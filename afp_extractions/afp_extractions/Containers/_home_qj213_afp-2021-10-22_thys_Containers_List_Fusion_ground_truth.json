{"file_name": "/home/qj213/afp-2021-10-22/thys/Containers/List_Fusion.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Containers", "problem_names": ["lemma Option_map_mono [partial_function_mono]:\n  \"mono_option f \\<Longrightarrow> mono_option (\\<lambda>x. map_option g (f x))\"", "lemma list_all2_coinduct [consumes 1, case_names Nil Cons, case_conclusion Cons hd tl, coinduct pred: list_all2]:\n  assumes X: \"X xs ys\"\n  and Nil': \"\\<And>xs ys. X xs ys \\<Longrightarrow> xs = [] \\<longleftrightarrow> ys = []\"\n  and Cons': \"\\<And>xs ys. \\<lbrakk> X xs ys; xs \\<noteq> []; ys \\<noteq> [] \\<rbrakk> \\<Longrightarrow> A (hd xs) (hd ys) \\<and> (X (tl xs) (tl ys) \\<or> list_all2 A (tl xs) (tl ys))\"\n  shows \"list_all2 A xs ys\"", "lemma terminatesI [intro?]:\n  \"(\\<And>s. s \\<in> terminates_on g) \\<Longrightarrow> terminates g\"", "lemma terminatesD:\n  \"terminates g \\<Longrightarrow> s \\<in> terminates_on g\"", "lemma terminates_on_stop:\n  \"terminates_on (\\<lambda>_. False, next) = UNIV\"", "lemma wf_terminates:\n  assumes \"wf R\"\n  and step: \"\\<And>s. fst g s \\<Longrightarrow> (snd (snd g s), s) \\<in> R\"\n  shows \"terminates g\"", "lemma terminates_wfD:\n  assumes \"terminates g\"\n  shows \"wf {(snd (snd g s), s) | s . fst g s}\"", "lemma terminates_wfE:\n  assumes \"terminates g\"\n  obtains R where \"wf R\" \"\\<And>s. fst g s \\<Longrightarrow> (snd (snd g s), s) \\<in> R\"", "lemma terminates_on_conv_dom_terminates_within:\n  \"terminates_on g = dom terminates_within\"", "lemma terminates_within_unfold:\n  \"has_next s \\<Longrightarrow> \n  terminates_within (has_next, next) s = map_option (\\<lambda>n. n + 1) (terminates_within (has_next, next) (snd (next s)))\"", "lemma terminates_on_generator_eq_UNIV:\n  \"terminates_on (generator g) = UNIV\"", "lemma terminates_within_stop:\n  \"terminates_within (\\<lambda>_. False, next) s = Some 0\"", "lemma terminates_within_generator_neq_None:\n  \"terminates_within (generator g) s \\<noteq> None\"", "lemma unfoldr_simps:\n  \"has_next s \\<Longrightarrow> unfoldr s = fst (next s) # unfoldr (snd (next s))\"\n  \"\\<not> has_next s \\<Longrightarrow> unfoldr s = []\"", "lemma generator_has_next_transfer [transfer_rule]: \n  \"(pcr_generator (=) (=) ===> (=)) fst list.has_next\"", "lemma generator_next_transfer [transfer_rule]:\n  \"(pcr_generator (=) (=) ===> (=)) snd list.next\"", "lemma unfoldr_eq_Nil_iff [iff]:\n  \"list.unfoldr g s = [] \\<longleftrightarrow> \\<not> list.has_next g s\"", "lemma Nil_eq_unfoldr_iff [simp]:\n  \"[] = list.unfoldr g s \\<longleftrightarrow> \\<not> list.has_next g s\"", "lemma terminates_list_generator: \"terminates (list_has_next, list_next)\"", "lemma has_next_list_generator [simp]: \n  \"list.has_next list_generator = list_has_next\"", "lemma next_list_generator [simp]: \n  \"list.next list_generator = list_next\"", "lemma unfoldr_list_generator:\n  \"list.unfoldr list_generator xs = xs\"", "lemma terminates_replicate_generator:\n  \"terminates (\\<lambda>n :: nat. 0 < n, \\<lambda>n. (a, n - 1))\"", "lemma has_next_replicate_generator [simp]:\n  \"list.has_next (replicate_generator a) n \\<longleftrightarrow> 0 < n\"", "lemma next_replicate_generator [simp]:\n  \"list.next (replicate_generator a) n = (a, n - 1)\"", "lemma unfoldr_replicate_generator:\n  \"list.unfoldr (replicate_generator a) n = replicate n a\"", "lemma has_next_map_generator [simp]:\n  \"list.has_next (map_generator g) = list.has_next g\"", "lemma next_map_generator [simp]:\n  \"list.next (map_generator g) = apfst f \\<circ> list.next g\"", "lemma unfoldr_map_generator:\n  \"list.unfoldr (map_generator g) = map f \\<circ> list.unfoldr g\"\n  (is \"?lhs = ?rhs\")", "lemma has_next_append_generator [simp]:\n  \"list.has_next (append_generator g1 g2) (Inl (s1, s2)) \\<longleftrightarrow>\n   list.has_next g1 s1 \\<or> list.has_next g2 s2\"\n  \"list.has_next (append_generator g1 g2) (Inr s2) \\<longleftrightarrow> list.has_next g2 s2\"", "lemma next_append_generator [simp]:\n  \"list.next (append_generator g1 g2) (Inl (s1, s2)) =\n  (if list.has_next g1 s1 then \n     let (x, s1') = list.next g1 s1 in (x, Inl (s1', s2))\n   else list.next (append_generator g1 g2) (Inr s2))\"\n  \"list.next (append_generator g1 g2) (Inr s2) = apsnd Inr (list.next g2 s2)\"", "lemma unfoldr_append_generator_Inr: \n  \"list.unfoldr (append_generator g1 g2) (Inr s2) = list.unfoldr g2 s2\"", "lemma unfoldr_append_generator_Inl:\n  \"list.unfoldr (append_generator g1 g2) (Inl (s1, s2)) = \n   list.unfoldr g1 s1 @ list.unfoldr g2 s2\"", "lemma unfoldr_append_generator:\n  \"list.unfoldr (append_generator g1 g2) (append_init s1 s2) =\n   list.unfoldr g1 s1 @ list.unfoldr g2 s2\"", "lemma has_next_zip_generator [simp]: \n  \"list.has_next (zip_generator g1 g2) (s1, s2) \\<longleftrightarrow> \n   list.has_next g1 s1 \\<and> list.has_next g2 s2\"", "lemma next_zip_generator [simp]: \n  \"list.next (zip_generator g1 g2) (s1, s2) = \n  ((fst (list.next g1 s1), fst (list.next g2 s2)), \n   (snd (list.next g1 s1), snd (list.next g2 s2)))\"", "lemma unfoldr_zip_generator:\n  \"list.unfoldr (zip_generator g1 g2) (zip_init s1 s2) = \n   zip (list.unfoldr g1 s1) (list.unfoldr g2 s2)\"", "lemma has_next_upt_generator [simp]:\n  \"list.has_next upt_generator n \\<longleftrightarrow> n < bound\"", "lemma next_upt_generator [simp]:\n  \"list.next upt_generator n = (n, Suc n)\"", "lemma unfoldr_upt_generator:\n  \"list.unfoldr upt_generator n = [n..<bound]\"", "lemma has_next_upto_generator [simp]:\n  \"list.has_next upto_generator n \\<longleftrightarrow> n \\<le> bound\"", "lemma next_upto_generator [simp]:\n  \"list.next upto_generator n = (n, n + 1)\"", "lemma unfoldr_upto_generator:\n  \"list.unfoldr upto_generator n = [n..bound]\"", "lemma has_next_filter_generator:\n  \"list.has_next (filter_generator g) s \\<longleftrightarrow>\n  list.has_next g s \\<and> (let (x, s') = list.next g s in if P x then True else list.has_next (filter_generator g) s')\"", "lemma next_filter_generator:\n   \"list.next (filter_generator g) s =\n   (let (x, s') = list.next g s\n    in if P x then (x, s') else list.next (filter_generator g) s')\"", "lemma has_next_filter_generator_induct [consumes 1, case_names find step]:\n  assumes \"list.has_next (filter_generator g) s\"\n  and find: \"\\<And>s. \\<lbrakk> list.has_next g s; P (fst (list.next g s)) \\<rbrakk> \\<Longrightarrow> Q s\"\n  and step: \"\\<And>s. \\<lbrakk> list.has_next g s; \\<not> P (fst (list.next g s)); Q (snd (list.next g s)) \\<rbrakk> \\<Longrightarrow> Q s\"\n  shows \"Q s\"", "lemma filter_generator_empty_conv:\n  \"list.has_next (filter_generator g) s \\<longleftrightarrow> (\\<exists>x\\<in>set (list.unfoldr g s). P x)\" (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma unfoldr_filter_generator:\n  \"list.unfoldr (filter_generator g) s = filter P (list.unfoldr g s)\"", "lemma hd_fusion_code [code]:\n  \"hd_fusion g s = (if list.has_next g s then fst (list.next g s) else undefined)\"", "lemma fold_fusion_code [code]:\n  \"fold_fusion g f s b =\n  (if list.has_next g s then\n     let (x, s') = list.next g s\n     in fold_fusion g f s' (f x b)\n   else b)\"", "lemma gen_length_fusion_code [code]:\n  \"gen_length_fusion g n s =\n  (if list.has_next g s then gen_length_fusion g (Suc n) (snd (list.next g s)) else n)\"", "lemma length_fusion_code [code]:\n  \"length_fusion g = gen_length_fusion g 0\"", "lemma map_fusion_code [code]:\n  \"map_fusion f g s =\n  (if list.has_next g s then\n     let (x, s') = list.next g s\n     in f x # map_fusion f g s'\n   else [])\"", "lemma append_fusion [code]:\n  \"append_fusion g1 g2 s1 s2 =\n  (if list.has_next g1 s1 then\n     let (x, s1') = list.next g1 s1\n     in x # append_fusion g1 g2 s1' s2\n   else list.unfoldr g2 s2)\"", "lemma zip_fusion_code [code]:\n  \"zip_fusion g1 g2 s1 s2 =\n  (if list.has_next g1 s1 \\<and> list.has_next g2 s2 then\n     let (x, s1') = list.next g1 s1;\n         (y, s2') = list.next g2 s2\n     in (x, y) # zip_fusion g1 g2 s1' s2'\n   else [])\"", "lemma list_all_fusion_code [code]:\n  \"list_all_fusion g P s \\<longleftrightarrow>\n  (list.has_next g s \\<longrightarrow>\n   (let (x, s') = list.next g s\n    in P x \\<and> list_all_fusion g P s'))\"", "lemma list_all2_fusion_code [code]:\n  \"list_all2_fusion P g1 g2 s1 s2 =\n  (if list.has_next g1 s1 then\n     list.has_next g2 s2 \\<and>\n     (let (x, s1') = list.next g1 s1;\n          (y, s2') = list.next g2 s2\n      in P x y \\<and> list_all2_fusion P g1 g2 s1' s2')\n   else \\<not> list.has_next g2 s2)\"", "lemma singleton_list_fusion_code [code]:\n  \"singleton_list_fusion g s \\<longleftrightarrow>\n  list.has_next g s \\<and> \\<not> list.has_next g (snd (list.next g s))\""], "translations": [["", "lemma Option_map_mono [partial_function_mono]:\n  \"mono_option f \\<Longrightarrow> mono_option (\\<lambda>x. map_option g (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone option.le_fun option_ord f \\<Longrightarrow>\n    monotone option.le_fun option_ord (\\<lambda>x. map_option g (f x))", "apply(rule monotoneI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>monotone option.le_fun option_ord f;\n        option.le_fun x y\\<rbrakk>\n       \\<Longrightarrow> option_ord (map_option g (f x))\n                          (map_option g (f y))", "apply(drule (1) monotoneD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>option.le_fun x y; option_ord (f x) (f y)\\<rbrakk>\n       \\<Longrightarrow> option_ord (map_option g (f x))\n                          (map_option g (f y))", "apply(auto simp add: map_option_case flat_ord_def split: option.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma list_all2_coinduct [consumes 1, case_names Nil Cons, case_conclusion Cons hd tl, coinduct pred: list_all2]:\n  assumes X: \"X xs ys\"\n  and Nil': \"\\<And>xs ys. X xs ys \\<Longrightarrow> xs = [] \\<longleftrightarrow> ys = []\"\n  and Cons': \"\\<And>xs ys. \\<lbrakk> X xs ys; xs \\<noteq> []; ys \\<noteq> [] \\<rbrakk> \\<Longrightarrow> A (hd xs) (hd ys) \\<and> (X (tl xs) (tl ys) \\<or> list_all2 A (tl xs) (tl ys))\"\n  shows \"list_all2 A xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 A xs ys", "using X"], ["proof (prove)\nusing this:\n  X xs ys\n\ngoal (1 subgoal):\n 1. list_all2 A xs ys", "proof(induction xs arbitrary: ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys. X [] ys \\<Longrightarrow> list_all2 A [] ys\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys. X xs ys \\<Longrightarrow> list_all2 A xs ys;\n        X (a # xs) ys\\<rbrakk>\n       \\<Longrightarrow> list_all2 A (a # xs) ys", "case Nil"], ["proof (state)\nthis:\n  X [] ys\n\ngoal (2 subgoals):\n 1. \\<And>ys. X [] ys \\<Longrightarrow> list_all2 A [] ys\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys. X xs ys \\<Longrightarrow> list_all2 A xs ys;\n        X (a # xs) ys\\<rbrakk>\n       \\<Longrightarrow> list_all2 A (a # xs) ys", "from Nil'[OF this]"], ["proof (chain)\npicking this:\n  ([] = []) = (ys = [])", "show ?case"], ["proof (prove)\nusing this:\n  ([] = []) = (ys = [])\n\ngoal (1 subgoal):\n 1. list_all2 A [] ys", "by simp"], ["proof (state)\nthis:\n  list_all2 A [] ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys. X xs ys \\<Longrightarrow> list_all2 A xs ys;\n        X (a # xs) ys\\<rbrakk>\n       \\<Longrightarrow> list_all2 A (a # xs) ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys. X xs ys \\<Longrightarrow> list_all2 A xs ys;\n        X (a # xs) ys\\<rbrakk>\n       \\<Longrightarrow> list_all2 A (a # xs) ys", "case (Cons x xs)"], ["proof (state)\nthis:\n  X xs ?ys \\<Longrightarrow> list_all2 A xs ?ys\n  X (x # xs) ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys. X xs ys \\<Longrightarrow> list_all2 A xs ys;\n        X (a # xs) ys\\<rbrakk>\n       \\<Longrightarrow> list_all2 A (a # xs) ys", "from Nil'[OF Cons.prems] Cons'[OF Cons.prems] Cons.IH"], ["proof (chain)\npicking this:\n  (x # xs = []) = (ys = [])\n  \\<lbrakk>x # xs \\<noteq> []; ys \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> A (hd (x # xs)) (hd ys) \\<and>\n                    (X (tl (x # xs)) (tl ys) \\<or>\n                     list_all2 A (tl (x # xs)) (tl ys))\n  X xs ?ys \\<Longrightarrow> list_all2 A xs ?ys", "show ?case"], ["proof (prove)\nusing this:\n  (x # xs = []) = (ys = [])\n  \\<lbrakk>x # xs \\<noteq> []; ys \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> A (hd (x # xs)) (hd ys) \\<and>\n                    (X (tl (x # xs)) (tl ys) \\<or>\n                     list_all2 A (tl (x # xs)) (tl ys))\n  X xs ?ys \\<Longrightarrow> list_all2 A xs ?ys\n\ngoal (1 subgoal):\n 1. list_all2 A (x # xs) ys", "by(auto simp add: neq_Nil_conv)"], ["proof (state)\nthis:\n  list_all2 A (x # xs) ys\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The type of generators for finite lists\\<close>"], ["", "type_synonym ('a, 's) raw_generator = \"('s \\<Rightarrow> bool) \\<times> ('s \\<Rightarrow> 'a \\<times> 's)\""], ["", "inductive_set terminates_on :: \"('a, 's) raw_generator \\<Rightarrow> 's set\"\n  for g :: \"('a, 's) raw_generator\"\nwhere\n  stop: \"\\<not> fst g s \\<Longrightarrow> s \\<in> terminates_on g\"\n| unfold: \"\\<lbrakk> fst g s; snd (snd g s) \\<in> terminates_on g \\<rbrakk> \\<Longrightarrow> s \\<in> terminates_on g\""], ["", "definition terminates :: \"('a, 's) raw_generator \\<Rightarrow> bool\"\nwhere \"terminates g \\<longleftrightarrow> (terminates_on g = UNIV)\""], ["", "lemma terminatesI [intro?]:\n  \"(\\<And>s. s \\<in> terminates_on g) \\<Longrightarrow> terminates g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s. s \\<in> terminates_on g) \\<Longrightarrow> terminates g", "by(auto simp add: terminates_def)"], ["", "lemma terminatesD:\n  \"terminates g \\<Longrightarrow> s \\<in> terminates_on g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates g \\<Longrightarrow> s \\<in> terminates_on g", "by(auto simp add: terminates_def)"], ["", "lemma terminates_on_stop:\n  \"terminates_on (\\<lambda>_. False, next) = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates_on (\\<lambda>_. False, next) = UNIV", "by(auto intro: terminates_on.stop)"], ["", "lemma wf_terminates:\n  assumes \"wf R\"\n  and step: \"\\<And>s. fst g s \\<Longrightarrow> (snd (snd g s), s) \\<in> R\"\n  shows \"terminates g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates g", "proof(rule terminatesI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on g", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on g", "from \\<open>wf R\\<close>"], ["proof (chain)\npicking this:\n  wf R", "show \"s \\<in> terminates_on g\""], ["proof (prove)\nusing this:\n  wf R\n\ngoal (1 subgoal):\n 1. s \\<in> terminates_on g", "proof(induction rule: wf_induct[rule_format, consumes 1, case_names wf])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           (y, x) \\<in> R \\<Longrightarrow>\n           y \\<in> terminates_on g) \\<Longrightarrow>\n       x \\<in> terminates_on g", "case (wf s)"], ["proof (state)\nthis:\n  (?y, s) \\<in> R \\<Longrightarrow> ?y \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           (y, x) \\<in> R \\<Longrightarrow>\n           y \\<in> terminates_on g) \\<Longrightarrow>\n       x \\<in> terminates_on g", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> terminates_on g", "proof(cases \"fst g s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. fst g s \\<Longrightarrow> s \\<in> terminates_on g\n 2. \\<not> fst g s \\<Longrightarrow> s \\<in> terminates_on g", "case True"], ["proof (state)\nthis:\n  fst g s\n\ngoal (2 subgoals):\n 1. fst g s \\<Longrightarrow> s \\<in> terminates_on g\n 2. \\<not> fst g s \\<Longrightarrow> s \\<in> terminates_on g", "hence \"(snd (snd g s), s) \\<in> R\""], ["proof (prove)\nusing this:\n  fst g s\n\ngoal (1 subgoal):\n 1. (snd (snd g s), s) \\<in> R", "by(rule step)"], ["proof (state)\nthis:\n  (snd (snd g s), s) \\<in> R\n\ngoal (2 subgoals):\n 1. fst g s \\<Longrightarrow> s \\<in> terminates_on g\n 2. \\<not> fst g s \\<Longrightarrow> s \\<in> terminates_on g", "hence \"snd (snd g s) \\<in> terminates_on g\""], ["proof (prove)\nusing this:\n  (snd (snd g s), s) \\<in> R\n\ngoal (1 subgoal):\n 1. snd (snd g s) \\<in> terminates_on g", "by(rule wf.IH)"], ["proof (state)\nthis:\n  snd (snd g s) \\<in> terminates_on g\n\ngoal (2 subgoals):\n 1. fst g s \\<Longrightarrow> s \\<in> terminates_on g\n 2. \\<not> fst g s \\<Longrightarrow> s \\<in> terminates_on g", "with True"], ["proof (chain)\npicking this:\n  fst g s\n  snd (snd g s) \\<in> terminates_on g", "show ?thesis"], ["proof (prove)\nusing this:\n  fst g s\n  snd (snd g s) \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. s \\<in> terminates_on g", "by(rule terminates_on.unfold)"], ["proof (state)\nthis:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. \\<not> fst g s \\<Longrightarrow> s \\<in> terminates_on g", "qed(rule terminates_on.stop)"], ["proof (state)\nthis:\n  s \\<in> terminates_on g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<in> terminates_on g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma terminates_wfD:\n  assumes \"terminates g\"\n  shows \"wf {(snd (snd g s), s) | s . fst g s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf {(snd (snd g s), s) |s. fst g s}", "proof(rule wfUNIVI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P x.\n       \\<forall>x.\n          (\\<forall>y.\n              (y, x)\n              \\<in> {(snd (snd g s), s) |s. fst g s} \\<longrightarrow>\n              P y) \\<longrightarrow>\n          P x \\<Longrightarrow>\n       P x", "fix thesis s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P x.\n       \\<forall>x.\n          (\\<forall>y.\n              (y, x)\n              \\<in> {(snd (snd g s), s) |s. fst g s} \\<longrightarrow>\n              P y) \\<longrightarrow>\n          P x \\<Longrightarrow>\n       P x", "assume wf [rule_format]: \"\\<forall>s. (\\<forall>s'. (s', s) \\<in> {(snd (snd g s), s) |s. fst g s} \\<longrightarrow> thesis s') \\<longrightarrow> thesis s\""], ["proof (state)\nthis:\n  (\\<And>s'.\n      (s', ?s) \\<in> {(snd (snd g s), s) |s. fst g s} \\<Longrightarrow>\n      thesis s') \\<Longrightarrow>\n  thesis ?s\n\ngoal (1 subgoal):\n 1. \\<And>P x.\n       \\<forall>x.\n          (\\<forall>y.\n              (y, x)\n              \\<in> {(snd (snd g s), s) |s. fst g s} \\<longrightarrow>\n              P y) \\<longrightarrow>\n          P x \\<Longrightarrow>\n       P x", "from assms"], ["proof (chain)\npicking this:\n  terminates g", "have \"s \\<in> terminates_on g\""], ["proof (prove)\nusing this:\n  terminates g\n\ngoal (1 subgoal):\n 1. s \\<in> terminates_on g", "by(auto simp add: terminates_def)"], ["proof (state)\nthis:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. \\<And>P x.\n       \\<forall>x.\n          (\\<forall>y.\n              (y, x)\n              \\<in> {(snd (snd g s), s) |s. fst g s} \\<longrightarrow>\n              P y) \\<longrightarrow>\n          P x \\<Longrightarrow>\n       P x", "thus \"thesis s\""], ["proof (prove)\nusing this:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. thesis s", "by induct (auto intro: wf)"], ["proof (state)\nthis:\n  thesis s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma terminates_wfE:\n  assumes \"terminates g\"\n  obtains R where \"wf R\" \"\\<And>s. fst g s \\<Longrightarrow> (snd (snd g s), s) \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>wf R;\n         \\<And>s.\n            fst g s \\<Longrightarrow> (snd (snd g s), s) \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule that)(rule terminates_wfD[OF assms], simp)"], ["", "context fixes g :: \"('a, 's) raw_generator\" begin"], ["", "partial_function (option) terminates_within :: \"'s \\<Rightarrow> nat option\"\nwhere\n  \"terminates_within s =\n   (let (has_next, next) = g\n    in if has_next s then \n          map_option (\\<lambda>n. n + 1) (terminates_within (snd (next s))) \n       else Some 0)\""], ["", "lemma terminates_on_conv_dom_terminates_within:\n  \"terminates_on g = dom terminates_within\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates_on g = dom local.terminates_within", "proof(safe)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> terminates_on g \\<Longrightarrow>\n       \\<exists>y. local.terminates_within x = Some y\n 2. \\<And>x y.\n       local.terminates_within x = Some y \\<Longrightarrow>\n       x \\<in> terminates_on g", "fix s"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> terminates_on g \\<Longrightarrow>\n       \\<exists>y. local.terminates_within x = Some y\n 2. \\<And>x y.\n       local.terminates_within x = Some y \\<Longrightarrow>\n       x \\<in> terminates_on g", "assume \"s \\<in> terminates_on g\""], ["proof (state)\nthis:\n  s \\<in> terminates_on g\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> terminates_on g \\<Longrightarrow>\n       \\<exists>y. local.terminates_within x = Some y\n 2. \\<And>x y.\n       local.terminates_within x = Some y \\<Longrightarrow>\n       x \\<in> terminates_on g", "then"], ["proof (chain)\npicking this:\n  s \\<in> terminates_on g", "show \"\\<exists>n. terminates_within s = Some n\""], ["proof (prove)\nusing this:\n  s \\<in> terminates_on g\n\ngoal (1 subgoal):\n 1. \\<exists>n. local.terminates_within s = Some n", "by(induct)(subst terminates_within.simps, simp add: split_beta)+"], ["proof (state)\nthis:\n  \\<exists>n. local.terminates_within s = Some n\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       local.terminates_within x = Some y \\<Longrightarrow>\n       x \\<in> terminates_on g", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       local.terminates_within x = Some y \\<Longrightarrow>\n       x \\<in> terminates_on g", "fix s n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       local.terminates_within x = Some y \\<Longrightarrow>\n       x \\<in> terminates_on g", "assume \"terminates_within s = Some n\""], ["proof (state)\nthis:\n  local.terminates_within s = Some n\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       local.terminates_within x = Some y \\<Longrightarrow>\n       x \\<in> terminates_on g", "then"], ["proof (chain)\npicking this:\n  local.terminates_within s = Some n", "show \"s \\<in> terminates_on g\""], ["proof (prove)\nusing this:\n  local.terminates_within s = Some n\n\ngoal (1 subgoal):\n 1. s \\<in> terminates_on g", "by(induct rule: terminates_within.raw_induct[rotated 1, consumes 1])(auto simp add: split_beta split: if_split_asm intro: terminates_on.intros)"], ["proof (state)\nthis:\n  s \\<in> terminates_on g\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma terminates_within_unfold:\n  \"has_next s \\<Longrightarrow> \n  terminates_within (has_next, next) s = map_option (\\<lambda>n. n + 1) (terminates_within (has_next, next) (snd (next s)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_next s \\<Longrightarrow>\n    terminates_within (has_next, next) s =\n    map_option (\\<lambda>n. n + 1)\n     (terminates_within (has_next, next) (snd (next s)))", "by(simp add: terminates_within.simps)"], ["", "typedef ('a, 's) generator = \"{g :: ('a, 's) raw_generator. terminates g}\"\n  morphisms generator Generator"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {g. terminates g}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. ?x \\<in> {g. terminates g}", "show \"(\\<lambda>_. False, undefined) \\<in> ?generator\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>_. False, undefined) \\<in> {g. terminates g}", "by(simp add: terminates_on_stop terminates_def)"], ["proof (state)\nthis:\n  (\\<lambda>_. False, undefined) \\<in> {g. terminates g}\n\ngoal:\nNo subgoals!", "qed"], ["", "setup_lifting type_definition_generator"], ["", "lemma terminates_on_generator_eq_UNIV:\n  \"terminates_on (generator g) = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates_on (generator g) = UNIV", "by transfer(simp add: terminates_def)"], ["", "lemma terminates_within_stop:\n  \"terminates_within (\\<lambda>_. False, next) s = Some 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates_within (\\<lambda>_. False, next) s = Some 0", "by(simp add: terminates_within.simps)"], ["", "lemma terminates_within_generator_neq_None:\n  \"terminates_within (generator g) s \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates_within (generator g) s \\<noteq> None", "by(transfer)(auto simp add: terminates_def terminates_on_conv_dom_terminates_within)"], ["", "locale list = \n  fixes g :: \"('a, 's) generator\" begin"], ["", "definition has_next :: \"'s \\<Rightarrow> bool\"\nwhere \"has_next = fst (generator g)\""], ["", "definition \"next\" :: \"'s \\<Rightarrow> 'a \\<times> 's\"\nwhere \"next = snd (generator g)\""], ["", "function unfoldr :: \"'s \\<Rightarrow> 'a list\"\nwhere \"unfoldr s = (if has_next s then let (a, s') = next s in a # unfoldr s' else [])\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x. (\\<And>s. x = s \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>s sa.\n       s = sa \\<Longrightarrow>\n       (if has_next s then let (a, s') = next s in a # unfoldr_sumC s'\n        else []) =\n       (if has_next sa then let (a, s') = next sa in a # unfoldr_sumC s'\n        else [])", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All unfoldr_dom", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. All unfoldr_dom", "have \"terminates (generator g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates (generator g)", "using generator[of g]"], ["proof (prove)\nusing this:\n  generator g \\<in> {g. terminates g}\n\ngoal (1 subgoal):\n 1. terminates (generator g)", "by simp"], ["proof (state)\nthis:\n  terminates (generator g)\n\ngoal (1 subgoal):\n 1. All unfoldr_dom", "thus ?thesis"], ["proof (prove)\nusing this:\n  terminates (generator g)\n\ngoal (1 subgoal):\n 1. All unfoldr_dom", "by(rule terminates_wfE)(erule \"termination\", metis has_next_def next_def snd_conv)"], ["proof (state)\nthis:\n  All unfoldr_dom\n\ngoal:\nNo subgoals!", "qed"], ["", "declare unfoldr.simps [simp del]"], ["", "lemma unfoldr_simps:\n  \"has_next s \\<Longrightarrow> unfoldr s = fst (next s) # unfoldr (snd (next s))\"\n  \"\\<not> has_next s \\<Longrightarrow> unfoldr s = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (has_next s \\<Longrightarrow>\n     unfoldr s = fst (next s) # unfoldr (snd (next s))) &&&\n    (\\<not> has_next s \\<Longrightarrow> unfoldr s = [])", "by(simp_all add: unfoldr.simps split_beta)"], ["", "end"], ["", "declare \n  list.has_next_def[code]\n  list.next_def[code]\n  list.unfoldr.simps[code]"], ["", "context includes lifting_syntax\nbegin"], ["", "lemma generator_has_next_transfer [transfer_rule]: \n  \"(pcr_generator (=) (=) ===> (=)) fst list.has_next\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pcr_generator (=) (=) ===> (=)) fst list.has_next", "by(auto simp add: generator.pcr_cr_eq cr_generator_def list.has_next_def dest: sym)"], ["", "lemma generator_next_transfer [transfer_rule]:\n  \"(pcr_generator (=) (=) ===> (=)) snd list.next\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pcr_generator (=) (=) ===> (=)) snd list.next", "by(auto simp add: generator.pcr_cr_eq cr_generator_def list.next_def)"], ["", "end"], ["", "lemma unfoldr_eq_Nil_iff [iff]:\n  \"list.unfoldr g s = [] \\<longleftrightarrow> \\<not> list.has_next g s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list.unfoldr g s = []) = (\\<not> list.has_next g s)", "by(subst list.unfoldr.simps)(simp add: split_beta)"], ["", "lemma Nil_eq_unfoldr_iff [simp]:\n  \"[] = list.unfoldr g s \\<longleftrightarrow> \\<not> list.has_next g s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([] = list.unfoldr g s) = (\\<not> list.has_next g s)", "by(auto intro: sym dest: sym)"], ["", "subsection \\<open>Generators for @{typ \"'a list\"}\\<close>"], ["", "primrec list_has_next :: \"'a list \\<Rightarrow> bool\"\nwhere\n  \"list_has_next [] \\<longleftrightarrow> False\"\n| \"list_has_next (x # xs) \\<longleftrightarrow> True\""], ["", "primrec list_next :: \"'a list \\<Rightarrow> 'a \\<times> 'a list\"\nwhere\n  \"list_next (x # xs) = (x, xs)\""], ["", "lemma terminates_list_generator: \"terminates (list_has_next, list_next)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates (list_has_next, list_next)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (list_has_next, list_next)", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (list_has_next, list_next)", "show \"xs \\<in> terminates_on (list_has_next, list_next)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> terminates_on (list_has_next, list_next)", "by(induct xs)(auto intro: terminates_on.intros)"], ["proof (state)\nthis:\n  xs \\<in> terminates_on (list_has_next, list_next)\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition list_generator :: \"('a, 'a list) generator\" \n  is \"(list_has_next, list_next)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates (list_has_next, list_next)", "by(rule terminates_list_generator)"], ["", "lemma has_next_list_generator [simp]: \n  \"list.has_next list_generator = list_has_next\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.has_next list_generator = list_has_next", "by transfer simp"], ["", "lemma next_list_generator [simp]: \n  \"list.next list_generator = list_next\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.next list_generator = list_next", "by transfer simp"], ["", "lemma unfoldr_list_generator:\n  \"list.unfoldr list_generator xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.unfoldr list_generator xs = xs", "by(induct xs)(simp_all add: list.unfoldr_simps)"], ["", "lemma terminates_replicate_generator:\n  \"terminates (\\<lambda>n :: nat. 0 < n, \\<lambda>n. (a, n - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates ((<) 0, \\<lambda>n. (a, n - 1))", "by(rule wf_terminates)(lexicographic_order)"], ["", "lift_definition replicate_generator :: \"'a \\<Rightarrow> ('a, nat) generator\"\n  is \"\\<lambda>a. (\\<lambda>n. 0 < n, \\<lambda>n. (a, n - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. terminates ((<) 0, \\<lambda>n. (a, n - 1))", "by(rule terminates_replicate_generator)"], ["", "lemma has_next_replicate_generator [simp]:\n  \"list.has_next (replicate_generator a) n \\<longleftrightarrow> 0 < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.has_next (replicate_generator a) n = (0 < n)", "by transfer simp"], ["", "lemma next_replicate_generator [simp]:\n  \"list.next (replicate_generator a) n = (a, n - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.next (replicate_generator a) n = (a, n - 1)", "by transfer simp"], ["", "lemma unfoldr_replicate_generator:\n  \"list.unfoldr (replicate_generator a) n = replicate n a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.unfoldr (replicate_generator a) n = replicate n a", "by(induct n)(simp_all add: list.unfoldr_simps)"], ["", "context fixes f :: \"'a \\<Rightarrow> 'b\" begin"], ["", "lift_definition map_generator :: \"('a, 's) generator \\<Rightarrow> ('b, 's) generator\"\n  is \"\\<lambda>(has_next, next). (has_next, \\<lambda>s. let (a, s') = next s in (f a, s'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>prod.\n       terminates prod \\<Longrightarrow>\n       terminates\n        (case prod of\n         (has_next, next) \\<Rightarrow>\n           (has_next, \\<lambda>s. let (a, y) = next s in (f a, y)))", "by(erule terminates_wfE)(erule wf_terminates, auto simp add: split_beta)"], ["", "lemma has_next_map_generator [simp]:\n  \"list.has_next (map_generator g) = list.has_next g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.has_next (local.map_generator g) = list.has_next g", "by transfer clarsimp"], ["", "lemma next_map_generator [simp]:\n  \"list.next (map_generator g) = apfst f \\<circ> list.next g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.next (local.map_generator g) = apfst f \\<circ> list.next g", "by transfer(simp add: fun_eq_iff split_beta apfst_def map_prod_def)"], ["", "lemma unfoldr_map_generator:\n  \"list.unfoldr (map_generator g) = map f \\<circ> list.unfoldr g\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. list.unfoldr (local.map_generator g) = map f \\<circ> list.unfoldr g", "proof(rule ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       list.unfoldr (local.map_generator g) x =\n       (map f \\<circ> list.unfoldr g) x", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       list.unfoldr (local.map_generator g) x =\n       (map f \\<circ> list.unfoldr g) x", "show \"?lhs s = ?rhs s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.unfoldr (local.map_generator g) s =\n    (map f \\<circ> list.unfoldr g) s", "by(induct s taking: \"map_generator g\" rule: list.unfoldr.induct)\n      (subst (1 2) list.unfoldr.simps, auto simp add: split_beta apfst_def map_prod_def)"], ["proof (state)\nthis:\n  list.unfoldr (local.map_generator g) s = (map f \\<circ> list.unfoldr g) s\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context fixes g1 :: \"('a, 's1) raw_generator\"\n  and g2 :: \"('a, 's2) raw_generator\" \nbegin"], ["", "fun append_has_next :: \"'s1 \\<times> 's2 + 's2 \\<Rightarrow> bool\"\nwhere\n  \"append_has_next (Inl (s1, s2)) \\<longleftrightarrow> fst g1 s1 \\<or> fst g2 s2\"\n| \"append_has_next (Inr s2) \\<longleftrightarrow> fst g2 s2\""], ["", "fun append_next :: \"'s1 \\<times> 's2 + 's2 \\<Rightarrow> 'a \\<times> ('s1 \\<times> 's2 + 's2)\"\nwhere\n  \"append_next (Inl (s1, s2)) = \n  (if fst g1 s1 then \n     let (x, s1') = snd g1 s1 in (x, Inl (s1', s2)) \n   else append_next (Inr s2))\"\n| \"append_next (Inr s2) = (let (x, s2') = snd g2 s2 in (x, Inr s2'))\""], ["", "end"], ["", "lift_definition append_generator :: \"('a, 's1) generator \\<Rightarrow> ('a, 's2) generator \\<Rightarrow> ('a, 's1 \\<times> 's2 + 's2) generator\"\n  is \"\\<lambda>g1 g2. (append_has_next g1 g2, append_next g1 g2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>prod1 prod2.\n       \\<lbrakk>terminates prod1; terminates prod2\\<rbrakk>\n       \\<Longrightarrow> terminates\n                          (append_has_next prod1 prod2,\n                           append_next prod1 prod2)", "proof(rule terminatesI, safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba s.\n       \\<lbrakk>terminates (a, b); terminates (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> s \\<in> terminates_on\n                                  (append_has_next (a, b) (aa, ba),\n                                   append_next (a, b) (aa, ba))", "fix has_next1 and next1 :: \"'s1 \\<Rightarrow> 'a \\<times> 's1\"\n    and has_next2 and next2 :: \"'s2 \\<Rightarrow> 'a \\<times> 's2\"\n    and s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba s.\n       \\<lbrakk>terminates (a, b); terminates (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> s \\<in> terminates_on\n                                  (append_has_next (a, b) (aa, ba),\n                                   append_next (a, b) (aa, ba))", "assume t1: \"terminates (has_next1, next1)\" \n    and t2: \"terminates (has_next2, next2)\""], ["proof (state)\nthis:\n  terminates (has_next1, next1)\n  terminates (has_next2, next2)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba s.\n       \\<lbrakk>terminates (a, b); terminates (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> s \\<in> terminates_on\n                                  (append_has_next (a, b) (aa, ba),\n                                   append_next (a, b) (aa, ba))", "let ?has_next = \"append_has_next (has_next1, next1) (has_next2, next2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba s.\n       \\<lbrakk>terminates (a, b); terminates (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> s \\<in> terminates_on\n                                  (append_has_next (a, b) (aa, ba),\n                                   append_next (a, b) (aa, ba))", "let ?next = \"append_next (has_next1, next1) (has_next2, next2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba s.\n       \\<lbrakk>terminates (a, b); terminates (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> s \\<in> terminates_on\n                                  (append_has_next (a, b) (aa, ba),\n                                   append_next (a, b) (aa, ba))", "note [simp] = split_beta\n    and [intro] = terminates_on.intros"], ["proof (state)\nthis:\n  (case ?prod of (x, xa) \\<Rightarrow> ?f x xa) = ?f (fst ?prod) (snd ?prod)\n  \\<not> fst ?g ?s \\<Longrightarrow> ?s \\<in> terminates_on ?g\n  \\<lbrakk>fst ?g ?s; snd (snd ?g ?s) \\<in> terminates_on ?g\\<rbrakk>\n  \\<Longrightarrow> ?s \\<in> terminates_on ?g\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba s.\n       \\<lbrakk>terminates (a, b); terminates (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> s \\<in> terminates_on\n                                  (append_has_next (a, b) (aa, ba),\n                                   append_next (a, b) (aa, ba))", "{"], ["proof (state)\nthis:\n  (case ?prod of (x, xa) \\<Rightarrow> ?f x xa) = ?f (fst ?prod) (snd ?prod)\n  \\<not> fst ?g ?s \\<Longrightarrow> ?s \\<in> terminates_on ?g\n  \\<lbrakk>fst ?g ?s; snd (snd ?g ?s) \\<in> terminates_on ?g\\<rbrakk>\n  \\<Longrightarrow> ?s \\<in> terminates_on ?g\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba s.\n       \\<lbrakk>terminates (a, b); terminates (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> s \\<in> terminates_on\n                                  (append_has_next (a, b) (aa, ba),\n                                   append_next (a, b) (aa, ba))", "fix s2 :: 's2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba s.\n       \\<lbrakk>terminates (a, b); terminates (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> s \\<in> terminates_on\n                                  (append_has_next (a, b) (aa, ba),\n                                   append_next (a, b) (aa, ba))", "from t2"], ["proof (chain)\npicking this:\n  terminates (has_next2, next2)", "have \"s2 \\<in> terminates_on (has_next2, next2)\""], ["proof (prove)\nusing this:\n  terminates (has_next2, next2)\n\ngoal (1 subgoal):\n 1. s2 \\<in> terminates_on (has_next2, next2)", "by(rule terminatesD)"], ["proof (state)\nthis:\n  s2 \\<in> terminates_on (has_next2, next2)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba s.\n       \\<lbrakk>terminates (a, b); terminates (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> s \\<in> terminates_on\n                                  (append_has_next (a, b) (aa, ba),\n                                   append_next (a, b) (aa, ba))", "hence \"Inr s2 \\<in> terminates_on (?has_next, ?next)\""], ["proof (prove)\nusing this:\n  s2 \\<in> terminates_on (has_next2, next2)\n\ngoal (1 subgoal):\n 1. Inr s2\n    \\<in> terminates_on\n           (append_has_next (has_next1, next1) (has_next2, next2),\n            append_next (has_next1, next1) (has_next2, next2))", "by induct auto"], ["proof (state)\nthis:\n  Inr s2\n  \\<in> terminates_on\n         (append_has_next (has_next1, next1) (has_next2, next2),\n          append_next (has_next1, next1) (has_next2, next2))\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba s.\n       \\<lbrakk>terminates (a, b); terminates (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> s \\<in> terminates_on\n                                  (append_has_next (a, b) (aa, ba),\n                                   append_next (a, b) (aa, ba))", "}"], ["proof (state)\nthis:\n  Inr ?s2.2\n  \\<in> terminates_on\n         (append_has_next (has_next1, next1) (has_next2, next2),\n          append_next (has_next1, next1) (has_next2, next2))\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba s.\n       \\<lbrakk>terminates (a, b); terminates (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> s \\<in> terminates_on\n                                  (append_has_next (a, b) (aa, ba),\n                                   append_next (a, b) (aa, ba))", "note Inr' = this"], ["proof (state)\nthis:\n  Inr ?s2.2\n  \\<in> terminates_on\n         (append_has_next (has_next1, next1) (has_next2, next2),\n          append_next (has_next1, next1) (has_next2, next2))\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba s.\n       \\<lbrakk>terminates (a, b); terminates (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> s \\<in> terminates_on\n                                  (append_has_next (a, b) (aa, ba),\n                                   append_next (a, b) (aa, ba))", "show \"s \\<in> terminates_on (?has_next, ?next)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> terminates_on\n             (append_has_next (has_next1, next1) (has_next2, next2),\n              append_next (has_next1, next1) (has_next2, next2))", "proof(cases s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       s = Inl a \\<Longrightarrow>\n       s \\<in> terminates_on\n                (append_has_next (has_next1, next1) (has_next2, next2),\n                 append_next (has_next1, next1) (has_next2, next2))\n 2. \\<And>b.\n       s = Inr b \\<Longrightarrow>\n       s \\<in> terminates_on\n                (append_has_next (has_next1, next1) (has_next2, next2),\n                 append_next (has_next1, next1) (has_next2, next2))", "case Inr"], ["proof (state)\nthis:\n  s = Inr b_\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       s = Inl a \\<Longrightarrow>\n       s \\<in> terminates_on\n                (append_has_next (has_next1, next1) (has_next2, next2),\n                 append_next (has_next1, next1) (has_next2, next2))\n 2. \\<And>b.\n       s = Inr b \\<Longrightarrow>\n       s \\<in> terminates_on\n                (append_has_next (has_next1, next1) (has_next2, next2),\n                 append_next (has_next1, next1) (has_next2, next2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  s = Inr b_\n\ngoal (1 subgoal):\n 1. s \\<in> terminates_on\n             (append_has_next (has_next1, next1) (has_next2, next2),\n              append_next (has_next1, next1) (has_next2, next2))", "by(simp add: Inr')"], ["proof (state)\nthis:\n  s \\<in> terminates_on\n           (append_has_next (has_next1, next1) (has_next2, next2),\n            append_next (has_next1, next1) (has_next2, next2))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       s = Inl a \\<Longrightarrow>\n       s \\<in> terminates_on\n                (append_has_next (has_next1, next1) (has_next2, next2),\n                 append_next (has_next1, next1) (has_next2, next2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       s = Inl a \\<Longrightarrow>\n       s \\<in> terminates_on\n                (append_has_next (has_next1, next1) (has_next2, next2),\n                 append_next (has_next1, next1) (has_next2, next2))", "case (Inl s1s2)"], ["proof (state)\nthis:\n  s = Inl s1s2\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       s = Inl a \\<Longrightarrow>\n       s \\<in> terminates_on\n                (append_has_next (has_next1, next1) (has_next2, next2),\n                 append_next (has_next1, next1) (has_next2, next2))", "moreover"], ["proof (state)\nthis:\n  s = Inl s1s2\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       s = Inl a \\<Longrightarrow>\n       s \\<in> terminates_on\n                (append_has_next (has_next1, next1) (has_next2, next2),\n                 append_next (has_next1, next1) (has_next2, next2))", "obtain s1 s2 where \"s1s2 = (s1, s2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s1 s2.\n        s1s2 = (s1, s2) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s1s2)"], ["proof (state)\nthis:\n  s1s2 = (s1, s2)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       s = Inl a \\<Longrightarrow>\n       s \\<in> terminates_on\n                (append_has_next (has_next1, next1) (has_next2, next2),\n                 append_next (has_next1, next1) (has_next2, next2))", "ultimately"], ["proof (chain)\npicking this:\n  s = Inl s1s2\n  s1s2 = (s1, s2)", "have s: \"s = Inl (s1, s2)\""], ["proof (prove)\nusing this:\n  s = Inl s1s2\n  s1s2 = (s1, s2)\n\ngoal (1 subgoal):\n 1. s = Inl (s1, s2)", "by simp"], ["proof (state)\nthis:\n  s = Inl (s1, s2)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       s = Inl a \\<Longrightarrow>\n       s \\<in> terminates_on\n                (append_has_next (has_next1, next1) (has_next2, next2),\n                 append_next (has_next1, next1) (has_next2, next2))", "from t1"], ["proof (chain)\npicking this:\n  terminates (has_next1, next1)", "have \"s1 \\<in> terminates_on (has_next1, next1)\""], ["proof (prove)\nusing this:\n  terminates (has_next1, next1)\n\ngoal (1 subgoal):\n 1. s1 \\<in> terminates_on (has_next1, next1)", "by(rule terminatesD)"], ["proof (state)\nthis:\n  s1 \\<in> terminates_on (has_next1, next1)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       s = Inl a \\<Longrightarrow>\n       s \\<in> terminates_on\n                (append_has_next (has_next1, next1) (has_next2, next2),\n                 append_next (has_next1, next1) (has_next2, next2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  s1 \\<in> terminates_on (has_next1, next1)\n\ngoal (1 subgoal):\n 1. s \\<in> terminates_on\n             (append_has_next (has_next1, next1) (has_next2, next2),\n              append_next (has_next1, next1) (has_next2, next2))", "unfolding s"], ["proof (prove)\nusing this:\n  s1 \\<in> terminates_on (has_next1, next1)\n\ngoal (1 subgoal):\n 1. Inl (s1, s2)\n    \\<in> terminates_on\n           (append_has_next (has_next1, next1) (has_next2, next2),\n            append_next (has_next1, next1) (has_next2, next2))", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<not> fst (has_next1, next1) s \\<Longrightarrow>\n       Inl (s, s2)\n       \\<in> terminates_on\n              (append_has_next (has_next1, next1) (has_next2, next2),\n               append_next (has_next1, next1) (has_next2, next2))\n 2. \\<And>s.\n       \\<lbrakk>fst (has_next1, next1) s;\n        snd (snd (has_next1, next1) s)\n        \\<in> terminates_on (has_next1, next1);\n        Inl (snd (snd (has_next1, next1) s), s2)\n        \\<in> terminates_on\n               (append_has_next (has_next1, next1) (has_next2, next2),\n                append_next (has_next1, next1) (has_next2, next2))\\<rbrakk>\n       \\<Longrightarrow> Inl (s, s2)\n                         \\<in> terminates_on\n                                (append_has_next (has_next1, next1)\n                                  (has_next2, next2),\n                                 append_next (has_next1, next1)\n                                  (has_next2, next2))", "case stop"], ["proof (state)\nthis:\n  \\<not> fst (has_next1, next1) s_\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<not> fst (has_next1, next1) s \\<Longrightarrow>\n       Inl (s, s2)\n       \\<in> terminates_on\n              (append_has_next (has_next1, next1) (has_next2, next2),\n               append_next (has_next1, next1) (has_next2, next2))\n 2. \\<And>s.\n       \\<lbrakk>fst (has_next1, next1) s;\n        snd (snd (has_next1, next1) s)\n        \\<in> terminates_on (has_next1, next1);\n        Inl (snd (snd (has_next1, next1) s), s2)\n        \\<in> terminates_on\n               (append_has_next (has_next1, next1) (has_next2, next2),\n                append_next (has_next1, next1) (has_next2, next2))\\<rbrakk>\n       \\<Longrightarrow> Inl (s, s2)\n                         \\<in> terminates_on\n                                (append_has_next (has_next1, next1)\n                                  (has_next2, next2),\n                                 append_next (has_next1, next1)\n                                  (has_next2, next2))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<not> fst (has_next1, next1) s_\n\ngoal (1 subgoal):\n 1. Inl (s_, s2)\n    \\<in> terminates_on\n           (append_has_next (has_next1, next1) (has_next2, next2),\n            append_next (has_next1, next1) (has_next2, next2))", "by(cases \"has_next2 s2\")(auto simp add: Inr')"], ["proof (state)\nthis:\n  Inl (s_, s2)\n  \\<in> terminates_on\n         (append_has_next (has_next1, next1) (has_next2, next2),\n          append_next (has_next1, next1) (has_next2, next2))\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>fst (has_next1, next1) s;\n        snd (snd (has_next1, next1) s)\n        \\<in> terminates_on (has_next1, next1);\n        Inl (snd (snd (has_next1, next1) s), s2)\n        \\<in> terminates_on\n               (append_has_next (has_next1, next1) (has_next2, next2),\n                append_next (has_next1, next1) (has_next2, next2))\\<rbrakk>\n       \\<Longrightarrow> Inl (s, s2)\n                         \\<in> terminates_on\n                                (append_has_next (has_next1, next1)\n                                  (has_next2, next2),\n                                 append_next (has_next1, next1)\n                                  (has_next2, next2))", "qed auto"], ["proof (state)\nthis:\n  s \\<in> terminates_on\n           (append_has_next (has_next1, next1) (has_next2, next2),\n            append_next (has_next1, next1) (has_next2, next2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<in> terminates_on\n           (append_has_next (has_next1, next1) (has_next2, next2),\n            append_next (has_next1, next1) (has_next2, next2))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition append_init :: \"'s1 \\<Rightarrow> 's2 \\<Rightarrow> 's1 \\<times> 's2 + 's2\"\nwhere \"append_init s1 s2 = Inl (s1, s2)\""], ["", "lemma has_next_append_generator [simp]:\n  \"list.has_next (append_generator g1 g2) (Inl (s1, s2)) \\<longleftrightarrow>\n   list.has_next g1 s1 \\<or> list.has_next g2 s2\"\n  \"list.has_next (append_generator g1 g2) (Inr s2) \\<longleftrightarrow> list.has_next g2 s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.has_next (append_generator g1 g2) (Inl (s1, s2)) =\n    (list.has_next g1 s1 \\<or> list.has_next g2 s2) &&&\n    list.has_next (append_generator g1 g2) (Inr s2) = list.has_next g2 s2", "by(transfer, simp)+"], ["", "lemma next_append_generator [simp]:\n  \"list.next (append_generator g1 g2) (Inl (s1, s2)) =\n  (if list.has_next g1 s1 then \n     let (x, s1') = list.next g1 s1 in (x, Inl (s1', s2))\n   else list.next (append_generator g1 g2) (Inr s2))\"\n  \"list.next (append_generator g1 g2) (Inr s2) = apsnd Inr (list.next g2 s2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.next (append_generator g1 g2) (Inl (s1, s2)) =\n    (if list.has_next g1 s1\n     then let (x, s1') = list.next g1 s1 in (x, Inl (s1', s2))\n     else list.next (append_generator g1 g2) (Inr s2)) &&&\n    list.next (append_generator g1 g2) (Inr s2) =\n    apsnd Inr (list.next g2 s2)", "by(transfer, simp add: apsnd_def map_prod_def)+"], ["", "lemma unfoldr_append_generator_Inr: \n  \"list.unfoldr (append_generator g1 g2) (Inr s2) = list.unfoldr g2 s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.unfoldr (append_generator g1 g2) (Inr s2) = list.unfoldr g2 s2", "by(induct s2 taking: g2 rule: list.unfoldr.induct)(subst (1 2) list.unfoldr.simps, auto split: prod.splits)"], ["", "lemma unfoldr_append_generator_Inl:\n  \"list.unfoldr (append_generator g1 g2) (Inl (s1, s2)) = \n   list.unfoldr g1 s1 @ list.unfoldr g2 s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.unfoldr (append_generator g1 g2) (Inl (s1, s2)) =\n    list.unfoldr g1 s1 @ list.unfoldr g2 s2", "apply(induct s1 taking: g1 rule: list.unfoldr.induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       (\\<And>x xa y.\n           \\<lbrakk>list.has_next g1 s; x = list.next g1 s;\n            (xa, y) = x\\<rbrakk>\n           \\<Longrightarrow> list.unfoldr (append_generator g1 g2)\n                              (Inl (y, s2)) =\n                             list.unfoldr g1 y @\n                             list.unfoldr g2 s2) \\<Longrightarrow>\n       list.unfoldr (append_generator g1 g2) (Inl (s, s2)) =\n       list.unfoldr g1 s @ list.unfoldr g2 s2", "apply(subst (1 2 3) list.unfoldr.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       (\\<And>x xa y.\n           \\<lbrakk>list.has_next g1 s; x = list.next g1 s;\n            (xa, y) = x\\<rbrakk>\n           \\<Longrightarrow> list.unfoldr (append_generator g1 g2)\n                              (Inl (y, s2)) =\n                             list.unfoldr g1 y @\n                             list.unfoldr g2 s2) \\<Longrightarrow>\n       (if list.has_next (append_generator g1 g2) (Inl (s, s2))\n        then let (a, s') = list.next (append_generator g1 g2) (Inl (s, s2))\n             in a # list.unfoldr (append_generator g1 g2) s'\n        else []) =\n       (if list.has_next g1 s\n        then let (a, s') = list.next g1 s in a # list.unfoldr g1 s'\n        else []) @\n       (if list.has_next g2 s2\n        then let (a, s') = list.next g2 s2 in a # list.unfoldr g2 s'\n        else [])", "apply(auto split: prod.splits simp add: apsnd_def map_prod_def unfoldr_append_generator_Inr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s x1 x2.\n       \\<lbrakk>\\<And>a b xa y.\n                   \\<lbrakk>(a, b) = list.next g1 s;\n                    (xa, y) = list.next g1 s\\<rbrakk>\n                   \\<Longrightarrow> list.unfoldr (append_generator g1 g2)\n(Inl (y, s2)) =\n                                     list.unfoldr g1 y @ list.unfoldr g2 s2;\n        list.next g2 s2 = (x1, x2); list.has_next g2 s2;\n        list.has_next g1 s\\<rbrakk>\n       \\<Longrightarrow> list.unfoldr g2 s2 = x1 # list.unfoldr g2 x2", "apply(simp add: list.unfoldr_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma unfoldr_append_generator:\n  \"list.unfoldr (append_generator g1 g2) (append_init s1 s2) =\n   list.unfoldr g1 s1 @ list.unfoldr g2 s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.unfoldr (append_generator g1 g2) (append_init s1 s2) =\n    list.unfoldr g1 s1 @ list.unfoldr g2 s2", "by(simp add: unfoldr_append_generator_Inl append_init_def)"], ["", "lift_definition zip_generator :: \"('a, 's1) generator \\<Rightarrow> ('b, 's2) generator \\<Rightarrow> ('a \\<times> 'b, 's1 \\<times> 's2) generator\"\n  is \"\\<lambda>(has_next1, next1) (has_next2, next2). \n      (\\<lambda>(s1, s2). has_next1 s1 \\<and> has_next2 s2, \n       \\<lambda>(s1, s2). let (x, s1') = next1 s1; (y, s2') = next2 s2\n                  in ((x, y), (s1', s2')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>prod1 prod2.\n       \\<lbrakk>terminates prod1; terminates prod2\\<rbrakk>\n       \\<Longrightarrow> terminates\n                          ((case prod1 of\n                            (has_next1, next1) \\<Rightarrow>\n                              \\<lambda>(has_next2, next2).\n                                 (\\<lambda>(s1, s2).\n                                     has_next1 s1 \\<and> has_next2 s2,\n                                  \\<lambda>(s1, s2).\n                                     let (x, s1') = next1 s1;\n   (y, s2') = next2 s2\n                                     in ((x, y), s1', s2')))\n                            prod2)", "proof(rule terminatesI, safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>terminates (a, b); terminates (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> (ab, bb)\n                         \\<in> terminates_on\n                                (\\<lambda>(s1, s2). a s1 \\<and> aa s2,\n                                 \\<lambda>(s1, s2).\n                                    let (x, s1') = b s1; (y, s2') = ba s2\n                                    in ((x, y), s1', s2'))", "fix has_next1 next1 has_next2 next2 s1 s2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>terminates (a, b); terminates (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> (ab, bb)\n                         \\<in> terminates_on\n                                (\\<lambda>(s1, s2). a s1 \\<and> aa s2,\n                                 \\<lambda>(s1, s2).\n                                    let (x, s1') = b s1; (y, s2') = ba s2\n                                    in ((x, y), s1', s2'))", "assume t1: \"terminates (has_next1, next1)\" \n    and t2: \"terminates (has_next2, next2)\""], ["proof (state)\nthis:\n  terminates (has_next1, next1)\n  terminates (has_next2, next2)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>terminates (a, b); terminates (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> (ab, bb)\n                         \\<in> terminates_on\n                                (\\<lambda>(s1, s2). a s1 \\<and> aa s2,\n                                 \\<lambda>(s1, s2).\n                                    let (x, s1') = b s1; (y, s2') = ba s2\n                                    in ((x, y), s1', s2'))", "have \"s1 \\<in> terminates_on (has_next1, next1)\" \"s2 \\<in> terminates_on (has_next2, next2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s1 \\<in> terminates_on (has_next1, next1) &&&\n    s2 \\<in> terminates_on (has_next2, next2)", "using t1 t2"], ["proof (prove)\nusing this:\n  terminates (has_next1, next1)\n  terminates (has_next2, next2)\n\ngoal (1 subgoal):\n 1. s1 \\<in> terminates_on (has_next1, next1) &&&\n    s2 \\<in> terminates_on (has_next2, next2)", "by(simp_all add: terminatesD)"], ["proof (state)\nthis:\n  s1 \\<in> terminates_on (has_next1, next1)\n  s2 \\<in> terminates_on (has_next2, next2)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>terminates (a, b); terminates (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> (ab, bb)\n                         \\<in> terminates_on\n                                (\\<lambda>(s1, s2). a s1 \\<and> aa s2,\n                                 \\<lambda>(s1, s2).\n                                    let (x, s1') = b s1; (y, s2') = ba s2\n                                    in ((x, y), s1', s2'))", "thus \"(s1, s2) \\<in> terminates_on (\\<lambda>(s1, s2). has_next1 s1 \\<and> has_next2 s2, \\<lambda>(s1, s2). let (x, s1') = next1 s1; (y, s2') = next2 s2 in ((x, y), (s1', s2')))\""], ["proof (prove)\nusing this:\n  s1 \\<in> terminates_on (has_next1, next1)\n  s2 \\<in> terminates_on (has_next2, next2)\n\ngoal (1 subgoal):\n 1. (s1, s2)\n    \\<in> terminates_on\n           (\\<lambda>(s1, s2). has_next1 s1 \\<and> has_next2 s2,\n            \\<lambda>(s1, s2).\n               let (x, s1') = next1 s1; (y, s2') = next2 s2\n               in ((x, y), s1', s2'))", "by(induct arbitrary: s2)(auto 4 3 elim: terminates_on.cases intro: terminates_on.intros simp add: split_beta Let_def)"], ["proof (state)\nthis:\n  (s1, s2)\n  \\<in> terminates_on\n         (\\<lambda>(s1, s2). has_next1 s1 \\<and> has_next2 s2,\n          \\<lambda>(s1, s2).\n             let (x, s1') = next1 s1; (y, s2') = next2 s2\n             in ((x, y), s1', s2'))\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation (input) zip_init :: \"'s1 \\<Rightarrow> 's2 \\<Rightarrow> 's1 \\<times> 's2\"\nwhere \"zip_init \\<equiv> Pair\""], ["", "lemma has_next_zip_generator [simp]: \n  \"list.has_next (zip_generator g1 g2) (s1, s2) \\<longleftrightarrow> \n   list.has_next g1 s1 \\<and> list.has_next g2 s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.has_next (zip_generator g1 g2) (s1, s2) =\n    (list.has_next g1 s1 \\<and> list.has_next g2 s2)", "by transfer clarsimp"], ["", "lemma next_zip_generator [simp]: \n  \"list.next (zip_generator g1 g2) (s1, s2) = \n  ((fst (list.next g1 s1), fst (list.next g2 s2)), \n   (snd (list.next g1 s1), snd (list.next g2 s2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.next (zip_generator g1 g2) (s1, s2) =\n    ((fst (list.next g1 s1), fst (list.next g2 s2)), snd (list.next g1 s1),\n     snd (list.next g2 s2))", "by transfer(simp add: split_beta)"], ["", "lemma unfoldr_zip_generator:\n  \"list.unfoldr (zip_generator g1 g2) (zip_init s1 s2) = \n   zip (list.unfoldr g1 s1) (list.unfoldr g2 s2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.unfoldr (zip_generator g1 g2) (s1, s2) =\n    zip (list.unfoldr g1 s1) (list.unfoldr g2 s2)", "by(induct \"(s1, s2)\" arbitrary: s1 s2 taking: \"zip_generator g1 g2\" rule: list.unfoldr.induct)\n  (subst (1 2 3) list.unfoldr.simps, auto 9 2 simp add: split_beta)"], ["", "context fixes bound :: nat begin"], ["", "lift_definition upt_generator :: \"(nat, nat) generator\"\n  is \"(\\<lambda>n. n < bound, \\<lambda>n. (n, Suc n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates (\\<lambda>n. n < bound, \\<lambda>n. (n, Suc n))", "by(rule wf_terminates)(relation \"measure (\\<lambda>n. bound - n)\", auto)"], ["", "lemma has_next_upt_generator [simp]:\n  \"list.has_next upt_generator n \\<longleftrightarrow> n < bound\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.has_next local.upt_generator n = (n < bound)", "by transfer simp"], ["", "lemma next_upt_generator [simp]:\n  \"list.next upt_generator n = (n, Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.next local.upt_generator n = (n, Suc n)", "by transfer simp"], ["", "lemma unfoldr_upt_generator:\n  \"list.unfoldr upt_generator n = [n..<bound]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.unfoldr local.upt_generator n = [n..<bound]", "by(induct \"bound - n\" arbitrary: n)(simp_all add: list.unfoldr_simps upt_conv_Cons)"], ["", "end"], ["", "context fixes bound :: int begin"], ["", "lift_definition upto_generator :: \"(int, int) generator\"\n  is \"(\\<lambda>n. n \\<le> bound, \\<lambda>n. (n, n + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates (\\<lambda>n. n \\<le> bound, \\<lambda>n. (n, n + 1))", "by(rule wf_terminates)(relation \"measure (\\<lambda>n. nat (bound + 1 - n))\", auto)"], ["", "lemma has_next_upto_generator [simp]:\n  \"list.has_next upto_generator n \\<longleftrightarrow> n \\<le> bound\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.has_next local.upto_generator n = (n \\<le> bound)", "by transfer simp"], ["", "lemma next_upto_generator [simp]:\n  \"list.next upto_generator n = (n, n + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.next local.upto_generator n = (n, n + 1)", "by transfer simp"], ["", "lemma unfoldr_upto_generator:\n  \"list.unfoldr upto_generator n = [n..bound]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.unfoldr local.upto_generator n = [n..bound]", "by(induct n taking: upto_generator rule: list.unfoldr.induct)(subst list.unfoldr.simps, subst upto.simps, auto)"], ["", "end"], ["", "context\n  fixes P :: \"'a \\<Rightarrow> bool\"\nbegin"], ["", "context \n  fixes g :: \"('a, 's) raw_generator\"\nbegin"], ["", "inductive filter_has_next :: \"'s \\<Rightarrow> bool\"\nwhere\n  \"\\<lbrakk> fst g s; P (fst (snd g s)) \\<rbrakk> \\<Longrightarrow> filter_has_next s\"\n| \"\\<lbrakk> fst g s; \\<not> P (fst (snd g s)); filter_has_next (snd (snd g s)) \\<rbrakk> \\<Longrightarrow> filter_has_next s\""], ["", "partial_function (tailrec) filter_next :: \"'s \\<Rightarrow> 'a \\<times> 's\"\nwhere\n  \"filter_next s = (let (x, s') = snd g s in if P x then (x, s') else filter_next s')\""], ["", "end"], ["", "lift_definition filter_generator :: \"('a, 's) generator \\<Rightarrow> ('a, 's) generator\"\n  is \"\\<lambda>g. (filter_has_next g, filter_next g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>prod.\n       terminates prod \\<Longrightarrow>\n       terminates (local.filter_has_next prod, local.filter_next prod)", "proof(rule wf_terminates)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>prod. terminates prod \\<Longrightarrow> wf (?R prod)\n 2. \\<And>prod s.\n       \\<lbrakk>terminates prod;\n        fst (local.filter_has_next prod, local.filter_next prod) s\\<rbrakk>\n       \\<Longrightarrow> (snd (snd (local.filter_has_next prod,\n                                    local.filter_next prod)\n                                s),\n                          s)\n                         \\<in> ?R prod", "fix g :: \"('a, 's) raw_generator\" and s"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>prod. terminates prod \\<Longrightarrow> wf (?R prod)\n 2. \\<And>prod s.\n       \\<lbrakk>terminates prod;\n        fst (local.filter_has_next prod, local.filter_next prod) s\\<rbrakk>\n       \\<Longrightarrow> (snd (snd (local.filter_has_next prod,\n                                    local.filter_next prod)\n                                s),\n                          s)\n                         \\<in> ?R prod", "let ?R = \"{(snd (snd g s), s) | s. fst g s}\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>prod. terminates prod \\<Longrightarrow> wf (?R prod)\n 2. \\<And>prod s.\n       \\<lbrakk>terminates prod;\n        fst (local.filter_has_next prod, local.filter_next prod) s\\<rbrakk>\n       \\<Longrightarrow> (snd (snd (local.filter_has_next prod,\n                                    local.filter_next prod)\n                                s),\n                          s)\n                         \\<in> ?R prod", "let ?g = \"(filter_has_next g, filter_next g)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>prod. terminates prod \\<Longrightarrow> wf (?R prod)\n 2. \\<And>prod s.\n       \\<lbrakk>terminates prod;\n        fst (local.filter_has_next prod, local.filter_next prod) s\\<rbrakk>\n       \\<Longrightarrow> (snd (snd (local.filter_has_next prod,\n                                    local.filter_next prod)\n                                s),\n                          s)\n                         \\<in> ?R prod", "assume \"terminates g\""], ["proof (state)\nthis:\n  terminates g\n\ngoal (2 subgoals):\n 1. \\<And>prod. terminates prod \\<Longrightarrow> wf (?R prod)\n 2. \\<And>prod s.\n       \\<lbrakk>terminates prod;\n        fst (local.filter_has_next prod, local.filter_next prod) s\\<rbrakk>\n       \\<Longrightarrow> (snd (snd (local.filter_has_next prod,\n                                    local.filter_next prod)\n                                s),\n                          s)\n                         \\<in> ?R prod", "thus \"wf (?R\\<^sup>+)\""], ["proof (prove)\nusing this:\n  terminates g\n\ngoal (1 subgoal):\n 1. wf ({(snd (snd g s), s) |s. fst g s}\\<^sup>+)", "by(rule terminates_wfD[THEN wf_trancl])"], ["proof (state)\nthis:\n  wf ({(snd (snd g s), s) |s. fst g s}\\<^sup>+)\n\ngoal (1 subgoal):\n 1. \\<And>prod s.\n       \\<lbrakk>terminates prod;\n        fst (local.filter_has_next prod, local.filter_next prod) s\\<rbrakk>\n       \\<Longrightarrow> (snd (snd (local.filter_has_next prod,\n                                    local.filter_next prod)\n                                s),\n                          s)\n                         \\<in> {(snd (snd prod s), s) |s.\n                                fst prod s}\\<^sup>+", "assume \"fst ?g s\""], ["proof (state)\nthis:\n  fst (local.filter_has_next g, local.filter_next g) s\n\ngoal (1 subgoal):\n 1. \\<And>prod s.\n       \\<lbrakk>terminates prod;\n        fst (local.filter_has_next prod, local.filter_next prod) s\\<rbrakk>\n       \\<Longrightarrow> (snd (snd (local.filter_has_next prod,\n                                    local.filter_next prod)\n                                s),\n                          s)\n                         \\<in> {(snd (snd prod s), s) |s.\n                                fst prod s}\\<^sup>+", "hence \"filter_has_next g s\""], ["proof (prove)\nusing this:\n  fst (local.filter_has_next g, local.filter_next g) s\n\ngoal (1 subgoal):\n 1. local.filter_has_next g s", "by simp"], ["proof (state)\nthis:\n  local.filter_has_next g s\n\ngoal (1 subgoal):\n 1. \\<And>prod s.\n       \\<lbrakk>terminates prod;\n        fst (local.filter_has_next prod, local.filter_next prod) s\\<rbrakk>\n       \\<Longrightarrow> (snd (snd (local.filter_has_next prod,\n                                    local.filter_next prod)\n                                s),\n                          s)\n                         \\<in> {(snd (snd prod s), s) |s.\n                                fst prod s}\\<^sup>+", "thus \"(snd (snd ?g s), s) \\<in> ?R\\<^sup>+\""], ["proof (prove)\nusing this:\n  local.filter_has_next g s\n\ngoal (1 subgoal):\n 1. (snd (snd (local.filter_has_next g, local.filter_next g) s), s)\n    \\<in> {(snd (snd g s), s) |s. fst g s}\\<^sup>+", "by induct(subst filter_next.simps, auto simp add: split_beta filter_next.simps split del: if_split intro: trancl_into_trancl)"], ["proof (state)\nthis:\n  (snd (snd (local.filter_has_next g, local.filter_next g) s), s)\n  \\<in> {(snd (snd g s), s) |s. fst g s}\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma has_next_filter_generator:\n  \"list.has_next (filter_generator g) s \\<longleftrightarrow>\n  list.has_next g s \\<and> (let (x, s') = list.next g s in if P x then True else list.has_next (filter_generator g) s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.has_next (local.filter_generator g) s =\n    (list.has_next g s \\<and>\n     (let (x, s') = list.next g s\n      in if P x then True else list.has_next (local.filter_generator g) s'))", "apply(transfer)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g s.\n       terminates g \\<Longrightarrow>\n       fst (local.filter_has_next g, local.filter_next g) s =\n       (fst g s \\<and>\n        (let (x, s') = snd g s\n         in if P x then True\n            else fst (local.filter_has_next g, local.filter_next g) s'))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g s.\n       terminates g \\<Longrightarrow>\n       local.filter_has_next g s =\n       (fst g s \\<and>\n        (case snd g s of\n         (x, s') \\<Rightarrow>\n           \\<not> P x \\<longrightarrow> local.filter_has_next g s'))", "apply(subst filter_has_next.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g s.\n       terminates g \\<Longrightarrow>\n       ((\\<exists>sa.\n            s = sa \\<and> fst g sa \\<and> P (fst (snd g sa))) \\<or>\n        (\\<exists>sa.\n            s = sa \\<and>\n            fst g sa \\<and>\n            \\<not> P (fst (snd g sa)) \\<and>\n            local.filter_has_next g (snd (snd g sa)))) =\n       (fst g s \\<and>\n        (case snd g s of\n         (x, s') \\<Rightarrow>\n           \\<not> P x \\<longrightarrow> local.filter_has_next g s'))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma next_filter_generator:\n   \"list.next (filter_generator g) s =\n   (let (x, s') = list.next g s\n    in if P x then (x, s') else list.next (filter_generator g) s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.next (local.filter_generator g) s =\n    (let (x, s') = list.next g s\n     in if P x then (x, s') else list.next (local.filter_generator g) s')", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g s.\n       terminates g \\<Longrightarrow>\n       snd (local.filter_has_next g, local.filter_next g) s =\n       (let (x, s') = snd g s\n        in if P x then (x, s')\n           else snd (local.filter_has_next g, local.filter_next g) s')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g s.\n       terminates g \\<Longrightarrow>\n       local.filter_next g s =\n       (case snd g s of\n        (x, s') \\<Rightarrow>\n          if P x then (x, s')\n          else snd (local.filter_has_next g, local.filter_next g) s')", "apply(subst filter_next.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g s.\n       terminates g \\<Longrightarrow>\n       (let (x, s') = snd g s\n        in if P x then (x, s') else local.filter_next g s') =\n       (case snd g s of\n        (x, s') \\<Rightarrow>\n          if P x then (x, s')\n          else snd (local.filter_has_next g, local.filter_next g) s')", "apply(simp cong: if_cong)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma has_next_filter_generator_induct [consumes 1, case_names find step]:\n  assumes \"list.has_next (filter_generator g) s\"\n  and find: \"\\<And>s. \\<lbrakk> list.has_next g s; P (fst (list.next g s)) \\<rbrakk> \\<Longrightarrow> Q s\"\n  and step: \"\\<And>s. \\<lbrakk> list.has_next g s; \\<not> P (fst (list.next g s)); Q (snd (list.next g s)) \\<rbrakk> \\<Longrightarrow> Q s\"\n  shows \"Q s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q s", "using assms"], ["proof (prove)\nusing this:\n  list.has_next (local.filter_generator g) s\n  \\<lbrakk>list.has_next g ?s3; P (fst (list.next g ?s3))\\<rbrakk>\n  \\<Longrightarrow> Q ?s3\n  \\<lbrakk>list.has_next g ?s3; \\<not> P (fst (list.next g ?s3));\n   Q (snd (list.next g ?s3))\\<rbrakk>\n  \\<Longrightarrow> Q ?s3\n\ngoal (1 subgoal):\n 1. Q s", "by transfer(auto elim: filter_has_next.induct)"], ["", "lemma filter_generator_empty_conv:\n  \"list.has_next (filter_generator g) s \\<longleftrightarrow> (\\<exists>x\\<in>set (list.unfoldr g s). P x)\" (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. list.has_next (local.filter_generator g) s =\n    (\\<exists>x\\<in>set (list.unfoldr g s). P x)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. list.has_next (local.filter_generator g) s \\<Longrightarrow>\n    \\<exists>x\\<in>set (list.unfoldr g s). P x\n 2. \\<exists>x\\<in>set (list.unfoldr g s). P x \\<Longrightarrow>\n    list.has_next (local.filter_generator g) s", "assume \"?lhs\""], ["proof (state)\nthis:\n  list.has_next (local.filter_generator g) s\n\ngoal (2 subgoals):\n 1. list.has_next (local.filter_generator g) s \\<Longrightarrow>\n    \\<exists>x\\<in>set (list.unfoldr g s). P x\n 2. \\<exists>x\\<in>set (list.unfoldr g s). P x \\<Longrightarrow>\n    list.has_next (local.filter_generator g) s", "thus ?rhs"], ["proof (prove)\nusing this:\n  list.has_next (local.filter_generator g) s\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>set (list.unfoldr g s). P x", "proof(induct rule: has_next_filter_generator_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>list.has_next g s; P (fst (list.next g s))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>set (list.unfoldr g s). P x\n 2. \\<And>s.\n       \\<lbrakk>list.has_next g s; \\<not> P (fst (list.next g s));\n        \\<exists>x\\<in>set (list.unfoldr g (snd (list.next g s))).\n           P x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>set (list.unfoldr g s). P x", "case (find s)"], ["proof (state)\nthis:\n  list.has_next g s\n  P (fst (list.next g s))\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>list.has_next g s; P (fst (list.next g s))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>set (list.unfoldr g s). P x\n 2. \\<And>s.\n       \\<lbrakk>list.has_next g s; \\<not> P (fst (list.next g s));\n        \\<exists>x\\<in>set (list.unfoldr g (snd (list.next g s))).\n           P x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>set (list.unfoldr g s). P x", "thus ?case"], ["proof (prove)\nusing this:\n  list.has_next g s\n  P (fst (list.next g s))\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>set (list.unfoldr g s). P x", "by(cases \"list.next g s\")(subst list.unfoldr.simps, auto)"], ["proof (state)\nthis:\n  \\<exists>x\\<in>set (list.unfoldr g s). P x\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>list.has_next g s; \\<not> P (fst (list.next g s));\n        \\<exists>x\\<in>set (list.unfoldr g (snd (list.next g s))).\n           P x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>set (list.unfoldr g s). P x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>list.has_next g s; \\<not> P (fst (list.next g s));\n        \\<exists>x\\<in>set (list.unfoldr g (snd (list.next g s))).\n           P x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>set (list.unfoldr g s). P x", "case (step s)"], ["proof (state)\nthis:\n  list.has_next g s\n  \\<not> P (fst (list.next g s))\n  \\<exists>x\\<in>set (list.unfoldr g (snd (list.next g s))). P x\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>list.has_next g s; \\<not> P (fst (list.next g s));\n        \\<exists>x\\<in>set (list.unfoldr g (snd (list.next g s))).\n           P x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>set (list.unfoldr g s). P x", "thus ?case"], ["proof (prove)\nusing this:\n  list.has_next g s\n  \\<not> P (fst (list.next g s))\n  \\<exists>x\\<in>set (list.unfoldr g (snd (list.next g s))). P x\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>set (list.unfoldr g s). P x", "by(cases \"list.next g s\")(subst list.unfoldr.simps, auto)"], ["proof (state)\nthis:\n  \\<exists>x\\<in>set (list.unfoldr g s). P x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x\\<in>set (list.unfoldr g s). P x\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>set (list.unfoldr g s). P x \\<Longrightarrow>\n    list.has_next (local.filter_generator g) s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>set (list.unfoldr g s). P x \\<Longrightarrow>\n    list.has_next (local.filter_generator g) s", "assume ?rhs"], ["proof (state)\nthis:\n  \\<exists>x\\<in>set (list.unfoldr g s). P x\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>set (list.unfoldr g s). P x \\<Longrightarrow>\n    list.has_next (local.filter_generator g) s", "then"], ["proof (chain)\npicking this:\n  \\<exists>x\\<in>set (list.unfoldr g s). P x", "obtain x where \"x \\<in> set (list.unfoldr g s)\" \"P x\""], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>set (list.unfoldr g s). P x\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> set (list.unfoldr g s); P x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> set (list.unfoldr g s)\n  P x\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>set (list.unfoldr g s). P x \\<Longrightarrow>\n    list.has_next (local.filter_generator g) s", "thus ?lhs"], ["proof (prove)\nusing this:\n  x \\<in> set (list.unfoldr g s)\n  P x\n\ngoal (1 subgoal):\n 1. list.has_next (local.filter_generator g) s", "proof(induct xs\\<equiv>\"list.unfoldr g s\" arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>[] = list.unfoldr g s; x \\<in> set (list.unfoldr g s);\n        P x\\<rbrakk>\n       \\<Longrightarrow> list.has_next (local.filter_generator g) s\n 2. \\<And>a xs s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>xs = list.unfoldr g s;\n                    x \\<in> set (list.unfoldr g s); P x\\<rbrakk>\n                   \\<Longrightarrow> list.has_next\n(local.filter_generator g) s;\n        a # xs = list.unfoldr g s; x \\<in> set (list.unfoldr g s);\n        P x\\<rbrakk>\n       \\<Longrightarrow> list.has_next (local.filter_generator g) s", "case Nil"], ["proof (state)\nthis:\n  [] = list.unfoldr g s\n  x \\<in> set (list.unfoldr g s)\n  P x\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>[] = list.unfoldr g s; x \\<in> set (list.unfoldr g s);\n        P x\\<rbrakk>\n       \\<Longrightarrow> list.has_next (local.filter_generator g) s\n 2. \\<And>a xs s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>xs = list.unfoldr g s;\n                    x \\<in> set (list.unfoldr g s); P x\\<rbrakk>\n                   \\<Longrightarrow> list.has_next\n(local.filter_generator g) s;\n        a # xs = list.unfoldr g s; x \\<in> set (list.unfoldr g s);\n        P x\\<rbrakk>\n       \\<Longrightarrow> list.has_next (local.filter_generator g) s", "thus ?case"], ["proof (prove)\nusing this:\n  [] = list.unfoldr g s\n  x \\<in> set (list.unfoldr g s)\n  P x\n\ngoal (1 subgoal):\n 1. list.has_next (local.filter_generator g) s", "by(simp del: Nil_eq_unfoldr_iff)"], ["proof (state)\nthis:\n  list.has_next (local.filter_generator g) s\n\ngoal (1 subgoal):\n 1. \\<And>a xs s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>xs = list.unfoldr g s;\n                    x \\<in> set (list.unfoldr g s); P x\\<rbrakk>\n                   \\<Longrightarrow> list.has_next\n(local.filter_generator g) s;\n        a # xs = list.unfoldr g s; x \\<in> set (list.unfoldr g s);\n        P x\\<rbrakk>\n       \\<Longrightarrow> list.has_next (local.filter_generator g) s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>xs = list.unfoldr g s;\n                    x \\<in> set (list.unfoldr g s); P x\\<rbrakk>\n                   \\<Longrightarrow> list.has_next\n(local.filter_generator g) s;\n        a # xs = list.unfoldr g s; x \\<in> set (list.unfoldr g s);\n        P x\\<rbrakk>\n       \\<Longrightarrow> list.has_next (local.filter_generator g) s", "case (Cons x' xs)"], ["proof (state)\nthis:\n  \\<lbrakk>xs = list.unfoldr g ?s3; x \\<in> set (list.unfoldr g ?s3);\n   P x\\<rbrakk>\n  \\<Longrightarrow> list.has_next (local.filter_generator g) ?s3\n  x' # xs = list.unfoldr g s\n  x \\<in> set (list.unfoldr g s)\n  P x\n\ngoal (1 subgoal):\n 1. \\<And>a xs s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>xs = list.unfoldr g s;\n                    x \\<in> set (list.unfoldr g s); P x\\<rbrakk>\n                   \\<Longrightarrow> list.has_next\n(local.filter_generator g) s;\n        a # xs = list.unfoldr g s; x \\<in> set (list.unfoldr g s);\n        P x\\<rbrakk>\n       \\<Longrightarrow> list.has_next (local.filter_generator g) s", "from \\<open>x' # xs = list.unfoldr g s\\<close>[symmetric, simp]"], ["proof (chain)\npicking this:\n  list.unfoldr g s = x' # xs", "have [simp]: \"fst (list.next g s) = x' \\<and> list.has_next g s \\<and> list.unfoldr g (snd (list.next g s)) = xs\""], ["proof (prove)\nusing this:\n  list.unfoldr g s = x' # xs\n\ngoal (1 subgoal):\n 1. fst (list.next g s) = x' \\<and>\n    list.has_next g s \\<and> list.unfoldr g (snd (list.next g s)) = xs", "by(subst (asm) list.unfoldr.simps)(simp add: split_beta split: if_split_asm)"], ["proof (state)\nthis:\n  fst (list.next g s) = x' \\<and>\n  list.has_next g s \\<and> list.unfoldr g (snd (list.next g s)) = xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>xs = list.unfoldr g s;\n                    x \\<in> set (list.unfoldr g s); P x\\<rbrakk>\n                   \\<Longrightarrow> list.has_next\n(local.filter_generator g) s;\n        a # xs = list.unfoldr g s; x \\<in> set (list.unfoldr g s);\n        P x\\<rbrakk>\n       \\<Longrightarrow> list.has_next (local.filter_generator g) s", "from Cons.hyps(1)[of \"snd (list.next g s)\"] \\<open>x \\<in> set (list.unfoldr g s)\\<close> \\<open>P x\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>xs = list.unfoldr g (snd (list.next g s));\n   x \\<in> set (list.unfoldr g (snd (list.next g s))); P x\\<rbrakk>\n  \\<Longrightarrow> list.has_next (local.filter_generator g)\n                     (snd (list.next g s))\n  x \\<in> set (list.unfoldr g s)\n  P x", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>xs = list.unfoldr g (snd (list.next g s));\n   x \\<in> set (list.unfoldr g (snd (list.next g s))); P x\\<rbrakk>\n  \\<Longrightarrow> list.has_next (local.filter_generator g)\n                     (snd (list.next g s))\n  x \\<in> set (list.unfoldr g s)\n  P x\n\ngoal (1 subgoal):\n 1. list.has_next (local.filter_generator g) s", "by(subst has_next_filter_generator)(auto simp add: split_beta)"], ["proof (state)\nthis:\n  list.has_next (local.filter_generator g) s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list.has_next (local.filter_generator g) s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unfoldr_filter_generator:\n  \"list.unfoldr (filter_generator g) s = filter P (list.unfoldr g s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.unfoldr (local.filter_generator g) s = filter P (list.unfoldr g s)", "unfolding list_all2_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (=) (list.unfoldr (local.filter_generator g) s)\n     (filter P (list.unfoldr g s))", "proof(coinduction arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       (list.unfoldr (local.filter_generator g) s = []) =\n       (filter P (list.unfoldr g s) = [])\n 2. \\<And>s.\n       \\<lbrakk>list.unfoldr (local.filter_generator g) s \\<noteq> [];\n        filter P (list.unfoldr g s) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> hd (list.unfoldr (local.filter_generator g) s) =\n                         hd (filter P (list.unfoldr g s)) \\<and>\n                         ((\\<exists>sa.\n                              tl (list.unfoldr (local.filter_generator g)\n                                   s) =\n                              list.unfoldr (local.filter_generator g)\n                               sa \\<and>\n                              tl (filter P (list.unfoldr g s)) =\n                              filter P (list.unfoldr g sa)) \\<or>\n                          list_all2 (=)\n                           (tl (list.unfoldr (local.filter_generator g) s))\n                           (tl (filter P (list.unfoldr g s))))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>s.\n       (list.unfoldr (local.filter_generator g) s = []) =\n       (filter P (list.unfoldr g s) = [])\n 2. \\<And>s.\n       \\<lbrakk>list.unfoldr (local.filter_generator g) s \\<noteq> [];\n        filter P (list.unfoldr g s) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> hd (list.unfoldr (local.filter_generator g) s) =\n                         hd (filter P (list.unfoldr g s)) \\<and>\n                         ((\\<exists>sa.\n                              tl (list.unfoldr (local.filter_generator g)\n                                   s) =\n                              list.unfoldr (local.filter_generator g)\n                               sa \\<and>\n                              tl (filter P (list.unfoldr g s)) =\n                              filter P (list.unfoldr g sa)) \\<or>\n                          list_all2 (=)\n                           (tl (list.unfoldr (local.filter_generator g) s))\n                           (tl (filter P (list.unfoldr g s))))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (list.unfoldr (local.filter_generator g) s = []) =\n    (filter P (list.unfoldr g s) = [])", "by(simp add: filter_empty_conv filter_generator_empty_conv)"], ["proof (state)\nthis:\n  (list.unfoldr (local.filter_generator g) s = []) =\n  (filter P (list.unfoldr g s) = [])\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>list.unfoldr (local.filter_generator g) s \\<noteq> [];\n        filter P (list.unfoldr g s) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> hd (list.unfoldr (local.filter_generator g) s) =\n                         hd (filter P (list.unfoldr g s)) \\<and>\n                         ((\\<exists>sa.\n                              tl (list.unfoldr (local.filter_generator g)\n                                   s) =\n                              list.unfoldr (local.filter_generator g)\n                               sa \\<and>\n                              tl (filter P (list.unfoldr g s)) =\n                              filter P (list.unfoldr g sa)) \\<or>\n                          list_all2 (=)\n                           (tl (list.unfoldr (local.filter_generator g) s))\n                           (tl (filter P (list.unfoldr g s))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>list.unfoldr (local.filter_generator g) s \\<noteq> [];\n        filter P (list.unfoldr g s) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> hd (list.unfoldr (local.filter_generator g) s) =\n                         hd (filter P (list.unfoldr g s)) \\<and>\n                         ((\\<exists>sa.\n                              tl (list.unfoldr (local.filter_generator g)\n                                   s) =\n                              list.unfoldr (local.filter_generator g)\n                               sa \\<and>\n                              tl (filter P (list.unfoldr g s)) =\n                              filter P (list.unfoldr g sa)) \\<or>\n                          list_all2 (=)\n                           (tl (list.unfoldr (local.filter_generator g) s))\n                           (tl (filter P (list.unfoldr g s))))", "case (Cons s)"], ["proof (state)\nthis:\n  list.unfoldr (local.filter_generator g) s \\<noteq> []\n  filter P (list.unfoldr g s) \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>list.unfoldr (local.filter_generator g) s \\<noteq> [];\n        filter P (list.unfoldr g s) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> hd (list.unfoldr (local.filter_generator g) s) =\n                         hd (filter P (list.unfoldr g s)) \\<and>\n                         ((\\<exists>sa.\n                              tl (list.unfoldr (local.filter_generator g)\n                                   s) =\n                              list.unfoldr (local.filter_generator g)\n                               sa \\<and>\n                              tl (filter P (list.unfoldr g s)) =\n                              filter P (list.unfoldr g sa)) \\<or>\n                          list_all2 (=)\n                           (tl (list.unfoldr (local.filter_generator g) s))\n                           (tl (filter P (list.unfoldr g s))))", "hence \"list.has_next (filter_generator g) s\""], ["proof (prove)\nusing this:\n  list.unfoldr (local.filter_generator g) s \\<noteq> []\n  filter P (list.unfoldr g s) \\<noteq> []\n\ngoal (1 subgoal):\n 1. list.has_next (local.filter_generator g) s", "by simp"], ["proof (state)\nthis:\n  list.has_next (local.filter_generator g) s\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>list.unfoldr (local.filter_generator g) s \\<noteq> [];\n        filter P (list.unfoldr g s) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> hd (list.unfoldr (local.filter_generator g) s) =\n                         hd (filter P (list.unfoldr g s)) \\<and>\n                         ((\\<exists>sa.\n                              tl (list.unfoldr (local.filter_generator g)\n                                   s) =\n                              list.unfoldr (local.filter_generator g)\n                               sa \\<and>\n                              tl (filter P (list.unfoldr g s)) =\n                              filter P (list.unfoldr g sa)) \\<or>\n                          list_all2 (=)\n                           (tl (list.unfoldr (local.filter_generator g) s))\n                           (tl (filter P (list.unfoldr g s))))", "thus ?case"], ["proof (prove)\nusing this:\n  list.has_next (local.filter_generator g) s\n\ngoal (1 subgoal):\n 1. hd (list.unfoldr (local.filter_generator g) s) =\n    hd (filter P (list.unfoldr g s)) \\<and>\n    ((\\<exists>s.\n         tl (list.unfoldr (local.filter_generator g) s) =\n         list.unfoldr (local.filter_generator g) s \\<and>\n         tl (filter P (list.unfoldr g s)) =\n         filter P (list.unfoldr g s)) \\<or>\n     list_all2 (=) (tl (list.unfoldr (local.filter_generator g) s))\n      (tl (filter P (list.unfoldr g s))))", "proof(induction rule: has_next_filter_generator_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>list.has_next g s; P (fst (list.next g s))\\<rbrakk>\n       \\<Longrightarrow> hd (list.unfoldr (local.filter_generator g) s) =\n                         hd (filter P (list.unfoldr g s)) \\<and>\n                         ((\\<exists>sa.\n                              tl (list.unfoldr (local.filter_generator g)\n                                   s) =\n                              list.unfoldr (local.filter_generator g)\n                               sa \\<and>\n                              tl (filter P (list.unfoldr g s)) =\n                              filter P (list.unfoldr g sa)) \\<or>\n                          list_all2 (=)\n                           (tl (list.unfoldr (local.filter_generator g) s))\n                           (tl (filter P (list.unfoldr g s))))\n 2. \\<And>s.\n       \\<lbrakk>list.has_next g s; \\<not> P (fst (list.next g s));\n        hd (list.unfoldr (local.filter_generator g) (snd (list.next g s))) =\n        hd (filter P (list.unfoldr g (snd (list.next g s)))) \\<and>\n        ((\\<exists>sa.\n             tl (list.unfoldr (local.filter_generator g)\n                  (snd (list.next g s))) =\n             list.unfoldr (local.filter_generator g) sa \\<and>\n             tl (filter P (list.unfoldr g (snd (list.next g s)))) =\n             filter P (list.unfoldr g sa)) \\<or>\n         list_all2 (=)\n          (tl (list.unfoldr (local.filter_generator g)\n                (snd (list.next g s))))\n          (tl (filter P (list.unfoldr g (snd (list.next g s))))))\\<rbrakk>\n       \\<Longrightarrow> hd (list.unfoldr (local.filter_generator g) s) =\n                         hd (filter P (list.unfoldr g s)) \\<and>\n                         ((\\<exists>sa.\n                              tl (list.unfoldr (local.filter_generator g)\n                                   s) =\n                              list.unfoldr (local.filter_generator g)\n                               sa \\<and>\n                              tl (filter P (list.unfoldr g s)) =\n                              filter P (list.unfoldr g sa)) \\<or>\n                          list_all2 (=)\n                           (tl (list.unfoldr (local.filter_generator g) s))\n                           (tl (filter P (list.unfoldr g s))))", "case (find s)"], ["proof (state)\nthis:\n  list.has_next g s\n  P (fst (list.next g s))\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>list.has_next g s; P (fst (list.next g s))\\<rbrakk>\n       \\<Longrightarrow> hd (list.unfoldr (local.filter_generator g) s) =\n                         hd (filter P (list.unfoldr g s)) \\<and>\n                         ((\\<exists>sa.\n                              tl (list.unfoldr (local.filter_generator g)\n                                   s) =\n                              list.unfoldr (local.filter_generator g)\n                               sa \\<and>\n                              tl (filter P (list.unfoldr g s)) =\n                              filter P (list.unfoldr g sa)) \\<or>\n                          list_all2 (=)\n                           (tl (list.unfoldr (local.filter_generator g) s))\n                           (tl (filter P (list.unfoldr g s))))\n 2. \\<And>s.\n       \\<lbrakk>list.has_next g s; \\<not> P (fst (list.next g s));\n        hd (list.unfoldr (local.filter_generator g) (snd (list.next g s))) =\n        hd (filter P (list.unfoldr g (snd (list.next g s)))) \\<and>\n        ((\\<exists>sa.\n             tl (list.unfoldr (local.filter_generator g)\n                  (snd (list.next g s))) =\n             list.unfoldr (local.filter_generator g) sa \\<and>\n             tl (filter P (list.unfoldr g (snd (list.next g s)))) =\n             filter P (list.unfoldr g sa)) \\<or>\n         list_all2 (=)\n          (tl (list.unfoldr (local.filter_generator g)\n                (snd (list.next g s))))\n          (tl (filter P (list.unfoldr g (snd (list.next g s))))))\\<rbrakk>\n       \\<Longrightarrow> hd (list.unfoldr (local.filter_generator g) s) =\n                         hd (filter P (list.unfoldr g s)) \\<and>\n                         ((\\<exists>sa.\n                              tl (list.unfoldr (local.filter_generator g)\n                                   s) =\n                              list.unfoldr (local.filter_generator g)\n                               sa \\<and>\n                              tl (filter P (list.unfoldr g s)) =\n                              filter P (list.unfoldr g sa)) \\<or>\n                          list_all2 (=)\n                           (tl (list.unfoldr (local.filter_generator g) s))\n                           (tl (filter P (list.unfoldr g s))))", "thus ?case"], ["proof (prove)\nusing this:\n  list.has_next g s\n  P (fst (list.next g s))\n\ngoal (1 subgoal):\n 1. hd (list.unfoldr (local.filter_generator g) s) =\n    hd (filter P (list.unfoldr g s)) \\<and>\n    ((\\<exists>s.\n         tl (list.unfoldr (local.filter_generator g) s) =\n         list.unfoldr (local.filter_generator g) s \\<and>\n         tl (filter P (list.unfoldr g s)) =\n         filter P (list.unfoldr g s)) \\<or>\n     list_all2 (=) (tl (list.unfoldr (local.filter_generator g) s))\n      (tl (filter P (list.unfoldr g s))))", "apply(subst (1 2 3 5) list.unfoldr.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list.has_next g s; P (fst (list.next g s))\\<rbrakk>\n    \\<Longrightarrow> hd (if list.has_next (local.filter_generator g) s\n                          then let (a, s') =\n                                     list.next (local.filter_generator g) s\n                               in a #\n                                  list.unfoldr (local.filter_generator g) s'\n                          else []) =\n                      hd (filter P\n                           (if list.has_next g s\n                            then let (a, s') = list.next g s\n                                 in a # list.unfoldr g s'\n                            else [])) \\<and>\n                      ((\\<exists>s.\n                           tl (if list.has_next (local.filter_generator g) s\n                               then let (a, s') =\n    list.next (local.filter_generator g) s\n                                    in a #\n list.unfoldr (local.filter_generator g) s'\n                               else []) =\n                           list.unfoldr (local.filter_generator g) s \\<and>\n                           tl (filter P\n                                (if list.has_next g s\n                                 then let (a, s') = list.next g s\nin a # list.unfoldr g s'\n                                 else [])) =\n                           filter P (list.unfoldr g s)) \\<or>\n                       list_all2 (=)\n                        (tl (list.unfoldr (local.filter_generator g) s))\n                        (tl (filter P (list.unfoldr g s))))", "apply(subst (1 2) has_next_filter_generator)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list.has_next g s; P (fst (list.next g s))\\<rbrakk>\n    \\<Longrightarrow> hd (if list.has_next g s \\<and>\n                             (let (x, s') = list.next g s\n                              in if P x then True\n                                 else list.has_next\n (local.filter_generator g) s')\n                          then let (a, s') =\n                                     list.next (local.filter_generator g) s\n                               in a #\n                                  list.unfoldr (local.filter_generator g) s'\n                          else []) =\n                      hd (filter P\n                           (if list.has_next g s\n                            then let (a, s') = list.next g s\n                                 in a # list.unfoldr g s'\n                            else [])) \\<and>\n                      ((\\<exists>s.\n                           tl (if list.has_next g s \\<and>\n                                  (let (x, s') = list.next g s\n                                   in if P x then True\nelse list.has_next (local.filter_generator g) s')\n                               then let (a, s') =\n    list.next (local.filter_generator g) s\n                                    in a #\n list.unfoldr (local.filter_generator g) s'\n                               else []) =\n                           list.unfoldr (local.filter_generator g) s \\<and>\n                           tl (filter P\n                                (if list.has_next g s\n                                 then let (a, s') = list.next g s\nin a # list.unfoldr g s'\n                                 else [])) =\n                           filter P (list.unfoldr g s)) \\<or>\n                       list_all2 (=)\n                        (tl (list.unfoldr (local.filter_generator g) s))\n                        (tl (filter P (list.unfoldr g s))))", "apply(subst next_filter_generator)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list.has_next g s; P (fst (list.next g s))\\<rbrakk>\n    \\<Longrightarrow> hd (if list.has_next g s \\<and>\n                             (let (x, s') = list.next g s\n                              in if P x then True\n                                 else list.has_next\n (local.filter_generator g) s')\n                          then let (a, s') =\n                                     let (x, s') = list.next g s\n                                     in if P x then (x, s')\n  else list.next (local.filter_generator g) s'\n                               in a #\n                                  list.unfoldr (local.filter_generator g) s'\n                          else []) =\n                      hd (filter P\n                           (if list.has_next g s\n                            then let (a, s') = list.next g s\n                                 in a # list.unfoldr g s'\n                            else [])) \\<and>\n                      ((\\<exists>s.\n                           tl (if list.has_next g s \\<and>\n                                  (let (x, s') = list.next g s\n                                   in if P x then True\nelse list.has_next (local.filter_generator g) s')\n                               then let (a, s') =\n    list.next (local.filter_generator g) s\n                                    in a #\n list.unfoldr (local.filter_generator g) s'\n                               else []) =\n                           list.unfoldr (local.filter_generator g) s \\<and>\n                           tl (filter P\n                                (if list.has_next g s\n                                 then let (a, s') = list.next g s\nin a # list.unfoldr g s'\n                                 else [])) =\n                           filter P (list.unfoldr g s)) \\<or>\n                       list_all2 (=)\n                        (tl (list.unfoldr (local.filter_generator g) s))\n                        (tl (filter P (list.unfoldr g s))))", "apply(simp add: split_beta)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list.has_next g s; P (fst (list.next g s))\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>s.\n                          list.unfoldr (local.filter_generator g)\n                           (snd (list.next (local.filter_generator g) s)) =\n                          list.unfoldr (local.filter_generator g) s \\<and>\n                          filter P (list.unfoldr g (snd (list.next g s))) =\n                          filter P (list.unfoldr g s)) \\<or>\n                      list_all2 (=)\n                       (tl (list.unfoldr (local.filter_generator g) s))\n                       (tl (filter P (list.unfoldr g s)))", "apply(rule disjI1 exI conjI refl)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list.has_next g s; P (fst (list.next g s))\\<rbrakk>\n    \\<Longrightarrow> filter P (list.unfoldr g (snd (list.next g s))) =\n                      filter P\n                       (list.unfoldr g\n                         (snd (list.next (local.filter_generator g) s)))", "apply(subst next_filter_generator)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list.has_next g s; P (fst (list.next g s))\\<rbrakk>\n    \\<Longrightarrow> filter P (list.unfoldr g (snd (list.next g s))) =\n                      filter P\n                       (list.unfoldr g\n                         (snd (let (x, s') = list.next g s\n                               in if P x then (x, s')\n                                  else list.next (local.filter_generator g)\n  s')))", "apply(simp add: split_beta)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  hd (list.unfoldr (local.filter_generator g) s) =\n  hd (filter P (list.unfoldr g s)) \\<and>\n  ((\\<exists>s.\n       tl (list.unfoldr (local.filter_generator g) s) =\n       list.unfoldr (local.filter_generator g) s \\<and>\n       tl (filter P (list.unfoldr g s)) = filter P (list.unfoldr g s)) \\<or>\n   list_all2 (=) (tl (list.unfoldr (local.filter_generator g) s))\n    (tl (filter P (list.unfoldr g s))))\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>list.has_next g s; \\<not> P (fst (list.next g s));\n        hd (list.unfoldr (local.filter_generator g) (snd (list.next g s))) =\n        hd (filter P (list.unfoldr g (snd (list.next g s)))) \\<and>\n        ((\\<exists>sa.\n             tl (list.unfoldr (local.filter_generator g)\n                  (snd (list.next g s))) =\n             list.unfoldr (local.filter_generator g) sa \\<and>\n             tl (filter P (list.unfoldr g (snd (list.next g s)))) =\n             filter P (list.unfoldr g sa)) \\<or>\n         list_all2 (=)\n          (tl (list.unfoldr (local.filter_generator g)\n                (snd (list.next g s))))\n          (tl (filter P (list.unfoldr g (snd (list.next g s))))))\\<rbrakk>\n       \\<Longrightarrow> hd (list.unfoldr (local.filter_generator g) s) =\n                         hd (filter P (list.unfoldr g s)) \\<and>\n                         ((\\<exists>sa.\n                              tl (list.unfoldr (local.filter_generator g)\n                                   s) =\n                              list.unfoldr (local.filter_generator g)\n                               sa \\<and>\n                              tl (filter P (list.unfoldr g s)) =\n                              filter P (list.unfoldr g sa)) \\<or>\n                          list_all2 (=)\n                           (tl (list.unfoldr (local.filter_generator g) s))\n                           (tl (filter P (list.unfoldr g s))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>list.has_next g s; \\<not> P (fst (list.next g s));\n        hd (list.unfoldr (local.filter_generator g) (snd (list.next g s))) =\n        hd (filter P (list.unfoldr g (snd (list.next g s)))) \\<and>\n        ((\\<exists>sa.\n             tl (list.unfoldr (local.filter_generator g)\n                  (snd (list.next g s))) =\n             list.unfoldr (local.filter_generator g) sa \\<and>\n             tl (filter P (list.unfoldr g (snd (list.next g s)))) =\n             filter P (list.unfoldr g sa)) \\<or>\n         list_all2 (=)\n          (tl (list.unfoldr (local.filter_generator g)\n                (snd (list.next g s))))\n          (tl (filter P (list.unfoldr g (snd (list.next g s))))))\\<rbrakk>\n       \\<Longrightarrow> hd (list.unfoldr (local.filter_generator g) s) =\n                         hd (filter P (list.unfoldr g s)) \\<and>\n                         ((\\<exists>sa.\n                              tl (list.unfoldr (local.filter_generator g)\n                                   s) =\n                              list.unfoldr (local.filter_generator g)\n                               sa \\<and>\n                              tl (filter P (list.unfoldr g s)) =\n                              filter P (list.unfoldr g sa)) \\<or>\n                          list_all2 (=)\n                           (tl (list.unfoldr (local.filter_generator g) s))\n                           (tl (filter P (list.unfoldr g s))))", "case (step s)"], ["proof (state)\nthis:\n  list.has_next g s\n  \\<not> P (fst (list.next g s))\n  hd (list.unfoldr (local.filter_generator g) (snd (list.next g s))) =\n  hd (filter P (list.unfoldr g (snd (list.next g s)))) \\<and>\n  ((\\<exists>s.\n       tl (list.unfoldr (local.filter_generator g) (snd (list.next g s))) =\n       list.unfoldr (local.filter_generator g) s \\<and>\n       tl (filter P (list.unfoldr g (snd (list.next g s)))) =\n       filter P (list.unfoldr g s)) \\<or>\n   list_all2 (=)\n    (tl (list.unfoldr (local.filter_generator g) (snd (list.next g s))))\n    (tl (filter P (list.unfoldr g (snd (list.next g s))))))\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>list.has_next g s; \\<not> P (fst (list.next g s));\n        hd (list.unfoldr (local.filter_generator g) (snd (list.next g s))) =\n        hd (filter P (list.unfoldr g (snd (list.next g s)))) \\<and>\n        ((\\<exists>sa.\n             tl (list.unfoldr (local.filter_generator g)\n                  (snd (list.next g s))) =\n             list.unfoldr (local.filter_generator g) sa \\<and>\n             tl (filter P (list.unfoldr g (snd (list.next g s)))) =\n             filter P (list.unfoldr g sa)) \\<or>\n         list_all2 (=)\n          (tl (list.unfoldr (local.filter_generator g)\n                (snd (list.next g s))))\n          (tl (filter P (list.unfoldr g (snd (list.next g s))))))\\<rbrakk>\n       \\<Longrightarrow> hd (list.unfoldr (local.filter_generator g) s) =\n                         hd (filter P (list.unfoldr g s)) \\<and>\n                         ((\\<exists>sa.\n                              tl (list.unfoldr (local.filter_generator g)\n                                   s) =\n                              list.unfoldr (local.filter_generator g)\n                               sa \\<and>\n                              tl (filter P (list.unfoldr g s)) =\n                              filter P (list.unfoldr g sa)) \\<or>\n                          list_all2 (=)\n                           (tl (list.unfoldr (local.filter_generator g) s))\n                           (tl (filter P (list.unfoldr g s))))", "from step.hyps"], ["proof (chain)\npicking this:\n  list.has_next g s\n  \\<not> P (fst (list.next g s))", "have \"list.unfoldr (filter_generator g) s = list.unfoldr (filter_generator g) (snd (list.next g s))\""], ["proof (prove)\nusing this:\n  list.has_next g s\n  \\<not> P (fst (list.next g s))\n\ngoal (1 subgoal):\n 1. list.unfoldr (local.filter_generator g) s =\n    list.unfoldr (local.filter_generator g) (snd (list.next g s))", "apply(subst (1 2) list.unfoldr.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list.has_next g s; \\<not> P (fst (list.next g s))\\<rbrakk>\n    \\<Longrightarrow> (if list.has_next (local.filter_generator g) s\n                       then let (a, s') =\n                                  list.next (local.filter_generator g) s\n                            in a #\n                               list.unfoldr (local.filter_generator g) s'\n                       else []) =\n                      (if list.has_next (local.filter_generator g)\n                           (snd (list.next g s))\n                       then let (a, s') =\n                                  list.next (local.filter_generator g)\n                                   (snd (list.next g s))\n                            in a #\n                               list.unfoldr (local.filter_generator g) s'\n                       else [])", "apply(subst has_next_filter_generator)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list.has_next g s; \\<not> P (fst (list.next g s))\\<rbrakk>\n    \\<Longrightarrow> (if list.has_next g s \\<and>\n                          (let (x, s') = list.next g s\n                           in if P x then True\n                              else list.has_next (local.filter_generator g)\n                                    s')\n                       then let (a, s') =\n                                  list.next (local.filter_generator g) s\n                            in a #\n                               list.unfoldr (local.filter_generator g) s'\n                       else []) =\n                      (if list.has_next (local.filter_generator g)\n                           (snd (list.next g s))\n                       then let (a, s') =\n                                  list.next (local.filter_generator g)\n                                   (snd (list.next g s))\n                            in a #\n                               list.unfoldr (local.filter_generator g) s'\n                       else [])", "apply(subst next_filter_generator)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list.has_next g s; \\<not> P (fst (list.next g s))\\<rbrakk>\n    \\<Longrightarrow> (if list.has_next g s \\<and>\n                          (let (x, s') = list.next g s\n                           in if P x then True\n                              else list.has_next (local.filter_generator g)\n                                    s')\n                       then let (a, s') =\n                                  let (x, s') = list.next g s\n                                  in if P x then (x, s')\n                                     else list.next\n     (local.filter_generator g) s'\n                            in a #\n                               list.unfoldr (local.filter_generator g) s'\n                       else []) =\n                      (if list.has_next (local.filter_generator g)\n                           (snd (list.next g s))\n                       then let (a, s') =\n                                  list.next (local.filter_generator g)\n                                   (snd (list.next g s))\n                            in a #\n                               list.unfoldr (local.filter_generator g) s'\n                       else [])", "apply(auto simp add: split_beta)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  list.unfoldr (local.filter_generator g) s =\n  list.unfoldr (local.filter_generator g) (snd (list.next g s))\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>list.has_next g s; \\<not> P (fst (list.next g s));\n        hd (list.unfoldr (local.filter_generator g) (snd (list.next g s))) =\n        hd (filter P (list.unfoldr g (snd (list.next g s)))) \\<and>\n        ((\\<exists>sa.\n             tl (list.unfoldr (local.filter_generator g)\n                  (snd (list.next g s))) =\n             list.unfoldr (local.filter_generator g) sa \\<and>\n             tl (filter P (list.unfoldr g (snd (list.next g s)))) =\n             filter P (list.unfoldr g sa)) \\<or>\n         list_all2 (=)\n          (tl (list.unfoldr (local.filter_generator g)\n                (snd (list.next g s))))\n          (tl (filter P (list.unfoldr g (snd (list.next g s))))))\\<rbrakk>\n       \\<Longrightarrow> hd (list.unfoldr (local.filter_generator g) s) =\n                         hd (filter P (list.unfoldr g s)) \\<and>\n                         ((\\<exists>sa.\n                              tl (list.unfoldr (local.filter_generator g)\n                                   s) =\n                              list.unfoldr (local.filter_generator g)\n                               sa \\<and>\n                              tl (filter P (list.unfoldr g s)) =\n                              filter P (list.unfoldr g sa)) \\<or>\n                          list_all2 (=)\n                           (tl (list.unfoldr (local.filter_generator g) s))\n                           (tl (filter P (list.unfoldr g s))))", "moreover"], ["proof (state)\nthis:\n  list.unfoldr (local.filter_generator g) s =\n  list.unfoldr (local.filter_generator g) (snd (list.next g s))\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>list.has_next g s; \\<not> P (fst (list.next g s));\n        hd (list.unfoldr (local.filter_generator g) (snd (list.next g s))) =\n        hd (filter P (list.unfoldr g (snd (list.next g s)))) \\<and>\n        ((\\<exists>sa.\n             tl (list.unfoldr (local.filter_generator g)\n                  (snd (list.next g s))) =\n             list.unfoldr (local.filter_generator g) sa \\<and>\n             tl (filter P (list.unfoldr g (snd (list.next g s)))) =\n             filter P (list.unfoldr g sa)) \\<or>\n         list_all2 (=)\n          (tl (list.unfoldr (local.filter_generator g)\n                (snd (list.next g s))))\n          (tl (filter P (list.unfoldr g (snd (list.next g s))))))\\<rbrakk>\n       \\<Longrightarrow> hd (list.unfoldr (local.filter_generator g) s) =\n                         hd (filter P (list.unfoldr g s)) \\<and>\n                         ((\\<exists>sa.\n                              tl (list.unfoldr (local.filter_generator g)\n                                   s) =\n                              list.unfoldr (local.filter_generator g)\n                               sa \\<and>\n                              tl (filter P (list.unfoldr g s)) =\n                              filter P (list.unfoldr g sa)) \\<or>\n                          list_all2 (=)\n                           (tl (list.unfoldr (local.filter_generator g) s))\n                           (tl (filter P (list.unfoldr g s))))", "from step.hyps"], ["proof (chain)\npicking this:\n  list.has_next g s\n  \\<not> P (fst (list.next g s))", "have \"filter P (list.unfoldr g (snd (list.next g s))) = filter P (list.unfoldr g s)\""], ["proof (prove)\nusing this:\n  list.has_next g s\n  \\<not> P (fst (list.next g s))\n\ngoal (1 subgoal):\n 1. filter P (list.unfoldr g (snd (list.next g s))) =\n    filter P (list.unfoldr g s)", "by(subst (2) list.unfoldr.simps)(auto simp add: split_beta)"], ["proof (state)\nthis:\n  filter P (list.unfoldr g (snd (list.next g s))) =\n  filter P (list.unfoldr g s)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>list.has_next g s; \\<not> P (fst (list.next g s));\n        hd (list.unfoldr (local.filter_generator g) (snd (list.next g s))) =\n        hd (filter P (list.unfoldr g (snd (list.next g s)))) \\<and>\n        ((\\<exists>sa.\n             tl (list.unfoldr (local.filter_generator g)\n                  (snd (list.next g s))) =\n             list.unfoldr (local.filter_generator g) sa \\<and>\n             tl (filter P (list.unfoldr g (snd (list.next g s)))) =\n             filter P (list.unfoldr g sa)) \\<or>\n         list_all2 (=)\n          (tl (list.unfoldr (local.filter_generator g)\n                (snd (list.next g s))))\n          (tl (filter P (list.unfoldr g (snd (list.next g s))))))\\<rbrakk>\n       \\<Longrightarrow> hd (list.unfoldr (local.filter_generator g) s) =\n                         hd (filter P (list.unfoldr g s)) \\<and>\n                         ((\\<exists>sa.\n                              tl (list.unfoldr (local.filter_generator g)\n                                   s) =\n                              list.unfoldr (local.filter_generator g)\n                               sa \\<and>\n                              tl (filter P (list.unfoldr g s)) =\n                              filter P (list.unfoldr g sa)) \\<or>\n                          list_all2 (=)\n                           (tl (list.unfoldr (local.filter_generator g) s))\n                           (tl (filter P (list.unfoldr g s))))", "ultimately"], ["proof (chain)\npicking this:\n  list.unfoldr (local.filter_generator g) s =\n  list.unfoldr (local.filter_generator g) (snd (list.next g s))\n  filter P (list.unfoldr g (snd (list.next g s))) =\n  filter P (list.unfoldr g s)", "show ?case"], ["proof (prove)\nusing this:\n  list.unfoldr (local.filter_generator g) s =\n  list.unfoldr (local.filter_generator g) (snd (list.next g s))\n  filter P (list.unfoldr g (snd (list.next g s))) =\n  filter P (list.unfoldr g s)\n\ngoal (1 subgoal):\n 1. hd (list.unfoldr (local.filter_generator g) s) =\n    hd (filter P (list.unfoldr g s)) \\<and>\n    ((\\<exists>s.\n         tl (list.unfoldr (local.filter_generator g) s) =\n         list.unfoldr (local.filter_generator g) s \\<and>\n         tl (filter P (list.unfoldr g s)) =\n         filter P (list.unfoldr g s)) \\<or>\n     list_all2 (=) (tl (list.unfoldr (local.filter_generator g) s))\n      (tl (filter P (list.unfoldr g s))))", "using step.IH"], ["proof (prove)\nusing this:\n  list.unfoldr (local.filter_generator g) s =\n  list.unfoldr (local.filter_generator g) (snd (list.next g s))\n  filter P (list.unfoldr g (snd (list.next g s))) =\n  filter P (list.unfoldr g s)\n  hd (list.unfoldr (local.filter_generator g) (snd (list.next g s))) =\n  hd (filter P (list.unfoldr g (snd (list.next g s)))) \\<and>\n  ((\\<exists>s.\n       tl (list.unfoldr (local.filter_generator g) (snd (list.next g s))) =\n       list.unfoldr (local.filter_generator g) s \\<and>\n       tl (filter P (list.unfoldr g (snd (list.next g s)))) =\n       filter P (list.unfoldr g s)) \\<or>\n   list_all2 (=)\n    (tl (list.unfoldr (local.filter_generator g) (snd (list.next g s))))\n    (tl (filter P (list.unfoldr g (snd (list.next g s))))))\n\ngoal (1 subgoal):\n 1. hd (list.unfoldr (local.filter_generator g) s) =\n    hd (filter P (list.unfoldr g s)) \\<and>\n    ((\\<exists>s.\n         tl (list.unfoldr (local.filter_generator g) s) =\n         list.unfoldr (local.filter_generator g) s \\<and>\n         tl (filter P (list.unfoldr g s)) =\n         filter P (list.unfoldr g s)) \\<or>\n     list_all2 (=) (tl (list.unfoldr (local.filter_generator g) s))\n      (tl (filter P (list.unfoldr g s))))", "by simp"], ["proof (state)\nthis:\n  hd (list.unfoldr (local.filter_generator g) s) =\n  hd (filter P (list.unfoldr g s)) \\<and>\n  ((\\<exists>s.\n       tl (list.unfoldr (local.filter_generator g) s) =\n       list.unfoldr (local.filter_generator g) s \\<and>\n       tl (filter P (list.unfoldr g s)) = filter P (list.unfoldr g s)) \\<or>\n   list_all2 (=) (tl (list.unfoldr (local.filter_generator g) s))\n    (tl (filter P (list.unfoldr g s))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hd (list.unfoldr (local.filter_generator g) s) =\n  hd (filter P (list.unfoldr g s)) \\<and>\n  ((\\<exists>s.\n       tl (list.unfoldr (local.filter_generator g) s) =\n       list.unfoldr (local.filter_generator g) s \\<and>\n       tl (filter P (list.unfoldr g s)) = filter P (list.unfoldr g s)) \\<or>\n   list_all2 (=) (tl (list.unfoldr (local.filter_generator g) s))\n    (tl (filter P (list.unfoldr g s))))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Destroying lists\\<close>"], ["", "definition hd_fusion :: \"('a, 's) generator \\<Rightarrow> 's \\<Rightarrow> 'a\"\nwhere \"hd_fusion g s = hd (list.unfoldr g s)\""], ["", "lemma hd_fusion_code [code]:\n  \"hd_fusion g s = (if list.has_next g s then fst (list.next g s) else undefined)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd_fusion g s =\n    (if list.has_next g s then fst (list.next g s) else undefined)", "unfolding hd_fusion_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (list.unfoldr g s) =\n    (if list.has_next g s then fst (list.next g s) else undefined)", "by(subst list.unfoldr.simps)(simp add: hd_def split_beta)"], ["", "declare hd_fusion_def [symmetric, code_unfold]"], ["", "definition fold_fusion :: \"('a, 's) generator \\<Rightarrow> ('a \\<Rightarrow> 'b \\<Rightarrow> 'b) \\<Rightarrow> 's \\<Rightarrow> 'b \\<Rightarrow> 'b\"\nwhere \"fold_fusion g f s = fold f (list.unfoldr g s)\""], ["", "lemma fold_fusion_code [code]:\n  \"fold_fusion g f s b =\n  (if list.has_next g s then\n     let (x, s') = list.next g s\n     in fold_fusion g f s' (f x b)\n   else b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold_fusion g f s b =\n    (if list.has_next g s\n     then let (x, s') = list.next g s in fold_fusion g f s' (f x b) else b)", "unfolding fold_fusion_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fold f (list.unfoldr g s) b =\n    (if list.has_next g s\n     then let (x, s') = list.next g s in fold f (list.unfoldr g s') (f x b)\n     else b)", "by(subst list.unfoldr.simps)(simp add: split_beta)"], ["", "declare fold_fusion_def[symmetric, code_unfold]"], ["", "definition gen_length_fusion :: \"('a, 's) generator \\<Rightarrow> nat \\<Rightarrow> 's \\<Rightarrow> nat\"\nwhere \"gen_length_fusion g n s = n + length (list.unfoldr g s)\""], ["", "lemma gen_length_fusion_code [code]:\n  \"gen_length_fusion g n s =\n  (if list.has_next g s then gen_length_fusion g (Suc n) (snd (list.next g s)) else n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_length_fusion g n s =\n    (if list.has_next g s\n     then gen_length_fusion g (Suc n) (snd (list.next g s)) else n)", "unfolding gen_length_fusion_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. n + length (list.unfoldr g s) =\n    (if list.has_next g s\n     then Suc n + length (list.unfoldr g (snd (list.next g s))) else n)", "by(subst list.unfoldr.simps)(simp add: split_beta)"], ["", "definition length_fusion :: \"('a, 's) generator \\<Rightarrow> 's \\<Rightarrow> nat\"\nwhere \"length_fusion g s = length (list.unfoldr g s)\""], ["", "lemma length_fusion_code [code]:\n  \"length_fusion g = gen_length_fusion g 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length_fusion g = gen_length_fusion g 0", "by(simp add: fun_eq_iff length_fusion_def gen_length_fusion_def)"], ["", "declare length_fusion_def[symmetric, code_unfold]"], ["", "definition map_fusion :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> ('a, 's) generator \\<Rightarrow> 's \\<Rightarrow> 'b list\"\nwhere \"map_fusion f g s = map f (list.unfoldr g s)\""], ["", "lemma map_fusion_code [code]:\n  \"map_fusion f g s =\n  (if list.has_next g s then\n     let (x, s') = list.next g s\n     in f x # map_fusion f g s'\n   else [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_fusion f g s =\n    (if list.has_next g s\n     then let (x, s') = list.next g s in f x # map_fusion f g s' else [])", "unfolding map_fusion_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map f (list.unfoldr g s) =\n    (if list.has_next g s\n     then let (x, s') = list.next g s in f x # map f (list.unfoldr g s')\n     else [])", "by(subst list.unfoldr.simps)(simp add: split_beta)"], ["", "declare map_fusion_def[symmetric, code_unfold]"], ["", "definition append_fusion :: \"('a, 's1) generator \\<Rightarrow> ('a, 's2) generator \\<Rightarrow> 's1 \\<Rightarrow> 's2 \\<Rightarrow> 'a list\"\nwhere \"append_fusion g1 g2 s1 s2 = list.unfoldr g1 s1 @ list.unfoldr g2 s2\""], ["", "lemma append_fusion [code]:\n  \"append_fusion g1 g2 s1 s2 =\n  (if list.has_next g1 s1 then\n     let (x, s1') = list.next g1 s1\n     in x # append_fusion g1 g2 s1' s2\n   else list.unfoldr g2 s2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. append_fusion g1 g2 s1 s2 =\n    (if list.has_next g1 s1\n     then let (x, s1') = list.next g1 s1 in x # append_fusion g1 g2 s1' s2\n     else list.unfoldr g2 s2)", "unfolding append_fusion_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list.unfoldr g1 s1 @ list.unfoldr g2 s2 =\n    (if list.has_next g1 s1\n     then let (x, s1') = list.next g1 s1\n          in x # list.unfoldr g1 s1' @ list.unfoldr g2 s2\n     else list.unfoldr g2 s2)", "by(subst list.unfoldr.simps)(simp add: split_beta)"], ["", "declare append_fusion_def[symmetric, code_unfold]"], ["", "definition zip_fusion :: \"('a, 's1) generator \\<Rightarrow> ('b, 's2) generator \\<Rightarrow> 's1 \\<Rightarrow> 's2 \\<Rightarrow> ('a \\<times> 'b) list\"\nwhere \"zip_fusion g1 g2 s1 s2 = zip (list.unfoldr g1 s1) (list.unfoldr g2 s2)\""], ["", "lemma zip_fusion_code [code]:\n  \"zip_fusion g1 g2 s1 s2 =\n  (if list.has_next g1 s1 \\<and> list.has_next g2 s2 then\n     let (x, s1') = list.next g1 s1;\n         (y, s2') = list.next g2 s2\n     in (x, y) # zip_fusion g1 g2 s1' s2'\n   else [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zip_fusion g1 g2 s1 s2 =\n    (if list.has_next g1 s1 \\<and> list.has_next g2 s2\n     then let (x, s1') = list.next g1 s1; (y, s2') = list.next g2 s2\n          in (x, y) # zip_fusion g1 g2 s1' s2'\n     else [])", "unfolding zip_fusion_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. zip (list.unfoldr g1 s1) (list.unfoldr g2 s2) =\n    (if list.has_next g1 s1 \\<and> list.has_next g2 s2\n     then let (x, s1') = list.next g1 s1; (y, s2') = list.next g2 s2\n          in (x, y) # zip (list.unfoldr g1 s1') (list.unfoldr g2 s2')\n     else [])", "by(subst (1 2) list.unfoldr.simps)(simp add: split_beta)"], ["", "declare zip_fusion_def[symmetric, code_unfold]"], ["", "definition list_all_fusion :: \"('a, 's) generator \\<Rightarrow> ('a \\<Rightarrow> bool) \\<Rightarrow> 's \\<Rightarrow> bool\"\nwhere \"list_all_fusion g P s = List.list_all P (list.unfoldr g s)\""], ["", "lemma list_all_fusion_code [code]:\n  \"list_all_fusion g P s \\<longleftrightarrow>\n  (list.has_next g s \\<longrightarrow>\n   (let (x, s') = list.next g s\n    in P x \\<and> list_all_fusion g P s'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all_fusion g P s =\n    (list.has_next g s \\<longrightarrow>\n     (let (x, s') = list.next g s in P x \\<and> list_all_fusion g P s'))", "unfolding list_all_fusion_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all P (list.unfoldr g s) =\n    (list.has_next g s \\<longrightarrow>\n     (let (x, s') = list.next g s\n      in P x \\<and> list_all P (list.unfoldr g s')))", "by(subst list.unfoldr.simps)(simp add: split_beta)"], ["", "declare list_all_fusion_def[symmetric, code_unfold]"], ["", "definition list_all2_fusion :: \"('a \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> ('a, 's1) generator \\<Rightarrow> ('b, 's2) generator \\<Rightarrow> 's1 \\<Rightarrow> 's2 \\<Rightarrow> bool\"\nwhere\n  \"list_all2_fusion P g1 g2 s1 s2 = \n   list_all2 P (list.unfoldr g1 s1) (list.unfoldr g2 s2)\""], ["", "lemma list_all2_fusion_code [code]:\n  \"list_all2_fusion P g1 g2 s1 s2 =\n  (if list.has_next g1 s1 then\n     list.has_next g2 s2 \\<and>\n     (let (x, s1') = list.next g1 s1;\n          (y, s2') = list.next g2 s2\n      in P x y \\<and> list_all2_fusion P g1 g2 s1' s2')\n   else \\<not> list.has_next g2 s2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2_fusion P g1 g2 s1 s2 =\n    (if list.has_next g1 s1\n     then list.has_next g2 s2 \\<and>\n          (let (x, s1') = list.next g1 s1; (y, s2') = list.next g2 s2\n           in P x y \\<and> list_all2_fusion P g1 g2 s1' s2')\n     else \\<not> list.has_next g2 s2)", "unfolding list_all2_fusion_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 P (list.unfoldr g1 s1) (list.unfoldr g2 s2) =\n    (if list.has_next g1 s1\n     then list.has_next g2 s2 \\<and>\n          (let (x, s1') = list.next g1 s1; (y, s2') = list.next g2 s2\n           in P x y \\<and>\n              list_all2 P (list.unfoldr g1 s1') (list.unfoldr g2 s2'))\n     else \\<not> list.has_next g2 s2)", "by(subst (1 2) list.unfoldr.simps)(simp add: split_beta)"], ["", "declare list_all2_fusion_def[symmetric, code_unfold]"], ["", "definition singleton_list_fusion :: \"('a, 'state) generator \\<Rightarrow> 'state \\<Rightarrow> bool\"\nwhere \"singleton_list_fusion gen state = (case list.unfoldr gen state of [_] \\<Rightarrow> True | _ \\<Rightarrow> False)\""], ["", "lemma singleton_list_fusion_code [code]:\n  \"singleton_list_fusion g s \\<longleftrightarrow>\n  list.has_next g s \\<and> \\<not> list.has_next g (snd (list.next g s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. singleton_list_fusion g s =\n    (list.has_next g s \\<and> \\<not> list.has_next g (snd (list.next g s)))", "by(auto 4 5 simp add: singleton_list_fusion_def split: list.split if_split_asm prod.splits elim: list.unfoldr.elims dest: sym)"], ["", "end"]]}