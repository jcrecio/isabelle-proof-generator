{"file_name": "/home/qj213/afp-2021-10-22/thys/Containers/Map_To_Mapping.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Containers", "problem_names": ["lemma map_empty_transfer [transfer_rule]:\n  \"(pcr_mapping A B) map_empty Mapping.empty\"", "lemma eq_map_apply: \"m x \\<equiv> map_apply m x\"", "lemma map_apply_parametric [transfer_rule]:\n  \"((A ===> B) ===> A ===> B) map_apply map_apply\"", "lemma map_apply_transfer [transfer_rule]:\n  \"(pcr_mapping A B ===> A ===> rel_option B) map_apply Mapping.lookup\"", "lemma map_update_parametric [transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique A\"\n  shows \"(A ===> rel_option B ===> (A ===> rel_option B) ===> (A ===> rel_option B)) map_update map_update\"", "lemma update'_code [simp, code, code_unfold]:\n  \"update' x None = Mapping.delete x\"\n  \"update' x (Some y) = Mapping.update x y\"", "lemma map_is_empty_folds:\n  \"m = map_empty \\<longleftrightarrow> map_is_empty m\"\n  \"map_empty = m \\<longleftrightarrow> map_is_empty m\"", "lemma map_is_empty_transfer [transfer_rule]:\n  assumes \"bi_total A\"\n  shows \"(pcr_mapping A B ===> (=)) map_is_empty Mapping.is_empty\""], "translations": [["", "lemma map_empty_transfer [transfer_rule]:\n  \"(pcr_mapping A B) map_empty Mapping.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pcr_mapping A B map_empty Mapping.empty", "unfolding map_empty_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pcr_mapping A B Map.empty Mapping.empty", "by(rule Mapping.empty.transfer)"], ["", "definition map_apply :: \"('a \\<Rightarrow> 'b option) \\<Rightarrow> 'a \\<Rightarrow> 'b option\"\nwhere [code_unfold]: \"map_apply = (\\<lambda>m. m)\""], ["", "lemma eq_map_apply: \"m x \\<equiv> map_apply m x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m x \\<equiv> map_apply m x", "by(simp add: map_apply_def)"], ["", "declare eq_map_apply[symmetric, abs_def, containers_post]"], ["", "text \\<open>We cannot use @{thm [source] eq_map_apply} as a fold rule for operator identification,\n  because it would loop. We use a simproc instead.\\<close>"], ["", "ML \\<open>\nval map_apply_simproc = \n  Simplifier.make_simproc @{context} \"map_apply\"\n   {lhss = [@{term \"f x :: 'a option\"}],\n    proc = fn _ => fn ctxt => fn ct =>\n      (case Thm.term_of ct of\n        Const (@{const_name map_apply}, _) $ _ $ _ => NONE\n      | f $ x => \n          let\n            val cTr = \n              Thm.typ_of_cterm ct\n              |> dest_Type\n              |> snd |> hd\n              |> Thm.ctyp_of ctxt;\n            val cTx = Thm.ctyp_of ctxt (fastype_of x);\n            val cts = map (SOME o Thm.cterm_of ctxt) [f, x];\n          in\n            SOME (Thm.instantiate' [SOME cTr, SOME cTx] cts @{thm eq_map_apply})\n          end\n      | _ => NONE)}\n\\<close>"], ["", "lemma map_apply_parametric [transfer_rule]:\n  \"((A ===> B) ===> A ===> B) map_apply map_apply\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> B) ===> A ===> B) map_apply map_apply", "unfolding map_apply_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> B) ===> A ===> B) (\\<lambda>m. m) (\\<lambda>m. m)", "by(transfer_prover)"], ["", "lemma map_apply_transfer [transfer_rule]:\n  \"(pcr_mapping A B ===> A ===> rel_option B) map_apply Mapping.lookup\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pcr_mapping A B ===> A ===> rel_option B) map_apply Mapping.lookup", "by(auto simp add: pcr_mapping_def cr_mapping_def Mapping.lookup_def map_apply_def dest: rel_funD)"], ["", "definition map_update :: \"'a \\<Rightarrow> 'b option \\<Rightarrow> ('a \\<Rightarrow> 'b option) \\<Rightarrow> ('a \\<Rightarrow> 'b option)\"\nwhere \"map_update x y f = f(x := y)\""], ["", "lemma map_update_parametric [transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique A\"\n  shows \"(A ===> rel_option B ===> (A ===> rel_option B) ===> (A ===> rel_option B)) map_update map_update\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===>\n     rel_option B ===> (A ===> rel_option B) ===> A ===> rel_option B)\n     map_update map_update", "unfolding map_update_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===>\n     rel_option B ===> (A ===> rel_option B) ===> A ===> rel_option B)\n     (\\<lambda>x y f. f(x := y)) (\\<lambda>x y f. f(x := y))", "by transfer_prover"], ["", "context begin"], ["", "local_setup \\<open>Local_Theory.map_background_naming (Name_Space.mandatory_path \"Mapping\")\\<close>"], ["", "lift_definition update' :: \"'a \\<Rightarrow> 'b option \\<Rightarrow> ('a, 'b) mapping \\<Rightarrow> ('a, 'b) mapping\"\nis map_update parametric map_update_parametric"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma update'_code [simp, code, code_unfold]:\n  \"update' x None = Mapping.delete x\"\n  \"update' x (Some y) = Mapping.update x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. update' x None = Mapping.delete x &&&\n    update' x (Some y) = Mapping.update x y", "by(transfer, simp add: map_update_def fun_eq_iff)+"], ["", "end"], ["", "declare map_update_def[abs_def, containers_post] map_update_def[symmetric, containers_pre]"], ["", "definition map_is_empty :: \"('a \\<Rightarrow> 'b option) \\<Rightarrow> bool\"\nwhere \"map_is_empty m \\<longleftrightarrow> m = Map.empty\""], ["", "lemma map_is_empty_folds:\n  \"m = map_empty \\<longleftrightarrow> map_is_empty m\"\n  \"map_empty = m \\<longleftrightarrow> map_is_empty m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m = map_empty) = map_is_empty m &&& (map_empty = m) = map_is_empty m", "by(auto simp add: map_is_empty_def map_empty_def)"], ["", "declare map_is_empty_folds[containers_pre]\n  map_is_empty_def[abs_def, containers_post]"], ["", "lemma map_is_empty_transfer [transfer_rule]:\n  assumes \"bi_total A\"\n  shows \"(pcr_mapping A B ===> (=)) map_is_empty Mapping.is_empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pcr_mapping A B ===> (=)) map_is_empty Mapping.is_empty", "unfolding map_is_empty_def[abs_def] Mapping.is_empty_def[abs_def] dom_eq_empty_conv[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (pcr_mapping A B ===> (=)) (\\<lambda>m. dom m = {})\n     (\\<lambda>m. Mapping.keys m = {})", "by(rule rel_funI)+(auto simp del: dom_eq_empty_conv dest: rel_setD2 rel_setD1 Mapping.keys.transfer[THEN rel_funD, OF assms])"], ["", "end"], ["", "ML \\<open>\nsignature CONTAINERS = sig\n  val identify : Context.generic -> thm -> thm;\n  val identify_attribute : attribute;\nend\n\nstructure Containers: CONTAINERS =\nstruct\n\nfun identify context thm =\n  let\n    val ctxt' = Context.proof_of context\n    val ss = put_simpset HOL_basic_ss ctxt'\n    val ctxt1 = ss addsimps Containers_Pre.get ctxt' addsimprocs [map_apply_simproc]\n    val ctxt2 = ss addsimps Containers_Post.get ctxt'\n\n    (* Hack to recover Transfer.transferred function from attribute *)\n    fun transfer_transferred thm = Transfer.transferred_attribute [] (context, thm) |> snd |> the\n  in\n    thm\n    |> full_simplify ctxt1\n    |> transfer_transferred\n    |> full_simplify ctxt2\n  end\n\nval identify_attribute = Thm.rule_attribute [] identify\n\nend\n\\<close>"], ["", "attribute_setup \"containers_identify\" =\n  \\<open>Scan.succeed Containers.identify_attribute\\<close>\n  \"Transfer theorems for operator identification in Containers\""], ["", "hide_const (open) map_apply map_empty map_is_empty map_update"], ["", "hide_fact (open) map_apply_def map_empty_def eq_map_apply"], ["", "end"]]}