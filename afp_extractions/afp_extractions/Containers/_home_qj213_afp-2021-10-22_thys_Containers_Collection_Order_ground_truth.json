{"file_name": "/home/qj213/afp-2021-10-22/thys/Containers/Collection_Order.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Containers", "problem_names": ["lemma (in ccompare) ID_ccompare': \n  \"\\<And>c. ID ccompare = Some c \\<Longrightarrow> comparator c\"", "lemma (in ccompare) ID_ccompare: \n  \"\\<And>c. ID ccompare = Some c \\<Longrightarrow> class.linorder (le_of_comp c) (lt_of_comp c)\"", "lemma cless_eq_conv_cless: \n  fixes a b :: \"'a\"\n  assumes \"ID CCOMPARE('a) \\<noteq> None\"\n  shows \"cless_eq a b \\<longleftrightarrow> cless a b \\<or> a = b\"", "lemma corder_intro: \"class.linorder le lt \\<Longrightarrow> a = Some (le, lt)\\<Longrightarrow> a = Some (le',lt') \\<Longrightarrow>\n  class.linorder le' lt'\"", "lemma comparator_subst: \"c1 = c2 \\<Longrightarrow> comparator c1 \\<Longrightarrow> comparator c2\"", "lemma (in compare) compare_subst: \"\\<And> comp. compare = comp \\<Longrightarrow> comparator comp\"", "lemma is_ccompare_fun [simp]: \"\\<not> is_ccompare TYPE('a \\<Rightarrow> 'b)\"", "lemma is_ccompare_set [simp, code_post]:\n  \"is_ccompare TYPE('a set) \\<longleftrightarrow> is_ccompare TYPE('a :: ccompare)\"", "lemma ccompare_set_code [code]:\n  \"CCOMPARE('a :: ccompare set) = \n    (case ID CCOMPARE('a) of None \\<Rightarrow> None | Some _ \\<Rightarrow> Some (comp_of_ords cless_eq_set cless_set))\"", "lemma ID_ccompare_interval: \n  \"\\<lbrakk> ID CCOMPARE('a) = Some c; finite (UNIV :: 'a set) \\<rbrakk>\n  \\<Longrightarrow> class.linorder_proper_interval (le_of_comp c) (lt_of_comp c) cproper_interval\"", "lemma lt_of_comp_sum: \"lt_of_comp (comparator_sum ca cb) sx sy = (\n  case sx of Inl x \\<Rightarrow> (case sy of Inl y \\<Rightarrow> lt_of_comp ca x y | Inr y \\<Rightarrow> True)\n   | Inr x \\<Rightarrow> (case sy of Inl y \\<Rightarrow> False | Inr y \\<Rightarrow> lt_of_comp cb x y))\"", "lemma lt_of_comp_less_prod: \"lt_of_comp (comparator_prod c_a c_b) =\n  less_prod (le_of_comp c_a) (lt_of_comp c_a) (lt_of_comp c_b)\"", "lemma lt_of_comp_prod: \"lt_of_comp (comparator_prod c_a c_b) (x1,x2) (y1,y2) = \n  (lt_of_comp c_a x1 y1 \\<or> le_of_comp c_a x1 y1 \\<and> lt_of_comp c_b x2 y2)\"", "lemma infinite_UNIV_literal:\n  \"infinite (UNIV :: String.literal set)\"", "lemma lt_of_comp_option: \"lt_of_comp (comparator_option c) sx sy = (\n  case sx of None \\<Rightarrow> (case sy of None \\<Rightarrow> False | Some y \\<Rightarrow> True)\n   | Some x \\<Rightarrow> (case sy of None \\<Rightarrow> False | Some y \\<Rightarrow> lt_of_comp c x y))\"", "lemma Complement_cproper_interval_set_Complement:\n  fixes A B :: \"'a set\"\n  assumes corder: \"ID CCOMPARE('a) \\<noteq> None\"\n  shows \"cproper_interval (Some (- A)) (Some (- B)) = cproper_interval (Some B) (Some A)\""], "translations": [["", "lemma (in ccompare) ID_ccompare': \n  \"\\<And>c. ID ccompare = Some c \\<Longrightarrow> comparator c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c. ID ccompare = Some c \\<Longrightarrow> comparator c", "unfolding ID_def id_apply"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c. ccompare = Some c \\<Longrightarrow> comparator c", "using ccompare"], ["proof (prove)\nusing this:\n  ccompare = Some ?comp \\<Longrightarrow> comparator ?comp\n\ngoal (1 subgoal):\n 1. \\<And>c. ccompare = Some c \\<Longrightarrow> comparator c", "by simp"], ["", "lemma (in ccompare) ID_ccompare: \n  \"\\<And>c. ID ccompare = Some c \\<Longrightarrow> class.linorder (le_of_comp c) (lt_of_comp c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       ID ccompare = Some c \\<Longrightarrow>\n       class.linorder (le_of_comp c) (lt_of_comp c)", "by (rule comparator.linorder[OF ID_ccompare'])"], ["", "syntax \"_CCOMPARE\" :: \"type => logic\"  (\"(1CCOMPARE/(1'(_')))\")"], ["", "parse_translation \\<open>\nlet\n  fun ccompare_tr [ty] =\n     (Syntax.const @{syntax_const \"_constrain\"} $ Syntax.const @{const_syntax \"ccompare\"} $\n       (Syntax.const @{type_syntax option} $ \n         (Syntax.const @{type_syntax fun} $ ty $ \n           (Syntax.const @{type_syntax fun} $ ty $ Syntax.const @{type_syntax order}))))\n    | ccompare_tr ts = raise TERM (\"ccompare_tr\", ts);\nin [(@{syntax_const \"_CCOMPARE\"}, K ccompare_tr)] end\n\\<close>"], ["", "definition is_ccompare :: \"'a :: ccompare itself \\<Rightarrow> bool\"\nwhere \"is_ccompare _ \\<longleftrightarrow> ID CCOMPARE('a) \\<noteq> None\""], ["", "context ccompare\nbegin"], ["", "lemma cless_eq_conv_cless: \n  fixes a b :: \"'a\"\n  assumes \"ID CCOMPARE('a) \\<noteq> None\"\n  shows \"cless_eq a b \\<longleftrightarrow> cless a b \\<or> a = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cless_eq a b = (cless a b \\<or> a = b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cless_eq a b = (cless a b \\<or> a = b)", "from assms"], ["proof (chain)\npicking this:\n  ID ccompare \\<noteq> None", "interpret linorder cless_eq \"cless :: 'a \\<Rightarrow> 'a \\<Rightarrow> bool\""], ["proof (prove)\nusing this:\n  ID ccompare \\<noteq> None\n\ngoal (1 subgoal):\n 1. class.linorder cless_eq cless", "by(clarsimp simp add: ID_ccompare)"], ["proof (state)\ngoal (1 subgoal):\n 1. cless_eq a b = (cless a b \\<or> a = b)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. cless_eq a b = (cless a b \\<or> a = b)", "by(rule le_less)"], ["proof (state)\nthis:\n  cless_eq a b = (cless a b \\<or> a = b)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Generator for the @{class ccompare}--class\\<close>"], ["", "text \\<open>\nThis generator registers itself at the derive-manager for the class\n@{class ccompare}. To be more precise, one can choose whether one does not want to\nsupport a comparator by passing parameter \"no\", one wants to register an arbitrary type which\nis already in class @{class compare} using parameter \"compare\", or\none wants to generate a new comparator by passing no parameter.\nIn the last case, one demands that the type is a datatype\nand that all non-recursive types of that datatype already provide a comparator,\nwhich can usually be achieved via \"derive comparator type\" or \"derive compare type\".\n\n\n\\begin{itemize}\n\\item \\texttt{instantiation type :: (type,\\ldots,type) (no) corder}\n\\item \\texttt{instantiation datatype :: (type,\\ldots,type) corder}\n\\item \\texttt{instantiation datatype :: (compare,\\ldots,compare) (compare) corder}\n\\end{itemize}\n\nIf the parameter \"no\" is not used, then the corresponding\n@{const is_ccompare}-theorem is automatically generated and attributed with \n\\texttt{[simp, code-post]}.\n\\<close>"], ["", "text \\<open>\nTo create a new comparator, we just invoke the functionality provided by the generator.\nThe only difference is the boilerplate-code, which for the generator has to perform\nthe class instantiation for a comparator, whereas here we have to invoke the methods to \nsatisfy the corresponding locale for comparators.\n\\<close>"], ["", "text \\<open>\nThis generator can be used for arbitrary types, not just datatypes. \nWhen passing no parameters, we get same limitation as for the order generator.\n\\<close>"], ["", "lemma corder_intro: \"class.linorder le lt \\<Longrightarrow> a = Some (le, lt)\\<Longrightarrow> a = Some (le',lt') \\<Longrightarrow>\n  class.linorder le' lt'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>class.linorder le lt; a = Some (le, lt);\n     a = Some (le', lt')\\<rbrakk>\n    \\<Longrightarrow> class.linorder le' lt'", "by auto"], ["", "lemma comparator_subst: \"c1 = c2 \\<Longrightarrow> comparator c1 \\<Longrightarrow> comparator c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c1 = c2; comparator c1\\<rbrakk> \\<Longrightarrow> comparator c2", "by blast"], ["", "lemma (in compare) compare_subst: \"\\<And> comp. compare = comp \\<Longrightarrow> comparator comp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>comp. compare = comp \\<Longrightarrow> comparator comp", "using comparator_compare"], ["proof (prove)\nusing this:\n  comparator compare\n\ngoal (1 subgoal):\n 1. \\<And>comp. compare = comp \\<Longrightarrow> comparator comp", "by blast"], ["", "ML_file \\<open>ccompare_generator.ML\\<close>"], ["", "subsection \\<open>Instantiations for HOL types\\<close>"], ["", "derive (linorder) compare_order \n  Enum.finite_1 Enum.finite_2 Enum.finite_3 natural String.literal"], ["", "derive (compare) ccompare \n  unit bool nat int Enum.finite_1 Enum.finite_2 Enum.finite_3 integer natural char String.literal"], ["", "derive (no) ccompare Enum.finite_4 Enum.finite_5"], ["", "derive ccompare sum list option prod"], ["", "derive (no) ccompare \"fun\""], ["", "lemma is_ccompare_fun [simp]: \"\\<not> is_ccompare TYPE('a \\<Rightarrow> 'b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_ccompare TYPE('a \\<Rightarrow> 'b)", "by(simp add: is_ccompare_def ccompare_fun_def ID_None)"], ["", "instantiation set :: (ccompare) ccompare begin"], ["", "definition \"CCOMPARE('a set) = \n  map_option (\\<lambda> c. comp_of_ords (ord.set_less_eq (le_of_comp c)) (ord.set_less (le_of_comp c))) (ID CCOMPARE('a))\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a set, ccompare_class)", "by(intro_classes)(auto simp add: ccompare_set_def intro: comp_of_ords linorder.set_less_eq_linorder ID_ccompare)"], ["", "end"], ["", "lemma is_ccompare_set [simp, code_post]:\n  \"is_ccompare TYPE('a set) \\<longleftrightarrow> is_ccompare TYPE('a :: ccompare)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ccompare TYPE('a set) = is_ccompare TYPE('a)", "by(simp add: is_ccompare_def ccompare_set_def ID_def)"], ["", "definition cless_eq_set :: \"'a :: ccompare set \\<Rightarrow> 'a set \\<Rightarrow> bool\" \nwhere [simp, code del]: \"cless_eq_set = le_of_comp (the (ID CCOMPARE('a set)))\""], ["", "definition cless_set :: \"'a :: ccompare set \\<Rightarrow> 'a set \\<Rightarrow> bool\"\nwhere [simp, code del]: \"cless_set = lt_of_comp (the (ID CCOMPARE('a set)))\""], ["", "lemma ccompare_set_code [code]:\n  \"CCOMPARE('a :: ccompare set) = \n    (case ID CCOMPARE('a) of None \\<Rightarrow> None | Some _ \\<Rightarrow> Some (comp_of_ords cless_eq_set cless_set))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccompare =\n    (case ID ccompare of None \\<Rightarrow> None\n     | Some x \\<Rightarrow> Some (comp_of_ords cless_eq_set cless_set))", "by (clarsimp simp add: ccompare_set_def ID_Some split: option.split)"], ["", "derive (no) ccompare Predicate.pred"], ["", "subsection \\<open>Proper intervals\\<close>"], ["", "class cproper_interval = ccompare + \n  fixes cproper_interval :: \"'a option \\<Rightarrow> 'a option \\<Rightarrow> bool\"\n  assumes cproper_interval: \n  \"\\<lbrakk> ID CCOMPARE('a) \\<noteq> None; finite (UNIV :: 'a set) \\<rbrakk>\n  \\<Longrightarrow> class.proper_interval cless cproper_interval\"\nbegin"], ["", "lemma ID_ccompare_interval: \n  \"\\<lbrakk> ID CCOMPARE('a) = Some c; finite (UNIV :: 'a set) \\<rbrakk>\n  \\<Longrightarrow> class.linorder_proper_interval (le_of_comp c) (lt_of_comp c) cproper_interval\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ID ccompare = Some c; finite UNIV\\<rbrakk>\n    \\<Longrightarrow> class.linorder_proper_interval (le_of_comp c)\n                       (lt_of_comp c) cproper_interval", "using cproper_interval"], ["proof (prove)\nusing this:\n  \\<lbrakk>ID ccompare \\<noteq> None; finite UNIV\\<rbrakk>\n  \\<Longrightarrow> class.proper_interval cless cproper_interval\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ID ccompare = Some c; finite UNIV\\<rbrakk>\n    \\<Longrightarrow> class.linorder_proper_interval (le_of_comp c)\n                       (lt_of_comp c) cproper_interval", "by(simp add: ID_ccompare class.linorder_proper_interval_def)"], ["", "end"], ["", "instantiation unit :: cproper_interval begin"], ["", "definition \"cproper_interval = (proper_interval :: unit proper_interval)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(unit, cproper_interval_class)", "by intro_classes (simp add: compare_order_class.ord_defs cproper_interval_unit_def ccompare_unit_def ID_Some proper_interval_class.axioms)"], ["", "end"], ["", "instantiation bool :: cproper_interval begin"], ["", "definition \"cproper_interval = (proper_interval :: bool proper_interval)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(bool, cproper_interval_class)", "by(intro_classes)\n  (simp add: cproper_interval_bool_def ord_defs ccompare_bool_def ID_Some proper_interval_class.axioms)"], ["", "end"], ["", "instantiation nat :: cproper_interval begin"], ["", "definition \"cproper_interval = (proper_interval :: nat proper_interval)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(nat, cproper_interval_class)", "by intro_classes simp"], ["", "end"], ["", "instantiation int :: cproper_interval begin"], ["", "definition \"cproper_interval = (proper_interval :: int proper_interval)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(int, cproper_interval_class)", "by intro_classes \n  (simp add: cproper_interval_int_def ord_defs ccompare_int_def ID_Some proper_interval_class.axioms)"], ["", "end"], ["", "instantiation integer :: cproper_interval begin"], ["", "definition \"cproper_interval = (proper_interval :: integer proper_interval)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(integer, cproper_interval_class)", "by intro_classes \n  (simp add: cproper_interval_integer_def ord_defs ccompare_integer_def ID_Some proper_interval_class.axioms)"], ["", "end"], ["", "instantiation natural :: cproper_interval begin"], ["", "definition \"cproper_interval = (proper_interval :: natural proper_interval)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(natural, cproper_interval_class)", "by intro_classes (simp add: cproper_interval_natural_def ord_defs ccompare_natural_def ID_Some proper_interval_class.axioms)"], ["", "end"], ["", "instantiation char :: cproper_interval begin"], ["", "definition \"cproper_interval = (proper_interval :: char proper_interval)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(char, cproper_interval_class)", "by intro_classes (simp add: cproper_interval_char_def ord_defs ccompare_char_def ID_Some proper_interval_class.axioms)"], ["", "end"], ["", "instantiation Enum.finite_1 :: cproper_interval begin"], ["", "definition \"cproper_interval = (proper_interval :: Enum.finite_1 proper_interval)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(Enum.finite_1, cproper_interval_class)", "by intro_classes (simp add: cproper_interval_finite_1_def ord_defs ccompare_finite_1_def ID_Some proper_interval_class.axioms)"], ["", "end"], ["", "instantiation Enum.finite_2 :: cproper_interval begin"], ["", "definition \"cproper_interval = (proper_interval :: Enum.finite_2 proper_interval)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(Enum.finite_2, cproper_interval_class)", "by intro_classes (simp add: cproper_interval_finite_2_def ord_defs ccompare_finite_2_def ID_Some proper_interval_class.axioms)"], ["", "end"], ["", "instantiation Enum.finite_3 :: cproper_interval begin"], ["", "definition \"cproper_interval = (proper_interval :: Enum.finite_3 proper_interval)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(Enum.finite_3, cproper_interval_class)", "by intro_classes (simp add: cproper_interval_finite_3_def ord_defs ccompare_finite_3_def ID_Some proper_interval_class.axioms)"], ["", "end"], ["", "instantiation Enum.finite_4 :: cproper_interval begin"], ["", "definition \"(cproper_interval :: Enum.finite_4 proper_interval) _ _ = undefined\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(Enum.finite_4, cproper_interval_class)", "by intro_classes(simp add: ord_defs ccompare_finite_4_def ID_None)"], ["", "end"], ["", "instantiation Enum.finite_5 :: cproper_interval begin"], ["", "definition \"(cproper_interval :: Enum.finite_5 proper_interval) _ _ = undefined\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(Enum.finite_5, cproper_interval_class)", "by intro_classes(simp add: ord_defs ccompare_finite_5_def ID_None)"], ["", "end"], ["", "lemma lt_of_comp_sum: \"lt_of_comp (comparator_sum ca cb) sx sy = (\n  case sx of Inl x \\<Rightarrow> (case sy of Inl y \\<Rightarrow> lt_of_comp ca x y | Inr y \\<Rightarrow> True)\n   | Inr x \\<Rightarrow> (case sy of Inl y \\<Rightarrow> False | Inr y \\<Rightarrow> lt_of_comp cb x y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt_of_comp (comparator_sum ca cb) sx sy =\n    (case sx of\n     Inl x \\<Rightarrow>\n       case sy of Inl y \\<Rightarrow> lt_of_comp ca x y\n       | Inr y \\<Rightarrow> True\n     | Inr x \\<Rightarrow>\n         case sy of Inl y \\<Rightarrow> False\n         | Inr y \\<Rightarrow> lt_of_comp cb x y)", "by (simp add: lt_of_comp_def le_of_comp_def split: sum.split)"], ["", "instantiation sum :: (cproper_interval, cproper_interval) cproper_interval begin"], ["", "fun cproper_interval_sum :: \"('a + 'b) proper_interval\" where\n  \"cproper_interval_sum None None \\<longleftrightarrow> True\"\n| \"cproper_interval_sum None (Some (Inl x)) \\<longleftrightarrow> cproper_interval None (Some x)\"\n| \"cproper_interval_sum None (Some (Inr y)) \\<longleftrightarrow> True\"\n| \"cproper_interval_sum (Some (Inl x)) None \\<longleftrightarrow> True\"\n| \"cproper_interval_sum (Some (Inl x)) (Some (Inl y)) \\<longleftrightarrow> cproper_interval (Some x) (Some y)\"\n| \"cproper_interval_sum (Some (Inl x)) (Some (Inr y)) \\<longleftrightarrow> cproper_interval (Some x) None \\<or> cproper_interval None (Some y)\"\n| \"cproper_interval_sum (Some (Inr y)) None \\<longleftrightarrow> cproper_interval (Some y) None\"\n| \"cproper_interval_sum (Some (Inr y)) (Some (Inl x)) \\<longleftrightarrow> False\"\n| \"cproper_interval_sum (Some (Inr x)) (Some (Inr y)) \\<longleftrightarrow> cproper_interval (Some x) (Some y)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a + 'b, cproper_interval_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>ID ccompare \\<noteq> None; finite UNIV\\<rbrakk>\n    \\<Longrightarrow> class.proper_interval cless cproper_interval", "assume \"ID CCOMPARE('a + 'b) \\<noteq> None\" \"finite (UNIV :: ('a + 'b) set)\""], ["proof (state)\nthis:\n  ID ccompare \\<noteq> None\n  finite UNIV\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ID ccompare \\<noteq> None; finite UNIV\\<rbrakk>\n    \\<Longrightarrow> class.proper_interval cless cproper_interval", "then"], ["proof (chain)\npicking this:\n  ID ccompare \\<noteq> None\n  finite UNIV", "obtain c_a c_b\n    where A: \"ID CCOMPARE('a) = Some c_a\" \"finite (UNIV :: 'a set)\"\n    and B: \"ID CCOMPARE('b) = Some c_b\" \"finite (UNIV :: 'b set)\""], ["proof (prove)\nusing this:\n  ID ccompare \\<noteq> None\n  finite UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>c_a c_b.\n        \\<lbrakk>ID ccompare = Some c_a; finite UNIV;\n         ID ccompare = Some c_b; finite UNIV\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp add: ccompare_sum_def ID_Some ID_None split: option.split_asm)"], ["proof (state)\nthis:\n  ID ccompare = Some c_a\n  finite UNIV\n  ID ccompare = Some c_b\n  finite UNIV\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ID ccompare \\<noteq> None; finite UNIV\\<rbrakk>\n    \\<Longrightarrow> class.proper_interval cless cproper_interval", "note [simp] = proper_interval.proper_interval_simps[OF cproper_interval] \n    lt_of_comp_sum ccompare_sum_def ID_Some\n    and [split] = sum.split"], ["proof (state)\nthis:\n  \\<lbrakk>ID ccompare \\<noteq> None; finite UNIV\\<rbrakk>\n  \\<Longrightarrow> cproper_interval None None = True\n  \\<lbrakk>ID ccompare \\<noteq> None; finite UNIV\\<rbrakk>\n  \\<Longrightarrow> cproper_interval None (Some ?y) =\n                    (\\<exists>z. cless z ?y)\n  \\<lbrakk>ID ccompare \\<noteq> None; finite UNIV\\<rbrakk>\n  \\<Longrightarrow> cproper_interval (Some ?x) None =\n                    (\\<exists>z. cless ?x z)\n  \\<lbrakk>ID ccompare \\<noteq> None; finite UNIV\\<rbrakk>\n  \\<Longrightarrow> cproper_interval (Some ?x) (Some ?y) =\n                    (\\<exists>z. cless ?x z \\<and> cless z ?y)\n  lt_of_comp (comparator_sum ?ca ?cb) ?sx ?sy =\n  (case ?sx of\n   Inl x \\<Rightarrow>\n     case ?sy of Inl y \\<Rightarrow> lt_of_comp ?ca x y\n     | Inr y \\<Rightarrow> True\n   | Inr x \\<Rightarrow>\n       case ?sy of Inl y \\<Rightarrow> False\n       | Inr y \\<Rightarrow> lt_of_comp ?cb x y)\n  ccompare \\<equiv>\n  case ID ccompare of None \\<Rightarrow> None\n  | Some comp_'a \\<Rightarrow>\n      case ID ccompare of None \\<Rightarrow> None\n      | Some comp_'b \\<Rightarrow> Some (comparator_sum comp_'a comp_'b)\n  ID (Some ?x) = Some ?x\n  ?P (case ?sum of Inl x \\<Rightarrow> ?f1.0 x\n      | Inr x \\<Rightarrow> ?f2.0 x) =\n  ((\\<forall>x1. ?sum = Inl x1 \\<longrightarrow> ?P (?f1.0 x1)) \\<and>\n   (\\<forall>x2. ?sum = Inr x2 \\<longrightarrow> ?P (?f2.0 x2)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ID ccompare \\<noteq> None; finite UNIV\\<rbrakk>\n    \\<Longrightarrow> class.proper_interval cless cproper_interval", "show \"class.proper_interval cless (cproper_interval :: ('a + 'b) proper_interval)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.proper_interval cless cproper_interval", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. cproper_interval None None = True\n 2. \\<And>y. cproper_interval None (Some y) = (\\<exists>z. cless z y)\n 3. \\<And>x. cproper_interval (Some x) None = (\\<exists>z. cless x z)\n 4. \\<And>x y.\n       cproper_interval (Some x) (Some y) =\n       (\\<exists>z. cless x z \\<and> cless z y)", "fix y :: \"'a + 'b\""], ["proof (state)\ngoal (4 subgoals):\n 1. cproper_interval None None = True\n 2. \\<And>y. cproper_interval None (Some y) = (\\<exists>z. cless z y)\n 3. \\<And>x. cproper_interval (Some x) None = (\\<exists>z. cless x z)\n 4. \\<And>x y.\n       cproper_interval (Some x) (Some y) =\n       (\\<exists>z. cless x z \\<and> cless z y)", "show \"cproper_interval None (Some y) = (\\<exists>z. cless z y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cproper_interval None (Some y) = (\\<exists>z. cless z y)", "using A B"], ["proof (prove)\nusing this:\n  ID ccompare = Some c_a\n  finite UNIV\n  ID ccompare = Some c_b\n  finite UNIV\n\ngoal (1 subgoal):\n 1. cproper_interval None (Some y) = (\\<exists>z. cless z y)", "by(cases y)(auto, case_tac z, auto)"], ["proof (state)\nthis:\n  cproper_interval None (Some y) = (\\<exists>z. cless z y)\n\ngoal (3 subgoals):\n 1. cproper_interval None None = True\n 2. \\<And>x. cproper_interval (Some x) None = (\\<exists>z. cless x z)\n 3. \\<And>x y.\n       cproper_interval (Some x) (Some y) =\n       (\\<exists>z. cless x z \\<and> cless z y)", "fix x :: \"'a + 'b\""], ["proof (state)\ngoal (3 subgoals):\n 1. cproper_interval None None = True\n 2. \\<And>x. cproper_interval (Some x) None = (\\<exists>z. cless x z)\n 3. \\<And>x y.\n       cproper_interval (Some x) (Some y) =\n       (\\<exists>z. cless x z \\<and> cless z y)", "show \"cproper_interval (Some x) None = (\\<exists>z. cless x z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cproper_interval (Some x) None = (\\<exists>z. cless x z)", "using A B"], ["proof (prove)\nusing this:\n  ID ccompare = Some c_a\n  finite UNIV\n  ID ccompare = Some c_b\n  finite UNIV\n\ngoal (1 subgoal):\n 1. cproper_interval (Some x) None = (\\<exists>z. cless x z)", "by(cases x)(auto, case_tac z, auto)"], ["proof (state)\nthis:\n  cproper_interval (Some x) None = (\\<exists>z. cless x z)\n\ngoal (2 subgoals):\n 1. cproper_interval None None = True\n 2. \\<And>x y.\n       cproper_interval (Some x) (Some y) =\n       (\\<exists>z. cless x z \\<and> cless z y)", "show \"cproper_interval (Some x) (Some y) = (\\<exists>z. cless x z \\<and> cless z y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cproper_interval (Some x) (Some y) =\n    (\\<exists>z. cless x z \\<and> cless z y)", "using A B"], ["proof (prove)\nusing this:\n  ID ccompare = Some c_a\n  finite UNIV\n  ID ccompare = Some c_b\n  finite UNIV\n\ngoal (1 subgoal):\n 1. cproper_interval (Some x) (Some y) =\n    (\\<exists>z. cless x z \\<and> cless z y)", "by(cases x)(case_tac [!] y, auto, case_tac [!] z, auto)"], ["proof (state)\nthis:\n  cproper_interval (Some x) (Some y) =\n  (\\<exists>z. cless x z \\<and> cless z y)\n\ngoal (1 subgoal):\n 1. cproper_interval None None = True", "qed simp"], ["proof (state)\nthis:\n  class.proper_interval cless cproper_interval\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma lt_of_comp_less_prod: \"lt_of_comp (comparator_prod c_a c_b) =\n  less_prod (le_of_comp c_a) (lt_of_comp c_a) (lt_of_comp c_b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt_of_comp (comparator_prod c_a c_b) =\n    less_prod (le_of_comp c_a) (lt_of_comp c_a) (lt_of_comp c_b)", "unfolding less_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lt_of_comp (comparator_prod c_a c_b) =\n    (\\<lambda>(x1, x2) (y1, y2).\n        lt_of_comp c_a x1 y1 \\<or>\n        le_of_comp c_a x1 y1 \\<and> lt_of_comp c_b x2 y2)", "by (intro ext, auto simp: lt_of_comp_def le_of_comp_def split: order.split_asm prod.split)"], ["", "lemma lt_of_comp_prod: \"lt_of_comp (comparator_prod c_a c_b) (x1,x2) (y1,y2) = \n  (lt_of_comp c_a x1 y1 \\<or> le_of_comp c_a x1 y1 \\<and> lt_of_comp c_b x2 y2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt_of_comp (comparator_prod c_a c_b) (x1, x2) (y1, y2) =\n    (lt_of_comp c_a x1 y1 \\<or>\n     le_of_comp c_a x1 y1 \\<and> lt_of_comp c_b x2 y2)", "unfolding lt_of_comp_less_prod less_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (x1, x2) of\n     (x1, x2) \\<Rightarrow>\n       \\<lambda>(y1, y2).\n          lt_of_comp c_a x1 y1 \\<or>\n          le_of_comp c_a x1 y1 \\<and> lt_of_comp c_b x2 y2)\n     (y1, y2) =\n    (lt_of_comp c_a x1 y1 \\<or>\n     le_of_comp c_a x1 y1 \\<and> lt_of_comp c_b x2 y2)", "by simp"], ["", "instantiation prod :: (cproper_interval, cproper_interval) cproper_interval begin"], ["", "fun cproper_interval_prod :: \"('a \\<times> 'b) proper_interval\" where\n  \"cproper_interval_prod None None \\<longleftrightarrow> True\"\n| \"cproper_interval_prod None (Some (y1, y2)) \\<longleftrightarrow> cproper_interval None (Some y1) \\<or> cproper_interval None (Some y2)\"\n| \"cproper_interval_prod (Some (x1, x2)) None \\<longleftrightarrow> cproper_interval (Some x1) None \\<or> cproper_interval (Some x2) None\"\n| \"cproper_interval_prod (Some (x1, x2)) (Some (y1, y2)) \\<longleftrightarrow> \n   cproper_interval (Some x1) (Some y1) \\<or> \n   cless x1 y1 \\<and> (cproper_interval (Some x2) None \\<or> cproper_interval None (Some y2)) \\<or>\n   \\<not> cless y1 x1 \\<and> cproper_interval (Some x2) (Some y2)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<times> 'b, cproper_interval_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>ID ccompare \\<noteq> None; finite UNIV\\<rbrakk>\n    \\<Longrightarrow> class.proper_interval cless cproper_interval", "assume \"ID CCOMPARE('a \\<times> 'b) \\<noteq> None\" \"finite (UNIV :: ('a \\<times> 'b) set)\""], ["proof (state)\nthis:\n  ID ccompare \\<noteq> None\n  finite UNIV\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ID ccompare \\<noteq> None; finite UNIV\\<rbrakk>\n    \\<Longrightarrow> class.proper_interval cless cproper_interval", "then"], ["proof (chain)\npicking this:\n  ID ccompare \\<noteq> None\n  finite UNIV", "obtain c_a c_b \n    where A: \"ID CCOMPARE('a) = Some c_a\" \"finite (UNIV :: 'a set)\"\n    and B: \"ID CCOMPARE('b) = Some c_b\" \"finite (UNIV :: 'b set)\""], ["proof (prove)\nusing this:\n  ID ccompare \\<noteq> None\n  finite UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>c_a c_b.\n        \\<lbrakk>ID ccompare = Some c_a; finite UNIV;\n         ID ccompare = Some c_b; finite UNIV\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp add: ccompare_prod_def ID_Some ID_None finite_prod split: option.split_asm)"], ["proof (state)\nthis:\n  ID ccompare = Some c_a\n  finite UNIV\n  ID ccompare = Some c_b\n  finite UNIV\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ID ccompare \\<noteq> None; finite UNIV\\<rbrakk>\n    \\<Longrightarrow> class.proper_interval cless cproper_interval", "interpret a: linorder \"le_of_comp c_a\" \"lt_of_comp c_a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.linorder (le_of_comp c_a) (lt_of_comp c_a)", "by(rule ID_ccompare)(rule A)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>ID ccompare \\<noteq> None; finite UNIV\\<rbrakk>\n    \\<Longrightarrow> class.proper_interval cless cproper_interval", "note [simp] = proper_interval.proper_interval_simps[OF cproper_interval] \n    ccompare_prod_def lt_of_comp_prod ID_Some"], ["proof (state)\nthis:\n  \\<lbrakk>ID ccompare \\<noteq> None; finite UNIV\\<rbrakk>\n  \\<Longrightarrow> cproper_interval None None = True\n  \\<lbrakk>ID ccompare \\<noteq> None; finite UNIV\\<rbrakk>\n  \\<Longrightarrow> cproper_interval None (Some ?y) =\n                    (\\<exists>z. cless z ?y)\n  \\<lbrakk>ID ccompare \\<noteq> None; finite UNIV\\<rbrakk>\n  \\<Longrightarrow> cproper_interval (Some ?x) None =\n                    (\\<exists>z. cless ?x z)\n  \\<lbrakk>ID ccompare \\<noteq> None; finite UNIV\\<rbrakk>\n  \\<Longrightarrow> cproper_interval (Some ?x) (Some ?y) =\n                    (\\<exists>z. cless ?x z \\<and> cless z ?y)\n  ccompare \\<equiv>\n  case ID ccompare of None \\<Rightarrow> None\n  | Some comp_'a \\<Rightarrow>\n      case ID ccompare of None \\<Rightarrow> None\n      | Some comp_'b \\<Rightarrow> Some (comparator_prod comp_'a comp_'b)\n  lt_of_comp (comparator_prod ?c_a ?c_b) (?x1.0, ?x2.0) (?y1.0, ?y2.0) =\n  (lt_of_comp ?c_a ?x1.0 ?y1.0 \\<or>\n   le_of_comp ?c_a ?x1.0 ?y1.0 \\<and> lt_of_comp ?c_b ?x2.0 ?y2.0)\n  ID (Some ?x) = Some ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ID ccompare \\<noteq> None; finite UNIV\\<rbrakk>\n    \\<Longrightarrow> class.proper_interval cless cproper_interval", "show \"class.proper_interval cless (cproper_interval :: ('a \\<times> 'b) proper_interval)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.proper_interval cless cproper_interval", "using A B"], ["proof (prove)\nusing this:\n  ID ccompare = Some c_a\n  finite UNIV\n  ID ccompare = Some c_b\n  finite UNIV\n\ngoal (1 subgoal):\n 1. class.proper_interval cless cproper_interval", "by (unfold_locales, auto 4 4)"], ["proof (state)\nthis:\n  class.proper_interval cless cproper_interval\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instantiation list :: (ccompare) cproper_interval begin"], ["", "definition cproper_interval_list :: \"'a list proper_interval\"\nwhere \"cproper_interval_list xso yso = undefined\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a list, cproper_interval_class)", "by(intro_classes)(simp add: infinite_UNIV_listI)"], ["", "end"], ["", "lemma infinite_UNIV_literal:\n  \"infinite (UNIV :: String.literal set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite UNIV", "by (fact infinite_literal)"], ["", "instantiation String.literal :: cproper_interval begin"], ["", "definition cproper_interval_literal :: \"String.literal proper_interval\"\nwhere \"cproper_interval_literal xso yso = undefined\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(String.literal, cproper_interval_class)", "by(intro_classes)(simp add: infinite_UNIV_literal)"], ["", "end"], ["", "lemma lt_of_comp_option: \"lt_of_comp (comparator_option c) sx sy = (\n  case sx of None \\<Rightarrow> (case sy of None \\<Rightarrow> False | Some y \\<Rightarrow> True)\n   | Some x \\<Rightarrow> (case sy of None \\<Rightarrow> False | Some y \\<Rightarrow> lt_of_comp c x y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt_of_comp (comparator_option c) sx sy =\n    (case sx of\n     None \\<Rightarrow>\n       case sy of None \\<Rightarrow> False | Some y \\<Rightarrow> True\n     | Some x \\<Rightarrow>\n         case sy of None \\<Rightarrow> False\n         | Some y \\<Rightarrow> lt_of_comp c x y)", "by (simp add: lt_of_comp_def le_of_comp_def split: option.split)"], ["", "instantiation option :: (cproper_interval) cproper_interval begin"], ["", "fun cproper_interval_option :: \"'a option proper_interval\" where\n  \"cproper_interval_option None None \\<longleftrightarrow> True\"\n| \"cproper_interval_option None (Some x) \\<longleftrightarrow> x \\<noteq> None\"\n| \"cproper_interval_option (Some x) None \\<longleftrightarrow> cproper_interval x None\"\n| \"cproper_interval_option (Some x) (Some None) \\<longleftrightarrow> False\"\n| \"cproper_interval_option (Some x) (Some (Some y)) \\<longleftrightarrow> cproper_interval x (Some y)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a option, cproper_interval_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>ID ccompare \\<noteq> None; finite UNIV\\<rbrakk>\n    \\<Longrightarrow> class.proper_interval cless cproper_interval", "assume \"ID CCOMPARE('a option) \\<noteq> None\" \"finite (UNIV :: 'a option set)\""], ["proof (state)\nthis:\n  ID ccompare \\<noteq> None\n  finite UNIV\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ID ccompare \\<noteq> None; finite UNIV\\<rbrakk>\n    \\<Longrightarrow> class.proper_interval cless cproper_interval", "then"], ["proof (chain)\npicking this:\n  ID ccompare \\<noteq> None\n  finite UNIV", "obtain c_a\n    where A: \"ID CCOMPARE('a) = Some c_a\" \"finite (UNIV :: 'a set)\""], ["proof (prove)\nusing this:\n  ID ccompare \\<noteq> None\n  finite UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>c_a.\n        \\<lbrakk>ID ccompare = Some c_a; finite UNIV\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: ccompare_option_def ID_def split: option.split_asm)"], ["proof (state)\nthis:\n  ID ccompare = Some c_a\n  finite UNIV\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ID ccompare \\<noteq> None; finite UNIV\\<rbrakk>\n    \\<Longrightarrow> class.proper_interval cless cproper_interval", "note [simp] = proper_interval.proper_interval_simps[OF cproper_interval] \n    ccompare_option_def lt_of_comp_option ID_Some"], ["proof (state)\nthis:\n  \\<lbrakk>ID ccompare \\<noteq> None; finite UNIV\\<rbrakk>\n  \\<Longrightarrow> cproper_interval None None = True\n  \\<lbrakk>ID ccompare \\<noteq> None; finite UNIV\\<rbrakk>\n  \\<Longrightarrow> cproper_interval None (Some ?y) =\n                    (\\<exists>z. cless z ?y)\n  \\<lbrakk>ID ccompare \\<noteq> None; finite UNIV\\<rbrakk>\n  \\<Longrightarrow> cproper_interval (Some ?x) None =\n                    (\\<exists>z. cless ?x z)\n  \\<lbrakk>ID ccompare \\<noteq> None; finite UNIV\\<rbrakk>\n  \\<Longrightarrow> cproper_interval (Some ?x) (Some ?y) =\n                    (\\<exists>z. cless ?x z \\<and> cless z ?y)\n  ccompare \\<equiv>\n  case ID ccompare of None \\<Rightarrow> None\n  | Some comp_'a \\<Rightarrow> Some (comparator_option comp_'a)\n  lt_of_comp (comparator_option ?c) ?sx ?sy =\n  (case ?sx of\n   None \\<Rightarrow>\n     case ?sy of None \\<Rightarrow> False | Some y \\<Rightarrow> True\n   | Some x \\<Rightarrow>\n       case ?sy of None \\<Rightarrow> False\n       | Some y \\<Rightarrow> lt_of_comp ?c x y)\n  ID (Some ?x) = Some ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ID ccompare \\<noteq> None; finite UNIV\\<rbrakk>\n    \\<Longrightarrow> class.proper_interval cless cproper_interval", "show \"class.proper_interval cless (cproper_interval :: 'a option proper_interval)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.proper_interval cless cproper_interval", "using A"], ["proof (prove)\nusing this:\n  ID ccompare = Some c_a\n  finite UNIV\n\ngoal (1 subgoal):\n 1. class.proper_interval cless cproper_interval", "proof(unfold_locales)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>ID ccompare = Some c_a; finite UNIV\\<rbrakk>\n    \\<Longrightarrow> cproper_interval None None = True\n 2. \\<And>y.\n       \\<lbrakk>ID ccompare = Some c_a; finite UNIV\\<rbrakk>\n       \\<Longrightarrow> cproper_interval None (Some y) =\n                         (\\<exists>z. cless z y)\n 3. \\<And>x.\n       \\<lbrakk>ID ccompare = Some c_a; finite UNIV\\<rbrakk>\n       \\<Longrightarrow> cproper_interval (Some x) None =\n                         (\\<exists>z. cless x z)\n 4. \\<And>x y.\n       \\<lbrakk>ID ccompare = Some c_a; finite UNIV\\<rbrakk>\n       \\<Longrightarrow> cproper_interval (Some x) (Some y) =\n                         (\\<exists>z. cless x z \\<and> cless z y)", "fix x y :: \"'a option\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>ID ccompare = Some c_a; finite UNIV\\<rbrakk>\n    \\<Longrightarrow> cproper_interval None None = True\n 2. \\<And>y.\n       \\<lbrakk>ID ccompare = Some c_a; finite UNIV\\<rbrakk>\n       \\<Longrightarrow> cproper_interval None (Some y) =\n                         (\\<exists>z. cless z y)\n 3. \\<And>x.\n       \\<lbrakk>ID ccompare = Some c_a; finite UNIV\\<rbrakk>\n       \\<Longrightarrow> cproper_interval (Some x) None =\n                         (\\<exists>z. cless x z)\n 4. \\<And>x y.\n       \\<lbrakk>ID ccompare = Some c_a; finite UNIV\\<rbrakk>\n       \\<Longrightarrow> cproper_interval (Some x) (Some y) =\n                         (\\<exists>z. cless x z \\<and> cless z y)", "show \"cproper_interval (Some x) None = (\\<exists>z. cless x z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cproper_interval (Some x) None = (\\<exists>z. cless x z)", "using A"], ["proof (prove)\nusing this:\n  ID ccompare = Some c_a\n  finite UNIV\n\ngoal (1 subgoal):\n 1. cproper_interval (Some x) None = (\\<exists>z. cless x z)", "by(cases x)(auto split: option.split intro: exI[where x=\"Some undefined\"])"], ["proof (state)\nthis:\n  cproper_interval (Some x) None = (\\<exists>z. cless x z)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>ID ccompare = Some c_a; finite UNIV\\<rbrakk>\n    \\<Longrightarrow> cproper_interval None None = True\n 2. \\<And>y.\n       \\<lbrakk>ID ccompare = Some c_a; finite UNIV\\<rbrakk>\n       \\<Longrightarrow> cproper_interval None (Some y) =\n                         (\\<exists>z. cless z y)\n 3. \\<And>x y.\n       \\<lbrakk>ID ccompare = Some c_a; finite UNIV\\<rbrakk>\n       \\<Longrightarrow> cproper_interval (Some x) (Some y) =\n                         (\\<exists>z. cless x z \\<and> cless z y)", "show \"cproper_interval (Some x) (Some y) = (\\<exists>z. cless x z \\<and> cless z y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cproper_interval (Some x) (Some y) =\n    (\\<exists>z. cless x z \\<and> cless z y)", "using A"], ["proof (prove)\nusing this:\n  ID ccompare = Some c_a\n  finite UNIV\n\ngoal (1 subgoal):\n 1. cproper_interval (Some x) (Some y) =\n    (\\<exists>z. cless x z \\<and> cless z y)", "by(cases x y rule: option.exhaust[case_product option.exhaust])(auto cong: option.case_cong split: option.split)"], ["proof (state)\nthis:\n  cproper_interval (Some x) (Some y) =\n  (\\<exists>z. cless x z \\<and> cless z y)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ID ccompare = Some c_a; finite UNIV\\<rbrakk>\n    \\<Longrightarrow> cproper_interval None None = True\n 2. \\<And>y.\n       \\<lbrakk>ID ccompare = Some c_a; finite UNIV\\<rbrakk>\n       \\<Longrightarrow> cproper_interval None (Some y) =\n                         (\\<exists>z. cless z y)", "qed(auto split: option.splits)"], ["proof (state)\nthis:\n  class.proper_interval cless cproper_interval\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instantiation set :: (cproper_interval) cproper_interval begin"], ["", "fun cproper_interval_set :: \"'a set proper_interval\" where\n  [code]: \"cproper_interval_set None None \\<longleftrightarrow> True\"\n| [code]: \"cproper_interval_set None (Some B) \\<longleftrightarrow> (B \\<noteq> {})\"\n| [code]: \"cproper_interval_set (Some A) None \\<longleftrightarrow> (A \\<noteq> UNIV)\"\n| cproper_interval_set_Some_Some [code del]: \\<comment> \\<open>Refine for concrete implementations\\<close>\n  \"cproper_interval_set (Some A) (Some B) \\<longleftrightarrow> finite (UNIV :: 'a set) \\<and> (\\<exists>C. cless A C \\<and> cless C B)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a set, cproper_interval_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>ID ccompare \\<noteq> None; finite UNIV\\<rbrakk>\n    \\<Longrightarrow> class.proper_interval cless cproper_interval", "assume \"ID CCOMPARE('a set) \\<noteq> None\" \"finite (UNIV :: 'a set set)\""], ["proof (state)\nthis:\n  ID ccompare \\<noteq> None\n  finite UNIV\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ID ccompare \\<noteq> None; finite UNIV\\<rbrakk>\n    \\<Longrightarrow> class.proper_interval cless cproper_interval", "then"], ["proof (chain)\npicking this:\n  ID ccompare \\<noteq> None\n  finite UNIV", "obtain c_a\n    where A: \"ID CCOMPARE('a) = Some c_a\" \"finite (UNIV :: 'a set)\""], ["proof (prove)\nusing this:\n  ID ccompare \\<noteq> None\n  finite UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>c_a.\n        \\<lbrakk>ID ccompare = Some c_a; finite UNIV\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: ccompare_set_def ID_def Finite_Set.finite_set)"], ["proof (state)\nthis:\n  ID ccompare = Some c_a\n  finite UNIV\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ID ccompare \\<noteq> None; finite UNIV\\<rbrakk>\n    \\<Longrightarrow> class.proper_interval cless cproper_interval", "interpret a: linorder \"le_of_comp c_a\" \"lt_of_comp c_a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.linorder (le_of_comp c_a) (lt_of_comp c_a)", "by(rule ID_ccompare)(rule A)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>ID ccompare \\<noteq> None; finite UNIV\\<rbrakk>\n    \\<Longrightarrow> class.proper_interval cless cproper_interval", "note [simp] = proper_interval.proper_interval_simps[OF cproper_interval] ccompare_set_def \n    ID_Some lt_of_comp_of_ords"], ["proof (state)\nthis:\n  \\<lbrakk>ID ccompare \\<noteq> None; finite UNIV\\<rbrakk>\n  \\<Longrightarrow> cproper_interval None None = True\n  \\<lbrakk>ID ccompare \\<noteq> None; finite UNIV\\<rbrakk>\n  \\<Longrightarrow> cproper_interval None (Some ?y) =\n                    (\\<exists>z. cless z ?y)\n  \\<lbrakk>ID ccompare \\<noteq> None; finite UNIV\\<rbrakk>\n  \\<Longrightarrow> cproper_interval (Some ?x) None =\n                    (\\<exists>z. cless ?x z)\n  \\<lbrakk>ID ccompare \\<noteq> None; finite UNIV\\<rbrakk>\n  \\<Longrightarrow> cproper_interval (Some ?x) (Some ?y) =\n                    (\\<exists>z. cless ?x z \\<and> cless z ?y)\n  ccompare =\n  map_option\n   (\\<lambda>c.\n       comp_of_ords (ord.set_less_eq (le_of_comp c))\n        (ord.set_less (le_of_comp c)))\n   (ID ccompare)\n  ID (Some ?x) = Some ?x\n  lt_of_comp (comp_of_ords ?le ?lt) = ?lt\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ID ccompare \\<noteq> None; finite UNIV\\<rbrakk>\n    \\<Longrightarrow> class.proper_interval cless cproper_interval", "show \"class.proper_interval cless (cproper_interval :: 'a set proper_interval)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.proper_interval cless cproper_interval", "using A"], ["proof (prove)\nusing this:\n  ID ccompare = Some c_a\n  finite UNIV\n\ngoal (1 subgoal):\n 1. class.proper_interval cless cproper_interval", "by (unfold_locales, auto)"], ["proof (state)\nthis:\n  class.proper_interval cless cproper_interval\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Complement_cproper_interval_set_Complement:\n  fixes A B :: \"'a set\"\n  assumes corder: \"ID CCOMPARE('a) \\<noteq> None\"\n  shows \"cproper_interval (Some (- A)) (Some (- B)) = cproper_interval (Some B) (Some A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cproper_interval (Some (- A)) (Some (- B)) =\n    cproper_interval (Some B) (Some A)", "using assms"], ["proof (prove)\nusing this:\n  ID ccompare \\<noteq> None\n\ngoal (1 subgoal):\n 1. cproper_interval (Some (- A)) (Some (- B)) =\n    cproper_interval (Some B) (Some A)", "by(clarsimp simp add: ccompare_set_def ID_Some lt_of_comp_of_ords) (metis double_complement linorder.Compl_set_less_Compl[OF ID_ccompare])"], ["", "end"], ["", "instantiation \"fun\" :: (type, type) cproper_interval begin"], ["", "text \\<open>No interval checks on functions needed because we have not defined an order on them.\\<close>"], ["", "definition \"cproper_interval = (undefined :: ('a \\<Rightarrow> 'b) proper_interval)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow> 'b, cproper_interval_class)", "by(intro_classes)(simp add: ccompare_fun_def ID_None)"], ["", "end"], ["", "end"]]}