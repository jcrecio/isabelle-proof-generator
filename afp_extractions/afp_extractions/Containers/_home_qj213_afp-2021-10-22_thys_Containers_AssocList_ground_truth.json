{"file_name": "/home/qj213/afp-2021-10-22/thys/Containers/AssocList.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Containers", "problem_names": ["lemma update_conv_update_with_aux:\n  \"AList.update k v xs = update_with_aux v k (\\<lambda>_. v) xs\"", "lemma map_of_update_with_aux':\n  \"map_of (update_with_aux v k f ps) k' = ((map_of ps)(k \\<mapsto> (case map_of ps k of None \\<Rightarrow> f v | Some v \\<Rightarrow> f v))) k'\"", "lemma map_of_update_with_aux:\n  \"map_of (update_with_aux v k f ps) = (map_of ps)(k \\<mapsto> (case map_of ps k of None \\<Rightarrow> f v | Some v \\<Rightarrow> f v))\"", "lemma dom_update_with_aux: \"fst ` set (update_with_aux v k f ps) = {k} \\<union> fst ` set ps\"", "lemma distinct_update_with_aux [simp]:\n  \"distinct (map fst (update_with_aux v k f ps)) = distinct (map fst ps)\"", "lemma set_update_with_aux:\n  \"distinct (map fst xs) \n  \\<Longrightarrow> set (update_with_aux v k f xs) = (set xs - {k} \\<times> UNIV \\<union> {(k, f (case map_of xs k of None \\<Rightarrow> v | Some v \\<Rightarrow> v))})\"", "lemma set_delete_aux: \"distinct (map fst xs) \\<Longrightarrow> set (delete_aux k xs) = set xs - {k} \\<times> UNIV\"", "lemma dom_delete_aux: \"distinct (map fst ps) \\<Longrightarrow> fst ` set (delete_aux k ps) = fst ` set ps - {k}\"", "lemma distinct_delete_aux [simp]:\n  \"distinct (map fst ps) \\<Longrightarrow> distinct (map fst (delete_aux k ps))\"", "lemma map_of_delete_aux':\n  \"distinct (map fst xs) \\<Longrightarrow> map_of (delete_aux k xs) = (map_of xs)(k := None)\"", "lemma map_of_delete_aux:\n  \"distinct (map fst xs) \\<Longrightarrow> map_of (delete_aux k xs) k' = ((map_of xs)(k := None)) k'\"", "lemma delete_aux_eq_Nil_conv: \"delete_aux k ts = [] \\<longleftrightarrow> ts = [] \\<or> (\\<exists>v. ts = [(k, v)])\"", "lemma zip_with_index_from_simps [simp, code]:\n  \"zip_with_index_from n [] = []\"\n  \"zip_with_index_from n (x # xs) = (n, x) # zip_with_index_from (Suc n) xs\"", "lemma zip_with_index_from_append [simp]:\n  \"zip_with_index_from n (xs @ ys) = zip_with_index_from n xs @ zip_with_index_from (n + length xs) ys\"", "lemma zip_with_index_from_conv_nth:\n  \"zip_with_index_from n xs = map (\\<lambda>i. (n + i, xs ! i)) [0..<length xs]\"", "lemma map_of_zip_with_index_from [simp]:\n  \"map_of (zip_with_index_from n xs) i = (if i \\<ge> n \\<and> i < n + length xs then Some (xs ! (i - n)) else None)\"", "lemma map_of_map': \"map_of (map (\\<lambda>(k, v). (k, f k v)) xs) x = map_option (f x) (map_of xs x)\"", "lemma lookup_update_with [simp]: \n  \"DAList.lookup (update_with v k f al) = (DAList.lookup al)(k \\<mapsto> case DAList.lookup al k of None \\<Rightarrow> f v | Some v \\<Rightarrow> f v)\"", "lemma lookup_delete [simp]: \"DAList.lookup (delete k al) = (DAList.lookup al)(k := None)\"", "lemma finite_dom_lookup [simp, intro!]: \"finite (dom (DAList.lookup m))\"", "lemma update_conv_update_with: \"DAList.update k v = update_with v k (\\<lambda>_. v)\"", "lemma lookup_update [simp]: \"DAList.lookup (DAList.update k v al) = (DAList.lookup al)(k \\<mapsto> v)\"", "lemma dom_lookup_keys: \"dom (DAList.lookup al) = keys al\"", "lemma keys_empty [simp]: \"keys DAList.empty = {}\"", "lemma keys_update_with [simp]: \"keys (update_with v k f al) = insert k (keys al)\"", "lemma keys_update [simp]: \"keys (DAList.update k v al) = insert k (keys al)\"", "lemma keys_delete [simp]: \"keys (delete k al) = keys al - {k}\"", "lemma set_empty [simp]: \"set DAList.empty = {}\"", "lemma set_update_with:\n  \"set (update_with v k f al) = \n  (set al - {k} \\<times> UNIV \\<union> {(k, f (case DAList.lookup al k of None \\<Rightarrow> v | Some v \\<Rightarrow> v))})\"", "lemma set_update: \"set (DAList.update k v al) = (set al - {k} \\<times> UNIV \\<union> {(k, v)})\"", "lemma set_delete: \"set (delete k al) = set al - {k} \\<times> UNIV\"", "lemma size_dalist_transfer [transfer_rule]:\n  includes lifting_syntax\n  shows \"(pcr_alist (=) (=) ===> (=)) length size\"", "lemma size_eq_card_dom_lookup: \"size al = card (dom (DAList.lookup al))\""], "translations": [["", "lemma update_conv_update_with_aux:\n  \"AList.update k v xs = update_with_aux v k (\\<lambda>_. v) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AList.update k v xs = update_with_aux v k (\\<lambda>_. v) xs", "by(induct xs) simp_all"], ["", "lemma map_of_update_with_aux':\n  \"map_of (update_with_aux v k f ps) k' = ((map_of ps)(k \\<mapsto> (case map_of ps k of None \\<Rightarrow> f v | Some v \\<Rightarrow> f v))) k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (update_with_aux v k f ps) k' =\n    (map_of ps(k \\<mapsto>\n     case map_of ps k of None \\<Rightarrow> f v | Some v \\<Rightarrow> f v))\n     k'", "by(induct ps) auto"], ["", "lemma map_of_update_with_aux:\n  \"map_of (update_with_aux v k f ps) = (map_of ps)(k \\<mapsto> (case map_of ps k of None \\<Rightarrow> f v | Some v \\<Rightarrow> f v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (update_with_aux v k f ps) = map_of ps(k \\<mapsto>\n    case map_of ps k of None \\<Rightarrow> f v | Some v \\<Rightarrow> f v)", "by(simp add: fun_eq_iff map_of_update_with_aux')"], ["", "lemma dom_update_with_aux: \"fst ` set (update_with_aux v k f ps) = {k} \\<union> fst ` set ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` set (update_with_aux v k f ps) = {k} \\<union> fst ` set ps", "by (induct ps) auto"], ["", "lemma distinct_update_with_aux [simp]:\n  \"distinct (map fst (update_with_aux v k f ps)) = distinct (map fst ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (update_with_aux v k f ps)) = distinct (map fst ps)", "by(induct ps)(auto simp add: dom_update_with_aux)"], ["", "lemma set_update_with_aux:\n  \"distinct (map fst xs) \n  \\<Longrightarrow> set (update_with_aux v k f xs) = (set xs - {k} \\<times> UNIV \\<union> {(k, f (case map_of xs k of None \\<Rightarrow> v | Some v \\<Rightarrow> v))})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst xs) \\<Longrightarrow>\n    set (update_with_aux v k f xs) =\n    set xs - {k} \\<times> UNIV \\<union>\n    {(k, f (case map_of xs k of None \\<Rightarrow> v\n            | Some v \\<Rightarrow> v))}", "by(induct xs)(auto intro: rev_image_eqI)"], ["", "lemma set_delete_aux: \"distinct (map fst xs) \\<Longrightarrow> set (delete_aux k xs) = set xs - {k} \\<times> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst xs) \\<Longrightarrow>\n    set (delete_aux k xs) = set xs - {k} \\<times> UNIV", "apply(induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct (map fst []) \\<Longrightarrow>\n    set (delete_aux k []) = set [] - {k} \\<times> UNIV\n 2. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                set (delete_aux k xs) = set xs - {k} \\<times> UNIV;\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> set (delete_aux k (a # xs)) =\n                         set (a # xs) - {k} \\<times> UNIV", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>set (delete_aux k xs) = set xs - {k} \\<times> UNIV;\n        fst a \\<notin> fst ` set xs \\<and> distinct (map fst xs)\\<rbrakk>\n       \\<Longrightarrow> set (delete_aux k (a # xs)) =\n                         insert a (set xs) - {k} \\<times> UNIV", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b xs.\n       \\<lbrakk>set (delete_aux k xs) = set xs - {k} \\<times> UNIV;\n        a \\<notin> fst ` set xs; distinct (map fst xs)\\<rbrakk>\n       \\<Longrightarrow> (k = a \\<longrightarrow>\n                          set xs = set xs - {a} \\<times> UNIV) \\<and>\n                         (k \\<noteq> a \\<longrightarrow>\n                          insert (a, b) (set xs - {k} \\<times> UNIV) =\n                          insert (a, b) (set xs) - {k} \\<times> UNIV)", "apply(fastforce intro: rev_image_eqI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dom_delete_aux: \"distinct (map fst ps) \\<Longrightarrow> fst ` set (delete_aux k ps) = fst ` set ps - {k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst ps) \\<Longrightarrow>\n    fst ` set (delete_aux k ps) = fst ` set ps - {k}", "by(auto simp add: set_delete_aux)"], ["", "lemma distinct_delete_aux [simp]:\n  \"distinct (map fst ps) \\<Longrightarrow> distinct (map fst (delete_aux k ps))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst ps) \\<Longrightarrow>\n    distinct (map fst (delete_aux k ps))", "proof(induct ps)"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct (map fst []) \\<Longrightarrow>\n    distinct (map fst (delete_aux k []))\n 2. \\<And>a ps.\n       \\<lbrakk>distinct (map fst ps) \\<Longrightarrow>\n                distinct (map fst (delete_aux k ps));\n        distinct (map fst (a # ps))\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (delete_aux k (a # ps)))", "case Nil"], ["proof (state)\nthis:\n  distinct (map fst [])\n\ngoal (2 subgoals):\n 1. distinct (map fst []) \\<Longrightarrow>\n    distinct (map fst (delete_aux k []))\n 2. \\<And>a ps.\n       \\<lbrakk>distinct (map fst ps) \\<Longrightarrow>\n                distinct (map fst (delete_aux k ps));\n        distinct (map fst (a # ps))\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (delete_aux k (a # ps)))", "thus ?case"], ["proof (prove)\nusing this:\n  distinct (map fst [])\n\ngoal (1 subgoal):\n 1. distinct (map fst (delete_aux k []))", "by simp"], ["proof (state)\nthis:\n  distinct (map fst (delete_aux k []))\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       \\<lbrakk>distinct (map fst ps) \\<Longrightarrow>\n                distinct (map fst (delete_aux k ps));\n        distinct (map fst (a # ps))\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (delete_aux k (a # ps)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       \\<lbrakk>distinct (map fst ps) \\<Longrightarrow>\n                distinct (map fst (delete_aux k ps));\n        distinct (map fst (a # ps))\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (delete_aux k (a # ps)))", "case (Cons a ps)"], ["proof (state)\nthis:\n  distinct (map fst ps) \\<Longrightarrow>\n  distinct (map fst (delete_aux k ps))\n  distinct (map fst (a # ps))\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       \\<lbrakk>distinct (map fst ps) \\<Longrightarrow>\n                distinct (map fst (delete_aux k ps));\n        distinct (map fst (a # ps))\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (delete_aux k (a # ps)))", "obtain k' v where a: \"a = (k', v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k' v. a = (k', v) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases a)"], ["proof (state)\nthis:\n  a = (k', v)\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       \\<lbrakk>distinct (map fst ps) \\<Longrightarrow>\n                distinct (map fst (delete_aux k ps));\n        distinct (map fst (a # ps))\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (delete_aux k (a # ps)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (delete_aux k (a # ps)))", "proof(cases \"k' = k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k' = k \\<Longrightarrow> distinct (map fst (delete_aux k (a # ps)))\n 2. k' \\<noteq> k \\<Longrightarrow>\n    distinct (map fst (delete_aux k (a # ps)))", "case True"], ["proof (state)\nthis:\n  k' = k\n\ngoal (2 subgoals):\n 1. k' = k \\<Longrightarrow> distinct (map fst (delete_aux k (a # ps)))\n 2. k' \\<noteq> k \\<Longrightarrow>\n    distinct (map fst (delete_aux k (a # ps)))", "with Cons a"], ["proof (chain)\npicking this:\n  distinct (map fst ps) \\<Longrightarrow>\n  distinct (map fst (delete_aux k ps))\n  distinct (map fst (a # ps))\n  a = (k', v)\n  k' = k", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct (map fst ps) \\<Longrightarrow>\n  distinct (map fst (delete_aux k ps))\n  distinct (map fst (a # ps))\n  a = (k', v)\n  k' = k\n\ngoal (1 subgoal):\n 1. distinct (map fst (delete_aux k (a # ps)))", "by simp"], ["proof (state)\nthis:\n  distinct (map fst (delete_aux k (a # ps)))\n\ngoal (1 subgoal):\n 1. k' \\<noteq> k \\<Longrightarrow>\n    distinct (map fst (delete_aux k (a # ps)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k' \\<noteq> k \\<Longrightarrow>\n    distinct (map fst (delete_aux k (a # ps)))", "case False"], ["proof (state)\nthis:\n  k' \\<noteq> k\n\ngoal (1 subgoal):\n 1. k' \\<noteq> k \\<Longrightarrow>\n    distinct (map fst (delete_aux k (a # ps)))", "with Cons a"], ["proof (chain)\npicking this:\n  distinct (map fst ps) \\<Longrightarrow>\n  distinct (map fst (delete_aux k ps))\n  distinct (map fst (a # ps))\n  a = (k', v)\n  k' \\<noteq> k", "have \"k' \\<notin> fst ` set ps\" \"distinct (map fst ps)\""], ["proof (prove)\nusing this:\n  distinct (map fst ps) \\<Longrightarrow>\n  distinct (map fst (delete_aux k ps))\n  distinct (map fst (a # ps))\n  a = (k', v)\n  k' \\<noteq> k\n\ngoal (1 subgoal):\n 1. k' \\<notin> fst ` set ps &&& distinct (map fst ps)", "by simp_all"], ["proof (state)\nthis:\n  k' \\<notin> fst ` set ps\n  distinct (map fst ps)\n\ngoal (1 subgoal):\n 1. k' \\<noteq> k \\<Longrightarrow>\n    distinct (map fst (delete_aux k (a # ps)))", "with False a"], ["proof (chain)\npicking this:\n  k' \\<noteq> k\n  a = (k', v)\n  k' \\<notin> fst ` set ps\n  distinct (map fst ps)", "have \"k' \\<notin> fst ` set (delete_aux k ps)\""], ["proof (prove)\nusing this:\n  k' \\<noteq> k\n  a = (k', v)\n  k' \\<notin> fst ` set ps\n  distinct (map fst ps)\n\ngoal (1 subgoal):\n 1. k' \\<notin> fst ` set (delete_aux k ps)", "by(auto dest!: dom_delete_aux[where k=k])"], ["proof (state)\nthis:\n  k' \\<notin> fst ` set (delete_aux k ps)\n\ngoal (1 subgoal):\n 1. k' \\<noteq> k \\<Longrightarrow>\n    distinct (map fst (delete_aux k (a # ps)))", "with Cons a"], ["proof (chain)\npicking this:\n  distinct (map fst ps) \\<Longrightarrow>\n  distinct (map fst (delete_aux k ps))\n  distinct (map fst (a # ps))\n  a = (k', v)\n  k' \\<notin> fst ` set (delete_aux k ps)", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct (map fst ps) \\<Longrightarrow>\n  distinct (map fst (delete_aux k ps))\n  distinct (map fst (a # ps))\n  a = (k', v)\n  k' \\<notin> fst ` set (delete_aux k ps)\n\ngoal (1 subgoal):\n 1. distinct (map fst (delete_aux k (a # ps)))", "by simp"], ["proof (state)\nthis:\n  distinct (map fst (delete_aux k (a # ps)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct (map fst (delete_aux k (a # ps)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_of_delete_aux':\n  \"distinct (map fst xs) \\<Longrightarrow> map_of (delete_aux k xs) = (map_of xs)(k := None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst xs) \\<Longrightarrow>\n    map_of (delete_aux k xs) = (map_of xs)(k := None)", "by(induct xs)(fastforce simp add: map_of_eq_None_iff fun_upd_twist)+"], ["", "lemma map_of_delete_aux:\n  \"distinct (map fst xs) \\<Longrightarrow> map_of (delete_aux k xs) k' = ((map_of xs)(k := None)) k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst xs) \\<Longrightarrow>\n    map_of (delete_aux k xs) k' = ((map_of xs)(k := None)) k'", "by(simp add: map_of_delete_aux')"], ["", "lemma delete_aux_eq_Nil_conv: \"delete_aux k ts = [] \\<longleftrightarrow> ts = [] \\<or> (\\<exists>v. ts = [(k, v)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (delete_aux k ts = []) = (ts = [] \\<or> (\\<exists>v. ts = [(k, v)]))", "by(cases ts)(auto split: if_split_asm)"], ["", "lemma zip_with_index_from_simps [simp, code]:\n  \"zip_with_index_from n [] = []\"\n  \"zip_with_index_from n (x # xs) = (n, x) # zip_with_index_from (Suc n) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zip_with_index_from n [] = [] &&&\n    zip_with_index_from n (x # xs) = (n, x) # zip_with_index_from (Suc n) xs", "by(simp_all add: zip_with_index_from_def upt_rec del: upt.upt_Suc)"], ["", "lemma zip_with_index_from_append [simp]:\n  \"zip_with_index_from n (xs @ ys) = zip_with_index_from n xs @ zip_with_index_from (n + length xs) ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zip_with_index_from n (xs @ ys) =\n    zip_with_index_from n xs @ zip_with_index_from (n + length xs) ys", "by(simp add: zip_with_index_from_def zip_append[symmetric] upt_add_eq_append[symmetric] del: zip_append)\n    (simp add: add.assoc)"], ["", "lemma zip_with_index_from_conv_nth:\n  \"zip_with_index_from n xs = map (\\<lambda>i. (n + i, xs ! i)) [0..<length xs]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zip_with_index_from n xs =\n    map (\\<lambda>i. (n + i, xs ! i)) [0..<length xs]", "by(induction xs rule: rev_induct)(auto simp add: nth_append)"], ["", "lemma map_of_zip_with_index_from [simp]:\n  \"map_of (zip_with_index_from n xs) i = (if i \\<ge> n \\<and> i < n + length xs then Some (xs ! (i - n)) else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (zip_with_index_from n xs) i =\n    (if n \\<le> i \\<and> i < n + length xs then Some (xs ! (i - n))\n     else None)", "by(auto simp add: zip_with_index_from_def set_zip intro: exI[where x=\"i - n\"])"], ["", "lemma map_of_map': \"map_of (map (\\<lambda>(k, v). (k, f k v)) xs) x = map_option (f x) (map_of xs x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>(k, v). (k, f k v)) xs) x =\n    map_option (f x) (map_of xs x)", "by (induct xs)(auto)"], ["", "subsection \\<open>Operations on the abstract type @{typ \"('a, 'b) alist\"}\\<close>"], ["", "lift_definition update_with :: \"'v \\<Rightarrow> 'k \\<Rightarrow> ('v \\<Rightarrow> 'v) \\<Rightarrow> ('k, 'v) alist \\<Rightarrow> ('k, 'v) alist\"\n  is \"update_with_aux\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v k fun list.\n       (distinct \\<circ> map fst) list \\<Longrightarrow>\n       (distinct \\<circ> map fst) (update_with_aux v k fun list)", "by simp"], ["", "lift_definition delete :: \"'k \\<Rightarrow> ('k, 'v) alist \\<Rightarrow> ('k, 'v) alist\" is \"delete_aux\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k list.\n       (distinct \\<circ> map fst) list \\<Longrightarrow>\n       (distinct \\<circ> map fst) (delete_aux k list)", "by simp"], ["", "lift_definition keys :: \"('k, 'v) alist \\<Rightarrow> 'k set\" is \"set \\<circ> map fst\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition set :: \"('key, 'val) alist \\<Rightarrow> ('key \\<times> 'val) set\"\nis \"List.set\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition map_values :: \"('key \\<Rightarrow> 'val \\<Rightarrow> 'val') \\<Rightarrow> ('key, 'val) alist \\<Rightarrow> ('key, 'val') alist\" is\n  \"\\<lambda>f. map (\\<lambda>(x,y). (x, f x y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun list.\n       (distinct \\<circ> map fst) list \\<Longrightarrow>\n       (distinct \\<circ> map fst) (map (\\<lambda>(x, y). (x, fun x y)) list)", "by(simp add: o_def split_def)"], ["", "lemma lookup_update_with [simp]: \n  \"DAList.lookup (update_with v k f al) = (DAList.lookup al)(k \\<mapsto> case DAList.lookup al k of None \\<Rightarrow> f v | Some v \\<Rightarrow> f v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DAList.lookup (update_with v k f al) = DAList.lookup al(k \\<mapsto>\n    case DAList.lookup al k of None \\<Rightarrow> f v\n    | Some v \\<Rightarrow> f v)", "by transfer(simp add: map_of_update_with_aux)"], ["", "lemma lookup_delete [simp]: \"DAList.lookup (delete k al) = (DAList.lookup al)(k := None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DAList.lookup (delete k al) = (DAList.lookup al)(k := None)", "by transfer(simp add: map_of_delete_aux')"], ["", "lemma finite_dom_lookup [simp, intro!]: \"finite (dom (DAList.lookup m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (dom (DAList.lookup m))", "by transfer(simp add: finite_dom_map_of)"], ["", "lemma update_conv_update_with: \"DAList.update k v = update_with v k (\\<lambda>_. v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DAList.update k v = update_with v k (\\<lambda>_. v)", "by(rule ext)(transfer, simp add: update_conv_update_with_aux)"], ["", "lemma lookup_update [simp]: \"DAList.lookup (DAList.update k v al) = (DAList.lookup al)(k \\<mapsto> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DAList.lookup (DAList.update k v al) = DAList.lookup al(k \\<mapsto> v)", "by(simp add: update_conv_update_with split: option.split)"], ["", "lemma dom_lookup_keys: \"dom (DAList.lookup al) = keys al\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (DAList.lookup al) = keys al", "by transfer(simp add: dom_map_of_conv_image_fst)"], ["", "lemma keys_empty [simp]: \"keys DAList.empty = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys DAList.empty = {}", "by transfer simp"], ["", "lemma keys_update_with [simp]: \"keys (update_with v k f al) = insert k (keys al)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (update_with v k f al) = insert k (keys al)", "by(simp add: dom_lookup_keys[symmetric])"], ["", "lemma keys_update [simp]: \"keys (DAList.update k v al) = insert k (keys al)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (DAList.update k v al) = insert k (keys al)", "by(simp add: update_conv_update_with)"], ["", "lemma keys_delete [simp]: \"keys (delete k al) = keys al - {k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (delete k al) = keys al - {k}", "by(simp add: dom_lookup_keys[symmetric])"], ["", "lemma set_empty [simp]: \"set DAList.empty = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AssocList.set DAList.empty = {}", "by transfer simp"], ["", "lemma set_update_with:\n  \"set (update_with v k f al) = \n  (set al - {k} \\<times> UNIV \\<union> {(k, f (case DAList.lookup al k of None \\<Rightarrow> v | Some v \\<Rightarrow> v))})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AssocList.set (update_with v k f al) =\n    AssocList.set al - {k} \\<times> UNIV \\<union>\n    {(k, f (case DAList.lookup al k of None \\<Rightarrow> v\n            | Some v \\<Rightarrow> v))}", "by transfer(simp add: set_update_with_aux)"], ["", "lemma set_update: \"set (DAList.update k v al) = (set al - {k} \\<times> UNIV \\<union> {(k, v)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AssocList.set (DAList.update k v al) =\n    AssocList.set al - {k} \\<times> UNIV \\<union> {(k, v)}", "by(simp add: update_conv_update_with set_update_with)"], ["", "lemma set_delete: \"set (delete k al) = set al - {k} \\<times> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AssocList.set (delete k al) = AssocList.set al - {k} \\<times> UNIV", "by transfer(simp add: set_delete_aux)"], ["", "lemma size_dalist_transfer [transfer_rule]:\n  includes lifting_syntax\n  shows \"(pcr_alist (=) (=) ===> (=)) length size\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pcr_alist (=) (=) ===> (=)) length size", "unfolding size_alist_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (pcr_alist (=) (=) ===> (=)) length\n     (\\<lambda>al. length (alist.impl_of al))", "by transfer_prover"], ["", "lemma size_eq_card_dom_lookup: \"size al = card (dom (DAList.lookup al))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size al = card (dom (DAList.lookup al))", "by transfer (metis comp_apply distinct_card dom_map_of_conv_image_fst image_set length_map)"], ["", "hide_const (open) update_with keys set delete"], ["", "end"]]}