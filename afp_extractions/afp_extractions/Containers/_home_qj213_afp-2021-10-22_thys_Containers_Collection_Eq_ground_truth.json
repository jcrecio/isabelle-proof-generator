{"file_name": "/home/qj213/afp-2021-10-22/thys/Containers/Collection_Eq.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Containers", "problem_names": ["lemma ceq_equality: \"ceq = Some eq \\<Longrightarrow> equality eq\"", "lemma ID_ceq: \"ID ceq = Some eq \\<Longrightarrow> eq = (=)\"", "lemma equality_subst: \"c1 = c2 \\<Longrightarrow> equality c1 \\<Longrightarrow> equality c2\"", "lemma [code]: \"CEQ(unit) = Some (\\<lambda>_ _. True)\"", "lemma is_ceq_fun [simp]: \"\\<not> is_ceq TYPE('a \\<Rightarrow> 'b)\"", "lemma set_eq_code:\n  shows [code]: \"set_eq A B \\<longleftrightarrow> A \\<subseteq> B \\<and> B \\<subseteq> A\"\n  and [code_unfold]: \"(=) = set_eq\"", "lemma is_ceq_set [simp, code_post]: \"is_ceq TYPE('a set) \\<longleftrightarrow> is_ceq TYPE('a :: ceq)\"", "lemma ID_ceq_set_not_None_iff [simp]: \"ID CEQ('a set) \\<noteq> None \\<longleftrightarrow> ID CEQ('a :: ceq) \\<noteq> None\"", "lemma member_seq_code [code]: \n  \"member_seq seq.Empty x \\<longleftrightarrow> False\"\n  \"member_seq (seq.Insert y P) x \\<longleftrightarrow> eq x y \\<or> member_pred P x\"\n  \"member_seq (seq.Join Q xq) x \\<longleftrightarrow> member_pred Q x \\<or> member_seq xq x\"", "lemma member_pred_code [code]:\n  \"member_pred (Predicate.Seq f) = member_seq (f ())\"", "lemma leq_seq_code [code]:\n  \"leq_seq seq.Empty Q \\<longleftrightarrow> True\"\n  \"leq_seq (seq.Insert x P) Q \\<longleftrightarrow> member_pred Q x \\<and> leq_pred P Q\"\n  \"leq_seq (seq.Join P xp) Q \\<longleftrightarrow> leq_pred P Q \\<and> leq_seq xp Q\"", "lemma leq_pred_code [code]:\n  \"leq_pred (Predicate.Seq f) Q \\<longleftrightarrow> leq_seq (f ()) Q\"", "lemma member_pred_eq: \"member_pred = Predicate.eval\"", "lemma member_seq_eq: \"member_seq = Predicate.member\"", "lemma leq_pred_eq: \"leq_pred = (\\<le>)\"", "lemma predicate_eq_eq: \"predicate_eq = (=)\""], "translations": [["", "lemma ceq_equality: \"ceq = Some eq \\<Longrightarrow> equality eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ceq = Some eq \\<Longrightarrow> equality eq", "by (drule ceq, rule Equality_Generator.equalityI, simp)"], ["", "lemma ID_ceq: \"ID ceq = Some eq \\<Longrightarrow> eq = (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ID ceq = Some eq \\<Longrightarrow> eq = (=)", "unfolding ID_def id_apply"], ["proof (prove)\ngoal (1 subgoal):\n 1. ceq = Some eq \\<Longrightarrow> eq = (=)", "by(rule ceq)"], ["", "abbreviation ceq' :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" where \"ceq' \\<equiv> the (ID ceq)\""], ["", "end"], ["", "syntax \"_CEQ\" :: \"type => logic\"  (\"(1CEQ/(1'(_')))\")"], ["", "parse_translation \\<open>\nlet\n  fun ceq_tr [ty] =\n     (Syntax.const @{syntax_const \"_constrain\"} $ Syntax.const @{const_syntax \"ceq\"} $\n       (Syntax.const @{type_syntax option} $ \n         (Syntax.const @{type_syntax fun} $ ty $ \n           (Syntax.const @{type_syntax fun} $ ty $ Syntax.const @{type_syntax bool}))))\n    | ceq_tr ts = raise TERM (\"ceq_tr\", ts);\nin [(@{syntax_const \"_CEQ\"}, K ceq_tr)] end\n\\<close>"], ["", "typed_print_translation \\<open>\nlet\n  fun ceq_tr' ctxt\n    (Type (@{type_name option}, [Type (@{type_name fun}, [T, _])])) ts =\n    Term.list_comb (Syntax.const @{syntax_const \"_CEQ\"} $ Syntax_Phases.term_of_typ ctxt T, ts)\n  | ceq_tr' _ _ _ = raise Match;\nin [(@{const_syntax ceq}, ceq_tr')]\nend\n\\<close>"], ["", "definition is_ceq :: \"'a :: ceq itself \\<Rightarrow> bool\"\nwhere \"is_ceq _ \\<longleftrightarrow> ID CEQ('a) \\<noteq> None\""], ["", "subsection \\<open>Generator for the @{class ceq}-class\\<close>"], ["", "text \\<open>\nThis generator registers itself at the derive-manager for the class @{class ceq}.\nTo be more precise, one can choose whether one wants to take @{term \"(=)\"} as function\nfor @{term ceq} by passing \"eq\" as parameter, \nwhether equality should not be supported by passing \"no\" as parameter,\nor whether an own definition for equality should be derived by not passing\nany parameters. The last possibility only works for datatypes.\n\n\\begin{itemize}\n\\item \\texttt{instantiation type :: (type,\\ldots,type) (eq) ceq}\n\\item \\texttt{instantiation type :: (type,\\ldots,type) (no) ceq}\n\\item \\texttt{instantiation datatype :: (ceq,\\ldots,ceq) ceq}\n\\end{itemize}\n\nIf the parameter \"no\" is not used, then the corresponding\n@{term is_ceq}-theorem is also automatically generated and attributed with \n\\texttt{[simp, code-post]}.\n\\<close>"], ["", "text \\<open>\nThis generator can be used for arbitrary types, not just datatypes. \n\\<close>"], ["", "lemma equality_subst: \"c1 = c2 \\<Longrightarrow> equality c1 \\<Longrightarrow> equality c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c1 = c2; equality c1\\<rbrakk> \\<Longrightarrow> equality c2", "by blast"], ["", "ML_file \\<open>ceq_generator.ML\\<close>"], ["", "subsection \\<open>Type class instances for HOL types\\<close>"], ["", "derive (eq) ceq unit"], ["", "lemma [code]: \"CEQ(unit) = Some (\\<lambda>_ _. True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CEQ(unit) = Some (\\<lambda>_ _. True)", "unfolding ceq_unit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Some (=) = Some (\\<lambda>_ _. True)", "by (simp, intro ext, auto)"], ["", "derive (eq) ceq\n  bool\n  nat\n  int\n  Enum.finite_1\n  Enum.finite_2\n  Enum.finite_3\n  Enum.finite_4\n  Enum.finite_5\n  integer\n  natural\n  char\n  String.literal"], ["", "derive ceq sum prod list option"], ["", "derive (no) ceq \"fun\""], ["", "lemma is_ceq_fun [simp]: \"\\<not> is_ceq TYPE('a \\<Rightarrow> 'b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_ceq TYPE('a \\<Rightarrow> 'b)", "by(simp add: is_ceq_def ceq_fun_def ID_None)"], ["", "definition set_eq :: \"'a set \\<Rightarrow> 'a set \\<Rightarrow> bool\" \nwhere [code del]: \"set_eq = (=)\""], ["", "lemma set_eq_code:\n  shows [code]: \"set_eq A B \\<longleftrightarrow> A \\<subseteq> B \\<and> B \\<subseteq> A\"\n  and [code_unfold]: \"(=) = set_eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_eq A B = (A \\<subseteq> B \\<and> B \\<subseteq> A) &&& (=) = set_eq", "unfolding set_eq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A = B) = (A \\<subseteq> B \\<and> B \\<subseteq> A) &&& (=) = (=)", "by blast+"], ["", "instantiation set :: (ceq) ceq begin"], ["", "definition \"CEQ('a set) = (case ID CEQ('a) of None \\<Rightarrow> None | Some _ \\<Rightarrow> Some set_eq)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a set, ceq_class)", "by(intro_classes)(simp add: ceq_set_def set_eq_def split: option.splits)"], ["", "end"], ["", "lemma is_ceq_set [simp, code_post]: \"is_ceq TYPE('a set) \\<longleftrightarrow> is_ceq TYPE('a :: ceq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ceq TYPE('a set) = is_ceq TYPE('a)", "by(simp add: is_ceq_def ceq_set_def ID_None ID_Some split: option.split)"], ["", "lemma ID_ceq_set_not_None_iff [simp]: \"ID CEQ('a set) \\<noteq> None \\<longleftrightarrow> ID CEQ('a :: ceq) \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ID CEQ('a set) \\<noteq> None) = (ID CEQ('a) \\<noteq> None)", "by(simp add: ceq_set_def ID_def split: option.splits)"], ["", "text \\<open>Instantiation for @{typ \"'a Predicate.pred\"}\\<close>"], ["", "context fixes eq :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" begin"], ["", "definition member_pred :: \"'a Predicate.pred \\<Rightarrow> 'a \\<Rightarrow> bool\"\nwhere \"member_pred P x \\<longleftrightarrow> (\\<exists>y. eq x y \\<and> Predicate.eval P y)\""], ["", "definition member_seq :: \"'a Predicate.seq \\<Rightarrow> 'a \\<Rightarrow> bool\"\nwhere \"member_seq xp = member_pred (Predicate.pred_of_seq xp)\""], ["", "lemma member_seq_code [code]: \n  \"member_seq seq.Empty x \\<longleftrightarrow> False\"\n  \"member_seq (seq.Insert y P) x \\<longleftrightarrow> eq x y \\<or> member_pred P x\"\n  \"member_seq (seq.Join Q xq) x \\<longleftrightarrow> member_pred Q x \\<or> member_seq xq x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.member_seq seq.Empty x = False &&&\n    local.member_seq (seq.Insert y P) x =\n    (eq x y \\<or> local.member_pred P x) &&&\n    local.member_seq (seq.Join Q xq) x =\n    (local.member_pred Q x \\<or> local.member_seq xq x)", "by(auto simp add: member_seq_def member_pred_def)"], ["", "lemma member_pred_code [code]:\n  \"member_pred (Predicate.Seq f) = member_seq (f ())\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.member_pred (Predicate.Seq f) = local.member_seq (f ())", "by(simp add: member_seq_def Seq_def)"], ["", "definition leq_pred :: \"'a Predicate.pred \\<Rightarrow> 'a Predicate.pred \\<Rightarrow> bool\"\nwhere \"leq_pred P Q \\<longleftrightarrow> (\\<forall>x. Predicate.eval P x \\<longrightarrow> (\\<exists>y. eq x y \\<and> Predicate.eval Q y))\""], ["", "definition leq_seq :: \"'a Predicate.seq \\<Rightarrow> 'a Predicate.pred \\<Rightarrow> bool\"\nwhere \"leq_seq xp Q \\<longleftrightarrow> leq_pred (Predicate.pred_of_seq xp) Q\""], ["", "lemma leq_seq_code [code]:\n  \"leq_seq seq.Empty Q \\<longleftrightarrow> True\"\n  \"leq_seq (seq.Insert x P) Q \\<longleftrightarrow> member_pred Q x \\<and> leq_pred P Q\"\n  \"leq_seq (seq.Join P xp) Q \\<longleftrightarrow> leq_pred P Q \\<and> leq_seq xp Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.leq_seq seq.Empty Q = True &&&\n    local.leq_seq (seq.Insert x P) Q =\n    (local.member_pred Q x \\<and> local.leq_pred P Q) &&&\n    local.leq_seq (seq.Join P xp) Q =\n    (local.leq_pred P Q \\<and> local.leq_seq xp Q)", "by(auto simp add: leq_seq_def leq_pred_def member_pred_def)"], ["", "lemma leq_pred_code [code]:\n  \"leq_pred (Predicate.Seq f) Q \\<longleftrightarrow> leq_seq (f ()) Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.leq_pred (Predicate.Seq f) Q = local.leq_seq (f ()) Q", "by(simp add: leq_seq_def Seq_def)"], ["", "definition predicate_eq :: \"'a Predicate.pred \\<Rightarrow> 'a Predicate.pred \\<Rightarrow> bool\"\nwhere \"predicate_eq P Q \\<longleftrightarrow> leq_pred P Q \\<and> leq_pred Q P\""], ["", "context assumes eq: \"eq = (=)\" begin"], ["", "lemma member_pred_eq: \"member_pred = Predicate.eval\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.member_pred = pred.eval", "unfolding fun_eq_iff member_pred_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x xa.\n       (\\<exists>y. eq xa y \\<and> pred.eval x y) = pred.eval x xa", "by(simp add: eq)"], ["", "lemma member_seq_eq: \"member_seq = Predicate.member\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.member_seq = Predicate.member", "by(simp add: member_seq_def fun_eq_iff eval_member member_pred_eq)"], ["", "lemma leq_pred_eq: \"leq_pred = (\\<le>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.leq_pred = (\\<le>)", "unfolding fun_eq_iff leq_pred_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x xa.\n       (\\<forall>xb.\n           pred.eval x xb \\<longrightarrow>\n           (\\<exists>y. eq xb y \\<and> pred.eval xa y)) =\n       (x \\<le> xa)", "by(auto simp add: eq less_eq_pred_def)"], ["", "lemma predicate_eq_eq: \"predicate_eq = (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.predicate_eq = (=)", "unfolding predicate_eq_def fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x xa.\n       (local.leq_pred x xa \\<and> local.leq_pred xa x) = (x = xa)", "by(auto simp add: leq_pred_eq)"], ["", "end"], ["", "end"], ["", "instantiation Predicate.pred :: (ceq) ceq begin"], ["", "definition \"CEQ('a Predicate.pred) = map_option predicate_eq (ID CEQ('a))\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a Predicate.pred, ceq_class)", "by(intro_classes)(auto simp add: ceq_pred_def predicate_eq_eq dest: ID_ceq)"], ["", "end"], ["", "end"]]}