{"file_name": "/home/qj213/afp-2021-10-22/thys/Containers/Lexicographic_Order.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Containers", "problem_names": ["lemma lexordp_take_index_conv:\n  \"lexordp xs ys \\<longleftrightarrow> \n   (length xs < length ys \\<and> take (length xs) ys = xs) \\<or>\n   (\\<exists>i < min (length xs) (length ys). take i xs = take i ys \\<and> xs ! i < ys ! i)\"\n  (is \"?lhs = ?rhs\")", "lemma lexordp_lex: \"(xs, ys) \\<in> lex {(xs, ys). xs < ys} \\<longleftrightarrow> lexordp xs ys \\<and> length xs = length ys\"", "lemma lexord_fusion_code:\n  \"lexord_fusion g1 g2 s1 s2 \\<longleftrightarrow>\n  (if list.has_next g1 s1 then\n     if list.has_next g2 s2 then\n       let (x, s1') = list.next g1 s1;\n           (y, s2') = list.next g2 s2\n       in x < y \\<or> \\<not> y < x \\<and> lexord_fusion g1 g2 s1' s2'\n     else False\n   else list.has_next g2 s2)\"", "lemma lexord_eq_fusion_code:\n  \"lexord_eq_fusion g1 g2 s1 s2 \\<longleftrightarrow>\n  (list.has_next g1 s1 \\<longrightarrow>\n   list.has_next g2 s2 \\<and>\n   (let (x, s1') = list.next g1 s1;\n        (y, s2') = list.next g2 s2\n    in x < y \\<or> \\<not> y < x \\<and> lexord_eq_fusion g1 g2 s1' s2'))\"", "lemmas [code] =\n  lexord_fusion_code ord.lexord_fusion_code\n  lexord_eq_fusion_code ord.lexord_eq_fusion_code", "lemmas [symmetric, code_unfold] =\n  lexord_fusion_def ord.lexord_fusion_def\n  lexord_eq_fusion_def ord.lexord_eq_fusion_def"], "translations": [["", "lemma lexordp_take_index_conv:\n  \"lexordp xs ys \\<longleftrightarrow> \n   (length xs < length ys \\<and> take (length xs) ys = xs) \\<or>\n   (\\<exists>i < min (length xs) (length ys). take i xs = take i ys \\<and> xs ! i < ys ! i)\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lexordp xs ys =\n    (length xs < length ys \\<and> take (length xs) ys = xs \\<or>\n     (\\<exists>i<min (length xs) (length ys).\n         take i xs = take i ys \\<and> xs ! i < ys ! i))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. lexordp xs ys \\<Longrightarrow>\n    length xs < length ys \\<and> take (length xs) ys = xs \\<or>\n    (\\<exists>i<min (length xs) (length ys).\n        take i xs = take i ys \\<and> xs ! i < ys ! i)\n 2. length xs < length ys \\<and> take (length xs) ys = xs \\<or>\n    (\\<exists>i<min (length xs) (length ys).\n        take i xs = take i ys \\<and> xs ! i < ys ! i) \\<Longrightarrow>\n    lexordp xs ys", "assume ?lhs"], ["proof (state)\nthis:\n  lexordp xs ys\n\ngoal (2 subgoals):\n 1. lexordp xs ys \\<Longrightarrow>\n    length xs < length ys \\<and> take (length xs) ys = xs \\<or>\n    (\\<exists>i<min (length xs) (length ys).\n        take i xs = take i ys \\<and> xs ! i < ys ! i)\n 2. length xs < length ys \\<and> take (length xs) ys = xs \\<or>\n    (\\<exists>i<min (length xs) (length ys).\n        take i xs = take i ys \\<and> xs ! i < ys ! i) \\<Longrightarrow>\n    lexordp xs ys", "thus ?rhs"], ["proof (prove)\nusing this:\n  lexordp xs ys\n\ngoal (1 subgoal):\n 1. length xs < length ys \\<and> take (length xs) ys = xs \\<or>\n    (\\<exists>i<min (length xs) (length ys).\n        take i xs = take i ys \\<and> xs ! i < ys ! i)", "by induct (auto 4 3 del: disjCI intro: disjI2 exI[where x=\"Suc i\" for i])"], ["proof (state)\nthis:\n  length xs < length ys \\<and> take (length xs) ys = xs \\<or>\n  (\\<exists>i<min (length xs) (length ys).\n      take i xs = take i ys \\<and> xs ! i < ys ! i)\n\ngoal (1 subgoal):\n 1. length xs < length ys \\<and> take (length xs) ys = xs \\<or>\n    (\\<exists>i<min (length xs) (length ys).\n        take i xs = take i ys \\<and> xs ! i < ys ! i) \\<Longrightarrow>\n    lexordp xs ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. length xs < length ys \\<and> take (length xs) ys = xs \\<or>\n    (\\<exists>i<min (length xs) (length ys).\n        take i xs = take i ys \\<and> xs ! i < ys ! i) \\<Longrightarrow>\n    lexordp xs ys", "assume ?rhs (is \"?prefix \\<or> ?less\")"], ["proof (state)\nthis:\n  length xs < length ys \\<and> take (length xs) ys = xs \\<or>\n  (\\<exists>i<min (length xs) (length ys).\n      take i xs = take i ys \\<and> xs ! i < ys ! i)\n\ngoal (1 subgoal):\n 1. length xs < length ys \\<and> take (length xs) ys = xs \\<or>\n    (\\<exists>i<min (length xs) (length ys).\n        take i xs = take i ys \\<and> xs ! i < ys ! i) \\<Longrightarrow>\n    lexordp xs ys", "thus ?lhs"], ["proof (prove)\nusing this:\n  length xs < length ys \\<and> take (length xs) ys = xs \\<or>\n  (\\<exists>i<min (length xs) (length ys).\n      take i xs = take i ys \\<and> xs ! i < ys ! i)\n\ngoal (1 subgoal):\n 1. lexordp xs ys", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. length xs < length ys \\<and> take (length xs) ys = xs \\<Longrightarrow>\n    lexordp xs ys\n 2. \\<exists>i<min (length xs) (length ys).\n       take i xs = take i ys \\<and> xs ! i < ys ! i \\<Longrightarrow>\n    lexordp xs ys", "assume \"?prefix\""], ["proof (state)\nthis:\n  length xs < length ys \\<and> take (length xs) ys = xs\n\ngoal (2 subgoals):\n 1. length xs < length ys \\<and> take (length xs) ys = xs \\<Longrightarrow>\n    lexordp xs ys\n 2. \\<exists>i<min (length xs) (length ys).\n       take i xs = take i ys \\<and> xs ! i < ys ! i \\<Longrightarrow>\n    lexordp xs ys", "hence \"ys = xs @ hd (drop (length xs) ys) # tl (drop (length xs) ys)\""], ["proof (prove)\nusing this:\n  length xs < length ys \\<and> take (length xs) ys = xs\n\ngoal (1 subgoal):\n 1. ys = xs @ hd (drop (length xs) ys) # tl (drop (length xs) ys)", "by (metis append_Nil2 append_take_drop_id less_not_refl list.collapse)"], ["proof (state)\nthis:\n  ys = xs @ hd (drop (length xs) ys) # tl (drop (length xs) ys)\n\ngoal (2 subgoals):\n 1. length xs < length ys \\<and> take (length xs) ys = xs \\<Longrightarrow>\n    lexordp xs ys\n 2. \\<exists>i<min (length xs) (length ys).\n       take i xs = take i ys \\<and> xs ! i < ys ! i \\<Longrightarrow>\n    lexordp xs ys", "thus ?thesis"], ["proof (prove)\nusing this:\n  ys = xs @ hd (drop (length xs) ys) # tl (drop (length xs) ys)\n\ngoal (1 subgoal):\n 1. lexordp xs ys", "unfolding lexordp_iff"], ["proof (prove)\nusing this:\n  ys = xs @ hd (drop (length xs) ys) # tl (drop (length xs) ys)\n\ngoal (1 subgoal):\n 1. (\\<exists>x vs. ys = xs @ x # vs) \\<or>\n    (\\<exists>us a b vs ws.\n        a < b \\<and> xs = us @ a # vs \\<and> ys = us @ b # ws)", "by blast"], ["proof (state)\nthis:\n  lexordp xs ys\n\ngoal (1 subgoal):\n 1. \\<exists>i<min (length xs) (length ys).\n       take i xs = take i ys \\<and> xs ! i < ys ! i \\<Longrightarrow>\n    lexordp xs ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i<min (length xs) (length ys).\n       take i xs = take i ys \\<and> xs ! i < ys ! i \\<Longrightarrow>\n    lexordp xs ys", "assume \"?less\""], ["proof (state)\nthis:\n  \\<exists>i<min (length xs) (length ys).\n     take i xs = take i ys \\<and> xs ! i < ys ! i\n\ngoal (1 subgoal):\n 1. \\<exists>i<min (length xs) (length ys).\n       take i xs = take i ys \\<and> xs ! i < ys ! i \\<Longrightarrow>\n    lexordp xs ys", "then"], ["proof (chain)\npicking this:\n  \\<exists>i<min (length xs) (length ys).\n     take i xs = take i ys \\<and> xs ! i < ys ! i", "obtain i where \"i < min (length xs) (length ys)\"\n      and \"take i xs = take i ys\" and nth: \"xs ! i < ys ! i\""], ["proof (prove)\nusing this:\n  \\<exists>i<min (length xs) (length ys).\n     take i xs = take i ys \\<and> xs ! i < ys ! i\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < min (length xs) (length ys); take i xs = take i ys;\n         xs ! i < ys ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  i < min (length xs) (length ys)\n  take i xs = take i ys\n  xs ! i < ys ! i\n\ngoal (1 subgoal):\n 1. \\<exists>i<min (length xs) (length ys).\n       take i xs = take i ys \\<and> xs ! i < ys ! i \\<Longrightarrow>\n    lexordp xs ys", "hence \"xs = take i xs @ xs ! i # drop (Suc i) xs\" \"ys = take i xs @ ys ! i # drop (Suc i) ys\""], ["proof (prove)\nusing this:\n  i < min (length xs) (length ys)\n  take i xs = take i ys\n  xs ! i < ys ! i\n\ngoal (1 subgoal):\n 1. xs = take i xs @ xs ! i # drop (Suc i) xs &&&\n    ys = take i xs @ ys ! i # drop (Suc i) ys", "by -(subst append_take_drop_id[symmetric, of _ i], simp_all add: Cons_nth_drop_Suc)"], ["proof (state)\nthis:\n  xs = take i xs @ xs ! i # drop (Suc i) xs\n  ys = take i xs @ ys ! i # drop (Suc i) ys\n\ngoal (1 subgoal):\n 1. \\<exists>i<min (length xs) (length ys).\n       take i xs = take i ys \\<and> xs ! i < ys ! i \\<Longrightarrow>\n    lexordp xs ys", "with nth"], ["proof (chain)\npicking this:\n  xs ! i < ys ! i\n  xs = take i xs @ xs ! i # drop (Suc i) xs\n  ys = take i xs @ ys ! i # drop (Suc i) ys", "show ?thesis"], ["proof (prove)\nusing this:\n  xs ! i < ys ! i\n  xs = take i xs @ xs ! i # drop (Suc i) xs\n  ys = take i xs @ ys ! i # drop (Suc i) ys\n\ngoal (1 subgoal):\n 1. lexordp xs ys", "unfolding lexordp_iff"], ["proof (prove)\nusing this:\n  xs ! i < ys ! i\n  xs = take i xs @ xs ! i # drop (Suc i) xs\n  ys = take i xs @ ys ! i # drop (Suc i) ys\n\ngoal (1 subgoal):\n 1. (\\<exists>x vs. ys = xs @ x # vs) \\<or>\n    (\\<exists>us a b vs ws.\n        a < b \\<and> xs = us @ a # vs \\<and> ys = us @ b # ws)", "by blast"], ["proof (state)\nthis:\n  lexordp xs ys\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lexordp xs ys\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open>lexord is extension of partial ordering List.lex\\<close>"], ["", "lemma lexordp_lex: \"(xs, ys) \\<in> lex {(xs, ys). xs < ys} \\<longleftrightarrow> lexordp xs ys \\<and> length xs = length ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((xs, ys) \\<in> lex {(x, y). x < y}) =\n    (lexordp xs ys \\<and> length xs = length ys)", "proof(induct xs arbitrary: ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       (([], ys) \\<in> lex {(x, y). x < y}) =\n       (lexordp [] ys \\<and> length [] = length ys)\n 2. \\<And>a xs ys.\n       (\\<And>ys.\n           ((xs, ys) \\<in> lex {(x, y). x < y}) =\n           (lexordp xs ys \\<and> length xs = length ys)) \\<Longrightarrow>\n       ((a # xs, ys) \\<in> lex {(x, y). x < y}) =\n       (lexordp (a # xs) ys \\<and> length (a # xs) = length ys)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       (([], ys) \\<in> lex {(x, y). x < y}) =\n       (lexordp [] ys \\<and> length [] = length ys)\n 2. \\<And>a xs ys.\n       (\\<And>ys.\n           ((xs, ys) \\<in> lex {(x, y). x < y}) =\n           (lexordp xs ys \\<and> length xs = length ys)) \\<Longrightarrow>\n       ((a # xs, ys) \\<in> lex {(x, y). x < y}) =\n       (lexordp (a # xs) ys \\<and> length (a # xs) = length ys)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (([], ys) \\<in> lex {a. case a of (x, xa) \\<Rightarrow> x < xa}) =\n    (lexordp [] ys \\<and> length [] = length ys)", "by clarsimp"], ["proof (state)\nthis:\n  (([], ys) \\<in> lex {a. case a of (x, xa) \\<Rightarrow> x < xa}) =\n  (lexordp [] ys \\<and> length [] = length ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           ((xs, ys) \\<in> lex {(x, y). x < y}) =\n           (lexordp xs ys \\<and> length xs = length ys)) \\<Longrightarrow>\n       ((a # xs, ys) \\<in> lex {(x, y). x < y}) =\n       (lexordp (a # xs) ys \\<and> length (a # xs) = length ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           ((xs, ys) \\<in> lex {(x, y). x < y}) =\n           (lexordp xs ys \\<and> length xs = length ys)) \\<Longrightarrow>\n       ((a # xs, ys) \\<in> lex {(x, y). x < y}) =\n       (lexordp (a # xs) ys \\<and> length (a # xs) = length ys)", "case Cons"], ["proof (state)\nthis:\n  ((xs_, ?ys) \\<in> lex {a. case a of (x, xa) \\<Rightarrow> x < xa}) =\n  (lexordp xs_ ?ys \\<and> length xs_ = length ?ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           ((xs, ys) \\<in> lex {(x, y). x < y}) =\n           (lexordp xs ys \\<and> length xs = length ys)) \\<Longrightarrow>\n       ((a # xs, ys) \\<in> lex {(x, y). x < y}) =\n       (lexordp (a # xs) ys \\<and> length (a # xs) = length ys)", "thus ?case"], ["proof (prove)\nusing this:\n  ((xs_, ?ys) \\<in> lex {a. case a of (x, xa) \\<Rightarrow> x < xa}) =\n  (lexordp xs_ ?ys \\<and> length xs_ = length ?ys)\n\ngoal (1 subgoal):\n 1. ((a_ # xs_, ys) \\<in> lex {a. case a of (x, xa) \\<Rightarrow> x < xa}) =\n    (lexordp (a_ # xs_) ys \\<and> length (a_ # xs_) = length ys)", "by(cases ys)(simp_all, safe, simp)"], ["proof (state)\nthis:\n  ((a_ # xs_, ys) \\<in> lex {a. case a of (x, xa) \\<Rightarrow> x < xa}) =\n  (lexordp (a_ # xs_) ys \\<and> length (a_ # xs_) = length ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Setup for list fusion\\<close>"], ["", "context ord begin"], ["", "definition lexord_fusion :: \"('a, 's1) generator \\<Rightarrow> ('a, 's2) generator \\<Rightarrow> 's1 \\<Rightarrow> 's2 \\<Rightarrow> bool\"\nwhere [code del]: \"lexord_fusion g1 g2 s1 s2 = lexordp (list.unfoldr g1 s1) (list.unfoldr g2 s2)\""], ["", "definition lexord_eq_fusion :: \"('a, 's1) generator \\<Rightarrow> ('a, 's2) generator \\<Rightarrow> 's1 \\<Rightarrow> 's2 \\<Rightarrow> bool\"\nwhere [code del]: \"lexord_eq_fusion g1 g2 s1 s2 = lexordp_eq (list.unfoldr g1 s1) (list.unfoldr g2 s2)\""], ["", "lemma lexord_fusion_code:\n  \"lexord_fusion g1 g2 s1 s2 \\<longleftrightarrow>\n  (if list.has_next g1 s1 then\n     if list.has_next g2 s2 then\n       let (x, s1') = list.next g1 s1;\n           (y, s2') = list.next g2 s2\n       in x < y \\<or> \\<not> y < x \\<and> lexord_fusion g1 g2 s1' s2'\n     else False\n   else list.has_next g2 s2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lexord_fusion g1 g2 s1 s2 =\n    (if list.has_next g1 s1\n     then if list.has_next g2 s2\n          then let (x, s1') = list.next g1 s1; (y, s2') = list.next g2 s2\n               in x < y \\<or>\n                  \\<not> y < x \\<and> lexord_fusion g1 g2 s1' s2'\n          else False\n     else list.has_next g2 s2)", "unfolding lexord_fusion_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lexordp (list.unfoldr g1 s1) (list.unfoldr g2 s2) =\n    (if list.has_next g1 s1\n     then if list.has_next g2 s2\n          then let (x, s1') = list.next g1 s1; (y, s2') = list.next g2 s2\n               in x < y \\<or>\n                  \\<not> y < x \\<and>\n                  lexordp (list.unfoldr g1 s1') (list.unfoldr g2 s2')\n          else False\n     else list.has_next g2 s2)", "by(subst (1 2) list.unfoldr.simps)(auto split: prod.split_asm)"], ["", "lemma lexord_eq_fusion_code:\n  \"lexord_eq_fusion g1 g2 s1 s2 \\<longleftrightarrow>\n  (list.has_next g1 s1 \\<longrightarrow>\n   list.has_next g2 s2 \\<and>\n   (let (x, s1') = list.next g1 s1;\n        (y, s2') = list.next g2 s2\n    in x < y \\<or> \\<not> y < x \\<and> lexord_eq_fusion g1 g2 s1' s2'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lexord_eq_fusion g1 g2 s1 s2 =\n    (list.has_next g1 s1 \\<longrightarrow>\n     list.has_next g2 s2 \\<and>\n     (let (x, s1') = list.next g1 s1; (y, s2') = list.next g2 s2\n      in x < y \\<or> \\<not> y < x \\<and> lexord_eq_fusion g1 g2 s1' s2'))", "unfolding lexord_eq_fusion_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lexordp_eq (list.unfoldr g1 s1) (list.unfoldr g2 s2) =\n    (list.has_next g1 s1 \\<longrightarrow>\n     list.has_next g2 s2 \\<and>\n     (let (x, s1') = list.next g1 s1; (y, s2') = list.next g2 s2\n      in x < y \\<or>\n         \\<not> y < x \\<and>\n         lexordp_eq (list.unfoldr g1 s1') (list.unfoldr g2 s2')))", "by(subst (1 2) list.unfoldr.simps)(auto split: prod.split_asm)"], ["", "end"], ["", "lemmas [code] =\n  lexord_fusion_code ord.lexord_fusion_code\n  lexord_eq_fusion_code ord.lexord_eq_fusion_code"], ["", "lemmas [symmetric, code_unfold] =\n  lexord_fusion_def ord.lexord_fusion_def\n  lexord_eq_fusion_def ord.lexord_eq_fusion_def"], ["", "end"]]}