{"file_name": "/home/qj213/afp-2021-10-22/thys/Containers/Examples/TwoSat_Ex.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Containers", "problem_names": ["lemma negate_inject [simp]: \"negate x = negate y \\<longleftrightarrow> x = y\"", "lemma double_negate[simp]: \"negate (negate l) = l\"", "lemma var_negate[simp]: \"var (negate l) = var l\"", "lemma sat_lit_alt: \"sat_lit \\<sigma> (Lit p v) \\<longleftrightarrow> \\<sigma> v = p\"", "lemma is_2sat_simps [simp]: \"is_2sat {}\" \"is_2sat (insert cl cnf) \\<longleftrightarrow> proper_uprod cl \\<and> is_2sat cnf\"", "lemma negate_sat[simp]: \"sat_lit \\<sigma> (negate l) \\<longleftrightarrow> \\<not> sat_lit \\<sigma> l\"", "lemma imp_graph_alt: \"imp_graph cnf = {(negate l1,l2) | l1 l2. Upair l1 l2 \\<in> cnf}\"", "lemma imp_graph_empty [simp]: \"imp_graph {} = {}\"", "lemma imp_graph_insert [simp]:\n  \"imp_graph (insert cl cls) = edges_of_clause cl \\<union> imp_graph cls\"", "lemma imp_graph_skew_sym: \n  \"(l\\<^sub>1,l\\<^sub>2) \\<in> imp_graph cnf \\<Longrightarrow> (negate l\\<^sub>2, negate l\\<^sub>1) \\<in> imp_graph cnf\"", "lemma imp_graph_rtrancl_skew_sym:    \n  \"(l\\<^sub>1, l\\<^sub>2) \\<in> (imp_graph cnf)\\<^sup>* \\<Longrightarrow> (negate l\\<^sub>2, negate l\\<^sub>1) \\<in> (imp_graph cnf)\\<^sup>*\"", "lemma imp_step:\n    assumes S: \"sat_lit \\<sigma> l\\<^sub>1\"  \n    assumes I: \"(l\\<^sub>1, l\\<^sub>2) \\<in> imp_graph cnf\" \n    shows \"sat_lit \\<sigma> l\\<^sub>2\"", "lemma imp_steps:\n    assumes S: \"sat_lit \\<sigma> l\\<^sub>1\"  \n    assumes I: \"(l\\<^sub>1, l\\<^sub>2) \\<in> (imp_graph cnf)\\<^sup>*\" \n    shows \"sat_lit \\<sigma> l\\<^sub>2\"", "lemma ln_loop:\n    assumes \"(l, negate l) \\<in> (imp_graph cnf)\\<^sup>*\"\n    shows \"\\<not> sat_lit \\<sigma> l\"", "lemma loop_imp_unsat:\n  assumes \"(Pos x, Neg x) \\<in> (imp_graph cnf)\\<^sup>*\"\n  assumes \"(Neg x, Pos x) \\<in> (imp_graph cnf)\\<^sup>*\"\n  shows \"\\<not> satisfiable cnf\"", "lemma [simp]: \"consistent {}\"", "lemma eq_SomeD:\n  assumes \"x = Eps P\"\n  assumes \"\\<exists>x. P x\"\n  shows \"P x\"", "lemma extend_vars: \"vars_of_cnf cnf \\<subseteq> var ` extend ls\"", "lemma extend_cons_closed_aux:\n    assumes \"consistent ls\"\n    assumes \"G `` ls \\<subseteq> ls\"\n    shows \"consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls\"", "lemma extend_cons_closed:\n    \"consistent (extend {})\" \n    \"G `` extend {} \\<subseteq> extend {}\"", "lemma CCV_sat:\n    assumes CONS: \"consistent ls\"\n    assumes CLOSED: \"G``ls \\<subseteq> ls\"\n    assumes VARS: \"vars_of_cnf cnf \\<subseteq> var`ls\"  \n    shows \"sat_cnf (\\<lambda>x. Pos x \\<in> ls) cnf\"", "lemma sat: \"satisfiable cnf\"", "lemma imp_graph_vars:\n  assumes \"(l, l') \\<in> imp_graph cnf\"  \n  shows \"var l \\<in> vars_of_cnf cnf\"", "theorem finite_2sat_iff:\n  assumes FIN: \"finite (vars_of_cnf cnf)\"\n  assumes TSAT: \"is_2sat cnf\"  \n  shows \"satisfiable cnf \n    \\<longleftrightarrow> (\\<forall>x\\<in>vars_of_cnf cnf. \n          \\<not> ((Pos x, Neg x) \\<in> (imp_graph cnf)\\<^sup>* \\<and> (Neg x, Pos x) \\<in> (imp_graph cnf)\\<^sup>* ))\"", "lemma inj_on_Pos [simp]: \"inj_on Pos A\" \n  and inj_on_Neg [simp]: \"inj_on Neg A\"", "lemma lits_of_cnf_finite[iff]:\n  \"finite (lits_of_cnf cnf) \\<longleftrightarrow> finite (vars_of_cnf cnf)\"", "lemma vars_of_cnf_finite[simp, intro]:\n  \"finite cnf \\<Longrightarrow> finite (vars_of_cnf cnf)\"", "lemma lit_eq_negate_conv[simp]:\n  \"Lit p v = negate l \\<longleftrightarrow> l = Lit (\\<not>p) v\"\n  \"negate l = Lit p v \\<longleftrightarrow> l = Lit (\\<not>p) v\"", "lemma imp_graph_nodes: \"imp_graph cnf \\<subseteq> lits_of_cnf cnf \\<times> lits_of_cnf cnf\"", "lemma imp_graph_finite[simp, intro]: \"finite (vars_of_cnf cnf) \\<Longrightarrow> finite (imp_graph cnf)\""], "translations": [["", "lemma negate_inject [simp]: \"negate x = negate y \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (negate x = negate y) = (x = y)", "by(cases x; cases y) simp"], ["", "lemma double_negate[simp]: \"negate (negate l) = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. negate (negate l) = l", "by (cases l) auto"], ["", "lemma var_negate[simp]: \"var (negate l) = var l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var (negate l) = var l", "by (cases l) auto"], ["", "type_synonym valuation = \"var \\<Rightarrow> bool\""], ["", "definition sat_lit :: \"valuation \\<Rightarrow> lit \\<Rightarrow> bool\"\n  where \"sat_lit \\<sigma> l \\<longleftrightarrow> (\\<sigma> (var l) \\<longleftrightarrow> pos l)\""], ["", "lemma sat_lit_alt: \"sat_lit \\<sigma> (Lit p v) \\<longleftrightarrow> \\<sigma> v = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sat_lit \\<sigma> (Lit p v) = (\\<sigma> v = p)", "by (auto simp: sat_lit_def)"], ["", "function sat_clause where\n  \"sat_clause \\<sigma> (Upair l1 l2) \\<longleftrightarrow> sat_lit \\<sigma> l1 \\<or> sat_lit \\<sigma> l2\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>\\<sigma> l1 l2.\n           x = (\\<sigma>, Upair l1 l2) \\<Longrightarrow>\n           P) \\<Longrightarrow>\n       P\n 2. \\<And>\\<sigma> l1 l2 \\<sigma>' l1a l2a.\n       (\\<sigma>, Upair l1 l2) =\n       (\\<sigma>', Upair l1a l2a) \\<Longrightarrow>\n       (sat_lit \\<sigma> l1 \\<or> sat_lit \\<sigma> l2) =\n       (sat_lit \\<sigma>' l1a \\<or> sat_lit \\<sigma>' l2a)", "apply (metis surj_pair uprod_exhaust)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> l1 l2 \\<sigma>' l1a l2a.\n       (\\<sigma>, Upair l1 l2) =\n       (\\<sigma>', Upair l1a l2a) \\<Longrightarrow>\n       (sat_lit \\<sigma> l1 \\<or> sat_lit \\<sigma> l2) =\n       (sat_lit \\<sigma>' l1a \\<or> sat_lit \\<sigma>' l2a)", "by auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All sat_clause_dom", "by lexicographic_order"], ["", "definition sat_cnf :: \"valuation \\<Rightarrow> cnf \\<Rightarrow> bool\"  \n  where \"sat_cnf \\<sigma> cnf \\<longleftrightarrow> (\\<forall>cl\\<in>cnf. sat_clause \\<sigma> cl)\""], ["", "definition satisfiable :: \"cnf \\<Rightarrow> bool\"\nwhere \"satisfiable cnf \\<longleftrightarrow> (\\<exists>\\<sigma>. sat_cnf \\<sigma> cnf)\""], ["", "definition is_2sat :: \"cnf \\<Rightarrow> bool\"\nwhere \"is_2sat cnf \\<longleftrightarrow> (\\<forall>cl\\<in>cnf. proper_uprod cl)\""], ["", "lemma is_2sat_simps [simp]: \"is_2sat {}\" \"is_2sat (insert cl cnf) \\<longleftrightarrow> proper_uprod cl \\<and> is_2sat cnf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_2sat {} &&&\n    is_2sat (insert cl cnf) = (proper_uprod cl \\<and> is_2sat cnf)", "by(simp_all add: is_2sat_def)"], ["", "lemma negate_sat[simp]: \"sat_lit \\<sigma> (negate l) \\<longleftrightarrow> \\<not> sat_lit \\<sigma> l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sat_lit \\<sigma> (negate l) = (\\<not> sat_lit \\<sigma> l)", "by (cases l) (auto simp: sat_lit_def)"], ["", "function edges_of_clause where \n  \"edges_of_clause (Upair l1 l2) = {(negate l1, l2), (negate l2, l1)}\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>l1 l2. x = Upair l1 l2 \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 2. \\<And>l1 l2 l1a l2a.\n       Upair l1 l2 = Upair l1a l2a \\<Longrightarrow>\n       {(negate l1, l2), (negate l2, l1)} =\n       {(negate l1a, l2a), (negate l2a, l1a)}", "by (rule uprod_exhaust) auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All edges_of_clause_dom", "by lexicographic_order"], ["", "definition imp_graph :: \"cnf \\<Rightarrow> (lit \\<times> lit) set\" where\n  \"imp_graph cnf = \\<Union>(edges_of_clause ` cnf)\""], ["", "lemma imp_graph_alt: \"imp_graph cnf = {(negate l1,l2) | l1 l2. Upair l1 l2 \\<in> cnf}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_graph cnf = {(negate l1, l2) |l1 l2. Upair l1 l2 \\<in> cnf}", "unfolding imp_graph_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (edges_of_clause ` cnf) =\n    {(negate l1, l2) |l1 l2. Upair l1 l2 \\<in> cnf}", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>x \\<in> cnf; (a, b) \\<in> edges_of_clause x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l1 l2.\n                            (a, b) = (negate l1, l2) \\<and>\n                            Upair l1 l2 \\<in> cnf\n 2. \\<And>a b l1 l2.\n       Upair l1 l2 \\<in> cnf \\<Longrightarrow>\n       (negate l1, l2) \\<in> \\<Union> (edges_of_clause ` cnf)", "subgoal for l1 l2 cl"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cl \\<in> cnf; (l1, l2) \\<in> edges_of_clause cl\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l1a l2a.\n                         (l1, l2) = (negate l1a, l2a) \\<and>\n                         Upair l1a l2a \\<in> cnf", "by (cases cl; clarsimp; metis Upair_inject)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b l1 l2.\n       Upair l1 l2 \\<in> cnf \\<Longrightarrow>\n       (negate l1, l2) \\<in> \\<Union> (edges_of_clause ` cnf)", "using edges_of_clause.simps"], ["proof (prove)\nusing this:\n  edges_of_clause (Upair ?l1.0 ?l2.0) =\n  {(negate ?l1.0, ?l2.0), (negate ?l2.0, ?l1.0)}\n\ngoal (1 subgoal):\n 1. \\<And>a b l1 l2.\n       Upair l1 l2 \\<in> cnf \\<Longrightarrow>\n       (negate l1, l2) \\<in> \\<Union> (edges_of_clause ` cnf)", "by blast"], ["", "lemma imp_graph_empty [simp]: \"imp_graph {} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_graph {} = {}", "by (simp add: imp_graph_def)"], ["", "lemma imp_graph_insert [simp]:\n  \"imp_graph (insert cl cls) = edges_of_clause cl \\<union> imp_graph cls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_graph (insert cl cls) = edges_of_clause cl \\<union> imp_graph cls", "by (auto simp: imp_graph_def)"], ["", "lemma imp_graph_skew_sym: \n  \"(l\\<^sub>1,l\\<^sub>2) \\<in> imp_graph cnf \\<Longrightarrow> (negate l\\<^sub>2, negate l\\<^sub>1) \\<in> imp_graph cnf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l\\<^sub>1, l\\<^sub>2) \\<in> imp_graph cnf \\<Longrightarrow>\n    (negate l\\<^sub>2, negate l\\<^sub>1) \\<in> imp_graph cnf", "unfolding imp_graph_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (l\\<^sub>1, l\\<^sub>2)\n    \\<in> \\<Union> (edges_of_clause ` cnf) \\<Longrightarrow>\n    (negate l\\<^sub>2, negate l\\<^sub>1)\n    \\<in> \\<Union> (edges_of_clause ` cnf)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> cnf;\n        (l\\<^sub>1, l\\<^sub>2) \\<in> edges_of_clause x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>cnf.\n                            (negate l\\<^sub>2, negate l\\<^sub>1)\n                            \\<in> edges_of_clause x", "subgoal for cl"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cl \\<in> cnf;\n     (l\\<^sub>1, l\\<^sub>2) \\<in> edges_of_clause cl\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<in>cnf.\n                         (negate l\\<^sub>2, negate l\\<^sub>1)\n                         \\<in> edges_of_clause x", "by (cases cl) (auto 4 3 intro: rev_bexI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma imp_graph_rtrancl_skew_sym:    \n  \"(l\\<^sub>1, l\\<^sub>2) \\<in> (imp_graph cnf)\\<^sup>* \\<Longrightarrow> (negate l\\<^sub>2, negate l\\<^sub>1) \\<in> (imp_graph cnf)\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l\\<^sub>1, l\\<^sub>2) \\<in> (imp_graph cnf)\\<^sup>* \\<Longrightarrow>\n    (negate l\\<^sub>2, negate l\\<^sub>1) \\<in> (imp_graph cnf)\\<^sup>*", "by (induction rule: rtrancl.induct)(auto dest: imp_graph_skew_sym)"], ["", "context\n  fixes \\<sigma> cnf\n  assumes sat: \"sat_cnf \\<sigma> cnf\"  \nbegin"], ["", "lemma imp_step:\n    assumes S: \"sat_lit \\<sigma> l\\<^sub>1\"  \n    assumes I: \"(l\\<^sub>1, l\\<^sub>2) \\<in> imp_graph cnf\" \n    shows \"sat_lit \\<sigma> l\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sat_lit \\<sigma> l\\<^sub>2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sat_lit \\<sigma> l\\<^sub>2", "from I sat"], ["proof (chain)\npicking this:\n  (l\\<^sub>1, l\\<^sub>2) \\<in> imp_graph cnf\n  sat_cnf \\<sigma> cnf", "have \"\\<not> sat_lit \\<sigma> l\\<^sub>1 \\<or> sat_lit \\<sigma> l\\<^sub>2\""], ["proof (prove)\nusing this:\n  (l\\<^sub>1, l\\<^sub>2) \\<in> imp_graph cnf\n  sat_cnf \\<sigma> cnf\n\ngoal (1 subgoal):\n 1. \\<not> sat_lit \\<sigma> l\\<^sub>1 \\<or> sat_lit \\<sigma> l\\<^sub>2", "unfolding sat_cnf_def imp_graph_def"], ["proof (prove)\nusing this:\n  (l\\<^sub>1, l\\<^sub>2) \\<in> \\<Union> (edges_of_clause ` cnf)\n  Ball cnf (sat_clause \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> sat_lit \\<sigma> l\\<^sub>1 \\<or> sat_lit \\<sigma> l\\<^sub>2", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>cnf. sat_clause \\<sigma> x; x \\<in> cnf;\n        (l\\<^sub>1, l\\<^sub>2) \\<in> edges_of_clause x;\n        sat_lit \\<sigma> l\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> sat_lit \\<sigma> l\\<^sub>2", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>cnf. sat_clause \\<sigma> x; x \\<in> cnf;\n     (l\\<^sub>1, l\\<^sub>2) \\<in> edges_of_clause x;\n     sat_lit \\<sigma> l\\<^sub>1\\<rbrakk>\n    \\<Longrightarrow> sat_lit \\<sigma> l\\<^sub>2", "by(cases x)(auto split: if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<not> sat_lit \\<sigma> l\\<^sub>1 \\<or> sat_lit \\<sigma> l\\<^sub>2\n\ngoal (1 subgoal):\n 1. sat_lit \\<sigma> l\\<^sub>2", "with S"], ["proof (chain)\npicking this:\n  sat_lit \\<sigma> l\\<^sub>1\n  \\<not> sat_lit \\<sigma> l\\<^sub>1 \\<or> sat_lit \\<sigma> l\\<^sub>2", "show ?thesis"], ["proof (prove)\nusing this:\n  sat_lit \\<sigma> l\\<^sub>1\n  \\<not> sat_lit \\<sigma> l\\<^sub>1 \\<or> sat_lit \\<sigma> l\\<^sub>2\n\ngoal (1 subgoal):\n 1. sat_lit \\<sigma> l\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  sat_lit \\<sigma> l\\<^sub>2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma imp_steps:\n    assumes S: \"sat_lit \\<sigma> l\\<^sub>1\"  \n    assumes I: \"(l\\<^sub>1, l\\<^sub>2) \\<in> (imp_graph cnf)\\<^sup>*\" \n    shows \"sat_lit \\<sigma> l\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sat_lit \\<sigma> l\\<^sub>2", "using assms(2,1)"], ["proof (prove)\nusing this:\n  (l\\<^sub>1, l\\<^sub>2) \\<in> (imp_graph cnf)\\<^sup>*\n  sat_lit \\<sigma> l\\<^sub>1\n\ngoal (1 subgoal):\n 1. sat_lit \\<sigma> l\\<^sub>2", "by (induction) (auto intro: imp_step)"], ["", "lemma ln_loop:\n    assumes \"(l, negate l) \\<in> (imp_graph cnf)\\<^sup>*\"\n    shows \"\\<not> sat_lit \\<sigma> l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> sat_lit \\<sigma> l", "using imp_steps[OF _ assms]"], ["proof (prove)\nusing this:\n  sat_lit \\<sigma> l \\<Longrightarrow> sat_lit \\<sigma> (negate l)\n\ngoal (1 subgoal):\n 1. \\<not> sat_lit \\<sigma> l", "by (cases \"sat_lit \\<sigma> l\") auto"], ["", "end"], ["", "lemma loop_imp_unsat:\n  assumes \"(Pos x, Neg x) \\<in> (imp_graph cnf)\\<^sup>*\"\n  assumes \"(Neg x, Pos x) \\<in> (imp_graph cnf)\\<^sup>*\"\n  shows \"\\<not> satisfiable cnf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> satisfiable cnf", "using assms ln_loop[of _ cnf \"Pos x\"] ln_loop[of _ cnf \"Neg x\"]"], ["proof (prove)\nusing this:\n  (Pos x, Neg x) \\<in> (imp_graph cnf)\\<^sup>*\n  (Neg x, Pos x) \\<in> (imp_graph cnf)\\<^sup>*\n  \\<lbrakk>sat_cnf ?\\<sigma> cnf;\n   (Pos x, negate (Pos x)) \\<in> (imp_graph cnf)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> \\<not> sat_lit ?\\<sigma> (Pos x)\n  \\<lbrakk>sat_cnf ?\\<sigma> cnf;\n   (Neg x, negate (Neg x)) \\<in> (imp_graph cnf)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> \\<not> sat_lit ?\\<sigma> (Neg x)\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable cnf", "unfolding satisfiable_def"], ["proof (prove)\nusing this:\n  (Pos x, Neg x) \\<in> (imp_graph cnf)\\<^sup>*\n  (Neg x, Pos x) \\<in> (imp_graph cnf)\\<^sup>*\n  \\<lbrakk>sat_cnf ?\\<sigma> cnf;\n   (Pos x, negate (Pos x)) \\<in> (imp_graph cnf)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> \\<not> sat_lit ?\\<sigma> (Pos x)\n  \\<lbrakk>sat_cnf ?\\<sigma> cnf;\n   (Neg x, negate (Neg x)) \\<in> (imp_graph cnf)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> \\<not> sat_lit ?\\<sigma> (Neg x)\n\ngoal (1 subgoal):\n 1. \\<nexists>\\<sigma>. sat_cnf \\<sigma> cnf", "by(auto simp add: sat_lit_def)"], ["", "(*\n  Informal argument why we can find satisfying valuation if\n  there are no cycles Pos x \\<rightarrow>\\<^sup>* Neg x \\<rightarrow>\\<^sup>* Pos x.\n\n  Assign all variables as follows:\n    Let current assignment be A. By assumption, closed and consistent.\n    Choose unassigned variable x\n    Try to assign Pos x, form transitive closure.\n    If this yields a conflict, assign Neg x\n\n    Assume both Pos x and Neg x would yield conflict:\n      As current assignment is always closed, we have \n        G\\<^sup>*``Pos x \\<inter> negate``A = {} and G\\<^sup>*``Neg x \\<inter> negate``A = {}\n        (Otherwise:\n          Pos x \\<rightarrow>\\<^sup>* negate l, l\\<in>A\n          \\<Longrightarrow> l \\<rightarrow>\\<^sup>* Neg x (skew sym)\n          \\<Longrightarrow> Neg x \\<in> A (A closed, l\\<in>A)\n          \\<Longrightarrow> x not unassigned, contr!\n        )\n      Thus, conflict must be of form:\n        Pos x \\<rightarrow>\\<^sup>* Pos y, Pos x \\<rightarrow>\\<^sup>* Neg y\n        Neg x \\<rightarrow>\\<^sup>* Pos z, Neg x \\<rightarrow>\\<^sup>* Neg z\n        \n        \\<Longrightarrow> (skew sym)\n          Pos y \\<rightarrow>\\<^sup>* Neg x \\<Longrightarrow> Pos x \\<rightarrow>\\<^sup>* Neg x\n          Pos z \\<rightarrow>\\<^sup>* Pos x \\<Longrightarrow> Neg x \\<rightarrow>\\<^sup>* Pos x\n          contr to no-cycle assm\n*)"], ["", "definition consistent :: \"lit set \\<Rightarrow> bool\" where\n  \"consistent ls \\<longleftrightarrow> (\\<nexists>x. Pos x \\<in> ls \\<and> Neg x \\<in> ls)\""], ["", "lemma [simp]: \"consistent {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent {}", "by (auto simp: consistent_def)"], ["", "definition vars_of_cnf :: \"cnf \\<Rightarrow> var set\" \nwhere \"vars_of_cnf cnf \\<equiv> \\<Union>cl\\<in>cnf. var ` set_uprod cl\""], ["", "lemma eq_SomeD:\n  assumes \"x = Eps P\"\n  assumes \"\\<exists>x. P x\"\n  shows \"P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P x", "using assms"], ["proof (prove)\nusing this:\n  x = Eps P\n  \\<exists>x. P x\n\ngoal (1 subgoal):\n 1. P x", "by (auto simp: someI)"], ["", "locale construct_sa =\n  fixes cnf :: cnf\n  assumes FIN: \"finite (vars_of_cnf cnf)\"  \n  assumes NO_CYC: \n    \"\\<nexists>x. (Pos x, Neg x) \\<in> (imp_graph cnf)\\<^sup>* \\<and> (Neg x, Pos x) \\<in> (imp_graph cnf)\\<^sup>*\"\n  assumes TSAT: \"is_2sat cnf\"\nbegin"], ["", "abbreviation \"G \\<equiv> imp_graph cnf\""], ["", "function extend :: \"lit set \\<Rightarrow> lit set\" where\n    \"extend ls = (\n      if vars_of_cnf cnf \\<subseteq> var ` ls then ls \n      else let\n        x = SOME x. x \\<in> vars_of_cnf cnf - var ` ls\n      in\n        if consistent (ls \\<union> G\\<^sup>* `` {Pos x}) then\n          extend (ls \\<union> G\\<^sup>* `` {Pos x})\n        else\n          extend (ls \\<union> G\\<^sup>* `` {Neg x})\n    )\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x. (\\<And>ls. x = ls \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>ls lsa.\n       ls = lsa \\<Longrightarrow>\n       (if vars_of_cnf cnf \\<subseteq> var ` ls then ls\n        else let x = SOME x. x \\<in> vars_of_cnf cnf - var ` ls\n             in if consistent (ls \\<union> G\\<^sup>* `` {Pos x})\n                then extend_sumC (ls \\<union> G\\<^sup>* `` {Pos x})\n                else extend_sumC (ls \\<union> G\\<^sup>* `` {Neg x})) =\n       (if vars_of_cnf cnf \\<subseteq> var ` lsa then lsa\n        else let x = SOME x. x \\<in> vars_of_cnf cnf - var ` lsa\n             in if consistent (lsa \\<union> G\\<^sup>* `` {Pos x})\n                then extend_sumC (lsa \\<union> G\\<^sup>* `` {Pos x})\n                else extend_sumC (lsa \\<union> G\\<^sup>* `` {Neg x}))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All extend_dom", "apply (relation \"inv_image finite_psubset (\\<lambda>ls. vars_of_cnf cnf - var`ls)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. wf (inv_image finite_psubset (\\<lambda>ls. vars_of_cnf cnf - var ` ls))\n 2. \\<And>ls x.\n       \\<lbrakk>\\<not> vars_of_cnf cnf \\<subseteq> var ` ls;\n        x = (SOME x. x \\<in> vars_of_cnf cnf - var ` ls);\n        consistent (ls \\<union> G\\<^sup>* `` {Pos x})\\<rbrakk>\n       \\<Longrightarrow> (ls \\<union> G\\<^sup>* `` {Pos x}, ls)\n                         \\<in> inv_image finite_psubset\n                                (\\<lambda>ls. vars_of_cnf cnf - var ` ls)\n 3. \\<And>ls x.\n       \\<lbrakk>\\<not> vars_of_cnf cnf \\<subseteq> var ` ls;\n        x = (SOME x. x \\<in> vars_of_cnf cnf - var ` ls);\n        \\<not> consistent (ls \\<union> G\\<^sup>* `` {Pos x})\\<rbrakk>\n       \\<Longrightarrow> (ls \\<union> G\\<^sup>* `` {Neg x}, ls)\n                         \\<in> inv_image finite_psubset\n                                (\\<lambda>ls. vars_of_cnf cnf - var ` ls)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ls x.\n       \\<lbrakk>\\<not> vars_of_cnf cnf \\<subseteq> var ` ls;\n        x = (SOME x. x \\<in> vars_of_cnf cnf - var ` ls);\n        consistent (ls \\<union> G\\<^sup>* `` {Pos x})\\<rbrakk>\n       \\<Longrightarrow> (ls \\<union> G\\<^sup>* `` {Pos x}, ls)\n                         \\<in> inv_image finite_psubset\n                                (\\<lambda>ls. vars_of_cnf cnf - var ` ls)\n 2. \\<And>ls x.\n       \\<lbrakk>\\<not> vars_of_cnf cnf \\<subseteq> var ` ls;\n        x = (SOME x. x \\<in> vars_of_cnf cnf - var ` ls);\n        \\<not> consistent (ls \\<union> G\\<^sup>* `` {Pos x})\\<rbrakk>\n       \\<Longrightarrow> (ls \\<union> G\\<^sup>* `` {Neg x}, ls)\n                         \\<in> inv_image finite_psubset\n                                (\\<lambda>ls. vars_of_cnf cnf - var ` ls)", "apply (drule eq_SomeD; auto simp: FIN)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ls x.\n       \\<lbrakk>\\<not> vars_of_cnf cnf \\<subseteq> var ` ls;\n        x = (SOME x. x \\<in> vars_of_cnf cnf - var ` ls);\n        \\<not> consistent (ls \\<union> G\\<^sup>* `` {Pos x})\\<rbrakk>\n       \\<Longrightarrow> (ls \\<union> G\\<^sup>* `` {Neg x}, ls)\n                         \\<in> inv_image finite_psubset\n                                (\\<lambda>ls. vars_of_cnf cnf - var ` ls)", "apply (drule eq_SomeD; auto simp: FIN)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare extend.simps[simp del]"], ["", "lemma extend_vars: \"vars_of_cnf cnf \\<subseteq> var ` extend ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars_of_cnf cnf \\<subseteq> var ` extend ls", "apply (induction ls rule: extend.induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ls.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<not> vars_of_cnf cnf \\<subseteq> var ` ls;\n                    x = (SOME x. x \\<in> vars_of_cnf cnf - var ` ls);\n                    consistent (ls \\<union> G\\<^sup>* `` {Pos x})\\<rbrakk>\n                   \\<Longrightarrow> vars_of_cnf cnf\n                                     \\<subseteq> var `\n           extend (ls \\<union> G\\<^sup>* `` {Pos x});\n        \\<And>x.\n           \\<lbrakk>\\<not> vars_of_cnf cnf \\<subseteq> var ` ls;\n            x = (SOME x. x \\<in> vars_of_cnf cnf - var ` ls);\n            \\<not> consistent (ls \\<union> G\\<^sup>* `` {Pos x})\\<rbrakk>\n           \\<Longrightarrow> vars_of_cnf cnf\n                             \\<subseteq> var `\n   extend (ls \\<union> G\\<^sup>* `` {Neg x})\\<rbrakk>\n       \\<Longrightarrow> vars_of_cnf cnf \\<subseteq> var ` extend ls", "apply (subst extend.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ls.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<not> vars_of_cnf cnf \\<subseteq> var ` ls;\n                    x = (SOME x. x \\<in> vars_of_cnf cnf - var ` ls);\n                    consistent (ls \\<union> G\\<^sup>* `` {Pos x})\\<rbrakk>\n                   \\<Longrightarrow> vars_of_cnf cnf\n                                     \\<subseteq> var `\n           extend (ls \\<union> G\\<^sup>* `` {Pos x});\n        \\<And>x.\n           \\<lbrakk>\\<not> vars_of_cnf cnf \\<subseteq> var ` ls;\n            x = (SOME x. x \\<in> vars_of_cnf cnf - var ` ls);\n            \\<not> consistent (ls \\<union> G\\<^sup>* `` {Pos x})\\<rbrakk>\n           \\<Longrightarrow> vars_of_cnf cnf\n                             \\<subseteq> var `\n   extend (ls \\<union> G\\<^sup>* `` {Neg x})\\<rbrakk>\n       \\<Longrightarrow> vars_of_cnf cnf\n                         \\<subseteq> var `\n                                     (if vars_of_cnf cnf\n   \\<subseteq> var ` ls\nthen ls\nelse let x = SOME x. x \\<in> vars_of_cnf cnf - var ` ls\n     in if consistent (ls \\<union> G\\<^sup>* `` {Pos x})\n        then extend (ls \\<union> G\\<^sup>* `` {Pos x})\n        else extend (ls \\<union> G\\<^sup>* `` {Neg x}))", "apply (auto split: if_splits simp: Let_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma extend_cons_closed_aux:\n    assumes \"consistent ls\"\n    assumes \"G `` ls \\<subseteq> ls\"\n    shows \"consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls", "using assms(1,2)"], ["proof (prove)\nusing this:\n  consistent ls\n  G `` ls \\<subseteq> ls\n\ngoal (1 subgoal):\n 1. consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls", "proof (induction ls rule: extend.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ls.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<not> vars_of_cnf cnf \\<subseteq> var ` ls;\n                    x = (SOME x. x \\<in> vars_of_cnf cnf - var ` ls);\n                    consistent (ls \\<union> G\\<^sup>* `` {Pos x});\n                    consistent (ls \\<union> G\\<^sup>* `` {Pos x});\n                    G `` (ls \\<union> G\\<^sup>* `` {Pos x})\n                    \\<subseteq> ls \\<union> G\\<^sup>* `` {Pos x}\\<rbrakk>\n                   \\<Longrightarrow> consistent\n(extend (ls \\<union> G\\<^sup>* `` {Pos x})) \\<and>\n                                     G ``\n                                     extend\n(ls \\<union> G\\<^sup>* `` {Pos x})\n                                     \\<subseteq> extend\n            (ls \\<union> G\\<^sup>* `` {Pos x});\n        \\<And>x.\n           \\<lbrakk>\\<not> vars_of_cnf cnf \\<subseteq> var ` ls;\n            x = (SOME x. x \\<in> vars_of_cnf cnf - var ` ls);\n            \\<not> consistent (ls \\<union> G\\<^sup>* `` {Pos x});\n            consistent (ls \\<union> G\\<^sup>* `` {Neg x});\n            G `` (ls \\<union> G\\<^sup>* `` {Neg x})\n            \\<subseteq> ls \\<union> G\\<^sup>* `` {Neg x}\\<rbrakk>\n           \\<Longrightarrow> consistent\n                              (extend\n                                (ls \\<union> G\\<^sup>* `` {Neg x})) \\<and>\n                             G `` extend (ls \\<union> G\\<^sup>* `` {Neg x})\n                             \\<subseteq> extend\n    (ls \\<union> G\\<^sup>* `` {Neg x});\n        consistent ls; G `` ls \\<subseteq> ls\\<rbrakk>\n       \\<Longrightarrow> consistent (extend ls) \\<and>\n                         G `` extend ls \\<subseteq> extend ls", "case (1 ls)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> vars_of_cnf cnf \\<subseteq> var ` ls;\n   ?x = (SOME x. x \\<in> vars_of_cnf cnf - var ` ls);\n   consistent (ls \\<union> G\\<^sup>* `` {Pos ?x});\n   consistent (ls \\<union> G\\<^sup>* `` {Pos ?x});\n   G `` (ls \\<union> G\\<^sup>* `` {Pos ?x})\n   \\<subseteq> ls \\<union> G\\<^sup>* `` {Pos ?x}\\<rbrakk>\n  \\<Longrightarrow> consistent\n                     (extend (ls \\<union> G\\<^sup>* `` {Pos ?x})) \\<and>\n                    G `` extend (ls \\<union> G\\<^sup>* `` {Pos ?x})\n                    \\<subseteq> extend (ls \\<union> G\\<^sup>* `` {Pos ?x})\n  \\<lbrakk>\\<not> vars_of_cnf cnf \\<subseteq> var ` ls;\n   ?x = (SOME x. x \\<in> vars_of_cnf cnf - var ` ls);\n   \\<not> consistent (ls \\<union> G\\<^sup>* `` {Pos ?x});\n   consistent (ls \\<union> G\\<^sup>* `` {Neg ?x});\n   G `` (ls \\<union> G\\<^sup>* `` {Neg ?x})\n   \\<subseteq> ls \\<union> G\\<^sup>* `` {Neg ?x}\\<rbrakk>\n  \\<Longrightarrow> consistent\n                     (extend (ls \\<union> G\\<^sup>* `` {Neg ?x})) \\<and>\n                    G `` extend (ls \\<union> G\\<^sup>* `` {Neg ?x})\n                    \\<subseteq> extend (ls \\<union> G\\<^sup>* `` {Neg ?x})\n  consistent ls\n  G `` ls \\<subseteq> ls\n\ngoal (1 subgoal):\n 1. \\<And>ls.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<not> vars_of_cnf cnf \\<subseteq> var ` ls;\n                    x = (SOME x. x \\<in> vars_of_cnf cnf - var ` ls);\n                    consistent (ls \\<union> G\\<^sup>* `` {Pos x});\n                    consistent (ls \\<union> G\\<^sup>* `` {Pos x});\n                    G `` (ls \\<union> G\\<^sup>* `` {Pos x})\n                    \\<subseteq> ls \\<union> G\\<^sup>* `` {Pos x}\\<rbrakk>\n                   \\<Longrightarrow> consistent\n(extend (ls \\<union> G\\<^sup>* `` {Pos x})) \\<and>\n                                     G ``\n                                     extend\n(ls \\<union> G\\<^sup>* `` {Pos x})\n                                     \\<subseteq> extend\n            (ls \\<union> G\\<^sup>* `` {Pos x});\n        \\<And>x.\n           \\<lbrakk>\\<not> vars_of_cnf cnf \\<subseteq> var ` ls;\n            x = (SOME x. x \\<in> vars_of_cnf cnf - var ` ls);\n            \\<not> consistent (ls \\<union> G\\<^sup>* `` {Pos x});\n            consistent (ls \\<union> G\\<^sup>* `` {Neg x});\n            G `` (ls \\<union> G\\<^sup>* `` {Neg x})\n            \\<subseteq> ls \\<union> G\\<^sup>* `` {Neg x}\\<rbrakk>\n           \\<Longrightarrow> consistent\n                              (extend\n                                (ls \\<union> G\\<^sup>* `` {Neg x})) \\<and>\n                             G `` extend (ls \\<union> G\\<^sup>* `` {Neg x})\n                             \\<subseteq> extend\n    (ls \\<union> G\\<^sup>* `` {Neg x});\n        consistent ls; G `` ls \\<subseteq> ls\\<rbrakk>\n       \\<Longrightarrow> consistent (extend ls) \\<and>\n                         G `` extend ls \\<subseteq> extend ls", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls", "proof (cases \"vars_of_cnf cnf \\<subseteq> var`ls\")"], ["proof (state)\ngoal (2 subgoals):\n 1. vars_of_cnf cnf \\<subseteq> var ` ls \\<Longrightarrow>\n    consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls\n 2. \\<not> vars_of_cnf cnf \\<subseteq> var ` ls \\<Longrightarrow>\n    consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls", "case True"], ["proof (state)\nthis:\n  vars_of_cnf cnf \\<subseteq> var ` ls\n\ngoal (2 subgoals):\n 1. vars_of_cnf cnf \\<subseteq> var ` ls \\<Longrightarrow>\n    consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls\n 2. \\<not> vars_of_cnf cnf \\<subseteq> var ` ls \\<Longrightarrow>\n    consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls", "thus ?thesis"], ["proof (prove)\nusing this:\n  vars_of_cnf cnf \\<subseteq> var ` ls\n\ngoal (1 subgoal):\n 1. consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls", "using \"1.prems\""], ["proof (prove)\nusing this:\n  vars_of_cnf cnf \\<subseteq> var ` ls\n  consistent ls\n  G `` ls \\<subseteq> ls\n\ngoal (1 subgoal):\n 1. consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls", "by(subst (1 2 3) extend.simps) auto"], ["proof (state)\nthis:\n  consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls\n\ngoal (1 subgoal):\n 1. \\<not> vars_of_cnf cnf \\<subseteq> var ` ls \\<Longrightarrow>\n    consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> vars_of_cnf cnf \\<subseteq> var ` ls \\<Longrightarrow>\n    consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls", "case [simp]: False"], ["proof (state)\nthis:\n  \\<not> vars_of_cnf cnf \\<subseteq> var ` ls\n\ngoal (1 subgoal):\n 1. \\<not> vars_of_cnf cnf \\<subseteq> var ` ls \\<Longrightarrow>\n    consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls", "define x where \"x = (SOME x. x \\<in> vars_of_cnf cnf - var ` ls)\""], ["proof (state)\nthis:\n  x = (SOME x. x \\<in> vars_of_cnf cnf - var ` ls)\n\ngoal (1 subgoal):\n 1. \\<not> vars_of_cnf cnf \\<subseteq> var ` ls \\<Longrightarrow>\n    consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls", "with False"], ["proof (chain)\npicking this:\n  \\<not> vars_of_cnf cnf \\<subseteq> var ` ls\n  x = (SOME x. x \\<in> vars_of_cnf cnf - var ` ls)", "have XI: \"x \\<in> vars_of_cnf cnf - var ` ls\""], ["proof (prove)\nusing this:\n  \\<not> vars_of_cnf cnf \\<subseteq> var ` ls\n  x = (SOME x. x \\<in> vars_of_cnf cnf - var ` ls)\n\ngoal (1 subgoal):\n 1. x \\<in> vars_of_cnf cnf - var ` ls", "by (metis (full_types) DiffI someI_ex subsetI)"], ["proof (state)\nthis:\n  x \\<in> vars_of_cnf cnf - var ` ls\n\ngoal (1 subgoal):\n 1. \\<not> vars_of_cnf cnf \\<subseteq> var ` ls \\<Longrightarrow>\n    consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls", "proof (cases \"consistent (ls \\<union> G\\<^sup>*``{Pos x})\")"], ["proof (state)\ngoal (2 subgoals):\n 1. consistent (ls \\<union> G\\<^sup>* `` {Pos x}) \\<Longrightarrow>\n    consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls\n 2. \\<not> consistent (ls \\<union> G\\<^sup>* `` {Pos x}) \\<Longrightarrow>\n    consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls", "case CPOS [simp]: True"], ["proof (state)\nthis:\n  consistent (ls \\<union> G\\<^sup>* `` {Pos x})\n\ngoal (2 subgoals):\n 1. consistent (ls \\<union> G\\<^sup>* `` {Pos x}) \\<Longrightarrow>\n    consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls\n 2. \\<not> consistent (ls \\<union> G\\<^sup>* `` {Pos x}) \\<Longrightarrow>\n    consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls", "from \"1.prems\""], ["proof (chain)\npicking this:\n  consistent ls\n  G `` ls \\<subseteq> ls", "have CL: \"G `` (ls \\<union> G\\<^sup>* `` {Pos x}) \\<subseteq> ls \\<union> G\\<^sup>* `` {Pos x}\""], ["proof (prove)\nusing this:\n  consistent ls\n  G `` ls \\<subseteq> ls\n\ngoal (1 subgoal):\n 1. G `` (ls \\<union> G\\<^sup>* `` {Pos x})\n    \\<subseteq> ls \\<union> G\\<^sup>* `` {Pos x}", "by auto"], ["proof (state)\nthis:\n  G `` (ls \\<union> G\\<^sup>* `` {Pos x})\n  \\<subseteq> ls \\<union> G\\<^sup>* `` {Pos x}\n\ngoal (2 subgoals):\n 1. consistent (ls \\<union> G\\<^sup>* `` {Pos x}) \\<Longrightarrow>\n    consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls\n 2. \\<not> consistent (ls \\<union> G\\<^sup>* `` {Pos x}) \\<Longrightarrow>\n    consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls", "using \"1.IH\"(1)[OF False x_def CPOS CPOS CL]"], ["proof (prove)\nusing this:\n  consistent (extend (ls \\<union> G\\<^sup>* `` {Pos x})) \\<and>\n  G `` extend (ls \\<union> G\\<^sup>* `` {Pos x})\n  \\<subseteq> extend (ls \\<union> G\\<^sup>* `` {Pos x})\n\ngoal (1 subgoal):\n 1. consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls", "unfolding extend.simps[of ls]"], ["proof (prove)\nusing this:\n  consistent (extend (ls \\<union> G\\<^sup>* `` {Pos x})) \\<and>\n  G `` extend (ls \\<union> G\\<^sup>* `` {Pos x})\n  \\<subseteq> extend (ls \\<union> G\\<^sup>* `` {Pos x})\n\ngoal (1 subgoal):\n 1. consistent\n     (if vars_of_cnf cnf \\<subseteq> var ` ls then ls\n      else let x = SOME x. x \\<in> vars_of_cnf cnf - var ` ls\n           in if consistent (ls \\<union> G\\<^sup>* `` {Pos x})\n              then extend (ls \\<union> G\\<^sup>* `` {Pos x})\n              else extend (ls \\<union> G\\<^sup>* `` {Neg x})) \\<and>\n    G ``\n    (if vars_of_cnf cnf \\<subseteq> var ` ls then ls\n     else let x = SOME x. x \\<in> vars_of_cnf cnf - var ` ls\n          in if consistent (ls \\<union> G\\<^sup>* `` {Pos x})\n             then extend (ls \\<union> G\\<^sup>* `` {Pos x})\n             else extend (ls \\<union> G\\<^sup>* `` {Neg x}))\n    \\<subseteq> (if vars_of_cnf cnf \\<subseteq> var ` ls then ls\n                 else let x = SOME x. x \\<in> vars_of_cnf cnf - var ` ls\n                      in if consistent (ls \\<union> G\\<^sup>* `` {Pos x})\n                         then extend (ls \\<union> G\\<^sup>* `` {Pos x})\n                         else extend (ls \\<union> G\\<^sup>* `` {Neg x}))", "unfolding x_def[symmetric]"], ["proof (prove)\nusing this:\n  consistent (extend (ls \\<union> G\\<^sup>* `` {Pos x})) \\<and>\n  G `` extend (ls \\<union> G\\<^sup>* `` {Pos x})\n  \\<subseteq> extend (ls \\<union> G\\<^sup>* `` {Pos x})\n\ngoal (1 subgoal):\n 1. consistent\n     (if vars_of_cnf cnf \\<subseteq> var ` ls then ls\n      else let x = x\n           in if consistent (ls \\<union> G\\<^sup>* `` {Pos x})\n              then extend (ls \\<union> G\\<^sup>* `` {Pos x})\n              else extend (ls \\<union> G\\<^sup>* `` {Neg x})) \\<and>\n    G ``\n    (if vars_of_cnf cnf \\<subseteq> var ` ls then ls\n     else let x = x\n          in if consistent (ls \\<union> G\\<^sup>* `` {Pos x})\n             then extend (ls \\<union> G\\<^sup>* `` {Pos x})\n             else extend (ls \\<union> G\\<^sup>* `` {Neg x}))\n    \\<subseteq> (if vars_of_cnf cnf \\<subseteq> var ` ls then ls\n                 else let x = x\n                      in if consistent (ls \\<union> G\\<^sup>* `` {Pos x})\n                         then extend (ls \\<union> G\\<^sup>* `` {Pos x})\n                         else extend (ls \\<union> G\\<^sup>* `` {Neg x}))", "by auto"], ["proof (state)\nthis:\n  consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls\n\ngoal (1 subgoal):\n 1. \\<not> consistent (ls \\<union> G\\<^sup>* `` {Pos x}) \\<Longrightarrow>\n    consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> consistent (ls \\<union> G\\<^sup>* `` {Pos x}) \\<Longrightarrow>\n    consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls", "case NCPOS: False"], ["proof (state)\nthis:\n  \\<not> consistent (ls \\<union> G\\<^sup>* `` {Pos x})\n\ngoal (1 subgoal):\n 1. \\<not> consistent (ls \\<union> G\\<^sup>* `` {Pos x}) \\<Longrightarrow>\n    consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls", "from \"1.prems\""], ["proof (chain)\npicking this:\n  consistent ls\n  G `` ls \\<subseteq> ls", "have CL: \"G `` (ls \\<union> G\\<^sup>* `` {Neg x}) \\<subseteq> ls \\<union> G\\<^sup>* `` {Neg x}\""], ["proof (prove)\nusing this:\n  consistent ls\n  G `` ls \\<subseteq> ls\n\ngoal (1 subgoal):\n 1. G `` (ls \\<union> G\\<^sup>* `` {Neg x})\n    \\<subseteq> ls \\<union> G\\<^sup>* `` {Neg x}", "by auto"], ["proof (state)\nthis:\n  G `` (ls \\<union> G\\<^sup>* `` {Neg x})\n  \\<subseteq> ls \\<union> G\\<^sup>* `` {Neg x}\n\ngoal (1 subgoal):\n 1. \\<not> consistent (ls \\<union> G\\<^sup>* `` {Pos x}) \\<Longrightarrow>\n    consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls", "proof (cases \"consistent (ls \\<union> G\\<^sup>* `` {Neg x})\")"], ["proof (state)\ngoal (2 subgoals):\n 1. consistent (ls \\<union> G\\<^sup>* `` {Neg x}) \\<Longrightarrow>\n    consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls\n 2. \\<not> consistent (ls \\<union> G\\<^sup>* `` {Neg x}) \\<Longrightarrow>\n    consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls", "case CNEG[simp]: True"], ["proof (state)\nthis:\n  consistent (ls \\<union> G\\<^sup>* `` {Neg x})\n\ngoal (2 subgoals):\n 1. consistent (ls \\<union> G\\<^sup>* `` {Neg x}) \\<Longrightarrow>\n    consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls\n 2. \\<not> consistent (ls \\<union> G\\<^sup>* `` {Neg x}) \\<Longrightarrow>\n    consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls", "using \"1.IH\"(2)[OF False x_def NCPOS CNEG CL] NCPOS"], ["proof (prove)\nusing this:\n  consistent (extend (ls \\<union> G\\<^sup>* `` {Neg x})) \\<and>\n  G `` extend (ls \\<union> G\\<^sup>* `` {Neg x})\n  \\<subseteq> extend (ls \\<union> G\\<^sup>* `` {Neg x})\n  \\<not> consistent (ls \\<union> G\\<^sup>* `` {Pos x})\n\ngoal (1 subgoal):\n 1. consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls", "unfolding extend.simps[of ls] x_def[symmetric]"], ["proof (prove)\nusing this:\n  consistent (extend (ls \\<union> G\\<^sup>* `` {Neg x})) \\<and>\n  G `` extend (ls \\<union> G\\<^sup>* `` {Neg x})\n  \\<subseteq> extend (ls \\<union> G\\<^sup>* `` {Neg x})\n  \\<not> consistent (ls \\<union> G\\<^sup>* `` {Pos x})\n\ngoal (1 subgoal):\n 1. consistent\n     (if vars_of_cnf cnf \\<subseteq> var ` ls then ls\n      else let x = x\n           in if consistent (ls \\<union> G\\<^sup>* `` {Pos x})\n              then extend (ls \\<union> G\\<^sup>* `` {Pos x})\n              else extend (ls \\<union> G\\<^sup>* `` {Neg x})) \\<and>\n    G ``\n    (if vars_of_cnf cnf \\<subseteq> var ` ls then ls\n     else let x = x\n          in if consistent (ls \\<union> G\\<^sup>* `` {Pos x})\n             then extend (ls \\<union> G\\<^sup>* `` {Pos x})\n             else extend (ls \\<union> G\\<^sup>* `` {Neg x}))\n    \\<subseteq> (if vars_of_cnf cnf \\<subseteq> var ` ls then ls\n                 else let x = x\n                      in if consistent (ls \\<union> G\\<^sup>* `` {Pos x})\n                         then extend (ls \\<union> G\\<^sup>* `` {Pos x})\n                         else extend (ls \\<union> G\\<^sup>* `` {Neg x}))", "by auto"], ["proof (state)\nthis:\n  consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls\n\ngoal (1 subgoal):\n 1. \\<not> consistent (ls \\<union> G\\<^sup>* `` {Neg x}) \\<Longrightarrow>\n    consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> consistent (ls \\<union> G\\<^sup>* `` {Neg x}) \\<Longrightarrow>\n    consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls", "case NCNEG: False"], ["proof (state)\nthis:\n  \\<not> consistent (ls \\<union> G\\<^sup>* `` {Neg x})\n\ngoal (1 subgoal):\n 1. \\<not> consistent (ls \\<union> G\\<^sup>* `` {Neg x}) \\<Longrightarrow>\n    consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls", "have X1: \"(l, negate l)\\<in> G\\<^sup>*\"\n            if UNASS: \"var l \\<notin> var ` ls\" and \"\\<not> consistent (ls \\<union> G\\<^sup>* `` {l})\" for l"], ["proof (prove)\ngoal (1 subgoal):\n 1. (l, negate l) \\<in> G\\<^sup>*", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (l, negate l) \\<in> G\\<^sup>*", "from that(2)"], ["proof (chain)\npicking this:\n  \\<not> consistent (ls \\<union> G\\<^sup>* `` {l})", "obtain y where X1: \"Pos y \\<in> ls \\<union> G\\<^sup>*``{l}\" \"Neg y \\<in> ls \\<union> G\\<^sup>*``{l}\""], ["proof (prove)\nusing this:\n  \\<not> consistent (ls \\<union> G\\<^sup>* `` {l})\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>Pos y \\<in> ls \\<union> G\\<^sup>* `` {l};\n         Neg y \\<in> ls \\<union> G\\<^sup>* `` {l}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding consistent_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<nexists>x.\n             Pos x \\<in> ls \\<union> G\\<^sup>* `` {l} \\<and>\n             Neg x \\<in> ls \\<union> G\\<^sup>* `` {l})\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>Pos y \\<in> ls \\<union> G\\<^sup>* `` {l};\n         Neg y \\<in> ls \\<union> G\\<^sup>* `` {l}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Pos y \\<in> ls \\<union> G\\<^sup>* `` {l}\n  Neg y \\<in> ls \\<union> G\\<^sup>* `` {l}\n\ngoal (1 subgoal):\n 1. (l, negate l) \\<in> G\\<^sup>*", "with \"1.prems\""], ["proof (chain)\npicking this:\n  consistent ls\n  G `` ls \\<subseteq> ls\n  Pos y \\<in> ls \\<union> G\\<^sup>* `` {l}\n  Neg y \\<in> ls \\<union> G\\<^sup>* `` {l}", "have \"(l, Pos y) \\<in> G\\<^sup>* \\<or> (l, Neg y) \\<in> G\\<^sup>*\""], ["proof (prove)\nusing this:\n  consistent ls\n  G `` ls \\<subseteq> ls\n  Pos y \\<in> ls \\<union> G\\<^sup>* `` {l}\n  Neg y \\<in> ls \\<union> G\\<^sup>* `` {l}\n\ngoal (1 subgoal):\n 1. (l, Pos y) \\<in> G\\<^sup>* \\<or> (l, Neg y) \\<in> G\\<^sup>*", "unfolding consistent_def"], ["proof (prove)\nusing this:\n  \\<nexists>x. Pos x \\<in> ls \\<and> Neg x \\<in> ls\n  G `` ls \\<subseteq> ls\n  Pos y \\<in> ls \\<union> G\\<^sup>* `` {l}\n  Neg y \\<in> ls \\<union> G\\<^sup>* `` {l}\n\ngoal (1 subgoal):\n 1. (l, Pos y) \\<in> G\\<^sup>* \\<or> (l, Neg y) \\<in> G\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (l, Pos y) \\<in> G\\<^sup>* \\<or> (l, Neg y) \\<in> G\\<^sup>*\n\ngoal (1 subgoal):\n 1. (l, negate l) \\<in> G\\<^sup>*", "hence X2: \"(l, Pos y) \\<in> G\\<^sup>* \\<and> (l, Neg y) \\<in> G\\<^sup>*\""], ["proof (prove)\nusing this:\n  (l, Pos y) \\<in> G\\<^sup>* \\<or> (l, Neg y) \\<in> G\\<^sup>*\n\ngoal (1 subgoal):\n 1. (l, Pos y) \\<in> G\\<^sup>* \\<and> (l, Neg y) \\<in> G\\<^sup>*", "proof (safe; rule_tac ccontr)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>(l, Pos y) \\<in> G\\<^sup>*;\n     (l, Pos y) \\<in> G\\<^sup>* \\<or> (l, Neg y) \\<in> G\\<^sup>*;\n     (l, Neg y) \\<notin> G\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>(l, Neg y) \\<in> G\\<^sup>*;\n     (l, Pos y) \\<in> G\\<^sup>* \\<or> (l, Neg y) \\<in> G\\<^sup>*;\n     (l, Pos y) \\<notin> G\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"(l, Pos y) \\<in> G\\<^sup>*\" \"(l, Neg y)\\<notin>G\\<^sup>*\""], ["proof (state)\nthis:\n  (l, Pos y) \\<in> G\\<^sup>*\n  (l, Neg y) \\<notin> G\\<^sup>*\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(l, Pos y) \\<in> G\\<^sup>*;\n     (l, Pos y) \\<in> G\\<^sup>* \\<or> (l, Neg y) \\<in> G\\<^sup>*;\n     (l, Neg y) \\<notin> G\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>(l, Neg y) \\<in> G\\<^sup>*;\n     (l, Pos y) \\<in> G\\<^sup>* \\<or> (l, Neg y) \\<in> G\\<^sup>*;\n     (l, Pos y) \\<notin> G\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"(Neg y,negate l)\\<in>G\\<^sup>*\" \"Neg y \\<in> ls\""], ["proof (prove)\nusing this:\n  (l, Pos y) \\<in> G\\<^sup>*\n  (l, Neg y) \\<notin> G\\<^sup>*\n\ngoal (1 subgoal):\n 1. (Neg y, negate l) \\<in> G\\<^sup>* &&& Neg y \\<in> ls", "using X1"], ["proof (prove)\nusing this:\n  (l, Pos y) \\<in> G\\<^sup>*\n  (l, Neg y) \\<notin> G\\<^sup>*\n  Pos y \\<in> ls \\<union> G\\<^sup>* `` {l}\n  Neg y \\<in> ls \\<union> G\\<^sup>* `` {l}\n\ngoal (1 subgoal):\n 1. (Neg y, negate l) \\<in> G\\<^sup>* &&& Neg y \\<in> ls", "by (auto dest: imp_graph_rtrancl_skew_sym)"], ["proof (state)\nthis:\n  (Neg y, negate l) \\<in> G\\<^sup>*\n  Neg y \\<in> ls\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(l, Pos y) \\<in> G\\<^sup>*;\n     (l, Pos y) \\<in> G\\<^sup>* \\<or> (l, Neg y) \\<in> G\\<^sup>*;\n     (l, Neg y) \\<notin> G\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>(l, Neg y) \\<in> G\\<^sup>*;\n     (l, Pos y) \\<in> G\\<^sup>* \\<or> (l, Neg y) \\<in> G\\<^sup>*;\n     (l, Pos y) \\<notin> G\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> False", "with CL"], ["proof (chain)\npicking this:\n  G `` (ls \\<union> G\\<^sup>* `` {Neg x})\n  \\<subseteq> ls \\<union> G\\<^sup>* `` {Neg x}\n  (Neg y, negate l) \\<in> G\\<^sup>*\n  Neg y \\<in> ls", "have \"negate l \\<in> ls\""], ["proof (prove)\nusing this:\n  G `` (ls \\<union> G\\<^sup>* `` {Neg x})\n  \\<subseteq> ls \\<union> G\\<^sup>* `` {Neg x}\n  (Neg y, negate l) \\<in> G\\<^sup>*\n  Neg y \\<in> ls\n\ngoal (1 subgoal):\n 1. negate l \\<in> ls", "by (metis \"1.prems\"(2) ImageI Image_closed_trancl)"], ["proof (state)\nthis:\n  negate l \\<in> ls\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(l, Pos y) \\<in> G\\<^sup>*;\n     (l, Pos y) \\<in> G\\<^sup>* \\<or> (l, Neg y) \\<in> G\\<^sup>*;\n     (l, Neg y) \\<notin> G\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>(l, Neg y) \\<in> G\\<^sup>*;\n     (l, Pos y) \\<in> G\\<^sup>* \\<or> (l, Neg y) \\<in> G\\<^sup>*;\n     (l, Pos y) \\<notin> G\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> False", "with UNASS"], ["proof (chain)\npicking this:\n  var l \\<notin> var ` ls\n  negate l \\<in> ls", "show False"], ["proof (prove)\nusing this:\n  var l \\<notin> var ` ls\n  negate l \\<in> ls\n\ngoal (1 subgoal):\n 1. False", "by (cases l) force+"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(l, Neg y) \\<in> G\\<^sup>*;\n     (l, Pos y) \\<in> G\\<^sup>* \\<or> (l, Neg y) \\<in> G\\<^sup>*;\n     (l, Pos y) \\<notin> G\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(l, Neg y) \\<in> G\\<^sup>*;\n     (l, Pos y) \\<in> G\\<^sup>* \\<or> (l, Neg y) \\<in> G\\<^sup>*;\n     (l, Pos y) \\<notin> G\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"(l, Neg y) \\<in> G\\<^sup>*\" \"(l, Pos y) \\<notin> G\\<^sup>*\""], ["proof (state)\nthis:\n  (l, Neg y) \\<in> G\\<^sup>*\n  (l, Pos y) \\<notin> G\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(l, Neg y) \\<in> G\\<^sup>*;\n     (l, Pos y) \\<in> G\\<^sup>* \\<or> (l, Neg y) \\<in> G\\<^sup>*;\n     (l, Pos y) \\<notin> G\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"(Pos y, negate l) \\<in> G\\<^sup>*\" \"Pos y \\<in> ls\""], ["proof (prove)\nusing this:\n  (l, Neg y) \\<in> G\\<^sup>*\n  (l, Pos y) \\<notin> G\\<^sup>*\n\ngoal (1 subgoal):\n 1. (Pos y, negate l) \\<in> G\\<^sup>* &&& Pos y \\<in> ls", "using X1"], ["proof (prove)\nusing this:\n  (l, Neg y) \\<in> G\\<^sup>*\n  (l, Pos y) \\<notin> G\\<^sup>*\n  Pos y \\<in> ls \\<union> G\\<^sup>* `` {l}\n  Neg y \\<in> ls \\<union> G\\<^sup>* `` {l}\n\ngoal (1 subgoal):\n 1. (Pos y, negate l) \\<in> G\\<^sup>* &&& Pos y \\<in> ls", "by (auto dest: imp_graph_rtrancl_skew_sym)"], ["proof (state)\nthis:\n  (Pos y, negate l) \\<in> G\\<^sup>*\n  Pos y \\<in> ls\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(l, Neg y) \\<in> G\\<^sup>*;\n     (l, Pos y) \\<in> G\\<^sup>* \\<or> (l, Neg y) \\<in> G\\<^sup>*;\n     (l, Pos y) \\<notin> G\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> False", "with CL"], ["proof (chain)\npicking this:\n  G `` (ls \\<union> G\\<^sup>* `` {Neg x})\n  \\<subseteq> ls \\<union> G\\<^sup>* `` {Neg x}\n  (Pos y, negate l) \\<in> G\\<^sup>*\n  Pos y \\<in> ls", "have \"negate l \\<in> ls\""], ["proof (prove)\nusing this:\n  G `` (ls \\<union> G\\<^sup>* `` {Neg x})\n  \\<subseteq> ls \\<union> G\\<^sup>* `` {Neg x}\n  (Pos y, negate l) \\<in> G\\<^sup>*\n  Pos y \\<in> ls\n\ngoal (1 subgoal):\n 1. negate l \\<in> ls", "by (metis \"1.prems\"(2) ImageI Image_closed_trancl)"], ["proof (state)\nthis:\n  negate l \\<in> ls\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(l, Neg y) \\<in> G\\<^sup>*;\n     (l, Pos y) \\<in> G\\<^sup>* \\<or> (l, Neg y) \\<in> G\\<^sup>*;\n     (l, Pos y) \\<notin> G\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> False", "with UNASS"], ["proof (chain)\npicking this:\n  var l \\<notin> var ` ls\n  negate l \\<in> ls", "show False"], ["proof (prove)\nusing this:\n  var l \\<notin> var ` ls\n  negate l \\<in> ls\n\ngoal (1 subgoal):\n 1. False", "by (cases l) force+"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (l, Pos y) \\<in> G\\<^sup>* \\<and> (l, Neg y) \\<in> G\\<^sup>*\n\ngoal (1 subgoal):\n 1. (l, negate l) \\<in> G\\<^sup>*", "from X2 imp_graph_rtrancl_skew_sym[of _ _ cnf]"], ["proof (chain)\npicking this:\n  (l, Pos y) \\<in> G\\<^sup>* \\<and> (l, Neg y) \\<in> G\\<^sup>*\n  (?l\\<^sub>1, ?l\\<^sub>2) \\<in> G\\<^sup>* \\<Longrightarrow>\n  (negate ?l\\<^sub>2, negate ?l\\<^sub>1) \\<in> G\\<^sup>*", "have \"(Neg y, negate l) \\<in> G\\<^sup>*\""], ["proof (prove)\nusing this:\n  (l, Pos y) \\<in> G\\<^sup>* \\<and> (l, Neg y) \\<in> G\\<^sup>*\n  (?l\\<^sub>1, ?l\\<^sub>2) \\<in> G\\<^sup>* \\<Longrightarrow>\n  (negate ?l\\<^sub>2, negate ?l\\<^sub>1) \\<in> G\\<^sup>*\n\ngoal (1 subgoal):\n 1. (Neg y, negate l) \\<in> G\\<^sup>*", "by force"], ["proof (state)\nthis:\n  (Neg y, negate l) \\<in> G\\<^sup>*\n\ngoal (1 subgoal):\n 1. (l, negate l) \\<in> G\\<^sup>*", "with X2"], ["proof (chain)\npicking this:\n  (l, Pos y) \\<in> G\\<^sup>* \\<and> (l, Neg y) \\<in> G\\<^sup>*\n  (Neg y, negate l) \\<in> G\\<^sup>*", "show ?thesis"], ["proof (prove)\nusing this:\n  (l, Pos y) \\<in> G\\<^sup>* \\<and> (l, Neg y) \\<in> G\\<^sup>*\n  (Neg y, negate l) \\<in> G\\<^sup>*\n\ngoal (1 subgoal):\n 1. (l, negate l) \\<in> G\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (l, negate l) \\<in> G\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>var ?l \\<notin> var ` ls;\n   \\<not> consistent (ls \\<union> G\\<^sup>* `` {?l})\\<rbrakk>\n  \\<Longrightarrow> (?l, negate ?l) \\<in> G\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<not> consistent (ls \\<union> G\\<^sup>* `` {Neg x}) \\<Longrightarrow>\n    consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls", "from X1[of \"Pos x\", OF _ NCPOS] XI"], ["proof (chain)\npicking this:\n  var (Pos x) \\<notin> var ` ls \\<Longrightarrow>\n  (Pos x, negate (Pos x)) \\<in> G\\<^sup>*\n  x \\<in> vars_of_cnf cnf - var ` ls", "have \"(Pos x, Neg x)\\<in>G\\<^sup>*\""], ["proof (prove)\nusing this:\n  var (Pos x) \\<notin> var ` ls \\<Longrightarrow>\n  (Pos x, negate (Pos x)) \\<in> G\\<^sup>*\n  x \\<in> vars_of_cnf cnf - var ` ls\n\ngoal (1 subgoal):\n 1. (Pos x, Neg x) \\<in> G\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (Pos x, Neg x) \\<in> G\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<not> consistent (ls \\<union> G\\<^sup>* `` {Neg x}) \\<Longrightarrow>\n    consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls", "moreover"], ["proof (state)\nthis:\n  (Pos x, Neg x) \\<in> G\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<not> consistent (ls \\<union> G\\<^sup>* `` {Neg x}) \\<Longrightarrow>\n    consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls", "from X1[of \"Neg x\", OF _ NCNEG] XI"], ["proof (chain)\npicking this:\n  var (Neg x) \\<notin> var ` ls \\<Longrightarrow>\n  (Neg x, negate (Neg x)) \\<in> G\\<^sup>*\n  x \\<in> vars_of_cnf cnf - var ` ls", "have \"(Neg x, Pos x)\\<in>G\\<^sup>*\""], ["proof (prove)\nusing this:\n  var (Neg x) \\<notin> var ` ls \\<Longrightarrow>\n  (Neg x, negate (Neg x)) \\<in> G\\<^sup>*\n  x \\<in> vars_of_cnf cnf - var ` ls\n\ngoal (1 subgoal):\n 1. (Neg x, Pos x) \\<in> G\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (Neg x, Pos x) \\<in> G\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<not> consistent (ls \\<union> G\\<^sup>* `` {Neg x}) \\<Longrightarrow>\n    consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls", "ultimately"], ["proof (chain)\npicking this:\n  (Pos x, Neg x) \\<in> G\\<^sup>*\n  (Neg x, Pos x) \\<in> G\\<^sup>*", "have False"], ["proof (prove)\nusing this:\n  (Pos x, Neg x) \\<in> G\\<^sup>*\n  (Neg x, Pos x) \\<in> G\\<^sup>*\n\ngoal (1 subgoal):\n 1. False", "using NO_CYC"], ["proof (prove)\nusing this:\n  (Pos x, Neg x) \\<in> G\\<^sup>*\n  (Neg x, Pos x) \\<in> G\\<^sup>*\n  \\<nexists>x.\n     (Pos x, Neg x) \\<in> G\\<^sup>* \\<and> (Neg x, Pos x) \\<in> G\\<^sup>*\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> consistent (ls \\<union> G\\<^sup>* `` {Neg x}) \\<Longrightarrow>\n    consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls", "by blast"], ["proof (state)\nthis:\n  consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  consistent (extend ls) \\<and> G `` extend ls \\<subseteq> extend ls\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma extend_cons_closed:\n    \"consistent (extend {})\" \n    \"G `` extend {} \\<subseteq> extend {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent (extend {}) &&& G `` extend {} \\<subseteq> extend {}", "using extend_cons_closed_aux[of \"{}\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>consistent {}; G `` {} \\<subseteq> {}\\<rbrakk>\n  \\<Longrightarrow> consistent (extend {}) \\<and>\n                    G `` extend {} \\<subseteq> extend {}\n\ngoal (1 subgoal):\n 1. consistent (extend {}) &&& G `` extend {} \\<subseteq> extend {}", "by auto"], ["", "lemma CCV_sat:\n    assumes CONS: \"consistent ls\"\n    assumes CLOSED: \"G``ls \\<subseteq> ls\"\n    assumes VARS: \"vars_of_cnf cnf \\<subseteq> var`ls\"  \n    shows \"sat_cnf (\\<lambda>x. Pos x \\<in> ls) cnf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sat_cnf (\\<lambda>x. Pos x \\<in> ls) cnf", "unfolding sat_cnf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball cnf (sat_clause (\\<lambda>x. Pos x \\<in> ls))", "proof (rule, rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> cnf;\n        \\<not> sat_clause (\\<lambda>x. Pos x \\<in> ls) x\\<rbrakk>\n       \\<Longrightarrow> False", "fix cl"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> cnf;\n        \\<not> sat_clause (\\<lambda>x. Pos x \\<in> ls) x\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"cl\\<in>cnf\""], ["proof (state)\nthis:\n  cl \\<in> cnf\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> cnf;\n        \\<not> sat_clause (\\<lambda>x. Pos x \\<in> ls) x\\<rbrakk>\n       \\<Longrightarrow> False", "with TSAT"], ["proof (chain)\npicking this:\n  is_2sat cnf\n  cl \\<in> cnf", "obtain l1 l2 where [simp]: \"cl = Upair l1 l2\" \"l1 \\<noteq> l2\""], ["proof (prove)\nusing this:\n  is_2sat cnf\n  cl \\<in> cnf\n\ngoal (1 subgoal):\n 1. (\\<And>l1 l2.\n        \\<lbrakk>cl = Upair l1 l2; l1 \\<noteq> l2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding is_2sat_def"], ["proof (prove)\nusing this:\n  Ball cnf proper_uprod\n  cl \\<in> cnf\n\ngoal (1 subgoal):\n 1. (\\<And>l1 l2.\n        \\<lbrakk>cl = Upair l1 l2; l1 \\<noteq> l2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp add: proper_uprod_def dest!: bspec split: uprod_split_asm)"], ["proof (state)\nthis:\n  cl = Upair l1 l2\n  l1 \\<noteq> l2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> cnf;\n        \\<not> sat_clause (\\<lambda>x. Pos x \\<in> ls) x\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"\\<not> sat_clause (\\<lambda>x. Pos x \\<in> ls) cl\""], ["proof (state)\nthis:\n  \\<not> sat_clause (\\<lambda>x. Pos x \\<in> ls) cl\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> cnf;\n        \\<not> sat_clause (\\<lambda>x. Pos x \\<in> ls) x\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"l1 \\<notin> ls\" \"l2 \\<notin> ls\""], ["proof (prove)\nusing this:\n  \\<not> sat_clause (\\<lambda>x. Pos x \\<in> ls) cl\n\ngoal (1 subgoal):\n 1. l1 \\<notin> ls &&& l2 \\<notin> ls", "using \\<open>consistent ls\\<close>"], ["proof (prove)\nusing this:\n  \\<not> sat_clause (\\<lambda>x. Pos x \\<in> ls) cl\n  consistent ls\n\ngoal (1 subgoal):\n 1. l1 \\<notin> ls &&& l2 \\<notin> ls", "apply (auto simp: sat_lit_def consistent_def)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>\\<forall>x. Pos x \\<in> ls \\<longrightarrow> Neg x \\<notin> ls;\n     l1 \\<in> ls; Pos (var l1) \\<in> ls; \\<not> pos l1;\n     Pos (var l2) \\<in> ls; \\<not> pos l2\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>\\<forall>x. Pos x \\<in> ls \\<longrightarrow> Neg x \\<notin> ls;\n     l1 \\<in> ls; Pos (var l1) \\<in> ls; \\<not> pos l1;\n     Pos (var l2) \\<notin> ls; pos l2\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>\\<forall>x. Pos x \\<in> ls \\<longrightarrow> Neg x \\<notin> ls;\n     l1 \\<in> ls; Pos (var l1) \\<notin> ls; pos l1; Pos (var l2) \\<in> ls;\n     \\<not> pos l2\\<rbrakk>\n    \\<Longrightarrow> False\n 4. \\<lbrakk>\\<forall>x. Pos x \\<in> ls \\<longrightarrow> Neg x \\<notin> ls;\n     l1 \\<in> ls; Pos (var l1) \\<notin> ls; pos l1;\n     Pos (var l2) \\<notin> ls; pos l2\\<rbrakk>\n    \\<Longrightarrow> False\n 5. \\<lbrakk>\\<forall>x. Pos x \\<in> ls \\<longrightarrow> Neg x \\<notin> ls;\n     l2 \\<in> ls; Pos (var l1) \\<in> ls; \\<not> pos l1;\n     Pos (var l2) \\<in> ls; \\<not> pos l2\\<rbrakk>\n    \\<Longrightarrow> False\n 6. \\<lbrakk>\\<forall>x. Pos x \\<in> ls \\<longrightarrow> Neg x \\<notin> ls;\n     l2 \\<in> ls; Pos (var l1) \\<in> ls; \\<not> pos l1;\n     Pos (var l2) \\<notin> ls; pos l2\\<rbrakk>\n    \\<Longrightarrow> False\n 7. \\<lbrakk>\\<forall>x. Pos x \\<in> ls \\<longrightarrow> Neg x \\<notin> ls;\n     l2 \\<in> ls; Pos (var l1) \\<notin> ls; pos l1; Pos (var l2) \\<in> ls;\n     \\<not> pos l2\\<rbrakk>\n    \\<Longrightarrow> False\n 8. \\<lbrakk>\\<forall>x. Pos x \\<in> ls \\<longrightarrow> Neg x \\<notin> ls;\n     l2 \\<in> ls; Pos (var l1) \\<notin> ls; pos l1;\n     Pos (var l2) \\<notin> ls; pos l2\\<rbrakk>\n    \\<Longrightarrow> False", "apply (cases l1; cases l2; auto)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  l1 \\<notin> ls\n  l2 \\<notin> ls\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> cnf;\n        \\<not> sat_clause (\\<lambda>x. Pos x \\<in> ls) x\\<rbrakk>\n       \\<Longrightarrow> False", "from VARS \\<open>cl \\<in> cnf\\<close>"], ["proof (chain)\npicking this:\n  vars_of_cnf cnf \\<subseteq> var ` ls\n  cl \\<in> cnf", "have \"var l1 \\<in> var ` ls\""], ["proof (prove)\nusing this:\n  vars_of_cnf cnf \\<subseteq> var ` ls\n  cl \\<in> cnf\n\ngoal (1 subgoal):\n 1. var l1 \\<in> var ` ls", "by (auto 4 3 simp: vars_of_cnf_def)"], ["proof (state)\nthis:\n  var l1 \\<in> var ` ls\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> cnf;\n        \\<not> sat_clause (\\<lambda>x. Pos x \\<in> ls) x\\<rbrakk>\n       \\<Longrightarrow> False", "with \\<open>l1 \\<notin> ls\\<close>"], ["proof (chain)\npicking this:\n  l1 \\<notin> ls\n  var l1 \\<in> var ` ls", "have \"negate l1 \\<in> ls\""], ["proof (prove)\nusing this:\n  l1 \\<notin> ls\n  var l1 \\<in> var ` ls\n\ngoal (1 subgoal):\n 1. negate l1 \\<in> ls", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>l1 \\<notin> ls; var l1 \\<in> var ` ls\\<rbrakk>\n    \\<Longrightarrow> negate l1 \\<in> ls", "have \"\\<forall>L n f. \\<exists>l. ((n::nat) \\<notin> f ` L \\<or> (l::lit) \\<in> L) \\<and> (n \\<notin> f ` L \\<or> f l = n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>L n f.\n       \\<exists>l.\n          (n \\<notin> f ` L \\<or> l \\<in> L) \\<and>\n          (n \\<notin> f ` L \\<or> f l = n)", "by blast"], ["proof (state)\nthis:\n  \\<forall>L n f.\n     \\<exists>l.\n        (n \\<notin> f ` L \\<or> l \\<in> L) \\<and>\n        (n \\<notin> f ` L \\<or> f l = n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l1 \\<notin> ls; var l1 \\<in> var ` ls\\<rbrakk>\n    \\<Longrightarrow> negate l1 \\<in> ls", "then"], ["proof (chain)\npicking this:\n  \\<forall>L n f.\n     \\<exists>l.\n        (n \\<notin> f ` L \\<or> l \\<in> L) \\<and>\n        (n \\<notin> f ` L \\<or> f l = n)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>L n f.\n     \\<exists>l.\n        (n \\<notin> f ` L \\<or> l \\<in> L) \\<and>\n        (n \\<notin> f ` L \\<or> f l = n)\n\ngoal (1 subgoal):\n 1. negate l1 \\<in> ls", "by (metis (no_types) \\<open>l1 \\<notin> ls\\<close> \\<open>var l1 \\<in> var ` ls\\<close> lit.expand negate_sat var_negate)"], ["proof (state)\nthis:\n  negate l1 \\<in> ls\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  negate l1 \\<in> ls\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> cnf;\n        \\<not> sat_clause (\\<lambda>x. Pos x \\<in> ls) x\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  negate l1 \\<in> ls\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> cnf;\n        \\<not> sat_clause (\\<lambda>x. Pos x \\<in> ls) x\\<rbrakk>\n       \\<Longrightarrow> False", "from \\<open>cl \\<in> cnf\\<close>"], ["proof (chain)\npicking this:\n  cl \\<in> cnf", "have \"(negate l1, l2) \\<in> G\""], ["proof (prove)\nusing this:\n  cl \\<in> cnf\n\ngoal (1 subgoal):\n 1. (negate l1, l2) \\<in> G", "unfolding imp_graph_def"], ["proof (prove)\nusing this:\n  cl \\<in> cnf\n\ngoal (1 subgoal):\n 1. (negate l1, l2) \\<in> \\<Union> (edges_of_clause ` cnf)", "by(auto intro: rev_bexI)"], ["proof (state)\nthis:\n  (negate l1, l2) \\<in> G\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> cnf;\n        \\<not> sat_clause (\\<lambda>x. Pos x \\<in> ls) x\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  negate l1 \\<in> ls\n  (negate l1, l2) \\<in> G", "have \"l2 \\<in> ls\""], ["proof (prove)\nusing this:\n  negate l1 \\<in> ls\n  (negate l1, l2) \\<in> G\n\ngoal (1 subgoal):\n 1. l2 \\<in> ls", "using CLOSED"], ["proof (prove)\nusing this:\n  negate l1 \\<in> ls\n  (negate l1, l2) \\<in> G\n  G `` ls \\<subseteq> ls\n\ngoal (1 subgoal):\n 1. l2 \\<in> ls", "by auto"], ["proof (state)\nthis:\n  l2 \\<in> ls\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> cnf;\n        \\<not> sat_clause (\\<lambda>x. Pos x \\<in> ls) x\\<rbrakk>\n       \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  l2 \\<in> ls\n\ngoal (1 subgoal):\n 1. False", "using \\<open>l2 \\<notin> ls\\<close>"], ["proof (prove)\nusing this:\n  l2 \\<in> ls\n  l2 \\<notin> ls\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sat: \"satisfiable cnf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfiable cnf", "using CCV_sat[OF extend_cons_closed extend_vars]"], ["proof (prove)\nusing this:\n  sat_cnf (\\<lambda>x. Pos x \\<in> extend {}) cnf\n\ngoal (1 subgoal):\n 1. satisfiable cnf", "by(auto   simp add: satisfiable_def)"], ["", "end"], ["", "lemma imp_graph_vars:\n  assumes \"(l, l') \\<in> imp_graph cnf\"  \n  shows \"var l \\<in> vars_of_cnf cnf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var l \\<in> vars_of_cnf cnf", "using assms"], ["proof (prove)\nusing this:\n  (l, l') \\<in> imp_graph cnf\n\ngoal (1 subgoal):\n 1. var l \\<in> vars_of_cnf cnf", "unfolding imp_graph_def vars_of_cnf_def"], ["proof (prove)\nusing this:\n  (l, l') \\<in> \\<Union> (edges_of_clause ` cnf)\n\ngoal (1 subgoal):\n 1. var l \\<in> (\\<Union>cl\\<in>cnf. var ` set_uprod cl)", "apply (clarsimp elim!: rev_bexI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (l, l') \\<in> edges_of_clause x \\<Longrightarrow>\n       var l \\<in> var ` set_uprod x", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (l, l') \\<in> edges_of_clause x \\<Longrightarrow>\n    var l \\<in> var ` set_uprod x", "by(cases x)(auto split: uprod_split_asm if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem finite_2sat_iff:\n  assumes FIN: \"finite (vars_of_cnf cnf)\"\n  assumes TSAT: \"is_2sat cnf\"  \n  shows \"satisfiable cnf \n    \\<longleftrightarrow> (\\<forall>x\\<in>vars_of_cnf cnf. \n          \\<not> ((Pos x, Neg x) \\<in> (imp_graph cnf)\\<^sup>* \\<and> (Neg x, Pos x) \\<in> (imp_graph cnf)\\<^sup>* ))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfiable cnf =\n    (\\<forall>x\\<in>vars_of_cnf cnf.\n        \\<not> ((Pos x, Neg x) \\<in> (imp_graph cnf)\\<^sup>* \\<and>\n                (Neg x, Pos x) \\<in> (imp_graph cnf)\\<^sup>*))", "apply (safe;clarsimp?; (auto dest: loop_imp_unsat;fail)?)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_of_cnf cnf.\n       (Pos x, Neg x) \\<in> (imp_graph cnf)\\<^sup>* \\<longrightarrow>\n       (Neg x, Pos x) \\<notin> (imp_graph cnf)\\<^sup>* \\<Longrightarrow>\n    satisfiable cnf", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_of_cnf cnf.\n       (Pos x, Neg x) \\<in> (imp_graph cnf)\\<^sup>* \\<longrightarrow>\n       (Neg x, Pos x) \\<notin> (imp_graph cnf)\\<^sup>* \\<Longrightarrow>\n    satisfiable cnf", "assume \" \\<forall>x\\<in>vars_of_cnf cnf.\n     (Pos x, Neg x) \\<in> (imp_graph cnf)\\<^sup>* \\<longrightarrow> (Neg x, Pos x) \\<notin> (imp_graph cnf)\\<^sup>*\""], ["proof (state)\nthis:\n  \\<forall>x\\<in>vars_of_cnf cnf.\n     (Pos x, Neg x) \\<in> (imp_graph cnf)\\<^sup>* \\<longrightarrow>\n     (Neg x, Pos x) \\<notin> (imp_graph cnf)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_of_cnf cnf.\n       (Pos x, Neg x) \\<in> (imp_graph cnf)\\<^sup>* \\<longrightarrow>\n       (Neg x, Pos x) \\<notin> (imp_graph cnf)\\<^sup>* \\<Longrightarrow>\n    satisfiable cnf", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>vars_of_cnf cnf.\n     (Pos x, Neg x) \\<in> (imp_graph cnf)\\<^sup>* \\<longrightarrow>\n     (Neg x, Pos x) \\<notin> (imp_graph cnf)\\<^sup>*", "interpret construct_sa cnf"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>vars_of_cnf cnf.\n     (Pos x, Neg x) \\<in> (imp_graph cnf)\\<^sup>* \\<longrightarrow>\n     (Neg x, Pos x) \\<notin> (imp_graph cnf)\\<^sup>*\n\ngoal (1 subgoal):\n 1. construct_sa cnf", "apply (unfold_locales)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>x\\<in>vars_of_cnf cnf.\n       (Pos x, Neg x) \\<in> (imp_graph cnf)\\<^sup>* \\<longrightarrow>\n       (Neg x, Pos x) \\<notin> (imp_graph cnf)\\<^sup>* \\<Longrightarrow>\n    finite (vars_of_cnf cnf)\n 2. \\<forall>x\\<in>vars_of_cnf cnf.\n       (Pos x, Neg x) \\<in> (imp_graph cnf)\\<^sup>* \\<longrightarrow>\n       (Neg x, Pos x) \\<notin> (imp_graph cnf)\\<^sup>* \\<Longrightarrow>\n    \\<nexists>x.\n       (Pos x, Neg x) \\<in> (imp_graph cnf)\\<^sup>* \\<and>\n       (Neg x, Pos x) \\<in> (imp_graph cnf)\\<^sup>*\n 3. \\<forall>x\\<in>vars_of_cnf cnf.\n       (Pos x, Neg x) \\<in> (imp_graph cnf)\\<^sup>* \\<longrightarrow>\n       (Neg x, Pos x) \\<notin> (imp_graph cnf)\\<^sup>* \\<Longrightarrow>\n    is_2sat cnf", "using FIN TSAT"], ["proof (prove)\nusing this:\n  finite (vars_of_cnf cnf)\n  is_2sat cnf\n\ngoal (3 subgoals):\n 1. \\<forall>x\\<in>vars_of_cnf cnf.\n       (Pos x, Neg x) \\<in> (imp_graph cnf)\\<^sup>* \\<longrightarrow>\n       (Neg x, Pos x) \\<notin> (imp_graph cnf)\\<^sup>* \\<Longrightarrow>\n    finite (vars_of_cnf cnf)\n 2. \\<forall>x\\<in>vars_of_cnf cnf.\n       (Pos x, Neg x) \\<in> (imp_graph cnf)\\<^sup>* \\<longrightarrow>\n       (Neg x, Pos x) \\<notin> (imp_graph cnf)\\<^sup>* \\<Longrightarrow>\n    \\<nexists>x.\n       (Pos x, Neg x) \\<in> (imp_graph cnf)\\<^sup>* \\<and>\n       (Neg x, Pos x) \\<in> (imp_graph cnf)\\<^sup>*\n 3. \\<forall>x\\<in>vars_of_cnf cnf.\n       (Pos x, Neg x) \\<in> (imp_graph cnf)\\<^sup>* \\<longrightarrow>\n       (Neg x, Pos x) \\<notin> (imp_graph cnf)\\<^sup>* \\<Longrightarrow>\n    is_2sat cnf", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>vars_of_cnf cnf.\n                   (Pos x, Neg x)\n                   \\<in> (imp_graph cnf)\\<^sup>* \\<longrightarrow>\n                   (Neg x, Pos x) \\<notin> (imp_graph cnf)\\<^sup>*;\n        finite (vars_of_cnf cnf); is_2sat cnf;\n        (Pos x, Neg x) \\<in> (imp_graph cnf)\\<^sup>*;\n        (Neg x, Pos x) \\<in> (imp_graph cnf)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis converse_rtranclE imp_graph_vars lit.inject lit.sel(2))"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_of_cnf cnf.\n       (Pos x, Neg x) \\<in> G\\<^sup>* \\<longrightarrow>\n       (Neg x, Pos x) \\<notin> G\\<^sup>* \\<Longrightarrow>\n    satisfiable cnf", "from sat"], ["proof (chain)\npicking this:\n  satisfiable cnf", "show \"satisfiable cnf\""], ["proof (prove)\nusing this:\n  satisfiable cnf\n\ngoal (1 subgoal):\n 1. satisfiable cnf", "."], ["proof (state)\nthis:\n  satisfiable cnf\n\ngoal:\nNo subgoals!", "qed"], ["", "derive linorder lit"], ["", "subsection \\<open>Finiteness\\<close>"], ["", "definition \"lits_of_cnf cnf = Pos`vars_of_cnf cnf \\<union> Neg`vars_of_cnf cnf\""], ["", "lemma inj_on_Pos [simp]: \"inj_on Pos A\" \n  and inj_on_Neg [simp]: \"inj_on Neg A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on Pos A &&& inj_on Neg A", "by(auto simp add: inj_on_def)"], ["", "lemma lits_of_cnf_finite[iff]:\n  \"finite (lits_of_cnf cnf) \\<longleftrightarrow> finite (vars_of_cnf cnf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (lits_of_cnf cnf) = finite (vars_of_cnf cnf)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (lits_of_cnf cnf) = finite (vars_of_cnf cnf)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (lits_of_cnf cnf) = finite (vars_of_cnf cnf)", "unfolding lits_of_cnf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Pos ` vars_of_cnf cnf \\<union> Neg ` vars_of_cnf cnf) =\n    finite (vars_of_cnf cnf)", "by (auto simp: finite_image_iff)"], ["proof (state)\nthis:\n  finite (lits_of_cnf cnf) = finite (vars_of_cnf cnf)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vars_of_cnf_finite[simp, intro]:\n  \"finite cnf \\<Longrightarrow> finite (vars_of_cnf cnf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite cnf \\<Longrightarrow> finite (vars_of_cnf cnf)", "unfolding vars_of_cnf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite cnf \\<Longrightarrow>\n    finite (\\<Union>cl\\<in>cnf. var ` set_uprod cl)", "by auto"], ["", "lemma lit_eq_negate_conv[simp]:\n  \"Lit p v = negate l \\<longleftrightarrow> l = Lit (\\<not>p) v\"\n  \"negate l = Lit p v \\<longleftrightarrow> l = Lit (\\<not>p) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Lit p v = negate l) = (l = Lit (\\<not> p) v) &&&\n    (negate l = Lit p v) = (l = Lit (\\<not> p) v)", "by (cases l; auto)+"], ["", "lemma imp_graph_nodes: \"imp_graph cnf \\<subseteq> lits_of_cnf cnf \\<times> lits_of_cnf cnf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_graph cnf \\<subseteq> lits_of_cnf cnf \\<times> lits_of_cnf cnf", "unfolding imp_graph_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (edges_of_clause ` cnf)\n    \\<subseteq> lits_of_cnf cnf \\<times> lits_of_cnf cnf", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x.\n       \\<lbrakk>x \\<in> cnf; (a, b) \\<in> edges_of_clause x\\<rbrakk>\n       \\<Longrightarrow> a \\<in> lits_of_cnf cnf \\<and>\n                         b \\<in> lits_of_cnf cnf", "subgoal for l1 l2 cl"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cl \\<in> cnf; (l1, l2) \\<in> edges_of_clause cl\\<rbrakk>\n    \\<Longrightarrow> l1 \\<in> lits_of_cnf cnf \\<and>\n                      l2 \\<in> lits_of_cnf cnf", "by (cases cl; cases l1; cases l2)(fastforce simp: lits_of_cnf_def vars_of_cnf_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma imp_graph_finite[simp, intro]: \"finite (vars_of_cnf cnf) \\<Longrightarrow> finite (imp_graph cnf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (vars_of_cnf cnf) \\<Longrightarrow> finite (imp_graph cnf)", "using finite_subset[OF imp_graph_nodes]"], ["proof (prove)\nusing this:\n  finite (lits_of_cnf ?cnf1 \\<times> lits_of_cnf ?cnf1) \\<Longrightarrow>\n  finite (imp_graph ?cnf1)\n\ngoal (1 subgoal):\n 1. finite (vars_of_cnf cnf) \\<Longrightarrow> finite (imp_graph cnf)", "by blast"], ["", "end"]]}