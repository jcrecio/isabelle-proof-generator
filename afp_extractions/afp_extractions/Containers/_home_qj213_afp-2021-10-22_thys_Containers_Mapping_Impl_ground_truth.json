{"file_name": "/home/qj213/afp-2021-10-22/thys/Containers/Mapping_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Containers", "problem_names": ["lemma lookup_Mapping_code [code]:\n  \"Mapping.lookup (Assoc_List_Mapping al) = DAList.lookup al\"\n  \"Mapping.lookup (RBT_Mapping t) = RBT_Mapping2.lookup t\"", "lemma is_empty_transfer [transfer_rule]:\n  includes lifting_syntax\n  shows \"(pcr_mapping (=) (=) ===> (=)) (\\<lambda>m. m = Map.empty) Mapping.is_empty\"", "lemma is_empty_Mapping [code]:\n  fixes t :: \"('a :: ccompare, 'b) mapping_rbt\" shows\n  \"Mapping.is_empty (Assoc_List_Mapping al) \\<longleftrightarrow> al = DAList.empty\"\n  \"Mapping.is_empty (RBT_Mapping t) \\<longleftrightarrow>\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''is_empty RBT_Mapping: ccompare = None'') (\\<lambda>_. Mapping.is_empty (RBT_Mapping t))\n                     | Some _ \\<Rightarrow> RBT_Mapping2.is_empty t)\"", "lemma update_Mapping [code]:\n  fixes t :: \"('a :: ccompare, 'b) mapping_rbt\" shows\n  \"Mapping.update k v (Mapping m) = Mapping (m(k \\<mapsto> v))\"\n  \"Mapping.update k v (Assoc_List_Mapping al) = Assoc_List_Mapping (DAList.update k v al)\"\n  \"Mapping.update k v (RBT_Mapping t) =\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''update RBT_Mapping: ccompare = None'') (\\<lambda>_. Mapping.update k v (RBT_Mapping t))\n                     | Some _ \\<Rightarrow> RBT_Mapping (RBT_Mapping2.insert k v t))\" (is ?RBT)", "lemma delete_Mapping [code]:\n  fixes t :: \"('a :: ccompare, 'b) mapping_rbt\" shows\n  \"Mapping.delete k (Mapping m) = Mapping (m(k := None))\"\n  \"Mapping.delete k (Assoc_List_Mapping al) = Assoc_List_Mapping (AssocList.delete k al)\"\n  \"Mapping.delete k (RBT_Mapping t) = \n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''delete RBT_Mapping: ccompare = None'') (\\<lambda>_. Mapping.delete k (RBT_Mapping t))\n                     | Some _ \\<Rightarrow> RBT_Mapping (RBT_Mapping2.delete k t))\"", "theorem rbt_comp_lookup_map_const: \"rbt_comp_lookup c (RBT_Impl.map (\\<lambda>_. f) t) = map_option f \\<circ> rbt_comp_lookup c t\"", "lemma keys_Mapping [code]:\n  fixes t :: \"('a :: ccompare, 'b) mapping_rbt\" shows\n  \"Mapping.keys (Mapping m) = Collect (\\<lambda>k. m k \\<noteq> None)\" (is \"?Mapping\")\n  \"Mapping.keys (Assoc_List_Mapping al) = AssocList.keys al\" (is \"?Assoc_List\")\n  \"Mapping.keys (RBT_Mapping t) = RBT_set (RBT_Mapping2.map (\\<lambda>_ _. ()) t)\" (is \"?RBT\")", "lemma Mapping_size_transfer [transfer_rule]:\n  includes lifting_syntax\n  shows \"(pcr_mapping (=) (=) ===> (=)) (card \\<circ> dom) Mapping.size\"", "lemma size_Mapping [code]:\n  fixes t :: \"('a :: ccompare, 'b) mapping_rbt\" shows\n  \"Mapping.size (Assoc_List_Mapping al) = size al\"\n  \"Mapping.size (RBT_Mapping t) =\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''size RBT_Mapping: ccompare = None'') (\\<lambda>_. Mapping.size (RBT_Mapping t))\n                     | Some _ \\<Rightarrow> length (RBT_Mapping2.entries t))\"", "lemma filter_code [code]:\n  fixes t :: \"('a :: ccompare, 'b) mapping_rbt\" shows\n  \"Mapping.filter P (Mapping m) = Mapping (\\<lambda>k. case m k of None \\<Rightarrow> None | Some v \\<Rightarrow> if P k v then Some v else None)\"\n  \"Mapping.filter P (Assoc_List_Mapping al) = Assoc_List_Mapping (DAList.filter (\\<lambda>(k, v). P k v) al)\"\n  \"Mapping.filter P (RBT_Mapping t) =\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''filter RBT_Mapping: ccompare = None'') (\\<lambda>_. Mapping.filter P (RBT_Mapping t))\n                         | Some _ \\<Rightarrow> RBT_Mapping (RBT_Mapping2.filter (\\<lambda>(k, v). P k v) t))\"", "lemma map_values_code [code]:\n  fixes t :: \"('a :: ccompare, 'b) mapping_rbt\" shows\n  \"Mapping.map_values f (Mapping m) = Mapping (\\<lambda>k. map_option (f k) (m k))\"\n  \"Mapping.map_values f (Assoc_List_Mapping al) = Assoc_List_Mapping (AssocList.map_values f al)\"\n  \"Mapping.map_values f (RBT_Mapping t) = \n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''map_values RBT_Mapping: ccompare = None'') (\\<lambda>_. Mapping.map_values f (RBT_Mapping t))\n                         | Some _ \\<Rightarrow> RBT_Mapping (RBT_Mapping2.map f t))\"", "lemma [code]:\n  fixes x :: mapping_impl\n  shows \"size x = 0\"\n  and \"size_mapping_impl x = 0\"", "lemma mapping_empty_choose_code [code]:\n  \"(mapping_empty_choose :: ('a :: ccompare, 'b) mapping) =\n   (case ID CCOMPARE('a) of Some _  \\<Rightarrow> RBT_Mapping RBT_Mapping2.empty\n    | None \\<Rightarrow> Assoc_List_Mapping DAList.empty)\"", "lemma mapping_impl_choose2_code [code]:\n  \"mapping_impl_choose2 x y = mapping_Choose\"\n  \"mapping_impl_choose2 mapping_Mapping mapping_Mapping = mapping_Mapping\"\n  \"mapping_impl_choose2 mapping_Assoc_List mapping_Assoc_List = mapping_Assoc_List\"\n  \"mapping_impl_choose2 mapping_RBT mapping_RBT = mapping_RBT\"", "lemma mapping_empty_code [code]:\n  \"mapping_empty mapping_Choose = mapping_empty_choose\"\n  \"mapping_empty mapping_Mapping = Mapping (\\<lambda>_. None)\"\n  \"mapping_empty mapping_Assoc_List = Assoc_List_Mapping DAList.empty\"\n  \"mapping_empty mapping_RBT = RBT_Mapping RBT_Mapping2.empty\"", "lemma Mapping_empty_code [code, code_unfold]: \n  \"(Mapping.empty :: ('a :: mapping_impl, 'b) mapping) =\n   mapping_empty (of_phantom MAPPING_IMPL('a))\"", "lemma bulkload_code [code]:\n  \"Mapping.bulkload vs = RBT_Mapping (RBT_Mapping2.bulkload (zip_with_index vs))\""], "translations": [["", "lemma lookup_Mapping_code [code]:\n  \"Mapping.lookup (Assoc_List_Mapping al) = DAList.lookup al\"\n  \"Mapping.lookup (RBT_Mapping t) = RBT_Mapping2.lookup t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.lookup (Assoc_List_Mapping al) = DAList.lookup al &&&\n    Mapping.lookup (RBT_Mapping t) = RBT_Mapping2.lookup t", "by(simp_all)(transfer, rule)+"], ["", "declare [[code drop: Mapping.is_empty]]"], ["", "lemma is_empty_transfer [transfer_rule]:\n  includes lifting_syntax\n  shows \"(pcr_mapping (=) (=) ===> (=)) (\\<lambda>m. m = Map.empty) Mapping.is_empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pcr_mapping (=) (=) ===> (=)) (\\<lambda>m. m = Map.empty)\n     Mapping.is_empty", "unfolding mapping.pcr_cr_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_mapping ===> (=)) (\\<lambda>m. m = Map.empty) Mapping.is_empty", "apply(rule rel_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       cr_mapping x y \\<Longrightarrow> (x = Map.empty) = Mapping.is_empty y", "apply(case_tac y)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y ya.\n       \\<lbrakk>cr_mapping x y; y = Mapping ya; ya \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> (x = Map.empty) = Mapping.is_empty y", "apply(simp add: Mapping.is_empty_def cr_mapping_def Mapping_inverse Mapping.keys.rep_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_empty_Mapping [code]:\n  fixes t :: \"('a :: ccompare, 'b) mapping_rbt\" shows\n  \"Mapping.is_empty (Assoc_List_Mapping al) \\<longleftrightarrow> al = DAList.empty\"\n  \"Mapping.is_empty (RBT_Mapping t) \\<longleftrightarrow>\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''is_empty RBT_Mapping: ccompare = None'') (\\<lambda>_. Mapping.is_empty (RBT_Mapping t))\n                     | Some _ \\<Rightarrow> RBT_Mapping2.is_empty t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.is_empty (Assoc_List_Mapping al) = (al = DAList.empty) &&&\n    Mapping.is_empty (RBT_Mapping t) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''is_empty RBT_Mapping: ccompare = None''\n        (\\<lambda>_. Mapping.is_empty (RBT_Mapping t))\n     | Some x \\<Rightarrow> RBT_Mapping2.is_empty t)", "apply(simp_all split: option.split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Mapping.is_empty (Mapping (DAList.lookup al)) = (al = DAList.empty)\n 2. (\\<exists>x2. ID ccompare = Some x2) \\<longrightarrow>\n    Mapping.is_empty (Mapping (RBT_Mapping2.lookup t)) =\n    (t = RBT_Mapping2.empty)", "apply(transfer, case_tac al, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x2. ID ccompare = Some x2) \\<longrightarrow>\n    Mapping.is_empty (Mapping (RBT_Mapping2.lookup t)) =\n    (t = RBT_Mapping2.empty)", "apply(transfer, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare [[code drop: Mapping.update]]"], ["", "lemma update_Mapping [code]:\n  fixes t :: \"('a :: ccompare, 'b) mapping_rbt\" shows\n  \"Mapping.update k v (Mapping m) = Mapping (m(k \\<mapsto> v))\"\n  \"Mapping.update k v (Assoc_List_Mapping al) = Assoc_List_Mapping (DAList.update k v al)\"\n  \"Mapping.update k v (RBT_Mapping t) =\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''update RBT_Mapping: ccompare = None'') (\\<lambda>_. Mapping.update k v (RBT_Mapping t))\n                     | Some _ \\<Rightarrow> RBT_Mapping (RBT_Mapping2.insert k v t))\" (is ?RBT)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.update k v (Mapping m) = Mapping (m(k \\<mapsto> v)) &&&\n    Mapping.update k v (Assoc_List_Mapping al) =\n    Assoc_List_Mapping (DAList.update k v al) &&&\n    Mapping.update k v (RBT_Mapping t) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''update RBT_Mapping: ccompare = None''\n        (\\<lambda>_. Mapping.update k v (RBT_Mapping t))\n     | Some x \\<Rightarrow> RBT_Mapping (RBT_Mapping2.insert k v t))", "by(simp_all split: option.split)(transfer, simp)+"], ["", "declare [[code drop: Mapping.delete]]"], ["", "lemma delete_Mapping [code]:\n  fixes t :: \"('a :: ccompare, 'b) mapping_rbt\" shows\n  \"Mapping.delete k (Mapping m) = Mapping (m(k := None))\"\n  \"Mapping.delete k (Assoc_List_Mapping al) = Assoc_List_Mapping (AssocList.delete k al)\"\n  \"Mapping.delete k (RBT_Mapping t) = \n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''delete RBT_Mapping: ccompare = None'') (\\<lambda>_. Mapping.delete k (RBT_Mapping t))\n                     | Some _ \\<Rightarrow> RBT_Mapping (RBT_Mapping2.delete k t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.delete k (Mapping m) = Mapping (m(k := None)) &&&\n    Mapping.delete k (Assoc_List_Mapping al) =\n    Assoc_List_Mapping (AssocList.delete k al) &&&\n    Mapping.delete k (RBT_Mapping t) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''delete RBT_Mapping: ccompare = None''\n        (\\<lambda>_. Mapping.delete k (RBT_Mapping t))\n     | Some x \\<Rightarrow> RBT_Mapping (RBT_Mapping2.delete k t))", "by(simp_all split: option.split)(transfer, simp)+"], ["", "declare [[code drop: Mapping.keys]]"], ["", "theorem rbt_comp_lookup_map_const: \"rbt_comp_lookup c (RBT_Impl.map (\\<lambda>_. f) t) = map_option f \\<circ> rbt_comp_lookup c t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_comp_lookup c (RBT_Impl.map (\\<lambda>_. f) t) =\n    map_option f \\<circ> rbt_comp_lookup c t", "by(induct t)(auto simp: fun_eq_iff split: order.split)"], ["", "lemma keys_Mapping [code]:\n  fixes t :: \"('a :: ccompare, 'b) mapping_rbt\" shows\n  \"Mapping.keys (Mapping m) = Collect (\\<lambda>k. m k \\<noteq> None)\" (is \"?Mapping\")\n  \"Mapping.keys (Assoc_List_Mapping al) = AssocList.keys al\" (is \"?Assoc_List\")\n  \"Mapping.keys (RBT_Mapping t) = RBT_set (RBT_Mapping2.map (\\<lambda>_ _. ()) t)\" (is \"?RBT\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.keys (Mapping m) = {k. m k \\<noteq> None} &&&\n    Mapping.keys (Assoc_List_Mapping al) = AssocList.keys al &&&\n    Mapping.keys (RBT_Mapping t) =\n    RBT_set (RBT_Mapping2.map (\\<lambda>_ _. ()) t)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. Mapping.keys (Mapping m) = {k. m k \\<noteq> None}\n 2. Mapping.keys (Assoc_List_Mapping al) = AssocList.keys al\n 3. Mapping.keys (RBT_Mapping t) =\n    RBT_set (RBT_Mapping2.map (\\<lambda>_ _. ()) t)", "show ?Mapping"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.keys (Mapping m) = {k. m k \\<noteq> None}", "by transfer auto"], ["proof (state)\nthis:\n  Mapping.keys (Mapping m) = {k. m k \\<noteq> None}\n\ngoal (2 subgoals):\n 1. Mapping.keys (Assoc_List_Mapping al) = AssocList.keys al\n 2. Mapping.keys (RBT_Mapping t) =\n    RBT_set (RBT_Mapping2.map (\\<lambda>_ _. ()) t)", "show ?Assoc_List"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.keys (Assoc_List_Mapping al) = AssocList.keys al", "by simp(transfer, auto intro: rev_image_eqI)"], ["proof (state)\nthis:\n  Mapping.keys (Assoc_List_Mapping al) = AssocList.keys al\n\ngoal (1 subgoal):\n 1. Mapping.keys (RBT_Mapping t) =\n    RBT_set (RBT_Mapping2.map (\\<lambda>_ _. ()) t)", "show ?RBT"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.keys (RBT_Mapping t) =\n    RBT_set (RBT_Mapping2.map (\\<lambda>_ _. ()) t)", "by(simp add: RBT_set_def, transfer, auto simp add: rbt_comp_lookup_map_const o_def)"], ["proof (state)\nthis:\n  Mapping.keys (RBT_Mapping t) =\n  RBT_set (RBT_Mapping2.map (\\<lambda>_ _. ()) t)\n\ngoal:\nNo subgoals!", "qed"], ["", "declare [[code drop: Mapping.size]]"], ["", "lemma Mapping_size_transfer [transfer_rule]:\n  includes lifting_syntax\n  shows \"(pcr_mapping (=) (=) ===> (=)) (card \\<circ> dom) Mapping.size\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pcr_mapping (=) (=) ===> (=)) (card \\<circ> dom) Mapping.size", "apply(rule rel_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       pcr_mapping (=) (=) x y \\<Longrightarrow>\n       (card \\<circ> dom) x = Mapping.size y", "apply(case_tac y)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y ya.\n       \\<lbrakk>pcr_mapping (=) (=) x y; y = Mapping ya;\n        ya \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> (card \\<circ> dom) x = Mapping.size y", "apply(simp add: Mapping.size_def Mapping.keys.rep_eq Mapping_inverse mapping.pcr_cr_eq cr_mapping_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma size_Mapping [code]:\n  fixes t :: \"('a :: ccompare, 'b) mapping_rbt\" shows\n  \"Mapping.size (Assoc_List_Mapping al) = size al\"\n  \"Mapping.size (RBT_Mapping t) =\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''size RBT_Mapping: ccompare = None'') (\\<lambda>_. Mapping.size (RBT_Mapping t))\n                     | Some _ \\<Rightarrow> length (RBT_Mapping2.entries t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.size (Assoc_List_Mapping al) = size al &&&\n    Mapping.size (RBT_Mapping t) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''size RBT_Mapping: ccompare = None''\n        (\\<lambda>_. Mapping.size (RBT_Mapping t))\n     | Some x \\<Rightarrow> length (RBT_Mapping2.entries t))", "apply(simp_all split: option.split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Mapping.size (Mapping (DAList.lookup al)) = size al\n 2. (\\<exists>x2. ID ccompare = Some x2) \\<longrightarrow>\n    Mapping.size (Mapping (RBT_Mapping2.lookup t)) =\n    length (RBT_Mapping2.entries t)", "apply(transfer, simp add: dom_map_of_conv_image_fst set_map[symmetric] distinct_card del: set_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x2. ID ccompare = Some x2) \\<longrightarrow>\n    Mapping.size (Mapping (RBT_Mapping2.lookup t)) =\n    length (RBT_Mapping2.entries t)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       ord.is_rbt cless t \\<or> ID ccompare = None \\<Longrightarrow>\n       (\\<exists>x2. ID ccompare = Some x2) \\<longrightarrow>\n       (card \\<circ> dom) (rbt_comp_lookup ccomp t) =\n       length (RBT_Impl.entries t)", "apply(clarsimp simp add: size_eq_card_dom_lookup)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t x2.\n       \\<lbrakk>ord.is_rbt (lt_of_comp x2) t; ID ccompare = Some x2\\<rbrakk>\n       \\<Longrightarrow> card (dom (ord.rbt_lookup (lt_of_comp x2) t)) =\n                         length (RBT_Impl.entries t)", "apply(simp add: linorder.rbt_lookup_keys[OF ID_ccompare] ord.is_rbt_rbt_sorted RBT_Impl.keys_def distinct_card linorder.distinct_entries[OF ID_ccompare] del: set_map)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare [[code drop: Mapping.tabulate]]"], ["", "declare tabulate_fold [code]"], ["", "declare [[code drop: Mapping.ordered_keys]]"], ["", "declare ordered_keys_def[code]"], ["", "declare [[code drop: Mapping.lookup_default]]"], ["", "declare Mapping.lookup_default_def[code]"], ["", "declare [[code drop: Mapping.filter]]"], ["", "lemma filter_code [code]:\n  fixes t :: \"('a :: ccompare, 'b) mapping_rbt\" shows\n  \"Mapping.filter P (Mapping m) = Mapping (\\<lambda>k. case m k of None \\<Rightarrow> None | Some v \\<Rightarrow> if P k v then Some v else None)\"\n  \"Mapping.filter P (Assoc_List_Mapping al) = Assoc_List_Mapping (DAList.filter (\\<lambda>(k, v). P k v) al)\"\n  \"Mapping.filter P (RBT_Mapping t) =\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''filter RBT_Mapping: ccompare = None'') (\\<lambda>_. Mapping.filter P (RBT_Mapping t))\n                         | Some _ \\<Rightarrow> RBT_Mapping (RBT_Mapping2.filter (\\<lambda>(k, v). P k v) t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.filter P (Mapping m) =\n    Mapping\n     (\\<lambda>k.\n         case m k of None \\<Rightarrow> None\n         | Some v \\<Rightarrow> if P k v then Some v else None) &&&\n    Mapping.filter P (Assoc_List_Mapping al) =\n    Assoc_List_Mapping (DAList.filter (\\<lambda>(k, v). P k v) al) &&&\n    Mapping.filter P (RBT_Mapping t) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''filter RBT_Mapping: ccompare = None''\n        (\\<lambda>_. Mapping.filter P (RBT_Mapping t))\n     | Some x \\<Rightarrow>\n         RBT_Mapping (RBT_Mapping2.filter (\\<lambda>(k, v). P k v) t))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.filter P (Mapping m) =\n    Mapping\n     (\\<lambda>k.\n         case m k of None \\<Rightarrow> None\n         | Some v \\<Rightarrow> if P k v then Some v else None)", "by transfer simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. Mapping.filter P (Assoc_List_Mapping al) =\n    Assoc_List_Mapping (DAList.filter (\\<lambda>(k, v). P k v) al)\n 2. Mapping.filter P (RBT_Mapping t) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''filter RBT_Mapping: ccompare = None''\n        (\\<lambda>_. Mapping.filter P (RBT_Mapping t))\n     | Some x \\<Rightarrow>\n         RBT_Mapping (RBT_Mapping2.filter (\\<lambda>(k, v). P k v) t))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.filter P (Assoc_List_Mapping al) =\n    Assoc_List_Mapping (DAList.filter (\\<lambda>(k, v). P k v) al)", "by (simp, transfer)(simp add: map_of_filter_apply fun_eq_iff cong: if_cong option.case_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.filter P (RBT_Mapping t) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''filter RBT_Mapping: ccompare = None''\n        (\\<lambda>_. Mapping.filter P (RBT_Mapping t))\n     | Some x \\<Rightarrow>\n         RBT_Mapping (RBT_Mapping2.filter (\\<lambda>(k, v). P k v) t))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.filter P (RBT_Mapping t) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''filter RBT_Mapping: ccompare = None''\n        (\\<lambda>_. Mapping.filter P (RBT_Mapping t))\n     | Some x \\<Rightarrow>\n         RBT_Mapping (RBT_Mapping2.filter (\\<lambda>(k, v). P k v) t))", "by(clarsimp simp add: Mapping_inject Mapping.filter.abs_eq fun_eq_iff split: option.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare [[code drop: Mapping.map]]"], ["", "lemma map_values_code [code]:\n  fixes t :: \"('a :: ccompare, 'b) mapping_rbt\" shows\n  \"Mapping.map_values f (Mapping m) = Mapping (\\<lambda>k. map_option (f k) (m k))\"\n  \"Mapping.map_values f (Assoc_List_Mapping al) = Assoc_List_Mapping (AssocList.map_values f al)\"\n  \"Mapping.map_values f (RBT_Mapping t) = \n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''map_values RBT_Mapping: ccompare = None'') (\\<lambda>_. Mapping.map_values f (RBT_Mapping t))\n                         | Some _ \\<Rightarrow> RBT_Mapping (RBT_Mapping2.map f t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.map_values f (Mapping m) =\n    Mapping (\\<lambda>k. map_option (f k) (m k)) &&&\n    Mapping.map_values f (Assoc_List_Mapping al) =\n    Assoc_List_Mapping (map_values f al) &&&\n    Mapping.map_values f (RBT_Mapping t) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''map_values RBT_Mapping: ccompare = None''\n        (\\<lambda>_. Mapping.map_values f (RBT_Mapping t))\n     | Some x \\<Rightarrow> RBT_Mapping (RBT_Mapping2.map f t))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.map_values f (Mapping m) =\n    Mapping (\\<lambda>k. map_option (f k) (m k))", "by transfer simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. Mapping.map_values f (Assoc_List_Mapping al) =\n    Assoc_List_Mapping (map_values f al)\n 2. Mapping.map_values f (RBT_Mapping t) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''map_values RBT_Mapping: ccompare = None''\n        (\\<lambda>_. Mapping.map_values f (RBT_Mapping t))\n     | Some x \\<Rightarrow> RBT_Mapping (RBT_Mapping2.map f t))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.map_values f (Assoc_List_Mapping al) =\n    Assoc_List_Mapping (map_values f al)", "by(simp, transfer)(simp add: fun_eq_iff map_of_map')"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.map_values f (RBT_Mapping t) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''map_values RBT_Mapping: ccompare = None''\n        (\\<lambda>_. Mapping.map_values f (RBT_Mapping t))\n     | Some x \\<Rightarrow> RBT_Mapping (RBT_Mapping2.map f t))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.map_values f (RBT_Mapping t) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''map_values RBT_Mapping: ccompare = None''\n        (\\<lambda>_. Mapping.map_values f (RBT_Mapping t))\n     | Some x \\<Rightarrow> RBT_Mapping (RBT_Mapping2.map f t))", "by(clarsimp simp add: Mapping_inject Mapping.map_values.abs_eq fun_eq_iff split: option.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare [[code drop: Mapping.combine_with_key]]"], ["", "declare [[code drop: Mapping.combine]]"], ["", "datatype mapping_impl = Mapping_IMPL"], ["", "declare\n  mapping_impl.eq.simps [code del]\n  mapping_impl.rec [code del]\n  mapping_impl.case [code del]"], ["", "lemma [code]:\n  fixes x :: mapping_impl\n  shows \"size x = 0\"\n  and \"size_mapping_impl x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size x = 0 &&& size_mapping_impl x = 0", "by(case_tac [!] x) simp_all"], ["", "definition mapping_Choose :: mapping_impl where [simp]: \"mapping_Choose = Mapping_IMPL\""], ["", "definition mapping_Assoc_List :: mapping_impl where [simp]: \"mapping_Assoc_List = Mapping_IMPL\""], ["", "definition mapping_RBT :: mapping_impl where [simp]: \"mapping_RBT = Mapping_IMPL\""], ["", "definition mapping_Mapping :: mapping_impl where [simp]: \"mapping_Mapping = Mapping_IMPL\""], ["", "code_datatype mapping_Choose mapping_Assoc_List mapping_RBT mapping_Mapping"], ["", "definition mapping_empty_choose :: \"('a, 'b) mapping\" \nwhere [simp]: \"mapping_empty_choose = Mapping.empty\""], ["", "lemma mapping_empty_choose_code [code]:\n  \"(mapping_empty_choose :: ('a :: ccompare, 'b) mapping) =\n   (case ID CCOMPARE('a) of Some _  \\<Rightarrow> RBT_Mapping RBT_Mapping2.empty\n    | None \\<Rightarrow> Assoc_List_Mapping DAList.empty)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mapping_empty_choose =\n    (case ID ccompare of None \\<Rightarrow> Assoc_List_Mapping DAList.empty\n     | Some x \\<Rightarrow> RBT_Mapping RBT_Mapping2.empty)", "by(auto split: option.split simp add: DAList.lookup_empty[abs_def] Mapping.empty_def)"], ["", "definition mapping_impl_choose2 :: \"mapping_impl \\<Rightarrow> mapping_impl \\<Rightarrow> mapping_impl\"\nwhere [simp]: \"mapping_impl_choose2 = (\\<lambda>_ _. Mapping_IMPL)\""], ["", "lemma mapping_impl_choose2_code [code]:\n  \"mapping_impl_choose2 x y = mapping_Choose\"\n  \"mapping_impl_choose2 mapping_Mapping mapping_Mapping = mapping_Mapping\"\n  \"mapping_impl_choose2 mapping_Assoc_List mapping_Assoc_List = mapping_Assoc_List\"\n  \"mapping_impl_choose2 mapping_RBT mapping_RBT = mapping_RBT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mapping_impl_choose2 x y = mapping_Choose &&&\n     mapping_impl_choose2 mapping_Mapping mapping_Mapping =\n     mapping_Mapping) &&&\n    mapping_impl_choose2 mapping_Assoc_List mapping_Assoc_List =\n    mapping_Assoc_List &&&\n    mapping_impl_choose2 mapping_RBT mapping_RBT = mapping_RBT", "by(simp_all)"], ["", "definition mapping_empty :: \"mapping_impl \\<Rightarrow> ('a, 'b) mapping\"\nwhere [simp]: \"mapping_empty = (\\<lambda>_. Mapping.empty)\""], ["", "lemma mapping_empty_code [code]:\n  \"mapping_empty mapping_Choose = mapping_empty_choose\"\n  \"mapping_empty mapping_Mapping = Mapping (\\<lambda>_. None)\"\n  \"mapping_empty mapping_Assoc_List = Assoc_List_Mapping DAList.empty\"\n  \"mapping_empty mapping_RBT = RBT_Mapping RBT_Mapping2.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mapping_empty mapping_Choose = mapping_empty_choose &&&\n     mapping_empty mapping_Mapping = Mapping Map.empty) &&&\n    mapping_empty mapping_Assoc_List = Assoc_List_Mapping DAList.empty &&&\n    mapping_empty mapping_RBT = RBT_Mapping RBT_Mapping2.empty", "by(simp_all add: Mapping.empty_def DAList.lookup_empty[abs_def])"], ["", "subsection \\<open>Type classes\\<close>"], ["", "class mapping_impl = \n  fixes mapping_impl :: \"('a, mapping_impl) phantom\""], ["", "syntax (input)\n  \"_MAPPING_IMPL\" :: \"type => logic\"  (\"(1MAPPING'_IMPL/(1'(_')))\")"], ["", "parse_translation \\<open>\nlet\n  fun mapping_impl_tr [ty] =\n     (Syntax.const @{syntax_const \"_constrain\"} $ Syntax.const @{const_syntax \"mapping_impl\"} $\n       (Syntax.const @{type_syntax phantom} $ ty $ Syntax.const @{type_syntax mapping_impl}))\n    | mapping_impl_tr ts = raise TERM (\"mapping_impl_tr\", ts);\nin [(@{syntax_const \"_MAPPING_IMPL\"}, K mapping_impl_tr)] end\n\\<close>"], ["", "declare [[code drop: Mapping.empty]]"], ["", "lemma Mapping_empty_code [code, code_unfold]: \n  \"(Mapping.empty :: ('a :: mapping_impl, 'b) mapping) =\n   mapping_empty (of_phantom MAPPING_IMPL('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.empty = mapping_empty (of_phantom mapping_impl)", "by simp"], ["", "subsection \\<open>Generator for the @{class mapping_impl}-class\\<close>"], ["", "text \\<open>\nThis generator registers itself at the derive-manager for the classes @{class mapping_impl}.\nHere, one can choose\nthe desired implementation via the parameter. \n\n\\begin{itemize}\n\\item \\texttt{instantiation type :: (type,\\ldots,type) (rbt,assoclist,mapping,choose, or arbitrary constant name) mapping-impl}\n\\end{itemize}\n\\<close>"], ["", "text \\<open>\nThis generator can be used for arbitrary types, not just datatypes. \n\\<close>"], ["", "ML_file \\<open>mapping_impl_generator.ML\\<close>"], ["", "derive (assoclist) mapping_impl unit bool"], ["", "derive (rbt) mapping_impl nat"], ["", "derive (mapping_RBT) mapping_impl int"], ["", "(* shows usage of constant names *)"], ["", "derive (assoclist) mapping_impl Enum.finite_1 Enum.finite_2 Enum.finite_3"], ["", "derive (rbt) mapping_impl integer natural"], ["", "derive (rbt) mapping_impl char"], ["", "instantiation sum :: (mapping_impl, mapping_impl) mapping_impl begin"], ["", "definition \"MAPPING_IMPL('a + 'b) = Phantom('a + 'b) \n  (mapping_impl_choose2 (of_phantom MAPPING_IMPL('a)) (of_phantom MAPPING_IMPL('b)))\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a + 'b, mapping_impl_class)", ".."], ["", "end"], ["", "instantiation prod :: (mapping_impl, mapping_impl) mapping_impl begin"], ["", "definition \"MAPPING_IMPL('a * 'b) = Phantom('a * 'b) \n  (mapping_impl_choose2 (of_phantom MAPPING_IMPL('a)) (of_phantom MAPPING_IMPL('b)))\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<times> 'b, mapping_impl_class)", ".."], ["", "end"], ["", "derive (choose) mapping_impl list"], ["", "derive (rbt) mapping_impl String.literal"], ["", "instantiation option :: (mapping_impl) mapping_impl begin"], ["", "definition \"MAPPING_IMPL('a option) = Phantom('a option) (of_phantom MAPPING_IMPL('a))\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a option, mapping_impl_class)", ".."], ["", "end"], ["", "derive (choose) mapping_impl set"], ["", "instantiation phantom :: (type, mapping_impl) mapping_impl begin"], ["", "definition \"MAPPING_IMPL(('a, 'b) phantom) = Phantom (('a, 'b) phantom) \n  (of_phantom MAPPING_IMPL('b))\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) phantom, mapping_impl_class)", ".."], ["", "end"], ["", "declare [[code drop: Mapping.bulkload]]"], ["", "lemma bulkload_code [code]:\n  \"Mapping.bulkload vs = RBT_Mapping (RBT_Mapping2.bulkload (zip_with_index vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.bulkload vs =\n    RBT_Mapping (RBT_Mapping2.bulkload (zip_with_index vs))", "by(simp add: Mapping.bulkload.abs_eq Mapping_inject ccompare_nat_def ID_def fun_eq_iff)"], ["", "end"]]}