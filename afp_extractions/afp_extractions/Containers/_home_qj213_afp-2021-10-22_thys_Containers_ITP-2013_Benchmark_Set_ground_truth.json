{"file_name": "/home/qj213/afp-2021-10-22/thys/Containers/ITP-2013/Benchmark_Set.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Containers", "problem_names": ["lemma word_of_integer_code [code]:\n  \"word_of_integer k = \n  (if k < 0 then - word_of_integer (- k)\n   else if k = 0 then 0\n   else let (q, r) = divmod_integer k 2\n        in if r = 0 then 2 * word_of_integer q else 2 * word_of_integer q + 1)\""], "translations": [["", "lemma word_of_integer_code [code]:\n  \"word_of_integer k = \n  (if k < 0 then - word_of_integer (- k)\n   else if k = 0 then 0\n   else let (q, r) = divmod_integer k 2\n        in if r = 0 then 2 * word_of_integer q else 2 * word_of_integer q + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. word_of_integer k =\n    (if k < 0 then - word_of_integer (- k)\n     else if k = 0 then 0\n          else let (q, r) = divmod_integer k 2\n               in if r = 0 then 2 * word_of_integer q\n                  else 2 * word_of_integer q + 1)", "apply (unfold word_of_integer_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (word_of_int \\<circ> int_of_integer) k =\n    (if k < 0 then - (word_of_int \\<circ> int_of_integer) (- k)\n     else if k = 0 then 0\n          else let (q, r) = divmod_integer k 2\n               in if r = 0 then 2 * (word_of_int \\<circ> int_of_integer) q\n                  else 2 * (word_of_int \\<circ> int_of_integer) q + 1)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       take_bit LENGTH('a) (((\\<lambda>k. k) \\<circ> int_of_integer) k) =\n       take_bit LENGTH('a)\n        (if k < 0 then - ((\\<lambda>k. k) \\<circ> int_of_integer) (- k)\n         else if k = 0 then 0\n              else let (q, r) = divmod_integer k 2\n                   in if r = 0\n                      then 2 * ((\\<lambda>k. k) \\<circ> int_of_integer) q\n                      else 2 * ((\\<lambda>k. k) \\<circ> int_of_integer) q +\n                           1)", "apply (auto simp add: not_less comp_def split_beta)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k mod 2 = 1; k \\<noteq> 0; 0 \\<le> k\\<rbrakk>\n       \\<Longrightarrow> take_bit LENGTH('a) (int_of_integer k) =\n                         take_bit LENGTH('a)\n                          (2 * (int_of_integer k div 2) + 1)", "apply (subst int_of_integer_code)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k mod 2 = 1; k \\<noteq> 0; 0 \\<le> k\\<rbrakk>\n       \\<Longrightarrow> take_bit LENGTH('a)\n                          (if k < 0 then - int_of_integer (- k)\n                           else if k = 0 then 0\n                                else let (l, j) = divmod_integer k 2;\n   l' = 2 * int_of_integer l\n                                     in if j = 0 then l' else l' + 1) =\n                         take_bit LENGTH('a)\n                          (2 * (int_of_integer k div 2) + 1)", "apply (clarsimp simp add: divmod_integer_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition word_of :: \"natural \\<Rightarrow> 'a::len word\"\nwhere \"word_of = word_of_integer o integer_of_natural\""], ["", "text \\<open>randomly generate a set of (up to) n elements drawn from 0 to bound\\<close>"], ["", "fun gen_build1 :: \"natural \\<Rightarrow> nat \\<Rightarrow> (32 word set \\<times> Random.seed) \\<Rightarrow> (32 word set \\<times> Random.seed)\"\nwhere \n  \"gen_build1 bound n (A, seed) =\n  (if n = 0 then (A, seed) \n   else let (x, seed') = Random.range bound seed in gen_build1 bound (n - 1) (insert (word_of x) A, seed'))\""], ["", "declare gen_build1.simps[simp del]"], ["", "definition build1 :: \"natural \\<Rightarrow> Random.seed \\<Rightarrow> (32 word set \\<times> Random.seed)\"\nwhere \n  \"build1 bound seed =\n  (let (n', seed') = Random.range bound seed;\n       (compl, seed'') = Random.range 2 seed;\n       (x, seed''') = gen_build1 bound (Code_Numeral.nat_of_natural n') ({}, seed'')\n   in (if compl = 0 then x else - x, seed'''))\""], ["", "text \\<open>randomly generate a set of (up to) n sets each with a random number between 0 and bound of elements between 0 and bound\\<close>"], ["", "fun gen_build2 :: \"natural \\<Rightarrow> nat \\<Rightarrow> (32 word set set \\<times> Random.seed) \\<Rightarrow> (32 word set set \\<times> Random.seed)\"\nwhere\n  \"gen_build2 bound n (A, seed) =\n  (if n = 0 then (A, seed)\n   else let (x, seed') = build1 bound seed\n        in gen_build2 bound (n - 1) (insert x A, seed'))\""], ["", "declare gen_build2.simps[simp del]"], ["", "definition build :: \"nat \\<Rightarrow> nat \\<Rightarrow> Random.seed \\<Rightarrow> 32 word set set \\<times> Random.seed\"\nwhere \"build n m seed = gen_build2 (of_nat m) n ({}, seed)\""], ["", "fun gen_lookup :: \"32 word set set \\<Rightarrow> natural \\<Rightarrow> nat \\<Rightarrow> (nat \\<times> Random.seed) \\<Rightarrow> (nat \\<times> Random.seed)\"\nwhere\n  \"gen_lookup A bound n (hits, seed) =\n  (if n = 0 then (hits, seed)\n   else let (x, seed') = build1 bound seed\n        in gen_lookup A bound (n - 1) (if x : A then hits + 1 else hits, seed'))\""], ["", "declare gen_lookup.simps [simp del]"], ["", "primrec lookup :: \"nat \\<Rightarrow> nat \\<Rightarrow> (32 word set set \\<times> Random.seed) \\<Rightarrow> (nat \\<times> Random.seed)\"\nwhere \"lookup n m (A, seed) = gen_lookup A (of_nat m) 100 (0, seed)\""], ["", "definition covered :: \"32 word set set \\<Rightarrow> nat\"\nwhere \"covered A = card (\\<Union>A)\""], ["", "definition complete :: \"nat \\<Rightarrow> nat \\<Rightarrow> Random.seed \\<Rightarrow> (nat \\<times> nat)\"\nwhere \"complete n m seed = (let (A, seed') = build n m seed in (fst (lookup n m (A, seed)), covered A))\""], ["", "end"]]}