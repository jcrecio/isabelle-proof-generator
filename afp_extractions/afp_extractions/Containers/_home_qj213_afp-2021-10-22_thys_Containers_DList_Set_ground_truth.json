{"file_name": "/home/qj213/afp-2021-10-22/thys/Containers/DList_Set.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Containers", "problem_names": ["lemma list_member_filterD: \"list_member (filter P xs) x \\<Longrightarrow> list_member xs x\"", "lemma list_distinct_filter [simp]: \"list_distinct xs \\<Longrightarrow> list_distinct (filter P xs)\"", "lemma list_distinct_tl [simp]: \"list_distinct xs \\<Longrightarrow> list_distinct (tl xs)\"", "lemmas [code] =\n  equal_base.list_member.simps\n  equal_base.list_distinct.simps\n  equal_base.list_insert_def\n  equal_base.list_remove1.simps\n  equal_base.list_remdups.simps", "lemmas [simp] =\n  equal_base.list_member.simps\n  equal_base.list_distinct.simps\n  equal_base.list_remove1.simps\n  equal_base.list_remdups.simps", "lemma list_member_conv_member [simp]: \n  \"equal_base.list_member (=) = List.member\"", "lemma list_distinct_conv_distinct [simp]:\n  \"equal_base.list_distinct (=) = List.distinct\"", "lemma list_insert_conv_insert [simp]:\n  \"equal_base.list_insert (=) = List.insert\"", "lemma list_remove1_conv_remove1 [simp]:\n  \"equal_base.list_remove1 (=) = List.remove1\"", "lemma list_remdups_conv_remdups [simp]:\n  \"equal_base.list_remdups (=) = List.remdups\"", "lemma member_insert [simp]: \"list_member (list_insert x xs) y \\<longleftrightarrow> equal x y \\<or> list_member xs y\"", "lemma member_remove1 [simp]:\n  \"\\<not> equal x y \\<Longrightarrow> list_member (list_remove1 x xs) y = list_member xs y\"", "lemma distinct_remove1:\n  \"list_distinct xs \\<Longrightarrow> list_distinct (list_remove1 x xs)\"", "lemma distinct_member_remove1 [simp]:\n  \"list_distinct xs \\<Longrightarrow> list_member (list_remove1 x xs) = (list_member xs)(x := False)\"", "lemma ID_ceq: (* FIXME: Adapt Set_Impl to directly use above equal class! *)\n  \"ID CEQ('a :: ceq) = Some eq \\<Longrightarrow> equal eq\"", "lemma Abs_dlist_inverse:\n  fixes y :: \"'a :: ceq list\"\n  assumes \"y \\<in> {xs. equal_base.list_distinct ceq' xs \\<or> ID CEQ('a) = None}\"\n  shows \"list_of_dlist (Abs_dlist y) = y\"", "lemma list_of_dlist_inverse: \"Abs_dlist (list_of_dlist dxs) = dxs\"", "lemma type_definition_set_dlist':\n  \"type_definition list_of_dlist Abs_dlist\n  {xs :: 'a :: ceq list. equal_base.list_distinct ceq' xs \\<or> ID CEQ('a) = None}\"", "lemmas Abs_dlist_cases[cases type: set_dlist] = \n  type_definition.Abs_cases[OF type_definition_set_dlist'] \n  and Abs_dlist_induct[induct type: set_dlist] =\n  type_definition.Abs_induct[OF type_definition_set_dlist'] and\n  Abs_dlist_inject = type_definition.Abs_inject[OF type_definition_set_dlist']", "lemma member_empty [simp]: \"member empty = (\\<lambda>_. False)\"", "lemma null_iff [simp]: \"null xs \\<longleftrightarrow> xs = empty\"", "lemma list_of_dlist_empty [simp]: \"list_of_dlist DList_Set.empty = []\"", "lemma list_of_dlist_insert [simp]: \"\\<not> member dxs x \\<Longrightarrow> list_of_dlist (insert x dxs) = x # list_of_dlist dxs\"", "lemma list_of_dlist_eq_Nil_iff [simp]: \"list_of_dlist dxs = [] \\<longleftrightarrow> dxs = empty\"", "lemma fold_empty [simp]: \"DList_Set.fold f empty b = b\"", "lemma fold_insert [simp]: \"\\<not> member dxs x \\<Longrightarrow> DList_Set.fold f (insert x dxs) b = DList_Set.fold f dxs (f x b)\"", "lemma no_memb_fold_insert:\n  \"\\<not> member dxs x \\<Longrightarrow> fold f (insert x dxs) b = fold f dxs (f x b)\"", "lemma set_fold_insert: \"set (List.fold List.insert xs1 xs2) = set xs1 \\<union> set xs2\"", "lemma list_of_dlist_eq_singleton_conv:\n  \"list_of_dlist dxs = [x] \\<longleftrightarrow> dxs = DList_Set.insert x DList_Set.empty\"", "lemma product_code [code abstract]:\n  \"list_of_dlist (product dxs1 dxs2) = fold (\\<lambda>a. fold (\\<lambda>c rest. (a, c) # rest) dxs2) dxs1 []\"", "lemma set_list_of_dlist_Abs_dlist:\n  \"set (list_of_dlist (Abs_dlist xs)) = set xs\"", "lemma equal_ceq: \"equal (ceq' :: 'a \\<Rightarrow> 'a \\<Rightarrow> bool)\"", "lemma set_dlist_induct [case_names Nil insert, induct type: set_dlist]:\n  fixes dxs :: \"'a :: ceq set_dlist\"\n  assumes Nil: \"P empty\" and Cons: \"\\<And>a dxs. \\<lbrakk> \\<not> member dxs a; P dxs \\<rbrakk> \\<Longrightarrow> P (insert a dxs)\"\n  shows \"P dxs\"", "lemma fold_transfer2 [transfer_rule]:\n  assumes \"is_equality A\"\n  shows \"((A ===> pcr_set_dlist (=) ===> pcr_set_dlist (=)) ===>\n    (pcr_set_dlist (=) :: 'a list \\<Rightarrow> 'a set_dlist \\<Rightarrow> bool) ===> pcr_set_dlist (=) ===> pcr_set_dlist (=))\n     List.fold DList_Set.fold\"", "lemma distinct_list_of_dlist:\n  \"distinct (list_of_dlist (dxs :: 'a set_dlist))\"", "lemma member_empty_empty: \"(\\<forall>x :: 'a. \\<not> member dxs x) \\<longleftrightarrow> dxs = empty\"", "lemma Collect_member: \"Collect (member (dxs :: 'a set_dlist)) = set (list_of_dlist dxs)\"", "lemma member_insert: \"member (insert (x :: 'a) xs) = (member xs)(x := True)\"", "lemma member_remove:\n  \"member (remove (x :: 'a) xs) = (member xs)(x := False)\"", "lemma member_union: \"member (union (xs1 :: 'a set_dlist) xs2) x \\<longleftrightarrow> member xs1 x \\<or> member xs2 x\"", "lemma member_fold_insert: \"member (List.fold insert xs dxs) (x :: 'a) \\<longleftrightarrow> member dxs x \\<or> x \\<in> set xs\"", "lemma card_eq_length [simp]:\n  \"card (Collect (member (dxs :: 'a set_dlist))) = length dxs\"", "lemma finite_member [simp]: \n  \"finite (Collect (member (dxs :: 'a set_dlist)))\"", "lemma member_filter [simp]: \"member (filter P xs) = (\\<lambda>x :: 'a. member xs x \\<and> P x)\"", "lemma dlist_all_conv_member: \"dlist_all P dxs \\<longleftrightarrow> (\\<forall>x :: 'a. member dxs x \\<longrightarrow> P x)\"", "lemma dlist_ex_conv_member: \"dlist_ex P dxs \\<longleftrightarrow> (\\<exists>x :: 'a. member dxs x \\<and> P x)\"", "lemma member_Id_on: \"member (Id_on dxs) = (\\<lambda>(x :: 'a, y). x = y \\<and> member dxs x)\"", "lemma product_member: \n  assumes \"ID CEQ('a :: ceq) \\<noteq> None\" \"ID CEQ('b :: ceq) \\<noteq> None\"\n  shows \"member (product dxs1 dxs2) = (\\<lambda>(a :: 'a, b :: 'b). member dxs1 a \\<and> member dxs2 b)\""], "translations": [["", "lemma list_member_filterD: \"list_member (filter P xs) x \\<Longrightarrow> list_member xs x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_member (filter P xs) x \\<Longrightarrow> list_member xs x", "by(induct xs)(auto split: if_split_asm)"], ["", "lemma list_distinct_filter [simp]: \"list_distinct xs \\<Longrightarrow> list_distinct (filter P xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_distinct xs \\<Longrightarrow> list_distinct (filter P xs)", "by(induct xs)(auto dest: list_member_filterD)"], ["", "lemma list_distinct_tl [simp]: \"list_distinct xs \\<Longrightarrow> list_distinct (tl xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_distinct xs \\<Longrightarrow> list_distinct (tl xs)", "by(cases xs) simp_all"], ["", "end"], ["", "lemmas [code] =\n  equal_base.list_member.simps\n  equal_base.list_distinct.simps\n  equal_base.list_insert_def\n  equal_base.list_remove1.simps\n  equal_base.list_remdups.simps"], ["", "lemmas [simp] =\n  equal_base.list_member.simps\n  equal_base.list_distinct.simps\n  equal_base.list_remove1.simps\n  equal_base.list_remdups.simps"], ["", "lemma list_member_conv_member [simp]: \n  \"equal_base.list_member (=) = List.member\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_base.list_member (=) = List.member", "proof(intro ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa. equal_base.list_member (=) x xa = List.member x xa", "fix xs and x :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa. equal_base.list_member (=) x xa = List.member x xa", "show \"equal_base.list_member (=) xs x = List.member xs x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_base.list_member (=) xs x = List.member xs x", "by(induct xs)(auto simp add: List.member_def)"], ["proof (state)\nthis:\n  equal_base.list_member (=) xs x = List.member xs x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_distinct_conv_distinct [simp]:\n  \"equal_base.list_distinct (=) = List.distinct\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_base.list_distinct (=) = distinct", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. equal_base.list_distinct (=) x = distinct x", "fix xs :: \"'a list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. equal_base.list_distinct (=) x = distinct x", "show \"equal_base.list_distinct (=) xs = distinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_base.list_distinct (=) xs = distinct xs", "by(induct xs)(auto simp add: List.member_def)"], ["proof (state)\nthis:\n  equal_base.list_distinct (=) xs = distinct xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_insert_conv_insert [simp]:\n  \"equal_base.list_insert (=) = List.insert\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_base.list_insert (=) = List.insert", "unfolding equal_base.list_insert_def[abs_def] List.insert_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x xs.\n        if equal_base.list_member (=) xs x then xs else x # xs) =\n    (\\<lambda>x xs. if x \\<in> set xs then xs else x # xs)", "by(simp add: List.member_def)"], ["", "lemma list_remove1_conv_remove1 [simp]:\n  \"equal_base.list_remove1 (=) = List.remove1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_base.list_remove1 (=) = remove1", "unfolding equal_base.list_remove1_def List.remove1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>uu uua.\n        rec_list (\\<lambda>x. [])\n         (\\<lambda>y xs xsa x. if x = y then xs else y # xsa x) uua uu) =\n    (\\<lambda>uu uua.\n        rec_list (\\<lambda>x. [])\n         (\\<lambda>y xs xsa x. if x = y then xs else y # xsa x) uua uu)", ".."], ["", "lemma list_remdups_conv_remdups [simp]:\n  \"equal_base.list_remdups (=) = List.remdups\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_base.list_remdups (=) = remdups", "unfolding equal_base.list_remdups_def List.remdups_def list_member_conv_member List.member_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_list []\n     (\\<lambda>x xs xsa. if x \\<in> set xs then xsa else x # xsa) =\n    rec_list [] (\\<lambda>x xs xsa. if x \\<in> set xs then xsa else x # xsa)", ".."], ["", "context equal begin"], ["", "lemma member_insert [simp]: \"list_member (list_insert x xs) y \\<longleftrightarrow> equal x y \\<or> list_member xs y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_member (list_insert x xs) y = (equal x y \\<or> list_member xs y)", "by(auto simp add: equal_eq List.member_def)"], ["", "lemma member_remove1 [simp]:\n  \"\\<not> equal x y \\<Longrightarrow> list_member (list_remove1 x xs) y = list_member xs y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> equal x y \\<Longrightarrow>\n    list_member (list_remove1 x xs) y = list_member xs y", "by(simp add: equal_eq List.member_def)"], ["", "lemma distinct_remove1:\n  \"list_distinct xs \\<Longrightarrow> list_distinct (list_remove1 x xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_distinct xs \\<Longrightarrow> list_distinct (list_remove1 x xs)", "by(simp add: equal_eq)"], ["", "lemma distinct_member_remove1 [simp]:\n  \"list_distinct xs \\<Longrightarrow> list_member (list_remove1 x xs) = (list_member xs)(x := False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_distinct xs \\<Longrightarrow>\n    list_member (list_remove1 x xs) = (list_member xs)(x := False)", "by(auto simp add: equal_eq List.member_def[abs_def] fun_eq_iff)"], ["", "end"], ["", "lemma ID_ceq: (* FIXME: Adapt Set_Impl to directly use above equal class! *)\n  \"ID CEQ('a :: ceq) = Some eq \\<Longrightarrow> equal eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ID CEQ('a) = Some eq \\<Longrightarrow> equal eq", "by(unfold_locales)(clarsimp simp add: ID_ceq)"], ["", "subsection \\<open>The type of distinct lists\\<close>"], ["", "typedef (overloaded) 'a :: ceq set_dlist =\n  \"{xs::'a list. equal_base.list_distinct ceq' xs \\<or> ID CEQ('a) = None}\"\n  morphisms list_of_dlist Abs_dlist'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> {xs.\n                equal_base.list_distinct ceq' xs \\<or> ID CEQ('a) = None}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. ?x \\<in> {xs. equal_base.list_distinct ceq' xs \\<or> ID CEQ('a) = None}", "show \"[] \\<in> ?set_dlist\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<in> {xs. equal_base.list_distinct ceq' xs \\<or> ID CEQ('a) = None}", "by(simp)"], ["proof (state)\nthis:\n  [] \\<in> {xs. equal_base.list_distinct ceq' xs \\<or> ID CEQ('a) = None}\n\ngoal:\nNo subgoals!", "qed"], ["", "definition Abs_dlist :: \"'a :: ceq list \\<Rightarrow> 'a set_dlist\" \nwhere \n  \"Abs_dlist xs = Abs_dlist' \n  (if equal_base.list_distinct ceq' xs \\<or> ID CEQ('a) = None then xs \n   else equal_base.list_remdups ceq' xs)\""], ["", "lemma Abs_dlist_inverse:\n  fixes y :: \"'a :: ceq list\"\n  assumes \"y \\<in> {xs. equal_base.list_distinct ceq' xs \\<or> ID CEQ('a) = None}\"\n  shows \"list_of_dlist (Abs_dlist y) = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_dlist (Abs_dlist y) = y", "using assms"], ["proof (prove)\nusing this:\n  y \\<in> {xs. equal_base.list_distinct ceq' xs \\<or> ID CEQ('a) = None}\n\ngoal (1 subgoal):\n 1. list_of_dlist (Abs_dlist y) = y", "by(auto simp add: Abs_dlist_def Abs_dlist'_inverse)"], ["", "lemma list_of_dlist_inverse: \"Abs_dlist (list_of_dlist dxs) = dxs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_dlist (list_of_dlist dxs) = dxs", "by(cases dxs)(simp add: Abs_dlist'_inverse Abs_dlist_def)"], ["", "lemma type_definition_set_dlist':\n  \"type_definition list_of_dlist Abs_dlist\n  {xs :: 'a :: ceq list. equal_base.list_distinct ceq' xs \\<or> ID CEQ('a) = None}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type_definition list_of_dlist Abs_dlist\n     {xs. equal_base.list_distinct ceq' xs \\<or> ID CEQ('a) = None}", "by(unfold_locales)(rule set_dlist.list_of_dlist Abs_dlist_inverse list_of_dlist_inverse)+"], ["", "lemmas Abs_dlist_cases[cases type: set_dlist] = \n  type_definition.Abs_cases[OF type_definition_set_dlist'] \n  and Abs_dlist_induct[induct type: set_dlist] =\n  type_definition.Abs_induct[OF type_definition_set_dlist'] and\n  Abs_dlist_inject = type_definition.Abs_inject[OF type_definition_set_dlist']"], ["", "setup_lifting type_definition_set_dlist'"], ["", "subsection \\<open>Operations\\<close>"], ["", "lift_definition empty :: \"'a :: ceq set_dlist\" is \"[]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_base.list_distinct ceq' [] \\<or> ID CEQ('a) = None", "by simp"], ["", "lift_definition insert :: \"'a :: ceq \\<Rightarrow> 'a set_dlist \\<Rightarrow> 'a set_dlist\" is \n  \"equal_base.list_insert ceq'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       equal_base.list_distinct ceq' list \\<or>\n       ID CEQ('a) = None \\<Longrightarrow>\n       equal_base.list_distinct ceq'\n        (equal_base.list_insert ceq' a list) \\<or>\n       ID CEQ('a) = None", "by(simp add: equal_base.list_insert_def)"], ["", "lift_definition remove :: \"'a :: ceq \\<Rightarrow> 'a set_dlist \\<Rightarrow> 'a set_dlist\" is \n  \"equal_base.list_remove1 ceq'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       equal_base.list_distinct ceq' list \\<or>\n       ID CEQ('a) = None \\<Longrightarrow>\n       equal_base.list_distinct ceq'\n        (equal_base.list_remove1 ceq' a list) \\<or>\n       ID CEQ('a) = None", "by(auto simp: equal.distinct_remove1 ID_ceq)"], ["", "lift_definition filter :: \"('a :: ceq \\<Rightarrow> bool) \\<Rightarrow> 'a set_dlist \\<Rightarrow> 'a set_dlist\" is List.filter"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun list.\n       equal_base.list_distinct ceq' list \\<or>\n       ID CEQ('a) = None \\<Longrightarrow>\n       equal_base.list_distinct ceq' (filter fun list) \\<or>\n       ID CEQ('a) = None", "by(auto simp add: equal_base.list_distinct_filter)"], ["", "text \\<open>Derived operations:\\<close>"], ["", "lift_definition null :: \"'a :: ceq set_dlist \\<Rightarrow> bool\" is List.null"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition member :: \"'a :: ceq set_dlist \\<Rightarrow> 'a \\<Rightarrow> bool\" is \"equal_base.list_member ceq'\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition length :: \"'a :: ceq set_dlist \\<Rightarrow> nat\" is List.length"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition fold :: \"('a :: ceq \\<Rightarrow> 'b \\<Rightarrow> 'b) \\<Rightarrow> 'a set_dlist \\<Rightarrow> 'b \\<Rightarrow> 'b\" is List.fold"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition foldr :: \"('a :: ceq \\<Rightarrow> 'b \\<Rightarrow> 'b) \\<Rightarrow> 'a set_dlist \\<Rightarrow> 'b \\<Rightarrow> 'b\" is List.foldr"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition hd :: \"'a :: ceq set_dlist \\<Rightarrow> 'a\" is \"List.hd\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition tl :: \"'a :: ceq set_dlist \\<Rightarrow> 'a set_dlist\" is \"List.tl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list.\n       equal_base.list_distinct ceq' list \\<or>\n       ID CEQ('a) = None \\<Longrightarrow>\n       equal_base.list_distinct ceq' (tl list) \\<or> ID CEQ('a) = None", "by(auto simp add: equal_base.list_distinct_tl)"], ["", "lift_definition dlist_all :: \"('a \\<Rightarrow> bool) \\<Rightarrow> 'a :: ceq set_dlist \\<Rightarrow> bool\" is \"list_all\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition dlist_ex :: \"('a \\<Rightarrow> bool) \\<Rightarrow> 'a :: ceq set_dlist \\<Rightarrow> bool\" is \"list_ex\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition union :: \"'a :: ceq set_dlist \\<Rightarrow> 'a set_dlist \\<Rightarrow> 'a set_dlist\" where\n  \"union = fold insert\""], ["", "lift_definition product :: \"'a :: ceq set_dlist \\<Rightarrow> 'b :: ceq set_dlist \\<Rightarrow> ('a \\<times> 'b) set_dlist\"\n  is \"\\<lambda>xs ys. rev (concat (map (\\<lambda>x. map (Pair x) ys) xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list1 list2.\n       \\<lbrakk>equal_base.list_distinct ceq' list1 \\<or> ID CEQ('a) = None;\n        equal_base.list_distinct ceq' list2 \\<or> ID CEQ('b) = None\\<rbrakk>\n       \\<Longrightarrow> equal_base.list_distinct ceq'\n                          (rev (concat\n                                 (map (\\<lambda>x. map (Pair x) list2)\n                                   list1))) \\<or>\n                         ID CEQ('a \\<times> 'b) = None", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>list1 list2.\n       \\<lbrakk>equal_base.list_distinct ceq' list1 \\<or> ID CEQ('a) = None;\n        equal_base.list_distinct ceq' list2 \\<or> ID CEQ('b) = None\\<rbrakk>\n       \\<Longrightarrow> equal_base.list_distinct ceq'\n                          (rev (concat\n                                 (map (\\<lambda>x. map (Pair x) list2)\n                                   list1))) \\<or>\n                         ID CEQ('a \\<times> 'b) = None", "fix xs :: \"'a list\" and ys :: \"'b list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>list1 list2.\n       \\<lbrakk>equal_base.list_distinct ceq' list1 \\<or> ID CEQ('a) = None;\n        equal_base.list_distinct ceq' list2 \\<or> ID CEQ('b) = None\\<rbrakk>\n       \\<Longrightarrow> equal_base.list_distinct ceq'\n                          (rev (concat\n                                 (map (\\<lambda>x. map (Pair x) list2)\n                                   list1))) \\<or>\n                         ID CEQ('a \\<times> 'b) = None", "assume *: \"equal_base.list_distinct ceq' xs \\<or> ID CEQ('a) = None\"\n    \"equal_base.list_distinct ceq' ys \\<or> ID CEQ('b) = None\""], ["proof (state)\nthis:\n  equal_base.list_distinct ceq' xs \\<or> ID CEQ('a) = None\n  equal_base.list_distinct ceq' ys \\<or> ID CEQ('b) = None\n\ngoal (1 subgoal):\n 1. \\<And>list1 list2.\n       \\<lbrakk>equal_base.list_distinct ceq' list1 \\<or> ID CEQ('a) = None;\n        equal_base.list_distinct ceq' list2 \\<or> ID CEQ('b) = None\\<rbrakk>\n       \\<Longrightarrow> equal_base.list_distinct ceq'\n                          (rev (concat\n                                 (map (\\<lambda>x. map (Pair x) list2)\n                                   list1))) \\<or>\n                         ID CEQ('a \\<times> 'b) = None", "let ?product = \"concat (map (\\<lambda>x. map (Pair x) ys) xs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>list1 list2.\n       \\<lbrakk>equal_base.list_distinct ceq' list1 \\<or> ID CEQ('a) = None;\n        equal_base.list_distinct ceq' list2 \\<or> ID CEQ('b) = None\\<rbrakk>\n       \\<Longrightarrow> equal_base.list_distinct ceq'\n                          (rev (concat\n                                 (map (\\<lambda>x. map (Pair x) list2)\n                                   list1))) \\<or>\n                         ID CEQ('a \\<times> 'b) = None", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>list1 list2.\n       \\<lbrakk>equal_base.list_distinct ceq' list1 \\<or> ID CEQ('a) = None;\n        equal_base.list_distinct ceq' list2 \\<or> ID CEQ('b) = None\\<rbrakk>\n       \\<Longrightarrow> equal_base.list_distinct ceq'\n                          (rev (concat\n                                 (map (\\<lambda>x. map (Pair x) list2)\n                                   list1))) \\<or>\n                         ID CEQ('a \\<times> 'b) = None", "assume neq: \"ID CEQ('a) \\<noteq> None\" \"ID CEQ('b) \\<noteq> None\""], ["proof (state)\nthis:\n  ID CEQ('a) \\<noteq> None\n  ID CEQ('b) \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<And>list1 list2.\n       \\<lbrakk>equal_base.list_distinct ceq' list1 \\<or> ID CEQ('a) = None;\n        equal_base.list_distinct ceq' list2 \\<or> ID CEQ('b) = None\\<rbrakk>\n       \\<Longrightarrow> equal_base.list_distinct ceq'\n                          (rev (concat\n                                 (map (\\<lambda>x. map (Pair x) list2)\n                                   list1))) \\<or>\n                         ID CEQ('a \\<times> 'b) = None", "hence ceq': \"ceq' = ((=) :: 'a \\<Rightarrow> 'a \\<Rightarrow> bool)\" \"ceq' = ((=) :: 'b \\<Rightarrow> 'b \\<Rightarrow> bool)\""], ["proof (prove)\nusing this:\n  ID CEQ('a) \\<noteq> None\n  ID CEQ('b) \\<noteq> None\n\ngoal (1 subgoal):\n 1. ceq' = (=) &&& ceq' = (=)", "by(auto intro: equal.equal_eq[OF ID_ceq])"], ["proof (state)\nthis:\n  ceq' = (=)\n  ceq' = (=)\n\ngoal (1 subgoal):\n 1. \\<And>list1 list2.\n       \\<lbrakk>equal_base.list_distinct ceq' list1 \\<or> ID CEQ('a) = None;\n        equal_base.list_distinct ceq' list2 \\<or> ID CEQ('b) = None\\<rbrakk>\n       \\<Longrightarrow> equal_base.list_distinct ceq'\n                          (rev (concat\n                                 (map (\\<lambda>x. map (Pair x) list2)\n                                   list1))) \\<or>\n                         ID CEQ('a \\<times> 'b) = None", "with * neq"], ["proof (chain)\npicking this:\n  equal_base.list_distinct ceq' xs \\<or> ID CEQ('a) = None\n  equal_base.list_distinct ceq' ys \\<or> ID CEQ('b) = None\n  ID CEQ('a) \\<noteq> None\n  ID CEQ('b) \\<noteq> None\n  ceq' = (=)\n  ceq' = (=)", "have dist: \"distinct xs\" \"distinct ys\""], ["proof (prove)\nusing this:\n  equal_base.list_distinct ceq' xs \\<or> ID CEQ('a) = None\n  equal_base.list_distinct ceq' ys \\<or> ID CEQ('b) = None\n  ID CEQ('a) \\<noteq> None\n  ID CEQ('b) \\<noteq> None\n  ceq' = (=)\n  ceq' = (=)\n\ngoal (1 subgoal):\n 1. distinct xs &&& distinct ys", "by simp_all"], ["proof (state)\nthis:\n  distinct xs\n  distinct ys\n\ngoal (1 subgoal):\n 1. \\<And>list1 list2.\n       \\<lbrakk>equal_base.list_distinct ceq' list1 \\<or> ID CEQ('a) = None;\n        equal_base.list_distinct ceq' list2 \\<or> ID CEQ('b) = None\\<rbrakk>\n       \\<Longrightarrow> equal_base.list_distinct ceq'\n                          (rev (concat\n                                 (map (\\<lambda>x. map (Pair x) list2)\n                                   list1))) \\<or>\n                         ID CEQ('a \\<times> 'b) = None", "hence \"distinct ?product\""], ["proof (prove)\nusing this:\n  distinct xs\n  distinct ys\n\ngoal (1 subgoal):\n 1. distinct (concat (map (\\<lambda>x. map (Pair x) ys) xs))", "by(cases \"ys = []\")(auto simp add: distinct_map map_replicate_const intro!: inj_onI distinct_concat)"], ["proof (state)\nthis:\n  distinct (concat (map (\\<lambda>x. map (Pair x) ys) xs))\n\ngoal (1 subgoal):\n 1. \\<And>list1 list2.\n       \\<lbrakk>equal_base.list_distinct ceq' list1 \\<or> ID CEQ('a) = None;\n        equal_base.list_distinct ceq' list2 \\<or> ID CEQ('b) = None\\<rbrakk>\n       \\<Longrightarrow> equal_base.list_distinct ceq'\n                          (rev (concat\n                                 (map (\\<lambda>x. map (Pair x) list2)\n                                   list1))) \\<or>\n                         ID CEQ('a \\<times> 'b) = None", "hence \"distinct (rev ?product)\""], ["proof (prove)\nusing this:\n  distinct (concat (map (\\<lambda>x. map (Pair x) ys) xs))\n\ngoal (1 subgoal):\n 1. distinct (rev (concat (map (\\<lambda>x. map (Pair x) ys) xs)))", "by simp"], ["proof (state)\nthis:\n  distinct (rev (concat (map (\\<lambda>x. map (Pair x) ys) xs)))\n\ngoal (1 subgoal):\n 1. \\<And>list1 list2.\n       \\<lbrakk>equal_base.list_distinct ceq' list1 \\<or> ID CEQ('a) = None;\n        equal_base.list_distinct ceq' list2 \\<or> ID CEQ('b) = None\\<rbrakk>\n       \\<Longrightarrow> equal_base.list_distinct ceq'\n                          (rev (concat\n                                 (map (\\<lambda>x. map (Pair x) list2)\n                                   list1))) \\<or>\n                         ID CEQ('a \\<times> 'b) = None", "moreover"], ["proof (state)\nthis:\n  distinct (rev (concat (map (\\<lambda>x. map (Pair x) ys) xs)))\n\ngoal (1 subgoal):\n 1. \\<And>list1 list2.\n       \\<lbrakk>equal_base.list_distinct ceq' list1 \\<or> ID CEQ('a) = None;\n        equal_base.list_distinct ceq' list2 \\<or> ID CEQ('b) = None\\<rbrakk>\n       \\<Longrightarrow> equal_base.list_distinct ceq'\n                          (rev (concat\n                                 (map (\\<lambda>x. map (Pair x) list2)\n                                   list1))) \\<or>\n                         ID CEQ('a \\<times> 'b) = None", "have \"ceq' = ((=) :: ('a \\<times> 'b) \\<Rightarrow> ('a \\<times> 'b) \\<Rightarrow> bool)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ceq' = (=)", "using neq ceq'"], ["proof (prove)\nusing this:\n  ID CEQ('a) \\<noteq> None\n  ID CEQ('b) \\<noteq> None\n  ceq' = (=)\n  ceq' = (=)\n\ngoal (1 subgoal):\n 1. ceq' = (=)", "by (auto simp add: ceq_prod_def ID_Some fun_eq_iff list_all_eq_def)"], ["proof (state)\nthis:\n  ceq' = (=)\n\ngoal (1 subgoal):\n 1. \\<And>list1 list2.\n       \\<lbrakk>equal_base.list_distinct ceq' list1 \\<or> ID CEQ('a) = None;\n        equal_base.list_distinct ceq' list2 \\<or> ID CEQ('b) = None\\<rbrakk>\n       \\<Longrightarrow> equal_base.list_distinct ceq'\n                          (rev (concat\n                                 (map (\\<lambda>x. map (Pair x) list2)\n                                   list1))) \\<or>\n                         ID CEQ('a \\<times> 'b) = None", "ultimately"], ["proof (chain)\npicking this:\n  distinct (rev (concat (map (\\<lambda>x. map (Pair x) ys) xs)))\n  ceq' = (=)", "have \"equal_base.list_distinct ceq' (rev ?product)\""], ["proof (prove)\nusing this:\n  distinct (rev (concat (map (\\<lambda>x. map (Pair x) ys) xs)))\n  ceq' = (=)\n\ngoal (1 subgoal):\n 1. equal_base.list_distinct ceq'\n     (rev (concat (map (\\<lambda>x. map (Pair x) ys) xs)))", "by simp"], ["proof (state)\nthis:\n  equal_base.list_distinct ceq'\n   (rev (concat (map (\\<lambda>x. map (Pair x) ys) xs)))\n\ngoal (1 subgoal):\n 1. \\<And>list1 list2.\n       \\<lbrakk>equal_base.list_distinct ceq' list1 \\<or> ID CEQ('a) = None;\n        equal_base.list_distinct ceq' list2 \\<or> ID CEQ('b) = None\\<rbrakk>\n       \\<Longrightarrow> equal_base.list_distinct ceq'\n                          (rev (concat\n                                 (map (\\<lambda>x. map (Pair x) list2)\n                                   list1))) \\<or>\n                         ID CEQ('a \\<times> 'b) = None", "}"], ["proof (state)\nthis:\n  \\<lbrakk>ID CEQ('a) \\<noteq> None; ID CEQ('b) \\<noteq> None\\<rbrakk>\n  \\<Longrightarrow> equal_base.list_distinct ceq'\n                     (rev (concat (map (\\<lambda>x. map (Pair x) ys) xs)))\n\ngoal (1 subgoal):\n 1. \\<And>list1 list2.\n       \\<lbrakk>equal_base.list_distinct ceq' list1 \\<or> ID CEQ('a) = None;\n        equal_base.list_distinct ceq' list2 \\<or> ID CEQ('b) = None\\<rbrakk>\n       \\<Longrightarrow> equal_base.list_distinct ceq'\n                          (rev (concat\n                                 (map (\\<lambda>x. map (Pair x) list2)\n                                   list1))) \\<or>\n                         ID CEQ('a \\<times> 'b) = None", "with *"], ["proof (chain)\npicking this:\n  equal_base.list_distinct ceq' xs \\<or> ID CEQ('a) = None\n  equal_base.list_distinct ceq' ys \\<or> ID CEQ('b) = None\n  \\<lbrakk>ID CEQ('a) \\<noteq> None; ID CEQ('b) \\<noteq> None\\<rbrakk>\n  \\<Longrightarrow> equal_base.list_distinct ceq'\n                     (rev (concat (map (\\<lambda>x. map (Pair x) ys) xs)))", "show \"equal_base.list_distinct ceq' (rev ?product) \\<or> ID CEQ('a \\<times> 'b) = None\""], ["proof (prove)\nusing this:\n  equal_base.list_distinct ceq' xs \\<or> ID CEQ('a) = None\n  equal_base.list_distinct ceq' ys \\<or> ID CEQ('b) = None\n  \\<lbrakk>ID CEQ('a) \\<noteq> None; ID CEQ('b) \\<noteq> None\\<rbrakk>\n  \\<Longrightarrow> equal_base.list_distinct ceq'\n                     (rev (concat (map (\\<lambda>x. map (Pair x) ys) xs)))\n\ngoal (1 subgoal):\n 1. equal_base.list_distinct ceq'\n     (rev (concat (map (\\<lambda>x. map (Pair x) ys) xs))) \\<or>\n    ID CEQ('a \\<times> 'b) = None", "by(fastforce simp add: ceq_prod_def ID_def split: option.split_asm)"], ["proof (state)\nthis:\n  equal_base.list_distinct ceq'\n   (rev (concat (map (\\<lambda>x. map (Pair x) ys) xs))) \\<or>\n  ID CEQ('a \\<times> 'b) = None\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition Id_on :: \"'a :: ceq set_dlist \\<Rightarrow> ('a \\<times> 'a) set_dlist\"\n is \"map (\\<lambda>x. (x, x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list.\n       equal_base.list_distinct ceq' list \\<or>\n       ID CEQ('a) = None \\<Longrightarrow>\n       equal_base.list_distinct ceq' (map (\\<lambda>x. (x, x)) list) \\<or>\n       ID CEQ('a \\<times> 'a) = None", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>list.\n       equal_base.list_distinct ceq' list \\<or>\n       ID CEQ('a) = None \\<Longrightarrow>\n       equal_base.list_distinct ceq' (map (\\<lambda>x. (x, x)) list) \\<or>\n       ID CEQ('a \\<times> 'a) = None", "fix xs :: \"'a list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>list.\n       equal_base.list_distinct ceq' list \\<or>\n       ID CEQ('a) = None \\<Longrightarrow>\n       equal_base.list_distinct ceq' (map (\\<lambda>x. (x, x)) list) \\<or>\n       ID CEQ('a \\<times> 'a) = None", "assume ceq: \"equal_base.list_distinct ceq' xs \\<or> ID CEQ('a) = None\""], ["proof (state)\nthis:\n  equal_base.list_distinct ceq' xs \\<or> ID CEQ('a) = None\n\ngoal (1 subgoal):\n 1. \\<And>list.\n       equal_base.list_distinct ceq' list \\<or>\n       ID CEQ('a) = None \\<Longrightarrow>\n       equal_base.list_distinct ceq' (map (\\<lambda>x. (x, x)) list) \\<or>\n       ID CEQ('a \\<times> 'a) = None", "{"], ["proof (state)\nthis:\n  equal_base.list_distinct ceq' xs \\<or> ID CEQ('a) = None\n\ngoal (1 subgoal):\n 1. \\<And>list.\n       equal_base.list_distinct ceq' list \\<or>\n       ID CEQ('a) = None \\<Longrightarrow>\n       equal_base.list_distinct ceq' (map (\\<lambda>x. (x, x)) list) \\<or>\n       ID CEQ('a \\<times> 'a) = None", "assume ceq: \"ID CEQ('a \\<times> 'a) \\<noteq> None\"\n      and xs: \"equal_base.list_distinct ceq' xs\""], ["proof (state)\nthis:\n  ID CEQ('a \\<times> 'a) \\<noteq> None\n  equal_base.list_distinct ceq' xs\n\ngoal (1 subgoal):\n 1. \\<And>list.\n       equal_base.list_distinct ceq' list \\<or>\n       ID CEQ('a) = None \\<Longrightarrow>\n       equal_base.list_distinct ceq' (map (\\<lambda>x. (x, x)) list) \\<or>\n       ID CEQ('a \\<times> 'a) = None", "from ceq"], ["proof (chain)\npicking this:\n  ID CEQ('a \\<times> 'a) \\<noteq> None", "have \"ID CEQ('a) \\<noteq> None\"\n      and \"ceq' = ((=) :: 'a \\<Rightarrow> 'a \\<Rightarrow> bool)\" \n      and \"ceq' = ((=) :: ('a \\<times> 'a) \\<Rightarrow> ('a \\<times> 'a) \\<Rightarrow> bool)\""], ["proof (prove)\nusing this:\n  ID CEQ('a \\<times> 'a) \\<noteq> None\n\ngoal (1 subgoal):\n 1. ID CEQ('a) \\<noteq> None &&& ceq' = (=) &&& ceq' = (=)", "by(auto simp add: equal.equal_eq[OF ID_ceq] ceq_prod_def ID_None ID_Some split: option.split_asm)"], ["proof (state)\nthis:\n  ID CEQ('a) \\<noteq> None\n  ceq' = (=)\n  ceq' = (=)\n\ngoal (1 subgoal):\n 1. \\<And>list.\n       equal_base.list_distinct ceq' list \\<or>\n       ID CEQ('a) = None \\<Longrightarrow>\n       equal_base.list_distinct ceq' (map (\\<lambda>x. (x, x)) list) \\<or>\n       ID CEQ('a \\<times> 'a) = None", "hence \"?thesis xs\""], ["proof (prove)\nusing this:\n  ID CEQ('a) \\<noteq> None\n  ceq' = (=)\n  ceq' = (=)\n\ngoal (1 subgoal):\n 1. equal_base.list_distinct ceq' (map (\\<lambda>x. (x, x)) xs) \\<or>\n    ID CEQ('a \\<times> 'a) = None", "using xs"], ["proof (prove)\nusing this:\n  ID CEQ('a) \\<noteq> None\n  ceq' = (=)\n  ceq' = (=)\n  equal_base.list_distinct ceq' xs\n\ngoal (1 subgoal):\n 1. equal_base.list_distinct ceq' (map (\\<lambda>x. (x, x)) xs) \\<or>\n    ID CEQ('a \\<times> 'a) = None", "by(auto simp add: distinct_map intro: inj_onI)"], ["proof (state)\nthis:\n  equal_base.list_distinct ceq' (map (\\<lambda>x. (x, x)) xs) \\<or>\n  ID CEQ('a \\<times> 'a) = None\n\ngoal (1 subgoal):\n 1. \\<And>list.\n       equal_base.list_distinct ceq' list \\<or>\n       ID CEQ('a) = None \\<Longrightarrow>\n       equal_base.list_distinct ceq' (map (\\<lambda>x. (x, x)) list) \\<or>\n       ID CEQ('a \\<times> 'a) = None", "}"], ["proof (state)\nthis:\n  \\<lbrakk>ID CEQ('a \\<times> 'a) \\<noteq> None;\n   equal_base.list_distinct ceq' xs\\<rbrakk>\n  \\<Longrightarrow> equal_base.list_distinct ceq'\n                     (map (\\<lambda>x. (x, x)) xs) \\<or>\n                    ID CEQ('a \\<times> 'a) = None\n\ngoal (1 subgoal):\n 1. \\<And>list.\n       equal_base.list_distinct ceq' list \\<or>\n       ID CEQ('a) = None \\<Longrightarrow>\n       equal_base.list_distinct ceq' (map (\\<lambda>x. (x, x)) list) \\<or>\n       ID CEQ('a \\<times> 'a) = None", "thus \"?thesis xs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>ID CEQ('a \\<times> 'a) \\<noteq> None;\n   equal_base.list_distinct ceq' xs\\<rbrakk>\n  \\<Longrightarrow> equal_base.list_distinct ceq'\n                     (map (\\<lambda>x. (x, x)) xs) \\<or>\n                    ID CEQ('a \\<times> 'a) = None\n\ngoal (1 subgoal):\n 1. equal_base.list_distinct ceq' (map (\\<lambda>x. (x, x)) xs) \\<or>\n    ID CEQ('a \\<times> 'a) = None", "using ceq"], ["proof (prove)\nusing this:\n  \\<lbrakk>ID CEQ('a \\<times> 'a) \\<noteq> None;\n   equal_base.list_distinct ceq' xs\\<rbrakk>\n  \\<Longrightarrow> equal_base.list_distinct ceq'\n                     (map (\\<lambda>x. (x, x)) xs) \\<or>\n                    ID CEQ('a \\<times> 'a) = None\n  equal_base.list_distinct ceq' xs \\<or> ID CEQ('a) = None\n\ngoal (1 subgoal):\n 1. equal_base.list_distinct ceq' (map (\\<lambda>x. (x, x)) xs) \\<or>\n    ID CEQ('a \\<times> 'a) = None", "by(auto dest: equal.equal_eq[OF ID_ceq] simp add: ceq_prod_def ID_None)"], ["proof (state)\nthis:\n  equal_base.list_distinct ceq' (map (\\<lambda>x. (x, x)) xs) \\<or>\n  ID CEQ('a \\<times> 'a) = None\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Properties\\<close>"], ["", "lemma member_empty [simp]: \"member empty = (\\<lambda>_. False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. member DList_Set.empty = (\\<lambda>_. False)", "by transfer (simp add: fun_eq_iff)"], ["", "lemma null_iff [simp]: \"null xs \\<longleftrightarrow> xs = empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. null xs = (xs = DList_Set.empty)", "by transfer(simp add: List.null_def)"], ["", "lemma list_of_dlist_empty [simp]: \"list_of_dlist DList_Set.empty = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_dlist DList_Set.empty = []", "by(rule empty.rep_eq)"], ["", "lemma list_of_dlist_insert [simp]: \"\\<not> member dxs x \\<Longrightarrow> list_of_dlist (insert x dxs) = x # list_of_dlist dxs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> member dxs x \\<Longrightarrow>\n    list_of_dlist (DList_Set.insert x dxs) = x # list_of_dlist dxs", "by(cases dxs)(auto simp add: DList_Set.insert_def DList_Set.member_def Abs_dlist_inverse Abs_dlist_inject equal_base.list_insert_def List.member_def intro: Abs_dlist_inverse)"], ["", "lemma list_of_dlist_eq_Nil_iff [simp]: \"list_of_dlist dxs = [] \\<longleftrightarrow> dxs = empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_of_dlist dxs = []) = (dxs = DList_Set.empty)", "by(cases dxs)(auto simp add: Abs_dlist_inverse Abs_dlist_inject DList_Set.empty_def)"], ["", "lemma fold_empty [simp]: \"DList_Set.fold f empty b = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DList_Set.fold f DList_Set.empty b = b", "by(transfer) simp"], ["", "lemma fold_insert [simp]: \"\\<not> member dxs x \\<Longrightarrow> DList_Set.fold f (insert x dxs) b = DList_Set.fold f dxs (f x b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> member dxs x \\<Longrightarrow>\n    DList_Set.fold f (DList_Set.insert x dxs) b =\n    DList_Set.fold f dxs (f x b)", "by(transfer)(simp add: equal_base.list_insert_def)"], ["", "lemma no_memb_fold_insert:\n  \"\\<not> member dxs x \\<Longrightarrow> fold f (insert x dxs) b = fold f dxs (f x b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> member dxs x \\<Longrightarrow>\n    DList_Set.fold f (DList_Set.insert x dxs) b =\n    DList_Set.fold f dxs (f x b)", "by(transfer)(simp add: equal_base.list_insert_def)"], ["", "lemma set_fold_insert: \"set (List.fold List.insert xs1 xs2) = set xs1 \\<union> set xs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (List.fold List.insert xs1 xs2) = set xs1 \\<union> set xs2", "by(induct xs1 arbitrary: xs2) simp_all"], ["", "lemma list_of_dlist_eq_singleton_conv:\n  \"list_of_dlist dxs = [x] \\<longleftrightarrow> dxs = DList_Set.insert x DList_Set.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_of_dlist dxs = [x]) = (dxs = DList_Set.insert x DList_Set.empty)", "by transfer(case_tac dxs, auto simp add: equal_base.list_insert_def)"], ["", "lemma product_code [code abstract]:\n  \"list_of_dlist (product dxs1 dxs2) = fold (\\<lambda>a. fold (\\<lambda>c rest. (a, c) # rest) dxs2) dxs1 []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_dlist (product dxs1 dxs2) =\n    DList_Set.fold\n     (\\<lambda>a. DList_Set.fold (\\<lambda>c. (#) (a, c)) dxs2) dxs1 []", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_of_dlist (product dxs1 dxs2) =\n    DList_Set.fold\n     (\\<lambda>a. DList_Set.fold (\\<lambda>c. (#) (a, c)) dxs2) dxs1 []", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. list_of_dlist (product dxs1 dxs2) =\n    DList_Set.fold\n     (\\<lambda>a. DList_Set.fold (\\<lambda>c. (#) (a, c)) dxs2) dxs1 []", "fix xs ys and zs :: \"('a \\<times> 'b) list\""], ["proof (state)\ngoal (1 subgoal):\n 1. list_of_dlist (product dxs1 dxs2) =\n    DList_Set.fold\n     (\\<lambda>a. DList_Set.fold (\\<lambda>c. (#) (a, c)) dxs2) dxs1 []", "have \"rev (concat (map (\\<lambda>x. map (Pair x) ys) xs)) @ zs = \n          List.fold (\\<lambda>a. List.fold (\\<lambda>c rest. (a, c) # rest) ys) xs zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (concat (map (\\<lambda>x. map (Pair x) ys) xs)) @ zs =\n    List.fold (\\<lambda>a. List.fold (\\<lambda>c. (#) (a, c)) ys) xs zs", "proof(induction xs arbitrary: zs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>zs.\n       rev (concat (map (\\<lambda>x. map (Pair x) ys) [])) @ zs =\n       List.fold (\\<lambda>a. List.fold (\\<lambda>c. (#) (a, c)) ys) [] zs\n 2. \\<And>a xs zs.\n       (\\<And>zs.\n           rev (concat (map (\\<lambda>x. map (Pair x) ys) xs)) @ zs =\n           List.fold (\\<lambda>a. List.fold (\\<lambda>c. (#) (a, c)) ys) xs\n            zs) \\<Longrightarrow>\n       rev (concat (map (\\<lambda>x. map (Pair x) ys) (a # xs))) @ zs =\n       List.fold (\\<lambda>a. List.fold (\\<lambda>c. (#) (a, c)) ys)\n        (a # xs) zs", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>zs.\n       rev (concat (map (\\<lambda>x. map (Pair x) ys) [])) @ zs =\n       List.fold (\\<lambda>a. List.fold (\\<lambda>c. (#) (a, c)) ys) [] zs\n 2. \\<And>a xs zs.\n       (\\<And>zs.\n           rev (concat (map (\\<lambda>x. map (Pair x) ys) xs)) @ zs =\n           List.fold (\\<lambda>a. List.fold (\\<lambda>c. (#) (a, c)) ys) xs\n            zs) \\<Longrightarrow>\n       rev (concat (map (\\<lambda>x. map (Pair x) ys) (a # xs))) @ zs =\n       List.fold (\\<lambda>a. List.fold (\\<lambda>c. (#) (a, c)) ys)\n        (a # xs) zs", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (concat (map (\\<lambda>x. map (Pair x) ys) [])) @ zs =\n    List.fold (\\<lambda>a. List.fold (\\<lambda>c. (#) (a, c)) ys) [] zs", "by simp"], ["proof (state)\nthis:\n  rev (concat (map (\\<lambda>x. map (Pair x) ys) [])) @ zs =\n  List.fold (\\<lambda>a. List.fold (\\<lambda>c. (#) (a, c)) ys) [] zs\n\ngoal (1 subgoal):\n 1. \\<And>a xs zs.\n       (\\<And>zs.\n           rev (concat (map (\\<lambda>x. map (Pair x) ys) xs)) @ zs =\n           List.fold (\\<lambda>a. List.fold (\\<lambda>c. (#) (a, c)) ys) xs\n            zs) \\<Longrightarrow>\n       rev (concat (map (\\<lambda>x. map (Pair x) ys) (a # xs))) @ zs =\n       List.fold (\\<lambda>a. List.fold (\\<lambda>c. (#) (a, c)) ys)\n        (a # xs) zs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs zs.\n       (\\<And>zs.\n           rev (concat (map (\\<lambda>x. map (Pair x) ys) xs)) @ zs =\n           List.fold (\\<lambda>a. List.fold (\\<lambda>c. (#) (a, c)) ys) xs\n            zs) \\<Longrightarrow>\n       rev (concat (map (\\<lambda>x. map (Pair x) ys) (a # xs))) @ zs =\n       List.fold (\\<lambda>a. List.fold (\\<lambda>c. (#) (a, c)) ys)\n        (a # xs) zs", "case (Cons x xs)"], ["proof (state)\nthis:\n  rev (concat (map (\\<lambda>x. map (Pair x) ys) xs)) @ ?zs =\n  List.fold (\\<lambda>a. List.fold (\\<lambda>c. (#) (a, c)) ys) xs ?zs\n\ngoal (1 subgoal):\n 1. \\<And>a xs zs.\n       (\\<And>zs.\n           rev (concat (map (\\<lambda>x. map (Pair x) ys) xs)) @ zs =\n           List.fold (\\<lambda>a. List.fold (\\<lambda>c. (#) (a, c)) ys) xs\n            zs) \\<Longrightarrow>\n       rev (concat (map (\\<lambda>x. map (Pair x) ys) (a # xs))) @ zs =\n       List.fold (\\<lambda>a. List.fold (\\<lambda>c. (#) (a, c)) ys)\n        (a # xs) zs", "have \"List.fold (\\<lambda>c rest. (x, c) # rest) ys zs = rev (map (Pair x) ys) @ zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.fold (\\<lambda>c. (#) (x, c)) ys zs = rev (map (Pair x) ys) @ zs", "by(induct ys arbitrary: zs) simp_all"], ["proof (state)\nthis:\n  List.fold (\\<lambda>c. (#) (x, c)) ys zs = rev (map (Pair x) ys) @ zs\n\ngoal (1 subgoal):\n 1. \\<And>a xs zs.\n       (\\<And>zs.\n           rev (concat (map (\\<lambda>x. map (Pair x) ys) xs)) @ zs =\n           List.fold (\\<lambda>a. List.fold (\\<lambda>c. (#) (a, c)) ys) xs\n            zs) \\<Longrightarrow>\n       rev (concat (map (\\<lambda>x. map (Pair x) ys) (a # xs))) @ zs =\n       List.fold (\\<lambda>a. List.fold (\\<lambda>c. (#) (a, c)) ys)\n        (a # xs) zs", "with Cons.IH[of \"rev (map (Pair x) ys) @ zs\"]"], ["proof (chain)\npicking this:\n  rev (concat (map (\\<lambda>x. map (Pair x) ys) xs)) @\n  rev (map (Pair x) ys) @ zs =\n  List.fold (\\<lambda>a. List.fold (\\<lambda>c. (#) (a, c)) ys) xs\n   (rev (map (Pair x) ys) @ zs)\n  List.fold (\\<lambda>c. (#) (x, c)) ys zs = rev (map (Pair x) ys) @ zs", "show ?case"], ["proof (prove)\nusing this:\n  rev (concat (map (\\<lambda>x. map (Pair x) ys) xs)) @\n  rev (map (Pair x) ys) @ zs =\n  List.fold (\\<lambda>a. List.fold (\\<lambda>c. (#) (a, c)) ys) xs\n   (rev (map (Pair x) ys) @ zs)\n  List.fold (\\<lambda>c. (#) (x, c)) ys zs = rev (map (Pair x) ys) @ zs\n\ngoal (1 subgoal):\n 1. rev (concat (map (\\<lambda>x. map (Pair x) ys) (x # xs))) @ zs =\n    List.fold (\\<lambda>a. List.fold (\\<lambda>c. (#) (a, c)) ys) (x # xs)\n     zs", "by simp"], ["proof (state)\nthis:\n  rev (concat (map (\\<lambda>x. map (Pair x) ys) (x # xs))) @ zs =\n  List.fold (\\<lambda>a. List.fold (\\<lambda>c. (#) (a, c)) ys) (x # xs) zs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rev (concat (map (\\<lambda>x. map (Pair x) ys) xs)) @ zs =\n  List.fold (\\<lambda>a. List.fold (\\<lambda>c. (#) (a, c)) ys) xs zs\n\ngoal (1 subgoal):\n 1. list_of_dlist (product dxs1 dxs2) =\n    DList_Set.fold\n     (\\<lambda>a. DList_Set.fold (\\<lambda>c. (#) (a, c)) dxs2) dxs1 []", "}"], ["proof (state)\nthis:\n  rev (concat (map (\\<lambda>x. map (Pair x) ?ys2) ?xs2)) @ ?zs2 =\n  List.fold (\\<lambda>a. List.fold (\\<lambda>c. (#) (a, c)) ?ys2) ?xs2 ?zs2\n\ngoal (1 subgoal):\n 1. list_of_dlist (product dxs1 dxs2) =\n    DList_Set.fold\n     (\\<lambda>a. DList_Set.fold (\\<lambda>c. (#) (a, c)) dxs2) dxs1 []", "from this[of \"list_of_dlist dxs2\" \"list_of_dlist dxs1\" \"[]\"]"], ["proof (chain)\npicking this:\n  rev (concat\n        (map (\\<lambda>x. map (Pair x) (list_of_dlist dxs2))\n          (list_of_dlist dxs1))) @\n  [] =\n  List.fold\n   (\\<lambda>a. List.fold (\\<lambda>c. (#) (a, c)) (list_of_dlist dxs2))\n   (list_of_dlist dxs1) []", "show ?thesis"], ["proof (prove)\nusing this:\n  rev (concat\n        (map (\\<lambda>x. map (Pair x) (list_of_dlist dxs2))\n          (list_of_dlist dxs1))) @\n  [] =\n  List.fold\n   (\\<lambda>a. List.fold (\\<lambda>c. (#) (a, c)) (list_of_dlist dxs2))\n   (list_of_dlist dxs1) []\n\ngoal (1 subgoal):\n 1. list_of_dlist (product dxs1 dxs2) =\n    DList_Set.fold\n     (\\<lambda>a. DList_Set.fold (\\<lambda>c. (#) (a, c)) dxs2) dxs1 []", "by(simp add: product.rep_eq fold.rep_eq)"], ["proof (state)\nthis:\n  list_of_dlist (product dxs1 dxs2) =\n  DList_Set.fold (\\<lambda>a. DList_Set.fold (\\<lambda>c. (#) (a, c)) dxs2)\n   dxs1 []\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_list_of_dlist_Abs_dlist:\n  \"set (list_of_dlist (Abs_dlist xs)) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (list_of_dlist (Abs_dlist xs)) = set xs", "by(clarsimp simp add: Abs_dlist_def Abs_dlist'_inverse)(subst Abs_dlist'_inverse, auto dest: equal.equal_eq[OF ID_ceq])"], ["", "context assumes ID_ceq_neq_None: \"ID CEQ('a :: ceq) \\<noteq> None\"\nbegin"], ["", "lemma equal_ceq: \"equal (ceq' :: 'a \\<Rightarrow> 'a \\<Rightarrow> bool)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal ceq'", "using ID_ceq_neq_None"], ["proof (prove)\nusing this:\n  ID CEQ('a) \\<noteq> None\n\ngoal (1 subgoal):\n 1. equal ceq'", "by(clarsimp)(rule ID_ceq)"], ["", "(* workaround for the next theorem *)"], ["", "declare Domainp_forall_transfer[where A = \"pcr_set_dlist (=)\", simplified set_dlist.domain_eq, transfer_rule]"], ["", "lemma set_dlist_induct [case_names Nil insert, induct type: set_dlist]:\n  fixes dxs :: \"'a :: ceq set_dlist\"\n  assumes Nil: \"P empty\" and Cons: \"\\<And>a dxs. \\<lbrakk> \\<not> member dxs a; P dxs \\<rbrakk> \\<Longrightarrow> P (insert a dxs)\"\n  shows \"P dxs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P dxs", "using assms"], ["proof (prove)\nusing this:\n  P DList_Set.empty\n  \\<lbrakk>\\<not> member ?dxs ?a; P ?dxs\\<rbrakk>\n  \\<Longrightarrow> P (DList_Set.insert ?a ?dxs)\n\ngoal (1 subgoal):\n 1. P dxs", "proof transfer"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P x.\n       \\<lbrakk>P [];\n        \\<And>dxs a.\n           \\<lbrakk>equal_base.list_distinct ceq' dxs \\<or>\n                    ID CEQ('a) = None;\n            \\<not> equal_base.list_member ceq' dxs a; P dxs\\<rbrakk>\n           \\<Longrightarrow> P (equal_base.list_insert ceq' a dxs);\n        equal_base.list_distinct ceq' x \\<or> ID CEQ('a) = None\\<rbrakk>\n       \\<Longrightarrow> P x", "fix P :: \"'a list \\<Rightarrow> bool\" and xs :: \"'a list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P x.\n       \\<lbrakk>P [];\n        \\<And>dxs a.\n           \\<lbrakk>equal_base.list_distinct ceq' dxs \\<or>\n                    ID CEQ('a) = None;\n            \\<not> equal_base.list_member ceq' dxs a; P dxs\\<rbrakk>\n           \\<Longrightarrow> P (equal_base.list_insert ceq' a dxs);\n        equal_base.list_distinct ceq' x \\<or> ID CEQ('a) = None\\<rbrakk>\n       \\<Longrightarrow> P x", "assume NIL: \"P []\"\n    and Insert: \"\\<And>xs. equal_base.list_distinct ceq' xs \\<or> ID CEQ('a) = None\n                 \\<Longrightarrow> (\\<And>x. \\<lbrakk> \\<not> equal_base.list_member ceq' xs x; P xs \\<rbrakk> \\<Longrightarrow> P (equal_base.list_insert ceq' x xs))\"\n    and Eq: \"equal_base.list_distinct ceq' xs \\<or> ID CEQ('a) = None\""], ["proof (state)\nthis:\n  P []\n  \\<lbrakk>equal_base.list_distinct ceq' ?xs \\<or> ID CEQ('a) = None;\n   \\<not> equal_base.list_member ceq' ?xs ?x; P ?xs\\<rbrakk>\n  \\<Longrightarrow> P (equal_base.list_insert ceq' ?x ?xs)\n  equal_base.list_distinct ceq' xs \\<or> ID CEQ('a) = None\n\ngoal (1 subgoal):\n 1. \\<And>P x.\n       \\<lbrakk>P [];\n        \\<And>dxs a.\n           \\<lbrakk>equal_base.list_distinct ceq' dxs \\<or>\n                    ID CEQ('a) = None;\n            \\<not> equal_base.list_member ceq' dxs a; P dxs\\<rbrakk>\n           \\<Longrightarrow> P (equal_base.list_insert ceq' a dxs);\n        equal_base.list_distinct ceq' x \\<or> ID CEQ('a) = None\\<rbrakk>\n       \\<Longrightarrow> P x", "from Eq"], ["proof (chain)\npicking this:\n  equal_base.list_distinct ceq' xs \\<or> ID CEQ('a) = None", "show \"P xs\""], ["proof (prove)\nusing this:\n  equal_base.list_distinct ceq' xs \\<or> ID CEQ('a) = None\n\ngoal (1 subgoal):\n 1. P xs", "proof(induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. equal_base.list_distinct ceq' [] \\<or>\n    ID CEQ('a) = None \\<Longrightarrow>\n    P []\n 2. \\<And>a xs.\n       \\<lbrakk>equal_base.list_distinct ceq' xs \\<or>\n                ID CEQ('a) = None \\<Longrightarrow>\n                P xs;\n        equal_base.list_distinct ceq' (a # xs) \\<or>\n        ID CEQ('a) = None\\<rbrakk>\n       \\<Longrightarrow> P (a # xs)", "case Nil"], ["proof (state)\nthis:\n  equal_base.list_distinct ceq' [] \\<or> ID CEQ('a) = None\n\ngoal (2 subgoals):\n 1. equal_base.list_distinct ceq' [] \\<or>\n    ID CEQ('a) = None \\<Longrightarrow>\n    P []\n 2. \\<And>a xs.\n       \\<lbrakk>equal_base.list_distinct ceq' xs \\<or>\n                ID CEQ('a) = None \\<Longrightarrow>\n                P xs;\n        equal_base.list_distinct ceq' (a # xs) \\<or>\n        ID CEQ('a) = None\\<rbrakk>\n       \\<Longrightarrow> P (a # xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P []", "by(rule NIL)"], ["proof (state)\nthis:\n  P []\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>equal_base.list_distinct ceq' xs \\<or>\n                ID CEQ('a) = None \\<Longrightarrow>\n                P xs;\n        equal_base.list_distinct ceq' (a # xs) \\<or>\n        ID CEQ('a) = None\\<rbrakk>\n       \\<Longrightarrow> P (a # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>equal_base.list_distinct ceq' xs \\<or>\n                ID CEQ('a) = None \\<Longrightarrow>\n                P xs;\n        equal_base.list_distinct ceq' (a # xs) \\<or>\n        ID CEQ('a) = None\\<rbrakk>\n       \\<Longrightarrow> P (a # xs)", "case (Cons x xs)"], ["proof (state)\nthis:\n  equal_base.list_distinct ceq' xs \\<or> ID CEQ('a) = None \\<Longrightarrow>\n  P xs\n  equal_base.list_distinct ceq' (x # xs) \\<or> ID CEQ('a) = None\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>equal_base.list_distinct ceq' xs \\<or>\n                ID CEQ('a) = None \\<Longrightarrow>\n                P xs;\n        equal_base.list_distinct ceq' (a # xs) \\<or>\n        ID CEQ('a) = None\\<rbrakk>\n       \\<Longrightarrow> P (a # xs)", "thus ?case"], ["proof (prove)\nusing this:\n  equal_base.list_distinct ceq' xs \\<or> ID CEQ('a) = None \\<Longrightarrow>\n  P xs\n  equal_base.list_distinct ceq' (x # xs) \\<or> ID CEQ('a) = None\n\ngoal (1 subgoal):\n 1. P (x # xs)", "using Insert[of xs x] equal.equal_eq[OF equal_ceq] ID_ceq_neq_None"], ["proof (prove)\nusing this:\n  equal_base.list_distinct ceq' xs \\<or> ID CEQ('a) = None \\<Longrightarrow>\n  P xs\n  equal_base.list_distinct ceq' (x # xs) \\<or> ID CEQ('a) = None\n  \\<lbrakk>equal_base.list_distinct ceq' xs \\<or> ID CEQ('a) = None;\n   \\<not> equal_base.list_member ceq' xs x; P xs\\<rbrakk>\n  \\<Longrightarrow> P (equal_base.list_insert ceq' x xs)\n  ceq' = (=)\n  ID CEQ('a) \\<noteq> None\n\ngoal (1 subgoal):\n 1. P (x # xs)", "by(auto simp add: List.member_def simp del: not_None_eq)"], ["proof (state)\nthis:\n  P (x # xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P xs\n\ngoal:\nNo subgoals!", "qed"], ["", "context includes lifting_syntax\nbegin"], ["", "lemma fold_transfer2 [transfer_rule]:\n  assumes \"is_equality A\"\n  shows \"((A ===> pcr_set_dlist (=) ===> pcr_set_dlist (=)) ===>\n    (pcr_set_dlist (=) :: 'a list \\<Rightarrow> 'a set_dlist \\<Rightarrow> bool) ===> pcr_set_dlist (=) ===> pcr_set_dlist (=))\n     List.fold DList_Set.fold\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> pcr_set_dlist (=) ===> pcr_set_dlist (=)) ===>\n     pcr_set_dlist (=) ===> pcr_set_dlist (=) ===> pcr_set_dlist (=))\n     List.fold DList_Set.fold", "unfolding Transfer.Rel_def set_dlist.pcr_cr_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> cr_set_dlist ===> cr_set_dlist) ===>\n     cr_set_dlist ===> cr_set_dlist ===> cr_set_dlist)\n     List.fold DList_Set.fold", "proof(rule rel_funI)+"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(A ===> cr_set_dlist ===> cr_set_dlist) x y;\n        cr_set_dlist xa ya; cr_set_dlist xb yb\\<rbrakk>\n       \\<Longrightarrow> cr_set_dlist (List.fold x xa xb)\n                          (DList_Set.fold y ya yb)", "fix f :: \"'a \\<Rightarrow> 'b list \\<Rightarrow> 'b list\" and g and xs :: \"'a list\" and ys and b :: \"'b list\" and c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(A ===> cr_set_dlist ===> cr_set_dlist) x y;\n        cr_set_dlist xa ya; cr_set_dlist xb yb\\<rbrakk>\n       \\<Longrightarrow> cr_set_dlist (List.fold x xa xb)\n                          (DList_Set.fold y ya yb)", "assume fg: \"(A ===> cr_set_dlist ===> cr_set_dlist) f g\""], ["proof (state)\nthis:\n  (A ===> cr_set_dlist ===> cr_set_dlist) f g\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(A ===> cr_set_dlist ===> cr_set_dlist) x y;\n        cr_set_dlist xa ya; cr_set_dlist xb yb\\<rbrakk>\n       \\<Longrightarrow> cr_set_dlist (List.fold x xa xb)\n                          (DList_Set.fold y ya yb)", "assume \"cr_set_dlist xs ys\" \"cr_set_dlist b c\""], ["proof (state)\nthis:\n  cr_set_dlist xs ys\n  cr_set_dlist b c\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(A ===> cr_set_dlist ===> cr_set_dlist) x y;\n        cr_set_dlist xa ya; cr_set_dlist xb yb\\<rbrakk>\n       \\<Longrightarrow> cr_set_dlist (List.fold x xa xb)\n                          (DList_Set.fold y ya yb)", "thus \"cr_set_dlist (List.fold f xs b) (DList_Set.fold g ys c)\""], ["proof (prove)\nusing this:\n  cr_set_dlist xs ys\n  cr_set_dlist b c\n\ngoal (1 subgoal):\n 1. cr_set_dlist (List.fold f xs b) (DList_Set.fold g ys c)", "proof(induct ys arbitrary: xs b c rule: set_dlist_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs b c.\n       \\<lbrakk>cr_set_dlist xs DList_Set.empty; cr_set_dlist b c\\<rbrakk>\n       \\<Longrightarrow> cr_set_dlist (List.fold f xs b)\n                          (DList_Set.fold g DList_Set.empty c)\n 2. \\<And>a dxs xs b c.\n       \\<lbrakk>\\<not> member dxs a;\n        \\<And>xs b c.\n           \\<lbrakk>cr_set_dlist xs dxs; cr_set_dlist b c\\<rbrakk>\n           \\<Longrightarrow> cr_set_dlist (List.fold f xs b)\n                              (DList_Set.fold g dxs c);\n        cr_set_dlist xs (DList_Set.insert a dxs); cr_set_dlist b c\\<rbrakk>\n       \\<Longrightarrow> cr_set_dlist (List.fold f xs b)\n                          (DList_Set.fold g (DList_Set.insert a dxs) c)", "case Nil"], ["proof (state)\nthis:\n  cr_set_dlist xs DList_Set.empty\n  cr_set_dlist b c\n\ngoal (2 subgoals):\n 1. \\<And>xs b c.\n       \\<lbrakk>cr_set_dlist xs DList_Set.empty; cr_set_dlist b c\\<rbrakk>\n       \\<Longrightarrow> cr_set_dlist (List.fold f xs b)\n                          (DList_Set.fold g DList_Set.empty c)\n 2. \\<And>a dxs xs b c.\n       \\<lbrakk>\\<not> member dxs a;\n        \\<And>xs b c.\n           \\<lbrakk>cr_set_dlist xs dxs; cr_set_dlist b c\\<rbrakk>\n           \\<Longrightarrow> cr_set_dlist (List.fold f xs b)\n                              (DList_Set.fold g dxs c);\n        cr_set_dlist xs (DList_Set.insert a dxs); cr_set_dlist b c\\<rbrakk>\n       \\<Longrightarrow> cr_set_dlist (List.fold f xs b)\n                          (DList_Set.fold g (DList_Set.insert a dxs) c)", "thus ?case"], ["proof (prove)\nusing this:\n  cr_set_dlist xs DList_Set.empty\n  cr_set_dlist b c\n\ngoal (1 subgoal):\n 1. cr_set_dlist (List.fold f xs b) (DList_Set.fold g DList_Set.empty c)", "by(simp add: cr_set_dlist_def)"], ["proof (state)\nthis:\n  cr_set_dlist (List.fold f xs b) (DList_Set.fold g DList_Set.empty c)\n\ngoal (1 subgoal):\n 1. \\<And>a dxs xs b c.\n       \\<lbrakk>\\<not> member dxs a;\n        \\<And>xs b c.\n           \\<lbrakk>cr_set_dlist xs dxs; cr_set_dlist b c\\<rbrakk>\n           \\<Longrightarrow> cr_set_dlist (List.fold f xs b)\n                              (DList_Set.fold g dxs c);\n        cr_set_dlist xs (DList_Set.insert a dxs); cr_set_dlist b c\\<rbrakk>\n       \\<Longrightarrow> cr_set_dlist (List.fold f xs b)\n                          (DList_Set.fold g (DList_Set.insert a dxs) c)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a dxs xs b c.\n       \\<lbrakk>\\<not> member dxs a;\n        \\<And>xs b c.\n           \\<lbrakk>cr_set_dlist xs dxs; cr_set_dlist b c\\<rbrakk>\n           \\<Longrightarrow> cr_set_dlist (List.fold f xs b)\n                              (DList_Set.fold g dxs c);\n        cr_set_dlist xs (DList_Set.insert a dxs); cr_set_dlist b c\\<rbrakk>\n       \\<Longrightarrow> cr_set_dlist (List.fold f xs b)\n                          (DList_Set.fold g (DList_Set.insert a dxs) c)", "case (insert y dxs)"], ["proof (state)\nthis:\n  \\<not> member dxs y\n  \\<lbrakk>cr_set_dlist ?xs dxs; cr_set_dlist ?b ?c\\<rbrakk>\n  \\<Longrightarrow> cr_set_dlist (List.fold f ?xs ?b)\n                     (DList_Set.fold g dxs ?c)\n  cr_set_dlist xs (DList_Set.insert y dxs)\n  cr_set_dlist b c\n\ngoal (1 subgoal):\n 1. \\<And>a dxs xs b c.\n       \\<lbrakk>\\<not> member dxs a;\n        \\<And>xs b c.\n           \\<lbrakk>cr_set_dlist xs dxs; cr_set_dlist b c\\<rbrakk>\n           \\<Longrightarrow> cr_set_dlist (List.fold f xs b)\n                              (DList_Set.fold g dxs c);\n        cr_set_dlist xs (DList_Set.insert a dxs); cr_set_dlist b c\\<rbrakk>\n       \\<Longrightarrow> cr_set_dlist (List.fold f xs b)\n                          (DList_Set.fold g (DList_Set.insert a dxs) c)", "have \"A y y\" and \"cr_set_dlist (list_of_dlist c) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A y y &&& cr_set_dlist (list_of_dlist c) c", "using assms"], ["proof (prove)\nusing this:\n  is_equality A\n\ngoal (1 subgoal):\n 1. A y y &&& cr_set_dlist (list_of_dlist c) c", "by(simp_all add: cr_set_dlist_def is_equality_def)"], ["proof (state)\nthis:\n  A y y\n  cr_set_dlist (list_of_dlist c) c\n\ngoal (1 subgoal):\n 1. \\<And>a dxs xs b c.\n       \\<lbrakk>\\<not> member dxs a;\n        \\<And>xs b c.\n           \\<lbrakk>cr_set_dlist xs dxs; cr_set_dlist b c\\<rbrakk>\n           \\<Longrightarrow> cr_set_dlist (List.fold f xs b)\n                              (DList_Set.fold g dxs c);\n        cr_set_dlist xs (DList_Set.insert a dxs); cr_set_dlist b c\\<rbrakk>\n       \\<Longrightarrow> cr_set_dlist (List.fold f xs b)\n                          (DList_Set.fold g (DList_Set.insert a dxs) c)", "with fg"], ["proof (chain)\npicking this:\n  (A ===> cr_set_dlist ===> cr_set_dlist) f g\n  A y y\n  cr_set_dlist (list_of_dlist c) c", "have \"cr_set_dlist (f y (list_of_dlist c)) (g y c)\""], ["proof (prove)\nusing this:\n  (A ===> cr_set_dlist ===> cr_set_dlist) f g\n  A y y\n  cr_set_dlist (list_of_dlist c) c\n\ngoal (1 subgoal):\n 1. cr_set_dlist (f y (list_of_dlist c)) (g y c)", "by -(drule (1) rel_funD)+"], ["proof (state)\nthis:\n  cr_set_dlist (f y (list_of_dlist c)) (g y c)\n\ngoal (1 subgoal):\n 1. \\<And>a dxs xs b c.\n       \\<lbrakk>\\<not> member dxs a;\n        \\<And>xs b c.\n           \\<lbrakk>cr_set_dlist xs dxs; cr_set_dlist b c\\<rbrakk>\n           \\<Longrightarrow> cr_set_dlist (List.fold f xs b)\n                              (DList_Set.fold g dxs c);\n        cr_set_dlist xs (DList_Set.insert a dxs); cr_set_dlist b c\\<rbrakk>\n       \\<Longrightarrow> cr_set_dlist (List.fold f xs b)\n                          (DList_Set.fold g (DList_Set.insert a dxs) c)", "thus ?case"], ["proof (prove)\nusing this:\n  cr_set_dlist (f y (list_of_dlist c)) (g y c)\n\ngoal (1 subgoal):\n 1. cr_set_dlist (List.fold f xs b)\n     (DList_Set.fold g (DList_Set.insert y dxs) c)", "using insert"], ["proof (prove)\nusing this:\n  cr_set_dlist (f y (list_of_dlist c)) (g y c)\n  \\<not> member dxs y\n  \\<lbrakk>cr_set_dlist ?xs dxs; cr_set_dlist ?b ?c\\<rbrakk>\n  \\<Longrightarrow> cr_set_dlist (List.fold f ?xs ?b)\n                     (DList_Set.fold g dxs ?c)\n  cr_set_dlist xs (DList_Set.insert y dxs)\n  cr_set_dlist b c\n\ngoal (1 subgoal):\n 1. cr_set_dlist (List.fold f xs b)\n     (DList_Set.fold g (DList_Set.insert y dxs) c)", "by(simp add: cr_set_dlist_def)"], ["proof (state)\nthis:\n  cr_set_dlist (List.fold f xs b)\n   (DList_Set.fold g (DList_Set.insert y dxs) c)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cr_set_dlist (List.fold f xs b) (DList_Set.fold g ys c)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma distinct_list_of_dlist:\n  \"distinct (list_of_dlist (dxs :: 'a set_dlist))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (list_of_dlist dxs)", "using list_of_dlist[of dxs] equal.equal_eq[OF equal_ceq]"], ["proof (prove)\nusing this:\n  list_of_dlist dxs\n  \\<in> {xs. equal_base.list_distinct ceq' xs \\<or> ID CEQ('a) = None}\n  ceq' = (=)\n\ngoal (1 subgoal):\n 1. distinct (list_of_dlist dxs)", "by(simp add: ID_ceq_neq_None)"], ["", "lemma member_empty_empty: \"(\\<forall>x :: 'a. \\<not> member dxs x) \\<longleftrightarrow> dxs = empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. \\<not> member dxs x) = (dxs = DList_Set.empty)", "by(transfer)(simp add: equal.equal_eq[OF equal_ceq] List.member_def)"], ["", "lemma Collect_member: \"Collect (member (dxs :: 'a set_dlist)) = set (list_of_dlist dxs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Collect (member dxs) = set (list_of_dlist dxs)", "by(simp add: member_def equal.equal_eq[OF equal_ceq] List.member_def[abs_def])"], ["", "lemma member_insert: \"member (insert (x :: 'a) xs) = (member xs)(x := True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. member (DList_Set.insert x xs) = (member xs)(x := True)", "by(transfer)(simp add: fun_eq_iff List.member_def ID_ceq_neq_None equal.equal_eq[OF equal_ceq])"], ["", "lemma member_remove:\n  \"member (remove (x :: 'a) xs) = (member xs)(x := False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. member (remove x xs) = (member xs)(x := False)", "by transfer (auto simp add: fun_eq_iff ID_ceq_neq_None equal.equal_eq[OF equal_ceq] List.member_def)"], ["", "lemma member_union: \"member (union (xs1 :: 'a set_dlist) xs2) x \\<longleftrightarrow> member xs1 x \\<or> member xs2 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. member (DList_Set.union xs1 xs2) x = (member xs1 x \\<or> member xs2 x)", "unfolding union_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. member (DList_Set.fold DList_Set.insert xs1 xs2) x =\n    (member xs1 x \\<or> member xs2 x)", "by(transfer)(simp add: equal.equal_eq[OF equal_ceq] List.member_def set_fold_insert)"], ["", "lemma member_fold_insert: \"member (List.fold insert xs dxs) (x :: 'a) \\<longleftrightarrow> member dxs x \\<or> x \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. member (List.fold DList_Set.insert xs dxs) x =\n    (member dxs x \\<or> x \\<in> set xs)", "by transfer(auto simp add: ID_ceq_neq_None equal.equal_eq[OF equal_ceq] List.member_def set_fold_insert)"], ["", "lemma card_eq_length [simp]:\n  \"card (Collect (member (dxs :: 'a set_dlist))) = length dxs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (Collect (member dxs)) = DList_Set.length dxs", "by transfer(simp add: ID_ceq_neq_None equal.equal_eq[OF equal_ceq] List.member_def[abs_def] distinct_card)"], ["", "lemma finite_member [simp]: \n  \"finite (Collect (member (dxs :: 'a set_dlist)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Collect (member dxs))", "by transfer(simp add: ID_ceq_neq_None equal.equal_eq[OF equal_ceq] List.member_def[abs_def])"], ["", "lemma member_filter [simp]: \"member (filter P xs) = (\\<lambda>x :: 'a. member xs x \\<and> P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. member (DList_Set.filter P xs) = (\\<lambda>x. member xs x \\<and> P x)", "by transfer(simp add: ID_ceq_neq_None equal.equal_eq[OF equal_ceq] List.member_def[abs_def])"], ["", "lemma dlist_all_conv_member: \"dlist_all P dxs \\<longleftrightarrow> (\\<forall>x :: 'a. member dxs x \\<longrightarrow> P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dlist_all P dxs = (\\<forall>x. member dxs x \\<longrightarrow> P x)", "by transfer(auto simp add: ID_ceq_neq_None equal.equal_eq[OF equal_ceq] list_all_iff List.member_def)"], ["", "lemma dlist_ex_conv_member: \"dlist_ex P dxs \\<longleftrightarrow> (\\<exists>x :: 'a. member dxs x \\<and> P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dlist_ex P dxs = (\\<exists>x. member dxs x \\<and> P x)", "by transfer(auto simp add: ID_ceq_neq_None equal.equal_eq[OF equal_ceq] list_ex_iff List.member_def)"], ["", "lemma member_Id_on: \"member (Id_on dxs) = (\\<lambda>(x :: 'a, y). x = y \\<and> member dxs x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. member (DList_Set.Id_on dxs) =\n    (\\<lambda>(x, y). x = y \\<and> member dxs x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. member (DList_Set.Id_on dxs) =\n    (\\<lambda>(x, y). x = y \\<and> member dxs x)", "have \"ID CEQ('a \\<times> 'a) = Some (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ID CEQ('a \\<times> 'a) = Some (=)", "using equal.equal_eq[where ?'a='a, OF equal_ceq]"], ["proof (prove)\nusing this:\n  ceq' = (=)\n\ngoal (1 subgoal):\n 1. ID CEQ('a \\<times> 'a) = Some (=)", "by(auto simp add: ceq_prod_def list_all_eq_def ID_ceq_neq_None ID_Some fun_eq_iff split: option.split)"], ["proof (state)\nthis:\n  ID CEQ('a \\<times> 'a) = Some (=)\n\ngoal (1 subgoal):\n 1. member (DList_Set.Id_on dxs) =\n    (\\<lambda>(x, y). x = y \\<and> member dxs x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ID CEQ('a \\<times> 'a) = Some (=)\n\ngoal (1 subgoal):\n 1. member (DList_Set.Id_on dxs) =\n    (\\<lambda>(x, y). x = y \\<and> member dxs x)", "using equal.equal_eq[where ?'a='a, OF equal_ceq]"], ["proof (prove)\nusing this:\n  ID CEQ('a \\<times> 'a) = Some (=)\n  ceq' = (=)\n\ngoal (1 subgoal):\n 1. member (DList_Set.Id_on dxs) =\n    (\\<lambda>(x, y). x = y \\<and> member dxs x)", "by transfer(auto simp add: ID_ceq_neq_None List.member_def[abs_def] ID_Some intro!: ext split: option.split_asm)"], ["proof (state)\nthis:\n  member (DList_Set.Id_on dxs) =\n  (\\<lambda>(x, y). x = y \\<and> member dxs x)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma product_member: \n  assumes \"ID CEQ('a :: ceq) \\<noteq> None\" \"ID CEQ('b :: ceq) \\<noteq> None\"\n  shows \"member (product dxs1 dxs2) = (\\<lambda>(a :: 'a, b :: 'b). member dxs1 a \\<and> member dxs2 b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. member (product dxs1 dxs2) =\n    (\\<lambda>(a, b). member dxs1 a \\<and> member dxs2 b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. member (product dxs1 dxs2) =\n    (\\<lambda>(a, b). member dxs1 a \\<and> member dxs2 b)", "from assms"], ["proof (chain)\npicking this:\n  ID CEQ('a) \\<noteq> None\n  ID CEQ('b) \\<noteq> None", "have \"ceq' = ((=) :: 'a \\<Rightarrow> 'a \\<Rightarrow> bool)\" \"ceq' = ((=) :: 'b \\<Rightarrow> 'b \\<Rightarrow> bool)\""], ["proof (prove)\nusing this:\n  ID CEQ('a) \\<noteq> None\n  ID CEQ('b) \\<noteq> None\n\ngoal (1 subgoal):\n 1. ceq' = (=) &&& ceq' = (=)", "by(auto intro: equal.equal_eq[OF ID_ceq])"], ["proof (state)\nthis:\n  ceq' = (=)\n  ceq' = (=)\n\ngoal (1 subgoal):\n 1. member (product dxs1 dxs2) =\n    (\\<lambda>(a, b). member dxs1 a \\<and> member dxs2 b)", "moreover"], ["proof (state)\nthis:\n  ceq' = (=)\n  ceq' = (=)\n\ngoal (1 subgoal):\n 1. member (product dxs1 dxs2) =\n    (\\<lambda>(a, b). member dxs1 a \\<and> member dxs2 b)", "with assms"], ["proof (chain)\npicking this:\n  ID CEQ('a) \\<noteq> None\n  ID CEQ('b) \\<noteq> None\n  ceq' = (=)\n  ceq' = (=)", "have \"ceq' = ((=) :: ('a \\<times> 'b) \\<Rightarrow> ('a \\<times> 'b) \\<Rightarrow> bool)\""], ["proof (prove)\nusing this:\n  ID CEQ('a) \\<noteq> None\n  ID CEQ('b) \\<noteq> None\n  ceq' = (=)\n  ceq' = (=)\n\ngoal (1 subgoal):\n 1. ceq' = (=)", "by(auto simp add: ceq_prod_def list_all_eq_def ID_Some fun_eq_iff)"], ["proof (state)\nthis:\n  ceq' = (=)\n\ngoal (1 subgoal):\n 1. member (product dxs1 dxs2) =\n    (\\<lambda>(a, b). member dxs1 a \\<and> member dxs2 b)", "ultimately"], ["proof (chain)\npicking this:\n  ceq' = (=)\n  ceq' = (=)\n  ceq' = (=)", "show ?thesis"], ["proof (prove)\nusing this:\n  ceq' = (=)\n  ceq' = (=)\n  ceq' = (=)\n\ngoal (1 subgoal):\n 1. member (product dxs1 dxs2) =\n    (\\<lambda>(a, b). member dxs1 a \\<and> member dxs2 b)", "by(transfer)(auto simp add: List.member_def[abs_def])"], ["proof (state)\nthis:\n  member (product dxs1 dxs2) =\n  (\\<lambda>(a, b). member dxs1 a \\<and> member dxs2 b)\n\ngoal:\nNo subgoals!", "qed"], ["", "hide_const (open) empty insert remove null member length fold foldr union filter hd tl dlist_all product Id_on"], ["", "end"]]}