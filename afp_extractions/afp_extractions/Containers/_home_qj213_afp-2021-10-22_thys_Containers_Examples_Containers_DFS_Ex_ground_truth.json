{"file_name": "/home/qj213/afp-2021-10-22/thys/Containers/Examples/Containers_DFS_Ex.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Containers", "problem_names": ["lemma in_restrict [iff]: \"(a, b) \\<in> R \\<upharpoonleft> A \\<longleftrightarrow> (a, b) \\<in> R \\<and> b \\<in> A\"", "lemma restrict_UNIV [simp]: \"R \\<upharpoonleft> UNIV = R\"", "lemma restrict_restrict [simp]: \"R \\<upharpoonleft> A \\<upharpoonleft> B = R \\<upharpoonleft> (A \\<inter> B)\"", "lemma rtrancl_restrict_reachable:\n  assumes x: \"(x, y) \\<in> R\\<^sup>*\"\n  and z: \"(z, y) \\<notin> R\\<^sup>*\"\n  shows \"(x, y) \\<in> (R \\<upharpoonleft> - R\\<^sup>* `` {z})\\<^sup>*\"", "lemma rtrancl_restrict_start:\n  assumes \"(x, y) \\<in> R\\<^sup>*\"\n  shows \"(x, y) \\<in> (R \\<upharpoonleft> - {x})\\<^sup>*\"", "lemma (in comp_fun_commute) fold_set_union_disj: (* Move to distribution *)\n  assumes \"finite A\" \"finite B\" \"A \\<inter> B = {}\"\n  shows \"Finite_Set.fold f z (A \\<union> B) = Finite_Set.fold f (Finite_Set.fold f z A) B\"", "lemma Image_insert [simp]:\n  fixes A :: \"'a set\"\n  assumes \"NO_MATCH ({} :: 'a set) A\"\n  shows \"R `` insert x A = R `` {x} \\<union> (R `` A)\"", "lemma loop_simps:\n  \"loop x Reachable = Reachable\"\n  \"loop x (Visited \\<V>) = (if x \\<in> \\<V> then Visited \\<V> else dfs x tgt \\<V>)\"", "lemma comp_fun_commute_dfs_body: \"comp_fun_commute loop\"", "lemma fold_dfs_Reachable [simp]:\n  \"Finite_Set.fold loop Reachable A = Reachable\"", "lemma dfs_blocked:\n  assumes \"finite A\"\n  and \"E `` A \\<subseteq> visited\" \"tgt \\<notin> A\"\n  shows \"Finite_Set.fold loop (Visited visited) A = Visited (A \\<union> visited)\"", "lemma dfs_visited:\n  assumes \"finite A\"\n  and \"A \\<subseteq> visited\"\n  shows \"Finite_Set.fold loop (Visited visited) A = Visited visited\"", "lemma dfs_rec:\n  \"dfs src tgt visited =\n  (if src = tgt then Reachable\n   else let succs = E `` {src} in if finite succs then Finite_Set.fold loop (Visited (insert src visited)) succs\n   else Code.abort (STR ''infinite successor relation'') (\\<lambda>_. dfs src tgt visited))\"", "lemma dfs_code [code]:\n  \"dfs src tgt visited =\n  (if src = tgt then Reachable\n   else let S = E `` {src} in \n   if finite S then set_fold_cfc (dfs_body tgt) (Visited (insert src visited)) S\n   else Code.abort (STR ''infinite successor relation'') (\\<lambda>_. dfs src tgt visited))\"", "lemma reachable_dfs [code]:\n  \"reachable src tgt = is_Reachable (dfs src tgt {})\"", "lemma succs_code [code]: \"succs (Succ s) = s\"", "lemmas [containers_identify, code] = reachable_dfs dfs_code dfs_body.rep_eq"], "translations": [["", "lemma in_restrict [iff]: \"(a, b) \\<in> R \\<upharpoonleft> A \\<longleftrightarrow> (a, b) \\<in> R \\<and> b \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((a, b) \\<in> R \\<upharpoonleft> A) = ((a, b) \\<in> R \\<and> b \\<in> A)", "by(simp add: restrict_def)"], ["", "lemma restrict_UNIV [simp]: \"R \\<upharpoonleft> UNIV = R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<upharpoonleft> UNIV = R", "by auto"], ["", "lemma restrict_restrict [simp]: \"R \\<upharpoonleft> A \\<upharpoonleft> B = R \\<upharpoonleft> (A \\<inter> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<upharpoonleft> A \\<upharpoonleft> B =\n    R \\<upharpoonleft> A \\<inter> B", "by auto"], ["", "lemma rtrancl_restrict_reachable:\n  assumes x: \"(x, y) \\<in> R\\<^sup>*\"\n  and z: \"(z, y) \\<notin> R\\<^sup>*\"\n  shows \"(x, y) \\<in> (R \\<upharpoonleft> - R\\<^sup>* `` {z})\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> (R \\<upharpoonleft> - R\\<^sup>* `` {z})\\<^sup>*", "using x"], ["proof (prove)\nusing this:\n  (x, y) \\<in> R\\<^sup>*\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (R \\<upharpoonleft> - R\\<^sup>* `` {z})\\<^sup>*", "proof(induction rule: converse_rtrancl_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. (y, y) \\<in> (R \\<upharpoonleft> - R\\<^sup>* `` {z})\\<^sup>*\n 2. \\<And>ya za.\n       \\<lbrakk>(ya, za) \\<in> R; (za, y) \\<in> R\\<^sup>*;\n        (za, y)\n        \\<in> (R \\<upharpoonleft> - R\\<^sup>* `` {z})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> (ya, y)\n                         \\<in> (R \\<upharpoonleft>\n                                - R\\<^sup>* `` {z})\\<^sup>*", "case (step x x')"], ["proof (state)\nthis:\n  (x, x') \\<in> R\n  (x', y) \\<in> R\\<^sup>*\n  (x', y) \\<in> (R \\<upharpoonleft> - R\\<^sup>* `` {z})\\<^sup>*\n\ngoal (2 subgoals):\n 1. (y, y) \\<in> (R \\<upharpoonleft> - R\\<^sup>* `` {z})\\<^sup>*\n 2. \\<And>ya za.\n       \\<lbrakk>(ya, za) \\<in> R; (za, y) \\<in> R\\<^sup>*;\n        (za, y)\n        \\<in> (R \\<upharpoonleft> - R\\<^sup>* `` {z})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> (ya, y)\n                         \\<in> (R \\<upharpoonleft>\n                                - R\\<^sup>* `` {z})\\<^sup>*", "from \\<open>(x, x') \\<in> R\\<close> z \\<open>(x', y) \\<in> R\\<^sup>*\\<close>"], ["proof (chain)\npicking this:\n  (x, x') \\<in> R\n  (z, y) \\<notin> R\\<^sup>*\n  (x', y) \\<in> R\\<^sup>*", "have \"(x, x') \\<in> R \\<upharpoonleft> - R\\<^sup>* `` {z}\""], ["proof (prove)\nusing this:\n  (x, x') \\<in> R\n  (z, y) \\<notin> R\\<^sup>*\n  (x', y) \\<in> R\\<^sup>*\n\ngoal (1 subgoal):\n 1. (x, x') \\<in> R \\<upharpoonleft> - R\\<^sup>* `` {z}", "by(auto intro: rtrancl_trans converse_rtrancl_into_rtrancl)"], ["proof (state)\nthis:\n  (x, x') \\<in> R \\<upharpoonleft> - R\\<^sup>* `` {z}\n\ngoal (2 subgoals):\n 1. (y, y) \\<in> (R \\<upharpoonleft> - R\\<^sup>* `` {z})\\<^sup>*\n 2. \\<And>ya za.\n       \\<lbrakk>(ya, za) \\<in> R; (za, y) \\<in> R\\<^sup>*;\n        (za, y)\n        \\<in> (R \\<upharpoonleft> - R\\<^sup>* `` {z})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> (ya, y)\n                         \\<in> (R \\<upharpoonleft>\n                                - R\\<^sup>* `` {z})\\<^sup>*", "thus ?case"], ["proof (prove)\nusing this:\n  (x, x') \\<in> R \\<upharpoonleft> - R\\<^sup>* `` {z}\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (R \\<upharpoonleft> - R\\<^sup>* `` {z})\\<^sup>*", "using step.IH"], ["proof (prove)\nusing this:\n  (x, x') \\<in> R \\<upharpoonleft> - R\\<^sup>* `` {z}\n  (x', y) \\<in> (R \\<upharpoonleft> - R\\<^sup>* `` {z})\\<^sup>*\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (R \\<upharpoonleft> - R\\<^sup>* `` {z})\\<^sup>*", "by(rule converse_rtrancl_into_rtrancl)"], ["proof (state)\nthis:\n  (x, y) \\<in> (R \\<upharpoonleft> - R\\<^sup>* `` {z})\\<^sup>*\n\ngoal (1 subgoal):\n 1. (y, y) \\<in> (R \\<upharpoonleft> - R\\<^sup>* `` {z})\\<^sup>*", "qed simp"], ["", "lemma rtrancl_restrict_start:\n  assumes \"(x, y) \\<in> R\\<^sup>*\"\n  shows \"(x, y) \\<in> (R \\<upharpoonleft> - {x})\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> (R \\<upharpoonleft> - {x})\\<^sup>*", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x, y) \\<in> (R \\<upharpoonleft> - {x})\\<^sup>*", "let ?R = \"\\<lambda>x y. (x, y) \\<in> R\""], ["proof (state)\ngoal (1 subgoal):\n 1. (x, y) \\<in> (R \\<upharpoonleft> - {x})\\<^sup>*", "define z where \"z \\<equiv> x\""], ["proof (state)\nthis:\n  z \\<equiv> x\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (R \\<upharpoonleft> - {x})\\<^sup>*", "with assms"], ["proof (chain)\npicking this:\n  (x, y) \\<in> R\\<^sup>*\n  z \\<equiv> x", "obtain xs where \"rtrancl_path ?R x xs y\" \"z \\<notin> set xs\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> R\\<^sup>*\n  z \\<equiv> x\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>rtrancl_path (\\<lambda>x y. (x, y) \\<in> R) x xs y;\n         z \\<notin> set xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: rtrancl_def rtranclp_eq_rtrancl_path elim: rtrancl_path_distinct)"], ["proof (state)\nthis:\n  rtrancl_path (\\<lambda>x y. (x, y) \\<in> R) x xs y\n  z \\<notin> set xs\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (R \\<upharpoonleft> - {x})\\<^sup>*", "thus \"(x, y) \\<in> (R \\<upharpoonleft> - {z})\\<^sup>*\""], ["proof (prove)\nusing this:\n  rtrancl_path (\\<lambda>x y. (x, y) \\<in> R) x xs y\n  z \\<notin> set xs\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (R \\<upharpoonleft> - {z})\\<^sup>*", "by induction(auto intro: converse_rtrancl_into_rtrancl)"], ["proof (state)\nthis:\n  (x, y) \\<in> (R \\<upharpoonleft> - {z})\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in comp_fun_commute) fold_set_union_disj: (* Move to distribution *)\n  assumes \"finite A\" \"finite B\" \"A \\<inter> B = {}\"\n  shows \"Finite_Set.fold f z (A \\<union> B) = Finite_Set.fold f (Finite_Set.fold f z A) B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_Set.fold f z (A \\<union> B) =\n    Finite_Set.fold f (Finite_Set.fold f z A) B", "using assms(2,1,3)"], ["proof (prove)\nusing this:\n  finite B\n  finite A\n  A \\<inter> B = {}\n\ngoal (1 subgoal):\n 1. Finite_Set.fold f z (A \\<union> B) =\n    Finite_Set.fold f (Finite_Set.fold f z A) B", "by induction simp_all"], ["", "lemma Image_insert [simp]:\n  fixes A :: \"'a set\"\n  assumes \"NO_MATCH ({} :: 'a set) A\"\n  shows \"R `` insert x A = R `` {x} \\<union> (R `` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R `` insert x A = R `` {x} \\<union> R `` A", "by(auto)"], ["", "subsection \\<open>Declarative definition\\<close>"], ["", "datatype 'a dfs_result = is_Reachable: Reachable | Visited \"'a set\""], ["", "context fixes E :: \"('a \\<times> 'a) set\" begin"], ["", "definition reachable :: \"'a => 'a => bool\"\nwhere \"reachable src tgt \\<longleftrightarrow> (src, tgt) \\<in> E\\<^sup>*\""], ["", "text \\<open>\n  We avoid the non-determinism of visited nodes in depth-first search by only returning\n  the set of visited nodes when the search fails, because in that case it contains all reachable\n  nodes and therefore is deterministic again.\n\\<close>"], ["", "definition dfs :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a set \\<Rightarrow> 'a dfs_result\"\nwhere \n  \"dfs src tgt visited =\n  (if tgt \\<in> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src} then Reachable else Visited (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src}))\""], ["", "subsection \\<open>Derivation of the recursion equation\\<close>"], ["", "context\n  fixes tgt :: 'a and loop\n  defines \"loop \\<equiv> \\<lambda>x r. case r of Reachable \\<Rightarrow> Reachable | Visited \\<V> \\<Rightarrow> \n    if x \\<in> \\<V> then Visited \\<V> else dfs x tgt \\<V>\"\nbegin"], ["", "private"], ["", "lemma loop_simps:\n  \"loop x Reachable = Reachable\"\n  \"loop x (Visited \\<V>) = (if x \\<in> \\<V> then Visited \\<V> else dfs x tgt \\<V>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. loop x Reachable = Reachable &&&\n    loop x (Visited \\<V>) =\n    (if x \\<in> \\<V> then Visited \\<V> else local.dfs x tgt \\<V>)", "by(simp_all add: loop_def)"], ["", "context notes [simp] = loop_simps begin"], ["", "lemma comp_fun_commute_dfs_body: \"comp_fun_commute loop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_commute loop", "by(unfold_locales)(auto simp add: loop_def dfs_def fun_eq_iff intro: rtrancl_mono[THEN subsetD, rotated] rtrancl_trans dest: rtrancl_restrict_reachable split: dfs_result.split)"], ["", "interpretation f: comp_fun_commute loop"], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_commute loop", "by(rule comp_fun_commute_dfs_body)"], ["", "lemma fold_dfs_Reachable [simp]:\n  \"Finite_Set.fold loop Reachable A = Reachable\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_Set.fold loop Reachable A = Reachable", "proof(cases \"finite A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow> Finite_Set.fold loop Reachable A = Reachable\n 2. infinite A \\<Longrightarrow>\n    Finite_Set.fold loop Reachable A = Reachable", "case True"], ["proof (state)\nthis:\n  finite A\n\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow> Finite_Set.fold loop Reachable A = Reachable\n 2. infinite A \\<Longrightarrow>\n    Finite_Set.fold loop Reachable A = Reachable", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. Finite_Set.fold loop Reachable A = Reachable", "by(induction) auto"], ["proof (state)\nthis:\n  Finite_Set.fold loop Reachable A = Reachable\n\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow>\n    Finite_Set.fold loop Reachable A = Reachable", "qed simp"], ["", "lemma dfs_blocked:\n  assumes \"finite A\"\n  and \"E `` A \\<subseteq> visited\" \"tgt \\<notin> A\"\n  shows \"Finite_Set.fold loop (Visited visited) A = Visited (A \\<union> visited)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_Set.fold loop (Visited visited) A = Visited (A \\<union> visited)", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  E `` A \\<subseteq> visited\n  tgt \\<notin> A\n\ngoal (1 subgoal):\n 1. Finite_Set.fold loop (Visited visited) A = Visited (A \\<union> visited)", "by induction(auto elim: converse_rtranclE simp add: dfs_def)"], ["", "lemma dfs_visited:\n  assumes \"finite A\"\n  and \"A \\<subseteq> visited\"\n  shows \"Finite_Set.fold loop (Visited visited) A = Visited visited\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_Set.fold loop (Visited visited) A = Visited visited", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  A \\<subseteq> visited\n\ngoal (1 subgoal):\n 1. Finite_Set.fold loop (Visited visited) A = Visited visited", "by induction(auto)"], ["", "lemma dfs_rec:\n  \"dfs src tgt visited =\n  (if src = tgt then Reachable\n   else let succs = E `` {src} in if finite succs then Finite_Set.fold loop (Visited (insert src visited)) succs\n   else Code.abort (STR ''infinite successor relation'') (\\<lambda>_. dfs src tgt visited))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dfs src tgt visited =\n    (if src = tgt then Reachable\n     else let succs = E `` {src}\n          in if finite succs\n             then Finite_Set.fold loop (Visited (insert src visited)) succs\n             else Code.abort STR ''infinite successor relation''\n                   (\\<lambda>_. local.dfs src tgt visited))", "proof(cases \"src \\<noteq> tgt \\<and> finite (E `` {src})\")"], ["proof (state)\ngoal (2 subgoals):\n 1. src \\<noteq> tgt \\<and> finite (E `` {src}) \\<Longrightarrow>\n    local.dfs src tgt visited =\n    (if src = tgt then Reachable\n     else let succs = E `` {src}\n          in if finite succs\n             then Finite_Set.fold loop (Visited (insert src visited)) succs\n             else Code.abort STR ''infinite successor relation''\n                   (\\<lambda>_. local.dfs src tgt visited))\n 2. \\<not> (src \\<noteq> tgt \\<and> finite (E `` {src})) \\<Longrightarrow>\n    local.dfs src tgt visited =\n    (if src = tgt then Reachable\n     else let succs = E `` {src}\n          in if finite succs\n             then Finite_Set.fold loop (Visited (insert src visited)) succs\n             else Code.abort STR ''infinite successor relation''\n                   (\\<lambda>_. local.dfs src tgt visited))", "case False"], ["proof (state)\nthis:\n  \\<not> (src \\<noteq> tgt \\<and> finite (E `` {src}))\n\ngoal (2 subgoals):\n 1. src \\<noteq> tgt \\<and> finite (E `` {src}) \\<Longrightarrow>\n    local.dfs src tgt visited =\n    (if src = tgt then Reachable\n     else let succs = E `` {src}\n          in if finite succs\n             then Finite_Set.fold loop (Visited (insert src visited)) succs\n             else Code.abort STR ''infinite successor relation''\n                   (\\<lambda>_. local.dfs src tgt visited))\n 2. \\<not> (src \\<noteq> tgt \\<and> finite (E `` {src})) \\<Longrightarrow>\n    local.dfs src tgt visited =\n    (if src = tgt then Reachable\n     else let succs = E `` {src}\n          in if finite succs\n             then Finite_Set.fold loop (Visited (insert src visited)) succs\n             else Code.abort STR ''infinite successor relation''\n                   (\\<lambda>_. local.dfs src tgt visited))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (src \\<noteq> tgt \\<and> finite (E `` {src}))\n\ngoal (1 subgoal):\n 1. local.dfs src tgt visited =\n    (if src = tgt then Reachable\n     else let succs = E `` {src}\n          in if finite succs\n             then Finite_Set.fold loop (Visited (insert src visited)) succs\n             else Code.abort STR ''infinite successor relation''\n                   (\\<lambda>_. local.dfs src tgt visited))", "by(auto simp add: dfs_def)"], ["proof (state)\nthis:\n  local.dfs src tgt visited =\n  (if src = tgt then Reachable\n   else let succs = E `` {src}\n        in if finite succs\n           then Finite_Set.fold loop (Visited (insert src visited)) succs\n           else Code.abort STR ''infinite successor relation''\n                 (\\<lambda>_. local.dfs src tgt visited))\n\ngoal (1 subgoal):\n 1. src \\<noteq> tgt \\<and> finite (E `` {src}) \\<Longrightarrow>\n    local.dfs src tgt visited =\n    (if src = tgt then Reachable\n     else let succs = E `` {src}\n          in if finite succs\n             then Finite_Set.fold loop (Visited (insert src visited)) succs\n             else Code.abort STR ''infinite successor relation''\n                   (\\<lambda>_. local.dfs src tgt visited))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. src \\<noteq> tgt \\<and> finite (E `` {src}) \\<Longrightarrow>\n    local.dfs src tgt visited =\n    (if src = tgt then Reachable\n     else let succs = E `` {src}\n          in if finite succs\n             then Finite_Set.fold loop (Visited (insert src visited)) succs\n             else Code.abort STR ''infinite successor relation''\n                   (\\<lambda>_. local.dfs src tgt visited))", "case True"], ["proof (state)\nthis:\n  src \\<noteq> tgt \\<and> finite (E `` {src})\n\ngoal (1 subgoal):\n 1. src \\<noteq> tgt \\<and> finite (E `` {src}) \\<Longrightarrow>\n    local.dfs src tgt visited =\n    (if src = tgt then Reachable\n     else let succs = E `` {src}\n          in if finite succs\n             then Finite_Set.fold loop (Visited (insert src visited)) succs\n             else Code.abort STR ''infinite successor relation''\n                   (\\<lambda>_. local.dfs src tgt visited))", "hence [simp]: \"src \\<noteq> tgt\" \"tgt \\<noteq> src\"\n    and fin: \"finite (E `` {src})\""], ["proof (prove)\nusing this:\n  src \\<noteq> tgt \\<and> finite (E `` {src})\n\ngoal (1 subgoal):\n 1. (src \\<noteq> tgt &&& tgt \\<noteq> src) &&& finite (E `` {src})", "by auto"], ["proof (state)\nthis:\n  src \\<noteq> tgt\n  tgt \\<noteq> src\n  finite (E `` {src})\n\ngoal (1 subgoal):\n 1. src \\<noteq> tgt \\<and> finite (E `` {src}) \\<Longrightarrow>\n    local.dfs src tgt visited =\n    (if src = tgt then Reachable\n     else let succs = E `` {src}\n          in if finite succs\n             then Finite_Set.fold loop (Visited (insert src visited)) succs\n             else Code.abort STR ''infinite successor relation''\n                   (\\<lambda>_. local.dfs src tgt visited))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dfs src tgt visited =\n    (if src = tgt then Reachable\n     else let succs = E `` {src}\n          in if finite succs\n             then Finite_Set.fold loop (Visited (insert src visited)) succs\n             else Code.abort STR ''infinite successor relation''\n                   (\\<lambda>_. local.dfs src tgt visited))", "proof(cases \"(src, tgt) \\<in> (E \\<upharpoonleft> - visited)\\<^sup>*\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (src, tgt)\n    \\<in> (E \\<upharpoonleft> - visited)\\<^sup>* \\<Longrightarrow>\n    local.dfs src tgt visited =\n    (if src = tgt then Reachable\n     else let succs = E `` {src}\n          in if finite succs\n             then Finite_Set.fold loop (Visited (insert src visited)) succs\n             else Code.abort STR ''infinite successor relation''\n                   (\\<lambda>_. local.dfs src tgt visited))\n 2. (src, tgt)\n    \\<notin> (E \\<upharpoonleft> - visited)\\<^sup>* \\<Longrightarrow>\n    local.dfs src tgt visited =\n    (if src = tgt then Reachable\n     else let succs = E `` {src}\n          in if finite succs\n             then Finite_Set.fold loop (Visited (insert src visited)) succs\n             else Code.abort STR ''infinite successor relation''\n                   (\\<lambda>_. local.dfs src tgt visited))", "case True"], ["proof (state)\nthis:\n  (src, tgt) \\<in> (E \\<upharpoonleft> - visited)\\<^sup>*\n\ngoal (2 subgoals):\n 1. (src, tgt)\n    \\<in> (E \\<upharpoonleft> - visited)\\<^sup>* \\<Longrightarrow>\n    local.dfs src tgt visited =\n    (if src = tgt then Reachable\n     else let succs = E `` {src}\n          in if finite succs\n             then Finite_Set.fold loop (Visited (insert src visited)) succs\n             else Code.abort STR ''infinite successor relation''\n                   (\\<lambda>_. local.dfs src tgt visited))\n 2. (src, tgt)\n    \\<notin> (E \\<upharpoonleft> - visited)\\<^sup>* \\<Longrightarrow>\n    local.dfs src tgt visited =\n    (if src = tgt then Reachable\n     else let succs = E `` {src}\n          in if finite succs\n             then Finite_Set.fold loop (Visited (insert src visited)) succs\n             else Code.abort STR ''infinite successor relation''\n                   (\\<lambda>_. local.dfs src tgt visited))", "let ?g = \"\\<lambda>x y. (x, y) \\<in> E \\<upharpoonleft> - visited\""], ["proof (state)\ngoal (2 subgoals):\n 1. (src, tgt)\n    \\<in> (E \\<upharpoonleft> - visited)\\<^sup>* \\<Longrightarrow>\n    local.dfs src tgt visited =\n    (if src = tgt then Reachable\n     else let succs = E `` {src}\n          in if finite succs\n             then Finite_Set.fold loop (Visited (insert src visited)) succs\n             else Code.abort STR ''infinite successor relation''\n                   (\\<lambda>_. local.dfs src tgt visited))\n 2. (src, tgt)\n    \\<notin> (E \\<upharpoonleft> - visited)\\<^sup>* \\<Longrightarrow>\n    local.dfs src tgt visited =\n    (if src = tgt then Reachable\n     else let succs = E `` {src}\n          in if finite succs\n             then Finite_Set.fold loop (Visited (insert src visited)) succs\n             else Code.abort STR ''infinite successor relation''\n                   (\\<lambda>_. local.dfs src tgt visited))", "have \"Finite_Set.fold loop (Visited (insert src visited)) (E `` {src}) = \n      Finite_Set.fold loop (Finite_Set.fold loop (Visited (insert src visited)) (E `` {src} - insert src visited)) (E `` {src} \\<inter> insert src visited)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_Set.fold loop (Visited (insert src visited)) (E `` {src}) =\n    Finite_Set.fold loop\n     (Finite_Set.fold loop (Visited (insert src visited))\n       (E `` {src} - insert src visited))\n     (E `` {src} \\<inter> insert src visited)", "using fin"], ["proof (prove)\nusing this:\n  finite (E `` {src})\n\ngoal (1 subgoal):\n 1. Finite_Set.fold loop (Visited (insert src visited)) (E `` {src}) =\n    Finite_Set.fold loop\n     (Finite_Set.fold loop (Visited (insert src visited))\n       (E `` {src} - insert src visited))\n     (E `` {src} \\<inter> insert src visited)", "by(subst f.fold_set_union_disj[symmetric])(auto intro: arg_cong2[where f=\"Finite_Set.fold loop\"])"], ["proof (state)\nthis:\n  Finite_Set.fold loop (Visited (insert src visited)) (E `` {src}) =\n  Finite_Set.fold loop\n   (Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited))\n   (E `` {src} \\<inter> insert src visited)\n\ngoal (2 subgoals):\n 1. (src, tgt)\n    \\<in> (E \\<upharpoonleft> - visited)\\<^sup>* \\<Longrightarrow>\n    local.dfs src tgt visited =\n    (if src = tgt then Reachable\n     else let succs = E `` {src}\n          in if finite succs\n             then Finite_Set.fold loop (Visited (insert src visited)) succs\n             else Code.abort STR ''infinite successor relation''\n                   (\\<lambda>_. local.dfs src tgt visited))\n 2. (src, tgt)\n    \\<notin> (E \\<upharpoonleft> - visited)\\<^sup>* \\<Longrightarrow>\n    local.dfs src tgt visited =\n    (if src = tgt then Reachable\n     else let succs = E `` {src}\n          in if finite succs\n             then Finite_Set.fold loop (Visited (insert src visited)) succs\n             else Code.abort STR ''infinite successor relation''\n                   (\\<lambda>_. local.dfs src tgt visited))", "also"], ["proof (state)\nthis:\n  Finite_Set.fold loop (Visited (insert src visited)) (E `` {src}) =\n  Finite_Set.fold loop\n   (Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited))\n   (E `` {src} \\<inter> insert src visited)\n\ngoal (2 subgoals):\n 1. (src, tgt)\n    \\<in> (E \\<upharpoonleft> - visited)\\<^sup>* \\<Longrightarrow>\n    local.dfs src tgt visited =\n    (if src = tgt then Reachable\n     else let succs = E `` {src}\n          in if finite succs\n             then Finite_Set.fold loop (Visited (insert src visited)) succs\n             else Code.abort STR ''infinite successor relation''\n                   (\\<lambda>_. local.dfs src tgt visited))\n 2. (src, tgt)\n    \\<notin> (E \\<upharpoonleft> - visited)\\<^sup>* \\<Longrightarrow>\n    local.dfs src tgt visited =\n    (if src = tgt then Reachable\n     else let succs = E `` {src}\n          in if finite succs\n             then Finite_Set.fold loop (Visited (insert src visited)) succs\n             else Code.abort STR ''infinite successor relation''\n                   (\\<lambda>_. local.dfs src tgt visited))", "from True"], ["proof (chain)\npicking this:\n  (src, tgt) \\<in> (E \\<upharpoonleft> - visited)\\<^sup>*", "obtain xs where \"rtrancl_path ?g src xs tgt\" \"distinct (src # xs)\""], ["proof (prove)\nusing this:\n  (src, tgt) \\<in> (E \\<upharpoonleft> - visited)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>rtrancl_path\n                  (\\<lambda>x y. (x, y) \\<in> E \\<upharpoonleft> - visited)\n                  src xs tgt;\n         distinct (src # xs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: rtrancl_def rtranclp_eq_rtrancl_path elim: rtrancl_path_distinct)"], ["proof (state)\nthis:\n  rtrancl_path (\\<lambda>x y. (x, y) \\<in> E \\<upharpoonleft> - visited) src\n   xs tgt\n  distinct (src # xs)\n\ngoal (2 subgoals):\n 1. (src, tgt)\n    \\<in> (E \\<upharpoonleft> - visited)\\<^sup>* \\<Longrightarrow>\n    local.dfs src tgt visited =\n    (if src = tgt then Reachable\n     else let succs = E `` {src}\n          in if finite succs\n             then Finite_Set.fold loop (Visited (insert src visited)) succs\n             else Code.abort STR ''infinite successor relation''\n                   (\\<lambda>_. local.dfs src tgt visited))\n 2. (src, tgt)\n    \\<notin> (E \\<upharpoonleft> - visited)\\<^sup>* \\<Longrightarrow>\n    local.dfs src tgt visited =\n    (if src = tgt then Reachable\n     else let succs = E `` {src}\n          in if finite succs\n             then Finite_Set.fold loop (Visited (insert src visited)) succs\n             else Code.abort STR ''infinite successor relation''\n                   (\\<lambda>_. local.dfs src tgt visited))", "hence \"Finite_Set.fold loop (Visited (insert src visited)) (E `` {src} - insert src visited) = Reachable\""], ["proof (prove)\nusing this:\n  rtrancl_path (\\<lambda>x y. (x, y) \\<in> E \\<upharpoonleft> - visited) src\n   xs tgt\n  distinct (src # xs)\n\ngoal (1 subgoal):\n 1. Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Reachable", "using \\<open>src \\<noteq> tgt\\<close> fin"], ["proof (prove)\nusing this:\n  rtrancl_path (\\<lambda>x y. (x, y) \\<in> E \\<upharpoonleft> - visited) src\n   xs tgt\n  distinct (src # xs)\n  src \\<noteq> tgt\n  finite (E `` {src})\n\ngoal (1 subgoal):\n 1. Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Reachable", "proof(induction src xs z\\<equiv>tgt)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct [tgt]; tgt \\<noteq> tgt; finite (E `` {tgt})\\<rbrakk>\n    \\<Longrightarrow> Finite_Set.fold loop (Visited (insert tgt visited))\n                       (E `` {tgt} - insert tgt visited) =\n                      Reachable\n 2. \\<And>x y ys.\n       \\<lbrakk>(x, y) \\<in> E \\<upharpoonleft> - visited;\n        rtrancl_path\n         (\\<lambda>x y. (x, y) \\<in> E \\<upharpoonleft> - visited) y ys tgt;\n        \\<lbrakk>distinct (y # ys); y \\<noteq> tgt;\n         finite (E `` {y})\\<rbrakk>\n        \\<Longrightarrow> Finite_Set.fold loop (Visited (insert y visited))\n                           (E `` {y} - insert y visited) =\n                          Reachable;\n        distinct (x # y # ys); x \\<noteq> tgt; finite (E `` {x})\\<rbrakk>\n       \\<Longrightarrow> Finite_Set.fold loop (Visited (insert x visited))\n                          (E `` {x} - insert x visited) =\n                         Reachable", "case (step x y xs)"], ["proof (state)\nthis:\n  (x, y) \\<in> E \\<upharpoonleft> - visited\n  rtrancl_path (\\<lambda>x y. (x, y) \\<in> E \\<upharpoonleft> - visited) y\n   xs tgt\n  \\<lbrakk>distinct (y # xs); y \\<noteq> tgt; finite (E `` {y})\\<rbrakk>\n  \\<Longrightarrow> Finite_Set.fold loop (Visited (insert y visited))\n                     (E `` {y} - insert y visited) =\n                    Reachable\n  distinct (x # y # xs)\n  x \\<noteq> tgt\n  finite (E `` {x})\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct [tgt]; tgt \\<noteq> tgt; finite (E `` {tgt})\\<rbrakk>\n    \\<Longrightarrow> Finite_Set.fold loop (Visited (insert tgt visited))\n                       (E `` {tgt} - insert tgt visited) =\n                      Reachable\n 2. \\<And>x y ys.\n       \\<lbrakk>(x, y) \\<in> E \\<upharpoonleft> - visited;\n        rtrancl_path\n         (\\<lambda>x y. (x, y) \\<in> E \\<upharpoonleft> - visited) y ys tgt;\n        \\<lbrakk>distinct (y # ys); y \\<noteq> tgt;\n         finite (E `` {y})\\<rbrakk>\n        \\<Longrightarrow> Finite_Set.fold loop (Visited (insert y visited))\n                           (E `` {y} - insert y visited) =\n                          Reachable;\n        distinct (x # y # ys); x \\<noteq> tgt; finite (E `` {x})\\<rbrakk>\n       \\<Longrightarrow> Finite_Set.fold loop (Visited (insert x visited))\n                          (E `` {x} - insert x visited) =\n                         Reachable", "let ?succs = \"E `` {x} - visited - {y,x}\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct [tgt]; tgt \\<noteq> tgt; finite (E `` {tgt})\\<rbrakk>\n    \\<Longrightarrow> Finite_Set.fold loop (Visited (insert tgt visited))\n                       (E `` {tgt} - insert tgt visited) =\n                      Reachable\n 2. \\<And>x y ys.\n       \\<lbrakk>(x, y) \\<in> E \\<upharpoonleft> - visited;\n        rtrancl_path\n         (\\<lambda>x y. (x, y) \\<in> E \\<upharpoonleft> - visited) y ys tgt;\n        \\<lbrakk>distinct (y # ys); y \\<noteq> tgt;\n         finite (E `` {y})\\<rbrakk>\n        \\<Longrightarrow> Finite_Set.fold loop (Visited (insert y visited))\n                           (E `` {y} - insert y visited) =\n                          Reachable;\n        distinct (x # y # ys); x \\<noteq> tgt; finite (E `` {x})\\<rbrakk>\n       \\<Longrightarrow> Finite_Set.fold loop (Visited (insert x visited))\n                          (E `` {x} - insert x visited) =\n                         Reachable", "have \"Finite_Set.fold loop (Visited (insert x visited)) (insert y ?succs) =\n            Finite_Set.fold loop (loop y (Visited (insert x visited))) ?succs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_Set.fold loop (Visited (insert x visited))\n     (insert y (E `` {x} - visited - {y, x})) =\n    Finite_Set.fold loop (loop y (Visited (insert x visited)))\n     (E `` {x} - visited - {y, x})", "by(rule f.fold_insert2)(simp_all add: \\<open>finite (E `` {x})\\<close>)"], ["proof (state)\nthis:\n  Finite_Set.fold loop (Visited (insert x visited))\n   (insert y (E `` {x} - visited - {y, x})) =\n  Finite_Set.fold loop (loop y (Visited (insert x visited)))\n   (E `` {x} - visited - {y, x})\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct [tgt]; tgt \\<noteq> tgt; finite (E `` {tgt})\\<rbrakk>\n    \\<Longrightarrow> Finite_Set.fold loop (Visited (insert tgt visited))\n                       (E `` {tgt} - insert tgt visited) =\n                      Reachable\n 2. \\<And>x y ys.\n       \\<lbrakk>(x, y) \\<in> E \\<upharpoonleft> - visited;\n        rtrancl_path\n         (\\<lambda>x y. (x, y) \\<in> E \\<upharpoonleft> - visited) y ys tgt;\n        \\<lbrakk>distinct (y # ys); y \\<noteq> tgt;\n         finite (E `` {y})\\<rbrakk>\n        \\<Longrightarrow> Finite_Set.fold loop (Visited (insert y visited))\n                           (E `` {y} - insert y visited) =\n                          Reachable;\n        distinct (x # y # ys); x \\<noteq> tgt; finite (E `` {x})\\<rbrakk>\n       \\<Longrightarrow> Finite_Set.fold loop (Visited (insert x visited))\n                          (E `` {x} - insert x visited) =\n                         Reachable", "also"], ["proof (state)\nthis:\n  Finite_Set.fold loop (Visited (insert x visited))\n   (insert y (E `` {x} - visited - {y, x})) =\n  Finite_Set.fold loop (loop y (Visited (insert x visited)))\n   (E `` {x} - visited - {y, x})\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct [tgt]; tgt \\<noteq> tgt; finite (E `` {tgt})\\<rbrakk>\n    \\<Longrightarrow> Finite_Set.fold loop (Visited (insert tgt visited))\n                       (E `` {tgt} - insert tgt visited) =\n                      Reachable\n 2. \\<And>x y ys.\n       \\<lbrakk>(x, y) \\<in> E \\<upharpoonleft> - visited;\n        rtrancl_path\n         (\\<lambda>x y. (x, y) \\<in> E \\<upharpoonleft> - visited) y ys tgt;\n        \\<lbrakk>distinct (y # ys); y \\<noteq> tgt;\n         finite (E `` {y})\\<rbrakk>\n        \\<Longrightarrow> Finite_Set.fold loop (Visited (insert y visited))\n                           (E `` {y} - insert y visited) =\n                          Reachable;\n        distinct (x # y # ys); x \\<noteq> tgt; finite (E `` {x})\\<rbrakk>\n       \\<Longrightarrow> Finite_Set.fold loop (Visited (insert x visited))\n                          (E `` {x} - insert x visited) =\n                         Reachable", "from \\<open>distinct (x # y # xs)\\<close>"], ["proof (chain)\npicking this:\n  distinct (x # y # xs)", "have \"x \\<notin> set (y # xs)\""], ["proof (prove)\nusing this:\n  distinct (x # y # xs)\n\ngoal (1 subgoal):\n 1. x \\<notin> set (y # xs)", "by simp"], ["proof (state)\nthis:\n  x \\<notin> set (y # xs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct [tgt]; tgt \\<noteq> tgt; finite (E `` {tgt})\\<rbrakk>\n    \\<Longrightarrow> Finite_Set.fold loop (Visited (insert tgt visited))\n                       (E `` {tgt} - insert tgt visited) =\n                      Reachable\n 2. \\<And>x y ys.\n       \\<lbrakk>(x, y) \\<in> E \\<upharpoonleft> - visited;\n        rtrancl_path\n         (\\<lambda>x y. (x, y) \\<in> E \\<upharpoonleft> - visited) y ys tgt;\n        \\<lbrakk>distinct (y # ys); y \\<noteq> tgt;\n         finite (E `` {y})\\<rbrakk>\n        \\<Longrightarrow> Finite_Set.fold loop (Visited (insert y visited))\n                           (E `` {y} - insert y visited) =\n                          Reachable;\n        distinct (x # y # ys); x \\<noteq> tgt; finite (E `` {x})\\<rbrakk>\n       \\<Longrightarrow> Finite_Set.fold loop (Visited (insert x visited))\n                          (E `` {x} - insert x visited) =\n                         Reachable", "with \\<open>rtrancl_path ?g y xs tgt\\<close>"], ["proof (chain)\npicking this:\n  rtrancl_path (\\<lambda>x y. (x, y) \\<in> E \\<upharpoonleft> - visited) y\n   xs tgt\n  x \\<notin> set (y # xs)", "have \"(y, tgt) \\<in> (E \\<upharpoonleft> - insert x visited)\\<^sup>*\""], ["proof (prove)\nusing this:\n  rtrancl_path (\\<lambda>x y. (x, y) \\<in> E \\<upharpoonleft> - visited) y\n   xs tgt\n  x \\<notin> set (y # xs)\n\ngoal (1 subgoal):\n 1. (y, tgt) \\<in> (E \\<upharpoonleft> - insert x visited)\\<^sup>*", "by induction(auto intro: converse_rtrancl_into_rtrancl)"], ["proof (state)\nthis:\n  (y, tgt) \\<in> (E \\<upharpoonleft> - insert x visited)\\<^sup>*\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct [tgt]; tgt \\<noteq> tgt; finite (E `` {tgt})\\<rbrakk>\n    \\<Longrightarrow> Finite_Set.fold loop (Visited (insert tgt visited))\n                       (E `` {tgt} - insert tgt visited) =\n                      Reachable\n 2. \\<And>x y ys.\n       \\<lbrakk>(x, y) \\<in> E \\<upharpoonleft> - visited;\n        rtrancl_path\n         (\\<lambda>x y. (x, y) \\<in> E \\<upharpoonleft> - visited) y ys tgt;\n        \\<lbrakk>distinct (y # ys); y \\<noteq> tgt;\n         finite (E `` {y})\\<rbrakk>\n        \\<Longrightarrow> Finite_Set.fold loop (Visited (insert y visited))\n                           (E `` {y} - insert y visited) =\n                          Reachable;\n        distinct (x # y # ys); x \\<noteq> tgt; finite (E `` {x})\\<rbrakk>\n       \\<Longrightarrow> Finite_Set.fold loop (Visited (insert x visited))\n                          (E `` {x} - insert x visited) =\n                         Reachable", "with \\<open>(x, y) \\<in> E \\<upharpoonleft> - visited\\<close>"], ["proof (chain)\npicking this:\n  (x, y) \\<in> E \\<upharpoonleft> - visited\n  (y, tgt) \\<in> (E \\<upharpoonleft> - insert x visited)\\<^sup>*", "have \"loop y (Visited (insert x visited)) = Reachable\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> E \\<upharpoonleft> - visited\n  (y, tgt) \\<in> (E \\<upharpoonleft> - insert x visited)\\<^sup>*\n\ngoal (1 subgoal):\n 1. loop y (Visited (insert x visited)) = Reachable", "using \\<open>x \\<notin> set (y # xs)\\<close>"], ["proof (prove)\nusing this:\n  (x, y) \\<in> E \\<upharpoonleft> - visited\n  (y, tgt) \\<in> (E \\<upharpoonleft> - insert x visited)\\<^sup>*\n  x \\<notin> set (y # xs)\n\ngoal (1 subgoal):\n 1. loop y (Visited (insert x visited)) = Reachable", "by(auto simp add: dfs_def)"], ["proof (state)\nthis:\n  loop y (Visited (insert x visited)) = Reachable\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct [tgt]; tgt \\<noteq> tgt; finite (E `` {tgt})\\<rbrakk>\n    \\<Longrightarrow> Finite_Set.fold loop (Visited (insert tgt visited))\n                       (E `` {tgt} - insert tgt visited) =\n                      Reachable\n 2. \\<And>x y ys.\n       \\<lbrakk>(x, y) \\<in> E \\<upharpoonleft> - visited;\n        rtrancl_path\n         (\\<lambda>x y. (x, y) \\<in> E \\<upharpoonleft> - visited) y ys tgt;\n        \\<lbrakk>distinct (y # ys); y \\<noteq> tgt;\n         finite (E `` {y})\\<rbrakk>\n        \\<Longrightarrow> Finite_Set.fold loop (Visited (insert y visited))\n                           (E `` {y} - insert y visited) =\n                          Reachable;\n        distinct (x # y # ys); x \\<noteq> tgt; finite (E `` {x})\\<rbrakk>\n       \\<Longrightarrow> Finite_Set.fold loop (Visited (insert x visited))\n                          (E `` {x} - insert x visited) =\n                         Reachable", "also"], ["proof (state)\nthis:\n  loop y (Visited (insert x visited)) = Reachable\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct [tgt]; tgt \\<noteq> tgt; finite (E `` {tgt})\\<rbrakk>\n    \\<Longrightarrow> Finite_Set.fold loop (Visited (insert tgt visited))\n                       (E `` {tgt} - insert tgt visited) =\n                      Reachable\n 2. \\<And>x y ys.\n       \\<lbrakk>(x, y) \\<in> E \\<upharpoonleft> - visited;\n        rtrancl_path\n         (\\<lambda>x y. (x, y) \\<in> E \\<upharpoonleft> - visited) y ys tgt;\n        \\<lbrakk>distinct (y # ys); y \\<noteq> tgt;\n         finite (E `` {y})\\<rbrakk>\n        \\<Longrightarrow> Finite_Set.fold loop (Visited (insert y visited))\n                           (E `` {y} - insert y visited) =\n                          Reachable;\n        distinct (x # y # ys); x \\<noteq> tgt; finite (E `` {x})\\<rbrakk>\n       \\<Longrightarrow> Finite_Set.fold loop (Visited (insert x visited))\n                          (E `` {x} - insert x visited) =\n                         Reachable", "from \\<open>(x, y) \\<in> E \\<upharpoonleft> - visited\\<close>"], ["proof (chain)\npicking this:\n  (x, y) \\<in> E \\<upharpoonleft> - visited", "have \"insert y ?succs = E `` {x} - insert x visited\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> E \\<upharpoonleft> - visited\n\ngoal (1 subgoal):\n 1. insert y (E `` {x} - visited - {y, x}) = E `` {x} - insert x visited", "using \\<open>distinct (x # y # xs)\\<close>"], ["proof (prove)\nusing this:\n  (x, y) \\<in> E \\<upharpoonleft> - visited\n  distinct (x # y # xs)\n\ngoal (1 subgoal):\n 1. insert y (E `` {x} - visited - {y, x}) = E `` {x} - insert x visited", "by auto"], ["proof (state)\nthis:\n  insert y (E `` {x} - visited - {y, x}) = E `` {x} - insert x visited\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct [tgt]; tgt \\<noteq> tgt; finite (E `` {tgt})\\<rbrakk>\n    \\<Longrightarrow> Finite_Set.fold loop (Visited (insert tgt visited))\n                       (E `` {tgt} - insert tgt visited) =\n                      Reachable\n 2. \\<And>x y ys.\n       \\<lbrakk>(x, y) \\<in> E \\<upharpoonleft> - visited;\n        rtrancl_path\n         (\\<lambda>x y. (x, y) \\<in> E \\<upharpoonleft> - visited) y ys tgt;\n        \\<lbrakk>distinct (y # ys); y \\<noteq> tgt;\n         finite (E `` {y})\\<rbrakk>\n        \\<Longrightarrow> Finite_Set.fold loop (Visited (insert y visited))\n                           (E `` {y} - insert y visited) =\n                          Reachable;\n        distinct (x # y # ys); x \\<noteq> tgt; finite (E `` {x})\\<rbrakk>\n       \\<Longrightarrow> Finite_Set.fold loop (Visited (insert x visited))\n                          (E `` {x} - insert x visited) =\n                         Reachable", "finally"], ["proof (chain)\npicking this:\n  Finite_Set.fold loop (Visited (insert x visited))\n   (E `` {x} - insert x visited) =\n  Finite_Set.fold loop Reachable (E `` {x} - visited - {y, x})", "show ?case"], ["proof (prove)\nusing this:\n  Finite_Set.fold loop (Visited (insert x visited))\n   (E `` {x} - insert x visited) =\n  Finite_Set.fold loop Reachable (E `` {x} - visited - {y, x})\n\ngoal (1 subgoal):\n 1. Finite_Set.fold loop (Visited (insert x visited))\n     (E `` {x} - insert x visited) =\n    Reachable", "by simp"], ["proof (state)\nthis:\n  Finite_Set.fold loop (Visited (insert x visited))\n   (E `` {x} - insert x visited) =\n  Reachable\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct [tgt]; tgt \\<noteq> tgt; finite (E `` {tgt})\\<rbrakk>\n    \\<Longrightarrow> Finite_Set.fold loop (Visited (insert tgt visited))\n                       (E `` {tgt} - insert tgt visited) =\n                      Reachable", "qed simp"], ["proof (state)\nthis:\n  Finite_Set.fold loop (Visited (insert src visited))\n   (E `` {src} - insert src visited) =\n  Reachable\n\ngoal (2 subgoals):\n 1. (src, tgt)\n    \\<in> (E \\<upharpoonleft> - visited)\\<^sup>* \\<Longrightarrow>\n    local.dfs src tgt visited =\n    (if src = tgt then Reachable\n     else let succs = E `` {src}\n          in if finite succs\n             then Finite_Set.fold loop (Visited (insert src visited)) succs\n             else Code.abort STR ''infinite successor relation''\n                   (\\<lambda>_. local.dfs src tgt visited))\n 2. (src, tgt)\n    \\<notin> (E \\<upharpoonleft> - visited)\\<^sup>* \\<Longrightarrow>\n    local.dfs src tgt visited =\n    (if src = tgt then Reachable\n     else let succs = E `` {src}\n          in if finite succs\n             then Finite_Set.fold loop (Visited (insert src visited)) succs\n             else Code.abort STR ''infinite successor relation''\n                   (\\<lambda>_. local.dfs src tgt visited))", "finally"], ["proof (chain)\npicking this:\n  Finite_Set.fold loop (Visited (insert src visited)) (E `` {src}) =\n  Finite_Set.fold loop Reachable (E `` {src} \\<inter> insert src visited)", "show ?thesis"], ["proof (prove)\nusing this:\n  Finite_Set.fold loop (Visited (insert src visited)) (E `` {src}) =\n  Finite_Set.fold loop Reachable (E `` {src} \\<inter> insert src visited)\n\ngoal (1 subgoal):\n 1. local.dfs src tgt visited =\n    (if src = tgt then Reachable\n     else let succs = E `` {src}\n          in if finite succs\n             then Finite_Set.fold loop (Visited (insert src visited)) succs\n             else Code.abort STR ''infinite successor relation''\n                   (\\<lambda>_. local.dfs src tgt visited))", "using True"], ["proof (prove)\nusing this:\n  Finite_Set.fold loop (Visited (insert src visited)) (E `` {src}) =\n  Finite_Set.fold loop Reachable (E `` {src} \\<inter> insert src visited)\n  (src, tgt) \\<in> (E \\<upharpoonleft> - visited)\\<^sup>*\n\ngoal (1 subgoal):\n 1. local.dfs src tgt visited =\n    (if src = tgt then Reachable\n     else let succs = E `` {src}\n          in if finite succs\n             then Finite_Set.fold loop (Visited (insert src visited)) succs\n             else Code.abort STR ''infinite successor relation''\n                   (\\<lambda>_. local.dfs src tgt visited))", "by(simp add: dfs_def Let_def)"], ["proof (state)\nthis:\n  local.dfs src tgt visited =\n  (if src = tgt then Reachable\n   else let succs = E `` {src}\n        in if finite succs\n           then Finite_Set.fold loop (Visited (insert src visited)) succs\n           else Code.abort STR ''infinite successor relation''\n                 (\\<lambda>_. local.dfs src tgt visited))\n\ngoal (1 subgoal):\n 1. (src, tgt)\n    \\<notin> (E \\<upharpoonleft> - visited)\\<^sup>* \\<Longrightarrow>\n    local.dfs src tgt visited =\n    (if src = tgt then Reachable\n     else let succs = E `` {src}\n          in if finite succs\n             then Finite_Set.fold loop (Visited (insert src visited)) succs\n             else Code.abort STR ''infinite successor relation''\n                   (\\<lambda>_. local.dfs src tgt visited))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (src, tgt)\n    \\<notin> (E \\<upharpoonleft> - visited)\\<^sup>* \\<Longrightarrow>\n    local.dfs src tgt visited =\n    (if src = tgt then Reachable\n     else let succs = E `` {src}\n          in if finite succs\n             then Finite_Set.fold loop (Visited (insert src visited)) succs\n             else Code.abort STR ''infinite successor relation''\n                   (\\<lambda>_. local.dfs src tgt visited))", "case False"], ["proof (state)\nthis:\n  (src, tgt) \\<notin> (E \\<upharpoonleft> - visited)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (src, tgt)\n    \\<notin> (E \\<upharpoonleft> - visited)\\<^sup>* \\<Longrightarrow>\n    local.dfs src tgt visited =\n    (if src = tgt then Reachable\n     else let succs = E `` {src}\n          in if finite succs\n             then Finite_Set.fold loop (Visited (insert src visited)) succs\n             else Code.abort STR ''infinite successor relation''\n                   (\\<lambda>_. local.dfs src tgt visited))", "have \"Finite_Set.fold loop (Visited (insert src visited)) (E `` {src}) = \n      Finite_Set.fold loop (Finite_Set.fold loop (Visited (insert src visited)) (E `` {src} - insert src visited)) (E `` {src} \\<inter> insert src visited)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_Set.fold loop (Visited (insert src visited)) (E `` {src}) =\n    Finite_Set.fold loop\n     (Finite_Set.fold loop (Visited (insert src visited))\n       (E `` {src} - insert src visited))\n     (E `` {src} \\<inter> insert src visited)", "using fin"], ["proof (prove)\nusing this:\n  finite (E `` {src})\n\ngoal (1 subgoal):\n 1. Finite_Set.fold loop (Visited (insert src visited)) (E `` {src}) =\n    Finite_Set.fold loop\n     (Finite_Set.fold loop (Visited (insert src visited))\n       (E `` {src} - insert src visited))\n     (E `` {src} \\<inter> insert src visited)", "by(subst f.fold_set_union_disj[symmetric])(auto intro: arg_cong2[where f=\"Finite_Set.fold loop\"])"], ["proof (state)\nthis:\n  Finite_Set.fold loop (Visited (insert src visited)) (E `` {src}) =\n  Finite_Set.fold loop\n   (Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited))\n   (E `` {src} \\<inter> insert src visited)\n\ngoal (1 subgoal):\n 1. (src, tgt)\n    \\<notin> (E \\<upharpoonleft> - visited)\\<^sup>* \\<Longrightarrow>\n    local.dfs src tgt visited =\n    (if src = tgt then Reachable\n     else let succs = E `` {src}\n          in if finite succs\n             then Finite_Set.fold loop (Visited (insert src visited)) succs\n             else Code.abort STR ''infinite successor relation''\n                   (\\<lambda>_. local.dfs src tgt visited))", "also"], ["proof (state)\nthis:\n  Finite_Set.fold loop (Visited (insert src visited)) (E `` {src}) =\n  Finite_Set.fold loop\n   (Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited))\n   (E `` {src} \\<inter> insert src visited)\n\ngoal (1 subgoal):\n 1. (src, tgt)\n    \\<notin> (E \\<upharpoonleft> - visited)\\<^sup>* \\<Longrightarrow>\n    local.dfs src tgt visited =\n    (if src = tgt then Reachable\n     else let succs = E `` {src}\n          in if finite succs\n             then Finite_Set.fold loop (Visited (insert src visited)) succs\n             else Code.abort STR ''infinite successor relation''\n                   (\\<lambda>_. local.dfs src tgt visited))", "from fin"], ["proof (chain)\npicking this:\n  finite (E `` {src})", "have \"finite (E `` {src} - visited)\""], ["proof (prove)\nusing this:\n  finite (E `` {src})\n\ngoal (1 subgoal):\n 1. finite (E `` {src} - visited)", "by simp"], ["proof (state)\nthis:\n  finite (E `` {src} - visited)\n\ngoal (1 subgoal):\n 1. (src, tgt)\n    \\<notin> (E \\<upharpoonleft> - visited)\\<^sup>* \\<Longrightarrow>\n    local.dfs src tgt visited =\n    (if src = tgt then Reachable\n     else let succs = E `` {src}\n          in if finite succs\n             then Finite_Set.fold loop (Visited (insert src visited)) succs\n             else Code.abort STR ''infinite successor relation''\n                   (\\<lambda>_. local.dfs src tgt visited))", "then"], ["proof (chain)\npicking this:\n  finite (E `` {src} - visited)", "have \"Finite_Set.fold loop (Visited (insert src visited)) (E `` {src} - insert src visited) = Visited (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})\""], ["proof (prove)\nusing this:\n  finite (E `` {src} - visited)\n\ngoal (1 subgoal):\n 1. Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "using False"], ["proof (prove)\nusing this:\n  finite (E `` {src} - visited)\n  (src, tgt) \\<notin> (E \\<upharpoonleft> - visited)\\<^sup>*\n\ngoal (1 subgoal):\n 1. Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "proof(induct A\\<equiv>\"E `` {src} - visited\" arbitrary: visited rule: finite_psubset_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>visited.\n       \\<lbrakk>finite (E `` {src} - visited);\n        \\<And>visiteda.\n           \\<lbrakk>E `` {src} - visiteda \\<subset> E `` {src} - visited;\n            (src, tgt)\n            \\<notin> (E \\<upharpoonleft> - visiteda)\\<^sup>*\\<rbrakk>\n           \\<Longrightarrow> Finite_Set.fold loop\n                              (Visited (insert src visiteda))\n                              (E `` {src} - insert src visiteda) =\n                             Visited\n                              (visiteda \\<union>\n                               (E \\<upharpoonleft> - visiteda)\\<^sup>* ``\n                               {src});\n        (src, tgt) \\<notin> (E \\<upharpoonleft> - visited)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> Finite_Set.fold loop (Visited (insert src visited))\n                          (E `` {src} - insert src visited) =\n                         Visited\n                          (visited \\<union>\n                           (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "case psubset"], ["proof (state)\nthis:\n  finite (E `` {src} - visited)\n  \\<lbrakk>E `` {src} - ?visited \\<subset> E `` {src} - visited;\n   (src, tgt) \\<notin> (E \\<upharpoonleft> - ?visited)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> Finite_Set.fold loop (Visited (insert src ?visited))\n                     (E `` {src} - insert src ?visited) =\n                    Visited\n                     (?visited \\<union>\n                      (E \\<upharpoonleft> - ?visited)\\<^sup>* `` {src})\n  (src, tgt) \\<notin> (E \\<upharpoonleft> - visited)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>visited.\n       \\<lbrakk>finite (E `` {src} - visited);\n        \\<And>visiteda.\n           \\<lbrakk>E `` {src} - visiteda \\<subset> E `` {src} - visited;\n            (src, tgt)\n            \\<notin> (E \\<upharpoonleft> - visiteda)\\<^sup>*\\<rbrakk>\n           \\<Longrightarrow> Finite_Set.fold loop\n                              (Visited (insert src visiteda))\n                              (E `` {src} - insert src visiteda) =\n                             Visited\n                              (visiteda \\<union>\n                               (E \\<upharpoonleft> - visiteda)\\<^sup>* ``\n                               {src});\n        (src, tgt) \\<notin> (E \\<upharpoonleft> - visited)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> Finite_Set.fold loop (Visited (insert src visited))\n                          (E `` {src} - insert src visited) =\n                         Visited\n                          (visited \\<union>\n                           (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "note fin = \\<open>finite (E `` {src})\\<close>"], ["proof (state)\nthis:\n  finite (E `` {src})\n\ngoal (1 subgoal):\n 1. \\<And>visited.\n       \\<lbrakk>finite (E `` {src} - visited);\n        \\<And>visiteda.\n           \\<lbrakk>E `` {src} - visiteda \\<subset> E `` {src} - visited;\n            (src, tgt)\n            \\<notin> (E \\<upharpoonleft> - visiteda)\\<^sup>*\\<rbrakk>\n           \\<Longrightarrow> Finite_Set.fold loop\n                              (Visited (insert src visiteda))\n                              (E `` {src} - insert src visiteda) =\n                             Visited\n                              (visiteda \\<union>\n                               (E \\<upharpoonleft> - visiteda)\\<^sup>* ``\n                               {src});\n        (src, tgt) \\<notin> (E \\<upharpoonleft> - visited)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> Finite_Set.fold loop (Visited (insert src visited))\n                          (E `` {src} - insert src visited) =\n                         Visited\n                          (visited \\<union>\n                           (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "note src_tgt = \\<open>(src, tgt) \\<notin> (E \\<upharpoonleft> - visited)\\<^sup>*\\<close>"], ["proof (state)\nthis:\n  (src, tgt) \\<notin> (E \\<upharpoonleft> - visited)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>visited.\n       \\<lbrakk>finite (E `` {src} - visited);\n        \\<And>visiteda.\n           \\<lbrakk>E `` {src} - visiteda \\<subset> E `` {src} - visited;\n            (src, tgt)\n            \\<notin> (E \\<upharpoonleft> - visiteda)\\<^sup>*\\<rbrakk>\n           \\<Longrightarrow> Finite_Set.fold loop\n                              (Visited (insert src visiteda))\n                              (E `` {src} - insert src visiteda) =\n                             Visited\n                              (visiteda \\<union>\n                               (E \\<upharpoonleft> - visiteda)\\<^sup>* ``\n                               {src});\n        (src, tgt) \\<notin> (E \\<upharpoonleft> - visited)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> Finite_Set.fold loop (Visited (insert src visited))\n                          (E `` {src} - insert src visited) =\n                         Visited\n                          (visited \\<union>\n                           (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "proof (cases \"E `` {src} - insert src visited = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. E `` {src} - insert src visited = {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})\n 2. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "case True"], ["proof (state)\nthis:\n  E `` {src} - insert src visited = {}\n\ngoal (2 subgoals):\n 1. E `` {src} - insert src visited = {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})\n 2. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "{"], ["proof (state)\nthis:\n  E `` {src} - insert src visited = {}\n\ngoal (2 subgoals):\n 1. E `` {src} - insert src visited = {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})\n 2. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "let ?g = \"\\<lambda>x y. (x, y) \\<in> E \\<upharpoonleft> - visited\""], ["proof (state)\ngoal (2 subgoals):\n 1. E `` {src} - insert src visited = {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})\n 2. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. E `` {src} - insert src visited = {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})\n 2. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "assume \"(src, x) \\<in> (E \\<upharpoonleft> - visited)\\<^sup>*\""], ["proof (state)\nthis:\n  (src, x) \\<in> (E \\<upharpoonleft> - visited)\\<^sup>*\n\ngoal (2 subgoals):\n 1. E `` {src} - insert src visited = {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})\n 2. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "then"], ["proof (chain)\npicking this:\n  (src, x) \\<in> (E \\<upharpoonleft> - visited)\\<^sup>*", "obtain xs where \"rtrancl_path ?g src xs x\" \"distinct (src # xs)\""], ["proof (prove)\nusing this:\n  (src, x) \\<in> (E \\<upharpoonleft> - visited)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>rtrancl_path\n                  (\\<lambda>x y. (x, y) \\<in> E \\<upharpoonleft> - visited)\n                  src xs x;\n         distinct (src # xs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: rtrancl_def rtranclp_eq_rtrancl_path elim: rtrancl_path_distinct)"], ["proof (state)\nthis:\n  rtrancl_path (\\<lambda>x y. (x, y) \\<in> E \\<upharpoonleft> - visited) src\n   xs x\n  distinct (src # xs)\n\ngoal (2 subgoals):\n 1. E `` {src} - insert src visited = {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})\n 2. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "hence \"src = x\""], ["proof (prove)\nusing this:\n  rtrancl_path (\\<lambda>x y. (x, y) \\<in> E \\<upharpoonleft> - visited) src\n   xs x\n  distinct (src # xs)\n\ngoal (1 subgoal):\n 1. src = x", "using True"], ["proof (prove)\nusing this:\n  rtrancl_path (\\<lambda>x y. (x, y) \\<in> E \\<upharpoonleft> - visited) src\n   xs x\n  distinct (src # xs)\n  E `` {src} - insert src visited = {}\n\ngoal (1 subgoal):\n 1. src = x", "by induction auto"], ["proof (state)\nthis:\n  src = x\n\ngoal (2 subgoals):\n 1. E `` {src} - insert src visited = {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})\n 2. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "}"], ["proof (state)\nthis:\n  (src, ?x2) \\<in> (E \\<upharpoonleft> - visited)\\<^sup>* \\<Longrightarrow>\n  src = ?x2\n\ngoal (2 subgoals):\n 1. E `` {src} - insert src visited = {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})\n 2. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "then"], ["proof (chain)\npicking this:\n  (src, ?x2) \\<in> (E \\<upharpoonleft> - visited)\\<^sup>* \\<Longrightarrow>\n  src = ?x2", "show ?thesis"], ["proof (prove)\nusing this:\n  (src, ?x2) \\<in> (E \\<upharpoonleft> - visited)\\<^sup>* \\<Longrightarrow>\n  src = ?x2\n\ngoal (1 subgoal):\n 1. Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "unfolding True"], ["proof (prove)\nusing this:\n  (src, ?x2) \\<in> (E \\<upharpoonleft> - visited)\\<^sup>* \\<Longrightarrow>\n  src = ?x2\n\ngoal (1 subgoal):\n 1. Finite_Set.fold loop (Visited (insert src visited)) {} =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "using True"], ["proof (prove)\nusing this:\n  (src, ?x2) \\<in> (E \\<upharpoonleft> - visited)\\<^sup>* \\<Longrightarrow>\n  src = ?x2\n  E `` {src} - insert src visited = {}\n\ngoal (1 subgoal):\n 1. Finite_Set.fold loop (Visited (insert src visited)) {} =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "by(auto elim: converse_rtranclE)"], ["proof (state)\nthis:\n  Finite_Set.fold loop (Visited (insert src visited))\n   (E `` {src} - insert src visited) =\n  Visited (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})\n\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "case False"], ["proof (state)\nthis:\n  E `` {src} - insert src visited \\<noteq> {}\n\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "then"], ["proof (chain)\npicking this:\n  E `` {src} - insert src visited \\<noteq> {}", "obtain y where y: \"y \\<in> E `` {src}\" \"y \\<notin> visited\" \"y \\<noteq> src\""], ["proof (prove)\nusing this:\n  E `` {src} - insert src visited \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> E `` {src}; y \\<notin> visited;\n         y \\<noteq> src\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y \\<in> E `` {src}\n  y \\<notin> visited\n  y \\<noteq> src\n\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "let ?succs = \"E `` {src} - insert src visited - {y}\""], ["proof (state)\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "let ?visited = \"insert src visited\""], ["proof (state)\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "let ?visited' = \"?visited \\<union> (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}\""], ["proof (state)\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "have \"Finite_Set.fold loop (Visited ?visited) (insert y ?succs) =\n              Finite_Set.fold loop (loop y (Visited ?visited)) ?succs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_Set.fold loop (Visited (insert src visited))\n     (insert y (E `` {src} - insert src visited - {y})) =\n    Finite_Set.fold loop (loop y (Visited (insert src visited)))\n     (E `` {src} - insert src visited - {y})", "by(rule f.fold_insert2)(simp_all add: fin)"], ["proof (state)\nthis:\n  Finite_Set.fold loop (Visited (insert src visited))\n   (insert y (E `` {src} - insert src visited - {y})) =\n  Finite_Set.fold loop (loop y (Visited (insert src visited)))\n   (E `` {src} - insert src visited - {y})\n\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "also"], ["proof (state)\nthis:\n  Finite_Set.fold loop (Visited (insert src visited))\n   (insert y (E `` {src} - insert src visited - {y})) =\n  Finite_Set.fold loop (loop y (Visited (insert src visited)))\n   (E `` {src} - insert src visited - {y})\n\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "have y_tgt: \"(y, tgt) \\<notin> (E \\<upharpoonleft> - ?visited)\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y, tgt) \\<notin> (E \\<upharpoonleft> - insert src visited)\\<^sup>*", "using y src_tgt"], ["proof (prove)\nusing this:\n  y \\<in> E `` {src}\n  y \\<notin> visited\n  y \\<noteq> src\n  (src, tgt) \\<notin> (E \\<upharpoonleft> - visited)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (y, tgt) \\<notin> (E \\<upharpoonleft> - insert src visited)\\<^sup>*", "by(auto intro: converse_rtrancl_into_rtrancl rtrancl_mono[THEN subsetD, rotated])"], ["proof (state)\nthis:\n  (y, tgt) \\<notin> (E \\<upharpoonleft> - insert src visited)\\<^sup>*\n\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "hence \"loop y (Visited (insert src visited)) = Visited ?visited'\""], ["proof (prove)\nusing this:\n  (y, tgt) \\<notin> (E \\<upharpoonleft> - insert src visited)\\<^sup>*\n\ngoal (1 subgoal):\n 1. loop y (Visited (insert src visited)) =\n    Visited\n     (insert src visited \\<union>\n      (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y})", "using y"], ["proof (prove)\nusing this:\n  (y, tgt) \\<notin> (E \\<upharpoonleft> - insert src visited)\\<^sup>*\n  y \\<in> E `` {src}\n  y \\<notin> visited\n  y \\<noteq> src\n\ngoal (1 subgoal):\n 1. loop y (Visited (insert src visited)) =\n    Visited\n     (insert src visited \\<union>\n      (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y})", "by(auto simp add: dfs_def)"], ["proof (state)\nthis:\n  loop y (Visited (insert src visited)) =\n  Visited\n   (insert src visited \\<union>\n    (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y})\n\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "also"], ["proof (state)\nthis:\n  loop y (Visited (insert src visited)) =\n  Visited\n   (insert src visited \\<union>\n    (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y})\n\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "define A where \"A \\<equiv> ?succs \\<inter> (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}\""], ["proof (state)\nthis:\n  A \\<equiv>\n  (E `` {src} - insert src visited - {y}) \\<inter>\n  (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}\n\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "have \"?succs = A \\<union> (E `` {src} - insert src ?visited')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited - {y} =\n    A \\<union>\n    (E `` {src} -\n     insert src\n      (insert src visited \\<union>\n       (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}))", "unfolding A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited - {y} =\n    (E `` {src} - insert src visited - {y}) \\<inter>\n    (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y} \\<union>\n    (E `` {src} -\n     insert src\n      (insert src visited \\<union>\n       (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}))", "using y"], ["proof (prove)\nusing this:\n  y \\<in> E `` {src}\n  y \\<notin> visited\n  y \\<noteq> src\n\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited - {y} =\n    (E `` {src} - insert src visited - {y}) \\<inter>\n    (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y} \\<union>\n    (E `` {src} -\n     insert src\n      (insert src visited \\<union>\n       (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}))", "by auto"], ["proof (state)\nthis:\n  E `` {src} - insert src visited - {y} =\n  A \\<union>\n  (E `` {src} -\n   insert src\n    (insert src visited \\<union>\n     (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}))\n\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "hence \"Finite_Set.fold loop (Visited ?visited') ?succs =\n               Finite_Set.fold loop (Visited ?visited') \\<dots>\""], ["proof (prove)\nusing this:\n  E `` {src} - insert src visited - {y} =\n  A \\<union>\n  (E `` {src} -\n   insert src\n    (insert src visited \\<union>\n     (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}))\n\ngoal (1 subgoal):\n 1. Finite_Set.fold loop\n     (Visited\n       (insert src visited \\<union>\n        (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}))\n     (E `` {src} - insert src visited - {y}) =\n    Finite_Set.fold loop\n     (Visited\n       (insert src visited \\<union>\n        (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}))\n     (A \\<union>\n      (E `` {src} -\n       insert src\n        (insert src visited \\<union>\n         (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y})))", "by simp"], ["proof (state)\nthis:\n  Finite_Set.fold loop\n   (Visited\n     (insert src visited \\<union>\n      (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}))\n   (E `` {src} - insert src visited - {y}) =\n  Finite_Set.fold loop\n   (Visited\n     (insert src visited \\<union>\n      (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}))\n   (A \\<union>\n    (E `` {src} -\n     insert src\n      (insert src visited \\<union>\n       (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y})))\n\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "also"], ["proof (state)\nthis:\n  Finite_Set.fold loop\n   (Visited\n     (insert src visited \\<union>\n      (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}))\n   (E `` {src} - insert src visited - {y}) =\n  Finite_Set.fold loop\n   (Visited\n     (insert src visited \\<union>\n      (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}))\n   (A \\<union>\n    (E `` {src} -\n     insert src\n      (insert src visited \\<union>\n       (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y})))\n\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "have \"\\<dots> = Finite_Set.fold loop (Finite_Set.fold loop (Visited ?visited') A) (E `` {src} - insert src ?visited')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_Set.fold loop\n     (Visited\n       (insert src visited \\<union>\n        (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}))\n     (A \\<union>\n      (E `` {src} -\n       insert src\n        (insert src visited \\<union>\n         (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}))) =\n    Finite_Set.fold loop\n     (Finite_Set.fold loop\n       (Visited\n         (insert src visited \\<union>\n          (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}))\n       A)\n     (E `` {src} -\n      insert src\n       (insert src visited \\<union>\n        (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}))", "by(rule f.fold_set_union_disj)(auto simp add: A_def intro: finite_subset[OF _ fin])"], ["proof (state)\nthis:\n  Finite_Set.fold loop\n   (Visited\n     (insert src visited \\<union>\n      (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}))\n   (A \\<union>\n    (E `` {src} -\n     insert src\n      (insert src visited \\<union>\n       (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}))) =\n  Finite_Set.fold loop\n   (Finite_Set.fold loop\n     (Visited\n       (insert src visited \\<union>\n        (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}))\n     A)\n   (E `` {src} -\n    insert src\n     (insert src visited \\<union>\n      (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}))\n\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "also"], ["proof (state)\nthis:\n  Finite_Set.fold loop\n   (Visited\n     (insert src visited \\<union>\n      (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}))\n   (A \\<union>\n    (E `` {src} -\n     insert src\n      (insert src visited \\<union>\n       (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}))) =\n  Finite_Set.fold loop\n   (Finite_Set.fold loop\n     (Visited\n       (insert src visited \\<union>\n        (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}))\n     A)\n   (E `` {src} -\n    insert src\n     (insert src visited \\<union>\n      (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}))\n\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "{"], ["proof (state)\nthis:\n  Finite_Set.fold loop\n   (Visited\n     (insert src visited \\<union>\n      (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}))\n   (A \\<union>\n    (E `` {src} -\n     insert src\n      (insert src visited \\<union>\n       (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}))) =\n  Finite_Set.fold loop\n   (Finite_Set.fold loop\n     (Visited\n       (insert src visited \\<union>\n        (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}))\n     A)\n   (E `` {src} -\n    insert src\n     (insert src visited \\<union>\n      (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}))\n\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "from fin"], ["proof (chain)\npicking this:\n  finite (E `` {src})", "have \"finite A\""], ["proof (prove)\nusing this:\n  finite (E `` {src})\n\ngoal (1 subgoal):\n 1. finite A", "unfolding A_def"], ["proof (prove)\nusing this:\n  finite (E `` {src})\n\ngoal (1 subgoal):\n 1. finite\n     ((E `` {src} - insert src visited - {y}) \\<inter>\n      (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y})", "by(rule finite_subset[rotated]) auto"], ["proof (state)\nthis:\n  finite A\n\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "moreover"], ["proof (state)\nthis:\n  finite A\n\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "have \"E `` A \\<subseteq> ?visited'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E `` A\n    \\<subseteq> insert src visited \\<union>\n                (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}", "using y"], ["proof (prove)\nusing this:\n  y \\<in> E `` {src}\n  y \\<notin> visited\n  y \\<noteq> src\n\ngoal (1 subgoal):\n 1. E `` A\n    \\<subseteq> insert src visited \\<union>\n                (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}", "unfolding A_def"], ["proof (prove)\nusing this:\n  y \\<in> E `` {src}\n  y \\<notin> visited\n  y \\<noteq> src\n\ngoal (1 subgoal):\n 1. E ``\n    ((E `` {src} - insert src visited - {y}) \\<inter>\n     (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y})\n    \\<subseteq> insert src visited \\<union>\n                (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}", "by(auto intro: rtrancl_into_rtrancl)"], ["proof (state)\nthis:\n  E `` A\n  \\<subseteq> insert src visited \\<union>\n              (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}\n\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "moreover"], ["proof (state)\nthis:\n  E `` A\n  \\<subseteq> insert src visited \\<union>\n              (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}\n\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "have \"tgt \\<notin> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tgt \\<notin> A", "unfolding A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. tgt\n    \\<notin> (E `` {src} - insert src visited - {y}) \\<inter>\n             (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}", "using y_tgt"], ["proof (prove)\nusing this:\n  (y, tgt) \\<notin> (E \\<upharpoonleft> - insert src visited)\\<^sup>*\n\ngoal (1 subgoal):\n 1. tgt\n    \\<notin> (E `` {src} - insert src visited - {y}) \\<inter>\n             (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}", "by auto"], ["proof (state)\nthis:\n  tgt \\<notin> A\n\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "ultimately"], ["proof (chain)\npicking this:\n  finite A\n  E `` A\n  \\<subseteq> insert src visited \\<union>\n              (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}\n  tgt \\<notin> A", "have \"Finite_Set.fold loop (Visited ?visited') A = (Visited (A \\<union> ?visited'))\""], ["proof (prove)\nusing this:\n  finite A\n  E `` A\n  \\<subseteq> insert src visited \\<union>\n              (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}\n  tgt \\<notin> A\n\ngoal (1 subgoal):\n 1. Finite_Set.fold loop\n     (Visited\n       (insert src visited \\<union>\n        (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}))\n     A =\n    Visited\n     (A \\<union>\n      (insert src visited \\<union>\n       (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}))", "by(rule dfs_blocked)"], ["proof (state)\nthis:\n  Finite_Set.fold loop\n   (Visited\n     (insert src visited \\<union>\n      (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}))\n   A =\n  Visited\n   (A \\<union>\n    (insert src visited \\<union>\n     (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}))\n\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "}"], ["proof (state)\nthis:\n  Finite_Set.fold loop\n   (Visited\n     (insert src visited \\<union>\n      (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}))\n   A =\n  Visited\n   (A \\<union>\n    (insert src visited \\<union>\n     (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}))\n\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "also"], ["proof (state)\nthis:\n  Finite_Set.fold loop\n   (Visited\n     (insert src visited \\<union>\n      (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}))\n   A =\n  Visited\n   (A \\<union>\n    (insert src visited \\<union>\n     (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}))\n\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "have \"A \\<union> ?visited' = insert src ?visited'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<union>\n    (insert src visited \\<union>\n     (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}) =\n    insert src\n     (insert src visited \\<union>\n      (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y})", "unfolding A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (E `` {src} - insert src visited - {y}) \\<inter>\n    (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y} \\<union>\n    (insert src visited \\<union>\n     (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}) =\n    insert src\n     (insert src visited \\<union>\n      (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y})", "by auto"], ["proof (state)\nthis:\n  A \\<union>\n  (insert src visited \\<union>\n   (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}) =\n  insert src\n   (insert src visited \\<union>\n    (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y})\n\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "also"], ["proof (state)\nthis:\n  A \\<union>\n  (insert src visited \\<union>\n   (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}) =\n  insert src\n   (insert src visited \\<union>\n    (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y})\n\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "{"], ["proof (state)\nthis:\n  A \\<union>\n  (insert src visited \\<union>\n   (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}) =\n  insert src\n   (insert src visited \\<union>\n    (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y})\n\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "have \"E `` {src} - ?visited' \\<subset> E `` {src} - visited\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E `` {src} -\n    (insert src visited \\<union>\n     (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y})\n    \\<subset> E `` {src} - visited", "using y"], ["proof (prove)\nusing this:\n  y \\<in> E `` {src}\n  y \\<notin> visited\n  y \\<noteq> src\n\ngoal (1 subgoal):\n 1. E `` {src} -\n    (insert src visited \\<union>\n     (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y})\n    \\<subset> E `` {src} - visited", "by fastforce"], ["proof (state)\nthis:\n  E `` {src} -\n  (insert src visited \\<union>\n   (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y})\n  \\<subset> E `` {src} - visited\n\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "moreover"], ["proof (state)\nthis:\n  E `` {src} -\n  (insert src visited \\<union>\n   (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y})\n  \\<subset> E `` {src} - visited\n\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "have \"(src, tgt) \\<notin> (E \\<upharpoonleft> - ?visited')\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (src, tgt)\n    \\<notin> (E \\<upharpoonleft>\n              - (insert src visited \\<union>\n                 (E \\<upharpoonleft> - insert src visited)\\<^sup>* ``\n                 {y}))\\<^sup>*", "using \\<open>(src, tgt) \\<notin> (E \\<upharpoonleft> - visited)\\<^sup>*\\<close>"], ["proof (prove)\nusing this:\n  (src, tgt) \\<notin> (E \\<upharpoonleft> - visited)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (src, tgt)\n    \\<notin> (E \\<upharpoonleft>\n              - (insert src visited \\<union>\n                 (E \\<upharpoonleft> - insert src visited)\\<^sup>* ``\n                 {y}))\\<^sup>*", "by(auto intro: rtrancl_mono[THEN subsetD, rotated])"], ["proof (state)\nthis:\n  (src, tgt)\n  \\<notin> (E \\<upharpoonleft>\n            - (insert src visited \\<union>\n               (E \\<upharpoonleft> - insert src visited)\\<^sup>* ``\n               {y}))\\<^sup>*\n\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "ultimately"], ["proof (chain)\npicking this:\n  E `` {src} -\n  (insert src visited \\<union>\n   (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y})\n  \\<subset> E `` {src} - visited\n  (src, tgt)\n  \\<notin> (E \\<upharpoonleft>\n            - (insert src visited \\<union>\n               (E \\<upharpoonleft> - insert src visited)\\<^sup>* ``\n               {y}))\\<^sup>*", "have \"Finite_Set.fold loop (Visited (insert src ?visited')) (E `` {src} - insert src ?visited') =\n                Visited (?visited' \\<union> (E \\<upharpoonleft> - ?visited')\\<^sup>* `` {src})\""], ["proof (prove)\nusing this:\n  E `` {src} -\n  (insert src visited \\<union>\n   (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y})\n  \\<subset> E `` {src} - visited\n  (src, tgt)\n  \\<notin> (E \\<upharpoonleft>\n            - (insert src visited \\<union>\n               (E \\<upharpoonleft> - insert src visited)\\<^sup>* ``\n               {y}))\\<^sup>*\n\ngoal (1 subgoal):\n 1. Finite_Set.fold loop\n     (Visited\n       (insert src\n         (insert src visited \\<union>\n          (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y})))\n     (E `` {src} -\n      insert src\n       (insert src visited \\<union>\n        (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y})) =\n    Visited\n     (insert src visited \\<union>\n      (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y} \\<union>\n      (E \\<upharpoonleft>\n       - (insert src visited \\<union>\n          (E \\<upharpoonleft> - insert src visited)\\<^sup>* ``\n          {y}))\\<^sup>* ``\n      {src})", "by(rule psubset.hyps)"], ["proof (state)\nthis:\n  Finite_Set.fold loop\n   (Visited\n     (insert src\n       (insert src visited \\<union>\n        (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y})))\n   (E `` {src} -\n    insert src\n     (insert src visited \\<union>\n      (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y})) =\n  Visited\n   (insert src visited \\<union>\n    (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y} \\<union>\n    (E \\<upharpoonleft>\n     - (insert src visited \\<union>\n        (E \\<upharpoonleft> - insert src visited)\\<^sup>* ``\n        {y}))\\<^sup>* ``\n    {src})\n\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "}"], ["proof (state)\nthis:\n  Finite_Set.fold loop\n   (Visited\n     (insert src\n       (insert src visited \\<union>\n        (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y})))\n   (E `` {src} -\n    insert src\n     (insert src visited \\<union>\n      (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y})) =\n  Visited\n   (insert src visited \\<union>\n    (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y} \\<union>\n    (E \\<upharpoonleft>\n     - (insert src visited \\<union>\n        (E \\<upharpoonleft> - insert src visited)\\<^sup>* ``\n        {y}))\\<^sup>* ``\n    {src})\n\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "also"], ["proof (state)\nthis:\n  Finite_Set.fold loop\n   (Visited\n     (insert src\n       (insert src visited \\<union>\n        (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y})))\n   (E `` {src} -\n    insert src\n     (insert src visited \\<union>\n      (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y})) =\n  Visited\n   (insert src visited \\<union>\n    (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y} \\<union>\n    (E \\<upharpoonleft>\n     - (insert src visited \\<union>\n        (E \\<upharpoonleft> - insert src visited)\\<^sup>* ``\n        {y}))\\<^sup>* ``\n    {src})\n\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "{"], ["proof (state)\nthis:\n  Finite_Set.fold loop\n   (Visited\n     (insert src\n       (insert src visited \\<union>\n        (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y})))\n   (E `` {src} -\n    insert src\n     (insert src visited \\<union>\n      (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y})) =\n  Visited\n   (insert src visited \\<union>\n    (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y} \\<union>\n    (E \\<upharpoonleft>\n     - (insert src visited \\<union>\n        (E \\<upharpoonleft> - insert src visited)\\<^sup>* ``\n        {y}))\\<^sup>* ``\n    {src})\n\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "assume src_x: \"(src, x) \\<in> (E \\<upharpoonleft> - visited)\\<^sup>*\"\n            and y_x: \"(y, x) \\<notin> (E \\<upharpoonleft> - insert src visited)\\<^sup>*\""], ["proof (state)\nthis:\n  (src, x) \\<in> (E \\<upharpoonleft> - visited)\\<^sup>*\n  (y, x) \\<notin> (E \\<upharpoonleft> - insert src visited)\\<^sup>*\n\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "from src_x"], ["proof (chain)\npicking this:\n  (src, x) \\<in> (E \\<upharpoonleft> - visited)\\<^sup>*", "have \"(src, x) \\<in> (E \\<upharpoonleft> - ?visited)\\<^sup>*\""], ["proof (prove)\nusing this:\n  (src, x) \\<in> (E \\<upharpoonleft> - visited)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (src, x) \\<in> (E \\<upharpoonleft> - insert src visited)\\<^sup>*", "by (metis rtrancl_restrict_start Compl_insert Containers_DFS_Ex.restrict_restrict Diff_Compl double_complement)"], ["proof (state)\nthis:\n  (src, x) \\<in> (E \\<upharpoonleft> - insert src visited)\\<^sup>*\n\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "from rtrancl_restrict_reachable[OF this y_x]"], ["proof (chain)\npicking this:\n  (src, x)\n  \\<in> (E \\<upharpoonleft> - insert src visited \\<upharpoonleft>\n         - (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y})\\<^sup>*", "have \"(src, x) \\<in> (E \\<upharpoonleft> - ?visited')\\<^sup>*\""], ["proof (prove)\nusing this:\n  (src, x)\n  \\<in> (E \\<upharpoonleft> - insert src visited \\<upharpoonleft>\n         - (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y})\\<^sup>*\n\ngoal (1 subgoal):\n 1. (src, x)\n    \\<in> (E \\<upharpoonleft>\n           - (insert src visited \\<union>\n              (E \\<upharpoonleft> - insert src visited)\\<^sup>* ``\n              {y}))\\<^sup>*", "by simp (metis Un_insert_left compl_sup)"], ["proof (state)\nthis:\n  (src, x)\n  \\<in> (E \\<upharpoonleft>\n         - (insert src visited \\<union>\n            (E \\<upharpoonleft> - insert src visited)\\<^sup>* ``\n            {y}))\\<^sup>*\n\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(src, ?x2) \\<in> (E \\<upharpoonleft> - visited)\\<^sup>*;\n   (y, ?x2)\n   \\<notin> (E \\<upharpoonleft> - insert src visited)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> (src, ?x2)\n                    \\<in> (E \\<upharpoonleft>\n                           - (insert src visited \\<union>\n                              (E \\<upharpoonleft>\n                               - insert src visited)\\<^sup>* ``\n                              {y}))\\<^sup>*\n\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>(src, ?x2) \\<in> (E \\<upharpoonleft> - visited)\\<^sup>*;\n   (y, ?x2)\n   \\<notin> (E \\<upharpoonleft> - insert src visited)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> (src, ?x2)\n                    \\<in> (E \\<upharpoonleft>\n                           - (insert src visited \\<union>\n                              (E \\<upharpoonleft>\n                               - insert src visited)\\<^sup>* ``\n                              {y}))\\<^sup>*", "have \"?visited' \\<union> (E \\<upharpoonleft> - ?visited')\\<^sup>* `` {src} = visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(src, ?x2) \\<in> (E \\<upharpoonleft> - visited)\\<^sup>*;\n   (y, ?x2)\n   \\<notin> (E \\<upharpoonleft> - insert src visited)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> (src, ?x2)\n                    \\<in> (E \\<upharpoonleft>\n                           - (insert src visited \\<union>\n                              (E \\<upharpoonleft>\n                               - insert src visited)\\<^sup>* ``\n                              {y}))\\<^sup>*\n\ngoal (1 subgoal):\n 1. insert src visited \\<union>\n    (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y} \\<union>\n    (E \\<upharpoonleft>\n     - (insert src visited \\<union>\n        (E \\<upharpoonleft> - insert src visited)\\<^sup>* ``\n        {y}))\\<^sup>* ``\n    {src} =\n    visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src}", "using y"], ["proof (prove)\nusing this:\n  \\<lbrakk>(src, ?x2) \\<in> (E \\<upharpoonleft> - visited)\\<^sup>*;\n   (y, ?x2)\n   \\<notin> (E \\<upharpoonleft> - insert src visited)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> (src, ?x2)\n                    \\<in> (E \\<upharpoonleft>\n                           - (insert src visited \\<union>\n                              (E \\<upharpoonleft>\n                               - insert src visited)\\<^sup>* ``\n                              {y}))\\<^sup>*\n  y \\<in> E `` {src}\n  y \\<notin> visited\n  y \\<noteq> src\n\ngoal (1 subgoal):\n 1. insert src visited \\<union>\n    (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y} \\<union>\n    (E \\<upharpoonleft>\n     - (insert src visited \\<union>\n        (E \\<upharpoonleft> - insert src visited)\\<^sup>* ``\n        {y}))\\<^sup>* ``\n    {src} =\n    visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src}", "by(auto intro: converse_rtrancl_into_rtrancl rtrancl_mono[THEN subsetD, rotated])"], ["proof (state)\nthis:\n  insert src visited \\<union>\n  (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y} \\<union>\n  (E \\<upharpoonleft>\n   - (insert src visited \\<union>\n      (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}))\\<^sup>* ``\n  {src} =\n  visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src}\n\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "also"], ["proof (state)\nthis:\n  insert src visited \\<union>\n  (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y} \\<union>\n  (E \\<upharpoonleft>\n   - (insert src visited \\<union>\n      (E \\<upharpoonleft> - insert src visited)\\<^sup>* `` {y}))\\<^sup>* ``\n  {src} =\n  visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src}\n\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "have \"insert y ?succs = E `` {src} - insert src visited\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert y (E `` {src} - insert src visited - {y}) =\n    E `` {src} - insert src visited", "using y"], ["proof (prove)\nusing this:\n  y \\<in> E `` {src}\n  y \\<notin> visited\n  y \\<noteq> src\n\ngoal (1 subgoal):\n 1. insert y (E `` {src} - insert src visited - {y}) =\n    E `` {src} - insert src visited", "by auto"], ["proof (state)\nthis:\n  insert y (E `` {src} - insert src visited - {y}) =\n  E `` {src} - insert src visited\n\ngoal (1 subgoal):\n 1. E `` {src} - insert src visited \\<noteq> {} \\<Longrightarrow>\n    Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "finally"], ["proof (chain)\npicking this:\n  Finite_Set.fold loop (Visited (insert src visited))\n   (E `` {src} - insert src visited) =\n  Visited (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "show ?thesis"], ["proof (prove)\nusing this:\n  Finite_Set.fold loop (Visited (insert src visited))\n   (E `` {src} - insert src visited) =\n  Visited (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})\n\ngoal (1 subgoal):\n 1. Finite_Set.fold loop (Visited (insert src visited))\n     (E `` {src} - insert src visited) =\n    Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})", "."], ["proof (state)\nthis:\n  Finite_Set.fold loop (Visited (insert src visited))\n   (E `` {src} - insert src visited) =\n  Visited (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Finite_Set.fold loop (Visited (insert src visited))\n   (E `` {src} - insert src visited) =\n  Visited (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Finite_Set.fold loop (Visited (insert src visited))\n   (E `` {src} - insert src visited) =\n  Visited (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src})\n\ngoal (1 subgoal):\n 1. (src, tgt)\n    \\<notin> (E \\<upharpoonleft> - visited)\\<^sup>* \\<Longrightarrow>\n    local.dfs src tgt visited =\n    (if src = tgt then Reachable\n     else let succs = E `` {src}\n          in if finite succs\n             then Finite_Set.fold loop (Visited (insert src visited)) succs\n             else Code.abort STR ''infinite successor relation''\n                   (\\<lambda>_. local.dfs src tgt visited))", "finally"], ["proof (chain)\npicking this:\n  Finite_Set.fold loop (Visited (insert src visited)) (E `` {src}) =\n  Finite_Set.fold loop\n   (Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src}))\n   (E `` {src} \\<inter> insert src visited)", "show ?thesis"], ["proof (prove)\nusing this:\n  Finite_Set.fold loop (Visited (insert src visited)) (E `` {src}) =\n  Finite_Set.fold loop\n   (Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src}))\n   (E `` {src} \\<inter> insert src visited)\n\ngoal (1 subgoal):\n 1. local.dfs src tgt visited =\n    (if src = tgt then Reachable\n     else let succs = E `` {src}\n          in if finite succs\n             then Finite_Set.fold loop (Visited (insert src visited)) succs\n             else Code.abort STR ''infinite successor relation''\n                   (\\<lambda>_. local.dfs src tgt visited))", "using False fin"], ["proof (prove)\nusing this:\n  Finite_Set.fold loop (Visited (insert src visited)) (E `` {src}) =\n  Finite_Set.fold loop\n   (Visited\n     (visited \\<union> (E \\<upharpoonleft> - visited)\\<^sup>* `` {src}))\n   (E `` {src} \\<inter> insert src visited)\n  (src, tgt) \\<notin> (E \\<upharpoonleft> - visited)\\<^sup>*\n  finite (E `` {src})\n\ngoal (1 subgoal):\n 1. local.dfs src tgt visited =\n    (if src = tgt then Reachable\n     else let succs = E `` {src}\n          in if finite succs\n             then Finite_Set.fold loop (Visited (insert src visited)) succs\n             else Code.abort STR ''infinite successor relation''\n                   (\\<lambda>_. local.dfs src tgt visited))", "by(simp add: dfs_def Let_def)(subst dfs_visited; auto)"], ["proof (state)\nthis:\n  local.dfs src tgt visited =\n  (if src = tgt then Reachable\n   else let succs = E `` {src}\n        in if finite succs\n           then Finite_Set.fold loop (Visited (insert src visited)) succs\n           else Code.abort STR ''infinite successor relation''\n                 (\\<lambda>_. local.dfs src tgt visited))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.dfs src tgt visited =\n  (if src = tgt then Reachable\n   else let succs = E `` {src}\n        in if finite succs\n           then Finite_Set.fold loop (Visited (insert src visited)) succs\n           else Code.abort STR ''infinite successor relation''\n                 (\\<lambda>_. local.dfs src tgt visited))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "lift_definition dfs_body :: \"'a \\<Rightarrow> ('a, 'a dfs_result) comp_fun_commute\"\nis \"\\<lambda>tgt x r. case r of Reachable \\<Rightarrow> Reachable | Visited \\<V> \\<Rightarrow> if x \\<in> \\<V> then Visited \\<V> else dfs x tgt \\<V>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       comp_fun_commute\n        (\\<lambda>x.\n            case_dfs_result Reachable\n             (\\<lambda>\\<V>.\n                 if x \\<in> \\<V> then Visited \\<V> else local.dfs x a \\<V>))", "by(rule comp_fun_commute_dfs_body)"], ["", "lemma dfs_code [code]:\n  \"dfs src tgt visited =\n  (if src = tgt then Reachable\n   else let S = E `` {src} in \n   if finite S then set_fold_cfc (dfs_body tgt) (Visited (insert src visited)) S\n   else Code.abort (STR ''infinite successor relation'') (\\<lambda>_. dfs src tgt visited))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dfs src tgt visited =\n    (if src = tgt then Reachable\n     else let S = E `` {src}\n          in if finite S\n             then set_fold_cfc (local.dfs_body tgt)\n                   (Visited (insert src visited)) S\n             else Code.abort STR ''infinite successor relation''\n                   (\\<lambda>_. local.dfs src tgt visited))", "by transfer(subst dfs_rec, simp add: Let_def)"], ["", "lemma reachable_dfs [code]:\n  \"reachable src tgt = is_Reachable (dfs src tgt {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.reachable src tgt = is_Reachable (local.dfs src tgt {})", "by(simp add: dfs_def reachable_def)"], ["", "end"], ["", "subsection \\<open>Refinement to executable code\\<close>"], ["", "typedef 'a graph = \"UNIV :: ('a \\<times> 'a) set set\" morphisms edges Graph"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> UNIV", ".."], ["", "setup_lifting type_definition_graph"], ["", "text \\<open>Implement graphs with successor function\\<close>"], ["", "definition graph_of_succs :: \"('a \\<Rightarrow> 'a set) \\<Rightarrow> ('a \\<times> 'a) set\"\nwhere \"graph_of_succs succs = {(v, w). w \\<in> succs v}\""], ["", "declare graph_of_succs_def[containers_post, symmetric, containers_pre]"], ["", "lift_definition Succ :: \"('a \\<Rightarrow> 'a set) \\<Rightarrow> 'a graph\" is \"graph_of_succs\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "code_datatype Succ"], ["", "text \\<open>Identify operations on graph\\<close>"], ["", "definition successors :: \"('a \\<times> 'a) set \\<Rightarrow> 'a \\<Rightarrow> 'a set\" where \"successors E x = E `` {x}\""], ["", "declare successors_def[containers_post, symmetric, containers_pre]"], ["", "lift_definition succs :: \"'a graph \\<Rightarrow> 'a \\<Rightarrow> 'a set\" is successors"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma succs_code [code]: \"succs (Succ s) = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succs (Succ s) = s", "by transfer(simp add: successors_def fun_eq_iff graph_of_succs_def)"], ["", "text \\<open>Transfer algorithms to abstract graph type\\<close>"], ["", "lift_definition reachable_impl :: \"'a graph \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> bool\" is reachable"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition dfs_impl :: \"'a graph \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> 'a set \\<Rightarrow> 'a dfs_result\" is dfs"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition dfs_body_impl :: \"'a graph \\<Rightarrow> 'a \\<Rightarrow> ('a, 'a dfs_result) comp_fun_commute\" is dfs_body"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemmas [containers_identify, code] = reachable_dfs dfs_code dfs_body.rep_eq"], ["", "subsection \\<open>Tests\\<close>"], ["", "definition test_graph :: \"nat graph\"\nwhere \"test_graph = Succ ((\\<lambda>_. {})(0 := {1,3}, 1 := {2,4}, 2 := {1}, 3 := {1, 5}, 4 := {5}))\""], ["", "definition test_dfs where \"test_dfs = map (reachable_impl test_graph 0) [0..<7]\""], ["", "ML_val \\<open>\n  val [true, true, true, true, true, true, false] = @{code test_dfs};\n\\<close>"], ["", "end"]]}