{"file_name": "/home/qj213/afp-2021-10-22/thys/Containers/RBT_Set2.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Containers", "problem_names": ["lemma map_of_map_Pair_const:\n  \"map_of (map (\\<lambda>x. (x, v)) xs) = (\\<lambda>x. if x \\<in> set xs then Some v else None)\"", "lemma map_of_rev_unit [simp]: \n  fixes xs :: \"('a * unit) list\" \n  shows \"map_of (rev xs) = map_of xs\"", "lemma fold_split_conv_map_fst: \"fold (\\<lambda>(x, y). f x) xs = fold f (map fst xs)\"", "lemma foldr_split_conv_map_fst: \"foldr (\\<lambda>(x, y). f x) xs = foldr f (map fst xs)\"", "lemma set_foldr_Cons:\n  \"set (foldr (\\<lambda>x xs. if P x xs then x # xs else xs) as []) \\<subseteq> set as\"", "lemma distinct_fst_foldr_Cons:\n  \"distinct (map f as) \\<Longrightarrow> distinct (map f (foldr (\\<lambda>x xs. if P x xs then x # xs else xs) as []))\"", "lemma filter_conv_foldr:\n  \"filter P xs = foldr (\\<lambda>x xs. if P x then x # xs else xs) xs []\"", "lemma map_of_filter: \"map_of (filter (\\<lambda>x. P (fst x)) xs) = map_of xs |` Collect P\"", "lemma map_of_map_Pair_key: \"map_of (map (\\<lambda>k. (k, f k)) xs) x = (if x \\<in> set xs then Some (f x) else None)\"", "lemma neq_Empty_conv: \"t \\<noteq> rbt.Empty \\<longleftrightarrow> (\\<exists>c l k v r. t = Branch c l k v r)\"", "lemma is_rbt_RBT_fold_rbt_insert [simp]:\n  \"is_rbt t \\<Longrightarrow> is_rbt (fold (\\<lambda>(k, v). rbt_insert k v) xs t)\"", "lemma rbt_lookup_RBT_fold_rbt_insert [simp]: \n  \"is_rbt t \\<Longrightarrow> rbt_lookup (fold (\\<lambda>(k, v). rbt_insert k v) xs t) = rbt_lookup t ++ map_of (rev xs)\"", "lemma is_rbt_fold_rbt_delete [simp]:\n  \"is_rbt t \\<Longrightarrow> is_rbt (fold rbt_delete xs t)\"", "lemma rbt_lookup_fold_rbt_delete [simp]: \n  \"is_rbt t \\<Longrightarrow> rbt_lookup (fold rbt_delete xs t) = rbt_lookup t |` (- set xs)\"", "lemma is_rbt_fold_rbt_insert: \"is_rbt t \\<Longrightarrow> is_rbt (fold (\\<lambda>k. rbt_insert k (f k)) xs t)\"", "lemma rbt_lookup_fold_rbt_insert: \n  \"is_rbt t \\<Longrightarrow> \n  rbt_lookup (fold (\\<lambda>k. rbt_insert k (f k)) xs t) = \n  rbt_lookup t ++ map_of (map (\\<lambda>k. (k, f k)) xs)\"", "lemma fold_rev_simps [simp, code]:\n  \"fold_rev f RBT_Impl.Empty = id\"\n  \"fold_rev f (Branch c l k v r) = fold_rev f l o f k v o fold_rev f r\"", "lemma rbt_comp_minus: assumes c: \"comparator c\"\n  shows \"rbt_comp_minus c = ord.rbt_minus (lt_of_comp c)\"", "lemma sorted_fst_foldr_Cons:\n  \"sorted (map f as) \\<Longrightarrow> sorted (map f (foldr (\\<lambda>x xs. if P x xs then x # xs else xs) as []))\"", "lemma is_rbt_rbt_minus:\n  \"\\<lbrakk> is_rbt t1; is_rbt t2 \\<rbrakk> \\<Longrightarrow> is_rbt (rbt_minus t1 t2)\"", "lemma rbt_lookup_rbt_minus:\n  \"\\<lbrakk> is_rbt t1; is_rbt t2 \\<rbrakk> \n  \\<Longrightarrow> rbt_lookup (rbt_minus t1 t2) = rbt_lookup t1 |` (- dom (rbt_lookup t2))\"", "lemma member_empty [simp]:\n  \"member empty = (\\<lambda>_. False)\"", "lemma fold_conv_fold_keys: \"RBT_Set2.fold f rbt b = List.fold f (RBT_Set2.keys rbt) b\"", "lemma fold_conv_fold_keys':\n  \"fold f t = List.fold f (RBT_Impl.keys (RBT_Mapping2.impl_of t))\"", "lemma member_lookup [code]: \"member t x \\<longleftrightarrow> RBT_Mapping2.lookup t x = Some ()\"", "lemma unfoldr_rbt_keys_generator:\n  \"list.unfoldr rbt_keys_generator (init t) = keys t\"", "lemma keys_eq_Nil_iff [simp]: \"keys rbt = [] \\<longleftrightarrow> rbt = empty\"", "lemma fold1_conv_fold: \"fold1 f rbt = List.fold f (tl (keys rbt)) (hd (keys rbt))\"", "lemma set_linorder: \"class.linorder (cless_eq :: 'a \\<Rightarrow> 'a \\<Rightarrow> bool) cless\"", "lemma ccomp_comparator: \"comparator (ccomp :: 'a comparator)\"", "lemmas rbt_comps = rbt_comp_simps[OF ccomp_comparator] rbt_comp_minus[OF ccomp_comparator]", "lemma is_rbt_impl_of [simp, intro]:\n  fixes t :: \"'a set_rbt\"\n  shows \"ord.is_rbt cless (RBT_Mapping2.impl_of t)\"", "lemma member_RBT:\n  \"ord.is_rbt cless t \\<Longrightarrow> member (Set_RBT t) (x :: 'a) \\<longleftrightarrow> ord.rbt_lookup cless t x = Some ()\"", "lemma member_impl_of:\n  \"ord.rbt_lookup cless (RBT_Mapping2.impl_of t) (x :: 'a) = Some () \\<longleftrightarrow> member t x\"", "lemma member_insert [simp]:\n  \"member (insert x (t :: 'a set_rbt)) = (member t)(x := True)\"", "lemma member_fold_insert [simp]:\n  \"member (List.fold insert xs (t :: 'a set_rbt)) = (\\<lambda>x. member t x \\<or> x \\<in> set xs)\"", "lemma member_remove [simp]:\n  \"member (remove (x :: 'a) t) = (member t)(x := False)\"", "lemma member_bulkload [simp]:\n  \"member (bulkload xs) (x :: 'a) \\<longleftrightarrow> x \\<in> set xs\"", "lemma member_conv_keys: \"member t = (\\<lambda>x :: 'a. x \\<in> set (keys t))\"", "lemma is_empty_empty [simp]:\n  \"is_empty t \\<longleftrightarrow> t = empty\"", "lemma RBT_lookup_empty [simp]:\n  \"ord.rbt_lookup cless (t :: ('a, unit) rbt) = Map.empty \\<longleftrightarrow> t = RBT_Impl.Empty\"", "lemma member_empty_empty [simp]:\n  \"member t = (\\<lambda>_. False) \\<longleftrightarrow> (t :: 'a set_rbt) = empty\"", "lemma member_union [simp]:\n  \"member (union (t1 :: 'a set_rbt) t2) = (\\<lambda>x. member t1 x \\<or> member t2 x)\"", "lemma member_minus [simp]:\n  \"member (minus (t1 :: 'a set_rbt) t2) = (\\<lambda>x. member t1 x \\<and> \\<not> member t2 x)\"", "lemma member_inter [simp]:\n  \"member (inter (t1 :: 'a set_rbt) t2) = (\\<lambda>x. member t1 x \\<and> member t2 x)\"", "lemma member_inter_list [simp]:\n  \"member (inter_list (t :: 'a set_rbt) xs) = (\\<lambda>x. member t x \\<and> x \\<in> set xs)\"", "lemma member_filter [simp]:\n  \"member (filter P (t :: 'a set_rbt)) = (\\<lambda>x. member t x \\<and> P x)\"", "lemma distinct_keys [simp]:\n  \"distinct (keys (rbt :: 'a set_rbt))\"", "lemma all_conv_all_member:\n  \"all P t \\<longleftrightarrow> (\\<forall>x :: 'a. member t x \\<longrightarrow> P x)\"", "lemma ex_conv_ex_member:\n  \"ex P t \\<longleftrightarrow> (\\<exists>x :: 'a. member t x \\<and> P x)\"", "lemma finite_member: \"finite (Collect (RBT_Set2.member (t :: 'a set_rbt)))\"", "lemma member_Id_on: \"member (Id_on t) = (\\<lambda>(k :: 'a, k'). k = k' \\<and> member t k)\"", "lemma set_linorder': \"class.linorder (cless_eq :: 'b \\<Rightarrow> 'b \\<Rightarrow> bool) cless\"", "lemma member_product:\n  \"member (product rbt1 rbt2) = (\\<lambda>ab :: 'a \\<times> 'b. ab \\<in> Collect (member rbt1) \\<times> Collect (member rbt2))\"", "lemma sorted_RBT_Set_keys: \n  \"ID CCOMPARE('a :: ccompare) = Some c \n  \\<Longrightarrow> linorder.sorted (le_of_comp c) (RBT_Set2.keys rbt)\"", "lemma set_linorder2: \"class.linorder (cless_eq :: 'a \\<Rightarrow> 'a \\<Rightarrow> bool) cless\"", "lemma set_keys_Mapping_RBT: \"set (keys (Mapping_RBT t)) = set (RBT_Impl.keys t)\""], "translations": [["", "lemma map_of_map_Pair_const:\n  \"map_of (map (\\<lambda>x. (x, v)) xs) = (\\<lambda>x. if x \\<in> set xs then Some v else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>x. (x, v)) xs) =\n    (\\<lambda>x. if x \\<in> set xs then Some v else None)", "by(induct xs) auto"], ["", "lemma map_of_rev_unit [simp]: \n  fixes xs :: \"('a * unit) list\" \n  shows \"map_of (rev xs) = map_of xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (rev xs) = map_of xs", "by(induct xs rule: rev_induct)(auto simp add: map_add_def split: option.split)"], ["", "lemma fold_split_conv_map_fst: \"fold (\\<lambda>(x, y). f x) xs = fold f (map fst xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>(x, y). f x) xs = fold f (map fst xs)", "by(simp add: fold_map o_def split_def)"], ["", "lemma foldr_split_conv_map_fst: \"foldr (\\<lambda>(x, y). f x) xs = foldr f (map fst xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>(x, y). f x) xs = foldr f (map fst xs)", "by(simp add: foldr_map o_def split_def fun_eq_iff)"], ["", "lemma set_foldr_Cons:\n  \"set (foldr (\\<lambda>x xs. if P x xs then x # xs else xs) as []) \\<subseteq> set as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (foldr (\\<lambda>x xs. if P x xs then x # xs else xs) as [])\n    \\<subseteq> set as", "by(induct as) auto"], ["", "lemma distinct_fst_foldr_Cons:\n  \"distinct (map f as) \\<Longrightarrow> distinct (map f (foldr (\\<lambda>x xs. if P x xs then x # xs else xs) as []))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map f as) \\<Longrightarrow>\n    distinct\n     (map f (foldr (\\<lambda>x xs. if P x xs then x # xs else xs) as []))", "proof(induct as)"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct (map f []) \\<Longrightarrow>\n    distinct\n     (map f (foldr (\\<lambda>x xs. if P x xs then x # xs else xs) [] []))\n 2. \\<And>a as.\n       \\<lbrakk>distinct (map f as) \\<Longrightarrow>\n                distinct\n                 (map f\n                   (foldr (\\<lambda>x xs. if P x xs then x # xs else xs) as\n                     []));\n        distinct (map f (a # as))\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map f\n                            (foldr\n                              (\\<lambda>x xs. if P x xs then x # xs else xs)\n                              (a # as) []))", "case (Cons a as)"], ["proof (state)\nthis:\n  distinct (map f as) \\<Longrightarrow>\n  distinct\n   (map f (foldr (\\<lambda>x xs. if P x xs then x # xs else xs) as []))\n  distinct (map f (a # as))\n\ngoal (2 subgoals):\n 1. distinct (map f []) \\<Longrightarrow>\n    distinct\n     (map f (foldr (\\<lambda>x xs. if P x xs then x # xs else xs) [] []))\n 2. \\<And>a as.\n       \\<lbrakk>distinct (map f as) \\<Longrightarrow>\n                distinct\n                 (map f\n                   (foldr (\\<lambda>x xs. if P x xs then x # xs else xs) as\n                     []));\n        distinct (map f (a # as))\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map f\n                            (foldr\n                              (\\<lambda>x xs. if P x xs then x # xs else xs)\n                              (a # as) []))", "with set_foldr_Cons[of P as]"], ["proof (chain)\npicking this:\n  set (foldr (\\<lambda>x xs. if P x xs then x # xs else xs) as [])\n  \\<subseteq> set as\n  distinct (map f as) \\<Longrightarrow>\n  distinct\n   (map f (foldr (\\<lambda>x xs. if P x xs then x # xs else xs) as []))\n  distinct (map f (a # as))", "show ?case"], ["proof (prove)\nusing this:\n  set (foldr (\\<lambda>x xs. if P x xs then x # xs else xs) as [])\n  \\<subseteq> set as\n  distinct (map f as) \\<Longrightarrow>\n  distinct\n   (map f (foldr (\\<lambda>x xs. if P x xs then x # xs else xs) as []))\n  distinct (map f (a # as))\n\ngoal (1 subgoal):\n 1. distinct\n     (map f\n       (foldr (\\<lambda>x xs. if P x xs then x # xs else xs) (a # as) []))", "by auto"], ["proof (state)\nthis:\n  distinct\n   (map f\n     (foldr (\\<lambda>x xs. if P x xs then x # xs else xs) (a # as) []))\n\ngoal (1 subgoal):\n 1. distinct (map f []) \\<Longrightarrow>\n    distinct\n     (map f (foldr (\\<lambda>x xs. if P x xs then x # xs else xs) [] []))", "qed simp"], ["", "lemma filter_conv_foldr:\n  \"filter P xs = foldr (\\<lambda>x xs. if P x then x # xs else xs) xs []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter P xs = foldr (\\<lambda>x xs. if P x then x # xs else xs) xs []", "by(induct xs) simp_all"], ["", "lemma map_of_filter: \"map_of (filter (\\<lambda>x. P (fst x)) xs) = map_of xs |` Collect P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (filter (\\<lambda>x. P (fst x)) xs) = map_of xs |` Collect P", "by(induct xs)(simp_all add: fun_eq_iff restrict_map_def)"], ["", "lemma map_of_map_Pair_key: \"map_of (map (\\<lambda>k. (k, f k)) xs) x = (if x \\<in> set xs then Some (f x) else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>k. (k, f k)) xs) x =\n    (if x \\<in> set xs then Some (f x) else None)", "by(induct xs) simp_all"], ["", "lemma neq_Empty_conv: \"t \\<noteq> rbt.Empty \\<longleftrightarrow> (\\<exists>c l k v r. t = Branch c l k v r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t \\<noteq> rbt.Empty) = (\\<exists>c l k v r. t = Branch c l k v r)", "by(cases t) simp_all"], ["", "context linorder begin"], ["", "lemma is_rbt_RBT_fold_rbt_insert [simp]:\n  \"is_rbt t \\<Longrightarrow> is_rbt (fold (\\<lambda>(k, v). rbt_insert k v) xs t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_rbt t \\<Longrightarrow>\n    is_rbt (fold (\\<lambda>(k, v). rbt_insert k v) xs t)", "by(induct xs arbitrary: t)(simp_all add: split_beta)"], ["", "lemma rbt_lookup_RBT_fold_rbt_insert [simp]: \n  \"is_rbt t \\<Longrightarrow> rbt_lookup (fold (\\<lambda>(k, v). rbt_insert k v) xs t) = rbt_lookup t ++ map_of (rev xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_rbt t \\<Longrightarrow>\n    rbt_lookup (fold (\\<lambda>(k, v). rbt_insert k v) xs t) =\n    rbt_lookup t ++ map_of (rev xs)", "apply(induct xs arbitrary: t rule: rev_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t.\n       is_rbt t \\<Longrightarrow>\n       rbt_lookup (fold (\\<lambda>(x, y). rbt_insert x y) [] t) =\n       rbt_lookup t ++ map_of (rev [])\n 2. \\<And>x xs t.\n       \\<lbrakk>\\<And>t.\n                   is_rbt t \\<Longrightarrow>\n                   rbt_lookup\n                    (fold (\\<lambda>(x, y). rbt_insert x y) xs t) =\n                   rbt_lookup t ++ map_of (rev xs);\n        is_rbt t\\<rbrakk>\n       \\<Longrightarrow> rbt_lookup\n                          (fold (\\<lambda>(x, y). rbt_insert x y) (xs @ [x])\n                            t) =\n                         rbt_lookup t ++ map_of (rev (xs @ [x]))", "apply(simp_all add: split_beta fun_eq_iff rbt_lookup_rbt_insert)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_rbt_fold_rbt_delete [simp]:\n  \"is_rbt t \\<Longrightarrow> is_rbt (fold rbt_delete xs t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_rbt t \\<Longrightarrow> is_rbt (fold rbt_delete xs t)", "by(induct xs arbitrary: t)(simp_all)"], ["", "lemma rbt_lookup_fold_rbt_delete [simp]: \n  \"is_rbt t \\<Longrightarrow> rbt_lookup (fold rbt_delete xs t) = rbt_lookup t |` (- set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_rbt t \\<Longrightarrow>\n    rbt_lookup (fold rbt_delete xs t) = rbt_lookup t |` (- set xs)", "apply(induct xs rule: rev_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_rbt t \\<Longrightarrow>\n    rbt_lookup (fold rbt_delete [] t) = rbt_lookup t |` (- set [])\n 2. \\<And>x xs.\n       \\<lbrakk>is_rbt t \\<Longrightarrow>\n                rbt_lookup (fold rbt_delete xs t) =\n                rbt_lookup t |` (- set xs);\n        is_rbt t\\<rbrakk>\n       \\<Longrightarrow> rbt_lookup (fold rbt_delete (xs @ [x]) t) =\n                         rbt_lookup t |` (- set (xs @ [x]))", "apply(simp_all add: rbt_lookup_rbt_delete ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>rbt_lookup (fold rbt_delete xs t) =\n                rbt_lookup t |` (- set xs);\n        is_rbt t\\<rbrakk>\n       \\<Longrightarrow> rbt_lookup t |` (- set xs \\<inter> - {x}) =\n                         rbt_lookup t |` (- insert x (set xs))", "apply(metis Un_insert_right compl_sup sup_bot_right)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_rbt_fold_rbt_insert: \"is_rbt t \\<Longrightarrow> is_rbt (fold (\\<lambda>k. rbt_insert k (f k)) xs t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_rbt t \\<Longrightarrow>\n    is_rbt (fold (\\<lambda>k. rbt_insert k (f k)) xs t)", "by(induct xs rule: rev_induct) simp_all"], ["", "lemma rbt_lookup_fold_rbt_insert: \n  \"is_rbt t \\<Longrightarrow> \n  rbt_lookup (fold (\\<lambda>k. rbt_insert k (f k)) xs t) = \n  rbt_lookup t ++ map_of (map (\\<lambda>k. (k, f k)) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_rbt t \\<Longrightarrow>\n    rbt_lookup (fold (\\<lambda>k. rbt_insert k (f k)) xs t) =\n    rbt_lookup t ++ map_of (map (\\<lambda>k. (k, f k)) xs)", "by(induct xs arbitrary: t)(auto simp add: rbt_lookup_rbt_insert map_add_def fun_eq_iff map_of_map_Pair_key split: option.splits)"], ["", "end"], ["", "definition fold_rev :: \"('a \\<Rightarrow> 'b \\<Rightarrow> 'c \\<Rightarrow> 'c) \\<Rightarrow> ('a, 'b) rbt \\<Rightarrow> 'c \\<Rightarrow> 'c\"\nwhere \"fold_rev f t = List.foldr (\\<lambda>(k, v). f k v) (RBT_Impl.entries t)\""], ["", "lemma fold_rev_simps [simp, code]:\n  \"fold_rev f RBT_Impl.Empty = id\"\n  \"fold_rev f (Branch c l k v r) = fold_rev f l o f k v o fold_rev f r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold_rev f rbt.Empty = id &&&\n    fold_rev f (Branch c l k v r) =\n    fold_rev f l \\<circ> f k v \\<circ> fold_rev f r", "by(simp_all add: fold_rev_def fun_eq_iff)"], ["", "definition (in ord) rbt_minus :: \"('a, 'b) rbt \\<Rightarrow> ('a, 'b) rbt \\<Rightarrow> ('a, 'b) rbt\"\nwhere\n  \"rbt_minus t1 t2 =\n  (let h1 = bheight t1; h2 = bheight t2\n   in if 2 * h1 \\<le> h2 then rbtreeify (fold_rev (\\<lambda>k v kvs. if rbt_lookup t2 k = None then (k, v) # kvs else kvs) t1 [])\n      else RBT_Impl.fold (\\<lambda>k v. rbt_delete k) t2 t1)\""], ["", "definition rbt_comp_minus :: \"'a comparator \\<Rightarrow> ('a, 'b) rbt \\<Rightarrow> ('a, 'b) rbt \\<Rightarrow> ('a, 'b) rbt\"\nwhere\n  \"rbt_comp_minus c t1 t2 =\n  (let h1 = bheight t1; h2 = bheight t2\n   in if 2 * h1 \\<le> h2 then rbtreeify (fold_rev (\\<lambda>k v kvs. if rbt_comp_lookup c t2 k = None then (k, v) # kvs else kvs) t1 [])\n      else RBT_Impl.fold (\\<lambda>k v. rbt_comp_delete c k) t2 t1)\""], ["", "lemma rbt_comp_minus: assumes c: \"comparator c\"\n  shows \"rbt_comp_minus c = ord.rbt_minus (lt_of_comp c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_comp_minus c = ord.rbt_minus (lt_of_comp c)", "by (intro ext, unfold rbt_comp_minus_def ord.rbt_minus_def, auto simp: rbt_comp_simps[OF c])"], ["", "context linorder begin"], ["", "lemma sorted_fst_foldr_Cons:\n  \"sorted (map f as) \\<Longrightarrow> sorted (map f (foldr (\\<lambda>x xs. if P x xs then x # xs else xs) as []))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (map f as) \\<Longrightarrow>\n    sorted\n     (map f (foldr (\\<lambda>x xs. if P x xs then x # xs else xs) as []))", "proof(induct as)"], ["proof (state)\ngoal (2 subgoals):\n 1. sorted (map f []) \\<Longrightarrow>\n    sorted\n     (map f (foldr (\\<lambda>x xs. if P x xs then x # xs else xs) [] []))\n 2. \\<And>a as.\n       \\<lbrakk>sorted (map f as) \\<Longrightarrow>\n                sorted\n                 (map f\n                   (foldr (\\<lambda>x xs. if P x xs then x # xs else xs) as\n                     []));\n        sorted (map f (a # as))\\<rbrakk>\n       \\<Longrightarrow> sorted\n                          (map f\n                            (foldr\n                              (\\<lambda>x xs. if P x xs then x # xs else xs)\n                              (a # as) []))", "case (Cons a as)"], ["proof (state)\nthis:\n  sorted (map f as) \\<Longrightarrow>\n  sorted\n   (map f (foldr (\\<lambda>x xs. if P x xs then x # xs else xs) as []))\n  sorted (map f (a # as))\n\ngoal (2 subgoals):\n 1. sorted (map f []) \\<Longrightarrow>\n    sorted\n     (map f (foldr (\\<lambda>x xs. if P x xs then x # xs else xs) [] []))\n 2. \\<And>a as.\n       \\<lbrakk>sorted (map f as) \\<Longrightarrow>\n                sorted\n                 (map f\n                   (foldr (\\<lambda>x xs. if P x xs then x # xs else xs) as\n                     []));\n        sorted (map f (a # as))\\<rbrakk>\n       \\<Longrightarrow> sorted\n                          (map f\n                            (foldr\n                              (\\<lambda>x xs. if P x xs then x # xs else xs)\n                              (a # as) []))", "with set_foldr_Cons[of P as]"], ["proof (chain)\npicking this:\n  set (foldr (\\<lambda>x xs. if P x xs then x # xs else xs) as [])\n  \\<subseteq> set as\n  sorted (map f as) \\<Longrightarrow>\n  sorted\n   (map f (foldr (\\<lambda>x xs. if P x xs then x # xs else xs) as []))\n  sorted (map f (a # as))", "show ?case"], ["proof (prove)\nusing this:\n  set (foldr (\\<lambda>x xs. if P x xs then x # xs else xs) as [])\n  \\<subseteq> set as\n  sorted (map f as) \\<Longrightarrow>\n  sorted\n   (map f (foldr (\\<lambda>x xs. if P x xs then x # xs else xs) as []))\n  sorted (map f (a # as))\n\ngoal (1 subgoal):\n 1. sorted\n     (map f\n       (foldr (\\<lambda>x xs. if P x xs then x # xs else xs) (a # as) []))", "by(auto)"], ["proof (state)\nthis:\n  sorted\n   (map f\n     (foldr (\\<lambda>x xs. if P x xs then x # xs else xs) (a # as) []))\n\ngoal (1 subgoal):\n 1. sorted (map f []) \\<Longrightarrow>\n    sorted\n     (map f (foldr (\\<lambda>x xs. if P x xs then x # xs else xs) [] []))", "qed simp"], ["", "lemma is_rbt_rbt_minus:\n  \"\\<lbrakk> is_rbt t1; is_rbt t2 \\<rbrakk> \\<Longrightarrow> is_rbt (rbt_minus t1 t2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rbt t1; is_rbt t2\\<rbrakk>\n    \\<Longrightarrow> is_rbt (rbt_minus t1 t2)", "by(auto simp add: rbt_minus_def Let_def RBT_Impl.fold_def fold_rev_def is_rbt_fold_rbt_delete[where xs=\"map fst (RBT_Impl.entries t2)\", simplified fold_map o_def] split_def is_rbt_rbtreeify sorted_fst_foldr_Cons rbt_sorted_entries distinct_fst_foldr_Cons distinct_entries cong: if_cong)"], ["", "lemma rbt_lookup_rbt_minus:\n  \"\\<lbrakk> is_rbt t1; is_rbt t2 \\<rbrakk> \n  \\<Longrightarrow> rbt_lookup (rbt_minus t1 t2) = rbt_lookup t1 |` (- dom (rbt_lookup t2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rbt t1; is_rbt t2\\<rbrakk>\n    \\<Longrightarrow> rbt_lookup (rbt_minus t1 t2) =\n                      rbt_lookup t1 |` (- dom (rbt_lookup t2))", "apply(clarsimp simp add: rbt_minus_def Let_def domIff[symmetric] rbt_lookup_keys rbt_lookup_rbtreeify RBT_Impl.keys_def trans[OF RBT_Impl.fold_def fold_split_conv_map_fst] split_def sorted_fst_foldr_Cons rbt_sorted_entries distinct_fst_foldr_Cons distinct_entries fold_rev_def simp del: set_map cong: if_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_rbt t1; is_rbt t2; 2 * bheight t1 \\<le> bheight t2\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (foldr\n                         (\\<lambda>p kvs.\n                             if rbt_lookup t2 (fst p) = None then p # kvs\n                             else kvs)\n                         (RBT_Impl.entries t1) []) =\n                      rbt_lookup t1 |`\n                      (- set (map fst (RBT_Impl.entries t2)))", "apply(auto simp add: map_of_entries[symmetric] filter_conv_foldr[symmetric] map_of_filter[where P=\"\\<lambda>k. map_of (RBT_Impl.entries t2) k = None\"] intro!: arg_cong[where f=\"\\<lambda>x. map_of (RBT_Impl.entries t1) |` x\"] dest: map_of_eq_None_iff[THEN iffD1] intro: map_of_eq_None_iff[THEN iffD2])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsection \\<open>Type and operations\\<close>"], ["", "type_synonym 'a set_rbt = \"('a, unit) mapping_rbt\""], ["", "translations \n  (type) \"'a set_rbt\" <= (type) \"('a, unit) mapping_rbt\""], ["", "abbreviation (input) Set_RBT :: \"('a :: ccompare, unit) RBT_Impl.rbt \\<Rightarrow> 'a set_rbt\"\nwhere \"Set_RBT \\<equiv> Mapping_RBT\""], ["", "subsection \\<open>Primitive operations\\<close>"], ["", "lift_definition member :: \"'a :: ccompare set_rbt \\<Rightarrow> 'a \\<Rightarrow> bool\" is\n  \"\\<lambda>t x. x \\<in> dom (rbt_comp_lookup ccomp t)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "abbreviation empty :: \"'a :: ccompare set_rbt\"\nwhere \"empty \\<equiv> RBT_Mapping2.empty\""], ["", "abbreviation insert :: \"'a :: ccompare \\<Rightarrow> 'a set_rbt \\<Rightarrow> 'a set_rbt\" \nwhere \"insert k \\<equiv> RBT_Mapping2.insert k ()\""], ["", "abbreviation remove :: \"'a :: ccompare \\<Rightarrow> 'a set_rbt \\<Rightarrow> 'a set_rbt\"\nwhere \"remove \\<equiv> RBT_Mapping2.delete\""], ["", "lift_definition bulkload :: \"'a :: ccompare list \\<Rightarrow> 'a set_rbt\" is\n  \"rbt_comp_bulkload ccomp \\<circ> map (\\<lambda>x. (x, ()))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list.\n       ord.is_rbt cless\n        ((rbt_comp_bulkload ccomp \\<circ> map (\\<lambda>x. (x, ())))\n          list) \\<or>\n       ID ccompare = None", "by(auto 4 3 intro: linorder.rbt_bulkload_is_rbt ID_ccompare simp: rbt_comp_bulkload[OF ID_ccompare'])"], ["", "abbreviation is_empty :: \"'a :: ccompare set_rbt \\<Rightarrow> bool\"\nwhere \"is_empty \\<equiv> RBT_Mapping2.is_empty\""], ["", "abbreviation union :: \"'a :: ccompare set_rbt \\<Rightarrow> 'a set_rbt \\<Rightarrow> 'a set_rbt\"\nwhere \"union \\<equiv> RBT_Mapping2.join (\\<lambda>_ _. id)\""], ["", "abbreviation inter :: \"'a :: ccompare set_rbt \\<Rightarrow> 'a set_rbt \\<Rightarrow> 'a set_rbt\"\nwhere \"inter \\<equiv> RBT_Mapping2.meet (\\<lambda>_ _. id)\""], ["", "lift_definition inter_list :: \"'a :: ccompare set_rbt \\<Rightarrow> 'a list \\<Rightarrow> 'a set_rbt\" is\n  \"\\<lambda>t xs. fold (\\<lambda>k. rbt_comp_insert ccomp k ()) [x \\<leftarrow> xs. rbt_comp_lookup ccomp t x \\<noteq> None] RBT_Impl.Empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rbt list.\n       ord.is_rbt cless rbt \\<or> ID ccompare = None \\<Longrightarrow>\n       ord.is_rbt cless\n        (fold (\\<lambda>k. rbt_comp_insert ccomp k ())\n          (filter (\\<lambda>x. rbt_comp_lookup ccomp rbt x \\<noteq> None)\n            list)\n          rbt.Empty) \\<or>\n       ID ccompare = None", "by(auto 4 3 intro: ID_ccompare linorder.is_rbt_fold_rbt_insert ord.Empty_is_rbt simp: rbt_comp_simps[OF ID_ccompare'])"], ["", "lift_definition minus :: \"'a :: ccompare set_rbt \\<Rightarrow> 'a set_rbt \\<Rightarrow> 'a set_rbt\" is \n  \"rbt_comp_minus ccomp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rbt1 rbt2.\n       \\<lbrakk>ord.is_rbt cless rbt1 \\<or> ID ccompare = None;\n        ord.is_rbt cless rbt2 \\<or> ID ccompare = None\\<rbrakk>\n       \\<Longrightarrow> ord.is_rbt cless\n                          (rbt_comp_minus ccomp rbt1 rbt2) \\<or>\n                         ID ccompare = None", "by(auto 4 3 intro: linorder.is_rbt_rbt_minus ID_ccompare simp: rbt_comp_minus[OF ID_ccompare'])"], ["", "abbreviation filter :: \"('a :: ccompare \\<Rightarrow> bool) \\<Rightarrow> 'a set_rbt \\<Rightarrow> 'a set_rbt\"\nwhere \"filter P \\<equiv> RBT_Mapping2.filter (P \\<circ> fst)\""], ["", "lift_definition fold :: \"('a :: ccompare \\<Rightarrow> 'b \\<Rightarrow> 'b) \\<Rightarrow> 'a set_rbt \\<Rightarrow> 'b \\<Rightarrow> 'b\" is \"\\<lambda>f. RBT_Impl.fold (\\<lambda>a _. f a)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition fold1 :: \"('a :: ccompare \\<Rightarrow> 'a \\<Rightarrow> 'a) \\<Rightarrow> 'a set_rbt \\<Rightarrow> 'a\" is \"RBT_Impl_fold1\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition keys :: \"'a :: ccompare set_rbt \\<Rightarrow> 'a list\" is \"RBT_Impl.keys\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "abbreviation all :: \"('a :: ccompare \\<Rightarrow> bool) \\<Rightarrow> 'a set_rbt \\<Rightarrow> bool\"\nwhere \"all P \\<equiv> RBT_Mapping2.all (\\<lambda>k _. P k)\""], ["", "abbreviation ex :: \"('a :: ccompare \\<Rightarrow> bool) \\<Rightarrow> 'a set_rbt \\<Rightarrow> bool\"\nwhere \"ex P \\<equiv> RBT_Mapping2.ex (\\<lambda>k _. P k)\""], ["", "definition product :: \"'a :: ccompare set_rbt \\<Rightarrow> 'b :: ccompare set_rbt \\<Rightarrow> ('a \\<times> 'b) set_rbt\"\nwhere \"product rbt1 rbt2 = RBT_Mapping2.product (\\<lambda>_ _ _ _. ()) rbt1 rbt2\""], ["", "abbreviation Id_on :: \"'a :: ccompare set_rbt \\<Rightarrow> ('a \\<times> 'a) set_rbt\"\nwhere \"Id_on \\<equiv> RBT_Mapping2.diag\""], ["", "abbreviation init :: \"'a :: ccompare set_rbt \\<Rightarrow> ('a, unit, 'a) rbt_generator_state\"\nwhere \"init \\<equiv> RBT_Mapping2.init\""], ["", "subsection \\<open>Properties\\<close>"], ["", "lemma member_empty [simp]:\n  \"member empty = (\\<lambda>_. False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. member RBT_Set2.empty = (\\<lambda>_. False)", "by(simp add: member_def empty_def Mapping_RBT_inverse ord.Empty_is_rbt ord.rbt_lookup.simps fun_eq_iff)"], ["", "lemma fold_conv_fold_keys: \"RBT_Set2.fold f rbt b = List.fold f (RBT_Set2.keys rbt) b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RBT_Set2.fold f rbt b = List.fold f (keys rbt) b", "by(simp add: RBT_Set2.fold_def RBT_Set2.keys_def RBT_Impl.fold_def RBT_Impl.keys_def fold_map o_def split_def)"], ["", "lemma fold_conv_fold_keys':\n  \"fold f t = List.fold f (RBT_Impl.keys (RBT_Mapping2.impl_of t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RBT_Set2.fold f t = List.fold f (RBT_Impl.keys (mapping_rbt.impl_of t))", "by(simp add: fold.rep_eq RBT_Impl.fold_def RBT_Impl.keys_def fold_map o_def split_def)"], ["", "lemma member_lookup [code]: \"member t x \\<longleftrightarrow> RBT_Mapping2.lookup t x = Some ()\""], ["proof (prove)\ngoal (1 subgoal):\n 1. member t x = (RBT_Mapping2.lookup t x = Some ())", "by transfer auto"], ["", "lemma unfoldr_rbt_keys_generator:\n  \"list.unfoldr rbt_keys_generator (init t) = keys t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.unfoldr rbt_keys_generator (init t) = keys t", "by transfer(simp add: unfoldr_rbt_keys_generator)"], ["", "lemma keys_eq_Nil_iff [simp]: \"keys rbt = [] \\<longleftrightarrow> rbt = empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (keys rbt = []) = (rbt = RBT_Set2.empty)", "by transfer(case_tac rbt, simp_all)"], ["", "lemma fold1_conv_fold: \"fold1 f rbt = List.fold f (tl (keys rbt)) (hd (keys rbt))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold1 f rbt = List.fold f (tl (keys rbt)) (hd (keys rbt))", "by transfer(simp add: RBT_Impl_fold1_def)"], ["", "context assumes ID_ccompare_neq_None: \"ID CCOMPARE('a :: ccompare) \\<noteq> None\"\nbegin"], ["", "lemma set_linorder: \"class.linorder (cless_eq :: 'a \\<Rightarrow> 'a \\<Rightarrow> bool) cless\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.linorder cless_eq cless", "using ID_ccompare_neq_None"], ["proof (prove)\nusing this:\n  ID ccompare \\<noteq> None\n\ngoal (1 subgoal):\n 1. class.linorder cless_eq cless", "by(clarsimp)(rule ID_ccompare)"], ["", "lemma ccomp_comparator: \"comparator (ccomp :: 'a comparator)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator ccomp", "using ID_ccompare_neq_None"], ["proof (prove)\nusing this:\n  ID ccompare \\<noteq> None\n\ngoal (1 subgoal):\n 1. comparator ccomp", "by(clarsimp)(rule ID_ccompare')"], ["", "lemmas rbt_comps = rbt_comp_simps[OF ccomp_comparator] rbt_comp_minus[OF ccomp_comparator]"], ["", "lemma is_rbt_impl_of [simp, intro]:\n  fixes t :: \"'a set_rbt\"\n  shows \"ord.is_rbt cless (RBT_Mapping2.impl_of t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord.is_rbt cless (mapping_rbt.impl_of t)", "using ID_ccompare_neq_None impl_of [of t]"], ["proof (prove)\nusing this:\n  ID ccompare \\<noteq> None\n  mapping_rbt.impl_of t\n  \\<in> {t. ord.is_rbt cless t \\<or> ID ccompare = None}\n\ngoal (1 subgoal):\n 1. ord.is_rbt cless (mapping_rbt.impl_of t)", "by auto"], ["", "lemma member_RBT:\n  \"ord.is_rbt cless t \\<Longrightarrow> member (Set_RBT t) (x :: 'a) \\<longleftrightarrow> ord.rbt_lookup cless t x = Some ()\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord.is_rbt cless t \\<Longrightarrow>\n    member (Mapping_RBT t) x = (ord.rbt_lookup cless t x = Some ())", "by(auto simp add: member_def Mapping_RBT_inverse rbt_comps)"], ["", "lemma member_impl_of:\n  \"ord.rbt_lookup cless (RBT_Mapping2.impl_of t) (x :: 'a) = Some () \\<longleftrightarrow> member t x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ord.rbt_lookup cless (mapping_rbt.impl_of t) x = Some ()) = member t x", "by transfer (auto simp: rbt_comps)"], ["", "lemma member_insert [simp]:\n  \"member (insert x (t :: 'a set_rbt)) = (member t)(x := True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. member (RBT_Set2.insert x t) = (member t)(x := True)", "by transfer (simp add: fun_eq_iff linorder.rbt_lookup_rbt_insert[OF set_linorder] ID_ccompare_neq_None)"], ["", "lemma member_fold_insert [simp]:\n  \"member (List.fold insert xs (t :: 'a set_rbt)) = (\\<lambda>x. member t x \\<or> x \\<in> set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. member (List.fold RBT_Set2.insert xs t) =\n    (\\<lambda>x. member t x \\<or> x \\<in> set xs)", "by(induct xs arbitrary: t) auto"], ["", "lemma member_remove [simp]:\n  \"member (remove (x :: 'a) t) = (member t)(x := False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. member (remove x t) = (member t)(x := False)", "by transfer (simp add: linorder.rbt_lookup_rbt_delete[OF set_linorder] ID_ccompare_neq_None fun_eq_iff)"], ["", "lemma member_bulkload [simp]:\n  \"member (bulkload xs) (x :: 'a) \\<longleftrightarrow> x \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. member (bulkload xs) x = (x \\<in> set xs)", "by transfer (auto simp add: linorder.rbt_lookup_rbt_bulkload[OF set_linorder] rbt_comps map_of_map_Pair_const split: if_split_asm)"], ["", "lemma member_conv_keys: \"member t = (\\<lambda>x :: 'a. x \\<in> set (keys t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. member t = (\\<lambda>x. x \\<in> set (keys t))", "by(transfer)(simp add: ID_ccompare_neq_None linorder.rbt_lookup_keys[OF set_linorder] ord.is_rbt_rbt_sorted)"], ["", "lemma is_empty_empty [simp]:\n  \"is_empty t \\<longleftrightarrow> t = empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RBT_Set2.is_empty t = (t = RBT_Set2.empty)", "by transfer (simp split: rbt.split)"], ["", "lemma RBT_lookup_empty [simp]:\n  \"ord.rbt_lookup cless (t :: ('a, unit) rbt) = Map.empty \\<longleftrightarrow> t = RBT_Impl.Empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ord.rbt_lookup cless t = Map.empty) = (t = rbt.Empty)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (ord.rbt_lookup cless t = Map.empty) = (t = rbt.Empty)", "interpret linorder \"cless_eq :: 'a \\<Rightarrow> 'a \\<Rightarrow> bool\" cless"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.linorder cless_eq cless", "by(rule set_linorder)"], ["proof (state)\ngoal (1 subgoal):\n 1. (local.rbt_lookup t = Map.empty) = (t = rbt.Empty)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.rbt_lookup t = Map.empty) = (t = rbt.Empty)", "by(cases t)(auto simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  (local.rbt_lookup t = Map.empty) = (t = rbt.Empty)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma member_empty_empty [simp]:\n  \"member t = (\\<lambda>_. False) \\<longleftrightarrow> (t :: 'a set_rbt) = empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (member t = (\\<lambda>_. False)) = (t = RBT_Set2.empty)", "by transfer(simp add: ID_ccompare_neq_None fun_eq_iff RBT_lookup_empty[symmetric])"], ["", "lemma member_union [simp]:\n  \"member (union (t1 :: 'a set_rbt) t2) = (\\<lambda>x. member t1 x \\<or> member t2 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. member (RBT_Set2.union t1 t2) =\n    (\\<lambda>x. member t1 x \\<or> member t2 x)", "by(auto simp add: member_lookup fun_eq_iff lookup_join[OF ID_ccompare_neq_None] split: option.split)"], ["", "lemma member_minus [simp]:\n  \"member (minus (t1 :: 'a set_rbt) t2) = (\\<lambda>x. member t1 x \\<and> \\<not> member t2 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. member (RBT_Set2.minus t1 t2) =\n    (\\<lambda>x. member t1 x \\<and> \\<not> member t2 x)", "by(transfer)(auto simp add: ID_ccompare_neq_None fun_eq_iff rbt_comps linorder.rbt_lookup_rbt_minus[OF set_linorder] ord.is_rbt_rbt_sorted)"], ["", "lemma member_inter [simp]:\n  \"member (inter (t1 :: 'a set_rbt) t2) = (\\<lambda>x. member t1 x \\<and> member t2 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. member (RBT_Set2.inter t1 t2) =\n    (\\<lambda>x. member t1 x \\<and> member t2 x)", "by(auto simp add: member_lookup fun_eq_iff lookup_meet[OF ID_ccompare_neq_None] split: option.split)"], ["", "lemma member_inter_list [simp]:\n  \"member (inter_list (t :: 'a set_rbt) xs) = (\\<lambda>x. member t x \\<and> x \\<in> set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. member (inter_list t xs) =\n    (\\<lambda>x. member t x \\<and> x \\<in> set xs)", "by transfer(auto simp add: ID_ccompare_neq_None fun_eq_iff linorder.rbt_lookup_fold_rbt_insert[OF set_linorder] ord.Empty_is_rbt map_of_map_Pair_key ord.rbt_lookup.simps rel_option_iff split: if_split_asm option.split_asm)"], ["", "lemma member_filter [simp]:\n  \"member (filter P (t :: 'a set_rbt)) = (\\<lambda>x. member t x \\<and> P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. member (RBT_Set2.filter P t) = (\\<lambda>x. member t x \\<and> P x)", "by(simp add: member_lookup fun_eq_iff lookup_filter[OF ID_ccompare_neq_None] split: option.split)"], ["", "lemma distinct_keys [simp]:\n  \"distinct (keys (rbt :: 'a set_rbt))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (keys rbt)", "by transfer(simp add: ID_ccompare_neq_None RBT_Impl.keys_def ord.is_rbt_rbt_sorted linorder.distinct_entries[OF set_linorder])"], ["", "lemma all_conv_all_member:\n  \"all P t \\<longleftrightarrow> (\\<forall>x :: 'a. member t x \\<longrightarrow> P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all P t = (\\<forall>x. member t x \\<longrightarrow> P x)", "by(simp add: member_lookup all_conv_all_lookup[OF ID_ccompare_neq_None])"], ["", "lemma ex_conv_ex_member:\n  \"ex P t \\<longleftrightarrow> (\\<exists>x :: 'a. member t x \\<and> P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ex P t = (\\<exists>x. member t x \\<and> P x)", "by(simp add: member_lookup ex_conv_ex_lookup[OF ID_ccompare_neq_None])"], ["", "lemma finite_member: \"finite (Collect (RBT_Set2.member (t :: 'a set_rbt)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Collect (member t))", "by transfer (simp add: rbt_comps linorder.finite_dom_rbt_lookup[OF set_linorder])"], ["", "lemma member_Id_on: \"member (Id_on t) = (\\<lambda>(k :: 'a, k'). k = k' \\<and> member t k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. member (RBT_Set2.Id_on t) = (\\<lambda>(k, k'). k = k' \\<and> member t k)", "by(simp add: member_lookup[abs_def] diag_lookup[OF ID_ccompare_neq_None] fun_eq_iff)"], ["", "context assumes ID_ccompare_neq_None': \"ID CCOMPARE('b :: ccompare) \\<noteq> None\"\nbegin"], ["", "lemma set_linorder': \"class.linorder (cless_eq :: 'b \\<Rightarrow> 'b \\<Rightarrow> bool) cless\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.linorder cless_eq cless", "using ID_ccompare_neq_None'"], ["proof (prove)\nusing this:\n  ID ccompare \\<noteq> None\n\ngoal (1 subgoal):\n 1. class.linorder cless_eq cless", "by(clarsimp)(rule ID_ccompare)"], ["", "lemma member_product:\n  \"member (product rbt1 rbt2) = (\\<lambda>ab :: 'a \\<times> 'b. ab \\<in> Collect (member rbt1) \\<times> Collect (member rbt2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. member (product rbt1 rbt2) =\n    (\\<lambda>ab.\n        ab \\<in> Collect (member rbt1) \\<times> Collect (member rbt2))", "by(auto simp add: fun_eq_iff member_lookup product_def RBT_Mapping2.lookup_product ID_ccompare_neq_None ID_ccompare_neq_None' split: option.splits)"], ["", "end"], ["", "end"], ["", "lemma sorted_RBT_Set_keys: \n  \"ID CCOMPARE('a :: ccompare) = Some c \n  \\<Longrightarrow> linorder.sorted (le_of_comp c) (RBT_Set2.keys rbt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ID ccompare = Some c \\<Longrightarrow>\n    linorder.sorted (le_of_comp c) (keys rbt)", "by transfer(auto simp add: RBT_Set2.keys.rep_eq RBT_Impl.keys_def linorder.rbt_sorted_entries[OF ID_ccompare] ord.is_rbt_rbt_sorted)"], ["", "context assumes ID_ccompare_neq_None: \"ID CCOMPARE('a :: {ccompare, lattice}) \\<noteq> None\"\nbegin"], ["", "lemma set_linorder2: \"class.linorder (cless_eq :: 'a \\<Rightarrow> 'a \\<Rightarrow> bool) cless\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.linorder cless_eq cless", "using ID_ccompare_neq_None"], ["proof (prove)\nusing this:\n  ID ccompare \\<noteq> None\n\ngoal (1 subgoal):\n 1. class.linorder cless_eq cless", "by(clarsimp)(rule ID_ccompare)"], ["", "end"], ["", "lemma set_keys_Mapping_RBT: \"set (keys (Mapping_RBT t)) = set (RBT_Impl.keys t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (keys (Mapping_RBT t)) = set (RBT_Impl.keys t)", "proof(cases t)"], ["proof (state)\ngoal (2 subgoals):\n 1. t = rbt.Empty \\<Longrightarrow>\n    set (keys (Mapping_RBT t)) = set (RBT_Impl.keys t)\n 2. \\<And>x21 x22 x23 x24 x25.\n       t = Branch x21 x22 x23 x24 x25 \\<Longrightarrow>\n       set (keys (Mapping_RBT t)) = set (RBT_Impl.keys t)", "case Empty"], ["proof (state)\nthis:\n  t = rbt.Empty\n\ngoal (2 subgoals):\n 1. t = rbt.Empty \\<Longrightarrow>\n    set (keys (Mapping_RBT t)) = set (RBT_Impl.keys t)\n 2. \\<And>x21 x22 x23 x24 x25.\n       t = Branch x21 x22 x23 x24 x25 \\<Longrightarrow>\n       set (keys (Mapping_RBT t)) = set (RBT_Impl.keys t)", "thus ?thesis"], ["proof (prove)\nusing this:\n  t = rbt.Empty\n\ngoal (1 subgoal):\n 1. set (keys (Mapping_RBT t)) = set (RBT_Impl.keys t)", "by(clarsimp simp add: Mapping_RBT_def keys.rep_eq is_ccompare_def Mapping_RBT'_inverse ord.is_rbt_def ord.rbt_sorted.simps)"], ["proof (state)\nthis:\n  set (keys (Mapping_RBT t)) = set (RBT_Impl.keys t)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23 x24 x25.\n       t = Branch x21 x22 x23 x24 x25 \\<Longrightarrow>\n       set (keys (Mapping_RBT t)) = set (RBT_Impl.keys t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23 x24 x25.\n       t = Branch x21 x22 x23 x24 x25 \\<Longrightarrow>\n       set (keys (Mapping_RBT t)) = set (RBT_Impl.keys t)", "case (Branch c l k v r)"], ["proof (state)\nthis:\n  t = Branch c l k v r\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23 x24 x25.\n       t = Branch x21 x22 x23 x24 x25 \\<Longrightarrow>\n       set (keys (Mapping_RBT t)) = set (RBT_Impl.keys t)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (keys (Mapping_RBT t)) = set (RBT_Impl.keys t)", "proof(cases \"is_ccompare TYPE('a) \\<and> \\<not> ord.is_rbt cless (Branch c l k v r)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is_ccompare TYPE('a) \\<and>\n    \\<not> ord.is_rbt cless (Branch c l k v r) \\<Longrightarrow>\n    set (keys (Mapping_RBT t)) = set (RBT_Impl.keys t)\n 2. \\<not> (is_ccompare TYPE('a) \\<and>\n            \\<not> ord.is_rbt cless (Branch c l k v r)) \\<Longrightarrow>\n    set (keys (Mapping_RBT t)) = set (RBT_Impl.keys t)", "case False"], ["proof (state)\nthis:\n  \\<not> (is_ccompare TYPE('a) \\<and>\n          \\<not> ord.is_rbt cless (Branch c l k v r))\n\ngoal (2 subgoals):\n 1. is_ccompare TYPE('a) \\<and>\n    \\<not> ord.is_rbt cless (Branch c l k v r) \\<Longrightarrow>\n    set (keys (Mapping_RBT t)) = set (RBT_Impl.keys t)\n 2. \\<not> (is_ccompare TYPE('a) \\<and>\n            \\<not> ord.is_rbt cless (Branch c l k v r)) \\<Longrightarrow>\n    set (keys (Mapping_RBT t)) = set (RBT_Impl.keys t)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (is_ccompare TYPE('a) \\<and>\n          \\<not> ord.is_rbt cless (Branch c l k v r))\n\ngoal (1 subgoal):\n 1. set (keys (Mapping_RBT t)) = set (RBT_Impl.keys t)", "using Branch"], ["proof (prove)\nusing this:\n  \\<not> (is_ccompare TYPE('a) \\<and>\n          \\<not> ord.is_rbt cless (Branch c l k v r))\n  t = Branch c l k v r\n\ngoal (1 subgoal):\n 1. set (keys (Mapping_RBT t)) = set (RBT_Impl.keys t)", "by(auto simp add: Mapping_RBT_def keys.rep_eq is_ccompare_def Mapping_RBT'_inverse simp del: not_None_eq)"], ["proof (state)\nthis:\n  set (keys (Mapping_RBT t)) = set (RBT_Impl.keys t)\n\ngoal (1 subgoal):\n 1. is_ccompare TYPE('a) \\<and>\n    \\<not> ord.is_rbt cless (Branch c l k v r) \\<Longrightarrow>\n    set (keys (Mapping_RBT t)) = set (RBT_Impl.keys t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. is_ccompare TYPE('a) \\<and>\n    \\<not> ord.is_rbt cless (Branch c l k v r) \\<Longrightarrow>\n    set (keys (Mapping_RBT t)) = set (RBT_Impl.keys t)", "case True"], ["proof (state)\nthis:\n  is_ccompare TYPE('a) \\<and> \\<not> ord.is_rbt cless (Branch c l k v r)\n\ngoal (1 subgoal):\n 1. is_ccompare TYPE('a) \\<and>\n    \\<not> ord.is_rbt cless (Branch c l k v r) \\<Longrightarrow>\n    set (keys (Mapping_RBT t)) = set (RBT_Impl.keys t)", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_ccompare TYPE('a) \\<and> \\<not> ord.is_rbt cless (Branch c l k v r)\n\ngoal (1 subgoal):\n 1. set (keys (Mapping_RBT t)) = set (RBT_Impl.keys t)", "using Branch"], ["proof (prove)\nusing this:\n  is_ccompare TYPE('a) \\<and> \\<not> ord.is_rbt cless (Branch c l k v r)\n  t = Branch c l k v r\n\ngoal (1 subgoal):\n 1. set (keys (Mapping_RBT t)) = set (RBT_Impl.keys t)", "by(clarsimp simp add: Mapping_RBT_def keys.rep_eq is_ccompare_def Mapping_RBT'_inverse RBT_ext.linorder.is_rbt_fold_rbt_insert_impl[OF ID_ccompare] linorder.rbt_insert_is_rbt[OF ID_ccompare] ord.Empty_is_rbt)(subst linorder.rbt_lookup_keys[OF ID_ccompare, symmetric], assumption, auto simp add: linorder.rbt_sorted_fold_insert[OF ID_ccompare] RBT_ext.linorder.rbt_lookup_fold_rbt_insert_impl[OF ID_ccompare] RBT_ext.linorder.rbt_lookup_rbt_insert'[OF ID_ccompare] linorder.rbt_insert_rbt_sorted[OF ID_ccompare] ord.is_rbt_rbt_sorted ord.Empty_is_rbt dom_map_of_conv_image_fst RBT_Impl.keys_def ord.rbt_lookup.simps)"], ["proof (state)\nthis:\n  set (keys (Mapping_RBT t)) = set (RBT_Impl.keys t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (keys (Mapping_RBT t)) = set (RBT_Impl.keys t)\n\ngoal:\nNo subgoals!", "qed"], ["", "hide_const (open) member empty insert remove bulkload union minus\n  keys fold fold_rev filter all ex product Id_on init"], ["", "end"]]}