{"file_name": "/home/qj213/afp-2021-10-22/thys/Containers/Collection_Enum.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Containers", "problem_names": ["lemma ID_cEnum: \n  \"ID cEnum = Some (enum, enum_all, enum_ex)\n  \\<Longrightarrow> UNIV = set enum \\<and> enum_all = Ball UNIV \\<and> enum_ex = Bex UNIV\"", "lemma in_cenum: \"ID cEnum = Some (enum, rest) \\<Longrightarrow> f \\<in> set enum\"", "lemma all_n_lists_iff: fixes cenum shows\n  \"all_n_lists (Ball (set cenum)) P n \\<longleftrightarrow> (\\<forall>xs \\<in> set (List.n_lists n cenum). P xs)\"", "lemma ex_n_lists_iff: fixes cenum shows\n  \"ex_n_lists (Bex (set cenum)) P n \\<longleftrightarrow> (\\<exists>xs \\<in> set (List.n_lists n cenum). P xs)\""], "translations": [["", "lemma ID_cEnum: \n  \"ID cEnum = Some (enum, enum_all, enum_ex)\n  \\<Longrightarrow> UNIV = set enum \\<and> enum_all = Ball UNIV \\<and> enum_ex = Bex UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ID cEnum = Some (enum, enum_all, enum_ex) \\<Longrightarrow>\n    UNIV = set enum \\<and> enum_all = Ball UNIV \\<and> enum_ex = Bex UNIV", "unfolding ID_def id_apply fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. cEnum = Some (enum, enum_all, enum_ex) \\<Longrightarrow>\n    UNIV = set enum \\<and>\n    (\\<forall>x. enum_all x = Ball UNIV x) \\<and>\n    (\\<forall>x. enum_ex x = Bex UNIV x)", "by(intro conjI allI UNIV_cenum cenum_all_UNIV cenum_ex_UNIV fun_eq_iff)"], ["", "lemma in_cenum: \"ID cEnum = Some (enum, rest) \\<Longrightarrow> f \\<in> set enum\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ID cEnum = Some (enum, rest) \\<Longrightarrow> f \\<in> set enum", "by(cases rest)(auto dest: ID_cEnum)"], ["", "abbreviation cenum :: \"'a list\" \nwhere \"cenum \\<equiv> fst (the (ID cEnum))\""], ["", "abbreviation cenum_all :: \"('a \\<Rightarrow> bool) \\<Rightarrow> bool\" \nwhere \"cenum_all \\<equiv> fst (snd (the (ID cEnum)))\""], ["", "abbreviation cenum_ex :: \"('a \\<Rightarrow> bool) \\<Rightarrow> bool\" \nwhere \"cenum_ex \\<equiv> snd (snd (the (ID cEnum)))\""], ["", "end"], ["", "syntax \"_CENUM\" :: \"type => logic\"  (\"(1CENUM/(1'(_')))\")"], ["", "parse_translation \\<open>\nlet\n  fun cenum_tr [ty] =\n     (Syntax.const @{syntax_const \"_constrain\"} $ Syntax.const @{const_syntax \"cEnum\"} $\n       (Syntax.const @{type_syntax option} $ \n         (Syntax.const @{type_syntax prod} $\n           (Syntax.const @{type_syntax list} $ ty) $\n           (Syntax.const @{type_syntax prod} $\n             (Syntax.const @{type_syntax fun} $\n               (Syntax.const @{type_syntax fun} $ ty $ (Syntax.const @{type_syntax bool})) $\n               (Syntax.const @{type_syntax bool})) $\n             (Syntax.const @{type_syntax fun} $\n               (Syntax.const @{type_syntax fun} $ ty $ (Syntax.const @{type_syntax bool})) $\n               (Syntax.const @{type_syntax bool}))))))\n    | cenum_tr ts = raise TERM (\"cenum_tr\", ts);\nin [(@{syntax_const \"_CENUM\"}, K cenum_tr)] end\n\\<close>"], ["", "typed_print_translation \\<open>\nlet\n  fun cenum_tr' ctxt\n    (Type (@{type_name option}, [Type (@{type_name prod}, [Type (@{type_name list}, [T]), _])])) ts =\n    Term.list_comb (Syntax.const @{syntax_const \"_CENUM\"} $ Syntax_Phases.term_of_typ ctxt T, ts)\n  | cenum_tr' _ _ _ = raise Match;\nin [(@{const_syntax cEnum}, cenum_tr')]\nend\n\\<close>"], ["", "subsection \\<open>Generator for the @{class cenum}-class\\<close>"], ["", "text \\<open>\nThis generator registers itself at the derive-manager for the class @{class cenum}.\nTo be more precise, one can currently only choose to not support enumeration \nby passing \"no\" as parameter.  \n\n\\begin{itemize}\n\\item \\texttt{instantiation type :: (type,\\ldots,type) (no) cenum}\n\\end{itemize}\n\\<close>"], ["", "text \\<open>\nThis generator can be used for arbitrary types, not just datatypes. \n\\<close>"], ["", "ML_file \\<open>cenum_generator.ML\\<close>"], ["", "subsection \\<open>Instantiations\\<close>"], ["", "context fixes cenum_all :: \"('a \\<Rightarrow> bool) \\<Rightarrow> bool\" begin"], ["", "fun all_n_lists :: \"('a list \\<Rightarrow> bool) \\<Rightarrow> nat \\<Rightarrow> bool\"\nwhere [simp del]:\n  \"all_n_lists P n = (if n = 0 then P [] else cenum_all (\\<lambda>x. all_n_lists (\\<lambda>xs. P (x # xs)) (n - 1)))\""], ["", "end"], ["", "context fixes cenum_ex :: \"('a \\<Rightarrow> bool) \\<Rightarrow> bool\" begin"], ["", "fun ex_n_lists :: \"('a list \\<Rightarrow> bool) \\<Rightarrow> nat \\<Rightarrow> bool\"\nwhere [simp del]:\n  \"ex_n_lists P n \\<longleftrightarrow> (if n = 0 then P [] else cenum_ex (%x. ex_n_lists (%xs. P (x # xs)) (n - 1)))\""], ["", "end"], ["", "lemma all_n_lists_iff: fixes cenum shows\n  \"all_n_lists (Ball (set cenum)) P n \\<longleftrightarrow> (\\<forall>xs \\<in> set (List.n_lists n cenum). P xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_n_lists (Ball (set cenum)) P n =\n    (\\<forall>xs\\<in>set (List.n_lists n cenum). P xs)", "proof(induct P n rule: all_n_lists.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P n.\n       (\\<And>x.\n           n \\<noteq> 0 \\<Longrightarrow>\n           all_n_lists (Ball (set cenum)) (\\<lambda>a. P (x # a)) (n - 1) =\n           (\\<forall>xs\\<in>set (List.n_lists (n - 1) cenum).\n               P (x # xs))) \\<Longrightarrow>\n       all_n_lists (Ball (set cenum)) P n =\n       (\\<forall>xs\\<in>set (List.n_lists n cenum). P xs)", "case (1 P n)"], ["proof (state)\nthis:\n  n \\<noteq> 0 \\<Longrightarrow>\n  all_n_lists (Ball (set cenum)) (\\<lambda>a. P (?x # a)) (n - 1) =\n  (\\<forall>xs\\<in>set (List.n_lists (n - 1) cenum). P (?x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>P n.\n       (\\<And>x.\n           n \\<noteq> 0 \\<Longrightarrow>\n           all_n_lists (Ball (set cenum)) (\\<lambda>a. P (x # a)) (n - 1) =\n           (\\<forall>xs\\<in>set (List.n_lists (n - 1) cenum).\n               P (x # xs))) \\<Longrightarrow>\n       all_n_lists (Ball (set cenum)) P n =\n       (\\<forall>xs\\<in>set (List.n_lists n cenum). P xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. all_n_lists (Ball (set cenum)) P n =\n    (\\<forall>xs\\<in>set (List.n_lists n cenum). P xs)", "proof(cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    all_n_lists (Ball (set cenum)) P n =\n    (\\<forall>xs\\<in>set (List.n_lists n cenum). P xs)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       all_n_lists (Ball (set cenum)) P n =\n       (\\<forall>xs\\<in>set (List.n_lists n cenum). P xs)", "case 0"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    all_n_lists (Ball (set cenum)) P n =\n    (\\<forall>xs\\<in>set (List.n_lists n cenum). P xs)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       all_n_lists (Ball (set cenum)) P n =\n       (\\<forall>xs\\<in>set (List.n_lists n cenum). P xs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. all_n_lists (Ball (set cenum)) P n =\n    (\\<forall>xs\\<in>set (List.n_lists n cenum). P xs)", "by(simp add: all_n_lists.simps)"], ["proof (state)\nthis:\n  all_n_lists (Ball (set cenum)) P n =\n  (\\<forall>xs\\<in>set (List.n_lists n cenum). P xs)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       all_n_lists (Ball (set cenum)) P n =\n       (\\<forall>xs\\<in>set (List.n_lists n cenum). P xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       all_n_lists (Ball (set cenum)) P n =\n       (\\<forall>xs\\<in>set (List.n_lists n cenum). P xs)", "case (Suc n')"], ["proof (state)\nthis:\n  n = Suc n'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       all_n_lists (Ball (set cenum)) P n =\n       (\\<forall>xs\\<in>set (List.n_lists n cenum). P xs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  n = Suc n'\n\ngoal (1 subgoal):\n 1. all_n_lists (Ball (set cenum)) P n =\n    (\\<forall>xs\\<in>set (List.n_lists n cenum). P xs)", "using \"1\""], ["proof (prove)\nusing this:\n  n = Suc n'\n  n \\<noteq> 0 \\<Longrightarrow>\n  all_n_lists (Ball (set cenum)) (\\<lambda>a. P (?x # a)) (n - 1) =\n  (\\<forall>xs\\<in>set (List.n_lists (n - 1) cenum). P (?x # xs))\n\ngoal (1 subgoal):\n 1. all_n_lists (Ball (set cenum)) P n =\n    (\\<forall>xs\\<in>set (List.n_lists n cenum). P xs)", "by(subst all_n_lists.simps) auto"], ["proof (state)\nthis:\n  all_n_lists (Ball (set cenum)) P n =\n  (\\<forall>xs\\<in>set (List.n_lists n cenum). P xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  all_n_lists (Ball (set cenum)) P n =\n  (\\<forall>xs\\<in>set (List.n_lists n cenum). P xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ex_n_lists_iff: fixes cenum shows\n  \"ex_n_lists (Bex (set cenum)) P n \\<longleftrightarrow> (\\<exists>xs \\<in> set (List.n_lists n cenum). P xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ex_n_lists (Bex (set cenum)) P n =\n    (\\<exists>xs\\<in>set (List.n_lists n cenum). P xs)", "proof(induct P n rule: ex_n_lists.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P n.\n       (\\<And>x.\n           n \\<noteq> 0 \\<Longrightarrow>\n           ex_n_lists (Bex (set cenum)) (\\<lambda>a. P (x # a)) (n - 1) =\n           (\\<exists>xs\\<in>set (List.n_lists (n - 1) cenum).\n               P (x # xs))) \\<Longrightarrow>\n       ex_n_lists (Bex (set cenum)) P n =\n       (\\<exists>xs\\<in>set (List.n_lists n cenum). P xs)", "case (1 P n)"], ["proof (state)\nthis:\n  n \\<noteq> 0 \\<Longrightarrow>\n  ex_n_lists (Bex (set cenum)) (\\<lambda>a. P (?x # a)) (n - 1) =\n  (\\<exists>xs\\<in>set (List.n_lists (n - 1) cenum). P (?x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>P n.\n       (\\<And>x.\n           n \\<noteq> 0 \\<Longrightarrow>\n           ex_n_lists (Bex (set cenum)) (\\<lambda>a. P (x # a)) (n - 1) =\n           (\\<exists>xs\\<in>set (List.n_lists (n - 1) cenum).\n               P (x # xs))) \\<Longrightarrow>\n       ex_n_lists (Bex (set cenum)) P n =\n       (\\<exists>xs\\<in>set (List.n_lists n cenum). P xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ex_n_lists (Bex (set cenum)) P n =\n    (\\<exists>xs\\<in>set (List.n_lists n cenum). P xs)", "proof(cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    ex_n_lists (Bex (set cenum)) P n =\n    (\\<exists>xs\\<in>set (List.n_lists n cenum). P xs)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ex_n_lists (Bex (set cenum)) P n =\n       (\\<exists>xs\\<in>set (List.n_lists n cenum). P xs)", "case 0"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    ex_n_lists (Bex (set cenum)) P n =\n    (\\<exists>xs\\<in>set (List.n_lists n cenum). P xs)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ex_n_lists (Bex (set cenum)) P n =\n       (\\<exists>xs\\<in>set (List.n_lists n cenum). P xs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. ex_n_lists (Bex (set cenum)) P n =\n    (\\<exists>xs\\<in>set (List.n_lists n cenum). P xs)", "by(simp add: ex_n_lists.simps)"], ["proof (state)\nthis:\n  ex_n_lists (Bex (set cenum)) P n =\n  (\\<exists>xs\\<in>set (List.n_lists n cenum). P xs)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ex_n_lists (Bex (set cenum)) P n =\n       (\\<exists>xs\\<in>set (List.n_lists n cenum). P xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ex_n_lists (Bex (set cenum)) P n =\n       (\\<exists>xs\\<in>set (List.n_lists n cenum). P xs)", "case (Suc n')"], ["proof (state)\nthis:\n  n = Suc n'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ex_n_lists (Bex (set cenum)) P n =\n       (\\<exists>xs\\<in>set (List.n_lists n cenum). P xs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  n = Suc n'\n\ngoal (1 subgoal):\n 1. ex_n_lists (Bex (set cenum)) P n =\n    (\\<exists>xs\\<in>set (List.n_lists n cenum). P xs)", "using \"1\""], ["proof (prove)\nusing this:\n  n = Suc n'\n  n \\<noteq> 0 \\<Longrightarrow>\n  ex_n_lists (Bex (set cenum)) (\\<lambda>a. P (?x # a)) (n - 1) =\n  (\\<exists>xs\\<in>set (List.n_lists (n - 1) cenum). P (?x # xs))\n\ngoal (1 subgoal):\n 1. ex_n_lists (Bex (set cenum)) P n =\n    (\\<exists>xs\\<in>set (List.n_lists n cenum). P xs)", "by(subst ex_n_lists.simps) auto"], ["proof (state)\nthis:\n  ex_n_lists (Bex (set cenum)) P n =\n  (\\<exists>xs\\<in>set (List.n_lists n cenum). P xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ex_n_lists (Bex (set cenum)) P n =\n  (\\<exists>xs\\<in>set (List.n_lists n cenum). P xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "instantiation \"fun\" :: (cenum, cenum) cenum begin"], ["", "definition \n  \"CENUM('a \\<Rightarrow> 'b) =\n  (case ID CENUM('a) of None \\<Rightarrow> None | Some (enum_a, enum_all_a, enum_ex_a) \\<Rightarrow>\n     case ID CENUM('b) of None \\<Rightarrow> None | Some (enum_b, enum_all_b, enum_ex_b) \\<Rightarrow> Some \n       (map (\\<lambda>ys. the o map_of (zip enum_a ys)) (List.n_lists (length enum_a) enum_b),\n        \\<lambda>P. all_n_lists enum_all_b (\\<lambda>bs. P (the o map_of (zip enum_a bs))) (length enum_a),\n        \\<lambda>P. ex_n_lists enum_ex_b (\\<lambda>bs. P (the o map_of (zip enum_a bs))) (length enum_a)))\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow> 'b, cenum_class)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>enum enum_all enum_ex.\n       CENUM('a \\<Rightarrow> 'b) =\n       Some (enum, enum_all, enum_ex) \\<Longrightarrow>\n       UNIV = set enum\n 2. \\<And>enum enum_all enum_ex P.\n       CENUM('a \\<Rightarrow> 'b) =\n       Some (enum, enum_all, enum_ex) \\<Longrightarrow>\n       enum_all P = Ball UNIV P\n 3. \\<And>enum enum_all enum_ex P.\n       CENUM('a \\<Rightarrow> 'b) =\n       Some (enum, enum_all, enum_ex) \\<Longrightarrow>\n       enum_ex P = Bex UNIV P", "fix enum enum_all enum_ex P"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>enum enum_all enum_ex.\n       CENUM('a \\<Rightarrow> 'b) =\n       Some (enum, enum_all, enum_ex) \\<Longrightarrow>\n       UNIV = set enum\n 2. \\<And>enum enum_all enum_ex P.\n       CENUM('a \\<Rightarrow> 'b) =\n       Some (enum, enum_all, enum_ex) \\<Longrightarrow>\n       enum_all P = Ball UNIV P\n 3. \\<And>enum enum_all enum_ex P.\n       CENUM('a \\<Rightarrow> 'b) =\n       Some (enum, enum_all, enum_ex) \\<Longrightarrow>\n       enum_ex P = Bex UNIV P", "assume \"CENUM('a \\<Rightarrow> 'b) = Some (enum, enum_all, enum_ex)\""], ["proof (state)\nthis:\n  CENUM('a \\<Rightarrow> 'b) = Some (enum, enum_all, enum_ex)\n\ngoal (3 subgoals):\n 1. \\<And>enum enum_all enum_ex.\n       CENUM('a \\<Rightarrow> 'b) =\n       Some (enum, enum_all, enum_ex) \\<Longrightarrow>\n       UNIV = set enum\n 2. \\<And>enum enum_all enum_ex P.\n       CENUM('a \\<Rightarrow> 'b) =\n       Some (enum, enum_all, enum_ex) \\<Longrightarrow>\n       enum_all P = Ball UNIV P\n 3. \\<And>enum enum_all enum_ex P.\n       CENUM('a \\<Rightarrow> 'b) =\n       Some (enum, enum_all, enum_ex) \\<Longrightarrow>\n       enum_ex P = Bex UNIV P", "then"], ["proof (chain)\npicking this:\n  CENUM('a \\<Rightarrow> 'b) = Some (enum, enum_all, enum_ex)", "obtain enum_a enum_all_a enum_ex_a enum_b enum_all_b enum_ex_b\n    where a: \"ID CENUM('a) = Some (enum_a, enum_all_a, enum_ex_a)\"\n    and b: \"ID CENUM('b) = Some (enum_b, enum_all_b, enum_ex_b)\"\n    and enum: \"enum = map (\\<lambda>ys. the o map_of (zip enum_a ys)) (List.n_lists (length enum_a) enum_b)\"\n    and enum_all: \"enum_all = (\\<lambda>P. all_n_lists enum_all_b (\\<lambda>bs. P (the o map_of (zip enum_a bs))) (length enum_a))\"\n    and enum_ex: \"enum_ex = (\\<lambda>P. ex_n_lists enum_ex_b (\\<lambda>bs. P (the o map_of (zip enum_a bs))) (length enum_a))\""], ["proof (prove)\nusing this:\n  CENUM('a \\<Rightarrow> 'b) = Some (enum, enum_all, enum_ex)\n\ngoal (1 subgoal):\n 1. (\\<And>enum_a enum_all_a enum_ex_a enum_b enum_all_b enum_ex_b.\n        \\<lbrakk>ID CENUM('a) = Some (enum_a, enum_all_a, enum_ex_a);\n         ID CENUM('b) = Some (enum_b, enum_all_b, enum_ex_b);\n         enum =\n         map (\\<lambda>ys. the \\<circ> map_of (zip enum_a ys))\n          (List.n_lists (length enum_a) enum_b);\n         enum_all =\n         (\\<lambda>P.\n             all_n_lists enum_all_b\n              (\\<lambda>bs. P (the \\<circ> map_of (zip enum_a bs)))\n              (length enum_a));\n         enum_ex =\n         (\\<lambda>P.\n             ex_n_lists enum_ex_b\n              (\\<lambda>bs. P (the \\<circ> map_of (zip enum_a bs)))\n              (length enum_a))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp add: cEnum_fun_def split: option.split_asm)"], ["proof (state)\nthis:\n  ID CENUM('a) = Some (enum_a, enum_all_a, enum_ex_a)\n  ID CENUM('b) = Some (enum_b, enum_all_b, enum_ex_b)\n  enum =\n  map (\\<lambda>ys. the \\<circ> map_of (zip enum_a ys))\n   (List.n_lists (length enum_a) enum_b)\n  enum_all =\n  (\\<lambda>P.\n      all_n_lists enum_all_b\n       (\\<lambda>bs. P (the \\<circ> map_of (zip enum_a bs)))\n       (length enum_a))\n  enum_ex =\n  (\\<lambda>P.\n      ex_n_lists enum_ex_b\n       (\\<lambda>bs. P (the \\<circ> map_of (zip enum_a bs)))\n       (length enum_a))\n\ngoal (3 subgoals):\n 1. \\<And>enum enum_all enum_ex.\n       CENUM('a \\<Rightarrow> 'b) =\n       Some (enum, enum_all, enum_ex) \\<Longrightarrow>\n       UNIV = set enum\n 2. \\<And>enum enum_all enum_ex P.\n       CENUM('a \\<Rightarrow> 'b) =\n       Some (enum, enum_all, enum_ex) \\<Longrightarrow>\n       enum_all P = Ball UNIV P\n 3. \\<And>enum enum_all enum_ex P.\n       CENUM('a \\<Rightarrow> 'b) =\n       Some (enum, enum_all, enum_ex) \\<Longrightarrow>\n       enum_ex P = Bex UNIV P", "show \"UNIV = set enum\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = set enum", "proof (rule UNIV_eq_I)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set enum", "fix f :: \"'a \\<Rightarrow> 'b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set enum", "have \"f = the \\<circ> map_of (zip enum_a (map f enum_a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = the \\<circ> map_of (zip enum_a (map f enum_a))", "by (auto simp add: map_of_zip_map fun_eq_iff intro: in_cenum[OF a])"], ["proof (state)\nthis:\n  f = the \\<circ> map_of (zip enum_a (map f enum_a))\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set enum", "then"], ["proof (chain)\npicking this:\n  f = the \\<circ> map_of (zip enum_a (map f enum_a))", "show \"f \\<in> set enum\""], ["proof (prove)\nusing this:\n  f = the \\<circ> map_of (zip enum_a (map f enum_a))\n\ngoal (1 subgoal):\n 1. f \\<in> set enum", "by (auto simp add: enum set_n_lists intro: in_cenum[OF b])"], ["proof (state)\nthis:\n  f \\<in> set enum\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  UNIV = set enum\n\ngoal (2 subgoals):\n 1. \\<And>enum enum_all enum_ex P.\n       CENUM('a \\<Rightarrow> 'b) =\n       Some (enum, enum_all, enum_ex) \\<Longrightarrow>\n       enum_all P = Ball UNIV P\n 2. \\<And>enum enum_all enum_ex P.\n       CENUM('a \\<Rightarrow> 'b) =\n       Some (enum, enum_all, enum_ex) \\<Longrightarrow>\n       enum_ex P = Bex UNIV P", "show \"enum_all P = Ball UNIV P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enum_all P = Ball UNIV P", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. enum_all P \\<Longrightarrow> Ball UNIV P\n 2. Ball UNIV P \\<Longrightarrow> enum_all P", "assume \"enum_all P\""], ["proof (state)\nthis:\n  enum_all P\n\ngoal (2 subgoals):\n 1. enum_all P \\<Longrightarrow> Ball UNIV P\n 2. Ball UNIV P \\<Longrightarrow> enum_all P", "show \"Ball UNIV P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball UNIV P", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> UNIV \\<Longrightarrow> P x", "fix f :: \"'a \\<Rightarrow> 'b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> UNIV \\<Longrightarrow> P x", "have f: \"f = the \\<circ> map_of (zip (enum_a) (map f enum_a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = the \\<circ> map_of (zip enum_a (map f enum_a))", "by (auto simp add: map_of_zip_map fun_eq_iff intro: in_cenum[OF a])"], ["proof (state)\nthis:\n  f = the \\<circ> map_of (zip enum_a (map f enum_a))\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> UNIV \\<Longrightarrow> P x", "from \\<open>enum_all P\\<close>"], ["proof (chain)\npicking this:\n  enum_all P", "have \"P (the \\<circ> map_of (zip enum_a (map f enum_a)))\""], ["proof (prove)\nusing this:\n  enum_all P\n\ngoal (1 subgoal):\n 1. P (the \\<circ> map_of (zip enum_a (map f enum_a)))", "apply(simp add: enum_all ID_cEnum[OF b] all_n_lists_iff set_n_lists)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs.\n       length xs = length enum_a \\<and>\n       set xs \\<subseteq> set enum_b \\<longrightarrow>\n       P (the \\<circ> map_of (zip enum_a xs)) \\<Longrightarrow>\n    P (the \\<circ> map_of (zip enum_a (map f enum_a)))", "apply(erule allE, erule mp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map f enum_a) = length enum_a \\<and>\n    set (map f enum_a) \\<subseteq> set enum_b", "apply(auto simp add: in_cenum[OF b])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  P (the \\<circ> map_of (zip enum_a (map f enum_a)))\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> UNIV \\<Longrightarrow> P x", "with f"], ["proof (chain)\npicking this:\n  f = the \\<circ> map_of (zip enum_a (map f enum_a))\n  P (the \\<circ> map_of (zip enum_a (map f enum_a)))", "show \"P f\""], ["proof (prove)\nusing this:\n  f = the \\<circ> map_of (zip enum_a (map f enum_a))\n  P (the \\<circ> map_of (zip enum_a (map f enum_a)))\n\ngoal (1 subgoal):\n 1. P f", "by simp"], ["proof (state)\nthis:\n  P f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Ball UNIV P\n\ngoal (1 subgoal):\n 1. Ball UNIV P \\<Longrightarrow> enum_all P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Ball UNIV P \\<Longrightarrow> enum_all P", "assume \"Ball UNIV P\""], ["proof (state)\nthis:\n  Ball UNIV P\n\ngoal (1 subgoal):\n 1. Ball UNIV P \\<Longrightarrow> enum_all P", "from this"], ["proof (chain)\npicking this:\n  Ball UNIV P", "show \"enum_all P\""], ["proof (prove)\nusing this:\n  Ball UNIV P\n\ngoal (1 subgoal):\n 1. enum_all P", "by(simp add: enum_all ID_cEnum[OF b] all_n_lists_iff)"], ["proof (state)\nthis:\n  enum_all P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  enum_all P = Ball UNIV P\n\ngoal (1 subgoal):\n 1. \\<And>enum enum_all enum_ex P.\n       CENUM('a \\<Rightarrow> 'b) =\n       Some (enum, enum_all, enum_ex) \\<Longrightarrow>\n       enum_ex P = Bex UNIV P", "show \"enum_ex P = Bex UNIV P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enum_ex P = Bex UNIV P", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. enum_ex P \\<Longrightarrow> Bex UNIV P\n 2. Bex UNIV P \\<Longrightarrow> enum_ex P", "assume \"enum_ex P\""], ["proof (state)\nthis:\n  enum_ex P\n\ngoal (2 subgoals):\n 1. enum_ex P \\<Longrightarrow> Bex UNIV P\n 2. Bex UNIV P \\<Longrightarrow> enum_ex P", "from this"], ["proof (chain)\npicking this:\n  enum_ex P", "show \"Bex UNIV P\""], ["proof (prove)\nusing this:\n  enum_ex P\n\ngoal (1 subgoal):\n 1. Bex UNIV P", "by(auto simp add: enum_ex ID_cEnum[OF b] ex_n_lists_iff)"], ["proof (state)\nthis:\n  Bex UNIV P\n\ngoal (1 subgoal):\n 1. Bex UNIV P \\<Longrightarrow> enum_ex P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Bex UNIV P \\<Longrightarrow> enum_ex P", "assume \"Bex UNIV P\""], ["proof (state)\nthis:\n  Bex UNIV P\n\ngoal (1 subgoal):\n 1. Bex UNIV P \\<Longrightarrow> enum_ex P", "from this"], ["proof (chain)\npicking this:\n  Bex UNIV P", "obtain f where \"P f\""], ["proof (prove)\nusing this:\n  Bex UNIV P\n\ngoal (1 subgoal):\n 1. (\\<And>f. P f \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", ".."], ["proof (state)\nthis:\n  P f\n\ngoal (1 subgoal):\n 1. Bex UNIV P \\<Longrightarrow> enum_ex P", "also"], ["proof (state)\nthis:\n  P f\n\ngoal (1 subgoal):\n 1. Bex UNIV P \\<Longrightarrow> enum_ex P", "have f: \"f = the \\<circ> map_of (zip (enum_a) (map f enum_a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = the \\<circ> map_of (zip enum_a (map f enum_a))", "by (auto simp add: map_of_zip_map fun_eq_iff intro: in_cenum[OF a])"], ["proof (state)\nthis:\n  f = the \\<circ> map_of (zip enum_a (map f enum_a))\n\ngoal (1 subgoal):\n 1. Bex UNIV P \\<Longrightarrow> enum_ex P", "finally"], ["proof (chain)\npicking this:\n  P (the \\<circ> map_of (zip enum_a (map f enum_a)))", "show \"enum_ex P\""], ["proof (prove)\nusing this:\n  P (the \\<circ> map_of (zip enum_a (map f enum_a)))\n\ngoal (1 subgoal):\n 1. enum_ex P", "apply(simp add: enum_ex ID_cEnum[OF b] ex_n_lists_iff o_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (\\<lambda>a.\n          the (map_of (zip enum_a (map f enum_a)) a)) \\<Longrightarrow>\n    \\<exists>xs\\<in>set (List.n_lists (length enum_a) enum_b).\n       P (\\<lambda>x. the (map_of (zip enum_a xs) x))", "apply(erule bexI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map f enum_a \\<in> set (List.n_lists (length enum_a) enum_b)", "apply(auto simp add: set_n_lists intro!: in_cenum[OF b])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  enum_ex P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  enum_ex P = Bex UNIV P\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instantiation set :: (cenum) cenum begin"], ["", "definition\n  \"CENUM('a set) =\n  (case ID CENUM('a) of None \\<Rightarrow> None | Some (enum_a, enum_all_a, enum_ex_a) \\<Rightarrow> Some \n    (map set (subseqs enum_a),\n     \\<lambda>P. list_all P (map set (subseqs enum_a)),\n     \\<lambda>P. list_ex P (map set (subseqs enum_a))))\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a set, cenum_class)", "by(intro_classes)(auto simp add: cEnum_set_def subseqs_powset list_ex_iff list_all_iff split: option.split_asm dest!: ID_cEnum)"], ["", "end"], ["", "instantiation unit :: cenum begin"], ["", "definition \"CENUM(unit) = Some (enum_class.enum, enum_class.enum_all, enum_class.enum_ex)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(unit, cenum_class)", "by(intro_classes)(auto simp add: cEnum_unit_def enum_UNIV enum_all_UNIV enum_ex_UNIV)"], ["", "end"], ["", "instantiation bool :: cenum begin"], ["", "definition \"CENUM(bool) = Some (enum_class.enum, enum_class.enum_all, enum_class.enum_ex)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(bool, cenum_class)", "by(intro_classes)(auto simp add: cEnum_bool_def enum_UNIV enum_all_UNIV enum_ex_UNIV)"], ["", "end"], ["", "instantiation prod :: (cenum, cenum) cenum begin"], ["", "definition \n  \"CENUM('a \\<times> 'b) =\n  (case ID CENUM('a) of None \\<Rightarrow> None | Some (enum_a, enum_all_a, enum_ex_a) \\<Rightarrow>\n     case ID CENUM('b) of None \\<Rightarrow> None | Some (enum_b, enum_all_b, enum_ex_b) \\<Rightarrow> Some \n       (List.product enum_a enum_b,\n        \\<lambda>P. enum_all_a (%x. enum_all_b (%y. P (x, y))),\n        \\<lambda>P. enum_ex_a (%x. enum_ex_b (%y. P (x, y)))))\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<times> 'b, cenum_class)", "by(intro_classes)(auto 4 4 simp add: cEnum_prod_def split: option.split_asm dest!: ID_cEnum)"], ["", "end"], ["", "instantiation sum :: (cenum, cenum) cenum begin"], ["", "definition \n  \"CENUM('a + 'b) =\n  (case ID CENUM('a) of None \\<Rightarrow> None | Some (enum_a, enum_all_a, enum_ex_a) \\<Rightarrow>\n     case ID CENUM('b) of None \\<Rightarrow> None | Some (enum_b, enum_all_b, enum_ex_b) \\<Rightarrow> Some \n       (map Inl enum_a @ map Inr enum_b,\n        \\<lambda>P. enum_all_a (\\<lambda>x. P (Inl x)) \\<and> enum_all_b (\\<lambda>x. P (Inr x)),\n        \\<lambda>P. enum_ex_a (\\<lambda>x. P (Inl x)) \\<or> enum_ex_b (\\<lambda>x. P (Inr x))))\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a + 'b, cenum_class)", "by(intro_classes)(auto 4 4 simp add: cEnum_sum_def UNIV_sum split: option.split_asm dest!: ID_cEnum)"], ["", "end"], ["", "instantiation option :: (cenum) cenum begin"], ["", "definition\n  \"CENUM('a option) =\n  (case ID CENUM('a) of None \\<Rightarrow> None | Some (enum_a, enum_all_a, enum_ex_a) \\<Rightarrow> Some \n    (None # map Some enum_a,\n     \\<lambda>P. P None \\<and> enum_all_a (\\<lambda>x. P (Some x)),\n     \\<lambda>P. P None \\<or> enum_ex_a (\\<lambda>x. P (Some x))))\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a option, cenum_class)", "by(intro_classes)(auto simp add: cEnum_option_def UNIV_option_conv split: option.split_asm dest: ID_cEnum)"], ["", "end"], ["", "instantiation Enum.finite_1 :: cenum begin"], ["", "definition \"CENUM(Enum.finite_1) = Some (enum_class.enum, enum_class.enum_all, enum_class.enum_ex)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(Enum.finite_1, cenum_class)", "by(intro_classes)(auto simp add: cEnum_finite_1_def enum_UNIV enum_all_UNIV enum_ex_UNIV)"], ["", "end"], ["", "instantiation Enum.finite_2 :: cenum begin"], ["", "definition \"CENUM(Enum.finite_2) = Some (enum_class.enum, enum_class.enum_all, enum_class.enum_ex)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(Enum.finite_2, cenum_class)", "by(intro_classes)(auto simp add: cEnum_finite_2_def enum_UNIV enum_all_UNIV enum_ex_UNIV)"], ["", "end"], ["", "instantiation Enum.finite_3 :: cenum begin"], ["", "definition \"CENUM(Enum.finite_3) = Some (enum_class.enum, enum_class.enum_all, enum_class.enum_ex)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(Enum.finite_3, cenum_class)", "by(intro_classes)(auto simp add: cEnum_finite_3_def enum_UNIV enum_all_UNIV enum_ex_UNIV)"], ["", "end"], ["", "instantiation Enum.finite_4 :: cenum begin"], ["", "definition \"CENUM(Enum.finite_4) = Some (enum_class.enum, enum_class.enum_all, enum_class.enum_ex)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(Enum.finite_4, cenum_class)", "by(intro_classes)(auto simp add: cEnum_finite_4_def enum_UNIV enum_all_UNIV enum_ex_UNIV)"], ["", "end"], ["", "instantiation Enum.finite_5 :: cenum begin"], ["", "definition \"CENUM(Enum.finite_5) = Some (enum_class.enum, enum_class.enum_all, enum_class.enum_ex)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(Enum.finite_5, cenum_class)", "by(intro_classes)(auto simp add: cEnum_finite_5_def enum_UNIV enum_all_UNIV enum_ex_UNIV)"], ["", "end"], ["", "instantiation char :: cenum begin"], ["", "definition \"CENUM(char) = Some (enum_class.enum, enum_class.enum_all, enum_class.enum_ex)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(char, cenum_class)", "by(intro_classes)(auto simp add: cEnum_char_def enum_UNIV enum_all_UNIV enum_ex_UNIV)"], ["", "end"], ["", "derive (no) cenum list nat int integer natural String.literal"], ["", "end"]]}