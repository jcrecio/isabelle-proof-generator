{"file_name": "/home/qj213/afp-2021-10-22/thys/Containers/Set_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Containers", "problem_names": ["lemma length_quicksort_accp:\n  \"quicksort_acc_quicksort_part_dom (Inl (ac, xs)) \\<Longrightarrow> length (quicksort_acc ac xs) = length ac + length xs\"\n  and length_quicksort_partp:\n  \"quicksort_acc_quicksort_part_dom (Inr (ac, x, lts, eqs, gts, zs)) \n  \\<Longrightarrow> length (quicksort_part ac x lts eqs gts zs) = length ac + 1 + length lts + length eqs + length gts + length zs\"", "lemma set_quicksort_acc [simp]: \"set (quicksort_acc ac xs) = set ac \\<union> set xs\"\n  and set_quicksort_part [simp]:\n  \"set (quicksort_part ac x lts eqs gts zs) =\n  set ac \\<union> {x} \\<union> set lts \\<union> set eqs \\<union> set gts \\<union> set zs\"", "lemma set_quicksort [simp]: \"set (quicksort xs) = set xs\"", "lemma distinct_quicksort_acc: \n  \"distinct (quicksort_acc ac xs) = distinct (ac @ xs)\"\n  and distinct_quicksort_part:\n  \"distinct (quicksort_part ac x lts eqs gts zs) = distinct (ac @ [x] @ lts @ eqs @ gts @ zs)\"", "lemma distinct_quicksort [simp]: \"distinct (quicksort xs) = distinct xs\"", "lemmas [code] =\n  ord.quicksort_acc.simps quicksort_acc.simps\n  ord.quicksort_part.simps quicksort_part.simps\n  ord.quicksort_def quicksort_def", "lemma sorted_quicksort_acc:\n  \"\\<lbrakk> sorted ac; \\<forall>x \\<in> set xs. \\<forall>a \\<in> set ac. x < a \\<rbrakk>\n  \\<Longrightarrow> sorted (quicksort_acc ac xs)\"\n  and sorted_quicksort_part:\n  \"\\<lbrakk> sorted ac; \\<forall>y \\<in> set lts \\<union> {x} \\<union> set eqs \\<union> set gts \\<union> set zs. \\<forall>a \\<in> set ac. y < a;\n     \\<forall>y \\<in> set lts. y < x; \\<forall>y \\<in> set eqs. y = x; \\<forall>y \\<in> set gts. y > x \\<rbrakk>\n  \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts zs)\"", "lemma sorted_quicksort [simp]: \"sorted (quicksort xs)\"", "lemma insort_key_append1:\n  \"\\<forall>y \\<in> set ys. f x < f y \\<Longrightarrow> insort_key f x (xs @ ys) = insort_key f x xs @ ys\"", "lemma insort_key_append2:\n  \"\\<forall>y \\<in> set xs. f x > f y \\<Longrightarrow> insort_key f x (xs @ ys) = xs @ insort_key f x ys\"", "lemma sort_key_append:\n  \"\\<forall>x\\<in>set xs. \\<forall>y\\<in>set ys. f x < f y \\<Longrightarrow> sort_key f (xs @ ys) = sort_key f xs @ sort_key f ys\"", "lemma to_single_list: \"x # xs = single_list x @ xs\"", "lemma sort_snoc: \"sort (xs @ [x]) = insort x (sort xs)\"", "lemma sort_append_swap: \"sort (xs @ ys) = sort (ys @ xs)\"", "lemma sort_append_swap2: \"sort (xs @ ys @ zs) = sort (ys @ xs @ zs)\"", "lemma sort_Cons_append_swap: \"sort (x # xs) = sort (xs @ [x])\"", "lemma sort_append_Cons_swap: \"sort (ys @ x # xs) = sort (ys @ xs @ [x])\"", "lemma quicksort_acc_conv_sort: \n  \"quicksort_acc ac xs = sort xs @ ac\"\n  and quicksort_part_conv_sort: \n  \"\\<lbrakk> \\<forall>y \\<in> set lts. y < x; \\<forall>y \\<in> set eqs. y = x; \\<forall>y \\<in> set gts. y > x \\<rbrakk> \n  \\<Longrightarrow> quicksort_part ac x lts eqs gts zs = sort (lts @ eqs @ gts @ x # zs) @ ac\"", "lemma quicksort_conv_sort: \"quicksort xs = sort xs\"", "lemma sort_remdups: \"sort (remdups xs) = remdups (sort xs)\"", "lemmas [code] = ord.remdups_sorted.simps", "lemma [simp]:\n  assumes \"sorted xs\"\n  shows sorted_remdups_sorted: \"sorted (remdups_sorted xs)\"\n  and set_remdups_sorted: \"set (remdups_sorted xs) = set xs\"", "lemma distinct_remdups_sorted [simp]: \"sorted xs \\<Longrightarrow> distinct (remdups_sorted xs)\"", "lemma remdups_sorted_conv_remdups: \"sorted xs \\<Longrightarrow> remdups_sorted xs = remdups xs\"", "lemma csorted_list_of_set_set [simp]:\n  \"\\<lbrakk> ID CCOMPARE('a :: ccompare) = Some c; linorder.sorted (le_of_comp c) xs; distinct xs \\<rbrakk> \n  \\<Longrightarrow> linorder.sorted_list_of_set (le_of_comp c) (set xs) = xs\"", "lemma csorted_list_of_set_split:\n  fixes A :: \"'a :: ccompare set\" shows\n  \"P (csorted_list_of_set A) \\<longleftrightarrow> \n  (\\<forall>xs. ID CCOMPARE('a) \\<noteq> None \\<longrightarrow> finite A \\<longrightarrow> A = set xs \\<longrightarrow> distinct xs \\<longrightarrow> linorder.sorted cless_eq xs \\<longrightarrow> P xs) \\<and> \n  (ID CCOMPARE('a) = None \\<or> \\<not> finite A \\<longrightarrow> P undefined)\"", "lemma is_empty_unfold [code_unfold]:\n  \"set_eq A {} = Set.is_empty A\"\n  \"set_eq {} A = Set.is_empty A\"", "lemma is_UNIV_unfold [code_unfold]: \n  \"A = UNIV \\<longleftrightarrow> is_UNIV A\" \n  \"UNIV = A \\<longleftrightarrow> is_UNIV A\"\n  \"set_eq A UNIV \\<longleftrightarrow> is_UNIV A\"\n  \"set_eq UNIV A \\<longleftrightarrow> is_UNIV A\"", "lemma [code_unfold del, symmetric, code_post del]:\n  \"x \\<in> set xs \\<equiv> List.member xs x\"", "lemma [code_unfold del, symmetric, code_post del]:\n  \"finite \\<equiv> Cardinality.finite'\"", "lemma [code_unfold del, symmetric, code_post del]:\n  \"card \\<equiv> Cardinality.card'\"", "lemma DList_set_empty [simp]: \"DList_set DList_Set.empty = {}\"", "lemma RBT_set_empty [simp]: \"RBT_set RBT_Set2.empty = {}\"", "lemma RBT_set_conv_keys: \n  \"ID CCOMPARE('a :: ccompare) \\<noteq> None \n  \\<Longrightarrow> RBT_set (t :: 'a set_rbt) = set (RBT_Set2.keys t)\"", "lemma comp_fun_commute_apply' [simp]:\n  \"comp_fun_commute (comp_fun_commute_apply f)\"", "lemma set_fold_cfc_code [code]:\n  fixes xs :: \"'a :: ceq list\" \n  and dxs :: \"'a :: ceq set_dlist\"\n  and rbt :: \"'b :: ccompare set_rbt\"\n  shows set_fold_cfc_Complement[set_complement_code]:\n  \"set_fold_cfc f''' b (Complement A) = Code.abort (STR ''set_fold_cfc not supported on Complement'') (\\<lambda>_. set_fold_cfc f''' b (Complement A))\"\n  and\n  \"set_fold_cfc f''' b (Collect_set P) = Code.abort (STR ''set_fold_cfc not supported on Collect_set'') (\\<lambda>_. set_fold_cfc f''' b (Collect_set P))\"\n  \"set_fold_cfc f b (Set_Monad xs) =\n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''set_fold_cfc Set_Monad: ceq = None'') (\\<lambda>_. set_fold_cfc f b (Set_Monad xs))\n                 | Some eq \\<Rightarrow> List.fold (comp_fun_commute_apply f) (equal_base.list_remdups eq xs) b)\"\n  (is ?Set_Monad)\n  \"set_fold_cfc f' b (DList_set dxs) =\n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''set_fold_cfc DList_set: ceq = None'') (\\<lambda>_. set_fold_cfc f' b (DList_set dxs))\n                  | Some _ \\<Rightarrow> DList_Set.fold (comp_fun_commute_apply f') dxs b)\"\n  (is ?DList_set)\n  \"set_fold_cfc f'' b (RBT_set rbt) =\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''set_fold_cfc RBT_set: ccompare = None'') (\\<lambda>_. set_fold_cfc f'' b (RBT_set rbt))\n                     | Some _ \\<Rightarrow> RBT_Set2.fold (comp_fun_commute_apply f'') rbt b)\"\n  (is ?RBT_set)", "lemma comp_fun_idem_apply' [simp]:\n  \"comp_fun_idem (comp_fun_idem_apply f)\"", "lemma set_fold_cfi_code [code]:\n  fixes xs :: \"'a list\" \n  and dxs :: \"'b :: ceq set_dlist\"\n  and rbt :: \"'c :: ccompare set_rbt\" shows\n  \"set_fold_cfi f b (Complement A) = Code.abort (STR ''set_fold_cfi not supported on Complement'') (\\<lambda>_. set_fold_cfi f b (Complement A))\"\n  \"set_fold_cfi f b (Collect_set P) = Code.abort (STR ''set_fold_cfi not supported on Collect_set'') (\\<lambda>_. set_fold_cfi f b (Collect_set P))\"\n  \"set_fold_cfi f b (Set_Monad xs) = List.fold (comp_fun_idem_apply f) xs b\"\n  (is ?Set_Monad)\n  \"set_fold_cfi f' b (DList_set dxs) =\n  (case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''set_fold_cfi DList_set: ceq = None'') (\\<lambda>_. set_fold_cfi f' b (DList_set dxs))\n                  | Some _ \\<Rightarrow> DList_Set.fold (comp_fun_idem_apply f') dxs b)\"\n  (is ?DList_set)\n  \"set_fold_cfi f'' b (RBT_set rbt) =\n  (case ID CCOMPARE('c) of None \\<Rightarrow> Code.abort (STR ''set_fold_cfi RBT_set: ccompare = None'') (\\<lambda>_. set_fold_cfi f'' b (RBT_set rbt))\n                     | Some _ \\<Rightarrow> RBT_Set2.fold (comp_fun_idem_apply f'') rbt b)\"\n  (is ?RBT_set)", "lemma semilattice_set_apply' [simp]:\n  \"semilattice_set (semilattice_set_apply f)\"", "lemma comp_fun_idem_semilattice_set_apply [simp]:\n  \"comp_fun_idem (semilattice_set_apply f)\"", "lemma (in semilattice_set) F_set_conv_fold:\n  \"xs \\<noteq> [] \\<Longrightarrow> F (set xs) = Finite_Set.fold f (hd xs) (set (tl xs))\"", "lemma set_fold1_code [code]:\n  fixes rbt :: \"'a :: {ccompare, lattice} set_rbt\"\n  and dxs :: \"'b :: {ceq, lattice} set_dlist\" shows\n  set_fold1_Complement[set_complement_code]:\n  \"set_fold1 f (Complement A) = Code.abort (STR ''set_fold1: Complement'') (\\<lambda>_. set_fold1 f (Complement A))\"\n  and \"set_fold1 f (Collect_set P) = Code.abort (STR ''set_fold1: Collect_set'') (\\<lambda>_. set_fold1 f (Collect_set P))\"\n  and \"set_fold1 f (Set_Monad (x # xs)) = fold (semilattice_set_apply f) xs x\" (is \"?Set_Monad\")\n  and\n  \"set_fold1 f' (DList_set dxs) =\n  (case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''set_fold1 DList_set: ceq = None'') (\\<lambda>_. set_fold1 f' (DList_set dxs))\n                  | Some _ \\<Rightarrow> if DList_Set.null dxs then Code.abort (STR ''set_fold1 DList_set: empty set'') (\\<lambda>_. set_fold1 f' (DList_set dxs))\n                              else DList_Set.fold (semilattice_set_apply f') (DList_Set.tl dxs) (DList_Set.hd dxs))\"\n  (is \"?DList_set\")\n  and\n  \"set_fold1 f'' (RBT_set rbt) =\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''set_fold1 RBT_set: ccompare = None'') (\\<lambda>_. set_fold1 f'' (RBT_set rbt))\n                     | Some _ \\<Rightarrow> if RBT_Set2.is_empty rbt then Code.abort (STR ''set_fold1 RBT_set: empty set'') (\\<lambda>_. set_fold1 f'' (RBT_set rbt))\n                                 else RBT_Set2.fold1 (semilattice_set_apply f'') rbt)\"\n  (is \"?RBT_set\")", "lemma Collect_code [code]:\n  fixes P :: \"'a :: cenum \\<Rightarrow> bool\" shows\n  \"Collect P =\n  (case ID CENUM('a) of None \\<Rightarrow> Collect_set P\n            | Some (enum, _) \\<Rightarrow> Set_Monad (filter P enum))\"", "lemma finite_code [code]:\n  fixes dxs :: \"'a :: ceq set_dlist\" \n  and rbt :: \"'b :: ccompare set_rbt\"\n  and A :: \"'c :: finite_UNIV set\" and P :: \"'c \\<Rightarrow> bool\" shows\n  \"finite (DList_set dxs) = \n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''finite DList_set: ceq = None'') (\\<lambda>_. finite (DList_set dxs))\n                 | Some _ \\<Rightarrow> True)\"\n  \"finite (RBT_set rbt) =\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''finite RBT_set: ccompare = None'') (\\<lambda>_. finite (RBT_set rbt))\n                     | Some _ \\<Rightarrow> True)\"\n  and finite_Complement [set_complement_code]:\n  \"finite (Complement A) \\<longleftrightarrow>\n  (if of_phantom (finite_UNIV :: 'c finite_UNIV) then True\n   else if finite A then False\n   else Code.abort (STR ''finite Complement: infinite set'') (\\<lambda>_. finite (Complement A)))\"\n  and\n  \"finite (Set_Monad xs) = True\"\n  \"finite (Collect_set P) \\<longleftrightarrow>\n  of_phantom (finite_UNIV :: 'c finite_UNIV) \\<or> Code.abort (STR ''finite Collect_set'') (\\<lambda>_. finite (Collect_set P))\"", "lemma card_code [code]:\n  fixes dxs :: \"'a :: ceq set_dlist\" and xs :: \"'a list\"\n  and rbt :: \"'b :: ccompare set_rbt\" \n  and A :: \"'c :: card_UNIV set\" shows\n  \"card (DList_set dxs) = \n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''card DList_set: ceq = None'') (\\<lambda>_. card (DList_set dxs))\n                  | Some _ \\<Rightarrow> DList_Set.length dxs)\"\n  \"card (RBT_set rbt) = \n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''card RBT_set: ccompare = None'') (\\<lambda>_. card (RBT_set rbt))\n                    | Some _ \\<Rightarrow> length (RBT_Set2.keys rbt))\"\n  \"card (Set_Monad xs) =\n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''card Set_Monad: ceq = None'') (\\<lambda>_. card (Set_Monad xs))\n                 | Some eq \\<Rightarrow> length (equal_base.list_remdups eq xs))\"\n  and card_Complement [set_complement_code]:\n  \"card (Complement A) =\n   (let a = card A; s = CARD('c)\n    in if s > 0 then s - a \n       else if finite A then 0\n       else Code.abort (STR ''card Complement: infinite'') (\\<lambda>_. card (Complement A)))\"", "lemma is_UNIV_code [code]:\n  fixes rbt :: \"'a :: {cproper_interval, finite_UNIV} set_rbt\" \n  and A :: \"'b :: card_UNIV set\" shows\n  \"is_UNIV A \\<longleftrightarrow>\n   (let a = CARD('b);\n        b = card A\n    in if a > 0 then a = b\n       else if b > 0 then False\n       else Code.abort (STR ''is_UNIV called on infinite type and set'') (\\<lambda>_. is_UNIV A))\"\n  (is ?generic)\n  \"is_UNIV (RBT_set rbt) = \n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''is_UNIV RBT_set: ccompare = None'') (\\<lambda>_. is_UNIV (RBT_set rbt))\n                     | Some _ \\<Rightarrow> of_phantom (finite_UNIV :: 'a finite_UNIV) \\<and> proper_intrvl.exhaustive_fusion cproper_interval rbt_keys_generator (RBT_Set2.init rbt))\"\n  (is ?rbt)", "lemma is_empty_code [code]:\n  fixes dxs :: \"'a :: ceq set_dlist\" \n  and rbt :: \"'b :: ccompare set_rbt\" \n  and A :: \"'c set\" shows\n  \"Set.is_empty (Set_Monad xs) \\<longleftrightarrow> xs = []\"\n  \"Set.is_empty (DList_set dxs) \\<longleftrightarrow> \n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''is_empty DList_set: ceq = None'') (\\<lambda>_. Set.is_empty (DList_set dxs))\n                  | Some _ \\<Rightarrow> DList_Set.null dxs)\" (is ?DList_set)\n  \"Set.is_empty (RBT_set rbt) \\<longleftrightarrow> \n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''is_empty RBT_set: ccompare = None'') (\\<lambda>_. Set.is_empty (RBT_set rbt))\n                  | Some _ \\<Rightarrow> RBT_Set2.is_empty rbt)\" (is ?RBT_set)\n  and is_empty_Complement [set_complement_code]:\n  \"Set.is_empty (Complement A) \\<longleftrightarrow> is_UNIV A\" (is ?Complement)", "lemma Set_insert_code [code]:\n  fixes dxs :: \"'a :: ceq set_dlist\" \n  and rbt :: \"'b :: ccompare set_rbt\" shows\n  \"\\<And>x. Set.insert x (Collect_set A) = \n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''insert Collect_set: ceq = None'') (\\<lambda>_. Set.insert x (Collect_set A))\n                | Some eq \\<Rightarrow> Collect_set (equal_base.fun_upd eq A x True))\"\n  \"\\<And>x. Set.insert x (Set_Monad xs) = Set_Monad (x # xs)\"\n  \"\\<And>x. Set.insert x (DList_set dxs) =\n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''insert DList_set: ceq = None'') (\\<lambda>_. Set.insert x (DList_set dxs))\n                  | Some _ \\<Rightarrow> DList_set (DList_Set.insert x dxs))\"\n  \"\\<And>x. Set.insert x (RBT_set rbt) =\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''insert RBT_set: ccompare = None'') (\\<lambda>_. Set.insert x (RBT_set rbt))\n                     | Some _ \\<Rightarrow> RBT_set (RBT_Set2.insert x rbt))\"\n  and insert_Complement [set_complement_code]:\n  \"\\<And>x. Set.insert x (Complement X) = Complement (Set.remove x X)\"", "lemma Set_member_code [code]:\n  fixes xs :: \"'a :: ceq list\" shows\n  \"\\<And>x. x \\<in> Collect_set A \\<longleftrightarrow> A x\"\n  \"\\<And>x. x \\<in> DList_set dxs \\<longleftrightarrow> DList_Set.member dxs x\"\n  \"\\<And>x. x \\<in> RBT_set rbt \\<longleftrightarrow> RBT_Set2.member rbt x\"\n  and mem_Complement [set_complement_code]:\n  \"\\<And>x. x \\<in> Complement X \\<longleftrightarrow> x \\<notin> X\"\n  and\n  \"\\<And>x. x \\<in> Set_Monad xs \\<longleftrightarrow>\n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''member Set_Monad: ceq = None'') (\\<lambda>_. x \\<in> Set_Monad xs)\n                 | Some eq \\<Rightarrow> equal_base.list_member eq xs x)\"", "lemma Set_remove_code [code]:\n  fixes rbt :: \"'a :: ccompare set_rbt\"\n  and dxs :: \"'b :: ceq set_dlist\" shows\n  \"\\<And>x. Set.remove x (Collect_set A) =\n  (case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''remove Collect: ceq = None'') (\\<lambda>_. Set.remove x (Collect_set A))\n                 | Some eq \\<Rightarrow> Collect_set (equal_base.fun_upd eq A x False))\"\n  \"\\<And>x. Set.remove x (DList_set dxs) = \n  (case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''remove DList_set: ceq = None'') (\\<lambda>_. Set.remove x (DList_set dxs))\n                  | Some _ \\<Rightarrow> DList_set (DList_Set.remove x dxs))\"\n  \"\\<And>x. Set.remove x (RBT_set rbt) =\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''remove RBT_set: ccompare = None'') (\\<lambda>_. Set.remove x (RBT_set rbt))\n                     | Some _ \\<Rightarrow> RBT_set (RBT_Set2.remove x rbt))\"\n  and remove_Complement [set_complement_code]:\n  \"\\<And>x A. Set.remove x (Complement A) = Complement (Set.insert x A)\"", "lemma Set_uminus_code [code, set_complement_code]:\n  \"- A = Complement A\"\n  \"- (Collect_set P) = Collect_set (\\<lambda>x. \\<not> P x)\"\n  \"- (Complement B) = B\"", "lemma Set_uminus_cenum:\n  fixes A :: \"'a :: cenum set\" shows\n  \"- A =\n  (case ID CENUM('a) of None \\<Rightarrow> Complement A\n            | Some (enum, _) \\<Rightarrow> Set_Monad (filter (\\<lambda>x. x \\<notin> A) enum))\"\n  and \"- (Complement B) = B\"", "lemma Set_minus_code [code]: \"A - B = A \\<inter> (- B)\"", "lemma Set_union_code [code]:\n  fixes rbt1 rbt2 :: \"'a :: ccompare set_rbt\"\n  and rbt :: \"'b :: {ccompare, ceq} set_rbt\"\n  and dxs :: \"'b set_dlist\"\n  and dxs1 dxs2 :: \"'c :: ceq set_dlist\" shows\n  \"RBT_set rbt1 \\<union> RBT_set rbt2 =\n   (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''union RBT_set RBT_set: ccompare = None'') (\\<lambda>_. RBT_set rbt1 \\<union> RBT_set rbt2)\n                      | Some _ \\<Rightarrow> RBT_set (RBT_Set2.union rbt1 rbt2))\" (is ?RBT_set_RBT_set)\n  \"RBT_set rbt \\<union> DList_set dxs =\n   (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''union RBT_set DList_set: ccompare = None'') (\\<lambda>_. RBT_set rbt \\<union> DList_set dxs)\n                      | Some _ \\<Rightarrow>\n       case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''union RBT_set DList_set: ceq = None'') (\\<lambda>_. RBT_set rbt \\<union> DList_set dxs)\n                      | Some _ \\<Rightarrow> RBT_set (DList_Set.fold RBT_Set2.insert dxs rbt))\" (is ?RBT_set_DList_set)\n  \"DList_set dxs \\<union> RBT_set rbt =\n   (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''union DList_set RBT_set: ccompare = None'') (\\<lambda>_. RBT_set rbt \\<union> DList_set dxs)\n                      | Some _ \\<Rightarrow>\n       case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''union DList_set RBT_set: ceq = None'') (\\<lambda>_. RBT_set rbt \\<union> DList_set dxs)\n                      | Some _ \\<Rightarrow> RBT_set (DList_Set.fold RBT_Set2.insert dxs rbt))\" (is ?DList_set_RBT_set)\n  \"DList_set dxs1 \\<union> DList_set dxs2 = \n   (case ID CEQ('c) of None \\<Rightarrow> Code.abort (STR ''union DList_set DList_set: ceq = None'') (\\<lambda>_. DList_set dxs1 \\<union> DList_set dxs2)\n                      | Some _ \\<Rightarrow> DList_set (DList_Set.union dxs1 dxs2))\" (is ?DList_set_DList_set)\n  \"Set_Monad zs \\<union> RBT_set rbt2 =\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''union Set_Monad RBT_set: ccompare = None'') (\\<lambda>_. Set_Monad zs \\<union> RBT_set rbt2)\n                      | Some _ \\<Rightarrow> RBT_set (fold RBT_Set2.insert zs rbt2))\" (is ?Set_Monad_RBT_set)\n  \"RBT_set rbt1 \\<union> Set_Monad zs =\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''union RBT_set Set_Monad: ccompare = None'') (\\<lambda>_. RBT_set rbt1 \\<union> Set_Monad zs)\n                      | Some _ \\<Rightarrow> RBT_set (fold RBT_Set2.insert zs rbt1))\" (is ?RBT_set_Set_Monad)\n  \"Set_Monad ws \\<union> DList_set dxs2 =\n  (case ID CEQ('c) of None \\<Rightarrow> Code.abort (STR ''union Set_Monad DList_set: ceq = None'') (\\<lambda>_. Set_Monad ws \\<union> DList_set dxs2)\n                  | Some _ \\<Rightarrow> DList_set (fold DList_Set.insert ws dxs2))\" (is ?Set_Monad_DList_set)\n  \"DList_set dxs1 \\<union> Set_Monad ws =\n  (case ID CEQ('c) of None \\<Rightarrow> Code.abort (STR ''union DList_set Set_Monad: ceq = None'') (\\<lambda>_. DList_set dxs1 \\<union> Set_Monad ws)\n                  | Some _ \\<Rightarrow> DList_set (fold DList_Set.insert ws dxs1))\" (is ?DList_set_Set_Monad)\n  \"Set_Monad xs \\<union> Set_Monad ys = Set_Monad (xs @ ys)\"\n  \"Collect_set A \\<union> B = Collect_set (\\<lambda>x. A x \\<or> x \\<in> B)\"\n  \"B \\<union> Collect_set A = Collect_set (\\<lambda>x. A x \\<or> x \\<in> B)\"\n  and Set_union_Complement [set_complement_code]:\n  \"Complement B \\<union> B' = Complement (B \\<inter> - B')\"\n  \"B' \\<union> Complement B = Complement (- B' \\<inter> B)\"", "lemma Set_inter_code [code]:\n  fixes rbt1 rbt2 :: \"'a :: ccompare set_rbt\"\n  and rbt :: \"'b :: {ccompare, ceq} set_rbt\"\n  and dxs :: \"'b set_dlist\"\n  and dxs1 dxs2 :: \"'c :: ceq set_dlist\" \n  and xs1 xs2 :: \"'c list\"\n  shows\n  \"Collect_set A'' \\<inter> J = Collect_set (\\<lambda>x. A'' x \\<and> x \\<in> J)\" (is ?collect1)\n  \"J \\<inter> Collect_set A'' = Collect_set (\\<lambda>x. A'' x \\<and> x \\<in> J)\" (is ?collect2)\n\n  \"Set_Monad xs'' \\<inter> I = Set_Monad (filter (\\<lambda>x. x \\<in> I) xs'')\" (is ?monad1)\n  \"I \\<inter> Set_Monad xs'' = Set_Monad (filter (\\<lambda>x. x \\<in> I) xs'')\" (is ?monad2)\n\n  \"DList_set dxs1 \\<inter> H =\n   (case ID CEQ('c) of None \\<Rightarrow> Code.abort (STR ''inter DList_set1: ceq = None'') (\\<lambda>_. DList_set dxs1 \\<inter> H)\n                  | Some eq \\<Rightarrow> DList_set (DList_Set.filter (\\<lambda>x. x \\<in> H) dxs1))\" (is ?dlist1)\n  \"H \\<inter> DList_set dxs2 =\n   (case ID CEQ('c) of None \\<Rightarrow> Code.abort (STR ''inter DList_set2: ceq = None'') (\\<lambda>_. H \\<inter> DList_set dxs2)\n                  | Some eq \\<Rightarrow> DList_set (DList_Set.filter (\\<lambda>x. x \\<in> H) dxs2))\" (is ?dlist2)\n\n  \"RBT_set rbt1 \\<inter> G =\n   (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''inter RBT_set1: ccompare = None'') (\\<lambda>_. RBT_set rbt1 \\<inter> G)\n                      | Some _ \\<Rightarrow> RBT_set (RBT_Set2.filter (\\<lambda>x. x \\<in> G) rbt1))\" (is ?rbt1)\n  \"G \\<inter> RBT_set rbt2 =\n   (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''inter RBT_set2: ccompare = None'') (\\<lambda>_. G \\<inter> RBT_set rbt2)\n                      | Some _ \\<Rightarrow> RBT_set (RBT_Set2.filter (\\<lambda>x. x \\<in> G) rbt2))\" (is ?rbt2)\n  and Set_inter_Complement [set_complement_code]:\n  \"Complement B'' \\<inter> Complement B''' = Complement (B'' \\<union> B''')\" (is ?complement)\n  and\n  \"Set_Monad xs \\<inter> RBT_set rbt1 =\n   (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''inter Set_Monad RBT_set: ccompare = None'') (\\<lambda>_. RBT_set rbt1 \\<inter> Set_Monad xs)\n                      | Some _ \\<Rightarrow> RBT_set (RBT_Set2.inter_list rbt1 xs))\" (is ?monad_rbt)\n  \"Set_Monad xs' \\<inter> DList_set dxs2 =\n   (case ID CEQ('c) of None \\<Rightarrow> Code.abort (STR ''inter Set_Monad DList_set: ceq = None'') (\\<lambda>_. Set_Monad xs' \\<inter> DList_set dxs2)\n                  | Some eq \\<Rightarrow> DList_set (DList_Set.filter (equal_base.list_member eq xs') dxs2))\" (is ?monad_dlist)\n  \"Set_Monad xs1 \\<inter> Set_Monad xs2 =\n  (case ID CEQ('c) of None \\<Rightarrow> Code.abort (STR ''inter Set_Monad Set_Monad: ceq = None'') (\\<lambda>_. Set_Monad xs1 \\<inter> Set_Monad xs2)\n                 | Some eq \\<Rightarrow> Set_Monad (filter (equal_base.list_member eq xs2) xs1))\" (is ?monad)\n\n  \"DList_set dxs \\<inter> RBT_set rbt = \n   (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''inter DList_set RBT_set: ccompare = None'') (\\<lambda>_. DList_set dxs \\<inter> RBT_set rbt)\n                      | Some _ \\<Rightarrow>\n       case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''inter DList_set RBT_set: ceq = None'') (\\<lambda>_. DList_set dxs \\<inter> RBT_set rbt)\n                      | Some _ \\<Rightarrow> RBT_set (RBT_Set2.inter_list rbt (list_of_dlist dxs)))\" (is ?dlist_rbt)\n  \"DList_set dxs1 \\<inter> DList_set dxs2 =\n   (case ID CEQ('c) of None \\<Rightarrow> Code.abort (STR ''inter DList_set DList_set: ceq = None'') (\\<lambda>_. DList_set dxs1 \\<inter> DList_set dxs2)\n                   | Some _ \\<Rightarrow> DList_set (DList_Set.filter (DList_Set.member dxs2) dxs1))\" (is ?dlist)\n  \"DList_set dxs1 \\<inter> Set_Monad xs' =\n   (case ID CEQ('c) of None \\<Rightarrow> Code.abort (STR ''inter DList_set Set_Monad: ceq = None'') (\\<lambda>_. DList_set dxs1 \\<inter> Set_Monad xs')\n                  | Some eq \\<Rightarrow> DList_set (DList_Set.filter (equal_base.list_member eq xs') dxs1))\" (is ?dlist_monad)\n\n  \"RBT_set rbt1 \\<inter> RBT_set rbt2 =\n   (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''inter RBT_set RBT_set: ccompare = None'') (\\<lambda>_. RBT_set rbt1 \\<inter> RBT_set rbt2)\n                      | Some _ \\<Rightarrow> RBT_set (RBT_Set2.inter rbt1 rbt2))\" (is ?rbt_rbt)\n  \"RBT_set rbt \\<inter> DList_set dxs = \n   (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''inter RBT_set DList_set: ccompare = None'') (\\<lambda>_. RBT_set rbt \\<inter> DList_set dxs)\n                      | Some _ \\<Rightarrow>\n       case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''inter RBT_set DList_set: ceq = None'') (\\<lambda>_. RBT_set rbt \\<inter> DList_set dxs)\n                      | Some _ \\<Rightarrow> RBT_set (RBT_Set2.inter_list rbt (list_of_dlist dxs)))\" (is ?rbt_dlist)\n  \"RBT_set rbt1 \\<inter> Set_Monad xs =\n   (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''inter RBT_set Set_Monad: ccompare = None'') (\\<lambda>_. RBT_set rbt1 \\<inter> Set_Monad xs)\n                      | Some _ \\<Rightarrow> RBT_set (RBT_Set2.inter_list rbt1 xs))\" (is ?rbt_monad)", "lemma Set_bind_code [code]:\n  fixes dxs :: \"'a :: ceq set_dlist\"\n  and rbt :: \"'b :: ccompare set_rbt\" shows\n  \"Set.bind (Set_Monad xs) f = fold ((\\<union>) \\<circ> f) xs (Set_Monad [])\" (is ?Set_Monad)\n  \"Set.bind (DList_set dxs) f' =\n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''bind DList_set: ceq = None'') (\\<lambda>_. Set.bind (DList_set dxs) f')\n                  | Some _ \\<Rightarrow> DList_Set.fold (union \\<circ> f') dxs {})\" (is ?DList)\n  \"Set.bind (RBT_set rbt) f'' = \n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''bind RBT_set: ccompare = None'') (\\<lambda>_. Set.bind (RBT_set rbt) f'')\n                     | Some _ \\<Rightarrow> RBT_Set2.fold (union \\<circ> f'') rbt {})\" (is ?RBT)", "lemma UNIV_code [code]: \"UNIV = - {}\"", "lemma Inf_fin_code [code]: \"Inf_fin A = set_fold1 inf_sls A\"", "lemma Sup_fin_code [code]: \"Sup_fin A = set_fold1 sup_sls A\"", "lemma Inf_code:\n  fixes A :: \"'a :: complete_lattice set\" shows\n  \"Inf A = (if finite A then set_fold_cfi inf_cfi top A else Code.abort (STR ''Inf: infinite'') (\\<lambda>_. Inf A))\"", "lemma Sup_code:\n  fixes A :: \"'a :: complete_lattice set\" shows\n  \"Sup A = (if finite A then set_fold_cfi sup_cfi bot A else Code.abort (STR ''Sup: infinite'') (\\<lambda>_. Sup A))\"", "lemmas Inter_code [code] = Inf_code[where ?'a = \"_ :: type set\"]", "lemmas Union_code [code] = Sup_code[where ?'a = \"_ :: type set\"]", "lemmas Predicate_Inf_code [code] = Inf_code[where ?'a = \"_ :: type Predicate.pred\"]", "lemmas Predicate_Sup_code [code] = Sup_code[where ?'a = \"_ :: type Predicate.pred\"]", "lemmas Inf_fun_code [code] = Inf_code[where ?'a = \"_ :: type \\<Rightarrow> _ :: complete_lattice\"]", "lemmas Sup_fun_code [code] = Sup_code[where ?'a = \"_ :: type \\<Rightarrow> _ :: complete_lattice\"]", "lemma Min_code [code]: \"Min A = set_fold1 min_sls A\"", "lemma Max_code [code]: \"Max A = set_fold1 max_sls A\"", "lemma Ball_code [code]:\n  fixes rbt :: \"'a :: ccompare set_rbt\"\n  and dxs :: \"'b :: ceq set_dlist\" shows\n  \"Ball (Set_Monad xs) P = list_all P xs\"\n  \"Ball (DList_set dxs) P' = \n  (case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''Ball DList_set: ceq = None'') (\\<lambda>_. Ball (DList_set dxs) P')\n                  | Some _ \\<Rightarrow> DList_Set.dlist_all P' dxs)\"\n  \"Ball (RBT_set rbt) P'' = \n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''Ball RBT_set: ccompare = None'') (\\<lambda>_. Ball (RBT_set rbt) P'')\n                     | Some _ \\<Rightarrow> RBT_Set2.all P'' rbt)\"", "lemma Bex_code [code]:\n  fixes rbt :: \"'a :: ccompare set_rbt\"\n  and dxs :: \"'b :: ceq set_dlist\" shows\n  \"Bex (Set_Monad xs) P = list_ex P xs\"\n  \"Bex (DList_set dxs) P' = \n  (case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''Bex DList_set: ceq = None'') (\\<lambda>_. Bex (DList_set dxs) P')\n                  | Some _ \\<Rightarrow> DList_Set.dlist_ex P' dxs)\"\n  \"Bex (RBT_set rbt) P'' = \n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''Bex RBT_set: ccompare = None'') (\\<lambda>_. Bex (RBT_set rbt) P'')\n                     | Some _ \\<Rightarrow> RBT_Set2.ex P'' rbt)\"", "lemma csorted_list_of_set_code [code]:\n  fixes rbt :: \"'a :: ccompare set_rbt\" \n  and dxs :: \"'b :: {ccompare, ceq} set_dlist\" \n  and xs :: \"'a :: ccompare list\" shows\n  \"csorted_list_of_set (RBT_set rbt) =\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''csorted_list_of_set RBT_set: ccompare = None'') (\\<lambda>_. csorted_list_of_set (RBT_set rbt))\n                     | Some _ \\<Rightarrow> RBT_Set2.keys rbt)\"\n  \"csorted_list_of_set (DList_set dxs) =\n  (case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''csorted_list_of_set DList_set: ceq = None'') (\\<lambda>_. csorted_list_of_set (DList_set dxs))\n              | Some _ \\<Rightarrow>\n     case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''csorted_list_of_set DList_set: ccompare = None'') (\\<lambda>_. csorted_list_of_set (DList_set dxs))\n                 | Some c \\<Rightarrow> ord.quicksort (lt_of_comp c) (list_of_dlist dxs))\"\n  \"csorted_list_of_set (Set_Monad xs) =\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''csorted_list_of_set Set_Monad: ccompare = None'') (\\<lambda>_. csorted_list_of_set (Set_Monad xs))\n              | Some c \\<Rightarrow> ord.remdups_sorted (lt_of_comp c) (ord.quicksort (lt_of_comp c) xs))\"", "lemma cless_set_code [code]:\n  fixes rbt rbt' :: \"'a :: ccompare set_rbt\"\n  and rbt1 rbt2 :: \"'b :: cproper_interval set_rbt\"\n  and A B :: \"'a set\" \n  and A' B' :: \"'b set\" shows\n  \"cless_set A B \\<longleftrightarrow>\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''cless_set: ccompare = None'') (\\<lambda>_. cless_set A B)\n              | Some c \\<Rightarrow>\n     if finite A \\<and> finite B then ord.lexordp (\\<lambda>x y. lt_of_comp c y x) (csorted_list_of_set A) (csorted_list_of_set B)\n     else Code.abort (STR ''cless_set: infinite set'') (\\<lambda>_. cless_set A B))\"\n  (is \"?fin_fin\")\n  and cless_set_Complement2 [set_complement_code]:\n  \"cless_set A' (Complement B') \\<longleftrightarrow>\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''cless_set Complement2: ccompare = None'') (\\<lambda>_. cless_set A' (Complement B'))\n              | Some c \\<Rightarrow>\n     if finite A' \\<and> finite B' then\n        finite (UNIV :: 'b set) \\<longrightarrow>\n        proper_intrvl.set_less_aux_Compl (lt_of_comp c) cproper_interval None (csorted_list_of_set A') (csorted_list_of_set B')\n     else Code.abort (STR ''cless_set Complement2: infinite set'') (\\<lambda>_. cless_set A' (Complement B')))\"\n  (is \"?fin_Compl_fin\")\n  and cless_set_Complement1 [set_complement_code]:\n  \"cless_set (Complement A') B' \\<longleftrightarrow>\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''cless_set Complement1: ccompare = None'') (\\<lambda>_. cless_set (Complement A') B')\n              | Some c \\<Rightarrow>\n      if finite A' \\<and> finite B' then\n        finite (UNIV :: 'b set) \\<and>\n        proper_intrvl.Compl_set_less_aux (lt_of_comp c) cproper_interval None (csorted_list_of_set A') (csorted_list_of_set B')\n      else Code.abort (STR ''cless_set Complement1: infinite set'') (\\<lambda>_. cless_set (Complement A') B'))\"\n  (is \"?Compl_fin_fin\")\n  and cless_set_Complement12 [set_complement_code]:\n  \"cless_set (Complement A) (Complement B) \\<longleftrightarrow>\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''cless_set Complement Complement: ccompare = None'') (\\<lambda>_. cless_set (Complement A) (Complement B))\n                     | Some _ \\<Rightarrow> cless B A)\" (is ?Compl_Compl)\n  and\n  \"cless_set (RBT_set rbt) (RBT_set rbt') \\<longleftrightarrow> \n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''cless_set RBT_set RBT_set: ccompare = None'') (\\<lambda>_. cless_set (RBT_set rbt) (RBT_set rbt'))\n             | Some c \\<Rightarrow> ord.lexord_fusion (\\<lambda>x y. lt_of_comp c y x) rbt_keys_generator rbt_keys_generator (RBT_Set2.init rbt) (RBT_Set2.init rbt'))\"\n    (is ?rbt_rbt)\n  and cless_set_rbt_Complement2 [set_complement_code]:\n  \"cless_set (RBT_set rbt1) (Complement (RBT_set rbt2)) \\<longleftrightarrow>\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''cless_set RBT_set (Complement RBT_set): ccompare = None'') (\\<lambda>_. cless_set (RBT_set rbt1) (Complement (RBT_set rbt2)))\n             | Some c \\<Rightarrow>\n     finite (UNIV :: 'b set) \\<longrightarrow>\n     proper_intrvl.set_less_aux_Compl_fusion (lt_of_comp c) cproper_interval rbt_keys_generator rbt_keys_generator None (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))\"\n    (is ?rbt_Compl)\n  and cless_set_rbt_Complement1 [set_complement_code]:\n  \"cless_set (Complement (RBT_set rbt1)) (RBT_set rbt2) \\<longleftrightarrow>\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''cless_set (Complement RBT_set) RBT_set: ccompare = None'') (\\<lambda>_. cless_set (Complement (RBT_set rbt1)) (RBT_set rbt2))\n             | Some c \\<Rightarrow>\n     finite (UNIV :: 'b set) \\<and> \n     proper_intrvl.Compl_set_less_aux_fusion (lt_of_comp c) cproper_interval rbt_keys_generator rbt_keys_generator None (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))\"\n    (is ?Compl_rbt)", "lemma le_of_comp_set_less_eq: \n  \"le_of_comp (comp_of_ords (ord.set_less_eq le) (ord.set_less le)) = ord.set_less_eq le\"", "lemma cless_eq_set_code [code]:\n  fixes rbt rbt' :: \"'a :: ccompare set_rbt\"\n  and rbt1 rbt2 :: \"'b :: cproper_interval set_rbt\"\n  and A B :: \"'a set\" \n  and A' B' :: \"'b set\" shows\n  \"cless_eq_set A B \\<longleftrightarrow>\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''cless_eq_set: ccompare = None'') (\\<lambda>_. cless_eq_set A B)\n              | Some c \\<Rightarrow>\n     if finite A \\<and> finite B then \n        ord.lexordp_eq (\\<lambda>x y. lt_of_comp c y x) (csorted_list_of_set A) (csorted_list_of_set B)\n     else Code.abort (STR ''cless_eq_set: infinite set'') (\\<lambda>_. cless_eq_set A B))\"\n  (is \"?fin_fin\")\n  and cless_eq_set_Complement2 [set_complement_code]:\n  \"cless_eq_set A' (Complement B') \\<longleftrightarrow>\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''cless_eq_set Complement2: ccompare = None'') (\\<lambda>_. cless_eq_set A' (Complement B'))\n              | Some c \\<Rightarrow>\n     if finite A' \\<and> finite B' then \n        finite (UNIV :: 'b set) \\<longrightarrow>\n        proper_intrvl.set_less_eq_aux_Compl (lt_of_comp c) cproper_interval None (csorted_list_of_set A') (csorted_list_of_set B')\n     else Code.abort (STR ''cless_eq_set Complement2: infinite set'') (\\<lambda>_. cless_eq_set A' (Complement B')))\"\n  (is \"?fin_Compl_fin\")\n  and cless_eq_set_Complement1 [set_complement_code]:\n  \"cless_eq_set (Complement A') B' \\<longleftrightarrow>\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''cless_eq_set Complement1: ccompare = None'') (\\<lambda>_. cless_eq_set (Complement A') B')\n              | Some c \\<Rightarrow>\n    if finite A' \\<and> finite B' then \n      finite (UNIV :: 'b set) \\<and>\n      proper_intrvl.Compl_set_less_eq_aux (lt_of_comp c) cproper_interval None (csorted_list_of_set A') (csorted_list_of_set B')\n    else Code.abort (STR ''cless_eq_set Complement1: infinite set'') (\\<lambda>_. cless_eq_set (Complement A') B'))\"\n  (is \"?Compl_fin_fin\")\n  and cless_eq_set_Complement12 [set_complement_code]:\n  \"cless_eq_set (Complement A) (Complement B) \\<longleftrightarrow> \n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''cless_eq_set Complement Complement: ccompare = None'') (\\<lambda>_. cless_eq (Complement A) (Complement B))\n             | Some c \\<Rightarrow> cless_eq_set B A)\" \n  (is ?Compl_Compl)\n\n  \"cless_eq_set (RBT_set rbt) (RBT_set rbt') \\<longleftrightarrow> \n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''cless_eq_set RBT_set RBT_set: ccompare = None'') (\\<lambda>_. cless_eq_set (RBT_set rbt) (RBT_set rbt'))\n             | Some c \\<Rightarrow> ord.lexord_eq_fusion (\\<lambda>x y. lt_of_comp c y x) rbt_keys_generator rbt_keys_generator (RBT_Set2.init rbt) (RBT_Set2.init rbt'))\" \n    (is ?rbt_rbt)\n  and cless_eq_set_rbt_Complement2 [set_complement_code]:\n  \"cless_eq_set (RBT_set rbt1) (Complement (RBT_set rbt2)) \\<longleftrightarrow>\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''cless_eq_set RBT_set (Complement RBT_set): ccompare = None'') (\\<lambda>_. cless_eq_set (RBT_set rbt1) (Complement (RBT_set rbt2)))\n             | Some c \\<Rightarrow>\n     finite (UNIV :: 'b set) \\<longrightarrow>\n     proper_intrvl.set_less_eq_aux_Compl_fusion (lt_of_comp c) cproper_interval rbt_keys_generator rbt_keys_generator None (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))\"\n    (is ?rbt_Compl)\n  and cless_eq_set_rbt_Complement1 [set_complement_code]:\n  \"cless_eq_set (Complement (RBT_set rbt1)) (RBT_set rbt2) \\<longleftrightarrow>\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''cless_eq_set (Complement RBT_set) RBT_set: ccompare = None'') (\\<lambda>_. cless_eq_set (Complement (RBT_set rbt1)) (RBT_set rbt2))\n             | Some c \\<Rightarrow>\n     finite (UNIV :: 'b set) \\<and> \n     proper_intrvl.Compl_set_less_eq_aux_fusion (lt_of_comp c) cproper_interval rbt_keys_generator rbt_keys_generator None (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))\"\n    (is ?Compl_rbt)", "lemma cproper_interval_set_Some_Some_code [code]:\n  fixes rbt1 rbt2 :: \"'a :: cproper_interval set_rbt\" \n  and A B :: \"'a set\" shows\n\n  \"cproper_interval (Some A) (Some B) \\<longleftrightarrow>\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''cproper_interval: ccompare = None'') (\\<lambda>_. cproper_interval (Some A) (Some B))\n              | Some c \\<Rightarrow>\n       finite (UNIV :: 'a set) \\<and> proper_intrvl.proper_interval_set_aux (lt_of_comp c) cproper_interval (csorted_list_of_set A) (csorted_list_of_set B))\"\n  (is ?fin_fin)\n  and cproper_interval_set_Some_Some_Complement [set_complement_code]:\n  \"cproper_interval (Some A) (Some (Complement B)) \\<longleftrightarrow>\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''cproper_interval Complement2: ccompare = None'') (\\<lambda>_. cproper_interval (Some A) (Some (Complement B)))\n              | Some c \\<Rightarrow>\n       finite (UNIV :: 'a set) \\<and> proper_intrvl.proper_interval_set_Compl_aux (lt_of_comp c) cproper_interval None 0 (csorted_list_of_set A) (csorted_list_of_set B))\"\n  (is ?fin_Compl_fin)\n  and cproper_interval_set_Some_Complement_Some [set_complement_code]:\n  \"cproper_interval (Some (Complement A)) (Some B) \\<longleftrightarrow>\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''cproper_interval Complement1: ccompare = None'') (\\<lambda>_. cproper_interval (Some (Complement A)) (Some B))\n              | Some c \\<Rightarrow>\n       finite (UNIV :: 'a set) \\<and> proper_intrvl.proper_interval_Compl_set_aux (lt_of_comp c) cproper_interval None (csorted_list_of_set A) (csorted_list_of_set B))\"\n  (is ?Compl_fin_fin)\n  and cproper_interval_set_Some_Complement_Some_Complement [set_complement_code]:\n  \"cproper_interval (Some (Complement A)) (Some (Complement B)) \\<longleftrightarrow>\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''cproper_interval Complement Complement: ccompare = None'') (\\<lambda>_. cproper_interval (Some (Complement A)) (Some (Complement B)))\n             | Some _ \\<Rightarrow> cproper_interval (Some B) (Some A))\"\n  (is ?Compl_Compl)\n\n  \"cproper_interval (Some (RBT_set rbt1)) (Some (RBT_set rbt2)) \\<longleftrightarrow>\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''cproper_interval RBT_set RBT_set: ccompare = None'') (\\<lambda>_. cproper_interval (Some (RBT_set rbt1)) (Some (RBT_set rbt2)))\n             | Some c \\<Rightarrow>\n     finite (UNIV :: 'a set) \\<and> proper_intrvl.proper_interval_set_aux_fusion (lt_of_comp c) cproper_interval rbt_keys_generator rbt_keys_generator (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))\"\n  (is ?rbt_rbt)\n  and cproper_interval_set_Some_rbt_Some_Complement [set_complement_code]:\n  \"cproper_interval (Some (RBT_set rbt1)) (Some (Complement (RBT_set rbt2))) \\<longleftrightarrow>\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''cproper_interval RBT_set (Complement RBT_set): ccompare = None'') (\\<lambda>_. cproper_interval (Some (RBT_set rbt1)) (Some (Complement (RBT_set rbt2))))\n             | Some c \\<Rightarrow>\n     finite (UNIV :: 'a set) \\<and> proper_intrvl.proper_interval_set_Compl_aux_fusion (lt_of_comp c) cproper_interval rbt_keys_generator rbt_keys_generator None 0 (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))\"\n  (is ?rbt_Compl_rbt)\n  and cproper_interval_set_Some_Complement_Some_rbt [set_complement_code]:\n  \"cproper_interval (Some (Complement (RBT_set rbt1))) (Some (RBT_set rbt2)) \\<longleftrightarrow>\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''cproper_interval (Complement RBT_set) RBT_set: ccompare = None'') (\\<lambda>_. cproper_interval (Some (Complement (RBT_set rbt1))) (Some (RBT_set rbt2)))\n             | Some c \\<Rightarrow>\n     finite (UNIV :: 'a set) \\<and> proper_intrvl.proper_interval_Compl_set_aux_fusion (lt_of_comp c) cproper_interval rbt_keys_generator rbt_keys_generator None (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))\"\n  (is ?Compl_rbt_rbt)", "lemma sorted_list_subset_correct:\n  \"\\<lbrakk> sorted xs; distinct xs; sorted ys; distinct ys \\<rbrakk> \n  \\<Longrightarrow> sorted_list_subset (=) xs ys \\<longleftrightarrow> set xs \\<subseteq> set ys\"", "lemma sorted_list_subset_fusion_code:\n  \"sorted_list_subset_fusion eq g1 g2 s1 s2 =\n  (if list.has_next g1 s1 then\n     let (x, s1') = list.next g1 s1\n     in list.has_next g2 s2 \\<and> (\n        let (y, s2') = list.next g2 s2 \n        in if eq x y then sorted_list_subset_fusion eq g1 g2 s1' s2' \n           else y < x \\<and> sorted_list_subset_fusion eq g1 g2 s1 s2')\n   else True)\"", "lemmas [code] = ord.sorted_list_subset_fusion_code", "lemma subseteq_code [code]: \"(\\<subseteq>) = subset_eq\"", "lemma subset'_code [code]: \"Cardinality.subset' = subset_eq\"", "lemma subset_eq_code [folded subset_eq_def, code]:\n  fixes A1 A2 :: \"'a set\"\n  and rbt :: \"'b :: ccompare set_rbt\"\n  and rbt1 rbt2 :: \"'d :: {ccompare, ceq} set_rbt\"\n  and dxs :: \"'c :: ceq set_dlist\" \n  and xs :: \"'c list\" shows\n  \"RBT_set rbt \\<subseteq> B \\<longleftrightarrow> \n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''subset RBT_set1: ccompare = None'') (\\<lambda>_. RBT_set rbt \\<subseteq> B)\n                     | Some _ \\<Rightarrow> list_all_fusion rbt_keys_generator (\\<lambda>x. x \\<in> B) (RBT_Set2.init rbt))\" (is ?rbt)\n  \"DList_set dxs \\<subseteq> C \\<longleftrightarrow> \n  (case ID CEQ('c) of None \\<Rightarrow> Code.abort (STR ''subset DList_set1: ceq = None'') (\\<lambda>_. DList_set dxs \\<subseteq> C)\n                     | Some _ \\<Rightarrow> DList_Set.dlist_all (\\<lambda>x. x \\<in> C) dxs)\" (is ?dlist)\n  \"Set_Monad xs \\<subseteq> C \\<longleftrightarrow> list_all (\\<lambda>x. x \\<in> C) xs\" (is ?Set_Monad)\n  and Collect_subset_eq_Complement [folded subset_eq_def, set_complement_code]:\n  \"Collect_set P \\<subseteq> Complement A \\<longleftrightarrow> A \\<subseteq> {x. \\<not> P x}\" (is ?Collect_set_Compl)\n  and Complement_subset_eq_Complement [folded subset_eq_def, set_complement_code]:\n  \"Complement A1 \\<subseteq> Complement A2 \\<longleftrightarrow> A2 \\<subseteq> A1\" (is ?Compl)\n  and\n  \"RBT_set rbt1 \\<subseteq> RBT_set rbt2 \\<longleftrightarrow>\n  (case ID CCOMPARE('d) of None \\<Rightarrow> Code.abort (STR ''subset RBT_set RBT_set: ccompare = None'') (\\<lambda>_. RBT_set rbt1 \\<subseteq> RBT_set rbt2)\n                     | Some c \\<Rightarrow> \n    (case ID CEQ('d) of None \\<Rightarrow> ord.sorted_list_subset_fusion (lt_of_comp c) (\\<lambda> x y. c x y = Eq) rbt_keys_generator rbt_keys_generator (RBT_Set2.init rbt1) (RBT_Set2.init rbt2)\n                   | Some eq \\<Rightarrow> ord.sorted_list_subset_fusion (lt_of_comp c) eq rbt_keys_generator rbt_keys_generator (RBT_Set2.init rbt1) (RBT_Set2.init rbt2)))\" \n  (is ?rbt_rbt)", "lemma eq_set_code [code]: \"Cardinality.eq_set = set_eq\"", "lemma set_eq_code [code]:\n  fixes rbt1 rbt2 :: \"'b :: {ccompare, ceq} set_rbt\" shows\n  \"set_eq A B \\<longleftrightarrow> A \\<subseteq> B \\<and> B \\<subseteq> A\"\n  and set_eq_Complement_Complement [set_complement_code]:\n  \"set_eq (Complement A) (Complement B) = set_eq A B\"\n  and\n  \"set_eq (RBT_set rbt1) (RBT_set rbt2) = \n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''set_eq RBT_set RBT_set: ccompare = None'') (\\<lambda>_. set_eq (RBT_set rbt1) (RBT_set rbt2))\n                     | Some c \\<Rightarrow> \n     (case ID CEQ('b) of None \\<Rightarrow> list_all2_fusion (\\<lambda> x y. c x y = Eq) rbt_keys_generator rbt_keys_generator (RBT_Set2.init rbt1) (RBT_Set2.init rbt2)\n                    | Some eq \\<Rightarrow> list_all2_fusion eq rbt_keys_generator rbt_keys_generator (RBT_Set2.init rbt1) (RBT_Set2.init rbt2)))\"\n  (is ?rbt_rbt)", "lemma Set_project_code [code]:\n  \"Set.filter P A = A \\<inter> Collect_set P\"", "lemma Set_image_code [code]:\n  fixes dxs :: \"'a :: ceq set_dlist\" \n  and rbt :: \"'b :: ccompare set_rbt\" shows\n  \"image f (Set_Monad xs) = Set_Monad (map f xs)\"\n  \"image f (Collect_set A) = Code.abort (STR ''image Collect_set'') (\\<lambda>_. image f (Collect_set A))\"\n  and image_Complement_Complement [set_complement_code]:\n  \"image f (Complement (Complement B)) = image f B\"\n  and\n  \"image g (DList_set dxs) = \n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''image DList_set: ceq = None'') (\\<lambda>_. image g (DList_set dxs))\n                  | Some _ \\<Rightarrow> DList_Set.fold (insert \\<circ> g) dxs {})\"\n  (is ?dlist)\n  \"image h (RBT_set rbt) = \n   (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''image RBT_set: ccompare = None'') (\\<lambda>_. image h (RBT_set rbt))\n                      | Some _ \\<Rightarrow> RBT_Set2.fold (insert \\<circ> h) rbt {})\"\n   (is ?rbt)", "lemma the_elem_code [code]:\n  fixes dxs :: \"'a :: ceq set_dlist\" \n  and rbt :: \"'b :: ccompare set_rbt\" shows\n  \"the_elem (Set_Monad [x]) = x\"\n  \"the_elem (DList_set dxs) =\n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''the_elem DList_set: ceq = None'') (\\<lambda>_. the_elem (DList_set dxs))\n                  | Some _ \\<Rightarrow> \n     case list_of_dlist dxs of [x] \\<Rightarrow> x \n       | _ \\<Rightarrow> Code.abort (STR ''the_elem DList_set: not unique'') (\\<lambda>_. the_elem (DList_set dxs)))\"\n  \"the_elem (RBT_set rbt) =\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''the_elem RBT_set: ccompare = None'') (\\<lambda>_. the_elem (RBT_set rbt))\n                     | Some _ \\<Rightarrow> \n     case RBT_Mapping2.impl_of rbt of RBT_Impl.Branch _ RBT_Impl.Empty x _ RBT_Impl.Empty \\<Rightarrow> x\n       | _ \\<Rightarrow> Code.abort (STR ''the_elem RBT_set: not unique'') (\\<lambda>_. the_elem (RBT_set rbt)))\"", "lemma Pow_set_conv_fold:\n  \"Pow (set xs \\<union> A) = fold (\\<lambda>x A. A \\<union> insert x ` A) xs (Pow A)\"", "lemma Pow_code [code]:\n  fixes dxs :: \"'a :: ceq set_dlist\" \n  and rbt :: \"'b :: ccompare set_rbt\" shows\n  \"Pow A = Collect_set (\\<lambda>B. B \\<subseteq> A)\"\n  \"Pow (Set_Monad xs) = fold (\\<lambda>x A. A \\<union> insert x ` A) xs {{}}\"\n  \"Pow (DList_set dxs) =\n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''Pow DList_set: ceq = None'') (\\<lambda>_. Pow (DList_set dxs))\n                  | Some _ \\<Rightarrow> DList_Set.fold (\\<lambda>x A. A \\<union> insert x ` A) dxs {{}})\"\n  \"Pow (RBT_set rbt) =\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''Pow RBT_set: ccompare = None'') (\\<lambda>_. Pow (RBT_set rbt))\n                     | Some _ \\<Rightarrow> RBT_Set2.fold (\\<lambda>x A. A \\<union> insert x ` A) rbt {{}})\"", "lemma fold_singleton: \"Finite_Set.fold f x {y} = f y x\"", "lemma sum_code [code]:\n  \"sum f A = (if finite A then set_fold_cfc (sum_cfc f) 0 A else 0)\"", "lemma product_code [code]:\n  fixes dxs :: \"'a :: ceq set_dlist\"\n  and dys :: \"'b :: ceq set_dlist\" \n  and rbt1 :: \"'c :: ccompare set_rbt\"\n  and rbt2 :: \"'d :: ccompare set_rbt\" shows\n  \"Product_Type.product A B = Collect_set (\\<lambda>(x, y). x \\<in> A \\<and> y \\<in> B)\"\n\n  \"Product_Type.product (Set_Monad xs) (Set_Monad ys) = \n   Set_Monad (fold (\\<lambda>x. fold (\\<lambda>y rest. (x, y) # rest) ys) xs [])\"\n  (is ?Set_Monad)\n\n  \"Product_Type.product (DList_set dxs) B1 = \n   (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''product DList_set1: ceq = None'') (\\<lambda>_. Product_Type.product (DList_set dxs) B1)\n                   | Some _ \\<Rightarrow>  DList_Set.fold (\\<lambda>x rest. Pair x ` B1 \\<union> rest) dxs {})\" \n  (is \"?dlist1\")\n\n  \"Product_Type.product A1 (DList_set dys) = \n   (case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''product DList_set2: ceq = None'') (\\<lambda>_. Product_Type.product A1 (DList_set dys))\n                   | Some _ \\<Rightarrow> DList_Set.fold (\\<lambda>y rest. (\\<lambda>x. (x, y)) ` A1 \\<union> rest) dys {})\"\n  (is \"?dlist2\")\n\n  \"Product_Type.product (DList_set dxs) (DList_set dys) = \n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''product DList_set DList_set: ceq1 = None'') (\\<lambda>_. Product_Type.product (DList_set dxs) (DList_set dys))\n                  | Some _ \\<Rightarrow> \n     case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''product DList_set DList_set: ceq2 = None'') (\\<lambda>_. Product_Type.product (DList_set dxs) (DList_set dys))\n                    | Some _ \\<Rightarrow> DList_set (DList_Set.product dxs dys))\"\n\n  \"Product_Type.product (RBT_set rbt1) B2 =\n  (case ID CCOMPARE('c) of None \\<Rightarrow> Code.abort (STR ''product RBT_set: ccompare1 = None'') (\\<lambda>_. Product_Type.product (RBT_set rbt1) B2)\n                     | Some _ \\<Rightarrow> RBT_Set2.fold (\\<lambda>x rest. Pair x ` B2 \\<union> rest) rbt1 {})\"\n  (is \"?rbt1\")\n\n  \"Product_Type.product A2 (RBT_set rbt2) =\n  (case ID CCOMPARE('d) of None \\<Rightarrow> Code.abort (STR ''product RBT_set: ccompare2 = None'') (\\<lambda>_. Product_Type.product A2 (RBT_set rbt2))\n                     | Some _ \\<Rightarrow> RBT_Set2.fold (\\<lambda>y rest. (\\<lambda>x. (x, y)) ` A2 \\<union> rest) rbt2 {})\"\n  (is \"?rbt2\")\n\n  \"Product_Type.product (RBT_set rbt1) (RBT_set rbt2) =\n  (case ID CCOMPARE('c) of None \\<Rightarrow> Code.abort (STR ''product RBT_set RBT_set: ccompare1 = None'') (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n                     | Some _ \\<Rightarrow>\n     case ID CCOMPARE('d) of None \\<Rightarrow> Code.abort (STR ''product RBT_set RBT_set: ccompare2 = None'') (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n                       | Some _ \\<Rightarrow> RBT_set (RBT_Set2.product rbt1 rbt2))\"", "lemma Id_on_code [code]: \n  fixes A :: \"'a :: ceq set\"\n  and dxs :: \"'a set_dlist\" \n  and P :: \"'a \\<Rightarrow> bool\" \n  and rbt :: \"'b :: ccompare set_rbt\" shows\n  \"Id_on B = (\\<lambda>x. (x, x)) ` B\"\n  and Id_on_Complement [set_complement_code]:\n  \"Id_on (Complement A) =\n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''Id_on Complement: ceq = None'') (\\<lambda>_. Id_on (Complement A))\n                 | Some eq \\<Rightarrow> Collect_set (\\<lambda>(x, y). eq x y \\<and> x \\<notin> A))\"\n  and\n  \"Id_on (Collect_set P) =\n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''Id_on Collect_set: ceq = None'') (\\<lambda>_. Id_on (Collect_set P))\n                 | Some eq \\<Rightarrow> Collect_set (\\<lambda>(x, y). eq x y \\<and> P x))\"\n  \"Id_on (DList_set dxs) = \n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''Id_on DList_set: ceq = None'') (\\<lambda>_. Id_on (DList_set dxs))\n                  | Some _ \\<Rightarrow> DList_set (DList_Set.Id_on dxs))\"\n  \"Id_on (RBT_set rbt) =\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''Id_on RBT_set: ccompare = None'') (\\<lambda>_. Id_on (RBT_set rbt))\n                     | Some _ \\<Rightarrow> RBT_set (RBT_Set2.Id_on rbt))\"", "lemma Image_code [code]:\n  fixes dxs :: \"('a :: ceq \\<times> 'b :: ceq) set_dlist\" \n  and rbt :: \"('c :: ccompare \\<times> 'd :: ccompare) set_rbt\" shows\n  \"X `` Y = snd ` Set.filter (\\<lambda>(x, y). x \\<in> Y) X\"\n  (is ?generic)\n\n  \"Set_Monad rxs `` A = Set_Monad (fold (\\<lambda>(x, y) rest. if x \\<in> A then y # rest else rest) rxs [])\"\n  (is ?Set_Monad)\n  \"DList_set dxs `` B = \n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''Image DList_set: ceq1 = None'') (\\<lambda>_. DList_set dxs `` B)\n                  | Some _ \\<Rightarrow>\n     case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''Image DList_set: ceq2 = None'') (\\<lambda>_. DList_set dxs `` B)\n                    | Some _ \\<Rightarrow>\n        DList_Set.fold (\\<lambda>(x, y) acc. if x \\<in> B then insert y acc else acc) dxs {})\"\n  (is ?DList_set)\n  \"RBT_set rbt `` C =\n   (case ID CCOMPARE('c) of None \\<Rightarrow> Code.abort (STR ''Image RBT_set: ccompare1 = None'') (\\<lambda>_. RBT_set rbt `` C)\n                      | Some _ \\<Rightarrow>\n      case ID CCOMPARE('d) of None \\<Rightarrow> Code.abort (STR ''Image RBT_set: ccompare2 = None'') (\\<lambda>_. RBT_set rbt `` C)\n                        | Some _ \\<Rightarrow>\n        RBT_Set2.fold (\\<lambda>(x, y) acc. if x \\<in> C then insert y acc else acc) rbt {})\"\n  (is ?RBT_set)", "lemma insert_relcomp: \"insert (a, b) A O B = A O B \\<union> {a} \\<times> {c. (b, c) \\<in> B}\"", "lemma trancl_code [code]:\n  \"trancl A = \n  (if finite A then ntrancl (card A - 1) A else Code.abort (STR ''trancl: infinite set'') (\\<lambda>_. trancl A))\"", "lemma set_relcomp_set:\n  \"set xs O set ys = fold (\\<lambda>(x, y). fold (\\<lambda>(y', z) A. if y = y' then insert (x, z) A else A) ys) xs {}\"", "lemma If_not: \"(if \\<not> a then b else c) = (if a then c else b)\"", "lemma relcomp_code [code]:\n  fixes rbt1 :: \"('a :: ccompare \\<times> 'b :: ccompare) set_rbt\"\n  and rbt2 :: \"('b \\<times> 'c :: ccompare) set_rbt\"\n  and rbt3 :: \"('a \\<times> 'd :: {ccompare, ceq}) set_rbt\" \n  and rbt4 :: \"('d \\<times> 'a) set_rbt\"\n  and rbt5 :: \"('b \\<times> 'a) set_rbt\"\n  and dxs1 :: \"('d \\<times> 'e :: ceq) set_dlist\" \n  and dxs2 :: \"('e \\<times> 'd) set_dlist\"\n  and dxs3 :: \"('e \\<times> 'f :: ceq) set_dlist\"\n  and dxs4 :: \"('f \\<times> 'g :: ceq) set_dlist\"\n  and xs1 :: \"('h \\<times> 'i :: ceq) list\"\n  and xs2 :: \"('i \\<times> 'j) list\"\n  and xs3 :: \"('b \\<times> 'h) list\"\n  and xs4 :: \"('h \\<times> 'b) list\"\n  and xs5 :: \"('f \\<times> 'h) list\"\n  and xs6 :: \"('h \\<times> 'f) list\"\n  shows\n  \"RBT_set rbt1 O RBT_set rbt2 = \n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''relcomp RBT_set RBT_set: ccompare1 = None'') (\\<lambda>_. RBT_set rbt1 O RBT_set rbt2)\n                     | Some _ \\<Rightarrow>\n     case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''relcomp RBT_set RBT_set: ccompare2 = None'') (\\<lambda>_. RBT_set rbt1 O RBT_set rbt2)\n           | Some c_b \\<Rightarrow>\n       case ID CCOMPARE('c) of None \\<Rightarrow> Code.abort (STR ''relcomp RBT_set RBT_set: ccompare3 = None'') (\\<lambda>_. RBT_set rbt1 O RBT_set rbt2)\n                         | Some _ \\<Rightarrow> RBT_Set2.fold (\\<lambda>(x, y). RBT_Set2.fold (\\<lambda>(y', z) A. if c_b y y' \\<noteq> Eq then A else insert (x, z) A) rbt2) rbt1 {})\"\n  (is ?rbt_rbt)\n\n  \"RBT_set rbt3 O DList_set dxs1 = \n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''relcomp RBT_set DList_set: ccompare1 = None'') (\\<lambda>_. RBT_set rbt3 O DList_set dxs1)\n                     | Some _ \\<Rightarrow>\n     case ID CCOMPARE('d) of None \\<Rightarrow> Code.abort (STR ''relcomp RBT_set DList_set: ccompare2 = None'') (\\<lambda>_. RBT_set rbt3 O DList_set dxs1)\n                       | Some _ \\<Rightarrow>\n       case ID CEQ('d) of None \\<Rightarrow> Code.abort (STR ''relcomp RBT_set DList_set: ceq2 = None'') (\\<lambda>_. RBT_set rbt3 O DList_set dxs1)\n                     | Some eq \\<Rightarrow>\n         case ID CEQ('e) of None \\<Rightarrow> Code.abort (STR ''relcomp RBT_set DList_set: ceq3 = None'') (\\<lambda>_. RBT_set rbt3 O DList_set dxs1)\n                        | Some _ \\<Rightarrow> RBT_Set2.fold (\\<lambda>(x, y). DList_Set.fold (\\<lambda>(y', z) A. if eq y y' then insert (x, z) A else A) dxs1) rbt3 {})\"\n  (is ?rbt_dlist)\n\n  \"DList_set dxs2 O RBT_set rbt4 = \n  (case ID CEQ('e) of None \\<Rightarrow> Code.abort (STR ''relcomp DList_set RBT_set: ceq1 = None'') (\\<lambda>_. DList_set dxs2 O RBT_set rbt4)\n                  | Some _ \\<Rightarrow>\n     case ID CCOMPARE('d) of None \\<Rightarrow> Code.abort (STR ''relcomp DList_set RBT_set: ceq2 = None'') (\\<lambda>_. DList_set dxs2 O RBT_set rbt4)\n                       | Some _ \\<Rightarrow>\n       case ID CEQ('d) of None \\<Rightarrow> Code.abort (STR ''relcomp DList_set RBT_set: ccompare2 = None'') (\\<lambda>_. DList_set dxs2 O RBT_set rbt4)\n                     | Some eq \\<Rightarrow>\n         case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''relcomp DList_set RBT_set: ccompare3 = None'') (\\<lambda>_. DList_set dxs2 O RBT_set rbt4)\n                           | Some _ \\<Rightarrow> DList_Set.fold (\\<lambda>(x, y). RBT_Set2.fold (\\<lambda>(y', z) A. if eq y y' then insert (x, z) A else A) rbt4) dxs2 {})\"\n  (is ?dlist_rbt)\n\n  \"DList_set dxs3 O DList_set dxs4 =\n  (case ID CEQ('e) of None \\<Rightarrow> Code.abort (STR ''relcomp DList_set DList_set: ceq1 = None'') (\\<lambda>_. DList_set dxs3 O DList_set dxs4)\n                  | Some _ \\<Rightarrow>\n     case ID CEQ('f) of None \\<Rightarrow> Code.abort (STR ''relcomp DList_set DList_set: ceq2 = None'') (\\<lambda>_. DList_set dxs3 O DList_set dxs4)\n                   | Some eq \\<Rightarrow>\n       case ID CEQ('g) of None \\<Rightarrow> Code.abort (STR ''relcomp DList_set DList_set: ceq3 = None'') (\\<lambda>_. DList_set dxs3 O DList_set dxs4)\n                      | Some _ \\<Rightarrow> DList_Set.fold (\\<lambda>(x, y). DList_Set.fold (\\<lambda>(y', z) A. if eq y y' then insert (x, z) A else A) dxs4) dxs3 {})\"\n  (is ?dlist_dlist)\n\n  \"Set_Monad xs1 O Set_Monad xs2 =\n  (case ID CEQ('i) of None \\<Rightarrow> Code.abort (STR ''relcomp Set_Monad Set_Monad: ceq = None'') (\\<lambda>_. Set_Monad xs1 O Set_Monad xs2)\n                 | Some eq \\<Rightarrow> fold (\\<lambda>(x, y). fold (\\<lambda>(y', z) A. if eq y y' then insert (x, z) A else A) xs2) xs1 {})\"\n  (is ?monad_monad)\n\n  \"RBT_set rbt1 O Set_Monad xs3 =\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''relcomp RBT_set Set_Monad: ccompare1 = None'') (\\<lambda>_. RBT_set rbt1 O Set_Monad xs3)\n                     | Some _ \\<Rightarrow>\n     case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''relcomp RBT_set Set_Monad: ccompare2 = None'') (\\<lambda>_. RBT_set rbt1 O Set_Monad xs3)\n           | Some c_b \\<Rightarrow> RBT_Set2.fold (\\<lambda>(x, y). fold (\\<lambda>(y', z) A. if c_b y y' \\<noteq> Eq then A else insert (x, z) A) xs3) rbt1 {})\"\n  (is ?rbt_monad)\n\n  \"Set_Monad xs4 O RBT_set rbt5 =\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''relcomp Set_Monad RBT_set: ccompare1 = None'') (\\<lambda>_. Set_Monad xs4 O RBT_set rbt5)\n                     | Some _ \\<Rightarrow>\n     case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''relcomp Set_Monad RBT_set: ccompare2 = None'') (\\<lambda>_. Set_Monad xs4 O RBT_set rbt5)\n           | Some c_b \\<Rightarrow> fold (\\<lambda>(x, y). RBT_Set2.fold (\\<lambda>(y', z) A. if c_b y y' \\<noteq> Eq then A else insert (x, z) A) rbt5) xs4 {})\"\n  (is ?monad_rbt)\n\n  \"DList_set dxs3 O Set_Monad xs5 =\n  (case ID CEQ('e) of None \\<Rightarrow> Code.abort (STR ''relcomp DList_set Set_Monad: ceq1 = None'') (\\<lambda>_. DList_set dxs3 O Set_Monad xs5)\n                  | Some _ \\<Rightarrow>\n     case ID CEQ('f) of None \\<Rightarrow> Code.abort (STR ''relcomp DList_set Set_Monad: ceq2 = None'') (\\<lambda>_. DList_set dxs3 O Set_Monad xs5)\n                   | Some eq \\<Rightarrow> DList_Set.fold (\\<lambda>(x, y). fold (\\<lambda>(y', z) A. if eq y y' then insert (x, z) A else A) xs5) dxs3 {})\"\n  (is ?dlist_monad)\n\n  \"Set_Monad xs6 O DList_set dxs4 =\n  (case ID CEQ('f) of None \\<Rightarrow> Code.abort (STR ''relcomp Set_Monad DList_set: ceq1 = None'') (\\<lambda>_. Set_Monad xs6 O DList_set dxs4)\n                      | Some eq \\<Rightarrow>\n     case ID CEQ('g) of None \\<Rightarrow> Code.abort (STR ''relcomp Set_Monad DList_set: ceq2 = None'') (\\<lambda>_. Set_Monad xs6 O DList_set dxs4)\n                   | Some _ \\<Rightarrow> fold (\\<lambda>(x, y). DList_Set.fold (\\<lambda>(y', z) A. if eq y y' then insert (x, z) A else A) dxs4) xs6 {})\"\n  (is ?monad_dlist)", "lemma irrefl_code [code]:\n  fixes r :: \"('a :: {ceq, ccompare} \\<times> 'a) set\" shows\n  \"irrefl r \\<longleftrightarrow> \n  (case ID CEQ('a) of Some eq \\<Rightarrow> (\\<forall>(x, y) \\<in> r. \\<not> eq x y) | None \\<Rightarrow>\n    case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''irrefl: ceq = None & ccompare = None'') (\\<lambda>_. irrefl r)\n                | Some c \\<Rightarrow> (\\<forall>(x, y) \\<in> r. c x y \\<noteq> Eq))\"", "lemma wf_code [code]:\n  fixes rbt :: \"('a :: ccompare \\<times> 'a) set_rbt\" \n  and dxs :: \"('b :: ceq \\<times> 'b) set_dlist\" shows\n  \"wf (Set_Monad xs) = acyclic (Set_Monad xs)\"\n  \"wf (RBT_set rbt) = \n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''wf RBT_set: ccompare = None'') (\\<lambda>_. wf (RBT_set rbt))\n                     | Some _ \\<Rightarrow> acyclic (RBT_set rbt))\"\n  \"wf (DList_set dxs) =\n  (case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''wf DList_set: ceq = None'') (\\<lambda>_. wf (DList_set dxs))\n                     | Some _ \\<Rightarrow> acyclic (DList_set dxs))\"", "lemma bacc_code [code]:\n  \"bacc R 0 = - snd ` R\"\n  \"bacc R (Suc n) = (let rec = bacc R n in rec \\<union> - snd ` (Set.filter (\\<lambda>(y, x). y \\<notin> rec) R))\"", "lemma acc_code [code]:\n  fixes A :: \"('a :: {finite, card_UNIV} \\<times> 'a) set\" shows\n  \"Wellfounded.acc A = bacc A (of_phantom (card_UNIV :: 'a card_UNIV))\"", "lemma sorted_list_of_set_code [code]:\n  fixes dxs :: \"'a :: {linorder, ceq} set_dlist\"\n  and rbt :: \"'b :: {linorder, ccompare} set_rbt\"\n  shows\n  \"sorted_list_of_set (Set_Monad xs) = sort (remdups xs)\"\n  \"sorted_list_of_set (DList_set dxs) =\n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''sorted_list_of_set DList_set: ceq = None'') (\\<lambda>_. sorted_list_of_set (DList_set dxs))\n                  | Some _ \\<Rightarrow> sort (list_of_dlist dxs))\"\n  \"sorted_list_of_set (RBT_set rbt) =\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''sorted_list_of_set RBT_set: ccompare = None'') (\\<lambda>_. sorted_list_of_set (RBT_set rbt))\n                     | Some _ \\<Rightarrow> sort (RBT_Set2.keys rbt))\"\n  \\<comment> \\<open>We must sort the keys because @{term ccompare}'s ordering need not coincide with @{term linorder}'s.\\<close>", "lemma map_project_set: \"List.map_project f (set xs) = set (List.map_filter f xs)\"", "lemma map_project_simps:\n  shows map_project_empty: \"List.map_project f {} = {}\"\n  and map_project_insert: \n  \"List.map_project f (insert x A) = \n  (case f x of None \\<Rightarrow> List.map_project f A \n   | Some y \\<Rightarrow> insert y (List.map_project f A))\"", "lemma map_project_conv_fold: \n  \"List.map_project f (set xs) = \n   fold (\\<lambda>x A. case f x of None \\<Rightarrow> A | Some y \\<Rightarrow> insert y A) xs {}\"", "lemma map_project_code [code]:\n  fixes dxs :: \"'a :: ceq set_dlist\" \n  and rbt :: \"'b :: ccompare set_rbt\" shows\n  \"List.map_project f (Set_Monad xs) = Set_Monad (List.map_filter f xs)\"\n  \"List.map_project g (DList_set dxs) = \n   (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''map_project DList_set: ceq = None'') (\\<lambda>_. List.map_project g (DList_set dxs))\n                   | Some _ \\<Rightarrow> DList_Set.fold (\\<lambda>x A. case g x of None \\<Rightarrow> A | Some y \\<Rightarrow> insert y A) dxs {})\"\n  (is ?dlist)\n  \"List.map_project h (RBT_set rbt) = \n   (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''map_project RBT_set: ccompare = None'') (\\<lambda>_. List.map_project h (RBT_set rbt))\n                      | Some _ \\<Rightarrow> RBT_Set2.fold (\\<lambda>x A. case h x of None \\<Rightarrow> A | Some y \\<Rightarrow> insert y A) rbt {})\"\n  (is ?rbt)", "lemma Bleast_code [code]:\n  \"Bleast A P = \n  (if finite A then case filter P (sorted_list_of_set A) of [] \\<Rightarrow> abort_Bleast A P | x # xs \\<Rightarrow> x \n   else abort_Bleast A P)\"", "lemma can_select_code [code]:\n  fixes xs :: \"'a :: ceq list\" \n  and dxs :: \"'a :: ceq set_dlist\" \n  and rbt :: \"'b :: ccompare set_rbt\" shows\n  \"can_select P (Set_Monad xs) =\n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''can_select Set_Monad: ceq = None'') (\\<lambda>_. can_select P (Set_Monad xs))\n                 | Some eq \\<Rightarrow> case filter P xs of Nil \\<Rightarrow> False | x # xs \\<Rightarrow> list_all (eq x) xs)\"\n  (is ?Set_Monad)\n  \"can_select Q (DList_set dxs) =\n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''can_select DList_set: ceq = None'') (\\<lambda>_. can_select Q (DList_set dxs))\n                  | Some _ \\<Rightarrow> DList_Set.length (DList_Set.filter Q dxs) = 1)\"\n  (is ?dlist)\n  \"can_select R (RBT_set rbt) =\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''can_select RBT_set: ccompare = None'') (\\<lambda>_. can_select R (RBT_set rbt))\n                 | Some _ \\<Rightarrow> singleton_list_fusion (filter_generator R rbt_keys_generator) (RBT_Set2.init rbt))\"\n  (is ?rbt)", "lemma pred_of_set_code [code]:\n  fixes dxs :: \"'a :: ceq set_dlist\" \n  and rbt :: \"'b :: ccompare set_rbt\" shows\n  \"pred_of_set (Set_Monad xs) = fold (sup \\<circ> Predicate.single) xs bot\"\n  \"pred_of_set (DList_set dxs) =\n   (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''pred_of_set DList_set: ceq = None'') (\\<lambda>_. pred_of_set (DList_set dxs))\n                   | Some _ \\<Rightarrow> DList_Set.fold (sup \\<circ> Predicate.single) dxs bot)\"\n  \"pred_of_set (RBT_set rbt) =\n   (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''pred_of_set RBT_set: ccompare = None'') (\\<lambda>_. pred_of_set (RBT_set rbt))\n                      | Some _ \\<Rightarrow> RBT_Set2.fold (sup \\<circ> Predicate.single) rbt bot)\"", "lemma insert_monad_code [code]:\n  \"insert_monad x (Set_Monad xs) = Set_Monad (x # xs)\"", "lemma union_monad_code [code]:\n  \"union_monad (Set_Monad xs) (Set_Monad ys) = Set_Monad (xs @ ys)\"", "lemma set_of_pred_code [code]:\n  \"set_of_pred (Predicate.Seq f) = \n  (case f () of seq.Empty \\<Rightarrow> Set_Monad []\n   | seq.Insert x P \\<Rightarrow> insert_monad x (set_of_pred P)\n   | seq.Join P xq \\<Rightarrow> union_monad (set_of_pred P) (set_of_seq xq))\"", "lemma set_of_seq_code [code]:\n  \"set_of_seq seq.Empty = Set_Monad []\"\n  \"set_of_seq (seq.Insert x P) = insert_monad x (set_of_pred P)\"\n  \"set_of_seq (seq.Join P xq) = union_monad (set_of_pred P) (set_of_seq xq)\"", "lemma [code]: \n  fixes x :: set_impl\n  shows \"size x = 0\"\n  and \"size_set_impl x = 0\"", "lemma set_empty_choose_code [code]:\n  \"(set_empty_choose :: 'a :: {ceq, ccompare} set) =\n   (case CCOMPARE('a) of Some _  \\<Rightarrow> RBT_set RBT_Set2.empty\n    | None \\<Rightarrow> case CEQ('a) of None \\<Rightarrow> Set_Monad [] | Some _ \\<Rightarrow> DList_set (DList_Set.empty))\"", "lemma set_impl_choose2_code [code]:\n  \"set_impl_choose2 x y = set_Choose\"\n  \"set_impl_choose2 set_Collect set_Collect = set_Collect\"\n  \"set_impl_choose2 set_DList set_DList = set_DList\"\n  \"set_impl_choose2 set_RBT set_RBT = set_RBT\"\n  \"set_impl_choose2 set_Monad set_Monad = set_Monad\"", "lemma set_empty_code [code]:\n  \"set_empty set_Collect = Collect_set (\\<lambda>_. False)\"\n  \"set_empty set_DList = DList_set DList_Set.empty\"\n  \"set_empty set_RBT = RBT_set RBT_Set2.empty\"\n  \"set_empty set_Monad = Set_Monad []\"\n  \"set_empty set_Choose = set_empty_choose\"", "lemma empty_code [code, code_unfold]: \n  \"({} :: 'a :: set_impl set) = set_empty (of_phantom SET_IMPL('a))\"", "lemma set_aux_code [code]:\n  defines \"conv \\<equiv> foldl (\\<lambda>s (x :: 'a). insert x s)\"\n  shows\n  \"set_aux impl = conv (set_empty impl)\" (is \"?thesis1\")\n  \"set_aux set_Choose = \n   (case CCOMPARE('a :: {ccompare, ceq}) of Some _  \\<Rightarrow> conv (RBT_set RBT_Set2.empty)\n    | None \\<Rightarrow> case CEQ('a) of None \\<Rightarrow> Set_Monad\n              | Some _ \\<Rightarrow> conv (DList_set DList_Set.empty))\" (is \"?thesis2\")\n  \"set_aux set_Monad = Set_Monad\"", "lemma set_code [code]:\n  fixes xs :: \"'a :: set_impl list\"\n  shows \"set xs = set_aux (of_phantom (ID SET_IMPL('a))) xs\"", "lemma conj_code_post [code_post]: \n  assumes code_post\n  shows \"True & x \\<longleftrightarrow> x\" \"False & x \\<longleftrightarrow> False\"", "lemma RBT_set_collapse_RBT_set [code_post]:\n  fixes r :: \"'a :: ccompare set_rbt\"\n  assumes \"code_post \\<Longrightarrow> is_ccompare TYPE('a)\" and code_post_set\n  shows \"RBT_set r = collapse_RBT_set r {}\"", "lemma collapse_RBT_set_Branch [code_post]: \n  \"collapse_RBT_set (Mapping_RBT (Branch c l x v r)) M =\n   collapse_RBT_set (Mapping_RBT l) (insert x (collapse_RBT_set (Mapping_RBT r) M))\"", "lemma collapse_RBT_set_Empty [code_post]: \n  \"collapse_RBT_set (Mapping_RBT rbt.Empty) M = M\"", "lemma DList_set_collapse_DList_set [code_post]:\n  fixes dxs :: \"'a :: ceq set_dlist\"\n  assumes \"code_post \\<Longrightarrow> is_ceq TYPE('a)\" and code_post_set\n  shows \"DList_set dxs = collapse_DList_set dxs\"", "lemma collapse_DList_set_empty [code_post]: \"collapse_DList_set (Abs_dlist []) = {}\"", "lemma collapse_DList_set_Cons [code_post]: \n  \"collapse_DList_set (Abs_dlist (x # xs)) = insert x (collapse_DList_set (Abs_dlist xs))\"", "lemma Set_Monad_code_post [code_post]:\n  assumes code_post_set\n  shows \"Set_Monad [] = {}\"\n  and \"Set_Monad (x#xs) = insert x (Set_Monad xs)\""], "translations": [["", "lemma length_quicksort_accp:\n  \"quicksort_acc_quicksort_part_dom (Inl (ac, xs)) \\<Longrightarrow> length (quicksort_acc ac xs) = length ac + length xs\"\n  and length_quicksort_partp:\n  \"quicksort_acc_quicksort_part_dom (Inr (ac, x, lts, eqs, gts, zs)) \n  \\<Longrightarrow> length (quicksort_part ac x lts eqs gts zs) = length ac + 1 + length lts + length eqs + length gts + length zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (quicksort_acc_quicksort_part_dom (Inl (ac, xs)) \\<Longrightarrow>\n     length (quicksort_acc ac xs) = length ac + length xs) &&&\n    (quicksort_acc_quicksort_part_dom\n      (Inr (ac, x, lts, eqs, gts, zs)) \\<Longrightarrow>\n     length (quicksort_part ac x lts eqs gts zs) =\n     length ac + 1 + length lts + length eqs + length gts + length zs)", "apply(induct rule: quicksort_acc_quicksort_part.pinduct)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>ac.\n       quicksort_acc_quicksort_part_dom (Inl (ac, [])) \\<Longrightarrow>\n       length (quicksort_acc ac []) = length ac + length []\n 2. \\<And>ac x.\n       quicksort_acc_quicksort_part_dom (Inl (ac, [x])) \\<Longrightarrow>\n       length (quicksort_acc ac [x]) = length ac + length [x]\n 3. \\<And>ac x v va.\n       \\<lbrakk>quicksort_acc_quicksort_part_dom (Inl (ac, x # v # va));\n        length (quicksort_part ac x [] [] [] (v # va)) =\n        length ac + 1 + length [] + length [] + length [] +\n        length (v # va)\\<rbrakk>\n       \\<Longrightarrow> length (quicksort_acc ac (x # v # va)) =\n                         length ac + length (x # v # va)\n 4. \\<And>ac x lts eqs gts.\n       \\<lbrakk>quicksort_acc_quicksort_part_dom\n                 (Inr (ac, x, lts, eqs, gts, []));\n        length (quicksort_acc ac gts) = length ac + length gts;\n        length (quicksort_acc (eqs @ x # quicksort_acc ac gts) lts) =\n        length (eqs @ x # quicksort_acc ac gts) + length lts\\<rbrakk>\n       \\<Longrightarrow> length (quicksort_part ac x lts eqs gts []) =\n                         length ac + 1 + length lts + length eqs +\n                         length gts +\n                         length []\n 5. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>quicksort_acc_quicksort_part_dom\n                 (Inr (ac, x, lts, eqs, gts, z # zs));\n        x < z \\<Longrightarrow>\n        length (quicksort_part ac x lts eqs (z # gts) zs) =\n        length ac + 1 + length lts + length eqs + length (z # gts) +\n        length zs;\n        \\<lbrakk>\\<not> x < z; z < x\\<rbrakk>\n        \\<Longrightarrow> length\n                           (quicksort_part ac x (z # lts) eqs gts zs) =\n                          length ac + 1 + length (z # lts) + length eqs +\n                          length gts +\n                          length zs;\n        \\<lbrakk>\\<not> x < z; \\<not> z < x\\<rbrakk>\n        \\<Longrightarrow> length\n                           (quicksort_part ac x lts (z # eqs) gts zs) =\n                          length ac + 1 + length lts + length (z # eqs) +\n                          length gts +\n                          length zs\\<rbrakk>\n       \\<Longrightarrow> length (quicksort_part ac x lts eqs gts (z # zs)) =\n                         length ac + 1 + length lts + length eqs +\n                         length gts +\n                         length (z # zs)", "apply(simp_all add: quicksort_acc.psimps quicksort_part.psimps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. quicksort_acc_quicksort_part_dom x", "apply(relation \"measure (case_sum (\\<lambda>(_, xs). 2 * length xs ^ 2) (\\<lambda>(_, _, lts, eqs, gts, zs). 2 * (length lts + length eqs + length gts + length zs) ^ 2 + length zs + 1))\")"], ["proof (prove)\ngoal (7 subgoals):\n 1. wf (measure\n         (case_sum (\\<lambda>(uu_, xs). 2 * (length xs)\\<^sup>2)\n           (\\<lambda>(uu_, uu_, lts, eqs, gts, zs).\n               2 *\n               (length lts + length eqs + length gts + length zs)\\<^sup>2 +\n               length zs +\n               1)))\n 2. \\<And>ac x v va.\n       (Inr (ac, x, [], [], [], v # va), Inl (ac, x # v # va))\n       \\<in> measure\n              (case_sum (\\<lambda>(uu_, xs). 2 * (length xs)\\<^sup>2)\n                (\\<lambda>(uu_, uu_, lts, eqs, gts, zs).\n                    2 *\n                    (length lts + length eqs + length gts +\n                     length zs)\\<^sup>2 +\n                    length zs +\n                    1))\n 3. \\<And>ac x lts eqs gts.\n       (Inl (ac, gts), Inr (ac, x, lts, eqs, gts, []))\n       \\<in> measure\n              (case_sum (\\<lambda>(uu_, xs). 2 * (length xs)\\<^sup>2)\n                (\\<lambda>(uu_, uu_, lts, eqs, gts, zs).\n                    2 *\n                    (length lts + length eqs + length gts +\n                     length zs)\\<^sup>2 +\n                    length zs +\n                    1))\n 4. \\<And>ac x lts eqs gts.\n       quicksort_acc_quicksort_part_dom (Inl (ac, gts)) \\<Longrightarrow>\n       (Inl (eqs @ x # quicksort_acc ac gts, lts),\n        Inr (ac, x, lts, eqs, gts, []))\n       \\<in> measure\n              (case_sum (\\<lambda>(uu_, xs). 2 * (length xs)\\<^sup>2)\n                (\\<lambda>(uu_, uu_, lts, eqs, gts, zs).\n                    2 *\n                    (length lts + length eqs + length gts +\n                     length zs)\\<^sup>2 +\n                    length zs +\n                    1))\n 5. \\<And>ac x lts eqs gts z zs.\n       x < z \\<Longrightarrow>\n       (Inr (ac, x, lts, eqs, z # gts, zs),\n        Inr (ac, x, lts, eqs, gts, z # zs))\n       \\<in> measure\n              (case_sum (\\<lambda>(uu_, xs). 2 * (length xs)\\<^sup>2)\n                (\\<lambda>(uu_, uu_, lts, eqs, gts, zs).\n                    2 *\n                    (length lts + length eqs + length gts +\n                     length zs)\\<^sup>2 +\n                    length zs +\n                    1))\n 6. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<not> x < z; z < x\\<rbrakk>\n       \\<Longrightarrow> (Inr (ac, x, z # lts, eqs, gts, zs),\n                          Inr (ac, x, lts, eqs, gts, z # zs))\n                         \\<in> measure\n                                (case_sum\n                                  (\\<lambda>(uu_, xs).\n2 * (length xs)\\<^sup>2)\n                                  (\\<lambda>(uu_, uu_, lts, eqs, gts, zs).\n2 * (length lts + length eqs + length gts + length zs)\\<^sup>2 + length zs +\n1))\n 7. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<not> x < z; \\<not> z < x\\<rbrakk>\n       \\<Longrightarrow> (Inr (ac, x, lts, z # eqs, gts, zs),\n                          Inr (ac, x, lts, eqs, gts, z # zs))\n                         \\<in> measure\n                                (case_sum\n                                  (\\<lambda>(uu_, xs).\n2 * (length xs)\\<^sup>2)\n                                  (\\<lambda>(uu_, uu_, lts, eqs, gts, zs).\n2 * (length lts + length eqs + length gts + length zs)\\<^sup>2 + length zs +\n1))", "apply(simp_all add: power2_eq_square add_mult_distrib add_mult_distrib2 length_quicksort_accp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition quicksort :: \"'a list \\<Rightarrow> 'a list\"\nwhere \"quicksort = quicksort_acc []\""], ["", "lemma set_quicksort_acc [simp]: \"set (quicksort_acc ac xs) = set ac \\<union> set xs\"\n  and set_quicksort_part [simp]:\n  \"set (quicksort_part ac x lts eqs gts zs) =\n  set ac \\<union> {x} \\<union> set lts \\<union> set eqs \\<union> set gts \\<union> set zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (quicksort_acc ac xs) = set ac \\<union> set xs &&&\n    set (quicksort_part ac x lts eqs gts zs) =\n    set ac \\<union> {x} \\<union> set lts \\<union> set eqs \\<union>\n    set gts \\<union>\n    set zs", "by(induct ac xs and ac x lts eqs gts zs rule: quicksort_acc_quicksort_part.induct)(auto split: if_split_asm)"], ["", "lemma set_quicksort [simp]: \"set (quicksort xs) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (quicksort xs) = set xs", "by(simp add: quicksort_def)"], ["", "lemma distinct_quicksort_acc: \n  \"distinct (quicksort_acc ac xs) = distinct (ac @ xs)\"\n  and distinct_quicksort_part:\n  \"distinct (quicksort_part ac x lts eqs gts zs) = distinct (ac @ [x] @ lts @ eqs @ gts @ zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (quicksort_acc ac xs) = distinct (ac @ xs) &&&\n    distinct (quicksort_part ac x lts eqs gts zs) =\n    distinct (ac @ [x] @ lts @ eqs @ gts @ zs)", "by(induct ac xs and ac x lts eqs gts zs rule: quicksort_acc_quicksort_part.induct) auto"], ["", "lemma distinct_quicksort [simp]: \"distinct (quicksort xs) = distinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (quicksort xs) = distinct xs", "by(simp add: quicksort_def distinct_quicksort_acc)"], ["", "end"], ["", "lemmas [code] =\n  ord.quicksort_acc.simps quicksort_acc.simps\n  ord.quicksort_part.simps quicksort_part.simps\n  ord.quicksort_def quicksort_def"], ["", "context linorder begin"], ["", "lemma sorted_quicksort_acc:\n  \"\\<lbrakk> sorted ac; \\<forall>x \\<in> set xs. \\<forall>a \\<in> set ac. x < a \\<rbrakk>\n  \\<Longrightarrow> sorted (quicksort_acc ac xs)\"\n  and sorted_quicksort_part:\n  \"\\<lbrakk> sorted ac; \\<forall>y \\<in> set lts \\<union> {x} \\<union> set eqs \\<union> set gts \\<union> set zs. \\<forall>a \\<in> set ac. y < a;\n     \\<forall>y \\<in> set lts. y < x; \\<forall>y \\<in> set eqs. y = x; \\<forall>y \\<in> set gts. y > x \\<rbrakk>\n  \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>sorted ac;\n      \\<forall>x\\<in>set xs. \\<forall>a\\<in>set ac. x < a\\<rbrakk>\n     \\<Longrightarrow> sorted (quicksort_acc ac xs)) &&&\n    (\\<lbrakk>sorted ac;\n      \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                     set gts \\<union>\n                     set zs.\n         \\<forall>a\\<in>set ac. y < a;\n      \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n      \\<forall>y\\<in>set gts. x < y\\<rbrakk>\n     \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts zs))", "proof(induction ac xs and ac x lts eqs gts zs rule: quicksort_acc_quicksort_part.induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>ac.\n       \\<lbrakk>sorted ac;\n        \\<forall>x\\<in>set []. Ball (set ac) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_acc ac [])\n 2. \\<And>ac x.\n       \\<lbrakk>sorted ac;\n        \\<forall>x\\<in>set [x]. Ball (set ac) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_acc ac [x])\n 3. \\<And>ac x v va.\n       \\<lbrakk>\\<lbrakk>sorted ac;\n                 \\<forall>y\\<in>set [] \\<union> {x} \\<union> set [] \\<union>\n                                set [] \\<union>\n                                set (v # va).\n                    Ball (set ac) ((<) y);\n                 \\<forall>y\\<in>set []. y < x; \\<forall>y\\<in>set []. y = x;\n                 Ball (set []) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted\n                                   (quicksort_part ac x [] [] [] (v # va));\n        sorted ac;\n        \\<forall>x\\<in>set (x # v # va). Ball (set ac) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_acc ac (x # v # va))\n 4. \\<And>ac x lts eqs gts.\n       \\<lbrakk>\\<lbrakk>sorted ac;\n                 \\<forall>x\\<in>set gts. Ball (set ac) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted (quicksort_acc ac gts);\n        \\<lbrakk>sorted (eqs @ x # quicksort_acc ac gts);\n         \\<forall>xa\\<in>set lts.\n            Ball (set (eqs @ x # quicksort_acc ac gts)) ((<) xa)\\<rbrakk>\n        \\<Longrightarrow> sorted\n                           (quicksort_acc (eqs @ x # quicksort_acc ac gts)\n                             lts);\n        sorted ac;\n        \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                       set gts \\<union>\n                       set [].\n           Ball (set ac) ((<) y);\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts [])\n 5. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; sorted ac;\n                 \\<forall>y\\<in>set lts \\<union> {x} \\<union>\n                                set eqs \\<union>\n                                set (z # gts) \\<union>\n                                set zs.\n                    Ball (set ac) ((<) y);\n                 \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted\n                                   (quicksort_part ac x lts eqs (z # gts)\n                                     zs);\n        \\<lbrakk>\\<not> x < z; z < x; sorted ac;\n         \\<forall>y\\<in>set (z # lts) \\<union> {x} \\<union> set eqs \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set (z # lts). y < x; \\<forall>y\\<in>set eqs. y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x (z # lts) eqs gts zs);\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; sorted ac;\n         \\<forall>y\\<in>set lts \\<union> {x} \\<union> set (z # eqs) \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x lts (z # eqs) gts zs);\n        sorted ac;\n        \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                       set gts \\<union>\n                       set (z # zs).\n           Ball (set ac) ((<) y);\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts (z # zs))", "case 1"], ["proof (state)\nthis:\n  sorted ac_\n  \\<forall>x\\<in>set []. \\<forall>a\\<in>set ac_. x < a\n\ngoal (5 subgoals):\n 1. \\<And>ac.\n       \\<lbrakk>sorted ac;\n        \\<forall>x\\<in>set []. Ball (set ac) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_acc ac [])\n 2. \\<And>ac x.\n       \\<lbrakk>sorted ac;\n        \\<forall>x\\<in>set [x]. Ball (set ac) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_acc ac [x])\n 3. \\<And>ac x v va.\n       \\<lbrakk>\\<lbrakk>sorted ac;\n                 \\<forall>y\\<in>set [] \\<union> {x} \\<union> set [] \\<union>\n                                set [] \\<union>\n                                set (v # va).\n                    Ball (set ac) ((<) y);\n                 \\<forall>y\\<in>set []. y < x; \\<forall>y\\<in>set []. y = x;\n                 Ball (set []) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted\n                                   (quicksort_part ac x [] [] [] (v # va));\n        sorted ac;\n        \\<forall>x\\<in>set (x # v # va). Ball (set ac) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_acc ac (x # v # va))\n 4. \\<And>ac x lts eqs gts.\n       \\<lbrakk>\\<lbrakk>sorted ac;\n                 \\<forall>x\\<in>set gts. Ball (set ac) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted (quicksort_acc ac gts);\n        \\<lbrakk>sorted (eqs @ x # quicksort_acc ac gts);\n         \\<forall>xa\\<in>set lts.\n            Ball (set (eqs @ x # quicksort_acc ac gts)) ((<) xa)\\<rbrakk>\n        \\<Longrightarrow> sorted\n                           (quicksort_acc (eqs @ x # quicksort_acc ac gts)\n                             lts);\n        sorted ac;\n        \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                       set gts \\<union>\n                       set [].\n           Ball (set ac) ((<) y);\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts [])\n 5. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; sorted ac;\n                 \\<forall>y\\<in>set lts \\<union> {x} \\<union>\n                                set eqs \\<union>\n                                set (z # gts) \\<union>\n                                set zs.\n                    Ball (set ac) ((<) y);\n                 \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted\n                                   (quicksort_part ac x lts eqs (z # gts)\n                                     zs);\n        \\<lbrakk>\\<not> x < z; z < x; sorted ac;\n         \\<forall>y\\<in>set (z # lts) \\<union> {x} \\<union> set eqs \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set (z # lts). y < x; \\<forall>y\\<in>set eqs. y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x (z # lts) eqs gts zs);\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; sorted ac;\n         \\<forall>y\\<in>set lts \\<union> {x} \\<union> set (z # eqs) \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x lts (z # eqs) gts zs);\n        sorted ac;\n        \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                       set gts \\<union>\n                       set (z # zs).\n           Ball (set ac) ((<) y);\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts (z # zs))", "thus ?case"], ["proof (prove)\nusing this:\n  sorted ac_\n  \\<forall>x\\<in>set []. \\<forall>a\\<in>set ac_. x < a\n\ngoal (1 subgoal):\n 1. sorted (quicksort_acc ac_ [])", "by simp"], ["proof (state)\nthis:\n  sorted (quicksort_acc ac_ [])\n\ngoal (4 subgoals):\n 1. \\<And>ac x.\n       \\<lbrakk>sorted ac;\n        \\<forall>x\\<in>set [x]. Ball (set ac) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_acc ac [x])\n 2. \\<And>ac x v va.\n       \\<lbrakk>\\<lbrakk>sorted ac;\n                 \\<forall>y\\<in>set [] \\<union> {x} \\<union> set [] \\<union>\n                                set [] \\<union>\n                                set (v # va).\n                    Ball (set ac) ((<) y);\n                 \\<forall>y\\<in>set []. y < x; \\<forall>y\\<in>set []. y = x;\n                 Ball (set []) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted\n                                   (quicksort_part ac x [] [] [] (v # va));\n        sorted ac;\n        \\<forall>x\\<in>set (x # v # va). Ball (set ac) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_acc ac (x # v # va))\n 3. \\<And>ac x lts eqs gts.\n       \\<lbrakk>\\<lbrakk>sorted ac;\n                 \\<forall>x\\<in>set gts. Ball (set ac) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted (quicksort_acc ac gts);\n        \\<lbrakk>sorted (eqs @ x # quicksort_acc ac gts);\n         \\<forall>xa\\<in>set lts.\n            Ball (set (eqs @ x # quicksort_acc ac gts)) ((<) xa)\\<rbrakk>\n        \\<Longrightarrow> sorted\n                           (quicksort_acc (eqs @ x # quicksort_acc ac gts)\n                             lts);\n        sorted ac;\n        \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                       set gts \\<union>\n                       set [].\n           Ball (set ac) ((<) y);\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts [])\n 4. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; sorted ac;\n                 \\<forall>y\\<in>set lts \\<union> {x} \\<union>\n                                set eqs \\<union>\n                                set (z # gts) \\<union>\n                                set zs.\n                    Ball (set ac) ((<) y);\n                 \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted\n                                   (quicksort_part ac x lts eqs (z # gts)\n                                     zs);\n        \\<lbrakk>\\<not> x < z; z < x; sorted ac;\n         \\<forall>y\\<in>set (z # lts) \\<union> {x} \\<union> set eqs \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set (z # lts). y < x; \\<forall>y\\<in>set eqs. y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x (z # lts) eqs gts zs);\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; sorted ac;\n         \\<forall>y\\<in>set lts \\<union> {x} \\<union> set (z # eqs) \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x lts (z # eqs) gts zs);\n        sorted ac;\n        \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                       set gts \\<union>\n                       set (z # zs).\n           Ball (set ac) ((<) y);\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts (z # zs))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>ac x.\n       \\<lbrakk>sorted ac;\n        \\<forall>x\\<in>set [x]. Ball (set ac) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_acc ac [x])\n 2. \\<And>ac x v va.\n       \\<lbrakk>\\<lbrakk>sorted ac;\n                 \\<forall>y\\<in>set [] \\<union> {x} \\<union> set [] \\<union>\n                                set [] \\<union>\n                                set (v # va).\n                    Ball (set ac) ((<) y);\n                 \\<forall>y\\<in>set []. y < x; \\<forall>y\\<in>set []. y = x;\n                 Ball (set []) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted\n                                   (quicksort_part ac x [] [] [] (v # va));\n        sorted ac;\n        \\<forall>x\\<in>set (x # v # va). Ball (set ac) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_acc ac (x # v # va))\n 3. \\<And>ac x lts eqs gts.\n       \\<lbrakk>\\<lbrakk>sorted ac;\n                 \\<forall>x\\<in>set gts. Ball (set ac) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted (quicksort_acc ac gts);\n        \\<lbrakk>sorted (eqs @ x # quicksort_acc ac gts);\n         \\<forall>xa\\<in>set lts.\n            Ball (set (eqs @ x # quicksort_acc ac gts)) ((<) xa)\\<rbrakk>\n        \\<Longrightarrow> sorted\n                           (quicksort_acc (eqs @ x # quicksort_acc ac gts)\n                             lts);\n        sorted ac;\n        \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                       set gts \\<union>\n                       set [].\n           Ball (set ac) ((<) y);\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts [])\n 4. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; sorted ac;\n                 \\<forall>y\\<in>set lts \\<union> {x} \\<union>\n                                set eqs \\<union>\n                                set (z # gts) \\<union>\n                                set zs.\n                    Ball (set ac) ((<) y);\n                 \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted\n                                   (quicksort_part ac x lts eqs (z # gts)\n                                     zs);\n        \\<lbrakk>\\<not> x < z; z < x; sorted ac;\n         \\<forall>y\\<in>set (z # lts) \\<union> {x} \\<union> set eqs \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set (z # lts). y < x; \\<forall>y\\<in>set eqs. y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x (z # lts) eqs gts zs);\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; sorted ac;\n         \\<forall>y\\<in>set lts \\<union> {x} \\<union> set (z # eqs) \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x lts (z # eqs) gts zs);\n        sorted ac;\n        \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                       set gts \\<union>\n                       set (z # zs).\n           Ball (set ac) ((<) y);\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts (z # zs))", "case 2"], ["proof (state)\nthis:\n  sorted ac_\n  \\<forall>x\\<in>set [x_]. \\<forall>a\\<in>set ac_. x < a\n\ngoal (4 subgoals):\n 1. \\<And>ac x.\n       \\<lbrakk>sorted ac;\n        \\<forall>x\\<in>set [x]. Ball (set ac) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_acc ac [x])\n 2. \\<And>ac x v va.\n       \\<lbrakk>\\<lbrakk>sorted ac;\n                 \\<forall>y\\<in>set [] \\<union> {x} \\<union> set [] \\<union>\n                                set [] \\<union>\n                                set (v # va).\n                    Ball (set ac) ((<) y);\n                 \\<forall>y\\<in>set []. y < x; \\<forall>y\\<in>set []. y = x;\n                 Ball (set []) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted\n                                   (quicksort_part ac x [] [] [] (v # va));\n        sorted ac;\n        \\<forall>x\\<in>set (x # v # va). Ball (set ac) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_acc ac (x # v # va))\n 3. \\<And>ac x lts eqs gts.\n       \\<lbrakk>\\<lbrakk>sorted ac;\n                 \\<forall>x\\<in>set gts. Ball (set ac) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted (quicksort_acc ac gts);\n        \\<lbrakk>sorted (eqs @ x # quicksort_acc ac gts);\n         \\<forall>xa\\<in>set lts.\n            Ball (set (eqs @ x # quicksort_acc ac gts)) ((<) xa)\\<rbrakk>\n        \\<Longrightarrow> sorted\n                           (quicksort_acc (eqs @ x # quicksort_acc ac gts)\n                             lts);\n        sorted ac;\n        \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                       set gts \\<union>\n                       set [].\n           Ball (set ac) ((<) y);\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts [])\n 4. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; sorted ac;\n                 \\<forall>y\\<in>set lts \\<union> {x} \\<union>\n                                set eqs \\<union>\n                                set (z # gts) \\<union>\n                                set zs.\n                    Ball (set ac) ((<) y);\n                 \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted\n                                   (quicksort_part ac x lts eqs (z # gts)\n                                     zs);\n        \\<lbrakk>\\<not> x < z; z < x; sorted ac;\n         \\<forall>y\\<in>set (z # lts) \\<union> {x} \\<union> set eqs \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set (z # lts). y < x; \\<forall>y\\<in>set eqs. y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x (z # lts) eqs gts zs);\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; sorted ac;\n         \\<forall>y\\<in>set lts \\<union> {x} \\<union> set (z # eqs) \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x lts (z # eqs) gts zs);\n        sorted ac;\n        \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                       set gts \\<union>\n                       set (z # zs).\n           Ball (set ac) ((<) y);\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts (z # zs))", "thus ?case"], ["proof (prove)\nusing this:\n  sorted ac_\n  \\<forall>x\\<in>set [x_]. \\<forall>a\\<in>set ac_. x < a\n\ngoal (1 subgoal):\n 1. sorted (quicksort_acc ac_ [x_])", "by(auto)"], ["proof (state)\nthis:\n  sorted (quicksort_acc ac_ [x_])\n\ngoal (3 subgoals):\n 1. \\<And>ac x v va.\n       \\<lbrakk>\\<lbrakk>sorted ac;\n                 \\<forall>y\\<in>set [] \\<union> {x} \\<union> set [] \\<union>\n                                set [] \\<union>\n                                set (v # va).\n                    Ball (set ac) ((<) y);\n                 \\<forall>y\\<in>set []. y < x; \\<forall>y\\<in>set []. y = x;\n                 Ball (set []) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted\n                                   (quicksort_part ac x [] [] [] (v # va));\n        sorted ac;\n        \\<forall>x\\<in>set (x # v # va). Ball (set ac) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_acc ac (x # v # va))\n 2. \\<And>ac x lts eqs gts.\n       \\<lbrakk>\\<lbrakk>sorted ac;\n                 \\<forall>x\\<in>set gts. Ball (set ac) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted (quicksort_acc ac gts);\n        \\<lbrakk>sorted (eqs @ x # quicksort_acc ac gts);\n         \\<forall>xa\\<in>set lts.\n            Ball (set (eqs @ x # quicksort_acc ac gts)) ((<) xa)\\<rbrakk>\n        \\<Longrightarrow> sorted\n                           (quicksort_acc (eqs @ x # quicksort_acc ac gts)\n                             lts);\n        sorted ac;\n        \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                       set gts \\<union>\n                       set [].\n           Ball (set ac) ((<) y);\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts [])\n 3. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; sorted ac;\n                 \\<forall>y\\<in>set lts \\<union> {x} \\<union>\n                                set eqs \\<union>\n                                set (z # gts) \\<union>\n                                set zs.\n                    Ball (set ac) ((<) y);\n                 \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted\n                                   (quicksort_part ac x lts eqs (z # gts)\n                                     zs);\n        \\<lbrakk>\\<not> x < z; z < x; sorted ac;\n         \\<forall>y\\<in>set (z # lts) \\<union> {x} \\<union> set eqs \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set (z # lts). y < x; \\<forall>y\\<in>set eqs. y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x (z # lts) eqs gts zs);\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; sorted ac;\n         \\<forall>y\\<in>set lts \\<union> {x} \\<union> set (z # eqs) \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x lts (z # eqs) gts zs);\n        sorted ac;\n        \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                       set gts \\<union>\n                       set (z # zs).\n           Ball (set ac) ((<) y);\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts (z # zs))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ac x v va.\n       \\<lbrakk>\\<lbrakk>sorted ac;\n                 \\<forall>y\\<in>set [] \\<union> {x} \\<union> set [] \\<union>\n                                set [] \\<union>\n                                set (v # va).\n                    Ball (set ac) ((<) y);\n                 \\<forall>y\\<in>set []. y < x; \\<forall>y\\<in>set []. y = x;\n                 Ball (set []) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted\n                                   (quicksort_part ac x [] [] [] (v # va));\n        sorted ac;\n        \\<forall>x\\<in>set (x # v # va). Ball (set ac) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_acc ac (x # v # va))\n 2. \\<And>ac x lts eqs gts.\n       \\<lbrakk>\\<lbrakk>sorted ac;\n                 \\<forall>x\\<in>set gts. Ball (set ac) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted (quicksort_acc ac gts);\n        \\<lbrakk>sorted (eqs @ x # quicksort_acc ac gts);\n         \\<forall>xa\\<in>set lts.\n            Ball (set (eqs @ x # quicksort_acc ac gts)) ((<) xa)\\<rbrakk>\n        \\<Longrightarrow> sorted\n                           (quicksort_acc (eqs @ x # quicksort_acc ac gts)\n                             lts);\n        sorted ac;\n        \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                       set gts \\<union>\n                       set [].\n           Ball (set ac) ((<) y);\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts [])\n 3. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; sorted ac;\n                 \\<forall>y\\<in>set lts \\<union> {x} \\<union>\n                                set eqs \\<union>\n                                set (z # gts) \\<union>\n                                set zs.\n                    Ball (set ac) ((<) y);\n                 \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted\n                                   (quicksort_part ac x lts eqs (z # gts)\n                                     zs);\n        \\<lbrakk>\\<not> x < z; z < x; sorted ac;\n         \\<forall>y\\<in>set (z # lts) \\<union> {x} \\<union> set eqs \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set (z # lts). y < x; \\<forall>y\\<in>set eqs. y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x (z # lts) eqs gts zs);\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; sorted ac;\n         \\<forall>y\\<in>set lts \\<union> {x} \\<union> set (z # eqs) \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x lts (z # eqs) gts zs);\n        sorted ac;\n        \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                       set gts \\<union>\n                       set (z # zs).\n           Ball (set ac) ((<) y);\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts (z # zs))", "case 3"], ["proof (state)\nthis:\n  \\<lbrakk>sorted ac_;\n   \\<forall>y\\<in>set [] \\<union> {x_} \\<union> set [] \\<union>\n                  set [] \\<union>\n                  set (v_ # va_).\n      \\<forall>a\\<in>set ac_. y < a;\n   \\<forall>y\\<in>set []. y < x_; \\<forall>y\\<in>set []. y = x_;\n   \\<forall>a\\<in>set []. x_ < a\\<rbrakk>\n  \\<Longrightarrow> sorted (quicksort_part ac_ x_ [] [] [] (v_ # va_))\n  sorted ac_\n  \\<forall>x\\<in>set (x_ # v_ # va_). \\<forall>a\\<in>set ac_. x < a\n\ngoal (3 subgoals):\n 1. \\<And>ac x v va.\n       \\<lbrakk>\\<lbrakk>sorted ac;\n                 \\<forall>y\\<in>set [] \\<union> {x} \\<union> set [] \\<union>\n                                set [] \\<union>\n                                set (v # va).\n                    Ball (set ac) ((<) y);\n                 \\<forall>y\\<in>set []. y < x; \\<forall>y\\<in>set []. y = x;\n                 Ball (set []) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted\n                                   (quicksort_part ac x [] [] [] (v # va));\n        sorted ac;\n        \\<forall>x\\<in>set (x # v # va). Ball (set ac) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_acc ac (x # v # va))\n 2. \\<And>ac x lts eqs gts.\n       \\<lbrakk>\\<lbrakk>sorted ac;\n                 \\<forall>x\\<in>set gts. Ball (set ac) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted (quicksort_acc ac gts);\n        \\<lbrakk>sorted (eqs @ x # quicksort_acc ac gts);\n         \\<forall>xa\\<in>set lts.\n            Ball (set (eqs @ x # quicksort_acc ac gts)) ((<) xa)\\<rbrakk>\n        \\<Longrightarrow> sorted\n                           (quicksort_acc (eqs @ x # quicksort_acc ac gts)\n                             lts);\n        sorted ac;\n        \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                       set gts \\<union>\n                       set [].\n           Ball (set ac) ((<) y);\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts [])\n 3. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; sorted ac;\n                 \\<forall>y\\<in>set lts \\<union> {x} \\<union>\n                                set eqs \\<union>\n                                set (z # gts) \\<union>\n                                set zs.\n                    Ball (set ac) ((<) y);\n                 \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted\n                                   (quicksort_part ac x lts eqs (z # gts)\n                                     zs);\n        \\<lbrakk>\\<not> x < z; z < x; sorted ac;\n         \\<forall>y\\<in>set (z # lts) \\<union> {x} \\<union> set eqs \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set (z # lts). y < x; \\<forall>y\\<in>set eqs. y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x (z # lts) eqs gts zs);\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; sorted ac;\n         \\<forall>y\\<in>set lts \\<union> {x} \\<union> set (z # eqs) \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x lts (z # eqs) gts zs);\n        sorted ac;\n        \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                       set gts \\<union>\n                       set (z # zs).\n           Ball (set ac) ((<) y);\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts (z # zs))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>sorted ac_;\n   \\<forall>y\\<in>set [] \\<union> {x_} \\<union> set [] \\<union>\n                  set [] \\<union>\n                  set (v_ # va_).\n      \\<forall>a\\<in>set ac_. y < a;\n   \\<forall>y\\<in>set []. y < x_; \\<forall>y\\<in>set []. y = x_;\n   \\<forall>a\\<in>set []. x_ < a\\<rbrakk>\n  \\<Longrightarrow> sorted (quicksort_part ac_ x_ [] [] [] (v_ # va_))\n  sorted ac_\n  \\<forall>x\\<in>set (x_ # v_ # va_). \\<forall>a\\<in>set ac_. x < a\n\ngoal (1 subgoal):\n 1. sorted (quicksort_acc ac_ (x_ # v_ # va_))", "by simp"], ["proof (state)\nthis:\n  sorted (quicksort_acc ac_ (x_ # v_ # va_))\n\ngoal (2 subgoals):\n 1. \\<And>ac x lts eqs gts.\n       \\<lbrakk>\\<lbrakk>sorted ac;\n                 \\<forall>x\\<in>set gts. Ball (set ac) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted (quicksort_acc ac gts);\n        \\<lbrakk>sorted (eqs @ x # quicksort_acc ac gts);\n         \\<forall>xa\\<in>set lts.\n            Ball (set (eqs @ x # quicksort_acc ac gts)) ((<) xa)\\<rbrakk>\n        \\<Longrightarrow> sorted\n                           (quicksort_acc (eqs @ x # quicksort_acc ac gts)\n                             lts);\n        sorted ac;\n        \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                       set gts \\<union>\n                       set [].\n           Ball (set ac) ((<) y);\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts [])\n 2. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; sorted ac;\n                 \\<forall>y\\<in>set lts \\<union> {x} \\<union>\n                                set eqs \\<union>\n                                set (z # gts) \\<union>\n                                set zs.\n                    Ball (set ac) ((<) y);\n                 \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted\n                                   (quicksort_part ac x lts eqs (z # gts)\n                                     zs);\n        \\<lbrakk>\\<not> x < z; z < x; sorted ac;\n         \\<forall>y\\<in>set (z # lts) \\<union> {x} \\<union> set eqs \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set (z # lts). y < x; \\<forall>y\\<in>set eqs. y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x (z # lts) eqs gts zs);\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; sorted ac;\n         \\<forall>y\\<in>set lts \\<union> {x} \\<union> set (z # eqs) \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x lts (z # eqs) gts zs);\n        sorted ac;\n        \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                       set gts \\<union>\n                       set (z # zs).\n           Ball (set ac) ((<) y);\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts (z # zs))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ac x lts eqs gts.\n       \\<lbrakk>\\<lbrakk>sorted ac;\n                 \\<forall>x\\<in>set gts. Ball (set ac) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted (quicksort_acc ac gts);\n        \\<lbrakk>sorted (eqs @ x # quicksort_acc ac gts);\n         \\<forall>xa\\<in>set lts.\n            Ball (set (eqs @ x # quicksort_acc ac gts)) ((<) xa)\\<rbrakk>\n        \\<Longrightarrow> sorted\n                           (quicksort_acc (eqs @ x # quicksort_acc ac gts)\n                             lts);\n        sorted ac;\n        \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                       set gts \\<union>\n                       set [].\n           Ball (set ac) ((<) y);\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts [])\n 2. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; sorted ac;\n                 \\<forall>y\\<in>set lts \\<union> {x} \\<union>\n                                set eqs \\<union>\n                                set (z # gts) \\<union>\n                                set zs.\n                    Ball (set ac) ((<) y);\n                 \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted\n                                   (quicksort_part ac x lts eqs (z # gts)\n                                     zs);\n        \\<lbrakk>\\<not> x < z; z < x; sorted ac;\n         \\<forall>y\\<in>set (z # lts) \\<union> {x} \\<union> set eqs \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set (z # lts). y < x; \\<forall>y\\<in>set eqs. y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x (z # lts) eqs gts zs);\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; sorted ac;\n         \\<forall>y\\<in>set lts \\<union> {x} \\<union> set (z # eqs) \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x lts (z # eqs) gts zs);\n        sorted ac;\n        \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                       set gts \\<union>\n                       set (z # zs).\n           Ball (set ac) ((<) y);\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts (z # zs))", "case (4 ac x lts eqs gts)"], ["proof (state)\nthis:\n  \\<lbrakk>sorted ac;\n   \\<forall>x\\<in>set gts. \\<forall>a\\<in>set ac. x < a\\<rbrakk>\n  \\<Longrightarrow> sorted (quicksort_acc ac gts)\n  \\<lbrakk>sorted (eqs @ x # quicksort_acc ac gts);\n   \\<forall>x\\<in>set lts.\n      \\<forall>a\\<in>set (eqs @ x # quicksort_acc ac gts). x < a\\<rbrakk>\n  \\<Longrightarrow> sorted\n                     (quicksort_acc (eqs @ x # quicksort_acc ac gts) lts)\n  sorted ac\n  \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                 set gts \\<union>\n                 set [].\n     \\<forall>a\\<in>set ac. y < a\n  \\<forall>y\\<in>set lts. y < x\n  \\<forall>y\\<in>set eqs. y = x\n  \\<forall>a\\<in>set gts. x < a\n\ngoal (2 subgoals):\n 1. \\<And>ac x lts eqs gts.\n       \\<lbrakk>\\<lbrakk>sorted ac;\n                 \\<forall>x\\<in>set gts. Ball (set ac) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted (quicksort_acc ac gts);\n        \\<lbrakk>sorted (eqs @ x # quicksort_acc ac gts);\n         \\<forall>xa\\<in>set lts.\n            Ball (set (eqs @ x # quicksort_acc ac gts)) ((<) xa)\\<rbrakk>\n        \\<Longrightarrow> sorted\n                           (quicksort_acc (eqs @ x # quicksort_acc ac gts)\n                             lts);\n        sorted ac;\n        \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                       set gts \\<union>\n                       set [].\n           Ball (set ac) ((<) y);\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts [])\n 2. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; sorted ac;\n                 \\<forall>y\\<in>set lts \\<union> {x} \\<union>\n                                set eqs \\<union>\n                                set (z # gts) \\<union>\n                                set zs.\n                    Ball (set ac) ((<) y);\n                 \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted\n                                   (quicksort_part ac x lts eqs (z # gts)\n                                     zs);\n        \\<lbrakk>\\<not> x < z; z < x; sorted ac;\n         \\<forall>y\\<in>set (z # lts) \\<union> {x} \\<union> set eqs \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set (z # lts). y < x; \\<forall>y\\<in>set eqs. y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x (z # lts) eqs gts zs);\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; sorted ac;\n         \\<forall>y\\<in>set lts \\<union> {x} \\<union> set (z # eqs) \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x lts (z # eqs) gts zs);\n        sorted ac;\n        \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                       set gts \\<union>\n                       set (z # zs).\n           Ball (set ac) ((<) y);\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts (z # zs))", "note ac_greater = \\<open>\\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union> set gts \\<union> set []. \\<forall>a\\<in>set ac. y < a\\<close>"], ["proof (state)\nthis:\n  \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                 set gts \\<union>\n                 set [].\n     \\<forall>a\\<in>set ac. y < a\n\ngoal (2 subgoals):\n 1. \\<And>ac x lts eqs gts.\n       \\<lbrakk>\\<lbrakk>sorted ac;\n                 \\<forall>x\\<in>set gts. Ball (set ac) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted (quicksort_acc ac gts);\n        \\<lbrakk>sorted (eqs @ x # quicksort_acc ac gts);\n         \\<forall>xa\\<in>set lts.\n            Ball (set (eqs @ x # quicksort_acc ac gts)) ((<) xa)\\<rbrakk>\n        \\<Longrightarrow> sorted\n                           (quicksort_acc (eqs @ x # quicksort_acc ac gts)\n                             lts);\n        sorted ac;\n        \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                       set gts \\<union>\n                       set [].\n           Ball (set ac) ((<) y);\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts [])\n 2. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; sorted ac;\n                 \\<forall>y\\<in>set lts \\<union> {x} \\<union>\n                                set eqs \\<union>\n                                set (z # gts) \\<union>\n                                set zs.\n                    Ball (set ac) ((<) y);\n                 \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted\n                                   (quicksort_part ac x lts eqs (z # gts)\n                                     zs);\n        \\<lbrakk>\\<not> x < z; z < x; sorted ac;\n         \\<forall>y\\<in>set (z # lts) \\<union> {x} \\<union> set eqs \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set (z # lts). y < x; \\<forall>y\\<in>set eqs. y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x (z # lts) eqs gts zs);\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; sorted ac;\n         \\<forall>y\\<in>set lts \\<union> {x} \\<union> set (z # eqs) \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x lts (z # eqs) gts zs);\n        sorted ac;\n        \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                       set gts \\<union>\n                       set (z # zs).\n           Ball (set ac) ((<) y);\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts (z # zs))", "have \"sorted eqs\" \"set eqs \\<subseteq> {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted eqs &&& set eqs \\<subseteq> {x}", "using \\<open>\\<forall>y\\<in>set eqs. y = x\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>set eqs. y = x\n\ngoal (1 subgoal):\n 1. sorted eqs &&& set eqs \\<subseteq> {x}", "by(induct eqs)(simp_all)"], ["proof (state)\nthis:\n  sorted eqs\n  set eqs \\<subseteq> {x}\n\ngoal (2 subgoals):\n 1. \\<And>ac x lts eqs gts.\n       \\<lbrakk>\\<lbrakk>sorted ac;\n                 \\<forall>x\\<in>set gts. Ball (set ac) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted (quicksort_acc ac gts);\n        \\<lbrakk>sorted (eqs @ x # quicksort_acc ac gts);\n         \\<forall>xa\\<in>set lts.\n            Ball (set (eqs @ x # quicksort_acc ac gts)) ((<) xa)\\<rbrakk>\n        \\<Longrightarrow> sorted\n                           (quicksort_acc (eqs @ x # quicksort_acc ac gts)\n                             lts);\n        sorted ac;\n        \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                       set gts \\<union>\n                       set [].\n           Ball (set ac) ((<) y);\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts [])\n 2. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; sorted ac;\n                 \\<forall>y\\<in>set lts \\<union> {x} \\<union>\n                                set eqs \\<union>\n                                set (z # gts) \\<union>\n                                set zs.\n                    Ball (set ac) ((<) y);\n                 \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted\n                                   (quicksort_part ac x lts eqs (z # gts)\n                                     zs);\n        \\<lbrakk>\\<not> x < z; z < x; sorted ac;\n         \\<forall>y\\<in>set (z # lts) \\<union> {x} \\<union> set eqs \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set (z # lts). y < x; \\<forall>y\\<in>set eqs. y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x (z # lts) eqs gts zs);\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; sorted ac;\n         \\<forall>y\\<in>set lts \\<union> {x} \\<union> set (z # eqs) \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x lts (z # eqs) gts zs);\n        sorted ac;\n        \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                       set gts \\<union>\n                       set (z # zs).\n           Ball (set ac) ((<) y);\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts (z # zs))", "moreover"], ["proof (state)\nthis:\n  sorted eqs\n  set eqs \\<subseteq> {x}\n\ngoal (2 subgoals):\n 1. \\<And>ac x lts eqs gts.\n       \\<lbrakk>\\<lbrakk>sorted ac;\n                 \\<forall>x\\<in>set gts. Ball (set ac) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted (quicksort_acc ac gts);\n        \\<lbrakk>sorted (eqs @ x # quicksort_acc ac gts);\n         \\<forall>xa\\<in>set lts.\n            Ball (set (eqs @ x # quicksort_acc ac gts)) ((<) xa)\\<rbrakk>\n        \\<Longrightarrow> sorted\n                           (quicksort_acc (eqs @ x # quicksort_acc ac gts)\n                             lts);\n        sorted ac;\n        \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                       set gts \\<union>\n                       set [].\n           Ball (set ac) ((<) y);\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts [])\n 2. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; sorted ac;\n                 \\<forall>y\\<in>set lts \\<union> {x} \\<union>\n                                set eqs \\<union>\n                                set (z # gts) \\<union>\n                                set zs.\n                    Ball (set ac) ((<) y);\n                 \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted\n                                   (quicksort_part ac x lts eqs (z # gts)\n                                     zs);\n        \\<lbrakk>\\<not> x < z; z < x; sorted ac;\n         \\<forall>y\\<in>set (z # lts) \\<union> {x} \\<union> set eqs \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set (z # lts). y < x; \\<forall>y\\<in>set eqs. y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x (z # lts) eqs gts zs);\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; sorted ac;\n         \\<forall>y\\<in>set lts \\<union> {x} \\<union> set (z # eqs) \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x lts (z # eqs) gts zs);\n        sorted ac;\n        \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                       set gts \\<union>\n                       set (z # zs).\n           Ball (set ac) ((<) y);\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts (z # zs))", "have \"\\<forall>y \\<in> set ac \\<union> set gts. x \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set ac \\<union> set gts. x \\<le> y", "using \\<open>\\<forall>a\\<in>set gts. x < a\\<close> ac_greater"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set gts. x < a\n  \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                 set gts \\<union>\n                 set [].\n     \\<forall>a\\<in>set ac. y < a\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set ac \\<union> set gts. x \\<le> y", "by auto"], ["proof (state)\nthis:\n  \\<forall>y\\<in>set ac \\<union> set gts. x \\<le> y\n\ngoal (2 subgoals):\n 1. \\<And>ac x lts eqs gts.\n       \\<lbrakk>\\<lbrakk>sorted ac;\n                 \\<forall>x\\<in>set gts. Ball (set ac) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted (quicksort_acc ac gts);\n        \\<lbrakk>sorted (eqs @ x # quicksort_acc ac gts);\n         \\<forall>xa\\<in>set lts.\n            Ball (set (eqs @ x # quicksort_acc ac gts)) ((<) xa)\\<rbrakk>\n        \\<Longrightarrow> sorted\n                           (quicksort_acc (eqs @ x # quicksort_acc ac gts)\n                             lts);\n        sorted ac;\n        \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                       set gts \\<union>\n                       set [].\n           Ball (set ac) ((<) y);\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts [])\n 2. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; sorted ac;\n                 \\<forall>y\\<in>set lts \\<union> {x} \\<union>\n                                set eqs \\<union>\n                                set (z # gts) \\<union>\n                                set zs.\n                    Ball (set ac) ((<) y);\n                 \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted\n                                   (quicksort_part ac x lts eqs (z # gts)\n                                     zs);\n        \\<lbrakk>\\<not> x < z; z < x; sorted ac;\n         \\<forall>y\\<in>set (z # lts) \\<union> {x} \\<union> set eqs \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set (z # lts). y < x; \\<forall>y\\<in>set eqs. y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x (z # lts) eqs gts zs);\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; sorted ac;\n         \\<forall>y\\<in>set lts \\<union> {x} \\<union> set (z # eqs) \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x lts (z # eqs) gts zs);\n        sorted ac;\n        \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                       set gts \\<union>\n                       set (z # zs).\n           Ball (set ac) ((<) y);\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts (z # zs))", "moreover"], ["proof (state)\nthis:\n  \\<forall>y\\<in>set ac \\<union> set gts. x \\<le> y\n\ngoal (2 subgoals):\n 1. \\<And>ac x lts eqs gts.\n       \\<lbrakk>\\<lbrakk>sorted ac;\n                 \\<forall>x\\<in>set gts. Ball (set ac) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted (quicksort_acc ac gts);\n        \\<lbrakk>sorted (eqs @ x # quicksort_acc ac gts);\n         \\<forall>xa\\<in>set lts.\n            Ball (set (eqs @ x # quicksort_acc ac gts)) ((<) xa)\\<rbrakk>\n        \\<Longrightarrow> sorted\n                           (quicksort_acc (eqs @ x # quicksort_acc ac gts)\n                             lts);\n        sorted ac;\n        \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                       set gts \\<union>\n                       set [].\n           Ball (set ac) ((<) y);\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts [])\n 2. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; sorted ac;\n                 \\<forall>y\\<in>set lts \\<union> {x} \\<union>\n                                set eqs \\<union>\n                                set (z # gts) \\<union>\n                                set zs.\n                    Ball (set ac) ((<) y);\n                 \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted\n                                   (quicksort_part ac x lts eqs (z # gts)\n                                     zs);\n        \\<lbrakk>\\<not> x < z; z < x; sorted ac;\n         \\<forall>y\\<in>set (z # lts) \\<union> {x} \\<union> set eqs \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set (z # lts). y < x; \\<forall>y\\<in>set eqs. y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x (z # lts) eqs gts zs);\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; sorted ac;\n         \\<forall>y\\<in>set lts \\<union> {x} \\<union> set (z # eqs) \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x lts (z # eqs) gts zs);\n        sorted ac;\n        \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                       set gts \\<union>\n                       set (z # zs).\n           Ball (set ac) ((<) y);\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts (z # zs))", "have \"sorted (quicksort_acc ac gts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (quicksort_acc ac gts)", "using \\<open>sorted ac\\<close> ac_greater"], ["proof (prove)\nusing this:\n  sorted ac\n  \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                 set gts \\<union>\n                 set [].\n     \\<forall>a\\<in>set ac. y < a\n\ngoal (1 subgoal):\n 1. sorted (quicksort_acc ac gts)", "by(auto intro: \"4.IH\")"], ["proof (state)\nthis:\n  sorted (quicksort_acc ac gts)\n\ngoal (2 subgoals):\n 1. \\<And>ac x lts eqs gts.\n       \\<lbrakk>\\<lbrakk>sorted ac;\n                 \\<forall>x\\<in>set gts. Ball (set ac) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted (quicksort_acc ac gts);\n        \\<lbrakk>sorted (eqs @ x # quicksort_acc ac gts);\n         \\<forall>xa\\<in>set lts.\n            Ball (set (eqs @ x # quicksort_acc ac gts)) ((<) xa)\\<rbrakk>\n        \\<Longrightarrow> sorted\n                           (quicksort_acc (eqs @ x # quicksort_acc ac gts)\n                             lts);\n        sorted ac;\n        \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                       set gts \\<union>\n                       set [].\n           Ball (set ac) ((<) y);\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts [])\n 2. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; sorted ac;\n                 \\<forall>y\\<in>set lts \\<union> {x} \\<union>\n                                set eqs \\<union>\n                                set (z # gts) \\<union>\n                                set zs.\n                    Ball (set ac) ((<) y);\n                 \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted\n                                   (quicksort_part ac x lts eqs (z # gts)\n                                     zs);\n        \\<lbrakk>\\<not> x < z; z < x; sorted ac;\n         \\<forall>y\\<in>set (z # lts) \\<union> {x} \\<union> set eqs \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set (z # lts). y < x; \\<forall>y\\<in>set eqs. y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x (z # lts) eqs gts zs);\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; sorted ac;\n         \\<forall>y\\<in>set lts \\<union> {x} \\<union> set (z # eqs) \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x lts (z # eqs) gts zs);\n        sorted ac;\n        \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                       set gts \\<union>\n                       set (z # zs).\n           Ball (set ac) ((<) y);\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts (z # zs))", "ultimately"], ["proof (chain)\npicking this:\n  sorted eqs\n  set eqs \\<subseteq> {x}\n  \\<forall>y\\<in>set ac \\<union> set gts. x \\<le> y\n  sorted (quicksort_acc ac gts)", "have \"sorted (eqs @ x # quicksort_acc ac gts)\""], ["proof (prove)\nusing this:\n  sorted eqs\n  set eqs \\<subseteq> {x}\n  \\<forall>y\\<in>set ac \\<union> set gts. x \\<le> y\n  sorted (quicksort_acc ac gts)\n\ngoal (1 subgoal):\n 1. sorted (eqs @ x # quicksort_acc ac gts)", "by(auto simp add: sorted_append)"], ["proof (state)\nthis:\n  sorted (eqs @ x # quicksort_acc ac gts)\n\ngoal (2 subgoals):\n 1. \\<And>ac x lts eqs gts.\n       \\<lbrakk>\\<lbrakk>sorted ac;\n                 \\<forall>x\\<in>set gts. Ball (set ac) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted (quicksort_acc ac gts);\n        \\<lbrakk>sorted (eqs @ x # quicksort_acc ac gts);\n         \\<forall>xa\\<in>set lts.\n            Ball (set (eqs @ x # quicksort_acc ac gts)) ((<) xa)\\<rbrakk>\n        \\<Longrightarrow> sorted\n                           (quicksort_acc (eqs @ x # quicksort_acc ac gts)\n                             lts);\n        sorted ac;\n        \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                       set gts \\<union>\n                       set [].\n           Ball (set ac) ((<) y);\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts [])\n 2. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; sorted ac;\n                 \\<forall>y\\<in>set lts \\<union> {x} \\<union>\n                                set eqs \\<union>\n                                set (z # gts) \\<union>\n                                set zs.\n                    Ball (set ac) ((<) y);\n                 \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted\n                                   (quicksort_part ac x lts eqs (z # gts)\n                                     zs);\n        \\<lbrakk>\\<not> x < z; z < x; sorted ac;\n         \\<forall>y\\<in>set (z # lts) \\<union> {x} \\<union> set eqs \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set (z # lts). y < x; \\<forall>y\\<in>set eqs. y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x (z # lts) eqs gts zs);\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; sorted ac;\n         \\<forall>y\\<in>set lts \\<union> {x} \\<union> set (z # eqs) \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x lts (z # eqs) gts zs);\n        sorted ac;\n        \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                       set gts \\<union>\n                       set (z # zs).\n           Ball (set ac) ((<) y);\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts (z # zs))", "moreover"], ["proof (state)\nthis:\n  sorted (eqs @ x # quicksort_acc ac gts)\n\ngoal (2 subgoals):\n 1. \\<And>ac x lts eqs gts.\n       \\<lbrakk>\\<lbrakk>sorted ac;\n                 \\<forall>x\\<in>set gts. Ball (set ac) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted (quicksort_acc ac gts);\n        \\<lbrakk>sorted (eqs @ x # quicksort_acc ac gts);\n         \\<forall>xa\\<in>set lts.\n            Ball (set (eqs @ x # quicksort_acc ac gts)) ((<) xa)\\<rbrakk>\n        \\<Longrightarrow> sorted\n                           (quicksort_acc (eqs @ x # quicksort_acc ac gts)\n                             lts);\n        sorted ac;\n        \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                       set gts \\<union>\n                       set [].\n           Ball (set ac) ((<) y);\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts [])\n 2. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; sorted ac;\n                 \\<forall>y\\<in>set lts \\<union> {x} \\<union>\n                                set eqs \\<union>\n                                set (z # gts) \\<union>\n                                set zs.\n                    Ball (set ac) ((<) y);\n                 \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted\n                                   (quicksort_part ac x lts eqs (z # gts)\n                                     zs);\n        \\<lbrakk>\\<not> x < z; z < x; sorted ac;\n         \\<forall>y\\<in>set (z # lts) \\<union> {x} \\<union> set eqs \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set (z # lts). y < x; \\<forall>y\\<in>set eqs. y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x (z # lts) eqs gts zs);\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; sorted ac;\n         \\<forall>y\\<in>set lts \\<union> {x} \\<union> set (z # eqs) \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x lts (z # eqs) gts zs);\n        sorted ac;\n        \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                       set gts \\<union>\n                       set (z # zs).\n           Ball (set ac) ((<) y);\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts (z # zs))", "have \"\\<forall>y\\<in>set lts. \\<forall>a\\<in>set (eqs @ x # quicksort_acc ac gts). y < a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set lts.\n       \\<forall>a\\<in>set (eqs @ x # quicksort_acc ac gts). y < a", "using \\<open>\\<forall>y\\<in>set lts. y < x\\<close> ac_greater \\<open>\\<forall>a\\<in>set gts. x < a\\<close> \\<open>\\<forall>y\\<in>set eqs. y = x\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>set lts. y < x\n  \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                 set gts \\<union>\n                 set [].\n     \\<forall>a\\<in>set ac. y < a\n  \\<forall>a\\<in>set gts. x < a\n  \\<forall>y\\<in>set eqs. y = x\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set lts.\n       \\<forall>a\\<in>set (eqs @ x # quicksort_acc ac gts). y < a", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>y\\<in>set lts.\n     \\<forall>a\\<in>set (eqs @ x # quicksort_acc ac gts). y < a\n\ngoal (2 subgoals):\n 1. \\<And>ac x lts eqs gts.\n       \\<lbrakk>\\<lbrakk>sorted ac;\n                 \\<forall>x\\<in>set gts. Ball (set ac) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted (quicksort_acc ac gts);\n        \\<lbrakk>sorted (eqs @ x # quicksort_acc ac gts);\n         \\<forall>xa\\<in>set lts.\n            Ball (set (eqs @ x # quicksort_acc ac gts)) ((<) xa)\\<rbrakk>\n        \\<Longrightarrow> sorted\n                           (quicksort_acc (eqs @ x # quicksort_acc ac gts)\n                             lts);\n        sorted ac;\n        \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                       set gts \\<union>\n                       set [].\n           Ball (set ac) ((<) y);\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts [])\n 2. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; sorted ac;\n                 \\<forall>y\\<in>set lts \\<union> {x} \\<union>\n                                set eqs \\<union>\n                                set (z # gts) \\<union>\n                                set zs.\n                    Ball (set ac) ((<) y);\n                 \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted\n                                   (quicksort_part ac x lts eqs (z # gts)\n                                     zs);\n        \\<lbrakk>\\<not> x < z; z < x; sorted ac;\n         \\<forall>y\\<in>set (z # lts) \\<union> {x} \\<union> set eqs \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set (z # lts). y < x; \\<forall>y\\<in>set eqs. y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x (z # lts) eqs gts zs);\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; sorted ac;\n         \\<forall>y\\<in>set lts \\<union> {x} \\<union> set (z # eqs) \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x lts (z # eqs) gts zs);\n        sorted ac;\n        \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                       set gts \\<union>\n                       set (z # zs).\n           Ball (set ac) ((<) y);\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts (z # zs))", "ultimately"], ["proof (chain)\npicking this:\n  sorted (eqs @ x # quicksort_acc ac gts)\n  \\<forall>y\\<in>set lts.\n     \\<forall>a\\<in>set (eqs @ x # quicksort_acc ac gts). y < a", "show ?case"], ["proof (prove)\nusing this:\n  sorted (eqs @ x # quicksort_acc ac gts)\n  \\<forall>y\\<in>set lts.\n     \\<forall>a\\<in>set (eqs @ x # quicksort_acc ac gts). y < a\n\ngoal (1 subgoal):\n 1. sorted (quicksort_part ac x lts eqs gts [])", "by(simp add: \"4.IH\")"], ["proof (state)\nthis:\n  sorted (quicksort_part ac x lts eqs gts [])\n\ngoal (1 subgoal):\n 1. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; sorted ac;\n                 \\<forall>y\\<in>set lts \\<union> {x} \\<union>\n                                set eqs \\<union>\n                                set (z # gts) \\<union>\n                                set zs.\n                    Ball (set ac) ((<) y);\n                 \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted\n                                   (quicksort_part ac x lts eqs (z # gts)\n                                     zs);\n        \\<lbrakk>\\<not> x < z; z < x; sorted ac;\n         \\<forall>y\\<in>set (z # lts) \\<union> {x} \\<union> set eqs \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set (z # lts). y < x; \\<forall>y\\<in>set eqs. y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x (z # lts) eqs gts zs);\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; sorted ac;\n         \\<forall>y\\<in>set lts \\<union> {x} \\<union> set (z # eqs) \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x lts (z # eqs) gts zs);\n        sorted ac;\n        \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                       set gts \\<union>\n                       set (z # zs).\n           Ball (set ac) ((<) y);\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts (z # zs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; sorted ac;\n                 \\<forall>y\\<in>set lts \\<union> {x} \\<union>\n                                set eqs \\<union>\n                                set (z # gts) \\<union>\n                                set zs.\n                    Ball (set ac) ((<) y);\n                 \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted\n                                   (quicksort_part ac x lts eqs (z # gts)\n                                     zs);\n        \\<lbrakk>\\<not> x < z; z < x; sorted ac;\n         \\<forall>y\\<in>set (z # lts) \\<union> {x} \\<union> set eqs \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set (z # lts). y < x; \\<forall>y\\<in>set eqs. y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x (z # lts) eqs gts zs);\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; sorted ac;\n         \\<forall>y\\<in>set lts \\<union> {x} \\<union> set (z # eqs) \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x lts (z # eqs) gts zs);\n        sorted ac;\n        \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                       set gts \\<union>\n                       set (z # zs).\n           Ball (set ac) ((<) y);\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts (z # zs))", "case 5"], ["proof (state)\nthis:\n  \\<lbrakk>x_ < z_; sorted ac_;\n   \\<forall>y\\<in>set lts_ \\<union> {x_} \\<union> set eqs_ \\<union>\n                  set (z_ # gts_) \\<union>\n                  set zs_.\n      \\<forall>a\\<in>set ac_. y < a;\n   \\<forall>y\\<in>set lts_. y < x_; \\<forall>y\\<in>set eqs_. y = x_;\n   \\<forall>a\\<in>set (z_ # gts_). x_ < a\\<rbrakk>\n  \\<Longrightarrow> sorted (quicksort_part ac_ x_ lts_ eqs_ (z_ # gts_) zs_)\n  \\<lbrakk>\\<not> x_ < z_; z_ < x_; sorted ac_;\n   \\<forall>y\\<in>set (z_ # lts_) \\<union> {x_} \\<union> set eqs_ \\<union>\n                  set gts_ \\<union>\n                  set zs_.\n      \\<forall>a\\<in>set ac_. y < a;\n   \\<forall>y\\<in>set (z_ # lts_). y < x_; \\<forall>y\\<in>set eqs_. y = x_;\n   \\<forall>a\\<in>set gts_. x_ < a\\<rbrakk>\n  \\<Longrightarrow> sorted (quicksort_part ac_ x_ (z_ # lts_) eqs_ gts_ zs_)\n  \\<lbrakk>\\<not> x_ < z_; \\<not> z_ < x_; sorted ac_;\n   \\<forall>y\\<in>set lts_ \\<union> {x_} \\<union> set (z_ # eqs_) \\<union>\n                  set gts_ \\<union>\n                  set zs_.\n      \\<forall>a\\<in>set ac_. y < a;\n   \\<forall>y\\<in>set lts_. y < x_; \\<forall>y\\<in>set (z_ # eqs_). y = x_;\n   \\<forall>a\\<in>set gts_. x_ < a\\<rbrakk>\n  \\<Longrightarrow> sorted (quicksort_part ac_ x_ lts_ (z_ # eqs_) gts_ zs_)\n  sorted ac_\n  \\<forall>y\\<in>set lts_ \\<union> {x_} \\<union> set eqs_ \\<union>\n                 set gts_ \\<union>\n                 set (z_ # zs_).\n     \\<forall>a\\<in>set ac_. y < a\n  \\<forall>y\\<in>set lts_. y < x_\n  \\<forall>y\\<in>set eqs_. y = x_\n  \\<forall>a\\<in>set gts_. x_ < a\n\ngoal (1 subgoal):\n 1. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; sorted ac;\n                 \\<forall>y\\<in>set lts \\<union> {x} \\<union>\n                                set eqs \\<union>\n                                set (z # gts) \\<union>\n                                set zs.\n                    Ball (set ac) ((<) y);\n                 \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> sorted\n                                   (quicksort_part ac x lts eqs (z # gts)\n                                     zs);\n        \\<lbrakk>\\<not> x < z; z < x; sorted ac;\n         \\<forall>y\\<in>set (z # lts) \\<union> {x} \\<union> set eqs \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set (z # lts). y < x; \\<forall>y\\<in>set eqs. y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x (z # lts) eqs gts zs);\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; sorted ac;\n         \\<forall>y\\<in>set lts \\<union> {x} \\<union> set (z # eqs) \\<union>\n                        set gts \\<union>\n                        set zs.\n            Ball (set ac) ((<) y);\n         \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> sorted (quicksort_part ac x lts (z # eqs) gts zs);\n        sorted ac;\n        \\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union>\n                       set gts \\<union>\n                       set (z # zs).\n           Ball (set ac) ((<) y);\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts (z # zs))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>x_ < z_; sorted ac_;\n   \\<forall>y\\<in>set lts_ \\<union> {x_} \\<union> set eqs_ \\<union>\n                  set (z_ # gts_) \\<union>\n                  set zs_.\n      \\<forall>a\\<in>set ac_. y < a;\n   \\<forall>y\\<in>set lts_. y < x_; \\<forall>y\\<in>set eqs_. y = x_;\n   \\<forall>a\\<in>set (z_ # gts_). x_ < a\\<rbrakk>\n  \\<Longrightarrow> sorted (quicksort_part ac_ x_ lts_ eqs_ (z_ # gts_) zs_)\n  \\<lbrakk>\\<not> x_ < z_; z_ < x_; sorted ac_;\n   \\<forall>y\\<in>set (z_ # lts_) \\<union> {x_} \\<union> set eqs_ \\<union>\n                  set gts_ \\<union>\n                  set zs_.\n      \\<forall>a\\<in>set ac_. y < a;\n   \\<forall>y\\<in>set (z_ # lts_). y < x_; \\<forall>y\\<in>set eqs_. y = x_;\n   \\<forall>a\\<in>set gts_. x_ < a\\<rbrakk>\n  \\<Longrightarrow> sorted (quicksort_part ac_ x_ (z_ # lts_) eqs_ gts_ zs_)\n  \\<lbrakk>\\<not> x_ < z_; \\<not> z_ < x_; sorted ac_;\n   \\<forall>y\\<in>set lts_ \\<union> {x_} \\<union> set (z_ # eqs_) \\<union>\n                  set gts_ \\<union>\n                  set zs_.\n      \\<forall>a\\<in>set ac_. y < a;\n   \\<forall>y\\<in>set lts_. y < x_; \\<forall>y\\<in>set (z_ # eqs_). y = x_;\n   \\<forall>a\\<in>set gts_. x_ < a\\<rbrakk>\n  \\<Longrightarrow> sorted (quicksort_part ac_ x_ lts_ (z_ # eqs_) gts_ zs_)\n  sorted ac_\n  \\<forall>y\\<in>set lts_ \\<union> {x_} \\<union> set eqs_ \\<union>\n                 set gts_ \\<union>\n                 set (z_ # zs_).\n     \\<forall>a\\<in>set ac_. y < a\n  \\<forall>y\\<in>set lts_. y < x_\n  \\<forall>y\\<in>set eqs_. y = x_\n  \\<forall>a\\<in>set gts_. x_ < a\n\ngoal (1 subgoal):\n 1. sorted (quicksort_part ac_ x_ lts_ eqs_ gts_ (z_ # zs_))", "by(simp add: not_less eq_iff)"], ["proof (state)\nthis:\n  sorted (quicksort_part ac_ x_ lts_ eqs_ gts_ (z_ # zs_))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sorted_quicksort [simp]: \"sorted (quicksort xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (quicksort xs)", "by(simp add: quicksort_def sorted_quicksort_acc)"], ["", "lemma insort_key_append1:\n  \"\\<forall>y \\<in> set ys. f x < f y \\<Longrightarrow> insort_key f x (xs @ ys) = insort_key f x xs @ ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set ys. f x < f y \\<Longrightarrow>\n    insort_key f x (xs @ ys) = insort_key f x xs @ ys", "proof(induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>y\\<in>set ys. f x < f y \\<Longrightarrow>\n    insort_key f x ([] @ ys) = insort_key f x [] @ ys\n 2. \\<And>a xs.\n       \\<lbrakk>\\<forall>y\\<in>set ys. f x < f y \\<Longrightarrow>\n                insort_key f x (xs @ ys) = insort_key f x xs @ ys;\n        \\<forall>y\\<in>set ys. f x < f y\\<rbrakk>\n       \\<Longrightarrow> insort_key f x ((a # xs) @ ys) =\n                         insort_key f x (a # xs) @ ys", "case Nil"], ["proof (state)\nthis:\n  \\<forall>y\\<in>set ys. f x < f y\n\ngoal (2 subgoals):\n 1. \\<forall>y\\<in>set ys. f x < f y \\<Longrightarrow>\n    insort_key f x ([] @ ys) = insort_key f x [] @ ys\n 2. \\<And>a xs.\n       \\<lbrakk>\\<forall>y\\<in>set ys. f x < f y \\<Longrightarrow>\n                insort_key f x (xs @ ys) = insort_key f x xs @ ys;\n        \\<forall>y\\<in>set ys. f x < f y\\<rbrakk>\n       \\<Longrightarrow> insort_key f x ((a # xs) @ ys) =\n                         insort_key f x (a # xs) @ ys", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>set ys. f x < f y\n\ngoal (1 subgoal):\n 1. insort_key f x ([] @ ys) = insort_key f x [] @ ys", "by(cases ys) auto"], ["proof (state)\nthis:\n  insort_key f x ([] @ ys) = insort_key f x [] @ ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<forall>y\\<in>set ys. f x < f y \\<Longrightarrow>\n                insort_key f x (xs @ ys) = insort_key f x xs @ ys;\n        \\<forall>y\\<in>set ys. f x < f y\\<rbrakk>\n       \\<Longrightarrow> insort_key f x ((a # xs) @ ys) =\n                         insort_key f x (a # xs) @ ys", "qed simp"], ["", "lemma insort_key_append2:\n  \"\\<forall>y \\<in> set xs. f x > f y \\<Longrightarrow> insort_key f x (xs @ ys) = xs @ insort_key f x ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set xs. f y < f x \\<Longrightarrow>\n    insort_key f x (xs @ ys) = xs @ insort_key f x ys", "by(induct xs) auto"], ["", "lemma sort_key_append:\n  \"\\<forall>x\\<in>set xs. \\<forall>y\\<in>set ys. f x < f y \\<Longrightarrow> sort_key f (xs @ ys) = sort_key f xs @ sort_key f ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs.\n       \\<forall>y\\<in>set ys. f x < f y \\<Longrightarrow>\n    sort_key f (xs @ ys) = sort_key f xs @ sort_key f ys", "by(induct xs)(simp_all add: insort_key_append1)"], ["", "definition single_list :: \"'a \\<Rightarrow> 'a list\" where \"single_list a = [a]\""], ["", "lemma to_single_list: \"x # xs = single_list x @ xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x # xs = single_list x @ xs", "by(simp add: single_list_def)"], ["", "lemma sort_snoc: \"sort (xs @ [x]) = insort x (sort xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sort (xs @ [x]) = insort x (sort xs)", "by(induct xs)(simp_all add: insort_left_comm)"], ["", "lemma sort_append_swap: \"sort (xs @ ys) = sort (ys @ xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sort (xs @ ys) = sort (ys @ xs)", "by(induct xs arbitrary: ys rule: rev_induct)(simp_all add: sort_snoc[symmetric])"], ["", "lemma sort_append_swap2: \"sort (xs @ ys @ zs) = sort (ys @ xs @ zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sort (xs @ ys @ zs) = sort (ys @ xs @ zs)", "by(induct xs)(simp_all, subst (1 2) sort_append_swap, simp)"], ["", "lemma sort_Cons_append_swap: \"sort (x # xs) = sort (xs @ [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sort (x # xs) = sort (xs @ [x])", "by(subst sort_append_swap) simp"], ["", "lemma sort_append_Cons_swap: \"sort (ys @ x # xs) = sort (ys @ xs @ [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sort (ys @ x # xs) = sort (ys @ xs @ [x])", "apply(induct ys)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sort ([] @ x # xs) = sort ([] @ xs @ [x])\n 2. \\<And>a ys.\n       sort (ys @ x # xs) = sort (ys @ xs @ [x]) \\<Longrightarrow>\n       sort ((a # ys) @ x # xs) = sort ((a # ys) @ xs @ [x])", "apply(simp only: append.simps sort_Cons_append_swap)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ys.\n       sort (ys @ x # xs) = sort (ys @ xs @ [x]) \\<Longrightarrow>\n       sort ((a # ys) @ x # xs) = sort ((a # ys) @ xs @ [x])", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma quicksort_acc_conv_sort: \n  \"quicksort_acc ac xs = sort xs @ ac\"\n  and quicksort_part_conv_sort: \n  \"\\<lbrakk> \\<forall>y \\<in> set lts. y < x; \\<forall>y \\<in> set eqs. y = x; \\<forall>y \\<in> set gts. y > x \\<rbrakk> \n  \\<Longrightarrow> quicksort_part ac x lts eqs gts zs = sort (lts @ eqs @ gts @ x # zs) @ ac\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quicksort_acc ac xs = sort xs @ ac &&&\n    (\\<lbrakk>\\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n      \\<forall>y\\<in>set gts. x < y\\<rbrakk>\n     \\<Longrightarrow> quicksort_part ac x lts eqs gts zs =\n                       sort (lts @ eqs @ gts @ x # zs) @ ac)", "proof(induct ac xs and ac x lts eqs gts zs rule: quicksort_acc_quicksort_part.induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>ac. quicksort_acc ac [] = sort [] @ ac\n 2. \\<And>ac x. quicksort_acc ac [x] = sort [x] @ ac\n 3. \\<And>ac x v va.\n       (\\<lbrakk>\\<forall>y\\<in>set []. y < x; \\<forall>y\\<in>set []. y = x;\n         Ball (set []) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x [] [] [] (v # va) =\n                          sort ([] @ [] @ [] @ x # v # va) @\n                          ac) \\<Longrightarrow>\n       quicksort_acc ac (x # v # va) = sort (x # v # va) @ ac\n 4. \\<And>ac x lts eqs gts.\n       \\<lbrakk>quicksort_acc ac gts = sort gts @ ac;\n        quicksort_acc (eqs @ x # quicksort_acc ac gts) lts =\n        sort lts @ eqs @ x # quicksort_acc ac gts;\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> quicksort_part ac x lts eqs gts [] =\n                         sort (lts @ eqs @ gts @ [x]) @ ac\n 5. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> quicksort_part ac x lts eqs (z # gts) zs =\n                                  sort (lts @ eqs @ (z # gts) @ x # zs) @\n                                  ac;\n        \\<lbrakk>\\<not> x < z; z < x; \\<forall>y\\<in>set (z # lts). y < x;\n         \\<forall>y\\<in>set eqs. y = x; Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x (z # lts) eqs gts zs =\n                          sort ((z # lts) @ eqs @ gts @ x # zs) @ ac;\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; \\<forall>y\\<in>set lts. y < x;\n         \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x lts (z # eqs) gts zs =\n                          sort (lts @ (z # eqs) @ gts @ x # zs) @ ac;\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> quicksort_part ac x lts eqs gts (z # zs) =\n                         sort (lts @ eqs @ gts @ x # z # zs) @ ac", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. \\<And>ac. quicksort_acc ac [] = sort [] @ ac\n 2. \\<And>ac x. quicksort_acc ac [x] = sort [x] @ ac\n 3. \\<And>ac x v va.\n       (\\<lbrakk>\\<forall>y\\<in>set []. y < x; \\<forall>y\\<in>set []. y = x;\n         Ball (set []) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x [] [] [] (v # va) =\n                          sort ([] @ [] @ [] @ x # v # va) @\n                          ac) \\<Longrightarrow>\n       quicksort_acc ac (x # v # va) = sort (x # v # va) @ ac\n 4. \\<And>ac x lts eqs gts.\n       \\<lbrakk>quicksort_acc ac gts = sort gts @ ac;\n        quicksort_acc (eqs @ x # quicksort_acc ac gts) lts =\n        sort lts @ eqs @ x # quicksort_acc ac gts;\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> quicksort_part ac x lts eqs gts [] =\n                         sort (lts @ eqs @ gts @ [x]) @ ac\n 5. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> quicksort_part ac x lts eqs (z # gts) zs =\n                                  sort (lts @ eqs @ (z # gts) @ x # zs) @\n                                  ac;\n        \\<lbrakk>\\<not> x < z; z < x; \\<forall>y\\<in>set (z # lts). y < x;\n         \\<forall>y\\<in>set eqs. y = x; Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x (z # lts) eqs gts zs =\n                          sort ((z # lts) @ eqs @ gts @ x # zs) @ ac;\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; \\<forall>y\\<in>set lts. y < x;\n         \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x lts (z # eqs) gts zs =\n                          sort (lts @ (z # eqs) @ gts @ x # zs) @ ac;\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> quicksort_part ac x lts eqs gts (z # zs) =\n                         sort (lts @ eqs @ gts @ x # z # zs) @ ac", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. quicksort_acc ac_ [] = sort [] @ ac_", "by simp"], ["proof (state)\nthis:\n  quicksort_acc ac_ [] = sort [] @ ac_\n\ngoal (4 subgoals):\n 1. \\<And>ac x. quicksort_acc ac [x] = sort [x] @ ac\n 2. \\<And>ac x v va.\n       (\\<lbrakk>\\<forall>y\\<in>set []. y < x; \\<forall>y\\<in>set []. y = x;\n         Ball (set []) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x [] [] [] (v # va) =\n                          sort ([] @ [] @ [] @ x # v # va) @\n                          ac) \\<Longrightarrow>\n       quicksort_acc ac (x # v # va) = sort (x # v # va) @ ac\n 3. \\<And>ac x lts eqs gts.\n       \\<lbrakk>quicksort_acc ac gts = sort gts @ ac;\n        quicksort_acc (eqs @ x # quicksort_acc ac gts) lts =\n        sort lts @ eqs @ x # quicksort_acc ac gts;\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> quicksort_part ac x lts eqs gts [] =\n                         sort (lts @ eqs @ gts @ [x]) @ ac\n 4. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> quicksort_part ac x lts eqs (z # gts) zs =\n                                  sort (lts @ eqs @ (z # gts) @ x # zs) @\n                                  ac;\n        \\<lbrakk>\\<not> x < z; z < x; \\<forall>y\\<in>set (z # lts). y < x;\n         \\<forall>y\\<in>set eqs. y = x; Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x (z # lts) eqs gts zs =\n                          sort ((z # lts) @ eqs @ gts @ x # zs) @ ac;\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; \\<forall>y\\<in>set lts. y < x;\n         \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x lts (z # eqs) gts zs =\n                          sort (lts @ (z # eqs) @ gts @ x # zs) @ ac;\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> quicksort_part ac x lts eqs gts (z # zs) =\n                         sort (lts @ eqs @ gts @ x # z # zs) @ ac", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>ac x. quicksort_acc ac [x] = sort [x] @ ac\n 2. \\<And>ac x v va.\n       (\\<lbrakk>\\<forall>y\\<in>set []. y < x; \\<forall>y\\<in>set []. y = x;\n         Ball (set []) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x [] [] [] (v # va) =\n                          sort ([] @ [] @ [] @ x # v # va) @\n                          ac) \\<Longrightarrow>\n       quicksort_acc ac (x # v # va) = sort (x # v # va) @ ac\n 3. \\<And>ac x lts eqs gts.\n       \\<lbrakk>quicksort_acc ac gts = sort gts @ ac;\n        quicksort_acc (eqs @ x # quicksort_acc ac gts) lts =\n        sort lts @ eqs @ x # quicksort_acc ac gts;\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> quicksort_part ac x lts eqs gts [] =\n                         sort (lts @ eqs @ gts @ [x]) @ ac\n 4. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> quicksort_part ac x lts eqs (z # gts) zs =\n                                  sort (lts @ eqs @ (z # gts) @ x # zs) @\n                                  ac;\n        \\<lbrakk>\\<not> x < z; z < x; \\<forall>y\\<in>set (z # lts). y < x;\n         \\<forall>y\\<in>set eqs. y = x; Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x (z # lts) eqs gts zs =\n                          sort ((z # lts) @ eqs @ gts @ x # zs) @ ac;\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; \\<forall>y\\<in>set lts. y < x;\n         \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x lts (z # eqs) gts zs =\n                          sort (lts @ (z # eqs) @ gts @ x # zs) @ ac;\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> quicksort_part ac x lts eqs gts (z # zs) =\n                         sort (lts @ eqs @ gts @ x # z # zs) @ ac", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>ac x. quicksort_acc ac [x] = sort [x] @ ac\n 2. \\<And>ac x v va.\n       (\\<lbrakk>\\<forall>y\\<in>set []. y < x; \\<forall>y\\<in>set []. y = x;\n         Ball (set []) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x [] [] [] (v # va) =\n                          sort ([] @ [] @ [] @ x # v # va) @\n                          ac) \\<Longrightarrow>\n       quicksort_acc ac (x # v # va) = sort (x # v # va) @ ac\n 3. \\<And>ac x lts eqs gts.\n       \\<lbrakk>quicksort_acc ac gts = sort gts @ ac;\n        quicksort_acc (eqs @ x # quicksort_acc ac gts) lts =\n        sort lts @ eqs @ x # quicksort_acc ac gts;\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> quicksort_part ac x lts eqs gts [] =\n                         sort (lts @ eqs @ gts @ [x]) @ ac\n 4. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> quicksort_part ac x lts eqs (z # gts) zs =\n                                  sort (lts @ eqs @ (z # gts) @ x # zs) @\n                                  ac;\n        \\<lbrakk>\\<not> x < z; z < x; \\<forall>y\\<in>set (z # lts). y < x;\n         \\<forall>y\\<in>set eqs. y = x; Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x (z # lts) eqs gts zs =\n                          sort ((z # lts) @ eqs @ gts @ x # zs) @ ac;\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; \\<forall>y\\<in>set lts. y < x;\n         \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x lts (z # eqs) gts zs =\n                          sort (lts @ (z # eqs) @ gts @ x # zs) @ ac;\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> quicksort_part ac x lts eqs gts (z # zs) =\n                         sort (lts @ eqs @ gts @ x # z # zs) @ ac", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. quicksort_acc ac_ [x_] = sort [x_] @ ac_", "by simp"], ["proof (state)\nthis:\n  quicksort_acc ac_ [x_] = sort [x_] @ ac_\n\ngoal (3 subgoals):\n 1. \\<And>ac x v va.\n       (\\<lbrakk>\\<forall>y\\<in>set []. y < x; \\<forall>y\\<in>set []. y = x;\n         Ball (set []) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x [] [] [] (v # va) =\n                          sort ([] @ [] @ [] @ x # v # va) @\n                          ac) \\<Longrightarrow>\n       quicksort_acc ac (x # v # va) = sort (x # v # va) @ ac\n 2. \\<And>ac x lts eqs gts.\n       \\<lbrakk>quicksort_acc ac gts = sort gts @ ac;\n        quicksort_acc (eqs @ x # quicksort_acc ac gts) lts =\n        sort lts @ eqs @ x # quicksort_acc ac gts;\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> quicksort_part ac x lts eqs gts [] =\n                         sort (lts @ eqs @ gts @ [x]) @ ac\n 3. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> quicksort_part ac x lts eqs (z # gts) zs =\n                                  sort (lts @ eqs @ (z # gts) @ x # zs) @\n                                  ac;\n        \\<lbrakk>\\<not> x < z; z < x; \\<forall>y\\<in>set (z # lts). y < x;\n         \\<forall>y\\<in>set eqs. y = x; Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x (z # lts) eqs gts zs =\n                          sort ((z # lts) @ eqs @ gts @ x # zs) @ ac;\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; \\<forall>y\\<in>set lts. y < x;\n         \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x lts (z # eqs) gts zs =\n                          sort (lts @ (z # eqs) @ gts @ x # zs) @ ac;\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> quicksort_part ac x lts eqs gts (z # zs) =\n                         sort (lts @ eqs @ gts @ x # z # zs) @ ac", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ac x v va.\n       (\\<lbrakk>\\<forall>y\\<in>set []. y < x; \\<forall>y\\<in>set []. y = x;\n         Ball (set []) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x [] [] [] (v # va) =\n                          sort ([] @ [] @ [] @ x # v # va) @\n                          ac) \\<Longrightarrow>\n       quicksort_acc ac (x # v # va) = sort (x # v # va) @ ac\n 2. \\<And>ac x lts eqs gts.\n       \\<lbrakk>quicksort_acc ac gts = sort gts @ ac;\n        quicksort_acc (eqs @ x # quicksort_acc ac gts) lts =\n        sort lts @ eqs @ x # quicksort_acc ac gts;\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> quicksort_part ac x lts eqs gts [] =\n                         sort (lts @ eqs @ gts @ [x]) @ ac\n 3. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> quicksort_part ac x lts eqs (z # gts) zs =\n                                  sort (lts @ eqs @ (z # gts) @ x # zs) @\n                                  ac;\n        \\<lbrakk>\\<not> x < z; z < x; \\<forall>y\\<in>set (z # lts). y < x;\n         \\<forall>y\\<in>set eqs. y = x; Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x (z # lts) eqs gts zs =\n                          sort ((z # lts) @ eqs @ gts @ x # zs) @ ac;\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; \\<forall>y\\<in>set lts. y < x;\n         \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x lts (z # eqs) gts zs =\n                          sort (lts @ (z # eqs) @ gts @ x # zs) @ ac;\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> quicksort_part ac x lts eqs gts (z # zs) =\n                         sort (lts @ eqs @ gts @ x # z # zs) @ ac", "case 3"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>y\\<in>set []. y < x_; \\<forall>y\\<in>set []. y = x_;\n   \\<forall>a\\<in>set []. x_ < a\\<rbrakk>\n  \\<Longrightarrow> quicksort_part ac_ x_ [] [] [] (v_ # va_) =\n                    sort ([] @ [] @ [] @ x_ # v_ # va_) @ ac_\n\ngoal (3 subgoals):\n 1. \\<And>ac x v va.\n       (\\<lbrakk>\\<forall>y\\<in>set []. y < x; \\<forall>y\\<in>set []. y = x;\n         Ball (set []) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x [] [] [] (v # va) =\n                          sort ([] @ [] @ [] @ x # v # va) @\n                          ac) \\<Longrightarrow>\n       quicksort_acc ac (x # v # va) = sort (x # v # va) @ ac\n 2. \\<And>ac x lts eqs gts.\n       \\<lbrakk>quicksort_acc ac gts = sort gts @ ac;\n        quicksort_acc (eqs @ x # quicksort_acc ac gts) lts =\n        sort lts @ eqs @ x # quicksort_acc ac gts;\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> quicksort_part ac x lts eqs gts [] =\n                         sort (lts @ eqs @ gts @ [x]) @ ac\n 3. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> quicksort_part ac x lts eqs (z # gts) zs =\n                                  sort (lts @ eqs @ (z # gts) @ x # zs) @\n                                  ac;\n        \\<lbrakk>\\<not> x < z; z < x; \\<forall>y\\<in>set (z # lts). y < x;\n         \\<forall>y\\<in>set eqs. y = x; Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x (z # lts) eqs gts zs =\n                          sort ((z # lts) @ eqs @ gts @ x # zs) @ ac;\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; \\<forall>y\\<in>set lts. y < x;\n         \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x lts (z # eqs) gts zs =\n                          sort (lts @ (z # eqs) @ gts @ x # zs) @ ac;\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> quicksort_part ac x lts eqs gts (z # zs) =\n                         sort (lts @ eqs @ gts @ x # z # zs) @ ac", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>y\\<in>set []. y < x_; \\<forall>y\\<in>set []. y = x_;\n   \\<forall>a\\<in>set []. x_ < a\\<rbrakk>\n  \\<Longrightarrow> quicksort_part ac_ x_ [] [] [] (v_ # va_) =\n                    sort ([] @ [] @ [] @ x_ # v_ # va_) @ ac_\n\ngoal (1 subgoal):\n 1. quicksort_acc ac_ (x_ # v_ # va_) = sort (x_ # v_ # va_) @ ac_", "by simp"], ["proof (state)\nthis:\n  quicksort_acc ac_ (x_ # v_ # va_) = sort (x_ # v_ # va_) @ ac_\n\ngoal (2 subgoals):\n 1. \\<And>ac x lts eqs gts.\n       \\<lbrakk>quicksort_acc ac gts = sort gts @ ac;\n        quicksort_acc (eqs @ x # quicksort_acc ac gts) lts =\n        sort lts @ eqs @ x # quicksort_acc ac gts;\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> quicksort_part ac x lts eqs gts [] =\n                         sort (lts @ eqs @ gts @ [x]) @ ac\n 2. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> quicksort_part ac x lts eqs (z # gts) zs =\n                                  sort (lts @ eqs @ (z # gts) @ x # zs) @\n                                  ac;\n        \\<lbrakk>\\<not> x < z; z < x; \\<forall>y\\<in>set (z # lts). y < x;\n         \\<forall>y\\<in>set eqs. y = x; Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x (z # lts) eqs gts zs =\n                          sort ((z # lts) @ eqs @ gts @ x # zs) @ ac;\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; \\<forall>y\\<in>set lts. y < x;\n         \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x lts (z # eqs) gts zs =\n                          sort (lts @ (z # eqs) @ gts @ x # zs) @ ac;\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> quicksort_part ac x lts eqs gts (z # zs) =\n                         sort (lts @ eqs @ gts @ x # z # zs) @ ac", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ac x lts eqs gts.\n       \\<lbrakk>quicksort_acc ac gts = sort gts @ ac;\n        quicksort_acc (eqs @ x # quicksort_acc ac gts) lts =\n        sort lts @ eqs @ x # quicksort_acc ac gts;\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> quicksort_part ac x lts eqs gts [] =\n                         sort (lts @ eqs @ gts @ [x]) @ ac\n 2. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> quicksort_part ac x lts eqs (z # gts) zs =\n                                  sort (lts @ eqs @ (z # gts) @ x # zs) @\n                                  ac;\n        \\<lbrakk>\\<not> x < z; z < x; \\<forall>y\\<in>set (z # lts). y < x;\n         \\<forall>y\\<in>set eqs. y = x; Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x (z # lts) eqs gts zs =\n                          sort ((z # lts) @ eqs @ gts @ x # zs) @ ac;\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; \\<forall>y\\<in>set lts. y < x;\n         \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x lts (z # eqs) gts zs =\n                          sort (lts @ (z # eqs) @ gts @ x # zs) @ ac;\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> quicksort_part ac x lts eqs gts (z # zs) =\n                         sort (lts @ eqs @ gts @ x # z # zs) @ ac", "case (4 ac x lts eqs gts)"], ["proof (state)\nthis:\n  quicksort_acc ac gts = sort gts @ ac\n  quicksort_acc (eqs @ x # quicksort_acc ac gts) lts =\n  sort lts @ eqs @ x # quicksort_acc ac gts\n  \\<forall>y\\<in>set lts. y < x\n  \\<forall>y\\<in>set eqs. y = x\n  \\<forall>a\\<in>set gts. x < a\n\ngoal (2 subgoals):\n 1. \\<And>ac x lts eqs gts.\n       \\<lbrakk>quicksort_acc ac gts = sort gts @ ac;\n        quicksort_acc (eqs @ x # quicksort_acc ac gts) lts =\n        sort lts @ eqs @ x # quicksort_acc ac gts;\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> quicksort_part ac x lts eqs gts [] =\n                         sort (lts @ eqs @ gts @ [x]) @ ac\n 2. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> quicksort_part ac x lts eqs (z # gts) zs =\n                                  sort (lts @ eqs @ (z # gts) @ x # zs) @\n                                  ac;\n        \\<lbrakk>\\<not> x < z; z < x; \\<forall>y\\<in>set (z # lts). y < x;\n         \\<forall>y\\<in>set eqs. y = x; Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x (z # lts) eqs gts zs =\n                          sort ((z # lts) @ eqs @ gts @ x # zs) @ ac;\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; \\<forall>y\\<in>set lts. y < x;\n         \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x lts (z # eqs) gts zs =\n                          sort (lts @ (z # eqs) @ gts @ x # zs) @ ac;\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> quicksort_part ac x lts eqs gts (z # zs) =\n                         sort (lts @ eqs @ gts @ x # z # zs) @ ac", "note eqs = \\<open>\\<forall>y\\<in>set eqs. y = x\\<close>"], ["proof (state)\nthis:\n  \\<forall>y\\<in>set eqs. y = x\n\ngoal (2 subgoals):\n 1. \\<And>ac x lts eqs gts.\n       \\<lbrakk>quicksort_acc ac gts = sort gts @ ac;\n        quicksort_acc (eqs @ x # quicksort_acc ac gts) lts =\n        sort lts @ eqs @ x # quicksort_acc ac gts;\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> quicksort_part ac x lts eqs gts [] =\n                         sort (lts @ eqs @ gts @ [x]) @ ac\n 2. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> quicksort_part ac x lts eqs (z # gts) zs =\n                                  sort (lts @ eqs @ (z # gts) @ x # zs) @\n                                  ac;\n        \\<lbrakk>\\<not> x < z; z < x; \\<forall>y\\<in>set (z # lts). y < x;\n         \\<forall>y\\<in>set eqs. y = x; Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x (z # lts) eqs gts zs =\n                          sort ((z # lts) @ eqs @ gts @ x # zs) @ ac;\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; \\<forall>y\\<in>set lts. y < x;\n         \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x lts (z # eqs) gts zs =\n                          sort (lts @ (z # eqs) @ gts @ x # zs) @ ac;\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> quicksort_part ac x lts eqs gts (z # zs) =\n                         sort (lts @ eqs @ gts @ x # z # zs) @ ac", "{"], ["proof (state)\nthis:\n  \\<forall>y\\<in>set eqs. y = x\n\ngoal (2 subgoals):\n 1. \\<And>ac x lts eqs gts.\n       \\<lbrakk>quicksort_acc ac gts = sort gts @ ac;\n        quicksort_acc (eqs @ x # quicksort_acc ac gts) lts =\n        sort lts @ eqs @ x # quicksort_acc ac gts;\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> quicksort_part ac x lts eqs gts [] =\n                         sort (lts @ eqs @ gts @ [x]) @ ac\n 2. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> quicksort_part ac x lts eqs (z # gts) zs =\n                                  sort (lts @ eqs @ (z # gts) @ x # zs) @\n                                  ac;\n        \\<lbrakk>\\<not> x < z; z < x; \\<forall>y\\<in>set (z # lts). y < x;\n         \\<forall>y\\<in>set eqs. y = x; Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x (z # lts) eqs gts zs =\n                          sort ((z # lts) @ eqs @ gts @ x # zs) @ ac;\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; \\<forall>y\\<in>set lts. y < x;\n         \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x lts (z # eqs) gts zs =\n                          sort (lts @ (z # eqs) @ gts @ x # zs) @ ac;\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> quicksort_part ac x lts eqs gts (z # zs) =\n                         sort (lts @ eqs @ gts @ x # z # zs) @ ac", "fix eqs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ac x lts eqs gts.\n       \\<lbrakk>quicksort_acc ac gts = sort gts @ ac;\n        quicksort_acc (eqs @ x # quicksort_acc ac gts) lts =\n        sort lts @ eqs @ x # quicksort_acc ac gts;\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> quicksort_part ac x lts eqs gts [] =\n                         sort (lts @ eqs @ gts @ [x]) @ ac\n 2. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> quicksort_part ac x lts eqs (z # gts) zs =\n                                  sort (lts @ eqs @ (z # gts) @ x # zs) @\n                                  ac;\n        \\<lbrakk>\\<not> x < z; z < x; \\<forall>y\\<in>set (z # lts). y < x;\n         \\<forall>y\\<in>set eqs. y = x; Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x (z # lts) eqs gts zs =\n                          sort ((z # lts) @ eqs @ gts @ x # zs) @ ac;\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; \\<forall>y\\<in>set lts. y < x;\n         \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x lts (z # eqs) gts zs =\n                          sort (lts @ (z # eqs) @ gts @ x # zs) @ ac;\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> quicksort_part ac x lts eqs gts (z # zs) =\n                         sort (lts @ eqs @ gts @ x # z # zs) @ ac", "assume \"\\<forall>y\\<in>set eqs. y = x\""], ["proof (state)\nthis:\n  \\<forall>y\\<in>set eqs. y = x\n\ngoal (2 subgoals):\n 1. \\<And>ac x lts eqs gts.\n       \\<lbrakk>quicksort_acc ac gts = sort gts @ ac;\n        quicksort_acc (eqs @ x # quicksort_acc ac gts) lts =\n        sort lts @ eqs @ x # quicksort_acc ac gts;\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> quicksort_part ac x lts eqs gts [] =\n                         sort (lts @ eqs @ gts @ [x]) @ ac\n 2. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> quicksort_part ac x lts eqs (z # gts) zs =\n                                  sort (lts @ eqs @ (z # gts) @ x # zs) @\n                                  ac;\n        \\<lbrakk>\\<not> x < z; z < x; \\<forall>y\\<in>set (z # lts). y < x;\n         \\<forall>y\\<in>set eqs. y = x; Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x (z # lts) eqs gts zs =\n                          sort ((z # lts) @ eqs @ gts @ x # zs) @ ac;\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; \\<forall>y\\<in>set lts. y < x;\n         \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x lts (z # eqs) gts zs =\n                          sort (lts @ (z # eqs) @ gts @ x # zs) @ ac;\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> quicksort_part ac x lts eqs gts (z # zs) =\n                         sort (lts @ eqs @ gts @ x # z # zs) @ ac", "hence \"insort x eqs = x # eqs\""], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>set eqs. y = x\n\ngoal (1 subgoal):\n 1. insort x eqs = x # eqs", "by(induct eqs) simp_all"], ["proof (state)\nthis:\n  insort x eqs = x # eqs\n\ngoal (2 subgoals):\n 1. \\<And>ac x lts eqs gts.\n       \\<lbrakk>quicksort_acc ac gts = sort gts @ ac;\n        quicksort_acc (eqs @ x # quicksort_acc ac gts) lts =\n        sort lts @ eqs @ x # quicksort_acc ac gts;\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> quicksort_part ac x lts eqs gts [] =\n                         sort (lts @ eqs @ gts @ [x]) @ ac\n 2. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> quicksort_part ac x lts eqs (z # gts) zs =\n                                  sort (lts @ eqs @ (z # gts) @ x # zs) @\n                                  ac;\n        \\<lbrakk>\\<not> x < z; z < x; \\<forall>y\\<in>set (z # lts). y < x;\n         \\<forall>y\\<in>set eqs. y = x; Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x (z # lts) eqs gts zs =\n                          sort ((z # lts) @ eqs @ gts @ x # zs) @ ac;\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; \\<forall>y\\<in>set lts. y < x;\n         \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x lts (z # eqs) gts zs =\n                          sort (lts @ (z # eqs) @ gts @ x # zs) @ ac;\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> quicksort_part ac x lts eqs gts (z # zs) =\n                         sort (lts @ eqs @ gts @ x # z # zs) @ ac", "}"], ["proof (state)\nthis:\n  \\<forall>y\\<in>set ?eqsb2. y = x \\<Longrightarrow>\n  insort x ?eqsb2 = x # ?eqsb2\n\ngoal (2 subgoals):\n 1. \\<And>ac x lts eqs gts.\n       \\<lbrakk>quicksort_acc ac gts = sort gts @ ac;\n        quicksort_acc (eqs @ x # quicksort_acc ac gts) lts =\n        sort lts @ eqs @ x # quicksort_acc ac gts;\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> quicksort_part ac x lts eqs gts [] =\n                         sort (lts @ eqs @ gts @ [x]) @ ac\n 2. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> quicksort_part ac x lts eqs (z # gts) zs =\n                                  sort (lts @ eqs @ (z # gts) @ x # zs) @\n                                  ac;\n        \\<lbrakk>\\<not> x < z; z < x; \\<forall>y\\<in>set (z # lts). y < x;\n         \\<forall>y\\<in>set eqs. y = x; Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x (z # lts) eqs gts zs =\n                          sort ((z # lts) @ eqs @ gts @ x # zs) @ ac;\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; \\<forall>y\\<in>set lts. y < x;\n         \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x lts (z # eqs) gts zs =\n                          sort (lts @ (z # eqs) @ gts @ x # zs) @ ac;\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> quicksort_part ac x lts eqs gts (z # zs) =\n                         sort (lts @ eqs @ gts @ x # z # zs) @ ac", "note [simp] = this"], ["proof (state)\nthis:\n  \\<forall>y\\<in>set ?eqsb2. y = x \\<Longrightarrow>\n  insort x ?eqsb2 = x # ?eqsb2\n\ngoal (2 subgoals):\n 1. \\<And>ac x lts eqs gts.\n       \\<lbrakk>quicksort_acc ac gts = sort gts @ ac;\n        quicksort_acc (eqs @ x # quicksort_acc ac gts) lts =\n        sort lts @ eqs @ x # quicksort_acc ac gts;\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> quicksort_part ac x lts eqs gts [] =\n                         sort (lts @ eqs @ gts @ [x]) @ ac\n 2. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> quicksort_part ac x lts eqs (z # gts) zs =\n                                  sort (lts @ eqs @ (z # gts) @ x # zs) @\n                                  ac;\n        \\<lbrakk>\\<not> x < z; z < x; \\<forall>y\\<in>set (z # lts). y < x;\n         \\<forall>y\\<in>set eqs. y = x; Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x (z # lts) eqs gts zs =\n                          sort ((z # lts) @ eqs @ gts @ x # zs) @ ac;\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; \\<forall>y\\<in>set lts. y < x;\n         \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x lts (z # eqs) gts zs =\n                          sort (lts @ (z # eqs) @ gts @ x # zs) @ ac;\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> quicksort_part ac x lts eqs gts (z # zs) =\n                         sort (lts @ eqs @ gts @ x # z # zs) @ ac", "from eqs"], ["proof (chain)\npicking this:\n  \\<forall>y\\<in>set eqs. y = x", "have [simp]: \"sort eqs = eqs\""], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>set eqs. y = x\n\ngoal (1 subgoal):\n 1. sort eqs = eqs", "by(induct eqs) simp_all"], ["proof (state)\nthis:\n  sort eqs = eqs\n\ngoal (2 subgoals):\n 1. \\<And>ac x lts eqs gts.\n       \\<lbrakk>quicksort_acc ac gts = sort gts @ ac;\n        quicksort_acc (eqs @ x # quicksort_acc ac gts) lts =\n        sort lts @ eqs @ x # quicksort_acc ac gts;\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> quicksort_part ac x lts eqs gts [] =\n                         sort (lts @ eqs @ gts @ [x]) @ ac\n 2. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> quicksort_part ac x lts eqs (z # gts) zs =\n                                  sort (lts @ eqs @ (z # gts) @ x # zs) @\n                                  ac;\n        \\<lbrakk>\\<not> x < z; z < x; \\<forall>y\\<in>set (z # lts). y < x;\n         \\<forall>y\\<in>set eqs. y = x; Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x (z # lts) eqs gts zs =\n                          sort ((z # lts) @ eqs @ gts @ x # zs) @ ac;\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; \\<forall>y\\<in>set lts. y < x;\n         \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x lts (z # eqs) gts zs =\n                          sort (lts @ (z # eqs) @ gts @ x # zs) @ ac;\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> quicksort_part ac x lts eqs gts (z # zs) =\n                         sort (lts @ eqs @ gts @ x # z # zs) @ ac", "from eqs"], ["proof (chain)\npicking this:\n  \\<forall>y\\<in>set eqs. y = x", "have [simp]: \"eqs @ [x] = x # eqs\""], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>set eqs. y = x\n\ngoal (1 subgoal):\n 1. eqs @ [x] = x # eqs", "by(induct eqs) simp_all"], ["proof (state)\nthis:\n  eqs @ [x] = x # eqs\n\ngoal (2 subgoals):\n 1. \\<And>ac x lts eqs gts.\n       \\<lbrakk>quicksort_acc ac gts = sort gts @ ac;\n        quicksort_acc (eqs @ x # quicksort_acc ac gts) lts =\n        sort lts @ eqs @ x # quicksort_acc ac gts;\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> quicksort_part ac x lts eqs gts [] =\n                         sort (lts @ eqs @ gts @ [x]) @ ac\n 2. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> quicksort_part ac x lts eqs (z # gts) zs =\n                                  sort (lts @ eqs @ (z # gts) @ x # zs) @\n                                  ac;\n        \\<lbrakk>\\<not> x < z; z < x; \\<forall>y\\<in>set (z # lts). y < x;\n         \\<forall>y\\<in>set eqs. y = x; Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x (z # lts) eqs gts zs =\n                          sort ((z # lts) @ eqs @ gts @ x # zs) @ ac;\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; \\<forall>y\\<in>set lts. y < x;\n         \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x lts (z # eqs) gts zs =\n                          sort (lts @ (z # eqs) @ gts @ x # zs) @ ac;\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> quicksort_part ac x lts eqs gts (z # zs) =\n                         sort (lts @ eqs @ gts @ x # z # zs) @ ac", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. quicksort_part ac x lts eqs gts [] = sort (lts @ eqs @ gts @ [x]) @ ac", "using 4"], ["proof (prove)\nusing this:\n  quicksort_acc ac gts = sort gts @ ac\n  quicksort_acc (eqs @ x # quicksort_acc ac gts) lts =\n  sort lts @ eqs @ x # quicksort_acc ac gts\n  \\<forall>y\\<in>set lts. y < x\n  \\<forall>y\\<in>set eqs. y = x\n  \\<forall>a\\<in>set gts. x < a\n\ngoal (1 subgoal):\n 1. quicksort_part ac x lts eqs gts [] = sort (lts @ eqs @ gts @ [x]) @ ac", "apply(subst sort_key_append)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>quicksort_acc ac gts = sort gts @ ac;\n     quicksort_acc (eqs @ x # quicksort_acc ac gts) lts =\n     sort lts @ eqs @ x # quicksort_acc ac gts;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>a\\<in>set gts. x < a\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set lts.\n                         Ball (set (eqs @ gts @ [x])) ((<) x)\n 2. \\<lbrakk>quicksort_acc ac gts = sort gts @ ac;\n     quicksort_acc (eqs @ x # quicksort_acc ac gts) lts =\n     sort lts @ eqs @ x # quicksort_acc ac gts;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>a\\<in>set gts. x < a\\<rbrakk>\n    \\<Longrightarrow> quicksort_part ac x lts eqs gts [] =\n                      (sort lts @ sort (eqs @ gts @ [x])) @ ac", "apply(auto 4 3 dest: bspec)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>quicksort_acc ac gts = sort gts @ ac;\n     quicksort_acc (eqs @ x # quicksort_acc ac gts) lts =\n     sort lts @ eqs @ x # quicksort_acc ac gts;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>a\\<in>set gts. x < a\\<rbrakk>\n    \\<Longrightarrow> quicksort_part ac x lts eqs gts [] =\n                      (sort lts @ sort (eqs @ gts @ [x])) @ ac", "apply(simp add: append_assoc[symmetric] sort_snoc del: append_assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>quicksort_acc ac gts = sort gts @ ac;\n     quicksort_acc (eqs @ x # sort gts @ ac) lts =\n     (sort lts @ eqs) @ x # sort gts @ ac;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>a\\<in>set gts. x < a\\<rbrakk>\n    \\<Longrightarrow> (sort lts @ eqs) @ x # sort gts =\n                      sort lts @ insort x (sort (eqs @ gts))", "apply(subst sort_key_append)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>quicksort_acc ac gts = sort gts @ ac;\n     quicksort_acc (eqs @ x # sort gts @ ac) lts =\n     (sort lts @ eqs) @ x # sort gts @ ac;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>a\\<in>set gts. x < a\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set eqs. Ball (set gts) ((<) x)\n 2. \\<lbrakk>quicksort_acc ac gts = sort gts @ ac;\n     quicksort_acc (eqs @ x # sort gts @ ac) lts =\n     (sort lts @ eqs) @ x # sort gts @ ac;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>a\\<in>set gts. x < a\\<rbrakk>\n    \\<Longrightarrow> (sort lts @ eqs) @ x # sort gts =\n                      sort lts @ insort x (sort eqs @ sort gts)", "apply(auto 4 3 simp add: insort_key_append1 dest: bspec)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  quicksort_part ac x lts eqs gts [] = sort (lts @ eqs @ gts @ [x]) @ ac\n\ngoal (1 subgoal):\n 1. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> quicksort_part ac x lts eqs (z # gts) zs =\n                                  sort (lts @ eqs @ (z # gts) @ x # zs) @\n                                  ac;\n        \\<lbrakk>\\<not> x < z; z < x; \\<forall>y\\<in>set (z # lts). y < x;\n         \\<forall>y\\<in>set eqs. y = x; Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x (z # lts) eqs gts zs =\n                          sort ((z # lts) @ eqs @ gts @ x # zs) @ ac;\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; \\<forall>y\\<in>set lts. y < x;\n         \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x lts (z # eqs) gts zs =\n                          sort (lts @ (z # eqs) @ gts @ x # zs) @ ac;\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> quicksort_part ac x lts eqs gts (z # zs) =\n                         sort (lts @ eqs @ gts @ x # z # zs) @ ac", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> quicksort_part ac x lts eqs (z # gts) zs =\n                                  sort (lts @ eqs @ (z # gts) @ x # zs) @\n                                  ac;\n        \\<lbrakk>\\<not> x < z; z < x; \\<forall>y\\<in>set (z # lts). y < x;\n         \\<forall>y\\<in>set eqs. y = x; Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x (z # lts) eqs gts zs =\n                          sort ((z # lts) @ eqs @ gts @ x # zs) @ ac;\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; \\<forall>y\\<in>set lts. y < x;\n         \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x lts (z # eqs) gts zs =\n                          sort (lts @ (z # eqs) @ gts @ x # zs) @ ac;\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> quicksort_part ac x lts eqs gts (z # zs) =\n                         sort (lts @ eqs @ gts @ x # z # zs) @ ac", "case (5 ac x lts eqs gts z zs)"], ["proof (state)\nthis:\n  \\<lbrakk>x < z; \\<forall>y\\<in>set lts. y < x;\n   \\<forall>y\\<in>set eqs. y = x;\n   \\<forall>a\\<in>set (z # gts). x < a\\<rbrakk>\n  \\<Longrightarrow> quicksort_part ac x lts eqs (z # gts) zs =\n                    sort (lts @ eqs @ (z # gts) @ x # zs) @ ac\n  \\<lbrakk>\\<not> x < z; z < x; \\<forall>y\\<in>set (z # lts). y < x;\n   \\<forall>y\\<in>set eqs. y = x; \\<forall>a\\<in>set gts. x < a\\<rbrakk>\n  \\<Longrightarrow> quicksort_part ac x (z # lts) eqs gts zs =\n                    sort ((z # lts) @ eqs @ gts @ x # zs) @ ac\n  \\<lbrakk>\\<not> x < z; \\<not> z < x; \\<forall>y\\<in>set lts. y < x;\n   \\<forall>y\\<in>set (z # eqs). y = x;\n   \\<forall>a\\<in>set gts. x < a\\<rbrakk>\n  \\<Longrightarrow> quicksort_part ac x lts (z # eqs) gts zs =\n                    sort (lts @ (z # eqs) @ gts @ x # zs) @ ac\n  \\<forall>y\\<in>set lts. y < x\n  \\<forall>y\\<in>set eqs. y = x\n  \\<forall>a\\<in>set gts. x < a\n\ngoal (1 subgoal):\n 1. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> quicksort_part ac x lts eqs (z # gts) zs =\n                                  sort (lts @ eqs @ (z # gts) @ x # zs) @\n                                  ac;\n        \\<lbrakk>\\<not> x < z; z < x; \\<forall>y\\<in>set (z # lts). y < x;\n         \\<forall>y\\<in>set eqs. y = x; Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x (z # lts) eqs gts zs =\n                          sort ((z # lts) @ eqs @ gts @ x # zs) @ ac;\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; \\<forall>y\\<in>set lts. y < x;\n         \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x lts (z # eqs) gts zs =\n                          sort (lts @ (z # eqs) @ gts @ x # zs) @ ac;\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> quicksort_part ac x lts eqs gts (z # zs) =\n                         sort (lts @ eqs @ gts @ x # z # zs) @ ac", "have \"\\<lbrakk> \\<not> z < x; \\<not> x < z \\<rbrakk> \\<Longrightarrow> z = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> z < x; \\<not> x < z\\<rbrakk> \\<Longrightarrow> z = x", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> z < x; \\<not> x < z\\<rbrakk> \\<Longrightarrow> z = x\n\ngoal (1 subgoal):\n 1. \\<And>ac x lts eqs gts z zs.\n       \\<lbrakk>\\<lbrakk>x < z; \\<forall>y\\<in>set lts. y < x;\n                 \\<forall>y\\<in>set eqs. y = x;\n                 Ball (set (z # gts)) ((<) x)\\<rbrakk>\n                \\<Longrightarrow> quicksort_part ac x lts eqs (z # gts) zs =\n                                  sort (lts @ eqs @ (z # gts) @ x # zs) @\n                                  ac;\n        \\<lbrakk>\\<not> x < z; z < x; \\<forall>y\\<in>set (z # lts). y < x;\n         \\<forall>y\\<in>set eqs. y = x; Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x (z # lts) eqs gts zs =\n                          sort ((z # lts) @ eqs @ gts @ x # zs) @ ac;\n        \\<lbrakk>\\<not> x < z; \\<not> z < x; \\<forall>y\\<in>set lts. y < x;\n         \\<forall>y\\<in>set (z # eqs). y = x;\n         Ball (set gts) ((<) x)\\<rbrakk>\n        \\<Longrightarrow> quicksort_part ac x lts (z # eqs) gts zs =\n                          sort (lts @ (z # eqs) @ gts @ x # zs) @ ac;\n        \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n        Ball (set gts) ((<) x)\\<rbrakk>\n       \\<Longrightarrow> quicksort_part ac x lts eqs gts (z # zs) =\n                         sort (lts @ eqs @ gts @ x # z # zs) @ ac", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> z < x; \\<not> x < z\\<rbrakk> \\<Longrightarrow> z = x\n\ngoal (1 subgoal):\n 1. quicksort_part ac x lts eqs gts (z # zs) =\n    sort (lts @ eqs @ gts @ x # z # zs) @ ac", "using 5"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> z < x; \\<not> x < z\\<rbrakk> \\<Longrightarrow> z = x\n  \\<lbrakk>x < z; \\<forall>y\\<in>set lts. y < x;\n   \\<forall>y\\<in>set eqs. y = x;\n   \\<forall>a\\<in>set (z # gts). x < a\\<rbrakk>\n  \\<Longrightarrow> quicksort_part ac x lts eqs (z # gts) zs =\n                    sort (lts @ eqs @ (z # gts) @ x # zs) @ ac\n  \\<lbrakk>\\<not> x < z; z < x; \\<forall>y\\<in>set (z # lts). y < x;\n   \\<forall>y\\<in>set eqs. y = x; \\<forall>a\\<in>set gts. x < a\\<rbrakk>\n  \\<Longrightarrow> quicksort_part ac x (z # lts) eqs gts zs =\n                    sort ((z # lts) @ eqs @ gts @ x # zs) @ ac\n  \\<lbrakk>\\<not> x < z; \\<not> z < x; \\<forall>y\\<in>set lts. y < x;\n   \\<forall>y\\<in>set (z # eqs). y = x;\n   \\<forall>a\\<in>set gts. x < a\\<rbrakk>\n  \\<Longrightarrow> quicksort_part ac x lts (z # eqs) gts zs =\n                    sort (lts @ (z # eqs) @ gts @ x # zs) @ ac\n  \\<forall>y\\<in>set lts. y < x\n  \\<forall>y\\<in>set eqs. y = x\n  \\<forall>a\\<in>set gts. x < a\n\ngoal (1 subgoal):\n 1. quicksort_part ac x lts eqs gts (z # zs) =\n    sort (lts @ eqs @ gts @ x # z # zs) @ ac", "apply(simp del: sort_key_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>\\<not> z < x; \\<not> x < z\\<rbrakk>\n             \\<Longrightarrow> z = x;\n     x < z \\<Longrightarrow>\n     quicksort_part ac x lts eqs (z # gts) zs =\n     sort (lts @ eqs @ z # gts @ x # zs) @ ac;\n     \\<lbrakk>\\<not> x < z; z < x\\<rbrakk>\n     \\<Longrightarrow> quicksort_part ac x (z # lts) eqs gts zs =\n                       sort (z # lts @ eqs @ gts @ x # zs) @ ac;\n     \\<lbrakk>\\<not> x < z; \\<not> z < x\\<rbrakk>\n     \\<Longrightarrow> quicksort_part ac x lts (z # eqs) gts zs =\n                       sort (lts @ z # eqs @ gts @ x # zs) @ ac;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>a\\<in>set gts. x < a\\<rbrakk>\n    \\<Longrightarrow> (z < x \\<longrightarrow>\n                       (x < z \\<longrightarrow>\n                        sort (lts @ eqs @ z # gts @ x # zs) =\n                        sort (lts @ eqs @ gts @ x # z # zs)) \\<and>\n                       (\\<not> x < z \\<longrightarrow>\n                        sort (z # lts @ eqs @ gts @ x # zs) =\n                        sort (lts @ eqs @ gts @ x # z # zs))) \\<and>\n                      (\\<not> z < x \\<longrightarrow>\n                       (x < z \\<longrightarrow>\n                        sort (lts @ eqs @ z # gts @ x # zs) =\n                        sort (lts @ eqs @ gts @ x # z # zs)) \\<and>\n                       (\\<not> x < z \\<longrightarrow>\n                        sort (lts @ z # eqs @ gts @ x # zs) =\n                        sort (lts @ eqs @ gts @ x # z # zs)))", "apply(safe, simp_all del: sort_key_simps add: to_single_list)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>quicksort_part ac x (single_list z @ lts) eqs gts zs =\n             sort (single_list z @ lts @ eqs @ gts @ single_list x @ zs) @\n             ac;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>x\\<in>set gts. x < x; z < x; \\<not> x < z\\<rbrakk>\n    \\<Longrightarrow> sort\n                       (single_list z @\n                        lts @ eqs @ gts @ single_list x @ zs) =\n                      sort\n                       (lts @\n                        eqs @ gts @ single_list x @ single_list z @ zs)\n 2. \\<lbrakk>quicksort_part ac x lts eqs (single_list z @ gts) zs =\n             sort (lts @ eqs @ single_list z @ gts @ single_list x @ zs) @\n             ac;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>x\\<in>set gts. x < x; \\<not> z < x; x < z\\<rbrakk>\n    \\<Longrightarrow> sort\n                       (lts @\n                        eqs @ single_list z @ gts @ single_list x @ zs) =\n                      sort\n                       (lts @\n                        eqs @ gts @ single_list x @ single_list z @ zs)\n 3. \\<lbrakk>z = x;\n     quicksort_part ac x lts (single_list x @ eqs) gts zs =\n     sort (lts @ single_list x @ eqs @ gts @ single_list x @ zs) @ ac;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>x\\<in>set gts. x < x\\<rbrakk>\n    \\<Longrightarrow> sort\n                       (lts @\n                        single_list x @ eqs @ gts @ single_list x @ zs) =\n                      sort\n                       (lts @\n                        eqs @ gts @ single_list x @ single_list x @ zs)", "apply(subst sort_append_swap)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>quicksort_part ac x (single_list z @ lts) eqs gts zs =\n             sort (single_list z @ lts @ eqs @ gts @ single_list x @ zs) @\n             ac;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>x\\<in>set gts. x < x; z < x; \\<not> x < z\\<rbrakk>\n    \\<Longrightarrow> sort\n                       ((lts @ eqs @ gts @ single_list x @ zs) @\n                        single_list z) =\n                      sort\n                       (lts @\n                        eqs @ gts @ single_list x @ single_list z @ zs)\n 2. \\<lbrakk>quicksort_part ac x lts eqs (single_list z @ gts) zs =\n             sort (lts @ eqs @ single_list z @ gts @ single_list x @ zs) @\n             ac;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>x\\<in>set gts. x < x; \\<not> z < x; x < z\\<rbrakk>\n    \\<Longrightarrow> sort\n                       (lts @\n                        eqs @ single_list z @ gts @ single_list x @ zs) =\n                      sort\n                       (lts @\n                        eqs @ gts @ single_list x @ single_list z @ zs)\n 3. \\<lbrakk>z = x;\n     quicksort_part ac x lts (single_list x @ eqs) gts zs =\n     sort (lts @ single_list x @ eqs @ gts @ single_list x @ zs) @ ac;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>x\\<in>set gts. x < x\\<rbrakk>\n    \\<Longrightarrow> sort\n                       (lts @\n                        single_list x @ eqs @ gts @ single_list x @ zs) =\n                      sort\n                       (lts @\n                        eqs @ gts @ single_list x @ single_list x @ zs)", "apply(fold append_assoc)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>quicksort_part ac x (single_list z @ lts) eqs gts zs =\n             sort\n              (((((single_list z @ lts) @ eqs) @ gts) @ single_list x) @\n               zs) @\n             ac;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>x\\<in>set gts. x < x; z < x; \\<not> x < z\\<rbrakk>\n    \\<Longrightarrow> sort\n                       (((((lts @ eqs) @ gts) @ single_list x) @ zs) @\n                        single_list z) =\n                      sort\n                       (((((lts @ eqs) @ gts) @ single_list x) @\n                         single_list z) @\n                        zs)\n 2. \\<lbrakk>quicksort_part ac x lts eqs (single_list z @ gts) zs =\n             sort\n              (((((lts @ eqs) @ single_list z) @ gts) @ single_list x) @\n               zs) @\n             ac;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>x\\<in>set gts. x < x; \\<not> z < x; x < z\\<rbrakk>\n    \\<Longrightarrow> sort\n                       (((((lts @ eqs) @ single_list z) @ gts) @\n                         single_list x) @\n                        zs) =\n                      sort\n                       (((((lts @ eqs) @ gts) @ single_list x) @\n                         single_list z) @\n                        zs)\n 3. \\<lbrakk>z = x;\n     quicksort_part ac x lts (single_list x @ eqs) gts zs =\n     sort (((((lts @ single_list x) @ eqs) @ gts) @ single_list x) @ zs) @\n     ac;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>x\\<in>set gts. x < x\\<rbrakk>\n    \\<Longrightarrow> sort\n                       (((((lts @ single_list x) @ eqs) @ gts) @\n                         single_list x) @\n                        zs) =\n                      sort\n                       (((((lts @ eqs) @ gts) @ single_list x) @\n                         single_list x) @\n                        zs)", "apply(subst (2) sort_append_swap)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>quicksort_part ac x (single_list z @ lts) eqs gts zs =\n             sort\n              (((((single_list z @ lts) @ eqs) @ gts) @ single_list x) @\n               zs) @\n             ac;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>x\\<in>set gts. x < x; z < x; \\<not> x < z\\<rbrakk>\n    \\<Longrightarrow> sort\n                       (((((lts @ eqs) @ gts) @ single_list x) @ zs) @\n                        single_list z) =\n                      sort\n                       (zs @\n                        (((lts @ eqs) @ gts) @ single_list x) @\n                        single_list z)\n 2. \\<lbrakk>quicksort_part ac x lts eqs (single_list z @ gts) zs =\n             sort\n              (((((lts @ eqs) @ single_list z) @ gts) @ single_list x) @\n               zs) @\n             ac;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>x\\<in>set gts. x < x; \\<not> z < x; x < z\\<rbrakk>\n    \\<Longrightarrow> sort\n                       (((((lts @ eqs) @ single_list z) @ gts) @\n                         single_list x) @\n                        zs) =\n                      sort\n                       (((((lts @ eqs) @ gts) @ single_list x) @\n                         single_list z) @\n                        zs)\n 3. \\<lbrakk>z = x;\n     quicksort_part ac x lts (single_list x @ eqs) gts zs =\n     sort (((((lts @ single_list x) @ eqs) @ gts) @ single_list x) @ zs) @\n     ac;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>x\\<in>set gts. x < x\\<rbrakk>\n    \\<Longrightarrow> sort\n                       (((((lts @ single_list x) @ eqs) @ gts) @\n                         single_list x) @\n                        zs) =\n                      sort\n                       (((((lts @ eqs) @ gts) @ single_list x) @\n                         single_list x) @\n                        zs)", "apply(subst sort_append_swap2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>quicksort_part ac x (single_list z @ lts) eqs gts zs =\n             sort\n              (((((single_list z @ lts) @ eqs) @ gts) @ single_list x) @\n               zs) @\n             ac;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>x\\<in>set gts. x < x; z < x; \\<not> x < z\\<rbrakk>\n    \\<Longrightarrow> sort\n                       (((((lts @ eqs) @ gts) @ single_list x) @ zs) @\n                        single_list z) =\n                      sort\n                       ((((lts @ eqs) @ gts) @ single_list x) @\n                        zs @ single_list z)\n 2. \\<lbrakk>quicksort_part ac x lts eqs (single_list z @ gts) zs =\n             sort\n              (((((lts @ eqs) @ single_list z) @ gts) @ single_list x) @\n               zs) @\n             ac;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>x\\<in>set gts. x < x; \\<not> z < x; x < z\\<rbrakk>\n    \\<Longrightarrow> sort\n                       (((((lts @ eqs) @ single_list z) @ gts) @\n                         single_list x) @\n                        zs) =\n                      sort\n                       (((((lts @ eqs) @ gts) @ single_list x) @\n                         single_list z) @\n                        zs)\n 3. \\<lbrakk>z = x;\n     quicksort_part ac x lts (single_list x @ eqs) gts zs =\n     sort (((((lts @ single_list x) @ eqs) @ gts) @ single_list x) @ zs) @\n     ac;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>x\\<in>set gts. x < x\\<rbrakk>\n    \\<Longrightarrow> sort\n                       (((((lts @ single_list x) @ eqs) @ gts) @\n                         single_list x) @\n                        zs) =\n                      sort\n                       (((((lts @ eqs) @ gts) @ single_list x) @\n                         single_list x) @\n                        zs)", "apply(unfold append_assoc)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>quicksort_part ac x (single_list z @ lts) eqs gts zs =\n             sort (single_list z @ lts @ eqs @ gts @ single_list x @ zs) @\n             ac;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>x\\<in>set gts. x < x; z < x; \\<not> x < z\\<rbrakk>\n    \\<Longrightarrow> sort\n                       (lts @\n                        eqs @ gts @ single_list x @ zs @ single_list z) =\n                      sort\n                       (lts @\n                        eqs @ gts @ single_list x @ zs @ single_list z)\n 2. \\<lbrakk>quicksort_part ac x lts eqs (single_list z @ gts) zs =\n             sort (lts @ eqs @ single_list z @ gts @ single_list x @ zs) @\n             ac;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>x\\<in>set gts. x < x; \\<not> z < x; x < z\\<rbrakk>\n    \\<Longrightarrow> sort\n                       (lts @\n                        eqs @ single_list z @ gts @ single_list x @ zs) =\n                      sort\n                       (lts @\n                        eqs @ gts @ single_list x @ single_list z @ zs)\n 3. \\<lbrakk>z = x;\n     quicksort_part ac x lts (single_list x @ eqs) gts zs =\n     sort (lts @ single_list x @ eqs @ gts @ single_list x @ zs) @ ac;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>x\\<in>set gts. x < x\\<rbrakk>\n    \\<Longrightarrow> sort\n                       (lts @\n                        single_list x @ eqs @ gts @ single_list x @ zs) =\n                      sort\n                       (lts @\n                        eqs @ gts @ single_list x @ single_list x @ zs)", "apply(rule refl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>quicksort_part ac x lts eqs (single_list z @ gts) zs =\n             sort (lts @ eqs @ single_list z @ gts @ single_list x @ zs) @\n             ac;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>x\\<in>set gts. x < x; \\<not> z < x; x < z\\<rbrakk>\n    \\<Longrightarrow> sort\n                       (lts @\n                        eqs @ single_list z @ gts @ single_list x @ zs) =\n                      sort\n                       (lts @\n                        eqs @ gts @ single_list x @ single_list z @ zs)\n 2. \\<lbrakk>z = x;\n     quicksort_part ac x lts (single_list x @ eqs) gts zs =\n     sort (lts @ single_list x @ eqs @ gts @ single_list x @ zs) @ ac;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>x\\<in>set gts. x < x\\<rbrakk>\n    \\<Longrightarrow> sort\n                       (lts @\n                        single_list x @ eqs @ gts @ single_list x @ zs) =\n                      sort\n                       (lts @\n                        eqs @ gts @ single_list x @ single_list x @ zs)", "apply(subst (1 5) append_assoc[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>quicksort_part ac x lts eqs (single_list z @ gts) zs =\n             sort (lts @ eqs @ single_list z @ gts @ single_list x @ zs) @\n             ac;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>x\\<in>set gts. x < x; \\<not> z < x; x < z\\<rbrakk>\n    \\<Longrightarrow> sort\n                       ((lts @ eqs) @\n                        single_list z @ gts @ single_list x @ zs) =\n                      sort\n                       ((lts @ eqs) @\n                        gts @ single_list x @ single_list z @ zs)\n 2. \\<lbrakk>z = x;\n     quicksort_part ac x lts (single_list x @ eqs) gts zs =\n     sort (lts @ single_list x @ eqs @ gts @ single_list x @ zs) @ ac;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>x\\<in>set gts. x < x\\<rbrakk>\n    \\<Longrightarrow> sort\n                       (lts @\n                        single_list x @ eqs @ gts @ single_list x @ zs) =\n                      sort\n                       (lts @\n                        eqs @ gts @ single_list x @ single_list x @ zs)", "apply(subst (1 2) sort_append_swap)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>quicksort_part ac x lts eqs (single_list z @ gts) zs =\n             sort (lts @ eqs @ single_list z @ gts @ single_list x @ zs) @\n             ac;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>x\\<in>set gts. x < x; \\<not> z < x; x < z\\<rbrakk>\n    \\<Longrightarrow> sort\n                       ((single_list z @ gts @ single_list x @ zs) @\n                        lts @ eqs) =\n                      sort\n                       ((gts @ single_list x @ single_list z @ zs) @\n                        lts @ eqs)\n 2. \\<lbrakk>z = x;\n     quicksort_part ac x lts (single_list x @ eqs) gts zs =\n     sort (lts @ single_list x @ eqs @ gts @ single_list x @ zs) @ ac;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>x\\<in>set gts. x < x\\<rbrakk>\n    \\<Longrightarrow> sort\n                       (lts @\n                        single_list x @ eqs @ gts @ single_list x @ zs) =\n                      sort\n                       (lts @\n                        eqs @ gts @ single_list x @ single_list x @ zs)", "apply(unfold append_assoc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>quicksort_part ac x lts eqs (single_list z @ gts) zs =\n             sort (lts @ eqs @ single_list z @ gts @ single_list x @ zs) @\n             ac;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>x\\<in>set gts. x < x; \\<not> z < x; x < z\\<rbrakk>\n    \\<Longrightarrow> sort\n                       (single_list z @\n                        gts @ single_list x @ zs @ lts @ eqs) =\n                      sort\n                       (gts @\n                        single_list x @ single_list z @ zs @ lts @ eqs)\n 2. \\<lbrakk>z = x;\n     quicksort_part ac x lts (single_list x @ eqs) gts zs =\n     sort (lts @ single_list x @ eqs @ gts @ single_list x @ zs) @ ac;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>x\\<in>set gts. x < x\\<rbrakk>\n    \\<Longrightarrow> sort\n                       (lts @\n                        single_list x @ eqs @ gts @ single_list x @ zs) =\n                      sort\n                       (lts @\n                        eqs @ gts @ single_list x @ single_list x @ zs)", "apply(subst sort_append_swap2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>quicksort_part ac x lts eqs (single_list z @ gts) zs =\n             sort (lts @ eqs @ single_list z @ gts @ single_list x @ zs) @\n             ac;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>x\\<in>set gts. x < x; \\<not> z < x; x < z\\<rbrakk>\n    \\<Longrightarrow> sort\n                       (gts @\n                        single_list z @ single_list x @ zs @ lts @ eqs) =\n                      sort\n                       (gts @\n                        single_list x @ single_list z @ zs @ lts @ eqs)\n 2. \\<lbrakk>z = x;\n     quicksort_part ac x lts (single_list x @ eqs) gts zs =\n     sort (lts @ single_list x @ eqs @ gts @ single_list x @ zs) @ ac;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>x\\<in>set gts. x < x\\<rbrakk>\n    \\<Longrightarrow> sort\n                       (lts @\n                        single_list x @ eqs @ gts @ single_list x @ zs) =\n                      sort\n                       (lts @\n                        eqs @ gts @ single_list x @ single_list x @ zs)", "apply(subst (1 2) sort_append_swap)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>quicksort_part ac x lts eqs (single_list z @ gts) zs =\n             sort (lts @ eqs @ single_list z @ gts @ single_list x @ zs) @\n             ac;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>x\\<in>set gts. x < x; \\<not> z < x; x < z\\<rbrakk>\n    \\<Longrightarrow> sort\n                       ((single_list z @ single_list x @ zs @ lts @ eqs) @\n                        gts) =\n                      sort\n                       ((single_list x @ single_list z @ zs @ lts @ eqs) @\n                        gts)\n 2. \\<lbrakk>z = x;\n     quicksort_part ac x lts (single_list x @ eqs) gts zs =\n     sort (lts @ single_list x @ eqs @ gts @ single_list x @ zs) @ ac;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>x\\<in>set gts. x < x\\<rbrakk>\n    \\<Longrightarrow> sort\n                       (lts @\n                        single_list x @ eqs @ gts @ single_list x @ zs) =\n                      sort\n                       (lts @\n                        eqs @ gts @ single_list x @ single_list x @ zs)", "apply(unfold append_assoc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>quicksort_part ac x lts eqs (single_list z @ gts) zs =\n             sort (lts @ eqs @ single_list z @ gts @ single_list x @ zs) @\n             ac;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>x\\<in>set gts. x < x; \\<not> z < x; x < z\\<rbrakk>\n    \\<Longrightarrow> sort\n                       (single_list z @\n                        single_list x @ zs @ lts @ eqs @ gts) =\n                      sort\n                       (single_list x @\n                        single_list z @ zs @ lts @ eqs @ gts)\n 2. \\<lbrakk>z = x;\n     quicksort_part ac x lts (single_list x @ eqs) gts zs =\n     sort (lts @ single_list x @ eqs @ gts @ single_list x @ zs) @ ac;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>x\\<in>set gts. x < x\\<rbrakk>\n    \\<Longrightarrow> sort\n                       (lts @\n                        single_list x @ eqs @ gts @ single_list x @ zs) =\n                      sort\n                       (lts @\n                        eqs @ gts @ single_list x @ single_list x @ zs)", "apply(subst sort_append_swap2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>quicksort_part ac x lts eqs (single_list z @ gts) zs =\n             sort (lts @ eqs @ single_list z @ gts @ single_list x @ zs) @\n             ac;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>x\\<in>set gts. x < x; \\<not> z < x; x < z\\<rbrakk>\n    \\<Longrightarrow> sort\n                       (single_list x @\n                        single_list z @ zs @ lts @ eqs @ gts) =\n                      sort\n                       (single_list x @\n                        single_list z @ zs @ lts @ eqs @ gts)\n 2. \\<lbrakk>z = x;\n     quicksort_part ac x lts (single_list x @ eqs) gts zs =\n     sort (lts @ single_list x @ eqs @ gts @ single_list x @ zs) @ ac;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>x\\<in>set gts. x < x\\<rbrakk>\n    \\<Longrightarrow> sort\n                       (lts @\n                        single_list x @ eqs @ gts @ single_list x @ zs) =\n                      sort\n                       (lts @\n                        eqs @ gts @ single_list x @ single_list x @ zs)", "apply(rule refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>z = x;\n     quicksort_part ac x lts (single_list x @ eqs) gts zs =\n     sort (lts @ single_list x @ eqs @ gts @ single_list x @ zs) @ ac;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>x\\<in>set gts. x < x\\<rbrakk>\n    \\<Longrightarrow> sort\n                       (lts @\n                        single_list x @ eqs @ gts @ single_list x @ zs) =\n                      sort\n                       (lts @\n                        eqs @ gts @ single_list x @ single_list x @ zs)", "apply(subst (2 6) append_assoc[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>z = x;\n     quicksort_part ac x lts (single_list x @ eqs) gts zs =\n     sort (lts @ single_list x @ eqs @ gts @ single_list x @ zs) @ ac;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>x\\<in>set gts. x < x\\<rbrakk>\n    \\<Longrightarrow> sort\n                       (lts @\n                        (single_list x @ eqs) @ gts @ single_list x @ zs) =\n                      sort\n                       (lts @\n                        (eqs @ gts) @ single_list x @ single_list x @ zs)", "apply(subst (2 5) append_assoc[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>z = x;\n     quicksort_part ac x lts (single_list x @ eqs) gts zs =\n     sort (lts @ single_list x @ eqs @ gts @ single_list x @ zs) @ ac;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>x\\<in>set gts. x < x\\<rbrakk>\n    \\<Longrightarrow> sort\n                       (lts @\n                        ((single_list x @ eqs) @ gts) @\n                        single_list x @ zs) =\n                      sort\n                       (lts @\n                        ((eqs @ gts) @ single_list x) @ single_list x @ zs)", "apply(subst (1 2) sort_append_swap2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>z = x;\n     quicksort_part ac x lts (single_list x @ eqs) gts zs =\n     sort (lts @ single_list x @ eqs @ gts @ single_list x @ zs) @ ac;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>x\\<in>set gts. x < x\\<rbrakk>\n    \\<Longrightarrow> sort\n                       (((single_list x @ eqs) @ gts) @\n                        lts @ single_list x @ zs) =\n                      sort\n                       (((eqs @ gts) @ single_list x) @\n                        lts @ single_list x @ zs)", "apply(subst (4) append_assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>z = x;\n     quicksort_part ac x lts (single_list x @ eqs) gts zs =\n     sort (lts @ single_list x @ eqs @ gts @ single_list x @ zs) @ ac;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>x\\<in>set gts. x < x\\<rbrakk>\n    \\<Longrightarrow> sort\n                       (((single_list x @ eqs) @ gts) @\n                        lts @ single_list x @ zs) =\n                      sort\n                       ((eqs @ gts) @\n                        single_list x @ lts @ single_list x @ zs)", "apply(subst (2) sort_append_swap2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>z = x;\n     quicksort_part ac x lts (single_list x @ eqs) gts zs =\n     sort (lts @ single_list x @ eqs @ gts @ single_list x @ zs) @ ac;\n     \\<forall>y\\<in>set lts. y < x; \\<forall>y\\<in>set eqs. y = x;\n     \\<forall>x\\<in>set gts. x < x\\<rbrakk>\n    \\<Longrightarrow> sort\n                       (((single_list x @ eqs) @ gts) @\n                        lts @ single_list x @ zs) =\n                      sort\n                       (single_list x @\n                        (eqs @ gts) @ lts @ single_list x @ zs)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  quicksort_part ac x lts eqs gts (z # zs) =\n  sort (lts @ eqs @ gts @ x # z # zs) @ ac\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma quicksort_conv_sort: \"quicksort xs = sort xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quicksort xs = sort xs", "by(simp add: quicksort_def quicksort_acc_conv_sort)"], ["", "lemma sort_remdups: \"sort (remdups xs) = remdups (sort xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sort (remdups xs) = remdups (sort xs)", "by(rule sorted_distinct_set_unique) simp_all"], ["", "end"], ["", "text \\<open>Removing duplicates from a sorted list\\<close>"], ["", "context ord begin"], ["", "fun remdups_sorted :: \"'a list \\<Rightarrow> 'a list\"\nwhere\n  \"remdups_sorted [] = []\"\n| \"remdups_sorted [x] = [x]\"\n| \"remdups_sorted (x#y#xs) = (if x < y then x # remdups_sorted (y#xs) else remdups_sorted (y#xs))\""], ["", "end"], ["", "lemmas [code] = ord.remdups_sorted.simps"], ["", "context linorder begin"], ["", "lemma [simp]:\n  assumes \"sorted xs\"\n  shows sorted_remdups_sorted: \"sorted (remdups_sorted xs)\"\n  and set_remdups_sorted: \"set (remdups_sorted xs) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (remdups_sorted xs) &&& set (remdups_sorted xs) = set xs", "using assms"], ["proof (prove)\nusing this:\n  sorted xs\n\ngoal (1 subgoal):\n 1. sorted (remdups_sorted xs) &&& set (remdups_sorted xs) = set xs", "by(induct xs rule: remdups_sorted.induct)(auto)"], ["", "lemma distinct_remdups_sorted [simp]: \"sorted xs \\<Longrightarrow> distinct (remdups_sorted xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted xs \\<Longrightarrow> distinct (remdups_sorted xs)", "by(induct xs rule: remdups_sorted.induct)(auto)"], ["", "lemma remdups_sorted_conv_remdups: \"sorted xs \\<Longrightarrow> remdups_sorted xs = remdups xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted xs \\<Longrightarrow> remdups_sorted xs = remdups xs", "by(induct xs rule: remdups_sorted.induct)(auto)"], ["", "end"], ["", "text \\<open>An specialised operation to convert a finite set into a sorted list\\<close>"], ["", "definition csorted_list_of_set :: \"'a :: ccompare set \\<Rightarrow> 'a list\"\nwhere [code del]: \n  \"csorted_list_of_set A = \n  (if ID CCOMPARE('a) = None \\<or> \\<not> finite A then undefined else linorder.sorted_list_of_set cless_eq A)\""], ["", "lemma csorted_list_of_set_set [simp]:\n  \"\\<lbrakk> ID CCOMPARE('a :: ccompare) = Some c; linorder.sorted (le_of_comp c) xs; distinct xs \\<rbrakk> \n  \\<Longrightarrow> linorder.sorted_list_of_set (le_of_comp c) (set xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ID ccompare = Some c; linorder.sorted (le_of_comp c) xs;\n     distinct xs\\<rbrakk>\n    \\<Longrightarrow> linorder.sorted_list_of_set (le_of_comp c) (set xs) =\n                      xs", "by(simp add: distinct_remdups_id linorder.sorted_list_of_set_sort_remdups[OF ID_ccompare] linorder.sorted_sort_id[OF ID_ccompare])"], ["", "lemma csorted_list_of_set_split:\n  fixes A :: \"'a :: ccompare set\" shows\n  \"P (csorted_list_of_set A) \\<longleftrightarrow> \n  (\\<forall>xs. ID CCOMPARE('a) \\<noteq> None \\<longrightarrow> finite A \\<longrightarrow> A = set xs \\<longrightarrow> distinct xs \\<longrightarrow> linorder.sorted cless_eq xs \\<longrightarrow> P xs) \\<and> \n  (ID CCOMPARE('a) = None \\<or> \\<not> finite A \\<longrightarrow> P undefined)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (csorted_list_of_set A) =\n    ((\\<forall>xs.\n         ID ccompare \\<noteq> None \\<longrightarrow>\n         finite A \\<longrightarrow>\n         A = set xs \\<longrightarrow>\n         distinct xs \\<longrightarrow>\n         linorder.sorted cless_eq xs \\<longrightarrow> P xs) \\<and>\n     (ID ccompare = None \\<or> infinite A \\<longrightarrow> P undefined))", "by(auto simp add: csorted_list_of_set_def linorder.sorted_list_of_set[OF ID_ccompare])"], ["", "code_identifier code_module Set \\<rightharpoonup> (SML) Set_Impl\n  | code_module Set_Impl \\<rightharpoonup> (SML) Set_Impl"], ["", "subsection \\<open>Delete code equation with set as constructor\\<close>"], ["", "lemma is_empty_unfold [code_unfold]:\n  \"set_eq A {} = Set.is_empty A\"\n  \"set_eq {} A = Set.is_empty A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_eq A {} = Set.is_empty A &&& set_eq {} A = Set.is_empty A", "by(auto simp add: Set.is_empty_def set_eq_def)"], ["", "definition is_UNIV :: \"'a set \\<Rightarrow> bool\"\nwhere [code del]: \"is_UNIV A \\<longleftrightarrow> A = UNIV\""], ["", "lemma is_UNIV_unfold [code_unfold]: \n  \"A = UNIV \\<longleftrightarrow> is_UNIV A\" \n  \"UNIV = A \\<longleftrightarrow> is_UNIV A\"\n  \"set_eq A UNIV \\<longleftrightarrow> is_UNIV A\"\n  \"set_eq UNIV A \\<longleftrightarrow> is_UNIV A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A = UNIV) = is_UNIV A &&& (UNIV = A) = is_UNIV A) &&&\n    set_eq A UNIV = is_UNIV A &&& set_eq UNIV A = is_UNIV A", "by(auto simp add: is_UNIV_def set_eq_def)"], ["", "lemma [code_unfold del, symmetric, code_post del]:\n  \"x \\<in> set xs \\<equiv> List.member xs x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<equiv> List.member xs x", "by(simp add: List.member_def)"], ["", "lemma [code_unfold del, symmetric, code_post del]:\n  \"finite \\<equiv> Cardinality.finite'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite \\<equiv> Cardinality.finite'", "by(simp)"], ["", "lemma [code_unfold del, symmetric, code_post del]:\n  \"card \\<equiv> Cardinality.card'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card \\<equiv> Cardinality.card'", "by simp"], ["", "declare [[code drop:\n  Set.empty\n  Set.is_empty\n  uminus_set_inst.uminus_set\n  Set.member\n  Set.insert\n  Set.remove\n  UNIV\n  Set.filter\n  image\n  Set.subset_eq\n  Ball\n  Bex\n  Set.union\n  minus_set_inst.minus_set\n  Set.inter\n  card\n  Set.bind\n  the_elem\n  Pow\n  sum\n  Gcd\n  Lcm\n  Product_Type.product\n  Id_on\n  Image\n  trancl\n  relcomp\n  wf\n  Min\n  Inf_fin\n  Max\n  Sup_fin\n  \"Inf :: 'a set set \\<Rightarrow> 'a set\"\n  \"Sup :: 'a set set \\<Rightarrow> 'a set\"\n  sorted_list_of_set\n  List.map_project\n  Sup_pred_inst.Sup_pred\n  finite\n  Cardinality.finite'\n  card\n  Cardinality.card'\n  Inf_pred_inst.Inf_pred\n  pred_of_set\n  Cardinality.subset'\n  Cardinality.eq_set\n  Wellfounded.acc\n  Bleast\n  can_select\n  \"set_eq :: 'a set \\<Rightarrow> 'a set \\<Rightarrow> bool\"\n  irrefl\n  bacc\n  set_of_pred\n  set_of_seq\n  ]]"], ["", "declare \n  Cardinality.finite'_def[code]\n  Cardinality.card'_def[code]"], ["", "subsection \\<open>Set implementations\\<close>"], ["", "definition Collect_set :: \"('a \\<Rightarrow> bool) \\<Rightarrow> 'a set\"\nwhere [simp]: \"Collect_set = Collect\""], ["", "definition DList_set :: \"'a :: ceq set_dlist \\<Rightarrow> 'a set\"\nwhere \"DList_set = Collect o DList_Set.member\""], ["", "definition RBT_set :: \"'a :: ccompare set_rbt \\<Rightarrow> 'a set\"\nwhere \"RBT_set = Collect o RBT_Set2.member\""], ["", "definition Complement :: \"'a set \\<Rightarrow> 'a set\"\nwhere [simp]: \"Complement A = - A\""], ["", "definition Set_Monad :: \"'a list \\<Rightarrow> 'a set\"\nwhere [simp]: \"Set_Monad = set\""], ["", "code_datatype Collect_set DList_set RBT_set Set_Monad Complement"], ["", "lemma DList_set_empty [simp]: \"DList_set DList_Set.empty = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DList_set DList_Set.empty = {}", "by(simp add: DList_set_def)"], ["", "lemma RBT_set_empty [simp]: \"RBT_set RBT_Set2.empty = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RBT_set RBT_Set2.empty = {}", "by(simp add: RBT_set_def)"], ["", "lemma RBT_set_conv_keys: \n  \"ID CCOMPARE('a :: ccompare) \\<noteq> None \n  \\<Longrightarrow> RBT_set (t :: 'a set_rbt) = set (RBT_Set2.keys t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ID ccompare \\<noteq> None \\<Longrightarrow>\n    RBT_set t = set (RBT_Set2.keys t)", "by(clarsimp simp add: RBT_set_def member_conv_keys)"], ["", "subsection \\<open>Set operations\\<close>"], ["", "text \\<open>\n  A collection of all the theorems about @{const Complement}.\n\\<close>"], ["", "ML \\<open>\nstructure Set_Complement_Eqs = Named_Thms\n(\n  val name = @{binding set_complement_code}\n  val description = \"Code equations involving set complement\"\n)\n\\<close>"], ["", "setup \\<open>Set_Complement_Eqs.setup\\<close>"], ["", "text \\<open>Various fold operations over sets\\<close>"], ["", "typedef ('a, 'b) comp_fun_commute = \"{f :: 'a \\<Rightarrow> 'b \\<Rightarrow> 'b. comp_fun_commute f}\"\n  morphisms comp_fun_commute_apply Abs_comp_fun_commute"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {f. comp_fun_commute f}", "by(rule exI[where x=\"\\<lambda>_. id\"])(simp, unfold_locales, auto)"], ["", "setup_lifting type_definition_comp_fun_commute"], ["", "lemma comp_fun_commute_apply' [simp]:\n  \"comp_fun_commute (comp_fun_commute_apply f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_commute (comp_fun_commute_apply f)", "using comp_fun_commute_apply[of f]"], ["proof (prove)\nusing this:\n  comp_fun_commute_apply f \\<in> {f. comp_fun_commute f}\n\ngoal (1 subgoal):\n 1. comp_fun_commute (comp_fun_commute_apply f)", "by simp"], ["", "lift_definition set_fold_cfc :: \"('a, 'b) comp_fun_commute \\<Rightarrow> 'b \\<Rightarrow> 'a set \\<Rightarrow> 'b\" is \"Finite_Set.fold\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "declare [[code drop: set_fold_cfc]]"], ["", "lemma set_fold_cfc_code [code]:\n  fixes xs :: \"'a :: ceq list\" \n  and dxs :: \"'a :: ceq set_dlist\"\n  and rbt :: \"'b :: ccompare set_rbt\"\n  shows set_fold_cfc_Complement[set_complement_code]:\n  \"set_fold_cfc f''' b (Complement A) = Code.abort (STR ''set_fold_cfc not supported on Complement'') (\\<lambda>_. set_fold_cfc f''' b (Complement A))\"\n  and\n  \"set_fold_cfc f''' b (Collect_set P) = Code.abort (STR ''set_fold_cfc not supported on Collect_set'') (\\<lambda>_. set_fold_cfc f''' b (Collect_set P))\"\n  \"set_fold_cfc f b (Set_Monad xs) =\n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''set_fold_cfc Set_Monad: ceq = None'') (\\<lambda>_. set_fold_cfc f b (Set_Monad xs))\n                 | Some eq \\<Rightarrow> List.fold (comp_fun_commute_apply f) (equal_base.list_remdups eq xs) b)\"\n  (is ?Set_Monad)\n  \"set_fold_cfc f' b (DList_set dxs) =\n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''set_fold_cfc DList_set: ceq = None'') (\\<lambda>_. set_fold_cfc f' b (DList_set dxs))\n                  | Some _ \\<Rightarrow> DList_Set.fold (comp_fun_commute_apply f') dxs b)\"\n  (is ?DList_set)\n  \"set_fold_cfc f'' b (RBT_set rbt) =\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''set_fold_cfc RBT_set: ccompare = None'') (\\<lambda>_. set_fold_cfc f'' b (RBT_set rbt))\n                     | Some _ \\<Rightarrow> RBT_Set2.fold (comp_fun_commute_apply f'') rbt b)\"\n  (is ?RBT_set)"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_fold_cfc f''' b (Complement A) =\n    Code.abort STR ''set_fold_cfc not supported on Complement''\n     (\\<lambda>_. set_fold_cfc f''' b (Complement A)) &&&\n    (set_fold_cfc f''' b (Collect_set P) =\n     Code.abort STR ''set_fold_cfc not supported on Collect_set''\n      (\\<lambda>_. set_fold_cfc f''' b (Collect_set P)) &&&\n     set_fold_cfc f b (Set_Monad xs) =\n     (case ID CEQ('a) of\n      None \\<Rightarrow>\n        Code.abort STR ''set_fold_cfc Set_Monad: ceq = None''\n         (\\<lambda>_. set_fold_cfc f b (Set_Monad xs))\n      | Some eq \\<Rightarrow>\n          fold (comp_fun_commute_apply f) (equal_base.list_remdups eq xs)\n           b)) &&&\n    set_fold_cfc f' b (DList_set dxs) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''set_fold_cfc DList_set: ceq = None''\n        (\\<lambda>_. set_fold_cfc f' b (DList_set dxs))\n     | Some x \\<Rightarrow>\n         DList_Set.fold (comp_fun_commute_apply f') dxs b) &&&\n    set_fold_cfc f'' b (RBT_set rbt) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''set_fold_cfc RBT_set: ccompare = None''\n        (\\<lambda>_. set_fold_cfc f'' b (RBT_set rbt))\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (comp_fun_commute_apply f'') rbt b)", "proof -"], ["proof (state)\ngoal (5 subgoals):\n 1. set_fold_cfc f''' b (Complement A) =\n    Code.abort STR ''set_fold_cfc not supported on Complement''\n     (\\<lambda>_. set_fold_cfc f''' b (Complement A))\n 2. set_fold_cfc f''' b (Collect_set P) =\n    Code.abort STR ''set_fold_cfc not supported on Collect_set''\n     (\\<lambda>_. set_fold_cfc f''' b (Collect_set P))\n 3. set_fold_cfc f b (Set_Monad xs) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''set_fold_cfc Set_Monad: ceq = None''\n        (\\<lambda>_. set_fold_cfc f b (Set_Monad xs))\n     | Some eq \\<Rightarrow>\n         fold (comp_fun_commute_apply f) (equal_base.list_remdups eq xs) b)\n 4. set_fold_cfc f' b (DList_set dxs) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''set_fold_cfc DList_set: ceq = None''\n        (\\<lambda>_. set_fold_cfc f' b (DList_set dxs))\n     | Some x \\<Rightarrow>\n         DList_Set.fold (comp_fun_commute_apply f') dxs b)\n 5. set_fold_cfc f'' b (RBT_set rbt) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''set_fold_cfc RBT_set: ccompare = None''\n        (\\<lambda>_. set_fold_cfc f'' b (RBT_set rbt))\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (comp_fun_commute_apply f'') rbt b)", "show ?Set_Monad"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_fold_cfc f b (Set_Monad xs) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''set_fold_cfc Set_Monad: ceq = None''\n        (\\<lambda>_. set_fold_cfc f b (Set_Monad xs))\n     | Some eq \\<Rightarrow>\n         fold (comp_fun_commute_apply f) (equal_base.list_remdups eq xs) b)", "by(auto split: option.split dest!: Collection_Eq.ID_ceq simp add: set_fold_cfc_def comp_fun_commute.fold_set_fold_remdups)"], ["proof (state)\nthis:\n  set_fold_cfc f b (Set_Monad xs) =\n  (case ID CEQ('a) of\n   None \\<Rightarrow>\n     Code.abort STR ''set_fold_cfc Set_Monad: ceq = None''\n      (\\<lambda>_. set_fold_cfc f b (Set_Monad xs))\n   | Some eq \\<Rightarrow>\n       fold (comp_fun_commute_apply f) (equal_base.list_remdups eq xs) b)\n\ngoal (4 subgoals):\n 1. set_fold_cfc f''' b (Complement A) =\n    Code.abort STR ''set_fold_cfc not supported on Complement''\n     (\\<lambda>_. set_fold_cfc f''' b (Complement A))\n 2. set_fold_cfc f''' b (Collect_set P) =\n    Code.abort STR ''set_fold_cfc not supported on Collect_set''\n     (\\<lambda>_. set_fold_cfc f''' b (Collect_set P))\n 3. set_fold_cfc f' b (DList_set dxs) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''set_fold_cfc DList_set: ceq = None''\n        (\\<lambda>_. set_fold_cfc f' b (DList_set dxs))\n     | Some x \\<Rightarrow>\n         DList_Set.fold (comp_fun_commute_apply f') dxs b)\n 4. set_fold_cfc f'' b (RBT_set rbt) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''set_fold_cfc RBT_set: ccompare = None''\n        (\\<lambda>_. set_fold_cfc f'' b (RBT_set rbt))\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (comp_fun_commute_apply f'') rbt b)", "show ?DList_set"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_fold_cfc f' b (DList_set dxs) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''set_fold_cfc DList_set: ceq = None''\n        (\\<lambda>_. set_fold_cfc f' b (DList_set dxs))\n     | Some x \\<Rightarrow>\n         DList_Set.fold (comp_fun_commute_apply f') dxs b)", "apply(auto split: option.split simp add: DList_set_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       ID CEQ('a) = Some x2 \\<Longrightarrow>\n       set_fold_cfc f' b (Collect (DList_Set.member dxs)) =\n       DList_Set.fold (comp_fun_commute_apply f') dxs b", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2 f' b dxs.\n       \\<lbrakk>ID CEQ('a) = Some x2; comp_fun_commute f';\n        equal_base.list_distinct ceq' dxs \\<or> ID CEQ('a) = None\\<rbrakk>\n       \\<Longrightarrow> Finite_Set.fold f' b\n                          (Collect (equal_base.list_member ceq' dxs)) =\n                         fold f' dxs b", "apply(auto dest: Collection_Eq.ID_ceq simp add: List.member_def[abs_def] comp_fun_commute.fold_set_fold_remdups distinct_remdups_id)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  set_fold_cfc f' b (DList_set dxs) =\n  (case ID CEQ('a) of\n   None \\<Rightarrow>\n     Code.abort STR ''set_fold_cfc DList_set: ceq = None''\n      (\\<lambda>_. set_fold_cfc f' b (DList_set dxs))\n   | Some x \\<Rightarrow> DList_Set.fold (comp_fun_commute_apply f') dxs b)\n\ngoal (3 subgoals):\n 1. set_fold_cfc f''' b (Complement A) =\n    Code.abort STR ''set_fold_cfc not supported on Complement''\n     (\\<lambda>_. set_fold_cfc f''' b (Complement A))\n 2. set_fold_cfc f''' b (Collect_set P) =\n    Code.abort STR ''set_fold_cfc not supported on Collect_set''\n     (\\<lambda>_. set_fold_cfc f''' b (Collect_set P))\n 3. set_fold_cfc f'' b (RBT_set rbt) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''set_fold_cfc RBT_set: ccompare = None''\n        (\\<lambda>_. set_fold_cfc f'' b (RBT_set rbt))\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (comp_fun_commute_apply f'') rbt b)", "show ?RBT_set"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_fold_cfc f'' b (RBT_set rbt) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''set_fold_cfc RBT_set: ccompare = None''\n        (\\<lambda>_. set_fold_cfc f'' b (RBT_set rbt))\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (comp_fun_commute_apply f'') rbt b)", "apply(auto split: option.split simp add: RBT_set_conv_keys fold_conv_fold_keys)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       ID ccompare = Some x2 \\<Longrightarrow>\n       set_fold_cfc f'' b (set (RBT_Set2.keys rbt)) =\n       fold (comp_fun_commute_apply f'') (RBT_Set2.keys rbt) b", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2 f'' b rbt.\n       \\<lbrakk>ID ccompare = Some x2; comp_fun_commute f'';\n        ord.is_rbt cless rbt \\<or> ID ccompare = None\\<rbrakk>\n       \\<Longrightarrow> Finite_Set.fold f'' b (set (RBT_Impl.keys rbt)) =\n                         fold f'' (RBT_Impl.keys rbt) b", "apply(simp add: comp_fun_commute.fold_set_fold_remdups distinct_remdups_id linorder.distinct_keys[OF ID_ccompare] ord.is_rbt_rbt_sorted)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  set_fold_cfc f'' b (RBT_set rbt) =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''set_fold_cfc RBT_set: ccompare = None''\n      (\\<lambda>_. set_fold_cfc f'' b (RBT_set rbt))\n   | Some x \\<Rightarrow> RBT_Set2.fold (comp_fun_commute_apply f'') rbt b)\n\ngoal (2 subgoals):\n 1. set_fold_cfc f''' b (Complement A) =\n    Code.abort STR ''set_fold_cfc not supported on Complement''\n     (\\<lambda>_. set_fold_cfc f''' b (Complement A))\n 2. set_fold_cfc f''' b (Collect_set P) =\n    Code.abort STR ''set_fold_cfc not supported on Collect_set''\n     (\\<lambda>_. set_fold_cfc f''' b (Collect_set P))", "qed simp_all"], ["", "typedef ('a, 'b) comp_fun_idem = \"{f :: 'a \\<Rightarrow> 'b \\<Rightarrow> 'b. comp_fun_idem f}\"\n  morphisms comp_fun_idem_apply Abs_comp_fun_idem"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {f. comp_fun_idem f}", "by(rule exI[where x=\"\\<lambda>_. id\"])(simp, unfold_locales, auto)"], ["", "setup_lifting type_definition_comp_fun_idem"], ["", "lemma comp_fun_idem_apply' [simp]:\n  \"comp_fun_idem (comp_fun_idem_apply f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_idem (comp_fun_idem_apply f)", "using comp_fun_idem_apply[of f]"], ["proof (prove)\nusing this:\n  comp_fun_idem_apply f \\<in> {f. comp_fun_idem f}\n\ngoal (1 subgoal):\n 1. comp_fun_idem (comp_fun_idem_apply f)", "by simp"], ["", "lift_definition set_fold_cfi :: \"('a, 'b) comp_fun_idem \\<Rightarrow> 'b \\<Rightarrow> 'a set \\<Rightarrow> 'b\" is \"Finite_Set.fold\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "declare [[code drop: set_fold_cfi]]"], ["", "lemma set_fold_cfi_code [code]:\n  fixes xs :: \"'a list\" \n  and dxs :: \"'b :: ceq set_dlist\"\n  and rbt :: \"'c :: ccompare set_rbt\" shows\n  \"set_fold_cfi f b (Complement A) = Code.abort (STR ''set_fold_cfi not supported on Complement'') (\\<lambda>_. set_fold_cfi f b (Complement A))\"\n  \"set_fold_cfi f b (Collect_set P) = Code.abort (STR ''set_fold_cfi not supported on Collect_set'') (\\<lambda>_. set_fold_cfi f b (Collect_set P))\"\n  \"set_fold_cfi f b (Set_Monad xs) = List.fold (comp_fun_idem_apply f) xs b\"\n  (is ?Set_Monad)\n  \"set_fold_cfi f' b (DList_set dxs) =\n  (case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''set_fold_cfi DList_set: ceq = None'') (\\<lambda>_. set_fold_cfi f' b (DList_set dxs))\n                  | Some _ \\<Rightarrow> DList_Set.fold (comp_fun_idem_apply f') dxs b)\"\n  (is ?DList_set)\n  \"set_fold_cfi f'' b (RBT_set rbt) =\n  (case ID CCOMPARE('c) of None \\<Rightarrow> Code.abort (STR ''set_fold_cfi RBT_set: ccompare = None'') (\\<lambda>_. set_fold_cfi f'' b (RBT_set rbt))\n                     | Some _ \\<Rightarrow> RBT_Set2.fold (comp_fun_idem_apply f'') rbt b)\"\n  (is ?RBT_set)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (set_fold_cfi f b (Complement A) =\n     Code.abort STR ''set_fold_cfi not supported on Complement''\n      (\\<lambda>_. set_fold_cfi f b (Complement A)) &&&\n     set_fold_cfi f b (Collect_set P) =\n     Code.abort STR ''set_fold_cfi not supported on Collect_set''\n      (\\<lambda>_. set_fold_cfi f b (Collect_set P))) &&&\n    set_fold_cfi f b (Set_Monad xs) = fold (comp_fun_idem_apply f) xs b &&&\n    set_fold_cfi f' b (DList_set dxs) =\n    (case ID CEQ('b) of\n     None \\<Rightarrow>\n       Code.abort STR ''set_fold_cfi DList_set: ceq = None''\n        (\\<lambda>_. set_fold_cfi f' b (DList_set dxs))\n     | Some x \\<Rightarrow>\n         DList_Set.fold (comp_fun_idem_apply f') dxs b) &&&\n    set_fold_cfi f'' b (RBT_set rbt) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''set_fold_cfi RBT_set: ccompare = None''\n        (\\<lambda>_. set_fold_cfi f'' b (RBT_set rbt))\n     | Some x \\<Rightarrow> RBT_Set2.fold (comp_fun_idem_apply f'') rbt b)", "proof -"], ["proof (state)\ngoal (5 subgoals):\n 1. set_fold_cfi f b (Complement A) =\n    Code.abort STR ''set_fold_cfi not supported on Complement''\n     (\\<lambda>_. set_fold_cfi f b (Complement A))\n 2. set_fold_cfi f b (Collect_set P) =\n    Code.abort STR ''set_fold_cfi not supported on Collect_set''\n     (\\<lambda>_. set_fold_cfi f b (Collect_set P))\n 3. set_fold_cfi f b (Set_Monad xs) = fold (comp_fun_idem_apply f) xs b\n 4. set_fold_cfi f' b (DList_set dxs) =\n    (case ID CEQ('b) of\n     None \\<Rightarrow>\n       Code.abort STR ''set_fold_cfi DList_set: ceq = None''\n        (\\<lambda>_. set_fold_cfi f' b (DList_set dxs))\n     | Some x \\<Rightarrow> DList_Set.fold (comp_fun_idem_apply f') dxs b)\n 5. set_fold_cfi f'' b (RBT_set rbt) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''set_fold_cfi RBT_set: ccompare = None''\n        (\\<lambda>_. set_fold_cfi f'' b (RBT_set rbt))\n     | Some x \\<Rightarrow> RBT_Set2.fold (comp_fun_idem_apply f'') rbt b)", "show ?Set_Monad"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_fold_cfi f b (Set_Monad xs) = fold (comp_fun_idem_apply f) xs b", "by(auto split: option.split dest!: Collection_Eq.ID_ceq simp add: set_fold_cfi_def comp_fun_idem.fold_set_fold)"], ["proof (state)\nthis:\n  set_fold_cfi f b (Set_Monad xs) = fold (comp_fun_idem_apply f) xs b\n\ngoal (4 subgoals):\n 1. set_fold_cfi f b (Complement A) =\n    Code.abort STR ''set_fold_cfi not supported on Complement''\n     (\\<lambda>_. set_fold_cfi f b (Complement A))\n 2. set_fold_cfi f b (Collect_set P) =\n    Code.abort STR ''set_fold_cfi not supported on Collect_set''\n     (\\<lambda>_. set_fold_cfi f b (Collect_set P))\n 3. set_fold_cfi f' b (DList_set dxs) =\n    (case ID CEQ('b) of\n     None \\<Rightarrow>\n       Code.abort STR ''set_fold_cfi DList_set: ceq = None''\n        (\\<lambda>_. set_fold_cfi f' b (DList_set dxs))\n     | Some x \\<Rightarrow> DList_Set.fold (comp_fun_idem_apply f') dxs b)\n 4. set_fold_cfi f'' b (RBT_set rbt) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''set_fold_cfi RBT_set: ccompare = None''\n        (\\<lambda>_. set_fold_cfi f'' b (RBT_set rbt))\n     | Some x \\<Rightarrow> RBT_Set2.fold (comp_fun_idem_apply f'') rbt b)", "show ?DList_set"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_fold_cfi f' b (DList_set dxs) =\n    (case ID CEQ('b) of\n     None \\<Rightarrow>\n       Code.abort STR ''set_fold_cfi DList_set: ceq = None''\n        (\\<lambda>_. set_fold_cfi f' b (DList_set dxs))\n     | Some x \\<Rightarrow> DList_Set.fold (comp_fun_idem_apply f') dxs b)", "apply(auto split: option.split simp add: DList_set_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       ID CEQ('b) = Some x2 \\<Longrightarrow>\n       set_fold_cfi f' b (Collect (DList_Set.member dxs)) =\n       DList_Set.fold (comp_fun_idem_apply f') dxs b", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2 f' b dxs.\n       \\<lbrakk>ID CEQ('b) = Some x2; comp_fun_idem f';\n        equal_base.list_distinct ceq' dxs \\<or> ID CEQ('b) = None\\<rbrakk>\n       \\<Longrightarrow> Finite_Set.fold f' b\n                          (Collect (equal_base.list_member ceq' dxs)) =\n                         fold f' dxs b", "apply(auto dest: Collection_Eq.ID_ceq simp add: List.member_def[abs_def] comp_fun_idem.fold_set_fold)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  set_fold_cfi f' b (DList_set dxs) =\n  (case ID CEQ('b) of\n   None \\<Rightarrow>\n     Code.abort STR ''set_fold_cfi DList_set: ceq = None''\n      (\\<lambda>_. set_fold_cfi f' b (DList_set dxs))\n   | Some x \\<Rightarrow> DList_Set.fold (comp_fun_idem_apply f') dxs b)\n\ngoal (3 subgoals):\n 1. set_fold_cfi f b (Complement A) =\n    Code.abort STR ''set_fold_cfi not supported on Complement''\n     (\\<lambda>_. set_fold_cfi f b (Complement A))\n 2. set_fold_cfi f b (Collect_set P) =\n    Code.abort STR ''set_fold_cfi not supported on Collect_set''\n     (\\<lambda>_. set_fold_cfi f b (Collect_set P))\n 3. set_fold_cfi f'' b (RBT_set rbt) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''set_fold_cfi RBT_set: ccompare = None''\n        (\\<lambda>_. set_fold_cfi f'' b (RBT_set rbt))\n     | Some x \\<Rightarrow> RBT_Set2.fold (comp_fun_idem_apply f'') rbt b)", "show ?RBT_set"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_fold_cfi f'' b (RBT_set rbt) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''set_fold_cfi RBT_set: ccompare = None''\n        (\\<lambda>_. set_fold_cfi f'' b (RBT_set rbt))\n     | Some x \\<Rightarrow> RBT_Set2.fold (comp_fun_idem_apply f'') rbt b)", "apply(auto split: option.split simp add: RBT_set_conv_keys fold_conv_fold_keys)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       ID ccompare = Some x2 \\<Longrightarrow>\n       set_fold_cfi f'' b (set (RBT_Set2.keys rbt)) =\n       fold (comp_fun_idem_apply f'') (RBT_Set2.keys rbt) b", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2 f'' b rbt.\n       \\<lbrakk>ID ccompare = Some x2; comp_fun_idem f'';\n        ord.is_rbt cless rbt \\<or> ID ccompare = None\\<rbrakk>\n       \\<Longrightarrow> Finite_Set.fold f'' b (set (RBT_Impl.keys rbt)) =\n                         fold f'' (RBT_Impl.keys rbt) b", "apply(simp add: comp_fun_idem.fold_set_fold)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  set_fold_cfi f'' b (RBT_set rbt) =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''set_fold_cfi RBT_set: ccompare = None''\n      (\\<lambda>_. set_fold_cfi f'' b (RBT_set rbt))\n   | Some x \\<Rightarrow> RBT_Set2.fold (comp_fun_idem_apply f'') rbt b)\n\ngoal (2 subgoals):\n 1. set_fold_cfi f b (Complement A) =\n    Code.abort STR ''set_fold_cfi not supported on Complement''\n     (\\<lambda>_. set_fold_cfi f b (Complement A))\n 2. set_fold_cfi f b (Collect_set P) =\n    Code.abort STR ''set_fold_cfi not supported on Collect_set''\n     (\\<lambda>_. set_fold_cfi f b (Collect_set P))", "qed simp_all"], ["", "typedef 'a semilattice_set = \"{f :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a. semilattice_set f}\"\n  morphisms semilattice_set_apply Abs_semilattice_set"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {f. semilattice_set f}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. ?x \\<in> {f. semilattice_set f}", "show \"(\\<lambda>x y. if x = y then x else undefined) \\<in> ?semilattice_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x y. if x = y then x else undefined)\n    \\<in> {f. semilattice_set f}", "unfolding mem_Collect_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. semilattice_set (\\<lambda>x y. if x = y then x else undefined)", "by(unfold_locales) simp_all"], ["proof (state)\nthis:\n  (\\<lambda>x y. if x = y then x else undefined)\n  \\<in> {f. semilattice_set f}\n\ngoal:\nNo subgoals!", "qed"], ["", "setup_lifting type_definition_semilattice_set"], ["", "lemma semilattice_set_apply' [simp]:\n  \"semilattice_set (semilattice_set_apply f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. semilattice_set (semilattice_set_apply f)", "using semilattice_set_apply[of f]"], ["proof (prove)\nusing this:\n  semilattice_set_apply f \\<in> {f. semilattice_set f}\n\ngoal (1 subgoal):\n 1. semilattice_set (semilattice_set_apply f)", "by simp"], ["", "lemma comp_fun_idem_semilattice_set_apply [simp]:\n  \"comp_fun_idem (semilattice_set_apply f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_idem (semilattice_set_apply f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. comp_fun_idem (semilattice_set_apply f)", "interpret semilattice_set \"semilattice_set_apply f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. semilattice_set (semilattice_set_apply f)", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. comp_fun_idem (semilattice_set_apply f)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_idem (semilattice_set_apply f)", "by(unfold_locales)(simp_all add: fun_eq_iff left_commute)"], ["proof (state)\nthis:\n  comp_fun_idem (semilattice_set_apply f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition set_fold1 :: \"'a semilattice_set \\<Rightarrow> 'a set \\<Rightarrow> 'a\" is \"semilattice_set.F\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma (in semilattice_set) F_set_conv_fold:\n  \"xs \\<noteq> [] \\<Longrightarrow> F (set xs) = Finite_Set.fold f (hd xs) (set (tl xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    F (set xs) = Finite_Set.fold (\\<^bold>*) (hd xs) (set (tl xs))", "by(clarsimp simp add: neq_Nil_conv eq_fold)"], ["", "lemma set_fold1_code [code]:\n  fixes rbt :: \"'a :: {ccompare, lattice} set_rbt\"\n  and dxs :: \"'b :: {ceq, lattice} set_dlist\" shows\n  set_fold1_Complement[set_complement_code]:\n  \"set_fold1 f (Complement A) = Code.abort (STR ''set_fold1: Complement'') (\\<lambda>_. set_fold1 f (Complement A))\"\n  and \"set_fold1 f (Collect_set P) = Code.abort (STR ''set_fold1: Collect_set'') (\\<lambda>_. set_fold1 f (Collect_set P))\"\n  and \"set_fold1 f (Set_Monad (x # xs)) = fold (semilattice_set_apply f) xs x\" (is \"?Set_Monad\")\n  and\n  \"set_fold1 f' (DList_set dxs) =\n  (case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''set_fold1 DList_set: ceq = None'') (\\<lambda>_. set_fold1 f' (DList_set dxs))\n                  | Some _ \\<Rightarrow> if DList_Set.null dxs then Code.abort (STR ''set_fold1 DList_set: empty set'') (\\<lambda>_. set_fold1 f' (DList_set dxs))\n                              else DList_Set.fold (semilattice_set_apply f') (DList_Set.tl dxs) (DList_Set.hd dxs))\"\n  (is \"?DList_set\")\n  and\n  \"set_fold1 f'' (RBT_set rbt) =\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''set_fold1 RBT_set: ccompare = None'') (\\<lambda>_. set_fold1 f'' (RBT_set rbt))\n                     | Some _ \\<Rightarrow> if RBT_Set2.is_empty rbt then Code.abort (STR ''set_fold1 RBT_set: empty set'') (\\<lambda>_. set_fold1 f'' (RBT_set rbt))\n                                 else RBT_Set2.fold1 (semilattice_set_apply f'') rbt)\"\n  (is \"?RBT_set\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (set_fold1 f (Complement A) =\n     Code.abort STR ''set_fold1: Complement''\n      (\\<lambda>_. set_fold1 f (Complement A)) &&&\n     set_fold1 f (Collect_set P) =\n     Code.abort STR ''set_fold1: Collect_set''\n      (\\<lambda>_. set_fold1 f (Collect_set P))) &&&\n    set_fold1 f (Set_Monad (x # xs)) =\n    fold (semilattice_set_apply f) xs x &&&\n    set_fold1 f' (DList_set dxs) =\n    (case ID CEQ('b) of\n     None \\<Rightarrow>\n       Code.abort STR ''set_fold1 DList_set: ceq = None''\n        (\\<lambda>_. set_fold1 f' (DList_set dxs))\n     | Some x \\<Rightarrow>\n         if DList_Set.null dxs\n         then Code.abort STR ''set_fold1 DList_set: empty set''\n               (\\<lambda>_. set_fold1 f' (DList_set dxs))\n         else DList_Set.fold (semilattice_set_apply f') (DList_Set.tl dxs)\n               (DList_Set.hd dxs)) &&&\n    set_fold1 f'' (RBT_set rbt) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''set_fold1 RBT_set: ccompare = None''\n        (\\<lambda>_. set_fold1 f'' (RBT_set rbt))\n     | Some x \\<Rightarrow>\n         if RBT_Set2.is_empty rbt\n         then Code.abort STR ''set_fold1 RBT_set: empty set''\n               (\\<lambda>_. set_fold1 f'' (RBT_set rbt))\n         else fold1 (semilattice_set_apply f'') rbt)", "proof -"], ["proof (state)\ngoal (5 subgoals):\n 1. set_fold1 f (Complement A) =\n    Code.abort STR ''set_fold1: Complement''\n     (\\<lambda>_. set_fold1 f (Complement A))\n 2. set_fold1 f (Collect_set P) =\n    Code.abort STR ''set_fold1: Collect_set''\n     (\\<lambda>_. set_fold1 f (Collect_set P))\n 3. set_fold1 f (Set_Monad (x # xs)) = fold (semilattice_set_apply f) xs x\n 4. set_fold1 f' (DList_set dxs) =\n    (case ID CEQ('b) of\n     None \\<Rightarrow>\n       Code.abort STR ''set_fold1 DList_set: ceq = None''\n        (\\<lambda>_. set_fold1 f' (DList_set dxs))\n     | Some x \\<Rightarrow>\n         if DList_Set.null dxs\n         then Code.abort STR ''set_fold1 DList_set: empty set''\n               (\\<lambda>_. set_fold1 f' (DList_set dxs))\n         else DList_Set.fold (semilattice_set_apply f') (DList_Set.tl dxs)\n               (DList_Set.hd dxs))\n 5. set_fold1 f'' (RBT_set rbt) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''set_fold1 RBT_set: ccompare = None''\n        (\\<lambda>_. set_fold1 f'' (RBT_set rbt))\n     | Some x \\<Rightarrow>\n         if RBT_Set2.is_empty rbt\n         then Code.abort STR ''set_fold1 RBT_set: empty set''\n               (\\<lambda>_. set_fold1 f'' (RBT_set rbt))\n         else fold1 (semilattice_set_apply f'') rbt)", "show ?Set_Monad"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_fold1 f (Set_Monad (x # xs)) = fold (semilattice_set_apply f) xs x", "by(simp add: set_fold1_def semilattice_set.eq_fold comp_fun_idem.fold_set_fold)"], ["proof (state)\nthis:\n  set_fold1 f (Set_Monad (x # xs)) = fold (semilattice_set_apply f) xs x\n\ngoal (4 subgoals):\n 1. set_fold1 f (Complement A) =\n    Code.abort STR ''set_fold1: Complement''\n     (\\<lambda>_. set_fold1 f (Complement A))\n 2. set_fold1 f (Collect_set P) =\n    Code.abort STR ''set_fold1: Collect_set''\n     (\\<lambda>_. set_fold1 f (Collect_set P))\n 3. set_fold1 f' (DList_set dxs) =\n    (case ID CEQ('b) of\n     None \\<Rightarrow>\n       Code.abort STR ''set_fold1 DList_set: ceq = None''\n        (\\<lambda>_. set_fold1 f' (DList_set dxs))\n     | Some x \\<Rightarrow>\n         if DList_Set.null dxs\n         then Code.abort STR ''set_fold1 DList_set: empty set''\n               (\\<lambda>_. set_fold1 f' (DList_set dxs))\n         else DList_Set.fold (semilattice_set_apply f') (DList_Set.tl dxs)\n               (DList_Set.hd dxs))\n 4. set_fold1 f'' (RBT_set rbt) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''set_fold1 RBT_set: ccompare = None''\n        (\\<lambda>_. set_fold1 f'' (RBT_set rbt))\n     | Some x \\<Rightarrow>\n         if RBT_Set2.is_empty rbt\n         then Code.abort STR ''set_fold1 RBT_set: empty set''\n               (\\<lambda>_. set_fold1 f'' (RBT_set rbt))\n         else fold1 (semilattice_set_apply f'') rbt)", "show ?DList_set"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_fold1 f' (DList_set dxs) =\n    (case ID CEQ('b) of\n     None \\<Rightarrow>\n       Code.abort STR ''set_fold1 DList_set: ceq = None''\n        (\\<lambda>_. set_fold1 f' (DList_set dxs))\n     | Some x \\<Rightarrow>\n         if DList_Set.null dxs\n         then Code.abort STR ''set_fold1 DList_set: empty set''\n               (\\<lambda>_. set_fold1 f' (DList_set dxs))\n         else DList_Set.fold (semilattice_set_apply f') (DList_Set.tl dxs)\n               (DList_Set.hd dxs))", "by(simp add: set_fold1_def semilattice_set.F_set_conv_fold comp_fun_idem.fold_set_fold DList_set_def DList_Set.Collect_member split: option.split)(transfer, simp)"], ["proof (state)\nthis:\n  set_fold1 f' (DList_set dxs) =\n  (case ID CEQ('b) of\n   None \\<Rightarrow>\n     Code.abort STR ''set_fold1 DList_set: ceq = None''\n      (\\<lambda>_. set_fold1 f' (DList_set dxs))\n   | Some x \\<Rightarrow>\n       if DList_Set.null dxs\n       then Code.abort STR ''set_fold1 DList_set: empty set''\n             (\\<lambda>_. set_fold1 f' (DList_set dxs))\n       else DList_Set.fold (semilattice_set_apply f') (DList_Set.tl dxs)\n             (DList_Set.hd dxs))\n\ngoal (3 subgoals):\n 1. set_fold1 f (Complement A) =\n    Code.abort STR ''set_fold1: Complement''\n     (\\<lambda>_. set_fold1 f (Complement A))\n 2. set_fold1 f (Collect_set P) =\n    Code.abort STR ''set_fold1: Collect_set''\n     (\\<lambda>_. set_fold1 f (Collect_set P))\n 3. set_fold1 f'' (RBT_set rbt) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''set_fold1 RBT_set: ccompare = None''\n        (\\<lambda>_. set_fold1 f'' (RBT_set rbt))\n     | Some x \\<Rightarrow>\n         if RBT_Set2.is_empty rbt\n         then Code.abort STR ''set_fold1 RBT_set: empty set''\n               (\\<lambda>_. set_fold1 f'' (RBT_set rbt))\n         else fold1 (semilattice_set_apply f'') rbt)", "show ?RBT_set"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_fold1 f'' (RBT_set rbt) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''set_fold1 RBT_set: ccompare = None''\n        (\\<lambda>_. set_fold1 f'' (RBT_set rbt))\n     | Some x \\<Rightarrow>\n         if RBT_Set2.is_empty rbt\n         then Code.abort STR ''set_fold1 RBT_set: empty set''\n               (\\<lambda>_. set_fold1 f'' (RBT_set rbt))\n         else fold1 (semilattice_set_apply f'') rbt)", "by(simp add: set_fold1_def semilattice_set.F_set_conv_fold comp_fun_idem.fold_set_fold RBT_set_def RBT_Set2.member_conv_keys RBT_Set2.fold1_conv_fold split: option.split)"], ["proof (state)\nthis:\n  set_fold1 f'' (RBT_set rbt) =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''set_fold1 RBT_set: ccompare = None''\n      (\\<lambda>_. set_fold1 f'' (RBT_set rbt))\n   | Some x \\<Rightarrow>\n       if RBT_Set2.is_empty rbt\n       then Code.abort STR ''set_fold1 RBT_set: empty set''\n             (\\<lambda>_. set_fold1 f'' (RBT_set rbt))\n       else fold1 (semilattice_set_apply f'') rbt)\n\ngoal (2 subgoals):\n 1. set_fold1 f (Complement A) =\n    Code.abort STR ''set_fold1: Complement''\n     (\\<lambda>_. set_fold1 f (Complement A))\n 2. set_fold1 f (Collect_set P) =\n    Code.abort STR ''set_fold1: Collect_set''\n     (\\<lambda>_. set_fold1 f (Collect_set P))", "qed simp_all"], ["", "text \\<open>Implementation of set operations\\<close>"], ["", "lemma Collect_code [code]:\n  fixes P :: \"'a :: cenum \\<Rightarrow> bool\" shows\n  \"Collect P =\n  (case ID CENUM('a) of None \\<Rightarrow> Collect_set P\n            | Some (enum, _) \\<Rightarrow> Set_Monad (filter P enum))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Collect P =\n    (case ID CENUM('a) of None \\<Rightarrow> Collect_set P\n     | Some (enum, x) \\<Rightarrow> Set_Monad (filter P enum))", "by(auto split: option.split dest: in_cenum)"], ["", "lemma finite_code [code]:\n  fixes dxs :: \"'a :: ceq set_dlist\" \n  and rbt :: \"'b :: ccompare set_rbt\"\n  and A :: \"'c :: finite_UNIV set\" and P :: \"'c \\<Rightarrow> bool\" shows\n  \"finite (DList_set dxs) = \n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''finite DList_set: ceq = None'') (\\<lambda>_. finite (DList_set dxs))\n                 | Some _ \\<Rightarrow> True)\"\n  \"finite (RBT_set rbt) =\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''finite RBT_set: ccompare = None'') (\\<lambda>_. finite (RBT_set rbt))\n                     | Some _ \\<Rightarrow> True)\"\n  and finite_Complement [set_complement_code]:\n  \"finite (Complement A) \\<longleftrightarrow>\n  (if of_phantom (finite_UNIV :: 'c finite_UNIV) then True\n   else if finite A then False\n   else Code.abort (STR ''finite Complement: infinite set'') (\\<lambda>_. finite (Complement A)))\"\n  and\n  \"finite (Set_Monad xs) = True\"\n  \"finite (Collect_set P) \\<longleftrightarrow>\n  of_phantom (finite_UNIV :: 'c finite_UNIV) \\<or> Code.abort (STR ''finite Collect_set'') (\\<lambda>_. finite (Collect_set P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (finite (DList_set dxs) =\n     (case ID CEQ('a) of\n      None \\<Rightarrow>\n        Code.abort STR ''finite DList_set: ceq = None''\n         (\\<lambda>_. finite (DList_set dxs))\n      | Some x \\<Rightarrow> True) &&&\n     finite (RBT_set rbt) =\n     (case ID ccompare of\n      None \\<Rightarrow>\n        Code.abort STR ''finite RBT_set: ccompare = None''\n         (\\<lambda>_. finite (RBT_set rbt))\n      | Some x \\<Rightarrow> True)) &&&\n    finite (Complement A) =\n    (if of_phantom finite_UNIV then True\n     else if finite A then False\n          else Code.abort STR ''finite Complement: infinite set''\n                (\\<lambda>_. finite (Complement A))) &&&\n    finite (Set_Monad xs) = True &&&\n    finite (Collect_set P) =\n    (of_phantom finite_UNIV \\<or>\n     Code.abort STR ''finite Collect_set''\n      (\\<lambda>_. finite (Collect_set P)))", "by(auto simp add: DList_set_def RBT_set_def member_conv_keys card_gt_0_iff finite_UNIV split: option.split elim: finite_subset[rotated 1])"], ["", "lemma card_code [code]:\n  fixes dxs :: \"'a :: ceq set_dlist\" and xs :: \"'a list\"\n  and rbt :: \"'b :: ccompare set_rbt\" \n  and A :: \"'c :: card_UNIV set\" shows\n  \"card (DList_set dxs) = \n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''card DList_set: ceq = None'') (\\<lambda>_. card (DList_set dxs))\n                  | Some _ \\<Rightarrow> DList_Set.length dxs)\"\n  \"card (RBT_set rbt) = \n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''card RBT_set: ccompare = None'') (\\<lambda>_. card (RBT_set rbt))\n                    | Some _ \\<Rightarrow> length (RBT_Set2.keys rbt))\"\n  \"card (Set_Monad xs) =\n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''card Set_Monad: ceq = None'') (\\<lambda>_. card (Set_Monad xs))\n                 | Some eq \\<Rightarrow> length (equal_base.list_remdups eq xs))\"\n  and card_Complement [set_complement_code]:\n  \"card (Complement A) =\n   (let a = card A; s = CARD('c)\n    in if s > 0 then s - a \n       else if finite A then 0\n       else Code.abort (STR ''card Complement: infinite'') (\\<lambda>_. card (Complement A)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (card (DList_set dxs) =\n     (case ID CEQ('a) of\n      None \\<Rightarrow>\n        Code.abort STR ''card DList_set: ceq = None''\n         (\\<lambda>_. card (DList_set dxs))\n      | Some x \\<Rightarrow> DList_Set.length dxs) &&&\n     card (RBT_set rbt) =\n     (case ID ccompare of\n      None \\<Rightarrow>\n        Code.abort STR ''card RBT_set: ccompare = None''\n         (\\<lambda>_. card (RBT_set rbt))\n      | Some x \\<Rightarrow> length (RBT_Set2.keys rbt)) &&&\n     card (Set_Monad xs) =\n     (case ID CEQ('a) of\n      None \\<Rightarrow>\n        Code.abort STR ''card Set_Monad: ceq = None''\n         (\\<lambda>_. card (Set_Monad xs))\n      | Some eq \\<Rightarrow> length (equal_base.list_remdups eq xs))) &&&\n    card (Complement A) =\n    (let a = card A; s = CARD('c)\n     in if 0 < s then s - a\n        else if finite A then 0\n             else Code.abort STR ''card Complement: infinite''\n                   (\\<lambda>_. card (Complement A)))", "by(auto simp add: RBT_set_def member_conv_keys distinct_card DList_set_def Let_def card_UNIV Compl_eq_Diff_UNIV card_Diff_subset_Int card_gt_0_iff finite_subset[of A UNIV] List.card_set dest: Collection_Eq.ID_ceq split: option.split)"], ["", "lemma is_UNIV_code [code]:\n  fixes rbt :: \"'a :: {cproper_interval, finite_UNIV} set_rbt\" \n  and A :: \"'b :: card_UNIV set\" shows\n  \"is_UNIV A \\<longleftrightarrow>\n   (let a = CARD('b);\n        b = card A\n    in if a > 0 then a = b\n       else if b > 0 then False\n       else Code.abort (STR ''is_UNIV called on infinite type and set'') (\\<lambda>_. is_UNIV A))\"\n  (is ?generic)\n  \"is_UNIV (RBT_set rbt) = \n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''is_UNIV RBT_set: ccompare = None'') (\\<lambda>_. is_UNIV (RBT_set rbt))\n                     | Some _ \\<Rightarrow> of_phantom (finite_UNIV :: 'a finite_UNIV) \\<and> proper_intrvl.exhaustive_fusion cproper_interval rbt_keys_generator (RBT_Set2.init rbt))\"\n  (is ?rbt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_UNIV A =\n    (let a = CARD('b); b = card A\n     in if 0 < a then a = b\n        else if 0 < b then False\n             else Code.abort STR ''is_UNIV called on infinite type and set''\n                   (\\<lambda>_. is_UNIV A)) &&&\n    is_UNIV (RBT_set rbt) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''is_UNIV RBT_set: ccompare = None''\n        (\\<lambda>_. is_UNIV (RBT_set rbt))\n     | Some x \\<Rightarrow>\n         of_phantom finite_UNIV \\<and>\n         proper_intrvl.exhaustive_fusion cproper_interval rbt_keys_generator\n          (RBT_Set2.init rbt))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. is_UNIV A =\n    (let a = CARD('b); b = card A\n     in if 0 < a then a = b\n        else if 0 < b then False\n             else Code.abort STR ''is_UNIV called on infinite type and set''\n                   (\\<lambda>_. is_UNIV A))\n 2. is_UNIV (RBT_set rbt) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''is_UNIV RBT_set: ccompare = None''\n        (\\<lambda>_. is_UNIV (RBT_set rbt))\n     | Some x \\<Rightarrow>\n         of_phantom finite_UNIV \\<and>\n         proper_intrvl.exhaustive_fusion cproper_interval rbt_keys_generator\n          (RBT_Set2.init rbt))", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. is_UNIV A =\n    (let a = CARD('b); b = card A\n     in if 0 < a then a = b\n        else if 0 < b then False\n             else Code.abort STR ''is_UNIV called on infinite type and set''\n                   (\\<lambda>_. is_UNIV A))\n 2. is_UNIV (RBT_set rbt) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''is_UNIV RBT_set: ccompare = None''\n        (\\<lambda>_. is_UNIV (RBT_set rbt))\n     | Some x \\<Rightarrow>\n         of_phantom finite_UNIV \\<and>\n         proper_intrvl.exhaustive_fusion cproper_interval rbt_keys_generator\n          (RBT_Set2.init rbt))", "fix c"], ["proof (state)\ngoal (2 subgoals):\n 1. is_UNIV A =\n    (let a = CARD('b); b = card A\n     in if 0 < a then a = b\n        else if 0 < b then False\n             else Code.abort STR ''is_UNIV called on infinite type and set''\n                   (\\<lambda>_. is_UNIV A))\n 2. is_UNIV (RBT_set rbt) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''is_UNIV RBT_set: ccompare = None''\n        (\\<lambda>_. is_UNIV (RBT_set rbt))\n     | Some x \\<Rightarrow>\n         of_phantom finite_UNIV \\<and>\n         proper_intrvl.exhaustive_fusion cproper_interval rbt_keys_generator\n          (RBT_Set2.init rbt))", "assume linorder: \"ID CCOMPARE('a) = Some c\""], ["proof (state)\nthis:\n  ID ccompare = Some c\n\ngoal (2 subgoals):\n 1. is_UNIV A =\n    (let a = CARD('b); b = card A\n     in if 0 < a then a = b\n        else if 0 < b then False\n             else Code.abort STR ''is_UNIV called on infinite type and set''\n                   (\\<lambda>_. is_UNIV A))\n 2. is_UNIV (RBT_set rbt) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''is_UNIV RBT_set: ccompare = None''\n        (\\<lambda>_. is_UNIV (RBT_set rbt))\n     | Some x \\<Rightarrow>\n         of_phantom finite_UNIV \\<and>\n         proper_intrvl.exhaustive_fusion cproper_interval rbt_keys_generator\n          (RBT_Set2.init rbt))", "have \"is_UNIV (RBT_set rbt) =\n      (finite (UNIV :: 'a set) \\<and> proper_intrvl.exhaustive cproper_interval (RBT_Set2.keys rbt))\"\n      (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_UNIV (RBT_set rbt) =\n    (finite UNIV \\<and>\n     proper_intrvl.exhaustive cproper_interval (RBT_Set2.keys rbt))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. is_UNIV (RBT_set rbt) \\<Longrightarrow>\n    finite UNIV \\<and>\n    proper_intrvl.exhaustive cproper_interval (RBT_Set2.keys rbt)\n 2. finite UNIV \\<and>\n    proper_intrvl.exhaustive cproper_interval\n     (RBT_Set2.keys rbt) \\<Longrightarrow>\n    is_UNIV (RBT_set rbt)", "assume ?lhs"], ["proof (state)\nthis:\n  is_UNIV (RBT_set rbt)\n\ngoal (2 subgoals):\n 1. is_UNIV (RBT_set rbt) \\<Longrightarrow>\n    finite UNIV \\<and>\n    proper_intrvl.exhaustive cproper_interval (RBT_Set2.keys rbt)\n 2. finite UNIV \\<and>\n    proper_intrvl.exhaustive cproper_interval\n     (RBT_Set2.keys rbt) \\<Longrightarrow>\n    is_UNIV (RBT_set rbt)", "have \"finite (UNIV :: 'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite UNIV", "unfolding \\<open>?lhs\\<close>[unfolded is_UNIV_def, symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (RBT_set rbt)", "using linorder"], ["proof (prove)\nusing this:\n  ID ccompare = Some c\n\ngoal (1 subgoal):\n 1. finite (RBT_set rbt)", "by(simp add: finite_code)"], ["proof (state)\nthis:\n  finite UNIV\n\ngoal (2 subgoals):\n 1. is_UNIV (RBT_set rbt) \\<Longrightarrow>\n    finite UNIV \\<and>\n    proper_intrvl.exhaustive cproper_interval (RBT_Set2.keys rbt)\n 2. finite UNIV \\<and>\n    proper_intrvl.exhaustive cproper_interval\n     (RBT_Set2.keys rbt) \\<Longrightarrow>\n    is_UNIV (RBT_set rbt)", "moreover"], ["proof (state)\nthis:\n  finite UNIV\n\ngoal (2 subgoals):\n 1. is_UNIV (RBT_set rbt) \\<Longrightarrow>\n    finite UNIV \\<and>\n    proper_intrvl.exhaustive cproper_interval (RBT_Set2.keys rbt)\n 2. finite UNIV \\<and>\n    proper_intrvl.exhaustive cproper_interval\n     (RBT_Set2.keys rbt) \\<Longrightarrow>\n    is_UNIV (RBT_set rbt)", "hence \"proper_intrvl.exhaustive cproper_interval (RBT_Set2.keys rbt)\""], ["proof (prove)\nusing this:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. proper_intrvl.exhaustive cproper_interval (RBT_Set2.keys rbt)", "using linorder \\<open>?lhs\\<close>"], ["proof (prove)\nusing this:\n  finite UNIV\n  ID ccompare = Some c\n  is_UNIV (RBT_set rbt)\n\ngoal (1 subgoal):\n 1. proper_intrvl.exhaustive cproper_interval (RBT_Set2.keys rbt)", "by(simp add: linorder_proper_interval.exhaustive_correct[OF ID_ccompare_interval[OF linorder]] sorted_RBT_Set_keys is_UNIV_def RBT_set_conv_keys)"], ["proof (state)\nthis:\n  proper_intrvl.exhaustive cproper_interval (RBT_Set2.keys rbt)\n\ngoal (2 subgoals):\n 1. is_UNIV (RBT_set rbt) \\<Longrightarrow>\n    finite UNIV \\<and>\n    proper_intrvl.exhaustive cproper_interval (RBT_Set2.keys rbt)\n 2. finite UNIV \\<and>\n    proper_intrvl.exhaustive cproper_interval\n     (RBT_Set2.keys rbt) \\<Longrightarrow>\n    is_UNIV (RBT_set rbt)", "ultimately"], ["proof (chain)\npicking this:\n  finite UNIV\n  proper_intrvl.exhaustive cproper_interval (RBT_Set2.keys rbt)", "show ?rhs"], ["proof (prove)\nusing this:\n  finite UNIV\n  proper_intrvl.exhaustive cproper_interval (RBT_Set2.keys rbt)\n\ngoal (1 subgoal):\n 1. finite UNIV \\<and>\n    proper_intrvl.exhaustive cproper_interval (RBT_Set2.keys rbt)", ".."], ["proof (state)\nthis:\n  finite UNIV \\<and>\n  proper_intrvl.exhaustive cproper_interval (RBT_Set2.keys rbt)\n\ngoal (1 subgoal):\n 1. finite UNIV \\<and>\n    proper_intrvl.exhaustive cproper_interval\n     (RBT_Set2.keys rbt) \\<Longrightarrow>\n    is_UNIV (RBT_set rbt)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. finite UNIV \\<and>\n    proper_intrvl.exhaustive cproper_interval\n     (RBT_Set2.keys rbt) \\<Longrightarrow>\n    is_UNIV (RBT_set rbt)", "assume ?rhs"], ["proof (state)\nthis:\n  finite UNIV \\<and>\n  proper_intrvl.exhaustive cproper_interval (RBT_Set2.keys rbt)\n\ngoal (1 subgoal):\n 1. finite UNIV \\<and>\n    proper_intrvl.exhaustive cproper_interval\n     (RBT_Set2.keys rbt) \\<Longrightarrow>\n    is_UNIV (RBT_set rbt)", "thus ?lhs"], ["proof (prove)\nusing this:\n  finite UNIV \\<and>\n  proper_intrvl.exhaustive cproper_interval (RBT_Set2.keys rbt)\n\ngoal (1 subgoal):\n 1. is_UNIV (RBT_set rbt)", "using linorder"], ["proof (prove)\nusing this:\n  finite UNIV \\<and>\n  proper_intrvl.exhaustive cproper_interval (RBT_Set2.keys rbt)\n  ID ccompare = Some c\n\ngoal (1 subgoal):\n 1. is_UNIV (RBT_set rbt)", "by(auto simp add: linorder_proper_interval.exhaustive_correct[OF ID_ccompare_interval[OF linorder]] sorted_RBT_Set_keys is_UNIV_def RBT_set_conv_keys)"], ["proof (state)\nthis:\n  is_UNIV (RBT_set rbt)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_UNIV (RBT_set rbt) =\n  (finite UNIV \\<and>\n   proper_intrvl.exhaustive cproper_interval (RBT_Set2.keys rbt))\n\ngoal (2 subgoals):\n 1. is_UNIV A =\n    (let a = CARD('b); b = card A\n     in if 0 < a then a = b\n        else if 0 < b then False\n             else Code.abort STR ''is_UNIV called on infinite type and set''\n                   (\\<lambda>_. is_UNIV A))\n 2. is_UNIV (RBT_set rbt) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''is_UNIV RBT_set: ccompare = None''\n        (\\<lambda>_. is_UNIV (RBT_set rbt))\n     | Some x \\<Rightarrow>\n         of_phantom finite_UNIV \\<and>\n         proper_intrvl.exhaustive_fusion cproper_interval rbt_keys_generator\n          (RBT_Set2.init rbt))", "}"], ["proof (state)\nthis:\n  ID ccompare = Some ?c2 \\<Longrightarrow>\n  is_UNIV (RBT_set rbt) =\n  (finite UNIV \\<and>\n   proper_intrvl.exhaustive cproper_interval (RBT_Set2.keys rbt))\n\ngoal (2 subgoals):\n 1. is_UNIV A =\n    (let a = CARD('b); b = card A\n     in if 0 < a then a = b\n        else if 0 < b then False\n             else Code.abort STR ''is_UNIV called on infinite type and set''\n                   (\\<lambda>_. is_UNIV A))\n 2. is_UNIV (RBT_set rbt) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''is_UNIV RBT_set: ccompare = None''\n        (\\<lambda>_. is_UNIV (RBT_set rbt))\n     | Some x \\<Rightarrow>\n         of_phantom finite_UNIV \\<and>\n         proper_intrvl.exhaustive_fusion cproper_interval rbt_keys_generator\n          (RBT_Set2.init rbt))", "thus ?rbt"], ["proof (prove)\nusing this:\n  ID ccompare = Some ?c2 \\<Longrightarrow>\n  is_UNIV (RBT_set rbt) =\n  (finite UNIV \\<and>\n   proper_intrvl.exhaustive cproper_interval (RBT_Set2.keys rbt))\n\ngoal (1 subgoal):\n 1. is_UNIV (RBT_set rbt) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''is_UNIV RBT_set: ccompare = None''\n        (\\<lambda>_. is_UNIV (RBT_set rbt))\n     | Some x \\<Rightarrow>\n         of_phantom finite_UNIV \\<and>\n         proper_intrvl.exhaustive_fusion cproper_interval rbt_keys_generator\n          (RBT_Set2.init rbt))", "by(auto simp add: finite_UNIV proper_intrvl.exhaustive_fusion_def unfoldr_rbt_keys_generator is_UNIV_def split: option.split)"], ["proof (state)\nthis:\n  is_UNIV (RBT_set rbt) =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''is_UNIV RBT_set: ccompare = None''\n      (\\<lambda>_. is_UNIV (RBT_set rbt))\n   | Some x \\<Rightarrow>\n       of_phantom finite_UNIV \\<and>\n       proper_intrvl.exhaustive_fusion cproper_interval rbt_keys_generator\n        (RBT_Set2.init rbt))\n\ngoal (1 subgoal):\n 1. is_UNIV A =\n    (let a = CARD('b); b = card A\n     in if 0 < a then a = b\n        else if 0 < b then False\n             else Code.abort STR ''is_UNIV called on infinite type and set''\n                   (\\<lambda>_. is_UNIV A))", "show ?generic"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_UNIV A =\n    (let a = CARD('b); b = card A\n     in if 0 < a then a = b\n        else if 0 < b then False\n             else Code.abort STR ''is_UNIV called on infinite type and set''\n                   (\\<lambda>_. is_UNIV A))", "by(auto simp add: Let_def is_UNIV_def dest: card_seteq[of UNIV A] dest!: card_ge_0_finite)"], ["proof (state)\nthis:\n  is_UNIV A =\n  (let a = CARD('b); b = card A\n   in if 0 < a then a = b\n      else if 0 < b then False\n           else Code.abort STR ''is_UNIV called on infinite type and set''\n                 (\\<lambda>_. is_UNIV A))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_empty_code [code]:\n  fixes dxs :: \"'a :: ceq set_dlist\" \n  and rbt :: \"'b :: ccompare set_rbt\" \n  and A :: \"'c set\" shows\n  \"Set.is_empty (Set_Monad xs) \\<longleftrightarrow> xs = []\"\n  \"Set.is_empty (DList_set dxs) \\<longleftrightarrow> \n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''is_empty DList_set: ceq = None'') (\\<lambda>_. Set.is_empty (DList_set dxs))\n                  | Some _ \\<Rightarrow> DList_Set.null dxs)\" (is ?DList_set)\n  \"Set.is_empty (RBT_set rbt) \\<longleftrightarrow> \n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''is_empty RBT_set: ccompare = None'') (\\<lambda>_. Set.is_empty (RBT_set rbt))\n                  | Some _ \\<Rightarrow> RBT_Set2.is_empty rbt)\" (is ?RBT_set)\n  and is_empty_Complement [set_complement_code]:\n  \"Set.is_empty (Complement A) \\<longleftrightarrow> is_UNIV A\" (is ?Complement)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Set.is_empty (Set_Monad xs) = (xs = []) &&&\n     Set.is_empty (DList_set dxs) =\n     (case ID CEQ('a) of\n      None \\<Rightarrow>\n        Code.abort STR ''is_empty DList_set: ceq = None''\n         (\\<lambda>_. Set.is_empty (DList_set dxs))\n      | Some x \\<Rightarrow> DList_Set.null dxs) &&&\n     Set.is_empty (RBT_set rbt) =\n     (case ID ccompare of\n      None \\<Rightarrow>\n        Code.abort STR ''is_empty RBT_set: ccompare = None''\n         (\\<lambda>_. Set.is_empty (RBT_set rbt))\n      | Some x \\<Rightarrow> RBT_Set2.is_empty rbt)) &&&\n    Set.is_empty (Complement A) = is_UNIV A", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. Set.is_empty (Set_Monad xs) = (xs = [])\n 2. Set.is_empty (DList_set dxs) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''is_empty DList_set: ceq = None''\n        (\\<lambda>_. Set.is_empty (DList_set dxs))\n     | Some x \\<Rightarrow> DList_Set.null dxs)\n 3. Set.is_empty (RBT_set rbt) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''is_empty RBT_set: ccompare = None''\n        (\\<lambda>_. Set.is_empty (RBT_set rbt))\n     | Some x \\<Rightarrow> RBT_Set2.is_empty rbt)\n 4. Set.is_empty (Complement A) = is_UNIV A", "show ?DList_set"], ["proof (prove)\ngoal (1 subgoal):\n 1. Set.is_empty (DList_set dxs) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''is_empty DList_set: ceq = None''\n        (\\<lambda>_. Set.is_empty (DList_set dxs))\n     | Some x \\<Rightarrow> DList_Set.null dxs)", "by(clarsimp simp add: DList_set_def Set.is_empty_def DList_Set.member_empty_empty split: option.split)"], ["proof (state)\nthis:\n  Set.is_empty (DList_set dxs) =\n  (case ID CEQ('a) of\n   None \\<Rightarrow>\n     Code.abort STR ''is_empty DList_set: ceq = None''\n      (\\<lambda>_. Set.is_empty (DList_set dxs))\n   | Some x \\<Rightarrow> DList_Set.null dxs)\n\ngoal (3 subgoals):\n 1. Set.is_empty (Set_Monad xs) = (xs = [])\n 2. Set.is_empty (RBT_set rbt) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''is_empty RBT_set: ccompare = None''\n        (\\<lambda>_. Set.is_empty (RBT_set rbt))\n     | Some x \\<Rightarrow> RBT_Set2.is_empty rbt)\n 3. Set.is_empty (Complement A) = is_UNIV A", "show ?RBT_set"], ["proof (prove)\ngoal (1 subgoal):\n 1. Set.is_empty (RBT_set rbt) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''is_empty RBT_set: ccompare = None''\n        (\\<lambda>_. Set.is_empty (RBT_set rbt))\n     | Some x \\<Rightarrow> RBT_Set2.is_empty rbt)", "by(clarsimp simp add: RBT_set_def Set.is_empty_def RBT_Set2.member_empty_empty[symmetric] fun_eq_iff simp del: RBT_Set2.member_empty_empty split: option.split)"], ["proof (state)\nthis:\n  Set.is_empty (RBT_set rbt) =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''is_empty RBT_set: ccompare = None''\n      (\\<lambda>_. Set.is_empty (RBT_set rbt))\n   | Some x \\<Rightarrow> RBT_Set2.is_empty rbt)\n\ngoal (2 subgoals):\n 1. Set.is_empty (Set_Monad xs) = (xs = [])\n 2. Set.is_empty (Complement A) = is_UNIV A", "show ?Complement"], ["proof (prove)\ngoal (1 subgoal):\n 1. Set.is_empty (Complement A) = is_UNIV A", "by(auto simp add: is_UNIV_def Set.is_empty_def)"], ["proof (state)\nthis:\n  Set.is_empty (Complement A) = is_UNIV A\n\ngoal (1 subgoal):\n 1. Set.is_empty (Set_Monad xs) = (xs = [])", "qed(simp_all add: Set.is_empty_def List.null_def)"], ["", "lemma Set_insert_code [code]:\n  fixes dxs :: \"'a :: ceq set_dlist\" \n  and rbt :: \"'b :: ccompare set_rbt\" shows\n  \"\\<And>x. Set.insert x (Collect_set A) = \n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''insert Collect_set: ceq = None'') (\\<lambda>_. Set.insert x (Collect_set A))\n                | Some eq \\<Rightarrow> Collect_set (equal_base.fun_upd eq A x True))\"\n  \"\\<And>x. Set.insert x (Set_Monad xs) = Set_Monad (x # xs)\"\n  \"\\<And>x. Set.insert x (DList_set dxs) =\n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''insert DList_set: ceq = None'') (\\<lambda>_. Set.insert x (DList_set dxs))\n                  | Some _ \\<Rightarrow> DList_set (DList_Set.insert x dxs))\"\n  \"\\<And>x. Set.insert x (RBT_set rbt) =\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''insert RBT_set: ccompare = None'') (\\<lambda>_. Set.insert x (RBT_set rbt))\n                     | Some _ \\<Rightarrow> RBT_set (RBT_Set2.insert x rbt))\"\n  and insert_Complement [set_complement_code]:\n  \"\\<And>x. Set.insert x (Complement X) = Complement (Set.remove x X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((\\<And>x.\n          insert x (Collect_set A) =\n          (case ID CEQ('a) of\n           None \\<Rightarrow>\n             Code.abort STR ''insert Collect_set: ceq = None''\n              (\\<lambda>_. insert x (Collect_set A))\n           | Some eq \\<Rightarrow>\n               Collect_set (equal_base.fun_upd eq A x True))) &&&\n      (\\<And>x. insert x (Set_Monad xs) = Set_Monad (x # xs))) &&&\n     (\\<And>x.\n         insert x (DList_set dxs) =\n         (case ID CEQ('a) of\n          None \\<Rightarrow>\n            Code.abort STR ''insert DList_set: ceq = None''\n             (\\<lambda>_. insert x (DList_set dxs))\n          | Some xa \\<Rightarrow> DList_set (DList_Set.insert x dxs))) &&&\n     (\\<And>x.\n         insert x (RBT_set rbt) =\n         (case ID ccompare of\n          None \\<Rightarrow>\n            Code.abort STR ''insert RBT_set: ccompare = None''\n             (\\<lambda>_. insert x (RBT_set rbt))\n          | Some xa \\<Rightarrow> RBT_set (RBT_Set2.insert x rbt)))) &&&\n    (\\<And>x. insert x (Complement X) = Complement (Set.remove x X))", "by(auto split: option.split dest: equal.equal_eq[OF ID_ceq] simp add: DList_set_def DList_Set.member_insert RBT_set_def)"], ["", "lemma Set_member_code [code]:\n  fixes xs :: \"'a :: ceq list\" shows\n  \"\\<And>x. x \\<in> Collect_set A \\<longleftrightarrow> A x\"\n  \"\\<And>x. x \\<in> DList_set dxs \\<longleftrightarrow> DList_Set.member dxs x\"\n  \"\\<And>x. x \\<in> RBT_set rbt \\<longleftrightarrow> RBT_Set2.member rbt x\"\n  and mem_Complement [set_complement_code]:\n  \"\\<And>x. x \\<in> Complement X \\<longleftrightarrow> x \\<notin> X\"\n  and\n  \"\\<And>x. x \\<in> Set_Monad xs \\<longleftrightarrow>\n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''member Set_Monad: ceq = None'') (\\<lambda>_. x \\<in> Set_Monad xs)\n                 | Some eq \\<Rightarrow> equal_base.list_member eq xs x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<And>x. (x \\<in> Collect_set A) = A x) &&&\n     (\\<And>x. (x \\<in> DList_set dxs) = DList_Set.member dxs x) &&&\n     (\\<And>x. (x \\<in> RBT_set rbt) = RBT_Set2.member rbt x)) &&&\n    (\\<And>x. (x \\<in> Complement X) = (x \\<notin> X)) &&&\n    (\\<And>x.\n        (x \\<in> Set_Monad xs) =\n        (case ID CEQ('a) of\n         None \\<Rightarrow>\n           Code.abort STR ''member Set_Monad: ceq = None''\n            (\\<lambda>_. x \\<in> Set_Monad xs)\n         | Some eq \\<Rightarrow> equal_base.list_member eq xs x))", "by(auto simp add: DList_set_def RBT_set_def List.member_def split: option.split dest!: Collection_Eq.ID_ceq)"], ["", "lemma Set_remove_code [code]:\n  fixes rbt :: \"'a :: ccompare set_rbt\"\n  and dxs :: \"'b :: ceq set_dlist\" shows\n  \"\\<And>x. Set.remove x (Collect_set A) =\n  (case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''remove Collect: ceq = None'') (\\<lambda>_. Set.remove x (Collect_set A))\n                 | Some eq \\<Rightarrow> Collect_set (equal_base.fun_upd eq A x False))\"\n  \"\\<And>x. Set.remove x (DList_set dxs) = \n  (case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''remove DList_set: ceq = None'') (\\<lambda>_. Set.remove x (DList_set dxs))\n                  | Some _ \\<Rightarrow> DList_set (DList_Set.remove x dxs))\"\n  \"\\<And>x. Set.remove x (RBT_set rbt) =\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''remove RBT_set: ccompare = None'') (\\<lambda>_. Set.remove x (RBT_set rbt))\n                     | Some _ \\<Rightarrow> RBT_set (RBT_Set2.remove x rbt))\"\n  and remove_Complement [set_complement_code]:\n  \"\\<And>x A. Set.remove x (Complement A) = Complement (Set.insert x A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<And>x.\n         Set.remove x (Collect_set A) =\n         (case ID CEQ('b) of\n          None \\<Rightarrow>\n            Code.abort STR ''remove Collect: ceq = None''\n             (\\<lambda>_. Set.remove x (Collect_set A))\n          | Some eq \\<Rightarrow>\n              Collect_set (equal_base.fun_upd eq A x False))) &&&\n     (\\<And>x.\n         Set.remove x (DList_set dxs) =\n         (case ID CEQ('b) of\n          None \\<Rightarrow>\n            Code.abort STR ''remove DList_set: ceq = None''\n             (\\<lambda>_. Set.remove x (DList_set dxs))\n          | Some xa \\<Rightarrow> DList_set (DList_Set.remove x dxs))) &&&\n     (\\<And>x.\n         Set.remove x (RBT_set rbt) =\n         (case ID ccompare of\n          None \\<Rightarrow>\n            Code.abort STR ''remove RBT_set: ccompare = None''\n             (\\<lambda>_. Set.remove x (RBT_set rbt))\n          | Some xa \\<Rightarrow> RBT_set (RBT_Set2.remove x rbt)))) &&&\n    (\\<And>x A. Set.remove x (Complement A) = Complement (insert x A))", "by(auto split: option.split if_split_asm dest: equal.equal_eq[OF ID_ceq] simp add: DList_set_def DList_Set.member_remove RBT_set_def)"], ["", "lemma Set_uminus_code [code, set_complement_code]:\n  \"- A = Complement A\"\n  \"- (Collect_set P) = Collect_set (\\<lambda>x. \\<not> P x)\"\n  \"- (Complement B) = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - A = Complement A &&&\n    - Collect_set P = Collect_set (\\<lambda>x. \\<not> P x) &&&\n    - Complement B = B", "by auto"], ["", "text \\<open>\n  These equations represent complements as true complements.\n  If you want that the complement operations returns an explicit enumeration of the elements, use the following set of equations which use @{class cenum}.\n\\<close>"], ["", "lemma Set_uminus_cenum:\n  fixes A :: \"'a :: cenum set\" shows\n  \"- A =\n  (case ID CENUM('a) of None \\<Rightarrow> Complement A\n            | Some (enum, _) \\<Rightarrow> Set_Monad (filter (\\<lambda>x. x \\<notin> A) enum))\"\n  and \"- (Complement B) = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - A =\n    (case ID CENUM('a) of None \\<Rightarrow> Complement A\n     | Some (enum, x) \\<Rightarrow>\n         Set_Monad (filter (\\<lambda>x. x \\<notin> A) enum)) &&&\n    - Complement B = B", "by(auto split: option.split dest: ID_cEnum)"], ["", "lemma Set_minus_code [code]: \"A - B = A \\<inter> (- B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A - B = A \\<inter> - B", "by(rule Diff_eq)"], ["", "lemma Set_union_code [code]:\n  fixes rbt1 rbt2 :: \"'a :: ccompare set_rbt\"\n  and rbt :: \"'b :: {ccompare, ceq} set_rbt\"\n  and dxs :: \"'b set_dlist\"\n  and dxs1 dxs2 :: \"'c :: ceq set_dlist\" shows\n  \"RBT_set rbt1 \\<union> RBT_set rbt2 =\n   (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''union RBT_set RBT_set: ccompare = None'') (\\<lambda>_. RBT_set rbt1 \\<union> RBT_set rbt2)\n                      | Some _ \\<Rightarrow> RBT_set (RBT_Set2.union rbt1 rbt2))\" (is ?RBT_set_RBT_set)\n  \"RBT_set rbt \\<union> DList_set dxs =\n   (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''union RBT_set DList_set: ccompare = None'') (\\<lambda>_. RBT_set rbt \\<union> DList_set dxs)\n                      | Some _ \\<Rightarrow>\n       case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''union RBT_set DList_set: ceq = None'') (\\<lambda>_. RBT_set rbt \\<union> DList_set dxs)\n                      | Some _ \\<Rightarrow> RBT_set (DList_Set.fold RBT_Set2.insert dxs rbt))\" (is ?RBT_set_DList_set)\n  \"DList_set dxs \\<union> RBT_set rbt =\n   (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''union DList_set RBT_set: ccompare = None'') (\\<lambda>_. RBT_set rbt \\<union> DList_set dxs)\n                      | Some _ \\<Rightarrow>\n       case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''union DList_set RBT_set: ceq = None'') (\\<lambda>_. RBT_set rbt \\<union> DList_set dxs)\n                      | Some _ \\<Rightarrow> RBT_set (DList_Set.fold RBT_Set2.insert dxs rbt))\" (is ?DList_set_RBT_set)\n  \"DList_set dxs1 \\<union> DList_set dxs2 = \n   (case ID CEQ('c) of None \\<Rightarrow> Code.abort (STR ''union DList_set DList_set: ceq = None'') (\\<lambda>_. DList_set dxs1 \\<union> DList_set dxs2)\n                      | Some _ \\<Rightarrow> DList_set (DList_Set.union dxs1 dxs2))\" (is ?DList_set_DList_set)\n  \"Set_Monad zs \\<union> RBT_set rbt2 =\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''union Set_Monad RBT_set: ccompare = None'') (\\<lambda>_. Set_Monad zs \\<union> RBT_set rbt2)\n                      | Some _ \\<Rightarrow> RBT_set (fold RBT_Set2.insert zs rbt2))\" (is ?Set_Monad_RBT_set)\n  \"RBT_set rbt1 \\<union> Set_Monad zs =\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''union RBT_set Set_Monad: ccompare = None'') (\\<lambda>_. RBT_set rbt1 \\<union> Set_Monad zs)\n                      | Some _ \\<Rightarrow> RBT_set (fold RBT_Set2.insert zs rbt1))\" (is ?RBT_set_Set_Monad)\n  \"Set_Monad ws \\<union> DList_set dxs2 =\n  (case ID CEQ('c) of None \\<Rightarrow> Code.abort (STR ''union Set_Monad DList_set: ceq = None'') (\\<lambda>_. Set_Monad ws \\<union> DList_set dxs2)\n                  | Some _ \\<Rightarrow> DList_set (fold DList_Set.insert ws dxs2))\" (is ?Set_Monad_DList_set)\n  \"DList_set dxs1 \\<union> Set_Monad ws =\n  (case ID CEQ('c) of None \\<Rightarrow> Code.abort (STR ''union DList_set Set_Monad: ceq = None'') (\\<lambda>_. DList_set dxs1 \\<union> Set_Monad ws)\n                  | Some _ \\<Rightarrow> DList_set (fold DList_Set.insert ws dxs1))\" (is ?DList_set_Set_Monad)\n  \"Set_Monad xs \\<union> Set_Monad ys = Set_Monad (xs @ ys)\"\n  \"Collect_set A \\<union> B = Collect_set (\\<lambda>x. A x \\<or> x \\<in> B)\"\n  \"B \\<union> Collect_set A = Collect_set (\\<lambda>x. A x \\<or> x \\<in> B)\"\n  and Set_union_Complement [set_complement_code]:\n  \"Complement B \\<union> B' = Complement (B \\<inter> - B')\"\n  \"B' \\<union> Complement B = Complement (- B' \\<inter> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((RBT_set rbt1 \\<union> RBT_set rbt2 =\n       (case ID ccompare of\n        None \\<Rightarrow>\n          Code.abort STR ''union RBT_set RBT_set: ccompare = None''\n           (\\<lambda>_. RBT_set rbt1 \\<union> RBT_set rbt2)\n        | Some x \\<Rightarrow> RBT_set (RBT_Set2.union rbt1 rbt2)) &&&\n       RBT_set rbt \\<union> DList_set dxs =\n       (case ID ccompare of\n        None \\<Rightarrow>\n          Code.abort STR ''union RBT_set DList_set: ccompare = None''\n           (\\<lambda>_. RBT_set rbt \\<union> DList_set dxs)\n        | Some x \\<Rightarrow>\n            case ID CEQ('b) of\n            None \\<Rightarrow>\n              Code.abort STR ''union RBT_set DList_set: ceq = None''\n               (\\<lambda>_. RBT_set rbt \\<union> DList_set dxs)\n            | Some x \\<Rightarrow>\n                RBT_set (DList_Set.fold RBT_Set2.insert dxs rbt))) &&&\n      DList_set dxs \\<union> RBT_set rbt =\n      (case ID ccompare of\n       None \\<Rightarrow>\n         Code.abort STR ''union DList_set RBT_set: ccompare = None''\n          (\\<lambda>_. RBT_set rbt \\<union> DList_set dxs)\n       | Some x \\<Rightarrow>\n           case ID CEQ('b) of\n           None \\<Rightarrow>\n             Code.abort STR ''union DList_set RBT_set: ceq = None''\n              (\\<lambda>_. RBT_set rbt \\<union> DList_set dxs)\n           | Some x \\<Rightarrow>\n               RBT_set (DList_Set.fold RBT_Set2.insert dxs rbt)) &&&\n      DList_set dxs1 \\<union> DList_set dxs2 =\n      (case ID CEQ('c) of\n       None \\<Rightarrow>\n         Code.abort STR ''union DList_set DList_set: ceq = None''\n          (\\<lambda>_. DList_set dxs1 \\<union> DList_set dxs2)\n       | Some x \\<Rightarrow> DList_set (DList_Set.union dxs1 dxs2)) &&&\n      Set_Monad zs \\<union> RBT_set rbt2 =\n      (case ID ccompare of\n       None \\<Rightarrow>\n         Code.abort STR ''union Set_Monad RBT_set: ccompare = None''\n          (\\<lambda>_. Set_Monad zs \\<union> RBT_set rbt2)\n       | Some x \\<Rightarrow> RBT_set (fold RBT_Set2.insert zs rbt2))) &&&\n     (RBT_set rbt1 \\<union> Set_Monad zs =\n      (case ID ccompare of\n       None \\<Rightarrow>\n         Code.abort STR ''union RBT_set Set_Monad: ccompare = None''\n          (\\<lambda>_. RBT_set rbt1 \\<union> Set_Monad zs)\n       | Some x \\<Rightarrow> RBT_set (fold RBT_Set2.insert zs rbt1)) &&&\n      Set_Monad ws \\<union> DList_set dxs2 =\n      (case ID CEQ('c) of\n       None \\<Rightarrow>\n         Code.abort STR ''union Set_Monad DList_set: ceq = None''\n          (\\<lambda>_. Set_Monad ws \\<union> DList_set dxs2)\n       | Some x \\<Rightarrow> DList_set (fold DList_Set.insert ws dxs2)) &&&\n      DList_set dxs1 \\<union> Set_Monad ws =\n      (case ID CEQ('c) of\n       None \\<Rightarrow>\n         Code.abort STR ''union DList_set Set_Monad: ceq = None''\n          (\\<lambda>_. DList_set dxs1 \\<union> Set_Monad ws)\n       | Some x \\<Rightarrow>\n           DList_set (fold DList_Set.insert ws dxs1))) &&&\n     Set_Monad xs \\<union> Set_Monad ys = Set_Monad (xs @ ys) &&&\n     Collect_set A \\<union> B =\n     Collect_set (\\<lambda>x. A x \\<or> x \\<in> B) &&&\n     B \\<union> Collect_set A =\n     Collect_set (\\<lambda>x. A x \\<or> x \\<in> B)) &&&\n    Complement B \\<union> B' = Complement (B \\<inter> - B') &&&\n    B' \\<union> Complement B = Complement (- B' \\<inter> B)", "proof -"], ["proof (state)\ngoal (13 subgoals):\n 1. RBT_set rbt1 \\<union> RBT_set rbt2 =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''union RBT_set RBT_set: ccompare = None''\n        (\\<lambda>_. RBT_set rbt1 \\<union> RBT_set rbt2)\n     | Some x \\<Rightarrow> RBT_set (RBT_Set2.union rbt1 rbt2))\n 2. RBT_set rbt \\<union> DList_set dxs =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''union RBT_set DList_set: ccompare = None''\n        (\\<lambda>_. RBT_set rbt \\<union> DList_set dxs)\n     | Some x \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           Code.abort STR ''union RBT_set DList_set: ceq = None''\n            (\\<lambda>_. RBT_set rbt \\<union> DList_set dxs)\n         | Some x \\<Rightarrow>\n             RBT_set (DList_Set.fold RBT_Set2.insert dxs rbt))\n 3. DList_set dxs \\<union> RBT_set rbt =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''union DList_set RBT_set: ccompare = None''\n        (\\<lambda>_. RBT_set rbt \\<union> DList_set dxs)\n     | Some x \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           Code.abort STR ''union DList_set RBT_set: ceq = None''\n            (\\<lambda>_. RBT_set rbt \\<union> DList_set dxs)\n         | Some x \\<Rightarrow>\n             RBT_set (DList_Set.fold RBT_Set2.insert dxs rbt))\n 4. DList_set dxs1 \\<union> DList_set dxs2 =\n    (case ID CEQ('c) of\n     None \\<Rightarrow>\n       Code.abort STR ''union DList_set DList_set: ceq = None''\n        (\\<lambda>_. DList_set dxs1 \\<union> DList_set dxs2)\n     | Some x \\<Rightarrow> DList_set (DList_Set.union dxs1 dxs2))\n 5. Set_Monad zs \\<union> RBT_set rbt2 =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''union Set_Monad RBT_set: ccompare = None''\n        (\\<lambda>_. Set_Monad zs \\<union> RBT_set rbt2)\n     | Some x \\<Rightarrow> RBT_set (fold RBT_Set2.insert zs rbt2))\n 6. RBT_set rbt1 \\<union> Set_Monad zs =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''union RBT_set Set_Monad: ccompare = None''\n        (\\<lambda>_. RBT_set rbt1 \\<union> Set_Monad zs)\n     | Some x \\<Rightarrow> RBT_set (fold RBT_Set2.insert zs rbt1))\n 7. Set_Monad ws \\<union> DList_set dxs2 =\n    (case ID CEQ('c) of\n     None \\<Rightarrow>\n       Code.abort STR ''union Set_Monad DList_set: ceq = None''\n        (\\<lambda>_. Set_Monad ws \\<union> DList_set dxs2)\n     | Some x \\<Rightarrow> DList_set (fold DList_Set.insert ws dxs2))\n 8. DList_set dxs1 \\<union> Set_Monad ws =\n    (case ID CEQ('c) of\n     None \\<Rightarrow>\n       Code.abort STR ''union DList_set Set_Monad: ceq = None''\n        (\\<lambda>_. DList_set dxs1 \\<union> Set_Monad ws)\n     | Some x \\<Rightarrow> DList_set (fold DList_Set.insert ws dxs1))\n 9. Set_Monad xs \\<union> Set_Monad ys = Set_Monad (xs @ ys)\n 10. Collect_set A \\<union> B =\n     Collect_set (\\<lambda>x. A x \\<or> x \\<in> B)\nA total of 13 subgoals...", "show ?RBT_set_RBT_set ?Set_Monad_RBT_set ?RBT_set_Set_Monad"], ["proof (prove)\ngoal (1 subgoal):\n 1. RBT_set rbt1 \\<union> RBT_set rbt2 =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''union RBT_set RBT_set: ccompare = None''\n        (\\<lambda>_. RBT_set rbt1 \\<union> RBT_set rbt2)\n     | Some x \\<Rightarrow> RBT_set (RBT_Set2.union rbt1 rbt2)) &&&\n    Set_Monad zs \\<union> RBT_set rbt2 =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''union Set_Monad RBT_set: ccompare = None''\n        (\\<lambda>_. Set_Monad zs \\<union> RBT_set rbt2)\n     | Some x \\<Rightarrow> RBT_set (fold RBT_Set2.insert zs rbt2)) &&&\n    RBT_set rbt1 \\<union> Set_Monad zs =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''union RBT_set Set_Monad: ccompare = None''\n        (\\<lambda>_. RBT_set rbt1 \\<union> Set_Monad zs)\n     | Some x \\<Rightarrow> RBT_set (fold RBT_Set2.insert zs rbt1))", "by(auto split: option.split simp add: RBT_set_def)"], ["proof (state)\nthis:\n  RBT_set rbt1 \\<union> RBT_set rbt2 =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''union RBT_set RBT_set: ccompare = None''\n      (\\<lambda>_. RBT_set rbt1 \\<union> RBT_set rbt2)\n   | Some x \\<Rightarrow> RBT_set (RBT_Set2.union rbt1 rbt2))\n  Set_Monad zs \\<union> RBT_set rbt2 =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''union Set_Monad RBT_set: ccompare = None''\n      (\\<lambda>_. Set_Monad zs \\<union> RBT_set rbt2)\n   | Some x \\<Rightarrow> RBT_set (fold RBT_Set2.insert zs rbt2))\n  RBT_set rbt1 \\<union> Set_Monad zs =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''union RBT_set Set_Monad: ccompare = None''\n      (\\<lambda>_. RBT_set rbt1 \\<union> Set_Monad zs)\n   | Some x \\<Rightarrow> RBT_set (fold RBT_Set2.insert zs rbt1))\n\ngoal (10 subgoals):\n 1. RBT_set rbt \\<union> DList_set dxs =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''union RBT_set DList_set: ccompare = None''\n        (\\<lambda>_. RBT_set rbt \\<union> DList_set dxs)\n     | Some x \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           Code.abort STR ''union RBT_set DList_set: ceq = None''\n            (\\<lambda>_. RBT_set rbt \\<union> DList_set dxs)\n         | Some x \\<Rightarrow>\n             RBT_set (DList_Set.fold RBT_Set2.insert dxs rbt))\n 2. DList_set dxs \\<union> RBT_set rbt =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''union DList_set RBT_set: ccompare = None''\n        (\\<lambda>_. RBT_set rbt \\<union> DList_set dxs)\n     | Some x \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           Code.abort STR ''union DList_set RBT_set: ceq = None''\n            (\\<lambda>_. RBT_set rbt \\<union> DList_set dxs)\n         | Some x \\<Rightarrow>\n             RBT_set (DList_Set.fold RBT_Set2.insert dxs rbt))\n 3. DList_set dxs1 \\<union> DList_set dxs2 =\n    (case ID CEQ('c) of\n     None \\<Rightarrow>\n       Code.abort STR ''union DList_set DList_set: ceq = None''\n        (\\<lambda>_. DList_set dxs1 \\<union> DList_set dxs2)\n     | Some x \\<Rightarrow> DList_set (DList_Set.union dxs1 dxs2))\n 4. Set_Monad ws \\<union> DList_set dxs2 =\n    (case ID CEQ('c) of\n     None \\<Rightarrow>\n       Code.abort STR ''union Set_Monad DList_set: ceq = None''\n        (\\<lambda>_. Set_Monad ws \\<union> DList_set dxs2)\n     | Some x \\<Rightarrow> DList_set (fold DList_Set.insert ws dxs2))\n 5. DList_set dxs1 \\<union> Set_Monad ws =\n    (case ID CEQ('c) of\n     None \\<Rightarrow>\n       Code.abort STR ''union DList_set Set_Monad: ceq = None''\n        (\\<lambda>_. DList_set dxs1 \\<union> Set_Monad ws)\n     | Some x \\<Rightarrow> DList_set (fold DList_Set.insert ws dxs1))\n 6. Set_Monad xs \\<union> Set_Monad ys = Set_Monad (xs @ ys)\n 7. Collect_set A \\<union> B = Collect_set (\\<lambda>x. A x \\<or> x \\<in> B)\n 8. B \\<union> Collect_set A = Collect_set (\\<lambda>x. A x \\<or> x \\<in> B)\n 9. Complement B \\<union> B' = Complement (B \\<inter> - B')\n 10. B' \\<union> Complement B = Complement (- B' \\<inter> B)", "show ?RBT_set_DList_set ?DList_set_RBT_set"], ["proof (prove)\ngoal (1 subgoal):\n 1. RBT_set rbt \\<union> DList_set dxs =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''union RBT_set DList_set: ccompare = None''\n        (\\<lambda>_. RBT_set rbt \\<union> DList_set dxs)\n     | Some x \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           Code.abort STR ''union RBT_set DList_set: ceq = None''\n            (\\<lambda>_. RBT_set rbt \\<union> DList_set dxs)\n         | Some x \\<Rightarrow>\n             RBT_set (DList_Set.fold RBT_Set2.insert dxs rbt)) &&&\n    DList_set dxs \\<union> RBT_set rbt =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''union DList_set RBT_set: ccompare = None''\n        (\\<lambda>_. RBT_set rbt \\<union> DList_set dxs)\n     | Some x \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           Code.abort STR ''union DList_set RBT_set: ceq = None''\n            (\\<lambda>_. RBT_set rbt \\<union> DList_set dxs)\n         | Some x \\<Rightarrow>\n             RBT_set (DList_Set.fold RBT_Set2.insert dxs rbt))", "by(auto split: option.split simp add: RBT_set_def DList_set_def DList_Set.fold_def DList_Set.member_def List.member_def dest: equal.equal_eq[OF ID_ceq])"], ["proof (state)\nthis:\n  RBT_set rbt \\<union> DList_set dxs =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''union RBT_set DList_set: ccompare = None''\n      (\\<lambda>_. RBT_set rbt \\<union> DList_set dxs)\n   | Some x \\<Rightarrow>\n       case ID CEQ('b) of\n       None \\<Rightarrow>\n         Code.abort STR ''union RBT_set DList_set: ceq = None''\n          (\\<lambda>_. RBT_set rbt \\<union> DList_set dxs)\n       | Some x \\<Rightarrow>\n           RBT_set (DList_Set.fold RBT_Set2.insert dxs rbt))\n  DList_set dxs \\<union> RBT_set rbt =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''union DList_set RBT_set: ccompare = None''\n      (\\<lambda>_. RBT_set rbt \\<union> DList_set dxs)\n   | Some x \\<Rightarrow>\n       case ID CEQ('b) of\n       None \\<Rightarrow>\n         Code.abort STR ''union DList_set RBT_set: ceq = None''\n          (\\<lambda>_. RBT_set rbt \\<union> DList_set dxs)\n       | Some x \\<Rightarrow>\n           RBT_set (DList_Set.fold RBT_Set2.insert dxs rbt))\n\ngoal (8 subgoals):\n 1. DList_set dxs1 \\<union> DList_set dxs2 =\n    (case ID CEQ('c) of\n     None \\<Rightarrow>\n       Code.abort STR ''union DList_set DList_set: ceq = None''\n        (\\<lambda>_. DList_set dxs1 \\<union> DList_set dxs2)\n     | Some x \\<Rightarrow> DList_set (DList_Set.union dxs1 dxs2))\n 2. Set_Monad ws \\<union> DList_set dxs2 =\n    (case ID CEQ('c) of\n     None \\<Rightarrow>\n       Code.abort STR ''union Set_Monad DList_set: ceq = None''\n        (\\<lambda>_. Set_Monad ws \\<union> DList_set dxs2)\n     | Some x \\<Rightarrow> DList_set (fold DList_Set.insert ws dxs2))\n 3. DList_set dxs1 \\<union> Set_Monad ws =\n    (case ID CEQ('c) of\n     None \\<Rightarrow>\n       Code.abort STR ''union DList_set Set_Monad: ceq = None''\n        (\\<lambda>_. DList_set dxs1 \\<union> Set_Monad ws)\n     | Some x \\<Rightarrow> DList_set (fold DList_Set.insert ws dxs1))\n 4. Set_Monad xs \\<union> Set_Monad ys = Set_Monad (xs @ ys)\n 5. Collect_set A \\<union> B = Collect_set (\\<lambda>x. A x \\<or> x \\<in> B)\n 6. B \\<union> Collect_set A = Collect_set (\\<lambda>x. A x \\<or> x \\<in> B)\n 7. Complement B \\<union> B' = Complement (B \\<inter> - B')\n 8. B' \\<union> Complement B = Complement (- B' \\<inter> B)", "show ?DList_set_Set_Monad ?Set_Monad_DList_set"], ["proof (prove)\ngoal (1 subgoal):\n 1. DList_set dxs1 \\<union> Set_Monad ws =\n    (case ID CEQ('c) of\n     None \\<Rightarrow>\n       Code.abort STR ''union DList_set Set_Monad: ceq = None''\n        (\\<lambda>_. DList_set dxs1 \\<union> Set_Monad ws)\n     | Some x \\<Rightarrow> DList_set (fold DList_Set.insert ws dxs1)) &&&\n    Set_Monad ws \\<union> DList_set dxs2 =\n    (case ID CEQ('c) of\n     None \\<Rightarrow>\n       Code.abort STR ''union Set_Monad DList_set: ceq = None''\n        (\\<lambda>_. Set_Monad ws \\<union> DList_set dxs2)\n     | Some x \\<Rightarrow> DList_set (fold DList_Set.insert ws dxs2))", "by(auto split: option.split simp add: DList_set_def DList_Set.member_fold_insert)"], ["proof (state)\nthis:\n  DList_set dxs1 \\<union> Set_Monad ws =\n  (case ID CEQ('c) of\n   None \\<Rightarrow>\n     Code.abort STR ''union DList_set Set_Monad: ceq = None''\n      (\\<lambda>_. DList_set dxs1 \\<union> Set_Monad ws)\n   | Some x \\<Rightarrow> DList_set (fold DList_Set.insert ws dxs1))\n  Set_Monad ws \\<union> DList_set dxs2 =\n  (case ID CEQ('c) of\n   None \\<Rightarrow>\n     Code.abort STR ''union Set_Monad DList_set: ceq = None''\n      (\\<lambda>_. Set_Monad ws \\<union> DList_set dxs2)\n   | Some x \\<Rightarrow> DList_set (fold DList_Set.insert ws dxs2))\n\ngoal (6 subgoals):\n 1. DList_set dxs1 \\<union> DList_set dxs2 =\n    (case ID CEQ('c) of\n     None \\<Rightarrow>\n       Code.abort STR ''union DList_set DList_set: ceq = None''\n        (\\<lambda>_. DList_set dxs1 \\<union> DList_set dxs2)\n     | Some x \\<Rightarrow> DList_set (DList_Set.union dxs1 dxs2))\n 2. Set_Monad xs \\<union> Set_Monad ys = Set_Monad (xs @ ys)\n 3. Collect_set A \\<union> B = Collect_set (\\<lambda>x. A x \\<or> x \\<in> B)\n 4. B \\<union> Collect_set A = Collect_set (\\<lambda>x. A x \\<or> x \\<in> B)\n 5. Complement B \\<union> B' = Complement (B \\<inter> - B')\n 6. B' \\<union> Complement B = Complement (- B' \\<inter> B)", "show ?DList_set_DList_set"], ["proof (prove)\ngoal (1 subgoal):\n 1. DList_set dxs1 \\<union> DList_set dxs2 =\n    (case ID CEQ('c) of\n     None \\<Rightarrow>\n       Code.abort STR ''union DList_set DList_set: ceq = None''\n        (\\<lambda>_. DList_set dxs1 \\<union> DList_set dxs2)\n     | Some x \\<Rightarrow> DList_set (DList_Set.union dxs1 dxs2))", "by(auto split: option.split simp add: DList_set_def DList_Set.member_union)"], ["proof (state)\nthis:\n  DList_set dxs1 \\<union> DList_set dxs2 =\n  (case ID CEQ('c) of\n   None \\<Rightarrow>\n     Code.abort STR ''union DList_set DList_set: ceq = None''\n      (\\<lambda>_. DList_set dxs1 \\<union> DList_set dxs2)\n   | Some x \\<Rightarrow> DList_set (DList_Set.union dxs1 dxs2))\n\ngoal (5 subgoals):\n 1. Set_Monad xs \\<union> Set_Monad ys = Set_Monad (xs @ ys)\n 2. Collect_set A \\<union> B = Collect_set (\\<lambda>x. A x \\<or> x \\<in> B)\n 3. B \\<union> Collect_set A = Collect_set (\\<lambda>x. A x \\<or> x \\<in> B)\n 4. Complement B \\<union> B' = Complement (B \\<inter> - B')\n 5. B' \\<union> Complement B = Complement (- B' \\<inter> B)", "qed(auto)"], ["", "lemma Set_inter_code [code]:\n  fixes rbt1 rbt2 :: \"'a :: ccompare set_rbt\"\n  and rbt :: \"'b :: {ccompare, ceq} set_rbt\"\n  and dxs :: \"'b set_dlist\"\n  and dxs1 dxs2 :: \"'c :: ceq set_dlist\" \n  and xs1 xs2 :: \"'c list\"\n  shows\n  \"Collect_set A'' \\<inter> J = Collect_set (\\<lambda>x. A'' x \\<and> x \\<in> J)\" (is ?collect1)\n  \"J \\<inter> Collect_set A'' = Collect_set (\\<lambda>x. A'' x \\<and> x \\<in> J)\" (is ?collect2)\n\n  \"Set_Monad xs'' \\<inter> I = Set_Monad (filter (\\<lambda>x. x \\<in> I) xs'')\" (is ?monad1)\n  \"I \\<inter> Set_Monad xs'' = Set_Monad (filter (\\<lambda>x. x \\<in> I) xs'')\" (is ?monad2)\n\n  \"DList_set dxs1 \\<inter> H =\n   (case ID CEQ('c) of None \\<Rightarrow> Code.abort (STR ''inter DList_set1: ceq = None'') (\\<lambda>_. DList_set dxs1 \\<inter> H)\n                  | Some eq \\<Rightarrow> DList_set (DList_Set.filter (\\<lambda>x. x \\<in> H) dxs1))\" (is ?dlist1)\n  \"H \\<inter> DList_set dxs2 =\n   (case ID CEQ('c) of None \\<Rightarrow> Code.abort (STR ''inter DList_set2: ceq = None'') (\\<lambda>_. H \\<inter> DList_set dxs2)\n                  | Some eq \\<Rightarrow> DList_set (DList_Set.filter (\\<lambda>x. x \\<in> H) dxs2))\" (is ?dlist2)\n\n  \"RBT_set rbt1 \\<inter> G =\n   (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''inter RBT_set1: ccompare = None'') (\\<lambda>_. RBT_set rbt1 \\<inter> G)\n                      | Some _ \\<Rightarrow> RBT_set (RBT_Set2.filter (\\<lambda>x. x \\<in> G) rbt1))\" (is ?rbt1)\n  \"G \\<inter> RBT_set rbt2 =\n   (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''inter RBT_set2: ccompare = None'') (\\<lambda>_. G \\<inter> RBT_set rbt2)\n                      | Some _ \\<Rightarrow> RBT_set (RBT_Set2.filter (\\<lambda>x. x \\<in> G) rbt2))\" (is ?rbt2)\n  and Set_inter_Complement [set_complement_code]:\n  \"Complement B'' \\<inter> Complement B''' = Complement (B'' \\<union> B''')\" (is ?complement)\n  and\n  \"Set_Monad xs \\<inter> RBT_set rbt1 =\n   (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''inter Set_Monad RBT_set: ccompare = None'') (\\<lambda>_. RBT_set rbt1 \\<inter> Set_Monad xs)\n                      | Some _ \\<Rightarrow> RBT_set (RBT_Set2.inter_list rbt1 xs))\" (is ?monad_rbt)\n  \"Set_Monad xs' \\<inter> DList_set dxs2 =\n   (case ID CEQ('c) of None \\<Rightarrow> Code.abort (STR ''inter Set_Monad DList_set: ceq = None'') (\\<lambda>_. Set_Monad xs' \\<inter> DList_set dxs2)\n                  | Some eq \\<Rightarrow> DList_set (DList_Set.filter (equal_base.list_member eq xs') dxs2))\" (is ?monad_dlist)\n  \"Set_Monad xs1 \\<inter> Set_Monad xs2 =\n  (case ID CEQ('c) of None \\<Rightarrow> Code.abort (STR ''inter Set_Monad Set_Monad: ceq = None'') (\\<lambda>_. Set_Monad xs1 \\<inter> Set_Monad xs2)\n                 | Some eq \\<Rightarrow> Set_Monad (filter (equal_base.list_member eq xs2) xs1))\" (is ?monad)\n\n  \"DList_set dxs \\<inter> RBT_set rbt = \n   (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''inter DList_set RBT_set: ccompare = None'') (\\<lambda>_. DList_set dxs \\<inter> RBT_set rbt)\n                      | Some _ \\<Rightarrow>\n       case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''inter DList_set RBT_set: ceq = None'') (\\<lambda>_. DList_set dxs \\<inter> RBT_set rbt)\n                      | Some _ \\<Rightarrow> RBT_set (RBT_Set2.inter_list rbt (list_of_dlist dxs)))\" (is ?dlist_rbt)\n  \"DList_set dxs1 \\<inter> DList_set dxs2 =\n   (case ID CEQ('c) of None \\<Rightarrow> Code.abort (STR ''inter DList_set DList_set: ceq = None'') (\\<lambda>_. DList_set dxs1 \\<inter> DList_set dxs2)\n                   | Some _ \\<Rightarrow> DList_set (DList_Set.filter (DList_Set.member dxs2) dxs1))\" (is ?dlist)\n  \"DList_set dxs1 \\<inter> Set_Monad xs' =\n   (case ID CEQ('c) of None \\<Rightarrow> Code.abort (STR ''inter DList_set Set_Monad: ceq = None'') (\\<lambda>_. DList_set dxs1 \\<inter> Set_Monad xs')\n                  | Some eq \\<Rightarrow> DList_set (DList_Set.filter (equal_base.list_member eq xs') dxs1))\" (is ?dlist_monad)\n\n  \"RBT_set rbt1 \\<inter> RBT_set rbt2 =\n   (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''inter RBT_set RBT_set: ccompare = None'') (\\<lambda>_. RBT_set rbt1 \\<inter> RBT_set rbt2)\n                      | Some _ \\<Rightarrow> RBT_set (RBT_Set2.inter rbt1 rbt2))\" (is ?rbt_rbt)\n  \"RBT_set rbt \\<inter> DList_set dxs = \n   (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''inter RBT_set DList_set: ccompare = None'') (\\<lambda>_. RBT_set rbt \\<inter> DList_set dxs)\n                      | Some _ \\<Rightarrow>\n       case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''inter RBT_set DList_set: ceq = None'') (\\<lambda>_. RBT_set rbt \\<inter> DList_set dxs)\n                      | Some _ \\<Rightarrow> RBT_set (RBT_Set2.inter_list rbt (list_of_dlist dxs)))\" (is ?rbt_dlist)\n  \"RBT_set rbt1 \\<inter> Set_Monad xs =\n   (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''inter RBT_set Set_Monad: ccompare = None'') (\\<lambda>_. RBT_set rbt1 \\<inter> Set_Monad xs)\n                      | Some _ \\<Rightarrow> RBT_set (RBT_Set2.inter_list rbt1 xs))\" (is ?rbt_monad)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((Collect_set A'' \\<inter> J =\n       Collect_set (\\<lambda>x. A'' x \\<and> x \\<in> J) &&&\n       J \\<inter> Collect_set A'' =\n       Collect_set (\\<lambda>x. A'' x \\<and> x \\<in> J)) &&&\n      Set_Monad xs'' \\<inter> I =\n      Set_Monad (filter (\\<lambda>x. x \\<in> I) xs'') &&&\n      I \\<inter> Set_Monad xs'' =\n      Set_Monad (filter (\\<lambda>x. x \\<in> I) xs'')) &&&\n     (DList_set dxs1 \\<inter> H =\n      (case ID CEQ('c) of\n       None \\<Rightarrow>\n         Code.abort STR ''inter DList_set1: ceq = None''\n          (\\<lambda>_. DList_set dxs1 \\<inter> H)\n       | Some eq \\<Rightarrow>\n           DList_set (DList_Set.filter (\\<lambda>x. x \\<in> H) dxs1)) &&&\n      H \\<inter> DList_set dxs2 =\n      (case ID CEQ('c) of\n       None \\<Rightarrow>\n         Code.abort STR ''inter DList_set2: ceq = None''\n          (\\<lambda>_. H \\<inter> DList_set dxs2)\n       | Some eq \\<Rightarrow>\n           DList_set (DList_Set.filter (\\<lambda>x. x \\<in> H) dxs2))) &&&\n     RBT_set rbt1 \\<inter> G =\n     (case ID ccompare of\n      None \\<Rightarrow>\n        Code.abort STR ''inter RBT_set1: ccompare = None''\n         (\\<lambda>_. RBT_set rbt1 \\<inter> G)\n      | Some x \\<Rightarrow>\n          RBT_set (RBT_Set2.filter (\\<lambda>x. x \\<in> G) rbt1)) &&&\n     G \\<inter> RBT_set rbt2 =\n     (case ID ccompare of\n      None \\<Rightarrow>\n        Code.abort STR ''inter RBT_set2: ccompare = None''\n         (\\<lambda>_. G \\<inter> RBT_set rbt2)\n      | Some x \\<Rightarrow>\n          RBT_set (RBT_Set2.filter (\\<lambda>x. x \\<in> G) rbt2))) &&&\n    Complement B'' \\<inter> Complement B''' =\n    Complement (B'' \\<union> B''') &&&\n    ((Set_Monad xs \\<inter> RBT_set rbt1 =\n      (case ID ccompare of\n       None \\<Rightarrow>\n         Code.abort STR ''inter Set_Monad RBT_set: ccompare = None''\n          (\\<lambda>_. RBT_set rbt1 \\<inter> Set_Monad xs)\n       | Some x \\<Rightarrow> RBT_set (inter_list rbt1 xs)) &&&\n      Set_Monad xs' \\<inter> DList_set dxs2 =\n      (case ID CEQ('c) of\n       None \\<Rightarrow>\n         Code.abort STR ''inter Set_Monad DList_set: ceq = None''\n          (\\<lambda>_. Set_Monad xs' \\<inter> DList_set dxs2)\n       | Some eq \\<Rightarrow>\n           DList_set\n            (DList_Set.filter (equal_base.list_member eq xs') dxs2))) &&&\n     Set_Monad xs1 \\<inter> Set_Monad xs2 =\n     (case ID CEQ('c) of\n      None \\<Rightarrow>\n        Code.abort STR ''inter Set_Monad Set_Monad: ceq = None''\n         (\\<lambda>_. Set_Monad xs1 \\<inter> Set_Monad xs2)\n      | Some eq \\<Rightarrow>\n          Set_Monad (filter (equal_base.list_member eq xs2) xs1)) &&&\n     DList_set dxs \\<inter> RBT_set rbt =\n     (case ID ccompare of\n      None \\<Rightarrow>\n        Code.abort STR ''inter DList_set RBT_set: ccompare = None''\n         (\\<lambda>_. DList_set dxs \\<inter> RBT_set rbt)\n      | Some x \\<Rightarrow>\n          case ID CEQ('b) of\n          None \\<Rightarrow>\n            Code.abort STR ''inter DList_set RBT_set: ceq = None''\n             (\\<lambda>_. DList_set dxs \\<inter> RBT_set rbt)\n          | Some x \\<Rightarrow>\n              RBT_set (inter_list rbt (list_of_dlist dxs)))) &&&\n    (DList_set dxs1 \\<inter> DList_set dxs2 =\n     (case ID CEQ('c) of\n      None \\<Rightarrow>\n        Code.abort STR ''inter DList_set DList_set: ceq = None''\n         (\\<lambda>_. DList_set dxs1 \\<inter> DList_set dxs2)\n      | Some x \\<Rightarrow>\n          DList_set (DList_Set.filter (DList_Set.member dxs2) dxs1)) &&&\n     DList_set dxs1 \\<inter> Set_Monad xs' =\n     (case ID CEQ('c) of\n      None \\<Rightarrow>\n        Code.abort STR ''inter DList_set Set_Monad: ceq = None''\n         (\\<lambda>_. DList_set dxs1 \\<inter> Set_Monad xs')\n      | Some eq \\<Rightarrow>\n          DList_set\n           (DList_Set.filter (equal_base.list_member eq xs') dxs1))) &&&\n    RBT_set rbt1 \\<inter> RBT_set rbt2 =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''inter RBT_set RBT_set: ccompare = None''\n        (\\<lambda>_. RBT_set rbt1 \\<inter> RBT_set rbt2)\n     | Some x \\<Rightarrow> RBT_set (RBT_Set2.inter rbt1 rbt2)) &&&\n    RBT_set rbt \\<inter> DList_set dxs =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''inter RBT_set DList_set: ccompare = None''\n        (\\<lambda>_. RBT_set rbt \\<inter> DList_set dxs)\n     | Some x \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           Code.abort STR ''inter RBT_set DList_set: ceq = None''\n            (\\<lambda>_. RBT_set rbt \\<inter> DList_set dxs)\n         | Some x \\<Rightarrow>\n             RBT_set (inter_list rbt (list_of_dlist dxs))) &&&\n    RBT_set rbt1 \\<inter> Set_Monad xs =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''inter RBT_set Set_Monad: ccompare = None''\n        (\\<lambda>_. RBT_set rbt1 \\<inter> Set_Monad xs)\n     | Some x \\<Rightarrow> RBT_set (inter_list rbt1 xs))", "proof -"], ["proof (state)\ngoal (18 subgoals):\n 1. Collect_set A'' \\<inter> J =\n    Collect_set (\\<lambda>x. A'' x \\<and> x \\<in> J)\n 2. J \\<inter> Collect_set A'' =\n    Collect_set (\\<lambda>x. A'' x \\<and> x \\<in> J)\n 3. Set_Monad xs'' \\<inter> I =\n    Set_Monad (filter (\\<lambda>x. x \\<in> I) xs'')\n 4. I \\<inter> Set_Monad xs'' =\n    Set_Monad (filter (\\<lambda>x. x \\<in> I) xs'')\n 5. DList_set dxs1 \\<inter> H =\n    (case ID CEQ('c) of\n     None \\<Rightarrow>\n       Code.abort STR ''inter DList_set1: ceq = None''\n        (\\<lambda>_. DList_set dxs1 \\<inter> H)\n     | Some eq \\<Rightarrow>\n         DList_set (DList_Set.filter (\\<lambda>x. x \\<in> H) dxs1))\n 6. H \\<inter> DList_set dxs2 =\n    (case ID CEQ('c) of\n     None \\<Rightarrow>\n       Code.abort STR ''inter DList_set2: ceq = None''\n        (\\<lambda>_. H \\<inter> DList_set dxs2)\n     | Some eq \\<Rightarrow>\n         DList_set (DList_Set.filter (\\<lambda>x. x \\<in> H) dxs2))\n 7. RBT_set rbt1 \\<inter> G =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''inter RBT_set1: ccompare = None''\n        (\\<lambda>_. RBT_set rbt1 \\<inter> G)\n     | Some x \\<Rightarrow>\n         RBT_set (RBT_Set2.filter (\\<lambda>x. x \\<in> G) rbt1))\n 8. G \\<inter> RBT_set rbt2 =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''inter RBT_set2: ccompare = None''\n        (\\<lambda>_. G \\<inter> RBT_set rbt2)\n     | Some x \\<Rightarrow>\n         RBT_set (RBT_Set2.filter (\\<lambda>x. x \\<in> G) rbt2))\n 9. Complement B'' \\<inter> Complement B''' = Complement (B'' \\<union> B''')\n 10. Set_Monad xs \\<inter> RBT_set rbt1 =\n     (case ID ccompare of\n      None \\<Rightarrow>\n        Code.abort STR ''inter Set_Monad RBT_set: ccompare = None''\n         (\\<lambda>_. RBT_set rbt1 \\<inter> Set_Monad xs)\n      | Some x \\<Rightarrow> RBT_set (inter_list rbt1 xs))\nA total of 18 subgoals...", "show ?rbt_rbt ?rbt1 ?rbt2 ?rbt_dlist ?rbt_monad ?dlist_rbt ?monad_rbt"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RBT_set rbt1 \\<inter> RBT_set rbt2 =\n     (case ID ccompare of\n      None \\<Rightarrow>\n        Code.abort STR ''inter RBT_set RBT_set: ccompare = None''\n         (\\<lambda>_. RBT_set rbt1 \\<inter> RBT_set rbt2)\n      | Some x \\<Rightarrow> RBT_set (RBT_Set2.inter rbt1 rbt2)) &&&\n     RBT_set rbt1 \\<inter> G =\n     (case ID ccompare of\n      None \\<Rightarrow>\n        Code.abort STR ''inter RBT_set1: ccompare = None''\n         (\\<lambda>_. RBT_set rbt1 \\<inter> G)\n      | Some x \\<Rightarrow>\n          RBT_set (RBT_Set2.filter (\\<lambda>x. x \\<in> G) rbt1)) &&&\n     G \\<inter> RBT_set rbt2 =\n     (case ID ccompare of\n      None \\<Rightarrow>\n        Code.abort STR ''inter RBT_set2: ccompare = None''\n         (\\<lambda>_. G \\<inter> RBT_set rbt2)\n      | Some x \\<Rightarrow>\n          RBT_set (RBT_Set2.filter (\\<lambda>x. x \\<in> G) rbt2))) &&&\n    (RBT_set rbt \\<inter> DList_set dxs =\n     (case ID ccompare of\n      None \\<Rightarrow>\n        Code.abort STR ''inter RBT_set DList_set: ccompare = None''\n         (\\<lambda>_. RBT_set rbt \\<inter> DList_set dxs)\n      | Some x \\<Rightarrow>\n          case ID CEQ('b) of\n          None \\<Rightarrow>\n            Code.abort STR ''inter RBT_set DList_set: ceq = None''\n             (\\<lambda>_. RBT_set rbt \\<inter> DList_set dxs)\n          | Some x \\<Rightarrow>\n              RBT_set (inter_list rbt (list_of_dlist dxs))) &&&\n     RBT_set rbt1 \\<inter> Set_Monad xs =\n     (case ID ccompare of\n      None \\<Rightarrow>\n        Code.abort STR ''inter RBT_set Set_Monad: ccompare = None''\n         (\\<lambda>_. RBT_set rbt1 \\<inter> Set_Monad xs)\n      | Some x \\<Rightarrow> RBT_set (inter_list rbt1 xs))) &&&\n    DList_set dxs \\<inter> RBT_set rbt =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''inter DList_set RBT_set: ccompare = None''\n        (\\<lambda>_. DList_set dxs \\<inter> RBT_set rbt)\n     | Some x \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           Code.abort STR ''inter DList_set RBT_set: ceq = None''\n            (\\<lambda>_. DList_set dxs \\<inter> RBT_set rbt)\n         | Some x \\<Rightarrow>\n             RBT_set (inter_list rbt (list_of_dlist dxs))) &&&\n    Set_Monad xs \\<inter> RBT_set rbt1 =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''inter Set_Monad RBT_set: ccompare = None''\n        (\\<lambda>_. RBT_set rbt1 \\<inter> Set_Monad xs)\n     | Some x \\<Rightarrow> RBT_set (inter_list rbt1 xs))", "by(auto simp add: RBT_set_def DList_set_def DList_Set.member_def List.member_def dest: equal.equal_eq[OF ID_ceq] split: option.split)"], ["proof (state)\nthis:\n  RBT_set rbt1 \\<inter> RBT_set rbt2 =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''inter RBT_set RBT_set: ccompare = None''\n      (\\<lambda>_. RBT_set rbt1 \\<inter> RBT_set rbt2)\n   | Some x \\<Rightarrow> RBT_set (RBT_Set2.inter rbt1 rbt2))\n  RBT_set rbt1 \\<inter> G =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''inter RBT_set1: ccompare = None''\n      (\\<lambda>_. RBT_set rbt1 \\<inter> G)\n   | Some x \\<Rightarrow>\n       RBT_set (RBT_Set2.filter (\\<lambda>x. x \\<in> G) rbt1))\n  G \\<inter> RBT_set rbt2 =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''inter RBT_set2: ccompare = None''\n      (\\<lambda>_. G \\<inter> RBT_set rbt2)\n   | Some x \\<Rightarrow>\n       RBT_set (RBT_Set2.filter (\\<lambda>x. x \\<in> G) rbt2))\n  RBT_set rbt \\<inter> DList_set dxs =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''inter RBT_set DList_set: ccompare = None''\n      (\\<lambda>_. RBT_set rbt \\<inter> DList_set dxs)\n   | Some x \\<Rightarrow>\n       case ID CEQ('b) of\n       None \\<Rightarrow>\n         Code.abort STR ''inter RBT_set DList_set: ceq = None''\n          (\\<lambda>_. RBT_set rbt \\<inter> DList_set dxs)\n       | Some x \\<Rightarrow> RBT_set (inter_list rbt (list_of_dlist dxs)))\n  RBT_set rbt1 \\<inter> Set_Monad xs =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''inter RBT_set Set_Monad: ccompare = None''\n      (\\<lambda>_. RBT_set rbt1 \\<inter> Set_Monad xs)\n   | Some x \\<Rightarrow> RBT_set (inter_list rbt1 xs))\n  DList_set dxs \\<inter> RBT_set rbt =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''inter DList_set RBT_set: ccompare = None''\n      (\\<lambda>_. DList_set dxs \\<inter> RBT_set rbt)\n   | Some x \\<Rightarrow>\n       case ID CEQ('b) of\n       None \\<Rightarrow>\n         Code.abort STR ''inter DList_set RBT_set: ceq = None''\n          (\\<lambda>_. DList_set dxs \\<inter> RBT_set rbt)\n       | Some x \\<Rightarrow> RBT_set (inter_list rbt (list_of_dlist dxs)))\n  Set_Monad xs \\<inter> RBT_set rbt1 =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''inter Set_Monad RBT_set: ccompare = None''\n      (\\<lambda>_. RBT_set rbt1 \\<inter> Set_Monad xs)\n   | Some x \\<Rightarrow> RBT_set (inter_list rbt1 xs))\n\ngoal (11 subgoals):\n 1. Collect_set A'' \\<inter> J =\n    Collect_set (\\<lambda>x. A'' x \\<and> x \\<in> J)\n 2. J \\<inter> Collect_set A'' =\n    Collect_set (\\<lambda>x. A'' x \\<and> x \\<in> J)\n 3. Set_Monad xs'' \\<inter> I =\n    Set_Monad (filter (\\<lambda>x. x \\<in> I) xs'')\n 4. I \\<inter> Set_Monad xs'' =\n    Set_Monad (filter (\\<lambda>x. x \\<in> I) xs'')\n 5. DList_set dxs1 \\<inter> H =\n    (case ID CEQ('c) of\n     None \\<Rightarrow>\n       Code.abort STR ''inter DList_set1: ceq = None''\n        (\\<lambda>_. DList_set dxs1 \\<inter> H)\n     | Some eq \\<Rightarrow>\n         DList_set (DList_Set.filter (\\<lambda>x. x \\<in> H) dxs1))\n 6. H \\<inter> DList_set dxs2 =\n    (case ID CEQ('c) of\n     None \\<Rightarrow>\n       Code.abort STR ''inter DList_set2: ceq = None''\n        (\\<lambda>_. H \\<inter> DList_set dxs2)\n     | Some eq \\<Rightarrow>\n         DList_set (DList_Set.filter (\\<lambda>x. x \\<in> H) dxs2))\n 7. Complement B'' \\<inter> Complement B''' = Complement (B'' \\<union> B''')\n 8. Set_Monad xs' \\<inter> DList_set dxs2 =\n    (case ID CEQ('c) of\n     None \\<Rightarrow>\n       Code.abort STR ''inter Set_Monad DList_set: ceq = None''\n        (\\<lambda>_. Set_Monad xs' \\<inter> DList_set dxs2)\n     | Some eq \\<Rightarrow>\n         DList_set (DList_Set.filter (equal_base.list_member eq xs') dxs2))\n 9. Set_Monad xs1 \\<inter> Set_Monad xs2 =\n    (case ID CEQ('c) of\n     None \\<Rightarrow>\n       Code.abort STR ''inter Set_Monad Set_Monad: ceq = None''\n        (\\<lambda>_. Set_Monad xs1 \\<inter> Set_Monad xs2)\n     | Some eq \\<Rightarrow>\n         Set_Monad (filter (equal_base.list_member eq xs2) xs1))\n 10. DList_set dxs1 \\<inter> DList_set dxs2 =\n     (case ID CEQ('c) of\n      None \\<Rightarrow>\n        Code.abort STR ''inter DList_set DList_set: ceq = None''\n         (\\<lambda>_. DList_set dxs1 \\<inter> DList_set dxs2)\n      | Some x \\<Rightarrow>\n          DList_set (DList_Set.filter (DList_Set.member dxs2) dxs1))\nA total of 11 subgoals...", "show ?dlist ?dlist1 ?dlist2 ?dlist_monad ?monad_dlist ?monad ?monad1 ?monad2 ?collect1 ?collect2 ?complement"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((DList_set dxs1 \\<inter> DList_set dxs2 =\n      (case ID CEQ('c) of\n       None \\<Rightarrow>\n         Code.abort STR ''inter DList_set DList_set: ceq = None''\n          (\\<lambda>_. DList_set dxs1 \\<inter> DList_set dxs2)\n       | Some x \\<Rightarrow>\n           DList_set (DList_Set.filter (DList_Set.member dxs2) dxs1)) &&&\n      DList_set dxs1 \\<inter> H =\n      (case ID CEQ('c) of\n       None \\<Rightarrow>\n         Code.abort STR ''inter DList_set1: ceq = None''\n          (\\<lambda>_. DList_set dxs1 \\<inter> H)\n       | Some eq \\<Rightarrow>\n           DList_set (DList_Set.filter (\\<lambda>x. x \\<in> H) dxs1))) &&&\n     H \\<inter> DList_set dxs2 =\n     (case ID CEQ('c) of\n      None \\<Rightarrow>\n        Code.abort STR ''inter DList_set2: ceq = None''\n         (\\<lambda>_. H \\<inter> DList_set dxs2)\n      | Some eq \\<Rightarrow>\n          DList_set (DList_Set.filter (\\<lambda>x. x \\<in> H) dxs2)) &&&\n     DList_set dxs1 \\<inter> Set_Monad xs' =\n     (case ID CEQ('c) of\n      None \\<Rightarrow>\n        Code.abort STR ''inter DList_set Set_Monad: ceq = None''\n         (\\<lambda>_. DList_set dxs1 \\<inter> Set_Monad xs')\n      | Some eq \\<Rightarrow>\n          DList_set\n           (DList_Set.filter (equal_base.list_member eq xs') dxs1)) &&&\n     Set_Monad xs' \\<inter> DList_set dxs2 =\n     (case ID CEQ('c) of\n      None \\<Rightarrow>\n        Code.abort STR ''inter Set_Monad DList_set: ceq = None''\n         (\\<lambda>_. Set_Monad xs' \\<inter> DList_set dxs2)\n      | Some eq \\<Rightarrow>\n          DList_set\n           (DList_Set.filter (equal_base.list_member eq xs') dxs2))) &&&\n    (Set_Monad xs1 \\<inter> Set_Monad xs2 =\n     (case ID CEQ('c) of\n      None \\<Rightarrow>\n        Code.abort STR ''inter Set_Monad Set_Monad: ceq = None''\n         (\\<lambda>_. Set_Monad xs1 \\<inter> Set_Monad xs2)\n      | Some eq \\<Rightarrow>\n          Set_Monad (filter (equal_base.list_member eq xs2) xs1)) &&&\n     Set_Monad xs'' \\<inter> I =\n     Set_Monad (filter (\\<lambda>x. x \\<in> I) xs'') &&&\n     I \\<inter> Set_Monad xs'' =\n     Set_Monad (filter (\\<lambda>x. x \\<in> I) xs'')) &&&\n    Collect_set A'' \\<inter> J =\n    Collect_set (\\<lambda>x. A'' x \\<and> x \\<in> J) &&&\n    J \\<inter> Collect_set A'' =\n    Collect_set (\\<lambda>x. A'' x \\<and> x \\<in> J) &&&\n    Complement B'' \\<inter> Complement B''' = Complement (B'' \\<union> B''')", "by(auto simp add: DList_set_def List.member_def dest!: Collection_Eq.ID_ceq split: option.splits)"], ["proof (state)\nthis:\n  DList_set dxs1 \\<inter> DList_set dxs2 =\n  (case ID CEQ('c) of\n   None \\<Rightarrow>\n     Code.abort STR ''inter DList_set DList_set: ceq = None''\n      (\\<lambda>_. DList_set dxs1 \\<inter> DList_set dxs2)\n   | Some x \\<Rightarrow>\n       DList_set (DList_Set.filter (DList_Set.member dxs2) dxs1))\n  DList_set dxs1 \\<inter> H =\n  (case ID CEQ('c) of\n   None \\<Rightarrow>\n     Code.abort STR ''inter DList_set1: ceq = None''\n      (\\<lambda>_. DList_set dxs1 \\<inter> H)\n   | Some eq \\<Rightarrow>\n       DList_set (DList_Set.filter (\\<lambda>x. x \\<in> H) dxs1))\n  H \\<inter> DList_set dxs2 =\n  (case ID CEQ('c) of\n   None \\<Rightarrow>\n     Code.abort STR ''inter DList_set2: ceq = None''\n      (\\<lambda>_. H \\<inter> DList_set dxs2)\n   | Some eq \\<Rightarrow>\n       DList_set (DList_Set.filter (\\<lambda>x. x \\<in> H) dxs2))\n  DList_set dxs1 \\<inter> Set_Monad xs' =\n  (case ID CEQ('c) of\n   None \\<Rightarrow>\n     Code.abort STR ''inter DList_set Set_Monad: ceq = None''\n      (\\<lambda>_. DList_set dxs1 \\<inter> Set_Monad xs')\n   | Some eq \\<Rightarrow>\n       DList_set (DList_Set.filter (equal_base.list_member eq xs') dxs1))\n  Set_Monad xs' \\<inter> DList_set dxs2 =\n  (case ID CEQ('c) of\n   None \\<Rightarrow>\n     Code.abort STR ''inter Set_Monad DList_set: ceq = None''\n      (\\<lambda>_. Set_Monad xs' \\<inter> DList_set dxs2)\n   | Some eq \\<Rightarrow>\n       DList_set (DList_Set.filter (equal_base.list_member eq xs') dxs2))\n  Set_Monad xs1 \\<inter> Set_Monad xs2 =\n  (case ID CEQ('c) of\n   None \\<Rightarrow>\n     Code.abort STR ''inter Set_Monad Set_Monad: ceq = None''\n      (\\<lambda>_. Set_Monad xs1 \\<inter> Set_Monad xs2)\n   | Some eq \\<Rightarrow>\n       Set_Monad (filter (equal_base.list_member eq xs2) xs1))\n  Set_Monad xs'' \\<inter> I =\n  Set_Monad (filter (\\<lambda>x. x \\<in> I) xs'')\n  I \\<inter> Set_Monad xs'' =\n  Set_Monad (filter (\\<lambda>x. x \\<in> I) xs'')\n  Collect_set A'' \\<inter> J =\n  Collect_set (\\<lambda>x. A'' x \\<and> x \\<in> J)\n  J \\<inter> Collect_set A'' =\n  Collect_set (\\<lambda>x. A'' x \\<and> x \\<in> J)\n  Complement B'' \\<inter> Complement B''' = Complement (B'' \\<union> B''')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Set_bind_code [code]:\n  fixes dxs :: \"'a :: ceq set_dlist\"\n  and rbt :: \"'b :: ccompare set_rbt\" shows\n  \"Set.bind (Set_Monad xs) f = fold ((\\<union>) \\<circ> f) xs (Set_Monad [])\" (is ?Set_Monad)\n  \"Set.bind (DList_set dxs) f' =\n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''bind DList_set: ceq = None'') (\\<lambda>_. Set.bind (DList_set dxs) f')\n                  | Some _ \\<Rightarrow> DList_Set.fold (union \\<circ> f') dxs {})\" (is ?DList)\n  \"Set.bind (RBT_set rbt) f'' = \n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''bind RBT_set: ccompare = None'') (\\<lambda>_. Set.bind (RBT_set rbt) f'')\n                     | Some _ \\<Rightarrow> RBT_Set2.fold (union \\<circ> f'') rbt {})\" (is ?RBT)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Set_Monad xs \\<bind> f =\n    fold ((\\<union>) \\<circ> f) xs (Set_Monad []) &&&\n    DList_set dxs \\<bind> f' =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''bind DList_set: ceq = None''\n        (\\<lambda>_. DList_set dxs \\<bind> f')\n     | Some x \\<Rightarrow>\n         DList_Set.fold ((\\<union>) \\<circ> f') dxs {}) &&&\n    RBT_set rbt \\<bind> f'' =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''bind RBT_set: ccompare = None''\n        (\\<lambda>_. RBT_set rbt \\<bind> f'')\n     | Some x \\<Rightarrow> RBT_Set2.fold ((\\<union>) \\<circ> f'') rbt {})", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. Set_Monad xs \\<bind> f = fold ((\\<union>) \\<circ> f) xs (Set_Monad [])\n 2. DList_set dxs \\<bind> f' =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''bind DList_set: ceq = None''\n        (\\<lambda>_. DList_set dxs \\<bind> f')\n     | Some x \\<Rightarrow> DList_Set.fold ((\\<union>) \\<circ> f') dxs {})\n 3. RBT_set rbt \\<bind> f'' =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''bind RBT_set: ccompare = None''\n        (\\<lambda>_. RBT_set rbt \\<bind> f'')\n     | Some x \\<Rightarrow> RBT_Set2.fold ((\\<union>) \\<circ> f'') rbt {})", "show ?Set_Monad"], ["proof (prove)\ngoal (1 subgoal):\n 1. Set_Monad xs \\<bind> f = fold ((\\<union>) \\<circ> f) xs (Set_Monad [])", "by(simp add: set_bind_conv_fold)"], ["proof (state)\nthis:\n  Set_Monad xs \\<bind> f = fold ((\\<union>) \\<circ> f) xs (Set_Monad [])\n\ngoal (2 subgoals):\n 1. DList_set dxs \\<bind> f' =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''bind DList_set: ceq = None''\n        (\\<lambda>_. DList_set dxs \\<bind> f')\n     | Some x \\<Rightarrow> DList_Set.fold ((\\<union>) \\<circ> f') dxs {})\n 2. RBT_set rbt \\<bind> f'' =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''bind RBT_set: ccompare = None''\n        (\\<lambda>_. RBT_set rbt \\<bind> f'')\n     | Some x \\<Rightarrow> RBT_Set2.fold ((\\<union>) \\<circ> f'') rbt {})", "show ?DList"], ["proof (prove)\ngoal (1 subgoal):\n 1. DList_set dxs \\<bind> f' =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''bind DList_set: ceq = None''\n        (\\<lambda>_. DList_set dxs \\<bind> f')\n     | Some x \\<Rightarrow> DList_Set.fold ((\\<union>) \\<circ> f') dxs {})", "by(auto simp add: DList_set_def DList_Set.member_def List.member_def List.member_def[abs_def] set_bind_conv_fold DList_Set.fold_def split: option.split dest: equal.equal_eq[OF ID_ceq] ID_ceq)"], ["proof (state)\nthis:\n  DList_set dxs \\<bind> f' =\n  (case ID CEQ('a) of\n   None \\<Rightarrow>\n     Code.abort STR ''bind DList_set: ceq = None''\n      (\\<lambda>_. DList_set dxs \\<bind> f')\n   | Some x \\<Rightarrow> DList_Set.fold ((\\<union>) \\<circ> f') dxs {})\n\ngoal (1 subgoal):\n 1. RBT_set rbt \\<bind> f'' =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''bind RBT_set: ccompare = None''\n        (\\<lambda>_. RBT_set rbt \\<bind> f'')\n     | Some x \\<Rightarrow> RBT_Set2.fold ((\\<union>) \\<circ> f'') rbt {})", "show ?RBT"], ["proof (prove)\ngoal (1 subgoal):\n 1. RBT_set rbt \\<bind> f'' =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''bind RBT_set: ccompare = None''\n        (\\<lambda>_. RBT_set rbt \\<bind> f'')\n     | Some x \\<Rightarrow> RBT_Set2.fold ((\\<union>) \\<circ> f'') rbt {})", "by(clarsimp split: option.split simp add: RBT_set_def RBT_Set2.fold_conv_fold_keys RBT_Set2.member_conv_keys set_bind_conv_fold)"], ["proof (state)\nthis:\n  RBT_set rbt \\<bind> f'' =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''bind RBT_set: ccompare = None''\n      (\\<lambda>_. RBT_set rbt \\<bind> f'')\n   | Some x \\<Rightarrow> RBT_Set2.fold ((\\<union>) \\<circ> f'') rbt {})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma UNIV_code [code]: \"UNIV = - {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = - {}", "by(simp)"], ["", "lift_definition inf_sls :: \"'a :: lattice semilattice_set\" is \"inf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. semilattice_set inf", "by unfold_locales"], ["", "lemma Inf_fin_code [code]: \"Inf_fin A = set_fold1 inf_sls A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter>\\<^sub>f\\<^sub>i\\<^sub>n A = set_fold1 inf_sls A", "by transfer(simp add: Inf_fin_def)"], ["", "lift_definition sup_sls :: \"'a :: lattice semilattice_set\" is \"sup\""], ["proof (prove)\ngoal (1 subgoal):\n 1. semilattice_set sup", "by unfold_locales"], ["", "lemma Sup_fin_code [code]: \"Sup_fin A = set_fold1 sup_sls A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion>\\<^sub>f\\<^sub>i\\<^sub>n A = set_fold1 sup_sls A", "by transfer(simp add: Sup_fin_def)"], ["", "lift_definition inf_cfi :: \"('a :: lattice, 'a) comp_fun_idem\" is \"inf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_idem inf", "by(rule comp_fun_idem_inf)"], ["", "lemma Inf_code:\n  fixes A :: \"'a :: complete_lattice set\" shows\n  \"Inf A = (if finite A then set_fold_cfi inf_cfi top A else Code.abort (STR ''Inf: infinite'') (\\<lambda>_. Inf A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf A =\n    (if finite A then set_fold_cfi inf_cfi top A\n     else Code.abort STR ''Inf: infinite'' (\\<lambda>_. Inf A))", "by transfer(simp add: Inf_fold_inf)"], ["", "lift_definition sup_cfi :: \"('a :: lattice, 'a) comp_fun_idem\" is \"sup\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_idem sup", "by(rule comp_fun_idem_sup)"], ["", "lemma Sup_code:\n  fixes A :: \"'a :: complete_lattice set\" shows\n  \"Sup A = (if finite A then set_fold_cfi sup_cfi bot A else Code.abort (STR ''Sup: infinite'') (\\<lambda>_. Sup A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup A =\n    (if finite A then set_fold_cfi sup_cfi bot A\n     else Code.abort STR ''Sup: infinite'' (\\<lambda>_. Sup A))", "by transfer(simp add: Sup_fold_sup)"], ["", "lemmas Inter_code [code] = Inf_code[where ?'a = \"_ :: type set\"]"], ["", "lemmas Union_code [code] = Sup_code[where ?'a = \"_ :: type set\"]"], ["", "lemmas Predicate_Inf_code [code] = Inf_code[where ?'a = \"_ :: type Predicate.pred\"]"], ["", "lemmas Predicate_Sup_code [code] = Sup_code[where ?'a = \"_ :: type Predicate.pred\"]"], ["", "lemmas Inf_fun_code [code] = Inf_code[where ?'a = \"_ :: type \\<Rightarrow> _ :: complete_lattice\"]"], ["", "lemmas Sup_fun_code [code] = Sup_code[where ?'a = \"_ :: type \\<Rightarrow> _ :: complete_lattice\"]"], ["", "lift_definition min_sls :: \"'a :: linorder semilattice_set\" is min"], ["proof (prove)\ngoal (1 subgoal):\n 1. semilattice_set min", "by unfold_locales"], ["", "lemma Min_code [code]: \"Min A = set_fold1 min_sls A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min A = set_fold1 min_sls A", "by transfer(simp add: Min_def)"], ["", "lift_definition max_sls :: \"'a :: linorder semilattice_set\" is max"], ["proof (prove)\ngoal (1 subgoal):\n 1. semilattice_set max", "by unfold_locales"], ["", "lemma Max_code [code]: \"Max A = set_fold1 max_sls A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max A = set_fold1 max_sls A", "by transfer(simp add: Max_def)"], ["", "text \\<open>\n  We do not implement @{term Ball}, @{term Bex}, and @{term sorted_list_of_set} for @{term Collect_set} using @{term cEnum},\n  because it should already have been converted to an explicit list of elements if that is possible.\n\\<close>"], ["", "lemma Ball_code [code]:\n  fixes rbt :: \"'a :: ccompare set_rbt\"\n  and dxs :: \"'b :: ceq set_dlist\" shows\n  \"Ball (Set_Monad xs) P = list_all P xs\"\n  \"Ball (DList_set dxs) P' = \n  (case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''Ball DList_set: ceq = None'') (\\<lambda>_. Ball (DList_set dxs) P')\n                  | Some _ \\<Rightarrow> DList_Set.dlist_all P' dxs)\"\n  \"Ball (RBT_set rbt) P'' = \n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''Ball RBT_set: ccompare = None'') (\\<lambda>_. Ball (RBT_set rbt) P'')\n                     | Some _ \\<Rightarrow> RBT_Set2.all P'' rbt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (Set_Monad xs) P = list_all P xs &&&\n    Ball (DList_set dxs) P' =\n    (case ID CEQ('b) of\n     None \\<Rightarrow>\n       Code.abort STR ''Ball DList_set: ceq = None''\n        (\\<lambda>_. Ball (DList_set dxs) P')\n     | Some x \\<Rightarrow> DList_Set.dlist_all P' dxs) &&&\n    Ball (RBT_set rbt) P'' =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''Ball RBT_set: ccompare = None''\n        (\\<lambda>_. Ball (RBT_set rbt) P'')\n     | Some x \\<Rightarrow> RBT_Set2.all P'' rbt)", "by(simp_all add: DList_set_def RBT_set_def list_all_iff dlist_all_conv_member RBT_Set2.all_conv_all_member split: option.splits)"], ["", "lemma Bex_code [code]:\n  fixes rbt :: \"'a :: ccompare set_rbt\"\n  and dxs :: \"'b :: ceq set_dlist\" shows\n  \"Bex (Set_Monad xs) P = list_ex P xs\"\n  \"Bex (DList_set dxs) P' = \n  (case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''Bex DList_set: ceq = None'') (\\<lambda>_. Bex (DList_set dxs) P')\n                  | Some _ \\<Rightarrow> DList_Set.dlist_ex P' dxs)\"\n  \"Bex (RBT_set rbt) P'' = \n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''Bex RBT_set: ccompare = None'') (\\<lambda>_. Bex (RBT_set rbt) P'')\n                     | Some _ \\<Rightarrow> RBT_Set2.ex P'' rbt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Bex (Set_Monad xs) P = list_ex P xs &&&\n    Bex (DList_set dxs) P' =\n    (case ID CEQ('b) of\n     None \\<Rightarrow>\n       Code.abort STR ''Bex DList_set: ceq = None''\n        (\\<lambda>_. Bex (DList_set dxs) P')\n     | Some x \\<Rightarrow> dlist_ex P' dxs) &&&\n    Bex (RBT_set rbt) P'' =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''Bex RBT_set: ccompare = None''\n        (\\<lambda>_. Bex (RBT_set rbt) P'')\n     | Some x \\<Rightarrow> RBT_Set2.ex P'' rbt)", "by(simp_all add: DList_set_def RBT_set_def list_ex_iff dlist_ex_conv_member RBT_Set2.ex_conv_ex_member split: option.splits)"], ["", "lemma csorted_list_of_set_code [code]:\n  fixes rbt :: \"'a :: ccompare set_rbt\" \n  and dxs :: \"'b :: {ccompare, ceq} set_dlist\" \n  and xs :: \"'a :: ccompare list\" shows\n  \"csorted_list_of_set (RBT_set rbt) =\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''csorted_list_of_set RBT_set: ccompare = None'') (\\<lambda>_. csorted_list_of_set (RBT_set rbt))\n                     | Some _ \\<Rightarrow> RBT_Set2.keys rbt)\"\n  \"csorted_list_of_set (DList_set dxs) =\n  (case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''csorted_list_of_set DList_set: ceq = None'') (\\<lambda>_. csorted_list_of_set (DList_set dxs))\n              | Some _ \\<Rightarrow>\n     case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''csorted_list_of_set DList_set: ccompare = None'') (\\<lambda>_. csorted_list_of_set (DList_set dxs))\n                 | Some c \\<Rightarrow> ord.quicksort (lt_of_comp c) (list_of_dlist dxs))\"\n  \"csorted_list_of_set (Set_Monad xs) =\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''csorted_list_of_set Set_Monad: ccompare = None'') (\\<lambda>_. csorted_list_of_set (Set_Monad xs))\n              | Some c \\<Rightarrow> ord.remdups_sorted (lt_of_comp c) (ord.quicksort (lt_of_comp c) xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. csorted_list_of_set (RBT_set rbt) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''csorted_list_of_set RBT_set: ccompare = None''\n        (\\<lambda>_. csorted_list_of_set (RBT_set rbt))\n     | Some x \\<Rightarrow> RBT_Set2.keys rbt) &&&\n    csorted_list_of_set (DList_set dxs) =\n    (case ID CEQ('b) of\n     None \\<Rightarrow>\n       Code.abort STR ''csorted_list_of_set DList_set: ceq = None''\n        (\\<lambda>_. csorted_list_of_set (DList_set dxs))\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''csorted_list_of_set DList_set: ccompare = None''\n            (\\<lambda>_. csorted_list_of_set (DList_set dxs))\n         | Some c \\<Rightarrow>\n             ord.quicksort (lt_of_comp c) (list_of_dlist dxs)) &&&\n    csorted_list_of_set (Set_Monad xs) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''csorted_list_of_set Set_Monad: ccompare = None''\n        (\\<lambda>_. csorted_list_of_set (Set_Monad xs))\n     | Some c \\<Rightarrow>\n         ord.remdups_sorted (lt_of_comp c)\n          (ord.quicksort (lt_of_comp c) xs))", "by(auto split: option.split simp add: RBT_set_def DList_set_def DList_Set.Collect_member member_conv_keys sorted_RBT_Set_keys linorder.sorted_list_of_set_sort_remdups[OF ID_ccompare] linorder.quicksort_conv_sort[OF ID_ccompare] distinct_remdups_id distinct_list_of_dlist linorder.remdups_sorted_conv_remdups[OF ID_ccompare] linorder.sorted_sort[OF ID_ccompare] linorder.sort_remdups[OF ID_ccompare] csorted_list_of_set_def)"], ["", "lemma cless_set_code [code]:\n  fixes rbt rbt' :: \"'a :: ccompare set_rbt\"\n  and rbt1 rbt2 :: \"'b :: cproper_interval set_rbt\"\n  and A B :: \"'a set\" \n  and A' B' :: \"'b set\" shows\n  \"cless_set A B \\<longleftrightarrow>\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''cless_set: ccompare = None'') (\\<lambda>_. cless_set A B)\n              | Some c \\<Rightarrow>\n     if finite A \\<and> finite B then ord.lexordp (\\<lambda>x y. lt_of_comp c y x) (csorted_list_of_set A) (csorted_list_of_set B)\n     else Code.abort (STR ''cless_set: infinite set'') (\\<lambda>_. cless_set A B))\"\n  (is \"?fin_fin\")\n  and cless_set_Complement2 [set_complement_code]:\n  \"cless_set A' (Complement B') \\<longleftrightarrow>\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''cless_set Complement2: ccompare = None'') (\\<lambda>_. cless_set A' (Complement B'))\n              | Some c \\<Rightarrow>\n     if finite A' \\<and> finite B' then\n        finite (UNIV :: 'b set) \\<longrightarrow>\n        proper_intrvl.set_less_aux_Compl (lt_of_comp c) cproper_interval None (csorted_list_of_set A') (csorted_list_of_set B')\n     else Code.abort (STR ''cless_set Complement2: infinite set'') (\\<lambda>_. cless_set A' (Complement B')))\"\n  (is \"?fin_Compl_fin\")\n  and cless_set_Complement1 [set_complement_code]:\n  \"cless_set (Complement A') B' \\<longleftrightarrow>\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''cless_set Complement1: ccompare = None'') (\\<lambda>_. cless_set (Complement A') B')\n              | Some c \\<Rightarrow>\n      if finite A' \\<and> finite B' then\n        finite (UNIV :: 'b set) \\<and>\n        proper_intrvl.Compl_set_less_aux (lt_of_comp c) cproper_interval None (csorted_list_of_set A') (csorted_list_of_set B')\n      else Code.abort (STR ''cless_set Complement1: infinite set'') (\\<lambda>_. cless_set (Complement A') B'))\"\n  (is \"?Compl_fin_fin\")\n  and cless_set_Complement12 [set_complement_code]:\n  \"cless_set (Complement A) (Complement B) \\<longleftrightarrow>\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''cless_set Complement Complement: ccompare = None'') (\\<lambda>_. cless_set (Complement A) (Complement B))\n                     | Some _ \\<Rightarrow> cless B A)\" (is ?Compl_Compl)\n  and\n  \"cless_set (RBT_set rbt) (RBT_set rbt') \\<longleftrightarrow> \n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''cless_set RBT_set RBT_set: ccompare = None'') (\\<lambda>_. cless_set (RBT_set rbt) (RBT_set rbt'))\n             | Some c \\<Rightarrow> ord.lexord_fusion (\\<lambda>x y. lt_of_comp c y x) rbt_keys_generator rbt_keys_generator (RBT_Set2.init rbt) (RBT_Set2.init rbt'))\"\n    (is ?rbt_rbt)\n  and cless_set_rbt_Complement2 [set_complement_code]:\n  \"cless_set (RBT_set rbt1) (Complement (RBT_set rbt2)) \\<longleftrightarrow>\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''cless_set RBT_set (Complement RBT_set): ccompare = None'') (\\<lambda>_. cless_set (RBT_set rbt1) (Complement (RBT_set rbt2)))\n             | Some c \\<Rightarrow>\n     finite (UNIV :: 'b set) \\<longrightarrow>\n     proper_intrvl.set_less_aux_Compl_fusion (lt_of_comp c) cproper_interval rbt_keys_generator rbt_keys_generator None (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))\"\n    (is ?rbt_Compl)\n  and cless_set_rbt_Complement1 [set_complement_code]:\n  \"cless_set (Complement (RBT_set rbt1)) (RBT_set rbt2) \\<longleftrightarrow>\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''cless_set (Complement RBT_set) RBT_set: ccompare = None'') (\\<lambda>_. cless_set (Complement (RBT_set rbt1)) (RBT_set rbt2))\n             | Some c \\<Rightarrow>\n     finite (UNIV :: 'b set) \\<and> \n     proper_intrvl.Compl_set_less_aux_fusion (lt_of_comp c) cproper_interval rbt_keys_generator rbt_keys_generator None (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))\"\n    (is ?Compl_rbt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cless_set A B =\n     (case ID ccompare of\n      None \\<Rightarrow>\n        Code.abort STR ''cless_set: ccompare = None''\n         (\\<lambda>_. cless_set A B)\n      | Some c \\<Rightarrow>\n          if finite A \\<and> finite B\n          then ord.lexordp (\\<lambda>x y. lt_of_comp c y x)\n                (csorted_list_of_set A) (csorted_list_of_set B)\n          else Code.abort STR ''cless_set: infinite set''\n                (\\<lambda>_. cless_set A B)) &&&\n     cless_set A' (Complement B') =\n     (case ID ccompare of\n      None \\<Rightarrow>\n        Code.abort STR ''cless_set Complement2: ccompare = None''\n         (\\<lambda>_. cless_set A' (Complement B'))\n      | Some c \\<Rightarrow>\n          if finite A' \\<and> finite B'\n          then finite UNIV \\<longrightarrow>\n               proper_intrvl.set_less_aux_Compl (lt_of_comp c)\n                cproper_interval None (csorted_list_of_set A')\n                (csorted_list_of_set B')\n          else Code.abort STR ''cless_set Complement2: infinite set''\n                (\\<lambda>_. cless_set A' (Complement B'))) &&&\n     cless_set (Complement A') B' =\n     (case ID ccompare of\n      None \\<Rightarrow>\n        Code.abort STR ''cless_set Complement1: ccompare = None''\n         (\\<lambda>_. cless_set (Complement A') B')\n      | Some c \\<Rightarrow>\n          if finite A' \\<and> finite B'\n          then finite UNIV \\<and>\n               proper_intrvl.Compl_set_less_aux (lt_of_comp c)\n                cproper_interval None (csorted_list_of_set A')\n                (csorted_list_of_set B')\n          else Code.abort STR ''cless_set Complement1: infinite set''\n                (\\<lambda>_. cless_set (Complement A') B'))) &&&\n    (cless_set (Complement A) (Complement B) =\n     (case ID ccompare of\n      None \\<Rightarrow>\n        Code.abort STR ''cless_set Complement Complement: ccompare = None''\n         (\\<lambda>_. cless_set (Complement A) (Complement B))\n      | Some x \\<Rightarrow> cless B A) &&&\n     cless_set (RBT_set rbt) (RBT_set rbt') =\n     (case ID ccompare of\n      None \\<Rightarrow>\n        Code.abort STR ''cless_set RBT_set RBT_set: ccompare = None''\n         (\\<lambda>_. cless_set (RBT_set rbt) (RBT_set rbt'))\n      | Some c \\<Rightarrow>\n          ord.lexord_fusion (\\<lambda>x y. lt_of_comp c y x)\n           rbt_keys_generator rbt_keys_generator (RBT_Set2.init rbt)\n           (RBT_Set2.init rbt'))) &&&\n    cless_set (RBT_set rbt1) (Complement (RBT_set rbt2)) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort\n        STR ''cless_set RBT_set (Complement RBT_set): ccompare = None''\n        (\\<lambda>_. cless_set (RBT_set rbt1) (Complement (RBT_set rbt2)))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<longrightarrow>\n         proper_intrvl.set_less_aux_Compl_fusion (lt_of_comp c)\n          cproper_interval rbt_keys_generator rbt_keys_generator None\n          (RBT_Set2.init rbt1) (RBT_Set2.init rbt2)) &&&\n    cless_set (Complement (RBT_set rbt1)) (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort\n        STR ''cless_set (Complement RBT_set) RBT_set: ccompare = None''\n        (\\<lambda>_. cless_set (Complement (RBT_set rbt1)) (RBT_set rbt2))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<and>\n         proper_intrvl.Compl_set_less_aux_fusion (lt_of_comp c)\n          cproper_interval rbt_keys_generator rbt_keys_generator None\n          (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))", "proof -"], ["proof (state)\ngoal (7 subgoals):\n 1. cless_set A B =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_set: ccompare = None''\n        (\\<lambda>_. cless_set A B)\n     | Some c \\<Rightarrow>\n         if finite A \\<and> finite B\n         then ord.lexordp (\\<lambda>x y. lt_of_comp c y x)\n               (csorted_list_of_set A) (csorted_list_of_set B)\n         else Code.abort STR ''cless_set: infinite set''\n               (\\<lambda>_. cless_set A B))\n 2. cless_set A' (Complement B') =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_set Complement2: ccompare = None''\n        (\\<lambda>_. cless_set A' (Complement B'))\n     | Some c \\<Rightarrow>\n         if finite A' \\<and> finite B'\n         then finite UNIV \\<longrightarrow>\n              proper_intrvl.set_less_aux_Compl (lt_of_comp c)\n               cproper_interval None (csorted_list_of_set A')\n               (csorted_list_of_set B')\n         else Code.abort STR ''cless_set Complement2: infinite set''\n               (\\<lambda>_. cless_set A' (Complement B')))\n 3. cless_set (Complement A') B' =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_set Complement1: ccompare = None''\n        (\\<lambda>_. cless_set (Complement A') B')\n     | Some c \\<Rightarrow>\n         if finite A' \\<and> finite B'\n         then finite UNIV \\<and>\n              proper_intrvl.Compl_set_less_aux (lt_of_comp c)\n               cproper_interval None (csorted_list_of_set A')\n               (csorted_list_of_set B')\n         else Code.abort STR ''cless_set Complement1: infinite set''\n               (\\<lambda>_. cless_set (Complement A') B'))\n 4. cless_set (Complement A) (Complement B) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_set Complement Complement: ccompare = None''\n        (\\<lambda>_. cless_set (Complement A) (Complement B))\n     | Some x \\<Rightarrow> cless B A)\n 5. cless_set (RBT_set rbt) (RBT_set rbt') =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_set RBT_set RBT_set: ccompare = None''\n        (\\<lambda>_. cless_set (RBT_set rbt) (RBT_set rbt'))\n     | Some c \\<Rightarrow>\n         ord.lexord_fusion (\\<lambda>x y. lt_of_comp c y x)\n          rbt_keys_generator rbt_keys_generator (RBT_Set2.init rbt)\n          (RBT_Set2.init rbt'))\n 6. cless_set (RBT_set rbt1) (Complement (RBT_set rbt2)) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort\n        STR ''cless_set RBT_set (Complement RBT_set): ccompare = None''\n        (\\<lambda>_. cless_set (RBT_set rbt1) (Complement (RBT_set rbt2)))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<longrightarrow>\n         proper_intrvl.set_less_aux_Compl_fusion (lt_of_comp c)\n          cproper_interval rbt_keys_generator rbt_keys_generator None\n          (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))\n 7. cless_set (Complement (RBT_set rbt1)) (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort\n        STR ''cless_set (Complement RBT_set) RBT_set: ccompare = None''\n        (\\<lambda>_. cless_set (Complement (RBT_set rbt1)) (RBT_set rbt2))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<and>\n         proper_intrvl.Compl_set_less_aux_fusion (lt_of_comp c)\n          cproper_interval rbt_keys_generator rbt_keys_generator None\n          (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))", "note [split] = option.split csorted_list_of_set_split\n    and [simp] = \n    le_of_comp_of_ords_linorder[OF ID_ccompare]\n    lt_of_comp_of_ords\n    finite_subset[OF subset_UNIV] ccompare_set_def ID_Some\n    ord.lexord_fusion_def \n    proper_intrvl.Compl_set_less_aux_fusion_def\n    proper_intrvl.set_less_aux_Compl_fusion_def\n    unfoldr_rbt_keys_generator\n    RBT_set_def sorted_RBT_Set_keys member_conv_keys\n    linorder.set_less_finite_iff[OF ID_ccompare]\n    linorder.set_less_aux_code[OF ID_ccompare, symmetric]\n    linorder.Compl_set_less_Compl[OF ID_ccompare]\n    linorder.infinite_set_less_Complement[OF ID_ccompare]\n    linorder.infinite_Complement_set_less[OF ID_ccompare]\n    linorder_proper_interval.set_less_aux_Compl2_conv_set_less_aux_Compl[OF ID_ccompare_interval, symmetric]\n    linorder_proper_interval.Compl1_set_less_aux_conv_Compl_set_less_aux[OF ID_ccompare_interval, symmetric]"], ["proof (state)\nthis:\n  ?P (case ?option of None \\<Rightarrow> ?f1.0\n      | Some x \\<Rightarrow> ?f2.0 x) =\n  ((?option = None \\<longrightarrow> ?P ?f1.0) \\<and>\n   (\\<forall>x2. ?option = Some x2 \\<longrightarrow> ?P (?f2.0 x2)))\n  ?P (csorted_list_of_set ?A) =\n  ((\\<forall>xs.\n       ID ccompare \\<noteq> None \\<longrightarrow>\n       finite ?A \\<longrightarrow>\n       ?A = set xs \\<longrightarrow>\n       distinct xs \\<longrightarrow>\n       linorder.sorted cless_eq xs \\<longrightarrow> ?P xs) \\<and>\n   (ID ccompare = None \\<or> infinite ?A \\<longrightarrow> ?P undefined))\n  ID ccompare = Some ?c1 \\<Longrightarrow>\n  le_of_comp (comp_of_ords (le_of_comp ?c1) (lt_of_comp ?c1)) =\n  le_of_comp ?c1\n  lt_of_comp (comp_of_ords ?le ?lt) = ?lt\n  finite UNIV \\<Longrightarrow> finite ?A\n  ccompare =\n  map_option\n   (\\<lambda>c.\n       comp_of_ords (ord.set_less_eq (le_of_comp c))\n        (ord.set_less (le_of_comp c)))\n   (ID ccompare)\n  ID (Some ?x) = Some ?x\n  ord.lexord_fusion ?less ?g1.0 ?g2.0 ?s1.0 ?s2.0 =\n  ord.lexordp ?less (list.unfoldr ?g1.0 ?s1.0) (list.unfoldr ?g2.0 ?s2.0)\n  proper_intrvl.Compl_set_less_aux_fusion ?less ?proper_interval ?g1.0 ?g2.0\n   ?ao ?s1.0 ?s2.0 =\n  proper_intrvl.Compl_set_less_aux ?less ?proper_interval ?ao\n   (list.unfoldr ?g1.0 ?s1.0) (list.unfoldr ?g2.0 ?s2.0)\n  proper_intrvl.set_less_aux_Compl_fusion ?less ?proper_interval ?g1.0 ?g2.0\n   ?ao ?s1.0 ?s2.0 =\n  proper_intrvl.set_less_aux_Compl ?less ?proper_interval ?ao\n   (list.unfoldr ?g1.0 ?s1.0) (list.unfoldr ?g2.0 ?s2.0)\n  list.unfoldr rbt_keys_generator (RBT_Set2.init ?t) = RBT_Set2.keys ?t\n  RBT_set = Collect \\<circ> RBT_Set2.member\n  ID ccompare = Some ?c \\<Longrightarrow>\n  linorder.sorted (le_of_comp ?c) (RBT_Set2.keys ?rbt)\n  ID ccompare \\<noteq> None \\<Longrightarrow>\n  RBT_Set2.member ?t = (\\<lambda>x. x \\<in> set (RBT_Set2.keys ?t))\n  \\<lbrakk>ID ccompare = Some ?c1; finite ?A; finite ?B\\<rbrakk>\n  \\<Longrightarrow> ord.set_less (le_of_comp ?c1) ?A ?B =\n                    ord.set_less_aux (le_of_comp ?c1) ?A ?B\n  \\<lbrakk>ID ccompare = Some ?c; linorder.sorted (le_of_comp ?c) ?xs;\n   distinct ?xs; linorder.sorted (le_of_comp ?c) ?ys; distinct ?ys\\<rbrakk>\n  \\<Longrightarrow> ord.lexordp (\\<lambda>x y. lt_of_comp ?c y x) ?xs ?ys =\n                    ord.set_less_aux (le_of_comp ?c) (set ?xs) (set ?ys)\n  ID ccompare = Some ?c1 \\<Longrightarrow>\n  ord.set_less (le_of_comp ?c1) (- ?A) (- ?B) =\n  ord.set_less (le_of_comp ?c1) ?B ?A\n  \\<lbrakk>ID ccompare = Some ?c1; finite ?A; finite ?B;\n   infinite UNIV\\<rbrakk>\n  \\<Longrightarrow> ord.set_less (le_of_comp ?c1) ?A (- ?B)\n  \\<lbrakk>ID ccompare = Some ?c1; finite ?A; finite ?B;\n   infinite UNIV\\<rbrakk>\n  \\<Longrightarrow> \\<not> ord.set_less (le_of_comp ?c1) (- ?A) ?B\n  \\<lbrakk>ID ccompare = Some ?c; finite UNIV; finite UNIV;\n   linorder.sorted (le_of_comp ?c) ?xs; distinct ?xs;\n   linorder.sorted (le_of_comp ?c) ?ys; distinct ?ys\\<rbrakk>\n  \\<Longrightarrow> proper_intrvl.set_less_aux_Compl (lt_of_comp ?c)\n                     cproper_interval None ?xs ?ys =\n                    ord.set_less_aux (le_of_comp ?c) (set ?xs) (- set ?ys)\n  \\<lbrakk>ID ccompare = Some ?c; finite UNIV; finite UNIV;\n   linorder.sorted (le_of_comp ?c) ?xs; distinct ?xs;\n   linorder.sorted (le_of_comp ?c) ?ys; distinct ?ys\\<rbrakk>\n  \\<Longrightarrow> proper_intrvl.Compl_set_less_aux (lt_of_comp ?c)\n                     cproper_interval None ?xs ?ys =\n                    ord.set_less_aux (le_of_comp ?c) (- set ?xs) (set ?ys)\n\ngoal (7 subgoals):\n 1. cless_set A B =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_set: ccompare = None''\n        (\\<lambda>_. cless_set A B)\n     | Some c \\<Rightarrow>\n         if finite A \\<and> finite B\n         then ord.lexordp (\\<lambda>x y. lt_of_comp c y x)\n               (csorted_list_of_set A) (csorted_list_of_set B)\n         else Code.abort STR ''cless_set: infinite set''\n               (\\<lambda>_. cless_set A B))\n 2. cless_set A' (Complement B') =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_set Complement2: ccompare = None''\n        (\\<lambda>_. cless_set A' (Complement B'))\n     | Some c \\<Rightarrow>\n         if finite A' \\<and> finite B'\n         then finite UNIV \\<longrightarrow>\n              proper_intrvl.set_less_aux_Compl (lt_of_comp c)\n               cproper_interval None (csorted_list_of_set A')\n               (csorted_list_of_set B')\n         else Code.abort STR ''cless_set Complement2: infinite set''\n               (\\<lambda>_. cless_set A' (Complement B')))\n 3. cless_set (Complement A') B' =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_set Complement1: ccompare = None''\n        (\\<lambda>_. cless_set (Complement A') B')\n     | Some c \\<Rightarrow>\n         if finite A' \\<and> finite B'\n         then finite UNIV \\<and>\n              proper_intrvl.Compl_set_less_aux (lt_of_comp c)\n               cproper_interval None (csorted_list_of_set A')\n               (csorted_list_of_set B')\n         else Code.abort STR ''cless_set Complement1: infinite set''\n               (\\<lambda>_. cless_set (Complement A') B'))\n 4. cless_set (Complement A) (Complement B) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_set Complement Complement: ccompare = None''\n        (\\<lambda>_. cless_set (Complement A) (Complement B))\n     | Some x \\<Rightarrow> cless B A)\n 5. cless_set (RBT_set rbt) (RBT_set rbt') =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_set RBT_set RBT_set: ccompare = None''\n        (\\<lambda>_. cless_set (RBT_set rbt) (RBT_set rbt'))\n     | Some c \\<Rightarrow>\n         ord.lexord_fusion (\\<lambda>x y. lt_of_comp c y x)\n          rbt_keys_generator rbt_keys_generator (RBT_Set2.init rbt)\n          (RBT_Set2.init rbt'))\n 6. cless_set (RBT_set rbt1) (Complement (RBT_set rbt2)) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort\n        STR ''cless_set RBT_set (Complement RBT_set): ccompare = None''\n        (\\<lambda>_. cless_set (RBT_set rbt1) (Complement (RBT_set rbt2)))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<longrightarrow>\n         proper_intrvl.set_less_aux_Compl_fusion (lt_of_comp c)\n          cproper_interval rbt_keys_generator rbt_keys_generator None\n          (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))\n 7. cless_set (Complement (RBT_set rbt1)) (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort\n        STR ''cless_set (Complement RBT_set) RBT_set: ccompare = None''\n        (\\<lambda>_. cless_set (Complement (RBT_set rbt1)) (RBT_set rbt2))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<and>\n         proper_intrvl.Compl_set_less_aux_fusion (lt_of_comp c)\n          cproper_interval rbt_keys_generator rbt_keys_generator None\n          (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))", "show ?Compl_Compl"], ["proof (prove)\ngoal (1 subgoal):\n 1. cless_set (Complement A) (Complement B) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_set Complement Complement: ccompare = None''\n        (\\<lambda>_. cless_set (Complement A) (Complement B))\n     | Some x \\<Rightarrow> cless B A)", "by simp"], ["proof (state)\nthis:\n  cless_set (Complement A) (Complement B) =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''cless_set Complement Complement: ccompare = None''\n      (\\<lambda>_. cless_set (Complement A) (Complement B))\n   | Some x \\<Rightarrow> cless B A)\n\ngoal (6 subgoals):\n 1. cless_set A B =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_set: ccompare = None''\n        (\\<lambda>_. cless_set A B)\n     | Some c \\<Rightarrow>\n         if finite A \\<and> finite B\n         then ord.lexordp (\\<lambda>x y. lt_of_comp c y x)\n               (csorted_list_of_set A) (csorted_list_of_set B)\n         else Code.abort STR ''cless_set: infinite set''\n               (\\<lambda>_. cless_set A B))\n 2. cless_set A' (Complement B') =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_set Complement2: ccompare = None''\n        (\\<lambda>_. cless_set A' (Complement B'))\n     | Some c \\<Rightarrow>\n         if finite A' \\<and> finite B'\n         then finite UNIV \\<longrightarrow>\n              proper_intrvl.set_less_aux_Compl (lt_of_comp c)\n               cproper_interval None (csorted_list_of_set A')\n               (csorted_list_of_set B')\n         else Code.abort STR ''cless_set Complement2: infinite set''\n               (\\<lambda>_. cless_set A' (Complement B')))\n 3. cless_set (Complement A') B' =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_set Complement1: ccompare = None''\n        (\\<lambda>_. cless_set (Complement A') B')\n     | Some c \\<Rightarrow>\n         if finite A' \\<and> finite B'\n         then finite UNIV \\<and>\n              proper_intrvl.Compl_set_less_aux (lt_of_comp c)\n               cproper_interval None (csorted_list_of_set A')\n               (csorted_list_of_set B')\n         else Code.abort STR ''cless_set Complement1: infinite set''\n               (\\<lambda>_. cless_set (Complement A') B'))\n 4. cless_set (RBT_set rbt) (RBT_set rbt') =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_set RBT_set RBT_set: ccompare = None''\n        (\\<lambda>_. cless_set (RBT_set rbt) (RBT_set rbt'))\n     | Some c \\<Rightarrow>\n         ord.lexord_fusion (\\<lambda>x y. lt_of_comp c y x)\n          rbt_keys_generator rbt_keys_generator (RBT_Set2.init rbt)\n          (RBT_Set2.init rbt'))\n 5. cless_set (RBT_set rbt1) (Complement (RBT_set rbt2)) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort\n        STR ''cless_set RBT_set (Complement RBT_set): ccompare = None''\n        (\\<lambda>_. cless_set (RBT_set rbt1) (Complement (RBT_set rbt2)))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<longrightarrow>\n         proper_intrvl.set_less_aux_Compl_fusion (lt_of_comp c)\n          cproper_interval rbt_keys_generator rbt_keys_generator None\n          (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))\n 6. cless_set (Complement (RBT_set rbt1)) (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort\n        STR ''cless_set (Complement RBT_set) RBT_set: ccompare = None''\n        (\\<lambda>_. cless_set (Complement (RBT_set rbt1)) (RBT_set rbt2))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<and>\n         proper_intrvl.Compl_set_less_aux_fusion (lt_of_comp c)\n          cproper_interval rbt_keys_generator rbt_keys_generator None\n          (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))", "show ?rbt_rbt"], ["proof (prove)\ngoal (1 subgoal):\n 1. cless_set (RBT_set rbt) (RBT_set rbt') =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_set RBT_set RBT_set: ccompare = None''\n        (\\<lambda>_. cless_set (RBT_set rbt) (RBT_set rbt'))\n     | Some c \\<Rightarrow>\n         ord.lexord_fusion (\\<lambda>x y. lt_of_comp c y x)\n          rbt_keys_generator rbt_keys_generator (RBT_Set2.init rbt)\n          (RBT_Set2.init rbt'))", "by auto"], ["proof (state)\nthis:\n  cless_set (RBT_set rbt) (RBT_set rbt') =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''cless_set RBT_set RBT_set: ccompare = None''\n      (\\<lambda>_. cless_set (RBT_set rbt) (RBT_set rbt'))\n   | Some c \\<Rightarrow>\n       ord.lexord_fusion (\\<lambda>x y. lt_of_comp c y x) rbt_keys_generator\n        rbt_keys_generator (RBT_Set2.init rbt) (RBT_Set2.init rbt'))\n\ngoal (5 subgoals):\n 1. cless_set A B =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_set: ccompare = None''\n        (\\<lambda>_. cless_set A B)\n     | Some c \\<Rightarrow>\n         if finite A \\<and> finite B\n         then ord.lexordp (\\<lambda>x y. lt_of_comp c y x)\n               (csorted_list_of_set A) (csorted_list_of_set B)\n         else Code.abort STR ''cless_set: infinite set''\n               (\\<lambda>_. cless_set A B))\n 2. cless_set A' (Complement B') =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_set Complement2: ccompare = None''\n        (\\<lambda>_. cless_set A' (Complement B'))\n     | Some c \\<Rightarrow>\n         if finite A' \\<and> finite B'\n         then finite UNIV \\<longrightarrow>\n              proper_intrvl.set_less_aux_Compl (lt_of_comp c)\n               cproper_interval None (csorted_list_of_set A')\n               (csorted_list_of_set B')\n         else Code.abort STR ''cless_set Complement2: infinite set''\n               (\\<lambda>_. cless_set A' (Complement B')))\n 3. cless_set (Complement A') B' =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_set Complement1: ccompare = None''\n        (\\<lambda>_. cless_set (Complement A') B')\n     | Some c \\<Rightarrow>\n         if finite A' \\<and> finite B'\n         then finite UNIV \\<and>\n              proper_intrvl.Compl_set_less_aux (lt_of_comp c)\n               cproper_interval None (csorted_list_of_set A')\n               (csorted_list_of_set B')\n         else Code.abort STR ''cless_set Complement1: infinite set''\n               (\\<lambda>_. cless_set (Complement A') B'))\n 4. cless_set (RBT_set rbt1) (Complement (RBT_set rbt2)) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort\n        STR ''cless_set RBT_set (Complement RBT_set): ccompare = None''\n        (\\<lambda>_. cless_set (RBT_set rbt1) (Complement (RBT_set rbt2)))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<longrightarrow>\n         proper_intrvl.set_less_aux_Compl_fusion (lt_of_comp c)\n          cproper_interval rbt_keys_generator rbt_keys_generator None\n          (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))\n 5. cless_set (Complement (RBT_set rbt1)) (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort\n        STR ''cless_set (Complement RBT_set) RBT_set: ccompare = None''\n        (\\<lambda>_. cless_set (Complement (RBT_set rbt1)) (RBT_set rbt2))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<and>\n         proper_intrvl.Compl_set_less_aux_fusion (lt_of_comp c)\n          cproper_interval rbt_keys_generator rbt_keys_generator None\n          (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))", "show ?rbt_Compl"], ["proof (prove)\ngoal (1 subgoal):\n 1. cless_set (RBT_set rbt1) (Complement (RBT_set rbt2)) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort\n        STR ''cless_set RBT_set (Complement RBT_set): ccompare = None''\n        (\\<lambda>_. cless_set (RBT_set rbt1) (Complement (RBT_set rbt2)))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<longrightarrow>\n         proper_intrvl.set_less_aux_Compl_fusion (lt_of_comp c)\n          cproper_interval rbt_keys_generator rbt_keys_generator None\n          (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))", "by(cases \"finite (UNIV :: 'b set)\") auto"], ["proof (state)\nthis:\n  cless_set (RBT_set rbt1) (Complement (RBT_set rbt2)) =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort\n      STR ''cless_set RBT_set (Complement RBT_set): ccompare = None''\n      (\\<lambda>_. cless_set (RBT_set rbt1) (Complement (RBT_set rbt2)))\n   | Some c \\<Rightarrow>\n       finite UNIV \\<longrightarrow>\n       proper_intrvl.set_less_aux_Compl_fusion (lt_of_comp c)\n        cproper_interval rbt_keys_generator rbt_keys_generator None\n        (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))\n\ngoal (4 subgoals):\n 1. cless_set A B =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_set: ccompare = None''\n        (\\<lambda>_. cless_set A B)\n     | Some c \\<Rightarrow>\n         if finite A \\<and> finite B\n         then ord.lexordp (\\<lambda>x y. lt_of_comp c y x)\n               (csorted_list_of_set A) (csorted_list_of_set B)\n         else Code.abort STR ''cless_set: infinite set''\n               (\\<lambda>_. cless_set A B))\n 2. cless_set A' (Complement B') =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_set Complement2: ccompare = None''\n        (\\<lambda>_. cless_set A' (Complement B'))\n     | Some c \\<Rightarrow>\n         if finite A' \\<and> finite B'\n         then finite UNIV \\<longrightarrow>\n              proper_intrvl.set_less_aux_Compl (lt_of_comp c)\n               cproper_interval None (csorted_list_of_set A')\n               (csorted_list_of_set B')\n         else Code.abort STR ''cless_set Complement2: infinite set''\n               (\\<lambda>_. cless_set A' (Complement B')))\n 3. cless_set (Complement A') B' =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_set Complement1: ccompare = None''\n        (\\<lambda>_. cless_set (Complement A') B')\n     | Some c \\<Rightarrow>\n         if finite A' \\<and> finite B'\n         then finite UNIV \\<and>\n              proper_intrvl.Compl_set_less_aux (lt_of_comp c)\n               cproper_interval None (csorted_list_of_set A')\n               (csorted_list_of_set B')\n         else Code.abort STR ''cless_set Complement1: infinite set''\n               (\\<lambda>_. cless_set (Complement A') B'))\n 4. cless_set (Complement (RBT_set rbt1)) (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort\n        STR ''cless_set (Complement RBT_set) RBT_set: ccompare = None''\n        (\\<lambda>_. cless_set (Complement (RBT_set rbt1)) (RBT_set rbt2))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<and>\n         proper_intrvl.Compl_set_less_aux_fusion (lt_of_comp c)\n          cproper_interval rbt_keys_generator rbt_keys_generator None\n          (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))", "show ?Compl_rbt"], ["proof (prove)\ngoal (1 subgoal):\n 1. cless_set (Complement (RBT_set rbt1)) (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort\n        STR ''cless_set (Complement RBT_set) RBT_set: ccompare = None''\n        (\\<lambda>_. cless_set (Complement (RBT_set rbt1)) (RBT_set rbt2))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<and>\n         proper_intrvl.Compl_set_less_aux_fusion (lt_of_comp c)\n          cproper_interval rbt_keys_generator rbt_keys_generator None\n          (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))", "by(cases \"finite (UNIV :: 'b set)\") auto"], ["proof (state)\nthis:\n  cless_set (Complement (RBT_set rbt1)) (RBT_set rbt2) =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort\n      STR ''cless_set (Complement RBT_set) RBT_set: ccompare = None''\n      (\\<lambda>_. cless_set (Complement (RBT_set rbt1)) (RBT_set rbt2))\n   | Some c \\<Rightarrow>\n       finite UNIV \\<and>\n       proper_intrvl.Compl_set_less_aux_fusion (lt_of_comp c)\n        cproper_interval rbt_keys_generator rbt_keys_generator None\n        (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))\n\ngoal (3 subgoals):\n 1. cless_set A B =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_set: ccompare = None''\n        (\\<lambda>_. cless_set A B)\n     | Some c \\<Rightarrow>\n         if finite A \\<and> finite B\n         then ord.lexordp (\\<lambda>x y. lt_of_comp c y x)\n               (csorted_list_of_set A) (csorted_list_of_set B)\n         else Code.abort STR ''cless_set: infinite set''\n               (\\<lambda>_. cless_set A B))\n 2. cless_set A' (Complement B') =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_set Complement2: ccompare = None''\n        (\\<lambda>_. cless_set A' (Complement B'))\n     | Some c \\<Rightarrow>\n         if finite A' \\<and> finite B'\n         then finite UNIV \\<longrightarrow>\n              proper_intrvl.set_less_aux_Compl (lt_of_comp c)\n               cproper_interval None (csorted_list_of_set A')\n               (csorted_list_of_set B')\n         else Code.abort STR ''cless_set Complement2: infinite set''\n               (\\<lambda>_. cless_set A' (Complement B')))\n 3. cless_set (Complement A') B' =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_set Complement1: ccompare = None''\n        (\\<lambda>_. cless_set (Complement A') B')\n     | Some c \\<Rightarrow>\n         if finite A' \\<and> finite B'\n         then finite UNIV \\<and>\n              proper_intrvl.Compl_set_less_aux (lt_of_comp c)\n               cproper_interval None (csorted_list_of_set A')\n               (csorted_list_of_set B')\n         else Code.abort STR ''cless_set Complement1: infinite set''\n               (\\<lambda>_. cless_set (Complement A') B'))", "show ?fin_fin"], ["proof (prove)\ngoal (1 subgoal):\n 1. cless_set A B =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_set: ccompare = None''\n        (\\<lambda>_. cless_set A B)\n     | Some c \\<Rightarrow>\n         if finite A \\<and> finite B\n         then ord.lexordp (\\<lambda>x y. lt_of_comp c y x)\n               (csorted_list_of_set A) (csorted_list_of_set B)\n         else Code.abort STR ''cless_set: infinite set''\n               (\\<lambda>_. cless_set A B))", "by auto"], ["proof (state)\nthis:\n  cless_set A B =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''cless_set: ccompare = None''\n      (\\<lambda>_. cless_set A B)\n   | Some c \\<Rightarrow>\n       if finite A \\<and> finite B\n       then ord.lexordp (\\<lambda>x y. lt_of_comp c y x)\n             (csorted_list_of_set A) (csorted_list_of_set B)\n       else Code.abort STR ''cless_set: infinite set''\n             (\\<lambda>_. cless_set A B))\n\ngoal (2 subgoals):\n 1. cless_set A' (Complement B') =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_set Complement2: ccompare = None''\n        (\\<lambda>_. cless_set A' (Complement B'))\n     | Some c \\<Rightarrow>\n         if finite A' \\<and> finite B'\n         then finite UNIV \\<longrightarrow>\n              proper_intrvl.set_less_aux_Compl (lt_of_comp c)\n               cproper_interval None (csorted_list_of_set A')\n               (csorted_list_of_set B')\n         else Code.abort STR ''cless_set Complement2: infinite set''\n               (\\<lambda>_. cless_set A' (Complement B')))\n 2. cless_set (Complement A') B' =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_set Complement1: ccompare = None''\n        (\\<lambda>_. cless_set (Complement A') B')\n     | Some c \\<Rightarrow>\n         if finite A' \\<and> finite B'\n         then finite UNIV \\<and>\n              proper_intrvl.Compl_set_less_aux (lt_of_comp c)\n               cproper_interval None (csorted_list_of_set A')\n               (csorted_list_of_set B')\n         else Code.abort STR ''cless_set Complement1: infinite set''\n               (\\<lambda>_. cless_set (Complement A') B'))", "show ?fin_Compl_fin"], ["proof (prove)\ngoal (1 subgoal):\n 1. cless_set A' (Complement B') =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_set Complement2: ccompare = None''\n        (\\<lambda>_. cless_set A' (Complement B'))\n     | Some c \\<Rightarrow>\n         if finite A' \\<and> finite B'\n         then finite UNIV \\<longrightarrow>\n              proper_intrvl.set_less_aux_Compl (lt_of_comp c)\n               cproper_interval None (csorted_list_of_set A')\n               (csorted_list_of_set B')\n         else Code.abort STR ''cless_set Complement2: infinite set''\n               (\\<lambda>_. cless_set A' (Complement B')))", "by(cases \"finite (UNIV :: 'b set)\", auto)"], ["proof (state)\nthis:\n  cless_set A' (Complement B') =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''cless_set Complement2: ccompare = None''\n      (\\<lambda>_. cless_set A' (Complement B'))\n   | Some c \\<Rightarrow>\n       if finite A' \\<and> finite B'\n       then finite UNIV \\<longrightarrow>\n            proper_intrvl.set_less_aux_Compl (lt_of_comp c) cproper_interval\n             None (csorted_list_of_set A') (csorted_list_of_set B')\n       else Code.abort STR ''cless_set Complement2: infinite set''\n             (\\<lambda>_. cless_set A' (Complement B')))\n\ngoal (1 subgoal):\n 1. cless_set (Complement A') B' =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_set Complement1: ccompare = None''\n        (\\<lambda>_. cless_set (Complement A') B')\n     | Some c \\<Rightarrow>\n         if finite A' \\<and> finite B'\n         then finite UNIV \\<and>\n              proper_intrvl.Compl_set_less_aux (lt_of_comp c)\n               cproper_interval None (csorted_list_of_set A')\n               (csorted_list_of_set B')\n         else Code.abort STR ''cless_set Complement1: infinite set''\n               (\\<lambda>_. cless_set (Complement A') B'))", "show ?Compl_fin_fin"], ["proof (prove)\ngoal (1 subgoal):\n 1. cless_set (Complement A') B' =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_set Complement1: ccompare = None''\n        (\\<lambda>_. cless_set (Complement A') B')\n     | Some c \\<Rightarrow>\n         if finite A' \\<and> finite B'\n         then finite UNIV \\<and>\n              proper_intrvl.Compl_set_less_aux (lt_of_comp c)\n               cproper_interval None (csorted_list_of_set A')\n               (csorted_list_of_set B')\n         else Code.abort STR ''cless_set Complement1: infinite set''\n               (\\<lambda>_. cless_set (Complement A') B'))", "by(cases \"finite (UNIV :: 'b set)\") auto"], ["proof (state)\nthis:\n  cless_set (Complement A') B' =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''cless_set Complement1: ccompare = None''\n      (\\<lambda>_. cless_set (Complement A') B')\n   | Some c \\<Rightarrow>\n       if finite A' \\<and> finite B'\n       then finite UNIV \\<and>\n            proper_intrvl.Compl_set_less_aux (lt_of_comp c) cproper_interval\n             None (csorted_list_of_set A') (csorted_list_of_set B')\n       else Code.abort STR ''cless_set Complement1: infinite set''\n             (\\<lambda>_. cless_set (Complement A') B'))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma le_of_comp_set_less_eq: \n  \"le_of_comp (comp_of_ords (ord.set_less_eq le) (ord.set_less le)) = ord.set_less_eq le\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le_of_comp (comp_of_ords (ord.set_less_eq le) (ord.set_less le)) =\n    ord.set_less_eq le", "by (rule le_of_comp_of_ords_gen, simp add: ord.set_less_def)"], ["", "lemma cless_eq_set_code [code]:\n  fixes rbt rbt' :: \"'a :: ccompare set_rbt\"\n  and rbt1 rbt2 :: \"'b :: cproper_interval set_rbt\"\n  and A B :: \"'a set\" \n  and A' B' :: \"'b set\" shows\n  \"cless_eq_set A B \\<longleftrightarrow>\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''cless_eq_set: ccompare = None'') (\\<lambda>_. cless_eq_set A B)\n              | Some c \\<Rightarrow>\n     if finite A \\<and> finite B then \n        ord.lexordp_eq (\\<lambda>x y. lt_of_comp c y x) (csorted_list_of_set A) (csorted_list_of_set B)\n     else Code.abort (STR ''cless_eq_set: infinite set'') (\\<lambda>_. cless_eq_set A B))\"\n  (is \"?fin_fin\")\n  and cless_eq_set_Complement2 [set_complement_code]:\n  \"cless_eq_set A' (Complement B') \\<longleftrightarrow>\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''cless_eq_set Complement2: ccompare = None'') (\\<lambda>_. cless_eq_set A' (Complement B'))\n              | Some c \\<Rightarrow>\n     if finite A' \\<and> finite B' then \n        finite (UNIV :: 'b set) \\<longrightarrow>\n        proper_intrvl.set_less_eq_aux_Compl (lt_of_comp c) cproper_interval None (csorted_list_of_set A') (csorted_list_of_set B')\n     else Code.abort (STR ''cless_eq_set Complement2: infinite set'') (\\<lambda>_. cless_eq_set A' (Complement B')))\"\n  (is \"?fin_Compl_fin\")\n  and cless_eq_set_Complement1 [set_complement_code]:\n  \"cless_eq_set (Complement A') B' \\<longleftrightarrow>\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''cless_eq_set Complement1: ccompare = None'') (\\<lambda>_. cless_eq_set (Complement A') B')\n              | Some c \\<Rightarrow>\n    if finite A' \\<and> finite B' then \n      finite (UNIV :: 'b set) \\<and>\n      proper_intrvl.Compl_set_less_eq_aux (lt_of_comp c) cproper_interval None (csorted_list_of_set A') (csorted_list_of_set B')\n    else Code.abort (STR ''cless_eq_set Complement1: infinite set'') (\\<lambda>_. cless_eq_set (Complement A') B'))\"\n  (is \"?Compl_fin_fin\")\n  and cless_eq_set_Complement12 [set_complement_code]:\n  \"cless_eq_set (Complement A) (Complement B) \\<longleftrightarrow> \n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''cless_eq_set Complement Complement: ccompare = None'') (\\<lambda>_. cless_eq (Complement A) (Complement B))\n             | Some c \\<Rightarrow> cless_eq_set B A)\" \n  (is ?Compl_Compl)\n\n  \"cless_eq_set (RBT_set rbt) (RBT_set rbt') \\<longleftrightarrow> \n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''cless_eq_set RBT_set RBT_set: ccompare = None'') (\\<lambda>_. cless_eq_set (RBT_set rbt) (RBT_set rbt'))\n             | Some c \\<Rightarrow> ord.lexord_eq_fusion (\\<lambda>x y. lt_of_comp c y x) rbt_keys_generator rbt_keys_generator (RBT_Set2.init rbt) (RBT_Set2.init rbt'))\" \n    (is ?rbt_rbt)\n  and cless_eq_set_rbt_Complement2 [set_complement_code]:\n  \"cless_eq_set (RBT_set rbt1) (Complement (RBT_set rbt2)) \\<longleftrightarrow>\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''cless_eq_set RBT_set (Complement RBT_set): ccompare = None'') (\\<lambda>_. cless_eq_set (RBT_set rbt1) (Complement (RBT_set rbt2)))\n             | Some c \\<Rightarrow>\n     finite (UNIV :: 'b set) \\<longrightarrow>\n     proper_intrvl.set_less_eq_aux_Compl_fusion (lt_of_comp c) cproper_interval rbt_keys_generator rbt_keys_generator None (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))\"\n    (is ?rbt_Compl)\n  and cless_eq_set_rbt_Complement1 [set_complement_code]:\n  \"cless_eq_set (Complement (RBT_set rbt1)) (RBT_set rbt2) \\<longleftrightarrow>\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''cless_eq_set (Complement RBT_set) RBT_set: ccompare = None'') (\\<lambda>_. cless_eq_set (Complement (RBT_set rbt1)) (RBT_set rbt2))\n             | Some c \\<Rightarrow>\n     finite (UNIV :: 'b set) \\<and> \n     proper_intrvl.Compl_set_less_eq_aux_fusion (lt_of_comp c) cproper_interval rbt_keys_generator rbt_keys_generator None (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))\"\n    (is ?Compl_rbt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cless_eq_set A B =\n     (case ID ccompare of\n      None \\<Rightarrow>\n        Code.abort STR ''cless_eq_set: ccompare = None''\n         (\\<lambda>_. cless_eq_set A B)\n      | Some c \\<Rightarrow>\n          if finite A \\<and> finite B\n          then ord.lexordp_eq (\\<lambda>x y. lt_of_comp c y x)\n                (csorted_list_of_set A) (csorted_list_of_set B)\n          else Code.abort STR ''cless_eq_set: infinite set''\n                (\\<lambda>_. cless_eq_set A B)) &&&\n     cless_eq_set A' (Complement B') =\n     (case ID ccompare of\n      None \\<Rightarrow>\n        Code.abort STR ''cless_eq_set Complement2: ccompare = None''\n         (\\<lambda>_. cless_eq_set A' (Complement B'))\n      | Some c \\<Rightarrow>\n          if finite A' \\<and> finite B'\n          then finite UNIV \\<longrightarrow>\n               proper_intrvl.set_less_eq_aux_Compl (lt_of_comp c)\n                cproper_interval None (csorted_list_of_set A')\n                (csorted_list_of_set B')\n          else Code.abort STR ''cless_eq_set Complement2: infinite set''\n                (\\<lambda>_. cless_eq_set A' (Complement B'))) &&&\n     cless_eq_set (Complement A') B' =\n     (case ID ccompare of\n      None \\<Rightarrow>\n        Code.abort STR ''cless_eq_set Complement1: ccompare = None''\n         (\\<lambda>_. cless_eq_set (Complement A') B')\n      | Some c \\<Rightarrow>\n          if finite A' \\<and> finite B'\n          then finite UNIV \\<and>\n               proper_intrvl.Compl_set_less_eq_aux (lt_of_comp c)\n                cproper_interval None (csorted_list_of_set A')\n                (csorted_list_of_set B')\n          else Code.abort STR ''cless_eq_set Complement1: infinite set''\n                (\\<lambda>_. cless_eq_set (Complement A') B'))) &&&\n    (cless_eq_set (Complement A) (Complement B) =\n     (case ID ccompare of\n      None \\<Rightarrow>\n        Code.abort\n         STR ''cless_eq_set Complement Complement: ccompare = None''\n         (\\<lambda>_. cless_eq (Complement A) (Complement B))\n      | Some c \\<Rightarrow> cless_eq_set B A) &&&\n     cless_eq_set (RBT_set rbt) (RBT_set rbt') =\n     (case ID ccompare of\n      None \\<Rightarrow>\n        Code.abort STR ''cless_eq_set RBT_set RBT_set: ccompare = None''\n         (\\<lambda>_. cless_eq_set (RBT_set rbt) (RBT_set rbt'))\n      | Some c \\<Rightarrow>\n          ord.lexord_eq_fusion (\\<lambda>x y. lt_of_comp c y x)\n           rbt_keys_generator rbt_keys_generator (RBT_Set2.init rbt)\n           (RBT_Set2.init rbt'))) &&&\n    cless_eq_set (RBT_set rbt1) (Complement (RBT_set rbt2)) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort\n        STR ''cless_eq_set RBT_set (Complement RBT_set): ccompare = None''\n        (\\<lambda>_.\n            cless_eq_set (RBT_set rbt1) (Complement (RBT_set rbt2)))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<longrightarrow>\n         proper_intrvl.set_less_eq_aux_Compl_fusion (lt_of_comp c)\n          cproper_interval rbt_keys_generator rbt_keys_generator None\n          (RBT_Set2.init rbt1) (RBT_Set2.init rbt2)) &&&\n    cless_eq_set (Complement (RBT_set rbt1)) (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort\n        STR ''cless_eq_set (Complement RBT_set) RBT_set: ccompare = None''\n        (\\<lambda>_.\n            cless_eq_set (Complement (RBT_set rbt1)) (RBT_set rbt2))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<and>\n         proper_intrvl.Compl_set_less_eq_aux_fusion (lt_of_comp c)\n          cproper_interval rbt_keys_generator rbt_keys_generator None\n          (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))", "proof -"], ["proof (state)\ngoal (7 subgoals):\n 1. cless_eq_set A B =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_eq_set: ccompare = None''\n        (\\<lambda>_. cless_eq_set A B)\n     | Some c \\<Rightarrow>\n         if finite A \\<and> finite B\n         then ord.lexordp_eq (\\<lambda>x y. lt_of_comp c y x)\n               (csorted_list_of_set A) (csorted_list_of_set B)\n         else Code.abort STR ''cless_eq_set: infinite set''\n               (\\<lambda>_. cless_eq_set A B))\n 2. cless_eq_set A' (Complement B') =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_eq_set Complement2: ccompare = None''\n        (\\<lambda>_. cless_eq_set A' (Complement B'))\n     | Some c \\<Rightarrow>\n         if finite A' \\<and> finite B'\n         then finite UNIV \\<longrightarrow>\n              proper_intrvl.set_less_eq_aux_Compl (lt_of_comp c)\n               cproper_interval None (csorted_list_of_set A')\n               (csorted_list_of_set B')\n         else Code.abort STR ''cless_eq_set Complement2: infinite set''\n               (\\<lambda>_. cless_eq_set A' (Complement B')))\n 3. cless_eq_set (Complement A') B' =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_eq_set Complement1: ccompare = None''\n        (\\<lambda>_. cless_eq_set (Complement A') B')\n     | Some c \\<Rightarrow>\n         if finite A' \\<and> finite B'\n         then finite UNIV \\<and>\n              proper_intrvl.Compl_set_less_eq_aux (lt_of_comp c)\n               cproper_interval None (csorted_list_of_set A')\n               (csorted_list_of_set B')\n         else Code.abort STR ''cless_eq_set Complement1: infinite set''\n               (\\<lambda>_. cless_eq_set (Complement A') B'))\n 4. cless_eq_set (Complement A) (Complement B) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort\n        STR ''cless_eq_set Complement Complement: ccompare = None''\n        (\\<lambda>_. cless_eq (Complement A) (Complement B))\n     | Some c \\<Rightarrow> cless_eq_set B A)\n 5. cless_eq_set (RBT_set rbt) (RBT_set rbt') =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_eq_set RBT_set RBT_set: ccompare = None''\n        (\\<lambda>_. cless_eq_set (RBT_set rbt) (RBT_set rbt'))\n     | Some c \\<Rightarrow>\n         ord.lexord_eq_fusion (\\<lambda>x y. lt_of_comp c y x)\n          rbt_keys_generator rbt_keys_generator (RBT_Set2.init rbt)\n          (RBT_Set2.init rbt'))\n 6. cless_eq_set (RBT_set rbt1) (Complement (RBT_set rbt2)) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort\n        STR ''cless_eq_set RBT_set (Complement RBT_set): ccompare = None''\n        (\\<lambda>_.\n            cless_eq_set (RBT_set rbt1) (Complement (RBT_set rbt2)))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<longrightarrow>\n         proper_intrvl.set_less_eq_aux_Compl_fusion (lt_of_comp c)\n          cproper_interval rbt_keys_generator rbt_keys_generator None\n          (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))\n 7. cless_eq_set (Complement (RBT_set rbt1)) (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort\n        STR ''cless_eq_set (Complement RBT_set) RBT_set: ccompare = None''\n        (\\<lambda>_.\n            cless_eq_set (Complement (RBT_set rbt1)) (RBT_set rbt2))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<and>\n         proper_intrvl.Compl_set_less_eq_aux_fusion (lt_of_comp c)\n          cproper_interval rbt_keys_generator rbt_keys_generator None\n          (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))", "note [split] = option.split csorted_list_of_set_split\n    and [simp] = \n    le_of_comp_set_less_eq\n    finite_subset[OF subset_UNIV] ccompare_set_def ID_Some\n    ord.lexord_eq_fusion_def proper_intrvl.Compl_set_less_eq_aux_fusion_def\n    proper_intrvl.set_less_eq_aux_Compl_fusion_def\n    unfoldr_rbt_keys_generator\n    RBT_set_def sorted_RBT_Set_keys member_conv_keys\n    linorder.set_less_eq_finite_iff[OF ID_ccompare]\n    linorder.set_less_eq_aux_code[OF ID_ccompare, symmetric]\n    linorder.Compl_set_less_eq_Compl[OF ID_ccompare]\n    linorder.infinite_set_less_eq_Complement[OF ID_ccompare]\n    linorder.infinite_Complement_set_less_eq[OF ID_ccompare]\n    linorder_proper_interval.set_less_eq_aux_Compl2_conv_set_less_eq_aux_Compl[OF ID_ccompare_interval, symmetric]\n    linorder_proper_interval.Compl1_set_less_eq_aux_conv_Compl_set_less_eq_aux[OF ID_ccompare_interval, symmetric]"], ["proof (state)\nthis:\n  ?P (case ?option of None \\<Rightarrow> ?f1.0\n      | Some x \\<Rightarrow> ?f2.0 x) =\n  ((?option = None \\<longrightarrow> ?P ?f1.0) \\<and>\n   (\\<forall>x2. ?option = Some x2 \\<longrightarrow> ?P (?f2.0 x2)))\n  ?P (csorted_list_of_set ?A) =\n  ((\\<forall>xs.\n       ID ccompare \\<noteq> None \\<longrightarrow>\n       finite ?A \\<longrightarrow>\n       ?A = set xs \\<longrightarrow>\n       distinct xs \\<longrightarrow>\n       linorder.sorted cless_eq xs \\<longrightarrow> ?P xs) \\<and>\n   (ID ccompare = None \\<or> infinite ?A \\<longrightarrow> ?P undefined))\n  le_of_comp (comp_of_ords (ord.set_less_eq ?le) (ord.set_less ?le)) =\n  ord.set_less_eq ?le\n  finite UNIV \\<Longrightarrow> finite ?A\n  ccompare =\n  map_option\n   (\\<lambda>c.\n       comp_of_ords (ord.set_less_eq (le_of_comp c))\n        (ord.set_less (le_of_comp c)))\n   (ID ccompare)\n  ID (Some ?x) = Some ?x\n  ord.lexord_eq_fusion ?less ?g1.0 ?g2.0 ?s1.0 ?s2.0 =\n  ord.lexordp_eq ?less (list.unfoldr ?g1.0 ?s1.0) (list.unfoldr ?g2.0 ?s2.0)\n  proper_intrvl.Compl_set_less_eq_aux_fusion ?less ?proper_interval ?g1.0\n   ?g2.0 ?ao ?s1.0 ?s2.0 =\n  proper_intrvl.Compl_set_less_eq_aux ?less ?proper_interval ?ao\n   (list.unfoldr ?g1.0 ?s1.0) (list.unfoldr ?g2.0 ?s2.0)\n  proper_intrvl.set_less_eq_aux_Compl_fusion ?less ?proper_interval ?g1.0\n   ?g2.0 ?ao ?s1.0 ?s2.0 =\n  proper_intrvl.set_less_eq_aux_Compl ?less ?proper_interval ?ao\n   (list.unfoldr ?g1.0 ?s1.0) (list.unfoldr ?g2.0 ?s2.0)\n  list.unfoldr rbt_keys_generator (RBT_Set2.init ?t) = RBT_Set2.keys ?t\n  RBT_set = Collect \\<circ> RBT_Set2.member\n  ID ccompare = Some ?c \\<Longrightarrow>\n  linorder.sorted (le_of_comp ?c) (RBT_Set2.keys ?rbt)\n  ID ccompare \\<noteq> None \\<Longrightarrow>\n  RBT_Set2.member ?t = (\\<lambda>x. x \\<in> set (RBT_Set2.keys ?t))\n  \\<lbrakk>ID ccompare = Some ?c1; finite ?A; finite ?B\\<rbrakk>\n  \\<Longrightarrow> ord.set_less_eq (le_of_comp ?c1) ?A ?B =\n                    ord.set_less_eq_aux (le_of_comp ?c1) ?A ?B\n  \\<lbrakk>ID ccompare = Some ?c; linorder.sorted (le_of_comp ?c) ?xs;\n   distinct ?xs; linorder.sorted (le_of_comp ?c) ?ys; distinct ?ys\\<rbrakk>\n  \\<Longrightarrow> ord.lexordp_eq (\\<lambda>x y. lt_of_comp ?c y x) ?xs\n                     ?ys =\n                    ord.set_less_eq_aux (le_of_comp ?c) (set ?xs) (set ?ys)\n  ID ccompare = Some ?c1 \\<Longrightarrow>\n  ord.set_less_eq (le_of_comp ?c1) (- ?A) (- ?B) =\n  ord.set_less_eq (le_of_comp ?c1) ?B ?A\n  \\<lbrakk>ID ccompare = Some ?c1; finite ?A; finite ?B;\n   infinite UNIV\\<rbrakk>\n  \\<Longrightarrow> ord.set_less_eq (le_of_comp ?c1) ?A (- ?B)\n  \\<lbrakk>ID ccompare = Some ?c1; finite ?A; finite ?B;\n   infinite UNIV\\<rbrakk>\n  \\<Longrightarrow> \\<not> ord.set_less_eq (le_of_comp ?c1) (- ?A) ?B\n  \\<lbrakk>ID ccompare = Some ?c; finite UNIV; finite UNIV;\n   linorder.sorted (le_of_comp ?c) ?xs; distinct ?xs;\n   linorder.sorted (le_of_comp ?c) ?ys; distinct ?ys\\<rbrakk>\n  \\<Longrightarrow> proper_intrvl.set_less_eq_aux_Compl (lt_of_comp ?c)\n                     cproper_interval None ?xs ?ys =\n                    ord.set_less_eq_aux (le_of_comp ?c) (set ?xs)\n                     (- set ?ys)\n  \\<lbrakk>ID ccompare = Some ?c; finite UNIV; finite UNIV;\n   linorder.sorted (le_of_comp ?c) ?xs; distinct ?xs;\n   linorder.sorted (le_of_comp ?c) ?ys; distinct ?ys\\<rbrakk>\n  \\<Longrightarrow> proper_intrvl.Compl_set_less_eq_aux (lt_of_comp ?c)\n                     cproper_interval None ?xs ?ys =\n                    ord.set_less_eq_aux (le_of_comp ?c) (- set ?xs)\n                     (set ?ys)\n\ngoal (7 subgoals):\n 1. cless_eq_set A B =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_eq_set: ccompare = None''\n        (\\<lambda>_. cless_eq_set A B)\n     | Some c \\<Rightarrow>\n         if finite A \\<and> finite B\n         then ord.lexordp_eq (\\<lambda>x y. lt_of_comp c y x)\n               (csorted_list_of_set A) (csorted_list_of_set B)\n         else Code.abort STR ''cless_eq_set: infinite set''\n               (\\<lambda>_. cless_eq_set A B))\n 2. cless_eq_set A' (Complement B') =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_eq_set Complement2: ccompare = None''\n        (\\<lambda>_. cless_eq_set A' (Complement B'))\n     | Some c \\<Rightarrow>\n         if finite A' \\<and> finite B'\n         then finite UNIV \\<longrightarrow>\n              proper_intrvl.set_less_eq_aux_Compl (lt_of_comp c)\n               cproper_interval None (csorted_list_of_set A')\n               (csorted_list_of_set B')\n         else Code.abort STR ''cless_eq_set Complement2: infinite set''\n               (\\<lambda>_. cless_eq_set A' (Complement B')))\n 3. cless_eq_set (Complement A') B' =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_eq_set Complement1: ccompare = None''\n        (\\<lambda>_. cless_eq_set (Complement A') B')\n     | Some c \\<Rightarrow>\n         if finite A' \\<and> finite B'\n         then finite UNIV \\<and>\n              proper_intrvl.Compl_set_less_eq_aux (lt_of_comp c)\n               cproper_interval None (csorted_list_of_set A')\n               (csorted_list_of_set B')\n         else Code.abort STR ''cless_eq_set Complement1: infinite set''\n               (\\<lambda>_. cless_eq_set (Complement A') B'))\n 4. cless_eq_set (Complement A) (Complement B) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort\n        STR ''cless_eq_set Complement Complement: ccompare = None''\n        (\\<lambda>_. cless_eq (Complement A) (Complement B))\n     | Some c \\<Rightarrow> cless_eq_set B A)\n 5. cless_eq_set (RBT_set rbt) (RBT_set rbt') =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_eq_set RBT_set RBT_set: ccompare = None''\n        (\\<lambda>_. cless_eq_set (RBT_set rbt) (RBT_set rbt'))\n     | Some c \\<Rightarrow>\n         ord.lexord_eq_fusion (\\<lambda>x y. lt_of_comp c y x)\n          rbt_keys_generator rbt_keys_generator (RBT_Set2.init rbt)\n          (RBT_Set2.init rbt'))\n 6. cless_eq_set (RBT_set rbt1) (Complement (RBT_set rbt2)) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort\n        STR ''cless_eq_set RBT_set (Complement RBT_set): ccompare = None''\n        (\\<lambda>_.\n            cless_eq_set (RBT_set rbt1) (Complement (RBT_set rbt2)))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<longrightarrow>\n         proper_intrvl.set_less_eq_aux_Compl_fusion (lt_of_comp c)\n          cproper_interval rbt_keys_generator rbt_keys_generator None\n          (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))\n 7. cless_eq_set (Complement (RBT_set rbt1)) (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort\n        STR ''cless_eq_set (Complement RBT_set) RBT_set: ccompare = None''\n        (\\<lambda>_.\n            cless_eq_set (Complement (RBT_set rbt1)) (RBT_set rbt2))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<and>\n         proper_intrvl.Compl_set_less_eq_aux_fusion (lt_of_comp c)\n          cproper_interval rbt_keys_generator rbt_keys_generator None\n          (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))", "show ?Compl_Compl"], ["proof (prove)\ngoal (1 subgoal):\n 1. cless_eq_set (Complement A) (Complement B) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort\n        STR ''cless_eq_set Complement Complement: ccompare = None''\n        (\\<lambda>_. cless_eq (Complement A) (Complement B))\n     | Some c \\<Rightarrow> cless_eq_set B A)", "by simp"], ["proof (state)\nthis:\n  cless_eq_set (Complement A) (Complement B) =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''cless_eq_set Complement Complement: ccompare = None''\n      (\\<lambda>_. cless_eq (Complement A) (Complement B))\n   | Some c \\<Rightarrow> cless_eq_set B A)\n\ngoal (6 subgoals):\n 1. cless_eq_set A B =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_eq_set: ccompare = None''\n        (\\<lambda>_. cless_eq_set A B)\n     | Some c \\<Rightarrow>\n         if finite A \\<and> finite B\n         then ord.lexordp_eq (\\<lambda>x y. lt_of_comp c y x)\n               (csorted_list_of_set A) (csorted_list_of_set B)\n         else Code.abort STR ''cless_eq_set: infinite set''\n               (\\<lambda>_. cless_eq_set A B))\n 2. cless_eq_set A' (Complement B') =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_eq_set Complement2: ccompare = None''\n        (\\<lambda>_. cless_eq_set A' (Complement B'))\n     | Some c \\<Rightarrow>\n         if finite A' \\<and> finite B'\n         then finite UNIV \\<longrightarrow>\n              proper_intrvl.set_less_eq_aux_Compl (lt_of_comp c)\n               cproper_interval None (csorted_list_of_set A')\n               (csorted_list_of_set B')\n         else Code.abort STR ''cless_eq_set Complement2: infinite set''\n               (\\<lambda>_. cless_eq_set A' (Complement B')))\n 3. cless_eq_set (Complement A') B' =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_eq_set Complement1: ccompare = None''\n        (\\<lambda>_. cless_eq_set (Complement A') B')\n     | Some c \\<Rightarrow>\n         if finite A' \\<and> finite B'\n         then finite UNIV \\<and>\n              proper_intrvl.Compl_set_less_eq_aux (lt_of_comp c)\n               cproper_interval None (csorted_list_of_set A')\n               (csorted_list_of_set B')\n         else Code.abort STR ''cless_eq_set Complement1: infinite set''\n               (\\<lambda>_. cless_eq_set (Complement A') B'))\n 4. cless_eq_set (RBT_set rbt) (RBT_set rbt') =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_eq_set RBT_set RBT_set: ccompare = None''\n        (\\<lambda>_. cless_eq_set (RBT_set rbt) (RBT_set rbt'))\n     | Some c \\<Rightarrow>\n         ord.lexord_eq_fusion (\\<lambda>x y. lt_of_comp c y x)\n          rbt_keys_generator rbt_keys_generator (RBT_Set2.init rbt)\n          (RBT_Set2.init rbt'))\n 5. cless_eq_set (RBT_set rbt1) (Complement (RBT_set rbt2)) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort\n        STR ''cless_eq_set RBT_set (Complement RBT_set): ccompare = None''\n        (\\<lambda>_.\n            cless_eq_set (RBT_set rbt1) (Complement (RBT_set rbt2)))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<longrightarrow>\n         proper_intrvl.set_less_eq_aux_Compl_fusion (lt_of_comp c)\n          cproper_interval rbt_keys_generator rbt_keys_generator None\n          (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))\n 6. cless_eq_set (Complement (RBT_set rbt1)) (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort\n        STR ''cless_eq_set (Complement RBT_set) RBT_set: ccompare = None''\n        (\\<lambda>_.\n            cless_eq_set (Complement (RBT_set rbt1)) (RBT_set rbt2))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<and>\n         proper_intrvl.Compl_set_less_eq_aux_fusion (lt_of_comp c)\n          cproper_interval rbt_keys_generator rbt_keys_generator None\n          (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))", "show ?rbt_rbt"], ["proof (prove)\ngoal (1 subgoal):\n 1. cless_eq_set (RBT_set rbt) (RBT_set rbt') =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_eq_set RBT_set RBT_set: ccompare = None''\n        (\\<lambda>_. cless_eq_set (RBT_set rbt) (RBT_set rbt'))\n     | Some c \\<Rightarrow>\n         ord.lexord_eq_fusion (\\<lambda>x y. lt_of_comp c y x)\n          rbt_keys_generator rbt_keys_generator (RBT_Set2.init rbt)\n          (RBT_Set2.init rbt'))", "by auto"], ["proof (state)\nthis:\n  cless_eq_set (RBT_set rbt) (RBT_set rbt') =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''cless_eq_set RBT_set RBT_set: ccompare = None''\n      (\\<lambda>_. cless_eq_set (RBT_set rbt) (RBT_set rbt'))\n   | Some c \\<Rightarrow>\n       ord.lexord_eq_fusion (\\<lambda>x y. lt_of_comp c y x)\n        rbt_keys_generator rbt_keys_generator (RBT_Set2.init rbt)\n        (RBT_Set2.init rbt'))\n\ngoal (5 subgoals):\n 1. cless_eq_set A B =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_eq_set: ccompare = None''\n        (\\<lambda>_. cless_eq_set A B)\n     | Some c \\<Rightarrow>\n         if finite A \\<and> finite B\n         then ord.lexordp_eq (\\<lambda>x y. lt_of_comp c y x)\n               (csorted_list_of_set A) (csorted_list_of_set B)\n         else Code.abort STR ''cless_eq_set: infinite set''\n               (\\<lambda>_. cless_eq_set A B))\n 2. cless_eq_set A' (Complement B') =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_eq_set Complement2: ccompare = None''\n        (\\<lambda>_. cless_eq_set A' (Complement B'))\n     | Some c \\<Rightarrow>\n         if finite A' \\<and> finite B'\n         then finite UNIV \\<longrightarrow>\n              proper_intrvl.set_less_eq_aux_Compl (lt_of_comp c)\n               cproper_interval None (csorted_list_of_set A')\n               (csorted_list_of_set B')\n         else Code.abort STR ''cless_eq_set Complement2: infinite set''\n               (\\<lambda>_. cless_eq_set A' (Complement B')))\n 3. cless_eq_set (Complement A') B' =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_eq_set Complement1: ccompare = None''\n        (\\<lambda>_. cless_eq_set (Complement A') B')\n     | Some c \\<Rightarrow>\n         if finite A' \\<and> finite B'\n         then finite UNIV \\<and>\n              proper_intrvl.Compl_set_less_eq_aux (lt_of_comp c)\n               cproper_interval None (csorted_list_of_set A')\n               (csorted_list_of_set B')\n         else Code.abort STR ''cless_eq_set Complement1: infinite set''\n               (\\<lambda>_. cless_eq_set (Complement A') B'))\n 4. cless_eq_set (RBT_set rbt1) (Complement (RBT_set rbt2)) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort\n        STR ''cless_eq_set RBT_set (Complement RBT_set): ccompare = None''\n        (\\<lambda>_.\n            cless_eq_set (RBT_set rbt1) (Complement (RBT_set rbt2)))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<longrightarrow>\n         proper_intrvl.set_less_eq_aux_Compl_fusion (lt_of_comp c)\n          cproper_interval rbt_keys_generator rbt_keys_generator None\n          (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))\n 5. cless_eq_set (Complement (RBT_set rbt1)) (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort\n        STR ''cless_eq_set (Complement RBT_set) RBT_set: ccompare = None''\n        (\\<lambda>_.\n            cless_eq_set (Complement (RBT_set rbt1)) (RBT_set rbt2))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<and>\n         proper_intrvl.Compl_set_less_eq_aux_fusion (lt_of_comp c)\n          cproper_interval rbt_keys_generator rbt_keys_generator None\n          (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))", "show ?rbt_Compl"], ["proof (prove)\ngoal (1 subgoal):\n 1. cless_eq_set (RBT_set rbt1) (Complement (RBT_set rbt2)) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort\n        STR ''cless_eq_set RBT_set (Complement RBT_set): ccompare = None''\n        (\\<lambda>_.\n            cless_eq_set (RBT_set rbt1) (Complement (RBT_set rbt2)))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<longrightarrow>\n         proper_intrvl.set_less_eq_aux_Compl_fusion (lt_of_comp c)\n          cproper_interval rbt_keys_generator rbt_keys_generator None\n          (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))", "by(cases \"finite (UNIV :: 'b set)\") auto"], ["proof (state)\nthis:\n  cless_eq_set (RBT_set rbt1) (Complement (RBT_set rbt2)) =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort\n      STR ''cless_eq_set RBT_set (Complement RBT_set): ccompare = None''\n      (\\<lambda>_. cless_eq_set (RBT_set rbt1) (Complement (RBT_set rbt2)))\n   | Some c \\<Rightarrow>\n       finite UNIV \\<longrightarrow>\n       proper_intrvl.set_less_eq_aux_Compl_fusion (lt_of_comp c)\n        cproper_interval rbt_keys_generator rbt_keys_generator None\n        (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))\n\ngoal (4 subgoals):\n 1. cless_eq_set A B =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_eq_set: ccompare = None''\n        (\\<lambda>_. cless_eq_set A B)\n     | Some c \\<Rightarrow>\n         if finite A \\<and> finite B\n         then ord.lexordp_eq (\\<lambda>x y. lt_of_comp c y x)\n               (csorted_list_of_set A) (csorted_list_of_set B)\n         else Code.abort STR ''cless_eq_set: infinite set''\n               (\\<lambda>_. cless_eq_set A B))\n 2. cless_eq_set A' (Complement B') =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_eq_set Complement2: ccompare = None''\n        (\\<lambda>_. cless_eq_set A' (Complement B'))\n     | Some c \\<Rightarrow>\n         if finite A' \\<and> finite B'\n         then finite UNIV \\<longrightarrow>\n              proper_intrvl.set_less_eq_aux_Compl (lt_of_comp c)\n               cproper_interval None (csorted_list_of_set A')\n               (csorted_list_of_set B')\n         else Code.abort STR ''cless_eq_set Complement2: infinite set''\n               (\\<lambda>_. cless_eq_set A' (Complement B')))\n 3. cless_eq_set (Complement A') B' =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_eq_set Complement1: ccompare = None''\n        (\\<lambda>_. cless_eq_set (Complement A') B')\n     | Some c \\<Rightarrow>\n         if finite A' \\<and> finite B'\n         then finite UNIV \\<and>\n              proper_intrvl.Compl_set_less_eq_aux (lt_of_comp c)\n               cproper_interval None (csorted_list_of_set A')\n               (csorted_list_of_set B')\n         else Code.abort STR ''cless_eq_set Complement1: infinite set''\n               (\\<lambda>_. cless_eq_set (Complement A') B'))\n 4. cless_eq_set (Complement (RBT_set rbt1)) (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort\n        STR ''cless_eq_set (Complement RBT_set) RBT_set: ccompare = None''\n        (\\<lambda>_.\n            cless_eq_set (Complement (RBT_set rbt1)) (RBT_set rbt2))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<and>\n         proper_intrvl.Compl_set_less_eq_aux_fusion (lt_of_comp c)\n          cproper_interval rbt_keys_generator rbt_keys_generator None\n          (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))", "show ?Compl_rbt"], ["proof (prove)\ngoal (1 subgoal):\n 1. cless_eq_set (Complement (RBT_set rbt1)) (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort\n        STR ''cless_eq_set (Complement RBT_set) RBT_set: ccompare = None''\n        (\\<lambda>_.\n            cless_eq_set (Complement (RBT_set rbt1)) (RBT_set rbt2))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<and>\n         proper_intrvl.Compl_set_less_eq_aux_fusion (lt_of_comp c)\n          cproper_interval rbt_keys_generator rbt_keys_generator None\n          (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))", "by(cases \"finite (UNIV :: 'b set)\") auto"], ["proof (state)\nthis:\n  cless_eq_set (Complement (RBT_set rbt1)) (RBT_set rbt2) =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort\n      STR ''cless_eq_set (Complement RBT_set) RBT_set: ccompare = None''\n      (\\<lambda>_. cless_eq_set (Complement (RBT_set rbt1)) (RBT_set rbt2))\n   | Some c \\<Rightarrow>\n       finite UNIV \\<and>\n       proper_intrvl.Compl_set_less_eq_aux_fusion (lt_of_comp c)\n        cproper_interval rbt_keys_generator rbt_keys_generator None\n        (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))\n\ngoal (3 subgoals):\n 1. cless_eq_set A B =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_eq_set: ccompare = None''\n        (\\<lambda>_. cless_eq_set A B)\n     | Some c \\<Rightarrow>\n         if finite A \\<and> finite B\n         then ord.lexordp_eq (\\<lambda>x y. lt_of_comp c y x)\n               (csorted_list_of_set A) (csorted_list_of_set B)\n         else Code.abort STR ''cless_eq_set: infinite set''\n               (\\<lambda>_. cless_eq_set A B))\n 2. cless_eq_set A' (Complement B') =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_eq_set Complement2: ccompare = None''\n        (\\<lambda>_. cless_eq_set A' (Complement B'))\n     | Some c \\<Rightarrow>\n         if finite A' \\<and> finite B'\n         then finite UNIV \\<longrightarrow>\n              proper_intrvl.set_less_eq_aux_Compl (lt_of_comp c)\n               cproper_interval None (csorted_list_of_set A')\n               (csorted_list_of_set B')\n         else Code.abort STR ''cless_eq_set Complement2: infinite set''\n               (\\<lambda>_. cless_eq_set A' (Complement B')))\n 3. cless_eq_set (Complement A') B' =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_eq_set Complement1: ccompare = None''\n        (\\<lambda>_. cless_eq_set (Complement A') B')\n     | Some c \\<Rightarrow>\n         if finite A' \\<and> finite B'\n         then finite UNIV \\<and>\n              proper_intrvl.Compl_set_less_eq_aux (lt_of_comp c)\n               cproper_interval None (csorted_list_of_set A')\n               (csorted_list_of_set B')\n         else Code.abort STR ''cless_eq_set Complement1: infinite set''\n               (\\<lambda>_. cless_eq_set (Complement A') B'))", "show ?fin_fin"], ["proof (prove)\ngoal (1 subgoal):\n 1. cless_eq_set A B =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_eq_set: ccompare = None''\n        (\\<lambda>_. cless_eq_set A B)\n     | Some c \\<Rightarrow>\n         if finite A \\<and> finite B\n         then ord.lexordp_eq (\\<lambda>x y. lt_of_comp c y x)\n               (csorted_list_of_set A) (csorted_list_of_set B)\n         else Code.abort STR ''cless_eq_set: infinite set''\n               (\\<lambda>_. cless_eq_set A B))", "by auto"], ["proof (state)\nthis:\n  cless_eq_set A B =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''cless_eq_set: ccompare = None''\n      (\\<lambda>_. cless_eq_set A B)\n   | Some c \\<Rightarrow>\n       if finite A \\<and> finite B\n       then ord.lexordp_eq (\\<lambda>x y. lt_of_comp c y x)\n             (csorted_list_of_set A) (csorted_list_of_set B)\n       else Code.abort STR ''cless_eq_set: infinite set''\n             (\\<lambda>_. cless_eq_set A B))\n\ngoal (2 subgoals):\n 1. cless_eq_set A' (Complement B') =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_eq_set Complement2: ccompare = None''\n        (\\<lambda>_. cless_eq_set A' (Complement B'))\n     | Some c \\<Rightarrow>\n         if finite A' \\<and> finite B'\n         then finite UNIV \\<longrightarrow>\n              proper_intrvl.set_less_eq_aux_Compl (lt_of_comp c)\n               cproper_interval None (csorted_list_of_set A')\n               (csorted_list_of_set B')\n         else Code.abort STR ''cless_eq_set Complement2: infinite set''\n               (\\<lambda>_. cless_eq_set A' (Complement B')))\n 2. cless_eq_set (Complement A') B' =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_eq_set Complement1: ccompare = None''\n        (\\<lambda>_. cless_eq_set (Complement A') B')\n     | Some c \\<Rightarrow>\n         if finite A' \\<and> finite B'\n         then finite UNIV \\<and>\n              proper_intrvl.Compl_set_less_eq_aux (lt_of_comp c)\n               cproper_interval None (csorted_list_of_set A')\n               (csorted_list_of_set B')\n         else Code.abort STR ''cless_eq_set Complement1: infinite set''\n               (\\<lambda>_. cless_eq_set (Complement A') B'))", "show ?fin_Compl_fin"], ["proof (prove)\ngoal (1 subgoal):\n 1. cless_eq_set A' (Complement B') =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_eq_set Complement2: ccompare = None''\n        (\\<lambda>_. cless_eq_set A' (Complement B'))\n     | Some c \\<Rightarrow>\n         if finite A' \\<and> finite B'\n         then finite UNIV \\<longrightarrow>\n              proper_intrvl.set_less_eq_aux_Compl (lt_of_comp c)\n               cproper_interval None (csorted_list_of_set A')\n               (csorted_list_of_set B')\n         else Code.abort STR ''cless_eq_set Complement2: infinite set''\n               (\\<lambda>_. cless_eq_set A' (Complement B')))", "by (cases \"finite (UNIV :: 'b set)\", auto)"], ["proof (state)\nthis:\n  cless_eq_set A' (Complement B') =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''cless_eq_set Complement2: ccompare = None''\n      (\\<lambda>_. cless_eq_set A' (Complement B'))\n   | Some c \\<Rightarrow>\n       if finite A' \\<and> finite B'\n       then finite UNIV \\<longrightarrow>\n            proper_intrvl.set_less_eq_aux_Compl (lt_of_comp c)\n             cproper_interval None (csorted_list_of_set A')\n             (csorted_list_of_set B')\n       else Code.abort STR ''cless_eq_set Complement2: infinite set''\n             (\\<lambda>_. cless_eq_set A' (Complement B')))\n\ngoal (1 subgoal):\n 1. cless_eq_set (Complement A') B' =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_eq_set Complement1: ccompare = None''\n        (\\<lambda>_. cless_eq_set (Complement A') B')\n     | Some c \\<Rightarrow>\n         if finite A' \\<and> finite B'\n         then finite UNIV \\<and>\n              proper_intrvl.Compl_set_less_eq_aux (lt_of_comp c)\n               cproper_interval None (csorted_list_of_set A')\n               (csorted_list_of_set B')\n         else Code.abort STR ''cless_eq_set Complement1: infinite set''\n               (\\<lambda>_. cless_eq_set (Complement A') B'))", "show ?Compl_fin_fin"], ["proof (prove)\ngoal (1 subgoal):\n 1. cless_eq_set (Complement A') B' =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cless_eq_set Complement1: ccompare = None''\n        (\\<lambda>_. cless_eq_set (Complement A') B')\n     | Some c \\<Rightarrow>\n         if finite A' \\<and> finite B'\n         then finite UNIV \\<and>\n              proper_intrvl.Compl_set_less_eq_aux (lt_of_comp c)\n               cproper_interval None (csorted_list_of_set A')\n               (csorted_list_of_set B')\n         else Code.abort STR ''cless_eq_set Complement1: infinite set''\n               (\\<lambda>_. cless_eq_set (Complement A') B'))", "by(cases \"finite (UNIV :: 'b set)\") auto"], ["proof (state)\nthis:\n  cless_eq_set (Complement A') B' =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''cless_eq_set Complement1: ccompare = None''\n      (\\<lambda>_. cless_eq_set (Complement A') B')\n   | Some c \\<Rightarrow>\n       if finite A' \\<and> finite B'\n       then finite UNIV \\<and>\n            proper_intrvl.Compl_set_less_eq_aux (lt_of_comp c)\n             cproper_interval None (csorted_list_of_set A')\n             (csorted_list_of_set B')\n       else Code.abort STR ''cless_eq_set Complement1: infinite set''\n             (\\<lambda>_. cless_eq_set (Complement A') B'))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cproper_interval_set_Some_Some_code [code]:\n  fixes rbt1 rbt2 :: \"'a :: cproper_interval set_rbt\" \n  and A B :: \"'a set\" shows\n\n  \"cproper_interval (Some A) (Some B) \\<longleftrightarrow>\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''cproper_interval: ccompare = None'') (\\<lambda>_. cproper_interval (Some A) (Some B))\n              | Some c \\<Rightarrow>\n       finite (UNIV :: 'a set) \\<and> proper_intrvl.proper_interval_set_aux (lt_of_comp c) cproper_interval (csorted_list_of_set A) (csorted_list_of_set B))\"\n  (is ?fin_fin)\n  and cproper_interval_set_Some_Some_Complement [set_complement_code]:\n  \"cproper_interval (Some A) (Some (Complement B)) \\<longleftrightarrow>\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''cproper_interval Complement2: ccompare = None'') (\\<lambda>_. cproper_interval (Some A) (Some (Complement B)))\n              | Some c \\<Rightarrow>\n       finite (UNIV :: 'a set) \\<and> proper_intrvl.proper_interval_set_Compl_aux (lt_of_comp c) cproper_interval None 0 (csorted_list_of_set A) (csorted_list_of_set B))\"\n  (is ?fin_Compl_fin)\n  and cproper_interval_set_Some_Complement_Some [set_complement_code]:\n  \"cproper_interval (Some (Complement A)) (Some B) \\<longleftrightarrow>\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''cproper_interval Complement1: ccompare = None'') (\\<lambda>_. cproper_interval (Some (Complement A)) (Some B))\n              | Some c \\<Rightarrow>\n       finite (UNIV :: 'a set) \\<and> proper_intrvl.proper_interval_Compl_set_aux (lt_of_comp c) cproper_interval None (csorted_list_of_set A) (csorted_list_of_set B))\"\n  (is ?Compl_fin_fin)\n  and cproper_interval_set_Some_Complement_Some_Complement [set_complement_code]:\n  \"cproper_interval (Some (Complement A)) (Some (Complement B)) \\<longleftrightarrow>\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''cproper_interval Complement Complement: ccompare = None'') (\\<lambda>_. cproper_interval (Some (Complement A)) (Some (Complement B)))\n             | Some _ \\<Rightarrow> cproper_interval (Some B) (Some A))\"\n  (is ?Compl_Compl)\n\n  \"cproper_interval (Some (RBT_set rbt1)) (Some (RBT_set rbt2)) \\<longleftrightarrow>\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''cproper_interval RBT_set RBT_set: ccompare = None'') (\\<lambda>_. cproper_interval (Some (RBT_set rbt1)) (Some (RBT_set rbt2)))\n             | Some c \\<Rightarrow>\n     finite (UNIV :: 'a set) \\<and> proper_intrvl.proper_interval_set_aux_fusion (lt_of_comp c) cproper_interval rbt_keys_generator rbt_keys_generator (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))\"\n  (is ?rbt_rbt)\n  and cproper_interval_set_Some_rbt_Some_Complement [set_complement_code]:\n  \"cproper_interval (Some (RBT_set rbt1)) (Some (Complement (RBT_set rbt2))) \\<longleftrightarrow>\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''cproper_interval RBT_set (Complement RBT_set): ccompare = None'') (\\<lambda>_. cproper_interval (Some (RBT_set rbt1)) (Some (Complement (RBT_set rbt2))))\n             | Some c \\<Rightarrow>\n     finite (UNIV :: 'a set) \\<and> proper_intrvl.proper_interval_set_Compl_aux_fusion (lt_of_comp c) cproper_interval rbt_keys_generator rbt_keys_generator None 0 (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))\"\n  (is ?rbt_Compl_rbt)\n  and cproper_interval_set_Some_Complement_Some_rbt [set_complement_code]:\n  \"cproper_interval (Some (Complement (RBT_set rbt1))) (Some (RBT_set rbt2)) \\<longleftrightarrow>\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''cproper_interval (Complement RBT_set) RBT_set: ccompare = None'') (\\<lambda>_. cproper_interval (Some (Complement (RBT_set rbt1))) (Some (RBT_set rbt2)))\n             | Some c \\<Rightarrow>\n     finite (UNIV :: 'a set) \\<and> proper_intrvl.proper_interval_Compl_set_aux_fusion (lt_of_comp c) cproper_interval rbt_keys_generator rbt_keys_generator None (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))\"\n  (is ?Compl_rbt_rbt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cproper_interval (Some A) (Some B) =\n     (case ID ccompare of\n      None \\<Rightarrow>\n        Code.abort STR ''cproper_interval: ccompare = None''\n         (\\<lambda>_. cproper_interval (Some A) (Some B))\n      | Some c \\<Rightarrow>\n          finite UNIV \\<and>\n          proper_intrvl.proper_interval_set_aux (lt_of_comp c)\n           cproper_interval (csorted_list_of_set A)\n           (csorted_list_of_set B)) &&&\n     cproper_interval (Some A) (Some (Complement B)) =\n     (case ID ccompare of\n      None \\<Rightarrow>\n        Code.abort STR ''cproper_interval Complement2: ccompare = None''\n         (\\<lambda>_. cproper_interval (Some A) (Some (Complement B)))\n      | Some c \\<Rightarrow>\n          finite UNIV \\<and>\n          proper_intrvl.proper_interval_set_Compl_aux (lt_of_comp c)\n           cproper_interval None 0 (csorted_list_of_set A)\n           (csorted_list_of_set B)) &&&\n     cproper_interval (Some (Complement A)) (Some B) =\n     (case ID ccompare of\n      None \\<Rightarrow>\n        Code.abort STR ''cproper_interval Complement1: ccompare = None''\n         (\\<lambda>_. cproper_interval (Some (Complement A)) (Some B))\n      | Some c \\<Rightarrow>\n          finite UNIV \\<and>\n          proper_intrvl.proper_interval_Compl_set_aux (lt_of_comp c)\n           cproper_interval None (csorted_list_of_set A)\n           (csorted_list_of_set B))) &&&\n    (cproper_interval (Some (Complement A)) (Some (Complement B)) =\n     (case ID ccompare of\n      None \\<Rightarrow>\n        Code.abort\n         STR ''cproper_interval Complement Complement: ccompare = None''\n         (\\<lambda>_.\n             cproper_interval (Some (Complement A)) (Some (Complement B)))\n      | Some x \\<Rightarrow> cproper_interval (Some B) (Some A)) &&&\n     cproper_interval (Some (RBT_set rbt1)) (Some (RBT_set rbt2)) =\n     (case ID ccompare of\n      None \\<Rightarrow>\n        Code.abort STR ''cproper_interval RBT_set RBT_set: ccompare = None''\n         (\\<lambda>_.\n             cproper_interval (Some (RBT_set rbt1)) (Some (RBT_set rbt2)))\n      | Some c \\<Rightarrow>\n          finite UNIV \\<and>\n          proper_intrvl.proper_interval_set_aux_fusion (lt_of_comp c)\n           cproper_interval rbt_keys_generator rbt_keys_generator\n           (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))) &&&\n    cproper_interval (Some (RBT_set rbt1))\n     (Some (Complement (RBT_set rbt2))) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort\n        STR ''cproper_interval RBT_set (Complement RBT_set): ccompare = None''\n        (\\<lambda>_.\n            cproper_interval (Some (RBT_set rbt1))\n             (Some (Complement (RBT_set rbt2))))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<and>\n         proper_intrvl.proper_interval_set_Compl_aux_fusion (lt_of_comp c)\n          cproper_interval rbt_keys_generator rbt_keys_generator None 0\n          (RBT_Set2.init rbt1) (RBT_Set2.init rbt2)) &&&\n    cproper_interval (Some (Complement (RBT_set rbt1)))\n     (Some (RBT_set rbt2)) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort\n        STR ''cproper_interval (Complement RBT_set) RBT_set: ccompare = None''\n        (\\<lambda>_.\n            cproper_interval (Some (Complement (RBT_set rbt1)))\n             (Some (RBT_set rbt2)))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<and>\n         proper_intrvl.proper_interval_Compl_set_aux_fusion (lt_of_comp c)\n          cproper_interval rbt_keys_generator rbt_keys_generator None\n          (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))", "proof -"], ["proof (state)\ngoal (7 subgoals):\n 1. cproper_interval (Some A) (Some B) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cproper_interval: ccompare = None''\n        (\\<lambda>_. cproper_interval (Some A) (Some B))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<and>\n         proper_intrvl.proper_interval_set_aux (lt_of_comp c)\n          cproper_interval (csorted_list_of_set A) (csorted_list_of_set B))\n 2. cproper_interval (Some A) (Some (Complement B)) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cproper_interval Complement2: ccompare = None''\n        (\\<lambda>_. cproper_interval (Some A) (Some (Complement B)))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<and>\n         proper_intrvl.proper_interval_set_Compl_aux (lt_of_comp c)\n          cproper_interval None 0 (csorted_list_of_set A)\n          (csorted_list_of_set B))\n 3. cproper_interval (Some (Complement A)) (Some B) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cproper_interval Complement1: ccompare = None''\n        (\\<lambda>_. cproper_interval (Some (Complement A)) (Some B))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<and>\n         proper_intrvl.proper_interval_Compl_set_aux (lt_of_comp c)\n          cproper_interval None (csorted_list_of_set A)\n          (csorted_list_of_set B))\n 4. cproper_interval (Some (Complement A)) (Some (Complement B)) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort\n        STR ''cproper_interval Complement Complement: ccompare = None''\n        (\\<lambda>_.\n            cproper_interval (Some (Complement A)) (Some (Complement B)))\n     | Some x \\<Rightarrow> cproper_interval (Some B) (Some A))\n 5. cproper_interval (Some (RBT_set rbt1)) (Some (RBT_set rbt2)) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cproper_interval RBT_set RBT_set: ccompare = None''\n        (\\<lambda>_.\n            cproper_interval (Some (RBT_set rbt1)) (Some (RBT_set rbt2)))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<and>\n         proper_intrvl.proper_interval_set_aux_fusion (lt_of_comp c)\n          cproper_interval rbt_keys_generator rbt_keys_generator\n          (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))\n 6. cproper_interval (Some (RBT_set rbt1))\n     (Some (Complement (RBT_set rbt2))) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort\n        STR ''cproper_interval RBT_set (Complement RBT_set): ccompare = None''\n        (\\<lambda>_.\n            cproper_interval (Some (RBT_set rbt1))\n             (Some (Complement (RBT_set rbt2))))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<and>\n         proper_intrvl.proper_interval_set_Compl_aux_fusion (lt_of_comp c)\n          cproper_interval rbt_keys_generator rbt_keys_generator None 0\n          (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))\n 7. cproper_interval (Some (Complement (RBT_set rbt1)))\n     (Some (RBT_set rbt2)) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort\n        STR ''cproper_interval (Complement RBT_set) RBT_set: ccompare = None''\n        (\\<lambda>_.\n            cproper_interval (Some (Complement (RBT_set rbt1)))\n             (Some (RBT_set rbt2)))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<and>\n         proper_intrvl.proper_interval_Compl_set_aux_fusion (lt_of_comp c)\n          cproper_interval rbt_keys_generator rbt_keys_generator None\n          (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))", "note [split] = option.split csorted_list_of_set_split\n    and [simp] = \n    lt_of_comp_of_ords\n    finite_subset[OF subset_UNIV] ccompare_set_def ID_Some\n    linorder.set_less_finite_iff[OF ID_ccompare]\n    RBT_set_def sorted_RBT_Set_keys member_conv_keys\n    linorder.distinct_entries[OF ID_ccompare]\n    unfoldr_rbt_keys_generator\n    proper_intrvl.proper_interval_set_aux_fusion_def\n    proper_intrvl.proper_interval_set_Compl_aux_fusion_def\n    proper_intrvl.proper_interval_Compl_set_aux_fusion_def \n    linorder_proper_interval.proper_interval_set_aux[OF ID_ccompare_interval]\n    linorder_proper_interval.proper_interval_set_Compl_aux[OF ID_ccompare_interval]\n    linorder_proper_interval.proper_interval_Compl_set_aux[OF ID_ccompare_interval]\n    and [cong] = conj_cong"], ["proof (state)\nthis:\n  ?P (case ?option of None \\<Rightarrow> ?f1.0\n      | Some x \\<Rightarrow> ?f2.0 x) =\n  ((?option = None \\<longrightarrow> ?P ?f1.0) \\<and>\n   (\\<forall>x2. ?option = Some x2 \\<longrightarrow> ?P (?f2.0 x2)))\n  ?P (csorted_list_of_set ?A) =\n  ((\\<forall>xs.\n       ID ccompare \\<noteq> None \\<longrightarrow>\n       finite ?A \\<longrightarrow>\n       ?A = set xs \\<longrightarrow>\n       distinct xs \\<longrightarrow>\n       linorder.sorted cless_eq xs \\<longrightarrow> ?P xs) \\<and>\n   (ID ccompare = None \\<or> infinite ?A \\<longrightarrow> ?P undefined))\n  lt_of_comp (comp_of_ords ?le ?lt) = ?lt\n  finite UNIV \\<Longrightarrow> finite ?A\n  ccompare =\n  map_option\n   (\\<lambda>c.\n       comp_of_ords (ord.set_less_eq (le_of_comp c))\n        (ord.set_less (le_of_comp c)))\n   (ID ccompare)\n  ID (Some ?x) = Some ?x\n  \\<lbrakk>ID ccompare = Some ?c1; finite ?A; finite ?B\\<rbrakk>\n  \\<Longrightarrow> ord.set_less (le_of_comp ?c1) ?A ?B =\n                    ord.set_less_aux (le_of_comp ?c1) ?A ?B\n  RBT_set = Collect \\<circ> RBT_Set2.member\n  ID ccompare = Some ?c \\<Longrightarrow>\n  linorder.sorted (le_of_comp ?c) (RBT_Set2.keys ?rbt)\n  ID ccompare \\<noteq> None \\<Longrightarrow>\n  RBT_Set2.member ?t = (\\<lambda>x. x \\<in> set (RBT_Set2.keys ?t))\n  \\<lbrakk>ID ccompare = Some ?c1;\n   ord.rbt_sorted (lt_of_comp ?c1) ?t\\<rbrakk>\n  \\<Longrightarrow> distinct (map fst (RBT_Impl.entries ?t))\n  list.unfoldr rbt_keys_generator (RBT_Set2.init ?t) = RBT_Set2.keys ?t\n  proper_intrvl.proper_interval_set_aux_fusion ?less ?proper_interval ?g1.0\n   ?g2.0 ?s1.0 ?s2.0 =\n  proper_intrvl.proper_interval_set_aux ?less ?proper_interval\n   (list.unfoldr ?g1.0 ?s1.0) (list.unfoldr ?g2.0 ?s2.0)\n  proper_intrvl.proper_interval_set_Compl_aux_fusion ?less ?proper_interval\n   ?g1.0 ?g2.0 ?ao ?n ?s1.0 ?s2.0 =\n  proper_intrvl.proper_interval_set_Compl_aux ?less ?proper_interval ?ao ?n\n   (list.unfoldr ?g1.0 ?s1.0) (list.unfoldr ?g2.0 ?s2.0)\n  proper_intrvl.proper_interval_Compl_set_aux_fusion ?less ?proper_interval\n   ?g1.0 ?g2.0 ?ao ?s1.0 ?s2.0 =\n  proper_intrvl.proper_interval_Compl_set_aux ?less ?proper_interval ?ao\n   (list.unfoldr ?g1.0 ?s1.0) (list.unfoldr ?g2.0 ?s2.0)\n  \\<lbrakk>ID ccompare = Some ?c1; finite UNIV; finite UNIV;\n   linorder.sorted (le_of_comp ?c1) ?xs; distinct ?xs;\n   linorder.sorted (le_of_comp ?c1) ?ys; distinct ?ys\\<rbrakk>\n  \\<Longrightarrow> proper_intrvl.proper_interval_set_aux (lt_of_comp ?c1)\n                     cproper_interval ?xs ?ys =\n                    (\\<exists>A.\n                        ord.set_less_aux (le_of_comp ?c1) (set ?xs) A \\<and>\n                        ord.set_less_aux (le_of_comp ?c1) A (set ?ys))\n  \\<lbrakk>ID ccompare = Some ?c1; finite UNIV; finite UNIV;\n   linorder.sorted (le_of_comp ?c1) ?xs; distinct ?xs;\n   linorder.sorted (le_of_comp ?c1) ?ys; distinct ?ys\\<rbrakk>\n  \\<Longrightarrow> proper_intrvl.proper_interval_set_Compl_aux\n                     (lt_of_comp ?c1) cproper_interval None 0 ?xs ?ys =\n                    (\\<exists>A.\n                        ord.set_less_aux (le_of_comp ?c1) (set ?xs) A \\<and>\n                        ord.set_less_aux (le_of_comp ?c1) A (- set ?ys))\n  \\<lbrakk>ID ccompare = Some ?c1; finite UNIV; finite UNIV;\n   linorder.sorted (le_of_comp ?c1) ?xs; distinct ?xs;\n   linorder.sorted (le_of_comp ?c1) ?ys; distinct ?ys\\<rbrakk>\n  \\<Longrightarrow> proper_intrvl.proper_interval_Compl_set_aux\n                     (lt_of_comp ?c1) cproper_interval None ?xs ?ys =\n                    (\\<exists>A.\n                        ord.set_less_aux (le_of_comp ?c1) (- set ?xs)\n                         A \\<and>\n                        ord.set_less_aux (le_of_comp ?c1) A (set ?ys))\n  \\<lbrakk>?P = ?P'; ?P' \\<Longrightarrow> ?Q = ?Q'\\<rbrakk>\n  \\<Longrightarrow> (?P \\<and> ?Q) = (?P' \\<and> ?Q')\n\ngoal (7 subgoals):\n 1. cproper_interval (Some A) (Some B) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cproper_interval: ccompare = None''\n        (\\<lambda>_. cproper_interval (Some A) (Some B))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<and>\n         proper_intrvl.proper_interval_set_aux (lt_of_comp c)\n          cproper_interval (csorted_list_of_set A) (csorted_list_of_set B))\n 2. cproper_interval (Some A) (Some (Complement B)) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cproper_interval Complement2: ccompare = None''\n        (\\<lambda>_. cproper_interval (Some A) (Some (Complement B)))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<and>\n         proper_intrvl.proper_interval_set_Compl_aux (lt_of_comp c)\n          cproper_interval None 0 (csorted_list_of_set A)\n          (csorted_list_of_set B))\n 3. cproper_interval (Some (Complement A)) (Some B) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cproper_interval Complement1: ccompare = None''\n        (\\<lambda>_. cproper_interval (Some (Complement A)) (Some B))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<and>\n         proper_intrvl.proper_interval_Compl_set_aux (lt_of_comp c)\n          cproper_interval None (csorted_list_of_set A)\n          (csorted_list_of_set B))\n 4. cproper_interval (Some (Complement A)) (Some (Complement B)) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort\n        STR ''cproper_interval Complement Complement: ccompare = None''\n        (\\<lambda>_.\n            cproper_interval (Some (Complement A)) (Some (Complement B)))\n     | Some x \\<Rightarrow> cproper_interval (Some B) (Some A))\n 5. cproper_interval (Some (RBT_set rbt1)) (Some (RBT_set rbt2)) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cproper_interval RBT_set RBT_set: ccompare = None''\n        (\\<lambda>_.\n            cproper_interval (Some (RBT_set rbt1)) (Some (RBT_set rbt2)))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<and>\n         proper_intrvl.proper_interval_set_aux_fusion (lt_of_comp c)\n          cproper_interval rbt_keys_generator rbt_keys_generator\n          (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))\n 6. cproper_interval (Some (RBT_set rbt1))\n     (Some (Complement (RBT_set rbt2))) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort\n        STR ''cproper_interval RBT_set (Complement RBT_set): ccompare = None''\n        (\\<lambda>_.\n            cproper_interval (Some (RBT_set rbt1))\n             (Some (Complement (RBT_set rbt2))))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<and>\n         proper_intrvl.proper_interval_set_Compl_aux_fusion (lt_of_comp c)\n          cproper_interval rbt_keys_generator rbt_keys_generator None 0\n          (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))\n 7. cproper_interval (Some (Complement (RBT_set rbt1)))\n     (Some (RBT_set rbt2)) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort\n        STR ''cproper_interval (Complement RBT_set) RBT_set: ccompare = None''\n        (\\<lambda>_.\n            cproper_interval (Some (Complement (RBT_set rbt1)))\n             (Some (RBT_set rbt2)))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<and>\n         proper_intrvl.proper_interval_Compl_set_aux_fusion (lt_of_comp c)\n          cproper_interval rbt_keys_generator rbt_keys_generator None\n          (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))", "show ?Compl_Compl"], ["proof (prove)\ngoal (1 subgoal):\n 1. cproper_interval (Some (Complement A)) (Some (Complement B)) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort\n        STR ''cproper_interval Complement Complement: ccompare = None''\n        (\\<lambda>_.\n            cproper_interval (Some (Complement A)) (Some (Complement B)))\n     | Some x \\<Rightarrow> cproper_interval (Some B) (Some A))", "by(clarsimp simp add: Complement_cproper_interval_set_Complement simp del: cproper_interval_set_Some_Some)"], ["proof (state)\nthis:\n  cproper_interval (Some (Complement A)) (Some (Complement B)) =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort\n      STR ''cproper_interval Complement Complement: ccompare = None''\n      (\\<lambda>_.\n          cproper_interval (Some (Complement A)) (Some (Complement B)))\n   | Some x \\<Rightarrow> cproper_interval (Some B) (Some A))\n\ngoal (6 subgoals):\n 1. cproper_interval (Some A) (Some B) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cproper_interval: ccompare = None''\n        (\\<lambda>_. cproper_interval (Some A) (Some B))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<and>\n         proper_intrvl.proper_interval_set_aux (lt_of_comp c)\n          cproper_interval (csorted_list_of_set A) (csorted_list_of_set B))\n 2. cproper_interval (Some A) (Some (Complement B)) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cproper_interval Complement2: ccompare = None''\n        (\\<lambda>_. cproper_interval (Some A) (Some (Complement B)))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<and>\n         proper_intrvl.proper_interval_set_Compl_aux (lt_of_comp c)\n          cproper_interval None 0 (csorted_list_of_set A)\n          (csorted_list_of_set B))\n 3. cproper_interval (Some (Complement A)) (Some B) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cproper_interval Complement1: ccompare = None''\n        (\\<lambda>_. cproper_interval (Some (Complement A)) (Some B))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<and>\n         proper_intrvl.proper_interval_Compl_set_aux (lt_of_comp c)\n          cproper_interval None (csorted_list_of_set A)\n          (csorted_list_of_set B))\n 4. cproper_interval (Some (RBT_set rbt1)) (Some (RBT_set rbt2)) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cproper_interval RBT_set RBT_set: ccompare = None''\n        (\\<lambda>_.\n            cproper_interval (Some (RBT_set rbt1)) (Some (RBT_set rbt2)))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<and>\n         proper_intrvl.proper_interval_set_aux_fusion (lt_of_comp c)\n          cproper_interval rbt_keys_generator rbt_keys_generator\n          (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))\n 5. cproper_interval (Some (RBT_set rbt1))\n     (Some (Complement (RBT_set rbt2))) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort\n        STR ''cproper_interval RBT_set (Complement RBT_set): ccompare = None''\n        (\\<lambda>_.\n            cproper_interval (Some (RBT_set rbt1))\n             (Some (Complement (RBT_set rbt2))))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<and>\n         proper_intrvl.proper_interval_set_Compl_aux_fusion (lt_of_comp c)\n          cproper_interval rbt_keys_generator rbt_keys_generator None 0\n          (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))\n 6. cproper_interval (Some (Complement (RBT_set rbt1)))\n     (Some (RBT_set rbt2)) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort\n        STR ''cproper_interval (Complement RBT_set) RBT_set: ccompare = None''\n        (\\<lambda>_.\n            cproper_interval (Some (Complement (RBT_set rbt1)))\n             (Some (RBT_set rbt2)))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<and>\n         proper_intrvl.proper_interval_Compl_set_aux_fusion (lt_of_comp c)\n          cproper_interval rbt_keys_generator rbt_keys_generator None\n          (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))", "show ?rbt_rbt ?rbt_Compl_rbt ?Compl_rbt_rbt"], ["proof (prove)\ngoal (1 subgoal):\n 1. cproper_interval (Some (RBT_set rbt1)) (Some (RBT_set rbt2)) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cproper_interval RBT_set RBT_set: ccompare = None''\n        (\\<lambda>_.\n            cproper_interval (Some (RBT_set rbt1)) (Some (RBT_set rbt2)))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<and>\n         proper_intrvl.proper_interval_set_aux_fusion (lt_of_comp c)\n          cproper_interval rbt_keys_generator rbt_keys_generator\n          (RBT_Set2.init rbt1) (RBT_Set2.init rbt2)) &&&\n    cproper_interval (Some (RBT_set rbt1))\n     (Some (Complement (RBT_set rbt2))) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort\n        STR ''cproper_interval RBT_set (Complement RBT_set): ccompare = None''\n        (\\<lambda>_.\n            cproper_interval (Some (RBT_set rbt1))\n             (Some (Complement (RBT_set rbt2))))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<and>\n         proper_intrvl.proper_interval_set_Compl_aux_fusion (lt_of_comp c)\n          cproper_interval rbt_keys_generator rbt_keys_generator None 0\n          (RBT_Set2.init rbt1) (RBT_Set2.init rbt2)) &&&\n    cproper_interval (Some (Complement (RBT_set rbt1)))\n     (Some (RBT_set rbt2)) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort\n        STR ''cproper_interval (Complement RBT_set) RBT_set: ccompare = None''\n        (\\<lambda>_.\n            cproper_interval (Some (Complement (RBT_set rbt1)))\n             (Some (RBT_set rbt2)))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<and>\n         proper_intrvl.proper_interval_Compl_set_aux_fusion (lt_of_comp c)\n          cproper_interval rbt_keys_generator rbt_keys_generator None\n          (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))", "by auto"], ["proof (state)\nthis:\n  cproper_interval (Some (RBT_set rbt1)) (Some (RBT_set rbt2)) =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''cproper_interval RBT_set RBT_set: ccompare = None''\n      (\\<lambda>_.\n          cproper_interval (Some (RBT_set rbt1)) (Some (RBT_set rbt2)))\n   | Some c \\<Rightarrow>\n       finite UNIV \\<and>\n       proper_intrvl.proper_interval_set_aux_fusion (lt_of_comp c)\n        cproper_interval rbt_keys_generator rbt_keys_generator\n        (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))\n  cproper_interval (Some (RBT_set rbt1))\n   (Some (Complement (RBT_set rbt2))) =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort\n      STR ''cproper_interval RBT_set (Complement RBT_set): ccompare = None''\n      (\\<lambda>_.\n          cproper_interval (Some (RBT_set rbt1))\n           (Some (Complement (RBT_set rbt2))))\n   | Some c \\<Rightarrow>\n       finite UNIV \\<and>\n       proper_intrvl.proper_interval_set_Compl_aux_fusion (lt_of_comp c)\n        cproper_interval rbt_keys_generator rbt_keys_generator None 0\n        (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))\n  cproper_interval (Some (Complement (RBT_set rbt1)))\n   (Some (RBT_set rbt2)) =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort\n      STR ''cproper_interval (Complement RBT_set) RBT_set: ccompare = None''\n      (\\<lambda>_.\n          cproper_interval (Some (Complement (RBT_set rbt1)))\n           (Some (RBT_set rbt2)))\n   | Some c \\<Rightarrow>\n       finite UNIV \\<and>\n       proper_intrvl.proper_interval_Compl_set_aux_fusion (lt_of_comp c)\n        cproper_interval rbt_keys_generator rbt_keys_generator None\n        (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))\n\ngoal (3 subgoals):\n 1. cproper_interval (Some A) (Some B) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cproper_interval: ccompare = None''\n        (\\<lambda>_. cproper_interval (Some A) (Some B))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<and>\n         proper_intrvl.proper_interval_set_aux (lt_of_comp c)\n          cproper_interval (csorted_list_of_set A) (csorted_list_of_set B))\n 2. cproper_interval (Some A) (Some (Complement B)) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cproper_interval Complement2: ccompare = None''\n        (\\<lambda>_. cproper_interval (Some A) (Some (Complement B)))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<and>\n         proper_intrvl.proper_interval_set_Compl_aux (lt_of_comp c)\n          cproper_interval None 0 (csorted_list_of_set A)\n          (csorted_list_of_set B))\n 3. cproper_interval (Some (Complement A)) (Some B) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cproper_interval Complement1: ccompare = None''\n        (\\<lambda>_. cproper_interval (Some (Complement A)) (Some B))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<and>\n         proper_intrvl.proper_interval_Compl_set_aux (lt_of_comp c)\n          cproper_interval None (csorted_list_of_set A)\n          (csorted_list_of_set B))", "show ?fin_fin ?fin_Compl_fin ?Compl_fin_fin"], ["proof (prove)\ngoal (1 subgoal):\n 1. cproper_interval (Some A) (Some B) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cproper_interval: ccompare = None''\n        (\\<lambda>_. cproper_interval (Some A) (Some B))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<and>\n         proper_intrvl.proper_interval_set_aux (lt_of_comp c)\n          cproper_interval (csorted_list_of_set A)\n          (csorted_list_of_set B)) &&&\n    cproper_interval (Some A) (Some (Complement B)) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cproper_interval Complement2: ccompare = None''\n        (\\<lambda>_. cproper_interval (Some A) (Some (Complement B)))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<and>\n         proper_intrvl.proper_interval_set_Compl_aux (lt_of_comp c)\n          cproper_interval None 0 (csorted_list_of_set A)\n          (csorted_list_of_set B)) &&&\n    cproper_interval (Some (Complement A)) (Some B) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''cproper_interval Complement1: ccompare = None''\n        (\\<lambda>_. cproper_interval (Some (Complement A)) (Some B))\n     | Some c \\<Rightarrow>\n         finite UNIV \\<and>\n         proper_intrvl.proper_interval_Compl_set_aux (lt_of_comp c)\n          cproper_interval None (csorted_list_of_set A)\n          (csorted_list_of_set B))", "by auto"], ["proof (state)\nthis:\n  cproper_interval (Some A) (Some B) =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''cproper_interval: ccompare = None''\n      (\\<lambda>_. cproper_interval (Some A) (Some B))\n   | Some c \\<Rightarrow>\n       finite UNIV \\<and>\n       proper_intrvl.proper_interval_set_aux (lt_of_comp c) cproper_interval\n        (csorted_list_of_set A) (csorted_list_of_set B))\n  cproper_interval (Some A) (Some (Complement B)) =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''cproper_interval Complement2: ccompare = None''\n      (\\<lambda>_. cproper_interval (Some A) (Some (Complement B)))\n   | Some c \\<Rightarrow>\n       finite UNIV \\<and>\n       proper_intrvl.proper_interval_set_Compl_aux (lt_of_comp c)\n        cproper_interval None 0 (csorted_list_of_set A)\n        (csorted_list_of_set B))\n  cproper_interval (Some (Complement A)) (Some B) =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''cproper_interval Complement1: ccompare = None''\n      (\\<lambda>_. cproper_interval (Some (Complement A)) (Some B))\n   | Some c \\<Rightarrow>\n       finite UNIV \\<and>\n       proper_intrvl.proper_interval_Compl_set_aux (lt_of_comp c)\n        cproper_interval None (csorted_list_of_set A)\n        (csorted_list_of_set B))\n\ngoal:\nNo subgoals!", "qed"], ["", "context ord begin"], ["", "fun sorted_list_subset :: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> 'a list \\<Rightarrow> 'a list \\<Rightarrow> bool\"\nwhere\n  \"sorted_list_subset eq [] ys = True\"\n| \"sorted_list_subset eq (x # xs) [] = False\"\n| \"sorted_list_subset eq (x # xs) (y # ys) \\<longleftrightarrow>\n  (if eq x y then sorted_list_subset eq xs ys\n   else x > y \\<and> sorted_list_subset eq (x # xs) ys)\""], ["", "end"], ["", "context linorder begin"], ["", "lemma sorted_list_subset_correct:\n  \"\\<lbrakk> sorted xs; distinct xs; sorted ys; distinct ys \\<rbrakk> \n  \\<Longrightarrow> sorted_list_subset (=) xs ys \\<longleftrightarrow> set xs \\<subseteq> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted xs; distinct xs; sorted ys; distinct ys\\<rbrakk>\n    \\<Longrightarrow> sorted_list_subset (=) xs ys =\n                      (set xs \\<subseteq> set ys)", "apply(induct \"(=) :: 'a \\<Rightarrow> 'a \\<Rightarrow> bool\" xs ys rule: sorted_list_subset.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>sorted []; distinct []; sorted ys; distinct ys\\<rbrakk>\n       \\<Longrightarrow> sorted_list_subset (=) [] ys =\n                         (set [] \\<subseteq> set ys)\n 2. \\<And>x xs.\n       \\<lbrakk>sorted (x # xs); distinct (x # xs); sorted [];\n        distinct []\\<rbrakk>\n       \\<Longrightarrow> sorted_list_subset (=) (x # xs) [] =\n                         (set (x # xs) \\<subseteq> set [])\n 3. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>x = y; sorted xs; distinct xs; sorted ys;\n                 distinct ys\\<rbrakk>\n                \\<Longrightarrow> sorted_list_subset (=) xs ys =\n                                  (set xs \\<subseteq> set ys);\n        \\<lbrakk>x \\<noteq> y; sorted (x # xs); distinct (x # xs);\n         sorted ys; distinct ys\\<rbrakk>\n        \\<Longrightarrow> sorted_list_subset (=) (x # xs) ys =\n                          (set (x # xs) \\<subseteq> set ys);\n        sorted (x # xs); distinct (x # xs); sorted (y # ys);\n        distinct (y # ys)\\<rbrakk>\n       \\<Longrightarrow> sorted_list_subset (=) (x # xs) (y # ys) =\n                         (set (x # xs) \\<subseteq> set (y # ys))", "apply(auto 6 2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs y ys xa.\n       \\<lbrakk>\\<forall>xa\\<in>set xs. x \\<le> xa; sorted xs;\n        x \\<notin> set xs; distinct xs; \\<forall>x\\<in>set ys. y \\<le> x;\n        sorted ys; y \\<notin> set ys; distinct ys; x \\<noteq> y;\n        x \\<in> set ys; set xs \\<subseteq> insert y (set ys);\n        xa \\<in> set xs; sorted_list_subset (=) (x # xs) ys;\n        set xs \\<subseteq> set ys\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> set ys\n 2. \\<And>x xs y ys xa xb.\n       \\<lbrakk>\\<forall>xa\\<in>set xs. x \\<le> xa; sorted xs;\n        x \\<notin> set xs; distinct xs; \\<forall>x\\<in>set ys. y \\<le> x;\n        sorted ys; y \\<notin> set ys; distinct ys; x \\<noteq> y;\n        x \\<in> set ys; set xs \\<subseteq> insert y (set ys);\n        xa \\<in> set xs; \\<not> sorted_list_subset (=) (x # xs) ys;\n        xa \\<notin> set ys; xb \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> xb \\<in> set ys", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys xa xb.\n       \\<lbrakk>\\<forall>xa\\<in>set xs. x \\<le> xa; sorted xs;\n        x \\<notin> set xs; distinct xs; \\<forall>x\\<in>set ys. y \\<le> x;\n        sorted ys; y \\<notin> set ys; distinct ys; x \\<noteq> y;\n        x \\<in> set ys; set xs \\<subseteq> insert y (set ys);\n        xa \\<in> set xs; \\<not> sorted_list_subset (=) (x # xs) ys;\n        xa \\<notin> set ys; xb \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> xb \\<in> set ys", "by (metis eq_iff insert_iff subsetD)"], ["", "end"], ["", "context ord begin"], ["", "definition sorted_list_subset_fusion :: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> ('a, 's1) generator \\<Rightarrow> ('a, 's2) generator \\<Rightarrow> 's1 \\<Rightarrow> 's2 \\<Rightarrow> bool\"\nwhere \"sorted_list_subset_fusion eq g1 g2 s1 s2 = sorted_list_subset eq (list.unfoldr g1 s1) (list.unfoldr g2 s2)\""], ["", "lemma sorted_list_subset_fusion_code:\n  \"sorted_list_subset_fusion eq g1 g2 s1 s2 =\n  (if list.has_next g1 s1 then\n     let (x, s1') = list.next g1 s1\n     in list.has_next g2 s2 \\<and> (\n        let (y, s2') = list.next g2 s2 \n        in if eq x y then sorted_list_subset_fusion eq g1 g2 s1' s2' \n           else y < x \\<and> sorted_list_subset_fusion eq g1 g2 s1 s2')\n   else True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_list_subset_fusion eq g1 g2 s1 s2 =\n    (if list.has_next g1 s1\n     then let (x, s1') = list.next g1 s1\n          in list.has_next g2 s2 \\<and>\n             (let (y, s2') = list.next g2 s2\n              in if eq x y then sorted_list_subset_fusion eq g1 g2 s1' s2'\n                 else y < x \\<and>\n                      sorted_list_subset_fusion eq g1 g2 s1 s2')\n     else True)", "unfolding sorted_list_subset_fusion_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_list_subset eq (list.unfoldr g1 s1) (list.unfoldr g2 s2) =\n    (if list.has_next g1 s1\n     then let (x, s1') = list.next g1 s1\n          in list.has_next g2 s2 \\<and>\n             (let (y, s2') = list.next g2 s2\n              in if eq x y\n                 then sorted_list_subset eq (list.unfoldr g1 s1')\n                       (list.unfoldr g2 s2')\n                 else y < x \\<and>\n                      sorted_list_subset eq (list.unfoldr g1 s1)\n                       (list.unfoldr g2 s2'))\n     else True)", "by(subst (1 2 5) list.unfoldr.simps)(simp add: split_beta Let_def)"], ["", "end"], ["", "lemmas [code] = ord.sorted_list_subset_fusion_code"], ["", "text \\<open>\n  Define a new constant for the subset operation\n  because @{theory \"HOL-Library.Cardinality\"} introduces @{const \"Cardinality.subset'\"}\n  and rewrites @{const \"subset\"} to @{const \"Cardinality.subset'\"} \n  based on the sort of the element type.\n\\<close>"], ["", "definition subset_eq :: \"'a set \\<Rightarrow> 'a set \\<Rightarrow> bool\"\nwhere [simp, code del]: \"subset_eq = (\\<subseteq>)\""], ["", "lemma subseteq_code [code]: \"(\\<subseteq>) = subset_eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<subseteq>) = Set_Impl.subset_eq", "by simp"], ["", "lemma subset'_code [code]: \"Cardinality.subset' = subset_eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cardinality.subset' = Set_Impl.subset_eq", "by simp"], ["", "lemma subset_eq_code [folded subset_eq_def, code]:\n  fixes A1 A2 :: \"'a set\"\n  and rbt :: \"'b :: ccompare set_rbt\"\n  and rbt1 rbt2 :: \"'d :: {ccompare, ceq} set_rbt\"\n  and dxs :: \"'c :: ceq set_dlist\" \n  and xs :: \"'c list\" shows\n  \"RBT_set rbt \\<subseteq> B \\<longleftrightarrow> \n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''subset RBT_set1: ccompare = None'') (\\<lambda>_. RBT_set rbt \\<subseteq> B)\n                     | Some _ \\<Rightarrow> list_all_fusion rbt_keys_generator (\\<lambda>x. x \\<in> B) (RBT_Set2.init rbt))\" (is ?rbt)\n  \"DList_set dxs \\<subseteq> C \\<longleftrightarrow> \n  (case ID CEQ('c) of None \\<Rightarrow> Code.abort (STR ''subset DList_set1: ceq = None'') (\\<lambda>_. DList_set dxs \\<subseteq> C)\n                     | Some _ \\<Rightarrow> DList_Set.dlist_all (\\<lambda>x. x \\<in> C) dxs)\" (is ?dlist)\n  \"Set_Monad xs \\<subseteq> C \\<longleftrightarrow> list_all (\\<lambda>x. x \\<in> C) xs\" (is ?Set_Monad)\n  and Collect_subset_eq_Complement [folded subset_eq_def, set_complement_code]:\n  \"Collect_set P \\<subseteq> Complement A \\<longleftrightarrow> A \\<subseteq> {x. \\<not> P x}\" (is ?Collect_set_Compl)\n  and Complement_subset_eq_Complement [folded subset_eq_def, set_complement_code]:\n  \"Complement A1 \\<subseteq> Complement A2 \\<longleftrightarrow> A2 \\<subseteq> A1\" (is ?Compl)\n  and\n  \"RBT_set rbt1 \\<subseteq> RBT_set rbt2 \\<longleftrightarrow>\n  (case ID CCOMPARE('d) of None \\<Rightarrow> Code.abort (STR ''subset RBT_set RBT_set: ccompare = None'') (\\<lambda>_. RBT_set rbt1 \\<subseteq> RBT_set rbt2)\n                     | Some c \\<Rightarrow> \n    (case ID CEQ('d) of None \\<Rightarrow> ord.sorted_list_subset_fusion (lt_of_comp c) (\\<lambda> x y. c x y = Eq) rbt_keys_generator rbt_keys_generator (RBT_Set2.init rbt1) (RBT_Set2.init rbt2)\n                   | Some eq \\<Rightarrow> ord.sorted_list_subset_fusion (lt_of_comp c) eq rbt_keys_generator rbt_keys_generator (RBT_Set2.init rbt1) (RBT_Set2.init rbt2)))\" \n  (is ?rbt_rbt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((RBT_set rbt \\<subseteq> B) =\n      (case ID ccompare of\n       None \\<Rightarrow>\n         Code.abort STR ''subset RBT_set1: ccompare = None''\n          (\\<lambda>_. RBT_set rbt \\<subseteq> B)\n       | Some x \\<Rightarrow>\n           list_all_fusion rbt_keys_generator (\\<lambda>x. x \\<in> B)\n            (RBT_Set2.init rbt)) &&&\n      (DList_set dxs \\<subseteq> C) =\n      (case ID CEQ('c) of\n       None \\<Rightarrow>\n         Code.abort STR ''subset DList_set1: ceq = None''\n          (\\<lambda>_. DList_set dxs \\<subseteq> C)\n       | Some x \\<Rightarrow>\n           DList_Set.dlist_all (\\<lambda>x. x \\<in> C) dxs) &&&\n      (Set_Monad xs \\<subseteq> C) =\n      list_all (\\<lambda>x. x \\<in> C) xs) &&&\n     (Collect_set P \\<subseteq> Complement A) =\n     (A \\<subseteq> {x. \\<not> P x})) &&&\n    (Complement A1 \\<subseteq> Complement A2) = (A2 \\<subseteq> A1) &&&\n    (RBT_set rbt1 \\<subseteq> RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''subset RBT_set RBT_set: ccompare = None''\n        (\\<lambda>_. RBT_set rbt1 \\<subseteq> RBT_set rbt2)\n     | Some c \\<Rightarrow>\n         case ID CEQ('d) of\n         None \\<Rightarrow>\n           ord.sorted_list_subset_fusion (lt_of_comp c)\n            (\\<lambda>x y. c x y = Eq) rbt_keys_generator rbt_keys_generator\n            (RBT_Set2.init rbt1) (RBT_Set2.init rbt2)\n         | Some eq \\<Rightarrow>\n             ord.sorted_list_subset_fusion (lt_of_comp c) eq\n              rbt_keys_generator rbt_keys_generator (RBT_Set2.init rbt1)\n              (RBT_Set2.init rbt2))", "proof -"], ["proof (state)\ngoal (6 subgoals):\n 1. (RBT_set rbt \\<subseteq> B) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''subset RBT_set1: ccompare = None''\n        (\\<lambda>_. RBT_set rbt \\<subseteq> B)\n     | Some x \\<Rightarrow>\n         list_all_fusion rbt_keys_generator (\\<lambda>x. x \\<in> B)\n          (RBT_Set2.init rbt))\n 2. (DList_set dxs \\<subseteq> C) =\n    (case ID CEQ('c) of\n     None \\<Rightarrow>\n       Code.abort STR ''subset DList_set1: ceq = None''\n        (\\<lambda>_. DList_set dxs \\<subseteq> C)\n     | Some x \\<Rightarrow> DList_Set.dlist_all (\\<lambda>x. x \\<in> C) dxs)\n 3. (Set_Monad xs \\<subseteq> C) = list_all (\\<lambda>x. x \\<in> C) xs\n 4. (Collect_set P \\<subseteq> Complement A) =\n    (A \\<subseteq> {x. \\<not> P x})\n 5. (Complement A1 \\<subseteq> Complement A2) = (A2 \\<subseteq> A1)\n 6. (RBT_set rbt1 \\<subseteq> RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''subset RBT_set RBT_set: ccompare = None''\n        (\\<lambda>_. RBT_set rbt1 \\<subseteq> RBT_set rbt2)\n     | Some c \\<Rightarrow>\n         case ID CEQ('d) of\n         None \\<Rightarrow>\n           ord.sorted_list_subset_fusion (lt_of_comp c)\n            (\\<lambda>x y. c x y = Eq) rbt_keys_generator rbt_keys_generator\n            (RBT_Set2.init rbt1) (RBT_Set2.init rbt2)\n         | Some eq \\<Rightarrow>\n             ord.sorted_list_subset_fusion (lt_of_comp c) eq\n              rbt_keys_generator rbt_keys_generator (RBT_Set2.init rbt1)\n              (RBT_Set2.init rbt2))", "show ?rbt_rbt"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RBT_set rbt1 \\<subseteq> RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''subset RBT_set RBT_set: ccompare = None''\n        (\\<lambda>_. RBT_set rbt1 \\<subseteq> RBT_set rbt2)\n     | Some c \\<Rightarrow>\n         case ID CEQ('d) of\n         None \\<Rightarrow>\n           ord.sorted_list_subset_fusion (lt_of_comp c)\n            (\\<lambda>x y. c x y = Eq) rbt_keys_generator rbt_keys_generator\n            (RBT_Set2.init rbt1) (RBT_Set2.init rbt2)\n         | Some eq \\<Rightarrow>\n             ord.sorted_list_subset_fusion (lt_of_comp c) eq\n              rbt_keys_generator rbt_keys_generator (RBT_Set2.init rbt1)\n              (RBT_Set2.init rbt2))", "by (auto simp add: comparator.eq[OF ID_ccompare'] RBT_set_def member_conv_keys unfoldr_rbt_keys_generator ord.sorted_list_subset_fusion_def linorder.sorted_list_subset_correct[OF ID_ccompare] sorted_RBT_Set_keys split: option.split dest!: ID_ceq[THEN equal.equal_eq] del: iffI)"], ["proof (state)\nthis:\n  (RBT_set rbt1 \\<subseteq> RBT_set rbt2) =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''subset RBT_set RBT_set: ccompare = None''\n      (\\<lambda>_. RBT_set rbt1 \\<subseteq> RBT_set rbt2)\n   | Some c \\<Rightarrow>\n       case ID CEQ('d) of\n       None \\<Rightarrow>\n         ord.sorted_list_subset_fusion (lt_of_comp c)\n          (\\<lambda>x y. c x y = Eq) rbt_keys_generator rbt_keys_generator\n          (RBT_Set2.init rbt1) (RBT_Set2.init rbt2)\n       | Some eq \\<Rightarrow>\n           ord.sorted_list_subset_fusion (lt_of_comp c) eq\n            rbt_keys_generator rbt_keys_generator (RBT_Set2.init rbt1)\n            (RBT_Set2.init rbt2))\n\ngoal (5 subgoals):\n 1. (RBT_set rbt \\<subseteq> B) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''subset RBT_set1: ccompare = None''\n        (\\<lambda>_. RBT_set rbt \\<subseteq> B)\n     | Some x \\<Rightarrow>\n         list_all_fusion rbt_keys_generator (\\<lambda>x. x \\<in> B)\n          (RBT_Set2.init rbt))\n 2. (DList_set dxs \\<subseteq> C) =\n    (case ID CEQ('c) of\n     None \\<Rightarrow>\n       Code.abort STR ''subset DList_set1: ceq = None''\n        (\\<lambda>_. DList_set dxs \\<subseteq> C)\n     | Some x \\<Rightarrow> DList_Set.dlist_all (\\<lambda>x. x \\<in> C) dxs)\n 3. (Set_Monad xs \\<subseteq> C) = list_all (\\<lambda>x. x \\<in> C) xs\n 4. (Collect_set P \\<subseteq> Complement A) =\n    (A \\<subseteq> {x. \\<not> P x})\n 5. (Complement A1 \\<subseteq> Complement A2) = (A2 \\<subseteq> A1)", "show ?rbt"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RBT_set rbt \\<subseteq> B) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''subset RBT_set1: ccompare = None''\n        (\\<lambda>_. RBT_set rbt \\<subseteq> B)\n     | Some x \\<Rightarrow>\n         list_all_fusion rbt_keys_generator (\\<lambda>x. x \\<in> B)\n          (RBT_Set2.init rbt))", "by(auto simp add: RBT_set_def member_conv_keys list_all_fusion_def unfoldr_rbt_keys_generator keys.rep_eq list_all_iff split: option.split)"], ["proof (state)\nthis:\n  (RBT_set rbt \\<subseteq> B) =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''subset RBT_set1: ccompare = None''\n      (\\<lambda>_. RBT_set rbt \\<subseteq> B)\n   | Some x \\<Rightarrow>\n       list_all_fusion rbt_keys_generator (\\<lambda>x. x \\<in> B)\n        (RBT_Set2.init rbt))\n\ngoal (4 subgoals):\n 1. (DList_set dxs \\<subseteq> C) =\n    (case ID CEQ('c) of\n     None \\<Rightarrow>\n       Code.abort STR ''subset DList_set1: ceq = None''\n        (\\<lambda>_. DList_set dxs \\<subseteq> C)\n     | Some x \\<Rightarrow> DList_Set.dlist_all (\\<lambda>x. x \\<in> C) dxs)\n 2. (Set_Monad xs \\<subseteq> C) = list_all (\\<lambda>x. x \\<in> C) xs\n 3. (Collect_set P \\<subseteq> Complement A) =\n    (A \\<subseteq> {x. \\<not> P x})\n 4. (Complement A1 \\<subseteq> Complement A2) = (A2 \\<subseteq> A1)", "show ?dlist"], ["proof (prove)\ngoal (1 subgoal):\n 1. (DList_set dxs \\<subseteq> C) =\n    (case ID CEQ('c) of\n     None \\<Rightarrow>\n       Code.abort STR ''subset DList_set1: ceq = None''\n        (\\<lambda>_. DList_set dxs \\<subseteq> C)\n     | Some x \\<Rightarrow> DList_Set.dlist_all (\\<lambda>x. x \\<in> C) dxs)", "by(auto simp add: DList_set_def dlist_all_conv_member split: option.split)"], ["proof (state)\nthis:\n  (DList_set dxs \\<subseteq> C) =\n  (case ID CEQ('c) of\n   None \\<Rightarrow>\n     Code.abort STR ''subset DList_set1: ceq = None''\n      (\\<lambda>_. DList_set dxs \\<subseteq> C)\n   | Some x \\<Rightarrow> DList_Set.dlist_all (\\<lambda>x. x \\<in> C) dxs)\n\ngoal (3 subgoals):\n 1. (Set_Monad xs \\<subseteq> C) = list_all (\\<lambda>x. x \\<in> C) xs\n 2. (Collect_set P \\<subseteq> Complement A) =\n    (A \\<subseteq> {x. \\<not> P x})\n 3. (Complement A1 \\<subseteq> Complement A2) = (A2 \\<subseteq> A1)", "show ?Set_Monad"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Set_Monad xs \\<subseteq> C) = list_all (\\<lambda>x. x \\<in> C) xs", "by(auto simp add: list_all_iff split: option.split)"], ["proof (state)\nthis:\n  (Set_Monad xs \\<subseteq> C) = list_all (\\<lambda>x. x \\<in> C) xs\n\ngoal (2 subgoals):\n 1. (Collect_set P \\<subseteq> Complement A) =\n    (A \\<subseteq> {x. \\<not> P x})\n 2. (Complement A1 \\<subseteq> Complement A2) = (A2 \\<subseteq> A1)", "show ?Collect_set_Compl ?Compl"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Collect_set P \\<subseteq> Complement A) =\n    (A \\<subseteq> {x. \\<not> P x}) &&&\n    (Complement A1 \\<subseteq> Complement A2) = (A2 \\<subseteq> A1)", "by auto"], ["proof (state)\nthis:\n  (Collect_set P \\<subseteq> Complement A) = (A \\<subseteq> {x. \\<not> P x})\n  (Complement A1 \\<subseteq> Complement A2) = (A2 \\<subseteq> A1)\n\ngoal:\nNo subgoals!", "qed"], ["", "hide_const (open) subset_eq"], ["", "hide_fact (open) subset_eq_def"], ["", "lemma eq_set_code [code]: \"Cardinality.eq_set = set_eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cardinality.eq_set = set_eq", "by(simp add: set_eq_def)"], ["", "lemma set_eq_code [code]:\n  fixes rbt1 rbt2 :: \"'b :: {ccompare, ceq} set_rbt\" shows\n  \"set_eq A B \\<longleftrightarrow> A \\<subseteq> B \\<and> B \\<subseteq> A\"\n  and set_eq_Complement_Complement [set_complement_code]:\n  \"set_eq (Complement A) (Complement B) = set_eq A B\"\n  and\n  \"set_eq (RBT_set rbt1) (RBT_set rbt2) = \n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''set_eq RBT_set RBT_set: ccompare = None'') (\\<lambda>_. set_eq (RBT_set rbt1) (RBT_set rbt2))\n                     | Some c \\<Rightarrow> \n     (case ID CEQ('b) of None \\<Rightarrow> list_all2_fusion (\\<lambda> x y. c x y = Eq) rbt_keys_generator rbt_keys_generator (RBT_Set2.init rbt1) (RBT_Set2.init rbt2)\n                    | Some eq \\<Rightarrow> list_all2_fusion eq rbt_keys_generator rbt_keys_generator (RBT_Set2.init rbt1) (RBT_Set2.init rbt2)))\"\n  (is ?rbt_rbt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_eq A B = (A \\<subseteq> B \\<and> B \\<subseteq> A) &&&\n    set_eq (Complement A) (Complement B) = set_eq A B &&&\n    set_eq (RBT_set rbt1) (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''set_eq RBT_set RBT_set: ccompare = None''\n        (\\<lambda>_. set_eq (RBT_set rbt1) (RBT_set rbt2))\n     | Some c \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           list_all2_fusion (\\<lambda>x y. c x y = Eq) rbt_keys_generator\n            rbt_keys_generator (RBT_Set2.init rbt1) (RBT_Set2.init rbt2)\n         | Some eq \\<Rightarrow>\n             list_all2_fusion eq rbt_keys_generator rbt_keys_generator\n              (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. set_eq A B = (A \\<subseteq> B \\<and> B \\<subseteq> A)\n 2. set_eq (Complement A) (Complement B) = set_eq A B\n 3. set_eq (RBT_set rbt1) (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''set_eq RBT_set RBT_set: ccompare = None''\n        (\\<lambda>_. set_eq (RBT_set rbt1) (RBT_set rbt2))\n     | Some c \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           list_all2_fusion (\\<lambda>x y. c x y = Eq) rbt_keys_generator\n            rbt_keys_generator (RBT_Set2.init rbt1) (RBT_Set2.init rbt2)\n         | Some eq \\<Rightarrow>\n             list_all2_fusion eq rbt_keys_generator rbt_keys_generator\n              (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))", "show ?rbt_rbt"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_eq (RBT_set rbt1) (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''set_eq RBT_set RBT_set: ccompare = None''\n        (\\<lambda>_. set_eq (RBT_set rbt1) (RBT_set rbt2))\n     | Some c \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           list_all2_fusion (\\<lambda>x y. c x y = Eq) rbt_keys_generator\n            rbt_keys_generator (RBT_Set2.init rbt1) (RBT_Set2.init rbt2)\n         | Some eq \\<Rightarrow>\n             list_all2_fusion eq rbt_keys_generator rbt_keys_generator\n              (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))", "by (auto 4 3 split: option.split simp add: comparator.eq[OF ID_ccompare'] sorted_RBT_Set_keys list_all2_fusion_def unfoldr_rbt_keys_generator RBT_set_conv_keys set_eq_def list.rel_eq dest!: ID_ceq[THEN equal.equal_eq] intro: linorder.sorted_distinct_set_unique[OF ID_ccompare])"], ["proof (state)\nthis:\n  set_eq (RBT_set rbt1) (RBT_set rbt2) =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''set_eq RBT_set RBT_set: ccompare = None''\n      (\\<lambda>_. set_eq (RBT_set rbt1) (RBT_set rbt2))\n   | Some c \\<Rightarrow>\n       case ID CEQ('b) of\n       None \\<Rightarrow>\n         list_all2_fusion (\\<lambda>x y. c x y = Eq) rbt_keys_generator\n          rbt_keys_generator (RBT_Set2.init rbt1) (RBT_Set2.init rbt2)\n       | Some eq \\<Rightarrow>\n           list_all2_fusion eq rbt_keys_generator rbt_keys_generator\n            (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))\n\ngoal (2 subgoals):\n 1. set_eq A B = (A \\<subseteq> B \\<and> B \\<subseteq> A)\n 2. set_eq (Complement A) (Complement B) = set_eq A B", "qed(auto simp add: set_eq_def)"], ["", "lemma Set_project_code [code]:\n  \"Set.filter P A = A \\<inter> Collect_set P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Set.filter P A = A \\<inter> Collect_set P", "by(auto simp add: Set.filter_def)"], ["", "lemma Set_image_code [code]:\n  fixes dxs :: \"'a :: ceq set_dlist\" \n  and rbt :: \"'b :: ccompare set_rbt\" shows\n  \"image f (Set_Monad xs) = Set_Monad (map f xs)\"\n  \"image f (Collect_set A) = Code.abort (STR ''image Collect_set'') (\\<lambda>_. image f (Collect_set A))\"\n  and image_Complement_Complement [set_complement_code]:\n  \"image f (Complement (Complement B)) = image f B\"\n  and\n  \"image g (DList_set dxs) = \n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''image DList_set: ceq = None'') (\\<lambda>_. image g (DList_set dxs))\n                  | Some _ \\<Rightarrow> DList_Set.fold (insert \\<circ> g) dxs {})\"\n  (is ?dlist)\n  \"image h (RBT_set rbt) = \n   (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''image RBT_set: ccompare = None'') (\\<lambda>_. image h (RBT_set rbt))\n                      | Some _ \\<Rightarrow> RBT_Set2.fold (insert \\<circ> h) rbt {})\"\n   (is ?rbt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (f ` Set_Monad xs = Set_Monad (map f xs) &&&\n     f ` Collect_set A =\n     Code.abort STR ''image Collect_set''\n      (\\<lambda>_. f ` Collect_set A)) &&&\n    f ` Complement (Complement B) = f ` B &&&\n    g ` DList_set dxs =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''image DList_set: ceq = None''\n        (\\<lambda>_. g ` DList_set dxs)\n     | Some x \\<Rightarrow> DList_Set.fold (insert \\<circ> g) dxs {}) &&&\n    h ` RBT_set rbt =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''image RBT_set: ccompare = None''\n        (\\<lambda>_. h ` RBT_set rbt)\n     | Some x \\<Rightarrow> RBT_Set2.fold (insert \\<circ> h) rbt {})", "proof -"], ["proof (state)\ngoal (5 subgoals):\n 1. f ` Set_Monad xs = Set_Monad (map f xs)\n 2. f ` Collect_set A =\n    Code.abort STR ''image Collect_set'' (\\<lambda>_. f ` Collect_set A)\n 3. f ` Complement (Complement B) = f ` B\n 4. g ` DList_set dxs =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''image DList_set: ceq = None''\n        (\\<lambda>_. g ` DList_set dxs)\n     | Some x \\<Rightarrow> DList_Set.fold (insert \\<circ> g) dxs {})\n 5. h ` RBT_set rbt =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''image RBT_set: ccompare = None''\n        (\\<lambda>_. h ` RBT_set rbt)\n     | Some x \\<Rightarrow> RBT_Set2.fold (insert \\<circ> h) rbt {})", "{"], ["proof (state)\ngoal (5 subgoals):\n 1. f ` Set_Monad xs = Set_Monad (map f xs)\n 2. f ` Collect_set A =\n    Code.abort STR ''image Collect_set'' (\\<lambda>_. f ` Collect_set A)\n 3. f ` Complement (Complement B) = f ` B\n 4. g ` DList_set dxs =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''image DList_set: ceq = None''\n        (\\<lambda>_. g ` DList_set dxs)\n     | Some x \\<Rightarrow> DList_Set.fold (insert \\<circ> g) dxs {})\n 5. h ` RBT_set rbt =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''image RBT_set: ccompare = None''\n        (\\<lambda>_. h ` RBT_set rbt)\n     | Some x \\<Rightarrow> RBT_Set2.fold (insert \\<circ> h) rbt {})", "fix xs"], ["proof (state)\ngoal (5 subgoals):\n 1. f ` Set_Monad xs = Set_Monad (map f xs)\n 2. f ` Collect_set A =\n    Code.abort STR ''image Collect_set'' (\\<lambda>_. f ` Collect_set A)\n 3. f ` Complement (Complement B) = f ` B\n 4. g ` DList_set dxs =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''image DList_set: ceq = None''\n        (\\<lambda>_. g ` DList_set dxs)\n     | Some x \\<Rightarrow> DList_Set.fold (insert \\<circ> g) dxs {})\n 5. h ` RBT_set rbt =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''image RBT_set: ccompare = None''\n        (\\<lambda>_. h ` RBT_set rbt)\n     | Some x \\<Rightarrow> RBT_Set2.fold (insert \\<circ> h) rbt {})", "have \"fold (insert \\<circ> g) xs {} = g ` set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (insert \\<circ> g) xs {} = g ` set xs", "by(induct xs rule: rev_induct) simp_all"], ["proof (state)\nthis:\n  fold (insert \\<circ> g) xs {} = g ` set xs\n\ngoal (5 subgoals):\n 1. f ` Set_Monad xs = Set_Monad (map f xs)\n 2. f ` Collect_set A =\n    Code.abort STR ''image Collect_set'' (\\<lambda>_. f ` Collect_set A)\n 3. f ` Complement (Complement B) = f ` B\n 4. g ` DList_set dxs =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''image DList_set: ceq = None''\n        (\\<lambda>_. g ` DList_set dxs)\n     | Some x \\<Rightarrow> DList_Set.fold (insert \\<circ> g) dxs {})\n 5. h ` RBT_set rbt =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''image RBT_set: ccompare = None''\n        (\\<lambda>_. h ` RBT_set rbt)\n     | Some x \\<Rightarrow> RBT_Set2.fold (insert \\<circ> h) rbt {})", "}"], ["proof (state)\nthis:\n  fold (insert \\<circ> g) ?xsa2 {} = g ` set ?xsa2\n\ngoal (5 subgoals):\n 1. f ` Set_Monad xs = Set_Monad (map f xs)\n 2. f ` Collect_set A =\n    Code.abort STR ''image Collect_set'' (\\<lambda>_. f ` Collect_set A)\n 3. f ` Complement (Complement B) = f ` B\n 4. g ` DList_set dxs =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''image DList_set: ceq = None''\n        (\\<lambda>_. g ` DList_set dxs)\n     | Some x \\<Rightarrow> DList_Set.fold (insert \\<circ> g) dxs {})\n 5. h ` RBT_set rbt =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''image RBT_set: ccompare = None''\n        (\\<lambda>_. h ` RBT_set rbt)\n     | Some x \\<Rightarrow> RBT_Set2.fold (insert \\<circ> h) rbt {})", "thus ?dlist"], ["proof (prove)\nusing this:\n  fold (insert \\<circ> g) ?xsa2 {} = g ` set ?xsa2\n\ngoal (1 subgoal):\n 1. g ` DList_set dxs =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''image DList_set: ceq = None''\n        (\\<lambda>_. g ` DList_set dxs)\n     | Some x \\<Rightarrow> DList_Set.fold (insert \\<circ> g) dxs {})", "by(simp add: DList_set_def DList_Set.fold_def DList_Set.Collect_member split: option.split)"], ["proof (state)\nthis:\n  g ` DList_set dxs =\n  (case ID CEQ('a) of\n   None \\<Rightarrow>\n     Code.abort STR ''image DList_set: ceq = None''\n      (\\<lambda>_. g ` DList_set dxs)\n   | Some x \\<Rightarrow> DList_Set.fold (insert \\<circ> g) dxs {})\n\ngoal (4 subgoals):\n 1. f ` Set_Monad xs = Set_Monad (map f xs)\n 2. f ` Collect_set A =\n    Code.abort STR ''image Collect_set'' (\\<lambda>_. f ` Collect_set A)\n 3. f ` Complement (Complement B) = f ` B\n 4. h ` RBT_set rbt =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''image RBT_set: ccompare = None''\n        (\\<lambda>_. h ` RBT_set rbt)\n     | Some x \\<Rightarrow> RBT_Set2.fold (insert \\<circ> h) rbt {})", "{"], ["proof (state)\nthis:\n  g ` DList_set dxs =\n  (case ID CEQ('a) of\n   None \\<Rightarrow>\n     Code.abort STR ''image DList_set: ceq = None''\n      (\\<lambda>_. g ` DList_set dxs)\n   | Some x \\<Rightarrow> DList_Set.fold (insert \\<circ> g) dxs {})\n\ngoal (4 subgoals):\n 1. f ` Set_Monad xs = Set_Monad (map f xs)\n 2. f ` Collect_set A =\n    Code.abort STR ''image Collect_set'' (\\<lambda>_. f ` Collect_set A)\n 3. f ` Complement (Complement B) = f ` B\n 4. h ` RBT_set rbt =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''image RBT_set: ccompare = None''\n        (\\<lambda>_. h ` RBT_set rbt)\n     | Some x \\<Rightarrow> RBT_Set2.fold (insert \\<circ> h) rbt {})", "fix xs"], ["proof (state)\ngoal (4 subgoals):\n 1. f ` Set_Monad xs = Set_Monad (map f xs)\n 2. f ` Collect_set A =\n    Code.abort STR ''image Collect_set'' (\\<lambda>_. f ` Collect_set A)\n 3. f ` Complement (Complement B) = f ` B\n 4. h ` RBT_set rbt =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''image RBT_set: ccompare = None''\n        (\\<lambda>_. h ` RBT_set rbt)\n     | Some x \\<Rightarrow> RBT_Set2.fold (insert \\<circ> h) rbt {})", "have \"fold (insert \\<circ> h) xs {} = h ` set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (insert \\<circ> h) xs {} = h ` set xs", "by(induct xs rule: rev_induct) simp_all"], ["proof (state)\nthis:\n  fold (insert \\<circ> h) xs {} = h ` set xs\n\ngoal (4 subgoals):\n 1. f ` Set_Monad xs = Set_Monad (map f xs)\n 2. f ` Collect_set A =\n    Code.abort STR ''image Collect_set'' (\\<lambda>_. f ` Collect_set A)\n 3. f ` Complement (Complement B) = f ` B\n 4. h ` RBT_set rbt =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''image RBT_set: ccompare = None''\n        (\\<lambda>_. h ` RBT_set rbt)\n     | Some x \\<Rightarrow> RBT_Set2.fold (insert \\<circ> h) rbt {})", "}"], ["proof (state)\nthis:\n  fold (insert \\<circ> h) ?xsa2 {} = h ` set ?xsa2\n\ngoal (4 subgoals):\n 1. f ` Set_Monad xs = Set_Monad (map f xs)\n 2. f ` Collect_set A =\n    Code.abort STR ''image Collect_set'' (\\<lambda>_. f ` Collect_set A)\n 3. f ` Complement (Complement B) = f ` B\n 4. h ` RBT_set rbt =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''image RBT_set: ccompare = None''\n        (\\<lambda>_. h ` RBT_set rbt)\n     | Some x \\<Rightarrow> RBT_Set2.fold (insert \\<circ> h) rbt {})", "thus ?rbt"], ["proof (prove)\nusing this:\n  fold (insert \\<circ> h) ?xsa2 {} = h ` set ?xsa2\n\ngoal (1 subgoal):\n 1. h ` RBT_set rbt =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''image RBT_set: ccompare = None''\n        (\\<lambda>_. h ` RBT_set rbt)\n     | Some x \\<Rightarrow> RBT_Set2.fold (insert \\<circ> h) rbt {})", "by(auto simp add: RBT_set_def fold_conv_fold_keys member_conv_keys split: option.split)"], ["proof (state)\nthis:\n  h ` RBT_set rbt =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''image RBT_set: ccompare = None''\n      (\\<lambda>_. h ` RBT_set rbt)\n   | Some x \\<Rightarrow> RBT_Set2.fold (insert \\<circ> h) rbt {})\n\ngoal (3 subgoals):\n 1. f ` Set_Monad xs = Set_Monad (map f xs)\n 2. f ` Collect_set A =\n    Code.abort STR ''image Collect_set'' (\\<lambda>_. f ` Collect_set A)\n 3. f ` Complement (Complement B) = f ` B", "qed simp_all"], ["", "lemma the_elem_code [code]:\n  fixes dxs :: \"'a :: ceq set_dlist\" \n  and rbt :: \"'b :: ccompare set_rbt\" shows\n  \"the_elem (Set_Monad [x]) = x\"\n  \"the_elem (DList_set dxs) =\n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''the_elem DList_set: ceq = None'') (\\<lambda>_. the_elem (DList_set dxs))\n                  | Some _ \\<Rightarrow> \n     case list_of_dlist dxs of [x] \\<Rightarrow> x \n       | _ \\<Rightarrow> Code.abort (STR ''the_elem DList_set: not unique'') (\\<lambda>_. the_elem (DList_set dxs)))\"\n  \"the_elem (RBT_set rbt) =\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''the_elem RBT_set: ccompare = None'') (\\<lambda>_. the_elem (RBT_set rbt))\n                     | Some _ \\<Rightarrow> \n     case RBT_Mapping2.impl_of rbt of RBT_Impl.Branch _ RBT_Impl.Empty x _ RBT_Impl.Empty \\<Rightarrow> x\n       | _ \\<Rightarrow> Code.abort (STR ''the_elem RBT_set: not unique'') (\\<lambda>_. the_elem (RBT_set rbt)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_elem (Set_Monad [x]) = x &&&\n    the_elem (DList_set dxs) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''the_elem DList_set: ceq = None''\n        (\\<lambda>_. the_elem (DList_set dxs))\n     | Some x \\<Rightarrow>\n         case list_of_dlist dxs of\n         [] \\<Rightarrow>\n           Code.abort STR ''the_elem DList_set: not unique''\n            (\\<lambda>_. the_elem (DList_set dxs))\n         | [x] \\<Rightarrow> x\n         | x # aa # lista \\<Rightarrow>\n             Code.abort STR ''the_elem DList_set: not unique''\n              (\\<lambda>_. the_elem (DList_set dxs))) &&&\n    the_elem (RBT_set rbt) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''the_elem RBT_set: ccompare = None''\n        (\\<lambda>_. the_elem (RBT_set rbt))\n     | Some x \\<Rightarrow>\n         case mapping_rbt.impl_of rbt of\n         rbt.Empty \\<Rightarrow>\n           Code.abort STR ''the_elem RBT_set: not unique''\n            (\\<lambda>_. the_elem (RBT_set rbt))\n         | Branch xa rbt.Empty x xb rbt.Empty \\<Rightarrow> x\n         | Branch xa rbt.Empty x xb\n            (Branch colora rbt1 aa ba rbt2a) \\<Rightarrow>\n             Code.abort STR ''the_elem RBT_set: not unique''\n              (\\<lambda>_. the_elem (RBT_set rbt))\n         | Branch xa (Branch colora rbt1a ab bb rbt2b) x xb\n            rbt2 \\<Rightarrow>\n             Code.abort STR ''the_elem RBT_set: not unique''\n              (\\<lambda>_. the_elem (RBT_set rbt)))", "by(auto simp add: RBT_set_def DList_set_def DList_Set.Collect_member the_elem_def member_conv_keys split: option.split list.split rbt.split)(simp add: RBT_Set2.keys_def)"], ["", "lemma Pow_set_conv_fold:\n  \"Pow (set xs \\<union> A) = fold (\\<lambda>x A. A \\<union> insert x ` A) xs (Pow A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pow (set xs \\<union> A) =\n    fold (\\<lambda>x A. A \\<union> insert x ` A) xs (Pow A)", "by(induct xs rule: rev_induct)(auto simp add: Pow_insert)"], ["", "lemma Pow_code [code]:\n  fixes dxs :: \"'a :: ceq set_dlist\" \n  and rbt :: \"'b :: ccompare set_rbt\" shows\n  \"Pow A = Collect_set (\\<lambda>B. B \\<subseteq> A)\"\n  \"Pow (Set_Monad xs) = fold (\\<lambda>x A. A \\<union> insert x ` A) xs {{}}\"\n  \"Pow (DList_set dxs) =\n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''Pow DList_set: ceq = None'') (\\<lambda>_. Pow (DList_set dxs))\n                  | Some _ \\<Rightarrow> DList_Set.fold (\\<lambda>x A. A \\<union> insert x ` A) dxs {{}})\"\n  \"Pow (RBT_set rbt) =\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''Pow RBT_set: ccompare = None'') (\\<lambda>_. Pow (RBT_set rbt))\n                     | Some _ \\<Rightarrow> RBT_Set2.fold (\\<lambda>x A. A \\<union> insert x ` A) rbt {{}})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Pow A = Collect_set (\\<lambda>B. B \\<subseteq> A) &&&\n     Pow (Set_Monad xs) =\n     fold (\\<lambda>x A. A \\<union> insert x ` A) xs {{}}) &&&\n    Pow (DList_set dxs) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''Pow DList_set: ceq = None''\n        (\\<lambda>_. Pow (DList_set dxs))\n     | Some x \\<Rightarrow>\n         DList_Set.fold (\\<lambda>x A. A \\<union> insert x ` A) dxs\n          {{}}) &&&\n    Pow (RBT_set rbt) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''Pow RBT_set: ccompare = None''\n        (\\<lambda>_. Pow (RBT_set rbt))\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>x A. A \\<union> insert x ` A) rbt {{}})", "by(auto simp add: DList_set_def DList_Set.Collect_member DList_Set.fold_def RBT_set_def fold_conv_fold_keys member_conv_keys Pow_set_conv_fold[where A=\"{}\", simplified] split: option.split)"], ["", "lemma fold_singleton: \"Finite_Set.fold f x {y} = f y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_Set.fold f x {y} = f y x", "by(fastforce simp add: Finite_Set.fold_def intro: fold_graph.intros elim: fold_graph.cases)"], ["", "lift_definition sum_cfc :: \"('a \\<Rightarrow> 'b :: comm_monoid_add) \\<Rightarrow> ('a, 'b) comp_fun_commute\"\nis \"\\<lambda>f :: 'a \\<Rightarrow> 'b. plus \\<circ> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun. comp_fun_commute ((+) \\<circ> fun)", "by(unfold_locales)(simp add: fun_eq_iff add.left_commute)"], ["", "lemma sum_code [code]:\n  \"sum f A = (if finite A then set_fold_cfc (sum_cfc f) 0 A else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f A =\n    (if finite A then set_fold_cfc (sum_cfc f) (0::'a) A else (0::'a))", "by transfer(simp add: sum.eq_fold)"], ["", "lemma product_code [code]:\n  fixes dxs :: \"'a :: ceq set_dlist\"\n  and dys :: \"'b :: ceq set_dlist\" \n  and rbt1 :: \"'c :: ccompare set_rbt\"\n  and rbt2 :: \"'d :: ccompare set_rbt\" shows\n  \"Product_Type.product A B = Collect_set (\\<lambda>(x, y). x \\<in> A \\<and> y \\<in> B)\"\n\n  \"Product_Type.product (Set_Monad xs) (Set_Monad ys) = \n   Set_Monad (fold (\\<lambda>x. fold (\\<lambda>y rest. (x, y) # rest) ys) xs [])\"\n  (is ?Set_Monad)\n\n  \"Product_Type.product (DList_set dxs) B1 = \n   (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''product DList_set1: ceq = None'') (\\<lambda>_. Product_Type.product (DList_set dxs) B1)\n                   | Some _ \\<Rightarrow>  DList_Set.fold (\\<lambda>x rest. Pair x ` B1 \\<union> rest) dxs {})\" \n  (is \"?dlist1\")\n\n  \"Product_Type.product A1 (DList_set dys) = \n   (case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''product DList_set2: ceq = None'') (\\<lambda>_. Product_Type.product A1 (DList_set dys))\n                   | Some _ \\<Rightarrow> DList_Set.fold (\\<lambda>y rest. (\\<lambda>x. (x, y)) ` A1 \\<union> rest) dys {})\"\n  (is \"?dlist2\")\n\n  \"Product_Type.product (DList_set dxs) (DList_set dys) = \n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''product DList_set DList_set: ceq1 = None'') (\\<lambda>_. Product_Type.product (DList_set dxs) (DList_set dys))\n                  | Some _ \\<Rightarrow> \n     case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''product DList_set DList_set: ceq2 = None'') (\\<lambda>_. Product_Type.product (DList_set dxs) (DList_set dys))\n                    | Some _ \\<Rightarrow> DList_set (DList_Set.product dxs dys))\"\n\n  \"Product_Type.product (RBT_set rbt1) B2 =\n  (case ID CCOMPARE('c) of None \\<Rightarrow> Code.abort (STR ''product RBT_set: ccompare1 = None'') (\\<lambda>_. Product_Type.product (RBT_set rbt1) B2)\n                     | Some _ \\<Rightarrow> RBT_Set2.fold (\\<lambda>x rest. Pair x ` B2 \\<union> rest) rbt1 {})\"\n  (is \"?rbt1\")\n\n  \"Product_Type.product A2 (RBT_set rbt2) =\n  (case ID CCOMPARE('d) of None \\<Rightarrow> Code.abort (STR ''product RBT_set: ccompare2 = None'') (\\<lambda>_. Product_Type.product A2 (RBT_set rbt2))\n                     | Some _ \\<Rightarrow> RBT_Set2.fold (\\<lambda>y rest. (\\<lambda>x. (x, y)) ` A2 \\<union> rest) rbt2 {})\"\n  (is \"?rbt2\")\n\n  \"Product_Type.product (RBT_set rbt1) (RBT_set rbt2) =\n  (case ID CCOMPARE('c) of None \\<Rightarrow> Code.abort (STR ''product RBT_set RBT_set: ccompare1 = None'') (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n                     | Some _ \\<Rightarrow>\n     case ID CCOMPARE('d) of None \\<Rightarrow> Code.abort (STR ''product RBT_set RBT_set: ccompare2 = None'') (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n                       | Some _ \\<Rightarrow> RBT_set (RBT_Set2.product rbt1 rbt2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Product_Type.product A B =\n      Collect_set (\\<lambda>(x, y). x \\<in> A \\<and> y \\<in> B) &&&\n      Product_Type.product (Set_Monad xs) (Set_Monad ys) =\n      Set_Monad\n       (fold (\\<lambda>x. fold (\\<lambda>y. (#) (x, y)) ys) xs [])) &&&\n     Product_Type.product (DList_set dxs) B1 =\n     (case ID CEQ('a) of\n      None \\<Rightarrow>\n        Code.abort STR ''product DList_set1: ceq = None''\n         (\\<lambda>_. Product_Type.product (DList_set dxs) B1)\n      | Some x \\<Rightarrow>\n          DList_Set.fold (\\<lambda>x. (\\<union>) (Pair x ` B1)) dxs {}) &&&\n     Product_Type.product A1 (DList_set dys) =\n     (case ID CEQ('b) of\n      None \\<Rightarrow>\n        Code.abort STR ''product DList_set2: ceq = None''\n         (\\<lambda>_. Product_Type.product A1 (DList_set dys))\n      | Some x \\<Rightarrow>\n          DList_Set.fold\n           (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A1)) dys {})) &&&\n    (Product_Type.product (DList_set dxs) (DList_set dys) =\n     (case ID CEQ('a) of\n      None \\<Rightarrow>\n        Code.abort STR ''product DList_set DList_set: ceq1 = None''\n         (\\<lambda>_. Product_Type.product (DList_set dxs) (DList_set dys))\n      | Some x \\<Rightarrow>\n          case ID CEQ('b) of\n          None \\<Rightarrow>\n            Code.abort STR ''product DList_set DList_set: ceq2 = None''\n             (\\<lambda>_.\n                 Product_Type.product (DList_set dxs) (DList_set dys))\n          | Some x \\<Rightarrow> DList_set (DList_Set.product dxs dys)) &&&\n     Product_Type.product (RBT_set rbt1) B2 =\n     (case ID ccompare of\n      None \\<Rightarrow>\n        Code.abort STR ''product RBT_set: ccompare1 = None''\n         (\\<lambda>_. Product_Type.product (RBT_set rbt1) B2)\n      | Some x \\<Rightarrow>\n          RBT_Set2.fold (\\<lambda>x. (\\<union>) (Pair x ` B2)) rbt1 {})) &&&\n    Product_Type.product A2 (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set: ccompare2 = None''\n        (\\<lambda>_. Product_Type.product A2 (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A2))\n          rbt2 {}) &&&\n    Product_Type.product (RBT_set rbt1) (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set RBT_set: ccompare1 = None''\n        (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''product RBT_set RBT_set: ccompare2 = None''\n            (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n         | Some x \\<Rightarrow> RBT_set (RBT_Set2.product rbt1 rbt2))", "proof -"], ["proof (state)\ngoal (8 subgoals):\n 1. Product_Type.product A B =\n    Collect_set (\\<lambda>(x, y). x \\<in> A \\<and> y \\<in> B)\n 2. Product_Type.product (Set_Monad xs) (Set_Monad ys) =\n    Set_Monad (fold (\\<lambda>x. fold (\\<lambda>y. (#) (x, y)) ys) xs [])\n 3. Product_Type.product (DList_set dxs) B1 =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set1: ceq = None''\n        (\\<lambda>_. Product_Type.product (DList_set dxs) B1)\n     | Some x \\<Rightarrow>\n         DList_Set.fold (\\<lambda>x. (\\<union>) (Pair x ` B1)) dxs {})\n 4. Product_Type.product A1 (DList_set dys) =\n    (case ID CEQ('b) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set2: ceq = None''\n        (\\<lambda>_. Product_Type.product A1 (DList_set dys))\n     | Some x \\<Rightarrow>\n         DList_Set.fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A1))\n          dys {})\n 5. Product_Type.product (DList_set dxs) (DList_set dys) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set DList_set: ceq1 = None''\n        (\\<lambda>_. Product_Type.product (DList_set dxs) (DList_set dys))\n     | Some x \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           Code.abort STR ''product DList_set DList_set: ceq2 = None''\n            (\\<lambda>_.\n                Product_Type.product (DList_set dxs) (DList_set dys))\n         | Some x \\<Rightarrow> DList_set (DList_Set.product dxs dys))\n 6. Product_Type.product (RBT_set rbt1) B2 =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set: ccompare1 = None''\n        (\\<lambda>_. Product_Type.product (RBT_set rbt1) B2)\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>x. (\\<union>) (Pair x ` B2)) rbt1 {})\n 7. Product_Type.product A2 (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set: ccompare2 = None''\n        (\\<lambda>_. Product_Type.product A2 (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A2))\n          rbt2 {})\n 8. Product_Type.product (RBT_set rbt1) (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set RBT_set: ccompare1 = None''\n        (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''product RBT_set RBT_set: ccompare2 = None''\n            (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n         | Some x \\<Rightarrow> RBT_set (RBT_Set2.product rbt1 rbt2))", "have [simp]: \"\\<And>a zs. fold (\\<lambda>y. (#) (a, y)) ys zs = rev (map (Pair a) ys) @ zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a zs.\n       fold (\\<lambda>y. (#) (a, y)) ys zs = rev (map (Pair a) ys) @ zs", "by(induct ys) simp_all"], ["proof (state)\nthis:\n  fold (\\<lambda>y. (#) (?a, y)) ys ?zs = rev (map (Pair ?a) ys) @ ?zs\n\ngoal (8 subgoals):\n 1. Product_Type.product A B =\n    Collect_set (\\<lambda>(x, y). x \\<in> A \\<and> y \\<in> B)\n 2. Product_Type.product (Set_Monad xs) (Set_Monad ys) =\n    Set_Monad (fold (\\<lambda>x. fold (\\<lambda>y. (#) (x, y)) ys) xs [])\n 3. Product_Type.product (DList_set dxs) B1 =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set1: ceq = None''\n        (\\<lambda>_. Product_Type.product (DList_set dxs) B1)\n     | Some x \\<Rightarrow>\n         DList_Set.fold (\\<lambda>x. (\\<union>) (Pair x ` B1)) dxs {})\n 4. Product_Type.product A1 (DList_set dys) =\n    (case ID CEQ('b) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set2: ceq = None''\n        (\\<lambda>_. Product_Type.product A1 (DList_set dys))\n     | Some x \\<Rightarrow>\n         DList_Set.fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A1))\n          dys {})\n 5. Product_Type.product (DList_set dxs) (DList_set dys) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set DList_set: ceq1 = None''\n        (\\<lambda>_. Product_Type.product (DList_set dxs) (DList_set dys))\n     | Some x \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           Code.abort STR ''product DList_set DList_set: ceq2 = None''\n            (\\<lambda>_.\n                Product_Type.product (DList_set dxs) (DList_set dys))\n         | Some x \\<Rightarrow> DList_set (DList_Set.product dxs dys))\n 6. Product_Type.product (RBT_set rbt1) B2 =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set: ccompare1 = None''\n        (\\<lambda>_. Product_Type.product (RBT_set rbt1) B2)\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>x. (\\<union>) (Pair x ` B2)) rbt1 {})\n 7. Product_Type.product A2 (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set: ccompare2 = None''\n        (\\<lambda>_. Product_Type.product A2 (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A2))\n          rbt2 {})\n 8. Product_Type.product (RBT_set rbt1) (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set RBT_set: ccompare1 = None''\n        (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''product RBT_set RBT_set: ccompare2 = None''\n            (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n         | Some x \\<Rightarrow> RBT_set (RBT_Set2.product rbt1 rbt2))", "have [simp]: \"\\<And>zs. fold (\\<lambda>x. fold (\\<lambda>y rest. (x, y) # rest) ys) xs zs = rev (concat (map (\\<lambda>x. map (Pair x) ys) xs)) @ zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>zs.\n       fold (\\<lambda>x. fold (\\<lambda>y. (#) (x, y)) ys) xs zs =\n       rev (concat (map (\\<lambda>x. map (Pair x) ys) xs)) @ zs", "by(induct xs) simp_all"], ["proof (state)\nthis:\n  fold (\\<lambda>x. fold (\\<lambda>y. (#) (x, y)) ys) xs ?zs1 =\n  rev (concat (map (\\<lambda>x. map (Pair x) ys) xs)) @ ?zs1\n\ngoal (8 subgoals):\n 1. Product_Type.product A B =\n    Collect_set (\\<lambda>(x, y). x \\<in> A \\<and> y \\<in> B)\n 2. Product_Type.product (Set_Monad xs) (Set_Monad ys) =\n    Set_Monad (fold (\\<lambda>x. fold (\\<lambda>y. (#) (x, y)) ys) xs [])\n 3. Product_Type.product (DList_set dxs) B1 =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set1: ceq = None''\n        (\\<lambda>_. Product_Type.product (DList_set dxs) B1)\n     | Some x \\<Rightarrow>\n         DList_Set.fold (\\<lambda>x. (\\<union>) (Pair x ` B1)) dxs {})\n 4. Product_Type.product A1 (DList_set dys) =\n    (case ID CEQ('b) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set2: ceq = None''\n        (\\<lambda>_. Product_Type.product A1 (DList_set dys))\n     | Some x \\<Rightarrow>\n         DList_Set.fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A1))\n          dys {})\n 5. Product_Type.product (DList_set dxs) (DList_set dys) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set DList_set: ceq1 = None''\n        (\\<lambda>_. Product_Type.product (DList_set dxs) (DList_set dys))\n     | Some x \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           Code.abort STR ''product DList_set DList_set: ceq2 = None''\n            (\\<lambda>_.\n                Product_Type.product (DList_set dxs) (DList_set dys))\n         | Some x \\<Rightarrow> DList_set (DList_Set.product dxs dys))\n 6. Product_Type.product (RBT_set rbt1) B2 =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set: ccompare1 = None''\n        (\\<lambda>_. Product_Type.product (RBT_set rbt1) B2)\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>x. (\\<union>) (Pair x ` B2)) rbt1 {})\n 7. Product_Type.product A2 (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set: ccompare2 = None''\n        (\\<lambda>_. Product_Type.product A2 (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A2))\n          rbt2 {})\n 8. Product_Type.product (RBT_set rbt1) (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set RBT_set: ccompare1 = None''\n        (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''product RBT_set RBT_set: ccompare2 = None''\n            (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n         | Some x \\<Rightarrow> RBT_set (RBT_Set2.product rbt1 rbt2))", "show ?Set_Monad"], ["proof (prove)\ngoal (1 subgoal):\n 1. Product_Type.product (Set_Monad xs) (Set_Monad ys) =\n    Set_Monad (fold (\\<lambda>x. fold (\\<lambda>y. (#) (x, y)) ys) xs [])", "by(auto simp add: Product_Type.product_def)"], ["proof (state)\nthis:\n  Product_Type.product (Set_Monad xs) (Set_Monad ys) =\n  Set_Monad (fold (\\<lambda>x. fold (\\<lambda>y. (#) (x, y)) ys) xs [])\n\ngoal (7 subgoals):\n 1. Product_Type.product A B =\n    Collect_set (\\<lambda>(x, y). x \\<in> A \\<and> y \\<in> B)\n 2. Product_Type.product (DList_set dxs) B1 =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set1: ceq = None''\n        (\\<lambda>_. Product_Type.product (DList_set dxs) B1)\n     | Some x \\<Rightarrow>\n         DList_Set.fold (\\<lambda>x. (\\<union>) (Pair x ` B1)) dxs {})\n 3. Product_Type.product A1 (DList_set dys) =\n    (case ID CEQ('b) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set2: ceq = None''\n        (\\<lambda>_. Product_Type.product A1 (DList_set dys))\n     | Some x \\<Rightarrow>\n         DList_Set.fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A1))\n          dys {})\n 4. Product_Type.product (DList_set dxs) (DList_set dys) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set DList_set: ceq1 = None''\n        (\\<lambda>_. Product_Type.product (DList_set dxs) (DList_set dys))\n     | Some x \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           Code.abort STR ''product DList_set DList_set: ceq2 = None''\n            (\\<lambda>_.\n                Product_Type.product (DList_set dxs) (DList_set dys))\n         | Some x \\<Rightarrow> DList_set (DList_Set.product dxs dys))\n 5. Product_Type.product (RBT_set rbt1) B2 =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set: ccompare1 = None''\n        (\\<lambda>_. Product_Type.product (RBT_set rbt1) B2)\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>x. (\\<union>) (Pair x ` B2)) rbt1 {})\n 6. Product_Type.product A2 (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set: ccompare2 = None''\n        (\\<lambda>_. Product_Type.product A2 (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A2))\n          rbt2 {})\n 7. Product_Type.product (RBT_set rbt1) (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set RBT_set: ccompare1 = None''\n        (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''product RBT_set RBT_set: ccompare2 = None''\n            (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n         | Some x \\<Rightarrow> RBT_set (RBT_Set2.product rbt1 rbt2))", "{"], ["proof (state)\nthis:\n  Product_Type.product (Set_Monad xs) (Set_Monad ys) =\n  Set_Monad (fold (\\<lambda>x. fold (\\<lambda>y. (#) (x, y)) ys) xs [])\n\ngoal (7 subgoals):\n 1. Product_Type.product A B =\n    Collect_set (\\<lambda>(x, y). x \\<in> A \\<and> y \\<in> B)\n 2. Product_Type.product (DList_set dxs) B1 =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set1: ceq = None''\n        (\\<lambda>_. Product_Type.product (DList_set dxs) B1)\n     | Some x \\<Rightarrow>\n         DList_Set.fold (\\<lambda>x. (\\<union>) (Pair x ` B1)) dxs {})\n 3. Product_Type.product A1 (DList_set dys) =\n    (case ID CEQ('b) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set2: ceq = None''\n        (\\<lambda>_. Product_Type.product A1 (DList_set dys))\n     | Some x \\<Rightarrow>\n         DList_Set.fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A1))\n          dys {})\n 4. Product_Type.product (DList_set dxs) (DList_set dys) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set DList_set: ceq1 = None''\n        (\\<lambda>_. Product_Type.product (DList_set dxs) (DList_set dys))\n     | Some x \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           Code.abort STR ''product DList_set DList_set: ceq2 = None''\n            (\\<lambda>_.\n                Product_Type.product (DList_set dxs) (DList_set dys))\n         | Some x \\<Rightarrow> DList_set (DList_Set.product dxs dys))\n 5. Product_Type.product (RBT_set rbt1) B2 =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set: ccompare1 = None''\n        (\\<lambda>_. Product_Type.product (RBT_set rbt1) B2)\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>x. (\\<union>) (Pair x ` B2)) rbt1 {})\n 6. Product_Type.product A2 (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set: ccompare2 = None''\n        (\\<lambda>_. Product_Type.product A2 (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A2))\n          rbt2 {})\n 7. Product_Type.product (RBT_set rbt1) (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set RBT_set: ccompare1 = None''\n        (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''product RBT_set RBT_set: ccompare2 = None''\n            (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n         | Some x \\<Rightarrow> RBT_set (RBT_Set2.product rbt1 rbt2))", "fix xs :: \"'a list\""], ["proof (state)\ngoal (7 subgoals):\n 1. Product_Type.product A B =\n    Collect_set (\\<lambda>(x, y). x \\<in> A \\<and> y \\<in> B)\n 2. Product_Type.product (DList_set dxs) B1 =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set1: ceq = None''\n        (\\<lambda>_. Product_Type.product (DList_set dxs) B1)\n     | Some x \\<Rightarrow>\n         DList_Set.fold (\\<lambda>x. (\\<union>) (Pair x ` B1)) dxs {})\n 3. Product_Type.product A1 (DList_set dys) =\n    (case ID CEQ('b) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set2: ceq = None''\n        (\\<lambda>_. Product_Type.product A1 (DList_set dys))\n     | Some x \\<Rightarrow>\n         DList_Set.fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A1))\n          dys {})\n 4. Product_Type.product (DList_set dxs) (DList_set dys) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set DList_set: ceq1 = None''\n        (\\<lambda>_. Product_Type.product (DList_set dxs) (DList_set dys))\n     | Some x \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           Code.abort STR ''product DList_set DList_set: ceq2 = None''\n            (\\<lambda>_.\n                Product_Type.product (DList_set dxs) (DList_set dys))\n         | Some x \\<Rightarrow> DList_set (DList_Set.product dxs dys))\n 5. Product_Type.product (RBT_set rbt1) B2 =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set: ccompare1 = None''\n        (\\<lambda>_. Product_Type.product (RBT_set rbt1) B2)\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>x. (\\<union>) (Pair x ` B2)) rbt1 {})\n 6. Product_Type.product A2 (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set: ccompare2 = None''\n        (\\<lambda>_. Product_Type.product A2 (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A2))\n          rbt2 {})\n 7. Product_Type.product (RBT_set rbt1) (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set RBT_set: ccompare1 = None''\n        (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''product RBT_set RBT_set: ccompare2 = None''\n            (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n         | Some x \\<Rightarrow> RBT_set (RBT_Set2.product rbt1 rbt2))", "have \"fold (\\<lambda>x. (\\<union>) (Pair x ` B1)) xs {} = set xs \\<times> B1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>x. (\\<union>) (Pair x ` B1)) xs {} = set xs \\<times> B1", "by(induct xs rule: rev_induct) auto"], ["proof (state)\nthis:\n  fold (\\<lambda>x. (\\<union>) (Pair x ` B1)) xs {} = set xs \\<times> B1\n\ngoal (7 subgoals):\n 1. Product_Type.product A B =\n    Collect_set (\\<lambda>(x, y). x \\<in> A \\<and> y \\<in> B)\n 2. Product_Type.product (DList_set dxs) B1 =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set1: ceq = None''\n        (\\<lambda>_. Product_Type.product (DList_set dxs) B1)\n     | Some x \\<Rightarrow>\n         DList_Set.fold (\\<lambda>x. (\\<union>) (Pair x ` B1)) dxs {})\n 3. Product_Type.product A1 (DList_set dys) =\n    (case ID CEQ('b) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set2: ceq = None''\n        (\\<lambda>_. Product_Type.product A1 (DList_set dys))\n     | Some x \\<Rightarrow>\n         DList_Set.fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A1))\n          dys {})\n 4. Product_Type.product (DList_set dxs) (DList_set dys) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set DList_set: ceq1 = None''\n        (\\<lambda>_. Product_Type.product (DList_set dxs) (DList_set dys))\n     | Some x \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           Code.abort STR ''product DList_set DList_set: ceq2 = None''\n            (\\<lambda>_.\n                Product_Type.product (DList_set dxs) (DList_set dys))\n         | Some x \\<Rightarrow> DList_set (DList_Set.product dxs dys))\n 5. Product_Type.product (RBT_set rbt1) B2 =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set: ccompare1 = None''\n        (\\<lambda>_. Product_Type.product (RBT_set rbt1) B2)\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>x. (\\<union>) (Pair x ` B2)) rbt1 {})\n 6. Product_Type.product A2 (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set: ccompare2 = None''\n        (\\<lambda>_. Product_Type.product A2 (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A2))\n          rbt2 {})\n 7. Product_Type.product (RBT_set rbt1) (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set RBT_set: ccompare1 = None''\n        (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''product RBT_set RBT_set: ccompare2 = None''\n            (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n         | Some x \\<Rightarrow> RBT_set (RBT_Set2.product rbt1 rbt2))", "}"], ["proof (state)\nthis:\n  fold (\\<lambda>x. (\\<union>) (Pair x ` B1)) ?xsa3 {} =\n  set ?xsa3 \\<times> B1\n\ngoal (7 subgoals):\n 1. Product_Type.product A B =\n    Collect_set (\\<lambda>(x, y). x \\<in> A \\<and> y \\<in> B)\n 2. Product_Type.product (DList_set dxs) B1 =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set1: ceq = None''\n        (\\<lambda>_. Product_Type.product (DList_set dxs) B1)\n     | Some x \\<Rightarrow>\n         DList_Set.fold (\\<lambda>x. (\\<union>) (Pair x ` B1)) dxs {})\n 3. Product_Type.product A1 (DList_set dys) =\n    (case ID CEQ('b) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set2: ceq = None''\n        (\\<lambda>_. Product_Type.product A1 (DList_set dys))\n     | Some x \\<Rightarrow>\n         DList_Set.fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A1))\n          dys {})\n 4. Product_Type.product (DList_set dxs) (DList_set dys) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set DList_set: ceq1 = None''\n        (\\<lambda>_. Product_Type.product (DList_set dxs) (DList_set dys))\n     | Some x \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           Code.abort STR ''product DList_set DList_set: ceq2 = None''\n            (\\<lambda>_.\n                Product_Type.product (DList_set dxs) (DList_set dys))\n         | Some x \\<Rightarrow> DList_set (DList_Set.product dxs dys))\n 5. Product_Type.product (RBT_set rbt1) B2 =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set: ccompare1 = None''\n        (\\<lambda>_. Product_Type.product (RBT_set rbt1) B2)\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>x. (\\<union>) (Pair x ` B2)) rbt1 {})\n 6. Product_Type.product A2 (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set: ccompare2 = None''\n        (\\<lambda>_. Product_Type.product A2 (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A2))\n          rbt2 {})\n 7. Product_Type.product (RBT_set rbt1) (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set RBT_set: ccompare1 = None''\n        (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''product RBT_set RBT_set: ccompare2 = None''\n            (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n         | Some x \\<Rightarrow> RBT_set (RBT_Set2.product rbt1 rbt2))", "thus ?dlist1"], ["proof (prove)\nusing this:\n  fold (\\<lambda>x. (\\<union>) (Pair x ` B1)) ?xsa3 {} =\n  set ?xsa3 \\<times> B1\n\ngoal (1 subgoal):\n 1. Product_Type.product (DList_set dxs) B1 =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set1: ceq = None''\n        (\\<lambda>_. Product_Type.product (DList_set dxs) B1)\n     | Some x \\<Rightarrow>\n         DList_Set.fold (\\<lambda>x. (\\<union>) (Pair x ` B1)) dxs {})", "by(simp add: Product_Type.product_def DList_set_def DList_Set.fold.rep_eq DList_Set.Collect_member split: option.split)"], ["proof (state)\nthis:\n  Product_Type.product (DList_set dxs) B1 =\n  (case ID CEQ('a) of\n   None \\<Rightarrow>\n     Code.abort STR ''product DList_set1: ceq = None''\n      (\\<lambda>_. Product_Type.product (DList_set dxs) B1)\n   | Some x \\<Rightarrow>\n       DList_Set.fold (\\<lambda>x. (\\<union>) (Pair x ` B1)) dxs {})\n\ngoal (6 subgoals):\n 1. Product_Type.product A B =\n    Collect_set (\\<lambda>(x, y). x \\<in> A \\<and> y \\<in> B)\n 2. Product_Type.product A1 (DList_set dys) =\n    (case ID CEQ('b) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set2: ceq = None''\n        (\\<lambda>_. Product_Type.product A1 (DList_set dys))\n     | Some x \\<Rightarrow>\n         DList_Set.fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A1))\n          dys {})\n 3. Product_Type.product (DList_set dxs) (DList_set dys) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set DList_set: ceq1 = None''\n        (\\<lambda>_. Product_Type.product (DList_set dxs) (DList_set dys))\n     | Some x \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           Code.abort STR ''product DList_set DList_set: ceq2 = None''\n            (\\<lambda>_.\n                Product_Type.product (DList_set dxs) (DList_set dys))\n         | Some x \\<Rightarrow> DList_set (DList_Set.product dxs dys))\n 4. Product_Type.product (RBT_set rbt1) B2 =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set: ccompare1 = None''\n        (\\<lambda>_. Product_Type.product (RBT_set rbt1) B2)\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>x. (\\<union>) (Pair x ` B2)) rbt1 {})\n 5. Product_Type.product A2 (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set: ccompare2 = None''\n        (\\<lambda>_. Product_Type.product A2 (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A2))\n          rbt2 {})\n 6. Product_Type.product (RBT_set rbt1) (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set RBT_set: ccompare1 = None''\n        (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''product RBT_set RBT_set: ccompare2 = None''\n            (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n         | Some x \\<Rightarrow> RBT_set (RBT_Set2.product rbt1 rbt2))", "{"], ["proof (state)\nthis:\n  Product_Type.product (DList_set dxs) B1 =\n  (case ID CEQ('a) of\n   None \\<Rightarrow>\n     Code.abort STR ''product DList_set1: ceq = None''\n      (\\<lambda>_. Product_Type.product (DList_set dxs) B1)\n   | Some x \\<Rightarrow>\n       DList_Set.fold (\\<lambda>x. (\\<union>) (Pair x ` B1)) dxs {})\n\ngoal (6 subgoals):\n 1. Product_Type.product A B =\n    Collect_set (\\<lambda>(x, y). x \\<in> A \\<and> y \\<in> B)\n 2. Product_Type.product A1 (DList_set dys) =\n    (case ID CEQ('b) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set2: ceq = None''\n        (\\<lambda>_. Product_Type.product A1 (DList_set dys))\n     | Some x \\<Rightarrow>\n         DList_Set.fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A1))\n          dys {})\n 3. Product_Type.product (DList_set dxs) (DList_set dys) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set DList_set: ceq1 = None''\n        (\\<lambda>_. Product_Type.product (DList_set dxs) (DList_set dys))\n     | Some x \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           Code.abort STR ''product DList_set DList_set: ceq2 = None''\n            (\\<lambda>_.\n                Product_Type.product (DList_set dxs) (DList_set dys))\n         | Some x \\<Rightarrow> DList_set (DList_Set.product dxs dys))\n 4. Product_Type.product (RBT_set rbt1) B2 =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set: ccompare1 = None''\n        (\\<lambda>_. Product_Type.product (RBT_set rbt1) B2)\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>x. (\\<union>) (Pair x ` B2)) rbt1 {})\n 5. Product_Type.product A2 (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set: ccompare2 = None''\n        (\\<lambda>_. Product_Type.product A2 (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A2))\n          rbt2 {})\n 6. Product_Type.product (RBT_set rbt1) (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set RBT_set: ccompare1 = None''\n        (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''product RBT_set RBT_set: ccompare2 = None''\n            (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n         | Some x \\<Rightarrow> RBT_set (RBT_Set2.product rbt1 rbt2))", "fix ys :: \"'b list\""], ["proof (state)\ngoal (6 subgoals):\n 1. Product_Type.product A B =\n    Collect_set (\\<lambda>(x, y). x \\<in> A \\<and> y \\<in> B)\n 2. Product_Type.product A1 (DList_set dys) =\n    (case ID CEQ('b) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set2: ceq = None''\n        (\\<lambda>_. Product_Type.product A1 (DList_set dys))\n     | Some x \\<Rightarrow>\n         DList_Set.fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A1))\n          dys {})\n 3. Product_Type.product (DList_set dxs) (DList_set dys) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set DList_set: ceq1 = None''\n        (\\<lambda>_. Product_Type.product (DList_set dxs) (DList_set dys))\n     | Some x \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           Code.abort STR ''product DList_set DList_set: ceq2 = None''\n            (\\<lambda>_.\n                Product_Type.product (DList_set dxs) (DList_set dys))\n         | Some x \\<Rightarrow> DList_set (DList_Set.product dxs dys))\n 4. Product_Type.product (RBT_set rbt1) B2 =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set: ccompare1 = None''\n        (\\<lambda>_. Product_Type.product (RBT_set rbt1) B2)\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>x. (\\<union>) (Pair x ` B2)) rbt1 {})\n 5. Product_Type.product A2 (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set: ccompare2 = None''\n        (\\<lambda>_. Product_Type.product A2 (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A2))\n          rbt2 {})\n 6. Product_Type.product (RBT_set rbt1) (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set RBT_set: ccompare1 = None''\n        (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''product RBT_set RBT_set: ccompare2 = None''\n            (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n         | Some x \\<Rightarrow> RBT_set (RBT_Set2.product rbt1 rbt2))", "have \"fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A1)) ys {} = A1 \\<times> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A1)) ys {} =\n    A1 \\<times> set ys", "by(induct ys rule: rev_induct) auto"], ["proof (state)\nthis:\n  fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A1)) ys {} =\n  A1 \\<times> set ys\n\ngoal (6 subgoals):\n 1. Product_Type.product A B =\n    Collect_set (\\<lambda>(x, y). x \\<in> A \\<and> y \\<in> B)\n 2. Product_Type.product A1 (DList_set dys) =\n    (case ID CEQ('b) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set2: ceq = None''\n        (\\<lambda>_. Product_Type.product A1 (DList_set dys))\n     | Some x \\<Rightarrow>\n         DList_Set.fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A1))\n          dys {})\n 3. Product_Type.product (DList_set dxs) (DList_set dys) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set DList_set: ceq1 = None''\n        (\\<lambda>_. Product_Type.product (DList_set dxs) (DList_set dys))\n     | Some x \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           Code.abort STR ''product DList_set DList_set: ceq2 = None''\n            (\\<lambda>_.\n                Product_Type.product (DList_set dxs) (DList_set dys))\n         | Some x \\<Rightarrow> DList_set (DList_Set.product dxs dys))\n 4. Product_Type.product (RBT_set rbt1) B2 =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set: ccompare1 = None''\n        (\\<lambda>_. Product_Type.product (RBT_set rbt1) B2)\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>x. (\\<union>) (Pair x ` B2)) rbt1 {})\n 5. Product_Type.product A2 (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set: ccompare2 = None''\n        (\\<lambda>_. Product_Type.product A2 (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A2))\n          rbt2 {})\n 6. Product_Type.product (RBT_set rbt1) (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set RBT_set: ccompare1 = None''\n        (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''product RBT_set RBT_set: ccompare2 = None''\n            (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n         | Some x \\<Rightarrow> RBT_set (RBT_Set2.product rbt1 rbt2))", "}"], ["proof (state)\nthis:\n  fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A1)) ?ysa3 {} =\n  A1 \\<times> set ?ysa3\n\ngoal (6 subgoals):\n 1. Product_Type.product A B =\n    Collect_set (\\<lambda>(x, y). x \\<in> A \\<and> y \\<in> B)\n 2. Product_Type.product A1 (DList_set dys) =\n    (case ID CEQ('b) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set2: ceq = None''\n        (\\<lambda>_. Product_Type.product A1 (DList_set dys))\n     | Some x \\<Rightarrow>\n         DList_Set.fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A1))\n          dys {})\n 3. Product_Type.product (DList_set dxs) (DList_set dys) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set DList_set: ceq1 = None''\n        (\\<lambda>_. Product_Type.product (DList_set dxs) (DList_set dys))\n     | Some x \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           Code.abort STR ''product DList_set DList_set: ceq2 = None''\n            (\\<lambda>_.\n                Product_Type.product (DList_set dxs) (DList_set dys))\n         | Some x \\<Rightarrow> DList_set (DList_Set.product dxs dys))\n 4. Product_Type.product (RBT_set rbt1) B2 =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set: ccompare1 = None''\n        (\\<lambda>_. Product_Type.product (RBT_set rbt1) B2)\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>x. (\\<union>) (Pair x ` B2)) rbt1 {})\n 5. Product_Type.product A2 (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set: ccompare2 = None''\n        (\\<lambda>_. Product_Type.product A2 (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A2))\n          rbt2 {})\n 6. Product_Type.product (RBT_set rbt1) (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set RBT_set: ccompare1 = None''\n        (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''product RBT_set RBT_set: ccompare2 = None''\n            (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n         | Some x \\<Rightarrow> RBT_set (RBT_Set2.product rbt1 rbt2))", "thus ?dlist2"], ["proof (prove)\nusing this:\n  fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A1)) ?ysa3 {} =\n  A1 \\<times> set ?ysa3\n\ngoal (1 subgoal):\n 1. Product_Type.product A1 (DList_set dys) =\n    (case ID CEQ('b) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set2: ceq = None''\n        (\\<lambda>_. Product_Type.product A1 (DList_set dys))\n     | Some x \\<Rightarrow>\n         DList_Set.fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A1))\n          dys {})", "by(simp add: Product_Type.product_def DList_set_def DList_Set.fold.rep_eq DList_Set.Collect_member split: option.split)"], ["proof (state)\nthis:\n  Product_Type.product A1 (DList_set dys) =\n  (case ID CEQ('b) of\n   None \\<Rightarrow>\n     Code.abort STR ''product DList_set2: ceq = None''\n      (\\<lambda>_. Product_Type.product A1 (DList_set dys))\n   | Some x \\<Rightarrow>\n       DList_Set.fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A1))\n        dys {})\n\ngoal (5 subgoals):\n 1. Product_Type.product A B =\n    Collect_set (\\<lambda>(x, y). x \\<in> A \\<and> y \\<in> B)\n 2. Product_Type.product (DList_set dxs) (DList_set dys) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set DList_set: ceq1 = None''\n        (\\<lambda>_. Product_Type.product (DList_set dxs) (DList_set dys))\n     | Some x \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           Code.abort STR ''product DList_set DList_set: ceq2 = None''\n            (\\<lambda>_.\n                Product_Type.product (DList_set dxs) (DList_set dys))\n         | Some x \\<Rightarrow> DList_set (DList_Set.product dxs dys))\n 3. Product_Type.product (RBT_set rbt1) B2 =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set: ccompare1 = None''\n        (\\<lambda>_. Product_Type.product (RBT_set rbt1) B2)\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>x. (\\<union>) (Pair x ` B2)) rbt1 {})\n 4. Product_Type.product A2 (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set: ccompare2 = None''\n        (\\<lambda>_. Product_Type.product A2 (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A2))\n          rbt2 {})\n 5. Product_Type.product (RBT_set rbt1) (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set RBT_set: ccompare1 = None''\n        (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''product RBT_set RBT_set: ccompare2 = None''\n            (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n         | Some x \\<Rightarrow> RBT_set (RBT_Set2.product rbt1 rbt2))", "{"], ["proof (state)\nthis:\n  Product_Type.product A1 (DList_set dys) =\n  (case ID CEQ('b) of\n   None \\<Rightarrow>\n     Code.abort STR ''product DList_set2: ceq = None''\n      (\\<lambda>_. Product_Type.product A1 (DList_set dys))\n   | Some x \\<Rightarrow>\n       DList_Set.fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A1))\n        dys {})\n\ngoal (5 subgoals):\n 1. Product_Type.product A B =\n    Collect_set (\\<lambda>(x, y). x \\<in> A \\<and> y \\<in> B)\n 2. Product_Type.product (DList_set dxs) (DList_set dys) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set DList_set: ceq1 = None''\n        (\\<lambda>_. Product_Type.product (DList_set dxs) (DList_set dys))\n     | Some x \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           Code.abort STR ''product DList_set DList_set: ceq2 = None''\n            (\\<lambda>_.\n                Product_Type.product (DList_set dxs) (DList_set dys))\n         | Some x \\<Rightarrow> DList_set (DList_Set.product dxs dys))\n 3. Product_Type.product (RBT_set rbt1) B2 =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set: ccompare1 = None''\n        (\\<lambda>_. Product_Type.product (RBT_set rbt1) B2)\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>x. (\\<union>) (Pair x ` B2)) rbt1 {})\n 4. Product_Type.product A2 (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set: ccompare2 = None''\n        (\\<lambda>_. Product_Type.product A2 (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A2))\n          rbt2 {})\n 5. Product_Type.product (RBT_set rbt1) (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set RBT_set: ccompare1 = None''\n        (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''product RBT_set RBT_set: ccompare2 = None''\n            (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n         | Some x \\<Rightarrow> RBT_set (RBT_Set2.product rbt1 rbt2))", "fix xs :: \"'c list\""], ["proof (state)\ngoal (5 subgoals):\n 1. Product_Type.product A B =\n    Collect_set (\\<lambda>(x, y). x \\<in> A \\<and> y \\<in> B)\n 2. Product_Type.product (DList_set dxs) (DList_set dys) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set DList_set: ceq1 = None''\n        (\\<lambda>_. Product_Type.product (DList_set dxs) (DList_set dys))\n     | Some x \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           Code.abort STR ''product DList_set DList_set: ceq2 = None''\n            (\\<lambda>_.\n                Product_Type.product (DList_set dxs) (DList_set dys))\n         | Some x \\<Rightarrow> DList_set (DList_Set.product dxs dys))\n 3. Product_Type.product (RBT_set rbt1) B2 =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set: ccompare1 = None''\n        (\\<lambda>_. Product_Type.product (RBT_set rbt1) B2)\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>x. (\\<union>) (Pair x ` B2)) rbt1 {})\n 4. Product_Type.product A2 (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set: ccompare2 = None''\n        (\\<lambda>_. Product_Type.product A2 (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A2))\n          rbt2 {})\n 5. Product_Type.product (RBT_set rbt1) (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set RBT_set: ccompare1 = None''\n        (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''product RBT_set RBT_set: ccompare2 = None''\n            (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n         | Some x \\<Rightarrow> RBT_set (RBT_Set2.product rbt1 rbt2))", "have \"fold (\\<lambda>x. (\\<union>) (Pair x ` B2)) xs {} = set xs \\<times> B2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>x. (\\<union>) (Pair x ` B2)) xs {} = set xs \\<times> B2", "by(induct xs rule: rev_induct) auto"], ["proof (state)\nthis:\n  fold (\\<lambda>x. (\\<union>) (Pair x ` B2)) xs {} = set xs \\<times> B2\n\ngoal (5 subgoals):\n 1. Product_Type.product A B =\n    Collect_set (\\<lambda>(x, y). x \\<in> A \\<and> y \\<in> B)\n 2. Product_Type.product (DList_set dxs) (DList_set dys) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set DList_set: ceq1 = None''\n        (\\<lambda>_. Product_Type.product (DList_set dxs) (DList_set dys))\n     | Some x \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           Code.abort STR ''product DList_set DList_set: ceq2 = None''\n            (\\<lambda>_.\n                Product_Type.product (DList_set dxs) (DList_set dys))\n         | Some x \\<Rightarrow> DList_set (DList_Set.product dxs dys))\n 3. Product_Type.product (RBT_set rbt1) B2 =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set: ccompare1 = None''\n        (\\<lambda>_. Product_Type.product (RBT_set rbt1) B2)\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>x. (\\<union>) (Pair x ` B2)) rbt1 {})\n 4. Product_Type.product A2 (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set: ccompare2 = None''\n        (\\<lambda>_. Product_Type.product A2 (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A2))\n          rbt2 {})\n 5. Product_Type.product (RBT_set rbt1) (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set RBT_set: ccompare1 = None''\n        (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''product RBT_set RBT_set: ccompare2 = None''\n            (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n         | Some x \\<Rightarrow> RBT_set (RBT_Set2.product rbt1 rbt2))", "}"], ["proof (state)\nthis:\n  fold (\\<lambda>x. (\\<union>) (Pair x ` B2)) ?xsa3 {} =\n  set ?xsa3 \\<times> B2\n\ngoal (5 subgoals):\n 1. Product_Type.product A B =\n    Collect_set (\\<lambda>(x, y). x \\<in> A \\<and> y \\<in> B)\n 2. Product_Type.product (DList_set dxs) (DList_set dys) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set DList_set: ceq1 = None''\n        (\\<lambda>_. Product_Type.product (DList_set dxs) (DList_set dys))\n     | Some x \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           Code.abort STR ''product DList_set DList_set: ceq2 = None''\n            (\\<lambda>_.\n                Product_Type.product (DList_set dxs) (DList_set dys))\n         | Some x \\<Rightarrow> DList_set (DList_Set.product dxs dys))\n 3. Product_Type.product (RBT_set rbt1) B2 =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set: ccompare1 = None''\n        (\\<lambda>_. Product_Type.product (RBT_set rbt1) B2)\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>x. (\\<union>) (Pair x ` B2)) rbt1 {})\n 4. Product_Type.product A2 (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set: ccompare2 = None''\n        (\\<lambda>_. Product_Type.product A2 (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A2))\n          rbt2 {})\n 5. Product_Type.product (RBT_set rbt1) (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set RBT_set: ccompare1 = None''\n        (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''product RBT_set RBT_set: ccompare2 = None''\n            (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n         | Some x \\<Rightarrow> RBT_set (RBT_Set2.product rbt1 rbt2))", "thus ?rbt1"], ["proof (prove)\nusing this:\n  fold (\\<lambda>x. (\\<union>) (Pair x ` B2)) ?xsa3 {} =\n  set ?xsa3 \\<times> B2\n\ngoal (1 subgoal):\n 1. Product_Type.product (RBT_set rbt1) B2 =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set: ccompare1 = None''\n        (\\<lambda>_. Product_Type.product (RBT_set rbt1) B2)\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>x. (\\<union>) (Pair x ` B2)) rbt1 {})", "by(simp add: Product_Type.product_def RBT_set_def RBT_Set2.member_product RBT_Set2.member_conv_keys fold_conv_fold_keys split: option.split)"], ["proof (state)\nthis:\n  Product_Type.product (RBT_set rbt1) B2 =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''product RBT_set: ccompare1 = None''\n      (\\<lambda>_. Product_Type.product (RBT_set rbt1) B2)\n   | Some x \\<Rightarrow>\n       RBT_Set2.fold (\\<lambda>x. (\\<union>) (Pair x ` B2)) rbt1 {})\n\ngoal (4 subgoals):\n 1. Product_Type.product A B =\n    Collect_set (\\<lambda>(x, y). x \\<in> A \\<and> y \\<in> B)\n 2. Product_Type.product (DList_set dxs) (DList_set dys) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set DList_set: ceq1 = None''\n        (\\<lambda>_. Product_Type.product (DList_set dxs) (DList_set dys))\n     | Some x \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           Code.abort STR ''product DList_set DList_set: ceq2 = None''\n            (\\<lambda>_.\n                Product_Type.product (DList_set dxs) (DList_set dys))\n         | Some x \\<Rightarrow> DList_set (DList_Set.product dxs dys))\n 3. Product_Type.product A2 (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set: ccompare2 = None''\n        (\\<lambda>_. Product_Type.product A2 (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A2))\n          rbt2 {})\n 4. Product_Type.product (RBT_set rbt1) (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set RBT_set: ccompare1 = None''\n        (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''product RBT_set RBT_set: ccompare2 = None''\n            (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n         | Some x \\<Rightarrow> RBT_set (RBT_Set2.product rbt1 rbt2))", "{"], ["proof (state)\nthis:\n  Product_Type.product (RBT_set rbt1) B2 =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''product RBT_set: ccompare1 = None''\n      (\\<lambda>_. Product_Type.product (RBT_set rbt1) B2)\n   | Some x \\<Rightarrow>\n       RBT_Set2.fold (\\<lambda>x. (\\<union>) (Pair x ` B2)) rbt1 {})\n\ngoal (4 subgoals):\n 1. Product_Type.product A B =\n    Collect_set (\\<lambda>(x, y). x \\<in> A \\<and> y \\<in> B)\n 2. Product_Type.product (DList_set dxs) (DList_set dys) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set DList_set: ceq1 = None''\n        (\\<lambda>_. Product_Type.product (DList_set dxs) (DList_set dys))\n     | Some x \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           Code.abort STR ''product DList_set DList_set: ceq2 = None''\n            (\\<lambda>_.\n                Product_Type.product (DList_set dxs) (DList_set dys))\n         | Some x \\<Rightarrow> DList_set (DList_Set.product dxs dys))\n 3. Product_Type.product A2 (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set: ccompare2 = None''\n        (\\<lambda>_. Product_Type.product A2 (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A2))\n          rbt2 {})\n 4. Product_Type.product (RBT_set rbt1) (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set RBT_set: ccompare1 = None''\n        (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''product RBT_set RBT_set: ccompare2 = None''\n            (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n         | Some x \\<Rightarrow> RBT_set (RBT_Set2.product rbt1 rbt2))", "fix ys :: \"'d list\""], ["proof (state)\ngoal (4 subgoals):\n 1. Product_Type.product A B =\n    Collect_set (\\<lambda>(x, y). x \\<in> A \\<and> y \\<in> B)\n 2. Product_Type.product (DList_set dxs) (DList_set dys) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set DList_set: ceq1 = None''\n        (\\<lambda>_. Product_Type.product (DList_set dxs) (DList_set dys))\n     | Some x \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           Code.abort STR ''product DList_set DList_set: ceq2 = None''\n            (\\<lambda>_.\n                Product_Type.product (DList_set dxs) (DList_set dys))\n         | Some x \\<Rightarrow> DList_set (DList_Set.product dxs dys))\n 3. Product_Type.product A2 (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set: ccompare2 = None''\n        (\\<lambda>_. Product_Type.product A2 (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A2))\n          rbt2 {})\n 4. Product_Type.product (RBT_set rbt1) (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set RBT_set: ccompare1 = None''\n        (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''product RBT_set RBT_set: ccompare2 = None''\n            (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n         | Some x \\<Rightarrow> RBT_set (RBT_Set2.product rbt1 rbt2))", "have \"fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A2)) ys {} = A2 \\<times> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A2)) ys {} =\n    A2 \\<times> set ys", "by(induct ys rule: rev_induct) auto"], ["proof (state)\nthis:\n  fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A2)) ys {} =\n  A2 \\<times> set ys\n\ngoal (4 subgoals):\n 1. Product_Type.product A B =\n    Collect_set (\\<lambda>(x, y). x \\<in> A \\<and> y \\<in> B)\n 2. Product_Type.product (DList_set dxs) (DList_set dys) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set DList_set: ceq1 = None''\n        (\\<lambda>_. Product_Type.product (DList_set dxs) (DList_set dys))\n     | Some x \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           Code.abort STR ''product DList_set DList_set: ceq2 = None''\n            (\\<lambda>_.\n                Product_Type.product (DList_set dxs) (DList_set dys))\n         | Some x \\<Rightarrow> DList_set (DList_Set.product dxs dys))\n 3. Product_Type.product A2 (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set: ccompare2 = None''\n        (\\<lambda>_. Product_Type.product A2 (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A2))\n          rbt2 {})\n 4. Product_Type.product (RBT_set rbt1) (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set RBT_set: ccompare1 = None''\n        (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''product RBT_set RBT_set: ccompare2 = None''\n            (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n         | Some x \\<Rightarrow> RBT_set (RBT_Set2.product rbt1 rbt2))", "}"], ["proof (state)\nthis:\n  fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A2)) ?ysa3 {} =\n  A2 \\<times> set ?ysa3\n\ngoal (4 subgoals):\n 1. Product_Type.product A B =\n    Collect_set (\\<lambda>(x, y). x \\<in> A \\<and> y \\<in> B)\n 2. Product_Type.product (DList_set dxs) (DList_set dys) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set DList_set: ceq1 = None''\n        (\\<lambda>_. Product_Type.product (DList_set dxs) (DList_set dys))\n     | Some x \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           Code.abort STR ''product DList_set DList_set: ceq2 = None''\n            (\\<lambda>_.\n                Product_Type.product (DList_set dxs) (DList_set dys))\n         | Some x \\<Rightarrow> DList_set (DList_Set.product dxs dys))\n 3. Product_Type.product A2 (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set: ccompare2 = None''\n        (\\<lambda>_. Product_Type.product A2 (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A2))\n          rbt2 {})\n 4. Product_Type.product (RBT_set rbt1) (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set RBT_set: ccompare1 = None''\n        (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''product RBT_set RBT_set: ccompare2 = None''\n            (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n         | Some x \\<Rightarrow> RBT_set (RBT_Set2.product rbt1 rbt2))", "thus ?rbt2"], ["proof (prove)\nusing this:\n  fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A2)) ?ysa3 {} =\n  A2 \\<times> set ?ysa3\n\ngoal (1 subgoal):\n 1. Product_Type.product A2 (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set: ccompare2 = None''\n        (\\<lambda>_. Product_Type.product A2 (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A2))\n          rbt2 {})", "by(simp add: Product_Type.product_def RBT_set_def RBT_Set2.member_product RBT_Set2.member_conv_keys fold_conv_fold_keys split: option.split)"], ["proof (state)\nthis:\n  Product_Type.product A2 (RBT_set rbt2) =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''product RBT_set: ccompare2 = None''\n      (\\<lambda>_. Product_Type.product A2 (RBT_set rbt2))\n   | Some x \\<Rightarrow>\n       RBT_Set2.fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A2))\n        rbt2 {})\n\ngoal (3 subgoals):\n 1. Product_Type.product A B =\n    Collect_set (\\<lambda>(x, y). x \\<in> A \\<and> y \\<in> B)\n 2. Product_Type.product (DList_set dxs) (DList_set dys) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''product DList_set DList_set: ceq1 = None''\n        (\\<lambda>_. Product_Type.product (DList_set dxs) (DList_set dys))\n     | Some x \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           Code.abort STR ''product DList_set DList_set: ceq2 = None''\n            (\\<lambda>_.\n                Product_Type.product (DList_set dxs) (DList_set dys))\n         | Some x \\<Rightarrow> DList_set (DList_Set.product dxs dys))\n 3. Product_Type.product (RBT_set rbt1) (RBT_set rbt2) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''product RBT_set RBT_set: ccompare1 = None''\n        (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''product RBT_set RBT_set: ccompare2 = None''\n            (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n         | Some x \\<Rightarrow> RBT_set (RBT_Set2.product rbt1 rbt2))", "qed(auto simp add: RBT_set_def DList_set_def Product_Type.product_def DList_Set.product_member RBT_Set2.member_product split: option.split)"], ["", "lemma Id_on_code [code]: \n  fixes A :: \"'a :: ceq set\"\n  and dxs :: \"'a set_dlist\" \n  and P :: \"'a \\<Rightarrow> bool\" \n  and rbt :: \"'b :: ccompare set_rbt\" shows\n  \"Id_on B = (\\<lambda>x. (x, x)) ` B\"\n  and Id_on_Complement [set_complement_code]:\n  \"Id_on (Complement A) =\n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''Id_on Complement: ceq = None'') (\\<lambda>_. Id_on (Complement A))\n                 | Some eq \\<Rightarrow> Collect_set (\\<lambda>(x, y). eq x y \\<and> x \\<notin> A))\"\n  and\n  \"Id_on (Collect_set P) =\n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''Id_on Collect_set: ceq = None'') (\\<lambda>_. Id_on (Collect_set P))\n                 | Some eq \\<Rightarrow> Collect_set (\\<lambda>(x, y). eq x y \\<and> P x))\"\n  \"Id_on (DList_set dxs) = \n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''Id_on DList_set: ceq = None'') (\\<lambda>_. Id_on (DList_set dxs))\n                  | Some _ \\<Rightarrow> DList_set (DList_Set.Id_on dxs))\"\n  \"Id_on (RBT_set rbt) =\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''Id_on RBT_set: ccompare = None'') (\\<lambda>_. Id_on (RBT_set rbt))\n                     | Some _ \\<Rightarrow> RBT_set (RBT_Set2.Id_on rbt))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Id_on B = (\\<lambda>x. (x, x)) ` B &&&\n    Id_on (Complement A) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''Id_on Complement: ceq = None''\n        (\\<lambda>_. Id_on (Complement A))\n     | Some eq \\<Rightarrow>\n         Collect_set (\\<lambda>(x, y). eq x y \\<and> x \\<notin> A)) &&&\n    Id_on (Collect_set P) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''Id_on Collect_set: ceq = None''\n        (\\<lambda>_. Id_on (Collect_set P))\n     | Some eq \\<Rightarrow>\n         Collect_set (\\<lambda>(x, y). eq x y \\<and> P x)) &&&\n    Id_on (DList_set dxs) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''Id_on DList_set: ceq = None''\n        (\\<lambda>_. Id_on (DList_set dxs))\n     | Some x \\<Rightarrow> DList_set (DList_Set.Id_on dxs)) &&&\n    Id_on (RBT_set rbt) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''Id_on RBT_set: ccompare = None''\n        (\\<lambda>_. Id_on (RBT_set rbt))\n     | Some x \\<Rightarrow> RBT_set (RBT_Set2.Id_on rbt))", "by(auto simp add: DList_set_def RBT_set_def DList_Set.member_Id_on RBT_Set2.member_Id_on dest: equal.equal_eq[OF ID_ceq] split: option.split)"], ["", "lemma Image_code [code]:\n  fixes dxs :: \"('a :: ceq \\<times> 'b :: ceq) set_dlist\" \n  and rbt :: \"('c :: ccompare \\<times> 'd :: ccompare) set_rbt\" shows\n  \"X `` Y = snd ` Set.filter (\\<lambda>(x, y). x \\<in> Y) X\"\n  (is ?generic)\n\n  \"Set_Monad rxs `` A = Set_Monad (fold (\\<lambda>(x, y) rest. if x \\<in> A then y # rest else rest) rxs [])\"\n  (is ?Set_Monad)\n  \"DList_set dxs `` B = \n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''Image DList_set: ceq1 = None'') (\\<lambda>_. DList_set dxs `` B)\n                  | Some _ \\<Rightarrow>\n     case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''Image DList_set: ceq2 = None'') (\\<lambda>_. DList_set dxs `` B)\n                    | Some _ \\<Rightarrow>\n        DList_Set.fold (\\<lambda>(x, y) acc. if x \\<in> B then insert y acc else acc) dxs {})\"\n  (is ?DList_set)\n  \"RBT_set rbt `` C =\n   (case ID CCOMPARE('c) of None \\<Rightarrow> Code.abort (STR ''Image RBT_set: ccompare1 = None'') (\\<lambda>_. RBT_set rbt `` C)\n                      | Some _ \\<Rightarrow>\n      case ID CCOMPARE('d) of None \\<Rightarrow> Code.abort (STR ''Image RBT_set: ccompare2 = None'') (\\<lambda>_. RBT_set rbt `` C)\n                        | Some _ \\<Rightarrow>\n        RBT_Set2.fold (\\<lambda>(x, y) acc. if x \\<in> C then insert y acc else acc) rbt {})\"\n  (is ?RBT_set)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (X `` Y = snd ` Set.filter (\\<lambda>(x, y). x \\<in> Y) X &&&\n     Set_Monad rxs `` A =\n     Set_Monad\n      (fold (\\<lambda>(x, y) rest. if x \\<in> A then y # rest else rest) rxs\n        [])) &&&\n    DList_set dxs `` B =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''Image DList_set: ceq1 = None''\n        (\\<lambda>_. DList_set dxs `` B)\n     | Some x \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           Code.abort STR ''Image DList_set: ceq2 = None''\n            (\\<lambda>_. DList_set dxs `` B)\n         | Some x \\<Rightarrow>\n             DList_Set.fold\n              (\\<lambda>(x, y) acc. if x \\<in> B then insert y acc else acc)\n              dxs {}) &&&\n    RBT_set rbt `` C =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''Image RBT_set: ccompare1 = None''\n        (\\<lambda>_. RBT_set rbt `` C)\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''Image RBT_set: ccompare2 = None''\n            (\\<lambda>_. RBT_set rbt `` C)\n         | Some x \\<Rightarrow>\n             RBT_Set2.fold\n              (\\<lambda>(x, y) acc. if x \\<in> C then insert y acc else acc)\n              rbt {})", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. X `` Y = snd ` Set.filter (\\<lambda>(x, y). x \\<in> Y) X\n 2. Set_Monad rxs `` A =\n    Set_Monad\n     (fold (\\<lambda>(x, y) rest. if x \\<in> A then y # rest else rest) rxs\n       [])\n 3. DList_set dxs `` B =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''Image DList_set: ceq1 = None''\n        (\\<lambda>_. DList_set dxs `` B)\n     | Some x \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           Code.abort STR ''Image DList_set: ceq2 = None''\n            (\\<lambda>_. DList_set dxs `` B)\n         | Some x \\<Rightarrow>\n             DList_Set.fold\n              (\\<lambda>(x, y) acc. if x \\<in> B then insert y acc else acc)\n              dxs {})\n 4. RBT_set rbt `` C =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''Image RBT_set: ccompare1 = None''\n        (\\<lambda>_. RBT_set rbt `` C)\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''Image RBT_set: ccompare2 = None''\n            (\\<lambda>_. RBT_set rbt `` C)\n         | Some x \\<Rightarrow>\n             RBT_Set2.fold\n              (\\<lambda>(x, y) acc. if x \\<in> C then insert y acc else acc)\n              rbt {})", "show ?generic"], ["proof (prove)\ngoal (1 subgoal):\n 1. X `` Y = snd ` Set.filter (\\<lambda>(x, y). x \\<in> Y) X", "by(auto intro: rev_image_eqI)"], ["proof (state)\nthis:\n  X `` Y = snd ` Set.filter (\\<lambda>(x, y). x \\<in> Y) X\n\ngoal (3 subgoals):\n 1. Set_Monad rxs `` A =\n    Set_Monad\n     (fold (\\<lambda>(x, y) rest. if x \\<in> A then y # rest else rest) rxs\n       [])\n 2. DList_set dxs `` B =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''Image DList_set: ceq1 = None''\n        (\\<lambda>_. DList_set dxs `` B)\n     | Some x \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           Code.abort STR ''Image DList_set: ceq2 = None''\n            (\\<lambda>_. DList_set dxs `` B)\n         | Some x \\<Rightarrow>\n             DList_Set.fold\n              (\\<lambda>(x, y) acc. if x \\<in> B then insert y acc else acc)\n              dxs {})\n 3. RBT_set rbt `` C =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''Image RBT_set: ccompare1 = None''\n        (\\<lambda>_. RBT_set rbt `` C)\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''Image RBT_set: ccompare2 = None''\n            (\\<lambda>_. RBT_set rbt `` C)\n         | Some x \\<Rightarrow>\n             RBT_Set2.fold\n              (\\<lambda>(x, y) acc. if x \\<in> C then insert y acc else acc)\n              rbt {})", "have \"set (fold (\\<lambda>(x, y) rest. if x \\<in> A then y # rest else rest) rxs []) = set rxs `` A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (fold (\\<lambda>(x, y) rest. if x \\<in> A then y # rest else rest)\n          rxs []) =\n    set rxs `` A", "by(induct rxs rule: rev_induct)(auto split: if_split_asm)"], ["proof (state)\nthis:\n  set (fold (\\<lambda>(x, y) rest. if x \\<in> A then y # rest else rest) rxs\n        []) =\n  set rxs `` A\n\ngoal (3 subgoals):\n 1. Set_Monad rxs `` A =\n    Set_Monad\n     (fold (\\<lambda>(x, y) rest. if x \\<in> A then y # rest else rest) rxs\n       [])\n 2. DList_set dxs `` B =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''Image DList_set: ceq1 = None''\n        (\\<lambda>_. DList_set dxs `` B)\n     | Some x \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           Code.abort STR ''Image DList_set: ceq2 = None''\n            (\\<lambda>_. DList_set dxs `` B)\n         | Some x \\<Rightarrow>\n             DList_Set.fold\n              (\\<lambda>(x, y) acc. if x \\<in> B then insert y acc else acc)\n              dxs {})\n 3. RBT_set rbt `` C =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''Image RBT_set: ccompare1 = None''\n        (\\<lambda>_. RBT_set rbt `` C)\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''Image RBT_set: ccompare2 = None''\n            (\\<lambda>_. RBT_set rbt `` C)\n         | Some x \\<Rightarrow>\n             RBT_Set2.fold\n              (\\<lambda>(x, y) acc. if x \\<in> C then insert y acc else acc)\n              rbt {})", "thus ?Set_Monad"], ["proof (prove)\nusing this:\n  set (fold (\\<lambda>(x, y) rest. if x \\<in> A then y # rest else rest) rxs\n        []) =\n  set rxs `` A\n\ngoal (1 subgoal):\n 1. Set_Monad rxs `` A =\n    Set_Monad\n     (fold (\\<lambda>(x, y) rest. if x \\<in> A then y # rest else rest) rxs\n       [])", "by(auto)"], ["proof (state)\nthis:\n  Set_Monad rxs `` A =\n  Set_Monad\n   (fold (\\<lambda>(x, y) rest. if x \\<in> A then y # rest else rest) rxs\n     [])\n\ngoal (2 subgoals):\n 1. DList_set dxs `` B =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''Image DList_set: ceq1 = None''\n        (\\<lambda>_. DList_set dxs `` B)\n     | Some x \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           Code.abort STR ''Image DList_set: ceq2 = None''\n            (\\<lambda>_. DList_set dxs `` B)\n         | Some x \\<Rightarrow>\n             DList_Set.fold\n              (\\<lambda>(x, y) acc. if x \\<in> B then insert y acc else acc)\n              dxs {})\n 2. RBT_set rbt `` C =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''Image RBT_set: ccompare1 = None''\n        (\\<lambda>_. RBT_set rbt `` C)\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''Image RBT_set: ccompare2 = None''\n            (\\<lambda>_. RBT_set rbt `` C)\n         | Some x \\<Rightarrow>\n             RBT_Set2.fold\n              (\\<lambda>(x, y) acc. if x \\<in> C then insert y acc else acc)\n              rbt {})", "{"], ["proof (state)\nthis:\n  Set_Monad rxs `` A =\n  Set_Monad\n   (fold (\\<lambda>(x, y) rest. if x \\<in> A then y # rest else rest) rxs\n     [])\n\ngoal (2 subgoals):\n 1. DList_set dxs `` B =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''Image DList_set: ceq1 = None''\n        (\\<lambda>_. DList_set dxs `` B)\n     | Some x \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           Code.abort STR ''Image DList_set: ceq2 = None''\n            (\\<lambda>_. DList_set dxs `` B)\n         | Some x \\<Rightarrow>\n             DList_Set.fold\n              (\\<lambda>(x, y) acc. if x \\<in> B then insert y acc else acc)\n              dxs {})\n 2. RBT_set rbt `` C =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''Image RBT_set: ccompare1 = None''\n        (\\<lambda>_. RBT_set rbt `` C)\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''Image RBT_set: ccompare2 = None''\n            (\\<lambda>_. RBT_set rbt `` C)\n         | Some x \\<Rightarrow>\n             RBT_Set2.fold\n              (\\<lambda>(x, y) acc. if x \\<in> C then insert y acc else acc)\n              rbt {})", "fix dxs :: \"('a \\<times> 'b) list\""], ["proof (state)\ngoal (2 subgoals):\n 1. DList_set dxs `` B =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''Image DList_set: ceq1 = None''\n        (\\<lambda>_. DList_set dxs `` B)\n     | Some x \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           Code.abort STR ''Image DList_set: ceq2 = None''\n            (\\<lambda>_. DList_set dxs `` B)\n         | Some x \\<Rightarrow>\n             DList_Set.fold\n              (\\<lambda>(x, y) acc. if x \\<in> B then insert y acc else acc)\n              dxs {})\n 2. RBT_set rbt `` C =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''Image RBT_set: ccompare1 = None''\n        (\\<lambda>_. RBT_set rbt `` C)\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''Image RBT_set: ccompare2 = None''\n            (\\<lambda>_. RBT_set rbt `` C)\n         | Some x \\<Rightarrow>\n             RBT_Set2.fold\n              (\\<lambda>(x, y) acc. if x \\<in> C then insert y acc else acc)\n              rbt {})", "have \"fold (\\<lambda>(x, y) acc. if x \\<in> B then insert y acc else acc) dxs {} = set dxs `` B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>(x, y) acc. if x \\<in> B then insert y acc else acc) dxs\n     {} =\n    set dxs `` B", "by(induct dxs rule: rev_induct)(auto split: if_split_asm)"], ["proof (state)\nthis:\n  fold (\\<lambda>(x, y) acc. if x \\<in> B then insert y acc else acc) dxs\n   {} =\n  set dxs `` B\n\ngoal (2 subgoals):\n 1. DList_set dxs `` B =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''Image DList_set: ceq1 = None''\n        (\\<lambda>_. DList_set dxs `` B)\n     | Some x \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           Code.abort STR ''Image DList_set: ceq2 = None''\n            (\\<lambda>_. DList_set dxs `` B)\n         | Some x \\<Rightarrow>\n             DList_Set.fold\n              (\\<lambda>(x, y) acc. if x \\<in> B then insert y acc else acc)\n              dxs {})\n 2. RBT_set rbt `` C =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''Image RBT_set: ccompare1 = None''\n        (\\<lambda>_. RBT_set rbt `` C)\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''Image RBT_set: ccompare2 = None''\n            (\\<lambda>_. RBT_set rbt `` C)\n         | Some x \\<Rightarrow>\n             RBT_Set2.fold\n              (\\<lambda>(x, y) acc. if x \\<in> C then insert y acc else acc)\n              rbt {})", "}"], ["proof (state)\nthis:\n  fold (\\<lambda>(x, y) acc. if x \\<in> B then insert y acc else acc) ?dxsa2\n   {} =\n  set ?dxsa2 `` B\n\ngoal (2 subgoals):\n 1. DList_set dxs `` B =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''Image DList_set: ceq1 = None''\n        (\\<lambda>_. DList_set dxs `` B)\n     | Some x \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           Code.abort STR ''Image DList_set: ceq2 = None''\n            (\\<lambda>_. DList_set dxs `` B)\n         | Some x \\<Rightarrow>\n             DList_Set.fold\n              (\\<lambda>(x, y) acc. if x \\<in> B then insert y acc else acc)\n              dxs {})\n 2. RBT_set rbt `` C =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''Image RBT_set: ccompare1 = None''\n        (\\<lambda>_. RBT_set rbt `` C)\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''Image RBT_set: ccompare2 = None''\n            (\\<lambda>_. RBT_set rbt `` C)\n         | Some x \\<Rightarrow>\n             RBT_Set2.fold\n              (\\<lambda>(x, y) acc. if x \\<in> C then insert y acc else acc)\n              rbt {})", "thus ?DList_set"], ["proof (prove)\nusing this:\n  fold (\\<lambda>(x, y) acc. if x \\<in> B then insert y acc else acc) ?dxsa2\n   {} =\n  set ?dxsa2 `` B\n\ngoal (1 subgoal):\n 1. DList_set dxs `` B =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''Image DList_set: ceq1 = None''\n        (\\<lambda>_. DList_set dxs `` B)\n     | Some x \\<Rightarrow>\n         case ID CEQ('b) of\n         None \\<Rightarrow>\n           Code.abort STR ''Image DList_set: ceq2 = None''\n            (\\<lambda>_. DList_set dxs `` B)\n         | Some x \\<Rightarrow>\n             DList_Set.fold\n              (\\<lambda>(x, y) acc. if x \\<in> B then insert y acc else acc)\n              dxs {})", "by(clarsimp simp add: DList_set_def Collect_member ceq_prod_def ID_Some DList_Set.fold.rep_eq split: option.split)"], ["proof (state)\nthis:\n  DList_set dxs `` B =\n  (case ID CEQ('a) of\n   None \\<Rightarrow>\n     Code.abort STR ''Image DList_set: ceq1 = None''\n      (\\<lambda>_. DList_set dxs `` B)\n   | Some x \\<Rightarrow>\n       case ID CEQ('b) of\n       None \\<Rightarrow>\n         Code.abort STR ''Image DList_set: ceq2 = None''\n          (\\<lambda>_. DList_set dxs `` B)\n       | Some x \\<Rightarrow>\n           DList_Set.fold\n            (\\<lambda>(x, y) acc. if x \\<in> B then insert y acc else acc)\n            dxs {})\n\ngoal (1 subgoal):\n 1. RBT_set rbt `` C =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''Image RBT_set: ccompare1 = None''\n        (\\<lambda>_. RBT_set rbt `` C)\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''Image RBT_set: ccompare2 = None''\n            (\\<lambda>_. RBT_set rbt `` C)\n         | Some x \\<Rightarrow>\n             RBT_Set2.fold\n              (\\<lambda>(x, y) acc. if x \\<in> C then insert y acc else acc)\n              rbt {})", "{"], ["proof (state)\nthis:\n  DList_set dxs `` B =\n  (case ID CEQ('a) of\n   None \\<Rightarrow>\n     Code.abort STR ''Image DList_set: ceq1 = None''\n      (\\<lambda>_. DList_set dxs `` B)\n   | Some x \\<Rightarrow>\n       case ID CEQ('b) of\n       None \\<Rightarrow>\n         Code.abort STR ''Image DList_set: ceq2 = None''\n          (\\<lambda>_. DList_set dxs `` B)\n       | Some x \\<Rightarrow>\n           DList_Set.fold\n            (\\<lambda>(x, y) acc. if x \\<in> B then insert y acc else acc)\n            dxs {})\n\ngoal (1 subgoal):\n 1. RBT_set rbt `` C =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''Image RBT_set: ccompare1 = None''\n        (\\<lambda>_. RBT_set rbt `` C)\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''Image RBT_set: ccompare2 = None''\n            (\\<lambda>_. RBT_set rbt `` C)\n         | Some x \\<Rightarrow>\n             RBT_Set2.fold\n              (\\<lambda>(x, y) acc. if x \\<in> C then insert y acc else acc)\n              rbt {})", "fix rbt :: \"(('c \\<times> 'd) \\<times> unit) list\""], ["proof (state)\ngoal (1 subgoal):\n 1. RBT_set rbt `` C =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''Image RBT_set: ccompare1 = None''\n        (\\<lambda>_. RBT_set rbt `` C)\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''Image RBT_set: ccompare2 = None''\n            (\\<lambda>_. RBT_set rbt `` C)\n         | Some x \\<Rightarrow>\n             RBT_Set2.fold\n              (\\<lambda>(x, y) acc. if x \\<in> C then insert y acc else acc)\n              rbt {})", "have \"fold (\\<lambda>(a, _). case a of (x, y) \\<Rightarrow> \\<lambda>acc. if x \\<in> C then insert y acc else acc) rbt {} = (fst ` set rbt) `` C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold\n     (\\<lambda>(a, uu_).\n         case a of\n         (x, y) \\<Rightarrow>\n           \\<lambda>acc. if x \\<in> C then insert y acc else acc)\n     rbt {} =\n    (fst ` set rbt) `` C", "by(induct rbt rule: rev_induct)(auto simp add: split_beta split: if_split_asm)"], ["proof (state)\nthis:\n  fold\n   (\\<lambda>(a, uu_).\n       case a of\n       (x, y) \\<Rightarrow>\n         \\<lambda>acc. if x \\<in> C then insert y acc else acc)\n   rbt {} =\n  (fst ` set rbt) `` C\n\ngoal (1 subgoal):\n 1. RBT_set rbt `` C =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''Image RBT_set: ccompare1 = None''\n        (\\<lambda>_. RBT_set rbt `` C)\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''Image RBT_set: ccompare2 = None''\n            (\\<lambda>_. RBT_set rbt `` C)\n         | Some x \\<Rightarrow>\n             RBT_Set2.fold\n              (\\<lambda>(x, y) acc. if x \\<in> C then insert y acc else acc)\n              rbt {})", "}"], ["proof (state)\nthis:\n  fold\n   (\\<lambda>(a, uu_).\n       case a of\n       (x, y) \\<Rightarrow>\n         \\<lambda>acc. if x \\<in> C then insert y acc else acc)\n   ?rbta2 {} =\n  (fst ` set ?rbta2) `` C\n\ngoal (1 subgoal):\n 1. RBT_set rbt `` C =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''Image RBT_set: ccompare1 = None''\n        (\\<lambda>_. RBT_set rbt `` C)\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''Image RBT_set: ccompare2 = None''\n            (\\<lambda>_. RBT_set rbt `` C)\n         | Some x \\<Rightarrow>\n             RBT_Set2.fold\n              (\\<lambda>(x, y) acc. if x \\<in> C then insert y acc else acc)\n              rbt {})", "thus ?RBT_set"], ["proof (prove)\nusing this:\n  fold\n   (\\<lambda>(a, uu_).\n       case a of\n       (x, y) \\<Rightarrow>\n         \\<lambda>acc. if x \\<in> C then insert y acc else acc)\n   ?rbta2 {} =\n  (fst ` set ?rbta2) `` C\n\ngoal (1 subgoal):\n 1. RBT_set rbt `` C =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''Image RBT_set: ccompare1 = None''\n        (\\<lambda>_. RBT_set rbt `` C)\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''Image RBT_set: ccompare2 = None''\n            (\\<lambda>_. RBT_set rbt `` C)\n         | Some x \\<Rightarrow>\n             RBT_Set2.fold\n              (\\<lambda>(x, y) acc. if x \\<in> C then insert y acc else acc)\n              rbt {})", "by(clarsimp simp add: RBT_set_def ccompare_prod_def ID_Some RBT_Set2.fold.rep_eq member_conv_keys RBT_Set2.keys.rep_eq RBT_Impl.fold_def RBT_Impl.keys_def split: option.split)"], ["proof (state)\nthis:\n  RBT_set rbt `` C =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''Image RBT_set: ccompare1 = None''\n      (\\<lambda>_. RBT_set rbt `` C)\n   | Some x \\<Rightarrow>\n       case ID ccompare of\n       None \\<Rightarrow>\n         Code.abort STR ''Image RBT_set: ccompare2 = None''\n          (\\<lambda>_. RBT_set rbt `` C)\n       | Some x \\<Rightarrow>\n           RBT_Set2.fold\n            (\\<lambda>(x, y) acc. if x \\<in> C then insert y acc else acc)\n            rbt {})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insert_relcomp: \"insert (a, b) A O B = A O B \\<union> {a} \\<times> {c. (b, c) \\<in> B}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (a, b) A O B = A O B \\<union> {a} \\<times> {c. (b, c) \\<in> B}", "by auto"], ["", "lemma trancl_code [code]:\n  \"trancl A = \n  (if finite A then ntrancl (card A - 1) A else Code.abort (STR ''trancl: infinite set'') (\\<lambda>_. trancl A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A\\<^sup>+ =\n    (if finite A then ntrancl (card A - 1) A\n     else Code.abort STR ''trancl: infinite set'' (\\<lambda>_. A\\<^sup>+))", "by (simp add: finite_trancl_ntranl)"], ["", "lemma set_relcomp_set:\n  \"set xs O set ys = fold (\\<lambda>(x, y). fold (\\<lambda>(y', z) A. if y = y' then insert (x, z) A else A) ys) xs {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs O set ys =\n    fold\n     (\\<lambda>(x, y).\n         fold (\\<lambda>(y', z) A. if y = y' then insert (x, z) A else A)\n          ys)\n     xs {}", "proof(induct xs rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. set [] O set ys =\n    fold\n     (\\<lambda>a.\n         case a of\n         (x, y) \\<Rightarrow>\n           fold\n            (\\<lambda>a.\n                case a of\n                (y', z) \\<Rightarrow>\n                  \\<lambda>A. if y = y' then insert (x, z) A else A)\n            ys)\n     [] {}\n 2. \\<And>x xs.\n       set xs O set ys =\n       fold\n        (\\<lambda>a.\n            case a of\n            (x, y) \\<Rightarrow>\n              fold\n               (\\<lambda>a.\n                   case a of\n                   (y', z) \\<Rightarrow>\n                     \\<lambda>A. if y = y' then insert (x, z) A else A)\n               ys)\n        xs {} \\<Longrightarrow>\n       set (xs @ [x]) O set ys =\n       fold\n        (\\<lambda>a.\n            case a of\n            (x, y) \\<Rightarrow>\n              fold\n               (\\<lambda>a.\n                   case a of\n                   (y', z) \\<Rightarrow>\n                     \\<lambda>A. if y = y' then insert (x, z) A else A)\n               ys)\n        (xs @ [x]) {}", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. set [] O set ys =\n    fold\n     (\\<lambda>a.\n         case a of\n         (x, y) \\<Rightarrow>\n           fold\n            (\\<lambda>a.\n                case a of\n                (y', z) \\<Rightarrow>\n                  \\<lambda>A. if y = y' then insert (x, z) A else A)\n            ys)\n     [] {}\n 2. \\<And>x xs.\n       set xs O set ys =\n       fold\n        (\\<lambda>a.\n            case a of\n            (x, y) \\<Rightarrow>\n              fold\n               (\\<lambda>a.\n                   case a of\n                   (y', z) \\<Rightarrow>\n                     \\<lambda>A. if y = y' then insert (x, z) A else A)\n               ys)\n        xs {} \\<Longrightarrow>\n       set (xs @ [x]) O set ys =\n       fold\n        (\\<lambda>a.\n            case a of\n            (x, y) \\<Rightarrow>\n              fold\n               (\\<lambda>a.\n                   case a of\n                   (y', z) \\<Rightarrow>\n                     \\<lambda>A. if y = y' then insert (x, z) A else A)\n               ys)\n        (xs @ [x]) {}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set [] O set ys =\n    fold\n     (\\<lambda>a.\n         case a of\n         (x, y) \\<Rightarrow>\n           fold\n            (\\<lambda>a.\n                case a of\n                (y', z) \\<Rightarrow>\n                  \\<lambda>A. if y = y' then insert (x, z) A else A)\n            ys)\n     [] {}", "by simp"], ["proof (state)\nthis:\n  set [] O set ys =\n  fold\n   (\\<lambda>a.\n       case a of\n       (x, y) \\<Rightarrow>\n         fold\n          (\\<lambda>a.\n              case a of\n              (y', z) \\<Rightarrow>\n                \\<lambda>A. if y = y' then insert (x, z) A else A)\n          ys)\n   [] {}\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       set xs O set ys =\n       fold\n        (\\<lambda>a.\n            case a of\n            (x, y) \\<Rightarrow>\n              fold\n               (\\<lambda>a.\n                   case a of\n                   (y', z) \\<Rightarrow>\n                     \\<lambda>A. if y = y' then insert (x, z) A else A)\n               ys)\n        xs {} \\<Longrightarrow>\n       set (xs @ [x]) O set ys =\n       fold\n        (\\<lambda>a.\n            case a of\n            (x, y) \\<Rightarrow>\n              fold\n               (\\<lambda>a.\n                   case a of\n                   (y', z) \\<Rightarrow>\n                     \\<lambda>A. if y = y' then insert (x, z) A else A)\n               ys)\n        (xs @ [x]) {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       set xs O set ys =\n       fold\n        (\\<lambda>a.\n            case a of\n            (x, y) \\<Rightarrow>\n              fold\n               (\\<lambda>a.\n                   case a of\n                   (y', z) \\<Rightarrow>\n                     \\<lambda>A. if y = y' then insert (x, z) A else A)\n               ys)\n        xs {} \\<Longrightarrow>\n       set (xs @ [x]) O set ys =\n       fold\n        (\\<lambda>a.\n            case a of\n            (x, y) \\<Rightarrow>\n              fold\n               (\\<lambda>a.\n                   case a of\n                   (y', z) \\<Rightarrow>\n                     \\<lambda>A. if y = y' then insert (x, z) A else A)\n               ys)\n        (xs @ [x]) {}", "case (snoc x xs)"], ["proof (state)\nthis:\n  set xs O set ys =\n  fold\n   (\\<lambda>a.\n       case a of\n       (x, y) \\<Rightarrow>\n         fold\n          (\\<lambda>a.\n              case a of\n              (y', z) \\<Rightarrow>\n                \\<lambda>A. if y = y' then insert (x, z) A else A)\n          ys)\n   xs {}\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       set xs O set ys =\n       fold\n        (\\<lambda>a.\n            case a of\n            (x, y) \\<Rightarrow>\n              fold\n               (\\<lambda>a.\n                   case a of\n                   (y', z) \\<Rightarrow>\n                     \\<lambda>A. if y = y' then insert (x, z) A else A)\n               ys)\n        xs {} \\<Longrightarrow>\n       set (xs @ [x]) O set ys =\n       fold\n        (\\<lambda>a.\n            case a of\n            (x, y) \\<Rightarrow>\n              fold\n               (\\<lambda>a.\n                   case a of\n                   (y', z) \\<Rightarrow>\n                     \\<lambda>A. if y = y' then insert (x, z) A else A)\n               ys)\n        (xs @ [x]) {}", "note [[show_types]]"], ["proof (state)\nthis:\n  TERM _\n\ngoal (1 subgoal):\n 1. \\<And>(x::'a \\<times> 'c) xs::('a \\<times> 'c) list.\n       set xs O set ys =\n       fold\n        (\\<lambda>a::'a \\<times> 'c.\n            case a of\n            (x::'a, y::'c) \\<Rightarrow>\n              fold\n               (\\<lambda>a::'c \\<times> 'b.\n                   case a of\n                   (y'::'c, z::'b) \\<Rightarrow>\n                     \\<lambda>A::('a \\<times> 'b) set.\n                        if y = y' then insert (x, z) A else A)\n               ys)\n        xs {} \\<Longrightarrow>\n       set (xs @ [x]) O set ys =\n       fold\n        (\\<lambda>a::'a \\<times> 'c.\n            case a of\n            (x::'a, y::'c) \\<Rightarrow>\n              fold\n               (\\<lambda>a::'c \\<times> 'b.\n                   case a of\n                   (y'::'c, z::'b) \\<Rightarrow>\n                     \\<lambda>A::('a \\<times> 'b) set.\n                        if y = y' then insert (x, z) A else A)\n               ys)\n        (xs @ [x]) {}\nvariables:\n  xs :: ('a \\<times> 'c) list\n  ys :: ('c \\<times> 'b) list", "{"], ["proof (state)\nthis:\n  TERM _\n\ngoal (1 subgoal):\n 1. \\<And>(x::'a \\<times> 'c) xs::('a \\<times> 'c) list.\n       set xs O set ys =\n       fold\n        (\\<lambda>a::'a \\<times> 'c.\n            case a of\n            (x::'a, y::'c) \\<Rightarrow>\n              fold\n               (\\<lambda>a::'c \\<times> 'b.\n                   case a of\n                   (y'::'c, z::'b) \\<Rightarrow>\n                     \\<lambda>A::('a \\<times> 'b) set.\n                        if y = y' then insert (x, z) A else A)\n               ys)\n        xs {} \\<Longrightarrow>\n       set (xs @ [x]) O set ys =\n       fold\n        (\\<lambda>a::'a \\<times> 'c.\n            case a of\n            (x::'a, y::'c) \\<Rightarrow>\n              fold\n               (\\<lambda>a::'c \\<times> 'b.\n                   case a of\n                   (y'::'c, z::'b) \\<Rightarrow>\n                     \\<lambda>A::('a \\<times> 'b) set.\n                        if y = y' then insert (x, z) A else A)\n               ys)\n        (xs @ [x]) {}\nvariables:\n  xs :: ('a \\<times> 'c) list\n  ys :: ('c \\<times> 'b) list", "fix a :: 'a and b :: 'c and X :: \"('a \\<times> 'b) set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>(x::'a \\<times> 'c) xs::('a \\<times> 'c) list.\n       set xs O set ys =\n       fold\n        (\\<lambda>a::'a \\<times> 'c.\n            case a of\n            (x::'a, y::'c) \\<Rightarrow>\n              fold\n               (\\<lambda>a::'c \\<times> 'b.\n                   case a of\n                   (y'::'c, z::'b) \\<Rightarrow>\n                     \\<lambda>A::('a \\<times> 'b) set.\n                        if y = y' then insert (x, z) A else A)\n               ys)\n        xs {} \\<Longrightarrow>\n       set (xs @ [x]) O set ys =\n       fold\n        (\\<lambda>a::'a \\<times> 'c.\n            case a of\n            (x::'a, y::'c) \\<Rightarrow>\n              fold\n               (\\<lambda>a::'c \\<times> 'b.\n                   case a of\n                   (y'::'c, z::'b) \\<Rightarrow>\n                     \\<lambda>A::('a \\<times> 'b) set.\n                        if y = y' then insert (x, z) A else A)\n               ys)\n        (xs @ [x]) {}\nvariables:\n  xs :: ('a \\<times> 'c) list\n  ys :: ('c \\<times> 'b) list", "have \"fold (\\<lambda>(y', z) A. if b = y' then insert (a, z) A else A) ys X = X \\<union> {a} \\<times> {c. (b, c) \\<in> set ys}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold\n     (\\<lambda>(y'::'c, z::'b) A::('a \\<times> 'b) set.\n         if b = y' then insert (a, z) A else A)\n     ys X =\n    X \\<union> {a} \\<times> {c::'b. (b, c) \\<in> set ys}\nvariables:\n  X :: ('a \\<times> 'b) set\n  ys :: ('c \\<times> 'b) list\n  a :: 'a\n  b :: 'c", "by(induct ys arbitrary: X rule: rev_induct)(auto split: if_split_asm)"], ["proof (state)\nthis:\n  fold\n   (\\<lambda>(y'::'c, z::'b) A::('a \\<times> 'b) set.\n       if (b::'c) = y' then insert (a::'a, z) A else A)\n   (ys::('c \\<times> 'b) list) (X::('a \\<times> 'b) set) =\n  X \\<union> {a} \\<times> {c::'b. (b, c) \\<in> set ys}\n\ngoal (1 subgoal):\n 1. \\<And>(x::'a \\<times> 'c) xs::('a \\<times> 'c) list.\n       set xs O set ys =\n       fold\n        (\\<lambda>a::'a \\<times> 'c.\n            case a of\n            (x::'a, y::'c) \\<Rightarrow>\n              fold\n               (\\<lambda>a::'c \\<times> 'b.\n                   case a of\n                   (y'::'c, z::'b) \\<Rightarrow>\n                     \\<lambda>A::('a \\<times> 'b) set.\n                        if y = y' then insert (x, z) A else A)\n               ys)\n        xs {} \\<Longrightarrow>\n       set (xs @ [x]) O set ys =\n       fold\n        (\\<lambda>a::'a \\<times> 'c.\n            case a of\n            (x::'a, y::'c) \\<Rightarrow>\n              fold\n               (\\<lambda>a::'c \\<times> 'b.\n                   case a of\n                   (y'::'c, z::'b) \\<Rightarrow>\n                     \\<lambda>A::('a \\<times> 'b) set.\n                        if y = y' then insert (x, z) A else A)\n               ys)\n        (xs @ [x]) {}\nvariables:\n  xs :: ('a \\<times> 'c) list\n  ys :: ('c \\<times> 'b) list", "}"], ["proof (state)\nthis:\n  fold\n   (\\<lambda>(y'::'c, z::'b) A::('a \\<times> 'b) set.\n       if (?b2::'c) = y' then insert (?a2::'a, z) A else A)\n   (ys::('c \\<times> 'b) list) (?X2::('a \\<times> 'b) set) =\n  ?X2 \\<union> {?a2} \\<times> {c::'b. (?b2, c) \\<in> set ys}\n\ngoal (1 subgoal):\n 1. \\<And>(x::'a \\<times> 'c) xs::('a \\<times> 'c) list.\n       set xs O set ys =\n       fold\n        (\\<lambda>a::'a \\<times> 'c.\n            case a of\n            (x::'a, y::'c) \\<Rightarrow>\n              fold\n               (\\<lambda>a::'c \\<times> 'b.\n                   case a of\n                   (y'::'c, z::'b) \\<Rightarrow>\n                     \\<lambda>A::('a \\<times> 'b) set.\n                        if y = y' then insert (x, z) A else A)\n               ys)\n        xs {} \\<Longrightarrow>\n       set (xs @ [x]) O set ys =\n       fold\n        (\\<lambda>a::'a \\<times> 'c.\n            case a of\n            (x::'a, y::'c) \\<Rightarrow>\n              fold\n               (\\<lambda>a::'c \\<times> 'b.\n                   case a of\n                   (y'::'c, z::'b) \\<Rightarrow>\n                     \\<lambda>A::('a \\<times> 'b) set.\n                        if y = y' then insert (x, z) A else A)\n               ys)\n        (xs @ [x]) {}\nvariables:\n  xs :: ('a \\<times> 'c) list\n  ys :: ('c \\<times> 'b) list", "thus ?case"], ["proof (prove)\nusing this:\n  fold\n   (\\<lambda>(y'::'c, z::'b) A::('a \\<times> 'b) set.\n       if (?b2::'c) = y' then insert (?a2::'a, z) A else A)\n   (ys::('c \\<times> 'b) list) (?X2::('a \\<times> 'b) set) =\n  ?X2 \\<union> {?a2} \\<times> {c::'b. (?b2, c) \\<in> set ys}\n\ngoal (1 subgoal):\n 1. set (xs @ [x]) O set ys =\n    fold\n     (\\<lambda>a::'a \\<times> 'c.\n         case a of\n         (x::'a, y::'c) \\<Rightarrow>\n           fold\n            (\\<lambda>a::'c \\<times> 'b.\n                case a of\n                (y'::'c, z::'b) \\<Rightarrow>\n                  \\<lambda>A::('a \\<times> 'b) set.\n                     if y = y' then insert (x, z) A else A)\n            ys)\n     (xs @ [x]) {}\nvariables:\n  ys :: ('c \\<times> 'b) list\n  x :: 'a \\<times> 'c\n  xs :: ('a \\<times> 'c) list", "using snoc"], ["proof (prove)\nusing this:\n  fold\n   (\\<lambda>(y'::'c, z::'b) A::('a \\<times> 'b) set.\n       if (?b2::'c) = y' then insert (?a2::'a, z) A else A)\n   (ys::('c \\<times> 'b) list) (?X2::('a \\<times> 'b) set) =\n  ?X2 \\<union> {?a2} \\<times> {c::'b. (?b2, c) \\<in> set ys}\n  set (xs::('a \\<times> 'c) list) O set (ys::('c \\<times> 'b) list) =\n  fold\n   (\\<lambda>a::'a \\<times> 'c.\n       case a of\n       (x::'a, y::'c) \\<Rightarrow>\n         fold\n          (\\<lambda>a::'c \\<times> 'b.\n              case a of\n              (y'::'c, z::'b) \\<Rightarrow>\n                \\<lambda>A::('a \\<times> 'b) set.\n                   if y = y' then insert (x, z) A else A)\n          ys)\n   xs {}\n\ngoal (1 subgoal):\n 1. set (xs @ [x]) O set ys =\n    fold\n     (\\<lambda>a::'a \\<times> 'c.\n         case a of\n         (x::'a, y::'c) \\<Rightarrow>\n           fold\n            (\\<lambda>a::'c \\<times> 'b.\n                case a of\n                (y'::'c, z::'b) \\<Rightarrow>\n                  \\<lambda>A::('a \\<times> 'b) set.\n                     if y = y' then insert (x, z) A else A)\n            ys)\n     (xs @ [x]) {}\nvariables:\n  ys :: ('c \\<times> 'b) list\n  x :: 'a \\<times> 'c\n  xs :: ('a \\<times> 'c) list", "by(cases x)(simp add: insert_relcomp)"], ["proof (state)\nthis:\n  set ((xs::('a \\<times> 'c) list) @ [x::'a \\<times> 'c]) O\n  set (ys::('c \\<times> 'b) list) =\n  fold\n   (\\<lambda>a::'a \\<times> 'c.\n       case a of\n       (x::'a, y::'c) \\<Rightarrow>\n         fold\n          (\\<lambda>a::'c \\<times> 'b.\n              case a of\n              (y'::'c, z::'b) \\<Rightarrow>\n                \\<lambda>A::('a \\<times> 'b) set.\n                   if y = y' then insert (x, z) A else A)\n          ys)\n   (xs @ [x]) {}\n\ngoal:\nNo subgoals!\nvariables:\n  ys :: ('c \\<times> 'b) list\n  xs :: ('a \\<times> 'c) list", "qed"], ["", "lemma If_not: \"(if \\<not> a then b else c) = (if a then c else b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<not> a then b else c) = (if a then c else b)", "by auto"], ["", "lemma relcomp_code [code]:\n  fixes rbt1 :: \"('a :: ccompare \\<times> 'b :: ccompare) set_rbt\"\n  and rbt2 :: \"('b \\<times> 'c :: ccompare) set_rbt\"\n  and rbt3 :: \"('a \\<times> 'd :: {ccompare, ceq}) set_rbt\" \n  and rbt4 :: \"('d \\<times> 'a) set_rbt\"\n  and rbt5 :: \"('b \\<times> 'a) set_rbt\"\n  and dxs1 :: \"('d \\<times> 'e :: ceq) set_dlist\" \n  and dxs2 :: \"('e \\<times> 'd) set_dlist\"\n  and dxs3 :: \"('e \\<times> 'f :: ceq) set_dlist\"\n  and dxs4 :: \"('f \\<times> 'g :: ceq) set_dlist\"\n  and xs1 :: \"('h \\<times> 'i :: ceq) list\"\n  and xs2 :: \"('i \\<times> 'j) list\"\n  and xs3 :: \"('b \\<times> 'h) list\"\n  and xs4 :: \"('h \\<times> 'b) list\"\n  and xs5 :: \"('f \\<times> 'h) list\"\n  and xs6 :: \"('h \\<times> 'f) list\"\n  shows\n  \"RBT_set rbt1 O RBT_set rbt2 = \n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''relcomp RBT_set RBT_set: ccompare1 = None'') (\\<lambda>_. RBT_set rbt1 O RBT_set rbt2)\n                     | Some _ \\<Rightarrow>\n     case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''relcomp RBT_set RBT_set: ccompare2 = None'') (\\<lambda>_. RBT_set rbt1 O RBT_set rbt2)\n           | Some c_b \\<Rightarrow>\n       case ID CCOMPARE('c) of None \\<Rightarrow> Code.abort (STR ''relcomp RBT_set RBT_set: ccompare3 = None'') (\\<lambda>_. RBT_set rbt1 O RBT_set rbt2)\n                         | Some _ \\<Rightarrow> RBT_Set2.fold (\\<lambda>(x, y). RBT_Set2.fold (\\<lambda>(y', z) A. if c_b y y' \\<noteq> Eq then A else insert (x, z) A) rbt2) rbt1 {})\"\n  (is ?rbt_rbt)\n\n  \"RBT_set rbt3 O DList_set dxs1 = \n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''relcomp RBT_set DList_set: ccompare1 = None'') (\\<lambda>_. RBT_set rbt3 O DList_set dxs1)\n                     | Some _ \\<Rightarrow>\n     case ID CCOMPARE('d) of None \\<Rightarrow> Code.abort (STR ''relcomp RBT_set DList_set: ccompare2 = None'') (\\<lambda>_. RBT_set rbt3 O DList_set dxs1)\n                       | Some _ \\<Rightarrow>\n       case ID CEQ('d) of None \\<Rightarrow> Code.abort (STR ''relcomp RBT_set DList_set: ceq2 = None'') (\\<lambda>_. RBT_set rbt3 O DList_set dxs1)\n                     | Some eq \\<Rightarrow>\n         case ID CEQ('e) of None \\<Rightarrow> Code.abort (STR ''relcomp RBT_set DList_set: ceq3 = None'') (\\<lambda>_. RBT_set rbt3 O DList_set dxs1)\n                        | Some _ \\<Rightarrow> RBT_Set2.fold (\\<lambda>(x, y). DList_Set.fold (\\<lambda>(y', z) A. if eq y y' then insert (x, z) A else A) dxs1) rbt3 {})\"\n  (is ?rbt_dlist)\n\n  \"DList_set dxs2 O RBT_set rbt4 = \n  (case ID CEQ('e) of None \\<Rightarrow> Code.abort (STR ''relcomp DList_set RBT_set: ceq1 = None'') (\\<lambda>_. DList_set dxs2 O RBT_set rbt4)\n                  | Some _ \\<Rightarrow>\n     case ID CCOMPARE('d) of None \\<Rightarrow> Code.abort (STR ''relcomp DList_set RBT_set: ceq2 = None'') (\\<lambda>_. DList_set dxs2 O RBT_set rbt4)\n                       | Some _ \\<Rightarrow>\n       case ID CEQ('d) of None \\<Rightarrow> Code.abort (STR ''relcomp DList_set RBT_set: ccompare2 = None'') (\\<lambda>_. DList_set dxs2 O RBT_set rbt4)\n                     | Some eq \\<Rightarrow>\n         case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''relcomp DList_set RBT_set: ccompare3 = None'') (\\<lambda>_. DList_set dxs2 O RBT_set rbt4)\n                           | Some _ \\<Rightarrow> DList_Set.fold (\\<lambda>(x, y). RBT_Set2.fold (\\<lambda>(y', z) A. if eq y y' then insert (x, z) A else A) rbt4) dxs2 {})\"\n  (is ?dlist_rbt)\n\n  \"DList_set dxs3 O DList_set dxs4 =\n  (case ID CEQ('e) of None \\<Rightarrow> Code.abort (STR ''relcomp DList_set DList_set: ceq1 = None'') (\\<lambda>_. DList_set dxs3 O DList_set dxs4)\n                  | Some _ \\<Rightarrow>\n     case ID CEQ('f) of None \\<Rightarrow> Code.abort (STR ''relcomp DList_set DList_set: ceq2 = None'') (\\<lambda>_. DList_set dxs3 O DList_set dxs4)\n                   | Some eq \\<Rightarrow>\n       case ID CEQ('g) of None \\<Rightarrow> Code.abort (STR ''relcomp DList_set DList_set: ceq3 = None'') (\\<lambda>_. DList_set dxs3 O DList_set dxs4)\n                      | Some _ \\<Rightarrow> DList_Set.fold (\\<lambda>(x, y). DList_Set.fold (\\<lambda>(y', z) A. if eq y y' then insert (x, z) A else A) dxs4) dxs3 {})\"\n  (is ?dlist_dlist)\n\n  \"Set_Monad xs1 O Set_Monad xs2 =\n  (case ID CEQ('i) of None \\<Rightarrow> Code.abort (STR ''relcomp Set_Monad Set_Monad: ceq = None'') (\\<lambda>_. Set_Monad xs1 O Set_Monad xs2)\n                 | Some eq \\<Rightarrow> fold (\\<lambda>(x, y). fold (\\<lambda>(y', z) A. if eq y y' then insert (x, z) A else A) xs2) xs1 {})\"\n  (is ?monad_monad)\n\n  \"RBT_set rbt1 O Set_Monad xs3 =\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''relcomp RBT_set Set_Monad: ccompare1 = None'') (\\<lambda>_. RBT_set rbt1 O Set_Monad xs3)\n                     | Some _ \\<Rightarrow>\n     case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''relcomp RBT_set Set_Monad: ccompare2 = None'') (\\<lambda>_. RBT_set rbt1 O Set_Monad xs3)\n           | Some c_b \\<Rightarrow> RBT_Set2.fold (\\<lambda>(x, y). fold (\\<lambda>(y', z) A. if c_b y y' \\<noteq> Eq then A else insert (x, z) A) xs3) rbt1 {})\"\n  (is ?rbt_monad)\n\n  \"Set_Monad xs4 O RBT_set rbt5 =\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''relcomp Set_Monad RBT_set: ccompare1 = None'') (\\<lambda>_. Set_Monad xs4 O RBT_set rbt5)\n                     | Some _ \\<Rightarrow>\n     case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''relcomp Set_Monad RBT_set: ccompare2 = None'') (\\<lambda>_. Set_Monad xs4 O RBT_set rbt5)\n           | Some c_b \\<Rightarrow> fold (\\<lambda>(x, y). RBT_Set2.fold (\\<lambda>(y', z) A. if c_b y y' \\<noteq> Eq then A else insert (x, z) A) rbt5) xs4 {})\"\n  (is ?monad_rbt)\n\n  \"DList_set dxs3 O Set_Monad xs5 =\n  (case ID CEQ('e) of None \\<Rightarrow> Code.abort (STR ''relcomp DList_set Set_Monad: ceq1 = None'') (\\<lambda>_. DList_set dxs3 O Set_Monad xs5)\n                  | Some _ \\<Rightarrow>\n     case ID CEQ('f) of None \\<Rightarrow> Code.abort (STR ''relcomp DList_set Set_Monad: ceq2 = None'') (\\<lambda>_. DList_set dxs3 O Set_Monad xs5)\n                   | Some eq \\<Rightarrow> DList_Set.fold (\\<lambda>(x, y). fold (\\<lambda>(y', z) A. if eq y y' then insert (x, z) A else A) xs5) dxs3 {})\"\n  (is ?dlist_monad)\n\n  \"Set_Monad xs6 O DList_set dxs4 =\n  (case ID CEQ('f) of None \\<Rightarrow> Code.abort (STR ''relcomp Set_Monad DList_set: ceq1 = None'') (\\<lambda>_. Set_Monad xs6 O DList_set dxs4)\n                      | Some eq \\<Rightarrow>\n     case ID CEQ('g) of None \\<Rightarrow> Code.abort (STR ''relcomp Set_Monad DList_set: ceq2 = None'') (\\<lambda>_. Set_Monad xs6 O DList_set dxs4)\n                   | Some _ \\<Rightarrow> fold (\\<lambda>(x, y). DList_Set.fold (\\<lambda>(y', z) A. if eq y y' then insert (x, z) A else A) dxs4) xs6 {})\"\n  (is ?monad_dlist)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((RBT_set rbt1 O RBT_set rbt2 =\n      (case ID ccompare of\n       None \\<Rightarrow>\n         Code.abort STR ''relcomp RBT_set RBT_set: ccompare1 = None''\n          (\\<lambda>_. RBT_set rbt1 O RBT_set rbt2)\n       | Some x \\<Rightarrow>\n           case ID ccompare of\n           None \\<Rightarrow>\n             Code.abort STR ''relcomp RBT_set RBT_set: ccompare2 = None''\n              (\\<lambda>_. RBT_set rbt1 O RBT_set rbt2)\n           | Some c_b \\<Rightarrow>\n               case ID ccompare of\n               None \\<Rightarrow>\n                 Code.abort\n                  STR ''relcomp RBT_set RBT_set: ccompare3 = None''\n                  (\\<lambda>_. RBT_set rbt1 O RBT_set rbt2)\n               | Some x \\<Rightarrow>\n                   RBT_Set2.fold\n                    (\\<lambda>(x, y).\n                        RBT_Set2.fold\n                         (\\<lambda>(y', z) A.\n                             if c_b y y' \\<noteq> Eq then A\n                             else insert (x, z) A)\n                         rbt2)\n                    rbt1 {}) &&&\n      RBT_set rbt3 O DList_set dxs1 =\n      (case ID ccompare of\n       None \\<Rightarrow>\n         Code.abort STR ''relcomp RBT_set DList_set: ccompare1 = None''\n          (\\<lambda>_. RBT_set rbt3 O DList_set dxs1)\n       | Some x \\<Rightarrow>\n           case ID ccompare of\n           None \\<Rightarrow>\n             Code.abort STR ''relcomp RBT_set DList_set: ccompare2 = None''\n              (\\<lambda>_. RBT_set rbt3 O DList_set dxs1)\n           | Some x \\<Rightarrow>\n               case ID CEQ('d) of\n               None \\<Rightarrow>\n                 Code.abort STR ''relcomp RBT_set DList_set: ceq2 = None''\n                  (\\<lambda>_. RBT_set rbt3 O DList_set dxs1)\n               | Some eq \\<Rightarrow>\n                   case ID CEQ('e) of\n                   None \\<Rightarrow>\n                     Code.abort\n                      STR ''relcomp RBT_set DList_set: ceq3 = None''\n                      (\\<lambda>_. RBT_set rbt3 O DList_set dxs1)\n                   | Some x \\<Rightarrow>\n                       RBT_Set2.fold\n                        (\\<lambda>(x, y).\n                            DList_Set.fold\n                             (\\<lambda>(y', z) A.\n                                 if eq y y' then insert (x, z) A else A)\n                             dxs1)\n                        rbt3 {})) &&&\n     DList_set dxs2 O RBT_set rbt4 =\n     (case ID CEQ('e) of\n      None \\<Rightarrow>\n        Code.abort STR ''relcomp DList_set RBT_set: ceq1 = None''\n         (\\<lambda>_. DList_set dxs2 O RBT_set rbt4)\n      | Some x \\<Rightarrow>\n          case ID ccompare of\n          None \\<Rightarrow>\n            Code.abort STR ''relcomp DList_set RBT_set: ceq2 = None''\n             (\\<lambda>_. DList_set dxs2 O RBT_set rbt4)\n          | Some x \\<Rightarrow>\n              case ID CEQ('d) of\n              None \\<Rightarrow>\n                Code.abort\n                 STR ''relcomp DList_set RBT_set: ccompare2 = None''\n                 (\\<lambda>_. DList_set dxs2 O RBT_set rbt4)\n              | Some eq \\<Rightarrow>\n                  case ID ccompare of\n                  None \\<Rightarrow>\n                    Code.abort\n                     STR ''relcomp DList_set RBT_set: ccompare3 = None''\n                     (\\<lambda>_. DList_set dxs2 O RBT_set rbt4)\n                  | Some x \\<Rightarrow>\n                      DList_Set.fold\n                       (\\<lambda>(x, y).\n                           RBT_Set2.fold\n                            (\\<lambda>(y', z) A.\n                                if eq y y' then insert (x, z) A else A)\n                            rbt4)\n                       dxs2 {}) &&&\n     DList_set dxs3 O DList_set dxs4 =\n     (case ID CEQ('e) of\n      None \\<Rightarrow>\n        Code.abort STR ''relcomp DList_set DList_set: ceq1 = None''\n         (\\<lambda>_. DList_set dxs3 O DList_set dxs4)\n      | Some x \\<Rightarrow>\n          case ID CEQ('f) of\n          None \\<Rightarrow>\n            Code.abort STR ''relcomp DList_set DList_set: ceq2 = None''\n             (\\<lambda>_. DList_set dxs3 O DList_set dxs4)\n          | Some eq \\<Rightarrow>\n              case ID CEQ('g) of\n              None \\<Rightarrow>\n                Code.abort STR ''relcomp DList_set DList_set: ceq3 = None''\n                 (\\<lambda>_. DList_set dxs3 O DList_set dxs4)\n              | Some x \\<Rightarrow>\n                  DList_Set.fold\n                   (\\<lambda>(x, y).\n                       DList_Set.fold\n                        (\\<lambda>(y', z) A.\n                            if eq y y' then insert (x, z) A else A)\n                        dxs4)\n                   dxs3 {})) &&&\n    (Set_Monad xs1 O Set_Monad xs2 =\n     (case ID CEQ('i) of\n      None \\<Rightarrow>\n        Code.abort STR ''relcomp Set_Monad Set_Monad: ceq = None''\n         (\\<lambda>_. Set_Monad xs1 O Set_Monad xs2)\n      | Some eq \\<Rightarrow>\n          fold\n           (\\<lambda>(x, y).\n               fold\n                (\\<lambda>(y', z) A. if eq y y' then insert (x, z) A else A)\n                xs2)\n           xs1 {}) &&&\n     RBT_set rbt1 O Set_Monad xs3 =\n     (case ID ccompare of\n      None \\<Rightarrow>\n        Code.abort STR ''relcomp RBT_set Set_Monad: ccompare1 = None''\n         (\\<lambda>_. RBT_set rbt1 O Set_Monad xs3)\n      | Some x \\<Rightarrow>\n          case ID ccompare of\n          None \\<Rightarrow>\n            Code.abort STR ''relcomp RBT_set Set_Monad: ccompare2 = None''\n             (\\<lambda>_. RBT_set rbt1 O Set_Monad xs3)\n          | Some c_b \\<Rightarrow>\n              RBT_Set2.fold\n               (\\<lambda>(x, y).\n                   fold\n                    (\\<lambda>(y', z) A.\n                        if c_b y y' \\<noteq> Eq then A else insert (x, z) A)\n                    xs3)\n               rbt1 {})) &&&\n    Set_Monad xs4 O RBT_set rbt5 =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''relcomp Set_Monad RBT_set: ccompare1 = None''\n        (\\<lambda>_. Set_Monad xs4 O RBT_set rbt5)\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''relcomp Set_Monad RBT_set: ccompare2 = None''\n            (\\<lambda>_. Set_Monad xs4 O RBT_set rbt5)\n         | Some c_b \\<Rightarrow>\n             fold\n              (\\<lambda>(x, y).\n                  RBT_Set2.fold\n                   (\\<lambda>(y', z) A.\n                       if c_b y y' \\<noteq> Eq then A else insert (x, z) A)\n                   rbt5)\n              xs4 {}) &&&\n    DList_set dxs3 O Set_Monad xs5 =\n    (case ID CEQ('e) of\n     None \\<Rightarrow>\n       Code.abort STR ''relcomp DList_set Set_Monad: ceq1 = None''\n        (\\<lambda>_. DList_set dxs3 O Set_Monad xs5)\n     | Some x \\<Rightarrow>\n         case ID CEQ('f) of\n         None \\<Rightarrow>\n           Code.abort STR ''relcomp DList_set Set_Monad: ceq2 = None''\n            (\\<lambda>_. DList_set dxs3 O Set_Monad xs5)\n         | Some eq \\<Rightarrow>\n             DList_Set.fold\n              (\\<lambda>(x, y).\n                  fold\n                   (\\<lambda>(y', z) A.\n                       if eq y y' then insert (x, z) A else A)\n                   xs5)\n              dxs3 {}) &&&\n    Set_Monad xs6 O DList_set dxs4 =\n    (case ID CEQ('f) of\n     None \\<Rightarrow>\n       Code.abort STR ''relcomp Set_Monad DList_set: ceq1 = None''\n        (\\<lambda>_. Set_Monad xs6 O DList_set dxs4)\n     | Some eq \\<Rightarrow>\n         case ID CEQ('g) of\n         None \\<Rightarrow>\n           Code.abort STR ''relcomp Set_Monad DList_set: ceq2 = None''\n            (\\<lambda>_. Set_Monad xs6 O DList_set dxs4)\n         | Some x \\<Rightarrow>\n             fold\n              (\\<lambda>(x, y).\n                  DList_Set.fold\n                   (\\<lambda>(y', z) A.\n                       if eq y y' then insert (x, z) A else A)\n                   dxs4)\n              xs6 {})", "proof -"], ["proof (state)\ngoal (9 subgoals):\n 1. RBT_set rbt1 O RBT_set rbt2 =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''relcomp RBT_set RBT_set: ccompare1 = None''\n        (\\<lambda>_. RBT_set rbt1 O RBT_set rbt2)\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''relcomp RBT_set RBT_set: ccompare2 = None''\n            (\\<lambda>_. RBT_set rbt1 O RBT_set rbt2)\n         | Some c_b \\<Rightarrow>\n             case ID ccompare of\n             None \\<Rightarrow>\n               Code.abort STR ''relcomp RBT_set RBT_set: ccompare3 = None''\n                (\\<lambda>_. RBT_set rbt1 O RBT_set rbt2)\n             | Some x \\<Rightarrow>\n                 RBT_Set2.fold\n                  (\\<lambda>(x, y).\n                      RBT_Set2.fold\n                       (\\<lambda>(y', z) A.\n                           if c_b y y' \\<noteq> Eq then A\n                           else insert (x, z) A)\n                       rbt2)\n                  rbt1 {})\n 2. RBT_set rbt3 O DList_set dxs1 =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''relcomp RBT_set DList_set: ccompare1 = None''\n        (\\<lambda>_. RBT_set rbt3 O DList_set dxs1)\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''relcomp RBT_set DList_set: ccompare2 = None''\n            (\\<lambda>_. RBT_set rbt3 O DList_set dxs1)\n         | Some x \\<Rightarrow>\n             case ID CEQ('d) of\n             None \\<Rightarrow>\n               Code.abort STR ''relcomp RBT_set DList_set: ceq2 = None''\n                (\\<lambda>_. RBT_set rbt3 O DList_set dxs1)\n             | Some eq \\<Rightarrow>\n                 case ID CEQ('e) of\n                 None \\<Rightarrow>\n                   Code.abort STR ''relcomp RBT_set DList_set: ceq3 = None''\n                    (\\<lambda>_. RBT_set rbt3 O DList_set dxs1)\n                 | Some x \\<Rightarrow>\n                     RBT_Set2.fold\n                      (\\<lambda>(x, y).\n                          DList_Set.fold\n                           (\\<lambda>(y', z) A.\n                               if eq y y' then insert (x, z) A else A)\n                           dxs1)\n                      rbt3 {})\n 3. DList_set dxs2 O RBT_set rbt4 =\n    (case ID CEQ('e) of\n     None \\<Rightarrow>\n       Code.abort STR ''relcomp DList_set RBT_set: ceq1 = None''\n        (\\<lambda>_. DList_set dxs2 O RBT_set rbt4)\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''relcomp DList_set RBT_set: ceq2 = None''\n            (\\<lambda>_. DList_set dxs2 O RBT_set rbt4)\n         | Some x \\<Rightarrow>\n             case ID CEQ('d) of\n             None \\<Rightarrow>\n               Code.abort\n                STR ''relcomp DList_set RBT_set: ccompare2 = None''\n                (\\<lambda>_. DList_set dxs2 O RBT_set rbt4)\n             | Some eq \\<Rightarrow>\n                 case ID ccompare of\n                 None \\<Rightarrow>\n                   Code.abort\n                    STR ''relcomp DList_set RBT_set: ccompare3 = None''\n                    (\\<lambda>_. DList_set dxs2 O RBT_set rbt4)\n                 | Some x \\<Rightarrow>\n                     DList_Set.fold\n                      (\\<lambda>(x, y).\n                          RBT_Set2.fold\n                           (\\<lambda>(y', z) A.\n                               if eq y y' then insert (x, z) A else A)\n                           rbt4)\n                      dxs2 {})\n 4. DList_set dxs3 O DList_set dxs4 =\n    (case ID CEQ('e) of\n     None \\<Rightarrow>\n       Code.abort STR ''relcomp DList_set DList_set: ceq1 = None''\n        (\\<lambda>_. DList_set dxs3 O DList_set dxs4)\n     | Some x \\<Rightarrow>\n         case ID CEQ('f) of\n         None \\<Rightarrow>\n           Code.abort STR ''relcomp DList_set DList_set: ceq2 = None''\n            (\\<lambda>_. DList_set dxs3 O DList_set dxs4)\n         | Some eq \\<Rightarrow>\n             case ID CEQ('g) of\n             None \\<Rightarrow>\n               Code.abort STR ''relcomp DList_set DList_set: ceq3 = None''\n                (\\<lambda>_. DList_set dxs3 O DList_set dxs4)\n             | Some x \\<Rightarrow>\n                 DList_Set.fold\n                  (\\<lambda>(x, y).\n                      DList_Set.fold\n                       (\\<lambda>(y', z) A.\n                           if eq y y' then insert (x, z) A else A)\n                       dxs4)\n                  dxs3 {})\n 5. Set_Monad xs1 O Set_Monad xs2 =\n    (case ID CEQ('i) of\n     None \\<Rightarrow>\n       Code.abort STR ''relcomp Set_Monad Set_Monad: ceq = None''\n        (\\<lambda>_. Set_Monad xs1 O Set_Monad xs2)\n     | Some eq \\<Rightarrow>\n         fold\n          (\\<lambda>(x, y).\n              fold\n               (\\<lambda>(y', z) A. if eq y y' then insert (x, z) A else A)\n               xs2)\n          xs1 {})\n 6. RBT_set rbt1 O Set_Monad xs3 =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''relcomp RBT_set Set_Monad: ccompare1 = None''\n        (\\<lambda>_. RBT_set rbt1 O Set_Monad xs3)\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''relcomp RBT_set Set_Monad: ccompare2 = None''\n            (\\<lambda>_. RBT_set rbt1 O Set_Monad xs3)\n         | Some c_b \\<Rightarrow>\n             RBT_Set2.fold\n              (\\<lambda>(x, y).\n                  fold\n                   (\\<lambda>(y', z) A.\n                       if c_b y y' \\<noteq> Eq then A else insert (x, z) A)\n                   xs3)\n              rbt1 {})\n 7. Set_Monad xs4 O RBT_set rbt5 =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''relcomp Set_Monad RBT_set: ccompare1 = None''\n        (\\<lambda>_. Set_Monad xs4 O RBT_set rbt5)\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''relcomp Set_Monad RBT_set: ccompare2 = None''\n            (\\<lambda>_. Set_Monad xs4 O RBT_set rbt5)\n         | Some c_b \\<Rightarrow>\n             fold\n              (\\<lambda>(x, y).\n                  RBT_Set2.fold\n                   (\\<lambda>(y', z) A.\n                       if c_b y y' \\<noteq> Eq then A else insert (x, z) A)\n                   rbt5)\n              xs4 {})\n 8. DList_set dxs3 O Set_Monad xs5 =\n    (case ID CEQ('e) of\n     None \\<Rightarrow>\n       Code.abort STR ''relcomp DList_set Set_Monad: ceq1 = None''\n        (\\<lambda>_. DList_set dxs3 O Set_Monad xs5)\n     | Some x \\<Rightarrow>\n         case ID CEQ('f) of\n         None \\<Rightarrow>\n           Code.abort STR ''relcomp DList_set Set_Monad: ceq2 = None''\n            (\\<lambda>_. DList_set dxs3 O Set_Monad xs5)\n         | Some eq \\<Rightarrow>\n             DList_Set.fold\n              (\\<lambda>(x, y).\n                  fold\n                   (\\<lambda>(y', z) A.\n                       if eq y y' then insert (x, z) A else A)\n                   xs5)\n              dxs3 {})\n 9. Set_Monad xs6 O DList_set dxs4 =\n    (case ID CEQ('f) of\n     None \\<Rightarrow>\n       Code.abort STR ''relcomp Set_Monad DList_set: ceq1 = None''\n        (\\<lambda>_. Set_Monad xs6 O DList_set dxs4)\n     | Some eq \\<Rightarrow>\n         case ID CEQ('g) of\n         None \\<Rightarrow>\n           Code.abort STR ''relcomp Set_Monad DList_set: ceq2 = None''\n            (\\<lambda>_. Set_Monad xs6 O DList_set dxs4)\n         | Some x \\<Rightarrow>\n             fold\n              (\\<lambda>(x, y).\n                  DList_Set.fold\n                   (\\<lambda>(y', z) A.\n                       if eq y y' then insert (x, z) A else A)\n                   dxs4)\n              xs6 {})", "show ?rbt_rbt ?rbt_monad ?monad_rbt"], ["proof (prove)\ngoal (1 subgoal):\n 1. RBT_set rbt1 O RBT_set rbt2 =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''relcomp RBT_set RBT_set: ccompare1 = None''\n        (\\<lambda>_. RBT_set rbt1 O RBT_set rbt2)\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''relcomp RBT_set RBT_set: ccompare2 = None''\n            (\\<lambda>_. RBT_set rbt1 O RBT_set rbt2)\n         | Some c_b \\<Rightarrow>\n             case ID ccompare of\n             None \\<Rightarrow>\n               Code.abort STR ''relcomp RBT_set RBT_set: ccompare3 = None''\n                (\\<lambda>_. RBT_set rbt1 O RBT_set rbt2)\n             | Some x \\<Rightarrow>\n                 RBT_Set2.fold\n                  (\\<lambda>(x, y).\n                      RBT_Set2.fold\n                       (\\<lambda>(y', z) A.\n                           if c_b y y' \\<noteq> Eq then A\n                           else insert (x, z) A)\n                       rbt2)\n                  rbt1 {}) &&&\n    RBT_set rbt1 O Set_Monad xs3 =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''relcomp RBT_set Set_Monad: ccompare1 = None''\n        (\\<lambda>_. RBT_set rbt1 O Set_Monad xs3)\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''relcomp RBT_set Set_Monad: ccompare2 = None''\n            (\\<lambda>_. RBT_set rbt1 O Set_Monad xs3)\n         | Some c_b \\<Rightarrow>\n             RBT_Set2.fold\n              (\\<lambda>(x, y).\n                  fold\n                   (\\<lambda>(y', z) A.\n                       if c_b y y' \\<noteq> Eq then A else insert (x, z) A)\n                   xs3)\n              rbt1 {}) &&&\n    Set_Monad xs4 O RBT_set rbt5 =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''relcomp Set_Monad RBT_set: ccompare1 = None''\n        (\\<lambda>_. Set_Monad xs4 O RBT_set rbt5)\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''relcomp Set_Monad RBT_set: ccompare2 = None''\n            (\\<lambda>_. Set_Monad xs4 O RBT_set rbt5)\n         | Some c_b \\<Rightarrow>\n             fold\n              (\\<lambda>(x, y).\n                  RBT_Set2.fold\n                   (\\<lambda>(y', z) A.\n                       if c_b y y' \\<noteq> Eq then A else insert (x, z) A)\n                   rbt5)\n              xs4 {})", "by(auto simp add: comparator.eq[OF ID_ccompare'] RBT_set_def ccompare_prod_def member_conv_keys ID_Some RBT_Set2.fold_conv_fold_keys' RBT_Set2.keys.rep_eq If_not set_relcomp_set split: option.split del: equalityI)"], ["proof (state)\nthis:\n  RBT_set rbt1 O RBT_set rbt2 =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''relcomp RBT_set RBT_set: ccompare1 = None''\n      (\\<lambda>_. RBT_set rbt1 O RBT_set rbt2)\n   | Some x \\<Rightarrow>\n       case ID ccompare of\n       None \\<Rightarrow>\n         Code.abort STR ''relcomp RBT_set RBT_set: ccompare2 = None''\n          (\\<lambda>_. RBT_set rbt1 O RBT_set rbt2)\n       | Some c_b \\<Rightarrow>\n           case ID ccompare of\n           None \\<Rightarrow>\n             Code.abort STR ''relcomp RBT_set RBT_set: ccompare3 = None''\n              (\\<lambda>_. RBT_set rbt1 O RBT_set rbt2)\n           | Some x \\<Rightarrow>\n               RBT_Set2.fold\n                (\\<lambda>(x, y).\n                    RBT_Set2.fold\n                     (\\<lambda>(y', z) A.\n                         if c_b y y' \\<noteq> Eq then A\n                         else insert (x, z) A)\n                     rbt2)\n                rbt1 {})\n  RBT_set rbt1 O Set_Monad xs3 =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''relcomp RBT_set Set_Monad: ccompare1 = None''\n      (\\<lambda>_. RBT_set rbt1 O Set_Monad xs3)\n   | Some x \\<Rightarrow>\n       case ID ccompare of\n       None \\<Rightarrow>\n         Code.abort STR ''relcomp RBT_set Set_Monad: ccompare2 = None''\n          (\\<lambda>_. RBT_set rbt1 O Set_Monad xs3)\n       | Some c_b \\<Rightarrow>\n           RBT_Set2.fold\n            (\\<lambda>(x, y).\n                fold\n                 (\\<lambda>(y', z) A.\n                     if c_b y y' \\<noteq> Eq then A else insert (x, z) A)\n                 xs3)\n            rbt1 {})\n  Set_Monad xs4 O RBT_set rbt5 =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''relcomp Set_Monad RBT_set: ccompare1 = None''\n      (\\<lambda>_. Set_Monad xs4 O RBT_set rbt5)\n   | Some x \\<Rightarrow>\n       case ID ccompare of\n       None \\<Rightarrow>\n         Code.abort STR ''relcomp Set_Monad RBT_set: ccompare2 = None''\n          (\\<lambda>_. Set_Monad xs4 O RBT_set rbt5)\n       | Some c_b \\<Rightarrow>\n           fold\n            (\\<lambda>(x, y).\n                RBT_Set2.fold\n                 (\\<lambda>(y', z) A.\n                     if c_b y y' \\<noteq> Eq then A else insert (x, z) A)\n                 rbt5)\n            xs4 {})\n\ngoal (6 subgoals):\n 1. RBT_set rbt3 O DList_set dxs1 =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''relcomp RBT_set DList_set: ccompare1 = None''\n        (\\<lambda>_. RBT_set rbt3 O DList_set dxs1)\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''relcomp RBT_set DList_set: ccompare2 = None''\n            (\\<lambda>_. RBT_set rbt3 O DList_set dxs1)\n         | Some x \\<Rightarrow>\n             case ID CEQ('d) of\n             None \\<Rightarrow>\n               Code.abort STR ''relcomp RBT_set DList_set: ceq2 = None''\n                (\\<lambda>_. RBT_set rbt3 O DList_set dxs1)\n             | Some eq \\<Rightarrow>\n                 case ID CEQ('e) of\n                 None \\<Rightarrow>\n                   Code.abort STR ''relcomp RBT_set DList_set: ceq3 = None''\n                    (\\<lambda>_. RBT_set rbt3 O DList_set dxs1)\n                 | Some x \\<Rightarrow>\n                     RBT_Set2.fold\n                      (\\<lambda>(x, y).\n                          DList_Set.fold\n                           (\\<lambda>(y', z) A.\n                               if eq y y' then insert (x, z) A else A)\n                           dxs1)\n                      rbt3 {})\n 2. DList_set dxs2 O RBT_set rbt4 =\n    (case ID CEQ('e) of\n     None \\<Rightarrow>\n       Code.abort STR ''relcomp DList_set RBT_set: ceq1 = None''\n        (\\<lambda>_. DList_set dxs2 O RBT_set rbt4)\n     | Some x \\<Rightarrow>\n         case ID ccompare of\n         None \\<Rightarrow>\n           Code.abort STR ''relcomp DList_set RBT_set: ceq2 = None''\n            (\\<lambda>_. DList_set dxs2 O RBT_set rbt4)\n         | Some x \\<Rightarrow>\n             case ID CEQ('d) of\n             None \\<Rightarrow>\n               Code.abort\n                STR ''relcomp DList_set RBT_set: ccompare2 = None''\n                (\\<lambda>_. DList_set dxs2 O RBT_set rbt4)\n             | Some eq \\<Rightarrow>\n                 case ID ccompare of\n                 None \\<Rightarrow>\n                   Code.abort\n                    STR ''relcomp DList_set RBT_set: ccompare3 = None''\n                    (\\<lambda>_. DList_set dxs2 O RBT_set rbt4)\n                 | Some x \\<Rightarrow>\n                     DList_Set.fold\n                      (\\<lambda>(x, y).\n                          RBT_Set2.fold\n                           (\\<lambda>(y', z) A.\n                               if eq y y' then insert (x, z) A else A)\n                           rbt4)\n                      dxs2 {})\n 3. DList_set dxs3 O DList_set dxs4 =\n    (case ID CEQ('e) of\n     None \\<Rightarrow>\n       Code.abort STR ''relcomp DList_set DList_set: ceq1 = None''\n        (\\<lambda>_. DList_set dxs3 O DList_set dxs4)\n     | Some x \\<Rightarrow>\n         case ID CEQ('f) of\n         None \\<Rightarrow>\n           Code.abort STR ''relcomp DList_set DList_set: ceq2 = None''\n            (\\<lambda>_. DList_set dxs3 O DList_set dxs4)\n         | Some eq \\<Rightarrow>\n             case ID CEQ('g) of\n             None \\<Rightarrow>\n               Code.abort STR ''relcomp DList_set DList_set: ceq3 = None''\n                (\\<lambda>_. DList_set dxs3 O DList_set dxs4)\n             | Some x \\<Rightarrow>\n                 DList_Set.fold\n                  (\\<lambda>(x, y).\n                      DList_Set.fold\n                       (\\<lambda>(y', z) A.\n                           if eq y y' then insert (x, z) A else A)\n                       dxs4)\n                  dxs3 {})\n 4. Set_Monad xs1 O Set_Monad xs2 =\n    (case ID CEQ('i) of\n     None \\<Rightarrow>\n       Code.abort STR ''relcomp Set_Monad Set_Monad: ceq = None''\n        (\\<lambda>_. Set_Monad xs1 O Set_Monad xs2)\n     | Some eq \\<Rightarrow>\n         fold\n          (\\<lambda>(x, y).\n              fold\n               (\\<lambda>(y', z) A. if eq y y' then insert (x, z) A else A)\n               xs2)\n          xs1 {})\n 5. DList_set dxs3 O Set_Monad xs5 =\n    (case ID CEQ('e) of\n     None \\<Rightarrow>\n       Code.abort STR ''relcomp DList_set Set_Monad: ceq1 = None''\n        (\\<lambda>_. DList_set dxs3 O Set_Monad xs5)\n     | Some x \\<Rightarrow>\n         case ID CEQ('f) of\n         None \\<Rightarrow>\n           Code.abort STR ''relcomp DList_set Set_Monad: ceq2 = None''\n            (\\<lambda>_. DList_set dxs3 O Set_Monad xs5)\n         | Some eq \\<Rightarrow>\n             DList_Set.fold\n              (\\<lambda>(x, y).\n                  fold\n                   (\\<lambda>(y', z) A.\n                       if eq y y' then insert (x, z) A else A)\n                   xs5)\n              dxs3 {})\n 6. Set_Monad xs6 O DList_set dxs4 =\n    (case ID CEQ('f) of\n     None \\<Rightarrow>\n       Code.abort STR ''relcomp Set_Monad DList_set: ceq1 = None''\n        (\\<lambda>_. Set_Monad xs6 O DList_set dxs4)\n     | Some eq \\<Rightarrow>\n         case ID CEQ('g) of\n         None \\<Rightarrow>\n           Code.abort STR ''relcomp Set_Monad DList_set: ceq2 = None''\n            (\\<lambda>_. Set_Monad xs6 O DList_set dxs4)\n         | Some x \\<Rightarrow>\n             fold\n              (\\<lambda>(x, y).\n                  DList_Set.fold\n                   (\\<lambda>(y', z) A.\n                       if eq y y' then insert (x, z) A else A)\n                   dxs4)\n              xs6 {})", "show ?rbt_dlist ?dlist_rbt ?dlist_dlist ?monad_monad ?dlist_monad ?monad_dlist"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RBT_set rbt3 O DList_set dxs1 =\n     (case ID ccompare of\n      None \\<Rightarrow>\n        Code.abort STR ''relcomp RBT_set DList_set: ccompare1 = None''\n         (\\<lambda>_. RBT_set rbt3 O DList_set dxs1)\n      | Some x \\<Rightarrow>\n          case ID ccompare of\n          None \\<Rightarrow>\n            Code.abort STR ''relcomp RBT_set DList_set: ccompare2 = None''\n             (\\<lambda>_. RBT_set rbt3 O DList_set dxs1)\n          | Some x \\<Rightarrow>\n              case ID CEQ('d) of\n              None \\<Rightarrow>\n                Code.abort STR ''relcomp RBT_set DList_set: ceq2 = None''\n                 (\\<lambda>_. RBT_set rbt3 O DList_set dxs1)\n              | Some eq \\<Rightarrow>\n                  case ID CEQ('e) of\n                  None \\<Rightarrow>\n                    Code.abort\n                     STR ''relcomp RBT_set DList_set: ceq3 = None''\n                     (\\<lambda>_. RBT_set rbt3 O DList_set dxs1)\n                  | Some x \\<Rightarrow>\n                      RBT_Set2.fold\n                       (\\<lambda>(x, y).\n                           DList_Set.fold\n                            (\\<lambda>(y', z) A.\n                                if eq y y' then insert (x, z) A else A)\n                            dxs1)\n                       rbt3 {}) &&&\n     DList_set dxs2 O RBT_set rbt4 =\n     (case ID CEQ('e) of\n      None \\<Rightarrow>\n        Code.abort STR ''relcomp DList_set RBT_set: ceq1 = None''\n         (\\<lambda>_. DList_set dxs2 O RBT_set rbt4)\n      | Some x \\<Rightarrow>\n          case ID ccompare of\n          None \\<Rightarrow>\n            Code.abort STR ''relcomp DList_set RBT_set: ceq2 = None''\n             (\\<lambda>_. DList_set dxs2 O RBT_set rbt4)\n          | Some x \\<Rightarrow>\n              case ID CEQ('d) of\n              None \\<Rightarrow>\n                Code.abort\n                 STR ''relcomp DList_set RBT_set: ccompare2 = None''\n                 (\\<lambda>_. DList_set dxs2 O RBT_set rbt4)\n              | Some eq \\<Rightarrow>\n                  case ID ccompare of\n                  None \\<Rightarrow>\n                    Code.abort\n                     STR ''relcomp DList_set RBT_set: ccompare3 = None''\n                     (\\<lambda>_. DList_set dxs2 O RBT_set rbt4)\n                  | Some x \\<Rightarrow>\n                      DList_Set.fold\n                       (\\<lambda>(x, y).\n                           RBT_Set2.fold\n                            (\\<lambda>(y', z) A.\n                                if eq y y' then insert (x, z) A else A)\n                            rbt4)\n                       dxs2 {}) &&&\n     DList_set dxs3 O DList_set dxs4 =\n     (case ID CEQ('e) of\n      None \\<Rightarrow>\n        Code.abort STR ''relcomp DList_set DList_set: ceq1 = None''\n         (\\<lambda>_. DList_set dxs3 O DList_set dxs4)\n      | Some x \\<Rightarrow>\n          case ID CEQ('f) of\n          None \\<Rightarrow>\n            Code.abort STR ''relcomp DList_set DList_set: ceq2 = None''\n             (\\<lambda>_. DList_set dxs3 O DList_set dxs4)\n          | Some eq \\<Rightarrow>\n              case ID CEQ('g) of\n              None \\<Rightarrow>\n                Code.abort STR ''relcomp DList_set DList_set: ceq3 = None''\n                 (\\<lambda>_. DList_set dxs3 O DList_set dxs4)\n              | Some x \\<Rightarrow>\n                  DList_Set.fold\n                   (\\<lambda>(x, y).\n                       DList_Set.fold\n                        (\\<lambda>(y', z) A.\n                            if eq y y' then insert (x, z) A else A)\n                        dxs4)\n                   dxs3 {})) &&&\n    Set_Monad xs1 O Set_Monad xs2 =\n    (case ID CEQ('i) of\n     None \\<Rightarrow>\n       Code.abort STR ''relcomp Set_Monad Set_Monad: ceq = None''\n        (\\<lambda>_. Set_Monad xs1 O Set_Monad xs2)\n     | Some eq \\<Rightarrow>\n         fold\n          (\\<lambda>(x, y).\n              fold\n               (\\<lambda>(y', z) A. if eq y y' then insert (x, z) A else A)\n               xs2)\n          xs1 {}) &&&\n    DList_set dxs3 O Set_Monad xs5 =\n    (case ID CEQ('e) of\n     None \\<Rightarrow>\n       Code.abort STR ''relcomp DList_set Set_Monad: ceq1 = None''\n        (\\<lambda>_. DList_set dxs3 O Set_Monad xs5)\n     | Some x \\<Rightarrow>\n         case ID CEQ('f) of\n         None \\<Rightarrow>\n           Code.abort STR ''relcomp DList_set Set_Monad: ceq2 = None''\n            (\\<lambda>_. DList_set dxs3 O Set_Monad xs5)\n         | Some eq \\<Rightarrow>\n             DList_Set.fold\n              (\\<lambda>(x, y).\n                  fold\n                   (\\<lambda>(y', z) A.\n                       if eq y y' then insert (x, z) A else A)\n                   xs5)\n              dxs3 {}) &&&\n    Set_Monad xs6 O DList_set dxs4 =\n    (case ID CEQ('f) of\n     None \\<Rightarrow>\n       Code.abort STR ''relcomp Set_Monad DList_set: ceq1 = None''\n        (\\<lambda>_. Set_Monad xs6 O DList_set dxs4)\n     | Some eq \\<Rightarrow>\n         case ID CEQ('g) of\n         None \\<Rightarrow>\n           Code.abort STR ''relcomp Set_Monad DList_set: ceq2 = None''\n            (\\<lambda>_. Set_Monad xs6 O DList_set dxs4)\n         | Some x \\<Rightarrow>\n             fold\n              (\\<lambda>(x, y).\n                  DList_Set.fold\n                   (\\<lambda>(y', z) A.\n                       if eq y y' then insert (x, z) A else A)\n                   dxs4)\n              xs6 {})", "by(auto simp add: RBT_set_def DList_set_def member_conv_keys ID_Some ccompare_prod_def ceq_prod_def Collect_member RBT_Set2.fold_conv_fold_keys' RBT_Set2.keys.rep_eq DList_Set.fold.rep_eq set_relcomp_set dest: equal.equal_eq[OF ID_ceq] split: option.split del: equalityI)"], ["proof (state)\nthis:\n  RBT_set rbt3 O DList_set dxs1 =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''relcomp RBT_set DList_set: ccompare1 = None''\n      (\\<lambda>_. RBT_set rbt3 O DList_set dxs1)\n   | Some x \\<Rightarrow>\n       case ID ccompare of\n       None \\<Rightarrow>\n         Code.abort STR ''relcomp RBT_set DList_set: ccompare2 = None''\n          (\\<lambda>_. RBT_set rbt3 O DList_set dxs1)\n       | Some x \\<Rightarrow>\n           case ID CEQ('d) of\n           None \\<Rightarrow>\n             Code.abort STR ''relcomp RBT_set DList_set: ceq2 = None''\n              (\\<lambda>_. RBT_set rbt3 O DList_set dxs1)\n           | Some eq \\<Rightarrow>\n               case ID CEQ('e) of\n               None \\<Rightarrow>\n                 Code.abort STR ''relcomp RBT_set DList_set: ceq3 = None''\n                  (\\<lambda>_. RBT_set rbt3 O DList_set dxs1)\n               | Some x \\<Rightarrow>\n                   RBT_Set2.fold\n                    (\\<lambda>(x, y).\n                        DList_Set.fold\n                         (\\<lambda>(y', z) A.\n                             if eq y y' then insert (x, z) A else A)\n                         dxs1)\n                    rbt3 {})\n  DList_set dxs2 O RBT_set rbt4 =\n  (case ID CEQ('e) of\n   None \\<Rightarrow>\n     Code.abort STR ''relcomp DList_set RBT_set: ceq1 = None''\n      (\\<lambda>_. DList_set dxs2 O RBT_set rbt4)\n   | Some x \\<Rightarrow>\n       case ID ccompare of\n       None \\<Rightarrow>\n         Code.abort STR ''relcomp DList_set RBT_set: ceq2 = None''\n          (\\<lambda>_. DList_set dxs2 O RBT_set rbt4)\n       | Some x \\<Rightarrow>\n           case ID CEQ('d) of\n           None \\<Rightarrow>\n             Code.abort STR ''relcomp DList_set RBT_set: ccompare2 = None''\n              (\\<lambda>_. DList_set dxs2 O RBT_set rbt4)\n           | Some eq \\<Rightarrow>\n               case ID ccompare of\n               None \\<Rightarrow>\n                 Code.abort\n                  STR ''relcomp DList_set RBT_set: ccompare3 = None''\n                  (\\<lambda>_. DList_set dxs2 O RBT_set rbt4)\n               | Some x \\<Rightarrow>\n                   DList_Set.fold\n                    (\\<lambda>(x, y).\n                        RBT_Set2.fold\n                         (\\<lambda>(y', z) A.\n                             if eq y y' then insert (x, z) A else A)\n                         rbt4)\n                    dxs2 {})\n  DList_set dxs3 O DList_set dxs4 =\n  (case ID CEQ('e) of\n   None \\<Rightarrow>\n     Code.abort STR ''relcomp DList_set DList_set: ceq1 = None''\n      (\\<lambda>_. DList_set dxs3 O DList_set dxs4)\n   | Some x \\<Rightarrow>\n       case ID CEQ('f) of\n       None \\<Rightarrow>\n         Code.abort STR ''relcomp DList_set DList_set: ceq2 = None''\n          (\\<lambda>_. DList_set dxs3 O DList_set dxs4)\n       | Some eq \\<Rightarrow>\n           case ID CEQ('g) of\n           None \\<Rightarrow>\n             Code.abort STR ''relcomp DList_set DList_set: ceq3 = None''\n              (\\<lambda>_. DList_set dxs3 O DList_set dxs4)\n           | Some x \\<Rightarrow>\n               DList_Set.fold\n                (\\<lambda>(x, y).\n                    DList_Set.fold\n                     (\\<lambda>(y', z) A.\n                         if eq y y' then insert (x, z) A else A)\n                     dxs4)\n                dxs3 {})\n  Set_Monad xs1 O Set_Monad xs2 =\n  (case ID CEQ('i) of\n   None \\<Rightarrow>\n     Code.abort STR ''relcomp Set_Monad Set_Monad: ceq = None''\n      (\\<lambda>_. Set_Monad xs1 O Set_Monad xs2)\n   | Some eq \\<Rightarrow>\n       fold\n        (\\<lambda>(x, y).\n            fold\n             (\\<lambda>(y', z) A. if eq y y' then insert (x, z) A else A)\n             xs2)\n        xs1 {})\n  DList_set dxs3 O Set_Monad xs5 =\n  (case ID CEQ('e) of\n   None \\<Rightarrow>\n     Code.abort STR ''relcomp DList_set Set_Monad: ceq1 = None''\n      (\\<lambda>_. DList_set dxs3 O Set_Monad xs5)\n   | Some x \\<Rightarrow>\n       case ID CEQ('f) of\n       None \\<Rightarrow>\n         Code.abort STR ''relcomp DList_set Set_Monad: ceq2 = None''\n          (\\<lambda>_. DList_set dxs3 O Set_Monad xs5)\n       | Some eq \\<Rightarrow>\n           DList_Set.fold\n            (\\<lambda>(x, y).\n                fold\n                 (\\<lambda>(y', z) A.\n                     if eq y y' then insert (x, z) A else A)\n                 xs5)\n            dxs3 {})\n  Set_Monad xs6 O DList_set dxs4 =\n  (case ID CEQ('f) of\n   None \\<Rightarrow>\n     Code.abort STR ''relcomp Set_Monad DList_set: ceq1 = None''\n      (\\<lambda>_. Set_Monad xs6 O DList_set dxs4)\n   | Some eq \\<Rightarrow>\n       case ID CEQ('g) of\n       None \\<Rightarrow>\n         Code.abort STR ''relcomp Set_Monad DList_set: ceq2 = None''\n          (\\<lambda>_. Set_Monad xs6 O DList_set dxs4)\n       | Some x \\<Rightarrow>\n           fold\n            (\\<lambda>(x, y).\n                DList_Set.fold\n                 (\\<lambda>(y', z) A.\n                     if eq y y' then insert (x, z) A else A)\n                 dxs4)\n            xs6 {})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma irrefl_code [code]:\n  fixes r :: \"('a :: {ceq, ccompare} \\<times> 'a) set\" shows\n  \"irrefl r \\<longleftrightarrow> \n  (case ID CEQ('a) of Some eq \\<Rightarrow> (\\<forall>(x, y) \\<in> r. \\<not> eq x y) | None \\<Rightarrow>\n    case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''irrefl: ceq = None & ccompare = None'') (\\<lambda>_. irrefl r)\n                | Some c \\<Rightarrow> (\\<forall>(x, y) \\<in> r. c x y \\<noteq> Eq))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irrefl r =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       case ID ccompare of\n       None \\<Rightarrow>\n         Code.abort STR ''irrefl: ceq = None & ccompare = None''\n          (\\<lambda>_. irrefl r)\n       | Some c \\<Rightarrow> \\<forall>(x, y)\\<in>r. c x y \\<noteq> Eq\n     | Some eq \\<Rightarrow> \\<forall>(x, y)\\<in>r. \\<not> eq x y)", "apply(auto simp add: irrefl_distinct comparator.eq[OF ID_ccompare'] split: option.split dest!: ID_ceq[THEN equal.equal_eq])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wf_code [code]:\n  fixes rbt :: \"('a :: ccompare \\<times> 'a) set_rbt\" \n  and dxs :: \"('b :: ceq \\<times> 'b) set_dlist\" shows\n  \"wf (Set_Monad xs) = acyclic (Set_Monad xs)\"\n  \"wf (RBT_set rbt) = \n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''wf RBT_set: ccompare = None'') (\\<lambda>_. wf (RBT_set rbt))\n                     | Some _ \\<Rightarrow> acyclic (RBT_set rbt))\"\n  \"wf (DList_set dxs) =\n  (case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''wf DList_set: ceq = None'') (\\<lambda>_. wf (DList_set dxs))\n                     | Some _ \\<Rightarrow> acyclic (DList_set dxs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (Set_Monad xs) = acyclic (Set_Monad xs) &&&\n    wf (RBT_set rbt) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''wf RBT_set: ccompare = None''\n        (\\<lambda>_. wf (RBT_set rbt))\n     | Some x \\<Rightarrow> acyclic (RBT_set rbt)) &&&\n    wf (DList_set dxs) =\n    (case ID CEQ('b) of\n     None \\<Rightarrow>\n       Code.abort STR ''wf DList_set: ceq = None''\n        (\\<lambda>_. wf (DList_set dxs))\n     | Some x \\<Rightarrow> acyclic (DList_set dxs))", "by(auto simp add: wf_iff_acyclic_if_finite split: option.split del: iffI)(simp_all add: wf_iff_acyclic_if_finite finite_code ccompare_prod_def ceq_prod_def ID_Some)"], ["", "lemma bacc_code [code]:\n  \"bacc R 0 = - snd ` R\"\n  \"bacc R (Suc n) = (let rec = bacc R n in rec \\<union> - snd ` (Set.filter (\\<lambda>(y, x). y \\<notin> rec) R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bacc R 0 = - snd ` R &&&\n    bacc R (Suc n) =\n    (let rec = bacc R n\n     in rec \\<union> - snd ` Set.filter (\\<lambda>(y, x). y \\<notin> rec) R)", "by(auto intro: rev_image_eqI simp add: Let_def)"], ["", "(* TODO: acc could also be computed for infinite universes if r is finite *)"], ["", "lemma acc_code [code]:\n  fixes A :: \"('a :: {finite, card_UNIV} \\<times> 'a) set\" shows\n  \"Wellfounded.acc A = bacc A (of_phantom (card_UNIV :: 'a card_UNIV))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Wellfounded.acc A = bacc A (of_phantom card_UNIV_class.card_UNIV)", "by(simp add: card_UNIV acc_bacc_eq)"], ["", "lemma sorted_list_of_set_code [code]:\n  fixes dxs :: \"'a :: {linorder, ceq} set_dlist\"\n  and rbt :: \"'b :: {linorder, ccompare} set_rbt\"\n  shows\n  \"sorted_list_of_set (Set_Monad xs) = sort (remdups xs)\"\n  \"sorted_list_of_set (DList_set dxs) =\n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''sorted_list_of_set DList_set: ceq = None'') (\\<lambda>_. sorted_list_of_set (DList_set dxs))\n                  | Some _ \\<Rightarrow> sort (list_of_dlist dxs))\"\n  \"sorted_list_of_set (RBT_set rbt) =\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''sorted_list_of_set RBT_set: ccompare = None'') (\\<lambda>_. sorted_list_of_set (RBT_set rbt))\n                     | Some _ \\<Rightarrow> sort (RBT_Set2.keys rbt))\"\n  \\<comment> \\<open>We must sort the keys because @{term ccompare}'s ordering need not coincide with @{term linorder}'s.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_list_of_set (Set_Monad xs) = sort (remdups xs) &&&\n    sorted_list_of_set (DList_set dxs) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''sorted_list_of_set DList_set: ceq = None''\n        (\\<lambda>_. sorted_list_of_set (DList_set dxs))\n     | Some x \\<Rightarrow> sort (list_of_dlist dxs)) &&&\n    sorted_list_of_set (RBT_set rbt) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''sorted_list_of_set RBT_set: ccompare = None''\n        (\\<lambda>_. sorted_list_of_set (RBT_set rbt))\n     | Some x \\<Rightarrow> sort (RBT_Set2.keys rbt))", "by(auto simp add: DList_set_def RBT_set_def sorted_list_of_set_sort_remdups Collect_member distinct_remdups_id distinct_list_of_dlist member_conv_keys split: option.split)"], ["", "lemma map_project_set: \"List.map_project f (set xs) = set (List.map_filter f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.map_project f (set xs) = set (List.map_filter f xs)", "by(auto simp add: List.map_project_def List.map_filter_def intro: rev_image_eqI)"], ["", "lemma map_project_simps:\n  shows map_project_empty: \"List.map_project f {} = {}\"\n  and map_project_insert: \n  \"List.map_project f (insert x A) = \n  (case f x of None \\<Rightarrow> List.map_project f A \n   | Some y \\<Rightarrow> insert y (List.map_project f A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.map_project f {} = {} &&&\n    List.map_project f (insert x A) =\n    (case f x of None \\<Rightarrow> List.map_project f A\n     | Some y \\<Rightarrow> insert y (List.map_project f A))", "by(auto simp add: List.map_project_def split: option.split)"], ["", "lemma map_project_conv_fold: \n  \"List.map_project f (set xs) = \n   fold (\\<lambda>x A. case f x of None \\<Rightarrow> A | Some y \\<Rightarrow> insert y A) xs {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.map_project f (set xs) =\n    fold\n     (\\<lambda>x A.\n         case f x of None \\<Rightarrow> A | Some y \\<Rightarrow> insert y A)\n     xs {}", "by(induct xs rule: rev_induct)(simp_all add: map_project_simps cong: option.case_cong)"], ["", "lemma map_project_code [code]:\n  fixes dxs :: \"'a :: ceq set_dlist\" \n  and rbt :: \"'b :: ccompare set_rbt\" shows\n  \"List.map_project f (Set_Monad xs) = Set_Monad (List.map_filter f xs)\"\n  \"List.map_project g (DList_set dxs) = \n   (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''map_project DList_set: ceq = None'') (\\<lambda>_. List.map_project g (DList_set dxs))\n                   | Some _ \\<Rightarrow> DList_Set.fold (\\<lambda>x A. case g x of None \\<Rightarrow> A | Some y \\<Rightarrow> insert y A) dxs {})\"\n  (is ?dlist)\n  \"List.map_project h (RBT_set rbt) = \n   (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''map_project RBT_set: ccompare = None'') (\\<lambda>_. List.map_project h (RBT_set rbt))\n                      | Some _ \\<Rightarrow> RBT_Set2.fold (\\<lambda>x A. case h x of None \\<Rightarrow> A | Some y \\<Rightarrow> insert y A) rbt {})\"\n  (is ?rbt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. List.map_project f (Set_Monad xs) = Set_Monad (List.map_filter f xs) &&&\n    List.map_project g (DList_set dxs) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''map_project DList_set: ceq = None''\n        (\\<lambda>_. List.map_project g (DList_set dxs))\n     | Some x \\<Rightarrow>\n         DList_Set.fold\n          (\\<lambda>x A.\n              case g x of None \\<Rightarrow> A\n              | Some y \\<Rightarrow> insert y A)\n          dxs {}) &&&\n    List.map_project h (RBT_set rbt) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''map_project RBT_set: ccompare = None''\n        (\\<lambda>_. List.map_project h (RBT_set rbt))\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold\n          (\\<lambda>x A.\n              case h x of None \\<Rightarrow> A\n              | Some y \\<Rightarrow> insert y A)\n          rbt {})", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. List.map_project f (Set_Monad xs) = Set_Monad (List.map_filter f xs)\n 2. List.map_project g (DList_set dxs) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''map_project DList_set: ceq = None''\n        (\\<lambda>_. List.map_project g (DList_set dxs))\n     | Some x \\<Rightarrow>\n         DList_Set.fold\n          (\\<lambda>x A.\n              case g x of None \\<Rightarrow> A\n              | Some y \\<Rightarrow> insert y A)\n          dxs {})\n 3. List.map_project h (RBT_set rbt) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''map_project RBT_set: ccompare = None''\n        (\\<lambda>_. List.map_project h (RBT_set rbt))\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold\n          (\\<lambda>x A.\n              case h x of None \\<Rightarrow> A\n              | Some y \\<Rightarrow> insert y A)\n          rbt {})", "show ?dlist ?rbt"], ["proof (prove)\ngoal (1 subgoal):\n 1. List.map_project g (DList_set dxs) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''map_project DList_set: ceq = None''\n        (\\<lambda>_. List.map_project g (DList_set dxs))\n     | Some x \\<Rightarrow>\n         DList_Set.fold\n          (\\<lambda>x A.\n              case g x of None \\<Rightarrow> A\n              | Some y \\<Rightarrow> insert y A)\n          dxs {}) &&&\n    List.map_project h (RBT_set rbt) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''map_project RBT_set: ccompare = None''\n        (\\<lambda>_. List.map_project h (RBT_set rbt))\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold\n          (\\<lambda>x A.\n              case h x of None \\<Rightarrow> A\n              | Some y \\<Rightarrow> insert y A)\n          rbt {})", "by(auto split: option.split simp add: RBT_set_def DList_set_def DList_Set.fold.rep_eq Collect_member map_project_conv_fold RBT_Set2.fold_conv_fold_keys member_conv_keys del: equalityI)"], ["proof (state)\nthis:\n  List.map_project g (DList_set dxs) =\n  (case ID CEQ('a) of\n   None \\<Rightarrow>\n     Code.abort STR ''map_project DList_set: ceq = None''\n      (\\<lambda>_. List.map_project g (DList_set dxs))\n   | Some x \\<Rightarrow>\n       DList_Set.fold\n        (\\<lambda>x A.\n            case g x of None \\<Rightarrow> A\n            | Some y \\<Rightarrow> insert y A)\n        dxs {})\n  List.map_project h (RBT_set rbt) =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''map_project RBT_set: ccompare = None''\n      (\\<lambda>_. List.map_project h (RBT_set rbt))\n   | Some x \\<Rightarrow>\n       RBT_Set2.fold\n        (\\<lambda>x A.\n            case h x of None \\<Rightarrow> A\n            | Some y \\<Rightarrow> insert y A)\n        rbt {})\n\ngoal (1 subgoal):\n 1. List.map_project f (Set_Monad xs) = Set_Monad (List.map_filter f xs)", "qed(auto simp add: List.map_project_def List.map_filter_def intro: rev_image_eqI)"], ["", "lemma Bleast_code [code]:\n  \"Bleast A P = \n  (if finite A then case filter P (sorted_list_of_set A) of [] \\<Rightarrow> abort_Bleast A P | x # xs \\<Rightarrow> x \n   else abort_Bleast A P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Bleast A P =\n    (if finite A\n     then case filter P (sorted_list_of_set A) of\n          [] \\<Rightarrow> abort_Bleast A P | x # xs \\<Rightarrow> x\n     else abort_Bleast A P)", "proof(cases \"finite A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow>\n    Bleast A P =\n    (if finite A\n     then case filter P (sorted_list_of_set A) of\n          [] \\<Rightarrow> abort_Bleast A P | x # xs \\<Rightarrow> x\n     else abort_Bleast A P)\n 2. infinite A \\<Longrightarrow>\n    Bleast A P =\n    (if finite A\n     then case filter P (sorted_list_of_set A) of\n          [] \\<Rightarrow> abort_Bleast A P | x # xs \\<Rightarrow> x\n     else abort_Bleast A P)", "case True"], ["proof (state)\nthis:\n  finite A\n\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow>\n    Bleast A P =\n    (if finite A\n     then case filter P (sorted_list_of_set A) of\n          [] \\<Rightarrow> abort_Bleast A P | x # xs \\<Rightarrow> x\n     else abort_Bleast A P)\n 2. infinite A \\<Longrightarrow>\n    Bleast A P =\n    (if finite A\n     then case filter P (sorted_list_of_set A) of\n          [] \\<Rightarrow> abort_Bleast A P | x # xs \\<Rightarrow> x\n     else abort_Bleast A P)", "hence *: \"A = set (sorted_list_of_set A)\""], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. A = set (sorted_list_of_set A)", "by(simp add: sorted_list_of_set)"], ["proof (state)\nthis:\n  A = set (sorted_list_of_set A)\n\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow>\n    Bleast A P =\n    (if finite A\n     then case filter P (sorted_list_of_set A) of\n          [] \\<Rightarrow> abort_Bleast A P | x # xs \\<Rightarrow> x\n     else abort_Bleast A P)\n 2. infinite A \\<Longrightarrow>\n    Bleast A P =\n    (if finite A\n     then case filter P (sorted_list_of_set A) of\n          [] \\<Rightarrow> abort_Bleast A P | x # xs \\<Rightarrow> x\n     else abort_Bleast A P)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bleast A P =\n    (if finite A\n     then case filter P (sorted_list_of_set A) of\n          [] \\<Rightarrow> abort_Bleast A P | x # xs \\<Rightarrow> x\n     else abort_Bleast A P)", "using True"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. Bleast A P =\n    (if finite A\n     then case filter P (sorted_list_of_set A) of\n          [] \\<Rightarrow> abort_Bleast A P | x # xs \\<Rightarrow> x\n     else abort_Bleast A P)", "by(subst (1 3) *)(unfold Bleast_code, simp add: sorted_sort_id)"], ["proof (state)\nthis:\n  Bleast A P =\n  (if finite A\n   then case filter P (sorted_list_of_set A) of\n        [] \\<Rightarrow> abort_Bleast A P | x # xs \\<Rightarrow> x\n   else abort_Bleast A P)\n\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow>\n    Bleast A P =\n    (if finite A\n     then case filter P (sorted_list_of_set A) of\n          [] \\<Rightarrow> abort_Bleast A P | x # xs \\<Rightarrow> x\n     else abort_Bleast A P)", "qed(simp add: abort_Bleast_def Bleast_def)"], ["", "lemma can_select_code [code]:\n  fixes xs :: \"'a :: ceq list\" \n  and dxs :: \"'a :: ceq set_dlist\" \n  and rbt :: \"'b :: ccompare set_rbt\" shows\n  \"can_select P (Set_Monad xs) =\n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''can_select Set_Monad: ceq = None'') (\\<lambda>_. can_select P (Set_Monad xs))\n                 | Some eq \\<Rightarrow> case filter P xs of Nil \\<Rightarrow> False | x # xs \\<Rightarrow> list_all (eq x) xs)\"\n  (is ?Set_Monad)\n  \"can_select Q (DList_set dxs) =\n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''can_select DList_set: ceq = None'') (\\<lambda>_. can_select Q (DList_set dxs))\n                  | Some _ \\<Rightarrow> DList_Set.length (DList_Set.filter Q dxs) = 1)\"\n  (is ?dlist)\n  \"can_select R (RBT_set rbt) =\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''can_select RBT_set: ccompare = None'') (\\<lambda>_. can_select R (RBT_set rbt))\n                 | Some _ \\<Rightarrow> singleton_list_fusion (filter_generator R rbt_keys_generator) (RBT_Set2.init rbt))\"\n  (is ?rbt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. can_select P (Set_Monad xs) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''can_select Set_Monad: ceq = None''\n        (\\<lambda>_. can_select P (Set_Monad xs))\n     | Some eq \\<Rightarrow>\n         case filter P xs of [] \\<Rightarrow> False\n         | x # xs \\<Rightarrow> list_all (eq x) xs) &&&\n    can_select Q (DList_set dxs) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''can_select DList_set: ceq = None''\n        (\\<lambda>_. can_select Q (DList_set dxs))\n     | Some x \\<Rightarrow>\n         DList_Set.length (DList_Set.filter Q dxs) = 1) &&&\n    can_select R (RBT_set rbt) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''can_select RBT_set: ccompare = None''\n        (\\<lambda>_. can_select R (RBT_set rbt))\n     | Some x \\<Rightarrow>\n         singleton_list_fusion (filter_generator R rbt_keys_generator)\n          (RBT_Set2.init rbt))", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. can_select P (Set_Monad xs) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''can_select Set_Monad: ceq = None''\n        (\\<lambda>_. can_select P (Set_Monad xs))\n     | Some eq \\<Rightarrow>\n         case filter P xs of [] \\<Rightarrow> False\n         | x # xs \\<Rightarrow> list_all (eq x) xs)\n 2. can_select Q (DList_set dxs) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''can_select DList_set: ceq = None''\n        (\\<lambda>_. can_select Q (DList_set dxs))\n     | Some x \\<Rightarrow> DList_Set.length (DList_Set.filter Q dxs) = 1)\n 3. can_select R (RBT_set rbt) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''can_select RBT_set: ccompare = None''\n        (\\<lambda>_. can_select R (RBT_set rbt))\n     | Some x \\<Rightarrow>\n         singleton_list_fusion (filter_generator R rbt_keys_generator)\n          (RBT_Set2.init rbt))", "show ?Set_Monad"], ["proof (prove)\ngoal (1 subgoal):\n 1. can_select P (Set_Monad xs) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''can_select Set_Monad: ceq = None''\n        (\\<lambda>_. can_select P (Set_Monad xs))\n     | Some eq \\<Rightarrow>\n         case filter P xs of [] \\<Rightarrow> False\n         | x # xs \\<Rightarrow> list_all (eq x) xs)", "apply(auto split: option.split list.split dest!: ID_ceq[THEN equal.equal_eq] dest: filter_eq_ConsD simp add: can_select_def filter_empty_conv list_all_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>filter P xs = x21 # x22;\n        \\<forall>x\\<in>set x22. x21 = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x. x \\<in> set xs \\<and> P x\n 2. \\<And>x21 x22 x y.\n       \\<lbrakk>filter P xs = x21 # x22; \\<forall>x\\<in>set x22. x21 = x;\n        x \\<in> set xs; P x; y \\<in> set xs; P y\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply(drule filter_eq_ConsD, fastforce)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x y.\n       \\<lbrakk>filter P xs = x21 # x22; \\<forall>x\\<in>set x22. x21 = x;\n        x \\<in> set xs; P x; y \\<in> set xs; P y\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply(drule filter_eq_ConsD, clarsimp, blast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  can_select P (Set_Monad xs) =\n  (case ID CEQ('a) of\n   None \\<Rightarrow>\n     Code.abort STR ''can_select Set_Monad: ceq = None''\n      (\\<lambda>_. can_select P (Set_Monad xs))\n   | Some eq \\<Rightarrow>\n       case filter P xs of [] \\<Rightarrow> False\n       | x # xs \\<Rightarrow> list_all (eq x) xs)\n\ngoal (2 subgoals):\n 1. can_select Q (DList_set dxs) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''can_select DList_set: ceq = None''\n        (\\<lambda>_. can_select Q (DList_set dxs))\n     | Some x \\<Rightarrow> DList_Set.length (DList_Set.filter Q dxs) = 1)\n 2. can_select R (RBT_set rbt) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''can_select RBT_set: ccompare = None''\n        (\\<lambda>_. can_select R (RBT_set rbt))\n     | Some x \\<Rightarrow>\n         singleton_list_fusion (filter_generator R rbt_keys_generator)\n          (RBT_Set2.init rbt))", "show ?dlist"], ["proof (prove)\ngoal (1 subgoal):\n 1. can_select Q (DList_set dxs) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''can_select DList_set: ceq = None''\n        (\\<lambda>_. can_select Q (DList_set dxs))\n     | Some x \\<Rightarrow> DList_Set.length (DList_Set.filter Q dxs) = 1)", "by(clarsimp simp add: can_select_def card_eq_length[symmetric] Set_member_code card_eq_Suc_0_ex1 simp del: card_eq_length split: option.split)"], ["proof (state)\nthis:\n  can_select Q (DList_set dxs) =\n  (case ID CEQ('a) of\n   None \\<Rightarrow>\n     Code.abort STR ''can_select DList_set: ceq = None''\n      (\\<lambda>_. can_select Q (DList_set dxs))\n   | Some x \\<Rightarrow> DList_Set.length (DList_Set.filter Q dxs) = 1)\n\ngoal (1 subgoal):\n 1. can_select R (RBT_set rbt) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''can_select RBT_set: ccompare = None''\n        (\\<lambda>_. can_select R (RBT_set rbt))\n     | Some x \\<Rightarrow>\n         singleton_list_fusion (filter_generator R rbt_keys_generator)\n          (RBT_Set2.init rbt))", "note [simp del] = distinct_keys"], ["proof (state)\nthis:\n  ID ccompare \\<noteq> None \\<Longrightarrow> distinct (RBT_Set2.keys ?rbt)\n\ngoal (1 subgoal):\n 1. can_select R (RBT_set rbt) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''can_select RBT_set: ccompare = None''\n        (\\<lambda>_. can_select R (RBT_set rbt))\n     | Some x \\<Rightarrow>\n         singleton_list_fusion (filter_generator R rbt_keys_generator)\n          (RBT_Set2.init rbt))", "show ?rbt"], ["proof (prove)\ngoal (1 subgoal):\n 1. can_select R (RBT_set rbt) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''can_select RBT_set: ccompare = None''\n        (\\<lambda>_. can_select R (RBT_set rbt))\n     | Some x \\<Rightarrow>\n         singleton_list_fusion (filter_generator R rbt_keys_generator)\n          (RBT_Set2.init rbt))", "using distinct_keys[of rbt]"], ["proof (prove)\nusing this:\n  ID ccompare \\<noteq> None \\<Longrightarrow> distinct (RBT_Set2.keys rbt)\n\ngoal (1 subgoal):\n 1. can_select R (RBT_set rbt) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''can_select RBT_set: ccompare = None''\n        (\\<lambda>_. can_select R (RBT_set rbt))\n     | Some x \\<Rightarrow>\n         singleton_list_fusion (filter_generator R rbt_keys_generator)\n          (RBT_Set2.init rbt))", "apply(auto simp add: can_select_def singleton_list_fusion_def unfoldr_filter_generator unfoldr_rbt_keys_generator Set_member_code member_conv_keys filter_empty_conv empty_filter_conv split: option.split list.split dest: filter_eq_ConsD)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x21 x2.\n       \\<lbrakk>distinct (RBT_Set2.keys rbt);\n        filter R (RBT_Set2.keys rbt) = [x21]; ID ccompare = Some x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            x \\<in> set (RBT_Set2.keys rbt) \\<and> R x\n 2. \\<And>x21 x2 x y.\n       \\<lbrakk>distinct (RBT_Set2.keys rbt);\n        filter R (RBT_Set2.keys rbt) = [x21]; ID ccompare = Some x2;\n        x \\<in> set (RBT_Set2.keys rbt); R x;\n        y \\<in> set (RBT_Set2.keys rbt); R y\\<rbrakk>\n       \\<Longrightarrow> x = y\n 3. \\<And>x21 x21a x22a x2 x.\n       \\<lbrakk>distinct (RBT_Set2.keys rbt);\n        filter R (RBT_Set2.keys rbt) = x21 # x21a # x22a;\n        ID ccompare = Some x2;\n        \\<forall>y y'.\n           y \\<in> set (RBT_Set2.keys rbt) \\<and>\n           R y \\<and>\n           y' \\<in> set (RBT_Set2.keys rbt) \\<and> R y' \\<longrightarrow>\n           y = y';\n        x \\<in> set (RBT_Set2.keys rbt); R x\\<rbrakk>\n       \\<Longrightarrow> False", "apply(drule filter_eq_ConsD, fastforce)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x2 x y.\n       \\<lbrakk>distinct (RBT_Set2.keys rbt);\n        filter R (RBT_Set2.keys rbt) = [x21]; ID ccompare = Some x2;\n        x \\<in> set (RBT_Set2.keys rbt); R x;\n        y \\<in> set (RBT_Set2.keys rbt); R y\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x21 x21a x22a x2 x.\n       \\<lbrakk>distinct (RBT_Set2.keys rbt);\n        filter R (RBT_Set2.keys rbt) = x21 # x21a # x22a;\n        ID ccompare = Some x2;\n        \\<forall>y y'.\n           y \\<in> set (RBT_Set2.keys rbt) \\<and>\n           R y \\<and>\n           y' \\<in> set (RBT_Set2.keys rbt) \\<and> R y' \\<longrightarrow>\n           y = y';\n        x \\<in> set (RBT_Set2.keys rbt); R x\\<rbrakk>\n       \\<Longrightarrow> False", "apply(drule filter_eq_ConsD, fastforce simp add: empty_filter_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x21a x22a x2 x.\n       \\<lbrakk>distinct (RBT_Set2.keys rbt);\n        filter R (RBT_Set2.keys rbt) = x21 # x21a # x22a;\n        ID ccompare = Some x2;\n        \\<forall>y y'.\n           y \\<in> set (RBT_Set2.keys rbt) \\<and>\n           R y \\<and>\n           y' \\<in> set (RBT_Set2.keys rbt) \\<and> R y' \\<longrightarrow>\n           y = y';\n        x \\<in> set (RBT_Set2.keys rbt); R x\\<rbrakk>\n       \\<Longrightarrow> False", "apply(drule filter_eq_ConsD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x21a x22a x2 x.\n       \\<lbrakk>distinct (RBT_Set2.keys rbt); ID ccompare = Some x2;\n        \\<forall>y y'.\n           y \\<in> set (RBT_Set2.keys rbt) \\<and>\n           R y \\<and>\n           y' \\<in> set (RBT_Set2.keys rbt) \\<and> R y' \\<longrightarrow>\n           y = y';\n        x \\<in> set (RBT_Set2.keys rbt); R x;\n        \\<exists>us vs.\n           RBT_Set2.keys rbt = us @ x21 # vs \\<and>\n           (\\<forall>u\\<in>set us. \\<not> R u) \\<and>\n           R x21 \\<and> x21a # x22a = filter R vs\\<rbrakk>\n       \\<Longrightarrow> False", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x21a x22a x2 x us vs.\n       \\<lbrakk>ID ccompare = Some x2;\n        \\<forall>y y'.\n           (y = x21 \\<or> y \\<in> set us \\<or> y \\<in> set vs) \\<and>\n           R y \\<and>\n           (y' = x21 \\<or> y' \\<in> set us \\<or> y' \\<in> set vs) \\<and>\n           R y' \\<longrightarrow>\n           y = y';\n        x = x21 \\<or> x \\<in> set us \\<or> x \\<in> set vs; R x;\n        RBT_Set2.keys rbt = us @ x21 # vs;\n        \\<forall>u\\<in>set us. \\<not> R u; R x21; x21a # x22a = filter R vs;\n        distinct us; x21 \\<notin> set vs; distinct vs; x21 \\<notin> set us;\n        set us \\<inter> set vs = {}\\<rbrakk>\n       \\<Longrightarrow> False", "apply(drule Cons_eq_filterD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x21a x22a x2 x us vs.\n       \\<lbrakk>ID ccompare = Some x2;\n        \\<forall>y y'.\n           (y = x21 \\<or> y \\<in> set us \\<or> y \\<in> set vs) \\<and>\n           R y \\<and>\n           (y' = x21 \\<or> y' \\<in> set us \\<or> y' \\<in> set vs) \\<and>\n           R y' \\<longrightarrow>\n           y = y';\n        x = x21 \\<or> x \\<in> set us \\<or> x \\<in> set vs; R x;\n        RBT_Set2.keys rbt = us @ x21 # vs;\n        \\<forall>u\\<in>set us. \\<not> R u; R x21; distinct us;\n        x21 \\<notin> set vs; distinct vs; x21 \\<notin> set us;\n        set us \\<inter> set vs = {};\n        \\<exists>us vsa.\n           vs = us @ x21a # vsa \\<and>\n           (\\<forall>u\\<in>set us. \\<not> R u) \\<and>\n           R x21a \\<and> x22a = filter R vsa\\<rbrakk>\n       \\<Longrightarrow> False", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x21a x22a x2 x us vs usa vsa.\n       \\<lbrakk>ID ccompare = Some x2;\n        \\<forall>y y'.\n           (y = x21 \\<or>\n            y \\<in> set us \\<or> y \\<in> set (usa @ x21a # vsa)) \\<and>\n           R y \\<and>\n           (y' = x21 \\<or>\n            y' \\<in> set us \\<or> y' \\<in> set (usa @ x21a # vsa)) \\<and>\n           R y' \\<longrightarrow>\n           y = y';\n        x = x21 \\<or> x \\<in> set us \\<or> x \\<in> set (usa @ x21a # vsa);\n        R x; RBT_Set2.keys rbt = us @ x21 # usa @ x21a # vsa;\n        \\<forall>u\\<in>set us. \\<not> R u; R x21; distinct us;\n        x21 \\<notin> set (usa @ x21a # vsa); distinct (usa @ x21a # vsa);\n        x21 \\<notin> set us; set us \\<inter> set (usa @ x21a # vsa) = {};\n        \\<forall>u\\<in>set usa. \\<not> R u; R x21a\\<rbrakk>\n       \\<Longrightarrow> False", "apply(simp (no_asm_use))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x21a x2 x us usa vsa.\n       \\<lbrakk>ID ccompare = Some x2;\n        \\<forall>y y'.\n           (y = x21 \\<or>\n            y \\<in> set us \\<or>\n            y = x21a \\<or> y \\<in> set usa \\<or> y \\<in> set vsa) \\<and>\n           R y \\<and>\n           (y' = x21 \\<or>\n            y' \\<in> set us \\<or>\n            y' = x21a \\<or> y' \\<in> set usa \\<or> y' \\<in> set vsa) \\<and>\n           R y' \\<longrightarrow>\n           y = y';\n        x = x21 \\<or>\n        x \\<in> set us \\<or>\n        x = x21a \\<or> x \\<in> set usa \\<or> x \\<in> set vsa;\n        R x; RBT_Set2.keys rbt = us @ x21 # usa @ x21a # vsa;\n        \\<forall>u\\<in>set us. \\<not> R u; R x21; distinct us;\n        x21 \\<noteq> x21a \\<and>\n        x21 \\<notin> set usa \\<and> x21 \\<notin> set vsa;\n        distinct usa \\<and>\n        x21a \\<notin> set vsa \\<and>\n        distinct vsa \\<and>\n        x21a \\<notin> set usa \\<and> set usa \\<inter> set vsa = {};\n        x21 \\<notin> set us;\n        x21a \\<notin> set us \\<and>\n        set us \\<inter> (set usa \\<union> set vsa) = {};\n        \\<forall>u\\<in>set usa. \\<not> R u; R x21a\\<rbrakk>\n       \\<Longrightarrow> False", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  can_select R (RBT_set rbt) =\n  (case ID ccompare of\n   None \\<Rightarrow>\n     Code.abort STR ''can_select RBT_set: ccompare = None''\n      (\\<lambda>_. can_select R (RBT_set rbt))\n   | Some x \\<Rightarrow>\n       singleton_list_fusion (filter_generator R rbt_keys_generator)\n        (RBT_Set2.init rbt))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pred_of_set_code [code]:\n  fixes dxs :: \"'a :: ceq set_dlist\" \n  and rbt :: \"'b :: ccompare set_rbt\" shows\n  \"pred_of_set (Set_Monad xs) = fold (sup \\<circ> Predicate.single) xs bot\"\n  \"pred_of_set (DList_set dxs) =\n   (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''pred_of_set DList_set: ceq = None'') (\\<lambda>_. pred_of_set (DList_set dxs))\n                   | Some _ \\<Rightarrow> DList_Set.fold (sup \\<circ> Predicate.single) dxs bot)\"\n  \"pred_of_set (RBT_set rbt) =\n   (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''pred_of_set RBT_set: ccompare = None'') (\\<lambda>_. pred_of_set (RBT_set rbt))\n                      | Some _ \\<Rightarrow> RBT_Set2.fold (sup \\<circ> Predicate.single) rbt bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_of_set (Set_Monad xs) =\n    fold (sup \\<circ> Predicate.single) xs bot &&&\n    pred_of_set (DList_set dxs) =\n    (case ID CEQ('a) of\n     None \\<Rightarrow>\n       Code.abort STR ''pred_of_set DList_set: ceq = None''\n        (\\<lambda>_. pred_of_set (DList_set dxs))\n     | Some x \\<Rightarrow>\n         DList_Set.fold (sup \\<circ> Predicate.single) dxs bot) &&&\n    pred_of_set (RBT_set rbt) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''pred_of_set RBT_set: ccompare = None''\n        (\\<lambda>_. pred_of_set (RBT_set rbt))\n     | Some x \\<Rightarrow>\n         RBT_Set2.fold (sup \\<circ> Predicate.single) rbt bot)", "by(auto simp add: pred_of_set_set_fold_sup fold_map DList_set_def RBT_set_def Collect_member member_conv_keys DList_Set.fold.rep_eq fold_conv_fold_keys split: option.split)"], ["", "text \\<open>\n  @{typ \"'a Predicate.pred\"} is implemented as a monad, \n  so we keep the monad when converting to @{typ \"'a set\"}. \n  For this case, @{term insert_monad} and @{term union_monad} \n  avoid the unnecessary dictionary construction.\n\\<close>"], ["", "definition insert_monad :: \"'a \\<Rightarrow> 'a set \\<Rightarrow> 'a set\"\nwhere [simp]: \"insert_monad = insert\""], ["", "definition union_monad :: \"'a set \\<Rightarrow> 'a set \\<Rightarrow> 'a set\"\nwhere [simp]: \"union_monad = (\\<union>)\""], ["", "lemma insert_monad_code [code]:\n  \"insert_monad x (Set_Monad xs) = Set_Monad (x # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_monad x (Set_Monad xs) = Set_Monad (x # xs)", "by simp"], ["", "lemma union_monad_code [code]:\n  \"union_monad (Set_Monad xs) (Set_Monad ys) = Set_Monad (xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. union_monad (Set_Monad xs) (Set_Monad ys) = Set_Monad (xs @ ys)", "by(simp)"], ["", "lemma set_of_pred_code [code]:\n  \"set_of_pred (Predicate.Seq f) = \n  (case f () of seq.Empty \\<Rightarrow> Set_Monad []\n   | seq.Insert x P \\<Rightarrow> insert_monad x (set_of_pred P)\n   | seq.Join P xq \\<Rightarrow> union_monad (set_of_pred P) (set_of_seq xq))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_of_pred (Predicate.Seq f) =\n    (case f () of seq.Empty \\<Rightarrow> Set_Monad []\n     | seq.Insert x P \\<Rightarrow> insert_monad x (set_of_pred P)\n     | seq.Join P xq \\<Rightarrow>\n         union_monad (set_of_pred P) (set_of_seq xq))", "by(simp add: of_pred_code cong: seq.case_cong)"], ["", "lemma set_of_seq_code [code]:\n  \"set_of_seq seq.Empty = Set_Monad []\"\n  \"set_of_seq (seq.Insert x P) = insert_monad x (set_of_pred P)\"\n  \"set_of_seq (seq.Join P xq) = union_monad (set_of_pred P) (set_of_seq xq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_of_seq seq.Empty = Set_Monad [] &&&\n    set_of_seq (seq.Insert x P) = insert_monad x (set_of_pred P) &&&\n    set_of_seq (seq.Join P xq) = union_monad (set_of_pred P) (set_of_seq xq)", "by(simp_all add: of_seq_code)"], ["", "hide_const (open) insert_monad union_monad"], ["", "subsection \\<open>Type class instantiations\\<close>"], ["", "datatype set_impl = Set_IMPL"], ["", "declare\n  set_impl.eq.simps [code del]\n  set_impl.size [code del]\n  set_impl.rec [code del]\n  set_impl.case [code del]"], ["", "lemma [code]: \n  fixes x :: set_impl\n  shows \"size x = 0\"\n  and \"size_set_impl x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size x = 0 &&& size_set_impl x = 0", "by(case_tac [!] x) simp_all"], ["", "definition set_Choose :: set_impl where [simp]: \"set_Choose = Set_IMPL\""], ["", "definition set_Collect :: set_impl where [simp]: \"set_Collect = Set_IMPL\""], ["", "definition set_DList :: set_impl where [simp]: \"set_DList = Set_IMPL\""], ["", "definition set_RBT :: set_impl where [simp]: \"set_RBT = Set_IMPL\""], ["", "definition set_Monad :: set_impl where [simp]: \"set_Monad = Set_IMPL\""], ["", "code_datatype set_Choose set_Collect set_DList set_RBT set_Monad"], ["", "definition set_empty_choose :: \"'a set\" where [simp]: \"set_empty_choose = {}\""], ["", "lemma set_empty_choose_code [code]:\n  \"(set_empty_choose :: 'a :: {ceq, ccompare} set) =\n   (case CCOMPARE('a) of Some _  \\<Rightarrow> RBT_set RBT_Set2.empty\n    | None \\<Rightarrow> case CEQ('a) of None \\<Rightarrow> Set_Monad [] | Some _ \\<Rightarrow> DList_set (DList_Set.empty))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_empty_choose =\n    (case ccompare of\n     None \\<Rightarrow>\n       case CEQ('a) of None \\<Rightarrow> Set_Monad []\n       | Some x \\<Rightarrow> DList_set DList_Set.empty\n     | Some x \\<Rightarrow> RBT_set RBT_Set2.empty)", "by(simp split: option.split)"], ["", "definition set_impl_choose2 :: \"set_impl \\<Rightarrow> set_impl \\<Rightarrow> set_impl\"\nwhere [simp]: \"set_impl_choose2 = (\\<lambda>_ _. Set_IMPL)\""], ["", "lemma set_impl_choose2_code [code]:\n  \"set_impl_choose2 x y = set_Choose\"\n  \"set_impl_choose2 set_Collect set_Collect = set_Collect\"\n  \"set_impl_choose2 set_DList set_DList = set_DList\"\n  \"set_impl_choose2 set_RBT set_RBT = set_RBT\"\n  \"set_impl_choose2 set_Monad set_Monad = set_Monad\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set_impl_choose2 x y = set_Choose &&&\n     set_impl_choose2 set_Collect set_Collect = set_Collect) &&&\n    set_impl_choose2 set_DList set_DList = set_DList &&&\n    set_impl_choose2 set_RBT set_RBT = set_RBT &&&\n    set_impl_choose2 set_Monad set_Monad = set_Monad", "by(simp_all)"], ["", "definition set_empty :: \"set_impl \\<Rightarrow> 'a set\"\nwhere [simp]: \"set_empty = (\\<lambda>_. {})\""], ["", "lemma set_empty_code [code]:\n  \"set_empty set_Collect = Collect_set (\\<lambda>_. False)\"\n  \"set_empty set_DList = DList_set DList_Set.empty\"\n  \"set_empty set_RBT = RBT_set RBT_Set2.empty\"\n  \"set_empty set_Monad = Set_Monad []\"\n  \"set_empty set_Choose = set_empty_choose\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set_empty set_Collect = Collect_set (\\<lambda>_. False) &&&\n     set_empty set_DList = DList_set DList_Set.empty) &&&\n    set_empty set_RBT = RBT_set RBT_Set2.empty &&&\n    set_empty set_Monad = Set_Monad [] &&&\n    set_empty set_Choose = set_empty_choose", "by(simp_all)"], ["", "class set_impl =\n  fixes set_impl :: \"('a, set_impl) phantom\""], ["", "syntax (input)\n  \"_SET_IMPL\" :: \"type => logic\"  (\"(1SET'_IMPL/(1'(_')))\")"], ["", "parse_translation \\<open>\nlet\n  fun set_impl_tr [ty] =\n     (Syntax.const @{syntax_const \"_constrain\"} $ Syntax.const @{const_syntax \"set_impl\"} $\n       (Syntax.const @{type_syntax phantom} $ ty $ Syntax.const @{type_syntax set_impl}))\n    | set_impl_tr ts = raise TERM (\"set_impl_tr\", ts);\nin [(@{syntax_const \"_SET_IMPL\"}, K set_impl_tr)] end\n\\<close>"], ["", "declare [[code drop: \"{}\"]]"], ["", "lemma empty_code [code, code_unfold]: \n  \"({} :: 'a :: set_impl set) = set_empty (of_phantom SET_IMPL('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} = set_empty (of_phantom set_impl)", "by simp"], ["", "subsection \\<open>Generator for the @{class set_impl}-class\\<close>"], ["", "text \\<open>\nThis generator registers itself at the derive-manager for the classes @{class set_impl}.\nHere, one can choose\nthe desired implementation via the parameter.\n\n\\begin{itemize}\n\\item \\texttt{instantiation type :: (type,\\ldots,type) (rbt,dlist,collect,monad,choose, or arbitrary constant name) set-impl}\n\\end{itemize}\n\\<close>"], ["", "text \\<open>\nThis generator can be used for arbitrary types, not just datatypes. \n\\<close>"], ["", "ML_file \\<open>set_impl_generator.ML\\<close>"], ["", "derive (dlist) set_impl unit bool"], ["", "derive (rbt) set_impl nat"], ["", "derive (set_RBT) set_impl int"], ["", "(* shows usage of constant names *)"], ["", "derive (dlist) set_impl Enum.finite_1 Enum.finite_2 Enum.finite_3"], ["", "derive (rbt) set_impl integer natural"], ["", "derive (rbt) set_impl char"], ["", "instantiation sum :: (set_impl, set_impl) set_impl begin"], ["", "definition \"SET_IMPL('a + 'b) = Phantom('a + 'b) \n  (set_impl_choose2 (of_phantom SET_IMPL('a)) (of_phantom SET_IMPL('b)))\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a + 'b, set_impl_class)", ".."], ["", "end"], ["", "instantiation prod :: (set_impl, set_impl) set_impl begin"], ["", "definition \"SET_IMPL('a * 'b) = Phantom('a * 'b) \n  (set_impl_choose2 (of_phantom SET_IMPL('a)) (of_phantom SET_IMPL('b)))\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<times> 'b, set_impl_class)", ".."], ["", "end"], ["", "derive (choose) set_impl list"], ["", "derive (rbt) set_impl String.literal"], ["", "instantiation option :: (set_impl) set_impl begin"], ["", "definition \"SET_IMPL('a option) = Phantom('a option) (of_phantom SET_IMPL('a))\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a option, set_impl_class)", ".."], ["", "end"], ["", "derive (monad) set_impl \"fun\""], ["", "derive (choose) set_impl set"], ["", "instantiation phantom :: (type, set_impl) set_impl begin"], ["", "definition \"SET_IMPL(('a, 'b) phantom) = Phantom (('a, 'b) phantom) (of_phantom SET_IMPL('b))\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) phantom, set_impl_class)", ".."], ["", "end"], ["", "text \\<open>\n  We enable automatic implementation selection for sets constructed by @{const set},\n  although they could be directly converted using @{const Set_Monad} in constant time.\n  However, then it is more likely that the parameters of binary operators have \n  different implementations, which can lead to less efficient execution.\n\n  However, we test whether automatic selection picks @{const Set_Monad} anyway and\n  take a short-cut.\n\\<close>"], ["", "definition set_aux :: \"set_impl \\<Rightarrow> 'a list \\<Rightarrow> 'a set\"\nwhere [simp, code del]: \"set_aux _ = set\""], ["", "lemma set_aux_code [code]:\n  defines \"conv \\<equiv> foldl (\\<lambda>s (x :: 'a). insert x s)\"\n  shows\n  \"set_aux impl = conv (set_empty impl)\" (is \"?thesis1\")\n  \"set_aux set_Choose = \n   (case CCOMPARE('a :: {ccompare, ceq}) of Some _  \\<Rightarrow> conv (RBT_set RBT_Set2.empty)\n    | None \\<Rightarrow> case CEQ('a) of None \\<Rightarrow> Set_Monad\n              | Some _ \\<Rightarrow> conv (DList_set DList_Set.empty))\" (is \"?thesis2\")\n  \"set_aux set_Monad = Set_Monad\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_aux impl = conv (set_empty impl) &&&\n    set_aux set_Choose =\n    (case ccompare of\n     None \\<Rightarrow>\n       case CEQ('a) of None \\<Rightarrow> Set_Monad\n       | Some x \\<Rightarrow> conv (DList_set DList_Set.empty)\n     | Some x \\<Rightarrow> conv (RBT_set RBT_Set2.empty)) &&&\n    set_aux set_Monad = Set_Monad", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. set_aux impl = conv (set_empty impl)\n 2. set_aux set_Choose =\n    (case ccompare of\n     None \\<Rightarrow>\n       case CEQ('a) of None \\<Rightarrow> Set_Monad\n       | Some x \\<Rightarrow> conv (DList_set DList_Set.empty)\n     | Some x \\<Rightarrow> conv (RBT_set RBT_Set2.empty))\n 3. set_aux set_Monad = Set_Monad", "have \"conv {} = set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conv {} = set", "by(rule ext)(induct_tac x rule: rev_induct, simp_all add: conv_def)"], ["proof (state)\nthis:\n  conv {} = set\n\ngoal (3 subgoals):\n 1. set_aux impl = conv (set_empty impl)\n 2. set_aux set_Choose =\n    (case ccompare of\n     None \\<Rightarrow>\n       case CEQ('a) of None \\<Rightarrow> Set_Monad\n       | Some x \\<Rightarrow> conv (DList_set DList_Set.empty)\n     | Some x \\<Rightarrow> conv (RBT_set RBT_Set2.empty))\n 3. set_aux set_Monad = Set_Monad", "thus ?thesis1 ?thesis2"], ["proof (prove)\nusing this:\n  conv {} = set\n\ngoal (1 subgoal):\n 1. set_aux impl = conv (set_empty impl) &&&\n    set_aux set_Choose =\n    (case ccompare of\n     None \\<Rightarrow>\n       case CEQ('a) of None \\<Rightarrow> Set_Monad\n       | Some x \\<Rightarrow> conv (DList_set DList_Set.empty)\n     | Some x \\<Rightarrow> conv (RBT_set RBT_Set2.empty))", "by(simp_all split: option.split)"], ["proof (state)\nthis:\n  set_aux impl = conv (set_empty impl)\n  set_aux set_Choose =\n  (case ccompare of\n   None \\<Rightarrow>\n     case CEQ('a) of None \\<Rightarrow> Set_Monad\n     | Some x \\<Rightarrow> conv (DList_set DList_Set.empty)\n   | Some x \\<Rightarrow> conv (RBT_set RBT_Set2.empty))\n\ngoal (1 subgoal):\n 1. set_aux set_Monad = Set_Monad", "qed simp"], ["", "lemma set_code [code]:\n  fixes xs :: \"'a :: set_impl list\"\n  shows \"set xs = set_aux (of_phantom (ID SET_IMPL('a))) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs = set_aux (of_phantom (ID set_impl)) xs", "by(simp)"], ["", "subsection \\<open>Pretty printing for sets\\<close>"], ["", "text \\<open>\n  @{term code_post} marks contexts (as hypothesis) in which we use code\\_post as a\n  decision procedure rather than a pretty-printing engine. \n  The intended use is to enable more rules when proving assumptions of rewrite rules.\n\\<close>"], ["", "definition code_post :: bool where \"code_post = True\""], ["", "lemma conj_code_post [code_post]: \n  assumes code_post\n  shows \"True & x \\<longleftrightarrow> x\" \"False & x \\<longleftrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (True \\<and> x) = x &&& (False \\<and> x) = False", "by simp_all"], ["", "text \\<open>\n  A flag to switch post-processing of sets on and off.\n  Use \\verb$declare pretty_sets[code_post del]$ to disable pretty printing of sets in value.\n\\<close>"], ["", "definition code_post_set :: bool\nwhere pretty_sets [code_post, simp]: \"code_post_set = True\""], ["", "definition collapse_RBT_set :: \"'a set_rbt \\<Rightarrow> 'a :: ccompare set \\<Rightarrow> 'a set\"\nwhere \"collapse_RBT_set r M = set (RBT_Set2.keys r) \\<union> M\""], ["", "lemma RBT_set_collapse_RBT_set [code_post]:\n  fixes r :: \"'a :: ccompare set_rbt\"\n  assumes \"code_post \\<Longrightarrow> is_ccompare TYPE('a)\" and code_post_set\n  shows \"RBT_set r = collapse_RBT_set r {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RBT_set r = collapse_RBT_set r {}", "using assms"], ["proof (prove)\nusing this:\n  code_post \\<Longrightarrow> is_ccompare TYPE('a)\n  code_post_set\n\ngoal (1 subgoal):\n 1. RBT_set r = collapse_RBT_set r {}", "by(clarsimp simp add: code_post_def is_ccompare_def RBT_set_def member_conv_keys collapse_RBT_set_def)"], ["", "lemma collapse_RBT_set_Branch [code_post]: \n  \"collapse_RBT_set (Mapping_RBT (Branch c l x v r)) M =\n   collapse_RBT_set (Mapping_RBT l) (insert x (collapse_RBT_set (Mapping_RBT r) M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collapse_RBT_set (Mapping_RBT (Branch c l x v r)) M =\n    collapse_RBT_set (Mapping_RBT l)\n     (insert x (collapse_RBT_set (Mapping_RBT r) M))", "unfolding collapse_RBT_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (RBT_Set2.keys (Mapping_RBT (Branch c l x v r))) \\<union> M =\n    set (RBT_Set2.keys (Mapping_RBT l)) \\<union>\n    insert x (set (RBT_Set2.keys (Mapping_RBT r)) \\<union> M)", "by(auto simp add: is_ccompare_def set_keys_Mapping_RBT)"], ["", "lemma collapse_RBT_set_Empty [code_post]: \n  \"collapse_RBT_set (Mapping_RBT rbt.Empty) M = M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collapse_RBT_set (Mapping_RBT rbt.Empty) M = M", "by(auto simp add: collapse_RBT_set_def set_keys_Mapping_RBT)"], ["", "definition collapse_DList_set :: \"'a :: ceq set_dlist \\<Rightarrow> 'a set\"\nwhere \"collapse_DList_set dxs = set (DList_Set.list_of_dlist dxs)\""], ["", "lemma DList_set_collapse_DList_set [code_post]:\n  fixes dxs :: \"'a :: ceq set_dlist\"\n  assumes \"code_post \\<Longrightarrow> is_ceq TYPE('a)\" and code_post_set\n  shows \"DList_set dxs = collapse_DList_set dxs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DList_set dxs = collapse_DList_set dxs", "using assms"], ["proof (prove)\nusing this:\n  code_post \\<Longrightarrow> is_ceq TYPE('a)\n  code_post_set\n\ngoal (1 subgoal):\n 1. DList_set dxs = collapse_DList_set dxs", "by(clarsimp simp add: code_post_def DList_set_def is_ceq_def collapse_DList_set_def Collect_member)"], ["", "lemma collapse_DList_set_empty [code_post]: \"collapse_DList_set (Abs_dlist []) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collapse_DList_set (Abs_dlist []) = {}", "by(simp add: collapse_DList_set_def Abs_dlist_inverse)"], ["", "lemma collapse_DList_set_Cons [code_post]: \n  \"collapse_DList_set (Abs_dlist (x # xs)) = insert x (collapse_DList_set (Abs_dlist xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collapse_DList_set (Abs_dlist (x # xs)) =\n    insert x (collapse_DList_set (Abs_dlist xs))", "by(simp add: collapse_DList_set_def set_list_of_dlist_Abs_dlist)"], ["", "lemma Set_Monad_code_post [code_post]:\n  assumes code_post_set\n  shows \"Set_Monad [] = {}\"\n  and \"Set_Monad (x#xs) = insert x (Set_Monad xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Set_Monad [] = {} &&& Set_Monad (x # xs) = insert x (Set_Monad xs)", "by simp_all"], ["", "end"]]}