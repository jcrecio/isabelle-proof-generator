{"file_name": "/home/qj213/afp-2021-10-22/thys/Containers/RBT_Mapping2.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Containers", "problem_names": ["lemma distinct_map_filterI: \"distinct (map f xs) \\<Longrightarrow> distinct (map f (filter P xs))\"", "lemma map_of_filter_apply:\n  \"distinct (map fst xs)\n  \\<Longrightarrow> map_of (filter P xs) k = \n  (case map_of xs k of None \\<Rightarrow> None | Some v \\<Rightarrow> if P (k, v) then Some v else None)\"", "lemma Mapping_RBT_inverse:\n  fixes y :: \"('a :: ccompare, 'b) rbt\"\n  assumes \"y \\<in> {t. ord.is_rbt cless t \\<or> ID CCOMPARE('a) = None}\"\n  shows \"impl_of (Mapping_RBT y) = y\"", "lemma impl_of_inverse: \"Mapping_RBT (impl_of t) = t\"", "lemma type_definition_mapping_rbt': \n  \"type_definition impl_of Mapping_RBT \n    {t :: ('a, 'b) rbt. ord.is_rbt cless t \\<or> ID CCOMPARE('a :: ccompare) = None}\"", "lemmas Mapping_RBT_cases[cases type: mapping_rbt] = \n  type_definition.Abs_cases[OF type_definition_mapping_rbt'] \n  and Mapping_RBT_induct[induct type: mapping_rbt] =\n  type_definition.Abs_induct[OF type_definition_mapping_rbt'] and\n  Mapping_RBT_inject = type_definition.Abs_inject[OF type_definition_mapping_rbt']", "lemma rbt_eq_iff:\n  \"t1 = t2 \\<longleftrightarrow> impl_of t1 = impl_of t2\"", "lemma rbt_eqI:\n  \"impl_of t1 = impl_of t2 \\<Longrightarrow> t1 = t2\"", "lemma Mapping_RBT_impl_of [simp]:\n  \"Mapping_RBT (impl_of t) = t\"", "lemma unfoldr_rbt_entries_generator:\n  \"list.unfoldr rbt_entries_generator (init t) = entries t\"", "lemma lookup_RBT:\n  \"ord.is_rbt cless t \\<Longrightarrow>\n  lookup (Mapping_RBT t) = rbt_comp_lookup ccomp t\"", "lemma lookup_impl_of:\n  \"rbt_comp_lookup ccomp (impl_of t) = lookup t\"", "lemma entries_impl_of:\n  \"RBT_Impl.entries (impl_of t) = entries t\"", "lemma keys_impl_of:\n  \"set (RBT_Impl.keys (impl_of t)) = keys t\"", "lemma lookup_empty [simp]:\n  \"lookup empty = Map.empty\"", "lemma fold_conv_fold:\n  \"fold f t = List.fold (case_prod f) (entries t)\"", "lemma is_empty_empty [simp]:\n  \"is_empty t \\<longleftrightarrow> t = empty\"", "lemma mapping_linorder: \"class.linorder (cless_eq :: 'a \\<Rightarrow> 'a \\<Rightarrow> bool) cless\"", "lemma mapping_comparator: \"comparator (ccomp :: 'a comparator)\"", "lemmas rbt_comp[simp] = rbt_comp_simps[OF mapping_comparator]", "lemma is_rbt_impl_of [simp, intro]:\n  fixes t :: \"('a, 'b) mapping_rbt\"\n  shows \"ord.is_rbt cless (impl_of t)\"", "lemma lookup_insert [simp]:\n  \"lookup (insert (k :: 'a) v t) = (lookup t)(k \\<mapsto> v)\"", "lemma lookup_delete [simp]:\n  \"lookup (delete (k :: 'a) t) = (lookup t)(k := None)\"", "lemma map_of_entries [simp]:\n  \"map_of (entries (t :: ('a, 'b) mapping_rbt)) = lookup t\"", "lemma entries_lookup:\n  \"entries (t1 :: ('a, 'b) mapping_rbt) = entries t2 \\<longleftrightarrow> lookup t1 = lookup t2\"", "lemma lookup_bulkload [simp]:\n  \"lookup (bulkload xs) = map_of (xs :: ('a \\<times> 'b) list)\"", "lemma lookup_map_entry [simp]:\n  \"lookup (map_entry (k :: 'a) f t) = (lookup t)(k := map_option f (lookup t k))\"", "lemma lookup_map [simp]:\n  \"lookup (map f t) (k :: 'a) = map_option (f k) (lookup t k)\"", "lemma RBT_lookup_empty [simp]:\n  \"ord.rbt_lookup cless (t :: ('a, 'b) RBT_Impl.rbt) = Map.empty \\<longleftrightarrow> t = RBT_Impl.Empty\"", "lemma lookup_empty_empty [simp]:\n  \"lookup t = Map.empty \\<longleftrightarrow> (t :: ('a, 'b) mapping_rbt) = empty\"", "lemma finite_dom_lookup [simp]: \"finite (dom (lookup (t :: ('a, 'b) mapping_rbt)))\"", "lemma card_com_lookup [unfolded length_map, simp]:\n  \"card (dom (lookup (t :: ('a, 'b) mapping_rbt))) = length (List.map fst (entries t))\"", "lemma lookup_join:\n  \"lookup (join f (t1 :: ('a, 'b) mapping_rbt) t2) =\n  (\\<lambda>k. case lookup t1 k of None \\<Rightarrow> lookup t2 k | Some v1 \\<Rightarrow> Some (case lookup t2 k of None \\<Rightarrow> v1 | Some v2 \\<Rightarrow> f k v1 v2))\"", "lemma lookup_meet:\n  \"lookup (meet f (t1 :: ('a, 'b) mapping_rbt) t2) =\n  (\\<lambda>k. case lookup t1 k of None \\<Rightarrow> None | Some v1 \\<Rightarrow> case lookup t2 k of None \\<Rightarrow> None | Some v2 \\<Rightarrow> Some (f k v1 v2))\"", "lemma lookup_filter [simp]:\n  \"lookup (filter P (t :: ('a, 'b) mapping_rbt)) k = \n  (case lookup t k of None \\<Rightarrow> None | Some v \\<Rightarrow> if P (k, v) then Some v else None)\"", "lemma all_conv_all_lookup:\n  \"all P t \\<longleftrightarrow> (\\<forall>(k :: 'a) v. lookup t k = Some v \\<longrightarrow> P k v)\"", "lemma ex_conv_ex_lookup:\n  \"ex P t \\<longleftrightarrow> (\\<exists>(k :: 'a) v. lookup t k = Some v \\<and> P k v)\"", "lemma diag_lookup:\n  \"lookup (diag t) = (\\<lambda>(k :: 'a, k'). if k = k' then lookup t k else None)\"", "lemma mapping_linorder': \"class.linorder (cless_eq :: 'b \\<Rightarrow> 'b \\<Rightarrow> bool) cless\"", "lemma mapping_comparator': \"comparator (ccomp :: 'b comparator)\"", "lemmas rbt_comp'[simp] = rbt_comp_simps[OF mapping_comparator']", "lemma ccomp_comparator_prod:\n  \"ccomp = (comparator_prod ccomp ccomp :: ('a \\<times> 'b)comparator)\"", "lemma lookup_product: \n  \"lookup (product f rbt1 rbt2) (a :: 'a, b :: 'b) = \n  (case lookup rbt1 a of None \\<Rightarrow> None\n   | Some c \\<Rightarrow> map_option (f a c b) (lookup rbt2 b))\""], "translations": [["", "lemma distinct_map_filterI: \"distinct (map f xs) \\<Longrightarrow> distinct (map f (filter P xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map f xs) \\<Longrightarrow> distinct (map f (filter P xs))", "by(induct xs) auto"], ["", "lemma map_of_filter_apply:\n  \"distinct (map fst xs)\n  \\<Longrightarrow> map_of (filter P xs) k = \n  (case map_of xs k of None \\<Rightarrow> None | Some v \\<Rightarrow> if P (k, v) then Some v else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst xs) \\<Longrightarrow>\n    map_of (filter P xs) k =\n    (case map_of xs k of None \\<Rightarrow> None\n     | Some v \\<Rightarrow> if P (k, v) then Some v else None)", "by(induct xs)(auto simp add: map_of_eq_None_iff split: option.split)"], ["", "subsection \\<open>Type definition\\<close>"], ["", "typedef (overloaded) ('a, 'b) mapping_rbt\n  = \"{t :: ('a :: ccompare, 'b) RBT_Impl.rbt. ord.is_rbt cless t \\<or> ID CCOMPARE('a) = None}\"\n  morphisms impl_of Mapping_RBT'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {t. ord.is_rbt cless t \\<or> ID ccompare = None}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. ?x \\<in> {t. ord.is_rbt cless t \\<or> ID ccompare = None}", "show \"RBT_Impl.Empty \\<in> ?mapping_rbt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt.Empty \\<in> {t. ord.is_rbt cless t \\<or> ID ccompare = None}", "by(simp add: ord.Empty_is_rbt)"], ["proof (state)\nthis:\n  rbt.Empty \\<in> {t. ord.is_rbt cless t \\<or> ID ccompare = None}\n\ngoal:\nNo subgoals!", "qed"], ["", "definition Mapping_RBT :: \"('a :: ccompare, 'b) rbt \\<Rightarrow> ('a, 'b) mapping_rbt\"\nwhere\n  \"Mapping_RBT t = Mapping_RBT'\n  (if ord.is_rbt cless t \\<or> ID CCOMPARE('a) = None then t\n   else RBT_Impl.fold (ord.rbt_insert cless) t rbt.Empty)\""], ["", "lemma Mapping_RBT_inverse:\n  fixes y :: \"('a :: ccompare, 'b) rbt\"\n  assumes \"y \\<in> {t. ord.is_rbt cless t \\<or> ID CCOMPARE('a) = None}\"\n  shows \"impl_of (Mapping_RBT y) = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. impl_of (Mapping_RBT y) = y", "using assms"], ["proof (prove)\nusing this:\n  y \\<in> {t. ord.is_rbt cless t \\<or> ID ccompare = None}\n\ngoal (1 subgoal):\n 1. impl_of (Mapping_RBT y) = y", "by(auto simp add: Mapping_RBT_def Mapping_RBT'_inverse)"], ["", "lemma impl_of_inverse: \"Mapping_RBT (impl_of t) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping_RBT (impl_of t) = t", "by(cases t)(auto simp add: Mapping_RBT'_inverse Mapping_RBT_def)"], ["", "lemma type_definition_mapping_rbt': \n  \"type_definition impl_of Mapping_RBT \n    {t :: ('a, 'b) rbt. ord.is_rbt cless t \\<or> ID CCOMPARE('a :: ccompare) = None}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type_definition impl_of Mapping_RBT\n     {t. ord.is_rbt cless t \\<or> ID ccompare = None}", "by unfold_locales(rule mapping_rbt.impl_of impl_of_inverse Mapping_RBT_inverse)+"], ["", "lemmas Mapping_RBT_cases[cases type: mapping_rbt] = \n  type_definition.Abs_cases[OF type_definition_mapping_rbt'] \n  and Mapping_RBT_induct[induct type: mapping_rbt] =\n  type_definition.Abs_induct[OF type_definition_mapping_rbt'] and\n  Mapping_RBT_inject = type_definition.Abs_inject[OF type_definition_mapping_rbt']"], ["", "lemma rbt_eq_iff:\n  \"t1 = t2 \\<longleftrightarrow> impl_of t1 = impl_of t2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t1 = t2) = (impl_of t1 = impl_of t2)", "by (simp add: impl_of_inject)"], ["", "lemma rbt_eqI:\n  \"impl_of t1 = impl_of t2 \\<Longrightarrow> t1 = t2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. impl_of t1 = impl_of t2 \\<Longrightarrow> t1 = t2", "by (simp add: rbt_eq_iff)"], ["", "lemma Mapping_RBT_impl_of [simp]:\n  \"Mapping_RBT (impl_of t) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping_RBT (impl_of t) = t", "by (simp add: impl_of_inverse)"], ["", "subsection \\<open>Operations\\<close>"], ["", "setup_lifting type_definition_mapping_rbt'"], ["", "context fixes dummy :: \"'a :: ccompare\" begin"], ["", "lift_definition lookup :: \"('a, 'b) mapping_rbt \\<Rightarrow> 'a \\<rightharpoonup> 'b\" is \"rbt_comp_lookup ccomp\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition empty :: \"('a, 'b) mapping_rbt\" is \"RBT_Impl.Empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord.is_rbt cless rbt.Empty \\<or> ID ccompare = None", "by(simp add: ord.Empty_is_rbt)"], ["", "lift_definition insert :: \"'a \\<Rightarrow> 'b \\<Rightarrow> ('a, 'b) mapping_rbt \\<Rightarrow> ('a, 'b) mapping_rbt\" is\n  \"rbt_comp_insert ccomp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b rbt.\n       ord.is_rbt cless rbt \\<or> ID ccompare = None \\<Longrightarrow>\n       ord.is_rbt cless (rbt_comp_insert ccomp a b rbt) \\<or>\n       ID ccompare = None", "by(auto 4 3 intro: linorder.rbt_insert_is_rbt ID_ccompare simp: rbt_comp_insert[OF ID_ccompare'])"], ["", "lift_definition delete :: \"'a \\<Rightarrow> ('a, 'b) mapping_rbt \\<Rightarrow> ('a, 'b) mapping_rbt\" is\n  \"rbt_comp_delete ccomp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a rbt.\n       ord.is_rbt cless rbt \\<or> ID ccompare = None \\<Longrightarrow>\n       ord.is_rbt cless (rbt_comp_delete ccomp a rbt) \\<or>\n       ID ccompare = None", "by(auto 4 3 intro: linorder.rbt_delete_is_rbt ID_ccompare simp: rbt_comp_delete[OF ID_ccompare'])"], ["", "lift_definition bulkload :: \"('a \\<times> 'b) list \\<Rightarrow> ('a, 'b) mapping_rbt\" is\n  \"rbt_comp_bulkload ccomp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list.\n       ord.is_rbt cless (rbt_comp_bulkload ccomp list) \\<or>\n       ID ccompare = None", "by(auto 4 3 intro: linorder.rbt_bulkload_is_rbt ID_ccompare simp: rbt_comp_bulkload[OF ID_ccompare'])"], ["", "lift_definition map_entry :: \"'a \\<Rightarrow> ('b \\<Rightarrow> 'b) \\<Rightarrow> ('a, 'b) mapping_rbt \\<Rightarrow> ('a, 'b) mapping_rbt\" is\n  \"rbt_comp_map_entry ccomp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a fun rbt.\n       ord.is_rbt cless rbt \\<or> ID ccompare = None \\<Longrightarrow>\n       ord.is_rbt cless (rbt_comp_map_entry ccomp a fun rbt) \\<or>\n       ID ccompare = None", "by(auto simp: ord.rbt_map_entry_is_rbt rbt_comp_map_entry[OF ID_ccompare'])"], ["", "lift_definition map :: \"('a \\<Rightarrow> 'b \\<Rightarrow> 'c) \\<Rightarrow> ('a, 'b) mapping_rbt \\<Rightarrow> ('a, 'c) mapping_rbt\" is \"RBT_Impl.map\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun rbt.\n       ord.is_rbt cless rbt \\<or> ID ccompare = None \\<Longrightarrow>\n       ord.is_rbt cless (RBT_Impl.map fun rbt) \\<or> ID ccompare = None", "by(simp add: ord.map_is_rbt)"], ["", "lift_definition entries :: \"('a, 'b) mapping_rbt \\<Rightarrow> ('a \\<times> 'b) list\" is \"RBT_Impl.entries\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition keys :: \"('a, 'b) mapping_rbt \\<Rightarrow> 'a set\" is \"set \\<circ> RBT_Impl.keys\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition fold :: \"('a \\<Rightarrow> 'b \\<Rightarrow> 'c \\<Rightarrow> 'c) \\<Rightarrow> ('a, 'b) mapping_rbt \\<Rightarrow> 'c \\<Rightarrow> 'c\" is \"RBT_Impl.fold\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition is_empty :: \"('a, 'b) mapping_rbt \\<Rightarrow> bool\" is \"case_rbt True (\\<lambda>_ _ _ _ _. False)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition filter :: \"('a \\<times> 'b \\<Rightarrow> bool) \\<Rightarrow> ('a, 'b) mapping_rbt \\<Rightarrow> ('a, 'b) mapping_rbt\" is\n  \"\\<lambda>P t. rbtreeify (List.filter P (RBT_Impl.entries t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun rbt.\n       ord.is_rbt cless rbt \\<or> ID ccompare = None \\<Longrightarrow>\n       ord.is_rbt cless\n        (rbtreeify (filter fun (RBT_Impl.entries rbt))) \\<or>\n       ID ccompare = None", "by(auto intro!: linorder.is_rbt_rbtreeify ID_ccompare linorder.sorted_filter linorder.rbt_sorted_entries ord.is_rbt_rbt_sorted linorder.distinct_entries distinct_map_filterI simp add: filter_map[symmetric])"], ["", "lift_definition join ::\n  \"('a \\<Rightarrow> 'b \\<Rightarrow> 'b \\<Rightarrow> 'b) \\<Rightarrow> ('a, 'b) mapping_rbt \\<Rightarrow> ('a, 'b) mapping_rbt \\<Rightarrow> ('a, 'b) mapping_rbt\"\nis \"rbt_comp_union_with_key ccomp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun rbt1 rbt2.\n       \\<lbrakk>ord.is_rbt cless rbt1 \\<or> ID ccompare = None;\n        ord.is_rbt cless rbt2 \\<or> ID ccompare = None\\<rbrakk>\n       \\<Longrightarrow> ord.is_rbt cless\n                          (rbt_comp_union_with_key ccomp fun rbt1\n                            rbt2) \\<or>\n                         ID ccompare = None", "by(auto 4 3 intro: linorder.is_rbt_rbt_unionwk ID_ccompare simp: rbt_comp_union_with_key[OF ID_ccompare'])"], ["", "lift_definition meet ::\n  \"('a \\<Rightarrow> 'b \\<Rightarrow> 'b \\<Rightarrow> 'b) \\<Rightarrow> ('a, 'b) mapping_rbt \\<Rightarrow> ('a, 'b) mapping_rbt \\<Rightarrow> ('a, 'b) mapping_rbt\" \nis \"rbt_comp_inter_with_key ccomp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun rbt1 rbt2.\n       \\<lbrakk>ord.is_rbt cless rbt1 \\<or> ID ccompare = None;\n        ord.is_rbt cless rbt2 \\<or> ID ccompare = None\\<rbrakk>\n       \\<Longrightarrow> ord.is_rbt cless\n                          (rbt_comp_inter_with_key ccomp fun rbt1\n                            rbt2) \\<or>\n                         ID ccompare = None", "by(auto 4 3 intro: linorder.rbt_interwk_is_rbt ID_ccompare ord.is_rbt_rbt_sorted simp: rbt_comp_inter_with_key[OF ID_ccompare'])"], ["", "lift_definition all :: \"('a \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> ('a, 'b) mapping_rbt \\<Rightarrow> bool\" \nis \"RBT_Impl_rbt_all\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition ex :: \"('a \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> ('a, 'b) mapping_rbt \\<Rightarrow> bool\"\nis \"RBT_Impl_rbt_ex\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition product ::\n  \"('a \\<Rightarrow> 'b \\<Rightarrow> 'c \\<Rightarrow> 'd \\<Rightarrow> 'e) \\<Rightarrow> ('a, 'b) mapping_rbt\n  \\<Rightarrow> ('c :: ccompare, 'd) mapping_rbt \\<Rightarrow> ('a \\<times> 'c, 'e) mapping_rbt\"\nis \"rbt_product\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun rbt1 rbt2.\n       \\<lbrakk>ord.is_rbt cless rbt1 \\<or> ID ccompare = None;\n        ord.is_rbt cless rbt2 \\<or> ID ccompare = None\\<rbrakk>\n       \\<Longrightarrow> ord.is_rbt cless (rbt_product fun rbt1 rbt2) \\<or>\n                         ID ccompare = None", "by (fastforce intro: is_rbt_rbt_product ID_ccompare simp add: lt_of_comp_less_prod ccompare_prod_def ID_Some ID_None split: option.split_asm)"], ["", "lift_definition diag ::\n  \"('a, 'b) mapping_rbt \\<Rightarrow> ('a \\<times> 'a, 'b) mapping_rbt\"\nis \"RBT_Impl_diag\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rbt.\n       ord.is_rbt cless rbt \\<or> ID ccompare = None \\<Longrightarrow>\n       ord.is_rbt cless (RBT_Impl_diag rbt) \\<or> ID ccompare = None", "by(auto simp add: lt_of_comp_less_prod ccompare_prod_def ID_Some ID_None is_rbt_RBT_Impl_diag split: option.split_asm)"], ["", "lift_definition init :: \"('a, 'b) mapping_rbt \\<Rightarrow> ('a, 'b, 'c) rbt_generator_state\"\nis \"rbt_init\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "subsection \\<open>Properties\\<close>"], ["", "lemma unfoldr_rbt_entries_generator:\n  \"list.unfoldr rbt_entries_generator (init t) = entries t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.unfoldr rbt_entries_generator (init t) = entries t", "by transfer(simp add: unfoldr_rbt_entries_generator)"], ["", "lemma lookup_RBT:\n  \"ord.is_rbt cless t \\<Longrightarrow>\n  lookup (Mapping_RBT t) = rbt_comp_lookup ccomp t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord.is_rbt cless t \\<Longrightarrow>\n    lookup (Mapping_RBT t) = rbt_comp_lookup ccomp t", "by(simp add: lookup_def Mapping_RBT_inverse)"], ["", "lemma lookup_impl_of:\n  \"rbt_comp_lookup ccomp (impl_of t) = lookup t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_comp_lookup ccomp (impl_of t) = lookup t", "by(transfer) simp"], ["", "lemma entries_impl_of:\n  \"RBT_Impl.entries (impl_of t) = entries t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RBT_Impl.entries (impl_of t) = entries t", "by transfer simp"], ["", "lemma keys_impl_of:\n  \"set (RBT_Impl.keys (impl_of t)) = keys t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (RBT_Impl.keys (impl_of t)) = keys t", "by (simp add: keys_def)"], ["", "lemma lookup_empty [simp]:\n  \"lookup empty = Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup RBT_Mapping2.empty = Map.empty", "by transfer (simp add: fun_eq_iff ord.rbt_lookup.simps)"], ["", "lemma fold_conv_fold:\n  \"fold f t = List.fold (case_prod f) (entries t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RBT_Mapping2.fold f t = List.fold (\\<lambda>(x, y). f x y) (entries t)", "by transfer(simp add: RBT_Impl.fold_def)"], ["", "lemma is_empty_empty [simp]:\n  \"is_empty t \\<longleftrightarrow> t = empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_empty t = (t = RBT_Mapping2.empty)", "by transfer (simp split: rbt.split)"], ["", "context assumes ID_ccompare_neq_None: \"ID CCOMPARE('a :: ccompare) \\<noteq> None\"\nbegin"], ["", "lemma mapping_linorder: \"class.linorder (cless_eq :: 'a \\<Rightarrow> 'a \\<Rightarrow> bool) cless\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.linorder cless_eq cless", "using ID_ccompare_neq_None"], ["proof (prove)\nusing this:\n  ID ccompare \\<noteq> None\n\ngoal (1 subgoal):\n 1. class.linorder cless_eq cless", "by(clarsimp)(rule ID_ccompare)"], ["", "lemma mapping_comparator: \"comparator (ccomp :: 'a comparator)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator ccomp", "using ID_ccompare_neq_None"], ["proof (prove)\nusing this:\n  ID ccompare \\<noteq> None\n\ngoal (1 subgoal):\n 1. comparator ccomp", "by(clarsimp)(rule ID_ccompare')"], ["", "lemmas rbt_comp[simp] = rbt_comp_simps[OF mapping_comparator]"], ["", "lemma is_rbt_impl_of [simp, intro]:\n  fixes t :: \"('a, 'b) mapping_rbt\"\n  shows \"ord.is_rbt cless (impl_of t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord.is_rbt cless (impl_of t)", "using ID_ccompare_neq_None impl_of [of t]"], ["proof (prove)\nusing this:\n  ID ccompare \\<noteq> None\n  impl_of t \\<in> {t. ord.is_rbt cless t \\<or> ID ccompare = None}\n\ngoal (1 subgoal):\n 1. ord.is_rbt cless (impl_of t)", "by auto"], ["", "lemma lookup_insert [simp]:\n  \"lookup (insert (k :: 'a) v t) = (lookup t)(k \\<mapsto> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (RBT_Mapping2.insert k v t) = lookup t(k \\<mapsto> v)", "by transfer (simp add: ID_ccompare_neq_None \n  linorder.rbt_lookup_rbt_insert[OF mapping_linorder])"], ["", "lemma lookup_delete [simp]:\n  \"lookup (delete (k :: 'a) t) = (lookup t)(k := None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (delete k t) = (lookup t)(k := None)", "by transfer(simp add: ID_ccompare_neq_None linorder.rbt_lookup_rbt_delete[OF mapping_linorder] restrict_complement_singleton_eq)"], ["", "lemma map_of_entries [simp]:\n  \"map_of (entries (t :: ('a, 'b) mapping_rbt)) = lookup t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (entries t) = lookup t", "by transfer(simp add: ID_ccompare_neq_None linorder.map_of_entries[OF mapping_linorder] ord.is_rbt_rbt_sorted)"], ["", "lemma entries_lookup:\n  \"entries (t1 :: ('a, 'b) mapping_rbt) = entries t2 \\<longleftrightarrow> lookup t1 = lookup t2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (entries t1 = entries t2) = (lookup t1 = lookup t2)", "by transfer(simp add: ID_ccompare_neq_None linorder.entries_rbt_lookup[OF mapping_linorder] ord.is_rbt_rbt_sorted)"], ["", "lemma lookup_bulkload [simp]:\n  \"lookup (bulkload xs) = map_of (xs :: ('a \\<times> 'b) list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (bulkload xs) = map_of xs", "by transfer(simp add: linorder.rbt_lookup_rbt_bulkload[OF mapping_linorder])"], ["", "lemma lookup_map_entry [simp]:\n  \"lookup (map_entry (k :: 'a) f t) = (lookup t)(k := map_option f (lookup t k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (map_entry k f t) = (lookup t)(k := map_option f (lookup t k))", "by transfer(simp add: ID_ccompare_neq_None linorder.rbt_lookup_rbt_map_entry[OF mapping_linorder])"], ["", "lemma lookup_map [simp]:\n  \"lookup (map f t) (k :: 'a) = map_option (f k) (lookup t k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (RBT_Mapping2.map f t) k = map_option (f k) (lookup t k)", "by transfer(simp add: linorder.rbt_lookup_map[OF mapping_linorder])"], ["", "lemma RBT_lookup_empty [simp]:\n  \"ord.rbt_lookup cless (t :: ('a, 'b) RBT_Impl.rbt) = Map.empty \\<longleftrightarrow> t = RBT_Impl.Empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ord.rbt_lookup cless t = Map.empty) = (t = rbt.Empty)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (ord.rbt_lookup cless t = Map.empty) = (t = rbt.Empty)", "interpret linorder \"cless_eq :: 'a \\<Rightarrow> 'a \\<Rightarrow> bool\" cless"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.linorder cless_eq cless", "by(rule mapping_linorder)"], ["proof (state)\ngoal (1 subgoal):\n 1. (local.rbt_lookup t = Map.empty) = (t = rbt.Empty)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.rbt_lookup t = Map.empty) = (t = rbt.Empty)", "by(cases t)(auto simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  (local.rbt_lookup t = Map.empty) = (t = rbt.Empty)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_empty_empty [simp]:\n  \"lookup t = Map.empty \\<longleftrightarrow> (t :: ('a, 'b) mapping_rbt) = empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lookup t = Map.empty) = (t = RBT_Mapping2.empty)", "by transfer simp"], ["", "lemma finite_dom_lookup [simp]: \"finite (dom (lookup (t :: ('a, 'b) mapping_rbt)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (dom (lookup t))", "by transfer(auto simp add: linorder.finite_dom_rbt_lookup[OF mapping_linorder])"], ["", "lemma card_com_lookup [unfolded length_map, simp]:\n  \"card (dom (lookup (t :: ('a, 'b) mapping_rbt))) = length (List.map fst (entries t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (dom (lookup t)) = length (list.map fst (entries t))", "by transfer(auto simp add: linorder.rbt_lookup_keys[OF mapping_linorder] linorder.distinct_entries[OF mapping_linorder] RBT_Impl.keys_def ord.is_rbt_rbt_sorted ID_ccompare_neq_None List.card_set simp del: set_map length_map)"], ["", "lemma lookup_join:\n  \"lookup (join f (t1 :: ('a, 'b) mapping_rbt) t2) =\n  (\\<lambda>k. case lookup t1 k of None \\<Rightarrow> lookup t2 k | Some v1 \\<Rightarrow> Some (case lookup t2 k of None \\<Rightarrow> v1 | Some v2 \\<Rightarrow> f k v1 v2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (join f t1 t2) =\n    (\\<lambda>k.\n        case lookup t1 k of None \\<Rightarrow> lookup t2 k\n        | Some v1 \\<Rightarrow>\n            Some\n             (case lookup t2 k of None \\<Rightarrow> v1\n              | Some v2 \\<Rightarrow> f k v1 v2))", "by transfer(auto simp add: fun_eq_iff linorder.rbt_lookup_rbt_unionwk[OF mapping_linorder] ord.is_rbt_rbt_sorted ID_ccompare_neq_None split: option.splits)"], ["", "lemma lookup_meet:\n  \"lookup (meet f (t1 :: ('a, 'b) mapping_rbt) t2) =\n  (\\<lambda>k. case lookup t1 k of None \\<Rightarrow> None | Some v1 \\<Rightarrow> case lookup t2 k of None \\<Rightarrow> None | Some v2 \\<Rightarrow> Some (f k v1 v2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (meet f t1 t2) =\n    (\\<lambda>k.\n        case lookup t1 k of None \\<Rightarrow> None\n        | Some v1 \\<Rightarrow>\n            case lookup t2 k of None \\<Rightarrow> None\n            | Some v2 \\<Rightarrow> Some (f k v1 v2))", "by transfer(auto simp add: fun_eq_iff linorder.rbt_lookup_rbt_interwk[OF mapping_linorder] ord.is_rbt_rbt_sorted ID_ccompare_neq_None split: option.splits)"], ["", "lemma lookup_filter [simp]:\n  \"lookup (filter P (t :: ('a, 'b) mapping_rbt)) k = \n  (case lookup t k of None \\<Rightarrow> None | Some v \\<Rightarrow> if P (k, v) then Some v else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (RBT_Mapping2.filter P t) k =\n    (case lookup t k of None \\<Rightarrow> None\n     | Some v \\<Rightarrow> if P (k, v) then Some v else None)", "by transfer(simp split: option.split add: ID_ccompare_neq_None linorder.rbt_lookup_rbtreeify[OF mapping_linorder] linorder.sorted_filter[OF mapping_linorder] ord.is_rbt_rbt_sorted linorder.rbt_sorted_entries[OF mapping_linorder] distinct_map_filterI linorder.distinct_entries[OF mapping_linorder] map_of_filter_apply linorder.map_of_entries[OF mapping_linorder])"], ["", "lemma all_conv_all_lookup:\n  \"all P t \\<longleftrightarrow> (\\<forall>(k :: 'a) v. lookup t k = Some v \\<longrightarrow> P k v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all P t = (\\<forall>k v. lookup t k = Some v \\<longrightarrow> P k v)", "by transfer(auto simp add: ID_ccompare_neq_None linorder.rbt_lookup_keys[OF mapping_linorder] ord.is_rbt_rbt_sorted RBT_Impl.keys_def RBT_Impl_rbt_all_def linorder.map_of_entries[OF mapping_linorder, symmetric] linorder.distinct_entries[OF mapping_linorder] dest: map_of_SomeD intro: map_of_is_SomeI)"], ["", "lemma ex_conv_ex_lookup:\n  \"ex P t \\<longleftrightarrow> (\\<exists>(k :: 'a) v. lookup t k = Some v \\<and> P k v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ex P t = (\\<exists>k v. lookup t k = Some v \\<and> P k v)", "by transfer(auto simp add: ID_ccompare_neq_None linorder.rbt_lookup_keys[OF mapping_linorder] ord.is_rbt_rbt_sorted RBT_Impl.keys_def RBT_Impl_rbt_ex_def linorder.map_of_entries[OF mapping_linorder, symmetric] linorder.distinct_entries[OF mapping_linorder] intro: map_of_is_SomeI)"], ["", "lemma diag_lookup:\n  \"lookup (diag t) = (\\<lambda>(k :: 'a, k'). if k = k' then lookup t k else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (diag t) =\n    (\\<lambda>(k, k'). if k = k' then lookup t k else None)", "using linorder.rbt_lookup_RBT_Impl_diag[where ?'b='b, OF mapping_linorder]"], ["proof (prove)\nusing this:\n  ord.rbt_lookup (less_prod cless_eq cless cless) (RBT_Impl_diag ?t) =\n  (\\<lambda>(k, k'). if k = k' then ord.rbt_lookup cless ?t k else None)\n\ngoal (1 subgoal):\n 1. lookup (diag t) =\n    (\\<lambda>(k, k'). if k = k' then lookup t k else None)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>\\<And>t.\n                   ord.rbt_lookup (less_prod cless_eq cless cless)\n                    (RBT_Impl_diag t) =\n                   (\\<lambda>(k, k').\n                       if k = k' then ord.rbt_lookup cless t k else None);\n        ord.is_rbt cless t \\<or> ID ccompare = None\\<rbrakk>\n       \\<Longrightarrow> rbt_comp_lookup ccomp (RBT_Impl_diag t) =\n                         (\\<lambda>(k, k').\n                             if k = k' then rbt_comp_lookup ccomp t k\n                             else None)", "apply (clarsimp simp add: ID_ccompare_neq_None ccompare_prod_def lt_of_comp_less_prod[symmetric] \n  rbt_comp_lookup[OF comparator_prod[OF mapping_comparator mapping_comparator], symmetric]\n  ID_Some split: option.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t x2.\n       \\<lbrakk>\\<And>t.\n                   rbt_comp_lookup (comparator_prod x2 x2)\n                    (RBT_Impl_diag t) =\n                   (\\<lambda>(k, k').\n                       if k = k' then ord.rbt_lookup cless t k else None);\n        ord.is_rbt (lt_of_comp x2) t; ID ccompare = Some x2\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>(k, k').\n                             if k = k' then ord.rbt_lookup cless t k\n                             else None) =\n                         (\\<lambda>(k, k').\n                             if k = k' then rbt_comp_lookup ccomp t k\n                             else None)", "apply (unfold rbt_comp_lookup[OF mapping_comparator], simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "context assumes ID_ccompare_neq_None': \"ID CCOMPARE('b :: ccompare) \\<noteq> None\"\nbegin"], ["", "lemma mapping_linorder': \"class.linorder (cless_eq :: 'b \\<Rightarrow> 'b \\<Rightarrow> bool) cless\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.linorder cless_eq cless", "using ID_ccompare_neq_None'"], ["proof (prove)\nusing this:\n  ID ccompare \\<noteq> None\n\ngoal (1 subgoal):\n 1. class.linorder cless_eq cless", "by(clarsimp)(rule ID_ccompare)"], ["", "lemma mapping_comparator': \"comparator (ccomp :: 'b comparator)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator ccomp", "using ID_ccompare_neq_None'"], ["proof (prove)\nusing this:\n  ID ccompare \\<noteq> None\n\ngoal (1 subgoal):\n 1. comparator ccomp", "by(clarsimp)(rule ID_ccompare')"], ["", "lemmas rbt_comp'[simp] = rbt_comp_simps[OF mapping_comparator']"], ["", "lemma ccomp_comparator_prod:\n  \"ccomp = (comparator_prod ccomp ccomp :: ('a \\<times> 'b)comparator)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccomp = comparator_prod ccomp ccomp", "by(simp add: ccompare_prod_def lt_of_comp_less_prod ID_ccompare_neq_None ID_ccompare_neq_None' ID_Some split: option.splits)"], ["", "lemma lookup_product: \n  \"lookup (product f rbt1 rbt2) (a :: 'a, b :: 'b) = \n  (case lookup rbt1 a of None \\<Rightarrow> None\n   | Some c \\<Rightarrow> map_option (f a c b) (lookup rbt2 b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (product f rbt1 rbt2) (a, b) =\n    (case lookup rbt1 a of None \\<Rightarrow> None\n     | Some c \\<Rightarrow> map_option (f a c b) (lookup rbt2 b))", "using mapping_linorder mapping_linorder'"], ["proof (prove)\nusing this:\n  class.linorder cless_eq cless\n  class.linorder cless_eq cless\n\ngoal (1 subgoal):\n 1. lookup (product f rbt1 rbt2) (a, b) =\n    (case lookup rbt1 a of None \\<Rightarrow> None\n     | Some c \\<Rightarrow> map_option (f a c b) (lookup rbt2 b))", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f rbt1 rbt2 a b.\n       \\<lbrakk>class.linorder cless_eq cless;\n        class.linorder cless_eq cless;\n        ord.is_rbt cless rbt1 \\<or> ID ccompare = None;\n        ord.is_rbt cless rbt2 \\<or> ID ccompare = None\\<rbrakk>\n       \\<Longrightarrow> rbt_comp_lookup ccomp (rbt_product f rbt1 rbt2)\n                          (a, b) =\n                         (case rbt_comp_lookup ccomp rbt1 a of\n                          None \\<Rightarrow> None\n                          | Some c \\<Rightarrow>\n                              map_option (f a c b)\n                               (rbt_comp_lookup ccomp rbt2 b))", "apply (unfold ccomp_comparator_prod rbt_comp_lookup[OF comparator_prod[OF mapping_comparator mapping_comparator']]\n  rbt_comp rbt_comp' lt_of_comp_less_prod)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f rbt1 rbt2 a b.\n       \\<lbrakk>class.linorder cless_eq cless;\n        class.linorder cless_eq cless;\n        ord.is_rbt cless rbt1 \\<or> ID ccompare = None;\n        ord.is_rbt cless rbt2 \\<or> ID ccompare = None\\<rbrakk>\n       \\<Longrightarrow> ord.rbt_lookup (less_prod cless_eq cless cless)\n                          (rbt_product f rbt1 rbt2) (a, b) =\n                         (case ord.rbt_lookup cless rbt1 a of\n                          None \\<Rightarrow> None\n                          | Some c \\<Rightarrow>\n                              map_option (f a c b)\n                               (ord.rbt_lookup cless rbt2 b))", "apply (simp add: ID_ccompare_neq_None ID_ccompare_neq_None' rbt_lookup_rbt_product)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "end"], ["", "hide_const (open) impl_of lookup empty insert delete\n  entries keys bulkload map_entry map fold join meet filter all ex product diag init"], ["", "end"]]}