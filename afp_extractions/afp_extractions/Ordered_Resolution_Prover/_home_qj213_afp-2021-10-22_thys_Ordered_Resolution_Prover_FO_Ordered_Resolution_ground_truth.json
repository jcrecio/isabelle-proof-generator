{"file_name": "/home/qj213/afp-2021-10-22/thys/Ordered_Resolution_Prover/FO_Ordered_Resolution.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Ordered_Resolution_Prover", "problem_names": ["lemma Bex_cartesian_product: \"(\\<exists>xy \\<in> A \\<times> B. P xy) \\<equiv> (\\<exists>x \\<in> A. \\<exists>y \\<in> B. P (x, y))\"", "lemma eql_map_neg_lit_eql_atm:\n  assumes \"map (\\<lambda>L. L \\<cdot>l \\<eta>) (map Neg As') = map Neg As\"\n  shows \"As' \\<cdot>al \\<eta> = As\"", "lemma instance_list:\n  assumes \"negs (mset As) = SDA' \\<cdot> \\<eta>\"\n  shows \"\\<exists>As'. negs (mset As') = SDA' \\<and> As' \\<cdot>al \\<eta> = As\"", "lemma map2_add_mset_map:\n  assumes \"length AAs' = n\" and \"length As' = n\"\n  shows \"map2 add_mset (As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>) = map2 add_mset As' AAs' \\<cdot>aml \\<eta>\"", "lemma strictly_maximal_wrt_maximal_wrt: \"strictly_maximal_wrt A C \\<Longrightarrow> maximal_wrt A C\"", "lemma maximal_wrt_subst: \"maximal_wrt (A \\<cdot>a \\<sigma>) (C \\<cdot> \\<sigma>) \\<Longrightarrow> maximal_wrt A C\"", "lemma strictly_maximal_wrt_subst:\n  \"strictly_maximal_wrt (A \\<cdot>a \\<sigma>) (C \\<cdot> \\<sigma>) \\<Longrightarrow> strictly_maximal_wrt A C\"", "lemma ord_resolve_empty_main_prem: \"\\<not> ord_resolve Cs {#} AAs As \\<sigma> E\"", "lemma ord_resolve_rename_empty_main_prem: \"\\<not> ord_resolve_rename Cs {#} AAs As \\<sigma> E\"", "lemma ord_resolve_ground_inst_sound:\n  assumes\n    res_e: \"ord_resolve CAs DA AAs As \\<sigma> E\" and\n    cc_inst_true: \"I \\<Turnstile>m mset CAs \\<cdot>cm \\<sigma> \\<cdot>cm \\<eta>\" and\n    d_inst_true: \"I \\<Turnstile> DA \\<cdot> \\<sigma> \\<cdot> \\<eta>\" and\n    ground_subst_\\<eta>: \"is_ground_subst \\<eta>\"\n  shows \"I \\<Turnstile> E \\<cdot> \\<eta>\"", "lemma ord_resolve_rename_ground_inst_sound:\n  assumes\n    \"ord_resolve_rename CAs DA AAs As \\<sigma> E\" and\n    \"\\<rho>s = tl (renamings_apart (DA # CAs))\" and\n    \"\\<rho> = hd (renamings_apart (DA # CAs))\" and\n    \"I \\<Turnstile>m (mset (CAs \\<cdot>\\<cdot>cl \\<rho>s)) \\<cdot>cm \\<sigma> \\<cdot>cm \\<eta>\" and\n    \"I \\<Turnstile> DA \\<cdot> \\<rho> \\<cdot> \\<sigma> \\<cdot> \\<eta>\" and\n    \"is_ground_subst \\<eta>\"\n  shows \"I \\<Turnstile> E \\<cdot> \\<eta>\"", "theorem ord_resolve_sound:\n assumes\n   res_e: \"ord_resolve CAs DA AAs As \\<sigma> E\" and\n   cc_d_true: \"\\<And>\\<sigma>. is_ground_subst \\<sigma> \\<Longrightarrow> I \\<Turnstile>m (mset CAs + {#DA#}) \\<cdot>cm \\<sigma>\" and\n   ground_subst_\\<eta>: \"is_ground_subst \\<eta>\"\n shows \"I \\<Turnstile> E \\<cdot> \\<eta>\"", "lemma subst_sound:\n  assumes\n    \"\\<And>\\<sigma>. is_ground_subst \\<sigma> \\<Longrightarrow> I \\<Turnstile> C \\<cdot> \\<sigma>\" and\n    \"is_ground_subst \\<eta>\"\n  shows \"I \\<Turnstile> C \\<cdot> \\<rho> \\<cdot> \\<eta>\"", "lemma subst_sound_scl:\n  assumes\n    len: \"length P = length CAs\" and\n    true_cas: \"\\<And>\\<sigma>. is_ground_subst \\<sigma> \\<Longrightarrow> I \\<Turnstile>m mset CAs \\<cdot>cm \\<sigma>\" and\n    ground_subst_\\<eta>: \"is_ground_subst \\<eta>\"\n  shows \"I \\<Turnstile>m mset (CAs \\<cdot>\\<cdot>cl P) \\<cdot>cm \\<eta>\"", "lemma ord_resolve_rename_sound:\n  assumes\n    res_e: \"ord_resolve_rename CAs DA AAs As \\<sigma> E\" and\n    cc_d_true: \"\\<And>\\<sigma>. is_ground_subst \\<sigma> \\<Longrightarrow> I \\<Turnstile>m ((mset CAs) + {#DA#}) \\<cdot>cm \\<sigma>\" and\n    ground_subst_\\<eta>: \"is_ground_subst \\<eta>\"\n  shows \"I \\<Turnstile> E \\<cdot> \\<eta>\"", "lemma ord_resolve_unique:\n  assumes\n    \"ord_resolve CAs DA AAs As \\<sigma> E\" and\n    \"ord_resolve CAs DA AAs As \\<sigma>' E'\"\n  shows \"\\<sigma> = \\<sigma>' \\<and> E = E'\"", "lemma ord_resolve_rename_unique:\n  assumes\n    \"ord_resolve_rename CAs DA AAs As \\<sigma> E\" and\n    \"ord_resolve_rename CAs DA AAs As \\<sigma>' E'\"\n  shows \"\\<sigma> = \\<sigma>' \\<and> E = E'\"", "lemma ord_resolve_max_side_prems: \"ord_resolve CAs DA AAs As \\<sigma> E \\<Longrightarrow> length CAs \\<le> size DA\"", "lemma ord_resolve_rename_max_side_prems:\n  \"ord_resolve_rename CAs DA AAs As \\<sigma> E \\<Longrightarrow> length CAs \\<le> size DA\"", "lemma finite_ord_FO_resolution_inferences_between:\n  assumes fin_cc: \"finite CC\"\n  shows \"finite (ord_FO_resolution.inferences_between CC C)\"", "lemma ord_FO_resolution_inferences_between_empty_empty:\n  \"ord_FO_resolution.inferences_between {} {#} = {}\"", "lemma S_M_grounding_of_clss:\n  assumes \"C \\<in> grounding_of_clss M\"\n  obtains D \\<sigma> where\n    \"D \\<in> M \\<and> C = D \\<cdot> \\<sigma> \\<and> S_M C = S D \\<cdot> \\<sigma> \\<and> is_ground_subst \\<sigma>\"", "lemma S_M_not_grounding_of_clss: \"C \\<notin> grounding_of_clss M \\<Longrightarrow> S_M C = S C\"", "lemma S_M_selects_subseteq: \"S_M C \\<subseteq># C\"", "lemma S_M_selects_neg_lits: \"L \\<in># S_M C \\<Longrightarrow> is_neg L\"", "lemma ground_resolvent_subset:\n  assumes\n    gr_cas: \"is_ground_cls_list CAs\" and\n    gr_da: \"is_ground_cls DA\" and\n    res_e: \"ord_resolve S CAs DA AAs As \\<sigma> E\"\n  shows \"E \\<subseteq># \\<Sum>\\<^sub># (mset CAs) + DA\"", "lemma ord_resolve_obtain_clauses:\n  assumes\n    res_e: \"ord_resolve (S_M S M) CAs DA AAs As \\<sigma> E\" and\n    select: \"selection S\" and\n    grounding: \"{DA} \\<union> set CAs \\<subseteq> grounding_of_clss M\" and\n    n: \"length CAs = n\" and\n    d: \"DA = D + negs (mset As)\" and\n    c: \"(\\<forall>i < n. CAs ! i = Cs ! i + poss (AAs ! i))\" \"length Cs = n\" \"length AAs = n\"\n  obtains DA0 \\<eta>0 CAs0 \\<eta>s0 As0 AAs0 D0 Cs0 where\n    \"length CAs0 = n\"\n    \"length \\<eta>s0 = n\"\n    \"DA0 \\<in> M\"\n    \"DA0 \\<cdot> \\<eta>0 = DA\"\n    \"S DA0 \\<cdot> \\<eta>0 = S_M S M DA\"\n    \"\\<forall>CA0 \\<in> set CAs0. CA0 \\<in> M\"\n    \"CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs\"\n    \"map S CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = map (S_M S M) CAs\"\n    \"is_ground_subst \\<eta>0\"\n    \"is_ground_subst_list \\<eta>s0\"\n    \"As0  \\<cdot>al \\<eta>0 = As\"\n    \"AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs\"\n    \"length As0 = n\"\n    \"D0 \\<cdot> \\<eta>0 = D\"\n    \"DA0 = D0 + (negs (mset As0))\"\n    \"S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow> negs (mset As0) = S DA0\"\n    \"length Cs0 = n\"\n    \"Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs\"\n    \"\\<forall>i < n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i)\"\n    \"length AAs0 = n\"", "lemma ord_resolve_rename_lifting:\n  assumes\n    sel_stable: \"\\<And>\\<rho> C. is_renaming \\<rho> \\<Longrightarrow> S (C \\<cdot> \\<rho>) = S C \\<cdot> \\<rho>\" and\n    res_e: \"ord_resolve (S_M S M) CAs DA AAs As \\<sigma> E\" and\n    select: \"selection S\" and\n    grounding: \"{DA} \\<union> set CAs \\<subseteq> grounding_of_clss M\"\n  obtains \\<eta>s \\<eta> \\<eta>2 CAs0 DA0 AAs0 As0 E0 \\<tau> where\n    \"is_ground_subst \\<eta>\"\n    \"is_ground_subst_list \\<eta>s\"\n    \"is_ground_subst \\<eta>2\"\n    \"ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0\"\n    \"CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs\" \"DA0 \\<cdot> \\<eta> = DA\" \"E0 \\<cdot> \\<eta>2 = E\"\n    \"{DA0} \\<union> set CAs0 \\<subseteq> M\"\n    \"length CAs0 = length CAs\"\n    \"length \\<eta>s = length CAs\"", "lemma ground_ord_resolve_ground:\n  assumes\n    select: \"selection S\" and\n    CAs_p: \"ground_resolution_with_selection.ord_resolve S CAs DA AAs As E\" and\n    ground_cas: \"is_ground_cls_list CAs\" and\n    ground_da: \"is_ground_cls DA\"\n  shows \"is_ground_cls E\"", "lemma ground_ord_resolve_imp_ord_resolve:\n  assumes\n    ground_da: \\<open>is_ground_cls DA\\<close> and\n    ground_cas: \\<open>is_ground_cls_list CAs\\<close> and\n    gr: \"ground_resolution_with_selection S_G\" and\n    gr_res: \\<open>ground_resolution_with_selection.ord_resolve S_G CAs DA AAs As E\\<close>\n  shows \\<open>\\<exists>\\<sigma>. ord_resolve S_G CAs DA AAs As \\<sigma> E\\<close>"], "translations": [["", "lemma Bex_cartesian_product: \"(\\<exists>xy \\<in> A \\<times> B. P xy) \\<equiv> (\\<exists>x \\<in> A. \\<exists>y \\<in> B. P (x, y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xy\\<in>A \\<times> B. P xy \\<equiv>\n    \\<exists>x\\<in>A. \\<exists>y\\<in>B. P (x, y)", "by simp"], ["", "lemma eql_map_neg_lit_eql_atm:\n  assumes \"map (\\<lambda>L. L \\<cdot>l \\<eta>) (map Neg As') = map Neg As\"\n  shows \"As' \\<cdot>al \\<eta> = As\""], ["proof (prove)\ngoal (1 subgoal):\n 1. As' \\<cdot>al \\<eta> = As", "using assms"], ["proof (prove)\nusing this:\n  map (\\<lambda>L. L \\<cdot>l \\<eta>) (map Neg As') = map Neg As\n\ngoal (1 subgoal):\n 1. As' \\<cdot>al \\<eta> = As", "by (induction As' arbitrary: As) auto"], ["", "lemma instance_list:\n  assumes \"negs (mset As) = SDA' \\<cdot> \\<eta>\"\n  shows \"\\<exists>As'. negs (mset As') = SDA' \\<and> As' \\<cdot>al \\<eta> = As\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>As'. negs (mset As') = SDA' \\<and> As' \\<cdot>al \\<eta> = As", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>As'. negs (mset As') = SDA' \\<and> As' \\<cdot>al \\<eta> = As", "from assms"], ["proof (chain)\npicking this:\n  negs (mset As) = SDA' \\<cdot> \\<eta>", "have negL: \"\\<forall>L \\<in># SDA'. is_neg L\""], ["proof (prove)\nusing this:\n  negs (mset As) = SDA' \\<cdot> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<forall>L\\<in>#SDA'. is_neg L", "using Melem_subst_cls subst_lit_in_negs_is_neg"], ["proof (prove)\nusing this:\n  negs (mset As) = SDA' \\<cdot> \\<eta>\n  (?L \\<in># ?C \\<cdot> ?\\<sigma>) =\n  (\\<exists>M. M \\<in># ?C \\<and> ?L = M \\<cdot>l ?\\<sigma>)\n  ?L \\<cdot>l ?\\<sigma> \\<in># negs ?AA \\<Longrightarrow> is_neg ?L\n\ngoal (1 subgoal):\n 1. \\<forall>L\\<in>#SDA'. is_neg L", "by metis"], ["proof (state)\nthis:\n  \\<forall>L\\<in>#SDA'. is_neg L\n\ngoal (1 subgoal):\n 1. \\<exists>As'. negs (mset As') = SDA' \\<and> As' \\<cdot>al \\<eta> = As", "from assms"], ["proof (chain)\npicking this:\n  negs (mset As) = SDA' \\<cdot> \\<eta>", "have \"{#L \\<cdot>l \\<eta>. L \\<in># SDA'#} = mset (map Neg As)\""], ["proof (prove)\nusing this:\n  negs (mset As) = SDA' \\<cdot> \\<eta>\n\ngoal (1 subgoal):\n 1. {#L \\<cdot>l \\<eta>. L \\<in># SDA'#} = mset (map Neg As)", "using subst_cls_def"], ["proof (prove)\nusing this:\n  negs (mset As) = SDA' \\<cdot> \\<eta>\n  ?AA \\<cdot> ?\\<sigma> = {#A \\<cdot>l ?\\<sigma>. A \\<in># ?AA#}\n\ngoal (1 subgoal):\n 1. {#L \\<cdot>l \\<eta>. L \\<in># SDA'#} = mset (map Neg As)", "by auto"], ["proof (state)\nthis:\n  {#L \\<cdot>l \\<eta>. L \\<in># SDA'#} = mset (map Neg As)\n\ngoal (1 subgoal):\n 1. \\<exists>As'. negs (mset As') = SDA' \\<and> As' \\<cdot>al \\<eta> = As", "then"], ["proof (chain)\npicking this:\n  {#L \\<cdot>l \\<eta>. L \\<in># SDA'#} = mset (map Neg As)", "have \"\\<exists>NAs'. map (\\<lambda>L. L \\<cdot>l \\<eta>) NAs' = map Neg As \\<and> mset NAs' = SDA'\""], ["proof (prove)\nusing this:\n  {#L \\<cdot>l \\<eta>. L \\<in># SDA'#} = mset (map Neg As)\n\ngoal (1 subgoal):\n 1. \\<exists>NAs'.\n       map (\\<lambda>L. L \\<cdot>l \\<eta>) NAs' = map Neg As \\<and>\n       mset NAs' = SDA'", "using image_mset_of_subset_list[of \"\\<lambda>L. L \\<cdot>l \\<eta>\" SDA' \"map Neg As\"]"], ["proof (prove)\nusing this:\n  {#L \\<cdot>l \\<eta>. L \\<in># SDA'#} = mset (map Neg As)\n  {#L \\<cdot>l \\<eta>. L \\<in># SDA'#} = mset (map Neg As) \\<Longrightarrow>\n  \\<exists>qC'.\n     map (\\<lambda>L. L \\<cdot>l \\<eta>) qC' = map Neg As \\<and>\n     mset qC' = SDA'\n\ngoal (1 subgoal):\n 1. \\<exists>NAs'.\n       map (\\<lambda>L. L \\<cdot>l \\<eta>) NAs' = map Neg As \\<and>\n       mset NAs' = SDA'", "by auto"], ["proof (state)\nthis:\n  \\<exists>NAs'.\n     map (\\<lambda>L. L \\<cdot>l \\<eta>) NAs' = map Neg As \\<and>\n     mset NAs' = SDA'\n\ngoal (1 subgoal):\n 1. \\<exists>As'. negs (mset As') = SDA' \\<and> As' \\<cdot>al \\<eta> = As", "then"], ["proof (chain)\npicking this:\n  \\<exists>NAs'.\n     map (\\<lambda>L. L \\<cdot>l \\<eta>) NAs' = map Neg As \\<and>\n     mset NAs' = SDA'", "obtain As' where As'_p:\n    \"map (\\<lambda>L. L \\<cdot>l \\<eta>) (map Neg As') = map Neg As \\<and> mset (map Neg As') = SDA'\""], ["proof (prove)\nusing this:\n  \\<exists>NAs'.\n     map (\\<lambda>L. L \\<cdot>l \\<eta>) NAs' = map Neg As \\<and>\n     mset NAs' = SDA'\n\ngoal (1 subgoal):\n 1. (\\<And>As'.\n        map (\\<lambda>L. L \\<cdot>l \\<eta>) (map Neg As') =\n        map Neg As \\<and>\n        mset (map Neg As') = SDA' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis (no_types, lifting) Neg_atm_of_iff negL ex_map_conv set_mset_mset)"], ["proof (state)\nthis:\n  map (\\<lambda>L. L \\<cdot>l \\<eta>) (map Neg As') = map Neg As \\<and>\n  mset (map Neg As') = SDA'\n\ngoal (1 subgoal):\n 1. \\<exists>As'. negs (mset As') = SDA' \\<and> As' \\<cdot>al \\<eta> = As", "have \"negs (mset As') = SDA'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. negs (mset As') = SDA'", "using As'_p"], ["proof (prove)\nusing this:\n  map (\\<lambda>L. L \\<cdot>l \\<eta>) (map Neg As') = map Neg As \\<and>\n  mset (map Neg As') = SDA'\n\ngoal (1 subgoal):\n 1. negs (mset As') = SDA'", "by auto"], ["proof (state)\nthis:\n  negs (mset As') = SDA'\n\ngoal (1 subgoal):\n 1. \\<exists>As'. negs (mset As') = SDA' \\<and> As' \\<cdot>al \\<eta> = As", "moreover"], ["proof (state)\nthis:\n  negs (mset As') = SDA'\n\ngoal (1 subgoal):\n 1. \\<exists>As'. negs (mset As') = SDA' \\<and> As' \\<cdot>al \\<eta> = As", "have \"map (\\<lambda>L. L \\<cdot>l \\<eta>) (map Neg As') = map Neg As\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>L. L \\<cdot>l \\<eta>) (map Neg As') = map Neg As", "using As'_p"], ["proof (prove)\nusing this:\n  map (\\<lambda>L. L \\<cdot>l \\<eta>) (map Neg As') = map Neg As \\<and>\n  mset (map Neg As') = SDA'\n\ngoal (1 subgoal):\n 1. map (\\<lambda>L. L \\<cdot>l \\<eta>) (map Neg As') = map Neg As", "by auto"], ["proof (state)\nthis:\n  map (\\<lambda>L. L \\<cdot>l \\<eta>) (map Neg As') = map Neg As\n\ngoal (1 subgoal):\n 1. \\<exists>As'. negs (mset As') = SDA' \\<and> As' \\<cdot>al \\<eta> = As", "then"], ["proof (chain)\npicking this:\n  map (\\<lambda>L. L \\<cdot>l \\<eta>) (map Neg As') = map Neg As", "have \"As' \\<cdot>al \\<eta> = As\""], ["proof (prove)\nusing this:\n  map (\\<lambda>L. L \\<cdot>l \\<eta>) (map Neg As') = map Neg As\n\ngoal (1 subgoal):\n 1. As' \\<cdot>al \\<eta> = As", "using eql_map_neg_lit_eql_atm"], ["proof (prove)\nusing this:\n  map (\\<lambda>L. L \\<cdot>l \\<eta>) (map Neg As') = map Neg As\n  map (\\<lambda>L. L \\<cdot>l ?\\<eta>) (map Neg ?As') =\n  map Neg ?As \\<Longrightarrow>\n  ?As' \\<cdot>al ?\\<eta> = ?As\n\ngoal (1 subgoal):\n 1. As' \\<cdot>al \\<eta> = As", "by auto"], ["proof (state)\nthis:\n  As' \\<cdot>al \\<eta> = As\n\ngoal (1 subgoal):\n 1. \\<exists>As'. negs (mset As') = SDA' \\<and> As' \\<cdot>al \\<eta> = As", "ultimately"], ["proof (chain)\npicking this:\n  negs (mset As') = SDA'\n  As' \\<cdot>al \\<eta> = As", "show ?thesis"], ["proof (prove)\nusing this:\n  negs (mset As') = SDA'\n  As' \\<cdot>al \\<eta> = As\n\ngoal (1 subgoal):\n 1. \\<exists>As'. negs (mset As') = SDA' \\<and> As' \\<cdot>al \\<eta> = As", "by blast"], ["proof (state)\nthis:\n  \\<exists>As'. negs (mset As') = SDA' \\<and> As' \\<cdot>al \\<eta> = As\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map2_add_mset_map:\n  assumes \"length AAs' = n\" and \"length As' = n\"\n  shows \"map2 add_mset (As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>) = map2 add_mset As' AAs' \\<cdot>aml \\<eta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Map2.map2 add_mset (As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>) =\n    Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>", "using assms"], ["proof (prove)\nusing this:\n  length AAs' = n\n  length As' = n\n\ngoal (1 subgoal):\n 1. Map2.map2 add_mset (As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>) =\n    Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>", "proof (induction n arbitrary: AAs' As')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>AAs' As'.\n       \\<lbrakk>length AAs' = 0; length As' = 0\\<rbrakk>\n       \\<Longrightarrow> Map2.map2 add_mset (As' \\<cdot>al \\<eta>)\n                          (AAs' \\<cdot>aml \\<eta>) =\n                         Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>\n 2. \\<And>n AAs' As'.\n       \\<lbrakk>\\<And>AAs' As'.\n                   \\<lbrakk>length AAs' = n; length As' = n\\<rbrakk>\n                   \\<Longrightarrow> Map2.map2 add_mset\n(As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>) =\n                                     Map2.map2 add_mset As' AAs' \\<cdot>aml\n                                     \\<eta>;\n        length AAs' = Suc n; length As' = Suc n\\<rbrakk>\n       \\<Longrightarrow> Map2.map2 add_mset (As' \\<cdot>al \\<eta>)\n                          (AAs' \\<cdot>aml \\<eta>) =\n                         Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>length ?AAs' = n; length ?As' = n\\<rbrakk>\n  \\<Longrightarrow> Map2.map2 add_mset (?As' \\<cdot>al \\<eta>)\n                     (?AAs' \\<cdot>aml \\<eta>) =\n                    Map2.map2 add_mset ?As' ?AAs' \\<cdot>aml \\<eta>\n  length AAs' = Suc n\n  length As' = Suc n\n\ngoal (2 subgoals):\n 1. \\<And>AAs' As'.\n       \\<lbrakk>length AAs' = 0; length As' = 0\\<rbrakk>\n       \\<Longrightarrow> Map2.map2 add_mset (As' \\<cdot>al \\<eta>)\n                          (AAs' \\<cdot>aml \\<eta>) =\n                         Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>\n 2. \\<And>n AAs' As'.\n       \\<lbrakk>\\<And>AAs' As'.\n                   \\<lbrakk>length AAs' = n; length As' = n\\<rbrakk>\n                   \\<Longrightarrow> Map2.map2 add_mset\n(As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>) =\n                                     Map2.map2 add_mset As' AAs' \\<cdot>aml\n                                     \\<eta>;\n        length AAs' = Suc n; length As' = Suc n\\<rbrakk>\n       \\<Longrightarrow> Map2.map2 add_mset (As' \\<cdot>al \\<eta>)\n                          (AAs' \\<cdot>aml \\<eta>) =\n                         Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ?AAs' = n; length ?As' = n\\<rbrakk>\n  \\<Longrightarrow> Map2.map2 add_mset (?As' \\<cdot>al \\<eta>)\n                     (?AAs' \\<cdot>aml \\<eta>) =\n                    Map2.map2 add_mset ?As' ?AAs' \\<cdot>aml \\<eta>\n  length AAs' = Suc n\n  length As' = Suc n", "have \"map2 add_mset (tl (As' \\<cdot>al \\<eta>)) (tl (AAs' \\<cdot>aml \\<eta>)) = map2 add_mset (tl As') (tl AAs') \\<cdot>aml \\<eta>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?AAs' = n; length ?As' = n\\<rbrakk>\n  \\<Longrightarrow> Map2.map2 add_mset (?As' \\<cdot>al \\<eta>)\n                     (?AAs' \\<cdot>aml \\<eta>) =\n                    Map2.map2 add_mset ?As' ?AAs' \\<cdot>aml \\<eta>\n  length AAs' = Suc n\n  length As' = Suc n\n\ngoal (1 subgoal):\n 1. Map2.map2 add_mset (tl (As' \\<cdot>al \\<eta>))\n     (tl (AAs' \\<cdot>aml \\<eta>)) =\n    Map2.map2 add_mset (tl As') (tl AAs') \\<cdot>aml \\<eta>", "by simp"], ["proof (state)\nthis:\n  Map2.map2 add_mset (tl (As' \\<cdot>al \\<eta>))\n   (tl (AAs' \\<cdot>aml \\<eta>)) =\n  Map2.map2 add_mset (tl As') (tl AAs') \\<cdot>aml \\<eta>\n\ngoal (2 subgoals):\n 1. \\<And>AAs' As'.\n       \\<lbrakk>length AAs' = 0; length As' = 0\\<rbrakk>\n       \\<Longrightarrow> Map2.map2 add_mset (As' \\<cdot>al \\<eta>)\n                          (AAs' \\<cdot>aml \\<eta>) =\n                         Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>\n 2. \\<And>n AAs' As'.\n       \\<lbrakk>\\<And>AAs' As'.\n                   \\<lbrakk>length AAs' = n; length As' = n\\<rbrakk>\n                   \\<Longrightarrow> Map2.map2 add_mset\n(As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>) =\n                                     Map2.map2 add_mset As' AAs' \\<cdot>aml\n                                     \\<eta>;\n        length AAs' = Suc n; length As' = Suc n\\<rbrakk>\n       \\<Longrightarrow> Map2.map2 add_mset (As' \\<cdot>al \\<eta>)\n                          (AAs' \\<cdot>aml \\<eta>) =\n                         Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>", "moreover"], ["proof (state)\nthis:\n  Map2.map2 add_mset (tl (As' \\<cdot>al \\<eta>))\n   (tl (AAs' \\<cdot>aml \\<eta>)) =\n  Map2.map2 add_mset (tl As') (tl AAs') \\<cdot>aml \\<eta>\n\ngoal (2 subgoals):\n 1. \\<And>AAs' As'.\n       \\<lbrakk>length AAs' = 0; length As' = 0\\<rbrakk>\n       \\<Longrightarrow> Map2.map2 add_mset (As' \\<cdot>al \\<eta>)\n                          (AAs' \\<cdot>aml \\<eta>) =\n                         Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>\n 2. \\<And>n AAs' As'.\n       \\<lbrakk>\\<And>AAs' As'.\n                   \\<lbrakk>length AAs' = n; length As' = n\\<rbrakk>\n                   \\<Longrightarrow> Map2.map2 add_mset\n(As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>) =\n                                     Map2.map2 add_mset As' AAs' \\<cdot>aml\n                                     \\<eta>;\n        length AAs' = Suc n; length As' = Suc n\\<rbrakk>\n       \\<Longrightarrow> Map2.map2 add_mset (As' \\<cdot>al \\<eta>)\n                          (AAs' \\<cdot>aml \\<eta>) =\n                         Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>", "have Succ: \"length (As' \\<cdot>al \\<eta>) = Suc n\" \"length (AAs' \\<cdot>aml \\<eta>) = Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (As' \\<cdot>al \\<eta>) = Suc n &&&\n    length (AAs' \\<cdot>aml \\<eta>) = Suc n", "using Suc(3) Suc(2)"], ["proof (prove)\nusing this:\n  length As' = Suc n\n  length AAs' = Suc n\n\ngoal (1 subgoal):\n 1. length (As' \\<cdot>al \\<eta>) = Suc n &&&\n    length (AAs' \\<cdot>aml \\<eta>) = Suc n", "by auto"], ["proof (state)\nthis:\n  length (As' \\<cdot>al \\<eta>) = Suc n\n  length (AAs' \\<cdot>aml \\<eta>) = Suc n\n\ngoal (2 subgoals):\n 1. \\<And>AAs' As'.\n       \\<lbrakk>length AAs' = 0; length As' = 0\\<rbrakk>\n       \\<Longrightarrow> Map2.map2 add_mset (As' \\<cdot>al \\<eta>)\n                          (AAs' \\<cdot>aml \\<eta>) =\n                         Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>\n 2. \\<And>n AAs' As'.\n       \\<lbrakk>\\<And>AAs' As'.\n                   \\<lbrakk>length AAs' = n; length As' = n\\<rbrakk>\n                   \\<Longrightarrow> Map2.map2 add_mset\n(As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>) =\n                                     Map2.map2 add_mset As' AAs' \\<cdot>aml\n                                     \\<eta>;\n        length AAs' = Suc n; length As' = Suc n\\<rbrakk>\n       \\<Longrightarrow> Map2.map2 add_mset (As' \\<cdot>al \\<eta>)\n                          (AAs' \\<cdot>aml \\<eta>) =\n                         Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>", "then"], ["proof (chain)\npicking this:\n  length (As' \\<cdot>al \\<eta>) = Suc n\n  length (AAs' \\<cdot>aml \\<eta>) = Suc n", "have \"length (tl (As' \\<cdot>al \\<eta>)) = n\" \"length (tl (AAs' \\<cdot>aml \\<eta>)) = n\""], ["proof (prove)\nusing this:\n  length (As' \\<cdot>al \\<eta>) = Suc n\n  length (AAs' \\<cdot>aml \\<eta>) = Suc n\n\ngoal (1 subgoal):\n 1. length (tl (As' \\<cdot>al \\<eta>)) = n &&&\n    length (tl (AAs' \\<cdot>aml \\<eta>)) = n", "by auto"], ["proof (state)\nthis:\n  length (tl (As' \\<cdot>al \\<eta>)) = n\n  length (tl (AAs' \\<cdot>aml \\<eta>)) = n\n\ngoal (2 subgoals):\n 1. \\<And>AAs' As'.\n       \\<lbrakk>length AAs' = 0; length As' = 0\\<rbrakk>\n       \\<Longrightarrow> Map2.map2 add_mset (As' \\<cdot>al \\<eta>)\n                          (AAs' \\<cdot>aml \\<eta>) =\n                         Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>\n 2. \\<And>n AAs' As'.\n       \\<lbrakk>\\<And>AAs' As'.\n                   \\<lbrakk>length AAs' = n; length As' = n\\<rbrakk>\n                   \\<Longrightarrow> Map2.map2 add_mset\n(As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>) =\n                                     Map2.map2 add_mset As' AAs' \\<cdot>aml\n                                     \\<eta>;\n        length AAs' = Suc n; length As' = Suc n\\<rbrakk>\n       \\<Longrightarrow> Map2.map2 add_mset (As' \\<cdot>al \\<eta>)\n                          (AAs' \\<cdot>aml \\<eta>) =\n                         Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>", "then"], ["proof (chain)\npicking this:\n  length (tl (As' \\<cdot>al \\<eta>)) = n\n  length (tl (AAs' \\<cdot>aml \\<eta>)) = n", "have \"length (map2 add_mset (tl (As' \\<cdot>al \\<eta>)) (tl (AAs' \\<cdot>aml \\<eta>))) = n\"\n    \"length (map2 add_mset (tl As') (tl AAs') \\<cdot>aml \\<eta>) = n\""], ["proof (prove)\nusing this:\n  length (tl (As' \\<cdot>al \\<eta>)) = n\n  length (tl (AAs' \\<cdot>aml \\<eta>)) = n\n\ngoal (1 subgoal):\n 1. length\n     (Map2.map2 add_mset (tl (As' \\<cdot>al \\<eta>))\n       (tl (AAs' \\<cdot>aml \\<eta>))) =\n    n &&&\n    length (Map2.map2 add_mset (tl As') (tl AAs') \\<cdot>aml \\<eta>) = n", "using Suc(2,3)"], ["proof (prove)\nusing this:\n  length (tl (As' \\<cdot>al \\<eta>)) = n\n  length (tl (AAs' \\<cdot>aml \\<eta>)) = n\n  length AAs' = Suc n\n  length As' = Suc n\n\ngoal (1 subgoal):\n 1. length\n     (Map2.map2 add_mset (tl (As' \\<cdot>al \\<eta>))\n       (tl (AAs' \\<cdot>aml \\<eta>))) =\n    n &&&\n    length (Map2.map2 add_mset (tl As') (tl AAs') \\<cdot>aml \\<eta>) = n", "by auto"], ["proof (state)\nthis:\n  length\n   (Map2.map2 add_mset (tl (As' \\<cdot>al \\<eta>))\n     (tl (AAs' \\<cdot>aml \\<eta>))) =\n  n\n  length (Map2.map2 add_mset (tl As') (tl AAs') \\<cdot>aml \\<eta>) = n\n\ngoal (2 subgoals):\n 1. \\<And>AAs' As'.\n       \\<lbrakk>length AAs' = 0; length As' = 0\\<rbrakk>\n       \\<Longrightarrow> Map2.map2 add_mset (As' \\<cdot>al \\<eta>)\n                          (AAs' \\<cdot>aml \\<eta>) =\n                         Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>\n 2. \\<And>n AAs' As'.\n       \\<lbrakk>\\<And>AAs' As'.\n                   \\<lbrakk>length AAs' = n; length As' = n\\<rbrakk>\n                   \\<Longrightarrow> Map2.map2 add_mset\n(As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>) =\n                                     Map2.map2 add_mset As' AAs' \\<cdot>aml\n                                     \\<eta>;\n        length AAs' = Suc n; length As' = Suc n\\<rbrakk>\n       \\<Longrightarrow> Map2.map2 add_mset (As' \\<cdot>al \\<eta>)\n                          (AAs' \\<cdot>aml \\<eta>) =\n                         Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>", "ultimately"], ["proof (chain)\npicking this:\n  Map2.map2 add_mset (tl (As' \\<cdot>al \\<eta>))\n   (tl (AAs' \\<cdot>aml \\<eta>)) =\n  Map2.map2 add_mset (tl As') (tl AAs') \\<cdot>aml \\<eta>\n  length\n   (Map2.map2 add_mset (tl (As' \\<cdot>al \\<eta>))\n     (tl (AAs' \\<cdot>aml \\<eta>))) =\n  n\n  length (Map2.map2 add_mset (tl As') (tl AAs') \\<cdot>aml \\<eta>) = n", "have \"\\<forall>i < n. tl (map2 add_mset ( (As' \\<cdot>al \\<eta>)) ((AAs' \\<cdot>aml \\<eta>))) ! i =\n    tl (map2 add_mset (As') (AAs') \\<cdot>aml \\<eta>) ! i\""], ["proof (prove)\nusing this:\n  Map2.map2 add_mset (tl (As' \\<cdot>al \\<eta>))\n   (tl (AAs' \\<cdot>aml \\<eta>)) =\n  Map2.map2 add_mset (tl As') (tl AAs') \\<cdot>aml \\<eta>\n  length\n   (Map2.map2 add_mset (tl (As' \\<cdot>al \\<eta>))\n     (tl (AAs' \\<cdot>aml \\<eta>))) =\n  n\n  length (Map2.map2 add_mset (tl As') (tl AAs') \\<cdot>aml \\<eta>) = n\n\ngoal (1 subgoal):\n 1. \\<forall>i<n.\n       tl (Map2.map2 add_mset (As' \\<cdot>al \\<eta>)\n            (AAs' \\<cdot>aml \\<eta>)) !\n       i =\n       tl (Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>) ! i", "using Suc(2,3) Succ"], ["proof (prove)\nusing this:\n  Map2.map2 add_mset (tl (As' \\<cdot>al \\<eta>))\n   (tl (AAs' \\<cdot>aml \\<eta>)) =\n  Map2.map2 add_mset (tl As') (tl AAs') \\<cdot>aml \\<eta>\n  length\n   (Map2.map2 add_mset (tl (As' \\<cdot>al \\<eta>))\n     (tl (AAs' \\<cdot>aml \\<eta>))) =\n  n\n  length (Map2.map2 add_mset (tl As') (tl AAs') \\<cdot>aml \\<eta>) = n\n  length AAs' = Suc n\n  length As' = Suc n\n  length (As' \\<cdot>al \\<eta>) = Suc n\n  length (AAs' \\<cdot>aml \\<eta>) = Suc n\n\ngoal (1 subgoal):\n 1. \\<forall>i<n.\n       tl (Map2.map2 add_mset (As' \\<cdot>al \\<eta>)\n            (AAs' \\<cdot>aml \\<eta>)) !\n       i =\n       tl (Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>) ! i", "by (simp add: map2_tl map_tl subst_atm_mset_list_def del: subst_atm_list_tl)"], ["proof (state)\nthis:\n  \\<forall>i<n.\n     tl (Map2.map2 add_mset (As' \\<cdot>al \\<eta>)\n          (AAs' \\<cdot>aml \\<eta>)) !\n     i =\n     tl (Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>) ! i\n\ngoal (2 subgoals):\n 1. \\<And>AAs' As'.\n       \\<lbrakk>length AAs' = 0; length As' = 0\\<rbrakk>\n       \\<Longrightarrow> Map2.map2 add_mset (As' \\<cdot>al \\<eta>)\n                          (AAs' \\<cdot>aml \\<eta>) =\n                         Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>\n 2. \\<And>n AAs' As'.\n       \\<lbrakk>\\<And>AAs' As'.\n                   \\<lbrakk>length AAs' = n; length As' = n\\<rbrakk>\n                   \\<Longrightarrow> Map2.map2 add_mset\n(As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>) =\n                                     Map2.map2 add_mset As' AAs' \\<cdot>aml\n                                     \\<eta>;\n        length AAs' = Suc n; length As' = Suc n\\<rbrakk>\n       \\<Longrightarrow> Map2.map2 add_mset (As' \\<cdot>al \\<eta>)\n                          (AAs' \\<cdot>aml \\<eta>) =\n                         Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>", "moreover"], ["proof (state)\nthis:\n  \\<forall>i<n.\n     tl (Map2.map2 add_mset (As' \\<cdot>al \\<eta>)\n          (AAs' \\<cdot>aml \\<eta>)) !\n     i =\n     tl (Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>) ! i\n\ngoal (2 subgoals):\n 1. \\<And>AAs' As'.\n       \\<lbrakk>length AAs' = 0; length As' = 0\\<rbrakk>\n       \\<Longrightarrow> Map2.map2 add_mset (As' \\<cdot>al \\<eta>)\n                          (AAs' \\<cdot>aml \\<eta>) =\n                         Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>\n 2. \\<And>n AAs' As'.\n       \\<lbrakk>\\<And>AAs' As'.\n                   \\<lbrakk>length AAs' = n; length As' = n\\<rbrakk>\n                   \\<Longrightarrow> Map2.map2 add_mset\n(As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>) =\n                                     Map2.map2 add_mset As' AAs' \\<cdot>aml\n                                     \\<eta>;\n        length AAs' = Suc n; length As' = Suc n\\<rbrakk>\n       \\<Longrightarrow> Map2.map2 add_mset (As' \\<cdot>al \\<eta>)\n                          (AAs' \\<cdot>aml \\<eta>) =\n                         Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>", "have nn: \"length (map2 add_mset ((As' \\<cdot>al \\<eta>)) ((AAs' \\<cdot>aml \\<eta>))) = Suc n\"\n    \"length (map2 add_mset (As') (AAs') \\<cdot>aml \\<eta>) = Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (Map2.map2 add_mset (As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>)) =\n    Suc n &&&\n    length (Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>) = Suc n", "using Succ Suc"], ["proof (prove)\nusing this:\n  length (As' \\<cdot>al \\<eta>) = Suc n\n  length (AAs' \\<cdot>aml \\<eta>) = Suc n\n  \\<lbrakk>length ?AAs' = n; length ?As' = n\\<rbrakk>\n  \\<Longrightarrow> Map2.map2 add_mset (?As' \\<cdot>al \\<eta>)\n                     (?AAs' \\<cdot>aml \\<eta>) =\n                    Map2.map2 add_mset ?As' ?AAs' \\<cdot>aml \\<eta>\n  length AAs' = Suc n\n  length As' = Suc n\n\ngoal (1 subgoal):\n 1. length\n     (Map2.map2 add_mset (As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>)) =\n    Suc n &&&\n    length (Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>) = Suc n", "by auto"], ["proof (state)\nthis:\n  length\n   (Map2.map2 add_mset (As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>)) =\n  Suc n\n  length (Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>) = Suc n\n\ngoal (2 subgoals):\n 1. \\<And>AAs' As'.\n       \\<lbrakk>length AAs' = 0; length As' = 0\\<rbrakk>\n       \\<Longrightarrow> Map2.map2 add_mset (As' \\<cdot>al \\<eta>)\n                          (AAs' \\<cdot>aml \\<eta>) =\n                         Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>\n 2. \\<And>n AAs' As'.\n       \\<lbrakk>\\<And>AAs' As'.\n                   \\<lbrakk>length AAs' = n; length As' = n\\<rbrakk>\n                   \\<Longrightarrow> Map2.map2 add_mset\n(As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>) =\n                                     Map2.map2 add_mset As' AAs' \\<cdot>aml\n                                     \\<eta>;\n        length AAs' = Suc n; length As' = Suc n\\<rbrakk>\n       \\<Longrightarrow> Map2.map2 add_mset (As' \\<cdot>al \\<eta>)\n                          (AAs' \\<cdot>aml \\<eta>) =\n                         Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>i<n.\n     tl (Map2.map2 add_mset (As' \\<cdot>al \\<eta>)\n          (AAs' \\<cdot>aml \\<eta>)) !\n     i =\n     tl (Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>) ! i\n  length\n   (Map2.map2 add_mset (As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>)) =\n  Suc n\n  length (Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>) = Suc n", "have \"\\<forall>i. i < Suc n \\<longrightarrow> i > 0 \\<longrightarrow>\n    map2 add_mset (As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>) ! i = (map2 add_mset As' AAs' \\<cdot>aml \\<eta>) ! i\""], ["proof (prove)\nusing this:\n  \\<forall>i<n.\n     tl (Map2.map2 add_mset (As' \\<cdot>al \\<eta>)\n          (AAs' \\<cdot>aml \\<eta>)) !\n     i =\n     tl (Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>) ! i\n  length\n   (Map2.map2 add_mset (As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>)) =\n  Suc n\n  length (Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>) = Suc n\n\ngoal (1 subgoal):\n 1. \\<forall>i<Suc n.\n       0 < i \\<longrightarrow>\n       Map2.map2 add_mset (As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>) !\n       i =\n       (Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>) ! i", "by (auto simp: subst_atm_mset_list_def gr0_conv_Suc subst_atm_mset_def)"], ["proof (state)\nthis:\n  \\<forall>i<Suc n.\n     0 < i \\<longrightarrow>\n     Map2.map2 add_mset (As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>) !\n     i =\n     (Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>) ! i\n\ngoal (2 subgoals):\n 1. \\<And>AAs' As'.\n       \\<lbrakk>length AAs' = 0; length As' = 0\\<rbrakk>\n       \\<Longrightarrow> Map2.map2 add_mset (As' \\<cdot>al \\<eta>)\n                          (AAs' \\<cdot>aml \\<eta>) =\n                         Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>\n 2. \\<And>n AAs' As'.\n       \\<lbrakk>\\<And>AAs' As'.\n                   \\<lbrakk>length AAs' = n; length As' = n\\<rbrakk>\n                   \\<Longrightarrow> Map2.map2 add_mset\n(As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>) =\n                                     Map2.map2 add_mset As' AAs' \\<cdot>aml\n                                     \\<eta>;\n        length AAs' = Suc n; length As' = Suc n\\<rbrakk>\n       \\<Longrightarrow> Map2.map2 add_mset (As' \\<cdot>al \\<eta>)\n                          (AAs' \\<cdot>aml \\<eta>) =\n                         Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>", "moreover"], ["proof (state)\nthis:\n  \\<forall>i<Suc n.\n     0 < i \\<longrightarrow>\n     Map2.map2 add_mset (As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>) !\n     i =\n     (Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>) ! i\n\ngoal (2 subgoals):\n 1. \\<And>AAs' As'.\n       \\<lbrakk>length AAs' = 0; length As' = 0\\<rbrakk>\n       \\<Longrightarrow> Map2.map2 add_mset (As' \\<cdot>al \\<eta>)\n                          (AAs' \\<cdot>aml \\<eta>) =\n                         Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>\n 2. \\<And>n AAs' As'.\n       \\<lbrakk>\\<And>AAs' As'.\n                   \\<lbrakk>length AAs' = n; length As' = n\\<rbrakk>\n                   \\<Longrightarrow> Map2.map2 add_mset\n(As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>) =\n                                     Map2.map2 add_mset As' AAs' \\<cdot>aml\n                                     \\<eta>;\n        length AAs' = Suc n; length As' = Suc n\\<rbrakk>\n       \\<Longrightarrow> Map2.map2 add_mset (As' \\<cdot>al \\<eta>)\n                          (AAs' \\<cdot>aml \\<eta>) =\n                         Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>", "have \"add_mset (hd As' \\<cdot>a \\<eta>) (hd AAs' \\<cdot>am \\<eta>) = add_mset (hd As') (hd AAs') \\<cdot>am \\<eta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_mset (hd As' \\<cdot>a \\<eta>) (hd AAs' \\<cdot>am \\<eta>) =\n    add_mset (hd As') (hd AAs') \\<cdot>am \\<eta>", "unfolding subst_atm_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. add_mset (hd As' \\<cdot>a \\<eta>)\n     {#A \\<cdot>a \\<eta>. A \\<in># hd AAs'#} =\n    {#A \\<cdot>a \\<eta>. A \\<in># add_mset (hd As') (hd AAs')#}", "by auto"], ["proof (state)\nthis:\n  add_mset (hd As' \\<cdot>a \\<eta>) (hd AAs' \\<cdot>am \\<eta>) =\n  add_mset (hd As') (hd AAs') \\<cdot>am \\<eta>\n\ngoal (2 subgoals):\n 1. \\<And>AAs' As'.\n       \\<lbrakk>length AAs' = 0; length As' = 0\\<rbrakk>\n       \\<Longrightarrow> Map2.map2 add_mset (As' \\<cdot>al \\<eta>)\n                          (AAs' \\<cdot>aml \\<eta>) =\n                         Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>\n 2. \\<And>n AAs' As'.\n       \\<lbrakk>\\<And>AAs' As'.\n                   \\<lbrakk>length AAs' = n; length As' = n\\<rbrakk>\n                   \\<Longrightarrow> Map2.map2 add_mset\n(As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>) =\n                                     Map2.map2 add_mset As' AAs' \\<cdot>aml\n                                     \\<eta>;\n        length AAs' = Suc n; length As' = Suc n\\<rbrakk>\n       \\<Longrightarrow> Map2.map2 add_mset (As' \\<cdot>al \\<eta>)\n                          (AAs' \\<cdot>aml \\<eta>) =\n                         Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>", "then"], ["proof (chain)\npicking this:\n  add_mset (hd As' \\<cdot>a \\<eta>) (hd AAs' \\<cdot>am \\<eta>) =\n  add_mset (hd As') (hd AAs') \\<cdot>am \\<eta>", "have \"(map2 add_mset (As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>)) ! 0  = (map2 add_mset (As') (AAs') \\<cdot>aml \\<eta>) ! 0\""], ["proof (prove)\nusing this:\n  add_mset (hd As' \\<cdot>a \\<eta>) (hd AAs' \\<cdot>am \\<eta>) =\n  add_mset (hd As') (hd AAs') \\<cdot>am \\<eta>\n\ngoal (1 subgoal):\n 1. Map2.map2 add_mset (As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>) ! 0 =\n    (Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>) ! 0", "using Suc"], ["proof (prove)\nusing this:\n  add_mset (hd As' \\<cdot>a \\<eta>) (hd AAs' \\<cdot>am \\<eta>) =\n  add_mset (hd As') (hd AAs') \\<cdot>am \\<eta>\n  \\<lbrakk>length ?AAs' = n; length ?As' = n\\<rbrakk>\n  \\<Longrightarrow> Map2.map2 add_mset (?As' \\<cdot>al \\<eta>)\n                     (?AAs' \\<cdot>aml \\<eta>) =\n                    Map2.map2 add_mset ?As' ?AAs' \\<cdot>aml \\<eta>\n  length AAs' = Suc n\n  length As' = Suc n\n\ngoal (1 subgoal):\n 1. Map2.map2 add_mset (As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>) ! 0 =\n    (Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>) ! 0", "by (simp add: Succ(2) subst_atm_mset_def)"], ["proof (state)\nthis:\n  Map2.map2 add_mset (As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>) ! 0 =\n  (Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>) ! 0\n\ngoal (2 subgoals):\n 1. \\<And>AAs' As'.\n       \\<lbrakk>length AAs' = 0; length As' = 0\\<rbrakk>\n       \\<Longrightarrow> Map2.map2 add_mset (As' \\<cdot>al \\<eta>)\n                          (AAs' \\<cdot>aml \\<eta>) =\n                         Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>\n 2. \\<And>n AAs' As'.\n       \\<lbrakk>\\<And>AAs' As'.\n                   \\<lbrakk>length AAs' = n; length As' = n\\<rbrakk>\n                   \\<Longrightarrow> Map2.map2 add_mset\n(As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>) =\n                                     Map2.map2 add_mset As' AAs' \\<cdot>aml\n                                     \\<eta>;\n        length AAs' = Suc n; length As' = Suc n\\<rbrakk>\n       \\<Longrightarrow> Map2.map2 add_mset (As' \\<cdot>al \\<eta>)\n                          (AAs' \\<cdot>aml \\<eta>) =\n                         Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>i<Suc n.\n     0 < i \\<longrightarrow>\n     Map2.map2 add_mset (As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>) !\n     i =\n     (Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>) ! i\n  Map2.map2 add_mset (As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>) ! 0 =\n  (Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>) ! 0", "have \"\\<forall>i < Suc n. (map2 add_mset (As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>)) ! i =\n    (map2 add_mset (As') (AAs') \\<cdot>aml \\<eta>) ! i\""], ["proof (prove)\nusing this:\n  \\<forall>i<Suc n.\n     0 < i \\<longrightarrow>\n     Map2.map2 add_mset (As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>) !\n     i =\n     (Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>) ! i\n  Map2.map2 add_mset (As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>) ! 0 =\n  (Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>) ! 0\n\ngoal (1 subgoal):\n 1. \\<forall>i<Suc n.\n       Map2.map2 add_mset (As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>) !\n       i =\n       (Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>) ! i", "using Suc"], ["proof (prove)\nusing this:\n  \\<forall>i<Suc n.\n     0 < i \\<longrightarrow>\n     Map2.map2 add_mset (As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>) !\n     i =\n     (Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>) ! i\n  Map2.map2 add_mset (As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>) ! 0 =\n  (Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>) ! 0\n  \\<lbrakk>length ?AAs' = n; length ?As' = n\\<rbrakk>\n  \\<Longrightarrow> Map2.map2 add_mset (?As' \\<cdot>al \\<eta>)\n                     (?AAs' \\<cdot>aml \\<eta>) =\n                    Map2.map2 add_mset ?As' ?AAs' \\<cdot>aml \\<eta>\n  length AAs' = Suc n\n  length As' = Suc n\n\ngoal (1 subgoal):\n 1. \\<forall>i<Suc n.\n       Map2.map2 add_mset (As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>) !\n       i =\n       (Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>) ! i", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<Suc n.\n     Map2.map2 add_mset (As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>) !\n     i =\n     (Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>) ! i\n\ngoal (2 subgoals):\n 1. \\<And>AAs' As'.\n       \\<lbrakk>length AAs' = 0; length As' = 0\\<rbrakk>\n       \\<Longrightarrow> Map2.map2 add_mset (As' \\<cdot>al \\<eta>)\n                          (AAs' \\<cdot>aml \\<eta>) =\n                         Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>\n 2. \\<And>n AAs' As'.\n       \\<lbrakk>\\<And>AAs' As'.\n                   \\<lbrakk>length AAs' = n; length As' = n\\<rbrakk>\n                   \\<Longrightarrow> Map2.map2 add_mset\n(As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>) =\n                                     Map2.map2 add_mset As' AAs' \\<cdot>aml\n                                     \\<eta>;\n        length AAs' = Suc n; length As' = Suc n\\<rbrakk>\n       \\<Longrightarrow> Map2.map2 add_mset (As' \\<cdot>al \\<eta>)\n                          (AAs' \\<cdot>aml \\<eta>) =\n                         Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<Suc n.\n     Map2.map2 add_mset (As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>) !\n     i =\n     (Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>) ! i", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>i<Suc n.\n     Map2.map2 add_mset (As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>) !\n     i =\n     (Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>) ! i\n\ngoal (1 subgoal):\n 1. Map2.map2 add_mset (As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>) =\n    Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>", "using nn list_eq_iff_nth_eq"], ["proof (prove)\nusing this:\n  \\<forall>i<Suc n.\n     Map2.map2 add_mset (As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>) !\n     i =\n     (Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>) ! i\n  length\n   (Map2.map2 add_mset (As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>)) =\n  Suc n\n  length (Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>) = Suc n\n  (?xs = ?ys) =\n  (length ?xs = length ?ys \\<and>\n   (\\<forall>i<length ?xs. ?xs ! i = ?ys ! i))\n\ngoal (1 subgoal):\n 1. Map2.map2 add_mset (As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>) =\n    Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>", "by metis"], ["proof (state)\nthis:\n  Map2.map2 add_mset (As' \\<cdot>al \\<eta>) (AAs' \\<cdot>aml \\<eta>) =\n  Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>\n\ngoal (1 subgoal):\n 1. \\<And>AAs' As'.\n       \\<lbrakk>length AAs' = 0; length As' = 0\\<rbrakk>\n       \\<Longrightarrow> Map2.map2 add_mset (As' \\<cdot>al \\<eta>)\n                          (AAs' \\<cdot>aml \\<eta>) =\n                         Map2.map2 add_mset As' AAs' \\<cdot>aml \\<eta>", "qed auto"], ["", "context\n  fixes S :: \"'a clause \\<Rightarrow> 'a clause\"\nbegin"], ["", "subsection \\<open>Calculus\\<close>"], ["", "text \\<open>\nThe following corresponds to Figure 4.\n\\<close>"], ["", "definition maximal_wrt :: \"'a \\<Rightarrow> 'a literal multiset \\<Rightarrow> bool\" where\n  \"maximal_wrt A C \\<longleftrightarrow> (\\<forall>B \\<in> atms_of C. \\<not> less_atm A B)\""], ["", "definition strictly_maximal_wrt :: \"'a \\<Rightarrow> 'a literal multiset \\<Rightarrow> bool\" where\n  \"strictly_maximal_wrt A C \\<equiv> \\<forall>B \\<in> atms_of C. A \\<noteq> B \\<and> \\<not> less_atm A B\""], ["", "lemma strictly_maximal_wrt_maximal_wrt: \"strictly_maximal_wrt A C \\<Longrightarrow> maximal_wrt A C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strictly_maximal_wrt A C \\<Longrightarrow> maximal_wrt A C", "unfolding maximal_wrt_def strictly_maximal_wrt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>B\\<in>atms_of C.\n       A \\<noteq> B \\<and> \\<not> less_atm A B \\<Longrightarrow>\n    \\<forall>B\\<in>atms_of C. \\<not> less_atm A B", "by auto"], ["", "lemma maximal_wrt_subst: \"maximal_wrt (A \\<cdot>a \\<sigma>) (C \\<cdot> \\<sigma>) \\<Longrightarrow> maximal_wrt A C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maximal_wrt (A \\<cdot>a \\<sigma>) (C \\<cdot> \\<sigma>) \\<Longrightarrow>\n    maximal_wrt A C", "unfolding maximal_wrt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>B\\<in>atms_of (C \\<cdot> \\<sigma>).\n       \\<not> less_atm (A \\<cdot>a \\<sigma>) B \\<Longrightarrow>\n    \\<forall>B\\<in>atms_of C. \\<not> less_atm A B", "using in_atms_of_subst less_atm_stable"], ["proof (prove)\nusing this:\n  ?B \\<in> atms_of ?C \\<Longrightarrow>\n  ?B \\<cdot>a ?\\<sigma> \\<in> atms_of (?C \\<cdot> ?\\<sigma>)\n  less_atm ?A ?B \\<Longrightarrow>\n  less_atm (?A \\<cdot>a ?\\<sigma>) (?B \\<cdot>a ?\\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<forall>B\\<in>atms_of (C \\<cdot> \\<sigma>).\n       \\<not> less_atm (A \\<cdot>a \\<sigma>) B \\<Longrightarrow>\n    \\<forall>B\\<in>atms_of C. \\<not> less_atm A B", "by blast"], ["", "lemma strictly_maximal_wrt_subst:\n  \"strictly_maximal_wrt (A \\<cdot>a \\<sigma>) (C \\<cdot> \\<sigma>) \\<Longrightarrow> strictly_maximal_wrt A C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strictly_maximal_wrt (A \\<cdot>a \\<sigma>)\n     (C \\<cdot> \\<sigma>) \\<Longrightarrow>\n    strictly_maximal_wrt A C", "unfolding strictly_maximal_wrt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>B\\<in>atms_of (C \\<cdot> \\<sigma>).\n       A \\<cdot>a \\<sigma> \\<noteq> B \\<and>\n       \\<not> less_atm (A \\<cdot>a \\<sigma>) B \\<Longrightarrow>\n    \\<forall>B\\<in>atms_of C. A \\<noteq> B \\<and> \\<not> less_atm A B", "using in_atms_of_subst less_atm_stable"], ["proof (prove)\nusing this:\n  ?B \\<in> atms_of ?C \\<Longrightarrow>\n  ?B \\<cdot>a ?\\<sigma> \\<in> atms_of (?C \\<cdot> ?\\<sigma>)\n  less_atm ?A ?B \\<Longrightarrow>\n  less_atm (?A \\<cdot>a ?\\<sigma>) (?B \\<cdot>a ?\\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<forall>B\\<in>atms_of (C \\<cdot> \\<sigma>).\n       A \\<cdot>a \\<sigma> \\<noteq> B \\<and>\n       \\<not> less_atm (A \\<cdot>a \\<sigma>) B \\<Longrightarrow>\n    \\<forall>B\\<in>atms_of C. A \\<noteq> B \\<and> \\<not> less_atm A B", "by blast"], ["", "inductive eligible :: \"'s \\<Rightarrow> 'a list \\<Rightarrow> 'a clause \\<Rightarrow> bool\" where\n  eligible:\n    \"S DA = negs (mset As) \\<or> S DA = {#} \\<and> length As = 1 \\<and> maximal_wrt (As ! 0 \\<cdot>a \\<sigma>) (DA \\<cdot> \\<sigma>) \\<Longrightarrow>\n     eligible \\<sigma> As DA\""], ["", "inductive\n  ord_resolve\n  :: \"'a clause list \\<Rightarrow> 'a clause \\<Rightarrow> 'a multiset list \\<Rightarrow> 'a list \\<Rightarrow> 's \\<Rightarrow> 'a clause \\<Rightarrow> bool\"\nwhere\n  ord_resolve:\n    \"length CAs = n \\<Longrightarrow>\n     length Cs = n \\<Longrightarrow>\n     length AAs = n \\<Longrightarrow>\n     length As = n \\<Longrightarrow>\n     n \\<noteq> 0 \\<Longrightarrow>\n     (\\<forall>i < n. CAs ! i = Cs ! i + poss (AAs ! i)) \\<Longrightarrow>\n     (\\<forall>i < n. AAs ! i \\<noteq> {#}) \\<Longrightarrow>\n     Some \\<sigma> = mgu (set_mset ` set (map2 add_mset As AAs)) \\<Longrightarrow>\n     eligible \\<sigma> As (D + negs (mset As)) \\<Longrightarrow>\n     (\\<forall>i < n. strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>) (Cs ! i \\<cdot> \\<sigma>)) \\<Longrightarrow>\n     (\\<forall>i < n. S (CAs ! i) = {#}) \\<Longrightarrow>\n     ord_resolve CAs (D + negs (mset As)) AAs As \\<sigma> ((\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>)\""], ["", "inductive\n  ord_resolve_rename\n  :: \"'a clause list \\<Rightarrow> 'a clause \\<Rightarrow> 'a multiset list \\<Rightarrow> 'a list \\<Rightarrow> 's \\<Rightarrow> 'a clause \\<Rightarrow> bool\"\nwhere\n  ord_resolve_rename:\n    \"length CAs = n \\<Longrightarrow>\n     length AAs = n \\<Longrightarrow>\n     length As = n \\<Longrightarrow>\n     (\\<forall>i < n. poss (AAs ! i) \\<subseteq># CAs ! i) \\<Longrightarrow>\n     negs (mset As) \\<subseteq># DA \\<Longrightarrow>\n     \\<rho> = hd (renamings_apart (DA # CAs)) \\<Longrightarrow>\n     \\<rho>s = tl (renamings_apart (DA # CAs)) \\<Longrightarrow>\n     ord_resolve (CAs \\<cdot>\\<cdot>cl \\<rho>s) (DA \\<cdot> \\<rho>) (AAs \\<cdot>\\<cdot>aml \\<rho>s) (As \\<cdot>al \\<rho>) \\<sigma> E \\<Longrightarrow>\n     ord_resolve_rename CAs DA AAs As \\<sigma> E\""], ["", "lemma ord_resolve_empty_main_prem: \"\\<not> ord_resolve Cs {#} AAs As \\<sigma> E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> ord_resolve Cs {#} AAs As \\<sigma> E", "by (simp add: ord_resolve.simps)"], ["", "lemma ord_resolve_rename_empty_main_prem: \"\\<not> ord_resolve_rename Cs {#} AAs As \\<sigma> E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> ord_resolve_rename Cs {#} AAs As \\<sigma> E", "by (simp add: ord_resolve_empty_main_prem ord_resolve_rename.simps)"], ["", "subsection \\<open>Soundness\\<close>"], ["", "text \\<open>\nSoundness is not discussed in the chapter, but it is an important property.\n\\<close>"], ["", "lemma ord_resolve_ground_inst_sound:\n  assumes\n    res_e: \"ord_resolve CAs DA AAs As \\<sigma> E\" and\n    cc_inst_true: \"I \\<Turnstile>m mset CAs \\<cdot>cm \\<sigma> \\<cdot>cm \\<eta>\" and\n    d_inst_true: \"I \\<Turnstile> DA \\<cdot> \\<sigma> \\<cdot> \\<eta>\" and\n    ground_subst_\\<eta>: \"is_ground_subst \\<eta>\"\n  shows \"I \\<Turnstile> E \\<cdot> \\<eta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<Turnstile> E \\<cdot> \\<eta>", "using res_e"], ["proof (prove)\nusing this:\n  ord_resolve CAs DA AAs As \\<sigma> E\n\ngoal (1 subgoal):\n 1. I \\<Turnstile> E \\<cdot> \\<eta>", "proof (cases rule: ord_resolve.cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> I \\<Turnstile> E \\<cdot> \\<eta>", "case (ord_resolve n Cs D)"], ["proof (state)\nthis:\n  DA = D + negs (mset As)\n  E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  n \\<noteq> 0\n  \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i)\n  \\<forall>i<n. AAs ! i \\<noteq> {#}\n  Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs))\n  eligible \\<sigma> As (D + negs (mset As))\n  \\<forall>i<n.\n     strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n      (Cs ! i \\<cdot> \\<sigma>)\n  \\<forall>i<n. S (CAs ! i) = {#}\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> I \\<Turnstile> E \\<cdot> \\<eta>", "note da = this(1) and e = this(2) and cas_len = this(3) and cs_len = this(4) and\n    aas_len = this(5) and as_len = this(6) and cas = this(8) and mgu = this(10) and\n    len = this(1)"], ["proof (state)\nthis:\n  DA = D + negs (mset As)\n  E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i)\n  Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs))\n  DA = D + negs (mset As)\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> I \\<Turnstile> E \\<cdot> \\<eta>", "have len: \"length CAs = length As\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length CAs = length As", "using as_len cas_len"], ["proof (prove)\nusing this:\n  length As = n\n  length CAs = n\n\ngoal (1 subgoal):\n 1. length CAs = length As", "by auto"], ["proof (state)\nthis:\n  length CAs = length As\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> I \\<Turnstile> E \\<cdot> \\<eta>", "have \"is_ground_subst (\\<sigma> \\<odot> \\<eta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_subst (\\<sigma> \\<odot> \\<eta>)", "using ground_subst_\\<eta>"], ["proof (prove)\nusing this:\n  is_ground_subst \\<eta>\n\ngoal (1 subgoal):\n 1. is_ground_subst (\\<sigma> \\<odot> \\<eta>)", "by (rule is_ground_comp_subst)"], ["proof (state)\nthis:\n  is_ground_subst (\\<sigma> \\<odot> \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> I \\<Turnstile> E \\<cdot> \\<eta>", "then"], ["proof (chain)\npicking this:\n  is_ground_subst (\\<sigma> \\<odot> \\<eta>)", "have cc_true: \"I \\<Turnstile>m mset CAs \\<cdot>cm \\<sigma> \\<cdot>cm \\<eta>\" and d_true: \"I \\<Turnstile> DA \\<cdot> \\<sigma> \\<cdot> \\<eta>\""], ["proof (prove)\nusing this:\n  is_ground_subst (\\<sigma> \\<odot> \\<eta>)\n\ngoal (1 subgoal):\n 1. I \\<Turnstile>m mset CAs \\<cdot>cm \\<sigma> \\<cdot>cm \\<eta> &&&\n    I \\<Turnstile> DA \\<cdot> \\<sigma> \\<cdot> \\<eta>", "using cc_inst_true d_inst_true"], ["proof (prove)\nusing this:\n  is_ground_subst (\\<sigma> \\<odot> \\<eta>)\n  I \\<Turnstile>m mset CAs \\<cdot>cm \\<sigma> \\<cdot>cm \\<eta>\n  I \\<Turnstile> DA \\<cdot> \\<sigma> \\<cdot> \\<eta>\n\ngoal (1 subgoal):\n 1. I \\<Turnstile>m mset CAs \\<cdot>cm \\<sigma> \\<cdot>cm \\<eta> &&&\n    I \\<Turnstile> DA \\<cdot> \\<sigma> \\<cdot> \\<eta>", "by auto"], ["proof (state)\nthis:\n  I \\<Turnstile>m mset CAs \\<cdot>cm \\<sigma> \\<cdot>cm \\<eta>\n  I \\<Turnstile> DA \\<cdot> \\<sigma> \\<cdot> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> I \\<Turnstile> E \\<cdot> \\<eta>", "from mgu"], ["proof (chain)\npicking this:\n  Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs))", "have unif: \"\\<forall>i < n. \\<forall>A\\<in>#AAs ! i. A \\<cdot>a \\<sigma> = As ! i \\<cdot>a \\<sigma>\""], ["proof (prove)\nusing this:\n  Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs))\n\ngoal (1 subgoal):\n 1. \\<forall>i<n.\n       \\<forall>A\\<in>#AAs ! i.\n          A \\<cdot>a \\<sigma> = As ! i \\<cdot>a \\<sigma>", "using mgu_unifier as_len aas_len"], ["proof (prove)\nusing this:\n  Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs))\n  \\<lbrakk>length ?As = ?n; length ?AAs = ?n;\n   Some ?\\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset ?As ?AAs));\n   ?i < ?n; ?A \\<in># ?AAs ! ?i\\<rbrakk>\n  \\<Longrightarrow> ?A \\<cdot>a ?\\<sigma> = ?As ! ?i \\<cdot>a ?\\<sigma>\n  length As = n\n  length AAs = n\n\ngoal (1 subgoal):\n 1. \\<forall>i<n.\n       \\<forall>A\\<in>#AAs ! i.\n          A \\<cdot>a \\<sigma> = As ! i \\<cdot>a \\<sigma>", "by blast"], ["proof (state)\nthis:\n  \\<forall>i<n.\n     \\<forall>A\\<in>#AAs ! i. A \\<cdot>a \\<sigma> = As ! i \\<cdot>a \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> I \\<Turnstile> E \\<cdot> \\<eta>", "show \"I \\<Turnstile> E \\<cdot> \\<eta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<Turnstile> E \\<cdot> \\<eta>", "proof (cases \"\\<forall>A \\<in> set As. A \\<cdot>a \\<sigma> \\<cdot>a \\<eta> \\<in> I\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>A\\<in>set As.\n       A \\<cdot>a \\<sigma> \\<cdot>a \\<eta> \\<in> I \\<Longrightarrow>\n    I \\<Turnstile> E \\<cdot> \\<eta>\n 2. \\<not> (\\<forall>A\\<in>set As.\n               A \\<cdot>a \\<sigma> \\<cdot>a \\<eta>\n               \\<in> I) \\<Longrightarrow>\n    I \\<Turnstile> E \\<cdot> \\<eta>", "case True"], ["proof (state)\nthis:\n  \\<forall>A\\<in>set As. A \\<cdot>a \\<sigma> \\<cdot>a \\<eta> \\<in> I\n\ngoal (2 subgoals):\n 1. \\<forall>A\\<in>set As.\n       A \\<cdot>a \\<sigma> \\<cdot>a \\<eta> \\<in> I \\<Longrightarrow>\n    I \\<Turnstile> E \\<cdot> \\<eta>\n 2. \\<not> (\\<forall>A\\<in>set As.\n               A \\<cdot>a \\<sigma> \\<cdot>a \\<eta>\n               \\<in> I) \\<Longrightarrow>\n    I \\<Turnstile> E \\<cdot> \\<eta>", "then"], ["proof (chain)\npicking this:\n  \\<forall>A\\<in>set As. A \\<cdot>a \\<sigma> \\<cdot>a \\<eta> \\<in> I", "have \"\\<not> I \\<Turnstile> negs (mset As) \\<cdot> \\<sigma> \\<cdot> \\<eta>\""], ["proof (prove)\nusing this:\n  \\<forall>A\\<in>set As. A \\<cdot>a \\<sigma> \\<cdot>a \\<eta> \\<in> I\n\ngoal (1 subgoal):\n 1. \\<not> I \\<Turnstile> negs (mset As) \\<cdot> \\<sigma> \\<cdot> \\<eta>", "unfolding true_cls_def[of I]"], ["proof (prove)\nusing this:\n  \\<forall>A\\<in>set As. A \\<cdot>a \\<sigma> \\<cdot>a \\<eta> \\<in> I\n\ngoal (1 subgoal):\n 1. \\<not> Multiset.Bex (negs (mset As) \\<cdot> \\<sigma> \\<cdot> \\<eta>)\n            ((\\<Turnstile>l) I)", "by auto"], ["proof (state)\nthis:\n  \\<not> I \\<Turnstile> negs (mset As) \\<cdot> \\<sigma> \\<cdot> \\<eta>\n\ngoal (2 subgoals):\n 1. \\<forall>A\\<in>set As.\n       A \\<cdot>a \\<sigma> \\<cdot>a \\<eta> \\<in> I \\<Longrightarrow>\n    I \\<Turnstile> E \\<cdot> \\<eta>\n 2. \\<not> (\\<forall>A\\<in>set As.\n               A \\<cdot>a \\<sigma> \\<cdot>a \\<eta>\n               \\<in> I) \\<Longrightarrow>\n    I \\<Turnstile> E \\<cdot> \\<eta>", "then"], ["proof (chain)\npicking this:\n  \\<not> I \\<Turnstile> negs (mset As) \\<cdot> \\<sigma> \\<cdot> \\<eta>", "have \"I \\<Turnstile> D \\<cdot> \\<sigma> \\<cdot> \\<eta>\""], ["proof (prove)\nusing this:\n  \\<not> I \\<Turnstile> negs (mset As) \\<cdot> \\<sigma> \\<cdot> \\<eta>\n\ngoal (1 subgoal):\n 1. I \\<Turnstile> D \\<cdot> \\<sigma> \\<cdot> \\<eta>", "using d_true da"], ["proof (prove)\nusing this:\n  \\<not> I \\<Turnstile> negs (mset As) \\<cdot> \\<sigma> \\<cdot> \\<eta>\n  I \\<Turnstile> DA \\<cdot> \\<sigma> \\<cdot> \\<eta>\n  DA = D + negs (mset As)\n\ngoal (1 subgoal):\n 1. I \\<Turnstile> D \\<cdot> \\<sigma> \\<cdot> \\<eta>", "by auto"], ["proof (state)\nthis:\n  I \\<Turnstile> D \\<cdot> \\<sigma> \\<cdot> \\<eta>\n\ngoal (2 subgoals):\n 1. \\<forall>A\\<in>set As.\n       A \\<cdot>a \\<sigma> \\<cdot>a \\<eta> \\<in> I \\<Longrightarrow>\n    I \\<Turnstile> E \\<cdot> \\<eta>\n 2. \\<not> (\\<forall>A\\<in>set As.\n               A \\<cdot>a \\<sigma> \\<cdot>a \\<eta>\n               \\<in> I) \\<Longrightarrow>\n    I \\<Turnstile> E \\<cdot> \\<eta>", "then"], ["proof (chain)\npicking this:\n  I \\<Turnstile> D \\<cdot> \\<sigma> \\<cdot> \\<eta>", "show ?thesis"], ["proof (prove)\nusing this:\n  I \\<Turnstile> D \\<cdot> \\<sigma> \\<cdot> \\<eta>\n\ngoal (1 subgoal):\n 1. I \\<Turnstile> E \\<cdot> \\<eta>", "unfolding e"], ["proof (prove)\nusing this:\n  I \\<Turnstile> D \\<cdot> \\<sigma> \\<cdot> \\<eta>\n\ngoal (1 subgoal):\n 1. I \\<Turnstile>\n    (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma> \\<cdot> \\<eta>", "by auto"], ["proof (state)\nthis:\n  I \\<Turnstile> E \\<cdot> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>A\\<in>set As.\n               A \\<cdot>a \\<sigma> \\<cdot>a \\<eta>\n               \\<in> I) \\<Longrightarrow>\n    I \\<Turnstile> E \\<cdot> \\<eta>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>A\\<in>set As.\n               A \\<cdot>a \\<sigma> \\<cdot>a \\<eta>\n               \\<in> I) \\<Longrightarrow>\n    I \\<Turnstile> E \\<cdot> \\<eta>", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<forall>A\\<in>set As.\n             A \\<cdot>a \\<sigma> \\<cdot>a \\<eta> \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>A\\<in>set As.\n               A \\<cdot>a \\<sigma> \\<cdot>a \\<eta>\n               \\<in> I) \\<Longrightarrow>\n    I \\<Turnstile> E \\<cdot> \\<eta>", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>A\\<in>set As.\n             A \\<cdot>a \\<sigma> \\<cdot>a \\<eta> \\<in> I)", "obtain i where a_in_aa: \"i < length CAs\" and a_false: \"(As ! i) \\<cdot>a \\<sigma> \\<cdot>a \\<eta> \\<notin> I\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>A\\<in>set As.\n             A \\<cdot>a \\<sigma> \\<cdot>a \\<eta> \\<in> I)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length CAs;\n         As ! i \\<cdot>a \\<sigma> \\<cdot>a \\<eta> \\<notin> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using da len"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>A\\<in>set As.\n             A \\<cdot>a \\<sigma> \\<cdot>a \\<eta> \\<in> I)\n  DA = D + negs (mset As)\n  length CAs = length As\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length CAs;\n         As ! i \\<cdot>a \\<sigma> \\<cdot>a \\<eta> \\<notin> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis in_set_conv_nth)"], ["proof (state)\nthis:\n  i < length CAs\n  As ! i \\<cdot>a \\<sigma> \\<cdot>a \\<eta> \\<notin> I\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>A\\<in>set As.\n               A \\<cdot>a \\<sigma> \\<cdot>a \\<eta>\n               \\<in> I) \\<Longrightarrow>\n    I \\<Turnstile> E \\<cdot> \\<eta>", "define C where \"C \\<equiv> Cs ! i\""], ["proof (state)\nthis:\n  C \\<equiv> Cs ! i\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>A\\<in>set As.\n               A \\<cdot>a \\<sigma> \\<cdot>a \\<eta>\n               \\<in> I) \\<Longrightarrow>\n    I \\<Turnstile> E \\<cdot> \\<eta>", "define BB where \"BB \\<equiv> AAs ! i\""], ["proof (state)\nthis:\n  BB \\<equiv> AAs ! i\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>A\\<in>set As.\n               A \\<cdot>a \\<sigma> \\<cdot>a \\<eta>\n               \\<in> I) \\<Longrightarrow>\n    I \\<Turnstile> E \\<cdot> \\<eta>", "have c_cf': \"C \\<subseteq># \\<Sum>\\<^sub># (mset CAs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<subseteq># \\<Sum>\\<^sub># (mset CAs)", "unfolding C_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cs ! i \\<subseteq># \\<Sum>\\<^sub># (mset CAs)", "using a_in_aa cas cas_len"], ["proof (prove)\nusing this:\n  i < length CAs\n  \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i)\n  length CAs = n\n\ngoal (1 subgoal):\n 1. Cs ! i \\<subseteq># \\<Sum>\\<^sub># (mset CAs)", "by (metis less_subset_eq_Union_mset mset_subset_eq_add_left subset_mset.order.trans)"], ["proof (state)\nthis:\n  C \\<subseteq># \\<Sum>\\<^sub># (mset CAs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>A\\<in>set As.\n               A \\<cdot>a \\<sigma> \\<cdot>a \\<eta>\n               \\<in> I) \\<Longrightarrow>\n    I \\<Turnstile> E \\<cdot> \\<eta>", "have c_in_cc: \"C + poss BB \\<in># mset CAs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C + poss BB \\<in># mset CAs", "using C_def BB_def a_in_aa cas_len in_set_conv_nth cas"], ["proof (prove)\nusing this:\n  C \\<equiv> Cs ! i\n  BB \\<equiv> AAs ! i\n  i < length CAs\n  length CAs = n\n  (?x \\<in> set ?xs) = (\\<exists>i<length ?xs. ?xs ! i = ?x)\n  \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i)\n\ngoal (1 subgoal):\n 1. C + poss BB \\<in># mset CAs", "by fastforce"], ["proof (state)\nthis:\n  C + poss BB \\<in># mset CAs\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>A\\<in>set As.\n               A \\<cdot>a \\<sigma> \\<cdot>a \\<eta>\n               \\<in> I) \\<Longrightarrow>\n    I \\<Turnstile> E \\<cdot> \\<eta>", "{"], ["proof (state)\nthis:\n  C + poss BB \\<in># mset CAs\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>A\\<in>set As.\n               A \\<cdot>a \\<sigma> \\<cdot>a \\<eta>\n               \\<in> I) \\<Longrightarrow>\n    I \\<Turnstile> E \\<cdot> \\<eta>", "fix B"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>A\\<in>set As.\n               A \\<cdot>a \\<sigma> \\<cdot>a \\<eta>\n               \\<in> I) \\<Longrightarrow>\n    I \\<Turnstile> E \\<cdot> \\<eta>", "assume \"B \\<in># BB\""], ["proof (state)\nthis:\n  B \\<in># BB\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>A\\<in>set As.\n               A \\<cdot>a \\<sigma> \\<cdot>a \\<eta>\n               \\<in> I) \\<Longrightarrow>\n    I \\<Turnstile> E \\<cdot> \\<eta>", "then"], ["proof (chain)\npicking this:\n  B \\<in># BB", "have \"B \\<cdot>a \\<sigma> = (As ! i) \\<cdot>a \\<sigma>\""], ["proof (prove)\nusing this:\n  B \\<in># BB\n\ngoal (1 subgoal):\n 1. B \\<cdot>a \\<sigma> = As ! i \\<cdot>a \\<sigma>", "using unif a_in_aa cas_len"], ["proof (prove)\nusing this:\n  B \\<in># BB\n  \\<forall>i<n.\n     \\<forall>A\\<in>#AAs ! i. A \\<cdot>a \\<sigma> = As ! i \\<cdot>a \\<sigma>\n  i < length CAs\n  length CAs = n\n\ngoal (1 subgoal):\n 1. B \\<cdot>a \\<sigma> = As ! i \\<cdot>a \\<sigma>", "unfolding BB_def"], ["proof (prove)\nusing this:\n  B \\<in># AAs ! i\n  \\<forall>i<n.\n     \\<forall>A\\<in>#AAs ! i. A \\<cdot>a \\<sigma> = As ! i \\<cdot>a \\<sigma>\n  i < length CAs\n  length CAs = n\n\ngoal (1 subgoal):\n 1. B \\<cdot>a \\<sigma> = As ! i \\<cdot>a \\<sigma>", "by auto"], ["proof (state)\nthis:\n  B \\<cdot>a \\<sigma> = As ! i \\<cdot>a \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>A\\<in>set As.\n               A \\<cdot>a \\<sigma> \\<cdot>a \\<eta>\n               \\<in> I) \\<Longrightarrow>\n    I \\<Turnstile> E \\<cdot> \\<eta>", "}"], ["proof (state)\nthis:\n  ?B2 \\<in># BB \\<Longrightarrow>\n  ?B2 \\<cdot>a \\<sigma> = As ! i \\<cdot>a \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>A\\<in>set As.\n               A \\<cdot>a \\<sigma> \\<cdot>a \\<eta>\n               \\<in> I) \\<Longrightarrow>\n    I \\<Turnstile> E \\<cdot> \\<eta>", "then"], ["proof (chain)\npicking this:\n  ?B2 \\<in># BB \\<Longrightarrow>\n  ?B2 \\<cdot>a \\<sigma> = As ! i \\<cdot>a \\<sigma>", "have \"\\<not> I \\<Turnstile> poss BB \\<cdot> \\<sigma> \\<cdot> \\<eta>\""], ["proof (prove)\nusing this:\n  ?B2 \\<in># BB \\<Longrightarrow>\n  ?B2 \\<cdot>a \\<sigma> = As ! i \\<cdot>a \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> I \\<Turnstile> poss BB \\<cdot> \\<sigma> \\<cdot> \\<eta>", "using a_false"], ["proof (prove)\nusing this:\n  ?B2 \\<in># BB \\<Longrightarrow>\n  ?B2 \\<cdot>a \\<sigma> = As ! i \\<cdot>a \\<sigma>\n  As ! i \\<cdot>a \\<sigma> \\<cdot>a \\<eta> \\<notin> I\n\ngoal (1 subgoal):\n 1. \\<not> I \\<Turnstile> poss BB \\<cdot> \\<sigma> \\<cdot> \\<eta>", "by (auto simp: true_cls_def)"], ["proof (state)\nthis:\n  \\<not> I \\<Turnstile> poss BB \\<cdot> \\<sigma> \\<cdot> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>A\\<in>set As.\n               A \\<cdot>a \\<sigma> \\<cdot>a \\<eta>\n               \\<in> I) \\<Longrightarrow>\n    I \\<Turnstile> E \\<cdot> \\<eta>", "moreover"], ["proof (state)\nthis:\n  \\<not> I \\<Turnstile> poss BB \\<cdot> \\<sigma> \\<cdot> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>A\\<in>set As.\n               A \\<cdot>a \\<sigma> \\<cdot>a \\<eta>\n               \\<in> I) \\<Longrightarrow>\n    I \\<Turnstile> E \\<cdot> \\<eta>", "have \"I \\<Turnstile> (C + poss BB) \\<cdot> \\<sigma> \\<cdot> \\<eta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<Turnstile> (C + poss BB) \\<cdot> \\<sigma> \\<cdot> \\<eta>", "using c_in_cc cc_true true_cls_mset_true_cls[of I \"mset CAs \\<cdot>cm \\<sigma> \\<cdot>cm \\<eta>\"]"], ["proof (prove)\nusing this:\n  C + poss BB \\<in># mset CAs\n  I \\<Turnstile>m mset CAs \\<cdot>cm \\<sigma> \\<cdot>cm \\<eta>\n  \\<lbrakk>I \\<Turnstile>m mset CAs \\<cdot>cm \\<sigma> \\<cdot>cm \\<eta>;\n   ?C \\<in># mset CAs \\<cdot>cm \\<sigma> \\<cdot>cm \\<eta>\\<rbrakk>\n  \\<Longrightarrow> I \\<Turnstile> ?C\n\ngoal (1 subgoal):\n 1. I \\<Turnstile> (C + poss BB) \\<cdot> \\<sigma> \\<cdot> \\<eta>", "by force"], ["proof (state)\nthis:\n  I \\<Turnstile> (C + poss BB) \\<cdot> \\<sigma> \\<cdot> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>A\\<in>set As.\n               A \\<cdot>a \\<sigma> \\<cdot>a \\<eta>\n               \\<in> I) \\<Longrightarrow>\n    I \\<Turnstile> E \\<cdot> \\<eta>", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> I \\<Turnstile> poss BB \\<cdot> \\<sigma> \\<cdot> \\<eta>\n  I \\<Turnstile> (C + poss BB) \\<cdot> \\<sigma> \\<cdot> \\<eta>", "have \"I \\<Turnstile> C \\<cdot> \\<sigma> \\<cdot> \\<eta>\""], ["proof (prove)\nusing this:\n  \\<not> I \\<Turnstile> poss BB \\<cdot> \\<sigma> \\<cdot> \\<eta>\n  I \\<Turnstile> (C + poss BB) \\<cdot> \\<sigma> \\<cdot> \\<eta>\n\ngoal (1 subgoal):\n 1. I \\<Turnstile> C \\<cdot> \\<sigma> \\<cdot> \\<eta>", "by simp"], ["proof (state)\nthis:\n  I \\<Turnstile> C \\<cdot> \\<sigma> \\<cdot> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>A\\<in>set As.\n               A \\<cdot>a \\<sigma> \\<cdot>a \\<eta>\n               \\<in> I) \\<Longrightarrow>\n    I \\<Turnstile> E \\<cdot> \\<eta>", "then"], ["proof (chain)\npicking this:\n  I \\<Turnstile> C \\<cdot> \\<sigma> \\<cdot> \\<eta>", "show ?thesis"], ["proof (prove)\nusing this:\n  I \\<Turnstile> C \\<cdot> \\<sigma> \\<cdot> \\<eta>\n\ngoal (1 subgoal):\n 1. I \\<Turnstile> E \\<cdot> \\<eta>", "unfolding e subst_cls_union"], ["proof (prove)\nusing this:\n  I \\<Turnstile> C \\<cdot> \\<sigma> \\<cdot> \\<eta>\n\ngoal (1 subgoal):\n 1. I \\<Turnstile>\n    \\<Sum>\\<^sub># (mset Cs) \\<cdot> \\<sigma> \\<cdot> \\<eta> +\n    D \\<cdot> \\<sigma> \\<cdot> \\<eta>", "using c_cf' C_def a_in_aa cas_len cs_len"], ["proof (prove)\nusing this:\n  I \\<Turnstile> C \\<cdot> \\<sigma> \\<cdot> \\<eta>\n  C \\<subseteq># \\<Sum>\\<^sub># (mset CAs)\n  C \\<equiv> Cs ! i\n  i < length CAs\n  length CAs = n\n  length Cs = n\n\ngoal (1 subgoal):\n 1. I \\<Turnstile>\n    \\<Sum>\\<^sub># (mset Cs) \\<cdot> \\<sigma> \\<cdot> \\<eta> +\n    D \\<cdot> \\<sigma> \\<cdot> \\<eta>", "by (metis (no_types, lifting) mset_subset_eq_add_left nth_mem_mset set_mset_mono sum_mset.remove true_cls_mono subst_cls_mono)"], ["proof (state)\nthis:\n  I \\<Turnstile> E \\<cdot> \\<eta>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  I \\<Turnstile> E \\<cdot> \\<eta>\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nThe previous lemma is not only used to prove soundness, but also the following lemma which is\nused to prove Lemma 4.10.\n\\<close>"], ["", "lemma ord_resolve_rename_ground_inst_sound:\n  assumes\n    \"ord_resolve_rename CAs DA AAs As \\<sigma> E\" and\n    \"\\<rho>s = tl (renamings_apart (DA # CAs))\" and\n    \"\\<rho> = hd (renamings_apart (DA # CAs))\" and\n    \"I \\<Turnstile>m (mset (CAs \\<cdot>\\<cdot>cl \\<rho>s)) \\<cdot>cm \\<sigma> \\<cdot>cm \\<eta>\" and\n    \"I \\<Turnstile> DA \\<cdot> \\<rho> \\<cdot> \\<sigma> \\<cdot> \\<eta>\" and\n    \"is_ground_subst \\<eta>\"\n  shows \"I \\<Turnstile> E \\<cdot> \\<eta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<Turnstile> E \\<cdot> \\<eta>", "using assms"], ["proof (prove)\nusing this:\n  ord_resolve_rename CAs DA AAs As \\<sigma> E\n  \\<rho>s = tl (renamings_apart (DA # CAs))\n  \\<rho> = hd (renamings_apart (DA # CAs))\n  I \\<Turnstile>m\n  mset (CAs \\<cdot>\\<cdot>cl \\<rho>s) \\<cdot>cm \\<sigma> \\<cdot>cm \\<eta>\n  I \\<Turnstile> DA \\<cdot> \\<rho> \\<cdot> \\<sigma> \\<cdot> \\<eta>\n  is_ground_subst \\<eta>\n\ngoal (1 subgoal):\n 1. I \\<Turnstile> E \\<cdot> \\<eta>", "by (cases rule: ord_resolve_rename.cases) (fast intro: ord_resolve_ground_inst_sound)"], ["", "text \\<open>\nHere follows the soundness theorem for the resolution rule.\n\\<close>"], ["", "theorem ord_resolve_sound:\n assumes\n   res_e: \"ord_resolve CAs DA AAs As \\<sigma> E\" and\n   cc_d_true: \"\\<And>\\<sigma>. is_ground_subst \\<sigma> \\<Longrightarrow> I \\<Turnstile>m (mset CAs + {#DA#}) \\<cdot>cm \\<sigma>\" and\n   ground_subst_\\<eta>: \"is_ground_subst \\<eta>\"\n shows \"I \\<Turnstile> E \\<cdot> \\<eta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<Turnstile> E \\<cdot> \\<eta>", "proof (use res_e in \\<open>cases rule: ord_resolve.cases\\<close>)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> I \\<Turnstile> E \\<cdot> \\<eta>", "case (ord_resolve n Cs D)"], ["proof (state)\nthis:\n  DA = D + negs (mset As)\n  E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  n \\<noteq> 0\n  \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i)\n  \\<forall>i<n. AAs ! i \\<noteq> {#}\n  Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs))\n  eligible \\<sigma> As (D + negs (mset As))\n  \\<forall>i<n.\n     strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n      (Cs ! i \\<cdot> \\<sigma>)\n  \\<forall>i<n. S (CAs ! i) = {#}\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> I \\<Turnstile> E \\<cdot> \\<eta>", "note da = this(1) and e = this(2) and cas_len = this(3) and cs_len = this(4)\n    and aas_len = this(5) and as_len = this(6) and cas = this(8) and mgu = this(10)"], ["proof (state)\nthis:\n  DA = D + negs (mset As)\n  E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i)\n  Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs))\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> I \\<Turnstile> E \\<cdot> \\<eta>", "have ground_subst_\\<sigma>_\\<eta>: \"is_ground_subst (\\<sigma> \\<odot> \\<eta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_subst (\\<sigma> \\<odot> \\<eta>)", "using ground_subst_\\<eta>"], ["proof (prove)\nusing this:\n  is_ground_subst \\<eta>\n\ngoal (1 subgoal):\n 1. is_ground_subst (\\<sigma> \\<odot> \\<eta>)", "by (rule is_ground_comp_subst)"], ["proof (state)\nthis:\n  is_ground_subst (\\<sigma> \\<odot> \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> I \\<Turnstile> E \\<cdot> \\<eta>", "have cas_true: \"I \\<Turnstile>m mset CAs \\<cdot>cm \\<sigma> \\<cdot>cm \\<eta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<Turnstile>m mset CAs \\<cdot>cm \\<sigma> \\<cdot>cm \\<eta>", "using cc_d_true ground_subst_\\<sigma>_\\<eta>"], ["proof (prove)\nusing this:\n  is_ground_subst ?\\<sigma> \\<Longrightarrow>\n  I \\<Turnstile>m (mset CAs + {#DA#}) \\<cdot>cm ?\\<sigma>\n  is_ground_subst (\\<sigma> \\<odot> \\<eta>)\n\ngoal (1 subgoal):\n 1. I \\<Turnstile>m mset CAs \\<cdot>cm \\<sigma> \\<cdot>cm \\<eta>", "by fastforce"], ["proof (state)\nthis:\n  I \\<Turnstile>m mset CAs \\<cdot>cm \\<sigma> \\<cdot>cm \\<eta>\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> I \\<Turnstile> E \\<cdot> \\<eta>", "have da_true: \"I \\<Turnstile> DA \\<cdot> \\<sigma> \\<cdot> \\<eta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<Turnstile> DA \\<cdot> \\<sigma> \\<cdot> \\<eta>", "using cc_d_true ground_subst_\\<sigma>_\\<eta>"], ["proof (prove)\nusing this:\n  is_ground_subst ?\\<sigma> \\<Longrightarrow>\n  I \\<Turnstile>m (mset CAs + {#DA#}) \\<cdot>cm ?\\<sigma>\n  is_ground_subst (\\<sigma> \\<odot> \\<eta>)\n\ngoal (1 subgoal):\n 1. I \\<Turnstile> DA \\<cdot> \\<sigma> \\<cdot> \\<eta>", "by fastforce"], ["proof (state)\nthis:\n  I \\<Turnstile> DA \\<cdot> \\<sigma> \\<cdot> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> I \\<Turnstile> E \\<cdot> \\<eta>", "show \"I \\<Turnstile> E \\<cdot> \\<eta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<Turnstile> E \\<cdot> \\<eta>", "using ord_resolve_ground_inst_sound[OF res_e cas_true da_true] ground_subst_\\<eta>"], ["proof (prove)\nusing this:\n  is_ground_subst \\<eta> \\<Longrightarrow> I \\<Turnstile> E \\<cdot> \\<eta>\n  is_ground_subst \\<eta>\n\ngoal (1 subgoal):\n 1. I \\<Turnstile> E \\<cdot> \\<eta>", "by auto"], ["proof (state)\nthis:\n  I \\<Turnstile> E \\<cdot> \\<eta>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subst_sound:\n  assumes\n    \"\\<And>\\<sigma>. is_ground_subst \\<sigma> \\<Longrightarrow> I \\<Turnstile> C \\<cdot> \\<sigma>\" and\n    \"is_ground_subst \\<eta>\"\n  shows \"I \\<Turnstile> C \\<cdot> \\<rho> \\<cdot> \\<eta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<Turnstile> C \\<cdot> \\<rho> \\<cdot> \\<eta>", "using assms is_ground_comp_subst subst_cls_comp_subst"], ["proof (prove)\nusing this:\n  is_ground_subst ?\\<sigma> \\<Longrightarrow>\n  I \\<Turnstile> C \\<cdot> ?\\<sigma>\n  is_ground_subst \\<eta>\n  is_ground_subst ?\\<sigma> \\<Longrightarrow>\n  is_ground_subst (?\\<tau> \\<odot> ?\\<sigma>)\n  ?C \\<cdot> (?\\<tau> \\<odot> ?\\<sigma>) =\n  ?C \\<cdot> ?\\<tau> \\<cdot> ?\\<sigma>\n\ngoal (1 subgoal):\n 1. I \\<Turnstile> C \\<cdot> \\<rho> \\<cdot> \\<eta>", "by metis"], ["", "lemma subst_sound_scl:\n  assumes\n    len: \"length P = length CAs\" and\n    true_cas: \"\\<And>\\<sigma>. is_ground_subst \\<sigma> \\<Longrightarrow> I \\<Turnstile>m mset CAs \\<cdot>cm \\<sigma>\" and\n    ground_subst_\\<eta>: \"is_ground_subst \\<eta>\"\n  shows \"I \\<Turnstile>m mset (CAs \\<cdot>\\<cdot>cl P) \\<cdot>cm \\<eta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<Turnstile>m mset (CAs \\<cdot>\\<cdot>cl P) \\<cdot>cm \\<eta>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. I \\<Turnstile>m mset (CAs \\<cdot>\\<cdot>cl P) \\<cdot>cm \\<eta>", "from true_cas"], ["proof (chain)\npicking this:\n  is_ground_subst ?\\<sigma> \\<Longrightarrow>\n  I \\<Turnstile>m mset CAs \\<cdot>cm ?\\<sigma>", "have \"\\<And>CA. CA\\<in># mset CAs \\<Longrightarrow> (\\<And>\\<sigma>. is_ground_subst \\<sigma> \\<Longrightarrow> I \\<Turnstile> CA \\<cdot> \\<sigma>)\""], ["proof (prove)\nusing this:\n  is_ground_subst ?\\<sigma> \\<Longrightarrow>\n  I \\<Turnstile>m mset CAs \\<cdot>cm ?\\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>CA.\n       CA \\<in># mset CAs \\<Longrightarrow>\n       (\\<And>\\<sigma>.\n           is_ground_subst \\<sigma> \\<Longrightarrow>\n           I \\<Turnstile> CA \\<cdot> \\<sigma>)", "unfolding true_cls_mset_def"], ["proof (prove)\nusing this:\n  is_ground_subst ?\\<sigma> \\<Longrightarrow>\n  Multiset.Ball (mset CAs \\<cdot>cm ?\\<sigma>) ((\\<Turnstile>) I)\n\ngoal (1 subgoal):\n 1. \\<And>CA.\n       CA \\<in># mset CAs \\<Longrightarrow>\n       (\\<And>\\<sigma>.\n           is_ground_subst \\<sigma> \\<Longrightarrow>\n           I \\<Turnstile> CA \\<cdot> \\<sigma>)", "by force"], ["proof (state)\nthis:\n  \\<lbrakk>?CA \\<in># mset CAs; is_ground_subst ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> I \\<Turnstile> ?CA \\<cdot> ?\\<sigma>\n\ngoal (1 subgoal):\n 1. I \\<Turnstile>m mset (CAs \\<cdot>\\<cdot>cl P) \\<cdot>cm \\<eta>", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?CA \\<in># mset CAs; is_ground_subst ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> I \\<Turnstile> ?CA \\<cdot> ?\\<sigma>", "have \"\\<forall>i < length CAs. \\<forall>\\<sigma>. is_ground_subst \\<sigma> \\<longrightarrow> (I \\<Turnstile> CAs ! i \\<cdot> \\<sigma>)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?CA \\<in># mset CAs; is_ground_subst ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> I \\<Turnstile> ?CA \\<cdot> ?\\<sigma>\n\ngoal (1 subgoal):\n 1. \\<forall>i<length CAs.\n       \\<forall>\\<sigma>.\n          is_ground_subst \\<sigma> \\<longrightarrow>\n          I \\<Turnstile> CAs ! i \\<cdot> \\<sigma>", "using in_set_conv_nth"], ["proof (prove)\nusing this:\n  \\<lbrakk>?CA \\<in># mset CAs; is_ground_subst ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> I \\<Turnstile> ?CA \\<cdot> ?\\<sigma>\n  (?x \\<in> set ?xs) = (\\<exists>i<length ?xs. ?xs ! i = ?x)\n\ngoal (1 subgoal):\n 1. \\<forall>i<length CAs.\n       \\<forall>\\<sigma>.\n          is_ground_subst \\<sigma> \\<longrightarrow>\n          I \\<Turnstile> CAs ! i \\<cdot> \\<sigma>", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<length CAs.\n     \\<forall>\\<sigma>.\n        is_ground_subst \\<sigma> \\<longrightarrow>\n        I \\<Turnstile> CAs ! i \\<cdot> \\<sigma>\n\ngoal (1 subgoal):\n 1. I \\<Turnstile>m mset (CAs \\<cdot>\\<cdot>cl P) \\<cdot>cm \\<eta>", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<length CAs.\n     \\<forall>\\<sigma>.\n        is_ground_subst \\<sigma> \\<longrightarrow>\n        I \\<Turnstile> CAs ! i \\<cdot> \\<sigma>", "have true_cp: \"\\<forall>i < length CAs. \\<forall>\\<sigma>. is_ground_subst \\<sigma> \\<longrightarrow> I \\<Turnstile> CAs ! i \\<cdot> P ! i \\<cdot> \\<sigma>\""], ["proof (prove)\nusing this:\n  \\<forall>i<length CAs.\n     \\<forall>\\<sigma>.\n        is_ground_subst \\<sigma> \\<longrightarrow>\n        I \\<Turnstile> CAs ! i \\<cdot> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<forall>i<length CAs.\n       \\<forall>\\<sigma>.\n          is_ground_subst \\<sigma> \\<longrightarrow>\n          I \\<Turnstile> CAs ! i \\<cdot> P ! i \\<cdot> \\<sigma>", "using subst_sound len"], ["proof (prove)\nusing this:\n  \\<forall>i<length CAs.\n     \\<forall>\\<sigma>.\n        is_ground_subst \\<sigma> \\<longrightarrow>\n        I \\<Turnstile> CAs ! i \\<cdot> \\<sigma>\n  \\<lbrakk>\\<And>\\<sigma>.\n              is_ground_subst \\<sigma> \\<Longrightarrow>\n              ?I \\<Turnstile> ?C \\<cdot> \\<sigma>;\n   is_ground_subst ?\\<eta>\\<rbrakk>\n  \\<Longrightarrow> ?I \\<Turnstile> ?C \\<cdot> ?\\<rho> \\<cdot> ?\\<eta>\n  length P = length CAs\n\ngoal (1 subgoal):\n 1. \\<forall>i<length CAs.\n       \\<forall>\\<sigma>.\n          is_ground_subst \\<sigma> \\<longrightarrow>\n          I \\<Turnstile> CAs ! i \\<cdot> P ! i \\<cdot> \\<sigma>", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<length CAs.\n     \\<forall>\\<sigma>.\n        is_ground_subst \\<sigma> \\<longrightarrow>\n        I \\<Turnstile> CAs ! i \\<cdot> P ! i \\<cdot> \\<sigma>\n\ngoal (1 subgoal):\n 1. I \\<Turnstile>m mset (CAs \\<cdot>\\<cdot>cl P) \\<cdot>cm \\<eta>", "{"], ["proof (state)\nthis:\n  \\<forall>i<length CAs.\n     \\<forall>\\<sigma>.\n        is_ground_subst \\<sigma> \\<longrightarrow>\n        I \\<Turnstile> CAs ! i \\<cdot> P ! i \\<cdot> \\<sigma>\n\ngoal (1 subgoal):\n 1. I \\<Turnstile>m mset (CAs \\<cdot>\\<cdot>cl P) \\<cdot>cm \\<eta>", "fix CA"], ["proof (state)\ngoal (1 subgoal):\n 1. I \\<Turnstile>m mset (CAs \\<cdot>\\<cdot>cl P) \\<cdot>cm \\<eta>", "assume \"CA \\<in># mset (CAs \\<cdot>\\<cdot>cl P)\""], ["proof (state)\nthis:\n  CA \\<in># mset (CAs \\<cdot>\\<cdot>cl P)\n\ngoal (1 subgoal):\n 1. I \\<Turnstile>m mset (CAs \\<cdot>\\<cdot>cl P) \\<cdot>cm \\<eta>", "then"], ["proof (chain)\npicking this:\n  CA \\<in># mset (CAs \\<cdot>\\<cdot>cl P)", "obtain i where\n      i_x: \"i < length (CAs \\<cdot>\\<cdot>cl P)\" \"CA = (CAs \\<cdot>\\<cdot>cl P) ! i\""], ["proof (prove)\nusing this:\n  CA \\<in># mset (CAs \\<cdot>\\<cdot>cl P)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length (CAs \\<cdot>\\<cdot>cl P);\n         CA = (CAs \\<cdot>\\<cdot>cl P) ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis in_mset_conv_nth)"], ["proof (state)\nthis:\n  i < length (CAs \\<cdot>\\<cdot>cl P)\n  CA = (CAs \\<cdot>\\<cdot>cl P) ! i\n\ngoal (1 subgoal):\n 1. I \\<Turnstile>m mset (CAs \\<cdot>\\<cdot>cl P) \\<cdot>cm \\<eta>", "then"], ["proof (chain)\npicking this:\n  i < length (CAs \\<cdot>\\<cdot>cl P)\n  CA = (CAs \\<cdot>\\<cdot>cl P) ! i", "have \"\\<forall>\\<sigma>. is_ground_subst \\<sigma> \\<longrightarrow> I \\<Turnstile> CA \\<cdot> \\<sigma>\""], ["proof (prove)\nusing this:\n  i < length (CAs \\<cdot>\\<cdot>cl P)\n  CA = (CAs \\<cdot>\\<cdot>cl P) ! i\n\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       is_ground_subst \\<sigma> \\<longrightarrow>\n       I \\<Turnstile> CA \\<cdot> \\<sigma>", "using true_cp"], ["proof (prove)\nusing this:\n  i < length (CAs \\<cdot>\\<cdot>cl P)\n  CA = (CAs \\<cdot>\\<cdot>cl P) ! i\n  \\<forall>i<length CAs.\n     \\<forall>\\<sigma>.\n        is_ground_subst \\<sigma> \\<longrightarrow>\n        I \\<Turnstile> CAs ! i \\<cdot> P ! i \\<cdot> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       is_ground_subst \\<sigma> \\<longrightarrow>\n       I \\<Turnstile> CA \\<cdot> \\<sigma>", "unfolding subst_cls_lists_def"], ["proof (prove)\nusing this:\n  i < length (Map2.map2 (\\<cdot>) CAs P)\n  CA = Map2.map2 (\\<cdot>) CAs P ! i\n  \\<forall>i<length CAs.\n     \\<forall>\\<sigma>.\n        is_ground_subst \\<sigma> \\<longrightarrow>\n        I \\<Turnstile> CAs ! i \\<cdot> P ! i \\<cdot> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       is_ground_subst \\<sigma> \\<longrightarrow>\n       I \\<Turnstile> CA \\<cdot> \\<sigma>", "by (simp add: len)"], ["proof (state)\nthis:\n  \\<forall>\\<sigma>.\n     is_ground_subst \\<sigma> \\<longrightarrow>\n     I \\<Turnstile> CA \\<cdot> \\<sigma>\n\ngoal (1 subgoal):\n 1. I \\<Turnstile>m mset (CAs \\<cdot>\\<cdot>cl P) \\<cdot>cm \\<eta>", "}"], ["proof (state)\nthis:\n  ?CA2 \\<in># mset (CAs \\<cdot>\\<cdot>cl P) \\<Longrightarrow>\n  \\<forall>\\<sigma>.\n     is_ground_subst \\<sigma> \\<longrightarrow>\n     I \\<Turnstile> ?CA2 \\<cdot> \\<sigma>\n\ngoal (1 subgoal):\n 1. I \\<Turnstile>m mset (CAs \\<cdot>\\<cdot>cl P) \\<cdot>cm \\<eta>", "then"], ["proof (chain)\npicking this:\n  ?CA2 \\<in># mset (CAs \\<cdot>\\<cdot>cl P) \\<Longrightarrow>\n  \\<forall>\\<sigma>.\n     is_ground_subst \\<sigma> \\<longrightarrow>\n     I \\<Turnstile> ?CA2 \\<cdot> \\<sigma>", "show ?thesis"], ["proof (prove)\nusing this:\n  ?CA2 \\<in># mset (CAs \\<cdot>\\<cdot>cl P) \\<Longrightarrow>\n  \\<forall>\\<sigma>.\n     is_ground_subst \\<sigma> \\<longrightarrow>\n     I \\<Turnstile> ?CA2 \\<cdot> \\<sigma>\n\ngoal (1 subgoal):\n 1. I \\<Turnstile>m mset (CAs \\<cdot>\\<cdot>cl P) \\<cdot>cm \\<eta>", "using assms"], ["proof (prove)\nusing this:\n  ?CA2 \\<in># mset (CAs \\<cdot>\\<cdot>cl P) \\<Longrightarrow>\n  \\<forall>\\<sigma>.\n     is_ground_subst \\<sigma> \\<longrightarrow>\n     I \\<Turnstile> ?CA2 \\<cdot> \\<sigma>\n  length P = length CAs\n  is_ground_subst ?\\<sigma> \\<Longrightarrow>\n  I \\<Turnstile>m mset CAs \\<cdot>cm ?\\<sigma>\n  is_ground_subst \\<eta>\n\ngoal (1 subgoal):\n 1. I \\<Turnstile>m mset (CAs \\<cdot>\\<cdot>cl P) \\<cdot>cm \\<eta>", "unfolding true_cls_mset_def"], ["proof (prove)\nusing this:\n  ?CA2 \\<in># mset (CAs \\<cdot>\\<cdot>cl P) \\<Longrightarrow>\n  \\<forall>\\<sigma>.\n     is_ground_subst \\<sigma> \\<longrightarrow>\n     I \\<Turnstile> ?CA2 \\<cdot> \\<sigma>\n  length P = length CAs\n  is_ground_subst ?\\<sigma> \\<Longrightarrow>\n  Multiset.Ball (mset CAs \\<cdot>cm ?\\<sigma>) ((\\<Turnstile>) I)\n  is_ground_subst \\<eta>\n\ngoal (1 subgoal):\n 1. Multiset.Ball (mset (CAs \\<cdot>\\<cdot>cl P) \\<cdot>cm \\<eta>)\n     ((\\<Turnstile>) I)", "by auto"], ["proof (state)\nthis:\n  I \\<Turnstile>m mset (CAs \\<cdot>\\<cdot>cl P) \\<cdot>cm \\<eta>\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nHere follows the soundness theorem for the resolution rule with renaming.\n\\<close>"], ["", "lemma ord_resolve_rename_sound:\n  assumes\n    res_e: \"ord_resolve_rename CAs DA AAs As \\<sigma> E\" and\n    cc_d_true: \"\\<And>\\<sigma>. is_ground_subst \\<sigma> \\<Longrightarrow> I \\<Turnstile>m ((mset CAs) + {#DA#}) \\<cdot>cm \\<sigma>\" and\n    ground_subst_\\<eta>: \"is_ground_subst \\<eta>\"\n  shows \"I \\<Turnstile> E \\<cdot> \\<eta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<Turnstile> E \\<cdot> \\<eta>", "using res_e"], ["proof (prove)\nusing this:\n  ord_resolve_rename CAs DA AAs As \\<sigma> E\n\ngoal (1 subgoal):\n 1. I \\<Turnstile> E \\<cdot> \\<eta>", "proof (cases rule: ord_resolve_rename.cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n \\<rho> \\<rho>s.\n       \\<lbrakk>length CAs = n; length AAs = n; length As = n;\n        \\<forall>i<n. poss (AAs ! i) \\<subseteq># CAs ! i;\n        negs (mset As) \\<subseteq># DA;\n        \\<rho> = hd (renamings_apart (DA # CAs));\n        \\<rho>s = tl (renamings_apart (DA # CAs));\n        ord_resolve (CAs \\<cdot>\\<cdot>cl \\<rho>s) (DA \\<cdot> \\<rho>)\n         (AAs \\<cdot>\\<cdot>aml \\<rho>s) (As \\<cdot>al \\<rho>) \\<sigma>\n         E\\<rbrakk>\n       \\<Longrightarrow> I \\<Turnstile> E \\<cdot> \\<eta>", "case (ord_resolve_rename n \\<rho> \\<rho>s)"], ["proof (state)\nthis:\n  length CAs = n\n  length AAs = n\n  length As = n\n  \\<forall>i<n. poss (AAs ! i) \\<subseteq># CAs ! i\n  negs (mset As) \\<subseteq># DA\n  \\<rho> = hd (renamings_apart (DA # CAs))\n  \\<rho>s = tl (renamings_apart (DA # CAs))\n  ord_resolve (CAs \\<cdot>\\<cdot>cl \\<rho>s) (DA \\<cdot> \\<rho>)\n   (AAs \\<cdot>\\<cdot>aml \\<rho>s) (As \\<cdot>al \\<rho>) \\<sigma> E\n\ngoal (1 subgoal):\n 1. \\<And>n \\<rho> \\<rho>s.\n       \\<lbrakk>length CAs = n; length AAs = n; length As = n;\n        \\<forall>i<n. poss (AAs ! i) \\<subseteq># CAs ! i;\n        negs (mset As) \\<subseteq># DA;\n        \\<rho> = hd (renamings_apart (DA # CAs));\n        \\<rho>s = tl (renamings_apart (DA # CAs));\n        ord_resolve (CAs \\<cdot>\\<cdot>cl \\<rho>s) (DA \\<cdot> \\<rho>)\n         (AAs \\<cdot>\\<cdot>aml \\<rho>s) (As \\<cdot>al \\<rho>) \\<sigma>\n         E\\<rbrakk>\n       \\<Longrightarrow> I \\<Turnstile> E \\<cdot> \\<eta>", "note \\<rho>s = this(7) and res = this(8)"], ["proof (state)\nthis:\n  \\<rho>s = tl (renamings_apart (DA # CAs))\n  ord_resolve (CAs \\<cdot>\\<cdot>cl \\<rho>s) (DA \\<cdot> \\<rho>)\n   (AAs \\<cdot>\\<cdot>aml \\<rho>s) (As \\<cdot>al \\<rho>) \\<sigma> E\n\ngoal (1 subgoal):\n 1. \\<And>n \\<rho> \\<rho>s.\n       \\<lbrakk>length CAs = n; length AAs = n; length As = n;\n        \\<forall>i<n. poss (AAs ! i) \\<subseteq># CAs ! i;\n        negs (mset As) \\<subseteq># DA;\n        \\<rho> = hd (renamings_apart (DA # CAs));\n        \\<rho>s = tl (renamings_apart (DA # CAs));\n        ord_resolve (CAs \\<cdot>\\<cdot>cl \\<rho>s) (DA \\<cdot> \\<rho>)\n         (AAs \\<cdot>\\<cdot>aml \\<rho>s) (As \\<cdot>al \\<rho>) \\<sigma>\n         E\\<rbrakk>\n       \\<Longrightarrow> I \\<Turnstile> E \\<cdot> \\<eta>", "have len: \"length \\<rho>s = length CAs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length \\<rho>s = length CAs", "using \\<rho>s renamings_apart_length"], ["proof (prove)\nusing this:\n  \\<rho>s = tl (renamings_apart (DA # CAs))\n  length (renamings_apart ?Cs) = length ?Cs\n\ngoal (1 subgoal):\n 1. length \\<rho>s = length CAs", "by auto"], ["proof (state)\nthis:\n  length \\<rho>s = length CAs\n\ngoal (1 subgoal):\n 1. \\<And>n \\<rho> \\<rho>s.\n       \\<lbrakk>length CAs = n; length AAs = n; length As = n;\n        \\<forall>i<n. poss (AAs ! i) \\<subseteq># CAs ! i;\n        negs (mset As) \\<subseteq># DA;\n        \\<rho> = hd (renamings_apart (DA # CAs));\n        \\<rho>s = tl (renamings_apart (DA # CAs));\n        ord_resolve (CAs \\<cdot>\\<cdot>cl \\<rho>s) (DA \\<cdot> \\<rho>)\n         (AAs \\<cdot>\\<cdot>aml \\<rho>s) (As \\<cdot>al \\<rho>) \\<sigma>\n         E\\<rbrakk>\n       \\<Longrightarrow> I \\<Turnstile> E \\<cdot> \\<eta>", "have \"\\<And>\\<sigma>. is_ground_subst \\<sigma> \\<Longrightarrow> I \\<Turnstile>m (mset (CAs \\<cdot>\\<cdot>cl \\<rho>s) + {#DA \\<cdot> \\<rho>#}) \\<cdot>cm \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       is_ground_subst \\<sigma> \\<Longrightarrow>\n       I \\<Turnstile>m\n       (mset (CAs \\<cdot>\\<cdot>cl \\<rho>s) +\n        {#DA \\<cdot> \\<rho>#}) \\<cdot>cm\n       \\<sigma>", "using subst_sound_scl[OF len, of I] subst_sound cc_d_true"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>\\<sigma>.\n              is_ground_subst \\<sigma> \\<Longrightarrow>\n              I \\<Turnstile>m mset CAs \\<cdot>cm \\<sigma>;\n   is_ground_subst ?\\<eta>\\<rbrakk>\n  \\<Longrightarrow> I \\<Turnstile>m\n                    mset (CAs \\<cdot>\\<cdot>cl \\<rho>s) \\<cdot>cm ?\\<eta>\n  \\<lbrakk>\\<And>\\<sigma>.\n              is_ground_subst \\<sigma> \\<Longrightarrow>\n              ?I \\<Turnstile> ?C \\<cdot> \\<sigma>;\n   is_ground_subst ?\\<eta>\\<rbrakk>\n  \\<Longrightarrow> ?I \\<Turnstile> ?C \\<cdot> ?\\<rho> \\<cdot> ?\\<eta>\n  is_ground_subst ?\\<sigma> \\<Longrightarrow>\n  I \\<Turnstile>m (mset CAs + {#DA#}) \\<cdot>cm ?\\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       is_ground_subst \\<sigma> \\<Longrightarrow>\n       I \\<Turnstile>m\n       (mset (CAs \\<cdot>\\<cdot>cl \\<rho>s) +\n        {#DA \\<cdot> \\<rho>#}) \\<cdot>cm\n       \\<sigma>", "by auto"], ["proof (state)\nthis:\n  is_ground_subst ?\\<sigma> \\<Longrightarrow>\n  I \\<Turnstile>m\n  (mset (CAs \\<cdot>\\<cdot>cl \\<rho>s) + {#DA \\<cdot> \\<rho>#}) \\<cdot>cm\n  ?\\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>n \\<rho> \\<rho>s.\n       \\<lbrakk>length CAs = n; length AAs = n; length As = n;\n        \\<forall>i<n. poss (AAs ! i) \\<subseteq># CAs ! i;\n        negs (mset As) \\<subseteq># DA;\n        \\<rho> = hd (renamings_apart (DA # CAs));\n        \\<rho>s = tl (renamings_apart (DA # CAs));\n        ord_resolve (CAs \\<cdot>\\<cdot>cl \\<rho>s) (DA \\<cdot> \\<rho>)\n         (AAs \\<cdot>\\<cdot>aml \\<rho>s) (As \\<cdot>al \\<rho>) \\<sigma>\n         E\\<rbrakk>\n       \\<Longrightarrow> I \\<Turnstile> E \\<cdot> \\<eta>", "then"], ["proof (chain)\npicking this:\n  is_ground_subst ?\\<sigma> \\<Longrightarrow>\n  I \\<Turnstile>m\n  (mset (CAs \\<cdot>\\<cdot>cl \\<rho>s) + {#DA \\<cdot> \\<rho>#}) \\<cdot>cm\n  ?\\<sigma>", "show \"I \\<Turnstile> E \\<cdot> \\<eta>\""], ["proof (prove)\nusing this:\n  is_ground_subst ?\\<sigma> \\<Longrightarrow>\n  I \\<Turnstile>m\n  (mset (CAs \\<cdot>\\<cdot>cl \\<rho>s) + {#DA \\<cdot> \\<rho>#}) \\<cdot>cm\n  ?\\<sigma>\n\ngoal (1 subgoal):\n 1. I \\<Turnstile> E \\<cdot> \\<eta>", "using ground_subst_\\<eta> ord_resolve_sound[OF res]"], ["proof (prove)\nusing this:\n  is_ground_subst ?\\<sigma> \\<Longrightarrow>\n  I \\<Turnstile>m\n  (mset (CAs \\<cdot>\\<cdot>cl \\<rho>s) + {#DA \\<cdot> \\<rho>#}) \\<cdot>cm\n  ?\\<sigma>\n  is_ground_subst \\<eta>\n  \\<lbrakk>\\<And>\\<sigma>.\n              is_ground_subst \\<sigma> \\<Longrightarrow>\n              ?I \\<Turnstile>m\n              (mset (CAs \\<cdot>\\<cdot>cl \\<rho>s) +\n               {#DA \\<cdot> \\<rho>#}) \\<cdot>cm\n              \\<sigma>;\n   is_ground_subst ?\\<eta>\\<rbrakk>\n  \\<Longrightarrow> ?I \\<Turnstile> E \\<cdot> ?\\<eta>\n\ngoal (1 subgoal):\n 1. I \\<Turnstile> E \\<cdot> \\<eta>", "by simp"], ["proof (state)\nthis:\n  I \\<Turnstile> E \\<cdot> \\<eta>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Other Basic Properties\\<close>"], ["", "lemma ord_resolve_unique:\n  assumes\n    \"ord_resolve CAs DA AAs As \\<sigma> E\" and\n    \"ord_resolve CAs DA AAs As \\<sigma>' E'\"\n  shows \"\\<sigma> = \\<sigma>' \\<and> E = E'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> = \\<sigma>' \\<and> E = E'", "using assms"], ["proof (prove)\nusing this:\n  ord_resolve CAs DA AAs As \\<sigma> E\n  ord_resolve CAs DA AAs As \\<sigma>' E'\n\ngoal (1 subgoal):\n 1. \\<sigma> = \\<sigma>' \\<and> E = E'", "proof (cases rule: ord_resolve.cases[case_product ord_resolve.cases], intro conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>CAsa__ n__ Cs__ AAsa__ Asa__ \\<sigma>''__ D__ CAsb__ na__ Csa__\n       AAsb__ Asb__ \\<sigma>'''__ Da__.\n       \\<lbrakk>CAs = CAsa__; DA = D__ + negs (mset Asa__); AAs = AAsa__;\n        As = Asa__; \\<sigma> = \\<sigma>''__;\n        E = (\\<Sum>\\<^sub># (mset Cs__) + D__) \\<cdot> \\<sigma>''__;\n        length CAsa__ = n__; length Cs__ = n__; length AAsa__ = n__;\n        length Asa__ = n__; n__ \\<noteq> 0;\n        \\<forall>i<n__. CAsa__ ! i = Cs__ ! i + poss (AAsa__ ! i);\n        \\<forall>i<n__. AAsa__ ! i \\<noteq> {#};\n        Some \\<sigma>''__ =\n        mgu (set_mset ` set (Map2.map2 add_mset Asa__ AAsa__));\n        eligible \\<sigma>''__ Asa__ (D__ + negs (mset Asa__));\n        \\<forall>i<n__.\n           strictly_maximal_wrt (Asa__ ! i \\<cdot>a \\<sigma>''__)\n            (Cs__ ! i \\<cdot> \\<sigma>''__);\n        \\<forall>i<n__. S (CAsa__ ! i) = {#}; CAs = CAsb__;\n        DA = Da__ + negs (mset Asb__); AAs = AAsb__; As = Asb__;\n        \\<sigma>' = \\<sigma>'''__;\n        E' = (\\<Sum>\\<^sub># (mset Csa__) + Da__) \\<cdot> \\<sigma>'''__;\n        length CAsb__ = na__; length Csa__ = na__; length AAsb__ = na__;\n        length Asb__ = na__; na__ \\<noteq> 0;\n        \\<forall>i<na__. CAsb__ ! i = Csa__ ! i + poss (AAsb__ ! i);\n        \\<forall>i<na__. AAsb__ ! i \\<noteq> {#};\n        Some \\<sigma>'''__ =\n        mgu (set_mset ` set (Map2.map2 add_mset Asb__ AAsb__));\n        eligible \\<sigma>'''__ Asb__ (Da__ + negs (mset Asb__));\n        \\<forall>i<na__.\n           strictly_maximal_wrt (Asb__ ! i \\<cdot>a \\<sigma>'''__)\n            (Csa__ ! i \\<cdot> \\<sigma>'''__);\n        \\<forall>i<na__. S (CAsb__ ! i) = {#};\n        ord_resolve CAs DA AAs As \\<sigma> E;\n        ord_resolve CAs DA AAs As \\<sigma>' E'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 2. \\<And>CAsa__ n__ Cs__ AAsa__ Asa__ \\<sigma>''__ D__ CAsb__ na__ Csa__\n       AAsb__ Asb__ \\<sigma>'''__ Da__.\n       \\<lbrakk>CAs = CAsa__; DA = D__ + negs (mset Asa__); AAs = AAsa__;\n        As = Asa__; \\<sigma> = \\<sigma>''__;\n        E = (\\<Sum>\\<^sub># (mset Cs__) + D__) \\<cdot> \\<sigma>''__;\n        length CAsa__ = n__; length Cs__ = n__; length AAsa__ = n__;\n        length Asa__ = n__; n__ \\<noteq> 0;\n        \\<forall>i<n__. CAsa__ ! i = Cs__ ! i + poss (AAsa__ ! i);\n        \\<forall>i<n__. AAsa__ ! i \\<noteq> {#};\n        Some \\<sigma>''__ =\n        mgu (set_mset ` set (Map2.map2 add_mset Asa__ AAsa__));\n        eligible \\<sigma>''__ Asa__ (D__ + negs (mset Asa__));\n        \\<forall>i<n__.\n           strictly_maximal_wrt (Asa__ ! i \\<cdot>a \\<sigma>''__)\n            (Cs__ ! i \\<cdot> \\<sigma>''__);\n        \\<forall>i<n__. S (CAsa__ ! i) = {#}; CAs = CAsb__;\n        DA = Da__ + negs (mset Asb__); AAs = AAsb__; As = Asb__;\n        \\<sigma>' = \\<sigma>'''__;\n        E' = (\\<Sum>\\<^sub># (mset Csa__) + Da__) \\<cdot> \\<sigma>'''__;\n        length CAsb__ = na__; length Csa__ = na__; length AAsb__ = na__;\n        length Asb__ = na__; na__ \\<noteq> 0;\n        \\<forall>i<na__. CAsb__ ! i = Csa__ ! i + poss (AAsb__ ! i);\n        \\<forall>i<na__. AAsb__ ! i \\<noteq> {#};\n        Some \\<sigma>'''__ =\n        mgu (set_mset ` set (Map2.map2 add_mset Asb__ AAsb__));\n        eligible \\<sigma>'''__ Asb__ (Da__ + negs (mset Asb__));\n        \\<forall>i<na__.\n           strictly_maximal_wrt (Asb__ ! i \\<cdot>a \\<sigma>'''__)\n            (Csa__ ! i \\<cdot> \\<sigma>'''__);\n        \\<forall>i<na__. S (CAsb__ ! i) = {#};\n        ord_resolve CAs DA AAs As \\<sigma> E;\n        ord_resolve CAs DA AAs As \\<sigma>' E'\\<rbrakk>\n       \\<Longrightarrow> E = E'", "case (ord_resolve_ord_resolve CAs n Cs AAs As \\<sigma>'' DA CAs' n' Cs' AAs' As' \\<sigma>''' DA')"], ["proof (state)\nthis:\n  CAs = CAs\n  DA = DA + negs (mset As)\n  AAs = AAs\n  As = As\n  \\<sigma> = \\<sigma>''\n  E = (\\<Sum>\\<^sub># (mset Cs) + DA) \\<cdot> \\<sigma>''\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  n \\<noteq> 0\n  \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i)\n  \\<forall>i<n. AAs ! i \\<noteq> {#}\n  Some \\<sigma>'' = mgu (set_mset ` set (Map2.map2 add_mset As AAs))\n  eligible \\<sigma>'' As (DA + negs (mset As))\n  \\<forall>i<n.\n     strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>'')\n      (Cs ! i \\<cdot> \\<sigma>'')\n  \\<forall>i<n. S (CAs ! i) = {#}\n  CAs = CAs'\n  DA = DA' + negs (mset As')\n  AAs = AAs'\n  As = As'\n  \\<sigma>' = \\<sigma>'''\n  E' = (\\<Sum>\\<^sub># (mset Cs') + DA') \\<cdot> \\<sigma>'''\n  length CAs' = n'\n  length Cs' = n'\n  length AAs' = n'\n  length As' = n'\n  n' \\<noteq> 0\n  \\<forall>i<n'. CAs' ! i = Cs' ! i + poss (AAs' ! i)\n  \\<forall>i<n'. AAs' ! i \\<noteq> {#}\n  Some \\<sigma>''' = mgu (set_mset ` set (Map2.map2 add_mset As' AAs'))\n  eligible \\<sigma>''' As' (DA' + negs (mset As'))\n  \\<forall>i<n'.\n     strictly_maximal_wrt (As' ! i \\<cdot>a \\<sigma>''')\n      (Cs' ! i \\<cdot> \\<sigma>''')\n  \\<forall>i<n'. S (CAs' ! i) = {#}\n\ngoal (2 subgoals):\n 1. \\<And>CAsa__ n__ Cs__ AAsa__ Asa__ \\<sigma>''__ D__ CAsb__ na__ Csa__\n       AAsb__ Asb__ \\<sigma>'''__ Da__.\n       \\<lbrakk>CAs = CAsa__; DA = D__ + negs (mset Asa__); AAs = AAsa__;\n        As = Asa__; \\<sigma> = \\<sigma>''__;\n        E = (\\<Sum>\\<^sub># (mset Cs__) + D__) \\<cdot> \\<sigma>''__;\n        length CAsa__ = n__; length Cs__ = n__; length AAsa__ = n__;\n        length Asa__ = n__; n__ \\<noteq> 0;\n        \\<forall>i<n__. CAsa__ ! i = Cs__ ! i + poss (AAsa__ ! i);\n        \\<forall>i<n__. AAsa__ ! i \\<noteq> {#};\n        Some \\<sigma>''__ =\n        mgu (set_mset ` set (Map2.map2 add_mset Asa__ AAsa__));\n        eligible \\<sigma>''__ Asa__ (D__ + negs (mset Asa__));\n        \\<forall>i<n__.\n           strictly_maximal_wrt (Asa__ ! i \\<cdot>a \\<sigma>''__)\n            (Cs__ ! i \\<cdot> \\<sigma>''__);\n        \\<forall>i<n__. S (CAsa__ ! i) = {#}; CAs = CAsb__;\n        DA = Da__ + negs (mset Asb__); AAs = AAsb__; As = Asb__;\n        \\<sigma>' = \\<sigma>'''__;\n        E' = (\\<Sum>\\<^sub># (mset Csa__) + Da__) \\<cdot> \\<sigma>'''__;\n        length CAsb__ = na__; length Csa__ = na__; length AAsb__ = na__;\n        length Asb__ = na__; na__ \\<noteq> 0;\n        \\<forall>i<na__. CAsb__ ! i = Csa__ ! i + poss (AAsb__ ! i);\n        \\<forall>i<na__. AAsb__ ! i \\<noteq> {#};\n        Some \\<sigma>'''__ =\n        mgu (set_mset ` set (Map2.map2 add_mset Asb__ AAsb__));\n        eligible \\<sigma>'''__ Asb__ (Da__ + negs (mset Asb__));\n        \\<forall>i<na__.\n           strictly_maximal_wrt (Asb__ ! i \\<cdot>a \\<sigma>'''__)\n            (Csa__ ! i \\<cdot> \\<sigma>'''__);\n        \\<forall>i<na__. S (CAsb__ ! i) = {#};\n        ord_resolve CAs DA AAs As \\<sigma> E;\n        ord_resolve CAs DA AAs As \\<sigma>' E'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 2. \\<And>CAsa__ n__ Cs__ AAsa__ Asa__ \\<sigma>''__ D__ CAsb__ na__ Csa__\n       AAsb__ Asb__ \\<sigma>'''__ Da__.\n       \\<lbrakk>CAs = CAsa__; DA = D__ + negs (mset Asa__); AAs = AAsa__;\n        As = Asa__; \\<sigma> = \\<sigma>''__;\n        E = (\\<Sum>\\<^sub># (mset Cs__) + D__) \\<cdot> \\<sigma>''__;\n        length CAsa__ = n__; length Cs__ = n__; length AAsa__ = n__;\n        length Asa__ = n__; n__ \\<noteq> 0;\n        \\<forall>i<n__. CAsa__ ! i = Cs__ ! i + poss (AAsa__ ! i);\n        \\<forall>i<n__. AAsa__ ! i \\<noteq> {#};\n        Some \\<sigma>''__ =\n        mgu (set_mset ` set (Map2.map2 add_mset Asa__ AAsa__));\n        eligible \\<sigma>''__ Asa__ (D__ + negs (mset Asa__));\n        \\<forall>i<n__.\n           strictly_maximal_wrt (Asa__ ! i \\<cdot>a \\<sigma>''__)\n            (Cs__ ! i \\<cdot> \\<sigma>''__);\n        \\<forall>i<n__. S (CAsa__ ! i) = {#}; CAs = CAsb__;\n        DA = Da__ + negs (mset Asb__); AAs = AAsb__; As = Asb__;\n        \\<sigma>' = \\<sigma>'''__;\n        E' = (\\<Sum>\\<^sub># (mset Csa__) + Da__) \\<cdot> \\<sigma>'''__;\n        length CAsb__ = na__; length Csa__ = na__; length AAsb__ = na__;\n        length Asb__ = na__; na__ \\<noteq> 0;\n        \\<forall>i<na__. CAsb__ ! i = Csa__ ! i + poss (AAsb__ ! i);\n        \\<forall>i<na__. AAsb__ ! i \\<noteq> {#};\n        Some \\<sigma>'''__ =\n        mgu (set_mset ` set (Map2.map2 add_mset Asb__ AAsb__));\n        eligible \\<sigma>'''__ Asb__ (Da__ + negs (mset Asb__));\n        \\<forall>i<na__.\n           strictly_maximal_wrt (Asb__ ! i \\<cdot>a \\<sigma>'''__)\n            (Csa__ ! i \\<cdot> \\<sigma>'''__);\n        \\<forall>i<na__. S (CAsb__ ! i) = {#};\n        ord_resolve CAs DA AAs As \\<sigma> E;\n        ord_resolve CAs DA AAs As \\<sigma>' E'\\<rbrakk>\n       \\<Longrightarrow> E = E'", "note res = this(1-17) and res' = this(18-34)"], ["proof (state)\nthis:\n  CAs = CAs\n  DA = DA + negs (mset As)\n  AAs = AAs\n  As = As\n  \\<sigma> = \\<sigma>''\n  E = (\\<Sum>\\<^sub># (mset Cs) + DA) \\<cdot> \\<sigma>''\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  n \\<noteq> 0\n  \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i)\n  \\<forall>i<n. AAs ! i \\<noteq> {#}\n  Some \\<sigma>'' = mgu (set_mset ` set (Map2.map2 add_mset As AAs))\n  eligible \\<sigma>'' As (DA + negs (mset As))\n  \\<forall>i<n.\n     strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>'')\n      (Cs ! i \\<cdot> \\<sigma>'')\n  \\<forall>i<n. S (CAs ! i) = {#}\n  CAs = CAs'\n  DA = DA' + negs (mset As')\n  AAs = AAs'\n  As = As'\n  \\<sigma>' = \\<sigma>'''\n  E' = (\\<Sum>\\<^sub># (mset Cs') + DA') \\<cdot> \\<sigma>'''\n  length CAs' = n'\n  length Cs' = n'\n  length AAs' = n'\n  length As' = n'\n  n' \\<noteq> 0\n  \\<forall>i<n'. CAs' ! i = Cs' ! i + poss (AAs' ! i)\n  \\<forall>i<n'. AAs' ! i \\<noteq> {#}\n  Some \\<sigma>''' = mgu (set_mset ` set (Map2.map2 add_mset As' AAs'))\n  eligible \\<sigma>''' As' (DA' + negs (mset As'))\n  \\<forall>i<n'.\n     strictly_maximal_wrt (As' ! i \\<cdot>a \\<sigma>''')\n      (Cs' ! i \\<cdot> \\<sigma>''')\n  \\<forall>i<n'. S (CAs' ! i) = {#}\n\ngoal (2 subgoals):\n 1. \\<And>CAsa__ n__ Cs__ AAsa__ Asa__ \\<sigma>''__ D__ CAsb__ na__ Csa__\n       AAsb__ Asb__ \\<sigma>'''__ Da__.\n       \\<lbrakk>CAs = CAsa__; DA = D__ + negs (mset Asa__); AAs = AAsa__;\n        As = Asa__; \\<sigma> = \\<sigma>''__;\n        E = (\\<Sum>\\<^sub># (mset Cs__) + D__) \\<cdot> \\<sigma>''__;\n        length CAsa__ = n__; length Cs__ = n__; length AAsa__ = n__;\n        length Asa__ = n__; n__ \\<noteq> 0;\n        \\<forall>i<n__. CAsa__ ! i = Cs__ ! i + poss (AAsa__ ! i);\n        \\<forall>i<n__. AAsa__ ! i \\<noteq> {#};\n        Some \\<sigma>''__ =\n        mgu (set_mset ` set (Map2.map2 add_mset Asa__ AAsa__));\n        eligible \\<sigma>''__ Asa__ (D__ + negs (mset Asa__));\n        \\<forall>i<n__.\n           strictly_maximal_wrt (Asa__ ! i \\<cdot>a \\<sigma>''__)\n            (Cs__ ! i \\<cdot> \\<sigma>''__);\n        \\<forall>i<n__. S (CAsa__ ! i) = {#}; CAs = CAsb__;\n        DA = Da__ + negs (mset Asb__); AAs = AAsb__; As = Asb__;\n        \\<sigma>' = \\<sigma>'''__;\n        E' = (\\<Sum>\\<^sub># (mset Csa__) + Da__) \\<cdot> \\<sigma>'''__;\n        length CAsb__ = na__; length Csa__ = na__; length AAsb__ = na__;\n        length Asb__ = na__; na__ \\<noteq> 0;\n        \\<forall>i<na__. CAsb__ ! i = Csa__ ! i + poss (AAsb__ ! i);\n        \\<forall>i<na__. AAsb__ ! i \\<noteq> {#};\n        Some \\<sigma>'''__ =\n        mgu (set_mset ` set (Map2.map2 add_mset Asb__ AAsb__));\n        eligible \\<sigma>'''__ Asb__ (Da__ + negs (mset Asb__));\n        \\<forall>i<na__.\n           strictly_maximal_wrt (Asb__ ! i \\<cdot>a \\<sigma>'''__)\n            (Csa__ ! i \\<cdot> \\<sigma>'''__);\n        \\<forall>i<na__. S (CAsb__ ! i) = {#};\n        ord_resolve CAs DA AAs As \\<sigma> E;\n        ord_resolve CAs DA AAs As \\<sigma>' E'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 2. \\<And>CAsa__ n__ Cs__ AAsa__ Asa__ \\<sigma>''__ D__ CAsb__ na__ Csa__\n       AAsb__ Asb__ \\<sigma>'''__ Da__.\n       \\<lbrakk>CAs = CAsa__; DA = D__ + negs (mset Asa__); AAs = AAsa__;\n        As = Asa__; \\<sigma> = \\<sigma>''__;\n        E = (\\<Sum>\\<^sub># (mset Cs__) + D__) \\<cdot> \\<sigma>''__;\n        length CAsa__ = n__; length Cs__ = n__; length AAsa__ = n__;\n        length Asa__ = n__; n__ \\<noteq> 0;\n        \\<forall>i<n__. CAsa__ ! i = Cs__ ! i + poss (AAsa__ ! i);\n        \\<forall>i<n__. AAsa__ ! i \\<noteq> {#};\n        Some \\<sigma>''__ =\n        mgu (set_mset ` set (Map2.map2 add_mset Asa__ AAsa__));\n        eligible \\<sigma>''__ Asa__ (D__ + negs (mset Asa__));\n        \\<forall>i<n__.\n           strictly_maximal_wrt (Asa__ ! i \\<cdot>a \\<sigma>''__)\n            (Cs__ ! i \\<cdot> \\<sigma>''__);\n        \\<forall>i<n__. S (CAsa__ ! i) = {#}; CAs = CAsb__;\n        DA = Da__ + negs (mset Asb__); AAs = AAsb__; As = Asb__;\n        \\<sigma>' = \\<sigma>'''__;\n        E' = (\\<Sum>\\<^sub># (mset Csa__) + Da__) \\<cdot> \\<sigma>'''__;\n        length CAsb__ = na__; length Csa__ = na__; length AAsb__ = na__;\n        length Asb__ = na__; na__ \\<noteq> 0;\n        \\<forall>i<na__. CAsb__ ! i = Csa__ ! i + poss (AAsb__ ! i);\n        \\<forall>i<na__. AAsb__ ! i \\<noteq> {#};\n        Some \\<sigma>'''__ =\n        mgu (set_mset ` set (Map2.map2 add_mset Asb__ AAsb__));\n        eligible \\<sigma>'''__ Asb__ (Da__ + negs (mset Asb__));\n        \\<forall>i<na__.\n           strictly_maximal_wrt (Asb__ ! i \\<cdot>a \\<sigma>'''__)\n            (Csa__ ! i \\<cdot> \\<sigma>'''__);\n        \\<forall>i<na__. S (CAsb__ ! i) = {#};\n        ord_resolve CAs DA AAs As \\<sigma> E;\n        ord_resolve CAs DA AAs As \\<sigma>' E'\\<rbrakk>\n       \\<Longrightarrow> E = E'", "show \\<sigma>: \"\\<sigma> = \\<sigma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> = \\<sigma>'", "using res(3-5,14) res'(3-5,14)"], ["proof (prove)\nusing this:\n  AAs = AAs\n  As = As\n  \\<sigma> = \\<sigma>''\n  Some \\<sigma>'' = mgu (set_mset ` set (Map2.map2 add_mset As AAs))\n  AAs = AAs'\n  As = As'\n  \\<sigma>' = \\<sigma>'''\n  Some \\<sigma>''' = mgu (set_mset ` set (Map2.map2 add_mset As' AAs'))\n\ngoal (1 subgoal):\n 1. \\<sigma> = \\<sigma>'", "by (metis option.inject)"], ["proof (state)\nthis:\n  \\<sigma> = \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<And>CAsa__ n__ Cs__ AAsa__ Asa__ \\<sigma>''__ D__ CAsb__ na__ Csa__\n       AAsb__ Asb__ \\<sigma>'''__ Da__.\n       \\<lbrakk>CAs = CAsa__; DA = D__ + negs (mset Asa__); AAs = AAsa__;\n        As = Asa__; \\<sigma> = \\<sigma>''__;\n        E = (\\<Sum>\\<^sub># (mset Cs__) + D__) \\<cdot> \\<sigma>''__;\n        length CAsa__ = n__; length Cs__ = n__; length AAsa__ = n__;\n        length Asa__ = n__; n__ \\<noteq> 0;\n        \\<forall>i<n__. CAsa__ ! i = Cs__ ! i + poss (AAsa__ ! i);\n        \\<forall>i<n__. AAsa__ ! i \\<noteq> {#};\n        Some \\<sigma>''__ =\n        mgu (set_mset ` set (Map2.map2 add_mset Asa__ AAsa__));\n        eligible \\<sigma>''__ Asa__ (D__ + negs (mset Asa__));\n        \\<forall>i<n__.\n           strictly_maximal_wrt (Asa__ ! i \\<cdot>a \\<sigma>''__)\n            (Cs__ ! i \\<cdot> \\<sigma>''__);\n        \\<forall>i<n__. S (CAsa__ ! i) = {#}; CAs = CAsb__;\n        DA = Da__ + negs (mset Asb__); AAs = AAsb__; As = Asb__;\n        \\<sigma>' = \\<sigma>'''__;\n        E' = (\\<Sum>\\<^sub># (mset Csa__) + Da__) \\<cdot> \\<sigma>'''__;\n        length CAsb__ = na__; length Csa__ = na__; length AAsb__ = na__;\n        length Asb__ = na__; na__ \\<noteq> 0;\n        \\<forall>i<na__. CAsb__ ! i = Csa__ ! i + poss (AAsb__ ! i);\n        \\<forall>i<na__. AAsb__ ! i \\<noteq> {#};\n        Some \\<sigma>'''__ =\n        mgu (set_mset ` set (Map2.map2 add_mset Asb__ AAsb__));\n        eligible \\<sigma>'''__ Asb__ (Da__ + negs (mset Asb__));\n        \\<forall>i<na__.\n           strictly_maximal_wrt (Asb__ ! i \\<cdot>a \\<sigma>'''__)\n            (Csa__ ! i \\<cdot> \\<sigma>'''__);\n        \\<forall>i<na__. S (CAsb__ ! i) = {#};\n        ord_resolve CAs DA AAs As \\<sigma> E;\n        ord_resolve CAs DA AAs As \\<sigma>' E'\\<rbrakk>\n       \\<Longrightarrow> E = E'", "have \"Cs = Cs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cs = Cs'", "using res(1,3,7,8,12) res'(1,3,7,8,12)"], ["proof (prove)\nusing this:\n  CAs = CAs\n  AAs = AAs\n  length CAs = n\n  length Cs = n\n  \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i)\n  CAs = CAs'\n  AAs = AAs'\n  length CAs' = n'\n  length Cs' = n'\n  \\<forall>i<n'. CAs' ! i = Cs' ! i + poss (AAs' ! i)\n\ngoal (1 subgoal):\n 1. Cs = Cs'", "by (metis add_right_imp_eq nth_equalityI)"], ["proof (state)\nthis:\n  Cs = Cs'\n\ngoal (1 subgoal):\n 1. \\<And>CAsa__ n__ Cs__ AAsa__ Asa__ \\<sigma>''__ D__ CAsb__ na__ Csa__\n       AAsb__ Asb__ \\<sigma>'''__ Da__.\n       \\<lbrakk>CAs = CAsa__; DA = D__ + negs (mset Asa__); AAs = AAsa__;\n        As = Asa__; \\<sigma> = \\<sigma>''__;\n        E = (\\<Sum>\\<^sub># (mset Cs__) + D__) \\<cdot> \\<sigma>''__;\n        length CAsa__ = n__; length Cs__ = n__; length AAsa__ = n__;\n        length Asa__ = n__; n__ \\<noteq> 0;\n        \\<forall>i<n__. CAsa__ ! i = Cs__ ! i + poss (AAsa__ ! i);\n        \\<forall>i<n__. AAsa__ ! i \\<noteq> {#};\n        Some \\<sigma>''__ =\n        mgu (set_mset ` set (Map2.map2 add_mset Asa__ AAsa__));\n        eligible \\<sigma>''__ Asa__ (D__ + negs (mset Asa__));\n        \\<forall>i<n__.\n           strictly_maximal_wrt (Asa__ ! i \\<cdot>a \\<sigma>''__)\n            (Cs__ ! i \\<cdot> \\<sigma>''__);\n        \\<forall>i<n__. S (CAsa__ ! i) = {#}; CAs = CAsb__;\n        DA = Da__ + negs (mset Asb__); AAs = AAsb__; As = Asb__;\n        \\<sigma>' = \\<sigma>'''__;\n        E' = (\\<Sum>\\<^sub># (mset Csa__) + Da__) \\<cdot> \\<sigma>'''__;\n        length CAsb__ = na__; length Csa__ = na__; length AAsb__ = na__;\n        length Asb__ = na__; na__ \\<noteq> 0;\n        \\<forall>i<na__. CAsb__ ! i = Csa__ ! i + poss (AAsb__ ! i);\n        \\<forall>i<na__. AAsb__ ! i \\<noteq> {#};\n        Some \\<sigma>'''__ =\n        mgu (set_mset ` set (Map2.map2 add_mset Asb__ AAsb__));\n        eligible \\<sigma>'''__ Asb__ (Da__ + negs (mset Asb__));\n        \\<forall>i<na__.\n           strictly_maximal_wrt (Asb__ ! i \\<cdot>a \\<sigma>'''__)\n            (Csa__ ! i \\<cdot> \\<sigma>'''__);\n        \\<forall>i<na__. S (CAsb__ ! i) = {#};\n        ord_resolve CAs DA AAs As \\<sigma> E;\n        ord_resolve CAs DA AAs As \\<sigma>' E'\\<rbrakk>\n       \\<Longrightarrow> E = E'", "moreover"], ["proof (state)\nthis:\n  Cs = Cs'\n\ngoal (1 subgoal):\n 1. \\<And>CAsa__ n__ Cs__ AAsa__ Asa__ \\<sigma>''__ D__ CAsb__ na__ Csa__\n       AAsb__ Asb__ \\<sigma>'''__ Da__.\n       \\<lbrakk>CAs = CAsa__; DA = D__ + negs (mset Asa__); AAs = AAsa__;\n        As = Asa__; \\<sigma> = \\<sigma>''__;\n        E = (\\<Sum>\\<^sub># (mset Cs__) + D__) \\<cdot> \\<sigma>''__;\n        length CAsa__ = n__; length Cs__ = n__; length AAsa__ = n__;\n        length Asa__ = n__; n__ \\<noteq> 0;\n        \\<forall>i<n__. CAsa__ ! i = Cs__ ! i + poss (AAsa__ ! i);\n        \\<forall>i<n__. AAsa__ ! i \\<noteq> {#};\n        Some \\<sigma>''__ =\n        mgu (set_mset ` set (Map2.map2 add_mset Asa__ AAsa__));\n        eligible \\<sigma>''__ Asa__ (D__ + negs (mset Asa__));\n        \\<forall>i<n__.\n           strictly_maximal_wrt (Asa__ ! i \\<cdot>a \\<sigma>''__)\n            (Cs__ ! i \\<cdot> \\<sigma>''__);\n        \\<forall>i<n__. S (CAsa__ ! i) = {#}; CAs = CAsb__;\n        DA = Da__ + negs (mset Asb__); AAs = AAsb__; As = Asb__;\n        \\<sigma>' = \\<sigma>'''__;\n        E' = (\\<Sum>\\<^sub># (mset Csa__) + Da__) \\<cdot> \\<sigma>'''__;\n        length CAsb__ = na__; length Csa__ = na__; length AAsb__ = na__;\n        length Asb__ = na__; na__ \\<noteq> 0;\n        \\<forall>i<na__. CAsb__ ! i = Csa__ ! i + poss (AAsb__ ! i);\n        \\<forall>i<na__. AAsb__ ! i \\<noteq> {#};\n        Some \\<sigma>'''__ =\n        mgu (set_mset ` set (Map2.map2 add_mset Asb__ AAsb__));\n        eligible \\<sigma>'''__ Asb__ (Da__ + negs (mset Asb__));\n        \\<forall>i<na__.\n           strictly_maximal_wrt (Asb__ ! i \\<cdot>a \\<sigma>'''__)\n            (Csa__ ! i \\<cdot> \\<sigma>'''__);\n        \\<forall>i<na__. S (CAsb__ ! i) = {#};\n        ord_resolve CAs DA AAs As \\<sigma> E;\n        ord_resolve CAs DA AAs As \\<sigma>' E'\\<rbrakk>\n       \\<Longrightarrow> E = E'", "have \"DA = DA'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DA = DA'", "using res(2,4) res'(2,4)"], ["proof (prove)\nusing this:\n  DA = DA + negs (mset As)\n  As = As\n  DA = DA' + negs (mset As')\n  As = As'\n\ngoal (1 subgoal):\n 1. DA = DA'", "by fastforce"], ["proof (state)\nthis:\n  DA = DA'\n\ngoal (1 subgoal):\n 1. \\<And>CAsa__ n__ Cs__ AAsa__ Asa__ \\<sigma>''__ D__ CAsb__ na__ Csa__\n       AAsb__ Asb__ \\<sigma>'''__ Da__.\n       \\<lbrakk>CAs = CAsa__; DA = D__ + negs (mset Asa__); AAs = AAsa__;\n        As = Asa__; \\<sigma> = \\<sigma>''__;\n        E = (\\<Sum>\\<^sub># (mset Cs__) + D__) \\<cdot> \\<sigma>''__;\n        length CAsa__ = n__; length Cs__ = n__; length AAsa__ = n__;\n        length Asa__ = n__; n__ \\<noteq> 0;\n        \\<forall>i<n__. CAsa__ ! i = Cs__ ! i + poss (AAsa__ ! i);\n        \\<forall>i<n__. AAsa__ ! i \\<noteq> {#};\n        Some \\<sigma>''__ =\n        mgu (set_mset ` set (Map2.map2 add_mset Asa__ AAsa__));\n        eligible \\<sigma>''__ Asa__ (D__ + negs (mset Asa__));\n        \\<forall>i<n__.\n           strictly_maximal_wrt (Asa__ ! i \\<cdot>a \\<sigma>''__)\n            (Cs__ ! i \\<cdot> \\<sigma>''__);\n        \\<forall>i<n__. S (CAsa__ ! i) = {#}; CAs = CAsb__;\n        DA = Da__ + negs (mset Asb__); AAs = AAsb__; As = Asb__;\n        \\<sigma>' = \\<sigma>'''__;\n        E' = (\\<Sum>\\<^sub># (mset Csa__) + Da__) \\<cdot> \\<sigma>'''__;\n        length CAsb__ = na__; length Csa__ = na__; length AAsb__ = na__;\n        length Asb__ = na__; na__ \\<noteq> 0;\n        \\<forall>i<na__. CAsb__ ! i = Csa__ ! i + poss (AAsb__ ! i);\n        \\<forall>i<na__. AAsb__ ! i \\<noteq> {#};\n        Some \\<sigma>'''__ =\n        mgu (set_mset ` set (Map2.map2 add_mset Asb__ AAsb__));\n        eligible \\<sigma>'''__ Asb__ (Da__ + negs (mset Asb__));\n        \\<forall>i<na__.\n           strictly_maximal_wrt (Asb__ ! i \\<cdot>a \\<sigma>'''__)\n            (Csa__ ! i \\<cdot> \\<sigma>'''__);\n        \\<forall>i<na__. S (CAsb__ ! i) = {#};\n        ord_resolve CAs DA AAs As \\<sigma> E;\n        ord_resolve CAs DA AAs As \\<sigma>' E'\\<rbrakk>\n       \\<Longrightarrow> E = E'", "ultimately"], ["proof (chain)\npicking this:\n  Cs = Cs'\n  DA = DA'", "show \"E = E'\""], ["proof (prove)\nusing this:\n  Cs = Cs'\n  DA = DA'\n\ngoal (1 subgoal):\n 1. E = E'", "using res(5,6) res'(5,6) \\<sigma>"], ["proof (prove)\nusing this:\n  Cs = Cs'\n  DA = DA'\n  \\<sigma> = \\<sigma>''\n  E = (\\<Sum>\\<^sub># (mset Cs) + DA) \\<cdot> \\<sigma>''\n  \\<sigma>' = \\<sigma>'''\n  E' = (\\<Sum>\\<^sub># (mset Cs') + DA') \\<cdot> \\<sigma>'''\n  \\<sigma> = \\<sigma>'\n\ngoal (1 subgoal):\n 1. E = E'", "by blast"], ["proof (state)\nthis:\n  E = E'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ord_resolve_rename_unique:\n  assumes\n    \"ord_resolve_rename CAs DA AAs As \\<sigma> E\" and\n    \"ord_resolve_rename CAs DA AAs As \\<sigma>' E'\"\n  shows \"\\<sigma> = \\<sigma>' \\<and> E = E'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> = \\<sigma>' \\<and> E = E'", "using assms"], ["proof (prove)\nusing this:\n  ord_resolve_rename CAs DA AAs As \\<sigma> E\n  ord_resolve_rename CAs DA AAs As \\<sigma>' E'\n\ngoal (1 subgoal):\n 1. \\<sigma> = \\<sigma>' \\<and> E = E'", "unfolding ord_resolve_rename.simps"], ["proof (prove)\nusing this:\n  \\<exists>CAsa n AAsa Asa DAa \\<rho> \\<rho>s \\<sigma>' Ea.\n     CAs = CAsa \\<and>\n     DA = DAa \\<and>\n     AAs = AAsa \\<and>\n     As = Asa \\<and>\n     \\<sigma> = \\<sigma>' \\<and>\n     E = Ea \\<and>\n     length CAsa = n \\<and>\n     length AAsa = n \\<and>\n     length Asa = n \\<and>\n     (\\<forall>i<n. poss (AAsa ! i) \\<subseteq># CAsa ! i) \\<and>\n     negs (mset Asa) \\<subseteq># DAa \\<and>\n     \\<rho> = hd (renamings_apart (DAa # CAsa)) \\<and>\n     \\<rho>s = tl (renamings_apart (DAa # CAsa)) \\<and>\n     ord_resolve (CAsa \\<cdot>\\<cdot>cl \\<rho>s) (DAa \\<cdot> \\<rho>)\n      (AAsa \\<cdot>\\<cdot>aml \\<rho>s) (Asa \\<cdot>al \\<rho>) \\<sigma>' Ea\n  \\<exists>CAsa n AAsa Asa DAa \\<rho> \\<rho>s \\<sigma> E.\n     CAs = CAsa \\<and>\n     DA = DAa \\<and>\n     AAs = AAsa \\<and>\n     As = Asa \\<and>\n     \\<sigma>' = \\<sigma> \\<and>\n     E' = E \\<and>\n     length CAsa = n \\<and>\n     length AAsa = n \\<and>\n     length Asa = n \\<and>\n     (\\<forall>i<n. poss (AAsa ! i) \\<subseteq># CAsa ! i) \\<and>\n     negs (mset Asa) \\<subseteq># DAa \\<and>\n     \\<rho> = hd (renamings_apart (DAa # CAsa)) \\<and>\n     \\<rho>s = tl (renamings_apart (DAa # CAsa)) \\<and>\n     ord_resolve (CAsa \\<cdot>\\<cdot>cl \\<rho>s) (DAa \\<cdot> \\<rho>)\n      (AAsa \\<cdot>\\<cdot>aml \\<rho>s) (Asa \\<cdot>al \\<rho>) \\<sigma> E\n\ngoal (1 subgoal):\n 1. \\<sigma> = \\<sigma>' \\<and> E = E'", "using ord_resolve_unique"], ["proof (prove)\nusing this:\n  \\<exists>CAsa n AAsa Asa DAa \\<rho> \\<rho>s \\<sigma>' Ea.\n     CAs = CAsa \\<and>\n     DA = DAa \\<and>\n     AAs = AAsa \\<and>\n     As = Asa \\<and>\n     \\<sigma> = \\<sigma>' \\<and>\n     E = Ea \\<and>\n     length CAsa = n \\<and>\n     length AAsa = n \\<and>\n     length Asa = n \\<and>\n     (\\<forall>i<n. poss (AAsa ! i) \\<subseteq># CAsa ! i) \\<and>\n     negs (mset Asa) \\<subseteq># DAa \\<and>\n     \\<rho> = hd (renamings_apart (DAa # CAsa)) \\<and>\n     \\<rho>s = tl (renamings_apart (DAa # CAsa)) \\<and>\n     ord_resolve (CAsa \\<cdot>\\<cdot>cl \\<rho>s) (DAa \\<cdot> \\<rho>)\n      (AAsa \\<cdot>\\<cdot>aml \\<rho>s) (Asa \\<cdot>al \\<rho>) \\<sigma>' Ea\n  \\<exists>CAsa n AAsa Asa DAa \\<rho> \\<rho>s \\<sigma> E.\n     CAs = CAsa \\<and>\n     DA = DAa \\<and>\n     AAs = AAsa \\<and>\n     As = Asa \\<and>\n     \\<sigma>' = \\<sigma> \\<and>\n     E' = E \\<and>\n     length CAsa = n \\<and>\n     length AAsa = n \\<and>\n     length Asa = n \\<and>\n     (\\<forall>i<n. poss (AAsa ! i) \\<subseteq># CAsa ! i) \\<and>\n     negs (mset Asa) \\<subseteq># DAa \\<and>\n     \\<rho> = hd (renamings_apart (DAa # CAsa)) \\<and>\n     \\<rho>s = tl (renamings_apart (DAa # CAsa)) \\<and>\n     ord_resolve (CAsa \\<cdot>\\<cdot>cl \\<rho>s) (DAa \\<cdot> \\<rho>)\n      (AAsa \\<cdot>\\<cdot>aml \\<rho>s) (Asa \\<cdot>al \\<rho>) \\<sigma> E\n  \\<lbrakk>ord_resolve ?CAs ?DA ?AAs ?As ?\\<sigma> ?E;\n   ord_resolve ?CAs ?DA ?AAs ?As ?\\<sigma>' ?E'\\<rbrakk>\n  \\<Longrightarrow> ?\\<sigma> = ?\\<sigma>' \\<and> ?E = ?E'\n\ngoal (1 subgoal):\n 1. \\<sigma> = \\<sigma>' \\<and> E = E'", "by meson"], ["", "lemma ord_resolve_max_side_prems: \"ord_resolve CAs DA AAs As \\<sigma> E \\<Longrightarrow> length CAs \\<le> size DA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_resolve CAs DA AAs As \\<sigma> E \\<Longrightarrow>\n    length CAs \\<le> size DA", "by (auto elim!: ord_resolve.cases)"], ["", "lemma ord_resolve_rename_max_side_prems:\n  \"ord_resolve_rename CAs DA AAs As \\<sigma> E \\<Longrightarrow> length CAs \\<le> size DA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_resolve_rename CAs DA AAs As \\<sigma> E \\<Longrightarrow>\n    length CAs \\<le> size DA", "by (elim ord_resolve_rename.cases, drule ord_resolve_max_side_prems, simp add: renamings_apart_length)"], ["", "subsection \\<open>Inference System\\<close>"], ["", "definition ord_FO_\\<Gamma> :: \"'a inference set\" where\n  \"ord_FO_\\<Gamma> = {Infer (mset CAs) DA E | CAs DA AAs As \\<sigma> E. ord_resolve_rename CAs DA AAs As \\<sigma> E}\""], ["", "interpretation ord_FO_resolution: inference_system ord_FO_\\<Gamma>"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma finite_ord_FO_resolution_inferences_between:\n  assumes fin_cc: \"finite CC\"\n  shows \"finite (ord_FO_resolution.inferences_between CC C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (ord_FO_resolution.inferences_between CC C)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (ord_FO_resolution.inferences_between CC C)", "let ?CCC = \"CC \\<union> {C}\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite (ord_FO_resolution.inferences_between CC C)", "define all_AA where \"all_AA = (\\<Union>D \\<in> ?CCC. atms_of D)\""], ["proof (state)\nthis:\n  all_AA = \\<Union> (atms_of ` (CC \\<union> {C}))\n\ngoal (1 subgoal):\n 1. finite (ord_FO_resolution.inferences_between CC C)", "define max_ary where \"max_ary = Max (size ` ?CCC)\""], ["proof (state)\nthis:\n  max_ary = Max (size ` (CC \\<union> {C}))\n\ngoal (1 subgoal):\n 1. finite (ord_FO_resolution.inferences_between CC C)", "define CAS where \"CAS = {CAs. CAs \\<in> lists ?CCC \\<and> length CAs \\<le> max_ary}\""], ["proof (state)\nthis:\n  CAS = {CAs \\<in> lists (CC \\<union> {C}). length CAs \\<le> max_ary}\n\ngoal (1 subgoal):\n 1. finite (ord_FO_resolution.inferences_between CC C)", "define AS where \"AS = {As. As \\<in> lists all_AA \\<and> length As \\<le> max_ary}\""], ["proof (state)\nthis:\n  AS = {As \\<in> lists all_AA. length As \\<le> max_ary}\n\ngoal (1 subgoal):\n 1. finite (ord_FO_resolution.inferences_between CC C)", "define AAS where \"AAS = {AAs. AAs \\<in> lists (mset ` AS) \\<and> length AAs \\<le> max_ary}\""], ["proof (state)\nthis:\n  AAS = {AAs \\<in> lists (mset ` AS). length AAs \\<le> max_ary}\n\ngoal (1 subgoal):\n 1. finite (ord_FO_resolution.inferences_between CC C)", "note defs = all_AA_def max_ary_def CAS_def AS_def AAS_def"], ["proof (state)\nthis:\n  all_AA = \\<Union> (atms_of ` (CC \\<union> {C}))\n  max_ary = Max (size ` (CC \\<union> {C}))\n  CAS = {CAs \\<in> lists (CC \\<union> {C}). length CAs \\<le> max_ary}\n  AS = {As \\<in> lists all_AA. length As \\<le> max_ary}\n  AAS = {AAs \\<in> lists (mset ` AS). length AAs \\<le> max_ary}\n\ngoal (1 subgoal):\n 1. finite (ord_FO_resolution.inferences_between CC C)", "let ?infer_of =\n    \"\\<lambda>CAs DA AAs As. Infer (mset CAs) DA (THE E. \\<exists>\\<sigma>. ord_resolve_rename CAs DA AAs As \\<sigma> E)\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite (ord_FO_resolution.inferences_between CC C)", "let ?Z = \"{\\<gamma> | CAs DA AAs As \\<sigma> E \\<gamma>. \\<gamma> = Infer (mset CAs) DA E\n    \\<and> ord_resolve_rename CAs DA AAs As \\<sigma> E \\<and> infer_from ?CCC \\<gamma> \\<and> C \\<in># prems_of \\<gamma>}\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite (ord_FO_resolution.inferences_between CC C)", "let ?Y = \"{Infer (mset CAs) DA E | CAs DA AAs As \\<sigma> E.\n    ord_resolve_rename CAs DA AAs As \\<sigma> E \\<and> set CAs \\<union> {DA} \\<subseteq> ?CCC}\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite (ord_FO_resolution.inferences_between CC C)", "let ?X = \"{?infer_of CAs DA AAs As | CAs DA AAs As. CAs \\<in> CAS \\<and> DA \\<in> ?CCC \\<and> AAs \\<in> AAS \\<and> As \\<in> AS}\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite (ord_FO_resolution.inferences_between CC C)", "let ?W = \"CAS \\<times> ?CCC \\<times> AAS \\<times> AS\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite (ord_FO_resolution.inferences_between CC C)", "have fin_w: \"finite ?W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (CAS \\<times> (CC \\<union> {C}) \\<times> AAS \\<times> AS)", "unfolding defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     ({CAs \\<in> lists (CC \\<union> {C}).\n       length CAs \\<le> Max (size ` (CC \\<union> {C}))} \\<times>\n      (CC \\<union> {C}) \\<times>\n      {AAs\n       \\<in> lists\n              (mset `\n               {As \\<in> lists (\\<Union> (atms_of ` (CC \\<union> {C}))).\n                length As \\<le> Max (size ` (CC \\<union> {C}))}).\n       length AAs \\<le> Max (size ` (CC \\<union> {C}))} \\<times>\n      {As \\<in> lists (\\<Union> (atms_of ` (CC \\<union> {C}))).\n       length As \\<le> Max (size ` (CC \\<union> {C}))})", "using fin_cc"], ["proof (prove)\nusing this:\n  finite CC\n\ngoal (1 subgoal):\n 1. finite\n     ({CAs \\<in> lists (CC \\<union> {C}).\n       length CAs \\<le> Max (size ` (CC \\<union> {C}))} \\<times>\n      (CC \\<union> {C}) \\<times>\n      {AAs\n       \\<in> lists\n              (mset `\n               {As \\<in> lists (\\<Union> (atms_of ` (CC \\<union> {C}))).\n                length As \\<le> Max (size ` (CC \\<union> {C}))}).\n       length AAs \\<le> Max (size ` (CC \\<union> {C}))} \\<times>\n      {As \\<in> lists (\\<Union> (atms_of ` (CC \\<union> {C}))).\n       length As \\<le> Max (size ` (CC \\<union> {C}))})", "by (simp add: finite_lists_length_le lists_eq_set)"], ["proof (state)\nthis:\n  finite (CAS \\<times> (CC \\<union> {C}) \\<times> AAS \\<times> AS)\n\ngoal (1 subgoal):\n 1. finite (ord_FO_resolution.inferences_between CC C)", "have \"?Z \\<subseteq> ?Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {uu_.\n     \\<exists>CAs DA AAs As \\<sigma> E \\<gamma>.\n        uu_ = \\<gamma> \\<and>\n        \\<gamma> = Infer (mset CAs) DA E \\<and>\n        ord_resolve_rename CAs DA AAs As \\<sigma> E \\<and>\n        infer_from (CC \\<union> {C}) \\<gamma> \\<and>\n        C \\<in># prems_of \\<gamma>}\n    \\<subseteq> {uu_.\n                 \\<exists>CAs DA AAs As \\<sigma> E.\n                    uu_ = Infer (mset CAs) DA E \\<and>\n                    ord_resolve_rename CAs DA AAs As \\<sigma> E \\<and>\n                    set CAs \\<union> {DA} \\<subseteq> CC \\<union> {C}}", "by (force simp: infer_from_def)"], ["proof (state)\nthis:\n  {uu_.\n   \\<exists>CAs DA AAs As \\<sigma> E \\<gamma>.\n      uu_ = \\<gamma> \\<and>\n      \\<gamma> = Infer (mset CAs) DA E \\<and>\n      ord_resolve_rename CAs DA AAs As \\<sigma> E \\<and>\n      infer_from (CC \\<union> {C}) \\<gamma> \\<and>\n      C \\<in># prems_of \\<gamma>}\n  \\<subseteq> {uu_.\n               \\<exists>CAs DA AAs As \\<sigma> E.\n                  uu_ = Infer (mset CAs) DA E \\<and>\n                  ord_resolve_rename CAs DA AAs As \\<sigma> E \\<and>\n                  set CAs \\<union> {DA} \\<subseteq> CC \\<union> {C}}\n\ngoal (1 subgoal):\n 1. finite (ord_FO_resolution.inferences_between CC C)", "also"], ["proof (state)\nthis:\n  {uu_.\n   \\<exists>CAs DA AAs As \\<sigma> E \\<gamma>.\n      uu_ = \\<gamma> \\<and>\n      \\<gamma> = Infer (mset CAs) DA E \\<and>\n      ord_resolve_rename CAs DA AAs As \\<sigma> E \\<and>\n      infer_from (CC \\<union> {C}) \\<gamma> \\<and>\n      C \\<in># prems_of \\<gamma>}\n  \\<subseteq> {uu_.\n               \\<exists>CAs DA AAs As \\<sigma> E.\n                  uu_ = Infer (mset CAs) DA E \\<and>\n                  ord_resolve_rename CAs DA AAs As \\<sigma> E \\<and>\n                  set CAs \\<union> {DA} \\<subseteq> CC \\<union> {C}}\n\ngoal (1 subgoal):\n 1. finite (ord_FO_resolution.inferences_between CC C)", "have \"\\<dots> \\<subseteq> ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {uu_.\n     \\<exists>CAs DA AAs As \\<sigma> E.\n        uu_ = Infer (mset CAs) DA E \\<and>\n        ord_resolve_rename CAs DA AAs As \\<sigma> E \\<and>\n        set CAs \\<union> {DA} \\<subseteq> CC \\<union> {C}}\n    \\<subseteq> {Infer (mset CAs) DA\n                  (THE E.\n                      \\<exists>\\<sigma>.\n                         ord_resolve_rename CAs DA AAs As \\<sigma> E) |\n                 CAs DA AAs As.\n                 CAs \\<in> CAS \\<and>\n                 DA \\<in> CC \\<union> {C} \\<and>\n                 AAs \\<in> AAS \\<and> As \\<in> AS}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {uu_.\n     \\<exists>CAs DA AAs As \\<sigma> E.\n        uu_ = Infer (mset CAs) DA E \\<and>\n        ord_resolve_rename CAs DA AAs As \\<sigma> E \\<and>\n        set CAs \\<union> {DA} \\<subseteq> CC \\<union> {C}}\n    \\<subseteq> {Infer (mset CAs) DA\n                  (THE E.\n                      \\<exists>\\<sigma>.\n                         ord_resolve_rename CAs DA AAs As \\<sigma> E) |\n                 CAs DA AAs As.\n                 CAs \\<in> CAS \\<and>\n                 DA \\<in> CC \\<union> {C} \\<and>\n                 AAs \\<in> AAS \\<and> As \\<in> AS}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. {uu_.\n     \\<exists>CAs DA AAs As \\<sigma> E.\n        uu_ = Infer (mset CAs) DA E \\<and>\n        ord_resolve_rename CAs DA AAs As \\<sigma> E \\<and>\n        set CAs \\<union> {DA} \\<subseteq> CC \\<union> {C}}\n    \\<subseteq> {Infer (mset CAs) DA\n                  (THE E.\n                      \\<exists>\\<sigma>.\n                         ord_resolve_rename CAs DA AAs As \\<sigma> E) |\n                 CAs DA AAs As.\n                 CAs \\<in> CAS \\<and>\n                 DA \\<in> CC \\<union> {C} \\<and>\n                 AAs \\<in> AAS \\<and> As \\<in> AS}", "fix CAs DA AAs As \\<sigma> E"], ["proof (state)\ngoal (1 subgoal):\n 1. {uu_.\n     \\<exists>CAs DA AAs As \\<sigma> E.\n        uu_ = Infer (mset CAs) DA E \\<and>\n        ord_resolve_rename CAs DA AAs As \\<sigma> E \\<and>\n        set CAs \\<union> {DA} \\<subseteq> CC \\<union> {C}}\n    \\<subseteq> {Infer (mset CAs) DA\n                  (THE E.\n                      \\<exists>\\<sigma>.\n                         ord_resolve_rename CAs DA AAs As \\<sigma> E) |\n                 CAs DA AAs As.\n                 CAs \\<in> CAS \\<and>\n                 DA \\<in> CC \\<union> {C} \\<and>\n                 AAs \\<in> AAS \\<and> As \\<in> AS}", "assume\n        res_e: \"ord_resolve_rename CAs DA AAs As \\<sigma> E\" and\n        da_in: \"DA \\<in> ?CCC\" and\n        cas_sub: \"set CAs \\<subseteq> ?CCC\""], ["proof (state)\nthis:\n  ord_resolve_rename CAs DA AAs As \\<sigma> E\n  DA \\<in> CC \\<union> {C}\n  set CAs \\<subseteq> CC \\<union> {C}\n\ngoal (1 subgoal):\n 1. {uu_.\n     \\<exists>CAs DA AAs As \\<sigma> E.\n        uu_ = Infer (mset CAs) DA E \\<and>\n        ord_resolve_rename CAs DA AAs As \\<sigma> E \\<and>\n        set CAs \\<union> {DA} \\<subseteq> CC \\<union> {C}}\n    \\<subseteq> {Infer (mset CAs) DA\n                  (THE E.\n                      \\<exists>\\<sigma>.\n                         ord_resolve_rename CAs DA AAs As \\<sigma> E) |\n                 CAs DA AAs As.\n                 CAs \\<in> CAS \\<and>\n                 DA \\<in> CC \\<union> {C} \\<and>\n                 AAs \\<in> AAS \\<and> As \\<in> AS}", "have \"E = (THE E. \\<exists>\\<sigma>. ord_resolve_rename CAs DA AAs As \\<sigma> E)\n        \\<and> CAs \\<in> CAS \\<and> AAs \\<in> AAS \\<and> As \\<in> AS\" (is \"?e \\<and> ?cas \\<and> ?aas \\<and> ?as\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. E =\n    (THE E.\n        \\<exists>\\<sigma>.\n           ord_resolve_rename CAs DA AAs As \\<sigma> E) \\<and>\n    CAs \\<in> CAS \\<and> AAs \\<in> AAS \\<and> As \\<in> AS", "proof (intro conjI)"], ["proof (state)\ngoal (4 subgoals):\n 1. E =\n    (THE E. \\<exists>\\<sigma>. ord_resolve_rename CAs DA AAs As \\<sigma> E)\n 2. CAs \\<in> CAS\n 3. AAs \\<in> AAS\n 4. As \\<in> AS", "show ?e"], ["proof (prove)\ngoal (1 subgoal):\n 1. E =\n    (THE E. \\<exists>\\<sigma>. ord_resolve_rename CAs DA AAs As \\<sigma> E)", "using res_e ord_resolve_rename_unique"], ["proof (prove)\nusing this:\n  ord_resolve_rename CAs DA AAs As \\<sigma> E\n  \\<lbrakk>ord_resolve_rename ?CAs ?DA ?AAs ?As ?\\<sigma> ?E;\n   ord_resolve_rename ?CAs ?DA ?AAs ?As ?\\<sigma>' ?E'\\<rbrakk>\n  \\<Longrightarrow> ?\\<sigma> = ?\\<sigma>' \\<and> ?E = ?E'\n\ngoal (1 subgoal):\n 1. E =\n    (THE E. \\<exists>\\<sigma>. ord_resolve_rename CAs DA AAs As \\<sigma> E)", "by (blast intro: the_equality[symmetric])"], ["proof (state)\nthis:\n  E =\n  (THE E. \\<exists>\\<sigma>. ord_resolve_rename CAs DA AAs As \\<sigma> E)\n\ngoal (3 subgoals):\n 1. CAs \\<in> CAS\n 2. AAs \\<in> AAS\n 3. As \\<in> AS", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. CAs \\<in> CAS\n 2. AAs \\<in> AAS\n 3. As \\<in> AS", "show ?cas"], ["proof (prove)\ngoal (1 subgoal):\n 1. CAs \\<in> CAS", "unfolding CAS_def max_ary_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CAs\n    \\<in> {CAs \\<in> lists (CC \\<union> {C}).\n           length CAs \\<le> Max (size ` (CC \\<union> {C}))}", "using cas_sub\n            ord_resolve_rename_max_side_prems[OF res_e] da_in fin_cc"], ["proof (prove)\nusing this:\n  set CAs \\<subseteq> CC \\<union> {C}\n  length CAs \\<le> size DA\n  DA \\<in> CC \\<union> {C}\n  finite CC\n\ngoal (1 subgoal):\n 1. CAs\n    \\<in> {CAs \\<in> lists (CC \\<union> {C}).\n           length CAs \\<le> Max (size ` (CC \\<union> {C}))}", "by (auto simp add: Max_ge_iff)"], ["proof (state)\nthis:\n  CAs \\<in> CAS\n\ngoal (2 subgoals):\n 1. AAs \\<in> AAS\n 2. As \\<in> AS", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. AAs \\<in> AAS\n 2. As \\<in> AS", "show ?aas"], ["proof (prove)\ngoal (1 subgoal):\n 1. AAs \\<in> AAS", "using res_e"], ["proof (prove)\nusing this:\n  ord_resolve_rename CAs DA AAs As \\<sigma> E\n\ngoal (1 subgoal):\n 1. AAs \\<in> AAS", "proof (cases rule: ord_resolve_rename.cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n \\<rho> \\<rho>s.\n       \\<lbrakk>length CAs = n; length AAs = n; length As = n;\n        \\<forall>i<n. poss (AAs ! i) \\<subseteq># CAs ! i;\n        negs (mset As) \\<subseteq># DA;\n        \\<rho> = hd (renamings_apart (DA # CAs));\n        \\<rho>s = tl (renamings_apart (DA # CAs));\n        ord_resolve (CAs \\<cdot>\\<cdot>cl \\<rho>s) (DA \\<cdot> \\<rho>)\n         (AAs \\<cdot>\\<cdot>aml \\<rho>s) (As \\<cdot>al \\<rho>) \\<sigma>\n         E\\<rbrakk>\n       \\<Longrightarrow> AAs \\<in> AAS", "case (ord_resolve_rename n \\<rho> \\<rho>s)"], ["proof (state)\nthis:\n  length CAs = n\n  length AAs = n\n  length As = n\n  \\<forall>i<n. poss (AAs ! i) \\<subseteq># CAs ! i\n  negs (mset As) \\<subseteq># DA\n  \\<rho> = hd (renamings_apart (DA # CAs))\n  \\<rho>s = tl (renamings_apart (DA # CAs))\n  ord_resolve (CAs \\<cdot>\\<cdot>cl \\<rho>s) (DA \\<cdot> \\<rho>)\n   (AAs \\<cdot>\\<cdot>aml \\<rho>s) (As \\<cdot>al \\<rho>) \\<sigma> E\n\ngoal (1 subgoal):\n 1. \\<And>n \\<rho> \\<rho>s.\n       \\<lbrakk>length CAs = n; length AAs = n; length As = n;\n        \\<forall>i<n. poss (AAs ! i) \\<subseteq># CAs ! i;\n        negs (mset As) \\<subseteq># DA;\n        \\<rho> = hd (renamings_apart (DA # CAs));\n        \\<rho>s = tl (renamings_apart (DA # CAs));\n        ord_resolve (CAs \\<cdot>\\<cdot>cl \\<rho>s) (DA \\<cdot> \\<rho>)\n         (AAs \\<cdot>\\<cdot>aml \\<rho>s) (As \\<cdot>al \\<rho>) \\<sigma>\n         E\\<rbrakk>\n       \\<Longrightarrow> AAs \\<in> AAS", "note len_cas = this(1) and len_aas = this(2) and len_as = this(3) and\n            aas_sub = this(4) and as_sub = this(5) and res_e' = this(8)"], ["proof (state)\nthis:\n  length CAs = n\n  length AAs = n\n  length As = n\n  \\<forall>i<n. poss (AAs ! i) \\<subseteq># CAs ! i\n  negs (mset As) \\<subseteq># DA\n  ord_resolve (CAs \\<cdot>\\<cdot>cl \\<rho>s) (DA \\<cdot> \\<rho>)\n   (AAs \\<cdot>\\<cdot>aml \\<rho>s) (As \\<cdot>al \\<rho>) \\<sigma> E\n\ngoal (1 subgoal):\n 1. \\<And>n \\<rho> \\<rho>s.\n       \\<lbrakk>length CAs = n; length AAs = n; length As = n;\n        \\<forall>i<n. poss (AAs ! i) \\<subseteq># CAs ! i;\n        negs (mset As) \\<subseteq># DA;\n        \\<rho> = hd (renamings_apart (DA # CAs));\n        \\<rho>s = tl (renamings_apart (DA # CAs));\n        ord_resolve (CAs \\<cdot>\\<cdot>cl \\<rho>s) (DA \\<cdot> \\<rho>)\n         (AAs \\<cdot>\\<cdot>aml \\<rho>s) (As \\<cdot>al \\<rho>) \\<sigma>\n         E\\<rbrakk>\n       \\<Longrightarrow> AAs \\<in> AAS", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. AAs \\<in> AAS", "unfolding AAS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. AAs \\<in> {AAs \\<in> lists (mset ` AS). length AAs \\<le> max_ary}", "proof (clarify, intro conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. AAs \\<in> lists (mset ` AS)\n 2. length AAs \\<le> max_ary", "show \"AAs \\<in> lists (mset ` AS)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AAs \\<in> lists (mset ` AS)", "unfolding AS_def image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. AAs\n    \\<in> lists\n           {y. \\<exists>x\\<in>{As \\<in> lists all_AA.\n                               length As \\<le> max_ary}.\n                  y = mset x}", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set AAs \\<Longrightarrow>\n       \\<exists>xa.\n          xa \\<in> lists all_AA \\<and>\n          length xa \\<le> max_ary \\<and> x = mset xa", "fix AA"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set AAs \\<Longrightarrow>\n       \\<exists>xa.\n          xa \\<in> lists all_AA \\<and>\n          length xa \\<le> max_ary \\<and> x = mset xa", "assume \"AA \\<in> set AAs\""], ["proof (state)\nthis:\n  AA \\<in> set AAs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set AAs \\<Longrightarrow>\n       \\<exists>xa.\n          xa \\<in> lists all_AA \\<and>\n          length xa \\<le> max_ary \\<and> x = mset xa", "then"], ["proof (chain)\npicking this:\n  AA \\<in> set AAs", "obtain i where\n                i_lt: \"i < n\" and\n                aa: \"AA = AAs ! i\""], ["proof (prove)\nusing this:\n  AA \\<in> set AAs\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < n; AA = AAs ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis in_set_conv_nth len_aas)"], ["proof (state)\nthis:\n  i < n\n  AA = AAs ! i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set AAs \\<Longrightarrow>\n       \\<exists>xa.\n          xa \\<in> lists all_AA \\<and>\n          length xa \\<le> max_ary \\<and> x = mset xa", "have casi_in: \"CAs ! i \\<in> ?CCC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CAs ! i \\<in> CC \\<union> {C}", "using i_lt len_cas cas_sub nth_mem"], ["proof (prove)\nusing this:\n  i < n\n  length CAs = n\n  set CAs \\<subseteq> CC \\<union> {C}\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. CAs ! i \\<in> CC \\<union> {C}", "by blast"], ["proof (state)\nthis:\n  CAs ! i \\<in> CC \\<union> {C}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set AAs \\<Longrightarrow>\n       \\<exists>xa.\n          xa \\<in> lists all_AA \\<and>\n          length xa \\<le> max_ary \\<and> x = mset xa", "have pos_aa_sub: \"poss AA \\<subseteq># CAs ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poss AA \\<subseteq># CAs ! i", "using aa aas_sub i_lt"], ["proof (prove)\nusing this:\n  AA = AAs ! i\n  \\<forall>i<n. poss (AAs ! i) \\<subseteq># CAs ! i\n  i < n\n\ngoal (1 subgoal):\n 1. poss AA \\<subseteq># CAs ! i", "by blast"], ["proof (state)\nthis:\n  poss AA \\<subseteq># CAs ! i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set AAs \\<Longrightarrow>\n       \\<exists>xa.\n          xa \\<in> lists all_AA \\<and>\n          length xa \\<le> max_ary \\<and> x = mset xa", "then"], ["proof (chain)\npicking this:\n  poss AA \\<subseteq># CAs ! i", "have \"set_mset AA \\<subseteq> atms_of (CAs ! i)\""], ["proof (prove)\nusing this:\n  poss AA \\<subseteq># CAs ! i\n\ngoal (1 subgoal):\n 1. set_mset AA \\<subseteq> atms_of (CAs ! i)", "by (metis atms_of_poss lits_subseteq_imp_atms_subseteq set_mset_mono)"], ["proof (state)\nthis:\n  set_mset AA \\<subseteq> atms_of (CAs ! i)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set AAs \\<Longrightarrow>\n       \\<exists>xa.\n          xa \\<in> lists all_AA \\<and>\n          length xa \\<le> max_ary \\<and> x = mset xa", "also"], ["proof (state)\nthis:\n  set_mset AA \\<subseteq> atms_of (CAs ! i)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set AAs \\<Longrightarrow>\n       \\<exists>xa.\n          xa \\<in> lists all_AA \\<and>\n          length xa \\<le> max_ary \\<and> x = mset xa", "have aa_sub: \"\\<dots> \\<subseteq> all_AA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atms_of (CAs ! i) \\<subseteq> all_AA", "unfolding all_AA_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. atms_of (CAs ! i) \\<subseteq> \\<Union> (atms_of ` (CC \\<union> {C}))", "using casi_in"], ["proof (prove)\nusing this:\n  CAs ! i \\<in> CC \\<union> {C}\n\ngoal (1 subgoal):\n 1. atms_of (CAs ! i) \\<subseteq> \\<Union> (atms_of ` (CC \\<union> {C}))", "by force"], ["proof (state)\nthis:\n  atms_of (CAs ! i) \\<subseteq> all_AA\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set AAs \\<Longrightarrow>\n       \\<exists>xa.\n          xa \\<in> lists all_AA \\<and>\n          length xa \\<le> max_ary \\<and> x = mset xa", "finally"], ["proof (chain)\npicking this:\n  set_mset AA \\<subseteq> all_AA", "have aa_sub: \"set_mset AA \\<subseteq> all_AA\""], ["proof (prove)\nusing this:\n  set_mset AA \\<subseteq> all_AA\n\ngoal (1 subgoal):\n 1. set_mset AA \\<subseteq> all_AA", "."], ["proof (state)\nthis:\n  set_mset AA \\<subseteq> all_AA\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set AAs \\<Longrightarrow>\n       \\<exists>xa.\n          xa \\<in> lists all_AA \\<and>\n          length xa \\<le> max_ary \\<and> x = mset xa", "have \"size AA = size (poss AA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size AA = size (poss AA)", "by simp"], ["proof (state)\nthis:\n  size AA = size (poss AA)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set AAs \\<Longrightarrow>\n       \\<exists>xa.\n          xa \\<in> lists all_AA \\<and>\n          length xa \\<le> max_ary \\<and> x = mset xa", "also"], ["proof (state)\nthis:\n  size AA = size (poss AA)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set AAs \\<Longrightarrow>\n       \\<exists>xa.\n          xa \\<in> lists all_AA \\<and>\n          length xa \\<le> max_ary \\<and> x = mset xa", "have \"\\<dots> \\<le> size (CAs ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (poss AA) \\<le> size (CAs ! i)", "by (rule size_mset_mono[OF pos_aa_sub])"], ["proof (state)\nthis:\n  size (poss AA) \\<le> size (CAs ! i)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set AAs \\<Longrightarrow>\n       \\<exists>xa.\n          xa \\<in> lists all_AA \\<and>\n          length xa \\<le> max_ary \\<and> x = mset xa", "also"], ["proof (state)\nthis:\n  size (poss AA) \\<le> size (CAs ! i)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set AAs \\<Longrightarrow>\n       \\<exists>xa.\n          xa \\<in> lists all_AA \\<and>\n          length xa \\<le> max_ary \\<and> x = mset xa", "have \"\\<dots> \\<le> max_ary\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (CAs ! i) \\<le> max_ary", "unfolding max_ary_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. size (CAs ! i) \\<le> Max (size ` (CC \\<union> {C}))", "using fin_cc casi_in"], ["proof (prove)\nusing this:\n  finite CC\n  CAs ! i \\<in> CC \\<union> {C}\n\ngoal (1 subgoal):\n 1. size (CAs ! i) \\<le> Max (size ` (CC \\<union> {C}))", "by auto"], ["proof (state)\nthis:\n  size (CAs ! i) \\<le> max_ary\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set AAs \\<Longrightarrow>\n       \\<exists>xa.\n          xa \\<in> lists all_AA \\<and>\n          length xa \\<le> max_ary \\<and> x = mset xa", "finally"], ["proof (chain)\npicking this:\n  size AA \\<le> max_ary", "have sz_aa: \"size AA \\<le> max_ary\""], ["proof (prove)\nusing this:\n  size AA \\<le> max_ary\n\ngoal (1 subgoal):\n 1. size AA \\<le> max_ary", "."], ["proof (state)\nthis:\n  size AA \\<le> max_ary\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set AAs \\<Longrightarrow>\n       \\<exists>xa.\n          xa \\<in> lists all_AA \\<and>\n          length xa \\<le> max_ary \\<and> x = mset xa", "let ?As' = \"sorted_list_of_multiset AA\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set AAs \\<Longrightarrow>\n       \\<exists>xa.\n          xa \\<in> lists all_AA \\<and>\n          length xa \\<le> max_ary \\<and> x = mset xa", "have \"?As' \\<in> lists all_AA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_list_of_multiset AA \\<in> lists all_AA", "using aa_sub"], ["proof (prove)\nusing this:\n  set_mset AA \\<subseteq> all_AA\n\ngoal (1 subgoal):\n 1. sorted_list_of_multiset AA \\<in> lists all_AA", "by auto"], ["proof (state)\nthis:\n  sorted_list_of_multiset AA \\<in> lists all_AA\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set AAs \\<Longrightarrow>\n       \\<exists>xa.\n          xa \\<in> lists all_AA \\<and>\n          length xa \\<le> max_ary \\<and> x = mset xa", "moreover"], ["proof (state)\nthis:\n  sorted_list_of_multiset AA \\<in> lists all_AA\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set AAs \\<Longrightarrow>\n       \\<exists>xa.\n          xa \\<in> lists all_AA \\<and>\n          length xa \\<le> max_ary \\<and> x = mset xa", "have \"length ?As' \\<le> max_ary\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (sorted_list_of_multiset AA) \\<le> max_ary", "using sz_aa"], ["proof (prove)\nusing this:\n  size AA \\<le> max_ary\n\ngoal (1 subgoal):\n 1. length (sorted_list_of_multiset AA) \\<le> max_ary", "by simp"], ["proof (state)\nthis:\n  length (sorted_list_of_multiset AA) \\<le> max_ary\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set AAs \\<Longrightarrow>\n       \\<exists>xa.\n          xa \\<in> lists all_AA \\<and>\n          length xa \\<le> max_ary \\<and> x = mset xa", "moreover"], ["proof (state)\nthis:\n  length (sorted_list_of_multiset AA) \\<le> max_ary\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set AAs \\<Longrightarrow>\n       \\<exists>xa.\n          xa \\<in> lists all_AA \\<and>\n          length xa \\<le> max_ary \\<and> x = mset xa", "have \"AA = mset ?As'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AA = mset (sorted_list_of_multiset AA)", "by simp"], ["proof (state)\nthis:\n  AA = mset (sorted_list_of_multiset AA)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set AAs \\<Longrightarrow>\n       \\<exists>xa.\n          xa \\<in> lists all_AA \\<and>\n          length xa \\<le> max_ary \\<and> x = mset xa", "ultimately"], ["proof (chain)\npicking this:\n  sorted_list_of_multiset AA \\<in> lists all_AA\n  length (sorted_list_of_multiset AA) \\<le> max_ary\n  AA = mset (sorted_list_of_multiset AA)", "show \"\\<exists>xa. xa \\<in> lists all_AA \\<and> length xa \\<le> max_ary \\<and> AA = mset xa\""], ["proof (prove)\nusing this:\n  sorted_list_of_multiset AA \\<in> lists all_AA\n  length (sorted_list_of_multiset AA) \\<le> max_ary\n  AA = mset (sorted_list_of_multiset AA)\n\ngoal (1 subgoal):\n 1. \\<exists>xa.\n       xa \\<in> lists all_AA \\<and>\n       length xa \\<le> max_ary \\<and> AA = mset xa", "by blast"], ["proof (state)\nthis:\n  \\<exists>xa.\n     xa \\<in> lists all_AA \\<and>\n     length xa \\<le> max_ary \\<and> AA = mset xa\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  AAs \\<in> lists (mset ` AS)\n\ngoal (1 subgoal):\n 1. length AAs \\<le> max_ary", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. length AAs \\<le> max_ary", "have \"length AAs = length As\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length AAs = length As", "unfolding len_aas len_as"], ["proof (prove)\ngoal (1 subgoal):\n 1. n = n", ".."], ["proof (state)\nthis:\n  length AAs = length As\n\ngoal (1 subgoal):\n 1. length AAs \\<le> max_ary", "also"], ["proof (state)\nthis:\n  length AAs = length As\n\ngoal (1 subgoal):\n 1. length AAs \\<le> max_ary", "have \"\\<dots> \\<le> size DA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length As \\<le> size DA", "using as_sub size_mset_mono"], ["proof (prove)\nusing this:\n  negs (mset As) \\<subseteq># DA\n  ?A \\<subseteq># ?B \\<Longrightarrow> size ?A \\<le> size ?B\n\ngoal (1 subgoal):\n 1. length As \\<le> size DA", "by fastforce"], ["proof (state)\nthis:\n  length As \\<le> size DA\n\ngoal (1 subgoal):\n 1. length AAs \\<le> max_ary", "also"], ["proof (state)\nthis:\n  length As \\<le> size DA\n\ngoal (1 subgoal):\n 1. length AAs \\<le> max_ary", "have \"\\<dots> \\<le> max_ary\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size DA \\<le> max_ary", "unfolding max_ary_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. size DA \\<le> Max (size ` (CC \\<union> {C}))", "using fin_cc da_in"], ["proof (prove)\nusing this:\n  finite CC\n  DA \\<in> CC \\<union> {C}\n\ngoal (1 subgoal):\n 1. size DA \\<le> Max (size ` (CC \\<union> {C}))", "by auto"], ["proof (state)\nthis:\n  size DA \\<le> max_ary\n\ngoal (1 subgoal):\n 1. length AAs \\<le> max_ary", "finally"], ["proof (chain)\npicking this:\n  length AAs \\<le> max_ary", "show \"length AAs \\<le> max_ary\""], ["proof (prove)\nusing this:\n  length AAs \\<le> max_ary\n\ngoal (1 subgoal):\n 1. length AAs \\<le> max_ary", "."], ["proof (state)\nthis:\n  length AAs \\<le> max_ary\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  AAs \\<in> AAS\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  AAs \\<in> AAS\n\ngoal (1 subgoal):\n 1. As \\<in> AS", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. As \\<in> AS", "show ?as"], ["proof (prove)\ngoal (1 subgoal):\n 1. As \\<in> AS", "unfolding AS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. As \\<in> {As \\<in> lists all_AA. length As \\<le> max_ary}", "proof (clarify, intro conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. As \\<in> lists all_AA\n 2. length As \\<le> max_ary", "have \"set As \\<subseteq> atms_of DA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set As \\<subseteq> atms_of DA", "using res_e[simplified ord_resolve_rename.simps]"], ["proof (prove)\nusing this:\n  \\<exists>CAsa n AAsa Asa DAa \\<rho> \\<rho>s \\<sigma>' Ea.\n     CAs = CAsa \\<and>\n     DA = DAa \\<and>\n     AAs = AAsa \\<and>\n     As = Asa \\<and>\n     \\<sigma> = \\<sigma>' \\<and>\n     E = Ea \\<and>\n     length CAsa = n \\<and>\n     length AAsa = n \\<and>\n     length Asa = n \\<and>\n     (\\<forall>i<n. poss (AAsa ! i) \\<subseteq># CAsa ! i) \\<and>\n     negs (mset Asa) \\<subseteq># DAa \\<and>\n     \\<rho> = hd (renamings_apart (DAa # CAsa)) \\<and>\n     \\<rho>s = tl (renamings_apart (DAa # CAsa)) \\<and>\n     ord_resolve (CAsa \\<cdot>\\<cdot>cl \\<rho>s) (DAa \\<cdot> \\<rho>)\n      (AAsa \\<cdot>\\<cdot>aml \\<rho>s) (Asa \\<cdot>al \\<rho>) \\<sigma>' Ea\n\ngoal (1 subgoal):\n 1. set As \\<subseteq> atms_of DA", "by (metis atms_of_negs lits_subseteq_imp_atms_subseteq set_mset_mono set_mset_mset)"], ["proof (state)\nthis:\n  set As \\<subseteq> atms_of DA\n\ngoal (2 subgoals):\n 1. As \\<in> lists all_AA\n 2. length As \\<le> max_ary", "also"], ["proof (state)\nthis:\n  set As \\<subseteq> atms_of DA\n\ngoal (2 subgoals):\n 1. As \\<in> lists all_AA\n 2. length As \\<le> max_ary", "have \"\\<dots> \\<subseteq> all_AA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atms_of DA \\<subseteq> all_AA", "unfolding all_AA_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. atms_of DA \\<subseteq> \\<Union> (atms_of ` (CC \\<union> {C}))", "using da_in"], ["proof (prove)\nusing this:\n  DA \\<in> CC \\<union> {C}\n\ngoal (1 subgoal):\n 1. atms_of DA \\<subseteq> \\<Union> (atms_of ` (CC \\<union> {C}))", "by blast"], ["proof (state)\nthis:\n  atms_of DA \\<subseteq> all_AA\n\ngoal (2 subgoals):\n 1. As \\<in> lists all_AA\n 2. length As \\<le> max_ary", "finally"], ["proof (chain)\npicking this:\n  set As \\<subseteq> all_AA", "show \"As \\<in> lists all_AA\""], ["proof (prove)\nusing this:\n  set As \\<subseteq> all_AA\n\ngoal (1 subgoal):\n 1. As \\<in> lists all_AA", "unfolding lists_eq_set"], ["proof (prove)\nusing this:\n  set As \\<subseteq> all_AA\n\ngoal (1 subgoal):\n 1. As \\<in> {xs. set xs \\<subseteq> all_AA}", "by simp"], ["proof (state)\nthis:\n  As \\<in> lists all_AA\n\ngoal (1 subgoal):\n 1. length As \\<le> max_ary", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. length As \\<le> max_ary", "have \"length As \\<le> size DA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length As \\<le> size DA", "using res_e[simplified ord_resolve_rename.simps]\n              ord_resolve_rename_max_side_prems[OF res_e]"], ["proof (prove)\nusing this:\n  \\<exists>CAsa n AAsa Asa DAa \\<rho> \\<rho>s \\<sigma>' Ea.\n     CAs = CAsa \\<and>\n     DA = DAa \\<and>\n     AAs = AAsa \\<and>\n     As = Asa \\<and>\n     \\<sigma> = \\<sigma>' \\<and>\n     E = Ea \\<and>\n     length CAsa = n \\<and>\n     length AAsa = n \\<and>\n     length Asa = n \\<and>\n     (\\<forall>i<n. poss (AAsa ! i) \\<subseteq># CAsa ! i) \\<and>\n     negs (mset Asa) \\<subseteq># DAa \\<and>\n     \\<rho> = hd (renamings_apart (DAa # CAsa)) \\<and>\n     \\<rho>s = tl (renamings_apart (DAa # CAsa)) \\<and>\n     ord_resolve (CAsa \\<cdot>\\<cdot>cl \\<rho>s) (DAa \\<cdot> \\<rho>)\n      (AAsa \\<cdot>\\<cdot>aml \\<rho>s) (Asa \\<cdot>al \\<rho>) \\<sigma>' Ea\n  length CAs \\<le> size DA\n\ngoal (1 subgoal):\n 1. length As \\<le> size DA", "by auto"], ["proof (state)\nthis:\n  length As \\<le> size DA\n\ngoal (1 subgoal):\n 1. length As \\<le> max_ary", "also"], ["proof (state)\nthis:\n  length As \\<le> size DA\n\ngoal (1 subgoal):\n 1. length As \\<le> max_ary", "have \"size DA \\<le> max_ary\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size DA \\<le> max_ary", "unfolding max_ary_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. size DA \\<le> Max (size ` (CC \\<union> {C}))", "using fin_cc da_in"], ["proof (prove)\nusing this:\n  finite CC\n  DA \\<in> CC \\<union> {C}\n\ngoal (1 subgoal):\n 1. size DA \\<le> Max (size ` (CC \\<union> {C}))", "by auto"], ["proof (state)\nthis:\n  size DA \\<le> max_ary\n\ngoal (1 subgoal):\n 1. length As \\<le> max_ary", "finally"], ["proof (chain)\npicking this:\n  length As \\<le> max_ary", "show \"length As \\<le> max_ary\""], ["proof (prove)\nusing this:\n  length As \\<le> max_ary\n\ngoal (1 subgoal):\n 1. length As \\<le> max_ary", "."], ["proof (state)\nthis:\n  length As \\<le> max_ary\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  As \\<in> AS\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  E =\n  (THE E.\n      \\<exists>\\<sigma>. ord_resolve_rename CAs DA AAs As \\<sigma> E) \\<and>\n  CAs \\<in> CAS \\<and> AAs \\<in> AAS \\<and> As \\<in> AS\n\ngoal (1 subgoal):\n 1. {uu_.\n     \\<exists>CAs DA AAs As \\<sigma> E.\n        uu_ = Infer (mset CAs) DA E \\<and>\n        ord_resolve_rename CAs DA AAs As \\<sigma> E \\<and>\n        set CAs \\<union> {DA} \\<subseteq> CC \\<union> {C}}\n    \\<subseteq> {Infer (mset CAs) DA\n                  (THE E.\n                      \\<exists>\\<sigma>.\n                         ord_resolve_rename CAs DA AAs As \\<sigma> E) |\n                 CAs DA AAs As.\n                 CAs \\<in> CAS \\<and>\n                 DA \\<in> CC \\<union> {C} \\<and>\n                 AAs \\<in> AAS \\<and> As \\<in> AS}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>ord_resolve_rename ?CAs2 ?DA2 ?AAs2 ?As2 ?\\<sigma>2 ?E2;\n   ?DA2 \\<in> CC \\<union> {C};\n   set ?CAs2 \\<subseteq> CC \\<union> {C}\\<rbrakk>\n  \\<Longrightarrow> ?E2 =\n                    (THE E.\n                        \\<exists>\\<sigma>.\n                           ord_resolve_rename ?CAs2 ?DA2 ?AAs2 ?As2 \\<sigma>\n                            E) \\<and>\n                    ?CAs2 \\<in> CAS \\<and>\n                    ?AAs2 \\<in> AAS \\<and> ?As2 \\<in> AS\n\ngoal (1 subgoal):\n 1. {uu_.\n     \\<exists>CAs DA AAs As \\<sigma> E.\n        uu_ = Infer (mset CAs) DA E \\<and>\n        ord_resolve_rename CAs DA AAs As \\<sigma> E \\<and>\n        set CAs \\<union> {DA} \\<subseteq> CC \\<union> {C}}\n    \\<subseteq> {Infer (mset CAs) DA\n                  (THE E.\n                      \\<exists>\\<sigma>.\n                         ord_resolve_rename CAs DA AAs As \\<sigma> E) |\n                 CAs DA AAs As.\n                 CAs \\<in> CAS \\<and>\n                 DA \\<in> CC \\<union> {C} \\<and>\n                 AAs \\<in> AAS \\<and> As \\<in> AS}", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>ord_resolve_rename ?CAs2 ?DA2 ?AAs2 ?As2 ?\\<sigma>2 ?E2;\n   ?DA2 \\<in> CC \\<union> {C};\n   set ?CAs2 \\<subseteq> CC \\<union> {C}\\<rbrakk>\n  \\<Longrightarrow> ?E2 =\n                    (THE E.\n                        \\<exists>\\<sigma>.\n                           ord_resolve_rename ?CAs2 ?DA2 ?AAs2 ?As2 \\<sigma>\n                            E) \\<and>\n                    ?CAs2 \\<in> CAS \\<and>\n                    ?AAs2 \\<in> AAS \\<and> ?As2 \\<in> AS", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>ord_resolve_rename ?CAs2 ?DA2 ?AAs2 ?As2 ?\\<sigma>2 ?E2;\n   ?DA2 \\<in> CC \\<union> {C};\n   set ?CAs2 \\<subseteq> CC \\<union> {C}\\<rbrakk>\n  \\<Longrightarrow> ?E2 =\n                    (THE E.\n                        \\<exists>\\<sigma>.\n                           ord_resolve_rename ?CAs2 ?DA2 ?AAs2 ?As2 \\<sigma>\n                            E) \\<and>\n                    ?CAs2 \\<in> CAS \\<and>\n                    ?AAs2 \\<in> AAS \\<and> ?As2 \\<in> AS\n\ngoal (1 subgoal):\n 1. {uu_.\n     \\<exists>CAs DA AAs As \\<sigma> E.\n        uu_ = Infer (mset CAs) DA E \\<and>\n        ord_resolve_rename CAs DA AAs As \\<sigma> E \\<and>\n        set CAs \\<union> {DA} \\<subseteq> CC \\<union> {C}}\n    \\<subseteq> {Infer (mset CAs) DA\n                  (THE E.\n                      \\<exists>\\<sigma>.\n                         ord_resolve_rename CAs DA AAs As \\<sigma> E) |\n                 CAs DA AAs As.\n                 CAs \\<in> CAS \\<and>\n                 DA \\<in> CC \\<union> {C} \\<and>\n                 AAs \\<in> AAS \\<and> As \\<in> AS}", "by simp fast"], ["proof (state)\nthis:\n  {uu_.\n   \\<exists>CAs DA AAs As \\<sigma> E.\n      uu_ = Infer (mset CAs) DA E \\<and>\n      ord_resolve_rename CAs DA AAs As \\<sigma> E \\<and>\n      set CAs \\<union> {DA} \\<subseteq> CC \\<union> {C}}\n  \\<subseteq> {Infer (mset CAs) DA\n                (THE E.\n                    \\<exists>\\<sigma>.\n                       ord_resolve_rename CAs DA AAs As \\<sigma> E) |\n               CAs DA AAs As.\n               CAs \\<in> CAS \\<and>\n               DA \\<in> CC \\<union> {C} \\<and>\n               AAs \\<in> AAS \\<and> As \\<in> AS}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {uu_.\n   \\<exists>CAs DA AAs As \\<sigma> E.\n      uu_ = Infer (mset CAs) DA E \\<and>\n      ord_resolve_rename CAs DA AAs As \\<sigma> E \\<and>\n      set CAs \\<union> {DA} \\<subseteq> CC \\<union> {C}}\n  \\<subseteq> {Infer (mset CAs) DA\n                (THE E.\n                    \\<exists>\\<sigma>.\n                       ord_resolve_rename CAs DA AAs As \\<sigma> E) |\n               CAs DA AAs As.\n               CAs \\<in> CAS \\<and>\n               DA \\<in> CC \\<union> {C} \\<and>\n               AAs \\<in> AAS \\<and> As \\<in> AS}\n\ngoal (1 subgoal):\n 1. finite (ord_FO_resolution.inferences_between CC C)", "also"], ["proof (state)\nthis:\n  {uu_.\n   \\<exists>CAs DA AAs As \\<sigma> E.\n      uu_ = Infer (mset CAs) DA E \\<and>\n      ord_resolve_rename CAs DA AAs As \\<sigma> E \\<and>\n      set CAs \\<union> {DA} \\<subseteq> CC \\<union> {C}}\n  \\<subseteq> {Infer (mset CAs) DA\n                (THE E.\n                    \\<exists>\\<sigma>.\n                       ord_resolve_rename CAs DA AAs As \\<sigma> E) |\n               CAs DA AAs As.\n               CAs \\<in> CAS \\<and>\n               DA \\<in> CC \\<union> {C} \\<and>\n               AAs \\<in> AAS \\<and> As \\<in> AS}\n\ngoal (1 subgoal):\n 1. finite (ord_FO_resolution.inferences_between CC C)", "have \"\\<dots> \\<subseteq> (\\<lambda>(CAs, DA, AAs, As). ?infer_of CAs DA AAs As) ` ?W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Infer (mset CAs) DA\n      (THE E.\n          \\<exists>\\<sigma>. ord_resolve_rename CAs DA AAs As \\<sigma> E) |\n     CAs DA AAs As.\n     CAs \\<in> CAS \\<and>\n     DA \\<in> CC \\<union> {C} \\<and> AAs \\<in> AAS \\<and> As \\<in> AS}\n    \\<subseteq> (\\<lambda>(CAs, DA, AAs, As).\n                    Infer (mset CAs) DA\n                     (THE E.\n                         \\<exists>\\<sigma>.\n                            ord_resolve_rename CAs DA AAs As \\<sigma> E)) `\n                (CAS \\<times> (CC \\<union> {C}) \\<times> AAS \\<times> AS)", "unfolding image_def Bex_cartesian_product"], ["proof (prove)\ngoal (1 subgoal):\n 1. {Infer (mset CAs) DA\n      (THE E.\n          \\<exists>\\<sigma>. ord_resolve_rename CAs DA AAs As \\<sigma> E) |\n     CAs DA AAs As.\n     CAs \\<in> CAS \\<and>\n     DA \\<in> CC \\<union> {C} \\<and> AAs \\<in> AAS \\<and> As \\<in> AS}\n    \\<subseteq> {y. \\<exists>x\\<in>CAS.\n                       \\<exists>xa\\<in>CC \\<union> {C}.\n                          \\<exists>xaa\\<in>AAS.\n                             \\<exists>ya\\<in>AS.\n                                y =\n                                (case (x, xa, xaa, ya) of\n                                 (CAs, DA, AAs, As) \\<Rightarrow>\n                                   Infer (mset CAs) DA\n                                    (THE E.\n  \\<exists>\\<sigma>. ord_resolve_rename CAs DA AAs As \\<sigma> E))}", "by fast"], ["proof (state)\nthis:\n  {Infer (mset CAs) DA\n    (THE E.\n        \\<exists>\\<sigma>. ord_resolve_rename CAs DA AAs As \\<sigma> E) |\n   CAs DA AAs As.\n   CAs \\<in> CAS \\<and>\n   DA \\<in> CC \\<union> {C} \\<and> AAs \\<in> AAS \\<and> As \\<in> AS}\n  \\<subseteq> (\\<lambda>(CAs, DA, AAs, As).\n                  Infer (mset CAs) DA\n                   (THE E.\n                       \\<exists>\\<sigma>.\n                          ord_resolve_rename CAs DA AAs As \\<sigma> E)) `\n              (CAS \\<times> (CC \\<union> {C}) \\<times> AAS \\<times> AS)\n\ngoal (1 subgoal):\n 1. finite (ord_FO_resolution.inferences_between CC C)", "finally"], ["proof (chain)\npicking this:\n  {uu_.\n   \\<exists>CAs DA AAs As \\<sigma> E \\<gamma>.\n      uu_ = \\<gamma> \\<and>\n      \\<gamma> = Infer (mset CAs) DA E \\<and>\n      ord_resolve_rename CAs DA AAs As \\<sigma> E \\<and>\n      infer_from (CC \\<union> {C}) \\<gamma> \\<and>\n      C \\<in># prems_of \\<gamma>}\n  \\<subseteq> (\\<lambda>(CAs, DA, AAs, As).\n                  Infer (mset CAs) DA\n                   (THE E.\n                       \\<exists>\\<sigma>.\n                          ord_resolve_rename CAs DA AAs As \\<sigma> E)) `\n              (CAS \\<times> (CC \\<union> {C}) \\<times> AAS \\<times> AS)", "show ?thesis"], ["proof (prove)\nusing this:\n  {uu_.\n   \\<exists>CAs DA AAs As \\<sigma> E \\<gamma>.\n      uu_ = \\<gamma> \\<and>\n      \\<gamma> = Infer (mset CAs) DA E \\<and>\n      ord_resolve_rename CAs DA AAs As \\<sigma> E \\<and>\n      infer_from (CC \\<union> {C}) \\<gamma> \\<and>\n      C \\<in># prems_of \\<gamma>}\n  \\<subseteq> (\\<lambda>(CAs, DA, AAs, As).\n                  Infer (mset CAs) DA\n                   (THE E.\n                       \\<exists>\\<sigma>.\n                          ord_resolve_rename CAs DA AAs As \\<sigma> E)) `\n              (CAS \\<times> (CC \\<union> {C}) \\<times> AAS \\<times> AS)\n\ngoal (1 subgoal):\n 1. finite (ord_FO_resolution.inferences_between CC C)", "unfolding inference_system.inferences_between_def ord_FO_\\<Gamma>_def mem_Collect_eq"], ["proof (prove)\nusing this:\n  {uu_.\n   \\<exists>CAs DA AAs As \\<sigma> E \\<gamma>.\n      uu_ = \\<gamma> \\<and>\n      \\<gamma> = Infer (mset CAs) DA E \\<and>\n      ord_resolve_rename CAs DA AAs As \\<sigma> E \\<and>\n      infer_from (CC \\<union> {C}) \\<gamma> \\<and>\n      C \\<in># prems_of \\<gamma>}\n  \\<subseteq> (\\<lambda>(CAs, DA, AAs, As).\n                  Infer (mset CAs) DA\n                   (THE E.\n                       \\<exists>\\<sigma>.\n                          ord_resolve_rename CAs DA AAs As \\<sigma> E)) `\n              (CAS \\<times> (CC \\<union> {C}) \\<times> AAS \\<times> AS)\n\ngoal (1 subgoal):\n 1. finite\n     {\\<gamma>.\n      (\\<exists>CAs DA AAs As \\<sigma> E.\n          \\<gamma> = Infer (mset CAs) DA E \\<and>\n          ord_resolve_rename CAs DA AAs As \\<sigma> E) \\<and>\n      infer_from (CC \\<union> {C}) \\<gamma> \\<and>\n      C \\<in># prems_of \\<gamma>}", "by (fast intro: rev_finite_subset[OF finite_imageI[OF fin_w]])"], ["proof (state)\nthis:\n  finite (ord_FO_resolution.inferences_between CC C)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ord_FO_resolution_inferences_between_empty_empty:\n  \"ord_FO_resolution.inferences_between {} {#} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_FO_resolution.inferences_between {} {#} = {}", "unfolding ord_FO_resolution.inferences_between_def inference_system.inferences_between_def\n    infer_from_def ord_FO_\\<Gamma>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<gamma>\n     \\<in> {uu_.\n            \\<exists>CAs DA AAs As \\<sigma> E.\n               uu_ = Infer (mset CAs) DA E \\<and>\n               ord_resolve_rename CAs DA AAs As \\<sigma> E}.\n     set_mset (prems_of \\<gamma>) \\<subseteq> {} \\<union> {{#}} \\<and>\n     {#} \\<in># prems_of \\<gamma>} =\n    {}", "using ord_resolve_rename_empty_main_prem"], ["proof (prove)\nusing this:\n  \\<not> ord_resolve_rename ?Cs {#} ?AAs ?As ?\\<sigma> ?E\n\ngoal (1 subgoal):\n 1. {\\<gamma>\n     \\<in> {uu_.\n            \\<exists>CAs DA AAs As \\<sigma> E.\n               uu_ = Infer (mset CAs) DA E \\<and>\n               ord_resolve_rename CAs DA AAs As \\<sigma> E}.\n     set_mset (prems_of \\<gamma>) \\<subseteq> {} \\<union> {{#}} \\<and>\n     {#} \\<in># prems_of \\<gamma>} =\n    {}", "by auto"], ["", "subsection \\<open>Lifting\\<close>"], ["", "text \\<open>\nThe following corresponds to the passage between Lemmas 4.11 and 4.12.\n\\<close>"], ["", "context\n  fixes M :: \"'a clause set\"\n  assumes select: \"selection S\"\nbegin"], ["", "interpretation selection"], ["proof (prove)\ngoal (1 subgoal):\n 1. selection S", "by (rule select)"], ["", "definition S_M :: \"'a literal multiset \\<Rightarrow> 'a literal multiset\" where\n  \"S_M C =\n   (if C \\<in> grounding_of_clss M then\n      (SOME C'. \\<exists>D \\<sigma>. D \\<in> M \\<and> C = D \\<cdot> \\<sigma> \\<and> C' = S D \\<cdot> \\<sigma> \\<and> is_ground_subst \\<sigma>)\n    else\n      S C)\""], ["", "lemma S_M_grounding_of_clss:\n  assumes \"C \\<in> grounding_of_clss M\"\n  obtains D \\<sigma> where\n    \"D \\<in> M \\<and> C = D \\<cdot> \\<sigma> \\<and> S_M C = S D \\<cdot> \\<sigma> \\<and> is_ground_subst \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>D \\<sigma>.\n        D \\<in> M \\<and>\n        C = D \\<cdot> \\<sigma> \\<and>\n        S_M C = S D \\<cdot> \\<sigma> \\<and>\n        is_ground_subst \\<sigma> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof (atomize_elim, unfold S_M_def eqTrueI[OF assms] if_True, rule someI_ex)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x D \\<sigma>.\n       D \\<in> M \\<and>\n       C = D \\<cdot> \\<sigma> \\<and>\n       x = S D \\<cdot> \\<sigma> \\<and> is_ground_subst \\<sigma>", "from assms"], ["proof (chain)\npicking this:\n  C \\<in> grounding_of_clss M", "show \"\\<exists>C' D \\<sigma>. D \\<in> M \\<and> C = D \\<cdot> \\<sigma> \\<and> C' = S D \\<cdot> \\<sigma> \\<and> is_ground_subst \\<sigma>\""], ["proof (prove)\nusing this:\n  C \\<in> grounding_of_clss M\n\ngoal (1 subgoal):\n 1. \\<exists>C' D \\<sigma>.\n       D \\<in> M \\<and>\n       C = D \\<cdot> \\<sigma> \\<and>\n       C' = S D \\<cdot> \\<sigma> \\<and> is_ground_subst \\<sigma>", "by (auto simp: grounding_of_clss_def grounding_of_cls_def)"], ["proof (state)\nthis:\n  \\<exists>C' D \\<sigma>.\n     D \\<in> M \\<and>\n     C = D \\<cdot> \\<sigma> \\<and>\n     C' = S D \\<cdot> \\<sigma> \\<and> is_ground_subst \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma S_M_not_grounding_of_clss: \"C \\<notin> grounding_of_clss M \\<Longrightarrow> S_M C = S C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<notin> grounding_of_clss M \\<Longrightarrow> S_M C = S C", "unfolding S_M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<notin> grounding_of_clss M \\<Longrightarrow>\n    (if C \\<in> grounding_of_clss M\n     then SOME C'.\n             \\<exists>D \\<sigma>.\n                D \\<in> M \\<and>\n                C = D \\<cdot> \\<sigma> \\<and>\n                C' = S D \\<cdot> \\<sigma> \\<and> is_ground_subst \\<sigma>\n     else S C) =\n    S C", "by simp"], ["", "lemma S_M_selects_subseteq: \"S_M C \\<subseteq># C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S_M C \\<subseteq># C", "by (metis S_M_grounding_of_clss S_M_not_grounding_of_clss S_selects_subseteq subst_cls_mono_mset)"], ["", "lemma S_M_selects_neg_lits: \"L \\<in># S_M C \\<Longrightarrow> is_neg L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L \\<in># S_M C \\<Longrightarrow> is_neg L", "by (metis Melem_subst_cls S_M_grounding_of_clss S_M_not_grounding_of_clss S_selects_neg_lits\n      subst_lit_is_neg)"], ["", "end"], ["", "end"], ["", "text \\<open>\nThe following corresponds to Lemma 4.12:\n\\<close>"], ["", "lemma ground_resolvent_subset:\n  assumes\n    gr_cas: \"is_ground_cls_list CAs\" and\n    gr_da: \"is_ground_cls DA\" and\n    res_e: \"ord_resolve S CAs DA AAs As \\<sigma> E\"\n  shows \"E \\<subseteq># \\<Sum>\\<^sub># (mset CAs) + DA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E \\<subseteq># \\<Sum>\\<^sub># (mset CAs) + DA", "using res_e"], ["proof (prove)\nusing this:\n  ord_resolve S CAs DA AAs As \\<sigma> E\n\ngoal (1 subgoal):\n 1. E \\<subseteq># \\<Sum>\\<^sub># (mset CAs) + DA", "proof (cases rule: ord_resolve.cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible S \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> E \\<subseteq># \\<Sum>\\<^sub># (mset CAs) + DA", "case (ord_resolve n Cs D)"], ["proof (state)\nthis:\n  DA = D + negs (mset As)\n  E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  n \\<noteq> 0\n  \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i)\n  \\<forall>i<n. AAs ! i \\<noteq> {#}\n  Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs))\n  eligible S \\<sigma> As (D + negs (mset As))\n  \\<forall>i<n.\n     strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n      (Cs ! i \\<cdot> \\<sigma>)\n  \\<forall>i<n. S (CAs ! i) = {#}\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible S \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> E \\<subseteq># \\<Sum>\\<^sub># (mset CAs) + DA", "note da = this(1) and e = this(2) and cas_len = this(3) and cs_len = this(4)\n    and aas_len = this(5) and as_len = this(6) and cas = this(8) and mgu = this(10)"], ["proof (state)\nthis:\n  DA = D + negs (mset As)\n  E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i)\n  Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs))\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible S \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> E \\<subseteq># \\<Sum>\\<^sub># (mset CAs) + DA", "then"], ["proof (chain)\npicking this:\n  DA = D + negs (mset As)\n  E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i)\n  Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs))", "have cs_sub_cas: \"\\<Sum>\\<^sub># (mset Cs) \\<subseteq># \\<Sum>\\<^sub># (mset CAs)\""], ["proof (prove)\nusing this:\n  DA = D + negs (mset As)\n  E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i)\n  Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs))\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (mset Cs) \\<subseteq># \\<Sum>\\<^sub># (mset CAs)", "using subseteq_list_Union_mset cas_len cs_len"], ["proof (prove)\nusing this:\n  DA = D + negs (mset As)\n  E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i)\n  Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs))\n  \\<lbrakk>length ?Ci = ?n; length ?CAi = ?n;\n   \\<forall>i<?n. ?Ci ! i \\<subseteq># ?CAi ! i\\<rbrakk>\n  \\<Longrightarrow> \\<Sum>\\<^sub># (mset ?Ci) \\<subseteq>#\n                    \\<Sum>\\<^sub># (mset ?CAi)\n  length CAs = n\n  length Cs = n\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (mset Cs) \\<subseteq># \\<Sum>\\<^sub># (mset CAs)", "by force"], ["proof (state)\nthis:\n  \\<Sum>\\<^sub># (mset Cs) \\<subseteq># \\<Sum>\\<^sub># (mset CAs)\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible S \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> E \\<subseteq># \\<Sum>\\<^sub># (mset CAs) + DA", "then"], ["proof (chain)\npicking this:\n  \\<Sum>\\<^sub># (mset Cs) \\<subseteq># \\<Sum>\\<^sub># (mset CAs)", "have cs_sub_cas: \"\\<Sum>\\<^sub># (mset Cs) \\<subseteq># \\<Sum>\\<^sub># (mset CAs)\""], ["proof (prove)\nusing this:\n  \\<Sum>\\<^sub># (mset Cs) \\<subseteq># \\<Sum>\\<^sub># (mset CAs)\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (mset Cs) \\<subseteq># \\<Sum>\\<^sub># (mset CAs)", "using subseteq_list_Union_mset cas_len cs_len"], ["proof (prove)\nusing this:\n  \\<Sum>\\<^sub># (mset Cs) \\<subseteq># \\<Sum>\\<^sub># (mset CAs)\n  \\<lbrakk>length ?Ci = ?n; length ?CAi = ?n;\n   \\<forall>i<?n. ?Ci ! i \\<subseteq># ?CAi ! i\\<rbrakk>\n  \\<Longrightarrow> \\<Sum>\\<^sub># (mset ?Ci) \\<subseteq>#\n                    \\<Sum>\\<^sub># (mset ?CAi)\n  length CAs = n\n  length Cs = n\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (mset Cs) \\<subseteq># \\<Sum>\\<^sub># (mset CAs)", "by force"], ["proof (state)\nthis:\n  \\<Sum>\\<^sub># (mset Cs) \\<subseteq># \\<Sum>\\<^sub># (mset CAs)\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible S \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> E \\<subseteq># \\<Sum>\\<^sub># (mset CAs) + DA", "then"], ["proof (chain)\npicking this:\n  \\<Sum>\\<^sub># (mset Cs) \\<subseteq># \\<Sum>\\<^sub># (mset CAs)", "have gr_cs: \"is_ground_cls_list Cs\""], ["proof (prove)\nusing this:\n  \\<Sum>\\<^sub># (mset Cs) \\<subseteq># \\<Sum>\\<^sub># (mset CAs)\n\ngoal (1 subgoal):\n 1. is_ground_cls_list Cs", "using gr_cas"], ["proof (prove)\nusing this:\n  \\<Sum>\\<^sub># (mset Cs) \\<subseteq># \\<Sum>\\<^sub># (mset CAs)\n  is_ground_cls_list CAs\n\ngoal (1 subgoal):\n 1. is_ground_cls_list Cs", "by simp"], ["proof (state)\nthis:\n  is_ground_cls_list Cs\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible S \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> E \\<subseteq># \\<Sum>\\<^sub># (mset CAs) + DA", "have d_sub_da: \"D \\<subseteq># DA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D \\<subseteq># DA", "by (simp add: da)"], ["proof (state)\nthis:\n  D \\<subseteq># DA\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible S \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> E \\<subseteq># \\<Sum>\\<^sub># (mset CAs) + DA", "then"], ["proof (chain)\npicking this:\n  D \\<subseteq># DA", "have gr_d: \"is_ground_cls D\""], ["proof (prove)\nusing this:\n  D \\<subseteq># DA\n\ngoal (1 subgoal):\n 1. is_ground_cls D", "using gr_da is_ground_cls_mono"], ["proof (prove)\nusing this:\n  D \\<subseteq># DA\n  is_ground_cls DA\n  \\<lbrakk>?C \\<subseteq># ?D; is_ground_cls ?D\\<rbrakk>\n  \\<Longrightarrow> is_ground_cls ?C\n\ngoal (1 subgoal):\n 1. is_ground_cls D", "by auto"], ["proof (state)\nthis:\n  is_ground_cls D\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible S \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> E \\<subseteq># \\<Sum>\\<^sub># (mset CAs) + DA", "have \"is_ground_cls (\\<Sum>\\<^sub># (mset Cs) + D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_cls (\\<Sum>\\<^sub># (mset Cs) + D)", "using gr_cs gr_d"], ["proof (prove)\nusing this:\n  is_ground_cls_list Cs\n  is_ground_cls D\n\ngoal (1 subgoal):\n 1. is_ground_cls (\\<Sum>\\<^sub># (mset Cs) + D)", "by auto"], ["proof (state)\nthis:\n  is_ground_cls (\\<Sum>\\<^sub># (mset Cs) + D)\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible S \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> E \\<subseteq># \\<Sum>\\<^sub># (mset CAs) + DA", "with e"], ["proof (chain)\npicking this:\n  E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>\n  is_ground_cls (\\<Sum>\\<^sub># (mset Cs) + D)", "have \"E = \\<Sum>\\<^sub># (mset Cs) + D\""], ["proof (prove)\nusing this:\n  E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>\n  is_ground_cls (\\<Sum>\\<^sub># (mset Cs) + D)\n\ngoal (1 subgoal):\n 1. E = \\<Sum>\\<^sub># (mset Cs) + D", "by auto"], ["proof (state)\nthis:\n  E = \\<Sum>\\<^sub># (mset Cs) + D\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible S \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> E \\<subseteq># \\<Sum>\\<^sub># (mset CAs) + DA", "then"], ["proof (chain)\npicking this:\n  E = \\<Sum>\\<^sub># (mset Cs) + D", "show ?thesis"], ["proof (prove)\nusing this:\n  E = \\<Sum>\\<^sub># (mset Cs) + D\n\ngoal (1 subgoal):\n 1. E \\<subseteq># \\<Sum>\\<^sub># (mset CAs) + DA", "using cs_sub_cas d_sub_da"], ["proof (prove)\nusing this:\n  E = \\<Sum>\\<^sub># (mset Cs) + D\n  \\<Sum>\\<^sub># (mset Cs) \\<subseteq># \\<Sum>\\<^sub># (mset CAs)\n  D \\<subseteq># DA\n\ngoal (1 subgoal):\n 1. E \\<subseteq># \\<Sum>\\<^sub># (mset CAs) + DA", "by (auto simp: subset_mset.add_mono)"], ["proof (state)\nthis:\n  E \\<subseteq># \\<Sum>\\<^sub># (mset CAs) + DA\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ord_resolve_obtain_clauses:\n  assumes\n    res_e: \"ord_resolve (S_M S M) CAs DA AAs As \\<sigma> E\" and\n    select: \"selection S\" and\n    grounding: \"{DA} \\<union> set CAs \\<subseteq> grounding_of_clss M\" and\n    n: \"length CAs = n\" and\n    d: \"DA = D + negs (mset As)\" and\n    c: \"(\\<forall>i < n. CAs ! i = Cs ! i + poss (AAs ! i))\" \"length Cs = n\" \"length AAs = n\"\n  obtains DA0 \\<eta>0 CAs0 \\<eta>s0 As0 AAs0 D0 Cs0 where\n    \"length CAs0 = n\"\n    \"length \\<eta>s0 = n\"\n    \"DA0 \\<in> M\"\n    \"DA0 \\<cdot> \\<eta>0 = DA\"\n    \"S DA0 \\<cdot> \\<eta>0 = S_M S M DA\"\n    \"\\<forall>CA0 \\<in> set CAs0. CA0 \\<in> M\"\n    \"CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs\"\n    \"map S CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = map (S_M S M) CAs\"\n    \"is_ground_subst \\<eta>0\"\n    \"is_ground_subst_list \\<eta>s0\"\n    \"As0  \\<cdot>al \\<eta>0 = As\"\n    \"AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs\"\n    \"length As0 = n\"\n    \"D0 \\<cdot> \\<eta>0 = D\"\n    \"DA0 = D0 + (negs (mset As0))\"\n    \"S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow> negs (mset As0) = S DA0\"\n    \"length Cs0 = n\"\n    \"Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs\"\n    \"\\<forall>i < n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i)\"\n    \"length AAs0 = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>CAs0 \\<eta>s0 DA0 \\<eta>0 As0 AAs0 D0 Cs0.\n        \\<lbrakk>length CAs0 = n; length \\<eta>s0 = n; DA0 \\<in> M;\n         DA0 \\<cdot> \\<eta>0 = DA; S DA0 \\<cdot> \\<eta>0 = S_M S M DA;\n         \\<forall>CA0\\<in>set CAs0. CA0 \\<in> M;\n         CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs;\n         map S CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = map (S_M S M) CAs;\n         is_ground_subst \\<eta>0; is_ground_subst_list \\<eta>s0;\n         As0 \\<cdot>al \\<eta>0 = As; AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs;\n         length As0 = n; D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n         S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n         negs (mset As0) = S DA0;\n         length Cs0 = n; Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n         \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n         length AAs0 = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using res_e"], ["proof (prove)\nusing this:\n  ord_resolve (S_M S M) CAs DA AAs As \\<sigma> E\n\ngoal (1 subgoal):\n 1. (\\<And>CAs0 \\<eta>s0 DA0 \\<eta>0 As0 AAs0 D0 Cs0.\n        \\<lbrakk>length CAs0 = n; length \\<eta>s0 = n; DA0 \\<in> M;\n         DA0 \\<cdot> \\<eta>0 = DA; S DA0 \\<cdot> \\<eta>0 = S_M S M DA;\n         \\<forall>CA0\\<in>set CAs0. CA0 \\<in> M;\n         CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs;\n         map S CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = map (S_M S M) CAs;\n         is_ground_subst \\<eta>0; is_ground_subst_list \\<eta>s0;\n         As0 \\<cdot>al \\<eta>0 = As; AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs;\n         length As0 = n; D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n         S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n         negs (mset As0) = S DA0;\n         length Cs0 = n; Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n         \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n         length AAs0 = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (cases rule: ord_resolve.cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na Csa Da.\n       \\<lbrakk>\\<And>CAs0 \\<eta>s0 DA0 \\<eta>0 As0 AAs0 D0 Cs0.\n                   \\<lbrakk>length CAs0 = n; length \\<eta>s0 = n;\n                    DA0 \\<in> M; DA0 \\<cdot> \\<eta>0 = DA;\n                    S DA0 \\<cdot> \\<eta>0 = S_M S M DA;\n                    \\<forall>CA0\\<in>set CAs0. CA0 \\<in> M;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs;\n                    map S CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 =\n                    map (S_M S M) CAs;\n                    is_ground_subst \\<eta>0; is_ground_subst_list \\<eta>s0;\n                    As0 \\<cdot>al \\<eta>0 = As;\n                    AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length As0 = n;\n                    D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n                    S_M S M (D + negs (mset As)) \\<noteq>\n                    {#} \\<Longrightarrow>\n                    negs (mset As0) = S DA0;\n                    length Cs0 = n; Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n                    \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n                    length AAs0 = n\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = Da + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Csa) + Da) \\<cdot> \\<sigma>;\n        length CAs = na; length Csa = na; length AAs = na; length As = na;\n        na \\<noteq> 0; \\<forall>i<na. CAs ! i = Csa ! i + poss (AAs ! i);\n        \\<forall>i<na. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (Da + negs (mset As));\n        \\<forall>i<na.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Csa ! i \\<cdot> \\<sigma>);\n        \\<forall>i<na. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (ord_resolve n_twin Cs_twins D_twin)"], ["proof (state)\nthis:\n  DA = D_twin + negs (mset As)\n  E = (\\<Sum>\\<^sub># (mset Cs_twins) + D_twin) \\<cdot> \\<sigma>\n  length CAs = n_twin\n  length Cs_twins = n_twin\n  length AAs = n_twin\n  length As = n_twin\n  n_twin \\<noteq> 0\n  \\<forall>i<n_twin. CAs ! i = Cs_twins ! i + poss (AAs ! i)\n  \\<forall>i<n_twin. AAs ! i \\<noteq> {#}\n  Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs))\n  eligible (S_M S M) \\<sigma> As (D_twin + negs (mset As))\n  \\<forall>i<n_twin.\n     strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n      (Cs_twins ! i \\<cdot> \\<sigma>)\n  \\<forall>i<n_twin. S_M S M (CAs ! i) = {#}\n\ngoal (1 subgoal):\n 1. \\<And>na Csa Da.\n       \\<lbrakk>\\<And>CAs0 \\<eta>s0 DA0 \\<eta>0 As0 AAs0 D0 Cs0.\n                   \\<lbrakk>length CAs0 = n; length \\<eta>s0 = n;\n                    DA0 \\<in> M; DA0 \\<cdot> \\<eta>0 = DA;\n                    S DA0 \\<cdot> \\<eta>0 = S_M S M DA;\n                    \\<forall>CA0\\<in>set CAs0. CA0 \\<in> M;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs;\n                    map S CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 =\n                    map (S_M S M) CAs;\n                    is_ground_subst \\<eta>0; is_ground_subst_list \\<eta>s0;\n                    As0 \\<cdot>al \\<eta>0 = As;\n                    AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length As0 = n;\n                    D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n                    S_M S M (D + negs (mset As)) \\<noteq>\n                    {#} \\<Longrightarrow>\n                    negs (mset As0) = S DA0;\n                    length Cs0 = n; Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n                    \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n                    length AAs0 = n\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = Da + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Csa) + Da) \\<cdot> \\<sigma>;\n        length CAs = na; length Csa = na; length AAs = na; length As = na;\n        na \\<noteq> 0; \\<forall>i<na. CAs ! i = Csa ! i + poss (AAs ! i);\n        \\<forall>i<na. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (Da + negs (mset As));\n        \\<forall>i<na.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Csa ! i \\<cdot> \\<sigma>);\n        \\<forall>i<na. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "note da = this(1) and e = this(2) and cas = this(8) and mgu = this(10) and eligible = this(11)"], ["proof (state)\nthis:\n  DA = D_twin + negs (mset As)\n  E = (\\<Sum>\\<^sub># (mset Cs_twins) + D_twin) \\<cdot> \\<sigma>\n  \\<forall>i<n_twin. CAs ! i = Cs_twins ! i + poss (AAs ! i)\n  Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs))\n  eligible (S_M S M) \\<sigma> As (D_twin + negs (mset As))\n\ngoal (1 subgoal):\n 1. \\<And>na Csa Da.\n       \\<lbrakk>\\<And>CAs0 \\<eta>s0 DA0 \\<eta>0 As0 AAs0 D0 Cs0.\n                   \\<lbrakk>length CAs0 = n; length \\<eta>s0 = n;\n                    DA0 \\<in> M; DA0 \\<cdot> \\<eta>0 = DA;\n                    S DA0 \\<cdot> \\<eta>0 = S_M S M DA;\n                    \\<forall>CA0\\<in>set CAs0. CA0 \\<in> M;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs;\n                    map S CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 =\n                    map (S_M S M) CAs;\n                    is_ground_subst \\<eta>0; is_ground_subst_list \\<eta>s0;\n                    As0 \\<cdot>al \\<eta>0 = As;\n                    AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length As0 = n;\n                    D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n                    S_M S M (D + negs (mset As)) \\<noteq>\n                    {#} \\<Longrightarrow>\n                    negs (mset As0) = S DA0;\n                    length Cs0 = n; Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n                    \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n                    length AAs0 = n\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = Da + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Csa) + Da) \\<cdot> \\<sigma>;\n        length CAs = na; length Csa = na; length AAs = na; length As = na;\n        na \\<noteq> 0; \\<forall>i<na. CAs ! i = Csa ! i + poss (AAs ! i);\n        \\<forall>i<na. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (Da + negs (mset As));\n        \\<forall>i<na.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Csa ! i \\<cdot> \\<sigma>);\n        \\<forall>i<na. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "from ord_resolve"], ["proof (chain)\npicking this:\n  DA = D_twin + negs (mset As)\n  E = (\\<Sum>\\<^sub># (mset Cs_twins) + D_twin) \\<cdot> \\<sigma>\n  length CAs = n_twin\n  length Cs_twins = n_twin\n  length AAs = n_twin\n  length As = n_twin\n  n_twin \\<noteq> 0\n  \\<forall>i<n_twin. CAs ! i = Cs_twins ! i + poss (AAs ! i)\n  \\<forall>i<n_twin. AAs ! i \\<noteq> {#}\n  Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs))\n  eligible (S_M S M) \\<sigma> As (D_twin + negs (mset As))\n  \\<forall>i<n_twin.\n     strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n      (Cs_twins ! i \\<cdot> \\<sigma>)\n  \\<forall>i<n_twin. S_M S M (CAs ! i) = {#}", "have \"n_twin = n\" \"D_twin = D\""], ["proof (prove)\nusing this:\n  DA = D_twin + negs (mset As)\n  E = (\\<Sum>\\<^sub># (mset Cs_twins) + D_twin) \\<cdot> \\<sigma>\n  length CAs = n_twin\n  length Cs_twins = n_twin\n  length AAs = n_twin\n  length As = n_twin\n  n_twin \\<noteq> 0\n  \\<forall>i<n_twin. CAs ! i = Cs_twins ! i + poss (AAs ! i)\n  \\<forall>i<n_twin. AAs ! i \\<noteq> {#}\n  Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs))\n  eligible (S_M S M) \\<sigma> As (D_twin + negs (mset As))\n  \\<forall>i<n_twin.\n     strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n      (Cs_twins ! i \\<cdot> \\<sigma>)\n  \\<forall>i<n_twin. S_M S M (CAs ! i) = {#}\n\ngoal (1 subgoal):\n 1. n_twin = n &&& D_twin = D", "using n d"], ["proof (prove)\nusing this:\n  DA = D_twin + negs (mset As)\n  E = (\\<Sum>\\<^sub># (mset Cs_twins) + D_twin) \\<cdot> \\<sigma>\n  length CAs = n_twin\n  length Cs_twins = n_twin\n  length AAs = n_twin\n  length As = n_twin\n  n_twin \\<noteq> 0\n  \\<forall>i<n_twin. CAs ! i = Cs_twins ! i + poss (AAs ! i)\n  \\<forall>i<n_twin. AAs ! i \\<noteq> {#}\n  Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs))\n  eligible (S_M S M) \\<sigma> As (D_twin + negs (mset As))\n  \\<forall>i<n_twin.\n     strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n      (Cs_twins ! i \\<cdot> \\<sigma>)\n  \\<forall>i<n_twin. S_M S M (CAs ! i) = {#}\n  length CAs = n\n  DA = D + negs (mset As)\n\ngoal (1 subgoal):\n 1. n_twin = n &&& D_twin = D", "by auto"], ["proof (state)\nthis:\n  n_twin = n\n  D_twin = D\n\ngoal (1 subgoal):\n 1. \\<And>na Csa Da.\n       \\<lbrakk>\\<And>CAs0 \\<eta>s0 DA0 \\<eta>0 As0 AAs0 D0 Cs0.\n                   \\<lbrakk>length CAs0 = n; length \\<eta>s0 = n;\n                    DA0 \\<in> M; DA0 \\<cdot> \\<eta>0 = DA;\n                    S DA0 \\<cdot> \\<eta>0 = S_M S M DA;\n                    \\<forall>CA0\\<in>set CAs0. CA0 \\<in> M;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs;\n                    map S CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 =\n                    map (S_M S M) CAs;\n                    is_ground_subst \\<eta>0; is_ground_subst_list \\<eta>s0;\n                    As0 \\<cdot>al \\<eta>0 = As;\n                    AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length As0 = n;\n                    D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n                    S_M S M (D + negs (mset As)) \\<noteq>\n                    {#} \\<Longrightarrow>\n                    negs (mset As0) = S DA0;\n                    length Cs0 = n; Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n                    \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n                    length AAs0 = n\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = Da + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Csa) + Da) \\<cdot> \\<sigma>;\n        length CAs = na; length Csa = na; length AAs = na; length As = na;\n        na \\<noteq> 0; \\<forall>i<na. CAs ! i = Csa ! i + poss (AAs ! i);\n        \\<forall>i<na. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (Da + negs (mset As));\n        \\<forall>i<na.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Csa ! i \\<cdot> \\<sigma>);\n        \\<forall>i<na. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  n_twin = n\n  D_twin = D\n\ngoal (1 subgoal):\n 1. \\<And>na Csa Da.\n       \\<lbrakk>\\<And>CAs0 \\<eta>s0 DA0 \\<eta>0 As0 AAs0 D0 Cs0.\n                   \\<lbrakk>length CAs0 = n; length \\<eta>s0 = n;\n                    DA0 \\<in> M; DA0 \\<cdot> \\<eta>0 = DA;\n                    S DA0 \\<cdot> \\<eta>0 = S_M S M DA;\n                    \\<forall>CA0\\<in>set CAs0. CA0 \\<in> M;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs;\n                    map S CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 =\n                    map (S_M S M) CAs;\n                    is_ground_subst \\<eta>0; is_ground_subst_list \\<eta>s0;\n                    As0 \\<cdot>al \\<eta>0 = As;\n                    AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length As0 = n;\n                    D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n                    S_M S M (D + negs (mset As)) \\<noteq>\n                    {#} \\<Longrightarrow>\n                    negs (mset As0) = S DA0;\n                    length Cs0 = n; Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n                    \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n                    length AAs0 = n\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = Da + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Csa) + Da) \\<cdot> \\<sigma>;\n        length CAs = na; length Csa = na; length AAs = na; length As = na;\n        na \\<noteq> 0; \\<forall>i<na. CAs ! i = Csa ! i + poss (AAs ! i);\n        \\<forall>i<na. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (Da + negs (mset As));\n        \\<forall>i<na.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Csa ! i \\<cdot> \\<sigma>);\n        \\<forall>i<na. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"Cs_twins = Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cs_twins = Cs", "using c cas n calculation(1) \\<open>length Cs_twins = n_twin\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i)\n  length Cs = n\n  length AAs = n\n  \\<forall>i<n_twin. CAs ! i = Cs_twins ! i + poss (AAs ! i)\n  length CAs = n\n  n_twin = n\n  length Cs_twins = n_twin\n\ngoal (1 subgoal):\n 1. Cs_twins = Cs", "by (auto simp add: nth_equalityI)"], ["proof (state)\nthis:\n  Cs_twins = Cs\n\ngoal (1 subgoal):\n 1. \\<And>na Csa Da.\n       \\<lbrakk>\\<And>CAs0 \\<eta>s0 DA0 \\<eta>0 As0 AAs0 D0 Cs0.\n                   \\<lbrakk>length CAs0 = n; length \\<eta>s0 = n;\n                    DA0 \\<in> M; DA0 \\<cdot> \\<eta>0 = DA;\n                    S DA0 \\<cdot> \\<eta>0 = S_M S M DA;\n                    \\<forall>CA0\\<in>set CAs0. CA0 \\<in> M;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs;\n                    map S CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 =\n                    map (S_M S M) CAs;\n                    is_ground_subst \\<eta>0; is_ground_subst_list \\<eta>s0;\n                    As0 \\<cdot>al \\<eta>0 = As;\n                    AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length As0 = n;\n                    D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n                    S_M S M (D + negs (mset As)) \\<noteq>\n                    {#} \\<Longrightarrow>\n                    negs (mset As0) = S DA0;\n                    length Cs0 = n; Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n                    \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n                    length AAs0 = n\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = Da + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Csa) + Da) \\<cdot> \\<sigma>;\n        length CAs = na; length Csa = na; length AAs = na; length As = na;\n        na \\<noteq> 0; \\<forall>i<na. CAs ! i = Csa ! i + poss (AAs ! i);\n        \\<forall>i<na. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (Da + negs (mset As));\n        \\<forall>i<na.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Csa ! i \\<cdot> \\<sigma>);\n        \\<forall>i<na. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  n_twin = n\n  D_twin = D\n  Cs_twins = Cs", "have nz: \"n \\<noteq> 0\" and cs_len: \"length Cs = n\" and aas_len: \"length AAs = n\" and as_len: \"length As = n\"\n    and da: \"DA = D + negs (mset As)\" and eligible: \"eligible (S_M S M) \\<sigma> As (D + negs (mset As))\"\n    and cas: \"\\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i)\""], ["proof (prove)\nusing this:\n  n_twin = n\n  D_twin = D\n  Cs_twins = Cs\n\ngoal (1 subgoal):\n 1. (n \\<noteq> 0 &&& length Cs = n &&& length AAs = n) &&&\n    (length As = n &&& DA = D + negs (mset As)) &&&\n    eligible (S_M S M) \\<sigma> As (D + negs (mset As)) &&&\n    \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i)", "using ord_resolve"], ["proof (prove)\nusing this:\n  n_twin = n\n  D_twin = D\n  Cs_twins = Cs\n  DA = D_twin + negs (mset As)\n  E = (\\<Sum>\\<^sub># (mset Cs_twins) + D_twin) \\<cdot> \\<sigma>\n  length CAs = n_twin\n  length Cs_twins = n_twin\n  length AAs = n_twin\n  length As = n_twin\n  n_twin \\<noteq> 0\n  \\<forall>i<n_twin. CAs ! i = Cs_twins ! i + poss (AAs ! i)\n  \\<forall>i<n_twin. AAs ! i \\<noteq> {#}\n  Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs))\n  eligible (S_M S M) \\<sigma> As (D_twin + negs (mset As))\n  \\<forall>i<n_twin.\n     strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n      (Cs_twins ! i \\<cdot> \\<sigma>)\n  \\<forall>i<n_twin. S_M S M (CAs ! i) = {#}\n\ngoal (1 subgoal):\n 1. (n \\<noteq> 0 &&& length Cs = n &&& length AAs = n) &&&\n    (length As = n &&& DA = D + negs (mset As)) &&&\n    eligible (S_M S M) \\<sigma> As (D + negs (mset As)) &&&\n    \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i)", "by force+"], ["proof (state)\nthis:\n  n \\<noteq> 0\n  length Cs = n\n  length AAs = n\n  length As = n\n  DA = D + negs (mset As)\n  eligible (S_M S M) \\<sigma> As (D + negs (mset As))\n  \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i)\n\ngoal (1 subgoal):\n 1. \\<And>na Csa Da.\n       \\<lbrakk>\\<And>CAs0 \\<eta>s0 DA0 \\<eta>0 As0 AAs0 D0 Cs0.\n                   \\<lbrakk>length CAs0 = n; length \\<eta>s0 = n;\n                    DA0 \\<in> M; DA0 \\<cdot> \\<eta>0 = DA;\n                    S DA0 \\<cdot> \\<eta>0 = S_M S M DA;\n                    \\<forall>CA0\\<in>set CAs0. CA0 \\<in> M;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs;\n                    map S CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 =\n                    map (S_M S M) CAs;\n                    is_ground_subst \\<eta>0; is_ground_subst_list \\<eta>s0;\n                    As0 \\<cdot>al \\<eta>0 = As;\n                    AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length As0 = n;\n                    D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n                    S_M S M (D + negs (mset As)) \\<noteq>\n                    {#} \\<Longrightarrow>\n                    negs (mset As0) = S DA0;\n                    length Cs0 = n; Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n                    \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n                    length AAs0 = n\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = Da + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Csa) + Da) \\<cdot> \\<sigma>;\n        length CAs = na; length Csa = na; length AAs = na; length As = na;\n        na \\<noteq> 0; \\<forall>i<na. CAs ! i = Csa ! i + poss (AAs ! i);\n        \\<forall>i<na. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (Da + negs (mset As));\n        \\<forall>i<na.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Csa ! i \\<cdot> \\<sigma>);\n        \\<forall>i<na. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "note n = \\<open>n \\<noteq> 0\\<close> \\<open>length CAs = n\\<close> \\<open>length Cs = n\\<close> \\<open>length AAs = n\\<close> \\<open>length As = n\\<close>"], ["proof (state)\nthis:\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n\ngoal (1 subgoal):\n 1. \\<And>na Csa Da.\n       \\<lbrakk>\\<And>CAs0 \\<eta>s0 DA0 \\<eta>0 As0 AAs0 D0 Cs0.\n                   \\<lbrakk>length CAs0 = n; length \\<eta>s0 = n;\n                    DA0 \\<in> M; DA0 \\<cdot> \\<eta>0 = DA;\n                    S DA0 \\<cdot> \\<eta>0 = S_M S M DA;\n                    \\<forall>CA0\\<in>set CAs0. CA0 \\<in> M;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs;\n                    map S CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 =\n                    map (S_M S M) CAs;\n                    is_ground_subst \\<eta>0; is_ground_subst_list \\<eta>s0;\n                    As0 \\<cdot>al \\<eta>0 = As;\n                    AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length As0 = n;\n                    D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n                    S_M S M (D + negs (mset As)) \\<noteq>\n                    {#} \\<Longrightarrow>\n                    negs (mset As0) = S DA0;\n                    length Cs0 = n; Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n                    \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n                    length AAs0 = n\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = Da + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Csa) + Da) \\<cdot> \\<sigma>;\n        length CAs = na; length Csa = na; length AAs = na; length As = na;\n        na \\<noteq> 0; \\<forall>i<na. CAs ! i = Csa ! i + poss (AAs ! i);\n        \\<forall>i<na. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (Da + negs (mset As));\n        \\<forall>i<na.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Csa ! i \\<cdot> \\<sigma>);\n        \\<forall>i<na. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "interpret S: selection S"], ["proof (prove)\ngoal (1 subgoal):\n 1. selection S", "by (rule select)\n\n  \\<comment> \\<open>Obtain FO side premises\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na Csa Da.\n       \\<lbrakk>\\<And>CAs0 \\<eta>s0 DA0 \\<eta>0 As0 AAs0 D0 Cs0.\n                   \\<lbrakk>length CAs0 = n; length \\<eta>s0 = n;\n                    DA0 \\<in> M; DA0 \\<cdot> \\<eta>0 = DA;\n                    S DA0 \\<cdot> \\<eta>0 = S_M S M DA;\n                    \\<forall>CA0\\<in>set CAs0. CA0 \\<in> M;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs;\n                    map S CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 =\n                    map (S_M S M) CAs;\n                    is_ground_subst \\<eta>0; is_ground_subst_list \\<eta>s0;\n                    As0 \\<cdot>al \\<eta>0 = As;\n                    AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length As0 = n;\n                    D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n                    S_M S M (D + negs (mset As)) \\<noteq>\n                    {#} \\<Longrightarrow>\n                    negs (mset As0) = S DA0;\n                    length Cs0 = n; Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n                    \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n                    length AAs0 = n\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = Da + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Csa) + Da) \\<cdot> \\<sigma>;\n        length CAs = na; length Csa = na; length AAs = na; length As = na;\n        na \\<noteq> 0; \\<forall>i<na. CAs ! i = Csa ! i + poss (AAs ! i);\n        \\<forall>i<na. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (Da + negs (mset As));\n        \\<forall>i<na.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Csa ! i \\<cdot> \\<sigma>);\n        \\<forall>i<na. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"\\<forall>CA \\<in> set CAs. \\<exists>CA0 \\<eta>c0. CA0 \\<in> M \\<and> CA0 \\<cdot> \\<eta>c0 = CA \\<and> S CA0 \\<cdot> \\<eta>c0 = S_M S M CA \\<and> is_ground_subst \\<eta>c0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>CA\\<in>set CAs.\n       \\<exists>CA0 \\<eta>c0.\n          CA0 \\<in> M \\<and>\n          CA0 \\<cdot> \\<eta>c0 = CA \\<and>\n          S CA0 \\<cdot> \\<eta>c0 = S_M S M CA \\<and>\n          is_ground_subst \\<eta>c0", "using grounding S_M_grounding_of_clss select"], ["proof (prove)\nusing this:\n  {DA} \\<union> set CAs \\<subseteq> grounding_of_clss M\n  \\<lbrakk>selection ?S; ?C \\<in> grounding_of_clss ?M;\n   \\<And>D \\<sigma>.\n      D \\<in> ?M \\<and>\n      ?C = D \\<cdot> \\<sigma> \\<and>\n      S_M ?S ?M ?C = ?S D \\<cdot> \\<sigma> \\<and>\n      is_ground_subst \\<sigma> \\<Longrightarrow>\n      ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  selection S\n\ngoal (1 subgoal):\n 1. \\<forall>CA\\<in>set CAs.\n       \\<exists>CA0 \\<eta>c0.\n          CA0 \\<in> M \\<and>\n          CA0 \\<cdot> \\<eta>c0 = CA \\<and>\n          S CA0 \\<cdot> \\<eta>c0 = S_M S M CA \\<and>\n          is_ground_subst \\<eta>c0", "by (metis (no_types) le_supE subset_iff)"], ["proof (state)\nthis:\n  \\<forall>CA\\<in>set CAs.\n     \\<exists>CA0 \\<eta>c0.\n        CA0 \\<in> M \\<and>\n        CA0 \\<cdot> \\<eta>c0 = CA \\<and>\n        S CA0 \\<cdot> \\<eta>c0 = S_M S M CA \\<and> is_ground_subst \\<eta>c0\n\ngoal (1 subgoal):\n 1. \\<And>na Csa Da.\n       \\<lbrakk>\\<And>CAs0 \\<eta>s0 DA0 \\<eta>0 As0 AAs0 D0 Cs0.\n                   \\<lbrakk>length CAs0 = n; length \\<eta>s0 = n;\n                    DA0 \\<in> M; DA0 \\<cdot> \\<eta>0 = DA;\n                    S DA0 \\<cdot> \\<eta>0 = S_M S M DA;\n                    \\<forall>CA0\\<in>set CAs0. CA0 \\<in> M;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs;\n                    map S CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 =\n                    map (S_M S M) CAs;\n                    is_ground_subst \\<eta>0; is_ground_subst_list \\<eta>s0;\n                    As0 \\<cdot>al \\<eta>0 = As;\n                    AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length As0 = n;\n                    D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n                    S_M S M (D + negs (mset As)) \\<noteq>\n                    {#} \\<Longrightarrow>\n                    negs (mset As0) = S DA0;\n                    length Cs0 = n; Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n                    \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n                    length AAs0 = n\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = Da + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Csa) + Da) \\<cdot> \\<sigma>;\n        length CAs = na; length Csa = na; length AAs = na; length As = na;\n        na \\<noteq> 0; \\<forall>i<na. CAs ! i = Csa ! i + poss (AAs ! i);\n        \\<forall>i<na. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (Da + negs (mset As));\n        \\<forall>i<na.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Csa ! i \\<cdot> \\<sigma>);\n        \\<forall>i<na. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<forall>CA\\<in>set CAs.\n     \\<exists>CA0 \\<eta>c0.\n        CA0 \\<in> M \\<and>\n        CA0 \\<cdot> \\<eta>c0 = CA \\<and>\n        S CA0 \\<cdot> \\<eta>c0 = S_M S M CA \\<and> is_ground_subst \\<eta>c0", "have \"\\<forall>i < n. \\<exists>CA0 \\<eta>c0. CA0 \\<in> M \\<and> CA0 \\<cdot> \\<eta>c0 = (CAs ! i) \\<and> S CA0 \\<cdot> \\<eta>c0 = S_M S M (CAs ! i) \\<and> is_ground_subst \\<eta>c0\""], ["proof (prove)\nusing this:\n  \\<forall>CA\\<in>set CAs.\n     \\<exists>CA0 \\<eta>c0.\n        CA0 \\<in> M \\<and>\n        CA0 \\<cdot> \\<eta>c0 = CA \\<and>\n        S CA0 \\<cdot> \\<eta>c0 = S_M S M CA \\<and> is_ground_subst \\<eta>c0\n\ngoal (1 subgoal):\n 1. \\<forall>i<n.\n       \\<exists>CA0 \\<eta>c0.\n          CA0 \\<in> M \\<and>\n          CA0 \\<cdot> \\<eta>c0 = CAs ! i \\<and>\n          S CA0 \\<cdot> \\<eta>c0 = S_M S M (CAs ! i) \\<and>\n          is_ground_subst \\<eta>c0", "using n"], ["proof (prove)\nusing this:\n  \\<forall>CA\\<in>set CAs.\n     \\<exists>CA0 \\<eta>c0.\n        CA0 \\<in> M \\<and>\n        CA0 \\<cdot> \\<eta>c0 = CA \\<and>\n        S CA0 \\<cdot> \\<eta>c0 = S_M S M CA \\<and> is_ground_subst \\<eta>c0\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n\ngoal (1 subgoal):\n 1. \\<forall>i<n.\n       \\<exists>CA0 \\<eta>c0.\n          CA0 \\<in> M \\<and>\n          CA0 \\<cdot> \\<eta>c0 = CAs ! i \\<and>\n          S CA0 \\<cdot> \\<eta>c0 = S_M S M (CAs ! i) \\<and>\n          is_ground_subst \\<eta>c0", "by force"], ["proof (state)\nthis:\n  \\<forall>i<n.\n     \\<exists>CA0 \\<eta>c0.\n        CA0 \\<in> M \\<and>\n        CA0 \\<cdot> \\<eta>c0 = CAs ! i \\<and>\n        S CA0 \\<cdot> \\<eta>c0 = S_M S M (CAs ! i) \\<and>\n        is_ground_subst \\<eta>c0\n\ngoal (1 subgoal):\n 1. \\<And>na Csa Da.\n       \\<lbrakk>\\<And>CAs0 \\<eta>s0 DA0 \\<eta>0 As0 AAs0 D0 Cs0.\n                   \\<lbrakk>length CAs0 = n; length \\<eta>s0 = n;\n                    DA0 \\<in> M; DA0 \\<cdot> \\<eta>0 = DA;\n                    S DA0 \\<cdot> \\<eta>0 = S_M S M DA;\n                    \\<forall>CA0\\<in>set CAs0. CA0 \\<in> M;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs;\n                    map S CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 =\n                    map (S_M S M) CAs;\n                    is_ground_subst \\<eta>0; is_ground_subst_list \\<eta>s0;\n                    As0 \\<cdot>al \\<eta>0 = As;\n                    AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length As0 = n;\n                    D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n                    S_M S M (D + negs (mset As)) \\<noteq>\n                    {#} \\<Longrightarrow>\n                    negs (mset As0) = S DA0;\n                    length Cs0 = n; Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n                    \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n                    length AAs0 = n\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = Da + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Csa) + Da) \\<cdot> \\<sigma>;\n        length CAs = na; length Csa = na; length AAs = na; length As = na;\n        na \\<noteq> 0; \\<forall>i<na. CAs ! i = Csa ! i + poss (AAs ! i);\n        \\<forall>i<na. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (Da + negs (mset As));\n        \\<forall>i<na.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Csa ! i \\<cdot> \\<sigma>);\n        \\<forall>i<na. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<n.\n     \\<exists>CA0 \\<eta>c0.\n        CA0 \\<in> M \\<and>\n        CA0 \\<cdot> \\<eta>c0 = CAs ! i \\<and>\n        S CA0 \\<cdot> \\<eta>c0 = S_M S M (CAs ! i) \\<and>\n        is_ground_subst \\<eta>c0", "obtain \\<eta>s0f CAs0f where f_p:\n    \"\\<forall>i < n. CAs0f i \\<in> M\"\n    \"\\<forall>i < n. (CAs0f i) \\<cdot> (\\<eta>s0f i) = (CAs ! i)\"\n    \"\\<forall>i < n. S (CAs0f i)  \\<cdot> (\\<eta>s0f i) = S_M S M (CAs ! i)\"\n    \"\\<forall>i < n. is_ground_subst (\\<eta>s0f i)\""], ["proof (prove)\nusing this:\n  \\<forall>i<n.\n     \\<exists>CA0 \\<eta>c0.\n        CA0 \\<in> M \\<and>\n        CA0 \\<cdot> \\<eta>c0 = CAs ! i \\<and>\n        S CA0 \\<cdot> \\<eta>c0 = S_M S M (CAs ! i) \\<and>\n        is_ground_subst \\<eta>c0\n\ngoal (1 subgoal):\n 1. (\\<And>CAs0f \\<eta>s0f.\n        \\<lbrakk>\\<forall>i<n. CAs0f i \\<in> M;\n         \\<forall>i<n. CAs0f i \\<cdot> \\<eta>s0f i = CAs ! i;\n         \\<forall>i<n. S (CAs0f i) \\<cdot> \\<eta>s0f i = S_M S M (CAs ! i);\n         \\<forall>i<n. is_ground_subst (\\<eta>s0f i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using n"], ["proof (prove)\nusing this:\n  \\<forall>i<n.\n     \\<exists>CA0 \\<eta>c0.\n        CA0 \\<in> M \\<and>\n        CA0 \\<cdot> \\<eta>c0 = CAs ! i \\<and>\n        S CA0 \\<cdot> \\<eta>c0 = S_M S M (CAs ! i) \\<and>\n        is_ground_subst \\<eta>c0\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n\ngoal (1 subgoal):\n 1. (\\<And>CAs0f \\<eta>s0f.\n        \\<lbrakk>\\<forall>i<n. CAs0f i \\<in> M;\n         \\<forall>i<n. CAs0f i \\<cdot> \\<eta>s0f i = CAs ! i;\n         \\<forall>i<n. S (CAs0f i) \\<cdot> \\<eta>s0f i = S_M S M (CAs ! i);\n         \\<forall>i<n. is_ground_subst (\\<eta>s0f i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (no_types))"], ["proof (state)\nthis:\n  \\<forall>i<n. CAs0f i \\<in> M\n  \\<forall>i<n. CAs0f i \\<cdot> \\<eta>s0f i = CAs ! i\n  \\<forall>i<n. S (CAs0f i) \\<cdot> \\<eta>s0f i = S_M S M (CAs ! i)\n  \\<forall>i<n. is_ground_subst (\\<eta>s0f i)\n\ngoal (1 subgoal):\n 1. \\<And>na Csa Da.\n       \\<lbrakk>\\<And>CAs0 \\<eta>s0 DA0 \\<eta>0 As0 AAs0 D0 Cs0.\n                   \\<lbrakk>length CAs0 = n; length \\<eta>s0 = n;\n                    DA0 \\<in> M; DA0 \\<cdot> \\<eta>0 = DA;\n                    S DA0 \\<cdot> \\<eta>0 = S_M S M DA;\n                    \\<forall>CA0\\<in>set CAs0. CA0 \\<in> M;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs;\n                    map S CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 =\n                    map (S_M S M) CAs;\n                    is_ground_subst \\<eta>0; is_ground_subst_list \\<eta>s0;\n                    As0 \\<cdot>al \\<eta>0 = As;\n                    AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length As0 = n;\n                    D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n                    S_M S M (D + negs (mset As)) \\<noteq>\n                    {#} \\<Longrightarrow>\n                    negs (mset As0) = S DA0;\n                    length Cs0 = n; Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n                    \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n                    length AAs0 = n\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = Da + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Csa) + Da) \\<cdot> \\<sigma>;\n        length CAs = na; length Csa = na; length AAs = na; length As = na;\n        na \\<noteq> 0; \\<forall>i<na. CAs ! i = Csa ! i + poss (AAs ! i);\n        \\<forall>i<na. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (Da + negs (mset As));\n        \\<forall>i<na.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Csa ! i \\<cdot> \\<sigma>);\n        \\<forall>i<na. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "define \\<eta>s0 where\n    \"\\<eta>s0 = map \\<eta>s0f [0 ..<n]\""], ["proof (state)\nthis:\n  \\<eta>s0 = map \\<eta>s0f [0..<n]\n\ngoal (1 subgoal):\n 1. \\<And>na Csa Da.\n       \\<lbrakk>\\<And>CAs0 \\<eta>s0 DA0 \\<eta>0 As0 AAs0 D0 Cs0.\n                   \\<lbrakk>length CAs0 = n; length \\<eta>s0 = n;\n                    DA0 \\<in> M; DA0 \\<cdot> \\<eta>0 = DA;\n                    S DA0 \\<cdot> \\<eta>0 = S_M S M DA;\n                    \\<forall>CA0\\<in>set CAs0. CA0 \\<in> M;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs;\n                    map S CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 =\n                    map (S_M S M) CAs;\n                    is_ground_subst \\<eta>0; is_ground_subst_list \\<eta>s0;\n                    As0 \\<cdot>al \\<eta>0 = As;\n                    AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length As0 = n;\n                    D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n                    S_M S M (D + negs (mset As)) \\<noteq>\n                    {#} \\<Longrightarrow>\n                    negs (mset As0) = S DA0;\n                    length Cs0 = n; Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n                    \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n                    length AAs0 = n\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = Da + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Csa) + Da) \\<cdot> \\<sigma>;\n        length CAs = na; length Csa = na; length AAs = na; length As = na;\n        na \\<noteq> 0; \\<forall>i<na. CAs ! i = Csa ! i + poss (AAs ! i);\n        \\<forall>i<na. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (Da + negs (mset As));\n        \\<forall>i<na.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Csa ! i \\<cdot> \\<sigma>);\n        \\<forall>i<na. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "define CAs0 where\n    \"CAs0 = map CAs0f [0 ..<n]\""], ["proof (state)\nthis:\n  CAs0 = map CAs0f [0..<n]\n\ngoal (1 subgoal):\n 1. \\<And>na Csa Da.\n       \\<lbrakk>\\<And>CAs0 \\<eta>s0 DA0 \\<eta>0 As0 AAs0 D0 Cs0.\n                   \\<lbrakk>length CAs0 = n; length \\<eta>s0 = n;\n                    DA0 \\<in> M; DA0 \\<cdot> \\<eta>0 = DA;\n                    S DA0 \\<cdot> \\<eta>0 = S_M S M DA;\n                    \\<forall>CA0\\<in>set CAs0. CA0 \\<in> M;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs;\n                    map S CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 =\n                    map (S_M S M) CAs;\n                    is_ground_subst \\<eta>0; is_ground_subst_list \\<eta>s0;\n                    As0 \\<cdot>al \\<eta>0 = As;\n                    AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length As0 = n;\n                    D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n                    S_M S M (D + negs (mset As)) \\<noteq>\n                    {#} \\<Longrightarrow>\n                    negs (mset As0) = S DA0;\n                    length Cs0 = n; Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n                    \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n                    length AAs0 = n\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = Da + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Csa) + Da) \\<cdot> \\<sigma>;\n        length CAs = na; length Csa = na; length AAs = na; length As = na;\n        na \\<noteq> 0; \\<forall>i<na. CAs ! i = Csa ! i + poss (AAs ! i);\n        \\<forall>i<na. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (Da + negs (mset As));\n        \\<forall>i<na.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Csa ! i \\<cdot> \\<sigma>);\n        \\<forall>i<na. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"length \\<eta>s0 = n\" \"length CAs0 = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length \\<eta>s0 = n &&& length CAs0 = n", "unfolding \\<eta>s0_def CAs0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map \\<eta>s0f [0..<n]) = n &&& length (map CAs0f [0..<n]) = n", "by auto"], ["proof (state)\nthis:\n  length \\<eta>s0 = n\n  length CAs0 = n\n\ngoal (1 subgoal):\n 1. \\<And>na Csa Da.\n       \\<lbrakk>\\<And>CAs0 \\<eta>s0 DA0 \\<eta>0 As0 AAs0 D0 Cs0.\n                   \\<lbrakk>length CAs0 = n; length \\<eta>s0 = n;\n                    DA0 \\<in> M; DA0 \\<cdot> \\<eta>0 = DA;\n                    S DA0 \\<cdot> \\<eta>0 = S_M S M DA;\n                    \\<forall>CA0\\<in>set CAs0. CA0 \\<in> M;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs;\n                    map S CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 =\n                    map (S_M S M) CAs;\n                    is_ground_subst \\<eta>0; is_ground_subst_list \\<eta>s0;\n                    As0 \\<cdot>al \\<eta>0 = As;\n                    AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length As0 = n;\n                    D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n                    S_M S M (D + negs (mset As)) \\<noteq>\n                    {#} \\<Longrightarrow>\n                    negs (mset As0) = S DA0;\n                    length Cs0 = n; Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n                    \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n                    length AAs0 = n\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = Da + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Csa) + Da) \\<cdot> \\<sigma>;\n        length CAs = na; length Csa = na; length AAs = na; length As = na;\n        na \\<noteq> 0; \\<forall>i<na. CAs ! i = Csa ! i + poss (AAs ! i);\n        \\<forall>i<na. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (Da + negs (mset As));\n        \\<forall>i<na.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Csa ! i \\<cdot> \\<sigma>);\n        \\<forall>i<na. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "note n = \\<open>length \\<eta>s0 = n\\<close> \\<open>length CAs0 = n\\<close> n\n\n  \\<comment> \\<open>The properties we need of the FO side premises\\<close>"], ["proof (state)\nthis:\n  length \\<eta>s0 = n\n  length CAs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n\ngoal (1 subgoal):\n 1. \\<And>na Csa Da.\n       \\<lbrakk>\\<And>CAs0 \\<eta>s0 DA0 \\<eta>0 As0 AAs0 D0 Cs0.\n                   \\<lbrakk>length CAs0 = n; length \\<eta>s0 = n;\n                    DA0 \\<in> M; DA0 \\<cdot> \\<eta>0 = DA;\n                    S DA0 \\<cdot> \\<eta>0 = S_M S M DA;\n                    \\<forall>CA0\\<in>set CAs0. CA0 \\<in> M;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs;\n                    map S CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 =\n                    map (S_M S M) CAs;\n                    is_ground_subst \\<eta>0; is_ground_subst_list \\<eta>s0;\n                    As0 \\<cdot>al \\<eta>0 = As;\n                    AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length As0 = n;\n                    D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n                    S_M S M (D + negs (mset As)) \\<noteq>\n                    {#} \\<Longrightarrow>\n                    negs (mset As0) = S DA0;\n                    length Cs0 = n; Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n                    \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n                    length AAs0 = n\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = Da + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Csa) + Da) \\<cdot> \\<sigma>;\n        length CAs = na; length Csa = na; length AAs = na; length As = na;\n        na \\<noteq> 0; \\<forall>i<na. CAs ! i = Csa ! i + poss (AAs ! i);\n        \\<forall>i<na. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (Da + negs (mset As));\n        \\<forall>i<na.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Csa ! i \\<cdot> \\<sigma>);\n        \\<forall>i<na. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have CAs0_in_M: \"\\<forall>CA0 \\<in> set CAs0. CA0 \\<in> M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>CA0\\<in>set CAs0. CA0 \\<in> M", "unfolding CAs0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>CA0\\<in>set (map CAs0f [0..<n]). CA0 \\<in> M", "using f_p(1)"], ["proof (prove)\nusing this:\n  \\<forall>i<n. CAs0f i \\<in> M\n\ngoal (1 subgoal):\n 1. \\<forall>CA0\\<in>set (map CAs0f [0..<n]). CA0 \\<in> M", "by auto"], ["proof (state)\nthis:\n  \\<forall>CA0\\<in>set CAs0. CA0 \\<in> M\n\ngoal (1 subgoal):\n 1. \\<And>na Csa Da.\n       \\<lbrakk>\\<And>CAs0 \\<eta>s0 DA0 \\<eta>0 As0 AAs0 D0 Cs0.\n                   \\<lbrakk>length CAs0 = n; length \\<eta>s0 = n;\n                    DA0 \\<in> M; DA0 \\<cdot> \\<eta>0 = DA;\n                    S DA0 \\<cdot> \\<eta>0 = S_M S M DA;\n                    \\<forall>CA0\\<in>set CAs0. CA0 \\<in> M;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs;\n                    map S CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 =\n                    map (S_M S M) CAs;\n                    is_ground_subst \\<eta>0; is_ground_subst_list \\<eta>s0;\n                    As0 \\<cdot>al \\<eta>0 = As;\n                    AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length As0 = n;\n                    D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n                    S_M S M (D + negs (mset As)) \\<noteq>\n                    {#} \\<Longrightarrow>\n                    negs (mset As0) = S DA0;\n                    length Cs0 = n; Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n                    \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n                    length AAs0 = n\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = Da + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Csa) + Da) \\<cdot> \\<sigma>;\n        length CAs = na; length Csa = na; length AAs = na; length As = na;\n        na \\<noteq> 0; \\<forall>i<na. CAs ! i = Csa ! i + poss (AAs ! i);\n        \\<forall>i<na. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (Da + negs (mset As));\n        \\<forall>i<na.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Csa ! i \\<cdot> \\<sigma>);\n        \\<forall>i<na. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have CAs0_to_CAs: \"CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs", "unfolding CAs0_def \\<eta>s0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map CAs0f [0..<n] \\<cdot>\\<cdot>cl map \\<eta>s0f [0..<n] = CAs", "using f_p(2)"], ["proof (prove)\nusing this:\n  \\<forall>i<n. CAs0f i \\<cdot> \\<eta>s0f i = CAs ! i\n\ngoal (1 subgoal):\n 1. map CAs0f [0..<n] \\<cdot>\\<cdot>cl map \\<eta>s0f [0..<n] = CAs", "by (auto simp: n intro: nth_equalityI)"], ["proof (state)\nthis:\n  CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs\n\ngoal (1 subgoal):\n 1. \\<And>na Csa Da.\n       \\<lbrakk>\\<And>CAs0 \\<eta>s0 DA0 \\<eta>0 As0 AAs0 D0 Cs0.\n                   \\<lbrakk>length CAs0 = n; length \\<eta>s0 = n;\n                    DA0 \\<in> M; DA0 \\<cdot> \\<eta>0 = DA;\n                    S DA0 \\<cdot> \\<eta>0 = S_M S M DA;\n                    \\<forall>CA0\\<in>set CAs0. CA0 \\<in> M;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs;\n                    map S CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 =\n                    map (S_M S M) CAs;\n                    is_ground_subst \\<eta>0; is_ground_subst_list \\<eta>s0;\n                    As0 \\<cdot>al \\<eta>0 = As;\n                    AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length As0 = n;\n                    D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n                    S_M S M (D + negs (mset As)) \\<noteq>\n                    {#} \\<Longrightarrow>\n                    negs (mset As0) = S DA0;\n                    length Cs0 = n; Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n                    \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n                    length AAs0 = n\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = Da + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Csa) + Da) \\<cdot> \\<sigma>;\n        length CAs = na; length Csa = na; length AAs = na; length As = na;\n        na \\<noteq> 0; \\<forall>i<na. CAs ! i = Csa ! i + poss (AAs ! i);\n        \\<forall>i<na. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (Da + negs (mset As));\n        \\<forall>i<na.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Csa ! i \\<cdot> \\<sigma>);\n        \\<forall>i<na. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have SCAs0_to_SMCAs: \"(map S CAs0) \\<cdot>\\<cdot>cl \\<eta>s0 = map (S_M S M) CAs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map S CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = map (S_M S M) CAs", "unfolding CAs0_def \\<eta>s0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map S (map CAs0f [0..<n]) \\<cdot>\\<cdot>cl map \\<eta>s0f [0..<n] =\n    map (S_M S M) CAs", "using f_p(3) n"], ["proof (prove)\nusing this:\n  \\<forall>i<n. S (CAs0f i) \\<cdot> \\<eta>s0f i = S_M S M (CAs ! i)\n  length \\<eta>s0 = n\n  length CAs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n\ngoal (1 subgoal):\n 1. map S (map CAs0f [0..<n]) \\<cdot>\\<cdot>cl map \\<eta>s0f [0..<n] =\n    map (S_M S M) CAs", "by (force intro: nth_equalityI)"], ["proof (state)\nthis:\n  map S CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = map (S_M S M) CAs\n\ngoal (1 subgoal):\n 1. \\<And>na Csa Da.\n       \\<lbrakk>\\<And>CAs0 \\<eta>s0 DA0 \\<eta>0 As0 AAs0 D0 Cs0.\n                   \\<lbrakk>length CAs0 = n; length \\<eta>s0 = n;\n                    DA0 \\<in> M; DA0 \\<cdot> \\<eta>0 = DA;\n                    S DA0 \\<cdot> \\<eta>0 = S_M S M DA;\n                    \\<forall>CA0\\<in>set CAs0. CA0 \\<in> M;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs;\n                    map S CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 =\n                    map (S_M S M) CAs;\n                    is_ground_subst \\<eta>0; is_ground_subst_list \\<eta>s0;\n                    As0 \\<cdot>al \\<eta>0 = As;\n                    AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length As0 = n;\n                    D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n                    S_M S M (D + negs (mset As)) \\<noteq>\n                    {#} \\<Longrightarrow>\n                    negs (mset As0) = S DA0;\n                    length Cs0 = n; Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n                    \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n                    length AAs0 = n\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = Da + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Csa) + Da) \\<cdot> \\<sigma>;\n        length CAs = na; length Csa = na; length AAs = na; length As = na;\n        na \\<noteq> 0; \\<forall>i<na. CAs ! i = Csa ! i + poss (AAs ! i);\n        \\<forall>i<na. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (Da + negs (mset As));\n        \\<forall>i<na.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Csa ! i \\<cdot> \\<sigma>);\n        \\<forall>i<na. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have sub_ground: \"\\<forall>\\<eta>c0 \\<in> set \\<eta>s0. is_ground_subst \\<eta>c0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (set \\<eta>s0) is_ground_subst", "unfolding \\<eta>s0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (set (map \\<eta>s0f [0..<n])) is_ground_subst", "using f_p n"], ["proof (prove)\nusing this:\n  \\<forall>i<n. CAs0f i \\<in> M\n  \\<forall>i<n. CAs0f i \\<cdot> \\<eta>s0f i = CAs ! i\n  \\<forall>i<n. S (CAs0f i) \\<cdot> \\<eta>s0f i = S_M S M (CAs ! i)\n  \\<forall>i<n. is_ground_subst (\\<eta>s0f i)\n  length \\<eta>s0 = n\n  length CAs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n\ngoal (1 subgoal):\n 1. Ball (set (map \\<eta>s0f [0..<n])) is_ground_subst", "by force"], ["proof (state)\nthis:\n  Ball (set \\<eta>s0) is_ground_subst\n\ngoal (1 subgoal):\n 1. \\<And>na Csa Da.\n       \\<lbrakk>\\<And>CAs0 \\<eta>s0 DA0 \\<eta>0 As0 AAs0 D0 Cs0.\n                   \\<lbrakk>length CAs0 = n; length \\<eta>s0 = n;\n                    DA0 \\<in> M; DA0 \\<cdot> \\<eta>0 = DA;\n                    S DA0 \\<cdot> \\<eta>0 = S_M S M DA;\n                    \\<forall>CA0\\<in>set CAs0. CA0 \\<in> M;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs;\n                    map S CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 =\n                    map (S_M S M) CAs;\n                    is_ground_subst \\<eta>0; is_ground_subst_list \\<eta>s0;\n                    As0 \\<cdot>al \\<eta>0 = As;\n                    AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length As0 = n;\n                    D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n                    S_M S M (D + negs (mset As)) \\<noteq>\n                    {#} \\<Longrightarrow>\n                    negs (mset As0) = S DA0;\n                    length Cs0 = n; Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n                    \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n                    length AAs0 = n\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = Da + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Csa) + Da) \\<cdot> \\<sigma>;\n        length CAs = na; length Csa = na; length AAs = na; length As = na;\n        na \\<noteq> 0; \\<forall>i<na. CAs ! i = Csa ! i + poss (AAs ! i);\n        \\<forall>i<na. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (Da + negs (mset As));\n        \\<forall>i<na.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Csa ! i \\<cdot> \\<sigma>);\n        \\<forall>i<na. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  Ball (set \\<eta>s0) is_ground_subst", "have \"is_ground_subst_list \\<eta>s0\""], ["proof (prove)\nusing this:\n  Ball (set \\<eta>s0) is_ground_subst\n\ngoal (1 subgoal):\n 1. is_ground_subst_list \\<eta>s0", "using n"], ["proof (prove)\nusing this:\n  Ball (set \\<eta>s0) is_ground_subst\n  length \\<eta>s0 = n\n  length CAs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n\ngoal (1 subgoal):\n 1. is_ground_subst_list \\<eta>s0", "unfolding is_ground_subst_list_def"], ["proof (prove)\nusing this:\n  Ball (set \\<eta>s0) is_ground_subst\n  length \\<eta>s0 = n\n  length CAs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n\ngoal (1 subgoal):\n 1. Ball (set \\<eta>s0) is_ground_subst", "by auto\n\n  \\<comment> \\<open>Split side premises CAs0 into Cs0 and AAs0\\<close>"], ["proof (state)\nthis:\n  is_ground_subst_list \\<eta>s0\n\ngoal (1 subgoal):\n 1. \\<And>na Csa Da.\n       \\<lbrakk>\\<And>CAs0 \\<eta>s0 DA0 \\<eta>0 As0 AAs0 D0 Cs0.\n                   \\<lbrakk>length CAs0 = n; length \\<eta>s0 = n;\n                    DA0 \\<in> M; DA0 \\<cdot> \\<eta>0 = DA;\n                    S DA0 \\<cdot> \\<eta>0 = S_M S M DA;\n                    \\<forall>CA0\\<in>set CAs0. CA0 \\<in> M;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs;\n                    map S CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 =\n                    map (S_M S M) CAs;\n                    is_ground_subst \\<eta>0; is_ground_subst_list \\<eta>s0;\n                    As0 \\<cdot>al \\<eta>0 = As;\n                    AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length As0 = n;\n                    D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n                    S_M S M (D + negs (mset As)) \\<noteq>\n                    {#} \\<Longrightarrow>\n                    negs (mset As0) = S DA0;\n                    length Cs0 = n; Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n                    \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n                    length AAs0 = n\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = Da + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Csa) + Da) \\<cdot> \\<sigma>;\n        length CAs = na; length Csa = na; length AAs = na; length As = na;\n        na \\<noteq> 0; \\<forall>i<na. CAs ! i = Csa ! i + poss (AAs ! i);\n        \\<forall>i<na. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (Da + negs (mset As));\n        \\<forall>i<na.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Csa ! i \\<cdot> \\<sigma>);\n        \\<forall>i<na. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain AAs0 Cs0 where AAs0_Cs0_p:\n   \"AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs\" \"length Cs0 = n\" \"Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs\"\n   \"\\<forall>i < n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i)\" \"length AAs0 = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>AAs0 Cs0.\n        \\<lbrakk>AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length Cs0 = n;\n         Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n         \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n         length AAs0 = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>AAs0 Cs0.\n        \\<lbrakk>AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length Cs0 = n;\n         Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n         \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n         length AAs0 = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<forall>i < n. \\<exists>AA0. AA0 \\<cdot>am \\<eta>s0 ! i = AAs ! i \\<and> poss AA0 \\<subseteq># CAs0 ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<n.\n       \\<exists>AA0.\n          AA0 \\<cdot>am \\<eta>s0 ! i = AAs ! i \\<and>\n          poss AA0 \\<subseteq># CAs0 ! i", "proof (rule, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       \\<exists>AA0.\n          AA0 \\<cdot>am \\<eta>s0 ! i = AAs ! i \\<and>\n          poss AA0 \\<subseteq># CAs0 ! i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       \\<exists>AA0.\n          AA0 \\<cdot>am \\<eta>s0 ! i = AAs ! i \\<and>\n          poss AA0 \\<subseteq># CAs0 ! i", "assume \"i < n\""], ["proof (state)\nthis:\n  i < n\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       \\<exists>AA0.\n          AA0 \\<cdot>am \\<eta>s0 ! i = AAs ! i \\<and>\n          poss AA0 \\<subseteq># CAs0 ! i", "have \"CAs0 ! i \\<cdot> \\<eta>s0 ! i = CAs ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CAs0 ! i \\<cdot> \\<eta>s0 ! i = CAs ! i", "using \\<open>i < n\\<close> \\<open>CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs\\<close> n"], ["proof (prove)\nusing this:\n  i < n\n  CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs\n  length \\<eta>s0 = n\n  length CAs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n\ngoal (1 subgoal):\n 1. CAs0 ! i \\<cdot> \\<eta>s0 ! i = CAs ! i", "by force"], ["proof (state)\nthis:\n  CAs0 ! i \\<cdot> \\<eta>s0 ! i = CAs ! i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       \\<exists>AA0.\n          AA0 \\<cdot>am \\<eta>s0 ! i = AAs ! i \\<and>\n          poss AA0 \\<subseteq># CAs0 ! i", "moreover"], ["proof (state)\nthis:\n  CAs0 ! i \\<cdot> \\<eta>s0 ! i = CAs ! i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       \\<exists>AA0.\n          AA0 \\<cdot>am \\<eta>s0 ! i = AAs ! i \\<and>\n          poss AA0 \\<subseteq># CAs0 ! i", "have \"poss (AAs ! i) \\<subseteq># CAs !i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poss (AAs ! i) \\<subseteq># CAs ! i", "using \\<open>i < n\\<close> cas"], ["proof (prove)\nusing this:\n  i < n\n  \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i)\n\ngoal (1 subgoal):\n 1. poss (AAs ! i) \\<subseteq># CAs ! i", "by auto"], ["proof (state)\nthis:\n  poss (AAs ! i) \\<subseteq># CAs ! i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       \\<exists>AA0.\n          AA0 \\<cdot>am \\<eta>s0 ! i = AAs ! i \\<and>\n          poss AA0 \\<subseteq># CAs0 ! i", "ultimately"], ["proof (chain)\npicking this:\n  CAs0 ! i \\<cdot> \\<eta>s0 ! i = CAs ! i\n  poss (AAs ! i) \\<subseteq># CAs ! i", "obtain poss_AA0 where\n        nn: \"poss_AA0 \\<cdot> \\<eta>s0 ! i = poss (AAs ! i) \\<and> poss_AA0 \\<subseteq># CAs0 ! i\""], ["proof (prove)\nusing this:\n  CAs0 ! i \\<cdot> \\<eta>s0 ! i = CAs ! i\n  poss (AAs ! i) \\<subseteq># CAs ! i\n\ngoal (1 subgoal):\n 1. (\\<And>poss_AA0.\n        poss_AA0 \\<cdot> \\<eta>s0 ! i = poss (AAs ! i) \\<and>\n        poss_AA0 \\<subseteq># CAs0 ! i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using cas image_mset_of_subset"], ["proof (prove)\nusing this:\n  CAs0 ! i \\<cdot> \\<eta>s0 ! i = CAs ! i\n  poss (AAs ! i) \\<subseteq># CAs ! i\n  \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i)\n  ?A \\<subseteq># image_mset ?\\<eta> ?C' \\<Longrightarrow>\n  \\<exists>A'. image_mset ?\\<eta> A' = ?A \\<and> A' \\<subseteq># ?C'\n\ngoal (1 subgoal):\n 1. (\\<And>poss_AA0.\n        poss_AA0 \\<cdot> \\<eta>s0 ! i = poss (AAs ! i) \\<and>\n        poss_AA0 \\<subseteq># CAs0 ! i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding subst_cls_def"], ["proof (prove)\nusing this:\n  {#A \\<cdot>l \\<eta>s0 ! i. A \\<in># CAs0 ! i#} = CAs ! i\n  poss (AAs ! i) \\<subseteq># CAs ! i\n  \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i)\n  ?A \\<subseteq># image_mset ?\\<eta> ?C' \\<Longrightarrow>\n  \\<exists>A'. image_mset ?\\<eta> A' = ?A \\<and> A' \\<subseteq># ?C'\n\ngoal (1 subgoal):\n 1. (\\<And>poss_AA0.\n        {#A \\<cdot>l \\<eta>s0 ! i. A \\<in># poss_AA0#} =\n        poss (AAs ! i) \\<and>\n        poss_AA0 \\<subseteq># CAs0 ! i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  poss_AA0 \\<cdot> \\<eta>s0 ! i = poss (AAs ! i) \\<and>\n  poss_AA0 \\<subseteq># CAs0 ! i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       \\<exists>AA0.\n          AA0 \\<cdot>am \\<eta>s0 ! i = AAs ! i \\<and>\n          poss AA0 \\<subseteq># CAs0 ! i", "then"], ["proof (chain)\npicking this:\n  poss_AA0 \\<cdot> \\<eta>s0 ! i = poss (AAs ! i) \\<and>\n  poss_AA0 \\<subseteq># CAs0 ! i", "have l: \"\\<forall>L \\<in># poss_AA0. is_pos L\""], ["proof (prove)\nusing this:\n  poss_AA0 \\<cdot> \\<eta>s0 ! i = poss (AAs ! i) \\<and>\n  poss_AA0 \\<subseteq># CAs0 ! i\n\ngoal (1 subgoal):\n 1. \\<forall>L\\<in>#poss_AA0. is_pos L", "unfolding subst_cls_def"], ["proof (prove)\nusing this:\n  {#A \\<cdot>l \\<eta>s0 ! i. A \\<in># poss_AA0#} = poss (AAs ! i) \\<and>\n  poss_AA0 \\<subseteq># CAs0 ! i\n\ngoal (1 subgoal):\n 1. \\<forall>L\\<in>#poss_AA0. is_pos L", "by (metis Melem_subst_cls imageE literal.disc(1)\n            literal.map_disc_iff set_image_mset subst_cls_def subst_lit_def)"], ["proof (state)\nthis:\n  \\<forall>L\\<in>#poss_AA0. is_pos L\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       \\<exists>AA0.\n          AA0 \\<cdot>am \\<eta>s0 ! i = AAs ! i \\<and>\n          poss AA0 \\<subseteq># CAs0 ! i", "define AA0 where\n        \"AA0 = image_mset atm_of poss_AA0\""], ["proof (state)\nthis:\n  AA0 = image_mset atm_of poss_AA0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       \\<exists>AA0.\n          AA0 \\<cdot>am \\<eta>s0 ! i = AAs ! i \\<and>\n          poss AA0 \\<subseteq># CAs0 ! i", "have na: \"poss AA0 = poss_AA0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poss AA0 = poss_AA0", "using l"], ["proof (prove)\nusing this:\n  \\<forall>L\\<in>#poss_AA0. is_pos L\n\ngoal (1 subgoal):\n 1. poss AA0 = poss_AA0", "unfolding AA0_def"], ["proof (prove)\nusing this:\n  \\<forall>L\\<in>#poss_AA0. is_pos L\n\ngoal (1 subgoal):\n 1. poss (image_mset atm_of poss_AA0) = poss_AA0", "by auto"], ["proof (state)\nthis:\n  poss AA0 = poss_AA0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       \\<exists>AA0.\n          AA0 \\<cdot>am \\<eta>s0 ! i = AAs ! i \\<and>\n          poss AA0 \\<subseteq># CAs0 ! i", "then"], ["proof (chain)\npicking this:\n  poss AA0 = poss_AA0", "have \"AA0 \\<cdot>am \\<eta>s0 ! i = AAs ! i\""], ["proof (prove)\nusing this:\n  poss AA0 = poss_AA0\n\ngoal (1 subgoal):\n 1. AA0 \\<cdot>am \\<eta>s0 ! i = AAs ! i", "using nn"], ["proof (prove)\nusing this:\n  poss AA0 = poss_AA0\n  poss_AA0 \\<cdot> \\<eta>s0 ! i = poss (AAs ! i) \\<and>\n  poss_AA0 \\<subseteq># CAs0 ! i\n\ngoal (1 subgoal):\n 1. AA0 \\<cdot>am \\<eta>s0 ! i = AAs ! i", "by (metis (mono_tags) literal.inject(1) multiset.inj_map_strong subst_cls_poss)"], ["proof (state)\nthis:\n  AA0 \\<cdot>am \\<eta>s0 ! i = AAs ! i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       \\<exists>AA0.\n          AA0 \\<cdot>am \\<eta>s0 ! i = AAs ! i \\<and>\n          poss AA0 \\<subseteq># CAs0 ! i", "moreover"], ["proof (state)\nthis:\n  AA0 \\<cdot>am \\<eta>s0 ! i = AAs ! i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       \\<exists>AA0.\n          AA0 \\<cdot>am \\<eta>s0 ! i = AAs ! i \\<and>\n          poss AA0 \\<subseteq># CAs0 ! i", "have \"poss AA0 \\<subseteq># CAs0 ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poss AA0 \\<subseteq># CAs0 ! i", "using na nn"], ["proof (prove)\nusing this:\n  poss AA0 = poss_AA0\n  poss_AA0 \\<cdot> \\<eta>s0 ! i = poss (AAs ! i) \\<and>\n  poss_AA0 \\<subseteq># CAs0 ! i\n\ngoal (1 subgoal):\n 1. poss AA0 \\<subseteq># CAs0 ! i", "by auto"], ["proof (state)\nthis:\n  poss AA0 \\<subseteq># CAs0 ! i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       \\<exists>AA0.\n          AA0 \\<cdot>am \\<eta>s0 ! i = AAs ! i \\<and>\n          poss AA0 \\<subseteq># CAs0 ! i", "ultimately"], ["proof (chain)\npicking this:\n  AA0 \\<cdot>am \\<eta>s0 ! i = AAs ! i\n  poss AA0 \\<subseteq># CAs0 ! i", "show \"\\<exists>AA0. AA0 \\<cdot>am \\<eta>s0 ! i = AAs ! i \\<and> poss AA0 \\<subseteq># CAs0 ! i\""], ["proof (prove)\nusing this:\n  AA0 \\<cdot>am \\<eta>s0 ! i = AAs ! i\n  poss AA0 \\<subseteq># CAs0 ! i\n\ngoal (1 subgoal):\n 1. \\<exists>AA0.\n       AA0 \\<cdot>am \\<eta>s0 ! i = AAs ! i \\<and>\n       poss AA0 \\<subseteq># CAs0 ! i", "by blast"], ["proof (state)\nthis:\n  \\<exists>AA0.\n     AA0 \\<cdot>am \\<eta>s0 ! i = AAs ! i \\<and>\n     poss AA0 \\<subseteq># CAs0 ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i<n.\n     \\<exists>AA0.\n        AA0 \\<cdot>am \\<eta>s0 ! i = AAs ! i \\<and>\n        poss AA0 \\<subseteq># CAs0 ! i\n\ngoal (1 subgoal):\n 1. (\\<And>AAs0 Cs0.\n        \\<lbrakk>AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length Cs0 = n;\n         Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n         \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n         length AAs0 = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<n.\n     \\<exists>AA0.\n        AA0 \\<cdot>am \\<eta>s0 ! i = AAs ! i \\<and>\n        poss AA0 \\<subseteq># CAs0 ! i", "obtain AAs0f where\n      AAs0f_p: \"\\<forall>i < n. AAs0f i \\<cdot>am \\<eta>s0 ! i = AAs ! i \\<and> (poss (AAs0f i)) \\<subseteq># CAs0 ! i\""], ["proof (prove)\nusing this:\n  \\<forall>i<n.\n     \\<exists>AA0.\n        AA0 \\<cdot>am \\<eta>s0 ! i = AAs ! i \\<and>\n        poss AA0 \\<subseteq># CAs0 ! i\n\ngoal (1 subgoal):\n 1. (\\<And>AAs0f.\n        \\<forall>i<n.\n           AAs0f i \\<cdot>am \\<eta>s0 ! i = AAs ! i \\<and>\n           poss (AAs0f i) \\<subseteq># CAs0 ! i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  \\<forall>i<n.\n     AAs0f i \\<cdot>am \\<eta>s0 ! i = AAs ! i \\<and>\n     poss (AAs0f i) \\<subseteq># CAs0 ! i\n\ngoal (1 subgoal):\n 1. (\\<And>AAs0 Cs0.\n        \\<lbrakk>AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length Cs0 = n;\n         Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n         \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n         length AAs0 = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define AAs0 where \"AAs0 = map AAs0f [0 ..<n]\""], ["proof (state)\nthis:\n  AAs0 = map AAs0f [0..<n]\n\ngoal (1 subgoal):\n 1. (\\<And>AAs0 Cs0.\n        \\<lbrakk>AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length Cs0 = n;\n         Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n         \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n         length AAs0 = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  AAs0 = map AAs0f [0..<n]", "have \"length AAs0 = n\""], ["proof (prove)\nusing this:\n  AAs0 = map AAs0f [0..<n]\n\ngoal (1 subgoal):\n 1. length AAs0 = n", "by auto"], ["proof (state)\nthis:\n  length AAs0 = n\n\ngoal (1 subgoal):\n 1. (\\<And>AAs0 Cs0.\n        \\<lbrakk>AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length Cs0 = n;\n         Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n         \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n         length AAs0 = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note n = n \\<open>length AAs0 = n\\<close>"], ["proof (state)\nthis:\n  length \\<eta>s0 = n\n  length CAs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length AAs0 = n\n\ngoal (1 subgoal):\n 1. (\\<And>AAs0 Cs0.\n        \\<lbrakk>AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length Cs0 = n;\n         Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n         \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n         length AAs0 = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from AAs0_def"], ["proof (chain)\npicking this:\n  AAs0 = map AAs0f [0..<n]", "have \"\\<forall>i < n. AAs0 ! i \\<cdot>am \\<eta>s0 ! i = AAs ! i\""], ["proof (prove)\nusing this:\n  AAs0 = map AAs0f [0..<n]\n\ngoal (1 subgoal):\n 1. \\<forall>i<n. AAs0 ! i \\<cdot>am \\<eta>s0 ! i = AAs ! i", "using AAs0f_p"], ["proof (prove)\nusing this:\n  AAs0 = map AAs0f [0..<n]\n  \\<forall>i<n.\n     AAs0f i \\<cdot>am \\<eta>s0 ! i = AAs ! i \\<and>\n     poss (AAs0f i) \\<subseteq># CAs0 ! i\n\ngoal (1 subgoal):\n 1. \\<forall>i<n. AAs0 ! i \\<cdot>am \\<eta>s0 ! i = AAs ! i", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<n. AAs0 ! i \\<cdot>am \\<eta>s0 ! i = AAs ! i\n\ngoal (1 subgoal):\n 1. (\\<And>AAs0 Cs0.\n        \\<lbrakk>AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length Cs0 = n;\n         Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n         \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n         length AAs0 = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<n. AAs0 ! i \\<cdot>am \\<eta>s0 ! i = AAs ! i", "have AAs0_AAs: \"AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs\""], ["proof (prove)\nusing this:\n  \\<forall>i<n. AAs0 ! i \\<cdot>am \\<eta>s0 ! i = AAs ! i\n\ngoal (1 subgoal):\n 1. AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs", "using n"], ["proof (prove)\nusing this:\n  \\<forall>i<n. AAs0 ! i \\<cdot>am \\<eta>s0 ! i = AAs ! i\n  length \\<eta>s0 = n\n  length CAs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length AAs0 = n\n\ngoal (1 subgoal):\n 1. AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs", "by (auto intro: nth_equalityI)"], ["proof (state)\nthis:\n  AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs\n\ngoal (1 subgoal):\n 1. (\\<And>AAs0 Cs0.\n        \\<lbrakk>AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length Cs0 = n;\n         Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n         \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n         length AAs0 = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from AAs0_def"], ["proof (chain)\npicking this:\n  AAs0 = map AAs0f [0..<n]", "have AAs0_in_CAs0: \"\\<forall>i < n. poss (AAs0 ! i) \\<subseteq># CAs0 ! i\""], ["proof (prove)\nusing this:\n  AAs0 = map AAs0f [0..<n]\n\ngoal (1 subgoal):\n 1. \\<forall>i<n. poss (AAs0 ! i) \\<subseteq># CAs0 ! i", "using AAs0f_p"], ["proof (prove)\nusing this:\n  AAs0 = map AAs0f [0..<n]\n  \\<forall>i<n.\n     AAs0f i \\<cdot>am \\<eta>s0 ! i = AAs ! i \\<and>\n     poss (AAs0f i) \\<subseteq># CAs0 ! i\n\ngoal (1 subgoal):\n 1. \\<forall>i<n. poss (AAs0 ! i) \\<subseteq># CAs0 ! i", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<n. poss (AAs0 ! i) \\<subseteq># CAs0 ! i\n\ngoal (1 subgoal):\n 1. (\\<And>AAs0 Cs0.\n        \\<lbrakk>AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length Cs0 = n;\n         Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n         \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n         length AAs0 = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define Cs0 where\n      \"Cs0 = map2 (-) CAs0 (map poss AAs0)\""], ["proof (state)\nthis:\n  Cs0 = Map2.map2 (-) CAs0 (map poss AAs0)\n\ngoal (1 subgoal):\n 1. (\\<And>AAs0 Cs0.\n        \\<lbrakk>AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length Cs0 = n;\n         Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n         \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n         length AAs0 = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"length Cs0 = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length Cs0 = n", "using Cs0_def n"], ["proof (prove)\nusing this:\n  Cs0 = Map2.map2 (-) CAs0 (map poss AAs0)\n  length \\<eta>s0 = n\n  length CAs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length AAs0 = n\n\ngoal (1 subgoal):\n 1. length Cs0 = n", "by auto"], ["proof (state)\nthis:\n  length Cs0 = n\n\ngoal (1 subgoal):\n 1. (\\<And>AAs0 Cs0.\n        \\<lbrakk>AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length Cs0 = n;\n         Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n         \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n         length AAs0 = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note n = n \\<open>length Cs0 = n\\<close>"], ["proof (state)\nthis:\n  length \\<eta>s0 = n\n  length CAs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length AAs0 = n\n  length Cs0 = n\n\ngoal (1 subgoal):\n 1. (\\<And>AAs0 Cs0.\n        \\<lbrakk>AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length Cs0 = n;\n         Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n         \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n         length AAs0 = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<forall>i < n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i)", "using AAs0_in_CAs0 Cs0_def n"], ["proof (prove)\nusing this:\n  \\<forall>i<n. poss (AAs0 ! i) \\<subseteq># CAs0 ! i\n  Cs0 = Map2.map2 (-) CAs0 (map poss AAs0)\n  length \\<eta>s0 = n\n  length CAs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length AAs0 = n\n  length Cs0 = n\n\ngoal (1 subgoal):\n 1. \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i)", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i)\n\ngoal (1 subgoal):\n 1. (\\<And>AAs0 Cs0.\n        \\<lbrakk>AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length Cs0 = n;\n         Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n         \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n         length AAs0 = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i)", "have \"Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs\""], ["proof (prove)\nusing this:\n  \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i)\n\ngoal (1 subgoal):\n 1. Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs", "using \\<open>CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs\\<close> AAs0_AAs cas n"], ["proof (prove)\nusing this:\n  \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i)\n  CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs\n  AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs\n  \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i)\n  length \\<eta>s0 = n\n  length CAs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length AAs0 = n\n  length Cs0 = n\n\ngoal (1 subgoal):\n 1. Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs", "by (auto intro: nth_equalityI)"], ["proof (state)\nthis:\n  Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs\n\ngoal (1 subgoal):\n 1. (\\<And>AAs0 Cs0.\n        \\<lbrakk>AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length Cs0 = n;\n         Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n         \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n         length AAs0 = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using that\n        \\<open>AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs\\<close> \\<open>Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs\\<close> \\<open>\\<forall>i < n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i)\\<close>\n        \\<open>length AAs0 = n\\<close> \\<open>length Cs0 = n\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?AAs0.0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length ?Cs0.0 = n;\n   ?Cs0.0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n   \\<forall>i<n. CAs0 ! i = ?Cs0.0 ! i + poss (?AAs0.0 ! i);\n   length ?AAs0.0 = n\\<rbrakk>\n  \\<Longrightarrow> thesis\n  AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs\n  Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs\n  \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i)\n  length AAs0 = n\n  length Cs0 = n\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed\n\n  \\<comment> \\<open>Obtain FO main premise\\<close>"], ["proof (state)\nthis:\n  AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs\n  length Cs0 = n\n  Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs\n  \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i)\n  length AAs0 = n\n\ngoal (1 subgoal):\n 1. \\<And>na Csa Da.\n       \\<lbrakk>\\<And>CAs0 \\<eta>s0 DA0 \\<eta>0 As0 AAs0 D0 Cs0.\n                   \\<lbrakk>length CAs0 = n; length \\<eta>s0 = n;\n                    DA0 \\<in> M; DA0 \\<cdot> \\<eta>0 = DA;\n                    S DA0 \\<cdot> \\<eta>0 = S_M S M DA;\n                    \\<forall>CA0\\<in>set CAs0. CA0 \\<in> M;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs;\n                    map S CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 =\n                    map (S_M S M) CAs;\n                    is_ground_subst \\<eta>0; is_ground_subst_list \\<eta>s0;\n                    As0 \\<cdot>al \\<eta>0 = As;\n                    AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length As0 = n;\n                    D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n                    S_M S M (D + negs (mset As)) \\<noteq>\n                    {#} \\<Longrightarrow>\n                    negs (mset As0) = S DA0;\n                    length Cs0 = n; Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n                    \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n                    length AAs0 = n\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = Da + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Csa) + Da) \\<cdot> \\<sigma>;\n        length CAs = na; length Csa = na; length AAs = na; length As = na;\n        na \\<noteq> 0; \\<forall>i<na. CAs ! i = Csa ! i + poss (AAs ! i);\n        \\<forall>i<na. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (Da + negs (mset As));\n        \\<forall>i<na.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Csa ! i \\<cdot> \\<sigma>);\n        \\<forall>i<na. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"\\<exists>DA0 \\<eta>0. DA0 \\<in> M \\<and> DA = DA0 \\<cdot> \\<eta>0 \\<and> S DA0 \\<cdot> \\<eta>0 = S_M S M DA \\<and> is_ground_subst \\<eta>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>DA0 \\<eta>0.\n       DA0 \\<in> M \\<and>\n       DA = DA0 \\<cdot> \\<eta>0 \\<and>\n       S DA0 \\<cdot> \\<eta>0 = S_M S M DA \\<and> is_ground_subst \\<eta>0", "using grounding S_M_grounding_of_clss select"], ["proof (prove)\nusing this:\n  {DA} \\<union> set CAs \\<subseteq> grounding_of_clss M\n  \\<lbrakk>selection ?S; ?C \\<in> grounding_of_clss ?M;\n   \\<And>D \\<sigma>.\n      D \\<in> ?M \\<and>\n      ?C = D \\<cdot> \\<sigma> \\<and>\n      S_M ?S ?M ?C = ?S D \\<cdot> \\<sigma> \\<and>\n      is_ground_subst \\<sigma> \\<Longrightarrow>\n      ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  selection S\n\ngoal (1 subgoal):\n 1. \\<exists>DA0 \\<eta>0.\n       DA0 \\<in> M \\<and>\n       DA = DA0 \\<cdot> \\<eta>0 \\<and>\n       S DA0 \\<cdot> \\<eta>0 = S_M S M DA \\<and> is_ground_subst \\<eta>0", "by (metis le_supE singletonI subsetCE)"], ["proof (state)\nthis:\n  \\<exists>DA0 \\<eta>0.\n     DA0 \\<in> M \\<and>\n     DA = DA0 \\<cdot> \\<eta>0 \\<and>\n     S DA0 \\<cdot> \\<eta>0 = S_M S M DA \\<and> is_ground_subst \\<eta>0\n\ngoal (1 subgoal):\n 1. \\<And>na Csa Da.\n       \\<lbrakk>\\<And>CAs0 \\<eta>s0 DA0 \\<eta>0 As0 AAs0 D0 Cs0.\n                   \\<lbrakk>length CAs0 = n; length \\<eta>s0 = n;\n                    DA0 \\<in> M; DA0 \\<cdot> \\<eta>0 = DA;\n                    S DA0 \\<cdot> \\<eta>0 = S_M S M DA;\n                    \\<forall>CA0\\<in>set CAs0. CA0 \\<in> M;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs;\n                    map S CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 =\n                    map (S_M S M) CAs;\n                    is_ground_subst \\<eta>0; is_ground_subst_list \\<eta>s0;\n                    As0 \\<cdot>al \\<eta>0 = As;\n                    AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length As0 = n;\n                    D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n                    S_M S M (D + negs (mset As)) \\<noteq>\n                    {#} \\<Longrightarrow>\n                    negs (mset As0) = S DA0;\n                    length Cs0 = n; Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n                    \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n                    length AAs0 = n\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = Da + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Csa) + Da) \\<cdot> \\<sigma>;\n        length CAs = na; length Csa = na; length AAs = na; length As = na;\n        na \\<noteq> 0; \\<forall>i<na. CAs ! i = Csa ! i + poss (AAs ! i);\n        \\<forall>i<na. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (Da + negs (mset As));\n        \\<forall>i<na.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Csa ! i \\<cdot> \\<sigma>);\n        \\<forall>i<na. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<exists>DA0 \\<eta>0.\n     DA0 \\<in> M \\<and>\n     DA = DA0 \\<cdot> \\<eta>0 \\<and>\n     S DA0 \\<cdot> \\<eta>0 = S_M S M DA \\<and> is_ground_subst \\<eta>0", "obtain DA0 \\<eta>0 where\n    DA0_\\<eta>0_p: \"DA0 \\<in> M \\<and> DA = DA0 \\<cdot> \\<eta>0 \\<and> S DA0 \\<cdot> \\<eta>0 = S_M S M DA \\<and> is_ground_subst \\<eta>0\""], ["proof (prove)\nusing this:\n  \\<exists>DA0 \\<eta>0.\n     DA0 \\<in> M \\<and>\n     DA = DA0 \\<cdot> \\<eta>0 \\<and>\n     S DA0 \\<cdot> \\<eta>0 = S_M S M DA \\<and> is_ground_subst \\<eta>0\n\ngoal (1 subgoal):\n 1. (\\<And>DA0 \\<eta>0.\n        DA0 \\<in> M \\<and>\n        DA = DA0 \\<cdot> \\<eta>0 \\<and>\n        S DA0 \\<cdot> \\<eta>0 = S_M S M DA \\<and>\n        is_ground_subst \\<eta>0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto\n  \\<comment> \\<open>The properties we need of the FO main premise\\<close>"], ["proof (state)\nthis:\n  DA0 \\<in> M \\<and>\n  DA = DA0 \\<cdot> \\<eta>0 \\<and>\n  S DA0 \\<cdot> \\<eta>0 = S_M S M DA \\<and> is_ground_subst \\<eta>0\n\ngoal (1 subgoal):\n 1. \\<And>na Csa Da.\n       \\<lbrakk>\\<And>CAs0 \\<eta>s0 DA0 \\<eta>0 As0 AAs0 D0 Cs0.\n                   \\<lbrakk>length CAs0 = n; length \\<eta>s0 = n;\n                    DA0 \\<in> M; DA0 \\<cdot> \\<eta>0 = DA;\n                    S DA0 \\<cdot> \\<eta>0 = S_M S M DA;\n                    \\<forall>CA0\\<in>set CAs0. CA0 \\<in> M;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs;\n                    map S CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 =\n                    map (S_M S M) CAs;\n                    is_ground_subst \\<eta>0; is_ground_subst_list \\<eta>s0;\n                    As0 \\<cdot>al \\<eta>0 = As;\n                    AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length As0 = n;\n                    D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n                    S_M S M (D + negs (mset As)) \\<noteq>\n                    {#} \\<Longrightarrow>\n                    negs (mset As0) = S DA0;\n                    length Cs0 = n; Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n                    \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n                    length AAs0 = n\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = Da + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Csa) + Da) \\<cdot> \\<sigma>;\n        length CAs = na; length Csa = na; length AAs = na; length As = na;\n        na \\<noteq> 0; \\<forall>i<na. CAs ! i = Csa ! i + poss (AAs ! i);\n        \\<forall>i<na. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (Da + negs (mset As));\n        \\<forall>i<na.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Csa ! i \\<cdot> \\<sigma>);\n        \\<forall>i<na. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have DA0_in_M: \"DA0 \\<in> M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DA0 \\<in> M", "using DA0_\\<eta>0_p"], ["proof (prove)\nusing this:\n  DA0 \\<in> M \\<and>\n  DA = DA0 \\<cdot> \\<eta>0 \\<and>\n  S DA0 \\<cdot> \\<eta>0 = S_M S M DA \\<and> is_ground_subst \\<eta>0\n\ngoal (1 subgoal):\n 1. DA0 \\<in> M", "by auto"], ["proof (state)\nthis:\n  DA0 \\<in> M\n\ngoal (1 subgoal):\n 1. \\<And>na Csa Da.\n       \\<lbrakk>\\<And>CAs0 \\<eta>s0 DA0 \\<eta>0 As0 AAs0 D0 Cs0.\n                   \\<lbrakk>length CAs0 = n; length \\<eta>s0 = n;\n                    DA0 \\<in> M; DA0 \\<cdot> \\<eta>0 = DA;\n                    S DA0 \\<cdot> \\<eta>0 = S_M S M DA;\n                    \\<forall>CA0\\<in>set CAs0. CA0 \\<in> M;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs;\n                    map S CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 =\n                    map (S_M S M) CAs;\n                    is_ground_subst \\<eta>0; is_ground_subst_list \\<eta>s0;\n                    As0 \\<cdot>al \\<eta>0 = As;\n                    AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length As0 = n;\n                    D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n                    S_M S M (D + negs (mset As)) \\<noteq>\n                    {#} \\<Longrightarrow>\n                    negs (mset As0) = S DA0;\n                    length Cs0 = n; Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n                    \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n                    length AAs0 = n\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = Da + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Csa) + Da) \\<cdot> \\<sigma>;\n        length CAs = na; length Csa = na; length AAs = na; length As = na;\n        na \\<noteq> 0; \\<forall>i<na. CAs ! i = Csa ! i + poss (AAs ! i);\n        \\<forall>i<na. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (Da + negs (mset As));\n        \\<forall>i<na.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Csa ! i \\<cdot> \\<sigma>);\n        \\<forall>i<na. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have DA0_to_DA: \"DA0 \\<cdot> \\<eta>0 = DA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DA0 \\<cdot> \\<eta>0 = DA", "using DA0_\\<eta>0_p"], ["proof (prove)\nusing this:\n  DA0 \\<in> M \\<and>\n  DA = DA0 \\<cdot> \\<eta>0 \\<and>\n  S DA0 \\<cdot> \\<eta>0 = S_M S M DA \\<and> is_ground_subst \\<eta>0\n\ngoal (1 subgoal):\n 1. DA0 \\<cdot> \\<eta>0 = DA", "by auto"], ["proof (state)\nthis:\n  DA0 \\<cdot> \\<eta>0 = DA\n\ngoal (1 subgoal):\n 1. \\<And>na Csa Da.\n       \\<lbrakk>\\<And>CAs0 \\<eta>s0 DA0 \\<eta>0 As0 AAs0 D0 Cs0.\n                   \\<lbrakk>length CAs0 = n; length \\<eta>s0 = n;\n                    DA0 \\<in> M; DA0 \\<cdot> \\<eta>0 = DA;\n                    S DA0 \\<cdot> \\<eta>0 = S_M S M DA;\n                    \\<forall>CA0\\<in>set CAs0. CA0 \\<in> M;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs;\n                    map S CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 =\n                    map (S_M S M) CAs;\n                    is_ground_subst \\<eta>0; is_ground_subst_list \\<eta>s0;\n                    As0 \\<cdot>al \\<eta>0 = As;\n                    AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length As0 = n;\n                    D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n                    S_M S M (D + negs (mset As)) \\<noteq>\n                    {#} \\<Longrightarrow>\n                    negs (mset As0) = S DA0;\n                    length Cs0 = n; Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n                    \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n                    length AAs0 = n\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = Da + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Csa) + Da) \\<cdot> \\<sigma>;\n        length CAs = na; length Csa = na; length AAs = na; length As = na;\n        na \\<noteq> 0; \\<forall>i<na. CAs ! i = Csa ! i + poss (AAs ! i);\n        \\<forall>i<na. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (Da + negs (mset As));\n        \\<forall>i<na.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Csa ! i \\<cdot> \\<sigma>);\n        \\<forall>i<na. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have SDA0_to_SMDA: \"S DA0 \\<cdot> \\<eta>0 = S_M S M DA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S DA0 \\<cdot> \\<eta>0 = S_M S M DA", "using DA0_\\<eta>0_p"], ["proof (prove)\nusing this:\n  DA0 \\<in> M \\<and>\n  DA = DA0 \\<cdot> \\<eta>0 \\<and>\n  S DA0 \\<cdot> \\<eta>0 = S_M S M DA \\<and> is_ground_subst \\<eta>0\n\ngoal (1 subgoal):\n 1. S DA0 \\<cdot> \\<eta>0 = S_M S M DA", "by auto"], ["proof (state)\nthis:\n  S DA0 \\<cdot> \\<eta>0 = S_M S M DA\n\ngoal (1 subgoal):\n 1. \\<And>na Csa Da.\n       \\<lbrakk>\\<And>CAs0 \\<eta>s0 DA0 \\<eta>0 As0 AAs0 D0 Cs0.\n                   \\<lbrakk>length CAs0 = n; length \\<eta>s0 = n;\n                    DA0 \\<in> M; DA0 \\<cdot> \\<eta>0 = DA;\n                    S DA0 \\<cdot> \\<eta>0 = S_M S M DA;\n                    \\<forall>CA0\\<in>set CAs0. CA0 \\<in> M;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs;\n                    map S CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 =\n                    map (S_M S M) CAs;\n                    is_ground_subst \\<eta>0; is_ground_subst_list \\<eta>s0;\n                    As0 \\<cdot>al \\<eta>0 = As;\n                    AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length As0 = n;\n                    D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n                    S_M S M (D + negs (mset As)) \\<noteq>\n                    {#} \\<Longrightarrow>\n                    negs (mset As0) = S DA0;\n                    length Cs0 = n; Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n                    \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n                    length AAs0 = n\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = Da + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Csa) + Da) \\<cdot> \\<sigma>;\n        length CAs = na; length Csa = na; length AAs = na; length As = na;\n        na \\<noteq> 0; \\<forall>i<na. CAs ! i = Csa ! i + poss (AAs ! i);\n        \\<forall>i<na. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (Da + negs (mset As));\n        \\<forall>i<na.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Csa ! i \\<cdot> \\<sigma>);\n        \\<forall>i<na. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"is_ground_subst \\<eta>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_subst \\<eta>0", "using DA0_\\<eta>0_p"], ["proof (prove)\nusing this:\n  DA0 \\<in> M \\<and>\n  DA = DA0 \\<cdot> \\<eta>0 \\<and>\n  S DA0 \\<cdot> \\<eta>0 = S_M S M DA \\<and> is_ground_subst \\<eta>0\n\ngoal (1 subgoal):\n 1. is_ground_subst \\<eta>0", "by auto\n\n  \\<comment> \\<open>Split main premise DA0 into D0 and As0\\<close>"], ["proof (state)\nthis:\n  is_ground_subst \\<eta>0\n\ngoal (1 subgoal):\n 1. \\<And>na Csa Da.\n       \\<lbrakk>\\<And>CAs0 \\<eta>s0 DA0 \\<eta>0 As0 AAs0 D0 Cs0.\n                   \\<lbrakk>length CAs0 = n; length \\<eta>s0 = n;\n                    DA0 \\<in> M; DA0 \\<cdot> \\<eta>0 = DA;\n                    S DA0 \\<cdot> \\<eta>0 = S_M S M DA;\n                    \\<forall>CA0\\<in>set CAs0. CA0 \\<in> M;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs;\n                    map S CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 =\n                    map (S_M S M) CAs;\n                    is_ground_subst \\<eta>0; is_ground_subst_list \\<eta>s0;\n                    As0 \\<cdot>al \\<eta>0 = As;\n                    AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length As0 = n;\n                    D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n                    S_M S M (D + negs (mset As)) \\<noteq>\n                    {#} \\<Longrightarrow>\n                    negs (mset As0) = S DA0;\n                    length Cs0 = n; Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n                    \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n                    length AAs0 = n\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = Da + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Csa) + Da) \\<cdot> \\<sigma>;\n        length CAs = na; length Csa = na; length AAs = na; length As = na;\n        na \\<noteq> 0; \\<forall>i<na. CAs ! i = Csa ! i + poss (AAs ! i);\n        \\<forall>i<na. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (Da + negs (mset As));\n        \\<forall>i<na.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Csa ! i \\<cdot> \\<sigma>);\n        \\<forall>i<na. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain D0 As0 where D0As0_p:\n     \"As0  \\<cdot>al \\<eta>0 = As\" \"length As0 = n\" \"D0 \\<cdot> \\<eta>0 = D\" \"DA0 = D0 + (negs (mset As0))\"\n    \"S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow> negs (mset As0) = S DA0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>As0 D0.\n        \\<lbrakk>As0 \\<cdot>al \\<eta>0 = As; length As0 = n;\n         D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n         S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n         negs (mset As0) = S DA0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>As0 D0.\n        \\<lbrakk>As0 \\<cdot>al \\<eta>0 = As; length As0 = n;\n         D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n         S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n         negs (mset As0) = S DA0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>As0 D0.\n        \\<lbrakk>As0 \\<cdot>al \\<eta>0 = As; length As0 = n;\n         D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n         S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n         negs (mset As0) = S DA0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "assume a: \"S_M S M (D + negs (mset As)) = {#} \\<and> length As = (Suc 0)\n        \\<and> maximal_wrt (As ! 0 \\<cdot>a \\<sigma>) ((D + negs (mset As)) \\<cdot> \\<sigma>)\""], ["proof (state)\nthis:\n  S_M S M (D + negs (mset As)) = {#} \\<and>\n  length As = Suc 0 \\<and>\n  maximal_wrt (As ! 0 \\<cdot>a \\<sigma>)\n   ((D + negs (mset As)) \\<cdot> \\<sigma>)\n\ngoal (1 subgoal):\n 1. (\\<And>As0 D0.\n        \\<lbrakk>As0 \\<cdot>al \\<eta>0 = As; length As0 = n;\n         D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n         S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n         negs (mset As0) = S DA0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  S_M S M (D + negs (mset As)) = {#} \\<and>\n  length As = Suc 0 \\<and>\n  maximal_wrt (As ! 0 \\<cdot>a \\<sigma>)\n   ((D + negs (mset As)) \\<cdot> \\<sigma>)", "have as: \"mset As = {#As ! 0#}\""], ["proof (prove)\nusing this:\n  S_M S M (D + negs (mset As)) = {#} \\<and>\n  length As = Suc 0 \\<and>\n  maximal_wrt (As ! 0 \\<cdot>a \\<sigma>)\n   ((D + negs (mset As)) \\<cdot> \\<sigma>)\n\ngoal (1 subgoal):\n 1. mset As = {#As ! 0#}", "by (auto intro: nth_equalityI)"], ["proof (state)\nthis:\n  mset As = {#As ! 0#}\n\ngoal (1 subgoal):\n 1. (\\<And>As0 D0.\n        \\<lbrakk>As0 \\<cdot>al \\<eta>0 = As; length As0 = n;\n         D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n         S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n         negs (mset As0) = S DA0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  mset As = {#As ! 0#}", "have \"negs (mset As) = {#Neg (As ! 0)#}\""], ["proof (prove)\nusing this:\n  mset As = {#As ! 0#}\n\ngoal (1 subgoal):\n 1. negs (mset As) = {#Neg (As ! 0)#}", "by (simp add: \\<open>mset As = {#As ! 0#}\\<close>)"], ["proof (state)\nthis:\n  negs (mset As) = {#Neg (As ! 0)#}\n\ngoal (1 subgoal):\n 1. (\\<And>As0 D0.\n        \\<lbrakk>As0 \\<cdot>al \\<eta>0 = As; length As0 = n;\n         D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n         S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n         negs (mset As0) = S DA0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  negs (mset As) = {#Neg (As ! 0)#}", "have \"DA = D + {#Neg (As ! 0)#}\""], ["proof (prove)\nusing this:\n  negs (mset As) = {#Neg (As ! 0)#}\n\ngoal (1 subgoal):\n 1. DA = D + {#Neg (As ! 0)#}", "using da"], ["proof (prove)\nusing this:\n  negs (mset As) = {#Neg (As ! 0)#}\n  DA = D + negs (mset As)\n\ngoal (1 subgoal):\n 1. DA = D + {#Neg (As ! 0)#}", "by auto"], ["proof (state)\nthis:\n  DA = D + {#Neg (As ! 0)#}\n\ngoal (1 subgoal):\n 1. (\\<And>As0 D0.\n        \\<lbrakk>As0 \\<cdot>al \\<eta>0 = As; length As0 = n;\n         D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n         S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n         negs (mset As0) = S DA0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  DA = D + {#Neg (As ! 0)#}", "obtain L where \"L \\<in># DA0 \\<and> L \\<cdot>l \\<eta>0 = Neg (As ! 0)\""], ["proof (prove)\nusing this:\n  DA = D + {#Neg (As ! 0)#}\n\ngoal (1 subgoal):\n 1. (\\<And>L.\n        L \\<in># DA0 \\<and>\n        L \\<cdot>l \\<eta>0 = Neg (As ! 0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using DA0_to_DA"], ["proof (prove)\nusing this:\n  DA = D + {#Neg (As ! 0)#}\n  DA0 \\<cdot> \\<eta>0 = DA\n\ngoal (1 subgoal):\n 1. (\\<And>L.\n        L \\<in># DA0 \\<and>\n        L \\<cdot>l \\<eta>0 = Neg (As ! 0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis Melem_subst_cls mset_subset_eq_add_right single_subset_iff)"], ["proof (state)\nthis:\n  L \\<in># DA0 \\<and> L \\<cdot>l \\<eta>0 = Neg (As ! 0)\n\ngoal (1 subgoal):\n 1. (\\<And>As0 D0.\n        \\<lbrakk>As0 \\<cdot>al \\<eta>0 = As; length As0 = n;\n         D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n         S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n         negs (mset As0) = S DA0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  L \\<in># DA0 \\<and> L \\<cdot>l \\<eta>0 = Neg (As ! 0)", "have \"Neg (atm_of L) \\<in># DA0 \\<and> Neg (atm_of L) \\<cdot>l \\<eta>0 = Neg (As ! 0)\""], ["proof (prove)\nusing this:\n  L \\<in># DA0 \\<and> L \\<cdot>l \\<eta>0 = Neg (As ! 0)\n\ngoal (1 subgoal):\n 1. Neg (atm_of L) \\<in># DA0 \\<and>\n    Neg (atm_of L) \\<cdot>l \\<eta>0 = Neg (As ! 0)", "by (metis Neg_atm_of_iff literal.sel(2) subst_lit_is_pos)"], ["proof (state)\nthis:\n  Neg (atm_of L) \\<in># DA0 \\<and>\n  Neg (atm_of L) \\<cdot>l \\<eta>0 = Neg (As ! 0)\n\ngoal (1 subgoal):\n 1. (\\<And>As0 D0.\n        \\<lbrakk>As0 \\<cdot>al \\<eta>0 = As; length As0 = n;\n         D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n         S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n         negs (mset As0) = S DA0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  Neg (atm_of L) \\<in># DA0 \\<and>\n  Neg (atm_of L) \\<cdot>l \\<eta>0 = Neg (As ! 0)", "have \"[atm_of L] \\<cdot>al \\<eta>0 = As \\<and> negs (mset [atm_of L]) \\<subseteq># DA0\""], ["proof (prove)\nusing this:\n  Neg (atm_of L) \\<in># DA0 \\<and>\n  Neg (atm_of L) \\<cdot>l \\<eta>0 = Neg (As ! 0)\n\ngoal (1 subgoal):\n 1. [atm_of L] \\<cdot>al \\<eta>0 = As \\<and>\n    negs (mset [atm_of L]) \\<subseteq># DA0", "using as subst_lit_def"], ["proof (prove)\nusing this:\n  Neg (atm_of L) \\<in># DA0 \\<and>\n  Neg (atm_of L) \\<cdot>l \\<eta>0 = Neg (As ! 0)\n  mset As = {#As ! 0#}\n  ?L \\<cdot>l ?\\<sigma> = map_literal (\\<lambda>A. A \\<cdot>a ?\\<sigma>) ?L\n\ngoal (1 subgoal):\n 1. [atm_of L] \\<cdot>al \\<eta>0 = As \\<and>\n    negs (mset [atm_of L]) \\<subseteq># DA0", "by auto"], ["proof (state)\nthis:\n  [atm_of L] \\<cdot>al \\<eta>0 = As \\<and>\n  negs (mset [atm_of L]) \\<subseteq># DA0\n\ngoal (1 subgoal):\n 1. (\\<And>As0 D0.\n        \\<lbrakk>As0 \\<cdot>al \\<eta>0 = As; length As0 = n;\n         D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n         S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n         negs (mset As0) = S DA0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  [atm_of L] \\<cdot>al \\<eta>0 = As \\<and>\n  negs (mset [atm_of L]) \\<subseteq># DA0", "have \"\\<exists>As0. As0 \\<cdot>al \\<eta>0 = As \\<and> negs (mset As0) \\<subseteq># DA0\n        \\<and> (S_M S M (D + negs (mset As)) \\<noteq> {#} \\<longrightarrow> negs (mset As0) = S DA0)\""], ["proof (prove)\nusing this:\n  [atm_of L] \\<cdot>al \\<eta>0 = As \\<and>\n  negs (mset [atm_of L]) \\<subseteq># DA0\n\ngoal (1 subgoal):\n 1. \\<exists>As0.\n       As0 \\<cdot>al \\<eta>0 = As \\<and>\n       negs (mset As0) \\<subseteq># DA0 \\<and>\n       (S_M S M (D + negs (mset As)) \\<noteq> {#} \\<longrightarrow>\n        negs (mset As0) = S DA0)", "using a"], ["proof (prove)\nusing this:\n  [atm_of L] \\<cdot>al \\<eta>0 = As \\<and>\n  negs (mset [atm_of L]) \\<subseteq># DA0\n  S_M S M (D + negs (mset As)) = {#} \\<and>\n  length As = Suc 0 \\<and>\n  maximal_wrt (As ! 0 \\<cdot>a \\<sigma>)\n   ((D + negs (mset As)) \\<cdot> \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<exists>As0.\n       As0 \\<cdot>al \\<eta>0 = As \\<and>\n       negs (mset As0) \\<subseteq># DA0 \\<and>\n       (S_M S M (D + negs (mset As)) \\<noteq> {#} \\<longrightarrow>\n        negs (mset As0) = S DA0)", "by blast"], ["proof (state)\nthis:\n  \\<exists>As0.\n     As0 \\<cdot>al \\<eta>0 = As \\<and>\n     negs (mset As0) \\<subseteq># DA0 \\<and>\n     (S_M S M (D + negs (mset As)) \\<noteq> {#} \\<longrightarrow>\n      negs (mset As0) = S DA0)\n\ngoal (1 subgoal):\n 1. (\\<And>As0 D0.\n        \\<lbrakk>As0 \\<cdot>al \\<eta>0 = As; length As0 = n;\n         D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n         S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n         negs (mset As0) = S DA0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "}"], ["proof (state)\nthis:\n  S_M S M (D + negs (mset As)) = {#} \\<and>\n  length As = Suc 0 \\<and>\n  maximal_wrt (As ! 0 \\<cdot>a \\<sigma>)\n   ((D + negs (mset As)) \\<cdot> \\<sigma>) \\<Longrightarrow>\n  \\<exists>As0.\n     As0 \\<cdot>al \\<eta>0 = As \\<and>\n     negs (mset As0) \\<subseteq># DA0 \\<and>\n     (S_M S M (D + negs (mset As)) \\<noteq> {#} \\<longrightarrow>\n      negs (mset As0) = S DA0)\n\ngoal (1 subgoal):\n 1. (\\<And>As0 D0.\n        \\<lbrakk>As0 \\<cdot>al \\<eta>0 = As; length As0 = n;\n         D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n         S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n         negs (mset As0) = S DA0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  S_M S M (D + negs (mset As)) = {#} \\<and>\n  length As = Suc 0 \\<and>\n  maximal_wrt (As ! 0 \\<cdot>a \\<sigma>)\n   ((D + negs (mset As)) \\<cdot> \\<sigma>) \\<Longrightarrow>\n  \\<exists>As0.\n     As0 \\<cdot>al \\<eta>0 = As \\<and>\n     negs (mset As0) \\<subseteq># DA0 \\<and>\n     (S_M S M (D + negs (mset As)) \\<noteq> {#} \\<longrightarrow>\n      negs (mset As0) = S DA0)\n\ngoal (1 subgoal):\n 1. (\\<And>As0 D0.\n        \\<lbrakk>As0 \\<cdot>al \\<eta>0 = As; length As0 = n;\n         D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n         S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n         negs (mset As0) = S DA0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "{"], ["proof (state)\nthis:\n  S_M S M (D + negs (mset As)) = {#} \\<and>\n  length As = Suc 0 \\<and>\n  maximal_wrt (As ! 0 \\<cdot>a \\<sigma>)\n   ((D + negs (mset As)) \\<cdot> \\<sigma>) \\<Longrightarrow>\n  \\<exists>As0.\n     As0 \\<cdot>al \\<eta>0 = As \\<and>\n     negs (mset As0) \\<subseteq># DA0 \\<and>\n     (S_M S M (D + negs (mset As)) \\<noteq> {#} \\<longrightarrow>\n      negs (mset As0) = S DA0)\n\ngoal (1 subgoal):\n 1. (\\<And>As0 D0.\n        \\<lbrakk>As0 \\<cdot>al \\<eta>0 = As; length As0 = n;\n         D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n         S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n         negs (mset As0) = S DA0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "assume \"S_M S M (D + negs (mset As)) = negs (mset As)\""], ["proof (state)\nthis:\n  S_M S M (D + negs (mset As)) = negs (mset As)\n\ngoal (1 subgoal):\n 1. (\\<And>As0 D0.\n        \\<lbrakk>As0 \\<cdot>al \\<eta>0 = As; length As0 = n;\n         D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n         S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n         negs (mset As0) = S DA0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  S_M S M (D + negs (mset As)) = negs (mset As)", "have \"negs (mset As) = S DA0 \\<cdot> \\<eta>0\""], ["proof (prove)\nusing this:\n  S_M S M (D + negs (mset As)) = negs (mset As)\n\ngoal (1 subgoal):\n 1. negs (mset As) = S DA0 \\<cdot> \\<eta>0", "using da \\<open>S DA0 \\<cdot> \\<eta>0 = S_M S M DA\\<close>"], ["proof (prove)\nusing this:\n  S_M S M (D + negs (mset As)) = negs (mset As)\n  DA = D + negs (mset As)\n  S DA0 \\<cdot> \\<eta>0 = S_M S M DA\n\ngoal (1 subgoal):\n 1. negs (mset As) = S DA0 \\<cdot> \\<eta>0", "by auto"], ["proof (state)\nthis:\n  negs (mset As) = S DA0 \\<cdot> \\<eta>0\n\ngoal (1 subgoal):\n 1. (\\<And>As0 D0.\n        \\<lbrakk>As0 \\<cdot>al \\<eta>0 = As; length As0 = n;\n         D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n         S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n         negs (mset As0) = S DA0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  negs (mset As) = S DA0 \\<cdot> \\<eta>0", "have \"\\<exists>As0. negs (mset As0) = S DA0 \\<and> As0 \\<cdot>al \\<eta>0 = As\""], ["proof (prove)\nusing this:\n  negs (mset As) = S DA0 \\<cdot> \\<eta>0\n\ngoal (1 subgoal):\n 1. \\<exists>As0. negs (mset As0) = S DA0 \\<and> As0 \\<cdot>al \\<eta>0 = As", "using instance_list[of As \"S DA0\" \\<eta>0] S.S_selects_neg_lits"], ["proof (prove)\nusing this:\n  negs (mset As) = S DA0 \\<cdot> \\<eta>0\n  negs (mset As) = S DA0 \\<cdot> \\<eta>0 \\<Longrightarrow>\n  \\<exists>As'. negs (mset As') = S DA0 \\<and> As' \\<cdot>al \\<eta>0 = As\n  ?L \\<in># S ?C \\<Longrightarrow> is_neg ?L\n\ngoal (1 subgoal):\n 1. \\<exists>As0. negs (mset As0) = S DA0 \\<and> As0 \\<cdot>al \\<eta>0 = As", "by auto"], ["proof (state)\nthis:\n  \\<exists>As0. negs (mset As0) = S DA0 \\<and> As0 \\<cdot>al \\<eta>0 = As\n\ngoal (1 subgoal):\n 1. (\\<And>As0 D0.\n        \\<lbrakk>As0 \\<cdot>al \\<eta>0 = As; length As0 = n;\n         D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n         S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n         negs (mset As0) = S DA0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<exists>As0. negs (mset As0) = S DA0 \\<and> As0 \\<cdot>al \\<eta>0 = As", "have \"\\<exists>As0. As0 \\<cdot>al \\<eta>0 = As \\<and> negs (mset As0) \\<subseteq># DA0\n        \\<and> (S_M S M (D + negs (mset As)) \\<noteq> {#} \\<longrightarrow> negs (mset As0) = S DA0)\""], ["proof (prove)\nusing this:\n  \\<exists>As0. negs (mset As0) = S DA0 \\<and> As0 \\<cdot>al \\<eta>0 = As\n\ngoal (1 subgoal):\n 1. \\<exists>As0.\n       As0 \\<cdot>al \\<eta>0 = As \\<and>\n       negs (mset As0) \\<subseteq># DA0 \\<and>\n       (S_M S M (D + negs (mset As)) \\<noteq> {#} \\<longrightarrow>\n        negs (mset As0) = S DA0)", "using S.S_selects_subseteq"], ["proof (prove)\nusing this:\n  \\<exists>As0. negs (mset As0) = S DA0 \\<and> As0 \\<cdot>al \\<eta>0 = As\n  S ?C \\<subseteq># ?C\n\ngoal (1 subgoal):\n 1. \\<exists>As0.\n       As0 \\<cdot>al \\<eta>0 = As \\<and>\n       negs (mset As0) \\<subseteq># DA0 \\<and>\n       (S_M S M (D + negs (mset As)) \\<noteq> {#} \\<longrightarrow>\n        negs (mset As0) = S DA0)", "by auto"], ["proof (state)\nthis:\n  \\<exists>As0.\n     As0 \\<cdot>al \\<eta>0 = As \\<and>\n     negs (mset As0) \\<subseteq># DA0 \\<and>\n     (S_M S M (D + negs (mset As)) \\<noteq> {#} \\<longrightarrow>\n      negs (mset As0) = S DA0)\n\ngoal (1 subgoal):\n 1. (\\<And>As0 D0.\n        \\<lbrakk>As0 \\<cdot>al \\<eta>0 = As; length As0 = n;\n         D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n         S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n         negs (mset As0) = S DA0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "}"], ["proof (state)\nthis:\n  S_M S M (D + negs (mset As)) = negs (mset As) \\<Longrightarrow>\n  \\<exists>As0.\n     As0 \\<cdot>al \\<eta>0 = As \\<and>\n     negs (mset As0) \\<subseteq># DA0 \\<and>\n     (S_M S M (D + negs (mset As)) \\<noteq> {#} \\<longrightarrow>\n      negs (mset As0) = S DA0)\n\ngoal (1 subgoal):\n 1. (\\<And>As0 D0.\n        \\<lbrakk>As0 \\<cdot>al \\<eta>0 = As; length As0 = n;\n         D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n         S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n         negs (mset As0) = S DA0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  S_M S M (D + negs (mset As)) = {#} \\<and>\n  length As = Suc 0 \\<and>\n  maximal_wrt (As ! 0 \\<cdot>a \\<sigma>)\n   ((D + negs (mset As)) \\<cdot> \\<sigma>) \\<Longrightarrow>\n  \\<exists>As0.\n     As0 \\<cdot>al \\<eta>0 = As \\<and>\n     negs (mset As0) \\<subseteq># DA0 \\<and>\n     (S_M S M (D + negs (mset As)) \\<noteq> {#} \\<longrightarrow>\n      negs (mset As0) = S DA0)\n  S_M S M (D + negs (mset As)) = negs (mset As) \\<Longrightarrow>\n  \\<exists>As0.\n     As0 \\<cdot>al \\<eta>0 = As \\<and>\n     negs (mset As0) \\<subseteq># DA0 \\<and>\n     (S_M S M (D + negs (mset As)) \\<noteq> {#} \\<longrightarrow>\n      negs (mset As0) = S DA0)", "have \"\\<exists>As0. As0 \\<cdot>al \\<eta>0 = As \\<and> (negs (mset As0)) \\<subseteq># DA0\n      \\<and> (S_M S M (D + negs (mset As)) \\<noteq> {#} \\<longrightarrow> negs (mset As0) = S DA0)\""], ["proof (prove)\nusing this:\n  S_M S M (D + negs (mset As)) = {#} \\<and>\n  length As = Suc 0 \\<and>\n  maximal_wrt (As ! 0 \\<cdot>a \\<sigma>)\n   ((D + negs (mset As)) \\<cdot> \\<sigma>) \\<Longrightarrow>\n  \\<exists>As0.\n     As0 \\<cdot>al \\<eta>0 = As \\<and>\n     negs (mset As0) \\<subseteq># DA0 \\<and>\n     (S_M S M (D + negs (mset As)) \\<noteq> {#} \\<longrightarrow>\n      negs (mset As0) = S DA0)\n  S_M S M (D + negs (mset As)) = negs (mset As) \\<Longrightarrow>\n  \\<exists>As0.\n     As0 \\<cdot>al \\<eta>0 = As \\<and>\n     negs (mset As0) \\<subseteq># DA0 \\<and>\n     (S_M S M (D + negs (mset As)) \\<noteq> {#} \\<longrightarrow>\n      negs (mset As0) = S DA0)\n\ngoal (1 subgoal):\n 1. \\<exists>As0.\n       As0 \\<cdot>al \\<eta>0 = As \\<and>\n       negs (mset As0) \\<subseteq># DA0 \\<and>\n       (S_M S M (D + negs (mset As)) \\<noteq> {#} \\<longrightarrow>\n        negs (mset As0) = S DA0)", "using eligible"], ["proof (prove)\nusing this:\n  S_M S M (D + negs (mset As)) = {#} \\<and>\n  length As = Suc 0 \\<and>\n  maximal_wrt (As ! 0 \\<cdot>a \\<sigma>)\n   ((D + negs (mset As)) \\<cdot> \\<sigma>) \\<Longrightarrow>\n  \\<exists>As0.\n     As0 \\<cdot>al \\<eta>0 = As \\<and>\n     negs (mset As0) \\<subseteq># DA0 \\<and>\n     (S_M S M (D + negs (mset As)) \\<noteq> {#} \\<longrightarrow>\n      negs (mset As0) = S DA0)\n  S_M S M (D + negs (mset As)) = negs (mset As) \\<Longrightarrow>\n  \\<exists>As0.\n     As0 \\<cdot>al \\<eta>0 = As \\<and>\n     negs (mset As0) \\<subseteq># DA0 \\<and>\n     (S_M S M (D + negs (mset As)) \\<noteq> {#} \\<longrightarrow>\n      negs (mset As0) = S DA0)\n  eligible (S_M S M) \\<sigma> As (D + negs (mset As))\n\ngoal (1 subgoal):\n 1. \\<exists>As0.\n       As0 \\<cdot>al \\<eta>0 = As \\<and>\n       negs (mset As0) \\<subseteq># DA0 \\<and>\n       (S_M S M (D + negs (mset As)) \\<noteq> {#} \\<longrightarrow>\n        negs (mset As0) = S DA0)", "unfolding eligible.simps"], ["proof (prove)\nusing this:\n  S_M S M (D + negs (mset As)) = {#} \\<and>\n  length As = Suc 0 \\<and>\n  maximal_wrt (As ! 0 \\<cdot>a \\<sigma>)\n   ((D + negs (mset As)) \\<cdot> \\<sigma>) \\<Longrightarrow>\n  \\<exists>As0.\n     As0 \\<cdot>al \\<eta>0 = As \\<and>\n     negs (mset As0) \\<subseteq># DA0 \\<and>\n     (S_M S M (D + negs (mset As)) \\<noteq> {#} \\<longrightarrow>\n      negs (mset As0) = S DA0)\n  S_M S M (D + negs (mset As)) = negs (mset As) \\<Longrightarrow>\n  \\<exists>As0.\n     As0 \\<cdot>al \\<eta>0 = As \\<and>\n     negs (mset As0) \\<subseteq># DA0 \\<and>\n     (S_M S M (D + negs (mset As)) \\<noteq> {#} \\<longrightarrow>\n      negs (mset As0) = S DA0)\n  \\<exists>DA Asa \\<sigma>'.\n     \\<sigma> = \\<sigma>' \\<and>\n     As = Asa \\<and>\n     D + negs (mset As) = DA \\<and>\n     (S_M S M DA = negs (mset Asa) \\<or>\n      S_M S M DA = {#} \\<and>\n      length Asa = 1 \\<and>\n      maximal_wrt (Asa ! 0 \\<cdot>a \\<sigma>') (DA \\<cdot> \\<sigma>'))\n\ngoal (1 subgoal):\n 1. \\<exists>As0.\n       As0 \\<cdot>al \\<eta>0 = As \\<and>\n       negs (mset As0) \\<subseteq># DA0 \\<and>\n       (S_M S M (D + negs (mset As)) \\<noteq> {#} \\<longrightarrow>\n        negs (mset As0) = S DA0)", "by auto"], ["proof (state)\nthis:\n  \\<exists>As0.\n     As0 \\<cdot>al \\<eta>0 = As \\<and>\n     negs (mset As0) \\<subseteq># DA0 \\<and>\n     (S_M S M (D + negs (mset As)) \\<noteq> {#} \\<longrightarrow>\n      negs (mset As0) = S DA0)\n\ngoal (1 subgoal):\n 1. (\\<And>As0 D0.\n        \\<lbrakk>As0 \\<cdot>al \\<eta>0 = As; length As0 = n;\n         D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n         S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n         negs (mset As0) = S DA0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<exists>As0.\n     As0 \\<cdot>al \\<eta>0 = As \\<and>\n     negs (mset As0) \\<subseteq># DA0 \\<and>\n     (S_M S M (D + negs (mset As)) \\<noteq> {#} \\<longrightarrow>\n      negs (mset As0) = S DA0)", "obtain As0 where\n      As0_p: \"As0 \\<cdot>al \\<eta>0 = As \\<and> negs (mset As0) \\<subseteq># DA0\n      \\<and> (S_M S M (D + negs (mset As)) \\<noteq> {#} \\<longrightarrow> negs (mset As0) = S DA0)\""], ["proof (prove)\nusing this:\n  \\<exists>As0.\n     As0 \\<cdot>al \\<eta>0 = As \\<and>\n     negs (mset As0) \\<subseteq># DA0 \\<and>\n     (S_M S M (D + negs (mset As)) \\<noteq> {#} \\<longrightarrow>\n      negs (mset As0) = S DA0)\n\ngoal (1 subgoal):\n 1. (\\<And>As0.\n        As0 \\<cdot>al \\<eta>0 = As \\<and>\n        negs (mset As0) \\<subseteq># DA0 \\<and>\n        (S_M S M (D + negs (mset As)) \\<noteq> {#} \\<longrightarrow>\n         negs (mset As0) = S DA0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  As0 \\<cdot>al \\<eta>0 = As \\<and>\n  negs (mset As0) \\<subseteq># DA0 \\<and>\n  (S_M S M (D + negs (mset As)) \\<noteq> {#} \\<longrightarrow>\n   negs (mset As0) = S DA0)\n\ngoal (1 subgoal):\n 1. (\\<And>As0 D0.\n        \\<lbrakk>As0 \\<cdot>al \\<eta>0 = As; length As0 = n;\n         D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n         S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n         negs (mset As0) = S DA0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  As0 \\<cdot>al \\<eta>0 = As \\<and>\n  negs (mset As0) \\<subseteq># DA0 \\<and>\n  (S_M S M (D + negs (mset As)) \\<noteq> {#} \\<longrightarrow>\n   negs (mset As0) = S DA0)", "have \"length As0 = n\""], ["proof (prove)\nusing this:\n  As0 \\<cdot>al \\<eta>0 = As \\<and>\n  negs (mset As0) \\<subseteq># DA0 \\<and>\n  (S_M S M (D + negs (mset As)) \\<noteq> {#} \\<longrightarrow>\n   negs (mset As0) = S DA0)\n\ngoal (1 subgoal):\n 1. length As0 = n", "using as_len"], ["proof (prove)\nusing this:\n  As0 \\<cdot>al \\<eta>0 = As \\<and>\n  negs (mset As0) \\<subseteq># DA0 \\<and>\n  (S_M S M (D + negs (mset As)) \\<noteq> {#} \\<longrightarrow>\n   negs (mset As0) = S DA0)\n  length As = n\n\ngoal (1 subgoal):\n 1. length As0 = n", "by auto"], ["proof (state)\nthis:\n  length As0 = n\n\ngoal (1 subgoal):\n 1. (\\<And>As0 D0.\n        \\<lbrakk>As0 \\<cdot>al \\<eta>0 = As; length As0 = n;\n         D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n         S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n         negs (mset As0) = S DA0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note n = n this"], ["proof (state)\nthis:\n  length \\<eta>s0 = n\n  length CAs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length As0 = n\n\ngoal (1 subgoal):\n 1. (\\<And>As0 D0.\n        \\<lbrakk>As0 \\<cdot>al \\<eta>0 = As; length As0 = n;\n         D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n         S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n         negs (mset As0) = S DA0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"As0 \\<cdot>al \\<eta>0 = As\""], ["proof (prove)\ngoal (1 subgoal):\n 1. As0 \\<cdot>al \\<eta>0 = As", "using As0_p"], ["proof (prove)\nusing this:\n  As0 \\<cdot>al \\<eta>0 = As \\<and>\n  negs (mset As0) \\<subseteq># DA0 \\<and>\n  (S_M S M (D + negs (mset As)) \\<noteq> {#} \\<longrightarrow>\n   negs (mset As0) = S DA0)\n\ngoal (1 subgoal):\n 1. As0 \\<cdot>al \\<eta>0 = As", "by auto"], ["proof (state)\nthis:\n  As0 \\<cdot>al \\<eta>0 = As\n\ngoal (1 subgoal):\n 1. (\\<And>As0 D0.\n        \\<lbrakk>As0 \\<cdot>al \\<eta>0 = As; length As0 = n;\n         D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n         S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n         negs (mset As0) = S DA0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define D0 where\n      \"D0 = DA0 - negs (mset As0)\""], ["proof (state)\nthis:\n  D0 = DA0 - negs (mset As0)\n\ngoal (1 subgoal):\n 1. (\\<And>As0 D0.\n        \\<lbrakk>As0 \\<cdot>al \\<eta>0 = As; length As0 = n;\n         D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n         S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n         negs (mset As0) = S DA0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  D0 = DA0 - negs (mset As0)", "have \"DA0 = D0 + negs (mset As0)\""], ["proof (prove)\nusing this:\n  D0 = DA0 - negs (mset As0)\n\ngoal (1 subgoal):\n 1. DA0 = D0 + negs (mset As0)", "using As0_p"], ["proof (prove)\nusing this:\n  D0 = DA0 - negs (mset As0)\n  As0 \\<cdot>al \\<eta>0 = As \\<and>\n  negs (mset As0) \\<subseteq># DA0 \\<and>\n  (S_M S M (D + negs (mset As)) \\<noteq> {#} \\<longrightarrow>\n   negs (mset As0) = S DA0)\n\ngoal (1 subgoal):\n 1. DA0 = D0 + negs (mset As0)", "by auto"], ["proof (state)\nthis:\n  DA0 = D0 + negs (mset As0)\n\ngoal (1 subgoal):\n 1. (\\<And>As0 D0.\n        \\<lbrakk>As0 \\<cdot>al \\<eta>0 = As; length As0 = n;\n         D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n         S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n         negs (mset As0) = S DA0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  DA0 = D0 + negs (mset As0)", "have \"D0 \\<cdot> \\<eta>0 = D\""], ["proof (prove)\nusing this:\n  DA0 = D0 + negs (mset As0)\n\ngoal (1 subgoal):\n 1. D0 \\<cdot> \\<eta>0 = D", "using DA0_to_DA da As0_p"], ["proof (prove)\nusing this:\n  DA0 = D0 + negs (mset As0)\n  DA0 \\<cdot> \\<eta>0 = DA\n  DA = D + negs (mset As)\n  As0 \\<cdot>al \\<eta>0 = As \\<and>\n  negs (mset As0) \\<subseteq># DA0 \\<and>\n  (S_M S M (D + negs (mset As)) \\<noteq> {#} \\<longrightarrow>\n   negs (mset As0) = S DA0)\n\ngoal (1 subgoal):\n 1. D0 \\<cdot> \\<eta>0 = D", "by auto"], ["proof (state)\nthis:\n  D0 \\<cdot> \\<eta>0 = D\n\ngoal (1 subgoal):\n 1. (\\<And>As0 D0.\n        \\<lbrakk>As0 \\<cdot>al \\<eta>0 = As; length As0 = n;\n         D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n         S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n         negs (mset As0) = S DA0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow> negs (mset As0) = S DA0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n    negs (mset As0) = S DA0", "using As0_p"], ["proof (prove)\nusing this:\n  As0 \\<cdot>al \\<eta>0 = As \\<and>\n  negs (mset As0) \\<subseteq># DA0 \\<and>\n  (S_M S M (D + negs (mset As)) \\<noteq> {#} \\<longrightarrow>\n   negs (mset As0) = S DA0)\n\ngoal (1 subgoal):\n 1. S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n    negs (mset As0) = S DA0", "by blast"], ["proof (state)\nthis:\n  S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n  negs (mset As0) = S DA0\n\ngoal (1 subgoal):\n 1. (\\<And>As0 D0.\n        \\<lbrakk>As0 \\<cdot>al \\<eta>0 = As; length As0 = n;\n         D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n         S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n         negs (mset As0) = S DA0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n  negs (mset As0) = S DA0", "show ?thesis"], ["proof (prove)\nusing this:\n  S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n  negs (mset As0) = S DA0\n\ngoal (1 subgoal):\n 1. thesis", "using that \\<open>As0 \\<cdot>al \\<eta>0 = As\\<close> \\<open>D0 \\<cdot> \\<eta>0= D\\<close> \\<open>DA0 = D0 +  (negs (mset As0))\\<close> \\<open>length As0 = n\\<close>"], ["proof (prove)\nusing this:\n  S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n  negs (mset As0) = S DA0\n  \\<lbrakk>?As0.0 \\<cdot>al \\<eta>0 = As; length ?As0.0 = n;\n   ?D0.0 \\<cdot> \\<eta>0 = D; DA0 = ?D0.0 + negs (mset ?As0.0);\n   S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n   negs (mset ?As0.0) = S DA0\\<rbrakk>\n  \\<Longrightarrow> thesis\n  As0 \\<cdot>al \\<eta>0 = As\n  D0 \\<cdot> \\<eta>0 = D\n  DA0 = D0 + negs (mset As0)\n  length As0 = n\n\ngoal (1 subgoal):\n 1. thesis", "by metis"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  As0 \\<cdot>al \\<eta>0 = As\n  length As0 = n\n  D0 \\<cdot> \\<eta>0 = D\n  DA0 = D0 + negs (mset As0)\n  S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n  negs (mset As0) = S DA0\n\ngoal (1 subgoal):\n 1. \\<And>na Csa Da.\n       \\<lbrakk>\\<And>CAs0 \\<eta>s0 DA0 \\<eta>0 As0 AAs0 D0 Cs0.\n                   \\<lbrakk>length CAs0 = n; length \\<eta>s0 = n;\n                    DA0 \\<in> M; DA0 \\<cdot> \\<eta>0 = DA;\n                    S DA0 \\<cdot> \\<eta>0 = S_M S M DA;\n                    \\<forall>CA0\\<in>set CAs0. CA0 \\<in> M;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs;\n                    map S CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 =\n                    map (S_M S M) CAs;\n                    is_ground_subst \\<eta>0; is_ground_subst_list \\<eta>s0;\n                    As0 \\<cdot>al \\<eta>0 = As;\n                    AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs; length As0 = n;\n                    D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n                    S_M S M (D + negs (mset As)) \\<noteq>\n                    {#} \\<Longrightarrow>\n                    negs (mset As0) = S DA0;\n                    length Cs0 = n; Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n                    \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n                    length AAs0 = n\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = Da + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Csa) + Da) \\<cdot> \\<sigma>;\n        length CAs = na; length Csa = na; length AAs = na; length As = na;\n        na \\<noteq> 0; \\<forall>i<na. CAs ! i = Csa ! i + poss (AAs ! i);\n        \\<forall>i<na. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (Da + negs (mset As));\n        \\<forall>i<na.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Csa ! i \\<cdot> \\<sigma>);\n        \\<forall>i<na. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using that[OF n(2,1) DA0_in_M  DA0_to_DA SDA0_to_SMDA CAs0_in_M CAs0_to_CAs SCAs0_to_SMCAs\n        \\<open>is_ground_subst \\<eta>0\\<close> \\<open>is_ground_subst_list \\<eta>s0\\<close> \\<open>As0  \\<cdot>al \\<eta>0 = As\\<close>\n        \\<open>AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs\\<close>\n        \\<open>length As0 = n\\<close>\n        \\<open>D0 \\<cdot> \\<eta>0 = D\\<close>\n        \\<open>DA0 = D0 + (negs (mset As0))\\<close>\n        \\<open>S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow> negs (mset As0) = S DA0\\<close>\n        \\<open>length Cs0 = n\\<close>\n        \\<open>Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs\\<close>\n        \\<open>\\<forall>i < n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i)\\<close>\n        \\<open>length AAs0 = n\\<close>]"], ["proof (prove)\nusing this:\n  (S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n   S_M S M (D + negs (mset As)) \\<noteq> {#}) \\<Longrightarrow>\n  thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ord_resolve_rename_lifting:\n  assumes\n    sel_stable: \"\\<And>\\<rho> C. is_renaming \\<rho> \\<Longrightarrow> S (C \\<cdot> \\<rho>) = S C \\<cdot> \\<rho>\" and\n    res_e: \"ord_resolve (S_M S M) CAs DA AAs As \\<sigma> E\" and\n    select: \"selection S\" and\n    grounding: \"{DA} \\<union> set CAs \\<subseteq> grounding_of_clss M\"\n  obtains \\<eta>s \\<eta> \\<eta>2 CAs0 DA0 AAs0 As0 E0 \\<tau> where\n    \"is_ground_subst \\<eta>\"\n    \"is_ground_subst_list \\<eta>s\"\n    \"is_ground_subst \\<eta>2\"\n    \"ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0\"\n    \"CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs\" \"DA0 \\<cdot> \\<eta> = DA\" \"E0 \\<cdot> \\<eta>2 = E\"\n    \"{DA0} \\<union> set CAs0 \\<subseteq> M\"\n    \"length CAs0 = length CAs\"\n    \"length \\<eta>s = length CAs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n        \\<lbrakk>is_ground_subst \\<eta>; is_ground_subst_list \\<eta>s;\n         is_ground_subst \\<eta>2;\n         ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n         CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs; DA0 \\<cdot> \\<eta> = DA;\n         E0 \\<cdot> \\<eta>2 = E; {DA0} \\<union> set CAs0 \\<subseteq> M;\n         length CAs0 = length CAs; length \\<eta>s = length CAs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using res_e"], ["proof (prove)\nusing this:\n  ord_resolve (S_M S M) CAs DA AAs As \\<sigma> E\n\ngoal (1 subgoal):\n 1. (\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n        \\<lbrakk>is_ground_subst \\<eta>; is_ground_subst_list \\<eta>s;\n         is_ground_subst \\<eta>2;\n         ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n         CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs; DA0 \\<cdot> \\<eta> = DA;\n         E0 \\<cdot> \\<eta>2 = E; {DA0} \\<union> set CAs0 \\<subseteq> M;\n         length CAs0 = length CAs; length \\<eta>s = length CAs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (cases rule: ord_resolve.cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (ord_resolve n Cs D)"], ["proof (state)\nthis:\n  DA = D + negs (mset As)\n  E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  n \\<noteq> 0\n  \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i)\n  \\<forall>i<n. AAs ! i \\<noteq> {#}\n  Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs))\n  eligible (S_M S M) \\<sigma> As (D + negs (mset As))\n  \\<forall>i<n.\n     strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n      (Cs ! i \\<cdot> \\<sigma>)\n  \\<forall>i<n. S_M S M (CAs ! i) = {#}\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "note da = this(1) and e = this(2) and cas_len = this(3) and cs_len = this(4) and\n    aas_len = this(5) and as_len = this(6) and nz = this(7) and cas = this(8) and\n    aas_not_empt = this(9) and mgu = this(10) and eligible = this(11) and str_max = this(12) and\n    sel_empt = this(13)"], ["proof (state)\nthis:\n  DA = D + negs (mset As)\n  E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  n \\<noteq> 0\n  \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i)\n  \\<forall>i<n. AAs ! i \\<noteq> {#}\n  Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs))\n  eligible (S_M S M) \\<sigma> As (D + negs (mset As))\n  \\<forall>i<n.\n     strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n      (Cs ! i \\<cdot> \\<sigma>)\n  \\<forall>i<n. S_M S M (CAs ! i) = {#}\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have sel_ren_list_inv:\n    \"\\<And>\\<rho>s Cs. length \\<rho>s = length Cs \\<Longrightarrow> is_renaming_list \\<rho>s \\<Longrightarrow> map S (Cs \\<cdot>\\<cdot>cl \\<rho>s) = map S Cs \\<cdot>\\<cdot>cl \\<rho>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<rho>s Cs.\n       \\<lbrakk>length \\<rho>s = length Cs;\n        is_renaming_list \\<rho>s\\<rbrakk>\n       \\<Longrightarrow> map S (Cs \\<cdot>\\<cdot>cl \\<rho>s) =\n                         map S Cs \\<cdot>\\<cdot>cl \\<rho>s", "using sel_stable"], ["proof (prove)\nusing this:\n  is_renaming ?\\<rho> \\<Longrightarrow>\n  S (?C \\<cdot> ?\\<rho>) = S ?C \\<cdot> ?\\<rho>\n\ngoal (1 subgoal):\n 1. \\<And>\\<rho>s Cs.\n       \\<lbrakk>length \\<rho>s = length Cs;\n        is_renaming_list \\<rho>s\\<rbrakk>\n       \\<Longrightarrow> map S (Cs \\<cdot>\\<cdot>cl \\<rho>s) =\n                         map S Cs \\<cdot>\\<cdot>cl \\<rho>s", "unfolding is_renaming_list_def"], ["proof (prove)\nusing this:\n  is_renaming ?\\<rho> \\<Longrightarrow>\n  S (?C \\<cdot> ?\\<rho>) = S ?C \\<cdot> ?\\<rho>\n\ngoal (1 subgoal):\n 1. \\<And>\\<rho>s Cs.\n       \\<lbrakk>length \\<rho>s = length Cs;\n        Ball (set \\<rho>s) is_renaming\\<rbrakk>\n       \\<Longrightarrow> map S (Cs \\<cdot>\\<cdot>cl \\<rho>s) =\n                         map S Cs \\<cdot>\\<cdot>cl \\<rho>s", "by (auto intro: nth_equalityI)"], ["proof (state)\nthis:\n  \\<lbrakk>length ?\\<rho>s = length ?Cs; is_renaming_list ?\\<rho>s\\<rbrakk>\n  \\<Longrightarrow> map S (?Cs \\<cdot>\\<cdot>cl ?\\<rho>s) =\n                    map S ?Cs \\<cdot>\\<cdot>cl ?\\<rho>s\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "note n = \\<open>n \\<noteq> 0\\<close> \\<open>length CAs = n\\<close> \\<open>length Cs = n\\<close> \\<open>length AAs = n\\<close> \\<open>length As = n\\<close>"], ["proof (state)\nthis:\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "interpret S: selection S"], ["proof (prove)\ngoal (1 subgoal):\n 1. selection S", "by (rule select)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain DA0 \\<eta>0 CAs0 \\<eta>s0 As0 AAs0 D0 Cs0 where as0:\n    \"length CAs0 = n\"\n    \"length \\<eta>s0 = n\"\n    \"DA0 \\<in> M\"\n    \"DA0 \\<cdot> \\<eta>0 = DA\"\n    \"S DA0 \\<cdot> \\<eta>0 = S_M S M DA\"\n    \"\\<forall>CA0 \\<in> set CAs0. CA0 \\<in> M\"\n    \"CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs\"\n    \"map S CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = map (S_M S M) CAs\"\n    \"is_ground_subst \\<eta>0\"\n    \"is_ground_subst_list \\<eta>s0\"\n    \"As0 \\<cdot>al \\<eta>0 = As\"\n    \"AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs\"\n    \"length As0 = n\"\n    \"D0 \\<cdot> \\<eta>0 = D\"\n    \"DA0 = D0 + (negs (mset As0))\"\n    \"S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow> negs (mset As0) = S DA0\"\n    \"length Cs0 = n\"\n    \"Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs\"\n    \"\\<forall>i < n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i)\"\n    \"length AAs0 = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>CAs0 \\<eta>s0 DA0 \\<eta>0 As0 AAs0 D0 Cs0.\n        \\<lbrakk>length CAs0 = n; length \\<eta>s0 = n; DA0 \\<in> M;\n         DA0 \\<cdot> \\<eta>0 = DA; S DA0 \\<cdot> \\<eta>0 = S_M S M DA;\n         \\<forall>CA0\\<in>set CAs0. CA0 \\<in> M;\n         CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs;\n         map S CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = map (S_M S M) CAs;\n         is_ground_subst \\<eta>0; is_ground_subst_list \\<eta>s0;\n         As0 \\<cdot>al \\<eta>0 = As; AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs;\n         length As0 = n; D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n         S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n         negs (mset As0) = S DA0;\n         length Cs0 = n; Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n         \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n         length AAs0 = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ord_resolve_obtain_clauses[of S M CAs DA, OF res_e select grounding n(2) \\<open>DA = D + negs (mset As)\\<close>\n      \\<open>\\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i)\\<close> \\<open>length Cs = n\\<close> \\<open>length AAs = n\\<close>, of thesis]"], ["proof (prove)\nusing this:\n  (\\<And>DA0 \\<eta>0 CAs0 \\<eta>s0 As0 AAs0 D0 Cs0.\n      \\<lbrakk>length CAs0 = n; length \\<eta>s0 = n; DA0 \\<in> M;\n       DA0 \\<cdot> \\<eta>0 = DA; S DA0 \\<cdot> \\<eta>0 = S_M S M DA;\n       \\<forall>CA0\\<in>set CAs0. CA0 \\<in> M;\n       CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs;\n       map S CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = map (S_M S M) CAs;\n       is_ground_subst \\<eta>0; is_ground_subst_list \\<eta>s0;\n       As0 \\<cdot>al \\<eta>0 = As; AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs;\n       length As0 = n; D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n       S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n       negs (mset As0) = S DA0;\n       length Cs0 = n; Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n       \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n       length AAs0 = n\\<rbrakk>\n      \\<Longrightarrow> thesis) \\<Longrightarrow>\n  thesis\n\ngoal (1 subgoal):\n 1. (\\<And>CAs0 \\<eta>s0 DA0 \\<eta>0 As0 AAs0 D0 Cs0.\n        \\<lbrakk>length CAs0 = n; length \\<eta>s0 = n; DA0 \\<in> M;\n         DA0 \\<cdot> \\<eta>0 = DA; S DA0 \\<cdot> \\<eta>0 = S_M S M DA;\n         \\<forall>CA0\\<in>set CAs0. CA0 \\<in> M;\n         CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs;\n         map S CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = map (S_M S M) CAs;\n         is_ground_subst \\<eta>0; is_ground_subst_list \\<eta>s0;\n         As0 \\<cdot>al \\<eta>0 = As; AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs;\n         length As0 = n; D0 \\<cdot> \\<eta>0 = D; DA0 = D0 + negs (mset As0);\n         S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n         negs (mset As0) = S DA0;\n         length Cs0 = n; Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs;\n         \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i);\n         length AAs0 = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  length CAs0 = n\n  length \\<eta>s0 = n\n  DA0 \\<in> M\n  DA0 \\<cdot> \\<eta>0 = DA\n  S DA0 \\<cdot> \\<eta>0 = S_M S M DA\n  \\<forall>CA0\\<in>set CAs0. CA0 \\<in> M\n  CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs\n  map S CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = map (S_M S M) CAs\n  is_ground_subst \\<eta>0\n  is_ground_subst_list \\<eta>s0\n  As0 \\<cdot>al \\<eta>0 = As\n  AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs\n  length As0 = n\n  D0 \\<cdot> \\<eta>0 = D\n  DA0 = D0 + negs (mset As0)\n  S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n  negs (mset As0) = S DA0\n  length Cs0 = n\n  Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs\n  \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i)\n  length AAs0 = n\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "note n = \\<open>length CAs0 = n\\<close> \\<open>length \\<eta>s0 = n\\<close> \\<open>length As0 = n\\<close> \\<open>length AAs0 = n\\<close> \\<open>length Cs0 = n\\<close> n"], ["proof (state)\nthis:\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"length (renamings_apart (DA0 # CAs0)) = Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (renamings_apart (DA0 # CAs0)) = Suc n", "using n renamings_apart_length"], ["proof (prove)\nusing this:\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length (renamings_apart ?Cs) = length ?Cs\n\ngoal (1 subgoal):\n 1. length (renamings_apart (DA0 # CAs0)) = Suc n", "by auto"], ["proof (state)\nthis:\n  length (renamings_apart (DA0 # CAs0)) = Suc n\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "note n = this n"], ["proof (state)\nthis:\n  length (renamings_apart (DA0 # CAs0)) = Suc n\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "define \\<rho> where\n    \"\\<rho> = hd (renamings_apart (DA0 # CAs0))\""], ["proof (state)\nthis:\n  \\<rho> = hd (renamings_apart (DA0 # CAs0))\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "define \\<rho>s where\n    \"\\<rho>s = tl (renamings_apart (DA0 # CAs0))\""], ["proof (state)\nthis:\n  \\<rho>s = tl (renamings_apart (DA0 # CAs0))\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "define DA0' where\n    \"DA0' = DA0 \\<cdot> \\<rho>\""], ["proof (state)\nthis:\n  DA0' = DA0 \\<cdot> \\<rho>\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "define D0' where\n    \"D0' = D0 \\<cdot> \\<rho>\""], ["proof (state)\nthis:\n  D0' = D0 \\<cdot> \\<rho>\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "define As0' where\n    \"As0' = As0 \\<cdot>al \\<rho>\""], ["proof (state)\nthis:\n  As0' = As0 \\<cdot>al \\<rho>\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "define CAs0' where\n    \"CAs0' = CAs0 \\<cdot>\\<cdot>cl \\<rho>s\""], ["proof (state)\nthis:\n  CAs0' = CAs0 \\<cdot>\\<cdot>cl \\<rho>s\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "define Cs0' where\n    \"Cs0' = Cs0 \\<cdot>\\<cdot>cl \\<rho>s\""], ["proof (state)\nthis:\n  Cs0' = Cs0 \\<cdot>\\<cdot>cl \\<rho>s\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "define AAs0' where\n    \"AAs0' = AAs0 \\<cdot>\\<cdot>aml \\<rho>s\""], ["proof (state)\nthis:\n  AAs0' = AAs0 \\<cdot>\\<cdot>aml \\<rho>s\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "define \\<eta>0' where\n    \"\\<eta>0' = inv_renaming \\<rho> \\<odot> \\<eta>0\""], ["proof (state)\nthis:\n  \\<eta>0' = inv_renaming \\<rho> \\<odot> \\<eta>0\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "define \\<eta>s0' where\n    \"\\<eta>s0' = map inv_renaming \\<rho>s \\<odot>s \\<eta>s0\""], ["proof (state)\nthis:\n  \\<eta>s0' = map inv_renaming \\<rho>s \\<odot>s \\<eta>s0\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have renames_DA0: \"is_renaming \\<rho>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_renaming \\<rho>", "using renamings_apart_length renamings_apart_renaming"], ["proof (prove)\nusing this:\n  length (renamings_apart ?Cs) = length ?Cs\n  ?\\<rho> \\<in> set (renamings_apart ?Cs) \\<Longrightarrow>\n  is_renaming ?\\<rho>\n\ngoal (1 subgoal):\n 1. is_renaming \\<rho>", "unfolding \\<rho>_def"], ["proof (prove)\nusing this:\n  length (renamings_apart ?Cs) = length ?Cs\n  ?\\<rho> \\<in> set (renamings_apart ?Cs) \\<Longrightarrow>\n  is_renaming ?\\<rho>\n\ngoal (1 subgoal):\n 1. is_renaming (hd (renamings_apart (DA0 # CAs0)))", "by (metis length_greater_0_conv list.exhaust_sel list.set_intros(1) list.simps(3))"], ["proof (state)\nthis:\n  is_renaming \\<rho>\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have renames_CAs0: \"is_renaming_list \\<rho>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_renaming_list \\<rho>s", "using renamings_apart_length renamings_apart_renaming"], ["proof (prove)\nusing this:\n  length (renamings_apart ?Cs) = length ?Cs\n  ?\\<rho> \\<in> set (renamings_apart ?Cs) \\<Longrightarrow>\n  is_renaming ?\\<rho>\n\ngoal (1 subgoal):\n 1. is_renaming_list \\<rho>s", "unfolding \\<rho>s_def"], ["proof (prove)\nusing this:\n  length (renamings_apart ?Cs) = length ?Cs\n  ?\\<rho> \\<in> set (renamings_apart ?Cs) \\<Longrightarrow>\n  is_renaming ?\\<rho>\n\ngoal (1 subgoal):\n 1. is_renaming_list (tl (renamings_apart (DA0 # CAs0)))", "by (metis is_renaming_list_def length_greater_0_conv list.set_sel(2) list.simps(3))"], ["proof (state)\nthis:\n  is_renaming_list \\<rho>s\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"length \\<rho>s = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length \\<rho>s = n", "unfolding \\<rho>s_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (tl (renamings_apart (DA0 # CAs0))) = n", "using n"], ["proof (prove)\nusing this:\n  length (renamings_apart (DA0 # CAs0)) = Suc n\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n\ngoal (1 subgoal):\n 1. length (tl (renamings_apart (DA0 # CAs0))) = n", "by auto"], ["proof (state)\nthis:\n  length \\<rho>s = n\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "note n = n \\<open>length \\<rho>s = n\\<close>"], ["proof (state)\nthis:\n  length (renamings_apart (DA0 # CAs0)) = Suc n\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length \\<rho>s = n\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"length As0' = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length As0' = n", "unfolding As0'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (As0 \\<cdot>al \\<rho>) = n", "using n"], ["proof (prove)\nusing this:\n  length (renamings_apart (DA0 # CAs0)) = Suc n\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length \\<rho>s = n\n\ngoal (1 subgoal):\n 1. length (As0 \\<cdot>al \\<rho>) = n", "by auto"], ["proof (state)\nthis:\n  length As0' = n\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"length CAs0' = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length CAs0' = n", "using as0(1) n"], ["proof (prove)\nusing this:\n  length CAs0 = n\n  length (renamings_apart (DA0 # CAs0)) = Suc n\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length \\<rho>s = n\n\ngoal (1 subgoal):\n 1. length CAs0' = n", "unfolding CAs0'_def"], ["proof (prove)\nusing this:\n  length CAs0 = n\n  length (renamings_apart (DA0 # CAs0)) = Suc n\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length \\<rho>s = n\n\ngoal (1 subgoal):\n 1. length (CAs0 \\<cdot>\\<cdot>cl \\<rho>s) = n", "by auto"], ["proof (state)\nthis:\n  length CAs0' = n\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"length Cs0' = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length Cs0' = n", "unfolding Cs0'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (Cs0 \\<cdot>\\<cdot>cl \\<rho>s) = n", "using n"], ["proof (prove)\nusing this:\n  length (renamings_apart (DA0 # CAs0)) = Suc n\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length \\<rho>s = n\n\ngoal (1 subgoal):\n 1. length (Cs0 \\<cdot>\\<cdot>cl \\<rho>s) = n", "by auto"], ["proof (state)\nthis:\n  length Cs0' = n\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"length AAs0' = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length AAs0' = n", "unfolding AAs0'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (AAs0 \\<cdot>\\<cdot>aml \\<rho>s) = n", "using n"], ["proof (prove)\nusing this:\n  length (renamings_apart (DA0 # CAs0)) = Suc n\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length \\<rho>s = n\n\ngoal (1 subgoal):\n 1. length (AAs0 \\<cdot>\\<cdot>aml \\<rho>s) = n", "by auto"], ["proof (state)\nthis:\n  length AAs0' = n\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"length \\<eta>s0' = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length \\<eta>s0' = n", "using as0(2) n"], ["proof (prove)\nusing this:\n  length \\<eta>s0 = n\n  length (renamings_apart (DA0 # CAs0)) = Suc n\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length \\<rho>s = n\n\ngoal (1 subgoal):\n 1. length \\<eta>s0' = n", "unfolding \\<eta>s0'_def"], ["proof (prove)\nusing this:\n  length \\<eta>s0 = n\n  length (renamings_apart (DA0 # CAs0)) = Suc n\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length \\<rho>s = n\n\ngoal (1 subgoal):\n 1. length (map inv_renaming \\<rho>s \\<odot>s \\<eta>s0) = n", "by auto"], ["proof (state)\nthis:\n  length \\<eta>s0' = n\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "note n = \\<open>length CAs0' = n\\<close> \\<open>length \\<eta>s0' = n\\<close> \\<open>length As0' = n\\<close> \\<open>length AAs0' = n\\<close> \\<open>length Cs0' = n\\<close> n"], ["proof (state)\nthis:\n  length CAs0' = n\n  length \\<eta>s0' = n\n  length As0' = n\n  length AAs0' = n\n  length Cs0' = n\n  length (renamings_apart (DA0 # CAs0)) = Suc n\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length \\<rho>s = n\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have DA0'_DA: \"DA0' \\<cdot> \\<eta>0' = DA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DA0' \\<cdot> \\<eta>0' = DA", "using as0(4)"], ["proof (prove)\nusing this:\n  DA0 \\<cdot> \\<eta>0 = DA\n\ngoal (1 subgoal):\n 1. DA0' \\<cdot> \\<eta>0' = DA", "unfolding \\<eta>0'_def DA0'_def"], ["proof (prove)\nusing this:\n  DA0 \\<cdot> \\<eta>0 = DA\n\ngoal (1 subgoal):\n 1. DA0 \\<cdot> \\<rho> \\<cdot> (inv_renaming \\<rho> \\<odot> \\<eta>0) = DA", "using renames_DA0"], ["proof (prove)\nusing this:\n  DA0 \\<cdot> \\<eta>0 = DA\n  is_renaming \\<rho>\n\ngoal (1 subgoal):\n 1. DA0 \\<cdot> \\<rho> \\<cdot> (inv_renaming \\<rho> \\<odot> \\<eta>0) = DA", "by simp"], ["proof (state)\nthis:\n  DA0' \\<cdot> \\<eta>0' = DA\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have D0'_D: \"D0' \\<cdot> \\<eta>0' = D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D0' \\<cdot> \\<eta>0' = D", "using as0(14)"], ["proof (prove)\nusing this:\n  D0 \\<cdot> \\<eta>0 = D\n\ngoal (1 subgoal):\n 1. D0' \\<cdot> \\<eta>0' = D", "unfolding \\<eta>0'_def D0'_def"], ["proof (prove)\nusing this:\n  D0 \\<cdot> \\<eta>0 = D\n\ngoal (1 subgoal):\n 1. D0 \\<cdot> \\<rho> \\<cdot> (inv_renaming \\<rho> \\<odot> \\<eta>0) = D", "using renames_DA0"], ["proof (prove)\nusing this:\n  D0 \\<cdot> \\<eta>0 = D\n  is_renaming \\<rho>\n\ngoal (1 subgoal):\n 1. D0 \\<cdot> \\<rho> \\<cdot> (inv_renaming \\<rho> \\<odot> \\<eta>0) = D", "by simp"], ["proof (state)\nthis:\n  D0' \\<cdot> \\<eta>0' = D\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have As0'_As: \"As0' \\<cdot>al \\<eta>0' = As\""], ["proof (prove)\ngoal (1 subgoal):\n 1. As0' \\<cdot>al \\<eta>0' = As", "using as0(11)"], ["proof (prove)\nusing this:\n  As0 \\<cdot>al \\<eta>0 = As\n\ngoal (1 subgoal):\n 1. As0' \\<cdot>al \\<eta>0' = As", "unfolding \\<eta>0'_def As0'_def"], ["proof (prove)\nusing this:\n  As0 \\<cdot>al \\<eta>0 = As\n\ngoal (1 subgoal):\n 1. As0 \\<cdot>al \\<rho> \\<cdot>al (inv_renaming \\<rho> \\<odot> \\<eta>0) =\n    As", "using renames_DA0"], ["proof (prove)\nusing this:\n  As0 \\<cdot>al \\<eta>0 = As\n  is_renaming \\<rho>\n\ngoal (1 subgoal):\n 1. As0 \\<cdot>al \\<rho> \\<cdot>al (inv_renaming \\<rho> \\<odot> \\<eta>0) =\n    As", "by auto"], ["proof (state)\nthis:\n  As0' \\<cdot>al \\<eta>0' = As\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"S DA0' \\<cdot> \\<eta>0' = S_M S M DA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S DA0' \\<cdot> \\<eta>0' = S_M S M DA", "using as0(5)"], ["proof (prove)\nusing this:\n  S DA0 \\<cdot> \\<eta>0 = S_M S M DA\n\ngoal (1 subgoal):\n 1. S DA0' \\<cdot> \\<eta>0' = S_M S M DA", "unfolding \\<eta>0'_def DA0'_def"], ["proof (prove)\nusing this:\n  S DA0 \\<cdot> \\<eta>0 = S_M S M DA\n\ngoal (1 subgoal):\n 1. S (DA0 \\<cdot> \\<rho>) \\<cdot> (inv_renaming \\<rho> \\<odot> \\<eta>0) =\n    S_M S M DA", "using renames_DA0 sel_stable"], ["proof (prove)\nusing this:\n  S DA0 \\<cdot> \\<eta>0 = S_M S M DA\n  is_renaming \\<rho>\n  is_renaming ?\\<rho> \\<Longrightarrow>\n  S (?C \\<cdot> ?\\<rho>) = S ?C \\<cdot> ?\\<rho>\n\ngoal (1 subgoal):\n 1. S (DA0 \\<cdot> \\<rho>) \\<cdot> (inv_renaming \\<rho> \\<odot> \\<eta>0) =\n    S_M S M DA", "by auto"], ["proof (state)\nthis:\n  S DA0' \\<cdot> \\<eta>0' = S_M S M DA\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have CAs0'_CAs: \"CAs0' \\<cdot>\\<cdot>cl \\<eta>s0' = CAs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CAs0' \\<cdot>\\<cdot>cl \\<eta>s0' = CAs", "using as0(7)"], ["proof (prove)\nusing this:\n  CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs\n\ngoal (1 subgoal):\n 1. CAs0' \\<cdot>\\<cdot>cl \\<eta>s0' = CAs", "unfolding CAs0'_def \\<eta>s0'_def"], ["proof (prove)\nusing this:\n  CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs\n\ngoal (1 subgoal):\n 1. CAs0 \\<cdot>\\<cdot>cl \\<rho>s \\<cdot>\\<cdot>cl\n    (map inv_renaming \\<rho>s \\<odot>s \\<eta>s0) =\n    CAs", "using renames_CAs0 n"], ["proof (prove)\nusing this:\n  CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs\n  is_renaming_list \\<rho>s\n  length CAs0' = n\n  length \\<eta>s0' = n\n  length As0' = n\n  length AAs0' = n\n  length Cs0' = n\n  length (renamings_apart (DA0 # CAs0)) = Suc n\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length \\<rho>s = n\n\ngoal (1 subgoal):\n 1. CAs0 \\<cdot>\\<cdot>cl \\<rho>s \\<cdot>\\<cdot>cl\n    (map inv_renaming \\<rho>s \\<odot>s \\<eta>s0) =\n    CAs", "by auto"], ["proof (state)\nthis:\n  CAs0' \\<cdot>\\<cdot>cl \\<eta>s0' = CAs\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have Cs0'_Cs: \"Cs0' \\<cdot>\\<cdot>cl \\<eta>s0' = Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cs0' \\<cdot>\\<cdot>cl \\<eta>s0' = Cs", "using as0(18)"], ["proof (prove)\nusing this:\n  Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs\n\ngoal (1 subgoal):\n 1. Cs0' \\<cdot>\\<cdot>cl \\<eta>s0' = Cs", "unfolding Cs0'_def \\<eta>s0'_def"], ["proof (prove)\nusing this:\n  Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs\n\ngoal (1 subgoal):\n 1. Cs0 \\<cdot>\\<cdot>cl \\<rho>s \\<cdot>\\<cdot>cl\n    (map inv_renaming \\<rho>s \\<odot>s \\<eta>s0) =\n    Cs", "using renames_CAs0 n"], ["proof (prove)\nusing this:\n  Cs0 \\<cdot>\\<cdot>cl \\<eta>s0 = Cs\n  is_renaming_list \\<rho>s\n  length CAs0' = n\n  length \\<eta>s0' = n\n  length As0' = n\n  length AAs0' = n\n  length Cs0' = n\n  length (renamings_apart (DA0 # CAs0)) = Suc n\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length \\<rho>s = n\n\ngoal (1 subgoal):\n 1. Cs0 \\<cdot>\\<cdot>cl \\<rho>s \\<cdot>\\<cdot>cl\n    (map inv_renaming \\<rho>s \\<odot>s \\<eta>s0) =\n    Cs", "by auto"], ["proof (state)\nthis:\n  Cs0' \\<cdot>\\<cdot>cl \\<eta>s0' = Cs\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have AAs0'_AAs: \"AAs0' \\<cdot>\\<cdot>aml \\<eta>s0' = AAs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AAs0' \\<cdot>\\<cdot>aml \\<eta>s0' = AAs", "using as0(12)"], ["proof (prove)\nusing this:\n  AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs\n\ngoal (1 subgoal):\n 1. AAs0' \\<cdot>\\<cdot>aml \\<eta>s0' = AAs", "unfolding \\<eta>s0'_def AAs0'_def"], ["proof (prove)\nusing this:\n  AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs\n\ngoal (1 subgoal):\n 1. AAs0 \\<cdot>\\<cdot>aml \\<rho>s \\<cdot>\\<cdot>aml\n    (map inv_renaming \\<rho>s \\<odot>s \\<eta>s0) =\n    AAs", "using renames_CAs0"], ["proof (prove)\nusing this:\n  AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs\n  is_renaming_list \\<rho>s\n\ngoal (1 subgoal):\n 1. AAs0 \\<cdot>\\<cdot>aml \\<rho>s \\<cdot>\\<cdot>aml\n    (map inv_renaming \\<rho>s \\<odot>s \\<eta>s0) =\n    AAs", "using n"], ["proof (prove)\nusing this:\n  AAs0 \\<cdot>\\<cdot>aml \\<eta>s0 = AAs\n  is_renaming_list \\<rho>s\n  length CAs0' = n\n  length \\<eta>s0' = n\n  length As0' = n\n  length AAs0' = n\n  length Cs0' = n\n  length (renamings_apart (DA0 # CAs0)) = Suc n\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length \\<rho>s = n\n\ngoal (1 subgoal):\n 1. AAs0 \\<cdot>\\<cdot>aml \\<rho>s \\<cdot>\\<cdot>aml\n    (map inv_renaming \\<rho>s \\<odot>s \\<eta>s0) =\n    AAs", "by auto"], ["proof (state)\nthis:\n  AAs0' \\<cdot>\\<cdot>aml \\<eta>s0' = AAs\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"map S CAs0' \\<cdot>\\<cdot>cl \\<eta>s0' = map (S_M S M) CAs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map S CAs0' \\<cdot>\\<cdot>cl \\<eta>s0' = map (S_M S M) CAs", "unfolding CAs0'_def \\<eta>s0'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map S (CAs0 \\<cdot>\\<cdot>cl \\<rho>s) \\<cdot>\\<cdot>cl\n    (map inv_renaming \\<rho>s \\<odot>s \\<eta>s0) =\n    map (S_M S M) CAs", "using as0(8) n renames_CAs0 sel_ren_list_inv"], ["proof (prove)\nusing this:\n  map S CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = map (S_M S M) CAs\n  length CAs0' = n\n  length \\<eta>s0' = n\n  length As0' = n\n  length AAs0' = n\n  length Cs0' = n\n  length (renamings_apart (DA0 # CAs0)) = Suc n\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length \\<rho>s = n\n  is_renaming_list \\<rho>s\n  \\<lbrakk>length ?\\<rho>s = length ?Cs; is_renaming_list ?\\<rho>s\\<rbrakk>\n  \\<Longrightarrow> map S (?Cs \\<cdot>\\<cdot>cl ?\\<rho>s) =\n                    map S ?Cs \\<cdot>\\<cdot>cl ?\\<rho>s\n\ngoal (1 subgoal):\n 1. map S (CAs0 \\<cdot>\\<cdot>cl \\<rho>s) \\<cdot>\\<cdot>cl\n    (map inv_renaming \\<rho>s \\<odot>s \\<eta>s0) =\n    map (S_M S M) CAs", "by auto"], ["proof (state)\nthis:\n  map S CAs0' \\<cdot>\\<cdot>cl \\<eta>s0' = map (S_M S M) CAs\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have DA0'_split: \"DA0' = D0' + negs (mset As0')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DA0' = D0' + negs (mset As0')", "using as0(15) DA0'_def D0'_def As0'_def"], ["proof (prove)\nusing this:\n  DA0 = D0 + negs (mset As0)\n  DA0' = DA0 \\<cdot> \\<rho>\n  D0' = D0 \\<cdot> \\<rho>\n  As0' = As0 \\<cdot>al \\<rho>\n\ngoal (1 subgoal):\n 1. DA0' = D0' + negs (mset As0')", "by auto"], ["proof (state)\nthis:\n  DA0' = D0' + negs (mset As0')\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  DA0' = D0' + negs (mset As0')", "have D0'_subset_DA0': \"D0' \\<subseteq># DA0'\""], ["proof (prove)\nusing this:\n  DA0' = D0' + negs (mset As0')\n\ngoal (1 subgoal):\n 1. D0' \\<subseteq># DA0'", "by auto"], ["proof (state)\nthis:\n  D0' \\<subseteq># DA0'\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "from DA0'_split"], ["proof (chain)\npicking this:\n  DA0' = D0' + negs (mset As0')", "have negs_As0'_subset_DA0': \"negs (mset As0') \\<subseteq># DA0'\""], ["proof (prove)\nusing this:\n  DA0' = D0' + negs (mset As0')\n\ngoal (1 subgoal):\n 1. negs (mset As0') \\<subseteq># DA0'", "by auto"], ["proof (state)\nthis:\n  negs (mset As0') \\<subseteq># DA0'\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have CAs0'_split: \"\\<forall>i<n. CAs0' ! i = Cs0' ! i + poss (AAs0' ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<n. CAs0' ! i = Cs0' ! i + poss (AAs0' ! i)", "using as0(19) CAs0'_def Cs0'_def AAs0'_def n"], ["proof (prove)\nusing this:\n  \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i)\n  CAs0' = CAs0 \\<cdot>\\<cdot>cl \\<rho>s\n  Cs0' = Cs0 \\<cdot>\\<cdot>cl \\<rho>s\n  AAs0' = AAs0 \\<cdot>\\<cdot>aml \\<rho>s\n  length CAs0' = n\n  length \\<eta>s0' = n\n  length As0' = n\n  length AAs0' = n\n  length Cs0' = n\n  length (renamings_apart (DA0 # CAs0)) = Suc n\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length \\<rho>s = n\n\ngoal (1 subgoal):\n 1. \\<forall>i<n. CAs0' ! i = Cs0' ! i + poss (AAs0' ! i)", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<n. CAs0' ! i = Cs0' ! i + poss (AAs0' ! i)\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<n. CAs0' ! i = Cs0' ! i + poss (AAs0' ! i)", "have \"\\<forall>i<n. Cs0' ! i \\<subseteq># CAs0' ! i\""], ["proof (prove)\nusing this:\n  \\<forall>i<n. CAs0' ! i = Cs0' ! i + poss (AAs0' ! i)\n\ngoal (1 subgoal):\n 1. \\<forall>i<n. Cs0' ! i \\<subseteq># CAs0' ! i", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<n. Cs0' ! i \\<subseteq># CAs0' ! i\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "from CAs0'_split"], ["proof (chain)\npicking this:\n  \\<forall>i<n. CAs0' ! i = Cs0' ! i + poss (AAs0' ! i)", "have poss_AAs0'_subset_CAs0': \"\\<forall>i<n. poss (AAs0' ! i) \\<subseteq># CAs0' ! i\""], ["proof (prove)\nusing this:\n  \\<forall>i<n. CAs0' ! i = Cs0' ! i + poss (AAs0' ! i)\n\ngoal (1 subgoal):\n 1. \\<forall>i<n. poss (AAs0' ! i) \\<subseteq># CAs0' ! i", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<n. poss (AAs0' ! i) \\<subseteq># CAs0' ! i\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<n. poss (AAs0' ! i) \\<subseteq># CAs0' ! i", "have AAs0'_in_atms_of_CAs0': \"\\<forall>i < n. \\<forall>A\\<in>#AAs0' ! i. A \\<in> atms_of (CAs0' ! i)\""], ["proof (prove)\nusing this:\n  \\<forall>i<n. poss (AAs0' ! i) \\<subseteq># CAs0' ! i\n\ngoal (1 subgoal):\n 1. \\<forall>i<n. \\<forall>A\\<in>#AAs0' ! i. A \\<in> atms_of (CAs0' ! i)", "by (auto simp add: atm_iff_pos_or_neg_lit)"], ["proof (state)\nthis:\n  \\<forall>i<n. \\<forall>A\\<in>#AAs0' ! i. A \\<in> atms_of (CAs0' ! i)\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have as0':\n    \"S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow> negs (mset As0') = S DA0'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n    negs (mset As0') = S DA0'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n    negs (mset As0') = S DA0'", "assume a: \"S_M S M (D + negs (mset As)) \\<noteq> {#}\""], ["proof (state)\nthis:\n  S_M S M (D + negs (mset As)) \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n    negs (mset As0') = S DA0'", "then"], ["proof (chain)\npicking this:\n  S_M S M (D + negs (mset As)) \\<noteq> {#}", "have \"negs (mset As0) \\<cdot> \\<rho> = S DA0 \\<cdot> \\<rho>\""], ["proof (prove)\nusing this:\n  S_M S M (D + negs (mset As)) \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. negs (mset As0) \\<cdot> \\<rho> = S DA0 \\<cdot> \\<rho>", "using as0(16)"], ["proof (prove)\nusing this:\n  S_M S M (D + negs (mset As)) \\<noteq> {#}\n  S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n  negs (mset As0) = S DA0\n\ngoal (1 subgoal):\n 1. negs (mset As0) \\<cdot> \\<rho> = S DA0 \\<cdot> \\<rho>", "unfolding \\<rho>_def"], ["proof (prove)\nusing this:\n  S_M S M (D + negs (mset As)) \\<noteq> {#}\n  S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n  negs (mset As0) = S DA0\n\ngoal (1 subgoal):\n 1. negs (mset As0) \\<cdot> hd (renamings_apart (DA0 # CAs0)) =\n    S DA0 \\<cdot> hd (renamings_apart (DA0 # CAs0))", "by metis"], ["proof (state)\nthis:\n  negs (mset As0) \\<cdot> \\<rho> = S DA0 \\<cdot> \\<rho>\n\ngoal (1 subgoal):\n 1. S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n    negs (mset As0') = S DA0'", "then"], ["proof (chain)\npicking this:\n  negs (mset As0) \\<cdot> \\<rho> = S DA0 \\<cdot> \\<rho>", "show \"negs (mset As0') = S DA0'\""], ["proof (prove)\nusing this:\n  negs (mset As0) \\<cdot> \\<rho> = S DA0 \\<cdot> \\<rho>\n\ngoal (1 subgoal):\n 1. negs (mset As0') = S DA0'", "using  As0'_def DA0'_def"], ["proof (prove)\nusing this:\n  negs (mset As0) \\<cdot> \\<rho> = S DA0 \\<cdot> \\<rho>\n  As0' = As0 \\<cdot>al \\<rho>\n  DA0' = DA0 \\<cdot> \\<rho>\n\ngoal (1 subgoal):\n 1. negs (mset As0') = S DA0'", "using sel_stable[of \\<rho> DA0] renames_DA0"], ["proof (prove)\nusing this:\n  negs (mset As0) \\<cdot> \\<rho> = S DA0 \\<cdot> \\<rho>\n  As0' = As0 \\<cdot>al \\<rho>\n  DA0' = DA0 \\<cdot> \\<rho>\n  is_renaming \\<rho> \\<Longrightarrow>\n  S (DA0 \\<cdot> \\<rho>) = S DA0 \\<cdot> \\<rho>\n  is_renaming \\<rho>\n\ngoal (1 subgoal):\n 1. negs (mset As0') = S DA0'", "by auto"], ["proof (state)\nthis:\n  negs (mset As0') = S DA0'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n  negs (mset As0') = S DA0'\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have vd: \"var_disjoint (DA0' # CAs0')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var_disjoint (DA0' # CAs0')", "unfolding DA0'_def CAs0'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. var_disjoint (DA0 \\<cdot> \\<rho> # CAs0 \\<cdot>\\<cdot>cl \\<rho>s)", "using renamings_apart_var_disjoint"], ["proof (prove)\nusing this:\n  var_disjoint (?Cs \\<cdot>\\<cdot>cl renamings_apart ?Cs)\n\ngoal (1 subgoal):\n 1. var_disjoint (DA0 \\<cdot> \\<rho> # CAs0 \\<cdot>\\<cdot>cl \\<rho>s)", "unfolding \\<rho>_def \\<rho>s_def"], ["proof (prove)\nusing this:\n  var_disjoint (?Cs \\<cdot>\\<cdot>cl renamings_apart ?Cs)\n\ngoal (1 subgoal):\n 1. var_disjoint\n     (DA0 \\<cdot> hd (renamings_apart (DA0 # CAs0)) #\n      CAs0 \\<cdot>\\<cdot>cl tl (renamings_apart (DA0 # CAs0)))", "by (metis length_greater_0_conv list.exhaust_sel n(6) substitution.subst_cls_lists_Cons\n        substitution_axioms zero_less_Suc)\n\n  \\<comment> \\<open>Introduce ground substitution\\<close>"], ["proof (state)\nthis:\n  var_disjoint (DA0' # CAs0')\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "from vd DA0'_DA CAs0'_CAs"], ["proof (chain)\npicking this:\n  var_disjoint (DA0' # CAs0')\n  DA0' \\<cdot> \\<eta>0' = DA\n  CAs0' \\<cdot>\\<cdot>cl \\<eta>s0' = CAs", "have \"\\<exists>\\<eta>. \\<forall>i < Suc n. \\<forall>S. S \\<subseteq># (DA0' # CAs0') ! i \\<longrightarrow> S \\<cdot> (\\<eta>0'#\\<eta>s0') ! i = S \\<cdot> \\<eta>\""], ["proof (prove)\nusing this:\n  var_disjoint (DA0' # CAs0')\n  DA0' \\<cdot> \\<eta>0' = DA\n  CAs0' \\<cdot>\\<cdot>cl \\<eta>s0' = CAs\n\ngoal (1 subgoal):\n 1. \\<exists>\\<eta>.\n       \\<forall>i<Suc n.\n          \\<forall>S.\n             S \\<subseteq># (DA0' # CAs0') ! i \\<longrightarrow>\n             S \\<cdot> (\\<eta>0' # \\<eta>s0') ! i = S \\<cdot> \\<eta>", "unfolding var_disjoint_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<sigma>s.\n     length \\<sigma>s = length (DA0' # CAs0') \\<longrightarrow>\n     (\\<exists>\\<tau>.\n         \\<forall>i<length (DA0' # CAs0').\n            \\<forall>S.\n               S \\<subseteq># (DA0' # CAs0') ! i \\<longrightarrow>\n               S \\<cdot> \\<sigma>s ! i = S \\<cdot> \\<tau>)\n  DA0' \\<cdot> \\<eta>0' = DA\n  CAs0' \\<cdot>\\<cdot>cl \\<eta>s0' = CAs\n\ngoal (1 subgoal):\n 1. \\<exists>\\<eta>.\n       \\<forall>i<Suc n.\n          \\<forall>S.\n             S \\<subseteq># (DA0' # CAs0') ! i \\<longrightarrow>\n             S \\<cdot> (\\<eta>0' # \\<eta>s0') ! i = S \\<cdot> \\<eta>", "using n"], ["proof (prove)\nusing this:\n  \\<forall>\\<sigma>s.\n     length \\<sigma>s = length (DA0' # CAs0') \\<longrightarrow>\n     (\\<exists>\\<tau>.\n         \\<forall>i<length (DA0' # CAs0').\n            \\<forall>S.\n               S \\<subseteq># (DA0' # CAs0') ! i \\<longrightarrow>\n               S \\<cdot> \\<sigma>s ! i = S \\<cdot> \\<tau>)\n  DA0' \\<cdot> \\<eta>0' = DA\n  CAs0' \\<cdot>\\<cdot>cl \\<eta>s0' = CAs\n  length CAs0' = n\n  length \\<eta>s0' = n\n  length As0' = n\n  length AAs0' = n\n  length Cs0' = n\n  length (renamings_apart (DA0 # CAs0)) = Suc n\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length \\<rho>s = n\n\ngoal (1 subgoal):\n 1. \\<exists>\\<eta>.\n       \\<forall>i<Suc n.\n          \\<forall>S.\n             S \\<subseteq># (DA0' # CAs0') ! i \\<longrightarrow>\n             S \\<cdot> (\\<eta>0' # \\<eta>s0') ! i = S \\<cdot> \\<eta>", "by auto"], ["proof (state)\nthis:\n  \\<exists>\\<eta>.\n     \\<forall>i<Suc n.\n        \\<forall>S.\n           S \\<subseteq># (DA0' # CAs0') ! i \\<longrightarrow>\n           S \\<cdot> (\\<eta>0' # \\<eta>s0') ! i = S \\<cdot> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<exists>\\<eta>.\n     \\<forall>i<Suc n.\n        \\<forall>S.\n           S \\<subseteq># (DA0' # CAs0') ! i \\<longrightarrow>\n           S \\<cdot> (\\<eta>0' # \\<eta>s0') ! i = S \\<cdot> \\<eta>", "obtain \\<eta> where \\<eta>_p: \"\\<forall>i < Suc n. \\<forall>S. S \\<subseteq># (DA0' # CAs0') ! i \\<longrightarrow> S \\<cdot> (\\<eta>0'#\\<eta>s0') ! i = S \\<cdot> \\<eta>\""], ["proof (prove)\nusing this:\n  \\<exists>\\<eta>.\n     \\<forall>i<Suc n.\n        \\<forall>S.\n           S \\<subseteq># (DA0' # CAs0') ! i \\<longrightarrow>\n           S \\<cdot> (\\<eta>0' # \\<eta>s0') ! i = S \\<cdot> \\<eta>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<eta>.\n        \\<forall>i<Suc n.\n           \\<forall>S.\n              S \\<subseteq># (DA0' # CAs0') ! i \\<longrightarrow>\n              S \\<cdot> (\\<eta>0' # \\<eta>s0') ! i =\n              S \\<cdot> \\<eta> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<Suc n.\n     \\<forall>S.\n        S \\<subseteq># (DA0' # CAs0') ! i \\<longrightarrow>\n        S \\<cdot> (\\<eta>0' # \\<eta>s0') ! i = S \\<cdot> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \\<eta>_p_lit: \"\\<forall>i < Suc n. \\<forall>L. L \\<in># (DA0' # CAs0') ! i \\<longrightarrow> L \\<cdot>l (\\<eta>0'#\\<eta>s0') ! i = L \\<cdot>l \\<eta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<Suc n.\n       \\<forall>L.\n          L \\<in># (DA0' # CAs0') ! i \\<longrightarrow>\n          L \\<cdot>l (\\<eta>0' # \\<eta>s0') ! i = L \\<cdot>l \\<eta>", "proof (rule, rule, rule, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i L.\n       \\<lbrakk>i < Suc n; L \\<in># (DA0' # CAs0') ! i\\<rbrakk>\n       \\<Longrightarrow> L \\<cdot>l (\\<eta>0' # \\<eta>s0') ! i =\n                         L \\<cdot>l \\<eta>", "fix i :: \"nat\" and L :: \"'a literal\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i L.\n       \\<lbrakk>i < Suc n; L \\<in># (DA0' # CAs0') ! i\\<rbrakk>\n       \\<Longrightarrow> L \\<cdot>l (\\<eta>0' # \\<eta>s0') ! i =\n                         L \\<cdot>l \\<eta>", "assume a:\n      \"i < Suc n\"\n      \"L \\<in># (DA0' # CAs0') ! i\""], ["proof (state)\nthis:\n  i < Suc n\n  L \\<in># (DA0' # CAs0') ! i\n\ngoal (1 subgoal):\n 1. \\<And>i L.\n       \\<lbrakk>i < Suc n; L \\<in># (DA0' # CAs0') ! i\\<rbrakk>\n       \\<Longrightarrow> L \\<cdot>l (\\<eta>0' # \\<eta>s0') ! i =\n                         L \\<cdot>l \\<eta>", "then"], ["proof (chain)\npicking this:\n  i < Suc n\n  L \\<in># (DA0' # CAs0') ! i", "have \"\\<forall>S. S \\<subseteq># (DA0' # CAs0') ! i \\<longrightarrow> S \\<cdot> (\\<eta>0' # \\<eta>s0') ! i = S \\<cdot> \\<eta>\""], ["proof (prove)\nusing this:\n  i < Suc n\n  L \\<in># (DA0' # CAs0') ! i\n\ngoal (1 subgoal):\n 1. \\<forall>S.\n       S \\<subseteq># (DA0' # CAs0') ! i \\<longrightarrow>\n       S \\<cdot> (\\<eta>0' # \\<eta>s0') ! i = S \\<cdot> \\<eta>", "using \\<eta>_p"], ["proof (prove)\nusing this:\n  i < Suc n\n  L \\<in># (DA0' # CAs0') ! i\n  \\<forall>i<Suc n.\n     \\<forall>S.\n        S \\<subseteq># (DA0' # CAs0') ! i \\<longrightarrow>\n        S \\<cdot> (\\<eta>0' # \\<eta>s0') ! i = S \\<cdot> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<forall>S.\n       S \\<subseteq># (DA0' # CAs0') ! i \\<longrightarrow>\n       S \\<cdot> (\\<eta>0' # \\<eta>s0') ! i = S \\<cdot> \\<eta>", "by auto"], ["proof (state)\nthis:\n  \\<forall>S.\n     S \\<subseteq># (DA0' # CAs0') ! i \\<longrightarrow>\n     S \\<cdot> (\\<eta>0' # \\<eta>s0') ! i = S \\<cdot> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<And>i L.\n       \\<lbrakk>i < Suc n; L \\<in># (DA0' # CAs0') ! i\\<rbrakk>\n       \\<Longrightarrow> L \\<cdot>l (\\<eta>0' # \\<eta>s0') ! i =\n                         L \\<cdot>l \\<eta>", "then"], ["proof (chain)\npicking this:\n  \\<forall>S.\n     S \\<subseteq># (DA0' # CAs0') ! i \\<longrightarrow>\n     S \\<cdot> (\\<eta>0' # \\<eta>s0') ! i = S \\<cdot> \\<eta>", "have \"{# L #} \\<cdot> (\\<eta>0' # \\<eta>s0') ! i = {# L #} \\<cdot> \\<eta>\""], ["proof (prove)\nusing this:\n  \\<forall>S.\n     S \\<subseteq># (DA0' # CAs0') ! i \\<longrightarrow>\n     S \\<cdot> (\\<eta>0' # \\<eta>s0') ! i = S \\<cdot> \\<eta>\n\ngoal (1 subgoal):\n 1. {#L#} \\<cdot> (\\<eta>0' # \\<eta>s0') ! i = {#L#} \\<cdot> \\<eta>", "using a"], ["proof (prove)\nusing this:\n  \\<forall>S.\n     S \\<subseteq># (DA0' # CAs0') ! i \\<longrightarrow>\n     S \\<cdot> (\\<eta>0' # \\<eta>s0') ! i = S \\<cdot> \\<eta>\n  i < Suc n\n  L \\<in># (DA0' # CAs0') ! i\n\ngoal (1 subgoal):\n 1. {#L#} \\<cdot> (\\<eta>0' # \\<eta>s0') ! i = {#L#} \\<cdot> \\<eta>", "by (meson single_subset_iff)"], ["proof (state)\nthis:\n  {#L#} \\<cdot> (\\<eta>0' # \\<eta>s0') ! i = {#L#} \\<cdot> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<And>i L.\n       \\<lbrakk>i < Suc n; L \\<in># (DA0' # CAs0') ! i\\<rbrakk>\n       \\<Longrightarrow> L \\<cdot>l (\\<eta>0' # \\<eta>s0') ! i =\n                         L \\<cdot>l \\<eta>", "then"], ["proof (chain)\npicking this:\n  {#L#} \\<cdot> (\\<eta>0' # \\<eta>s0') ! i = {#L#} \\<cdot> \\<eta>", "show \"L \\<cdot>l (\\<eta>0' # \\<eta>s0') ! i = L \\<cdot>l \\<eta>\""], ["proof (prove)\nusing this:\n  {#L#} \\<cdot> (\\<eta>0' # \\<eta>s0') ! i = {#L#} \\<cdot> \\<eta>\n\ngoal (1 subgoal):\n 1. L \\<cdot>l (\\<eta>0' # \\<eta>s0') ! i = L \\<cdot>l \\<eta>", "by auto"], ["proof (state)\nthis:\n  L \\<cdot>l (\\<eta>0' # \\<eta>s0') ! i = L \\<cdot>l \\<eta>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i<Suc n.\n     \\<forall>L.\n        L \\<in># (DA0' # CAs0') ! i \\<longrightarrow>\n        L \\<cdot>l (\\<eta>0' # \\<eta>s0') ! i = L \\<cdot>l \\<eta>\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \\<eta>_p_atm: \"\\<forall>i < Suc n. \\<forall>A. A \\<in> atms_of ((DA0' # CAs0') ! i) \\<longrightarrow> A \\<cdot>a (\\<eta>0'#\\<eta>s0') ! i = A \\<cdot>a \\<eta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<Suc n.\n       \\<forall>A.\n          A \\<in> atms_of ((DA0' # CAs0') ! i) \\<longrightarrow>\n          A \\<cdot>a (\\<eta>0' # \\<eta>s0') ! i = A \\<cdot>a \\<eta>", "proof (rule, rule, rule, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i A.\n       \\<lbrakk>i < Suc n; A \\<in> atms_of ((DA0' # CAs0') ! i)\\<rbrakk>\n       \\<Longrightarrow> A \\<cdot>a (\\<eta>0' # \\<eta>s0') ! i =\n                         A \\<cdot>a \\<eta>", "fix i :: \"nat\" and A :: \"'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i A.\n       \\<lbrakk>i < Suc n; A \\<in> atms_of ((DA0' # CAs0') ! i)\\<rbrakk>\n       \\<Longrightarrow> A \\<cdot>a (\\<eta>0' # \\<eta>s0') ! i =\n                         A \\<cdot>a \\<eta>", "assume a:\n      \"i < Suc n\"\n      \"A \\<in> atms_of ((DA0' # CAs0') ! i)\""], ["proof (state)\nthis:\n  i < Suc n\n  A \\<in> atms_of ((DA0' # CAs0') ! i)\n\ngoal (1 subgoal):\n 1. \\<And>i A.\n       \\<lbrakk>i < Suc n; A \\<in> atms_of ((DA0' # CAs0') ! i)\\<rbrakk>\n       \\<Longrightarrow> A \\<cdot>a (\\<eta>0' # \\<eta>s0') ! i =\n                         A \\<cdot>a \\<eta>", "then"], ["proof (chain)\npicking this:\n  i < Suc n\n  A \\<in> atms_of ((DA0' # CAs0') ! i)", "obtain L where L_p: \"atm_of L = A \\<and> L \\<in># (DA0' # CAs0') ! i\""], ["proof (prove)\nusing this:\n  i < Suc n\n  A \\<in> atms_of ((DA0' # CAs0') ! i)\n\ngoal (1 subgoal):\n 1. (\\<And>L.\n        atm_of L = A \\<and> L \\<in># (DA0' # CAs0') ! i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding atms_of_def"], ["proof (prove)\nusing this:\n  i < Suc n\n  A \\<in> atm_of ` set_mset ((DA0' # CAs0') ! i)\n\ngoal (1 subgoal):\n 1. (\\<And>L.\n        atm_of L = A \\<and> L \\<in># (DA0' # CAs0') ! i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  atm_of L = A \\<and> L \\<in># (DA0' # CAs0') ! i\n\ngoal (1 subgoal):\n 1. \\<And>i A.\n       \\<lbrakk>i < Suc n; A \\<in> atms_of ((DA0' # CAs0') ! i)\\<rbrakk>\n       \\<Longrightarrow> A \\<cdot>a (\\<eta>0' # \\<eta>s0') ! i =\n                         A \\<cdot>a \\<eta>", "then"], ["proof (chain)\npicking this:\n  atm_of L = A \\<and> L \\<in># (DA0' # CAs0') ! i", "have \"L \\<cdot>l (\\<eta>0'#\\<eta>s0') ! i = L \\<cdot>l \\<eta>\""], ["proof (prove)\nusing this:\n  atm_of L = A \\<and> L \\<in># (DA0' # CAs0') ! i\n\ngoal (1 subgoal):\n 1. L \\<cdot>l (\\<eta>0' # \\<eta>s0') ! i = L \\<cdot>l \\<eta>", "using \\<eta>_p_lit a"], ["proof (prove)\nusing this:\n  atm_of L = A \\<and> L \\<in># (DA0' # CAs0') ! i\n  \\<forall>i<Suc n.\n     \\<forall>L.\n        L \\<in># (DA0' # CAs0') ! i \\<longrightarrow>\n        L \\<cdot>l (\\<eta>0' # \\<eta>s0') ! i = L \\<cdot>l \\<eta>\n  i < Suc n\n  A \\<in> atms_of ((DA0' # CAs0') ! i)\n\ngoal (1 subgoal):\n 1. L \\<cdot>l (\\<eta>0' # \\<eta>s0') ! i = L \\<cdot>l \\<eta>", "by auto"], ["proof (state)\nthis:\n  L \\<cdot>l (\\<eta>0' # \\<eta>s0') ! i = L \\<cdot>l \\<eta>\n\ngoal (1 subgoal):\n 1. \\<And>i A.\n       \\<lbrakk>i < Suc n; A \\<in> atms_of ((DA0' # CAs0') ! i)\\<rbrakk>\n       \\<Longrightarrow> A \\<cdot>a (\\<eta>0' # \\<eta>s0') ! i =\n                         A \\<cdot>a \\<eta>", "then"], ["proof (chain)\npicking this:\n  L \\<cdot>l (\\<eta>0' # \\<eta>s0') ! i = L \\<cdot>l \\<eta>", "show \"A \\<cdot>a (\\<eta>0' # \\<eta>s0') ! i = A \\<cdot>a \\<eta>\""], ["proof (prove)\nusing this:\n  L \\<cdot>l (\\<eta>0' # \\<eta>s0') ! i = L \\<cdot>l \\<eta>\n\ngoal (1 subgoal):\n 1. A \\<cdot>a (\\<eta>0' # \\<eta>s0') ! i = A \\<cdot>a \\<eta>", "using L_p"], ["proof (prove)\nusing this:\n  L \\<cdot>l (\\<eta>0' # \\<eta>s0') ! i = L \\<cdot>l \\<eta>\n  atm_of L = A \\<and> L \\<in># (DA0' # CAs0') ! i\n\ngoal (1 subgoal):\n 1. A \\<cdot>a (\\<eta>0' # \\<eta>s0') ! i = A \\<cdot>a \\<eta>", "unfolding subst_lit_def"], ["proof (prove)\nusing this:\n  map_literal (\\<lambda>A. A \\<cdot>a (\\<eta>0' # \\<eta>s0') ! i) L =\n  map_literal (\\<lambda>A. A \\<cdot>a \\<eta>) L\n  atm_of L = A \\<and> L \\<in># (DA0' # CAs0') ! i\n\ngoal (1 subgoal):\n 1. A \\<cdot>a (\\<eta>0' # \\<eta>s0') ! i = A \\<cdot>a \\<eta>", "by (cases L) auto"], ["proof (state)\nthis:\n  A \\<cdot>a (\\<eta>0' # \\<eta>s0') ! i = A \\<cdot>a \\<eta>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i<Suc n.\n     \\<forall>A.\n        A \\<in> atms_of ((DA0' # CAs0') ! i) \\<longrightarrow>\n        A \\<cdot>a (\\<eta>0' # \\<eta>s0') ! i = A \\<cdot>a \\<eta>\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have DA0'_DA: \"DA0' \\<cdot> \\<eta> = DA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DA0' \\<cdot> \\<eta> = DA", "using DA0'_DA \\<eta>_p"], ["proof (prove)\nusing this:\n  DA0' \\<cdot> \\<eta>0' = DA\n  \\<forall>i<Suc n.\n     \\<forall>S.\n        S \\<subseteq># (DA0' # CAs0') ! i \\<longrightarrow>\n        S \\<cdot> (\\<eta>0' # \\<eta>s0') ! i = S \\<cdot> \\<eta>\n\ngoal (1 subgoal):\n 1. DA0' \\<cdot> \\<eta> = DA", "by auto"], ["proof (state)\nthis:\n  DA0' \\<cdot> \\<eta> = DA\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"D0' \\<cdot> \\<eta> = D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D0' \\<cdot> \\<eta> = D", "using \\<eta>_p D0'_D n D0'_subset_DA0'"], ["proof (prove)\nusing this:\n  \\<forall>i<Suc n.\n     \\<forall>S.\n        S \\<subseteq># (DA0' # CAs0') ! i \\<longrightarrow>\n        S \\<cdot> (\\<eta>0' # \\<eta>s0') ! i = S \\<cdot> \\<eta>\n  D0' \\<cdot> \\<eta>0' = D\n  length CAs0' = n\n  length \\<eta>s0' = n\n  length As0' = n\n  length AAs0' = n\n  length Cs0' = n\n  length (renamings_apart (DA0 # CAs0)) = Suc n\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length \\<rho>s = n\n  D0' \\<subseteq># DA0'\n\ngoal (1 subgoal):\n 1. D0' \\<cdot> \\<eta> = D", "by auto"], ["proof (state)\nthis:\n  D0' \\<cdot> \\<eta> = D\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"As0' \\<cdot>al \\<eta> = As\""], ["proof (prove)\ngoal (1 subgoal):\n 1. As0' \\<cdot>al \\<eta> = As", "proof (rule nth_equalityI)"], ["proof (state)\ngoal (2 subgoals):\n 1. length (As0' \\<cdot>al \\<eta>) = length As\n 2. \\<And>i.\n       i < length (As0' \\<cdot>al \\<eta>) \\<Longrightarrow>\n       (As0' \\<cdot>al \\<eta>) ! i = As ! i", "show \"length (As0' \\<cdot>al \\<eta>) = length As\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (As0' \\<cdot>al \\<eta>) = length As", "using n"], ["proof (prove)\nusing this:\n  length CAs0' = n\n  length \\<eta>s0' = n\n  length As0' = n\n  length AAs0' = n\n  length Cs0' = n\n  length (renamings_apart (DA0 # CAs0)) = Suc n\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length \\<rho>s = n\n\ngoal (1 subgoal):\n 1. length (As0' \\<cdot>al \\<eta>) = length As", "by auto"], ["proof (state)\nthis:\n  length (As0' \\<cdot>al \\<eta>) = length As\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (As0' \\<cdot>al \\<eta>) \\<Longrightarrow>\n       (As0' \\<cdot>al \\<eta>) ! i = As ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (As0' \\<cdot>al \\<eta>) \\<Longrightarrow>\n       (As0' \\<cdot>al \\<eta>) ! i = As ! i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (As0' \\<cdot>al \\<eta>) \\<Longrightarrow>\n       (As0' \\<cdot>al \\<eta>) ! i = As ! i", "show \"i<length (As0' \\<cdot>al \\<eta>) \\<Longrightarrow> (As0' \\<cdot>al \\<eta>) ! i = As ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length (As0' \\<cdot>al \\<eta>) \\<Longrightarrow>\n    (As0' \\<cdot>al \\<eta>) ! i = As ! i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. i < length (As0' \\<cdot>al \\<eta>) \\<Longrightarrow>\n    (As0' \\<cdot>al \\<eta>) ! i = As ! i", "assume a: \"i < length (As0' \\<cdot>al \\<eta>)\""], ["proof (state)\nthis:\n  i < length (As0' \\<cdot>al \\<eta>)\n\ngoal (1 subgoal):\n 1. i < length (As0' \\<cdot>al \\<eta>) \\<Longrightarrow>\n    (As0' \\<cdot>al \\<eta>) ! i = As ! i", "have A_eq: \"\\<forall>A. A \\<in> atms_of DA0' \\<longrightarrow> A \\<cdot>a \\<eta>0' = A \\<cdot>a \\<eta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A.\n       A \\<in> atms_of DA0' \\<longrightarrow>\n       A \\<cdot>a \\<eta>0' = A \\<cdot>a \\<eta>", "using \\<eta>_p_atm n"], ["proof (prove)\nusing this:\n  \\<forall>i<Suc n.\n     \\<forall>A.\n        A \\<in> atms_of ((DA0' # CAs0') ! i) \\<longrightarrow>\n        A \\<cdot>a (\\<eta>0' # \\<eta>s0') ! i = A \\<cdot>a \\<eta>\n  length CAs0' = n\n  length \\<eta>s0' = n\n  length As0' = n\n  length AAs0' = n\n  length Cs0' = n\n  length (renamings_apart (DA0 # CAs0)) = Suc n\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length \\<rho>s = n\n\ngoal (1 subgoal):\n 1. \\<forall>A.\n       A \\<in> atms_of DA0' \\<longrightarrow>\n       A \\<cdot>a \\<eta>0' = A \\<cdot>a \\<eta>", "by force"], ["proof (state)\nthis:\n  \\<forall>A.\n     A \\<in> atms_of DA0' \\<longrightarrow>\n     A \\<cdot>a \\<eta>0' = A \\<cdot>a \\<eta>\n\ngoal (1 subgoal):\n 1. i < length (As0' \\<cdot>al \\<eta>) \\<Longrightarrow>\n    (As0' \\<cdot>al \\<eta>) ! i = As ! i", "have \"As0' ! i \\<in> atms_of DA0'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. As0' ! i \\<in> atms_of DA0'", "using negs_As0'_subset_DA0'"], ["proof (prove)\nusing this:\n  negs (mset As0') \\<subseteq># DA0'\n\ngoal (1 subgoal):\n 1. As0' ! i \\<in> atms_of DA0'", "unfolding atms_of_def"], ["proof (prove)\nusing this:\n  negs (mset As0') \\<subseteq># DA0'\n\ngoal (1 subgoal):\n 1. As0' ! i \\<in> atm_of ` set_mset DA0'", "using a n"], ["proof (prove)\nusing this:\n  negs (mset As0') \\<subseteq># DA0'\n  i < length (As0' \\<cdot>al \\<eta>)\n  length CAs0' = n\n  length \\<eta>s0' = n\n  length As0' = n\n  length AAs0' = n\n  length Cs0' = n\n  length (renamings_apart (DA0 # CAs0)) = Suc n\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length \\<rho>s = n\n\ngoal (1 subgoal):\n 1. As0' ! i \\<in> atm_of ` set_mset DA0'", "by force"], ["proof (state)\nthis:\n  As0' ! i \\<in> atms_of DA0'\n\ngoal (1 subgoal):\n 1. i < length (As0' \\<cdot>al \\<eta>) \\<Longrightarrow>\n    (As0' \\<cdot>al \\<eta>) ! i = As ! i", "then"], ["proof (chain)\npicking this:\n  As0' ! i \\<in> atms_of DA0'", "have \"As0' ! i \\<cdot>a \\<eta>0' = As0' ! i \\<cdot>a \\<eta>\""], ["proof (prove)\nusing this:\n  As0' ! i \\<in> atms_of DA0'\n\ngoal (1 subgoal):\n 1. As0' ! i \\<cdot>a \\<eta>0' = As0' ! i \\<cdot>a \\<eta>", "using A_eq"], ["proof (prove)\nusing this:\n  As0' ! i \\<in> atms_of DA0'\n  \\<forall>A.\n     A \\<in> atms_of DA0' \\<longrightarrow>\n     A \\<cdot>a \\<eta>0' = A \\<cdot>a \\<eta>\n\ngoal (1 subgoal):\n 1. As0' ! i \\<cdot>a \\<eta>0' = As0' ! i \\<cdot>a \\<eta>", "by simp"], ["proof (state)\nthis:\n  As0' ! i \\<cdot>a \\<eta>0' = As0' ! i \\<cdot>a \\<eta>\n\ngoal (1 subgoal):\n 1. i < length (As0' \\<cdot>al \\<eta>) \\<Longrightarrow>\n    (As0' \\<cdot>al \\<eta>) ! i = As ! i", "then"], ["proof (chain)\npicking this:\n  As0' ! i \\<cdot>a \\<eta>0' = As0' ! i \\<cdot>a \\<eta>", "show \"(As0' \\<cdot>al \\<eta>) ! i = As ! i\""], ["proof (prove)\nusing this:\n  As0' ! i \\<cdot>a \\<eta>0' = As0' ! i \\<cdot>a \\<eta>\n\ngoal (1 subgoal):\n 1. (As0' \\<cdot>al \\<eta>) ! i = As ! i", "using As0'_As \\<open>length As0' = n\\<close> a"], ["proof (prove)\nusing this:\n  As0' ! i \\<cdot>a \\<eta>0' = As0' ! i \\<cdot>a \\<eta>\n  As0' \\<cdot>al \\<eta>0' = As\n  length As0' = n\n  i < length (As0' \\<cdot>al \\<eta>)\n\ngoal (1 subgoal):\n 1. (As0' \\<cdot>al \\<eta>) ! i = As ! i", "by auto"], ["proof (state)\nthis:\n  (As0' \\<cdot>al \\<eta>) ! i = As ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i < length (As0' \\<cdot>al \\<eta>) \\<Longrightarrow>\n  (As0' \\<cdot>al \\<eta>) ! i = As ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  As0' \\<cdot>al \\<eta> = As\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "interpret selection"], ["proof (prove)\ngoal (1 subgoal):\n 1. selection S", "by (rule select)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"S DA0' \\<cdot> \\<eta> = S_M S M DA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S DA0' \\<cdot> \\<eta> = S_M S M DA", "using \\<open>S DA0' \\<cdot> \\<eta>0' = S_M S M DA\\<close> \\<eta>_p S.S_selects_subseteq"], ["proof (prove)\nusing this:\n  S DA0' \\<cdot> \\<eta>0' = S_M S M DA\n  \\<forall>i<Suc n.\n     \\<forall>S.\n        S \\<subseteq># (DA0' # CAs0') ! i \\<longrightarrow>\n        S \\<cdot> (\\<eta>0' # \\<eta>s0') ! i = S \\<cdot> \\<eta>\n  S ?C \\<subseteq># ?C\n\ngoal (1 subgoal):\n 1. S DA0' \\<cdot> \\<eta> = S_M S M DA", "by auto"], ["proof (state)\nthis:\n  S DA0' \\<cdot> \\<eta> = S_M S M DA\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "from \\<eta>_p"], ["proof (chain)\npicking this:\n  \\<forall>i<Suc n.\n     \\<forall>S.\n        S \\<subseteq># (DA0' # CAs0') ! i \\<longrightarrow>\n        S \\<cdot> (\\<eta>0' # \\<eta>s0') ! i = S \\<cdot> \\<eta>", "have \\<eta>_p_CAs0': \"\\<forall>i < n. (CAs0' ! i) \\<cdot> (\\<eta>s0' ! i) = (CAs0'! i) \\<cdot> \\<eta>\""], ["proof (prove)\nusing this:\n  \\<forall>i<Suc n.\n     \\<forall>S.\n        S \\<subseteq># (DA0' # CAs0') ! i \\<longrightarrow>\n        S \\<cdot> (\\<eta>0' # \\<eta>s0') ! i = S \\<cdot> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<forall>i<n. CAs0' ! i \\<cdot> \\<eta>s0' ! i = CAs0' ! i \\<cdot> \\<eta>", "using n"], ["proof (prove)\nusing this:\n  \\<forall>i<Suc n.\n     \\<forall>S.\n        S \\<subseteq># (DA0' # CAs0') ! i \\<longrightarrow>\n        S \\<cdot> (\\<eta>0' # \\<eta>s0') ! i = S \\<cdot> \\<eta>\n  length CAs0' = n\n  length \\<eta>s0' = n\n  length As0' = n\n  length AAs0' = n\n  length Cs0' = n\n  length (renamings_apart (DA0 # CAs0)) = Suc n\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length \\<rho>s = n\n\ngoal (1 subgoal):\n 1. \\<forall>i<n. CAs0' ! i \\<cdot> \\<eta>s0' ! i = CAs0' ! i \\<cdot> \\<eta>", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<n. CAs0' ! i \\<cdot> \\<eta>s0' ! i = CAs0' ! i \\<cdot> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<n. CAs0' ! i \\<cdot> \\<eta>s0' ! i = CAs0' ! i \\<cdot> \\<eta>", "have \"CAs0' \\<cdot>\\<cdot>cl \\<eta>s0' = CAs0' \\<cdot>cl \\<eta>\""], ["proof (prove)\nusing this:\n  \\<forall>i<n. CAs0' ! i \\<cdot> \\<eta>s0' ! i = CAs0' ! i \\<cdot> \\<eta>\n\ngoal (1 subgoal):\n 1. CAs0' \\<cdot>\\<cdot>cl \\<eta>s0' = CAs0' \\<cdot>cl \\<eta>", "using n"], ["proof (prove)\nusing this:\n  \\<forall>i<n. CAs0' ! i \\<cdot> \\<eta>s0' ! i = CAs0' ! i \\<cdot> \\<eta>\n  length CAs0' = n\n  length \\<eta>s0' = n\n  length As0' = n\n  length AAs0' = n\n  length Cs0' = n\n  length (renamings_apart (DA0 # CAs0)) = Suc n\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length \\<rho>s = n\n\ngoal (1 subgoal):\n 1. CAs0' \\<cdot>\\<cdot>cl \\<eta>s0' = CAs0' \\<cdot>cl \\<eta>", "by (auto intro: nth_equalityI)"], ["proof (state)\nthis:\n  CAs0' \\<cdot>\\<cdot>cl \\<eta>s0' = CAs0' \\<cdot>cl \\<eta>\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  CAs0' \\<cdot>\\<cdot>cl \\<eta>s0' = CAs0' \\<cdot>cl \\<eta>", "have CAs0'_\\<eta>_fo_CAs: \"CAs0' \\<cdot>cl \\<eta> = CAs\""], ["proof (prove)\nusing this:\n  CAs0' \\<cdot>\\<cdot>cl \\<eta>s0' = CAs0' \\<cdot>cl \\<eta>\n\ngoal (1 subgoal):\n 1. CAs0' \\<cdot>cl \\<eta> = CAs", "using CAs0'_CAs \\<eta>_p n"], ["proof (prove)\nusing this:\n  CAs0' \\<cdot>\\<cdot>cl \\<eta>s0' = CAs0' \\<cdot>cl \\<eta>\n  CAs0' \\<cdot>\\<cdot>cl \\<eta>s0' = CAs\n  \\<forall>i<Suc n.\n     \\<forall>S.\n        S \\<subseteq># (DA0' # CAs0') ! i \\<longrightarrow>\n        S \\<cdot> (\\<eta>0' # \\<eta>s0') ! i = S \\<cdot> \\<eta>\n  length CAs0' = n\n  length \\<eta>s0' = n\n  length As0' = n\n  length AAs0' = n\n  length Cs0' = n\n  length (renamings_apart (DA0 # CAs0)) = Suc n\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length \\<rho>s = n\n\ngoal (1 subgoal):\n 1. CAs0' \\<cdot>cl \\<eta> = CAs", "by auto"], ["proof (state)\nthis:\n  CAs0' \\<cdot>cl \\<eta> = CAs\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "from \\<eta>_p"], ["proof (chain)\npicking this:\n  \\<forall>i<Suc n.\n     \\<forall>S.\n        S \\<subseteq># (DA0' # CAs0') ! i \\<longrightarrow>\n        S \\<cdot> (\\<eta>0' # \\<eta>s0') ! i = S \\<cdot> \\<eta>", "have \"\\<forall>i < n. S (CAs0' ! i) \\<cdot> \\<eta>s0' ! i = S (CAs0' ! i) \\<cdot> \\<eta>\""], ["proof (prove)\nusing this:\n  \\<forall>i<Suc n.\n     \\<forall>S.\n        S \\<subseteq># (DA0' # CAs0') ! i \\<longrightarrow>\n        S \\<cdot> (\\<eta>0' # \\<eta>s0') ! i = S \\<cdot> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<forall>i<n.\n       S (CAs0' ! i) \\<cdot> \\<eta>s0' ! i = S (CAs0' ! i) \\<cdot> \\<eta>", "using S.S_selects_subseteq n"], ["proof (prove)\nusing this:\n  \\<forall>i<Suc n.\n     \\<forall>S.\n        S \\<subseteq># (DA0' # CAs0') ! i \\<longrightarrow>\n        S \\<cdot> (\\<eta>0' # \\<eta>s0') ! i = S \\<cdot> \\<eta>\n  S ?C \\<subseteq># ?C\n  length CAs0' = n\n  length \\<eta>s0' = n\n  length As0' = n\n  length AAs0' = n\n  length Cs0' = n\n  length (renamings_apart (DA0 # CAs0)) = Suc n\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length \\<rho>s = n\n\ngoal (1 subgoal):\n 1. \\<forall>i<n.\n       S (CAs0' ! i) \\<cdot> \\<eta>s0' ! i = S (CAs0' ! i) \\<cdot> \\<eta>", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<n.\n     S (CAs0' ! i) \\<cdot> \\<eta>s0' ! i = S (CAs0' ! i) \\<cdot> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<n.\n     S (CAs0' ! i) \\<cdot> \\<eta>s0' ! i = S (CAs0' ! i) \\<cdot> \\<eta>", "have \"map S CAs0' \\<cdot>\\<cdot>cl \\<eta>s0' = map S CAs0' \\<cdot>cl \\<eta>\""], ["proof (prove)\nusing this:\n  \\<forall>i<n.\n     S (CAs0' ! i) \\<cdot> \\<eta>s0' ! i = S (CAs0' ! i) \\<cdot> \\<eta>\n\ngoal (1 subgoal):\n 1. map S CAs0' \\<cdot>\\<cdot>cl \\<eta>s0' = map S CAs0' \\<cdot>cl \\<eta>", "using n"], ["proof (prove)\nusing this:\n  \\<forall>i<n.\n     S (CAs0' ! i) \\<cdot> \\<eta>s0' ! i = S (CAs0' ! i) \\<cdot> \\<eta>\n  length CAs0' = n\n  length \\<eta>s0' = n\n  length As0' = n\n  length AAs0' = n\n  length Cs0' = n\n  length (renamings_apart (DA0 # CAs0)) = Suc n\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length \\<rho>s = n\n\ngoal (1 subgoal):\n 1. map S CAs0' \\<cdot>\\<cdot>cl \\<eta>s0' = map S CAs0' \\<cdot>cl \\<eta>", "by (auto intro: nth_equalityI)"], ["proof (state)\nthis:\n  map S CAs0' \\<cdot>\\<cdot>cl \\<eta>s0' = map S CAs0' \\<cdot>cl \\<eta>\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  map S CAs0' \\<cdot>\\<cdot>cl \\<eta>s0' = map S CAs0' \\<cdot>cl \\<eta>", "have SCAs0'_\\<eta>_fo_SMCAs: \"map S CAs0' \\<cdot>cl \\<eta> = map (S_M S M) CAs\""], ["proof (prove)\nusing this:\n  map S CAs0' \\<cdot>\\<cdot>cl \\<eta>s0' = map S CAs0' \\<cdot>cl \\<eta>\n\ngoal (1 subgoal):\n 1. map S CAs0' \\<cdot>cl \\<eta> = map (S_M S M) CAs", "using \\<open>map S CAs0' \\<cdot>\\<cdot>cl \\<eta>s0' = map (S_M S M) CAs\\<close>"], ["proof (prove)\nusing this:\n  map S CAs0' \\<cdot>\\<cdot>cl \\<eta>s0' = map S CAs0' \\<cdot>cl \\<eta>\n  map S CAs0' \\<cdot>\\<cdot>cl \\<eta>s0' = map (S_M S M) CAs\n\ngoal (1 subgoal):\n 1. map S CAs0' \\<cdot>cl \\<eta> = map (S_M S M) CAs", "by auto"], ["proof (state)\nthis:\n  map S CAs0' \\<cdot>cl \\<eta> = map (S_M S M) CAs\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"Cs0' \\<cdot>cl \\<eta> = Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cs0' \\<cdot>cl \\<eta> = Cs", "proof (rule nth_equalityI)"], ["proof (state)\ngoal (2 subgoals):\n 1. length (Cs0' \\<cdot>cl \\<eta>) = length Cs\n 2. \\<And>i.\n       i < length (Cs0' \\<cdot>cl \\<eta>) \\<Longrightarrow>\n       (Cs0' \\<cdot>cl \\<eta>) ! i = Cs ! i", "show \"length (Cs0' \\<cdot>cl \\<eta>) = length Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (Cs0' \\<cdot>cl \\<eta>) = length Cs", "using n"], ["proof (prove)\nusing this:\n  length CAs0' = n\n  length \\<eta>s0' = n\n  length As0' = n\n  length AAs0' = n\n  length Cs0' = n\n  length (renamings_apart (DA0 # CAs0)) = Suc n\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length \\<rho>s = n\n\ngoal (1 subgoal):\n 1. length (Cs0' \\<cdot>cl \\<eta>) = length Cs", "by auto"], ["proof (state)\nthis:\n  length (Cs0' \\<cdot>cl \\<eta>) = length Cs\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (Cs0' \\<cdot>cl \\<eta>) \\<Longrightarrow>\n       (Cs0' \\<cdot>cl \\<eta>) ! i = Cs ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (Cs0' \\<cdot>cl \\<eta>) \\<Longrightarrow>\n       (Cs0' \\<cdot>cl \\<eta>) ! i = Cs ! i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (Cs0' \\<cdot>cl \\<eta>) \\<Longrightarrow>\n       (Cs0' \\<cdot>cl \\<eta>) ! i = Cs ! i", "show \"i<length (Cs0' \\<cdot>cl \\<eta>) \\<Longrightarrow> (Cs0' \\<cdot>cl \\<eta>) ! i = Cs ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length (Cs0' \\<cdot>cl \\<eta>) \\<Longrightarrow>\n    (Cs0' \\<cdot>cl \\<eta>) ! i = Cs ! i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. i < length (Cs0' \\<cdot>cl \\<eta>) \\<Longrightarrow>\n    (Cs0' \\<cdot>cl \\<eta>) ! i = Cs ! i", "assume \"i < length (Cs0' \\<cdot>cl \\<eta>)\""], ["proof (state)\nthis:\n  i < length (Cs0' \\<cdot>cl \\<eta>)\n\ngoal (1 subgoal):\n 1. i < length (Cs0' \\<cdot>cl \\<eta>) \\<Longrightarrow>\n    (Cs0' \\<cdot>cl \\<eta>) ! i = Cs ! i", "then"], ["proof (chain)\npicking this:\n  i < length (Cs0' \\<cdot>cl \\<eta>)", "have a: \"i < n\""], ["proof (prove)\nusing this:\n  i < length (Cs0' \\<cdot>cl \\<eta>)\n\ngoal (1 subgoal):\n 1. i < n", "using n"], ["proof (prove)\nusing this:\n  i < length (Cs0' \\<cdot>cl \\<eta>)\n  length CAs0' = n\n  length \\<eta>s0' = n\n  length As0' = n\n  length AAs0' = n\n  length Cs0' = n\n  length (renamings_apart (DA0 # CAs0)) = Suc n\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length \\<rho>s = n\n\ngoal (1 subgoal):\n 1. i < n", "by force"], ["proof (state)\nthis:\n  i < n\n\ngoal (1 subgoal):\n 1. i < length (Cs0' \\<cdot>cl \\<eta>) \\<Longrightarrow>\n    (Cs0' \\<cdot>cl \\<eta>) ! i = Cs ! i", "have \"(Cs0' \\<cdot>\\<cdot>cl \\<eta>s0') ! i = Cs ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Cs0' \\<cdot>\\<cdot>cl \\<eta>s0') ! i = Cs ! i", "using Cs0'_Cs a n"], ["proof (prove)\nusing this:\n  Cs0' \\<cdot>\\<cdot>cl \\<eta>s0' = Cs\n  i < n\n  length CAs0' = n\n  length \\<eta>s0' = n\n  length As0' = n\n  length AAs0' = n\n  length Cs0' = n\n  length (renamings_apart (DA0 # CAs0)) = Suc n\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length \\<rho>s = n\n\ngoal (1 subgoal):\n 1. (Cs0' \\<cdot>\\<cdot>cl \\<eta>s0') ! i = Cs ! i", "by force"], ["proof (state)\nthis:\n  (Cs0' \\<cdot>\\<cdot>cl \\<eta>s0') ! i = Cs ! i\n\ngoal (1 subgoal):\n 1. i < length (Cs0' \\<cdot>cl \\<eta>) \\<Longrightarrow>\n    (Cs0' \\<cdot>cl \\<eta>) ! i = Cs ! i", "moreover"], ["proof (state)\nthis:\n  (Cs0' \\<cdot>\\<cdot>cl \\<eta>s0') ! i = Cs ! i\n\ngoal (1 subgoal):\n 1. i < length (Cs0' \\<cdot>cl \\<eta>) \\<Longrightarrow>\n    (Cs0' \\<cdot>cl \\<eta>) ! i = Cs ! i", "have \\<eta>_p_CAs0': \"\\<forall>S. S \\<subseteq># CAs0' ! i \\<longrightarrow> S \\<cdot> \\<eta>s0' ! i = S \\<cdot> \\<eta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>S.\n       S \\<subseteq># CAs0' ! i \\<longrightarrow>\n       S \\<cdot> \\<eta>s0' ! i = S \\<cdot> \\<eta>", "using \\<eta>_p a"], ["proof (prove)\nusing this:\n  \\<forall>i<Suc n.\n     \\<forall>S.\n        S \\<subseteq># (DA0' # CAs0') ! i \\<longrightarrow>\n        S \\<cdot> (\\<eta>0' # \\<eta>s0') ! i = S \\<cdot> \\<eta>\n  i < n\n\ngoal (1 subgoal):\n 1. \\<forall>S.\n       S \\<subseteq># CAs0' ! i \\<longrightarrow>\n       S \\<cdot> \\<eta>s0' ! i = S \\<cdot> \\<eta>", "by force"], ["proof (state)\nthis:\n  \\<forall>S.\n     S \\<subseteq># CAs0' ! i \\<longrightarrow>\n     S \\<cdot> \\<eta>s0' ! i = S \\<cdot> \\<eta>\n\ngoal (1 subgoal):\n 1. i < length (Cs0' \\<cdot>cl \\<eta>) \\<Longrightarrow>\n    (Cs0' \\<cdot>cl \\<eta>) ! i = Cs ! i", "have \"Cs0' ! i \\<cdot> \\<eta>s0' ! i = (Cs0' \\<cdot>cl \\<eta>) ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cs0' ! i \\<cdot> \\<eta>s0' ! i = (Cs0' \\<cdot>cl \\<eta>) ! i", "using \\<eta>_p_CAs0' \\<open>\\<forall>i<n. Cs0' ! i \\<subseteq># CAs0' ! i\\<close> a n"], ["proof (prove)\nusing this:\n  \\<forall>S.\n     S \\<subseteq># CAs0' ! i \\<longrightarrow>\n     S \\<cdot> \\<eta>s0' ! i = S \\<cdot> \\<eta>\n  \\<forall>i<n. Cs0' ! i \\<subseteq># CAs0' ! i\n  i < n\n  length CAs0' = n\n  length \\<eta>s0' = n\n  length As0' = n\n  length AAs0' = n\n  length Cs0' = n\n  length (renamings_apart (DA0 # CAs0)) = Suc n\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length \\<rho>s = n\n\ngoal (1 subgoal):\n 1. Cs0' ! i \\<cdot> \\<eta>s0' ! i = (Cs0' \\<cdot>cl \\<eta>) ! i", "by force"], ["proof (state)\nthis:\n  Cs0' ! i \\<cdot> \\<eta>s0' ! i = (Cs0' \\<cdot>cl \\<eta>) ! i\n\ngoal (1 subgoal):\n 1. i < length (Cs0' \\<cdot>cl \\<eta>) \\<Longrightarrow>\n    (Cs0' \\<cdot>cl \\<eta>) ! i = Cs ! i", "then"], ["proof (chain)\npicking this:\n  Cs0' ! i \\<cdot> \\<eta>s0' ! i = (Cs0' \\<cdot>cl \\<eta>) ! i", "have \"(Cs0' \\<cdot>\\<cdot>cl \\<eta>s0') ! i = (Cs0' \\<cdot>cl \\<eta>) ! i \""], ["proof (prove)\nusing this:\n  Cs0' ! i \\<cdot> \\<eta>s0' ! i = (Cs0' \\<cdot>cl \\<eta>) ! i\n\ngoal (1 subgoal):\n 1. (Cs0' \\<cdot>\\<cdot>cl \\<eta>s0') ! i = (Cs0' \\<cdot>cl \\<eta>) ! i", "using a n"], ["proof (prove)\nusing this:\n  Cs0' ! i \\<cdot> \\<eta>s0' ! i = (Cs0' \\<cdot>cl \\<eta>) ! i\n  i < n\n  length CAs0' = n\n  length \\<eta>s0' = n\n  length As0' = n\n  length AAs0' = n\n  length Cs0' = n\n  length (renamings_apart (DA0 # CAs0)) = Suc n\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length \\<rho>s = n\n\ngoal (1 subgoal):\n 1. (Cs0' \\<cdot>\\<cdot>cl \\<eta>s0') ! i = (Cs0' \\<cdot>cl \\<eta>) ! i", "by force"], ["proof (state)\nthis:\n  (Cs0' \\<cdot>\\<cdot>cl \\<eta>s0') ! i = (Cs0' \\<cdot>cl \\<eta>) ! i\n\ngoal (1 subgoal):\n 1. i < length (Cs0' \\<cdot>cl \\<eta>) \\<Longrightarrow>\n    (Cs0' \\<cdot>cl \\<eta>) ! i = Cs ! i", "ultimately"], ["proof (chain)\npicking this:\n  (Cs0' \\<cdot>\\<cdot>cl \\<eta>s0') ! i = Cs ! i\n  (Cs0' \\<cdot>\\<cdot>cl \\<eta>s0') ! i = (Cs0' \\<cdot>cl \\<eta>) ! i", "show \"(Cs0' \\<cdot>cl \\<eta>) ! i = Cs ! i\""], ["proof (prove)\nusing this:\n  (Cs0' \\<cdot>\\<cdot>cl \\<eta>s0') ! i = Cs ! i\n  (Cs0' \\<cdot>\\<cdot>cl \\<eta>s0') ! i = (Cs0' \\<cdot>cl \\<eta>) ! i\n\ngoal (1 subgoal):\n 1. (Cs0' \\<cdot>cl \\<eta>) ! i = Cs ! i", "by auto"], ["proof (state)\nthis:\n  (Cs0' \\<cdot>cl \\<eta>) ! i = Cs ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i < length (Cs0' \\<cdot>cl \\<eta>) \\<Longrightarrow>\n  (Cs0' \\<cdot>cl \\<eta>) ! i = Cs ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Cs0' \\<cdot>cl \\<eta> = Cs\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have AAs0'_AAs: \"AAs0' \\<cdot>aml \\<eta> = AAs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AAs0' \\<cdot>aml \\<eta> = AAs", "proof (rule nth_equalityI)"], ["proof (state)\ngoal (2 subgoals):\n 1. length (AAs0' \\<cdot>aml \\<eta>) = length AAs\n 2. \\<And>i.\n       i < length (AAs0' \\<cdot>aml \\<eta>) \\<Longrightarrow>\n       (AAs0' \\<cdot>aml \\<eta>) ! i = AAs ! i", "show \"length (AAs0' \\<cdot>aml \\<eta>) = length AAs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (AAs0' \\<cdot>aml \\<eta>) = length AAs", "using n"], ["proof (prove)\nusing this:\n  length CAs0' = n\n  length \\<eta>s0' = n\n  length As0' = n\n  length AAs0' = n\n  length Cs0' = n\n  length (renamings_apart (DA0 # CAs0)) = Suc n\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length \\<rho>s = n\n\ngoal (1 subgoal):\n 1. length (AAs0' \\<cdot>aml \\<eta>) = length AAs", "by auto"], ["proof (state)\nthis:\n  length (AAs0' \\<cdot>aml \\<eta>) = length AAs\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (AAs0' \\<cdot>aml \\<eta>) \\<Longrightarrow>\n       (AAs0' \\<cdot>aml \\<eta>) ! i = AAs ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (AAs0' \\<cdot>aml \\<eta>) \\<Longrightarrow>\n       (AAs0' \\<cdot>aml \\<eta>) ! i = AAs ! i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (AAs0' \\<cdot>aml \\<eta>) \\<Longrightarrow>\n       (AAs0' \\<cdot>aml \\<eta>) ! i = AAs ! i", "show \"i<length (AAs0' \\<cdot>aml \\<eta>) \\<Longrightarrow> (AAs0' \\<cdot>aml \\<eta>) ! i = AAs ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length (AAs0' \\<cdot>aml \\<eta>) \\<Longrightarrow>\n    (AAs0' \\<cdot>aml \\<eta>) ! i = AAs ! i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. i < length (AAs0' \\<cdot>aml \\<eta>) \\<Longrightarrow>\n    (AAs0' \\<cdot>aml \\<eta>) ! i = AAs ! i", "assume a: \"i < length (AAs0' \\<cdot>aml \\<eta>)\""], ["proof (state)\nthis:\n  i < length (AAs0' \\<cdot>aml \\<eta>)\n\ngoal (1 subgoal):\n 1. i < length (AAs0' \\<cdot>aml \\<eta>) \\<Longrightarrow>\n    (AAs0' \\<cdot>aml \\<eta>) ! i = AAs ! i", "then"], ["proof (chain)\npicking this:\n  i < length (AAs0' \\<cdot>aml \\<eta>)", "have \"i < n\""], ["proof (prove)\nusing this:\n  i < length (AAs0' \\<cdot>aml \\<eta>)\n\ngoal (1 subgoal):\n 1. i < n", "using n"], ["proof (prove)\nusing this:\n  i < length (AAs0' \\<cdot>aml \\<eta>)\n  length CAs0' = n\n  length \\<eta>s0' = n\n  length As0' = n\n  length AAs0' = n\n  length Cs0' = n\n  length (renamings_apart (DA0 # CAs0)) = Suc n\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length \\<rho>s = n\n\ngoal (1 subgoal):\n 1. i < n", "by force"], ["proof (state)\nthis:\n  i < n\n\ngoal (1 subgoal):\n 1. i < length (AAs0' \\<cdot>aml \\<eta>) \\<Longrightarrow>\n    (AAs0' \\<cdot>aml \\<eta>) ! i = AAs ! i", "then"], ["proof (chain)\npicking this:\n  i < n", "have \"\\<forall>A. A \\<in> atms_of ((DA0' # CAs0') ! Suc i) \\<longrightarrow> A \\<cdot>a (\\<eta>0' # \\<eta>s0') ! Suc i = A \\<cdot>a \\<eta>\""], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. \\<forall>A.\n       A \\<in> atms_of ((DA0' # CAs0') ! Suc i) \\<longrightarrow>\n       A \\<cdot>a (\\<eta>0' # \\<eta>s0') ! Suc i = A \\<cdot>a \\<eta>", "using \\<eta>_p_atm n"], ["proof (prove)\nusing this:\n  i < n\n  \\<forall>i<Suc n.\n     \\<forall>A.\n        A \\<in> atms_of ((DA0' # CAs0') ! i) \\<longrightarrow>\n        A \\<cdot>a (\\<eta>0' # \\<eta>s0') ! i = A \\<cdot>a \\<eta>\n  length CAs0' = n\n  length \\<eta>s0' = n\n  length As0' = n\n  length AAs0' = n\n  length Cs0' = n\n  length (renamings_apart (DA0 # CAs0)) = Suc n\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length \\<rho>s = n\n\ngoal (1 subgoal):\n 1. \\<forall>A.\n       A \\<in> atms_of ((DA0' # CAs0') ! Suc i) \\<longrightarrow>\n       A \\<cdot>a (\\<eta>0' # \\<eta>s0') ! Suc i = A \\<cdot>a \\<eta>", "by force"], ["proof (state)\nthis:\n  \\<forall>A.\n     A \\<in> atms_of ((DA0' # CAs0') ! Suc i) \\<longrightarrow>\n     A \\<cdot>a (\\<eta>0' # \\<eta>s0') ! Suc i = A \\<cdot>a \\<eta>\n\ngoal (1 subgoal):\n 1. i < length (AAs0' \\<cdot>aml \\<eta>) \\<Longrightarrow>\n    (AAs0' \\<cdot>aml \\<eta>) ! i = AAs ! i", "then"], ["proof (chain)\npicking this:\n  \\<forall>A.\n     A \\<in> atms_of ((DA0' # CAs0') ! Suc i) \\<longrightarrow>\n     A \\<cdot>a (\\<eta>0' # \\<eta>s0') ! Suc i = A \\<cdot>a \\<eta>", "have A_eq: \"\\<forall>A. A \\<in> atms_of (CAs0' ! i) \\<longrightarrow> A \\<cdot>a \\<eta>s0' ! i = A \\<cdot>a \\<eta>\""], ["proof (prove)\nusing this:\n  \\<forall>A.\n     A \\<in> atms_of ((DA0' # CAs0') ! Suc i) \\<longrightarrow>\n     A \\<cdot>a (\\<eta>0' # \\<eta>s0') ! Suc i = A \\<cdot>a \\<eta>\n\ngoal (1 subgoal):\n 1. \\<forall>A.\n       A \\<in> atms_of (CAs0' ! i) \\<longrightarrow>\n       A \\<cdot>a \\<eta>s0' ! i = A \\<cdot>a \\<eta>", "by auto"], ["proof (state)\nthis:\n  \\<forall>A.\n     A \\<in> atms_of (CAs0' ! i) \\<longrightarrow>\n     A \\<cdot>a \\<eta>s0' ! i = A \\<cdot>a \\<eta>\n\ngoal (1 subgoal):\n 1. i < length (AAs0' \\<cdot>aml \\<eta>) \\<Longrightarrow>\n    (AAs0' \\<cdot>aml \\<eta>) ! i = AAs ! i", "have AAs_CAs0': \"\\<forall>A \\<in># AAs0' ! i. A \\<in> atms_of (CAs0' ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>#AAs0' ! i. A \\<in> atms_of (CAs0' ! i)", "using AAs0'_in_atms_of_CAs0'"], ["proof (prove)\nusing this:\n  \\<forall>i<n. \\<forall>A\\<in>#AAs0' ! i. A \\<in> atms_of (CAs0' ! i)\n\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>#AAs0' ! i. A \\<in> atms_of (CAs0' ! i)", "unfolding atms_of_def"], ["proof (prove)\nusing this:\n  \\<forall>i<n.\n     \\<forall>A\\<in>#AAs0' ! i. A \\<in> atm_of ` set_mset (CAs0' ! i)\n\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>#AAs0' ! i. A \\<in> atm_of ` set_mset (CAs0' ! i)", "using a n"], ["proof (prove)\nusing this:\n  \\<forall>i<n.\n     \\<forall>A\\<in>#AAs0' ! i. A \\<in> atm_of ` set_mset (CAs0' ! i)\n  i < length (AAs0' \\<cdot>aml \\<eta>)\n  length CAs0' = n\n  length \\<eta>s0' = n\n  length As0' = n\n  length AAs0' = n\n  length Cs0' = n\n  length (renamings_apart (DA0 # CAs0)) = Suc n\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length \\<rho>s = n\n\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>#AAs0' ! i. A \\<in> atm_of ` set_mset (CAs0' ! i)", "by force"], ["proof (state)\nthis:\n  \\<forall>A\\<in>#AAs0' ! i. A \\<in> atms_of (CAs0' ! i)\n\ngoal (1 subgoal):\n 1. i < length (AAs0' \\<cdot>aml \\<eta>) \\<Longrightarrow>\n    (AAs0' \\<cdot>aml \\<eta>) ! i = AAs ! i", "then"], ["proof (chain)\npicking this:\n  \\<forall>A\\<in>#AAs0' ! i. A \\<in> atms_of (CAs0' ! i)", "have \"AAs0' ! i \\<cdot>am  \\<eta>s0' ! i = AAs0' ! i \\<cdot>am \\<eta>\""], ["proof (prove)\nusing this:\n  \\<forall>A\\<in>#AAs0' ! i. A \\<in> atms_of (CAs0' ! i)\n\ngoal (1 subgoal):\n 1. AAs0' ! i \\<cdot>am \\<eta>s0' ! i = AAs0' ! i \\<cdot>am \\<eta>", "unfolding subst_atm_mset_def"], ["proof (prove)\nusing this:\n  \\<forall>A\\<in>#AAs0' ! i. A \\<in> atms_of (CAs0' ! i)\n\ngoal (1 subgoal):\n 1. {#A \\<cdot>a \\<eta>s0' ! i. A \\<in># AAs0' ! i#} =\n    {#A \\<cdot>a \\<eta>. A \\<in># AAs0' ! i#}", "using A_eq"], ["proof (prove)\nusing this:\n  \\<forall>A\\<in>#AAs0' ! i. A \\<in> atms_of (CAs0' ! i)\n  \\<forall>A.\n     A \\<in> atms_of (CAs0' ! i) \\<longrightarrow>\n     A \\<cdot>a \\<eta>s0' ! i = A \\<cdot>a \\<eta>\n\ngoal (1 subgoal):\n 1. {#A \\<cdot>a \\<eta>s0' ! i. A \\<in># AAs0' ! i#} =\n    {#A \\<cdot>a \\<eta>. A \\<in># AAs0' ! i#}", "unfolding subst_atm_mset_def"], ["proof (prove)\nusing this:\n  \\<forall>A\\<in>#AAs0' ! i. A \\<in> atms_of (CAs0' ! i)\n  \\<forall>A.\n     A \\<in> atms_of (CAs0' ! i) \\<longrightarrow>\n     A \\<cdot>a \\<eta>s0' ! i = A \\<cdot>a \\<eta>\n\ngoal (1 subgoal):\n 1. {#A \\<cdot>a \\<eta>s0' ! i. A \\<in># AAs0' ! i#} =\n    {#A \\<cdot>a \\<eta>. A \\<in># AAs0' ! i#}", "by auto"], ["proof (state)\nthis:\n  AAs0' ! i \\<cdot>am \\<eta>s0' ! i = AAs0' ! i \\<cdot>am \\<eta>\n\ngoal (1 subgoal):\n 1. i < length (AAs0' \\<cdot>aml \\<eta>) \\<Longrightarrow>\n    (AAs0' \\<cdot>aml \\<eta>) ! i = AAs ! i", "then"], ["proof (chain)\npicking this:\n  AAs0' ! i \\<cdot>am \\<eta>s0' ! i = AAs0' ! i \\<cdot>am \\<eta>", "show \"(AAs0' \\<cdot>aml \\<eta>) ! i = AAs ! i\""], ["proof (prove)\nusing this:\n  AAs0' ! i \\<cdot>am \\<eta>s0' ! i = AAs0' ! i \\<cdot>am \\<eta>\n\ngoal (1 subgoal):\n 1. (AAs0' \\<cdot>aml \\<eta>) ! i = AAs ! i", "using AAs0'_AAs \\<open>length AAs0' = n\\<close> \\<open>length \\<eta>s0' = n\\<close> a"], ["proof (prove)\nusing this:\n  AAs0' ! i \\<cdot>am \\<eta>s0' ! i = AAs0' ! i \\<cdot>am \\<eta>\n  AAs0' \\<cdot>\\<cdot>aml \\<eta>s0' = AAs\n  length AAs0' = n\n  length \\<eta>s0' = n\n  i < length (AAs0' \\<cdot>aml \\<eta>)\n\ngoal (1 subgoal):\n 1. (AAs0' \\<cdot>aml \\<eta>) ! i = AAs ! i", "by auto"], ["proof (state)\nthis:\n  (AAs0' \\<cdot>aml \\<eta>) ! i = AAs ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i < length (AAs0' \\<cdot>aml \\<eta>) \\<Longrightarrow>\n  (AAs0' \\<cdot>aml \\<eta>) ! i = AAs ! i\n\ngoal:\nNo subgoals!", "qed\n\n  \\<comment> \\<open>Obtain MGU and substitution\\<close>"], ["proof (state)\nthis:\n  AAs0' \\<cdot>aml \\<eta> = AAs\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain \\<tau> \\<phi> where \\<tau>\\<phi>:\n    \"Some \\<tau> = mgu (set_mset ` set (map2 add_mset As0' AAs0'))\"\n    \"\\<tau> \\<odot> \\<phi> = \\<eta> \\<odot> \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<tau> \\<phi>.\n        \\<lbrakk>Some \\<tau> =\n                 mgu (set_mset ` set (Map2.map2 add_mset As0' AAs0'));\n         \\<tau> \\<odot> \\<phi> = \\<eta> \\<odot> \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>\\<tau> \\<phi>.\n        \\<lbrakk>Some \\<tau> =\n                 mgu (set_mset ` set (Map2.map2 add_mset As0' AAs0'));\n         \\<tau> \\<odot> \\<phi> = \\<eta> \\<odot> \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have uu: \"is_unifiers \\<sigma> (set_mset ` set (map2 add_mset (As0' \\<cdot>al \\<eta>) (AAs0' \\<cdot>aml \\<eta>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unifiers \\<sigma>\n     (set_mset `\n      set (Map2.map2 add_mset (As0' \\<cdot>al \\<eta>)\n            (AAs0' \\<cdot>aml \\<eta>)))", "using mgu mgu_sound is_mgu_def"], ["proof (prove)\nusing this:\n  Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs))\n  \\<lbrakk>finite ?AAA; \\<forall>AA\\<in>?AAA. finite AA;\n   mgu ?AAA = Some ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> is_mgu ?\\<sigma> ?AAA\n  is_mgu ?\\<sigma> ?AAA =\n  (is_unifiers ?\\<sigma> ?AAA \\<and>\n   (\\<forall>\\<tau>.\n       is_unifiers \\<tau> ?AAA \\<longrightarrow>\n       (\\<exists>\\<gamma>. \\<tau> = ?\\<sigma> \\<odot> \\<gamma>)))\n\ngoal (1 subgoal):\n 1. is_unifiers \\<sigma>\n     (set_mset `\n      set (Map2.map2 add_mset (As0' \\<cdot>al \\<eta>)\n            (AAs0' \\<cdot>aml \\<eta>)))", "unfolding \\<open>AAs0' \\<cdot>aml \\<eta> = AAs\\<close>"], ["proof (prove)\nusing this:\n  Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs))\n  \\<lbrakk>finite ?AAA; \\<forall>AA\\<in>?AAA. finite AA;\n   mgu ?AAA = Some ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> is_mgu ?\\<sigma> ?AAA\n  is_mgu ?\\<sigma> ?AAA =\n  (is_unifiers ?\\<sigma> ?AAA \\<and>\n   (\\<forall>\\<tau>.\n       is_unifiers \\<tau> ?AAA \\<longrightarrow>\n       (\\<exists>\\<gamma>. \\<tau> = ?\\<sigma> \\<odot> \\<gamma>)))\n\ngoal (1 subgoal):\n 1. is_unifiers \\<sigma>\n     (set_mset ` set (Map2.map2 add_mset (As0' \\<cdot>al \\<eta>) AAs))", "using \\<open>As0' \\<cdot>al \\<eta> = As\\<close>"], ["proof (prove)\nusing this:\n  Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs))\n  \\<lbrakk>finite ?AAA; \\<forall>AA\\<in>?AAA. finite AA;\n   mgu ?AAA = Some ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> is_mgu ?\\<sigma> ?AAA\n  is_mgu ?\\<sigma> ?AAA =\n  (is_unifiers ?\\<sigma> ?AAA \\<and>\n   (\\<forall>\\<tau>.\n       is_unifiers \\<tau> ?AAA \\<longrightarrow>\n       (\\<exists>\\<gamma>. \\<tau> = ?\\<sigma> \\<odot> \\<gamma>)))\n  As0' \\<cdot>al \\<eta> = As\n\ngoal (1 subgoal):\n 1. is_unifiers \\<sigma>\n     (set_mset ` set (Map2.map2 add_mset (As0' \\<cdot>al \\<eta>) AAs))", "by auto"], ["proof (state)\nthis:\n  is_unifiers \\<sigma>\n   (set_mset `\n    set (Map2.map2 add_mset (As0' \\<cdot>al \\<eta>)\n          (AAs0' \\<cdot>aml \\<eta>)))\n\ngoal (1 subgoal):\n 1. (\\<And>\\<tau> \\<phi>.\n        \\<lbrakk>Some \\<tau> =\n                 mgu (set_mset ` set (Map2.map2 add_mset As0' AAs0'));\n         \\<tau> \\<odot> \\<phi> = \\<eta> \\<odot> \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \\<eta>\\<sigma>uni: \"is_unifiers (\\<eta> \\<odot> \\<sigma>) (set_mset ` set (map2 add_mset As0' AAs0'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unifiers (\\<eta> \\<odot> \\<sigma>)\n     (set_mset ` set (Map2.map2 add_mset As0' AAs0'))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_unifiers (\\<eta> \\<odot> \\<sigma>)\n     (set_mset ` set (Map2.map2 add_mset As0' AAs0'))", "have \"set_mset ` set (map2 add_mset As0' AAs0' \\<cdot>aml \\<eta>) =\n        set_mset ` set (map2 add_mset As0' AAs0') \\<cdot>ass \\<eta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_mset ` set (Map2.map2 add_mset As0' AAs0' \\<cdot>aml \\<eta>) =\n    set_mset ` set (Map2.map2 add_mset As0' AAs0') \\<cdot>ass \\<eta>", "unfolding subst_atmss_def subst_atm_mset_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_mset `\n    set (map (\\<lambda>AA. AA \\<cdot>am \\<eta>)\n          (Map2.map2 add_mset As0' AAs0')) =\n    (\\<lambda>AA. AA \\<cdot>as \\<eta>) `\n    set_mset ` set (Map2.map2 add_mset As0' AAs0')", "using subst_atm_mset_def subst_atms_def"], ["proof (prove)\nusing this:\n  ?AA \\<cdot>am ?\\<sigma> = {#A \\<cdot>a ?\\<sigma>. A \\<in># ?AA#}\n  ?AA \\<cdot>as ?\\<sigma> = (\\<lambda>A. A \\<cdot>a ?\\<sigma>) ` ?AA\n\ngoal (1 subgoal):\n 1. set_mset `\n    set (map (\\<lambda>AA. AA \\<cdot>am \\<eta>)\n          (Map2.map2 add_mset As0' AAs0')) =\n    (\\<lambda>AA. AA \\<cdot>as \\<eta>) `\n    set_mset ` set (Map2.map2 add_mset As0' AAs0')", "by (simp add: image_image subst_atm_mset_def subst_atms_def)"], ["proof (state)\nthis:\n  set_mset ` set (Map2.map2 add_mset As0' AAs0' \\<cdot>aml \\<eta>) =\n  set_mset ` set (Map2.map2 add_mset As0' AAs0') \\<cdot>ass \\<eta>\n\ngoal (1 subgoal):\n 1. is_unifiers (\\<eta> \\<odot> \\<sigma>)\n     (set_mset ` set (Map2.map2 add_mset As0' AAs0'))", "then"], ["proof (chain)\npicking this:\n  set_mset ` set (Map2.map2 add_mset As0' AAs0' \\<cdot>aml \\<eta>) =\n  set_mset ` set (Map2.map2 add_mset As0' AAs0') \\<cdot>ass \\<eta>", "have \"is_unifiers \\<sigma> (set_mset ` set (map2 add_mset As0' AAs0') \\<cdot>ass \\<eta>)\""], ["proof (prove)\nusing this:\n  set_mset ` set (Map2.map2 add_mset As0' AAs0' \\<cdot>aml \\<eta>) =\n  set_mset ` set (Map2.map2 add_mset As0' AAs0') \\<cdot>ass \\<eta>\n\ngoal (1 subgoal):\n 1. is_unifiers \\<sigma>\n     (set_mset ` set (Map2.map2 add_mset As0' AAs0') \\<cdot>ass \\<eta>)", "using uu"], ["proof (prove)\nusing this:\n  set_mset ` set (Map2.map2 add_mset As0' AAs0' \\<cdot>aml \\<eta>) =\n  set_mset ` set (Map2.map2 add_mset As0' AAs0') \\<cdot>ass \\<eta>\n  is_unifiers \\<sigma>\n   (set_mset `\n    set (Map2.map2 add_mset (As0' \\<cdot>al \\<eta>)\n          (AAs0' \\<cdot>aml \\<eta>)))\n\ngoal (1 subgoal):\n 1. is_unifiers \\<sigma>\n     (set_mset ` set (Map2.map2 add_mset As0' AAs0') \\<cdot>ass \\<eta>)", "by (auto simp: n map2_add_mset_map)"], ["proof (state)\nthis:\n  is_unifiers \\<sigma>\n   (set_mset ` set (Map2.map2 add_mset As0' AAs0') \\<cdot>ass \\<eta>)\n\ngoal (1 subgoal):\n 1. is_unifiers (\\<eta> \\<odot> \\<sigma>)\n     (set_mset ` set (Map2.map2 add_mset As0' AAs0'))", "then"], ["proof (chain)\npicking this:\n  is_unifiers \\<sigma>\n   (set_mset ` set (Map2.map2 add_mset As0' AAs0') \\<cdot>ass \\<eta>)", "show ?thesis"], ["proof (prove)\nusing this:\n  is_unifiers \\<sigma>\n   (set_mset ` set (Map2.map2 add_mset As0' AAs0') \\<cdot>ass \\<eta>)\n\ngoal (1 subgoal):\n 1. is_unifiers (\\<eta> \\<odot> \\<sigma>)\n     (set_mset ` set (Map2.map2 add_mset As0' AAs0'))", "using is_unifiers_comp"], ["proof (prove)\nusing this:\n  is_unifiers \\<sigma>\n   (set_mset ` set (Map2.map2 add_mset As0' AAs0') \\<cdot>ass \\<eta>)\n  is_unifiers ?\\<sigma>\n   (set_mset ` set (Map2.map2 add_mset ?As ?Bs) \\<cdot>ass ?\\<eta>) =\n  is_unifiers (?\\<eta> \\<odot> ?\\<sigma>)\n   (set_mset ` set (Map2.map2 add_mset ?As ?Bs))\n\ngoal (1 subgoal):\n 1. is_unifiers (\\<eta> \\<odot> \\<sigma>)\n     (set_mset ` set (Map2.map2 add_mset As0' AAs0'))", "by auto"], ["proof (state)\nthis:\n  is_unifiers (\\<eta> \\<odot> \\<sigma>)\n   (set_mset ` set (Map2.map2 add_mset As0' AAs0'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_unifiers (\\<eta> \\<odot> \\<sigma>)\n   (set_mset ` set (Map2.map2 add_mset As0' AAs0'))\n\ngoal (1 subgoal):\n 1. (\\<And>\\<tau> \\<phi>.\n        \\<lbrakk>Some \\<tau> =\n                 mgu (set_mset ` set (Map2.map2 add_mset As0' AAs0'));\n         \\<tau> \\<odot> \\<phi> = \\<eta> \\<odot> \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  is_unifiers (\\<eta> \\<odot> \\<sigma>)\n   (set_mset ` set (Map2.map2 add_mset As0' AAs0'))", "obtain \\<tau> where\n      \\<tau>_p: \"Some \\<tau> = mgu (set_mset ` set (map2 add_mset As0' AAs0'))\""], ["proof (prove)\nusing this:\n  is_unifiers (\\<eta> \\<odot> \\<sigma>)\n   (set_mset ` set (Map2.map2 add_mset As0' AAs0'))\n\ngoal (1 subgoal):\n 1. (\\<And>\\<tau>.\n        Some \\<tau> =\n        mgu (set_mset `\n             set (Map2.map2 add_mset As0' AAs0')) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using mgu_complete"], ["proof (prove)\nusing this:\n  is_unifiers (\\<eta> \\<odot> \\<sigma>)\n   (set_mset ` set (Map2.map2 add_mset As0' AAs0'))\n  \\<lbrakk>finite ?AAA; \\<forall>AA\\<in>?AAA. finite AA;\n   is_unifiers ?\\<sigma> ?AAA\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<tau>. mgu ?AAA = Some \\<tau>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<tau>.\n        Some \\<tau> =\n        mgu (set_mset `\n             set (Map2.map2 add_mset As0' AAs0')) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis (mono_tags, hide_lams) List.finite_set finite_imageI finite_set_mset image_iff)"], ["proof (state)\nthis:\n  Some \\<tau> = mgu (set_mset ` set (Map2.map2 add_mset As0' AAs0'))\n\ngoal (1 subgoal):\n 1. (\\<And>\\<tau> \\<phi>.\n        \\<lbrakk>Some \\<tau> =\n                 mgu (set_mset ` set (Map2.map2 add_mset As0' AAs0'));\n         \\<tau> \\<odot> \\<phi> = \\<eta> \\<odot> \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  Some \\<tau> = mgu (set_mset ` set (Map2.map2 add_mset As0' AAs0'))\n\ngoal (1 subgoal):\n 1. (\\<And>\\<tau> \\<phi>.\n        \\<lbrakk>Some \\<tau> =\n                 mgu (set_mset ` set (Map2.map2 add_mset As0' AAs0'));\n         \\<tau> \\<odot> \\<phi> = \\<eta> \\<odot> \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  Some \\<tau> = mgu (set_mset ` set (Map2.map2 add_mset As0' AAs0'))", "obtain \\<phi> where \\<phi>_p: \"\\<tau> \\<odot> \\<phi> = \\<eta> \\<odot> \\<sigma>\""], ["proof (prove)\nusing this:\n  Some \\<tau> = mgu (set_mset ` set (Map2.map2 add_mset As0' AAs0'))\n\ngoal (1 subgoal):\n 1. (\\<And>\\<phi>.\n        \\<tau> \\<odot> \\<phi> = \\<eta> \\<odot> \\<sigma> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis (mono_tags, hide_lams) finite_set \\<eta>\\<sigma>uni finite_imageI finite_set_mset image_iff\n          mgu_sound set_mset_mset substitution_ops.is_mgu_def)"], ["proof (state)\nthis:\n  \\<tau> \\<odot> \\<phi> = \\<eta> \\<odot> \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<tau> \\<phi>.\n        \\<lbrakk>Some \\<tau> =\n                 mgu (set_mset ` set (Map2.map2 add_mset As0' AAs0'));\n         \\<tau> \\<odot> \\<phi> = \\<eta> \\<odot> \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "(* should be simpler *)"], ["proof (state)\nthis:\n  \\<tau> \\<odot> \\<phi> = \\<eta> \\<odot> \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<tau> \\<phi>.\n        \\<lbrakk>Some \\<tau> =\n                 mgu (set_mset ` set (Map2.map2 add_mset As0' AAs0'));\n         \\<tau> \\<odot> \\<phi> = \\<eta> \\<odot> \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  Some \\<tau> = mgu (set_mset ` set (Map2.map2 add_mset As0' AAs0'))\n  \\<tau> \\<odot> \\<phi> = \\<eta> \\<odot> \\<sigma>", "show thesis"], ["proof (prove)\nusing this:\n  Some \\<tau> = mgu (set_mset ` set (Map2.map2 add_mset As0' AAs0'))\n  \\<tau> \\<odot> \\<phi> = \\<eta> \\<odot> \\<sigma>\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  Some \\<tau> = mgu (set_mset ` set (Map2.map2 add_mset As0' AAs0'))\n  \\<tau> \\<odot> \\<phi> = \\<eta> \\<odot> \\<sigma>\n  \\<lbrakk>Some ?\\<tau> =\n           mgu (set_mset ` set (Map2.map2 add_mset As0' AAs0'));\n   ?\\<tau> \\<odot> ?\\<phi> = \\<eta> \\<odot> \\<sigma>\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed\n\n  \\<comment> \\<open>Lifting eligibility\\<close>"], ["proof (state)\nthis:\n  Some \\<tau> = mgu (set_mset ` set (Map2.map2 add_mset As0' AAs0'))\n  \\<tau> \\<odot> \\<phi> = \\<eta> \\<odot> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have eligible0': \"eligible S \\<tau> As0' (D0' + negs (mset As0'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eligible S \\<tau> As0' (D0' + negs (mset As0'))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eligible S \\<tau> As0' (D0' + negs (mset As0'))", "have \"S_M S M (D + negs (mset As)) = negs (mset As) \\<or> S_M S M (D + negs (mset As)) = {#} \\<and>\n      length As = 1 \\<and> maximal_wrt (As ! 0 \\<cdot>a \\<sigma>) ((D + negs (mset As)) \\<cdot> \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S_M S M (D + negs (mset As)) = negs (mset As) \\<or>\n    S_M S M (D + negs (mset As)) = {#} \\<and>\n    length As = 1 \\<and>\n    maximal_wrt (As ! 0 \\<cdot>a \\<sigma>)\n     ((D + negs (mset As)) \\<cdot> \\<sigma>)", "using eligible"], ["proof (prove)\nusing this:\n  eligible (S_M S M) \\<sigma> As (D + negs (mset As))\n\ngoal (1 subgoal):\n 1. S_M S M (D + negs (mset As)) = negs (mset As) \\<or>\n    S_M S M (D + negs (mset As)) = {#} \\<and>\n    length As = 1 \\<and>\n    maximal_wrt (As ! 0 \\<cdot>a \\<sigma>)\n     ((D + negs (mset As)) \\<cdot> \\<sigma>)", "unfolding eligible.simps"], ["proof (prove)\nusing this:\n  \\<exists>DA Asa \\<sigma>'.\n     \\<sigma> = \\<sigma>' \\<and>\n     As = Asa \\<and>\n     D + negs (mset As) = DA \\<and>\n     (S_M S M DA = negs (mset Asa) \\<or>\n      S_M S M DA = {#} \\<and>\n      length Asa = 1 \\<and>\n      maximal_wrt (Asa ! 0 \\<cdot>a \\<sigma>') (DA \\<cdot> \\<sigma>'))\n\ngoal (1 subgoal):\n 1. S_M S M (D + negs (mset As)) = negs (mset As) \\<or>\n    S_M S M (D + negs (mset As)) = {#} \\<and>\n    length As = 1 \\<and>\n    maximal_wrt (As ! 0 \\<cdot>a \\<sigma>)\n     ((D + negs (mset As)) \\<cdot> \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  S_M S M (D + negs (mset As)) = negs (mset As) \\<or>\n  S_M S M (D + negs (mset As)) = {#} \\<and>\n  length As = 1 \\<and>\n  maximal_wrt (As ! 0 \\<cdot>a \\<sigma>)\n   ((D + negs (mset As)) \\<cdot> \\<sigma>)\n\ngoal (1 subgoal):\n 1. eligible S \\<tau> As0' (D0' + negs (mset As0'))", "then"], ["proof (chain)\npicking this:\n  S_M S M (D + negs (mset As)) = negs (mset As) \\<or>\n  S_M S M (D + negs (mset As)) = {#} \\<and>\n  length As = 1 \\<and>\n  maximal_wrt (As ! 0 \\<cdot>a \\<sigma>)\n   ((D + negs (mset As)) \\<cdot> \\<sigma>)", "show ?thesis"], ["proof (prove)\nusing this:\n  S_M S M (D + negs (mset As)) = negs (mset As) \\<or>\n  S_M S M (D + negs (mset As)) = {#} \\<and>\n  length As = 1 \\<and>\n  maximal_wrt (As ! 0 \\<cdot>a \\<sigma>)\n   ((D + negs (mset As)) \\<cdot> \\<sigma>)\n\ngoal (1 subgoal):\n 1. eligible S \\<tau> As0' (D0' + negs (mset As0'))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. S_M S M (D + negs (mset As)) = negs (mset As) \\<Longrightarrow>\n    eligible S \\<tau> As0' (D0' + negs (mset As0'))\n 2. S_M S M (D + negs (mset As)) = {#} \\<and>\n    length As = 1 \\<and>\n    maximal_wrt (As ! 0 \\<cdot>a \\<sigma>)\n     ((D + negs (mset As)) \\<cdot> \\<sigma>) \\<Longrightarrow>\n    eligible S \\<tau> As0' (D0' + negs (mset As0'))", "assume \"S_M S M (D + negs (mset As)) = negs (mset As)\""], ["proof (state)\nthis:\n  S_M S M (D + negs (mset As)) = negs (mset As)\n\ngoal (2 subgoals):\n 1. S_M S M (D + negs (mset As)) = negs (mset As) \\<Longrightarrow>\n    eligible S \\<tau> As0' (D0' + negs (mset As0'))\n 2. S_M S M (D + negs (mset As)) = {#} \\<and>\n    length As = 1 \\<and>\n    maximal_wrt (As ! 0 \\<cdot>a \\<sigma>)\n     ((D + negs (mset As)) \\<cdot> \\<sigma>) \\<Longrightarrow>\n    eligible S \\<tau> As0' (D0' + negs (mset As0'))", "then"], ["proof (chain)\npicking this:\n  S_M S M (D + negs (mset As)) = negs (mset As)", "have \"S_M S M (D + negs (mset As)) \\<noteq> {#}\""], ["proof (prove)\nusing this:\n  S_M S M (D + negs (mset As)) = negs (mset As)\n\ngoal (1 subgoal):\n 1. S_M S M (D + negs (mset As)) \\<noteq> {#}", "using n"], ["proof (prove)\nusing this:\n  S_M S M (D + negs (mset As)) = negs (mset As)\n  length CAs0' = n\n  length \\<eta>s0' = n\n  length As0' = n\n  length AAs0' = n\n  length Cs0' = n\n  length (renamings_apart (DA0 # CAs0)) = Suc n\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length \\<rho>s = n\n\ngoal (1 subgoal):\n 1. S_M S M (D + negs (mset As)) \\<noteq> {#}", "by force"], ["proof (state)\nthis:\n  S_M S M (D + negs (mset As)) \\<noteq> {#}\n\ngoal (2 subgoals):\n 1. S_M S M (D + negs (mset As)) = negs (mset As) \\<Longrightarrow>\n    eligible S \\<tau> As0' (D0' + negs (mset As0'))\n 2. S_M S M (D + negs (mset As)) = {#} \\<and>\n    length As = 1 \\<and>\n    maximal_wrt (As ! 0 \\<cdot>a \\<sigma>)\n     ((D + negs (mset As)) \\<cdot> \\<sigma>) \\<Longrightarrow>\n    eligible S \\<tau> As0' (D0' + negs (mset As0'))", "then"], ["proof (chain)\npicking this:\n  S_M S M (D + negs (mset As)) \\<noteq> {#}", "have \"S (D0' + negs (mset As0')) = negs (mset As0')\""], ["proof (prove)\nusing this:\n  S_M S M (D + negs (mset As)) \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. S (D0' + negs (mset As0')) = negs (mset As0')", "using as0' DA0'_split"], ["proof (prove)\nusing this:\n  S_M S M (D + negs (mset As)) \\<noteq> {#}\n  S_M S M (D + negs (mset As)) \\<noteq> {#} \\<Longrightarrow>\n  negs (mset As0') = S DA0'\n  DA0' = D0' + negs (mset As0')\n\ngoal (1 subgoal):\n 1. S (D0' + negs (mset As0')) = negs (mset As0')", "by auto"], ["proof (state)\nthis:\n  S (D0' + negs (mset As0')) = negs (mset As0')\n\ngoal (2 subgoals):\n 1. S_M S M (D + negs (mset As)) = negs (mset As) \\<Longrightarrow>\n    eligible S \\<tau> As0' (D0' + negs (mset As0'))\n 2. S_M S M (D + negs (mset As)) = {#} \\<and>\n    length As = 1 \\<and>\n    maximal_wrt (As ! 0 \\<cdot>a \\<sigma>)\n     ((D + negs (mset As)) \\<cdot> \\<sigma>) \\<Longrightarrow>\n    eligible S \\<tau> As0' (D0' + negs (mset As0'))", "then"], ["proof (chain)\npicking this:\n  S (D0' + negs (mset As0')) = negs (mset As0')", "show ?thesis"], ["proof (prove)\nusing this:\n  S (D0' + negs (mset As0')) = negs (mset As0')\n\ngoal (1 subgoal):\n 1. eligible S \\<tau> As0' (D0' + negs (mset As0'))", "unfolding eligible.simps[simplified]"], ["proof (prove)\nusing this:\n  S (D0' + negs (mset As0')) = negs (mset As0')\n\ngoal (1 subgoal):\n 1. S (D0' + negs (mset As0')) = negs (mset As0') \\<or>\n    S (D0' + negs (mset As0')) = {#} \\<and>\n    length As0' = Suc 0 \\<and>\n    maximal_wrt (As0' ! 0 \\<cdot>a \\<tau>)\n     ((D0' + negs (mset As0')) \\<cdot> \\<tau>)", "by auto"], ["proof (state)\nthis:\n  eligible S \\<tau> As0' (D0' + negs (mset As0'))\n\ngoal (1 subgoal):\n 1. S_M S M (D + negs (mset As)) = {#} \\<and>\n    length As = 1 \\<and>\n    maximal_wrt (As ! 0 \\<cdot>a \\<sigma>)\n     ((D + negs (mset As)) \\<cdot> \\<sigma>) \\<Longrightarrow>\n    eligible S \\<tau> As0' (D0' + negs (mset As0'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. S_M S M (D + negs (mset As)) = {#} \\<and>\n    length As = 1 \\<and>\n    maximal_wrt (As ! 0 \\<cdot>a \\<sigma>)\n     ((D + negs (mset As)) \\<cdot> \\<sigma>) \\<Longrightarrow>\n    eligible S \\<tau> As0' (D0' + negs (mset As0'))", "assume asm: \"S_M S M (D + negs (mset As)) = {#} \\<and> length As = 1 \\<and>\n        maximal_wrt (As ! 0 \\<cdot>a \\<sigma>) ((D + negs (mset As)) \\<cdot> \\<sigma>)\""], ["proof (state)\nthis:\n  S_M S M (D + negs (mset As)) = {#} \\<and>\n  length As = 1 \\<and>\n  maximal_wrt (As ! 0 \\<cdot>a \\<sigma>)\n   ((D + negs (mset As)) \\<cdot> \\<sigma>)\n\ngoal (1 subgoal):\n 1. S_M S M (D + negs (mset As)) = {#} \\<and>\n    length As = 1 \\<and>\n    maximal_wrt (As ! 0 \\<cdot>a \\<sigma>)\n     ((D + negs (mset As)) \\<cdot> \\<sigma>) \\<Longrightarrow>\n    eligible S \\<tau> As0' (D0' + negs (mset As0'))", "then"], ["proof (chain)\npicking this:\n  S_M S M (D + negs (mset As)) = {#} \\<and>\n  length As = 1 \\<and>\n  maximal_wrt (As ! 0 \\<cdot>a \\<sigma>)\n   ((D + negs (mset As)) \\<cdot> \\<sigma>)", "have \"S (D0' + negs (mset As0')) = {#}\""], ["proof (prove)\nusing this:\n  S_M S M (D + negs (mset As)) = {#} \\<and>\n  length As = 1 \\<and>\n  maximal_wrt (As ! 0 \\<cdot>a \\<sigma>)\n   ((D + negs (mset As)) \\<cdot> \\<sigma>)\n\ngoal (1 subgoal):\n 1. S (D0' + negs (mset As0')) = {#}", "using \\<open>D0' \\<cdot> \\<eta> = D\\<close>[symmetric] \\<open>As0' \\<cdot>al \\<eta> = As\\<close>[symmetric] \\<open>S (DA0') \\<cdot> \\<eta> = S_M S M (DA)\\<close>\n          da DA0'_split subst_cls_empty_iff"], ["proof (prove)\nusing this:\n  S_M S M (D + negs (mset As)) = {#} \\<and>\n  length As = 1 \\<and>\n  maximal_wrt (As ! 0 \\<cdot>a \\<sigma>)\n   ((D + negs (mset As)) \\<cdot> \\<sigma>)\n  D = D0' \\<cdot> \\<eta>\n  As = As0' \\<cdot>al \\<eta>\n  S DA0' \\<cdot> \\<eta> = S_M S M DA\n  DA = D + negs (mset As)\n  DA0' = D0' + negs (mset As0')\n  (?C \\<cdot> ?\\<eta> = {#}) = (?C = {#})\n\ngoal (1 subgoal):\n 1. S (D0' + negs (mset As0')) = {#}", "by metis"], ["proof (state)\nthis:\n  S (D0' + negs (mset As0')) = {#}\n\ngoal (1 subgoal):\n 1. S_M S M (D + negs (mset As)) = {#} \\<and>\n    length As = 1 \\<and>\n    maximal_wrt (As ! 0 \\<cdot>a \\<sigma>)\n     ((D + negs (mset As)) \\<cdot> \\<sigma>) \\<Longrightarrow>\n    eligible S \\<tau> As0' (D0' + negs (mset As0'))", "moreover"], ["proof (state)\nthis:\n  S (D0' + negs (mset As0')) = {#}\n\ngoal (1 subgoal):\n 1. S_M S M (D + negs (mset As)) = {#} \\<and>\n    length As = 1 \\<and>\n    maximal_wrt (As ! 0 \\<cdot>a \\<sigma>)\n     ((D + negs (mset As)) \\<cdot> \\<sigma>) \\<Longrightarrow>\n    eligible S \\<tau> As0' (D0' + negs (mset As0'))", "from asm"], ["proof (chain)\npicking this:\n  S_M S M (D + negs (mset As)) = {#} \\<and>\n  length As = 1 \\<and>\n  maximal_wrt (As ! 0 \\<cdot>a \\<sigma>)\n   ((D + negs (mset As)) \\<cdot> \\<sigma>)", "have l: \"length As0' = 1\""], ["proof (prove)\nusing this:\n  S_M S M (D + negs (mset As)) = {#} \\<and>\n  length As = 1 \\<and>\n  maximal_wrt (As ! 0 \\<cdot>a \\<sigma>)\n   ((D + negs (mset As)) \\<cdot> \\<sigma>)\n\ngoal (1 subgoal):\n 1. length As0' = 1", "using \\<open>As0' \\<cdot>al \\<eta> = As\\<close>"], ["proof (prove)\nusing this:\n  S_M S M (D + negs (mset As)) = {#} \\<and>\n  length As = 1 \\<and>\n  maximal_wrt (As ! 0 \\<cdot>a \\<sigma>)\n   ((D + negs (mset As)) \\<cdot> \\<sigma>)\n  As0' \\<cdot>al \\<eta> = As\n\ngoal (1 subgoal):\n 1. length As0' = 1", "by auto"], ["proof (state)\nthis:\n  length As0' = 1\n\ngoal (1 subgoal):\n 1. S_M S M (D + negs (mset As)) = {#} \\<and>\n    length As = 1 \\<and>\n    maximal_wrt (As ! 0 \\<cdot>a \\<sigma>)\n     ((D + negs (mset As)) \\<cdot> \\<sigma>) \\<Longrightarrow>\n    eligible S \\<tau> As0' (D0' + negs (mset As0'))", "moreover"], ["proof (state)\nthis:\n  length As0' = 1\n\ngoal (1 subgoal):\n 1. S_M S M (D + negs (mset As)) = {#} \\<and>\n    length As = 1 \\<and>\n    maximal_wrt (As ! 0 \\<cdot>a \\<sigma>)\n     ((D + negs (mset As)) \\<cdot> \\<sigma>) \\<Longrightarrow>\n    eligible S \\<tau> As0' (D0' + negs (mset As0'))", "from asm"], ["proof (chain)\npicking this:\n  S_M S M (D + negs (mset As)) = {#} \\<and>\n  length As = 1 \\<and>\n  maximal_wrt (As ! 0 \\<cdot>a \\<sigma>)\n   ((D + negs (mset As)) \\<cdot> \\<sigma>)", "have \"maximal_wrt (As0' ! 0 \\<cdot>a (\\<tau> \\<odot> \\<phi>)) ((D0' + negs (mset As0')) \\<cdot> (\\<tau> \\<odot> \\<phi>))\""], ["proof (prove)\nusing this:\n  S_M S M (D + negs (mset As)) = {#} \\<and>\n  length As = 1 \\<and>\n  maximal_wrt (As ! 0 \\<cdot>a \\<sigma>)\n   ((D + negs (mset As)) \\<cdot> \\<sigma>)\n\ngoal (1 subgoal):\n 1. maximal_wrt (As0' ! 0 \\<cdot>a (\\<tau> \\<odot> \\<phi>))\n     ((D0' + negs (mset As0')) \\<cdot> (\\<tau> \\<odot> \\<phi>))", "using \\<open>As0' \\<cdot>al \\<eta> = As\\<close> \\<open>D0' \\<cdot> \\<eta> = D\\<close>"], ["proof (prove)\nusing this:\n  S_M S M (D + negs (mset As)) = {#} \\<and>\n  length As = 1 \\<and>\n  maximal_wrt (As ! 0 \\<cdot>a \\<sigma>)\n   ((D + negs (mset As)) \\<cdot> \\<sigma>)\n  As0' \\<cdot>al \\<eta> = As\n  D0' \\<cdot> \\<eta> = D\n\ngoal (1 subgoal):\n 1. maximal_wrt (As0' ! 0 \\<cdot>a (\\<tau> \\<odot> \\<phi>))\n     ((D0' + negs (mset As0')) \\<cdot> (\\<tau> \\<odot> \\<phi>))", "using l \\<tau>\\<phi>"], ["proof (prove)\nusing this:\n  S_M S M (D + negs (mset As)) = {#} \\<and>\n  length As = 1 \\<and>\n  maximal_wrt (As ! 0 \\<cdot>a \\<sigma>)\n   ((D + negs (mset As)) \\<cdot> \\<sigma>)\n  As0' \\<cdot>al \\<eta> = As\n  D0' \\<cdot> \\<eta> = D\n  length As0' = 1\n  Some \\<tau> = mgu (set_mset ` set (Map2.map2 add_mset As0' AAs0'))\n  \\<tau> \\<odot> \\<phi> = \\<eta> \\<odot> \\<sigma>\n\ngoal (1 subgoal):\n 1. maximal_wrt (As0' ! 0 \\<cdot>a (\\<tau> \\<odot> \\<phi>))\n     ((D0' + negs (mset As0')) \\<cdot> (\\<tau> \\<odot> \\<phi>))", "by auto"], ["proof (state)\nthis:\n  maximal_wrt (As0' ! 0 \\<cdot>a (\\<tau> \\<odot> \\<phi>))\n   ((D0' + negs (mset As0')) \\<cdot> (\\<tau> \\<odot> \\<phi>))\n\ngoal (1 subgoal):\n 1. S_M S M (D + negs (mset As)) = {#} \\<and>\n    length As = 1 \\<and>\n    maximal_wrt (As ! 0 \\<cdot>a \\<sigma>)\n     ((D + negs (mset As)) \\<cdot> \\<sigma>) \\<Longrightarrow>\n    eligible S \\<tau> As0' (D0' + negs (mset As0'))", "then"], ["proof (chain)\npicking this:\n  maximal_wrt (As0' ! 0 \\<cdot>a (\\<tau> \\<odot> \\<phi>))\n   ((D0' + negs (mset As0')) \\<cdot> (\\<tau> \\<odot> \\<phi>))", "have \"maximal_wrt (As0' ! 0 \\<cdot>a \\<tau> \\<cdot>a \\<phi>) ((D0' + negs (mset As0')) \\<cdot> \\<tau> \\<cdot> \\<phi>)\""], ["proof (prove)\nusing this:\n  maximal_wrt (As0' ! 0 \\<cdot>a (\\<tau> \\<odot> \\<phi>))\n   ((D0' + negs (mset As0')) \\<cdot> (\\<tau> \\<odot> \\<phi>))\n\ngoal (1 subgoal):\n 1. maximal_wrt (As0' ! 0 \\<cdot>a \\<tau> \\<cdot>a \\<phi>)\n     ((D0' + negs (mset As0')) \\<cdot> \\<tau> \\<cdot> \\<phi>)", "by auto"], ["proof (state)\nthis:\n  maximal_wrt (As0' ! 0 \\<cdot>a \\<tau> \\<cdot>a \\<phi>)\n   ((D0' + negs (mset As0')) \\<cdot> \\<tau> \\<cdot> \\<phi>)\n\ngoal (1 subgoal):\n 1. S_M S M (D + negs (mset As)) = {#} \\<and>\n    length As = 1 \\<and>\n    maximal_wrt (As ! 0 \\<cdot>a \\<sigma>)\n     ((D + negs (mset As)) \\<cdot> \\<sigma>) \\<Longrightarrow>\n    eligible S \\<tau> As0' (D0' + negs (mset As0'))", "then"], ["proof (chain)\npicking this:\n  maximal_wrt (As0' ! 0 \\<cdot>a \\<tau> \\<cdot>a \\<phi>)\n   ((D0' + negs (mset As0')) \\<cdot> \\<tau> \\<cdot> \\<phi>)", "have \"maximal_wrt (As0' ! 0 \\<cdot>a \\<tau>) ((D0' + negs (mset As0')) \\<cdot> \\<tau>)\""], ["proof (prove)\nusing this:\n  maximal_wrt (As0' ! 0 \\<cdot>a \\<tau> \\<cdot>a \\<phi>)\n   ((D0' + negs (mset As0')) \\<cdot> \\<tau> \\<cdot> \\<phi>)\n\ngoal (1 subgoal):\n 1. maximal_wrt (As0' ! 0 \\<cdot>a \\<tau>)\n     ((D0' + negs (mset As0')) \\<cdot> \\<tau>)", "using maximal_wrt_subst"], ["proof (prove)\nusing this:\n  maximal_wrt (As0' ! 0 \\<cdot>a \\<tau> \\<cdot>a \\<phi>)\n   ((D0' + negs (mset As0')) \\<cdot> \\<tau> \\<cdot> \\<phi>)\n  maximal_wrt (?A \\<cdot>a ?\\<sigma>)\n   (?C \\<cdot> ?\\<sigma>) \\<Longrightarrow>\n  maximal_wrt ?A ?C\n\ngoal (1 subgoal):\n 1. maximal_wrt (As0' ! 0 \\<cdot>a \\<tau>)\n     ((D0' + negs (mset As0')) \\<cdot> \\<tau>)", "by blast"], ["proof (state)\nthis:\n  maximal_wrt (As0' ! 0 \\<cdot>a \\<tau>)\n   ((D0' + negs (mset As0')) \\<cdot> \\<tau>)\n\ngoal (1 subgoal):\n 1. S_M S M (D + negs (mset As)) = {#} \\<and>\n    length As = 1 \\<and>\n    maximal_wrt (As ! 0 \\<cdot>a \\<sigma>)\n     ((D + negs (mset As)) \\<cdot> \\<sigma>) \\<Longrightarrow>\n    eligible S \\<tau> As0' (D0' + negs (mset As0'))", "ultimately"], ["proof (chain)\npicking this:\n  S (D0' + negs (mset As0')) = {#}\n  length As0' = 1\n  maximal_wrt (As0' ! 0 \\<cdot>a \\<tau>)\n   ((D0' + negs (mset As0')) \\<cdot> \\<tau>)", "show ?thesis"], ["proof (prove)\nusing this:\n  S (D0' + negs (mset As0')) = {#}\n  length As0' = 1\n  maximal_wrt (As0' ! 0 \\<cdot>a \\<tau>)\n   ((D0' + negs (mset As0')) \\<cdot> \\<tau>)\n\ngoal (1 subgoal):\n 1. eligible S \\<tau> As0' (D0' + negs (mset As0'))", "unfolding eligible.simps[simplified]"], ["proof (prove)\nusing this:\n  S (D0' + negs (mset As0')) = {#}\n  length As0' = 1\n  maximal_wrt (As0' ! 0 \\<cdot>a \\<tau>)\n   ((D0' + negs (mset As0')) \\<cdot> \\<tau>)\n\ngoal (1 subgoal):\n 1. S (D0' + negs (mset As0')) = negs (mset As0') \\<or>\n    S (D0' + negs (mset As0')) = {#} \\<and>\n    length As0' = Suc 0 \\<and>\n    maximal_wrt (As0' ! 0 \\<cdot>a \\<tau>)\n     ((D0' + negs (mset As0')) \\<cdot> \\<tau>)", "by auto"], ["proof (state)\nthis:\n  eligible S \\<tau> As0' (D0' + negs (mset As0'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eligible S \\<tau> As0' (D0' + negs (mset As0'))\n\ngoal:\nNo subgoals!", "qed\n\n  \\<comment> \\<open>Lifting maximality\\<close>"], ["proof (state)\nthis:\n  eligible S \\<tau> As0' (D0' + negs (mset As0'))\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have maximality: \"\\<forall>i < n. strictly_maximal_wrt (As0' ! i \\<cdot>a \\<tau>) (Cs0' ! i \\<cdot> \\<tau>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<n.\n       strictly_maximal_wrt (As0' ! i \\<cdot>a \\<tau>)\n        (Cs0' ! i \\<cdot> \\<tau>)", "(* Reformulate in list notation? *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<n.\n       strictly_maximal_wrt (As0' ! i \\<cdot>a \\<tau>)\n        (Cs0' ! i \\<cdot> \\<tau>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i<n.\n       strictly_maximal_wrt (As0' ! i \\<cdot>a \\<tau>)\n        (Cs0' ! i \\<cdot> \\<tau>)", "from str_max"], ["proof (chain)\npicking this:\n  \\<forall>i<n.\n     strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n      (Cs ! i \\<cdot> \\<sigma>)", "have \"\\<forall>i < n. strictly_maximal_wrt ((As0' \\<cdot>al \\<eta>) ! i \\<cdot>a \\<sigma>) ((Cs0' \\<cdot>cl \\<eta>) ! i \\<cdot> \\<sigma>)\""], ["proof (prove)\nusing this:\n  \\<forall>i<n.\n     strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n      (Cs ! i \\<cdot> \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<forall>i<n.\n       strictly_maximal_wrt ((As0' \\<cdot>al \\<eta>) ! i \\<cdot>a \\<sigma>)\n        ((Cs0' \\<cdot>cl \\<eta>) ! i \\<cdot> \\<sigma>)", "using \\<open>As0' \\<cdot>al \\<eta> = As\\<close>  \\<open>Cs0' \\<cdot>cl \\<eta> = Cs\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>i<n.\n     strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n      (Cs ! i \\<cdot> \\<sigma>)\n  As0' \\<cdot>al \\<eta> = As\n  Cs0' \\<cdot>cl \\<eta> = Cs\n\ngoal (1 subgoal):\n 1. \\<forall>i<n.\n       strictly_maximal_wrt ((As0' \\<cdot>al \\<eta>) ! i \\<cdot>a \\<sigma>)\n        ((Cs0' \\<cdot>cl \\<eta>) ! i \\<cdot> \\<sigma>)", "by simp"], ["proof (state)\nthis:\n  \\<forall>i<n.\n     strictly_maximal_wrt ((As0' \\<cdot>al \\<eta>) ! i \\<cdot>a \\<sigma>)\n      ((Cs0' \\<cdot>cl \\<eta>) ! i \\<cdot> \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<forall>i<n.\n       strictly_maximal_wrt (As0' ! i \\<cdot>a \\<tau>)\n        (Cs0' ! i \\<cdot> \\<tau>)", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<n.\n     strictly_maximal_wrt ((As0' \\<cdot>al \\<eta>) ! i \\<cdot>a \\<sigma>)\n      ((Cs0' \\<cdot>cl \\<eta>) ! i \\<cdot> \\<sigma>)", "have \"\\<forall>i < n. strictly_maximal_wrt (As0' ! i \\<cdot>a (\\<tau> \\<odot> \\<phi>)) (Cs0' ! i \\<cdot> (\\<tau> \\<odot> \\<phi>))\""], ["proof (prove)\nusing this:\n  \\<forall>i<n.\n     strictly_maximal_wrt ((As0' \\<cdot>al \\<eta>) ! i \\<cdot>a \\<sigma>)\n      ((Cs0' \\<cdot>cl \\<eta>) ! i \\<cdot> \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<forall>i<n.\n       strictly_maximal_wrt (As0' ! i \\<cdot>a (\\<tau> \\<odot> \\<phi>))\n        (Cs0' ! i \\<cdot> (\\<tau> \\<odot> \\<phi>))", "using n \\<tau>\\<phi>"], ["proof (prove)\nusing this:\n  \\<forall>i<n.\n     strictly_maximal_wrt ((As0' \\<cdot>al \\<eta>) ! i \\<cdot>a \\<sigma>)\n      ((Cs0' \\<cdot>cl \\<eta>) ! i \\<cdot> \\<sigma>)\n  length CAs0' = n\n  length \\<eta>s0' = n\n  length As0' = n\n  length AAs0' = n\n  length Cs0' = n\n  length (renamings_apart (DA0 # CAs0)) = Suc n\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length \\<rho>s = n\n  Some \\<tau> = mgu (set_mset ` set (Map2.map2 add_mset As0' AAs0'))\n  \\<tau> \\<odot> \\<phi> = \\<eta> \\<odot> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<forall>i<n.\n       strictly_maximal_wrt (As0' ! i \\<cdot>a (\\<tau> \\<odot> \\<phi>))\n        (Cs0' ! i \\<cdot> (\\<tau> \\<odot> \\<phi>))", "by simp"], ["proof (state)\nthis:\n  \\<forall>i<n.\n     strictly_maximal_wrt (As0' ! i \\<cdot>a (\\<tau> \\<odot> \\<phi>))\n      (Cs0' ! i \\<cdot> (\\<tau> \\<odot> \\<phi>))\n\ngoal (1 subgoal):\n 1. \\<forall>i<n.\n       strictly_maximal_wrt (As0' ! i \\<cdot>a \\<tau>)\n        (Cs0' ! i \\<cdot> \\<tau>)", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<n.\n     strictly_maximal_wrt (As0' ! i \\<cdot>a (\\<tau> \\<odot> \\<phi>))\n      (Cs0' ! i \\<cdot> (\\<tau> \\<odot> \\<phi>))", "have \"\\<forall>i < n. strictly_maximal_wrt (As0' ! i \\<cdot>a \\<tau> \\<cdot>a \\<phi>) (Cs0' ! i \\<cdot> \\<tau> \\<cdot> \\<phi>)\""], ["proof (prove)\nusing this:\n  \\<forall>i<n.\n     strictly_maximal_wrt (As0' ! i \\<cdot>a (\\<tau> \\<odot> \\<phi>))\n      (Cs0' ! i \\<cdot> (\\<tau> \\<odot> \\<phi>))\n\ngoal (1 subgoal):\n 1. \\<forall>i<n.\n       strictly_maximal_wrt (As0' ! i \\<cdot>a \\<tau> \\<cdot>a \\<phi>)\n        (Cs0' ! i \\<cdot> \\<tau> \\<cdot> \\<phi>)", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<n.\n     strictly_maximal_wrt (As0' ! i \\<cdot>a \\<tau> \\<cdot>a \\<phi>)\n      (Cs0' ! i \\<cdot> \\<tau> \\<cdot> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<forall>i<n.\n       strictly_maximal_wrt (As0' ! i \\<cdot>a \\<tau>)\n        (Cs0' ! i \\<cdot> \\<tau>)", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<n.\n     strictly_maximal_wrt (As0' ! i \\<cdot>a \\<tau> \\<cdot>a \\<phi>)\n      (Cs0' ! i \\<cdot> \\<tau> \\<cdot> \\<phi>)", "show \"\\<forall>i < n. strictly_maximal_wrt (As0' ! i \\<cdot>a \\<tau>) (Cs0' ! i \\<cdot> \\<tau>)\""], ["proof (prove)\nusing this:\n  \\<forall>i<n.\n     strictly_maximal_wrt (As0' ! i \\<cdot>a \\<tau> \\<cdot>a \\<phi>)\n      (Cs0' ! i \\<cdot> \\<tau> \\<cdot> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<forall>i<n.\n       strictly_maximal_wrt (As0' ! i \\<cdot>a \\<tau>)\n        (Cs0' ! i \\<cdot> \\<tau>)", "using strictly_maximal_wrt_subst \\<tau>\\<phi>"], ["proof (prove)\nusing this:\n  \\<forall>i<n.\n     strictly_maximal_wrt (As0' ! i \\<cdot>a \\<tau> \\<cdot>a \\<phi>)\n      (Cs0' ! i \\<cdot> \\<tau> \\<cdot> \\<phi>)\n  strictly_maximal_wrt (?A \\<cdot>a ?\\<sigma>)\n   (?C \\<cdot> ?\\<sigma>) \\<Longrightarrow>\n  strictly_maximal_wrt ?A ?C\n  Some \\<tau> = mgu (set_mset ` set (Map2.map2 add_mset As0' AAs0'))\n  \\<tau> \\<odot> \\<phi> = \\<eta> \\<odot> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<forall>i<n.\n       strictly_maximal_wrt (As0' ! i \\<cdot>a \\<tau>)\n        (Cs0' ! i \\<cdot> \\<tau>)", "by blast"], ["proof (state)\nthis:\n  \\<forall>i<n.\n     strictly_maximal_wrt (As0' ! i \\<cdot>a \\<tau>)\n      (Cs0' ! i \\<cdot> \\<tau>)\n\ngoal:\nNo subgoals!", "qed\n\n  \\<comment> \\<open>Lifting nothing being selected\\<close>"], ["proof (state)\nthis:\n  \\<forall>i<n.\n     strictly_maximal_wrt (As0' ! i \\<cdot>a \\<tau>)\n      (Cs0' ! i \\<cdot> \\<tau>)\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have nothing_selected: \"\\<forall>i < n. S (CAs0' ! i) = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<n. S (CAs0' ! i) = {#}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i<n. S (CAs0' ! i) = {#}", "have \"\\<forall>i < n. (map S CAs0' \\<cdot>cl \\<eta>) ! i = map (S_M S M) CAs ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<n. (map S CAs0' \\<cdot>cl \\<eta>) ! i = map (S_M S M) CAs ! i", "by (simp add: \\<open>map S CAs0' \\<cdot>cl \\<eta> = map (S_M S M) CAs\\<close>)"], ["proof (state)\nthis:\n  \\<forall>i<n. (map S CAs0' \\<cdot>cl \\<eta>) ! i = map (S_M S M) CAs ! i\n\ngoal (1 subgoal):\n 1. \\<forall>i<n. S (CAs0' ! i) = {#}", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<n. (map S CAs0' \\<cdot>cl \\<eta>) ! i = map (S_M S M) CAs ! i", "have \"\\<forall>i < n. S (CAs0' ! i) \\<cdot> \\<eta> = S_M S M (CAs ! i)\""], ["proof (prove)\nusing this:\n  \\<forall>i<n. (map S CAs0' \\<cdot>cl \\<eta>) ! i = map (S_M S M) CAs ! i\n\ngoal (1 subgoal):\n 1. \\<forall>i<n. S (CAs0' ! i) \\<cdot> \\<eta> = S_M S M (CAs ! i)", "using n"], ["proof (prove)\nusing this:\n  \\<forall>i<n. (map S CAs0' \\<cdot>cl \\<eta>) ! i = map (S_M S M) CAs ! i\n  length CAs0' = n\n  length \\<eta>s0' = n\n  length As0' = n\n  length AAs0' = n\n  length Cs0' = n\n  length (renamings_apart (DA0 # CAs0)) = Suc n\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length \\<rho>s = n\n\ngoal (1 subgoal):\n 1. \\<forall>i<n. S (CAs0' ! i) \\<cdot> \\<eta> = S_M S M (CAs ! i)", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<n. S (CAs0' ! i) \\<cdot> \\<eta> = S_M S M (CAs ! i)\n\ngoal (1 subgoal):\n 1. \\<forall>i<n. S (CAs0' ! i) = {#}", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<n. S (CAs0' ! i) \\<cdot> \\<eta> = S_M S M (CAs ! i)", "have \"\\<forall>i < n. S (CAs0' ! i)  \\<cdot> \\<eta> = {#}\""], ["proof (prove)\nusing this:\n  \\<forall>i<n. S (CAs0' ! i) \\<cdot> \\<eta> = S_M S M (CAs ! i)\n\ngoal (1 subgoal):\n 1. \\<forall>i<n. S (CAs0' ! i) \\<cdot> \\<eta> = {#}", "using sel_empt \\<open>\\<forall>i < n.  S (CAs0' ! i) \\<cdot> \\<eta> = S_M S M (CAs ! i)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>i<n. S (CAs0' ! i) \\<cdot> \\<eta> = S_M S M (CAs ! i)\n  \\<forall>i<n. S_M S M (CAs ! i) = {#}\n  \\<forall>i<n. S (CAs0' ! i) \\<cdot> \\<eta> = S_M S M (CAs ! i)\n\ngoal (1 subgoal):\n 1. \\<forall>i<n. S (CAs0' ! i) \\<cdot> \\<eta> = {#}", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<n. S (CAs0' ! i) \\<cdot> \\<eta> = {#}\n\ngoal (1 subgoal):\n 1. \\<forall>i<n. S (CAs0' ! i) = {#}", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<n. S (CAs0' ! i) \\<cdot> \\<eta> = {#}", "show \"\\<forall>i < n. S (CAs0' ! i) = {#}\""], ["proof (prove)\nusing this:\n  \\<forall>i<n. S (CAs0' ! i) \\<cdot> \\<eta> = {#}\n\ngoal (1 subgoal):\n 1. \\<forall>i<n. S (CAs0' ! i) = {#}", "using subst_cls_empty_iff"], ["proof (prove)\nusing this:\n  \\<forall>i<n. S (CAs0' ! i) \\<cdot> \\<eta> = {#}\n  (?C \\<cdot> ?\\<eta> = {#}) = (?C = {#})\n\ngoal (1 subgoal):\n 1. \\<forall>i<n. S (CAs0' ! i) = {#}", "by blast"], ["proof (state)\nthis:\n  \\<forall>i<n. S (CAs0' ! i) = {#}\n\ngoal:\nNo subgoals!", "qed\n\n  \\<comment> \\<open>Lifting AAs0's non-emptiness\\<close>"], ["proof (state)\nthis:\n  \\<forall>i<n. S (CAs0' ! i) = {#}\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"\\<forall>i < n. AAs0' ! i \\<noteq> {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<n. AAs0' ! i \\<noteq> {#}", "using n aas_not_empt \\<open>AAs0' \\<cdot>aml \\<eta> = AAs\\<close>"], ["proof (prove)\nusing this:\n  length CAs0' = n\n  length \\<eta>s0' = n\n  length As0' = n\n  length AAs0' = n\n  length Cs0' = n\n  length (renamings_apart (DA0 # CAs0)) = Suc n\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length \\<rho>s = n\n  \\<forall>i<n. AAs ! i \\<noteq> {#}\n  AAs0' \\<cdot>aml \\<eta> = AAs\n\ngoal (1 subgoal):\n 1. \\<forall>i<n. AAs0' ! i \\<noteq> {#}", "by auto\n\n  \\<comment> \\<open>Resolve the lifted clauses\\<close>"], ["proof (state)\nthis:\n  \\<forall>i<n. AAs0' ! i \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "define E0' where\n    \"E0' = ((\\<Sum>\\<^sub># (mset Cs0')) + D0') \\<cdot> \\<tau>\""], ["proof (state)\nthis:\n  E0' = (\\<Sum>\\<^sub># (mset Cs0') + D0') \\<cdot> \\<tau>\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have res_e0': \"ord_resolve S CAs0' DA0' AAs0' As0' \\<tau> E0'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_resolve S CAs0' DA0' AAs0' As0' \\<tau> E0'", "using ord_resolve.intros[of CAs0' n Cs0' AAs0' As0' \\<tau> S D0',\n      OF _ _ _ _ _ _ \\<open>\\<forall>i < n. AAs0' ! i \\<noteq> {#}\\<close> \\<tau>\\<phi>(1) eligible0'\n        \\<open>\\<forall>i < n. strictly_maximal_wrt (As0' ! i \\<cdot>a \\<tau>) (Cs0' ! i \\<cdot> \\<tau>)\\<close> \\<open>\\<forall>i < n. S (CAs0' ! i) = {#}\\<close>]"], ["proof (prove)\nusing this:\n  \\<lbrakk>length CAs0' = n; length Cs0' = n; length AAs0' = n;\n   length As0' = n; n \\<noteq> 0;\n   \\<forall>i<n. CAs0' ! i = Cs0' ! i + poss (AAs0' ! i)\\<rbrakk>\n  \\<Longrightarrow> ord_resolve S CAs0' (D0' + negs (mset As0')) AAs0' As0'\n                     \\<tau>\n                     ((\\<Sum>\\<^sub># (mset Cs0') + D0') \\<cdot> \\<tau>)\n\ngoal (1 subgoal):\n 1. ord_resolve S CAs0' DA0' AAs0' As0' \\<tau> E0'", "unfolding E0'_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>length CAs0' = n; length Cs0' = n; length AAs0' = n;\n   length As0' = n; n \\<noteq> 0;\n   \\<forall>i<n. CAs0' ! i = Cs0' ! i + poss (AAs0' ! i)\\<rbrakk>\n  \\<Longrightarrow> ord_resolve S CAs0' (D0' + negs (mset As0')) AAs0' As0'\n                     \\<tau>\n                     ((\\<Sum>\\<^sub># (mset Cs0') + D0') \\<cdot> \\<tau>)\n\ngoal (1 subgoal):\n 1. ord_resolve S CAs0' DA0' AAs0' As0' \\<tau>\n     ((\\<Sum>\\<^sub># (mset Cs0') + D0') \\<cdot> \\<tau>)", "using DA0'_split n \\<open>\\<forall>i<n. CAs0' ! i = Cs0' ! i + poss (AAs0' ! i)\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>length CAs0' = n; length Cs0' = n; length AAs0' = n;\n   length As0' = n; n \\<noteq> 0;\n   \\<forall>i<n. CAs0' ! i = Cs0' ! i + poss (AAs0' ! i)\\<rbrakk>\n  \\<Longrightarrow> ord_resolve S CAs0' (D0' + negs (mset As0')) AAs0' As0'\n                     \\<tau>\n                     ((\\<Sum>\\<^sub># (mset Cs0') + D0') \\<cdot> \\<tau>)\n  DA0' = D0' + negs (mset As0')\n  length CAs0' = n\n  length \\<eta>s0' = n\n  length As0' = n\n  length AAs0' = n\n  length Cs0' = n\n  length (renamings_apart (DA0 # CAs0)) = Suc n\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length \\<rho>s = n\n  \\<forall>i<n. CAs0' ! i = Cs0' ! i + poss (AAs0' ! i)\n\ngoal (1 subgoal):\n 1. ord_resolve S CAs0' DA0' AAs0' As0' \\<tau>\n     ((\\<Sum>\\<^sub># (mset Cs0') + D0') \\<cdot> \\<tau>)", "by blast\n\n  \\<comment> \\<open>Prove resolvent instantiates to ground resolvent\\<close>"], ["proof (state)\nthis:\n  ord_resolve S CAs0' DA0' AAs0' As0' \\<tau> E0'\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have e0'\\<phi>e: \"E0' \\<cdot> \\<phi> = E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E0' \\<cdot> \\<phi> = E", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. E0' \\<cdot> \\<phi> = E", "have \"E0' \\<cdot> \\<phi> = ((\\<Sum>\\<^sub># (mset Cs0')) + D0') \\<cdot> (\\<tau> \\<odot> \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E0' \\<cdot> \\<phi> =\n    (\\<Sum>\\<^sub># (mset Cs0') + D0') \\<cdot> (\\<tau> \\<odot> \\<phi>)", "unfolding E0'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub># (mset Cs0') + D0') \\<cdot> \\<tau> \\<cdot> \\<phi> =\n    (\\<Sum>\\<^sub># (mset Cs0') + D0') \\<cdot> (\\<tau> \\<odot> \\<phi>)", "by auto"], ["proof (state)\nthis:\n  E0' \\<cdot> \\<phi> =\n  (\\<Sum>\\<^sub># (mset Cs0') + D0') \\<cdot> (\\<tau> \\<odot> \\<phi>)\n\ngoal (1 subgoal):\n 1. E0' \\<cdot> \\<phi> = E", "also"], ["proof (state)\nthis:\n  E0' \\<cdot> \\<phi> =\n  (\\<Sum>\\<^sub># (mset Cs0') + D0') \\<cdot> (\\<tau> \\<odot> \\<phi>)\n\ngoal (1 subgoal):\n 1. E0' \\<cdot> \\<phi> = E", "have \"\\<dots> = (\\<Sum>\\<^sub># (mset Cs0') + D0') \\<cdot> (\\<eta> \\<odot> \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub># (mset Cs0') + D0') \\<cdot> (\\<tau> \\<odot> \\<phi>) =\n    (\\<Sum>\\<^sub># (mset Cs0') + D0') \\<cdot> (\\<eta> \\<odot> \\<sigma>)", "using \\<tau>\\<phi>"], ["proof (prove)\nusing this:\n  Some \\<tau> = mgu (set_mset ` set (Map2.map2 add_mset As0' AAs0'))\n  \\<tau> \\<odot> \\<phi> = \\<eta> \\<odot> \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub># (mset Cs0') + D0') \\<cdot> (\\<tau> \\<odot> \\<phi>) =\n    (\\<Sum>\\<^sub># (mset Cs0') + D0') \\<cdot> (\\<eta> \\<odot> \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sub># (mset Cs0') + D0') \\<cdot> (\\<tau> \\<odot> \\<phi>) =\n  (\\<Sum>\\<^sub># (mset Cs0') + D0') \\<cdot> (\\<eta> \\<odot> \\<sigma>)\n\ngoal (1 subgoal):\n 1. E0' \\<cdot> \\<phi> = E", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sub># (mset Cs0') + D0') \\<cdot> (\\<tau> \\<odot> \\<phi>) =\n  (\\<Sum>\\<^sub># (mset Cs0') + D0') \\<cdot> (\\<eta> \\<odot> \\<sigma>)\n\ngoal (1 subgoal):\n 1. E0' \\<cdot> \\<phi> = E", "have \"\\<dots> = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub># (mset Cs0') + D0') \\<cdot> (\\<eta> \\<odot> \\<sigma>) =\n    (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>", "using \\<open>Cs0' \\<cdot>cl \\<eta> = Cs\\<close> \\<open>D0' \\<cdot> \\<eta> = D\\<close>"], ["proof (prove)\nusing this:\n  Cs0' \\<cdot>cl \\<eta> = Cs\n  D0' \\<cdot> \\<eta> = D\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub># (mset Cs0') + D0') \\<cdot> (\\<eta> \\<odot> \\<sigma>) =\n    (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sub># (mset Cs0') + D0') \\<cdot> (\\<eta> \\<odot> \\<sigma>) =\n  (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>\n\ngoal (1 subgoal):\n 1. E0' \\<cdot> \\<phi> = E", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sub># (mset Cs0') + D0') \\<cdot> (\\<eta> \\<odot> \\<sigma>) =\n  (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>\n\ngoal (1 subgoal):\n 1. E0' \\<cdot> \\<phi> = E", "have \"\\<dots> = E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma> = E", "using e"], ["proof (prove)\nusing this:\n  E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma> = E", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma> = E\n\ngoal (1 subgoal):\n 1. E0' \\<cdot> \\<phi> = E", "finally"], ["proof (chain)\npicking this:\n  E0' \\<cdot> \\<phi> = E", "show e0'\\<phi>e: \"E0' \\<cdot> \\<phi> = E\""], ["proof (prove)\nusing this:\n  E0' \\<cdot> \\<phi> = E\n\ngoal (1 subgoal):\n 1. E0' \\<cdot> \\<phi> = E", "."], ["proof (state)\nthis:\n  E0' \\<cdot> \\<phi> = E\n\ngoal:\nNo subgoals!", "qed\n\n  \\<comment> \\<open>Replace @{term \\<phi>} with a true ground substitution\\<close>"], ["proof (state)\nthis:\n  E0' \\<cdot> \\<phi> = E\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain \\<eta>2 where\n    ground_\\<eta>2: \"is_ground_subst \\<eta>2\" \"E0' \\<cdot> \\<eta>2 = E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<eta>2.\n        \\<lbrakk>is_ground_subst \\<eta>2; E0' \\<cdot> \\<eta>2 = E\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>\\<eta>2.\n        \\<lbrakk>is_ground_subst \\<eta>2; E0' \\<cdot> \\<eta>2 = E\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"is_ground_cls_list CAs\" \"is_ground_cls DA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_cls_list CAs &&& is_ground_cls DA", "using grounding grounding_ground"], ["proof (prove)\nusing this:\n  {DA} \\<union> set CAs \\<subseteq> grounding_of_clss M\n  ?C \\<in> grounding_of_clss ?M \\<Longrightarrow> is_ground_cls ?C\n\ngoal (1 subgoal):\n 1. is_ground_cls_list CAs &&& is_ground_cls DA", "unfolding is_ground_cls_list_def"], ["proof (prove)\nusing this:\n  {DA} \\<union> set CAs \\<subseteq> grounding_of_clss M\n  ?C \\<in> grounding_of_clss ?M \\<Longrightarrow> is_ground_cls ?C\n\ngoal (1 subgoal):\n 1. Ball (set CAs) is_ground_cls &&& is_ground_cls DA", "by auto"], ["proof (state)\nthis:\n  is_ground_cls_list CAs\n  is_ground_cls DA\n\ngoal (1 subgoal):\n 1. (\\<And>\\<eta>2.\n        \\<lbrakk>is_ground_subst \\<eta>2; E0' \\<cdot> \\<eta>2 = E\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  is_ground_cls_list CAs\n  is_ground_cls DA", "have \"is_ground_cls E\""], ["proof (prove)\nusing this:\n  is_ground_cls_list CAs\n  is_ground_cls DA\n\ngoal (1 subgoal):\n 1. is_ground_cls E", "using res_e ground_resolvent_subset"], ["proof (prove)\nusing this:\n  is_ground_cls_list CAs\n  is_ground_cls DA\n  ord_resolve (S_M S M) CAs DA AAs As \\<sigma> E\n  \\<lbrakk>is_ground_cls_list ?CAs; is_ground_cls ?DA;\n   ord_resolve ?S ?CAs ?DA ?AAs ?As ?\\<sigma> ?E\\<rbrakk>\n  \\<Longrightarrow> ?E \\<subseteq># \\<Sum>\\<^sub># (mset ?CAs) + ?DA\n\ngoal (1 subgoal):\n 1. is_ground_cls E", "by (force intro: is_ground_cls_mono)"], ["proof (state)\nthis:\n  is_ground_cls E\n\ngoal (1 subgoal):\n 1. (\\<And>\\<eta>2.\n        \\<lbrakk>is_ground_subst \\<eta>2; E0' \\<cdot> \\<eta>2 = E\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  is_ground_cls E", "show thesis"], ["proof (prove)\nusing this:\n  is_ground_cls E\n\ngoal (1 subgoal):\n 1. thesis", "using that e0'\\<phi>e make_ground_subst"], ["proof (prove)\nusing this:\n  is_ground_cls E\n  \\<lbrakk>is_ground_subst ?\\<eta>2.0; E0' \\<cdot> ?\\<eta>2.0 = E\\<rbrakk>\n  \\<Longrightarrow> thesis\n  E0' \\<cdot> \\<phi> = E\n  is_ground_cls (?C \\<cdot> ?\\<sigma>) \\<Longrightarrow>\n  \\<exists>\\<tau>.\n     is_ground_subst \\<tau> \\<and> ?C \\<cdot> \\<tau> = ?C \\<cdot> ?\\<sigma>\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_ground_subst \\<eta>2\n  E0' \\<cdot> \\<eta>2 = E\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \\<open>length CAs0 = length CAs\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. length CAs0 = length CAs", "using n"], ["proof (prove)\nusing this:\n  length CAs0' = n\n  length \\<eta>s0' = n\n  length As0' = n\n  length AAs0' = n\n  length Cs0' = n\n  length (renamings_apart (DA0 # CAs0)) = Suc n\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length \\<rho>s = n\n\ngoal (1 subgoal):\n 1. length CAs0 = length CAs", "by simp"], ["proof (state)\nthis:\n  length CAs0 = length CAs\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \\<open>length \\<eta>s0 = length CAs\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. length \\<eta>s0 = length CAs", "using n"], ["proof (prove)\nusing this:\n  length CAs0' = n\n  length \\<eta>s0' = n\n  length As0' = n\n  length AAs0' = n\n  length Cs0' = n\n  length (renamings_apart (DA0 # CAs0)) = Suc n\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length \\<rho>s = n\n\ngoal (1 subgoal):\n 1. length \\<eta>s0 = length CAs", "by simp\n\n  \\<comment> \\<open>Wrap up the proof\\<close>"], ["proof (state)\nthis:\n  length \\<eta>s0 = length CAs\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"ord_resolve S (CAs0 \\<cdot>\\<cdot>cl \\<rho>s) (DA0 \\<cdot> \\<rho>) (AAs0 \\<cdot>\\<cdot>aml \\<rho>s) (As0 \\<cdot>al \\<rho>) \\<tau> E0'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_resolve S (CAs0 \\<cdot>\\<cdot>cl \\<rho>s) (DA0 \\<cdot> \\<rho>)\n     (AAs0 \\<cdot>\\<cdot>aml \\<rho>s) (As0 \\<cdot>al \\<rho>) \\<tau> E0'", "using res_e0' As0'_def \\<rho>_def AAs0'_def \\<rho>s_def DA0'_def \\<rho>_def CAs0'_def \\<rho>s_def"], ["proof (prove)\nusing this:\n  ord_resolve S CAs0' DA0' AAs0' As0' \\<tau> E0'\n  As0' = As0 \\<cdot>al \\<rho>\n  \\<rho> = hd (renamings_apart (DA0 # CAs0))\n  AAs0' = AAs0 \\<cdot>\\<cdot>aml \\<rho>s\n  \\<rho>s = tl (renamings_apart (DA0 # CAs0))\n  DA0' = DA0 \\<cdot> \\<rho>\n  \\<rho> = hd (renamings_apart (DA0 # CAs0))\n  CAs0' = CAs0 \\<cdot>\\<cdot>cl \\<rho>s\n  \\<rho>s = tl (renamings_apart (DA0 # CAs0))\n\ngoal (1 subgoal):\n 1. ord_resolve S (CAs0 \\<cdot>\\<cdot>cl \\<rho>s) (DA0 \\<cdot> \\<rho>)\n     (AAs0 \\<cdot>\\<cdot>aml \\<rho>s) (As0 \\<cdot>al \\<rho>) \\<tau> E0'", "by simp"], ["proof (state)\nthis:\n  ord_resolve S (CAs0 \\<cdot>\\<cdot>cl \\<rho>s) (DA0 \\<cdot> \\<rho>)\n   (AAs0 \\<cdot>\\<cdot>aml \\<rho>s) (As0 \\<cdot>al \\<rho>) \\<tau> E0'\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  ord_resolve S (CAs0 \\<cdot>\\<cdot>cl \\<rho>s) (DA0 \\<cdot> \\<rho>)\n   (AAs0 \\<cdot>\\<cdot>aml \\<rho>s) (As0 \\<cdot>al \\<rho>) \\<tau> E0'\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"\\<forall>i<n. poss (AAs0 ! i) \\<subseteq># CAs0 ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<n. poss (AAs0 ! i) \\<subseteq># CAs0 ! i", "using as0(19)"], ["proof (prove)\nusing this:\n  \\<forall>i<n. CAs0 ! i = Cs0 ! i + poss (AAs0 ! i)\n\ngoal (1 subgoal):\n 1. \\<forall>i<n. poss (AAs0 ! i) \\<subseteq># CAs0 ! i", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<n. poss (AAs0 ! i) \\<subseteq># CAs0 ! i\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  \\<forall>i<n. poss (AAs0 ! i) \\<subseteq># CAs0 ! i\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"negs (mset As0) \\<subseteq># DA0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. negs (mset As0) \\<subseteq># DA0", "using local.as0(15)"], ["proof (prove)\nusing this:\n  DA0 = D0 + negs (mset As0)\n\ngoal (1 subgoal):\n 1. negs (mset As0) \\<subseteq># DA0", "by auto"], ["proof (state)\nthis:\n  negs (mset As0) \\<subseteq># DA0\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  ord_resolve S (CAs0 \\<cdot>\\<cdot>cl \\<rho>s) (DA0 \\<cdot> \\<rho>)\n   (AAs0 \\<cdot>\\<cdot>aml \\<rho>s) (As0 \\<cdot>al \\<rho>) \\<tau> E0'\n  \\<forall>i<n. poss (AAs0 ! i) \\<subseteq># CAs0 ! i\n  negs (mset As0) \\<subseteq># DA0", "have \"ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0'\""], ["proof (prove)\nusing this:\n  ord_resolve S (CAs0 \\<cdot>\\<cdot>cl \\<rho>s) (DA0 \\<cdot> \\<rho>)\n   (AAs0 \\<cdot>\\<cdot>aml \\<rho>s) (As0 \\<cdot>al \\<rho>) \\<tau> E0'\n  \\<forall>i<n. poss (AAs0 ! i) \\<subseteq># CAs0 ! i\n  negs (mset As0) \\<subseteq># DA0\n\ngoal (1 subgoal):\n 1. ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0'", "using ord_resolve_rename[of CAs0 n AAs0 As0 DA0 \\<rho> \\<rho>s S \\<tau> E0'] \\<rho>_def \\<rho>s_def n"], ["proof (prove)\nusing this:\n  ord_resolve S (CAs0 \\<cdot>\\<cdot>cl \\<rho>s) (DA0 \\<cdot> \\<rho>)\n   (AAs0 \\<cdot>\\<cdot>aml \\<rho>s) (As0 \\<cdot>al \\<rho>) \\<tau> E0'\n  \\<forall>i<n. poss (AAs0 ! i) \\<subseteq># CAs0 ! i\n  negs (mset As0) \\<subseteq># DA0\n  \\<lbrakk>length CAs0 = n; length AAs0 = n; length As0 = n;\n   \\<forall>i<n. poss (AAs0 ! i) \\<subseteq># CAs0 ! i;\n   negs (mset As0) \\<subseteq># DA0;\n   \\<rho> = hd (renamings_apart (DA0 # CAs0));\n   \\<rho>s = tl (renamings_apart (DA0 # CAs0));\n   ord_resolve S (CAs0 \\<cdot>\\<cdot>cl \\<rho>s) (DA0 \\<cdot> \\<rho>)\n    (AAs0 \\<cdot>\\<cdot>aml \\<rho>s) (As0 \\<cdot>al \\<rho>) \\<tau>\n    E0'\\<rbrakk>\n  \\<Longrightarrow> ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0'\n  \\<rho> = hd (renamings_apart (DA0 # CAs0))\n  \\<rho>s = tl (renamings_apart (DA0 # CAs0))\n  length CAs0' = n\n  length \\<eta>s0' = n\n  length As0' = n\n  length AAs0' = n\n  length Cs0' = n\n  length (renamings_apart (DA0 # CAs0)) = Suc n\n  length CAs0 = n\n  length \\<eta>s0 = n\n  length As0 = n\n  length AAs0 = n\n  length Cs0 = n\n  n \\<noteq> 0\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  length \\<rho>s = n\n\ngoal (1 subgoal):\n 1. ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0'", "by auto"], ["proof (state)\nthis:\n  ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0'\n\ngoal (1 subgoal):\n 1. \\<And>n Cs D.\n       \\<lbrakk>\\<And>\\<eta> \\<eta>s \\<eta>2 CAs0 DA0 AAs0 As0 \\<tau> E0.\n                   \\<lbrakk>is_ground_subst \\<eta>;\n                    is_ground_subst_list \\<eta>s; is_ground_subst \\<eta>2;\n                    ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0;\n                    CAs0 \\<cdot>\\<cdot>cl \\<eta>s = CAs;\n                    DA0 \\<cdot> \\<eta> = DA; E0 \\<cdot> \\<eta>2 = E;\n                    {DA0} \\<union> set CAs0 \\<subseteq> M;\n                    length CAs0 = length CAs;\n                    length \\<eta>s = length CAs\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        DA = D + negs (mset As);\n        E = (\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>; length CAs = n;\n        length Cs = n; length AAs = n; length As = n; n \\<noteq> 0;\n        \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible (S_M S M) \\<sigma> As (D + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n            (Cs ! i \\<cdot> \\<sigma>);\n        \\<forall>i<n. S_M S M (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0'", "show thesis"], ["proof (prove)\nusing this:\n  ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0'\n\ngoal (1 subgoal):\n 1. thesis", "using that[of \\<eta>0 \\<eta>s0 \\<eta>2 CAs0 DA0] \\<open>is_ground_subst \\<eta>0\\<close> \\<open>is_ground_subst_list \\<eta>s0\\<close>\n      \\<open>is_ground_subst \\<eta>2\\<close> \\<open>CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs\\<close> \\<open>DA0 \\<cdot> \\<eta>0 = DA\\<close> \\<open>E0' \\<cdot> \\<eta>2 = E\\<close> \\<open>DA0 \\<in> M\\<close>\n      \\<open>\\<forall>CA \\<in> set CAs0. CA \\<in> M\\<close> \\<open>length CAs0 = length CAs\\<close> \\<open>length \\<eta>s0 = length CAs\\<close>"], ["proof (prove)\nusing this:\n  ord_resolve_rename S CAs0 DA0 AAs0 As0 \\<tau> E0'\n  \\<lbrakk>is_ground_subst \\<eta>0; is_ground_subst_list \\<eta>s0;\n   is_ground_subst \\<eta>2;\n   ord_resolve_rename S CAs0 DA0 ?AAs0.0 ?As0.0 ?\\<tau> ?E0.0;\n   CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs; DA0 \\<cdot> \\<eta>0 = DA;\n   ?E0.0 \\<cdot> \\<eta>2 = E; {DA0} \\<union> set CAs0 \\<subseteq> M;\n   length CAs0 = length CAs; length \\<eta>s0 = length CAs\\<rbrakk>\n  \\<Longrightarrow> thesis\n  is_ground_subst \\<eta>0\n  is_ground_subst_list \\<eta>s0\n  is_ground_subst \\<eta>2\n  CAs0 \\<cdot>\\<cdot>cl \\<eta>s0 = CAs\n  DA0 \\<cdot> \\<eta>0 = DA\n  E0' \\<cdot> \\<eta>2 = E\n  DA0 \\<in> M\n  \\<forall>CA\\<in>set CAs0. CA \\<in> M\n  length CAs0 = length CAs\n  length \\<eta>s0 = length CAs\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ground_ord_resolve_ground:\n  assumes\n    select: \"selection S\" and\n    CAs_p: \"ground_resolution_with_selection.ord_resolve S CAs DA AAs As E\" and\n    ground_cas: \"is_ground_cls_list CAs\" and\n    ground_da: \"is_ground_cls DA\"\n  shows \"is_ground_cls E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_cls E", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_ground_cls E", "have a1: \"atms_of E \\<subseteq> (\\<Union>CA \\<in> set CAs. atms_of CA) \\<union> atms_of DA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atms_of E \\<subseteq> \\<Union> (atms_of ` set CAs) \\<union> atms_of DA", "using ground_resolution_with_selection.ord_resolve_atms_of_concl_subset[OF _ CAs_p]\n      ground_resolution_with_selection.intro[OF select]"], ["proof (prove)\nusing this:\n  ground_resolution_with_selection S \\<Longrightarrow>\n  atms_of E \\<subseteq> \\<Union> (atms_of ` set CAs) \\<union> atms_of DA\n  ground_resolution_with_selection S\n\ngoal (1 subgoal):\n 1. atms_of E \\<subseteq> \\<Union> (atms_of ` set CAs) \\<union> atms_of DA", "by blast"], ["proof (state)\nthis:\n  atms_of E \\<subseteq> \\<Union> (atms_of ` set CAs) \\<union> atms_of DA\n\ngoal (1 subgoal):\n 1. is_ground_cls E", "{"], ["proof (state)\nthis:\n  atms_of E \\<subseteq> \\<Union> (atms_of ` set CAs) \\<union> atms_of DA\n\ngoal (1 subgoal):\n 1. is_ground_cls E", "fix L :: \"'a literal\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_ground_cls E", "assume \"L \\<in># E\""], ["proof (state)\nthis:\n  L \\<in># E\n\ngoal (1 subgoal):\n 1. is_ground_cls E", "then"], ["proof (chain)\npicking this:\n  L \\<in># E", "have \"atm_of L \\<in> atms_of E\""], ["proof (prove)\nusing this:\n  L \\<in># E\n\ngoal (1 subgoal):\n 1. atm_of L \\<in> atms_of E", "by (meson atm_of_lit_in_atms_of)"], ["proof (state)\nthis:\n  atm_of L \\<in> atms_of E\n\ngoal (1 subgoal):\n 1. is_ground_cls E", "then"], ["proof (chain)\npicking this:\n  atm_of L \\<in> atms_of E", "have \"is_ground_atm (atm_of L)\""], ["proof (prove)\nusing this:\n  atm_of L \\<in> atms_of E\n\ngoal (1 subgoal):\n 1. is_ground_atm (atm_of L)", "using a1 ground_cas ground_da is_ground_cls_imp_is_ground_atm is_ground_cls_list_def"], ["proof (prove)\nusing this:\n  atm_of L \\<in> atms_of E\n  atms_of E \\<subseteq> \\<Union> (atms_of ` set CAs) \\<union> atms_of DA\n  is_ground_cls_list CAs\n  is_ground_cls DA\n  \\<lbrakk>?A \\<in> atms_of ?C; is_ground_cls ?C\\<rbrakk>\n  \\<Longrightarrow> is_ground_atm ?A\n  is_ground_cls_list ?CC = Ball (set ?CC) is_ground_cls\n\ngoal (1 subgoal):\n 1. is_ground_atm (atm_of L)", "by auto"], ["proof (state)\nthis:\n  is_ground_atm (atm_of L)\n\ngoal (1 subgoal):\n 1. is_ground_cls E", "}"], ["proof (state)\nthis:\n  ?L2 \\<in># E \\<Longrightarrow> is_ground_atm (atm_of ?L2)\n\ngoal (1 subgoal):\n 1. is_ground_cls E", "then"], ["proof (chain)\npicking this:\n  ?L2 \\<in># E \\<Longrightarrow> is_ground_atm (atm_of ?L2)", "show ?thesis"], ["proof (prove)\nusing this:\n  ?L2 \\<in># E \\<Longrightarrow> is_ground_atm (atm_of ?L2)\n\ngoal (1 subgoal):\n 1. is_ground_cls E", "unfolding is_ground_cls_def is_ground_lit_def"], ["proof (prove)\nusing this:\n  ?L2 \\<in># E \\<Longrightarrow> is_ground_atm (atm_of ?L2)\n\ngoal (1 subgoal):\n 1. \\<forall>L. L \\<in># E \\<longrightarrow> is_ground_atm (atm_of L)", "by simp"], ["proof (state)\nthis:\n  is_ground_cls E\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ground_ord_resolve_imp_ord_resolve:\n  assumes\n    ground_da: \\<open>is_ground_cls DA\\<close> and\n    ground_cas: \\<open>is_ground_cls_list CAs\\<close> and\n    gr: \"ground_resolution_with_selection S_G\" and\n    gr_res: \\<open>ground_resolution_with_selection.ord_resolve S_G CAs DA AAs As E\\<close>\n  shows \\<open>\\<exists>\\<sigma>. ord_resolve S_G CAs DA AAs As \\<sigma> E\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>. ord_resolve S_G CAs DA AAs As \\<sigma> E", "proof (cases rule: ground_resolution_with_selection.ord_resolve.cases[OF gr gr_res])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>CAsa n Cs AAsa Asa D.\n       \\<lbrakk>CAs = CAsa; DA = D + negs (mset Asa); AAs = AAsa; As = Asa;\n        E = \\<Sum>\\<^sub># (mset Cs) + D; length CAsa = n; length Cs = n;\n        length AAsa = n; length Asa = n; n \\<noteq> 0;\n        \\<forall>i<n. CAsa ! i = Cs ! i + poss (AAsa ! i);\n        \\<forall>i<n. AAsa ! i \\<noteq> {#};\n        \\<forall>i<n. \\<forall>A\\<in>#AAsa ! i. A = Asa ! i;\n        ground_resolution_with_selection.eligible S_G Asa\n         (D + negs (mset Asa));\n        \\<forall>i<n.\n           ground_resolution_with_selection.strictly_maximal_wrt (Asa ! i)\n            (Cs ! i);\n        \\<forall>i<n. S_G (CAsa ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            ord_resolve S_G CAs DA AAs As \\<sigma> E", "case (1 CAs n Cs AAs As D)"], ["proof (state)\nthis:\n  CAs = CAs\n  DA = D + negs (mset As)\n  AAs = AAs\n  As = As\n  E = \\<Sum>\\<^sub># (mset Cs) + D\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  n \\<noteq> 0\n  \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i)\n  \\<forall>i<n. AAs ! i \\<noteq> {#}\n  \\<forall>i<n. \\<forall>A\\<in>#AAs ! i. A = As ! i\n  ground_resolution_with_selection.eligible S_G As (D + negs (mset As))\n  \\<forall>i<n.\n     ground_resolution_with_selection.strictly_maximal_wrt (As ! i) (Cs ! i)\n  \\<forall>i<n. S_G (CAs ! i) = {#}\n\ngoal (1 subgoal):\n 1. \\<And>CAsa n Cs AAsa Asa D.\n       \\<lbrakk>CAs = CAsa; DA = D + negs (mset Asa); AAs = AAsa; As = Asa;\n        E = \\<Sum>\\<^sub># (mset Cs) + D; length CAsa = n; length Cs = n;\n        length AAsa = n; length Asa = n; n \\<noteq> 0;\n        \\<forall>i<n. CAsa ! i = Cs ! i + poss (AAsa ! i);\n        \\<forall>i<n. AAsa ! i \\<noteq> {#};\n        \\<forall>i<n. \\<forall>A\\<in>#AAsa ! i. A = Asa ! i;\n        ground_resolution_with_selection.eligible S_G Asa\n         (D + negs (mset Asa));\n        \\<forall>i<n.\n           ground_resolution_with_selection.strictly_maximal_wrt (Asa ! i)\n            (Cs ! i);\n        \\<forall>i<n. S_G (CAsa ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            ord_resolve S_G CAs DA AAs As \\<sigma> E", "note cas = this(1) and da = this(2) and aas = this(3) and as = this(4) and e = this(5) and\n    cas_len = this(6) and cs_len = this(7) and aas_len = this(8) and as_len = this(9) and\n    nz = this(10) and casi = this(11) and aas_not_empt = this(12) and as_aas = this(13) and\n    eligibility = this(14) and str_max = this(15) and sel_empt = this(16)"], ["proof (state)\nthis:\n  CAs = CAs\n  DA = D + negs (mset As)\n  AAs = AAs\n  As = As\n  E = \\<Sum>\\<^sub># (mset Cs) + D\n  length CAs = n\n  length Cs = n\n  length AAs = n\n  length As = n\n  n \\<noteq> 0\n  \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i)\n  \\<forall>i<n. AAs ! i \\<noteq> {#}\n  \\<forall>i<n. \\<forall>A\\<in>#AAs ! i. A = As ! i\n  ground_resolution_with_selection.eligible S_G As (D + negs (mset As))\n  \\<forall>i<n.\n     ground_resolution_with_selection.strictly_maximal_wrt (As ! i) (Cs ! i)\n  \\<forall>i<n. S_G (CAs ! i) = {#}\n\ngoal (1 subgoal):\n 1. \\<And>CAsa n Cs AAsa Asa D.\n       \\<lbrakk>CAs = CAsa; DA = D + negs (mset Asa); AAs = AAsa; As = Asa;\n        E = \\<Sum>\\<^sub># (mset Cs) + D; length CAsa = n; length Cs = n;\n        length AAsa = n; length Asa = n; n \\<noteq> 0;\n        \\<forall>i<n. CAsa ! i = Cs ! i + poss (AAsa ! i);\n        \\<forall>i<n. AAsa ! i \\<noteq> {#};\n        \\<forall>i<n. \\<forall>A\\<in>#AAsa ! i. A = Asa ! i;\n        ground_resolution_with_selection.eligible S_G Asa\n         (D + negs (mset Asa));\n        \\<forall>i<n.\n           ground_resolution_with_selection.strictly_maximal_wrt (Asa ! i)\n            (Cs ! i);\n        \\<forall>i<n. S_G (CAsa ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            ord_resolve S_G CAs DA AAs As \\<sigma> E", "have len_aas_len_as: \"length AAs = length As\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length AAs = length As", "using aas_len as_len"], ["proof (prove)\nusing this:\n  length AAs = n\n  length As = n\n\ngoal (1 subgoal):\n 1. length AAs = length As", "by auto"], ["proof (state)\nthis:\n  length AAs = length As\n\ngoal (1 subgoal):\n 1. \\<And>CAsa n Cs AAsa Asa D.\n       \\<lbrakk>CAs = CAsa; DA = D + negs (mset Asa); AAs = AAsa; As = Asa;\n        E = \\<Sum>\\<^sub># (mset Cs) + D; length CAsa = n; length Cs = n;\n        length AAsa = n; length Asa = n; n \\<noteq> 0;\n        \\<forall>i<n. CAsa ! i = Cs ! i + poss (AAsa ! i);\n        \\<forall>i<n. AAsa ! i \\<noteq> {#};\n        \\<forall>i<n. \\<forall>A\\<in>#AAsa ! i. A = Asa ! i;\n        ground_resolution_with_selection.eligible S_G Asa\n         (D + negs (mset Asa));\n        \\<forall>i<n.\n           ground_resolution_with_selection.strictly_maximal_wrt (Asa ! i)\n            (Cs ! i);\n        \\<forall>i<n. S_G (CAsa ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            ord_resolve S_G CAs DA AAs As \\<sigma> E", "from as_aas"], ["proof (chain)\npicking this:\n  \\<forall>i<n. \\<forall>A\\<in>#AAs ! i. A = As ! i", "have \"\\<forall>i < n. \\<forall>A \\<in># add_mset (As ! i) (AAs ! i). A = As ! i\""], ["proof (prove)\nusing this:\n  \\<forall>i<n. \\<forall>A\\<in>#AAs ! i. A = As ! i\n\ngoal (1 subgoal):\n 1. \\<forall>i<n. \\<forall>A\\<in>#add_mset (As ! i) (AAs ! i). A = As ! i", "by simp"], ["proof (state)\nthis:\n  \\<forall>i<n. \\<forall>A\\<in>#add_mset (As ! i) (AAs ! i). A = As ! i\n\ngoal (1 subgoal):\n 1. \\<And>CAsa n Cs AAsa Asa D.\n       \\<lbrakk>CAs = CAsa; DA = D + negs (mset Asa); AAs = AAsa; As = Asa;\n        E = \\<Sum>\\<^sub># (mset Cs) + D; length CAsa = n; length Cs = n;\n        length AAsa = n; length Asa = n; n \\<noteq> 0;\n        \\<forall>i<n. CAsa ! i = Cs ! i + poss (AAsa ! i);\n        \\<forall>i<n. AAsa ! i \\<noteq> {#};\n        \\<forall>i<n. \\<forall>A\\<in>#AAsa ! i. A = Asa ! i;\n        ground_resolution_with_selection.eligible S_G Asa\n         (D + negs (mset Asa));\n        \\<forall>i<n.\n           ground_resolution_with_selection.strictly_maximal_wrt (Asa ! i)\n            (Cs ! i);\n        \\<forall>i<n. S_G (CAsa ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            ord_resolve S_G CAs DA AAs As \\<sigma> E", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<n. \\<forall>A\\<in>#add_mset (As ! i) (AAs ! i). A = As ! i", "have \"\\<forall>i < n. card (set_mset (add_mset (As ! i) (AAs ! i))) \\<le> Suc 0\""], ["proof (prove)\nusing this:\n  \\<forall>i<n. \\<forall>A\\<in>#add_mset (As ! i) (AAs ! i). A = As ! i\n\ngoal (1 subgoal):\n 1. \\<forall>i<n. card (set_mset (add_mset (As ! i) (AAs ! i))) \\<le> Suc 0", "using all_the_same"], ["proof (prove)\nusing this:\n  \\<forall>i<n. \\<forall>A\\<in>#add_mset (As ! i) (AAs ! i). A = As ! i\n  \\<forall>x\\<in>#?X. x = ?y \\<Longrightarrow>\n  card (set_mset ?X) \\<le> Suc 0\n\ngoal (1 subgoal):\n 1. \\<forall>i<n. card (set_mset (add_mset (As ! i) (AAs ! i))) \\<le> Suc 0", "by metis"], ["proof (state)\nthis:\n  \\<forall>i<n. card (set_mset (add_mset (As ! i) (AAs ! i))) \\<le> Suc 0\n\ngoal (1 subgoal):\n 1. \\<And>CAsa n Cs AAsa Asa D.\n       \\<lbrakk>CAs = CAsa; DA = D + negs (mset Asa); AAs = AAsa; As = Asa;\n        E = \\<Sum>\\<^sub># (mset Cs) + D; length CAsa = n; length Cs = n;\n        length AAsa = n; length Asa = n; n \\<noteq> 0;\n        \\<forall>i<n. CAsa ! i = Cs ! i + poss (AAsa ! i);\n        \\<forall>i<n. AAsa ! i \\<noteq> {#};\n        \\<forall>i<n. \\<forall>A\\<in>#AAsa ! i. A = Asa ! i;\n        ground_resolution_with_selection.eligible S_G Asa\n         (D + negs (mset Asa));\n        \\<forall>i<n.\n           ground_resolution_with_selection.strictly_maximal_wrt (Asa ! i)\n            (Cs ! i);\n        \\<forall>i<n. S_G (CAsa ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            ord_resolve S_G CAs DA AAs As \\<sigma> E", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<n. card (set_mset (add_mset (As ! i) (AAs ! i))) \\<le> Suc 0", "have \"\\<forall>i < length AAs. card (set_mset (add_mset (As ! i) (AAs ! i))) \\<le> Suc 0\""], ["proof (prove)\nusing this:\n  \\<forall>i<n. card (set_mset (add_mset (As ! i) (AAs ! i))) \\<le> Suc 0\n\ngoal (1 subgoal):\n 1. \\<forall>i<length AAs.\n       card (set_mset (add_mset (As ! i) (AAs ! i))) \\<le> Suc 0", "using aas_len"], ["proof (prove)\nusing this:\n  \\<forall>i<n. card (set_mset (add_mset (As ! i) (AAs ! i))) \\<le> Suc 0\n  length AAs = n\n\ngoal (1 subgoal):\n 1. \\<forall>i<length AAs.\n       card (set_mset (add_mset (As ! i) (AAs ! i))) \\<le> Suc 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<length AAs.\n     card (set_mset (add_mset (As ! i) (AAs ! i))) \\<le> Suc 0\n\ngoal (1 subgoal):\n 1. \\<And>CAsa n Cs AAsa Asa D.\n       \\<lbrakk>CAs = CAsa; DA = D + negs (mset Asa); AAs = AAsa; As = Asa;\n        E = \\<Sum>\\<^sub># (mset Cs) + D; length CAsa = n; length Cs = n;\n        length AAsa = n; length Asa = n; n \\<noteq> 0;\n        \\<forall>i<n. CAsa ! i = Cs ! i + poss (AAsa ! i);\n        \\<forall>i<n. AAsa ! i \\<noteq> {#};\n        \\<forall>i<n. \\<forall>A\\<in>#AAsa ! i. A = Asa ! i;\n        ground_resolution_with_selection.eligible S_G Asa\n         (D + negs (mset Asa));\n        \\<forall>i<n.\n           ground_resolution_with_selection.strictly_maximal_wrt (Asa ! i)\n            (Cs ! i);\n        \\<forall>i<n. S_G (CAsa ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            ord_resolve S_G CAs DA AAs As \\<sigma> E", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<length AAs.\n     card (set_mset (add_mset (As ! i) (AAs ! i))) \\<le> Suc 0", "have \"\\<forall>AA \\<in> set (map2 add_mset As AAs). card (set_mset AA) \\<le> Suc 0\""], ["proof (prove)\nusing this:\n  \\<forall>i<length AAs.\n     card (set_mset (add_mset (As ! i) (AAs ! i))) \\<le> Suc 0\n\ngoal (1 subgoal):\n 1. \\<forall>AA\\<in>set (Map2.map2 add_mset As AAs).\n       card (set_mset AA) \\<le> Suc 0", "using set_map2_ex[of AAs As add_mset, OF len_aas_len_as]"], ["proof (prove)\nusing this:\n  \\<forall>i<length AAs.\n     card (set_mset (add_mset (As ! i) (AAs ! i))) \\<le> Suc 0\n  set (Map2.map2 add_mset As AAs) =\n  {x. \\<exists>i<length AAs. x = add_mset (As ! i) (AAs ! i)}\n\ngoal (1 subgoal):\n 1. \\<forall>AA\\<in>set (Map2.map2 add_mset As AAs).\n       card (set_mset AA) \\<le> Suc 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>AA\\<in>set (Map2.map2 add_mset As AAs).\n     card (set_mset AA) \\<le> Suc 0\n\ngoal (1 subgoal):\n 1. \\<And>CAsa n Cs AAsa Asa D.\n       \\<lbrakk>CAs = CAsa; DA = D + negs (mset Asa); AAs = AAsa; As = Asa;\n        E = \\<Sum>\\<^sub># (mset Cs) + D; length CAsa = n; length Cs = n;\n        length AAsa = n; length Asa = n; n \\<noteq> 0;\n        \\<forall>i<n. CAsa ! i = Cs ! i + poss (AAsa ! i);\n        \\<forall>i<n. AAsa ! i \\<noteq> {#};\n        \\<forall>i<n. \\<forall>A\\<in>#AAsa ! i. A = Asa ! i;\n        ground_resolution_with_selection.eligible S_G Asa\n         (D + negs (mset Asa));\n        \\<forall>i<n.\n           ground_resolution_with_selection.strictly_maximal_wrt (Asa ! i)\n            (Cs ! i);\n        \\<forall>i<n. S_G (CAsa ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            ord_resolve S_G CAs DA AAs As \\<sigma> E", "then"], ["proof (chain)\npicking this:\n  \\<forall>AA\\<in>set (Map2.map2 add_mset As AAs).\n     card (set_mset AA) \\<le> Suc 0", "have \"is_unifiers id_subst (set_mset ` set (map2 add_mset As AAs))\""], ["proof (prove)\nusing this:\n  \\<forall>AA\\<in>set (Map2.map2 add_mset As AAs).\n     card (set_mset AA) \\<le> Suc 0\n\ngoal (1 subgoal):\n 1. is_unifiers id_subst (set_mset ` set (Map2.map2 add_mset As AAs))", "unfolding is_unifiers_def is_unifier_def"], ["proof (prove)\nusing this:\n  \\<forall>AA\\<in>set (Map2.map2 add_mset As AAs).\n     card (set_mset AA) \\<le> Suc 0\n\ngoal (1 subgoal):\n 1. \\<forall>AA\\<in>set_mset ` set (Map2.map2 add_mset As AAs).\n       card (AA \\<cdot>as id_subst) \\<le> 1", "by auto"], ["proof (state)\nthis:\n  is_unifiers id_subst (set_mset ` set (Map2.map2 add_mset As AAs))\n\ngoal (1 subgoal):\n 1. \\<And>CAsa n Cs AAsa Asa D.\n       \\<lbrakk>CAs = CAsa; DA = D + negs (mset Asa); AAs = AAsa; As = Asa;\n        E = \\<Sum>\\<^sub># (mset Cs) + D; length CAsa = n; length Cs = n;\n        length AAsa = n; length Asa = n; n \\<noteq> 0;\n        \\<forall>i<n. CAsa ! i = Cs ! i + poss (AAsa ! i);\n        \\<forall>i<n. AAsa ! i \\<noteq> {#};\n        \\<forall>i<n. \\<forall>A\\<in>#AAsa ! i. A = Asa ! i;\n        ground_resolution_with_selection.eligible S_G Asa\n         (D + negs (mset Asa));\n        \\<forall>i<n.\n           ground_resolution_with_selection.strictly_maximal_wrt (Asa ! i)\n            (Cs ! i);\n        \\<forall>i<n. S_G (CAsa ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            ord_resolve S_G CAs DA AAs As \\<sigma> E", "moreover"], ["proof (state)\nthis:\n  is_unifiers id_subst (set_mset ` set (Map2.map2 add_mset As AAs))\n\ngoal (1 subgoal):\n 1. \\<And>CAsa n Cs AAsa Asa D.\n       \\<lbrakk>CAs = CAsa; DA = D + negs (mset Asa); AAs = AAsa; As = Asa;\n        E = \\<Sum>\\<^sub># (mset Cs) + D; length CAsa = n; length Cs = n;\n        length AAsa = n; length Asa = n; n \\<noteq> 0;\n        \\<forall>i<n. CAsa ! i = Cs ! i + poss (AAsa ! i);\n        \\<forall>i<n. AAsa ! i \\<noteq> {#};\n        \\<forall>i<n. \\<forall>A\\<in>#AAsa ! i. A = Asa ! i;\n        ground_resolution_with_selection.eligible S_G Asa\n         (D + negs (mset Asa));\n        \\<forall>i<n.\n           ground_resolution_with_selection.strictly_maximal_wrt (Asa ! i)\n            (Cs ! i);\n        \\<forall>i<n. S_G (CAsa ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            ord_resolve S_G CAs DA AAs As \\<sigma> E", "have \"finite (set_mset ` set (map2 add_mset As AAs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set_mset ` set (Map2.map2 add_mset As AAs))", "by auto"], ["proof (state)\nthis:\n  finite (set_mset ` set (Map2.map2 add_mset As AAs))\n\ngoal (1 subgoal):\n 1. \\<And>CAsa n Cs AAsa Asa D.\n       \\<lbrakk>CAs = CAsa; DA = D + negs (mset Asa); AAs = AAsa; As = Asa;\n        E = \\<Sum>\\<^sub># (mset Cs) + D; length CAsa = n; length Cs = n;\n        length AAsa = n; length Asa = n; n \\<noteq> 0;\n        \\<forall>i<n. CAsa ! i = Cs ! i + poss (AAsa ! i);\n        \\<forall>i<n. AAsa ! i \\<noteq> {#};\n        \\<forall>i<n. \\<forall>A\\<in>#AAsa ! i. A = Asa ! i;\n        ground_resolution_with_selection.eligible S_G Asa\n         (D + negs (mset Asa));\n        \\<forall>i<n.\n           ground_resolution_with_selection.strictly_maximal_wrt (Asa ! i)\n            (Cs ! i);\n        \\<forall>i<n. S_G (CAsa ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            ord_resolve S_G CAs DA AAs As \\<sigma> E", "moreover"], ["proof (state)\nthis:\n  finite (set_mset ` set (Map2.map2 add_mset As AAs))\n\ngoal (1 subgoal):\n 1. \\<And>CAsa n Cs AAsa Asa D.\n       \\<lbrakk>CAs = CAsa; DA = D + negs (mset Asa); AAs = AAsa; As = Asa;\n        E = \\<Sum>\\<^sub># (mset Cs) + D; length CAsa = n; length Cs = n;\n        length AAsa = n; length Asa = n; n \\<noteq> 0;\n        \\<forall>i<n. CAsa ! i = Cs ! i + poss (AAsa ! i);\n        \\<forall>i<n. AAsa ! i \\<noteq> {#};\n        \\<forall>i<n. \\<forall>A\\<in>#AAsa ! i. A = Asa ! i;\n        ground_resolution_with_selection.eligible S_G Asa\n         (D + negs (mset Asa));\n        \\<forall>i<n.\n           ground_resolution_with_selection.strictly_maximal_wrt (Asa ! i)\n            (Cs ! i);\n        \\<forall>i<n. S_G (CAsa ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            ord_resolve S_G CAs DA AAs As \\<sigma> E", "have \"\\<forall>AA \\<in> set_mset ` set (map2 add_mset As AAs). finite AA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>AA\\<in>set_mset ` set (Map2.map2 add_mset As AAs). finite AA", "by auto"], ["proof (state)\nthis:\n  \\<forall>AA\\<in>set_mset ` set (Map2.map2 add_mset As AAs). finite AA\n\ngoal (1 subgoal):\n 1. \\<And>CAsa n Cs AAsa Asa D.\n       \\<lbrakk>CAs = CAsa; DA = D + negs (mset Asa); AAs = AAsa; As = Asa;\n        E = \\<Sum>\\<^sub># (mset Cs) + D; length CAsa = n; length Cs = n;\n        length AAsa = n; length Asa = n; n \\<noteq> 0;\n        \\<forall>i<n. CAsa ! i = Cs ! i + poss (AAsa ! i);\n        \\<forall>i<n. AAsa ! i \\<noteq> {#};\n        \\<forall>i<n. \\<forall>A\\<in>#AAsa ! i. A = Asa ! i;\n        ground_resolution_with_selection.eligible S_G Asa\n         (D + negs (mset Asa));\n        \\<forall>i<n.\n           ground_resolution_with_selection.strictly_maximal_wrt (Asa ! i)\n            (Cs ! i);\n        \\<forall>i<n. S_G (CAsa ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            ord_resolve S_G CAs DA AAs As \\<sigma> E", "ultimately"], ["proof (chain)\npicking this:\n  is_unifiers id_subst (set_mset ` set (Map2.map2 add_mset As AAs))\n  finite (set_mset ` set (Map2.map2 add_mset As AAs))\n  \\<forall>AA\\<in>set_mset ` set (Map2.map2 add_mset As AAs). finite AA", "obtain \\<sigma> where\n    \\<sigma>_p: \"Some \\<sigma> = mgu (set_mset ` set (map2 add_mset As AAs))\""], ["proof (prove)\nusing this:\n  is_unifiers id_subst (set_mset ` set (Map2.map2 add_mset As AAs))\n  finite (set_mset ` set (Map2.map2 add_mset As AAs))\n  \\<forall>AA\\<in>set_mset ` set (Map2.map2 add_mset As AAs). finite AA\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>.\n        Some \\<sigma> =\n        mgu (set_mset ` set (Map2.map2 add_mset As AAs)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using mgu_complete"], ["proof (prove)\nusing this:\n  is_unifiers id_subst (set_mset ` set (Map2.map2 add_mset As AAs))\n  finite (set_mset ` set (Map2.map2 add_mset As AAs))\n  \\<forall>AA\\<in>set_mset ` set (Map2.map2 add_mset As AAs). finite AA\n  \\<lbrakk>finite ?AAA; \\<forall>AA\\<in>?AAA. finite AA;\n   is_unifiers ?\\<sigma> ?AAA\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<tau>. mgu ?AAA = Some \\<tau>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>.\n        Some \\<sigma> =\n        mgu (set_mset ` set (Map2.map2 add_mset As AAs)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs))\n\ngoal (1 subgoal):\n 1. \\<And>CAsa n Cs AAsa Asa D.\n       \\<lbrakk>CAs = CAsa; DA = D + negs (mset Asa); AAs = AAsa; As = Asa;\n        E = \\<Sum>\\<^sub># (mset Cs) + D; length CAsa = n; length Cs = n;\n        length AAsa = n; length Asa = n; n \\<noteq> 0;\n        \\<forall>i<n. CAsa ! i = Cs ! i + poss (AAsa ! i);\n        \\<forall>i<n. AAsa ! i \\<noteq> {#};\n        \\<forall>i<n. \\<forall>A\\<in>#AAsa ! i. A = Asa ! i;\n        ground_resolution_with_selection.eligible S_G Asa\n         (D + negs (mset Asa));\n        \\<forall>i<n.\n           ground_resolution_with_selection.strictly_maximal_wrt (Asa ! i)\n            (Cs ! i);\n        \\<forall>i<n. S_G (CAsa ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            ord_resolve S_G CAs DA AAs As \\<sigma> E", "have ground_elig: \"ground_resolution_with_selection.eligible S_G As (D + negs (mset As))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ground_resolution_with_selection.eligible S_G As (D + negs (mset As))", "using eligibility"], ["proof (prove)\nusing this:\n  ground_resolution_with_selection.eligible S_G As (D + negs (mset As))\n\ngoal (1 subgoal):\n 1. ground_resolution_with_selection.eligible S_G As (D + negs (mset As))", "by simp"], ["proof (state)\nthis:\n  ground_resolution_with_selection.eligible S_G As (D + negs (mset As))\n\ngoal (1 subgoal):\n 1. \\<And>CAsa n Cs AAsa Asa D.\n       \\<lbrakk>CAs = CAsa; DA = D + negs (mset Asa); AAs = AAsa; As = Asa;\n        E = \\<Sum>\\<^sub># (mset Cs) + D; length CAsa = n; length Cs = n;\n        length AAsa = n; length Asa = n; n \\<noteq> 0;\n        \\<forall>i<n. CAsa ! i = Cs ! i + poss (AAsa ! i);\n        \\<forall>i<n. AAsa ! i \\<noteq> {#};\n        \\<forall>i<n. \\<forall>A\\<in>#AAsa ! i. A = Asa ! i;\n        ground_resolution_with_selection.eligible S_G Asa\n         (D + negs (mset Asa));\n        \\<forall>i<n.\n           ground_resolution_with_selection.strictly_maximal_wrt (Asa ! i)\n            (Cs ! i);\n        \\<forall>i<n. S_G (CAsa ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            ord_resolve S_G CAs DA AAs As \\<sigma> E", "have ground_cs: \"\\<forall>i < n. is_ground_cls (Cs ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<n. is_ground_cls (Cs ! i)", "using cas cas_len cs_len casi ground_cas nth_mem"], ["proof (prove)\nusing this:\n  CAs = CAs\n  length CAs = n\n  length Cs = n\n  \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i)\n  is_ground_cls_list CAs\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. \\<forall>i<n. is_ground_cls (Cs ! i)", "unfolding is_ground_cls_list_def"], ["proof (prove)\nusing this:\n  CAs = CAs\n  length CAs = n\n  length Cs = n\n  \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i)\n  Ball (set CAs) is_ground_cls\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. \\<forall>i<n. is_ground_cls (Cs ! i)", "by force"], ["proof (state)\nthis:\n  \\<forall>i<n. is_ground_cls (Cs ! i)\n\ngoal (1 subgoal):\n 1. \\<And>CAsa n Cs AAsa Asa D.\n       \\<lbrakk>CAs = CAsa; DA = D + negs (mset Asa); AAs = AAsa; As = Asa;\n        E = \\<Sum>\\<^sub># (mset Cs) + D; length CAsa = n; length Cs = n;\n        length AAsa = n; length Asa = n; n \\<noteq> 0;\n        \\<forall>i<n. CAsa ! i = Cs ! i + poss (AAsa ! i);\n        \\<forall>i<n. AAsa ! i \\<noteq> {#};\n        \\<forall>i<n. \\<forall>A\\<in>#AAsa ! i. A = Asa ! i;\n        ground_resolution_with_selection.eligible S_G Asa\n         (D + negs (mset Asa));\n        \\<forall>i<n.\n           ground_resolution_with_selection.strictly_maximal_wrt (Asa ! i)\n            (Cs ! i);\n        \\<forall>i<n. S_G (CAsa ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            ord_resolve S_G CAs DA AAs As \\<sigma> E", "have ground_set_as: \"is_ground_atms (set As)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_atms (set As)", "using da ground_da"], ["proof (prove)\nusing this:\n  DA = D + negs (mset As)\n  is_ground_cls DA\n\ngoal (1 subgoal):\n 1. is_ground_atms (set As)", "by (metis atms_of_negs is_ground_cls_is_ground_atms_atms_of\n        is_ground_cls_union set_mset_mset)"], ["proof (state)\nthis:\n  is_ground_atms (set As)\n\ngoal (1 subgoal):\n 1. \\<And>CAsa n Cs AAsa Asa D.\n       \\<lbrakk>CAs = CAsa; DA = D + negs (mset Asa); AAs = AAsa; As = Asa;\n        E = \\<Sum>\\<^sub># (mset Cs) + D; length CAsa = n; length Cs = n;\n        length AAsa = n; length Asa = n; n \\<noteq> 0;\n        \\<forall>i<n. CAsa ! i = Cs ! i + poss (AAsa ! i);\n        \\<forall>i<n. AAsa ! i \\<noteq> {#};\n        \\<forall>i<n. \\<forall>A\\<in>#AAsa ! i. A = Asa ! i;\n        ground_resolution_with_selection.eligible S_G Asa\n         (D + negs (mset Asa));\n        \\<forall>i<n.\n           ground_resolution_with_selection.strictly_maximal_wrt (Asa ! i)\n            (Cs ! i);\n        \\<forall>i<n. S_G (CAsa ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            ord_resolve S_G CAs DA AAs As \\<sigma> E", "then"], ["proof (chain)\npicking this:\n  is_ground_atms (set As)", "have ground_mset_as: \"is_ground_atm_mset (mset As)\""], ["proof (prove)\nusing this:\n  is_ground_atms (set As)\n\ngoal (1 subgoal):\n 1. is_ground_atm_mset (mset As)", "unfolding is_ground_atm_mset_def is_ground_atms_def"], ["proof (prove)\nusing this:\n  Ball (set As) is_ground_atm\n\ngoal (1 subgoal):\n 1. \\<forall>A. A \\<in># mset As \\<longrightarrow> is_ground_atm A", "by auto"], ["proof (state)\nthis:\n  is_ground_atm_mset (mset As)\n\ngoal (1 subgoal):\n 1. \\<And>CAsa n Cs AAsa Asa D.\n       \\<lbrakk>CAs = CAsa; DA = D + negs (mset Asa); AAs = AAsa; As = Asa;\n        E = \\<Sum>\\<^sub># (mset Cs) + D; length CAsa = n; length Cs = n;\n        length AAsa = n; length Asa = n; n \\<noteq> 0;\n        \\<forall>i<n. CAsa ! i = Cs ! i + poss (AAsa ! i);\n        \\<forall>i<n. AAsa ! i \\<noteq> {#};\n        \\<forall>i<n. \\<forall>A\\<in>#AAsa ! i. A = Asa ! i;\n        ground_resolution_with_selection.eligible S_G Asa\n         (D + negs (mset Asa));\n        \\<forall>i<n.\n           ground_resolution_with_selection.strictly_maximal_wrt (Asa ! i)\n            (Cs ! i);\n        \\<forall>i<n. S_G (CAsa ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            ord_resolve S_G CAs DA AAs As \\<sigma> E", "have ground_as: \"is_ground_atm_list As\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_atm_list As", "using ground_set_as is_ground_atm_list_def is_ground_atms_def"], ["proof (prove)\nusing this:\n  is_ground_atms (set As)\n  is_ground_atm_list ?As = Ball (set ?As) is_ground_atm\n  is_ground_atms ?AA = Ball ?AA is_ground_atm\n\ngoal (1 subgoal):\n 1. is_ground_atm_list As", "by auto"], ["proof (state)\nthis:\n  is_ground_atm_list As\n\ngoal (1 subgoal):\n 1. \\<And>CAsa n Cs AAsa Asa D.\n       \\<lbrakk>CAs = CAsa; DA = D + negs (mset Asa); AAs = AAsa; As = Asa;\n        E = \\<Sum>\\<^sub># (mset Cs) + D; length CAsa = n; length Cs = n;\n        length AAsa = n; length Asa = n; n \\<noteq> 0;\n        \\<forall>i<n. CAsa ! i = Cs ! i + poss (AAsa ! i);\n        \\<forall>i<n. AAsa ! i \\<noteq> {#};\n        \\<forall>i<n. \\<forall>A\\<in>#AAsa ! i. A = Asa ! i;\n        ground_resolution_with_selection.eligible S_G Asa\n         (D + negs (mset Asa));\n        \\<forall>i<n.\n           ground_resolution_with_selection.strictly_maximal_wrt (Asa ! i)\n            (Cs ! i);\n        \\<forall>i<n. S_G (CAsa ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            ord_resolve S_G CAs DA AAs As \\<sigma> E", "have ground_d: \"is_ground_cls D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_cls D", "using ground_da da"], ["proof (prove)\nusing this:\n  is_ground_cls DA\n  DA = D + negs (mset As)\n\ngoal (1 subgoal):\n 1. is_ground_cls D", "by simp"], ["proof (state)\nthis:\n  is_ground_cls D\n\ngoal (1 subgoal):\n 1. \\<And>CAsa n Cs AAsa Asa D.\n       \\<lbrakk>CAs = CAsa; DA = D + negs (mset Asa); AAs = AAsa; As = Asa;\n        E = \\<Sum>\\<^sub># (mset Cs) + D; length CAsa = n; length Cs = n;\n        length AAsa = n; length Asa = n; n \\<noteq> 0;\n        \\<forall>i<n. CAsa ! i = Cs ! i + poss (AAsa ! i);\n        \\<forall>i<n. AAsa ! i \\<noteq> {#};\n        \\<forall>i<n. \\<forall>A\\<in>#AAsa ! i. A = Asa ! i;\n        ground_resolution_with_selection.eligible S_G Asa\n         (D + negs (mset Asa));\n        \\<forall>i<n.\n           ground_resolution_with_selection.strictly_maximal_wrt (Asa ! i)\n            (Cs ! i);\n        \\<forall>i<n. S_G (CAsa ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            ord_resolve S_G CAs DA AAs As \\<sigma> E", "from as_len nz"], ["proof (chain)\npicking this:\n  length As = n\n  n \\<noteq> 0", "have atms:\n    \"atms_of D \\<union> set As \\<noteq> {}\"\n    \"finite (atms_of D \\<union> set As)\""], ["proof (prove)\nusing this:\n  length As = n\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. atms_of D \\<union> set As \\<noteq> {} &&&\n    finite (atms_of D \\<union> set As)", "by auto"], ["proof (state)\nthis:\n  atms_of D \\<union> set As \\<noteq> {}\n  finite (atms_of D \\<union> set As)\n\ngoal (1 subgoal):\n 1. \\<And>CAsa n Cs AAsa Asa D.\n       \\<lbrakk>CAs = CAsa; DA = D + negs (mset Asa); AAs = AAsa; As = Asa;\n        E = \\<Sum>\\<^sub># (mset Cs) + D; length CAsa = n; length Cs = n;\n        length AAsa = n; length Asa = n; n \\<noteq> 0;\n        \\<forall>i<n. CAsa ! i = Cs ! i + poss (AAsa ! i);\n        \\<forall>i<n. AAsa ! i \\<noteq> {#};\n        \\<forall>i<n. \\<forall>A\\<in>#AAsa ! i. A = Asa ! i;\n        ground_resolution_with_selection.eligible S_G Asa\n         (D + negs (mset Asa));\n        \\<forall>i<n.\n           ground_resolution_with_selection.strictly_maximal_wrt (Asa ! i)\n            (Cs ! i);\n        \\<forall>i<n. S_G (CAsa ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            ord_resolve S_G CAs DA AAs As \\<sigma> E", "then"], ["proof (chain)\npicking this:\n  atms_of D \\<union> set As \\<noteq> {}\n  finite (atms_of D \\<union> set As)", "have \"Max (atms_of D \\<union> set As) \\<in> atms_of D \\<union> set As\""], ["proof (prove)\nusing this:\n  atms_of D \\<union> set As \\<noteq> {}\n  finite (atms_of D \\<union> set As)\n\ngoal (1 subgoal):\n 1. Max (atms_of D \\<union> set As) \\<in> atms_of D \\<union> set As", "using Max_in"], ["proof (prove)\nusing this:\n  atms_of D \\<union> set As \\<noteq> {}\n  finite (atms_of D \\<union> set As)\n  \\<lbrakk>finite ?A; ?A \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> Max ?A \\<in> ?A\n\ngoal (1 subgoal):\n 1. Max (atms_of D \\<union> set As) \\<in> atms_of D \\<union> set As", "by metis"], ["proof (state)\nthis:\n  Max (atms_of D \\<union> set As) \\<in> atms_of D \\<union> set As\n\ngoal (1 subgoal):\n 1. \\<And>CAsa n Cs AAsa Asa D.\n       \\<lbrakk>CAs = CAsa; DA = D + negs (mset Asa); AAs = AAsa; As = Asa;\n        E = \\<Sum>\\<^sub># (mset Cs) + D; length CAsa = n; length Cs = n;\n        length AAsa = n; length Asa = n; n \\<noteq> 0;\n        \\<forall>i<n. CAsa ! i = Cs ! i + poss (AAsa ! i);\n        \\<forall>i<n. AAsa ! i \\<noteq> {#};\n        \\<forall>i<n. \\<forall>A\\<in>#AAsa ! i. A = Asa ! i;\n        ground_resolution_with_selection.eligible S_G Asa\n         (D + negs (mset Asa));\n        \\<forall>i<n.\n           ground_resolution_with_selection.strictly_maximal_wrt (Asa ! i)\n            (Cs ! i);\n        \\<forall>i<n. S_G (CAsa ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            ord_resolve S_G CAs DA AAs As \\<sigma> E", "then"], ["proof (chain)\npicking this:\n  Max (atms_of D \\<union> set As) \\<in> atms_of D \\<union> set As", "have is_ground_Max: \"is_ground_atm (Max (atms_of D \\<union> set As))\""], ["proof (prove)\nusing this:\n  Max (atms_of D \\<union> set As) \\<in> atms_of D \\<union> set As\n\ngoal (1 subgoal):\n 1. is_ground_atm (Max (atms_of D \\<union> set As))", "using ground_d ground_mset_as is_ground_cls_imp_is_ground_atm"], ["proof (prove)\nusing this:\n  Max (atms_of D \\<union> set As) \\<in> atms_of D \\<union> set As\n  is_ground_cls D\n  is_ground_atm_mset (mset As)\n  \\<lbrakk>?A \\<in> atms_of ?C; is_ground_cls ?C\\<rbrakk>\n  \\<Longrightarrow> is_ground_atm ?A\n\ngoal (1 subgoal):\n 1. is_ground_atm (Max (atms_of D \\<union> set As))", "unfolding is_ground_atm_mset_def"], ["proof (prove)\nusing this:\n  Max (atms_of D \\<union> set As) \\<in> atms_of D \\<union> set As\n  is_ground_cls D\n  \\<forall>A. A \\<in># mset As \\<longrightarrow> is_ground_atm A\n  \\<lbrakk>?A \\<in> atms_of ?C; is_ground_cls ?C\\<rbrakk>\n  \\<Longrightarrow> is_ground_atm ?A\n\ngoal (1 subgoal):\n 1. is_ground_atm (Max (atms_of D \\<union> set As))", "by auto"], ["proof (state)\nthis:\n  is_ground_atm (Max (atms_of D \\<union> set As))\n\ngoal (1 subgoal):\n 1. \\<And>CAsa n Cs AAsa Asa D.\n       \\<lbrakk>CAs = CAsa; DA = D + negs (mset Asa); AAs = AAsa; As = Asa;\n        E = \\<Sum>\\<^sub># (mset Cs) + D; length CAsa = n; length Cs = n;\n        length AAsa = n; length Asa = n; n \\<noteq> 0;\n        \\<forall>i<n. CAsa ! i = Cs ! i + poss (AAsa ! i);\n        \\<forall>i<n. AAsa ! i \\<noteq> {#};\n        \\<forall>i<n. \\<forall>A\\<in>#AAsa ! i. A = Asa ! i;\n        ground_resolution_with_selection.eligible S_G Asa\n         (D + negs (mset Asa));\n        \\<forall>i<n.\n           ground_resolution_with_selection.strictly_maximal_wrt (Asa ! i)\n            (Cs ! i);\n        \\<forall>i<n. S_G (CAsa ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            ord_resolve S_G CAs DA AAs As \\<sigma> E", "have \"maximal_wrt (Max (atms_of D \\<union> set As)) (D + negs (mset As))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maximal_wrt (Max (atms_of D \\<union> set As)) (D + negs (mset As))", "unfolding maximal_wrt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>B\\<in>atms_of (D + negs (mset As)).\n       \\<not> less_atm (Max (atms_of D \\<union> set As)) B", "by clarsimp (metis atms Max_less_iff UnCI ground_d ground_set_as infinite_growing\n        is_ground_Max is_ground_atms_def is_ground_cls_imp_is_ground_atm less_atm_ground)"], ["proof (state)\nthis:\n  maximal_wrt (Max (atms_of D \\<union> set As)) (D + negs (mset As))\n\ngoal (1 subgoal):\n 1. \\<And>CAsa n Cs AAsa Asa D.\n       \\<lbrakk>CAs = CAsa; DA = D + negs (mset Asa); AAs = AAsa; As = Asa;\n        E = \\<Sum>\\<^sub># (mset Cs) + D; length CAsa = n; length Cs = n;\n        length AAsa = n; length Asa = n; n \\<noteq> 0;\n        \\<forall>i<n. CAsa ! i = Cs ! i + poss (AAsa ! i);\n        \\<forall>i<n. AAsa ! i \\<noteq> {#};\n        \\<forall>i<n. \\<forall>A\\<in>#AAsa ! i. A = Asa ! i;\n        ground_resolution_with_selection.eligible S_G Asa\n         (D + negs (mset Asa));\n        \\<forall>i<n.\n           ground_resolution_with_selection.strictly_maximal_wrt (Asa ! i)\n            (Cs ! i);\n        \\<forall>i<n. S_G (CAsa ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            ord_resolve S_G CAs DA AAs As \\<sigma> E", "moreover"], ["proof (state)\nthis:\n  maximal_wrt (Max (atms_of D \\<union> set As)) (D + negs (mset As))\n\ngoal (1 subgoal):\n 1. \\<And>CAsa n Cs AAsa Asa D.\n       \\<lbrakk>CAs = CAsa; DA = D + negs (mset Asa); AAs = AAsa; As = Asa;\n        E = \\<Sum>\\<^sub># (mset Cs) + D; length CAsa = n; length Cs = n;\n        length AAsa = n; length Asa = n; n \\<noteq> 0;\n        \\<forall>i<n. CAsa ! i = Cs ! i + poss (AAsa ! i);\n        \\<forall>i<n. AAsa ! i \\<noteq> {#};\n        \\<forall>i<n. \\<forall>A\\<in>#AAsa ! i. A = Asa ! i;\n        ground_resolution_with_selection.eligible S_G Asa\n         (D + negs (mset Asa));\n        \\<forall>i<n.\n           ground_resolution_with_selection.strictly_maximal_wrt (Asa ! i)\n            (Cs ! i);\n        \\<forall>i<n. S_G (CAsa ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            ord_resolve S_G CAs DA AAs As \\<sigma> E", "have\n    \"Max (atms_of D \\<union> set As) \\<cdot>a \\<sigma> = Max (atms_of D \\<union> set As)\" and\n    \"D \\<cdot> \\<sigma> + negs (mset As \\<cdot>am \\<sigma>) = D + negs (mset As)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (atms_of D \\<union> set As) \\<cdot>a \\<sigma> =\n    Max (atms_of D \\<union> set As) &&&\n    D \\<cdot> \\<sigma> + negs (mset As \\<cdot>am \\<sigma>) =\n    D + negs (mset As)", "using ground_elig is_ground_Max ground_mset_as ground_d"], ["proof (prove)\nusing this:\n  ground_resolution_with_selection.eligible S_G As (D + negs (mset As))\n  is_ground_atm (Max (atms_of D \\<union> set As))\n  is_ground_atm_mset (mset As)\n  is_ground_cls D\n\ngoal (1 subgoal):\n 1. Max (atms_of D \\<union> set As) \\<cdot>a \\<sigma> =\n    Max (atms_of D \\<union> set As) &&&\n    D \\<cdot> \\<sigma> + negs (mset As \\<cdot>am \\<sigma>) =\n    D + negs (mset As)", "by auto"], ["proof (state)\nthis:\n  Max (atms_of D \\<union> set As) \\<cdot>a \\<sigma> =\n  Max (atms_of D \\<union> set As)\n  D \\<cdot> \\<sigma> + negs (mset As \\<cdot>am \\<sigma>) =\n  D + negs (mset As)\n\ngoal (1 subgoal):\n 1. \\<And>CAsa n Cs AAsa Asa D.\n       \\<lbrakk>CAs = CAsa; DA = D + negs (mset Asa); AAs = AAsa; As = Asa;\n        E = \\<Sum>\\<^sub># (mset Cs) + D; length CAsa = n; length Cs = n;\n        length AAsa = n; length Asa = n; n \\<noteq> 0;\n        \\<forall>i<n. CAsa ! i = Cs ! i + poss (AAsa ! i);\n        \\<forall>i<n. AAsa ! i \\<noteq> {#};\n        \\<forall>i<n. \\<forall>A\\<in>#AAsa ! i. A = Asa ! i;\n        ground_resolution_with_selection.eligible S_G Asa\n         (D + negs (mset Asa));\n        \\<forall>i<n.\n           ground_resolution_with_selection.strictly_maximal_wrt (Asa ! i)\n            (Cs ! i);\n        \\<forall>i<n. S_G (CAsa ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            ord_resolve S_G CAs DA AAs As \\<sigma> E", "ultimately"], ["proof (chain)\npicking this:\n  maximal_wrt (Max (atms_of D \\<union> set As)) (D + negs (mset As))\n  Max (atms_of D \\<union> set As) \\<cdot>a \\<sigma> =\n  Max (atms_of D \\<union> set As)\n  D \\<cdot> \\<sigma> + negs (mset As \\<cdot>am \\<sigma>) =\n  D + negs (mset As)", "have fo_elig: \"eligible S_G \\<sigma> As (D + negs (mset As))\""], ["proof (prove)\nusing this:\n  maximal_wrt (Max (atms_of D \\<union> set As)) (D + negs (mset As))\n  Max (atms_of D \\<union> set As) \\<cdot>a \\<sigma> =\n  Max (atms_of D \\<union> set As)\n  D \\<cdot> \\<sigma> + negs (mset As \\<cdot>am \\<sigma>) =\n  D + negs (mset As)\n\ngoal (1 subgoal):\n 1. eligible S_G \\<sigma> As (D + negs (mset As))", "using ground_elig"], ["proof (prove)\nusing this:\n  maximal_wrt (Max (atms_of D \\<union> set As)) (D + negs (mset As))\n  Max (atms_of D \\<union> set As) \\<cdot>a \\<sigma> =\n  Max (atms_of D \\<union> set As)\n  D \\<cdot> \\<sigma> + negs (mset As \\<cdot>am \\<sigma>) =\n  D + negs (mset As)\n  ground_resolution_with_selection.eligible S_G As (D + negs (mset As))\n\ngoal (1 subgoal):\n 1. eligible S_G \\<sigma> As (D + negs (mset As))", "unfolding ground_resolution_with_selection.eligible.simps[OF gr]\n      ground_resolution_with_selection.maximal_wrt_def[OF gr] eligible.simps"], ["proof (prove)\nusing this:\n  maximal_wrt (Max (atms_of D \\<union> set As)) (D + negs (mset As))\n  Max (atms_of D \\<union> set As) \\<cdot>a \\<sigma> =\n  Max (atms_of D \\<union> set As)\n  D \\<cdot> \\<sigma> + negs (mset As \\<cdot>am \\<sigma>) =\n  D + negs (mset As)\n  \\<exists>DA As.\n     As = As \\<and>\n     D + negs (mset As) = DA \\<and>\n     (S_G DA = negs (mset As) \\<or>\n      S_G DA = {#} \\<and>\n      length As = 1 \\<and> (DA = {#} \\<or> As ! 0 = Max (atms_of DA)))\n\ngoal (1 subgoal):\n 1. \\<exists>DA As \\<sigma>'.\n       \\<sigma> = \\<sigma>' \\<and>\n       As = As \\<and>\n       D + negs (mset As) = DA \\<and>\n       (S_G DA = negs (mset As) \\<or>\n        S_G DA = {#} \\<and>\n        length As = 1 \\<and>\n        maximal_wrt (As ! 0 \\<cdot>a \\<sigma>') (DA \\<cdot> \\<sigma>'))", "by auto"], ["proof (state)\nthis:\n  eligible S_G \\<sigma> As (D + negs (mset As))\n\ngoal (1 subgoal):\n 1. \\<And>CAsa n Cs AAsa Asa D.\n       \\<lbrakk>CAs = CAsa; DA = D + negs (mset Asa); AAs = AAsa; As = Asa;\n        E = \\<Sum>\\<^sub># (mset Cs) + D; length CAsa = n; length Cs = n;\n        length AAsa = n; length Asa = n; n \\<noteq> 0;\n        \\<forall>i<n. CAsa ! i = Cs ! i + poss (AAsa ! i);\n        \\<forall>i<n. AAsa ! i \\<noteq> {#};\n        \\<forall>i<n. \\<forall>A\\<in>#AAsa ! i. A = Asa ! i;\n        ground_resolution_with_selection.eligible S_G Asa\n         (D + negs (mset Asa));\n        \\<forall>i<n.\n           ground_resolution_with_selection.strictly_maximal_wrt (Asa ! i)\n            (Cs ! i);\n        \\<forall>i<n. S_G (CAsa ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            ord_resolve S_G CAs DA AAs As \\<sigma> E", "have \"\\<forall>i < n. strictly_maximal_wrt (As ! i) (Cs ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<n. strictly_maximal_wrt (As ! i) (Cs ! i)", "using str_max[unfolded ground_resolution_with_selection.strictly_maximal_wrt_def[OF gr]]\n      ground_as[unfolded is_ground_atm_list_def] ground_cs as_len less_atm_ground"], ["proof (prove)\nusing this:\n  \\<forall>i<n. \\<forall>B\\<in>atms_of (Cs ! i). B < As ! i\n  Ball (set As) is_ground_atm\n  \\<forall>i<n. is_ground_cls (Cs ! i)\n  length As = n\n  \\<lbrakk>is_ground_atm ?A; is_ground_atm ?B; less_atm ?A ?B\\<rbrakk>\n  \\<Longrightarrow> ?A < ?B\n\ngoal (1 subgoal):\n 1. \\<forall>i<n. strictly_maximal_wrt (As ! i) (Cs ! i)", "unfolding strictly_maximal_wrt_def"], ["proof (prove)\nusing this:\n  \\<forall>i<n. \\<forall>B\\<in>atms_of (Cs ! i). B < As ! i\n  Ball (set As) is_ground_atm\n  \\<forall>i<n. is_ground_cls (Cs ! i)\n  length As = n\n  \\<lbrakk>is_ground_atm ?A; is_ground_atm ?B; less_atm ?A ?B\\<rbrakk>\n  \\<Longrightarrow> ?A < ?B\n\ngoal (1 subgoal):\n 1. \\<forall>i<n.\n       \\<forall>B\\<in>atms_of (Cs ! i).\n          As ! i \\<noteq> B \\<and> \\<not> less_atm (As ! i) B", "by clarsimp (fastforce simp: is_ground_cls_as_atms)+"], ["proof (state)\nthis:\n  \\<forall>i<n. strictly_maximal_wrt (As ! i) (Cs ! i)\n\ngoal (1 subgoal):\n 1. \\<And>CAsa n Cs AAsa Asa D.\n       \\<lbrakk>CAs = CAsa; DA = D + negs (mset Asa); AAs = AAsa; As = Asa;\n        E = \\<Sum>\\<^sub># (mset Cs) + D; length CAsa = n; length Cs = n;\n        length AAsa = n; length Asa = n; n \\<noteq> 0;\n        \\<forall>i<n. CAsa ! i = Cs ! i + poss (AAsa ! i);\n        \\<forall>i<n. AAsa ! i \\<noteq> {#};\n        \\<forall>i<n. \\<forall>A\\<in>#AAsa ! i. A = Asa ! i;\n        ground_resolution_with_selection.eligible S_G Asa\n         (D + negs (mset Asa));\n        \\<forall>i<n.\n           ground_resolution_with_selection.strictly_maximal_wrt (Asa ! i)\n            (Cs ! i);\n        \\<forall>i<n. S_G (CAsa ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            ord_resolve S_G CAs DA AAs As \\<sigma> E", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<n. strictly_maximal_wrt (As ! i) (Cs ! i)", "have ll: \"\\<forall>i < n. strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>) (Cs ! i \\<cdot> \\<sigma>)\""], ["proof (prove)\nusing this:\n  \\<forall>i<n. strictly_maximal_wrt (As ! i) (Cs ! i)\n\ngoal (1 subgoal):\n 1. \\<forall>i<n.\n       strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n        (Cs ! i \\<cdot> \\<sigma>)", "by (simp add: ground_as ground_cs as_len)"], ["proof (state)\nthis:\n  \\<forall>i<n.\n     strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>)\n      (Cs ! i \\<cdot> \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<And>CAsa n Cs AAsa Asa D.\n       \\<lbrakk>CAs = CAsa; DA = D + negs (mset Asa); AAs = AAsa; As = Asa;\n        E = \\<Sum>\\<^sub># (mset Cs) + D; length CAsa = n; length Cs = n;\n        length AAsa = n; length Asa = n; n \\<noteq> 0;\n        \\<forall>i<n. CAsa ! i = Cs ! i + poss (AAsa ! i);\n        \\<forall>i<n. AAsa ! i \\<noteq> {#};\n        \\<forall>i<n. \\<forall>A\\<in>#AAsa ! i. A = Asa ! i;\n        ground_resolution_with_selection.eligible S_G Asa\n         (D + negs (mset Asa));\n        \\<forall>i<n.\n           ground_resolution_with_selection.strictly_maximal_wrt (Asa ! i)\n            (Cs ! i);\n        \\<forall>i<n. S_G (CAsa ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            ord_resolve S_G CAs DA AAs As \\<sigma> E", "have ground_e: \"is_ground_cls E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_cls E", "using ground_d ground_cs cs_len"], ["proof (prove)\nusing this:\n  is_ground_cls D\n  \\<forall>i<n. is_ground_cls (Cs ! i)\n  length Cs = n\n\ngoal (1 subgoal):\n 1. is_ground_cls E", "unfolding e is_ground_cls_def"], ["proof (prove)\nusing this:\n  \\<forall>L. L \\<in># D \\<longrightarrow> is_ground_lit L\n  \\<forall>i<n.\n     \\<forall>L. L \\<in># Cs ! i \\<longrightarrow> is_ground_lit L\n  length Cs = n\n\ngoal (1 subgoal):\n 1. \\<forall>L.\n       L \\<in># \\<Sum>\\<^sub># (mset Cs) + D \\<longrightarrow>\n       is_ground_lit L", "by simp (metis in_mset_sum_list2 in_set_conv_nth)"], ["proof (state)\nthis:\n  is_ground_cls E\n\ngoal (1 subgoal):\n 1. \\<And>CAsa n Cs AAsa Asa D.\n       \\<lbrakk>CAs = CAsa; DA = D + negs (mset Asa); AAs = AAsa; As = Asa;\n        E = \\<Sum>\\<^sub># (mset Cs) + D; length CAsa = n; length Cs = n;\n        length AAsa = n; length Asa = n; n \\<noteq> 0;\n        \\<forall>i<n. CAsa ! i = Cs ! i + poss (AAsa ! i);\n        \\<forall>i<n. AAsa ! i \\<noteq> {#};\n        \\<forall>i<n. \\<forall>A\\<in>#AAsa ! i. A = Asa ! i;\n        ground_resolution_with_selection.eligible S_G Asa\n         (D + negs (mset Asa));\n        \\<forall>i<n.\n           ground_resolution_with_selection.strictly_maximal_wrt (Asa ! i)\n            (Cs ! i);\n        \\<forall>i<n. S_G (CAsa ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            ord_resolve S_G CAs DA AAs As \\<sigma> E", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>. ord_resolve S_G CAs DA AAs As \\<sigma> E", "using cas da aas as e ground_e ord_resolve.intros[OF cas_len cs_len aas_len as_len nz casi\n        aas_not_empt \\<sigma>_p fo_elig ll sel_empt]"], ["proof (prove)\nusing this:\n  CAs = CAs\n  DA = D + negs (mset As)\n  AAs = AAs\n  As = As\n  E = \\<Sum>\\<^sub># (mset Cs) + D\n  is_ground_cls E\n  ord_resolve S_G CAs (D + negs (mset As)) AAs As \\<sigma>\n   ((\\<Sum>\\<^sub># (mset Cs) + D) \\<cdot> \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>. ord_resolve S_G CAs DA AAs As \\<sigma> E", "by auto"], ["proof (state)\nthis:\n  \\<exists>\\<sigma>. ord_resolve S_G CAs DA AAs As \\<sigma> E\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}