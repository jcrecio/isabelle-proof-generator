{"file_name": "/home/qj213/afp-2021-10-22/thys/Ordered_Resolution_Prover/Lazy_List_Chain.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Ordered_Resolution_Prover", "problem_names": ["lemma\n  chain_LNil[simp]: \"\\<not> chain R LNil\" and\n  chain_not_lnull: \"chain R xs \\<Longrightarrow> \\<not> lnull xs\"", "lemma chain_lappend:\n  assumes\n    r_xs: \"chain R xs\" and\n    r_ys: \"chain R ys\" and\n    mid: \"R (llast xs) (lhd ys)\"\n  shows \"chain R (lappend xs ys)\"", "lemma chain_length_pos: \"chain R xs \\<Longrightarrow> llength xs > 0\"", "lemma chain_ldropn:\n  assumes \"chain R xs\" and \"enat n < llength xs\"\n  shows \"chain R (ldropn n xs)\"", "lemma inf_chain_ldropn_chain: \"chain R xs \\<Longrightarrow> \\<not> lfinite xs \\<Longrightarrow> chain R (ldropn n xs)\"", "lemma inf_chain_ltl_chain: \"chain R xs \\<Longrightarrow> \\<not> lfinite xs \\<Longrightarrow> chain R (ltl xs)\"", "lemma chain_lnth_rel:\n  assumes\n    chain: \"chain R xs\" and\n    len: \"enat (Suc j) < llength xs\"\n  shows \"R (lnth xs j) (lnth xs (Suc j))\"", "lemma infinite_chain_lnth_rel:\n  assumes \"\\<not> lfinite c\" and \"chain r c\"\n  shows \"r (lnth c i) (lnth c (Suc i))\"", "lemma lnth_rel_chain:\n  assumes\n    \"\\<not> lnull xs\" and\n    \"\\<forall>j. enat (j + 1) < llength xs \\<longrightarrow> R (lnth xs j) (lnth xs (j + 1))\"\n  shows \"chain R xs\"", "lemma chain_lmap:\n  assumes \"\\<forall>x y. R x y \\<longrightarrow> R' (f x) (f y)\" and \"chain R xs\"\n  shows \"chain R' (lmap f xs)\"", "lemma chain_mono:\n  assumes \"\\<forall>x y. R x y \\<longrightarrow> R' x y\" and \"chain R xs\"\n  shows \"chain R' xs\"", "lemma lfinite_chain_imp_rtranclp_lhd_llast: \"lfinite xs \\<Longrightarrow> chain R xs \\<Longrightarrow> R\\<^sup>*\\<^sup>* (lhd xs) (llast xs)\"", "lemma tranclp_imp_exists_finite_chain_list:\n  \"R\\<^sup>+\\<^sup>+ x y \\<Longrightarrow> \\<exists>xs. chain R (llist_of (x # xs @ [y]))\"", "lemma lnull_prepend[simp]: \"lnull (prepend xs ys) = (xs = [] \\<and> lnull ys)\"", "lemma lhd_prepend[simp]: \"lhd (prepend xs ys) = (if xs \\<noteq> [] then hd xs else lhd ys)\"", "lemma prepend_LNil[simp]: \"prepend xs LNil = llist_of xs\"", "lemma lfinite_prepend[simp]: \"lfinite (prepend xs ys) \\<longleftrightarrow> lfinite ys\"", "lemma llength_prepend[simp]: \"llength (prepend xs ys) = length xs + llength ys\"", "lemma llast_prepend[simp]: \"\\<not> lnull ys \\<Longrightarrow> llast (prepend xs ys) = llast ys\"", "lemma prepend_prepend: \"prepend xs (prepend ys zs) = prepend (xs @ ys) zs\"", "lemma chain_prepend:\n  \"chain R (llist_of zs) \\<Longrightarrow> last zs = lhd xs \\<Longrightarrow> chain R xs \\<Longrightarrow> chain R (prepend zs (ltl xs))\"", "lemma lmap_prepend[simp]: \"lmap f (prepend xs ys) = prepend (map f xs) (lmap f ys)\"", "lemma lset_prepend[simp]: \"lset (prepend xs ys) = set xs \\<union> lset ys\"", "lemma prepend_LCons: \"prepend xs (LCons y ys) = prepend (xs @ [y]) ys\"", "lemma lnth_prepend:\n  \"lnth (prepend xs ys) i = (if i < length xs then nth xs i else lnth ys (i - length xs))\"", "theorem lfinite_less_induct[consumes 1, case_names less]:\n  assumes fin: \"lfinite xs\"\n    and step: \"\\<And>xs. lfinite xs \\<Longrightarrow> (\\<And>zs. llength zs < llength xs \\<Longrightarrow> P zs) \\<Longrightarrow> P xs\"\n  shows \"P xs\"", "theorem lfinite_prepend_induct[consumes 1, case_names LNil prepend]:\n  assumes \"lfinite xs\"\n    and LNil: \"P LNil\"\n    and prepend: \"\\<And>xs. lfinite xs \\<Longrightarrow> (\\<And>zs. (\\<exists>ys. xs = prepend ys zs \\<and> ys \\<noteq> []) \\<Longrightarrow> P zs) \\<Longrightarrow> P xs\"\n  shows \"P xs\"", "lemma emb_lfinite:\n  assumes \"emb xs ys\"\n  shows \"lfinite ys \\<longleftrightarrow> lfinite xs\"", "lemma emb_prepend_coinduct[rotated, case_names emb]:\n  assumes \"(\\<And>x1 x2. X x1 x2 \\<Longrightarrow>\n    (\\<exists>xs. x1 = LNil \\<and> x2 = xs \\<and> lfinite xs)\n     \\<or> (\\<exists>xs ys x zs. x1 = LCons x xs \\<and> x2 = prepend zs (LCons x ys)\n       \\<and> (prepend_cong1 (X xs) ys \\<or> emb xs ys)))\" (is \"\\<And>x1 x2. X x1 x2 \\<Longrightarrow> ?bisim x1 x2\")\n  shows \"X x1 x2 \\<Longrightarrow> emb x1 x2\"", "lemma chain_imp_chain': \"chain R xs \\<Longrightarrow> chain' R xs\"", "lemma chain'_imp_chain: \"chain' R xs \\<Longrightarrow> chain R xs\"", "lemma chain_chain': \"chain = chain'\"", "lemma chain_prepend_coinduct[case_names chain]:\n  \"X x \\<Longrightarrow> (\\<And>x. X x \\<Longrightarrow>\n    (\\<exists>z. x = LCons z LNil) \\<or>\n    (\\<exists>y xs zs. x = LCons y (prepend zs xs) \\<and>\n      (X xs \\<or> chain R xs) \\<and> chain R (llist_of (y # zs @ [lhd xs])))) \\<Longrightarrow> chain R x\"", "lemma pick[simp]:\n  assumes \"R\\<^sup>+\\<^sup>+ x y\"\n  shows \"chain R (llist_of (x # pick x y @ [y]))\"", "lemma\n  wit_LNil[simp]: \"wit LNil = LNil\" and\n  wit_lsingleton[simp]: \"wit (LCons x LNil) = LCons x LNil\" and\n  wit_LCons2: \"wit (LCons x (LCons y xs)) =\n     (LCons x (prepend (pick x y) (wit (LCons y xs))))\"", "lemma lnull_wit[simp]: \"lnull (wit xs) \\<longleftrightarrow> lnull xs\"", "lemma lhd_wit[simp]: \"chain R\\<^sup>+\\<^sup>+ xs \\<Longrightarrow> lhd (wit xs) = lhd xs\"", "lemma LNil_eq_iff_lnull: \"LNil = xs \\<longleftrightarrow> lnull xs\"", "lemma emb_wit[simp]: \"chain R\\<^sup>+\\<^sup>+ xs \\<Longrightarrow> emb xs (wit xs)\"", "lemma lfinite_wit[simp]:\n  assumes \"chain R\\<^sup>+\\<^sup>+ xs\"\n  shows \"lfinite (wit xs) \\<longleftrightarrow> lfinite xs\"", "lemma llast_wit[simp]:\n  assumes \"chain R\\<^sup>+\\<^sup>+ xs\"\n  shows \"llast (wit xs) = llast xs\"", "lemma chain_tranclp_imp_exists_chain:\n  \"chain R\\<^sup>+\\<^sup>+ xs \\<Longrightarrow>\n   \\<exists>ys. chain R ys \\<and> emb xs ys \\<and> lhd ys = lhd xs \\<and> llast ys = llast xs\"", "lemma emb_lset_mono[rotated]: \"x \\<in> lset xs \\<Longrightarrow> emb xs ys \\<Longrightarrow> x \\<in> lset ys\"", "lemma emb_Ball_lset_antimono:\n  assumes \"emb Xs Ys\"\n  shows \"\\<forall>Y \\<in> lset Ys. x \\<in> Y \\<Longrightarrow> \\<forall>X \\<in> lset Xs. x \\<in> X\"", "lemma emb_lfinite_antimono[rotated]: \"lfinite ys \\<Longrightarrow> emb xs ys \\<Longrightarrow> lfinite xs\"", "lemma emb_Liminf_llist_mono_aux:\n  assumes \"emb Xs Ys\" and \"\\<not> lfinite Xs\" and \"\\<not> lfinite Ys\" and \"\\<forall>j\\<ge>i. x \\<in> lnth Ys j\"\n  shows \"\\<forall>j\\<ge>i. x \\<in> lnth Xs j\"", "lemma emb_Liminf_llist_infinite:\n  assumes \"emb Xs Ys\" and \"\\<not> lfinite Xs\"\n  shows \"Liminf_llist Ys \\<subseteq> Liminf_llist Xs\"", "lemma emb_lmap: \"emb xs ys \\<Longrightarrow> emb (lmap f xs) (lmap f ys)\"", "lemma chain_inf_llist_if_infinite_chain_function:\n  assumes \"\\<forall>i. r (f (Suc i)) (f i)\"\n  shows \"\\<not> lfinite (inf_llist f) \\<and> chain r\\<inverse>\\<inverse> (inf_llist f)\"", "lemma infinite_chain_function_iff_infinite_chain_llist:\n  \"(\\<exists>f. \\<forall>i. r (f (Suc i)) (f i)) \\<longleftrightarrow> (\\<exists>c. \\<not> lfinite c \\<and> chain r\\<inverse>\\<inverse> c)\"", "lemma wfP_iff_no_infinite_down_chain_llist: \"wfP r \\<longleftrightarrow> (\\<nexists>c. \\<not> lfinite c \\<and> chain r\\<inverse>\\<inverse> c)\"", "lemma\n  full_chain_LNil[simp]: \"\\<not> full_chain R LNil\" and\n  full_chain_not_lnull: \"full_chain R xs \\<Longrightarrow> \\<not> lnull xs\"", "lemma full_chain_ldropn:\n  assumes full: \"full_chain R xs\" and \"enat n < llength xs\"\n  shows \"full_chain R (ldropn n xs)\"", "lemma full_chain_iff_chain:\n  \"full_chain R xs \\<longleftrightarrow> chain R xs \\<and> (lfinite xs \\<longrightarrow> (\\<forall>y. \\<not> R (llast xs) y))\"", "lemma full_chain_imp_chain: \"full_chain R xs \\<Longrightarrow> chain R xs\"", "lemma full_chain_length_pos: \"full_chain R xs \\<Longrightarrow> llength xs > 0\"", "lemma full_chain_lnth_rel:\n  \"full_chain R xs \\<Longrightarrow> enat (Suc j) < llength xs \\<Longrightarrow> R (lnth xs j) (lnth xs (Suc j))\"", "lemma full_chain_tranclp_imp_exists_full_chain:\n  assumes full: \"full_chain R\\<^sup>+\\<^sup>+ xs\"\n  shows \"\\<exists>ys. full_chain R ys \\<and> emb xs ys \\<and> lhd ys = lhd xs \\<and> llast ys = llast xs\""], "translations": [["", "lemma\n  chain_LNil[simp]: \"\\<not> chain R LNil\" and\n  chain_not_lnull: \"chain R xs \\<Longrightarrow> \\<not> lnull xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> chain R LNil &&& (chain R xs \\<Longrightarrow> \\<not> lnull xs)", "by (auto elim: chain.cases)"], ["", "lemma chain_lappend:\n  assumes\n    r_xs: \"chain R xs\" and\n    r_ys: \"chain R ys\" and\n    mid: \"R (llast xs) (lhd ys)\"\n  shows \"chain R (lappend xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain R (lappend xs ys)", "proof (cases \"lfinite xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lfinite xs \\<Longrightarrow> chain R (lappend xs ys)\n 2. \\<not> lfinite xs \\<Longrightarrow> chain R (lappend xs ys)", "case True"], ["proof (state)\nthis:\n  lfinite xs\n\ngoal (2 subgoals):\n 1. lfinite xs \\<Longrightarrow> chain R (lappend xs ys)\n 2. \\<not> lfinite xs \\<Longrightarrow> chain R (lappend xs ys)", "then"], ["proof (chain)\npicking this:\n  lfinite xs", "show ?thesis"], ["proof (prove)\nusing this:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. chain R (lappend xs ys)", "using r_xs mid"], ["proof (prove)\nusing this:\n  lfinite xs\n  chain R xs\n  R (llast xs) (lhd ys)\n\ngoal (1 subgoal):\n 1. chain R (lappend xs ys)", "proof (induct rule: lfinite.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>chain R LNil; R (llast LNil) (lhd ys)\\<rbrakk>\n    \\<Longrightarrow> chain R (lappend LNil ys)\n 2. \\<And>xs x.\n       \\<lbrakk>lfinite xs;\n        \\<lbrakk>chain R xs; R (llast xs) (lhd ys)\\<rbrakk>\n        \\<Longrightarrow> chain R (lappend xs ys);\n        chain R (LCons x xs); R (llast (LCons x xs)) (lhd ys)\\<rbrakk>\n       \\<Longrightarrow> chain R (lappend (LCons x xs) ys)", "case (lfinite_LConsI xs x)"], ["proof (state)\nthis:\n  lfinite xs\n  \\<lbrakk>chain R xs; R (llast xs) (lhd ys)\\<rbrakk>\n  \\<Longrightarrow> chain R (lappend xs ys)\n  chain R (LCons x xs)\n  R (llast (LCons x xs)) (lhd ys)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>chain R LNil; R (llast LNil) (lhd ys)\\<rbrakk>\n    \\<Longrightarrow> chain R (lappend LNil ys)\n 2. \\<And>xs x.\n       \\<lbrakk>lfinite xs;\n        \\<lbrakk>chain R xs; R (llast xs) (lhd ys)\\<rbrakk>\n        \\<Longrightarrow> chain R (lappend xs ys);\n        chain R (LCons x xs); R (llast (LCons x xs)) (lhd ys)\\<rbrakk>\n       \\<Longrightarrow> chain R (lappend (LCons x xs) ys)", "note fin = this(1) and ih = this(2) and r_xxs = this(3) and mid = this(4)"], ["proof (state)\nthis:\n  lfinite xs\n  \\<lbrakk>chain R xs; R (llast xs) (lhd ys)\\<rbrakk>\n  \\<Longrightarrow> chain R (lappend xs ys)\n  chain R (LCons x xs)\n  R (llast (LCons x xs)) (lhd ys)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>chain R LNil; R (llast LNil) (lhd ys)\\<rbrakk>\n    \\<Longrightarrow> chain R (lappend LNil ys)\n 2. \\<And>xs x.\n       \\<lbrakk>lfinite xs;\n        \\<lbrakk>chain R xs; R (llast xs) (lhd ys)\\<rbrakk>\n        \\<Longrightarrow> chain R (lappend xs ys);\n        chain R (LCons x xs); R (llast (LCons x xs)) (lhd ys)\\<rbrakk>\n       \\<Longrightarrow> chain R (lappend (LCons x xs) ys)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. chain R (lappend (LCons x xs) ys)", "proof (cases \"xs = LNil\")"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = LNil \\<Longrightarrow> chain R (lappend (LCons x xs) ys)\n 2. xs \\<noteq> LNil \\<Longrightarrow> chain R (lappend (LCons x xs) ys)", "case True"], ["proof (state)\nthis:\n  xs = LNil\n\ngoal (2 subgoals):\n 1. xs = LNil \\<Longrightarrow> chain R (lappend (LCons x xs) ys)\n 2. xs \\<noteq> LNil \\<Longrightarrow> chain R (lappend (LCons x xs) ys)", "then"], ["proof (chain)\npicking this:\n  xs = LNil", "show ?thesis"], ["proof (prove)\nusing this:\n  xs = LNil\n\ngoal (1 subgoal):\n 1. chain R (lappend (LCons x xs) ys)", "using r_ys mid"], ["proof (prove)\nusing this:\n  xs = LNil\n  chain R ys\n  R (llast (LCons x xs)) (lhd ys)\n\ngoal (1 subgoal):\n 1. chain R (lappend (LCons x xs) ys)", "by simp (rule chain_cons)"], ["proof (state)\nthis:\n  chain R (lappend (LCons x xs) ys)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> LNil \\<Longrightarrow> chain R (lappend (LCons x xs) ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xs \\<noteq> LNil \\<Longrightarrow> chain R (lappend (LCons x xs) ys)", "case xs_nnil: False"], ["proof (state)\nthis:\n  xs \\<noteq> LNil\n\ngoal (1 subgoal):\n 1. xs \\<noteq> LNil \\<Longrightarrow> chain R (lappend (LCons x xs) ys)", "have r_xs: \"chain R xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain R xs", "by (metis chain.simps ltl_simps(2) r_xxs xs_nnil)"], ["proof (state)\nthis:\n  chain R xs\n\ngoal (1 subgoal):\n 1. xs \\<noteq> LNil \\<Longrightarrow> chain R (lappend (LCons x xs) ys)", "have mid': \"R (llast xs) (lhd ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R (llast xs) (lhd ys)", "by (metis llast_LCons lnull_def mid xs_nnil)"], ["proof (state)\nthis:\n  R (llast xs) (lhd ys)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> LNil \\<Longrightarrow> chain R (lappend (LCons x xs) ys)", "have start: \"R x (lhd (lappend xs ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R x (lhd (lappend xs ys))", "by (metis (no_types) chain.simps lhd_LCons lhd_lappend chain_not_lnull ltl_simps(2) r_xxs\n            xs_nnil)"], ["proof (state)\nthis:\n  R x (lhd (lappend xs ys))\n\ngoal (1 subgoal):\n 1. xs \\<noteq> LNil \\<Longrightarrow> chain R (lappend (LCons x xs) ys)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. chain R (lappend (LCons x xs) ys)", "unfolding lappend_code(2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. chain R (LCons x (lappend xs ys))", "using ih[OF r_xs mid'] start"], ["proof (prove)\nusing this:\n  chain R (lappend xs ys)\n  R x (lhd (lappend xs ys))\n\ngoal (1 subgoal):\n 1. chain R (LCons x (lappend xs ys))", "by (rule chain_cons)"], ["proof (state)\nthis:\n  chain R (lappend (LCons x xs) ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  chain R (lappend (LCons x xs) ys)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>chain R LNil; R (llast LNil) (lhd ys)\\<rbrakk>\n    \\<Longrightarrow> chain R (lappend LNil ys)", "qed simp"], ["proof (state)\nthis:\n  chain R (lappend xs ys)\n\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow> chain R (lappend xs ys)", "qed (simp add: r_xs lappend_inf)"], ["", "lemma chain_length_pos: \"chain R xs \\<Longrightarrow> llength xs > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain R xs \\<Longrightarrow> 0 < llength xs", "by (cases xs) simp+"], ["", "lemma chain_ldropn:\n  assumes \"chain R xs\" and \"enat n < llength xs\"\n  shows \"chain R (ldropn n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain R (ldropn n xs)", "using assms"], ["proof (prove)\nusing this:\n  chain R xs\n  enat n < llength xs\n\ngoal (1 subgoal):\n 1. chain R (ldropn n xs)", "by (induct n arbitrary: xs, simp,\n      metis chain.cases ldrop_eSuc_ltl ldropn_LNil ldropn_eq_LNil ltl_simps(2) not_less)"], ["", "lemma inf_chain_ldropn_chain: \"chain R xs \\<Longrightarrow> \\<not> lfinite xs \\<Longrightarrow> chain R (ldropn n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>chain R xs; \\<not> lfinite xs\\<rbrakk>\n    \\<Longrightarrow> chain R (ldropn n xs)", "using chain.simps[of R xs]"], ["proof (prove)\nusing this:\n  chain R xs =\n  ((\\<exists>x. xs = LCons x LNil) \\<or>\n   (\\<exists>xsa x.\n       xs = LCons x xsa \\<and> chain R xsa \\<and> R x (lhd xsa)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>chain R xs; \\<not> lfinite xs\\<rbrakk>\n    \\<Longrightarrow> chain R (ldropn n xs)", "by (simp add: chain_ldropn not_lfinite_llength)"], ["", "lemma inf_chain_ltl_chain: \"chain R xs \\<Longrightarrow> \\<not> lfinite xs \\<Longrightarrow> chain R (ltl xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>chain R xs; \\<not> lfinite xs\\<rbrakk>\n    \\<Longrightarrow> chain R (ltl xs)", "by (metis inf_chain_ldropn_chain ldropn_0 ldropn_ltl)"], ["", "lemma chain_lnth_rel:\n  assumes\n    chain: \"chain R xs\" and\n    len: \"enat (Suc j) < llength xs\"\n  shows \"R (lnth xs j) (lnth xs (Suc j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R (lnth xs j) (lnth xs (Suc j))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. R (lnth xs j) (lnth xs (Suc j))", "define ys where \"ys = ldropn j xs\""], ["proof (state)\nthis:\n  ys = ldropn j xs\n\ngoal (1 subgoal):\n 1. R (lnth xs j) (lnth xs (Suc j))", "have \"llength ys > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < llength ys", "unfolding ys_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < llength (ldropn j xs)", "using len"], ["proof (prove)\nusing this:\n  enat (Suc j) < llength xs\n\ngoal (1 subgoal):\n 1. 1 < llength (ldropn j xs)", "by (metis One_nat_def funpow_swap1 ldropn_0 ldropn_def ldropn_eq_LNil ldropn_ltl not_less\n        one_enat_def)"], ["proof (state)\nthis:\n  1 < llength ys\n\ngoal (1 subgoal):\n 1. R (lnth xs j) (lnth xs (Suc j))", "obtain y0 y1 ys' where\n    ys: \"ys = LCons y0 (LCons y1 ys')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y0 y1 ys'.\n        ys = LCons y0 (LCons y1 ys') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding ys_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y0 y1 ys'.\n        ldropn j xs = LCons y0 (LCons y1 ys') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis Suc_ile_eq ldropn_Suc_conv_ldropn len less_imp_not_less not_less)"], ["proof (state)\nthis:\n  ys = LCons y0 (LCons y1 ys')\n\ngoal (1 subgoal):\n 1. R (lnth xs j) (lnth xs (Suc j))", "have \"chain R ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain R ys", "unfolding ys_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. chain R (ldropn j xs)", "using Suc_ile_eq chain chain_ldropn len less_imp_le"], ["proof (prove)\nusing this:\n  (enat (Suc ?m) \\<le> ?n) = (enat ?m < ?n)\n  chain R xs\n  \\<lbrakk>chain ?R ?xs; enat ?n < llength ?xs\\<rbrakk>\n  \\<Longrightarrow> chain ?R (ldropn ?n ?xs)\n  enat (Suc j) < llength xs\n  ?x < ?y \\<Longrightarrow> ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. chain R (ldropn j xs)", "by blast"], ["proof (state)\nthis:\n  chain R ys\n\ngoal (1 subgoal):\n 1. R (lnth xs j) (lnth xs (Suc j))", "then"], ["proof (chain)\npicking this:\n  chain R ys", "have \"R y0 y1\""], ["proof (prove)\nusing this:\n  chain R ys\n\ngoal (1 subgoal):\n 1. R y0 y1", "unfolding ys"], ["proof (prove)\nusing this:\n  chain R (LCons y0 (LCons y1 ys'))\n\ngoal (1 subgoal):\n 1. R y0 y1", "by (auto elim: chain.cases)"], ["proof (state)\nthis:\n  R y0 y1\n\ngoal (1 subgoal):\n 1. R (lnth xs j) (lnth xs (Suc j))", "then"], ["proof (chain)\npicking this:\n  R y0 y1", "show ?thesis"], ["proof (prove)\nusing this:\n  R y0 y1\n\ngoal (1 subgoal):\n 1. R (lnth xs j) (lnth xs (Suc j))", "using ys_def"], ["proof (prove)\nusing this:\n  R y0 y1\n  ys = ldropn j xs\n\ngoal (1 subgoal):\n 1. R (lnth xs j) (lnth xs (Suc j))", "unfolding ys"], ["proof (prove)\nusing this:\n  R y0 y1\n  LCons y0 (LCons y1 ys') = ldropn j xs\n\ngoal (1 subgoal):\n 1. R (lnth xs j) (lnth xs (Suc j))", "by (metis ldropn_Suc_conv_ldropn ldropn_eq_LConsD llist.inject)"], ["proof (state)\nthis:\n  R (lnth xs j) (lnth xs (Suc j))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma infinite_chain_lnth_rel:\n  assumes \"\\<not> lfinite c\" and \"chain r c\"\n  shows \"r (lnth c i) (lnth c (Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r (lnth c i) (lnth c (Suc i))", "using assms chain_lnth_rel lfinite_conv_llength_enat"], ["proof (prove)\nusing this:\n  \\<not> lfinite c\n  chain r c\n  \\<lbrakk>chain ?R ?xs; enat (Suc ?j) < llength ?xs\\<rbrakk>\n  \\<Longrightarrow> ?R (lnth ?xs ?j) (lnth ?xs (Suc ?j))\n  lfinite ?xs = (\\<exists>n. llength ?xs = enat n)\n\ngoal (1 subgoal):\n 1. r (lnth c i) (lnth c (Suc i))", "by force"], ["", "lemma lnth_rel_chain:\n  assumes\n    \"\\<not> lnull xs\" and\n    \"\\<forall>j. enat (j + 1) < llength xs \\<longrightarrow> R (lnth xs j) (lnth xs (j + 1))\"\n  shows \"chain R xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain R xs", "using assms"], ["proof (prove)\nusing this:\n  \\<not> lnull xs\n  \\<forall>j.\n     enat (j + 1) < llength xs \\<longrightarrow>\n     R (lnth xs j) (lnth xs (j + 1))\n\ngoal (1 subgoal):\n 1. chain R xs", "proof (coinduction arbitrary: xs rule: chain.coinduct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<not> lnull xs;\n        \\<forall>j.\n           enat (j + 1) < llength xs \\<longrightarrow>\n           R (lnth xs j) (lnth xs (j + 1))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x. xs = LCons x LNil) \\<or>\n                         (\\<exists>xsa x.\n                             xs = LCons x xsa \\<and>\n                             ((\\<exists>xs.\n                                  xsa = xs \\<and>\n                                  \\<not> lnull xs \\<and>\n                                  (\\<forall>j.\nenat (j + 1) < llength xs \\<longrightarrow>\nR (lnth xs j) (lnth xs (j + 1)))) \\<or>\n                              chain R xsa) \\<and>\n                             R x (lhd xsa))", "case chain"], ["proof (state)\nthis:\n  \\<not> lnull xs\n  \\<forall>j.\n     enat (j + 1) < llength xs \\<longrightarrow>\n     R (lnth xs j) (lnth xs (j + 1))\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<not> lnull xs;\n        \\<forall>j.\n           enat (j + 1) < llength xs \\<longrightarrow>\n           R (lnth xs j) (lnth xs (j + 1))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x. xs = LCons x LNil) \\<or>\n                         (\\<exists>xsa x.\n                             xs = LCons x xsa \\<and>\n                             ((\\<exists>xs.\n                                  xsa = xs \\<and>\n                                  \\<not> lnull xs \\<and>\n                                  (\\<forall>j.\nenat (j + 1) < llength xs \\<longrightarrow>\nR (lnth xs j) (lnth xs (j + 1)))) \\<or>\n                              chain R xsa) \\<and>\n                             R x (lhd xsa))", "note nnul = this(1) and nth_chain = this(2)"], ["proof (state)\nthis:\n  \\<not> lnull xs\n  \\<forall>j.\n     enat (j + 1) < llength xs \\<longrightarrow>\n     R (lnth xs j) (lnth xs (j + 1))\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<not> lnull xs;\n        \\<forall>j.\n           enat (j + 1) < llength xs \\<longrightarrow>\n           R (lnth xs j) (lnth xs (j + 1))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x. xs = LCons x LNil) \\<or>\n                         (\\<exists>xsa x.\n                             xs = LCons x xsa \\<and>\n                             ((\\<exists>xs.\n                                  xsa = xs \\<and>\n                                  \\<not> lnull xs \\<and>\n                                  (\\<forall>j.\nenat (j + 1) < llength xs \\<longrightarrow>\nR (lnth xs j) (lnth xs (j + 1)))) \\<or>\n                              chain R xsa) \\<and>\n                             R x (lhd xsa))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. xs = LCons x LNil) \\<or>\n    (\\<exists>xs x.\n        xs = LCons x xs \\<and>\n        ((\\<exists>xsa.\n             xs = xsa \\<and>\n             \\<not> lnull xsa \\<and>\n             (\\<forall>j.\n                 enat (j + 1) < llength xsa \\<longrightarrow>\n                 R (lnth xsa j) (lnth xsa (j + 1)))) \\<or>\n         chain R xs) \\<and>\n        R x (lhd xs))", "proof (cases \"lnull (ltl xs)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lnull (ltl xs) \\<Longrightarrow>\n    (\\<exists>x. xs = LCons x LNil) \\<or>\n    (\\<exists>xs x.\n        xs = LCons x xs \\<and>\n        ((\\<exists>xsa.\n             xs = xsa \\<and>\n             \\<not> lnull xsa \\<and>\n             (\\<forall>j.\n                 enat (j + 1) < llength xsa \\<longrightarrow>\n                 R (lnth xsa j) (lnth xsa (j + 1)))) \\<or>\n         chain R xs) \\<and>\n        R x (lhd xs))\n 2. \\<not> lnull (ltl xs) \\<Longrightarrow>\n    (\\<exists>x. xs = LCons x LNil) \\<or>\n    (\\<exists>xs x.\n        xs = LCons x xs \\<and>\n        ((\\<exists>xsa.\n             xs = xsa \\<and>\n             \\<not> lnull xsa \\<and>\n             (\\<forall>j.\n                 enat (j + 1) < llength xsa \\<longrightarrow>\n                 R (lnth xsa j) (lnth xsa (j + 1)))) \\<or>\n         chain R xs) \\<and>\n        R x (lhd xs))", "case True"], ["proof (state)\nthis:\n  lnull (ltl xs)\n\ngoal (2 subgoals):\n 1. lnull (ltl xs) \\<Longrightarrow>\n    (\\<exists>x. xs = LCons x LNil) \\<or>\n    (\\<exists>xs x.\n        xs = LCons x xs \\<and>\n        ((\\<exists>xsa.\n             xs = xsa \\<and>\n             \\<not> lnull xsa \\<and>\n             (\\<forall>j.\n                 enat (j + 1) < llength xsa \\<longrightarrow>\n                 R (lnth xsa j) (lnth xsa (j + 1)))) \\<or>\n         chain R xs) \\<and>\n        R x (lhd xs))\n 2. \\<not> lnull (ltl xs) \\<Longrightarrow>\n    (\\<exists>x. xs = LCons x LNil) \\<or>\n    (\\<exists>xs x.\n        xs = LCons x xs \\<and>\n        ((\\<exists>xsa.\n             xs = xsa \\<and>\n             \\<not> lnull xsa \\<and>\n             (\\<forall>j.\n                 enat (j + 1) < llength xsa \\<longrightarrow>\n                 R (lnth xsa j) (lnth xsa (j + 1)))) \\<or>\n         chain R xs) \\<and>\n        R x (lhd xs))", "have \"xs = LCons (lhd xs) LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = LCons (lhd xs) LNil", "using nnul True"], ["proof (prove)\nusing this:\n  \\<not> lnull xs\n  lnull (ltl xs)\n\ngoal (1 subgoal):\n 1. xs = LCons (lhd xs) LNil", "by (simp add: llist.expand)"], ["proof (state)\nthis:\n  xs = LCons (lhd xs) LNil\n\ngoal (2 subgoals):\n 1. lnull (ltl xs) \\<Longrightarrow>\n    (\\<exists>x. xs = LCons x LNil) \\<or>\n    (\\<exists>xs x.\n        xs = LCons x xs \\<and>\n        ((\\<exists>xsa.\n             xs = xsa \\<and>\n             \\<not> lnull xsa \\<and>\n             (\\<forall>j.\n                 enat (j + 1) < llength xsa \\<longrightarrow>\n                 R (lnth xsa j) (lnth xsa (j + 1)))) \\<or>\n         chain R xs) \\<and>\n        R x (lhd xs))\n 2. \\<not> lnull (ltl xs) \\<Longrightarrow>\n    (\\<exists>x. xs = LCons x LNil) \\<or>\n    (\\<exists>xs x.\n        xs = LCons x xs \\<and>\n        ((\\<exists>xsa.\n             xs = xsa \\<and>\n             \\<not> lnull xsa \\<and>\n             (\\<forall>j.\n                 enat (j + 1) < llength xsa \\<longrightarrow>\n                 R (lnth xsa j) (lnth xsa (j + 1)))) \\<or>\n         chain R xs) \\<and>\n        R x (lhd xs))", "then"], ["proof (chain)\npicking this:\n  xs = LCons (lhd xs) LNil", "show ?thesis"], ["proof (prove)\nusing this:\n  xs = LCons (lhd xs) LNil\n\ngoal (1 subgoal):\n 1. (\\<exists>x. xs = LCons x LNil) \\<or>\n    (\\<exists>xs x.\n        xs = LCons x xs \\<and>\n        ((\\<exists>xsa.\n             xs = xsa \\<and>\n             \\<not> lnull xsa \\<and>\n             (\\<forall>j.\n                 enat (j + 1) < llength xsa \\<longrightarrow>\n                 R (lnth xsa j) (lnth xsa (j + 1)))) \\<or>\n         chain R xs) \\<and>\n        R x (lhd xs))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>x. xs = LCons x LNil) \\<or>\n  (\\<exists>xs x.\n      xs = LCons x xs \\<and>\n      ((\\<exists>xsa.\n           xs = xsa \\<and>\n           \\<not> lnull xsa \\<and>\n           (\\<forall>j.\n               enat (j + 1) < llength xsa \\<longrightarrow>\n               R (lnth xsa j) (lnth xsa (j + 1)))) \\<or>\n       chain R xs) \\<and>\n      R x (lhd xs))\n\ngoal (1 subgoal):\n 1. \\<not> lnull (ltl xs) \\<Longrightarrow>\n    (\\<exists>x. xs = LCons x LNil) \\<or>\n    (\\<exists>xs x.\n        xs = LCons x xs \\<and>\n        ((\\<exists>xsa.\n             xs = xsa \\<and>\n             \\<not> lnull xsa \\<and>\n             (\\<forall>j.\n                 enat (j + 1) < llength xsa \\<longrightarrow>\n                 R (lnth xsa j) (lnth xsa (j + 1)))) \\<or>\n         chain R xs) \\<and>\n        R x (lhd xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> lnull (ltl xs) \\<Longrightarrow>\n    (\\<exists>x. xs = LCons x LNil) \\<or>\n    (\\<exists>xs x.\n        xs = LCons x xs \\<and>\n        ((\\<exists>xsa.\n             xs = xsa \\<and>\n             \\<not> lnull xsa \\<and>\n             (\\<forall>j.\n                 enat (j + 1) < llength xsa \\<longrightarrow>\n                 R (lnth xsa j) (lnth xsa (j + 1)))) \\<or>\n         chain R xs) \\<and>\n        R x (lhd xs))", "case nnul': False"], ["proof (state)\nthis:\n  \\<not> lnull (ltl xs)\n\ngoal (1 subgoal):\n 1. \\<not> lnull (ltl xs) \\<Longrightarrow>\n    (\\<exists>x. xs = LCons x LNil) \\<or>\n    (\\<exists>xs x.\n        xs = LCons x xs \\<and>\n        ((\\<exists>xsa.\n             xs = xsa \\<and>\n             \\<not> lnull xsa \\<and>\n             (\\<forall>j.\n                 enat (j + 1) < llength xsa \\<longrightarrow>\n                 R (lnth xsa j) (lnth xsa (j + 1)))) \\<or>\n         chain R xs) \\<and>\n        R x (lhd xs))", "moreover"], ["proof (state)\nthis:\n  \\<not> lnull (ltl xs)\n\ngoal (1 subgoal):\n 1. \\<not> lnull (ltl xs) \\<Longrightarrow>\n    (\\<exists>x. xs = LCons x LNil) \\<or>\n    (\\<exists>xs x.\n        xs = LCons x xs \\<and>\n        ((\\<exists>xsa.\n             xs = xsa \\<and>\n             \\<not> lnull xsa \\<and>\n             (\\<forall>j.\n                 enat (j + 1) < llength xsa \\<longrightarrow>\n                 R (lnth xsa j) (lnth xsa (j + 1)))) \\<or>\n         chain R xs) \\<and>\n        R x (lhd xs))", "have \"xs = LCons (lhd xs) (ltl xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = LCons (lhd xs) (ltl xs)", "using nnul"], ["proof (prove)\nusing this:\n  \\<not> lnull xs\n\ngoal (1 subgoal):\n 1. xs = LCons (lhd xs) (ltl xs)", "by simp"], ["proof (state)\nthis:\n  xs = LCons (lhd xs) (ltl xs)\n\ngoal (1 subgoal):\n 1. \\<not> lnull (ltl xs) \\<Longrightarrow>\n    (\\<exists>x. xs = LCons x LNil) \\<or>\n    (\\<exists>xs x.\n        xs = LCons x xs \\<and>\n        ((\\<exists>xsa.\n             xs = xsa \\<and>\n             \\<not> lnull xsa \\<and>\n             (\\<forall>j.\n                 enat (j + 1) < llength xsa \\<longrightarrow>\n                 R (lnth xsa j) (lnth xsa (j + 1)))) \\<or>\n         chain R xs) \\<and>\n        R x (lhd xs))", "moreover"], ["proof (state)\nthis:\n  xs = LCons (lhd xs) (ltl xs)\n\ngoal (1 subgoal):\n 1. \\<not> lnull (ltl xs) \\<Longrightarrow>\n    (\\<exists>x. xs = LCons x LNil) \\<or>\n    (\\<exists>xs x.\n        xs = LCons x xs \\<and>\n        ((\\<exists>xsa.\n             xs = xsa \\<and>\n             \\<not> lnull xsa \\<and>\n             (\\<forall>j.\n                 enat (j + 1) < llength xsa \\<longrightarrow>\n                 R (lnth xsa j) (lnth xsa (j + 1)))) \\<or>\n         chain R xs) \\<and>\n        R x (lhd xs))", "have\n      \"\\<forall>j. enat (j + 1) < llength (ltl xs) \\<longrightarrow> R (lnth (ltl xs) j) (lnth (ltl xs) (j + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j.\n       enat (j + 1) < llength (ltl xs) \\<longrightarrow>\n       R (lnth (ltl xs) j) (lnth (ltl xs) (j + 1))", "using nnul nth_chain"], ["proof (prove)\nusing this:\n  \\<not> lnull xs\n  \\<forall>j.\n     enat (j + 1) < llength xs \\<longrightarrow>\n     R (lnth xs j) (lnth xs (j + 1))\n\ngoal (1 subgoal):\n 1. \\<forall>j.\n       enat (j + 1) < llength (ltl xs) \\<longrightarrow>\n       R (lnth (ltl xs) j) (lnth (ltl xs) (j + 1))", "by (metis Suc_eq_plus1 ldrop_eSuc_ltl ldropn_Suc_conv_ldropn ldropn_eq_LConsD lnth_ltl)"], ["proof (state)\nthis:\n  \\<forall>j.\n     enat (j + 1) < llength (ltl xs) \\<longrightarrow>\n     R (lnth (ltl xs) j) (lnth (ltl xs) (j + 1))\n\ngoal (1 subgoal):\n 1. \\<not> lnull (ltl xs) \\<Longrightarrow>\n    (\\<exists>x. xs = LCons x LNil) \\<or>\n    (\\<exists>xs x.\n        xs = LCons x xs \\<and>\n        ((\\<exists>xsa.\n             xs = xsa \\<and>\n             \\<not> lnull xsa \\<and>\n             (\\<forall>j.\n                 enat (j + 1) < llength xsa \\<longrightarrow>\n                 R (lnth xsa j) (lnth xsa (j + 1)))) \\<or>\n         chain R xs) \\<and>\n        R x (lhd xs))", "moreover"], ["proof (state)\nthis:\n  \\<forall>j.\n     enat (j + 1) < llength (ltl xs) \\<longrightarrow>\n     R (lnth (ltl xs) j) (lnth (ltl xs) (j + 1))\n\ngoal (1 subgoal):\n 1. \\<not> lnull (ltl xs) \\<Longrightarrow>\n    (\\<exists>x. xs = LCons x LNil) \\<or>\n    (\\<exists>xs x.\n        xs = LCons x xs \\<and>\n        ((\\<exists>xsa.\n             xs = xsa \\<and>\n             \\<not> lnull xsa \\<and>\n             (\\<forall>j.\n                 enat (j + 1) < llength xsa \\<longrightarrow>\n                 R (lnth xsa j) (lnth xsa (j + 1)))) \\<or>\n         chain R xs) \\<and>\n        R x (lhd xs))", "have \"R (lhd xs) (lhd (ltl xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R (lhd xs) (lhd (ltl xs))", "using nnul' nnul nth_chain[rule_format, of 0, simplified]"], ["proof (prove)\nusing this:\n  \\<not> lnull (ltl xs)\n  \\<not> lnull xs\n  enat (Suc 0) < llength xs \\<Longrightarrow>\n  R (lnth xs 0) (lnth xs (Suc 0))\n\ngoal (1 subgoal):\n 1. R (lhd xs) (lhd (ltl xs))", "by (metis ldropn_0 ldropn_Suc_conv_ldropn ldropn_eq_LConsD lhd_LCons_ltl lhd_conv_lnth\n          lnth_Suc_LCons ltl_simps(2))"], ["proof (state)\nthis:\n  R (lhd xs) (lhd (ltl xs))\n\ngoal (1 subgoal):\n 1. \\<not> lnull (ltl xs) \\<Longrightarrow>\n    (\\<exists>x. xs = LCons x LNil) \\<or>\n    (\\<exists>xs x.\n        xs = LCons x xs \\<and>\n        ((\\<exists>xsa.\n             xs = xsa \\<and>\n             \\<not> lnull xsa \\<and>\n             (\\<forall>j.\n                 enat (j + 1) < llength xsa \\<longrightarrow>\n                 R (lnth xsa j) (lnth xsa (j + 1)))) \\<or>\n         chain R xs) \\<and>\n        R x (lhd xs))", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> lnull (ltl xs)\n  xs = LCons (lhd xs) (ltl xs)\n  \\<forall>j.\n     enat (j + 1) < llength (ltl xs) \\<longrightarrow>\n     R (lnth (ltl xs) j) (lnth (ltl xs) (j + 1))\n  R (lhd xs) (lhd (ltl xs))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> lnull (ltl xs)\n  xs = LCons (lhd xs) (ltl xs)\n  \\<forall>j.\n     enat (j + 1) < llength (ltl xs) \\<longrightarrow>\n     R (lnth (ltl xs) j) (lnth (ltl xs) (j + 1))\n  R (lhd xs) (lhd (ltl xs))\n\ngoal (1 subgoal):\n 1. (\\<exists>x. xs = LCons x LNil) \\<or>\n    (\\<exists>xs x.\n        xs = LCons x xs \\<and>\n        ((\\<exists>xsa.\n             xs = xsa \\<and>\n             \\<not> lnull xsa \\<and>\n             (\\<forall>j.\n                 enat (j + 1) < llength xsa \\<longrightarrow>\n                 R (lnth xsa j) (lnth xsa (j + 1)))) \\<or>\n         chain R xs) \\<and>\n        R x (lhd xs))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>x. xs = LCons x LNil) \\<or>\n  (\\<exists>xs x.\n      xs = LCons x xs \\<and>\n      ((\\<exists>xsa.\n           xs = xsa \\<and>\n           \\<not> lnull xsa \\<and>\n           (\\<forall>j.\n               enat (j + 1) < llength xsa \\<longrightarrow>\n               R (lnth xsa j) (lnth xsa (j + 1)))) \\<or>\n       chain R xs) \\<and>\n      R x (lhd xs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>x. xs = LCons x LNil) \\<or>\n  (\\<exists>xs x.\n      xs = LCons x xs \\<and>\n      ((\\<exists>xsa.\n           xs = xsa \\<and>\n           \\<not> lnull xsa \\<and>\n           (\\<forall>j.\n               enat (j + 1) < llength xsa \\<longrightarrow>\n               R (lnth xsa j) (lnth xsa (j + 1)))) \\<or>\n       chain R xs) \\<and>\n      R x (lhd xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma chain_lmap:\n  assumes \"\\<forall>x y. R x y \\<longrightarrow> R' (f x) (f y)\" and \"chain R xs\"\n  shows \"chain R' (lmap f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain R' (lmap f xs)", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>x y. R x y \\<longrightarrow> R' (f x) (f y)\n  chain R xs\n\ngoal (1 subgoal):\n 1. chain R' (lmap f xs)", "proof (coinduction arbitrary: xs)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>x y. R x y \\<longrightarrow> R' (f x) (f y);\n        chain R xs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x. lmap f xs = LCons x LNil) \\<or>\n                         (\\<exists>xsa x.\n                             lmap f xs = LCons x xsa \\<and>\n                             ((\\<exists>xs.\n                                  xsa = lmap f xs \\<and>\n                                  (\\<forall>x y.\nR x y \\<longrightarrow> R' (f x) (f y)) \\<and>\n                                  chain R xs) \\<or>\n                              chain R' xsa) \\<and>\n                             R' x (lhd xsa))", "case chain"], ["proof (state)\nthis:\n  \\<forall>x y. R x y \\<longrightarrow> R' (f x) (f y)\n  chain R xs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>x y. R x y \\<longrightarrow> R' (f x) (f y);\n        chain R xs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x. lmap f xs = LCons x LNil) \\<or>\n                         (\\<exists>xsa x.\n                             lmap f xs = LCons x xsa \\<and>\n                             ((\\<exists>xs.\n                                  xsa = lmap f xs \\<and>\n                                  (\\<forall>x y.\nR x y \\<longrightarrow> R' (f x) (f y)) \\<and>\n                                  chain R xs) \\<or>\n                              chain R' xsa) \\<and>\n                             R' x (lhd xsa))", "then"], ["proof (chain)\npicking this:\n  \\<forall>x y. R x y \\<longrightarrow> R' (f x) (f y)\n  chain R xs", "have \"(\\<exists>y. xs = LCons y LNil) \\<or> (\\<exists>ys x. xs = LCons x ys \\<and> chain R ys \\<and> R x (lhd ys))\""], ["proof (prove)\nusing this:\n  \\<forall>x y. R x y \\<longrightarrow> R' (f x) (f y)\n  chain R xs\n\ngoal (1 subgoal):\n 1. (\\<exists>y. xs = LCons y LNil) \\<or>\n    (\\<exists>ys x. xs = LCons x ys \\<and> chain R ys \\<and> R x (lhd ys))", "using chain.simps[of R xs]"], ["proof (prove)\nusing this:\n  \\<forall>x y. R x y \\<longrightarrow> R' (f x) (f y)\n  chain R xs\n  chain R xs =\n  ((\\<exists>x. xs = LCons x LNil) \\<or>\n   (\\<exists>xs x. xs = LCons x xs \\<and> chain R xs \\<and> R x (lhd xs)))\n\ngoal (1 subgoal):\n 1. (\\<exists>y. xs = LCons y LNil) \\<or>\n    (\\<exists>ys x. xs = LCons x ys \\<and> chain R ys \\<and> R x (lhd ys))", "by auto"], ["proof (state)\nthis:\n  (\\<exists>y. xs = LCons y LNil) \\<or>\n  (\\<exists>ys x. xs = LCons x ys \\<and> chain R ys \\<and> R x (lhd ys))\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>x y. R x y \\<longrightarrow> R' (f x) (f y);\n        chain R xs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x. lmap f xs = LCons x LNil) \\<or>\n                         (\\<exists>xsa x.\n                             lmap f xs = LCons x xsa \\<and>\n                             ((\\<exists>xs.\n                                  xsa = lmap f xs \\<and>\n                                  (\\<forall>x y.\nR x y \\<longrightarrow> R' (f x) (f y)) \\<and>\n                                  chain R xs) \\<or>\n                              chain R' xsa) \\<and>\n                             R' x (lhd xsa))", "then"], ["proof (chain)\npicking this:\n  (\\<exists>y. xs = LCons y LNil) \\<or>\n  (\\<exists>ys x. xs = LCons x ys \\<and> chain R ys \\<and> R x (lhd ys))", "show ?case"], ["proof (prove)\nusing this:\n  (\\<exists>y. xs = LCons y LNil) \\<or>\n  (\\<exists>ys x. xs = LCons x ys \\<and> chain R ys \\<and> R x (lhd ys))\n\ngoal (1 subgoal):\n 1. (\\<exists>x. lmap f xs = LCons x LNil) \\<or>\n    (\\<exists>xs x.\n        lmap f xs = LCons x xs \\<and>\n        ((\\<exists>xsa.\n             xs = lmap f xsa \\<and>\n             (\\<forall>x y. R x y \\<longrightarrow> R' (f x) (f y)) \\<and>\n             chain R xsa) \\<or>\n         chain R' xs) \\<and>\n        R' x (lhd xs))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>y. xs = LCons y LNil \\<Longrightarrow>\n    (\\<exists>x. lmap f xs = LCons x LNil) \\<or>\n    (\\<exists>xs x.\n        lmap f xs = LCons x xs \\<and>\n        ((\\<exists>xsa.\n             xs = lmap f xsa \\<and>\n             (\\<forall>x y. R x y \\<longrightarrow> R' (f x) (f y)) \\<and>\n             chain R xsa) \\<or>\n         chain R' xs) \\<and>\n        R' x (lhd xs))\n 2. \\<exists>ys x.\n       xs = LCons x ys \\<and>\n       chain R ys \\<and> R x (lhd ys) \\<Longrightarrow>\n    (\\<exists>x. lmap f xs = LCons x LNil) \\<or>\n    (\\<exists>xs x.\n        lmap f xs = LCons x xs \\<and>\n        ((\\<exists>xsa.\n             xs = lmap f xsa \\<and>\n             (\\<forall>x y. R x y \\<longrightarrow> R' (f x) (f y)) \\<and>\n             chain R xsa) \\<or>\n         chain R' xs) \\<and>\n        R' x (lhd xs))", "assume \"\\<exists>ys x. xs = LCons x ys \\<and> chain R ys \\<and> R x (lhd ys)\""], ["proof (state)\nthis:\n  \\<exists>ys x. xs = LCons x ys \\<and> chain R ys \\<and> R x (lhd ys)\n\ngoal (2 subgoals):\n 1. \\<exists>y. xs = LCons y LNil \\<Longrightarrow>\n    (\\<exists>x. lmap f xs = LCons x LNil) \\<or>\n    (\\<exists>xs x.\n        lmap f xs = LCons x xs \\<and>\n        ((\\<exists>xsa.\n             xs = lmap f xsa \\<and>\n             (\\<forall>x y. R x y \\<longrightarrow> R' (f x) (f y)) \\<and>\n             chain R xsa) \\<or>\n         chain R' xs) \\<and>\n        R' x (lhd xs))\n 2. \\<exists>ys x.\n       xs = LCons x ys \\<and>\n       chain R ys \\<and> R x (lhd ys) \\<Longrightarrow>\n    (\\<exists>x. lmap f xs = LCons x LNil) \\<or>\n    (\\<exists>xs x.\n        lmap f xs = LCons x xs \\<and>\n        ((\\<exists>xsa.\n             xs = lmap f xsa \\<and>\n             (\\<forall>x y. R x y \\<longrightarrow> R' (f x) (f y)) \\<and>\n             chain R xsa) \\<or>\n         chain R' xs) \\<and>\n        R' x (lhd xs))", "then"], ["proof (chain)\npicking this:\n  \\<exists>ys x. xs = LCons x ys \\<and> chain R ys \\<and> R x (lhd ys)", "have \"\\<exists>ys x. lmap f xs = LCons x ys \\<and>\n      (\\<exists>xs. ys = lmap f xs \\<and> (\\<forall>x y. R x y \\<longrightarrow> R' (f x) (f y)) \\<and> chain R xs) \\<and> R' x (lhd ys)\""], ["proof (prove)\nusing this:\n  \\<exists>ys x. xs = LCons x ys \\<and> chain R ys \\<and> R x (lhd ys)\n\ngoal (1 subgoal):\n 1. \\<exists>ys x.\n       lmap f xs = LCons x ys \\<and>\n       (\\<exists>xs.\n           ys = lmap f xs \\<and>\n           (\\<forall>x y. R x y \\<longrightarrow> R' (f x) (f y)) \\<and>\n           chain R xs) \\<and>\n       R' x (lhd ys)", "using chain"], ["proof (prove)\nusing this:\n  \\<exists>ys x. xs = LCons x ys \\<and> chain R ys \\<and> R x (lhd ys)\n  \\<forall>x y. R x y \\<longrightarrow> R' (f x) (f y)\n  chain R xs\n\ngoal (1 subgoal):\n 1. \\<exists>ys x.\n       lmap f xs = LCons x ys \\<and>\n       (\\<exists>xs.\n           ys = lmap f xs \\<and>\n           (\\<forall>x y. R x y \\<longrightarrow> R' (f x) (f y)) \\<and>\n           chain R xs) \\<and>\n       R' x (lhd ys)", "by (metis (no_types) lhd_LCons llist.distinct(1) llist.exhaust_sel llist.map_sel(1)\n          lmap_eq_LNil chain_not_lnull ltl_lmap ltl_simps(2))"], ["proof (state)\nthis:\n  \\<exists>ys x.\n     lmap f xs = LCons x ys \\<and>\n     (\\<exists>xs.\n         ys = lmap f xs \\<and>\n         (\\<forall>x y. R x y \\<longrightarrow> R' (f x) (f y)) \\<and>\n         chain R xs) \\<and>\n     R' x (lhd ys)\n\ngoal (2 subgoals):\n 1. \\<exists>y. xs = LCons y LNil \\<Longrightarrow>\n    (\\<exists>x. lmap f xs = LCons x LNil) \\<or>\n    (\\<exists>xs x.\n        lmap f xs = LCons x xs \\<and>\n        ((\\<exists>xsa.\n             xs = lmap f xsa \\<and>\n             (\\<forall>x y. R x y \\<longrightarrow> R' (f x) (f y)) \\<and>\n             chain R xsa) \\<or>\n         chain R' xs) \\<and>\n        R' x (lhd xs))\n 2. \\<exists>ys x.\n       xs = LCons x ys \\<and>\n       chain R ys \\<and> R x (lhd ys) \\<Longrightarrow>\n    (\\<exists>x. lmap f xs = LCons x LNil) \\<or>\n    (\\<exists>xs x.\n        lmap f xs = LCons x xs \\<and>\n        ((\\<exists>xsa.\n             xs = lmap f xsa \\<and>\n             (\\<forall>x y. R x y \\<longrightarrow> R' (f x) (f y)) \\<and>\n             chain R xsa) \\<or>\n         chain R' xs) \\<and>\n        R' x (lhd xs))", "then"], ["proof (chain)\npicking this:\n  \\<exists>ys x.\n     lmap f xs = LCons x ys \\<and>\n     (\\<exists>xs.\n         ys = lmap f xs \\<and>\n         (\\<forall>x y. R x y \\<longrightarrow> R' (f x) (f y)) \\<and>\n         chain R xs) \\<and>\n     R' x (lhd ys)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>ys x.\n     lmap f xs = LCons x ys \\<and>\n     (\\<exists>xs.\n         ys = lmap f xs \\<and>\n         (\\<forall>x y. R x y \\<longrightarrow> R' (f x) (f y)) \\<and>\n         chain R xs) \\<and>\n     R' x (lhd ys)\n\ngoal (1 subgoal):\n 1. (\\<exists>x. lmap f xs = LCons x LNil) \\<or>\n    (\\<exists>xs x.\n        lmap f xs = LCons x xs \\<and>\n        ((\\<exists>xsa.\n             xs = lmap f xsa \\<and>\n             (\\<forall>x y. R x y \\<longrightarrow> R' (f x) (f y)) \\<and>\n             chain R xsa) \\<or>\n         chain R' xs) \\<and>\n        R' x (lhd xs))", "by auto"], ["proof (state)\nthis:\n  (\\<exists>x. lmap f xs = LCons x LNil) \\<or>\n  (\\<exists>xs x.\n      lmap f xs = LCons x xs \\<and>\n      ((\\<exists>xsa.\n           xs = lmap f xsa \\<and>\n           (\\<forall>x y. R x y \\<longrightarrow> R' (f x) (f y)) \\<and>\n           chain R xsa) \\<or>\n       chain R' xs) \\<and>\n      R' x (lhd xs))\n\ngoal (1 subgoal):\n 1. \\<exists>y. xs = LCons y LNil \\<Longrightarrow>\n    (\\<exists>x. lmap f xs = LCons x LNil) \\<or>\n    (\\<exists>xs x.\n        lmap f xs = LCons x xs \\<and>\n        ((\\<exists>xsa.\n             xs = lmap f xsa \\<and>\n             (\\<forall>x y. R x y \\<longrightarrow> R' (f x) (f y)) \\<and>\n             chain R xsa) \\<or>\n         chain R' xs) \\<and>\n        R' x (lhd xs))", "qed auto"], ["proof (state)\nthis:\n  (\\<exists>x. lmap f xs = LCons x LNil) \\<or>\n  (\\<exists>xs x.\n      lmap f xs = LCons x xs \\<and>\n      ((\\<exists>xsa.\n           xs = lmap f xsa \\<and>\n           (\\<forall>x y. R x y \\<longrightarrow> R' (f x) (f y)) \\<and>\n           chain R xsa) \\<or>\n       chain R' xs) \\<and>\n      R' x (lhd xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma chain_mono:\n  assumes \"\\<forall>x y. R x y \\<longrightarrow> R' x y\" and \"chain R xs\"\n  shows \"chain R' xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain R' xs", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>x y. R x y \\<longrightarrow> R' x y\n  chain R xs\n\ngoal (1 subgoal):\n 1. chain R' xs", "by (rule chain_lmap[of _ _ \"\\<lambda>x. x\", unfolded llist.map_ident])"], ["", "lemma lfinite_chain_imp_rtranclp_lhd_llast: \"lfinite xs \\<Longrightarrow> chain R xs \\<Longrightarrow> R\\<^sup>*\\<^sup>* (lhd xs) (llast xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lfinite xs; chain R xs\\<rbrakk>\n    \\<Longrightarrow> R\\<^sup>*\\<^sup>* (lhd xs) (llast xs)", "proof (induct rule: lfinite.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. chain R LNil \\<Longrightarrow> R\\<^sup>*\\<^sup>* (lhd LNil) (llast LNil)\n 2. \\<And>xs x.\n       \\<lbrakk>lfinite xs;\n        chain R xs \\<Longrightarrow> R\\<^sup>*\\<^sup>* (lhd xs) (llast xs);\n        chain R (LCons x xs)\\<rbrakk>\n       \\<Longrightarrow> R\\<^sup>*\\<^sup>* (lhd (LCons x xs))\n                          (llast (LCons x xs))", "case (lfinite_LConsI xs x)"], ["proof (state)\nthis:\n  lfinite xs\n  chain R xs \\<Longrightarrow> R\\<^sup>*\\<^sup>* (lhd xs) (llast xs)\n  chain R (LCons x xs)\n\ngoal (2 subgoals):\n 1. chain R LNil \\<Longrightarrow> R\\<^sup>*\\<^sup>* (lhd LNil) (llast LNil)\n 2. \\<And>xs x.\n       \\<lbrakk>lfinite xs;\n        chain R xs \\<Longrightarrow> R\\<^sup>*\\<^sup>* (lhd xs) (llast xs);\n        chain R (LCons x xs)\\<rbrakk>\n       \\<Longrightarrow> R\\<^sup>*\\<^sup>* (lhd (LCons x xs))\n                          (llast (LCons x xs))", "note fin_xs = this(1) and ih = this(2) and r_x_xs = this(3)"], ["proof (state)\nthis:\n  lfinite xs\n  chain R xs \\<Longrightarrow> R\\<^sup>*\\<^sup>* (lhd xs) (llast xs)\n  chain R (LCons x xs)\n\ngoal (2 subgoals):\n 1. chain R LNil \\<Longrightarrow> R\\<^sup>*\\<^sup>* (lhd LNil) (llast LNil)\n 2. \\<And>xs x.\n       \\<lbrakk>lfinite xs;\n        chain R xs \\<Longrightarrow> R\\<^sup>*\\<^sup>* (lhd xs) (llast xs);\n        chain R (LCons x xs)\\<rbrakk>\n       \\<Longrightarrow> R\\<^sup>*\\<^sup>* (lhd (LCons x xs))\n                          (llast (LCons x xs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. R\\<^sup>*\\<^sup>* (lhd (LCons x xs)) (llast (LCons x xs))", "proof (cases \"xs = LNil\")"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = LNil \\<Longrightarrow>\n    R\\<^sup>*\\<^sup>* (lhd (LCons x xs)) (llast (LCons x xs))\n 2. xs \\<noteq> LNil \\<Longrightarrow>\n    R\\<^sup>*\\<^sup>* (lhd (LCons x xs)) (llast (LCons x xs))", "case xs_nnil: False"], ["proof (state)\nthis:\n  xs \\<noteq> LNil\n\ngoal (2 subgoals):\n 1. xs = LNil \\<Longrightarrow>\n    R\\<^sup>*\\<^sup>* (lhd (LCons x xs)) (llast (LCons x xs))\n 2. xs \\<noteq> LNil \\<Longrightarrow>\n    R\\<^sup>*\\<^sup>* (lhd (LCons x xs)) (llast (LCons x xs))", "then"], ["proof (chain)\npicking this:\n  xs \\<noteq> LNil", "have r_xs: \"chain R xs\""], ["proof (prove)\nusing this:\n  xs \\<noteq> LNil\n\ngoal (1 subgoal):\n 1. chain R xs", "using r_x_xs"], ["proof (prove)\nusing this:\n  xs \\<noteq> LNil\n  chain R (LCons x xs)\n\ngoal (1 subgoal):\n 1. chain R xs", "by (blast elim: chain.cases)"], ["proof (state)\nthis:\n  chain R xs\n\ngoal (2 subgoals):\n 1. xs = LNil \\<Longrightarrow>\n    R\\<^sup>*\\<^sup>* (lhd (LCons x xs)) (llast (LCons x xs))\n 2. xs \\<noteq> LNil \\<Longrightarrow>\n    R\\<^sup>*\\<^sup>* (lhd (LCons x xs)) (llast (LCons x xs))", "then"], ["proof (chain)\npicking this:\n  chain R xs", "show ?thesis"], ["proof (prove)\nusing this:\n  chain R xs\n\ngoal (1 subgoal):\n 1. R\\<^sup>*\\<^sup>* (lhd (LCons x xs)) (llast (LCons x xs))", "using ih[OF r_xs] xs_nnil r_x_xs"], ["proof (prove)\nusing this:\n  chain R xs\n  R\\<^sup>*\\<^sup>* (lhd xs) (llast xs)\n  xs \\<noteq> LNil\n  chain R (LCons x xs)\n\ngoal (1 subgoal):\n 1. R\\<^sup>*\\<^sup>* (lhd (LCons x xs)) (llast (LCons x xs))", "by (metis chain.cases converse_rtranclp_into_rtranclp lhd_LCons llast_LCons chain_not_lnull\n          ltl_simps(2))"], ["proof (state)\nthis:\n  R\\<^sup>*\\<^sup>* (lhd (LCons x xs)) (llast (LCons x xs))\n\ngoal (1 subgoal):\n 1. xs = LNil \\<Longrightarrow>\n    R\\<^sup>*\\<^sup>* (lhd (LCons x xs)) (llast (LCons x xs))", "qed simp"], ["proof (state)\nthis:\n  R\\<^sup>*\\<^sup>* (lhd (LCons x xs)) (llast (LCons x xs))\n\ngoal (1 subgoal):\n 1. chain R LNil \\<Longrightarrow> R\\<^sup>*\\<^sup>* (lhd LNil) (llast LNil)", "qed simp"], ["", "lemma tranclp_imp_exists_finite_chain_list:\n  \"R\\<^sup>+\\<^sup>+ x y \\<Longrightarrow> \\<exists>xs. chain R (llist_of (x # xs @ [y]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R\\<^sup>+\\<^sup>+ x y \\<Longrightarrow>\n    \\<exists>xs. chain R (llist_of (x # xs @ [y]))", "proof (induct rule: tranclp.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       R a b \\<Longrightarrow>\n       \\<exists>xs. chain R (llist_of (a # xs @ [b]))\n 2. \\<And>a b c.\n       \\<lbrakk>R\\<^sup>+\\<^sup>+ a b;\n        \\<exists>xs. chain R (llist_of (a # xs @ [b])); R b c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs. chain R (llist_of (a # xs @ [c]))", "case (r_into_trancl x y)"], ["proof (state)\nthis:\n  R x y\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       R a b \\<Longrightarrow>\n       \\<exists>xs. chain R (llist_of (a # xs @ [b]))\n 2. \\<And>a b c.\n       \\<lbrakk>R\\<^sup>+\\<^sup>+ a b;\n        \\<exists>xs. chain R (llist_of (a # xs @ [b])); R b c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs. chain R (llist_of (a # xs @ [c]))", "then"], ["proof (chain)\npicking this:\n  R x y", "have \"chain R (llist_of (x # [] @ [y]))\""], ["proof (prove)\nusing this:\n  R x y\n\ngoal (1 subgoal):\n 1. chain R (llist_of (x # [] @ [y]))", "by (auto intro: chain.intros)"], ["proof (state)\nthis:\n  chain R (llist_of (x # [] @ [y]))\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       R a b \\<Longrightarrow>\n       \\<exists>xs. chain R (llist_of (a # xs @ [b]))\n 2. \\<And>a b c.\n       \\<lbrakk>R\\<^sup>+\\<^sup>+ a b;\n        \\<exists>xs. chain R (llist_of (a # xs @ [b])); R b c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs. chain R (llist_of (a # xs @ [c]))", "then"], ["proof (chain)\npicking this:\n  chain R (llist_of (x # [] @ [y]))", "show ?case"], ["proof (prove)\nusing this:\n  chain R (llist_of (x # [] @ [y]))\n\ngoal (1 subgoal):\n 1. \\<exists>xs. chain R (llist_of (x # xs @ [y]))", "by blast"], ["proof (state)\nthis:\n  \\<exists>xs. chain R (llist_of (x # xs @ [y]))\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>R\\<^sup>+\\<^sup>+ a b;\n        \\<exists>xs. chain R (llist_of (a # xs @ [b])); R b c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs. chain R (llist_of (a # xs @ [c]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>R\\<^sup>+\\<^sup>+ a b;\n        \\<exists>xs. chain R (llist_of (a # xs @ [b])); R b c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs. chain R (llist_of (a # xs @ [c]))", "case (trancl_into_trancl x y z)"], ["proof (state)\nthis:\n  R\\<^sup>+\\<^sup>+ x y\n  \\<exists>xs. chain R (llist_of (x # xs @ [y]))\n  R y z\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>R\\<^sup>+\\<^sup>+ a b;\n        \\<exists>xs. chain R (llist_of (a # xs @ [b])); R b c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs. chain R (llist_of (a # xs @ [c]))", "note rstar_xy = this(1) and ih = this(2) and r_yz = this(3)"], ["proof (state)\nthis:\n  R\\<^sup>+\\<^sup>+ x y\n  \\<exists>xs. chain R (llist_of (x # xs @ [y]))\n  R y z\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>R\\<^sup>+\\<^sup>+ a b;\n        \\<exists>xs. chain R (llist_of (a # xs @ [b])); R b c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs. chain R (llist_of (a # xs @ [c]))", "obtain xs where\n    xs: \"chain R (llist_of (x # xs @ [y]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        chain R (llist_of (x # xs @ [y])) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ih"], ["proof (prove)\nusing this:\n  \\<exists>xs. chain R (llist_of (x # xs @ [y]))\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        chain R (llist_of (x # xs @ [y])) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  chain R (llist_of (x # xs @ [y]))\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>R\\<^sup>+\\<^sup>+ a b;\n        \\<exists>xs. chain R (llist_of (a # xs @ [b])); R b c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs. chain R (llist_of (a # xs @ [c]))", "define ys where\n    \"ys = xs @ [y]\""], ["proof (state)\nthis:\n  ys = xs @ [y]\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>R\\<^sup>+\\<^sup>+ a b;\n        \\<exists>xs. chain R (llist_of (a # xs @ [b])); R b c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs. chain R (llist_of (a # xs @ [c]))", "have \"chain R (llist_of (x # ys @ [z]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain R (llist_of (x # ys @ [z]))", "unfolding ys_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. chain R (llist_of (x # (xs @ [y]) @ [z]))", "using r_yz chain_lappend[OF xs chain_singleton, of z]"], ["proof (prove)\nusing this:\n  R y z\n  R (llast (llist_of (x # xs @ [y]))) (lhd (LCons z LNil)) \\<Longrightarrow>\n  chain R (lappend (llist_of (x # xs @ [y])) (LCons z LNil))\n\ngoal (1 subgoal):\n 1. chain R (llist_of (x # (xs @ [y]) @ [z]))", "by (auto simp: lappend_llist_of_LCons llast_LCons)"], ["proof (state)\nthis:\n  chain R (llist_of (x # ys @ [z]))\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>R\\<^sup>+\\<^sup>+ a b;\n        \\<exists>xs. chain R (llist_of (a # xs @ [b])); R b c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs. chain R (llist_of (a # xs @ [c]))", "then"], ["proof (chain)\npicking this:\n  chain R (llist_of (x # ys @ [z]))", "show ?case"], ["proof (prove)\nusing this:\n  chain R (llist_of (x # ys @ [z]))\n\ngoal (1 subgoal):\n 1. \\<exists>xs. chain R (llist_of (x # xs @ [z]))", "by blast"], ["proof (state)\nthis:\n  \\<exists>xs. chain R (llist_of (x # xs @ [z]))\n\ngoal:\nNo subgoals!", "qed"], ["", "inductive_cases chain_consE: \"chain R (LCons x xs)\""], ["", "inductive_cases chain_nontrivE: \"chain R (LCons x (LCons y xs))\""], ["", "subsection \\<open>A Coinductive Puzzle\\<close>"], ["", "primrec prepend where\n  \"prepend [] ys = ys\"\n| \"prepend (x # xs) ys = LCons x (prepend xs ys)\""], ["", "lemma lnull_prepend[simp]: \"lnull (prepend xs ys) = (xs = [] \\<and> lnull ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull (prepend xs ys) = (xs = [] \\<and> lnull ys)", "by (induct xs) auto"], ["", "lemma lhd_prepend[simp]: \"lhd (prepend xs ys) = (if xs \\<noteq> [] then hd xs else lhd ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lhd (prepend xs ys) = (if xs \\<noteq> [] then hd xs else lhd ys)", "by (induct xs) auto"], ["", "lemma prepend_LNil[simp]: \"prepend xs LNil = llist_of xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prepend xs LNil = llist_of xs", "by (induct xs) auto"], ["", "lemma lfinite_prepend[simp]: \"lfinite (prepend xs ys) \\<longleftrightarrow> lfinite ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite (prepend xs ys) = lfinite ys", "by (induct xs) auto"], ["", "lemma llength_prepend[simp]: \"llength (prepend xs ys) = length xs + llength ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (prepend xs ys) = enat (length xs) + llength ys", "by (induct xs) (auto simp: enat_0 iadd_Suc eSuc_enat[symmetric])"], ["", "lemma llast_prepend[simp]: \"\\<not> lnull ys \\<Longrightarrow> llast (prepend xs ys) = llast ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lnull ys \\<Longrightarrow> llast (prepend xs ys) = llast ys", "by (induct xs) (auto simp: llast_LCons)"], ["", "lemma prepend_prepend: \"prepend xs (prepend ys zs) = prepend (xs @ ys) zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prepend xs (prepend ys zs) = prepend (xs @ ys) zs", "by (induct xs) auto"], ["", "lemma chain_prepend:\n  \"chain R (llist_of zs) \\<Longrightarrow> last zs = lhd xs \\<Longrightarrow> chain R xs \\<Longrightarrow> chain R (prepend zs (ltl xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>chain R (llist_of zs); last zs = lhd xs; chain R xs\\<rbrakk>\n    \\<Longrightarrow> chain R (prepend zs (ltl xs))", "by (induct zs; cases xs)\n    (auto split: if_splits simp: lnull_def[symmetric] intro!: chain_cons elim!: chain_consE)"], ["", "lemma lmap_prepend[simp]: \"lmap f (prepend xs ys) = prepend (map f xs) (lmap f ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lmap f (prepend xs ys) = prepend (map f xs) (lmap f ys)", "by (induct xs) auto"], ["", "lemma lset_prepend[simp]: \"lset (prepend xs ys) = set xs \\<union> lset ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset (prepend xs ys) = set xs \\<union> lset ys", "by (induct xs) auto"], ["", "lemma prepend_LCons: \"prepend xs (LCons y ys) = prepend (xs @ [y]) ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prepend xs (LCons y ys) = prepend (xs @ [y]) ys", "by (induct xs) auto"], ["", "lemma lnth_prepend:\n  \"lnth (prepend xs ys) i = (if i < length xs then nth xs i else lnth ys (i - length xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnth (prepend xs ys) i =\n    (if i < length xs then xs ! i else lnth ys (i - length xs))", "by (induct xs arbitrary: i) (auto simp: lnth_LCons' nth_Cons')"], ["", "theorem lfinite_less_induct[consumes 1, case_names less]:\n  assumes fin: \"lfinite xs\"\n    and step: \"\\<And>xs. lfinite xs \\<Longrightarrow> (\\<And>zs. llength zs < llength xs \\<Longrightarrow> P zs) \\<Longrightarrow> P xs\"\n  shows \"P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs", "using fin"], ["proof (prove)\nusing this:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. P xs", "proof (induct \"the_enat (llength xs)\" arbitrary: xs rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<And>xsa.\n                   \\<lbrakk>the_enat (llength xsa) < the_enat (llength xs);\n                    lfinite xsa\\<rbrakk>\n                   \\<Longrightarrow> P xsa;\n        lfinite xs\\<rbrakk>\n       \\<Longrightarrow> P xs", "case (less xs)"], ["proof (state)\nthis:\n  \\<lbrakk>the_enat (llength ?xs) < the_enat (llength xs);\n   lfinite ?xs\\<rbrakk>\n  \\<Longrightarrow> P ?xs\n  lfinite xs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<And>xsa.\n                   \\<lbrakk>the_enat (llength xsa) < the_enat (llength xs);\n                    lfinite xsa\\<rbrakk>\n                   \\<Longrightarrow> P xsa;\n        lfinite xs\\<rbrakk>\n       \\<Longrightarrow> P xs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs", "using less(2)"], ["proof (prove)\nusing this:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. P xs", "by (intro step[OF less(2)] less(1))\n      (auto dest!: lfinite_llength_enat simp: eSuc_enat elim!: less_enatE llength_eq_enat_lfiniteD)"], ["proof (state)\nthis:\n  P xs\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem lfinite_prepend_induct[consumes 1, case_names LNil prepend]:\n  assumes \"lfinite xs\"\n    and LNil: \"P LNil\"\n    and prepend: \"\\<And>xs. lfinite xs \\<Longrightarrow> (\\<And>zs. (\\<exists>ys. xs = prepend ys zs \\<and> ys \\<noteq> []) \\<Longrightarrow> P zs) \\<Longrightarrow> P xs\"\n  shows \"P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs", "using assms(1)"], ["proof (prove)\nusing this:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. P xs", "proof (induct xs rule: lfinite_less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>lfinite xs;\n        \\<And>zs. llength zs < llength xs \\<Longrightarrow> P zs\\<rbrakk>\n       \\<Longrightarrow> P xs", "case (less xs)"], ["proof (state)\nthis:\n  lfinite xs\n  llength ?zs < llength xs \\<Longrightarrow> P ?zs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>lfinite xs;\n        \\<And>zs. llength zs < llength xs \\<Longrightarrow> P zs\\<rbrakk>\n       \\<Longrightarrow> P xs", "from less(1)"], ["proof (chain)\npicking this:\n  lfinite xs", "show ?case"], ["proof (prove)\nusing this:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. P xs", "by (cases xs)\n      (force simp: LNil neq_Nil_conv dest: lfinite_llength_enat intro!: prepend[of \"LCons _ _\"] intro: less)+"], ["proof (state)\nthis:\n  P xs\n\ngoal:\nNo subgoals!", "qed"], ["", "coinductive emb :: \"'a llist \\<Rightarrow> 'a llist \\<Rightarrow> bool\" where\n  \"lfinite xs \\<Longrightarrow> emb LNil xs\"\n| \"emb xs ys \\<Longrightarrow> emb (LCons x xs) (prepend zs (LCons x ys))\""], ["", "inductive_cases emb_LConsE: \"emb (LCons z zs) ys\""], ["", "inductive_cases emb_LNil1E: \"emb LNil ys\""], ["", "inductive_cases emb_LNil2E: \"emb xs LNil\""], ["", "lemma emb_lfinite:\n  assumes \"emb xs ys\"\n  shows \"lfinite ys \\<longleftrightarrow> lfinite xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite ys = lfinite xs", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. lfinite ys \\<Longrightarrow> lfinite xs\n 2. lfinite xs \\<Longrightarrow> lfinite ys", "assume \"lfinite xs\""], ["proof (state)\nthis:\n  lfinite xs\n\ngoal (2 subgoals):\n 1. lfinite ys \\<Longrightarrow> lfinite xs\n 2. lfinite xs \\<Longrightarrow> lfinite ys", "then"], ["proof (chain)\npicking this:\n  lfinite xs", "show \"lfinite ys\""], ["proof (prove)\nusing this:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. lfinite ys", "using assms"], ["proof (prove)\nusing this:\n  lfinite xs\n  emb xs ys\n\ngoal (1 subgoal):\n 1. lfinite ys", "by (induct xs arbitrary: ys rule: lfinite_induct)\n      (auto simp: lnull_def neq_LNil_conv elim!: emb_LNil1E emb_LConsE)"], ["proof (state)\nthis:\n  lfinite ys\n\ngoal (1 subgoal):\n 1. lfinite ys \\<Longrightarrow> lfinite xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. lfinite ys \\<Longrightarrow> lfinite xs", "assume \"lfinite ys\""], ["proof (state)\nthis:\n  lfinite ys\n\ngoal (1 subgoal):\n 1. lfinite ys \\<Longrightarrow> lfinite xs", "then"], ["proof (chain)\npicking this:\n  lfinite ys", "show \"lfinite xs\""], ["proof (prove)\nusing this:\n  lfinite ys\n\ngoal (1 subgoal):\n 1. lfinite xs", "using assms"], ["proof (prove)\nusing this:\n  lfinite ys\n  emb xs ys\n\ngoal (1 subgoal):\n 1. lfinite xs", "proof (induction ys arbitrary: xs rule: lfinite_less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs xsa.\n       \\<lbrakk>lfinite xs;\n        \\<And>zs xsa.\n           \\<lbrakk>llength zs < llength xs; emb xsa zs\\<rbrakk>\n           \\<Longrightarrow> lfinite xsa;\n        emb xsa xs\\<rbrakk>\n       \\<Longrightarrow> lfinite xsa", "case (less ys)"], ["proof (state)\nthis:\n  lfinite ys\n  \\<lbrakk>llength ?zs < llength ys; emb ?xs ?zs\\<rbrakk>\n  \\<Longrightarrow> lfinite ?xs\n  emb xs ys\n\ngoal (1 subgoal):\n 1. \\<And>xs xsa.\n       \\<lbrakk>lfinite xs;\n        \\<And>zs xsa.\n           \\<lbrakk>llength zs < llength xs; emb xsa zs\\<rbrakk>\n           \\<Longrightarrow> lfinite xsa;\n        emb xsa xs\\<rbrakk>\n       \\<Longrightarrow> lfinite xsa", "from less.prems \\<open>lfinite ys\\<close>"], ["proof (chain)\npicking this:\n  emb xs ys\n  lfinite ys", "show ?case"], ["proof (prove)\nusing this:\n  emb xs ys\n  lfinite ys\n\ngoal (1 subgoal):\n 1. lfinite xs", "by (cases xs)\n        (auto simp: eSuc_enat elim!: emb_LNil1E emb_LConsE less.IH[rotated]\n          dest!: lfinite_llength_enat)"], ["proof (state)\nthis:\n  lfinite xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lfinite xs\n\ngoal:\nNo subgoals!", "qed"], ["", "inductive prepend_cong1 for X where\n  prepend_cong1_base: \"X xs \\<Longrightarrow> prepend_cong1 X xs\"\n| prepend_cong1_prepend: \"prepend_cong1 X ys \\<Longrightarrow> prepend_cong1 X (prepend xs ys)\""], ["", "lemma emb_prepend_coinduct[rotated, case_names emb]:\n  assumes \"(\\<And>x1 x2. X x1 x2 \\<Longrightarrow>\n    (\\<exists>xs. x1 = LNil \\<and> x2 = xs \\<and> lfinite xs)\n     \\<or> (\\<exists>xs ys x zs. x1 = LCons x xs \\<and> x2 = prepend zs (LCons x ys)\n       \\<and> (prepend_cong1 (X xs) ys \\<or> emb xs ys)))\" (is \"\\<And>x1 x2. X x1 x2 \\<Longrightarrow> ?bisim x1 x2\")\n  shows \"X x1 x2 \\<Longrightarrow> emb x1 x2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X x1 x2 \\<Longrightarrow> emb x1 x2", "proof (erule emb.coinduct[OF prepend_cong1_base])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       prepend_cong1 (X x1) x2 \\<Longrightarrow>\n       (\\<exists>xs. x1 = LNil \\<and> x2 = xs \\<and> lfinite xs) \\<or>\n       (\\<exists>xs ys x zs.\n           x1 = LCons x xs \\<and>\n           x2 = prepend zs (LCons x ys) \\<and>\n           (prepend_cong1 (X xs) ys \\<or> emb xs ys))", "fix xs zs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       prepend_cong1 (X x1) x2 \\<Longrightarrow>\n       (\\<exists>xs. x1 = LNil \\<and> x2 = xs \\<and> lfinite xs) \\<or>\n       (\\<exists>xs ys x zs.\n           x1 = LCons x xs \\<and>\n           x2 = prepend zs (LCons x ys) \\<and>\n           (prepend_cong1 (X xs) ys \\<or> emb xs ys))", "assume \"prepend_cong1 (X xs) zs\""], ["proof (state)\nthis:\n  prepend_cong1 (X xs) zs\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       prepend_cong1 (X x1) x2 \\<Longrightarrow>\n       (\\<exists>xs. x1 = LNil \\<and> x2 = xs \\<and> lfinite xs) \\<or>\n       (\\<exists>xs ys x zs.\n           x1 = LCons x xs \\<and>\n           x2 = prepend zs (LCons x ys) \\<and>\n           (prepend_cong1 (X xs) ys \\<or> emb xs ys))", "then"], ["proof (chain)\npicking this:\n  prepend_cong1 (X xs) zs", "show \"?bisim xs zs\""], ["proof (prove)\nusing this:\n  prepend_cong1 (X xs) zs\n\ngoal (1 subgoal):\n 1. (\\<exists>xsa. xs = LNil \\<and> zs = xsa \\<and> lfinite xsa) \\<or>\n    (\\<exists>xsa ys x zsa.\n        xs = LCons x xsa \\<and>\n        zs = prepend zsa (LCons x ys) \\<and>\n        (prepend_cong1 (X xsa) ys \\<or> emb xsa ys))", "by (induct zs rule: prepend_cong1.induct) (erule assms, force simp: prepend_prepend)"], ["proof (state)\nthis:\n  (\\<exists>xsa. xs = LNil \\<and> zs = xsa \\<and> lfinite xsa) \\<or>\n  (\\<exists>xsa ys x zsa.\n      xs = LCons x xsa \\<and>\n      zs = prepend zsa (LCons x ys) \\<and>\n      (prepend_cong1 (X xsa) ys \\<or> emb xsa ys))\n\ngoal:\nNo subgoals!", "qed"], ["", "context\nbegin"], ["", "private"], ["", "coinductive chain' for R where\n  \"chain' R (LCons x LNil)\"\n| \"chain R (llist_of (x # zs @ [lhd xs])) \\<Longrightarrow>\n   chain' R xs \\<Longrightarrow> chain' R (LCons x (prepend zs xs))\""], ["", "private"], ["", "lemma chain_imp_chain': \"chain R xs \\<Longrightarrow> chain' R xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain R xs \\<Longrightarrow> chain' R xs", "proof (coinduction arbitrary: xs rule: chain'.coinduct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       chain R xs \\<Longrightarrow>\n       (\\<exists>x. xs = LCons x LNil) \\<or>\n       (\\<exists>x zs xsa.\n           xs = LCons x (prepend zs xsa) \\<and>\n           chain R (llist_of (x # zs @ [lhd xsa])) \\<and>\n           ((\\<exists>xs. xsa = xs \\<and> chain R xs) \\<or> chain' R xsa))", "case chain'"], ["proof (state)\nthis:\n  chain R xs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       chain R xs \\<Longrightarrow>\n       (\\<exists>x. xs = LCons x LNil) \\<or>\n       (\\<exists>x zs xsa.\n           xs = LCons x (prepend zs xsa) \\<and>\n           chain R (llist_of (x # zs @ [lhd xsa])) \\<and>\n           ((\\<exists>xs. xsa = xs \\<and> chain R xs) \\<or> chain' R xsa))", "then"], ["proof (chain)\npicking this:\n  chain R xs", "show ?case"], ["proof (prove)\nusing this:\n  chain R xs\n\ngoal (1 subgoal):\n 1. (\\<exists>x. xs = LCons x LNil) \\<or>\n    (\\<exists>x zs xs.\n        xs = LCons x (prepend zs xs) \\<and>\n        chain R (llist_of (x # zs @ [lhd xs])) \\<and>\n        ((\\<exists>xsa. xs = xsa \\<and> chain R xsa) \\<or> chain' R xs))", "proof (cases rule: chain.cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       xs = LCons x LNil \\<Longrightarrow>\n       (\\<exists>x. xs = LCons x LNil) \\<or>\n       (\\<exists>x zs xs.\n           xs = LCons x (prepend zs xs) \\<and>\n           chain R (llist_of (x # zs @ [lhd xs])) \\<and>\n           ((\\<exists>xsa. xs = xsa \\<and> chain R xsa) \\<or> chain' R xs))\n 2. \\<And>xs x.\n       \\<lbrakk>xs = LCons x xs; chain R xs; R x (lhd xs)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x. xs = LCons x LNil) \\<or>\n                         (\\<exists>x zs xs.\n                             xs = LCons x (prepend zs xs) \\<and>\n                             chain R (llist_of (x # zs @ [lhd xs])) \\<and>\n                             ((\\<exists>xsa.\n                                  xs = xsa \\<and> chain R xsa) \\<or>\n                              chain' R xs))", "case (chain_cons zs z)"], ["proof (state)\nthis:\n  xs = LCons z zs\n  chain R zs\n  R z (lhd zs)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       xs = LCons x LNil \\<Longrightarrow>\n       (\\<exists>x. xs = LCons x LNil) \\<or>\n       (\\<exists>x zs xs.\n           xs = LCons x (prepend zs xs) \\<and>\n           chain R (llist_of (x # zs @ [lhd xs])) \\<and>\n           ((\\<exists>xsa. xs = xsa \\<and> chain R xsa) \\<or> chain' R xs))\n 2. \\<And>xs x.\n       \\<lbrakk>xs = LCons x xs; chain R xs; R x (lhd xs)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x. xs = LCons x LNil) \\<or>\n                         (\\<exists>x zs xs.\n                             xs = LCons x (prepend zs xs) \\<and>\n                             chain R (llist_of (x # zs @ [lhd xs])) \\<and>\n                             ((\\<exists>xsa.\n                                  xs = xsa \\<and> chain R xsa) \\<or>\n                              chain' R xs))", "then"], ["proof (chain)\npicking this:\n  xs = LCons z zs\n  chain R zs\n  R z (lhd zs)", "show ?thesis"], ["proof (prove)\nusing this:\n  xs = LCons z zs\n  chain R zs\n  R z (lhd zs)\n\ngoal (1 subgoal):\n 1. (\\<exists>x. xs = LCons x LNil) \\<or>\n    (\\<exists>x zs xs.\n        xs = LCons x (prepend zs xs) \\<and>\n        chain R (llist_of (x # zs @ [lhd xs])) \\<and>\n        ((\\<exists>xsa. xs = xsa \\<and> chain R xsa) \\<or> chain' R xs))", "by (intro disjI2 exI[of _ z] exI[of _ \"[]\"] exI[of _ \"zs\"])\n        (auto intro: chain.intros)"], ["proof (state)\nthis:\n  (\\<exists>x. xs = LCons x LNil) \\<or>\n  (\\<exists>x zs xs.\n      xs = LCons x (prepend zs xs) \\<and>\n      chain R (llist_of (x # zs @ [lhd xs])) \\<and>\n      ((\\<exists>xsa. xs = xsa \\<and> chain R xsa) \\<or> chain' R xs))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       xs = LCons x LNil \\<Longrightarrow>\n       (\\<exists>x. xs = LCons x LNil) \\<or>\n       (\\<exists>x zs xs.\n           xs = LCons x (prepend zs xs) \\<and>\n           chain R (llist_of (x # zs @ [lhd xs])) \\<and>\n           ((\\<exists>xsa. xs = xsa \\<and> chain R xsa) \\<or> chain' R xs))", "qed simp"], ["proof (state)\nthis:\n  (\\<exists>x. xs = LCons x LNil) \\<or>\n  (\\<exists>x zs xs.\n      xs = LCons x (prepend zs xs) \\<and>\n      chain R (llist_of (x # zs @ [lhd xs])) \\<and>\n      ((\\<exists>xsa. xs = xsa \\<and> chain R xsa) \\<or> chain' R xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma chain'_imp_chain: \"chain' R xs \\<Longrightarrow> chain R xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain' R xs \\<Longrightarrow> chain R xs", "proof (coinduction arbitrary: xs rule: chain.coinduct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       chain' R xs \\<Longrightarrow>\n       (\\<exists>x. xs = LCons x LNil) \\<or>\n       (\\<exists>xsa x.\n           xs = LCons x xsa \\<and>\n           ((\\<exists>xs. xsa = xs \\<and> chain' R xs) \\<or>\n            chain R xsa) \\<and>\n           R x (lhd xsa))", "case chain"], ["proof (state)\nthis:\n  chain' R xs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       chain' R xs \\<Longrightarrow>\n       (\\<exists>x. xs = LCons x LNil) \\<or>\n       (\\<exists>xsa x.\n           xs = LCons x xsa \\<and>\n           ((\\<exists>xs. xsa = xs \\<and> chain' R xs) \\<or>\n            chain R xsa) \\<and>\n           R x (lhd xsa))", "then"], ["proof (chain)\npicking this:\n  chain' R xs", "show ?case"], ["proof (prove)\nusing this:\n  chain' R xs\n\ngoal (1 subgoal):\n 1. (\\<exists>x. xs = LCons x LNil) \\<or>\n    (\\<exists>xs x.\n        xs = LCons x xs \\<and>\n        ((\\<exists>xsa. xs = xsa \\<and> chain' R xsa) \\<or>\n         chain R xs) \\<and>\n        R x (lhd xs))", "proof (cases rule: chain'.cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       xs = LCons x LNil \\<Longrightarrow>\n       (\\<exists>x. xs = LCons x LNil) \\<or>\n       (\\<exists>xs x.\n           xs = LCons x xs \\<and>\n           ((\\<exists>xsa. xs = xsa \\<and> chain' R xsa) \\<or>\n            chain R xs) \\<and>\n           R x (lhd xs))\n 2. \\<And>x zs xs.\n       \\<lbrakk>xs = LCons x (prepend zs xs);\n        chain R (llist_of (x # zs @ [lhd xs])); chain' R xs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x. xs = LCons x LNil) \\<or>\n                         (\\<exists>xs x.\n                             xs = LCons x xs \\<and>\n                             ((\\<exists>xsa.\n                                  xs = xsa \\<and> chain' R xsa) \\<or>\n                              chain R xs) \\<and>\n                             R x (lhd xs))", "case (2 y zs ys)"], ["proof (state)\nthis:\n  xs = LCons y (prepend zs ys)\n  chain R (llist_of (y # zs @ [lhd ys]))\n  chain' R ys\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       xs = LCons x LNil \\<Longrightarrow>\n       (\\<exists>x. xs = LCons x LNil) \\<or>\n       (\\<exists>xs x.\n           xs = LCons x xs \\<and>\n           ((\\<exists>xsa. xs = xsa \\<and> chain' R xsa) \\<or>\n            chain R xs) \\<and>\n           R x (lhd xs))\n 2. \\<And>x zs xs.\n       \\<lbrakk>xs = LCons x (prepend zs xs);\n        chain R (llist_of (x # zs @ [lhd xs])); chain' R xs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x. xs = LCons x LNil) \\<or>\n                         (\\<exists>xs x.\n                             xs = LCons x xs \\<and>\n                             ((\\<exists>xsa.\n                                  xs = xsa \\<and> chain' R xsa) \\<or>\n                              chain R xs) \\<and>\n                             R x (lhd xs))", "then"], ["proof (chain)\npicking this:\n  xs = LCons y (prepend zs ys)\n  chain R (llist_of (y # zs @ [lhd ys]))\n  chain' R ys", "show ?thesis"], ["proof (prove)\nusing this:\n  xs = LCons y (prepend zs ys)\n  chain R (llist_of (y # zs @ [lhd ys]))\n  chain' R ys\n\ngoal (1 subgoal):\n 1. (\\<exists>x. xs = LCons x LNil) \\<or>\n    (\\<exists>xs x.\n        xs = LCons x xs \\<and>\n        ((\\<exists>xsa. xs = xsa \\<and> chain' R xsa) \\<or>\n         chain R xs) \\<and>\n        R x (lhd xs))", "by (intro disjI2 exI[of _ \"prepend zs ys\"] exI[of _ y])\n        (force dest!: neq_Nil_conv[THEN iffD1] elim: chain.cases chain_nontrivE\n          intro: chain'.intros)"], ["proof (state)\nthis:\n  (\\<exists>x. xs = LCons x LNil) \\<or>\n  (\\<exists>xs x.\n      xs = LCons x xs \\<and>\n      ((\\<exists>xsa. xs = xsa \\<and> chain' R xsa) \\<or> chain R xs) \\<and>\n      R x (lhd xs))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       xs = LCons x LNil \\<Longrightarrow>\n       (\\<exists>x. xs = LCons x LNil) \\<or>\n       (\\<exists>xs x.\n           xs = LCons x xs \\<and>\n           ((\\<exists>xsa. xs = xsa \\<and> chain' R xsa) \\<or>\n            chain R xs) \\<and>\n           R x (lhd xs))", "qed simp"], ["proof (state)\nthis:\n  (\\<exists>x. xs = LCons x LNil) \\<or>\n  (\\<exists>xs x.\n      xs = LCons x xs \\<and>\n      ((\\<exists>xsa. xs = xsa \\<and> chain' R xsa) \\<or> chain R xs) \\<and>\n      R x (lhd xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma chain_chain': \"chain = chain'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain = chain'", "unfolding fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x xa. chain x xa = chain' x xa", "by (metis chain_imp_chain' chain'_imp_chain)"], ["", "lemma chain_prepend_coinduct[case_names chain]:\n  \"X x \\<Longrightarrow> (\\<And>x. X x \\<Longrightarrow>\n    (\\<exists>z. x = LCons z LNil) \\<or>\n    (\\<exists>y xs zs. x = LCons y (prepend zs xs) \\<and>\n      (X xs \\<or> chain R xs) \\<and> chain R (llist_of (y # zs @ [lhd xs])))) \\<Longrightarrow> chain R x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X x;\n     \\<And>x.\n        X x \\<Longrightarrow>\n        (\\<exists>z. x = LCons z LNil) \\<or>\n        (\\<exists>y xs zs.\n            x = LCons y (prepend zs xs) \\<and>\n            (X xs \\<or> chain R xs) \\<and>\n            chain R (llist_of (y # zs @ [lhd xs])))\\<rbrakk>\n    \\<Longrightarrow> chain R x", "by (subst chain_chain', erule chain'.coinduct) (force simp: chain_chain')"], ["", "end"], ["", "context\n  fixes R :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\"\nbegin"], ["", "private"], ["", "definition pick where\n  \"pick x y = (SOME xs. chain R (llist_of (x # xs @ [y])))\""], ["", "private"], ["", "lemma pick[simp]:\n  assumes \"R\\<^sup>+\\<^sup>+ x y\"\n  shows \"chain R (llist_of (x # pick x y @ [y]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain R (llist_of (x # pick x y @ [y]))", "unfolding pick_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. chain R\n     (llist_of (x # (SOME xs. chain R (llist_of (x # xs @ [y]))) @ [y]))", "using tranclp_imp_exists_finite_chain_list[THEN someI_ex, OF assms]"], ["proof (prove)\nusing this:\n  chain R\n   (llist_of (x # (SOME xa. chain R (llist_of (x # xa @ [y]))) @ [y]))\n\ngoal (1 subgoal):\n 1. chain R\n     (llist_of (x # (SOME xs. chain R (llist_of (x # xs @ [y]))) @ [y]))", "by auto"], ["", "private"], ["", "friend_of_corec prepend where\n  \"prepend xs ys = (case xs of [] \\<Rightarrow>\n    (case ys of LNil \\<Rightarrow> LNil | LCons x xs \\<Rightarrow> LCons x xs) | x # xs' \\<Rightarrow> LCons x (prepend xs' ys))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. prepend xs ys =\n    (case xs of\n     [] \\<Rightarrow>\n       case ys of LNil \\<Rightarrow> LNil\n       | LCons x xs \\<Rightarrow> LCons x xs\n     | x # xs' \\<Rightarrow> LCons x (prepend xs' ys))\n 2. rel_fun (rel_prod (=) (rel_prod Ra (rel_sum (=) (rel_prod (=) Ra))))\n     (rel_sum (=) (rel_prod (=) (rel_ssig_llist_v1 Ra)))\n     (\\<lambda>(xs, ys).\n         case xs of\n         [] \\<Rightarrow>\n           case snd ys of Inl x \\<Rightarrow> Inl ()\n           | Inr (x1, x2) \\<Rightarrow> Inr (x1, llist.v1.VLeaf x2)\n         | x # xs' \\<Rightarrow>\n             Inr (x, llist.v1.Oper\n                      (llist.v1.Sig (Inr (xs', llist.v1.VLeaf (fst ys))))))\n     (\\<lambda>(xs, ys).\n         case xs of\n         [] \\<Rightarrow>\n           case snd ys of Inl x \\<Rightarrow> Inl ()\n           | Inr (x1, x2) \\<Rightarrow> Inr (x1, llist.v1.VLeaf x2)\n         | x # xs' \\<Rightarrow>\n             Inr (x, llist.v1.Oper\n                      (llist.v1.Sig (Inr (xs', llist.v1.VLeaf (fst ys))))))", "by (simp split: list.splits llist.splits) transfer_prover"], ["", "private"], ["", "corec wit where\n  \"wit xs = (case xs of LCons x (LCons y xs) \\<Rightarrow>\n     LCons x (prepend (pick x y) (wit (LCons y xs))) | _ \\<Rightarrow> xs)\""], ["", "private"], ["", "lemma\n  wit_LNil[simp]: \"wit LNil = LNil\" and\n  wit_lsingleton[simp]: \"wit (LCons x LNil) = LCons x LNil\" and\n  wit_LCons2: \"wit (LCons x (LCons y xs)) =\n     (LCons x (prepend (pick x y) (wit (LCons y xs))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wit LNil = LNil &&&\n    wit (LCons x LNil) = LCons x LNil &&&\n    wit (LCons x (LCons y xs)) =\n    LCons x (prepend (pick x y) (wit (LCons y xs)))", "by (subst wit.code; auto)+"], ["", "private"], ["", "lemma lnull_wit[simp]: \"lnull (wit xs) \\<longleftrightarrow> lnull xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lnull (wit xs) = lnull xs", "by (subst wit.code) (auto split: llist.splits simp: Let_def)"], ["", "private"], ["", "lemma lhd_wit[simp]: \"chain R\\<^sup>+\\<^sup>+ xs \\<Longrightarrow> lhd (wit xs) = lhd xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain R\\<^sup>+\\<^sup>+ xs \\<Longrightarrow> lhd (wit xs) = lhd xs", "by (erule chain.cases; subst wit.code) (auto split: llist.splits simp: Let_def)"], ["", "private"], ["", "lemma LNil_eq_iff_lnull: \"LNil = xs \\<longleftrightarrow> lnull xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LNil = xs) = lnull xs", "by (cases xs) auto"], ["", "lemma emb_wit[simp]: \"chain R\\<^sup>+\\<^sup>+ xs \\<Longrightarrow> emb xs (wit xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain R\\<^sup>+\\<^sup>+ xs \\<Longrightarrow> emb xs (wit xs)", "proof (coinduction arbitrary: xs rule: emb_prepend_coinduct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       chain R\\<^sup>+\\<^sup>+ xs \\<Longrightarrow>\n       (\\<exists>xsa.\n           xs = LNil \\<and> wit xs = xsa \\<and> lfinite xsa) \\<or>\n       (\\<exists>xsa ys x zs.\n           xs = LCons x xsa \\<and>\n           wit xs = prepend zs (LCons x ys) \\<and>\n           (prepend_cong1\n             (\\<lambda>x2__.\n                 \\<exists>xs.\n                    xsa = xs \\<and>\n                    x2__ = wit xs \\<and> chain R\\<^sup>+\\<^sup>+ xs)\n             ys \\<or>\n            emb xsa ys))", "case (emb xs)"], ["proof (state)\nthis:\n  chain R\\<^sup>+\\<^sup>+ xs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       chain R\\<^sup>+\\<^sup>+ xs \\<Longrightarrow>\n       (\\<exists>xsa.\n           xs = LNil \\<and> wit xs = xsa \\<and> lfinite xsa) \\<or>\n       (\\<exists>xsa ys x zs.\n           xs = LCons x xsa \\<and>\n           wit xs = prepend zs (LCons x ys) \\<and>\n           (prepend_cong1\n             (\\<lambda>x2__.\n                 \\<exists>xs.\n                    xsa = xs \\<and>\n                    x2__ = wit xs \\<and> chain R\\<^sup>+\\<^sup>+ xs)\n             ys \\<or>\n            emb xsa ys))", "then"], ["proof (chain)\npicking this:\n  chain R\\<^sup>+\\<^sup>+ xs", "show ?case"], ["proof (prove)\nusing this:\n  chain R\\<^sup>+\\<^sup>+ xs\n\ngoal (1 subgoal):\n 1. (\\<exists>xs. xs = LNil \\<and> wit xs = xs \\<and> lfinite xs) \\<or>\n    (\\<exists>xs ys x zs.\n        xs = LCons x xs \\<and>\n        wit xs = prepend zs (LCons x ys) \\<and>\n        (prepend_cong1\n          (\\<lambda>x2__.\n              \\<exists>xsa.\n                 xs = xsa \\<and>\n                 x2__ = wit xsa \\<and> chain R\\<^sup>+\\<^sup>+ xsa)\n          ys \\<or>\n         emb xs ys))", "proof (cases rule: chain.cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       xs = LCons x LNil \\<Longrightarrow>\n       (\\<exists>xs. xs = LNil \\<and> wit xs = xs \\<and> lfinite xs) \\<or>\n       (\\<exists>xs ys x zs.\n           xs = LCons x xs \\<and>\n           wit xs = prepend zs (LCons x ys) \\<and>\n           (prepend_cong1\n             (\\<lambda>x2__.\n                 \\<exists>xsa.\n                    xs = xsa \\<and>\n                    x2__ = wit xsa \\<and> chain R\\<^sup>+\\<^sup>+ xsa)\n             ys \\<or>\n            emb xs ys))\n 2. \\<And>xs x.\n       \\<lbrakk>xs = LCons x xs; chain R\\<^sup>+\\<^sup>+ xs;\n        R\\<^sup>+\\<^sup>+ x (lhd xs)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             xs = LNil \\<and>\n                             wit xs = xs \\<and> lfinite xs) \\<or>\n                         (\\<exists>xs ys x zs.\n                             xs = LCons x xs \\<and>\n                             wit xs = prepend zs (LCons x ys) \\<and>\n                             (prepend_cong1\n                               (\\<lambda>x2__.\n                                   \\<exists>xsa.\nxs = xsa \\<and> x2__ = wit xsa \\<and> chain R\\<^sup>+\\<^sup>+ xsa)\n                               ys \\<or>\n                              emb xs ys))", "case (chain_cons zs z)"], ["proof (state)\nthis:\n  xs = LCons z zs\n  chain R\\<^sup>+\\<^sup>+ zs\n  R\\<^sup>+\\<^sup>+ z (lhd zs)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       xs = LCons x LNil \\<Longrightarrow>\n       (\\<exists>xs. xs = LNil \\<and> wit xs = xs \\<and> lfinite xs) \\<or>\n       (\\<exists>xs ys x zs.\n           xs = LCons x xs \\<and>\n           wit xs = prepend zs (LCons x ys) \\<and>\n           (prepend_cong1\n             (\\<lambda>x2__.\n                 \\<exists>xsa.\n                    xs = xsa \\<and>\n                    x2__ = wit xsa \\<and> chain R\\<^sup>+\\<^sup>+ xsa)\n             ys \\<or>\n            emb xs ys))\n 2. \\<And>xs x.\n       \\<lbrakk>xs = LCons x xs; chain R\\<^sup>+\\<^sup>+ xs;\n        R\\<^sup>+\\<^sup>+ x (lhd xs)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>xs.\n                             xs = LNil \\<and>\n                             wit xs = xs \\<and> lfinite xs) \\<or>\n                         (\\<exists>xs ys x zs.\n                             xs = LCons x xs \\<and>\n                             wit xs = prepend zs (LCons x ys) \\<and>\n                             (prepend_cong1\n                               (\\<lambda>x2__.\n                                   \\<exists>xsa.\nxs = xsa \\<and> x2__ = wit xsa \\<and> chain R\\<^sup>+\\<^sup>+ xsa)\n                               ys \\<or>\n                              emb xs ys))", "then"], ["proof (chain)\npicking this:\n  xs = LCons z zs\n  chain R\\<^sup>+\\<^sup>+ zs\n  R\\<^sup>+\\<^sup>+ z (lhd zs)", "show ?thesis"], ["proof (prove)\nusing this:\n  xs = LCons z zs\n  chain R\\<^sup>+\\<^sup>+ zs\n  R\\<^sup>+\\<^sup>+ z (lhd zs)\n\ngoal (1 subgoal):\n 1. (\\<exists>xs. xs = LNil \\<and> wit xs = xs \\<and> lfinite xs) \\<or>\n    (\\<exists>xs ys x zs.\n        xs = LCons x xs \\<and>\n        wit xs = prepend zs (LCons x ys) \\<and>\n        (prepend_cong1\n          (\\<lambda>x2__.\n              \\<exists>xsa.\n                 xs = xsa \\<and>\n                 x2__ = wit xsa \\<and> chain R\\<^sup>+\\<^sup>+ xsa)\n          ys \\<or>\n         emb xs ys))", "by (subst (2) wit.code)\n        (auto split: llist.splits intro!: exI[of _ \"[]\"] exI[of _ \"_ :: _ llist\"]\n          prepend_cong1_prepend[OF prepend_cong1_base])"], ["proof (state)\nthis:\n  (\\<exists>xs. xs = LNil \\<and> wit xs = xs \\<and> lfinite xs) \\<or>\n  (\\<exists>xs ys x zs.\n      xs = LCons x xs \\<and>\n      wit xs = prepend zs (LCons x ys) \\<and>\n      (prepend_cong1\n        (\\<lambda>x2__.\n            \\<exists>xsa.\n               xs = xsa \\<and>\n               x2__ = wit xsa \\<and> chain R\\<^sup>+\\<^sup>+ xsa)\n        ys \\<or>\n       emb xs ys))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       xs = LCons x LNil \\<Longrightarrow>\n       (\\<exists>xs. xs = LNil \\<and> wit xs = xs \\<and> lfinite xs) \\<or>\n       (\\<exists>xs ys x zs.\n           xs = LCons x xs \\<and>\n           wit xs = prepend zs (LCons x ys) \\<and>\n           (prepend_cong1\n             (\\<lambda>x2__.\n                 \\<exists>xsa.\n                    xs = xsa \\<and>\n                    x2__ = wit xsa \\<and> chain R\\<^sup>+\\<^sup>+ xsa)\n             ys \\<or>\n            emb xs ys))", "qed (auto intro!: exI[of _ LNil] exI[of _ \"[]\"] emb.intros)"], ["proof (state)\nthis:\n  (\\<exists>xs. xs = LNil \\<and> wit xs = xs \\<and> lfinite xs) \\<or>\n  (\\<exists>xs ys x zs.\n      xs = LCons x xs \\<and>\n      wit xs = prepend zs (LCons x ys) \\<and>\n      (prepend_cong1\n        (\\<lambda>x2__.\n            \\<exists>xsa.\n               xs = xsa \\<and>\n               x2__ = wit xsa \\<and> chain R\\<^sup>+\\<^sup>+ xsa)\n        ys \\<or>\n       emb xs ys))\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma lfinite_wit[simp]:\n  assumes \"chain R\\<^sup>+\\<^sup>+ xs\"\n  shows \"lfinite (wit xs) \\<longleftrightarrow> lfinite xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite (wit xs) = lfinite xs", "using emb_wit emb_lfinite assms"], ["proof (prove)\nusing this:\n  chain R\\<^sup>+\\<^sup>+ ?xs \\<Longrightarrow> emb ?xs (wit ?xs)\n  emb ?xs ?ys \\<Longrightarrow> lfinite ?ys = lfinite ?xs\n  chain R\\<^sup>+\\<^sup>+ xs\n\ngoal (1 subgoal):\n 1. lfinite (wit xs) = lfinite xs", "by blast"], ["", "private"], ["", "lemma llast_wit[simp]:\n  assumes \"chain R\\<^sup>+\\<^sup>+ xs\"\n  shows \"llast (wit xs) = llast xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llast (wit xs) = llast xs", "proof (cases \"lfinite xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lfinite xs \\<Longrightarrow> llast (wit xs) = llast xs\n 2. \\<not> lfinite xs \\<Longrightarrow> llast (wit xs) = llast xs", "case True"], ["proof (state)\nthis:\n  lfinite xs\n\ngoal (2 subgoals):\n 1. lfinite xs \\<Longrightarrow> llast (wit xs) = llast xs\n 2. \\<not> lfinite xs \\<Longrightarrow> llast (wit xs) = llast xs", "from this assms"], ["proof (chain)\npicking this:\n  lfinite xs\n  chain R\\<^sup>+\\<^sup>+ xs", "show ?thesis"], ["proof (prove)\nusing this:\n  lfinite xs\n  chain R\\<^sup>+\\<^sup>+ xs\n\ngoal (1 subgoal):\n 1. llast (wit xs) = llast xs", "proof (induct rule: lfinite.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. chain R\\<^sup>+\\<^sup>+ LNil \\<Longrightarrow>\n    llast (wit LNil) = llast LNil\n 2. \\<And>xs x.\n       \\<lbrakk>lfinite xs;\n        chain R\\<^sup>+\\<^sup>+ xs \\<Longrightarrow>\n        llast (wit xs) = llast xs;\n        chain R\\<^sup>+\\<^sup>+ (LCons x xs)\\<rbrakk>\n       \\<Longrightarrow> llast (wit (LCons x xs)) = llast (LCons x xs)", "case (lfinite_LConsI xs x)"], ["proof (state)\nthis:\n  lfinite xs\n  chain R\\<^sup>+\\<^sup>+ xs \\<Longrightarrow> llast (wit xs) = llast xs\n  chain R\\<^sup>+\\<^sup>+ (LCons x xs)\n\ngoal (2 subgoals):\n 1. chain R\\<^sup>+\\<^sup>+ LNil \\<Longrightarrow>\n    llast (wit LNil) = llast LNil\n 2. \\<And>xs x.\n       \\<lbrakk>lfinite xs;\n        chain R\\<^sup>+\\<^sup>+ xs \\<Longrightarrow>\n        llast (wit xs) = llast xs;\n        chain R\\<^sup>+\\<^sup>+ (LCons x xs)\\<rbrakk>\n       \\<Longrightarrow> llast (wit (LCons x xs)) = llast (LCons x xs)", "then"], ["proof (chain)\npicking this:\n  lfinite xs\n  chain R\\<^sup>+\\<^sup>+ xs \\<Longrightarrow> llast (wit xs) = llast xs\n  chain R\\<^sup>+\\<^sup>+ (LCons x xs)", "show ?case"], ["proof (prove)\nusing this:\n  lfinite xs\n  chain R\\<^sup>+\\<^sup>+ xs \\<Longrightarrow> llast (wit xs) = llast xs\n  chain R\\<^sup>+\\<^sup>+ (LCons x xs)\n\ngoal (1 subgoal):\n 1. llast (wit (LCons x xs)) = llast (LCons x xs)", "by (cases xs) (auto simp: wit_LCons2 llast_LCons elim: chain_nontrivE)"], ["proof (state)\nthis:\n  llast (wit (LCons x xs)) = llast (LCons x xs)\n\ngoal (1 subgoal):\n 1. chain R\\<^sup>+\\<^sup>+ LNil \\<Longrightarrow>\n    llast (wit LNil) = llast LNil", "qed auto"], ["proof (state)\nthis:\n  llast (wit xs) = llast xs\n\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow> llast (wit xs) = llast xs", "qed (auto simp: llast_linfinite assms)"], ["", "lemma chain_tranclp_imp_exists_chain:\n  \"chain R\\<^sup>+\\<^sup>+ xs \\<Longrightarrow>\n   \\<exists>ys. chain R ys \\<and> emb xs ys \\<and> lhd ys = lhd xs \\<and> llast ys = llast xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain R\\<^sup>+\\<^sup>+ xs \\<Longrightarrow>\n    \\<exists>ys.\n       chain R ys \\<and>\n       emb xs ys \\<and> lhd ys = lhd xs \\<and> llast ys = llast xs", "proof (intro exI[of _ \"wit xs\"] conjI, coinduction arbitrary: xs rule: chain_prepend_coinduct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>xs.\n       chain R\\<^sup>+\\<^sup>+ xs \\<Longrightarrow>\n       (\\<exists>z. wit xs = LCons z LNil) \\<or>\n       (\\<exists>y xsa zs.\n           wit xs = LCons y (prepend zs xsa) \\<and>\n           ((\\<exists>xs.\n                xsa = wit xs \\<and> chain R\\<^sup>+\\<^sup>+ xs) \\<or>\n            chain R xsa) \\<and>\n           chain R (llist_of (y # zs @ [lhd xsa])))\n 2. chain R\\<^sup>+\\<^sup>+ xs \\<Longrightarrow> emb xs (wit xs)\n 3. chain R\\<^sup>+\\<^sup>+ xs \\<Longrightarrow> lhd (wit xs) = lhd xs\n 4. chain R\\<^sup>+\\<^sup>+ xs \\<Longrightarrow> llast (wit xs) = llast xs", "case chain"], ["proof (state)\nthis:\n  chain R\\<^sup>+\\<^sup>+ xs\n\ngoal (4 subgoals):\n 1. \\<And>xs.\n       chain R\\<^sup>+\\<^sup>+ xs \\<Longrightarrow>\n       (\\<exists>z. wit xs = LCons z LNil) \\<or>\n       (\\<exists>y xsa zs.\n           wit xs = LCons y (prepend zs xsa) \\<and>\n           ((\\<exists>xs.\n                xsa = wit xs \\<and> chain R\\<^sup>+\\<^sup>+ xs) \\<or>\n            chain R xsa) \\<and>\n           chain R (llist_of (y # zs @ [lhd xsa])))\n 2. chain R\\<^sup>+\\<^sup>+ xs \\<Longrightarrow> emb xs (wit xs)\n 3. chain R\\<^sup>+\\<^sup>+ xs \\<Longrightarrow> lhd (wit xs) = lhd xs\n 4. chain R\\<^sup>+\\<^sup>+ xs \\<Longrightarrow> llast (wit xs) = llast xs", "then"], ["proof (chain)\npicking this:\n  chain R\\<^sup>+\\<^sup>+ xs", "show ?case"], ["proof (prove)\nusing this:\n  chain R\\<^sup>+\\<^sup>+ xs\n\ngoal (1 subgoal):\n 1. (\\<exists>z. wit xs = LCons z LNil) \\<or>\n    (\\<exists>y xs zs.\n        wit xs = LCons y (prepend zs xs) \\<and>\n        ((\\<exists>xsa.\n             xs = wit xsa \\<and> chain R\\<^sup>+\\<^sup>+ xsa) \\<or>\n         chain R xs) \\<and>\n        chain R (llist_of (y # zs @ [lhd xs])))", "by (subst (1 2) wit.code) (erule chain.cases; force split: llist.splits dest: pick)"], ["proof (state)\nthis:\n  (\\<exists>z. wit xs = LCons z LNil) \\<or>\n  (\\<exists>y xs zs.\n      wit xs = LCons y (prepend zs xs) \\<and>\n      ((\\<exists>xsa. xs = wit xsa \\<and> chain R\\<^sup>+\\<^sup>+ xsa) \\<or>\n       chain R xs) \\<and>\n      chain R (llist_of (y # zs @ [lhd xs])))\n\ngoal (3 subgoals):\n 1. chain R\\<^sup>+\\<^sup>+ xs \\<Longrightarrow> emb xs (wit xs)\n 2. chain R\\<^sup>+\\<^sup>+ xs \\<Longrightarrow> lhd (wit xs) = lhd xs\n 3. chain R\\<^sup>+\\<^sup>+ xs \\<Longrightarrow> llast (wit xs) = llast xs", "qed auto"], ["", "lemma emb_lset_mono[rotated]: \"x \\<in> lset xs \\<Longrightarrow> emb xs ys \\<Longrightarrow> x \\<in> lset ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> lset xs; emb xs ys\\<rbrakk>\n    \\<Longrightarrow> x \\<in> lset ys", "by (induct x xs arbitrary: ys rule: llist.set_induct) (auto elim!: emb_LConsE)"], ["", "lemma emb_Ball_lset_antimono:\n  assumes \"emb Xs Ys\"\n  shows \"\\<forall>Y \\<in> lset Ys. x \\<in> Y \\<Longrightarrow> \\<forall>X \\<in> lset Xs. x \\<in> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Y\\<in>lset Ys. x \\<in> Y \\<Longrightarrow>\n    \\<forall>X\\<in>lset Xs. x \\<in> X", "using emb_lset_mono[OF assms]"], ["proof (prove)\nusing this:\n  ?x \\<in> lset Xs \\<Longrightarrow> ?x \\<in> lset Ys\n\ngoal (1 subgoal):\n 1. \\<forall>Y\\<in>lset Ys. x \\<in> Y \\<Longrightarrow>\n    \\<forall>X\\<in>lset Xs. x \\<in> X", "by blast"], ["", "lemma emb_lfinite_antimono[rotated]: \"lfinite ys \\<Longrightarrow> emb xs ys \\<Longrightarrow> lfinite xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lfinite ys; emb xs ys\\<rbrakk> \\<Longrightarrow> lfinite xs", "by (induct ys arbitrary: xs rule: lfinite_prepend_induct)\n    (force elim!: emb_LNil2E simp: LNil_eq_iff_lnull prepend_LCons elim: emb.cases)+"], ["", "lemma emb_Liminf_llist_mono_aux:\n  assumes \"emb Xs Ys\" and \"\\<not> lfinite Xs\" and \"\\<not> lfinite Ys\" and \"\\<forall>j\\<ge>i. x \\<in> lnth Ys j\"\n  shows \"\\<forall>j\\<ge>i. x \\<in> lnth Xs j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j\\<ge>i. x \\<in> lnth Xs j", "using assms"], ["proof (prove)\nusing this:\n  emb Xs Ys\n  \\<not> lfinite Xs\n  \\<not> lfinite Ys\n  \\<forall>j\\<ge>i. x \\<in> lnth Ys j\n\ngoal (1 subgoal):\n 1. \\<forall>j\\<ge>i. x \\<in> lnth Xs j", "proof (induct i arbitrary: Xs Ys rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa Xs Ys.\n       \\<lbrakk>\\<And>y Xs Ys.\n                   \\<lbrakk>y < xa; emb Xs Ys; \\<not> lfinite Xs;\n                    \\<not> lfinite Ys;\n                    \\<forall>j\\<ge>y. x \\<in> lnth Ys j\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>j\\<ge>y. x \\<in> lnth Xs j;\n        emb Xs Ys; \\<not> lfinite Xs; \\<not> lfinite Ys;\n        \\<forall>j\\<ge>xa. x \\<in> lnth Ys j\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j\\<ge>xa. x \\<in> lnth Xs j", "case (less i)"], ["proof (state)\nthis:\n  \\<lbrakk>?y < i; emb ?Xs ?Ys; \\<not> lfinite ?Xs; \\<not> lfinite ?Ys;\n   \\<forall>j\\<ge>?y. x \\<in> lnth ?Ys j\\<rbrakk>\n  \\<Longrightarrow> \\<forall>j\\<ge>?y. x \\<in> lnth ?Xs j\n  emb Xs Ys\n  \\<not> lfinite Xs\n  \\<not> lfinite Ys\n  \\<forall>j\\<ge>i. x \\<in> lnth Ys j\n\ngoal (1 subgoal):\n 1. \\<And>xa Xs Ys.\n       \\<lbrakk>\\<And>y Xs Ys.\n                   \\<lbrakk>y < xa; emb Xs Ys; \\<not> lfinite Xs;\n                    \\<not> lfinite Ys;\n                    \\<forall>j\\<ge>y. x \\<in> lnth Ys j\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>j\\<ge>y. x \\<in> lnth Xs j;\n        emb Xs Ys; \\<not> lfinite Xs; \\<not> lfinite Ys;\n        \\<forall>j\\<ge>xa. x \\<in> lnth Ys j\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j\\<ge>xa. x \\<in> lnth Xs j", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?y < i; emb ?Xs ?Ys; \\<not> lfinite ?Xs; \\<not> lfinite ?Ys;\n   \\<forall>j\\<ge>?y. x \\<in> lnth ?Ys j\\<rbrakk>\n  \\<Longrightarrow> \\<forall>j\\<ge>?y. x \\<in> lnth ?Xs j\n  emb Xs Ys\n  \\<not> lfinite Xs\n  \\<not> lfinite Ys\n  \\<forall>j\\<ge>i. x \\<in> lnth Ys j", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y < i; emb ?Xs ?Ys; \\<not> lfinite ?Xs; \\<not> lfinite ?Ys;\n   \\<forall>j\\<ge>?y. x \\<in> lnth ?Ys j\\<rbrakk>\n  \\<Longrightarrow> \\<forall>j\\<ge>?y. x \\<in> lnth ?Xs j\n  emb Xs Ys\n  \\<not> lfinite Xs\n  \\<not> lfinite Ys\n  \\<forall>j\\<ge>i. x \\<in> lnth Ys j\n\ngoal (1 subgoal):\n 1. \\<forall>j\\<ge>i. x \\<in> lnth Xs j", "proof (cases i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>y Xs Ys.\n                \\<lbrakk>y < i; emb Xs Ys; \\<not> lfinite Xs;\n                 \\<not> lfinite Ys;\n                 \\<forall>j\\<ge>y. x \\<in> lnth Ys j\\<rbrakk>\n                \\<Longrightarrow> \\<forall>j\\<ge>y. x \\<in> lnth Xs j;\n     emb Xs Ys; \\<not> lfinite Xs; \\<not> lfinite Ys;\n     \\<forall>j\\<ge>i. x \\<in> lnth Ys j; i = 0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>j\\<ge>i. x \\<in> lnth Xs j\n 2. \\<And>nat.\n       \\<lbrakk>\\<And>y Xs Ys.\n                   \\<lbrakk>y < i; emb Xs Ys; \\<not> lfinite Xs;\n                    \\<not> lfinite Ys;\n                    \\<forall>j\\<ge>y. x \\<in> lnth Ys j\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>j\\<ge>y. x \\<in> lnth Xs j;\n        emb Xs Ys; \\<not> lfinite Xs; \\<not> lfinite Ys;\n        \\<forall>j\\<ge>i. x \\<in> lnth Ys j; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j\\<ge>i. x \\<in> lnth Xs j", "case 0"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>y Xs Ys.\n                \\<lbrakk>y < i; emb Xs Ys; \\<not> lfinite Xs;\n                 \\<not> lfinite Ys;\n                 \\<forall>j\\<ge>y. x \\<in> lnth Ys j\\<rbrakk>\n                \\<Longrightarrow> \\<forall>j\\<ge>y. x \\<in> lnth Xs j;\n     emb Xs Ys; \\<not> lfinite Xs; \\<not> lfinite Ys;\n     \\<forall>j\\<ge>i. x \\<in> lnth Ys j; i = 0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>j\\<ge>i. x \\<in> lnth Xs j\n 2. \\<And>nat.\n       \\<lbrakk>\\<And>y Xs Ys.\n                   \\<lbrakk>y < i; emb Xs Ys; \\<not> lfinite Xs;\n                    \\<not> lfinite Ys;\n                    \\<forall>j\\<ge>y. x \\<in> lnth Ys j\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>j\\<ge>y. x \\<in> lnth Xs j;\n        emb Xs Ys; \\<not> lfinite Xs; \\<not> lfinite Ys;\n        \\<forall>j\\<ge>i. x \\<in> lnth Ys j; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j\\<ge>i. x \\<in> lnth Xs j", "then"], ["proof (chain)\npicking this:\n  i = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  i = 0\n\ngoal (1 subgoal):\n 1. \\<forall>j\\<ge>i. x \\<in> lnth Xs j", "using emb_Ball_lset_antimono[OF less(2), of x] less(5)"], ["proof (prove)\nusing this:\n  i = 0\n  \\<forall>Y\\<in>lset Ys. x \\<in> Y \\<Longrightarrow>\n  \\<forall>X\\<in>lset Xs. x \\<in> X\n  \\<forall>j\\<ge>i. x \\<in> lnth Ys j\n\ngoal (1 subgoal):\n 1. \\<forall>j\\<ge>i. x \\<in> lnth Xs j", "unfolding Ball_def in_lset_conv_lnth simp_thms\n        not_lfinite_llength[OF less(3)] not_lfinite_llength[OF less(4)] enat_ord_code subset_eq"], ["proof (prove)\nusing this:\n  i = 0\n  \\<forall>xa.\n     (\\<exists>n. lnth Ys n = xa) \\<longrightarrow>\n     x \\<in> xa \\<Longrightarrow>\n  \\<forall>xa. (\\<exists>n. lnth Xs n = xa) \\<longrightarrow> x \\<in> xa\n  \\<forall>j\\<ge>i. x \\<in> lnth Ys j\n\ngoal (1 subgoal):\n 1. \\<forall>j\\<ge>i. x \\<in> lnth Xs j", "by blast"], ["proof (state)\nthis:\n  \\<forall>j\\<ge>i. x \\<in> lnth Xs j\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>\\<And>y Xs Ys.\n                   \\<lbrakk>y < i; emb Xs Ys; \\<not> lfinite Xs;\n                    \\<not> lfinite Ys;\n                    \\<forall>j\\<ge>y. x \\<in> lnth Ys j\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>j\\<ge>y. x \\<in> lnth Xs j;\n        emb Xs Ys; \\<not> lfinite Xs; \\<not> lfinite Ys;\n        \\<forall>j\\<ge>i. x \\<in> lnth Ys j; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j\\<ge>i. x \\<in> lnth Xs j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>\\<And>y Xs Ys.\n                   \\<lbrakk>y < i; emb Xs Ys; \\<not> lfinite Xs;\n                    \\<not> lfinite Ys;\n                    \\<forall>j\\<ge>y. x \\<in> lnth Ys j\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>j\\<ge>y. x \\<in> lnth Xs j;\n        emb Xs Ys; \\<not> lfinite Xs; \\<not> lfinite Ys;\n        \\<forall>j\\<ge>i. x \\<in> lnth Ys j; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j\\<ge>i. x \\<in> lnth Xs j", "case [simp]: (Suc nat)"], ["proof (state)\nthis:\n  i = Suc nat\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>\\<And>y Xs Ys.\n                   \\<lbrakk>y < i; emb Xs Ys; \\<not> lfinite Xs;\n                    \\<not> lfinite Ys;\n                    \\<forall>j\\<ge>y. x \\<in> lnth Ys j\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>j\\<ge>y. x \\<in> lnth Xs j;\n        emb Xs Ys; \\<not> lfinite Xs; \\<not> lfinite Ys;\n        \\<forall>j\\<ge>i. x \\<in> lnth Ys j; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j\\<ge>i. x \\<in> lnth Xs j", "from less(2,3)"], ["proof (chain)\npicking this:\n  emb Xs Ys\n  \\<not> lfinite Xs", "obtain xs as b bs where\n      [simp]: \"Xs = LCons b xs\" \"Ys = prepend as (LCons b bs)\" and \"emb xs bs\""], ["proof (prove)\nusing this:\n  emb Xs Ys\n  \\<not> lfinite Xs\n\ngoal (1 subgoal):\n 1. (\\<And>b xs as bs.\n        \\<lbrakk>Xs = LCons b xs; Ys = prepend as (LCons b bs);\n         emb xs bs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: emb.cases)"], ["proof (state)\nthis:\n  Xs = LCons b xs\n  Ys = prepend as (LCons b bs)\n  emb xs bs\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>\\<And>y Xs Ys.\n                   \\<lbrakk>y < i; emb Xs Ys; \\<not> lfinite Xs;\n                    \\<not> lfinite Ys;\n                    \\<forall>j\\<ge>y. x \\<in> lnth Ys j\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>j\\<ge>y. x \\<in> lnth Xs j;\n        emb Xs Ys; \\<not> lfinite Xs; \\<not> lfinite Ys;\n        \\<forall>j\\<ge>i. x \\<in> lnth Ys j; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j\\<ge>i. x \\<in> lnth Xs j", "have IH: \"\\<forall>k\\<ge>j. x \\<in> lnth xs k\" if \"\\<forall>k\\<ge>j. x \\<in> lnth bs k\" \"j < i\" for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k\\<ge>j. x \\<in> lnth xs k", "using that less(1)[OF _ \\<open>emb xs bs\\<close>] less(3,4)"], ["proof (prove)\nusing this:\n  \\<forall>k\\<ge>j. x \\<in> lnth bs k\n  j < i\n  \\<lbrakk>?y < i; \\<not> lfinite xs; \\<not> lfinite bs;\n   \\<forall>j\\<ge>?y. x \\<in> lnth bs j\\<rbrakk>\n  \\<Longrightarrow> \\<forall>j\\<ge>?y. x \\<in> lnth xs j\n  \\<not> lfinite Xs\n  \\<not> lfinite Ys\n\ngoal (1 subgoal):\n 1. \\<forall>k\\<ge>j. x \\<in> lnth xs k", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>k\\<ge>?j. x \\<in> lnth bs k; ?j < i\\<rbrakk>\n  \\<Longrightarrow> \\<forall>k\\<ge>?j. x \\<in> lnth xs k\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>\\<And>y Xs Ys.\n                   \\<lbrakk>y < i; emb Xs Ys; \\<not> lfinite Xs;\n                    \\<not> lfinite Ys;\n                    \\<forall>j\\<ge>y. x \\<in> lnth Ys j\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>j\\<ge>y. x \\<in> lnth Xs j;\n        emb Xs Ys; \\<not> lfinite Xs; \\<not> lfinite Ys;\n        \\<forall>j\\<ge>i. x \\<in> lnth Ys j; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j\\<ge>i. x \\<in> lnth Xs j", "from less(5)"], ["proof (chain)\npicking this:\n  \\<forall>j\\<ge>i. x \\<in> lnth Ys j", "have \"\\<forall>k\\<ge>i - length as - 1. x \\<in> lnth xs k\""], ["proof (prove)\nusing this:\n  \\<forall>j\\<ge>i. x \\<in> lnth Ys j\n\ngoal (1 subgoal):\n 1. \\<forall>k\\<ge>i - length as - 1. x \\<in> lnth xs k", "by (intro IH allI)\n        (drule spec[of _ \"_ + length as + 1\"], auto simp: lnth_prepend lnth_LCons')"], ["proof (state)\nthis:\n  \\<forall>k\\<ge>i - length as - 1. x \\<in> lnth xs k\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>\\<And>y Xs Ys.\n                   \\<lbrakk>y < i; emb Xs Ys; \\<not> lfinite Xs;\n                    \\<not> lfinite Ys;\n                    \\<forall>j\\<ge>y. x \\<in> lnth Ys j\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>j\\<ge>y. x \\<in> lnth Xs j;\n        emb Xs Ys; \\<not> lfinite Xs; \\<not> lfinite Ys;\n        \\<forall>j\\<ge>i. x \\<in> lnth Ys j; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j\\<ge>i. x \\<in> lnth Xs j", "then"], ["proof (chain)\npicking this:\n  \\<forall>k\\<ge>i - length as - 1. x \\<in> lnth xs k", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>k\\<ge>i - length as - 1. x \\<in> lnth xs k\n\ngoal (1 subgoal):\n 1. \\<forall>j\\<ge>i. x \\<in> lnth Xs j", "by (auto simp: lnth_LCons')"], ["proof (state)\nthis:\n  \\<forall>j\\<ge>i. x \\<in> lnth Xs j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>j\\<ge>i. x \\<in> lnth Xs j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma emb_Liminf_llist_infinite:\n  assumes \"emb Xs Ys\" and \"\\<not> lfinite Xs\"\n  shows \"Liminf_llist Ys \\<subseteq> Liminf_llist Xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Liminf_llist Ys \\<subseteq> Liminf_llist Xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Liminf_llist Ys \\<subseteq> Liminf_llist Xs", "from assms"], ["proof (chain)\npicking this:\n  emb Xs Ys\n  \\<not> lfinite Xs", "have \"\\<not> lfinite Ys\""], ["proof (prove)\nusing this:\n  emb Xs Ys\n  \\<not> lfinite Xs\n\ngoal (1 subgoal):\n 1. \\<not> lfinite Ys", "using emb_lfinite_antimono"], ["proof (prove)\nusing this:\n  emb Xs Ys\n  \\<not> lfinite Xs\n  \\<lbrakk>emb ?xs ?ys; lfinite ?ys\\<rbrakk> \\<Longrightarrow> lfinite ?xs\n\ngoal (1 subgoal):\n 1. \\<not> lfinite Ys", "by blast"], ["proof (state)\nthis:\n  \\<not> lfinite Ys\n\ngoal (1 subgoal):\n 1. Liminf_llist Ys \\<subseteq> Liminf_llist Xs", "with assms"], ["proof (chain)\npicking this:\n  emb Xs Ys\n  \\<not> lfinite Xs\n  \\<not> lfinite Ys", "show ?thesis"], ["proof (prove)\nusing this:\n  emb Xs Ys\n  \\<not> lfinite Xs\n  \\<not> lfinite Ys\n\ngoal (1 subgoal):\n 1. Liminf_llist Ys \\<subseteq> Liminf_llist Xs", "unfolding Liminf_llist_def"], ["proof (prove)\nusing this:\n  emb Xs Ys\n  \\<not> lfinite Xs\n  \\<not> lfinite Ys\n\ngoal (1 subgoal):\n 1. (\\<Union>i\\<in>{i. enat i < llength Ys}.\n        \\<Inter> (lnth Ys ` {j. i \\<le> j \\<and> enat j < llength Ys}))\n    \\<subseteq> (\\<Union>i\\<in>{i. enat i < llength Xs}.\n                    \\<Inter>\n                     (lnth Xs ` {j. i \\<le> j \\<and> enat j < llength Xs}))", "by (auto simp: not_lfinite_llength dest: emb_Liminf_llist_mono_aux)"], ["proof (state)\nthis:\n  Liminf_llist Ys \\<subseteq> Liminf_llist Xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma emb_lmap: \"emb xs ys \\<Longrightarrow> emb (lmap f xs) (lmap f ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emb xs ys \\<Longrightarrow> emb (lmap f xs) (lmap f ys)", "proof (coinduction arbitrary: xs ys rule: emb.coinduct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       emb xs ys \\<Longrightarrow>\n       (\\<exists>xsa.\n           lmap f xs = LNil \\<and> lmap f ys = xsa \\<and> lfinite xsa) \\<or>\n       (\\<exists>xsa ysa x zs.\n           lmap f xs = LCons x xsa \\<and>\n           lmap f ys = prepend zs (LCons x ysa) \\<and>\n           ((\\<exists>xs ys.\n                xsa = lmap f xs \\<and>\n                ysa = lmap f ys \\<and> emb xs ys) \\<or>\n            emb xsa ysa))", "case emb"], ["proof (state)\nthis:\n  emb xs ys\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       emb xs ys \\<Longrightarrow>\n       (\\<exists>xsa.\n           lmap f xs = LNil \\<and> lmap f ys = xsa \\<and> lfinite xsa) \\<or>\n       (\\<exists>xsa ysa x zs.\n           lmap f xs = LCons x xsa \\<and>\n           lmap f ys = prepend zs (LCons x ysa) \\<and>\n           ((\\<exists>xs ys.\n                xsa = lmap f xs \\<and>\n                ysa = lmap f ys \\<and> emb xs ys) \\<or>\n            emb xsa ysa))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>xs.\n        lmap f xs = LNil \\<and> lmap f ys = xs \\<and> lfinite xs) \\<or>\n    (\\<exists>xs ys x zs.\n        lmap f xs = LCons x xs \\<and>\n        lmap f ys = prepend zs (LCons x ys) \\<and>\n        ((\\<exists>xsa ysa.\n             xs = lmap f xsa \\<and>\n             ys = lmap f ysa \\<and> emb xsa ysa) \\<or>\n         emb xs ys))", "proof (cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = LNil \\<Longrightarrow>\n    (\\<exists>xs.\n        lmap f xs = LNil \\<and> lmap f ys = xs \\<and> lfinite xs) \\<or>\n    (\\<exists>xs ys x zs.\n        lmap f xs = LCons x xs \\<and>\n        lmap f ys = prepend zs (LCons x ys) \\<and>\n        ((\\<exists>xsa ysa.\n             xs = lmap f xsa \\<and>\n             ys = lmap f ysa \\<and> emb xsa ysa) \\<or>\n         emb xs ys))\n 2. \\<And>x21 x22.\n       xs = LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>xs.\n           lmap f xs = LNil \\<and> lmap f ys = xs \\<and> lfinite xs) \\<or>\n       (\\<exists>xs ys x zs.\n           lmap f xs = LCons x xs \\<and>\n           lmap f ys = prepend zs (LCons x ys) \\<and>\n           ((\\<exists>xsa ysa.\n                xs = lmap f xsa \\<and>\n                ys = lmap f ysa \\<and> emb xsa ysa) \\<or>\n            emb xs ys))", "case xs: (LCons x xs')"], ["proof (state)\nthis:\n  xs = LCons x xs'\n\ngoal (2 subgoals):\n 1. xs = LNil \\<Longrightarrow>\n    (\\<exists>xs.\n        lmap f xs = LNil \\<and> lmap f ys = xs \\<and> lfinite xs) \\<or>\n    (\\<exists>xs ys x zs.\n        lmap f xs = LCons x xs \\<and>\n        lmap f ys = prepend zs (LCons x ys) \\<and>\n        ((\\<exists>xsa ysa.\n             xs = lmap f xsa \\<and>\n             ys = lmap f ysa \\<and> emb xsa ysa) \\<or>\n         emb xs ys))\n 2. \\<And>x21 x22.\n       xs = LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>xs.\n           lmap f xs = LNil \\<and> lmap f ys = xs \\<and> lfinite xs) \\<or>\n       (\\<exists>xs ys x zs.\n           lmap f xs = LCons x xs \\<and>\n           lmap f ys = prepend zs (LCons x ys) \\<and>\n           ((\\<exists>xsa ysa.\n                xs = lmap f xsa \\<and>\n                ys = lmap f ysa \\<and> emb xsa ysa) \\<or>\n            emb xs ys))", "obtain ysa0 and zs0 where\n      ys: \"ys = prepend zs0 (LCons x ysa0)\" and\n      emb': \"emb xs' ysa0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>zs0 ysa0.\n        \\<lbrakk>ys = prepend zs0 (LCons x ysa0); emb xs' ysa0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using emb_LConsE[OF emb[unfolded xs]]"], ["proof (prove)\nusing this:\n  (\\<And>ys zs.\n      \\<lbrakk>ys = prepend zs (LCons x ys); emb xs' ys\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P\n\ngoal (1 subgoal):\n 1. (\\<And>zs0 ysa0.\n        \\<lbrakk>ys = prepend zs0 (LCons x ysa0); emb xs' ysa0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  ys = prepend zs0 (LCons x ysa0)\n  emb xs' ysa0\n\ngoal (2 subgoals):\n 1. xs = LNil \\<Longrightarrow>\n    (\\<exists>xs.\n        lmap f xs = LNil \\<and> lmap f ys = xs \\<and> lfinite xs) \\<or>\n    (\\<exists>xs ys x zs.\n        lmap f xs = LCons x xs \\<and>\n        lmap f ys = prepend zs (LCons x ys) \\<and>\n        ((\\<exists>xsa ysa.\n             xs = lmap f xsa \\<and>\n             ys = lmap f ysa \\<and> emb xsa ysa) \\<or>\n         emb xs ys))\n 2. \\<And>x21 x22.\n       xs = LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>xs.\n           lmap f xs = LNil \\<and> lmap f ys = xs \\<and> lfinite xs) \\<or>\n       (\\<exists>xs ys x zs.\n           lmap f xs = LCons x xs \\<and>\n           lmap f ys = prepend zs (LCons x ys) \\<and>\n           ((\\<exists>xsa ysa.\n                xs = lmap f xsa \\<and>\n                ys = lmap f ysa \\<and> emb xsa ysa) \\<or>\n            emb xs ys))", "let ?xa = \"f x\""], ["proof (state)\ngoal (2 subgoals):\n 1. xs = LNil \\<Longrightarrow>\n    (\\<exists>xs.\n        lmap f xs = LNil \\<and> lmap f ys = xs \\<and> lfinite xs) \\<or>\n    (\\<exists>xs ys x zs.\n        lmap f xs = LCons x xs \\<and>\n        lmap f ys = prepend zs (LCons x ys) \\<and>\n        ((\\<exists>xsa ysa.\n             xs = lmap f xsa \\<and>\n             ys = lmap f ysa \\<and> emb xsa ysa) \\<or>\n         emb xs ys))\n 2. \\<And>x21 x22.\n       xs = LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>xs.\n           lmap f xs = LNil \\<and> lmap f ys = xs \\<and> lfinite xs) \\<or>\n       (\\<exists>xs ys x zs.\n           lmap f xs = LCons x xs \\<and>\n           lmap f ys = prepend zs (LCons x ys) \\<and>\n           ((\\<exists>xsa ysa.\n                xs = lmap f xsa \\<and>\n                ys = lmap f ysa \\<and> emb xsa ysa) \\<or>\n            emb xs ys))", "let ?xsa = \"lmap f xs'\""], ["proof (state)\ngoal (2 subgoals):\n 1. xs = LNil \\<Longrightarrow>\n    (\\<exists>xs.\n        lmap f xs = LNil \\<and> lmap f ys = xs \\<and> lfinite xs) \\<or>\n    (\\<exists>xs ys x zs.\n        lmap f xs = LCons x xs \\<and>\n        lmap f ys = prepend zs (LCons x ys) \\<and>\n        ((\\<exists>xsa ysa.\n             xs = lmap f xsa \\<and>\n             ys = lmap f ysa \\<and> emb xsa ysa) \\<or>\n         emb xs ys))\n 2. \\<And>x21 x22.\n       xs = LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>xs.\n           lmap f xs = LNil \\<and> lmap f ys = xs \\<and> lfinite xs) \\<or>\n       (\\<exists>xs ys x zs.\n           lmap f xs = LCons x xs \\<and>\n           lmap f ys = prepend zs (LCons x ys) \\<and>\n           ((\\<exists>xsa ysa.\n                xs = lmap f xsa \\<and>\n                ys = lmap f ysa \\<and> emb xsa ysa) \\<or>\n            emb xs ys))", "let ?zs = \"map f zs0\""], ["proof (state)\ngoal (2 subgoals):\n 1. xs = LNil \\<Longrightarrow>\n    (\\<exists>xs.\n        lmap f xs = LNil \\<and> lmap f ys = xs \\<and> lfinite xs) \\<or>\n    (\\<exists>xs ys x zs.\n        lmap f xs = LCons x xs \\<and>\n        lmap f ys = prepend zs (LCons x ys) \\<and>\n        ((\\<exists>xsa ysa.\n             xs = lmap f xsa \\<and>\n             ys = lmap f ysa \\<and> emb xsa ysa) \\<or>\n         emb xs ys))\n 2. \\<And>x21 x22.\n       xs = LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>xs.\n           lmap f xs = LNil \\<and> lmap f ys = xs \\<and> lfinite xs) \\<or>\n       (\\<exists>xs ys x zs.\n           lmap f xs = LCons x xs \\<and>\n           lmap f ys = prepend zs (LCons x ys) \\<and>\n           ((\\<exists>xsa ysa.\n                xs = lmap f xsa \\<and>\n                ys = lmap f ysa \\<and> emb xsa ysa) \\<or>\n            emb xs ys))", "let ?ysa = \"lmap f ysa0\""], ["proof (state)\ngoal (2 subgoals):\n 1. xs = LNil \\<Longrightarrow>\n    (\\<exists>xs.\n        lmap f xs = LNil \\<and> lmap f ys = xs \\<and> lfinite xs) \\<or>\n    (\\<exists>xs ys x zs.\n        lmap f xs = LCons x xs \\<and>\n        lmap f ys = prepend zs (LCons x ys) \\<and>\n        ((\\<exists>xsa ysa.\n             xs = lmap f xsa \\<and>\n             ys = lmap f ysa \\<and> emb xsa ysa) \\<or>\n         emb xs ys))\n 2. \\<And>x21 x22.\n       xs = LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>xs.\n           lmap f xs = LNil \\<and> lmap f ys = xs \\<and> lfinite xs) \\<or>\n       (\\<exists>xs ys x zs.\n           lmap f xs = LCons x xs \\<and>\n           lmap f ys = prepend zs (LCons x ys) \\<and>\n           ((\\<exists>xsa ysa.\n                xs = lmap f xsa \\<and>\n                ys = lmap f ysa \\<and> emb xsa ysa) \\<or>\n            emb xs ys))", "have \"lmap f xs = LCons ?xa ?xsa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lmap f xs = LCons (f x) (lmap f xs')", "unfolding xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. lmap f (LCons x xs') = LCons (f x) (lmap f xs')", "by simp"], ["proof (state)\nthis:\n  lmap f xs = LCons (f x) (lmap f xs')\n\ngoal (2 subgoals):\n 1. xs = LNil \\<Longrightarrow>\n    (\\<exists>xs.\n        lmap f xs = LNil \\<and> lmap f ys = xs \\<and> lfinite xs) \\<or>\n    (\\<exists>xs ys x zs.\n        lmap f xs = LCons x xs \\<and>\n        lmap f ys = prepend zs (LCons x ys) \\<and>\n        ((\\<exists>xsa ysa.\n             xs = lmap f xsa \\<and>\n             ys = lmap f ysa \\<and> emb xsa ysa) \\<or>\n         emb xs ys))\n 2. \\<And>x21 x22.\n       xs = LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>xs.\n           lmap f xs = LNil \\<and> lmap f ys = xs \\<and> lfinite xs) \\<or>\n       (\\<exists>xs ys x zs.\n           lmap f xs = LCons x xs \\<and>\n           lmap f ys = prepend zs (LCons x ys) \\<and>\n           ((\\<exists>xsa ysa.\n                xs = lmap f xsa \\<and>\n                ys = lmap f ysa \\<and> emb xsa ysa) \\<or>\n            emb xs ys))", "moreover"], ["proof (state)\nthis:\n  lmap f xs = LCons (f x) (lmap f xs')\n\ngoal (2 subgoals):\n 1. xs = LNil \\<Longrightarrow>\n    (\\<exists>xs.\n        lmap f xs = LNil \\<and> lmap f ys = xs \\<and> lfinite xs) \\<or>\n    (\\<exists>xs ys x zs.\n        lmap f xs = LCons x xs \\<and>\n        lmap f ys = prepend zs (LCons x ys) \\<and>\n        ((\\<exists>xsa ysa.\n             xs = lmap f xsa \\<and>\n             ys = lmap f ysa \\<and> emb xsa ysa) \\<or>\n         emb xs ys))\n 2. \\<And>x21 x22.\n       xs = LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>xs.\n           lmap f xs = LNil \\<and> lmap f ys = xs \\<and> lfinite xs) \\<or>\n       (\\<exists>xs ys x zs.\n           lmap f xs = LCons x xs \\<and>\n           lmap f ys = prepend zs (LCons x ys) \\<and>\n           ((\\<exists>xsa ysa.\n                xs = lmap f xsa \\<and>\n                ys = lmap f ysa \\<and> emb xsa ysa) \\<or>\n            emb xs ys))", "have \"lmap f ys = prepend ?zs (LCons ?xa ?ysa)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lmap f ys = prepend (map f zs0) (LCons (f x) (lmap f ysa0))", "unfolding ys"], ["proof (prove)\ngoal (1 subgoal):\n 1. lmap f (prepend zs0 (LCons x ysa0)) =\n    prepend (map f zs0) (LCons (f x) (lmap f ysa0))", "by simp"], ["proof (state)\nthis:\n  lmap f ys = prepend (map f zs0) (LCons (f x) (lmap f ysa0))\n\ngoal (2 subgoals):\n 1. xs = LNil \\<Longrightarrow>\n    (\\<exists>xs.\n        lmap f xs = LNil \\<and> lmap f ys = xs \\<and> lfinite xs) \\<or>\n    (\\<exists>xs ys x zs.\n        lmap f xs = LCons x xs \\<and>\n        lmap f ys = prepend zs (LCons x ys) \\<and>\n        ((\\<exists>xsa ysa.\n             xs = lmap f xsa \\<and>\n             ys = lmap f ysa \\<and> emb xsa ysa) \\<or>\n         emb xs ys))\n 2. \\<And>x21 x22.\n       xs = LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>xs.\n           lmap f xs = LNil \\<and> lmap f ys = xs \\<and> lfinite xs) \\<or>\n       (\\<exists>xs ys x zs.\n           lmap f xs = LCons x xs \\<and>\n           lmap f ys = prepend zs (LCons x ys) \\<and>\n           ((\\<exists>xsa ysa.\n                xs = lmap f xsa \\<and>\n                ys = lmap f ysa \\<and> emb xsa ysa) \\<or>\n            emb xs ys))", "moreover"], ["proof (state)\nthis:\n  lmap f ys = prepend (map f zs0) (LCons (f x) (lmap f ysa0))\n\ngoal (2 subgoals):\n 1. xs = LNil \\<Longrightarrow>\n    (\\<exists>xs.\n        lmap f xs = LNil \\<and> lmap f ys = xs \\<and> lfinite xs) \\<or>\n    (\\<exists>xs ys x zs.\n        lmap f xs = LCons x xs \\<and>\n        lmap f ys = prepend zs (LCons x ys) \\<and>\n        ((\\<exists>xsa ysa.\n             xs = lmap f xsa \\<and>\n             ys = lmap f ysa \\<and> emb xsa ysa) \\<or>\n         emb xs ys))\n 2. \\<And>x21 x22.\n       xs = LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>xs.\n           lmap f xs = LNil \\<and> lmap f ys = xs \\<and> lfinite xs) \\<or>\n       (\\<exists>xs ys x zs.\n           lmap f xs = LCons x xs \\<and>\n           lmap f ys = prepend zs (LCons x ys) \\<and>\n           ((\\<exists>xsa ysa.\n                xs = lmap f xsa \\<and>\n                ys = lmap f ysa \\<and> emb xsa ysa) \\<or>\n            emb xs ys))", "have \"\\<exists>xsa ysa. ?xsa = lmap f xsa \\<and> ?ysa = lmap f ysa \\<and> emb xsa ysa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xsa ysa.\n       lmap f xs' = lmap f xsa \\<and>\n       lmap f ysa0 = lmap f ysa \\<and> emb xsa ysa", "using emb'"], ["proof (prove)\nusing this:\n  emb xs' ysa0\n\ngoal (1 subgoal):\n 1. \\<exists>xsa ysa.\n       lmap f xs' = lmap f xsa \\<and>\n       lmap f ysa0 = lmap f ysa \\<and> emb xsa ysa", "by blast"], ["proof (state)\nthis:\n  \\<exists>xsa ysa.\n     lmap f xs' = lmap f xsa \\<and>\n     lmap f ysa0 = lmap f ysa \\<and> emb xsa ysa\n\ngoal (2 subgoals):\n 1. xs = LNil \\<Longrightarrow>\n    (\\<exists>xs.\n        lmap f xs = LNil \\<and> lmap f ys = xs \\<and> lfinite xs) \\<or>\n    (\\<exists>xs ys x zs.\n        lmap f xs = LCons x xs \\<and>\n        lmap f ys = prepend zs (LCons x ys) \\<and>\n        ((\\<exists>xsa ysa.\n             xs = lmap f xsa \\<and>\n             ys = lmap f ysa \\<and> emb xsa ysa) \\<or>\n         emb xs ys))\n 2. \\<And>x21 x22.\n       xs = LCons x21 x22 \\<Longrightarrow>\n       (\\<exists>xs.\n           lmap f xs = LNil \\<and> lmap f ys = xs \\<and> lfinite xs) \\<or>\n       (\\<exists>xs ys x zs.\n           lmap f xs = LCons x xs \\<and>\n           lmap f ys = prepend zs (LCons x ys) \\<and>\n           ((\\<exists>xsa ysa.\n                xs = lmap f xsa \\<and>\n                ys = lmap f ysa \\<and> emb xsa ysa) \\<or>\n            emb xs ys))", "ultimately"], ["proof (chain)\npicking this:\n  lmap f xs = LCons (f x) (lmap f xs')\n  lmap f ys = prepend (map f zs0) (LCons (f x) (lmap f ysa0))\n  \\<exists>xsa ysa.\n     lmap f xs' = lmap f xsa \\<and>\n     lmap f ysa0 = lmap f ysa \\<and> emb xsa ysa", "show ?thesis"], ["proof (prove)\nusing this:\n  lmap f xs = LCons (f x) (lmap f xs')\n  lmap f ys = prepend (map f zs0) (LCons (f x) (lmap f ysa0))\n  \\<exists>xsa ysa.\n     lmap f xs' = lmap f xsa \\<and>\n     lmap f ysa0 = lmap f ysa \\<and> emb xsa ysa\n\ngoal (1 subgoal):\n 1. (\\<exists>xs.\n        lmap f xs = LNil \\<and> lmap f ys = xs \\<and> lfinite xs) \\<or>\n    (\\<exists>xs ys x zs.\n        lmap f xs = LCons x xs \\<and>\n        lmap f ys = prepend zs (LCons x ys) \\<and>\n        ((\\<exists>xsa ysa.\n             xs = lmap f xsa \\<and>\n             ys = lmap f ysa \\<and> emb xsa ysa) \\<or>\n         emb xs ys))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>xs.\n      lmap f xs = LNil \\<and> lmap f ys = xs \\<and> lfinite xs) \\<or>\n  (\\<exists>xs ys x zs.\n      lmap f xs = LCons x xs \\<and>\n      lmap f ys = prepend zs (LCons x ys) \\<and>\n      ((\\<exists>xsa ysa.\n           xs = lmap f xsa \\<and> ys = lmap f ysa \\<and> emb xsa ysa) \\<or>\n       emb xs ys))\n\ngoal (1 subgoal):\n 1. xs = LNil \\<Longrightarrow>\n    (\\<exists>xs.\n        lmap f xs = LNil \\<and> lmap f ys = xs \\<and> lfinite xs) \\<or>\n    (\\<exists>xs ys x zs.\n        lmap f xs = LCons x xs \\<and>\n        lmap f ys = prepend zs (LCons x ys) \\<and>\n        ((\\<exists>xsa ysa.\n             xs = lmap f xsa \\<and>\n             ys = lmap f ysa \\<and> emb xsa ysa) \\<or>\n         emb xs ys))", "qed (simp add: emb_lfinite[OF emb])"], ["proof (state)\nthis:\n  (\\<exists>xs.\n      lmap f xs = LNil \\<and> lmap f ys = xs \\<and> lfinite xs) \\<or>\n  (\\<exists>xs ys x zs.\n      lmap f xs = LCons x xs \\<and>\n      lmap f ys = prepend zs (LCons x ys) \\<and>\n      ((\\<exists>xsa ysa.\n           xs = lmap f xsa \\<and> ys = lmap f ysa \\<and> emb xsa ysa) \\<or>\n       emb xs ys))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma chain_inf_llist_if_infinite_chain_function:\n  assumes \"\\<forall>i. r (f (Suc i)) (f i)\"\n  shows \"\\<not> lfinite (inf_llist f) \\<and> chain r\\<inverse>\\<inverse> (inf_llist f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lfinite (inf_llist f) \\<and>\n    chain r\\<inverse>\\<inverse> (inf_llist f)", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>i. r (f (Suc i)) (f i)\n\ngoal (1 subgoal):\n 1. \\<not> lfinite (inf_llist f) \\<and>\n    chain r\\<inverse>\\<inverse> (inf_llist f)", "by (simp add: lnth_rel_chain)"], ["", "lemma infinite_chain_function_iff_infinite_chain_llist:\n  \"(\\<exists>f. \\<forall>i. r (f (Suc i)) (f i)) \\<longleftrightarrow> (\\<exists>c. \\<not> lfinite c \\<and> chain r\\<inverse>\\<inverse> c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>f. \\<forall>i. r (f (Suc i)) (f i)) =\n    (\\<exists>c. \\<not> lfinite c \\<and> chain r\\<inverse>\\<inverse> c)", "using chain_inf_llist_if_infinite_chain_function infinite_chain_lnth_rel"], ["proof (prove)\nusing this:\n  \\<forall>i. ?r (?f (Suc i)) (?f i) \\<Longrightarrow>\n  \\<not> lfinite (inf_llist ?f) \\<and>\n  chain ?r\\<inverse>\\<inverse> (inf_llist ?f)\n  \\<lbrakk>\\<not> lfinite ?c; chain ?r ?c\\<rbrakk>\n  \\<Longrightarrow> ?r (lnth ?c ?i) (lnth ?c (Suc ?i))\n\ngoal (1 subgoal):\n 1. (\\<exists>f. \\<forall>i. r (f (Suc i)) (f i)) =\n    (\\<exists>c. \\<not> lfinite c \\<and> chain r\\<inverse>\\<inverse> c)", "by blast"], ["", "lemma wfP_iff_no_infinite_down_chain_llist: \"wfP r \\<longleftrightarrow> (\\<nexists>c. \\<not> lfinite c \\<and> chain r\\<inverse>\\<inverse> c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfP r =\n    (\\<nexists>c. \\<not> lfinite c \\<and> chain r\\<inverse>\\<inverse> c)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wfP r =\n    (\\<nexists>c. \\<not> lfinite c \\<and> chain r\\<inverse>\\<inverse> c)", "have \"wfP r \\<longleftrightarrow>  wf {(x, y). r x y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfP r = wf {(x, y). r x y}", "unfolding wfP_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf {(x, y). r x y} = wf {(x, y). r x y}", "by auto"], ["proof (state)\nthis:\n  wfP r = wf {(x, y). r x y}\n\ngoal (1 subgoal):\n 1. wfP r =\n    (\\<nexists>c. \\<not> lfinite c \\<and> chain r\\<inverse>\\<inverse> c)", "also"], ["proof (state)\nthis:\n  wfP r = wf {(x, y). r x y}\n\ngoal (1 subgoal):\n 1. wfP r =\n    (\\<nexists>c. \\<not> lfinite c \\<and> chain r\\<inverse>\\<inverse> c)", "have \"\\<dots> \\<longleftrightarrow> (\\<nexists>f. \\<forall>i. (f (Suc i), f i) \\<in> {(x, y). r x y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf {(x, y). r x y} =\n    (\\<nexists>f. \\<forall>i. (f (Suc i), f i) \\<in> {(x, y). r x y})", "using wf_iff_no_infinite_down_chain"], ["proof (prove)\nusing this:\n  wf ?r = (\\<nexists>f. \\<forall>i. (f (Suc i), f i) \\<in> ?r)\n\ngoal (1 subgoal):\n 1. wf {(x, y). r x y} =\n    (\\<nexists>f. \\<forall>i. (f (Suc i), f i) \\<in> {(x, y). r x y})", "by blast"], ["proof (state)\nthis:\n  wf {(x, y). r x y} =\n  (\\<nexists>f. \\<forall>i. (f (Suc i), f i) \\<in> {(x, y). r x y})\n\ngoal (1 subgoal):\n 1. wfP r =\n    (\\<nexists>c. \\<not> lfinite c \\<and> chain r\\<inverse>\\<inverse> c)", "also"], ["proof (state)\nthis:\n  wf {(x, y). r x y} =\n  (\\<nexists>f. \\<forall>i. (f (Suc i), f i) \\<in> {(x, y). r x y})\n\ngoal (1 subgoal):\n 1. wfP r =\n    (\\<nexists>c. \\<not> lfinite c \\<and> chain r\\<inverse>\\<inverse> c)", "have \"\\<dots> \\<longleftrightarrow> (\\<nexists>f. \\<forall>i. r (f (Suc i)) (f i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nexists>f. \\<forall>i. (f (Suc i), f i) \\<in> {(x, y). r x y}) =\n    (\\<nexists>f. \\<forall>i. r (f (Suc i)) (f i))", "by auto"], ["proof (state)\nthis:\n  (\\<nexists>f. \\<forall>i. (f (Suc i), f i) \\<in> {(x, y). r x y}) =\n  (\\<nexists>f. \\<forall>i. r (f (Suc i)) (f i))\n\ngoal (1 subgoal):\n 1. wfP r =\n    (\\<nexists>c. \\<not> lfinite c \\<and> chain r\\<inverse>\\<inverse> c)", "also"], ["proof (state)\nthis:\n  (\\<nexists>f. \\<forall>i. (f (Suc i), f i) \\<in> {(x, y). r x y}) =\n  (\\<nexists>f. \\<forall>i. r (f (Suc i)) (f i))\n\ngoal (1 subgoal):\n 1. wfP r =\n    (\\<nexists>c. \\<not> lfinite c \\<and> chain r\\<inverse>\\<inverse> c)", "have \"\\<dots> \\<longleftrightarrow> (\\<nexists>c. \\<not>lfinite c \\<and> chain r\\<inverse>\\<inverse> c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nexists>f. \\<forall>i. r (f (Suc i)) (f i)) =\n    (\\<nexists>c. \\<not> lfinite c \\<and> chain r\\<inverse>\\<inverse> c)", "using infinite_chain_function_iff_infinite_chain_llist"], ["proof (prove)\nusing this:\n  (\\<exists>f. \\<forall>i. ?r (f (Suc i)) (f i)) =\n  (\\<exists>c. \\<not> lfinite c \\<and> chain ?r\\<inverse>\\<inverse> c)\n\ngoal (1 subgoal):\n 1. (\\<nexists>f. \\<forall>i. r (f (Suc i)) (f i)) =\n    (\\<nexists>c. \\<not> lfinite c \\<and> chain r\\<inverse>\\<inverse> c)", "by blast"], ["proof (state)\nthis:\n  (\\<nexists>f. \\<forall>i. r (f (Suc i)) (f i)) =\n  (\\<nexists>c. \\<not> lfinite c \\<and> chain r\\<inverse>\\<inverse> c)\n\ngoal (1 subgoal):\n 1. wfP r =\n    (\\<nexists>c. \\<not> lfinite c \\<and> chain r\\<inverse>\\<inverse> c)", "finally"], ["proof (chain)\npicking this:\n  wfP r =\n  (\\<nexists>c. \\<not> lfinite c \\<and> chain r\\<inverse>\\<inverse> c)", "show ?thesis"], ["proof (prove)\nusing this:\n  wfP r =\n  (\\<nexists>c. \\<not> lfinite c \\<and> chain r\\<inverse>\\<inverse> c)\n\ngoal (1 subgoal):\n 1. wfP r =\n    (\\<nexists>c. \\<not> lfinite c \\<and> chain r\\<inverse>\\<inverse> c)", "by auto"], ["proof (state)\nthis:\n  wfP r =\n  (\\<nexists>c. \\<not> lfinite c \\<and> chain r\\<inverse>\\<inverse> c)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Full Chains\\<close>"], ["", "coinductive full_chain :: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> 'a llist \\<Rightarrow> bool\" for R :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" where\n  full_chain_singleton: \"(\\<forall>y. \\<not> R x y) \\<Longrightarrow> full_chain R (LCons x LNil)\"\n| full_chain_cons: \"full_chain R xs \\<Longrightarrow> R x (lhd xs) \\<Longrightarrow> full_chain R (LCons x xs)\""], ["", "lemma\n  full_chain_LNil[simp]: \"\\<not> full_chain R LNil\" and\n  full_chain_not_lnull: \"full_chain R xs \\<Longrightarrow> \\<not> lnull xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> full_chain R LNil &&&\n    (full_chain R xs \\<Longrightarrow> \\<not> lnull xs)", "by (auto elim: full_chain.cases)"], ["", "lemma full_chain_ldropn:\n  assumes full: \"full_chain R xs\" and \"enat n < llength xs\"\n  shows \"full_chain R (ldropn n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. full_chain R (ldropn n xs)", "using assms"], ["proof (prove)\nusing this:\n  full_chain R xs\n  enat n < llength xs\n\ngoal (1 subgoal):\n 1. full_chain R (ldropn n xs)", "by (induct n arbitrary: xs, simp,\n      metis full_chain.cases ldrop_eSuc_ltl ldropn_LNil ldropn_eq_LNil ltl_simps(2) not_less)"], ["", "lemma full_chain_iff_chain:\n  \"full_chain R xs \\<longleftrightarrow> chain R xs \\<and> (lfinite xs \\<longrightarrow> (\\<forall>y. \\<not> R (llast xs) y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. full_chain R xs =\n    (chain R xs \\<and>\n     (lfinite xs \\<longrightarrow> (\\<forall>y. \\<not> R (llast xs) y)))", "proof (intro iffI conjI impI allI; (elim conjE)?)"], ["proof (state)\ngoal (3 subgoals):\n 1. full_chain R xs \\<Longrightarrow> chain R xs\n 2. \\<And>y.\n       \\<lbrakk>full_chain R xs; lfinite xs\\<rbrakk>\n       \\<Longrightarrow> \\<not> R (llast xs) y\n 3. \\<lbrakk>chain R xs;\n     lfinite xs \\<longrightarrow>\n     (\\<forall>y. \\<not> R (llast xs) y)\\<rbrakk>\n    \\<Longrightarrow> full_chain R xs", "assume full: \"full_chain R xs\""], ["proof (state)\nthis:\n  full_chain R xs\n\ngoal (3 subgoals):\n 1. full_chain R xs \\<Longrightarrow> chain R xs\n 2. \\<And>y.\n       \\<lbrakk>full_chain R xs; lfinite xs\\<rbrakk>\n       \\<Longrightarrow> \\<not> R (llast xs) y\n 3. \\<lbrakk>chain R xs;\n     lfinite xs \\<longrightarrow>\n     (\\<forall>y. \\<not> R (llast xs) y)\\<rbrakk>\n    \\<Longrightarrow> full_chain R xs", "show chain: \"chain R xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain R xs", "using full"], ["proof (prove)\nusing this:\n  full_chain R xs\n\ngoal (1 subgoal):\n 1. chain R xs", "by (coinduction arbitrary: xs) (auto elim: full_chain.cases)"], ["proof (state)\nthis:\n  chain R xs\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>full_chain R xs; lfinite xs\\<rbrakk>\n       \\<Longrightarrow> \\<not> R (llast xs) y\n 2. \\<lbrakk>chain R xs;\n     lfinite xs \\<longrightarrow>\n     (\\<forall>y. \\<not> R (llast xs) y)\\<rbrakk>\n    \\<Longrightarrow> full_chain R xs", "{"], ["proof (state)\nthis:\n  chain R xs\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>full_chain R xs; lfinite xs\\<rbrakk>\n       \\<Longrightarrow> \\<not> R (llast xs) y\n 2. \\<lbrakk>chain R xs;\n     lfinite xs \\<longrightarrow>\n     (\\<forall>y. \\<not> R (llast xs) y)\\<rbrakk>\n    \\<Longrightarrow> full_chain R xs", "fix y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>full_chain R xs; lfinite xs\\<rbrakk>\n       \\<Longrightarrow> \\<not> R (llast xs) y\n 2. \\<lbrakk>chain R xs;\n     lfinite xs \\<longrightarrow>\n     (\\<forall>y. \\<not> R (llast xs) y)\\<rbrakk>\n    \\<Longrightarrow> full_chain R xs", "assume \"lfinite xs\""], ["proof (state)\nthis:\n  lfinite xs\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>full_chain R xs; lfinite xs\\<rbrakk>\n       \\<Longrightarrow> \\<not> R (llast xs) y\n 2. \\<lbrakk>chain R xs;\n     lfinite xs \\<longrightarrow>\n     (\\<forall>y. \\<not> R (llast xs) y)\\<rbrakk>\n    \\<Longrightarrow> full_chain R xs", "then"], ["proof (chain)\npicking this:\n  lfinite xs", "obtain n where\n      suc_n: \"Suc n = llength xs\""], ["proof (prove)\nusing this:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        enat (Suc n) = llength xs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis chain chain_length_pos lessE less_enatE lfinite_conv_llength_enat)"], ["proof (state)\nthis:\n  enat (Suc n) = llength xs\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>full_chain R xs; lfinite xs\\<rbrakk>\n       \\<Longrightarrow> \\<not> R (llast xs) y\n 2. \\<lbrakk>chain R xs;\n     lfinite xs \\<longrightarrow>\n     (\\<forall>y. \\<not> R (llast xs) y)\\<rbrakk>\n    \\<Longrightarrow> full_chain R xs", "have \"full_chain R (ldropn n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. full_chain R (ldropn n xs)", "by (rule full_chain_ldropn[OF full]) (use suc_n Suc_ile_eq in force)"], ["proof (state)\nthis:\n  full_chain R (ldropn n xs)\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>full_chain R xs; lfinite xs\\<rbrakk>\n       \\<Longrightarrow> \\<not> R (llast xs) y\n 2. \\<lbrakk>chain R xs;\n     lfinite xs \\<longrightarrow>\n     (\\<forall>y. \\<not> R (llast xs) y)\\<rbrakk>\n    \\<Longrightarrow> full_chain R xs", "moreover"], ["proof (state)\nthis:\n  full_chain R (ldropn n xs)\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>full_chain R xs; lfinite xs\\<rbrakk>\n       \\<Longrightarrow> \\<not> R (llast xs) y\n 2. \\<lbrakk>chain R xs;\n     lfinite xs \\<longrightarrow>\n     (\\<forall>y. \\<not> R (llast xs) y)\\<rbrakk>\n    \\<Longrightarrow> full_chain R xs", "have \"ldropn n xs = LCons (llast xs) LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldropn n xs = LCons (llast xs) LNil", "using suc_n"], ["proof (prove)\nusing this:\n  enat (Suc n) = llength xs\n\ngoal (1 subgoal):\n 1. ldropn n xs = LCons (llast xs) LNil", "by (metis enat_le_plus_same(2) enat_ord_simps(2) gen_llength_def\n          ldropn_Suc_conv_ldropn ldropn_all lessI llast_ldropn llast_singleton llength_code)"], ["proof (state)\nthis:\n  ldropn n xs = LCons (llast xs) LNil\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>full_chain R xs; lfinite xs\\<rbrakk>\n       \\<Longrightarrow> \\<not> R (llast xs) y\n 2. \\<lbrakk>chain R xs;\n     lfinite xs \\<longrightarrow>\n     (\\<forall>y. \\<not> R (llast xs) y)\\<rbrakk>\n    \\<Longrightarrow> full_chain R xs", "ultimately"], ["proof (chain)\npicking this:\n  full_chain R (ldropn n xs)\n  ldropn n xs = LCons (llast xs) LNil", "show \"\\<not> R (llast xs) y\""], ["proof (prove)\nusing this:\n  full_chain R (ldropn n xs)\n  ldropn n xs = LCons (llast xs) LNil\n\ngoal (1 subgoal):\n 1. \\<not> R (llast xs) y", "by (auto elim: full_chain.cases)"], ["proof (state)\nthis:\n  \\<not> R (llast xs) y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>chain R xs;\n     lfinite xs \\<longrightarrow>\n     (\\<forall>y. \\<not> R (llast xs) y)\\<rbrakk>\n    \\<Longrightarrow> full_chain R xs", "}"], ["proof (state)\nthis:\n  lfinite xs \\<Longrightarrow> \\<not> R (llast xs) ?y2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>chain R xs;\n     lfinite xs \\<longrightarrow>\n     (\\<forall>y. \\<not> R (llast xs) y)\\<rbrakk>\n    \\<Longrightarrow> full_chain R xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>chain R xs;\n     lfinite xs \\<longrightarrow>\n     (\\<forall>y. \\<not> R (llast xs) y)\\<rbrakk>\n    \\<Longrightarrow> full_chain R xs", "assume\n    \"chain R xs\" and\n    \"lfinite xs \\<longrightarrow> (\\<forall>y. \\<not> R (llast xs) y)\""], ["proof (state)\nthis:\n  chain R xs\n  lfinite xs \\<longrightarrow> (\\<forall>y. \\<not> R (llast xs) y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>chain R xs;\n     lfinite xs \\<longrightarrow>\n     (\\<forall>y. \\<not> R (llast xs) y)\\<rbrakk>\n    \\<Longrightarrow> full_chain R xs", "then"], ["proof (chain)\npicking this:\n  chain R xs\n  lfinite xs \\<longrightarrow> (\\<forall>y. \\<not> R (llast xs) y)", "show \"full_chain R xs\""], ["proof (prove)\nusing this:\n  chain R xs\n  lfinite xs \\<longrightarrow> (\\<forall>y. \\<not> R (llast xs) y)\n\ngoal (1 subgoal):\n 1. full_chain R xs", "by (coinduction arbitrary: xs) (erule chain.cases, simp, metis lfinite_LConsI llast_LCons)"], ["proof (state)\nthis:\n  full_chain R xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma full_chain_imp_chain: \"full_chain R xs \\<Longrightarrow> chain R xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. full_chain R xs \\<Longrightarrow> chain R xs", "using full_chain_iff_chain"], ["proof (prove)\nusing this:\n  full_chain ?R ?xs =\n  (chain ?R ?xs \\<and>\n   (lfinite ?xs \\<longrightarrow> (\\<forall>y. \\<not> ?R (llast ?xs) y)))\n\ngoal (1 subgoal):\n 1. full_chain R xs \\<Longrightarrow> chain R xs", "by blast"], ["", "lemma full_chain_length_pos: \"full_chain R xs \\<Longrightarrow> llength xs > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. full_chain R xs \\<Longrightarrow> 0 < llength xs", "by (fact chain_length_pos[OF full_chain_imp_chain])"], ["", "lemma full_chain_lnth_rel:\n  \"full_chain R xs \\<Longrightarrow> enat (Suc j) < llength xs \\<Longrightarrow> R (lnth xs j) (lnth xs (Suc j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>full_chain R xs; enat (Suc j) < llength xs\\<rbrakk>\n    \\<Longrightarrow> R (lnth xs j) (lnth xs (Suc j))", "by (fact chain_lnth_rel[OF full_chain_imp_chain])"], ["", "inductive_cases full_chain_consE: \"full_chain R (LCons x xs)\""], ["", "inductive_cases full_chain_nontrivE: \"full_chain R (LCons x (LCons y xs))\""], ["", "lemma full_chain_tranclp_imp_exists_full_chain:\n  assumes full: \"full_chain R\\<^sup>+\\<^sup>+ xs\"\n  shows \"\\<exists>ys. full_chain R ys \\<and> emb xs ys \\<and> lhd ys = lhd xs \\<and> llast ys = llast xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ys.\n       full_chain R ys \\<and>\n       emb xs ys \\<and> lhd ys = lhd xs \\<and> llast ys = llast xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ys.\n       full_chain R ys \\<and>\n       emb xs ys \\<and> lhd ys = lhd xs \\<and> llast ys = llast xs", "obtain ys where ys:\n    \"chain R ys\" \"emb xs ys\" \"lhd ys = lhd xs\" \"llast ys = llast xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ys.\n        \\<lbrakk>chain R ys; emb xs ys; lhd ys = lhd xs;\n         llast ys = llast xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using full_chain_imp_chain[OF full] chain_tranclp_imp_exists_chain"], ["proof (prove)\nusing this:\n  chain R\\<^sup>+\\<^sup>+ xs\n  chain ?R\\<^sup>+\\<^sup>+ ?xs \\<Longrightarrow>\n  \\<exists>ys.\n     chain ?R ys \\<and>\n     emb ?xs ys \\<and> lhd ys = lhd ?xs \\<and> llast ys = llast ?xs\n\ngoal (1 subgoal):\n 1. (\\<And>ys.\n        \\<lbrakk>chain R ys; emb xs ys; lhd ys = lhd xs;\n         llast ys = llast xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  chain R ys\n  emb xs ys\n  lhd ys = lhd xs\n  llast ys = llast xs\n\ngoal (1 subgoal):\n 1. \\<exists>ys.\n       full_chain R ys \\<and>\n       emb xs ys \\<and> lhd ys = lhd xs \\<and> llast ys = llast xs", "have \"full_chain R ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. full_chain R ys", "using ys(1,4) emb_lfinite[OF ys(2)] full"], ["proof (prove)\nusing this:\n  chain R ys\n  llast ys = llast xs\n  lfinite ys = lfinite xs\n  full_chain R\\<^sup>+\\<^sup>+ xs\n\ngoal (1 subgoal):\n 1. full_chain R ys", "unfolding full_chain_iff_chain"], ["proof (prove)\nusing this:\n  chain R ys\n  llast ys = llast xs\n  lfinite ys = lfinite xs\n  chain R\\<^sup>+\\<^sup>+ xs \\<and>\n  (lfinite xs \\<longrightarrow>\n   (\\<forall>y. \\<not> R\\<^sup>+\\<^sup>+ (llast xs) y))\n\ngoal (1 subgoal):\n 1. chain R ys \\<and>\n    (lfinite ys \\<longrightarrow> (\\<forall>y. \\<not> R (llast ys) y))", "by auto"], ["proof (state)\nthis:\n  full_chain R ys\n\ngoal (1 subgoal):\n 1. \\<exists>ys.\n       full_chain R ys \\<and>\n       emb xs ys \\<and> lhd ys = lhd xs \\<and> llast ys = llast xs", "then"], ["proof (chain)\npicking this:\n  full_chain R ys", "show ?thesis"], ["proof (prove)\nusing this:\n  full_chain R ys\n\ngoal (1 subgoal):\n 1. \\<exists>ys.\n       full_chain R ys \\<and>\n       emb xs ys \\<and> lhd ys = lhd xs \\<and> llast ys = llast xs", "using ys(2-4)"], ["proof (prove)\nusing this:\n  full_chain R ys\n  emb xs ys\n  lhd ys = lhd xs\n  llast ys = llast xs\n\ngoal (1 subgoal):\n 1. \\<exists>ys.\n       full_chain R ys \\<and>\n       emb xs ys \\<and> lhd ys = lhd xs \\<and> llast ys = llast xs", "by auto"], ["proof (state)\nthis:\n  \\<exists>ys.\n     full_chain R ys \\<and>\n     emb xs ys \\<and> lhd ys = lhd xs \\<and> llast ys = llast xs\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}