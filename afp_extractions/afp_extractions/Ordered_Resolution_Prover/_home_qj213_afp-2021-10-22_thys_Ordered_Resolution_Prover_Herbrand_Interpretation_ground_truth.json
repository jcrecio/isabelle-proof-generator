{"file_name": "/home/qj213/afp-2021-10-22/thys/Ordered_Resolution_Prover/Herbrand_Interpretation.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Ordered_Resolution_Prover", "problem_names": ["lemma true_lit_simps[simp]:\n  \"I \\<Turnstile>l Pos A \\<longleftrightarrow> A \\<in> I\"\n  \"I \\<Turnstile>l Neg A \\<longleftrightarrow> A \\<notin> I\"", "lemma true_lit_iff[iff]: \"I \\<Turnstile>l L \\<longleftrightarrow> (\\<exists>A. L = Pos A \\<and> A \\<in> I \\<or> L = Neg A \\<and> A \\<notin> I)\"", "lemma true_cls_empty[iff]: \"\\<not> I \\<Turnstile> {#}\"", "lemma true_cls_singleton[iff]: \"I \\<Turnstile> {#L#} \\<longleftrightarrow> I \\<Turnstile>l L\"", "lemma true_cls_add_mset[iff]: \"I \\<Turnstile> add_mset C D \\<longleftrightarrow> I \\<Turnstile>l C \\<or> I \\<Turnstile> D\"", "lemma true_cls_union[iff]: \"I \\<Turnstile> C + D \\<longleftrightarrow> I \\<Turnstile> C \\<or> I \\<Turnstile> D\"", "lemma true_cls_mono: \"set_mset C \\<subseteq> set_mset D \\<Longrightarrow> I \\<Turnstile> C \\<Longrightarrow> I \\<Turnstile> D\"", "lemma\n  assumes \"I \\<subseteq> J\"\n  shows\n    false_to_true_imp_ex_pos: \"\\<not> I \\<Turnstile> C \\<Longrightarrow> J \\<Turnstile> C \\<Longrightarrow> \\<exists>A \\<in> J. Pos A \\<in># C\" and\n    true_to_false_imp_ex_neg: \"I \\<Turnstile> C \\<Longrightarrow> \\<not> J \\<Turnstile> C \\<Longrightarrow> \\<exists>A \\<in> J. Neg A \\<in># C\"", "lemma true_cls_replicate_mset[iff]: \"I \\<Turnstile> replicate_mset n L \\<longleftrightarrow> n \\<noteq> 0 \\<and> I \\<Turnstile>l L\"", "lemma pos_literal_in_imp_true_cls[intro]: \"Pos A \\<in># C \\<Longrightarrow> A \\<in> I \\<Longrightarrow> I \\<Turnstile> C\"", "lemma neg_literal_notin_imp_true_cls[intro]: \"Neg A \\<in># C \\<Longrightarrow> A \\<notin> I \\<Longrightarrow> I \\<Turnstile> C\"", "lemma pos_neg_in_imp_true: \"Pos A \\<in># C \\<Longrightarrow> Neg A \\<in># C \\<Longrightarrow> I \\<Turnstile> C\"", "lemma true_clss_empty[iff]: \"I \\<Turnstile>s {}\"", "lemma true_clss_singleton[iff]: \"I \\<Turnstile>s {C} \\<longleftrightarrow> I \\<Turnstile> C\"", "lemma true_clss_insert[iff]: \"I \\<Turnstile>s insert C DD \\<longleftrightarrow> I \\<Turnstile> C \\<and> I \\<Turnstile>s DD\"", "lemma true_clss_union[iff]: \"I \\<Turnstile>s CC \\<union> DD \\<longleftrightarrow> I \\<Turnstile>s CC \\<and> I \\<Turnstile>s DD\"", "lemma true_clss_Union[iff]: \"I \\<Turnstile>s \\<Union> CCC \\<longleftrightarrow> (\\<forall>CC \\<in> CCC. I \\<Turnstile>s CC)\"", "lemma true_clss_mono: \"DD \\<subseteq> CC \\<Longrightarrow> I \\<Turnstile>s CC \\<Longrightarrow> I \\<Turnstile>s DD\"", "lemma true_clss_mono_strong: \"(\\<forall>D \\<in> DD. \\<exists>C \\<in> CC. C \\<subseteq># D) \\<Longrightarrow> I \\<Turnstile>s CC \\<Longrightarrow> I \\<Turnstile>s DD\"", "lemma true_clss_subclause: \"C \\<subseteq># D \\<Longrightarrow> I \\<Turnstile>s {C} \\<Longrightarrow> I \\<Turnstile>s {D}\"", "lemma satisfiable_antimono: \"CC \\<subseteq> DD \\<Longrightarrow> satisfiable DD \\<Longrightarrow> satisfiable CC\"", "lemma unsatisfiable_mono: \"CC \\<subseteq> DD \\<Longrightarrow> \\<not> satisfiable CC \\<Longrightarrow> \\<not> satisfiable DD\"", "lemma true_cls_mset_empty[iff]: \"I \\<Turnstile>m {#}\"", "lemma true_cls_mset_singleton[iff]: \"I \\<Turnstile>m {#C#} \\<longleftrightarrow> I \\<Turnstile> C\"", "lemma true_cls_mset_union[iff]: \"I \\<Turnstile>m CC + DD \\<longleftrightarrow> I \\<Turnstile>m CC \\<and> I \\<Turnstile>m DD\"", "lemma true_cls_mset_Union[iff]: \"I \\<Turnstile>m \\<Sum>\\<^sub># CCC \\<longleftrightarrow> (\\<forall>CC \\<in># CCC. I \\<Turnstile>m CC)\"", "lemma true_cls_mset_add_mset[iff]: \"I \\<Turnstile>m add_mset C CC \\<longleftrightarrow> I \\<Turnstile> C \\<and> I \\<Turnstile>m CC\"", "lemma true_cls_mset_image_mset[iff]: \"I \\<Turnstile>m image_mset f A \\<longleftrightarrow> (\\<forall>x \\<in># A. I \\<Turnstile> f x)\"", "lemma true_cls_mset_mono: \"set_mset DD \\<subseteq> set_mset CC \\<Longrightarrow> I \\<Turnstile>m CC \\<Longrightarrow> I \\<Turnstile>m DD\"", "lemma true_cls_mset_mono_strong: \"(\\<forall>D \\<in># DD. \\<exists>C \\<in># CC. C \\<subseteq># D) \\<Longrightarrow> I \\<Turnstile>m CC \\<Longrightarrow> I \\<Turnstile>m DD\"", "lemma true_clss_set_mset[iff]: \"I \\<Turnstile>s set_mset CC \\<longleftrightarrow> I \\<Turnstile>m CC\"", "lemma true_clss_mset_set[simp]: \"finite CC \\<Longrightarrow> I \\<Turnstile>m mset_set CC \\<longleftrightarrow> I \\<Turnstile>s CC\"", "lemma true_cls_mset_true_cls: \"I \\<Turnstile>m CC \\<Longrightarrow> C \\<in># CC \\<Longrightarrow> I \\<Turnstile> C\""], "translations": [["", "lemma true_lit_simps[simp]:\n  \"I \\<Turnstile>l Pos A \\<longleftrightarrow> A \\<in> I\"\n  \"I \\<Turnstile>l Neg A \\<longleftrightarrow> A \\<notin> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (I \\<Turnstile>l Pos A) = (A \\<in> I) &&&\n    (I \\<Turnstile>l Neg A) = (A \\<notin> I)", "unfolding true_lit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if is_pos (Pos A) then \\<lambda>P. P else Not)\n     (atm_of (Pos A) \\<in> I) =\n    (A \\<in> I) &&&\n    (if is_pos (Neg A) then \\<lambda>P. P else Not)\n     (atm_of (Neg A) \\<in> I) =\n    (A \\<notin> I)", "by auto"], ["", "lemma true_lit_iff[iff]: \"I \\<Turnstile>l L \\<longleftrightarrow> (\\<exists>A. L = Pos A \\<and> A \\<in> I \\<or> L = Neg A \\<and> A \\<notin> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (I \\<Turnstile>l L) =\n    (\\<exists>A.\n        L = Pos A \\<and> A \\<in> I \\<or> L = Neg A \\<and> A \\<notin> I)", "by (cases L) simp+"], ["", "definition true_cls :: \"'a interp \\<Rightarrow> 'a clause \\<Rightarrow> bool\" (infix \"\\<Turnstile>\" 50) where\n  \"I \\<Turnstile> C \\<longleftrightarrow> (\\<exists>L \\<in># C. I \\<Turnstile>l L)\""], ["", "lemma true_cls_empty[iff]: \"\\<not> I \\<Turnstile> {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> I \\<Turnstile> {#}", "unfolding true_cls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> Multiset.Bex {#} ((\\<Turnstile>l) I)", "by simp"], ["", "lemma true_cls_singleton[iff]: \"I \\<Turnstile> {#L#} \\<longleftrightarrow> I \\<Turnstile>l L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (I \\<Turnstile> {#L#}) = (I \\<Turnstile>l L)", "unfolding true_cls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Multiset.Bex {#L#} ((\\<Turnstile>l) I) = (I \\<Turnstile>l L)", "by simp"], ["", "lemma true_cls_add_mset[iff]: \"I \\<Turnstile> add_mset C D \\<longleftrightarrow> I \\<Turnstile>l C \\<or> I \\<Turnstile> D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (I \\<Turnstile> add_mset C D) =\n    (I \\<Turnstile>l C \\<or> I \\<Turnstile> D)", "unfolding true_cls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Multiset.Bex (add_mset C D) ((\\<Turnstile>l) I) =\n    (I \\<Turnstile>l C \\<or> Multiset.Bex D ((\\<Turnstile>l) I))", "by auto"], ["", "lemma true_cls_union[iff]: \"I \\<Turnstile> C + D \\<longleftrightarrow> I \\<Turnstile> C \\<or> I \\<Turnstile> D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (I \\<Turnstile> C + D) = (I \\<Turnstile> C \\<or> I \\<Turnstile> D)", "unfolding true_cls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Multiset.Bex (C + D) ((\\<Turnstile>l) I) =\n    (Multiset.Bex C ((\\<Turnstile>l) I) \\<or>\n     Multiset.Bex D ((\\<Turnstile>l) I))", "by auto"], ["", "lemma true_cls_mono: \"set_mset C \\<subseteq> set_mset D \\<Longrightarrow> I \\<Turnstile> C \\<Longrightarrow> I \\<Turnstile> D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set_mset C \\<subseteq> set_mset D; I \\<Turnstile> C\\<rbrakk>\n    \\<Longrightarrow> I \\<Turnstile> D", "unfolding true_cls_def subset_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>#C. x \\<in># D;\n     Multiset.Bex C ((\\<Turnstile>l) I)\\<rbrakk>\n    \\<Longrightarrow> Multiset.Bex D ((\\<Turnstile>l) I)", "by metis"], ["", "lemma\n  assumes \"I \\<subseteq> J\"\n  shows\n    false_to_true_imp_ex_pos: \"\\<not> I \\<Turnstile> C \\<Longrightarrow> J \\<Turnstile> C \\<Longrightarrow> \\<exists>A \\<in> J. Pos A \\<in># C\" and\n    true_to_false_imp_ex_neg: \"I \\<Turnstile> C \\<Longrightarrow> \\<not> J \\<Turnstile> C \\<Longrightarrow> \\<exists>A \\<in> J. Neg A \\<in># C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>\\<not> I \\<Turnstile> C; J \\<Turnstile> C\\<rbrakk>\n     \\<Longrightarrow> \\<exists>A\\<in>J. Pos A \\<in># C) &&&\n    (\\<lbrakk>I \\<Turnstile> C; \\<not> J \\<Turnstile> C\\<rbrakk>\n     \\<Longrightarrow> \\<exists>A\\<in>J. Neg A \\<in># C)", "using assms"], ["proof (prove)\nusing this:\n  I \\<subseteq> J\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>\\<not> I \\<Turnstile> C; J \\<Turnstile> C\\<rbrakk>\n     \\<Longrightarrow> \\<exists>A\\<in>J. Pos A \\<in># C) &&&\n    (\\<lbrakk>I \\<Turnstile> C; \\<not> J \\<Turnstile> C\\<rbrakk>\n     \\<Longrightarrow> \\<exists>A\\<in>J. Neg A \\<in># C)", "unfolding subset_iff true_cls_def"], ["proof (prove)\nusing this:\n  \\<forall>t. t \\<in> I \\<longrightarrow> t \\<in> J\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>\\<not> Multiset.Bex C ((\\<Turnstile>l) I);\n      Multiset.Bex C ((\\<Turnstile>l) J)\\<rbrakk>\n     \\<Longrightarrow> \\<exists>A\\<in>J. Pos A \\<in># C) &&&\n    (\\<lbrakk>Multiset.Bex C ((\\<Turnstile>l) I);\n      \\<not> Multiset.Bex C ((\\<Turnstile>l) J)\\<rbrakk>\n     \\<Longrightarrow> \\<exists>A\\<in>J. Neg A \\<in># C)", "by (metis literal.collapse true_lit_simps)+"], ["", "lemma true_cls_replicate_mset[iff]: \"I \\<Turnstile> replicate_mset n L \\<longleftrightarrow> n \\<noteq> 0 \\<and> I \\<Turnstile>l L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (I \\<Turnstile> replicate_mset n L) =\n    (n \\<noteq> 0 \\<and> I \\<Turnstile>l L)", "by (simp add: true_cls_def)"], ["", "lemma pos_literal_in_imp_true_cls[intro]: \"Pos A \\<in># C \\<Longrightarrow> A \\<in> I \\<Longrightarrow> I \\<Turnstile> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Pos A \\<in># C; A \\<in> I\\<rbrakk>\n    \\<Longrightarrow> I \\<Turnstile> C", "using true_cls_def"], ["proof (prove)\nusing this:\n  (?I \\<Turnstile> ?C) = (\\<exists>L\\<in>#?C. ?I \\<Turnstile>l L)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Pos A \\<in># C; A \\<in> I\\<rbrakk>\n    \\<Longrightarrow> I \\<Turnstile> C", "by blast"], ["", "lemma neg_literal_notin_imp_true_cls[intro]: \"Neg A \\<in># C \\<Longrightarrow> A \\<notin> I \\<Longrightarrow> I \\<Turnstile> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Neg A \\<in># C; A \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> I \\<Turnstile> C", "using true_cls_def"], ["proof (prove)\nusing this:\n  (?I \\<Turnstile> ?C) = (\\<exists>L\\<in>#?C. ?I \\<Turnstile>l L)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Neg A \\<in># C; A \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> I \\<Turnstile> C", "by blast"], ["", "lemma pos_neg_in_imp_true: \"Pos A \\<in># C \\<Longrightarrow> Neg A \\<in># C \\<Longrightarrow> I \\<Turnstile> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Pos A \\<in># C; Neg A \\<in># C\\<rbrakk>\n    \\<Longrightarrow> I \\<Turnstile> C", "using true_cls_def"], ["proof (prove)\nusing this:\n  (?I \\<Turnstile> ?C) = (\\<exists>L\\<in>#?C. ?I \\<Turnstile>l L)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Pos A \\<in># C; Neg A \\<in># C\\<rbrakk>\n    \\<Longrightarrow> I \\<Turnstile> C", "by blast"], ["", "definition true_clss :: \"'a interp \\<Rightarrow> 'a clause set \\<Rightarrow> bool\" (infix \"\\<Turnstile>s\" 50) where\n  \"I \\<Turnstile>s CC \\<longleftrightarrow> (\\<forall>C \\<in> CC. I \\<Turnstile> C)\""], ["", "lemma true_clss_empty[iff]: \"I \\<Turnstile>s {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<Turnstile>s {}", "by (simp add: true_clss_def)"], ["", "lemma true_clss_singleton[iff]: \"I \\<Turnstile>s {C} \\<longleftrightarrow> I \\<Turnstile> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (I \\<Turnstile>s {C}) = (I \\<Turnstile> C)", "unfolding true_clss_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball {C} ((\\<Turnstile>) I) = (I \\<Turnstile> C)", "by blast"], ["", "lemma true_clss_insert[iff]: \"I \\<Turnstile>s insert C DD \\<longleftrightarrow> I \\<Turnstile> C \\<and> I \\<Turnstile>s DD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (I \\<Turnstile>s insert C DD) =\n    (I \\<Turnstile> C \\<and> I \\<Turnstile>s DD)", "unfolding true_clss_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (insert C DD) ((\\<Turnstile>) I) =\n    (I \\<Turnstile> C \\<and> Ball DD ((\\<Turnstile>) I))", "by blast"], ["", "lemma true_clss_union[iff]: \"I \\<Turnstile>s CC \\<union> DD \\<longleftrightarrow> I \\<Turnstile>s CC \\<and> I \\<Turnstile>s DD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (I \\<Turnstile>s CC \\<union> DD) =\n    (I \\<Turnstile>s CC \\<and> I \\<Turnstile>s DD)", "unfolding true_clss_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (CC \\<union> DD) ((\\<Turnstile>) I) =\n    (Ball CC ((\\<Turnstile>) I) \\<and> Ball DD ((\\<Turnstile>) I))", "by blast"], ["", "lemma true_clss_Union[iff]: \"I \\<Turnstile>s \\<Union> CCC \\<longleftrightarrow> (\\<forall>CC \\<in> CCC. I \\<Turnstile>s CC)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (I \\<Turnstile>s \\<Union> CCC) =\n    (\\<forall>CC\\<in>CCC. I \\<Turnstile>s CC)", "unfolding true_clss_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (\\<Union> CCC) ((\\<Turnstile>) I) =\n    (\\<forall>CC\\<in>CCC. Ball CC ((\\<Turnstile>) I))", "by simp"], ["", "lemma true_clss_mono: \"DD \\<subseteq> CC \\<Longrightarrow> I \\<Turnstile>s CC \\<Longrightarrow> I \\<Turnstile>s DD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>DD \\<subseteq> CC; I \\<Turnstile>s CC\\<rbrakk>\n    \\<Longrightarrow> I \\<Turnstile>s DD", "by (simp add: subsetD true_clss_def)"], ["", "lemma true_clss_mono_strong: \"(\\<forall>D \\<in> DD. \\<exists>C \\<in> CC. C \\<subseteq># D) \\<Longrightarrow> I \\<Turnstile>s CC \\<Longrightarrow> I \\<Turnstile>s DD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>D\\<in>DD. \\<exists>C\\<in>CC. C \\<subseteq># D;\n     I \\<Turnstile>s CC\\<rbrakk>\n    \\<Longrightarrow> I \\<Turnstile>s DD", "unfolding true_clss_def true_cls_def true_lit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>D\\<in>DD. \\<exists>C\\<in>CC. C \\<subseteq># D;\n     \\<forall>C\\<in>CC.\n        \\<exists>L\\<in>#C.\n           (if is_pos L then \\<lambda>P. P else Not)\n            (atm_of L \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>C\\<in>DD.\n                         \\<exists>L\\<in>#C.\n                            (if is_pos L then \\<lambda>P. P else Not)\n                             (atm_of L \\<in> I)", "by (meson mset_subset_eqD)"], ["", "lemma true_clss_subclause: \"C \\<subseteq># D \\<Longrightarrow> I \\<Turnstile>s {C} \\<Longrightarrow> I \\<Turnstile>s {D}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<subseteq># D; I \\<Turnstile>s {C}\\<rbrakk>\n    \\<Longrightarrow> I \\<Turnstile>s {D}", "by (rule true_clss_mono_strong[of _ \"{C}\"]) auto"], ["", "abbreviation satisfiable :: \"'a clause set \\<Rightarrow> bool\" where\n  \"satisfiable CC \\<equiv> \\<exists>I. I \\<Turnstile>s CC\""], ["", "lemma satisfiable_antimono: \"CC \\<subseteq> DD \\<Longrightarrow> satisfiable DD \\<Longrightarrow> satisfiable CC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>CC \\<subseteq> DD; satisfiable DD\\<rbrakk>\n    \\<Longrightarrow> satisfiable CC", "using true_clss_mono"], ["proof (prove)\nusing this:\n  \\<lbrakk>?DD \\<subseteq> ?CC; ?I \\<Turnstile>s ?CC\\<rbrakk>\n  \\<Longrightarrow> ?I \\<Turnstile>s ?DD\n\ngoal (1 subgoal):\n 1. \\<lbrakk>CC \\<subseteq> DD; satisfiable DD\\<rbrakk>\n    \\<Longrightarrow> satisfiable CC", "by blast"], ["", "lemma unsatisfiable_mono: \"CC \\<subseteq> DD \\<Longrightarrow> \\<not> satisfiable CC \\<Longrightarrow> \\<not> satisfiable DD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>CC \\<subseteq> DD; \\<not> satisfiable CC\\<rbrakk>\n    \\<Longrightarrow> \\<not> satisfiable DD", "using satisfiable_antimono"], ["proof (prove)\nusing this:\n  \\<lbrakk>?CC \\<subseteq> ?DD; satisfiable ?DD\\<rbrakk>\n  \\<Longrightarrow> satisfiable ?CC\n\ngoal (1 subgoal):\n 1. \\<lbrakk>CC \\<subseteq> DD; \\<not> satisfiable CC\\<rbrakk>\n    \\<Longrightarrow> \\<not> satisfiable DD", "by blast"], ["", "definition true_cls_mset :: \"'a interp \\<Rightarrow> 'a clause multiset \\<Rightarrow> bool\" (infix \"\\<Turnstile>m\" 50) where\n  \"I \\<Turnstile>m CC \\<longleftrightarrow> (\\<forall>C \\<in># CC. I \\<Turnstile> C)\""], ["", "lemma true_cls_mset_empty[iff]: \"I \\<Turnstile>m {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<Turnstile>m {#}", "unfolding true_cls_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Multiset.Ball {#} ((\\<Turnstile>) I)", "by auto"], ["", "lemma true_cls_mset_singleton[iff]: \"I \\<Turnstile>m {#C#} \\<longleftrightarrow> I \\<Turnstile> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (I \\<Turnstile>m {#C#}) = (I \\<Turnstile> C)", "by (simp add: true_cls_mset_def)"], ["", "lemma true_cls_mset_union[iff]: \"I \\<Turnstile>m CC + DD \\<longleftrightarrow> I \\<Turnstile>m CC \\<and> I \\<Turnstile>m DD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (I \\<Turnstile>m CC + DD) =\n    (I \\<Turnstile>m CC \\<and> I \\<Turnstile>m DD)", "unfolding true_cls_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Multiset.Ball (CC + DD) ((\\<Turnstile>) I) =\n    (Multiset.Ball CC ((\\<Turnstile>) I) \\<and>\n     Multiset.Ball DD ((\\<Turnstile>) I))", "by auto"], ["", "lemma true_cls_mset_Union[iff]: \"I \\<Turnstile>m \\<Sum>\\<^sub># CCC \\<longleftrightarrow> (\\<forall>CC \\<in># CCC. I \\<Turnstile>m CC)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (I \\<Turnstile>m \\<Sum>\\<^sub># CCC) =\n    (\\<forall>CC\\<in>#CCC. I \\<Turnstile>m CC)", "unfolding true_cls_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Multiset.Ball (\\<Sum>\\<^sub># CCC) ((\\<Turnstile>) I) =\n    (\\<forall>CC\\<in>#CCC. Multiset.Ball CC ((\\<Turnstile>) I))", "by simp"], ["", "lemma true_cls_mset_add_mset[iff]: \"I \\<Turnstile>m add_mset C CC \\<longleftrightarrow> I \\<Turnstile> C \\<and> I \\<Turnstile>m CC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (I \\<Turnstile>m add_mset C CC) =\n    (I \\<Turnstile> C \\<and> I \\<Turnstile>m CC)", "unfolding true_cls_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Multiset.Ball (add_mset C CC) ((\\<Turnstile>) I) =\n    (I \\<Turnstile> C \\<and> Multiset.Ball CC ((\\<Turnstile>) I))", "by auto"], ["", "lemma true_cls_mset_image_mset[iff]: \"I \\<Turnstile>m image_mset f A \\<longleftrightarrow> (\\<forall>x \\<in># A. I \\<Turnstile> f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (I \\<Turnstile>m image_mset f A) =\n    (\\<forall>x\\<in>#A. I \\<Turnstile> f x)", "unfolding true_cls_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Multiset.Ball (image_mset f A) ((\\<Turnstile>) I) =\n    (\\<forall>x\\<in>#A. I \\<Turnstile> f x)", "by auto"], ["", "lemma true_cls_mset_mono: \"set_mset DD \\<subseteq> set_mset CC \\<Longrightarrow> I \\<Turnstile>m CC \\<Longrightarrow> I \\<Turnstile>m DD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set_mset DD \\<subseteq> set_mset CC;\n     I \\<Turnstile>m CC\\<rbrakk>\n    \\<Longrightarrow> I \\<Turnstile>m DD", "unfolding true_cls_mset_def subset_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>t. t \\<in># DD \\<longrightarrow> t \\<in># CC;\n     Multiset.Ball CC ((\\<Turnstile>) I)\\<rbrakk>\n    \\<Longrightarrow> Multiset.Ball DD ((\\<Turnstile>) I)", "by auto"], ["", "lemma true_cls_mset_mono_strong: \"(\\<forall>D \\<in># DD. \\<exists>C \\<in># CC. C \\<subseteq># D) \\<Longrightarrow> I \\<Turnstile>m CC \\<Longrightarrow> I \\<Turnstile>m DD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>D\\<in>#DD. \\<exists>C\\<in>#CC. C \\<subseteq># D;\n     I \\<Turnstile>m CC\\<rbrakk>\n    \\<Longrightarrow> I \\<Turnstile>m DD", "unfolding true_cls_mset_def true_cls_def true_lit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>D\\<in>#DD. \\<exists>C\\<in>#CC. C \\<subseteq># D;\n     \\<forall>C\\<in>#CC.\n        \\<exists>L\\<in>#C.\n           (if is_pos L then \\<lambda>P. P else Not)\n            (atm_of L \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>C\\<in>#DD.\n                         \\<exists>L\\<in>#C.\n                            (if is_pos L then \\<lambda>P. P else Not)\n                             (atm_of L \\<in> I)", "by (meson mset_subset_eqD)"], ["", "lemma true_clss_set_mset[iff]: \"I \\<Turnstile>s set_mset CC \\<longleftrightarrow> I \\<Turnstile>m CC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (I \\<Turnstile>s set_mset CC) = (I \\<Turnstile>m CC)", "unfolding true_clss_def true_cls_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Multiset.Ball CC ((\\<Turnstile>) I) =\n    Multiset.Ball CC ((\\<Turnstile>) I)", "by auto"], ["", "lemma true_clss_mset_set[simp]: \"finite CC \\<Longrightarrow> I \\<Turnstile>m mset_set CC \\<longleftrightarrow> I \\<Turnstile>s CC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite CC \\<Longrightarrow>\n    (I \\<Turnstile>m mset_set CC) = (I \\<Turnstile>s CC)", "unfolding true_clss_def true_cls_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite CC \\<Longrightarrow>\n    Multiset.Ball (mset_set CC) ((\\<Turnstile>) I) =\n    Ball CC ((\\<Turnstile>) I)", "by auto"], ["", "lemma true_cls_mset_true_cls: \"I \\<Turnstile>m CC \\<Longrightarrow> C \\<in># CC \\<Longrightarrow> I \\<Turnstile> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<Turnstile>m CC; C \\<in># CC\\<rbrakk>\n    \\<Longrightarrow> I \\<Turnstile> C", "using true_cls_mset_def"], ["proof (prove)\nusing this:\n  (?I \\<Turnstile>m ?CC) = (\\<forall>C\\<in>#?CC. ?I \\<Turnstile> C)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<Turnstile>m CC; C \\<in># CC\\<rbrakk>\n    \\<Longrightarrow> I \\<Turnstile> C", "by auto"], ["", "end"]]}