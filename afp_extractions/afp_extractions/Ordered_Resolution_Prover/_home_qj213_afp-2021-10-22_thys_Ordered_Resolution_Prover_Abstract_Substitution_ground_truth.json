{"file_name": "/home/qj213/afp-2021-10-22/thys/Ordered_Resolution_Prover/Abstract_Substitution.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Ordered_Resolution_Prover", "problem_names": ["lemma f_Suc_decr_eventually_const:\n  fixes f :: \"nat \\<Rightarrow> nat\"\n  assumes leq: \"\\<forall>i. f (Suc i) \\<le> f i\"\n  shows \"\\<exists>l. \\<forall>l' \\<ge> l. f l' = f (Suc l')\"", "lemma atm_of_subst_lit[simp]: \"atm_of (L \\<cdot>l \\<sigma>) = atm_of L \\<cdot>a \\<sigma>\"", "lemma subst_cls_add_mset[simp]: \"add_mset L C \\<cdot> \\<sigma> = add_mset (L \\<cdot>l \\<sigma>) (C \\<cdot> \\<sigma>)\"", "lemma subst_cls_mset_add_mset[simp]: \"add_mset C CC \\<cdot>cm \\<sigma> = add_mset (C \\<cdot> \\<sigma>) (CC \\<cdot>cm \\<sigma>)\"", "lemma subst_ext_iff: \"\\<sigma> = \\<tau> \\<longleftrightarrow> (\\<forall>A. A \\<cdot>a \\<sigma> = A \\<cdot>a \\<tau>)\"", "lemma id_subst_comp_subst[simp]: \"id_subst \\<odot> \\<sigma> = \\<sigma>\"", "lemma comp_subst_id_subst[simp]: \"\\<sigma> \\<odot> id_subst = \\<sigma>\"", "lemma id_subst_comp_substs[simp]: \"replicate (length \\<sigma>s) id_subst \\<odot>s \\<sigma>s = \\<sigma>s\"", "lemma comp_substs_id_subst[simp]: \"\\<sigma>s \\<odot>s replicate (length \\<sigma>s) id_subst = \\<sigma>s\"", "lemma subst_atms_id_subst[simp]: \"AA \\<cdot>as id_subst = AA\"", "lemma subst_atmss_id_subst[simp]: \"AAA \\<cdot>ass id_subst = AAA\"", "lemma subst_atm_list_id_subst[simp]: \"As \\<cdot>al id_subst = As\"", "lemma subst_atm_mset_id_subst[simp]: \"AA \\<cdot>am id_subst = AA\"", "lemma subst_atm_mset_list_id_subst[simp]: \"AAs \\<cdot>aml id_subst = AAs\"", "lemma subst_atm_mset_lists_id_subst[simp]: \"AAs \\<cdot>\\<cdot>aml replicate (length AAs) id_subst = AAs\"", "lemma subst_lit_id_subst[simp]: \"L \\<cdot>l id_subst = L\"", "lemma subst_cls_id_subst[simp]: \"C \\<cdot> id_subst = C\"", "lemma subst_clss_id_subst[simp]: \"CC \\<cdot>cs id_subst = CC\"", "lemma subst_cls_list_id_subst[simp]: \"Cs \\<cdot>cl id_subst = Cs\"", "lemma subst_cls_lists_id_subst[simp]: \"Cs \\<cdot>\\<cdot>cl replicate (length Cs) id_subst = Cs\"", "lemma subst_cls_mset_id_subst[simp]: \"CC \\<cdot>cm id_subst = CC\"", "lemma comp_subst_assoc[simp]: \"\\<sigma> \\<odot> (\\<tau> \\<odot> \\<gamma>) = \\<sigma> \\<odot> \\<tau> \\<odot> \\<gamma>\"", "lemma subst_atms_comp_subst[simp]: \"AA \\<cdot>as (\\<tau> \\<odot> \\<sigma>) = AA \\<cdot>as \\<tau> \\<cdot>as \\<sigma>\"", "lemma subst_atmss_comp_subst[simp]: \"AAA \\<cdot>ass (\\<tau> \\<odot> \\<sigma>) = AAA \\<cdot>ass \\<tau> \\<cdot>ass \\<sigma>\"", "lemma subst_atm_list_comp_subst[simp]: \"As \\<cdot>al (\\<tau> \\<odot> \\<sigma>) = As \\<cdot>al \\<tau> \\<cdot>al \\<sigma>\"", "lemma subst_atm_mset_comp_subst[simp]: \"AA \\<cdot>am (\\<tau> \\<odot> \\<sigma>) = AA \\<cdot>am \\<tau> \\<cdot>am \\<sigma>\"", "lemma subst_atm_mset_list_comp_subst[simp]: \"AAs \\<cdot>aml (\\<tau> \\<odot> \\<sigma>) = (AAs \\<cdot>aml \\<tau>) \\<cdot>aml \\<sigma>\"", "lemma subst_atm_mset_lists_comp_substs[simp]: \"AAs \\<cdot>\\<cdot>aml (\\<tau>s \\<odot>s \\<sigma>s) = AAs \\<cdot>\\<cdot>aml \\<tau>s \\<cdot>\\<cdot>aml \\<sigma>s\"", "lemma subst_lit_comp_subst[simp]: \"L \\<cdot>l (\\<tau> \\<odot> \\<sigma>) = L \\<cdot>l \\<tau> \\<cdot>l \\<sigma>\"", "lemma subst_cls_comp_subst[simp]: \"C \\<cdot> (\\<tau> \\<odot> \\<sigma>) = C \\<cdot> \\<tau> \\<cdot> \\<sigma>\"", "lemma subst_clsscomp_subst[simp]: \"CC \\<cdot>cs (\\<tau> \\<odot> \\<sigma>) = CC \\<cdot>cs \\<tau> \\<cdot>cs \\<sigma>\"", "lemma subst_cls_list_comp_subst[simp]: \"Cs \\<cdot>cl (\\<tau> \\<odot> \\<sigma>) = Cs \\<cdot>cl \\<tau> \\<cdot>cl \\<sigma>\"", "lemma subst_cls_lists_comp_substs[simp]: \"Cs \\<cdot>\\<cdot>cl (\\<tau>s \\<odot>s \\<sigma>s) = Cs \\<cdot>\\<cdot>cl \\<tau>s \\<cdot>\\<cdot>cl \\<sigma>s\"", "lemma subst_cls_mset_comp_subst[simp]: \"CC \\<cdot>cm (\\<tau> \\<odot> \\<sigma>) = CC \\<cdot>cm \\<tau> \\<cdot>cm \\<sigma>\"", "lemma Melem_subst_atm_mset[simp]: \"A \\<in># AA \\<cdot>am \\<sigma> \\<longleftrightarrow> (\\<exists>B. B \\<in># AA \\<and> A = B \\<cdot>a \\<sigma>)\"", "lemma Melem_subst_cls[simp]: \"L \\<in># C \\<cdot> \\<sigma> \\<longleftrightarrow> (\\<exists>M. M \\<in># C \\<and> L = M \\<cdot>l \\<sigma>)\"", "lemma Melem_subst_cls_mset[simp]: \"AA \\<in># CC \\<cdot>cm \\<sigma> \\<longleftrightarrow> (\\<exists>BB. BB \\<in># CC \\<and> AA = BB \\<cdot> \\<sigma>)\"", "lemma subst_lit_is_neg[simp]: \"is_neg (L \\<cdot>l \\<sigma>) = is_neg L\"", "lemma subst_lit_is_pos[simp]: \"is_pos (L \\<cdot>l \\<sigma>) = is_pos L\"", "lemma subst_minus[simp]: \"(- L) \\<cdot>l \\<mu> = - (L  \\<cdot>l \\<mu>)\"", "lemma eql_neg_lit_eql_atm[simp]: \"(Neg A' \\<cdot>l \\<eta>) = Neg A \\<longleftrightarrow> A' \\<cdot>a \\<eta> = A\"", "lemma eql_pos_lit_eql_atm[simp]: \"(Pos A' \\<cdot>l \\<eta>) = Pos A \\<longleftrightarrow> A' \\<cdot>a \\<eta> = A\"", "lemma subst_cls_negs[simp]: \"(negs AA) \\<cdot> \\<sigma> = negs (AA \\<cdot>am \\<sigma>)\"", "lemma subst_cls_poss[simp]: \"(poss AA) \\<cdot> \\<sigma> = poss (AA \\<cdot>am \\<sigma>)\"", "lemma atms_of_subst_atms: \"atms_of C \\<cdot>as \\<sigma> = atms_of (C \\<cdot> \\<sigma>)\"", "lemma in_image_Neg_is_neg[simp]: \"L \\<cdot>l \\<sigma> \\<in> Neg ` AA \\<Longrightarrow> is_neg L\"", "lemma subst_lit_in_negs_subst_is_neg: \"L \\<cdot>l \\<sigma> \\<in># (negs AA) \\<cdot> \\<tau> \\<Longrightarrow> is_neg L\"", "lemma subst_lit_in_negs_is_neg: \"L \\<cdot>l \\<sigma> \\<in># negs AA \\<Longrightarrow> is_neg L\"", "lemma subst_atms_empty[simp]: \"{} \\<cdot>as \\<sigma> = {}\"", "lemma subst_atmss_empty[simp]: \"{} \\<cdot>ass \\<sigma> = {}\"", "lemma comp_substs_empty_iff[simp]: \"\\<sigma>s \\<odot>s \\<eta>s = [] \\<longleftrightarrow> \\<sigma>s = [] \\<or> \\<eta>s = []\"", "lemma subst_atm_list_empty[simp]: \"[] \\<cdot>al \\<sigma> = []\"", "lemma subst_atm_mset_empty[simp]: \"{#} \\<cdot>am \\<sigma> = {#}\"", "lemma subst_atm_mset_list_empty[simp]: \"[] \\<cdot>aml \\<sigma> = []\"", "lemma subst_atm_mset_lists_empty[simp]: \"[] \\<cdot>\\<cdot>aml \\<sigma>s = []\"", "lemma subst_cls_empty[simp]: \"{#} \\<cdot> \\<sigma> = {#}\"", "lemma subst_clss_empty[simp]: \"{} \\<cdot>cs \\<sigma> = {}\"", "lemma subst_cls_list_empty[simp]: \"[] \\<cdot>cl \\<sigma> = []\"", "lemma subst_cls_lists_empty[simp]: \"[] \\<cdot>\\<cdot>cl \\<sigma>s = []\"", "lemma subst_scls_mset_empty[simp]: \"{#} \\<cdot>cm \\<sigma> = {#}\"", "lemma subst_atms_empty_iff[simp]: \"AA \\<cdot>as \\<eta> = {} \\<longleftrightarrow> AA = {}\"", "lemma subst_atmss_empty_iff[simp]: \"AAA \\<cdot>ass \\<eta> = {} \\<longleftrightarrow> AAA = {}\"", "lemma subst_atm_list_empty_iff[simp]: \"As \\<cdot>al \\<eta> = [] \\<longleftrightarrow> As = []\"", "lemma subst_atm_mset_empty_iff[simp]: \"AA \\<cdot>am \\<eta> = {#} \\<longleftrightarrow> AA = {#}\"", "lemma subst_atm_mset_list_empty_iff[simp]: \"AAs \\<cdot>aml \\<eta> = [] \\<longleftrightarrow> AAs = []\"", "lemma subst_atm_mset_lists_empty_iff[simp]: \"AAs \\<cdot>\\<cdot>aml \\<eta>s = [] \\<longleftrightarrow> (AAs = [] \\<or> \\<eta>s = [])\"", "lemma subst_cls_empty_iff[simp]: \"C \\<cdot> \\<eta> = {#} \\<longleftrightarrow> C = {#}\"", "lemma subst_clss_empty_iff[simp]: \"CC \\<cdot>cs \\<eta> = {} \\<longleftrightarrow> CC = {}\"", "lemma subst_cls_list_empty_iff[simp]: \"Cs \\<cdot>cl \\<eta> = [] \\<longleftrightarrow> Cs = []\"", "lemma subst_cls_lists_empty_iff[simp]: \"Cs \\<cdot>\\<cdot>cl \\<eta>s = [] \\<longleftrightarrow> Cs = [] \\<or> \\<eta>s = []\"", "lemma subst_cls_mset_empty_iff[simp]: \"CC \\<cdot>cm \\<eta> = {#} \\<longleftrightarrow> CC = {#}\"", "lemma subst_atms_union[simp]: \"(AA \\<union> BB) \\<cdot>as \\<sigma> = AA \\<cdot>as \\<sigma> \\<union> BB \\<cdot>as \\<sigma>\"", "lemma subst_atmss_union[simp]: \"(AAA \\<union> BBB) \\<cdot>ass \\<sigma> = AAA \\<cdot>ass \\<sigma> \\<union> BBB \\<cdot>ass \\<sigma>\"", "lemma subst_atm_list_append[simp]: \"(As @ Bs) \\<cdot>al \\<sigma> = As \\<cdot>al \\<sigma> @ Bs \\<cdot>al \\<sigma>\"", "lemma subst_atm_mset_union[simp]: \"(AA + BB) \\<cdot>am \\<sigma> = AA \\<cdot>am \\<sigma> + BB \\<cdot>am \\<sigma>\"", "lemma subst_atm_mset_list_append[simp]: \"(AAs @ BBs) \\<cdot>aml \\<sigma> = AAs \\<cdot>aml \\<sigma> @ BBs \\<cdot>aml \\<sigma>\"", "lemma subst_cls_union[simp]: \"(C + D) \\<cdot> \\<sigma> = C \\<cdot> \\<sigma> + D \\<cdot> \\<sigma>\"", "lemma subst_clss_union[simp]: \"(CC \\<union> DD) \\<cdot>cs \\<sigma> = CC \\<cdot>cs \\<sigma> \\<union> DD \\<cdot>cs \\<sigma>\"", "lemma subst_cls_list_append[simp]: \"(Cs @ Ds) \\<cdot>cl \\<sigma> = Cs \\<cdot>cl \\<sigma> @ Ds \\<cdot>cl \\<sigma>\"", "lemma subst_cls_lists_append[simp]:\n  \"length Cs = length \\<sigma>s \\<Longrightarrow> length Cs' = length \\<sigma>s' \\<Longrightarrow>\n   (Cs @ Cs') \\<cdot>\\<cdot>cl (\\<sigma>s @ \\<sigma>s') = Cs \\<cdot>\\<cdot>cl \\<sigma>s @ Cs' \\<cdot>\\<cdot>cl \\<sigma>s'\"", "lemma subst_cls_mset_union[simp]: \"(CC + DD) \\<cdot>cm \\<sigma> = CC \\<cdot>cm \\<sigma> + DD \\<cdot>cm \\<sigma>\"", "lemma subst_atms_single[simp]: \"{A} \\<cdot>as \\<sigma> = {A \\<cdot>a \\<sigma>}\"", "lemma subst_atmss_single[simp]: \"{AA} \\<cdot>ass \\<sigma> = {AA \\<cdot>as \\<sigma>}\"", "lemma subst_atm_list_single[simp]: \"[A] \\<cdot>al \\<sigma> = [A \\<cdot>a \\<sigma>]\"", "lemma subst_atm_mset_single[simp]: \"{#A#} \\<cdot>am \\<sigma> = {#A \\<cdot>a \\<sigma>#}\"", "lemma subst_atm_mset_list[simp]: \"[AA] \\<cdot>aml \\<sigma> = [AA \\<cdot>am \\<sigma>]\"", "lemma subst_cls_single[simp]: \"{#L#} \\<cdot> \\<sigma> = {#L \\<cdot>l \\<sigma>#}\"", "lemma subst_clss_single[simp]: \"{C} \\<cdot>cs \\<sigma> = {C \\<cdot> \\<sigma>}\"", "lemma subst_cls_list_single[simp]: \"[C] \\<cdot>cl \\<sigma> = [C \\<cdot> \\<sigma>]\"", "lemma subst_cls_lists_single[simp]: \"[C] \\<cdot>\\<cdot>cl [\\<sigma>] = [C \\<cdot> \\<sigma>]\"", "lemma subst_cls_mset_single[simp]: \"{#C#} \\<cdot>cm \\<sigma> = {#C \\<cdot> \\<sigma>#}\"", "lemma subst_atm_list_Cons[simp]: \"(A # As) \\<cdot>al \\<sigma> = A \\<cdot>a \\<sigma> # As \\<cdot>al \\<sigma>\"", "lemma subst_atm_mset_list_Cons[simp]: \"(A # As) \\<cdot>aml \\<sigma> = A \\<cdot>am \\<sigma> # As \\<cdot>aml \\<sigma>\"", "lemma subst_atm_mset_lists_Cons[simp]: \"(C # Cs) \\<cdot>\\<cdot>aml (\\<sigma> # \\<sigma>s) = C \\<cdot>am \\<sigma> # Cs \\<cdot>\\<cdot>aml \\<sigma>s\"", "lemma subst_cls_list_Cons[simp]: \"(C # Cs) \\<cdot>cl \\<sigma> = C \\<cdot> \\<sigma> # Cs \\<cdot>cl \\<sigma>\"", "lemma subst_cls_lists_Cons[simp]: \"(C # Cs) \\<cdot>\\<cdot>cl (\\<sigma> # \\<sigma>s) = C \\<cdot> \\<sigma> # Cs \\<cdot>\\<cdot>cl \\<sigma>s\"", "lemma subst_atm_list_tl[simp]: \"tl (As \\<cdot>al \\<sigma>) = tl As \\<cdot>al \\<sigma>\"", "lemma subst_atm_mset_list_tl[simp]: \"tl (AAs \\<cdot>aml \\<sigma>) = tl AAs \\<cdot>aml \\<sigma>\"", "lemma subst_cls_list_tl[simp]: \"tl (Cs \\<cdot>cl \\<sigma>) = tl Cs \\<cdot>cl \\<sigma>\"", "lemma subst_cls_lists_tl[simp]: \"length Cs = length \\<sigma>s \\<Longrightarrow> tl (Cs \\<cdot>\\<cdot>cl \\<sigma>s) = tl Cs \\<cdot>\\<cdot>cl tl \\<sigma>s\"", "lemma comp_substs_nth[simp]:\n  \"length \\<tau>s = length \\<sigma>s \\<Longrightarrow> i < length \\<tau>s \\<Longrightarrow> (\\<tau>s \\<odot>s \\<sigma>s) ! i = (\\<tau>s ! i) \\<odot> (\\<sigma>s ! i)\"", "lemma subst_atm_list_nth[simp]: \"i < length As \\<Longrightarrow> (As \\<cdot>al \\<tau>) ! i = As ! i \\<cdot>a \\<tau>\"", "lemma subst_atm_mset_list_nth[simp]: \"i < length AAs \\<Longrightarrow> (AAs \\<cdot>aml \\<eta>) ! i = (AAs ! i) \\<cdot>am \\<eta>\"", "lemma subst_atm_mset_lists_nth[simp]:\n  \"length AAs = length \\<sigma>s \\<Longrightarrow> i < length AAs \\<Longrightarrow> (AAs \\<cdot>\\<cdot>aml \\<sigma>s) ! i = (AAs ! i) \\<cdot>am (\\<sigma>s ! i)\"", "lemma subst_cls_list_nth[simp]: \"i < length Cs \\<Longrightarrow> (Cs \\<cdot>cl \\<tau>) ! i = (Cs ! i) \\<cdot> \\<tau>\"", "lemma subst_cls_lists_nth[simp]:\n  \"length Cs = length \\<sigma>s \\<Longrightarrow> i < length Cs \\<Longrightarrow> (Cs \\<cdot>\\<cdot>cl \\<sigma>s) ! i = (Cs ! i) \\<cdot> (\\<sigma>s ! i)\"", "lemma subst_clss_image[simp]: \"image f X \\<cdot>cs \\<sigma> = {f x \\<cdot> \\<sigma> | x. x \\<in> X}\"", "lemma subst_cls_mset_image_mset[simp]: \"image_mset f X \\<cdot>cm \\<sigma> = {# f x \\<cdot> \\<sigma>. x \\<in># X #}\"", "lemma mset_subst_atm_list_subst_atm_mset[simp]: \"mset (As \\<cdot>al \\<sigma>) = mset (As) \\<cdot>am \\<sigma>\"", "lemma mset_subst_cls_list_subst_cls_mset: \"mset (Cs \\<cdot>cl \\<sigma>) = (mset Cs) \\<cdot>cm \\<sigma>\"", "lemma sum_list_subst_cls_list_subst_cls[simp]: \"sum_list (Cs \\<cdot>cl \\<eta>) = sum_list Cs \\<cdot> \\<eta>\"", "lemma set_mset_subst_cls_mset_subst_clss: \"set_mset (CC \\<cdot>cm \\<mu>) = (set_mset CC) \\<cdot>cs \\<mu>\"", "lemma Neg_Melem_subst_atm_subst_cls[simp]: \"Neg A \\<in># C \\<Longrightarrow> Neg (A \\<cdot>a \\<sigma>) \\<in># C \\<cdot> \\<sigma> \"", "lemma Pos_Melem_subst_atm_subst_cls[simp]: \"Pos A \\<in># C \\<Longrightarrow> Pos (A \\<cdot>a \\<sigma>) \\<in># C \\<cdot> \\<sigma> \"", "lemma in_atms_of_subst[simp]: \"B \\<in> atms_of C \\<Longrightarrow> B \\<cdot>a \\<sigma> \\<in> atms_of (C \\<cdot> \\<sigma>)\"", "lemma is_renaming_id_subst[simp]: \"is_renaming id_subst\"", "lemma is_renamingD: \"is_renaming \\<sigma> \\<Longrightarrow> (\\<forall>A1 A2. A1 \\<cdot>a \\<sigma> = A2 \\<cdot>a \\<sigma> \\<longleftrightarrow> A1 = A2)\"", "lemma inv_renaming_cancel_r[simp]: \"is_renaming r \\<Longrightarrow> r \\<odot> inv_renaming r = id_subst\"", "lemma inv_renaming_cancel_r_list[simp]:\n  \"is_renaming_list rs \\<Longrightarrow> rs \\<odot>s map inv_renaming rs = replicate (length rs) id_subst\"", "lemma Nil_comp_substs[simp]: \"[] \\<odot>s s = []\"", "lemma comp_substs_Nil[simp]: \"s \\<odot>s [] = []\"", "lemma is_renaming_idempotent_id_subst: \"is_renaming r \\<Longrightarrow> r \\<odot> r = r \\<Longrightarrow> r = id_subst\"", "lemma is_renaming_left_id_subst_right_id_subst:\n  \"is_renaming r \\<Longrightarrow> s \\<odot> r = id_subst \\<Longrightarrow> r \\<odot> s = id_subst\"", "lemma is_renaming_closure: \"is_renaming r1 \\<Longrightarrow> is_renaming r2 \\<Longrightarrow> is_renaming (r1 \\<odot> r2)\"", "lemma is_renaming_inv_renaming_cancel_atm[simp]: \"is_renaming \\<rho> \\<Longrightarrow> A \\<cdot>a \\<rho> \\<cdot>a inv_renaming \\<rho> = A\"", "lemma is_renaming_inv_renaming_cancel_atms[simp]: \"is_renaming \\<rho> \\<Longrightarrow> AA \\<cdot>as \\<rho> \\<cdot>as inv_renaming \\<rho> = AA\"", "lemma is_renaming_inv_renaming_cancel_atmss[simp]: \"is_renaming \\<rho> \\<Longrightarrow> AAA \\<cdot>ass \\<rho> \\<cdot>ass inv_renaming \\<rho> = AAA\"", "lemma is_renaming_inv_renaming_cancel_atm_list[simp]: \"is_renaming \\<rho> \\<Longrightarrow> As \\<cdot>al \\<rho> \\<cdot>al inv_renaming \\<rho> = As\"", "lemma is_renaming_inv_renaming_cancel_atm_mset[simp]: \"is_renaming \\<rho> \\<Longrightarrow> AA \\<cdot>am \\<rho> \\<cdot>am inv_renaming \\<rho> = AA\"", "lemma is_renaming_inv_renaming_cancel_atm_mset_list[simp]: \"is_renaming \\<rho> \\<Longrightarrow> (AAs \\<cdot>aml \\<rho>) \\<cdot>aml inv_renaming \\<rho> = AAs\"", "lemma is_renaming_list_inv_renaming_cancel_atm_mset_lists[simp]:\n  \"length AAs = length \\<rho>s \\<Longrightarrow> is_renaming_list \\<rho>s \\<Longrightarrow> AAs \\<cdot>\\<cdot>aml \\<rho>s \\<cdot>\\<cdot>aml map inv_renaming \\<rho>s = AAs\"", "lemma is_renaming_inv_renaming_cancel_lit[simp]: \"is_renaming \\<rho> \\<Longrightarrow> (L \\<cdot>l \\<rho>) \\<cdot>l inv_renaming \\<rho> = L\"", "lemma is_renaming_inv_renaming_cancel_cls[simp]: \"is_renaming \\<rho> \\<Longrightarrow> C  \\<cdot> \\<rho> \\<cdot> inv_renaming \\<rho> = C\"", "lemma is_renaming_inv_renaming_cancel_clss[simp]:\n  \"is_renaming \\<rho> \\<Longrightarrow> CC \\<cdot>cs \\<rho> \\<cdot>cs inv_renaming \\<rho> = CC\"", "lemma is_renaming_inv_renaming_cancel_cls_list[simp]:\n  \"is_renaming \\<rho> \\<Longrightarrow> Cs \\<cdot>cl \\<rho> \\<cdot>cl inv_renaming \\<rho> = Cs\"", "lemma is_renaming_list_inv_renaming_cancel_cls_list[simp]:\n  \"length Cs = length \\<rho>s \\<Longrightarrow> is_renaming_list \\<rho>s \\<Longrightarrow> Cs \\<cdot>\\<cdot>cl \\<rho>s \\<cdot>\\<cdot>cl map inv_renaming \\<rho>s = Cs\"", "lemma is_renaming_inv_renaming_cancel_cls_mset[simp]:\n  \"is_renaming \\<rho> \\<Longrightarrow> CC \\<cdot>cm \\<rho> \\<cdot>cm inv_renaming \\<rho> = CC\"", "lemma subst_cls_mono: \"set_mset C \\<subseteq> set_mset D \\<Longrightarrow> set_mset (C \\<cdot> \\<sigma>) \\<subseteq> set_mset (D \\<cdot> \\<sigma>)\"", "lemma subst_cls_mono_mset: \"C \\<subseteq># D \\<Longrightarrow> C \\<cdot> \\<sigma> \\<subseteq># D \\<cdot> \\<sigma>\"", "lemma subst_subset_mono: \"D \\<subset># C \\<Longrightarrow> D \\<cdot> \\<sigma> \\<subset># C \\<cdot> \\<sigma>\"", "lemma size_subst[simp]: \"size (D \\<cdot> \\<sigma>) = size D\"", "lemma subst_atm_list_length[simp]: \"length (As \\<cdot>al \\<sigma>) = length As\"", "lemma length_subst_atm_mset_list[simp]: \"length (AAs \\<cdot>aml \\<eta>) = length AAs\"", "lemma subst_atm_mset_lists_length[simp]: \"length (AAs \\<cdot>\\<cdot>aml \\<sigma>s) = min (length AAs) (length \\<sigma>s)\"", "lemma subst_cls_list_length[simp]: \"length (Cs \\<cdot>cl \\<sigma>) = length Cs\"", "lemma comp_substs_length[simp]: \"length (\\<tau>s \\<odot>s \\<sigma>s) = min (length \\<tau>s) (length \\<sigma>s)\"", "lemma subst_cls_lists_length[simp]: \"length (Cs \\<cdot>\\<cdot>cl \\<sigma>s) = min (length Cs) (length \\<sigma>s)\"", "lemma var_disjoint_clauses:\n  assumes \"var_disjoint Cs\"\n  shows \"\\<forall>\\<sigma>s. length \\<sigma>s = length Cs \\<longrightarrow> (\\<exists>\\<tau>. Cs \\<cdot>\\<cdot>cl \\<sigma>s = Cs \\<cdot>cl \\<tau>)\"", "lemma ex_ground_subst: \"\\<exists>\\<sigma>. is_ground_subst \\<sigma>\"", "lemma is_ground_cls_list_Cons[simp]:\n  \"is_ground_cls_list (C # Cs) = (is_ground_cls C \\<and> is_ground_cls_list Cs)\"", "lemma is_ground_atms_union[simp]: \"is_ground_atms (AA \\<union> BB) \\<longleftrightarrow> is_ground_atms AA \\<and> is_ground_atms BB\"", "lemma is_ground_atm_mset_union[simp]:\n  \"is_ground_atm_mset (AA + BB) \\<longleftrightarrow> is_ground_atm_mset AA \\<and> is_ground_atm_mset BB\"", "lemma is_ground_cls_union[simp]: \"is_ground_cls (C + D) \\<longleftrightarrow> is_ground_cls C \\<and> is_ground_cls D\"", "lemma is_ground_clss_union[simp]:\n  \"is_ground_clss (CC \\<union> DD) \\<longleftrightarrow> is_ground_clss CC \\<and> is_ground_clss DD\"", "lemma is_ground_cls_list_is_ground_cls_sum_list[simp]:\n  \"is_ground_cls_list Cs \\<Longrightarrow> is_ground_cls (sum_list Cs)\"", "lemma is_ground_cls_mono: \"C \\<subseteq># D \\<Longrightarrow> is_ground_cls D \\<Longrightarrow> is_ground_cls C\"", "lemma is_ground_clss_mono: \"CC \\<subseteq> DD \\<Longrightarrow> is_ground_clss DD \\<Longrightarrow> is_ground_clss CC\"", "lemma grounding_of_clss_mono: \"CC \\<subseteq> DD \\<Longrightarrow> grounding_of_clss CC \\<subseteq> grounding_of_clss DD\"", "lemma sum_list_subseteq_mset_is_ground_cls_list[simp]:\n  \"sum_list Cs \\<subseteq># sum_list Ds \\<Longrightarrow> is_ground_cls_list Ds \\<Longrightarrow> is_ground_cls_list Cs\"", "lemma is_ground_comp_subst[simp]: \"is_ground_subst \\<sigma> \\<Longrightarrow> is_ground_subst (\\<tau> \\<odot> \\<sigma>)\"", "lemma ground_subst_ground_atm[simp]: \"is_ground_subst \\<sigma> \\<Longrightarrow> is_ground_atm (A \\<cdot>a \\<sigma>)\"", "lemma ground_subst_ground_lit[simp]: \"is_ground_subst \\<sigma> \\<Longrightarrow> is_ground_lit (L \\<cdot>l \\<sigma>)\"", "lemma ground_subst_ground_cls[simp]: \"is_ground_subst \\<sigma> \\<Longrightarrow> is_ground_cls (C \\<cdot> \\<sigma>)\"", "lemma ground_subst_ground_clss[simp]: \"is_ground_subst \\<sigma> \\<Longrightarrow> is_ground_clss (CC \\<cdot>cs \\<sigma>)\"", "lemma ground_subst_ground_cls_list[simp]: \"is_ground_subst \\<sigma> \\<Longrightarrow> is_ground_cls_list (Cs \\<cdot>cl \\<sigma>)\"", "lemma ground_subst_ground_cls_lists[simp]:\n  \"\\<forall>\\<sigma> \\<in> set \\<sigma>s. is_ground_subst \\<sigma> \\<Longrightarrow> is_ground_cls_list (Cs \\<cdot>\\<cdot>cl \\<sigma>s)\"", "lemma subst_cls_eq_grounding_of_cls_subset_eq:\n  assumes \"D \\<cdot> \\<sigma> = C\"\n  shows \"grounding_of_cls C \\<subseteq> grounding_of_cls D\"", "lemma is_ground_subst_atm[simp]: \"is_ground_atm A \\<Longrightarrow> A \\<cdot>a \\<sigma> = A\"", "lemma is_ground_subst_atms[simp]: \"is_ground_atms AA \\<Longrightarrow> AA \\<cdot>as \\<sigma> = AA\"", "lemma is_ground_subst_atm_mset[simp]: \"is_ground_atm_mset AA \\<Longrightarrow> AA \\<cdot>am \\<sigma> = AA\"", "lemma is_ground_subst_atm_list[simp]: \"is_ground_atm_list As \\<Longrightarrow> As \\<cdot>al \\<sigma> = As\"", "lemma is_ground_subst_atm_list_member[simp]:\n  \"is_ground_atm_list As \\<Longrightarrow> i < length As \\<Longrightarrow> As ! i \\<cdot>a \\<sigma> = As ! i\"", "lemma is_ground_subst_lit[simp]: \"is_ground_lit L \\<Longrightarrow> L \\<cdot>l \\<sigma> = L\"", "lemma is_ground_subst_cls[simp]: \"is_ground_cls C \\<Longrightarrow> C \\<cdot> \\<sigma> = C\"", "lemma is_ground_subst_clss[simp]: \"is_ground_clss CC \\<Longrightarrow> CC \\<cdot>cs \\<sigma> = CC\"", "lemma is_ground_subst_cls_lists[simp]:\n  assumes \"length P = length Cs\" and \"is_ground_cls_list Cs\"\n  shows \"Cs \\<cdot>\\<cdot>cl P = Cs\"", "lemma is_ground_subst_lit_iff: \"is_ground_lit L \\<longleftrightarrow> (\\<forall>\\<sigma>. L = L \\<cdot>l \\<sigma>)\"", "lemma is_ground_subst_cls_iff: \"is_ground_cls C \\<longleftrightarrow> (\\<forall>\\<sigma>. C = C \\<cdot> \\<sigma>)\"", "lemma is_ground_cls_as_atms: \"is_ground_cls C \\<longleftrightarrow> (\\<forall>A \\<in> atms_of C. is_ground_atm A)\"", "lemma is_ground_cls_imp_is_ground_lit: \"L \\<in># C \\<Longrightarrow> is_ground_cls C \\<Longrightarrow> is_ground_lit L\"", "lemma is_ground_cls_imp_is_ground_atm: \"A \\<in> atms_of C \\<Longrightarrow> is_ground_cls C \\<Longrightarrow> is_ground_atm A\"", "lemma is_ground_cls_is_ground_atms_atms_of[simp]: \"is_ground_cls C \\<Longrightarrow> is_ground_atms (atms_of C)\"", "lemma grounding_ground: \"C \\<in> grounding_of_clss M \\<Longrightarrow> is_ground_cls C\"", "lemma in_subset_eq_grounding_of_clss_is_ground_cls[simp]:\n  \"C \\<in> CC \\<Longrightarrow> CC \\<subseteq> grounding_of_clss DD \\<Longrightarrow> is_ground_cls C\"", "lemma is_ground_cls_empty[simp]: \"is_ground_cls {#}\"", "lemma grounding_of_cls_ground: \"is_ground_cls C \\<Longrightarrow> grounding_of_cls C = {C}\"", "lemma grounding_of_cls_empty[simp]: \"grounding_of_cls {#} = {{#}}\"", "lemma union_grounding_of_cls_ground: \"is_ground_clss (\\<Union> (grounding_of_cls ` N))\"", "lemma grounding_of_grounding_of_cls: \"E \\<in> grounding_of_cls D \\<Longrightarrow> D \\<in> grounding_of_cls C \\<Longrightarrow> E = D\"", "lemma subsumes_empty_left[simp]: \"subsumes {#} C\"", "lemma strictly_subsumes_empty_left[simp]: \"strictly_subsumes {#} C \\<longleftrightarrow> C \\<noteq> {#}\"", "lemma card_le_one_alt: \"finite X \\<Longrightarrow> card X \\<le> 1 \\<longleftrightarrow> X = {} \\<or> (\\<exists>x. X = {x})\"", "lemma is_unifier_subst_atm_eqI:\n  assumes \"finite AA\"\n  shows \"is_unifier \\<sigma> AA \\<Longrightarrow> A \\<in> AA \\<Longrightarrow> B \\<in> AA \\<Longrightarrow> A \\<cdot>a \\<sigma> = B \\<cdot>a \\<sigma>\"", "lemma is_unifier_alt:\n  assumes \"finite AA\"\n  shows \"is_unifier \\<sigma> AA \\<longleftrightarrow> (\\<forall>A \\<in> AA. \\<forall>B \\<in> AA. A \\<cdot>a \\<sigma> = B \\<cdot>a \\<sigma>)\"", "lemma is_unifiers_subst_atm_eqI:\n  assumes \"finite AA\" \"is_unifiers \\<sigma> AAA\" \"AA \\<in> AAA\" \"A \\<in> AA\" \"B \\<in> AA\"\n  shows \"A \\<cdot>a \\<sigma> = B \\<cdot>a \\<sigma>\"", "theorem is_unifiers_comp:\n  \"is_unifiers \\<sigma> (set_mset ` set (map2 add_mset As Bs) \\<cdot>ass \\<eta>) \\<longleftrightarrow>\n   is_unifiers (\\<eta> \\<odot> \\<sigma>) (set_mset ` set (map2 add_mset As Bs))\"", "lemma is_mgu_is_unifiers: \"is_mgu \\<sigma> AAA \\<Longrightarrow> is_unifiers \\<sigma> AAA\"", "lemma is_mgu_is_most_general: \"is_mgu \\<sigma> AAA \\<Longrightarrow> is_unifiers \\<tau> AAA \\<Longrightarrow> \\<exists>\\<gamma>. \\<tau> = \\<sigma> \\<odot> \\<gamma>\"", "lemma is_unifiers_is_unifier: \"is_unifiers \\<sigma> AAA \\<Longrightarrow> AA \\<in> AAA \\<Longrightarrow> is_unifier \\<sigma> AA\"", "lemma variants_sym: \"variants D D' \\<longleftrightarrow> variants D' D\"", "lemma variants_iff_subsumes: \"variants C D \\<longleftrightarrow> subsumes C D \\<and> subsumes D C\"", "lemma wf_strictly_generalizes: \"wfP strictly_generalizes\"", "lemma strict_subset_subst_strictly_subsumes: \"C \\<cdot> \\<eta> \\<subset># D \\<Longrightarrow> strictly_subsumes C D\"", "lemma generalizes_refl: \"generalizes C C\"", "lemma generalizes_trans: \"generalizes C D \\<Longrightarrow> generalizes D E \\<Longrightarrow> generalizes C E\"", "lemma subsumes_refl: \"subsumes C C\"", "lemma subsumes_trans: \"subsumes C D \\<Longrightarrow> subsumes D E \\<Longrightarrow> subsumes C E\"", "lemma strictly_generalizes_irrefl: \"\\<not> strictly_generalizes C C\"", "lemma strictly_generalizes_antisym: \"strictly_generalizes C D \\<Longrightarrow> \\<not> strictly_generalizes D C\"", "lemma strictly_generalizes_trans:\n  \"strictly_generalizes C D \\<Longrightarrow> strictly_generalizes D E \\<Longrightarrow> strictly_generalizes C E\"", "lemma strictly_subsumes_irrefl: \"\\<not> strictly_subsumes C C\"", "lemma strictly_subsumes_antisym: \"strictly_subsumes C D \\<Longrightarrow> \\<not> strictly_subsumes D C\"", "lemma strictly_subsumes_trans:\n  \"strictly_subsumes C D \\<Longrightarrow> strictly_subsumes D E \\<Longrightarrow> strictly_subsumes C E\"", "lemma subset_strictly_subsumes: \"C \\<subset># D \\<Longrightarrow> strictly_subsumes C D\"", "lemma strictly_generalizes_neq: \"strictly_generalizes D' D \\<Longrightarrow> D' \\<noteq> D \\<cdot> \\<sigma>\"", "lemma strictly_subsumes_neq: \"strictly_subsumes D' D \\<Longrightarrow> D' \\<noteq> D \\<cdot> \\<sigma>\"", "lemma strictly_subsumes_has_minimum:\n  assumes \"CC \\<noteq> {}\"\n  shows \"\\<exists>C \\<in> CC. \\<forall>D \\<in> CC. \\<not> strictly_subsumes D C\"", "lemma wf_strictly_subsumes: \"wfP strictly_subsumes\"", "lemma variants_imp_exists_substitution: \"variants D D' \\<Longrightarrow> \\<exists>\\<sigma>. D \\<cdot> \\<sigma> = D'\"", "lemma strictly_subsumes_variants:\n  assumes \"strictly_subsumes E D\" and \"variants D D'\"\n  shows \"strictly_subsumes E D'\"", "lemma neg_strictly_subsumes_variants:\n  assumes \"\\<not> strictly_subsumes E D\" and \"variants D D'\"\n  shows \"\\<not> strictly_subsumes E D'\"", "lemmas is_unifiers_mgu = mgu_sound[unfolded is_mgu_def, THEN conjunct1]", "lemmas is_mgu_most_general = mgu_sound[unfolded is_mgu_def, THEN conjunct2]", "lemma mgu_unifier:\n  assumes\n    aslen: \"length As = n\" and\n    aaslen: \"length AAs = n\" and\n    mgu: \"Some \\<sigma> = mgu (set_mset ` set (map2 add_mset As AAs))\" and\n    i_lt: \"i < n\" and\n    a_in: \"A \\<in># AAs ! i\"\n  shows \"A \\<cdot>a \\<sigma> = As ! i \\<cdot>a \\<sigma>\""], "translations": [["", "lemma f_Suc_decr_eventually_const:\n  fixes f :: \"nat \\<Rightarrow> nat\"\n  assumes leq: \"\\<forall>i. f (Suc i) \\<le> f i\"\n  shows \"\\<exists>l. \\<forall>l' \\<ge> l. f l' = f (Suc l')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l. \\<forall>l'\\<ge>l. f l' = f (Suc l')", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>l. \\<forall>l'\\<ge>l. f l' = f (Suc l') \\<Longrightarrow>\n    False", "assume a: \"\\<nexists>l. \\<forall>l' \\<ge> l. f l' = f (Suc l')\""], ["proof (state)\nthis:\n  \\<nexists>l. \\<forall>l'\\<ge>l. f l' = f (Suc l')\n\ngoal (1 subgoal):\n 1. \\<nexists>l. \\<forall>l'\\<ge>l. f l' = f (Suc l') \\<Longrightarrow>\n    False", "have \"\\<forall>i. \\<exists>i'. i' > i \\<and> f i' < f i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. \\<exists>i'>i. f i' < f i", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. \\<exists>i'>i. f i' < f i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. \\<exists>i'>i. f i' < f i", "from a"], ["proof (chain)\npicking this:\n  \\<nexists>l. \\<forall>l'\\<ge>l. f l' = f (Suc l')", "have \"\\<exists>l' \\<ge> i. f l' \\<noteq> f (Suc l')\""], ["proof (prove)\nusing this:\n  \\<nexists>l. \\<forall>l'\\<ge>l. f l' = f (Suc l')\n\ngoal (1 subgoal):\n 1. \\<exists>l'\\<ge>i. f l' \\<noteq> f (Suc l')", "by auto"], ["proof (state)\nthis:\n  \\<exists>l'\\<ge>i. f l' \\<noteq> f (Suc l')\n\ngoal (1 subgoal):\n 1. \\<And>i. \\<exists>i'>i. f i' < f i", "then"], ["proof (chain)\npicking this:\n  \\<exists>l'\\<ge>i. f l' \\<noteq> f (Suc l')", "obtain l' where\n      l'_p: \"l' \\<ge> i \\<and> f l' \\<noteq> f (Suc l')\""], ["proof (prove)\nusing this:\n  \\<exists>l'\\<ge>i. f l' \\<noteq> f (Suc l')\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        i \\<le> l' \\<and> f l' \\<noteq> f (Suc l') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  i \\<le> l' \\<and> f l' \\<noteq> f (Suc l')\n\ngoal (1 subgoal):\n 1. \\<And>i. \\<exists>i'>i. f i' < f i", "then"], ["proof (chain)\npicking this:\n  i \\<le> l' \\<and> f l' \\<noteq> f (Suc l')", "have \"f l' > f (Suc l')\""], ["proof (prove)\nusing this:\n  i \\<le> l' \\<and> f l' \\<noteq> f (Suc l')\n\ngoal (1 subgoal):\n 1. f (Suc l') < f l'", "using leq le_eq_less_or_eq"], ["proof (prove)\nusing this:\n  i \\<le> l' \\<and> f l' \\<noteq> f (Suc l')\n  \\<forall>i. f (Suc i) \\<le> f i\n  (?m \\<le> ?n) = (?m < ?n \\<or> ?m = ?n)\n\ngoal (1 subgoal):\n 1. f (Suc l') < f l'", "by auto"], ["proof (state)\nthis:\n  f (Suc l') < f l'\n\ngoal (1 subgoal):\n 1. \\<And>i. \\<exists>i'>i. f i' < f i", "moreover"], ["proof (state)\nthis:\n  f (Suc l') < f l'\n\ngoal (1 subgoal):\n 1. \\<And>i. \\<exists>i'>i. f i' < f i", "have \"f i \\<ge> f l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f l' \\<le> f i", "using leq l'_p"], ["proof (prove)\nusing this:\n  \\<forall>i. f (Suc i) \\<le> f i\n  i \\<le> l' \\<and> f l' \\<noteq> f (Suc l')\n\ngoal (1 subgoal):\n 1. f l' \\<le> f i", "by (induction l' arbitrary: i) (blast intro: lift_Suc_antimono_le)+"], ["proof (state)\nthis:\n  f l' \\<le> f i\n\ngoal (1 subgoal):\n 1. \\<And>i. \\<exists>i'>i. f i' < f i", "ultimately"], ["proof (chain)\npicking this:\n  f (Suc l') < f l'\n  f l' \\<le> f i", "show \"\\<exists>i' > i. f i' < f i\""], ["proof (prove)\nusing this:\n  f (Suc l') < f l'\n  f l' \\<le> f i\n\ngoal (1 subgoal):\n 1. \\<exists>i'>i. f i' < f i", "using l'_p less_le_trans"], ["proof (prove)\nusing this:\n  f (Suc l') < f l'\n  f l' \\<le> f i\n  i \\<le> l' \\<and> f l' \\<noteq> f (Suc l')\n  \\<lbrakk>?x < ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n\ngoal (1 subgoal):\n 1. \\<exists>i'>i. f i' < f i", "by blast"], ["proof (state)\nthis:\n  \\<exists>i'>i. f i' < f i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i. \\<exists>i'>i. f i' < f i\n\ngoal (1 subgoal):\n 1. \\<nexists>l. \\<forall>l'\\<ge>l. f l' = f (Suc l') \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<forall>i. \\<exists>i'>i. f i' < f i", "obtain g_sm :: \"nat \\<Rightarrow> nat\" where\n    g_sm_p: \"\\<forall>i. g_sm i > i \\<and> f (g_sm i) < f i\""], ["proof (prove)\nusing this:\n  \\<forall>i. \\<exists>i'>i. f i' < f i\n\ngoal (1 subgoal):\n 1. (\\<And>g_sm.\n        \\<forall>i. i < g_sm i \\<and> f (g_sm i) < f i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  \\<forall>i. i < g_sm i \\<and> f (g_sm i) < f i\n\ngoal (1 subgoal):\n 1. \\<nexists>l. \\<forall>l'\\<ge>l. f l' = f (Suc l') \\<Longrightarrow>\n    False", "define c :: \"nat \\<Rightarrow> nat\" where\n    \"\\<And>n. c n = (g_sm ^^ n) 0\""], ["proof (state)\nthis:\n  c ?n = (g_sm ^^ ?n) 0\n\ngoal (1 subgoal):\n 1. \\<nexists>l. \\<forall>l'\\<ge>l. f l' = f (Suc l') \\<Longrightarrow>\n    False", "have \"f (c i) > f (c (Suc i))\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (c (Suc i)) < f (c i)", "by (induction i) (auto simp: c_def g_sm_p)"], ["proof (state)\nthis:\n  f (c (Suc ?i)) < f (c ?i)\n\ngoal (1 subgoal):\n 1. \\<nexists>l. \\<forall>l'\\<ge>l. f l' = f (Suc l') \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  f (c (Suc ?i)) < f (c ?i)", "have \"\\<forall>i. (f \\<circ> c) i > (f \\<circ> c) (Suc i)\""], ["proof (prove)\nusing this:\n  f (c (Suc ?i)) < f (c ?i)\n\ngoal (1 subgoal):\n 1. \\<forall>i. (f \\<circ> c) (Suc i) < (f \\<circ> c) i", "by auto"], ["proof (state)\nthis:\n  \\<forall>i. (f \\<circ> c) (Suc i) < (f \\<circ> c) i\n\ngoal (1 subgoal):\n 1. \\<nexists>l. \\<forall>l'\\<ge>l. f l' = f (Suc l') \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<forall>i. (f \\<circ> c) (Suc i) < (f \\<circ> c) i", "have \"\\<exists>fc :: nat \\<Rightarrow> nat. \\<forall>i. fc i > fc (Suc i)\""], ["proof (prove)\nusing this:\n  \\<forall>i. (f \\<circ> c) (Suc i) < (f \\<circ> c) i\n\ngoal (1 subgoal):\n 1. \\<exists>fc. \\<forall>i. fc (Suc i) < fc i", "by metis"], ["proof (state)\nthis:\n  \\<exists>fc. \\<forall>i. fc (Suc i) < fc i\n\ngoal (1 subgoal):\n 1. \\<nexists>l. \\<forall>l'\\<ge>l. f l' = f (Suc l') \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>fc. \\<forall>i. fc (Suc i) < fc i", "show False"], ["proof (prove)\nusing this:\n  \\<exists>fc. \\<forall>i. fc (Suc i) < fc i\n\ngoal (1 subgoal):\n 1. False", "using wf_less_than"], ["proof (prove)\nusing this:\n  \\<exists>fc. \\<forall>i. fc (Suc i) < fc i\n  wf less_than\n\ngoal (1 subgoal):\n 1. False", "by (simp add: wf_iff_no_infinite_down_chain)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Substitution Operators\\<close>"], ["", "locale substitution_ops =\n  fixes\n    subst_atm :: \"'a \\<Rightarrow> 's \\<Rightarrow> 'a\" and\n    id_subst :: 's and\n    comp_subst :: \"'s \\<Rightarrow> 's \\<Rightarrow> 's\"\nbegin"], ["", "abbreviation subst_atm_abbrev :: \"'a \\<Rightarrow> 's \\<Rightarrow> 'a\" (infixl \"\\<cdot>a\" 67) where\n  \"subst_atm_abbrev \\<equiv> subst_atm\""], ["", "abbreviation comp_subst_abbrev :: \"'s \\<Rightarrow> 's \\<Rightarrow> 's\" (infixl \"\\<odot>\" 67) where\n  \"comp_subst_abbrev \\<equiv> comp_subst\""], ["", "definition comp_substs :: \"'s list \\<Rightarrow> 's list \\<Rightarrow> 's list\" (infixl \"\\<odot>s\" 67) where\n  \"\\<sigma>s \\<odot>s \\<tau>s = map2 comp_subst \\<sigma>s \\<tau>s\""], ["", "definition subst_atms :: \"'a set \\<Rightarrow> 's \\<Rightarrow> 'a set\" (infixl \"\\<cdot>as\" 67) where\n  \"AA \\<cdot>as \\<sigma> = (\\<lambda>A. A \\<cdot>a \\<sigma>) ` AA\""], ["", "definition subst_atmss :: \"'a set set \\<Rightarrow> 's \\<Rightarrow> 'a set set\" (infixl \"\\<cdot>ass\" 67) where\n  \"AAA \\<cdot>ass \\<sigma> = (\\<lambda>AA. AA \\<cdot>as \\<sigma>) ` AAA\""], ["", "definition subst_atm_list :: \"'a list \\<Rightarrow> 's \\<Rightarrow> 'a list\" (infixl \"\\<cdot>al\" 67) where\n  \"As \\<cdot>al \\<sigma> = map (\\<lambda>A. A \\<cdot>a \\<sigma>) As\""], ["", "definition subst_atm_mset :: \"'a multiset \\<Rightarrow> 's \\<Rightarrow> 'a multiset\" (infixl \"\\<cdot>am\" 67) where\n  \"AA \\<cdot>am \\<sigma> = image_mset (\\<lambda>A. A \\<cdot>a \\<sigma>) AA\""], ["", "definition\n  subst_atm_mset_list :: \"'a multiset list \\<Rightarrow> 's \\<Rightarrow> 'a multiset list\" (infixl \"\\<cdot>aml\" 67)\nwhere\n  \"AAA \\<cdot>aml \\<sigma> = map (\\<lambda>AA. AA \\<cdot>am \\<sigma>) AAA\""], ["", "definition\n  subst_atm_mset_lists :: \"'a multiset list \\<Rightarrow> 's list \\<Rightarrow> 'a multiset list\" (infixl \"\\<cdot>\\<cdot>aml\" 67)\nwhere\n  \"AAs \\<cdot>\\<cdot>aml \\<sigma>s = map2 (\\<cdot>am) AAs \\<sigma>s\""], ["", "definition subst_lit :: \"'a literal \\<Rightarrow> 's \\<Rightarrow> 'a literal\" (infixl \"\\<cdot>l\" 67) where\n  \"L \\<cdot>l \\<sigma> = map_literal (\\<lambda>A. A \\<cdot>a \\<sigma>) L\""], ["", "lemma atm_of_subst_lit[simp]: \"atm_of (L \\<cdot>l \\<sigma>) = atm_of L \\<cdot>a \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atm_of (L \\<cdot>l \\<sigma>) = atm_of L \\<cdot>a \\<sigma>", "unfolding subst_lit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. atm_of (map_literal (\\<lambda>A. A \\<cdot>a \\<sigma>) L) =\n    atm_of L \\<cdot>a \\<sigma>", "by (cases L) simp+"], ["", "definition subst_cls :: \"'a clause \\<Rightarrow> 's \\<Rightarrow> 'a clause\" (infixl \"\\<cdot>\" 67) where\n  \"AA \\<cdot> \\<sigma> = image_mset (\\<lambda>A. A \\<cdot>l \\<sigma>) AA\""], ["", "definition subst_clss :: \"'a clause set \\<Rightarrow> 's \\<Rightarrow> 'a clause set\" (infixl \"\\<cdot>cs\" 67) where\n  \"AA \\<cdot>cs \\<sigma> = (\\<lambda>A. A \\<cdot> \\<sigma>) ` AA\""], ["", "definition subst_cls_list :: \"'a clause list \\<Rightarrow> 's \\<Rightarrow> 'a clause list\" (infixl \"\\<cdot>cl\" 67) where\n  \"Cs \\<cdot>cl \\<sigma> = map (\\<lambda>A. A \\<cdot> \\<sigma>) Cs\""], ["", "definition subst_cls_lists :: \"'a clause list \\<Rightarrow> 's list \\<Rightarrow> 'a clause list\" (infixl \"\\<cdot>\\<cdot>cl\" 67) where\n  \"Cs \\<cdot>\\<cdot>cl \\<sigma>s = map2 (\\<cdot>) Cs \\<sigma>s\""], ["", "definition subst_cls_mset :: \"'a clause multiset \\<Rightarrow> 's \\<Rightarrow> 'a clause multiset\" (infixl \"\\<cdot>cm\" 67) where\n  \"CC \\<cdot>cm \\<sigma> = image_mset (\\<lambda>A. A \\<cdot> \\<sigma>) CC\""], ["", "lemma subst_cls_add_mset[simp]: \"add_mset L C \\<cdot> \\<sigma> = add_mset (L \\<cdot>l \\<sigma>) (C \\<cdot> \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_mset L C \\<cdot> \\<sigma> =\n    add_mset (L \\<cdot>l \\<sigma>) (C \\<cdot> \\<sigma>)", "unfolding subst_cls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {#A \\<cdot>l \\<sigma>. A \\<in># add_mset L C#} =\n    add_mset (L \\<cdot>l \\<sigma>) {#A \\<cdot>l \\<sigma>. A \\<in># C#}", "by simp"], ["", "lemma subst_cls_mset_add_mset[simp]: \"add_mset C CC \\<cdot>cm \\<sigma> = add_mset (C \\<cdot> \\<sigma>) (CC \\<cdot>cm \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_mset C CC \\<cdot>cm \\<sigma> =\n    add_mset (C \\<cdot> \\<sigma>) (CC \\<cdot>cm \\<sigma>)", "unfolding subst_cls_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {#A \\<cdot> \\<sigma>. A \\<in># add_mset C CC#} =\n    add_mset (C \\<cdot> \\<sigma>) {#A \\<cdot> \\<sigma>. A \\<in># CC#}", "by simp"], ["", "definition generalizes_atm :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" where\n  \"generalizes_atm A B \\<longleftrightarrow> (\\<exists>\\<sigma>. A \\<cdot>a \\<sigma> = B)\""], ["", "definition strictly_generalizes_atm :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" where\n  \"strictly_generalizes_atm A B \\<longleftrightarrow> generalizes_atm A B \\<and> \\<not> generalizes_atm B A\""], ["", "definition generalizes_lit :: \"'a literal \\<Rightarrow> 'a literal \\<Rightarrow> bool\" where\n  \"generalizes_lit L M \\<longleftrightarrow> (\\<exists>\\<sigma>. L \\<cdot>l \\<sigma> = M)\""], ["", "definition strictly_generalizes_lit :: \"'a literal \\<Rightarrow> 'a literal \\<Rightarrow> bool\" where\n  \"strictly_generalizes_lit L M \\<longleftrightarrow> generalizes_lit L M \\<and> \\<not> generalizes_lit M L\""], ["", "definition generalizes :: \"'a clause \\<Rightarrow> 'a clause \\<Rightarrow> bool\" where\n  \"generalizes C D \\<longleftrightarrow> (\\<exists>\\<sigma>. C \\<cdot> \\<sigma> = D)\""], ["", "definition strictly_generalizes :: \"'a clause \\<Rightarrow> 'a clause \\<Rightarrow> bool\" where\n  \"strictly_generalizes C D \\<longleftrightarrow> generalizes C D \\<and> \\<not> generalizes D C\""], ["", "definition subsumes :: \"'a clause \\<Rightarrow> 'a clause \\<Rightarrow> bool\" where\n  \"subsumes C D \\<longleftrightarrow> (\\<exists>\\<sigma>. C \\<cdot> \\<sigma> \\<subseteq># D)\""], ["", "definition strictly_subsumes :: \"'a clause \\<Rightarrow> 'a clause \\<Rightarrow> bool\" where\n  \"strictly_subsumes C D \\<longleftrightarrow> subsumes C D \\<and> \\<not> subsumes D C\""], ["", "definition variants :: \"'a clause \\<Rightarrow> 'a clause \\<Rightarrow> bool\" where\n  \"variants C D \\<longleftrightarrow> generalizes C D \\<and> generalizes D C\""], ["", "definition is_renaming :: \"'s \\<Rightarrow> bool\" where\n  \"is_renaming \\<sigma> \\<longleftrightarrow> (\\<exists>\\<tau>. \\<sigma> \\<odot> \\<tau> = id_subst)\""], ["", "definition is_renaming_list :: \"'s list \\<Rightarrow> bool\" where\n  \"is_renaming_list \\<sigma>s \\<longleftrightarrow> (\\<forall>\\<sigma> \\<in> set \\<sigma>s. is_renaming \\<sigma>)\""], ["", "definition inv_renaming :: \"'s \\<Rightarrow> 's\" where\n  \"inv_renaming \\<sigma> = (SOME \\<tau>. \\<sigma> \\<odot> \\<tau> = id_subst)\""], ["", "definition is_ground_atm :: \"'a \\<Rightarrow> bool\" where\n  \"is_ground_atm A \\<longleftrightarrow> (\\<forall>\\<sigma>. A = A \\<cdot>a \\<sigma>)\""], ["", "definition is_ground_atms :: \"'a set \\<Rightarrow> bool\" where\n  \"is_ground_atms AA = (\\<forall>A \\<in> AA. is_ground_atm A)\""], ["", "definition is_ground_atm_list :: \"'a list \\<Rightarrow> bool\" where\n  \"is_ground_atm_list As \\<longleftrightarrow> (\\<forall>A \\<in> set As. is_ground_atm A)\""], ["", "definition is_ground_atm_mset :: \"'a multiset \\<Rightarrow> bool\" where\n  \"is_ground_atm_mset AA \\<longleftrightarrow> (\\<forall>A. A \\<in># AA \\<longrightarrow> is_ground_atm A)\""], ["", "definition is_ground_lit :: \"'a literal \\<Rightarrow> bool\" where\n  \"is_ground_lit L \\<longleftrightarrow> is_ground_atm (atm_of L)\""], ["", "definition is_ground_cls :: \"'a clause \\<Rightarrow> bool\" where\n  \"is_ground_cls C \\<longleftrightarrow> (\\<forall>L. L \\<in># C \\<longrightarrow> is_ground_lit L)\""], ["", "definition is_ground_clss :: \"'a clause set \\<Rightarrow> bool\" where\n  \"is_ground_clss CC \\<longleftrightarrow> (\\<forall>C \\<in> CC. is_ground_cls C)\""], ["", "definition is_ground_cls_list :: \"'a clause list \\<Rightarrow> bool\" where\n  \"is_ground_cls_list CC \\<longleftrightarrow> (\\<forall>C \\<in> set CC. is_ground_cls C)\""], ["", "definition is_ground_subst :: \"'s \\<Rightarrow> bool\" where\n  \"is_ground_subst \\<sigma> \\<longleftrightarrow> (\\<forall>A. is_ground_atm (A \\<cdot>a \\<sigma>))\""], ["", "definition is_ground_subst_list :: \"'s list \\<Rightarrow> bool\" where\n  \"is_ground_subst_list \\<sigma>s \\<longleftrightarrow> (\\<forall>\\<sigma> \\<in> set \\<sigma>s. is_ground_subst \\<sigma>)\""], ["", "definition grounding_of_cls :: \"'a clause \\<Rightarrow> 'a clause set\" where\n  \"grounding_of_cls C = {C \\<cdot> \\<sigma> |\\<sigma>. is_ground_subst \\<sigma>}\""], ["", "definition grounding_of_clss :: \"'a clause set \\<Rightarrow> 'a clause set\" where\n  \"grounding_of_clss CC = (\\<Union>C \\<in> CC. grounding_of_cls C)\""], ["", "definition is_unifier :: \"'s \\<Rightarrow> 'a set \\<Rightarrow> bool\" where\n  \"is_unifier \\<sigma> AA \\<longleftrightarrow> card (AA \\<cdot>as \\<sigma>) \\<le> 1\""], ["", "definition is_unifiers :: \"'s \\<Rightarrow> 'a set set \\<Rightarrow> bool\" where\n  \"is_unifiers \\<sigma> AAA \\<longleftrightarrow> (\\<forall>AA \\<in> AAA. is_unifier \\<sigma> AA)\""], ["", "definition is_mgu :: \"'s \\<Rightarrow> 'a set set \\<Rightarrow> bool\" where\n  \"is_mgu \\<sigma> AAA \\<longleftrightarrow> is_unifiers \\<sigma> AAA \\<and> (\\<forall>\\<tau>. is_unifiers \\<tau> AAA \\<longrightarrow> (\\<exists>\\<gamma>. \\<tau> = \\<sigma> \\<odot> \\<gamma>))\""], ["", "definition var_disjoint :: \"'a clause list \\<Rightarrow> bool\" where\n  \"var_disjoint Cs \\<longleftrightarrow>\n   (\\<forall>\\<sigma>s. length \\<sigma>s = length Cs \\<longrightarrow> (\\<exists>\\<tau>. \\<forall>i < length Cs. \\<forall>S. S \\<subseteq># Cs ! i \\<longrightarrow> S \\<cdot> \\<sigma>s ! i = S \\<cdot> \\<tau>))\""], ["", "end"], ["", "subsection \\<open>Substitution Lemmas\\<close>"], ["", "locale substitution = substitution_ops subst_atm id_subst comp_subst\n  for\n    subst_atm :: \"'a \\<Rightarrow> 's \\<Rightarrow> 'a\" and\n    id_subst :: 's and\n    comp_subst :: \"'s \\<Rightarrow> 's \\<Rightarrow> 's\" +\n  fixes\n    renamings_apart :: \"'a clause list \\<Rightarrow> 's list\" and\n    atm_of_atms :: \"'a list \\<Rightarrow> 'a\"\n  assumes\n    subst_atm_id_subst[simp]: \"A \\<cdot>a id_subst = A\" and\n    subst_atm_comp_subst[simp]: \"A \\<cdot>a (\\<sigma> \\<odot> \\<tau>) = (A \\<cdot>a \\<sigma>) \\<cdot>a \\<tau>\" and\n    subst_ext: \"(\\<And>A. A \\<cdot>a \\<sigma> = A \\<cdot>a \\<tau>) \\<Longrightarrow> \\<sigma> = \\<tau>\" and\n    make_ground_subst: \"is_ground_cls (C \\<cdot> \\<sigma>) \\<Longrightarrow> \\<exists>\\<tau>. is_ground_subst \\<tau> \\<and>C \\<cdot> \\<tau> = C \\<cdot> \\<sigma>\" and\n    wf_strictly_generalizes_atm: \"wfP strictly_generalizes_atm\" and\n    renamings_apart_length:  \"length (renamings_apart Cs) = length Cs\" and\n    renamings_apart_renaming: \"\\<rho> \\<in> set (renamings_apart Cs) \\<Longrightarrow> is_renaming \\<rho>\" and\n    renamings_apart_var_disjoint: \"var_disjoint (Cs \\<cdot>\\<cdot>cl (renamings_apart Cs))\" and\n    atm_of_atms_subst:\n      \"\\<And>As Bs. atm_of_atms As \\<cdot>a \\<sigma> = atm_of_atms Bs \\<longleftrightarrow> map (\\<lambda>A. A \\<cdot>a \\<sigma>) As = Bs\"\nbegin"], ["", "lemma subst_ext_iff: \"\\<sigma> = \\<tau> \\<longleftrightarrow> (\\<forall>A. A \\<cdot>a \\<sigma> = A \\<cdot>a \\<tau>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> = \\<tau>) =\n    (\\<forall>A. A \\<cdot>a \\<sigma> = A \\<cdot>a \\<tau>)", "by (blast intro: subst_ext)"], ["", "subsubsection \\<open>Identity Substitution\\<close>"], ["", "lemma id_subst_comp_subst[simp]: \"id_subst \\<odot> \\<sigma> = \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. id_subst \\<odot> \\<sigma> = \\<sigma>", "by (rule subst_ext) simp"], ["", "lemma comp_subst_id_subst[simp]: \"\\<sigma> \\<odot> id_subst = \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<odot> id_subst = \\<sigma>", "by (rule subst_ext) simp"], ["", "lemma id_subst_comp_substs[simp]: \"replicate (length \\<sigma>s) id_subst \\<odot>s \\<sigma>s = \\<sigma>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replicate (length \\<sigma>s) id_subst \\<odot>s \\<sigma>s = \\<sigma>s", "using comp_substs_def"], ["proof (prove)\nusing this:\n  ?\\<sigma>s \\<odot>s ?\\<tau>s = Map2.map2 (\\<odot>) ?\\<sigma>s ?\\<tau>s\n\ngoal (1 subgoal):\n 1. replicate (length \\<sigma>s) id_subst \\<odot>s \\<sigma>s = \\<sigma>s", "by (induction \\<sigma>s) auto"], ["", "lemma comp_substs_id_subst[simp]: \"\\<sigma>s \\<odot>s replicate (length \\<sigma>s) id_subst = \\<sigma>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma>s \\<odot>s replicate (length \\<sigma>s) id_subst = \\<sigma>s", "using comp_substs_def"], ["proof (prove)\nusing this:\n  ?\\<sigma>s \\<odot>s ?\\<tau>s = Map2.map2 (\\<odot>) ?\\<sigma>s ?\\<tau>s\n\ngoal (1 subgoal):\n 1. \\<sigma>s \\<odot>s replicate (length \\<sigma>s) id_subst = \\<sigma>s", "by (induction \\<sigma>s) auto"], ["", "lemma subst_atms_id_subst[simp]: \"AA \\<cdot>as id_subst = AA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AA \\<cdot>as id_subst = AA", "unfolding subst_atms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>A. A \\<cdot>a id_subst) ` AA = AA", "by simp"], ["", "lemma subst_atmss_id_subst[simp]: \"AAA \\<cdot>ass id_subst = AAA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AAA \\<cdot>ass id_subst = AAA", "unfolding subst_atmss_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>AA. AA \\<cdot>as id_subst) ` AAA = AAA", "by simp"], ["", "lemma subst_atm_list_id_subst[simp]: \"As \\<cdot>al id_subst = As\""], ["proof (prove)\ngoal (1 subgoal):\n 1. As \\<cdot>al id_subst = As", "unfolding subst_atm_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>A. A \\<cdot>a id_subst) As = As", "by auto"], ["", "lemma subst_atm_mset_id_subst[simp]: \"AA \\<cdot>am id_subst = AA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AA \\<cdot>am id_subst = AA", "unfolding subst_atm_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {#A \\<cdot>a id_subst. A \\<in># AA#} = AA", "by simp"], ["", "lemma subst_atm_mset_list_id_subst[simp]: \"AAs \\<cdot>aml id_subst = AAs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AAs \\<cdot>aml id_subst = AAs", "unfolding subst_atm_mset_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>AA. AA \\<cdot>am id_subst) AAs = AAs", "by simp"], ["", "lemma subst_atm_mset_lists_id_subst[simp]: \"AAs \\<cdot>\\<cdot>aml replicate (length AAs) id_subst = AAs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AAs \\<cdot>\\<cdot>aml replicate (length AAs) id_subst = AAs", "unfolding subst_atm_mset_lists_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Map2.map2 (\\<cdot>am) AAs (replicate (length AAs) id_subst) = AAs", "by (induct AAs) auto"], ["", "lemma subst_lit_id_subst[simp]: \"L \\<cdot>l id_subst = L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L \\<cdot>l id_subst = L", "unfolding subst_lit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_literal (\\<lambda>A. A \\<cdot>a id_subst) L = L", "by (simp add: literal.map_ident)"], ["", "lemma subst_cls_id_subst[simp]: \"C \\<cdot> id_subst = C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<cdot> id_subst = C", "unfolding subst_cls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {#A \\<cdot>l id_subst. A \\<in># C#} = C", "by simp"], ["", "lemma subst_clss_id_subst[simp]: \"CC \\<cdot>cs id_subst = CC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CC \\<cdot>cs id_subst = CC", "unfolding subst_clss_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>A. A \\<cdot> id_subst) ` CC = CC", "by simp"], ["", "lemma subst_cls_list_id_subst[simp]: \"Cs \\<cdot>cl id_subst = Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cs \\<cdot>cl id_subst = Cs", "unfolding subst_cls_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>A. A \\<cdot> id_subst) Cs = Cs", "by simp"], ["", "lemma subst_cls_lists_id_subst[simp]: \"Cs \\<cdot>\\<cdot>cl replicate (length Cs) id_subst = Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cs \\<cdot>\\<cdot>cl replicate (length Cs) id_subst = Cs", "unfolding subst_cls_lists_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Map2.map2 (\\<cdot>) Cs (replicate (length Cs) id_subst) = Cs", "by (induct Cs) auto"], ["", "lemma subst_cls_mset_id_subst[simp]: \"CC \\<cdot>cm id_subst = CC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CC \\<cdot>cm id_subst = CC", "unfolding subst_cls_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {#A \\<cdot> id_subst. A \\<in># CC#} = CC", "by simp"], ["", "subsubsection \\<open>Associativity of Composition\\<close>"], ["", "lemma comp_subst_assoc[simp]: \"\\<sigma> \\<odot> (\\<tau> \\<odot> \\<gamma>) = \\<sigma> \\<odot> \\<tau> \\<odot> \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<odot> (\\<tau> \\<odot> \\<gamma>) =\n    \\<sigma> \\<odot> \\<tau> \\<odot> \\<gamma>", "by (rule subst_ext) simp"], ["", "subsubsection \\<open>Compatibility of Substitution and Composition\\<close>"], ["", "lemma subst_atms_comp_subst[simp]: \"AA \\<cdot>as (\\<tau> \\<odot> \\<sigma>) = AA \\<cdot>as \\<tau> \\<cdot>as \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AA \\<cdot>as (\\<tau> \\<odot> \\<sigma>) =\n    AA \\<cdot>as \\<tau> \\<cdot>as \\<sigma>", "unfolding subst_atms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>A. A \\<cdot>a (\\<tau> \\<odot> \\<sigma>)) ` AA =\n    (\\<lambda>A. A \\<cdot>a \\<sigma>) ` (\\<lambda>A. A \\<cdot>a \\<tau>) ` AA", "by auto"], ["", "lemma subst_atmss_comp_subst[simp]: \"AAA \\<cdot>ass (\\<tau> \\<odot> \\<sigma>) = AAA \\<cdot>ass \\<tau> \\<cdot>ass \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AAA \\<cdot>ass (\\<tau> \\<odot> \\<sigma>) =\n    AAA \\<cdot>ass \\<tau> \\<cdot>ass \\<sigma>", "unfolding subst_atmss_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>AA. AA \\<cdot>as (\\<tau> \\<odot> \\<sigma>)) ` AAA =\n    (\\<lambda>AA. AA \\<cdot>as \\<sigma>) `\n    (\\<lambda>AA. AA \\<cdot>as \\<tau>) ` AAA", "by auto"], ["", "lemma subst_atm_list_comp_subst[simp]: \"As \\<cdot>al (\\<tau> \\<odot> \\<sigma>) = As \\<cdot>al \\<tau> \\<cdot>al \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. As \\<cdot>al (\\<tau> \\<odot> \\<sigma>) =\n    As \\<cdot>al \\<tau> \\<cdot>al \\<sigma>", "unfolding subst_atm_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>A. A \\<cdot>a (\\<tau> \\<odot> \\<sigma>)) As =\n    map (\\<lambda>A. A \\<cdot>a \\<sigma>)\n     (map (\\<lambda>A. A \\<cdot>a \\<tau>) As)", "by auto"], ["", "lemma subst_atm_mset_comp_subst[simp]: \"AA \\<cdot>am (\\<tau> \\<odot> \\<sigma>) = AA \\<cdot>am \\<tau> \\<cdot>am \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AA \\<cdot>am (\\<tau> \\<odot> \\<sigma>) =\n    AA \\<cdot>am \\<tau> \\<cdot>am \\<sigma>", "unfolding subst_atm_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {#A \\<cdot>a (\\<tau> \\<odot> \\<sigma>). A \\<in># AA#} =\n    {#A \\<cdot>a \\<sigma>. A \\<in># {#A \\<cdot>a \\<tau>. A \\<in># AA#}#}", "by auto"], ["", "lemma subst_atm_mset_list_comp_subst[simp]: \"AAs \\<cdot>aml (\\<tau> \\<odot> \\<sigma>) = (AAs \\<cdot>aml \\<tau>) \\<cdot>aml \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AAs \\<cdot>aml (\\<tau> \\<odot> \\<sigma>) =\n    AAs \\<cdot>aml \\<tau> \\<cdot>aml \\<sigma>", "unfolding subst_atm_mset_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>AA. AA \\<cdot>am (\\<tau> \\<odot> \\<sigma>)) AAs =\n    map (\\<lambda>AA. AA \\<cdot>am \\<sigma>)\n     (map (\\<lambda>AA. AA \\<cdot>am \\<tau>) AAs)", "by auto"], ["", "lemma subst_atm_mset_lists_comp_substs[simp]: \"AAs \\<cdot>\\<cdot>aml (\\<tau>s \\<odot>s \\<sigma>s) = AAs \\<cdot>\\<cdot>aml \\<tau>s \\<cdot>\\<cdot>aml \\<sigma>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AAs \\<cdot>\\<cdot>aml (\\<tau>s \\<odot>s \\<sigma>s) =\n    AAs \\<cdot>\\<cdot>aml \\<tau>s \\<cdot>\\<cdot>aml \\<sigma>s", "unfolding subst_atm_mset_lists_def comp_substs_def map_zip_map map_zip_map2 map_zip_assoc"], ["proof (prove)\ngoal (1 subgoal):\n 1. Map2.map2\n     (\\<lambda>x y.\n         case (x, case y of (x, xa) \\<Rightarrow> x \\<odot> xa) of\n         (x, xa) \\<Rightarrow> x \\<cdot>am xa)\n     AAs (zip \\<tau>s \\<sigma>s) =\n    Map2.map2\n     (\\<lambda>x (y, z).\n         case ((x, y), z) of\n         (x, y) \\<Rightarrow>\n           case (case x of (x, xa) \\<Rightarrow> x \\<cdot>am xa, y) of\n           (x, xa) \\<Rightarrow> x \\<cdot>am xa)\n     AAs (zip \\<tau>s \\<sigma>s)", "by (simp add: split_def)"], ["", "lemma subst_lit_comp_subst[simp]: \"L \\<cdot>l (\\<tau> \\<odot> \\<sigma>) = L \\<cdot>l \\<tau> \\<cdot>l \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L \\<cdot>l (\\<tau> \\<odot> \\<sigma>) =\n    L \\<cdot>l \\<tau> \\<cdot>l \\<sigma>", "unfolding subst_lit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_literal (\\<lambda>A. A \\<cdot>a (\\<tau> \\<odot> \\<sigma>)) L =\n    map_literal (\\<lambda>A. A \\<cdot>a \\<sigma>)\n     (map_literal (\\<lambda>A. A \\<cdot>a \\<tau>) L)", "by (auto simp: literal.map_comp o_def)"], ["", "lemma subst_cls_comp_subst[simp]: \"C \\<cdot> (\\<tau> \\<odot> \\<sigma>) = C \\<cdot> \\<tau> \\<cdot> \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<cdot> (\\<tau> \\<odot> \\<sigma>) = C \\<cdot> \\<tau> \\<cdot> \\<sigma>", "unfolding subst_cls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {#A \\<cdot>l (\\<tau> \\<odot> \\<sigma>). A \\<in># C#} =\n    {#A \\<cdot>l \\<sigma>. A \\<in># {#A \\<cdot>l \\<tau>. A \\<in># C#}#}", "by auto"], ["", "lemma subst_clsscomp_subst[simp]: \"CC \\<cdot>cs (\\<tau> \\<odot> \\<sigma>) = CC \\<cdot>cs \\<tau> \\<cdot>cs \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CC \\<cdot>cs (\\<tau> \\<odot> \\<sigma>) =\n    CC \\<cdot>cs \\<tau> \\<cdot>cs \\<sigma>", "unfolding subst_clss_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>A. A \\<cdot> (\\<tau> \\<odot> \\<sigma>)) ` CC =\n    (\\<lambda>A. A \\<cdot> \\<sigma>) ` (\\<lambda>A. A \\<cdot> \\<tau>) ` CC", "by auto"], ["", "lemma subst_cls_list_comp_subst[simp]: \"Cs \\<cdot>cl (\\<tau> \\<odot> \\<sigma>) = Cs \\<cdot>cl \\<tau> \\<cdot>cl \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cs \\<cdot>cl (\\<tau> \\<odot> \\<sigma>) =\n    Cs \\<cdot>cl \\<tau> \\<cdot>cl \\<sigma>", "unfolding subst_cls_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>A. A \\<cdot> (\\<tau> \\<odot> \\<sigma>)) Cs =\n    map (\\<lambda>A. A \\<cdot> \\<sigma>)\n     (map (\\<lambda>A. A \\<cdot> \\<tau>) Cs)", "by auto"], ["", "lemma subst_cls_lists_comp_substs[simp]: \"Cs \\<cdot>\\<cdot>cl (\\<tau>s \\<odot>s \\<sigma>s) = Cs \\<cdot>\\<cdot>cl \\<tau>s \\<cdot>\\<cdot>cl \\<sigma>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cs \\<cdot>\\<cdot>cl (\\<tau>s \\<odot>s \\<sigma>s) =\n    Cs \\<cdot>\\<cdot>cl \\<tau>s \\<cdot>\\<cdot>cl \\<sigma>s", "unfolding subst_cls_lists_def comp_substs_def map_zip_map map_zip_map2 map_zip_assoc"], ["proof (prove)\ngoal (1 subgoal):\n 1. Map2.map2\n     (\\<lambda>x y.\n         case (x, case y of (x, xa) \\<Rightarrow> x \\<odot> xa) of\n         (x, xa) \\<Rightarrow> x \\<cdot> xa)\n     Cs (zip \\<tau>s \\<sigma>s) =\n    Map2.map2\n     (\\<lambda>x (y, z).\n         case ((x, y), z) of\n         (x, y) \\<Rightarrow>\n           case (case x of (x, xa) \\<Rightarrow> x \\<cdot> xa, y) of\n           (x, xa) \\<Rightarrow> x \\<cdot> xa)\n     Cs (zip \\<tau>s \\<sigma>s)", "by (simp add: split_def)"], ["", "lemma subst_cls_mset_comp_subst[simp]: \"CC \\<cdot>cm (\\<tau> \\<odot> \\<sigma>) = CC \\<cdot>cm \\<tau> \\<cdot>cm \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CC \\<cdot>cm (\\<tau> \\<odot> \\<sigma>) =\n    CC \\<cdot>cm \\<tau> \\<cdot>cm \\<sigma>", "unfolding subst_cls_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {#A \\<cdot> (\\<tau> \\<odot> \\<sigma>). A \\<in># CC#} =\n    {#A \\<cdot> \\<sigma>. A \\<in># {#A \\<cdot> \\<tau>. A \\<in># CC#}#}", "by auto"], ["", "subsubsection \\<open>``Commutativity'' of Membership and Substitution\\<close>"], ["", "lemma Melem_subst_atm_mset[simp]: \"A \\<in># AA \\<cdot>am \\<sigma> \\<longleftrightarrow> (\\<exists>B. B \\<in># AA \\<and> A = B \\<cdot>a \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<in># AA \\<cdot>am \\<sigma>) =\n    (\\<exists>B. B \\<in># AA \\<and> A = B \\<cdot>a \\<sigma>)", "unfolding subst_atm_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<in># {#A \\<cdot>a \\<sigma>. A \\<in># AA#}) =\n    (\\<exists>B. B \\<in># AA \\<and> A = B \\<cdot>a \\<sigma>)", "by auto"], ["", "lemma Melem_subst_cls[simp]: \"L \\<in># C \\<cdot> \\<sigma> \\<longleftrightarrow> (\\<exists>M. M \\<in># C \\<and> L = M \\<cdot>l \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (L \\<in># C \\<cdot> \\<sigma>) =\n    (\\<exists>M. M \\<in># C \\<and> L = M \\<cdot>l \\<sigma>)", "unfolding subst_cls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (L \\<in># {#A \\<cdot>l \\<sigma>. A \\<in># C#}) =\n    (\\<exists>M. M \\<in># C \\<and> L = M \\<cdot>l \\<sigma>)", "by auto"], ["", "lemma Melem_subst_cls_mset[simp]: \"AA \\<in># CC \\<cdot>cm \\<sigma> \\<longleftrightarrow> (\\<exists>BB. BB \\<in># CC \\<and> AA = BB \\<cdot> \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (AA \\<in># CC \\<cdot>cm \\<sigma>) =\n    (\\<exists>BB. BB \\<in># CC \\<and> AA = BB \\<cdot> \\<sigma>)", "unfolding subst_cls_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (AA \\<in># {#A \\<cdot> \\<sigma>. A \\<in># CC#}) =\n    (\\<exists>BB. BB \\<in># CC \\<and> AA = BB \\<cdot> \\<sigma>)", "by auto"], ["", "subsubsection \\<open>Signs and Substitutions\\<close>"], ["", "lemma subst_lit_is_neg[simp]: \"is_neg (L \\<cdot>l \\<sigma>) = is_neg L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_neg (L \\<cdot>l \\<sigma>) = is_neg L", "unfolding subst_lit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_neg (map_literal (\\<lambda>A. A \\<cdot>a \\<sigma>) L) = is_neg L", "by auto"], ["", "lemma subst_lit_is_pos[simp]: \"is_pos (L \\<cdot>l \\<sigma>) = is_pos L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pos (L \\<cdot>l \\<sigma>) = is_pos L", "unfolding subst_lit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pos (map_literal (\\<lambda>A. A \\<cdot>a \\<sigma>) L) = is_pos L", "by auto"], ["", "lemma subst_minus[simp]: \"(- L) \\<cdot>l \\<mu> = - (L  \\<cdot>l \\<mu>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - L \\<cdot>l \\<mu> = - (L \\<cdot>l \\<mu>)", "by (simp add: literal.map_sel subst_lit_def uminus_literal_def)"], ["", "subsubsection \\<open>Substitution on Literal(s)\\<close>"], ["", "lemma eql_neg_lit_eql_atm[simp]: \"(Neg A' \\<cdot>l \\<eta>) = Neg A \\<longleftrightarrow> A' \\<cdot>a \\<eta> = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Neg A' \\<cdot>l \\<eta> = Neg A) = (A' \\<cdot>a \\<eta> = A)", "by (simp add: subst_lit_def)"], ["", "lemma eql_pos_lit_eql_atm[simp]: \"(Pos A' \\<cdot>l \\<eta>) = Pos A \\<longleftrightarrow> A' \\<cdot>a \\<eta> = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Pos A' \\<cdot>l \\<eta> = Pos A) = (A' \\<cdot>a \\<eta> = A)", "by (simp add: subst_lit_def)"], ["", "lemma subst_cls_negs[simp]: \"(negs AA) \\<cdot> \\<sigma> = negs (AA \\<cdot>am \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. negs AA \\<cdot> \\<sigma> = negs (AA \\<cdot>am \\<sigma>)", "unfolding subst_cls_def subst_lit_def subst_atm_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_clause (\\<lambda>A. A \\<cdot>a \\<sigma>) (negs AA) =\n    negs {#A \\<cdot>a \\<sigma>. A \\<in># AA#}", "by auto"], ["", "lemma subst_cls_poss[simp]: \"(poss AA) \\<cdot> \\<sigma> = poss (AA \\<cdot>am \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poss AA \\<cdot> \\<sigma> = poss (AA \\<cdot>am \\<sigma>)", "unfolding subst_cls_def subst_lit_def subst_atm_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_clause (\\<lambda>A. A \\<cdot>a \\<sigma>) (poss AA) =\n    poss {#A \\<cdot>a \\<sigma>. A \\<in># AA#}", "by auto"], ["", "lemma atms_of_subst_atms: \"atms_of C \\<cdot>as \\<sigma> = atms_of (C \\<cdot> \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atms_of C \\<cdot>as \\<sigma> = atms_of (C \\<cdot> \\<sigma>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. atms_of C \\<cdot>as \\<sigma> = atms_of (C \\<cdot> \\<sigma>)", "have \"atms_of (C \\<cdot> \\<sigma>) = set_mset (image_mset atm_of (image_mset (map_literal (\\<lambda>A. A \\<cdot>a \\<sigma>)) C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atms_of (C \\<cdot> \\<sigma>) =\n    set_mset\n     (image_mset atm_of (map_clause (\\<lambda>A. A \\<cdot>a \\<sigma>) C))", "unfolding subst_cls_def subst_atms_def subst_lit_def atms_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. atm_of ` set_mset (map_clause (\\<lambda>A. A \\<cdot>a \\<sigma>) C) =\n    set_mset\n     (image_mset atm_of (map_clause (\\<lambda>A. A \\<cdot>a \\<sigma>) C))", "by auto"], ["proof (state)\nthis:\n  atms_of (C \\<cdot> \\<sigma>) =\n  set_mset\n   (image_mset atm_of (map_clause (\\<lambda>A. A \\<cdot>a \\<sigma>) C))\n\ngoal (1 subgoal):\n 1. atms_of C \\<cdot>as \\<sigma> = atms_of (C \\<cdot> \\<sigma>)", "also"], ["proof (state)\nthis:\n  atms_of (C \\<cdot> \\<sigma>) =\n  set_mset\n   (image_mset atm_of (map_clause (\\<lambda>A. A \\<cdot>a \\<sigma>) C))\n\ngoal (1 subgoal):\n 1. atms_of C \\<cdot>as \\<sigma> = atms_of (C \\<cdot> \\<sigma>)", "have \"... = set_mset (image_mset (\\<lambda>A. A \\<cdot>a \\<sigma>) (image_mset atm_of C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_mset\n     (image_mset atm_of (map_clause (\\<lambda>A. A \\<cdot>a \\<sigma>) C)) =\n    set_mset {#A \\<cdot>a \\<sigma>. A \\<in># image_mset atm_of C#}", "by simp (meson literal.map_sel)"], ["proof (state)\nthis:\n  set_mset\n   (image_mset atm_of (map_clause (\\<lambda>A. A \\<cdot>a \\<sigma>) C)) =\n  set_mset {#A \\<cdot>a \\<sigma>. A \\<in># image_mset atm_of C#}\n\ngoal (1 subgoal):\n 1. atms_of C \\<cdot>as \\<sigma> = atms_of (C \\<cdot> \\<sigma>)", "finally"], ["proof (chain)\npicking this:\n  atms_of (C \\<cdot> \\<sigma>) =\n  set_mset {#A \\<cdot>a \\<sigma>. A \\<in># image_mset atm_of C#}", "show \"atms_of C \\<cdot>as \\<sigma> = atms_of (C \\<cdot> \\<sigma>)\""], ["proof (prove)\nusing this:\n  atms_of (C \\<cdot> \\<sigma>) =\n  set_mset {#A \\<cdot>a \\<sigma>. A \\<in># image_mset atm_of C#}\n\ngoal (1 subgoal):\n 1. atms_of C \\<cdot>as \\<sigma> = atms_of (C \\<cdot> \\<sigma>)", "unfolding subst_atms_def atms_of_def"], ["proof (prove)\nusing this:\n  atm_of ` set_mset (C \\<cdot> \\<sigma>) =\n  set_mset {#A \\<cdot>a \\<sigma>. A \\<in># image_mset atm_of C#}\n\ngoal (1 subgoal):\n 1. (\\<lambda>A. A \\<cdot>a \\<sigma>) ` atm_of ` set_mset C =\n    atm_of ` set_mset (C \\<cdot> \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  atms_of C \\<cdot>as \\<sigma> = atms_of (C \\<cdot> \\<sigma>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_image_Neg_is_neg[simp]: \"L \\<cdot>l \\<sigma> \\<in> Neg ` AA \\<Longrightarrow> is_neg L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L \\<cdot>l \\<sigma> \\<in> Neg ` AA \\<Longrightarrow> is_neg L", "by (metis bex_imageD literal.disc(2) literal.map_disc_iff subst_lit_def)"], ["", "lemma subst_lit_in_negs_subst_is_neg: \"L \\<cdot>l \\<sigma> \\<in># (negs AA) \\<cdot> \\<tau> \\<Longrightarrow> is_neg L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L \\<cdot>l \\<sigma> \\<in># negs AA \\<cdot> \\<tau> \\<Longrightarrow>\n    is_neg L", "by simp"], ["", "lemma subst_lit_in_negs_is_neg: \"L \\<cdot>l \\<sigma> \\<in># negs AA \\<Longrightarrow> is_neg L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L \\<cdot>l \\<sigma> \\<in># negs AA \\<Longrightarrow> is_neg L", "by simp"], ["", "subsubsection \\<open>Substitution on Empty\\<close>"], ["", "lemma subst_atms_empty[simp]: \"{} \\<cdot>as \\<sigma> = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<cdot>as \\<sigma> = {}", "unfolding subst_atms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>A. A \\<cdot>a \\<sigma>) ` {} = {}", "by auto"], ["", "lemma subst_atmss_empty[simp]: \"{} \\<cdot>ass \\<sigma> = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<cdot>ass \\<sigma> = {}", "unfolding subst_atmss_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>AA. AA \\<cdot>as \\<sigma>) ` {} = {}", "by auto"], ["", "lemma comp_substs_empty_iff[simp]: \"\\<sigma>s \\<odot>s \\<eta>s = [] \\<longleftrightarrow> \\<sigma>s = [] \\<or> \\<eta>s = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma>s \\<odot>s \\<eta>s = []) = (\\<sigma>s = [] \\<or> \\<eta>s = [])", "using comp_substs_def map2_empty_iff"], ["proof (prove)\nusing this:\n  ?\\<sigma>s \\<odot>s ?\\<tau>s = Map2.map2 (\\<odot>) ?\\<sigma>s ?\\<tau>s\n  (Map2.map2 ?f ?xs ?ys = []) = (?xs = [] \\<or> ?ys = [])\n\ngoal (1 subgoal):\n 1. (\\<sigma>s \\<odot>s \\<eta>s = []) = (\\<sigma>s = [] \\<or> \\<eta>s = [])", "by auto"], ["", "lemma subst_atm_list_empty[simp]: \"[] \\<cdot>al \\<sigma> = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<cdot>al \\<sigma> = []", "unfolding subst_atm_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>A. A \\<cdot>a \\<sigma>) [] = []", "by auto"], ["", "lemma subst_atm_mset_empty[simp]: \"{#} \\<cdot>am \\<sigma> = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#} \\<cdot>am \\<sigma> = {#}", "unfolding subst_atm_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {#A \\<cdot>a \\<sigma>. A \\<in># {#}#} = {#}", "by auto"], ["", "lemma subst_atm_mset_list_empty[simp]: \"[] \\<cdot>aml \\<sigma> = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<cdot>aml \\<sigma> = []", "unfolding subst_atm_mset_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>AA. AA \\<cdot>am \\<sigma>) [] = []", "by auto"], ["", "lemma subst_atm_mset_lists_empty[simp]: \"[] \\<cdot>\\<cdot>aml \\<sigma>s = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<cdot>\\<cdot>aml \\<sigma>s = []", "unfolding subst_atm_mset_lists_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Map2.map2 (\\<cdot>am) [] \\<sigma>s = []", "by auto"], ["", "lemma subst_cls_empty[simp]: \"{#} \\<cdot> \\<sigma> = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#} \\<cdot> \\<sigma> = {#}", "unfolding subst_cls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {#A \\<cdot>l \\<sigma>. A \\<in># {#}#} = {#}", "by auto"], ["", "lemma subst_clss_empty[simp]: \"{} \\<cdot>cs \\<sigma> = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<cdot>cs \\<sigma> = {}", "unfolding subst_clss_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>A. A \\<cdot> \\<sigma>) ` {} = {}", "by auto"], ["", "lemma subst_cls_list_empty[simp]: \"[] \\<cdot>cl \\<sigma> = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<cdot>cl \\<sigma> = []", "unfolding subst_cls_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>A. A \\<cdot> \\<sigma>) [] = []", "by auto"], ["", "lemma subst_cls_lists_empty[simp]: \"[] \\<cdot>\\<cdot>cl \\<sigma>s = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<cdot>\\<cdot>cl \\<sigma>s = []", "unfolding subst_cls_lists_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Map2.map2 (\\<cdot>) [] \\<sigma>s = []", "by auto"], ["", "lemma subst_scls_mset_empty[simp]: \"{#} \\<cdot>cm \\<sigma> = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#} \\<cdot>cm \\<sigma> = {#}", "unfolding subst_cls_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {#A \\<cdot> \\<sigma>. A \\<in># {#}#} = {#}", "by auto"], ["", "lemma subst_atms_empty_iff[simp]: \"AA \\<cdot>as \\<eta> = {} \\<longleftrightarrow> AA = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (AA \\<cdot>as \\<eta> = {}) = (AA = {})", "unfolding subst_atms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>A. A \\<cdot>a \\<eta>) ` AA = {}) = (AA = {})", "by auto"], ["", "lemma subst_atmss_empty_iff[simp]: \"AAA \\<cdot>ass \\<eta> = {} \\<longleftrightarrow> AAA = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (AAA \\<cdot>ass \\<eta> = {}) = (AAA = {})", "unfolding subst_atmss_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>AA. AA \\<cdot>as \\<eta>) ` AAA = {}) = (AAA = {})", "by auto"], ["", "lemma subst_atm_list_empty_iff[simp]: \"As \\<cdot>al \\<eta> = [] \\<longleftrightarrow> As = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (As \\<cdot>al \\<eta> = []) = (As = [])", "unfolding subst_atm_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map (\\<lambda>A. A \\<cdot>a \\<eta>) As = []) = (As = [])", "by auto"], ["", "lemma subst_atm_mset_empty_iff[simp]: \"AA \\<cdot>am \\<eta> = {#} \\<longleftrightarrow> AA = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (AA \\<cdot>am \\<eta> = {#}) = (AA = {#})", "unfolding subst_atm_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ({#A \\<cdot>a \\<eta>. A \\<in># AA#} = {#}) = (AA = {#})", "by auto"], ["", "lemma subst_atm_mset_list_empty_iff[simp]: \"AAs \\<cdot>aml \\<eta> = [] \\<longleftrightarrow> AAs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (AAs \\<cdot>aml \\<eta> = []) = (AAs = [])", "unfolding subst_atm_mset_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map (\\<lambda>AA. AA \\<cdot>am \\<eta>) AAs = []) = (AAs = [])", "by auto"], ["", "lemma subst_atm_mset_lists_empty_iff[simp]: \"AAs \\<cdot>\\<cdot>aml \\<eta>s = [] \\<longleftrightarrow> (AAs = [] \\<or> \\<eta>s = [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (AAs \\<cdot>\\<cdot>aml \\<eta>s = []) = (AAs = [] \\<or> \\<eta>s = [])", "using map2_empty_iff subst_atm_mset_lists_def"], ["proof (prove)\nusing this:\n  (Map2.map2 ?f ?xs ?ys = []) = (?xs = [] \\<or> ?ys = [])\n  ?AAs \\<cdot>\\<cdot>aml ?\\<sigma>s = Map2.map2 (\\<cdot>am) ?AAs ?\\<sigma>s\n\ngoal (1 subgoal):\n 1. (AAs \\<cdot>\\<cdot>aml \\<eta>s = []) = (AAs = [] \\<or> \\<eta>s = [])", "by auto"], ["", "lemma subst_cls_empty_iff[simp]: \"C \\<cdot> \\<eta> = {#} \\<longleftrightarrow> C = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (C \\<cdot> \\<eta> = {#}) = (C = {#})", "unfolding subst_cls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ({#A \\<cdot>l \\<eta>. A \\<in># C#} = {#}) = (C = {#})", "by auto"], ["", "lemma subst_clss_empty_iff[simp]: \"CC \\<cdot>cs \\<eta> = {} \\<longleftrightarrow> CC = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (CC \\<cdot>cs \\<eta> = {}) = (CC = {})", "unfolding subst_clss_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>A. A \\<cdot> \\<eta>) ` CC = {}) = (CC = {})", "by auto"], ["", "lemma subst_cls_list_empty_iff[simp]: \"Cs \\<cdot>cl \\<eta> = [] \\<longleftrightarrow> Cs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Cs \\<cdot>cl \\<eta> = []) = (Cs = [])", "unfolding subst_cls_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map (\\<lambda>A. A \\<cdot> \\<eta>) Cs = []) = (Cs = [])", "by auto"], ["", "lemma subst_cls_lists_empty_iff[simp]: \"Cs \\<cdot>\\<cdot>cl \\<eta>s = [] \\<longleftrightarrow> Cs = [] \\<or> \\<eta>s = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Cs \\<cdot>\\<cdot>cl \\<eta>s = []) = (Cs = [] \\<or> \\<eta>s = [])", "using map2_empty_iff subst_cls_lists_def"], ["proof (prove)\nusing this:\n  (Map2.map2 ?f ?xs ?ys = []) = (?xs = [] \\<or> ?ys = [])\n  ?Cs \\<cdot>\\<cdot>cl ?\\<sigma>s = Map2.map2 (\\<cdot>) ?Cs ?\\<sigma>s\n\ngoal (1 subgoal):\n 1. (Cs \\<cdot>\\<cdot>cl \\<eta>s = []) = (Cs = [] \\<or> \\<eta>s = [])", "by auto"], ["", "lemma subst_cls_mset_empty_iff[simp]: \"CC \\<cdot>cm \\<eta> = {#} \\<longleftrightarrow> CC = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (CC \\<cdot>cm \\<eta> = {#}) = (CC = {#})", "unfolding subst_cls_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ({#A \\<cdot> \\<eta>. A \\<in># CC#} = {#}) = (CC = {#})", "by auto"], ["", "subsubsection \\<open>Substitution on a Union\\<close>"], ["", "lemma subst_atms_union[simp]: \"(AA \\<union> BB) \\<cdot>as \\<sigma> = AA \\<cdot>as \\<sigma> \\<union> BB \\<cdot>as \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (AA \\<union> BB) \\<cdot>as \\<sigma> =\n    AA \\<cdot>as \\<sigma> \\<union> BB \\<cdot>as \\<sigma>", "unfolding subst_atms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>A. A \\<cdot>a \\<sigma>) ` (AA \\<union> BB) =\n    (\\<lambda>A. A \\<cdot>a \\<sigma>) ` AA \\<union>\n    (\\<lambda>A. A \\<cdot>a \\<sigma>) ` BB", "by auto"], ["", "lemma subst_atmss_union[simp]: \"(AAA \\<union> BBB) \\<cdot>ass \\<sigma> = AAA \\<cdot>ass \\<sigma> \\<union> BBB \\<cdot>ass \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (AAA \\<union> BBB) \\<cdot>ass \\<sigma> =\n    AAA \\<cdot>ass \\<sigma> \\<union> BBB \\<cdot>ass \\<sigma>", "unfolding subst_atmss_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>AA. AA \\<cdot>as \\<sigma>) ` (AAA \\<union> BBB) =\n    (\\<lambda>AA. AA \\<cdot>as \\<sigma>) ` AAA \\<union>\n    (\\<lambda>AA. AA \\<cdot>as \\<sigma>) ` BBB", "by auto"], ["", "lemma subst_atm_list_append[simp]: \"(As @ Bs) \\<cdot>al \\<sigma> = As \\<cdot>al \\<sigma> @ Bs \\<cdot>al \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (As @ Bs) \\<cdot>al \\<sigma> =\n    As \\<cdot>al \\<sigma> @ Bs \\<cdot>al \\<sigma>", "unfolding subst_atm_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>A. A \\<cdot>a \\<sigma>) (As @ Bs) =\n    map (\\<lambda>A. A \\<cdot>a \\<sigma>) As @\n    map (\\<lambda>A. A \\<cdot>a \\<sigma>) Bs", "by auto"], ["", "lemma subst_atm_mset_union[simp]: \"(AA + BB) \\<cdot>am \\<sigma> = AA \\<cdot>am \\<sigma> + BB \\<cdot>am \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (AA + BB) \\<cdot>am \\<sigma> =\n    AA \\<cdot>am \\<sigma> + BB \\<cdot>am \\<sigma>", "unfolding subst_atm_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {#A \\<cdot>a \\<sigma>. A \\<in># AA + BB#} =\n    {#A \\<cdot>a \\<sigma>. A \\<in># AA#} +\n    {#A \\<cdot>a \\<sigma>. A \\<in># BB#}", "by auto"], ["", "lemma subst_atm_mset_list_append[simp]: \"(AAs @ BBs) \\<cdot>aml \\<sigma> = AAs \\<cdot>aml \\<sigma> @ BBs \\<cdot>aml \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (AAs @ BBs) \\<cdot>aml \\<sigma> =\n    AAs \\<cdot>aml \\<sigma> @ BBs \\<cdot>aml \\<sigma>", "unfolding subst_atm_mset_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>AA. AA \\<cdot>am \\<sigma>) (AAs @ BBs) =\n    map (\\<lambda>AA. AA \\<cdot>am \\<sigma>) AAs @\n    map (\\<lambda>AA. AA \\<cdot>am \\<sigma>) BBs", "by auto"], ["", "lemma subst_cls_union[simp]: \"(C + D) \\<cdot> \\<sigma> = C \\<cdot> \\<sigma> + D \\<cdot> \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (C + D) \\<cdot> \\<sigma> = C \\<cdot> \\<sigma> + D \\<cdot> \\<sigma>", "unfolding subst_cls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {#A \\<cdot>l \\<sigma>. A \\<in># C + D#} =\n    {#A \\<cdot>l \\<sigma>. A \\<in># C#} +\n    {#A \\<cdot>l \\<sigma>. A \\<in># D#}", "by auto"], ["", "lemma subst_clss_union[simp]: \"(CC \\<union> DD) \\<cdot>cs \\<sigma> = CC \\<cdot>cs \\<sigma> \\<union> DD \\<cdot>cs \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (CC \\<union> DD) \\<cdot>cs \\<sigma> =\n    CC \\<cdot>cs \\<sigma> \\<union> DD \\<cdot>cs \\<sigma>", "unfolding subst_clss_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>A. A \\<cdot> \\<sigma>) ` (CC \\<union> DD) =\n    (\\<lambda>A. A \\<cdot> \\<sigma>) ` CC \\<union>\n    (\\<lambda>A. A \\<cdot> \\<sigma>) ` DD", "by auto"], ["", "lemma subst_cls_list_append[simp]: \"(Cs @ Ds) \\<cdot>cl \\<sigma> = Cs \\<cdot>cl \\<sigma> @ Ds \\<cdot>cl \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Cs @ Ds) \\<cdot>cl \\<sigma> =\n    Cs \\<cdot>cl \\<sigma> @ Ds \\<cdot>cl \\<sigma>", "unfolding subst_cls_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>A. A \\<cdot> \\<sigma>) (Cs @ Ds) =\n    map (\\<lambda>A. A \\<cdot> \\<sigma>) Cs @\n    map (\\<lambda>A. A \\<cdot> \\<sigma>) Ds", "by auto"], ["", "lemma subst_cls_lists_append[simp]:\n  \"length Cs = length \\<sigma>s \\<Longrightarrow> length Cs' = length \\<sigma>s' \\<Longrightarrow>\n   (Cs @ Cs') \\<cdot>\\<cdot>cl (\\<sigma>s @ \\<sigma>s') = Cs \\<cdot>\\<cdot>cl \\<sigma>s @ Cs' \\<cdot>\\<cdot>cl \\<sigma>s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length Cs = length \\<sigma>s;\n     length Cs' = length \\<sigma>s'\\<rbrakk>\n    \\<Longrightarrow> (Cs @ Cs') \\<cdot>\\<cdot>cl (\\<sigma>s @ \\<sigma>s') =\n                      Cs \\<cdot>\\<cdot>cl \\<sigma>s @\n                      Cs' \\<cdot>\\<cdot>cl \\<sigma>s'", "unfolding subst_cls_lists_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length Cs = length \\<sigma>s;\n     length Cs' = length \\<sigma>s'\\<rbrakk>\n    \\<Longrightarrow> Map2.map2 (\\<cdot>) (Cs @ Cs')\n                       (\\<sigma>s @ \\<sigma>s') =\n                      Map2.map2 (\\<cdot>) Cs \\<sigma>s @\n                      Map2.map2 (\\<cdot>) Cs' \\<sigma>s'", "by auto"], ["", "lemma subst_cls_mset_union[simp]: \"(CC + DD) \\<cdot>cm \\<sigma> = CC \\<cdot>cm \\<sigma> + DD \\<cdot>cm \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (CC + DD) \\<cdot>cm \\<sigma> =\n    CC \\<cdot>cm \\<sigma> + DD \\<cdot>cm \\<sigma>", "unfolding subst_cls_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {#A \\<cdot> \\<sigma>. A \\<in># CC + DD#} =\n    {#A \\<cdot> \\<sigma>. A \\<in># CC#} +\n    {#A \\<cdot> \\<sigma>. A \\<in># DD#}", "by auto"], ["", "subsubsection \\<open>Substitution on a Singleton\\<close>"], ["", "lemma subst_atms_single[simp]: \"{A} \\<cdot>as \\<sigma> = {A \\<cdot>a \\<sigma>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {A} \\<cdot>as \\<sigma> = {A \\<cdot>a \\<sigma>}", "unfolding subst_atms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>A. A \\<cdot>a \\<sigma>) ` {A} = {A \\<cdot>a \\<sigma>}", "by auto"], ["", "lemma subst_atmss_single[simp]: \"{AA} \\<cdot>ass \\<sigma> = {AA \\<cdot>as \\<sigma>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {AA} \\<cdot>ass \\<sigma> = {AA \\<cdot>as \\<sigma>}", "unfolding subst_atmss_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>AA. AA \\<cdot>as \\<sigma>) ` {AA} = {AA \\<cdot>as \\<sigma>}", "by auto"], ["", "lemma subst_atm_list_single[simp]: \"[A] \\<cdot>al \\<sigma> = [A \\<cdot>a \\<sigma>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [A] \\<cdot>al \\<sigma> = [A \\<cdot>a \\<sigma>]", "unfolding subst_atm_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>A. A \\<cdot>a \\<sigma>) [A] = [A \\<cdot>a \\<sigma>]", "by auto"], ["", "lemma subst_atm_mset_single[simp]: \"{#A#} \\<cdot>am \\<sigma> = {#A \\<cdot>a \\<sigma>#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#A#} \\<cdot>am \\<sigma> = {#A \\<cdot>a \\<sigma>#}", "unfolding subst_atm_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {#A \\<cdot>a \\<sigma>. A \\<in># {#A#}#} = {#A \\<cdot>a \\<sigma>#}", "by auto"], ["", "lemma subst_atm_mset_list[simp]: \"[AA] \\<cdot>aml \\<sigma> = [AA \\<cdot>am \\<sigma>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [AA] \\<cdot>aml \\<sigma> = [AA \\<cdot>am \\<sigma>]", "unfolding subst_atm_mset_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>AA. AA \\<cdot>am \\<sigma>) [AA] = [AA \\<cdot>am \\<sigma>]", "by auto"], ["", "lemma subst_cls_single[simp]: \"{#L#} \\<cdot> \\<sigma> = {#L \\<cdot>l \\<sigma>#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#L#} \\<cdot> \\<sigma> = {#L \\<cdot>l \\<sigma>#}", "by simp"], ["", "lemma subst_clss_single[simp]: \"{C} \\<cdot>cs \\<sigma> = {C \\<cdot> \\<sigma>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {C} \\<cdot>cs \\<sigma> = {C \\<cdot> \\<sigma>}", "unfolding subst_clss_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>A. A \\<cdot> \\<sigma>) ` {C} = {C \\<cdot> \\<sigma>}", "by auto"], ["", "lemma subst_cls_list_single[simp]: \"[C] \\<cdot>cl \\<sigma> = [C \\<cdot> \\<sigma>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [C] \\<cdot>cl \\<sigma> = [C \\<cdot> \\<sigma>]", "unfolding subst_cls_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>A. A \\<cdot> \\<sigma>) [C] = [C \\<cdot> \\<sigma>]", "by auto"], ["", "lemma subst_cls_lists_single[simp]: \"[C] \\<cdot>\\<cdot>cl [\\<sigma>] = [C \\<cdot> \\<sigma>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [C] \\<cdot>\\<cdot>cl [\\<sigma>] = [C \\<cdot> \\<sigma>]", "unfolding subst_cls_lists_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Map2.map2 (\\<cdot>) [C] [\\<sigma>] = [C \\<cdot> \\<sigma>]", "by auto"], ["", "lemma subst_cls_mset_single[simp]: \"{#C#} \\<cdot>cm \\<sigma> = {#C \\<cdot> \\<sigma>#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#C#} \\<cdot>cm \\<sigma> = {#C \\<cdot> \\<sigma>#}", "by simp"], ["", "subsubsection \\<open>Substitution on @{term Cons}\\<close>"], ["", "lemma subst_atm_list_Cons[simp]: \"(A # As) \\<cdot>al \\<sigma> = A \\<cdot>a \\<sigma> # As \\<cdot>al \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A # As) \\<cdot>al \\<sigma> =\n    A \\<cdot>a \\<sigma> # As \\<cdot>al \\<sigma>", "unfolding subst_atm_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>A. A \\<cdot>a \\<sigma>) (A # As) =\n    A \\<cdot>a \\<sigma> # map (\\<lambda>A. A \\<cdot>a \\<sigma>) As", "by auto"], ["", "lemma subst_atm_mset_list_Cons[simp]: \"(A # As) \\<cdot>aml \\<sigma> = A \\<cdot>am \\<sigma> # As \\<cdot>aml \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A # As) \\<cdot>aml \\<sigma> =\n    A \\<cdot>am \\<sigma> # As \\<cdot>aml \\<sigma>", "unfolding subst_atm_mset_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>AA. AA \\<cdot>am \\<sigma>) (A # As) =\n    A \\<cdot>am \\<sigma> # map (\\<lambda>AA. AA \\<cdot>am \\<sigma>) As", "by auto"], ["", "lemma subst_atm_mset_lists_Cons[simp]: \"(C # Cs) \\<cdot>\\<cdot>aml (\\<sigma> # \\<sigma>s) = C \\<cdot>am \\<sigma> # Cs \\<cdot>\\<cdot>aml \\<sigma>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (C # Cs) \\<cdot>\\<cdot>aml (\\<sigma> # \\<sigma>s) =\n    C \\<cdot>am \\<sigma> # Cs \\<cdot>\\<cdot>aml \\<sigma>s", "unfolding subst_atm_mset_lists_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Map2.map2 (\\<cdot>am) (C # Cs) (\\<sigma> # \\<sigma>s) =\n    C \\<cdot>am \\<sigma> # Map2.map2 (\\<cdot>am) Cs \\<sigma>s", "by auto"], ["", "lemma subst_cls_list_Cons[simp]: \"(C # Cs) \\<cdot>cl \\<sigma> = C \\<cdot> \\<sigma> # Cs \\<cdot>cl \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (C # Cs) \\<cdot>cl \\<sigma> = C \\<cdot> \\<sigma> # Cs \\<cdot>cl \\<sigma>", "unfolding subst_cls_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>A. A \\<cdot> \\<sigma>) (C # Cs) =\n    C \\<cdot> \\<sigma> # map (\\<lambda>A. A \\<cdot> \\<sigma>) Cs", "by auto"], ["", "lemma subst_cls_lists_Cons[simp]: \"(C # Cs) \\<cdot>\\<cdot>cl (\\<sigma> # \\<sigma>s) = C \\<cdot> \\<sigma> # Cs \\<cdot>\\<cdot>cl \\<sigma>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (C # Cs) \\<cdot>\\<cdot>cl (\\<sigma> # \\<sigma>s) =\n    C \\<cdot> \\<sigma> # Cs \\<cdot>\\<cdot>cl \\<sigma>s", "unfolding subst_cls_lists_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Map2.map2 (\\<cdot>) (C # Cs) (\\<sigma> # \\<sigma>s) =\n    C \\<cdot> \\<sigma> # Map2.map2 (\\<cdot>) Cs \\<sigma>s", "by auto"], ["", "subsubsection \\<open>Substitution on @{term tl}\\<close>"], ["", "lemma subst_atm_list_tl[simp]: \"tl (As \\<cdot>al \\<sigma>) = tl As \\<cdot>al \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl (As \\<cdot>al \\<sigma>) = tl As \\<cdot>al \\<sigma>", "by (cases As) auto"], ["", "lemma subst_atm_mset_list_tl[simp]: \"tl (AAs \\<cdot>aml \\<sigma>) = tl AAs \\<cdot>aml \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl (AAs \\<cdot>aml \\<sigma>) = tl AAs \\<cdot>aml \\<sigma>", "by (cases AAs) auto"], ["", "lemma subst_cls_list_tl[simp]: \"tl (Cs \\<cdot>cl \\<sigma>) = tl Cs \\<cdot>cl \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl (Cs \\<cdot>cl \\<sigma>) = tl Cs \\<cdot>cl \\<sigma>", "by (cases Cs) auto"], ["", "lemma subst_cls_lists_tl[simp]: \"length Cs = length \\<sigma>s \\<Longrightarrow> tl (Cs \\<cdot>\\<cdot>cl \\<sigma>s) = tl Cs \\<cdot>\\<cdot>cl tl \\<sigma>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length Cs = length \\<sigma>s \\<Longrightarrow>\n    tl (Cs \\<cdot>\\<cdot>cl \\<sigma>s) = tl Cs \\<cdot>\\<cdot>cl tl \\<sigma>s", "by (cases Cs; cases \\<sigma>s) auto"], ["", "subsubsection \\<open>Substitution on @{term nth}\\<close>"], ["", "lemma comp_substs_nth[simp]:\n  \"length \\<tau>s = length \\<sigma>s \\<Longrightarrow> i < length \\<tau>s \\<Longrightarrow> (\\<tau>s \\<odot>s \\<sigma>s) ! i = (\\<tau>s ! i) \\<odot> (\\<sigma>s ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length \\<tau>s = length \\<sigma>s; i < length \\<tau>s\\<rbrakk>\n    \\<Longrightarrow> (\\<tau>s \\<odot>s \\<sigma>s) ! i =\n                      \\<tau>s ! i \\<odot> \\<sigma>s ! i", "by (simp add: comp_substs_def)"], ["", "lemma subst_atm_list_nth[simp]: \"i < length As \\<Longrightarrow> (As \\<cdot>al \\<tau>) ! i = As ! i \\<cdot>a \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length As \\<Longrightarrow>\n    (As \\<cdot>al \\<tau>) ! i = As ! i \\<cdot>a \\<tau>", "unfolding subst_atm_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length As \\<Longrightarrow>\n    map (\\<lambda>A. A \\<cdot>a \\<tau>) As ! i = As ! i \\<cdot>a \\<tau>", "using less_Suc_eq_0_disj nth_map"], ["proof (prove)\nusing this:\n  (?m < Suc ?n) = (?m = 0 \\<or> (\\<exists>j. ?m = Suc j \\<and> j < ?n))\n  ?n < length ?xs \\<Longrightarrow> map ?f ?xs ! ?n = ?f (?xs ! ?n)\n\ngoal (1 subgoal):\n 1. i < length As \\<Longrightarrow>\n    map (\\<lambda>A. A \\<cdot>a \\<tau>) As ! i = As ! i \\<cdot>a \\<tau>", "by force"], ["", "lemma subst_atm_mset_list_nth[simp]: \"i < length AAs \\<Longrightarrow> (AAs \\<cdot>aml \\<eta>) ! i = (AAs ! i) \\<cdot>am \\<eta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length AAs \\<Longrightarrow>\n    (AAs \\<cdot>aml \\<eta>) ! i = AAs ! i \\<cdot>am \\<eta>", "unfolding subst_atm_mset_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length AAs \\<Longrightarrow>\n    map (\\<lambda>AA. AA \\<cdot>am \\<eta>) AAs ! i =\n    AAs ! i \\<cdot>am \\<eta>", "by auto"], ["", "lemma subst_atm_mset_lists_nth[simp]:\n  \"length AAs = length \\<sigma>s \\<Longrightarrow> i < length AAs \\<Longrightarrow> (AAs \\<cdot>\\<cdot>aml \\<sigma>s) ! i = (AAs ! i) \\<cdot>am (\\<sigma>s ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length AAs = length \\<sigma>s; i < length AAs\\<rbrakk>\n    \\<Longrightarrow> (AAs \\<cdot>\\<cdot>aml \\<sigma>s) ! i =\n                      AAs ! i \\<cdot>am \\<sigma>s ! i", "unfolding subst_atm_mset_lists_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length AAs = length \\<sigma>s; i < length AAs\\<rbrakk>\n    \\<Longrightarrow> Map2.map2 (\\<cdot>am) AAs \\<sigma>s ! i =\n                      AAs ! i \\<cdot>am \\<sigma>s ! i", "by auto"], ["", "lemma subst_cls_list_nth[simp]: \"i < length Cs \\<Longrightarrow> (Cs \\<cdot>cl \\<tau>) ! i = (Cs ! i) \\<cdot> \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length Cs \\<Longrightarrow>\n    (Cs \\<cdot>cl \\<tau>) ! i = Cs ! i \\<cdot> \\<tau>", "unfolding subst_cls_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length Cs \\<Longrightarrow>\n    map (\\<lambda>A. A \\<cdot> \\<tau>) Cs ! i = Cs ! i \\<cdot> \\<tau>", "using less_Suc_eq_0_disj nth_map"], ["proof (prove)\nusing this:\n  (?m < Suc ?n) = (?m = 0 \\<or> (\\<exists>j. ?m = Suc j \\<and> j < ?n))\n  ?n < length ?xs \\<Longrightarrow> map ?f ?xs ! ?n = ?f (?xs ! ?n)\n\ngoal (1 subgoal):\n 1. i < length Cs \\<Longrightarrow>\n    map (\\<lambda>A. A \\<cdot> \\<tau>) Cs ! i = Cs ! i \\<cdot> \\<tau>", "by (induction Cs) auto"], ["", "lemma subst_cls_lists_nth[simp]:\n  \"length Cs = length \\<sigma>s \\<Longrightarrow> i < length Cs \\<Longrightarrow> (Cs \\<cdot>\\<cdot>cl \\<sigma>s) ! i = (Cs ! i) \\<cdot> (\\<sigma>s ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length Cs = length \\<sigma>s; i < length Cs\\<rbrakk>\n    \\<Longrightarrow> (Cs \\<cdot>\\<cdot>cl \\<sigma>s) ! i =\n                      Cs ! i \\<cdot> \\<sigma>s ! i", "unfolding subst_cls_lists_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length Cs = length \\<sigma>s; i < length Cs\\<rbrakk>\n    \\<Longrightarrow> Map2.map2 (\\<cdot>) Cs \\<sigma>s ! i =\n                      Cs ! i \\<cdot> \\<sigma>s ! i", "by auto"], ["", "subsubsection \\<open>Substitution on Various Other Functions\\<close>"], ["", "lemma subst_clss_image[simp]: \"image f X \\<cdot>cs \\<sigma> = {f x \\<cdot> \\<sigma> | x. x \\<in> X}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` X \\<cdot>cs \\<sigma> = {f x \\<cdot> \\<sigma> |x. x \\<in> X}", "unfolding subst_clss_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>A. A \\<cdot> \\<sigma>) ` f ` X =\n    {f x \\<cdot> \\<sigma> |x. x \\<in> X}", "by auto"], ["", "lemma subst_cls_mset_image_mset[simp]: \"image_mset f X \\<cdot>cm \\<sigma> = {# f x \\<cdot> \\<sigma>. x \\<in># X #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. image_mset f X \\<cdot>cm \\<sigma> = {#f x \\<cdot> \\<sigma>. x \\<in># X#}", "unfolding subst_cls_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {#A \\<cdot> \\<sigma>. A \\<in># image_mset f X#} =\n    {#f x \\<cdot> \\<sigma>. x \\<in># X#}", "by auto"], ["", "lemma mset_subst_atm_list_subst_atm_mset[simp]: \"mset (As \\<cdot>al \\<sigma>) = mset (As) \\<cdot>am \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (As \\<cdot>al \\<sigma>) = mset As \\<cdot>am \\<sigma>", "unfolding subst_atm_list_def subst_atm_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (map (\\<lambda>A. A \\<cdot>a \\<sigma>) As) =\n    {#A \\<cdot>a \\<sigma>. A \\<in># mset As#}", "by auto"], ["", "lemma mset_subst_cls_list_subst_cls_mset: \"mset (Cs \\<cdot>cl \\<sigma>) = (mset Cs) \\<cdot>cm \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (Cs \\<cdot>cl \\<sigma>) = mset Cs \\<cdot>cm \\<sigma>", "unfolding subst_cls_mset_def subst_cls_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (map (\\<lambda>A. A \\<cdot> \\<sigma>) Cs) =\n    {#A \\<cdot> \\<sigma>. A \\<in># mset Cs#}", "by auto"], ["", "lemma sum_list_subst_cls_list_subst_cls[simp]: \"sum_list (Cs \\<cdot>cl \\<eta>) = sum_list Cs \\<cdot> \\<eta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (Cs \\<cdot>cl \\<eta>) = sum_list Cs \\<cdot> \\<eta>", "unfolding subst_cls_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>A\\<leftarrow>Cs. A \\<cdot> \\<eta>) = sum_list Cs \\<cdot> \\<eta>", "by (induction Cs) auto"], ["", "lemma set_mset_subst_cls_mset_subst_clss: \"set_mset (CC \\<cdot>cm \\<mu>) = (set_mset CC) \\<cdot>cs \\<mu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_mset (CC \\<cdot>cm \\<mu>) = set_mset CC \\<cdot>cs \\<mu>", "by (simp add: subst_cls_mset_def subst_clss_def)"], ["", "lemma Neg_Melem_subst_atm_subst_cls[simp]: \"Neg A \\<in># C \\<Longrightarrow> Neg (A \\<cdot>a \\<sigma>) \\<in># C \\<cdot> \\<sigma> \""], ["proof (prove)\ngoal (1 subgoal):\n 1. Neg A \\<in># C \\<Longrightarrow>\n    Neg (A \\<cdot>a \\<sigma>) \\<in># C \\<cdot> \\<sigma>", "by (metis Melem_subst_cls eql_neg_lit_eql_atm)"], ["", "lemma Pos_Melem_subst_atm_subst_cls[simp]: \"Pos A \\<in># C \\<Longrightarrow> Pos (A \\<cdot>a \\<sigma>) \\<in># C \\<cdot> \\<sigma> \""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pos A \\<in># C \\<Longrightarrow>\n    Pos (A \\<cdot>a \\<sigma>) \\<in># C \\<cdot> \\<sigma>", "by (metis Melem_subst_cls eql_pos_lit_eql_atm)"], ["", "lemma in_atms_of_subst[simp]: \"B \\<in> atms_of C \\<Longrightarrow> B \\<cdot>a \\<sigma> \\<in> atms_of (C \\<cdot> \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<in> atms_of C \\<Longrightarrow>\n    B \\<cdot>a \\<sigma> \\<in> atms_of (C \\<cdot> \\<sigma>)", "by (metis atms_of_subst_atms image_iff subst_atms_def)"], ["", "subsubsection \\<open>Renamings\\<close>"], ["", "lemma is_renaming_id_subst[simp]: \"is_renaming id_subst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_renaming id_subst", "unfolding is_renaming_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>. id_subst \\<odot> \\<tau> = id_subst", "by simp"], ["", "lemma is_renamingD: \"is_renaming \\<sigma> \\<Longrightarrow> (\\<forall>A1 A2. A1 \\<cdot>a \\<sigma> = A2 \\<cdot>a \\<sigma> \\<longleftrightarrow> A1 = A2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_renaming \\<sigma> \\<Longrightarrow>\n    \\<forall>A1 A2.\n       (A1 \\<cdot>a \\<sigma> = A2 \\<cdot>a \\<sigma>) = (A1 = A2)", "by (metis is_renaming_def subst_atm_comp_subst subst_atm_id_subst)"], ["", "lemma inv_renaming_cancel_r[simp]: \"is_renaming r \\<Longrightarrow> r \\<odot> inv_renaming r = id_subst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_renaming r \\<Longrightarrow> r \\<odot> inv_renaming r = id_subst", "unfolding inv_renaming_def is_renaming_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>. r \\<odot> \\<tau> = id_subst \\<Longrightarrow>\n    r \\<odot> (SOME \\<tau>. r \\<odot> \\<tau> = id_subst) = id_subst", "by (metis (mono_tags) someI_ex)"], ["", "lemma inv_renaming_cancel_r_list[simp]:\n  \"is_renaming_list rs \\<Longrightarrow> rs \\<odot>s map inv_renaming rs = replicate (length rs) id_subst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_renaming_list rs \\<Longrightarrow>\n    rs \\<odot>s map inv_renaming rs = replicate (length rs) id_subst", "unfolding is_renaming_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (set rs) is_renaming \\<Longrightarrow>\n    rs \\<odot>s map inv_renaming rs = replicate (length rs) id_subst", "by (induction rs) (auto simp add: comp_substs_def)"], ["", "lemma Nil_comp_substs[simp]: \"[] \\<odot>s s = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<odot>s s = []", "unfolding comp_substs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Map2.map2 (\\<odot>) [] s = []", "by auto"], ["", "lemma comp_substs_Nil[simp]: \"s \\<odot>s [] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<odot>s [] = []", "unfolding comp_substs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Map2.map2 (\\<odot>) s [] = []", "by auto"], ["", "lemma is_renaming_idempotent_id_subst: \"is_renaming r \\<Longrightarrow> r \\<odot> r = r \\<Longrightarrow> r = id_subst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_renaming r; r \\<odot> r = r\\<rbrakk>\n    \\<Longrightarrow> r = id_subst", "by (metis comp_subst_assoc comp_subst_id_subst inv_renaming_cancel_r)"], ["", "lemma is_renaming_left_id_subst_right_id_subst:\n  \"is_renaming r \\<Longrightarrow> s \\<odot> r = id_subst \\<Longrightarrow> r \\<odot> s = id_subst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_renaming r; s \\<odot> r = id_subst\\<rbrakk>\n    \\<Longrightarrow> r \\<odot> s = id_subst", "by (metis comp_subst_assoc comp_subst_id_subst is_renaming_def)"], ["", "lemma is_renaming_closure: \"is_renaming r1 \\<Longrightarrow> is_renaming r2 \\<Longrightarrow> is_renaming (r1 \\<odot> r2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_renaming r1; is_renaming r2\\<rbrakk>\n    \\<Longrightarrow> is_renaming (r1 \\<odot> r2)", "unfolding is_renaming_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>\\<tau>. r1 \\<odot> \\<tau> = id_subst;\n     \\<exists>\\<tau>. r2 \\<odot> \\<tau> = id_subst\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<tau>.\n                         r1 \\<odot> r2 \\<odot> \\<tau> = id_subst", "by (metis comp_subst_assoc comp_subst_id_subst)"], ["", "lemma is_renaming_inv_renaming_cancel_atm[simp]: \"is_renaming \\<rho> \\<Longrightarrow> A \\<cdot>a \\<rho> \\<cdot>a inv_renaming \\<rho> = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_renaming \\<rho> \\<Longrightarrow>\n    A \\<cdot>a \\<rho> \\<cdot>a inv_renaming \\<rho> = A", "by (metis inv_renaming_cancel_r subst_atm_comp_subst subst_atm_id_subst)"], ["", "lemma is_renaming_inv_renaming_cancel_atms[simp]: \"is_renaming \\<rho> \\<Longrightarrow> AA \\<cdot>as \\<rho> \\<cdot>as inv_renaming \\<rho> = AA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_renaming \\<rho> \\<Longrightarrow>\n    AA \\<cdot>as \\<rho> \\<cdot>as inv_renaming \\<rho> = AA", "by (metis inv_renaming_cancel_r subst_atms_comp_subst subst_atms_id_subst)"], ["", "lemma is_renaming_inv_renaming_cancel_atmss[simp]: \"is_renaming \\<rho> \\<Longrightarrow> AAA \\<cdot>ass \\<rho> \\<cdot>ass inv_renaming \\<rho> = AAA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_renaming \\<rho> \\<Longrightarrow>\n    AAA \\<cdot>ass \\<rho> \\<cdot>ass inv_renaming \\<rho> = AAA", "by (metis inv_renaming_cancel_r subst_atmss_comp_subst subst_atmss_id_subst)"], ["", "lemma is_renaming_inv_renaming_cancel_atm_list[simp]: \"is_renaming \\<rho> \\<Longrightarrow> As \\<cdot>al \\<rho> \\<cdot>al inv_renaming \\<rho> = As\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_renaming \\<rho> \\<Longrightarrow>\n    As \\<cdot>al \\<rho> \\<cdot>al inv_renaming \\<rho> = As", "by (metis inv_renaming_cancel_r subst_atm_list_comp_subst subst_atm_list_id_subst)"], ["", "lemma is_renaming_inv_renaming_cancel_atm_mset[simp]: \"is_renaming \\<rho> \\<Longrightarrow> AA \\<cdot>am \\<rho> \\<cdot>am inv_renaming \\<rho> = AA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_renaming \\<rho> \\<Longrightarrow>\n    AA \\<cdot>am \\<rho> \\<cdot>am inv_renaming \\<rho> = AA", "by (metis inv_renaming_cancel_r subst_atm_mset_comp_subst subst_atm_mset_id_subst)"], ["", "lemma is_renaming_inv_renaming_cancel_atm_mset_list[simp]: \"is_renaming \\<rho> \\<Longrightarrow> (AAs \\<cdot>aml \\<rho>) \\<cdot>aml inv_renaming \\<rho> = AAs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_renaming \\<rho> \\<Longrightarrow>\n    AAs \\<cdot>aml \\<rho> \\<cdot>aml inv_renaming \\<rho> = AAs", "by (metis inv_renaming_cancel_r subst_atm_mset_list_comp_subst subst_atm_mset_list_id_subst)"], ["", "lemma is_renaming_list_inv_renaming_cancel_atm_mset_lists[simp]:\n  \"length AAs = length \\<rho>s \\<Longrightarrow> is_renaming_list \\<rho>s \\<Longrightarrow> AAs \\<cdot>\\<cdot>aml \\<rho>s \\<cdot>\\<cdot>aml map inv_renaming \\<rho>s = AAs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length AAs = length \\<rho>s; is_renaming_list \\<rho>s\\<rbrakk>\n    \\<Longrightarrow> AAs \\<cdot>\\<cdot>aml \\<rho>s \\<cdot>\\<cdot>aml\n                      map inv_renaming \\<rho>s =\n                      AAs", "by (metis inv_renaming_cancel_r_list subst_atm_mset_lists_comp_substs\n      subst_atm_mset_lists_id_subst)"], ["", "lemma is_renaming_inv_renaming_cancel_lit[simp]: \"is_renaming \\<rho> \\<Longrightarrow> (L \\<cdot>l \\<rho>) \\<cdot>l inv_renaming \\<rho> = L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_renaming \\<rho> \\<Longrightarrow>\n    L \\<cdot>l \\<rho> \\<cdot>l inv_renaming \\<rho> = L", "by (metis inv_renaming_cancel_r subst_lit_comp_subst subst_lit_id_subst)"], ["", "lemma is_renaming_inv_renaming_cancel_cls[simp]: \"is_renaming \\<rho> \\<Longrightarrow> C  \\<cdot> \\<rho> \\<cdot> inv_renaming \\<rho> = C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_renaming \\<rho> \\<Longrightarrow>\n    C \\<cdot> \\<rho> \\<cdot> inv_renaming \\<rho> = C", "by (metis inv_renaming_cancel_r subst_cls_comp_subst subst_cls_id_subst)"], ["", "lemma is_renaming_inv_renaming_cancel_clss[simp]:\n  \"is_renaming \\<rho> \\<Longrightarrow> CC \\<cdot>cs \\<rho> \\<cdot>cs inv_renaming \\<rho> = CC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_renaming \\<rho> \\<Longrightarrow>\n    CC \\<cdot>cs \\<rho> \\<cdot>cs inv_renaming \\<rho> = CC", "by (metis inv_renaming_cancel_r subst_clss_id_subst subst_clsscomp_subst)"], ["", "lemma is_renaming_inv_renaming_cancel_cls_list[simp]:\n  \"is_renaming \\<rho> \\<Longrightarrow> Cs \\<cdot>cl \\<rho> \\<cdot>cl inv_renaming \\<rho> = Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_renaming \\<rho> \\<Longrightarrow>\n    Cs \\<cdot>cl \\<rho> \\<cdot>cl inv_renaming \\<rho> = Cs", "by (metis inv_renaming_cancel_r subst_cls_list_comp_subst subst_cls_list_id_subst)"], ["", "lemma is_renaming_list_inv_renaming_cancel_cls_list[simp]:\n  \"length Cs = length \\<rho>s \\<Longrightarrow> is_renaming_list \\<rho>s \\<Longrightarrow> Cs \\<cdot>\\<cdot>cl \\<rho>s \\<cdot>\\<cdot>cl map inv_renaming \\<rho>s = Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length Cs = length \\<rho>s; is_renaming_list \\<rho>s\\<rbrakk>\n    \\<Longrightarrow> Cs \\<cdot>\\<cdot>cl \\<rho>s \\<cdot>\\<cdot>cl\n                      map inv_renaming \\<rho>s =\n                      Cs", "by (metis inv_renaming_cancel_r_list subst_cls_lists_comp_substs subst_cls_lists_id_subst)"], ["", "lemma is_renaming_inv_renaming_cancel_cls_mset[simp]:\n  \"is_renaming \\<rho> \\<Longrightarrow> CC \\<cdot>cm \\<rho> \\<cdot>cm inv_renaming \\<rho> = CC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_renaming \\<rho> \\<Longrightarrow>\n    CC \\<cdot>cm \\<rho> \\<cdot>cm inv_renaming \\<rho> = CC", "by (metis inv_renaming_cancel_r subst_cls_mset_comp_subst subst_cls_mset_id_subst)"], ["", "subsubsection \\<open>Monotonicity\\<close>"], ["", "lemma subst_cls_mono: \"set_mset C \\<subseteq> set_mset D \\<Longrightarrow> set_mset (C \\<cdot> \\<sigma>) \\<subseteq> set_mset (D \\<cdot> \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_mset C \\<subseteq> set_mset D \\<Longrightarrow>\n    set_mset (C \\<cdot> \\<sigma>) \\<subseteq> set_mset (D \\<cdot> \\<sigma>)", "by force"], ["", "lemma subst_cls_mono_mset: \"C \\<subseteq># D \\<Longrightarrow> C \\<cdot> \\<sigma> \\<subseteq># D \\<cdot> \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<subseteq># D \\<Longrightarrow>\n    C \\<cdot> \\<sigma> \\<subseteq># D \\<cdot> \\<sigma>", "unfolding subst_clss_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<subseteq># D \\<Longrightarrow>\n    C \\<cdot> \\<sigma> \\<subseteq># D \\<cdot> \\<sigma>", "by (metis mset_subset_eq_exists_conv subst_cls_union)"], ["", "lemma subst_subset_mono: \"D \\<subset># C \\<Longrightarrow> D \\<cdot> \\<sigma> \\<subset># C \\<cdot> \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D \\<subset># C \\<Longrightarrow>\n    D \\<cdot> \\<sigma> \\<subset># C \\<cdot> \\<sigma>", "unfolding subst_cls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. D \\<subset># C \\<Longrightarrow>\n    {#A \\<cdot>l \\<sigma>. A \\<in># D#} \\<subset>#\n    {#A \\<cdot>l \\<sigma>. A \\<in># C#}", "by (simp add: image_mset_subset_mono)"], ["", "subsubsection \\<open>Size after Substitution\\<close>"], ["", "lemma size_subst[simp]: \"size (D \\<cdot> \\<sigma>) = size D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (D \\<cdot> \\<sigma>) = size D", "unfolding subst_cls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. size {#A \\<cdot>l \\<sigma>. A \\<in># D#} = size D", "by auto"], ["", "lemma subst_atm_list_length[simp]: \"length (As \\<cdot>al \\<sigma>) = length As\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (As \\<cdot>al \\<sigma>) = length As", "unfolding subst_atm_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map (\\<lambda>A. A \\<cdot>a \\<sigma>) As) = length As", "by auto"], ["", "lemma length_subst_atm_mset_list[simp]: \"length (AAs \\<cdot>aml \\<eta>) = length AAs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (AAs \\<cdot>aml \\<eta>) = length AAs", "unfolding subst_atm_mset_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map (\\<lambda>AA. AA \\<cdot>am \\<eta>) AAs) = length AAs", "by auto"], ["", "lemma subst_atm_mset_lists_length[simp]: \"length (AAs \\<cdot>\\<cdot>aml \\<sigma>s) = min (length AAs) (length \\<sigma>s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (AAs \\<cdot>\\<cdot>aml \\<sigma>s) =\n    min (length AAs) (length \\<sigma>s)", "unfolding subst_atm_mset_lists_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (Map2.map2 (\\<cdot>am) AAs \\<sigma>s) =\n    min (length AAs) (length \\<sigma>s)", "by auto"], ["", "lemma subst_cls_list_length[simp]: \"length (Cs \\<cdot>cl \\<sigma>) = length Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (Cs \\<cdot>cl \\<sigma>) = length Cs", "unfolding subst_cls_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map (\\<lambda>A. A \\<cdot> \\<sigma>) Cs) = length Cs", "by auto"], ["", "lemma comp_substs_length[simp]: \"length (\\<tau>s \\<odot>s \\<sigma>s) = min (length \\<tau>s) (length \\<sigma>s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (\\<tau>s \\<odot>s \\<sigma>s) =\n    min (length \\<tau>s) (length \\<sigma>s)", "unfolding comp_substs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (Map2.map2 (\\<odot>) \\<tau>s \\<sigma>s) =\n    min (length \\<tau>s) (length \\<sigma>s)", "by auto"], ["", "lemma subst_cls_lists_length[simp]: \"length (Cs \\<cdot>\\<cdot>cl \\<sigma>s) = min (length Cs) (length \\<sigma>s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (Cs \\<cdot>\\<cdot>cl \\<sigma>s) =\n    min (length Cs) (length \\<sigma>s)", "unfolding subst_cls_lists_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (Map2.map2 (\\<cdot>) Cs \\<sigma>s) =\n    min (length Cs) (length \\<sigma>s)", "by auto"], ["", "subsubsection \\<open>Variable Disjointness\\<close>"], ["", "lemma var_disjoint_clauses:\n  assumes \"var_disjoint Cs\"\n  shows \"\\<forall>\\<sigma>s. length \\<sigma>s = length Cs \\<longrightarrow> (\\<exists>\\<tau>. Cs \\<cdot>\\<cdot>cl \\<sigma>s = Cs \\<cdot>cl \\<tau>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>s.\n       length \\<sigma>s = length Cs \\<longrightarrow>\n       (\\<exists>\\<tau>.\n           Cs \\<cdot>\\<cdot>cl \\<sigma>s = Cs \\<cdot>cl \\<tau>)", "proof clarify"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>s.\n       length \\<sigma>s = length Cs \\<Longrightarrow>\n       \\<exists>\\<tau>. Cs \\<cdot>\\<cdot>cl \\<sigma>s = Cs \\<cdot>cl \\<tau>", "fix \\<sigma>s :: \"'s list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>s.\n       length \\<sigma>s = length Cs \\<Longrightarrow>\n       \\<exists>\\<tau>. Cs \\<cdot>\\<cdot>cl \\<sigma>s = Cs \\<cdot>cl \\<tau>", "assume a: \"length \\<sigma>s = length Cs\""], ["proof (state)\nthis:\n  length \\<sigma>s = length Cs\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>s.\n       length \\<sigma>s = length Cs \\<Longrightarrow>\n       \\<exists>\\<tau>. Cs \\<cdot>\\<cdot>cl \\<sigma>s = Cs \\<cdot>cl \\<tau>", "then"], ["proof (chain)\npicking this:\n  length \\<sigma>s = length Cs", "obtain \\<tau> where \"\\<forall>i < length Cs. \\<forall>S. S \\<subseteq># Cs ! i \\<longrightarrow> S \\<cdot> \\<sigma>s ! i = S \\<cdot> \\<tau>\""], ["proof (prove)\nusing this:\n  length \\<sigma>s = length Cs\n\ngoal (1 subgoal):\n 1. (\\<And>\\<tau>.\n        \\<forall>i<length Cs.\n           \\<forall>S.\n              S \\<subseteq># Cs ! i \\<longrightarrow>\n              S \\<cdot> \\<sigma>s ! i = S \\<cdot> \\<tau> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  length \\<sigma>s = length Cs\n  var_disjoint Cs\n\ngoal (1 subgoal):\n 1. (\\<And>\\<tau>.\n        \\<forall>i<length Cs.\n           \\<forall>S.\n              S \\<subseteq># Cs ! i \\<longrightarrow>\n              S \\<cdot> \\<sigma>s ! i = S \\<cdot> \\<tau> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding var_disjoint_def"], ["proof (prove)\nusing this:\n  length \\<sigma>s = length Cs\n  \\<forall>\\<sigma>s.\n     length \\<sigma>s = length Cs \\<longrightarrow>\n     (\\<exists>\\<tau>.\n         \\<forall>i<length Cs.\n            \\<forall>S.\n               S \\<subseteq># Cs ! i \\<longrightarrow>\n               S \\<cdot> \\<sigma>s ! i = S \\<cdot> \\<tau>)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<tau>.\n        \\<forall>i<length Cs.\n           \\<forall>S.\n              S \\<subseteq># Cs ! i \\<longrightarrow>\n              S \\<cdot> \\<sigma>s ! i = S \\<cdot> \\<tau> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>i<length Cs.\n     \\<forall>S.\n        S \\<subseteq># Cs ! i \\<longrightarrow>\n        S \\<cdot> \\<sigma>s ! i = S \\<cdot> \\<tau>\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>s.\n       length \\<sigma>s = length Cs \\<Longrightarrow>\n       \\<exists>\\<tau>. Cs \\<cdot>\\<cdot>cl \\<sigma>s = Cs \\<cdot>cl \\<tau>", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<length Cs.\n     \\<forall>S.\n        S \\<subseteq># Cs ! i \\<longrightarrow>\n        S \\<cdot> \\<sigma>s ! i = S \\<cdot> \\<tau>", "have \"\\<forall>i < length Cs. (Cs ! i) \\<cdot> \\<sigma>s ! i = (Cs ! i) \\<cdot> \\<tau>\""], ["proof (prove)\nusing this:\n  \\<forall>i<length Cs.\n     \\<forall>S.\n        S \\<subseteq># Cs ! i \\<longrightarrow>\n        S \\<cdot> \\<sigma>s ! i = S \\<cdot> \\<tau>\n\ngoal (1 subgoal):\n 1. \\<forall>i<length Cs.\n       Cs ! i \\<cdot> \\<sigma>s ! i = Cs ! i \\<cdot> \\<tau>", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<length Cs. Cs ! i \\<cdot> \\<sigma>s ! i = Cs ! i \\<cdot> \\<tau>\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>s.\n       length \\<sigma>s = length Cs \\<Longrightarrow>\n       \\<exists>\\<tau>. Cs \\<cdot>\\<cdot>cl \\<sigma>s = Cs \\<cdot>cl \\<tau>", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<length Cs. Cs ! i \\<cdot> \\<sigma>s ! i = Cs ! i \\<cdot> \\<tau>", "have \"Cs \\<cdot>\\<cdot>cl \\<sigma>s = Cs \\<cdot>cl \\<tau>\""], ["proof (prove)\nusing this:\n  \\<forall>i<length Cs. Cs ! i \\<cdot> \\<sigma>s ! i = Cs ! i \\<cdot> \\<tau>\n\ngoal (1 subgoal):\n 1. Cs \\<cdot>\\<cdot>cl \\<sigma>s = Cs \\<cdot>cl \\<tau>", "using a"], ["proof (prove)\nusing this:\n  \\<forall>i<length Cs. Cs ! i \\<cdot> \\<sigma>s ! i = Cs ! i \\<cdot> \\<tau>\n  length \\<sigma>s = length Cs\n\ngoal (1 subgoal):\n 1. Cs \\<cdot>\\<cdot>cl \\<sigma>s = Cs \\<cdot>cl \\<tau>", "by (auto intro: nth_equalityI)"], ["proof (state)\nthis:\n  Cs \\<cdot>\\<cdot>cl \\<sigma>s = Cs \\<cdot>cl \\<tau>\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>s.\n       length \\<sigma>s = length Cs \\<Longrightarrow>\n       \\<exists>\\<tau>. Cs \\<cdot>\\<cdot>cl \\<sigma>s = Cs \\<cdot>cl \\<tau>", "then"], ["proof (chain)\npicking this:\n  Cs \\<cdot>\\<cdot>cl \\<sigma>s = Cs \\<cdot>cl \\<tau>", "show \"\\<exists>\\<tau>. Cs \\<cdot>\\<cdot>cl \\<sigma>s = Cs \\<cdot>cl \\<tau>\""], ["proof (prove)\nusing this:\n  Cs \\<cdot>\\<cdot>cl \\<sigma>s = Cs \\<cdot>cl \\<tau>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>. Cs \\<cdot>\\<cdot>cl \\<sigma>s = Cs \\<cdot>cl \\<tau>", "by auto"], ["proof (state)\nthis:\n  \\<exists>\\<tau>. Cs \\<cdot>\\<cdot>cl \\<sigma>s = Cs \\<cdot>cl \\<tau>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Ground Expressions and Substitutions\\<close>"], ["", "lemma ex_ground_subst: \"\\<exists>\\<sigma>. is_ground_subst \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ex is_ground_subst", "using make_ground_subst[of \"{#}\"]"], ["proof (prove)\nusing this:\n  is_ground_cls ({#} \\<cdot> ?\\<sigma>) \\<Longrightarrow>\n  \\<exists>\\<tau>.\n     is_ground_subst \\<tau> \\<and>\n     {#} \\<cdot> \\<tau> = {#} \\<cdot> ?\\<sigma>\n\ngoal (1 subgoal):\n 1. Ex is_ground_subst", "by (simp add: is_ground_cls_def)"], ["", "lemma is_ground_cls_list_Cons[simp]:\n  \"is_ground_cls_list (C # Cs) = (is_ground_cls C \\<and> is_ground_cls_list Cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_cls_list (C # Cs) =\n    (is_ground_cls C \\<and> is_ground_cls_list Cs)", "unfolding is_ground_cls_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (set (C # Cs)) is_ground_cls =\n    (is_ground_cls C \\<and> Ball (set Cs) is_ground_cls)", "by auto"], ["", "paragraph \\<open>Ground union\\<close>"], ["", "lemma is_ground_atms_union[simp]: \"is_ground_atms (AA \\<union> BB) \\<longleftrightarrow> is_ground_atms AA \\<and> is_ground_atms BB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_atms (AA \\<union> BB) =\n    (is_ground_atms AA \\<and> is_ground_atms BB)", "unfolding is_ground_atms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (AA \\<union> BB) is_ground_atm =\n    (Ball AA is_ground_atm \\<and> Ball BB is_ground_atm)", "by auto"], ["", "lemma is_ground_atm_mset_union[simp]:\n  \"is_ground_atm_mset (AA + BB) \\<longleftrightarrow> is_ground_atm_mset AA \\<and> is_ground_atm_mset BB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_atm_mset (AA + BB) =\n    (is_ground_atm_mset AA \\<and> is_ground_atm_mset BB)", "unfolding is_ground_atm_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>A. A \\<in># AA + BB \\<longrightarrow> is_ground_atm A) =\n    ((\\<forall>A. A \\<in># AA \\<longrightarrow> is_ground_atm A) \\<and>\n     (\\<forall>A. A \\<in># BB \\<longrightarrow> is_ground_atm A))", "by auto"], ["", "lemma is_ground_cls_union[simp]: \"is_ground_cls (C + D) \\<longleftrightarrow> is_ground_cls C \\<and> is_ground_cls D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_cls (C + D) = (is_ground_cls C \\<and> is_ground_cls D)", "unfolding is_ground_cls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>L. L \\<in># C + D \\<longrightarrow> is_ground_lit L) =\n    ((\\<forall>L. L \\<in># C \\<longrightarrow> is_ground_lit L) \\<and>\n     (\\<forall>L. L \\<in># D \\<longrightarrow> is_ground_lit L))", "by auto"], ["", "lemma is_ground_clss_union[simp]:\n  \"is_ground_clss (CC \\<union> DD) \\<longleftrightarrow> is_ground_clss CC \\<and> is_ground_clss DD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_clss (CC \\<union> DD) =\n    (is_ground_clss CC \\<and> is_ground_clss DD)", "unfolding is_ground_clss_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (CC \\<union> DD) is_ground_cls =\n    (Ball CC is_ground_cls \\<and> Ball DD is_ground_cls)", "by auto"], ["", "lemma is_ground_cls_list_is_ground_cls_sum_list[simp]:\n  \"is_ground_cls_list Cs \\<Longrightarrow> is_ground_cls (sum_list Cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_cls_list Cs \\<Longrightarrow> is_ground_cls (sum_list Cs)", "by (meson in_mset_sum_list2 is_ground_cls_def is_ground_cls_list_def)"], ["", "paragraph \\<open>Grounding monotonicity\\<close>"], ["", "lemma is_ground_cls_mono: \"C \\<subseteq># D \\<Longrightarrow> is_ground_cls D \\<Longrightarrow> is_ground_cls C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<subseteq># D; is_ground_cls D\\<rbrakk>\n    \\<Longrightarrow> is_ground_cls C", "unfolding is_ground_cls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<subseteq># D;\n     \\<forall>L. L \\<in># D \\<longrightarrow> is_ground_lit L\\<rbrakk>\n    \\<Longrightarrow> \\<forall>L.\n                         L \\<in># C \\<longrightarrow> is_ground_lit L", "by (metis set_mset_mono subsetD)"], ["", "lemma is_ground_clss_mono: \"CC \\<subseteq> DD \\<Longrightarrow> is_ground_clss DD \\<Longrightarrow> is_ground_clss CC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>CC \\<subseteq> DD; is_ground_clss DD\\<rbrakk>\n    \\<Longrightarrow> is_ground_clss CC", "unfolding is_ground_clss_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>CC \\<subseteq> DD; Ball DD is_ground_cls\\<rbrakk>\n    \\<Longrightarrow> Ball CC is_ground_cls", "by blast"], ["", "lemma grounding_of_clss_mono: \"CC \\<subseteq> DD \\<Longrightarrow> grounding_of_clss CC \\<subseteq> grounding_of_clss DD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CC \\<subseteq> DD \\<Longrightarrow>\n    grounding_of_clss CC \\<subseteq> grounding_of_clss DD", "using grounding_of_clss_def"], ["proof (prove)\nusing this:\n  grounding_of_clss ?CC = \\<Union> (grounding_of_cls ` ?CC)\n\ngoal (1 subgoal):\n 1. CC \\<subseteq> DD \\<Longrightarrow>\n    grounding_of_clss CC \\<subseteq> grounding_of_clss DD", "by auto"], ["", "lemma sum_list_subseteq_mset_is_ground_cls_list[simp]:\n  \"sum_list Cs \\<subseteq># sum_list Ds \\<Longrightarrow> is_ground_cls_list Ds \\<Longrightarrow> is_ground_cls_list Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sum_list Cs \\<subseteq># sum_list Ds;\n     is_ground_cls_list Ds\\<rbrakk>\n    \\<Longrightarrow> is_ground_cls_list Cs", "by (meson in_mset_sum_list is_ground_cls_def is_ground_cls_list_is_ground_cls_sum_list\n      is_ground_cls_mono is_ground_cls_list_def)"], ["", "paragraph \\<open>Substituting on ground expression preserves ground\\<close>"], ["", "lemma is_ground_comp_subst[simp]: \"is_ground_subst \\<sigma> \\<Longrightarrow> is_ground_subst (\\<tau> \\<odot> \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_subst \\<sigma> \\<Longrightarrow>\n    is_ground_subst (\\<tau> \\<odot> \\<sigma>)", "unfolding is_ground_subst_def is_ground_atm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A \\<sigma>'.\n       A \\<cdot>a \\<sigma> =\n       A \\<cdot>a \\<sigma> \\<cdot>a \\<sigma>' \\<Longrightarrow>\n    \\<forall>A \\<sigma>'.\n       A \\<cdot>a (\\<tau> \\<odot> \\<sigma>) =\n       A \\<cdot>a (\\<tau> \\<odot> \\<sigma>) \\<cdot>a \\<sigma>'", "by auto"], ["", "lemma ground_subst_ground_atm[simp]: \"is_ground_subst \\<sigma> \\<Longrightarrow> is_ground_atm (A \\<cdot>a \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_subst \\<sigma> \\<Longrightarrow>\n    is_ground_atm (A \\<cdot>a \\<sigma>)", "by (simp add: is_ground_subst_def)"], ["", "lemma ground_subst_ground_lit[simp]: \"is_ground_subst \\<sigma> \\<Longrightarrow> is_ground_lit (L \\<cdot>l \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_subst \\<sigma> \\<Longrightarrow>\n    is_ground_lit (L \\<cdot>l \\<sigma>)", "unfolding is_ground_lit_def subst_lit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_subst \\<sigma> \\<Longrightarrow>\n    is_ground_atm (atm_of (map_literal (\\<lambda>A. A \\<cdot>a \\<sigma>) L))", "by (cases L) auto"], ["", "lemma ground_subst_ground_cls[simp]: \"is_ground_subst \\<sigma> \\<Longrightarrow> is_ground_cls (C \\<cdot> \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_subst \\<sigma> \\<Longrightarrow>\n    is_ground_cls (C \\<cdot> \\<sigma>)", "unfolding is_ground_cls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_subst \\<sigma> \\<Longrightarrow>\n    \\<forall>L.\n       L \\<in># C \\<cdot> \\<sigma> \\<longrightarrow> is_ground_lit L", "by auto"], ["", "lemma ground_subst_ground_clss[simp]: \"is_ground_subst \\<sigma> \\<Longrightarrow> is_ground_clss (CC \\<cdot>cs \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_subst \\<sigma> \\<Longrightarrow>\n    is_ground_clss (CC \\<cdot>cs \\<sigma>)", "unfolding is_ground_clss_def subst_clss_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_subst \\<sigma> \\<Longrightarrow>\n    Ball ((\\<lambda>A. A \\<cdot> \\<sigma>) ` CC) is_ground_cls", "by auto"], ["", "lemma ground_subst_ground_cls_list[simp]: \"is_ground_subst \\<sigma> \\<Longrightarrow> is_ground_cls_list (Cs \\<cdot>cl \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_subst \\<sigma> \\<Longrightarrow>\n    is_ground_cls_list (Cs \\<cdot>cl \\<sigma>)", "unfolding is_ground_cls_list_def subst_cls_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_subst \\<sigma> \\<Longrightarrow>\n    Ball (set (map (\\<lambda>A. A \\<cdot> \\<sigma>) Cs)) is_ground_cls", "by auto"], ["", "lemma ground_subst_ground_cls_lists[simp]:\n  \"\\<forall>\\<sigma> \\<in> set \\<sigma>s. is_ground_subst \\<sigma> \\<Longrightarrow> is_ground_cls_list (Cs \\<cdot>\\<cdot>cl \\<sigma>s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (set \\<sigma>s) is_ground_subst \\<Longrightarrow>\n    is_ground_cls_list (Cs \\<cdot>\\<cdot>cl \\<sigma>s)", "unfolding is_ground_cls_list_def subst_cls_lists_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (set \\<sigma>s) is_ground_subst \\<Longrightarrow>\n    Ball (set (Map2.map2 (\\<cdot>) Cs \\<sigma>s)) is_ground_cls", "by (auto simp: set_zip)"], ["", "lemma subst_cls_eq_grounding_of_cls_subset_eq:\n  assumes \"D \\<cdot> \\<sigma> = C\"\n  shows \"grounding_of_cls C \\<subseteq> grounding_of_cls D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. grounding_of_cls C \\<subseteq> grounding_of_cls D", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> grounding_of_cls C \\<Longrightarrow>\n       x \\<in> grounding_of_cls D", "fix C\\<sigma>'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> grounding_of_cls C \\<Longrightarrow>\n       x \\<in> grounding_of_cls D", "assume \"C\\<sigma>' \\<in> grounding_of_cls C\""], ["proof (state)\nthis:\n  C\\<sigma>' \\<in> grounding_of_cls C\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> grounding_of_cls C \\<Longrightarrow>\n       x \\<in> grounding_of_cls D", "then"], ["proof (chain)\npicking this:\n  C\\<sigma>' \\<in> grounding_of_cls C", "obtain \\<sigma>' where\n    C\\<sigma>': \"C \\<cdot> \\<sigma>' = C\\<sigma>'\" \"is_ground_subst \\<sigma>'\""], ["proof (prove)\nusing this:\n  C\\<sigma>' \\<in> grounding_of_cls C\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>'.\n        \\<lbrakk>C \\<cdot> \\<sigma>' = C\\<sigma>';\n         is_ground_subst \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding grounding_of_cls_def"], ["proof (prove)\nusing this:\n  C\\<sigma>' \\<in> {C \\<cdot> \\<sigma> |\\<sigma>. is_ground_subst \\<sigma>}\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>'.\n        \\<lbrakk>C \\<cdot> \\<sigma>' = C\\<sigma>';\n         is_ground_subst \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  C \\<cdot> \\<sigma>' = C\\<sigma>'\n  is_ground_subst \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> grounding_of_cls C \\<Longrightarrow>\n       x \\<in> grounding_of_cls D", "then"], ["proof (chain)\npicking this:\n  C \\<cdot> \\<sigma>' = C\\<sigma>'\n  is_ground_subst \\<sigma>'", "have \"C \\<cdot> \\<sigma>' = D \\<cdot> \\<sigma> \\<cdot> \\<sigma>' \\<and> is_ground_subst (\\<sigma> \\<odot> \\<sigma>')\""], ["proof (prove)\nusing this:\n  C \\<cdot> \\<sigma>' = C\\<sigma>'\n  is_ground_subst \\<sigma>'\n\ngoal (1 subgoal):\n 1. C \\<cdot> \\<sigma>' = D \\<cdot> \\<sigma> \\<cdot> \\<sigma>' \\<and>\n    is_ground_subst (\\<sigma> \\<odot> \\<sigma>')", "using assms"], ["proof (prove)\nusing this:\n  C \\<cdot> \\<sigma>' = C\\<sigma>'\n  is_ground_subst \\<sigma>'\n  D \\<cdot> \\<sigma> = C\n\ngoal (1 subgoal):\n 1. C \\<cdot> \\<sigma>' = D \\<cdot> \\<sigma> \\<cdot> \\<sigma>' \\<and>\n    is_ground_subst (\\<sigma> \\<odot> \\<sigma>')", "by auto"], ["proof (state)\nthis:\n  C \\<cdot> \\<sigma>' = D \\<cdot> \\<sigma> \\<cdot> \\<sigma>' \\<and>\n  is_ground_subst (\\<sigma> \\<odot> \\<sigma>')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> grounding_of_cls C \\<Longrightarrow>\n       x \\<in> grounding_of_cls D", "then"], ["proof (chain)\npicking this:\n  C \\<cdot> \\<sigma>' = D \\<cdot> \\<sigma> \\<cdot> \\<sigma>' \\<and>\n  is_ground_subst (\\<sigma> \\<odot> \\<sigma>')", "show \"C\\<sigma>' \\<in> grounding_of_cls D\""], ["proof (prove)\nusing this:\n  C \\<cdot> \\<sigma>' = D \\<cdot> \\<sigma> \\<cdot> \\<sigma>' \\<and>\n  is_ground_subst (\\<sigma> \\<odot> \\<sigma>')\n\ngoal (1 subgoal):\n 1. C\\<sigma>' \\<in> grounding_of_cls D", "unfolding grounding_of_cls_def"], ["proof (prove)\nusing this:\n  C \\<cdot> \\<sigma>' = D \\<cdot> \\<sigma> \\<cdot> \\<sigma>' \\<and>\n  is_ground_subst (\\<sigma> \\<odot> \\<sigma>')\n\ngoal (1 subgoal):\n 1. C\\<sigma>'\n    \\<in> {D \\<cdot> \\<sigma> |\\<sigma>. is_ground_subst \\<sigma>}", "using C\\<sigma>'(1)"], ["proof (prove)\nusing this:\n  C \\<cdot> \\<sigma>' = D \\<cdot> \\<sigma> \\<cdot> \\<sigma>' \\<and>\n  is_ground_subst (\\<sigma> \\<odot> \\<sigma>')\n  C \\<cdot> \\<sigma>' = C\\<sigma>'\n\ngoal (1 subgoal):\n 1. C\\<sigma>'\n    \\<in> {D \\<cdot> \\<sigma> |\\<sigma>. is_ground_subst \\<sigma>}", "by force"], ["proof (state)\nthis:\n  C\\<sigma>' \\<in> grounding_of_cls D\n\ngoal:\nNo subgoals!", "qed"], ["", "paragraph \\<open>Substituting on ground expression has no effect\\<close>"], ["", "lemma is_ground_subst_atm[simp]: \"is_ground_atm A \\<Longrightarrow> A \\<cdot>a \\<sigma> = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_atm A \\<Longrightarrow> A \\<cdot>a \\<sigma> = A", "unfolding is_ground_atm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>. A = A \\<cdot>a \\<sigma> \\<Longrightarrow>\n    A \\<cdot>a \\<sigma> = A", "by simp"], ["", "lemma is_ground_subst_atms[simp]: \"is_ground_atms AA \\<Longrightarrow> AA \\<cdot>as \\<sigma> = AA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_atms AA \\<Longrightarrow> AA \\<cdot>as \\<sigma> = AA", "unfolding is_ground_atms_def subst_atms_def image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball AA is_ground_atm \\<Longrightarrow>\n    {y. \\<exists>x\\<in>AA. y = x \\<cdot>a \\<sigma>} = AA", "by auto"], ["", "lemma is_ground_subst_atm_mset[simp]: \"is_ground_atm_mset AA \\<Longrightarrow> AA \\<cdot>am \\<sigma> = AA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_atm_mset AA \\<Longrightarrow> AA \\<cdot>am \\<sigma> = AA", "unfolding is_ground_atm_mset_def subst_atm_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A.\n       A \\<in># AA \\<longrightarrow> is_ground_atm A \\<Longrightarrow>\n    {#A \\<cdot>a \\<sigma>. A \\<in># AA#} = AA", "by auto"], ["", "lemma is_ground_subst_atm_list[simp]: \"is_ground_atm_list As \\<Longrightarrow> As \\<cdot>al \\<sigma> = As\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_atm_list As \\<Longrightarrow> As \\<cdot>al \\<sigma> = As", "unfolding is_ground_atm_list_def subst_atm_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (set As) is_ground_atm \\<Longrightarrow>\n    map (\\<lambda>A. A \\<cdot>a \\<sigma>) As = As", "by (auto intro: nth_equalityI)"], ["", "lemma is_ground_subst_atm_list_member[simp]:\n  \"is_ground_atm_list As \\<Longrightarrow> i < length As \\<Longrightarrow> As ! i \\<cdot>a \\<sigma> = As ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_ground_atm_list As; i < length As\\<rbrakk>\n    \\<Longrightarrow> As ! i \\<cdot>a \\<sigma> = As ! i", "unfolding is_ground_atm_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ball (set As) is_ground_atm; i < length As\\<rbrakk>\n    \\<Longrightarrow> As ! i \\<cdot>a \\<sigma> = As ! i", "by auto"], ["", "lemma is_ground_subst_lit[simp]: \"is_ground_lit L \\<Longrightarrow> L \\<cdot>l \\<sigma> = L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_lit L \\<Longrightarrow> L \\<cdot>l \\<sigma> = L", "unfolding is_ground_lit_def subst_lit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_atm (atm_of L) \\<Longrightarrow>\n    map_literal (\\<lambda>A. A \\<cdot>a \\<sigma>) L = L", "by (cases L) simp_all"], ["", "lemma is_ground_subst_cls[simp]: \"is_ground_cls C \\<Longrightarrow> C \\<cdot> \\<sigma> = C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_cls C \\<Longrightarrow> C \\<cdot> \\<sigma> = C", "unfolding is_ground_cls_def subst_cls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>L.\n       L \\<in># C \\<longrightarrow> is_ground_lit L \\<Longrightarrow>\n    {#A \\<cdot>l \\<sigma>. A \\<in># C#} = C", "by simp"], ["", "lemma is_ground_subst_clss[simp]: \"is_ground_clss CC \\<Longrightarrow> CC \\<cdot>cs \\<sigma> = CC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_clss CC \\<Longrightarrow> CC \\<cdot>cs \\<sigma> = CC", "unfolding is_ground_clss_def subst_clss_def image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball CC is_ground_cls \\<Longrightarrow>\n    {y. \\<exists>x\\<in>CC. y = x \\<cdot> \\<sigma>} = CC", "by auto"], ["", "lemma is_ground_subst_cls_lists[simp]:\n  assumes \"length P = length Cs\" and \"is_ground_cls_list Cs\"\n  shows \"Cs \\<cdot>\\<cdot>cl P = Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cs \\<cdot>\\<cdot>cl P = Cs", "using assms"], ["proof (prove)\nusing this:\n  length P = length Cs\n  is_ground_cls_list Cs\n\ngoal (1 subgoal):\n 1. Cs \\<cdot>\\<cdot>cl P = Cs", "by (metis is_ground_cls_list_def is_ground_subst_cls min.idem nth_equalityI nth_mem\n      subst_cls_lists_nth subst_cls_lists_length)"], ["", "lemma is_ground_subst_lit_iff: \"is_ground_lit L \\<longleftrightarrow> (\\<forall>\\<sigma>. L = L \\<cdot>l \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_lit L = (\\<forall>\\<sigma>. L = L \\<cdot>l \\<sigma>)", "using is_ground_atm_def is_ground_lit_def subst_lit_def"], ["proof (prove)\nusing this:\n  is_ground_atm ?A = (\\<forall>\\<sigma>. ?A = ?A \\<cdot>a \\<sigma>)\n  is_ground_lit ?L = is_ground_atm (atm_of ?L)\n  ?L \\<cdot>l ?\\<sigma> = map_literal (\\<lambda>A. A \\<cdot>a ?\\<sigma>) ?L\n\ngoal (1 subgoal):\n 1. is_ground_lit L = (\\<forall>\\<sigma>. L = L \\<cdot>l \\<sigma>)", "by (cases L) auto"], ["", "lemma is_ground_subst_cls_iff: \"is_ground_cls C \\<longleftrightarrow> (\\<forall>\\<sigma>. C = C \\<cdot> \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_cls C = (\\<forall>\\<sigma>. C = C \\<cdot> \\<sigma>)", "by (metis ex_ground_subst ground_subst_ground_cls is_ground_subst_cls)"], ["", "paragraph \\<open>Members of ground expressions are ground\\<close>"], ["", "lemma is_ground_cls_as_atms: \"is_ground_cls C \\<longleftrightarrow> (\\<forall>A \\<in> atms_of C. is_ground_atm A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_cls C = Ball (atms_of C) is_ground_atm", "by (auto simp: atms_of_def is_ground_cls_def is_ground_lit_def)"], ["", "lemma is_ground_cls_imp_is_ground_lit: \"L \\<in># C \\<Longrightarrow> is_ground_cls C \\<Longrightarrow> is_ground_lit L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>L \\<in># C; is_ground_cls C\\<rbrakk>\n    \\<Longrightarrow> is_ground_lit L", "by (simp add: is_ground_cls_def)"], ["", "lemma is_ground_cls_imp_is_ground_atm: \"A \\<in> atms_of C \\<Longrightarrow> is_ground_cls C \\<Longrightarrow> is_ground_atm A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> atms_of C; is_ground_cls C\\<rbrakk>\n    \\<Longrightarrow> is_ground_atm A", "by (simp add: is_ground_cls_as_atms)"], ["", "lemma is_ground_cls_is_ground_atms_atms_of[simp]: \"is_ground_cls C \\<Longrightarrow> is_ground_atms (atms_of C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_cls C \\<Longrightarrow> is_ground_atms (atms_of C)", "by (simp add: is_ground_cls_imp_is_ground_atm is_ground_atms_def)"], ["", "lemma grounding_ground: \"C \\<in> grounding_of_clss M \\<Longrightarrow> is_ground_cls C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<in> grounding_of_clss M \\<Longrightarrow> is_ground_cls C", "unfolding grounding_of_clss_def grounding_of_cls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<in> (\\<Union>C\\<in>M.\n                {C \\<cdot> \\<sigma> |\\<sigma>.\n                 is_ground_subst \\<sigma>}) \\<Longrightarrow>\n    is_ground_cls C", "by auto"], ["", "lemma in_subset_eq_grounding_of_clss_is_ground_cls[simp]:\n  \"C \\<in> CC \\<Longrightarrow> CC \\<subseteq> grounding_of_clss DD \\<Longrightarrow> is_ground_cls C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<in> CC; CC \\<subseteq> grounding_of_clss DD\\<rbrakk>\n    \\<Longrightarrow> is_ground_cls C", "unfolding grounding_of_clss_def grounding_of_cls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<in> CC;\n     CC \\<subseteq> (\\<Union>C\\<in>DD.\n                        {C \\<cdot> \\<sigma> |\\<sigma>.\n                         is_ground_subst \\<sigma>})\\<rbrakk>\n    \\<Longrightarrow> is_ground_cls C", "by auto"], ["", "lemma is_ground_cls_empty[simp]: \"is_ground_cls {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_cls {#}", "unfolding is_ground_cls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>L. L \\<in># {#} \\<longrightarrow> is_ground_lit L", "by simp"], ["", "lemma grounding_of_cls_ground: \"is_ground_cls C \\<Longrightarrow> grounding_of_cls C = {C}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_cls C \\<Longrightarrow> grounding_of_cls C = {C}", "unfolding grounding_of_cls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_cls C \\<Longrightarrow>\n    {C \\<cdot> \\<sigma> |\\<sigma>. is_ground_subst \\<sigma>} = {C}", "by (simp add: ex_ground_subst)"], ["", "lemma grounding_of_cls_empty[simp]: \"grounding_of_cls {#} = {{#}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. grounding_of_cls {#} = {{#}}", "by (simp add: grounding_of_cls_ground)"], ["", "lemma union_grounding_of_cls_ground: \"is_ground_clss (\\<Union> (grounding_of_cls ` N))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_clss (\\<Union> (grounding_of_cls ` N))", "by (simp add: grounding_ground grounding_of_clss_def is_ground_clss_def)"], ["", "paragraph \\<open>Grounding idempotence\\<close>"], ["", "lemma grounding_of_grounding_of_cls: \"E \\<in> grounding_of_cls D \\<Longrightarrow> D \\<in> grounding_of_cls C \\<Longrightarrow> E = D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>E \\<in> grounding_of_cls D; D \\<in> grounding_of_cls C\\<rbrakk>\n    \\<Longrightarrow> E = D", "using grounding_of_cls_def"], ["proof (prove)\nusing this:\n  grounding_of_cls ?C =\n  {?C \\<cdot> \\<sigma> |\\<sigma>. is_ground_subst \\<sigma>}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>E \\<in> grounding_of_cls D; D \\<in> grounding_of_cls C\\<rbrakk>\n    \\<Longrightarrow> E = D", "by auto"], ["", "subsubsection \\<open>Subsumption\\<close>"], ["", "lemma subsumes_empty_left[simp]: \"subsumes {#} C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subsumes {#} C", "unfolding subsumes_def subst_cls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>. {#A \\<cdot>l \\<sigma>. A \\<in># {#}#} \\<subseteq># C", "by simp"], ["", "lemma strictly_subsumes_empty_left[simp]: \"strictly_subsumes {#} C \\<longleftrightarrow> C \\<noteq> {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strictly_subsumes {#} C = (C \\<noteq> {#})", "unfolding strictly_subsumes_def subsumes_def subst_cls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<exists>\\<sigma>.\n         {#A \\<cdot>l \\<sigma>. A \\<in># {#}#} \\<subseteq># C) \\<and>\n     (\\<nexists>\\<sigma>.\n         {#A \\<cdot>l \\<sigma>. A \\<in># C#} \\<subseteq># {#})) =\n    (C \\<noteq> {#})", "by simp"], ["", "subsubsection \\<open>Unifiers\\<close>"], ["", "lemma card_le_one_alt: \"finite X \\<Longrightarrow> card X \\<le> 1 \\<longleftrightarrow> X = {} \\<or> (\\<exists>x. X = {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite X \\<Longrightarrow>\n    (card X \\<le> 1) = (X = {} \\<or> (\\<exists>x. X = {x}))", "by (induct rule: finite_induct) auto"], ["", "lemma is_unifier_subst_atm_eqI:\n  assumes \"finite AA\"\n  shows \"is_unifier \\<sigma> AA \\<Longrightarrow> A \\<in> AA \\<Longrightarrow> B \\<in> AA \\<Longrightarrow> A \\<cdot>a \\<sigma> = B \\<cdot>a \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_unifier \\<sigma> AA; A \\<in> AA; B \\<in> AA\\<rbrakk>\n    \\<Longrightarrow> A \\<cdot>a \\<sigma> = B \\<cdot>a \\<sigma>", "unfolding is_unifier_def subst_atms_def card_le_one_alt[OF finite_imageI[OF assms]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<lambda>A. A \\<cdot>a \\<sigma>) ` AA = {} \\<or>\n             (\\<exists>x. (\\<lambda>A. A \\<cdot>a \\<sigma>) ` AA = {x});\n     A \\<in> AA; B \\<in> AA\\<rbrakk>\n    \\<Longrightarrow> A \\<cdot>a \\<sigma> = B \\<cdot>a \\<sigma>", "by (metis equals0D imageI insert_iff)"], ["", "lemma is_unifier_alt:\n  assumes \"finite AA\"\n  shows \"is_unifier \\<sigma> AA \\<longleftrightarrow> (\\<forall>A \\<in> AA. \\<forall>B \\<in> AA. A \\<cdot>a \\<sigma> = B \\<cdot>a \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unifier \\<sigma> AA =\n    (\\<forall>A\\<in>AA.\n        \\<forall>B\\<in>AA. A \\<cdot>a \\<sigma> = B \\<cdot>a \\<sigma>)", "unfolding is_unifier_def subst_atms_def card_le_one_alt[OF finite_imageI[OF assms(1)]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>A. A \\<cdot>a \\<sigma>) ` AA = {} \\<or>\n     (\\<exists>x. (\\<lambda>A. A \\<cdot>a \\<sigma>) ` AA = {x})) =\n    (\\<forall>A\\<in>AA.\n        \\<forall>B\\<in>AA. A \\<cdot>a \\<sigma> = B \\<cdot>a \\<sigma>)", "by (rule iffI, metis empty_iff insert_iff insert_image, blast)"], ["", "lemma is_unifiers_subst_atm_eqI:\n  assumes \"finite AA\" \"is_unifiers \\<sigma> AAA\" \"AA \\<in> AAA\" \"A \\<in> AA\" \"B \\<in> AA\"\n  shows \"A \\<cdot>a \\<sigma> = B \\<cdot>a \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<cdot>a \\<sigma> = B \\<cdot>a \\<sigma>", "by (metis assms is_unifiers_def is_unifier_subst_atm_eqI)"], ["", "theorem is_unifiers_comp:\n  \"is_unifiers \\<sigma> (set_mset ` set (map2 add_mset As Bs) \\<cdot>ass \\<eta>) \\<longleftrightarrow>\n   is_unifiers (\\<eta> \\<odot> \\<sigma>) (set_mset ` set (map2 add_mset As Bs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unifiers \\<sigma>\n     (set_mset ` set (Map2.map2 add_mset As Bs) \\<cdot>ass \\<eta>) =\n    is_unifiers (\\<eta> \\<odot> \\<sigma>)\n     (set_mset ` set (Map2.map2 add_mset As Bs))", "unfolding is_unifiers_def is_unifier_def subst_atmss_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>AA\\<in>(\\<lambda>AA. AA \\<cdot>as \\<eta>) `\n                     set_mset ` set (Map2.map2 add_mset As Bs).\n        card (AA \\<cdot>as \\<sigma>) \\<le> 1) =\n    (\\<forall>AA\\<in>set_mset ` set (Map2.map2 add_mset As Bs).\n        card (AA \\<cdot>as (\\<eta> \\<odot> \\<sigma>)) \\<le> 1)", "by auto"], ["", "subsubsection \\<open>Most General Unifier\\<close>"], ["", "lemma is_mgu_is_unifiers: \"is_mgu \\<sigma> AAA \\<Longrightarrow> is_unifiers \\<sigma> AAA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_mgu \\<sigma> AAA \\<Longrightarrow> is_unifiers \\<sigma> AAA", "using is_mgu_def"], ["proof (prove)\nusing this:\n  is_mgu ?\\<sigma> ?AAA =\n  (is_unifiers ?\\<sigma> ?AAA \\<and>\n   (\\<forall>\\<tau>.\n       is_unifiers \\<tau> ?AAA \\<longrightarrow>\n       (\\<exists>\\<gamma>. \\<tau> = ?\\<sigma> \\<odot> \\<gamma>)))\n\ngoal (1 subgoal):\n 1. is_mgu \\<sigma> AAA \\<Longrightarrow> is_unifiers \\<sigma> AAA", "by blast"], ["", "lemma is_mgu_is_most_general: \"is_mgu \\<sigma> AAA \\<Longrightarrow> is_unifiers \\<tau> AAA \\<Longrightarrow> \\<exists>\\<gamma>. \\<tau> = \\<sigma> \\<odot> \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_mgu \\<sigma> AAA; is_unifiers \\<tau> AAA\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<gamma>. \\<tau> = \\<sigma> \\<odot> \\<gamma>", "using is_mgu_def"], ["proof (prove)\nusing this:\n  is_mgu ?\\<sigma> ?AAA =\n  (is_unifiers ?\\<sigma> ?AAA \\<and>\n   (\\<forall>\\<tau>.\n       is_unifiers \\<tau> ?AAA \\<longrightarrow>\n       (\\<exists>\\<gamma>. \\<tau> = ?\\<sigma> \\<odot> \\<gamma>)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_mgu \\<sigma> AAA; is_unifiers \\<tau> AAA\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<gamma>. \\<tau> = \\<sigma> \\<odot> \\<gamma>", "by blast"], ["", "lemma is_unifiers_is_unifier: \"is_unifiers \\<sigma> AAA \\<Longrightarrow> AA \\<in> AAA \\<Longrightarrow> is_unifier \\<sigma> AA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_unifiers \\<sigma> AAA; AA \\<in> AAA\\<rbrakk>\n    \\<Longrightarrow> is_unifier \\<sigma> AA", "using is_unifiers_def"], ["proof (prove)\nusing this:\n  is_unifiers ?\\<sigma> ?AAA =\n  (\\<forall>AA\\<in>?AAA. is_unifier ?\\<sigma> AA)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_unifiers \\<sigma> AAA; AA \\<in> AAA\\<rbrakk>\n    \\<Longrightarrow> is_unifier \\<sigma> AA", "by simp"], ["", "subsubsection \\<open>Generalization and Subsumption\\<close>"], ["", "lemma variants_sym: \"variants D D' \\<longleftrightarrow> variants D' D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. variants D D' = variants D' D", "unfolding variants_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (generalizes D D' \\<and> generalizes D' D) =\n    (generalizes D' D \\<and> generalizes D D')", "by auto"], ["", "lemma variants_iff_subsumes: \"variants C D \\<longleftrightarrow> subsumes C D \\<and> subsumes D C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. variants C D = (subsumes C D \\<and> subsumes D C)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. variants C D \\<Longrightarrow> subsumes C D \\<and> subsumes D C\n 2. subsumes C D \\<and> subsumes D C \\<Longrightarrow> variants C D", "assume \"variants C D\""], ["proof (state)\nthis:\n  variants C D\n\ngoal (2 subgoals):\n 1. variants C D \\<Longrightarrow> subsumes C D \\<and> subsumes D C\n 2. subsumes C D \\<and> subsumes D C \\<Longrightarrow> variants C D", "then"], ["proof (chain)\npicking this:\n  variants C D", "show \"subsumes C D \\<and> subsumes D C\""], ["proof (prove)\nusing this:\n  variants C D\n\ngoal (1 subgoal):\n 1. subsumes C D \\<and> subsumes D C", "unfolding variants_def generalizes_def subsumes_def"], ["proof (prove)\nusing this:\n  (\\<exists>\\<sigma>. C \\<cdot> \\<sigma> = D) \\<and>\n  (\\<exists>\\<sigma>. D \\<cdot> \\<sigma> = C)\n\ngoal (1 subgoal):\n 1. (\\<exists>\\<sigma>. C \\<cdot> \\<sigma> \\<subseteq># D) \\<and>\n    (\\<exists>\\<sigma>. D \\<cdot> \\<sigma> \\<subseteq># C)", "by (metis subset_mset.order.refl)"], ["proof (state)\nthis:\n  subsumes C D \\<and> subsumes D C\n\ngoal (1 subgoal):\n 1. subsumes C D \\<and> subsumes D C \\<Longrightarrow> variants C D", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. subsumes C D \\<and> subsumes D C \\<Longrightarrow> variants C D", "assume sub: \"subsumes C D \\<and> subsumes D C\""], ["proof (state)\nthis:\n  subsumes C D \\<and> subsumes D C\n\ngoal (1 subgoal):\n 1. subsumes C D \\<and> subsumes D C \\<Longrightarrow> variants C D", "then"], ["proof (chain)\npicking this:\n  subsumes C D \\<and> subsumes D C", "have \"size C = size D\""], ["proof (prove)\nusing this:\n  subsumes C D \\<and> subsumes D C\n\ngoal (1 subgoal):\n 1. size C = size D", "unfolding subsumes_def"], ["proof (prove)\nusing this:\n  (\\<exists>\\<sigma>. C \\<cdot> \\<sigma> \\<subseteq># D) \\<and>\n  (\\<exists>\\<sigma>. D \\<cdot> \\<sigma> \\<subseteq># C)\n\ngoal (1 subgoal):\n 1. size C = size D", "by (metis antisym size_mset_mono size_subst)"], ["proof (state)\nthis:\n  size C = size D\n\ngoal (1 subgoal):\n 1. subsumes C D \\<and> subsumes D C \\<Longrightarrow> variants C D", "then"], ["proof (chain)\npicking this:\n  size C = size D", "show \"variants C D\""], ["proof (prove)\nusing this:\n  size C = size D\n\ngoal (1 subgoal):\n 1. variants C D", "using sub"], ["proof (prove)\nusing this:\n  size C = size D\n  subsumes C D \\<and> subsumes D C\n\ngoal (1 subgoal):\n 1. variants C D", "unfolding subsumes_def variants_def generalizes_def"], ["proof (prove)\nusing this:\n  size C = size D\n  (\\<exists>\\<sigma>. C \\<cdot> \\<sigma> \\<subseteq># D) \\<and>\n  (\\<exists>\\<sigma>. D \\<cdot> \\<sigma> \\<subseteq># C)\n\ngoal (1 subgoal):\n 1. (\\<exists>\\<sigma>. C \\<cdot> \\<sigma> = D) \\<and>\n    (\\<exists>\\<sigma>. D \\<cdot> \\<sigma> = C)", "by (metis leD mset_subset_size size_mset_mono size_subst\n        subset_mset.order.not_eq_order_implies_strict)"], ["proof (state)\nthis:\n  variants C D\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wf_strictly_generalizes: \"wfP strictly_generalizes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfP strictly_generalizes", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wfP strictly_generalizes", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. wfP strictly_generalizes", "assume \"\\<exists>C_at. \\<forall>i. strictly_generalizes (C_at (Suc i)) (C_at i)\""], ["proof (state)\nthis:\n  \\<exists>C_at. \\<forall>i. strictly_generalizes (C_at (Suc i)) (C_at i)\n\ngoal (1 subgoal):\n 1. wfP strictly_generalizes", "then"], ["proof (chain)\npicking this:\n  \\<exists>C_at. \\<forall>i. strictly_generalizes (C_at (Suc i)) (C_at i)", "obtain C_at :: \"nat \\<Rightarrow> 'a clause\" where\n      sg_C: \"\\<And>i. strictly_generalizes (C_at (Suc i)) (C_at i)\""], ["proof (prove)\nusing this:\n  \\<exists>C_at. \\<forall>i. strictly_generalizes (C_at (Suc i)) (C_at i)\n\ngoal (1 subgoal):\n 1. (\\<And>C_at.\n        (\\<And>i.\n            strictly_generalizes (C_at (Suc i)) (C_at i)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  strictly_generalizes (C_at (Suc ?i)) (C_at ?i)\n\ngoal (1 subgoal):\n 1. wfP strictly_generalizes", "define n :: nat where\n      \"n = size (C_at 0)\""], ["proof (state)\nthis:\n  n = size (C_at 0)\n\ngoal (1 subgoal):\n 1. wfP strictly_generalizes", "have sz_C: \"size (C_at i) = n\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. size (C_at i) = n", "proof (induct i)"], ["proof (state)\ngoal (2 subgoals):\n 1. size (C_at 0) = n\n 2. \\<And>i. size (C_at i) = n \\<Longrightarrow> size (C_at (Suc i)) = n", "case (Suc i)"], ["proof (state)\nthis:\n  size (C_at i) = n\n\ngoal (2 subgoals):\n 1. size (C_at 0) = n\n 2. \\<And>i. size (C_at i) = n \\<Longrightarrow> size (C_at (Suc i)) = n", "then"], ["proof (chain)\npicking this:\n  size (C_at i) = n", "show ?case"], ["proof (prove)\nusing this:\n  size (C_at i) = n\n\ngoal (1 subgoal):\n 1. size (C_at (Suc i)) = n", "using sg_C[of i]"], ["proof (prove)\nusing this:\n  size (C_at i) = n\n  strictly_generalizes (C_at (Suc i)) (C_at i)\n\ngoal (1 subgoal):\n 1. size (C_at (Suc i)) = n", "unfolding strictly_generalizes_def generalizes_def subst_cls_def"], ["proof (prove)\nusing this:\n  size (C_at i) = n\n  (\\<exists>\\<sigma>.\n      {#A \\<cdot>l \\<sigma>. A \\<in># C_at (Suc i)#} = C_at i) \\<and>\n  (\\<nexists>\\<sigma>.\n      {#A \\<cdot>l \\<sigma>. A \\<in># C_at i#} = C_at (Suc i))\n\ngoal (1 subgoal):\n 1. size (C_at (Suc i)) = n", "by (metis size_image_mset)"], ["proof (state)\nthis:\n  size (C_at (Suc i)) = n\n\ngoal (1 subgoal):\n 1. size (C_at 0) = n", "qed (simp add: n_def)"], ["proof (state)\nthis:\n  size (C_at ?i) = n\n\ngoal (1 subgoal):\n 1. wfP strictly_generalizes", "obtain \\<sigma>_at :: \"nat \\<Rightarrow> 's\" where\n      C_\\<sigma>: \"\\<And>i. image_mset (\\<lambda>L. L \\<cdot>l \\<sigma>_at i) (C_at (Suc i)) = C_at i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>_at.\n        (\\<And>i.\n            {#L \\<cdot>l \\<sigma>_at i. L \\<in># C_at (Suc i)#} =\n            C_at i) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using sg_C[unfolded strictly_generalizes_def generalizes_def subst_cls_def]"], ["proof (prove)\nusing this:\n  (\\<exists>\\<sigma>.\n      {#A \\<cdot>l \\<sigma>. A \\<in># C_at (Suc ?i)#} = C_at ?i) \\<and>\n  (\\<nexists>\\<sigma>.\n      {#A \\<cdot>l \\<sigma>. A \\<in># C_at ?i#} = C_at (Suc ?i))\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>_at.\n        (\\<And>i.\n            {#L \\<cdot>l \\<sigma>_at i. L \\<in># C_at (Suc i)#} =\n            C_at i) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  {#L \\<cdot>l \\<sigma>_at ?i. L \\<in># C_at (Suc ?i)#} = C_at ?i\n\ngoal (1 subgoal):\n 1. wfP strictly_generalizes", "define Ls_at :: \"nat \\<Rightarrow> 'a literal list\" where\n      \"Ls_at = rec_nat (SOME Ls. mset Ls = C_at 0)\n         (\\<lambda>i Lsi. SOME Ls. mset Ls = C_at (Suc i) \\<and> map (\\<lambda>L. L \\<cdot>l \\<sigma>_at i) Ls = Lsi)\""], ["proof (state)\nthis:\n  Ls_at =\n  rec_nat (SOME Ls. mset Ls = C_at 0)\n   (\\<lambda>i Lsi.\n       SOME Ls.\n          mset Ls = C_at (Suc i) \\<and>\n          map (\\<lambda>L. L \\<cdot>l \\<sigma>_at i) Ls = Lsi)\n\ngoal (1 subgoal):\n 1. wfP strictly_generalizes", "have\n      Ls_at_0: \"Ls_at 0 = (SOME Ls. mset Ls = C_at 0)\" and\n      Ls_at_Suc: \"\\<And>i. Ls_at (Suc i) =\n        (SOME Ls. mset Ls = C_at (Suc i) \\<and> map (\\<lambda>L. L \\<cdot>l \\<sigma>_at i) Ls = Ls_at i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ls_at 0 = (SOME Ls. mset Ls = C_at 0) &&&\n    (\\<And>i.\n        Ls_at (Suc i) =\n        (SOME Ls.\n            mset Ls = C_at (Suc i) \\<and>\n            map (\\<lambda>L. L \\<cdot>l \\<sigma>_at i) Ls = Ls_at i))", "unfolding Ls_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_nat (SOME Ls. mset Ls = C_at 0)\n     (\\<lambda>i Lsi.\n         SOME Ls.\n            mset Ls = C_at (Suc i) \\<and>\n            map (\\<lambda>L. L \\<cdot>l \\<sigma>_at i) Ls = Lsi)\n     0 =\n    (SOME Ls. mset Ls = C_at 0) &&&\n    (\\<And>i.\n        rec_nat (SOME Ls. mset Ls = C_at 0)\n         (\\<lambda>i Lsi.\n             SOME Ls.\n                mset Ls = C_at (Suc i) \\<and>\n                map (\\<lambda>L. L \\<cdot>l \\<sigma>_at i) Ls = Lsi)\n         (Suc i) =\n        (SOME Ls.\n            mset Ls = C_at (Suc i) \\<and>\n            map (\\<lambda>L. L \\<cdot>l \\<sigma>_at i) Ls =\n            rec_nat (SOME Ls. mset Ls = C_at 0)\n             (\\<lambda>i Lsi.\n                 SOME Ls.\n                    mset Ls = C_at (Suc i) \\<and>\n                    map (\\<lambda>L. L \\<cdot>l \\<sigma>_at i) Ls = Lsi)\n             i))", "by simp+"], ["proof (state)\nthis:\n  Ls_at 0 = (SOME Ls. mset Ls = C_at 0)\n  Ls_at (Suc ?i) =\n  (SOME Ls.\n      mset Ls = C_at (Suc ?i) \\<and>\n      map (\\<lambda>L. L \\<cdot>l \\<sigma>_at ?i) Ls = Ls_at ?i)\n\ngoal (1 subgoal):\n 1. wfP strictly_generalizes", "have mset_Lt_at_0: \"mset (Ls_at 0) = C_at 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (Ls_at 0) = C_at 0", "unfolding Ls_at_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (SOME Ls. mset Ls = C_at 0) = C_at 0", "by (rule someI_ex) (metis list_of_mset_exi)"], ["proof (state)\nthis:\n  mset (Ls_at 0) = C_at 0\n\ngoal (1 subgoal):\n 1. wfP strictly_generalizes", "have \"mset (Ls_at (Suc i)) = C_at (Suc i) \\<and> map (\\<lambda>L. L \\<cdot>l \\<sigma>_at i) (Ls_at (Suc i)) = Ls_at i\"\n      for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (Ls_at (Suc i)) = C_at (Suc i) \\<and>\n    map (\\<lambda>L. L \\<cdot>l \\<sigma>_at i) (Ls_at (Suc i)) = Ls_at i", "proof (induct i)"], ["proof (state)\ngoal (2 subgoals):\n 1. mset (Ls_at (Suc 0)) = C_at (Suc 0) \\<and>\n    map (\\<lambda>L. L \\<cdot>l \\<sigma>_at 0) (Ls_at (Suc 0)) = Ls_at 0\n 2. \\<And>i.\n       mset (Ls_at (Suc i)) = C_at (Suc i) \\<and>\n       map (\\<lambda>L. L \\<cdot>l \\<sigma>_at i) (Ls_at (Suc i)) =\n       Ls_at i \\<Longrightarrow>\n       mset (Ls_at (Suc (Suc i))) = C_at (Suc (Suc i)) \\<and>\n       map (\\<lambda>L. L \\<cdot>l \\<sigma>_at (Suc i))\n        (Ls_at (Suc (Suc i))) =\n       Ls_at (Suc i)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. mset (Ls_at (Suc 0)) = C_at (Suc 0) \\<and>\n    map (\\<lambda>L. L \\<cdot>l \\<sigma>_at 0) (Ls_at (Suc 0)) = Ls_at 0\n 2. \\<And>i.\n       mset (Ls_at (Suc i)) = C_at (Suc i) \\<and>\n       map (\\<lambda>L. L \\<cdot>l \\<sigma>_at i) (Ls_at (Suc i)) =\n       Ls_at i \\<Longrightarrow>\n       mset (Ls_at (Suc (Suc i))) = C_at (Suc (Suc i)) \\<and>\n       map (\\<lambda>L. L \\<cdot>l \\<sigma>_at (Suc i))\n        (Ls_at (Suc (Suc i))) =\n       Ls_at (Suc i)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (Ls_at (Suc 0)) = C_at (Suc 0) \\<and>\n    map (\\<lambda>L. L \\<cdot>l \\<sigma>_at 0) (Ls_at (Suc 0)) = Ls_at 0", "by (simp add: Ls_at_Suc, rule someI_ex,\n            metis C_\\<sigma> image_mset_of_subset_list mset_Lt_at_0)"], ["proof (state)\nthis:\n  mset (Ls_at (Suc 0)) = C_at (Suc 0) \\<and>\n  map (\\<lambda>L. L \\<cdot>l \\<sigma>_at 0) (Ls_at (Suc 0)) = Ls_at 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       mset (Ls_at (Suc i)) = C_at (Suc i) \\<and>\n       map (\\<lambda>L. L \\<cdot>l \\<sigma>_at i) (Ls_at (Suc i)) =\n       Ls_at i \\<Longrightarrow>\n       mset (Ls_at (Suc (Suc i))) = C_at (Suc (Suc i)) \\<and>\n       map (\\<lambda>L. L \\<cdot>l \\<sigma>_at (Suc i))\n        (Ls_at (Suc (Suc i))) =\n       Ls_at (Suc i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       mset (Ls_at (Suc i)) = C_at (Suc i) \\<and>\n       map (\\<lambda>L. L \\<cdot>l \\<sigma>_at i) (Ls_at (Suc i)) =\n       Ls_at i \\<Longrightarrow>\n       mset (Ls_at (Suc (Suc i))) = C_at (Suc (Suc i)) \\<and>\n       map (\\<lambda>L. L \\<cdot>l \\<sigma>_at (Suc i))\n        (Ls_at (Suc (Suc i))) =\n       Ls_at (Suc i)", "case Suc"], ["proof (state)\nthis:\n  mset (Ls_at (Suc i_)) = C_at (Suc i_) \\<and>\n  map (\\<lambda>L. L \\<cdot>l \\<sigma>_at i_) (Ls_at (Suc i_)) = Ls_at i_\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       mset (Ls_at (Suc i)) = C_at (Suc i) \\<and>\n       map (\\<lambda>L. L \\<cdot>l \\<sigma>_at i) (Ls_at (Suc i)) =\n       Ls_at i \\<Longrightarrow>\n       mset (Ls_at (Suc (Suc i))) = C_at (Suc (Suc i)) \\<and>\n       map (\\<lambda>L. L \\<cdot>l \\<sigma>_at (Suc i))\n        (Ls_at (Suc (Suc i))) =\n       Ls_at (Suc i)", "then"], ["proof (chain)\npicking this:\n  mset (Ls_at (Suc i_)) = C_at (Suc i_) \\<and>\n  map (\\<lambda>L. L \\<cdot>l \\<sigma>_at i_) (Ls_at (Suc i_)) = Ls_at i_", "show ?case"], ["proof (prove)\nusing this:\n  mset (Ls_at (Suc i_)) = C_at (Suc i_) \\<and>\n  map (\\<lambda>L. L \\<cdot>l \\<sigma>_at i_) (Ls_at (Suc i_)) = Ls_at i_\n\ngoal (1 subgoal):\n 1. mset (Ls_at (Suc (Suc i_))) = C_at (Suc (Suc i_)) \\<and>\n    map (\\<lambda>L. L \\<cdot>l \\<sigma>_at (Suc i_))\n     (Ls_at (Suc (Suc i_))) =\n    Ls_at (Suc i_)", "by (subst (1 2) Ls_at_Suc) (rule someI_ex, metis C_\\<sigma> image_mset_of_subset_list)"], ["proof (state)\nthis:\n  mset (Ls_at (Suc (Suc i_))) = C_at (Suc (Suc i_)) \\<and>\n  map (\\<lambda>L. L \\<cdot>l \\<sigma>_at (Suc i_)) (Ls_at (Suc (Suc i_))) =\n  Ls_at (Suc i_)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mset (Ls_at (Suc ?i)) = C_at (Suc ?i) \\<and>\n  map (\\<lambda>L. L \\<cdot>l \\<sigma>_at ?i) (Ls_at (Suc ?i)) = Ls_at ?i\n\ngoal (1 subgoal):\n 1. wfP strictly_generalizes", "note mset_Ls = this[THEN conjunct1] and Ls_\\<sigma> = this[THEN conjunct2]"], ["proof (state)\nthis:\n  mset (Ls_at (Suc ?i1)) = C_at (Suc ?i1)\n  map (\\<lambda>L. L \\<cdot>l \\<sigma>_at ?i1) (Ls_at (Suc ?i1)) = Ls_at ?i1\n\ngoal (1 subgoal):\n 1. wfP strictly_generalizes", "have len_Ls: \"\\<And>i. length (Ls_at i) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. length (Ls_at i) = n", "by (metis mset_Ls mset_Lt_at_0 not0_implies_Suc size_mset sz_C)"], ["proof (state)\nthis:\n  length (Ls_at ?i) = n\n\ngoal (1 subgoal):\n 1. wfP strictly_generalizes", "have is_pos_Ls: \"\\<And>i j. j < n \\<Longrightarrow> is_pos (Ls_at (Suc i) ! j) \\<longleftrightarrow> is_pos (Ls_at i ! j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       j < n \\<Longrightarrow>\n       is_pos (Ls_at (Suc i) ! j) = is_pos (Ls_at i ! j)", "using Ls_\\<sigma> len_Ls"], ["proof (prove)\nusing this:\n  map (\\<lambda>L. L \\<cdot>l \\<sigma>_at ?i1) (Ls_at (Suc ?i1)) = Ls_at ?i1\n  length (Ls_at ?i) = n\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       j < n \\<Longrightarrow>\n       is_pos (Ls_at (Suc i) ! j) = is_pos (Ls_at i ! j)", "by (metis literal.map_disc_iff nth_map subst_lit_def)"], ["proof (state)\nthis:\n  ?j < n \\<Longrightarrow>\n  is_pos (Ls_at (Suc ?i) ! ?j) = is_pos (Ls_at ?i ! ?j)\n\ngoal (1 subgoal):\n 1. wfP strictly_generalizes", "have Ls_\\<tau>_strict_lit: \"\\<And>i \\<tau>. map (\\<lambda>L. L \\<cdot>l \\<tau>) (Ls_at i) \\<noteq> Ls_at (Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i \\<tau>.\n       map (\\<lambda>L. L \\<cdot>l \\<tau>) (Ls_at i) \\<noteq> Ls_at (Suc i)", "by (metis C_\\<sigma> mset_Ls Ls_\\<sigma> mset_map sg_C generalizes_def strictly_generalizes_def\n          subst_cls_def)"], ["proof (state)\nthis:\n  map (\\<lambda>L. L \\<cdot>l ?\\<tau>) (Ls_at ?i) \\<noteq> Ls_at (Suc ?i)\n\ngoal (1 subgoal):\n 1. wfP strictly_generalizes", "have Ls_\\<tau>_strict_tm:\n      \"map ((\\<lambda>t. t \\<cdot>a \\<tau>) \\<circ> atm_of) (Ls_at i) \\<noteq> map atm_of (Ls_at (Suc i))\" for i \\<tau>"], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((\\<lambda>t. t \\<cdot>a \\<tau>) \\<circ> atm_of) (Ls_at i) \\<noteq>\n    map atm_of (Ls_at (Suc i))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map ((\\<lambda>t. t \\<cdot>a \\<tau>) \\<circ> atm_of) (Ls_at i) \\<noteq>\n    map atm_of (Ls_at (Suc i))", "obtain j :: nat where\n        j_lt: \"j < n\" and\n        j_\\<tau>: \"Ls_at i ! j \\<cdot>l \\<tau> \\<noteq> Ls_at (Suc i) ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>j < n;\n         Ls_at i ! j \\<cdot>l \\<tau> \\<noteq> Ls_at (Suc i) ! j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Ls_\\<tau>_strict_lit[of \\<tau> i] len_Ls"], ["proof (prove)\nusing this:\n  map (\\<lambda>L. L \\<cdot>l \\<tau>) (Ls_at i) \\<noteq> Ls_at (Suc i)\n  length (Ls_at ?i) = n\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>j < n;\n         Ls_at i ! j \\<cdot>l \\<tau> \\<noteq> Ls_at (Suc i) ! j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (no_types, lifting) length_map list_eq_iff_nth_eq nth_map)"], ["proof (state)\nthis:\n  j < n\n  Ls_at i ! j \\<cdot>l \\<tau> \\<noteq> Ls_at (Suc i) ! j\n\ngoal (1 subgoal):\n 1. map ((\\<lambda>t. t \\<cdot>a \\<tau>) \\<circ> atm_of) (Ls_at i) \\<noteq>\n    map atm_of (Ls_at (Suc i))", "have \"atm_of (Ls_at i ! j) \\<cdot>a \\<tau> \\<noteq> atm_of (Ls_at (Suc i) ! j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atm_of (Ls_at i ! j) \\<cdot>a \\<tau> \\<noteq> atm_of (Ls_at (Suc i) ! j)", "using j_\\<tau> is_pos_Ls[OF j_lt]"], ["proof (prove)\nusing this:\n  Ls_at i ! j \\<cdot>l \\<tau> \\<noteq> Ls_at (Suc i) ! j\n  is_pos (Ls_at (Suc ?i) ! j) = is_pos (Ls_at ?i ! j)\n\ngoal (1 subgoal):\n 1. atm_of (Ls_at i ! j) \\<cdot>a \\<tau> \\<noteq> atm_of (Ls_at (Suc i) ! j)", "by (metis (mono_guards) literal.expand literal.map_disc_iff literal.map_sel subst_lit_def)"], ["proof (state)\nthis:\n  atm_of (Ls_at i ! j) \\<cdot>a \\<tau> \\<noteq> atm_of (Ls_at (Suc i) ! j)\n\ngoal (1 subgoal):\n 1. map ((\\<lambda>t. t \\<cdot>a \\<tau>) \\<circ> atm_of) (Ls_at i) \\<noteq>\n    map atm_of (Ls_at (Suc i))", "then"], ["proof (chain)\npicking this:\n  atm_of (Ls_at i ! j) \\<cdot>a \\<tau> \\<noteq> atm_of (Ls_at (Suc i) ! j)", "show ?thesis"], ["proof (prove)\nusing this:\n  atm_of (Ls_at i ! j) \\<cdot>a \\<tau> \\<noteq> atm_of (Ls_at (Suc i) ! j)\n\ngoal (1 subgoal):\n 1. map ((\\<lambda>t. t \\<cdot>a \\<tau>) \\<circ> atm_of) (Ls_at i) \\<noteq>\n    map atm_of (Ls_at (Suc i))", "using j_lt len_Ls"], ["proof (prove)\nusing this:\n  atm_of (Ls_at i ! j) \\<cdot>a \\<tau> \\<noteq> atm_of (Ls_at (Suc i) ! j)\n  j < n\n  length (Ls_at ?i) = n\n\ngoal (1 subgoal):\n 1. map ((\\<lambda>t. t \\<cdot>a \\<tau>) \\<circ> atm_of) (Ls_at i) \\<noteq>\n    map atm_of (Ls_at (Suc i))", "by (metis nth_map o_apply)"], ["proof (state)\nthis:\n  map ((\\<lambda>t. t \\<cdot>a \\<tau>) \\<circ> atm_of) (Ls_at i) \\<noteq>\n  map atm_of (Ls_at (Suc i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map ((\\<lambda>t. t \\<cdot>a ?\\<tau>) \\<circ> atm_of) (Ls_at ?i) \\<noteq>\n  map atm_of (Ls_at (Suc ?i))\n\ngoal (1 subgoal):\n 1. wfP strictly_generalizes", "define tm_at :: \"nat \\<Rightarrow> 'a\" where\n      \"\\<And>i. tm_at i = atm_of_atms (map atm_of (Ls_at i))\""], ["proof (state)\nthis:\n  tm_at ?i = atm_of_atms (map atm_of (Ls_at ?i))\n\ngoal (1 subgoal):\n 1. wfP strictly_generalizes", "have \"\\<And>i. generalizes_atm (tm_at (Suc i)) (tm_at i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. generalizes_atm (tm_at (Suc i)) (tm_at i)", "unfolding tm_at_def generalizes_atm_def atm_of_atms_subst"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>\\<sigma>.\n          map (\\<lambda>A. A \\<cdot>a \\<sigma>)\n           (map atm_of (Ls_at (Suc i))) =\n          map atm_of (Ls_at i)", "using Ls_\\<sigma>[THEN arg_cong, of \"map atm_of\"]"], ["proof (prove)\nusing this:\n  map atm_of\n   (map (\\<lambda>L. L \\<cdot>l \\<sigma>_at ?i2) (Ls_at (Suc ?i2))) =\n  map atm_of (Ls_at ?i2)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>\\<sigma>.\n          map (\\<lambda>A. A \\<cdot>a \\<sigma>)\n           (map atm_of (Ls_at (Suc i))) =\n          map atm_of (Ls_at i)", "by (auto simp: comp_def)"], ["proof (state)\nthis:\n  generalizes_atm (tm_at (Suc ?i)) (tm_at ?i)\n\ngoal (1 subgoal):\n 1. wfP strictly_generalizes", "moreover"], ["proof (state)\nthis:\n  generalizes_atm (tm_at (Suc ?i)) (tm_at ?i)\n\ngoal (1 subgoal):\n 1. wfP strictly_generalizes", "have \"\\<And>i. \\<not> generalizes_atm (tm_at i) (tm_at (Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. \\<not> generalizes_atm (tm_at i) (tm_at (Suc i))", "unfolding tm_at_def generalizes_atm_def atm_of_atms_subst"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<nexists>\\<sigma>.\n          map (\\<lambda>A. A \\<cdot>a \\<sigma>) (map atm_of (Ls_at i)) =\n          map atm_of (Ls_at (Suc i))", "by (simp add: Ls_\\<tau>_strict_tm)"], ["proof (state)\nthis:\n  \\<not> generalizes_atm (tm_at ?i) (tm_at (Suc ?i))\n\ngoal (1 subgoal):\n 1. wfP strictly_generalizes", "ultimately"], ["proof (chain)\npicking this:\n  generalizes_atm (tm_at (Suc ?i)) (tm_at ?i)\n  \\<not> generalizes_atm (tm_at ?i) (tm_at (Suc ?i))", "have \"\\<And>i. strictly_generalizes_atm (tm_at (Suc i)) (tm_at i)\""], ["proof (prove)\nusing this:\n  generalizes_atm (tm_at (Suc ?i)) (tm_at ?i)\n  \\<not> generalizes_atm (tm_at ?i) (tm_at (Suc ?i))\n\ngoal (1 subgoal):\n 1. \\<And>i. strictly_generalizes_atm (tm_at (Suc i)) (tm_at i)", "unfolding strictly_generalizes_atm_def"], ["proof (prove)\nusing this:\n  generalizes_atm (tm_at (Suc ?i)) (tm_at ?i)\n  \\<not> generalizes_atm (tm_at ?i) (tm_at (Suc ?i))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       generalizes_atm (tm_at (Suc i)) (tm_at i) \\<and>\n       \\<not> generalizes_atm (tm_at i) (tm_at (Suc i))", "by blast"], ["proof (state)\nthis:\n  strictly_generalizes_atm (tm_at (Suc ?i)) (tm_at ?i)\n\ngoal (1 subgoal):\n 1. wfP strictly_generalizes", "then"], ["proof (chain)\npicking this:\n  strictly_generalizes_atm (tm_at (Suc ?i)) (tm_at ?i)", "have False"], ["proof (prove)\nusing this:\n  strictly_generalizes_atm (tm_at (Suc ?i)) (tm_at ?i)\n\ngoal (1 subgoal):\n 1. False", "using wf_strictly_generalizes_atm[unfolded wfP_def wf_iff_no_infinite_down_chain]"], ["proof (prove)\nusing this:\n  strictly_generalizes_atm (tm_at (Suc ?i)) (tm_at ?i)\n  \\<nexists>f.\n     \\<forall>i.\n        (f (Suc i), f i) \\<in> {(x, y). strictly_generalizes_atm x y}\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. wfP strictly_generalizes", "}"], ["proof (state)\nthis:\n  \\<exists>C_at.\n     \\<forall>i.\n        strictly_generalizes (C_at (Suc i)) (C_at i) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. wfP strictly_generalizes", "then"], ["proof (chain)\npicking this:\n  \\<exists>C_at.\n     \\<forall>i.\n        strictly_generalizes (C_at (Suc i)) (C_at i) \\<Longrightarrow>\n  False", "show \"wfP (strictly_generalizes :: 'a clause \\<Rightarrow> _ \\<Rightarrow> _)\""], ["proof (prove)\nusing this:\n  \\<exists>C_at.\n     \\<forall>i.\n        strictly_generalizes (C_at (Suc i)) (C_at i) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. wfP strictly_generalizes", "unfolding wfP_def"], ["proof (prove)\nusing this:\n  \\<exists>C_at.\n     \\<forall>i.\n        strictly_generalizes (C_at (Suc i)) (C_at i) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. wf {(x, y). strictly_generalizes x y}", "by (blast intro: wf_iff_no_infinite_down_chain[THEN iffD2])"], ["proof (state)\nthis:\n  wfP strictly_generalizes\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma strict_subset_subst_strictly_subsumes: \"C \\<cdot> \\<eta> \\<subset># D \\<Longrightarrow> strictly_subsumes C D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<cdot> \\<eta> \\<subset># D \\<Longrightarrow> strictly_subsumes C D", "by (metis leD mset_subset_size size_mset_mono size_subst strictly_subsumes_def\n      subset_mset.dual_order.strict_implies_order substitution_ops.subsumes_def)"], ["", "lemma generalizes_refl: \"generalizes C C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generalizes C C", "unfolding generalizes_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>. C \\<cdot> \\<sigma> = C", "by (rule exI[of _ id_subst]) auto"], ["", "lemma generalizes_trans: \"generalizes C D \\<Longrightarrow> generalizes D E \\<Longrightarrow> generalizes C E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>generalizes C D; generalizes D E\\<rbrakk>\n    \\<Longrightarrow> generalizes C E", "unfolding generalizes_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>\\<sigma>. C \\<cdot> \\<sigma> = D;\n     \\<exists>\\<sigma>. D \\<cdot> \\<sigma> = E\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<sigma>. C \\<cdot> \\<sigma> = E", "using subst_cls_comp_subst"], ["proof (prove)\nusing this:\n  ?C \\<cdot> (?\\<tau> \\<odot> ?\\<sigma>) =\n  ?C \\<cdot> ?\\<tau> \\<cdot> ?\\<sigma>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>\\<sigma>. C \\<cdot> \\<sigma> = D;\n     \\<exists>\\<sigma>. D \\<cdot> \\<sigma> = E\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<sigma>. C \\<cdot> \\<sigma> = E", "by blast"], ["", "lemma subsumes_refl: \"subsumes C C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subsumes C C", "unfolding subsumes_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>. C \\<cdot> \\<sigma> \\<subseteq># C", "by (rule exI[of _ id_subst]) auto"], ["", "lemma subsumes_trans: \"subsumes C D \\<Longrightarrow> subsumes D E \\<Longrightarrow> subsumes C E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>subsumes C D; subsumes D E\\<rbrakk>\n    \\<Longrightarrow> subsumes C E", "unfolding subsumes_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>\\<sigma>. C \\<cdot> \\<sigma> \\<subseteq># D;\n     \\<exists>\\<sigma>. D \\<cdot> \\<sigma> \\<subseteq># E\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<sigma>. C \\<cdot> \\<sigma> \\<subseteq># E", "by (metis (no_types) subset_mset.order.trans subst_cls_comp_subst subst_cls_mono_mset)"], ["", "lemma strictly_generalizes_irrefl: \"\\<not> strictly_generalizes C C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> strictly_generalizes C C", "unfolding strictly_generalizes_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (generalizes C C \\<and> \\<not> generalizes C C)", "by blast"], ["", "lemma strictly_generalizes_antisym: \"strictly_generalizes C D \\<Longrightarrow> \\<not> strictly_generalizes D C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strictly_generalizes C D \\<Longrightarrow>\n    \\<not> strictly_generalizes D C", "unfolding strictly_generalizes_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. generalizes C D \\<and> \\<not> generalizes D C \\<Longrightarrow>\n    \\<not> (generalizes D C \\<and> \\<not> generalizes C D)", "by blast"], ["", "lemma strictly_generalizes_trans:\n  \"strictly_generalizes C D \\<Longrightarrow> strictly_generalizes D E \\<Longrightarrow> strictly_generalizes C E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>strictly_generalizes C D; strictly_generalizes D E\\<rbrakk>\n    \\<Longrightarrow> strictly_generalizes C E", "unfolding strictly_generalizes_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>generalizes C D \\<and> \\<not> generalizes D C;\n     generalizes D E \\<and> \\<not> generalizes E D\\<rbrakk>\n    \\<Longrightarrow> generalizes C E \\<and> \\<not> generalizes E C", "using generalizes_trans"], ["proof (prove)\nusing this:\n  \\<lbrakk>generalizes ?C ?D; generalizes ?D ?E\\<rbrakk>\n  \\<Longrightarrow> generalizes ?C ?E\n\ngoal (1 subgoal):\n 1. \\<lbrakk>generalizes C D \\<and> \\<not> generalizes D C;\n     generalizes D E \\<and> \\<not> generalizes E D\\<rbrakk>\n    \\<Longrightarrow> generalizes C E \\<and> \\<not> generalizes E C", "by blast"], ["", "lemma strictly_subsumes_irrefl: \"\\<not> strictly_subsumes C C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> strictly_subsumes C C", "unfolding strictly_subsumes_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (subsumes C C \\<and> \\<not> subsumes C C)", "by blast"], ["", "lemma strictly_subsumes_antisym: \"strictly_subsumes C D \\<Longrightarrow> \\<not> strictly_subsumes D C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strictly_subsumes C D \\<Longrightarrow> \\<not> strictly_subsumes D C", "unfolding strictly_subsumes_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. subsumes C D \\<and> \\<not> subsumes D C \\<Longrightarrow>\n    \\<not> (subsumes D C \\<and> \\<not> subsumes C D)", "by blast"], ["", "lemma strictly_subsumes_trans:\n  \"strictly_subsumes C D \\<Longrightarrow> strictly_subsumes D E \\<Longrightarrow> strictly_subsumes C E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>strictly_subsumes C D; strictly_subsumes D E\\<rbrakk>\n    \\<Longrightarrow> strictly_subsumes C E", "unfolding strictly_subsumes_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>subsumes C D \\<and> \\<not> subsumes D C;\n     subsumes D E \\<and> \\<not> subsumes E D\\<rbrakk>\n    \\<Longrightarrow> subsumes C E \\<and> \\<not> subsumes E C", "using subsumes_trans"], ["proof (prove)\nusing this:\n  \\<lbrakk>subsumes ?C ?D; subsumes ?D ?E\\<rbrakk>\n  \\<Longrightarrow> subsumes ?C ?E\n\ngoal (1 subgoal):\n 1. \\<lbrakk>subsumes C D \\<and> \\<not> subsumes D C;\n     subsumes D E \\<and> \\<not> subsumes E D\\<rbrakk>\n    \\<Longrightarrow> subsumes C E \\<and> \\<not> subsumes E C", "by blast"], ["", "lemma subset_strictly_subsumes: \"C \\<subset># D \\<Longrightarrow> strictly_subsumes C D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<subset># D \\<Longrightarrow> strictly_subsumes C D", "using strict_subset_subst_strictly_subsumes[of C id_subst]"], ["proof (prove)\nusing this:\n  C \\<cdot> id_subst \\<subset># ?D \\<Longrightarrow> strictly_subsumes C ?D\n\ngoal (1 subgoal):\n 1. C \\<subset># D \\<Longrightarrow> strictly_subsumes C D", "by auto"], ["", "lemma strictly_generalizes_neq: \"strictly_generalizes D' D \\<Longrightarrow> D' \\<noteq> D \\<cdot> \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strictly_generalizes D' D \\<Longrightarrow>\n    D' \\<noteq> D \\<cdot> \\<sigma>", "unfolding strictly_generalizes_def generalizes_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>\\<sigma>. D' \\<cdot> \\<sigma> = D) \\<and>\n    (\\<nexists>\\<sigma>. D \\<cdot> \\<sigma> = D') \\<Longrightarrow>\n    D' \\<noteq> D \\<cdot> \\<sigma>", "by blast"], ["", "lemma strictly_subsumes_neq: \"strictly_subsumes D' D \\<Longrightarrow> D' \\<noteq> D \\<cdot> \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strictly_subsumes D' D \\<Longrightarrow> D' \\<noteq> D \\<cdot> \\<sigma>", "unfolding strictly_subsumes_def subsumes_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>\\<sigma>. D' \\<cdot> \\<sigma> \\<subseteq># D) \\<and>\n    (\\<nexists>\\<sigma>.\n        D \\<cdot> \\<sigma> \\<subseteq># D') \\<Longrightarrow>\n    D' \\<noteq> D \\<cdot> \\<sigma>", "by blast"], ["", "lemma strictly_subsumes_has_minimum:\n  assumes \"CC \\<noteq> {}\"\n  shows \"\\<exists>C \\<in> CC. \\<forall>D \\<in> CC. \\<not> strictly_subsumes D C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C\\<in>CC. \\<forall>D\\<in>CC. \\<not> strictly_subsumes D C", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>C\\<in>CC.\n               \\<forall>D\\<in>CC.\n                  \\<not> strictly_subsumes D C) \\<Longrightarrow>\n    False", "assume \"\\<not> (\\<exists>C \\<in> CC. \\<forall>D\\<in>CC. \\<not> strictly_subsumes D C)\""], ["proof (state)\nthis:\n  \\<not> (\\<exists>C\\<in>CC.\n             \\<forall>D\\<in>CC. \\<not> strictly_subsumes D C)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>C\\<in>CC.\n               \\<forall>D\\<in>CC.\n                  \\<not> strictly_subsumes D C) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>C\\<in>CC.\n             \\<forall>D\\<in>CC. \\<not> strictly_subsumes D C)", "have \"\\<forall>C \\<in> CC. \\<exists>D \\<in> CC. strictly_subsumes D C\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>C\\<in>CC.\n             \\<forall>D\\<in>CC. \\<not> strictly_subsumes D C)\n\ngoal (1 subgoal):\n 1. \\<forall>C\\<in>CC. \\<exists>D\\<in>CC. strictly_subsumes D C", "by blast"], ["proof (state)\nthis:\n  \\<forall>C\\<in>CC. \\<exists>D\\<in>CC. strictly_subsumes D C\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>C\\<in>CC.\n               \\<forall>D\\<in>CC.\n                  \\<not> strictly_subsumes D C) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<forall>C\\<in>CC. \\<exists>D\\<in>CC. strictly_subsumes D C", "obtain f where\n    f_p: \"\\<forall>C \\<in> CC. f C \\<in> CC \\<and> strictly_subsumes (f C) C\""], ["proof (prove)\nusing this:\n  \\<forall>C\\<in>CC. \\<exists>D\\<in>CC. strictly_subsumes D C\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<forall>C\\<in>CC.\n           f C \\<in> CC \\<and> strictly_subsumes (f C) C \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  \\<forall>C\\<in>CC. f C \\<in> CC \\<and> strictly_subsumes (f C) C\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>C\\<in>CC.\n               \\<forall>D\\<in>CC.\n                  \\<not> strictly_subsumes D C) \\<Longrightarrow>\n    False", "from assms"], ["proof (chain)\npicking this:\n  CC \\<noteq> {}", "obtain C where\n    C_p: \"C \\<in> CC\""], ["proof (prove)\nusing this:\n  CC \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>C. C \\<in> CC \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  C \\<in> CC\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>C\\<in>CC.\n               \\<forall>D\\<in>CC.\n                  \\<not> strictly_subsumes D C) \\<Longrightarrow>\n    False", "define c :: \"nat \\<Rightarrow> 'a clause\" where\n    \"\\<And>n. c n = (f ^^ n) C\""], ["proof (state)\nthis:\n  c ?n = (f ^^ ?n) C\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>C\\<in>CC.\n               \\<forall>D\\<in>CC.\n                  \\<not> strictly_subsumes D C) \\<Longrightarrow>\n    False", "have incc: \"c i \\<in> CC\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. c i \\<in> CC", "by (induction i) (auto simp: c_def f_p C_p)"], ["proof (state)\nthis:\n  c ?i \\<in> CC\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>C\\<in>CC.\n               \\<forall>D\\<in>CC.\n                  \\<not> strictly_subsumes D C) \\<Longrightarrow>\n    False", "have ps: \"\\<forall>i. strictly_subsumes (c (Suc i)) (c i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. strictly_subsumes (c (Suc i)) (c i)", "using incc f_p"], ["proof (prove)\nusing this:\n  c ?i \\<in> CC\n  \\<forall>C\\<in>CC. f C \\<in> CC \\<and> strictly_subsumes (f C) C\n\ngoal (1 subgoal):\n 1. \\<forall>i. strictly_subsumes (c (Suc i)) (c i)", "unfolding c_def"], ["proof (prove)\nusing this:\n  (f ^^ ?i) C \\<in> CC\n  \\<forall>C\\<in>CC. f C \\<in> CC \\<and> strictly_subsumes (f C) C\n\ngoal (1 subgoal):\n 1. \\<forall>i. strictly_subsumes ((f ^^ Suc i) C) ((f ^^ i) C)", "by auto"], ["proof (state)\nthis:\n  \\<forall>i. strictly_subsumes (c (Suc i)) (c i)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>C\\<in>CC.\n               \\<forall>D\\<in>CC.\n                  \\<not> strictly_subsumes D C) \\<Longrightarrow>\n    False", "have \"\\<forall>i. size (c i) \\<ge> size (c (Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. size (c (Suc i)) \\<le> size (c i)", "using ps"], ["proof (prove)\nusing this:\n  \\<forall>i. strictly_subsumes (c (Suc i)) (c i)\n\ngoal (1 subgoal):\n 1. \\<forall>i. size (c (Suc i)) \\<le> size (c i)", "unfolding strictly_subsumes_def subsumes_def"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     (\\<exists>\\<sigma>. c (Suc i) \\<cdot> \\<sigma> \\<subseteq># c i) \\<and>\n     (\\<nexists>\\<sigma>. c i \\<cdot> \\<sigma> \\<subseteq># c (Suc i))\n\ngoal (1 subgoal):\n 1. \\<forall>i. size (c (Suc i)) \\<le> size (c i)", "by (metis size_mset_mono size_subst)"], ["proof (state)\nthis:\n  \\<forall>i. size (c (Suc i)) \\<le> size (c i)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>C\\<in>CC.\n               \\<forall>D\\<in>CC.\n                  \\<not> strictly_subsumes D C) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<forall>i. size (c (Suc i)) \\<le> size (c i)", "have lte: \"\\<forall>i. (size \\<circ> c) i \\<ge> (size \\<circ> c) (Suc i)\""], ["proof (prove)\nusing this:\n  \\<forall>i. size (c (Suc i)) \\<le> size (c i)\n\ngoal (1 subgoal):\n 1. \\<forall>i. (size \\<circ> c) (Suc i) \\<le> (size \\<circ> c) i", "unfolding comp_def"], ["proof (prove)\nusing this:\n  \\<forall>i. size (c (Suc i)) \\<le> size (c i)\n\ngoal (1 subgoal):\n 1. \\<forall>i. size (c (Suc i)) \\<le> size (c i)", "."], ["proof (state)\nthis:\n  \\<forall>i. (size \\<circ> c) (Suc i) \\<le> (size \\<circ> c) i\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>C\\<in>CC.\n               \\<forall>D\\<in>CC.\n                  \\<not> strictly_subsumes D C) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<forall>i. (size \\<circ> c) (Suc i) \\<le> (size \\<circ> c) i", "have \"\\<exists>l. \\<forall>l' \\<ge> l. size (c l') = size (c (Suc l'))\""], ["proof (prove)\nusing this:\n  \\<forall>i. (size \\<circ> c) (Suc i) \\<le> (size \\<circ> c) i\n\ngoal (1 subgoal):\n 1. \\<exists>l. \\<forall>l'\\<ge>l. size (c l') = size (c (Suc l'))", "using f_Suc_decr_eventually_const comp_def"], ["proof (prove)\nusing this:\n  \\<forall>i. (size \\<circ> c) (Suc i) \\<le> (size \\<circ> c) i\n  \\<forall>i. ?f (Suc i) \\<le> ?f i \\<Longrightarrow>\n  \\<exists>l. \\<forall>l'\\<ge>l. ?f l' = ?f (Suc l')\n  ?f \\<circ> ?g = (\\<lambda>x. ?f (?g x))\n\ngoal (1 subgoal):\n 1. \\<exists>l. \\<forall>l'\\<ge>l. size (c l') = size (c (Suc l'))", "by auto"], ["proof (state)\nthis:\n  \\<exists>l. \\<forall>l'\\<ge>l. size (c l') = size (c (Suc l'))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>C\\<in>CC.\n               \\<forall>D\\<in>CC.\n                  \\<not> strictly_subsumes D C) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>l. \\<forall>l'\\<ge>l. size (c l') = size (c (Suc l'))", "obtain l where\n    l_p: \"\\<forall>l' \\<ge> l. size (c l') = size (c (Suc l'))\""], ["proof (prove)\nusing this:\n  \\<exists>l. \\<forall>l'\\<ge>l. size (c l') = size (c (Suc l'))\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<forall>l'\\<ge>l. size (c l') = size (c (Suc l')) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  \\<forall>l'\\<ge>l. size (c l') = size (c (Suc l'))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>C\\<in>CC.\n               \\<forall>D\\<in>CC.\n                  \\<not> strictly_subsumes D C) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<forall>l'\\<ge>l. size (c l') = size (c (Suc l'))", "have \"\\<forall>l' \\<ge> l. strictly_generalizes (c (Suc l')) (c l')\""], ["proof (prove)\nusing this:\n  \\<forall>l'\\<ge>l. size (c l') = size (c (Suc l'))\n\ngoal (1 subgoal):\n 1. \\<forall>l'\\<ge>l. strictly_generalizes (c (Suc l')) (c l')", "using ps"], ["proof (prove)\nusing this:\n  \\<forall>l'\\<ge>l. size (c l') = size (c (Suc l'))\n  \\<forall>i. strictly_subsumes (c (Suc i)) (c i)\n\ngoal (1 subgoal):\n 1. \\<forall>l'\\<ge>l. strictly_generalizes (c (Suc l')) (c l')", "unfolding strictly_generalizes_def generalizes_def"], ["proof (prove)\nusing this:\n  \\<forall>l'\\<ge>l. size (c l') = size (c (Suc l'))\n  \\<forall>i. strictly_subsumes (c (Suc i)) (c i)\n\ngoal (1 subgoal):\n 1. \\<forall>l'\\<ge>l.\n       (\\<exists>\\<sigma>. c (Suc l') \\<cdot> \\<sigma> = c l') \\<and>\n       (\\<nexists>\\<sigma>. c l' \\<cdot> \\<sigma> = c (Suc l'))", "by (metis size_subst less_irrefl strictly_subsumes_def mset_subset_size subset_mset_def\n        subsumes_def strictly_subsumes_neq)"], ["proof (state)\nthis:\n  \\<forall>l'\\<ge>l. strictly_generalizes (c (Suc l')) (c l')\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>C\\<in>CC.\n               \\<forall>D\\<in>CC.\n                  \\<not> strictly_subsumes D C) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<forall>l'\\<ge>l. strictly_generalizes (c (Suc l')) (c l')", "have \"\\<forall>i. strictly_generalizes (c (Suc i + l)) (c (i + l))\""], ["proof (prove)\nusing this:\n  \\<forall>l'\\<ge>l. strictly_generalizes (c (Suc l')) (c l')\n\ngoal (1 subgoal):\n 1. \\<forall>i. strictly_generalizes (c (Suc i + l)) (c (i + l))", "unfolding strictly_generalizes_def generalizes_def"], ["proof (prove)\nusing this:\n  \\<forall>l'\\<ge>l.\n     (\\<exists>\\<sigma>. c (Suc l') \\<cdot> \\<sigma> = c l') \\<and>\n     (\\<nexists>\\<sigma>. c l' \\<cdot> \\<sigma> = c (Suc l'))\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       (\\<exists>\\<sigma>.\n           c (Suc i + l) \\<cdot> \\<sigma> = c (i + l)) \\<and>\n       (\\<nexists>\\<sigma>. c (i + l) \\<cdot> \\<sigma> = c (Suc i + l))", "by auto"], ["proof (state)\nthis:\n  \\<forall>i. strictly_generalizes (c (Suc i + l)) (c (i + l))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>C\\<in>CC.\n               \\<forall>D\\<in>CC.\n                  \\<not> strictly_subsumes D C) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<forall>i. strictly_generalizes (c (Suc i + l)) (c (i + l))", "have \"\\<exists>f. \\<forall>i. strictly_generalizes (f (Suc i)) (f i)\""], ["proof (prove)\nusing this:\n  \\<forall>i. strictly_generalizes (c (Suc i + l)) (c (i + l))\n\ngoal (1 subgoal):\n 1. \\<exists>f. \\<forall>i. strictly_generalizes (f (Suc i)) (f i)", "by (rule exI[of _ \"\\<lambda>x. c (x + l)\"])"], ["proof (state)\nthis:\n  \\<exists>f. \\<forall>i. strictly_generalizes (f (Suc i)) (f i)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>C\\<in>CC.\n               \\<forall>D\\<in>CC.\n                  \\<not> strictly_subsumes D C) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>f. \\<forall>i. strictly_generalizes (f (Suc i)) (f i)", "show False"], ["proof (prove)\nusing this:\n  \\<exists>f. \\<forall>i. strictly_generalizes (f (Suc i)) (f i)\n\ngoal (1 subgoal):\n 1. False", "using wf_strictly_generalizes\n      wf_iff_no_infinite_down_chain[of \"{(x, y). strictly_generalizes x y}\"]"], ["proof (prove)\nusing this:\n  \\<exists>f. \\<forall>i. strictly_generalizes (f (Suc i)) (f i)\n  wfP strictly_generalizes\n  wf {(x, y). strictly_generalizes x y} =\n  (\\<nexists>f.\n      \\<forall>i. (f (Suc i), f i) \\<in> {(x, y). strictly_generalizes x y})\n\ngoal (1 subgoal):\n 1. False", "unfolding wfP_def"], ["proof (prove)\nusing this:\n  \\<exists>f. \\<forall>i. strictly_generalizes (f (Suc i)) (f i)\n  wf {(x, y). strictly_generalizes x y}\n  wf {(x, y). strictly_generalizes x y} =\n  (\\<nexists>f.\n      \\<forall>i. (f (Suc i), f i) \\<in> {(x, y). strictly_generalizes x y})\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wf_strictly_subsumes: \"wfP strictly_subsumes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfP strictly_subsumes", "using strictly_subsumes_has_minimum"], ["proof (prove)\nusing this:\n  ?CC \\<noteq> {} \\<Longrightarrow>\n  \\<exists>C\\<in>?CC. \\<forall>D\\<in>?CC. \\<not> strictly_subsumes D C\n\ngoal (1 subgoal):\n 1. wfP strictly_subsumes", "by (metis equals0D wfP_eq_minimal)"], ["", "lemma variants_imp_exists_substitution: \"variants D D' \\<Longrightarrow> \\<exists>\\<sigma>. D \\<cdot> \\<sigma> = D'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. variants D D' \\<Longrightarrow>\n    \\<exists>\\<sigma>. D \\<cdot> \\<sigma> = D'", "unfolding variants_iff_subsumes subsumes_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>\\<sigma>. D \\<cdot> \\<sigma> \\<subseteq># D') \\<and>\n    (\\<exists>\\<sigma>.\n        D' \\<cdot> \\<sigma> \\<subseteq># D) \\<Longrightarrow>\n    \\<exists>\\<sigma>. D \\<cdot> \\<sigma> = D'", "by (meson strictly_subsumes_def subset_mset_def strict_subset_subst_strictly_subsumes subsumes_def)"], ["", "lemma strictly_subsumes_variants:\n  assumes \"strictly_subsumes E D\" and \"variants D D'\"\n  shows \"strictly_subsumes E D'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strictly_subsumes E D'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. strictly_subsumes E D'", "from assms"], ["proof (chain)\npicking this:\n  strictly_subsumes E D\n  variants D D'", "obtain \\<sigma> \\<sigma>' where\n    \\<sigma>_\\<sigma>'_p: \"D \\<cdot> \\<sigma> = D' \\<and> D' \\<cdot> \\<sigma>' = D\""], ["proof (prove)\nusing this:\n  strictly_subsumes E D\n  variants D D'\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma> \\<sigma>'.\n        D \\<cdot> \\<sigma> = D' \\<and>\n        D' \\<cdot> \\<sigma>' = D \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using variants_imp_exists_substitution variants_sym"], ["proof (prove)\nusing this:\n  strictly_subsumes E D\n  variants D D'\n  variants ?D ?D' \\<Longrightarrow>\n  \\<exists>\\<sigma>. ?D \\<cdot> \\<sigma> = ?D'\n  variants ?D ?D' = variants ?D' ?D\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma> \\<sigma>'.\n        D \\<cdot> \\<sigma> = D' \\<and>\n        D' \\<cdot> \\<sigma>' = D \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  D \\<cdot> \\<sigma> = D' \\<and> D' \\<cdot> \\<sigma>' = D\n\ngoal (1 subgoal):\n 1. strictly_subsumes E D'", "from assms"], ["proof (chain)\npicking this:\n  strictly_subsumes E D\n  variants D D'", "obtain \\<sigma>'' where\n    \"E \\<cdot> \\<sigma>'' \\<subseteq># D\""], ["proof (prove)\nusing this:\n  strictly_subsumes E D\n  variants D D'\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>''.\n        E \\<cdot> \\<sigma>'' \\<subseteq># D \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding strictly_subsumes_def subsumes_def"], ["proof (prove)\nusing this:\n  (\\<exists>\\<sigma>. E \\<cdot> \\<sigma> \\<subseteq># D) \\<and>\n  (\\<nexists>\\<sigma>. D \\<cdot> \\<sigma> \\<subseteq># E)\n  variants D D'\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>''.\n        E \\<cdot> \\<sigma>'' \\<subseteq># D \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  E \\<cdot> \\<sigma>'' \\<subseteq># D\n\ngoal (1 subgoal):\n 1. strictly_subsumes E D'", "then"], ["proof (chain)\npicking this:\n  E \\<cdot> \\<sigma>'' \\<subseteq># D", "have \"E \\<cdot> \\<sigma>'' \\<cdot> \\<sigma> \\<subseteq># D \\<cdot> \\<sigma>\""], ["proof (prove)\nusing this:\n  E \\<cdot> \\<sigma>'' \\<subseteq># D\n\ngoal (1 subgoal):\n 1. E \\<cdot> \\<sigma>'' \\<cdot> \\<sigma> \\<subseteq># D \\<cdot> \\<sigma>", "using subst_cls_mono_mset"], ["proof (prove)\nusing this:\n  E \\<cdot> \\<sigma>'' \\<subseteq># D\n  ?C \\<subseteq># ?D \\<Longrightarrow>\n  ?C \\<cdot> ?\\<sigma> \\<subseteq># ?D \\<cdot> ?\\<sigma>\n\ngoal (1 subgoal):\n 1. E \\<cdot> \\<sigma>'' \\<cdot> \\<sigma> \\<subseteq># D \\<cdot> \\<sigma>", "by blast"], ["proof (state)\nthis:\n  E \\<cdot> \\<sigma>'' \\<cdot> \\<sigma> \\<subseteq># D \\<cdot> \\<sigma>\n\ngoal (1 subgoal):\n 1. strictly_subsumes E D'", "then"], ["proof (chain)\npicking this:\n  E \\<cdot> \\<sigma>'' \\<cdot> \\<sigma> \\<subseteq># D \\<cdot> \\<sigma>", "have \"E \\<cdot> (\\<sigma>'' \\<odot> \\<sigma>) \\<subseteq># D'\""], ["proof (prove)\nusing this:\n  E \\<cdot> \\<sigma>'' \\<cdot> \\<sigma> \\<subseteq># D \\<cdot> \\<sigma>\n\ngoal (1 subgoal):\n 1. E \\<cdot> (\\<sigma>'' \\<odot> \\<sigma>) \\<subseteq># D'", "using \\<sigma>_\\<sigma>'_p"], ["proof (prove)\nusing this:\n  E \\<cdot> \\<sigma>'' \\<cdot> \\<sigma> \\<subseteq># D \\<cdot> \\<sigma>\n  D \\<cdot> \\<sigma> = D' \\<and> D' \\<cdot> \\<sigma>' = D\n\ngoal (1 subgoal):\n 1. E \\<cdot> (\\<sigma>'' \\<odot> \\<sigma>) \\<subseteq># D'", "by auto"], ["proof (state)\nthis:\n  E \\<cdot> (\\<sigma>'' \\<odot> \\<sigma>) \\<subseteq># D'\n\ngoal (1 subgoal):\n 1. strictly_subsumes E D'", "moreover"], ["proof (state)\nthis:\n  E \\<cdot> (\\<sigma>'' \\<odot> \\<sigma>) \\<subseteq># D'\n\ngoal (1 subgoal):\n 1. strictly_subsumes E D'", "from assms"], ["proof (chain)\npicking this:\n  strictly_subsumes E D\n  variants D D'", "have n: \"\\<nexists>\\<sigma>. D \\<cdot> \\<sigma> \\<subseteq># E\""], ["proof (prove)\nusing this:\n  strictly_subsumes E D\n  variants D D'\n\ngoal (1 subgoal):\n 1. \\<nexists>\\<sigma>. D \\<cdot> \\<sigma> \\<subseteq># E", "unfolding strictly_subsumes_def subsumes_def"], ["proof (prove)\nusing this:\n  (\\<exists>\\<sigma>. E \\<cdot> \\<sigma> \\<subseteq># D) \\<and>\n  (\\<nexists>\\<sigma>. D \\<cdot> \\<sigma> \\<subseteq># E)\n  variants D D'\n\ngoal (1 subgoal):\n 1. \\<nexists>\\<sigma>. D \\<cdot> \\<sigma> \\<subseteq># E", "by auto"], ["proof (state)\nthis:\n  \\<nexists>\\<sigma>. D \\<cdot> \\<sigma> \\<subseteq># E\n\ngoal (1 subgoal):\n 1. strictly_subsumes E D'", "have \"\\<nexists>\\<sigma>. D' \\<cdot> \\<sigma> \\<subseteq># E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>\\<sigma>. D' \\<cdot> \\<sigma> \\<subseteq># E", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>. D' \\<cdot> \\<sigma> \\<subseteq># E \\<Longrightarrow>\n    False", "assume \"\\<exists>\\<sigma>'''. D' \\<cdot> \\<sigma>''' \\<subseteq># E\""], ["proof (state)\nthis:\n  \\<exists>\\<sigma>'''. D' \\<cdot> \\<sigma>''' \\<subseteq># E\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>. D' \\<cdot> \\<sigma> \\<subseteq># E \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>\\<sigma>'''. D' \\<cdot> \\<sigma>''' \\<subseteq># E", "obtain \\<sigma>''' where\n      \"D' \\<cdot> \\<sigma>''' \\<subseteq># E\""], ["proof (prove)\nusing this:\n  \\<exists>\\<sigma>'''. D' \\<cdot> \\<sigma>''' \\<subseteq># E\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>'''.\n        D' \\<cdot> \\<sigma>''' \\<subseteq># E \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  D' \\<cdot> \\<sigma>''' \\<subseteq># E\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>. D' \\<cdot> \\<sigma> \\<subseteq># E \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  D' \\<cdot> \\<sigma>''' \\<subseteq># E", "have \"D \\<cdot> (\\<sigma> \\<odot> \\<sigma>''') \\<subseteq># E\""], ["proof (prove)\nusing this:\n  D' \\<cdot> \\<sigma>''' \\<subseteq># E\n\ngoal (1 subgoal):\n 1. D \\<cdot> (\\<sigma> \\<odot> \\<sigma>''') \\<subseteq># E", "using \\<sigma>_\\<sigma>'_p"], ["proof (prove)\nusing this:\n  D' \\<cdot> \\<sigma>''' \\<subseteq># E\n  D \\<cdot> \\<sigma> = D' \\<and> D' \\<cdot> \\<sigma>' = D\n\ngoal (1 subgoal):\n 1. D \\<cdot> (\\<sigma> \\<odot> \\<sigma>''') \\<subseteq># E", "by auto"], ["proof (state)\nthis:\n  D \\<cdot> (\\<sigma> \\<odot> \\<sigma>''') \\<subseteq># E\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>. D' \\<cdot> \\<sigma> \\<subseteq># E \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  D \\<cdot> (\\<sigma> \\<odot> \\<sigma>''') \\<subseteq># E", "show False"], ["proof (prove)\nusing this:\n  D \\<cdot> (\\<sigma> \\<odot> \\<sigma>''') \\<subseteq># E\n\ngoal (1 subgoal):\n 1. False", "using n"], ["proof (prove)\nusing this:\n  D \\<cdot> (\\<sigma> \\<odot> \\<sigma>''') \\<subseteq># E\n  \\<nexists>\\<sigma>. D \\<cdot> \\<sigma> \\<subseteq># E\n\ngoal (1 subgoal):\n 1. False", "by metis"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<nexists>\\<sigma>. D' \\<cdot> \\<sigma> \\<subseteq># E\n\ngoal (1 subgoal):\n 1. strictly_subsumes E D'", "ultimately"], ["proof (chain)\npicking this:\n  E \\<cdot> (\\<sigma>'' \\<odot> \\<sigma>) \\<subseteq># D'\n  \\<nexists>\\<sigma>. D' \\<cdot> \\<sigma> \\<subseteq># E", "show ?thesis"], ["proof (prove)\nusing this:\n  E \\<cdot> (\\<sigma>'' \\<odot> \\<sigma>) \\<subseteq># D'\n  \\<nexists>\\<sigma>. D' \\<cdot> \\<sigma> \\<subseteq># E\n\ngoal (1 subgoal):\n 1. strictly_subsumes E D'", "unfolding strictly_subsumes_def subsumes_def"], ["proof (prove)\nusing this:\n  E \\<cdot> (\\<sigma>'' \\<odot> \\<sigma>) \\<subseteq># D'\n  \\<nexists>\\<sigma>. D' \\<cdot> \\<sigma> \\<subseteq># E\n\ngoal (1 subgoal):\n 1. (\\<exists>\\<sigma>. E \\<cdot> \\<sigma> \\<subseteq># D') \\<and>\n    (\\<nexists>\\<sigma>. D' \\<cdot> \\<sigma> \\<subseteq># E)", "by metis"], ["proof (state)\nthis:\n  strictly_subsumes E D'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma neg_strictly_subsumes_variants:\n  assumes \"\\<not> strictly_subsumes E D\" and \"variants D D'\"\n  shows \"\\<not> strictly_subsumes E D'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> strictly_subsumes E D'", "using assms strictly_subsumes_variants variants_sym"], ["proof (prove)\nusing this:\n  \\<not> strictly_subsumes E D\n  variants D D'\n  \\<lbrakk>strictly_subsumes ?E ?D; variants ?D ?D'\\<rbrakk>\n  \\<Longrightarrow> strictly_subsumes ?E ?D'\n  variants ?D ?D' = variants ?D' ?D\n\ngoal (1 subgoal):\n 1. \\<not> strictly_subsumes E D'", "by auto"], ["", "end"], ["", "subsection \\<open>Most General Unifiers\\<close>"], ["", "locale mgu = substitution subst_atm id_subst comp_subst renamings_apart atm_of_atms\n  for\n    subst_atm :: \"'a \\<Rightarrow> 's \\<Rightarrow> 'a\" and\n    id_subst :: 's and\n    comp_subst :: \"'s \\<Rightarrow> 's \\<Rightarrow> 's\" and\n    atm_of_atms :: \"'a list \\<Rightarrow> 'a\" and\n    renamings_apart :: \"'a literal multiset list \\<Rightarrow> 's list\" +\n  fixes\n    mgu :: \"'a set set \\<Rightarrow> 's option\"\n  assumes\n    mgu_sound: \"finite AAA \\<Longrightarrow> (\\<forall>AA \\<in> AAA. finite AA) \\<Longrightarrow> mgu AAA = Some \\<sigma> \\<Longrightarrow> is_mgu \\<sigma> AAA\" and\n    mgu_complete:\n      \"finite AAA \\<Longrightarrow> (\\<forall>AA \\<in> AAA. finite AA) \\<Longrightarrow> is_unifiers \\<sigma> AAA \\<Longrightarrow> \\<exists>\\<tau>. mgu AAA = Some \\<tau>\"\nbegin"], ["", "lemmas is_unifiers_mgu = mgu_sound[unfolded is_mgu_def, THEN conjunct1]"], ["", "lemmas is_mgu_most_general = mgu_sound[unfolded is_mgu_def, THEN conjunct2]"], ["", "lemma mgu_unifier:\n  assumes\n    aslen: \"length As = n\" and\n    aaslen: \"length AAs = n\" and\n    mgu: \"Some \\<sigma> = mgu (set_mset ` set (map2 add_mset As AAs))\" and\n    i_lt: \"i < n\" and\n    a_in: \"A \\<in># AAs ! i\"\n  shows \"A \\<cdot>a \\<sigma> = As ! i \\<cdot>a \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<cdot>a \\<sigma> = As ! i \\<cdot>a \\<sigma>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<cdot>a \\<sigma> = As ! i \\<cdot>a \\<sigma>", "from mgu"], ["proof (chain)\npicking this:\n  Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs))", "have \"is_mgu \\<sigma> (set_mset ` set (map2 add_mset As AAs))\""], ["proof (prove)\nusing this:\n  Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs))\n\ngoal (1 subgoal):\n 1. is_mgu \\<sigma> (set_mset ` set (Map2.map2 add_mset As AAs))", "using mgu_sound"], ["proof (prove)\nusing this:\n  Some \\<sigma> = mgu (set_mset ` set (Map2.map2 add_mset As AAs))\n  \\<lbrakk>finite ?AAA; \\<forall>AA\\<in>?AAA. finite AA;\n   mgu ?AAA = Some ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> is_mgu ?\\<sigma> ?AAA\n\ngoal (1 subgoal):\n 1. is_mgu \\<sigma> (set_mset ` set (Map2.map2 add_mset As AAs))", "by auto"], ["proof (state)\nthis:\n  is_mgu \\<sigma> (set_mset ` set (Map2.map2 add_mset As AAs))\n\ngoal (1 subgoal):\n 1. A \\<cdot>a \\<sigma> = As ! i \\<cdot>a \\<sigma>", "then"], ["proof (chain)\npicking this:\n  is_mgu \\<sigma> (set_mset ` set (Map2.map2 add_mset As AAs))", "have \"is_unifiers \\<sigma> (set_mset ` set (map2 add_mset As AAs))\""], ["proof (prove)\nusing this:\n  is_mgu \\<sigma> (set_mset ` set (Map2.map2 add_mset As AAs))\n\ngoal (1 subgoal):\n 1. is_unifiers \\<sigma> (set_mset ` set (Map2.map2 add_mset As AAs))", "using is_mgu_is_unifiers"], ["proof (prove)\nusing this:\n  is_mgu \\<sigma> (set_mset ` set (Map2.map2 add_mset As AAs))\n  is_mgu ?\\<sigma> ?AAA \\<Longrightarrow> is_unifiers ?\\<sigma> ?AAA\n\ngoal (1 subgoal):\n 1. is_unifiers \\<sigma> (set_mset ` set (Map2.map2 add_mset As AAs))", "by auto"], ["proof (state)\nthis:\n  is_unifiers \\<sigma> (set_mset ` set (Map2.map2 add_mset As AAs))\n\ngoal (1 subgoal):\n 1. A \\<cdot>a \\<sigma> = As ! i \\<cdot>a \\<sigma>", "then"], ["proof (chain)\npicking this:\n  is_unifiers \\<sigma> (set_mset ` set (Map2.map2 add_mset As AAs))", "have \"is_unifier \\<sigma> (set_mset (add_mset (As ! i) (AAs ! i)))\""], ["proof (prove)\nusing this:\n  is_unifiers \\<sigma> (set_mset ` set (Map2.map2 add_mset As AAs))\n\ngoal (1 subgoal):\n 1. is_unifier \\<sigma> (set_mset (add_mset (As ! i) (AAs ! i)))", "using i_lt aslen aaslen"], ["proof (prove)\nusing this:\n  is_unifiers \\<sigma> (set_mset ` set (Map2.map2 add_mset As AAs))\n  i < n\n  length As = n\n  length AAs = n\n\ngoal (1 subgoal):\n 1. is_unifier \\<sigma> (set_mset (add_mset (As ! i) (AAs ! i)))", "unfolding is_unifiers_def is_unifier_def"], ["proof (prove)\nusing this:\n  \\<forall>AA\\<in>set_mset ` set (Map2.map2 add_mset As AAs).\n     card (AA \\<cdot>as \\<sigma>) \\<le> 1\n  i < n\n  length As = n\n  length AAs = n\n\ngoal (1 subgoal):\n 1. card (set_mset (add_mset (As ! i) (AAs ! i)) \\<cdot>as \\<sigma>) \\<le> 1", "by simp (metis length_zip min.idem nth_mem nth_zip prod.case set_mset_add_mset_insert)"], ["proof (state)\nthis:\n  is_unifier \\<sigma> (set_mset (add_mset (As ! i) (AAs ! i)))\n\ngoal (1 subgoal):\n 1. A \\<cdot>a \\<sigma> = As ! i \\<cdot>a \\<sigma>", "then"], ["proof (chain)\npicking this:\n  is_unifier \\<sigma> (set_mset (add_mset (As ! i) (AAs ! i)))", "show ?thesis"], ["proof (prove)\nusing this:\n  is_unifier \\<sigma> (set_mset (add_mset (As ! i) (AAs ! i)))\n\ngoal (1 subgoal):\n 1. A \\<cdot>a \\<sigma> = As ! i \\<cdot>a \\<sigma>", "using aslen aaslen a_in is_unifier_subst_atm_eqI"], ["proof (prove)\nusing this:\n  is_unifier \\<sigma> (set_mset (add_mset (As ! i) (AAs ! i)))\n  length As = n\n  length AAs = n\n  A \\<in># AAs ! i\n  \\<lbrakk>finite ?AA; is_unifier ?\\<sigma> ?AA; ?A \\<in> ?AA;\n   ?B \\<in> ?AA\\<rbrakk>\n  \\<Longrightarrow> ?A \\<cdot>a ?\\<sigma> = ?B \\<cdot>a ?\\<sigma>\n\ngoal (1 subgoal):\n 1. A \\<cdot>a \\<sigma> = As ! i \\<cdot>a \\<sigma>", "by (metis finite_set_mset insertCI set_mset_add_mset_insert)"], ["proof (state)\nthis:\n  A \\<cdot>a \\<sigma> = As ! i \\<cdot>a \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}