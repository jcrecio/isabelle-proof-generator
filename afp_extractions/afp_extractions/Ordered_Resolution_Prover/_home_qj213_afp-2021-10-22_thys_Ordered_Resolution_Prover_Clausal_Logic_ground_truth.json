{"file_name": "/home/qj213/afp-2021-10-22/thys/Ordered_Resolution_Prover/Clausal_Logic.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Ordered_Resolution_Prover", "problem_names": ["lemma Pos_atm_of_iff[simp]: \"Pos (atm_of L) = L \\<longleftrightarrow> is_pos L\"", "lemma Neg_atm_of_iff[simp]: \"Neg (atm_of L) = L \\<longleftrightarrow> is_neg L\"", "lemma set_literal_atm_of: \"set_literal L = {atm_of L}\"", "lemma ex_lit_cases: \"(\\<exists>L. P L) \\<longleftrightarrow> (\\<exists>A. P (Pos A) \\<or> P (Neg A))\"", "lemma\n  uminus_Pos[simp]: \"- Pos A = Neg A\" and\n  uminus_Neg[simp]: \"- Neg A = Pos A\"", "lemma atm_of_uminus[simp]: \"atm_of (-L) = atm_of L\"", "lemma uminus_of_uminus_id[simp]: \"- (- (x :: 'v literal)) = x\"", "lemma uminus_not_id[simp]: \"x \\<noteq> - (x:: 'v literal)\"", "lemma uminus_not_id'[simp]: \"- x \\<noteq> (x:: 'v literal)\"", "lemma uminus_eq_inj[iff]: \"- (a::'v literal) = - b \\<longleftrightarrow> a = b\"", "lemma uminus_lit_swap: \"(a::'a literal) = - b \\<longleftrightarrow> - a = b\"", "lemma is_pos_neg_not_is_pos: \"is_pos (- L) \\<longleftrightarrow> \\<not> is_pos L\"", "lemma pos_less_neg[simp]: \"Pos A < Neg A\"", "lemma pos_less_pos_iff[simp]: \"Pos A < Pos B \\<longleftrightarrow> A < B\"", "lemma pos_less_neg_iff[simp]: \"Pos A < Neg B \\<longleftrightarrow> A \\<le> B\"", "lemma neg_less_pos_iff[simp]: \"Neg A < Pos B \\<longleftrightarrow> A < B\"", "lemma neg_less_neg_iff[simp]: \"Neg A < Neg B \\<longleftrightarrow> A < B\"", "lemma pos_le_neg[simp]: \"Pos A \\<le> Neg A\"", "lemma pos_le_pos_iff[simp]: \"Pos A \\<le> Pos B \\<longleftrightarrow> A \\<le> B\"", "lemma pos_le_neg_iff[simp]: \"Pos A \\<le> Neg B \\<longleftrightarrow> A \\<le> B\"", "lemma neg_le_pos_iff[simp]: \"Neg A \\<le> Pos B \\<longleftrightarrow> A < B\"", "lemma neg_le_neg_iff[simp]: \"Neg A \\<le> Neg B \\<longleftrightarrow> A \\<le> B\"", "lemma leq_imp_less_eq_atm_of: \"L \\<le> M \\<Longrightarrow> atm_of L \\<le> atm_of M\"", "lemma Max_in_lits: \"C \\<noteq> {#} \\<Longrightarrow> Max_mset C \\<in># C\"", "lemma Max_atm_of_set_mset_commute: \"C \\<noteq> {#} \\<Longrightarrow> Max (atm_of ` set_mset C) = atm_of (Max_mset C)\"", "lemma Max_pos_neg_less_multiset:\n  assumes max: \"Max_mset C = Pos A\" and neg: \"Neg A \\<in># D\"\n  shows \"C < D\"", "lemma pos_Max_imp_neg_notin: \"Max_mset C = Pos A \\<Longrightarrow> Neg A \\<notin># C\"", "lemma less_eq_Max_lit: \"C \\<noteq> {#} \\<Longrightarrow> C \\<le> D \\<Longrightarrow> Max_mset C \\<le> Max_mset D\"", "lemma atms_of_empty[simp]: \"atms_of {#} = {}\"", "lemma atms_of_singleton[simp]: \"atms_of {#L#} = {atm_of L}\"", "lemma atms_of_add_mset[simp]: \"atms_of (add_mset a A) = insert (atm_of a) (atms_of A)\"", "lemma atms_of_union_mset[simp]: \"atms_of (A \\<union># B) = atms_of A \\<union> atms_of B\"", "lemma finite_atms_of[iff]: \"finite (atms_of C)\"", "lemma atm_of_lit_in_atms_of: \"L \\<in># C \\<Longrightarrow> atm_of L \\<in> atms_of C\"", "lemma atms_of_plus[simp]: \"atms_of (C + D) = atms_of C \\<union> atms_of D\"", "lemma in_atms_of_minusD: \"x \\<in> atms_of (A - B) \\<Longrightarrow> x \\<in> atms_of A\"", "lemma pos_lit_in_atms_of: \"Pos A \\<in># C \\<Longrightarrow> A \\<in> atms_of C\"", "lemma neg_lit_in_atms_of: \"Neg A \\<in># C \\<Longrightarrow> A \\<in> atms_of C\"", "lemma atm_imp_pos_or_neg_lit: \"A \\<in> atms_of C \\<Longrightarrow> Pos A \\<in># C \\<or> Neg A \\<in># C\"", "lemma atm_iff_pos_or_neg_lit: \"A \\<in> atms_of L \\<longleftrightarrow> Pos A \\<in># L \\<or> Neg A \\<in># L\"", "lemma atm_of_eq_atm_of: \"atm_of L = atm_of L' \\<longleftrightarrow> (L = L' \\<or> L = -L')\"", "lemma atm_of_in_atm_of_set_iff_in_set_or_uminus_in_set: \"atm_of L \\<in> atm_of ` I \\<longleftrightarrow> (L \\<in> I \\<or> -L \\<in> I)\"", "lemma lits_subseteq_imp_atms_subseteq: \"set_mset C \\<subseteq> set_mset D \\<Longrightarrow> atms_of C \\<subseteq> atms_of D\"", "lemma atms_empty_iff_empty[iff]: \"atms_of C = {} \\<longleftrightarrow> C = {#}\"", "lemma\n  atms_of_poss[simp]: \"atms_of (poss AA) = set_mset AA\" and\n  atms_of_negs[simp]: \"atms_of (negs AA) = set_mset AA\"", "lemma less_eq_Max_atms_of: \"C \\<noteq> {#} \\<Longrightarrow> C \\<le> D \\<Longrightarrow> Max (atms_of C) \\<le> Max (atms_of D)\"", "lemma le_multiset_Max_in_imp_Max:\n  \"Max (atms_of D) = A \\<Longrightarrow> C \\<le> D \\<Longrightarrow> A \\<in> atms_of C \\<Longrightarrow> Max (atms_of C) = A\"", "lemma atm_of_Max_lit[simp]: \"C \\<noteq> {#} \\<Longrightarrow> atm_of (Max_mset C) = Max (atms_of C)\"", "lemma Max_lit_eq_pos_or_neg_Max_atm:\n  \"C \\<noteq> {#} \\<Longrightarrow> Max_mset C = Pos (Max (atms_of C)) \\<or> Max_mset C = Neg (Max (atms_of C))\"", "lemma atms_less_imp_lit_less_pos: \"(\\<And>B. B \\<in> atms_of C \\<Longrightarrow> B < A) \\<Longrightarrow> L \\<in># C \\<Longrightarrow> L < Pos A\"", "lemma atms_less_eq_imp_lit_less_eq_neg: \"(\\<And>B. B \\<in> atms_of C \\<Longrightarrow> B \\<le> A) \\<Longrightarrow> L \\<in># C \\<Longrightarrow> L \\<le> Neg A\""], "translations": [["", "lemma Pos_atm_of_iff[simp]: \"Pos (atm_of L) = L \\<longleftrightarrow> is_pos L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Pos (atm_of L) = L) = is_pos L", "by (cases L) simp+"], ["", "lemma Neg_atm_of_iff[simp]: \"Neg (atm_of L) = L \\<longleftrightarrow> is_neg L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Neg (atm_of L) = L) = is_neg L", "by (cases L) simp+"], ["", "lemma set_literal_atm_of: \"set_literal L = {atm_of L}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_literal L = {atm_of L}", "by (cases L) simp+"], ["", "lemma ex_lit_cases: \"(\\<exists>L. P L) \\<longleftrightarrow> (\\<exists>A. P (Pos A) \\<or> P (Neg A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>L. P L) = (\\<exists>A. P (Pos A) \\<or> P (Neg A))", "by (metis literal.exhaust)"], ["", "instantiation literal :: (type) uminus\nbegin"], ["", "definition uminus_literal :: \"'a literal \\<Rightarrow> 'a literal\" where\n  \"uminus L = (if is_pos L then Neg else Pos) (atm_of L)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a literal, uminus_class)", ".."], ["", "end"], ["", "lemma\n  uminus_Pos[simp]: \"- Pos A = Neg A\" and\n  uminus_Neg[simp]: \"- Neg A = Pos A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - Pos A = Neg A &&& - Neg A = Pos A", "unfolding uminus_literal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if is_pos (Pos A) then Neg else Pos) (atm_of (Pos A)) = Neg A &&&\n    (if is_pos (Neg A) then Neg else Pos) (atm_of (Neg A)) = Pos A", "by simp_all"], ["", "lemma atm_of_uminus[simp]: \"atm_of (-L) = atm_of L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atm_of (- L) = atm_of L", "by (case_tac L, auto)"], ["", "lemma uminus_of_uminus_id[simp]: \"- (- (x :: 'v literal)) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (- x) = x", "by (simp add: uminus_literal_def)"], ["", "lemma uminus_not_id[simp]: \"x \\<noteq> - (x:: 'v literal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> - x", "by (case_tac x) auto"], ["", "lemma uminus_not_id'[simp]: \"- x \\<noteq> (x:: 'v literal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - x \\<noteq> x", "by (case_tac x, auto)"], ["", "lemma uminus_eq_inj[iff]: \"- (a::'v literal) = - b \\<longleftrightarrow> a = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- a = - b) = (a = b)", "by (case_tac a; case_tac b) auto+"], ["", "lemma uminus_lit_swap: \"(a::'a literal) = - b \\<longleftrightarrow> - a = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a = - b) = (- a = b)", "by auto"], ["", "lemma is_pos_neg_not_is_pos: \"is_pos (- L) \\<longleftrightarrow> \\<not> is_pos L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pos (- L) = is_neg L", "by (cases L) auto"], ["", "instantiation literal :: (preorder) preorder\nbegin"], ["", "definition less_literal :: \"'a literal \\<Rightarrow> 'a literal \\<Rightarrow> bool\" where\n  \"less_literal L M \\<longleftrightarrow> atm_of L < atm_of M \\<or> atm_of L \\<le> atm_of M \\<and> is_neg L < is_neg M\""], ["", "definition less_eq_literal :: \"'a literal \\<Rightarrow> 'a literal \\<Rightarrow> bool\" where\n  \"less_eq_literal L M \\<longleftrightarrow> atm_of L < atm_of M \\<or> atm_of L \\<le> atm_of M \\<and> is_neg L \\<le> is_neg M\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a literal, preorder_class)", "apply intro_classes"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z", "unfolding less_literal_def less_eq_literal_def"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       (atm_of x < atm_of y \\<or>\n        atm_of x \\<le> atm_of y \\<and> is_neg x < is_neg y) =\n       ((atm_of x < atm_of y \\<or>\n         atm_of x \\<le> atm_of y \\<and> is_neg x \\<le> is_neg y) \\<and>\n        \\<not> (atm_of y < atm_of x \\<or>\n                atm_of y \\<le> atm_of x \\<and> is_neg y \\<le> is_neg x))\n 2. \\<And>x.\n       atm_of x < atm_of x \\<or>\n       atm_of x \\<le> atm_of x \\<and> is_neg x \\<le> is_neg x\n 3. \\<And>x y z.\n       \\<lbrakk>atm_of x < atm_of y \\<or>\n                atm_of x \\<le> atm_of y \\<and> is_neg x \\<le> is_neg y;\n        atm_of y < atm_of z \\<or>\n        atm_of y \\<le> atm_of z \\<and> is_neg y \\<le> is_neg z\\<rbrakk>\n       \\<Longrightarrow> atm_of x < atm_of z \\<or>\n                         atm_of x \\<le> atm_of z \\<and>\n                         is_neg x \\<le> is_neg z", "by (auto intro: order_trans simp: less_le_not_le)"], ["", "end"], ["", "instantiation literal :: (order) order\nbegin"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a literal, order_class)", "by intro_classes (auto simp: less_eq_literal_def intro: literal.expand)"], ["", "end"], ["", "lemma pos_less_neg[simp]: \"Pos A < Neg A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pos A < Neg A", "unfolding less_literal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. atm_of (Pos A) < atm_of (Neg A) \\<or>\n    atm_of (Pos A) \\<le> atm_of (Neg A) \\<and>\n    is_neg (Pos A) < is_neg (Neg A)", "by simp"], ["", "lemma pos_less_pos_iff[simp]: \"Pos A < Pos B \\<longleftrightarrow> A < B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Pos A < Pos B) = (A < B)", "unfolding less_literal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (atm_of (Pos A) < atm_of (Pos B) \\<or>\n     atm_of (Pos A) \\<le> atm_of (Pos B) \\<and>\n     is_neg (Pos A) < is_neg (Pos B)) =\n    (A < B)", "by simp"], ["", "lemma pos_less_neg_iff[simp]: \"Pos A < Neg B \\<longleftrightarrow> A \\<le> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Pos A < Neg B) = (A \\<le> B)", "unfolding less_literal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (atm_of (Pos A) < atm_of (Neg B) \\<or>\n     atm_of (Pos A) \\<le> atm_of (Neg B) \\<and>\n     is_neg (Pos A) < is_neg (Neg B)) =\n    (A \\<le> B)", "by (auto simp: less_le_not_le)"], ["", "lemma neg_less_pos_iff[simp]: \"Neg A < Pos B \\<longleftrightarrow> A < B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Neg A < Pos B) = (A < B)", "unfolding less_literal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (atm_of (Neg A) < atm_of (Pos B) \\<or>\n     atm_of (Neg A) \\<le> atm_of (Pos B) \\<and>\n     is_neg (Neg A) < is_neg (Pos B)) =\n    (A < B)", "by simp"], ["", "lemma neg_less_neg_iff[simp]: \"Neg A < Neg B \\<longleftrightarrow> A < B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Neg A < Neg B) = (A < B)", "unfolding less_literal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (atm_of (Neg A) < atm_of (Neg B) \\<or>\n     atm_of (Neg A) \\<le> atm_of (Neg B) \\<and>\n     is_neg (Neg A) < is_neg (Neg B)) =\n    (A < B)", "by simp"], ["", "lemma pos_le_neg[simp]: \"Pos A \\<le> Neg A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pos A \\<le> Neg A", "unfolding less_eq_literal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. atm_of (Pos A) < atm_of (Neg A) \\<or>\n    atm_of (Pos A) \\<le> atm_of (Neg A) \\<and>\n    is_neg (Pos A) \\<le> is_neg (Neg A)", "by simp"], ["", "lemma pos_le_pos_iff[simp]: \"Pos A \\<le> Pos B \\<longleftrightarrow> A \\<le> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Pos A \\<le> Pos B) = (A \\<le> B)", "unfolding less_eq_literal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (atm_of (Pos A) < atm_of (Pos B) \\<or>\n     atm_of (Pos A) \\<le> atm_of (Pos B) \\<and>\n     is_neg (Pos A) \\<le> is_neg (Pos B)) =\n    (A \\<le> B)", "by (auto simp: less_le_not_le)"], ["", "lemma pos_le_neg_iff[simp]: \"Pos A \\<le> Neg B \\<longleftrightarrow> A \\<le> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Pos A \\<le> Neg B) = (A \\<le> B)", "unfolding less_eq_literal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (atm_of (Pos A) < atm_of (Neg B) \\<or>\n     atm_of (Pos A) \\<le> atm_of (Neg B) \\<and>\n     is_neg (Pos A) \\<le> is_neg (Neg B)) =\n    (A \\<le> B)", "by (auto simp: less_imp_le)"], ["", "lemma neg_le_pos_iff[simp]: \"Neg A \\<le> Pos B \\<longleftrightarrow> A < B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Neg A \\<le> Pos B) = (A < B)", "unfolding less_eq_literal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (atm_of (Neg A) < atm_of (Pos B) \\<or>\n     atm_of (Neg A) \\<le> atm_of (Pos B) \\<and>\n     is_neg (Neg A) \\<le> is_neg (Pos B)) =\n    (A < B)", "by simp"], ["", "lemma neg_le_neg_iff[simp]: \"Neg A \\<le> Neg B \\<longleftrightarrow> A \\<le> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Neg A \\<le> Neg B) = (A \\<le> B)", "unfolding less_eq_literal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (atm_of (Neg A) < atm_of (Neg B) \\<or>\n     atm_of (Neg A) \\<le> atm_of (Neg B) \\<and>\n     is_neg (Neg A) \\<le> is_neg (Neg B)) =\n    (A \\<le> B)", "by (auto simp: less_imp_le)"], ["", "lemma leq_imp_less_eq_atm_of: \"L \\<le> M \\<Longrightarrow> atm_of L \\<le> atm_of M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L \\<le> M \\<Longrightarrow> atm_of L \\<le> atm_of M", "unfolding less_eq_literal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. atm_of L < atm_of M \\<or>\n    atm_of L \\<le> atm_of M \\<and> is_neg L \\<le> is_neg M \\<Longrightarrow>\n    atm_of L \\<le> atm_of M", "using less_imp_le"], ["proof (prove)\nusing this:\n  ?x < ?y \\<Longrightarrow> ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. atm_of L < atm_of M \\<or>\n    atm_of L \\<le> atm_of M \\<and> is_neg L \\<le> is_neg M \\<Longrightarrow>\n    atm_of L \\<le> atm_of M", "by blast"], ["", "instantiation literal :: (linorder) linorder\nbegin"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a literal, linorder_class)", "apply intro_classes"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "unfolding less_eq_literal_def less_literal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (atm_of x < atm_of y \\<or>\n        atm_of x \\<le> atm_of y \\<and> is_neg x \\<le> is_neg y) \\<or>\n       atm_of y < atm_of x \\<or>\n       atm_of y \\<le> atm_of x \\<and> is_neg y \\<le> is_neg x", "by auto"], ["", "end"], ["", "instantiation literal :: (wellorder) wellorder\nbegin"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a literal, wellorder_class)", "proof intro_classes"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P a.\n       (\\<And>x.\n           (\\<And>y. y < x \\<Longrightarrow> P y) \\<Longrightarrow>\n           P x) \\<Longrightarrow>\n       P a", "fix P :: \"'a literal \\<Rightarrow> bool\" and L :: \"'a literal\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P a.\n       (\\<And>x.\n           (\\<And>y. y < x \\<Longrightarrow> P y) \\<Longrightarrow>\n           P x) \\<Longrightarrow>\n       P a", "assume ih: \"\\<And>L. (\\<And>M. M < L \\<Longrightarrow> P M) \\<Longrightarrow> P L\""], ["proof (state)\nthis:\n  (\\<And>M. M < ?L \\<Longrightarrow> P M) \\<Longrightarrow> P ?L\n\ngoal (1 subgoal):\n 1. \\<And>P a.\n       (\\<And>x.\n           (\\<And>y. y < x \\<Longrightarrow> P y) \\<Longrightarrow>\n           P x) \\<Longrightarrow>\n       P a", "have \"\\<And>x. (\\<And>y. y < x \\<Longrightarrow> P (Pos y) \\<and> P (Neg y)) \\<Longrightarrow> P (Pos x) \\<and> P (Neg x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y < x \\<Longrightarrow>\n           P (Pos y) \\<and> P (Neg y)) \\<Longrightarrow>\n       P (Pos x) \\<and> P (Neg x)", "by (rule conjI[OF ih ih])\n      (auto simp: less_literal_def atm_of_def split: literal.splits intro: ih)"], ["proof (state)\nthis:\n  (\\<And>y.\n      y < ?x \\<Longrightarrow> P (Pos y) \\<and> P (Neg y)) \\<Longrightarrow>\n  P (Pos ?x) \\<and> P (Neg ?x)\n\ngoal (1 subgoal):\n 1. \\<And>P a.\n       (\\<And>x.\n           (\\<And>y. y < x \\<Longrightarrow> P y) \\<Longrightarrow>\n           P x) \\<Longrightarrow>\n       P a", "then"], ["proof (chain)\npicking this:\n  (\\<And>y.\n      y < ?x \\<Longrightarrow> P (Pos y) \\<and> P (Neg y)) \\<Longrightarrow>\n  P (Pos ?x) \\<and> P (Neg ?x)", "have \"\\<And>A. P (Pos A) \\<and> P (Neg A)\""], ["proof (prove)\nusing this:\n  (\\<And>y.\n      y < ?x \\<Longrightarrow> P (Pos y) \\<and> P (Neg y)) \\<Longrightarrow>\n  P (Pos ?x) \\<and> P (Neg ?x)\n\ngoal (1 subgoal):\n 1. \\<And>A. P (Pos A) \\<and> P (Neg A)", "by (rule less_induct) blast"], ["proof (state)\nthis:\n  P (Pos ?A) \\<and> P (Neg ?A)\n\ngoal (1 subgoal):\n 1. \\<And>P a.\n       (\\<And>x.\n           (\\<And>y. y < x \\<Longrightarrow> P y) \\<Longrightarrow>\n           P x) \\<Longrightarrow>\n       P a", "then"], ["proof (chain)\npicking this:\n  P (Pos ?A) \\<and> P (Neg ?A)", "show \"P L\""], ["proof (prove)\nusing this:\n  P (Pos ?A) \\<and> P (Neg ?A)\n\ngoal (1 subgoal):\n 1. P L", "by (cases L) simp+"], ["proof (state)\nthis:\n  P L\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Clauses\\<close>"], ["", "text \\<open>\nClauses are (finite) multisets of literals.\n\\<close>"], ["", "type_synonym 'a clause = \"'a literal multiset\""], ["", "abbreviation map_clause :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> 'a clause \\<Rightarrow> 'b clause\" where\n  \"map_clause f \\<equiv> image_mset (map_literal f)\""], ["", "abbreviation rel_clause :: \"('a \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> 'a clause \\<Rightarrow> 'b clause \\<Rightarrow> bool\" where\n  \"rel_clause R \\<equiv> rel_mset (rel_literal R)\""], ["", "abbreviation poss :: \"'a multiset \\<Rightarrow> 'a clause\" where \"poss AA \\<equiv> {#Pos A. A \\<in># AA#}\""], ["", "abbreviation negs :: \"'a multiset \\<Rightarrow> 'a clause\" where \"negs AA \\<equiv> {#Neg A. A \\<in># AA#}\""], ["", "lemma Max_in_lits: \"C \\<noteq> {#} \\<Longrightarrow> Max_mset C \\<in># C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<noteq> {#} \\<Longrightarrow> Max_mset C \\<in># C", "by simp"], ["", "lemma Max_atm_of_set_mset_commute: \"C \\<noteq> {#} \\<Longrightarrow> Max (atm_of ` set_mset C) = atm_of (Max_mset C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<noteq> {#} \\<Longrightarrow>\n    Max (atm_of ` set_mset C) = atm_of (Max_mset C)", "by (rule mono_Max_commute[symmetric]) (auto simp: mono_def less_eq_literal_def)"], ["", "lemma Max_pos_neg_less_multiset:\n  assumes max: \"Max_mset C = Pos A\" and neg: \"Neg A \\<in># D\"\n  shows \"C < D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C < D", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. C < D", "have \"Max_mset C < Neg A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max_mset C < Neg A", "using max"], ["proof (prove)\nusing this:\n  Max_mset C = Pos A\n\ngoal (1 subgoal):\n 1. Max_mset C < Neg A", "by simp"], ["proof (state)\nthis:\n  Max_mset C < Neg A\n\ngoal (1 subgoal):\n 1. C < D", "then"], ["proof (chain)\npicking this:\n  Max_mset C < Neg A", "show ?thesis"], ["proof (prove)\nusing this:\n  Max_mset C < Neg A\n\ngoal (1 subgoal):\n 1. C < D", "using neg"], ["proof (prove)\nusing this:\n  Max_mset C < Neg A\n  Neg A \\<in># D\n\ngoal (1 subgoal):\n 1. C < D", "by (metis (no_types) Max_less_iff empty_iff ex_gt_imp_less_multiset finite_set_mset)"], ["proof (state)\nthis:\n  C < D\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pos_Max_imp_neg_notin: \"Max_mset C = Pos A \\<Longrightarrow> Neg A \\<notin># C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max_mset C = Pos A \\<Longrightarrow> Neg A \\<notin># C", "using Max_pos_neg_less_multiset"], ["proof (prove)\nusing this:\n  \\<lbrakk>Max_mset ?C = Pos ?A; Neg ?A \\<in># ?D\\<rbrakk>\n  \\<Longrightarrow> ?C < ?D\n\ngoal (1 subgoal):\n 1. Max_mset C = Pos A \\<Longrightarrow> Neg A \\<notin># C", "by blast"], ["", "lemma less_eq_Max_lit: \"C \\<noteq> {#} \\<Longrightarrow> C \\<le> D \\<Longrightarrow> Max_mset C \\<le> Max_mset D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<noteq> {#}; C \\<le> D\\<rbrakk>\n    \\<Longrightarrow> Max_mset C \\<le> Max_mset D", "proof (unfold less_eq_multiset\\<^sub>H\\<^sub>O)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<noteq> {#};\n     \\<forall>y.\n        count D y < count C y \\<longrightarrow>\n        (\\<exists>x>y. count C x < count D x)\\<rbrakk>\n    \\<Longrightarrow> Max_mset C \\<le> Max_mset D", "assume\n    ne: \"C \\<noteq> {#}\" and\n    ex_gt: \"\\<forall>x. count D x < count C x \\<longrightarrow> (\\<exists>y > x. count C y < count D y)\""], ["proof (state)\nthis:\n  C \\<noteq> {#}\n  \\<forall>x.\n     count D x < count C x \\<longrightarrow>\n     (\\<exists>y>x. count C y < count D y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<noteq> {#};\n     \\<forall>y.\n        count D y < count C y \\<longrightarrow>\n        (\\<exists>x>y. count C x < count D x)\\<rbrakk>\n    \\<Longrightarrow> Max_mset C \\<le> Max_mset D", "from ne"], ["proof (chain)\npicking this:\n  C \\<noteq> {#}", "have \"Max_mset C \\<in># C\""], ["proof (prove)\nusing this:\n  C \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. Max_mset C \\<in># C", "by (fast intro: Max_in_lits)"], ["proof (state)\nthis:\n  Max_mset C \\<in># C\n\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<noteq> {#};\n     \\<forall>y.\n        count D y < count C y \\<longrightarrow>\n        (\\<exists>x>y. count C x < count D x)\\<rbrakk>\n    \\<Longrightarrow> Max_mset C \\<le> Max_mset D", "then"], ["proof (chain)\npicking this:\n  Max_mset C \\<in># C", "have \"\\<exists>l. l \\<in># D \\<and> \\<not> l < Max_mset C\""], ["proof (prove)\nusing this:\n  Max_mset C \\<in># C\n\ngoal (1 subgoal):\n 1. \\<exists>l. l \\<in># D \\<and> \\<not> l < Max_mset C", "using ex_gt"], ["proof (prove)\nusing this:\n  Max_mset C \\<in># C\n  \\<forall>x.\n     count D x < count C x \\<longrightarrow>\n     (\\<exists>y>x. count C y < count D y)\n\ngoal (1 subgoal):\n 1. \\<exists>l. l \\<in># D \\<and> \\<not> l < Max_mset C", "by (metis count_greater_zero_iff count_inI less_not_sym)"], ["proof (state)\nthis:\n  \\<exists>l. l \\<in># D \\<and> \\<not> l < Max_mset C\n\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<noteq> {#};\n     \\<forall>y.\n        count D y < count C y \\<longrightarrow>\n        (\\<exists>x>y. count C x < count D x)\\<rbrakk>\n    \\<Longrightarrow> Max_mset C \\<le> Max_mset D", "then"], ["proof (chain)\npicking this:\n  \\<exists>l. l \\<in># D \\<and> \\<not> l < Max_mset C", "have \"\\<not> Max_mset D < Max_mset C\""], ["proof (prove)\nusing this:\n  \\<exists>l. l \\<in># D \\<and> \\<not> l < Max_mset C\n\ngoal (1 subgoal):\n 1. \\<not> Max_mset D < Max_mset C", "by (metis Max.coboundedI[OF finite_set_mset] le_less_trans)"], ["proof (state)\nthis:\n  \\<not> Max_mset D < Max_mset C\n\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<noteq> {#};\n     \\<forall>y.\n        count D y < count C y \\<longrightarrow>\n        (\\<exists>x>y. count C x < count D x)\\<rbrakk>\n    \\<Longrightarrow> Max_mset C \\<le> Max_mset D", "then"], ["proof (chain)\npicking this:\n  \\<not> Max_mset D < Max_mset C", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> Max_mset D < Max_mset C\n\ngoal (1 subgoal):\n 1. Max_mset C \\<le> Max_mset D", "by simp"], ["proof (state)\nthis:\n  Max_mset C \\<le> Max_mset D\n\ngoal:\nNo subgoals!", "qed"], ["", "definition atms_of :: \"'a clause \\<Rightarrow> 'a set\" where\n  \"atms_of C = atm_of ` set_mset C\""], ["", "lemma atms_of_empty[simp]: \"atms_of {#} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atms_of {#} = {}", "unfolding atms_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. atm_of ` set_mset {#} = {}", "by simp"], ["", "lemma atms_of_singleton[simp]: \"atms_of {#L#} = {atm_of L}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atms_of {#L#} = {atm_of L}", "unfolding atms_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. atm_of ` set_mset {#L#} = {atm_of L}", "by auto"], ["", "lemma atms_of_add_mset[simp]: \"atms_of (add_mset a A) = insert (atm_of a) (atms_of A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atms_of (add_mset a A) = insert (atm_of a) (atms_of A)", "unfolding atms_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. atm_of ` set_mset (add_mset a A) =\n    insert (atm_of a) (atm_of ` set_mset A)", "by auto"], ["", "lemma atms_of_union_mset[simp]: \"atms_of (A \\<union># B) = atms_of A \\<union> atms_of B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atms_of (A \\<union># B) = atms_of A \\<union> atms_of B", "unfolding atms_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. atm_of ` set_mset (A \\<union># B) =\n    atm_of ` set_mset A \\<union> atm_of ` set_mset B", "by auto"], ["", "lemma finite_atms_of[iff]: \"finite (atms_of C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (atms_of C)", "by (simp add: atms_of_def)"], ["", "lemma atm_of_lit_in_atms_of: \"L \\<in># C \\<Longrightarrow> atm_of L \\<in> atms_of C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L \\<in># C \\<Longrightarrow> atm_of L \\<in> atms_of C", "by (simp add: atms_of_def)"], ["", "lemma atms_of_plus[simp]: \"atms_of (C + D) = atms_of C \\<union> atms_of D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atms_of (C + D) = atms_of C \\<union> atms_of D", "unfolding atms_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. atm_of ` set_mset (C + D) =\n    atm_of ` set_mset C \\<union> atm_of ` set_mset D", "by auto"], ["", "lemma in_atms_of_minusD: \"x \\<in> atms_of (A - B) \\<Longrightarrow> x \\<in> atms_of A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> atms_of (A - B) \\<Longrightarrow> x \\<in> atms_of A", "by (auto simp: atms_of_def dest: in_diffD)"], ["", "lemma pos_lit_in_atms_of: \"Pos A \\<in># C \\<Longrightarrow> A \\<in> atms_of C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pos A \\<in># C \\<Longrightarrow> A \\<in> atms_of C", "unfolding atms_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Pos A \\<in># C \\<Longrightarrow> A \\<in> atm_of ` set_mset C", "by force"], ["", "lemma neg_lit_in_atms_of: \"Neg A \\<in># C \\<Longrightarrow> A \\<in> atms_of C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Neg A \\<in># C \\<Longrightarrow> A \\<in> atms_of C", "unfolding atms_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Neg A \\<in># C \\<Longrightarrow> A \\<in> atm_of ` set_mset C", "by force"], ["", "lemma atm_imp_pos_or_neg_lit: \"A \\<in> atms_of C \\<Longrightarrow> Pos A \\<in># C \\<or> Neg A \\<in># C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> atms_of C \\<Longrightarrow> Pos A \\<in># C \\<or> Neg A \\<in># C", "unfolding atms_of_def image_def mem_Collect_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>#C. A = atm_of x \\<Longrightarrow>\n    Pos A \\<in># C \\<or> Neg A \\<in># C", "by (metis Neg_atm_of_iff Pos_atm_of_iff)"], ["", "lemma atm_iff_pos_or_neg_lit: \"A \\<in> atms_of L \\<longleftrightarrow> Pos A \\<in># L \\<or> Neg A \\<in># L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<in> atms_of L) = (Pos A \\<in># L \\<or> Neg A \\<in># L)", "by (auto intro: pos_lit_in_atms_of neg_lit_in_atms_of dest: atm_imp_pos_or_neg_lit)"], ["", "lemma atm_of_eq_atm_of: \"atm_of L = atm_of L' \\<longleftrightarrow> (L = L' \\<or> L = -L')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (atm_of L = atm_of L') = (L = L' \\<or> L = - L')", "by (cases L; cases L') auto"], ["", "lemma atm_of_in_atm_of_set_iff_in_set_or_uminus_in_set: \"atm_of L \\<in> atm_of ` I \\<longleftrightarrow> (L \\<in> I \\<or> -L \\<in> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (atm_of L \\<in> atm_of ` I) = (L \\<in> I \\<or> - L \\<in> I)", "by (auto intro: rev_image_eqI simp: atm_of_eq_atm_of)"], ["", "lemma lits_subseteq_imp_atms_subseteq: \"set_mset C \\<subseteq> set_mset D \\<Longrightarrow> atms_of C \\<subseteq> atms_of D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_mset C \\<subseteq> set_mset D \\<Longrightarrow>\n    atms_of C \\<subseteq> atms_of D", "unfolding atms_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_mset C \\<subseteq> set_mset D \\<Longrightarrow>\n    atm_of ` set_mset C \\<subseteq> atm_of ` set_mset D", "by blast"], ["", "lemma atms_empty_iff_empty[iff]: \"atms_of C = {} \\<longleftrightarrow> C = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (atms_of C = {}) = (C = {#})", "unfolding atms_of_def image_def Collect_empty_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. \\<not> (\\<exists>xa\\<in>#C. x = atm_of xa)) = (C = {#})", "by auto"], ["", "lemma\n  atms_of_poss[simp]: \"atms_of (poss AA) = set_mset AA\" and\n  atms_of_negs[simp]: \"atms_of (negs AA) = set_mset AA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atms_of (poss AA) = set_mset AA &&& atms_of (negs AA) = set_mset AA", "unfolding atms_of_def image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. \\<exists>x\\<in>#poss AA. y = atm_of x} = set_mset AA &&&\n    {y. \\<exists>x\\<in>#negs AA. y = atm_of x} = set_mset AA", "by auto"], ["", "lemma less_eq_Max_atms_of: \"C \\<noteq> {#} \\<Longrightarrow> C \\<le> D \\<Longrightarrow> Max (atms_of C) \\<le> Max (atms_of D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<noteq> {#}; C \\<le> D\\<rbrakk>\n    \\<Longrightarrow> Max (atms_of C) \\<le> Max (atms_of D)", "unfolding atms_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<noteq> {#}; C \\<le> D\\<rbrakk>\n    \\<Longrightarrow> Max (atm_of ` set_mset C)\n                      \\<le> Max (atm_of ` set_mset D)", "by (metis Max_atm_of_set_mset_commute leq_imp_less_eq_atm_of less_eq_Max_lit\n      less_eq_multiset_empty_right)"], ["", "lemma le_multiset_Max_in_imp_Max:\n  \"Max (atms_of D) = A \\<Longrightarrow> C \\<le> D \\<Longrightarrow> A \\<in> atms_of C \\<Longrightarrow> Max (atms_of C) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Max (atms_of D) = A; C \\<le> D; A \\<in> atms_of C\\<rbrakk>\n    \\<Longrightarrow> Max (atms_of C) = A", "by (metis Max.coboundedI[OF finite_atms_of] atms_of_def empty_iff eq_iff image_subsetI\n      less_eq_Max_atms_of set_mset_empty subset_Compl_self_eq)"], ["", "lemma atm_of_Max_lit[simp]: \"C \\<noteq> {#} \\<Longrightarrow> atm_of (Max_mset C) = Max (atms_of C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<noteq> {#} \\<Longrightarrow> atm_of (Max_mset C) = Max (atms_of C)", "unfolding atms_of_def Max_atm_of_set_mset_commute"], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<noteq> {#} \\<Longrightarrow>\n    atm_of (Max_mset C) = atm_of (Max_mset C)", ".."], ["", "lemma Max_lit_eq_pos_or_neg_Max_atm:\n  \"C \\<noteq> {#} \\<Longrightarrow> Max_mset C = Pos (Max (atms_of C)) \\<or> Max_mset C = Neg (Max (atms_of C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<noteq> {#} \\<Longrightarrow>\n    Max_mset C = Pos (Max (atms_of C)) \\<or>\n    Max_mset C = Neg (Max (atms_of C))", "by (metis Neg_atm_of_iff Pos_atm_of_iff atm_of_Max_lit)"], ["", "lemma atms_less_imp_lit_less_pos: \"(\\<And>B. B \\<in> atms_of C \\<Longrightarrow> B < A) \\<Longrightarrow> L \\<in># C \\<Longrightarrow> L < Pos A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>B. B \\<in> atms_of C \\<Longrightarrow> B < A;\n     L \\<in># C\\<rbrakk>\n    \\<Longrightarrow> L < Pos A", "unfolding atms_of_def less_literal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>B. B \\<in> atm_of ` set_mset C \\<Longrightarrow> B < A;\n     L \\<in># C\\<rbrakk>\n    \\<Longrightarrow> atm_of L < atm_of (Pos A) \\<or>\n                      atm_of L \\<le> atm_of (Pos A) \\<and>\n                      is_neg L < is_neg (Pos A)", "by force"], ["", "lemma atms_less_eq_imp_lit_less_eq_neg: \"(\\<And>B. B \\<in> atms_of C \\<Longrightarrow> B \\<le> A) \\<Longrightarrow> L \\<in># C \\<Longrightarrow> L \\<le> Neg A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>B. B \\<in> atms_of C \\<Longrightarrow> B \\<le> A;\n     L \\<in># C\\<rbrakk>\n    \\<Longrightarrow> L \\<le> Neg A", "unfolding less_eq_literal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>B. B \\<in> atms_of C \\<Longrightarrow> B \\<le> A;\n     L \\<in># C\\<rbrakk>\n    \\<Longrightarrow> atm_of L < atm_of (Neg A) \\<or>\n                      atm_of L \\<le> atm_of (Neg A) \\<and>\n                      is_neg L \\<le> is_neg (Neg A)", "by (simp add: atm_of_lit_in_atms_of)"], ["", "end"]]}