{"file_name": "/home/qj213/afp-2021-10-22/thys/Relation_Algebra/Relation_Algebra_Direct_Products.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Relation_Algebra", "problem_names": ["lemma dp_p_fun1: \"is_direct_product x y \\<Longrightarrow> is_p_fun x\"", "lemma dp_sur1: \"is_direct_product x y \\<Longrightarrow> is_sur x\"", "lemma dp_total1: \"is_direct_product x y \\<Longrightarrow> is_total x\"", "lemma dp_map1: \"is_direct_product x y \\<Longrightarrow> is_map x\"", "lemma dp_p_fun2: \"is_direct_product x y \\<Longrightarrow> is_p_fun y\"", "lemma dp_sur2: \"is_direct_product x y \\<Longrightarrow> is_sur y\"", "lemma dp_total2: \"is_direct_product x y \\<Longrightarrow> is_total y\"", "lemma dp_map2: \"is_direct_product x y \\<Longrightarrow> is_map y\"", "lemma dp_aux1 [simp]:\n  assumes \"is_p_fun z\"\n    and \"is_total w\"\n    and \"x\\<^sup>\\<smile> ; z = 1\"\n  shows \"(w ; x\\<^sup>\\<smile> \\<cdot> y ; z\\<^sup>\\<smile>) ; z = y\"", "lemma dp_aux2 [simp]:\n  assumes \"is_p_fun z\"\n    and \"is_total w\"\n    and \"z\\<^sup>\\<smile> ; x = 1\"\n  shows \"(w ; x\\<^sup>\\<smile> \\<cdot> y ; z\\<^sup>\\<smile>) ; z = y\"", "lemma dp_aux3 [simp]:\n  assumes \"is_p_fun z\"\n    and \"is_total w\"\n    and \"x\\<^sup>\\<smile> ; z = 1\"\n  shows \"(y ; z\\<^sup>\\<smile> \\<cdot> w ; x\\<^sup>\\<smile>) ; z = y\"", "lemma dp_aux4 [simp]:\n  assumes \"is_p_fun z\"\n    and \"is_total w\"\n    and \"z\\<^sup>\\<smile> ; x = 1\"\n  shows \"( y ; z\\<^sup>\\<smile> \\<cdot> w ; x\\<^sup>\\<smile>) ; z = y\"", "lemma Phi_conv: \"(\\<Phi> w x y z)\\<^sup>\\<smile> = y ; w\\<^sup>\\<smile> \\<cdot> z ; x\\<^sup>\\<smile>\"", "lemma mono_dp_1:\n  assumes \"is_direct_product w x\"\n    and \"is_direct_product y z\"\n  shows \"\\<Phi> w x y z ; y = w\"", "lemma mono_dp_2:\n  assumes \"is_direct_product w x\"\n    and \"is_direct_product y z\"\n  shows \"\\<Phi> w x y z ; z = x\"", "lemma Phi_map:\n  assumes \"is_direct_product w x\"\n    and \"is_direct_product y z\"\n  shows \"is_map (\\<Phi> w x y z)\"", "lemma Phi_inj:\n  assumes \"is_direct_product w x\"\n    and \"is_direct_product y z\"\n  shows \"is_inj (\\<Phi> w x y z)\"", "lemma Phi_conv_map:\n  assumes \"is_direct_product w x\"\n    and \"is_direct_product y z\"\n  shows \"is_map ((\\<Phi> w x y z)\\<^sup>\\<smile>)\"", "lemma Phi_conv_inj:\n  assumes \"is_direct_product w x\"\n    and \"is_direct_product y z\"\n  shows \"is_inj ((\\<Phi> w x y z)\\<^sup>\\<smile>)\"", "lemma Phi_sur:\n  assumes \"is_direct_product w x\"\n  and \"is_direct_product y z\"\n  shows \"is_sur (\\<Phi> w x y z)\"", "lemma Phi_conv_sur:\n  assumes \"is_direct_product w x\"\n    and \"is_direct_product y z\"\n  shows \"is_sur ((\\<Phi> w x y z)\\<^sup>\\<smile>)\"", "lemma Phi_bij:\n  assumes \"is_direct_product w x\"\n    and \"is_direct_product y z\"\n  shows \"is_bij (\\<Phi> w x y z)\"", "lemma Phi_conv_bij:\n  assumes \"is_direct_product w x\"\n    and \"is_direct_product y z\"\n  shows \"is_bij ((\\<Phi> w x y z)\\<^sup>\\<smile>)\"", "lemma f_proj:\n  assumes \"is_direct_product x y\"\n  and \"is_map g\"\n  shows \"F f x g y ; x = f\"", "lemma g_proj:\n  assumes \"is_direct_product x y\"\n  and \"is_map f\"\n  shows \"F f x g y ; y = g\"", "lemma\n  assumes \"is_direct_product x y\"\n  and \"is_map f\"\n  and \"is_map g\"\n  and \"is_map G\"\n  and \"f = G ; x\"\n  and \"g = G ; y\"\n  shows \"G = F f x g y\""], "translations": [["", "lemma dp_p_fun1: \"is_direct_product x y \\<Longrightarrow> is_p_fun x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_direct_product x y \\<Longrightarrow> is_p_fun x", "by (metis is_direct_product_def eq_refl is_p_fun_def)"], ["", "lemma dp_sur1: \"is_direct_product x y \\<Longrightarrow> is_sur x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_direct_product x y \\<Longrightarrow> is_sur x", "by (metis is_direct_product_def eq_refl is_sur_def)"], ["", "lemma dp_total1: \"is_direct_product x y \\<Longrightarrow> is_total x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_direct_product x y \\<Longrightarrow> is_total x", "by (metis is_direct_product_def inf_le1 is_total_def)"], ["", "lemma dp_map1: \"is_direct_product x y \\<Longrightarrow> is_map x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_direct_product x y \\<Longrightarrow> is_map x", "by (metis dp_p_fun1 dp_total1 is_map_def)"], ["", "lemma dp_p_fun2: \"is_direct_product x y \\<Longrightarrow> is_p_fun y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_direct_product x y \\<Longrightarrow> is_p_fun y", "by (metis is_direct_product_def eq_refl is_p_fun_def)"], ["", "lemma dp_sur2: \"is_direct_product x y \\<Longrightarrow> is_sur y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_direct_product x y \\<Longrightarrow> is_sur y", "by (metis is_direct_product_def eq_refl is_sur_def)"], ["", "lemma dp_total2: \"is_direct_product x y \\<Longrightarrow> is_total y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_direct_product x y \\<Longrightarrow> is_total y", "by (metis is_direct_product_def inf_le2 is_total_def)"], ["", "lemma dp_map2: \"is_direct_product x y \\<Longrightarrow> is_map y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_direct_product x y \\<Longrightarrow> is_map y", "by (metis dp_p_fun2 dp_total2 is_map_def)"], ["", "text \\<open>Next we prove four auxiliary lemmas.\\<close>"], ["", "lemma dp_aux1 [simp]:\n  assumes \"is_p_fun z\"\n    and \"is_total w\"\n    and \"x\\<^sup>\\<smile> ; z = 1\"\n  shows \"(w ; x\\<^sup>\\<smile> \\<cdot> y ; z\\<^sup>\\<smile>) ; z = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w ; x\\<^sup>\\<smile> \\<cdot> y ; z\\<^sup>\\<smile>) ; z = y", "by (metis assms inf_top_left mult.assoc ss_422iii total_one inf.commute inf_top_right)"], ["", "lemma dp_aux2 [simp]:\n  assumes \"is_p_fun z\"\n    and \"is_total w\"\n    and \"z\\<^sup>\\<smile> ; x = 1\"\n  shows \"(w ; x\\<^sup>\\<smile> \\<cdot> y ; z\\<^sup>\\<smile>) ; z = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w ; x\\<^sup>\\<smile> \\<cdot> y ; z\\<^sup>\\<smile>) ; z = y", "by (metis assms conv_contrav conv_invol conv_one inf_top_left mult.assoc ss_422iii total_one)"], ["", "lemma dp_aux3 [simp]:\n  assumes \"is_p_fun z\"\n    and \"is_total w\"\n    and \"x\\<^sup>\\<smile> ; z = 1\"\n  shows \"(y ; z\\<^sup>\\<smile> \\<cdot> w ; x\\<^sup>\\<smile>) ; z = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y ; z\\<^sup>\\<smile> \\<cdot> w ; x\\<^sup>\\<smile>) ; z = y", "by (metis assms dp_aux1 inf.commute)"], ["", "lemma dp_aux4 [simp]:\n  assumes \"is_p_fun z\"\n    and \"is_total w\"\n    and \"z\\<^sup>\\<smile> ; x = 1\"\n  shows \"( y ; z\\<^sup>\\<smile> \\<cdot> w ; x\\<^sup>\\<smile>) ; z = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y ; z\\<^sup>\\<smile> \\<cdot> w ; x\\<^sup>\\<smile>) ; z = y", "by (metis assms dp_aux2 inf.commute)"], ["", "text \\<open>Next we define a function which is an isomorphism on projections.\\<close>"], ["", "definition Phi :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\" (\"\\<Phi>\")\n  where \"\\<Phi> \\<equiv> (\\<lambda>w x y z. w ; y\\<^sup>\\<smile> \\<cdot> x ; z\\<^sup>\\<smile>)\""], ["", "lemma Phi_conv: \"(\\<Phi> w x y z)\\<^sup>\\<smile> = y ; w\\<^sup>\\<smile> \\<cdot> z ; x\\<^sup>\\<smile>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Phi> w x y z)\\<^sup>\\<smile> =\n    y ; w\\<^sup>\\<smile> \\<cdot> z ; x\\<^sup>\\<smile>", "by (simp add: Phi_def)"], ["", "text \\<open>We prove that @{const Phi} is an isomorphism with respect to the\nprojections.\\<close>"], ["", "lemma mono_dp_1:\n  assumes \"is_direct_product w x\"\n    and \"is_direct_product y z\"\n  shows \"\\<Phi> w x y z ; y = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> w x y z ; y = w", "by (metis assms dp_aux4 is_direct_product_def dp_p_fun1 dp_total2 Phi_def)"], ["", "lemma mono_dp_2:\n  assumes \"is_direct_product w x\"\n    and \"is_direct_product y z\"\n  shows \"\\<Phi> w x y z ; z = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> w x y z ; z = x", "by (metis assms dp_aux1 is_direct_product_def dp_p_fun2 dp_total1 Phi_def)"], ["", "text \\<open>We now show that @{const Phi} is an injective function.\\<close>"], ["", "lemma Phi_map:\n  assumes \"is_direct_product w x\"\n    and \"is_direct_product y z\"\n  shows \"is_map (\\<Phi> w x y z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_map (\\<Phi> w x y z)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_map (\\<Phi> w x y z)", "have \"\\<Phi> w x y z ; -(1') = \\<Phi> w x y z ; -(y ; y\\<^sup>\\<smile> \\<cdot> z ; z\\<^sup>\\<smile>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> w x y z ; - 1' =\n    \\<Phi> w x y z ; - (y ; y\\<^sup>\\<smile> \\<cdot> z ; z\\<^sup>\\<smile>)", "by (metis assms(2) is_direct_product_def)"], ["proof (state)\nthis:\n  \\<Phi> w x y z ; - 1' =\n  \\<Phi> w x y z ; - (y ; y\\<^sup>\\<smile> \\<cdot> z ; z\\<^sup>\\<smile>)\n\ngoal (1 subgoal):\n 1. is_map (\\<Phi> w x y z)", "also"], ["proof (state)\nthis:\n  \\<Phi> w x y z ; - 1' =\n  \\<Phi> w x y z ; - (y ; y\\<^sup>\\<smile> \\<cdot> z ; z\\<^sup>\\<smile>)\n\ngoal (1 subgoal):\n 1. is_map (\\<Phi> w x y z)", "have \"... = \\<Phi> w x y z ; y ; -(y\\<^sup>\\<smile>) + \\<Phi> w x y z ; z ; -(z\\<^sup>\\<smile>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> w x y z ; - (y ; y\\<^sup>\\<smile> \\<cdot> z ; z\\<^sup>\\<smile>) =\n    \\<Phi> w x y z ; y ; - y\\<^sup>\\<smile> +\n    \\<Phi> w x y z ; z ; - z\\<^sup>\\<smile>", "by (metis compl_inf assms(2) ss43iii dp_map1 dp_map2 mult.assoc distrib_left)"], ["proof (state)\nthis:\n  \\<Phi> w x y z ; - (y ; y\\<^sup>\\<smile> \\<cdot> z ; z\\<^sup>\\<smile>) =\n  \\<Phi> w x y z ; y ; - y\\<^sup>\\<smile> +\n  \\<Phi> w x y z ; z ; - z\\<^sup>\\<smile>\n\ngoal (1 subgoal):\n 1. is_map (\\<Phi> w x y z)", "also"], ["proof (state)\nthis:\n  \\<Phi> w x y z ; - (y ; y\\<^sup>\\<smile> \\<cdot> z ; z\\<^sup>\\<smile>) =\n  \\<Phi> w x y z ; y ; - y\\<^sup>\\<smile> +\n  \\<Phi> w x y z ; z ; - z\\<^sup>\\<smile>\n\ngoal (1 subgoal):\n 1. is_map (\\<Phi> w x y z)", "have \"... = w ; -(y\\<^sup>\\<smile>) + x ; -(z\\<^sup>\\<smile>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> w x y z ; y ; - y\\<^sup>\\<smile> +\n    \\<Phi> w x y z ; z ; - z\\<^sup>\\<smile> =\n    w ; - y\\<^sup>\\<smile> + x ; - z\\<^sup>\\<smile>", "by (metis assms mono_dp_1 mono_dp_2)"], ["proof (state)\nthis:\n  \\<Phi> w x y z ; y ; - y\\<^sup>\\<smile> +\n  \\<Phi> w x y z ; z ; - z\\<^sup>\\<smile> =\n  w ; - y\\<^sup>\\<smile> + x ; - z\\<^sup>\\<smile>\n\ngoal (1 subgoal):\n 1. is_map (\\<Phi> w x y z)", "also"], ["proof (state)\nthis:\n  \\<Phi> w x y z ; y ; - y\\<^sup>\\<smile> +\n  \\<Phi> w x y z ; z ; - z\\<^sup>\\<smile> =\n  w ; - y\\<^sup>\\<smile> + x ; - z\\<^sup>\\<smile>\n\ngoal (1 subgoal):\n 1. is_map (\\<Phi> w x y z)", "have \"... = -(w ; y\\<^sup>\\<smile>) + -(x ; z\\<^sup>\\<smile>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w ; - y\\<^sup>\\<smile> + x ; - z\\<^sup>\\<smile> =\n    - (w ; y\\<^sup>\\<smile>) + - (x ; z\\<^sup>\\<smile>)", "by (metis assms(1) ss43iii dp_map1 dp_map2)"], ["proof (state)\nthis:\n  w ; - y\\<^sup>\\<smile> + x ; - z\\<^sup>\\<smile> =\n  - (w ; y\\<^sup>\\<smile>) + - (x ; z\\<^sup>\\<smile>)\n\ngoal (1 subgoal):\n 1. is_map (\\<Phi> w x y z)", "also"], ["proof (state)\nthis:\n  w ; - y\\<^sup>\\<smile> + x ; - z\\<^sup>\\<smile> =\n  - (w ; y\\<^sup>\\<smile>) + - (x ; z\\<^sup>\\<smile>)\n\ngoal (1 subgoal):\n 1. is_map (\\<Phi> w x y z)", "have \"... = -(\\<Phi> w x y z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (w ; y\\<^sup>\\<smile>) + - (x ; z\\<^sup>\\<smile>) = - \\<Phi> w x y z", "by (metis compl_inf Phi_def)"], ["proof (state)\nthis:\n  - (w ; y\\<^sup>\\<smile>) + - (x ; z\\<^sup>\\<smile>) = - \\<Phi> w x y z\n\ngoal (1 subgoal):\n 1. is_map (\\<Phi> w x y z)", "finally"], ["proof (chain)\npicking this:\n  \\<Phi> w x y z ; - 1' = - \\<Phi> w x y z", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Phi> w x y z ; - 1' = - \\<Phi> w x y z\n\ngoal (1 subgoal):\n 1. is_map (\\<Phi> w x y z)", "by (metis is_maprop)"], ["proof (state)\nthis:\n  is_map (\\<Phi> w x y z)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Phi_inj:\n  assumes \"is_direct_product w x\"\n    and \"is_direct_product y z\"\n  shows \"is_inj (\\<Phi> w x y z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_inj (\\<Phi> w x y z)", "by (metis Phi_def Phi_conv Phi_map assms inj_p_fun is_map_def)"], ["", "text \\<open>Next we show that the converse of @{const Phi} is an injective\nfunction.\\<close>"], ["", "lemma Phi_conv_map:\n  assumes \"is_direct_product w x\"\n    and \"is_direct_product y z\"\n  shows \"is_map ((\\<Phi> w x y z)\\<^sup>\\<smile>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_map ((\\<Phi> w x y z)\\<^sup>\\<smile>)", "by (metis Phi_conv Phi_def Phi_map assms)"], ["", "lemma Phi_conv_inj:\n  assumes \"is_direct_product w x\"\n    and \"is_direct_product y z\"\n  shows \"is_inj ((\\<Phi> w x y z)\\<^sup>\\<smile>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_inj ((\\<Phi> w x y z)\\<^sup>\\<smile>)", "by (metis Phi_inj Phi_conv Phi_def assms)"], ["", "lemma Phi_sur:\n  assumes \"is_direct_product w x\"\n  and \"is_direct_product y z\"\n  shows \"is_sur (\\<Phi> w x y z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_sur (\\<Phi> w x y z)", "by (metis assms Phi_conv Phi_def Phi_map is_map_def sur_total)"], ["", "lemma Phi_conv_sur:\n  assumes \"is_direct_product w x\"\n    and \"is_direct_product y z\"\n  shows \"is_sur ((\\<Phi> w x y z)\\<^sup>\\<smile>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_sur ((\\<Phi> w x y z)\\<^sup>\\<smile>)", "by (metis assms Phi_conv Phi_def Phi_sur)"], ["", "lemma Phi_bij:\n  assumes \"is_direct_product w x\"\n    and \"is_direct_product y z\"\n  shows \"is_bij (\\<Phi> w x y z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_bij (\\<Phi> w x y z)", "by (metis assms Phi_inj Phi_map Phi_sur is_bij_def)"], ["", "lemma Phi_conv_bij:\n  assumes \"is_direct_product w x\"\n    and \"is_direct_product y z\"\n  shows \"is_bij ((\\<Phi> w x y z)\\<^sup>\\<smile>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_bij ((\\<Phi> w x y z)\\<^sup>\\<smile>)", "by (metis Phi_bij Phi_def Phi_conv assms)"], ["", "text \\<open>Next we construct, for given functions~@{term f} and~@{term g}, a\nfunction~@{term F} which makes the standard product diagram commute, and we\nverify these commutation properties.\\<close>"], ["", "definition F :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\"\n  where \"F \\<equiv> (\\<lambda>f x g y. f ; x\\<^sup>\\<smile> \\<cdot> g ; y\\<^sup>\\<smile>)\""], ["", "lemma f_proj:\n  assumes \"is_direct_product x y\"\n  and \"is_map g\"\n  shows \"F f x g y ; x = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F f x g y ; x = f", "by (metis assms dp_aux4 F_def is_map_def is_direct_product_def dp_p_fun1)"], ["", "lemma g_proj:\n  assumes \"is_direct_product x y\"\n  and \"is_map f\"\n  shows \"F f x g y ; y = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F f x g y ; y = g", "by (metis assms dp_aux1 F_def is_map_def is_direct_product_def dp_p_fun2)"], ["", "text \\<open>Finally we show uniqueness of~@{const F}, hence universality of the\nconstruction.\\<close>"], ["", "lemma\n  assumes \"is_direct_product x y\"\n  and \"is_map f\"\n  and \"is_map g\"\n  and \"is_map G\"\n  and \"f = G ; x\"\n  and \"g = G ; y\"\n  shows \"G = F f x g y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G = F f x g y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. G = F f x g y", "have \"F f x g y = G ; (x ; x\\<^sup>\\<smile>) \\<cdot> G ; (y ; y\\<^sup>\\<smile>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F f x g y =\n    G ; (x ; x\\<^sup>\\<smile>) \\<cdot> G ; (y ; y\\<^sup>\\<smile>)", "by (metis assms(5) assms(6) F_def mult.assoc)"], ["proof (state)\nthis:\n  F f x g y = G ; (x ; x\\<^sup>\\<smile>) \\<cdot> G ; (y ; y\\<^sup>\\<smile>)\n\ngoal (1 subgoal):\n 1. G = F f x g y", "also"], ["proof (state)\nthis:\n  F f x g y = G ; (x ; x\\<^sup>\\<smile>) \\<cdot> G ; (y ; y\\<^sup>\\<smile>)\n\ngoal (1 subgoal):\n 1. G = F f x g y", "have \"\\<dots> = G ; (x ; x\\<^sup>\\<smile> \\<cdot> y ; y\\<^sup>\\<smile>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G ; (x ; x\\<^sup>\\<smile>) \\<cdot> G ; (y ; y\\<^sup>\\<smile>) =\n    G ; (x ; x\\<^sup>\\<smile> \\<cdot> y ; y\\<^sup>\\<smile>)", "by (metis assms(4) map_distl)"], ["proof (state)\nthis:\n  G ; (x ; x\\<^sup>\\<smile>) \\<cdot> G ; (y ; y\\<^sup>\\<smile>) =\n  G ; (x ; x\\<^sup>\\<smile> \\<cdot> y ; y\\<^sup>\\<smile>)\n\ngoal (1 subgoal):\n 1. G = F f x g y", "thus ?thesis"], ["proof (prove)\nusing this:\n  G ; (x ; x\\<^sup>\\<smile>) \\<cdot> G ; (y ; y\\<^sup>\\<smile>) =\n  G ; (x ; x\\<^sup>\\<smile> \\<cdot> y ; y\\<^sup>\\<smile>)\n\ngoal (1 subgoal):\n 1. G = F f x g y", "by (metis assms(1) is_direct_product_def calculation mult.right_neutral)"], ["proof (state)\nthis:\n  G = F f x g y\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* relation_algebra *)"], ["", "end"]]}