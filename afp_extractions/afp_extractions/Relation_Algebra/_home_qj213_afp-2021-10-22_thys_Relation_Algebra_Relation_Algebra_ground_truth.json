{"file_name": "/home/qj213/afp-2021-10-22/thys/Relation_Algebra/Relation_Algebra.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Relation_Algebra", "problem_names": ["lemma meet_interchange: \"(w \\<cdot> x) ; (y \\<cdot> z) \\<le> w ; y \\<cdot> x ; z\"", "lemma join_interchange: \"w ; x + y ; z \\<le> (w + y) ; (x + z)\"", "lemma conv_iso: \"x \\<le> y \\<longleftrightarrow> x\\<^sup>\\<smile> \\<le> y\\<^sup>\\<smile>\"", "lemma conv_zero [simp]: \"0\\<^sup>\\<smile> = 0\"", "lemma conv_one [simp]: \"1\\<^sup>\\<smile> = 1\"", "lemma conv_compl_aux: \"(-x)\\<^sup>\\<smile> = (-x)\\<^sup>\\<smile> + (-x\\<^sup>\\<smile>)\"", "lemma conv_compl: \"(-x)\\<^sup>\\<smile> = -(x\\<^sup>\\<smile>)\"", "lemma comp_res_aux [simp]: \"x\\<^sup>\\<smile> ; -(x ; y) \\<cdot> y = 0\"", "lemma conv_e [simp]: \"1'\\<^sup>\\<smile> = 1'\"", "lemma conv_times [simp]: \"(x \\<cdot> y)\\<^sup>\\<smile> = x\\<^sup>\\<smile> \\<cdot> y\\<^sup>\\<smile>\"", "lemma conv_self_conjugate: \"x\\<^sup>\\<smile> \\<cdot> y = 0 \\<longleftrightarrow> x \\<cdot> y\\<^sup>\\<smile> = 0\"", "lemma conv_self_conjugate_var: \"is_conjugation converse converse\"", "lemma one_idem_mult [simp]: \"1 ; 1 = 1\"", "lemma mult_subdistl: \"x ; (y \\<cdot> z) \\<le> x ; y\"", "lemma mult_subdistr: \"(x \\<cdot> y) ; z \\<le> x ; z\"", "lemma mult_subdistr_var: \"(x \\<cdot> y) ; z \\<le> x ; z \\<cdot> y ; z\"", "lemma peirce_1: \"x ; y \\<cdot> z\\<^sup>\\<smile> = 0 \\<Longrightarrow> y ; z \\<cdot> x\\<^sup>\\<smile> = 0\"", "lemma peirce: \"x ; y \\<cdot> z\\<^sup>\\<smile> = 0 \\<longleftrightarrow> y ; z \\<cdot> x\\<^sup>\\<smile> = 0\"", "lemma schroeder_1: \"x ; y \\<cdot> z = 0 \\<longleftrightarrow> y \\<cdot> x\\<^sup>\\<smile> ; z = 0\"", "lemma schroeder_2: \"y ; x \\<cdot> z = 0 \\<longleftrightarrow> y \\<cdot> z ; x\\<^sup>\\<smile> = 0\"", "lemma schroeder_1_var: \"is_conjugation (composition x) (composition (x\\<^sup>\\<smile>))\"", "lemma schroeder_2_var: \"is_conjugation (\\<lambda>x. x ; y) (\\<lambda>x. x ; y\\<^sup>\\<smile>)\"", "lemma conv_galois_1: \"x ; y \\<le> z \\<longleftrightarrow> y \\<le> -(x\\<^sup>\\<smile> ; -z)\"", "lemma conv_galois_2: \"y ; x \\<le> z \\<longleftrightarrow> y \\<le> -(-z ; x\\<^sup>\\<smile>)\"", "lemma modular_1_aux': \"x ; (y \\<cdot> -(x\\<^sup>\\<smile> ; z)) \\<cdot> z = 0\"", "lemma modular_2_aux': \"(y \\<cdot> -(z ; x\\<^sup>\\<smile>)) ; x \\<cdot> z = 0\"", "lemma modular_1': \"x ; y \\<cdot> z = x ; (y \\<cdot> x\\<^sup>\\<smile> ; z) \\<cdot> z\"", "lemma modular_2': \"y ; x \\<cdot> z = (y \\<cdot> z ; x\\<^sup>\\<smile>) ; x \\<cdot> z\"", "lemma modular_1_var: \"x ; y \\<cdot> z \\<le> x ; (y \\<cdot> x\\<^sup>\\<smile> ; z)\"", "lemma modular_2_var: \"x ; y \\<cdot> z \\<le> (x \\<cdot> z ; y\\<^sup>\\<smile>) ; y\"", "lemma modular_var_2: \"x ; y \\<le> x ; (y \\<cdot> x\\<^sup>\\<smile> ; 1)\"", "lemma modular_var_3: \"x ; y \\<le> (x \\<cdot> 1 ; y\\<^sup>\\<smile>) ; y\"", "lemma dedekind: \"x ; y \\<cdot> z \\<le> (x \\<cdot> z ; y\\<^sup>\\<smile>) ; (y \\<cdot> x\\<^sup>\\<smile> ; z)\"", "lemma dedekind_var_1: \"x ; y \\<le> (x \\<cdot> 1 ; y\\<^sup>\\<smile>) ; (y \\<cdot> x\\<^sup>\\<smile> ; 1)\"", "lemma ra_1: \"(x \\<cdot> y ; 1) ; z = x ; z \\<cdot> y ; 1\"", "lemma ra_2: \"x ; (z \\<cdot> y ; 1) = (x \\<cdot> (y ; 1)\\<^sup>\\<smile>) ; z\"", "lemma one_conv: \"1' \\<cdot> x ; 1 = 1' \\<cdot> x ; x\\<^sup>\\<smile>\"", "lemma maddux_12: \"-(y ; x) ; x\\<^sup>\\<smile> \\<le> -y\"", "lemma maddux_141: \"x ; y \\<cdot> z = 0 \\<longleftrightarrow> x\\<^sup>\\<smile> ; z \\<cdot> y = 0\"", "lemma maddux_142: \"x\\<^sup>\\<smile> ; z \\<cdot> y = 0 \\<longleftrightarrow> z ; y\\<^sup>\\<smile> \\<cdot> x = 0\"", "lemmas maddux_16 = modular_1_var", "lemmas maddux_17 = modular_2_var", "lemma maddux_20: \"x \\<le> x ; 1\"", "lemma maddux_21: \"x \\<le> 1 ; x\"", "lemma maddux_23: \"x ; y \\<cdot> -(x ; z) = x ; (y \\<cdot> -z) \\<cdot> -(x ; z)\"", "lemma maddux_24: \"-(x ; y) + x ; z = -(x ; (y \\<cdot> -z)) + x ; z\"", "lemma one_compl: \"-(x ; 1) ; 1 = -(x ; 1)\"", "lemma ss_p18: \"x ; 1 = 0 \\<longleftrightarrow> x = 0\""], "translations": [["", "lemma meet_interchange: \"(w \\<cdot> x) ; (y \\<cdot> z) \\<le> w ; y \\<cdot> x ; z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w \\<cdot> x) ; (y \\<cdot> z) \\<le> w ; y \\<cdot> x ; z", "by (metis inf_le1 inf_le2 le_infI mult_isol_var)"], ["", "lemma join_interchange: \"w ; x + y ; z \\<le> (w + y) ; (x + z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w ; x + y ; z \\<le> (w + y) ; (x + z)", "using local.mult_isol_var local.sup.bounded_iff local.sup.cobounded2 local.sup_ge1"], ["proof (prove)\nusing this:\n  \\<lbrakk>?u \\<le> ?x; ?v \\<le> ?y\\<rbrakk>\n  \\<Longrightarrow> ?u ; ?v \\<le> ?x ; ?y\n  (?b + ?c \\<le> ?a) = (?b \\<le> ?a \\<and> ?c \\<le> ?a)\n  ?b \\<le> ?a + ?b\n  ?x \\<le> ?x + ?y\n\ngoal (1 subgoal):\n 1. w ; x + y ; z \\<le> (w + y) ; (x + z)", "by presburger"], ["", "text \\<open>We now prove some simple facts about conversion.\\<close>"], ["", "lemma conv_iso: \"x \\<le> y \\<longleftrightarrow> x\\<^sup>\\<smile> \\<le> y\\<^sup>\\<smile>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> y) = (x\\<^sup>\\<smile> \\<le> y\\<^sup>\\<smile>)", "by (metis conv_add conv_invol le_iff_sup)"], ["", "lemma conv_zero [simp]: \"0\\<^sup>\\<smile> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sup>\\<smile> = 0", "by (metis conv_add conv_invol sup_bot_right sup_eq_bot_iff)"], ["", "lemma conv_one [simp]: \"1\\<^sup>\\<smile> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sup>\\<smile> = 1", "by (metis conv_add conv_invol sup_top_left sup_top_right)"], ["", "lemma conv_compl_aux: \"(-x)\\<^sup>\\<smile> = (-x)\\<^sup>\\<smile> + (-x\\<^sup>\\<smile>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- x)\\<^sup>\\<smile> = (- x)\\<^sup>\\<smile> + - x\\<^sup>\\<smile>", "by (metis aux9 conv_add conv_one double_compl galois_aux4 inf.commute less_eq_def sup.commute sup_top_left)"], ["", "lemma conv_compl: \"(-x)\\<^sup>\\<smile> = -(x\\<^sup>\\<smile>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- x)\\<^sup>\\<smile> = - x\\<^sup>\\<smile>", "by (metis add_commute conv_add conv_compl_aux conv_invol)"], ["", "lemma comp_res_aux [simp]: \"x\\<^sup>\\<smile> ; -(x ; y) \\<cdot> y = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<smile> ; - (x ; y) \\<cdot> y = 0", "by (metis comp_res galois_aux)"], ["", "lemma conv_e [simp]: \"1'\\<^sup>\\<smile> = 1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1'\\<^sup>\\<smile> = 1'", "by (metis comp_unitr conv_contrav conv_invol)"], ["", "lemma conv_times [simp]: \"(x \\<cdot> y)\\<^sup>\\<smile> = x\\<^sup>\\<smile> \\<cdot> y\\<^sup>\\<smile>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<cdot> y)\\<^sup>\\<smile> = x\\<^sup>\\<smile> \\<cdot> y\\<^sup>\\<smile>", "by (metis compl_inf double_compl conv_add conv_compl)"], ["", "text \\<open>The next lemmas show that conversion is self-conjugate in the sense of\nBoolean algebra with operators.\\<close>"], ["", "lemma conv_self_conjugate: \"x\\<^sup>\\<smile> \\<cdot> y = 0 \\<longleftrightarrow> x \\<cdot> y\\<^sup>\\<smile> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<smile> \\<cdot> y = 0) = (x \\<cdot> y\\<^sup>\\<smile> = 0)", "by (metis conv_invol conv_times conv_zero)"], ["", "lemma conv_self_conjugate_var: \"is_conjugation converse converse\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_conjugation relation_algebra_class.converse\n     relation_algebra_class.converse", "by (metis conv_self_conjugate is_conjugation_def)"], ["", "text \\<open>The following lemmas link the relative product and meet.\\<close>"], ["", "lemma one_idem_mult [simp]: \"1 ; 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 ; 1 = 1", "by (metis compl_eq_compl_iff galois_aux2 inf.commute inf_top_right mult_1_left mult_isor top_greatest)"], ["", "lemma mult_subdistl: \"x ; (y \\<cdot> z) \\<le> x ; y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; (y \\<cdot> z) \\<le> x ; y", "by (metis inf_le1 mult_isol)"], ["", "lemma mult_subdistr: \"(x \\<cdot> y) ; z \\<le> x ; z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<cdot> y) ; z \\<le> x ; z", "by (metis inf_le1 mult_isor)"], ["", "lemma mult_subdistr_var: \"(x \\<cdot> y) ; z \\<le> x ; z \\<cdot> y ; z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<cdot> y) ; z \\<le> x ; z \\<cdot> y ; z", "by (metis inf.commute le_inf_iff mult_subdistr)"], ["", "text \\<open>The following lemmas deal with variants of the Peirce law, the\nSchr\\\"oder laws and the Dedekind law. Some of them are obtained from Boolean\nalgebras with operators by instantiation, using conjugation properties.\nHowever, Isabelle does not always pick up this relationship.\\<close>"], ["", "lemma peirce_1: \"x ; y \\<cdot> z\\<^sup>\\<smile> = 0 \\<Longrightarrow> y ; z \\<cdot> x\\<^sup>\\<smile> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; y \\<cdot> z\\<^sup>\\<smile> = 0 \\<Longrightarrow>\n    y ; z \\<cdot> x\\<^sup>\\<smile> = 0", "by (metis compl_le_swap1 conv_contrav conv_self_conjugate galois_aux comp_res conv_invol galois_aux mult_isol order_trans)"], ["", "lemma peirce: \"x ; y \\<cdot> z\\<^sup>\\<smile> = 0 \\<longleftrightarrow> y ; z \\<cdot> x\\<^sup>\\<smile> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x ; y \\<cdot> z\\<^sup>\\<smile> = 0) =\n    (y ; z \\<cdot> x\\<^sup>\\<smile> = 0)", "by (metis peirce_1)"], ["", "lemma schroeder_1: \"x ; y \\<cdot> z = 0 \\<longleftrightarrow> y \\<cdot> x\\<^sup>\\<smile> ; z = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x ; y \\<cdot> z = 0) = (y \\<cdot> x\\<^sup>\\<smile> ; z = 0)", "by (metis conv_invol peirce conv_contrav conv_invol conv_self_conjugate inf.commute)"], ["", "lemma schroeder_2: \"y ; x \\<cdot> z = 0 \\<longleftrightarrow> y \\<cdot> z ; x\\<^sup>\\<smile> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y ; x \\<cdot> z = 0) = (y \\<cdot> z ; x\\<^sup>\\<smile> = 0)", "by (metis conv_invol peirce schroeder_1)"], ["", "text \\<open>The following two conjugation properties between multiplication with\nelements and their converses are used for deriving modular laws of relation\nalgebra from those of Boolean algebras with operators.\\<close>"], ["", "lemma schroeder_1_var: \"is_conjugation (composition x) (composition (x\\<^sup>\\<smile>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_conjugation ((;) x) ((;) (x\\<^sup>\\<smile>))", "by (metis schroeder_1 is_conjugation_def)"], ["", "lemma schroeder_2_var: \"is_conjugation (\\<lambda>x. x ; y) (\\<lambda>x. x ; y\\<^sup>\\<smile>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_conjugation (\\<lambda>x. x ; y) (\\<lambda>x. x ; y\\<^sup>\\<smile>)", "by (unfold is_conjugation_def, metis schroeder_2)"], ["", "text \\<open>The following Galois connections define residuals. They link relation\nalgebras with action algebras. This could be further explored and formalised.\n\\<close>"], ["", "lemma conv_galois_1: \"x ; y \\<le> z \\<longleftrightarrow> y \\<le> -(x\\<^sup>\\<smile> ; -z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x ; y \\<le> z) = (y \\<le> - (x\\<^sup>\\<smile> ; - z))", "by (metis galois_aux galois_aux2 schroeder_1)"], ["", "lemma conv_galois_2: \"y ; x \\<le> z \\<longleftrightarrow> y \\<le> -(-z ; x\\<^sup>\\<smile>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y ; x \\<le> z) = (y \\<le> - (- z ; x\\<^sup>\\<smile>))", "by (metis galois_aux galois_aux2 schroeder_2)"], ["", "text \\<open>Variants of the modular law for relation algebras can now be\ninstantiated from Boolean algebras with operators.\\<close>"], ["", "lemma modular_1_aux': \"x ; (y \\<cdot> -(x\\<^sup>\\<smile> ; z)) \\<cdot> z = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; (y \\<cdot> - (x\\<^sup>\\<smile> ; z)) \\<cdot> z = 0", "by (metis schroeder_1_var modular_1_aux)"], ["", "lemma modular_2_aux': \"(y \\<cdot> -(z ; x\\<^sup>\\<smile>)) ; x \\<cdot> z = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y \\<cdot> - (z ; x\\<^sup>\\<smile>)) ; x \\<cdot> z = 0", "by (metis modular_1_aux schroeder_2_var)"], ["", "lemma modular_1': \"x ; y \\<cdot> z = x ; (y \\<cdot> x\\<^sup>\\<smile> ; z) \\<cdot> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; y \\<cdot> z = x ; (y \\<cdot> x\\<^sup>\\<smile> ; z) \\<cdot> z", "by (metis schroeder_1_var modular_1)"], ["", "lemma modular_2': \"y ; x \\<cdot> z = (y \\<cdot> z ; x\\<^sup>\\<smile>) ; x \\<cdot> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y ; x \\<cdot> z = (y \\<cdot> z ; x\\<^sup>\\<smile>) ; x \\<cdot> z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. y ; x \\<cdot> z = (y \\<cdot> z ; x\\<^sup>\\<smile>) ; x \\<cdot> z", "have \"y ; x \\<cdot> z = (y \\<cdot> z ; x\\<^sup>\\<smile>) ; x \\<cdot> z + (y \\<cdot> -(z ; x\\<^sup>\\<smile>)) ; x \\<cdot> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y ; x \\<cdot> z =\n    (y \\<cdot> z ; x\\<^sup>\\<smile>) ; x \\<cdot> z +\n    (y \\<cdot> - (z ; x\\<^sup>\\<smile>)) ; x \\<cdot> z", "by (metis aux4 distrib_right inf.commute inf_sup_distrib1)"], ["proof (state)\nthis:\n  y ; x \\<cdot> z =\n  (y \\<cdot> z ; x\\<^sup>\\<smile>) ; x \\<cdot> z +\n  (y \\<cdot> - (z ; x\\<^sup>\\<smile>)) ; x \\<cdot> z\n\ngoal (1 subgoal):\n 1. y ; x \\<cdot> z = (y \\<cdot> z ; x\\<^sup>\\<smile>) ; x \\<cdot> z", "thus ?thesis"], ["proof (prove)\nusing this:\n  y ; x \\<cdot> z =\n  (y \\<cdot> z ; x\\<^sup>\\<smile>) ; x \\<cdot> z +\n  (y \\<cdot> - (z ; x\\<^sup>\\<smile>)) ; x \\<cdot> z\n\ngoal (1 subgoal):\n 1. y ; x \\<cdot> z = (y \\<cdot> z ; x\\<^sup>\\<smile>) ; x \\<cdot> z", "by (metis sup_bot_right modular_2_aux')"], ["proof (state)\nthis:\n  y ; x \\<cdot> z = (y \\<cdot> z ; x\\<^sup>\\<smile>) ; x \\<cdot> z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma modular_1_var: \"x ; y \\<cdot> z \\<le> x ; (y \\<cdot> x\\<^sup>\\<smile> ; z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; y \\<cdot> z \\<le> x ; (y \\<cdot> x\\<^sup>\\<smile> ; z)", "by (metis inf.commute inf_le2 modular_1')"], ["", "lemma modular_2_var: \"x ; y \\<cdot> z \\<le> (x \\<cdot> z ; y\\<^sup>\\<smile>) ; y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; y \\<cdot> z \\<le> (x \\<cdot> z ; y\\<^sup>\\<smile>) ; y", "by (metis inf.commute inf_le2 modular_2')"], ["", "lemma modular_var_2: \"x ; y \\<le> x ; (y \\<cdot> x\\<^sup>\\<smile> ; 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; y \\<le> x ; (y \\<cdot> x\\<^sup>\\<smile> ; 1)", "by (metis inf_top_right modular_1_var)"], ["", "lemma modular_var_3: \"x ; y \\<le> (x \\<cdot> 1 ; y\\<^sup>\\<smile>) ; y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; y \\<le> (x \\<cdot> 1 ; y\\<^sup>\\<smile>) ; y", "by (metis inf_top_right modular_2_var)"], ["", "text \\<open>The modular laws are used to prove the Dedekind rule.\\<close>"], ["", "lemma dedekind: \"x ; y \\<cdot> z \\<le> (x \\<cdot> z ; y\\<^sup>\\<smile>) ; (y \\<cdot> x\\<^sup>\\<smile> ; z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; y \\<cdot> z\n    \\<le> (x \\<cdot> z ; y\\<^sup>\\<smile>) ;\n          (y \\<cdot> x\\<^sup>\\<smile> ; z)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x ; y \\<cdot> z\n    \\<le> (x \\<cdot> z ; y\\<^sup>\\<smile>) ;\n          (y \\<cdot> x\\<^sup>\\<smile> ; z)", "have \"x ; y \\<cdot> z \\<le> (x \\<cdot> z ; y\\<^sup>\\<smile>) ; (y \\<cdot> ((x \\<cdot> z ; y\\<^sup>\\<smile>)\\<^sup>\\<smile> ; z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; y \\<cdot> z\n    \\<le> (x \\<cdot> z ; y\\<^sup>\\<smile>) ;\n          (y \\<cdot> (x \\<cdot> z ; y\\<^sup>\\<smile>)\\<^sup>\\<smile> ; z)", "by (metis modular_2' modular_1_var)"], ["proof (state)\nthis:\n  x ; y \\<cdot> z\n  \\<le> (x \\<cdot> z ; y\\<^sup>\\<smile>) ;\n        (y \\<cdot> (x \\<cdot> z ; y\\<^sup>\\<smile>)\\<^sup>\\<smile> ; z)\n\ngoal (1 subgoal):\n 1. x ; y \\<cdot> z\n    \\<le> (x \\<cdot> z ; y\\<^sup>\\<smile>) ;\n          (y \\<cdot> x\\<^sup>\\<smile> ; z)", "also"], ["proof (state)\nthis:\n  x ; y \\<cdot> z\n  \\<le> (x \\<cdot> z ; y\\<^sup>\\<smile>) ;\n        (y \\<cdot> (x \\<cdot> z ; y\\<^sup>\\<smile>)\\<^sup>\\<smile> ; z)\n\ngoal (1 subgoal):\n 1. x ; y \\<cdot> z\n    \\<le> (x \\<cdot> z ; y\\<^sup>\\<smile>) ;\n          (y \\<cdot> x\\<^sup>\\<smile> ; z)", "have \"\\<dots> \\<le> (x \\<cdot> z ; y\\<^sup>\\<smile>) ; (y \\<cdot> x\\<^sup>\\<smile> ; z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<cdot> z ; y\\<^sup>\\<smile>) ;\n    (y \\<cdot> (x \\<cdot> z ; y\\<^sup>\\<smile>)\\<^sup>\\<smile> ; z)\n    \\<le> (x \\<cdot> z ; y\\<^sup>\\<smile>) ;\n          (y \\<cdot> x\\<^sup>\\<smile> ; z)", "by (metis conv_iso inf_le1 inf_mono mult_isol mult_isor order_refl)"], ["proof (state)\nthis:\n  (x \\<cdot> z ; y\\<^sup>\\<smile>) ;\n  (y \\<cdot> (x \\<cdot> z ; y\\<^sup>\\<smile>)\\<^sup>\\<smile> ; z)\n  \\<le> (x \\<cdot> z ; y\\<^sup>\\<smile>) ; (y \\<cdot> x\\<^sup>\\<smile> ; z)\n\ngoal (1 subgoal):\n 1. x ; y \\<cdot> z\n    \\<le> (x \\<cdot> z ; y\\<^sup>\\<smile>) ;\n          (y \\<cdot> x\\<^sup>\\<smile> ; z)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (x \\<cdot> z ; y\\<^sup>\\<smile>) ;\n  (y \\<cdot> (x \\<cdot> z ; y\\<^sup>\\<smile>)\\<^sup>\\<smile> ; z)\n  \\<le> (x \\<cdot> z ; y\\<^sup>\\<smile>) ; (y \\<cdot> x\\<^sup>\\<smile> ; z)\n\ngoal (1 subgoal):\n 1. x ; y \\<cdot> z\n    \\<le> (x \\<cdot> z ; y\\<^sup>\\<smile>) ;\n          (y \\<cdot> x\\<^sup>\\<smile> ; z)", "by (metis calculation order_trans)"], ["proof (state)\nthis:\n  x ; y \\<cdot> z\n  \\<le> (x \\<cdot> z ; y\\<^sup>\\<smile>) ; (y \\<cdot> x\\<^sup>\\<smile> ; z)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dedekind_var_1: \"x ; y \\<le> (x \\<cdot> 1 ; y\\<^sup>\\<smile>) ; (y \\<cdot> x\\<^sup>\\<smile> ; 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; y\n    \\<le> (x \\<cdot> 1 ; y\\<^sup>\\<smile>) ;\n          (y \\<cdot> x\\<^sup>\\<smile> ; 1)", "by (metis dedekind inf.commute inf_top_left)"], ["", "end"], ["", "(* relation_algebra *)"], ["", "text \\<open>The Schr\\\"oder laws allow us, finally, to prove the annihilation laws\nfor zero. We formalise this by proving that relation algebras form dioids with\nzero.\\<close>"], ["", "sublocale relation_algebra < dioid_one_zero \"(+)\" \"(;)\" \"1'\" 0 \"(\\<le>)\" \"(<)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.dioid_one_zero (+) (;) 1' 0 (\\<le>) (<)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. 0 + x = x\n 2. \\<And>x. 0 ; x = 0\n 3. \\<And>x. x ; 0 = 0", "fix x :: 'a"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. 0 + x = x\n 2. \\<And>x. 0 ; x = 0\n 3. \\<And>x. x ; 0 = 0", "show \"0 + x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 + x = x", "by (fact sup_bot_left)"], ["proof (state)\nthis:\n  0 + x = x\n\ngoal (2 subgoals):\n 1. \\<And>x. 0 ; x = 0\n 2. \\<And>x. x ; 0 = 0", "show \"0 ; x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 ; x = 0", "by (metis f_strict schroeder_2_var)"], ["proof (state)\nthis:\n  0 ; x = 0\n\ngoal (1 subgoal):\n 1. \\<And>x. x ; 0 = 0", "show \"x ; 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; 0 = 0", "by (metis f_strict schroeder_1_var)"], ["proof (state)\nthis:\n  x ; 0 = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "context relation_algebra\nbegin"], ["", "text \\<open>Next we prove miscellaneous properties which we found in the books of\nMaddux and Schmidt and Str\\\"ohlein. Most of them do not carry any meaningful\nnames.\\<close>"], ["", "lemma ra_1: \"(x \\<cdot> y ; 1) ; z = x ; z \\<cdot> y ; 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<cdot> y ; 1) ; z = x ; z \\<cdot> y ; 1", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. (x \\<cdot> y ; 1) ; z \\<le> x ; z \\<cdot> y ; 1\n 2. x ; z \\<cdot> y ; 1 \\<le> (x \\<cdot> y ; 1) ; z", "show \"x ; z \\<cdot> y ; 1 \\<le> (x \\<cdot> y ; 1) ; z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; z \\<cdot> y ; 1 \\<le> (x \\<cdot> y ; 1) ; z", "by (metis modular_2_var comp_assoc order_trans eq_refl inf_mono inf_top_left mult_isor mult_subdistl)"], ["proof (state)\nthis:\n  x ; z \\<cdot> y ; 1 \\<le> (x \\<cdot> y ; 1) ; z\n\ngoal (1 subgoal):\n 1. (x \\<cdot> y ; 1) ; z \\<le> x ; z \\<cdot> y ; 1", "show \"(x \\<cdot> y ; 1) ; z \\<le> x ; z \\<cdot> y ; 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<cdot> y ; 1) ; z \\<le> x ; z \\<cdot> y ; 1", "by (metis inf.commute inf_greatest inf_top_left mult.assoc mult_subdistl mult_subdistr order_trans)"], ["proof (state)\nthis:\n  (x \\<cdot> y ; 1) ; z \\<le> x ; z \\<cdot> y ; 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ra_2: \"x ; (z \\<cdot> y ; 1) = (x \\<cdot> (y ; 1)\\<^sup>\\<smile>) ; z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; (z \\<cdot> y ; 1) = (x \\<cdot> (y ; 1)\\<^sup>\\<smile>) ; z", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. x ; (z \\<cdot> y ; 1) \\<le> (x \\<cdot> (y ; 1)\\<^sup>\\<smile>) ; z\n 2. (x \\<cdot> (y ; 1)\\<^sup>\\<smile>) ; z \\<le> x ; (z \\<cdot> y ; 1)", "have \"(x \\<cdot> 1 ; (z \\<cdot> y ; 1)\\<^sup>\\<smile>) ; z \\<le> (x \\<cdot> (y ; 1)\\<^sup>\\<smile>) ; z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<cdot> 1 ; (z \\<cdot> y ; 1)\\<^sup>\\<smile>) ; z\n    \\<le> (x \\<cdot> (y ; 1)\\<^sup>\\<smile>) ; z", "by (metis conv_contrav conv_invol conv_one conv_times inf.idem inf.left_commute le_iff_inf meet_assoc mult_isor ra_1)"], ["proof (state)\nthis:\n  (x \\<cdot> 1 ; (z \\<cdot> y ; 1)\\<^sup>\\<smile>) ; z\n  \\<le> (x \\<cdot> (y ; 1)\\<^sup>\\<smile>) ; z\n\ngoal (2 subgoals):\n 1. x ; (z \\<cdot> y ; 1) \\<le> (x \\<cdot> (y ; 1)\\<^sup>\\<smile>) ; z\n 2. (x \\<cdot> (y ; 1)\\<^sup>\\<smile>) ; z \\<le> x ; (z \\<cdot> y ; 1)", "thus \"x ; (z \\<cdot> y ; 1) \\<le> (x \\<cdot> (y ; 1)\\<^sup>\\<smile>) ; z\""], ["proof (prove)\nusing this:\n  (x \\<cdot> 1 ; (z \\<cdot> y ; 1)\\<^sup>\\<smile>) ; z\n  \\<le> (x \\<cdot> (y ; 1)\\<^sup>\\<smile>) ; z\n\ngoal (1 subgoal):\n 1. x ; (z \\<cdot> y ; 1) \\<le> (x \\<cdot> (y ; 1)\\<^sup>\\<smile>) ; z", "by (metis modular_var_3 mult_subdistl order_trans)"], ["proof (state)\nthis:\n  x ; (z \\<cdot> y ; 1) \\<le> (x \\<cdot> (y ; 1)\\<^sup>\\<smile>) ; z\n\ngoal (1 subgoal):\n 1. (x \\<cdot> (y ; 1)\\<^sup>\\<smile>) ; z \\<le> x ; (z \\<cdot> y ; 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (x \\<cdot> (y ; 1)\\<^sup>\\<smile>) ; z \\<le> x ; (z \\<cdot> y ; 1)", "have \"x ; (z \\<cdot> ((x \\<cdot> (y ; 1)\\<^sup>\\<smile>)\\<^sup>\\<smile> ; 1)) \\<le> x ; (z \\<cdot> y ; 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; (z \\<cdot> (x \\<cdot> (y ; 1)\\<^sup>\\<smile>)\\<^sup>\\<smile> ; 1)\n    \\<le> x ; (z \\<cdot> y ; 1)", "by (metis conv_invol conv_times eq_refl inf_le2 inf_mono mult.assoc mult_isol mult_isor one_idem_mult)"], ["proof (state)\nthis:\n  x ; (z \\<cdot> (x \\<cdot> (y ; 1)\\<^sup>\\<smile>)\\<^sup>\\<smile> ; 1)\n  \\<le> x ; (z \\<cdot> y ; 1)\n\ngoal (1 subgoal):\n 1. (x \\<cdot> (y ; 1)\\<^sup>\\<smile>) ; z \\<le> x ; (z \\<cdot> y ; 1)", "thus \"x ; (z \\<cdot> y ; 1) \\<ge> (x \\<cdot> (y ; 1)\\<^sup>\\<smile>) ; z\""], ["proof (prove)\nusing this:\n  x ; (z \\<cdot> (x \\<cdot> (y ; 1)\\<^sup>\\<smile>)\\<^sup>\\<smile> ; 1)\n  \\<le> x ; (z \\<cdot> y ; 1)\n\ngoal (1 subgoal):\n 1. (x \\<cdot> (y ; 1)\\<^sup>\\<smile>) ; z \\<le> x ; (z \\<cdot> y ; 1)", "by (metis modular_var_2 mult_subdistr order_trans)"], ["proof (state)\nthis:\n  (x \\<cdot> (y ; 1)\\<^sup>\\<smile>) ; z \\<le> x ; (z \\<cdot> y ; 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma one_conv: \"1' \\<cdot> x ; 1 = 1' \\<cdot> x ; x\\<^sup>\\<smile>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1' \\<cdot> x ; 1 = 1' \\<cdot> x ; x\\<^sup>\\<smile>", "by (metis inf.commute inf_top_left modular_1' mult.right_neutral)"], ["", "lemma maddux_12: \"-(y ; x) ; x\\<^sup>\\<smile> \\<le> -y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (y ; x) ; x\\<^sup>\\<smile> \\<le> - y", "by (metis galois_aux inf.commute inf_compl_bot schroeder_2)"], ["", "lemma maddux_141: \"x ; y \\<cdot> z = 0 \\<longleftrightarrow> x\\<^sup>\\<smile> ; z \\<cdot> y = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x ; y \\<cdot> z = 0) = (x\\<^sup>\\<smile> ; z \\<cdot> y = 0)", "by (metis inf.commute schroeder_1)"], ["", "lemma maddux_142: \"x\\<^sup>\\<smile> ; z \\<cdot> y = 0 \\<longleftrightarrow> z ; y\\<^sup>\\<smile> \\<cdot> x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<smile> ; z \\<cdot> y = 0) =\n    (z ; y\\<^sup>\\<smile> \\<cdot> x = 0)", "by (metis inf.commute schroeder_1 schroeder_2)"], ["", "lemmas maddux_16 = modular_1_var"], ["", "lemmas maddux_17 = modular_2_var"], ["", "lemma maddux_20: \"x \\<le> x ; 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> x ; 1", "by (metis inf_top_left mult.right_neutral mult_subdistl)"], ["", "lemma maddux_21: \"x \\<le> 1 ; x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> 1 ; x", "by (metis mult_isor mult_onel top_greatest)"], ["", "lemma maddux_23: \"x ; y \\<cdot> -(x ; z) = x ; (y \\<cdot> -z) \\<cdot> -(x ; z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; y \\<cdot> - (x ; z) = x ; (y \\<cdot> - z) \\<cdot> - (x ; z)", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x ; y \\<cdot> - (x ; z) \\<le> x ; (y \\<cdot> - z) \\<cdot> - (x ; z)\n 2. x ; (y \\<cdot> - z) \\<cdot> - (x ; z) \\<le> x ; y \\<cdot> - (x ; z)", "apply (metis local.aux6 local.aux6_var local.aux9 local.compl_inf_bot local.compl_sup_top local.compl_unique local.distrib_left local.galois_2 local.sup_ge2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x ; (y \\<cdot> - z) \\<cdot> - (x ; z) \\<le> x ; y \\<cdot> - (x ; z)", "using local.meet_iso local.mult_subdistl"], ["proof (prove)\nusing this:\n  ?x \\<le> ?y \\<Longrightarrow> ?x \\<cdot> ?z \\<le> ?y \\<cdot> ?z\n  ?x ; (?y \\<cdot> ?z) \\<le> ?x ; ?y\n\ngoal (1 subgoal):\n 1. x ; (y \\<cdot> - z) \\<cdot> - (x ; z) \\<le> x ; y \\<cdot> - (x ; z)", "by blast"], ["", "lemma maddux_24: \"-(x ; y) + x ; z = -(x ; (y \\<cdot> -z)) + x ; z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (x ; y) + x ; z = - (x ; (y \\<cdot> - z)) + x ; z", "by (metis de_morgan_3 double_compl maddux_23)"], ["", "lemma one_compl: \"-(x ; 1) ; 1 = -(x ; 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (x ; 1) ; 1 = - (x ; 1)", "by (metis antisym conv_one maddux_12 mult.assoc one_idem_mult maddux_20)"], ["", "lemma ss_p18: \"x ; 1 = 0 \\<longleftrightarrow> x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x ; 1 = 0) = (x = 0)", "by (metis annil le_bot maddux_20)"], ["", "end"], ["", "(* relation_algebra *)"], ["", "text \\<open>This finishes our development of the basic laws of relation algebras.\nThe next sections are devoted to special elements such as vectors, test or\nsubidentities, and, in particular, functions.\\<close>"], ["", "end"]]}