{"file_name": "/home/qj213/afp-2021-10-22/thys/Algebraic_VCs/AVC_KAD/VC_KAD_dual_Examples.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Algebraic_VCs", "problem_names": ["lemma euclid:\n  \"FPRE (\\<lambda>s::nat store. s ''x'' = x \\<and> s ''y'' = y)\n   (WHILE (\\<lambda>s. s ''y'' \\<noteq> 0) INV (\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y) \n    DO\n     (''z'' ::= (\\<lambda>s. s ''y''));\n     (''y'' ::= (\\<lambda>s. s ''x'' mod s ''y''));\n     (''x'' ::= (\\<lambda>s. s ''z''))\n    OD)\n   POST (\\<lambda>s. s ''x'' = gcd x y)\"", "lemma euclid_diff: \n   \"FPRE (\\<lambda>s::nat store. s ''x'' = x \\<and> s ''y'' = y \\<and> x > 0 \\<and> y > 0)\n    (WHILE (\\<lambda>s. s ''x''\\<noteq> s ''y'') INV (\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y) \n     DO\n        (IF (\\<lambda>s. s ''x'' >  s ''y'')\n         THEN (''x'' ::= (\\<lambda>s. s ''x'' - s ''y''))\n         ELSE (''y'' ::= (\\<lambda>s. s ''y'' - s ''x''))\n         FI)\n    OD)\n    POST (\\<lambda>s. s ''x'' = gcd x y)\"", "lemma varible_swap:\n  \"FPRE (\\<lambda>s. s ''x'' = a \\<and> s ''y'' = b)   \n    (''z'' ::= (\\<lambda>s. s ''x''));\n    (''x'' ::= (\\<lambda>s. s ''y''));\n    (''y'' ::= (\\<lambda>s. s ''z''))\n   POST (\\<lambda>s. s ''x'' = b \\<and> s ''y'' = a)\"", "lemma maximum: \n  \"FPRE (\\<lambda>s:: nat store. True) \n   (IF (\\<lambda>s. s ''x'' \\<ge> s ''y'') \n    THEN (''z'' ::= (\\<lambda>s. s ''x''))\n    ELSE (''z'' ::= (\\<lambda>s. s ''y''))\n    FI)\n   POST (\\<lambda>s. s ''z'' = max (s ''x'') (s ''y''))\"", "lemma integer_division: \n  \"FPRE (\\<lambda>s::nat store. x \\<ge> 0)\n    (''q'' ::= (\\<lambda>s. 0)); \n    (''r'' ::= (\\<lambda>s. x));\n    (WHILE (\\<lambda>s. y \\<le> s ''r'') INV (\\<lambda>s. x = s ''q'' * y + s ''r'' \\<and> s ''r'' \\<ge> 0)\n     DO\n      (''q'' ::= (\\<lambda>s. s ''q'' + 1));\n      (''r'' ::= (\\<lambda>s. s ''r'' - y))\n      OD)\n   POST (\\<lambda>s. x = s ''q'' * y + s ''r'' \\<and> s ''r'' \\<ge> 0 \\<and> s ''r'' < y)\"", "lemma factorial:\n  \"FPRE (\\<lambda>s::nat store. True)\n   (''x'' ::= (\\<lambda>s. 0));\n   (''y'' ::= (\\<lambda>s. 1));\n   (WHILE (\\<lambda>s. s ''x'' \\<noteq> x0) INV (\\<lambda>s. s ''y'' = fact (s ''x''))\n   DO\n     (''x'' ::= (\\<lambda>s. s ''x'' + 1));\n     (''y'' ::= (\\<lambda>s. s ''y'' \\<cdot> s ''x''))\n   OD)\n   POST (\\<lambda>s. s ''y'' = fact x0)\"", "lemma my_power:\n  \"FPRE (\\<lambda>s::nat store. True)\n   (''i'' ::= (\\<lambda>s. 0));\n   (''y'' ::= (\\<lambda>s. 1));\n   (WHILE (\\<lambda>s. s ''i'' < n) INV (\\<lambda>s. s ''y'' = x ^ (s ''i'') \\<and> s ''i'' \\<le> n)\n     DO\n       (''y'' ::= (\\<lambda>s. (s ''y'') * x));\n       (''i'' ::= (\\<lambda>s. s ''i'' + 1))\n     OD)\n   POST (\\<lambda>s. s ''y'' = x ^ n)\"", "lemma imp_reverse:\n  \"FPRE (\\<lambda>s:: 'a list store. s ''x'' = X)\n   (''y'' ::= (\\<lambda>s. []));\n   (WHILE (\\<lambda>s. s ''x'' \\<noteq> []) INV (\\<lambda>s. rev (s ''x'') @ s ''y'' = rev X)\n    DO \n     (''y'' ::= (\\<lambda>s. hd (s ''x'') # s ''y'')); \n     (''x'' ::= (\\<lambda>s. tl (s ''x'')))\n    OD) \n   POST (\\<lambda>s. s ''y''= rev X )\""], "translations": [["", "lemma euclid:\n  \"FPRE (\\<lambda>s::nat store. s ''x'' = x \\<and> s ''y'' = y)\n   (WHILE (\\<lambda>s. s ''y'' \\<noteq> 0) INV (\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y) \n    DO\n     (''z'' ::= (\\<lambda>s. s ''y''));\n     (''y'' ::= (\\<lambda>s. s ''x'' mod s ''y''));\n     (''x'' ::= (\\<lambda>s. s ''z''))\n    OD)\n   POST (\\<lambda>s. s ''x'' = gcd x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_antirange_kleene_algebra.bdia\n     (WHILE (\\<lambda>s.\n                s ''y'' \\<noteq>\n                0) INV (\\<lambda>s.\n                           gcd (s ''x'') (s ''y'') =\n                           gcd x\n                            y) DO (''z'' ::= (\\<lambda>s. s ''y'')) ;\n                                  (''y'' ::= (\\<lambda>s.\n           s ''x'' mod s ''y'')) ;\n                                  (''x'' ::= (\\<lambda>s. s ''z'')) OD)\n     \\<lceil>\\<lambda>s. s ''x'' = x \\<and> s ''y'' = y\\<rceil>\n    \\<subseteq> rel_antirange_kleene_algebra.ars_r\n                 \\<lceil>\\<lambda>s. s ''x'' = gcd x y\\<rceil>", "by (rule rel_modal_kleene_algebra.bdia_whilei, auto simp: gcd_non_0_nat)"], ["", "lemma euclid_diff: \n   \"FPRE (\\<lambda>s::nat store. s ''x'' = x \\<and> s ''y'' = y \\<and> x > 0 \\<and> y > 0)\n    (WHILE (\\<lambda>s. s ''x''\\<noteq> s ''y'') INV (\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y) \n     DO\n        (IF (\\<lambda>s. s ''x'' >  s ''y'')\n         THEN (''x'' ::= (\\<lambda>s. s ''x'' - s ''y''))\n         ELSE (''y'' ::= (\\<lambda>s. s ''y'' - s ''x''))\n         FI)\n    OD)\n    POST (\\<lambda>s. s ''x'' = gcd x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_antirange_kleene_algebra.bdia\n     (WHILE (\\<lambda>s.\n                s ''x'' \\<noteq>\n                s ''y'') INV (\\<lambda>s.\n                                 gcd (s ''x'') (s ''y'') =\n                                 gcd x\n                                  y) DO (IF (\\<lambda>s.\n          s ''y''\n          < s ''x'') THEN (''x'' ::= (\\<lambda>s.\n   s ''x'' -\n   s ''y'')) ELSE (''y'' ::= (\\<lambda>s. s ''y'' - s ''x'')) FI) OD)\n     \\<lceil>\\<lambda>s.\n                s ''x'' = x \\<and>\n                s ''y'' = y \\<and> 0 < x \\<and> 0 < y\\<rceil>\n    \\<subseteq> rel_antirange_kleene_algebra.ars_r\n                 \\<lceil>\\<lambda>s. s ''x'' = gcd x y\\<rceil>", "apply (rule rel_modal_kleene_algebra.bdia_whilei, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>s.\n       gcd (s ''x'') (s ''y'') = gcd x y \\<and>\n       s ''x'' = s ''y'' \\<longrightarrow>\n       s ''y'' = gcd x y\n 2. \\<forall>s.\n       ((\\<exists>w.\n            s ''x'' = w - s ''y'' \\<and>\n            s ''y'' < w \\<and>\n            w \\<noteq> s ''y'' \\<and>\n            gcd w (s ''y'') = gcd x y) \\<longrightarrow>\n        gcd (s ''x'') (s ''y'') = gcd x y) \\<and>\n       ((\\<exists>w.\n            s ''y'' = w - s ''x'' \\<and>\n            \\<not> w < s ''x'' \\<and>\n            s ''x'' \\<noteq> w \\<and>\n            gcd (s ''x'') w = gcd x y) \\<longrightarrow>\n        gcd (s ''x'') (s ''y'') = gcd x y)", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s.\n       ((\\<exists>w.\n            s ''x'' = w - s ''y'' \\<and>\n            s ''y'' < w \\<and>\n            w \\<noteq> s ''y'' \\<and>\n            gcd w (s ''y'') = gcd x y) \\<longrightarrow>\n        gcd (s ''x'') (s ''y'') = gcd x y) \\<and>\n       ((\\<exists>w.\n            s ''y'' = w - s ''x'' \\<and>\n            \\<not> w < s ''x'' \\<and>\n            s ''x'' \\<noteq> w \\<and>\n            gcd (s ''x'') w = gcd x y) \\<longrightarrow>\n        gcd (s ''x'') (s ''y'') = gcd x y)", "by (metis gcd.commute gcd_diff1_nat le_cases nat_less_le)"], ["", "lemma varible_swap:\n  \"FPRE (\\<lambda>s. s ''x'' = a \\<and> s ''y'' = b)   \n    (''z'' ::= (\\<lambda>s. s ''x''));\n    (''x'' ::= (\\<lambda>s. s ''y''));\n    (''y'' ::= (\\<lambda>s. s ''z''))\n   POST (\\<lambda>s. s ''x'' = b \\<and> s ''y'' = a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_antirange_kleene_algebra.bdia\n     ((''z'' ::= (\\<lambda>s. s ''x'')) ;\n      (''x'' ::= (\\<lambda>s. s ''y'')) ;\n      (''y'' ::= (\\<lambda>s. s ''z'')))\n     \\<lceil>\\<lambda>s. s ''x'' = a \\<and> s ''y'' = b\\<rceil>\n    \\<subseteq> rel_antirange_kleene_algebra.ars_r\n                 \\<lceil>\\<lambda>s. s ''x'' = b \\<and> s ''y'' = a\\<rceil>", "by simp"], ["", "lemma maximum: \n  \"FPRE (\\<lambda>s:: nat store. True) \n   (IF (\\<lambda>s. s ''x'' \\<ge> s ''y'') \n    THEN (''z'' ::= (\\<lambda>s. s ''x''))\n    ELSE (''z'' ::= (\\<lambda>s. s ''y''))\n    FI)\n   POST (\\<lambda>s. s ''z'' = max (s ''x'') (s ''y''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_antirange_kleene_algebra.bdia\n     (IF (\\<lambda>s.\n             s ''y''\n             \\<le> s ''x'') THEN (''z'' ::= (\\<lambda>s.\n          s ''x'')) ELSE (''z'' ::= (\\<lambda>s. s ''y'')) FI)\n     \\<lceil>\\<lambda>s. True\\<rceil>\n    \\<subseteq> rel_antirange_kleene_algebra.ars_r\n                 \\<lceil>\\<lambda>s.\n                            s ''z'' = max (s ''x'') (s ''y'')\\<rceil>", "by auto"], ["", "lemma integer_division: \n  \"FPRE (\\<lambda>s::nat store. x \\<ge> 0)\n    (''q'' ::= (\\<lambda>s. 0)); \n    (''r'' ::= (\\<lambda>s. x));\n    (WHILE (\\<lambda>s. y \\<le> s ''r'') INV (\\<lambda>s. x = s ''q'' * y + s ''r'' \\<and> s ''r'' \\<ge> 0)\n     DO\n      (''q'' ::= (\\<lambda>s. s ''q'' + 1));\n      (''r'' ::= (\\<lambda>s. s ''r'' - y))\n      OD)\n   POST (\\<lambda>s. x = s ''q'' * y + s ''r'' \\<and> s ''r'' \\<ge> 0 \\<and> s ''r'' < y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_antirange_kleene_algebra.bdia\n     ((''q'' ::= (\\<lambda>s. 0)) ; (''r'' ::= (\\<lambda>s. x)) ;\n      (WHILE (\\<lambda>s.\n                 y \\<le> s ''r'') INV (\\<lambda>s.\n    x = s ''q'' \\<cdot> y + s ''r'' \\<and>\n    0 \\<le> s ''r'') DO (''q'' ::= (\\<lambda>s. s ''q'' + 1)) ;\n                        (''r'' ::= (\\<lambda>s. s ''r'' - y)) OD))\n     \\<lceil>\\<lambda>s. 0 \\<le> x\\<rceil>\n    \\<subseteq> rel_antirange_kleene_algebra.ars_r\n                 \\<lceil>\\<lambda>s.\n                            x = s ''q'' \\<cdot> y + s ''r'' \\<and>\n                            0 \\<le> s ''r'' \\<and> s ''r'' < y\\<rceil>", "by (rule rel_modal_kleene_algebra.bdia_whilei_break, simp_all, auto simp: p2r_def)"], ["", "lemma factorial:\n  \"FPRE (\\<lambda>s::nat store. True)\n   (''x'' ::= (\\<lambda>s. 0));\n   (''y'' ::= (\\<lambda>s. 1));\n   (WHILE (\\<lambda>s. s ''x'' \\<noteq> x0) INV (\\<lambda>s. s ''y'' = fact (s ''x''))\n   DO\n     (''x'' ::= (\\<lambda>s. s ''x'' + 1));\n     (''y'' ::= (\\<lambda>s. s ''y'' \\<cdot> s ''x''))\n   OD)\n   POST (\\<lambda>s. s ''y'' = fact x0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_antirange_kleene_algebra.bdia\n     ((''x'' ::= (\\<lambda>s. 0)) ; (''y'' ::= (\\<lambda>s. 1)) ;\n      (WHILE (\\<lambda>s.\n                 s ''x'' \\<noteq>\n                 x0) INV (\\<lambda>s.\n                             s ''y'' =\n                             fact\n                              (s ''x'')) DO (''x'' ::= (\\<lambda>s.\n                     s ''x'' + 1)) ;\n      (''y'' ::= (\\<lambda>s. s ''y'' \\<cdot> s ''x'')) OD))\n     \\<lceil>\\<lambda>s. True\\<rceil>\n    \\<subseteq> rel_antirange_kleene_algebra.ars_r\n                 \\<lceil>\\<lambda>s. s ''y'' = fact x0\\<rceil>", "by (rule rel_modal_kleene_algebra.bdia_whilei_break, simp_all, auto simp: p2r_def)"], ["", "lemma my_power:\n  \"FPRE (\\<lambda>s::nat store. True)\n   (''i'' ::= (\\<lambda>s. 0));\n   (''y'' ::= (\\<lambda>s. 1));\n   (WHILE (\\<lambda>s. s ''i'' < n) INV (\\<lambda>s. s ''y'' = x ^ (s ''i'') \\<and> s ''i'' \\<le> n)\n     DO\n       (''y'' ::= (\\<lambda>s. (s ''y'') * x));\n       (''i'' ::= (\\<lambda>s. s ''i'' + 1))\n     OD)\n   POST (\\<lambda>s. s ''y'' = x ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_antirange_kleene_algebra.bdia\n     ((''i'' ::= (\\<lambda>s. 0)) ; (''y'' ::= (\\<lambda>s. 1)) ;\n      (WHILE (\\<lambda>s.\n                 s ''i''\n                 < n) INV (\\<lambda>s.\n                              s ''y'' = x ^ s ''i'' \\<and>\n                              s ''i''\n                              \\<le> n) DO (''y'' ::= (\\<lambda>s.\n                   s ''y'' \\<cdot> x)) ;\n    (''i'' ::= (\\<lambda>s. s ''i'' + 1)) OD))\n     \\<lceil>\\<lambda>s. True\\<rceil>\n    \\<subseteq> rel_antirange_kleene_algebra.ars_r\n                 \\<lceil>\\<lambda>s. s ''y'' = x ^ n\\<rceil>", "by (rule rel_modal_kleene_algebra.bdia_whilei_break, simp_all, auto simp add: p2r_def)"], ["", "lemma imp_reverse:\n  \"FPRE (\\<lambda>s:: 'a list store. s ''x'' = X)\n   (''y'' ::= (\\<lambda>s. []));\n   (WHILE (\\<lambda>s. s ''x'' \\<noteq> []) INV (\\<lambda>s. rev (s ''x'') @ s ''y'' = rev X)\n    DO \n     (''y'' ::= (\\<lambda>s. hd (s ''x'') # s ''y'')); \n     (''x'' ::= (\\<lambda>s. tl (s ''x'')))\n    OD) \n   POST (\\<lambda>s. s ''y''= rev X )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_antirange_kleene_algebra.bdia\n     ((''y'' ::= (\\<lambda>s. [])) ;\n      (WHILE (\\<lambda>s.\n                 s ''x'' \\<noteq>\n                 []) INV (\\<lambda>s.\n                             rev (s ''x'') @ s ''y'' =\n                             rev X) DO (''y'' ::= (\\<lambda>s.\n                hd (s ''x'') # s ''y'')) ;\n (''x'' ::= (\\<lambda>s. tl (s ''x''))) OD))\n     \\<lceil>\\<lambda>s. s ''x'' = X\\<rceil>\n    \\<subseteq> rel_antirange_kleene_algebra.ars_r\n                 \\<lceil>\\<lambda>s. s ''y'' = rev X\\<rceil>", "apply (rule rel_modal_kleene_algebra.bdia_whilei_break, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>s.\n       rev (s ''x'') @ s ''y'' = rev X \\<and> s ''x'' = [] \\<longrightarrow>\n       s ''y'' = rev X\n 2. \\<forall>s.\n       (\\<exists>w.\n           s ''x'' = tl w \\<and>\n           (\\<exists>wa.\n               s ''y'' = hd w # wa \\<and>\n               w \\<noteq> [] \\<and> rev w @ wa = rev X)) \\<longrightarrow>\n       rev (s ''x'') @ s ''y'' = rev X", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s.\n       (\\<exists>w.\n           s ''x'' = tl w \\<and>\n           (\\<exists>wa.\n               s ''y'' = hd w # wa \\<and>\n               w \\<noteq> [] \\<and> rev w @ wa = rev X)) \\<longrightarrow>\n       rev (s ''x'') @ s ''y'' = rev X", "by (safe, metis append.simps append_assoc hd_Cons_tl rev.simps(2))"], ["", "end"]]}