{"file_name": "/home/qj213/afp-2021-10-22/thys/Algebraic_VCs/AVC_KAD/Path_Model_Example.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Algebraic_VCs", "problem_names": ["lemma pp_a_neg [simp]: \"pp_a (p2pp Q) = p2pp (-Q)\"", "lemma ppath_assign [simp]: \"ppath_aka.fbox (v ::= e) (p2pp Q) = p2pp (\\<lambda>s. Q (s(v := e s)))\"", "lemma [simp]: \"p2pp P \\<union> p2pp Q = p2pp (P \\<squnion> Q)\"", "lemma [simp]: \"p2pp P; p2pp Q = p2pp (P \\<sqinter> Q)\"", "lemma [intro!]:  \"P \\<le> Q \\<Longrightarrow> \\<lceil>P\\<rceil> \\<subseteq> \\<lceil>Q\\<rceil>\"", "lemma [simp]: \"rdom \\<lceil>P\\<rceil> = \\<lceil>P\\<rceil>\"", "lemma euclid:\n  \"PRE (\\<lambda>s::nat store. s ''x'' = x \\<and> s ''y'' = y)\n   (WHILE (\\<lambda>s. s ''y'' \\<noteq> 0) INV (\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y) \n    DO\n     (''z'' ::= (\\<lambda>s. s ''y''));\n     (''y'' ::= (\\<lambda>s. s ''x'' mod s ''y''));\n     (''x'' ::= (\\<lambda>s. s ''z''))\n    OD)\n   POST (\\<lambda>s. s ''x'' = gcd x y)\"", "lemma euclid_diff: \n   \"PRE (\\<lambda>s::nat store. s ''x'' = x \\<and> s ''y'' = y \\<and> x > 0 \\<and> y > 0)\n    (WHILE (\\<lambda>s. s ''x''\\<noteq> s ''y'') INV (\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y) \n     DO\n        (IF (\\<lambda>s. s ''x'' >  s ''y'')\n         THEN (''x'' ::= (\\<lambda>s. s ''x'' - s ''y''))\n         ELSE (''y'' ::= (\\<lambda>s. s ''y'' - s ''x''))\n         FI)\n    OD)\n    POST (\\<lambda>s. s ''x'' = gcd x y)\"", "lemma varible_swap:\n  \"PRE (\\<lambda>s. s ''x'' = a \\<and> s ''y'' = b)   \n    (''z'' ::= (\\<lambda>s. s ''x''));\n    (''x'' ::= (\\<lambda>s. s ''y''));\n    (''y'' ::= (\\<lambda>s. s ''z''))\n   POST (\\<lambda>s. s ''x'' = b \\<and> s ''y'' = a)\"", "lemma maximum: \n  \"PRE (\\<lambda>s:: nat store. True) \n   (IF (\\<lambda>s. s ''x'' \\<ge> s ''y'') \n    THEN (''z'' ::= (\\<lambda>s. s ''x''))\n    ELSE (''z'' ::= (\\<lambda>s. s ''y''))\n    FI)\n   POST (\\<lambda>s. s ''z'' = max (s ''x'') (s ''y''))\"", "lemma integer_division: \n  \"PRE (\\<lambda>s::nat store. x \\<ge> 0)\n    (''q'' ::= (\\<lambda>s. 0)); \n    (''r'' ::= (\\<lambda>s. x));\n    (WHILE (\\<lambda>s. y \\<le> s ''r'') INV (\\<lambda>s. x = s ''q'' * y + s ''r'' \\<and> s ''r'' \\<ge> 0)\n     DO\n      (''q'' ::= (\\<lambda>s. s ''q'' + 1));\n      (''r'' ::= (\\<lambda>s. s ''r'' - y))\n      OD)\n   POST (\\<lambda>s. x = s ''q'' * y + s ''r'' \\<and> s ''r'' \\<ge> 0 \\<and> s ''r'' < y)\"", "lemma euclid2:\n  \"PRE (\\<lambda>s::nat store. s ''x'' = x \\<and> s ''y'' = y)\n   (WHILE (\\<lambda>s. s ''y'' \\<noteq> 0) INV (\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y) \n    DO\n     (''z'' ::= (\\<lambda>s. s ''y''));\n     (''y'' ::= (\\<lambda>s. s ''x'' mod s ''y''));\n     (''x'' ::= (\\<lambda>s. s ''z''))\n    OD)\n   POST (\\<lambda>s. s ''x'' = gcd x y)\"", "lemma euclid_diff2: \n   \"PRE (\\<lambda>s::nat store. s ''x'' = x \\<and> s ''y'' = y \\<and> x > 0 \\<and> y > 0)\n    (WHILE (\\<lambda>s. s ''x''\\<noteq> s ''y'') INV (\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y) \n     DO\n        (IF (\\<lambda>s. s ''x'' >  s ''y'')\n         THEN (''x'' ::= (\\<lambda>s. s ''x'' - s ''y''))\n         ELSE (''y'' ::= (\\<lambda>s. s ''y'' - s ''x''))\n         FI)\n    OD)\n    POST (\\<lambda>s. s ''x'' = gcd x y)\"", "lemma varible_swap2:\n  \"PRE (\\<lambda>s. s ''x'' = a \\<and> s ''y'' = b)   \n    (''z'' ::= (\\<lambda>s. s ''x''));\n    (''x'' ::= (\\<lambda>s. s ''y''));\n    (''y'' ::= (\\<lambda>s. s ''z''))\n   POST (\\<lambda>s. s ''x'' = b \\<and> s ''y'' = a)\"", "lemma maximum2: \n  \"PRE (\\<lambda>s:: nat store. True) \n   (IF (\\<lambda>s. s ''x'' \\<ge> s ''y'') \n    THEN (''z'' ::= (\\<lambda>s. s ''x''))\n    ELSE (''z'' ::= (\\<lambda>s. s ''y''))\n    FI)\n   POST (\\<lambda>s. s ''z'' = max (s ''x'') (s ''y''))\"", "lemma integer_division2: \n  \"PRE (\\<lambda>s::nat store. x \\<ge> 0)\n    (''q'' ::= (\\<lambda>s. 0)); \n    (''r'' ::= (\\<lambda>s. x));\n    (WHILE (\\<lambda>s. y \\<le> s ''r'') INV (\\<lambda>s. x = s ''q'' * y + s ''r'' \\<and> s ''r'' \\<ge> 0)\n     DO\n      (''q'' ::= (\\<lambda>s. s ''q'' + 1));\n      (''r'' ::= (\\<lambda>s. s ''r'' - y))\n      OD)\n   POST (\\<lambda>s. x = s ''q'' * y + s ''r'' \\<and> s ''r'' \\<ge> 0 \\<and> s ''r'' < y)\"", "lemma my_power2:\n  \"PRE (\\<lambda>s::nat store. True)\n   (''i'' ::= (\\<lambda>s. 0));\n   (''y'' ::= (\\<lambda>s. 1));\n   (WHILE (\\<lambda>s. s ''i'' < n) INV (\\<lambda>s. s ''y'' = x ^ (s ''i'') \\<and> s ''i'' \\<le> n)\n     DO\n       (''y'' ::= (\\<lambda>s. (s ''y'') * x));\n       (''i'' ::= (\\<lambda>s. s ''i'' + 1))\n     OD)\n   POST (\\<lambda>s. s ''y'' = x ^ n)\"", "lemma imp_reverse2:\n  \"PRE (\\<lambda>s:: 'a list store. s ''x'' = X)\n   (''y'' ::= (\\<lambda>s. []));\n   (WHILE (\\<lambda>s. s ''x'' \\<noteq> []) INV (\\<lambda>s. rev (s ''x'') @ s ''y'' = rev X)\n    DO \n     (''y'' ::= (\\<lambda>s. hd (s ''x'') # s ''y'')); \n     (''x'' ::= (\\<lambda>s. tl (s ''x'')))\n    OD) \n   POST (\\<lambda>s. s ''y''= rev X )\""], "translations": [["", "lemma pp_a_neg [simp]: \"pp_a (p2pp Q) = p2pp (-Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp_a (p2pp Q) = p2pp (- Q)", "by (force simp add: pp_a_def p2pp_def)"], ["", "lemma ppath_assign [simp]: \"ppath_aka.fbox (v ::= e) (p2pp Q) = p2pp (\\<lambda>s. Q (s(v := e s)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ppath_aka.fbox (v ::= e) (p2pp Q) = p2pp (\\<lambda>s. Q (s(v := e s)))", "by (force simp: ppath_aka.fbox_def pp_a_def p2pp_def pp_prod_def pp_gets_def)"], ["", "no_notation spec_sugar (\"PRE _ _ POST _\" [64,64,64] 63)\n   and relcomp (infixl \";\" 70)\n   and cond_sugar (\"IF _ THEN _ ELSE _ FI\" [64,64,64] 63)\n   and whilei_sugar (\"WHILE _ INV _ DO _ OD\" [64,64,64] 63)\n   and gets (\"_ ::= _\" [70, 65] 61)\n   and rel_antidomain_kleene_algebra.fbox (\"wp\")\n   and rel_antidomain_kleene_algebra.ads_d (\"rdom\")\n   and p2r (\"\\<lceil>_\\<rceil>\")"], ["", "notation ppath_aka.fbox (\"wp\")\n  and ppath_aka.ads_d (\"rdom\")\n  and p2pp (\"\\<lceil>_\\<rceil>\")\n  and pp_prod (infixl \";\" 70)"], ["", "abbreviation spec_sugar :: \"'a pred \\<Rightarrow> 'a ppath set \\<Rightarrow> 'a pred \\<Rightarrow> bool\" (\"PRE _ _ POST _\" [64,64,64] 63) where\n  \"PRE P X POST Q \\<equiv> rdom \\<lceil>P\\<rceil> \\<subseteq> wp X \\<lceil>Q\\<rceil>\""], ["", "abbreviation cond_sugar :: \"'a pred \\<Rightarrow> 'a ppath set \\<Rightarrow> 'a ppath set \\<Rightarrow> 'a ppath set\" (\"IF _ THEN _ ELSE _ FI\" [64,64,64] 63) where\n  \"IF P THEN X ELSE Y FI \\<equiv> ppath_aka.cond \\<lceil>P\\<rceil> X Y\""], ["", "abbreviation whilei_sugar :: \"'a pred \\<Rightarrow> 'a pred \\<Rightarrow> 'a ppath set \\<Rightarrow> 'a ppath set\" (\"WHILE _ INV _ DO _ OD\" [64,64,64] 63) where\n  \"WHILE P INV I DO X OD \\<equiv> ppath_aka.whilei \\<lceil>P\\<rceil> \\<lceil>I\\<rceil> X\""], ["", "lemma [simp]: \"p2pp P \\<union> p2pp Q = p2pp (P \\<squnion> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lceil>P\\<rceil> \\<union> \\<lceil>Q\\<rceil> =\n    \\<lceil>P \\<squnion> Q\\<rceil>", "by (force simp: p2pp_def)"], ["", "lemma [simp]: \"p2pp P; p2pp Q = p2pp (P \\<sqinter> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lceil>P\\<rceil> ; \\<lceil>Q\\<rceil> = \\<lceil>P \\<sqinter> Q\\<rceil>", "by (force simp: p2pp_def pp_prod_def)"], ["", "lemma [intro!]:  \"P \\<le> Q \\<Longrightarrow> \\<lceil>P\\<rceil> \\<subseteq> \\<lceil>Q\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<le> Q \\<Longrightarrow>\n    \\<lceil>P\\<rceil> \\<subseteq> \\<lceil>Q\\<rceil>", "by (force simp: p2pp_def)"], ["", "lemma [simp]: \"rdom \\<lceil>P\\<rceil> = \\<lceil>P\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rdom \\<lceil>P\\<rceil> = \\<lceil>P\\<rceil>", "by (simp add: ppath_aka.addual.ars_r_def)"], ["", "lemma euclid:\n  \"PRE (\\<lambda>s::nat store. s ''x'' = x \\<and> s ''y'' = y)\n   (WHILE (\\<lambda>s. s ''y'' \\<noteq> 0) INV (\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y) \n    DO\n     (''z'' ::= (\\<lambda>s. s ''y''));\n     (''y'' ::= (\\<lambda>s. s ''x'' mod s ''y''));\n     (''x'' ::= (\\<lambda>s. s ''z''))\n    OD)\n   POST (\\<lambda>s. s ''x'' = gcd x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rdom \\<lceil>\\<lambda>s. s ''x'' = x \\<and> s ''y'' = y\\<rceil>\n    \\<subseteq> wp (WHILE (\\<lambda>s.\n                              s ''y'' \\<noteq>\n                              zero_class.zero) INV (\\<lambda>s.\n                 gcd (s ''x'') (s ''y'') =\n                 gcd x\n                  y) DO (''z'' ::= (\\<lambda>s. s ''y'')) ;\n                        (''y'' ::= (\\<lambda>s. s ''x'' mod s ''y'')) ;\n                        (''x'' ::= (\\<lambda>s. s ''z'')) OD)\n                 \\<lceil>\\<lambda>s. s ''x'' = gcd x y\\<rceil>", "by (rule ppath_aka.fbox_whilei, simp_all, auto simp: p2pp_def rel_ad_def gcd_non_0_nat)"], ["", "lemma euclid_diff: \n   \"PRE (\\<lambda>s::nat store. s ''x'' = x \\<and> s ''y'' = y \\<and> x > 0 \\<and> y > 0)\n    (WHILE (\\<lambda>s. s ''x''\\<noteq> s ''y'') INV (\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y) \n     DO\n        (IF (\\<lambda>s. s ''x'' >  s ''y'')\n         THEN (''x'' ::= (\\<lambda>s. s ''x'' - s ''y''))\n         ELSE (''y'' ::= (\\<lambda>s. s ''y'' - s ''x''))\n         FI)\n    OD)\n    POST (\\<lambda>s. s ''x'' = gcd x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rdom\n     \\<lceil>\\<lambda>s.\n                s ''x'' = x \\<and>\n                s ''y'' = y \\<and>\n                zero_class.zero < x \\<and> zero_class.zero < y\\<rceil>\n    \\<subseteq> wp (WHILE (\\<lambda>s.\n                              s ''x'' \\<noteq>\n                              s ''y'') INV (\\<lambda>s.\n         gcd (s ''x'') (s ''y'') =\n         gcd x\n          y) DO (IF (\\<lambda>s.\n                        s ''y''\n                        < s ''x'') THEN (''x'' ::= (\\<lambda>s.\n                 s ''x'' -\n                 s ''y'')) ELSE (''y'' ::= (\\<lambda>s.\n         s ''y'' - s ''x'')) FI) OD)\n                 \\<lceil>\\<lambda>s. s ''x'' = gcd x y\\<rceil>", "apply (rule ppath_aka.fbox_whilei, simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lceil>\\<lambda>s.\n               s ''x'' = x \\<and>\n               s ''y'' = y \\<and>\n               zero_class.zero < x \\<and> zero_class.zero < y\\<rceil>\n    \\<subseteq> \\<lceil>\\<lambda>s.\n                           gcd (s ''x'') (s ''y'') = gcd x y\\<rceil>\n 2. \\<lceil>(\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y) \\<sqinter>\n            - (\\<lambda>s. s ''x'' \\<noteq> s ''y'')\\<rceil>\n    \\<subseteq> \\<lceil>\\<lambda>s. s ''x'' = gcd x y\\<rceil>\n 3. \\<lceil>(\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y) \\<sqinter>\n            (\\<lambda>s. s ''x'' \\<noteq> s ''y'')\\<rceil>\n    \\<subseteq> \\<lceil>(- (\\<lambda>s. s ''y'' < s ''x'') \\<squnion>\n                         (\\<lambda>s.\n                             gcd (s ''x'' - s ''y'') (s ''y'') =\n                             gcd x y)) \\<sqinter>\n                        ((\\<lambda>s. s ''y'' < s ''x'') \\<squnion>\n                         (\\<lambda>s.\n                             gcd (s ''x'') (s ''y'' - s ''x'') =\n                             gcd x y))\\<rceil>", "apply (simp_all add: p2pp_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. {Node s |s.\n     s ''x'' = x \\<and>\n     s ''y'' = y \\<and> zero_class.zero < x \\<and> zero_class.zero < y}\n    \\<subseteq> {Node s |s. gcd (s ''x'') (s ''y'') = gcd x y}\n 2. {Node s |s. gcd (s ''x'') (s ''y'') = gcd x y \\<and> s ''x'' = s ''y''}\n    \\<subseteq> {Node s |s. s ''x'' = gcd x y}\n 3. {Node s |s.\n     gcd (s ''x'') (s ''y'') = gcd x y \\<and> s ''x'' \\<noteq> s ''y''}\n    \\<subseteq> {Node s |s.\n                 (s ''y'' < s ''x'' \\<longrightarrow>\n                  gcd (s ''x'' - s ''y'') (s ''y'') = gcd x y) \\<and>\n                 (s ''y'' < s ''x'' \\<or>\n                  gcd (s ''x'') (s ''y'' - s ''x'') = gcd x y)}", "apply auto[2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. {Node s |s.\n     gcd (s ''x'') (s ''y'') = gcd x y \\<and> s ''x'' \\<noteq> s ''y''}\n    \\<subseteq> {Node s |s.\n                 (s ''y'' < s ''x'' \\<longrightarrow>\n                  gcd (s ''x'' - s ''y'') (s ''y'') = gcd x y) \\<and>\n                 (s ''y'' < s ''x'' \\<or>\n                  gcd (s ''x'') (s ''y'' - s ''x'') = gcd x y)}", "by (safe, metis gcd.commute gcd_diff1_nat le_cases nat_less_le)"], ["", "lemma varible_swap:\n  \"PRE (\\<lambda>s. s ''x'' = a \\<and> s ''y'' = b)   \n    (''z'' ::= (\\<lambda>s. s ''x''));\n    (''x'' ::= (\\<lambda>s. s ''y''));\n    (''y'' ::= (\\<lambda>s. s ''z''))\n   POST (\\<lambda>s. s ''x'' = b \\<and> s ''y'' = a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rdom \\<lceil>\\<lambda>s. s ''x'' = a \\<and> s ''y'' = b\\<rceil>\n    \\<subseteq> wp ((''z'' ::= (\\<lambda>s. s ''x'')) ;\n                    (''x'' ::= (\\<lambda>s. s ''y'')) ;\n                    (''y'' ::= (\\<lambda>s. s ''z'')))\n                 \\<lceil>\\<lambda>s. s ''x'' = b \\<and> s ''y'' = a\\<rceil>", "by auto"], ["", "lemma maximum: \n  \"PRE (\\<lambda>s:: nat store. True) \n   (IF (\\<lambda>s. s ''x'' \\<ge> s ''y'') \n    THEN (''z'' ::= (\\<lambda>s. s ''x''))\n    ELSE (''z'' ::= (\\<lambda>s. s ''y''))\n    FI)\n   POST (\\<lambda>s. s ''z'' = max (s ''x'') (s ''y''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rdom \\<lceil>\\<lambda>s. True\\<rceil>\n    \\<subseteq> wp (IF (\\<lambda>s.\n                           s ''y''\n                           \\<le> s ''x'') THEN (''z'' ::= (\\<lambda>s.\n                        s ''x'')) ELSE (''z'' ::= (\\<lambda>s. s ''y'')) FI)\n                 \\<lceil>\\<lambda>s.\n                            s ''z'' = max (s ''x'') (s ''y'')\\<rceil>", "by auto"], ["", "lemma integer_division: \n  \"PRE (\\<lambda>s::nat store. x \\<ge> 0)\n    (''q'' ::= (\\<lambda>s. 0)); \n    (''r'' ::= (\\<lambda>s. x));\n    (WHILE (\\<lambda>s. y \\<le> s ''r'') INV (\\<lambda>s. x = s ''q'' * y + s ''r'' \\<and> s ''r'' \\<ge> 0)\n     DO\n      (''q'' ::= (\\<lambda>s. s ''q'' + 1));\n      (''r'' ::= (\\<lambda>s. s ''r'' - y))\n      OD)\n   POST (\\<lambda>s. x = s ''q'' * y + s ''r'' \\<and> s ''r'' \\<ge> 0 \\<and> s ''r'' < y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rdom \\<lceil>\\<lambda>s. zero_class.zero \\<le> x\\<rceil>\n    \\<subseteq> wp ((''q'' ::= (\\<lambda>s. zero_class.zero)) ;\n                    (''r'' ::= (\\<lambda>s. x)) ;\n                    (WHILE (\\<lambda>s.\n                               y \\<le> s\n  ''r'') INV (\\<lambda>s.\n                 x = s ''q'' \\<cdot> y + s ''r'' \\<and>\n                 zero_class.zero\n                 \\<le> s ''r'') DO (''q'' ::= (\\<lambda>s. s ''q'' + 1)) ;\n                                   (''r'' ::= (\\<lambda>s.\n            s ''r'' - y)) OD))\n                 \\<lceil>\\<lambda>s.\n                            x = s ''q'' \\<cdot> y + s ''r'' \\<and>\n                            zero_class.zero \\<le> s ''r'' \\<and>\n                            s ''r'' < y\\<rceil>", "by (rule ppath_aka.fbox_whilei_break, auto)"], ["", "text \\<open>We now reconsider these examples with an Eisbach tactic.\\<close>"], ["", "named_theorems ht"], ["", "declare ppath_aka.fbox_whilei [ht]\n  ppath_aka.fbox_seq_var [ht]\n  subset_refl[ht]"], ["", "method hoare = (rule ht; hoare?)"], ["", "lemma euclid2:\n  \"PRE (\\<lambda>s::nat store. s ''x'' = x \\<and> s ''y'' = y)\n   (WHILE (\\<lambda>s. s ''y'' \\<noteq> 0) INV (\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y) \n    DO\n     (''z'' ::= (\\<lambda>s. s ''y''));\n     (''y'' ::= (\\<lambda>s. s ''x'' mod s ''y''));\n     (''x'' ::= (\\<lambda>s. s ''z''))\n    OD)\n   POST (\\<lambda>s. s ''x'' = gcd x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rdom \\<lceil>\\<lambda>s. s ''x'' = x \\<and> s ''y'' = y\\<rceil>\n    \\<subseteq> wp (WHILE (\\<lambda>s.\n                              s ''y'' \\<noteq>\n                              zero_class.zero) INV (\\<lambda>s.\n                 gcd (s ''x'') (s ''y'') =\n                 gcd x\n                  y) DO (''z'' ::= (\\<lambda>s. s ''y'')) ;\n                        (''y'' ::= (\\<lambda>s. s ''x'' mod s ''y'')) ;\n                        (''x'' ::= (\\<lambda>s. s ''z'')) OD)\n                 \\<lceil>\\<lambda>s. s ''x'' = gcd x y\\<rceil>", "apply hoare"], ["proof (prove)\ngoal (3 subgoals):\n 1. rdom \\<lceil>\\<lambda>s. s ''x'' = x \\<and> s ''y'' = y\\<rceil>\n    \\<subseteq> rdom\n                 \\<lceil>\\<lambda>s.\n                            gcd (s ''x'') (s ''y'') = gcd x y\\<rceil>\n 2. rdom \\<lceil>\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y\\<rceil> ;\n    pp_a \\<lceil>\\<lambda>s. s ''y'' \\<noteq> zero_class.zero\\<rceil>\n    \\<subseteq> rdom \\<lceil>\\<lambda>s. s ''x'' = gcd x y\\<rceil>\n 3. rdom \\<lceil>\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y\\<rceil> ;\n    rdom \\<lceil>\\<lambda>s. s ''y'' \\<noteq> zero_class.zero\\<rceil>\n    \\<subseteq> wp (''z'' ::= (\\<lambda>s. s ''y''))\n                 (wp (''y'' ::= (\\<lambda>s. s ''x'' mod s ''y''))\n                   (wp (''x'' ::= (\\<lambda>s. s ''z''))\n                     \\<lceil>\\<lambda>s.\n                                gcd (s ''x'') (s ''y'') = gcd x y\\<rceil>))", "using gcd_red_nat"], ["proof (prove)\nusing this:\n  gcd ?x ?y = gcd ?y (?x mod ?y)\n\ngoal (3 subgoals):\n 1. rdom \\<lceil>\\<lambda>s. s ''x'' = x \\<and> s ''y'' = y\\<rceil>\n    \\<subseteq> rdom\n                 \\<lceil>\\<lambda>s.\n                            gcd (s ''x'') (s ''y'') = gcd x y\\<rceil>\n 2. rdom \\<lceil>\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y\\<rceil> ;\n    pp_a \\<lceil>\\<lambda>s. s ''y'' \\<noteq> zero_class.zero\\<rceil>\n    \\<subseteq> rdom \\<lceil>\\<lambda>s. s ''x'' = gcd x y\\<rceil>\n 3. rdom \\<lceil>\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y\\<rceil> ;\n    rdom \\<lceil>\\<lambda>s. s ''y'' \\<noteq> zero_class.zero\\<rceil>\n    \\<subseteq> wp (''z'' ::= (\\<lambda>s. s ''y''))\n                 (wp (''y'' ::= (\\<lambda>s. s ''x'' mod s ''y''))\n                   (wp (''x'' ::= (\\<lambda>s. s ''z''))\n                     \\<lceil>\\<lambda>s.\n                                gcd (s ''x'') (s ''y'') = gcd x y\\<rceil>))", "by auto"], ["", "lemma euclid_diff2: \n   \"PRE (\\<lambda>s::nat store. s ''x'' = x \\<and> s ''y'' = y \\<and> x > 0 \\<and> y > 0)\n    (WHILE (\\<lambda>s. s ''x''\\<noteq> s ''y'') INV (\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y) \n     DO\n        (IF (\\<lambda>s. s ''x'' >  s ''y'')\n         THEN (''x'' ::= (\\<lambda>s. s ''x'' - s ''y''))\n         ELSE (''y'' ::= (\\<lambda>s. s ''y'' - s ''x''))\n         FI)\n    OD)\n    POST (\\<lambda>s. s ''x'' = gcd x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rdom\n     \\<lceil>\\<lambda>s.\n                s ''x'' = x \\<and>\n                s ''y'' = y \\<and>\n                zero_class.zero < x \\<and> zero_class.zero < y\\<rceil>\n    \\<subseteq> wp (WHILE (\\<lambda>s.\n                              s ''x'' \\<noteq>\n                              s ''y'') INV (\\<lambda>s.\n         gcd (s ''x'') (s ''y'') =\n         gcd x\n          y) DO (IF (\\<lambda>s.\n                        s ''y''\n                        < s ''x'') THEN (''x'' ::= (\\<lambda>s.\n                 s ''x'' -\n                 s ''y'')) ELSE (''y'' ::= (\\<lambda>s.\n         s ''y'' - s ''x'')) FI) OD)\n                 \\<lceil>\\<lambda>s. s ''x'' = gcd x y\\<rceil>", "by (hoare; clarsimp; metis gcd.commute gcd_diff1_nat le_cases nat_less_le)"], ["", "lemma varible_swap2:\n  \"PRE (\\<lambda>s. s ''x'' = a \\<and> s ''y'' = b)   \n    (''z'' ::= (\\<lambda>s. s ''x''));\n    (''x'' ::= (\\<lambda>s. s ''y''));\n    (''y'' ::= (\\<lambda>s. s ''z''))\n   POST (\\<lambda>s. s ''x'' = b \\<and> s ''y'' = a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rdom \\<lceil>\\<lambda>s. s ''x'' = a \\<and> s ''y'' = b\\<rceil>\n    \\<subseteq> wp ((''z'' ::= (\\<lambda>s. s ''x'')) ;\n                    (''x'' ::= (\\<lambda>s. s ''y'')) ;\n                    (''y'' ::= (\\<lambda>s. s ''z'')))\n                 \\<lceil>\\<lambda>s. s ''x'' = b \\<and> s ''y'' = a\\<rceil>", "by clarsimp"], ["", "lemma maximum2: \n  \"PRE (\\<lambda>s:: nat store. True) \n   (IF (\\<lambda>s. s ''x'' \\<ge> s ''y'') \n    THEN (''z'' ::= (\\<lambda>s. s ''x''))\n    ELSE (''z'' ::= (\\<lambda>s. s ''y''))\n    FI)\n   POST (\\<lambda>s. s ''z'' = max (s ''x'') (s ''y''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rdom \\<lceil>\\<lambda>s. True\\<rceil>\n    \\<subseteq> wp (IF (\\<lambda>s.\n                           s ''y''\n                           \\<le> s ''x'') THEN (''z'' ::= (\\<lambda>s.\n                        s ''x'')) ELSE (''z'' ::= (\\<lambda>s. s ''y'')) FI)\n                 \\<lceil>\\<lambda>s.\n                            s ''z'' = max (s ''x'') (s ''y'')\\<rceil>", "by auto"], ["", "lemma integer_division2: \n  \"PRE (\\<lambda>s::nat store. x \\<ge> 0)\n    (''q'' ::= (\\<lambda>s. 0)); \n    (''r'' ::= (\\<lambda>s. x));\n    (WHILE (\\<lambda>s. y \\<le> s ''r'') INV (\\<lambda>s. x = s ''q'' * y + s ''r'' \\<and> s ''r'' \\<ge> 0)\n     DO\n      (''q'' ::= (\\<lambda>s. s ''q'' + 1));\n      (''r'' ::= (\\<lambda>s. s ''r'' - y))\n      OD)\n   POST (\\<lambda>s. x = s ''q'' * y + s ''r'' \\<and> s ''r'' \\<ge> 0 \\<and> s ''r'' < y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rdom \\<lceil>\\<lambda>s. zero_class.zero \\<le> x\\<rceil>\n    \\<subseteq> wp ((''q'' ::= (\\<lambda>s. zero_class.zero)) ;\n                    (''r'' ::= (\\<lambda>s. x)) ;\n                    (WHILE (\\<lambda>s.\n                               y \\<le> s\n  ''r'') INV (\\<lambda>s.\n                 x = s ''q'' \\<cdot> y + s ''r'' \\<and>\n                 zero_class.zero\n                 \\<le> s ''r'') DO (''q'' ::= (\\<lambda>s. s ''q'' + 1)) ;\n                                   (''r'' ::= (\\<lambda>s.\n            s ''r'' - y)) OD))\n                 \\<lceil>\\<lambda>s.\n                            x = s ''q'' \\<cdot> y + s ''r'' \\<and>\n                            zero_class.zero \\<le> s ''r'' \\<and>\n                            s ''r'' < y\\<rceil>", "by hoare auto"], ["", "lemma my_power2:\n  \"PRE (\\<lambda>s::nat store. True)\n   (''i'' ::= (\\<lambda>s. 0));\n   (''y'' ::= (\\<lambda>s. 1));\n   (WHILE (\\<lambda>s. s ''i'' < n) INV (\\<lambda>s. s ''y'' = x ^ (s ''i'') \\<and> s ''i'' \\<le> n)\n     DO\n       (''y'' ::= (\\<lambda>s. (s ''y'') * x));\n       (''i'' ::= (\\<lambda>s. s ''i'' + 1))\n     OD)\n   POST (\\<lambda>s. s ''y'' = x ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rdom \\<lceil>\\<lambda>s. True\\<rceil>\n    \\<subseteq> wp ((''i'' ::= (\\<lambda>s. zero_class.zero)) ;\n                    (''y'' ::= (\\<lambda>s. 1)) ;\n                    (WHILE (\\<lambda>s.\n                               s ''i''\n                               < n) INV (\\<lambda>s.\n      s ''y'' = x ^ s ''i'' \\<and>\n      s ''i''\n      \\<le> n) DO (''y'' ::= (\\<lambda>s. s ''y'' \\<cdot> x)) ;\n                  (''i'' ::= (\\<lambda>s. s ''i'' + 1)) OD))\n                 \\<lceil>\\<lambda>s. s ''y'' = x ^ n\\<rceil>", "by hoare auto"], ["", "lemma imp_reverse2:\n  \"PRE (\\<lambda>s:: 'a list store. s ''x'' = X)\n   (''y'' ::= (\\<lambda>s. []));\n   (WHILE (\\<lambda>s. s ''x'' \\<noteq> []) INV (\\<lambda>s. rev (s ''x'') @ s ''y'' = rev X)\n    DO \n     (''y'' ::= (\\<lambda>s. hd (s ''x'') # s ''y'')); \n     (''x'' ::= (\\<lambda>s. tl (s ''x'')))\n    OD) \n   POST (\\<lambda>s. s ''y''= rev X )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rdom \\<lceil>\\<lambda>s. s ''x'' = X\\<rceil>\n    \\<subseteq> wp ((''y'' ::= (\\<lambda>s. [])) ;\n                    (WHILE (\\<lambda>s.\n                               s ''x'' \\<noteq>\n                               []) INV (\\<lambda>s.\n     rev (s ''x'') @ s ''y'' =\n     rev X) DO (''y'' ::= (\\<lambda>s. hd (s ''x'') # s ''y'')) ;\n               (''x'' ::= (\\<lambda>s. tl (s ''x''))) OD))\n                 \\<lceil>\\<lambda>s. s ''y'' = rev X\\<rceil>", "apply hoare"], ["proof (prove)\ngoal (3 subgoals):\n 1. rdom \\<lceil>\\<lambda>s. rev (s ''x'') @ s ''y'' = rev X\\<rceil> ;\n    pp_a \\<lceil>\\<lambda>s. s ''x'' \\<noteq> []\\<rceil>\n    \\<subseteq> rdom \\<lceil>\\<lambda>s. s ''y'' = rev X\\<rceil>\n 2. rdom \\<lceil>\\<lambda>s. rev (s ''x'') @ s ''y'' = rev X\\<rceil> ;\n    rdom \\<lceil>\\<lambda>s. s ''x'' \\<noteq> []\\<rceil>\n    \\<subseteq> wp (''y'' ::= (\\<lambda>s. hd (s ''x'') # s ''y''))\n                 (wp (''x'' ::= (\\<lambda>s. tl (s ''x'')))\n                   \\<lceil>\\<lambda>s.\n                              rev (s ''x'') @ s ''y'' = rev X\\<rceil>)\n 3. rdom \\<lceil>\\<lambda>s. s ''x'' = X\\<rceil>\n    \\<subseteq> wp (''y'' ::= (\\<lambda>s. []))\n                 (rdom\n                   \\<lceil>\\<lambda>s.\n                              rev (s ''x'') @ s ''y'' = rev X\\<rceil>)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>rev (x ''x'') @ x ''y'' = rev X;\n        x ''x'' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> rev (tl (x ''x'')) @ hd (x ''x'') # x ''y'' = rev X", "apply (metis append.simps append_assoc hd_Cons_tl rev.simps(2))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}