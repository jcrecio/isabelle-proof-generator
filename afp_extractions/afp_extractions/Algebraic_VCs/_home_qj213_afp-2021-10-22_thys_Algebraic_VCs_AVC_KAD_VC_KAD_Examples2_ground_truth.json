{"file_name": "/home/qj213/afp-2021-10-22/thys/Algebraic_VCs/AVC_KAD/VC_KAD_Examples2.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Algebraic_VCs", "problem_names": ["lemma euclid2:\n  \"PRE (\\<lambda>s::nat store. s ''x'' = x \\<and> s ''y'' = y)\n   (WHILE (\\<lambda>s. s ''y'' \\<noteq> 0) INV (\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y) \n    DO\n     (''z'' ::= (\\<lambda>s. s ''y''));\n     (''y'' ::= (\\<lambda>s. s ''x'' mod s ''y''));\n     (''x'' ::= (\\<lambda>s. s ''z''))\n    OD)\n   POST (\\<lambda>s. s ''x'' = gcd x y)\"", "lemma euclid_diff2: \n   \"PRE (\\<lambda>s::nat store. s ''x'' = x \\<and> s ''y'' = y \\<and> x > 0 \\<and> y > 0)\n    (WHILE (\\<lambda>s. s ''x''\\<noteq> s ''y'') INV (\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y) \n     DO\n        (IF (\\<lambda>s. s ''x'' >  s ''y'')\n         THEN (''x'' ::= (\\<lambda>s. s ''x'' - s ''y''))\n         ELSE (''y'' ::= (\\<lambda>s. s ''y'' - s ''x''))\n         FI)\n    OD)\n    POST (\\<lambda>s. s ''x'' = gcd x y)\"", "lemma integer_division2: \n  \"PRE (\\<lambda>s::nat store. x \\<ge> 0)\n    (''q'' ::= (\\<lambda>s. 0)); \n    (''r'' ::= (\\<lambda>s. x));\n    (WHILE (\\<lambda>s. y \\<le> s ''r'') INV (\\<lambda>s. x = s ''q'' * y + s ''r'' \\<and> s ''r'' \\<ge> 0)\n     DO\n      (''q'' ::= (\\<lambda>s. s ''q'' + 1));\n      (''r'' ::= (\\<lambda>s. s ''r'' - y))\n      OD)\n   POST (\\<lambda>s. x = s ''q'' * y + s ''r'' \\<and> s ''r'' \\<ge> 0 \\<and> s ''r'' < y)\"", "lemma factorial2:\n  \"PRE (\\<lambda>s::nat store. True)\n   (''x'' ::= (\\<lambda>s. 0));\n   (''y'' ::= (\\<lambda>s. 1));\n   (WHILE (\\<lambda>s. s ''x'' \\<noteq> x0) INV (\\<lambda>s. s ''y'' = fact (s ''x''))\n   DO\n     (''x'' ::= (\\<lambda>s. s ''x'' + 1));\n     (''y'' ::= (\\<lambda>s. s ''y'' \\<cdot> s ''x''))\n   OD)\n   POST (\\<lambda>s. s ''y'' = fact x0)\"", "lemma my_power2:\n  \"PRE (\\<lambda>s::nat store. True)\n   (''i'' ::= (\\<lambda>s. 0));\n   (''y'' ::= (\\<lambda>s. 1));\n   (WHILE (\\<lambda>s. s ''i'' < n) INV (\\<lambda>s. s ''y'' = x ^ (s ''i'') \\<and> s ''i'' \\<le> n)\n     DO\n       (''y'' ::= (\\<lambda>s. (s ''y'') * x));\n       (''i'' ::= (\\<lambda>s. s ''i'' + 1))\n     OD)\n   POST (\\<lambda>s. s ''y'' = x ^ n)\"", "lemma imp_reverse2:\n  \"PRE (\\<lambda>s:: 'a list store. s ''x'' = X)\n   (''y'' ::= (\\<lambda>s. []));\n   (WHILE (\\<lambda>s. s ''x'' \\<noteq> []) INV (\\<lambda>s. rev (s ''x'') @ s ''y'' = rev X)\n    DO \n     (''y'' ::= (\\<lambda>s. hd (s ''x'') # s ''y'')); \n     (''x'' ::= (\\<lambda>s. tl (s ''x'')))\n    OD) \n   POST (\\<lambda>s. s ''y''= rev X )\""], "translations": [["", "lemma euclid2:\n  \"PRE (\\<lambda>s::nat store. s ''x'' = x \\<and> s ''y'' = y)\n   (WHILE (\\<lambda>s. s ''y'' \\<noteq> 0) INV (\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y) \n    DO\n     (''z'' ::= (\\<lambda>s. s ''y''));\n     (''y'' ::= (\\<lambda>s. s ''x'' mod s ''y''));\n     (''x'' ::= (\\<lambda>s. s ''z''))\n    OD)\n   POST (\\<lambda>s. s ''x'' = gcd x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rdom \\<lceil>\\<lambda>s. s ''x'' = x \\<and> s ''y'' = y\\<rceil>\n    \\<subseteq> wp (WHILE (\\<lambda>s.\n                              s ''y'' \\<noteq>\n                              0) INV (\\<lambda>s.\n   gcd (s ''x'') (s ''y'') =\n   gcd x\n    y) DO (''z'' ::= (\\<lambda>s. s ''y'')) ;\n          (''y'' ::= (\\<lambda>s. s ''x'' mod s ''y'')) ;\n          (''x'' ::= (\\<lambda>s. s ''z'')) OD)\n                 \\<lceil>\\<lambda>s. s ''x'' = gcd x y\\<rceil>", "apply hoare"], ["proof (prove)\ngoal (3 subgoals):\n 1. rdom \\<lceil>\\<lambda>s. s ''x'' = x \\<and> s ''y'' = y\\<rceil>\n    \\<subseteq> rdom\n                 \\<lceil>\\<lambda>s.\n                            gcd (s ''x'') (s ''y'') = gcd x y\\<rceil>\n 2. rdom \\<lceil>\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y\\<rceil> ;\n    rel_ad \\<lceil>\\<lambda>s. s ''y'' \\<noteq> 0\\<rceil>\n    \\<subseteq> rdom \\<lceil>\\<lambda>s. s ''x'' = gcd x y\\<rceil>\n 3. rdom \\<lceil>\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y\\<rceil> ;\n    rdom \\<lceil>\\<lambda>s. s ''y'' \\<noteq> 0\\<rceil>\n    \\<subseteq> wp (''z'' ::= (\\<lambda>s. s ''y''))\n                 (wp (''y'' ::= (\\<lambda>s. s ''x'' mod s ''y''))\n                   (wp (''x'' ::= (\\<lambda>s. s ''z''))\n                     \\<lceil>\\<lambda>s.\n                                gcd (s ''x'') (s ''y'') = gcd x y\\<rceil>))", "using gcd_red_nat"], ["proof (prove)\nusing this:\n  gcd ?x ?y = gcd ?y (?x mod ?y)\n\ngoal (3 subgoals):\n 1. rdom \\<lceil>\\<lambda>s. s ''x'' = x \\<and> s ''y'' = y\\<rceil>\n    \\<subseteq> rdom\n                 \\<lceil>\\<lambda>s.\n                            gcd (s ''x'') (s ''y'') = gcd x y\\<rceil>\n 2. rdom \\<lceil>\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y\\<rceil> ;\n    rel_ad \\<lceil>\\<lambda>s. s ''y'' \\<noteq> 0\\<rceil>\n    \\<subseteq> rdom \\<lceil>\\<lambda>s. s ''x'' = gcd x y\\<rceil>\n 3. rdom \\<lceil>\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y\\<rceil> ;\n    rdom \\<lceil>\\<lambda>s. s ''y'' \\<noteq> 0\\<rceil>\n    \\<subseteq> wp (''z'' ::= (\\<lambda>s. s ''y''))\n                 (wp (''y'' ::= (\\<lambda>s. s ''x'' mod s ''y''))\n                   (wp (''x'' ::= (\\<lambda>s. s ''z''))\n                     \\<lceil>\\<lambda>s.\n                                gcd (s ''x'') (s ''y'') = gcd x y\\<rceil>))", "by auto"], ["", "lemma euclid_diff2: \n   \"PRE (\\<lambda>s::nat store. s ''x'' = x \\<and> s ''y'' = y \\<and> x > 0 \\<and> y > 0)\n    (WHILE (\\<lambda>s. s ''x''\\<noteq> s ''y'') INV (\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y) \n     DO\n        (IF (\\<lambda>s. s ''x'' >  s ''y'')\n         THEN (''x'' ::= (\\<lambda>s. s ''x'' - s ''y''))\n         ELSE (''y'' ::= (\\<lambda>s. s ''y'' - s ''x''))\n         FI)\n    OD)\n    POST (\\<lambda>s. s ''x'' = gcd x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rdom\n     \\<lceil>\\<lambda>s.\n                s ''x'' = x \\<and>\n                s ''y'' = y \\<and> 0 < x \\<and> 0 < y\\<rceil>\n    \\<subseteq> wp (WHILE (\\<lambda>s.\n                              s ''x'' \\<noteq>\n                              s ''y'') INV (\\<lambda>s.\n         gcd (s ''x'') (s ''y'') =\n         gcd x\n          y) DO (IF (\\<lambda>s.\n                        s ''y''\n                        < s ''x'') THEN (''x'' ::= (\\<lambda>s.\n                 s ''x'' -\n                 s ''y'')) ELSE (''y'' ::= (\\<lambda>s.\n         s ''y'' - s ''x'')) FI) OD)\n                 \\<lceil>\\<lambda>s. s ''x'' = gcd x y\\<rceil>", "apply (hoare, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>s.\n       gcd (s ''x'') (s ''y'') = gcd x y \\<and>\n       s ''x'' = s ''y'' \\<longrightarrow>\n       s ''y'' = gcd x y\n 2. \\<forall>s.\n       gcd (s ''x'') (s ''y'') = gcd x y \\<and>\n       s ''x'' \\<noteq> s ''y'' \\<longrightarrow>\n       (s ''y'' < s ''x'' \\<longrightarrow>\n        gcd (s ''x'' - s ''y'') (s ''y'') = gcd x y) \\<and>\n       (s ''y'' < s ''x'' \\<or> gcd (s ''x'') (s ''y'' - s ''x'') = gcd x y)", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s.\n       gcd (s ''x'') (s ''y'') = gcd x y \\<and>\n       s ''x'' \\<noteq> s ''y'' \\<longrightarrow>\n       (s ''y'' < s ''x'' \\<longrightarrow>\n        gcd (s ''x'' - s ''y'') (s ''y'') = gcd x y) \\<and>\n       (s ''y'' < s ''x'' \\<or> gcd (s ''x'') (s ''y'' - s ''x'') = gcd x y)", "by (metis gcd.commute gcd_diff1_nat le_cases nat_less_le)"], ["", "lemma integer_division2: \n  \"PRE (\\<lambda>s::nat store. x \\<ge> 0)\n    (''q'' ::= (\\<lambda>s. 0)); \n    (''r'' ::= (\\<lambda>s. x));\n    (WHILE (\\<lambda>s. y \\<le> s ''r'') INV (\\<lambda>s. x = s ''q'' * y + s ''r'' \\<and> s ''r'' \\<ge> 0)\n     DO\n      (''q'' ::= (\\<lambda>s. s ''q'' + 1));\n      (''r'' ::= (\\<lambda>s. s ''r'' - y))\n      OD)\n   POST (\\<lambda>s. x = s ''q'' * y + s ''r'' \\<and> s ''r'' \\<ge> 0 \\<and> s ''r'' < y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rdom \\<lceil>\\<lambda>s. 0 \\<le> x\\<rceil>\n    \\<subseteq> wp ((''q'' ::= (\\<lambda>s. 0)) ;\n                    (''r'' ::= (\\<lambda>s. x)) ;\n                    (WHILE (\\<lambda>s.\n                               y \\<le> s\n  ''r'') INV (\\<lambda>s.\n                 x = s ''q'' \\<cdot> y + s ''r'' \\<and>\n                 0 \\<le> s ''r'') DO (''q'' ::= (\\<lambda>s. s ''q'' + 1)) ;\n                                     (''r'' ::= (\\<lambda>s.\n              s ''r'' - y)) OD))\n                 \\<lceil>\\<lambda>s.\n                            x = s ''q'' \\<cdot> y + s ''r'' \\<and>\n                            0 \\<le> s ''r'' \\<and> s ''r'' < y\\<rceil>", "by hoare simp_all"], ["", "lemma factorial2:\n  \"PRE (\\<lambda>s::nat store. True)\n   (''x'' ::= (\\<lambda>s. 0));\n   (''y'' ::= (\\<lambda>s. 1));\n   (WHILE (\\<lambda>s. s ''x'' \\<noteq> x0) INV (\\<lambda>s. s ''y'' = fact (s ''x''))\n   DO\n     (''x'' ::= (\\<lambda>s. s ''x'' + 1));\n     (''y'' ::= (\\<lambda>s. s ''y'' \\<cdot> s ''x''))\n   OD)\n   POST (\\<lambda>s. s ''y'' = fact x0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rdom \\<lceil>\\<lambda>s. True\\<rceil>\n    \\<subseteq> wp ((''x'' ::= (\\<lambda>s. 0)) ;\n                    (''y'' ::= (\\<lambda>s. 1)) ;\n                    (WHILE (\\<lambda>s.\n                               s ''x'' \\<noteq>\n                               x0) INV (\\<lambda>s.\n     s ''y'' =\n     fact\n      (s ''x'')) DO (''x'' ::= (\\<lambda>s. s ''x'' + 1)) ;\n                    (''y'' ::= (\\<lambda>s. s ''y'' \\<cdot> s ''x'')) OD))\n                 \\<lceil>\\<lambda>s. s ''y'' = fact x0\\<rceil>", "by hoare simp_all"], ["", "lemma my_power2:\n  \"PRE (\\<lambda>s::nat store. True)\n   (''i'' ::= (\\<lambda>s. 0));\n   (''y'' ::= (\\<lambda>s. 1));\n   (WHILE (\\<lambda>s. s ''i'' < n) INV (\\<lambda>s. s ''y'' = x ^ (s ''i'') \\<and> s ''i'' \\<le> n)\n     DO\n       (''y'' ::= (\\<lambda>s. (s ''y'') * x));\n       (''i'' ::= (\\<lambda>s. s ''i'' + 1))\n     OD)\n   POST (\\<lambda>s. s ''y'' = x ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rdom \\<lceil>\\<lambda>s. True\\<rceil>\n    \\<subseteq> wp ((''i'' ::= (\\<lambda>s. 0)) ;\n                    (''y'' ::= (\\<lambda>s. 1)) ;\n                    (WHILE (\\<lambda>s.\n                               s ''i''\n                               < n) INV (\\<lambda>s.\n      s ''y'' = x ^ s ''i'' \\<and>\n      s ''i''\n      \\<le> n) DO (''y'' ::= (\\<lambda>s. s ''y'' \\<cdot> x)) ;\n                  (''i'' ::= (\\<lambda>s. s ''i'' + 1)) OD))\n                 \\<lceil>\\<lambda>s. s ''y'' = x ^ n\\<rceil>", "by hoare auto"], ["", "lemma imp_reverse2:\n  \"PRE (\\<lambda>s:: 'a list store. s ''x'' = X)\n   (''y'' ::= (\\<lambda>s. []));\n   (WHILE (\\<lambda>s. s ''x'' \\<noteq> []) INV (\\<lambda>s. rev (s ''x'') @ s ''y'' = rev X)\n    DO \n     (''y'' ::= (\\<lambda>s. hd (s ''x'') # s ''y'')); \n     (''x'' ::= (\\<lambda>s. tl (s ''x'')))\n    OD) \n   POST (\\<lambda>s. s ''y''= rev X )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rdom \\<lceil>\\<lambda>s. s ''x'' = X\\<rceil>\n    \\<subseteq> wp ((''y'' ::= (\\<lambda>s. [])) ;\n                    (WHILE (\\<lambda>s.\n                               s ''x'' \\<noteq>\n                               []) INV (\\<lambda>s.\n     rev (s ''x'') @ s ''y'' =\n     rev X) DO (''y'' ::= (\\<lambda>s. hd (s ''x'') # s ''y'')) ;\n               (''x'' ::= (\\<lambda>s. tl (s ''x''))) OD))\n                 \\<lceil>\\<lambda>s. s ''y'' = rev X\\<rceil>", "apply (hoare, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>s.\n       rev (s ''x'') @ s ''y'' = rev X \\<and> s ''x'' = [] \\<longrightarrow>\n       s ''y'' = rev X\n 2. \\<forall>s.\n       rev (s ''x'') @ s ''y'' = rev X \\<and>\n       s ''x'' \\<noteq> [] \\<longrightarrow>\n       rev (tl (s ''x'')) @ hd (s ''x'') # s ''y'' = rev X", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s.\n       rev (s ''x'') @ s ''y'' = rev X \\<and>\n       s ''x'' \\<noteq> [] \\<longrightarrow>\n       rev (tl (s ''x'')) @ hd (s ''x'') # s ''y'' = rev X", "by (clarsimp, metis append.simps append_assoc hd_Cons_tl rev.simps(2))"], ["", "end"]]}