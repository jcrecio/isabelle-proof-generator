{"file_name": "/home/qj213/afp-2021-10-22/thys/Algebraic_VCs/AVC_KAT/VC_KAT_scratch.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Algebraic_VCs", "problem_names": ["lemma mult_isol: \"x \\<le> y \\<Longrightarrow> z \\<cdot> x \\<le> z \\<cdot> y\"", "lemma mult_isor: \"x \\<le> y \\<Longrightarrow> x \\<cdot> z \\<le> y \\<cdot> z\"", "lemma add_iso: \"x \\<le> y \\<Longrightarrow> x + z \\<le> y + z\"", "lemma add_lub: \"x + y \\<le> z \\<longleftrightarrow> x \\<le> z \\<and> y \\<le> z\"", "lemma star_sim: \"x \\<cdot> y \\<le> z \\<cdot> x \\<Longrightarrow> x \\<cdot> y\\<^sup>\\<star> \\<le> z\\<^sup>\\<star> \\<cdot> x\"", "lemma t_n [simp]: \"t (at x) = at x\"", "lemma t_comm: \"t x \\<cdot> t y = t y \\<cdot> t x\"", "lemma t_idem [simp]: \"t x \\<cdot> t x = t x\"", "lemma t_mult_closed [simp]: \"t (t x \\<cdot> t y) = t x \\<cdot> t y\"", "lemma H_skip: \"H p 1 p\"", "lemma H_cons: \"t p \\<le> t p' \\<Longrightarrow> t q' \\<le> t q \\<Longrightarrow> H p' x q' \\<Longrightarrow> H p x q\"", "lemma H_seq: \"H r y q \\<Longrightarrow> H p x r  \\<Longrightarrow> H p (x \\<cdot> y) q\"", "lemma H_cond: \"H (t p \\<cdot> t r) x q \\<Longrightarrow> H (t p \\<cdot> at r) y q \\<Longrightarrow> H p (if r then x else y fi) q\"", "lemma H_loop: \"H (t p \\<cdot> t r) x p \\<Longrightarrow> H p (while r do x od) (t p \\<cdot> at r)\"", "lemma H_while_inv: \"t p \\<le> t i \\<Longrightarrow> t i \\<cdot> at r \\<le> t q \\<Longrightarrow> H (t i \\<cdot> t r) x i \\<Longrightarrow> H p (while r inv i do x od) q\"", "lemma (in dioid) power_inductl: \"z + x \\<cdot> y \\<le> y \\<Longrightarrow> x ^ i \\<cdot> z \\<le> y\"", "lemma (in dioid) power_inductr: \"z + y \\<cdot> x \\<le> y \\<Longrightarrow> z \\<cdot> x ^ i \\<le> y\"", "lemma power_is_relpow: \"rel_d.power X i = X ^^ i\"", "lemma rel_star_def: \"X^* = (\\<Union>i. rel_d.power X i)\"", "lemma rel_star_contl: \"X ; Y^* = (\\<Union>i. X ; rel_d.power Y i)\"", "lemma rel_star_contr: \"X^* ; Y = (\\<Union>i. (rel_d.power X i) ; Y)\"", "lemma t_p2r [simp]: \"rel_kat.t_op \\<lceil>P\\<rceil> = \\<lceil>P\\<rceil>\"", "lemma p2r_neg_hom [simp]: \"rel_at \\<lceil>P\\<rceil> = \\<lceil>\\<lambda>s. \\<not> P s\\<rceil>\"", "lemma p2r_conj_hom [simp]: \"\\<lceil>P\\<rceil> \\<inter> \\<lceil>Q\\<rceil> = \\<lceil>\\<lambda>s.  P s \\<and> Q s\\<rceil>\"", "lemma p2r_conj_hom_var [simp]: \"\\<lceil>P\\<rceil> ; \\<lceil>Q\\<rceil> = \\<lceil>\\<lambda>s. P s \\<and> Q s\\<rceil>\"", "lemma p2r_disj_hom [simp]: \"\\<lceil>P\\<rceil> \\<union> \\<lceil>Q\\<rceil> = \\<lceil>\\<lambda>s. P s \\<or> Q s\\<rceil>\"", "lemma impl_prop [simp]: \"\\<lceil>P\\<rceil> \\<subseteq> \\<lceil>Q\\<rceil> \\<longleftrightarrow> (\\<forall>s. P s \\<longrightarrow>  Q s)\"", "lemma H_assign: \"rel_kat.H \\<lceil>\\<lambda>s. P (s (v := e s))\\<rceil> (v ::= e) \\<lceil>P\\<rceil>\"", "lemma H_assign_var: \"(\\<forall>s. P s \\<longrightarrow> Q (s (v := e s))) \\<Longrightarrow> rel_kat.H \\<lceil>P\\<rceil> (v ::= e) \\<lceil>Q\\<rceil>\"", "lemma euclid:\n  \"PRE (\\<lambda>s::nat store. s ''x'' = x \\<and> s ''y'' = y)\n   (WHILE (\\<lambda>s. s ''y'' \\<noteq> 0) INV (\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y) \n    DO\n     (''z'' ::= (\\<lambda>s. s ''y''));\n     (''y'' ::= (\\<lambda>s. s ''x'' mod s ''y''));\n     (''x'' ::= (\\<lambda>s. s ''z''))\n    OD)\n   POST (\\<lambda>s. s ''x'' = gcd x y)\"", "lemma R_skip: \"1 \\<le> R p p\"", "lemma R_cons: \"t p \\<le> t p' \\<Longrightarrow> t q' \\<le> t q \\<Longrightarrow> R p' q' \\<le> R p q\"", "lemma R_seq: \"(R p r) \\<cdot> (R r q) \\<le> R p q\"", "lemma R_cond: \"if v then (R (t v \\<cdot> t p) q) else (R (at v \\<cdot> t p) q) fi \\<le> R p q\"", "lemma R_loop: \"while q do (R (t p \\<cdot> t q) p) od  \\<le> R p (t p \\<cdot> at q)\"", "lemma R_assign: \"(\\<forall>s. P s \\<longrightarrow> Q (s (v := e s))) \\<Longrightarrow> (v ::= e) \\<subseteq> rel_R \\<lceil>P\\<rceil> \\<lceil>Q\\<rceil>\"", "lemma R_assignr: \"(\\<forall>s. Q' s \\<longrightarrow> Q (s (v := e s))) \\<Longrightarrow> (rel_R \\<lceil>P\\<rceil> \\<lceil>Q'\\<rceil>) ; (v ::= e) \\<subseteq> rel_R \\<lceil>P\\<rceil> \\<lceil>Q\\<rceil>\"", "lemma R_assignl: \"(\\<forall>s. P s \\<longrightarrow> P' (s (v := e s))) \\<Longrightarrow> (v ::= e) ; (rel_R \\<lceil>P'\\<rceil> \\<lceil>Q\\<rceil>) \\<subseteq> rel_R \\<lceil>P\\<rceil> \\<lceil>Q\\<rceil>\"", "lemma var_swap_ref1: \n  \"rel_R \\<lceil>\\<lambda>s. s ''x'' = a \\<and> s ''y'' = b\\<rceil> \\<lceil>\\<lambda>s. s ''x'' = b \\<and> s ''y'' = a\\<rceil> \n   \\<supseteq> (''z'' ::= (\\<lambda>s. s ''x'')); rel_R \\<lceil>\\<lambda>s. s ''z'' = a \\<and> s ''y'' = b\\<rceil> \\<lceil>\\<lambda>s. s ''x'' = b \\<and> s ''y'' = a\\<rceil>\"", "lemma var_swap_ref2: \n  \"rel_R \\<lceil>\\<lambda>s. s ''z'' = a \\<and> s ''y'' = b\\<rceil> \\<lceil>\\<lambda>s. s ''x'' = b \\<and> s ''y'' = a\\<rceil> \n   \\<supseteq> (''x'' ::= (\\<lambda>s. s ''y'')); rel_R \\<lceil>\\<lambda>s. s ''z'' = a \\<and> s ''x'' = b\\<rceil> \\<lceil>\\<lambda>s. s ''x'' = b \\<and> s ''y'' = a\\<rceil>\"", "lemma var_swap_ref3:  \n  \"rel_R \\<lceil>\\<lambda>s. s ''z'' = a \\<and> s ''x'' = b\\<rceil> \\<lceil>\\<lambda>s. s ''x'' = b \\<and> s ''y'' = a\\<rceil> \n   \\<supseteq> (''y'' ::= (\\<lambda>s. s ''z'')); rel_R \\<lceil>\\<lambda>s. s ''x'' = b \\<and> s ''y'' = a\\<rceil> \\<lceil>\\<lambda>s. s ''x'' = b \\<and> s ''y'' = a\\<rceil>\"", "lemma var_swap_ref_var: \n  \"rel_R \\<lceil>\\<lambda>s. s ''x'' = a \\<and> s ''y'' = b\\<rceil> \\<lceil>\\<lambda>s. s ''x'' = b \\<and> s ''y'' = a\\<rceil> \n   \\<supseteq> (''z'' ::= (\\<lambda>s. s ''x'')); (''x'' ::= (\\<lambda>s. s ''y'')); (''y'' ::= (\\<lambda>s. s ''z''))\""], "translations": [["", "lemma mult_isol: \"x \\<le> y \\<Longrightarrow> z \\<cdot> x \\<le> z \\<cdot> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> z \\<cdot> x \\<le> z \\<cdot> y", "by (metis distrib_left less_eq_def)"], ["", "lemma mult_isor: \"x \\<le> y \\<Longrightarrow> x \\<cdot> z \\<le> y \\<cdot> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> x \\<cdot> z \\<le> y \\<cdot> z", "by (metis distrib_right less_eq_def)"], ["", "lemma add_iso: \"x \\<le> y \\<Longrightarrow> x + z \\<le> y + z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> x + z \\<le> y + z", "by (metis (no_types, lifting) abel_semigroup.commute add.abel_semigroup_axioms add.semigroup_axioms add_idem less_eq_def semigroup.assoc)"], ["", "lemma add_lub: \"x + y \\<le> z \\<longleftrightarrow> x \\<le> z \\<and> y \\<le> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x + y \\<le> z) = (x \\<le> z \\<and> y \\<le> z)", "by (metis add_assoc add_commute less_eq_def order.ordering_axioms ordering.refl)"], ["", "end"], ["", "class kleene_algebra = dioid + \n  fixes star :: \"'a \\<Rightarrow> 'a\" (\"_\\<^sup>\\<star>\" [101] 100)\n  assumes star_unfoldl: \"1 + x \\<cdot> x\\<^sup>\\<star> \\<le> x\\<^sup>\\<star>\"  \n  and star_unfoldr: \"1 + x\\<^sup>\\<star> \\<cdot> x \\<le> x\\<^sup>\\<star>\"\n  and star_inductl: \"z + x \\<cdot> y \\<le> y \\<Longrightarrow> x\\<^sup>\\<star> \\<cdot> z \\<le> y\"\n  and star_inductr: \"z + y \\<cdot> x \\<le> y \\<Longrightarrow> z \\<cdot> x\\<^sup>\\<star> \\<le> y\"\n\nbegin"], ["", "lemma star_sim: \"x \\<cdot> y \\<le> z \\<cdot> x \\<Longrightarrow> x \\<cdot> y\\<^sup>\\<star> \\<le> z\\<^sup>\\<star> \\<cdot> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<cdot> y \\<le> z \\<cdot> x \\<Longrightarrow>\n    x \\<cdot> y\\<^sup>\\<star> \\<le> z\\<^sup>\\<star> \\<cdot> x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<cdot> y \\<le> z \\<cdot> x \\<Longrightarrow>\n    x \\<cdot> y\\<^sup>\\<star> \\<le> z\\<^sup>\\<star> \\<cdot> x", "assume \"x \\<cdot> y \\<le> z \\<cdot> x\""], ["proof (state)\nthis:\n  x \\<cdot> y \\<le> z \\<cdot> x\n\ngoal (1 subgoal):\n 1. x \\<cdot> y \\<le> z \\<cdot> x \\<Longrightarrow>\n    x \\<cdot> y\\<^sup>\\<star> \\<le> z\\<^sup>\\<star> \\<cdot> x", "hence \"x + z\\<^sup>\\<star> \\<cdot> x \\<cdot> y \\<le> x + z\\<^sup>\\<star> \\<cdot> z \\<cdot> x\""], ["proof (prove)\nusing this:\n  x \\<cdot> y \\<le> z \\<cdot> x\n\ngoal (1 subgoal):\n 1. x + z\\<^sup>\\<star> \\<cdot> x \\<cdot> y\n    \\<le> x + z\\<^sup>\\<star> \\<cdot> z \\<cdot> x", "by (metis add_lub distrib_left eq_refl less_eq_def mult_assoc)"], ["proof (state)\nthis:\n  x + z\\<^sup>\\<star> \\<cdot> x \\<cdot> y\n  \\<le> x + z\\<^sup>\\<star> \\<cdot> z \\<cdot> x\n\ngoal (1 subgoal):\n 1. x \\<cdot> y \\<le> z \\<cdot> x \\<Longrightarrow>\n    x \\<cdot> y\\<^sup>\\<star> \\<le> z\\<^sup>\\<star> \\<cdot> x", "also"], ["proof (state)\nthis:\n  x + z\\<^sup>\\<star> \\<cdot> x \\<cdot> y\n  \\<le> x + z\\<^sup>\\<star> \\<cdot> z \\<cdot> x\n\ngoal (1 subgoal):\n 1. x \\<cdot> y \\<le> z \\<cdot> x \\<Longrightarrow>\n    x \\<cdot> y\\<^sup>\\<star> \\<le> z\\<^sup>\\<star> \\<cdot> x", "have  \"... \\<le> z\\<^sup>\\<star> \\<cdot> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + z\\<^sup>\\<star> \\<cdot> z \\<cdot> x \\<le> z\\<^sup>\\<star> \\<cdot> x", "using add_lub mult_isor star_unfoldr"], ["proof (prove)\nusing this:\n  (?x + ?y \\<le> ?z) = (?x \\<le> ?z \\<and> ?y \\<le> ?z)\n  ?x \\<le> ?y \\<Longrightarrow> ?x \\<cdot> ?z \\<le> ?y \\<cdot> ?z\n  (1::'a) + ?x\\<^sup>\\<star> \\<cdot> ?x \\<le> ?x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x + z\\<^sup>\\<star> \\<cdot> z \\<cdot> x \\<le> z\\<^sup>\\<star> \\<cdot> x", "by fastforce"], ["proof (state)\nthis:\n  x + z\\<^sup>\\<star> \\<cdot> z \\<cdot> x \\<le> z\\<^sup>\\<star> \\<cdot> x\n\ngoal (1 subgoal):\n 1. x \\<cdot> y \\<le> z \\<cdot> x \\<Longrightarrow>\n    x \\<cdot> y\\<^sup>\\<star> \\<le> z\\<^sup>\\<star> \\<cdot> x", "finally"], ["proof (chain)\npicking this:\n  x + z\\<^sup>\\<star> \\<cdot> x \\<cdot> y \\<le> z\\<^sup>\\<star> \\<cdot> x", "show ?thesis"], ["proof (prove)\nusing this:\n  x + z\\<^sup>\\<star> \\<cdot> x \\<cdot> y \\<le> z\\<^sup>\\<star> \\<cdot> x\n\ngoal (1 subgoal):\n 1. x \\<cdot> y\\<^sup>\\<star> \\<le> z\\<^sup>\\<star> \\<cdot> x", "by (simp add: star_inductr)"], ["proof (state)\nthis:\n  x \\<cdot> y\\<^sup>\\<star> \\<le> z\\<^sup>\\<star> \\<cdot> x\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "class kat = kleene_algebra +\n  fixes at :: \"'a \\<Rightarrow> 'a\" \n  assumes test_one [simp]: \"at (at 1) = 1\"\n  and test_mult [simp]: \"at (at (at (at x) \\<cdot> at (at y))) = at (at y) \\<cdot> at (at x)\" \n  and test_mult_comp [simp]: \"at x \\<cdot> at (at x) = 0\"\n  and test_de_morgan: \"at x + at y = at (at (at x) \\<cdot> at (at y))\"\n\nbegin"], ["", "definition t_op :: \"'a \\<Rightarrow> 'a\" (\"t_\" [100] 101) where\n  \"t x = at (at x)\""], ["", "lemma t_n [simp]: \"t (at x) = at x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tat x = at x", "by (metis add_idem test_de_morgan test_mult t_op_def)"], ["", "lemma t_comm: \"t x \\<cdot> t y = t y \\<cdot> t x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tx \\<cdot> ty = ty \\<cdot> tx", "by (metis add_commute test_de_morgan test_mult t_op_def)"], ["", "lemma t_idem [simp]: \"t x \\<cdot> t x = t x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tx \\<cdot> tx = tx", "by (metis add_idem test_de_morgan test_mult t_op_def)"], ["", "lemma t_mult_closed [simp]: \"t (t x \\<cdot> t y) = t x \\<cdot> t y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t(tx \\<cdot> ty) = tx \\<cdot> ty", "using t_comm t_op_def"], ["proof (prove)\nusing this:\n  t?x \\<cdot> t?y = t?y \\<cdot> t?x\n  t?x = at (at ?x)\n\ngoal (1 subgoal):\n 1. t(tx \\<cdot> ty) = tx \\<cdot> ty", "by auto"], ["", "subsubsection\\<open>Propositional Hoare Logic\\<close>"], ["", "definition H :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> bool\" where\n  \"H p x q \\<longleftrightarrow> t p \\<cdot> x \\<le> x \\<cdot> t q\""], ["", "definition if_then_else :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\" (\"if _ then _ else _ fi\" [64,64,64] 63) where\n  \"if p then x else y fi = t p \\<cdot> x + at p \\<cdot> y\""], ["", "definition while :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a\" (\"while _ do _ od\" [64,64] 63) where\n  \"while p do x od = (t p \\<cdot> x)\\<^sup>\\<star> \\<cdot> at p\""], ["", "definition while_inv :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\" (\"while _ inv _ do _ od\" [64,64,64] 63) where\n  \"while p inv i do x od = while p do x od\""], ["", "lemma H_skip: \"H p 1 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H p (1::'a) p", "by (simp add: H_def)"], ["", "lemma H_cons: \"t p \\<le> t p' \\<Longrightarrow> t q' \\<le> t q \\<Longrightarrow> H p' x q' \\<Longrightarrow> H p x q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tp \\<le> tp'; tq' \\<le> tq; H p' x q'\\<rbrakk>\n    \\<Longrightarrow> H p x q", "by (meson H_def mult_isol mult_isor order.trans)"], ["", "lemma H_seq: \"H r y q \\<Longrightarrow> H p x r  \\<Longrightarrow> H p (x \\<cdot> y) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>H r y q; H p x r\\<rbrakk> \\<Longrightarrow> H p (x \\<cdot> y) q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>H r y q; H p x r\\<rbrakk> \\<Longrightarrow> H p (x \\<cdot> y) q", "assume h1: \"H p x r\" and h2: \"H r y q\""], ["proof (state)\nthis:\n  H p x r\n  H r y q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>H r y q; H p x r\\<rbrakk> \\<Longrightarrow> H p (x \\<cdot> y) q", "hence h3: \"t p \\<cdot> x \\<le> x \\<cdot> t r\" and h4: \"t r \\<cdot> y \\<le> y \\<cdot> t q\""], ["proof (prove)\nusing this:\n  H p x r\n  H r y q\n\ngoal (1 subgoal):\n 1. tp \\<cdot> x \\<le> x \\<cdot> tr &&& tr \\<cdot> y \\<le> y \\<cdot> tq", "using H_def"], ["proof (prove)\nusing this:\n  H p x r\n  H r y q\n  H ?p ?x ?q = (t?p \\<cdot> ?x \\<le> ?x \\<cdot> t?q)\n\ngoal (1 subgoal):\n 1. tp \\<cdot> x \\<le> x \\<cdot> tr &&& tr \\<cdot> y \\<le> y \\<cdot> tq", "apply  blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. tr \\<cdot> y \\<le> y \\<cdot> tq", "using H_def h2"], ["proof (prove)\nusing this:\n  H ?p ?x ?q = (t?p \\<cdot> ?x \\<le> ?x \\<cdot> t?q)\n  H r y q\n\ngoal (1 subgoal):\n 1. tr \\<cdot> y \\<le> y \\<cdot> tq", "by blast"], ["proof (state)\nthis:\n  tp \\<cdot> x \\<le> x \\<cdot> tr\n  tr \\<cdot> y \\<le> y \\<cdot> tq\n\ngoal (1 subgoal):\n 1. \\<lbrakk>H r y q; H p x r\\<rbrakk> \\<Longrightarrow> H p (x \\<cdot> y) q", "hence \"t p \\<cdot> x \\<cdot> y \\<le> x \\<cdot> t r \\<cdot> y\""], ["proof (prove)\nusing this:\n  tp \\<cdot> x \\<le> x \\<cdot> tr\n  tr \\<cdot> y \\<le> y \\<cdot> tq\n\ngoal (1 subgoal):\n 1. tp \\<cdot> x \\<cdot> y \\<le> x \\<cdot> tr \\<cdot> y", "using mult_isor"], ["proof (prove)\nusing this:\n  tp \\<cdot> x \\<le> x \\<cdot> tr\n  tr \\<cdot> y \\<le> y \\<cdot> tq\n  ?x \\<le> ?y \\<Longrightarrow> ?x \\<cdot> ?z \\<le> ?y \\<cdot> ?z\n\ngoal (1 subgoal):\n 1. tp \\<cdot> x \\<cdot> y \\<le> x \\<cdot> tr \\<cdot> y", "by blast"], ["proof (state)\nthis:\n  tp \\<cdot> x \\<cdot> y \\<le> x \\<cdot> tr \\<cdot> y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>H r y q; H p x r\\<rbrakk> \\<Longrightarrow> H p (x \\<cdot> y) q", "also"], ["proof (state)\nthis:\n  tp \\<cdot> x \\<cdot> y \\<le> x \\<cdot> tr \\<cdot> y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>H r y q; H p x r\\<rbrakk> \\<Longrightarrow> H p (x \\<cdot> y) q", "have \"... \\<le> x \\<cdot> y \\<cdot> t q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<cdot> tr \\<cdot> y \\<le> x \\<cdot> y \\<cdot> tq", "by (simp add: h4 mult_isol mult_assoc)"], ["proof (state)\nthis:\n  x \\<cdot> tr \\<cdot> y \\<le> x \\<cdot> y \\<cdot> tq\n\ngoal (1 subgoal):\n 1. \\<lbrakk>H r y q; H p x r\\<rbrakk> \\<Longrightarrow> H p (x \\<cdot> y) q", "finally"], ["proof (chain)\npicking this:\n  tp \\<cdot> x \\<cdot> y \\<le> x \\<cdot> y \\<cdot> tq", "show ?thesis"], ["proof (prove)\nusing this:\n  tp \\<cdot> x \\<cdot> y \\<le> x \\<cdot> y \\<cdot> tq\n\ngoal (1 subgoal):\n 1. H p (x \\<cdot> y) q", "by (simp add: H_def mult_assoc)"], ["proof (state)\nthis:\n  H p (x \\<cdot> y) q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma H_cond: \"H (t p \\<cdot> t r) x q \\<Longrightarrow> H (t p \\<cdot> at r) y q \\<Longrightarrow> H p (if r then x else y fi) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>H (tp \\<cdot> tr) x q; H (tp \\<cdot> at r) y q\\<rbrakk>\n    \\<Longrightarrow> H p (if r then x else y fi) q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>H (tp \\<cdot> tr) x q; H (tp \\<cdot> at r) y q\\<rbrakk>\n    \\<Longrightarrow> H p (if r then x else y fi) q", "assume h1: \"H (t p \\<cdot> t r) x q\" and h2: \"H (t p \\<cdot> at r) y q\""], ["proof (state)\nthis:\n  H (tp \\<cdot> tr) x q\n  H (tp \\<cdot> at r) y q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>H (tp \\<cdot> tr) x q; H (tp \\<cdot> at r) y q\\<rbrakk>\n    \\<Longrightarrow> H p (if r then x else y fi) q", "hence h3: \"t r \\<cdot> t p \\<cdot> t r \\<cdot> x \\<le> t r \\<cdot> x \\<cdot> t q\" and h4: \"at r \\<cdot> t p \\<cdot> at r \\<cdot> y \\<le> at r \\<cdot> y \\<cdot> t q\""], ["proof (prove)\nusing this:\n  H (tp \\<cdot> tr) x q\n  H (tp \\<cdot> at r) y q\n\ngoal (1 subgoal):\n 1. tr \\<cdot> tp \\<cdot> tr \\<cdot> x \\<le> tr \\<cdot> x \\<cdot> tq &&&\n    at r \\<cdot> tp \\<cdot> at r \\<cdot> y \\<le> at r \\<cdot> y \\<cdot> tq", "by (simp add: H_def mult_isol mult_assoc, metis H_def h2 mult_isol mult_assoc t_mult_closed t_n)"], ["proof (state)\nthis:\n  tr \\<cdot> tp \\<cdot> tr \\<cdot> x \\<le> tr \\<cdot> x \\<cdot> tq\n  at r \\<cdot> tp \\<cdot> at r \\<cdot> y \\<le> at r \\<cdot> y \\<cdot> tq\n\ngoal (1 subgoal):\n 1. \\<lbrakk>H (tp \\<cdot> tr) x q; H (tp \\<cdot> at r) y q\\<rbrakk>\n    \\<Longrightarrow> H p (if r then x else y fi) q", "hence h5: \"t p \\<cdot> t r \\<cdot> x \\<le> t r \\<cdot> x \\<cdot> t q\" and  h6: \"t p \\<cdot> at r \\<cdot> y \\<le> at r \\<cdot> y \\<cdot> t q\""], ["proof (prove)\nusing this:\n  tr \\<cdot> tp \\<cdot> tr \\<cdot> x \\<le> tr \\<cdot> x \\<cdot> tq\n  at r \\<cdot> tp \\<cdot> at r \\<cdot> y \\<le> at r \\<cdot> y \\<cdot> tq\n\ngoal (1 subgoal):\n 1. tp \\<cdot> tr \\<cdot> x \\<le> tr \\<cdot> x \\<cdot> tq &&&\n    tp \\<cdot> at r \\<cdot> y \\<le> at r \\<cdot> y \\<cdot> tq", "by (simp add: mult_assoc t_comm, metis h4 mult_assoc t_comm t_idem t_n)"], ["proof (state)\nthis:\n  tp \\<cdot> tr \\<cdot> x \\<le> tr \\<cdot> x \\<cdot> tq\n  tp \\<cdot> at r \\<cdot> y \\<le> at r \\<cdot> y \\<cdot> tq\n\ngoal (1 subgoal):\n 1. \\<lbrakk>H (tp \\<cdot> tr) x q; H (tp \\<cdot> at r) y q\\<rbrakk>\n    \\<Longrightarrow> H p (if r then x else y fi) q", "have \"t p \\<cdot> (t r \\<cdot> x + at r \\<cdot> y) = t p \\<cdot> t r \\<cdot> x + t p \\<cdot> at r \\<cdot> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tp \\<cdot> (tr \\<cdot> x + at r \\<cdot> y) =\n    tp \\<cdot> tr \\<cdot> x + tp \\<cdot> at r \\<cdot> y", "by (simp add: distrib_left mult_assoc)"], ["proof (state)\nthis:\n  tp \\<cdot> (tr \\<cdot> x + at r \\<cdot> y) =\n  tp \\<cdot> tr \\<cdot> x + tp \\<cdot> at r \\<cdot> y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>H (tp \\<cdot> tr) x q; H (tp \\<cdot> at r) y q\\<rbrakk>\n    \\<Longrightarrow> H p (if r then x else y fi) q", "also"], ["proof (state)\nthis:\n  tp \\<cdot> (tr \\<cdot> x + at r \\<cdot> y) =\n  tp \\<cdot> tr \\<cdot> x + tp \\<cdot> at r \\<cdot> y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>H (tp \\<cdot> tr) x q; H (tp \\<cdot> at r) y q\\<rbrakk>\n    \\<Longrightarrow> H p (if r then x else y fi) q", "have \"... \\<le> t r \\<cdot> x \\<cdot> t q + t p \\<cdot> at r \\<cdot> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tp \\<cdot> tr \\<cdot> x + tp \\<cdot> at r \\<cdot> y\n    \\<le> tr \\<cdot> x \\<cdot> tq + tp \\<cdot> at r \\<cdot> y", "using h5 add_iso"], ["proof (prove)\nusing this:\n  tp \\<cdot> tr \\<cdot> x \\<le> tr \\<cdot> x \\<cdot> tq\n  ?x \\<le> ?y \\<Longrightarrow> ?x + ?z \\<le> ?y + ?z\n\ngoal (1 subgoal):\n 1. tp \\<cdot> tr \\<cdot> x + tp \\<cdot> at r \\<cdot> y\n    \\<le> tr \\<cdot> x \\<cdot> tq + tp \\<cdot> at r \\<cdot> y", "by blast"], ["proof (state)\nthis:\n  tp \\<cdot> tr \\<cdot> x + tp \\<cdot> at r \\<cdot> y\n  \\<le> tr \\<cdot> x \\<cdot> tq + tp \\<cdot> at r \\<cdot> y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>H (tp \\<cdot> tr) x q; H (tp \\<cdot> at r) y q\\<rbrakk>\n    \\<Longrightarrow> H p (if r then x else y fi) q", "also"], ["proof (state)\nthis:\n  tp \\<cdot> tr \\<cdot> x + tp \\<cdot> at r \\<cdot> y\n  \\<le> tr \\<cdot> x \\<cdot> tq + tp \\<cdot> at r \\<cdot> y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>H (tp \\<cdot> tr) x q; H (tp \\<cdot> at r) y q\\<rbrakk>\n    \\<Longrightarrow> H p (if r then x else y fi) q", "have \"... \\<le> t r \\<cdot> x \\<cdot> t q + at r \\<cdot> y \\<cdot> t q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tr \\<cdot> x \\<cdot> tq + tp \\<cdot> at r \\<cdot> y\n    \\<le> tr \\<cdot> x \\<cdot> tq + at r \\<cdot> y \\<cdot> tq", "by (simp add: add_commute h6 add_iso)"], ["proof (state)\nthis:\n  tr \\<cdot> x \\<cdot> tq + tp \\<cdot> at r \\<cdot> y\n  \\<le> tr \\<cdot> x \\<cdot> tq + at r \\<cdot> y \\<cdot> tq\n\ngoal (1 subgoal):\n 1. \\<lbrakk>H (tp \\<cdot> tr) x q; H (tp \\<cdot> at r) y q\\<rbrakk>\n    \\<Longrightarrow> H p (if r then x else y fi) q", "finally"], ["proof (chain)\npicking this:\n  tp \\<cdot> (tr \\<cdot> x + at r \\<cdot> y)\n  \\<le> tr \\<cdot> x \\<cdot> tq + at r \\<cdot> y \\<cdot> tq", "show ?thesis"], ["proof (prove)\nusing this:\n  tp \\<cdot> (tr \\<cdot> x + at r \\<cdot> y)\n  \\<le> tr \\<cdot> x \\<cdot> tq + at r \\<cdot> y \\<cdot> tq\n\ngoal (1 subgoal):\n 1. H p (if r then x else y fi) q", "by (simp add: H_def if_then_else_def distrib_right)"], ["proof (state)\nthis:\n  H p (if r then x else y fi) q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma H_loop: \"H (t p \\<cdot> t r) x p \\<Longrightarrow> H p (while r do x od) (t p \\<cdot> at r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H (tp \\<cdot> tr) x p \\<Longrightarrow>\n    H p (while r do x od) (tp \\<cdot> at r)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. H (tp \\<cdot> tr) x p \\<Longrightarrow>\n    H p (while r do x od) (tp \\<cdot> at r)", "assume  \"H (t p \\<cdot> t r) x p\""], ["proof (state)\nthis:\n  H (tp \\<cdot> tr) x p\n\ngoal (1 subgoal):\n 1. H (tp \\<cdot> tr) x p \\<Longrightarrow>\n    H p (while r do x od) (tp \\<cdot> at r)", "hence \"t r \\<cdot> t p \\<cdot> t r \\<cdot> x \\<le> t r \\<cdot> x \\<cdot> t p\""], ["proof (prove)\nusing this:\n  H (tp \\<cdot> tr) x p\n\ngoal (1 subgoal):\n 1. tr \\<cdot> tp \\<cdot> tr \\<cdot> x \\<le> tr \\<cdot> x \\<cdot> tp", "by (metis H_def distrib_left less_eq_def mult_assoc t_mult_closed)"], ["proof (state)\nthis:\n  tr \\<cdot> tp \\<cdot> tr \\<cdot> x \\<le> tr \\<cdot> x \\<cdot> tp\n\ngoal (1 subgoal):\n 1. H (tp \\<cdot> tr) x p \\<Longrightarrow>\n    H p (while r do x od) (tp \\<cdot> at r)", "hence \"t p \\<cdot> t r \\<cdot> x \\<le> t r \\<cdot> x \\<cdot> t p\""], ["proof (prove)\nusing this:\n  tr \\<cdot> tp \\<cdot> tr \\<cdot> x \\<le> tr \\<cdot> x \\<cdot> tp\n\ngoal (1 subgoal):\n 1. tp \\<cdot> tr \\<cdot> x \\<le> tr \\<cdot> x \\<cdot> tp", "by (simp add: mult_assoc t_comm)"], ["proof (state)\nthis:\n  tp \\<cdot> tr \\<cdot> x \\<le> tr \\<cdot> x \\<cdot> tp\n\ngoal (1 subgoal):\n 1. H (tp \\<cdot> tr) x p \\<Longrightarrow>\n    H p (while r do x od) (tp \\<cdot> at r)", "hence \"t p \\<cdot> (t r \\<cdot> x)\\<^sup>\\<star> \\<cdot> at r \\<le> (t r \\<cdot> x)\\<^sup>\\<star> \\<cdot> t p \\<cdot> at r\""], ["proof (prove)\nusing this:\n  tp \\<cdot> tr \\<cdot> x \\<le> tr \\<cdot> x \\<cdot> tp\n\ngoal (1 subgoal):\n 1. tp \\<cdot> (tr \\<cdot> x)\\<^sup>\\<star> \\<cdot> at r\n    \\<le> (tr \\<cdot> x)\\<^sup>\\<star> \\<cdot> tp \\<cdot> at r", "by (metis mult_isor star_sim mult_assoc)"], ["proof (state)\nthis:\n  tp \\<cdot> (tr \\<cdot> x)\\<^sup>\\<star> \\<cdot> at r\n  \\<le> (tr \\<cdot> x)\\<^sup>\\<star> \\<cdot> tp \\<cdot> at r\n\ngoal (1 subgoal):\n 1. H (tp \\<cdot> tr) x p \\<Longrightarrow>\n    H p (while r do x od) (tp \\<cdot> at r)", "hence \"t p \\<cdot> (t r \\<cdot> x)\\<^sup>\\<star> \\<cdot> at r \\<le> (t r \\<cdot> x)\\<^sup>\\<star> \\<cdot> at r \\<cdot> t p \\<cdot> at r\""], ["proof (prove)\nusing this:\n  tp \\<cdot> (tr \\<cdot> x)\\<^sup>\\<star> \\<cdot> at r\n  \\<le> (tr \\<cdot> x)\\<^sup>\\<star> \\<cdot> tp \\<cdot> at r\n\ngoal (1 subgoal):\n 1. tp \\<cdot> (tr \\<cdot> x)\\<^sup>\\<star> \\<cdot> at r\n    \\<le> (tr \\<cdot> x)\\<^sup>\\<star> \\<cdot> at r \\<cdot> tp \\<cdot> at r", "by (metis mult_assoc t_comm t_idem t_n)"], ["proof (state)\nthis:\n  tp \\<cdot> (tr \\<cdot> x)\\<^sup>\\<star> \\<cdot> at r\n  \\<le> (tr \\<cdot> x)\\<^sup>\\<star> \\<cdot> at r \\<cdot> tp \\<cdot> at r\n\ngoal (1 subgoal):\n 1. H (tp \\<cdot> tr) x p \\<Longrightarrow>\n    H p (while r do x od) (tp \\<cdot> at r)", "thus ?thesis"], ["proof (prove)\nusing this:\n  tp \\<cdot> (tr \\<cdot> x)\\<^sup>\\<star> \\<cdot> at r\n  \\<le> (tr \\<cdot> x)\\<^sup>\\<star> \\<cdot> at r \\<cdot> tp \\<cdot> at r\n\ngoal (1 subgoal):\n 1. H p (while r do x od) (tp \\<cdot> at r)", "by (metis H_def mult_assoc t_mult_closed t_n while_def)"], ["proof (state)\nthis:\n  H p (while r do x od) (tp \\<cdot> at r)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma H_while_inv: \"t p \\<le> t i \\<Longrightarrow> t i \\<cdot> at r \\<le> t q \\<Longrightarrow> H (t i \\<cdot> t r) x i \\<Longrightarrow> H p (while r inv i do x od) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tp \\<le> ti; ti \\<cdot> at r \\<le> tq;\n     H (ti \\<cdot> tr) x i\\<rbrakk>\n    \\<Longrightarrow> H p (while r inv i do x od) q", "by (metis H_cons H_loop t_mult_closed t_n while_inv_def)"], ["", "end"], ["", "subsubsection\\<open>Soundness and Relation KAT\\<close>"], ["", "notation relcomp (infixl \";\" 70)"], ["", "interpretation rel_d: dioid Id \"{}\" \"(\\<union>)\" \"(;)\" \"(\\<subseteq>)\" \"(\\<subset>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. VC_KAT_scratch.class.dioid Id {} (\\<union>) (;) (\\<subseteq>)\n     (\\<subset>)", "by (standard, auto)"], ["", "lemma (in dioid) power_inductl: \"z + x \\<cdot> y \\<le> y \\<Longrightarrow> x ^ i \\<cdot> z \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z + x \\<cdot> y \\<le> y \\<Longrightarrow> x ^ i \\<cdot> z \\<le> y", "apply (induct i; clarsimp simp add: add_lub)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>x ^ i \\<cdot> z \\<le> y; z \\<le> y;\n        x \\<cdot> y \\<le> y\\<rbrakk>\n       \\<Longrightarrow> x \\<cdot> x ^ i \\<cdot> z \\<le> y", "by (metis local.dual_order.trans local.mult_isol mult_assoc)"], ["", "lemma (in dioid) power_inductr: \"z + y \\<cdot> x \\<le> y \\<Longrightarrow> z \\<cdot> x ^ i \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z + y \\<cdot> x \\<le> y \\<Longrightarrow> z \\<cdot> x ^ i \\<le> y", "apply (induct i; clarsimp simp add: add_lub)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>z \\<cdot> x ^ i \\<le> y; z \\<le> y;\n        y \\<cdot> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> z \\<cdot> (x \\<cdot> x ^ i) \\<le> y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>z \\<cdot> x ^ i \\<le> y; z \\<le> y;\n        y \\<cdot> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> z \\<cdot> (x \\<cdot> x ^ i) \\<le> y", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>z \\<cdot> x ^ i \\<le> y; z \\<le> y;\n        y \\<cdot> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> z \\<cdot> (x \\<cdot> x ^ i) \\<le> y", "assume \"z \\<cdot> x ^ i \\<le> y\" \"z \\<le> y\" \"y \\<cdot> x \\<le> y\""], ["proof (state)\nthis:\n  z \\<cdot> x ^ i \\<le> y\n  z \\<le> y\n  y \\<cdot> x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>z \\<cdot> x ^ i \\<le> y; z \\<le> y;\n        y \\<cdot> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> z \\<cdot> (x \\<cdot> x ^ i) \\<le> y", "hence \"(z \\<cdot> x ^ i) \\<cdot> x \\<le> y\""], ["proof (prove)\nusing this:\n  z \\<cdot> x ^ i \\<le> y\n  z \\<le> y\n  y \\<cdot> x \\<le> y\n\ngoal (1 subgoal):\n 1. z \\<cdot> x ^ i \\<cdot> x \\<le> y", "using local.dual_order.trans local.mult_isor"], ["proof (prove)\nusing this:\n  z \\<cdot> x ^ i \\<le> y\n  z \\<le> y\n  y \\<cdot> x \\<le> y\n  \\<lbrakk>?b \\<le> ?a; ?c \\<le> ?b\\<rbrakk> \\<Longrightarrow> ?c \\<le> ?a\n  ?x \\<le> ?y \\<Longrightarrow> ?x \\<cdot> ?z \\<le> ?y \\<cdot> ?z\n\ngoal (1 subgoal):\n 1. z \\<cdot> x ^ i \\<cdot> x \\<le> y", "by blast"], ["proof (state)\nthis:\n  z \\<cdot> x ^ i \\<cdot> x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>z \\<cdot> x ^ i \\<le> y; z \\<le> y;\n        y \\<cdot> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> z \\<cdot> (x \\<cdot> x ^ i) \\<le> y", "thus \"z \\<cdot> (x \\<cdot> x ^ i) \\<le> y\""], ["proof (prove)\nusing this:\n  z \\<cdot> x ^ i \\<cdot> x \\<le> y\n\ngoal (1 subgoal):\n 1. z \\<cdot> (x \\<cdot> x ^ i) \\<le> y", "by (simp add: mult_assoc local.power_commutes)"], ["proof (state)\nthis:\n  z \\<cdot> (x \\<cdot> x ^ i) \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma power_is_relpow: \"rel_d.power X i = X ^^ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_d.power X i = X ^^ i", "by (induct i, simp_all add: relpow_commute)"], ["", "lemma rel_star_def: \"X^* = (\\<Union>i. rel_d.power X i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X\\<^sup>* = \\<Union> (range (rel_d.power X))", "by (simp add: power_is_relpow rtrancl_is_UN_relpow)"], ["", "lemma rel_star_contl: \"X ; Y^* = (\\<Union>i. X ; rel_d.power Y i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X ; Y\\<^sup>* = (\\<Union>i. X ; rel_d.power Y i)", "by (simp add: rel_star_def relcomp_UNION_distrib)"], ["", "lemma rel_star_contr: \"X^* ; Y = (\\<Union>i. (rel_d.power X i) ; Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X\\<^sup>* ; Y = (\\<Union>i. rel_d.power X i ; Y)", "by (simp add: rel_star_def relcomp_UNION_distrib2)"], ["", "definition rel_at :: \"'a rel \\<Rightarrow> 'a rel\" where \n  \"rel_at X = Id \\<inter> - X\""], ["", "interpretation rel_kat: kat Id \"{}\" \"(\\<union>)\" \"(;)\" \"(\\<subseteq>)\" \"(\\<subset>)\" rtrancl rel_at"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.kat Id {} (\\<union>) (;) (\\<subseteq>) (\\<subset>) rtrancl rel_at", "apply standard"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x. Id \\<union> x ; x\\<^sup>* \\<subseteq> x\\<^sup>*\n 2. \\<And>x. Id \\<union> x\\<^sup>* ; x \\<subseteq> x\\<^sup>*\n 3. \\<And>z x y.\n       z \\<union> x ; y \\<subseteq> y \\<Longrightarrow>\n       x\\<^sup>* ; z \\<subseteq> y\n 4. \\<And>z y x.\n       z \\<union> y ; x \\<subseteq> y \\<Longrightarrow>\n       z ; x\\<^sup>* \\<subseteq> y\n 5. rel_at (rel_at Id) = Id\n 6. \\<And>x y.\n       rel_at (rel_at (rel_at (rel_at x) ; rel_at (rel_at y))) =\n       rel_at (rel_at y) ; rel_at (rel_at x)\n 7. \\<And>x. rel_at x ; rel_at (rel_at x) = {}\n 8. \\<And>x y.\n       rel_at x \\<union> rel_at y =\n       rel_at (rel_at (rel_at x) ; rel_at (rel_at y))", "apply auto[2]"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>z x y.\n       z \\<union> x ; y \\<subseteq> y \\<Longrightarrow>\n       x\\<^sup>* ; z \\<subseteq> y\n 2. \\<And>z y x.\n       z \\<union> y ; x \\<subseteq> y \\<Longrightarrow>\n       z ; x\\<^sup>* \\<subseteq> y\n 3. rel_at (rel_at Id) = Id\n 4. \\<And>x y.\n       rel_at (rel_at (rel_at (rel_at x) ; rel_at (rel_at y))) =\n       rel_at (rel_at y) ; rel_at (rel_at x)\n 5. \\<And>x. rel_at x ; rel_at (rel_at x) = {}\n 6. \\<And>x y.\n       rel_at x \\<union> rel_at y =\n       rel_at (rel_at (rel_at x) ; rel_at (rel_at y))", "by (auto simp: rel_star_contr rel_d.power_inductl rel_star_contl  SUP_least rel_d.power_inductr rel_at_def)"], ["", "subsubsection\\<open>Embedding Predicates in Relations\\<close>"], ["", "type_synonym 'a pred = \"'a \\<Rightarrow> bool\""], ["", "abbreviation p2r :: \"'a pred \\<Rightarrow> 'a rel\" (\"\\<lceil>_\\<rceil>\") where\n  \"\\<lceil>P\\<rceil> \\<equiv> {(s,s) |s. P s}\""], ["", "lemma t_p2r [simp]: \"rel_kat.t_op \\<lceil>P\\<rceil> = \\<lceil>P\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_kat.t_op \\<lceil>P\\<rceil> = \\<lceil>P\\<rceil>", "by (auto simp add: rel_kat.t_op_def rel_at_def)"], ["", "lemma p2r_neg_hom [simp]: \"rel_at \\<lceil>P\\<rceil> = \\<lceil>\\<lambda>s. \\<not> P s\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_at \\<lceil>P\\<rceil> = \\<lceil>\\<lambda>s. \\<not> P s\\<rceil>", "by (auto simp: rel_at_def)"], ["", "lemma p2r_conj_hom [simp]: \"\\<lceil>P\\<rceil> \\<inter> \\<lceil>Q\\<rceil> = \\<lceil>\\<lambda>s.  P s \\<and> Q s\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lceil>P\\<rceil> \\<inter> \\<lceil>Q\\<rceil> =\n    \\<lceil>\\<lambda>s. P s \\<and> Q s\\<rceil>", "by auto"], ["", "lemma p2r_conj_hom_var [simp]: \"\\<lceil>P\\<rceil> ; \\<lceil>Q\\<rceil> = \\<lceil>\\<lambda>s. P s \\<and> Q s\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lceil>P\\<rceil> ; \\<lceil>Q\\<rceil> =\n    \\<lceil>\\<lambda>s. P s \\<and> Q s\\<rceil>", "by auto"], ["", "lemma p2r_disj_hom [simp]: \"\\<lceil>P\\<rceil> \\<union> \\<lceil>Q\\<rceil> = \\<lceil>\\<lambda>s. P s \\<or> Q s\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lceil>P\\<rceil> \\<union> \\<lceil>Q\\<rceil> =\n    \\<lceil>\\<lambda>s. P s \\<or> Q s\\<rceil>", "by auto"], ["", "lemma impl_prop [simp]: \"\\<lceil>P\\<rceil> \\<subseteq> \\<lceil>Q\\<rceil> \\<longleftrightarrow> (\\<forall>s. P s \\<longrightarrow>  Q s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lceil>P\\<rceil> \\<subseteq> \\<lceil>Q\\<rceil>) =\n    (\\<forall>s. P s \\<longrightarrow> Q s)", "by auto"], ["", "subsubsection \\<open>Store and Assignment\\<close>"], ["", "type_synonym 'a store = \"string  \\<Rightarrow> 'a\""], ["", "definition gets :: \"string \\<Rightarrow> ('a store \\<Rightarrow> 'a) \\<Rightarrow> 'a store rel\" (\"_ ::= _\" [70, 65] 61) where \n  \"v ::= e = {(s, s(v := e s)) |s. True}\""], ["", "lemma H_assign: \"rel_kat.H \\<lceil>\\<lambda>s. P (s (v := e s))\\<rceil> (v ::= e) \\<lceil>P\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_kat.H \\<lceil>\\<lambda>s. P (s(v := e s))\\<rceil> (v ::= e)\n     \\<lceil>P\\<rceil>", "by (auto simp: gets_def rel_kat.H_def rel_kat.t_op_def rel_at_def)"], ["", "lemma H_assign_var: \"(\\<forall>s. P s \\<longrightarrow> Q (s (v := e s))) \\<Longrightarrow> rel_kat.H \\<lceil>P\\<rceil> (v ::= e) \\<lceil>Q\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s. P s \\<longrightarrow> Q (s(v := e s)) \\<Longrightarrow>\n    rel_kat.H \\<lceil>P\\<rceil> (v ::= e) \\<lceil>Q\\<rceil>", "by (auto simp: gets_def rel_kat.H_def rel_kat.t_op_def rel_at_def)"], ["", "abbreviation H_sugar :: \"'a pred \\<Rightarrow> 'a rel \\<Rightarrow> 'a pred \\<Rightarrow> bool\" (\"PRE _ _ POST _\" [64,64,64] 63) where\n  \"PRE P X POST Q \\<equiv> rel_kat.H \\<lceil>P\\<rceil> X \\<lceil>Q\\<rceil>\""], ["", "abbreviation if_then_else_sugar :: \"'a pred \\<Rightarrow> 'a rel \\<Rightarrow> 'a rel \\<Rightarrow> 'a rel\" (\"IF _ THEN _ ELSE _ FI\" [64,64,64] 63) where\n  \"IF P THEN X ELSE Y FI \\<equiv> rel_kat.if_then_else \\<lceil>P\\<rceil> X Y\""], ["", "abbreviation while_inv_sugar :: \"'a pred \\<Rightarrow> 'a pred \\<Rightarrow> 'a rel \\<Rightarrow> 'a rel\" (\"WHILE _ INV _ DO _ OD\" [64,64,64] 63) where\n  \"WHILE P INV I DO X OD \\<equiv> rel_kat.while_inv \\<lceil>P\\<rceil> \\<lceil>I\\<rceil> X\""], ["", "subsubsection \\<open>Verification Example\\<close>"], ["", "lemma euclid:\n  \"PRE (\\<lambda>s::nat store. s ''x'' = x \\<and> s ''y'' = y)\n   (WHILE (\\<lambda>s. s ''y'' \\<noteq> 0) INV (\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y) \n    DO\n     (''z'' ::= (\\<lambda>s. s ''y''));\n     (''y'' ::= (\\<lambda>s. s ''x'' mod s ''y''));\n     (''x'' ::= (\\<lambda>s. s ''z''))\n    OD)\n   POST (\\<lambda>s. s ''x'' = gcd x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_kat.H \\<lceil>\\<lambda>s. s ''x'' = x \\<and> s ''y'' = y\\<rceil>\n     (rel_kat.while_inv \\<lceil>\\<lambda>s. s ''y'' \\<noteq> 0\\<rceil>\n       \\<lceil>\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y\\<rceil>\n       ((''z'' ::= (\\<lambda>s. s ''y'')) ;\n        (''y'' ::= (\\<lambda>s. s ''x'' mod s ''y'')) ;\n        (''x'' ::= (\\<lambda>s. s ''z''))))\n     \\<lceil>\\<lambda>s. s ''x'' = gcd x y\\<rceil>", "apply (rule rel_kat.H_while_inv, simp_all, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_kat.H\n     \\<lceil>\\<lambda>s.\n                gcd (s ''x'') (s ''y'') = gcd x y \\<and> 0 < s ''y''\\<rceil>\n     ((''z'' ::= (\\<lambda>s. s ''y'')) ;\n      (''y'' ::= (\\<lambda>s. s ''x'' mod s ''y'')) ;\n      (''x'' ::= (\\<lambda>s. s ''z'')))\n     \\<lceil>\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y\\<rceil>", "apply (intro rel_kat.H_seq)"], ["proof (prove)\ngoal (3 subgoals):\n 1. rel_kat.H ?r9 (''x'' ::= (\\<lambda>s. s ''z''))\n     \\<lceil>\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y\\<rceil>\n 2. rel_kat.H ?r10 (''y'' ::= (\\<lambda>s. s ''x'' mod s ''y'')) ?r9\n 3. rel_kat.H\n     \\<lceil>\\<lambda>s.\n                gcd (s ''x'') (s ''y'') = gcd x y \\<and> 0 < s ''y''\\<rceil>\n     (''z'' ::= (\\<lambda>s. s ''y'')) ?r10", "apply (subst H_assign, simp)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_kat.H\n     \\<lceil>\\<lambda>s.\n                gcd (s ''x'') (s ''y'') = gcd x y \\<and> 0 < s ''y''\\<rceil>\n     (''z'' ::= (\\<lambda>s. s ''y''))\n     \\<lceil>\\<lambda>s.\n                gcd ((s(''y'' := s ''x'' mod s ''y'',\n                        ''x'' := (s(''y'' := s ''x'' mod s ''y'')) ''z''))\n                      ''x'')\n                 ((s(''y'' := s ''x'' mod s ''y'',\n                     ''x'' := (s(''y'' := s ''x'' mod s ''y'')) ''z''))\n                   ''y'') =\n                gcd x y\\<rceil>", "apply (rule H_assign_var)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s.\n       gcd (s ''x'') (s ''y'') = gcd x y \\<and>\n       0 < s ''y'' \\<longrightarrow>\n       gcd ((s(''z'' := s ''y'',\n               ''y'' :=\n                 (s(''z'' := s ''y'')) ''x'' mod\n                 (s(''z'' := s ''y'')) ''y'',\n               ''x'' :=\n                 (s(''z'' := s ''y'',\n                    ''y'' :=\n                      (s(''z'' := s ''y'')) ''x'' mod\n                      (s(''z'' := s ''y'')) ''y''))\n                  ''z''))\n             ''x'')\n        ((s(''z'' := s ''y'',\n            ''y'' :=\n              (s(''z'' := s ''y'')) ''x'' mod (s(''z'' := s ''y'')) ''y'',\n            ''x'' :=\n              (s(''z'' := s ''y'',\n                 ''y'' :=\n                   (s(''z'' := s ''y'')) ''x'' mod\n                   (s(''z'' := s ''y'')) ''y''))\n               ''z''))\n          ''y'') =\n       gcd x y", "using gcd_red_nat"], ["proof (prove)\nusing this:\n  gcd ?x ?y = gcd ?y (?x mod ?y)\n\ngoal (1 subgoal):\n 1. \\<forall>s.\n       gcd (s ''x'') (s ''y'') = gcd x y \\<and>\n       0 < s ''y'' \\<longrightarrow>\n       gcd ((s(''z'' := s ''y'',\n               ''y'' :=\n                 (s(''z'' := s ''y'')) ''x'' mod\n                 (s(''z'' := s ''y'')) ''y'',\n               ''x'' :=\n                 (s(''z'' := s ''y'',\n                    ''y'' :=\n                      (s(''z'' := s ''y'')) ''x'' mod\n                      (s(''z'' := s ''y'')) ''y''))\n                  ''z''))\n             ''x'')\n        ((s(''z'' := s ''y'',\n            ''y'' :=\n              (s(''z'' := s ''y'')) ''x'' mod (s(''z'' := s ''y'')) ''y'',\n            ''x'' :=\n              (s(''z'' := s ''y'',\n                 ''y'' :=\n                   (s(''z'' := s ''y'')) ''x'' mod\n                   (s(''z'' := s ''y'')) ''y''))\n               ''z''))\n          ''y'') =\n       gcd x y", "by auto"], ["", "subsubsection \\<open>Definition of Refinement KAT\\<close>"], ["", "class rkat = kat +\n  fixes R :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a\"\n  assumes R1: \"H p (R p q) q\"\n  and R2: \"H p x q \\<Longrightarrow> x \\<le> R p q\"\n\nbegin"], ["", "subsubsection \\<open>Propositional Refinement Calculus\\<close>"], ["", "lemma R_skip: \"1 \\<le> R p p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) \\<le> R p p", "by (simp add: H_skip R2)"], ["", "lemma R_cons: \"t p \\<le> t p' \\<Longrightarrow> t q' \\<le> t q \\<Longrightarrow> R p' q' \\<le> R p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tp \\<le> tp'; tq' \\<le> tq\\<rbrakk>\n    \\<Longrightarrow> R p' q' \\<le> R p q", "by (simp add: H_cons R2 R1)"], ["", "lemma R_seq: \"(R p r) \\<cdot> (R r q) \\<le> R p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R p r \\<cdot> R r q \\<le> R p q", "using H_seq R2 R1"], ["proof (prove)\nusing this:\n  \\<lbrakk>H ?r ?y ?q; H ?p ?x ?r\\<rbrakk>\n  \\<Longrightarrow> H ?p (?x \\<cdot> ?y) ?q\n  H ?p ?x ?q \\<Longrightarrow> ?x \\<le> R ?p ?q\n  H ?p (R ?p ?q) ?q\n\ngoal (1 subgoal):\n 1. R p r \\<cdot> R r q \\<le> R p q", "by blast"], ["", "lemma R_cond: \"if v then (R (t v \\<cdot> t p) q) else (R (at v \\<cdot> t p) q) fi \\<le> R p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. if v then R (tv \\<cdot> tp) q else R (at v \\<cdot> tp) q fi \\<le> R p q", "by (metis H_cond R1 R2 t_comm t_n)"], ["", "lemma R_loop: \"while q do (R (t p \\<cdot> t q) p) od  \\<le> R p (t p \\<cdot> at q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. while q do R (tp \\<cdot> tq) p od \\<le> R p (tp \\<cdot> at q)", "by (simp add: H_loop R2 R1)"], ["", "end"], ["", "subsubsection \\<open>Soundness and Relation RKAT\\<close>"], ["", "definition rel_R :: \"'a rel \\<Rightarrow> 'a rel \\<Rightarrow> 'a rel\" where \n  \"rel_R P Q = \\<Union>{X. rel_kat.H P X Q}\""], ["", "interpretation rel_rkat: rkat Id \"{}\" \"(\\<union>)\"  \"(;)\" \"(\\<subseteq>)\" \"(\\<subset>)\" rtrancl rel_at rel_R"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.rkat Id {} (\\<union>) (;) (\\<subseteq>) (\\<subset>) rtrancl rel_at\n     rel_R", "by (standard, auto simp: rel_R_def rel_kat.H_def rel_kat.t_op_def rel_at_def)"], ["", "subsubsection \\<open>Assignment Laws\\<close>"], ["", "lemma R_assign: \"(\\<forall>s. P s \\<longrightarrow> Q (s (v := e s))) \\<Longrightarrow> (v ::= e) \\<subseteq> rel_R \\<lceil>P\\<rceil> \\<lceil>Q\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s. P s \\<longrightarrow> Q (s(v := e s)) \\<Longrightarrow>\n    v ::= e \\<subseteq> rel_R \\<lceil>P\\<rceil> \\<lceil>Q\\<rceil>", "by (simp add: H_assign_var rel_rkat.R2)"], ["", "lemma R_assignr: \"(\\<forall>s. Q' s \\<longrightarrow> Q (s (v := e s))) \\<Longrightarrow> (rel_R \\<lceil>P\\<rceil> \\<lceil>Q'\\<rceil>) ; (v ::= e) \\<subseteq> rel_R \\<lceil>P\\<rceil> \\<lceil>Q\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s. Q' s \\<longrightarrow> Q (s(v := e s)) \\<Longrightarrow>\n    rel_R \\<lceil>P\\<rceil> \\<lceil>Q'\\<rceil> ; (v ::= e)\n    \\<subseteq> rel_R \\<lceil>P\\<rceil> \\<lceil>Q\\<rceil>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>s. Q' s \\<longrightarrow> Q (s(v := e s)) \\<Longrightarrow>\n    rel_R \\<lceil>P\\<rceil> \\<lceil>Q'\\<rceil> ; (v ::= e)\n    \\<subseteq> rel_R \\<lceil>P\\<rceil> \\<lceil>Q\\<rceil>", "assume a1: \"\\<forall>s. Q' s \\<longrightarrow> Q (s(v := e s))\""], ["proof (state)\nthis:\n  \\<forall>s. Q' s \\<longrightarrow> Q (s(v := e s))\n\ngoal (1 subgoal):\n 1. \\<forall>s. Q' s \\<longrightarrow> Q (s(v := e s)) \\<Longrightarrow>\n    rel_R \\<lceil>P\\<rceil> \\<lceil>Q'\\<rceil> ; (v ::= e)\n    \\<subseteq> rel_R \\<lceil>P\\<rceil> \\<lceil>Q\\<rceil>", "have \"\\<forall>p pa cs f. \\<exists>fa. (p fa \\<or> cs ::= f \\<subseteq> rel_R \\<lceil>p\\<rceil> \\<lceil>pa\\<rceil>) \\<and> (\\<not> pa (fa(cs := f fa::'a)) \\<or> cs ::= f \\<subseteq> rel_R \\<lceil>p\\<rceil> \\<lceil>pa\\<rceil>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p pa cs f.\n       \\<exists>fa.\n          (p fa \\<or>\n           cs ::= f\n           \\<subseteq> rel_R \\<lceil>p\\<rceil> \\<lceil>pa\\<rceil>) \\<and>\n          (\\<not> pa (fa(cs := f fa)) \\<or>\n           cs ::= f \\<subseteq> rel_R \\<lceil>p\\<rceil> \\<lceil>pa\\<rceil>)", "using R_assign"], ["proof (prove)\nusing this:\n  \\<forall>s. ?P s \\<longrightarrow> ?Q (s(?v := ?e s)) \\<Longrightarrow>\n  ?v ::= ?e \\<subseteq> rel_R \\<lceil>?P\\<rceil> \\<lceil>?Q\\<rceil>\n\ngoal (1 subgoal):\n 1. \\<forall>p pa cs f.\n       \\<exists>fa.\n          (p fa \\<or>\n           cs ::= f\n           \\<subseteq> rel_R \\<lceil>p\\<rceil> \\<lceil>pa\\<rceil>) \\<and>\n          (\\<not> pa (fa(cs := f fa)) \\<or>\n           cs ::= f \\<subseteq> rel_R \\<lceil>p\\<rceil> \\<lceil>pa\\<rceil>)", "by blast"], ["proof (state)\nthis:\n  \\<forall>p pa cs f.\n     \\<exists>fa.\n        (p fa \\<or>\n         cs ::= f\n         \\<subseteq> rel_R \\<lceil>p\\<rceil> \\<lceil>pa\\<rceil>) \\<and>\n        (\\<not> pa (fa(cs := f fa)) \\<or>\n         cs ::= f \\<subseteq> rel_R \\<lceil>p\\<rceil> \\<lceil>pa\\<rceil>)\n\ngoal (1 subgoal):\n 1. \\<forall>s. Q' s \\<longrightarrow> Q (s(v := e s)) \\<Longrightarrow>\n    rel_R \\<lceil>P\\<rceil> \\<lceil>Q'\\<rceil> ; (v ::= e)\n    \\<subseteq> rel_R \\<lceil>P\\<rceil> \\<lceil>Q\\<rceil>", "hence \"v ::= e \\<subseteq> rel_R \\<lceil>Q'\\<rceil> \\<lceil>Q\\<rceil>\""], ["proof (prove)\nusing this:\n  \\<forall>p pa cs f.\n     \\<exists>fa.\n        (p fa \\<or>\n         cs ::= f\n         \\<subseteq> rel_R \\<lceil>p\\<rceil> \\<lceil>pa\\<rceil>) \\<and>\n        (\\<not> pa (fa(cs := f fa)) \\<or>\n         cs ::= f \\<subseteq> rel_R \\<lceil>p\\<rceil> \\<lceil>pa\\<rceil>)\n\ngoal (1 subgoal):\n 1. v ::= e \\<subseteq> rel_R \\<lceil>Q'\\<rceil> \\<lceil>Q\\<rceil>", "using a1"], ["proof (prove)\nusing this:\n  \\<forall>p pa cs f.\n     \\<exists>fa.\n        (p fa \\<or>\n         cs ::= f\n         \\<subseteq> rel_R \\<lceil>p\\<rceil> \\<lceil>pa\\<rceil>) \\<and>\n        (\\<not> pa (fa(cs := f fa)) \\<or>\n         cs ::= f \\<subseteq> rel_R \\<lceil>p\\<rceil> \\<lceil>pa\\<rceil>)\n  \\<forall>s. Q' s \\<longrightarrow> Q (s(v := e s))\n\ngoal (1 subgoal):\n 1. v ::= e \\<subseteq> rel_R \\<lceil>Q'\\<rceil> \\<lceil>Q\\<rceil>", "by blast"], ["proof (state)\nthis:\n  v ::= e \\<subseteq> rel_R \\<lceil>Q'\\<rceil> \\<lceil>Q\\<rceil>\n\ngoal (1 subgoal):\n 1. \\<forall>s. Q' s \\<longrightarrow> Q (s(v := e s)) \\<Longrightarrow>\n    rel_R \\<lceil>P\\<rceil> \\<lceil>Q'\\<rceil> ; (v ::= e)\n    \\<subseteq> rel_R \\<lceil>P\\<rceil> \\<lceil>Q\\<rceil>", "thus ?thesis"], ["proof (prove)\nusing this:\n  v ::= e \\<subseteq> rel_R \\<lceil>Q'\\<rceil> \\<lceil>Q\\<rceil>\n\ngoal (1 subgoal):\n 1. rel_R \\<lceil>P\\<rceil> \\<lceil>Q'\\<rceil> ; (v ::= e)\n    \\<subseteq> rel_R \\<lceil>P\\<rceil> \\<lceil>Q\\<rceil>", "by (meson dual_order.trans rel_d.mult_isol rel_rkat.R_seq)"], ["proof (state)\nthis:\n  rel_R \\<lceil>P\\<rceil> \\<lceil>Q'\\<rceil> ; (v ::= e)\n  \\<subseteq> rel_R \\<lceil>P\\<rceil> \\<lceil>Q\\<rceil>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma R_assignl: \"(\\<forall>s. P s \\<longrightarrow> P' (s (v := e s))) \\<Longrightarrow> (v ::= e) ; (rel_R \\<lceil>P'\\<rceil> \\<lceil>Q\\<rceil>) \\<subseteq> rel_R \\<lceil>P\\<rceil> \\<lceil>Q\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s. P s \\<longrightarrow> P' (s(v := e s)) \\<Longrightarrow>\n    (v ::= e) ; rel_R \\<lceil>P'\\<rceil> \\<lceil>Q\\<rceil>\n    \\<subseteq> rel_R \\<lceil>P\\<rceil> \\<lceil>Q\\<rceil>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>s. P s \\<longrightarrow> P' (s(v := e s)) \\<Longrightarrow>\n    (v ::= e) ; rel_R \\<lceil>P'\\<rceil> \\<lceil>Q\\<rceil>\n    \\<subseteq> rel_R \\<lceil>P\\<rceil> \\<lceil>Q\\<rceil>", "assume a1: \"\\<forall>s. P s \\<longrightarrow> P' (s(v := e s))\""], ["proof (state)\nthis:\n  \\<forall>s. P s \\<longrightarrow> P' (s(v := e s))\n\ngoal (1 subgoal):\n 1. \\<forall>s. P s \\<longrightarrow> P' (s(v := e s)) \\<Longrightarrow>\n    (v ::= e) ; rel_R \\<lceil>P'\\<rceil> \\<lceil>Q\\<rceil>\n    \\<subseteq> rel_R \\<lceil>P\\<rceil> \\<lceil>Q\\<rceil>", "have \"\\<forall>p pa cs f. \\<exists>fa. (p fa \\<or> cs ::= f \\<subseteq> rel_R \\<lceil>p\\<rceil> \\<lceil>pa\\<rceil>) \\<and> (\\<not> pa (fa(cs := f fa::'a)) \\<or> cs ::= f \\<subseteq> rel_R \\<lceil>p\\<rceil> \\<lceil>pa\\<rceil>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p pa cs f.\n       \\<exists>fa.\n          (p fa \\<or>\n           cs ::= f\n           \\<subseteq> rel_R \\<lceil>p\\<rceil> \\<lceil>pa\\<rceil>) \\<and>\n          (\\<not> pa (fa(cs := f fa)) \\<or>\n           cs ::= f \\<subseteq> rel_R \\<lceil>p\\<rceil> \\<lceil>pa\\<rceil>)", "using R_assign"], ["proof (prove)\nusing this:\n  \\<forall>s. ?P s \\<longrightarrow> ?Q (s(?v := ?e s)) \\<Longrightarrow>\n  ?v ::= ?e \\<subseteq> rel_R \\<lceil>?P\\<rceil> \\<lceil>?Q\\<rceil>\n\ngoal (1 subgoal):\n 1. \\<forall>p pa cs f.\n       \\<exists>fa.\n          (p fa \\<or>\n           cs ::= f\n           \\<subseteq> rel_R \\<lceil>p\\<rceil> \\<lceil>pa\\<rceil>) \\<and>\n          (\\<not> pa (fa(cs := f fa)) \\<or>\n           cs ::= f \\<subseteq> rel_R \\<lceil>p\\<rceil> \\<lceil>pa\\<rceil>)", "by blast"], ["proof (state)\nthis:\n  \\<forall>p pa cs f.\n     \\<exists>fa.\n        (p fa \\<or>\n         cs ::= f\n         \\<subseteq> rel_R \\<lceil>p\\<rceil> \\<lceil>pa\\<rceil>) \\<and>\n        (\\<not> pa (fa(cs := f fa)) \\<or>\n         cs ::= f \\<subseteq> rel_R \\<lceil>p\\<rceil> \\<lceil>pa\\<rceil>)\n\ngoal (1 subgoal):\n 1. \\<forall>s. P s \\<longrightarrow> P' (s(v := e s)) \\<Longrightarrow>\n    (v ::= e) ; rel_R \\<lceil>P'\\<rceil> \\<lceil>Q\\<rceil>\n    \\<subseteq> rel_R \\<lceil>P\\<rceil> \\<lceil>Q\\<rceil>", "then"], ["proof (chain)\npicking this:\n  \\<forall>p pa cs f.\n     \\<exists>fa.\n        (p fa \\<or>\n         cs ::= f\n         \\<subseteq> rel_R \\<lceil>p\\<rceil> \\<lceil>pa\\<rceil>) \\<and>\n        (\\<not> pa (fa(cs := f fa)) \\<or>\n         cs ::= f \\<subseteq> rel_R \\<lceil>p\\<rceil> \\<lceil>pa\\<rceil>)", "have \"v ::= e \\<subseteq> rel_R \\<lceil>P\\<rceil> \\<lceil>P'\\<rceil>\""], ["proof (prove)\nusing this:\n  \\<forall>p pa cs f.\n     \\<exists>fa.\n        (p fa \\<or>\n         cs ::= f\n         \\<subseteq> rel_R \\<lceil>p\\<rceil> \\<lceil>pa\\<rceil>) \\<and>\n        (\\<not> pa (fa(cs := f fa)) \\<or>\n         cs ::= f \\<subseteq> rel_R \\<lceil>p\\<rceil> \\<lceil>pa\\<rceil>)\n\ngoal (1 subgoal):\n 1. v ::= e \\<subseteq> rel_R \\<lceil>P\\<rceil> \\<lceil>P'\\<rceil>", "using a1"], ["proof (prove)\nusing this:\n  \\<forall>p pa cs f.\n     \\<exists>fa.\n        (p fa \\<or>\n         cs ::= f\n         \\<subseteq> rel_R \\<lceil>p\\<rceil> \\<lceil>pa\\<rceil>) \\<and>\n        (\\<not> pa (fa(cs := f fa)) \\<or>\n         cs ::= f \\<subseteq> rel_R \\<lceil>p\\<rceil> \\<lceil>pa\\<rceil>)\n  \\<forall>s. P s \\<longrightarrow> P' (s(v := e s))\n\ngoal (1 subgoal):\n 1. v ::= e \\<subseteq> rel_R \\<lceil>P\\<rceil> \\<lceil>P'\\<rceil>", "by blast"], ["proof (state)\nthis:\n  v ::= e \\<subseteq> rel_R \\<lceil>P\\<rceil> \\<lceil>P'\\<rceil>\n\ngoal (1 subgoal):\n 1. \\<forall>s. P s \\<longrightarrow> P' (s(v := e s)) \\<Longrightarrow>\n    (v ::= e) ; rel_R \\<lceil>P'\\<rceil> \\<lceil>Q\\<rceil>\n    \\<subseteq> rel_R \\<lceil>P\\<rceil> \\<lceil>Q\\<rceil>", "then"], ["proof (chain)\npicking this:\n  v ::= e \\<subseteq> rel_R \\<lceil>P\\<rceil> \\<lceil>P'\\<rceil>", "show ?thesis"], ["proof (prove)\nusing this:\n  v ::= e \\<subseteq> rel_R \\<lceil>P\\<rceil> \\<lceil>P'\\<rceil>\n\ngoal (1 subgoal):\n 1. (v ::= e) ; rel_R \\<lceil>P'\\<rceil> \\<lceil>Q\\<rceil>\n    \\<subseteq> rel_R \\<lceil>P\\<rceil> \\<lceil>Q\\<rceil>", "by (meson dual_order.trans rel_d.mult_isor rel_rkat.R_seq)"], ["proof (state)\nthis:\n  (v ::= e) ; rel_R \\<lceil>P'\\<rceil> \\<lceil>Q\\<rceil>\n  \\<subseteq> rel_R \\<lceil>P\\<rceil> \\<lceil>Q\\<rceil>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Refinement Example\\<close>"], ["", "lemma var_swap_ref1: \n  \"rel_R \\<lceil>\\<lambda>s. s ''x'' = a \\<and> s ''y'' = b\\<rceil> \\<lceil>\\<lambda>s. s ''x'' = b \\<and> s ''y'' = a\\<rceil> \n   \\<supseteq> (''z'' ::= (\\<lambda>s. s ''x'')); rel_R \\<lceil>\\<lambda>s. s ''z'' = a \\<and> s ''y'' = b\\<rceil> \\<lceil>\\<lambda>s. s ''x'' = b \\<and> s ''y'' = a\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (''z'' ::= (\\<lambda>s. s ''x'')) ;\n    rel_R \\<lceil>\\<lambda>s. s ''z'' = a \\<and> s ''y'' = b\\<rceil>\n     \\<lceil>\\<lambda>s. s ''x'' = b \\<and> s ''y'' = a\\<rceil>\n    \\<subseteq> rel_R\n                 \\<lceil>\\<lambda>s. s ''x'' = a \\<and> s ''y'' = b\\<rceil>\n                 \\<lceil>\\<lambda>s. s ''x'' = b \\<and> s ''y'' = a\\<rceil>", "by (rule R_assignl, auto)"], ["", "lemma var_swap_ref2: \n  \"rel_R \\<lceil>\\<lambda>s. s ''z'' = a \\<and> s ''y'' = b\\<rceil> \\<lceil>\\<lambda>s. s ''x'' = b \\<and> s ''y'' = a\\<rceil> \n   \\<supseteq> (''x'' ::= (\\<lambda>s. s ''y'')); rel_R \\<lceil>\\<lambda>s. s ''z'' = a \\<and> s ''x'' = b\\<rceil> \\<lceil>\\<lambda>s. s ''x'' = b \\<and> s ''y'' = a\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (''x'' ::= (\\<lambda>s. s ''y'')) ;\n    rel_R \\<lceil>\\<lambda>s. s ''z'' = a \\<and> s ''x'' = b\\<rceil>\n     \\<lceil>\\<lambda>s. s ''x'' = b \\<and> s ''y'' = a\\<rceil>\n    \\<subseteq> rel_R\n                 \\<lceil>\\<lambda>s. s ''z'' = a \\<and> s ''y'' = b\\<rceil>\n                 \\<lceil>\\<lambda>s. s ''x'' = b \\<and> s ''y'' = a\\<rceil>", "by (rule R_assignl, auto)"], ["", "lemma var_swap_ref3:  \n  \"rel_R \\<lceil>\\<lambda>s. s ''z'' = a \\<and> s ''x'' = b\\<rceil> \\<lceil>\\<lambda>s. s ''x'' = b \\<and> s ''y'' = a\\<rceil> \n   \\<supseteq> (''y'' ::= (\\<lambda>s. s ''z'')); rel_R \\<lceil>\\<lambda>s. s ''x'' = b \\<and> s ''y'' = a\\<rceil> \\<lceil>\\<lambda>s. s ''x'' = b \\<and> s ''y'' = a\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (''y'' ::= (\\<lambda>s. s ''z'')) ;\n    rel_R \\<lceil>\\<lambda>s. s ''x'' = b \\<and> s ''y'' = a\\<rceil>\n     \\<lceil>\\<lambda>s. s ''x'' = b \\<and> s ''y'' = a\\<rceil>\n    \\<subseteq> rel_R\n                 \\<lceil>\\<lambda>s. s ''z'' = a \\<and> s ''x'' = b\\<rceil>\n                 \\<lceil>\\<lambda>s. s ''x'' = b \\<and> s ''y'' = a\\<rceil>", "by (rule R_assignl, auto)"], ["", "lemma var_swap_ref_var: \n  \"rel_R \\<lceil>\\<lambda>s. s ''x'' = a \\<and> s ''y'' = b\\<rceil> \\<lceil>\\<lambda>s. s ''x'' = b \\<and> s ''y'' = a\\<rceil> \n   \\<supseteq> (''z'' ::= (\\<lambda>s. s ''x'')); (''x'' ::= (\\<lambda>s. s ''y'')); (''y'' ::= (\\<lambda>s. s ''z''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (''z'' ::= (\\<lambda>s. s ''x'')) ; (''x'' ::= (\\<lambda>s. s ''y'')) ;\n    (''y'' ::= (\\<lambda>s. s ''z''))\n    \\<subseteq> rel_R\n                 \\<lceil>\\<lambda>s. s ''x'' = a \\<and> s ''y'' = b\\<rceil>\n                 \\<lceil>\\<lambda>s. s ''x'' = b \\<and> s ''y'' = a\\<rceil>", "using var_swap_ref1 var_swap_ref2 var_swap_ref3 rel_rkat.R_skip"], ["proof (prove)\nusing this:\n  (''z'' ::= (\\<lambda>s. s ''x'')) ;\n  rel_R \\<lceil>\\<lambda>s. s ''z'' = ?a \\<and> s ''y'' = ?b\\<rceil>\n   \\<lceil>\\<lambda>s. s ''x'' = ?b \\<and> s ''y'' = ?a\\<rceil>\n  \\<subseteq> rel_R\n               \\<lceil>\\<lambda>s. s ''x'' = ?a \\<and> s ''y'' = ?b\\<rceil>\n               \\<lceil>\\<lambda>s. s ''x'' = ?b \\<and> s ''y'' = ?a\\<rceil>\n  (''x'' ::= (\\<lambda>s. s ''y'')) ;\n  rel_R \\<lceil>\\<lambda>s. s ''z'' = ?a \\<and> s ''x'' = ?b\\<rceil>\n   \\<lceil>\\<lambda>s. s ''x'' = ?b \\<and> s ''y'' = ?a\\<rceil>\n  \\<subseteq> rel_R\n               \\<lceil>\\<lambda>s. s ''z'' = ?a \\<and> s ''y'' = ?b\\<rceil>\n               \\<lceil>\\<lambda>s. s ''x'' = ?b \\<and> s ''y'' = ?a\\<rceil>\n  (''y'' ::= (\\<lambda>s. s ''z'')) ;\n  rel_R \\<lceil>\\<lambda>s. s ''x'' = ?b \\<and> s ''y'' = ?a\\<rceil>\n   \\<lceil>\\<lambda>s. s ''x'' = ?b \\<and> s ''y'' = ?a\\<rceil>\n  \\<subseteq> rel_R\n               \\<lceil>\\<lambda>s. s ''z'' = ?a \\<and> s ''x'' = ?b\\<rceil>\n               \\<lceil>\\<lambda>s. s ''x'' = ?b \\<and> s ''y'' = ?a\\<rceil>\n  Id \\<subseteq> rel_R ?p ?p\n\ngoal (1 subgoal):\n 1. (''z'' ::= (\\<lambda>s. s ''x'')) ; (''x'' ::= (\\<lambda>s. s ''y'')) ;\n    (''y'' ::= (\\<lambda>s. s ''z''))\n    \\<subseteq> rel_R\n                 \\<lceil>\\<lambda>s. s ''x'' = a \\<and> s ''y'' = b\\<rceil>\n                 \\<lceil>\\<lambda>s. s ''x'' = b \\<and> s ''y'' = a\\<rceil>", "by fastforce"], ["", "end"]]}