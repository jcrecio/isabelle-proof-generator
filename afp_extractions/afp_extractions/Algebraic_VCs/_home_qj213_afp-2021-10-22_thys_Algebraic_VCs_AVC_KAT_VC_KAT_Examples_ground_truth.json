{"file_name": "/home/qj213/afp-2021-10-22/thys/Algebraic_VCs/AVC_KAT/VC_KAT_Examples.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Algebraic_VCs", "problem_names": ["lemma euclid:\n  \"PRE (\\<lambda>s::nat store. s ''x'' = x \\<and> s ''y'' = y)\n   (WHILE (\\<lambda>s. s ''y'' \\<noteq> 0) INV (\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y) \n    DO\n     (''z'' ::= (\\<lambda>s. s ''y''));\n     (''y'' ::= (\\<lambda>s. s ''x'' mod s ''y''));\n     (''x'' ::= (\\<lambda>s. s ''z''))\n    OD)\n   POST (\\<lambda>s. s ''x'' = gcd x y)\"", "lemma maximum: \n  \"PRE (\\<lambda>s:: nat store. True)\n   (IF (\\<lambda>s. s ''x'' \\<ge> s ''y'') \n    THEN (''z'' ::= (\\<lambda>s. s ''x''))\n    ELSE (''z'' ::= (\\<lambda>s. s ''y''))\n    FI)\n   POST (\\<lambda>s. s ''z'' = max (s ''x'') (s ''y''))\"", "lemma integer_division: \n  \"PRE (\\<lambda>s::nat store. s ''x'' \\<ge> 0)\n    (''q'' ::= (\\<lambda>s. 0)); \n    (''r'' ::= (\\<lambda>s. s ''x''));\n    (WHILE (\\<lambda>s. s ''y'' \\<le> s ''r'') INV (\\<lambda>s. s ''x'' = s ''q'' * s ''y'' + s ''r'' \\<and> s ''r'' \\<ge> 0)\n     DO\n      (''q'' ::= (\\<lambda>s. s ''q'' + 1));\n      (''r'' ::= (\\<lambda>s. s ''r'' - s ''y''))\n      OD)\n   POST (\\<lambda>s. s ''x'' = s ''q'' * s ''y'' + s ''r'' \\<and> s ''r'' \\<ge> 0 \\<and> s ''r'' < s ''y'')\"", "lemma imp_reverse:\n  \"PRE (\\<lambda>s:: 'a list store. s ''x'' = X)\n   (''y'' ::= (\\<lambda>s. []));\n   (WHILE (\\<lambda>s. s ''x'' \\<noteq> []) INV (\\<lambda>s. rev (s ''x'') @ s ''y'' = rev X)\n    DO \n     (''y'' ::= (\\<lambda>s. hd (s ''x'') # s ''y'')); \n     (''x'' ::= (\\<lambda>s. tl (s ''x'')))\n    OD) \n   POST (\\<lambda>s. s ''y''= rev X )\""], "translations": [["", "lemma euclid:\n  \"PRE (\\<lambda>s::nat store. s ''x'' = x \\<and> s ''y'' = y)\n   (WHILE (\\<lambda>s. s ''y'' \\<noteq> 0) INV (\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y) \n    DO\n     (''z'' ::= (\\<lambda>s. s ''y''));\n     (''y'' ::= (\\<lambda>s. s ''x'' mod s ''y''));\n     (''x'' ::= (\\<lambda>s. s ''z''))\n    OD)\n   POST (\\<lambda>s. s ''x'' = gcd x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PRE (\\<lambda>s.\n            s ''x'' = x \\<and>\n            s ''y'' =\n            y) (WHILE (\\<lambda>s.\n                          s ''y'' \\<noteq>\n                          0) INV (\\<lambda>s.\n                                     gcd (s ''x'') (s ''y'') =\n                                     gcd x\ny) DO (''z'' ::= (\\<lambda>s. s ''y'')) ;\n      (''y'' ::= (\\<lambda>s. s ''x'' mod s ''y'')) ;\n      (''x'' ::= (\\<lambda>s.\n                     s ''z'')) OD) POST (\\<lambda>s. s ''x'' = gcd x y)", "apply (rule sH_while_inv)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>s.\n       s ''x'' = x \\<and> s ''y'' = y \\<longrightarrow>\n       gcd (s ''x'') (s ''y'') = gcd x y\n 2. \\<forall>s.\n       gcd (s ''x'') (s ''y'') = gcd x y \\<and>\n       \\<not> s ''y'' \\<noteq> 0 \\<longrightarrow>\n       s ''x'' = gcd x y\n 3. PRE (\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y) \\<sqinter>\n        (\\<lambda>s.\n            s ''y'' \\<noteq>\n            0) (''z'' ::= (\\<lambda>s. s ''y'')) ;\n               (''y'' ::= (\\<lambda>s. s ''x'' mod s ''y'')) ;\n               (''x'' ::= (\\<lambda>s.\n                              s ''z'')) POST (\\<lambda>s.\n           gcd (s ''x'') (s ''y'') = gcd x y)", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>s.\n       gcd (s ''x'') (s ''y'') = gcd x y \\<and>\n       s ''y'' = 0 \\<longrightarrow>\n       s ''x'' = gcd x y\n 2. PRE (\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y) \\<sqinter>\n        (\\<lambda>s.\n            0 < s ''y'') (''z'' ::= (\\<lambda>s. s ''y'')) ;\n                         (''y'' ::= (\\<lambda>s. s ''x'' mod s ''y'')) ;\n                         (''x'' ::= (\\<lambda>s.\n  s ''z'')) POST (\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y)", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. PRE (\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y) \\<sqinter>\n        (\\<lambda>s.\n            0 < s ''y'') (''z'' ::= (\\<lambda>s. s ''y'')) ;\n                         (''y'' ::= (\\<lambda>s. s ''x'' mod s ''y'')) ;\n                         (''x'' ::= (\\<lambda>s.\n  s ''z'')) POST (\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y)", "apply (intro rel_kat.H_seq)"], ["proof (prove)\ngoal (3 subgoals):\n 1. rel_kat.H ?r9 (''x'' ::= (\\<lambda>s. s ''z''))\n     \\<lceil>\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y\\<rceil>\n 2. rel_kat.H ?r10 (''y'' ::= (\\<lambda>s. s ''x'' mod s ''y'')) ?r9\n 3. rel_kat.H\n     \\<lceil>(\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y) \\<sqinter>\n             (\\<lambda>s. 0 < s ''y'')\\<rceil>\n     (''z'' ::= (\\<lambda>s. s ''y'')) ?r10", "apply (subst H_assign, simp)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. PRE (\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y) \\<sqinter>\n        (\\<lambda>s.\n            0 < s ''y'') (''z'' ::= (\\<lambda>s.\n  s ''y'')) POST (\\<lambda>s.\n                     gcd ((s(''y'' := s ''x'' mod s ''y'',\n                             ''x'' :=\n                               (s(''y'' := s ''x'' mod s ''y'')) ''z''))\n                           ''x'')\n                      ((s(''y'' := s ''x'' mod s ''y'',\n                          ''x'' := (s(''y'' := s ''x'' mod s ''y'')) ''z''))\n                        ''y'') =\n                     gcd x y)", "apply (intro H_assign_var)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s.\n       ((\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y) \\<sqinter>\n        (\\<lambda>s. 0 < s ''y''))\n        s \\<longrightarrow>\n       gcd ((s(''z'' := s ''y'',\n               ''y'' :=\n                 (s(''z'' := s ''y'')) ''x'' mod\n                 (s(''z'' := s ''y'')) ''y'',\n               ''x'' :=\n                 (s(''z'' := s ''y'',\n                    ''y'' :=\n                      (s(''z'' := s ''y'')) ''x'' mod\n                      (s(''z'' := s ''y'')) ''y''))\n                  ''z''))\n             ''x'')\n        ((s(''z'' := s ''y'',\n            ''y'' :=\n              (s(''z'' := s ''y'')) ''x'' mod (s(''z'' := s ''y'')) ''y'',\n            ''x'' :=\n              (s(''z'' := s ''y'',\n                 ''y'' :=\n                   (s(''z'' := s ''y'')) ''x'' mod\n                   (s(''z'' := s ''y'')) ''y''))\n               ''z''))\n          ''y'') =\n       gcd x y", "using gcd_red_nat"], ["proof (prove)\nusing this:\n  gcd ?x ?y = gcd ?y (?x mod ?y)\n\ngoal (1 subgoal):\n 1. \\<forall>s.\n       ((\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y) \\<sqinter>\n        (\\<lambda>s. 0 < s ''y''))\n        s \\<longrightarrow>\n       gcd ((s(''z'' := s ''y'',\n               ''y'' :=\n                 (s(''z'' := s ''y'')) ''x'' mod\n                 (s(''z'' := s ''y'')) ''y'',\n               ''x'' :=\n                 (s(''z'' := s ''y'',\n                    ''y'' :=\n                      (s(''z'' := s ''y'')) ''x'' mod\n                      (s(''z'' := s ''y'')) ''y''))\n                  ''z''))\n             ''x'')\n        ((s(''z'' := s ''y'',\n            ''y'' :=\n              (s(''z'' := s ''y'')) ''x'' mod (s(''z'' := s ''y'')) ''y'',\n            ''x'' :=\n              (s(''z'' := s ''y'',\n                 ''y'' :=\n                   (s(''z'' := s ''y'')) ''x'' mod\n                   (s(''z'' := s ''y'')) ''y''))\n               ''z''))\n          ''y'') =\n       gcd x y", "by auto"], ["", "lemma maximum: \n  \"PRE (\\<lambda>s:: nat store. True)\n   (IF (\\<lambda>s. s ''x'' \\<ge> s ''y'') \n    THEN (''z'' ::= (\\<lambda>s. s ''x''))\n    ELSE (''z'' ::= (\\<lambda>s. s ''y''))\n    FI)\n   POST (\\<lambda>s. s ''z'' = max (s ''x'') (s ''y''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PRE (\\<lambda>s.\n            True) (IF (\\<lambda>s.\n                          s ''y''\n                          \\<le> s ''x'') THEN (''z'' ::= (\\<lambda>s.\n                       s ''x'')) ELSE (''z'' ::= (\\<lambda>s.\n               s ''y'')) FI) POST (\\<lambda>s.\ns ''z'' = max (s ''x'') (s ''y''))", "by auto"], ["", "lemma integer_division: \n  \"PRE (\\<lambda>s::nat store. s ''x'' \\<ge> 0)\n    (''q'' ::= (\\<lambda>s. 0)); \n    (''r'' ::= (\\<lambda>s. s ''x''));\n    (WHILE (\\<lambda>s. s ''y'' \\<le> s ''r'') INV (\\<lambda>s. s ''x'' = s ''q'' * s ''y'' + s ''r'' \\<and> s ''r'' \\<ge> 0)\n     DO\n      (''q'' ::= (\\<lambda>s. s ''q'' + 1));\n      (''r'' ::= (\\<lambda>s. s ''r'' - s ''y''))\n      OD)\n   POST (\\<lambda>s. s ''x'' = s ''q'' * s ''y'' + s ''r'' \\<and> s ''r'' \\<ge> 0 \\<and> s ''r'' < s ''y'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PRE (\\<lambda>s.\n            0 \\<le> s ''x'') (''q'' ::= (\\<lambda>s. 0)) ;\n                             (''r'' ::= (\\<lambda>s. s ''x'')) ;\n                             (WHILE (\\<lambda>s.\n  s ''y''\n  \\<le> s ''r'') INV (\\<lambda>s.\n                         s ''x'' = s ''q'' \\<cdot> s ''y'' + s ''r'' \\<and>\n                         0 \\<le> s ''r'') DO (''q'' ::= (\\<lambda>s.\n                      s ''q'' + 1)) ;\n       (''r'' ::= (\\<lambda>s.\n                      s ''r'' -\n                      s ''y'')) OD) POST (\\<lambda>s.\n       s ''x'' = s ''q'' \\<cdot> s ''y'' + s ''r'' \\<and>\n       0 \\<le> s ''r'' \\<and> s ''r'' < s ''y'')", "apply (intro rel_kat.H_seq, subst sH_while_inv, simp_all)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<forall>s.\n       ?P3 s \\<longrightarrow> s ''x'' = s ''q'' \\<cdot> s ''y'' + s ''r''\n 2. PRE (\\<lambda>s. s ''x'' = s ''q'' \\<cdot> s ''y'' + s ''r'') \\<sqinter>\n        (\\<lambda>s.\n            s ''y''\n            \\<le> s ''r'') (''q'' ::= (\\<lambda>s. Suc (s ''q''))) ;\n                           (''r'' ::= (\\<lambda>s.\n    s ''r'' -\n    s ''y'')) POST (\\<lambda>s. s ''x'' = s ''q'' \\<cdot> s ''y'' + s ''r'')\n 3. rel_kat.H ?r1 (''r'' ::= (\\<lambda>s. s ''x'')) \\<lceil>?P3\\<rceil>\n 4. rel_kat.H \\<lceil>\\<lambda>s. True\\<rceil> (''q'' ::= (\\<lambda>s. 0))\n     ?r1", "apply auto[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. PRE (\\<lambda>s. s ''x'' = s ''q'' \\<cdot> s ''y'' + s ''r'') \\<sqinter>\n        (\\<lambda>s.\n            s ''y''\n            \\<le> s ''r'') (''q'' ::= (\\<lambda>s. Suc (s ''q''))) ;\n                           (''r'' ::= (\\<lambda>s.\n    s ''r'' -\n    s ''y'')) POST (\\<lambda>s. s ''x'' = s ''q'' \\<cdot> s ''y'' + s ''r'')\n 2. rel_kat.H ?r1 (''r'' ::= (\\<lambda>s. s ''x''))\n     \\<lceil>\\<lambda>s. s ''x'' = s ''q'' \\<cdot> s ''y'' + s ''r''\\<rceil>\n 3. rel_kat.H \\<lceil>\\<lambda>s. True\\<rceil> (''q'' ::= (\\<lambda>s. 0))\n     ?r1", "apply (intro rel_kat.H_seq)"], ["proof (prove)\ngoal (4 subgoals):\n 1. rel_kat.H ?r23 (''r'' ::= (\\<lambda>s. s ''r'' - s ''y''))\n     \\<lceil>\\<lambda>s. s ''x'' = s ''q'' \\<cdot> s ''y'' + s ''r''\\<rceil>\n 2. rel_kat.H\n     \\<lceil>(\\<lambda>s.\n                 s ''x'' = s ''q'' \\<cdot> s ''y'' + s ''r'') \\<sqinter>\n             (\\<lambda>s. s ''y'' \\<le> s ''r'')\\<rceil>\n     (''q'' ::= (\\<lambda>s. Suc (s ''q''))) ?r23\n 3. rel_kat.H ?r1 (''r'' ::= (\\<lambda>s. s ''x''))\n     \\<lceil>\\<lambda>s. s ''x'' = s ''q'' \\<cdot> s ''y'' + s ''r''\\<rceil>\n 4. rel_kat.H \\<lceil>\\<lambda>s. True\\<rceil> (''q'' ::= (\\<lambda>s. 0))\n     ?r1", "by (subst H_assign, simp_all)+"], ["", "lemma imp_reverse:\n  \"PRE (\\<lambda>s:: 'a list store. s ''x'' = X)\n   (''y'' ::= (\\<lambda>s. []));\n   (WHILE (\\<lambda>s. s ''x'' \\<noteq> []) INV (\\<lambda>s. rev (s ''x'') @ s ''y'' = rev X)\n    DO \n     (''y'' ::= (\\<lambda>s. hd (s ''x'') # s ''y'')); \n     (''x'' ::= (\\<lambda>s. tl (s ''x'')))\n    OD) \n   POST (\\<lambda>s. s ''y''= rev X )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PRE (\\<lambda>s.\n            s ''x'' =\n            X) (''y'' ::= (\\<lambda>s. [])) ;\n               (WHILE (\\<lambda>s.\n                          s ''x'' \\<noteq>\n                          []) INV (\\<lambda>s.\nrev (s ''x'') @ s ''y'' =\nrev X) DO (''y'' ::= (\\<lambda>s. hd (s ''x'') # s ''y'')) ;\n          (''x'' ::= (\\<lambda>s.\n                         tl (s ''x''))) OD) POST (\\<lambda>s.\n               s ''y'' = rev X)", "apply (intro rel_kat.H_seq, rule sH_while_inv)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<forall>s. ?P1 s \\<longrightarrow> rev (s ''x'') @ s ''y'' = rev X\n 2. \\<forall>s.\n       rev (s ''x'') @ s ''y'' = rev X \\<and>\n       \\<not> s ''x'' \\<noteq> [] \\<longrightarrow>\n       s ''y'' = rev X\n 3. PRE (\\<lambda>s. rev (s ''x'') @ s ''y'' = rev X) \\<sqinter>\n        (\\<lambda>s.\n            s ''x'' \\<noteq>\n            []) (''y'' ::= (\\<lambda>s. hd (s ''x'') # s ''y'')) ;\n                (''x'' ::= (\\<lambda>s.\n                               tl (s ''x''))) POST (\\<lambda>s.\n                 rev (s ''x'') @ s ''y'' = rev X)\n 4. PRE (\\<lambda>s. s ''x'' = X) (''y'' ::= (\\<lambda>s. [])) POST ?P1", "apply auto[2]"], ["proof (prove)\ngoal (2 subgoals):\n 1. PRE (\\<lambda>s. rev (s ''x'') @ s ''y'' = rev X) \\<sqinter>\n        (\\<lambda>s.\n            s ''x'' \\<noteq>\n            []) (''y'' ::= (\\<lambda>s. hd (s ''x'') # s ''y'')) ;\n                (''x'' ::= (\\<lambda>s.\n                               tl (s ''x''))) POST (\\<lambda>s.\n                 rev (s ''x'') @ s ''y'' = rev X)\n 2. PRE (\\<lambda>s.\n            s ''x'' =\n            X) (''y'' ::= (\\<lambda>s.\n                              [])) POST (\\<lambda>s.\n      rev (s ''x'') @ s ''y'' = rev X)", "apply (rule rel_kat.H_seq, rule H_assign_var)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>s.\n       ?P17 s \\<longrightarrow>\n       rev ((s(''x'' := tl (s ''x''))) ''x'') @\n       (s(''x'' := tl (s ''x''))) ''y'' =\n       rev X\n 2. PRE (\\<lambda>s. rev (s ''x'') @ s ''y'' = rev X) \\<sqinter>\n        (\\<lambda>s.\n            s ''x'' \\<noteq>\n            []) (''y'' ::= (\\<lambda>s. hd (s ''x'') # s ''y'')) POST ?P17\n 3. PRE (\\<lambda>s.\n            s ''x'' =\n            X) (''y'' ::= (\\<lambda>s.\n                              [])) POST (\\<lambda>s.\n      rev (s ''x'') @ s ''y'' = rev X)", "apply auto[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. PRE (\\<lambda>s. rev (s ''x'') @ s ''y'' = rev X) \\<sqinter>\n        (\\<lambda>s.\n            s ''x'' \\<noteq>\n            []) (''y'' ::= (\\<lambda>s.\n                               hd (s ''x'') #\n                               s ''y'')) POST (\\<lambda>s.\n            rev (tl (s ''x'')) @ s ''y'' = rev X)\n 2. PRE (\\<lambda>s.\n            s ''x'' =\n            X) (''y'' ::= (\\<lambda>s.\n                              [])) POST (\\<lambda>s.\n      rev (s ''x'') @ s ''y'' = rev X)", "apply (rule H_assign_var)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>s.\n       ((\\<lambda>s. rev (s ''x'') @ s ''y'' = rev X) \\<sqinter>\n        (\\<lambda>s. s ''x'' \\<noteq> []))\n        s \\<longrightarrow>\n       rev (tl ((s(''y'' := hd (s ''x'') # s ''y'')) ''x'')) @\n       (s(''y'' := hd (s ''x'') # s ''y'')) ''y'' =\n       rev X\n 2. PRE (\\<lambda>s.\n            s ''x'' =\n            X) (''y'' ::= (\\<lambda>s.\n                              [])) POST (\\<lambda>s.\n      rev (s ''x'') @ s ''y'' = rev X)", "apply (clarsimp, metis append.simps(1) append.simps(2) append_assoc hd_Cons_tl rev.simps(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. PRE (\\<lambda>s.\n            s ''x'' =\n            X) (''y'' ::= (\\<lambda>s.\n                              [])) POST (\\<lambda>s.\n      rev (s ''x'') @ s ''y'' = rev X)", "by simp"], ["", "end"]]}