{"file_name": "/home/qj213/afp-2021-10-22/thys/Algebraic_VCs/AVC_KAD/VC_KAD_wf_Examples.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Algebraic_VCs", "problem_names": ["lemma euclid:\n  \"rel_nabla (\n    \\<lceil>\\<lambda>s::nat store. 0 < s ''y''\\<rceil> ; \n      ((''z'' ::= (\\<lambda>s. s ''y'')) ; \n      (''y'' ::= (\\<lambda>s. s ''x'' mod s ''y'')) ;\n      (''x'' ::= (\\<lambda>s. s ''z'')))) \n    = {}\n    \\<Longrightarrow>\n  PRE (\\<lambda>s::nat store. s ''x'' = x \\<and> s ''y'' = y)\n   (WHILE (\\<lambda>s. s ''y'' \\<noteq> 0) INV (\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y) \n    DO\n     (''z'' ::= (\\<lambda>s. s ''y''));\n     (''y'' ::= (\\<lambda>s. s ''x'' mod s ''y''));\n     (''x'' ::= (\\<lambda>s. s ''z''))\n    OD)\n   POST (\\<lambda>s. s ''x'' = gcd x y)\""], "translations": [["", "lemma euclid:\n  \"rel_nabla (\n    \\<lceil>\\<lambda>s::nat store. 0 < s ''y''\\<rceil> ; \n      ((''z'' ::= (\\<lambda>s. s ''y'')) ; \n      (''y'' ::= (\\<lambda>s. s ''x'' mod s ''y'')) ;\n      (''x'' ::= (\\<lambda>s. s ''z'')))) \n    = {}\n    \\<Longrightarrow>\n  PRE (\\<lambda>s::nat store. s ''x'' = x \\<and> s ''y'' = y)\n   (WHILE (\\<lambda>s. s ''y'' \\<noteq> 0) INV (\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y) \n    DO\n     (''z'' ::= (\\<lambda>s. s ''y''));\n     (''y'' ::= (\\<lambda>s. s ''x'' mod s ''y''));\n     (''x'' ::= (\\<lambda>s. s ''z''))\n    OD)\n   POST (\\<lambda>s. s ''x'' = gcd x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_nabla\n     (\\<lceil>\\<lambda>s. 0 < s ''y''\\<rceil> ;\n      ((''z'' ::= (\\<lambda>s. s ''y'')) ;\n       (''y'' ::= (\\<lambda>s. s ''x'' mod s ''y'')) ;\n       (''x'' ::= (\\<lambda>s. s ''z'')))) =\n    {} \\<Longrightarrow>\n    rdom \\<lceil>\\<lambda>s. s ''x'' = x \\<and> s ''y'' = y\\<rceil>\n    \\<subseteq> wp (WHILE (\\<lambda>s.\n                              s ''y'' \\<noteq>\n                              0) INV (\\<lambda>s.\n   gcd (s ''x'') (s ''y'') =\n   gcd x\n    y) DO (''z'' ::= (\\<lambda>s. s ''y'')) ;\n          (''y'' ::= (\\<lambda>s. s ''x'' mod s ''y'')) ;\n          (''x'' ::= (\\<lambda>s. s ''z'')) OD)\n                 \\<lceil>\\<lambda>s. s ''x'' = gcd x y\\<rceil>", "apply (subst rel_fdivka.fbox_arden_whilei[symmetric], simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_nabla\n     (\\<lceil>\\<lambda>s. 0 < s ''y''\\<rceil> ;\n      ((''z'' ::= (\\<lambda>s. s ''y'')) ;\n       (''y'' ::= (\\<lambda>s. s ''x'' mod s ''y'')) ;\n       (''x'' ::= (\\<lambda>s. s ''z'')))) =\n    {} \\<Longrightarrow>\n    \\<forall>s.\n       (gcd (s ''x'') (s ''y'') = gcd x y) =\n       ((0 < s ''y'' \\<or> s ''x'' = gcd x y) \\<and>\n        (s ''y'' = 0 \\<or> gcd (s ''y'') (s ''x'' mod s ''y'') = gcd x y))", "using gcd_red_nat gr0I"], ["proof (prove)\nusing this:\n  gcd ?x ?y = gcd ?y (?x mod ?y)\n  (?n = 0 \\<Longrightarrow> False) \\<Longrightarrow> 0 < ?n\n\ngoal (1 subgoal):\n 1. rel_nabla\n     (\\<lceil>\\<lambda>s. 0 < s ''y''\\<rceil> ;\n      ((''z'' ::= (\\<lambda>s. s ''y'')) ;\n       (''y'' ::= (\\<lambda>s. s ''x'' mod s ''y'')) ;\n       (''x'' ::= (\\<lambda>s. s ''z'')))) =\n    {} \\<Longrightarrow>\n    \\<forall>s.\n       (gcd (s ''x'') (s ''y'') = gcd x y) =\n       ((0 < s ''y'' \\<or> s ''x'' = gcd x y) \\<and>\n        (s ''y'' = 0 \\<or> gcd (s ''y'') (s ''x'' mod s ''y'') = gcd x y))", "by force"], ["", "text \\<open>The termination assumption is now explicit in the verification proof. Here it is left \nuntouched. Means beyond these components are required for discharging it.\\<close>"], ["", "end"]]}