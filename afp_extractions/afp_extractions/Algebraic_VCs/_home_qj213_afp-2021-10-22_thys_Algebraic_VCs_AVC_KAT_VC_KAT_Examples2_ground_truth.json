{"file_name": "/home/qj213/afp-2021-10-22/thys/Algebraic_VCs/AVC_KAT/VC_KAT_Examples2.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Algebraic_VCs", "problem_names": ["lemma euclid:\n  \"PRE (\\<lambda>s::nat store. s ''x'' = x \\<and> s ''y'' = y)\n   (WHILE (\\<lambda>s. s ''y'' \\<noteq> 0) INV (\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y) \n    DO\n     (''z'' ::= (\\<lambda>s. s ''y''));\n     (''y'' ::= (\\<lambda>s. s ''x'' mod s ''y''));\n     (''x'' ::= (\\<lambda>s. s ''z''))\n    OD)\n   POST (\\<lambda>s. s ''x'' = gcd x y)\"", "lemma integer_division: \n  \"PRE (\\<lambda>s::nat store. s ''x'' \\<ge> 0)\n    (''q'' ::= (\\<lambda>s. 0)); \n    (''r'' ::= (\\<lambda>s. s ''x''));\n    (WHILE (\\<lambda>s. s ''y'' \\<le> s ''r'') INV (\\<lambda>s. s ''x'' = s ''q'' * s ''y'' + s ''r'' \\<and> s ''r'' \\<ge> 0)\n     DO\n      (''q'' ::= (\\<lambda>s. s ''q'' + 1));\n      (''r'' ::= (\\<lambda>s. s ''r'' - s ''y''))\n      OD)\n   POST (\\<lambda>s. s ''x'' = s ''q'' * s ''y'' + s ''r'' \\<and> s ''r'' \\<ge> 0 \\<and> s ''r'' < s ''y'')\"", "lemma imp_reverse:\n  \"PRE (\\<lambda>s:: 'a list store. s ''x'' = X)\n   (''y'' ::= (\\<lambda>s. []));\n   (WHILE (\\<lambda>s. s ''x'' \\<noteq> []) INV (\\<lambda>s. rev (s ''x'') @ s ''y'' = rev X)\n    DO \n     (''y'' ::= (\\<lambda>s. hd (s ''x'') # s ''y'')); \n     (''x'' ::= (\\<lambda>s. tl (s ''x'')))\n    OD) \n   POST (\\<lambda>s. s ''y''= rev X )\""], "translations": [["", "lemma euclid:\n  \"PRE (\\<lambda>s::nat store. s ''x'' = x \\<and> s ''y'' = y)\n   (WHILE (\\<lambda>s. s ''y'' \\<noteq> 0) INV (\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y) \n    DO\n     (''z'' ::= (\\<lambda>s. s ''y''));\n     (''y'' ::= (\\<lambda>s. s ''x'' mod s ''y''));\n     (''x'' ::= (\\<lambda>s. s ''z''))\n    OD)\n   POST (\\<lambda>s. s ''x'' = gcd x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PRE (\\<lambda>s.\n            s ''x'' = x \\<and>\n            s ''y'' =\n            y) (WHILE (\\<lambda>s.\n                          s ''y'' \\<noteq>\n                          0) INV (\\<lambda>s.\n                                     gcd (s ''x'') (s ''y'') =\n                                     gcd x\ny) DO (''z'' ::= (\\<lambda>s. s ''y'')) ;\n      (''y'' ::= (\\<lambda>s. s ''x'' mod s ''y'')) ;\n      (''x'' ::= (\\<lambda>s.\n                     s ''z'')) OD) POST (\\<lambda>s. s ''x'' = gcd x y)", "apply hoare"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<forall>s.\n       s ''x'' = x \\<and> s ''y'' = y \\<longrightarrow>\n       gcd (s ''x'') (s ''y'') = gcd x y\n 2. \\<forall>s.\n       gcd (s ''x'') (s ''y'') = gcd x y \\<and>\n       \\<not> s ''y'' \\<noteq> 0 \\<longrightarrow>\n       s ''x'' = gcd x y\n 3. \\<forall>s.\n       ?Q28 s \\<longrightarrow>\n       gcd ((s(''x'' := s ''z'')) ''x'') ((s(''x'' := s ''z'')) ''y'') =\n       gcd x y\n 4. \\<forall>s.\n       ?Q20 s \\<longrightarrow> ?Q28 (s(''y'' := s ''x'' mod s ''y''))\n 5. \\<forall>s.\n       ((\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y) \\<sqinter>\n        (\\<lambda>s. s ''y'' \\<noteq> 0))\n        s \\<longrightarrow>\n       ?Q20 (s(''z'' := s ''y''))", "using gcd_red_nat"], ["proof (prove)\nusing this:\n  gcd ?x ?y = gcd ?y (?x mod ?y)\n\ngoal (5 subgoals):\n 1. \\<forall>s.\n       s ''x'' = x \\<and> s ''y'' = y \\<longrightarrow>\n       gcd (s ''x'') (s ''y'') = gcd x y\n 2. \\<forall>s.\n       gcd (s ''x'') (s ''y'') = gcd x y \\<and>\n       \\<not> s ''y'' \\<noteq> 0 \\<longrightarrow>\n       s ''x'' = gcd x y\n 3. \\<forall>s.\n       ?Q28 s \\<longrightarrow>\n       gcd ((s(''x'' := s ''z'')) ''x'') ((s(''x'' := s ''z'')) ''y'') =\n       gcd x y\n 4. \\<forall>s.\n       ?Q20 s \\<longrightarrow> ?Q28 (s(''y'' := s ''x'' mod s ''y''))\n 5. \\<forall>s.\n       ((\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y) \\<sqinter>\n        (\\<lambda>s. s ''y'' \\<noteq> 0))\n        s \\<longrightarrow>\n       ?Q20 (s(''z'' := s ''y''))", "by auto"], ["", "lemma integer_division: \n  \"PRE (\\<lambda>s::nat store. s ''x'' \\<ge> 0)\n    (''q'' ::= (\\<lambda>s. 0)); \n    (''r'' ::= (\\<lambda>s. s ''x''));\n    (WHILE (\\<lambda>s. s ''y'' \\<le> s ''r'') INV (\\<lambda>s. s ''x'' = s ''q'' * s ''y'' + s ''r'' \\<and> s ''r'' \\<ge> 0)\n     DO\n      (''q'' ::= (\\<lambda>s. s ''q'' + 1));\n      (''r'' ::= (\\<lambda>s. s ''r'' - s ''y''))\n      OD)\n   POST (\\<lambda>s. s ''x'' = s ''q'' * s ''y'' + s ''r'' \\<and> s ''r'' \\<ge> 0 \\<and> s ''r'' < s ''y'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PRE (\\<lambda>s.\n            0 \\<le> s ''x'') (''q'' ::= (\\<lambda>s. 0)) ;\n                             (''r'' ::= (\\<lambda>s. s ''x'')) ;\n                             (WHILE (\\<lambda>s.\n  s ''y''\n  \\<le> s ''r'') INV (\\<lambda>s.\n                         s ''x'' = s ''q'' \\<cdot> s ''y'' + s ''r'' \\<and>\n                         0 \\<le> s ''r'') DO (''q'' ::= (\\<lambda>s.\n                      s ''q'' + 1)) ;\n       (''r'' ::= (\\<lambda>s.\n                      s ''r'' -\n                      s ''y'')) OD) POST (\\<lambda>s.\n       s ''x'' = s ''q'' \\<cdot> s ''y'' + s ''r'' \\<and>\n       0 \\<le> s ''r'' \\<and> s ''r'' < s ''y'')", "by hoare auto"], ["", "lemma imp_reverse:\n  \"PRE (\\<lambda>s:: 'a list store. s ''x'' = X)\n   (''y'' ::= (\\<lambda>s. []));\n   (WHILE (\\<lambda>s. s ''x'' \\<noteq> []) INV (\\<lambda>s. rev (s ''x'') @ s ''y'' = rev X)\n    DO \n     (''y'' ::= (\\<lambda>s. hd (s ''x'') # s ''y'')); \n     (''x'' ::= (\\<lambda>s. tl (s ''x'')))\n    OD) \n   POST (\\<lambda>s. s ''y''= rev X )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PRE (\\<lambda>s.\n            s ''x'' =\n            X) (''y'' ::= (\\<lambda>s. [])) ;\n               (WHILE (\\<lambda>s.\n                          s ''x'' \\<noteq>\n                          []) INV (\\<lambda>s.\nrev (s ''x'') @ s ''y'' =\nrev X) DO (''y'' ::= (\\<lambda>s. hd (s ''x'') # s ''y'')) ;\n          (''x'' ::= (\\<lambda>s.\n                         tl (s ''x''))) OD) POST (\\<lambda>s.\n               s ''y'' = rev X)", "apply hoare"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<forall>s. ?Q7 s \\<longrightarrow> rev (s ''x'') @ s ''y'' = rev X\n 2. \\<forall>s.\n       rev (s ''x'') @ s ''y'' = rev X \\<and>\n       \\<not> s ''x'' \\<noteq> [] \\<longrightarrow>\n       s ''y'' = rev X\n 3. \\<forall>s.\n       ?Q28 s \\<longrightarrow>\n       rev ((s(''x'' := tl (s ''x''))) ''x'') @\n       (s(''x'' := tl (s ''x''))) ''y'' =\n       rev X\n 4. \\<forall>s.\n       ((\\<lambda>s. rev (s ''x'') @ s ''y'' = rev X) \\<sqinter>\n        (\\<lambda>s. s ''x'' \\<noteq> []))\n        s \\<longrightarrow>\n       ?Q28 (s(''y'' := hd (s ''x'') # s ''y''))\n 5. \\<forall>s. s ''x'' = X \\<longrightarrow> ?Q7 (s(''y'' := []))", "apply auto[3]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>s.\n       ((\\<lambda>s. rev (s ''x'') @ s ''y'' = rev X) \\<sqinter>\n        (\\<lambda>s. s ''x'' \\<noteq> []))\n        s \\<longrightarrow>\n       rev (tl ((s(''y'' := hd (s ''x'') # s ''y'')) ''x'')) @\n       (s(''y'' := hd (s ''x'') # s ''y'')) ''y'' =\n       rev X\n 2. \\<forall>s.\n       s ''x'' = X \\<longrightarrow>\n       rev ((s(''y'' := [])) ''x'') @ (s(''y'' := [])) ''y'' = rev X", "apply (clarsimp, metis (no_types, lifting) Cons_eq_appendI append_eq_append_conv2 hd_Cons_tl rev.simps(2) self_append_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s.\n       s ''x'' = X \\<longrightarrow>\n       rev ((s(''y'' := [])) ''x'') @ (s(''y'' := [])) ''y'' = rev X", "by simp"], ["", "end"]]}