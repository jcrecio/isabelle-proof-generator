{"file_name": "/home/qj213/afp-2021-10-22/thys/Algebraic_VCs/AVC_KAD/VC_KAD_wf.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Algebraic_VCs", "problem_names": ["lemma rel_nabla_d_closed [simp]:  \"rdom (rel_nabla x) = rel_nabla x\"", "lemma rel_nabla_bin_d_closed [simp]:  \"rdom (rel_nabla_bin x q) = rel_nabla_bin x q\"", "lemma rel_nabla_unfold: \"rel_nabla X \\<subseteq> relfdia X (rel_nabla X)\"", "lemma rel_nabla_bin_unfold: \"rel_nabla_bin X Q \\<subseteq> relfdia X (rel_nabla_bin X Q) \\<union> rdom Q\"", "lemma rel_nabla_coinduct_var: \"P \\<subseteq> relfdia X P \\<Longrightarrow> P \\<subseteq> rel_nabla X\"", "lemma rel_nabla_bin_coinduct: \"P \\<subseteq> relfdia X P \\<union> rdom Q \\<Longrightarrow> P \\<subseteq> rel_nabla_bin X Q\"", "lemma nabla_fusion1: \"rel_nabla X \\<union> relfdia (X\\<^sup>*) Q \\<subseteq> rel_nabla_bin X Q\"", "lemma rel_ad_inter_seq: \"rel_ad X \\<inter> rel_ad Y = rel_ad X ; rel_ad Y\"", "lemma fusion2_aux2: \"rdom (rel_nabla_bin X Q) \\<subseteq> rdom (rel_nabla_bin X Q \\<inter> rel_ad (relfdia (X\\<^sup>*) Q) \\<union> relfdia (X\\<^sup>*) Q)\"", "lemma nabla_fusion2: \"rel_nabla_bin X Q \\<subseteq> rel_nabla X \\<union> relfdia (X\\<^sup>*) Q\"", "lemma rel_nabla_coinduct: \"P \\<subseteq> relfdia X P \\<union> rdom Q \\<Longrightarrow> P \\<subseteq> rel_nabla X \\<union> relfdia (rtrancl X) Q\"", "lemma fdia_arden: \"\\<nabla>x = 0 \\<Longrightarrow> d p \\<le> d q + |x\\<rangle> p \\<Longrightarrow> d p \\<le> |x\\<^sup>\\<star>\\<rangle> q\"", "lemma fdia_arden_eq: \"\\<nabla>x = 0 \\<Longrightarrow> d p = d q + |x\\<rangle> p \\<Longrightarrow> d p = |x\\<^sup>\\<star>\\<rangle> q\"", "lemma fdia_arden_iff: \"\\<nabla>x = 0 \\<Longrightarrow> (d p = d q + |x\\<rangle> p \\<longleftrightarrow> d p = |x\\<^sup>\\<star>\\<rangle> q)\"", "lemma \"|x\\<^sup>\\<star>] p \\<le> |x] p\"", "lemma fbox_arden: \"\\<nabla>x = 0 \\<Longrightarrow> d q \\<cdot> |x] p \\<le> d p \\<Longrightarrow> |x\\<^sup>\\<star>] q \\<le> d p\"", "lemma fbox_arden_eq: \"\\<nabla>x = 0 \\<Longrightarrow> d q \\<cdot> |x] p = d p \\<Longrightarrow> |x\\<^sup>\\<star>] q = d p\"", "lemma fbox_arden_iff: \"\\<nabla>x = 0 \\<Longrightarrow> (d p = d q \\<cdot> |x] p \\<longleftrightarrow> d p = |x\\<^sup>\\<star>] q)\"", "lemma fbox_arden_while_iff: \"\\<nabla> (d t \\<cdot> x) = 0 \\<Longrightarrow> (d p = (d t + d q) \\<cdot> |d t \\<cdot> x] p \\<longleftrightarrow> d p = |while t do x od] q)\"", "lemma fbox_arden_whilei: \"\\<nabla> (d t \\<cdot> x) = 0 \\<Longrightarrow> (d i = (d t + d q) \\<cdot> |d t \\<cdot> x] i \\<Longrightarrow> d i = |while t inv i do x od] q)\"", "lemma fbox_arden_whilei_iff: \"\\<nabla> (d t \\<cdot> x) = 0 \\<Longrightarrow> (d i = (d t + d q) \\<cdot> |d t \\<cdot> x] i \\<longleftrightarrow> d i = |while t inv i do x od] q)\"", "lemma noether_nabla: \"Noetherian x \\<Longrightarrow> \\<nabla> x = 0\"", "lemma nabla_noether_iff: \"Noetherian x \\<longleftrightarrow> \\<nabla> x = 0\"", "lemma nabla_preloeb_iff: \"\\<nabla> x = 0 \\<longleftrightarrow> PreLoebian x\"", "lemma rel_nabla_prop: \"rel_nabla R = {} \\<longleftrightarrow> (\\<forall>P. P \\<subseteq> relfdia R P \\<longrightarrow> P = {})\"", "lemma fdia_rel_im1: \"s2r ((converse R) `` P) = relfdia R (s2r P)\"", "lemma fdia_rel_im2: \"s2r ((converse R) `` (r2s (rdom P))) = relfdia R P\"", "lemma wf_nabla_aux: \"(P \\<subseteq> (converse R) `` P \\<longrightarrow> P = {}) \\<longleftrightarrow> (s2r P \\<subseteq> relfdia R (s2r P) \\<longrightarrow> s2r P = {})\"", "lemma wf_nabla: \"wf (converse R) \\<longleftrightarrow> rel_nabla R = {}\""], "translations": [["", "lemma rel_nabla_d_closed [simp]:  \"rdom (rel_nabla x) = rel_nabla x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rdom (rel_nabla x) = rel_nabla x", "by (auto simp: rel_nabla_def rel_antidomain_kleene_algebra.fdia_def rel_antidomain_kleene_algebra.ads_d_def rel_ad_def)"], ["", "lemma rel_nabla_bin_d_closed [simp]:  \"rdom (rel_nabla_bin x q) = rel_nabla_bin x q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rdom (rel_nabla_bin x q) = rel_nabla_bin x q", "by (auto simp: rel_nabla_bin_def rel_antidomain_kleene_algebra.fdia_def rel_antidomain_kleene_algebra.ads_d_def rel_ad_def)"], ["", "lemma rel_nabla_unfold: \"rel_nabla X \\<subseteq> relfdia X (rel_nabla X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_nabla X \\<subseteq> relfdia X (rel_nabla X)", "by (simp add: rel_nabla_def rel_ad_def rel_antidomain_kleene_algebra.fdia_def, blast)"], ["", "lemma rel_nabla_bin_unfold: \"rel_nabla_bin X Q \\<subseteq> relfdia X (rel_nabla_bin X Q) \\<union> rdom Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_nabla_bin X Q\n    \\<subseteq> relfdia X (rel_nabla_bin X Q) \\<union> rdom Q", "by (simp add: rel_nabla_bin_def rel_ad_def rel_antidomain_kleene_algebra.fdia_def, blast)"], ["", "lemma rel_nabla_coinduct_var: \"P \\<subseteq> relfdia X P \\<Longrightarrow> P \\<subseteq> rel_nabla X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<subseteq> relfdia X P \\<Longrightarrow> P \\<subseteq> rel_nabla X", "by (simp add: rel_nabla_def rel_antidomain_kleene_algebra.fdia_def rel_ad_def, blast)"], ["", "lemma rel_nabla_bin_coinduct: \"P \\<subseteq> relfdia X P \\<union> rdom Q \\<Longrightarrow> P \\<subseteq> rel_nabla_bin X Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<subseteq> relfdia X P \\<union> rdom Q \\<Longrightarrow>\n    P \\<subseteq> rel_nabla_bin X Q", "by (simp add: rel_nabla_bin_def rel_antidomain_kleene_algebra.fdia_def rel_ad_def, blast)"], ["", "text \\<open>The two fusion lemmas are, in fact, hard-coded fixpoint fusion proofs. They might be replaced\nby more generic fusion proofs eventually.\\<close>"], ["", "lemma nabla_fusion1: \"rel_nabla X \\<union> relfdia (X\\<^sup>*) Q \\<subseteq> rel_nabla_bin X Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_nabla X \\<union> relfdia (X\\<^sup>*) Q \\<subseteq> rel_nabla_bin X Q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rel_nabla X \\<union> relfdia (X\\<^sup>*) Q \\<subseteq> rel_nabla_bin X Q", "have \"rel_nabla X \\<union> relfdia (X\\<^sup>*) Q \\<subseteq> relfdia X (rel_nabla X) \\<union> relfdia X (relfdia (X\\<^sup>*) Q) \\<union> rdom Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_nabla X \\<union> relfdia (X\\<^sup>*) Q\n    \\<subseteq> relfdia X (rel_nabla X) \\<union>\n                relfdia X (relfdia (X\\<^sup>*) Q) \\<union>\n                rdom Q", "by (metis (no_types, lifting) Un_mono inf_sup_aci(6) order_refl rel_antidomain_kleene_algebra.dka.fdia_star_unfold_var rel_nabla_unfold sup.commute)"], ["proof (state)\nthis:\n  rel_nabla X \\<union> relfdia (X\\<^sup>*) Q\n  \\<subseteq> relfdia X (rel_nabla X) \\<union>\n              relfdia X (relfdia (X\\<^sup>*) Q) \\<union>\n              rdom Q\n\ngoal (1 subgoal):\n 1. rel_nabla X \\<union> relfdia (X\\<^sup>*) Q \\<subseteq> rel_nabla_bin X Q", "also"], ["proof (state)\nthis:\n  rel_nabla X \\<union> relfdia (X\\<^sup>*) Q\n  \\<subseteq> relfdia X (rel_nabla X) \\<union>\n              relfdia X (relfdia (X\\<^sup>*) Q) \\<union>\n              rdom Q\n\ngoal (1 subgoal):\n 1. rel_nabla X \\<union> relfdia (X\\<^sup>*) Q \\<subseteq> rel_nabla_bin X Q", "have \"... = relfdia X (rel_nabla X \\<union> relfdia (X\\<^sup>*) Q) \\<union> rdom Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. relfdia X (rel_nabla X) \\<union>\n    relfdia X (relfdia (X\\<^sup>*) Q) \\<union>\n    rdom Q =\n    relfdia X (rel_nabla X \\<union> relfdia (X\\<^sup>*) Q) \\<union> rdom Q", "by (simp add: rel_antidomain_kleene_algebra.dka.fdia_add1)"], ["proof (state)\nthis:\n  relfdia X (rel_nabla X) \\<union>\n  relfdia X (relfdia (X\\<^sup>*) Q) \\<union>\n  rdom Q =\n  relfdia X (rel_nabla X \\<union> relfdia (X\\<^sup>*) Q) \\<union> rdom Q\n\ngoal (1 subgoal):\n 1. rel_nabla X \\<union> relfdia (X\\<^sup>*) Q \\<subseteq> rel_nabla_bin X Q", "finally"], ["proof (chain)\npicking this:\n  rel_nabla X \\<union> relfdia (X\\<^sup>*) Q\n  \\<subseteq> relfdia X\n               (rel_nabla X \\<union> relfdia (X\\<^sup>*) Q) \\<union>\n              rdom Q", "show ?thesis"], ["proof (prove)\nusing this:\n  rel_nabla X \\<union> relfdia (X\\<^sup>*) Q\n  \\<subseteq> relfdia X\n               (rel_nabla X \\<union> relfdia (X\\<^sup>*) Q) \\<union>\n              rdom Q\n\ngoal (1 subgoal):\n 1. rel_nabla X \\<union> relfdia (X\\<^sup>*) Q \\<subseteq> rel_nabla_bin X Q", "using rel_nabla_bin_coinduct"], ["proof (prove)\nusing this:\n  rel_nabla X \\<union> relfdia (X\\<^sup>*) Q\n  \\<subseteq> relfdia X\n               (rel_nabla X \\<union> relfdia (X\\<^sup>*) Q) \\<union>\n              rdom Q\n  ?P \\<subseteq> relfdia ?X ?P \\<union> rdom ?Q \\<Longrightarrow>\n  ?P \\<subseteq> rel_nabla_bin ?X ?Q\n\ngoal (1 subgoal):\n 1. rel_nabla X \\<union> relfdia (X\\<^sup>*) Q \\<subseteq> rel_nabla_bin X Q", "by blast"], ["proof (state)\nthis:\n  rel_nabla X \\<union> relfdia (X\\<^sup>*) Q \\<subseteq> rel_nabla_bin X Q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rel_ad_inter_seq: \"rel_ad X \\<inter> rel_ad Y = rel_ad X ; rel_ad Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_ad X \\<inter> rel_ad Y = rel_ad X ; rel_ad Y", "by (auto simp: rel_ad_def)"], ["", "lemma fusion2_aux2: \"rdom (rel_nabla_bin X Q) \\<subseteq> rdom (rel_nabla_bin X Q \\<inter> rel_ad (relfdia (X\\<^sup>*) Q) \\<union> relfdia (X\\<^sup>*) Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rdom (rel_nabla_bin X Q)\n    \\<subseteq> rdom\n                 (rel_nabla_bin X Q \\<inter>\n                  rel_ad (relfdia (X\\<^sup>*) Q) \\<union>\n                  relfdia (X\\<^sup>*) Q)", "apply (auto simp: rel_antidomain_kleene_algebra.ads_d_def rel_ad_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x, y) \\<in> rel_nabla_bin X Q \\<Longrightarrow>\n       \\<exists>y.\n          y = x \\<and>\n          (x, x) \\<in> rel_nabla_bin X Q \\<and>\n          (\\<forall>y. (x, y) \\<notin> relfdia (X\\<^sup>*) Q) \\<or>\n          (x, y) \\<in> relfdia (X\\<^sup>*) Q", "by (metis pair_in_Id_conv r_into_rtrancl rel_antidomain_kleene_algebra.a_one rel_antidomain_kleene_algebra.a_star rel_antidomain_kleene_algebra.addual.ars_r_def rel_antidomain_kleene_algebra.dka.dns1'' rel_antidomain_kleene_algebra.dpdz.dom_one rel_antidomain_kleene_algebra.ds.ddual.rsr5 rel_antidomain_kleene_algebra.dual.conway.dagger_unfoldr_eq rel_antidomain_kleene_algebra.dual.tc_eq rel_nabla_bin_d_closed)"], ["", "lemma nabla_fusion2: \"rel_nabla_bin X Q \\<subseteq> rel_nabla X \\<union> relfdia (X\\<^sup>*) Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_nabla_bin X Q \\<subseteq> rel_nabla X \\<union> relfdia (X\\<^sup>*) Q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rel_nabla_bin X Q \\<subseteq> rel_nabla X \\<union> relfdia (X\\<^sup>*) Q", "have \"rel_nabla_bin X Q \\<inter> rel_ad (relfdia (X\\<^sup>*) Q)  \\<subseteq> (relfdia X (rel_nabla_bin X Q) \\<union> rdom Q) \\<inter> rel_ad (relfdia (X\\<^sup>*) Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_nabla_bin X Q \\<inter> rel_ad (relfdia (X\\<^sup>*) Q)\n    \\<subseteq> (relfdia X (rel_nabla_bin X Q) \\<union> rdom Q) \\<inter>\n                rel_ad (relfdia (X\\<^sup>*) Q)", "by (meson Int_mono equalityD1 rel_nabla_bin_unfold)"], ["proof (state)\nthis:\n  rel_nabla_bin X Q \\<inter> rel_ad (relfdia (X\\<^sup>*) Q)\n  \\<subseteq> (relfdia X (rel_nabla_bin X Q) \\<union> rdom Q) \\<inter>\n              rel_ad (relfdia (X\\<^sup>*) Q)\n\ngoal (1 subgoal):\n 1. rel_nabla_bin X Q \\<subseteq> rel_nabla X \\<union> relfdia (X\\<^sup>*) Q", "also"], ["proof (state)\nthis:\n  rel_nabla_bin X Q \\<inter> rel_ad (relfdia (X\\<^sup>*) Q)\n  \\<subseteq> (relfdia X (rel_nabla_bin X Q) \\<union> rdom Q) \\<inter>\n              rel_ad (relfdia (X\\<^sup>*) Q)\n\ngoal (1 subgoal):\n 1. rel_nabla_bin X Q \\<subseteq> rel_nabla X \\<union> relfdia (X\\<^sup>*) Q", "have \"... \\<subseteq> (relfdia X (rel_nabla_bin X Q \\<inter> rel_ad (relfdia (X\\<^sup>*) Q) \\<union> relfdia (X\\<^sup>*) Q) \\<union> rdom Q) \\<inter> rel_ad (relfdia (X\\<^sup>*) Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (relfdia X (rel_nabla_bin X Q) \\<union> rdom Q) \\<inter>\n    rel_ad (relfdia (X\\<^sup>*) Q)\n    \\<subseteq> (relfdia X\n                  (rel_nabla_bin X Q \\<inter>\n                   rel_ad (relfdia (X\\<^sup>*) Q) \\<union>\n                   relfdia (X\\<^sup>*) Q) \\<union>\n                 rdom Q) \\<inter>\n                rel_ad (relfdia (X\\<^sup>*) Q)", "using fusion2_aux2 rel_antidomain_kleene_algebra.dka.fd_iso1"], ["proof (prove)\nusing this:\n  rdom (rel_nabla_bin ?X ?Q)\n  \\<subseteq> rdom\n               (rel_nabla_bin ?X ?Q \\<inter>\n                rel_ad (relfdia (?X\\<^sup>*) ?Q) \\<union>\n                relfdia (?X\\<^sup>*) ?Q)\n  rdom ?x \\<subseteq> rdom ?y \\<Longrightarrow>\n  relfdia ?z ?x \\<subseteq> relfdia ?z ?y\n\ngoal (1 subgoal):\n 1. (relfdia X (rel_nabla_bin X Q) \\<union> rdom Q) \\<inter>\n    rel_ad (relfdia (X\\<^sup>*) Q)\n    \\<subseteq> (relfdia X\n                  (rel_nabla_bin X Q \\<inter>\n                   rel_ad (relfdia (X\\<^sup>*) Q) \\<union>\n                   relfdia (X\\<^sup>*) Q) \\<union>\n                 rdom Q) \\<inter>\n                rel_ad (relfdia (X\\<^sup>*) Q)", "by blast"], ["proof (state)\nthis:\n  (relfdia X (rel_nabla_bin X Q) \\<union> rdom Q) \\<inter>\n  rel_ad (relfdia (X\\<^sup>*) Q)\n  \\<subseteq> (relfdia X\n                (rel_nabla_bin X Q \\<inter>\n                 rel_ad (relfdia (X\\<^sup>*) Q) \\<union>\n                 relfdia (X\\<^sup>*) Q) \\<union>\n               rdom Q) \\<inter>\n              rel_ad (relfdia (X\\<^sup>*) Q)\n\ngoal (1 subgoal):\n 1. rel_nabla_bin X Q \\<subseteq> rel_nabla X \\<union> relfdia (X\\<^sup>*) Q", "also"], ["proof (state)\nthis:\n  (relfdia X (rel_nabla_bin X Q) \\<union> rdom Q) \\<inter>\n  rel_ad (relfdia (X\\<^sup>*) Q)\n  \\<subseteq> (relfdia X\n                (rel_nabla_bin X Q \\<inter>\n                 rel_ad (relfdia (X\\<^sup>*) Q) \\<union>\n                 relfdia (X\\<^sup>*) Q) \\<union>\n               rdom Q) \\<inter>\n              rel_ad (relfdia (X\\<^sup>*) Q)\n\ngoal (1 subgoal):\n 1. rel_nabla_bin X Q \\<subseteq> rel_nabla X \\<union> relfdia (X\\<^sup>*) Q", "have \"... = (relfdia X (rel_nabla_bin X Q \\<inter> rel_ad (relfdia (X\\<^sup>*) Q)) \\<union> relfdia X (relfdia (X\\<^sup>*) Q) \\<union> rdom Q) \\<inter> rel_ad (relfdia (X\\<^sup>*) Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (relfdia X\n      (rel_nabla_bin X Q \\<inter> rel_ad (relfdia (X\\<^sup>*) Q) \\<union>\n       relfdia (X\\<^sup>*) Q) \\<union>\n     rdom Q) \\<inter>\n    rel_ad (relfdia (X\\<^sup>*) Q) =\n    (relfdia X\n      (rel_nabla_bin X Q \\<inter> rel_ad (relfdia (X\\<^sup>*) Q)) \\<union>\n     relfdia X (relfdia (X\\<^sup>*) Q) \\<union>\n     rdom Q) \\<inter>\n    rel_ad (relfdia (X\\<^sup>*) Q)", "by (simp add: rel_antidomain_kleene_algebra.dka.fdia_add1)"], ["proof (state)\nthis:\n  (relfdia X\n    (rel_nabla_bin X Q \\<inter> rel_ad (relfdia (X\\<^sup>*) Q) \\<union>\n     relfdia (X\\<^sup>*) Q) \\<union>\n   rdom Q) \\<inter>\n  rel_ad (relfdia (X\\<^sup>*) Q) =\n  (relfdia X\n    (rel_nabla_bin X Q \\<inter> rel_ad (relfdia (X\\<^sup>*) Q)) \\<union>\n   relfdia X (relfdia (X\\<^sup>*) Q) \\<union>\n   rdom Q) \\<inter>\n  rel_ad (relfdia (X\\<^sup>*) Q)\n\ngoal (1 subgoal):\n 1. rel_nabla_bin X Q \\<subseteq> rel_nabla X \\<union> relfdia (X\\<^sup>*) Q", "also"], ["proof (state)\nthis:\n  (relfdia X\n    (rel_nabla_bin X Q \\<inter> rel_ad (relfdia (X\\<^sup>*) Q) \\<union>\n     relfdia (X\\<^sup>*) Q) \\<union>\n   rdom Q) \\<inter>\n  rel_ad (relfdia (X\\<^sup>*) Q) =\n  (relfdia X\n    (rel_nabla_bin X Q \\<inter> rel_ad (relfdia (X\\<^sup>*) Q)) \\<union>\n   relfdia X (relfdia (X\\<^sup>*) Q) \\<union>\n   rdom Q) \\<inter>\n  rel_ad (relfdia (X\\<^sup>*) Q)\n\ngoal (1 subgoal):\n 1. rel_nabla_bin X Q \\<subseteq> rel_nabla X \\<union> relfdia (X\\<^sup>*) Q", "have \"... = (relfdia X (rel_nabla_bin X Q \\<inter> rel_ad (relfdia (X\\<^sup>*) Q)) \\<union> relfdia (X\\<^sup>*) Q) \\<inter> rel_ad (relfdia (X\\<^sup>*) Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (relfdia X\n      (rel_nabla_bin X Q \\<inter> rel_ad (relfdia (X\\<^sup>*) Q)) \\<union>\n     relfdia X (relfdia (X\\<^sup>*) Q) \\<union>\n     rdom Q) \\<inter>\n    rel_ad (relfdia (X\\<^sup>*) Q) =\n    (relfdia X\n      (rel_nabla_bin X Q \\<inter> rel_ad (relfdia (X\\<^sup>*) Q)) \\<union>\n     relfdia (X\\<^sup>*) Q) \\<inter>\n    rel_ad (relfdia (X\\<^sup>*) Q)", "using rel_antidomain_kleene_algebra.dka.fdia_star_unfold_var"], ["proof (prove)\nusing this:\n  rdom ?y \\<union> relfdia ?x (relfdia (?x\\<^sup>*) ?y) =\n  relfdia (?x\\<^sup>*) ?y\n\ngoal (1 subgoal):\n 1. (relfdia X\n      (rel_nabla_bin X Q \\<inter> rel_ad (relfdia (X\\<^sup>*) Q)) \\<union>\n     relfdia X (relfdia (X\\<^sup>*) Q) \\<union>\n     rdom Q) \\<inter>\n    rel_ad (relfdia (X\\<^sup>*) Q) =\n    (relfdia X\n      (rel_nabla_bin X Q \\<inter> rel_ad (relfdia (X\\<^sup>*) Q)) \\<union>\n     relfdia (X\\<^sup>*) Q) \\<inter>\n    rel_ad (relfdia (X\\<^sup>*) Q)", "by blast"], ["proof (state)\nthis:\n  (relfdia X\n    (rel_nabla_bin X Q \\<inter> rel_ad (relfdia (X\\<^sup>*) Q)) \\<union>\n   relfdia X (relfdia (X\\<^sup>*) Q) \\<union>\n   rdom Q) \\<inter>\n  rel_ad (relfdia (X\\<^sup>*) Q) =\n  (relfdia X\n    (rel_nabla_bin X Q \\<inter> rel_ad (relfdia (X\\<^sup>*) Q)) \\<union>\n   relfdia (X\\<^sup>*) Q) \\<inter>\n  rel_ad (relfdia (X\\<^sup>*) Q)\n\ngoal (1 subgoal):\n 1. rel_nabla_bin X Q \\<subseteq> rel_nabla X \\<union> relfdia (X\\<^sup>*) Q", "finally"], ["proof (chain)\npicking this:\n  rel_nabla_bin X Q \\<inter> rel_ad (relfdia (X\\<^sup>*) Q)\n  \\<subseteq> (relfdia X\n                (rel_nabla_bin X Q \\<inter>\n                 rel_ad (relfdia (X\\<^sup>*) Q)) \\<union>\n               relfdia (X\\<^sup>*) Q) \\<inter>\n              rel_ad (relfdia (X\\<^sup>*) Q)", "have \"rel_nabla_bin X Q \\<inter> rel_ad (relfdia (X\\<^sup>*) Q) \\<subseteq> relfdia X ((rel_nabla_bin X Q) \\<inter> rel_ad (relfdia (X\\<^sup>*) Q))\""], ["proof (prove)\nusing this:\n  rel_nabla_bin X Q \\<inter> rel_ad (relfdia (X\\<^sup>*) Q)\n  \\<subseteq> (relfdia X\n                (rel_nabla_bin X Q \\<inter>\n                 rel_ad (relfdia (X\\<^sup>*) Q)) \\<union>\n               relfdia (X\\<^sup>*) Q) \\<inter>\n              rel_ad (relfdia (X\\<^sup>*) Q)\n\ngoal (1 subgoal):\n 1. rel_nabla_bin X Q \\<inter> rel_ad (relfdia (X\\<^sup>*) Q)\n    \\<subseteq> relfdia X\n                 (rel_nabla_bin X Q \\<inter> rel_ad (relfdia (X\\<^sup>*) Q))", "by (metis (no_types, lifting) inf_commute order_trans_rules(23) rel_ad_inter_seq rel_antidomain_kleene_algebra.a_mult_add rel_antidomain_kleene_algebra.a_subid_aux1' rel_antidomain_kleene_algebra.addual.bdia_def rel_antidomain_kleene_algebra.ds.ddual.rsr5)"], ["proof (state)\nthis:\n  rel_nabla_bin X Q \\<inter> rel_ad (relfdia (X\\<^sup>*) Q)\n  \\<subseteq> relfdia X\n               (rel_nabla_bin X Q \\<inter> rel_ad (relfdia (X\\<^sup>*) Q))\n\ngoal (1 subgoal):\n 1. rel_nabla_bin X Q \\<subseteq> rel_nabla X \\<union> relfdia (X\\<^sup>*) Q", "hence \"rdom (rel_nabla_bin X Q) ; rel_ad (relfdia (X\\<^sup>*) Q) \\<subseteq> rdom (rel_nabla X)\""], ["proof (prove)\nusing this:\n  rel_nabla_bin X Q \\<inter> rel_ad (relfdia (X\\<^sup>*) Q)\n  \\<subseteq> relfdia X\n               (rel_nabla_bin X Q \\<inter> rel_ad (relfdia (X\\<^sup>*) Q))\n\ngoal (1 subgoal):\n 1. rdom (rel_nabla_bin X Q) ; rel_ad (relfdia (X\\<^sup>*) Q)\n    \\<subseteq> rdom (rel_nabla X)", "by (metis rel_ad_inter_seq rel_antidomain_kleene_algebra.addual.ars_r_def rel_nabla_bin_d_closed rel_nabla_coinduct_var rel_nabla_d_closed)"], ["proof (state)\nthis:\n  rdom (rel_nabla_bin X Q) ; rel_ad (relfdia (X\\<^sup>*) Q)\n  \\<subseteq> rdom (rel_nabla X)\n\ngoal (1 subgoal):\n 1. rel_nabla_bin X Q \\<subseteq> rel_nabla X \\<union> relfdia (X\\<^sup>*) Q", "thus ?thesis"], ["proof (prove)\nusing this:\n  rdom (rel_nabla_bin X Q) ; rel_ad (relfdia (X\\<^sup>*) Q)\n  \\<subseteq> rdom (rel_nabla X)\n\ngoal (1 subgoal):\n 1. rel_nabla_bin X Q \\<subseteq> rel_nabla X \\<union> relfdia (X\\<^sup>*) Q", "by (metis rel_antidomain_kleene_algebra.addual.ars_r_def rel_antidomain_kleene_algebra.addual.bdia_def rel_antidomain_kleene_algebra.d_a_galois1 rel_antidomain_kleene_algebra.dpdz.domain_invol rel_nabla_bin_d_closed rel_nabla_d_closed)"], ["proof (state)\nthis:\n  rel_nabla_bin X Q \\<subseteq> rel_nabla X \\<union> relfdia (X\\<^sup>*) Q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rel_nabla_coinduct: \"P \\<subseteq> relfdia X P \\<union> rdom Q \\<Longrightarrow> P \\<subseteq> rel_nabla X \\<union> relfdia (rtrancl X) Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<subseteq> relfdia X P \\<union> rdom Q \\<Longrightarrow>\n    P \\<subseteq> rel_nabla X \\<union> relfdia (X\\<^sup>*) Q", "by (meson nabla_fusion2 order_trans rel_nabla_bin_coinduct)"], ["", "interpretation rel_fdivka: fdivergence_kleene_algebra rel_ad \"(\\<union>)\" \"(;) \" Id \"{}\" \"(\\<subseteq>)\" \"(\\<subset>)\" rtrancl rel_nabla"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.fdivergence_kleene_algebra rel_ad (\\<union>) (;) Id {}\n     (\\<subseteq>) (\\<subset>) rtrancl rel_nabla", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. rdom (rel_nabla x) = rel_nabla x\n 2. \\<And>x. rel_nabla x \\<subseteq> relfdia x (rel_nabla x)\n 3. \\<And>y x z.\n       rdom y \\<subseteq> relfdia x y \\<union> rdom z \\<Longrightarrow>\n       rdom y \\<subseteq> rel_nabla x \\<union> relfdia (x\\<^sup>*) z", "fix x y z:: \"'a rel\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. rdom (rel_nabla x) = rel_nabla x\n 2. \\<And>x. rel_nabla x \\<subseteq> relfdia x (rel_nabla x)\n 3. \\<And>y x z.\n       rdom y \\<subseteq> relfdia x y \\<union> rdom z \\<Longrightarrow>\n       rdom y \\<subseteq> rel_nabla x \\<union> relfdia (x\\<^sup>*) z", "show \"rdom (rel_nabla x) = rel_nabla x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rdom (rel_nabla x) = rel_nabla x", "by simp"], ["proof (state)\nthis:\n  rdom (rel_nabla x) = rel_nabla x\n\ngoal (2 subgoals):\n 1. \\<And>x. rel_nabla x \\<subseteq> relfdia x (rel_nabla x)\n 2. \\<And>y x z.\n       rdom y \\<subseteq> relfdia x y \\<union> rdom z \\<Longrightarrow>\n       rdom y \\<subseteq> rel_nabla x \\<union> relfdia (x\\<^sup>*) z", "show \"rel_nabla x \\<subseteq> relfdia x (rel_nabla x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_nabla x \\<subseteq> relfdia x (rel_nabla x)", "by (simp add: rel_nabla_unfold)"], ["proof (state)\nthis:\n  rel_nabla x \\<subseteq> relfdia x (rel_nabla x)\n\ngoal (1 subgoal):\n 1. \\<And>y x z.\n       rdom y \\<subseteq> relfdia x y \\<union> rdom z \\<Longrightarrow>\n       rdom y \\<subseteq> rel_nabla x \\<union> relfdia (x\\<^sup>*) z", "show \"rdom y \\<subseteq> relfdia x y \\<union> rdom z \\<Longrightarrow> rdom y \\<subseteq> rel_nabla x \\<union> relfdia (x\\<^sup>*) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rdom y \\<subseteq> relfdia x y \\<union> rdom z \\<Longrightarrow>\n    rdom y \\<subseteq> rel_nabla x \\<union> relfdia (x\\<^sup>*) z", "by (simp add: rel_nabla_coinduct)"], ["proof (state)\nthis:\n  rdom y \\<subseteq> relfdia x y \\<union> rdom z \\<Longrightarrow>\n  rdom y \\<subseteq> rel_nabla x \\<union> relfdia (x\\<^sup>*) z\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Meta-Equational Loop  Rule\\<close>"], ["", "context fdivergence_kleene_algebra\nbegin"], ["", "text \\<open>The rule below is inspired by Arden' rule from language theory. It can be used in total correctness proofs.\\<close>"], ["", "lemma fdia_arden: \"\\<nabla>x = 0 \\<Longrightarrow> d p \\<le> d q + |x\\<rangle> p \\<Longrightarrow> d p \\<le> |x\\<^sup>\\<star>\\<rangle> q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<nabla>x = (zero_class.zero::'a);\n     d p \\<le> d q +  |x\\<rangle> p\\<rbrakk>\n    \\<Longrightarrow> d p \\<le>  |x\\<^sup>\\<star>\\<rangle> q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<nabla>x = (zero_class.zero::'a);\n     d p \\<le> d q +  |x\\<rangle> p\\<rbrakk>\n    \\<Longrightarrow> d p \\<le>  |x\\<^sup>\\<star>\\<rangle> q", "assume a1: \"\\<nabla>x = zero_class.zero\""], ["proof (state)\nthis:\n  \\<nabla>x = (zero_class.zero::'a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<nabla>x = (zero_class.zero::'a);\n     d p \\<le> d q +  |x\\<rangle> p\\<rbrakk>\n    \\<Longrightarrow> d p \\<le>  |x\\<^sup>\\<star>\\<rangle> q", "assume \"d p \\<le> d q + |x\\<rangle> p\""], ["proof (state)\nthis:\n  d p \\<le> d q +  |x\\<rangle> p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<nabla>x = (zero_class.zero::'a);\n     d p \\<le> d q +  |x\\<rangle> p\\<rbrakk>\n    \\<Longrightarrow> d p \\<le>  |x\\<^sup>\\<star>\\<rangle> q", "then"], ["proof (chain)\npicking this:\n  d p \\<le> d q +  |x\\<rangle> p", "have \"ad (ad p) \\<le> zero_class.zero + ad (ad (x\\<^sup>\\<star> \\<cdot> q))\""], ["proof (prove)\nusing this:\n  d p \\<le> d q +  |x\\<rangle> p\n\ngoal (1 subgoal):\n 1. ad (ad p)\n    \\<le> (zero_class.zero::'a) + ad (ad (x\\<^sup>\\<star> \\<cdot> q))", "using a1 add_commute ads_d_def dka.fd_def nabla_coinduction"], ["proof (prove)\nusing this:\n  d p \\<le> d q +  |x\\<rangle> p\n  \\<nabla>x = (zero_class.zero::'a)\n  ?a + ?b = ?b + ?a\n  d ?x = ad (ad ?x)\n   |?x\\<rangle> ?y = d (?x \\<cdot> ?y)\n  d ?y \\<le>  |?x\\<rangle> ?y + d ?z \\<Longrightarrow>\n  d ?y \\<le> \\<nabla>?x +  |?x\\<^sup>\\<star>\\<rangle> ?z\n\ngoal (1 subgoal):\n 1. ad (ad p)\n    \\<le> (zero_class.zero::'a) + ad (ad (x\\<^sup>\\<star> \\<cdot> q))", "by force"], ["proof (state)\nthis:\n  ad (ad p)\n  \\<le> (zero_class.zero::'a) + ad (ad (x\\<^sup>\\<star> \\<cdot> q))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<nabla>x = (zero_class.zero::'a);\n     d p \\<le> d q +  |x\\<rangle> p\\<rbrakk>\n    \\<Longrightarrow> d p \\<le>  |x\\<^sup>\\<star>\\<rangle> q", "then"], ["proof (chain)\npicking this:\n  ad (ad p)\n  \\<le> (zero_class.zero::'a) + ad (ad (x\\<^sup>\\<star> \\<cdot> q))", "show ?thesis"], ["proof (prove)\nusing this:\n  ad (ad p)\n  \\<le> (zero_class.zero::'a) + ad (ad (x\\<^sup>\\<star> \\<cdot> q))\n\ngoal (1 subgoal):\n 1. d p \\<le>  |x\\<^sup>\\<star>\\<rangle> q", "by (simp add: ads_d_def dka.fd_def)"], ["proof (state)\nthis:\n  d p \\<le>  |x\\<^sup>\\<star>\\<rangle> q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fdia_arden_eq: \"\\<nabla>x = 0 \\<Longrightarrow> d p = d q + |x\\<rangle> p \\<Longrightarrow> d p = |x\\<^sup>\\<star>\\<rangle> q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<nabla>x = (zero_class.zero::'a);\n     d p = d q +  |x\\<rangle> p\\<rbrakk>\n    \\<Longrightarrow> d p =  |x\\<^sup>\\<star>\\<rangle> q", "by (simp add: fdia_arden dka.fdia_star_induct_eq eq_iff)"], ["", "lemma fdia_arden_iff: \"\\<nabla>x = 0 \\<Longrightarrow> (d p = d q + |x\\<rangle> p \\<longleftrightarrow> d p = |x\\<^sup>\\<star>\\<rangle> q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nabla>x = (zero_class.zero::'a) \\<Longrightarrow>\n    (d p = d q +  |x\\<rangle> p) = (d p =  |x\\<^sup>\\<star>\\<rangle> q)", "by (metis fdia_arden_eq dka.fdia_d_simp dka.fdia_star_unfold_var)"], ["", "lemma \"|x\\<^sup>\\<star>] p \\<le> |x] p\""], ["proof (prove)\ngoal (1 subgoal):\n 1.  |x\\<^sup>\\<star>] p \\<le>  |x] p", "by (simp add: fbox_antitone_var)"], ["", "lemma fbox_arden: \"\\<nabla>x = 0 \\<Longrightarrow> d q \\<cdot> |x] p \\<le> d p \\<Longrightarrow> |x\\<^sup>\\<star>] q \\<le> d p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<nabla>x = (zero_class.zero::'a);\n     d q \\<cdot>  |x] p \\<le> d p\\<rbrakk>\n    \\<Longrightarrow>  |x\\<^sup>\\<star>] q \\<le> d p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<nabla>x = (zero_class.zero::'a);\n     d q \\<cdot>  |x] p \\<le> d p\\<rbrakk>\n    \\<Longrightarrow>  |x\\<^sup>\\<star>] q \\<le> d p", "assume h1: \"\\<nabla>x = 0\" and \"d q \\<cdot> |x] p \\<le> d p\""], ["proof (state)\nthis:\n  \\<nabla>x = (zero_class.zero::'a)\n  d q \\<cdot>  |x] p \\<le> d p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<nabla>x = (zero_class.zero::'a);\n     d q \\<cdot>  |x] p \\<le> d p\\<rbrakk>\n    \\<Longrightarrow>  |x\\<^sup>\\<star>] q \\<le> d p", "hence \"ad p \\<le> ad (d q \\<cdot> |x] p)\""], ["proof (prove)\nusing this:\n  \\<nabla>x = (zero_class.zero::'a)\n  d q \\<cdot>  |x] p \\<le> d p\n\ngoal (1 subgoal):\n 1. ad p \\<le> ad (d q \\<cdot>  |x] p)", "by (metis a_antitone' a_subid addual.ars_r_def dpdz.domain_subid dual_order.trans)"], ["proof (state)\nthis:\n  ad p \\<le> ad (d q \\<cdot>  |x] p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<nabla>x = (zero_class.zero::'a);\n     d q \\<cdot>  |x] p \\<le> d p\\<rbrakk>\n    \\<Longrightarrow>  |x\\<^sup>\\<star>] q \\<le> d p", "hence \"ad p \\<le> ad q + |x\\<rangle> ad p\""], ["proof (prove)\nusing this:\n  ad p \\<le> ad (d q \\<cdot>  |x] p)\n\ngoal (1 subgoal):\n 1. ad p \\<le> ad q +  |x\\<rangle> ad p", "by (simp add: a_6 addual.bbox_def ds.fd_def)"], ["proof (state)\nthis:\n  ad p \\<le> ad q +  |x\\<rangle> ad p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<nabla>x = (zero_class.zero::'a);\n     d q \\<cdot>  |x] p \\<le> d p\\<rbrakk>\n    \\<Longrightarrow>  |x\\<^sup>\\<star>] q \\<le> d p", "hence \"ad p \\<le> |x\\<^sup>\\<star>\\<rangle> ad q\""], ["proof (prove)\nusing this:\n  ad p \\<le> ad q +  |x\\<rangle> ad p\n\ngoal (1 subgoal):\n 1. ad p \\<le>  |x\\<^sup>\\<star>\\<rangle> ad q", "by (metis fdia_arden h1 a_4 ads_d_def dpdz.dsg1  fdia_def meet_ord_def)"], ["proof (state)\nthis:\n  ad p \\<le>  |x\\<^sup>\\<star>\\<rangle> ad q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<nabla>x = (zero_class.zero::'a);\n     d q \\<cdot>  |x] p \\<le> d p\\<rbrakk>\n    \\<Longrightarrow>  |x\\<^sup>\\<star>] q \\<le> d p", "thus ?thesis"], ["proof (prove)\nusing this:\n  ad p \\<le>  |x\\<^sup>\\<star>\\<rangle> ad q\n\ngoal (1 subgoal):\n 1.  |x\\<^sup>\\<star>] q \\<le> d p", "by (metis a_antitone' ads_d_def fbox_simp fdia_fbox_de_morgan_2)"], ["proof (state)\nthis:\n   |x\\<^sup>\\<star>] q \\<le> d p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fbox_arden_eq: \"\\<nabla>x = 0 \\<Longrightarrow> d q \\<cdot> |x] p = d p \\<Longrightarrow> |x\\<^sup>\\<star>] q = d p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<nabla>x = (zero_class.zero::'a);\n     d q \\<cdot>  |x] p = d p\\<rbrakk>\n    \\<Longrightarrow>  |x\\<^sup>\\<star>] q = d p", "by (simp add: fbox_arden antisym fbox_star_induct_eq)"], ["", "lemma fbox_arden_iff: \"\\<nabla>x = 0 \\<Longrightarrow> (d p = d q \\<cdot> |x] p \\<longleftrightarrow> d p = |x\\<^sup>\\<star>] q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nabla>x = (zero_class.zero::'a) \\<Longrightarrow>\n    (d p = d q \\<cdot>  |x] p) = (d p =  |x\\<^sup>\\<star>] q)", "by (metis fbox_arden_eq fbox_simp fbox_star_unfold_var)"], ["", "lemma fbox_arden_while_iff: \"\\<nabla> (d t \\<cdot> x) = 0 \\<Longrightarrow> (d p = (d t + d q) \\<cdot> |d t \\<cdot> x] p \\<longleftrightarrow> d p = |while t do x od] q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nabla>(d t \\<cdot> x) = (zero_class.zero::'a) \\<Longrightarrow>\n    (d p = (d t + d q) \\<cdot>  |d t \\<cdot> x] p) =\n    (d p =  |while t do x od] q)", "by (metis fbox_arden_iff dka.dom_add_closed fbox_export3 while_def)"], ["", "lemma fbox_arden_whilei: \"\\<nabla> (d t \\<cdot> x) = 0 \\<Longrightarrow> (d i = (d t + d q) \\<cdot> |d t \\<cdot> x] i \\<Longrightarrow> d i = |while t inv i do x od] q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<nabla>(d t \\<cdot> x) = (zero_class.zero::'a);\n     d i = (d t + d q) \\<cdot>  |d t \\<cdot> x] i\\<rbrakk>\n    \\<Longrightarrow> d i =  |while t inv i do x od] q", "using fbox_arden_while_iff whilei_def"], ["proof (prove)\nusing this:\n  \\<nabla>(d ?t \\<cdot> ?x) = (zero_class.zero::'a) \\<Longrightarrow>\n  (d ?p = (d ?t + d ?q) \\<cdot>  |d ?t \\<cdot> ?x] ?p) =\n  (d ?p =  |while ?t do ?x od] ?q)\n  while ?p inv ?i do ?x od = while ?p do ?x od\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<nabla>(d t \\<cdot> x) = (zero_class.zero::'a);\n     d i = (d t + d q) \\<cdot>  |d t \\<cdot> x] i\\<rbrakk>\n    \\<Longrightarrow> d i =  |while t inv i do x od] q", "by auto"], ["", "lemma fbox_arden_whilei_iff: \"\\<nabla> (d t \\<cdot> x) = 0 \\<Longrightarrow> (d i = (d t + d q) \\<cdot> |d t \\<cdot> x] i \\<longleftrightarrow> d i = |while t inv i do x od] q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nabla>(d t \\<cdot> x) = (zero_class.zero::'a) \\<Longrightarrow>\n    (d i = (d t + d q) \\<cdot>  |d t \\<cdot> x] i) =\n    (d i =  |while t inv i do x od] q)", "using fbox_arden_while_iff whilei_def"], ["proof (prove)\nusing this:\n  \\<nabla>(d ?t \\<cdot> ?x) = (zero_class.zero::'a) \\<Longrightarrow>\n  (d ?p = (d ?t + d ?q) \\<cdot>  |d ?t \\<cdot> ?x] ?p) =\n  (d ?p =  |while ?t do ?x od] ?q)\n  while ?p inv ?i do ?x od = while ?p do ?x od\n\ngoal (1 subgoal):\n 1. \\<nabla>(d t \\<cdot> x) = (zero_class.zero::'a) \\<Longrightarrow>\n    (d i = (d t + d q) \\<cdot>  |d t \\<cdot> x] i) =\n    (d i =  |while t inv i do x od] q)", "by auto"], ["", "subsubsection \\<open>Noethericity and Absence of Divergence\\<close>"], ["", "text \\<open>Noetherian elements have been defined in the AFP entry for Kleene algebra with domain. First we show \nthat noethericity and absence of divergence coincide. Then we turn to the relational model and \nshow that noetherian relations model terminating programs.\\<close>"], ["", "lemma noether_nabla: \"Noetherian x \\<Longrightarrow> \\<nabla> x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Noetherian x \\<Longrightarrow> \\<nabla>x = (zero_class.zero::'a)", "by (metis nabla_closure nabla_unfold noetherian_alt)"], ["", "lemma nabla_noether_iff: \"Noetherian x \\<longleftrightarrow> \\<nabla> x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Noetherian x = (\\<nabla>x = (zero_class.zero::'a))", "using nabla_noether noether_nabla"], ["proof (prove)\nusing this:\n  \\<nabla>?x = (zero_class.zero::'a) \\<Longrightarrow> Noetherian ?x\n  Noetherian ?x \\<Longrightarrow> \\<nabla>?x = (zero_class.zero::'a)\n\ngoal (1 subgoal):\n 1. Noetherian x = (\\<nabla>x = (zero_class.zero::'a))", "by blast"], ["", "lemma nabla_preloeb_iff: \"\\<nabla> x = 0 \\<longleftrightarrow> PreLoebian x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nabla>x = (zero_class.zero::'a)) = PreLoebian x", "using Noetherian_iff_PreLoebian nabla_noether noether_nabla"], ["proof (prove)\nusing this:\n  Noetherian ?x = PreLoebian ?x\n  \\<nabla>?x = (zero_class.zero::'a) \\<Longrightarrow> Noetherian ?x\n  Noetherian ?x \\<Longrightarrow> \\<nabla>?x = (zero_class.zero::'a)\n\ngoal (1 subgoal):\n 1. (\\<nabla>x = (zero_class.zero::'a)) = PreLoebian x", "by blast"], ["", "end"], ["", "lemma rel_nabla_prop: \"rel_nabla R = {} \\<longleftrightarrow> (\\<forall>P. P \\<subseteq> relfdia R P \\<longrightarrow> P = {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_nabla R = {}) =\n    (\\<forall>P. P \\<subseteq> relfdia R P \\<longrightarrow> P = {})", "by (metis bot.extremum_uniqueI rel_nabla_coinduct_var rel_nabla_unfold)"], ["", "lemma fdia_rel_im1: \"s2r ((converse R) `` P) = relfdia R (s2r P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s2r (R\\<inverse> `` P) = relfdia R (s2r P)", "by (auto simp: Id_on_def rel_antidomain_kleene_algebra.ads_d_def rel_ad_def rel_antidomain_kleene_algebra.fdia_def Image_def converse_def)"], ["", "lemma fdia_rel_im2: \"s2r ((converse R) `` (r2s (rdom P))) = relfdia R P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s2r (R\\<inverse> `` r2s (rdom P)) = relfdia R P", "by (simp add: fdia_rel_im1 rsr)"], ["", "lemma wf_nabla_aux: \"(P \\<subseteq> (converse R) `` P \\<longrightarrow> P = {}) \\<longleftrightarrow> (s2r P \\<subseteq> relfdia R (s2r P) \\<longrightarrow> s2r P = {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<subseteq> R\\<inverse> `` P \\<longrightarrow> P = {}) =\n    (s2r P \\<subseteq> relfdia R (s2r P) \\<longrightarrow> s2r P = {})", "apply (standard, metis Domain_Id_on Domain_mono Id_on_empty fdia_rel_im1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. s2r P \\<subseteq> relfdia R (s2r P) \\<longrightarrow>\n    s2r P = {} \\<Longrightarrow>\n    P \\<subseteq> R\\<inverse> `` P \\<longrightarrow> P = {}", "using fdia_rel_im1"], ["proof (prove)\nusing this:\n  s2r (?R\\<inverse> `` ?P) = relfdia ?R (s2r ?P)\n\ngoal (1 subgoal):\n 1. s2r P \\<subseteq> relfdia R (s2r P) \\<longrightarrow>\n    s2r P = {} \\<Longrightarrow>\n    P \\<subseteq> R\\<inverse> `` P \\<longrightarrow> P = {}", "by fastforce"], ["", "text \\<open>A relation is noeterian if its converse is wellfounded. Hence a relation is noetherian if and only if its \ndivergence is empty. In the relational program semantics, noetherian programs terminate.\\<close>"], ["", "lemma wf_nabla: \"wf (converse R) \\<longleftrightarrow> rel_nabla R = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (R\\<inverse>) = (rel_nabla R = {})", "by (metis (no_types, lifting) fdia_rel_im2 rel_fdivka.nabla_unfold_eq rel_nabla_prop rel_nabla_unfold wfE_pf wfI_pf wf_nabla_aux)"], ["", "end"]]}