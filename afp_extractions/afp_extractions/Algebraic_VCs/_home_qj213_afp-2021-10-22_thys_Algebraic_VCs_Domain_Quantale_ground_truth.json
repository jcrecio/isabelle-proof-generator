{"file_name": "/home/qj213/afp-2021-10-22/thys/Algebraic_VCs/Domain_Quantale.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Algebraic_VCs", "problem_names": ["lemma inf_bot_iff_le: \"x \\<sqinter> y = \\<bottom> \\<longleftrightarrow> x \\<le> -y\"", "lemma a_d_iff: \"a x = 1 \\<sqinter> -(x \\<cdot> \\<top>)\"", "lemma topr: \"-(x \\<cdot> \\<top>) \\<cdot> \\<top> = -(x \\<cdot> \\<top>)\"", "lemma dd_a: \"dblo.d x = a (a x)\"", "lemma ad_a [simp]: \"a (dblo.d x) = a x\"", "lemma da_a [simp]: \"dblo.d (a x) = a x\"", "lemma a1 [simp]: \"a x \\<cdot> x = \\<bottom>\"", "lemma a2 [simp]: \"a (x \\<cdot> y) \\<squnion> a (x \\<cdot> a (a y)) = a (x \\<cdot> a (a y))\"", "lemma a3 [simp]: \"a (a x) \\<squnion> a x = 1\"", "lemma ar_r_iff: \"ar x = 1 \\<sqinter> -(\\<top> \\<cdot> x)\"", "lemma topl: \"\\<top>\\<cdot>(-(\\<top> \\<cdot> x)) = -(\\<top> \\<cdot> x)\"", "lemma r_ar: \"r x = ar (ar x)\"", "lemma ar_ar [simp]: \"ar (r x) = ar x\"", "lemma rar_ar [simp]: \"r (ar x) = ar x\"", "lemma ar1 [simp]: \"x \\<cdot> ar x = \\<bottom>\"", "lemma ars: \"r (r x \\<cdot> y) = r (x \\<cdot> y)\"", "lemma ar2 [simp]: \"ar (x \\<cdot> y) \\<squnion> ar (ar (ar x) \\<cdot> y) = ar (ar (ar x) \\<cdot> y)\"", "lemma ar3 [simp]: \"ar (ar x) \\<squnion> ar x = 1 \"", "lemma bot_annil'' [simp]: \"\\<bottom> \\<cdot> x = \\<bottom>\"", "lemma bot_annirr'' [simp]: \"x \\<cdot> \\<bottom> = \\<bottom>\"", "lemma sup_distl: \"x \\<cdot> (y \\<squnion> z) = x \\<cdot> y \\<squnion> x \\<cdot> z\"", "lemma sup_distr: \"(x \\<squnion> y) \\<cdot> z = x \\<cdot> z \\<squnion> y \\<cdot> z\"", "lemma Sup_sup_pred: \"x \\<squnion> Sup{y. P y} = Sup{y. y = x \\<or> P y}\"", "lemma star_def_var1: \"star x = Sup{y. \\<exists>i. y = x ^ i}\"", "lemma star_def_var2: \"star x = Sup{x ^ i |i. True}\"", "lemma star_unfoldl' [simp]: \"1 \\<squnion> x \\<cdot> (star x) = star x\"", "lemma star_unfoldr' [simp]: \"1 \\<squnion> (star x) \\<cdot> x = star x\"", "lemma (in dioid_one_zero) power_inductl: \"z + x \\<cdot> y \\<le> y \\<Longrightarrow> (x ^ n) \\<cdot> z \\<le> y\"", "lemma (in dioid_one_zero) power_inductr: \"z + y \\<cdot> x \\<le> y \\<Longrightarrow> z \\<cdot> (x ^ n) \\<le> y\"", "lemma star_inductl': \"z \\<squnion> x \\<cdot> y \\<le> y \\<Longrightarrow> (star x) \\<cdot> z \\<le> y\"", "lemma star_inductr': \"z \\<squnion> y \\<cdot> x \\<le> y \\<Longrightarrow> z \\<cdot> (star x) \\<le> y\"", "lemma \"(1 \\<sqinter> x \\<cdot> \\<top>) \\<cdot> x = x\"", "lemma \"(1 \\<sqinter> x \\<cdot> \\<top>) \\<cdot> x = x\"", "lemma \"(1 \\<sqinter> -(x \\<cdot> \\<top>)) \\<cdot> x = \\<bottom>\"", "lemma fbox_eq: \"ad.fbox x q = Sup{d p |p. d p \\<cdot> x \\<le> x \\<cdot> d q}\"", "lemma fdia_eq: \"ad.fdia x p = Inf{d q |q. x \\<cdot> d p \\<le> d q \\<cdot> x}\"", "lemma \"x \\<le> R p q \\<Longrightarrow> d p \\<le> ad.fbox x (d q)\"", "lemma \"d p \\<le> ad.fbox x (d q) \\<Longrightarrow> x \\<le> R p q\"", "lemma fbox_eq: \"ar.bbox x (r q) = Sup{r p |p. x \\<cdot> r p \\<le> (r q) \\<cdot> x}\"", "lemma fdia_eq: \"ar.bdia x (r p) = Inf{r q |q. (r p) \\<cdot> x \\<le> x \\<cdot> r q}\"", "lemma recursion: \"mono (f :: 'a \\<Rightarrow> 'a :: domain_boolean_quantale) \\<Longrightarrow> \n  (\\<And>x. d p \\<le> |x] d q \\<Longrightarrow> d p \\<le> |f x] d q) \\<Longrightarrow>  d p \\<le> |lfp f] d q\""], "translations": [["", "lemma inf_bot_iff_le: \"x \\<sqinter> y = \\<bottom> \\<longleftrightarrow> x \\<le> -y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> y = \\<bottom>) = (x \\<le> - y)", "by (metis le_iff_inf inf_sup_distrib1 inf_top_right sup_bot.left_neutral sup_compl_top compl_inf_bot inf.assoc inf_bot_right)"], ["", "end"], ["", "class domain_boolean_monoid = boolean_monoid + \n  assumes rdv': \"(z \\<sqinter> x \\<cdot> \\<top>) \\<cdot> y = z \\<cdot> y \\<sqinter> x \\<cdot> \\<top>\"     \n\nbegin"], ["", "sublocale dblo: domain_bdlo_monoid \"1\" \"(\\<cdot>)\" \"(\\<sqinter>)\" \"(\\<le>)\" \"(<)\" \"(\\<squnion>)\" \"\\<bottom>\" \"\\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.domain_bdlo_monoid (1::'a) (\\<cdot>) (\\<sqinter>) (\\<le>) (<)\n     (\\<squnion>) \\<bottom> \\<top>", "by (standard, simp add: rdv')"], ["", "definition \"a x = 1 \\<sqinter> -(dblo.d x)\""], ["", "lemma a_d_iff: \"a x = 1 \\<sqinter> -(x \\<cdot> \\<top>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a x = (1::'a) \\<sqinter> - (x \\<cdot> \\<top>)", "by (clarsimp simp: a_def dblo.d_def inf_sup_distrib1)"], ["", "lemma topr: \"-(x \\<cdot> \\<top>) \\<cdot> \\<top> = -(x \\<cdot> \\<top>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (x \\<cdot> \\<top>) \\<cdot> \\<top> = - (x \\<cdot> \\<top>)", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. - (x \\<cdot> \\<top>) \\<cdot> \\<top> \\<le> - (x \\<cdot> \\<top>)\n 2. - (x \\<cdot> \\<top>) \\<le> - (x \\<cdot> \\<top>) \\<cdot> \\<top>", "show \"-(x \\<cdot> \\<top>) \\<le> -(x \\<cdot> \\<top>) \\<cdot> \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (x \\<cdot> \\<top>) \\<le> - (x \\<cdot> \\<top>) \\<cdot> \\<top>", "by (metis mult_isol_var mult_oner order_refl top_greatest)"], ["proof (state)\nthis:\n  - (x \\<cdot> \\<top>) \\<le> - (x \\<cdot> \\<top>) \\<cdot> \\<top>\n\ngoal (1 subgoal):\n 1. - (x \\<cdot> \\<top>) \\<cdot> \\<top> \\<le> - (x \\<cdot> \\<top>)", "have \"-(x \\<cdot> \\<top>) \\<sqinter> (x \\<cdot> \\<top>) = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (x \\<cdot> \\<top>) \\<sqinter> x \\<cdot> \\<top> = \\<bottom>", "by simp"], ["proof (state)\nthis:\n  - (x \\<cdot> \\<top>) \\<sqinter> x \\<cdot> \\<top> = \\<bottom>\n\ngoal (1 subgoal):\n 1. - (x \\<cdot> \\<top>) \\<cdot> \\<top> \\<le> - (x \\<cdot> \\<top>)", "hence \"(-(x \\<cdot> \\<top>) \\<sqinter> (x \\<cdot> \\<top>)) \\<cdot> \\<top>  = \\<bottom>\""], ["proof (prove)\nusing this:\n  - (x \\<cdot> \\<top>) \\<sqinter> x \\<cdot> \\<top> = \\<bottom>\n\ngoal (1 subgoal):\n 1. (- (x \\<cdot> \\<top>) \\<sqinter> x \\<cdot> \\<top>) \\<cdot> \\<top> =\n    \\<bottom>", "by simp"], ["proof (state)\nthis:\n  (- (x \\<cdot> \\<top>) \\<sqinter> x \\<cdot> \\<top>) \\<cdot> \\<top> =\n  \\<bottom>\n\ngoal (1 subgoal):\n 1. - (x \\<cdot> \\<top>) \\<cdot> \\<top> \\<le> - (x \\<cdot> \\<top>)", "hence \"-(x \\<cdot> \\<top>) \\<cdot> \\<top> \\<sqinter> (x \\<cdot> \\<top>)  = \\<bottom>\""], ["proof (prove)\nusing this:\n  (- (x \\<cdot> \\<top>) \\<sqinter> x \\<cdot> \\<top>) \\<cdot> \\<top> =\n  \\<bottom>\n\ngoal (1 subgoal):\n 1. - (x \\<cdot> \\<top>) \\<cdot> \\<top> \\<sqinter> x \\<cdot> \\<top> =\n    \\<bottom>", "by (metis rdv')"], ["proof (state)\nthis:\n  - (x \\<cdot> \\<top>) \\<cdot> \\<top> \\<sqinter> x \\<cdot> \\<top> =\n  \\<bottom>\n\ngoal (1 subgoal):\n 1. - (x \\<cdot> \\<top>) \\<cdot> \\<top> \\<le> - (x \\<cdot> \\<top>)", "thus \"-(x \\<cdot> \\<top>) \\<cdot> \\<top> \\<le> -(x \\<cdot> \\<top>)\""], ["proof (prove)\nusing this:\n  - (x \\<cdot> \\<top>) \\<cdot> \\<top> \\<sqinter> x \\<cdot> \\<top> =\n  \\<bottom>\n\ngoal (1 subgoal):\n 1. - (x \\<cdot> \\<top>) \\<cdot> \\<top> \\<le> - (x \\<cdot> \\<top>)", "by (simp add: inf_bot_iff_le)"], ["proof (state)\nthis:\n  - (x \\<cdot> \\<top>) \\<cdot> \\<top> \\<le> - (x \\<cdot> \\<top>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dd_a: \"dblo.d x = a (a x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domain_bdlo_monoid.d (1::'a) (\\<cdot>) (\\<sqinter>) \\<top> x = a (a x)", "by (metis a_d_iff dblo.d_def double_compl inf_top.left_neutral mult_1_left rdv' topr)"], ["", "lemma ad_a [simp]: \"a (dblo.d x) = a x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a (domain_bdlo_monoid.d (1::'a) (\\<cdot>) (\\<sqinter>) \\<top> x) = a x", "by (simp add: a_def)"], ["", "lemma da_a [simp]: \"dblo.d (a x) = a x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domain_bdlo_monoid.d (1::'a) (\\<cdot>) (\\<sqinter>) \\<top> (a x) = a x", "using ad_a dd_a"], ["proof (prove)\nusing this:\n  a (domain_bdlo_monoid.d (1::'a) (\\<cdot>) (\\<sqinter>) \\<top> ?x) = a ?x\n  domain_bdlo_monoid.d (1::'a) (\\<cdot>) (\\<sqinter>) \\<top> ?x = a (a ?x)\n\ngoal (1 subgoal):\n 1. domain_bdlo_monoid.d (1::'a) (\\<cdot>) (\\<sqinter>) \\<top> (a x) = a x", "by auto"], ["", "lemma a1 [simp]: \"a x \\<cdot> x = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a x \\<cdot> x = \\<bottom>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a x \\<cdot> x = \\<bottom>", "have \"a x \\<cdot> x \\<cdot> \\<top> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a x \\<cdot> x \\<cdot> \\<top> = \\<bottom>", "by (metis a_d_iff inf_compl_bot mult_1_left rdv' topr)"], ["proof (state)\nthis:\n  a x \\<cdot> x \\<cdot> \\<top> = \\<bottom>\n\ngoal (1 subgoal):\n 1. a x \\<cdot> x = \\<bottom>", "then"], ["proof (chain)\npicking this:\n  a x \\<cdot> x \\<cdot> \\<top> = \\<bottom>", "show ?thesis"], ["proof (prove)\nusing this:\n  a x \\<cdot> x \\<cdot> \\<top> = \\<bottom>\n\ngoal (1 subgoal):\n 1. a x \\<cdot> x = \\<bottom>", "by (metis (no_types) dblo.d_def dblo.ds.domain_very_strict inf_bot_right)"], ["proof (state)\nthis:\n  a x \\<cdot> x = \\<bottom>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma a2 [simp]: \"a (x \\<cdot> y) \\<squnion> a (x \\<cdot> a (a y)) = a (x \\<cdot> a (a y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a (x \\<cdot> y) \\<squnion> a (x \\<cdot> a (a y)) = a (x \\<cdot> a (a y))", "by (metis a_def dblo.ds.dsr2 dd_a sup.idem)"], ["", "lemma a3 [simp]: \"a (a x) \\<squnion> a x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a (a x) \\<squnion> a x = (1::'a)", "by (metis a_def da_a inf.commute sup.commute sup_compl_top sup_inf_absorb sup_inf_distrib1)"], ["", "subclass domain_bdlo_monoid"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.domain_bdlo_monoid (1::'a) (\\<cdot>) (\\<sqinter>) (\\<le>) (<)\n     (\\<squnion>) \\<bottom> \\<top>", ".."], ["", "text \\<open>The next statement shows that every boolean monoid with domain is an antidomain semiring. \nIn this setting the domain operation has been defined explicitly.\\<close>"], ["", "sublocale ad: antidomain_semiring a \"(\\<squnion>)\" \"(\\<cdot>)\" \"1\" \"\\<bottom>\" \"(\\<le>)\" \"(<)\"\n  rewrites ad_eq: \"ad.ads_d x = d x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.antidomain_semiring a (\\<squnion>) (\\<cdot>) (1::'a) \\<bottom>\n     (\\<le>) (<) &&&\n    antidomain_semiringl.ads_d a x = d x", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. class.antidomain_semiring a (\\<squnion>) (\\<cdot>) (1::'a) \\<bottom>\n     (\\<le>) (<)\n 2. antidomain_semiringl.ads_d a x = d x", "show \"class.antidomain_semiring a (\\<squnion>) (\\<cdot>) 1 \\<bottom> (\\<le>) (<)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.antidomain_semiring a (\\<squnion>) (\\<cdot>) (1::'a) \\<bottom>\n     (\\<le>) (<)", "by (standard, simp_all)"], ["proof (state)\nthis:\n  class.antidomain_semiring a (\\<squnion>) (\\<cdot>) (1::'a) \\<bottom>\n   (\\<le>) (<)\n\ngoal (1 subgoal):\n 1. antidomain_semiringl.ads_d a x = d x", "then"], ["proof (chain)\npicking this:\n  class.antidomain_semiring a (\\<squnion>) (\\<cdot>) (1::'a) \\<bottom>\n   (\\<le>) (<)", "interpret ad: antidomain_semiring a \"(\\<squnion>)\" \"(\\<cdot>)\" \"1\" \"\\<bottom>\" \"(\\<le>)\" \"(<)\""], ["proof (prove)\nusing this:\n  class.antidomain_semiring a (\\<squnion>) (\\<cdot>) (1::'a) \\<bottom>\n   (\\<le>) (<)\n\ngoal (1 subgoal):\n 1. class.antidomain_semiring a (\\<squnion>) (\\<cdot>) (1::'a) \\<bottom>\n     (\\<le>) (<)", "."], ["proof (state)\ngoal (1 subgoal):\n 1. antidomain_semiringl.ads_d a x = d x", "show \"ad.ads_d x = d x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. antidomain_semiringl.ads_d a x = d x", "by (simp add: ad.ads_d_def dd_a)"], ["proof (state)\nthis:\n  antidomain_semiringl.ads_d a x = d x\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection\\<open>Boolean Monoids with Range\\<close>"], ["", "class range_boolean_monoid = boolean_monoid + \n  assumes ldv': \"y \\<cdot> (z \\<sqinter> \\<top> \\<cdot> x) = y \\<cdot> z \\<sqinter> \\<top> \\<cdot> x\"\n\nbegin"], ["", "definition \"r x = 1 \\<sqinter> \\<top> \\<cdot> x\""], ["", "definition \"ar x = 1 \\<sqinter> -(r x)\""], ["", "lemma ar_r_iff: \"ar x = 1 \\<sqinter> -(\\<top> \\<cdot> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ar x = (1::'a) \\<sqinter> - (\\<top> \\<cdot> x)", "by (simp add: ar_def inf_sup_distrib1 r_def)"], ["", "lemma topl: \"\\<top>\\<cdot>(-(\\<top> \\<cdot> x)) = -(\\<top> \\<cdot> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<top> \\<cdot> - (\\<top> \\<cdot> x) = - (\\<top> \\<cdot> x)", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<top> \\<cdot> - (\\<top> \\<cdot> x) \\<le> - (\\<top> \\<cdot> x)\n 2. - (\\<top> \\<cdot> x) \\<le> \\<top> \\<cdot> - (\\<top> \\<cdot> x)", "show \"\\<top> \\<cdot> - (\\<top> \\<cdot> x) \\<le> - (\\<top> \\<cdot> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<top> \\<cdot> - (\\<top> \\<cdot> x) \\<le> - (\\<top> \\<cdot> x)", "by (metis bot_annir' compl_inf_bot inf_bot_iff_le ldv')"], ["proof (state)\nthis:\n  \\<top> \\<cdot> - (\\<top> \\<cdot> x) \\<le> - (\\<top> \\<cdot> x)\n\ngoal (1 subgoal):\n 1. - (\\<top> \\<cdot> x) \\<le> \\<top> \\<cdot> - (\\<top> \\<cdot> x)", "show \"- (\\<top> \\<cdot> x) \\<le> \\<top> \\<cdot> - (\\<top> \\<cdot> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (\\<top> \\<cdot> x) \\<le> \\<top> \\<cdot> - (\\<top> \\<cdot> x)", "by (metis inf_le2 inf_top.right_neutral mult_1_left mult_isor)"], ["proof (state)\nthis:\n  - (\\<top> \\<cdot> x) \\<le> \\<top> \\<cdot> - (\\<top> \\<cdot> x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma r_ar: \"r x = ar (ar x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r x = ar (ar x)", "by (metis ar_r_iff double_compl inf.commute inf_top.right_neutral ldv' mult_1_right r_def topl)"], ["", "lemma ar_ar [simp]: \"ar (r x) = ar x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ar (r x) = ar x", "by (simp add: ar_def ldv' r_def)"], ["", "lemma rar_ar [simp]: \"r (ar x) = ar x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r (ar x) = ar x", "using r_ar ar_ar"], ["proof (prove)\nusing this:\n  r ?x = ar (ar ?x)\n  ar (r ?x) = ar ?x\n\ngoal (1 subgoal):\n 1. r (ar x) = ar x", "by force"], ["", "lemma ar1 [simp]: \"x \\<cdot> ar x = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<cdot> ar x = \\<bottom>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<cdot> ar x = \\<bottom>", "have \"\\<top> \\<cdot> x \\<cdot> ar x = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<top> \\<cdot> x \\<cdot> ar x = \\<bottom>", "by (metis ar_r_iff inf_compl_bot ldv' mult_oner topl)"], ["proof (state)\nthis:\n  \\<top> \\<cdot> x \\<cdot> ar x = \\<bottom>\n\ngoal (1 subgoal):\n 1. x \\<cdot> ar x = \\<bottom>", "then"], ["proof (chain)\npicking this:\n  \\<top> \\<cdot> x \\<cdot> ar x = \\<bottom>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<top> \\<cdot> x \\<cdot> ar x = \\<bottom>\n\ngoal (1 subgoal):\n 1. x \\<cdot> ar x = \\<bottom>", "by (metis inf_bot_iff_le inf_le2 inf_top.right_neutral mult_1_left mult_isor mult_oner topl)"], ["proof (state)\nthis:\n  x \\<cdot> ar x = \\<bottom>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ars: \"r (r x \\<cdot> y) = r (x \\<cdot> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r (r x \\<cdot> y) = r (x \\<cdot> y)", "by (metis inf.commute inf_top.right_neutral ldv' mult_oner mult_assoc r_def)"], ["", "lemma ar2 [simp]: \"ar (x \\<cdot> y) \\<squnion> ar (ar (ar x) \\<cdot> y) = ar (ar (ar x) \\<cdot> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ar (x \\<cdot> y) \\<squnion> ar (ar (ar x) \\<cdot> y) =\n    ar (ar (ar x) \\<cdot> y)", "by (metis ar_def ars r_ar sup.idem)"], ["", "lemma ar3 [simp]: \"ar (ar x) \\<squnion> ar x = 1 \""], ["proof (prove)\ngoal (1 subgoal):\n 1. ar (ar x) \\<squnion> ar x = (1::'a)", "by (metis ar_def rar_ar inf.commute sup.commute sup_compl_top sup_inf_absorb sup_inf_distrib1)"], ["", "sublocale ar: antirange_semiring \"(\\<squnion>)\" \"(\\<cdot>)\" \"1\" \"\\<bottom>\" ar \"(\\<le>)\" \"(<)\"\n  rewrites ar_eq: \"ar.ars_r x = r x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.antirange_semiring (\\<squnion>) (\\<cdot>) (1::'a) \\<bottom> ar\n     (\\<le>) (<) &&&\n    antirange_semiring.ars_r ar x = r x", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. class.antirange_semiring (\\<squnion>) (\\<cdot>) (1::'a) \\<bottom> ar\n     (\\<le>) (<)\n 2. antirange_semiring.ars_r ar x = r x", "show \"class.antirange_semiring (\\<squnion>) (\\<cdot>) 1 \\<bottom> ar (\\<le>) (<)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.antirange_semiring (\\<squnion>) (\\<cdot>) (1::'a) \\<bottom> ar\n     (\\<le>) (<)", "by (standard, simp_all)"], ["proof (state)\nthis:\n  class.antirange_semiring (\\<squnion>) (\\<cdot>) (1::'a) \\<bottom> ar\n   (\\<le>) (<)\n\ngoal (1 subgoal):\n 1. antirange_semiring.ars_r ar x = r x", "then"], ["proof (chain)\npicking this:\n  class.antirange_semiring (\\<squnion>) (\\<cdot>) (1::'a) \\<bottom> ar\n   (\\<le>) (<)", "interpret ar: antirange_semiring \"(\\<squnion>)\" \"(\\<cdot>)\" \"1\" \"\\<bottom>\" ar \"(\\<le>)\" \"(<)\""], ["proof (prove)\nusing this:\n  class.antirange_semiring (\\<squnion>) (\\<cdot>) (1::'a) \\<bottom> ar\n   (\\<le>) (<)\n\ngoal (1 subgoal):\n 1. class.antirange_semiring (\\<squnion>) (\\<cdot>) (1::'a) \\<bottom> ar\n     (\\<le>) (<)", "."], ["proof (state)\ngoal (1 subgoal):\n 1. antirange_semiring.ars_r ar x = r x", "show \"ar.ars_r x = r x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. antirange_semiring.ars_r ar x = r x", "by (simp add: ar.ars_r_def r_ar)"], ["proof (state)\nthis:\n  antirange_semiring.ars_r ar x = r x\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Quantales\\<close>"], ["", "text \\<open>This part will eventually move into an AFP quantale entry.\\<close>"], ["", "class quantale = complete_lattice + monoid_mult +\n  assumes Sup_distr: \"Sup X \\<cdot> y = Sup {z. \\<exists>x \\<in> X. z = x \\<cdot> y}\"\n  and Sup_distl: \"x \\<cdot> Sup Y = Sup {z. \\<exists>y \\<in> Y. z = x \\<cdot> y}\"       \n\nbegin"], ["", "lemma bot_annil'' [simp]: \"\\<bottom> \\<cdot> x = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom> \\<cdot> x = \\<bottom>", "using Sup_distr[where X=\"{}\"]"], ["proof (prove)\nusing this:\n  Sup {} \\<cdot> ?y = Sup {z. \\<exists>x\\<in>{}. z = x \\<cdot> ?y}\n\ngoal (1 subgoal):\n 1. \\<bottom> \\<cdot> x = \\<bottom>", "by auto"], ["", "lemma bot_annirr'' [simp]: \"x \\<cdot> \\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<cdot> \\<bottom> = \\<bottom>", "using Sup_distl[where Y=\"{}\"]"], ["proof (prove)\nusing this:\n  ?x \\<cdot> Sup {} = Sup {z. \\<exists>y\\<in>{}. z = ?x \\<cdot> y}\n\ngoal (1 subgoal):\n 1. x \\<cdot> \\<bottom> = \\<bottom>", "by auto"], ["", "lemma sup_distl: \"x \\<cdot> (y \\<squnion> z) = x \\<cdot> y \\<squnion> x \\<cdot> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<cdot> (y \\<squnion> z) = x \\<cdot> y \\<squnion> x \\<cdot> z", "using Sup_distl[where Y=\"{y, z}\"]"], ["proof (prove)\nusing this:\n  ?x \\<cdot> Sup {y, z} = Sup {za. \\<exists>y\\<in>{y, z}. za = ?x \\<cdot> y}\n\ngoal (1 subgoal):\n 1. x \\<cdot> (y \\<squnion> z) = x \\<cdot> y \\<squnion> x \\<cdot> z", "by (fastforce intro!: Sup_eqI)"], ["", "lemma sup_distr: \"(x \\<squnion> y) \\<cdot> z = x \\<cdot> z \\<squnion> y \\<cdot> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y) \\<cdot> z = x \\<cdot> z \\<squnion> y \\<cdot> z", "using Sup_distr[where X=\"{x, y}\"]"], ["proof (prove)\nusing this:\n  Sup {x, y} \\<cdot> ?y = Sup {z. \\<exists>x\\<in>{x, y}. z = x \\<cdot> ?y}\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y) \\<cdot> z = x \\<cdot> z \\<squnion> y \\<cdot> z", "by (fastforce intro!: Sup_eqI)"], ["", "sublocale semiring_one_zero \"(\\<squnion>)\" \"(\\<cdot>)\" \"1\" \"\\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.semiring_one_zero (\\<squnion>) (\\<cdot>) (1::'a) \\<bottom>", "by (standard, auto simp: sup.assoc sup.commute sup_left_commute sup_distl sup_distr)"], ["", "sublocale dioid_one_zero \"(\\<squnion>)\" \"(\\<cdot>)\" \"1\" \"\\<bottom>\" \"(\\<le>)\" \"(<)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.dioid_one_zero (\\<squnion>) (\\<cdot>) (1::'a) \\<bottom> (\\<le>)\n     (<)", "by (standard, simp add: le_iff_sup, auto)"], ["", "lemma Sup_sup_pred: \"x \\<squnion> Sup{y. P y} = Sup{y. y = x \\<or> P y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> Sup {y. P y} = Sup {y. y = x \\<or> P y}", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<squnion> Sup {y. P y} \\<le> Sup {y. y = x \\<or> P y}\n 2. Sup {y. y = x \\<or> P y} \\<le> x \\<squnion> Sup {y. P y}", "apply (simp add: Collect_mono Sup_subset_mono Sup_upper)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup {y. y = x \\<or> P y} \\<le> x \\<squnion> Sup {y. P y}", "using Sup_least Sup_upper le_supI2"], ["proof (prove)\nusing this:\n  (\\<And>x. x \\<in> ?A \\<Longrightarrow> x \\<le> ?z) \\<Longrightarrow>\n  Sup ?A \\<le> ?z\n  ?x \\<in> ?A \\<Longrightarrow> ?x \\<le> Sup ?A\n  ?x \\<le> ?b \\<Longrightarrow> ?x \\<le> ?a \\<squnion> ?b\n\ngoal (1 subgoal):\n 1. Sup {y. y = x \\<or> P y} \\<le> x \\<squnion> Sup {y. P y}", "by fastforce"], ["", "definition star :: \"'a \\<Rightarrow> 'a\" where\n  \"star x = (SUP i. x ^ i)\""], ["", "lemma star_def_var1: \"star x = Sup{y. \\<exists>i. y = x ^ i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quantale_class.star x = Sup {y. \\<exists>i. y = x ^ i}", "by (simp add: star_def full_SetCompr_eq)"], ["", "lemma star_def_var2: \"star x = Sup{x ^ i |i. True}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quantale_class.star x = Sup {x ^ i |i. True}", "by (simp add: star_def full_SetCompr_eq)"], ["", "lemma star_unfoldl' [simp]: \"1 \\<squnion> x \\<cdot> (star x) = star x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) \\<squnion> x \\<cdot> quantale_class.star x =\n    quantale_class.star x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (1::'a) \\<squnion> x \\<cdot> quantale_class.star x =\n    quantale_class.star x", "have \"1 \\<squnion> x \\<cdot> (star x) = x ^ 0 \\<squnion> x \\<cdot> Sup{y. \\<exists>i. y = x ^ i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) \\<squnion> x \\<cdot> quantale_class.star x =\n    x ^ zero_class.zero \\<squnion> x \\<cdot> Sup {y. \\<exists>i. y = x ^ i}", "by (simp add: star_def_var1)"], ["proof (state)\nthis:\n  (1::'a) \\<squnion> x \\<cdot> quantale_class.star x =\n  x ^ zero_class.zero \\<squnion> x \\<cdot> Sup {y. \\<exists>i. y = x ^ i}\n\ngoal (1 subgoal):\n 1. (1::'a) \\<squnion> x \\<cdot> quantale_class.star x =\n    quantale_class.star x", "also"], ["proof (state)\nthis:\n  (1::'a) \\<squnion> x \\<cdot> quantale_class.star x =\n  x ^ zero_class.zero \\<squnion> x \\<cdot> Sup {y. \\<exists>i. y = x ^ i}\n\ngoal (1 subgoal):\n 1. (1::'a) \\<squnion> x \\<cdot> quantale_class.star x =\n    quantale_class.star x", "have \"... = x ^ 0 \\<squnion> Sup{y. \\<exists>i. y = x ^ (i + 1)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ zero_class.zero \\<squnion>\n    x \\<cdot> Sup {y. \\<exists>i. y = x ^ i} =\n    x ^ zero_class.zero \\<squnion> Sup {y. \\<exists>i. y = x ^ (i + 1)}", "by (simp add: Sup_distl, metis)"], ["proof (state)\nthis:\n  x ^ zero_class.zero \\<squnion> x \\<cdot> Sup {y. \\<exists>i. y = x ^ i} =\n  x ^ zero_class.zero \\<squnion> Sup {y. \\<exists>i. y = x ^ (i + 1)}\n\ngoal (1 subgoal):\n 1. (1::'a) \\<squnion> x \\<cdot> quantale_class.star x =\n    quantale_class.star x", "also"], ["proof (state)\nthis:\n  x ^ zero_class.zero \\<squnion> x \\<cdot> Sup {y. \\<exists>i. y = x ^ i} =\n  x ^ zero_class.zero \\<squnion> Sup {y. \\<exists>i. y = x ^ (i + 1)}\n\ngoal (1 subgoal):\n 1. (1::'a) \\<squnion> x \\<cdot> quantale_class.star x =\n    quantale_class.star x", "have \"... = Sup{y. y = x ^ 0 \\<or> (\\<exists>i. y = x ^ (i + 1))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ zero_class.zero \\<squnion> Sup {y. \\<exists>i. y = x ^ (i + 1)} =\n    Sup {y. y = x ^ zero_class.zero \\<or> (\\<exists>i. y = x ^ (i + 1))}", "using Sup_sup_pred"], ["proof (prove)\nusing this:\n  ?x \\<squnion> Sup {y. ?P y} = Sup {y. y = ?x \\<or> ?P y}\n\ngoal (1 subgoal):\n 1. x ^ zero_class.zero \\<squnion> Sup {y. \\<exists>i. y = x ^ (i + 1)} =\n    Sup {y. y = x ^ zero_class.zero \\<or> (\\<exists>i. y = x ^ (i + 1))}", "by simp"], ["proof (state)\nthis:\n  x ^ zero_class.zero \\<squnion> Sup {y. \\<exists>i. y = x ^ (i + 1)} =\n  Sup {y. y = x ^ zero_class.zero \\<or> (\\<exists>i. y = x ^ (i + 1))}\n\ngoal (1 subgoal):\n 1. (1::'a) \\<squnion> x \\<cdot> quantale_class.star x =\n    quantale_class.star x", "also"], ["proof (state)\nthis:\n  x ^ zero_class.zero \\<squnion> Sup {y. \\<exists>i. y = x ^ (i + 1)} =\n  Sup {y. y = x ^ zero_class.zero \\<or> (\\<exists>i. y = x ^ (i + 1))}\n\ngoal (1 subgoal):\n 1. (1::'a) \\<squnion> x \\<cdot> quantale_class.star x =\n    quantale_class.star x", "have \"... = Sup{y. \\<exists>i. y = x ^ i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup {y. y = x ^ zero_class.zero \\<or> (\\<exists>i. y = x ^ (i + 1))} =\n    Sup {y. \\<exists>i. y = x ^ i}", "by (metis Suc_eq_plus1 power.power.power_Suc power.power_eq_if)"], ["proof (state)\nthis:\n  Sup {y. y = x ^ zero_class.zero \\<or> (\\<exists>i. y = x ^ (i + 1))} =\n  Sup {y. \\<exists>i. y = x ^ i}\n\ngoal (1 subgoal):\n 1. (1::'a) \\<squnion> x \\<cdot> quantale_class.star x =\n    quantale_class.star x", "finally"], ["proof (chain)\npicking this:\n  (1::'a) \\<squnion> x \\<cdot> quantale_class.star x =\n  Sup {y. \\<exists>i. y = x ^ i}", "show ?thesis"], ["proof (prove)\nusing this:\n  (1::'a) \\<squnion> x \\<cdot> quantale_class.star x =\n  Sup {y. \\<exists>i. y = x ^ i}\n\ngoal (1 subgoal):\n 1. (1::'a) \\<squnion> x \\<cdot> quantale_class.star x =\n    quantale_class.star x", "by (simp add: star_def_var1)"], ["proof (state)\nthis:\n  (1::'a) \\<squnion> x \\<cdot> quantale_class.star x = quantale_class.star x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma star_unfoldr' [simp]: \"1 \\<squnion> (star x) \\<cdot> x = star x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) \\<squnion> quantale_class.star x \\<cdot> x =\n    quantale_class.star x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (1::'a) \\<squnion> quantale_class.star x \\<cdot> x =\n    quantale_class.star x", "have \"1 \\<squnion> (star x) \\<cdot> x = x ^ 0 \\<squnion> Sup{y. \\<exists>i. y = x ^ i} \\<cdot> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) \\<squnion> quantale_class.star x \\<cdot> x =\n    x ^ zero_class.zero \\<squnion> Sup {y. \\<exists>i. y = x ^ i} \\<cdot> x", "by (simp add: star_def_var1)"], ["proof (state)\nthis:\n  (1::'a) \\<squnion> quantale_class.star x \\<cdot> x =\n  x ^ zero_class.zero \\<squnion> Sup {y. \\<exists>i. y = x ^ i} \\<cdot> x\n\ngoal (1 subgoal):\n 1. (1::'a) \\<squnion> quantale_class.star x \\<cdot> x =\n    quantale_class.star x", "also"], ["proof (state)\nthis:\n  (1::'a) \\<squnion> quantale_class.star x \\<cdot> x =\n  x ^ zero_class.zero \\<squnion> Sup {y. \\<exists>i. y = x ^ i} \\<cdot> x\n\ngoal (1 subgoal):\n 1. (1::'a) \\<squnion> quantale_class.star x \\<cdot> x =\n    quantale_class.star x", "have \"... = x ^ 0 \\<squnion> Sup{y. \\<exists>i. y = x ^ i \\<cdot> x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ zero_class.zero \\<squnion>\n    Sup {y. \\<exists>i. y = x ^ i} \\<cdot> x =\n    x ^ zero_class.zero \\<squnion> Sup {y. \\<exists>i. y = x ^ i \\<cdot> x}", "by (simp add: Sup_distr, metis)"], ["proof (state)\nthis:\n  x ^ zero_class.zero \\<squnion> Sup {y. \\<exists>i. y = x ^ i} \\<cdot> x =\n  x ^ zero_class.zero \\<squnion> Sup {y. \\<exists>i. y = x ^ i \\<cdot> x}\n\ngoal (1 subgoal):\n 1. (1::'a) \\<squnion> quantale_class.star x \\<cdot> x =\n    quantale_class.star x", "also"], ["proof (state)\nthis:\n  x ^ zero_class.zero \\<squnion> Sup {y. \\<exists>i. y = x ^ i} \\<cdot> x =\n  x ^ zero_class.zero \\<squnion> Sup {y. \\<exists>i. y = x ^ i \\<cdot> x}\n\ngoal (1 subgoal):\n 1. (1::'a) \\<squnion> quantale_class.star x \\<cdot> x =\n    quantale_class.star x", "have \"... = x ^ 0 \\<squnion> Sup{y. \\<exists>i. y = x ^ (i + 1)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ zero_class.zero \\<squnion>\n    Sup {y. \\<exists>i. y = x ^ i \\<cdot> x} =\n    x ^ zero_class.zero \\<squnion> Sup {y. \\<exists>i. y = x ^ (i + 1)}", "using power_Suc2"], ["proof (prove)\nusing this:\n  ?a ^ Suc ?n = ?a ^ ?n \\<cdot> ?a\n\ngoal (1 subgoal):\n 1. x ^ zero_class.zero \\<squnion>\n    Sup {y. \\<exists>i. y = x ^ i \\<cdot> x} =\n    x ^ zero_class.zero \\<squnion> Sup {y. \\<exists>i. y = x ^ (i + 1)}", "by simp"], ["proof (state)\nthis:\n  x ^ zero_class.zero \\<squnion> Sup {y. \\<exists>i. y = x ^ i \\<cdot> x} =\n  x ^ zero_class.zero \\<squnion> Sup {y. \\<exists>i. y = x ^ (i + 1)}\n\ngoal (1 subgoal):\n 1. (1::'a) \\<squnion> quantale_class.star x \\<cdot> x =\n    quantale_class.star x", "also"], ["proof (state)\nthis:\n  x ^ zero_class.zero \\<squnion> Sup {y. \\<exists>i. y = x ^ i \\<cdot> x} =\n  x ^ zero_class.zero \\<squnion> Sup {y. \\<exists>i. y = x ^ (i + 1)}\n\ngoal (1 subgoal):\n 1. (1::'a) \\<squnion> quantale_class.star x \\<cdot> x =\n    quantale_class.star x", "have \"... = Sup{y. y = x ^ 0 \\<or> (\\<exists>i. y = x ^ (i + 1))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ zero_class.zero \\<squnion> Sup {y. \\<exists>i. y = x ^ (i + 1)} =\n    Sup {y. y = x ^ zero_class.zero \\<or> (\\<exists>i. y = x ^ (i + 1))}", "using Sup_sup_pred"], ["proof (prove)\nusing this:\n  ?x \\<squnion> Sup {y. ?P y} = Sup {y. y = ?x \\<or> ?P y}\n\ngoal (1 subgoal):\n 1. x ^ zero_class.zero \\<squnion> Sup {y. \\<exists>i. y = x ^ (i + 1)} =\n    Sup {y. y = x ^ zero_class.zero \\<or> (\\<exists>i. y = x ^ (i + 1))}", "by simp"], ["proof (state)\nthis:\n  x ^ zero_class.zero \\<squnion> Sup {y. \\<exists>i. y = x ^ (i + 1)} =\n  Sup {y. y = x ^ zero_class.zero \\<or> (\\<exists>i. y = x ^ (i + 1))}\n\ngoal (1 subgoal):\n 1. (1::'a) \\<squnion> quantale_class.star x \\<cdot> x =\n    quantale_class.star x", "also"], ["proof (state)\nthis:\n  x ^ zero_class.zero \\<squnion> Sup {y. \\<exists>i. y = x ^ (i + 1)} =\n  Sup {y. y = x ^ zero_class.zero \\<or> (\\<exists>i. y = x ^ (i + 1))}\n\ngoal (1 subgoal):\n 1. (1::'a) \\<squnion> quantale_class.star x \\<cdot> x =\n    quantale_class.star x", "have \"... = Sup{y. \\<exists>i. y = x ^ i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup {y. y = x ^ zero_class.zero \\<or> (\\<exists>i. y = x ^ (i + 1))} =\n    Sup {y. \\<exists>i. y = x ^ i}", "by (metis Suc_eq_plus1 power.power.power_Suc power.power_eq_if)"], ["proof (state)\nthis:\n  Sup {y. y = x ^ zero_class.zero \\<or> (\\<exists>i. y = x ^ (i + 1))} =\n  Sup {y. \\<exists>i. y = x ^ i}\n\ngoal (1 subgoal):\n 1. (1::'a) \\<squnion> quantale_class.star x \\<cdot> x =\n    quantale_class.star x", "finally"], ["proof (chain)\npicking this:\n  (1::'a) \\<squnion> quantale_class.star x \\<cdot> x =\n  Sup {y. \\<exists>i. y = x ^ i}", "show ?thesis"], ["proof (prove)\nusing this:\n  (1::'a) \\<squnion> quantale_class.star x \\<cdot> x =\n  Sup {y. \\<exists>i. y = x ^ i}\n\ngoal (1 subgoal):\n 1. (1::'a) \\<squnion> quantale_class.star x \\<cdot> x =\n    quantale_class.star x", "by (simp add: star_def_var1)"], ["proof (state)\nthis:\n  (1::'a) \\<squnion> quantale_class.star x \\<cdot> x = quantale_class.star x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in dioid_one_zero) power_inductl: \"z + x \\<cdot> y \\<le> y \\<Longrightarrow> (x ^ n) \\<cdot> z \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z + x \\<cdot> y \\<le> y \\<Longrightarrow> x ^ n \\<cdot> z \\<le> y", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. z + x \\<cdot> y \\<le> y \\<Longrightarrow>\n    x ^ zero_class.zero \\<cdot> z \\<le> y\n 2. \\<And>n.\n       \\<lbrakk>z + x \\<cdot> y \\<le> y \\<Longrightarrow>\n                x ^ n \\<cdot> z \\<le> y;\n        z + x \\<cdot> y \\<le> y\\<rbrakk>\n       \\<Longrightarrow> x ^ Suc n \\<cdot> z \\<le> y", "case 0"], ["proof (state)\nthis:\n  z + x \\<cdot> y \\<le> y\n\ngoal (2 subgoals):\n 1. z + x \\<cdot> y \\<le> y \\<Longrightarrow>\n    x ^ zero_class.zero \\<cdot> z \\<le> y\n 2. \\<And>n.\n       \\<lbrakk>z + x \\<cdot> y \\<le> y \\<Longrightarrow>\n                x ^ n \\<cdot> z \\<le> y;\n        z + x \\<cdot> y \\<le> y\\<rbrakk>\n       \\<Longrightarrow> x ^ Suc n \\<cdot> z \\<le> y", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ zero_class.zero \\<cdot> z \\<le> y", "using \"0.prems\""], ["proof (prove)\nusing this:\n  z + x \\<cdot> y \\<le> y\n\ngoal (1 subgoal):\n 1. x ^ zero_class.zero \\<cdot> z \\<le> y", "by simp"], ["proof (state)\nthis:\n  x ^ zero_class.zero \\<cdot> z \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>z + x \\<cdot> y \\<le> y \\<Longrightarrow>\n                x ^ n \\<cdot> z \\<le> y;\n        z + x \\<cdot> y \\<le> y\\<rbrakk>\n       \\<Longrightarrow> x ^ Suc n \\<cdot> z \\<le> y", "case Suc"], ["proof (state)\nthis:\n  z + x \\<cdot> y \\<le> y \\<Longrightarrow> x ^ n_ \\<cdot> z \\<le> y\n  z + x \\<cdot> y \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>z + x \\<cdot> y \\<le> y \\<Longrightarrow>\n                x ^ n \\<cdot> z \\<le> y;\n        z + x \\<cdot> y \\<le> y\\<rbrakk>\n       \\<Longrightarrow> x ^ Suc n \\<cdot> z \\<le> y", "thus ?case"], ["proof (prove)\nusing this:\n  z + x \\<cdot> y \\<le> y \\<Longrightarrow> x ^ n_ \\<cdot> z \\<le> y\n  z + x \\<cdot> y \\<le> y\n\ngoal (1 subgoal):\n 1. x ^ Suc n_ \\<cdot> z \\<le> y", "by (simp, metis mult.assoc mult_isol order_trans)"], ["proof (state)\nthis:\n  x ^ Suc n_ \\<cdot> z \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in dioid_one_zero) power_inductr: \"z + y \\<cdot> x \\<le> y \\<Longrightarrow> z \\<cdot> (x ^ n) \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z + y \\<cdot> x \\<le> y \\<Longrightarrow> z \\<cdot> x ^ n \\<le> y", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n    z \\<cdot> x ^ zero_class.zero \\<le> y\n 2. \\<And>n.\n       \\<lbrakk>z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n                z \\<cdot> x ^ n \\<le> y;\n        z + y \\<cdot> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> z \\<cdot> x ^ Suc n \\<le> y", "case 0"], ["proof (state)\nthis:\n  z + y \\<cdot> x \\<le> y\n\ngoal (2 subgoals):\n 1. z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n    z \\<cdot> x ^ zero_class.zero \\<le> y\n 2. \\<And>n.\n       \\<lbrakk>z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n                z \\<cdot> x ^ n \\<le> y;\n        z + y \\<cdot> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> z \\<cdot> x ^ Suc n \\<le> y", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<cdot> x ^ zero_class.zero \\<le> y", "using \"0.prems\""], ["proof (prove)\nusing this:\n  z + y \\<cdot> x \\<le> y\n\ngoal (1 subgoal):\n 1. z \\<cdot> x ^ zero_class.zero \\<le> y", "by auto"], ["proof (state)\nthis:\n  z \\<cdot> x ^ zero_class.zero \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n                z \\<cdot> x ^ n \\<le> y;\n        z + y \\<cdot> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> z \\<cdot> x ^ Suc n \\<le> y", "case Suc"], ["proof (state)\nthis:\n  z + y \\<cdot> x \\<le> y \\<Longrightarrow> z \\<cdot> x ^ n_ \\<le> y\n  z + y \\<cdot> x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n                z \\<cdot> x ^ n \\<le> y;\n        z + y \\<cdot> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> z \\<cdot> x ^ Suc n \\<le> y", "{"], ["proof (state)\nthis:\n  z + y \\<cdot> x \\<le> y \\<Longrightarrow> z \\<cdot> x ^ n_ \\<le> y\n  z + y \\<cdot> x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n                z \\<cdot> x ^ n \\<le> y;\n        z + y \\<cdot> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> z \\<cdot> x ^ Suc n \\<le> y", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n                z \\<cdot> x ^ n \\<le> y;\n        z + y \\<cdot> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> z \\<cdot> x ^ Suc n \\<le> y", "assume \"z + y \\<cdot> x \\<le> y \\<Longrightarrow> z \\<cdot> x ^ n \\<le> y\"\n      and \"z + y \\<cdot> x \\<le> y\""], ["proof (state)\nthis:\n  z + y \\<cdot> x \\<le> y \\<Longrightarrow> z \\<cdot> x ^ n \\<le> y\n  z + y \\<cdot> x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n                z \\<cdot> x ^ n \\<le> y;\n        z + y \\<cdot> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> z \\<cdot> x ^ Suc n \\<le> y", "hence \"z \\<cdot> x ^ n \\<le> y\""], ["proof (prove)\nusing this:\n  z + y \\<cdot> x \\<le> y \\<Longrightarrow> z \\<cdot> x ^ n \\<le> y\n  z + y \\<cdot> x \\<le> y\n\ngoal (1 subgoal):\n 1. z \\<cdot> x ^ n \\<le> y", "by simp"], ["proof (state)\nthis:\n  z \\<cdot> x ^ n \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n                z \\<cdot> x ^ n \\<le> y;\n        z + y \\<cdot> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> z \\<cdot> x ^ Suc n \\<le> y", "also"], ["proof (state)\nthis:\n  z \\<cdot> x ^ n \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n                z \\<cdot> x ^ n \\<le> y;\n        z + y \\<cdot> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> z \\<cdot> x ^ Suc n \\<le> y", "have \"z \\<cdot> x ^ Suc n = z \\<cdot> x \\<cdot> x ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<cdot> x ^ Suc n = z \\<cdot> x \\<cdot> x ^ n", "by (metis mult.assoc power_Suc)"], ["proof (state)\nthis:\n  z \\<cdot> x ^ Suc n = z \\<cdot> x \\<cdot> x ^ n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n                z \\<cdot> x ^ n \\<le> y;\n        z + y \\<cdot> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> z \\<cdot> x ^ Suc n \\<le> y", "moreover"], ["proof (state)\nthis:\n  z \\<cdot> x ^ Suc n = z \\<cdot> x \\<cdot> x ^ n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n                z \\<cdot> x ^ n \\<le> y;\n        z + y \\<cdot> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> z \\<cdot> x ^ Suc n \\<le> y", "have \"... = (z \\<cdot> x ^ n) \\<cdot> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<cdot> x \\<cdot> x ^ n = z \\<cdot> x ^ n \\<cdot> x", "by (metis mult.assoc power_commutes)"], ["proof (state)\nthis:\n  z \\<cdot> x \\<cdot> x ^ n = z \\<cdot> x ^ n \\<cdot> x\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n                z \\<cdot> x ^ n \\<le> y;\n        z + y \\<cdot> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> z \\<cdot> x ^ Suc n \\<le> y", "moreover"], ["proof (state)\nthis:\n  z \\<cdot> x \\<cdot> x ^ n = z \\<cdot> x ^ n \\<cdot> x\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n                z \\<cdot> x ^ n \\<le> y;\n        z + y \\<cdot> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> z \\<cdot> x ^ Suc n \\<le> y", "have \"... \\<le> y \\<cdot> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<cdot> x ^ n \\<cdot> x \\<le> y \\<cdot> x", "by (metis calculation(1) mult_isor)"], ["proof (state)\nthis:\n  z \\<cdot> x ^ n \\<cdot> x \\<le> y \\<cdot> x\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n                z \\<cdot> x ^ n \\<le> y;\n        z + y \\<cdot> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> z \\<cdot> x ^ Suc n \\<le> y", "moreover"], ["proof (state)\nthis:\n  z \\<cdot> x ^ n \\<cdot> x \\<le> y \\<cdot> x\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n                z \\<cdot> x ^ n \\<le> y;\n        z + y \\<cdot> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> z \\<cdot> x ^ Suc n \\<le> y", "have \"... \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<cdot> x \\<le> y", "using \\<open>z + y \\<cdot> x \\<le> y\\<close>"], ["proof (prove)\nusing this:\n  z + y \\<cdot> x \\<le> y\n\ngoal (1 subgoal):\n 1. y \\<cdot> x \\<le> y", "by simp"], ["proof (state)\nthis:\n  y \\<cdot> x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n                z \\<cdot> x ^ n \\<le> y;\n        z + y \\<cdot> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> z \\<cdot> x ^ Suc n \\<le> y", "ultimately"], ["proof (chain)\npicking this:\n  z \\<cdot> x ^ n \\<le> y\n  z \\<cdot> x ^ Suc n = z \\<cdot> x \\<cdot> x ^ n\n  z \\<cdot> x \\<cdot> x ^ n = z \\<cdot> x ^ n \\<cdot> x\n  z \\<cdot> x ^ n \\<cdot> x \\<le> y \\<cdot> x\n  y \\<cdot> x \\<le> y", "have \"z \\<cdot> x ^ Suc n \\<le> y\""], ["proof (prove)\nusing this:\n  z \\<cdot> x ^ n \\<le> y\n  z \\<cdot> x ^ Suc n = z \\<cdot> x \\<cdot> x ^ n\n  z \\<cdot> x \\<cdot> x ^ n = z \\<cdot> x ^ n \\<cdot> x\n  z \\<cdot> x ^ n \\<cdot> x \\<le> y \\<cdot> x\n  y \\<cdot> x \\<le> y\n\ngoal (1 subgoal):\n 1. z \\<cdot> x ^ Suc n \\<le> y", "by simp"], ["proof (state)\nthis:\n  z \\<cdot> x ^ Suc n \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n                z \\<cdot> x ^ n \\<le> y;\n        z + y \\<cdot> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> z \\<cdot> x ^ Suc n \\<le> y", "}"], ["proof (state)\nthis:\n  \\<lbrakk>z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n           z \\<cdot> x ^ ?nb3 \\<le> y;\n   z + y \\<cdot> x \\<le> y\\<rbrakk>\n  \\<Longrightarrow> z \\<cdot> x ^ Suc ?nb3 \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n                z \\<cdot> x ^ n \\<le> y;\n        z + y \\<cdot> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> z \\<cdot> x ^ Suc n \\<le> y", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>z + y \\<cdot> x \\<le> y \\<Longrightarrow>\n           z \\<cdot> x ^ ?nb3 \\<le> y;\n   z + y \\<cdot> x \\<le> y\\<rbrakk>\n  \\<Longrightarrow> z \\<cdot> x ^ Suc ?nb3 \\<le> y\n\ngoal (1 subgoal):\n 1. z \\<cdot> x ^ Suc n_ \\<le> y", "by (metis Suc)"], ["proof (state)\nthis:\n  z \\<cdot> x ^ Suc n_ \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma star_inductl': \"z \\<squnion> x \\<cdot> y \\<le> y \\<Longrightarrow> (star x) \\<cdot> z \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<squnion> x \\<cdot> y \\<le> y \\<Longrightarrow>\n    quantale_class.star x \\<cdot> z \\<le> y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<squnion> x \\<cdot> y \\<le> y \\<Longrightarrow>\n    quantale_class.star x \\<cdot> z \\<le> y", "assume \"z \\<squnion> x \\<cdot> y \\<le> y\""], ["proof (state)\nthis:\n  z \\<squnion> x \\<cdot> y \\<le> y\n\ngoal (1 subgoal):\n 1. z \\<squnion> x \\<cdot> y \\<le> y \\<Longrightarrow>\n    quantale_class.star x \\<cdot> z \\<le> y", "hence \"\\<forall>i. x ^ i \\<cdot> z \\<le> y\""], ["proof (prove)\nusing this:\n  z \\<squnion> x \\<cdot> y \\<le> y\n\ngoal (1 subgoal):\n 1. \\<forall>i. x ^ i \\<cdot> z \\<le> y", "by (simp add: power_inductl)"], ["proof (state)\nthis:\n  \\<forall>i. x ^ i \\<cdot> z \\<le> y\n\ngoal (1 subgoal):\n 1. z \\<squnion> x \\<cdot> y \\<le> y \\<Longrightarrow>\n    quantale_class.star x \\<cdot> z \\<le> y", "hence \"Sup{w. \\<exists>i. w = x ^ i \\<cdot> z} \\<le> y\""], ["proof (prove)\nusing this:\n  \\<forall>i. x ^ i \\<cdot> z \\<le> y\n\ngoal (1 subgoal):\n 1. Sup {w. \\<exists>i. w = x ^ i \\<cdot> z} \\<le> y", "by (intro Sup_least, fast)"], ["proof (state)\nthis:\n  Sup {w. \\<exists>i. w = x ^ i \\<cdot> z} \\<le> y\n\ngoal (1 subgoal):\n 1. z \\<squnion> x \\<cdot> y \\<le> y \\<Longrightarrow>\n    quantale_class.star x \\<cdot> z \\<le> y", "hence \"Sup{w. \\<exists>i. w = x ^ i} \\<cdot> z \\<le> y\""], ["proof (prove)\nusing this:\n  Sup {w. \\<exists>i. w = x ^ i \\<cdot> z} \\<le> y\n\ngoal (1 subgoal):\n 1. Sup {w. \\<exists>i. w = x ^ i} \\<cdot> z \\<le> y", "using Sup_distr Sup_le_iff"], ["proof (prove)\nusing this:\n  Sup {w. \\<exists>i. w = x ^ i \\<cdot> z} \\<le> y\n  Sup ?X \\<cdot> ?y = Sup {z. \\<exists>x\\<in>?X. z = x \\<cdot> ?y}\n  (Sup ?A \\<le> ?b) = (\\<forall>a\\<in>?A. a \\<le> ?b)\n\ngoal (1 subgoal):\n 1. Sup {w. \\<exists>i. w = x ^ i} \\<cdot> z \\<le> y", "by auto"], ["proof (state)\nthis:\n  Sup {w. \\<exists>i. w = x ^ i} \\<cdot> z \\<le> y\n\ngoal (1 subgoal):\n 1. z \\<squnion> x \\<cdot> y \\<le> y \\<Longrightarrow>\n    quantale_class.star x \\<cdot> z \\<le> y", "thus \"(star x) \\<cdot> z \\<le> y\""], ["proof (prove)\nusing this:\n  Sup {w. \\<exists>i. w = x ^ i} \\<cdot> z \\<le> y\n\ngoal (1 subgoal):\n 1. quantale_class.star x \\<cdot> z \\<le> y", "by (simp add: star_def_var1)"], ["proof (state)\nthis:\n  quantale_class.star x \\<cdot> z \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma star_inductr': \"z \\<squnion> y \\<cdot> x \\<le> y \\<Longrightarrow> z \\<cdot> (star x) \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<squnion> y \\<cdot> x \\<le> y \\<Longrightarrow>\n    z \\<cdot> quantale_class.star x \\<le> y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<squnion> y \\<cdot> x \\<le> y \\<Longrightarrow>\n    z \\<cdot> quantale_class.star x \\<le> y", "assume \"z \\<squnion> y \\<cdot> x \\<le> y\""], ["proof (state)\nthis:\n  z \\<squnion> y \\<cdot> x \\<le> y\n\ngoal (1 subgoal):\n 1. z \\<squnion> y \\<cdot> x \\<le> y \\<Longrightarrow>\n    z \\<cdot> quantale_class.star x \\<le> y", "hence \"\\<forall>i. z \\<cdot> x ^ i  \\<le> y\""], ["proof (prove)\nusing this:\n  z \\<squnion> y \\<cdot> x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<forall>i. z \\<cdot> x ^ i \\<le> y", "by (simp add: power_inductr)"], ["proof (state)\nthis:\n  \\<forall>i. z \\<cdot> x ^ i \\<le> y\n\ngoal (1 subgoal):\n 1. z \\<squnion> y \\<cdot> x \\<le> y \\<Longrightarrow>\n    z \\<cdot> quantale_class.star x \\<le> y", "hence \"Sup{w. \\<exists>i. w = z \\<cdot> x ^ i} \\<le> y\""], ["proof (prove)\nusing this:\n  \\<forall>i. z \\<cdot> x ^ i \\<le> y\n\ngoal (1 subgoal):\n 1. Sup {w. \\<exists>i. w = z \\<cdot> x ^ i} \\<le> y", "by (intro Sup_least, fast)"], ["proof (state)\nthis:\n  Sup {w. \\<exists>i. w = z \\<cdot> x ^ i} \\<le> y\n\ngoal (1 subgoal):\n 1. z \\<squnion> y \\<cdot> x \\<le> y \\<Longrightarrow>\n    z \\<cdot> quantale_class.star x \\<le> y", "hence \"z \\<cdot> Sup{w. \\<exists>i. w = x ^ i} \\<le> y\""], ["proof (prove)\nusing this:\n  Sup {w. \\<exists>i. w = z \\<cdot> x ^ i} \\<le> y\n\ngoal (1 subgoal):\n 1. z \\<cdot> Sup {w. \\<exists>i. w = x ^ i} \\<le> y", "using Sup_distl Sup_le_iff"], ["proof (prove)\nusing this:\n  Sup {w. \\<exists>i. w = z \\<cdot> x ^ i} \\<le> y\n  ?x \\<cdot> Sup ?Y = Sup {z. \\<exists>y\\<in>?Y. z = ?x \\<cdot> y}\n  (Sup ?A \\<le> ?b) = (\\<forall>a\\<in>?A. a \\<le> ?b)\n\ngoal (1 subgoal):\n 1. z \\<cdot> Sup {w. \\<exists>i. w = x ^ i} \\<le> y", "by auto"], ["proof (state)\nthis:\n  z \\<cdot> Sup {w. \\<exists>i. w = x ^ i} \\<le> y\n\ngoal (1 subgoal):\n 1. z \\<squnion> y \\<cdot> x \\<le> y \\<Longrightarrow>\n    z \\<cdot> quantale_class.star x \\<le> y", "thus \"z \\<cdot> (star x) \\<le> y\""], ["proof (prove)\nusing this:\n  z \\<cdot> Sup {w. \\<exists>i. w = x ^ i} \\<le> y\n\ngoal (1 subgoal):\n 1. z \\<cdot> quantale_class.star x \\<le> y", "by (simp add: star_def_var1)"], ["proof (state)\nthis:\n  z \\<cdot> quantale_class.star x \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["", "sublocale ka: kleene_algebra \"(\\<squnion>)\" \"(\\<cdot>)\" \"1\" \"\\<bottom>\" \"(\\<le>)\" \"(<)\" star"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.kleene_algebra (\\<squnion>) (\\<cdot>) (1::'a) \\<bottom> (\\<le>)\n     (<) quantale_class.star", "by standard (simp_all add: star_inductl' star_inductr')"], ["", "end"], ["", "text \\<open>Distributive quantales are often assumed to satisfy infinite distributivity laws between\njoins and meets, but finite ones suffice for our purposes.\\<close>"], ["", "class distributive_quantale = quantale + distrib_lattice \n\nbegin"], ["", "subclass bd_lattice_ordered_monoid"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.bd_lattice_ordered_monoid (1::'a) (\\<cdot>) (\\<sqinter>) (\\<le>)\n     (<) (\\<squnion>) \\<bottom> \\<top>", "by (standard, simp_all add: distrib_left)"], ["", "lemma \"(1 \\<sqinter> x \\<cdot> \\<top>) \\<cdot> x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((1::'a) \\<sqinter> x \\<cdot> \\<top>) \\<cdot> x = x", "(* nitpick [expect=genuine]*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((1::'a) \\<sqinter> x \\<cdot> \\<top>) \\<cdot> x = x", "oops"], ["", "end"], ["", "subsection \\<open>Domain Quantales\\<close>"], ["", "class domain_quantale = distributive_quantale +\n  assumes rdv'': \"(z \\<sqinter> x \\<cdot> \\<top>) \\<cdot> y = z \\<cdot> y \\<sqinter> x \\<cdot> \\<top>\"  \n\nbegin"], ["", "subclass domain_bdlo_monoid"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.domain_bdlo_monoid (1::'a) (\\<cdot>) (\\<sqinter>) (\\<le>) (<)\n     (\\<squnion>) \\<bottom> \\<top>", "by (standard, simp add: rdv'')"], ["", "end"], ["", "class range_quantale = distributive_quantale +\n  assumes ldv'': \"y \\<cdot> (z \\<sqinter> \\<top> \\<cdot> x) = y \\<cdot> z \\<sqinter> \\<top> \\<cdot> x\""], ["", "class boolean_quantale = quantale + complete_boolean_algebra\n\nbegin"], ["", "subclass boolean_monoid"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.boolean_monoid (1::'a) (\\<cdot>) (-) uminus (\\<sqinter>) (\\<le>)\n     (<) (\\<squnion>) \\<bottom> \\<top>", "by (standard, simp_all add: sup_distl)"], ["", "lemma \"(1 \\<sqinter> x \\<cdot> \\<top>) \\<cdot> x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((1::'a) \\<sqinter> x \\<cdot> \\<top>) \\<cdot> x = x", "(*nitpick[expect=genuine]*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((1::'a) \\<sqinter> x \\<cdot> \\<top>) \\<cdot> x = x", "oops"], ["", "lemma \"(1 \\<sqinter> -(x \\<cdot> \\<top>)) \\<cdot> x = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((1::'a) \\<sqinter> - (x \\<cdot> \\<top>)) \\<cdot> x = \\<bottom>", "(*nitpick[expect=genuine]*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((1::'a) \\<sqinter> - (x \\<cdot> \\<top>)) \\<cdot> x = \\<bottom>", "oops"], ["", "end"], ["", "subsection\\<open>Boolean Domain Quantales\\<close>"], ["", "class domain_boolean_quantale = domain_quantale + boolean_quantale\n\nbegin"], ["", "subclass domain_boolean_monoid"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.domain_boolean_monoid (1::'a) (\\<cdot>) (-) uminus (\\<sqinter>)\n     (\\<le>) (<) (\\<squnion>) \\<bottom> \\<top>", "by (standard, simp add: rdv'')"], ["", "lemma fbox_eq: \"ad.fbox x q = Sup{d p |p. d p \\<cdot> x \\<le> x \\<cdot> d q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. antidomain_semiringl.fbox a (\\<cdot>) x q =\n    Sup {d p |p. d p \\<cdot> x \\<le> x \\<cdot> d q}", "apply (rule Sup_eqI[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<in> {d p |p. d p \\<cdot> x \\<le> x \\<cdot> d q} \\<Longrightarrow>\n       y \\<le> antidomain_semiringl.fbox a (\\<cdot>) x q\n 2. \\<And>y.\n       (\\<And>z.\n           z \\<in> {d p |p.\n                    d p \\<cdot> x \\<le> x \\<cdot> d q} \\<Longrightarrow>\n           z \\<le> y) \\<Longrightarrow>\n       antidomain_semiringl.fbox a (\\<cdot>) x q \\<le> y", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p.\n       d p \\<cdot> x \\<le> x \\<cdot> d q \\<Longrightarrow>\n       d p \\<le> antidomain_semiringl.fbox a (\\<cdot>) x q\n 2. \\<And>y.\n       (\\<And>z.\n           z \\<in> {d p |p.\n                    d p \\<cdot> x \\<le> x \\<cdot> d q} \\<Longrightarrow>\n           z \\<le> y) \\<Longrightarrow>\n       antidomain_semiringl.fbox a (\\<cdot>) x q \\<le> y", "using ad.fbox_demodalisation3 ad.fbox_simp"], ["proof (prove)\nusing this:\n  (d ?y \\<le> antidomain_semiringl.fbox a (\\<cdot>) ?x (d ?z)) =\n  (d ?y \\<cdot> ?x \\<le> ?x \\<cdot> d ?z)\n  antidomain_semiringl.fbox a (\\<cdot>) ?x ?y =\n  antidomain_semiringl.fbox a (\\<cdot>) ?x (d ?y)\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       d p \\<cdot> x \\<le> x \\<cdot> d q \\<Longrightarrow>\n       d p \\<le> antidomain_semiringl.fbox a (\\<cdot>) x q\n 2. \\<And>y.\n       (\\<And>z.\n           z \\<in> {d p |p.\n                    d p \\<cdot> x \\<le> x \\<cdot> d q} \\<Longrightarrow>\n           z \\<le> y) \\<Longrightarrow>\n       antidomain_semiringl.fbox a (\\<cdot>) x q \\<le> y", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       (\\<And>z.\n           z \\<in> {d p |p.\n                    d p \\<cdot> x \\<le> x \\<cdot> d q} \\<Longrightarrow>\n           z \\<le> y) \\<Longrightarrow>\n       antidomain_semiringl.fbox a (\\<cdot>) x q \\<le> y", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       (\\<And>z.\n           \\<exists>p.\n              z = d p \\<and>\n              d p \\<cdot> x \\<le> x \\<cdot> d q \\<Longrightarrow>\n           z \\<le> y) \\<Longrightarrow>\n       antidomain_semiringl.fbox a (\\<cdot>) x q \\<le> y", "by (metis ad.fbox_def ad.fbox_demodalisation3 ad.fbox_simp da_a eq_refl)"], ["", "lemma fdia_eq: \"ad.fdia x p = Inf{d q |q. x \\<cdot> d p \\<le> d q \\<cdot> x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. antidomain_semiringl.fdia a (\\<cdot>) x p =\n    Inf {d q |q. x \\<cdot> d p \\<le> d q \\<cdot> x}", "apply (rule Inf_eqI[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<in> {d q |q. x \\<cdot> d p \\<le> d q \\<cdot> x} \\<Longrightarrow>\n       antidomain_semiringl.fdia a (\\<cdot>) x p \\<le> i\n 2. \\<And>y.\n       (\\<And>i.\n           i \\<in> {d q |q.\n                    x \\<cdot> d p \\<le> d q \\<cdot> x} \\<Longrightarrow>\n           y \\<le> i) \\<Longrightarrow>\n       y \\<le> antidomain_semiringl.fdia a (\\<cdot>) x p", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q.\n       x \\<cdot> d p \\<le> d q \\<cdot> x \\<Longrightarrow>\n       antidomain_semiringl.fdia a (\\<cdot>) x p \\<le> d q\n 2. \\<And>y.\n       (\\<And>i.\n           i \\<in> {d q |q.\n                    x \\<cdot> d p \\<le> d q \\<cdot> x} \\<Longrightarrow>\n           y \\<le> i) \\<Longrightarrow>\n       y \\<le> antidomain_semiringl.fdia a (\\<cdot>) x p", "using ds.fdemodalisation2"], ["proof (prove)\nusing this:\n  (domain_semiringl.fd (\\<cdot>) d ?x ?y \\<le> d ?z) =\n  (?x \\<cdot> d ?y \\<le> d ?z \\<cdot> ?x)\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       x \\<cdot> d p \\<le> d q \\<cdot> x \\<Longrightarrow>\n       antidomain_semiringl.fdia a (\\<cdot>) x p \\<le> d q\n 2. \\<And>y.\n       (\\<And>i.\n           i \\<in> {d q |q.\n                    x \\<cdot> d p \\<le> d q \\<cdot> x} \\<Longrightarrow>\n           y \\<le> i) \\<Longrightarrow>\n       y \\<le> antidomain_semiringl.fdia a (\\<cdot>) x p", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       (\\<And>i.\n           i \\<in> {d q |q.\n                    x \\<cdot> d p \\<le> d q \\<cdot> x} \\<Longrightarrow>\n           y \\<le> i) \\<Longrightarrow>\n       y \\<le> antidomain_semiringl.fdia a (\\<cdot>) x p", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       (\\<And>i.\n           \\<exists>q.\n              i = d q \\<and>\n              x \\<cdot> d p \\<le> d q \\<cdot> x \\<Longrightarrow>\n           y \\<le> i) \\<Longrightarrow>\n       y \\<le> antidomain_semiringl.fdia a (\\<cdot>) x p", "by (metis ad.fd_eq_fdia ad.fdia_def da_a double_compl ds.fdemodalisation2 inf_bot_iff_le inf_compl_bot)"], ["", "text \\<open>The specification statement can be defined explicitly.\\<close>"], ["", "definition R :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a\" where\n  \"R p q \\<equiv> Sup{x. (d p) \\<cdot> x \\<le> x \\<cdot> d q}\""], ["", "lemma \"x \\<le> R p q \\<Longrightarrow> d p \\<le> ad.fbox x (d q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> R p q \\<Longrightarrow>\n    d p \\<le> antidomain_semiringl.fbox a (\\<cdot>) x (d q)", "proof (simp add: R_def ad.kat_1_equiv ad.kat_2_equiv)"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<le> Sup {x. d p \\<cdot> x \\<cdot> a q = \\<bottom>} \\<Longrightarrow>\n    d p \\<le> antidomain_semiringl.fbox a (\\<cdot>) x (d q)", "assume \"x \\<le> Sup{x. d p \\<cdot> x \\<cdot> a q = \\<bottom>}\""], ["proof (state)\nthis:\n  x \\<le> Sup {x. d p \\<cdot> x \\<cdot> a q = \\<bottom>}\n\ngoal (1 subgoal):\n 1. x \\<le> Sup {x. d p \\<cdot> x \\<cdot> a q = \\<bottom>} \\<Longrightarrow>\n    d p \\<le> antidomain_semiringl.fbox a (\\<cdot>) x (d q)", "hence \"d p \\<cdot> x \\<cdot> a q \\<le> d p \\<cdot> Sup{x. d p \\<cdot> x \\<cdot> a q = \\<bottom>} \\<cdot> a q \""], ["proof (prove)\nusing this:\n  x \\<le> Sup {x. d p \\<cdot> x \\<cdot> a q = \\<bottom>}\n\ngoal (1 subgoal):\n 1. d p \\<cdot> x \\<cdot> a q\n    \\<le> d p \\<cdot> Sup {x. d p \\<cdot> x \\<cdot> a q = \\<bottom>} \\<cdot>\n          a q", "using mult_double_iso"], ["proof (prove)\nusing this:\n  x \\<le> Sup {x. d p \\<cdot> x \\<cdot> a q = \\<bottom>}\n  ?x \\<le> ?y \\<Longrightarrow>\n  ?w \\<cdot> ?x \\<cdot> ?z \\<le> ?w \\<cdot> ?y \\<cdot> ?z\n\ngoal (1 subgoal):\n 1. d p \\<cdot> x \\<cdot> a q\n    \\<le> d p \\<cdot> Sup {x. d p \\<cdot> x \\<cdot> a q = \\<bottom>} \\<cdot>\n          a q", "by blast"], ["proof (state)\nthis:\n  d p \\<cdot> x \\<cdot> a q\n  \\<le> d p \\<cdot> Sup {x. d p \\<cdot> x \\<cdot> a q = \\<bottom>} \\<cdot>\n        a q\n\ngoal (1 subgoal):\n 1. x \\<le> Sup {x. d p \\<cdot> x \\<cdot> a q = \\<bottom>} \\<Longrightarrow>\n    d p \\<le> antidomain_semiringl.fbox a (\\<cdot>) x (d q)", "also"], ["proof (state)\nthis:\n  d p \\<cdot> x \\<cdot> a q\n  \\<le> d p \\<cdot> Sup {x. d p \\<cdot> x \\<cdot> a q = \\<bottom>} \\<cdot>\n        a q\n\ngoal (1 subgoal):\n 1. x \\<le> Sup {x. d p \\<cdot> x \\<cdot> a q = \\<bottom>} \\<Longrightarrow>\n    d p \\<le> antidomain_semiringl.fbox a (\\<cdot>) x (d q)", "have \"... = Sup{d p \\<cdot> x \\<cdot> a q |x. d p \\<cdot> x \\<cdot> a q = \\<bottom>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d p \\<cdot> Sup {x. d p \\<cdot> x \\<cdot> a q = \\<bottom>} \\<cdot> a q =\n    Sup {d p \\<cdot> x \\<cdot> a q |x.\n         d p \\<cdot> x \\<cdot> a q = \\<bottom>}", "apply (subst Sup_distl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup {z. \\<exists>y\\<in>{x. d p \\<cdot> x \\<cdot> a q = \\<bottom>}.\n               z = d p \\<cdot> y} \\<cdot>\n    a q =\n    Sup {d p \\<cdot> x \\<cdot> a q |x.\n         d p \\<cdot> x \\<cdot> a q = \\<bottom>}", "apply (subst Sup_distr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup {z. \\<exists>x\\<in>{z. \\<exists>y\n  \\<in>{x. d p \\<cdot> x \\<cdot> a q = \\<bottom>}.\n                                  z = d p \\<cdot> y}.\n               z = x \\<cdot> a q} =\n    Sup {d p \\<cdot> x \\<cdot> a q |x.\n         d p \\<cdot> x \\<cdot> a q = \\<bottom>}", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup {z. \\<exists>x.\n               (\\<exists>y.\n                   d p \\<cdot> y \\<cdot> a q = \\<bottom> \\<and>\n                   x = d p \\<cdot> y) \\<and>\n               z = x \\<cdot> a q} =\n    Sup {d p \\<cdot> x \\<cdot> a q |x.\n         d p \\<cdot> x \\<cdot> a q = \\<bottom>}", "by metis"], ["proof (state)\nthis:\n  d p \\<cdot> Sup {x. d p \\<cdot> x \\<cdot> a q = \\<bottom>} \\<cdot> a q =\n  Sup {d p \\<cdot> x \\<cdot> a q |x. d p \\<cdot> x \\<cdot> a q = \\<bottom>}\n\ngoal (1 subgoal):\n 1. x \\<le> Sup {x. d p \\<cdot> x \\<cdot> a q = \\<bottom>} \\<Longrightarrow>\n    d p \\<le> antidomain_semiringl.fbox a (\\<cdot>) x (d q)", "also"], ["proof (state)\nthis:\n  d p \\<cdot> Sup {x. d p \\<cdot> x \\<cdot> a q = \\<bottom>} \\<cdot> a q =\n  Sup {d p \\<cdot> x \\<cdot> a q |x. d p \\<cdot> x \\<cdot> a q = \\<bottom>}\n\ngoal (1 subgoal):\n 1. x \\<le> Sup {x. d p \\<cdot> x \\<cdot> a q = \\<bottom>} \\<Longrightarrow>\n    d p \\<le> antidomain_semiringl.fbox a (\\<cdot>) x (d q)", "have \"... = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup {d p \\<cdot> x \\<cdot> a q |x.\n         d p \\<cdot> x \\<cdot> a q = \\<bottom>} =\n    \\<bottom>", "by (auto simp: Sup_eqI)"], ["proof (state)\nthis:\n  Sup {d p \\<cdot> x \\<cdot> a q |x.\n       d p \\<cdot> x \\<cdot> a q = \\<bottom>} =\n  \\<bottom>\n\ngoal (1 subgoal):\n 1. x \\<le> Sup {x. d p \\<cdot> x \\<cdot> a q = \\<bottom>} \\<Longrightarrow>\n    d p \\<le> antidomain_semiringl.fbox a (\\<cdot>) x (d q)", "finally"], ["proof (chain)\npicking this:\n  d p \\<cdot> x \\<cdot> a q \\<le> \\<bottom>", "show ?thesis"], ["proof (prove)\nusing this:\n  d p \\<cdot> x \\<cdot> a q \\<le> \\<bottom>\n\ngoal (1 subgoal):\n 1. d p \\<le> antidomain_semiringl.fbox a (\\<cdot>) x (d q)", "using ad.fbox_demodalisation3 ad.kat_3 ad.kat_4 le_bot"], ["proof (prove)\nusing this:\n  d p \\<cdot> x \\<cdot> a q \\<le> \\<bottom>\n  (d ?y \\<le> antidomain_semiringl.fbox a (\\<cdot>) ?x (d ?z)) =\n  (d ?y \\<cdot> ?x \\<le> ?x \\<cdot> d ?z)\n  d ?x \\<cdot> ?y \\<cdot> a ?z = \\<bottom> \\<Longrightarrow>\n  d ?x \\<cdot> ?y = d ?x \\<cdot> ?y \\<cdot> d ?z\n  d ?x \\<cdot> ?y = d ?x \\<cdot> ?y \\<cdot> d ?z \\<Longrightarrow>\n  d ?x \\<cdot> ?y \\<le> ?y \\<cdot> d ?z\n  ?a \\<le> \\<bottom> \\<Longrightarrow> ?a = \\<bottom>\n\ngoal (1 subgoal):\n 1. d p \\<le> antidomain_semiringl.fbox a (\\<cdot>) x (d q)", "by blast"], ["proof (state)\nthis:\n  d p \\<le> antidomain_semiringl.fbox a (\\<cdot>) x (d q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \"d p \\<le> ad.fbox x (d q) \\<Longrightarrow> x \\<le> R p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d p\n    \\<le> antidomain_semiringl.fbox a (\\<cdot>) x (d q) \\<Longrightarrow>\n    x \\<le> R p q", "apply (simp add: R_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. d p\n    \\<le> antidomain_semiringl.fbox a (\\<cdot>) x (d q) \\<Longrightarrow>\n    x \\<le> Sup {x. d p \\<cdot> x \\<le> x \\<cdot> d q}", "apply (rule Sup_upper)"], ["proof (prove)\ngoal (1 subgoal):\n 1. d p\n    \\<le> antidomain_semiringl.fbox a (\\<cdot>) x (d q) \\<Longrightarrow>\n    x \\<in> {x. d p \\<cdot> x \\<le> x \\<cdot> d q}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. d p\n    \\<le> antidomain_semiringl.fbox a (\\<cdot>) x (d q) \\<Longrightarrow>\n    d p \\<cdot> x \\<le> x \\<cdot> d q", "using ad.fbox_demodalisation3 ad.fbox_simp"], ["proof (prove)\nusing this:\n  (d ?y \\<le> antidomain_semiringl.fbox a (\\<cdot>) ?x (d ?z)) =\n  (d ?y \\<cdot> ?x \\<le> ?x \\<cdot> d ?z)\n  antidomain_semiringl.fbox a (\\<cdot>) ?x ?y =\n  antidomain_semiringl.fbox a (\\<cdot>) ?x (d ?y)\n\ngoal (1 subgoal):\n 1. d p\n    \\<le> antidomain_semiringl.fbox a (\\<cdot>) x (d q) \\<Longrightarrow>\n    d p \\<cdot> x \\<le> x \\<cdot> d q", "apply auto[1]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsection\\<open>Relational Model of Boolean Domain Quantales\\<close>"], ["", "interpretation rel_dbq: domain_boolean_quantale Inter Union \"(\\<inter>)\" \"(\\<subseteq>)\" \"(\\<subset>)\" \"(\\<union>)\" \"{}\" UNIV minus uminus Id \"(O)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.domain_boolean_quantale \\<Inter> \\<Union> (\\<inter>) (\\<subseteq>)\n     (\\<subset>) (\\<union>) {} UNIV (-) uminus Id (O)", "apply (standard, simp_all add: O_assoc)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>X y. \\<Union> X O y = \\<Union> {z. \\<exists>x\\<in>X. z = x O y}\n 2. \\<And>x Y. x O \\<Union> Y = \\<Union> {z. \\<exists>y\\<in>Y. z = x O y}\n 3. \\<And>z x y. (z \\<inter> x O UNIV) O y = z O y \\<inter> x O UNIV", "by blast +"], ["", "subsection\\<open>Modal Boolean Quantales\\<close>"], ["", "class range_boolean_quantale = range_quantale + boolean_quantale\n\nbegin"], ["", "subclass range_boolean_monoid"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.range_boolean_monoid (1::'a) (\\<cdot>) (-) uminus (\\<sqinter>)\n     (\\<le>) (<) (\\<squnion>) \\<bottom> \\<top>", "by (standard, simp add: ldv'')"], ["", "lemma fbox_eq: \"ar.bbox x (r q) = Sup{r p |p. x \\<cdot> r p \\<le> (r q) \\<cdot> x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. antirange_semiring.bbox (\\<cdot>) ar x (r q) =\n    Sup {r p |p. x \\<cdot> r p \\<le> r q \\<cdot> x}", "apply (rule Sup_eqI[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<in> {r p |p. x \\<cdot> r p \\<le> r q \\<cdot> x} \\<Longrightarrow>\n       y \\<le> antirange_semiring.bbox (\\<cdot>) ar x (r q)\n 2. \\<And>y.\n       (\\<And>z.\n           z \\<in> {r p |p.\n                    x \\<cdot> r p \\<le> r q \\<cdot> x} \\<Longrightarrow>\n           z \\<le> y) \\<Longrightarrow>\n       antirange_semiring.bbox (\\<cdot>) ar x (r q) \\<le> y", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p.\n       x \\<cdot> r p \\<le> r q \\<cdot> x \\<Longrightarrow>\n       r p \\<le> antirange_semiring.bbox (\\<cdot>) ar x (r q)\n 2. \\<And>y.\n       (\\<And>z.\n           z \\<in> {r p |p.\n                    x \\<cdot> r p \\<le> r q \\<cdot> x} \\<Longrightarrow>\n           z \\<le> y) \\<Longrightarrow>\n       antirange_semiring.bbox (\\<cdot>) ar x (r q) \\<le> y", "using ar.ardual.fbox_demodalisation3 ar.ardual.fbox_simp"], ["proof (prove)\nusing this:\n  (r ?y \\<le> antirange_semiring.bbox (\\<cdot>) ar ?x (r ?z)) =\n  (?x \\<cdot> r ?y \\<le> r ?z \\<cdot> ?x)\n  antirange_semiring.bbox (\\<cdot>) ar ?x ?y =\n  antirange_semiring.bbox (\\<cdot>) ar ?x (r ?y)\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       x \\<cdot> r p \\<le> r q \\<cdot> x \\<Longrightarrow>\n       r p \\<le> antirange_semiring.bbox (\\<cdot>) ar x (r q)\n 2. \\<And>y.\n       (\\<And>z.\n           z \\<in> {r p |p.\n                    x \\<cdot> r p \\<le> r q \\<cdot> x} \\<Longrightarrow>\n           z \\<le> y) \\<Longrightarrow>\n       antirange_semiring.bbox (\\<cdot>) ar x (r q) \\<le> y", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       (\\<And>z.\n           z \\<in> {r p |p.\n                    x \\<cdot> r p \\<le> r q \\<cdot> x} \\<Longrightarrow>\n           z \\<le> y) \\<Longrightarrow>\n       antirange_semiring.bbox (\\<cdot>) ar x (r q) \\<le> y", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       (\\<And>z.\n           \\<exists>p.\n              z = r p \\<and>\n              x \\<cdot> r p \\<le> r q \\<cdot> x \\<Longrightarrow>\n           z \\<le> y) \\<Longrightarrow>\n       antirange_semiring.bbox (\\<cdot>) ar x (r q) \\<le> y", "by (metis ar.ardual.fbox_def ar.ardual.fbox_demodalisation3 eq_refl rar_ar)"], ["", "lemma fdia_eq: \"ar.bdia x (r p) = Inf{r q |q. (r p) \\<cdot> x \\<le> x \\<cdot> r q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. antirange_semiring.bdia (\\<cdot>) ar x (r p) =\n    Inf {r q |q. r p \\<cdot> x \\<le> x \\<cdot> r q}", "apply (rule Inf_eqI[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<in> {r q |q. r p \\<cdot> x \\<le> x \\<cdot> r q} \\<Longrightarrow>\n       antirange_semiring.bdia (\\<cdot>) ar x (r p) \\<le> i\n 2. \\<And>y.\n       (\\<And>i.\n           i \\<in> {r q |q.\n                    r p \\<cdot> x \\<le> x \\<cdot> r q} \\<Longrightarrow>\n           y \\<le> i) \\<Longrightarrow>\n       y \\<le> antirange_semiring.bdia (\\<cdot>) ar x (r p)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q.\n       r p \\<cdot> x \\<le> x \\<cdot> r q \\<Longrightarrow>\n       antirange_semiring.bdia (\\<cdot>) ar x (r p) \\<le> r q\n 2. \\<And>y.\n       (\\<And>i.\n           i \\<in> {r q |q.\n                    r p \\<cdot> x \\<le> x \\<cdot> r q} \\<Longrightarrow>\n           y \\<le> i) \\<Longrightarrow>\n       y \\<le> antirange_semiring.bdia (\\<cdot>) ar x (r p)", "using ar.ars_r_def ar.ardual.fdemodalisation22 ar.ardual.kat_3_equiv_opp ar.ardual.kat_4_equiv_opp"], ["proof (prove)\nusing this:\n  r ?x = ar (ar ?x)\n  (antirange_semiring.bdia (\\<cdot>) ar ?x ?y \\<le> r ?z) =\n  (r ?y \\<cdot> (?x \\<cdot> ar ?z) = \\<bottom>)\n  (r ?x \\<cdot> (?y \\<cdot> ar ?z) = \\<bottom>) =\n  (r ?x \\<cdot> ?y = r ?x \\<cdot> (?y \\<cdot> r ?z))\n  (r ?x \\<cdot> ?y = r ?x \\<cdot> (?y \\<cdot> r ?z)) =\n  (r ?x \\<cdot> ?y \\<le> ?y \\<cdot> r ?z)\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       r p \\<cdot> x \\<le> x \\<cdot> r q \\<Longrightarrow>\n       antirange_semiring.bdia (\\<cdot>) ar x (r p) \\<le> r q\n 2. \\<And>y.\n       (\\<And>i.\n           i \\<in> {r q |q.\n                    r p \\<cdot> x \\<le> x \\<cdot> r q} \\<Longrightarrow>\n           y \\<le> i) \\<Longrightarrow>\n       y \\<le> antirange_semiring.bdia (\\<cdot>) ar x (r p)", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       (\\<And>i.\n           i \\<in> {r q |q.\n                    r p \\<cdot> x \\<le> x \\<cdot> r q} \\<Longrightarrow>\n           y \\<le> i) \\<Longrightarrow>\n       y \\<le> antirange_semiring.bdia (\\<cdot>) ar x (r p)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       (\\<And>i.\n           \\<exists>q.\n              i = r q \\<and>\n              r p \\<cdot> x \\<le> x \\<cdot> r q \\<Longrightarrow>\n           y \\<le> i) \\<Longrightarrow>\n       y \\<le> antirange_semiring.bdia (\\<cdot>) ar x (r p)", "using ar.bdia_def ar.ardual.ds.fdemodalisation2 r_ar"], ["proof (prove)\nusing this:\n  antirange_semiring.bdia (\\<cdot>) ar ?x ?y = ar (ar (?y \\<cdot> ?x))\n  (antirange_semiring.bdia (\\<cdot>) ar ?x ?y \\<le> ar (ar ?z)) =\n  (ar (ar ?y) \\<cdot> ?x \\<le> ?x \\<cdot> ar (ar ?z))\n  r ?x = ar (ar ?x)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       (\\<And>i.\n           \\<exists>q.\n              i = r q \\<and>\n              r p \\<cdot> x \\<le> x \\<cdot> r q \\<Longrightarrow>\n           y \\<le> i) \\<Longrightarrow>\n       y \\<le> antirange_semiring.bdia (\\<cdot>) ar x (r p)", "by fastforce"], ["", "end"], ["", "class modal_boolean_quantale = domain_boolean_quantale + range_boolean_quantale +\n  assumes domrange' [simp]: \"d (r x) = r x\"\n  and rangedom' [simp]: \"r (d x) = d x\"\n\nbegin"], ["", "sublocale mka: modal_kleene_algebra \"(\\<squnion>)\" \"(\\<cdot>)\" 1 \\<bottom> \"(\\<le>)\" \"(<)\" star a ar"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.modal_kleene_algebra (\\<squnion>) (\\<cdot>) (1::'a) \\<bottom>\n     (\\<le>) (<) quantale_class.star a ar", "by standard (simp_all add: ar_eq ad_eq)"], ["", "end"], ["", "no_notation fbox (\"( |_] _)\" [61,81] 82)\n  and antidomain_semiringl_class.fbox (\"( |_] _)\" [61,81] 82)"], ["", "notation ad.fbox (\"( |_] _)\" [61,81] 82)"], ["", "subsection \\<open>Recursion Rule\\<close>"], ["", "lemma recursion: \"mono (f :: 'a \\<Rightarrow> 'a :: domain_boolean_quantale) \\<Longrightarrow> \n  (\\<And>x. d p \\<le> |x] d q \\<Longrightarrow> d p \\<le> |f x] d q) \\<Longrightarrow>  d p \\<le> |lfp f] d q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f;\n     \\<And>x.\n        d p \\<le>  |x] d q \\<Longrightarrow> d p \\<le>  |f x] d q\\<rbrakk>\n    \\<Longrightarrow> d p \\<le>  |lfp f] d q", "apply (erule lfp_ordinal_induct [where f=f], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<lbrakk>\\<And>x.\n                   d p \\<le>  |x] d q \\<Longrightarrow>\n                   d p \\<le>  |f x] d q;\n        \\<forall>S\\<in>M. d p \\<le>  |S] d q\\<rbrakk>\n       \\<Longrightarrow> d p \\<le>  |Sup M] d q", "by (auto simp: ad.addual.ardual.fbox_demodalisation3 Sup_distr Sup_distl intro: Sup_mono)"], ["", "text \\<open>We have already tested this rule in the context of test quantales~\\cite{ArmstrongGS15}, which is based\non a formalisation of quantales that is currently not in the AFP. The two theories will be merged as\nsoon as the quantale is available in the AFP.\\<close>"], ["", "end"]]}