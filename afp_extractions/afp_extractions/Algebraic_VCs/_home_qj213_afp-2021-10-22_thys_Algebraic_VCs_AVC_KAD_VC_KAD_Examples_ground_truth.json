{"file_name": "/home/qj213/afp-2021-10-22/thys/Algebraic_VCs/AVC_KAD/VC_KAD_Examples.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Algebraic_VCs", "problem_names": ["lemma euclid:\n  \"PRE (\\<lambda>s::nat store. s ''x'' = x \\<and> s ''y'' = y)\n   (WHILE (\\<lambda>s. s ''y'' \\<noteq> 0) INV (\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y) \n    DO\n     (''z'' ::= (\\<lambda>s. s ''y''));\n     (''y'' ::= (\\<lambda>s. s ''x'' mod s ''y''));\n     (''x'' ::= (\\<lambda>s. s ''z''))\n    OD)\n   POST (\\<lambda>s. s ''x'' = gcd x y)\"", "lemma euclid_diff: \n   \"PRE (\\<lambda>s::nat store. s ''x'' = x \\<and> s ''y'' = y \\<and> x > 0 \\<and> y > 0)\n    (WHILE (\\<lambda>s. s ''x''\\<noteq> s ''y'') INV (\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y) \n     DO\n        (IF (\\<lambda>s. s ''x'' >  s ''y'')\n         THEN (''x'' ::= (\\<lambda>s. s ''x'' - s ''y''))\n         ELSE (''y'' ::= (\\<lambda>s. s ''y'' - s ''x''))\n         FI)\n    OD)\n    POST (\\<lambda>s. s ''x'' = gcd x y)\"", "lemma varible_swap:\n  \"PRE (\\<lambda>s. s ''x'' = a \\<and> s ''y'' = b)   \n    (''z'' ::= (\\<lambda>s. s ''x''));\n    (''x'' ::= (\\<lambda>s. s ''y''));\n    (''y'' ::= (\\<lambda>s. s ''z''))\n   POST (\\<lambda>s. s ''x'' = b \\<and> s ''y'' = a)\"", "lemma maximum: \n  \"PRE (\\<lambda>s:: nat store. True) \n   (IF (\\<lambda>s. s ''x'' \\<ge> s ''y'') \n    THEN (''z'' ::= (\\<lambda>s. s ''x''))\n    ELSE (''z'' ::= (\\<lambda>s. s ''y''))\n    FI)\n   POST (\\<lambda>s. s ''z'' = max (s ''x'') (s ''y''))\"", "lemma integer_division: \n  \"PRE (\\<lambda>s::nat store. x \\<ge> 0)\n    (''q'' ::= (\\<lambda>s. 0)); \n    (''r'' ::= (\\<lambda>s. x));\n    (WHILE (\\<lambda>s. y \\<le> s ''r'') INV (\\<lambda>s. x = s ''q'' * y + s ''r'' \\<and> s ''r'' \\<ge> 0)\n     DO\n      (''q'' ::= (\\<lambda>s. s ''q'' + 1));\n      (''r'' ::= (\\<lambda>s. s ''r'' - y))\n      OD)\n   POST (\\<lambda>s. x = s ''q'' * y + s ''r'' \\<and> s ''r'' \\<ge> 0 \\<and> s ''r'' < y)\"", "lemma factorial:\n  \"PRE (\\<lambda>s::nat store. True)\n   (''x'' ::= (\\<lambda>s. 0));\n   (''y'' ::= (\\<lambda>s. 1));\n   (WHILE (\\<lambda>s. s ''x'' \\<noteq> x0) INV (\\<lambda>s. s ''y'' = fact (s ''x''))\n   DO\n     (''x'' ::= (\\<lambda>s. s ''x'' + 1));\n     (''y'' ::= (\\<lambda>s. s ''y'' \\<cdot> s ''x''))\n   OD)\n   POST (\\<lambda>s. s ''y'' = fact x0)\"", "lemma my_power:\n  \"PRE (\\<lambda>s::nat store. True)\n   (''i'' ::= (\\<lambda>s. 0));\n   (''y'' ::= (\\<lambda>s. 1));\n   (WHILE (\\<lambda>s. s ''i'' < n) INV (\\<lambda>s. s ''y'' = x ^ (s ''i'') \\<and> s ''i'' \\<le> n)\n     DO\n       (''y'' ::= (\\<lambda>s. (s ''y'') * x));\n       (''i'' ::= (\\<lambda>s. s ''i'' + 1))\n     OD)\n   POST (\\<lambda>s. s ''y'' = x ^ n)\"", "lemma imp_reverse:\n  \"PRE (\\<lambda>s:: 'a list store. s ''x'' = X)\n   (''y'' ::= (\\<lambda>s. []));\n   (WHILE (\\<lambda>s. s ''x'' \\<noteq> []) INV (\\<lambda>s. rev (s ''x'') @ s ''y'' = rev X)\n    DO \n     (''y'' ::= (\\<lambda>s. hd (s ''x'') # s ''y'')); \n     (''x'' ::= (\\<lambda>s. tl (s ''x'')))\n    OD) \n   POST (\\<lambda>s. s ''y''= rev X )\""], "translations": [["", "lemma euclid:\n  \"PRE (\\<lambda>s::nat store. s ''x'' = x \\<and> s ''y'' = y)\n   (WHILE (\\<lambda>s. s ''y'' \\<noteq> 0) INV (\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y) \n    DO\n     (''z'' ::= (\\<lambda>s. s ''y''));\n     (''y'' ::= (\\<lambda>s. s ''x'' mod s ''y''));\n     (''x'' ::= (\\<lambda>s. s ''z''))\n    OD)\n   POST (\\<lambda>s. s ''x'' = gcd x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rdom \\<lceil>\\<lambda>s. s ''x'' = x \\<and> s ''y'' = y\\<rceil>\n    \\<subseteq> wp (WHILE (\\<lambda>s.\n                              s ''y'' \\<noteq>\n                              0) INV (\\<lambda>s.\n   gcd (s ''x'') (s ''y'') =\n   gcd x\n    y) DO (''z'' ::= (\\<lambda>s. s ''y'')) ;\n          (''y'' ::= (\\<lambda>s. s ''x'' mod s ''y'')) ;\n          (''x'' ::= (\\<lambda>s. s ''z'')) OD)\n                 \\<lceil>\\<lambda>s. s ''x'' = gcd x y\\<rceil>", "by (rule rel_antidomain_kleene_algebra.fbox_whilei, auto simp: gcd_non_0_nat)"], ["", "lemma euclid_diff: \n   \"PRE (\\<lambda>s::nat store. s ''x'' = x \\<and> s ''y'' = y \\<and> x > 0 \\<and> y > 0)\n    (WHILE (\\<lambda>s. s ''x''\\<noteq> s ''y'') INV (\\<lambda>s. gcd (s ''x'') (s ''y'') = gcd x y) \n     DO\n        (IF (\\<lambda>s. s ''x'' >  s ''y'')\n         THEN (''x'' ::= (\\<lambda>s. s ''x'' - s ''y''))\n         ELSE (''y'' ::= (\\<lambda>s. s ''y'' - s ''x''))\n         FI)\n    OD)\n    POST (\\<lambda>s. s ''x'' = gcd x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rdom\n     \\<lceil>\\<lambda>s.\n                s ''x'' = x \\<and>\n                s ''y'' = y \\<and> 0 < x \\<and> 0 < y\\<rceil>\n    \\<subseteq> wp (WHILE (\\<lambda>s.\n                              s ''x'' \\<noteq>\n                              s ''y'') INV (\\<lambda>s.\n         gcd (s ''x'') (s ''y'') =\n         gcd x\n          y) DO (IF (\\<lambda>s.\n                        s ''y''\n                        < s ''x'') THEN (''x'' ::= (\\<lambda>s.\n                 s ''x'' -\n                 s ''y'')) ELSE (''y'' ::= (\\<lambda>s.\n         s ''y'' - s ''x'')) FI) OD)\n                 \\<lceil>\\<lambda>s. s ''x'' = gcd x y\\<rceil>", "apply (rule rel_antidomain_kleene_algebra.fbox_whilei, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>s.\n       gcd (s ''x'') (s ''y'') = gcd x y \\<and>\n       s ''x'' = s ''y'' \\<longrightarrow>\n       s ''y'' = gcd x y\n 2. \\<forall>s.\n       gcd (s ''x'') (s ''y'') = gcd x y \\<and>\n       s ''x'' \\<noteq> s ''y'' \\<longrightarrow>\n       (s ''y'' < s ''x'' \\<longrightarrow>\n        gcd (s ''x'' - s ''y'') (s ''y'') = gcd x y) \\<and>\n       (s ''y'' < s ''x'' \\<or> gcd (s ''x'') (s ''y'' - s ''x'') = gcd x y)", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s.\n       gcd (s ''x'') (s ''y'') = gcd x y \\<and>\n       s ''x'' \\<noteq> s ''y'' \\<longrightarrow>\n       (s ''y'' < s ''x'' \\<longrightarrow>\n        gcd (s ''x'' - s ''y'') (s ''y'') = gcd x y) \\<and>\n       (s ''y'' < s ''x'' \\<or> gcd (s ''x'') (s ''y'' - s ''x'') = gcd x y)", "by (metis gcd.commute gcd_diff1_nat le_cases nat_less_le)"], ["", "lemma varible_swap:\n  \"PRE (\\<lambda>s. s ''x'' = a \\<and> s ''y'' = b)   \n    (''z'' ::= (\\<lambda>s. s ''x''));\n    (''x'' ::= (\\<lambda>s. s ''y''));\n    (''y'' ::= (\\<lambda>s. s ''z''))\n   POST (\\<lambda>s. s ''x'' = b \\<and> s ''y'' = a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rdom \\<lceil>\\<lambda>s. s ''x'' = a \\<and> s ''y'' = b\\<rceil>\n    \\<subseteq> wp ((''z'' ::= (\\<lambda>s. s ''x'')) ;\n                    (''x'' ::= (\\<lambda>s. s ''y'')) ;\n                    (''y'' ::= (\\<lambda>s. s ''z'')))\n                 \\<lceil>\\<lambda>s. s ''x'' = b \\<and> s ''y'' = a\\<rceil>", "by simp"], ["", "lemma maximum: \n  \"PRE (\\<lambda>s:: nat store. True) \n   (IF (\\<lambda>s. s ''x'' \\<ge> s ''y'') \n    THEN (''z'' ::= (\\<lambda>s. s ''x''))\n    ELSE (''z'' ::= (\\<lambda>s. s ''y''))\n    FI)\n   POST (\\<lambda>s. s ''z'' = max (s ''x'') (s ''y''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rdom \\<lceil>\\<lambda>s. True\\<rceil>\n    \\<subseteq> wp (IF (\\<lambda>s.\n                           s ''y''\n                           \\<le> s ''x'') THEN (''z'' ::= (\\<lambda>s.\n                        s ''x'')) ELSE (''z'' ::= (\\<lambda>s. s ''y'')) FI)\n                 \\<lceil>\\<lambda>s.\n                            s ''z'' = max (s ''x'') (s ''y'')\\<rceil>", "by auto"], ["", "lemma integer_division: \n  \"PRE (\\<lambda>s::nat store. x \\<ge> 0)\n    (''q'' ::= (\\<lambda>s. 0)); \n    (''r'' ::= (\\<lambda>s. x));\n    (WHILE (\\<lambda>s. y \\<le> s ''r'') INV (\\<lambda>s. x = s ''q'' * y + s ''r'' \\<and> s ''r'' \\<ge> 0)\n     DO\n      (''q'' ::= (\\<lambda>s. s ''q'' + 1));\n      (''r'' ::= (\\<lambda>s. s ''r'' - y))\n      OD)\n   POST (\\<lambda>s. x = s ''q'' * y + s ''r'' \\<and> s ''r'' \\<ge> 0 \\<and> s ''r'' < y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rdom \\<lceil>\\<lambda>s. 0 \\<le> x\\<rceil>\n    \\<subseteq> wp ((''q'' ::= (\\<lambda>s. 0)) ;\n                    (''r'' ::= (\\<lambda>s. x)) ;\n                    (WHILE (\\<lambda>s.\n                               y \\<le> s\n  ''r'') INV (\\<lambda>s.\n                 x = s ''q'' \\<cdot> y + s ''r'' \\<and>\n                 0 \\<le> s ''r'') DO (''q'' ::= (\\<lambda>s. s ''q'' + 1)) ;\n                                     (''r'' ::= (\\<lambda>s.\n              s ''r'' - y)) OD))\n                 \\<lceil>\\<lambda>s.\n                            x = s ''q'' \\<cdot> y + s ''r'' \\<and>\n                            0 \\<le> s ''r'' \\<and> s ''r'' < y\\<rceil>", "by (rule rel_antidomain_kleene_algebra.fbox_whilei_break, simp_all)"], ["", "lemma factorial:\n  \"PRE (\\<lambda>s::nat store. True)\n   (''x'' ::= (\\<lambda>s. 0));\n   (''y'' ::= (\\<lambda>s. 1));\n   (WHILE (\\<lambda>s. s ''x'' \\<noteq> x0) INV (\\<lambda>s. s ''y'' = fact (s ''x''))\n   DO\n     (''x'' ::= (\\<lambda>s. s ''x'' + 1));\n     (''y'' ::= (\\<lambda>s. s ''y'' \\<cdot> s ''x''))\n   OD)\n   POST (\\<lambda>s. s ''y'' = fact x0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rdom \\<lceil>\\<lambda>s. True\\<rceil>\n    \\<subseteq> wp ((''x'' ::= (\\<lambda>s. 0)) ;\n                    (''y'' ::= (\\<lambda>s. 1)) ;\n                    (WHILE (\\<lambda>s.\n                               s ''x'' \\<noteq>\n                               x0) INV (\\<lambda>s.\n     s ''y'' =\n     fact\n      (s ''x'')) DO (''x'' ::= (\\<lambda>s. s ''x'' + 1)) ;\n                    (''y'' ::= (\\<lambda>s. s ''y'' \\<cdot> s ''x'')) OD))\n                 \\<lceil>\\<lambda>s. s ''y'' = fact x0\\<rceil>", "by (rule rel_antidomain_kleene_algebra.fbox_whilei_break, simp_all)"], ["", "lemma my_power:\n  \"PRE (\\<lambda>s::nat store. True)\n   (''i'' ::= (\\<lambda>s. 0));\n   (''y'' ::= (\\<lambda>s. 1));\n   (WHILE (\\<lambda>s. s ''i'' < n) INV (\\<lambda>s. s ''y'' = x ^ (s ''i'') \\<and> s ''i'' \\<le> n)\n     DO\n       (''y'' ::= (\\<lambda>s. (s ''y'') * x));\n       (''i'' ::= (\\<lambda>s. s ''i'' + 1))\n     OD)\n   POST (\\<lambda>s. s ''y'' = x ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rdom \\<lceil>\\<lambda>s. True\\<rceil>\n    \\<subseteq> wp ((''i'' ::= (\\<lambda>s. 0)) ;\n                    (''y'' ::= (\\<lambda>s. 1)) ;\n                    (WHILE (\\<lambda>s.\n                               s ''i''\n                               < n) INV (\\<lambda>s.\n      s ''y'' = x ^ s ''i'' \\<and>\n      s ''i''\n      \\<le> n) DO (''y'' ::= (\\<lambda>s. s ''y'' \\<cdot> x)) ;\n                  (''i'' ::= (\\<lambda>s. s ''i'' + 1)) OD))\n                 \\<lceil>\\<lambda>s. s ''y'' = x ^ n\\<rceil>", "by (rule rel_antidomain_kleene_algebra.fbox_whilei_break, auto)"], ["", "lemma imp_reverse:\n  \"PRE (\\<lambda>s:: 'a list store. s ''x'' = X)\n   (''y'' ::= (\\<lambda>s. []));\n   (WHILE (\\<lambda>s. s ''x'' \\<noteq> []) INV (\\<lambda>s. rev (s ''x'') @ s ''y'' = rev X)\n    DO \n     (''y'' ::= (\\<lambda>s. hd (s ''x'') # s ''y'')); \n     (''x'' ::= (\\<lambda>s. tl (s ''x'')))\n    OD) \n   POST (\\<lambda>s. s ''y''= rev X )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rdom \\<lceil>\\<lambda>s. s ''x'' = X\\<rceil>\n    \\<subseteq> wp ((''y'' ::= (\\<lambda>s. [])) ;\n                    (WHILE (\\<lambda>s.\n                               s ''x'' \\<noteq>\n                               []) INV (\\<lambda>s.\n     rev (s ''x'') @ s ''y'' =\n     rev X) DO (''y'' ::= (\\<lambda>s. hd (s ''x'') # s ''y'')) ;\n               (''x'' ::= (\\<lambda>s. tl (s ''x''))) OD))\n                 \\<lceil>\\<lambda>s. s ''y'' = rev X\\<rceil>", "apply (rule rel_antidomain_kleene_algebra.fbox_whilei_break, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>s.\n       rev (s ''x'') @ s ''y'' = rev X \\<and> s ''x'' = [] \\<longrightarrow>\n       s ''y'' = rev X\n 2. \\<forall>s.\n       rev (s ''x'') @ s ''y'' = rev X \\<and>\n       s ''x'' \\<noteq> [] \\<longrightarrow>\n       rev (tl (s ''x'')) @ hd (s ''x'') # s ''y'' = rev X", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s.\n       rev (s ''x'') @ s ''y'' = rev X \\<and>\n       s ''x'' \\<noteq> [] \\<longrightarrow>\n       rev (tl (s ''x'')) @ hd (s ''x'') # s ''y'' = rev X", "by (safe, metis append.simps append_assoc hd_Cons_tl rev.simps(2))"], ["", "end"]]}