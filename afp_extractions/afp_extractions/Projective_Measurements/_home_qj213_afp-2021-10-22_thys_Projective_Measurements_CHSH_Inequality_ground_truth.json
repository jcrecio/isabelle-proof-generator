{"file_name": "/home/qj213/afp-2021-10-22/thys/Projective_Measurements/CHSH_Inequality.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Projective_Measurements", "problem_names": ["lemma chsh_real:\n  fixes A0::real\n  assumes \"\\<bar>A0 * B1\\<bar> \\<le> 1\"\n  and \"\\<bar>A0 * B0\\<bar> \\<le> 1\"\n  and \"\\<bar>A1 * B0\\<bar> \\<le> 1\"\n  and \"\\<bar>A1 * B1\\<bar> \\<le> 1\"\n  shows \"\\<bar>A0 * B1 - A0 * B0 + A1 * B0 + A1*B1\\<bar> \\<le> 2\"", "lemma (in prob_space) chsh_expect:\n  fixes A0::\"'a \\<Rightarrow> real\"\n  assumes \"AE w in M. \\<bar>A0 w\\<bar> \\<le> 1\"\n  and \"AE w in M. \\<bar>A1 w\\<bar> \\<le> 1\"\n  and \"AE w in M. \\<bar>B0 w\\<bar> \\<le> 1\"\n  and \"AE w in M. \\<bar>B1 w\\<bar> \\<le> 1\"\nand \"integrable M (\\<lambda>w. A0 w * B1 w)\"\nand \"integrable M (\\<lambda>w. A1 w * B1 w)\"\nand \"integrable M (\\<lambda>w. A1 w * B0 w)\"\nand \"integrable M (\\<lambda>w. A0 w * B0 w)\"\nshows \"\\<bar>expectation (\\<lambda>w. A1 w * B0 w) + expectation (\\<lambda>w. A0 w *B1 w) + \n  expectation (\\<lambda>w. A1 w * B1 w) - expectation (\\<lambda>w. A0 w * B0 w)\\<bar> \\<le> 2\"", "lemma (in cpx_sq_mat) lhv_posl:\n  assumes \"lhv M A B R XA XB\"\n  shows \"AE w in M. (\\<forall> a \\<in> spectrum A. 0 \\<le> XA a w)\"", "lemma (in cpx_sq_mat) lhv_lt1_l:\n  assumes \"lhv M A B R XA XB\"\n  shows \"AE w in M. (\\<forall> a \\<in> spectrum A. XA a w \\<le> 1)\"", "lemma (in cpx_sq_mat) lhv_posr:\n  assumes \"lhv M A B R XA XB\"\n  shows \"AE w in M. (\\<forall> b \\<in> spectrum B. 0 \\<le> XB b w)\"", "lemma (in cpx_sq_mat) lhv_lt1_r:\n  assumes \"lhv M A B R XA XB\"\n  shows \"AE w in M. (\\<forall> a \\<in> spectrum B. XB a w \\<le> 1)\"", "lemma (in cpx_sq_mat) lhv_AE_propl:\n  assumes \"lhv M A B R XA XB\"\n  shows \"AE w in M. (\\<forall> a \\<in> spectrum A. 0 \\<le> XA a w \\<and> XA a w \\<le> 1) \\<and> (\\<Sum> a\\<in> spectrum A. XA a w) = 1\"", "lemma (in cpx_sq_mat) lhv_AE_propr:\n  assumes \"lhv M A B R XA XB\"\n  shows \"AE w in M. (\\<forall> a \\<in> spectrum B. 0 \\<le> XB a w \\<and> XB a w \\<le> 1) \\<and> (\\<Sum> a\\<in> spectrum B. XB a w) = 1\"", "lemma (in cpx_sq_mat) lhv_integral_eq:\n  fixes c::real\n  assumes \"lhv M A B R XA XB\"\n  and \"a\\<in> spectrum A\"\nand \"b\\<in> spectrum B\"\nshows \"integral\\<^sup>L M (\\<lambda>w. XA a w * XB b w) = \n  Re (Complex_Matrix.trace(eigen_projector A a * (eigen_projector B b) * R))\"", "lemma (in cpx_sq_mat) lhv_integrable:\n  fixes c::real\n  assumes \"lhv M A B R XA XB\"\n  and \"a\\<in> spectrum A\"\nand \"b\\<in> spectrum B\"\nshows \"integrable M (\\<lambda>w. XA a w * XB b w)\"", "lemma (in cpx_sq_mat) lhv_scal_integrable:\n  fixes c::real\n  assumes \"lhv M A B R XA XB\"\n  and \"a\\<in> spectrum A\"\nand \"b\\<in> spectrum B\"\nshows \"integrable M (\\<lambda>w. c *XA a w * d * XB b w)\"", "lemma (in cpx_sq_mat) lhv_lsum_scal_integrable:\n  assumes \"lhv M A B R XA XB\"\n  and  \"a\\<in> spectrum A\"\nshows \"integrable M (\\<lambda>x. \\<Sum>b\\<in>spectrum B. c * XA a x * (f b) * XB b x)\"", "lemma (in cpx_sq_mat) lhv_sum_integrable:\n  assumes \"lhv M A B R XA XB\"\nshows \"integrable M (\\<lambda>w.  (\\<Sum> a \\<in> spectrum A. (\\<Sum> b \\<in> spectrum B. f a * XA a w * g b * XB b w)))\"", "lemma (in cpx_sq_mat) spectrum_abs_1_weighted_suml:\n  assumes \"lhv M A B R Va Vb\"\nand \"{Re x |x. x \\<in> spectrum A} \\<noteq> {}\"\n  and \"{Re x |x. x \\<in> spectrum A} \\<subseteq> {- 1, 1}\"\nand \"hermitian A\"\n  and \"A\\<in> fc_mats\"\nshows \"AE w in M. \\<bar>(\\<Sum>a\\<in>spectrum A. Re a * Va a w)\\<bar> \\<le> 1\"", "lemma (in cpx_sq_mat) spectrum_abs_1_weighted_sumr:\n  assumes \"lhv M B A R Vb Va\"\nand \"{Re x |x. x \\<in> spectrum A} \\<noteq> {}\"\n  and \"{Re x |x. x \\<in> spectrum A} \\<subseteq> {- 1, 1}\"\nand \"hermitian A\"\n  and \"A\\<in> fc_mats\"\nshows \"AE w in M. \\<bar>(\\<Sum>a\\<in>spectrum A. Re a * Va a w)\\<bar> \\<le> 1\"", "lemma (in cpx_sq_mat) spectr_sum_integrable:\nassumes \"lhv M A B R Va Vb\"\nshows \"integrable M (\\<lambda>w. qt_expect A Va w * qt_expect B Vb w)\"", "lemma (in cpx_sq_mat) lhv_sum_integral':\n  assumes \"lhv M A B R XA XB\"\nshows \"integral\\<^sup>L M (\\<lambda>w. (\\<Sum> a \\<in> spectrum A. f a * XA a w) * (\\<Sum> b \\<in> spectrum B. g b * XB b w)) =\n  (\\<Sum> a \\<in> spectrum A. f a * (\\<Sum> b \\<in> spectrum B. g b  * integral\\<^sup>L M (\\<lambda>w. XA a w * XB b w)))\"", "lemma (in cpx_sq_mat) sum_qt_expect_trace:\n  assumes \"lhv M A B R XA XB\"\n  shows \"(\\<Sum> a \\<in> spectrum A. f a * (\\<Sum> b \\<in> spectrum B. g b * integral\\<^sup>L M (\\<lambda>w. XA a w * XB b w))) =\n    (\\<Sum> a \\<in> spectrum A. f a * (\\<Sum> b \\<in> spectrum B. g b * \n    Re (Complex_Matrix.trace(eigen_projector A a * (eigen_projector B b) * R))))\"", "lemma (in cpx_sq_mat) sum_eigen_projector_trace_dist:\n  assumes \"hermitian B\"\nand \"A\\<in> fc_mats\"\nand \"B\\<in> fc_mats\"\nand \"R\\<in> fc_mats\"\n  shows \"(\\<Sum> b \\<in> spectrum B. (b * \n    Complex_Matrix.trace(A * (eigen_projector B b) * R))) = Complex_Matrix.trace(A * B * R)\"", "lemma (in cpx_sq_mat) sum_eigen_projector_trace_right:\n  assumes \"hermitian A\"\nand \"A\\<in> fc_mats\"\nand \"B\\<in> fc_mats\"\nshows \"(\\<Sum> a \\<in> spectrum A. Complex_Matrix.trace (a \\<cdot>\\<^sub>m eigen_projector A a * B)) = \n  Complex_Matrix.trace (A * B)\"", "lemma (in cpx_sq_mat) sum_eigen_projector_trace:\n  assumes \"hermitian A\"\n  and \"hermitian B\"\n  and \"A\\<in> fc_mats\"\n  and \"B\\<in> fc_mats\"\nand \"R\\<in> fc_mats\"\n  shows \"(\\<Sum> a \\<in> spectrum A.  a *  (\\<Sum> b \\<in> spectrum B. (b * \n    Complex_Matrix.trace(eigen_projector A a * (eigen_projector B b) * R)))) = \n    Complex_Matrix.trace(A * B * R)\"", "lemma (in cpx_sq_mat) sum_qt_expect:\n  assumes \"lhv M A B R XA XB\"\n  and \"A\\<in> fc_mats\"\n  and \"B\\<in> fc_mats\"\n  and \"R\\<in> fc_mats\"\n  and \"hermitian A\"\n  and \"hermitian B\"\n  shows \"integral\\<^sup>L M (\\<lambda>w. (qt_expect A XA w) * (qt_expect B XB w)) = \n    Re (Complex_Matrix.trace(A * B * R))\"", "lemma ket_0_dim:\n  shows \"dim_vec ket_0 = 2\"", "lemma ket_0_norm:\n  shows \"\\<parallel>ket_0\\<parallel> = 1\"", "lemma ket_0_mat:\n  shows \"ket_vec ket_0 =  Matrix.mat_of_cols_list 2 [[1, 0]]\"", "lemma ket_1_dim:\n  shows \"dim_vec ket_1 = 2\"", "lemma ket_1_norm:\n  shows \"\\<parallel>ket_1\\<parallel> = 1\"", "lemma ket_01_dim:\n  shows \"dim_vec ket_01 = 4\"", "lemma ket_10_dim:\n  shows \"dim_vec ket_10 = 4\"", "lemma  ket_psim_dim:\n  shows \"dim_vec ket_psim = 4\"", "lemma ket_psim_norm:\n  shows \"\\<parallel>ket_psim\\<parallel> = 1\"", "lemma rho_psim_carrier:\n  shows \"rho_psim \\<in> carrier_mat 4 4\"", "lemma  rho_psim_dim_row:\n  shows \"dim_row rho_psim = 4\"", "lemma rho_psim_density:\n  shows \"density_operator rho_psim\"", "lemma Z_carrier: shows \"Z \\<in> carrier_mat 2 2\"", "lemma Z_hermitian:\n  shows \"hermitian Z\"", "lemma unitary_Z:\n  shows \"Complex_Matrix.unitary Z\"", "lemma X_carrier: shows \"X \\<in> carrier_mat 2 2\"", "lemma X_hermitian:\n  shows \"hermitian X\"", "lemma unitary_X:\n  shows \"Complex_Matrix.unitary X\"", "lemma XpZ_carrier:\n  shows \"XpZ \\<in> carrier_mat 2 2\"", "lemma XpZ_hermitian:\n  shows \"hermitian XpZ\"", "lemma XpZ_inv:\n  \"XpZ * XpZ = 1\\<^sub>m 2\"", "lemma unitary_XpZ:\n  shows \"Complex_Matrix.unitary XpZ\"", "lemma ZmX_carrier:\n  shows \"ZmX \\<in> carrier_mat 2 2\"", "lemma ZmX_hermitian:\n  shows \"hermitian ZmX\"", "lemma ZmX_inv:\n  \"ZmX * ZmX = 1\\<^sub>m 2\"", "lemma unitary_ZmX:\n  shows \"Complex_Matrix.unitary ZmX\"", "lemma Z_XpZ_carrier:\n  shows \"Z_XpZ \\<in> carrier_mat 4 4\"", "lemma X_XpZ_carrier:\n  shows \"X_XpZ \\<in> carrier_mat 4 4\"", "lemma Z_ZmX_carrier:\n  shows \"Z_ZmX \\<in> carrier_mat 4 4\"", "lemma X_ZmX_carrier:\n  shows \"X_ZmX \\<in> carrier_mat 4 4\"", "lemma  X_ZmX_rho_psim[simp]:\n  shows \"Complex_Matrix.trace (rho_psim * X_ZmX) = 1/ (sqrt 2)\"", "lemma  Z_ZmX_rho_psim[simp]:\n  shows \"Complex_Matrix.trace (rho_psim * Z_ZmX) = -1/ (sqrt 2)\"", "lemma X_XpZ_rho_psim[simp]:\n  shows \"Complex_Matrix.trace (rho_psim * X_XpZ) =1/ (sqrt 2)\"", "lemma Z_XpZ_rho_psim[simp]:\n  shows \"Complex_Matrix.trace (rho_psim * Z_XpZ) =1/ (sqrt 2)\"", "lemma Z_I_carrier:\n  shows \"Z_I \\<in> carrier_mat 4 4\"", "lemma Z_I_hermitian:\n  shows \"hermitian Z_I\"", "lemma  Z_I_unitary:\n  shows \"unitary Z_I\"", "lemma Z_I_spectrum:\n  shows \"{Re x |x. x \\<in> spectrum Z_I} \\<subseteq> {- 1, 1}\"", "lemma  X_I_carrier:\n  shows \"X_I \\<in> carrier_mat 4 4\"", "lemma X_I_hermitian:\n  shows \"hermitian X_I\"", "lemma X_I_unitary:\n  shows \"unitary X_I\"", "lemma  X_I_spectrum:\n  shows \"{Re x |x. x \\<in> spectrum X_I} \\<subseteq> {- 1, 1}\"", "lemma  I_XpZ_carrier:\n  shows \"I_XpZ \\<in> carrier_mat 4 4\"", "lemma  I_XpZ_hermitian:\n  shows \"hermitian I_XpZ\"", "lemma I_XpZ_unitary:\n  shows \"unitary I_XpZ\"", "lemma I_XpZ_spectrum:\n  shows \"{Re x |x. x \\<in> spectrum I_XpZ} \\<subseteq> {- 1, 1}\"", "lemma  I_ZmX_carrier:\n  shows \"I_ZmX \\<in> carrier_mat 4 4\"", "lemma I_ZmX_hermitian:\n  shows \"hermitian I_ZmX\"", "lemma I_ZmX_unitary:\n  shows \"unitary I_ZmX\"", "lemma I_ZmX_spectrum:\n  shows \"{Re x |x. x \\<in> spectrum I_ZmX} \\<subseteq> {- 1, 1}\"", "lemma X_I_ZmX_eq:\n  shows \"X_I * I_ZmX = X_ZmX\"", "lemma X_I_XpZ_eq:\n  shows \"X_I * I_XpZ = X_XpZ\"", "lemma Z_I_XpZ_eq:\n  shows \"Z_I * I_XpZ = Z_XpZ\"", "lemma Z_I_ZmX_eq:\n  shows \"Z_I * I_ZmX = Z_ZmX\"", "lemma (in bin_cpx) X_I_XpZ_trace:\n  assumes \"lhv M X_I I_XpZ R Vx Vp\"\n  and \"R\\<in> fc_mats\"\n  shows \"LINT w|M. (qt_expect X_I Vx w) * (qt_expect I_XpZ  Vp w) =\n  Re (Complex_Matrix.trace (R * X_XpZ))\"", "lemma (in bin_cpx) X_I_XpZ_chsh:\n  assumes \"lhv M X_I I_XpZ rho_psim Vx Vp\"\n  shows \"LINT w|M. (qt_expect X_I Vx w) * (qt_expect I_XpZ Vp w) =\n  1/sqrt 2\"", "lemma (in bin_cpx) Z_I_XpZ_trace:\n  assumes \"lhv M Z_I I_XpZ R Vz Vp\"\n  and \"R\\<in> fc_mats\"\n  shows \"LINT w|M. (qt_expect Z_I Vz w) * (qt_expect I_XpZ Vp w) =\n  Re (Complex_Matrix.trace (R * Z_XpZ))\"", "lemma (in bin_cpx) Z_I_XpZ_chsh:\n  assumes \"lhv M Z_I I_XpZ rho_psim Vz Vp\"\n  shows \"LINT w|M. (qt_expect Z_I Vz w) * (qt_expect I_XpZ Vp w) =\n  1/sqrt 2\"", "lemma (in bin_cpx) X_I_ZmX_trace:\n  assumes \"lhv M X_I I_ZmX R Vx Vp\"\n  and \"R\\<in> fc_mats\"\n  shows \"LINT w|M. (qt_expect X_I Vx w) * (qt_expect I_ZmX Vp w) =\n  Re (Complex_Matrix.trace (R * X_ZmX))\"", "lemma (in bin_cpx) X_I_ZmX_chsh:\n  assumes \"lhv M X_I I_ZmX rho_psim Vx Vp\"\n  shows \"LINT w|M. (qt_expect X_I Vx w) * (qt_expect I_ZmX Vp w) =\n  1/sqrt 2\"", "lemma (in bin_cpx) Z_I_ZmX_trace:\n  assumes \"lhv M Z_I I_ZmX R Vz Vp\"\n  and \"R\\<in> fc_mats\"\n  shows \"LINT w|M. (qt_expect Z_I Vz w) * (qt_expect I_ZmX Vp w) =\n  Re (Complex_Matrix.trace (R * Z_ZmX))\"", "lemma (in bin_cpx) Z_I_ZmX_chsh:\n  assumes \"lhv M Z_I I_ZmX rho_psim Vz Vp\"\nshows \"LINT w|M. (qt_expect Z_I Vz w) * (qt_expect I_ZmX Vp w) =\n  -1/sqrt 2\"", "lemma (in bin_cpx) chsh_upper_bound:\n  assumes \"prob_space M\"\n  and \"lhv M X_I I_XpZ rho_psim Vx Vp\"\n  and \"lhv M Z_I I_XpZ rho_psim Vz Vp\"\n  and \"lhv M X_I I_ZmX rho_psim Vx Vm\"\n  and \"lhv M Z_I I_ZmX rho_psim Vz Vm\"\nshows \"\\<bar>(LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w) + \n        (LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w) + \n        (LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w) -\n        (LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w)\\<bar>\n  \\<le> 2\"", "lemma (in bin_cpx) quantum_value:\n  assumes \"lhv M X_I I_XpZ rho_psim Vx Vp\"\n  and \"lhv M Z_I I_XpZ rho_psim Vz Vp\"\n  and \"lhv M X_I I_ZmX rho_psim Vx Vm\"\n  and \"lhv M Z_I I_ZmX rho_psim Vz Vm\"\nshows \"\\<bar>(LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w) + \n        (LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w) + \n        (LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w) -\n        (LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w)\\<bar>\n  = 2* sqrt 2\"", "lemma (in bin_cpx) no_lhv:\n  assumes \"lhv M X_I I_XpZ rho_psim Vx Vp\"\n  and \"lhv M Z_I I_XpZ rho_psim Vz Vp\"\n  and \"lhv M X_I I_ZmX rho_psim Vx Vm\"\n  and \"lhv M Z_I I_ZmX rho_psim Vz Vm\"\nshows False"], "translations": [["", "lemma chsh_real:\n  fixes A0::real\n  assumes \"\\<bar>A0 * B1\\<bar> \\<le> 1\"\n  and \"\\<bar>A0 * B0\\<bar> \\<le> 1\"\n  and \"\\<bar>A1 * B0\\<bar> \\<le> 1\"\n  and \"\\<bar>A1 * B1\\<bar> \\<le> 1\"\n  shows \"\\<bar>A0 * B1 - A0 * B0 + A1 * B0 + A1*B1\\<bar> \\<le> 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0 + A1 * B0 + A1 * B1\\<bar> \\<le> 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0 + A1 * B0 + A1 * B1\\<bar> \\<le> 2", "have \"A0 * B1 - A0 * B0 = A0 * B1 - A0 * B0 + A0 * B1 * A1 * B0 - A0 * B1 * A1 * B0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A0 * B1 - A0 * B0 =\n    A0 * B1 - A0 * B0 + A0 * B1 * A1 * B0 - A0 * B1 * A1 * B0", "by simp"], ["proof (state)\nthis:\n  A0 * B1 - A0 * B0 =\n  A0 * B1 - A0 * B0 + A0 * B1 * A1 * B0 - A0 * B1 * A1 * B0\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0 + A1 * B0 + A1 * B1\\<bar> \\<le> 2", "also"], ["proof (state)\nthis:\n  A0 * B1 - A0 * B0 =\n  A0 * B1 - A0 * B0 + A0 * B1 * A1 * B0 - A0 * B1 * A1 * B0\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0 + A1 * B0 + A1 * B1\\<bar> \\<le> 2", "have \"... = A0 * B1 * (1 + A1*B0) - A0 * B0 * (1 + A1* B1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A0 * B1 - A0 * B0 + A0 * B1 * A1 * B0 - A0 * B1 * A1 * B0 =\n    A0 * B1 * (1 + A1 * B0) - A0 * B0 * (1 + A1 * B1)", "by (metis (no_types, hide_lams) add_diff_cancel_right calculation diff_add_eq \n        group_cancel.sub1 mult.commute mult.right_neutral \n        vector_space_over_itself.scale_left_commute \n        vector_space_over_itself.scale_right_diff_distrib \n        vector_space_over_itself.scale_right_distrib \n        vector_space_over_itself.scale_scale)"], ["proof (state)\nthis:\n  A0 * B1 - A0 * B0 + A0 * B1 * A1 * B0 - A0 * B1 * A1 * B0 =\n  A0 * B1 * (1 + A1 * B0) - A0 * B0 * (1 + A1 * B1)\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0 + A1 * B0 + A1 * B1\\<bar> \\<le> 2", "finally"], ["proof (chain)\npicking this:\n  A0 * B1 - A0 * B0 = A0 * B1 * (1 + A1 * B0) - A0 * B0 * (1 + A1 * B1)", "have \"A0 * B1 - A0 * B0 = A0 * B1 * (1 + A1*B0) - A0 * B0 * (1 + A1* B1)\""], ["proof (prove)\nusing this:\n  A0 * B1 - A0 * B0 = A0 * B1 * (1 + A1 * B0) - A0 * B0 * (1 + A1 * B1)\n\ngoal (1 subgoal):\n 1. A0 * B1 - A0 * B0 = A0 * B1 * (1 + A1 * B0) - A0 * B0 * (1 + A1 * B1)", "."], ["proof (state)\nthis:\n  A0 * B1 - A0 * B0 = A0 * B1 * (1 + A1 * B0) - A0 * B0 * (1 + A1 * B1)\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0 + A1 * B0 + A1 * B1\\<bar> \\<le> 2", "hence \"\\<bar>A0 * B1 - A0 * B0\\<bar> \\<le> \\<bar>A0 * B1 * (1 + A1*B0)\\<bar> + \\<bar>A0 * B0 * (1 + A1* B1)\\<bar>\""], ["proof (prove)\nusing this:\n  A0 * B1 - A0 * B0 = A0 * B1 * (1 + A1 * B0) - A0 * B0 * (1 + A1 * B1)\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0\\<bar>\n    \\<le> \\<bar>A0 * B1 * (1 + A1 * B0)\\<bar> +\n          \\<bar>A0 * B0 * (1 + A1 * B1)\\<bar>", "by simp"], ["proof (state)\nthis:\n  \\<bar>A0 * B1 - A0 * B0\\<bar>\n  \\<le> \\<bar>A0 * B1 * (1 + A1 * B0)\\<bar> +\n        \\<bar>A0 * B0 * (1 + A1 * B1)\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0 + A1 * B0 + A1 * B1\\<bar> \\<le> 2", "also"], ["proof (state)\nthis:\n  \\<bar>A0 * B1 - A0 * B0\\<bar>\n  \\<le> \\<bar>A0 * B1 * (1 + A1 * B0)\\<bar> +\n        \\<bar>A0 * B0 * (1 + A1 * B1)\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0 + A1 * B0 + A1 * B1\\<bar> \\<le> 2", "have \"... = \\<bar>A0 * B1\\<bar> * \\<bar>(1 + A1*B0)\\<bar> + \\<bar>A0 * B0\\<bar> * \\<bar>(1 + A1* B1)\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 * (1 + A1 * B0)\\<bar> +\n    \\<bar>A0 * B0 * (1 + A1 * B1)\\<bar> =\n    \\<bar>A0 * B1\\<bar> * \\<bar>1 + A1 * B0\\<bar> +\n    \\<bar>A0 * B0\\<bar> * \\<bar>1 + A1 * B1\\<bar>", "by (simp add: abs_mult)"], ["proof (state)\nthis:\n  \\<bar>A0 * B1 * (1 + A1 * B0)\\<bar> +\n  \\<bar>A0 * B0 * (1 + A1 * B1)\\<bar> =\n  \\<bar>A0 * B1\\<bar> * \\<bar>1 + A1 * B0\\<bar> +\n  \\<bar>A0 * B0\\<bar> * \\<bar>1 + A1 * B1\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0 + A1 * B0 + A1 * B1\\<bar> \\<le> 2", "also"], ["proof (state)\nthis:\n  \\<bar>A0 * B1 * (1 + A1 * B0)\\<bar> +\n  \\<bar>A0 * B0 * (1 + A1 * B1)\\<bar> =\n  \\<bar>A0 * B1\\<bar> * \\<bar>1 + A1 * B0\\<bar> +\n  \\<bar>A0 * B0\\<bar> * \\<bar>1 + A1 * B1\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0 + A1 * B0 + A1 * B1\\<bar> \\<le> 2", "have \"... \\<le> \\<bar>(1 + A1*B0)\\<bar> + \\<bar>(1 + A1* B1)\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1\\<bar> * \\<bar>1 + A1 * B0\\<bar> +\n    \\<bar>A0 * B0\\<bar> * \\<bar>1 + A1 * B1\\<bar>\n    \\<le> \\<bar>1 + A1 * B0\\<bar> + \\<bar>1 + A1 * B1\\<bar>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1\\<bar> * \\<bar>1 + A1 * B0\\<bar> +\n    \\<bar>A0 * B0\\<bar> * \\<bar>1 + A1 * B1\\<bar>\n    \\<le> \\<bar>1 + A1 * B0\\<bar> + \\<bar>1 + A1 * B1\\<bar>", "have \"\\<bar>A0 * B1\\<bar> * \\<bar>(1 + A1*B0)\\<bar> \\<le> \\<bar>(1 + A1*B0)\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1\\<bar> * \\<bar>1 + A1 * B0\\<bar>\n    \\<le> \\<bar>1 + A1 * B0\\<bar>", "using assms(1) mult_left_le_one_le[of \"\\<bar>(1 + A1*B0)\\<bar>\"]"], ["proof (prove)\nusing this:\n  \\<bar>A0 * B1\\<bar> \\<le> 1\n  \\<lbrakk>0 \\<le> \\<bar>1 + A1 * B0\\<bar>; 0 \\<le> ?y; ?y \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> ?y * \\<bar>1 + A1 * B0\\<bar>\n                    \\<le> \\<bar>1 + A1 * B0\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1\\<bar> * \\<bar>1 + A1 * B0\\<bar>\n    \\<le> \\<bar>1 + A1 * B0\\<bar>", "by simp"], ["proof (state)\nthis:\n  \\<bar>A0 * B1\\<bar> * \\<bar>1 + A1 * B0\\<bar>\n  \\<le> \\<bar>1 + A1 * B0\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1\\<bar> * \\<bar>1 + A1 * B0\\<bar> +\n    \\<bar>A0 * B0\\<bar> * \\<bar>1 + A1 * B1\\<bar>\n    \\<le> \\<bar>1 + A1 * B0\\<bar> + \\<bar>1 + A1 * B1\\<bar>", "moreover"], ["proof (state)\nthis:\n  \\<bar>A0 * B1\\<bar> * \\<bar>1 + A1 * B0\\<bar>\n  \\<le> \\<bar>1 + A1 * B0\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1\\<bar> * \\<bar>1 + A1 * B0\\<bar> +\n    \\<bar>A0 * B0\\<bar> * \\<bar>1 + A1 * B1\\<bar>\n    \\<le> \\<bar>1 + A1 * B0\\<bar> + \\<bar>1 + A1 * B1\\<bar>", "have \"\\<bar>A0 * B0\\<bar> *\\<bar>(1 + A1* B1)\\<bar> \\<le> \\<bar>(1 + A1* B1)\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>A0 * B0\\<bar> * \\<bar>1 + A1 * B1\\<bar>\n    \\<le> \\<bar>1 + A1 * B1\\<bar>", "using assms mult_left_le_one_le[of \"\\<bar>(1 + A1*B1)\\<bar>\"]"], ["proof (prove)\nusing this:\n  \\<bar>A0 * B1\\<bar> \\<le> 1\n  \\<bar>A0 * B0\\<bar> \\<le> 1\n  \\<bar>A1 * B0\\<bar> \\<le> 1\n  \\<bar>A1 * B1\\<bar> \\<le> 1\n  \\<lbrakk>0 \\<le> \\<bar>1 + A1 * B1\\<bar>; 0 \\<le> ?y; ?y \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> ?y * \\<bar>1 + A1 * B1\\<bar>\n                    \\<le> \\<bar>1 + A1 * B1\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B0\\<bar> * \\<bar>1 + A1 * B1\\<bar>\n    \\<le> \\<bar>1 + A1 * B1\\<bar>", "by simp"], ["proof (state)\nthis:\n  \\<bar>A0 * B0\\<bar> * \\<bar>1 + A1 * B1\\<bar>\n  \\<le> \\<bar>1 + A1 * B1\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1\\<bar> * \\<bar>1 + A1 * B0\\<bar> +\n    \\<bar>A0 * B0\\<bar> * \\<bar>1 + A1 * B1\\<bar>\n    \\<le> \\<bar>1 + A1 * B0\\<bar> + \\<bar>1 + A1 * B1\\<bar>", "ultimately"], ["proof (chain)\npicking this:\n  \\<bar>A0 * B1\\<bar> * \\<bar>1 + A1 * B0\\<bar>\n  \\<le> \\<bar>1 + A1 * B0\\<bar>\n  \\<bar>A0 * B0\\<bar> * \\<bar>1 + A1 * B1\\<bar>\n  \\<le> \\<bar>1 + A1 * B1\\<bar>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>A0 * B1\\<bar> * \\<bar>1 + A1 * B0\\<bar>\n  \\<le> \\<bar>1 + A1 * B0\\<bar>\n  \\<bar>A0 * B0\\<bar> * \\<bar>1 + A1 * B1\\<bar>\n  \\<le> \\<bar>1 + A1 * B1\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1\\<bar> * \\<bar>1 + A1 * B0\\<bar> +\n    \\<bar>A0 * B0\\<bar> * \\<bar>1 + A1 * B1\\<bar>\n    \\<le> \\<bar>1 + A1 * B0\\<bar> + \\<bar>1 + A1 * B1\\<bar>", "by simp"], ["proof (state)\nthis:\n  \\<bar>A0 * B1\\<bar> * \\<bar>1 + A1 * B0\\<bar> +\n  \\<bar>A0 * B0\\<bar> * \\<bar>1 + A1 * B1\\<bar>\n  \\<le> \\<bar>1 + A1 * B0\\<bar> + \\<bar>1 + A1 * B1\\<bar>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<bar>A0 * B1\\<bar> * \\<bar>1 + A1 * B0\\<bar> +\n  \\<bar>A0 * B0\\<bar> * \\<bar>1 + A1 * B1\\<bar>\n  \\<le> \\<bar>1 + A1 * B0\\<bar> + \\<bar>1 + A1 * B1\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0 + A1 * B0 + A1 * B1\\<bar> \\<le> 2", "also"], ["proof (state)\nthis:\n  \\<bar>A0 * B1\\<bar> * \\<bar>1 + A1 * B0\\<bar> +\n  \\<bar>A0 * B0\\<bar> * \\<bar>1 + A1 * B1\\<bar>\n  \\<le> \\<bar>1 + A1 * B0\\<bar> + \\<bar>1 + A1 * B1\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0 + A1 * B0 + A1 * B1\\<bar> \\<le> 2", "have \"... = 1 + A1*B0 + 1 + A1* B1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>1 + A1 * B0\\<bar> + \\<bar>1 + A1 * B1\\<bar> =\n    1 + A1 * B0 + 1 + A1 * B1", "using assms"], ["proof (prove)\nusing this:\n  \\<bar>A0 * B1\\<bar> \\<le> 1\n  \\<bar>A0 * B0\\<bar> \\<le> 1\n  \\<bar>A1 * B0\\<bar> \\<le> 1\n  \\<bar>A1 * B1\\<bar> \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<bar>1 + A1 * B0\\<bar> + \\<bar>1 + A1 * B1\\<bar> =\n    1 + A1 * B0 + 1 + A1 * B1", "by (simp add: abs_le_iff)"], ["proof (state)\nthis:\n  \\<bar>1 + A1 * B0\\<bar> + \\<bar>1 + A1 * B1\\<bar> =\n  1 + A1 * B0 + 1 + A1 * B1\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0 + A1 * B0 + A1 * B1\\<bar> \\<le> 2", "also"], ["proof (state)\nthis:\n  \\<bar>1 + A1 * B0\\<bar> + \\<bar>1 + A1 * B1\\<bar> =\n  1 + A1 * B0 + 1 + A1 * B1\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0 + A1 * B0 + A1 * B1\\<bar> \\<le> 2", "have \"... = 2 + A1 * B0 + A1 * B1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + A1 * B0 + 1 + A1 * B1 = 2 + A1 * B0 + A1 * B1", "by simp"], ["proof (state)\nthis:\n  1 + A1 * B0 + 1 + A1 * B1 = 2 + A1 * B0 + A1 * B1\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0 + A1 * B0 + A1 * B1\\<bar> \\<le> 2", "finally"], ["proof (chain)\npicking this:\n  \\<bar>A0 * B1 - A0 * B0\\<bar> \\<le> 2 + A1 * B0 + A1 * B1", "have pls: \"\\<bar>A0 * B1 - A0 * B0\\<bar> \\<le> 2 + A1 * B0 + A1 * B1\""], ["proof (prove)\nusing this:\n  \\<bar>A0 * B1 - A0 * B0\\<bar> \\<le> 2 + A1 * B0 + A1 * B1\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0\\<bar> \\<le> 2 + A1 * B0 + A1 * B1", "."], ["proof (state)\nthis:\n  \\<bar>A0 * B1 - A0 * B0\\<bar> \\<le> 2 + A1 * B0 + A1 * B1\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0 + A1 * B0 + A1 * B1\\<bar> \\<le> 2", "have \"A0 * B1 - A0 * B0 = A0 * B1 - A0 * B0 + A0 * B1 * A1 * B0 - A0 * B1 * A1 * B0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A0 * B1 - A0 * B0 =\n    A0 * B1 - A0 * B0 + A0 * B1 * A1 * B0 - A0 * B1 * A1 * B0", "by simp"], ["proof (state)\nthis:\n  A0 * B1 - A0 * B0 =\n  A0 * B1 - A0 * B0 + A0 * B1 * A1 * B0 - A0 * B1 * A1 * B0\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0 + A1 * B0 + A1 * B1\\<bar> \\<le> 2", "also"], ["proof (state)\nthis:\n  A0 * B1 - A0 * B0 =\n  A0 * B1 - A0 * B0 + A0 * B1 * A1 * B0 - A0 * B1 * A1 * B0\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0 + A1 * B0 + A1 * B1\\<bar> \\<le> 2", "have \"... = A0 * B1 * (1 - A1*B0) - A0 * B0 * (1 - A1* B1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A0 * B1 - A0 * B0 + A0 * B1 * A1 * B0 - A0 * B1 * A1 * B0 =\n    A0 * B1 * (1 - A1 * B0) - A0 * B0 * (1 - A1 * B1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A0 * B1 - A0 * B0 + A0 * B1 * A1 * B0 - A0 * B1 * A1 * B0 =\n    A0 * B1 * (1 - A1 * B0) - A0 * B0 * (1 - A1 * B1)", "have \"A0 * (B1 - (B0 - A1 * (B1 * B0)) - A1 * (B1 * B0)) = A0 * (B1 - B0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A0 * (B1 - (B0 - A1 * (B1 * B0)) - A1 * (B1 * B0)) = A0 * (B1 - B0)", "by fastforce"], ["proof (state)\nthis:\n  A0 * (B1 - (B0 - A1 * (B1 * B0)) - A1 * (B1 * B0)) = A0 * (B1 - B0)\n\ngoal (1 subgoal):\n 1. A0 * B1 - A0 * B0 + A0 * B1 * A1 * B0 - A0 * B1 * A1 * B0 =\n    A0 * B1 * (1 - A1 * B0) - A0 * B0 * (1 - A1 * B1)", "then"], ["proof (chain)\npicking this:\n  A0 * (B1 - (B0 - A1 * (B1 * B0)) - A1 * (B1 * B0)) = A0 * (B1 - B0)", "show ?thesis"], ["proof (prove)\nusing this:\n  A0 * (B1 - (B0 - A1 * (B1 * B0)) - A1 * (B1 * B0)) = A0 * (B1 - B0)\n\ngoal (1 subgoal):\n 1. A0 * B1 - A0 * B0 + A0 * B1 * A1 * B0 - A0 * B1 * A1 * B0 =\n    A0 * B1 * (1 - A1 * B0) - A0 * B0 * (1 - A1 * B1)", "by (metis (no_types) add.commute calculation diff_diff_add mult.right_neutral \n          vector_space_over_itself.scale_left_commute \n          vector_space_over_itself.scale_right_diff_distrib vector_space_over_itself.scale_scale)"], ["proof (state)\nthis:\n  A0 * B1 - A0 * B0 + A0 * B1 * A1 * B0 - A0 * B1 * A1 * B0 =\n  A0 * B1 * (1 - A1 * B0) - A0 * B0 * (1 - A1 * B1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A0 * B1 - A0 * B0 + A0 * B1 * A1 * B0 - A0 * B1 * A1 * B0 =\n  A0 * B1 * (1 - A1 * B0) - A0 * B0 * (1 - A1 * B1)\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0 + A1 * B0 + A1 * B1\\<bar> \\<le> 2", "finally"], ["proof (chain)\npicking this:\n  A0 * B1 - A0 * B0 = A0 * B1 * (1 - A1 * B0) - A0 * B0 * (1 - A1 * B1)", "have \"A0 * B1 - A0 * B0 = A0 * B1 * (1 - A1*B0) - A0 * B0 * (1 - A1* B1)\""], ["proof (prove)\nusing this:\n  A0 * B1 - A0 * B0 = A0 * B1 * (1 - A1 * B0) - A0 * B0 * (1 - A1 * B1)\n\ngoal (1 subgoal):\n 1. A0 * B1 - A0 * B0 = A0 * B1 * (1 - A1 * B0) - A0 * B0 * (1 - A1 * B1)", "."], ["proof (state)\nthis:\n  A0 * B1 - A0 * B0 = A0 * B1 * (1 - A1 * B0) - A0 * B0 * (1 - A1 * B1)\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0 + A1 * B0 + A1 * B1\\<bar> \\<le> 2", "hence \"\\<bar>A0 * B1 - A0 * B0\\<bar> \\<le> \\<bar>A0 * B1 * (1 - A1*B0)\\<bar> + \\<bar>A0 * B0 * (1 - A1* B1)\\<bar>\""], ["proof (prove)\nusing this:\n  A0 * B1 - A0 * B0 = A0 * B1 * (1 - A1 * B0) - A0 * B0 * (1 - A1 * B1)\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0\\<bar>\n    \\<le> \\<bar>A0 * B1 * (1 - A1 * B0)\\<bar> +\n          \\<bar>A0 * B0 * (1 - A1 * B1)\\<bar>", "by simp"], ["proof (state)\nthis:\n  \\<bar>A0 * B1 - A0 * B0\\<bar>\n  \\<le> \\<bar>A0 * B1 * (1 - A1 * B0)\\<bar> +\n        \\<bar>A0 * B0 * (1 - A1 * B1)\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0 + A1 * B0 + A1 * B1\\<bar> \\<le> 2", "also"], ["proof (state)\nthis:\n  \\<bar>A0 * B1 - A0 * B0\\<bar>\n  \\<le> \\<bar>A0 * B1 * (1 - A1 * B0)\\<bar> +\n        \\<bar>A0 * B0 * (1 - A1 * B1)\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0 + A1 * B0 + A1 * B1\\<bar> \\<le> 2", "have \"... = \\<bar>A0 * B1\\<bar> * \\<bar>(1 - A1*B0)\\<bar> + \\<bar>A0 * B0\\<bar> * \\<bar>(1 - A1* B1)\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 * (1 - A1 * B0)\\<bar> +\n    \\<bar>A0 * B0 * (1 - A1 * B1)\\<bar> =\n    \\<bar>A0 * B1\\<bar> * \\<bar>1 - A1 * B0\\<bar> +\n    \\<bar>A0 * B0\\<bar> * \\<bar>1 - A1 * B1\\<bar>", "by (simp add: abs_mult)"], ["proof (state)\nthis:\n  \\<bar>A0 * B1 * (1 - A1 * B0)\\<bar> +\n  \\<bar>A0 * B0 * (1 - A1 * B1)\\<bar> =\n  \\<bar>A0 * B1\\<bar> * \\<bar>1 - A1 * B0\\<bar> +\n  \\<bar>A0 * B0\\<bar> * \\<bar>1 - A1 * B1\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0 + A1 * B0 + A1 * B1\\<bar> \\<le> 2", "also"], ["proof (state)\nthis:\n  \\<bar>A0 * B1 * (1 - A1 * B0)\\<bar> +\n  \\<bar>A0 * B0 * (1 - A1 * B1)\\<bar> =\n  \\<bar>A0 * B1\\<bar> * \\<bar>1 - A1 * B0\\<bar> +\n  \\<bar>A0 * B0\\<bar> * \\<bar>1 - A1 * B1\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0 + A1 * B0 + A1 * B1\\<bar> \\<le> 2", "have \"... \\<le> \\<bar>(1 - A1*B0)\\<bar> + \\<bar>(1 - A1* B1)\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1\\<bar> * \\<bar>1 - A1 * B0\\<bar> +\n    \\<bar>A0 * B0\\<bar> * \\<bar>1 - A1 * B1\\<bar>\n    \\<le> \\<bar>1 - A1 * B0\\<bar> + \\<bar>1 - A1 * B1\\<bar>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1\\<bar> * \\<bar>1 - A1 * B0\\<bar> +\n    \\<bar>A0 * B0\\<bar> * \\<bar>1 - A1 * B1\\<bar>\n    \\<le> \\<bar>1 - A1 * B0\\<bar> + \\<bar>1 - A1 * B1\\<bar>", "have \"\\<bar>A0 * B1\\<bar> * \\<bar>(1 - A1*B0)\\<bar> \\<le> \\<bar>(1 - A1*B0)\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1\\<bar> * \\<bar>1 - A1 * B0\\<bar>\n    \\<le> \\<bar>1 - A1 * B0\\<bar>", "using assms(1) mult_left_le_one_le[of \"\\<bar>(1 - A1*B0)\\<bar>\"]"], ["proof (prove)\nusing this:\n  \\<bar>A0 * B1\\<bar> \\<le> 1\n  \\<lbrakk>0 \\<le> \\<bar>1 - A1 * B0\\<bar>; 0 \\<le> ?y; ?y \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> ?y * \\<bar>1 - A1 * B0\\<bar>\n                    \\<le> \\<bar>1 - A1 * B0\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1\\<bar> * \\<bar>1 - A1 * B0\\<bar>\n    \\<le> \\<bar>1 - A1 * B0\\<bar>", "by simp"], ["proof (state)\nthis:\n  \\<bar>A0 * B1\\<bar> * \\<bar>1 - A1 * B0\\<bar>\n  \\<le> \\<bar>1 - A1 * B0\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1\\<bar> * \\<bar>1 - A1 * B0\\<bar> +\n    \\<bar>A0 * B0\\<bar> * \\<bar>1 - A1 * B1\\<bar>\n    \\<le> \\<bar>1 - A1 * B0\\<bar> + \\<bar>1 - A1 * B1\\<bar>", "moreover"], ["proof (state)\nthis:\n  \\<bar>A0 * B1\\<bar> * \\<bar>1 - A1 * B0\\<bar>\n  \\<le> \\<bar>1 - A1 * B0\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1\\<bar> * \\<bar>1 - A1 * B0\\<bar> +\n    \\<bar>A0 * B0\\<bar> * \\<bar>1 - A1 * B1\\<bar>\n    \\<le> \\<bar>1 - A1 * B0\\<bar> + \\<bar>1 - A1 * B1\\<bar>", "have \"\\<bar>A0 * B0\\<bar> *\\<bar>(1 - A1* B1)\\<bar> \\<le> \\<bar>(1 - A1* B1)\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>A0 * B0\\<bar> * \\<bar>1 - A1 * B1\\<bar>\n    \\<le> \\<bar>1 - A1 * B1\\<bar>", "using assms mult_left_le_one_le[of \"\\<bar>(1 - A1*B1)\\<bar>\"]"], ["proof (prove)\nusing this:\n  \\<bar>A0 * B1\\<bar> \\<le> 1\n  \\<bar>A0 * B0\\<bar> \\<le> 1\n  \\<bar>A1 * B0\\<bar> \\<le> 1\n  \\<bar>A1 * B1\\<bar> \\<le> 1\n  \\<lbrakk>0 \\<le> \\<bar>1 - A1 * B1\\<bar>; 0 \\<le> ?y; ?y \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> ?y * \\<bar>1 - A1 * B1\\<bar>\n                    \\<le> \\<bar>1 - A1 * B1\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B0\\<bar> * \\<bar>1 - A1 * B1\\<bar>\n    \\<le> \\<bar>1 - A1 * B1\\<bar>", "by simp"], ["proof (state)\nthis:\n  \\<bar>A0 * B0\\<bar> * \\<bar>1 - A1 * B1\\<bar>\n  \\<le> \\<bar>1 - A1 * B1\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1\\<bar> * \\<bar>1 - A1 * B0\\<bar> +\n    \\<bar>A0 * B0\\<bar> * \\<bar>1 - A1 * B1\\<bar>\n    \\<le> \\<bar>1 - A1 * B0\\<bar> + \\<bar>1 - A1 * B1\\<bar>", "ultimately"], ["proof (chain)\npicking this:\n  \\<bar>A0 * B1\\<bar> * \\<bar>1 - A1 * B0\\<bar>\n  \\<le> \\<bar>1 - A1 * B0\\<bar>\n  \\<bar>A0 * B0\\<bar> * \\<bar>1 - A1 * B1\\<bar>\n  \\<le> \\<bar>1 - A1 * B1\\<bar>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>A0 * B1\\<bar> * \\<bar>1 - A1 * B0\\<bar>\n  \\<le> \\<bar>1 - A1 * B0\\<bar>\n  \\<bar>A0 * B0\\<bar> * \\<bar>1 - A1 * B1\\<bar>\n  \\<le> \\<bar>1 - A1 * B1\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1\\<bar> * \\<bar>1 - A1 * B0\\<bar> +\n    \\<bar>A0 * B0\\<bar> * \\<bar>1 - A1 * B1\\<bar>\n    \\<le> \\<bar>1 - A1 * B0\\<bar> + \\<bar>1 - A1 * B1\\<bar>", "by simp"], ["proof (state)\nthis:\n  \\<bar>A0 * B1\\<bar> * \\<bar>1 - A1 * B0\\<bar> +\n  \\<bar>A0 * B0\\<bar> * \\<bar>1 - A1 * B1\\<bar>\n  \\<le> \\<bar>1 - A1 * B0\\<bar> + \\<bar>1 - A1 * B1\\<bar>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<bar>A0 * B1\\<bar> * \\<bar>1 - A1 * B0\\<bar> +\n  \\<bar>A0 * B0\\<bar> * \\<bar>1 - A1 * B1\\<bar>\n  \\<le> \\<bar>1 - A1 * B0\\<bar> + \\<bar>1 - A1 * B1\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0 + A1 * B0 + A1 * B1\\<bar> \\<le> 2", "also"], ["proof (state)\nthis:\n  \\<bar>A0 * B1\\<bar> * \\<bar>1 - A1 * B0\\<bar> +\n  \\<bar>A0 * B0\\<bar> * \\<bar>1 - A1 * B1\\<bar>\n  \\<le> \\<bar>1 - A1 * B0\\<bar> + \\<bar>1 - A1 * B1\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0 + A1 * B0 + A1 * B1\\<bar> \\<le> 2", "have \"... = 1 - A1*B0 + 1 - A1* B1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>1 - A1 * B0\\<bar> + \\<bar>1 - A1 * B1\\<bar> =\n    1 - A1 * B0 + 1 - A1 * B1", "using assms"], ["proof (prove)\nusing this:\n  \\<bar>A0 * B1\\<bar> \\<le> 1\n  \\<bar>A0 * B0\\<bar> \\<le> 1\n  \\<bar>A1 * B0\\<bar> \\<le> 1\n  \\<bar>A1 * B1\\<bar> \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<bar>1 - A1 * B0\\<bar> + \\<bar>1 - A1 * B1\\<bar> =\n    1 - A1 * B0 + 1 - A1 * B1", "by (simp add: abs_le_iff)"], ["proof (state)\nthis:\n  \\<bar>1 - A1 * B0\\<bar> + \\<bar>1 - A1 * B1\\<bar> =\n  1 - A1 * B0 + 1 - A1 * B1\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0 + A1 * B0 + A1 * B1\\<bar> \\<le> 2", "also"], ["proof (state)\nthis:\n  \\<bar>1 - A1 * B0\\<bar> + \\<bar>1 - A1 * B1\\<bar> =\n  1 - A1 * B0 + 1 - A1 * B1\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0 + A1 * B0 + A1 * B1\\<bar> \\<le> 2", "have \"... = 2 - A1 * B0 - A1 * B1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 - A1 * B0 + 1 - A1 * B1 = 2 - A1 * B0 - A1 * B1", "by simp"], ["proof (state)\nthis:\n  1 - A1 * B0 + 1 - A1 * B1 = 2 - A1 * B0 - A1 * B1\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0 + A1 * B0 + A1 * B1\\<bar> \\<le> 2", "finally"], ["proof (chain)\npicking this:\n  \\<bar>A0 * B1 - A0 * B0\\<bar> \\<le> 2 - A1 * B0 - A1 * B1", "have mns: \"\\<bar>A0 * B1 - A0 * B0\\<bar> \\<le> 2 - (A1 * B0 + A1 * B1)\""], ["proof (prove)\nusing this:\n  \\<bar>A0 * B1 - A0 * B0\\<bar> \\<le> 2 - A1 * B0 - A1 * B1\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0\\<bar> \\<le> 2 - (A1 * B0 + A1 * B1)", "by simp"], ["proof (state)\nthis:\n  \\<bar>A0 * B1 - A0 * B0\\<bar> \\<le> 2 - (A1 * B0 + A1 * B1)\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0 + A1 * B0 + A1 * B1\\<bar> \\<le> 2", "have ls: \"\\<bar>A0 * B1 - A0 * B0\\<bar> \\<le> 2 - \\<bar>A1 * B0 + A1 * B1\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0\\<bar> \\<le> 2 - \\<bar>A1 * B0 + A1 * B1\\<bar>", "proof (cases \"0 \\<le> A1 * B0 + A1 * B1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> A1 * B0 + A1 * B1 \\<Longrightarrow>\n    \\<bar>A0 * B1 - A0 * B0\\<bar> \\<le> 2 - \\<bar>A1 * B0 + A1 * B1\\<bar>\n 2. \\<not> 0 \\<le> A1 * B0 + A1 * B1 \\<Longrightarrow>\n    \\<bar>A0 * B1 - A0 * B0\\<bar> \\<le> 2 - \\<bar>A1 * B0 + A1 * B1\\<bar>", "case True"], ["proof (state)\nthis:\n  0 \\<le> A1 * B0 + A1 * B1\n\ngoal (2 subgoals):\n 1. 0 \\<le> A1 * B0 + A1 * B1 \\<Longrightarrow>\n    \\<bar>A0 * B1 - A0 * B0\\<bar> \\<le> 2 - \\<bar>A1 * B0 + A1 * B1\\<bar>\n 2. \\<not> 0 \\<le> A1 * B0 + A1 * B1 \\<Longrightarrow>\n    \\<bar>A0 * B1 - A0 * B0\\<bar> \\<le> 2 - \\<bar>A1 * B0 + A1 * B1\\<bar>", "then"], ["proof (chain)\npicking this:\n  0 \\<le> A1 * B0 + A1 * B1", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> A1 * B0 + A1 * B1\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0\\<bar> \\<le> 2 - \\<bar>A1 * B0 + A1 * B1\\<bar>", "using mns"], ["proof (prove)\nusing this:\n  0 \\<le> A1 * B0 + A1 * B1\n  \\<bar>A0 * B1 - A0 * B0\\<bar> \\<le> 2 - (A1 * B0 + A1 * B1)\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0\\<bar> \\<le> 2 - \\<bar>A1 * B0 + A1 * B1\\<bar>", "by simp"], ["proof (state)\nthis:\n  \\<bar>A0 * B1 - A0 * B0\\<bar> \\<le> 2 - \\<bar>A1 * B0 + A1 * B1\\<bar>\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> A1 * B0 + A1 * B1 \\<Longrightarrow>\n    \\<bar>A0 * B1 - A0 * B0\\<bar> \\<le> 2 - \\<bar>A1 * B0 + A1 * B1\\<bar>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> A1 * B0 + A1 * B1 \\<Longrightarrow>\n    \\<bar>A0 * B1 - A0 * B0\\<bar> \\<le> 2 - \\<bar>A1 * B0 + A1 * B1\\<bar>", "case False"], ["proof (state)\nthis:\n  \\<not> 0 \\<le> A1 * B0 + A1 * B1\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> A1 * B0 + A1 * B1 \\<Longrightarrow>\n    \\<bar>A0 * B1 - A0 * B0\\<bar> \\<le> 2 - \\<bar>A1 * B0 + A1 * B1\\<bar>", "then"], ["proof (chain)\npicking this:\n  \\<not> 0 \\<le> A1 * B0 + A1 * B1", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> 0 \\<le> A1 * B0 + A1 * B1\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0\\<bar> \\<le> 2 - \\<bar>A1 * B0 + A1 * B1\\<bar>", "using pls"], ["proof (prove)\nusing this:\n  \\<not> 0 \\<le> A1 * B0 + A1 * B1\n  \\<bar>A0 * B1 - A0 * B0\\<bar> \\<le> 2 + A1 * B0 + A1 * B1\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0\\<bar> \\<le> 2 - \\<bar>A1 * B0 + A1 * B1\\<bar>", "by simp"], ["proof (state)\nthis:\n  \\<bar>A0 * B1 - A0 * B0\\<bar> \\<le> 2 - \\<bar>A1 * B0 + A1 * B1\\<bar>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<bar>A0 * B1 - A0 * B0\\<bar> \\<le> 2 - \\<bar>A1 * B0 + A1 * B1\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0 + A1 * B0 + A1 * B1\\<bar> \\<le> 2", "have \"\\<bar>A0 * B1 - A0 * B0 + A1 * B0 + A1 * B1\\<bar> \\<le> \\<bar>A0 * B1 - A0 * B0\\<bar> + \\<bar>A1 * B0 + A1 * B1\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0 + A1 * B0 + A1 * B1\\<bar>\n    \\<le> \\<bar>A0 * B1 - A0 * B0\\<bar> + \\<bar>A1 * B0 + A1 * B1\\<bar>", "by simp"], ["proof (state)\nthis:\n  \\<bar>A0 * B1 - A0 * B0 + A1 * B0 + A1 * B1\\<bar>\n  \\<le> \\<bar>A0 * B1 - A0 * B0\\<bar> + \\<bar>A1 * B0 + A1 * B1\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0 + A1 * B0 + A1 * B1\\<bar> \\<le> 2", "also"], ["proof (state)\nthis:\n  \\<bar>A0 * B1 - A0 * B0 + A1 * B0 + A1 * B1\\<bar>\n  \\<le> \\<bar>A0 * B1 - A0 * B0\\<bar> + \\<bar>A1 * B0 + A1 * B1\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0 + A1 * B0 + A1 * B1\\<bar> \\<le> 2", "have \"... \\<le> 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0\\<bar> + \\<bar>A1 * B0 + A1 * B1\\<bar> \\<le> 2", "using ls"], ["proof (prove)\nusing this:\n  \\<bar>A0 * B1 - A0 * B0\\<bar> \\<le> 2 - \\<bar>A1 * B0 + A1 * B1\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0\\<bar> + \\<bar>A1 * B0 + A1 * B1\\<bar> \\<le> 2", "by simp"], ["proof (state)\nthis:\n  \\<bar>A0 * B1 - A0 * B0\\<bar> + \\<bar>A1 * B0 + A1 * B1\\<bar> \\<le> 2\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0 + A1 * B0 + A1 * B1\\<bar> \\<le> 2", "finally"], ["proof (chain)\npicking this:\n  \\<bar>A0 * B1 - A0 * B0 + A1 * B0 + A1 * B1\\<bar> \\<le> 2", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>A0 * B1 - A0 * B0 + A1 * B0 + A1 * B1\\<bar> \\<le> 2\n\ngoal (1 subgoal):\n 1. \\<bar>A0 * B1 - A0 * B0 + A1 * B0 + A1 * B1\\<bar> \\<le> 2", "."], ["proof (state)\nthis:\n  \\<bar>A0 * B1 - A0 * B0 + A1 * B0 + A1 * B1\\<bar> \\<le> 2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in prob_space) chsh_expect:\n  fixes A0::\"'a \\<Rightarrow> real\"\n  assumes \"AE w in M. \\<bar>A0 w\\<bar> \\<le> 1\"\n  and \"AE w in M. \\<bar>A1 w\\<bar> \\<le> 1\"\n  and \"AE w in M. \\<bar>B0 w\\<bar> \\<le> 1\"\n  and \"AE w in M. \\<bar>B1 w\\<bar> \\<le> 1\"\nand \"integrable M (\\<lambda>w. A0 w * B1 w)\"\nand \"integrable M (\\<lambda>w. A1 w * B1 w)\"\nand \"integrable M (\\<lambda>w. A1 w * B0 w)\"\nand \"integrable M (\\<lambda>w. A0 w * B0 w)\"\nshows \"\\<bar>expectation (\\<lambda>w. A1 w * B0 w) + expectation (\\<lambda>w. A0 w *B1 w) + \n  expectation (\\<lambda>w. A1 w * B1 w) - expectation (\\<lambda>w. A0 w * B0 w)\\<bar> \\<le> 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>expectation (\\<lambda>w. A1 w * B0 w) +\n          expectation (\\<lambda>w. A0 w * B1 w) +\n          expectation (\\<lambda>w. A1 w * B1 w) -\n          expectation (\\<lambda>w. A0 w * B0 w)\\<bar>\n    \\<le> 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>expectation (\\<lambda>w. A1 w * B0 w) +\n          expectation (\\<lambda>w. A0 w * B1 w) +\n          expectation (\\<lambda>w. A1 w * B1 w) -\n          expectation (\\<lambda>w. A0 w * B0 w)\\<bar>\n    \\<le> 2", "have exeq: \"expectation (\\<lambda>w. A1 w * B0 w) + expectation (\\<lambda>w. A0 w * B1 w) + \n    expectation (\\<lambda>w. A1 w * B1 w) - expectation (\\<lambda>w. A0 w * B0 w) = \n    expectation (\\<lambda>w. A0 w * B1 w - A0 w * B0 w + A1 w * B0 w + A1 w * B1 w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation (\\<lambda>w. A1 w * B0 w) +\n    expectation (\\<lambda>w. A0 w * B1 w) +\n    expectation (\\<lambda>w. A1 w * B1 w) -\n    expectation (\\<lambda>w. A0 w * B0 w) =\n    expectation\n     (\\<lambda>w. A0 w * B1 w - A0 w * B0 w + A1 w * B0 w + A1 w * B1 w)", "using assms"], ["proof (prove)\nusing this:\n  AE w in M. \\<bar>A0 w\\<bar> \\<le> 1\n  AE w in M. \\<bar>A1 w\\<bar> \\<le> 1\n  AE w in M. \\<bar>B0 w\\<bar> \\<le> 1\n  AE w in M. \\<bar>B1 w\\<bar> \\<le> 1\n  integrable M (\\<lambda>w. A0 w * B1 w)\n  integrable M (\\<lambda>w. A1 w * B1 w)\n  integrable M (\\<lambda>w. A1 w * B0 w)\n  integrable M (\\<lambda>w. A0 w * B0 w)\n\ngoal (1 subgoal):\n 1. expectation (\\<lambda>w. A1 w * B0 w) +\n    expectation (\\<lambda>w. A0 w * B1 w) +\n    expectation (\\<lambda>w. A1 w * B1 w) -\n    expectation (\\<lambda>w. A0 w * B0 w) =\n    expectation\n     (\\<lambda>w. A0 w * B1 w - A0 w * B0 w + A1 w * B0 w + A1 w * B1 w)", "by auto"], ["proof (state)\nthis:\n  expectation (\\<lambda>w. A1 w * B0 w) +\n  expectation (\\<lambda>w. A0 w * B1 w) +\n  expectation (\\<lambda>w. A1 w * B1 w) -\n  expectation (\\<lambda>w. A0 w * B0 w) =\n  expectation\n   (\\<lambda>w. A0 w * B1 w - A0 w * B0 w + A1 w * B0 w + A1 w * B1 w)\n\ngoal (1 subgoal):\n 1. \\<bar>expectation (\\<lambda>w. A1 w * B0 w) +\n          expectation (\\<lambda>w. A0 w * B1 w) +\n          expectation (\\<lambda>w. A1 w * B1 w) -\n          expectation (\\<lambda>w. A0 w * B0 w)\\<bar>\n    \\<le> 2", "have \"\\<bar>expectation (\\<lambda>w. A0 w * B1 w - A0 w * B0 w + A1 w * B0 w + A1 w * B1 w)\\<bar> \\<le>\n    expectation (\\<lambda>w. \\<bar>A0 w * B1 w - A0 w * B0 w + A1 w * B0 w + A1 w * B1 w\\<bar>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>expectation\n           (\\<lambda>w.\n               A0 w * B1 w - A0 w * B0 w + A1 w * B0 w + A1 w * B1 w)\\<bar>\n    \\<le> expectation\n           (\\<lambda>w.\n               \\<bar>A0 w * B1 w - A0 w * B0 w + A1 w * B0 w +\n                     A1 w * B1 w\\<bar>)", "using integral_abs_bound"], ["proof (prove)\nusing this:\n  \\<bar>integral\\<^sup>L ?M ?f\\<bar> \\<le> LINT x|?M. \\<bar>?f x\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>expectation\n           (\\<lambda>w.\n               A0 w * B1 w - A0 w * B0 w + A1 w * B0 w + A1 w * B1 w)\\<bar>\n    \\<le> expectation\n           (\\<lambda>w.\n               \\<bar>A0 w * B1 w - A0 w * B0 w + A1 w * B0 w +\n                     A1 w * B1 w\\<bar>)", "by blast"], ["proof (state)\nthis:\n  \\<bar>expectation\n         (\\<lambda>w.\n             A0 w * B1 w - A0 w * B0 w + A1 w * B0 w + A1 w * B1 w)\\<bar>\n  \\<le> expectation\n         (\\<lambda>w.\n             \\<bar>A0 w * B1 w - A0 w * B0 w + A1 w * B0 w +\n                   A1 w * B1 w\\<bar>)\n\ngoal (1 subgoal):\n 1. \\<bar>expectation (\\<lambda>w. A1 w * B0 w) +\n          expectation (\\<lambda>w. A0 w * B1 w) +\n          expectation (\\<lambda>w. A1 w * B1 w) -\n          expectation (\\<lambda>w. A0 w * B0 w)\\<bar>\n    \\<le> 2", "also"], ["proof (state)\nthis:\n  \\<bar>expectation\n         (\\<lambda>w.\n             A0 w * B1 w - A0 w * B0 w + A1 w * B0 w + A1 w * B1 w)\\<bar>\n  \\<le> expectation\n         (\\<lambda>w.\n             \\<bar>A0 w * B1 w - A0 w * B0 w + A1 w * B0 w +\n                   A1 w * B1 w\\<bar>)\n\ngoal (1 subgoal):\n 1. \\<bar>expectation (\\<lambda>w. A1 w * B0 w) +\n          expectation (\\<lambda>w. A0 w * B1 w) +\n          expectation (\\<lambda>w. A1 w * B1 w) -\n          expectation (\\<lambda>w. A0 w * B0 w)\\<bar>\n    \\<le> 2", "have \"... \\<le> 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation\n     (\\<lambda>w.\n         \\<bar>A0 w * B1 w - A0 w * B0 w + A1 w * B0 w + A1 w * B1 w\\<bar>)\n    \\<le> 2", "proof (rule integral_le_const)"], ["proof (state)\ngoal (2 subgoals):\n 1. integrable M\n     (\\<lambda>x.\n         \\<bar>A0 x * B1 x - A0 x * B0 x + A1 x * B0 x + A1 x * B1 x\\<bar>)\n 2. AE w in M. \\<bar>A0 w * B1 w - A0 w * B0 w + A1 w * B0 w +\n                     A1 w * B1 w\\<bar>\n               \\<le> 2", "show \"AE w in M. \\<bar>A0 w * B1 w - A0 w * B0 w + A1 w * B0 w + A1 w * B1 w\\<bar> \\<le> (2::real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE w in M. \\<bar>A0 w * B1 w - A0 w * B0 w + A1 w * B0 w +\n                     A1 w * B1 w\\<bar>\n               \\<le> 2", "proof (rule AE_mp)"], ["proof (state)\ngoal (2 subgoals):\n 1. almost_everywhere M ?P\n 2. AE w in M. ?P w \\<longrightarrow>\n               \\<bar>A0 w * B1 w - A0 w * B0 w + A1 w * B0 w +\n                     A1 w * B1 w\\<bar>\n               \\<le> 2", "show \"AE w in M. \\<bar>A0 w\\<bar> \\<le> 1 \\<and> \\<bar>A1 w\\<bar> \\<le> 1 \\<and> \\<bar>B0 w\\<bar> \\<le> 1 \\<and> \\<bar>B1 w\\<bar> \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE w in M. \\<bar>A0 w\\<bar> \\<le> 1 \\<and>\n               \\<bar>A1 w\\<bar> \\<le> 1 \\<and>\n               \\<bar>B0 w\\<bar> \\<le> 1 \\<and> \\<bar>B1 w\\<bar> \\<le> 1", "using assms"], ["proof (prove)\nusing this:\n  AE w in M. \\<bar>A0 w\\<bar> \\<le> 1\n  AE w in M. \\<bar>A1 w\\<bar> \\<le> 1\n  AE w in M. \\<bar>B0 w\\<bar> \\<le> 1\n  AE w in M. \\<bar>B1 w\\<bar> \\<le> 1\n  integrable M (\\<lambda>w. A0 w * B1 w)\n  integrable M (\\<lambda>w. A1 w * B1 w)\n  integrable M (\\<lambda>w. A1 w * B0 w)\n  integrable M (\\<lambda>w. A0 w * B0 w)\n\ngoal (1 subgoal):\n 1. AE w in M. \\<bar>A0 w\\<bar> \\<le> 1 \\<and>\n               \\<bar>A1 w\\<bar> \\<le> 1 \\<and>\n               \\<bar>B0 w\\<bar> \\<le> 1 \\<and> \\<bar>B1 w\\<bar> \\<le> 1", "by simp"], ["proof (state)\nthis:\n  AE w in M. \\<bar>A0 w\\<bar> \\<le> 1 \\<and>\n             \\<bar>A1 w\\<bar> \\<le> 1 \\<and>\n             \\<bar>B0 w\\<bar> \\<le> 1 \\<and> \\<bar>B1 w\\<bar> \\<le> 1\n\ngoal (1 subgoal):\n 1. AE w in M. \\<bar>A0 w\\<bar> \\<le> 1 \\<and>\n               \\<bar>A1 w\\<bar> \\<le> 1 \\<and>\n               \\<bar>B0 w\\<bar> \\<le> 1 \\<and>\n               \\<bar>B1 w\\<bar> \\<le> 1 \\<longrightarrow>\n               \\<bar>A0 w * B1 w - A0 w * B0 w + A1 w * B0 w +\n                     A1 w * B1 w\\<bar>\n               \\<le> 2", "show \"AE w in M. \\<bar>A0 w\\<bar> \\<le> 1 \\<and> \\<bar>A1 w\\<bar> \\<le> 1 \\<and> \\<bar>B0 w\\<bar> \\<le> 1 \\<and> \\<bar>B1 w\\<bar> \\<le> 1 \\<longrightarrow>\n               \\<bar>A0 w * B1 w - A0 w * B0 w + A1 w * B0 w + A1 w * B1 w\\<bar> \\<le> 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE w in M. \\<bar>A0 w\\<bar> \\<le> 1 \\<and>\n               \\<bar>A1 w\\<bar> \\<le> 1 \\<and>\n               \\<bar>B0 w\\<bar> \\<le> 1 \\<and>\n               \\<bar>B1 w\\<bar> \\<le> 1 \\<longrightarrow>\n               \\<bar>A0 w * B1 w - A0 w * B0 w + A1 w * B0 w +\n                     A1 w * B1 w\\<bar>\n               \\<le> 2", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<in> space M \\<Longrightarrow>\n       \\<bar>A0 w\\<bar> \\<le> 1 \\<and>\n       \\<bar>A1 w\\<bar> \\<le> 1 \\<and>\n       \\<bar>B0 w\\<bar> \\<le> 1 \\<and>\n       \\<bar>B1 w\\<bar> \\<le> 1 \\<longrightarrow>\n       \\<bar>A0 w * B1 w - A0 w * B0 w + A1 w * B0 w + A1 w * B1 w\\<bar>\n       \\<le> 2", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<in> space M \\<Longrightarrow>\n       \\<bar>A0 w\\<bar> \\<le> 1 \\<and>\n       \\<bar>A1 w\\<bar> \\<le> 1 \\<and>\n       \\<bar>B0 w\\<bar> \\<le> 1 \\<and>\n       \\<bar>B1 w\\<bar> \\<le> 1 \\<longrightarrow>\n       \\<bar>A0 w * B1 w - A0 w * B0 w + A1 w * B0 w + A1 w * B1 w\\<bar>\n       \\<le> 2", "assume \"w\\<in> space M\""], ["proof (state)\nthis:\n  w \\<in> space M\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<in> space M \\<Longrightarrow>\n       \\<bar>A0 w\\<bar> \\<le> 1 \\<and>\n       \\<bar>A1 w\\<bar> \\<le> 1 \\<and>\n       \\<bar>B0 w\\<bar> \\<le> 1 \\<and>\n       \\<bar>B1 w\\<bar> \\<le> 1 \\<longrightarrow>\n       \\<bar>A0 w * B1 w - A0 w * B0 w + A1 w * B0 w + A1 w * B1 w\\<bar>\n       \\<le> 2", "show \"\\<bar>A0 w\\<bar> \\<le> 1 \\<and> \\<bar>A1 w\\<bar> \\<le> 1 \\<and> \\<bar>B0 w\\<bar> \\<le> 1 \\<and> \\<bar>B1 w\\<bar> \\<le> 1 \\<longrightarrow>\n         \\<bar>A0 w * B1 w - A0 w * B0 w + A1 w * B0 w + A1 w * B1 w\\<bar> \\<le> 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>A0 w\\<bar> \\<le> 1 \\<and>\n    \\<bar>A1 w\\<bar> \\<le> 1 \\<and>\n    \\<bar>B0 w\\<bar> \\<le> 1 \\<and>\n    \\<bar>B1 w\\<bar> \\<le> 1 \\<longrightarrow>\n    \\<bar>A0 w * B1 w - A0 w * B0 w + A1 w * B0 w + A1 w * B1 w\\<bar>\n    \\<le> 2", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>A0 w\\<bar> \\<le> 1 \\<and>\n    \\<bar>A1 w\\<bar> \\<le> 1 \\<and>\n    \\<bar>B0 w\\<bar> \\<le> 1 \\<and>\n    \\<bar>B1 w\\<bar> \\<le> 1 \\<Longrightarrow>\n    \\<bar>A0 w * B1 w - A0 w * B0 w + A1 w * B0 w + A1 w * B1 w\\<bar>\n    \\<le> 2", "assume ineq: \"\\<bar>A0 w\\<bar> \\<le> 1 \\<and> \\<bar>A1 w\\<bar> \\<le> 1 \\<and> \\<bar>B0 w\\<bar> \\<le> 1 \\<and> \\<bar>B1 w\\<bar> \\<le> 1\""], ["proof (state)\nthis:\n  \\<bar>A0 w\\<bar> \\<le> 1 \\<and>\n  \\<bar>A1 w\\<bar> \\<le> 1 \\<and>\n  \\<bar>B0 w\\<bar> \\<le> 1 \\<and> \\<bar>B1 w\\<bar> \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<bar>A0 w\\<bar> \\<le> 1 \\<and>\n    \\<bar>A1 w\\<bar> \\<le> 1 \\<and>\n    \\<bar>B0 w\\<bar> \\<le> 1 \\<and>\n    \\<bar>B1 w\\<bar> \\<le> 1 \\<Longrightarrow>\n    \\<bar>A0 w * B1 w - A0 w * B0 w + A1 w * B0 w + A1 w * B1 w\\<bar>\n    \\<le> 2", "show \"\\<bar>A0 w * B1 w - A0 w * B0 w + A1 w * B0 w + A1 w * B1 w\\<bar> \\<le> 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>A0 w * B1 w - A0 w * B0 w + A1 w * B0 w + A1 w * B1 w\\<bar>\n    \\<le> 2", "proof (rule chsh_real)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<bar>A0 w * B1 w\\<bar> \\<le> 1\n 2. \\<bar>A0 w * B0 w\\<bar> \\<le> 1\n 3. \\<bar>A1 w * B0 w\\<bar> \\<le> 1\n 4. \\<bar>A1 w * B1 w\\<bar> \\<le> 1", "show \"\\<bar>A0 w * B1 w\\<bar> \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>A0 w * B1 w\\<bar> \\<le> 1", "using ineq"], ["proof (prove)\nusing this:\n  \\<bar>A0 w\\<bar> \\<le> 1 \\<and>\n  \\<bar>A1 w\\<bar> \\<le> 1 \\<and>\n  \\<bar>B0 w\\<bar> \\<le> 1 \\<and> \\<bar>B1 w\\<bar> \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<bar>A0 w * B1 w\\<bar> \\<le> 1", "by (simp add: abs_mult mult_le_one)"], ["proof (state)\nthis:\n  \\<bar>A0 w * B1 w\\<bar> \\<le> 1\n\ngoal (3 subgoals):\n 1. \\<bar>A0 w * B0 w\\<bar> \\<le> 1\n 2. \\<bar>A1 w * B0 w\\<bar> \\<le> 1\n 3. \\<bar>A1 w * B1 w\\<bar> \\<le> 1", "show \"\\<bar>A0 w * B0 w\\<bar> \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>A0 w * B0 w\\<bar> \\<le> 1", "using ineq"], ["proof (prove)\nusing this:\n  \\<bar>A0 w\\<bar> \\<le> 1 \\<and>\n  \\<bar>A1 w\\<bar> \\<le> 1 \\<and>\n  \\<bar>B0 w\\<bar> \\<le> 1 \\<and> \\<bar>B1 w\\<bar> \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<bar>A0 w * B0 w\\<bar> \\<le> 1", "by (simp add: abs_mult mult_le_one)"], ["proof (state)\nthis:\n  \\<bar>A0 w * B0 w\\<bar> \\<le> 1\n\ngoal (2 subgoals):\n 1. \\<bar>A1 w * B0 w\\<bar> \\<le> 1\n 2. \\<bar>A1 w * B1 w\\<bar> \\<le> 1", "show \"\\<bar>A1 w * B1 w\\<bar> \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>A1 w * B1 w\\<bar> \\<le> 1", "using ineq"], ["proof (prove)\nusing this:\n  \\<bar>A0 w\\<bar> \\<le> 1 \\<and>\n  \\<bar>A1 w\\<bar> \\<le> 1 \\<and>\n  \\<bar>B0 w\\<bar> \\<le> 1 \\<and> \\<bar>B1 w\\<bar> \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<bar>A1 w * B1 w\\<bar> \\<le> 1", "by (simp add: abs_mult mult_le_one)"], ["proof (state)\nthis:\n  \\<bar>A1 w * B1 w\\<bar> \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<bar>A1 w * B0 w\\<bar> \\<le> 1", "show \"\\<bar>A1 w * B0 w\\<bar> \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>A1 w * B0 w\\<bar> \\<le> 1", "using ineq"], ["proof (prove)\nusing this:\n  \\<bar>A0 w\\<bar> \\<le> 1 \\<and>\n  \\<bar>A1 w\\<bar> \\<le> 1 \\<and>\n  \\<bar>B0 w\\<bar> \\<le> 1 \\<and> \\<bar>B1 w\\<bar> \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<bar>A1 w * B0 w\\<bar> \\<le> 1", "by (simp add: abs_mult mult_le_one)"], ["proof (state)\nthis:\n  \\<bar>A1 w * B0 w\\<bar> \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<bar>A0 w * B1 w - A0 w * B0 w + A1 w * B0 w + A1 w * B1 w\\<bar> \\<le> 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<bar>A0 w\\<bar> \\<le> 1 \\<and>\n  \\<bar>A1 w\\<bar> \\<le> 1 \\<and>\n  \\<bar>B0 w\\<bar> \\<le> 1 \\<and> \\<bar>B1 w\\<bar> \\<le> 1 \\<longrightarrow>\n  \\<bar>A0 w * B1 w - A0 w * B0 w + A1 w * B0 w + A1 w * B1 w\\<bar> \\<le> 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  AE w in M. \\<bar>A0 w\\<bar> \\<le> 1 \\<and>\n             \\<bar>A1 w\\<bar> \\<le> 1 \\<and>\n             \\<bar>B0 w\\<bar> \\<le> 1 \\<and>\n             \\<bar>B1 w\\<bar> \\<le> 1 \\<longrightarrow>\n             \\<bar>A0 w * B1 w - A0 w * B0 w + A1 w * B0 w +\n                   A1 w * B1 w\\<bar>\n             \\<le> 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  AE w in M. \\<bar>A0 w * B1 w - A0 w * B0 w + A1 w * B0 w +\n                   A1 w * B1 w\\<bar>\n             \\<le> 2\n\ngoal (1 subgoal):\n 1. integrable M\n     (\\<lambda>x.\n         \\<bar>A0 x * B1 x - A0 x * B0 x + A1 x * B0 x + A1 x * B1 x\\<bar>)", "show \"integrable M (\\<lambda>x. \\<bar>A0 x * B1 x - A0 x * B0 x + A1 x * B0 x + A1 x * B1 x\\<bar>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integrable M\n     (\\<lambda>x.\n         \\<bar>A0 x * B1 x - A0 x * B0 x + A1 x * B0 x + A1 x * B1 x\\<bar>)", "proof (rule Bochner_Integration.integrable_abs)"], ["proof (state)\ngoal (1 subgoal):\n 1. integrable M\n     (\\<lambda>x. A0 x * B1 x - A0 x * B0 x + A1 x * B0 x + A1 x * B1 x)", "show \"integrable M (\\<lambda>x. A0 x * B1 x - A0 x * B0 x + A1 x * B0 x + A1 x * B1 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integrable M\n     (\\<lambda>x. A0 x * B1 x - A0 x * B0 x + A1 x * B0 x + A1 x * B1 x)", "using assms"], ["proof (prove)\nusing this:\n  AE w in M. \\<bar>A0 w\\<bar> \\<le> 1\n  AE w in M. \\<bar>A1 w\\<bar> \\<le> 1\n  AE w in M. \\<bar>B0 w\\<bar> \\<le> 1\n  AE w in M. \\<bar>B1 w\\<bar> \\<le> 1\n  integrable M (\\<lambda>w. A0 w * B1 w)\n  integrable M (\\<lambda>w. A1 w * B1 w)\n  integrable M (\\<lambda>w. A1 w * B0 w)\n  integrable M (\\<lambda>w. A0 w * B0 w)\n\ngoal (1 subgoal):\n 1. integrable M\n     (\\<lambda>x. A0 x * B1 x - A0 x * B0 x + A1 x * B0 x + A1 x * B1 x)", "by auto"], ["proof (state)\nthis:\n  integrable M\n   (\\<lambda>x. A0 x * B1 x - A0 x * B0 x + A1 x * B0 x + A1 x * B1 x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  integrable M\n   (\\<lambda>x.\n       \\<bar>A0 x * B1 x - A0 x * B0 x + A1 x * B0 x + A1 x * B1 x\\<bar>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  expectation\n   (\\<lambda>w.\n       \\<bar>A0 w * B1 w - A0 w * B0 w + A1 w * B0 w + A1 w * B1 w\\<bar>)\n  \\<le> 2\n\ngoal (1 subgoal):\n 1. \\<bar>expectation (\\<lambda>w. A1 w * B0 w) +\n          expectation (\\<lambda>w. A0 w * B1 w) +\n          expectation (\\<lambda>w. A1 w * B1 w) -\n          expectation (\\<lambda>w. A0 w * B0 w)\\<bar>\n    \\<le> 2", "finally"], ["proof (chain)\npicking this:\n  \\<bar>expectation\n         (\\<lambda>w.\n             A0 w * B1 w - A0 w * B0 w + A1 w * B0 w + A1 w * B1 w)\\<bar>\n  \\<le> 2", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>expectation\n         (\\<lambda>w.\n             A0 w * B1 w - A0 w * B0 w + A1 w * B0 w + A1 w * B1 w)\\<bar>\n  \\<le> 2\n\ngoal (1 subgoal):\n 1. \\<bar>expectation (\\<lambda>w. A1 w * B0 w) +\n          expectation (\\<lambda>w. A0 w * B1 w) +\n          expectation (\\<lambda>w. A1 w * B1 w) -\n          expectation (\\<lambda>w. A0 w * B0 w)\\<bar>\n    \\<le> 2", "using exeq"], ["proof (prove)\nusing this:\n  \\<bar>expectation\n         (\\<lambda>w.\n             A0 w * B1 w - A0 w * B0 w + A1 w * B0 w + A1 w * B1 w)\\<bar>\n  \\<le> 2\n  expectation (\\<lambda>w. A1 w * B0 w) +\n  expectation (\\<lambda>w. A0 w * B1 w) +\n  expectation (\\<lambda>w. A1 w * B1 w) -\n  expectation (\\<lambda>w. A0 w * B0 w) =\n  expectation\n   (\\<lambda>w. A0 w * B1 w - A0 w * B0 w + A1 w * B0 w + A1 w * B1 w)\n\ngoal (1 subgoal):\n 1. \\<bar>expectation (\\<lambda>w. A1 w * B0 w) +\n          expectation (\\<lambda>w. A0 w * B1 w) +\n          expectation (\\<lambda>w. A1 w * B1 w) -\n          expectation (\\<lambda>w. A0 w * B0 w)\\<bar>\n    \\<le> 2", "by simp"], ["proof (state)\nthis:\n  \\<bar>expectation (\\<lambda>w. A1 w * B0 w) +\n        expectation (\\<lambda>w. A0 w * B1 w) +\n        expectation (\\<lambda>w. A1 w * B1 w) -\n        expectation (\\<lambda>w. A0 w * B0 w)\\<bar>\n  \\<le> 2\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The local hidden variable assumption states that separated quantum measurements are \nindependent. It is standard for this assumption to be stated in a context where the hidden \nvariable admits a density; it is stated here in a more general contest involving expectations, \nwith no assumption on the existence of a density.\\<close>"], ["", "definition pos_rv:: \"'a measure \\<Rightarrow> ('a \\<Rightarrow> real) \\<Rightarrow> bool\" where\n\"pos_rv M Xr \\<equiv> Xr \\<in> borel_measurable M \\<and> (AE w in M. (0::real) \\<le> Xr w)\""], ["", "definition prv_sum:: \"'a measure \\<Rightarrow> complex Matrix.mat \\<Rightarrow> (complex \\<Rightarrow> 'a \\<Rightarrow> real) \\<Rightarrow> bool\" where\n\"prv_sum M A Xr \\<equiv> (AE w in M. (\\<Sum> a\\<in> spectrum A. Xr a w) = 1)\""], ["", "definition (in cpx_sq_mat) lhv where\n\"lhv M A B R XA XB \\<equiv> \n  prob_space M \\<and>\n  (\\<forall>a \\<in>spectrum A. pos_rv M (XA a)) \\<and> \n  (prv_sum M A XA) \\<and> \n  (\\<forall>b \\<in>spectrum B. pos_rv M (XB b)) \\<and>\n  (prv_sum M B XB) \\<and> \n  (\\<forall>a \\<in>spectrum A . \\<forall>b \\<in> spectrum B. \n    (integrable M (\\<lambda>w. XA a w * XB b w)) \\<and> \n    integral\\<^sup>L M (\\<lambda>w. XA a w * XB b w) = \n    Re (Complex_Matrix.trace(eigen_projector A a * (eigen_projector B b) * R)))\""], ["", "(*definition (in cpx_sq_mat) lhv where\n\"lhv M A B R XA XB \\<equiv> \n  prob_space M \\<and>\n  (\\<forall>a \\<in>spectrum A. (XA a \\<in> borel_measurable M) \\<and> \n    (AE w in M. ((0::real) \\<le> XA a w))) \\<and> \n  (AE w in M. (\\<Sum> a\\<in> spectrum A. XA a w) = 1) \\<and> \n  (\\<forall>b \\<in>spectrum B. (XB b \\<in> borel_measurable M) \\<and> \n    (AE w in M. (0 \\<le> XB b w))) \\<and>\n  (AE w in M. (\\<Sum> b\\<in> spectrum B. XB b w) = 1) \\<and> \n  (\\<forall>a \\<in>spectrum A . \\<forall>b \\<in> spectrum B. \n    (integrable M (\\<lambda>w. XA a w * XB b w)) \\<and> \n    integral\\<^sup>L M (\\<lambda>w. XA a w * XB b w) = \n    Re (Complex_Matrix.trace(eigen_projector A a * (eigen_projector B b) * R)))\"*)"], ["", "lemma (in cpx_sq_mat) lhv_posl:\n  assumes \"lhv M A B R XA XB\"\n  shows \"AE w in M. (\\<forall> a \\<in> spectrum A. 0 \\<le> XA a w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE w in M. \\<forall>a\\<in>spectrum A. 0 \\<le> XA a w", "proof (rule AE_ball_countable[THEN iffD2])"], ["proof (state)\ngoal (2 subgoals):\n 1. countable (spectrum A)\n 2. \\<forall>a\\<in>spectrum A. AE w in M. 0 \\<le> XA a w", "show \"countable (spectrum A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable (spectrum A)", "using spectrum_finite[of A]"], ["proof (prove)\nusing this:\n  finite (spectrum A)\n\ngoal (1 subgoal):\n 1. countable (spectrum A)", "by (simp add: countable_finite)"], ["proof (state)\nthis:\n  countable (spectrum A)\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>spectrum A. AE w in M. 0 \\<le> XA a w", "show \"\\<forall>a\\<in>spectrum A. AE w in M. 0 \\<le> XA a w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>spectrum A. AE w in M. 0 \\<le> XA a w", "using assms"], ["proof (prove)\nusing this:\n  lhv M A B R XA XB\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>spectrum A. AE w in M. 0 \\<le> XA a w", "unfolding lhv_def pos_rv_def"], ["proof (prove)\nusing this:\n  prob_space M \\<and>\n  (\\<forall>a\\<in>spectrum A.\n      XA a \\<in> borel_measurable M \\<and>\n      (AE w in M. 0 \\<le> XA a w)) \\<and>\n  prv_sum M A XA \\<and>\n  (\\<forall>b\\<in>spectrum B.\n      XB b \\<in> borel_measurable M \\<and>\n      (AE w in M. 0 \\<le> XB b w)) \\<and>\n  prv_sum M B XB \\<and>\n  (\\<forall>a\\<in>spectrum A.\n      \\<forall>b\\<in>spectrum B.\n         integrable M (\\<lambda>w. XA a w * XB b w) \\<and>\n         LINT w|M. XA a w * XB b w =\n         Re (Complex_Matrix.trace\n              (eigen_projector A a * eigen_projector B b * R)))\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>spectrum A. AE w in M. 0 \\<le> XA a w", "by simp"], ["proof (state)\nthis:\n  \\<forall>a\\<in>spectrum A. AE w in M. 0 \\<le> XA a w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in cpx_sq_mat) lhv_lt1_l:\n  assumes \"lhv M A B R XA XB\"\n  shows \"AE w in M. (\\<forall> a \\<in> spectrum A. XA a w \\<le> 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE w in M. \\<forall>a\\<in>spectrum A. XA a w \\<le> 1", "proof (rule AE_mp)"], ["proof (state)\ngoal (2 subgoals):\n 1. almost_everywhere M ?P\n 2. AE w in M. ?P w \\<longrightarrow>\n               (\\<forall>a\\<in>spectrum A. XA a w \\<le> 1)", "show \"AE w in M. (\\<forall> a \\<in> spectrum A. 0 \\<le> XA a w) \\<and> (\\<Sum> a\\<in> spectrum A. XA a w) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE w in M. (\\<forall>a\\<in>spectrum A. 0 \\<le> XA a w) \\<and>\n               (\\<Sum>a\\<in>spectrum A. XA a w) = 1", "using lhv_posl assms"], ["proof (prove)\nusing this:\n  lhv ?M ?A ?B ?R ?XA ?XB \\<Longrightarrow>\n  AE w in ?M. \\<forall>a\\<in>spectrum ?A. 0 \\<le> ?XA a w\n  lhv M A B R XA XB\n\ngoal (1 subgoal):\n 1. AE w in M. (\\<forall>a\\<in>spectrum A. 0 \\<le> XA a w) \\<and>\n               (\\<Sum>a\\<in>spectrum A. XA a w) = 1", "unfolding lhv_def pos_rv_def prv_sum_def"], ["proof (prove)\nusing this:\n  prob_space ?M \\<and>\n  (\\<forall>a\\<in>spectrum ?A.\n      ?XA a \\<in> borel_measurable ?M \\<and>\n      (AE w in ?M. 0 \\<le> ?XA a w)) \\<and>\n  (AE w in ?M. (\\<Sum>a\\<in>spectrum ?A. ?XA a w) = 1) \\<and>\n  (\\<forall>b\\<in>spectrum ?B.\n      ?XB b \\<in> borel_measurable ?M \\<and>\n      (AE w in ?M. 0 \\<le> ?XB b w)) \\<and>\n  (AE w in ?M. (\\<Sum>a\\<in>spectrum ?B. ?XB a w) = 1) \\<and>\n  (\\<forall>a\\<in>spectrum ?A.\n      \\<forall>b\\<in>spectrum ?B.\n         integrable ?M (\\<lambda>w. ?XA a w * ?XB b w) \\<and>\n         LINT w|?M. ?XA a w * ?XB b w =\n         Re (Complex_Matrix.trace\n              (eigen_projector ?A a * eigen_projector ?B b *\n               ?R))) \\<Longrightarrow>\n  AE w in ?M. \\<forall>a\\<in>spectrum ?A. 0 \\<le> ?XA a w\n  prob_space M \\<and>\n  (\\<forall>a\\<in>spectrum A.\n      XA a \\<in> borel_measurable M \\<and>\n      (AE w in M. 0 \\<le> XA a w)) \\<and>\n  (AE w in M. (\\<Sum>a\\<in>spectrum A. XA a w) = 1) \\<and>\n  (\\<forall>b\\<in>spectrum B.\n      XB b \\<in> borel_measurable M \\<and>\n      (AE w in M. 0 \\<le> XB b w)) \\<and>\n  (AE w in M. (\\<Sum>a\\<in>spectrum B. XB a w) = 1) \\<and>\n  (\\<forall>a\\<in>spectrum A.\n      \\<forall>b\\<in>spectrum B.\n         integrable M (\\<lambda>w. XA a w * XB b w) \\<and>\n         LINT w|M. XA a w * XB b w =\n         Re (Complex_Matrix.trace\n              (eigen_projector A a * eigen_projector B b * R)))\n\ngoal (1 subgoal):\n 1. AE w in M. (\\<forall>a\\<in>spectrum A. 0 \\<le> XA a w) \\<and>\n               (\\<Sum>a\\<in>spectrum A. XA a w) = 1", "by simp"], ["proof (state)\nthis:\n  AE w in M. (\\<forall>a\\<in>spectrum A. 0 \\<le> XA a w) \\<and>\n             (\\<Sum>a\\<in>spectrum A. XA a w) = 1\n\ngoal (1 subgoal):\n 1. AE w in M. (\\<forall>a\\<in>spectrum A. 0 \\<le> XA a w) \\<and>\n               (\\<Sum>a\\<in>spectrum A. XA a w) = 1 \\<longrightarrow>\n               (\\<forall>a\\<in>spectrum A. XA a w \\<le> 1)", "show \"AE w in M. (\\<forall>a\\<in>spectrum A. 0 \\<le> XA a w) \\<and> (\\<Sum>a\\<in>spectrum A. XA a w) = 1 \\<longrightarrow> \n    (\\<forall>a\\<in>spectrum A. XA a w \\<le> 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE w in M. (\\<forall>a\\<in>spectrum A. 0 \\<le> XA a w) \\<and>\n               (\\<Sum>a\\<in>spectrum A. XA a w) = 1 \\<longrightarrow>\n               (\\<forall>a\\<in>spectrum A. XA a w \\<le> 1)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<in> space M \\<Longrightarrow>\n       (\\<forall>a\\<in>spectrum A. 0 \\<le> XA a w) \\<and>\n       (\\<Sum>a\\<in>spectrum A. XA a w) = 1 \\<longrightarrow>\n       (\\<forall>a\\<in>spectrum A. XA a w \\<le> 1)", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<in> space M \\<Longrightarrow>\n       (\\<forall>a\\<in>spectrum A. 0 \\<le> XA a w) \\<and>\n       (\\<Sum>a\\<in>spectrum A. XA a w) = 1 \\<longrightarrow>\n       (\\<forall>a\\<in>spectrum A. XA a w \\<le> 1)", "assume \"w\\<in> space M\""], ["proof (state)\nthis:\n  w \\<in> space M\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<in> space M \\<Longrightarrow>\n       (\\<forall>a\\<in>spectrum A. 0 \\<le> XA a w) \\<and>\n       (\\<Sum>a\\<in>spectrum A. XA a w) = 1 \\<longrightarrow>\n       (\\<forall>a\\<in>spectrum A. XA a w \\<le> 1)", "show \"(\\<forall>a\\<in>spectrum A. 0 \\<le> XA a w) \\<and> (\\<Sum>a\\<in>spectrum A. XA a w) = 1 \\<longrightarrow> \n      (\\<forall>a\\<in>spectrum A. XA a w \\<le> 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>spectrum A. 0 \\<le> XA a w) \\<and>\n    (\\<Sum>a\\<in>spectrum A. XA a w) = 1 \\<longrightarrow>\n    (\\<forall>a\\<in>spectrum A. XA a w \\<le> 1)", "proof (rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>spectrum A. 0 \\<le> XA a w) \\<and>\n    (\\<Sum>a\\<in>spectrum A. XA a w) = 1 \\<Longrightarrow>\n    \\<forall>a\\<in>spectrum A. XA a w \\<le> 1", "assume pr: \"(\\<forall>a\\<in>spectrum A. 0 \\<le> XA a w) \\<and> (\\<Sum>a\\<in>spectrum A. XA a w) = 1\""], ["proof (state)\nthis:\n  (\\<forall>a\\<in>spectrum A. 0 \\<le> XA a w) \\<and>\n  (\\<Sum>a\\<in>spectrum A. XA a w) = 1\n\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>spectrum A. 0 \\<le> XA a w) \\<and>\n    (\\<Sum>a\\<in>spectrum A. XA a w) = 1 \\<Longrightarrow>\n    \\<forall>a\\<in>spectrum A. XA a w \\<le> 1", "show \"\\<forall>a\\<in>spectrum A. XA a w \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>spectrum A. XA a w \\<le> 1", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> spectrum A \\<Longrightarrow> XA a w \\<le> 1", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> spectrum A \\<Longrightarrow> XA a w \\<le> 1", "assume \"a\\<in> spectrum A\""], ["proof (state)\nthis:\n  a \\<in> spectrum A\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> spectrum A \\<Longrightarrow> XA a w \\<le> 1", "show \"XA a w \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. XA a w \\<le> 1", "proof (rule pos_sum_1_le[of \"spectrum A\"])"], ["proof (state)\ngoal (4 subgoals):\n 1. finite (spectrum A)\n 2. \\<forall>i\\<in>spectrum A. 0 \\<le> XA i w\n 3. (\\<Sum>i\\<in>spectrum A. XA i w) = 1\n 4. a \\<in> spectrum A", "show \"finite (spectrum A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (spectrum A)", "using spectrum_finite[of A]"], ["proof (prove)\nusing this:\n  finite (spectrum A)\n\ngoal (1 subgoal):\n 1. finite (spectrum A)", "by simp"], ["proof (state)\nthis:\n  finite (spectrum A)\n\ngoal (3 subgoals):\n 1. \\<forall>i\\<in>spectrum A. 0 \\<le> XA i w\n 2. (\\<Sum>i\\<in>spectrum A. XA i w) = 1\n 3. a \\<in> spectrum A", "show \"a \\<in> spectrum A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> spectrum A", "using \\<open>a \\<in> spectrum A\\<close>"], ["proof (prove)\nusing this:\n  a \\<in> spectrum A\n\ngoal (1 subgoal):\n 1. a \\<in> spectrum A", "."], ["proof (state)\nthis:\n  a \\<in> spectrum A\n\ngoal (2 subgoals):\n 1. \\<forall>i\\<in>spectrum A. 0 \\<le> XA i w\n 2. (\\<Sum>i\\<in>spectrum A. XA i w) = 1", "show \" \\<forall>i\\<in>spectrum A. 0 \\<le> XA i w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>spectrum A. 0 \\<le> XA i w", "using pr"], ["proof (prove)\nusing this:\n  (\\<forall>a\\<in>spectrum A. 0 \\<le> XA a w) \\<and>\n  (\\<Sum>a\\<in>spectrum A. XA a w) = 1\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>spectrum A. 0 \\<le> XA i w", "by simp"], ["proof (state)\nthis:\n  \\<forall>i\\<in>spectrum A. 0 \\<le> XA i w\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>spectrum A. XA i w) = 1", "show \"(\\<Sum>i\\<in>spectrum A. XA i w) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>spectrum A. XA i w) = 1", "using pr"], ["proof (prove)\nusing this:\n  (\\<forall>a\\<in>spectrum A. 0 \\<le> XA a w) \\<and>\n  (\\<Sum>a\\<in>spectrum A. XA a w) = 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>spectrum A. XA i w) = 1", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>spectrum A. XA i w) = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  XA a w \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>a\\<in>spectrum A. XA a w \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>a\\<in>spectrum A. 0 \\<le> XA a w) \\<and>\n  (\\<Sum>a\\<in>spectrum A. XA a w) = 1 \\<longrightarrow>\n  (\\<forall>a\\<in>spectrum A. XA a w \\<le> 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  AE w in M. (\\<forall>a\\<in>spectrum A. 0 \\<le> XA a w) \\<and>\n             (\\<Sum>a\\<in>spectrum A. XA a w) = 1 \\<longrightarrow>\n             (\\<forall>a\\<in>spectrum A. XA a w \\<le> 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in cpx_sq_mat) lhv_posr:\n  assumes \"lhv M A B R XA XB\"\n  shows \"AE w in M. (\\<forall> b \\<in> spectrum B. 0 \\<le> XB b w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE w in M. \\<forall>b\\<in>spectrum B. 0 \\<le> XB b w", "proof (rule AE_ball_countable[THEN iffD2])"], ["proof (state)\ngoal (2 subgoals):\n 1. countable (spectrum B)\n 2. \\<forall>b\\<in>spectrum B. AE w in M. 0 \\<le> XB b w", "show \"countable (spectrum B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable (spectrum B)", "using spectrum_finite[of B]"], ["proof (prove)\nusing this:\n  finite (spectrum B)\n\ngoal (1 subgoal):\n 1. countable (spectrum B)", "by (simp add: countable_finite)"], ["proof (state)\nthis:\n  countable (spectrum B)\n\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>spectrum B. AE w in M. 0 \\<le> XB b w", "show \"\\<forall>b\\<in>spectrum B. AE w in M. 0 \\<le> XB b w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>spectrum B. AE w in M. 0 \\<le> XB b w", "using assms"], ["proof (prove)\nusing this:\n  lhv M A B R XA XB\n\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>spectrum B. AE w in M. 0 \\<le> XB b w", "unfolding lhv_def pos_rv_def"], ["proof (prove)\nusing this:\n  prob_space M \\<and>\n  (\\<forall>a\\<in>spectrum A.\n      XA a \\<in> borel_measurable M \\<and>\n      (AE w in M. 0 \\<le> XA a w)) \\<and>\n  prv_sum M A XA \\<and>\n  (\\<forall>b\\<in>spectrum B.\n      XB b \\<in> borel_measurable M \\<and>\n      (AE w in M. 0 \\<le> XB b w)) \\<and>\n  prv_sum M B XB \\<and>\n  (\\<forall>a\\<in>spectrum A.\n      \\<forall>b\\<in>spectrum B.\n         integrable M (\\<lambda>w. XA a w * XB b w) \\<and>\n         LINT w|M. XA a w * XB b w =\n         Re (Complex_Matrix.trace\n              (eigen_projector A a * eigen_projector B b * R)))\n\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>spectrum B. AE w in M. 0 \\<le> XB b w", "by simp"], ["proof (state)\nthis:\n  \\<forall>b\\<in>spectrum B. AE w in M. 0 \\<le> XB b w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in cpx_sq_mat) lhv_lt1_r:\n  assumes \"lhv M A B R XA XB\"\n  shows \"AE w in M. (\\<forall> a \\<in> spectrum B. XB a w \\<le> 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE w in M. \\<forall>a\\<in>spectrum B. XB a w \\<le> 1", "proof (rule AE_mp)"], ["proof (state)\ngoal (2 subgoals):\n 1. almost_everywhere M ?P\n 2. AE w in M. ?P w \\<longrightarrow>\n               (\\<forall>a\\<in>spectrum B. XB a w \\<le> 1)", "show \"AE w in M. (\\<forall> a \\<in> spectrum B. 0 \\<le> XB a w) \\<and> (\\<Sum> a\\<in> spectrum B. XB a w) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE w in M. (\\<forall>a\\<in>spectrum B. 0 \\<le> XB a w) \\<and>\n               (\\<Sum>a\\<in>spectrum B. XB a w) = 1", "using lhv_posr assms"], ["proof (prove)\nusing this:\n  lhv ?M ?A ?B ?R ?XA ?XB \\<Longrightarrow>\n  AE w in ?M. \\<forall>b\\<in>spectrum ?B. 0 \\<le> ?XB b w\n  lhv M A B R XA XB\n\ngoal (1 subgoal):\n 1. AE w in M. (\\<forall>a\\<in>spectrum B. 0 \\<le> XB a w) \\<and>\n               (\\<Sum>a\\<in>spectrum B. XB a w) = 1", "unfolding lhv_def prv_sum_def pos_rv_def"], ["proof (prove)\nusing this:\n  prob_space ?M \\<and>\n  (\\<forall>a\\<in>spectrum ?A.\n      ?XA a \\<in> borel_measurable ?M \\<and>\n      (AE w in ?M. 0 \\<le> ?XA a w)) \\<and>\n  (AE w in ?M. (\\<Sum>a\\<in>spectrum ?A. ?XA a w) = 1) \\<and>\n  (\\<forall>b\\<in>spectrum ?B.\n      ?XB b \\<in> borel_measurable ?M \\<and>\n      (AE w in ?M. 0 \\<le> ?XB b w)) \\<and>\n  (AE w in ?M. (\\<Sum>a\\<in>spectrum ?B. ?XB a w) = 1) \\<and>\n  (\\<forall>a\\<in>spectrum ?A.\n      \\<forall>b\\<in>spectrum ?B.\n         integrable ?M (\\<lambda>w. ?XA a w * ?XB b w) \\<and>\n         LINT w|?M. ?XA a w * ?XB b w =\n         Re (Complex_Matrix.trace\n              (eigen_projector ?A a * eigen_projector ?B b *\n               ?R))) \\<Longrightarrow>\n  AE w in ?M. \\<forall>b\\<in>spectrum ?B. 0 \\<le> ?XB b w\n  prob_space M \\<and>\n  (\\<forall>a\\<in>spectrum A.\n      XA a \\<in> borel_measurable M \\<and>\n      (AE w in M. 0 \\<le> XA a w)) \\<and>\n  (AE w in M. (\\<Sum>a\\<in>spectrum A. XA a w) = 1) \\<and>\n  (\\<forall>b\\<in>spectrum B.\n      XB b \\<in> borel_measurable M \\<and>\n      (AE w in M. 0 \\<le> XB b w)) \\<and>\n  (AE w in M. (\\<Sum>a\\<in>spectrum B. XB a w) = 1) \\<and>\n  (\\<forall>a\\<in>spectrum A.\n      \\<forall>b\\<in>spectrum B.\n         integrable M (\\<lambda>w. XA a w * XB b w) \\<and>\n         LINT w|M. XA a w * XB b w =\n         Re (Complex_Matrix.trace\n              (eigen_projector A a * eigen_projector B b * R)))\n\ngoal (1 subgoal):\n 1. AE w in M. (\\<forall>a\\<in>spectrum B. 0 \\<le> XB a w) \\<and>\n               (\\<Sum>a\\<in>spectrum B. XB a w) = 1", "by simp"], ["proof (state)\nthis:\n  AE w in M. (\\<forall>a\\<in>spectrum B. 0 \\<le> XB a w) \\<and>\n             (\\<Sum>a\\<in>spectrum B. XB a w) = 1\n\ngoal (1 subgoal):\n 1. AE w in M. (\\<forall>a\\<in>spectrum B. 0 \\<le> XB a w) \\<and>\n               (\\<Sum>a\\<in>spectrum B. XB a w) = 1 \\<longrightarrow>\n               (\\<forall>a\\<in>spectrum B. XB a w \\<le> 1)", "show \"AE w in M. (\\<forall>a\\<in>spectrum B. 0 \\<le> XB a w) \\<and> (\\<Sum>a\\<in>spectrum B. XB a w) = 1 \\<longrightarrow> \n    (\\<forall>a\\<in>spectrum B. XB a w \\<le> 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE w in M. (\\<forall>a\\<in>spectrum B. 0 \\<le> XB a w) \\<and>\n               (\\<Sum>a\\<in>spectrum B. XB a w) = 1 \\<longrightarrow>\n               (\\<forall>a\\<in>spectrum B. XB a w \\<le> 1)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<in> space M \\<Longrightarrow>\n       (\\<forall>a\\<in>spectrum B. 0 \\<le> XB a w) \\<and>\n       (\\<Sum>a\\<in>spectrum B. XB a w) = 1 \\<longrightarrow>\n       (\\<forall>a\\<in>spectrum B. XB a w \\<le> 1)", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<in> space M \\<Longrightarrow>\n       (\\<forall>a\\<in>spectrum B. 0 \\<le> XB a w) \\<and>\n       (\\<Sum>a\\<in>spectrum B. XB a w) = 1 \\<longrightarrow>\n       (\\<forall>a\\<in>spectrum B. XB a w \\<le> 1)", "assume \"w\\<in> space M\""], ["proof (state)\nthis:\n  w \\<in> space M\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<in> space M \\<Longrightarrow>\n       (\\<forall>a\\<in>spectrum B. 0 \\<le> XB a w) \\<and>\n       (\\<Sum>a\\<in>spectrum B. XB a w) = 1 \\<longrightarrow>\n       (\\<forall>a\\<in>spectrum B. XB a w \\<le> 1)", "show \"(\\<forall>a\\<in>spectrum B. 0 \\<le> XB a w) \\<and> (\\<Sum>a\\<in>spectrum B. XB a w) = 1 \\<longrightarrow> \n      (\\<forall>a\\<in>spectrum B. XB a w \\<le> 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>spectrum B. 0 \\<le> XB a w) \\<and>\n    (\\<Sum>a\\<in>spectrum B. XB a w) = 1 \\<longrightarrow>\n    (\\<forall>a\\<in>spectrum B. XB a w \\<le> 1)", "proof (rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>spectrum B. 0 \\<le> XB a w) \\<and>\n    (\\<Sum>a\\<in>spectrum B. XB a w) = 1 \\<Longrightarrow>\n    \\<forall>a\\<in>spectrum B. XB a w \\<le> 1", "assume pr: \"(\\<forall>a\\<in>spectrum B. 0 \\<le> XB a w) \\<and> (\\<Sum>a\\<in>spectrum B. XB a w) = 1\""], ["proof (state)\nthis:\n  (\\<forall>a\\<in>spectrum B. 0 \\<le> XB a w) \\<and>\n  (\\<Sum>a\\<in>spectrum B. XB a w) = 1\n\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>spectrum B. 0 \\<le> XB a w) \\<and>\n    (\\<Sum>a\\<in>spectrum B. XB a w) = 1 \\<Longrightarrow>\n    \\<forall>a\\<in>spectrum B. XB a w \\<le> 1", "show \"\\<forall>a\\<in>spectrum B. XB a w \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>spectrum B. XB a w \\<le> 1", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> spectrum B \\<Longrightarrow> XB a w \\<le> 1", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> spectrum B \\<Longrightarrow> XB a w \\<le> 1", "assume \"a\\<in> spectrum B\""], ["proof (state)\nthis:\n  a \\<in> spectrum B\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> spectrum B \\<Longrightarrow> XB a w \\<le> 1", "show \"XB a w \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. XB a w \\<le> 1", "proof (rule pos_sum_1_le[of \"spectrum B\"])"], ["proof (state)\ngoal (4 subgoals):\n 1. finite (spectrum B)\n 2. \\<forall>i\\<in>spectrum B. 0 \\<le> XB i w\n 3. (\\<Sum>i\\<in>spectrum B. XB i w) = 1\n 4. a \\<in> spectrum B", "show \"finite (spectrum B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (spectrum B)", "using spectrum_finite[of B]"], ["proof (prove)\nusing this:\n  finite (spectrum B)\n\ngoal (1 subgoal):\n 1. finite (spectrum B)", "by simp"], ["proof (state)\nthis:\n  finite (spectrum B)\n\ngoal (3 subgoals):\n 1. \\<forall>i\\<in>spectrum B. 0 \\<le> XB i w\n 2. (\\<Sum>i\\<in>spectrum B. XB i w) = 1\n 3. a \\<in> spectrum B", "show \"a \\<in> spectrum B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> spectrum B", "using \\<open>a \\<in> spectrum B\\<close>"], ["proof (prove)\nusing this:\n  a \\<in> spectrum B\n\ngoal (1 subgoal):\n 1. a \\<in> spectrum B", "."], ["proof (state)\nthis:\n  a \\<in> spectrum B\n\ngoal (2 subgoals):\n 1. \\<forall>i\\<in>spectrum B. 0 \\<le> XB i w\n 2. (\\<Sum>i\\<in>spectrum B. XB i w) = 1", "show \" \\<forall>i\\<in>spectrum B. 0 \\<le> XB i w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>spectrum B. 0 \\<le> XB i w", "using pr"], ["proof (prove)\nusing this:\n  (\\<forall>a\\<in>spectrum B. 0 \\<le> XB a w) \\<and>\n  (\\<Sum>a\\<in>spectrum B. XB a w) = 1\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>spectrum B. 0 \\<le> XB i w", "by simp"], ["proof (state)\nthis:\n  \\<forall>i\\<in>spectrum B. 0 \\<le> XB i w\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>spectrum B. XB i w) = 1", "show \"(\\<Sum>i\\<in>spectrum B. XB i w) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>spectrum B. XB i w) = 1", "using pr"], ["proof (prove)\nusing this:\n  (\\<forall>a\\<in>spectrum B. 0 \\<le> XB a w) \\<and>\n  (\\<Sum>a\\<in>spectrum B. XB a w) = 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>spectrum B. XB i w) = 1", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>spectrum B. XB i w) = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  XB a w \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>a\\<in>spectrum B. XB a w \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>a\\<in>spectrum B. 0 \\<le> XB a w) \\<and>\n  (\\<Sum>a\\<in>spectrum B. XB a w) = 1 \\<longrightarrow>\n  (\\<forall>a\\<in>spectrum B. XB a w \\<le> 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  AE w in M. (\\<forall>a\\<in>spectrum B. 0 \\<le> XB a w) \\<and>\n             (\\<Sum>a\\<in>spectrum B. XB a w) = 1 \\<longrightarrow>\n             (\\<forall>a\\<in>spectrum B. XB a w \\<le> 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in cpx_sq_mat) lhv_AE_propl:\n  assumes \"lhv M A B R XA XB\"\n  shows \"AE w in M. (\\<forall> a \\<in> spectrum A. 0 \\<le> XA a w \\<and> XA a w \\<le> 1) \\<and> (\\<Sum> a\\<in> spectrum A. XA a w) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE w in M. (\\<forall>a\\<in>spectrum A.\n                   0 \\<le> XA a w \\<and> XA a w \\<le> 1) \\<and>\n               (\\<Sum>a\\<in>spectrum A. XA a w) = 1", "proof (rule AE_conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. AE w in M. \\<forall>a\\<in>spectrum A.\n                  0 \\<le> XA a w \\<and> XA a w \\<le> 1\n 2. AE w in M. (\\<Sum>a\\<in>spectrum A. XA a w) = 1", "show \"AE w in M. \\<forall>a\\<in>spectrum A. 0 \\<le> XA a w \\<and> XA a w \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE w in M. \\<forall>a\\<in>spectrum A.\n                  0 \\<le> XA a w \\<and> XA a w \\<le> 1", "proof (rule AE_mp)"], ["proof (state)\ngoal (2 subgoals):\n 1. almost_everywhere M ?P\n 2. AE w in M. ?P w \\<longrightarrow>\n               (\\<forall>a\\<in>spectrum A.\n                   0 \\<le> XA a w \\<and> XA a w \\<le> 1)", "show \"AE w in M. (\\<forall> a \\<in> spectrum A. 0 \\<le> XA a w) \\<and> (\\<forall> a \\<in> spectrum A. XA a w \\<le> 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE w in M. (\\<forall>a\\<in>spectrum A. 0 \\<le> XA a w) \\<and>\n               (\\<forall>a\\<in>spectrum A. XA a w \\<le> 1)", "using assms lhv_posl[of M A] lhv_lt1_l[of M A]"], ["proof (prove)\nusing this:\n  lhv M A B R XA XB\n  lhv M A ?B ?R ?XA ?XB \\<Longrightarrow>\n  AE w in M. \\<forall>a\\<in>spectrum A. 0 \\<le> ?XA a w\n  lhv M A ?B ?R ?XA ?XB \\<Longrightarrow>\n  AE w in M. \\<forall>a\\<in>spectrum A. ?XA a w \\<le> 1\n\ngoal (1 subgoal):\n 1. AE w in M. (\\<forall>a\\<in>spectrum A. 0 \\<le> XA a w) \\<and>\n               (\\<forall>a\\<in>spectrum A. XA a w \\<le> 1)", "by simp"], ["proof (state)\nthis:\n  AE w in M. (\\<forall>a\\<in>spectrum A. 0 \\<le> XA a w) \\<and>\n             (\\<forall>a\\<in>spectrum A. XA a w \\<le> 1)\n\ngoal (1 subgoal):\n 1. AE w in M. (\\<forall>a\\<in>spectrum A. 0 \\<le> XA a w) \\<and>\n               (\\<forall>a\\<in>spectrum A. XA a w \\<le> 1) \\<longrightarrow>\n               (\\<forall>a\\<in>spectrum A.\n                   0 \\<le> XA a w \\<and> XA a w \\<le> 1)", "show \"AE w in M. (\\<forall>a\\<in>spectrum A. 0 \\<le> XA a w) \\<and> (\\<forall>a\\<in>spectrum A. XA a w \\<le> 1) \\<longrightarrow>\n               (\\<forall>a\\<in>spectrum A. 0 \\<le> XA a w \\<and> XA a w \\<le> 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE w in M. (\\<forall>a\\<in>spectrum A. 0 \\<le> XA a w) \\<and>\n               (\\<forall>a\\<in>spectrum A. XA a w \\<le> 1) \\<longrightarrow>\n               (\\<forall>a\\<in>spectrum A.\n                   0 \\<le> XA a w \\<and> XA a w \\<le> 1)", "by auto"], ["proof (state)\nthis:\n  AE w in M. (\\<forall>a\\<in>spectrum A. 0 \\<le> XA a w) \\<and>\n             (\\<forall>a\\<in>spectrum A. XA a w \\<le> 1) \\<longrightarrow>\n             (\\<forall>a\\<in>spectrum A.\n                 0 \\<le> XA a w \\<and> XA a w \\<le> 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  AE w in M. \\<forall>a\\<in>spectrum A. 0 \\<le> XA a w \\<and> XA a w \\<le> 1\n\ngoal (1 subgoal):\n 1. AE w in M. (\\<Sum>a\\<in>spectrum A. XA a w) = 1", "show \"AE w in M. (\\<Sum>a\\<in>spectrum A. XA a w) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE w in M. (\\<Sum>a\\<in>spectrum A. XA a w) = 1", "using assms"], ["proof (prove)\nusing this:\n  lhv M A B R XA XB\n\ngoal (1 subgoal):\n 1. AE w in M. (\\<Sum>a\\<in>spectrum A. XA a w) = 1", "unfolding lhv_def prv_sum_def"], ["proof (prove)\nusing this:\n  prob_space M \\<and>\n  (\\<forall>a\\<in>spectrum A. pos_rv M (XA a)) \\<and>\n  (AE w in M. (\\<Sum>a\\<in>spectrum A. XA a w) = 1) \\<and>\n  (\\<forall>b\\<in>spectrum B. pos_rv M (XB b)) \\<and>\n  (AE w in M. (\\<Sum>a\\<in>spectrum B. XB a w) = 1) \\<and>\n  (\\<forall>a\\<in>spectrum A.\n      \\<forall>b\\<in>spectrum B.\n         integrable M (\\<lambda>w. XA a w * XB b w) \\<and>\n         LINT w|M. XA a w * XB b w =\n         Re (Complex_Matrix.trace\n              (eigen_projector A a * eigen_projector B b * R)))\n\ngoal (1 subgoal):\n 1. AE w in M. (\\<Sum>a\\<in>spectrum A. XA a w) = 1", "by simp"], ["proof (state)\nthis:\n  AE w in M. (\\<Sum>a\\<in>spectrum A. XA a w) = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in cpx_sq_mat) lhv_AE_propr:\n  assumes \"lhv M A B R XA XB\"\n  shows \"AE w in M. (\\<forall> a \\<in> spectrum B. 0 \\<le> XB a w \\<and> XB a w \\<le> 1) \\<and> (\\<Sum> a\\<in> spectrum B. XB a w) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE w in M. (\\<forall>a\\<in>spectrum B.\n                   0 \\<le> XB a w \\<and> XB a w \\<le> 1) \\<and>\n               (\\<Sum>a\\<in>spectrum B. XB a w) = 1", "proof (rule AE_conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. AE w in M. \\<forall>a\\<in>spectrum B.\n                  0 \\<le> XB a w \\<and> XB a w \\<le> 1\n 2. AE w in M. (\\<Sum>a\\<in>spectrum B. XB a w) = 1", "show \"AE w in M. \\<forall>a\\<in>spectrum B. 0 \\<le> XB a w \\<and> XB a w \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE w in M. \\<forall>a\\<in>spectrum B.\n                  0 \\<le> XB a w \\<and> XB a w \\<le> 1", "proof (rule AE_mp)"], ["proof (state)\ngoal (2 subgoals):\n 1. almost_everywhere M ?P\n 2. AE w in M. ?P w \\<longrightarrow>\n               (\\<forall>a\\<in>spectrum B.\n                   0 \\<le> XB a w \\<and> XB a w \\<le> 1)", "show \"AE w in M. (\\<forall> a \\<in> spectrum B. 0 \\<le> XB a w) \\<and> (\\<forall> a \\<in> spectrum B. XB a w \\<le> 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE w in M. (\\<forall>a\\<in>spectrum B. 0 \\<le> XB a w) \\<and>\n               (\\<forall>a\\<in>spectrum B. XB a w \\<le> 1)", "using assms lhv_posr[of M _ B] lhv_lt1_r[of M _ B]"], ["proof (prove)\nusing this:\n  lhv M A B R XA XB\n  lhv M ?A B ?R ?XA ?XB \\<Longrightarrow>\n  AE w in M. \\<forall>b\\<in>spectrum B. 0 \\<le> ?XB b w\n  lhv M ?A B ?R ?XA ?XB \\<Longrightarrow>\n  AE w in M. \\<forall>a\\<in>spectrum B. ?XB a w \\<le> 1\n\ngoal (1 subgoal):\n 1. AE w in M. (\\<forall>a\\<in>spectrum B. 0 \\<le> XB a w) \\<and>\n               (\\<forall>a\\<in>spectrum B. XB a w \\<le> 1)", "by simp"], ["proof (state)\nthis:\n  AE w in M. (\\<forall>a\\<in>spectrum B. 0 \\<le> XB a w) \\<and>\n             (\\<forall>a\\<in>spectrum B. XB a w \\<le> 1)\n\ngoal (1 subgoal):\n 1. AE w in M. (\\<forall>a\\<in>spectrum B. 0 \\<le> XB a w) \\<and>\n               (\\<forall>a\\<in>spectrum B. XB a w \\<le> 1) \\<longrightarrow>\n               (\\<forall>a\\<in>spectrum B.\n                   0 \\<le> XB a w \\<and> XB a w \\<le> 1)", "show \"AE w in M. (\\<forall>a\\<in>spectrum B. 0 \\<le> XB a w) \\<and> (\\<forall>a\\<in>spectrum B. XB a w \\<le> 1) \\<longrightarrow>\n               (\\<forall>a\\<in>spectrum B. 0 \\<le> XB a w \\<and> XB a w \\<le> 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE w in M. (\\<forall>a\\<in>spectrum B. 0 \\<le> XB a w) \\<and>\n               (\\<forall>a\\<in>spectrum B. XB a w \\<le> 1) \\<longrightarrow>\n               (\\<forall>a\\<in>spectrum B.\n                   0 \\<le> XB a w \\<and> XB a w \\<le> 1)", "by auto"], ["proof (state)\nthis:\n  AE w in M. (\\<forall>a\\<in>spectrum B. 0 \\<le> XB a w) \\<and>\n             (\\<forall>a\\<in>spectrum B. XB a w \\<le> 1) \\<longrightarrow>\n             (\\<forall>a\\<in>spectrum B.\n                 0 \\<le> XB a w \\<and> XB a w \\<le> 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  AE w in M. \\<forall>a\\<in>spectrum B. 0 \\<le> XB a w \\<and> XB a w \\<le> 1\n\ngoal (1 subgoal):\n 1. AE w in M. (\\<Sum>a\\<in>spectrum B. XB a w) = 1", "show \"AE w in M. (\\<Sum>a\\<in>spectrum B. XB a w) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE w in M. (\\<Sum>a\\<in>spectrum B. XB a w) = 1", "using assms"], ["proof (prove)\nusing this:\n  lhv M A B R XA XB\n\ngoal (1 subgoal):\n 1. AE w in M. (\\<Sum>a\\<in>spectrum B. XB a w) = 1", "unfolding lhv_def prv_sum_def"], ["proof (prove)\nusing this:\n  prob_space M \\<and>\n  (\\<forall>a\\<in>spectrum A. pos_rv M (XA a)) \\<and>\n  (AE w in M. (\\<Sum>a\\<in>spectrum A. XA a w) = 1) \\<and>\n  (\\<forall>b\\<in>spectrum B. pos_rv M (XB b)) \\<and>\n  (AE w in M. (\\<Sum>a\\<in>spectrum B. XB a w) = 1) \\<and>\n  (\\<forall>a\\<in>spectrum A.\n      \\<forall>b\\<in>spectrum B.\n         integrable M (\\<lambda>w. XA a w * XB b w) \\<and>\n         LINT w|M. XA a w * XB b w =\n         Re (Complex_Matrix.trace\n              (eigen_projector A a * eigen_projector B b * R)))\n\ngoal (1 subgoal):\n 1. AE w in M. (\\<Sum>a\\<in>spectrum B. XB a w) = 1", "by simp"], ["proof (state)\nthis:\n  AE w in M. (\\<Sum>a\\<in>spectrum B. XB a w) = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in cpx_sq_mat) lhv_integral_eq:\n  fixes c::real\n  assumes \"lhv M A B R XA XB\"\n  and \"a\\<in> spectrum A\"\nand \"b\\<in> spectrum B\"\nshows \"integral\\<^sup>L M (\\<lambda>w. XA a w * XB b w) = \n  Re (Complex_Matrix.trace(eigen_projector A a * (eigen_projector B b) * R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT w|M. XA a w * XB b w =\n    Re (Complex_Matrix.trace\n         (eigen_projector A a * eigen_projector B b * R))", "using assms"], ["proof (prove)\nusing this:\n  lhv M A B R XA XB\n  a \\<in> spectrum A\n  b \\<in> spectrum B\n\ngoal (1 subgoal):\n 1. LINT w|M. XA a w * XB b w =\n    Re (Complex_Matrix.trace\n         (eigen_projector A a * eigen_projector B b * R))", "unfolding lhv_def"], ["proof (prove)\nusing this:\n  prob_space M \\<and>\n  (\\<forall>a\\<in>spectrum A. pos_rv M (XA a)) \\<and>\n  prv_sum M A XA \\<and>\n  (\\<forall>b\\<in>spectrum B. pos_rv M (XB b)) \\<and>\n  prv_sum M B XB \\<and>\n  (\\<forall>a\\<in>spectrum A.\n      \\<forall>b\\<in>spectrum B.\n         integrable M (\\<lambda>w. XA a w * XB b w) \\<and>\n         LINT w|M. XA a w * XB b w =\n         Re (Complex_Matrix.trace\n              (eigen_projector A a * eigen_projector B b * R)))\n  a \\<in> spectrum A\n  b \\<in> spectrum B\n\ngoal (1 subgoal):\n 1. LINT w|M. XA a w * XB b w =\n    Re (Complex_Matrix.trace\n         (eigen_projector A a * eigen_projector B b * R))", "by simp"], ["", "lemma (in cpx_sq_mat) lhv_integrable:\n  fixes c::real\n  assumes \"lhv M A B R XA XB\"\n  and \"a\\<in> spectrum A\"\nand \"b\\<in> spectrum B\"\nshows \"integrable M (\\<lambda>w. XA a w * XB b w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integrable M (\\<lambda>w. XA a w * XB b w)", "using assms"], ["proof (prove)\nusing this:\n  lhv M A B R XA XB\n  a \\<in> spectrum A\n  b \\<in> spectrum B\n\ngoal (1 subgoal):\n 1. integrable M (\\<lambda>w. XA a w * XB b w)", "unfolding lhv_def"], ["proof (prove)\nusing this:\n  prob_space M \\<and>\n  (\\<forall>a\\<in>spectrum A. pos_rv M (XA a)) \\<and>\n  prv_sum M A XA \\<and>\n  (\\<forall>b\\<in>spectrum B. pos_rv M (XB b)) \\<and>\n  prv_sum M B XB \\<and>\n  (\\<forall>a\\<in>spectrum A.\n      \\<forall>b\\<in>spectrum B.\n         integrable M (\\<lambda>w. XA a w * XB b w) \\<and>\n         LINT w|M. XA a w * XB b w =\n         Re (Complex_Matrix.trace\n              (eigen_projector A a * eigen_projector B b * R)))\n  a \\<in> spectrum A\n  b \\<in> spectrum B\n\ngoal (1 subgoal):\n 1. integrable M (\\<lambda>w. XA a w * XB b w)", "by simp"], ["", "lemma (in cpx_sq_mat) lhv_scal_integrable:\n  fixes c::real\n  assumes \"lhv M A B R XA XB\"\n  and \"a\\<in> spectrum A\"\nand \"b\\<in> spectrum B\"\nshows \"integrable M (\\<lambda>w. c *XA a w * d * XB b w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integrable M (\\<lambda>w. c * XA a w * d * XB b w)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. integrable M (\\<lambda>w. c * XA a w * d * XB b w)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. integrable M (\\<lambda>w. c * XA a w * d * XB b w)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. integrable M (\\<lambda>w. c * XA a w * d * XB b w)", "assume \"x\\<in> space M\""], ["proof (state)\nthis:\n  x \\<in> space M\n\ngoal (1 subgoal):\n 1. integrable M (\\<lambda>w. c * XA a w * d * XB b w)", "have \"c * d * (XA a x * XB b x) = c * XA a x * d * XB b x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * d * (XA a x * XB b x) = c * XA a x * d * XB b x", "by simp"], ["proof (state)\nthis:\n  c * d * (XA a x * XB b x) = c * XA a x * d * XB b x\n\ngoal (1 subgoal):\n 1. integrable M (\\<lambda>w. c * XA a w * d * XB b w)", "}"], ["proof (state)\nthis:\n  ?x5 \\<in> space M \\<Longrightarrow>\n  c * d * (XA a ?x5 * XB b ?x5) = c * XA a ?x5 * d * XB b ?x5\n\ngoal (1 subgoal):\n 1. integrable M (\\<lambda>w. c * XA a w * d * XB b w)", "note eq = this"], ["proof (state)\nthis:\n  ?x5 \\<in> space M \\<Longrightarrow>\n  c * d * (XA a ?x5 * XB b ?x5) = c * XA a ?x5 * d * XB b ?x5\n\ngoal (1 subgoal):\n 1. integrable M (\\<lambda>w. c * XA a w * d * XB b w)", "have \"integrable M (\\<lambda>w. XA a w * XB b w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integrable M (\\<lambda>w. XA a w * XB b w)", "using assms"], ["proof (prove)\nusing this:\n  lhv M A B R XA XB\n  a \\<in> spectrum A\n  b \\<in> spectrum B\n\ngoal (1 subgoal):\n 1. integrable M (\\<lambda>w. XA a w * XB b w)", "unfolding lhv_def"], ["proof (prove)\nusing this:\n  prob_space M \\<and>\n  (\\<forall>a\\<in>spectrum A. pos_rv M (XA a)) \\<and>\n  prv_sum M A XA \\<and>\n  (\\<forall>b\\<in>spectrum B. pos_rv M (XB b)) \\<and>\n  prv_sum M B XB \\<and>\n  (\\<forall>a\\<in>spectrum A.\n      \\<forall>b\\<in>spectrum B.\n         integrable M (\\<lambda>w. XA a w * XB b w) \\<and>\n         LINT w|M. XA a w * XB b w =\n         Re (Complex_Matrix.trace\n              (eigen_projector A a * eigen_projector B b * R)))\n  a \\<in> spectrum A\n  b \\<in> spectrum B\n\ngoal (1 subgoal):\n 1. integrable M (\\<lambda>w. XA a w * XB b w)", "by simp"], ["proof (state)\nthis:\n  integrable M (\\<lambda>w. XA a w * XB b w)\n\ngoal (1 subgoal):\n 1. integrable M (\\<lambda>w. c * XA a w * d * XB b w)", "hence g:\"integrable M (\\<lambda>w. c * d * (XA a w * XB b w))\""], ["proof (prove)\nusing this:\n  integrable M (\\<lambda>w. XA a w * XB b w)\n\ngoal (1 subgoal):\n 1. integrable M (\\<lambda>w. c * d * (XA a w * XB b w))", "using integrable_real_mult_right"], ["proof (prove)\nusing this:\n  integrable M (\\<lambda>w. XA a w * XB b w)\n  integrable ?M ?f \\<Longrightarrow> integrable ?M (\\<lambda>w. ?c * ?f w)\n\ngoal (1 subgoal):\n 1. integrable M (\\<lambda>w. c * d * (XA a w * XB b w))", "by simp"], ["proof (state)\nthis:\n  integrable M (\\<lambda>w. c * d * (XA a w * XB b w))\n\ngoal (1 subgoal):\n 1. integrable M (\\<lambda>w. c * XA a w * d * XB b w)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. integrable M (\\<lambda>w. c * XA a w * d * XB b w)", "proof (rule Bochner_Integration.integrable_cong[THEN iffD2], simp)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> space M \\<Longrightarrow> c * XA a x * d * XB b x = ?g1 x\n 2. integrable M ?g1", "show \"integrable M (\\<lambda>w. c * d * (XA a w * XB b w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integrable M (\\<lambda>w. c * d * (XA a w * XB b w))", "using g"], ["proof (prove)\nusing this:\n  integrable M (\\<lambda>w. c * d * (XA a w * XB b w))\n\ngoal (1 subgoal):\n 1. integrable M (\\<lambda>w. c * d * (XA a w * XB b w))", "."], ["proof (state)\nthis:\n  integrable M (\\<lambda>w. c * d * (XA a w * XB b w))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space M \\<Longrightarrow>\n       c * XA a x * d * XB b x = c * d * (XA a x * XB b x)", "show \"\\<And>x. x \\<in> space M \\<Longrightarrow> c * XA a x * d * XB b x = c * d * (XA a x * XB b x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space M \\<Longrightarrow>\n       c * XA a x * d * XB b x = c * d * (XA a x * XB b x)", "using eq"], ["proof (prove)\nusing this:\n  ?x5 \\<in> space M \\<Longrightarrow>\n  c * d * (XA a ?x5 * XB b ?x5) = c * XA a ?x5 * d * XB b ?x5\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space M \\<Longrightarrow>\n       c * XA a x * d * XB b x = c * d * (XA a x * XB b x)", "by simp"], ["proof (state)\nthis:\n  ?x3 \\<in> space M \\<Longrightarrow>\n  c * XA a ?x3 * d * XB b ?x3 = c * d * (XA a ?x3 * XB b ?x3)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  integrable M (\\<lambda>w. c * XA a w * d * XB b w)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in cpx_sq_mat) lhv_lsum_scal_integrable:\n  assumes \"lhv M A B R XA XB\"\n  and  \"a\\<in> spectrum A\"\nshows \"integrable M (\\<lambda>x. \\<Sum>b\\<in>spectrum B. c * XA a x * (f b) * XB b x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integrable M\n     (\\<lambda>x. \\<Sum>b\\<in>spectrum B. c * XA a x * f b * XB b x)", "proof (rule Bochner_Integration.integrable_sum)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> spectrum B \\<Longrightarrow>\n       integrable M (\\<lambda>x. c * XA a x * f b * XB b x)", "fix b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> spectrum B \\<Longrightarrow>\n       integrable M (\\<lambda>x. c * XA a x * f b * XB b x)", "assume \"b\\<in> spectrum B\""], ["proof (state)\nthis:\n  b \\<in> spectrum B\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> spectrum B \\<Longrightarrow>\n       integrable M (\\<lambda>x. c * XA a x * f b * XB b x)", "thus \"integrable M (\\<lambda>x. c * XA a x * f b *XB b x)\""], ["proof (prove)\nusing this:\n  b \\<in> spectrum B\n\ngoal (1 subgoal):\n 1. integrable M (\\<lambda>x. c * XA a x * f b * XB b x)", "using \\<open>a\\<in> spectrum A\\<close> assms \n    lhv_scal_integrable[of M]"], ["proof (prove)\nusing this:\n  b \\<in> spectrum B\n  a \\<in> spectrum A\n  lhv M A B R XA XB\n  a \\<in> spectrum A\n  \\<lbrakk>lhv M ?A ?B ?R ?XA ?XB; ?a \\<in> spectrum ?A;\n   ?b \\<in> spectrum ?B\\<rbrakk>\n  \\<Longrightarrow> integrable M (\\<lambda>w. ?c * ?XA ?a w * ?d * ?XB ?b w)\n\ngoal (1 subgoal):\n 1. integrable M (\\<lambda>x. c * XA a x * f b * XB b x)", "by simp"], ["proof (state)\nthis:\n  integrable M (\\<lambda>x. c * XA a x * f b * XB b x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in cpx_sq_mat) lhv_sum_integrable:\n  assumes \"lhv M A B R XA XB\"\nshows \"integrable M (\\<lambda>w.  (\\<Sum> a \\<in> spectrum A. (\\<Sum> b \\<in> spectrum B. f a * XA a w * g b * XB b w)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integrable M\n     (\\<lambda>w.\n         \\<Sum>a\\<in>spectrum A.\n           \\<Sum>b\\<in>spectrum B. f a * XA a w * g b * XB b w)", "proof (rule Bochner_Integration.integrable_sum)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> spectrum A \\<Longrightarrow>\n       integrable M\n        (\\<lambda>x. \\<Sum>b\\<in>spectrum B. f a * XA a x * g b * XB b x)", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> spectrum A \\<Longrightarrow>\n       integrable M\n        (\\<lambda>x. \\<Sum>b\\<in>spectrum B. f a * XA a x * g b * XB b x)", "assume \"a\\<in> spectrum A\""], ["proof (state)\nthis:\n  a \\<in> spectrum A\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> spectrum A \\<Longrightarrow>\n       integrable M\n        (\\<lambda>x. \\<Sum>b\\<in>spectrum B. f a * XA a x * g b * XB b x)", "thus \"integrable M (\\<lambda>x. \\<Sum>b\\<in>spectrum B. f a * XA a x * g b * XB b x)\""], ["proof (prove)\nusing this:\n  a \\<in> spectrum A\n\ngoal (1 subgoal):\n 1. integrable M\n     (\\<lambda>x. \\<Sum>b\\<in>spectrum B. f a * XA a x * g b * XB b x)", "using assms lhv_lsum_scal_integrable[of M]"], ["proof (prove)\nusing this:\n  a \\<in> spectrum A\n  lhv M A B R XA XB\n  \\<lbrakk>lhv M ?A ?B ?R ?XA ?XB; ?a \\<in> spectrum ?A\\<rbrakk>\n  \\<Longrightarrow> integrable M\n                     (\\<lambda>x.\n                         \\<Sum>b\\<in>spectrum ?B.\n                           ?c * ?XA ?a x * ?f b * ?XB b x)\n\ngoal (1 subgoal):\n 1. integrable M\n     (\\<lambda>x. \\<Sum>b\\<in>spectrum B. f a * XA a x * g b * XB b x)", "by simp"], ["proof (state)\nthis:\n  integrable M\n   (\\<lambda>x. \\<Sum>b\\<in>spectrum B. f a * XA a x * g b * XB b x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in cpx_sq_mat) spectrum_abs_1_weighted_suml:\n  assumes \"lhv M A B R Va Vb\"\nand \"{Re x |x. x \\<in> spectrum A} \\<noteq> {}\"\n  and \"{Re x |x. x \\<in> spectrum A} \\<subseteq> {- 1, 1}\"\nand \"hermitian A\"\n  and \"A\\<in> fc_mats\"\nshows \"AE w in M. \\<bar>(\\<Sum>a\\<in>spectrum A. Re a * Va a w)\\<bar> \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE w in M. \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "proof (rule AE_mp)"], ["proof (state)\ngoal (2 subgoals):\n 1. almost_everywhere M ?P\n 2. AE w in M. ?P w \\<longrightarrow>\n               \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "show \"AE w in M. (\\<forall>a\\<in>spectrum A. 0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and> (\\<Sum>a\\<in>spectrum A. Va a w) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE w in M. (\\<forall>a\\<in>spectrum A.\n                   0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and>\n               (\\<Sum>a\\<in>spectrum A. Va a w) = 1", "using assms lhv_AE_propl[of M A B _ Va]"], ["proof (prove)\nusing this:\n  lhv M A B R Va Vb\n  {Re x |x. x \\<in> spectrum A} \\<noteq> {}\n  {Re x |x. x \\<in> spectrum A} \\<subseteq> {- 1, 1}\n  hermitian A\n  A \\<in> fc_mats\n  lhv M A B ?R Va ?XB \\<Longrightarrow>\n  AE w in M. (\\<forall>a\\<in>spectrum A.\n                 0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and>\n             (\\<Sum>a\\<in>spectrum A. Va a w) = 1\n\ngoal (1 subgoal):\n 1. AE w in M. (\\<forall>a\\<in>spectrum A.\n                   0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and>\n               (\\<Sum>a\\<in>spectrum A. Va a w) = 1", "by simp"], ["proof (state)\nthis:\n  AE w in M. (\\<forall>a\\<in>spectrum A.\n                 0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and>\n             (\\<Sum>a\\<in>spectrum A. Va a w) = 1\n\ngoal (1 subgoal):\n 1. AE w in M. (\\<forall>a\\<in>spectrum A.\n                   0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and>\n               (\\<Sum>a\\<in>spectrum A. Va a w) = 1 \\<longrightarrow>\n               \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "show \"AE w in M. (\\<forall>a\\<in>spectrum A. 0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and> (\\<Sum>a\\<in>spectrum A. Va a w) = 1 \\<longrightarrow>\n               \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE w in M. (\\<forall>a\\<in>spectrum A.\n                   0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and>\n               (\\<Sum>a\\<in>spectrum A. Va a w) = 1 \\<longrightarrow>\n               \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<in> space M \\<Longrightarrow>\n       (\\<forall>a\\<in>spectrum A.\n           0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and>\n       (\\<Sum>a\\<in>spectrum A. Va a w) = 1 \\<longrightarrow>\n       \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<in> space M \\<Longrightarrow>\n       (\\<forall>a\\<in>spectrum A.\n           0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and>\n       (\\<Sum>a\\<in>spectrum A. Va a w) = 1 \\<longrightarrow>\n       \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "assume \"w\\<in> space M\""], ["proof (state)\nthis:\n  w \\<in> space M\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<in> space M \\<Longrightarrow>\n       (\\<forall>a\\<in>spectrum A.\n           0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and>\n       (\\<Sum>a\\<in>spectrum A. Va a w) = 1 \\<longrightarrow>\n       \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "show \"(\\<forall>a\\<in>spectrum A. 0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and> (\\<Sum>a\\<in>spectrum A. Va a w) = 1 \\<longrightarrow>\n         \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>spectrum A. 0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and>\n    (\\<Sum>a\\<in>spectrum A. Va a w) = 1 \\<longrightarrow>\n    \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "proof (intro impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>spectrum A. 0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and>\n    (\\<Sum>a\\<in>spectrum A. Va a w) = 1 \\<Longrightarrow>\n    \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "assume pr: \"(\\<forall>a\\<in>spectrum A. 0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and> (\\<Sum>a\\<in>spectrum A. Va a w) = 1\""], ["proof (state)\nthis:\n  (\\<forall>a\\<in>spectrum A. 0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and>\n  (\\<Sum>a\\<in>spectrum A. Va a w) = 1\n\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>spectrum A. 0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and>\n    (\\<Sum>a\\<in>spectrum A. Va a w) = 1 \\<Longrightarrow>\n    \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "show \"\\<bar>(\\<Sum>a\\<in>spectrum A. Re a * Va a w)\\<bar> \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "proof (cases \"{Re x |x. x \\<in> spectrum A} = {- 1, 1}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. {Re x |x. x \\<in> spectrum A} = {- 1, 1} \\<Longrightarrow>\n    \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1\n 2. {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1} \\<Longrightarrow>\n    \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "case True"], ["proof (state)\nthis:\n  {Re x |x. x \\<in> spectrum A} = {- 1, 1}\n\ngoal (2 subgoals):\n 1. {Re x |x. x \\<in> spectrum A} = {- 1, 1} \\<Longrightarrow>\n    \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1\n 2. {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1} \\<Longrightarrow>\n    \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "hence sp: \"spectrum A = {-1, 1}\""], ["proof (prove)\nusing this:\n  {Re x |x. x \\<in> spectrum A} = {- 1, 1}\n\ngoal (1 subgoal):\n 1. spectrum A = {- 1, 1}", "using hermitian_Re_spectrum[of A] assms"], ["proof (prove)\nusing this:\n  {Re x |x. x \\<in> spectrum A} = {- 1, 1}\n  \\<lbrakk>hermitian A; A \\<in> fc_mats;\n   {Re x |x. x \\<in> spectrum A} = {?a, ?b}\\<rbrakk>\n  \\<Longrightarrow> spectrum A = {complex_of_real ?a, complex_of_real ?b}\n  lhv M A B R Va Vb\n  {Re x |x. x \\<in> spectrum A} \\<noteq> {}\n  {Re x |x. x \\<in> spectrum A} \\<subseteq> {- 1, 1}\n  hermitian A\n  A \\<in> fc_mats\n\ngoal (1 subgoal):\n 1. spectrum A = {- 1, 1}", "by simp"], ["proof (state)\nthis:\n  spectrum A = {- 1, 1}\n\ngoal (2 subgoals):\n 1. {Re x |x. x \\<in> spectrum A} = {- 1, 1} \\<Longrightarrow>\n    \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1\n 2. {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1} \\<Longrightarrow>\n    \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "hence scsum: \"(\\<Sum>a\\<in>spectrum A. Re a * Va a w) = Va 1 w - Va (-1) w\""], ["proof (prove)\nusing this:\n  spectrum A = {- 1, 1}\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A. Re a * Va a w) = Va 1 w - Va (- 1) w", "using sum_2_elems"], ["proof (prove)\nusing this:\n  spectrum A = {- 1, 1}\n  \\<lbrakk>?I = {?a, ?b}; ?a \\<noteq> ?b\\<rbrakk>\n  \\<Longrightarrow> sum ?f ?I = ?f ?a + ?f ?b\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A. Re a * Va a w) = Va 1 w - Va (- 1) w", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>spectrum A. Re a * Va a w) = Va 1 w - Va (- 1) w\n\ngoal (2 subgoals):\n 1. {Re x |x. x \\<in> spectrum A} = {- 1, 1} \\<Longrightarrow>\n    \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1\n 2. {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1} \\<Longrightarrow>\n    \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "have sum: \"(\\<Sum>a\\<in>spectrum A. Va a w) = Va (-1) w + Va 1 w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A. Va a w) = Va (- 1) w + Va 1 w", "using sp sum_2_elems"], ["proof (prove)\nusing this:\n  spectrum A = {- 1, 1}\n  \\<lbrakk>?I = {?a, ?b}; ?a \\<noteq> ?b\\<rbrakk>\n  \\<Longrightarrow> sum ?f ?I = ?f ?a + ?f ?b\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A. Va a w) = Va (- 1) w + Va 1 w", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>spectrum A. Va a w) = Va (- 1) w + Va 1 w\n\ngoal (2 subgoals):\n 1. {Re x |x. x \\<in> spectrum A} = {- 1, 1} \\<Longrightarrow>\n    \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1\n 2. {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1} \\<Longrightarrow>\n    \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "have \"\\<bar>Va 1 w - Va (-1) w\\<bar> \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>Va 1 w - Va (- 1) w\\<bar> \\<le> 1", "proof (rule fct_bound')"], ["proof (state)\ngoal (3 subgoals):\n 1. Va (- 1) w + Va 1 w = 1\n 2. 0 \\<le> Va 1 w\n 3. 0 \\<le> Va (- 1) w", "have \"1 \\<in> spectrum A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<in> spectrum A", "using sp"], ["proof (prove)\nusing this:\n  spectrum A = {- 1, 1}\n\ngoal (1 subgoal):\n 1. 1 \\<in> spectrum A", "by simp"], ["proof (state)\nthis:\n  1 \\<in> spectrum A\n\ngoal (3 subgoals):\n 1. Va (- 1) w + Va 1 w = 1\n 2. 0 \\<le> Va 1 w\n 3. 0 \\<le> Va (- 1) w", "thus \"0 \\<le> Va 1 w\""], ["proof (prove)\nusing this:\n  1 \\<in> spectrum A\n\ngoal (1 subgoal):\n 1. 0 \\<le> Va 1 w", "using pr"], ["proof (prove)\nusing this:\n  1 \\<in> spectrum A\n  (\\<forall>a\\<in>spectrum A. 0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and>\n  (\\<Sum>a\\<in>spectrum A. Va a w) = 1\n\ngoal (1 subgoal):\n 1. 0 \\<le> Va 1 w", "by simp"], ["proof (state)\nthis:\n  0 \\<le> Va 1 w\n\ngoal (2 subgoals):\n 1. Va (- 1) w + Va 1 w = 1\n 2. 0 \\<le> Va (- 1) w", "have \"-1 \\<in> spectrum A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - 1 \\<in> spectrum A", "using sp"], ["proof (prove)\nusing this:\n  spectrum A = {- 1, 1}\n\ngoal (1 subgoal):\n 1. - 1 \\<in> spectrum A", "by simp"], ["proof (state)\nthis:\n  - 1 \\<in> spectrum A\n\ngoal (2 subgoals):\n 1. Va (- 1) w + Va 1 w = 1\n 2. 0 \\<le> Va (- 1) w", "thus \"0 \\<le> Va (- 1) w\""], ["proof (prove)\nusing this:\n  - 1 \\<in> spectrum A\n\ngoal (1 subgoal):\n 1. 0 \\<le> Va (- 1) w", "using pr"], ["proof (prove)\nusing this:\n  - 1 \\<in> spectrum A\n  (\\<forall>a\\<in>spectrum A. 0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and>\n  (\\<Sum>a\\<in>spectrum A. Va a w) = 1\n\ngoal (1 subgoal):\n 1. 0 \\<le> Va (- 1) w", "by simp"], ["proof (state)\nthis:\n  0 \\<le> Va (- 1) w\n\ngoal (1 subgoal):\n 1. Va (- 1) w + Va 1 w = 1", "show \"Va (- 1) w + Va 1 w = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Va (- 1) w + Va 1 w = 1", "using pr sum"], ["proof (prove)\nusing this:\n  (\\<forall>a\\<in>spectrum A. 0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and>\n  (\\<Sum>a\\<in>spectrum A. Va a w) = 1\n  (\\<Sum>a\\<in>spectrum A. Va a w) = Va (- 1) w + Va 1 w\n\ngoal (1 subgoal):\n 1. Va (- 1) w + Va 1 w = 1", "by simp"], ["proof (state)\nthis:\n  Va (- 1) w + Va 1 w = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<bar>Va 1 w - Va (- 1) w\\<bar> \\<le> 1\n\ngoal (2 subgoals):\n 1. {Re x |x. x \\<in> spectrum A} = {- 1, 1} \\<Longrightarrow>\n    \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1\n 2. {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1} \\<Longrightarrow>\n    \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>Va 1 w - Va (- 1) w\\<bar> \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "using scsum"], ["proof (prove)\nusing this:\n  \\<bar>Va 1 w - Va (- 1) w\\<bar> \\<le> 1\n  (\\<Sum>a\\<in>spectrum A. Re a * Va a w) = Va 1 w - Va (- 1) w\n\ngoal (1 subgoal):\n 1. \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "by simp"], ["proof (state)\nthis:\n  \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1\n\ngoal (1 subgoal):\n 1. {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1} \\<Longrightarrow>\n    \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1} \\<Longrightarrow>\n    \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "case False"], ["proof (state)\nthis:\n  {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1}\n\ngoal (1 subgoal):\n 1. {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1} \\<Longrightarrow>\n    \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "then"], ["proof (chain)\npicking this:\n  {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1}", "show ?thesis"], ["proof (prove)\nusing this:\n  {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1}\n\ngoal (1 subgoal):\n 1. \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "proof (cases \"{Re x |x. x \\<in> spectrum A} = {- 1}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>{Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1};\n     {Re x |x. x \\<in> spectrum A} = {- 1}\\<rbrakk>\n    \\<Longrightarrow> \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar>\n                      \\<le> 1\n 2. \\<lbrakk>{Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1};\n     {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1}\\<rbrakk>\n    \\<Longrightarrow> \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar>\n                      \\<le> 1", "case True"], ["proof (state)\nthis:\n  {Re x |x. x \\<in> spectrum A} = {- 1}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>{Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1};\n     {Re x |x. x \\<in> spectrum A} = {- 1}\\<rbrakk>\n    \\<Longrightarrow> \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar>\n                      \\<le> 1\n 2. \\<lbrakk>{Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1};\n     {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1}\\<rbrakk>\n    \\<Longrightarrow> \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar>\n                      \\<le> 1", "hence \"spectrum A = {-1}\""], ["proof (prove)\nusing this:\n  {Re x |x. x \\<in> spectrum A} = {- 1}\n\ngoal (1 subgoal):\n 1. spectrum A = {- 1}", "using hermitian_Re_spectrum[of A] assms"], ["proof (prove)\nusing this:\n  {Re x |x. x \\<in> spectrum A} = {- 1}\n  \\<lbrakk>hermitian A; A \\<in> fc_mats;\n   {Re x |x. x \\<in> spectrum A} = {?a, ?b}\\<rbrakk>\n  \\<Longrightarrow> spectrum A = {complex_of_real ?a, complex_of_real ?b}\n  lhv M A B R Va Vb\n  {Re x |x. x \\<in> spectrum A} \\<noteq> {}\n  {Re x |x. x \\<in> spectrum A} \\<subseteq> {- 1, 1}\n  hermitian A\n  A \\<in> fc_mats\n\ngoal (1 subgoal):\n 1. spectrum A = {- 1}", "by simp"], ["proof (state)\nthis:\n  spectrum A = {- 1}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>{Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1};\n     {Re x |x. x \\<in> spectrum A} = {- 1}\\<rbrakk>\n    \\<Longrightarrow> \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar>\n                      \\<le> 1\n 2. \\<lbrakk>{Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1};\n     {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1}\\<rbrakk>\n    \\<Longrightarrow> \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar>\n                      \\<le> 1", "hence \"(\\<Sum>a\\<in>spectrum A. Re a * Va a w) = - Va (-1) w\""], ["proof (prove)\nusing this:\n  spectrum A = {- 1}\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A. Re a * Va a w) = - Va (- 1) w", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>spectrum A. Re a * Va a w) = - Va (- 1) w\n\ngoal (2 subgoals):\n 1. \\<lbrakk>{Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1};\n     {Re x |x. x \\<in> spectrum A} = {- 1}\\<rbrakk>\n    \\<Longrightarrow> \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar>\n                      \\<le> 1\n 2. \\<lbrakk>{Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1};\n     {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1}\\<rbrakk>\n    \\<Longrightarrow> \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar>\n                      \\<le> 1", "moreover"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>spectrum A. Re a * Va a w) = - Va (- 1) w\n\ngoal (2 subgoals):\n 1. \\<lbrakk>{Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1};\n     {Re x |x. x \\<in> spectrum A} = {- 1}\\<rbrakk>\n    \\<Longrightarrow> \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar>\n                      \\<le> 1\n 2. \\<lbrakk>{Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1};\n     {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1}\\<rbrakk>\n    \\<Longrightarrow> \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar>\n                      \\<le> 1", "have \"-1 \\<in> spectrum A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - 1 \\<in> spectrum A", "using \\<open>spectrum A = {-1}\\<close>"], ["proof (prove)\nusing this:\n  spectrum A = {- 1}\n\ngoal (1 subgoal):\n 1. - 1 \\<in> spectrum A", "by simp"], ["proof (state)\nthis:\n  - 1 \\<in> spectrum A\n\ngoal (2 subgoals):\n 1. \\<lbrakk>{Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1};\n     {Re x |x. x \\<in> spectrum A} = {- 1}\\<rbrakk>\n    \\<Longrightarrow> \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar>\n                      \\<le> 1\n 2. \\<lbrakk>{Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1};\n     {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1}\\<rbrakk>\n    \\<Longrightarrow> \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar>\n                      \\<le> 1", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Sum>a\\<in>spectrum A. Re a * Va a w) = - Va (- 1) w\n  - 1 \\<in> spectrum A", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>a\\<in>spectrum A. Re a * Va a w) = - Va (- 1) w\n  - 1 \\<in> spectrum A\n\ngoal (1 subgoal):\n 1. \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "using pr"], ["proof (prove)\nusing this:\n  (\\<Sum>a\\<in>spectrum A. Re a * Va a w) = - Va (- 1) w\n  - 1 \\<in> spectrum A\n  (\\<forall>a\\<in>spectrum A. 0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and>\n  (\\<Sum>a\\<in>spectrum A. Va a w) = 1\n\ngoal (1 subgoal):\n 1. \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "by simp"], ["proof (state)\nthis:\n  \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1};\n     {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1}\\<rbrakk>\n    \\<Longrightarrow> \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar>\n                      \\<le> 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>{Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1};\n     {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1}\\<rbrakk>\n    \\<Longrightarrow> \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar>\n                      \\<le> 1", "case False"], ["proof (state)\nthis:\n  {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1};\n     {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1}\\<rbrakk>\n    \\<Longrightarrow> \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar>\n                      \\<le> 1", "hence \"{Re x |x. x \\<in> spectrum A} = {1}\""], ["proof (prove)\nusing this:\n  {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1}\n\ngoal (1 subgoal):\n 1. {Re x |x. x \\<in> spectrum A} = {1}", "using assms \\<open>{Re x |x. x \\<in> spectrum A} \\<noteq> {-1, 1}\\<close>\n            last_subset[of \"{Re x |x. x \\<in> spectrum A}\"]"], ["proof (prove)\nusing this:\n  {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1}\n  lhv M A B R Va Vb\n  {Re x |x. x \\<in> spectrum A} \\<noteq> {}\n  {Re x |x. x \\<in> spectrum A} \\<subseteq> {- 1, 1}\n  hermitian A\n  A \\<in> fc_mats\n  {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1}\n  \\<lbrakk>{Re x |x. x \\<in> spectrum A} \\<subseteq> {?a, ?b};\n   ?a \\<noteq> ?b; {Re x |x. x \\<in> spectrum A} \\<noteq> {?a, ?b};\n   {Re x |x. x \\<in> spectrum A} \\<noteq> {};\n   {Re x |x. x \\<in> spectrum A} \\<noteq> {?a}\\<rbrakk>\n  \\<Longrightarrow> {Re x |x. x \\<in> spectrum A} = {?b}\n\ngoal (1 subgoal):\n 1. {Re x |x. x \\<in> spectrum A} = {1}", "by simp"], ["proof (state)\nthis:\n  {Re x |x. x \\<in> spectrum A} = {1}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1};\n     {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1}\\<rbrakk>\n    \\<Longrightarrow> \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar>\n                      \\<le> 1", "hence \"spectrum A = {1}\""], ["proof (prove)\nusing this:\n  {Re x |x. x \\<in> spectrum A} = {1}\n\ngoal (1 subgoal):\n 1. spectrum A = {1}", "using hermitian_Re_spectrum[of A] assms"], ["proof (prove)\nusing this:\n  {Re x |x. x \\<in> spectrum A} = {1}\n  \\<lbrakk>hermitian A; A \\<in> fc_mats;\n   {Re x |x. x \\<in> spectrum A} = {?a, ?b}\\<rbrakk>\n  \\<Longrightarrow> spectrum A = {complex_of_real ?a, complex_of_real ?b}\n  lhv M A B R Va Vb\n  {Re x |x. x \\<in> spectrum A} \\<noteq> {}\n  {Re x |x. x \\<in> spectrum A} \\<subseteq> {- 1, 1}\n  hermitian A\n  A \\<in> fc_mats\n\ngoal (1 subgoal):\n 1. spectrum A = {1}", "by simp"], ["proof (state)\nthis:\n  spectrum A = {1}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1};\n     {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1}\\<rbrakk>\n    \\<Longrightarrow> \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar>\n                      \\<le> 1", "hence \"(\\<Sum>a\\<in>spectrum A. Re a * Va a w) = Va 1 w\""], ["proof (prove)\nusing this:\n  spectrum A = {1}\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A. Re a * Va a w) = Va 1 w", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>spectrum A. Re a * Va a w) = Va 1 w\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1};\n     {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1}\\<rbrakk>\n    \\<Longrightarrow> \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar>\n                      \\<le> 1", "moreover"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>spectrum A. Re a * Va a w) = Va 1 w\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1};\n     {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1}\\<rbrakk>\n    \\<Longrightarrow> \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar>\n                      \\<le> 1", "have \"1 \\<in> spectrum A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<in> spectrum A", "using \\<open>spectrum A = {1}\\<close>"], ["proof (prove)\nusing this:\n  spectrum A = {1}\n\ngoal (1 subgoal):\n 1. 1 \\<in> spectrum A", "by simp"], ["proof (state)\nthis:\n  1 \\<in> spectrum A\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1};\n     {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1}\\<rbrakk>\n    \\<Longrightarrow> \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar>\n                      \\<le> 1", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Sum>a\\<in>spectrum A. Re a * Va a w) = Va 1 w\n  1 \\<in> spectrum A", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>a\\<in>spectrum A. Re a * Va a w) = Va 1 w\n  1 \\<in> spectrum A\n\ngoal (1 subgoal):\n 1. \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "using pr"], ["proof (prove)\nusing this:\n  (\\<Sum>a\\<in>spectrum A. Re a * Va a w) = Va 1 w\n  1 \\<in> spectrum A\n  (\\<forall>a\\<in>spectrum A. 0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and>\n  (\\<Sum>a\\<in>spectrum A. Va a w) = 1\n\ngoal (1 subgoal):\n 1. \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "by simp"], ["proof (state)\nthis:\n  \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>a\\<in>spectrum A. 0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and>\n  (\\<Sum>a\\<in>spectrum A. Va a w) = 1 \\<longrightarrow>\n  \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  AE w in M. (\\<forall>a\\<in>spectrum A.\n                 0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and>\n             (\\<Sum>a\\<in>spectrum A. Va a w) = 1 \\<longrightarrow>\n             \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in cpx_sq_mat) spectrum_abs_1_weighted_sumr:\n  assumes \"lhv M B A R Vb Va\"\nand \"{Re x |x. x \\<in> spectrum A} \\<noteq> {}\"\n  and \"{Re x |x. x \\<in> spectrum A} \\<subseteq> {- 1, 1}\"\nand \"hermitian A\"\n  and \"A\\<in> fc_mats\"\nshows \"AE w in M. \\<bar>(\\<Sum>a\\<in>spectrum A. Re a * Va a w)\\<bar> \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE w in M. \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "proof (rule AE_mp)"], ["proof (state)\ngoal (2 subgoals):\n 1. almost_everywhere M ?P\n 2. AE w in M. ?P w \\<longrightarrow>\n               \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "show \"AE w in M. (\\<forall>a\\<in>spectrum A. 0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and> (\\<Sum>a\\<in>spectrum A. Va a w) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE w in M. (\\<forall>a\\<in>spectrum A.\n                   0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and>\n               (\\<Sum>a\\<in>spectrum A. Va a w) = 1", "using assms lhv_AE_propr[of M B A _ Vb]"], ["proof (prove)\nusing this:\n  lhv M B A R Vb Va\n  {Re x |x. x \\<in> spectrum A} \\<noteq> {}\n  {Re x |x. x \\<in> spectrum A} \\<subseteq> {- 1, 1}\n  hermitian A\n  A \\<in> fc_mats\n  lhv M B A ?R Vb ?XB \\<Longrightarrow>\n  AE w in M. (\\<forall>a\\<in>spectrum A.\n                 0 \\<le> ?XB a w \\<and> ?XB a w \\<le> 1) \\<and>\n             (\\<Sum>a\\<in>spectrum A. ?XB a w) = 1\n\ngoal (1 subgoal):\n 1. AE w in M. (\\<forall>a\\<in>spectrum A.\n                   0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and>\n               (\\<Sum>a\\<in>spectrum A. Va a w) = 1", "by simp"], ["proof (state)\nthis:\n  AE w in M. (\\<forall>a\\<in>spectrum A.\n                 0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and>\n             (\\<Sum>a\\<in>spectrum A. Va a w) = 1\n\ngoal (1 subgoal):\n 1. AE w in M. (\\<forall>a\\<in>spectrum A.\n                   0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and>\n               (\\<Sum>a\\<in>spectrum A. Va a w) = 1 \\<longrightarrow>\n               \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "show \"AE w in M. (\\<forall>a\\<in>spectrum A. 0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and> (\\<Sum>a\\<in>spectrum A. Va a w) = 1 \\<longrightarrow>\n               \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE w in M. (\\<forall>a\\<in>spectrum A.\n                   0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and>\n               (\\<Sum>a\\<in>spectrum A. Va a w) = 1 \\<longrightarrow>\n               \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<in> space M \\<Longrightarrow>\n       (\\<forall>a\\<in>spectrum A.\n           0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and>\n       (\\<Sum>a\\<in>spectrum A. Va a w) = 1 \\<longrightarrow>\n       \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<in> space M \\<Longrightarrow>\n       (\\<forall>a\\<in>spectrum A.\n           0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and>\n       (\\<Sum>a\\<in>spectrum A. Va a w) = 1 \\<longrightarrow>\n       \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "assume \"w\\<in> space M\""], ["proof (state)\nthis:\n  w \\<in> space M\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<in> space M \\<Longrightarrow>\n       (\\<forall>a\\<in>spectrum A.\n           0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and>\n       (\\<Sum>a\\<in>spectrum A. Va a w) = 1 \\<longrightarrow>\n       \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "show \"(\\<forall>a\\<in>spectrum A. 0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and> (\\<Sum>a\\<in>spectrum A. Va a w) = 1 \\<longrightarrow>\n         \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>spectrum A. 0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and>\n    (\\<Sum>a\\<in>spectrum A. Va a w) = 1 \\<longrightarrow>\n    \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "proof (intro impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>spectrum A. 0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and>\n    (\\<Sum>a\\<in>spectrum A. Va a w) = 1 \\<Longrightarrow>\n    \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "assume pr: \"(\\<forall>a\\<in>spectrum A. 0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and> (\\<Sum>a\\<in>spectrum A. Va a w) = 1\""], ["proof (state)\nthis:\n  (\\<forall>a\\<in>spectrum A. 0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and>\n  (\\<Sum>a\\<in>spectrum A. Va a w) = 1\n\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>spectrum A. 0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and>\n    (\\<Sum>a\\<in>spectrum A. Va a w) = 1 \\<Longrightarrow>\n    \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "show \"\\<bar>(\\<Sum>a\\<in>spectrum A. Re a * Va a w)\\<bar> \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "proof (cases \"{Re x |x. x \\<in> spectrum A} = {- 1, 1}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. {Re x |x. x \\<in> spectrum A} = {- 1, 1} \\<Longrightarrow>\n    \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1\n 2. {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1} \\<Longrightarrow>\n    \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "case True"], ["proof (state)\nthis:\n  {Re x |x. x \\<in> spectrum A} = {- 1, 1}\n\ngoal (2 subgoals):\n 1. {Re x |x. x \\<in> spectrum A} = {- 1, 1} \\<Longrightarrow>\n    \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1\n 2. {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1} \\<Longrightarrow>\n    \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "hence sp: \"spectrum A = {-1, 1}\""], ["proof (prove)\nusing this:\n  {Re x |x. x \\<in> spectrum A} = {- 1, 1}\n\ngoal (1 subgoal):\n 1. spectrum A = {- 1, 1}", "using hermitian_Re_spectrum[of A] assms"], ["proof (prove)\nusing this:\n  {Re x |x. x \\<in> spectrum A} = {- 1, 1}\n  \\<lbrakk>hermitian A; A \\<in> fc_mats;\n   {Re x |x. x \\<in> spectrum A} = {?a, ?b}\\<rbrakk>\n  \\<Longrightarrow> spectrum A = {complex_of_real ?a, complex_of_real ?b}\n  lhv M B A R Vb Va\n  {Re x |x. x \\<in> spectrum A} \\<noteq> {}\n  {Re x |x. x \\<in> spectrum A} \\<subseteq> {- 1, 1}\n  hermitian A\n  A \\<in> fc_mats\n\ngoal (1 subgoal):\n 1. spectrum A = {- 1, 1}", "by simp"], ["proof (state)\nthis:\n  spectrum A = {- 1, 1}\n\ngoal (2 subgoals):\n 1. {Re x |x. x \\<in> spectrum A} = {- 1, 1} \\<Longrightarrow>\n    \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1\n 2. {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1} \\<Longrightarrow>\n    \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "hence scsum: \"(\\<Sum>a\\<in>spectrum A. Re a * Va a w) = Va 1 w - Va (-1) w\""], ["proof (prove)\nusing this:\n  spectrum A = {- 1, 1}\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A. Re a * Va a w) = Va 1 w - Va (- 1) w", "using sum_2_elems"], ["proof (prove)\nusing this:\n  spectrum A = {- 1, 1}\n  \\<lbrakk>?I = {?a, ?b}; ?a \\<noteq> ?b\\<rbrakk>\n  \\<Longrightarrow> sum ?f ?I = ?f ?a + ?f ?b\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A. Re a * Va a w) = Va 1 w - Va (- 1) w", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>spectrum A. Re a * Va a w) = Va 1 w - Va (- 1) w\n\ngoal (2 subgoals):\n 1. {Re x |x. x \\<in> spectrum A} = {- 1, 1} \\<Longrightarrow>\n    \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1\n 2. {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1} \\<Longrightarrow>\n    \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "have sum: \"(\\<Sum>a\\<in>spectrum A. Va a w) = Va (-1) w + Va 1 w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A. Va a w) = Va (- 1) w + Va 1 w", "using sp sum_2_elems"], ["proof (prove)\nusing this:\n  spectrum A = {- 1, 1}\n  \\<lbrakk>?I = {?a, ?b}; ?a \\<noteq> ?b\\<rbrakk>\n  \\<Longrightarrow> sum ?f ?I = ?f ?a + ?f ?b\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A. Va a w) = Va (- 1) w + Va 1 w", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>spectrum A. Va a w) = Va (- 1) w + Va 1 w\n\ngoal (2 subgoals):\n 1. {Re x |x. x \\<in> spectrum A} = {- 1, 1} \\<Longrightarrow>\n    \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1\n 2. {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1} \\<Longrightarrow>\n    \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "have \"\\<bar>Va 1 w - Va (-1) w\\<bar> \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>Va 1 w - Va (- 1) w\\<bar> \\<le> 1", "proof (rule fct_bound')"], ["proof (state)\ngoal (3 subgoals):\n 1. Va (- 1) w + Va 1 w = 1\n 2. 0 \\<le> Va 1 w\n 3. 0 \\<le> Va (- 1) w", "have \"1 \\<in> spectrum A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<in> spectrum A", "using sp"], ["proof (prove)\nusing this:\n  spectrum A = {- 1, 1}\n\ngoal (1 subgoal):\n 1. 1 \\<in> spectrum A", "by simp"], ["proof (state)\nthis:\n  1 \\<in> spectrum A\n\ngoal (3 subgoals):\n 1. Va (- 1) w + Va 1 w = 1\n 2. 0 \\<le> Va 1 w\n 3. 0 \\<le> Va (- 1) w", "thus \"0 \\<le> Va 1 w\""], ["proof (prove)\nusing this:\n  1 \\<in> spectrum A\n\ngoal (1 subgoal):\n 1. 0 \\<le> Va 1 w", "using pr"], ["proof (prove)\nusing this:\n  1 \\<in> spectrum A\n  (\\<forall>a\\<in>spectrum A. 0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and>\n  (\\<Sum>a\\<in>spectrum A. Va a w) = 1\n\ngoal (1 subgoal):\n 1. 0 \\<le> Va 1 w", "by simp"], ["proof (state)\nthis:\n  0 \\<le> Va 1 w\n\ngoal (2 subgoals):\n 1. Va (- 1) w + Va 1 w = 1\n 2. 0 \\<le> Va (- 1) w", "have \"-1 \\<in> spectrum A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - 1 \\<in> spectrum A", "using sp"], ["proof (prove)\nusing this:\n  spectrum A = {- 1, 1}\n\ngoal (1 subgoal):\n 1. - 1 \\<in> spectrum A", "by simp"], ["proof (state)\nthis:\n  - 1 \\<in> spectrum A\n\ngoal (2 subgoals):\n 1. Va (- 1) w + Va 1 w = 1\n 2. 0 \\<le> Va (- 1) w", "thus \"0 \\<le> Va (- 1) w\""], ["proof (prove)\nusing this:\n  - 1 \\<in> spectrum A\n\ngoal (1 subgoal):\n 1. 0 \\<le> Va (- 1) w", "using pr"], ["proof (prove)\nusing this:\n  - 1 \\<in> spectrum A\n  (\\<forall>a\\<in>spectrum A. 0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and>\n  (\\<Sum>a\\<in>spectrum A. Va a w) = 1\n\ngoal (1 subgoal):\n 1. 0 \\<le> Va (- 1) w", "by simp"], ["proof (state)\nthis:\n  0 \\<le> Va (- 1) w\n\ngoal (1 subgoal):\n 1. Va (- 1) w + Va 1 w = 1", "show \"Va (- 1) w + Va 1 w = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Va (- 1) w + Va 1 w = 1", "using pr sum"], ["proof (prove)\nusing this:\n  (\\<forall>a\\<in>spectrum A. 0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and>\n  (\\<Sum>a\\<in>spectrum A. Va a w) = 1\n  (\\<Sum>a\\<in>spectrum A. Va a w) = Va (- 1) w + Va 1 w\n\ngoal (1 subgoal):\n 1. Va (- 1) w + Va 1 w = 1", "by simp"], ["proof (state)\nthis:\n  Va (- 1) w + Va 1 w = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<bar>Va 1 w - Va (- 1) w\\<bar> \\<le> 1\n\ngoal (2 subgoals):\n 1. {Re x |x. x \\<in> spectrum A} = {- 1, 1} \\<Longrightarrow>\n    \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1\n 2. {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1} \\<Longrightarrow>\n    \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>Va 1 w - Va (- 1) w\\<bar> \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "using scsum"], ["proof (prove)\nusing this:\n  \\<bar>Va 1 w - Va (- 1) w\\<bar> \\<le> 1\n  (\\<Sum>a\\<in>spectrum A. Re a * Va a w) = Va 1 w - Va (- 1) w\n\ngoal (1 subgoal):\n 1. \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "by simp"], ["proof (state)\nthis:\n  \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1\n\ngoal (1 subgoal):\n 1. {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1} \\<Longrightarrow>\n    \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1} \\<Longrightarrow>\n    \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "case False"], ["proof (state)\nthis:\n  {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1}\n\ngoal (1 subgoal):\n 1. {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1} \\<Longrightarrow>\n    \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "then"], ["proof (chain)\npicking this:\n  {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1}", "show ?thesis"], ["proof (prove)\nusing this:\n  {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1}\n\ngoal (1 subgoal):\n 1. \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "proof (cases \"{Re x |x. x \\<in> spectrum A} = {- 1}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>{Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1};\n     {Re x |x. x \\<in> spectrum A} = {- 1}\\<rbrakk>\n    \\<Longrightarrow> \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar>\n                      \\<le> 1\n 2. \\<lbrakk>{Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1};\n     {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1}\\<rbrakk>\n    \\<Longrightarrow> \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar>\n                      \\<le> 1", "case True"], ["proof (state)\nthis:\n  {Re x |x. x \\<in> spectrum A} = {- 1}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>{Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1};\n     {Re x |x. x \\<in> spectrum A} = {- 1}\\<rbrakk>\n    \\<Longrightarrow> \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar>\n                      \\<le> 1\n 2. \\<lbrakk>{Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1};\n     {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1}\\<rbrakk>\n    \\<Longrightarrow> \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar>\n                      \\<le> 1", "hence \"spectrum A = {-1}\""], ["proof (prove)\nusing this:\n  {Re x |x. x \\<in> spectrum A} = {- 1}\n\ngoal (1 subgoal):\n 1. spectrum A = {- 1}", "using hermitian_Re_spectrum[of A] assms"], ["proof (prove)\nusing this:\n  {Re x |x. x \\<in> spectrum A} = {- 1}\n  \\<lbrakk>hermitian A; A \\<in> fc_mats;\n   {Re x |x. x \\<in> spectrum A} = {?a, ?b}\\<rbrakk>\n  \\<Longrightarrow> spectrum A = {complex_of_real ?a, complex_of_real ?b}\n  lhv M B A R Vb Va\n  {Re x |x. x \\<in> spectrum A} \\<noteq> {}\n  {Re x |x. x \\<in> spectrum A} \\<subseteq> {- 1, 1}\n  hermitian A\n  A \\<in> fc_mats\n\ngoal (1 subgoal):\n 1. spectrum A = {- 1}", "by simp"], ["proof (state)\nthis:\n  spectrum A = {- 1}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>{Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1};\n     {Re x |x. x \\<in> spectrum A} = {- 1}\\<rbrakk>\n    \\<Longrightarrow> \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar>\n                      \\<le> 1\n 2. \\<lbrakk>{Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1};\n     {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1}\\<rbrakk>\n    \\<Longrightarrow> \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar>\n                      \\<le> 1", "hence \"(\\<Sum>a\\<in>spectrum A. Re a * Va a w) = - Va (-1) w\""], ["proof (prove)\nusing this:\n  spectrum A = {- 1}\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A. Re a * Va a w) = - Va (- 1) w", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>spectrum A. Re a * Va a w) = - Va (- 1) w\n\ngoal (2 subgoals):\n 1. \\<lbrakk>{Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1};\n     {Re x |x. x \\<in> spectrum A} = {- 1}\\<rbrakk>\n    \\<Longrightarrow> \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar>\n                      \\<le> 1\n 2. \\<lbrakk>{Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1};\n     {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1}\\<rbrakk>\n    \\<Longrightarrow> \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar>\n                      \\<le> 1", "moreover"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>spectrum A. Re a * Va a w) = - Va (- 1) w\n\ngoal (2 subgoals):\n 1. \\<lbrakk>{Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1};\n     {Re x |x. x \\<in> spectrum A} = {- 1}\\<rbrakk>\n    \\<Longrightarrow> \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar>\n                      \\<le> 1\n 2. \\<lbrakk>{Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1};\n     {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1}\\<rbrakk>\n    \\<Longrightarrow> \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar>\n                      \\<le> 1", "have \"-1 \\<in> spectrum A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - 1 \\<in> spectrum A", "using \\<open>spectrum A = {-1}\\<close>"], ["proof (prove)\nusing this:\n  spectrum A = {- 1}\n\ngoal (1 subgoal):\n 1. - 1 \\<in> spectrum A", "by simp"], ["proof (state)\nthis:\n  - 1 \\<in> spectrum A\n\ngoal (2 subgoals):\n 1. \\<lbrakk>{Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1};\n     {Re x |x. x \\<in> spectrum A} = {- 1}\\<rbrakk>\n    \\<Longrightarrow> \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar>\n                      \\<le> 1\n 2. \\<lbrakk>{Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1};\n     {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1}\\<rbrakk>\n    \\<Longrightarrow> \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar>\n                      \\<le> 1", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Sum>a\\<in>spectrum A. Re a * Va a w) = - Va (- 1) w\n  - 1 \\<in> spectrum A", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>a\\<in>spectrum A. Re a * Va a w) = - Va (- 1) w\n  - 1 \\<in> spectrum A\n\ngoal (1 subgoal):\n 1. \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "using pr"], ["proof (prove)\nusing this:\n  (\\<Sum>a\\<in>spectrum A. Re a * Va a w) = - Va (- 1) w\n  - 1 \\<in> spectrum A\n  (\\<forall>a\\<in>spectrum A. 0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and>\n  (\\<Sum>a\\<in>spectrum A. Va a w) = 1\n\ngoal (1 subgoal):\n 1. \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "by simp"], ["proof (state)\nthis:\n  \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1};\n     {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1}\\<rbrakk>\n    \\<Longrightarrow> \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar>\n                      \\<le> 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>{Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1};\n     {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1}\\<rbrakk>\n    \\<Longrightarrow> \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar>\n                      \\<le> 1", "case False"], ["proof (state)\nthis:\n  {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1};\n     {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1}\\<rbrakk>\n    \\<Longrightarrow> \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar>\n                      \\<le> 1", "hence \"{Re x |x. x \\<in> spectrum A} = {1}\""], ["proof (prove)\nusing this:\n  {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1}\n\ngoal (1 subgoal):\n 1. {Re x |x. x \\<in> spectrum A} = {1}", "using assms \\<open>{Re x |x. x \\<in> spectrum A} \\<noteq> {-1, 1}\\<close>\n            last_subset[of \"{Re x |x. x \\<in> spectrum A}\"]"], ["proof (prove)\nusing this:\n  {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1}\n  lhv M B A R Vb Va\n  {Re x |x. x \\<in> spectrum A} \\<noteq> {}\n  {Re x |x. x \\<in> spectrum A} \\<subseteq> {- 1, 1}\n  hermitian A\n  A \\<in> fc_mats\n  {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1}\n  \\<lbrakk>{Re x |x. x \\<in> spectrum A} \\<subseteq> {?a, ?b};\n   ?a \\<noteq> ?b; {Re x |x. x \\<in> spectrum A} \\<noteq> {?a, ?b};\n   {Re x |x. x \\<in> spectrum A} \\<noteq> {};\n   {Re x |x. x \\<in> spectrum A} \\<noteq> {?a}\\<rbrakk>\n  \\<Longrightarrow> {Re x |x. x \\<in> spectrum A} = {?b}\n\ngoal (1 subgoal):\n 1. {Re x |x. x \\<in> spectrum A} = {1}", "by simp"], ["proof (state)\nthis:\n  {Re x |x. x \\<in> spectrum A} = {1}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1};\n     {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1}\\<rbrakk>\n    \\<Longrightarrow> \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar>\n                      \\<le> 1", "hence \"spectrum A = {1}\""], ["proof (prove)\nusing this:\n  {Re x |x. x \\<in> spectrum A} = {1}\n\ngoal (1 subgoal):\n 1. spectrum A = {1}", "using hermitian_Re_spectrum[of A] assms"], ["proof (prove)\nusing this:\n  {Re x |x. x \\<in> spectrum A} = {1}\n  \\<lbrakk>hermitian A; A \\<in> fc_mats;\n   {Re x |x. x \\<in> spectrum A} = {?a, ?b}\\<rbrakk>\n  \\<Longrightarrow> spectrum A = {complex_of_real ?a, complex_of_real ?b}\n  lhv M B A R Vb Va\n  {Re x |x. x \\<in> spectrum A} \\<noteq> {}\n  {Re x |x. x \\<in> spectrum A} \\<subseteq> {- 1, 1}\n  hermitian A\n  A \\<in> fc_mats\n\ngoal (1 subgoal):\n 1. spectrum A = {1}", "by simp"], ["proof (state)\nthis:\n  spectrum A = {1}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1};\n     {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1}\\<rbrakk>\n    \\<Longrightarrow> \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar>\n                      \\<le> 1", "hence \"(\\<Sum>a\\<in>spectrum A. Re a * Va a w) = Va 1 w\""], ["proof (prove)\nusing this:\n  spectrum A = {1}\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A. Re a * Va a w) = Va 1 w", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>spectrum A. Re a * Va a w) = Va 1 w\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1};\n     {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1}\\<rbrakk>\n    \\<Longrightarrow> \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar>\n                      \\<le> 1", "moreover"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>spectrum A. Re a * Va a w) = Va 1 w\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1};\n     {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1}\\<rbrakk>\n    \\<Longrightarrow> \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar>\n                      \\<le> 1", "have \"1 \\<in> spectrum A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<in> spectrum A", "using \\<open>spectrum A = {1}\\<close>"], ["proof (prove)\nusing this:\n  spectrum A = {1}\n\ngoal (1 subgoal):\n 1. 1 \\<in> spectrum A", "by simp"], ["proof (state)\nthis:\n  1 \\<in> spectrum A\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{Re x |x. x \\<in> spectrum A} \\<noteq> {- 1, 1};\n     {Re x |x. x \\<in> spectrum A} \\<noteq> {- 1}\\<rbrakk>\n    \\<Longrightarrow> \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar>\n                      \\<le> 1", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Sum>a\\<in>spectrum A. Re a * Va a w) = Va 1 w\n  1 \\<in> spectrum A", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>a\\<in>spectrum A. Re a * Va a w) = Va 1 w\n  1 \\<in> spectrum A\n\ngoal (1 subgoal):\n 1. \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "using pr"], ["proof (prove)\nusing this:\n  (\\<Sum>a\\<in>spectrum A. Re a * Va a w) = Va 1 w\n  1 \\<in> spectrum A\n  (\\<forall>a\\<in>spectrum A. 0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and>\n  (\\<Sum>a\\<in>spectrum A. Va a w) = 1\n\ngoal (1 subgoal):\n 1. \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1", "by simp"], ["proof (state)\nthis:\n  \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>a\\<in>spectrum A. 0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and>\n  (\\<Sum>a\\<in>spectrum A. Va a w) = 1 \\<longrightarrow>\n  \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  AE w in M. (\\<forall>a\\<in>spectrum A.\n                 0 \\<le> Va a w \\<and> Va a w \\<le> 1) \\<and>\n             (\\<Sum>a\\<in>spectrum A. Va a w) = 1 \\<longrightarrow>\n             \\<bar>\\<Sum>a\\<in>spectrum A. Re a * Va a w\\<bar> \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["", "definition qt_expect where\n\"qt_expect A Va = (\\<lambda>w. (\\<Sum>a\\<in>spectrum A. Re a * Va a w))\""], ["", "lemma (in cpx_sq_mat) spectr_sum_integrable:\nassumes \"lhv M A B R Va Vb\"\nshows \"integrable M (\\<lambda>w. qt_expect A Va w * qt_expect B Vb w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integrable M (\\<lambda>w. qt_expect A Va w * qt_expect B Vb w)", "proof (rule Bochner_Integration.integrable_cong[THEN iffD2])"], ["proof (state)\ngoal (3 subgoals):\n 1. M = ?N1\n 2. \\<And>x.\n       x \\<in> space ?N1 \\<Longrightarrow>\n       qt_expect A Va x * qt_expect B Vb x = ?g1 x\n 3. integrable ?N1 ?g1", "show \"M = M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M = M", "by simp"], ["proof (state)\nthis:\n  M = M\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> space M \\<Longrightarrow>\n       qt_expect A Va x * qt_expect B Vb x = ?g1 x\n 2. integrable M ?g1", "show \"\\<And>w. w \\<in> space M \\<Longrightarrow> qt_expect A Va w * qt_expect B Vb w = \n    (\\<Sum>a\\<in>spectrum A. (\\<Sum>b\\<in>spectrum B. Re a * Va a w * Re b * Vb b w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<in> space M \\<Longrightarrow>\n       qt_expect A Va w * qt_expect B Vb w =\n       (\\<Sum>a\\<in>spectrum A.\n          \\<Sum>b\\<in>spectrum B. Re a * Va a w * Re b * Vb b w)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<in> space M \\<Longrightarrow>\n       qt_expect A Va w * qt_expect B Vb w =\n       (\\<Sum>a\\<in>spectrum A.\n          \\<Sum>b\\<in>spectrum B. Re a * Va a w * Re b * Vb b w)", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<in> space M \\<Longrightarrow>\n       qt_expect A Va w * qt_expect B Vb w =\n       (\\<Sum>a\\<in>spectrum A.\n          \\<Sum>b\\<in>spectrum B. Re a * Va a w * Re b * Vb b w)", "assume \"w\\<in> space M\""], ["proof (state)\nthis:\n  w \\<in> space M\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<in> space M \\<Longrightarrow>\n       qt_expect A Va w * qt_expect B Vb w =\n       (\\<Sum>a\\<in>spectrum A.\n          \\<Sum>b\\<in>spectrum B. Re a * Va a w * Re b * Vb b w)", "show \"qt_expect A Va w * qt_expect B Vb w = \n      (\\<Sum>a\\<in>spectrum A. (\\<Sum>b\\<in>spectrum B. Re a * Va a w * Re b * Vb b w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qt_expect A Va w * qt_expect B Vb w =\n    (\\<Sum>a\\<in>spectrum A.\n       \\<Sum>b\\<in>spectrum B. Re a * Va a w * Re b * Vb b w)", "unfolding qt_expect_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A. Re a * Va a w) *\n    (\\<Sum>a\\<in>spectrum B. Re a * Vb a w) =\n    (\\<Sum>a\\<in>spectrum A.\n       \\<Sum>b\\<in>spectrum B. Re a * Va a w * Re b * Vb b w)", "by (metis (mono_tags, lifting) Finite_Cartesian_Product.sum_cong_aux sum_product \n          vector_space_over_itself.scale_scale)"], ["proof (state)\nthis:\n  qt_expect A Va w * qt_expect B Vb w =\n  (\\<Sum>a\\<in>spectrum A.\n     \\<Sum>b\\<in>spectrum B. Re a * Va a w * Re b * Vb b w)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?w3 \\<in> space M \\<Longrightarrow>\n  qt_expect A Va ?w3 * qt_expect B Vb ?w3 =\n  (\\<Sum>a\\<in>spectrum A.\n     \\<Sum>b\\<in>spectrum B. Re a * Va a ?w3 * Re b * Vb b ?w3)\n\ngoal (1 subgoal):\n 1. integrable M\n     (\\<lambda>x.\n         \\<Sum>a\\<in>spectrum A.\n           \\<Sum>b\\<in>spectrum B. Re a * Va a x * Re b * Vb b x)", "show \"integrable M (\\<lambda>w. \\<Sum>a\\<in>spectrum A. (\\<Sum>b\\<in>spectrum B. Re a * Va a w * Re b * Vb b w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integrable M\n     (\\<lambda>w.\n         \\<Sum>a\\<in>spectrum A.\n           \\<Sum>b\\<in>spectrum B. Re a * Va a w * Re b * Vb b w)", "using lhv_sum_integrable[of M] assms"], ["proof (prove)\nusing this:\n  lhv M ?A ?B ?R ?XA ?XB \\<Longrightarrow>\n  integrable M\n   (\\<lambda>w.\n       \\<Sum>a\\<in>spectrum ?A.\n         \\<Sum>b\\<in>spectrum ?B. ?f a * ?XA a w * ?g b * ?XB b w)\n  lhv M A B R Va Vb\n\ngoal (1 subgoal):\n 1. integrable M\n     (\\<lambda>w.\n         \\<Sum>a\\<in>spectrum A.\n           \\<Sum>b\\<in>spectrum B. Re a * Va a w * Re b * Vb b w)", "by simp"], ["proof (state)\nthis:\n  integrable M\n   (\\<lambda>w.\n       \\<Sum>a\\<in>spectrum A.\n         \\<Sum>b\\<in>spectrum B. Re a * Va a w * Re b * Vb b w)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in cpx_sq_mat) lhv_sum_integral':\n  assumes \"lhv M A B R XA XB\"\nshows \"integral\\<^sup>L M (\\<lambda>w. (\\<Sum> a \\<in> spectrum A. f a * XA a w) * (\\<Sum> b \\<in> spectrum B. g b * XB b w)) =\n  (\\<Sum> a \\<in> spectrum A. f a * (\\<Sum> b \\<in> spectrum B. g b  * integral\\<^sup>L M (\\<lambda>w. XA a w * XB b w)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT w|M.\n       (\\<Sum>a\\<in>spectrum A. f a * XA a w) *\n       (\\<Sum>b\\<in>spectrum B. g b * XB b w) =\n    (\\<Sum>a\\<in>spectrum A.\n       f a * (\\<Sum>b\\<in>spectrum B. g b * (LINT w|M. XA a w * XB b w)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LINT w|M.\n       (\\<Sum>a\\<in>spectrum A. f a * XA a w) *\n       (\\<Sum>b\\<in>spectrum B. g b * XB b w) =\n    (\\<Sum>a\\<in>spectrum A.\n       f a * (\\<Sum>b\\<in>spectrum B. g b * (LINT w|M. XA a w * XB b w)))", "have \"integral\\<^sup>L M (\\<lambda>w. (\\<Sum> a \\<in> spectrum A. f a * XA a w) * (\\<Sum> b \\<in> spectrum B. g b * XB b w)) =\n    integral\\<^sup>L M (\\<lambda>w. (\\<Sum> a \\<in> spectrum A. (\\<Sum> b \\<in> spectrum B. f a * XA a w * g b * XB b w)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT w|M.\n       (\\<Sum>a\\<in>spectrum A. f a * XA a w) *\n       (\\<Sum>b\\<in>spectrum B. g b * XB b w) =\n    LINT w|M.\n       (\\<Sum>a\\<in>spectrum A.\n          \\<Sum>b\\<in>spectrum B. f a * XA a w * g b * XB b w)", "proof (rule Bochner_Integration.integral_cong, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space M \\<Longrightarrow>\n       (\\<Sum>a\\<in>spectrum A. f a * XA a x) *\n       (\\<Sum>b\\<in>spectrum B. g b * XB b x) =\n       (\\<Sum>a\\<in>spectrum A.\n          \\<Sum>b\\<in>spectrum B. f a * XA a x * g b * XB b x)", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space M \\<Longrightarrow>\n       (\\<Sum>a\\<in>spectrum A. f a * XA a x) *\n       (\\<Sum>b\\<in>spectrum B. g b * XB b x) =\n       (\\<Sum>a\\<in>spectrum A.\n          \\<Sum>b\\<in>spectrum B. f a * XA a x * g b * XB b x)", "assume \"w\\<in> space M\""], ["proof (state)\nthis:\n  w \\<in> space M\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space M \\<Longrightarrow>\n       (\\<Sum>a\\<in>spectrum A. f a * XA a x) *\n       (\\<Sum>b\\<in>spectrum B. g b * XB b x) =\n       (\\<Sum>a\\<in>spectrum A.\n          \\<Sum>b\\<in>spectrum B. f a * XA a x * g b * XB b x)", "show \"(\\<Sum>a\\<in>spectrum A. f a * XA a w) * (\\<Sum>b\\<in>spectrum B. g b * XB b w) = \n      (\\<Sum>a\\<in>spectrum A. (\\<Sum>b\\<in>spectrum B. f a * XA a w * (g b) * XB b w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A. f a * XA a w) *\n    (\\<Sum>b\\<in>spectrum B. g b * XB b w) =\n    (\\<Sum>a\\<in>spectrum A.\n       \\<Sum>b\\<in>spectrum B. f a * XA a w * g b * XB b w)", "by (simp add: sum_product vector_space_over_itself.scale_scale)"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>spectrum A. f a * XA a w) *\n  (\\<Sum>b\\<in>spectrum B. g b * XB b w) =\n  (\\<Sum>a\\<in>spectrum A.\n     \\<Sum>b\\<in>spectrum B. f a * XA a w * g b * XB b w)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LINT w|M.\n     (\\<Sum>a\\<in>spectrum A. f a * XA a w) *\n     (\\<Sum>b\\<in>spectrum B. g b * XB b w) =\n  LINT w|M.\n     (\\<Sum>a\\<in>spectrum A.\n        \\<Sum>b\\<in>spectrum B. f a * XA a w * g b * XB b w)\n\ngoal (1 subgoal):\n 1. LINT w|M.\n       (\\<Sum>a\\<in>spectrum A. f a * XA a w) *\n       (\\<Sum>b\\<in>spectrum B. g b * XB b w) =\n    (\\<Sum>a\\<in>spectrum A.\n       f a * (\\<Sum>b\\<in>spectrum B. g b * (LINT w|M. XA a w * XB b w)))", "also"], ["proof (state)\nthis:\n  LINT w|M.\n     (\\<Sum>a\\<in>spectrum A. f a * XA a w) *\n     (\\<Sum>b\\<in>spectrum B. g b * XB b w) =\n  LINT w|M.\n     (\\<Sum>a\\<in>spectrum A.\n        \\<Sum>b\\<in>spectrum B. f a * XA a w * g b * XB b w)\n\ngoal (1 subgoal):\n 1. LINT w|M.\n       (\\<Sum>a\\<in>spectrum A. f a * XA a w) *\n       (\\<Sum>b\\<in>spectrum B. g b * XB b w) =\n    (\\<Sum>a\\<in>spectrum A.\n       f a * (\\<Sum>b\\<in>spectrum B. g b * (LINT w|M. XA a w * XB b w)))", "have \"... = (\\<Sum> a \\<in> spectrum A. \n    integral\\<^sup>L M (\\<lambda>w. (\\<Sum> b \\<in> spectrum B. f a * XA a w * g b * XB b w)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT w|M.\n       (\\<Sum>a\\<in>spectrum A.\n          \\<Sum>b\\<in>spectrum B. f a * XA a w * g b * XB b w) =\n    (\\<Sum>a\\<in>spectrum A.\n       LINT w|M. (\\<Sum>b\\<in>spectrum B. f a * XA a w * g b * XB b w))", "proof (rule Bochner_Integration.integral_sum)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> spectrum A \\<Longrightarrow>\n       integrable M\n        (\\<lambda>x. \\<Sum>b\\<in>spectrum B. f a * XA a x * g b * XB b x)", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> spectrum A \\<Longrightarrow>\n       integrable M\n        (\\<lambda>x. \\<Sum>b\\<in>spectrum B. f a * XA a x * g b * XB b x)", "assume \"a\\<in> spectrum A\""], ["proof (state)\nthis:\n  a \\<in> spectrum A\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> spectrum A \\<Longrightarrow>\n       integrable M\n        (\\<lambda>x. \\<Sum>b\\<in>spectrum B. f a * XA a x * g b * XB b x)", "thus \"integrable M (\\<lambda>x. \\<Sum>b\\<in>spectrum B. f a * XA a x * g b * XB b x)\""], ["proof (prove)\nusing this:\n  a \\<in> spectrum A\n\ngoal (1 subgoal):\n 1. integrable M\n     (\\<lambda>x. \\<Sum>b\\<in>spectrum B. f a * XA a x * g b * XB b x)", "using lhv_lsum_scal_integrable[of M] assms"], ["proof (prove)\nusing this:\n  a \\<in> spectrum A\n  \\<lbrakk>lhv M ?A ?B ?R ?XA ?XB; ?a \\<in> spectrum ?A\\<rbrakk>\n  \\<Longrightarrow> integrable M\n                     (\\<lambda>x.\n                         \\<Sum>b\\<in>spectrum ?B.\n                           ?c * ?XA ?a x * ?f b * ?XB b x)\n  lhv M A B R XA XB\n\ngoal (1 subgoal):\n 1. integrable M\n     (\\<lambda>x. \\<Sum>b\\<in>spectrum B. f a * XA a x * g b * XB b x)", "by simp"], ["proof (state)\nthis:\n  integrable M\n   (\\<lambda>x. \\<Sum>b\\<in>spectrum B. f a * XA a x * g b * XB b x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LINT w|M.\n     (\\<Sum>a\\<in>spectrum A.\n        \\<Sum>b\\<in>spectrum B. f a * XA a w * g b * XB b w) =\n  (\\<Sum>a\\<in>spectrum A.\n     LINT w|M. (\\<Sum>b\\<in>spectrum B. f a * XA a w * g b * XB b w))\n\ngoal (1 subgoal):\n 1. LINT w|M.\n       (\\<Sum>a\\<in>spectrum A. f a * XA a w) *\n       (\\<Sum>b\\<in>spectrum B. g b * XB b w) =\n    (\\<Sum>a\\<in>spectrum A.\n       f a * (\\<Sum>b\\<in>spectrum B. g b * (LINT w|M. XA a w * XB b w)))", "also"], ["proof (state)\nthis:\n  LINT w|M.\n     (\\<Sum>a\\<in>spectrum A.\n        \\<Sum>b\\<in>spectrum B. f a * XA a w * g b * XB b w) =\n  (\\<Sum>a\\<in>spectrum A.\n     LINT w|M. (\\<Sum>b\\<in>spectrum B. f a * XA a w * g b * XB b w))\n\ngoal (1 subgoal):\n 1. LINT w|M.\n       (\\<Sum>a\\<in>spectrum A. f a * XA a w) *\n       (\\<Sum>b\\<in>spectrum B. g b * XB b w) =\n    (\\<Sum>a\\<in>spectrum A.\n       f a * (\\<Sum>b\\<in>spectrum B. g b * (LINT w|M. XA a w * XB b w)))", "have \"... = (\\<Sum> a \\<in> spectrum A. f a *\n    integral\\<^sup>L M (\\<lambda>w. (\\<Sum> b \\<in> spectrum B. XA a w * g b * XB b w)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A.\n       LINT w|M. (\\<Sum>b\\<in>spectrum B. f a * XA a w * g b * XB b w)) =\n    (\\<Sum>a\\<in>spectrum A.\n       f a * (LINT w|M. (\\<Sum>b\\<in>spectrum B. XA a w * g b * XB b w)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A.\n       LINT w|M. (\\<Sum>b\\<in>spectrum B. f a * XA a w * g b * XB b w)) =\n    (\\<Sum>a\\<in>spectrum A.\n       f a * (LINT w|M. (\\<Sum>b\\<in>spectrum B. XA a w * g b * XB b w)))", "have \"\\<forall> a\\<in> spectrum A. integral\\<^sup>L M (\\<lambda>w. (\\<Sum> b \\<in> spectrum B. f a * XA a w * g b * XB b w)) =\n      f a * integral\\<^sup>L M (\\<lambda>w. (\\<Sum> b \\<in> spectrum B. XA a w * g b * XB b w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>spectrum A.\n       LINT w|M. (\\<Sum>b\\<in>spectrum B. f a * XA a w * g b * XB b w) =\n       f a * (LINT w|M. (\\<Sum>b\\<in>spectrum B. XA a w * g b * XB b w))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> spectrum A \\<Longrightarrow>\n       LINT w|M. (\\<Sum>b\\<in>spectrum B. f a * XA a w * g b * XB b w) =\n       f a * (LINT w|M. (\\<Sum>b\\<in>spectrum B. XA a w * g b * XB b w))", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> spectrum A \\<Longrightarrow>\n       LINT w|M. (\\<Sum>b\\<in>spectrum B. f a * XA a w * g b * XB b w) =\n       f a * (LINT w|M. (\\<Sum>b\\<in>spectrum B. XA a w * g b * XB b w))", "assume \"a\\<in> spectrum A\""], ["proof (state)\nthis:\n  a \\<in> spectrum A\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> spectrum A \\<Longrightarrow>\n       LINT w|M. (\\<Sum>b\\<in>spectrum B. f a * XA a w * g b * XB b w) =\n       f a * (LINT w|M. (\\<Sum>b\\<in>spectrum B. XA a w * g b * XB b w))", "have \"(LINT w|M. (\\<Sum>b\\<in>spectrum B. f a * XA a w * g b * XB b w)) = \n        (LINT w|M. f a* (\\<Sum>b\\<in>spectrum B. XA a w * g b * XB b w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT w|M. (\\<Sum>b\\<in>spectrum B. f a * XA a w * g b * XB b w) =\n    LINT w|M. f a * (\\<Sum>b\\<in>spectrum B. XA a w * g b * XB b w)", "proof (rule Bochner_Integration.integral_cong, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space M \\<Longrightarrow>\n       (\\<Sum>b\\<in>spectrum B. f a * XA a x * g b * XB b x) =\n       f a * (\\<Sum>b\\<in>spectrum B. XA a x * g b * XB b x)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space M \\<Longrightarrow>\n       (\\<Sum>b\\<in>spectrum B. f a * XA a x * g b * XB b x) =\n       f a * (\\<Sum>b\\<in>spectrum B. XA a x * g b * XB b x)", "assume \"x \\<in> space M\""], ["proof (state)\nthis:\n  x \\<in> space M\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space M \\<Longrightarrow>\n       (\\<Sum>b\\<in>spectrum B. f a * XA a x * g b * XB b x) =\n       f a * (\\<Sum>b\\<in>spectrum B. XA a x * g b * XB b x)", "show \"(\\<Sum>b\\<in>spectrum B. f a * XA a x * g b * XB b x) = \n          f a * (\\<Sum>b\\<in>spectrum B. XA a x * g b * XB b x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>spectrum B. f a * XA a x * g b * XB b x) =\n    f a * (\\<Sum>b\\<in>spectrum B. XA a x * g b * XB b x)", "by (metis (no_types, lifting) Finite_Cartesian_Product.sum_cong_aux \n              vector_space_over_itself.scale_scale vector_space_over_itself.scale_sum_right)"], ["proof (state)\nthis:\n  (\\<Sum>b\\<in>spectrum B. f a * XA a x * g b * XB b x) =\n  f a * (\\<Sum>b\\<in>spectrum B. XA a x * g b * XB b x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LINT w|M. (\\<Sum>b\\<in>spectrum B. f a * XA a w * g b * XB b w) =\n  LINT w|M. f a * (\\<Sum>b\\<in>spectrum B. XA a w * g b * XB b w)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> spectrum A \\<Longrightarrow>\n       LINT w|M. (\\<Sum>b\\<in>spectrum B. f a * XA a w * g b * XB b w) =\n       f a * (LINT w|M. (\\<Sum>b\\<in>spectrum B. XA a w * g b * XB b w))", "also"], ["proof (state)\nthis:\n  LINT w|M. (\\<Sum>b\\<in>spectrum B. f a * XA a w * g b * XB b w) =\n  LINT w|M. f a * (\\<Sum>b\\<in>spectrum B. XA a w * g b * XB b w)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> spectrum A \\<Longrightarrow>\n       LINT w|M. (\\<Sum>b\\<in>spectrum B. f a * XA a w * g b * XB b w) =\n       f a * (LINT w|M. (\\<Sum>b\\<in>spectrum B. XA a w * g b * XB b w))", "have \"... = f a * (LINT w|M. (\\<Sum>b\\<in>spectrum B. XA a w * g b * XB b w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT w|M. f a * (\\<Sum>b\\<in>spectrum B. XA a w * g b * XB b w) =\n    f a * (LINT w|M. (\\<Sum>b\\<in>spectrum B. XA a w * g b * XB b w))", "by simp"], ["proof (state)\nthis:\n  LINT w|M. f a * (\\<Sum>b\\<in>spectrum B. XA a w * g b * XB b w) =\n  f a * (LINT w|M. (\\<Sum>b\\<in>spectrum B. XA a w * g b * XB b w))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> spectrum A \\<Longrightarrow>\n       LINT w|M. (\\<Sum>b\\<in>spectrum B. f a * XA a w * g b * XB b w) =\n       f a * (LINT w|M. (\\<Sum>b\\<in>spectrum B. XA a w * g b * XB b w))", "finally"], ["proof (chain)\npicking this:\n  LINT w|M. (\\<Sum>b\\<in>spectrum B. f a * XA a w * g b * XB b w) =\n  f a * (LINT w|M. (\\<Sum>b\\<in>spectrum B. XA a w * g b * XB b w))", "show \"(LINT w|M. (\\<Sum>b\\<in>spectrum B. f a * XA a w * g b * XB b w)) = \n        f a * (LINT w|M. (\\<Sum>b\\<in>spectrum B. XA a w * g b * XB b w))\""], ["proof (prove)\nusing this:\n  LINT w|M. (\\<Sum>b\\<in>spectrum B. f a * XA a w * g b * XB b w) =\n  f a * (LINT w|M. (\\<Sum>b\\<in>spectrum B. XA a w * g b * XB b w))\n\ngoal (1 subgoal):\n 1. LINT w|M. (\\<Sum>b\\<in>spectrum B. f a * XA a w * g b * XB b w) =\n    f a * (LINT w|M. (\\<Sum>b\\<in>spectrum B. XA a w * g b * XB b w))", "."], ["proof (state)\nthis:\n  LINT w|M. (\\<Sum>b\\<in>spectrum B. f a * XA a w * g b * XB b w) =\n  f a * (LINT w|M. (\\<Sum>b\\<in>spectrum B. XA a w * g b * XB b w))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>a\\<in>spectrum A.\n     LINT w|M. (\\<Sum>b\\<in>spectrum B. f a * XA a w * g b * XB b w) =\n     f a * (LINT w|M. (\\<Sum>b\\<in>spectrum B. XA a w * g b * XB b w))\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A.\n       LINT w|M. (\\<Sum>b\\<in>spectrum B. f a * XA a w * g b * XB b w)) =\n    (\\<Sum>a\\<in>spectrum A.\n       f a * (LINT w|M. (\\<Sum>b\\<in>spectrum B. XA a w * g b * XB b w)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>spectrum A.\n     LINT w|M. (\\<Sum>b\\<in>spectrum B. f a * XA a w * g b * XB b w) =\n     f a * (LINT w|M. (\\<Sum>b\\<in>spectrum B. XA a w * g b * XB b w))\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A.\n       LINT w|M. (\\<Sum>b\\<in>spectrum B. f a * XA a w * g b * XB b w)) =\n    (\\<Sum>a\\<in>spectrum A.\n       f a * (LINT w|M. (\\<Sum>b\\<in>spectrum B. XA a w * g b * XB b w)))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>spectrum A.\n     LINT w|M. (\\<Sum>b\\<in>spectrum B. f a * XA a w * g b * XB b w)) =\n  (\\<Sum>a\\<in>spectrum A.\n     f a * (LINT w|M. (\\<Sum>b\\<in>spectrum B. XA a w * g b * XB b w)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>spectrum A.\n     LINT w|M. (\\<Sum>b\\<in>spectrum B. f a * XA a w * g b * XB b w)) =\n  (\\<Sum>a\\<in>spectrum A.\n     f a * (LINT w|M. (\\<Sum>b\\<in>spectrum B. XA a w * g b * XB b w)))\n\ngoal (1 subgoal):\n 1. LINT w|M.\n       (\\<Sum>a\\<in>spectrum A. f a * XA a w) *\n       (\\<Sum>b\\<in>spectrum B. g b * XB b w) =\n    (\\<Sum>a\\<in>spectrum A.\n       f a * (\\<Sum>b\\<in>spectrum B. g b * (LINT w|M. XA a w * XB b w)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>spectrum A.\n     LINT w|M. (\\<Sum>b\\<in>spectrum B. f a * XA a w * g b * XB b w)) =\n  (\\<Sum>a\\<in>spectrum A.\n     f a * (LINT w|M. (\\<Sum>b\\<in>spectrum B. XA a w * g b * XB b w)))\n\ngoal (1 subgoal):\n 1. LINT w|M.\n       (\\<Sum>a\\<in>spectrum A. f a * XA a w) *\n       (\\<Sum>b\\<in>spectrum B. g b * XB b w) =\n    (\\<Sum>a\\<in>spectrum A.\n       f a * (\\<Sum>b\\<in>spectrum B. g b * (LINT w|M. XA a w * XB b w)))", "have \"... = (\\<Sum> a \\<in> spectrum A. f a * (\\<Sum> b \\<in> spectrum B. g b *\n    integral\\<^sup>L M (\\<lambda>w. XA a w * XB b w)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A.\n       f a * (LINT w|M. (\\<Sum>b\\<in>spectrum B. XA a w * g b * XB b w))) =\n    (\\<Sum>a\\<in>spectrum A.\n       f a * (\\<Sum>b\\<in>spectrum B. g b * (LINT w|M. XA a w * XB b w)))", "proof (rule sum.cong, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum A \\<Longrightarrow>\n       f x * (LINT w|M. (\\<Sum>b\\<in>spectrum B. XA x w * g b * XB b w)) =\n       f x * (\\<Sum>b\\<in>spectrum B. g b * (LINT w|M. XA x w * XB b w))", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum A \\<Longrightarrow>\n       f x * (LINT w|M. (\\<Sum>b\\<in>spectrum B. XA x w * g b * XB b w)) =\n       f x * (\\<Sum>b\\<in>spectrum B. g b * (LINT w|M. XA x w * XB b w))", "assume \"a\\<in> spectrum A\""], ["proof (state)\nthis:\n  a \\<in> spectrum A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum A \\<Longrightarrow>\n       f x * (LINT w|M. (\\<Sum>b\\<in>spectrum B. XA x w * g b * XB b w)) =\n       f x * (\\<Sum>b\\<in>spectrum B. g b * (LINT w|M. XA x w * XB b w))", "have \"integral\\<^sup>L M (\\<lambda>w. (\\<Sum> b \\<in> spectrum B. XA a w * g b * XB b w)) = (\\<Sum> b \\<in> spectrum B. \n      integral\\<^sup>L M (\\<lambda>w. XA a w * g b * XB b w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT w|M. (\\<Sum>b\\<in>spectrum B. XA a w * g b * XB b w) =\n    (\\<Sum>b\\<in>spectrum B. LINT w|M. XA a w * g b * XB b w)", "proof (rule Bochner_Integration.integral_sum)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> spectrum B \\<Longrightarrow>\n       integrable M (\\<lambda>x. XA a x * g b * XB b x)", "show \"\\<And>b. b \\<in> spectrum B \\<Longrightarrow> integrable M (\\<lambda>x. XA a x * g b * XB b x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> spectrum B \\<Longrightarrow>\n       integrable M (\\<lambda>x. XA a x * g b * XB b x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> spectrum B \\<Longrightarrow>\n       integrable M (\\<lambda>x. XA a x * g b * XB b x)", "fix b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> spectrum B \\<Longrightarrow>\n       integrable M (\\<lambda>x. XA a x * g b * XB b x)", "assume \"b\\<in> spectrum B\""], ["proof (state)\nthis:\n  b \\<in> spectrum B\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> spectrum B \\<Longrightarrow>\n       integrable M (\\<lambda>x. XA a x * g b * XB b x)", "thus \"integrable M (\\<lambda>x. XA a x * g b * XB b x)\""], ["proof (prove)\nusing this:\n  b \\<in> spectrum B\n\ngoal (1 subgoal):\n 1. integrable M (\\<lambda>x. XA a x * g b * XB b x)", "using assms lhv_scal_integrable[of M _ _ _ _ _ a b 1] \\<open>a\\<in> spectrum A\\<close>"], ["proof (prove)\nusing this:\n  b \\<in> spectrum B\n  lhv M A B R XA XB\n  \\<lbrakk>lhv M ?A ?B ?R ?XA ?XB; a \\<in> spectrum ?A;\n   b \\<in> spectrum ?B\\<rbrakk>\n  \\<Longrightarrow> integrable M (\\<lambda>w. 1 * ?XA a w * ?d * ?XB b w)\n  a \\<in> spectrum A\n\ngoal (1 subgoal):\n 1. integrable M (\\<lambda>x. XA a x * g b * XB b x)", "by simp"], ["proof (state)\nthis:\n  integrable M (\\<lambda>x. XA a x * g b * XB b x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?b3 \\<in> spectrum B \\<Longrightarrow>\n  integrable M (\\<lambda>x. XA a x * g ?b3 * XB ?b3 x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LINT w|M. (\\<Sum>b\\<in>spectrum B. XA a w * g b * XB b w) =\n  (\\<Sum>b\\<in>spectrum B. LINT w|M. XA a w * g b * XB b w)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum A \\<Longrightarrow>\n       f x * (LINT w|M. (\\<Sum>b\\<in>spectrum B. XA x w * g b * XB b w)) =\n       f x * (\\<Sum>b\\<in>spectrum B. g b * (LINT w|M. XA x w * XB b w))", "also"], ["proof (state)\nthis:\n  LINT w|M. (\\<Sum>b\\<in>spectrum B. XA a w * g b * XB b w) =\n  (\\<Sum>b\\<in>spectrum B. LINT w|M. XA a w * g b * XB b w)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum A \\<Longrightarrow>\n       f x * (LINT w|M. (\\<Sum>b\\<in>spectrum B. XA x w * g b * XB b w)) =\n       f x * (\\<Sum>b\\<in>spectrum B. g b * (LINT w|M. XA x w * XB b w))", "have \"... = (\\<Sum> b \\<in> spectrum B. g b * integral\\<^sup>L M (\\<lambda>w. XA a w * XB b w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>spectrum B. LINT w|M. XA a w * g b * XB b w) =\n    (\\<Sum>b\\<in>spectrum B. g b * (LINT w|M. XA a w * XB b w))", "proof (rule sum.cong, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum B \\<Longrightarrow>\n       LINT w|M. XA a w * g x * XB x w = g x * (LINT w|M. XA a w * XB x w)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum B \\<Longrightarrow>\n       LINT w|M. XA a w * g x * XB x w = g x * (LINT w|M. XA a w * XB x w)", "assume \"x\\<in> spectrum B\""], ["proof (state)\nthis:\n  x \\<in> spectrum B\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum B \\<Longrightarrow>\n       LINT w|M. XA a w * g x * XB x w = g x * (LINT w|M. XA a w * XB x w)", "have \"LINT w|M. XA a w * g x * XB x w = LINT w|M. g x * (XA a w * XB x w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT w|M. XA a w * g x * XB x w = LINT w|M. g x * (XA a w * XB x w)", "by (rule Bochner_Integration.integral_cong, auto)"], ["proof (state)\nthis:\n  LINT w|M. XA a w * g x * XB x w = LINT w|M. g x * (XA a w * XB x w)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum B \\<Longrightarrow>\n       LINT w|M. XA a w * g x * XB x w = g x * (LINT w|M. XA a w * XB x w)", "also"], ["proof (state)\nthis:\n  LINT w|M. XA a w * g x * XB x w = LINT w|M. g x * (XA a w * XB x w)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum B \\<Longrightarrow>\n       LINT w|M. XA a w * g x * XB x w = g x * (LINT w|M. XA a w * XB x w)", "have \"... = g x * (LINT w|M. XA a w * XB x w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT w|M. g x * (XA a w * XB x w) = g x * (LINT w|M. XA a w * XB x w)", "using Bochner_Integration.integral_mult_right_zero[of M \"g x\" \"\\<lambda>w. XA a w * XB x w\"]"], ["proof (prove)\nusing this:\n  LINT xa|M. g x * (XA a xa * XB x xa) = g x * (LINT w|M. XA a w * XB x w)\n\ngoal (1 subgoal):\n 1. LINT w|M. g x * (XA a w * XB x w) = g x * (LINT w|M. XA a w * XB x w)", "by simp"], ["proof (state)\nthis:\n  LINT w|M. g x * (XA a w * XB x w) = g x * (LINT w|M. XA a w * XB x w)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum B \\<Longrightarrow>\n       LINT w|M. XA a w * g x * XB x w = g x * (LINT w|M. XA a w * XB x w)", "finally"], ["proof (chain)\npicking this:\n  LINT w|M. XA a w * g x * XB x w = g x * (LINT w|M. XA a w * XB x w)", "show \"LINT w|M. XA a w * g x * XB x w = g x * (LINT w|M. XA a w * XB x w)\""], ["proof (prove)\nusing this:\n  LINT w|M. XA a w * g x * XB x w = g x * (LINT w|M. XA a w * XB x w)\n\ngoal (1 subgoal):\n 1. LINT w|M. XA a w * g x * XB x w = g x * (LINT w|M. XA a w * XB x w)", "."], ["proof (state)\nthis:\n  LINT w|M. XA a w * g x * XB x w = g x * (LINT w|M. XA a w * XB x w)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>b\\<in>spectrum B. LINT w|M. XA a w * g b * XB b w) =\n  (\\<Sum>b\\<in>spectrum B. g b * (LINT w|M. XA a w * XB b w))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum A \\<Longrightarrow>\n       f x * (LINT w|M. (\\<Sum>b\\<in>spectrum B. XA x w * g b * XB b w)) =\n       f x * (\\<Sum>b\\<in>spectrum B. g b * (LINT w|M. XA x w * XB b w))", "finally"], ["proof (chain)\npicking this:\n  LINT w|M. (\\<Sum>b\\<in>spectrum B. XA a w * g b * XB b w) =\n  (\\<Sum>b\\<in>spectrum B. g b * (LINT w|M. XA a w * XB b w))", "have \"integral\\<^sup>L M (\\<lambda>w. (\\<Sum> b \\<in> spectrum B. XA a w * g b * XB b w)) = \n        (\\<Sum> b \\<in> spectrum B. g b * integral\\<^sup>L M (\\<lambda>w. XA a w * XB b w))\""], ["proof (prove)\nusing this:\n  LINT w|M. (\\<Sum>b\\<in>spectrum B. XA a w * g b * XB b w) =\n  (\\<Sum>b\\<in>spectrum B. g b * (LINT w|M. XA a w * XB b w))\n\ngoal (1 subgoal):\n 1. LINT w|M. (\\<Sum>b\\<in>spectrum B. XA a w * g b * XB b w) =\n    (\\<Sum>b\\<in>spectrum B. g b * (LINT w|M. XA a w * XB b w))", "."], ["proof (state)\nthis:\n  LINT w|M. (\\<Sum>b\\<in>spectrum B. XA a w * g b * XB b w) =\n  (\\<Sum>b\\<in>spectrum B. g b * (LINT w|M. XA a w * XB b w))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum A \\<Longrightarrow>\n       f x * (LINT w|M. (\\<Sum>b\\<in>spectrum B. XA x w * g b * XB b w)) =\n       f x * (\\<Sum>b\\<in>spectrum B. g b * (LINT w|M. XA x w * XB b w))", "thus \"f a * (LINT w|M. (\\<Sum>b\\<in>spectrum B. XA a w * g b * XB b w)) =\n        f a * (\\<Sum> b \\<in> spectrum B. g b * integral\\<^sup>L M (\\<lambda>w. XA a w * XB b w))\""], ["proof (prove)\nusing this:\n  LINT w|M. (\\<Sum>b\\<in>spectrum B. XA a w * g b * XB b w) =\n  (\\<Sum>b\\<in>spectrum B. g b * (LINT w|M. XA a w * XB b w))\n\ngoal (1 subgoal):\n 1. f a * (LINT w|M. (\\<Sum>b\\<in>spectrum B. XA a w * g b * XB b w)) =\n    f a * (\\<Sum>b\\<in>spectrum B. g b * (LINT w|M. XA a w * XB b w))", "by simp"], ["proof (state)\nthis:\n  f a * (LINT w|M. (\\<Sum>b\\<in>spectrum B. XA a w * g b * XB b w)) =\n  f a * (\\<Sum>b\\<in>spectrum B. g b * (LINT w|M. XA a w * XB b w))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>spectrum A.\n     f a * (LINT w|M. (\\<Sum>b\\<in>spectrum B. XA a w * g b * XB b w))) =\n  (\\<Sum>a\\<in>spectrum A.\n     f a * (\\<Sum>b\\<in>spectrum B. g b * (LINT w|M. XA a w * XB b w)))\n\ngoal (1 subgoal):\n 1. LINT w|M.\n       (\\<Sum>a\\<in>spectrum A. f a * XA a w) *\n       (\\<Sum>b\\<in>spectrum B. g b * XB b w) =\n    (\\<Sum>a\\<in>spectrum A.\n       f a * (\\<Sum>b\\<in>spectrum B. g b * (LINT w|M. XA a w * XB b w)))", "finally"], ["proof (chain)\npicking this:\n  LINT w|M.\n     (\\<Sum>a\\<in>spectrum A. f a * XA a w) *\n     (\\<Sum>b\\<in>spectrum B. g b * XB b w) =\n  (\\<Sum>a\\<in>spectrum A.\n     f a * (\\<Sum>b\\<in>spectrum B. g b * (LINT w|M. XA a w * XB b w)))", "show ?thesis"], ["proof (prove)\nusing this:\n  LINT w|M.\n     (\\<Sum>a\\<in>spectrum A. f a * XA a w) *\n     (\\<Sum>b\\<in>spectrum B. g b * XB b w) =\n  (\\<Sum>a\\<in>spectrum A.\n     f a * (\\<Sum>b\\<in>spectrum B. g b * (LINT w|M. XA a w * XB b w)))\n\ngoal (1 subgoal):\n 1. LINT w|M.\n       (\\<Sum>a\\<in>spectrum A. f a * XA a w) *\n       (\\<Sum>b\\<in>spectrum B. g b * XB b w) =\n    (\\<Sum>a\\<in>spectrum A.\n       f a * (\\<Sum>b\\<in>spectrum B. g b * (LINT w|M. XA a w * XB b w)))", "."], ["proof (state)\nthis:\n  LINT w|M.\n     (\\<Sum>a\\<in>spectrum A. f a * XA a w) *\n     (\\<Sum>b\\<in>spectrum B. g b * XB b w) =\n  (\\<Sum>a\\<in>spectrum A.\n     f a * (\\<Sum>b\\<in>spectrum B. g b * (LINT w|M. XA a w * XB b w)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in cpx_sq_mat) sum_qt_expect_trace:\n  assumes \"lhv M A B R XA XB\"\n  shows \"(\\<Sum> a \\<in> spectrum A. f a * (\\<Sum> b \\<in> spectrum B. g b * integral\\<^sup>L M (\\<lambda>w. XA a w * XB b w))) =\n    (\\<Sum> a \\<in> spectrum A. f a * (\\<Sum> b \\<in> spectrum B. g b * \n    Re (Complex_Matrix.trace(eigen_projector A a * (eigen_projector B b) * R))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A.\n       f a * (\\<Sum>b\\<in>spectrum B. g b * (LINT w|M. XA a w * XB b w))) =\n    (\\<Sum>a\\<in>spectrum A.\n       f a *\n       (\\<Sum>b\\<in>spectrum B.\n          g b *\n          Re (Complex_Matrix.trace\n               (eigen_projector A a * eigen_projector B b * R))))", "proof (rule sum.cong, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum A \\<Longrightarrow>\n       f x * (\\<Sum>b\\<in>spectrum B. g b * (LINT w|M. XA x w * XB b w)) =\n       f x *\n       (\\<Sum>b\\<in>spectrum B.\n          g b *\n          Re (Complex_Matrix.trace\n               (eigen_projector A x * eigen_projector B b * R)))", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum A \\<Longrightarrow>\n       f x * (\\<Sum>b\\<in>spectrum B. g b * (LINT w|M. XA x w * XB b w)) =\n       f x *\n       (\\<Sum>b\\<in>spectrum B.\n          g b *\n          Re (Complex_Matrix.trace\n               (eigen_projector A x * eigen_projector B b * R)))", "assume \"a\\<in> spectrum A\""], ["proof (state)\nthis:\n  a \\<in> spectrum A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum A \\<Longrightarrow>\n       f x * (\\<Sum>b\\<in>spectrum B. g b * (LINT w|M. XA x w * XB b w)) =\n       f x *\n       (\\<Sum>b\\<in>spectrum B.\n          g b *\n          Re (Complex_Matrix.trace\n               (eigen_projector A x * eigen_projector B b * R)))", "have \"(\\<Sum>b\\<in>spectrum B. g b * (LINT w|M. XA a w * XB b w)) =\n       (\\<Sum>b\\<in>spectrum B. g b * \n        Re (Complex_Matrix.trace (eigen_projector A a * eigen_projector B b * R)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>spectrum B. g b * (LINT w|M. XA a w * XB b w)) =\n    (\\<Sum>b\\<in>spectrum B.\n       g b *\n       Re (Complex_Matrix.trace\n            (eigen_projector A a * eigen_projector B b * R)))", "proof (rule sum.cong, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum B \\<Longrightarrow>\n       g x * (LINT w|M. XA a w * XB x w) =\n       g x *\n       Re (Complex_Matrix.trace\n            (eigen_projector A a * eigen_projector B x * R))", "fix b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum B \\<Longrightarrow>\n       g x * (LINT w|M. XA a w * XB x w) =\n       g x *\n       Re (Complex_Matrix.trace\n            (eigen_projector A a * eigen_projector B x * R))", "assume \"b\\<in> spectrum B\""], ["proof (state)\nthis:\n  b \\<in> spectrum B\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum B \\<Longrightarrow>\n       g x * (LINT w|M. XA a w * XB x w) =\n       g x *\n       Re (Complex_Matrix.trace\n            (eigen_projector A a * eigen_projector B x * R))", "show \"g b * (LINT w|M. XA a w * XB b w) = \n      g b * Re (Complex_Matrix.trace (eigen_projector A a * eigen_projector B b * R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g b * (LINT w|M. XA a w * XB b w) =\n    g b *\n    Re (Complex_Matrix.trace\n         (eigen_projector A a * eigen_projector B b * R))", "using lhv_integral_eq[of M] assms \\<open>a \\<in> spectrum A\\<close> \\<open>b \\<in> spectrum B\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>lhv M ?A ?B ?R ?XA ?XB; ?a \\<in> spectrum ?A;\n   ?b \\<in> spectrum ?B\\<rbrakk>\n  \\<Longrightarrow> LINT w|M. ?XA ?a w * ?XB ?b w =\n                    Re (Complex_Matrix.trace\n                         (eigen_projector ?A ?a * eigen_projector ?B ?b *\n                          ?R))\n  lhv M A B R XA XB\n  a \\<in> spectrum A\n  b \\<in> spectrum B\n\ngoal (1 subgoal):\n 1. g b * (LINT w|M. XA a w * XB b w) =\n    g b *\n    Re (Complex_Matrix.trace\n         (eigen_projector A a * eigen_projector B b * R))", "by simp"], ["proof (state)\nthis:\n  g b * (LINT w|M. XA a w * XB b w) =\n  g b *\n  Re (Complex_Matrix.trace (eigen_projector A a * eigen_projector B b * R))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>b\\<in>spectrum B. g b * (LINT w|M. XA a w * XB b w)) =\n  (\\<Sum>b\\<in>spectrum B.\n     g b *\n     Re (Complex_Matrix.trace\n          (eigen_projector A a * eigen_projector B b * R)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum A \\<Longrightarrow>\n       f x * (\\<Sum>b\\<in>spectrum B. g b * (LINT w|M. XA x w * XB b w)) =\n       f x *\n       (\\<Sum>b\\<in>spectrum B.\n          g b *\n          Re (Complex_Matrix.trace\n               (eigen_projector A x * eigen_projector B b * R)))", "thus \"f a * (\\<Sum>b\\<in>spectrum B. g b * (LINT w|M. XA a w * XB b w)) =\n        f a * (\\<Sum>b\\<in>spectrum B. g b * \n        Re (Complex_Matrix.trace (eigen_projector A a * eigen_projector B b * R)))\""], ["proof (prove)\nusing this:\n  (\\<Sum>b\\<in>spectrum B. g b * (LINT w|M. XA a w * XB b w)) =\n  (\\<Sum>b\\<in>spectrum B.\n     g b *\n     Re (Complex_Matrix.trace\n          (eigen_projector A a * eigen_projector B b * R)))\n\ngoal (1 subgoal):\n 1. f a * (\\<Sum>b\\<in>spectrum B. g b * (LINT w|M. XA a w * XB b w)) =\n    f a *\n    (\\<Sum>b\\<in>spectrum B.\n       g b *\n       Re (Complex_Matrix.trace\n            (eigen_projector A a * eigen_projector B b * R)))", "by simp"], ["proof (state)\nthis:\n  f a * (\\<Sum>b\\<in>spectrum B. g b * (LINT w|M. XA a w * XB b w)) =\n  f a *\n  (\\<Sum>b\\<in>spectrum B.\n     g b *\n     Re (Complex_Matrix.trace\n          (eigen_projector A a * eigen_projector B b * R)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in cpx_sq_mat) sum_eigen_projector_trace_dist:\n  assumes \"hermitian B\"\nand \"A\\<in> fc_mats\"\nand \"B\\<in> fc_mats\"\nand \"R\\<in> fc_mats\"\n  shows \"(\\<Sum> b \\<in> spectrum B. (b * \n    Complex_Matrix.trace(A * (eigen_projector B b) * R))) = Complex_Matrix.trace(A * B * R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>spectrum B.\n       b * Complex_Matrix.trace (A * eigen_projector B b * R)) =\n    Complex_Matrix.trace (A * B * R)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>spectrum B.\n       b * Complex_Matrix.trace (A * eigen_projector B b * R)) =\n    Complex_Matrix.trace (A * B * R)", "have \"(\\<Sum>b\\<in>spectrum B. b * Complex_Matrix.trace (A * eigen_projector B b * R)) =\n       (\\<Sum>b\\<in>spectrum B. Complex_Matrix.trace (A * (b \\<cdot>\\<^sub>m (eigen_projector B b)) * R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>spectrum B.\n       b * Complex_Matrix.trace (A * eigen_projector B b * R)) =\n    (\\<Sum>b\\<in>spectrum B.\n       Complex_Matrix.trace\n        (A * (b \\<cdot>\\<^sub>m eigen_projector B b) * R))", "proof (rule sum.cong, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum B \\<Longrightarrow>\n       x * Complex_Matrix.trace (A * eigen_projector B x * R) =\n       Complex_Matrix.trace\n        (A * (x \\<cdot>\\<^sub>m eigen_projector B x) * R)", "fix b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum B \\<Longrightarrow>\n       x * Complex_Matrix.trace (A * eigen_projector B x * R) =\n       Complex_Matrix.trace\n        (A * (x \\<cdot>\\<^sub>m eigen_projector B x) * R)", "assume \"b\\<in> spectrum B\""], ["proof (state)\nthis:\n  b \\<in> spectrum B\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum B \\<Longrightarrow>\n       x * Complex_Matrix.trace (A * eigen_projector B x * R) =\n       Complex_Matrix.trace\n        (A * (x \\<cdot>\\<^sub>m eigen_projector B x) * R)", "have \"b * Complex_Matrix.trace (A * eigen_projector B b * R) = \n      Complex_Matrix.trace (b \\<cdot>\\<^sub>m (A * eigen_projector B b * R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b * Complex_Matrix.trace (A * eigen_projector B b * R) =\n    Complex_Matrix.trace (b \\<cdot>\\<^sub>m (A * eigen_projector B b * R))", "proof (rule trace_smult[symmetric])"], ["proof (state)\ngoal (1 subgoal):\n 1. A * eigen_projector B b * R \\<in> carrier_mat ?n ?n", "show \"A * eigen_projector B b * R \\<in> carrier_mat dimR dimR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * eigen_projector B b * R \\<in> carrier_mat dimR dimR", "using eigen_projector_carrier \n          assms fc_mats_carrier dim_eq  \\<open>b \\<in> spectrum B\\<close> cpx_sq_mat_mult"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> fc_mats; ?a \\<in> spectrum ?A; hermitian ?A\\<rbrakk>\n  \\<Longrightarrow> eigen_projector ?A ?a \\<in> fc_mats\n  hermitian B\n  A \\<in> fc_mats\n  B \\<in> fc_mats\n  R \\<in> fc_mats\n  fc_mats = carrier_mat dimR dimC\n  dimR = dimC\n  b \\<in> spectrum B\n  \\<lbrakk>?A \\<in> fc_mats; ?B \\<in> fc_mats\\<rbrakk>\n  \\<Longrightarrow> ?A * ?B \\<in> fc_mats\n\ngoal (1 subgoal):\n 1. A * eigen_projector B b * R \\<in> carrier_mat dimR dimR", "by meson"], ["proof (state)\nthis:\n  A * eigen_projector B b * R \\<in> carrier_mat dimR dimR\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b * Complex_Matrix.trace (A * eigen_projector B b * R) =\n  Complex_Matrix.trace (b \\<cdot>\\<^sub>m (A * eigen_projector B b * R))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum B \\<Longrightarrow>\n       x * Complex_Matrix.trace (A * eigen_projector B x * R) =\n       Complex_Matrix.trace\n        (A * (x \\<cdot>\\<^sub>m eigen_projector B x) * R)", "also"], ["proof (state)\nthis:\n  b * Complex_Matrix.trace (A * eigen_projector B b * R) =\n  Complex_Matrix.trace (b \\<cdot>\\<^sub>m (A * eigen_projector B b * R))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum B \\<Longrightarrow>\n       x * Complex_Matrix.trace (A * eigen_projector B x * R) =\n       Complex_Matrix.trace\n        (A * (x \\<cdot>\\<^sub>m eigen_projector B x) * R)", "have \"... = Complex_Matrix.trace (A * (b \\<cdot>\\<^sub>m eigen_projector B b) * R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex_Matrix.trace (b \\<cdot>\\<^sub>m (A * eigen_projector B b * R)) =\n    Complex_Matrix.trace (A * (b \\<cdot>\\<^sub>m eigen_projector B b) * R)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Complex_Matrix.trace (b \\<cdot>\\<^sub>m (A * eigen_projector B b * R)) =\n    Complex_Matrix.trace (A * (b \\<cdot>\\<^sub>m eigen_projector B b) * R)", "have \"b \\<cdot>\\<^sub>m (A * eigen_projector B b * R) = b \\<cdot>\\<^sub>m (A * (eigen_projector B b * R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<cdot>\\<^sub>m (A * eigen_projector B b * R) =\n    b \\<cdot>\\<^sub>m (A * (eigen_projector B b * R))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<cdot>\\<^sub>m (A * eigen_projector B b * R) =\n    b \\<cdot>\\<^sub>m (A * (eigen_projector B b * R))", "have \"A * eigen_projector B b * R = A * (eigen_projector B b * R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * eigen_projector B b * R = A * (eigen_projector B b * R)", "by (metis \\<open>b \\<in> spectrum B\\<close> assms(1) assms(2) assms(3) assms(4) assoc_mult_mat dim_eq \n              fc_mats_carrier eigen_projector_carrier)"], ["proof (state)\nthis:\n  A * eigen_projector B b * R = A * (eigen_projector B b * R)\n\ngoal (1 subgoal):\n 1. b \\<cdot>\\<^sub>m (A * eigen_projector B b * R) =\n    b \\<cdot>\\<^sub>m (A * (eigen_projector B b * R))", "thus ?thesis"], ["proof (prove)\nusing this:\n  A * eigen_projector B b * R = A * (eigen_projector B b * R)\n\ngoal (1 subgoal):\n 1. b \\<cdot>\\<^sub>m (A * eigen_projector B b * R) =\n    b \\<cdot>\\<^sub>m (A * (eigen_projector B b * R))", "by simp"], ["proof (state)\nthis:\n  b \\<cdot>\\<^sub>m (A * eigen_projector B b * R) =\n  b \\<cdot>\\<^sub>m (A * (eigen_projector B b * R))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b \\<cdot>\\<^sub>m (A * eigen_projector B b * R) =\n  b \\<cdot>\\<^sub>m (A * (eigen_projector B b * R))\n\ngoal (1 subgoal):\n 1. Complex_Matrix.trace (b \\<cdot>\\<^sub>m (A * eigen_projector B b * R)) =\n    Complex_Matrix.trace (A * (b \\<cdot>\\<^sub>m eigen_projector B b) * R)", "also"], ["proof (state)\nthis:\n  b \\<cdot>\\<^sub>m (A * eigen_projector B b * R) =\n  b \\<cdot>\\<^sub>m (A * (eigen_projector B b * R))\n\ngoal (1 subgoal):\n 1. Complex_Matrix.trace (b \\<cdot>\\<^sub>m (A * eigen_projector B b * R)) =\n    Complex_Matrix.trace (A * (b \\<cdot>\\<^sub>m eigen_projector B b) * R)", "have \"... = A * (b \\<cdot>\\<^sub>m (eigen_projector B b * R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<cdot>\\<^sub>m (A * (eigen_projector B b * R)) =\n    A * (b \\<cdot>\\<^sub>m (eigen_projector B b * R))", "proof (rule mult_smult_distrib[symmetric])"], ["proof (state)\ngoal (2 subgoals):\n 1. A \\<in> carrier_mat ?nr ?n\n 2. eigen_projector B b * R \\<in> carrier_mat ?n ?nc", "show \"A \\<in> carrier_mat dimR dimR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat dimR dimR", "using eigen_projector_carrier  assms \n            fc_mats_carrier dim_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> fc_mats; ?a \\<in> spectrum ?A; hermitian ?A\\<rbrakk>\n  \\<Longrightarrow> eigen_projector ?A ?a \\<in> fc_mats\n  hermitian B\n  A \\<in> fc_mats\n  B \\<in> fc_mats\n  R \\<in> fc_mats\n  fc_mats = carrier_mat dimR dimC\n  dimR = dimC\n\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat dimR dimR", "by simp"], ["proof (state)\nthis:\n  A \\<in> carrier_mat dimR dimR\n\ngoal (1 subgoal):\n 1. eigen_projector B b * R \\<in> carrier_mat dimR ?nc", "show \"eigen_projector B b * R \\<in> carrier_mat dimR dimR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eigen_projector B b * R \\<in> carrier_mat dimR dimR", "using eigen_projector_carrier \n            \\<open>b \\<in> spectrum B\\<close> assms fc_mats_carrier dim_eq cpx_sq_mat_mult"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> fc_mats; ?a \\<in> spectrum ?A; hermitian ?A\\<rbrakk>\n  \\<Longrightarrow> eigen_projector ?A ?a \\<in> fc_mats\n  b \\<in> spectrum B\n  hermitian B\n  A \\<in> fc_mats\n  B \\<in> fc_mats\n  R \\<in> fc_mats\n  fc_mats = carrier_mat dimR dimC\n  dimR = dimC\n  \\<lbrakk>?A \\<in> fc_mats; ?B \\<in> fc_mats\\<rbrakk>\n  \\<Longrightarrow> ?A * ?B \\<in> fc_mats\n\ngoal (1 subgoal):\n 1. eigen_projector B b * R \\<in> carrier_mat dimR dimR", "by blast"], ["proof (state)\nthis:\n  eigen_projector B b * R \\<in> carrier_mat dimR dimR\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b \\<cdot>\\<^sub>m (A * (eigen_projector B b * R)) =\n  A * (b \\<cdot>\\<^sub>m (eigen_projector B b * R))\n\ngoal (1 subgoal):\n 1. Complex_Matrix.trace (b \\<cdot>\\<^sub>m (A * eigen_projector B b * R)) =\n    Complex_Matrix.trace (A * (b \\<cdot>\\<^sub>m eigen_projector B b) * R)", "also"], ["proof (state)\nthis:\n  b \\<cdot>\\<^sub>m (A * (eigen_projector B b * R)) =\n  A * (b \\<cdot>\\<^sub>m (eigen_projector B b * R))\n\ngoal (1 subgoal):\n 1. Complex_Matrix.trace (b \\<cdot>\\<^sub>m (A * eigen_projector B b * R)) =\n    Complex_Matrix.trace (A * (b \\<cdot>\\<^sub>m eigen_projector B b) * R)", "have \"... = A * ((b \\<cdot>\\<^sub>m eigen_projector B b) * R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * (b \\<cdot>\\<^sub>m (eigen_projector B b * R)) =\n    A * (b \\<cdot>\\<^sub>m eigen_projector B b * R)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A * (b \\<cdot>\\<^sub>m (eigen_projector B b * R)) =\n    A * (b \\<cdot>\\<^sub>m eigen_projector B b * R)", "have \"b \\<cdot>\\<^sub>m (eigen_projector B b * R) = (b \\<cdot>\\<^sub>m eigen_projector B b) * R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<cdot>\\<^sub>m (eigen_projector B b * R) =\n    b \\<cdot>\\<^sub>m eigen_projector B b * R", "proof (rule mult_smult_assoc_mat[symmetric])"], ["proof (state)\ngoal (2 subgoals):\n 1. eigen_projector B b \\<in> carrier_mat ?nr ?n\n 2. R \\<in> carrier_mat ?n ?nc", "show \"eigen_projector B b \\<in> carrier_mat dimR dimR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eigen_projector B b \\<in> carrier_mat dimR dimR", "using eigen_projector_carrier \n              \\<open>b \\<in> spectrum B\\<close> assms fc_mats_carrier dim_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> fc_mats; ?a \\<in> spectrum ?A; hermitian ?A\\<rbrakk>\n  \\<Longrightarrow> eigen_projector ?A ?a \\<in> fc_mats\n  b \\<in> spectrum B\n  hermitian B\n  A \\<in> fc_mats\n  B \\<in> fc_mats\n  R \\<in> fc_mats\n  fc_mats = carrier_mat dimR dimC\n  dimR = dimC\n\ngoal (1 subgoal):\n 1. eigen_projector B b \\<in> carrier_mat dimR dimR", "by simp"], ["proof (state)\nthis:\n  eigen_projector B b \\<in> carrier_mat dimR dimR\n\ngoal (1 subgoal):\n 1. R \\<in> carrier_mat dimR ?nc", "show \"R \\<in> carrier_mat dimR dimR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<in> carrier_mat dimR dimR", "using assms fc_mats_carrier dim_eq"], ["proof (prove)\nusing this:\n  hermitian B\n  A \\<in> fc_mats\n  B \\<in> fc_mats\n  R \\<in> fc_mats\n  fc_mats = carrier_mat dimR dimC\n  dimR = dimC\n\ngoal (1 subgoal):\n 1. R \\<in> carrier_mat dimR dimR", "by simp"], ["proof (state)\nthis:\n  R \\<in> carrier_mat dimR dimR\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b \\<cdot>\\<^sub>m (eigen_projector B b * R) =\n  b \\<cdot>\\<^sub>m eigen_projector B b * R\n\ngoal (1 subgoal):\n 1. A * (b \\<cdot>\\<^sub>m (eigen_projector B b * R)) =\n    A * (b \\<cdot>\\<^sub>m eigen_projector B b * R)", "thus ?thesis"], ["proof (prove)\nusing this:\n  b \\<cdot>\\<^sub>m (eigen_projector B b * R) =\n  b \\<cdot>\\<^sub>m eigen_projector B b * R\n\ngoal (1 subgoal):\n 1. A * (b \\<cdot>\\<^sub>m (eigen_projector B b * R)) =\n    A * (b \\<cdot>\\<^sub>m eigen_projector B b * R)", "by simp"], ["proof (state)\nthis:\n  A * (b \\<cdot>\\<^sub>m (eigen_projector B b * R)) =\n  A * (b \\<cdot>\\<^sub>m eigen_projector B b * R)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A * (b \\<cdot>\\<^sub>m (eigen_projector B b * R)) =\n  A * (b \\<cdot>\\<^sub>m eigen_projector B b * R)\n\ngoal (1 subgoal):\n 1. Complex_Matrix.trace (b \\<cdot>\\<^sub>m (A * eigen_projector B b * R)) =\n    Complex_Matrix.trace (A * (b \\<cdot>\\<^sub>m eigen_projector B b) * R)", "also"], ["proof (state)\nthis:\n  A * (b \\<cdot>\\<^sub>m (eigen_projector B b * R)) =\n  A * (b \\<cdot>\\<^sub>m eigen_projector B b * R)\n\ngoal (1 subgoal):\n 1. Complex_Matrix.trace (b \\<cdot>\\<^sub>m (A * eigen_projector B b * R)) =\n    Complex_Matrix.trace (A * (b \\<cdot>\\<^sub>m eigen_projector B b) * R)", "have \"... = A * (b \\<cdot>\\<^sub>m eigen_projector B b) * R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * (b \\<cdot>\\<^sub>m eigen_projector B b * R) =\n    A * (b \\<cdot>\\<^sub>m eigen_projector B b) * R", "by (metis \\<open>b \\<in> spectrum B\\<close> assms(1) assms(2) assms(3) assms(4) assoc_mult_mat \n            cpx_sq_mat_smult dim_eq fc_mats_carrier eigen_projector_carrier)"], ["proof (state)\nthis:\n  A * (b \\<cdot>\\<^sub>m eigen_projector B b * R) =\n  A * (b \\<cdot>\\<^sub>m eigen_projector B b) * R\n\ngoal (1 subgoal):\n 1. Complex_Matrix.trace (b \\<cdot>\\<^sub>m (A * eigen_projector B b * R)) =\n    Complex_Matrix.trace (A * (b \\<cdot>\\<^sub>m eigen_projector B b) * R)", "finally"], ["proof (chain)\npicking this:\n  b \\<cdot>\\<^sub>m (A * eigen_projector B b * R) =\n  A * (b \\<cdot>\\<^sub>m eigen_projector B b) * R", "have \"b \\<cdot>\\<^sub>m (A * eigen_projector B b * R) = A * (b \\<cdot>\\<^sub>m eigen_projector B b) * R\""], ["proof (prove)\nusing this:\n  b \\<cdot>\\<^sub>m (A * eigen_projector B b * R) =\n  A * (b \\<cdot>\\<^sub>m eigen_projector B b) * R\n\ngoal (1 subgoal):\n 1. b \\<cdot>\\<^sub>m (A * eigen_projector B b * R) =\n    A * (b \\<cdot>\\<^sub>m eigen_projector B b) * R", "."], ["proof (state)\nthis:\n  b \\<cdot>\\<^sub>m (A * eigen_projector B b * R) =\n  A * (b \\<cdot>\\<^sub>m eigen_projector B b) * R\n\ngoal (1 subgoal):\n 1. Complex_Matrix.trace (b \\<cdot>\\<^sub>m (A * eigen_projector B b * R)) =\n    Complex_Matrix.trace (A * (b \\<cdot>\\<^sub>m eigen_projector B b) * R)", "then"], ["proof (chain)\npicking this:\n  b \\<cdot>\\<^sub>m (A * eigen_projector B b * R) =\n  A * (b \\<cdot>\\<^sub>m eigen_projector B b) * R", "show ?thesis"], ["proof (prove)\nusing this:\n  b \\<cdot>\\<^sub>m (A * eigen_projector B b * R) =\n  A * (b \\<cdot>\\<^sub>m eigen_projector B b) * R\n\ngoal (1 subgoal):\n 1. Complex_Matrix.trace (b \\<cdot>\\<^sub>m (A * eigen_projector B b * R)) =\n    Complex_Matrix.trace (A * (b \\<cdot>\\<^sub>m eigen_projector B b) * R)", "by simp"], ["proof (state)\nthis:\n  Complex_Matrix.trace (b \\<cdot>\\<^sub>m (A * eigen_projector B b * R)) =\n  Complex_Matrix.trace (A * (b \\<cdot>\\<^sub>m eigen_projector B b) * R)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Complex_Matrix.trace (b \\<cdot>\\<^sub>m (A * eigen_projector B b * R)) =\n  Complex_Matrix.trace (A * (b \\<cdot>\\<^sub>m eigen_projector B b) * R)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum B \\<Longrightarrow>\n       x * Complex_Matrix.trace (A * eigen_projector B x * R) =\n       Complex_Matrix.trace\n        (A * (x \\<cdot>\\<^sub>m eigen_projector B x) * R)", "finally"], ["proof (chain)\npicking this:\n  b * Complex_Matrix.trace (A * eigen_projector B b * R) =\n  Complex_Matrix.trace (A * (b \\<cdot>\\<^sub>m eigen_projector B b) * R)", "show \"b * Complex_Matrix.trace (A * eigen_projector B b * R) = \n      Complex_Matrix.trace (A * (b \\<cdot>\\<^sub>m eigen_projector B b) * R)\""], ["proof (prove)\nusing this:\n  b * Complex_Matrix.trace (A * eigen_projector B b * R) =\n  Complex_Matrix.trace (A * (b \\<cdot>\\<^sub>m eigen_projector B b) * R)\n\ngoal (1 subgoal):\n 1. b * Complex_Matrix.trace (A * eigen_projector B b * R) =\n    Complex_Matrix.trace (A * (b \\<cdot>\\<^sub>m eigen_projector B b) * R)", "."], ["proof (state)\nthis:\n  b * Complex_Matrix.trace (A * eigen_projector B b * R) =\n  Complex_Matrix.trace (A * (b \\<cdot>\\<^sub>m eigen_projector B b) * R)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>b\\<in>spectrum B.\n     b * Complex_Matrix.trace (A * eigen_projector B b * R)) =\n  (\\<Sum>b\\<in>spectrum B.\n     Complex_Matrix.trace (A * (b \\<cdot>\\<^sub>m eigen_projector B b) * R))\n\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>spectrum B.\n       b * Complex_Matrix.trace (A * eigen_projector B b * R)) =\n    Complex_Matrix.trace (A * B * R)", "also"], ["proof (state)\nthis:\n  (\\<Sum>b\\<in>spectrum B.\n     b * Complex_Matrix.trace (A * eigen_projector B b * R)) =\n  (\\<Sum>b\\<in>spectrum B.\n     Complex_Matrix.trace (A * (b \\<cdot>\\<^sub>m eigen_projector B b) * R))\n\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>spectrum B.\n       b * Complex_Matrix.trace (A * eigen_projector B b * R)) =\n    Complex_Matrix.trace (A * B * R)", "have \"... = Complex_Matrix.trace (A * \n    (sum_mat (\\<lambda>b. b \\<cdot>\\<^sub>m eigen_projector B b) (spectrum B)) * R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>spectrum B.\n       Complex_Matrix.trace\n        (A * (b \\<cdot>\\<^sub>m eigen_projector B b) * R)) =\n    Complex_Matrix.trace\n     (A *\n      local.sum_mat (\\<lambda>b. b \\<cdot>\\<^sub>m eigen_projector B b)\n       (spectrum B) *\n      R)", "proof (rule trace_sum_mat_mat_distrib, (auto simp add: assms))"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (spectrum B)\n 2. \\<And>b.\n       b \\<in> spectrum B \\<Longrightarrow>\n       b \\<cdot>\\<^sub>m eigen_projector B b \\<in> fc_mats", "show \"finite (spectrum B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (spectrum B)", "using spectrum_finite[of B]"], ["proof (prove)\nusing this:\n  finite (spectrum B)\n\ngoal (1 subgoal):\n 1. finite (spectrum B)", "by simp"], ["proof (state)\nthis:\n  finite (spectrum B)\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> spectrum B \\<Longrightarrow>\n       b \\<cdot>\\<^sub>m eigen_projector B b \\<in> fc_mats", "fix b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> spectrum B \\<Longrightarrow>\n       b \\<cdot>\\<^sub>m eigen_projector B b \\<in> fc_mats", "assume \"b\\<in> spectrum B\""], ["proof (state)\nthis:\n  b \\<in> spectrum B\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> spectrum B \\<Longrightarrow>\n       b \\<cdot>\\<^sub>m eigen_projector B b \\<in> fc_mats", "show \"b \\<cdot>\\<^sub>m eigen_projector B b \\<in> fc_mats\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<cdot>\\<^sub>m eigen_projector B b \\<in> fc_mats", "by (simp add: \\<open>b \\<in> spectrum B\\<close> assms(1) assms(3) cpx_sq_mat_smult eigen_projector_carrier)"], ["proof (state)\nthis:\n  b \\<cdot>\\<^sub>m eigen_projector B b \\<in> fc_mats\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>b\\<in>spectrum B.\n     Complex_Matrix.trace\n      (A * (b \\<cdot>\\<^sub>m eigen_projector B b) * R)) =\n  Complex_Matrix.trace\n   (A *\n    local.sum_mat (\\<lambda>b. b \\<cdot>\\<^sub>m eigen_projector B b)\n     (spectrum B) *\n    R)\n\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>spectrum B.\n       b * Complex_Matrix.trace (A * eigen_projector B b * R)) =\n    Complex_Matrix.trace (A * B * R)", "also"], ["proof (state)\nthis:\n  (\\<Sum>b\\<in>spectrum B.\n     Complex_Matrix.trace\n      (A * (b \\<cdot>\\<^sub>m eigen_projector B b) * R)) =\n  Complex_Matrix.trace\n   (A *\n    local.sum_mat (\\<lambda>b. b \\<cdot>\\<^sub>m eigen_projector B b)\n     (spectrum B) *\n    R)\n\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>spectrum B.\n       b * Complex_Matrix.trace (A * eigen_projector B b * R)) =\n    Complex_Matrix.trace (A * B * R)", "have \"... = Complex_Matrix.trace (A * B * R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex_Matrix.trace\n     (A *\n      local.sum_mat (\\<lambda>b. b \\<cdot>\\<^sub>m eigen_projector B b)\n       (spectrum B) *\n      R) =\n    Complex_Matrix.trace (A * B * R)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Complex_Matrix.trace\n     (A *\n      local.sum_mat (\\<lambda>b. b \\<cdot>\\<^sub>m eigen_projector B b)\n       (spectrum B) *\n      R) =\n    Complex_Matrix.trace (A * B * R)", "have \"sum_mat (\\<lambda>b. b \\<cdot>\\<^sub>m eigen_projector B b) (spectrum B) = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.sum_mat (\\<lambda>b. b \\<cdot>\\<^sub>m eigen_projector B b)\n     (spectrum B) =\n    B", "using make_pm_sum' assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> fc_mats; hermitian ?A\\<rbrakk>\n  \\<Longrightarrow> local.sum_mat\n                     (\\<lambda>a. a \\<cdot>\\<^sub>m eigen_projector ?A a)\n                     (spectrum ?A) =\n                    ?A\n  hermitian B\n  A \\<in> fc_mats\n  B \\<in> fc_mats\n  R \\<in> fc_mats\n\ngoal (1 subgoal):\n 1. local.sum_mat (\\<lambda>b. b \\<cdot>\\<^sub>m eigen_projector B b)\n     (spectrum B) =\n    B", "by simp"], ["proof (state)\nthis:\n  local.sum_mat (\\<lambda>b. b \\<cdot>\\<^sub>m eigen_projector B b)\n   (spectrum B) =\n  B\n\ngoal (1 subgoal):\n 1. Complex_Matrix.trace\n     (A *\n      local.sum_mat (\\<lambda>b. b \\<cdot>\\<^sub>m eigen_projector B b)\n       (spectrum B) *\n      R) =\n    Complex_Matrix.trace (A * B * R)", "thus ?thesis"], ["proof (prove)\nusing this:\n  local.sum_mat (\\<lambda>b. b \\<cdot>\\<^sub>m eigen_projector B b)\n   (spectrum B) =\n  B\n\ngoal (1 subgoal):\n 1. Complex_Matrix.trace\n     (A *\n      local.sum_mat (\\<lambda>b. b \\<cdot>\\<^sub>m eigen_projector B b)\n       (spectrum B) *\n      R) =\n    Complex_Matrix.trace (A * B * R)", "by simp"], ["proof (state)\nthis:\n  Complex_Matrix.trace\n   (A *\n    local.sum_mat (\\<lambda>b. b \\<cdot>\\<^sub>m eigen_projector B b)\n     (spectrum B) *\n    R) =\n  Complex_Matrix.trace (A * B * R)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Complex_Matrix.trace\n   (A *\n    local.sum_mat (\\<lambda>b. b \\<cdot>\\<^sub>m eigen_projector B b)\n     (spectrum B) *\n    R) =\n  Complex_Matrix.trace (A * B * R)\n\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>spectrum B.\n       b * Complex_Matrix.trace (A * eigen_projector B b * R)) =\n    Complex_Matrix.trace (A * B * R)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>b\\<in>spectrum B.\n     b * Complex_Matrix.trace (A * eigen_projector B b * R)) =\n  Complex_Matrix.trace (A * B * R)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>b\\<in>spectrum B.\n     b * Complex_Matrix.trace (A * eigen_projector B b * R)) =\n  Complex_Matrix.trace (A * B * R)\n\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>spectrum B.\n       b * Complex_Matrix.trace (A * eigen_projector B b * R)) =\n    Complex_Matrix.trace (A * B * R)", "."], ["proof (state)\nthis:\n  (\\<Sum>b\\<in>spectrum B.\n     b * Complex_Matrix.trace (A * eigen_projector B b * R)) =\n  Complex_Matrix.trace (A * B * R)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in cpx_sq_mat) sum_eigen_projector_trace_right:\n  assumes \"hermitian A\"\nand \"A\\<in> fc_mats\"\nand \"B\\<in> fc_mats\"\nshows \"(\\<Sum> a \\<in> spectrum A. Complex_Matrix.trace (a \\<cdot>\\<^sub>m eigen_projector A a * B)) = \n  Complex_Matrix.trace (A * B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A.\n       Complex_Matrix.trace (a \\<cdot>\\<^sub>m eigen_projector A a * B)) =\n    Complex_Matrix.trace (A * B)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A.\n       Complex_Matrix.trace (a \\<cdot>\\<^sub>m eigen_projector A a * B)) =\n    Complex_Matrix.trace (A * B)", "have \"sum_mat (\\<lambda>a. a \\<cdot>\\<^sub>m eigen_projector A a * B) (spectrum A) = \n    sum_mat (\\<lambda>a. a \\<cdot>\\<^sub>m eigen_projector A a) (spectrum A) * B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.sum_mat (\\<lambda>a. a \\<cdot>\\<^sub>m eigen_projector A a * B)\n     (spectrum A) =\n    local.sum_mat (\\<lambda>a. a \\<cdot>\\<^sub>m eigen_projector A a)\n     (spectrum A) *\n    B", "proof (rule mult_sum_mat_distrib_right)"], ["proof (state)\ngoal (3 subgoals):\n 1. finite (spectrum A)\n 2. \\<And>a.\n       a \\<in> spectrum A \\<Longrightarrow>\n       a \\<cdot>\\<^sub>m eigen_projector A a \\<in> fc_mats\n 3. B \\<in> fc_mats", "show \"finite (spectrum A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (spectrum A)", "using spectrum_finite[of A]"], ["proof (prove)\nusing this:\n  finite (spectrum A)\n\ngoal (1 subgoal):\n 1. finite (spectrum A)", "by simp"], ["proof (state)\nthis:\n  finite (spectrum A)\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       a \\<in> spectrum A \\<Longrightarrow>\n       a \\<cdot>\\<^sub>m eigen_projector A a \\<in> fc_mats\n 2. B \\<in> fc_mats", "show \"\\<And>a. a \\<in> spectrum A \\<Longrightarrow> a \\<cdot>\\<^sub>m eigen_projector A a \\<in> fc_mats\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> spectrum A \\<Longrightarrow>\n       a \\<cdot>\\<^sub>m eigen_projector A a \\<in> fc_mats", "using assms(1) assms(2) cpx_sq_mat_smult eigen_projector_carrier"], ["proof (prove)\nusing this:\n  hermitian A\n  A \\<in> fc_mats\n  ?A \\<in> fc_mats \\<Longrightarrow> ?x \\<cdot>\\<^sub>m ?A \\<in> fc_mats\n  \\<lbrakk>?A \\<in> fc_mats; ?a \\<in> spectrum ?A; hermitian ?A\\<rbrakk>\n  \\<Longrightarrow> eigen_projector ?A ?a \\<in> fc_mats\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> spectrum A \\<Longrightarrow>\n       a \\<cdot>\\<^sub>m eigen_projector A a \\<in> fc_mats", "by blast"], ["proof (state)\nthis:\n  ?a3 \\<in> spectrum A \\<Longrightarrow>\n  ?a3 \\<cdot>\\<^sub>m eigen_projector A ?a3 \\<in> fc_mats\n\ngoal (1 subgoal):\n 1. B \\<in> fc_mats", "show \"B\\<in> fc_mats\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<in> fc_mats", "using assms"], ["proof (prove)\nusing this:\n  hermitian A\n  A \\<in> fc_mats\n  B \\<in> fc_mats\n\ngoal (1 subgoal):\n 1. B \\<in> fc_mats", "by simp"], ["proof (state)\nthis:\n  B \\<in> fc_mats\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.sum_mat (\\<lambda>a. a \\<cdot>\\<^sub>m eigen_projector A a * B)\n   (spectrum A) =\n  local.sum_mat (\\<lambda>a. a \\<cdot>\\<^sub>m eigen_projector A a)\n   (spectrum A) *\n  B\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A.\n       Complex_Matrix.trace (a \\<cdot>\\<^sub>m eigen_projector A a * B)) =\n    Complex_Matrix.trace (A * B)", "also"], ["proof (state)\nthis:\n  local.sum_mat (\\<lambda>a. a \\<cdot>\\<^sub>m eigen_projector A a * B)\n   (spectrum A) =\n  local.sum_mat (\\<lambda>a. a \\<cdot>\\<^sub>m eigen_projector A a)\n   (spectrum A) *\n  B\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A.\n       Complex_Matrix.trace (a \\<cdot>\\<^sub>m eigen_projector A a * B)) =\n    Complex_Matrix.trace (A * B)", "have \"... = A * B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.sum_mat (\\<lambda>a. a \\<cdot>\\<^sub>m eigen_projector A a)\n     (spectrum A) *\n    B =\n    A * B", "using make_pm_sum' assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> fc_mats; hermitian ?A\\<rbrakk>\n  \\<Longrightarrow> local.sum_mat\n                     (\\<lambda>a. a \\<cdot>\\<^sub>m eigen_projector ?A a)\n                     (spectrum ?A) =\n                    ?A\n  hermitian A\n  A \\<in> fc_mats\n  B \\<in> fc_mats\n\ngoal (1 subgoal):\n 1. local.sum_mat (\\<lambda>a. a \\<cdot>\\<^sub>m eigen_projector A a)\n     (spectrum A) *\n    B =\n    A * B", "by simp"], ["proof (state)\nthis:\n  local.sum_mat (\\<lambda>a. a \\<cdot>\\<^sub>m eigen_projector A a)\n   (spectrum A) *\n  B =\n  A * B\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A.\n       Complex_Matrix.trace (a \\<cdot>\\<^sub>m eigen_projector A a * B)) =\n    Complex_Matrix.trace (A * B)", "finally"], ["proof (chain)\npicking this:\n  local.sum_mat (\\<lambda>a. a \\<cdot>\\<^sub>m eigen_projector A a * B)\n   (spectrum A) =\n  A * B", "have seq: \"sum_mat (\\<lambda>a. a \\<cdot>\\<^sub>m eigen_projector A a * B) (spectrum A) = A * B\""], ["proof (prove)\nusing this:\n  local.sum_mat (\\<lambda>a. a \\<cdot>\\<^sub>m eigen_projector A a * B)\n   (spectrum A) =\n  A * B\n\ngoal (1 subgoal):\n 1. local.sum_mat (\\<lambda>a. a \\<cdot>\\<^sub>m eigen_projector A a * B)\n     (spectrum A) =\n    A * B", "."], ["proof (state)\nthis:\n  local.sum_mat (\\<lambda>a. a \\<cdot>\\<^sub>m eigen_projector A a * B)\n   (spectrum A) =\n  A * B\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A.\n       Complex_Matrix.trace (a \\<cdot>\\<^sub>m eigen_projector A a * B)) =\n    Complex_Matrix.trace (A * B)", "have \"(\\<Sum> a \\<in> spectrum A. Complex_Matrix.trace (a \\<cdot>\\<^sub>m eigen_projector A a * B)) =\n    Complex_Matrix.trace (sum_mat (\\<lambda>a. a \\<cdot>\\<^sub>m eigen_projector A a * B) (spectrum A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A.\n       Complex_Matrix.trace (a \\<cdot>\\<^sub>m eigen_projector A a * B)) =\n    Complex_Matrix.trace\n     (local.sum_mat (\\<lambda>a. a \\<cdot>\\<^sub>m eigen_projector A a * B)\n       (spectrum A))", "proof (rule trace_sum_mat[symmetric])"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (spectrum A)\n 2. \\<And>a.\n       a \\<in> spectrum A \\<Longrightarrow>\n       a \\<cdot>\\<^sub>m eigen_projector A a * B \\<in> fc_mats", "show \"finite (spectrum A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (spectrum A)", "using spectrum_finite[of A]"], ["proof (prove)\nusing this:\n  finite (spectrum A)\n\ngoal (1 subgoal):\n 1. finite (spectrum A)", "by simp"], ["proof (state)\nthis:\n  finite (spectrum A)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> spectrum A \\<Longrightarrow>\n       a \\<cdot>\\<^sub>m eigen_projector A a * B \\<in> fc_mats", "show \"\\<And>a. a \\<in> spectrum A \\<Longrightarrow> a \\<cdot>\\<^sub>m eigen_projector A a * B \\<in> fc_mats\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> spectrum A \\<Longrightarrow>\n       a \\<cdot>\\<^sub>m eigen_projector A a * B \\<in> fc_mats", "by (simp add: assms(1) assms(2) assms(3) cpx_sq_mat_mult cpx_sq_mat_smult \n          eigen_projector_carrier)"], ["proof (state)\nthis:\n  ?a3 \\<in> spectrum A \\<Longrightarrow>\n  ?a3 \\<cdot>\\<^sub>m eigen_projector A ?a3 * B \\<in> fc_mats\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>spectrum A.\n     Complex_Matrix.trace (a \\<cdot>\\<^sub>m eigen_projector A a * B)) =\n  Complex_Matrix.trace\n   (local.sum_mat (\\<lambda>a. a \\<cdot>\\<^sub>m eigen_projector A a * B)\n     (spectrum A))\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A.\n       Complex_Matrix.trace (a \\<cdot>\\<^sub>m eigen_projector A a * B)) =\n    Complex_Matrix.trace (A * B)", "also"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>spectrum A.\n     Complex_Matrix.trace (a \\<cdot>\\<^sub>m eigen_projector A a * B)) =\n  Complex_Matrix.trace\n   (local.sum_mat (\\<lambda>a. a \\<cdot>\\<^sub>m eigen_projector A a * B)\n     (spectrum A))\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A.\n       Complex_Matrix.trace (a \\<cdot>\\<^sub>m eigen_projector A a * B)) =\n    Complex_Matrix.trace (A * B)", "have \"... = Complex_Matrix.trace (A * B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex_Matrix.trace\n     (local.sum_mat (\\<lambda>a. a \\<cdot>\\<^sub>m eigen_projector A a * B)\n       (spectrum A)) =\n    Complex_Matrix.trace (A * B)", "using seq"], ["proof (prove)\nusing this:\n  local.sum_mat (\\<lambda>a. a \\<cdot>\\<^sub>m eigen_projector A a * B)\n   (spectrum A) =\n  A * B\n\ngoal (1 subgoal):\n 1. Complex_Matrix.trace\n     (local.sum_mat (\\<lambda>a. a \\<cdot>\\<^sub>m eigen_projector A a * B)\n       (spectrum A)) =\n    Complex_Matrix.trace (A * B)", "by simp"], ["proof (state)\nthis:\n  Complex_Matrix.trace\n   (local.sum_mat (\\<lambda>a. a \\<cdot>\\<^sub>m eigen_projector A a * B)\n     (spectrum A)) =\n  Complex_Matrix.trace (A * B)\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A.\n       Complex_Matrix.trace (a \\<cdot>\\<^sub>m eigen_projector A a * B)) =\n    Complex_Matrix.trace (A * B)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>a\\<in>spectrum A.\n     Complex_Matrix.trace (a \\<cdot>\\<^sub>m eigen_projector A a * B)) =\n  Complex_Matrix.trace (A * B)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>a\\<in>spectrum A.\n     Complex_Matrix.trace (a \\<cdot>\\<^sub>m eigen_projector A a * B)) =\n  Complex_Matrix.trace (A * B)\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A.\n       Complex_Matrix.trace (a \\<cdot>\\<^sub>m eigen_projector A a * B)) =\n    Complex_Matrix.trace (A * B)", "."], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>spectrum A.\n     Complex_Matrix.trace (a \\<cdot>\\<^sub>m eigen_projector A a * B)) =\n  Complex_Matrix.trace (A * B)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in cpx_sq_mat) sum_eigen_projector_trace:\n  assumes \"hermitian A\"\n  and \"hermitian B\"\n  and \"A\\<in> fc_mats\"\n  and \"B\\<in> fc_mats\"\nand \"R\\<in> fc_mats\"\n  shows \"(\\<Sum> a \\<in> spectrum A.  a *  (\\<Sum> b \\<in> spectrum B. (b * \n    Complex_Matrix.trace(eigen_projector A a * (eigen_projector B b) * R)))) = \n    Complex_Matrix.trace(A * B * R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A.\n       a *\n       (\\<Sum>b\\<in>spectrum B.\n          b *\n          Complex_Matrix.trace\n           (eigen_projector A a * eigen_projector B b * R))) =\n    Complex_Matrix.trace (A * B * R)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A.\n       a *\n       (\\<Sum>b\\<in>spectrum B.\n          b *\n          Complex_Matrix.trace\n           (eigen_projector A a * eigen_projector B b * R))) =\n    Complex_Matrix.trace (A * B * R)", "have \"(\\<Sum> a \\<in> spectrum A.  a *  (\\<Sum> b \\<in> spectrum B. (b * \n    Complex_Matrix.trace(eigen_projector A a * (eigen_projector B b) * R)))) = (\\<Sum> a \\<in> spectrum A.   \n    Complex_Matrix.trace (a \\<cdot>\\<^sub>m eigen_projector A a * (B * R)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A.\n       a *\n       (\\<Sum>b\\<in>spectrum B.\n          b *\n          Complex_Matrix.trace\n           (eigen_projector A a * eigen_projector B b * R))) =\n    (\\<Sum>a\\<in>spectrum A.\n       Complex_Matrix.trace\n        (a \\<cdot>\\<^sub>m eigen_projector A a * (B * R)))", "proof (rule sum.cong, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum A \\<Longrightarrow>\n       x *\n       (\\<Sum>b\\<in>spectrum B.\n          b *\n          Complex_Matrix.trace\n           (eigen_projector A x * eigen_projector B b * R)) =\n       Complex_Matrix.trace\n        (x \\<cdot>\\<^sub>m eigen_projector A x * (B * R))", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum A \\<Longrightarrow>\n       x *\n       (\\<Sum>b\\<in>spectrum B.\n          b *\n          Complex_Matrix.trace\n           (eigen_projector A x * eigen_projector B b * R)) =\n       Complex_Matrix.trace\n        (x \\<cdot>\\<^sub>m eigen_projector A x * (B * R))", "assume \"a\\<in> spectrum A\""], ["proof (state)\nthis:\n  a \\<in> spectrum A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum A \\<Longrightarrow>\n       x *\n       (\\<Sum>b\\<in>spectrum B.\n          b *\n          Complex_Matrix.trace\n           (eigen_projector A x * eigen_projector B b * R)) =\n       Complex_Matrix.trace\n        (x \\<cdot>\\<^sub>m eigen_projector A x * (B * R))", "hence \"(\\<Sum>b\\<in>spectrum B. b * \n      Complex_Matrix.trace (eigen_projector A a * eigen_projector B b * R)) =\n      Complex_Matrix.trace (eigen_projector A a * B * R)\""], ["proof (prove)\nusing this:\n  a \\<in> spectrum A\n\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>spectrum B.\n       b *\n       Complex_Matrix.trace\n        (eigen_projector A a * eigen_projector B b * R)) =\n    Complex_Matrix.trace (eigen_projector A a * B * R)", "using \n      sum_eigen_projector_trace_dist[of B \"eigen_projector A a\" R] assms eigen_projector_carrier"], ["proof (prove)\nusing this:\n  a \\<in> spectrum A\n  \\<lbrakk>hermitian B; eigen_projector A a \\<in> fc_mats; B \\<in> fc_mats;\n   R \\<in> fc_mats\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>b\\<in>spectrum B.\n                       b *\n                       Complex_Matrix.trace\n                        (eigen_projector A a * eigen_projector B b * R)) =\n                    Complex_Matrix.trace (eigen_projector A a * B * R)\n  hermitian A\n  hermitian B\n  A \\<in> fc_mats\n  B \\<in> fc_mats\n  R \\<in> fc_mats\n  \\<lbrakk>?A \\<in> fc_mats; ?a \\<in> spectrum ?A; hermitian ?A\\<rbrakk>\n  \\<Longrightarrow> eigen_projector ?A ?a \\<in> fc_mats\n\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>spectrum B.\n       b *\n       Complex_Matrix.trace\n        (eigen_projector A a * eigen_projector B b * R)) =\n    Complex_Matrix.trace (eigen_projector A a * B * R)", "by blast"], ["proof (state)\nthis:\n  (\\<Sum>b\\<in>spectrum B.\n     b *\n     Complex_Matrix.trace (eigen_projector A a * eigen_projector B b * R)) =\n  Complex_Matrix.trace (eigen_projector A a * B * R)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum A \\<Longrightarrow>\n       x *\n       (\\<Sum>b\\<in>spectrum B.\n          b *\n          Complex_Matrix.trace\n           (eigen_projector A x * eigen_projector B b * R)) =\n       Complex_Matrix.trace\n        (x \\<cdot>\\<^sub>m eigen_projector A x * (B * R))", "hence \"a *  (\\<Sum> b \\<in> spectrum B. (b * \n      Complex_Matrix.trace(eigen_projector A a * (eigen_projector B b) * R))) = \n      a * Complex_Matrix.trace (eigen_projector A a * B * R)\""], ["proof (prove)\nusing this:\n  (\\<Sum>b\\<in>spectrum B.\n     b *\n     Complex_Matrix.trace (eigen_projector A a * eigen_projector B b * R)) =\n  Complex_Matrix.trace (eigen_projector A a * B * R)\n\ngoal (1 subgoal):\n 1. a *\n    (\\<Sum>b\\<in>spectrum B.\n       b *\n       Complex_Matrix.trace\n        (eigen_projector A a * eigen_projector B b * R)) =\n    a * Complex_Matrix.trace (eigen_projector A a * B * R)", "by simp"], ["proof (state)\nthis:\n  a *\n  (\\<Sum>b\\<in>spectrum B.\n     b *\n     Complex_Matrix.trace (eigen_projector A a * eigen_projector B b * R)) =\n  a * Complex_Matrix.trace (eigen_projector A a * B * R)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum A \\<Longrightarrow>\n       x *\n       (\\<Sum>b\\<in>spectrum B.\n          b *\n          Complex_Matrix.trace\n           (eigen_projector A x * eigen_projector B b * R)) =\n       Complex_Matrix.trace\n        (x \\<cdot>\\<^sub>m eigen_projector A x * (B * R))", "also"], ["proof (state)\nthis:\n  a *\n  (\\<Sum>b\\<in>spectrum B.\n     b *\n     Complex_Matrix.trace (eigen_projector A a * eigen_projector B b * R)) =\n  a * Complex_Matrix.trace (eigen_projector A a * B * R)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum A \\<Longrightarrow>\n       x *\n       (\\<Sum>b\\<in>spectrum B.\n          b *\n          Complex_Matrix.trace\n           (eigen_projector A x * eigen_projector B b * R)) =\n       Complex_Matrix.trace\n        (x \\<cdot>\\<^sub>m eigen_projector A x * (B * R))", "have \"... = Complex_Matrix.trace (a \\<cdot>\\<^sub>m (eigen_projector A a * B * R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * Complex_Matrix.trace (eigen_projector A a * B * R) =\n    Complex_Matrix.trace (a \\<cdot>\\<^sub>m (eigen_projector A a * B * R))", "using trace_smult[symmetric, of \"eigen_projector A a * B * R\" dimR a] assms\n       \\<open>a \\<in> spectrum A\\<close> cpx_sq_mat_mult dim_eq fc_mats_carrier eigen_projector_carrier"], ["proof (prove)\nusing this:\n  eigen_projector A a * B * R \\<in> carrier_mat dimR dimR \\<Longrightarrow>\n  a * Complex_Matrix.trace (eigen_projector A a * B * R) =\n  Complex_Matrix.trace (a \\<cdot>\\<^sub>m (eigen_projector A a * B * R))\n  hermitian A\n  hermitian B\n  A \\<in> fc_mats\n  B \\<in> fc_mats\n  R \\<in> fc_mats\n  a \\<in> spectrum A\n  \\<lbrakk>?A \\<in> fc_mats; ?B \\<in> fc_mats\\<rbrakk>\n  \\<Longrightarrow> ?A * ?B \\<in> fc_mats\n  dimR = dimC\n  fc_mats = carrier_mat dimR dimC\n  \\<lbrakk>?A \\<in> fc_mats; ?a \\<in> spectrum ?A; hermitian ?A\\<rbrakk>\n  \\<Longrightarrow> eigen_projector ?A ?a \\<in> fc_mats\n\ngoal (1 subgoal):\n 1. a * Complex_Matrix.trace (eigen_projector A a * B * R) =\n    Complex_Matrix.trace (a \\<cdot>\\<^sub>m (eigen_projector A a * B * R))", "by force"], ["proof (state)\nthis:\n  a * Complex_Matrix.trace (eigen_projector A a * B * R) =\n  Complex_Matrix.trace (a \\<cdot>\\<^sub>m (eigen_projector A a * B * R))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum A \\<Longrightarrow>\n       x *\n       (\\<Sum>b\\<in>spectrum B.\n          b *\n          Complex_Matrix.trace\n           (eigen_projector A x * eigen_projector B b * R)) =\n       Complex_Matrix.trace\n        (x \\<cdot>\\<^sub>m eigen_projector A x * (B * R))", "also"], ["proof (state)\nthis:\n  a * Complex_Matrix.trace (eigen_projector A a * B * R) =\n  Complex_Matrix.trace (a \\<cdot>\\<^sub>m (eigen_projector A a * B * R))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum A \\<Longrightarrow>\n       x *\n       (\\<Sum>b\\<in>spectrum B.\n          b *\n          Complex_Matrix.trace\n           (eigen_projector A x * eigen_projector B b * R)) =\n       Complex_Matrix.trace\n        (x \\<cdot>\\<^sub>m eigen_projector A x * (B * R))", "have \"... = Complex_Matrix.trace (a \\<cdot>\\<^sub>m eigen_projector A a * (B * R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex_Matrix.trace (a \\<cdot>\\<^sub>m (eigen_projector A a * B * R)) =\n    Complex_Matrix.trace (a \\<cdot>\\<^sub>m eigen_projector A a * (B * R))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Complex_Matrix.trace (a \\<cdot>\\<^sub>m (eigen_projector A a * B * R)) =\n    Complex_Matrix.trace (a \\<cdot>\\<^sub>m eigen_projector A a * (B * R))", "have \"a \\<cdot>\\<^sub>m (eigen_projector A a * B * R) = a \\<cdot>\\<^sub>m (eigen_projector A a * B) * R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<cdot>\\<^sub>m (eigen_projector A a * B * R) =\n    a \\<cdot>\\<^sub>m (eigen_projector A a * B) * R", "proof (rule  mult_smult_assoc_mat[symmetric])"], ["proof (state)\ngoal (2 subgoals):\n 1. eigen_projector A a * B \\<in> carrier_mat ?nr ?n\n 2. R \\<in> carrier_mat ?n ?nc", "show \"R\\<in> carrier_mat dimR dimR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<in> carrier_mat dimR dimR", "using assms fc_mats_carrier dim_eq"], ["proof (prove)\nusing this:\n  hermitian A\n  hermitian B\n  A \\<in> fc_mats\n  B \\<in> fc_mats\n  R \\<in> fc_mats\n  fc_mats = carrier_mat dimR dimC\n  dimR = dimC\n\ngoal (1 subgoal):\n 1. R \\<in> carrier_mat dimR dimR", "by simp"], ["proof (state)\nthis:\n  R \\<in> carrier_mat dimR dimR\n\ngoal (1 subgoal):\n 1. eigen_projector A a * B \\<in> carrier_mat ?nr dimR", "show \"eigen_projector A a * B \\<in> carrier_mat dimR dimR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eigen_projector A a * B \\<in> carrier_mat dimR dimR", "using assms eigen_projector_carrier \n            cpx_sq_mat_mult fc_mats_carrier dim_eq \\<open>a \\<in> spectrum A\\<close>"], ["proof (prove)\nusing this:\n  hermitian A\n  hermitian B\n  A \\<in> fc_mats\n  B \\<in> fc_mats\n  R \\<in> fc_mats\n  \\<lbrakk>?A \\<in> fc_mats; ?a \\<in> spectrum ?A; hermitian ?A\\<rbrakk>\n  \\<Longrightarrow> eigen_projector ?A ?a \\<in> fc_mats\n  \\<lbrakk>?A \\<in> fc_mats; ?B \\<in> fc_mats\\<rbrakk>\n  \\<Longrightarrow> ?A * ?B \\<in> fc_mats\n  fc_mats = carrier_mat dimR dimC\n  dimR = dimC\n  a \\<in> spectrum A\n\ngoal (1 subgoal):\n 1. eigen_projector A a * B \\<in> carrier_mat dimR dimR", "by blast"], ["proof (state)\nthis:\n  eigen_projector A a * B \\<in> carrier_mat dimR dimR\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a \\<cdot>\\<^sub>m (eigen_projector A a * B * R) =\n  a \\<cdot>\\<^sub>m (eigen_projector A a * B) * R\n\ngoal (1 subgoal):\n 1. Complex_Matrix.trace (a \\<cdot>\\<^sub>m (eigen_projector A a * B * R)) =\n    Complex_Matrix.trace (a \\<cdot>\\<^sub>m eigen_projector A a * (B * R))", "also"], ["proof (state)\nthis:\n  a \\<cdot>\\<^sub>m (eigen_projector A a * B * R) =\n  a \\<cdot>\\<^sub>m (eigen_projector A a * B) * R\n\ngoal (1 subgoal):\n 1. Complex_Matrix.trace (a \\<cdot>\\<^sub>m (eigen_projector A a * B * R)) =\n    Complex_Matrix.trace (a \\<cdot>\\<^sub>m eigen_projector A a * (B * R))", "have \"... = a \\<cdot>\\<^sub>m eigen_projector A a * B * R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<cdot>\\<^sub>m (eigen_projector A a * B) * R =\n    a \\<cdot>\\<^sub>m eigen_projector A a * B * R", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<cdot>\\<^sub>m (eigen_projector A a * B) * R =\n    a \\<cdot>\\<^sub>m eigen_projector A a * B * R", "have \"a \\<cdot>\\<^sub>m (eigen_projector A a * B) = a \\<cdot>\\<^sub>m eigen_projector A a * B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<cdot>\\<^sub>m (eigen_projector A a * B) =\n    a \\<cdot>\\<^sub>m eigen_projector A a * B", "using mult_smult_assoc_mat[symmetric]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> carrier_mat ?nr ?n; ?B \\<in> carrier_mat ?n ?nc\\<rbrakk>\n  \\<Longrightarrow> ?k \\<cdot>\\<^sub>m (?A * ?B) =\n                    ?k \\<cdot>\\<^sub>m ?A * ?B\n\ngoal (1 subgoal):\n 1. a \\<cdot>\\<^sub>m (eigen_projector A a * B) =\n    a \\<cdot>\\<^sub>m eigen_projector A a * B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>A nr n B nc k.\n        \\<lbrakk>A \\<in> carrier_mat nr n; B \\<in> carrier_mat n nc\\<rbrakk>\n        \\<Longrightarrow> k \\<cdot>\\<^sub>m (A * B) =\n                          k \\<cdot>\\<^sub>m A * B) \\<Longrightarrow>\n    a \\<cdot>\\<^sub>m (eigen_projector A a * B) =\n    a \\<cdot>\\<^sub>m eigen_projector A a * B", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<cdot>\\<^sub>m (eigen_projector A a * B) =\n    a \\<cdot>\\<^sub>m eigen_projector A a * B", "by (metis \\<open>\\<And>nr nc n k B A. \\<lbrakk>A \\<in> carrier_mat nr n; B \\<in> carrier_mat n nc\\<rbrakk> \\<Longrightarrow> \n              k \\<cdot>\\<^sub>m (A * B) = k \\<cdot>\\<^sub>m A * B\\<close> \\<open>a \\<in> spectrum A\\<close> assms(1) assms(3) assms(4) dim_eq \n                fc_mats_carrier eigen_projector_carrier)"], ["proof (state)\nthis:\n  a \\<cdot>\\<^sub>m (eigen_projector A a * B) =\n  a \\<cdot>\\<^sub>m eigen_projector A a * B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a \\<cdot>\\<^sub>m (eigen_projector A a * B) =\n  a \\<cdot>\\<^sub>m eigen_projector A a * B\n\ngoal (1 subgoal):\n 1. a \\<cdot>\\<^sub>m (eigen_projector A a * B) * R =\n    a \\<cdot>\\<^sub>m eigen_projector A a * B * R", "thus ?thesis"], ["proof (prove)\nusing this:\n  a \\<cdot>\\<^sub>m (eigen_projector A a * B) =\n  a \\<cdot>\\<^sub>m eigen_projector A a * B\n\ngoal (1 subgoal):\n 1. a \\<cdot>\\<^sub>m (eigen_projector A a * B) * R =\n    a \\<cdot>\\<^sub>m eigen_projector A a * B * R", "by simp"], ["proof (state)\nthis:\n  a \\<cdot>\\<^sub>m (eigen_projector A a * B) * R =\n  a \\<cdot>\\<^sub>m eigen_projector A a * B * R\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a \\<cdot>\\<^sub>m (eigen_projector A a * B) * R =\n  a \\<cdot>\\<^sub>m eigen_projector A a * B * R\n\ngoal (1 subgoal):\n 1. Complex_Matrix.trace (a \\<cdot>\\<^sub>m (eigen_projector A a * B * R)) =\n    Complex_Matrix.trace (a \\<cdot>\\<^sub>m eigen_projector A a * (B * R))", "also"], ["proof (state)\nthis:\n  a \\<cdot>\\<^sub>m (eigen_projector A a * B) * R =\n  a \\<cdot>\\<^sub>m eigen_projector A a * B * R\n\ngoal (1 subgoal):\n 1. Complex_Matrix.trace (a \\<cdot>\\<^sub>m (eigen_projector A a * B * R)) =\n    Complex_Matrix.trace (a \\<cdot>\\<^sub>m eigen_projector A a * (B * R))", "have \"... = a \\<cdot>\\<^sub>m eigen_projector A a * (B * R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<cdot>\\<^sub>m eigen_projector A a * B * R =\n    a \\<cdot>\\<^sub>m eigen_projector A a * (B * R)", "by (metis \\<open>a \\<in> spectrum A\\<close> assms(1) assms(3) assms(4) assms(5) assoc_mult_mat \n            cpx_sq_mat_smult dim_eq fc_mats_carrier eigen_projector_carrier)"], ["proof (state)\nthis:\n  a \\<cdot>\\<^sub>m eigen_projector A a * B * R =\n  a \\<cdot>\\<^sub>m eigen_projector A a * (B * R)\n\ngoal (1 subgoal):\n 1. Complex_Matrix.trace (a \\<cdot>\\<^sub>m (eigen_projector A a * B * R)) =\n    Complex_Matrix.trace (a \\<cdot>\\<^sub>m eigen_projector A a * (B * R))", "finally"], ["proof (chain)\npicking this:\n  a \\<cdot>\\<^sub>m (eigen_projector A a * B * R) =\n  a \\<cdot>\\<^sub>m eigen_projector A a * (B * R)", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<cdot>\\<^sub>m (eigen_projector A a * B * R) =\n  a \\<cdot>\\<^sub>m eigen_projector A a * (B * R)\n\ngoal (1 subgoal):\n 1. Complex_Matrix.trace (a \\<cdot>\\<^sub>m (eigen_projector A a * B * R)) =\n    Complex_Matrix.trace (a \\<cdot>\\<^sub>m eigen_projector A a * (B * R))", "by simp"], ["proof (state)\nthis:\n  Complex_Matrix.trace (a \\<cdot>\\<^sub>m (eigen_projector A a * B * R)) =\n  Complex_Matrix.trace (a \\<cdot>\\<^sub>m eigen_projector A a * (B * R))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Complex_Matrix.trace (a \\<cdot>\\<^sub>m (eigen_projector A a * B * R)) =\n  Complex_Matrix.trace (a \\<cdot>\\<^sub>m eigen_projector A a * (B * R))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum A \\<Longrightarrow>\n       x *\n       (\\<Sum>b\\<in>spectrum B.\n          b *\n          Complex_Matrix.trace\n           (eigen_projector A x * eigen_projector B b * R)) =\n       Complex_Matrix.trace\n        (x \\<cdot>\\<^sub>m eigen_projector A x * (B * R))", "finally"], ["proof (chain)\npicking this:\n  a *\n  (\\<Sum>b\\<in>spectrum B.\n     b *\n     Complex_Matrix.trace (eigen_projector A a * eigen_projector B b * R)) =\n  Complex_Matrix.trace (a \\<cdot>\\<^sub>m eigen_projector A a * (B * R))", "show \"a *  (\\<Sum> b \\<in> spectrum B. (b * \n      Complex_Matrix.trace(eigen_projector A a * (eigen_projector B b) * R))) =\n      Complex_Matrix.trace (a \\<cdot>\\<^sub>m eigen_projector A a * (B * R))\""], ["proof (prove)\nusing this:\n  a *\n  (\\<Sum>b\\<in>spectrum B.\n     b *\n     Complex_Matrix.trace (eigen_projector A a * eigen_projector B b * R)) =\n  Complex_Matrix.trace (a \\<cdot>\\<^sub>m eigen_projector A a * (B * R))\n\ngoal (1 subgoal):\n 1. a *\n    (\\<Sum>b\\<in>spectrum B.\n       b *\n       Complex_Matrix.trace\n        (eigen_projector A a * eigen_projector B b * R)) =\n    Complex_Matrix.trace (a \\<cdot>\\<^sub>m eigen_projector A a * (B * R))", "."], ["proof (state)\nthis:\n  a *\n  (\\<Sum>b\\<in>spectrum B.\n     b *\n     Complex_Matrix.trace (eigen_projector A a * eigen_projector B b * R)) =\n  Complex_Matrix.trace (a \\<cdot>\\<^sub>m eigen_projector A a * (B * R))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>spectrum A.\n     a *\n     (\\<Sum>b\\<in>spectrum B.\n        b *\n        Complex_Matrix.trace\n         (eigen_projector A a * eigen_projector B b * R))) =\n  (\\<Sum>a\\<in>spectrum A.\n     Complex_Matrix.trace (a \\<cdot>\\<^sub>m eigen_projector A a * (B * R)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A.\n       a *\n       (\\<Sum>b\\<in>spectrum B.\n          b *\n          Complex_Matrix.trace\n           (eigen_projector A a * eigen_projector B b * R))) =\n    Complex_Matrix.trace (A * B * R)", "also"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>spectrum A.\n     a *\n     (\\<Sum>b\\<in>spectrum B.\n        b *\n        Complex_Matrix.trace\n         (eigen_projector A a * eigen_projector B b * R))) =\n  (\\<Sum>a\\<in>spectrum A.\n     Complex_Matrix.trace (a \\<cdot>\\<^sub>m eigen_projector A a * (B * R)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A.\n       a *\n       (\\<Sum>b\\<in>spectrum B.\n          b *\n          Complex_Matrix.trace\n           (eigen_projector A a * eigen_projector B b * R))) =\n    Complex_Matrix.trace (A * B * R)", "have \"... = Complex_Matrix.trace (A * (B * R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A.\n       Complex_Matrix.trace\n        (a \\<cdot>\\<^sub>m eigen_projector A a * (B * R))) =\n    Complex_Matrix.trace (A * (B * R))", "using sum_eigen_projector_trace_right[of A \"B * R\"] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>hermitian A; A \\<in> fc_mats; B * R \\<in> fc_mats\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>a\\<in>spectrum A.\n                       Complex_Matrix.trace\n                        (a \\<cdot>\\<^sub>m eigen_projector A a * (B * R))) =\n                    Complex_Matrix.trace (A * (B * R))\n  hermitian A\n  hermitian B\n  A \\<in> fc_mats\n  B \\<in> fc_mats\n  R \\<in> fc_mats\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A.\n       Complex_Matrix.trace\n        (a \\<cdot>\\<^sub>m eigen_projector A a * (B * R))) =\n    Complex_Matrix.trace (A * (B * R))", "by (simp add: cpx_sq_mat_mult)"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>spectrum A.\n     Complex_Matrix.trace\n      (a \\<cdot>\\<^sub>m eigen_projector A a * (B * R))) =\n  Complex_Matrix.trace (A * (B * R))\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A.\n       a *\n       (\\<Sum>b\\<in>spectrum B.\n          b *\n          Complex_Matrix.trace\n           (eigen_projector A a * eigen_projector B b * R))) =\n    Complex_Matrix.trace (A * B * R)", "also"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>spectrum A.\n     Complex_Matrix.trace\n      (a \\<cdot>\\<^sub>m eigen_projector A a * (B * R))) =\n  Complex_Matrix.trace (A * (B * R))\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A.\n       a *\n       (\\<Sum>b\\<in>spectrum B.\n          b *\n          Complex_Matrix.trace\n           (eigen_projector A a * eigen_projector B b * R))) =\n    Complex_Matrix.trace (A * B * R)", "have \"... = Complex_Matrix.trace (A * B * R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex_Matrix.trace (A * (B * R)) = Complex_Matrix.trace (A * B * R)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Complex_Matrix.trace (A * (B * R)) = Complex_Matrix.trace (A * B * R)", "have \"A * (B * R) = A * B * R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * (B * R) = A * B * R", "proof (rule assoc_mult_mat[symmetric])"], ["proof (state)\ngoal (3 subgoals):\n 1. A \\<in> carrier_mat ?n\\<^sub>1 ?n\\<^sub>2\n 2. B \\<in> carrier_mat ?n\\<^sub>2 ?n\\<^sub>3\n 3. R \\<in> carrier_mat ?n\\<^sub>3 ?n\\<^sub>4", "show \"A\\<in>  carrier_mat dimR dimR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat dimR dimR", "using assms fc_mats_carrier dim_eq"], ["proof (prove)\nusing this:\n  hermitian A\n  hermitian B\n  A \\<in> fc_mats\n  B \\<in> fc_mats\n  R \\<in> fc_mats\n  fc_mats = carrier_mat dimR dimC\n  dimR = dimC\n\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat dimR dimR", "by simp"], ["proof (state)\nthis:\n  A \\<in> carrier_mat dimR dimR\n\ngoal (2 subgoals):\n 1. B \\<in> carrier_mat dimR ?n\\<^sub>3\n 2. R \\<in> carrier_mat ?n\\<^sub>3 ?n\\<^sub>4", "show \"B\\<in>  carrier_mat dimR dimR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<in> carrier_mat dimR dimR", "using assms fc_mats_carrier dim_eq"], ["proof (prove)\nusing this:\n  hermitian A\n  hermitian B\n  A \\<in> fc_mats\n  B \\<in> fc_mats\n  R \\<in> fc_mats\n  fc_mats = carrier_mat dimR dimC\n  dimR = dimC\n\ngoal (1 subgoal):\n 1. B \\<in> carrier_mat dimR dimR", "by simp"], ["proof (state)\nthis:\n  B \\<in> carrier_mat dimR dimR\n\ngoal (1 subgoal):\n 1. R \\<in> carrier_mat dimR ?n\\<^sub>4", "show \"R\\<in>  carrier_mat dimR dimR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<in> carrier_mat dimR dimR", "using assms fc_mats_carrier dim_eq"], ["proof (prove)\nusing this:\n  hermitian A\n  hermitian B\n  A \\<in> fc_mats\n  B \\<in> fc_mats\n  R \\<in> fc_mats\n  fc_mats = carrier_mat dimR dimC\n  dimR = dimC\n\ngoal (1 subgoal):\n 1. R \\<in> carrier_mat dimR dimR", "by simp"], ["proof (state)\nthis:\n  R \\<in> carrier_mat dimR dimR\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A * (B * R) = A * B * R\n\ngoal (1 subgoal):\n 1. Complex_Matrix.trace (A * (B * R)) = Complex_Matrix.trace (A * B * R)", "thus ?thesis"], ["proof (prove)\nusing this:\n  A * (B * R) = A * B * R\n\ngoal (1 subgoal):\n 1. Complex_Matrix.trace (A * (B * R)) = Complex_Matrix.trace (A * B * R)", "by simp"], ["proof (state)\nthis:\n  Complex_Matrix.trace (A * (B * R)) = Complex_Matrix.trace (A * B * R)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Complex_Matrix.trace (A * (B * R)) = Complex_Matrix.trace (A * B * R)\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A.\n       a *\n       (\\<Sum>b\\<in>spectrum B.\n          b *\n          Complex_Matrix.trace\n           (eigen_projector A a * eigen_projector B b * R))) =\n    Complex_Matrix.trace (A * B * R)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>a\\<in>spectrum A.\n     a *\n     (\\<Sum>b\\<in>spectrum B.\n        b *\n        Complex_Matrix.trace\n         (eigen_projector A a * eigen_projector B b * R))) =\n  Complex_Matrix.trace (A * B * R)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>a\\<in>spectrum A.\n     a *\n     (\\<Sum>b\\<in>spectrum B.\n        b *\n        Complex_Matrix.trace\n         (eigen_projector A a * eigen_projector B b * R))) =\n  Complex_Matrix.trace (A * B * R)\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A.\n       a *\n       (\\<Sum>b\\<in>spectrum B.\n          b *\n          Complex_Matrix.trace\n           (eigen_projector A a * eigen_projector B b * R))) =\n    Complex_Matrix.trace (A * B * R)", "."], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>spectrum A.\n     a *\n     (\\<Sum>b\\<in>spectrum B.\n        b *\n        Complex_Matrix.trace\n         (eigen_projector A a * eigen_projector B b * R))) =\n  Complex_Matrix.trace (A * B * R)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We obtain the main result of this part, which relates the quantum expectation value of a \njoint measurement with an expectation.\\<close>"], ["", "lemma (in cpx_sq_mat) sum_qt_expect:\n  assumes \"lhv M A B R XA XB\"\n  and \"A\\<in> fc_mats\"\n  and \"B\\<in> fc_mats\"\n  and \"R\\<in> fc_mats\"\n  and \"hermitian A\"\n  and \"hermitian B\"\n  shows \"integral\\<^sup>L M (\\<lambda>w. (qt_expect A XA w) * (qt_expect B XB w)) = \n    Re (Complex_Matrix.trace(A * B * R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect A XA w * qt_expect B XB w =\n    Re (Complex_Matrix.trace (A * B * R))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect A XA w * qt_expect B XB w =\n    Re (Complex_Matrix.trace (A * B * R))", "have br: \"\\<forall> b \\<in> spectrum B. b\\<in> Reals\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>spectrum B. b \\<in> \\<real>", "using assms hermitian_spectrum_real[of B]"], ["proof (prove)\nusing this:\n  lhv M A B R XA XB\n  A \\<in> fc_mats\n  B \\<in> fc_mats\n  R \\<in> fc_mats\n  hermitian A\n  hermitian B\n  \\<lbrakk>B \\<in> fc_mats; hermitian B; ?a \\<in> spectrum B\\<rbrakk>\n  \\<Longrightarrow> ?a \\<in> \\<real>\n\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>spectrum B. b \\<in> \\<real>", "by auto"], ["proof (state)\nthis:\n  \\<forall>b\\<in>spectrum B. b \\<in> \\<real>\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect A XA w * qt_expect B XB w =\n    Re (Complex_Matrix.trace (A * B * R))", "have ar: \"\\<forall>a \\<in> spectrum A. a\\<in> Reals\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>spectrum A. a \\<in> \\<real>", "using hermitian_spectrum_real[of A] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>A \\<in> fc_mats; hermitian A; ?a \\<in> spectrum A\\<rbrakk>\n  \\<Longrightarrow> ?a \\<in> \\<real>\n  lhv M A B R XA XB\n  A \\<in> fc_mats\n  B \\<in> fc_mats\n  R \\<in> fc_mats\n  hermitian A\n  hermitian B\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>spectrum A. a \\<in> \\<real>", "by auto"], ["proof (state)\nthis:\n  \\<forall>a\\<in>spectrum A. a \\<in> \\<real>\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect A XA w * qt_expect B XB w =\n    Re (Complex_Matrix.trace (A * B * R))", "have \"integral\\<^sup>L M (\\<lambda>w. (\\<Sum> a \\<in> spectrum A. Re a* XA a w) * (\\<Sum> b \\<in> spectrum B. Re b *XB b w)) = \n    (\\<Sum> a \\<in> spectrum A. Re a * (\\<Sum> b \\<in> spectrum B. Re b * integral\\<^sup>L M (\\<lambda>w. XA a w * XB b w)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT w|M.\n       (\\<Sum>a\\<in>spectrum A. Re a * XA a w) *\n       (\\<Sum>b\\<in>spectrum B. Re b * XB b w) =\n    (\\<Sum>a\\<in>spectrum A.\n       Re a * (\\<Sum>b\\<in>spectrum B. Re b * (LINT w|M. XA a w * XB b w)))", "using lhv_sum_integral'[of M] assms"], ["proof (prove)\nusing this:\n  lhv M ?A ?B ?R ?XA ?XB \\<Longrightarrow>\n  LINT w|M.\n     (\\<Sum>a\\<in>spectrum ?A. ?f a * ?XA a w) *\n     (\\<Sum>b\\<in>spectrum ?B. ?g b * ?XB b w) =\n  (\\<Sum>a\\<in>spectrum ?A.\n     ?f a * (\\<Sum>b\\<in>spectrum ?B. ?g b * (LINT w|M. ?XA a w * ?XB b w)))\n  lhv M A B R XA XB\n  A \\<in> fc_mats\n  B \\<in> fc_mats\n  R \\<in> fc_mats\n  hermitian A\n  hermitian B\n\ngoal (1 subgoal):\n 1. LINT w|M.\n       (\\<Sum>a\\<in>spectrum A. Re a * XA a w) *\n       (\\<Sum>b\\<in>spectrum B. Re b * XB b w) =\n    (\\<Sum>a\\<in>spectrum A.\n       Re a * (\\<Sum>b\\<in>spectrum B. Re b * (LINT w|M. XA a w * XB b w)))", "by simp"], ["proof (state)\nthis:\n  LINT w|M.\n     (\\<Sum>a\\<in>spectrum A. Re a * XA a w) *\n     (\\<Sum>b\\<in>spectrum B. Re b * XB b w) =\n  (\\<Sum>a\\<in>spectrum A.\n     Re a * (\\<Sum>b\\<in>spectrum B. Re b * (LINT w|M. XA a w * XB b w)))\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect A XA w * qt_expect B XB w =\n    Re (Complex_Matrix.trace (A * B * R))", "also"], ["proof (state)\nthis:\n  LINT w|M.\n     (\\<Sum>a\\<in>spectrum A. Re a * XA a w) *\n     (\\<Sum>b\\<in>spectrum B. Re b * XB b w) =\n  (\\<Sum>a\\<in>spectrum A.\n     Re a * (\\<Sum>b\\<in>spectrum B. Re b * (LINT w|M. XA a w * XB b w)))\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect A XA w * qt_expect B XB w =\n    Re (Complex_Matrix.trace (A * B * R))", "have \"... = (\\<Sum> a \\<in> spectrum A. Re a * (\\<Sum> b \\<in> spectrum B. Re b * \n    Re (Complex_Matrix.trace(eigen_projector A a * (eigen_projector B b) * R))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A.\n       Re a *\n       (\\<Sum>b\\<in>spectrum B. Re b * (LINT w|M. XA a w * XB b w))) =\n    (\\<Sum>a\\<in>spectrum A.\n       Re a *\n       (\\<Sum>b\\<in>spectrum B.\n          Re b *\n          Re (Complex_Matrix.trace\n               (eigen_projector A a * eigen_projector B b * R))))", "using assms sum_qt_expect_trace[of M]"], ["proof (prove)\nusing this:\n  lhv M A B R XA XB\n  A \\<in> fc_mats\n  B \\<in> fc_mats\n  R \\<in> fc_mats\n  hermitian A\n  hermitian B\n  lhv M ?A ?B ?R ?XA ?XB \\<Longrightarrow>\n  (\\<Sum>a\\<in>spectrum ?A.\n     ?f a *\n     (\\<Sum>b\\<in>spectrum ?B. ?g b * (LINT w|M. ?XA a w * ?XB b w))) =\n  (\\<Sum>a\\<in>spectrum ?A.\n     ?f a *\n     (\\<Sum>b\\<in>spectrum ?B.\n        ?g b *\n        Re (Complex_Matrix.trace\n             (eigen_projector ?A a * eigen_projector ?B b * ?R))))\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A.\n       Re a *\n       (\\<Sum>b\\<in>spectrum B. Re b * (LINT w|M. XA a w * XB b w))) =\n    (\\<Sum>a\\<in>spectrum A.\n       Re a *\n       (\\<Sum>b\\<in>spectrum B.\n          Re b *\n          Re (Complex_Matrix.trace\n               (eigen_projector A a * eigen_projector B b * R))))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>spectrum A.\n     Re a * (\\<Sum>b\\<in>spectrum B. Re b * (LINT w|M. XA a w * XB b w))) =\n  (\\<Sum>a\\<in>spectrum A.\n     Re a *\n     (\\<Sum>b\\<in>spectrum B.\n        Re b *\n        Re (Complex_Matrix.trace\n             (eigen_projector A a * eigen_projector B b * R))))\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect A XA w * qt_expect B XB w =\n    Re (Complex_Matrix.trace (A * B * R))", "also"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>spectrum A.\n     Re a * (\\<Sum>b\\<in>spectrum B. Re b * (LINT w|M. XA a w * XB b w))) =\n  (\\<Sum>a\\<in>spectrum A.\n     Re a *\n     (\\<Sum>b\\<in>spectrum B.\n        Re b *\n        Re (Complex_Matrix.trace\n             (eigen_projector A a * eigen_projector B b * R))))\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect A XA w * qt_expect B XB w =\n    Re (Complex_Matrix.trace (A * B * R))", "have \"... = (\\<Sum> a \\<in> spectrum A. Re a * Re (\\<Sum> b \\<in> spectrum B. (b * \n    Complex_Matrix.trace(eigen_projector A a * (eigen_projector B b) * R))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A.\n       Re a *\n       (\\<Sum>b\\<in>spectrum B.\n          Re b *\n          Re (Complex_Matrix.trace\n               (eigen_projector A a * eigen_projector B b * R)))) =\n    (\\<Sum>a\\<in>spectrum A.\n       Re a *\n       Re (\\<Sum>b\\<in>spectrum B.\n             b *\n             Complex_Matrix.trace\n              (eigen_projector A a * eigen_projector B b * R)))", "proof (rule sum.cong, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum A \\<Longrightarrow>\n       Re x *\n       (\\<Sum>b\\<in>spectrum B.\n          Re b *\n          Re (Complex_Matrix.trace\n               (eigen_projector A x * eigen_projector B b * R))) =\n       Re x *\n       Re (\\<Sum>b\\<in>spectrum B.\n             b *\n             Complex_Matrix.trace\n              (eigen_projector A x * eigen_projector B b * R))", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum A \\<Longrightarrow>\n       Re x *\n       (\\<Sum>b\\<in>spectrum B.\n          Re b *\n          Re (Complex_Matrix.trace\n               (eigen_projector A x * eigen_projector B b * R))) =\n       Re x *\n       Re (\\<Sum>b\\<in>spectrum B.\n             b *\n             Complex_Matrix.trace\n              (eigen_projector A x * eigen_projector B b * R))", "assume \"a\\<in> spectrum A\""], ["proof (state)\nthis:\n  a \\<in> spectrum A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum A \\<Longrightarrow>\n       Re x *\n       (\\<Sum>b\\<in>spectrum B.\n          Re b *\n          Re (Complex_Matrix.trace\n               (eigen_projector A x * eigen_projector B b * R))) =\n       Re x *\n       Re (\\<Sum>b\\<in>spectrum B.\n             b *\n             Complex_Matrix.trace\n              (eigen_projector A x * eigen_projector B b * R))", "have \"(\\<Sum>b\\<in>spectrum B. Re b * \n      Re (Complex_Matrix.trace (eigen_projector A a * eigen_projector B b * R))) =\n      (\\<Sum> b \\<in> spectrum B. Re (b * \n      Complex_Matrix.trace(eigen_projector A a * (eigen_projector B b) * R)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>spectrum B.\n       Re b *\n       Re (Complex_Matrix.trace\n            (eigen_projector A a * eigen_projector B b * R))) =\n    (\\<Sum>b\\<in>spectrum B.\n       Re (b *\n           Complex_Matrix.trace\n            (eigen_projector A a * eigen_projector B b * R)))", "proof (rule sum.cong, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum B \\<Longrightarrow>\n       Re x *\n       Re (Complex_Matrix.trace\n            (eigen_projector A a * eigen_projector B x * R)) =\n       Re (x *\n           Complex_Matrix.trace\n            (eigen_projector A a * eigen_projector B x * R))", "fix b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum B \\<Longrightarrow>\n       Re x *\n       Re (Complex_Matrix.trace\n            (eigen_projector A a * eigen_projector B x * R)) =\n       Re (x *\n           Complex_Matrix.trace\n            (eigen_projector A a * eigen_projector B x * R))", "assume \"b\\<in> spectrum B\""], ["proof (state)\nthis:\n  b \\<in> spectrum B\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum B \\<Longrightarrow>\n       Re x *\n       Re (Complex_Matrix.trace\n            (eigen_projector A a * eigen_projector B x * R)) =\n       Re (x *\n           Complex_Matrix.trace\n            (eigen_projector A a * eigen_projector B x * R))", "hence \"b\\<in> Reals\""], ["proof (prove)\nusing this:\n  b \\<in> spectrum B\n\ngoal (1 subgoal):\n 1. b \\<in> \\<real>", "using hermitian_spectrum_real[of B] assms"], ["proof (prove)\nusing this:\n  b \\<in> spectrum B\n  \\<lbrakk>B \\<in> fc_mats; hermitian B; ?a \\<in> spectrum B\\<rbrakk>\n  \\<Longrightarrow> ?a \\<in> \\<real>\n  lhv M A B R XA XB\n  A \\<in> fc_mats\n  B \\<in> fc_mats\n  R \\<in> fc_mats\n  hermitian A\n  hermitian B\n\ngoal (1 subgoal):\n 1. b \\<in> \\<real>", "by simp"], ["proof (state)\nthis:\n  b \\<in> \\<real>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum B \\<Longrightarrow>\n       Re x *\n       Re (Complex_Matrix.trace\n            (eigen_projector A a * eigen_projector B x * R)) =\n       Re (x *\n           Complex_Matrix.trace\n            (eigen_projector A a * eigen_projector B x * R))", "hence \"Re b = b\""], ["proof (prove)\nusing this:\n  b \\<in> \\<real>\n\ngoal (1 subgoal):\n 1. complex_of_real (Re b) = b", "by simp"], ["proof (state)\nthis:\n  complex_of_real (Re b) = b\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum B \\<Longrightarrow>\n       Re x *\n       Re (Complex_Matrix.trace\n            (eigen_projector A a * eigen_projector B x * R)) =\n       Re (x *\n           Complex_Matrix.trace\n            (eigen_projector A a * eigen_projector B x * R))", "thus \"Re b * Re (Complex_Matrix.trace (eigen_projector A a * eigen_projector B b * R)) =\n         Re (b * Complex_Matrix.trace (eigen_projector A a * eigen_projector B b * R))\""], ["proof (prove)\nusing this:\n  complex_of_real (Re b) = b\n\ngoal (1 subgoal):\n 1. Re b *\n    Re (Complex_Matrix.trace\n         (eigen_projector A a * eigen_projector B b * R)) =\n    Re (b *\n        Complex_Matrix.trace\n         (eigen_projector A a * eigen_projector B b * R))", "using hermitian_spectrum_real"], ["proof (prove)\nusing this:\n  complex_of_real (Re b) = b\n  \\<lbrakk>?A \\<in> fc_mats; hermitian ?A; ?a \\<in> spectrum ?A\\<rbrakk>\n  \\<Longrightarrow> ?a \\<in> \\<real>\n\ngoal (1 subgoal):\n 1. Re b *\n    Re (Complex_Matrix.trace\n         (eigen_projector A a * eigen_projector B b * R)) =\n    Re (b *\n        Complex_Matrix.trace\n         (eigen_projector A a * eigen_projector B b * R))", "using \\<open>b \\<in> \\<real>\\<close> mult_real_cpx"], ["proof (prove)\nusing this:\n  complex_of_real (Re b) = b\n  \\<lbrakk>?A \\<in> fc_mats; hermitian ?A; ?a \\<in> spectrum ?A\\<rbrakk>\n  \\<Longrightarrow> ?a \\<in> \\<real>\n  b \\<in> \\<real>\n  ?a \\<in> \\<real> \\<Longrightarrow>\n  ?a * complex_of_real (Re ?b) = complex_of_real (Re (?a * ?b))\n\ngoal (1 subgoal):\n 1. Re b *\n    Re (Complex_Matrix.trace\n         (eigen_projector A a * eigen_projector B b * R)) =\n    Re (b *\n        Complex_Matrix.trace\n         (eigen_projector A a * eigen_projector B b * R))", "by auto"], ["proof (state)\nthis:\n  Re b *\n  Re (Complex_Matrix.trace\n       (eigen_projector A a * eigen_projector B b * R)) =\n  Re (b *\n      Complex_Matrix.trace (eigen_projector A a * eigen_projector B b * R))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>b\\<in>spectrum B.\n     Re b *\n     Re (Complex_Matrix.trace\n          (eigen_projector A a * eigen_projector B b * R))) =\n  (\\<Sum>b\\<in>spectrum B.\n     Re (b *\n         Complex_Matrix.trace\n          (eigen_projector A a * eigen_projector B b * R)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum A \\<Longrightarrow>\n       Re x *\n       (\\<Sum>b\\<in>spectrum B.\n          Re b *\n          Re (Complex_Matrix.trace\n               (eigen_projector A x * eigen_projector B b * R))) =\n       Re x *\n       Re (\\<Sum>b\\<in>spectrum B.\n             b *\n             Complex_Matrix.trace\n              (eigen_projector A x * eigen_projector B b * R))", "also"], ["proof (state)\nthis:\n  (\\<Sum>b\\<in>spectrum B.\n     Re b *\n     Re (Complex_Matrix.trace\n          (eigen_projector A a * eigen_projector B b * R))) =\n  (\\<Sum>b\\<in>spectrum B.\n     Re (b *\n         Complex_Matrix.trace\n          (eigen_projector A a * eigen_projector B b * R)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum A \\<Longrightarrow>\n       Re x *\n       (\\<Sum>b\\<in>spectrum B.\n          Re b *\n          Re (Complex_Matrix.trace\n               (eigen_projector A x * eigen_projector B b * R))) =\n       Re x *\n       Re (\\<Sum>b\\<in>spectrum B.\n             b *\n             Complex_Matrix.trace\n              (eigen_projector A x * eigen_projector B b * R))", "have \"... = \n      Re (\\<Sum> b \\<in> spectrum B. b * \n        Complex_Matrix.trace(eigen_projector A a * (eigen_projector B b) * R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>spectrum B.\n       Re (b *\n           Complex_Matrix.trace\n            (eigen_projector A a * eigen_projector B b * R))) =\n    Re (\\<Sum>b\\<in>spectrum B.\n          b *\n          Complex_Matrix.trace\n           (eigen_projector A a * eigen_projector B b * R))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>b\\<in>spectrum B.\n     Re (b *\n         Complex_Matrix.trace\n          (eigen_projector A a * eigen_projector B b * R))) =\n  Re (\\<Sum>b\\<in>spectrum B.\n        b *\n        Complex_Matrix.trace\n         (eigen_projector A a * eigen_projector B b * R))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum A \\<Longrightarrow>\n       Re x *\n       (\\<Sum>b\\<in>spectrum B.\n          Re b *\n          Re (Complex_Matrix.trace\n               (eigen_projector A x * eigen_projector B b * R))) =\n       Re x *\n       Re (\\<Sum>b\\<in>spectrum B.\n             b *\n             Complex_Matrix.trace\n              (eigen_projector A x * eigen_projector B b * R))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>b\\<in>spectrum B.\n     Re b *\n     Re (Complex_Matrix.trace\n          (eigen_projector A a * eigen_projector B b * R))) =\n  Re (\\<Sum>b\\<in>spectrum B.\n        b *\n        Complex_Matrix.trace\n         (eigen_projector A a * eigen_projector B b * R))", "have \"(\\<Sum>b\\<in>spectrum B. Re b * \n      Re (Complex_Matrix.trace (eigen_projector A a * eigen_projector B b * R))) =\n      Re (\\<Sum> b \\<in> spectrum B. b * \n        Complex_Matrix.trace(eigen_projector A a * (eigen_projector B b) * R))\""], ["proof (prove)\nusing this:\n  (\\<Sum>b\\<in>spectrum B.\n     Re b *\n     Re (Complex_Matrix.trace\n          (eigen_projector A a * eigen_projector B b * R))) =\n  Re (\\<Sum>b\\<in>spectrum B.\n        b *\n        Complex_Matrix.trace\n         (eigen_projector A a * eigen_projector B b * R))\n\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>spectrum B.\n       Re b *\n       Re (Complex_Matrix.trace\n            (eigen_projector A a * eigen_projector B b * R))) =\n    Re (\\<Sum>b\\<in>spectrum B.\n          b *\n          Complex_Matrix.trace\n           (eigen_projector A a * eigen_projector B b * R))", "."], ["proof (state)\nthis:\n  (\\<Sum>b\\<in>spectrum B.\n     Re b *\n     Re (Complex_Matrix.trace\n          (eigen_projector A a * eigen_projector B b * R))) =\n  Re (\\<Sum>b\\<in>spectrum B.\n        b *\n        Complex_Matrix.trace\n         (eigen_projector A a * eigen_projector B b * R))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum A \\<Longrightarrow>\n       Re x *\n       (\\<Sum>b\\<in>spectrum B.\n          Re b *\n          Re (Complex_Matrix.trace\n               (eigen_projector A x * eigen_projector B b * R))) =\n       Re x *\n       Re (\\<Sum>b\\<in>spectrum B.\n             b *\n             Complex_Matrix.trace\n              (eigen_projector A x * eigen_projector B b * R))", "thus \"Re a * (\\<Sum>b\\<in>spectrum B. Re b * \n      Re (Complex_Matrix.trace (eigen_projector A a * eigen_projector B b * R))) =\n         Re a * Re (\\<Sum>b\\<in>spectrum B.  \n          (b * Complex_Matrix.trace (eigen_projector A a * eigen_projector B b * R)))\""], ["proof (prove)\nusing this:\n  (\\<Sum>b\\<in>spectrum B.\n     Re b *\n     Re (Complex_Matrix.trace\n          (eigen_projector A a * eigen_projector B b * R))) =\n  Re (\\<Sum>b\\<in>spectrum B.\n        b *\n        Complex_Matrix.trace\n         (eigen_projector A a * eigen_projector B b * R))\n\ngoal (1 subgoal):\n 1. Re a *\n    (\\<Sum>b\\<in>spectrum B.\n       Re b *\n       Re (Complex_Matrix.trace\n            (eigen_projector A a * eigen_projector B b * R))) =\n    Re a *\n    Re (\\<Sum>b\\<in>spectrum B.\n          b *\n          Complex_Matrix.trace\n           (eigen_projector A a * eigen_projector B b * R))", "by simp"], ["proof (state)\nthis:\n  Re a *\n  (\\<Sum>b\\<in>spectrum B.\n     Re b *\n     Re (Complex_Matrix.trace\n          (eigen_projector A a * eigen_projector B b * R))) =\n  Re a *\n  Re (\\<Sum>b\\<in>spectrum B.\n        b *\n        Complex_Matrix.trace\n         (eigen_projector A a * eigen_projector B b * R))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>spectrum A.\n     Re a *\n     (\\<Sum>b\\<in>spectrum B.\n        Re b *\n        Re (Complex_Matrix.trace\n             (eigen_projector A a * eigen_projector B b * R)))) =\n  (\\<Sum>a\\<in>spectrum A.\n     Re a *\n     Re (\\<Sum>b\\<in>spectrum B.\n           b *\n           Complex_Matrix.trace\n            (eigen_projector A a * eigen_projector B b * R)))\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect A XA w * qt_expect B XB w =\n    Re (Complex_Matrix.trace (A * B * R))", "also"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>spectrum A.\n     Re a *\n     (\\<Sum>b\\<in>spectrum B.\n        Re b *\n        Re (Complex_Matrix.trace\n             (eigen_projector A a * eigen_projector B b * R)))) =\n  (\\<Sum>a\\<in>spectrum A.\n     Re a *\n     Re (\\<Sum>b\\<in>spectrum B.\n           b *\n           Complex_Matrix.trace\n            (eigen_projector A a * eigen_projector B b * R)))\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect A XA w * qt_expect B XB w =\n    Re (Complex_Matrix.trace (A * B * R))", "have \"... =  (\\<Sum> a \\<in> spectrum A. Re (a * (\\<Sum> b \\<in> spectrum B. (b * \n    Complex_Matrix.trace(eigen_projector A a * (eigen_projector B b) * R)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A.\n       Re a *\n       Re (\\<Sum>b\\<in>spectrum B.\n             b *\n             Complex_Matrix.trace\n              (eigen_projector A a * eigen_projector B b * R))) =\n    (\\<Sum>a\\<in>spectrum A.\n       Re (a *\n           (\\<Sum>b\\<in>spectrum B.\n              b *\n              Complex_Matrix.trace\n               (eigen_projector A a * eigen_projector B b * R))))", "proof (rule sum.cong, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum A \\<Longrightarrow>\n       Re x *\n       Re (\\<Sum>b\\<in>spectrum B.\n             b *\n             Complex_Matrix.trace\n              (eigen_projector A x * eigen_projector B b * R)) =\n       Re (x *\n           (\\<Sum>b\\<in>spectrum B.\n              b *\n              Complex_Matrix.trace\n               (eigen_projector A x * eigen_projector B b * R)))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum A \\<Longrightarrow>\n       Re x *\n       Re (\\<Sum>b\\<in>spectrum B.\n             b *\n             Complex_Matrix.trace\n              (eigen_projector A x * eigen_projector B b * R)) =\n       Re (x *\n           (\\<Sum>b\\<in>spectrum B.\n              b *\n              Complex_Matrix.trace\n               (eigen_projector A x * eigen_projector B b * R)))", "assume \"x\\<in> spectrum A\""], ["proof (state)\nthis:\n  x \\<in> spectrum A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum A \\<Longrightarrow>\n       Re x *\n       Re (\\<Sum>b\\<in>spectrum B.\n             b *\n             Complex_Matrix.trace\n              (eigen_projector A x * eigen_projector B b * R)) =\n       Re (x *\n           (\\<Sum>b\\<in>spectrum B.\n              b *\n              Complex_Matrix.trace\n               (eigen_projector A x * eigen_projector B b * R)))", "hence \"Re x = x\""], ["proof (prove)\nusing this:\n  x \\<in> spectrum A\n\ngoal (1 subgoal):\n 1. complex_of_real (Re x) = x", "using ar"], ["proof (prove)\nusing this:\n  x \\<in> spectrum A\n  \\<forall>a\\<in>spectrum A. a \\<in> \\<real>\n\ngoal (1 subgoal):\n 1. complex_of_real (Re x) = x", "by simp"], ["proof (state)\nthis:\n  complex_of_real (Re x) = x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> spectrum A \\<Longrightarrow>\n       Re x *\n       Re (\\<Sum>b\\<in>spectrum B.\n             b *\n             Complex_Matrix.trace\n              (eigen_projector A x * eigen_projector B b * R)) =\n       Re (x *\n           (\\<Sum>b\\<in>spectrum B.\n              b *\n              Complex_Matrix.trace\n               (eigen_projector A x * eigen_projector B b * R)))", "thus \"Re x * Re (\\<Sum>b\\<in>spectrum B. b * \n      Complex_Matrix.trace (eigen_projector A x * eigen_projector B b * R)) =\n         Re (x * (\\<Sum>b\\<in>spectrum B. b * \n        Complex_Matrix.trace (eigen_projector A x * eigen_projector B b * R)))\""], ["proof (prove)\nusing this:\n  complex_of_real (Re x) = x\n\ngoal (1 subgoal):\n 1. Re x *\n    Re (\\<Sum>b\\<in>spectrum B.\n          b *\n          Complex_Matrix.trace\n           (eigen_projector A x * eigen_projector B b * R)) =\n    Re (x *\n        (\\<Sum>b\\<in>spectrum B.\n           b *\n           Complex_Matrix.trace\n            (eigen_projector A x * eigen_projector B b * R)))", "using \\<open>x \\<in> spectrum A\\<close> ar mult_real_cpx"], ["proof (prove)\nusing this:\n  complex_of_real (Re x) = x\n  x \\<in> spectrum A\n  \\<forall>a\\<in>spectrum A. a \\<in> \\<real>\n  ?a \\<in> \\<real> \\<Longrightarrow>\n  ?a * complex_of_real (Re ?b) = complex_of_real (Re (?a * ?b))\n\ngoal (1 subgoal):\n 1. Re x *\n    Re (\\<Sum>b\\<in>spectrum B.\n          b *\n          Complex_Matrix.trace\n           (eigen_projector A x * eigen_projector B b * R)) =\n    Re (x *\n        (\\<Sum>b\\<in>spectrum B.\n           b *\n           Complex_Matrix.trace\n            (eigen_projector A x * eigen_projector B b * R)))", "by auto"], ["proof (state)\nthis:\n  Re x *\n  Re (\\<Sum>b\\<in>spectrum B.\n        b *\n        Complex_Matrix.trace\n         (eigen_projector A x * eigen_projector B b * R)) =\n  Re (x *\n      (\\<Sum>b\\<in>spectrum B.\n         b *\n         Complex_Matrix.trace\n          (eigen_projector A x * eigen_projector B b * R)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>spectrum A.\n     Re a *\n     Re (\\<Sum>b\\<in>spectrum B.\n           b *\n           Complex_Matrix.trace\n            (eigen_projector A a * eigen_projector B b * R))) =\n  (\\<Sum>a\\<in>spectrum A.\n     Re (a *\n         (\\<Sum>b\\<in>spectrum B.\n            b *\n            Complex_Matrix.trace\n             (eigen_projector A a * eigen_projector B b * R))))\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect A XA w * qt_expect B XB w =\n    Re (Complex_Matrix.trace (A * B * R))", "also"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>spectrum A.\n     Re a *\n     Re (\\<Sum>b\\<in>spectrum B.\n           b *\n           Complex_Matrix.trace\n            (eigen_projector A a * eigen_projector B b * R))) =\n  (\\<Sum>a\\<in>spectrum A.\n     Re (a *\n         (\\<Sum>b\\<in>spectrum B.\n            b *\n            Complex_Matrix.trace\n             (eigen_projector A a * eigen_projector B b * R))))\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect A XA w * qt_expect B XB w =\n    Re (Complex_Matrix.trace (A * B * R))", "have \"... = Re (\\<Sum> a \\<in> spectrum A.  a *  (\\<Sum> b \\<in> spectrum B. (b * \n    Complex_Matrix.trace(eigen_projector A a * (eigen_projector B b) * R))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>spectrum A.\n       Re (a *\n           (\\<Sum>b\\<in>spectrum B.\n              b *\n              Complex_Matrix.trace\n               (eigen_projector A a * eigen_projector B b * R)))) =\n    Re (\\<Sum>a\\<in>spectrum A.\n          a *\n          (\\<Sum>b\\<in>spectrum B.\n             b *\n             Complex_Matrix.trace\n              (eigen_projector A a * eigen_projector B b * R)))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>spectrum A.\n     Re (a *\n         (\\<Sum>b\\<in>spectrum B.\n            b *\n            Complex_Matrix.trace\n             (eigen_projector A a * eigen_projector B b * R)))) =\n  Re (\\<Sum>a\\<in>spectrum A.\n        a *\n        (\\<Sum>b\\<in>spectrum B.\n           b *\n           Complex_Matrix.trace\n            (eigen_projector A a * eigen_projector B b * R)))\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect A XA w * qt_expect B XB w =\n    Re (Complex_Matrix.trace (A * B * R))", "also"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>spectrum A.\n     Re (a *\n         (\\<Sum>b\\<in>spectrum B.\n            b *\n            Complex_Matrix.trace\n             (eigen_projector A a * eigen_projector B b * R)))) =\n  Re (\\<Sum>a\\<in>spectrum A.\n        a *\n        (\\<Sum>b\\<in>spectrum B.\n           b *\n           Complex_Matrix.trace\n            (eigen_projector A a * eigen_projector B b * R)))\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect A XA w * qt_expect B XB w =\n    Re (Complex_Matrix.trace (A * B * R))", "have \"... = Re (Complex_Matrix.trace(A *B * R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (\\<Sum>a\\<in>spectrum A.\n          a *\n          (\\<Sum>b\\<in>spectrum B.\n             b *\n             Complex_Matrix.trace\n              (eigen_projector A a * eigen_projector B b * R))) =\n    Re (Complex_Matrix.trace (A * B * R))", "using assms \n    sum_eigen_projector_trace[of A B]"], ["proof (prove)\nusing this:\n  lhv M A B R XA XB\n  A \\<in> fc_mats\n  B \\<in> fc_mats\n  R \\<in> fc_mats\n  hermitian A\n  hermitian B\n  \\<lbrakk>hermitian A; hermitian B; A \\<in> fc_mats; B \\<in> fc_mats;\n   ?R \\<in> fc_mats\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>a\\<in>spectrum A.\n                       a *\n                       (\\<Sum>b\\<in>spectrum B.\n                          b *\n                          Complex_Matrix.trace\n                           (eigen_projector A a * eigen_projector B b *\n                            ?R))) =\n                    Complex_Matrix.trace (A * B * ?R)\n\ngoal (1 subgoal):\n 1. Re (\\<Sum>a\\<in>spectrum A.\n          a *\n          (\\<Sum>b\\<in>spectrum B.\n             b *\n             Complex_Matrix.trace\n              (eigen_projector A a * eigen_projector B b * R))) =\n    Re (Complex_Matrix.trace (A * B * R))", "by simp"], ["proof (state)\nthis:\n  Re (\\<Sum>a\\<in>spectrum A.\n        a *\n        (\\<Sum>b\\<in>spectrum B.\n           b *\n           Complex_Matrix.trace\n            (eigen_projector A a * eigen_projector B b * R))) =\n  Re (Complex_Matrix.trace (A * B * R))\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect A XA w * qt_expect B XB w =\n    Re (Complex_Matrix.trace (A * B * R))", "finally"], ["proof (chain)\npicking this:\n  LINT w|M.\n     (\\<Sum>a\\<in>spectrum A. Re a * XA a w) *\n     (\\<Sum>b\\<in>spectrum B. Re b * XB b w) =\n  Re (Complex_Matrix.trace (A * B * R))", "show ?thesis"], ["proof (prove)\nusing this:\n  LINT w|M.\n     (\\<Sum>a\\<in>spectrum A. Re a * XA a w) *\n     (\\<Sum>b\\<in>spectrum B. Re b * XB b w) =\n  Re (Complex_Matrix.trace (A * B * R))\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect A XA w * qt_expect B XB w =\n    Re (Complex_Matrix.trace (A * B * R))", "unfolding qt_expect_def"], ["proof (prove)\nusing this:\n  LINT w|M.\n     (\\<Sum>a\\<in>spectrum A. Re a * XA a w) *\n     (\\<Sum>b\\<in>spectrum B. Re b * XB b w) =\n  Re (Complex_Matrix.trace (A * B * R))\n\ngoal (1 subgoal):\n 1. LINT w|M.\n       (\\<Sum>a\\<in>spectrum A. Re a * XA a w) *\n       (\\<Sum>a\\<in>spectrum B. Re a * XB a w) =\n    Re (Complex_Matrix.trace (A * B * R))", "."], ["proof (state)\nthis:\n  LINT w|M. qt_expect A XA w * qt_expect B XB w =\n  Re (Complex_Matrix.trace (A * B * R))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Properties of specific observables\\<close>"], ["", "text \\<open>In this part we consider a specific density operator and specific observables corresponding \nto joint bipartite measurements. We will compute the quantum expectation value of this system and \nprove that it violates the CHSH inequality, thus proving that the local hidden variable assumption \ncannot hold.\\<close>"], ["", "subsubsection \\<open>Ket 0, Ket 1 and the corresponding projectors\\<close>"], ["", "definition ket_0::\"complex Matrix.vec\" where\n\"ket_0 = unit_vec 2 0\""], ["", "lemma ket_0_dim:\n  shows \"dim_vec ket_0 = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec ket_0 = 2", "unfolding ket_0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (unit_vec 2 0) = 2", "by simp"], ["", "lemma ket_0_norm:\n  shows \"\\<parallel>ket_0\\<parallel> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>ket_0\\<parallel> = 1", "using unit_cpx_vec_length"], ["proof (prove)\nusing this:\n  ?i < ?n \\<Longrightarrow> \\<parallel>unit_vec ?n ?i\\<parallel> = 1\n\ngoal (1 subgoal):\n 1. \\<parallel>ket_0\\<parallel> = 1", "unfolding ket_0_def"], ["proof (prove)\nusing this:\n  ?i < ?n \\<Longrightarrow> \\<parallel>unit_vec ?n ?i\\<parallel> = 1\n\ngoal (1 subgoal):\n 1. \\<parallel>unit_vec 2 0\\<parallel> = 1", "by simp"], ["", "lemma ket_0_mat:\n  shows \"ket_vec ket_0 =  Matrix.mat_of_cols_list 2 [[1, 0]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |ket_0\\<rangle> = Matrix.mat_of_cols_list 2 [[1, 0]]", "by (auto simp add: ket_vec_def Matrix.mat_of_cols_list_def ket_0_def)"], ["", "definition ket_1::\"complex Matrix.vec\" where\n\"ket_1 = unit_vec 2 1\""], ["", "lemma ket_1_dim:\n  shows \"dim_vec ket_1 = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec ket_1 = 2", "unfolding ket_1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (unit_vec 2 1) = 2", "by simp"], ["", "lemma ket_1_norm:\n  shows \"\\<parallel>ket_1\\<parallel> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>ket_1\\<parallel> = 1", "using unit_cpx_vec_length"], ["proof (prove)\nusing this:\n  ?i < ?n \\<Longrightarrow> \\<parallel>unit_vec ?n ?i\\<parallel> = 1\n\ngoal (1 subgoal):\n 1. \\<parallel>ket_1\\<parallel> = 1", "unfolding ket_1_def"], ["proof (prove)\nusing this:\n  ?i < ?n \\<Longrightarrow> \\<parallel>unit_vec ?n ?i\\<parallel> = 1\n\ngoal (1 subgoal):\n 1. \\<parallel>unit_vec 2 1\\<parallel> = 1", "by simp"], ["", "definition ket_01\n  where \"ket_01 = tensor_vec ket_0 ket_1\""], ["", "lemma ket_01_dim:\n  shows \"dim_vec ket_01 = 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec ket_01 = 4", "unfolding ket_01_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (ket_0 \\<otimes> ket_1) = 4", "by (simp add: ket_0_dim ket_1_dim)"], ["", "definition  ket_10 \n  where \"ket_10 = tensor_vec ket_1 ket_0\""], ["", "lemma ket_10_dim:\n  shows \"dim_vec ket_10 = 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec ket_10 = 4", "unfolding ket_10_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (ket_1 \\<otimes> ket_0) = 4", "by (simp add: ket_0_dim ket_1_dim)"], ["", "text \\<open>We define \\verb+ket_psim+, one of the Bell states (or EPR pair).\\<close>"], ["", "definition ket_psim where\n\"ket_psim = 1/(sqrt 2) \\<cdot>\\<^sub>v (ket_01 - ket_10)\""], ["", "lemma  ket_psim_dim:\n  shows \"dim_vec ket_psim = 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec ket_psim = 4", "using ket_01_dim ket_10_dim"], ["proof (prove)\nusing this:\n  dim_vec ket_01 = 4\n  dim_vec ket_10 = 4\n\ngoal (1 subgoal):\n 1. dim_vec ket_psim = 4", "unfolding ket_psim_def"], ["proof (prove)\nusing this:\n  dim_vec ket_01 = 4\n  dim_vec ket_10 = 4\n\ngoal (1 subgoal):\n 1. dim_vec\n     (complex_of_real (1 / sqrt 2) \\<cdot>\\<^sub>v (ket_01 - ket_10)) =\n    4", "by simp"], ["", "lemma ket_psim_norm:\n  shows \"\\<parallel>ket_psim\\<parallel> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>ket_psim\\<parallel> = 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<parallel>ket_psim\\<parallel> = 1", "have \"dim_vec ket_psim = 2\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec ket_psim = 2\\<^sup>2", "unfolding ket_psim_def ket_01_def ket_10_def ket_0_def ket_1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec\n     (complex_of_real (1 / sqrt 2) \\<cdot>\\<^sub>v\n      ((unit_vec 2 0 \\<otimes> unit_vec 2 1) -\n       (unit_vec 2 1 \\<otimes> unit_vec 2 0))) =\n    2\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  dim_vec ket_psim = 2\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>ket_psim\\<parallel> = 1", "moreover"], ["proof (state)\nthis:\n  dim_vec ket_psim = 2\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>ket_psim\\<parallel> = 1", "have \"(\\<Sum>i<4. (cmod (vec_index ket_psim i))\\<^sup>2) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<4. (cmod (ket_psim $ i))\\<^sup>2) = 1", "apply (auto simp add: ket_psim_def ket_01_def ket_10_def ket_0_def ket_1_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<4.\n        (cmod\n          (((if i div 2 = 0 then 1 else 0) *\n            (if i mod 2 = Suc 0 then 1 else 0) -\n            (if i div 2 = Suc 0 then 1 else 0) *\n            (if i mod 2 = 0 then 1 else 0)) /\n           complex_of_real (sqrt 2)))\\<^sup>2) =\n    1", "apply (simp add: sum_4_elems)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Sum>i<4. (cmod (ket_psim $ i))\\<^sup>2) = 1\n\ngoal (1 subgoal):\n 1. \\<parallel>ket_psim\\<parallel> = 1", "ultimately"], ["proof (chain)\npicking this:\n  dim_vec ket_psim = 2\\<^sup>2\n  (\\<Sum>i<4. (cmod (ket_psim $ i))\\<^sup>2) = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  dim_vec ket_psim = 2\\<^sup>2\n  (\\<Sum>i<4. (cmod (ket_psim $ i))\\<^sup>2) = 1\n\ngoal (1 subgoal):\n 1. \\<parallel>ket_psim\\<parallel> = 1", "by (simp add: cpx_vec_length_def)"], ["proof (state)\nthis:\n  \\<parallel>ket_psim\\<parallel> = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\\verb+rho_psim+ represents the density operator associated with the quantum \nstate \\verb+ket_psim+.\\<close>"], ["", "definition  rho_psim where\n\"rho_psim = rank_1_proj ket_psim\""], ["", "lemma rho_psim_carrier:\n  shows \"rho_psim \\<in> carrier_mat 4 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rho_psim \\<in> carrier_mat 4 4", "using rank_1_proj_carrier[of ket_psim] ket_psim_dim  \n    rho_psim_def"], ["proof (prove)\nusing this:\n  rank_1_proj ket_psim\n  \\<in> carrier_mat (dim_vec ket_psim) (dim_vec ket_psim)\n  dim_vec ket_psim = 4\n  rho_psim = rank_1_proj ket_psim\n\ngoal (1 subgoal):\n 1. rho_psim \\<in> carrier_mat 4 4", "by simp"], ["", "lemma  rho_psim_dim_row:\n  shows \"dim_row rho_psim = 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row rho_psim = 4", "using rho_psim_carrier"], ["proof (prove)\nusing this:\n  rho_psim \\<in> carrier_mat 4 4\n\ngoal (1 subgoal):\n 1. dim_row rho_psim = 4", "by simp"], ["", "lemma rho_psim_density:\n  shows \"density_operator rho_psim\""], ["proof (prove)\ngoal (1 subgoal):\n 1. density_operator rho_psim", "unfolding density_operator_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex_Matrix.positive rho_psim \\<and>\n    Complex_Matrix.trace rho_psim = 1", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. Complex_Matrix.positive rho_psim\n 2. Complex_Matrix.trace rho_psim = 1", "show \"Complex_Matrix.positive rho_psim\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex_Matrix.positive rho_psim", "using rank_1_proj_positive[of ket_psim] ket_psim_norm \n      rho_psim_def"], ["proof (prove)\nusing this:\n  \\<parallel>ket_psim\\<parallel> = 1 \\<Longrightarrow>\n  Complex_Matrix.positive (rank_1_proj ket_psim)\n  \\<parallel>ket_psim\\<parallel> = 1\n  rho_psim = rank_1_proj ket_psim\n\ngoal (1 subgoal):\n 1. Complex_Matrix.positive rho_psim", "by simp"], ["proof (state)\nthis:\n  Complex_Matrix.positive rho_psim\n\ngoal (1 subgoal):\n 1. Complex_Matrix.trace rho_psim = 1", "show \"Complex_Matrix.trace rho_psim = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex_Matrix.trace rho_psim = 1", "using rank_1_proj_trace[of ket_psim] ket_psim_norm \n      rho_psim_def"], ["proof (prove)\nusing this:\n  \\<parallel>ket_psim\\<parallel> = 1 \\<Longrightarrow>\n  Complex_Matrix.trace (rank_1_proj ket_psim) = 1\n  \\<parallel>ket_psim\\<parallel> = 1\n  rho_psim = rank_1_proj ket_psim\n\ngoal (1 subgoal):\n 1. Complex_Matrix.trace rho_psim = 1", "by simp"], ["proof (state)\nthis:\n  Complex_Matrix.trace rho_psim = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>The X and Z matrices and two of their combinations\\<close>"], ["", "text \\<open>In this part we prove properties of two standard matrices in quantum theory, $X$ and $Z$, \nas well as two of their combinations: $\\frac{X+Z}{\\sqrt{2}}$ and $\\frac{Z - X}{\\sqrt{2}}$. \nNote that all of these matrices are observables, they will be used to violate the CHSH inequality.\\<close>"], ["", "lemma Z_carrier: shows \"Z \\<in> carrier_mat 2 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Z \\<in> carrier_mat 2 2", "unfolding Z_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix.mat 2 2\n     (\\<lambda>(i, j). if i \\<noteq> j then 0 else if i = 0 then 1 else - 1)\n    \\<in> carrier_mat 2 2", "by simp"], ["", "lemma Z_hermitian:\n  shows \"hermitian Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian Z", "using dagger_adjoint dagger_of_Z"], ["proof (prove)\nusing this:\n  ?M\\<^sup>\\<dagger> = Complex_Matrix.adjoint ?M\n  Z\\<^sup>\\<dagger> = Z\n\ngoal (1 subgoal):\n 1. hermitian Z", "unfolding  hermitian_def"], ["proof (prove)\nusing this:\n  ?M\\<^sup>\\<dagger> = Complex_Matrix.adjoint ?M\n  Z\\<^sup>\\<dagger> = Z\n\ngoal (1 subgoal):\n 1. Complex_Matrix.adjoint Z = Z", "by simp"], ["", "lemma unitary_Z:\n  shows \"Complex_Matrix.unitary Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex_Matrix.unitary Z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Complex_Matrix.unitary Z", "have \"Complex_Matrix.adjoint Z * Z = (1\\<^sub>m 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex_Matrix.adjoint Z * Z = 1\\<^sub>m 2", "using dagger_adjoint[of Z]"], ["proof (prove)\nusing this:\n  Z\\<^sup>\\<dagger> = Complex_Matrix.adjoint Z\n\ngoal (1 subgoal):\n 1. Complex_Matrix.adjoint Z * Z = 1\\<^sub>m 2", "by simp"], ["proof (state)\nthis:\n  Complex_Matrix.adjoint Z * Z = 1\\<^sub>m 2\n\ngoal (1 subgoal):\n 1. Complex_Matrix.unitary Z", "thus ?thesis"], ["proof (prove)\nusing this:\n  Complex_Matrix.adjoint Z * Z = 1\\<^sub>m 2\n\ngoal (1 subgoal):\n 1. Complex_Matrix.unitary Z", "unfolding unitary_def"], ["proof (prove)\nusing this:\n  Complex_Matrix.adjoint Z * Z = 1\\<^sub>m 2\n\ngoal (1 subgoal):\n 1. Z \\<in> carrier_mat (dim_row Z) (dim_row Z) \\<and>\n    inverts_mat Z (Complex_Matrix.adjoint Z)", "by (metis Complex_Matrix.adjoint_adjoint Complex_Matrix.unitary_def Z_carrier adjoint_dim \n        carrier_matD(1) inverts_mat_def unitary_adjoint)"], ["proof (state)\nthis:\n  Complex_Matrix.unitary Z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma X_carrier: shows \"X \\<in> carrier_mat 2 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> carrier_mat 2 2", "unfolding X_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix.mat 2 2 (\\<lambda>(i, j). if i = j then 0 else 1)\n    \\<in> carrier_mat 2 2", "by simp"], ["", "lemma X_hermitian:\n  shows \"hermitian X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian X", "using dagger_adjoint dagger_of_X"], ["proof (prove)\nusing this:\n  ?M\\<^sup>\\<dagger> = Complex_Matrix.adjoint ?M\n  X\\<^sup>\\<dagger> = X\n\ngoal (1 subgoal):\n 1. hermitian X", "unfolding  hermitian_def"], ["proof (prove)\nusing this:\n  ?M\\<^sup>\\<dagger> = Complex_Matrix.adjoint ?M\n  X\\<^sup>\\<dagger> = X\n\ngoal (1 subgoal):\n 1. Complex_Matrix.adjoint X = X", "by simp"], ["", "lemma unitary_X:\n  shows \"Complex_Matrix.unitary X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex_Matrix.unitary X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Complex_Matrix.unitary X", "have \"Complex_Matrix.adjoint X * X = (1\\<^sub>m 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex_Matrix.adjoint X * X = 1\\<^sub>m 2", "using dagger_adjoint[of X]"], ["proof (prove)\nusing this:\n  X\\<^sup>\\<dagger> = Complex_Matrix.adjoint X\n\ngoal (1 subgoal):\n 1. Complex_Matrix.adjoint X * X = 1\\<^sub>m 2", "by simp"], ["proof (state)\nthis:\n  Complex_Matrix.adjoint X * X = 1\\<^sub>m 2\n\ngoal (1 subgoal):\n 1. Complex_Matrix.unitary X", "thus ?thesis"], ["proof (prove)\nusing this:\n  Complex_Matrix.adjoint X * X = 1\\<^sub>m 2\n\ngoal (1 subgoal):\n 1. Complex_Matrix.unitary X", "unfolding unitary_def"], ["proof (prove)\nusing this:\n  Complex_Matrix.adjoint X * X = 1\\<^sub>m 2\n\ngoal (1 subgoal):\n 1. X \\<in> carrier_mat (dim_row X) (dim_row X) \\<and>\n    inverts_mat X (Complex_Matrix.adjoint X)", "by (metis Complex_Matrix.adjoint_adjoint Complex_Matrix.unitary_def X_carrier adjoint_dim \n        carrier_matD(1) inverts_mat_def unitary_adjoint)"], ["proof (state)\nthis:\n  Complex_Matrix.unitary X\n\ngoal:\nNo subgoals!", "qed"], ["", "definition XpZ\n  where \"XpZ = -1/sqrt(2) \\<cdot>\\<^sub>m (X + Z)\""], ["", "lemma XpZ_carrier:\n  shows \"XpZ \\<in> carrier_mat 2 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. XpZ \\<in> carrier_mat 2 2", "unfolding XpZ_def X_def Z_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (- 1 / sqrt 2) \\<cdot>\\<^sub>m\n    (Matrix.mat 2 2 (\\<lambda>(i, j). if i = j then 0 else 1) +\n     Matrix.mat 2 2\n      (\\<lambda>(i, j).\n          if i \\<noteq> j then 0 else if i = 0 then 1 else - 1))\n    \\<in> carrier_mat 2 2", "by simp"], ["", "lemma XpZ_hermitian:\n  shows \"hermitian XpZ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian XpZ", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. hermitian XpZ", "have \"X + Z \\<in> carrier_mat 2 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X + Z \\<in> carrier_mat 2 2", "using Z_carrier X_carrier"], ["proof (prove)\nusing this:\n  Z \\<in> carrier_mat 2 2\n  X \\<in> carrier_mat 2 2\n\ngoal (1 subgoal):\n 1. X + Z \\<in> carrier_mat 2 2", "by simp"], ["proof (state)\nthis:\n  X + Z \\<in> carrier_mat 2 2\n\ngoal (1 subgoal):\n 1. hermitian XpZ", "moreover"], ["proof (state)\nthis:\n  X + Z \\<in> carrier_mat 2 2\n\ngoal (1 subgoal):\n 1. hermitian XpZ", "have \"hermitian (X + Z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian (X + Z)", "using X_hermitian Z_hermitian hermitian_add Matrix.mat_carrier"], ["proof (prove)\nusing this:\n  hermitian X\n  hermitian Z\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; ?B \\<in> carrier_mat ?n ?n;\n   hermitian ?A; hermitian ?B\\<rbrakk>\n  \\<Longrightarrow> hermitian (?A + ?B)\n  Matrix.mat ?nr ?nc ?f \\<in> carrier_mat ?nr ?nc\n\ngoal (1 subgoal):\n 1. hermitian (X + Z)", "unfolding X_def Z_def"], ["proof (prove)\nusing this:\n  hermitian (Matrix.mat 2 2 (\\<lambda>(i, j). if i = j then 0 else 1))\n  hermitian\n   (Matrix.mat 2 2\n     (\\<lambda>(i, j).\n         if i \\<noteq> j then 0 else if i = 0 then 1 else - 1))\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; ?B \\<in> carrier_mat ?n ?n;\n   hermitian ?A; hermitian ?B\\<rbrakk>\n  \\<Longrightarrow> hermitian (?A + ?B)\n  Matrix.mat ?nr ?nc ?f \\<in> carrier_mat ?nr ?nc\n\ngoal (1 subgoal):\n 1. hermitian\n     (Matrix.mat 2 2 (\\<lambda>(i, j). if i = j then 0 else 1) +\n      Matrix.mat 2 2\n       (\\<lambda>(i, j).\n           if i \\<noteq> j then 0 else if i = 0 then 1 else - 1))", "by blast"], ["proof (state)\nthis:\n  hermitian (X + Z)\n\ngoal (1 subgoal):\n 1. hermitian XpZ", "ultimately"], ["proof (chain)\npicking this:\n  X + Z \\<in> carrier_mat 2 2\n  hermitian (X + Z)", "show ?thesis"], ["proof (prove)\nusing this:\n  X + Z \\<in> carrier_mat 2 2\n  hermitian (X + Z)\n\ngoal (1 subgoal):\n 1. hermitian XpZ", "using hermitian_smult[of \"X + Z\" 2 \"- 1 / sqrt 2\"]"], ["proof (prove)\nusing this:\n  X + Z \\<in> carrier_mat 2 2\n  hermitian (X + Z)\n  \\<lbrakk>X + Z \\<in> carrier_mat 2 2; hermitian (X + Z)\\<rbrakk>\n  \\<Longrightarrow> hermitian\n                     (complex_of_real (- 1 / sqrt 2) \\<cdot>\\<^sub>m\n                      (X + Z))\n\ngoal (1 subgoal):\n 1. hermitian XpZ", "unfolding XpZ_def"], ["proof (prove)\nusing this:\n  X + Z \\<in> carrier_mat 2 2\n  hermitian (X + Z)\n  \\<lbrakk>X + Z \\<in> carrier_mat 2 2; hermitian (X + Z)\\<rbrakk>\n  \\<Longrightarrow> hermitian\n                     (complex_of_real (- 1 / sqrt 2) \\<cdot>\\<^sub>m\n                      (X + Z))\n\ngoal (1 subgoal):\n 1. hermitian (complex_of_real (- 1 / sqrt 2) \\<cdot>\\<^sub>m (X + Z))", "by auto"], ["proof (state)\nthis:\n  hermitian XpZ\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma XpZ_inv:\n  \"XpZ * XpZ = 1\\<^sub>m 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. XpZ * XpZ = 1\\<^sub>m 2", "unfolding XpZ_def X_def Z_def times_mat_def one_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix.mat\n     (dim_row\n       (complex_of_real (- 1 / sqrt 2) \\<cdot>\\<^sub>m\n        (Matrix.mat 2 2 (\\<lambda>(i, j). if i = j then 0 else 1) +\n         Matrix.mat 2 2\n          (\\<lambda>(i, j).\n              if i \\<noteq> j then 0 else if i = 0 then 1 else - 1))))\n     (dim_col\n       (complex_of_real (- 1 / sqrt 2) \\<cdot>\\<^sub>m\n        (Matrix.mat 2 2 (\\<lambda>(i, j). if i = j then 0 else 1) +\n         Matrix.mat 2 2\n          (\\<lambda>(i, j).\n              if i \\<noteq> j then 0 else if i = 0 then 1 else - 1))))\n     (\\<lambda>(i, j).\n         Matrix.row\n          (complex_of_real (- 1 / sqrt 2) \\<cdot>\\<^sub>m\n           (Matrix.mat 2 2 (\\<lambda>(i, j). if i = j then 0 else 1) +\n            Matrix.mat 2 2\n             (\\<lambda>(i, j).\n                 if i \\<noteq> j then 0 else if i = 0 then 1 else - 1)))\n          i \\<bullet>\n         Matrix.col\n          (complex_of_real (- 1 / sqrt 2) \\<cdot>\\<^sub>m\n           (Matrix.mat 2 2 (\\<lambda>(i, j). if i = j then 0 else 1) +\n            Matrix.mat 2 2\n             (\\<lambda>(i, j).\n                 if i \\<noteq> j then 0 else if i = 0 then 1 else - 1)))\n          j) =\n    Matrix.mat 2 2 (\\<lambda>(i, j). if i = j then 1 else 0)", "apply (rule cong_mat, simp+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < 2; j < 2\\<rbrakk>\n       \\<Longrightarrow> (i = 0 \\<longrightarrow>\n                          (j = 0 \\<longrightarrow>\n                           (Matrix.vec 2\n                             (\\<lambda>j. if j = 0 then 0 else 1) +\n                            Matrix.vec 2\n                             (\\<lambda>j. if 0 < j then 0 else 1)) \\<bullet>\n                           Matrix.col\n                            (Matrix.mat 2 2\n                              (\\<lambda>(i, j). if i = j then 0 else 1) +\n                             Matrix.mat 2 2\n                              (\\<lambda>(i, j).\n                                  if i \\<noteq> j then 0\n                                  else if i = 0 then 1 else - 1))\n                            0 =\n                           complex_of_real (sqrt 2) *\n                           complex_of_real (sqrt 2)) \\<and>\n                          (0 < j \\<longrightarrow>\n                           (Matrix.vec 2\n                             (\\<lambda>j. if j = 0 then 0 else 1) +\n                            Matrix.vec 2\n                             (\\<lambda>j. if 0 < j then 0 else 1)) \\<bullet>\n                           Matrix.col\n                            (Matrix.mat 2 2\n                              (\\<lambda>(i, j). if i = j then 0 else 1) +\n                             Matrix.mat 2 2\n                              (\\<lambda>(i, j).\n                                  if i \\<noteq> j then 0\n                                  else if i = 0 then 1 else - 1))\n                            j =\n                           0)) \\<and>\n                         (0 < i \\<longrightarrow>\n                          (i = j \\<longrightarrow>\n                           (Matrix.vec 2\n                             (\\<lambda>ja. if j = ja then 0 else 1) +\n                            Matrix.vec 2\n                             (\\<lambda>ja.\n                                 if j \\<noteq> ja then 0\n                                 else - 1)) \\<bullet>\n                           Matrix.col\n                            (Matrix.mat 2 2\n                              (\\<lambda>(i, j). if i = j then 0 else 1) +\n                             Matrix.mat 2 2\n                              (\\<lambda>(i, j).\n                                  if i \\<noteq> j then 0\n                                  else if i = 0 then 1 else - 1))\n                            j =\n                           complex_of_real (sqrt 2) *\n                           complex_of_real (sqrt 2)) \\<and>\n                          (i \\<noteq> j \\<longrightarrow>\n                           (Matrix.vec 2\n                             (\\<lambda>j. if i = j then 0 else 1) +\n                            Matrix.vec 2\n                             (\\<lambda>j.\n                                 if i \\<noteq> j then 0 else - 1)) \\<bullet>\n                           Matrix.col\n                            (Matrix.mat 2 2\n                              (\\<lambda>(i, j). if i = j then 0 else 1) +\n                             Matrix.mat 2 2\n                              (\\<lambda>(i, j).\n                                  if i \\<noteq> j then 0\n                                  else if i = 0 then 1 else - 1))\n                            j =\n                           0))", "apply (auto simp add: Matrix.scalar_prod_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. complex_of_real (sqrt 2) * complex_of_real (sqrt 2) = 2\n 2. \\<And>j.\n       \\<lbrakk>j < 2; 0 < j\\<rbrakk>\n       \\<Longrightarrow> complex_of_real (sqrt 2) *\n                         complex_of_real (sqrt 2) =\n                         2", "apply (auto simp add: Gates.csqrt_2_sq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma unitary_XpZ:\n  shows \"Complex_Matrix.unitary XpZ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex_Matrix.unitary XpZ", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Complex_Matrix.unitary XpZ", "have \"Complex_Matrix.adjoint XpZ * XpZ = (1\\<^sub>m 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex_Matrix.adjoint XpZ * XpZ = 1\\<^sub>m 2", "using XpZ_inv XpZ_hermitian"], ["proof (prove)\nusing this:\n  XpZ * XpZ = 1\\<^sub>m 2\n  hermitian XpZ\n\ngoal (1 subgoal):\n 1. Complex_Matrix.adjoint XpZ * XpZ = 1\\<^sub>m 2", "unfolding hermitian_def"], ["proof (prove)\nusing this:\n  XpZ * XpZ = 1\\<^sub>m 2\n  Complex_Matrix.adjoint XpZ = XpZ\n\ngoal (1 subgoal):\n 1. Complex_Matrix.adjoint XpZ * XpZ = 1\\<^sub>m 2", "by simp"], ["proof (state)\nthis:\n  Complex_Matrix.adjoint XpZ * XpZ = 1\\<^sub>m 2\n\ngoal (1 subgoal):\n 1. Complex_Matrix.unitary XpZ", "thus ?thesis"], ["proof (prove)\nusing this:\n  Complex_Matrix.adjoint XpZ * XpZ = 1\\<^sub>m 2\n\ngoal (1 subgoal):\n 1. Complex_Matrix.unitary XpZ", "unfolding unitary_def"], ["proof (prove)\nusing this:\n  Complex_Matrix.adjoint XpZ * XpZ = 1\\<^sub>m 2\n\ngoal (1 subgoal):\n 1. XpZ \\<in> carrier_mat (dim_row XpZ) (dim_row XpZ) \\<and>\n    inverts_mat XpZ (Complex_Matrix.adjoint XpZ)", "by (metis Complex_Matrix.adjoint_adjoint Complex_Matrix.unitary_def XpZ_carrier adjoint_dim \n        carrier_matD(1) inverts_mat_def unitary_adjoint)"], ["proof (state)\nthis:\n  Complex_Matrix.unitary XpZ\n\ngoal:\nNo subgoals!", "qed"], ["", "definition ZmX\n  where \"ZmX = 1/sqrt(2) \\<cdot>\\<^sub>m (Z - X)\""], ["", "lemma ZmX_carrier:\n  shows \"ZmX \\<in> carrier_mat 2 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ZmX \\<in> carrier_mat 2 2", "unfolding ZmX_def X_def Z_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (1 / sqrt 2) \\<cdot>\\<^sub>m\n    (Matrix.mat 2 2\n      (\\<lambda>(i, j).\n          if i \\<noteq> j then 0 else if i = 0 then 1 else - 1) -\n     Matrix.mat 2 2 (\\<lambda>(i, j). if i = j then 0 else 1))\n    \\<in> carrier_mat 2 2", "by (simp add: minus_carrier_mat')"], ["", "lemma ZmX_hermitian:\n  shows \"hermitian ZmX\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian ZmX", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. hermitian ZmX", "have \"Z - X \\<in> carrier_mat 2 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Z - X \\<in> carrier_mat 2 2", "unfolding X_def Z_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix.mat 2 2\n     (\\<lambda>(i, j).\n         if i \\<noteq> j then 0 else if i = 0 then 1 else - 1) -\n    Matrix.mat 2 2 (\\<lambda>(i, j). if i = j then 0 else 1)\n    \\<in> carrier_mat 2 2", "by (simp add: minus_carrier_mat)"], ["proof (state)\nthis:\n  Z - X \\<in> carrier_mat 2 2\n\ngoal (1 subgoal):\n 1. hermitian ZmX", "moreover"], ["proof (state)\nthis:\n  Z - X \\<in> carrier_mat 2 2\n\ngoal (1 subgoal):\n 1. hermitian ZmX", "have \"hermitian (Z - X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian (Z - X)", "using X_hermitian Z_hermitian hermitian_minus Matrix.mat_carrier"], ["proof (prove)\nusing this:\n  hermitian X\n  hermitian Z\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; ?B \\<in> carrier_mat ?n ?n;\n   hermitian ?A; hermitian ?B\\<rbrakk>\n  \\<Longrightarrow> hermitian (?A - ?B)\n  Matrix.mat ?nr ?nc ?f \\<in> carrier_mat ?nr ?nc\n\ngoal (1 subgoal):\n 1. hermitian (Z - X)", "unfolding X_def Z_def"], ["proof (prove)\nusing this:\n  hermitian (Matrix.mat 2 2 (\\<lambda>(i, j). if i = j then 0 else 1))\n  hermitian\n   (Matrix.mat 2 2\n     (\\<lambda>(i, j).\n         if i \\<noteq> j then 0 else if i = 0 then 1 else - 1))\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; ?B \\<in> carrier_mat ?n ?n;\n   hermitian ?A; hermitian ?B\\<rbrakk>\n  \\<Longrightarrow> hermitian (?A - ?B)\n  Matrix.mat ?nr ?nc ?f \\<in> carrier_mat ?nr ?nc\n\ngoal (1 subgoal):\n 1. hermitian\n     (Matrix.mat 2 2\n       (\\<lambda>(i, j).\n           if i \\<noteq> j then 0 else if i = 0 then 1 else - 1) -\n      Matrix.mat 2 2 (\\<lambda>(i, j). if i = j then 0 else 1))", "by blast"], ["proof (state)\nthis:\n  hermitian (Z - X)\n\ngoal (1 subgoal):\n 1. hermitian ZmX", "ultimately"], ["proof (chain)\npicking this:\n  Z - X \\<in> carrier_mat 2 2\n  hermitian (Z - X)", "show ?thesis"], ["proof (prove)\nusing this:\n  Z - X \\<in> carrier_mat 2 2\n  hermitian (Z - X)\n\ngoal (1 subgoal):\n 1. hermitian ZmX", "using hermitian_smult[of \"Z - X\" 2 \"1 / sqrt 2\"]"], ["proof (prove)\nusing this:\n  Z - X \\<in> carrier_mat 2 2\n  hermitian (Z - X)\n  \\<lbrakk>Z - X \\<in> carrier_mat 2 2; hermitian (Z - X)\\<rbrakk>\n  \\<Longrightarrow> hermitian\n                     (complex_of_real (1 / sqrt 2) \\<cdot>\\<^sub>m (Z - X))\n\ngoal (1 subgoal):\n 1. hermitian ZmX", "unfolding ZmX_def"], ["proof (prove)\nusing this:\n  Z - X \\<in> carrier_mat 2 2\n  hermitian (Z - X)\n  \\<lbrakk>Z - X \\<in> carrier_mat 2 2; hermitian (Z - X)\\<rbrakk>\n  \\<Longrightarrow> hermitian\n                     (complex_of_real (1 / sqrt 2) \\<cdot>\\<^sub>m (Z - X))\n\ngoal (1 subgoal):\n 1. hermitian (complex_of_real (1 / sqrt 2) \\<cdot>\\<^sub>m (Z - X))", "by auto"], ["proof (state)\nthis:\n  hermitian ZmX\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ZmX_inv:\n  \"ZmX * ZmX = 1\\<^sub>m 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ZmX * ZmX = 1\\<^sub>m 2", "unfolding ZmX_def X_def Z_def times_mat_def one_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix.mat\n     (dim_row\n       (complex_of_real (1 / sqrt 2) \\<cdot>\\<^sub>m\n        (Matrix.mat 2 2\n          (\\<lambda>(i, j).\n              if i \\<noteq> j then 0 else if i = 0 then 1 else - 1) -\n         Matrix.mat 2 2 (\\<lambda>(i, j). if i = j then 0 else 1))))\n     (dim_col\n       (complex_of_real (1 / sqrt 2) \\<cdot>\\<^sub>m\n        (Matrix.mat 2 2\n          (\\<lambda>(i, j).\n              if i \\<noteq> j then 0 else if i = 0 then 1 else - 1) -\n         Matrix.mat 2 2 (\\<lambda>(i, j). if i = j then 0 else 1))))\n     (\\<lambda>(i, j).\n         Matrix.row\n          (complex_of_real (1 / sqrt 2) \\<cdot>\\<^sub>m\n           (Matrix.mat 2 2\n             (\\<lambda>(i, j).\n                 if i \\<noteq> j then 0 else if i = 0 then 1 else - 1) -\n            Matrix.mat 2 2 (\\<lambda>(i, j). if i = j then 0 else 1)))\n          i \\<bullet>\n         Matrix.col\n          (complex_of_real (1 / sqrt 2) \\<cdot>\\<^sub>m\n           (Matrix.mat 2 2\n             (\\<lambda>(i, j).\n                 if i \\<noteq> j then 0 else if i = 0 then 1 else - 1) -\n            Matrix.mat 2 2 (\\<lambda>(i, j). if i = j then 0 else 1)))\n          j) =\n    Matrix.mat 2 2 (\\<lambda>(i, j). if i = j then 1 else 0)", "apply (rule cong_mat, simp+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < 2; j < 2\\<rbrakk>\n       \\<Longrightarrow> (i = j \\<longrightarrow>\n                          Matrix.row\n                           (Matrix.mat 2 2\n                             (\\<lambda>(i, j).\n                                 if i \\<noteq> j then 0\n                                 else if i = 0 then 1 else - 1) -\n                            Matrix.mat 2 2\n                             (\\<lambda>(i, j). if i = j then 0 else 1))\n                           j \\<bullet>\n                          Matrix.col\n                           (Matrix.mat 2 2\n                             (\\<lambda>(i, j).\n                                 if i \\<noteq> j then 0\n                                 else if i = 0 then 1 else - 1) -\n                            Matrix.mat 2 2\n                             (\\<lambda>(i, j). if i = j then 0 else 1))\n                           j =\n                          complex_of_real (sqrt 2) *\n                          complex_of_real (sqrt 2)) \\<and>\n                         (i \\<noteq> j \\<longrightarrow>\n                          Matrix.row\n                           (Matrix.mat 2 2\n                             (\\<lambda>(i, j).\n                                 if i \\<noteq> j then 0\n                                 else if i = 0 then 1 else - 1) -\n                            Matrix.mat 2 2\n                             (\\<lambda>(i, j). if i = j then 0 else 1))\n                           i \\<bullet>\n                          Matrix.col\n                           (Matrix.mat 2 2\n                             (\\<lambda>(i, j).\n                                 if i \\<noteq> j then 0\n                                 else if i = 0 then 1 else - 1) -\n                            Matrix.mat 2 2\n                             (\\<lambda>(i, j). if i = j then 0 else 1))\n                           j =\n                          0)", "apply (auto simp add: Matrix.scalar_prod_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < 2 \\<Longrightarrow>\n       complex_of_real (sqrt 2) * complex_of_real (sqrt 2) = 2", "apply (auto simp add: Gates.csqrt_2_sq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma unitary_ZmX:\n  shows \"Complex_Matrix.unitary ZmX\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex_Matrix.unitary ZmX", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Complex_Matrix.unitary ZmX", "have \"Complex_Matrix.adjoint ZmX * ZmX = (1\\<^sub>m 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex_Matrix.adjoint ZmX * ZmX = 1\\<^sub>m 2", "using ZmX_inv ZmX_hermitian"], ["proof (prove)\nusing this:\n  ZmX * ZmX = 1\\<^sub>m 2\n  hermitian ZmX\n\ngoal (1 subgoal):\n 1. Complex_Matrix.adjoint ZmX * ZmX = 1\\<^sub>m 2", "unfolding hermitian_def"], ["proof (prove)\nusing this:\n  ZmX * ZmX = 1\\<^sub>m 2\n  Complex_Matrix.adjoint ZmX = ZmX\n\ngoal (1 subgoal):\n 1. Complex_Matrix.adjoint ZmX * ZmX = 1\\<^sub>m 2", "by simp"], ["proof (state)\nthis:\n  Complex_Matrix.adjoint ZmX * ZmX = 1\\<^sub>m 2\n\ngoal (1 subgoal):\n 1. Complex_Matrix.unitary ZmX", "thus ?thesis"], ["proof (prove)\nusing this:\n  Complex_Matrix.adjoint ZmX * ZmX = 1\\<^sub>m 2\n\ngoal (1 subgoal):\n 1. Complex_Matrix.unitary ZmX", "unfolding unitary_def"], ["proof (prove)\nusing this:\n  Complex_Matrix.adjoint ZmX * ZmX = 1\\<^sub>m 2\n\ngoal (1 subgoal):\n 1. ZmX \\<in> carrier_mat (dim_row ZmX) (dim_row ZmX) \\<and>\n    inverts_mat ZmX (Complex_Matrix.adjoint ZmX)", "by (metis Complex_Matrix.adjoint_adjoint Complex_Matrix.unitary_def ZmX_carrier adjoint_dim \n        carrier_matD(1) inverts_mat_def unitary_adjoint)"], ["proof (state)\nthis:\n  Complex_Matrix.unitary ZmX\n\ngoal:\nNo subgoals!", "qed"], ["", "definition  Z_XpZ \n  where \"Z_XpZ = tensor_mat Z XpZ\""], ["", "lemma Z_XpZ_carrier:\n  shows \"Z_XpZ \\<in> carrier_mat 4 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Z_XpZ \\<in> carrier_mat 4 4", "unfolding Z_XpZ_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Z \\<Otimes> XpZ \\<in> carrier_mat 4 4", "using tensor_mat_carrier XpZ_carrier \n    Z_carrier"], ["proof (prove)\nusing this:\n  ?U \\<Otimes> ?V\n  \\<in> carrier_mat (dim_row ?U * dim_row ?V) (dim_col ?U * dim_col ?V)\n  XpZ \\<in> carrier_mat 2 2\n  Z \\<in> carrier_mat 2 2\n\ngoal (1 subgoal):\n 1. Z \\<Otimes> XpZ \\<in> carrier_mat 4 4", "by auto"], ["", "definition X_XpZ \n  where \"X_XpZ = tensor_mat X XpZ\""], ["", "lemma X_XpZ_carrier:\n  shows \"X_XpZ \\<in> carrier_mat 4 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X_XpZ \\<in> carrier_mat 4 4", "using tensor_mat_carrier XpZ_carrier X_carrier"], ["proof (prove)\nusing this:\n  ?U \\<Otimes> ?V\n  \\<in> carrier_mat (dim_row ?U * dim_row ?V) (dim_col ?U * dim_col ?V)\n  XpZ \\<in> carrier_mat 2 2\n  X \\<in> carrier_mat 2 2\n\ngoal (1 subgoal):\n 1. X_XpZ \\<in> carrier_mat 4 4", "unfolding X_XpZ_def"], ["proof (prove)\nusing this:\n  ?U \\<Otimes> ?V\n  \\<in> carrier_mat (dim_row ?U * dim_row ?V) (dim_col ?U * dim_col ?V)\n  XpZ \\<in> carrier_mat 2 2\n  X \\<in> carrier_mat 2 2\n\ngoal (1 subgoal):\n 1. X \\<Otimes> XpZ \\<in> carrier_mat 4 4", "by auto"], ["", "definition Z_ZmX\n  where \"Z_ZmX = tensor_mat Z ZmX\""], ["", "lemma Z_ZmX_carrier:\n  shows \"Z_ZmX \\<in> carrier_mat 4 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Z_ZmX \\<in> carrier_mat 4 4", "using tensor_mat_carrier ZmX_carrier Z_carrier"], ["proof (prove)\nusing this:\n  ?U \\<Otimes> ?V\n  \\<in> carrier_mat (dim_row ?U * dim_row ?V) (dim_col ?U * dim_col ?V)\n  ZmX \\<in> carrier_mat 2 2\n  Z \\<in> carrier_mat 2 2\n\ngoal (1 subgoal):\n 1. Z_ZmX \\<in> carrier_mat 4 4", "unfolding Z_ZmX_def"], ["proof (prove)\nusing this:\n  ?U \\<Otimes> ?V\n  \\<in> carrier_mat (dim_row ?U * dim_row ?V) (dim_col ?U * dim_col ?V)\n  ZmX \\<in> carrier_mat 2 2\n  Z \\<in> carrier_mat 2 2\n\ngoal (1 subgoal):\n 1. Z \\<Otimes> ZmX \\<in> carrier_mat 4 4", "by auto"], ["", "definition X_ZmX\n  where \"X_ZmX = tensor_mat X ZmX\""], ["", "lemma X_ZmX_carrier:\n  shows \"X_ZmX \\<in> carrier_mat 4 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X_ZmX \\<in> carrier_mat 4 4", "using tensor_mat_carrier X_carrier ZmX_carrier"], ["proof (prove)\nusing this:\n  ?U \\<Otimes> ?V\n  \\<in> carrier_mat (dim_row ?U * dim_row ?V) (dim_col ?U * dim_col ?V)\n  X \\<in> carrier_mat 2 2\n  ZmX \\<in> carrier_mat 2 2\n\ngoal (1 subgoal):\n 1. X_ZmX \\<in> carrier_mat 4 4", "unfolding X_ZmX_def"], ["proof (prove)\nusing this:\n  ?U \\<Otimes> ?V\n  \\<in> carrier_mat (dim_row ?U * dim_row ?V) (dim_col ?U * dim_col ?V)\n  X \\<in> carrier_mat 2 2\n  ZmX \\<in> carrier_mat 2 2\n\ngoal (1 subgoal):\n 1. X \\<Otimes> ZmX \\<in> carrier_mat 4 4", "by auto"], ["", "lemma  X_ZmX_rho_psim[simp]:\n  shows \"Complex_Matrix.trace (rho_psim * X_ZmX) = 1/ (sqrt 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex_Matrix.trace (rho_psim * X_ZmX) = complex_of_real (1 / sqrt 2)", "apply (auto simp add: ket_10_def ket_1_def X_ZmX_def ZmX_def X_def ket_01_def\n      Z_def rho_psim_def ket_psim_def rank_1_proj_def outer_prod_def ket_0_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex_Matrix.trace\n     (Matrix.mat 4 (Suc 0)\n       (\\<lambda>(i, j).\n           (1 / complex_of_real (sqrt 2) \\<cdot>\\<^sub>v\n            ((unit_vec 2 0 \\<otimes> unit_vec 2 (Suc 0)) -\n             (unit_vec 2 (Suc 0) \\<otimes> unit_vec 2 0))) $\n           i) *\n      Matrix.mat (Suc 0) 4\n       (\\<lambda>(i, j).\n           conjugate\n            (1 / complex_of_real (sqrt 2) \\<cdot>\\<^sub>v\n             ((unit_vec 2 0 \\<otimes> unit_vec 2 (Suc 0)) -\n              (unit_vec 2 (Suc 0) \\<otimes> unit_vec 2 0))) $\n           j) *\n      (Matrix.mat 2 2 (\\<lambda>(i, j). if i = j then 0 else 1) \\<Otimes>\n       1 / complex_of_real (sqrt 2) \\<cdot>\\<^sub>m\n       (Matrix.mat 2 2\n         (\\<lambda>(i, j).\n             if i \\<noteq> j then 0 else if i = 0 then 1 else - 1) -\n        Matrix.mat 2 2 (\\<lambda>(i, j). if i = j then 0 else 1)))) =\n    1 / complex_of_real (sqrt 2)", "apply (auto simp add: Complex_Matrix.trace_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k<4.\n        (cnj (if k div 2 = 0 then 1 else 0) *\n         cnj (if k mod 2 = Suc 0 then 1 else 0) -\n         cnj (if k div 2 = Suc 0 then 1 else 0) *\n         cnj (if k mod 2 = 0 then 1 else 0)) *\n        ((if k div 2 = 0 then 0 else 1) *\n         ((if k mod 2 = 0 then 0 else if k mod 2 = 0 then 1 else - 1) -\n          (if k mod 2 = Suc 0 then 0 else 1))) /\n        (complex_of_real (sqrt 2) * complex_of_real (sqrt 2) *\n         complex_of_real (sqrt 2))) +\n    (\\<Sum>k<4.\n        - ((cnj (if k div 2 = 0 then 1 else 0) *\n            cnj (if k mod 2 = Suc 0 then 1 else 0) -\n            cnj (if k div 2 = Suc 0 then 1 else 0) *\n            cnj (if k mod 2 = 0 then 1 else 0)) *\n           ((if k div 2 = Suc 0 then 0 else 1) *\n            ((if k mod 2 = Suc 0 then 0\n              else if k mod 2 = 0 then 1 else - 1) -\n             (if k mod 2 = 0 then 0 else 1))) /\n           (complex_of_real (sqrt 2) * complex_of_real (sqrt 2) *\n            complex_of_real (sqrt 2)))) =\n    1 / complex_of_real (sqrt 2)", "apply (simp add: sum_4_elems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 /\n    (complex_of_real (sqrt 2) *\n     (complex_of_real (sqrt 2) * complex_of_real (sqrt 2))) =\n    1 / complex_of_real (sqrt 2)", "apply (simp add: csqrt_2_sq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma  Z_ZmX_rho_psim[simp]:\n  shows \"Complex_Matrix.trace (rho_psim * Z_ZmX) = -1/ (sqrt 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex_Matrix.trace (rho_psim * Z_ZmX) = complex_of_real (- 1 / sqrt 2)", "apply (auto simp add: rho_psim_def ket_psim_def ket_10_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex_Matrix.trace\n     (rank_1_proj\n       (1 / complex_of_real (sqrt 2) \\<cdot>\\<^sub>v\n        (ket_01 - (ket_1 \\<otimes> ket_0))) *\n      Z_ZmX) =\n    - (1 / complex_of_real (sqrt 2))", "apply (auto simp add: Z_ZmX_def Z_def ZmX_def X_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex_Matrix.trace\n     (rank_1_proj\n       (1 / complex_of_real (sqrt 2) \\<cdot>\\<^sub>v\n        (ket_01 - (ket_1 \\<otimes> ket_0))) *\n      (Matrix.mat 2 2\n        (\\<lambda>(i, j).\n            if i \\<noteq> j then 0 else if i = 0 then 1 else - 1) \\<Otimes>\n       1 / complex_of_real (sqrt 2) \\<cdot>\\<^sub>m\n       (Matrix.mat 2 2\n         (\\<lambda>(i, j).\n             if i \\<noteq> j then 0 else if i = 0 then 1 else - 1) -\n        Matrix.mat 2 2 (\\<lambda>(i, j). if i = j then 0 else 1)))) =\n    - (1 / complex_of_real (sqrt 2))", "apply (auto simp add: rank_1_proj_def outer_prod_def ket_01_def ket_1_def ket_0_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex_Matrix.trace\n     (Matrix.mat 4 (Suc 0)\n       (\\<lambda>(i, j).\n           (1 / complex_of_real (sqrt 2) \\<cdot>\\<^sub>v\n            ((unit_vec 2 0 \\<otimes> unit_vec 2 (Suc 0)) -\n             (unit_vec 2 (Suc 0) \\<otimes> unit_vec 2 0))) $\n           i) *\n      Matrix.mat (Suc 0) 4\n       (\\<lambda>(i, j).\n           conjugate\n            (1 / complex_of_real (sqrt 2) \\<cdot>\\<^sub>v\n             ((unit_vec 2 0 \\<otimes> unit_vec 2 (Suc 0)) -\n              (unit_vec 2 (Suc 0) \\<otimes> unit_vec 2 0))) $\n           j) *\n      (Matrix.mat 2 2\n        (\\<lambda>(i, j).\n            if i \\<noteq> j then 0 else if i = 0 then 1 else - 1) \\<Otimes>\n       1 / complex_of_real (sqrt 2) \\<cdot>\\<^sub>m\n       (Matrix.mat 2 2\n         (\\<lambda>(i, j).\n             if i \\<noteq> j then 0 else if i = 0 then 1 else - 1) -\n        Matrix.mat 2 2 (\\<lambda>(i, j). if i = j then 0 else 1)))) =\n    - (1 / complex_of_real (sqrt 2))", "apply (auto simp add: Complex_Matrix.trace_def sum_4_elems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 /\n    (complex_of_real (sqrt 2) *\n     (complex_of_real (sqrt 2) * complex_of_real (sqrt 2))) =\n    1 / complex_of_real (sqrt 2)", "apply (simp add: csqrt_2_sq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma X_XpZ_rho_psim[simp]:\n  shows \"Complex_Matrix.trace (rho_psim * X_XpZ) =1/ (sqrt 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex_Matrix.trace (rho_psim * X_XpZ) = complex_of_real (1 / sqrt 2)", "apply (auto simp add: rho_psim_def ket_psim_def ket_10_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex_Matrix.trace\n     (rank_1_proj\n       (1 / complex_of_real (sqrt 2) \\<cdot>\\<^sub>v\n        (ket_01 - (ket_1 \\<otimes> ket_0))) *\n      X_XpZ) =\n    1 / complex_of_real (sqrt 2)", "apply (auto simp add: X_XpZ_def Z_def XpZ_def X_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex_Matrix.trace\n     (rank_1_proj\n       (1 / complex_of_real (sqrt 2) \\<cdot>\\<^sub>v\n        (ket_01 - (ket_1 \\<otimes> ket_0))) *\n      (Matrix.mat 2 2 (\\<lambda>(i, j). if i = j then 0 else 1) \\<Otimes>\n       - (1 / complex_of_real (sqrt 2)) \\<cdot>\\<^sub>m\n       (Matrix.mat 2 2 (\\<lambda>(i, j). if i = j then 0 else 1) +\n        Matrix.mat 2 2\n         (\\<lambda>(i, j).\n             if i \\<noteq> j then 0 else if i = 0 then 1 else - 1)))) =\n    1 / complex_of_real (sqrt 2)", "apply (auto simp add: rank_1_proj_def outer_prod_def ket_01_def ket_1_def ket_0_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex_Matrix.trace\n     (Matrix.mat 4 (Suc 0)\n       (\\<lambda>(i, j).\n           (1 / complex_of_real (sqrt 2) \\<cdot>\\<^sub>v\n            ((unit_vec 2 0 \\<otimes> unit_vec 2 (Suc 0)) -\n             (unit_vec 2 (Suc 0) \\<otimes> unit_vec 2 0))) $\n           i) *\n      Matrix.mat (Suc 0) 4\n       (\\<lambda>(i, j).\n           conjugate\n            (1 / complex_of_real (sqrt 2) \\<cdot>\\<^sub>v\n             ((unit_vec 2 0 \\<otimes> unit_vec 2 (Suc 0)) -\n              (unit_vec 2 (Suc 0) \\<otimes> unit_vec 2 0))) $\n           j) *\n      (Matrix.mat 2 2 (\\<lambda>(i, j). if i = j then 0 else 1) \\<Otimes>\n       - (1 / complex_of_real (sqrt 2)) \\<cdot>\\<^sub>m\n       (Matrix.mat 2 2 (\\<lambda>(i, j). if i = j then 0 else 1) +\n        Matrix.mat 2 2\n         (\\<lambda>(i, j).\n             if i \\<noteq> j then 0 else if i = 0 then 1 else - 1)))) =\n    1 / complex_of_real (sqrt 2)", "apply (auto simp add: Complex_Matrix.trace_def sum_4_elems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 /\n    (complex_of_real (sqrt 2) *\n     (complex_of_real (sqrt 2) * complex_of_real (sqrt 2))) =\n    1 / complex_of_real (sqrt 2)", "apply (simp add: csqrt_2_sq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Z_XpZ_rho_psim[simp]:\n  shows \"Complex_Matrix.trace (rho_psim * Z_XpZ) =1/ (sqrt 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex_Matrix.trace (rho_psim * Z_XpZ) = complex_of_real (1 / sqrt 2)", "apply (auto simp add: rho_psim_def ket_psim_def ket_10_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex_Matrix.trace\n     (rank_1_proj\n       (1 / complex_of_real (sqrt 2) \\<cdot>\\<^sub>v\n        (ket_01 - (ket_1 \\<otimes> ket_0))) *\n      Z_XpZ) =\n    1 / complex_of_real (sqrt 2)", "apply (auto simp add: Z_XpZ_def  XpZ_def X_def Z_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex_Matrix.trace\n     (rank_1_proj\n       (1 / complex_of_real (sqrt 2) \\<cdot>\\<^sub>v\n        (ket_01 - (ket_1 \\<otimes> ket_0))) *\n      (Matrix.mat 2 2\n        (\\<lambda>(i, j).\n            if i \\<noteq> j then 0 else if i = 0 then 1 else - 1) \\<Otimes>\n       - (1 / complex_of_real (sqrt 2)) \\<cdot>\\<^sub>m\n       (Matrix.mat 2 2 (\\<lambda>(i, j). if i = j then 0 else 1) +\n        Matrix.mat 2 2\n         (\\<lambda>(i, j).\n             if i \\<noteq> j then 0 else if i = 0 then 1 else - 1)))) =\n    1 / complex_of_real (sqrt 2)", "apply (auto simp add: rank_1_proj_def outer_prod_def ket_01_def ket_1_def ket_0_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex_Matrix.trace\n     (Matrix.mat 4 (Suc 0)\n       (\\<lambda>(i, j).\n           (1 / complex_of_real (sqrt 2) \\<cdot>\\<^sub>v\n            ((unit_vec 2 0 \\<otimes> unit_vec 2 (Suc 0)) -\n             (unit_vec 2 (Suc 0) \\<otimes> unit_vec 2 0))) $\n           i) *\n      Matrix.mat (Suc 0) 4\n       (\\<lambda>(i, j).\n           conjugate\n            (1 / complex_of_real (sqrt 2) \\<cdot>\\<^sub>v\n             ((unit_vec 2 0 \\<otimes> unit_vec 2 (Suc 0)) -\n              (unit_vec 2 (Suc 0) \\<otimes> unit_vec 2 0))) $\n           j) *\n      (Matrix.mat 2 2\n        (\\<lambda>(i, j).\n            if i \\<noteq> j then 0 else if i = 0 then 1 else - 1) \\<Otimes>\n       - (1 / complex_of_real (sqrt 2)) \\<cdot>\\<^sub>m\n       (Matrix.mat 2 2 (\\<lambda>(i, j). if i = j then 0 else 1) +\n        Matrix.mat 2 2\n         (\\<lambda>(i, j).\n             if i \\<noteq> j then 0 else if i = 0 then 1 else - 1)))) =\n    1 / complex_of_real (sqrt 2)", "apply (auto simp add: Complex_Matrix.trace_def sum_4_elems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 /\n    (complex_of_real (sqrt 2) *\n     (complex_of_real (sqrt 2) * complex_of_real (sqrt 2))) =\n    1 / complex_of_real (sqrt 2)", "apply (simp add: csqrt_2_sq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition Z_I where\n\"Z_I = tensor_mat Z (1\\<^sub>m 2)\""], ["", "lemma Z_I_carrier:\n  shows \"Z_I \\<in> carrier_mat 4 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Z_I \\<in> carrier_mat 4 4", "using tensor_mat_carrier Z_carrier"], ["proof (prove)\nusing this:\n  ?U \\<Otimes> ?V\n  \\<in> carrier_mat (dim_row ?U * dim_row ?V) (dim_col ?U * dim_col ?V)\n  Z \\<in> carrier_mat 2 2\n\ngoal (1 subgoal):\n 1. Z_I \\<in> carrier_mat 4 4", "unfolding Z_I_def"], ["proof (prove)\nusing this:\n  ?U \\<Otimes> ?V\n  \\<in> carrier_mat (dim_row ?U * dim_row ?V) (dim_col ?U * dim_col ?V)\n  Z \\<in> carrier_mat 2 2\n\ngoal (1 subgoal):\n 1. Z \\<Otimes> 1\\<^sub>m 2 \\<in> carrier_mat 4 4", "by auto"], ["", "lemma Z_I_hermitian:\n  shows \"hermitian Z_I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian Z_I", "unfolding Z_I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian (Z \\<Otimes> 1\\<^sub>m 2)", "using tensor_mat_hermitian[of Z 2 \"1\\<^sub>m 2\" 2]"], ["proof (prove)\nusing this:\n  \\<lbrakk>Z \\<in> carrier_mat 2 2; 1\\<^sub>m 2 \\<in> carrier_mat 2 2;\n   0 < 2; 0 < 2; hermitian Z; hermitian (1\\<^sub>m 2)\\<rbrakk>\n  \\<Longrightarrow> hermitian (Z \\<Otimes> 1\\<^sub>m 2)\n\ngoal (1 subgoal):\n 1. hermitian (Z \\<Otimes> 1\\<^sub>m 2)", "by (simp add: Z_carrier Z_hermitian hermitian_one)"], ["", "lemma  Z_I_unitary:\n  shows \"unitary Z_I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex_Matrix.unitary Z_I", "unfolding Z_I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex_Matrix.unitary (Z \\<Otimes> 1\\<^sub>m 2)", "using tensor_mat_unitary[of Z \"1\\<^sub>m 2\"] Z_carrier unitary_Z"], ["proof (prove)\nusing this:\n  \\<lbrakk>Complex_Matrix.unitary Z; Complex_Matrix.unitary (1\\<^sub>m 2);\n   0 < dim_row Z; 0 < dim_row (1\\<^sub>m 2)\\<rbrakk>\n  \\<Longrightarrow> Complex_Matrix.unitary (Z \\<Otimes> 1\\<^sub>m 2)\n  Z \\<in> carrier_mat 2 2\n  Complex_Matrix.unitary Z\n\ngoal (1 subgoal):\n 1. Complex_Matrix.unitary (Z \\<Otimes> 1\\<^sub>m 2)", "using unitary_one"], ["proof (prove)\nusing this:\n  \\<lbrakk>Complex_Matrix.unitary Z; Complex_Matrix.unitary (1\\<^sub>m 2);\n   0 < dim_row Z; 0 < dim_row (1\\<^sub>m 2)\\<rbrakk>\n  \\<Longrightarrow> Complex_Matrix.unitary (Z \\<Otimes> 1\\<^sub>m 2)\n  Z \\<in> carrier_mat 2 2\n  Complex_Matrix.unitary Z\n  Complex_Matrix.unitary (1\\<^sub>m ?n)\n\ngoal (1 subgoal):\n 1. Complex_Matrix.unitary (Z \\<Otimes> 1\\<^sub>m 2)", "by auto"], ["", "lemma Z_I_spectrum:\n  shows \"{Re x |x. x \\<in> spectrum Z_I} \\<subseteq> {- 1, 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Re x |x. x \\<in> spectrum Z_I} \\<subseteq> {- 1, 1}", "using unitary_hermitian_Re_spectrum Z_I_hermitian\n    Z_I_unitary Z_I_carrier"], ["proof (prove)\nusing this:\n  \\<lbrakk>Complex_Matrix.unitary ?U; hermitian ?U;\n   ?U \\<in> carrier_mat ?n ?n; 0 < ?n\\<rbrakk>\n  \\<Longrightarrow> {Re x |x. x \\<in> spectrum ?U} \\<subseteq> {- 1, 1}\n  hermitian Z_I\n  Complex_Matrix.unitary Z_I\n  Z_I \\<in> carrier_mat 4 4\n\ngoal (1 subgoal):\n 1. {Re x |x. x \\<in> spectrum Z_I} \\<subseteq> {- 1, 1}", "by simp"], ["", "definition X_I where\n\"X_I = tensor_mat X (1\\<^sub>m 2)\""], ["", "lemma  X_I_carrier:\n  shows \"X_I \\<in> carrier_mat 4 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X_I \\<in> carrier_mat 4 4", "using tensor_mat_carrier X_carrier"], ["proof (prove)\nusing this:\n  ?U \\<Otimes> ?V\n  \\<in> carrier_mat (dim_row ?U * dim_row ?V) (dim_col ?U * dim_col ?V)\n  X \\<in> carrier_mat 2 2\n\ngoal (1 subgoal):\n 1. X_I \\<in> carrier_mat 4 4", "unfolding X_I_def"], ["proof (prove)\nusing this:\n  ?U \\<Otimes> ?V\n  \\<in> carrier_mat (dim_row ?U * dim_row ?V) (dim_col ?U * dim_col ?V)\n  X \\<in> carrier_mat 2 2\n\ngoal (1 subgoal):\n 1. X \\<Otimes> 1\\<^sub>m 2 \\<in> carrier_mat 4 4", "by auto"], ["", "lemma X_I_hermitian:\n  shows \"hermitian X_I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian X_I", "unfolding X_I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian (X \\<Otimes> 1\\<^sub>m 2)", "using tensor_mat_hermitian[of X 2 \"1\\<^sub>m 2\" 2]"], ["proof (prove)\nusing this:\n  \\<lbrakk>X \\<in> carrier_mat 2 2; 1\\<^sub>m 2 \\<in> carrier_mat 2 2;\n   0 < 2; 0 < 2; hermitian X; hermitian (1\\<^sub>m 2)\\<rbrakk>\n  \\<Longrightarrow> hermitian (X \\<Otimes> 1\\<^sub>m 2)\n\ngoal (1 subgoal):\n 1. hermitian (X \\<Otimes> 1\\<^sub>m 2)", "by (simp add: X_carrier X_hermitian hermitian_one)"], ["", "lemma X_I_unitary:\n  shows \"unitary X_I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex_Matrix.unitary X_I", "unfolding X_I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex_Matrix.unitary (X \\<Otimes> 1\\<^sub>m 2)", "using tensor_mat_unitary[of X \"1\\<^sub>m 2\"] X_carrier unitary_X"], ["proof (prove)\nusing this:\n  \\<lbrakk>Complex_Matrix.unitary X; Complex_Matrix.unitary (1\\<^sub>m 2);\n   0 < dim_row X; 0 < dim_row (1\\<^sub>m 2)\\<rbrakk>\n  \\<Longrightarrow> Complex_Matrix.unitary (X \\<Otimes> 1\\<^sub>m 2)\n  X \\<in> carrier_mat 2 2\n  Complex_Matrix.unitary X\n\ngoal (1 subgoal):\n 1. Complex_Matrix.unitary (X \\<Otimes> 1\\<^sub>m 2)", "using unitary_one"], ["proof (prove)\nusing this:\n  \\<lbrakk>Complex_Matrix.unitary X; Complex_Matrix.unitary (1\\<^sub>m 2);\n   0 < dim_row X; 0 < dim_row (1\\<^sub>m 2)\\<rbrakk>\n  \\<Longrightarrow> Complex_Matrix.unitary (X \\<Otimes> 1\\<^sub>m 2)\n  X \\<in> carrier_mat 2 2\n  Complex_Matrix.unitary X\n  Complex_Matrix.unitary (1\\<^sub>m ?n)\n\ngoal (1 subgoal):\n 1. Complex_Matrix.unitary (X \\<Otimes> 1\\<^sub>m 2)", "by auto"], ["", "lemma  X_I_spectrum:\n  shows \"{Re x |x. x \\<in> spectrum X_I} \\<subseteq> {- 1, 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Re x |x. x \\<in> spectrum X_I} \\<subseteq> {- 1, 1}", "using unitary_hermitian_Re_spectrum X_I_hermitian\n    X_I_unitary X_I_carrier"], ["proof (prove)\nusing this:\n  \\<lbrakk>Complex_Matrix.unitary ?U; hermitian ?U;\n   ?U \\<in> carrier_mat ?n ?n; 0 < ?n\\<rbrakk>\n  \\<Longrightarrow> {Re x |x. x \\<in> spectrum ?U} \\<subseteq> {- 1, 1}\n  hermitian X_I\n  Complex_Matrix.unitary X_I\n  X_I \\<in> carrier_mat 4 4\n\ngoal (1 subgoal):\n 1. {Re x |x. x \\<in> spectrum X_I} \\<subseteq> {- 1, 1}", "by simp"], ["", "definition  I_XpZ where\n\"I_XpZ = tensor_mat (1\\<^sub>m 2) XpZ\""], ["", "lemma  I_XpZ_carrier:\n  shows \"I_XpZ \\<in> carrier_mat 4 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I_XpZ \\<in> carrier_mat 4 4", "using tensor_mat_carrier XpZ_carrier"], ["proof (prove)\nusing this:\n  ?U \\<Otimes> ?V\n  \\<in> carrier_mat (dim_row ?U * dim_row ?V) (dim_col ?U * dim_col ?V)\n  XpZ \\<in> carrier_mat 2 2\n\ngoal (1 subgoal):\n 1. I_XpZ \\<in> carrier_mat 4 4", "unfolding I_XpZ_def"], ["proof (prove)\nusing this:\n  ?U \\<Otimes> ?V\n  \\<in> carrier_mat (dim_row ?U * dim_row ?V) (dim_col ?U * dim_col ?V)\n  XpZ \\<in> carrier_mat 2 2\n\ngoal (1 subgoal):\n 1. 1\\<^sub>m 2 \\<Otimes> XpZ \\<in> carrier_mat 4 4", "by auto"], ["", "lemma  I_XpZ_hermitian:\n  shows \"hermitian I_XpZ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian I_XpZ", "unfolding I_XpZ_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian (1\\<^sub>m 2 \\<Otimes> XpZ)", "using tensor_mat_hermitian[of \"1\\<^sub>m 2\" 2 XpZ 2]"], ["proof (prove)\nusing this:\n  \\<lbrakk>1\\<^sub>m 2 \\<in> carrier_mat 2 2; XpZ \\<in> carrier_mat 2 2;\n   0 < 2; 0 < 2; hermitian (1\\<^sub>m 2); hermitian XpZ\\<rbrakk>\n  \\<Longrightarrow> hermitian (1\\<^sub>m 2 \\<Otimes> XpZ)\n\ngoal (1 subgoal):\n 1. hermitian (1\\<^sub>m 2 \\<Otimes> XpZ)", "by (simp add: XpZ_carrier XpZ_hermitian hermitian_one)"], ["", "lemma I_XpZ_unitary:\n  shows \"unitary I_XpZ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex_Matrix.unitary I_XpZ", "unfolding I_XpZ_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex_Matrix.unitary (1\\<^sub>m 2 \\<Otimes> XpZ)", "using tensor_mat_unitary[of \"1\\<^sub>m 2\" XpZ] XpZ_carrier \n    unitary_XpZ"], ["proof (prove)\nusing this:\n  \\<lbrakk>Complex_Matrix.unitary (1\\<^sub>m 2); Complex_Matrix.unitary XpZ;\n   0 < dim_row (1\\<^sub>m 2); 0 < dim_row XpZ\\<rbrakk>\n  \\<Longrightarrow> Complex_Matrix.unitary (1\\<^sub>m 2 \\<Otimes> XpZ)\n  XpZ \\<in> carrier_mat 2 2\n  Complex_Matrix.unitary XpZ\n\ngoal (1 subgoal):\n 1. Complex_Matrix.unitary (1\\<^sub>m 2 \\<Otimes> XpZ)", "using unitary_one"], ["proof (prove)\nusing this:\n  \\<lbrakk>Complex_Matrix.unitary (1\\<^sub>m 2); Complex_Matrix.unitary XpZ;\n   0 < dim_row (1\\<^sub>m 2); 0 < dim_row XpZ\\<rbrakk>\n  \\<Longrightarrow> Complex_Matrix.unitary (1\\<^sub>m 2 \\<Otimes> XpZ)\n  XpZ \\<in> carrier_mat 2 2\n  Complex_Matrix.unitary XpZ\n  Complex_Matrix.unitary (1\\<^sub>m ?n)\n\ngoal (1 subgoal):\n 1. Complex_Matrix.unitary (1\\<^sub>m 2 \\<Otimes> XpZ)", "by auto"], ["", "lemma I_XpZ_spectrum:\n  shows \"{Re x |x. x \\<in> spectrum I_XpZ} \\<subseteq> {- 1, 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Re x |x. x \\<in> spectrum I_XpZ} \\<subseteq> {- 1, 1}", "using unitary_hermitian_Re_spectrum \n    I_XpZ_hermitian I_XpZ_unitary I_XpZ_carrier"], ["proof (prove)\nusing this:\n  \\<lbrakk>Complex_Matrix.unitary ?U; hermitian ?U;\n   ?U \\<in> carrier_mat ?n ?n; 0 < ?n\\<rbrakk>\n  \\<Longrightarrow> {Re x |x. x \\<in> spectrum ?U} \\<subseteq> {- 1, 1}\n  hermitian I_XpZ\n  Complex_Matrix.unitary I_XpZ\n  I_XpZ \\<in> carrier_mat 4 4\n\ngoal (1 subgoal):\n 1. {Re x |x. x \\<in> spectrum I_XpZ} \\<subseteq> {- 1, 1}", "by simp"], ["", "definition I_ZmX where\n\"I_ZmX = tensor_mat (1\\<^sub>m 2) ZmX\""], ["", "lemma  I_ZmX_carrier:\n  shows \"I_ZmX \\<in> carrier_mat 4 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I_ZmX \\<in> carrier_mat 4 4", "using tensor_mat_carrier ZmX_carrier"], ["proof (prove)\nusing this:\n  ?U \\<Otimes> ?V\n  \\<in> carrier_mat (dim_row ?U * dim_row ?V) (dim_col ?U * dim_col ?V)\n  ZmX \\<in> carrier_mat 2 2\n\ngoal (1 subgoal):\n 1. I_ZmX \\<in> carrier_mat 4 4", "unfolding I_ZmX_def"], ["proof (prove)\nusing this:\n  ?U \\<Otimes> ?V\n  \\<in> carrier_mat (dim_row ?U * dim_row ?V) (dim_col ?U * dim_col ?V)\n  ZmX \\<in> carrier_mat 2 2\n\ngoal (1 subgoal):\n 1. 1\\<^sub>m 2 \\<Otimes> ZmX \\<in> carrier_mat 4 4", "by auto"], ["", "lemma I_ZmX_hermitian:\n  shows \"hermitian I_ZmX\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian I_ZmX", "unfolding I_ZmX_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian (1\\<^sub>m 2 \\<Otimes> ZmX)", "using tensor_mat_hermitian[of \"1\\<^sub>m 2\" 2 ZmX 2]"], ["proof (prove)\nusing this:\n  \\<lbrakk>1\\<^sub>m 2 \\<in> carrier_mat 2 2; ZmX \\<in> carrier_mat 2 2;\n   0 < 2; 0 < 2; hermitian (1\\<^sub>m 2); hermitian ZmX\\<rbrakk>\n  \\<Longrightarrow> hermitian (1\\<^sub>m 2 \\<Otimes> ZmX)\n\ngoal (1 subgoal):\n 1. hermitian (1\\<^sub>m 2 \\<Otimes> ZmX)", "by (simp add: ZmX_carrier ZmX_hermitian hermitian_one)"], ["", "lemma I_ZmX_unitary:\n  shows \"unitary I_ZmX\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex_Matrix.unitary I_ZmX", "unfolding I_ZmX_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex_Matrix.unitary (1\\<^sub>m 2 \\<Otimes> ZmX)", "using tensor_mat_unitary[of \"1\\<^sub>m 2\" ZmX] ZmX_carrier \n    unitary_ZmX"], ["proof (prove)\nusing this:\n  \\<lbrakk>Complex_Matrix.unitary (1\\<^sub>m 2); Complex_Matrix.unitary ZmX;\n   0 < dim_row (1\\<^sub>m 2); 0 < dim_row ZmX\\<rbrakk>\n  \\<Longrightarrow> Complex_Matrix.unitary (1\\<^sub>m 2 \\<Otimes> ZmX)\n  ZmX \\<in> carrier_mat 2 2\n  Complex_Matrix.unitary ZmX\n\ngoal (1 subgoal):\n 1. Complex_Matrix.unitary (1\\<^sub>m 2 \\<Otimes> ZmX)", "using unitary_one"], ["proof (prove)\nusing this:\n  \\<lbrakk>Complex_Matrix.unitary (1\\<^sub>m 2); Complex_Matrix.unitary ZmX;\n   0 < dim_row (1\\<^sub>m 2); 0 < dim_row ZmX\\<rbrakk>\n  \\<Longrightarrow> Complex_Matrix.unitary (1\\<^sub>m 2 \\<Otimes> ZmX)\n  ZmX \\<in> carrier_mat 2 2\n  Complex_Matrix.unitary ZmX\n  Complex_Matrix.unitary (1\\<^sub>m ?n)\n\ngoal (1 subgoal):\n 1. Complex_Matrix.unitary (1\\<^sub>m 2 \\<Otimes> ZmX)", "by auto"], ["", "lemma I_ZmX_spectrum:\n  shows \"{Re x |x. x \\<in> spectrum I_ZmX} \\<subseteq> {- 1, 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Re x |x. x \\<in> spectrum I_ZmX} \\<subseteq> {- 1, 1}", "using unitary_hermitian_Re_spectrum I_ZmX_hermitian\n    I_ZmX_unitary I_ZmX_carrier"], ["proof (prove)\nusing this:\n  \\<lbrakk>Complex_Matrix.unitary ?U; hermitian ?U;\n   ?U \\<in> carrier_mat ?n ?n; 0 < ?n\\<rbrakk>\n  \\<Longrightarrow> {Re x |x. x \\<in> spectrum ?U} \\<subseteq> {- 1, 1}\n  hermitian I_ZmX\n  Complex_Matrix.unitary I_ZmX\n  I_ZmX \\<in> carrier_mat 4 4\n\ngoal (1 subgoal):\n 1. {Re x |x. x \\<in> spectrum I_ZmX} \\<subseteq> {- 1, 1}", "by simp"], ["", "lemma X_I_ZmX_eq:\n  shows \"X_I * I_ZmX = X_ZmX\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X_I * I_ZmX = X_ZmX", "unfolding X_I_def I_ZmX_def X_ZmX_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (X \\<Otimes> 1\\<^sub>m 2) * (1\\<^sub>m 2 \\<Otimes> ZmX) =\n    X \\<Otimes> ZmX", "using mult_distr_tensor"], ["proof (prove)\nusing this:\n  \\<lbrakk>dim_col ?A = dim_row ?B; dim_col ?C = dim_row ?D; 0 < dim_col ?A;\n   0 < dim_col ?B; 0 < dim_col ?C; 0 < dim_col ?D\\<rbrakk>\n  \\<Longrightarrow> ?A * ?B \\<Otimes> ?C * ?D =\n                    (?A \\<Otimes> ?C) * (?B \\<Otimes> ?D)\n\ngoal (1 subgoal):\n 1. (X \\<Otimes> 1\\<^sub>m 2) * (1\\<^sub>m 2 \\<Otimes> ZmX) =\n    X \\<Otimes> ZmX", "by (metis (no_types, lifting) X_inv ZmX_inv index_mult_mat(2) index_mult_mat(3) index_one_mat(2) \n      index_one_mat(3) left_mult_one_mat' pos2 right_mult_one_mat')"], ["", "lemma X_I_XpZ_eq:\n  shows \"X_I * I_XpZ = X_XpZ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X_I * I_XpZ = X_XpZ", "unfolding X_I_def I_XpZ_def X_XpZ_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (X \\<Otimes> 1\\<^sub>m 2) * (1\\<^sub>m 2 \\<Otimes> XpZ) =\n    X \\<Otimes> XpZ", "using mult_distr_tensor"], ["proof (prove)\nusing this:\n  \\<lbrakk>dim_col ?A = dim_row ?B; dim_col ?C = dim_row ?D; 0 < dim_col ?A;\n   0 < dim_col ?B; 0 < dim_col ?C; 0 < dim_col ?D\\<rbrakk>\n  \\<Longrightarrow> ?A * ?B \\<Otimes> ?C * ?D =\n                    (?A \\<Otimes> ?C) * (?B \\<Otimes> ?D)\n\ngoal (1 subgoal):\n 1. (X \\<Otimes> 1\\<^sub>m 2) * (1\\<^sub>m 2 \\<Otimes> XpZ) =\n    X \\<Otimes> XpZ", "by (metis (no_types, lifting) X_inv XpZ_inv index_mult_mat(2) index_mult_mat(3) index_one_mat(2) \n      index_one_mat(3) left_mult_one_mat' pos2 right_mult_one_mat')"], ["", "lemma Z_I_XpZ_eq:\n  shows \"Z_I * I_XpZ = Z_XpZ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Z_I * I_XpZ = Z_XpZ", "unfolding Z_I_def I_XpZ_def Z_XpZ_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Z \\<Otimes> 1\\<^sub>m 2) * (1\\<^sub>m 2 \\<Otimes> XpZ) =\n    Z \\<Otimes> XpZ", "using mult_distr_tensor"], ["proof (prove)\nusing this:\n  \\<lbrakk>dim_col ?A = dim_row ?B; dim_col ?C = dim_row ?D; 0 < dim_col ?A;\n   0 < dim_col ?B; 0 < dim_col ?C; 0 < dim_col ?D\\<rbrakk>\n  \\<Longrightarrow> ?A * ?B \\<Otimes> ?C * ?D =\n                    (?A \\<Otimes> ?C) * (?B \\<Otimes> ?D)\n\ngoal (1 subgoal):\n 1. (Z \\<Otimes> 1\\<^sub>m 2) * (1\\<^sub>m 2 \\<Otimes> XpZ) =\n    Z \\<Otimes> XpZ", "by (metis (no_types, lifting) Z_inv XpZ_inv index_mult_mat(2) index_mult_mat(3) index_one_mat(2) \n      index_one_mat(3) left_mult_one_mat' pos2 right_mult_one_mat')"], ["", "lemma Z_I_ZmX_eq:\n  shows \"Z_I * I_ZmX = Z_ZmX\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Z_I * I_ZmX = Z_ZmX", "unfolding Z_I_def I_ZmX_def Z_ZmX_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Z \\<Otimes> 1\\<^sub>m 2) * (1\\<^sub>m 2 \\<Otimes> ZmX) =\n    Z \\<Otimes> ZmX", "using mult_distr_tensor"], ["proof (prove)\nusing this:\n  \\<lbrakk>dim_col ?A = dim_row ?B; dim_col ?C = dim_row ?D; 0 < dim_col ?A;\n   0 < dim_col ?B; 0 < dim_col ?C; 0 < dim_col ?D\\<rbrakk>\n  \\<Longrightarrow> ?A * ?B \\<Otimes> ?C * ?D =\n                    (?A \\<Otimes> ?C) * (?B \\<Otimes> ?D)\n\ngoal (1 subgoal):\n 1. (Z \\<Otimes> 1\\<^sub>m 2) * (1\\<^sub>m 2 \\<Otimes> ZmX) =\n    Z \\<Otimes> ZmX", "by (metis (no_types, lifting) Z_inv ZmX_inv index_mult_mat(2) index_mult_mat(3) index_one_mat(2) \n      index_one_mat(3) left_mult_one_mat' pos2 right_mult_one_mat')"], ["", "subsubsection \\<open>No local hidden variable\\<close>"], ["", "text \\<open>We show that the local hidden variable hypothesis cannot hold by exhibiting a quantum \nexpectation value that is greater than the upper-bound givven by the CHSH inequality.\\<close>"], ["", "locale bin_cpx = cpx_sq_mat +\n  assumes dim4: \"dimR = 4\""], ["", "lemma (in bin_cpx) X_I_XpZ_trace:\n  assumes \"lhv M X_I I_XpZ R Vx Vp\"\n  and \"R\\<in> fc_mats\"\n  shows \"LINT w|M. (qt_expect X_I Vx w) * (qt_expect I_XpZ  Vp w) =\n  Re (Complex_Matrix.trace (R * X_XpZ))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w =\n    Re (Complex_Matrix.trace (R * X_XpZ))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w =\n    Re (Complex_Matrix.trace (R * X_XpZ))", "have \"LINT w|M. (qt_expect X_I Vx w) * (qt_expect I_XpZ  Vp w) =\n  Re (Complex_Matrix.trace (X_I * I_XpZ * R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w =\n    Re (Complex_Matrix.trace (X_I * I_XpZ * R))", "proof (rule sum_qt_expect, (simp add: assms))"], ["proof (state)\ngoal (5 subgoals):\n 1. X_I \\<in> fc_mats\n 2. I_XpZ \\<in> fc_mats\n 3. R \\<in> fc_mats\n 4. hermitian X_I\n 5. hermitian I_XpZ", "show \"X_I \\<in> fc_mats\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X_I \\<in> fc_mats", "using X_I_carrier dim4  fc_mats_carrier dim_eq"], ["proof (prove)\nusing this:\n  X_I \\<in> carrier_mat 4 4\n  dimR = 4\n  fc_mats = carrier_mat dimR dimC\n  dimR = dimC\n\ngoal (1 subgoal):\n 1. X_I \\<in> fc_mats", "by simp"], ["proof (state)\nthis:\n  X_I \\<in> fc_mats\n\ngoal (4 subgoals):\n 1. I_XpZ \\<in> fc_mats\n 2. R \\<in> fc_mats\n 3. hermitian X_I\n 4. hermitian I_XpZ", "show \"R\\<in> fc_mats\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<in> fc_mats", "using assms"], ["proof (prove)\nusing this:\n  lhv M X_I I_XpZ R Vx Vp\n  R \\<in> fc_mats\n\ngoal (1 subgoal):\n 1. R \\<in> fc_mats", "by simp"], ["proof (state)\nthis:\n  R \\<in> fc_mats\n\ngoal (3 subgoals):\n 1. I_XpZ \\<in> fc_mats\n 2. hermitian X_I\n 3. hermitian I_XpZ", "show \"I_XpZ \\<in> fc_mats\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I_XpZ \\<in> fc_mats", "using I_XpZ_carrier dim4 fc_mats_carrier dim_eq"], ["proof (prove)\nusing this:\n  I_XpZ \\<in> carrier_mat 4 4\n  dimR = 4\n  fc_mats = carrier_mat dimR dimC\n  dimR = dimC\n\ngoal (1 subgoal):\n 1. I_XpZ \\<in> fc_mats", "by simp"], ["proof (state)\nthis:\n  I_XpZ \\<in> fc_mats\n\ngoal (2 subgoals):\n 1. hermitian X_I\n 2. hermitian I_XpZ", "show \"hermitian X_I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian X_I", "using X_I_hermitian"], ["proof (prove)\nusing this:\n  hermitian X_I\n\ngoal (1 subgoal):\n 1. hermitian X_I", "."], ["proof (state)\nthis:\n  hermitian X_I\n\ngoal (1 subgoal):\n 1. hermitian I_XpZ", "show \"hermitian I_XpZ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian I_XpZ", "using I_XpZ_hermitian"], ["proof (prove)\nusing this:\n  hermitian I_XpZ\n\ngoal (1 subgoal):\n 1. hermitian I_XpZ", "."], ["proof (state)\nthis:\n  hermitian I_XpZ\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w =\n  Re (Complex_Matrix.trace (X_I * I_XpZ * R))\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w =\n    Re (Complex_Matrix.trace (R * X_XpZ))", "also"], ["proof (state)\nthis:\n  LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w =\n  Re (Complex_Matrix.trace (X_I * I_XpZ * R))\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w =\n    Re (Complex_Matrix.trace (R * X_XpZ))", "have \"... = Re (Complex_Matrix.trace (X_XpZ * R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (Complex_Matrix.trace (X_I * I_XpZ * R)) =\n    Re (Complex_Matrix.trace (X_XpZ * R))", "using X_I_XpZ_eq"], ["proof (prove)\nusing this:\n  X_I * I_XpZ = X_XpZ\n\ngoal (1 subgoal):\n 1. Re (Complex_Matrix.trace (X_I * I_XpZ * R)) =\n    Re (Complex_Matrix.trace (X_XpZ * R))", "by simp"], ["proof (state)\nthis:\n  Re (Complex_Matrix.trace (X_I * I_XpZ * R)) =\n  Re (Complex_Matrix.trace (X_XpZ * R))\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w =\n    Re (Complex_Matrix.trace (R * X_XpZ))", "also"], ["proof (state)\nthis:\n  Re (Complex_Matrix.trace (X_I * I_XpZ * R)) =\n  Re (Complex_Matrix.trace (X_XpZ * R))\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w =\n    Re (Complex_Matrix.trace (R * X_XpZ))", "have \"... = Re (Complex_Matrix.trace (R * X_XpZ))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (Complex_Matrix.trace (X_XpZ * R)) =\n    Re (Complex_Matrix.trace (R * X_XpZ))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Re (Complex_Matrix.trace (X_XpZ * R)) =\n    Re (Complex_Matrix.trace (R * X_XpZ))", "have \"Complex_Matrix.trace (X_XpZ * R) = Complex_Matrix.trace (R * X_XpZ)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex_Matrix.trace (X_XpZ * R) = Complex_Matrix.trace (R * X_XpZ)", "using trace_comm[of X_XpZ 4 R] X_XpZ_carrier assms dim4 fc_mats_carrier dim_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>X_XpZ \\<in> carrier_mat 4 4; R \\<in> carrier_mat 4 4\\<rbrakk>\n  \\<Longrightarrow> Complex_Matrix.trace (X_XpZ * R) =\n                    Complex_Matrix.trace (R * X_XpZ)\n  X_XpZ \\<in> carrier_mat 4 4\n  lhv M X_I I_XpZ R Vx Vp\n  R \\<in> fc_mats\n  dimR = 4\n  fc_mats = carrier_mat dimR dimC\n  dimR = dimC\n\ngoal (1 subgoal):\n 1. Complex_Matrix.trace (X_XpZ * R) = Complex_Matrix.trace (R * X_XpZ)", "by simp"], ["proof (state)\nthis:\n  Complex_Matrix.trace (X_XpZ * R) = Complex_Matrix.trace (R * X_XpZ)\n\ngoal (1 subgoal):\n 1. Re (Complex_Matrix.trace (X_XpZ * R)) =\n    Re (Complex_Matrix.trace (R * X_XpZ))", "thus ?thesis"], ["proof (prove)\nusing this:\n  Complex_Matrix.trace (X_XpZ * R) = Complex_Matrix.trace (R * X_XpZ)\n\ngoal (1 subgoal):\n 1. Re (Complex_Matrix.trace (X_XpZ * R)) =\n    Re (Complex_Matrix.trace (R * X_XpZ))", "by simp"], ["proof (state)\nthis:\n  Re (Complex_Matrix.trace (X_XpZ * R)) =\n  Re (Complex_Matrix.trace (R * X_XpZ))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Re (Complex_Matrix.trace (X_XpZ * R)) =\n  Re (Complex_Matrix.trace (R * X_XpZ))\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w =\n    Re (Complex_Matrix.trace (R * X_XpZ))", "finally"], ["proof (chain)\npicking this:\n  LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w =\n  Re (Complex_Matrix.trace (R * X_XpZ))", "show ?thesis"], ["proof (prove)\nusing this:\n  LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w =\n  Re (Complex_Matrix.trace (R * X_XpZ))\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w =\n    Re (Complex_Matrix.trace (R * X_XpZ))", "."], ["proof (state)\nthis:\n  LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w =\n  Re (Complex_Matrix.trace (R * X_XpZ))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in bin_cpx) X_I_XpZ_chsh:\n  assumes \"lhv M X_I I_XpZ rho_psim Vx Vp\"\n  shows \"LINT w|M. (qt_expect X_I Vx w) * (qt_expect I_XpZ Vp w) =\n  1/sqrt 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w = 1 / sqrt 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w = 1 / sqrt 2", "have \"LINT w|M. (qt_expect X_I Vx w) * (qt_expect I_XpZ Vp w) =\n  Re (Complex_Matrix.trace (rho_psim * X_XpZ))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w =\n    Re (Complex_Matrix.trace (rho_psim * X_XpZ))", "proof (rule X_I_XpZ_trace, (simp add: assms))"], ["proof (state)\ngoal (1 subgoal):\n 1. rho_psim \\<in> fc_mats", "show \"rho_psim \\<in> fc_mats\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rho_psim \\<in> fc_mats", "using rho_psim_carrier fc_mats_carrier dim_eq dim4"], ["proof (prove)\nusing this:\n  rho_psim \\<in> carrier_mat 4 4\n  fc_mats = carrier_mat dimR dimC\n  dimR = dimC\n  dimR = 4\n\ngoal (1 subgoal):\n 1. rho_psim \\<in> fc_mats", "by simp"], ["proof (state)\nthis:\n  rho_psim \\<in> fc_mats\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w =\n  Re (Complex_Matrix.trace (rho_psim * X_XpZ))\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w = 1 / sqrt 2", "also"], ["proof (state)\nthis:\n  LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w =\n  Re (Complex_Matrix.trace (rho_psim * X_XpZ))\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w = 1 / sqrt 2", "have \"... = 1/sqrt 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (Complex_Matrix.trace (rho_psim * X_XpZ)) = 1 / sqrt 2", "using X_XpZ_rho_psim"], ["proof (prove)\nusing this:\n  Complex_Matrix.trace (rho_psim * X_XpZ) = complex_of_real (1 / sqrt 2)\n\ngoal (1 subgoal):\n 1. Re (Complex_Matrix.trace (rho_psim * X_XpZ)) = 1 / sqrt 2", "by simp"], ["proof (state)\nthis:\n  Re (Complex_Matrix.trace (rho_psim * X_XpZ)) = 1 / sqrt 2\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w = 1 / sqrt 2", "finally"], ["proof (chain)\npicking this:\n  LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w = 1 / sqrt 2", "show ?thesis"], ["proof (prove)\nusing this:\n  LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w = 1 / sqrt 2\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w = 1 / sqrt 2", "."], ["proof (state)\nthis:\n  LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w = 1 / sqrt 2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in bin_cpx) Z_I_XpZ_trace:\n  assumes \"lhv M Z_I I_XpZ R Vz Vp\"\n  and \"R\\<in> fc_mats\"\n  shows \"LINT w|M. (qt_expect Z_I Vz w) * (qt_expect I_XpZ Vp w) =\n  Re (Complex_Matrix.trace (R * Z_XpZ))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w =\n    Re (Complex_Matrix.trace (R * Z_XpZ))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w =\n    Re (Complex_Matrix.trace (R * Z_XpZ))", "have \"LINT w|M. (qt_expect Z_I Vz w) * (qt_expect I_XpZ Vp w) =\n  Re (Complex_Matrix.trace (Z_I * I_XpZ * R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w =\n    Re (Complex_Matrix.trace (Z_I * I_XpZ * R))", "proof (rule sum_qt_expect, (simp add: assms))"], ["proof (state)\ngoal (5 subgoals):\n 1. Z_I \\<in> fc_mats\n 2. I_XpZ \\<in> fc_mats\n 3. R \\<in> fc_mats\n 4. hermitian Z_I\n 5. hermitian I_XpZ", "show \"Z_I \\<in> fc_mats\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Z_I \\<in> fc_mats", "using Z_I_carrier dim4 fc_mats_carrier dim_eq"], ["proof (prove)\nusing this:\n  Z_I \\<in> carrier_mat 4 4\n  dimR = 4\n  fc_mats = carrier_mat dimR dimC\n  dimR = dimC\n\ngoal (1 subgoal):\n 1. Z_I \\<in> fc_mats", "by simp"], ["proof (state)\nthis:\n  Z_I \\<in> fc_mats\n\ngoal (4 subgoals):\n 1. I_XpZ \\<in> fc_mats\n 2. R \\<in> fc_mats\n 3. hermitian Z_I\n 4. hermitian I_XpZ", "show \"R\\<in> fc_mats\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<in> fc_mats", "using assms"], ["proof (prove)\nusing this:\n  lhv M Z_I I_XpZ R Vz Vp\n  R \\<in> fc_mats\n\ngoal (1 subgoal):\n 1. R \\<in> fc_mats", "by simp"], ["proof (state)\nthis:\n  R \\<in> fc_mats\n\ngoal (3 subgoals):\n 1. I_XpZ \\<in> fc_mats\n 2. hermitian Z_I\n 3. hermitian I_XpZ", "show \"I_XpZ \\<in> fc_mats\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I_XpZ \\<in> fc_mats", "using I_XpZ_carrier dim4 fc_mats_carrier dim_eq"], ["proof (prove)\nusing this:\n  I_XpZ \\<in> carrier_mat 4 4\n  dimR = 4\n  fc_mats = carrier_mat dimR dimC\n  dimR = dimC\n\ngoal (1 subgoal):\n 1. I_XpZ \\<in> fc_mats", "by simp"], ["proof (state)\nthis:\n  I_XpZ \\<in> fc_mats\n\ngoal (2 subgoals):\n 1. hermitian Z_I\n 2. hermitian I_XpZ", "show \"hermitian Z_I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian Z_I", "using Z_I_hermitian"], ["proof (prove)\nusing this:\n  hermitian Z_I\n\ngoal (1 subgoal):\n 1. hermitian Z_I", "."], ["proof (state)\nthis:\n  hermitian Z_I\n\ngoal (1 subgoal):\n 1. hermitian I_XpZ", "show \"hermitian I_XpZ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian I_XpZ", "using I_XpZ_hermitian"], ["proof (prove)\nusing this:\n  hermitian I_XpZ\n\ngoal (1 subgoal):\n 1. hermitian I_XpZ", "."], ["proof (state)\nthis:\n  hermitian I_XpZ\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w =\n  Re (Complex_Matrix.trace (Z_I * I_XpZ * R))\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w =\n    Re (Complex_Matrix.trace (R * Z_XpZ))", "also"], ["proof (state)\nthis:\n  LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w =\n  Re (Complex_Matrix.trace (Z_I * I_XpZ * R))\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w =\n    Re (Complex_Matrix.trace (R * Z_XpZ))", "have \"... = Re (Complex_Matrix.trace (Z_XpZ * R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (Complex_Matrix.trace (Z_I * I_XpZ * R)) =\n    Re (Complex_Matrix.trace (Z_XpZ * R))", "using Z_I_XpZ_eq"], ["proof (prove)\nusing this:\n  Z_I * I_XpZ = Z_XpZ\n\ngoal (1 subgoal):\n 1. Re (Complex_Matrix.trace (Z_I * I_XpZ * R)) =\n    Re (Complex_Matrix.trace (Z_XpZ * R))", "by simp"], ["proof (state)\nthis:\n  Re (Complex_Matrix.trace (Z_I * I_XpZ * R)) =\n  Re (Complex_Matrix.trace (Z_XpZ * R))\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w =\n    Re (Complex_Matrix.trace (R * Z_XpZ))", "also"], ["proof (state)\nthis:\n  Re (Complex_Matrix.trace (Z_I * I_XpZ * R)) =\n  Re (Complex_Matrix.trace (Z_XpZ * R))\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w =\n    Re (Complex_Matrix.trace (R * Z_XpZ))", "have \"... = Re (Complex_Matrix.trace (R * Z_XpZ))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (Complex_Matrix.trace (Z_XpZ * R)) =\n    Re (Complex_Matrix.trace (R * Z_XpZ))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Re (Complex_Matrix.trace (Z_XpZ * R)) =\n    Re (Complex_Matrix.trace (R * Z_XpZ))", "have \"Complex_Matrix.trace (Z_XpZ * R) = Complex_Matrix.trace (R * Z_XpZ)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex_Matrix.trace (Z_XpZ * R) = Complex_Matrix.trace (R * Z_XpZ)", "using trace_comm[of Z_XpZ 4 R] Z_XpZ_carrier assms dim4 fc_mats_carrier dim_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>Z_XpZ \\<in> carrier_mat 4 4; R \\<in> carrier_mat 4 4\\<rbrakk>\n  \\<Longrightarrow> Complex_Matrix.trace (Z_XpZ * R) =\n                    Complex_Matrix.trace (R * Z_XpZ)\n  Z_XpZ \\<in> carrier_mat 4 4\n  lhv M Z_I I_XpZ R Vz Vp\n  R \\<in> fc_mats\n  dimR = 4\n  fc_mats = carrier_mat dimR dimC\n  dimR = dimC\n\ngoal (1 subgoal):\n 1. Complex_Matrix.trace (Z_XpZ * R) = Complex_Matrix.trace (R * Z_XpZ)", "by simp"], ["proof (state)\nthis:\n  Complex_Matrix.trace (Z_XpZ * R) = Complex_Matrix.trace (R * Z_XpZ)\n\ngoal (1 subgoal):\n 1. Re (Complex_Matrix.trace (Z_XpZ * R)) =\n    Re (Complex_Matrix.trace (R * Z_XpZ))", "thus ?thesis"], ["proof (prove)\nusing this:\n  Complex_Matrix.trace (Z_XpZ * R) = Complex_Matrix.trace (R * Z_XpZ)\n\ngoal (1 subgoal):\n 1. Re (Complex_Matrix.trace (Z_XpZ * R)) =\n    Re (Complex_Matrix.trace (R * Z_XpZ))", "by simp"], ["proof (state)\nthis:\n  Re (Complex_Matrix.trace (Z_XpZ * R)) =\n  Re (Complex_Matrix.trace (R * Z_XpZ))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Re (Complex_Matrix.trace (Z_XpZ * R)) =\n  Re (Complex_Matrix.trace (R * Z_XpZ))\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w =\n    Re (Complex_Matrix.trace (R * Z_XpZ))", "finally"], ["proof (chain)\npicking this:\n  LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w =\n  Re (Complex_Matrix.trace (R * Z_XpZ))", "show ?thesis"], ["proof (prove)\nusing this:\n  LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w =\n  Re (Complex_Matrix.trace (R * Z_XpZ))\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w =\n    Re (Complex_Matrix.trace (R * Z_XpZ))", "."], ["proof (state)\nthis:\n  LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w =\n  Re (Complex_Matrix.trace (R * Z_XpZ))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in bin_cpx) Z_I_XpZ_chsh:\n  assumes \"lhv M Z_I I_XpZ rho_psim Vz Vp\"\n  shows \"LINT w|M. (qt_expect Z_I Vz w) * (qt_expect I_XpZ Vp w) =\n  1/sqrt 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w = 1 / sqrt 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w = 1 / sqrt 2", "have \"LINT w|M. (qt_expect Z_I Vz w) * (qt_expect I_XpZ Vp w) =\n  Re (Complex_Matrix.trace (rho_psim * Z_XpZ))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w =\n    Re (Complex_Matrix.trace (rho_psim * Z_XpZ))", "proof (rule Z_I_XpZ_trace, (simp add: assms))"], ["proof (state)\ngoal (1 subgoal):\n 1. rho_psim \\<in> fc_mats", "show \"rho_psim \\<in> fc_mats\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rho_psim \\<in> fc_mats", "using rho_psim_carrier fc_mats_carrier dim_eq dim4"], ["proof (prove)\nusing this:\n  rho_psim \\<in> carrier_mat 4 4\n  fc_mats = carrier_mat dimR dimC\n  dimR = dimC\n  dimR = 4\n\ngoal (1 subgoal):\n 1. rho_psim \\<in> fc_mats", "by simp"], ["proof (state)\nthis:\n  rho_psim \\<in> fc_mats\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w =\n  Re (Complex_Matrix.trace (rho_psim * Z_XpZ))\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w = 1 / sqrt 2", "also"], ["proof (state)\nthis:\n  LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w =\n  Re (Complex_Matrix.trace (rho_psim * Z_XpZ))\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w = 1 / sqrt 2", "have \"... = 1/sqrt 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (Complex_Matrix.trace (rho_psim * Z_XpZ)) = 1 / sqrt 2", "using Z_XpZ_rho_psim"], ["proof (prove)\nusing this:\n  Complex_Matrix.trace (rho_psim * Z_XpZ) = complex_of_real (1 / sqrt 2)\n\ngoal (1 subgoal):\n 1. Re (Complex_Matrix.trace (rho_psim * Z_XpZ)) = 1 / sqrt 2", "by simp"], ["proof (state)\nthis:\n  Re (Complex_Matrix.trace (rho_psim * Z_XpZ)) = 1 / sqrt 2\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w = 1 / sqrt 2", "finally"], ["proof (chain)\npicking this:\n  LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w = 1 / sqrt 2", "show ?thesis"], ["proof (prove)\nusing this:\n  LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w = 1 / sqrt 2\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w = 1 / sqrt 2", "unfolding qt_expect_def"], ["proof (prove)\nusing this:\n  LINT w|M.\n     (\\<Sum>a\\<in>spectrum Z_I. Re a * Vz a w) *\n     (\\<Sum>a\\<in>spectrum I_XpZ. Re a * Vp a w) =\n  1 / sqrt 2\n\ngoal (1 subgoal):\n 1. LINT w|M.\n       (\\<Sum>a\\<in>spectrum Z_I. Re a * Vz a w) *\n       (\\<Sum>a\\<in>spectrum I_XpZ. Re a * Vp a w) =\n    1 / sqrt 2", "."], ["proof (state)\nthis:\n  LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w = 1 / sqrt 2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in bin_cpx) X_I_ZmX_trace:\n  assumes \"lhv M X_I I_ZmX R Vx Vp\"\n  and \"R\\<in> fc_mats\"\n  shows \"LINT w|M. (qt_expect X_I Vx w) * (qt_expect I_ZmX Vp w) =\n  Re (Complex_Matrix.trace (R * X_ZmX))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vp w =\n    Re (Complex_Matrix.trace (R * X_ZmX))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vp w =\n    Re (Complex_Matrix.trace (R * X_ZmX))", "have \"LINT w|M. (qt_expect X_I Vx w) * (qt_expect I_ZmX Vp w) =\n  Re (Complex_Matrix.trace (X_I * I_ZmX * R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vp w =\n    Re (Complex_Matrix.trace (X_I * I_ZmX * R))", "proof (rule sum_qt_expect, (simp add: assms))"], ["proof (state)\ngoal (5 subgoals):\n 1. X_I \\<in> fc_mats\n 2. I_ZmX \\<in> fc_mats\n 3. R \\<in> fc_mats\n 4. hermitian X_I\n 5. hermitian I_ZmX", "show \"X_I \\<in> fc_mats\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X_I \\<in> fc_mats", "using X_I_carrier dim4 fc_mats_carrier dim_eq"], ["proof (prove)\nusing this:\n  X_I \\<in> carrier_mat 4 4\n  dimR = 4\n  fc_mats = carrier_mat dimR dimC\n  dimR = dimC\n\ngoal (1 subgoal):\n 1. X_I \\<in> fc_mats", "by simp"], ["proof (state)\nthis:\n  X_I \\<in> fc_mats\n\ngoal (4 subgoals):\n 1. I_ZmX \\<in> fc_mats\n 2. R \\<in> fc_mats\n 3. hermitian X_I\n 4. hermitian I_ZmX", "show \"R\\<in> fc_mats\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<in> fc_mats", "using assms"], ["proof (prove)\nusing this:\n  lhv M X_I I_ZmX R Vx Vp\n  R \\<in> fc_mats\n\ngoal (1 subgoal):\n 1. R \\<in> fc_mats", "by simp"], ["proof (state)\nthis:\n  R \\<in> fc_mats\n\ngoal (3 subgoals):\n 1. I_ZmX \\<in> fc_mats\n 2. hermitian X_I\n 3. hermitian I_ZmX", "show \"I_ZmX \\<in> fc_mats\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I_ZmX \\<in> fc_mats", "using I_ZmX_carrier dim4 fc_mats_carrier dim_eq"], ["proof (prove)\nusing this:\n  I_ZmX \\<in> carrier_mat 4 4\n  dimR = 4\n  fc_mats = carrier_mat dimR dimC\n  dimR = dimC\n\ngoal (1 subgoal):\n 1. I_ZmX \\<in> fc_mats", "by simp"], ["proof (state)\nthis:\n  I_ZmX \\<in> fc_mats\n\ngoal (2 subgoals):\n 1. hermitian X_I\n 2. hermitian I_ZmX", "show \"hermitian X_I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian X_I", "using X_I_hermitian"], ["proof (prove)\nusing this:\n  hermitian X_I\n\ngoal (1 subgoal):\n 1. hermitian X_I", "."], ["proof (state)\nthis:\n  hermitian X_I\n\ngoal (1 subgoal):\n 1. hermitian I_ZmX", "show \"hermitian I_ZmX\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian I_ZmX", "using I_ZmX_hermitian"], ["proof (prove)\nusing this:\n  hermitian I_ZmX\n\ngoal (1 subgoal):\n 1. hermitian I_ZmX", "."], ["proof (state)\nthis:\n  hermitian I_ZmX\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vp w =\n  Re (Complex_Matrix.trace (X_I * I_ZmX * R))\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vp w =\n    Re (Complex_Matrix.trace (R * X_ZmX))", "also"], ["proof (state)\nthis:\n  LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vp w =\n  Re (Complex_Matrix.trace (X_I * I_ZmX * R))\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vp w =\n    Re (Complex_Matrix.trace (R * X_ZmX))", "have \"... = Re (Complex_Matrix.trace (X_ZmX * R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (Complex_Matrix.trace (X_I * I_ZmX * R)) =\n    Re (Complex_Matrix.trace (X_ZmX * R))", "using X_I_ZmX_eq"], ["proof (prove)\nusing this:\n  X_I * I_ZmX = X_ZmX\n\ngoal (1 subgoal):\n 1. Re (Complex_Matrix.trace (X_I * I_ZmX * R)) =\n    Re (Complex_Matrix.trace (X_ZmX * R))", "by simp"], ["proof (state)\nthis:\n  Re (Complex_Matrix.trace (X_I * I_ZmX * R)) =\n  Re (Complex_Matrix.trace (X_ZmX * R))\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vp w =\n    Re (Complex_Matrix.trace (R * X_ZmX))", "also"], ["proof (state)\nthis:\n  Re (Complex_Matrix.trace (X_I * I_ZmX * R)) =\n  Re (Complex_Matrix.trace (X_ZmX * R))\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vp w =\n    Re (Complex_Matrix.trace (R * X_ZmX))", "have \"... = Re (Complex_Matrix.trace (R * X_ZmX))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (Complex_Matrix.trace (X_ZmX * R)) =\n    Re (Complex_Matrix.trace (R * X_ZmX))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Re (Complex_Matrix.trace (X_ZmX * R)) =\n    Re (Complex_Matrix.trace (R * X_ZmX))", "have \"Complex_Matrix.trace (X_ZmX * R) = Complex_Matrix.trace (R * X_ZmX)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex_Matrix.trace (X_ZmX * R) = Complex_Matrix.trace (R * X_ZmX)", "using trace_comm[of X_ZmX 4 R] X_ZmX_carrier assms dim4 fc_mats_carrier dim_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>X_ZmX \\<in> carrier_mat 4 4; R \\<in> carrier_mat 4 4\\<rbrakk>\n  \\<Longrightarrow> Complex_Matrix.trace (X_ZmX * R) =\n                    Complex_Matrix.trace (R * X_ZmX)\n  X_ZmX \\<in> carrier_mat 4 4\n  lhv M X_I I_ZmX R Vx Vp\n  R \\<in> fc_mats\n  dimR = 4\n  fc_mats = carrier_mat dimR dimC\n  dimR = dimC\n\ngoal (1 subgoal):\n 1. Complex_Matrix.trace (X_ZmX * R) = Complex_Matrix.trace (R * X_ZmX)", "by simp"], ["proof (state)\nthis:\n  Complex_Matrix.trace (X_ZmX * R) = Complex_Matrix.trace (R * X_ZmX)\n\ngoal (1 subgoal):\n 1. Re (Complex_Matrix.trace (X_ZmX * R)) =\n    Re (Complex_Matrix.trace (R * X_ZmX))", "thus ?thesis"], ["proof (prove)\nusing this:\n  Complex_Matrix.trace (X_ZmX * R) = Complex_Matrix.trace (R * X_ZmX)\n\ngoal (1 subgoal):\n 1. Re (Complex_Matrix.trace (X_ZmX * R)) =\n    Re (Complex_Matrix.trace (R * X_ZmX))", "by simp"], ["proof (state)\nthis:\n  Re (Complex_Matrix.trace (X_ZmX * R)) =\n  Re (Complex_Matrix.trace (R * X_ZmX))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Re (Complex_Matrix.trace (X_ZmX * R)) =\n  Re (Complex_Matrix.trace (R * X_ZmX))\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vp w =\n    Re (Complex_Matrix.trace (R * X_ZmX))", "finally"], ["proof (chain)\npicking this:\n  LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vp w =\n  Re (Complex_Matrix.trace (R * X_ZmX))", "show ?thesis"], ["proof (prove)\nusing this:\n  LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vp w =\n  Re (Complex_Matrix.trace (R * X_ZmX))\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vp w =\n    Re (Complex_Matrix.trace (R * X_ZmX))", "."], ["proof (state)\nthis:\n  LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vp w =\n  Re (Complex_Matrix.trace (R * X_ZmX))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in bin_cpx) X_I_ZmX_chsh:\n  assumes \"lhv M X_I I_ZmX rho_psim Vx Vp\"\n  shows \"LINT w|M. (qt_expect X_I Vx w) * (qt_expect I_ZmX Vp w) =\n  1/sqrt 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vp w = 1 / sqrt 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vp w = 1 / sqrt 2", "have \"LINT w|M. (qt_expect X_I Vx w) * (qt_expect I_ZmX Vp w) =\n  Re (Complex_Matrix.trace (rho_psim * X_ZmX))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vp w =\n    Re (Complex_Matrix.trace (rho_psim * X_ZmX))", "proof (rule X_I_ZmX_trace, (simp add: assms))"], ["proof (state)\ngoal (1 subgoal):\n 1. rho_psim \\<in> fc_mats", "show \"rho_psim \\<in> fc_mats\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rho_psim \\<in> fc_mats", "using rho_psim_carrier fc_mats_carrier dim_eq dim4"], ["proof (prove)\nusing this:\n  rho_psim \\<in> carrier_mat 4 4\n  fc_mats = carrier_mat dimR dimC\n  dimR = dimC\n  dimR = 4\n\ngoal (1 subgoal):\n 1. rho_psim \\<in> fc_mats", "by simp"], ["proof (state)\nthis:\n  rho_psim \\<in> fc_mats\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vp w =\n  Re (Complex_Matrix.trace (rho_psim * X_ZmX))\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vp w = 1 / sqrt 2", "also"], ["proof (state)\nthis:\n  LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vp w =\n  Re (Complex_Matrix.trace (rho_psim * X_ZmX))\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vp w = 1 / sqrt 2", "have \"... = 1/sqrt 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (Complex_Matrix.trace (rho_psim * X_ZmX)) = 1 / sqrt 2", "using X_ZmX_rho_psim"], ["proof (prove)\nusing this:\n  Complex_Matrix.trace (rho_psim * X_ZmX) = complex_of_real (1 / sqrt 2)\n\ngoal (1 subgoal):\n 1. Re (Complex_Matrix.trace (rho_psim * X_ZmX)) = 1 / sqrt 2", "by simp"], ["proof (state)\nthis:\n  Re (Complex_Matrix.trace (rho_psim * X_ZmX)) = 1 / sqrt 2\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vp w = 1 / sqrt 2", "finally"], ["proof (chain)\npicking this:\n  LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vp w = 1 / sqrt 2", "show ?thesis"], ["proof (prove)\nusing this:\n  LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vp w = 1 / sqrt 2\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vp w = 1 / sqrt 2", "unfolding qt_expect_def"], ["proof (prove)\nusing this:\n  LINT w|M.\n     (\\<Sum>a\\<in>spectrum X_I. Re a * Vx a w) *\n     (\\<Sum>a\\<in>spectrum I_ZmX. Re a * Vp a w) =\n  1 / sqrt 2\n\ngoal (1 subgoal):\n 1. LINT w|M.\n       (\\<Sum>a\\<in>spectrum X_I. Re a * Vx a w) *\n       (\\<Sum>a\\<in>spectrum I_ZmX. Re a * Vp a w) =\n    1 / sqrt 2", "."], ["proof (state)\nthis:\n  LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vp w = 1 / sqrt 2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in bin_cpx) Z_I_ZmX_trace:\n  assumes \"lhv M Z_I I_ZmX R Vz Vp\"\n  and \"R\\<in> fc_mats\"\n  shows \"LINT w|M. (qt_expect Z_I Vz w) * (qt_expect I_ZmX Vp w) =\n  Re (Complex_Matrix.trace (R * Z_ZmX))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vp w =\n    Re (Complex_Matrix.trace (R * Z_ZmX))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vp w =\n    Re (Complex_Matrix.trace (R * Z_ZmX))", "have \"LINT w|M. (qt_expect Z_I Vz w) * (qt_expect I_ZmX Vp w) =\n  Re (Complex_Matrix.trace (Z_I * I_ZmX * R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vp w =\n    Re (Complex_Matrix.trace (Z_I * I_ZmX * R))", "proof (rule sum_qt_expect, (simp add: assms))"], ["proof (state)\ngoal (5 subgoals):\n 1. Z_I \\<in> fc_mats\n 2. I_ZmX \\<in> fc_mats\n 3. R \\<in> fc_mats\n 4. hermitian Z_I\n 5. hermitian I_ZmX", "show \"Z_I \\<in> fc_mats\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Z_I \\<in> fc_mats", "using Z_I_carrier dim4 fc_mats_carrier dim_eq"], ["proof (prove)\nusing this:\n  Z_I \\<in> carrier_mat 4 4\n  dimR = 4\n  fc_mats = carrier_mat dimR dimC\n  dimR = dimC\n\ngoal (1 subgoal):\n 1. Z_I \\<in> fc_mats", "by simp"], ["proof (state)\nthis:\n  Z_I \\<in> fc_mats\n\ngoal (4 subgoals):\n 1. I_ZmX \\<in> fc_mats\n 2. R \\<in> fc_mats\n 3. hermitian Z_I\n 4. hermitian I_ZmX", "show \"R\\<in> fc_mats\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<in> fc_mats", "using assms"], ["proof (prove)\nusing this:\n  lhv M Z_I I_ZmX R Vz Vp\n  R \\<in> fc_mats\n\ngoal (1 subgoal):\n 1. R \\<in> fc_mats", "by simp"], ["proof (state)\nthis:\n  R \\<in> fc_mats\n\ngoal (3 subgoals):\n 1. I_ZmX \\<in> fc_mats\n 2. hermitian Z_I\n 3. hermitian I_ZmX", "show \"I_ZmX \\<in> fc_mats\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I_ZmX \\<in> fc_mats", "using I_ZmX_carrier dim4 fc_mats_carrier dim_eq"], ["proof (prove)\nusing this:\n  I_ZmX \\<in> carrier_mat 4 4\n  dimR = 4\n  fc_mats = carrier_mat dimR dimC\n  dimR = dimC\n\ngoal (1 subgoal):\n 1. I_ZmX \\<in> fc_mats", "by simp"], ["proof (state)\nthis:\n  I_ZmX \\<in> fc_mats\n\ngoal (2 subgoals):\n 1. hermitian Z_I\n 2. hermitian I_ZmX", "show \"hermitian Z_I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian Z_I", "using Z_I_hermitian"], ["proof (prove)\nusing this:\n  hermitian Z_I\n\ngoal (1 subgoal):\n 1. hermitian Z_I", "."], ["proof (state)\nthis:\n  hermitian Z_I\n\ngoal (1 subgoal):\n 1. hermitian I_ZmX", "show \"hermitian I_ZmX\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian I_ZmX", "using I_ZmX_hermitian"], ["proof (prove)\nusing this:\n  hermitian I_ZmX\n\ngoal (1 subgoal):\n 1. hermitian I_ZmX", "."], ["proof (state)\nthis:\n  hermitian I_ZmX\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vp w =\n  Re (Complex_Matrix.trace (Z_I * I_ZmX * R))\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vp w =\n    Re (Complex_Matrix.trace (R * Z_ZmX))", "also"], ["proof (state)\nthis:\n  LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vp w =\n  Re (Complex_Matrix.trace (Z_I * I_ZmX * R))\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vp w =\n    Re (Complex_Matrix.trace (R * Z_ZmX))", "have \"... = Re (Complex_Matrix.trace (Z_ZmX * R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (Complex_Matrix.trace (Z_I * I_ZmX * R)) =\n    Re (Complex_Matrix.trace (Z_ZmX * R))", "using Z_I_ZmX_eq"], ["proof (prove)\nusing this:\n  Z_I * I_ZmX = Z_ZmX\n\ngoal (1 subgoal):\n 1. Re (Complex_Matrix.trace (Z_I * I_ZmX * R)) =\n    Re (Complex_Matrix.trace (Z_ZmX * R))", "by simp"], ["proof (state)\nthis:\n  Re (Complex_Matrix.trace (Z_I * I_ZmX * R)) =\n  Re (Complex_Matrix.trace (Z_ZmX * R))\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vp w =\n    Re (Complex_Matrix.trace (R * Z_ZmX))", "also"], ["proof (state)\nthis:\n  Re (Complex_Matrix.trace (Z_I * I_ZmX * R)) =\n  Re (Complex_Matrix.trace (Z_ZmX * R))\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vp w =\n    Re (Complex_Matrix.trace (R * Z_ZmX))", "have \"... = Re (Complex_Matrix.trace (R * Z_ZmX))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (Complex_Matrix.trace (Z_ZmX * R)) =\n    Re (Complex_Matrix.trace (R * Z_ZmX))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Re (Complex_Matrix.trace (Z_ZmX * R)) =\n    Re (Complex_Matrix.trace (R * Z_ZmX))", "have \"Complex_Matrix.trace (Z_ZmX * R) = Complex_Matrix.trace (R * Z_ZmX)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex_Matrix.trace (Z_ZmX * R) = Complex_Matrix.trace (R * Z_ZmX)", "using trace_comm[of Z_ZmX 4 R] Z_ZmX_carrier assms dim4 fc_mats_carrier dim_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>Z_ZmX \\<in> carrier_mat 4 4; R \\<in> carrier_mat 4 4\\<rbrakk>\n  \\<Longrightarrow> Complex_Matrix.trace (Z_ZmX * R) =\n                    Complex_Matrix.trace (R * Z_ZmX)\n  Z_ZmX \\<in> carrier_mat 4 4\n  lhv M Z_I I_ZmX R Vz Vp\n  R \\<in> fc_mats\n  dimR = 4\n  fc_mats = carrier_mat dimR dimC\n  dimR = dimC\n\ngoal (1 subgoal):\n 1. Complex_Matrix.trace (Z_ZmX * R) = Complex_Matrix.trace (R * Z_ZmX)", "by simp"], ["proof (state)\nthis:\n  Complex_Matrix.trace (Z_ZmX * R) = Complex_Matrix.trace (R * Z_ZmX)\n\ngoal (1 subgoal):\n 1. Re (Complex_Matrix.trace (Z_ZmX * R)) =\n    Re (Complex_Matrix.trace (R * Z_ZmX))", "thus ?thesis"], ["proof (prove)\nusing this:\n  Complex_Matrix.trace (Z_ZmX * R) = Complex_Matrix.trace (R * Z_ZmX)\n\ngoal (1 subgoal):\n 1. Re (Complex_Matrix.trace (Z_ZmX * R)) =\n    Re (Complex_Matrix.trace (R * Z_ZmX))", "by simp"], ["proof (state)\nthis:\n  Re (Complex_Matrix.trace (Z_ZmX * R)) =\n  Re (Complex_Matrix.trace (R * Z_ZmX))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Re (Complex_Matrix.trace (Z_ZmX * R)) =\n  Re (Complex_Matrix.trace (R * Z_ZmX))\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vp w =\n    Re (Complex_Matrix.trace (R * Z_ZmX))", "finally"], ["proof (chain)\npicking this:\n  LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vp w =\n  Re (Complex_Matrix.trace (R * Z_ZmX))", "show ?thesis"], ["proof (prove)\nusing this:\n  LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vp w =\n  Re (Complex_Matrix.trace (R * Z_ZmX))\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vp w =\n    Re (Complex_Matrix.trace (R * Z_ZmX))", "."], ["proof (state)\nthis:\n  LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vp w =\n  Re (Complex_Matrix.trace (R * Z_ZmX))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in bin_cpx) Z_I_ZmX_chsh:\n  assumes \"lhv M Z_I I_ZmX rho_psim Vz Vp\"\nshows \"LINT w|M. (qt_expect Z_I Vz w) * (qt_expect I_ZmX Vp w) =\n  -1/sqrt 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vp w = - 1 / sqrt 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vp w = - 1 / sqrt 2", "have \"LINT w|M. (qt_expect Z_I Vz w) * (qt_expect I_ZmX Vp w) =\n  Re (Complex_Matrix.trace (rho_psim * Z_ZmX))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vp w =\n    Re (Complex_Matrix.trace (rho_psim * Z_ZmX))", "proof (rule Z_I_ZmX_trace, (simp add: assms))"], ["proof (state)\ngoal (1 subgoal):\n 1. rho_psim \\<in> fc_mats", "show \"rho_psim \\<in> fc_mats\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rho_psim \\<in> fc_mats", "using rho_psim_carrier fc_mats_carrier dim_eq dim4"], ["proof (prove)\nusing this:\n  rho_psim \\<in> carrier_mat 4 4\n  fc_mats = carrier_mat dimR dimC\n  dimR = dimC\n  dimR = 4\n\ngoal (1 subgoal):\n 1. rho_psim \\<in> fc_mats", "by simp"], ["proof (state)\nthis:\n  rho_psim \\<in> fc_mats\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vp w =\n  Re (Complex_Matrix.trace (rho_psim * Z_ZmX))\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vp w = - 1 / sqrt 2", "also"], ["proof (state)\nthis:\n  LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vp w =\n  Re (Complex_Matrix.trace (rho_psim * Z_ZmX))\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vp w = - 1 / sqrt 2", "have \"... = -1/sqrt 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (Complex_Matrix.trace (rho_psim * Z_ZmX)) = - 1 / sqrt 2", "using Z_ZmX_rho_psim"], ["proof (prove)\nusing this:\n  Complex_Matrix.trace (rho_psim * Z_ZmX) = complex_of_real (- 1 / sqrt 2)\n\ngoal (1 subgoal):\n 1. Re (Complex_Matrix.trace (rho_psim * Z_ZmX)) = - 1 / sqrt 2", "by simp"], ["proof (state)\nthis:\n  Re (Complex_Matrix.trace (rho_psim * Z_ZmX)) = - 1 / sqrt 2\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vp w = - 1 / sqrt 2", "finally"], ["proof (chain)\npicking this:\n  LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vp w = - 1 / sqrt 2", "show ?thesis"], ["proof (prove)\nusing this:\n  LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vp w = - 1 / sqrt 2\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vp w = - 1 / sqrt 2", "unfolding qt_expect_def"], ["proof (prove)\nusing this:\n  LINT w|M.\n     (\\<Sum>a\\<in>spectrum Z_I. Re a * Vz a w) *\n     (\\<Sum>a\\<in>spectrum I_ZmX. Re a * Vp a w) =\n  - 1 / sqrt 2\n\ngoal (1 subgoal):\n 1. LINT w|M.\n       (\\<Sum>a\\<in>spectrum Z_I. Re a * Vz a w) *\n       (\\<Sum>a\\<in>spectrum I_ZmX. Re a * Vp a w) =\n    - 1 / sqrt 2", "."], ["proof (state)\nthis:\n  LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vp w = - 1 / sqrt 2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in bin_cpx) chsh_upper_bound:\n  assumes \"prob_space M\"\n  and \"lhv M X_I I_XpZ rho_psim Vx Vp\"\n  and \"lhv M Z_I I_XpZ rho_psim Vz Vp\"\n  and \"lhv M X_I I_ZmX rho_psim Vx Vm\"\n  and \"lhv M Z_I I_ZmX rho_psim Vz Vm\"\nshows \"\\<bar>(LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w) + \n        (LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w) + \n        (LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w) -\n        (LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w)\\<bar>\n  \\<le> 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>(LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w) +\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w) +\n          (LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w) -\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w)\\<bar>\n    \\<le> 2", "proof (rule prob_space.chsh_expect)"], ["proof (state)\ngoal (9 subgoals):\n 1. prob_space M\n 2. AE w in M. \\<bar>qt_expect Z_I Vz w\\<bar> \\<le> 1\n 3. AE w in M. \\<bar>qt_expect X_I Vx w\\<bar> \\<le> 1\n 4. AE w in M. \\<bar>qt_expect I_ZmX Vm w\\<bar> \\<le> 1\n 5. AE w in M. \\<bar>qt_expect I_XpZ Vp w\\<bar> \\<le> 1\n 6. integrable M (\\<lambda>w. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w)\n 7. integrable M (\\<lambda>w. qt_expect X_I Vx w * qt_expect I_XpZ Vp w)\n 8. integrable M (\\<lambda>w. qt_expect X_I Vx w * qt_expect I_ZmX Vm w)\n 9. integrable M (\\<lambda>w. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w)", "show \"AE w in M. \\<bar>qt_expect X_I Vx w\\<bar> \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE w in M. \\<bar>qt_expect X_I Vx w\\<bar> \\<le> 1", "unfolding qt_expect_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. AE w in M. \\<bar>\\<Sum>a\\<in>spectrum X_I. Re a * Vx a w\\<bar> \\<le> 1", "proof (rule spectrum_abs_1_weighted_suml)"], ["proof (state)\ngoal (5 subgoals):\n 1. lhv M X_I ?B ?R Vx ?Vb\n 2. {Re x |x. x \\<in> spectrum X_I} \\<noteq> {}\n 3. {Re x |x. x \\<in> spectrum X_I} \\<subseteq> {- 1, 1}\n 4. hermitian X_I\n 5. X_I \\<in> fc_mats", "show \"X_I \\<in> fc_mats\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X_I \\<in> fc_mats", "using X_I_carrier fc_mats_carrier dim_eq dim4"], ["proof (prove)\nusing this:\n  X_I \\<in> carrier_mat 4 4\n  fc_mats = carrier_mat dimR dimC\n  dimR = dimC\n  dimR = 4\n\ngoal (1 subgoal):\n 1. X_I \\<in> fc_mats", "by simp"], ["proof (state)\nthis:\n  X_I \\<in> fc_mats\n\ngoal (4 subgoals):\n 1. lhv M X_I ?B ?R Vx ?Vb\n 2. {Re x |x. x \\<in> spectrum X_I} \\<noteq> {}\n 3. {Re x |x. x \\<in> spectrum X_I} \\<subseteq> {- 1, 1}\n 4. hermitian X_I", "show \"hermitian X_I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian X_I", "using X_I_hermitian"], ["proof (prove)\nusing this:\n  hermitian X_I\n\ngoal (1 subgoal):\n 1. hermitian X_I", "."], ["proof (state)\nthis:\n  hermitian X_I\n\ngoal (3 subgoals):\n 1. lhv M X_I ?B ?R Vx ?Vb\n 2. {Re x |x. x \\<in> spectrum X_I} \\<noteq> {}\n 3. {Re x |x. x \\<in> spectrum X_I} \\<subseteq> {- 1, 1}", "show \"lhv M X_I I_XpZ rho_psim Vx Vp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lhv M X_I I_XpZ rho_psim Vx Vp", "using assms"], ["proof (prove)\nusing this:\n  prob_space M\n  lhv M X_I I_XpZ rho_psim Vx Vp\n  lhv M Z_I I_XpZ rho_psim Vz Vp\n  lhv M X_I I_ZmX rho_psim Vx Vm\n  lhv M Z_I I_ZmX rho_psim Vz Vm\n\ngoal (1 subgoal):\n 1. lhv M X_I I_XpZ rho_psim Vx Vp", "by simp"], ["proof (state)\nthis:\n  lhv M X_I I_XpZ rho_psim Vx Vp\n\ngoal (2 subgoals):\n 1. {Re x |x. x \\<in> spectrum X_I} \\<noteq> {}\n 2. {Re x |x. x \\<in> spectrum X_I} \\<subseteq> {- 1, 1}", "show \"{Re x |x. x \\<in> spectrum X_I} \\<subseteq> {- 1, 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Re x |x. x \\<in> spectrum X_I} \\<subseteq> {- 1, 1}", "using X_I_spectrum"], ["proof (prove)\nusing this:\n  {Re x |x. x \\<in> spectrum X_I} \\<subseteq> {- 1, 1}\n\ngoal (1 subgoal):\n 1. {Re x |x. x \\<in> spectrum X_I} \\<subseteq> {- 1, 1}", "by simp"], ["proof (state)\nthis:\n  {Re x |x. x \\<in> spectrum X_I} \\<subseteq> {- 1, 1}\n\ngoal (1 subgoal):\n 1. {Re x |x. x \\<in> spectrum X_I} \\<noteq> {}", "show \"{Re x |x. x \\<in> spectrum X_I} \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Re x |x. x \\<in> spectrum X_I} \\<noteq> {}", "using spectrum_ne X_I_hermitian \\<open>X_I \\<in> fc_mats\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> fc_mats; hermitian ?A\\<rbrakk>\n  \\<Longrightarrow> spectrum ?A \\<noteq> {}\n  hermitian X_I\n  X_I \\<in> fc_mats\n\ngoal (1 subgoal):\n 1. {Re x |x. x \\<in> spectrum X_I} \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  {Re x |x. x \\<in> spectrum X_I} \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  AE w in M. \\<bar>qt_expect X_I Vx w\\<bar> \\<le> 1\n\ngoal (8 subgoals):\n 1. prob_space M\n 2. AE w in M. \\<bar>qt_expect Z_I Vz w\\<bar> \\<le> 1\n 3. AE w in M. \\<bar>qt_expect I_ZmX Vm w\\<bar> \\<le> 1\n 4. AE w in M. \\<bar>qt_expect I_XpZ Vp w\\<bar> \\<le> 1\n 5. integrable M (\\<lambda>w. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w)\n 6. integrable M (\\<lambda>w. qt_expect X_I Vx w * qt_expect I_XpZ Vp w)\n 7. integrable M (\\<lambda>w. qt_expect X_I Vx w * qt_expect I_ZmX Vm w)\n 8. integrable M (\\<lambda>w. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w)", "show \"AE w in M. \\<bar>qt_expect Z_I Vz w\\<bar> \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE w in M. \\<bar>qt_expect Z_I Vz w\\<bar> \\<le> 1", "unfolding qt_expect_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. AE w in M. \\<bar>\\<Sum>a\\<in>spectrum Z_I. Re a * Vz a w\\<bar> \\<le> 1", "proof (rule spectrum_abs_1_weighted_suml)"], ["proof (state)\ngoal (5 subgoals):\n 1. lhv M Z_I ?B ?R Vz ?Vb\n 2. {Re x |x. x \\<in> spectrum Z_I} \\<noteq> {}\n 3. {Re x |x. x \\<in> spectrum Z_I} \\<subseteq> {- 1, 1}\n 4. hermitian Z_I\n 5. Z_I \\<in> fc_mats", "show \"Z_I \\<in> fc_mats\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Z_I \\<in> fc_mats", "using Z_I_carrier fc_mats_carrier dim_eq dim4"], ["proof (prove)\nusing this:\n  Z_I \\<in> carrier_mat 4 4\n  fc_mats = carrier_mat dimR dimC\n  dimR = dimC\n  dimR = 4\n\ngoal (1 subgoal):\n 1. Z_I \\<in> fc_mats", "by simp"], ["proof (state)\nthis:\n  Z_I \\<in> fc_mats\n\ngoal (4 subgoals):\n 1. lhv M Z_I ?B ?R Vz ?Vb\n 2. {Re x |x. x \\<in> spectrum Z_I} \\<noteq> {}\n 3. {Re x |x. x \\<in> spectrum Z_I} \\<subseteq> {- 1, 1}\n 4. hermitian Z_I", "show \"hermitian Z_I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian Z_I", "using Z_I_hermitian"], ["proof (prove)\nusing this:\n  hermitian Z_I\n\ngoal (1 subgoal):\n 1. hermitian Z_I", "."], ["proof (state)\nthis:\n  hermitian Z_I\n\ngoal (3 subgoals):\n 1. lhv M Z_I ?B ?R Vz ?Vb\n 2. {Re x |x. x \\<in> spectrum Z_I} \\<noteq> {}\n 3. {Re x |x. x \\<in> spectrum Z_I} \\<subseteq> {- 1, 1}", "show \"lhv M Z_I I_XpZ rho_psim Vz Vp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lhv M Z_I I_XpZ rho_psim Vz Vp", "using assms"], ["proof (prove)\nusing this:\n  prob_space M\n  lhv M X_I I_XpZ rho_psim Vx Vp\n  lhv M Z_I I_XpZ rho_psim Vz Vp\n  lhv M X_I I_ZmX rho_psim Vx Vm\n  lhv M Z_I I_ZmX rho_psim Vz Vm\n\ngoal (1 subgoal):\n 1. lhv M Z_I I_XpZ rho_psim Vz Vp", "by simp"], ["proof (state)\nthis:\n  lhv M Z_I I_XpZ rho_psim Vz Vp\n\ngoal (2 subgoals):\n 1. {Re x |x. x \\<in> spectrum Z_I} \\<noteq> {}\n 2. {Re x |x. x \\<in> spectrum Z_I} \\<subseteq> {- 1, 1}", "show \"{Re x |x. x \\<in> spectrum Z_I} \\<subseteq> {- 1, 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Re x |x. x \\<in> spectrum Z_I} \\<subseteq> {- 1, 1}", "using Z_I_spectrum"], ["proof (prove)\nusing this:\n  {Re x |x. x \\<in> spectrum Z_I} \\<subseteq> {- 1, 1}\n\ngoal (1 subgoal):\n 1. {Re x |x. x \\<in> spectrum Z_I} \\<subseteq> {- 1, 1}", "by simp"], ["proof (state)\nthis:\n  {Re x |x. x \\<in> spectrum Z_I} \\<subseteq> {- 1, 1}\n\ngoal (1 subgoal):\n 1. {Re x |x. x \\<in> spectrum Z_I} \\<noteq> {}", "show \"{Re x |x. x \\<in> spectrum Z_I} \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Re x |x. x \\<in> spectrum Z_I} \\<noteq> {}", "using spectrum_ne Z_I_hermitian \\<open>Z_I \\<in> fc_mats\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> fc_mats; hermitian ?A\\<rbrakk>\n  \\<Longrightarrow> spectrum ?A \\<noteq> {}\n  hermitian Z_I\n  Z_I \\<in> fc_mats\n\ngoal (1 subgoal):\n 1. {Re x |x. x \\<in> spectrum Z_I} \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  {Re x |x. x \\<in> spectrum Z_I} \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  AE w in M. \\<bar>qt_expect Z_I Vz w\\<bar> \\<le> 1\n\ngoal (7 subgoals):\n 1. prob_space M\n 2. AE w in M. \\<bar>qt_expect I_ZmX Vm w\\<bar> \\<le> 1\n 3. AE w in M. \\<bar>qt_expect I_XpZ Vp w\\<bar> \\<le> 1\n 4. integrable M (\\<lambda>w. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w)\n 5. integrable M (\\<lambda>w. qt_expect X_I Vx w * qt_expect I_XpZ Vp w)\n 6. integrable M (\\<lambda>w. qt_expect X_I Vx w * qt_expect I_ZmX Vm w)\n 7. integrable M (\\<lambda>w. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w)", "show \"AE w in M. \\<bar>qt_expect I_XpZ Vp w\\<bar> \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE w in M. \\<bar>qt_expect I_XpZ Vp w\\<bar> \\<le> 1", "unfolding qt_expect_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. AE w in M. \\<bar>\\<Sum>a\\<in>spectrum I_XpZ. Re a * Vp a w\\<bar> \\<le> 1", "proof (rule spectrum_abs_1_weighted_sumr)"], ["proof (state)\ngoal (5 subgoals):\n 1. lhv M ?B I_XpZ ?R ?Vb Vp\n 2. {Re x |x. x \\<in> spectrum I_XpZ} \\<noteq> {}\n 3. {Re x |x. x \\<in> spectrum I_XpZ} \\<subseteq> {- 1, 1}\n 4. hermitian I_XpZ\n 5. I_XpZ \\<in> fc_mats", "show \"I_XpZ \\<in> fc_mats\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I_XpZ \\<in> fc_mats", "using I_XpZ_carrier fc_mats_carrier dim_eq dim4"], ["proof (prove)\nusing this:\n  I_XpZ \\<in> carrier_mat 4 4\n  fc_mats = carrier_mat dimR dimC\n  dimR = dimC\n  dimR = 4\n\ngoal (1 subgoal):\n 1. I_XpZ \\<in> fc_mats", "by simp"], ["proof (state)\nthis:\n  I_XpZ \\<in> fc_mats\n\ngoal (4 subgoals):\n 1. lhv M ?B I_XpZ ?R ?Vb Vp\n 2. {Re x |x. x \\<in> spectrum I_XpZ} \\<noteq> {}\n 3. {Re x |x. x \\<in> spectrum I_XpZ} \\<subseteq> {- 1, 1}\n 4. hermitian I_XpZ", "show \"hermitian I_XpZ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian I_XpZ", "using I_XpZ_hermitian"], ["proof (prove)\nusing this:\n  hermitian I_XpZ\n\ngoal (1 subgoal):\n 1. hermitian I_XpZ", "."], ["proof (state)\nthis:\n  hermitian I_XpZ\n\ngoal (3 subgoals):\n 1. lhv M ?B I_XpZ ?R ?Vb Vp\n 2. {Re x |x. x \\<in> spectrum I_XpZ} \\<noteq> {}\n 3. {Re x |x. x \\<in> spectrum I_XpZ} \\<subseteq> {- 1, 1}", "show \"lhv M Z_I I_XpZ rho_psim Vz Vp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lhv M Z_I I_XpZ rho_psim Vz Vp", "using assms"], ["proof (prove)\nusing this:\n  prob_space M\n  lhv M X_I I_XpZ rho_psim Vx Vp\n  lhv M Z_I I_XpZ rho_psim Vz Vp\n  lhv M X_I I_ZmX rho_psim Vx Vm\n  lhv M Z_I I_ZmX rho_psim Vz Vm\n\ngoal (1 subgoal):\n 1. lhv M Z_I I_XpZ rho_psim Vz Vp", "by simp"], ["proof (state)\nthis:\n  lhv M Z_I I_XpZ rho_psim Vz Vp\n\ngoal (2 subgoals):\n 1. {Re x |x. x \\<in> spectrum I_XpZ} \\<noteq> {}\n 2. {Re x |x. x \\<in> spectrum I_XpZ} \\<subseteq> {- 1, 1}", "show \"{Re x |x. x \\<in> spectrum I_XpZ} \\<subseteq> {- 1, 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Re x |x. x \\<in> spectrum I_XpZ} \\<subseteq> {- 1, 1}", "using I_XpZ_spectrum"], ["proof (prove)\nusing this:\n  {Re x |x. x \\<in> spectrum I_XpZ} \\<subseteq> {- 1, 1}\n\ngoal (1 subgoal):\n 1. {Re x |x. x \\<in> spectrum I_XpZ} \\<subseteq> {- 1, 1}", "by simp"], ["proof (state)\nthis:\n  {Re x |x. x \\<in> spectrum I_XpZ} \\<subseteq> {- 1, 1}\n\ngoal (1 subgoal):\n 1. {Re x |x. x \\<in> spectrum I_XpZ} \\<noteq> {}", "show \"{Re x |x. x \\<in> spectrum I_XpZ} \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Re x |x. x \\<in> spectrum I_XpZ} \\<noteq> {}", "using spectrum_ne I_XpZ_hermitian \\<open>I_XpZ \\<in> fc_mats\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> fc_mats; hermitian ?A\\<rbrakk>\n  \\<Longrightarrow> spectrum ?A \\<noteq> {}\n  hermitian I_XpZ\n  I_XpZ \\<in> fc_mats\n\ngoal (1 subgoal):\n 1. {Re x |x. x \\<in> spectrum I_XpZ} \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  {Re x |x. x \\<in> spectrum I_XpZ} \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  AE w in M. \\<bar>qt_expect I_XpZ Vp w\\<bar> \\<le> 1\n\ngoal (6 subgoals):\n 1. prob_space M\n 2. AE w in M. \\<bar>qt_expect I_ZmX Vm w\\<bar> \\<le> 1\n 3. integrable M (\\<lambda>w. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w)\n 4. integrable M (\\<lambda>w. qt_expect X_I Vx w * qt_expect I_XpZ Vp w)\n 5. integrable M (\\<lambda>w. qt_expect X_I Vx w * qt_expect I_ZmX Vm w)\n 6. integrable M (\\<lambda>w. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w)", "show \"AE w in M. \\<bar>qt_expect I_ZmX Vm w\\<bar> \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE w in M. \\<bar>qt_expect I_ZmX Vm w\\<bar> \\<le> 1", "unfolding qt_expect_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. AE w in M. \\<bar>\\<Sum>a\\<in>spectrum I_ZmX. Re a * Vm a w\\<bar> \\<le> 1", "proof (rule spectrum_abs_1_weighted_sumr)"], ["proof (state)\ngoal (5 subgoals):\n 1. lhv M ?B I_ZmX ?R ?Vb Vm\n 2. {Re x |x. x \\<in> spectrum I_ZmX} \\<noteq> {}\n 3. {Re x |x. x \\<in> spectrum I_ZmX} \\<subseteq> {- 1, 1}\n 4. hermitian I_ZmX\n 5. I_ZmX \\<in> fc_mats", "show \"I_ZmX \\<in> fc_mats\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I_ZmX \\<in> fc_mats", "using I_ZmX_carrier fc_mats_carrier dim_eq dim4"], ["proof (prove)\nusing this:\n  I_ZmX \\<in> carrier_mat 4 4\n  fc_mats = carrier_mat dimR dimC\n  dimR = dimC\n  dimR = 4\n\ngoal (1 subgoal):\n 1. I_ZmX \\<in> fc_mats", "by simp"], ["proof (state)\nthis:\n  I_ZmX \\<in> fc_mats\n\ngoal (4 subgoals):\n 1. lhv M ?B I_ZmX ?R ?Vb Vm\n 2. {Re x |x. x \\<in> spectrum I_ZmX} \\<noteq> {}\n 3. {Re x |x. x \\<in> spectrum I_ZmX} \\<subseteq> {- 1, 1}\n 4. hermitian I_ZmX", "show \"hermitian I_ZmX\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hermitian I_ZmX", "using I_ZmX_hermitian"], ["proof (prove)\nusing this:\n  hermitian I_ZmX\n\ngoal (1 subgoal):\n 1. hermitian I_ZmX", "."], ["proof (state)\nthis:\n  hermitian I_ZmX\n\ngoal (3 subgoals):\n 1. lhv M ?B I_ZmX ?R ?Vb Vm\n 2. {Re x |x. x \\<in> spectrum I_ZmX} \\<noteq> {}\n 3. {Re x |x. x \\<in> spectrum I_ZmX} \\<subseteq> {- 1, 1}", "show \"lhv M Z_I I_ZmX rho_psim Vz Vm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lhv M Z_I I_ZmX rho_psim Vz Vm", "using assms"], ["proof (prove)\nusing this:\n  prob_space M\n  lhv M X_I I_XpZ rho_psim Vx Vp\n  lhv M Z_I I_XpZ rho_psim Vz Vp\n  lhv M X_I I_ZmX rho_psim Vx Vm\n  lhv M Z_I I_ZmX rho_psim Vz Vm\n\ngoal (1 subgoal):\n 1. lhv M Z_I I_ZmX rho_psim Vz Vm", "by simp"], ["proof (state)\nthis:\n  lhv M Z_I I_ZmX rho_psim Vz Vm\n\ngoal (2 subgoals):\n 1. {Re x |x. x \\<in> spectrum I_ZmX} \\<noteq> {}\n 2. {Re x |x. x \\<in> spectrum I_ZmX} \\<subseteq> {- 1, 1}", "show \"{Re x |x. x \\<in> spectrum I_ZmX} \\<subseteq> {- 1, 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Re x |x. x \\<in> spectrum I_ZmX} \\<subseteq> {- 1, 1}", "using I_ZmX_spectrum"], ["proof (prove)\nusing this:\n  {Re x |x. x \\<in> spectrum I_ZmX} \\<subseteq> {- 1, 1}\n\ngoal (1 subgoal):\n 1. {Re x |x. x \\<in> spectrum I_ZmX} \\<subseteq> {- 1, 1}", "by simp"], ["proof (state)\nthis:\n  {Re x |x. x \\<in> spectrum I_ZmX} \\<subseteq> {- 1, 1}\n\ngoal (1 subgoal):\n 1. {Re x |x. x \\<in> spectrum I_ZmX} \\<noteq> {}", "show \"{Re x |x. x \\<in> spectrum I_ZmX} \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Re x |x. x \\<in> spectrum I_ZmX} \\<noteq> {}", "using spectrum_ne I_ZmX_hermitian \\<open>I_ZmX \\<in> fc_mats\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> fc_mats; hermitian ?A\\<rbrakk>\n  \\<Longrightarrow> spectrum ?A \\<noteq> {}\n  hermitian I_ZmX\n  I_ZmX \\<in> fc_mats\n\ngoal (1 subgoal):\n 1. {Re x |x. x \\<in> spectrum I_ZmX} \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  {Re x |x. x \\<in> spectrum I_ZmX} \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  AE w in M. \\<bar>qt_expect I_ZmX Vm w\\<bar> \\<le> 1\n\ngoal (5 subgoals):\n 1. prob_space M\n 2. integrable M (\\<lambda>w. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w)\n 3. integrable M (\\<lambda>w. qt_expect X_I Vx w * qt_expect I_XpZ Vp w)\n 4. integrable M (\\<lambda>w. qt_expect X_I Vx w * qt_expect I_ZmX Vm w)\n 5. integrable M (\\<lambda>w. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w)", "show \"prob_space M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prob_space M", "using assms"], ["proof (prove)\nusing this:\n  prob_space M\n  lhv M X_I I_XpZ rho_psim Vx Vp\n  lhv M Z_I I_XpZ rho_psim Vz Vp\n  lhv M X_I I_ZmX rho_psim Vx Vm\n  lhv M Z_I I_ZmX rho_psim Vz Vm\n\ngoal (1 subgoal):\n 1. prob_space M", "by simp"], ["proof (state)\nthis:\n  prob_space M\n\ngoal (4 subgoals):\n 1. integrable M (\\<lambda>w. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w)\n 2. integrable M (\\<lambda>w. qt_expect X_I Vx w * qt_expect I_XpZ Vp w)\n 3. integrable M (\\<lambda>w. qt_expect X_I Vx w * qt_expect I_ZmX Vm w)\n 4. integrable M (\\<lambda>w. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w)", "show \"integrable M (\\<lambda>w. qt_expect X_I Vx w * qt_expect I_ZmX Vm w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integrable M (\\<lambda>w. qt_expect X_I Vx w * qt_expect I_ZmX Vm w)", "using spectr_sum_integrable[of M] assms"], ["proof (prove)\nusing this:\n  lhv M ?A ?B ?R ?Va ?Vb \\<Longrightarrow>\n  integrable M (\\<lambda>w. qt_expect ?A ?Va w * qt_expect ?B ?Vb w)\n  prob_space M\n  lhv M X_I I_XpZ rho_psim Vx Vp\n  lhv M Z_I I_XpZ rho_psim Vz Vp\n  lhv M X_I I_ZmX rho_psim Vx Vm\n  lhv M Z_I I_ZmX rho_psim Vz Vm\n\ngoal (1 subgoal):\n 1. integrable M (\\<lambda>w. qt_expect X_I Vx w * qt_expect I_ZmX Vm w)", "by simp"], ["proof (state)\nthis:\n  integrable M (\\<lambda>w. qt_expect X_I Vx w * qt_expect I_ZmX Vm w)\n\ngoal (3 subgoals):\n 1. integrable M (\\<lambda>w. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w)\n 2. integrable M (\\<lambda>w. qt_expect X_I Vx w * qt_expect I_XpZ Vp w)\n 3. integrable M (\\<lambda>w. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w)", "show \"integrable M (\\<lambda>w. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integrable M (\\<lambda>w. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w)", "using spectr_sum_integrable[of M] assms"], ["proof (prove)\nusing this:\n  lhv M ?A ?B ?R ?Va ?Vb \\<Longrightarrow>\n  integrable M (\\<lambda>w. qt_expect ?A ?Va w * qt_expect ?B ?Vb w)\n  prob_space M\n  lhv M X_I I_XpZ rho_psim Vx Vp\n  lhv M Z_I I_XpZ rho_psim Vz Vp\n  lhv M X_I I_ZmX rho_psim Vx Vm\n  lhv M Z_I I_ZmX rho_psim Vz Vm\n\ngoal (1 subgoal):\n 1. integrable M (\\<lambda>w. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w)", "by simp"], ["proof (state)\nthis:\n  integrable M (\\<lambda>w. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w)\n\ngoal (2 subgoals):\n 1. integrable M (\\<lambda>w. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w)\n 2. integrable M (\\<lambda>w. qt_expect X_I Vx w * qt_expect I_XpZ Vp w)", "show \"integrable M (\\<lambda>w. qt_expect X_I Vx w * qt_expect I_XpZ Vp w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integrable M (\\<lambda>w. qt_expect X_I Vx w * qt_expect I_XpZ Vp w)", "using spectr_sum_integrable[of M] assms"], ["proof (prove)\nusing this:\n  lhv M ?A ?B ?R ?Va ?Vb \\<Longrightarrow>\n  integrable M (\\<lambda>w. qt_expect ?A ?Va w * qt_expect ?B ?Vb w)\n  prob_space M\n  lhv M X_I I_XpZ rho_psim Vx Vp\n  lhv M Z_I I_XpZ rho_psim Vz Vp\n  lhv M X_I I_ZmX rho_psim Vx Vm\n  lhv M Z_I I_ZmX rho_psim Vz Vm\n\ngoal (1 subgoal):\n 1. integrable M (\\<lambda>w. qt_expect X_I Vx w * qt_expect I_XpZ Vp w)", "by simp"], ["proof (state)\nthis:\n  integrable M (\\<lambda>w. qt_expect X_I Vx w * qt_expect I_XpZ Vp w)\n\ngoal (1 subgoal):\n 1. integrable M (\\<lambda>w. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w)", "show \"integrable M (\\<lambda>w. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integrable M (\\<lambda>w. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w)", "using spectr_sum_integrable[of M] assms"], ["proof (prove)\nusing this:\n  lhv M ?A ?B ?R ?Va ?Vb \\<Longrightarrow>\n  integrable M (\\<lambda>w. qt_expect ?A ?Va w * qt_expect ?B ?Vb w)\n  prob_space M\n  lhv M X_I I_XpZ rho_psim Vx Vp\n  lhv M Z_I I_XpZ rho_psim Vz Vp\n  lhv M X_I I_ZmX rho_psim Vx Vm\n  lhv M Z_I I_ZmX rho_psim Vz Vm\n\ngoal (1 subgoal):\n 1. integrable M (\\<lambda>w. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w)", "by simp"], ["proof (state)\nthis:\n  integrable M (\\<lambda>w. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in bin_cpx) quantum_value:\n  assumes \"lhv M X_I I_XpZ rho_psim Vx Vp\"\n  and \"lhv M Z_I I_XpZ rho_psim Vz Vp\"\n  and \"lhv M X_I I_ZmX rho_psim Vx Vm\"\n  and \"lhv M Z_I I_ZmX rho_psim Vz Vm\"\nshows \"\\<bar>(LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w) + \n        (LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w) + \n        (LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w) -\n        (LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w)\\<bar>\n  = 2* sqrt 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>(LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w) +\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w) +\n          (LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w) -\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w)\\<bar> =\n    2 * sqrt 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>(LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w) +\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w) +\n          (LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w) -\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w)\\<bar> =\n    2 * sqrt 2", "have \"LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w = 1/sqrt 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w = 1 / sqrt 2", "using X_I_ZmX_chsh[of M] assms"], ["proof (prove)\nusing this:\n  lhv M X_I I_ZmX rho_psim ?Vx ?Vp \\<Longrightarrow>\n  LINT w|M. qt_expect X_I ?Vx w * qt_expect I_ZmX ?Vp w = 1 / sqrt 2\n  lhv M X_I I_XpZ rho_psim Vx Vp\n  lhv M Z_I I_XpZ rho_psim Vz Vp\n  lhv M X_I I_ZmX rho_psim Vx Vm\n  lhv M Z_I I_ZmX rho_psim Vz Vm\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w = 1 / sqrt 2", "unfolding qt_expect_def"], ["proof (prove)\nusing this:\n  lhv M X_I I_ZmX rho_psim ?Vx ?Vp \\<Longrightarrow>\n  LINT w|M.\n     (\\<Sum>a\\<in>spectrum X_I. Re a * ?Vx a w) *\n     (\\<Sum>a\\<in>spectrum I_ZmX. Re a * ?Vp a w) =\n  1 / sqrt 2\n  lhv M X_I I_XpZ rho_psim Vx Vp\n  lhv M Z_I I_XpZ rho_psim Vz Vp\n  lhv M X_I I_ZmX rho_psim Vx Vm\n  lhv M Z_I I_ZmX rho_psim Vz Vm\n\ngoal (1 subgoal):\n 1. LINT w|M.\n       (\\<Sum>a\\<in>spectrum X_I. Re a * Vx a w) *\n       (\\<Sum>a\\<in>spectrum I_ZmX. Re a * Vm a w) =\n    1 / sqrt 2", "by simp"], ["proof (state)\nthis:\n  LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w = 1 / sqrt 2\n\ngoal (1 subgoal):\n 1. \\<bar>(LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w) +\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w) +\n          (LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w) -\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w)\\<bar> =\n    2 * sqrt 2", "moreover"], ["proof (state)\nthis:\n  LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w = 1 / sqrt 2\n\ngoal (1 subgoal):\n 1. \\<bar>(LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w) +\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w) +\n          (LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w) -\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w)\\<bar> =\n    2 * sqrt 2", "have b: \"LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w = 1/sqrt 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w = 1 / sqrt 2", "using X_I_XpZ_chsh[of M] assms"], ["proof (prove)\nusing this:\n  lhv M X_I I_XpZ rho_psim ?Vx ?Vp \\<Longrightarrow>\n  LINT w|M. qt_expect X_I ?Vx w * qt_expect I_XpZ ?Vp w = 1 / sqrt 2\n  lhv M X_I I_XpZ rho_psim Vx Vp\n  lhv M Z_I I_XpZ rho_psim Vz Vp\n  lhv M X_I I_ZmX rho_psim Vx Vm\n  lhv M Z_I I_ZmX rho_psim Vz Vm\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w = 1 / sqrt 2", "unfolding qt_expect_def"], ["proof (prove)\nusing this:\n  lhv M X_I I_XpZ rho_psim ?Vx ?Vp \\<Longrightarrow>\n  LINT w|M.\n     (\\<Sum>a\\<in>spectrum X_I. Re a * ?Vx a w) *\n     (\\<Sum>a\\<in>spectrum I_XpZ. Re a * ?Vp a w) =\n  1 / sqrt 2\n  lhv M X_I I_XpZ rho_psim Vx Vp\n  lhv M Z_I I_XpZ rho_psim Vz Vp\n  lhv M X_I I_ZmX rho_psim Vx Vm\n  lhv M Z_I I_ZmX rho_psim Vz Vm\n\ngoal (1 subgoal):\n 1. LINT w|M.\n       (\\<Sum>a\\<in>spectrum X_I. Re a * Vx a w) *\n       (\\<Sum>a\\<in>spectrum I_XpZ. Re a * Vp a w) =\n    1 / sqrt 2", "by simp"], ["proof (state)\nthis:\n  LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w = 1 / sqrt 2\n\ngoal (1 subgoal):\n 1. \\<bar>(LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w) +\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w) +\n          (LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w) -\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w)\\<bar> =\n    2 * sqrt 2", "moreover"], ["proof (state)\nthis:\n  LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w = 1 / sqrt 2\n\ngoal (1 subgoal):\n 1. \\<bar>(LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w) +\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w) +\n          (LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w) -\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w)\\<bar> =\n    2 * sqrt 2", "have c: \"LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w = 1/sqrt 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w = 1 / sqrt 2", "using Z_I_XpZ_chsh[of M] assms"], ["proof (prove)\nusing this:\n  lhv M Z_I I_XpZ rho_psim ?Vz ?Vp \\<Longrightarrow>\n  LINT w|M. qt_expect Z_I ?Vz w * qt_expect I_XpZ ?Vp w = 1 / sqrt 2\n  lhv M X_I I_XpZ rho_psim Vx Vp\n  lhv M Z_I I_XpZ rho_psim Vz Vp\n  lhv M X_I I_ZmX rho_psim Vx Vm\n  lhv M Z_I I_ZmX rho_psim Vz Vm\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w = 1 / sqrt 2", "unfolding qt_expect_def"], ["proof (prove)\nusing this:\n  lhv M Z_I I_XpZ rho_psim ?Vz ?Vp \\<Longrightarrow>\n  LINT w|M.\n     (\\<Sum>a\\<in>spectrum Z_I. Re a * ?Vz a w) *\n     (\\<Sum>a\\<in>spectrum I_XpZ. Re a * ?Vp a w) =\n  1 / sqrt 2\n  lhv M X_I I_XpZ rho_psim Vx Vp\n  lhv M Z_I I_XpZ rho_psim Vz Vp\n  lhv M X_I I_ZmX rho_psim Vx Vm\n  lhv M Z_I I_ZmX rho_psim Vz Vm\n\ngoal (1 subgoal):\n 1. LINT w|M.\n       (\\<Sum>a\\<in>spectrum Z_I. Re a * Vz a w) *\n       (\\<Sum>a\\<in>spectrum I_XpZ. Re a * Vp a w) =\n    1 / sqrt 2", "by simp"], ["proof (state)\nthis:\n  LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w = 1 / sqrt 2\n\ngoal (1 subgoal):\n 1. \\<bar>(LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w) +\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w) +\n          (LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w) -\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w)\\<bar> =\n    2 * sqrt 2", "moreover"], ["proof (state)\nthis:\n  LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w = 1 / sqrt 2\n\ngoal (1 subgoal):\n 1. \\<bar>(LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w) +\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w) +\n          (LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w) -\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w)\\<bar> =\n    2 * sqrt 2", "have \"LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w = -1/sqrt 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w = - 1 / sqrt 2", "using Z_I_ZmX_chsh[of M] assms"], ["proof (prove)\nusing this:\n  lhv M Z_I I_ZmX rho_psim ?Vz ?Vp \\<Longrightarrow>\n  LINT w|M. qt_expect Z_I ?Vz w * qt_expect I_ZmX ?Vp w = - 1 / sqrt 2\n  lhv M X_I I_XpZ rho_psim Vx Vp\n  lhv M Z_I I_XpZ rho_psim Vz Vp\n  lhv M X_I I_ZmX rho_psim Vx Vm\n  lhv M Z_I I_ZmX rho_psim Vz Vm\n\ngoal (1 subgoal):\n 1. LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w = - 1 / sqrt 2", "unfolding qt_expect_def"], ["proof (prove)\nusing this:\n  lhv M Z_I I_ZmX rho_psim ?Vz ?Vp \\<Longrightarrow>\n  LINT w|M.\n     (\\<Sum>a\\<in>spectrum Z_I. Re a * ?Vz a w) *\n     (\\<Sum>a\\<in>spectrum I_ZmX. Re a * ?Vp a w) =\n  - 1 / sqrt 2\n  lhv M X_I I_XpZ rho_psim Vx Vp\n  lhv M Z_I I_XpZ rho_psim Vz Vp\n  lhv M X_I I_ZmX rho_psim Vx Vm\n  lhv M Z_I I_ZmX rho_psim Vz Vm\n\ngoal (1 subgoal):\n 1. LINT w|M.\n       (\\<Sum>a\\<in>spectrum Z_I. Re a * Vz a w) *\n       (\\<Sum>a\\<in>spectrum I_ZmX. Re a * Vm a w) =\n    - 1 / sqrt 2", "by simp"], ["proof (state)\nthis:\n  LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w = - 1 / sqrt 2\n\ngoal (1 subgoal):\n 1. \\<bar>(LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w) +\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w) +\n          (LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w) -\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w)\\<bar> =\n    2 * sqrt 2", "ultimately"], ["proof (chain)\npicking this:\n  LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w = 1 / sqrt 2\n  LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w = 1 / sqrt 2\n  LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w = 1 / sqrt 2\n  LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w = - 1 / sqrt 2", "have \"(LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w) + \n        (LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w) + \n        (LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w) -\n        (LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w) = 4/(sqrt 2)\""], ["proof (prove)\nusing this:\n  LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w = 1 / sqrt 2\n  LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w = 1 / sqrt 2\n  LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w = 1 / sqrt 2\n  LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w = - 1 / sqrt 2\n\ngoal (1 subgoal):\n 1. (LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w) +\n    (LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w) +\n    (LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w) -\n    (LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w) =\n    4 / sqrt 2", "by simp"], ["proof (state)\nthis:\n  (LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w) +\n  (LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w) +\n  (LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w) -\n  (LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w) =\n  4 / sqrt 2\n\ngoal (1 subgoal):\n 1. \\<bar>(LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w) +\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w) +\n          (LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w) -\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w)\\<bar> =\n    2 * sqrt 2", "also"], ["proof (state)\nthis:\n  (LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w) +\n  (LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w) +\n  (LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w) -\n  (LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w) =\n  4 / sqrt 2\n\ngoal (1 subgoal):\n 1. \\<bar>(LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w) +\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w) +\n          (LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w) -\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w)\\<bar> =\n    2 * sqrt 2", "have \"... = (4 * (sqrt 2))/(sqrt 2 * (sqrt 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 / sqrt 2 = 4 * sqrt 2 / (sqrt 2 * sqrt 2)", "by (metis mult_numeral_1_right real_divide_square_eq times_divide_eq_right)"], ["proof (state)\nthis:\n  4 / sqrt 2 = 4 * sqrt 2 / (sqrt 2 * sqrt 2)\n\ngoal (1 subgoal):\n 1. \\<bar>(LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w) +\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w) +\n          (LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w) -\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w)\\<bar> =\n    2 * sqrt 2", "also"], ["proof (state)\nthis:\n  4 / sqrt 2 = 4 * sqrt 2 / (sqrt 2 * sqrt 2)\n\ngoal (1 subgoal):\n 1. \\<bar>(LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w) +\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w) +\n          (LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w) -\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w)\\<bar> =\n    2 * sqrt 2", "have \"... = (4 * (sqrt 2)) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * sqrt 2 / (sqrt 2 * sqrt 2) = 4 * sqrt 2 / 2", "by simp"], ["proof (state)\nthis:\n  4 * sqrt 2 / (sqrt 2 * sqrt 2) = 4 * sqrt 2 / 2\n\ngoal (1 subgoal):\n 1. \\<bar>(LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w) +\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w) +\n          (LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w) -\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w)\\<bar> =\n    2 * sqrt 2", "also"], ["proof (state)\nthis:\n  4 * sqrt 2 / (sqrt 2 * sqrt 2) = 4 * sqrt 2 / 2\n\ngoal (1 subgoal):\n 1. \\<bar>(LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w) +\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w) +\n          (LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w) -\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w)\\<bar> =\n    2 * sqrt 2", "have \"... = 2 * (sqrt 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * sqrt 2 / 2 = 2 * sqrt 2", "by simp"], ["proof (state)\nthis:\n  4 * sqrt 2 / 2 = 2 * sqrt 2\n\ngoal (1 subgoal):\n 1. \\<bar>(LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w) +\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w) +\n          (LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w) -\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w)\\<bar> =\n    2 * sqrt 2", "finally"], ["proof (chain)\npicking this:\n  (LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w) +\n  (LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w) +\n  (LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w) -\n  (LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w) =\n  2 * sqrt 2", "have \"(LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w) + \n        (LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w) + \n        (LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w) -\n        (LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w) = 2 * sqrt 2\""], ["proof (prove)\nusing this:\n  (LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w) +\n  (LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w) +\n  (LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w) -\n  (LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w) =\n  2 * sqrt 2\n\ngoal (1 subgoal):\n 1. (LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w) +\n    (LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w) +\n    (LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w) -\n    (LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w) =\n    2 * sqrt 2", "."], ["proof (state)\nthis:\n  (LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w) +\n  (LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w) +\n  (LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w) -\n  (LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w) =\n  2 * sqrt 2\n\ngoal (1 subgoal):\n 1. \\<bar>(LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w) +\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w) +\n          (LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w) -\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w)\\<bar> =\n    2 * sqrt 2", "thus ?thesis"], ["proof (prove)\nusing this:\n  (LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w) +\n  (LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w) +\n  (LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w) -\n  (LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w) =\n  2 * sqrt 2\n\ngoal (1 subgoal):\n 1. \\<bar>(LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w) +\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w) +\n          (LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w) -\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w)\\<bar> =\n    2 * sqrt 2", "by (simp add: b c)"], ["proof (state)\nthis:\n  \\<bar>(LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w) +\n        (LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w) +\n        (LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w) -\n        (LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w)\\<bar> =\n  2 * sqrt 2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in bin_cpx) no_lhv:\n  assumes \"lhv M X_I I_XpZ rho_psim Vx Vp\"\n  and \"lhv M Z_I I_XpZ rho_psim Vz Vp\"\n  and \"lhv M X_I I_ZmX rho_psim Vx Vm\"\n  and \"lhv M Z_I I_ZmX rho_psim Vz Vm\"\nshows False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"prob_space M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prob_space M", "using assms"], ["proof (prove)\nusing this:\n  lhv M X_I I_XpZ rho_psim Vx Vp\n  lhv M Z_I I_XpZ rho_psim Vz Vp\n  lhv M X_I I_ZmX rho_psim Vx Vm\n  lhv M Z_I I_ZmX rho_psim Vz Vm\n\ngoal (1 subgoal):\n 1. prob_space M", "unfolding lhv_def"], ["proof (prove)\nusing this:\n  prob_space M \\<and>\n  (\\<forall>a\\<in>spectrum X_I. pos_rv M (Vx a)) \\<and>\n  prv_sum M X_I Vx \\<and>\n  (\\<forall>b\\<in>spectrum I_XpZ. pos_rv M (Vp b)) \\<and>\n  prv_sum M I_XpZ Vp \\<and>\n  (\\<forall>a\\<in>spectrum X_I.\n      \\<forall>b\\<in>spectrum I_XpZ.\n         integrable M (\\<lambda>w. Vx a w * Vp b w) \\<and>\n         LINT w|M. Vx a w * Vp b w =\n         Re (Complex_Matrix.trace\n              (eigen_projector X_I a * eigen_projector I_XpZ b * rho_psim)))\n  prob_space M \\<and>\n  (\\<forall>a\\<in>spectrum Z_I. pos_rv M (Vz a)) \\<and>\n  prv_sum M Z_I Vz \\<and>\n  (\\<forall>b\\<in>spectrum I_XpZ. pos_rv M (Vp b)) \\<and>\n  prv_sum M I_XpZ Vp \\<and>\n  (\\<forall>a\\<in>spectrum Z_I.\n      \\<forall>b\\<in>spectrum I_XpZ.\n         integrable M (\\<lambda>w. Vz a w * Vp b w) \\<and>\n         LINT w|M. Vz a w * Vp b w =\n         Re (Complex_Matrix.trace\n              (eigen_projector Z_I a * eigen_projector I_XpZ b * rho_psim)))\n  prob_space M \\<and>\n  (\\<forall>a\\<in>spectrum X_I. pos_rv M (Vx a)) \\<and>\n  prv_sum M X_I Vx \\<and>\n  (\\<forall>b\\<in>spectrum I_ZmX. pos_rv M (Vm b)) \\<and>\n  prv_sum M I_ZmX Vm \\<and>\n  (\\<forall>a\\<in>spectrum X_I.\n      \\<forall>b\\<in>spectrum I_ZmX.\n         integrable M (\\<lambda>w. Vx a w * Vm b w) \\<and>\n         LINT w|M. Vx a w * Vm b w =\n         Re (Complex_Matrix.trace\n              (eigen_projector X_I a * eigen_projector I_ZmX b * rho_psim)))\n  prob_space M \\<and>\n  (\\<forall>a\\<in>spectrum Z_I. pos_rv M (Vz a)) \\<and>\n  prv_sum M Z_I Vz \\<and>\n  (\\<forall>b\\<in>spectrum I_ZmX. pos_rv M (Vm b)) \\<and>\n  prv_sum M I_ZmX Vm \\<and>\n  (\\<forall>a\\<in>spectrum Z_I.\n      \\<forall>b\\<in>spectrum I_ZmX.\n         integrable M (\\<lambda>w. Vz a w * Vm b w) \\<and>\n         LINT w|M. Vz a w * Vm b w =\n         Re (Complex_Matrix.trace\n              (eigen_projector Z_I a * eigen_projector I_ZmX b * rho_psim)))\n\ngoal (1 subgoal):\n 1. prob_space M", "by simp"], ["proof (state)\nthis:\n  prob_space M\n\ngoal (1 subgoal):\n 1. False", "have \"2 * sqrt 2 = \\<bar>(LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w) + \n        (LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w) + \n        (LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w) -\n        (LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w)\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * sqrt 2 =\n    \\<bar>(LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w) +\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w) +\n          (LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w) -\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w)\\<bar>", "using assms quantum_value[of M]"], ["proof (prove)\nusing this:\n  lhv M X_I I_XpZ rho_psim Vx Vp\n  lhv M Z_I I_XpZ rho_psim Vz Vp\n  lhv M X_I I_ZmX rho_psim Vx Vm\n  lhv M Z_I I_ZmX rho_psim Vz Vm\n  \\<lbrakk>lhv M X_I I_XpZ rho_psim ?Vx ?Vp;\n   lhv M Z_I I_XpZ rho_psim ?Vz ?Vp; lhv M X_I I_ZmX rho_psim ?Vx ?Vm;\n   lhv M Z_I I_ZmX rho_psim ?Vz ?Vm\\<rbrakk>\n  \\<Longrightarrow> \\<bar>(LINT w|M.\n                              qt_expect X_I ?Vx w * qt_expect I_ZmX ?Vm w) +\n                          (LINT w|M.\n                              qt_expect Z_I ?Vz w * qt_expect I_XpZ ?Vp w) +\n                          (LINT w|M.\n                              qt_expect X_I ?Vx w * qt_expect I_XpZ ?Vp w) -\n                          (LINT w|M.\n                              qt_expect Z_I ?Vz w *\n                              qt_expect I_ZmX ?Vm w)\\<bar> =\n                    2 * sqrt 2\n\ngoal (1 subgoal):\n 1. 2 * sqrt 2 =\n    \\<bar>(LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w) +\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w) +\n          (LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w) -\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w)\\<bar>", "by simp"], ["proof (state)\nthis:\n  2 * sqrt 2 =\n  \\<bar>(LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w) +\n        (LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w) +\n        (LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w) -\n        (LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w)\\<bar>\n\ngoal (1 subgoal):\n 1. False", "also"], ["proof (state)\nthis:\n  2 * sqrt 2 =\n  \\<bar>(LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w) +\n        (LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w) +\n        (LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w) -\n        (LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w)\\<bar>\n\ngoal (1 subgoal):\n 1. False", "have \"... \\<le> 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>(LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w) +\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w) +\n          (LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w) -\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w)\\<bar>\n    \\<le> 2", "using chsh_upper_bound[of M] assms \\<open>prob_space M\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>prob_space M; lhv M X_I I_XpZ rho_psim ?Vx ?Vp;\n   lhv M Z_I I_XpZ rho_psim ?Vz ?Vp; lhv M X_I I_ZmX rho_psim ?Vx ?Vm;\n   lhv M Z_I I_ZmX rho_psim ?Vz ?Vm\\<rbrakk>\n  \\<Longrightarrow> \\<bar>(LINT w|M.\n                              qt_expect X_I ?Vx w * qt_expect I_ZmX ?Vm w) +\n                          (LINT w|M.\n                              qt_expect Z_I ?Vz w * qt_expect I_XpZ ?Vp w) +\n                          (LINT w|M.\n                              qt_expect X_I ?Vx w * qt_expect I_XpZ ?Vp w) -\n                          (LINT w|M.\n                              qt_expect Z_I ?Vz w *\n                              qt_expect I_ZmX ?Vm w)\\<bar>\n                    \\<le> 2\n  lhv M X_I I_XpZ rho_psim Vx Vp\n  lhv M Z_I I_XpZ rho_psim Vz Vp\n  lhv M X_I I_ZmX rho_psim Vx Vm\n  lhv M Z_I I_ZmX rho_psim Vz Vm\n  prob_space M\n\ngoal (1 subgoal):\n 1. \\<bar>(LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w) +\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w) +\n          (LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w) -\n          (LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w)\\<bar>\n    \\<le> 2", "by simp"], ["proof (state)\nthis:\n  \\<bar>(LINT w|M. qt_expect X_I Vx w * qt_expect I_ZmX Vm w) +\n        (LINT w|M. qt_expect Z_I Vz w * qt_expect I_XpZ Vp w) +\n        (LINT w|M. qt_expect X_I Vx w * qt_expect I_XpZ Vp w) -\n        (LINT w|M. qt_expect Z_I Vz w * qt_expect I_ZmX Vm w)\\<bar>\n  \\<le> 2\n\ngoal (1 subgoal):\n 1. False", "finally"], ["proof (chain)\npicking this:\n  2 * sqrt 2 \\<le> 2", "have \"2 * sqrt 2 \\<le> 2\""], ["proof (prove)\nusing this:\n  2 * sqrt 2 \\<le> 2\n\ngoal (1 subgoal):\n 1. 2 * sqrt 2 \\<le> 2", "."], ["proof (state)\nthis:\n  2 * sqrt 2 \\<le> 2\n\ngoal (1 subgoal):\n 1. False", "thus False"], ["proof (prove)\nusing this:\n  2 * sqrt 2 \\<le> 2\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}