{"file_name": "/home/qj213/afp-2021-10-22/thys/Finitely_Generated_Abelian_Groups/Finite_And_Cyclic_Groups.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Finitely_Generated_Abelian_Groups", "problem_names": ["lemma (in finite_group) ord_pos: \n  assumes \"x \\<in> carrier G\"\n  shows   \"ord x > 0\"", "lemma (in finite_group) order_gt_0 [simp,intro]: \"order G > 0\"", "lemma (in finite_group) finite_ord_conv_Least:\n  assumes \"x \\<in> carrier G\"\n  shows \"ord x = (LEAST n::nat. 0 < n \\<and> x [^] n = \\<one>)\"", "lemma (in finite_group) non_trivial_group_ord_gr_1:\n  assumes \"carrier G \\<noteq> {\\<one>}\"\n  shows \"\\<exists>e \\<in> carrier G. ord e > 1\"", "lemma (in finite_group) max_order_elem:\n  obtains a where \"a \\<in> carrier G\" \"\\<forall>x \\<in> carrier G. ord x \\<le> ord a\"", "lemma (in finite_group) iso_imp_finite:\n  assumes \"G \\<cong> H\" \"group H\"\n  shows \"finite_group H\"", "lemma (in finite_group) finite_FactGroup:\n  assumes \"H \\<lhd> G\"\n  shows \"finite_group (G Mod H)\"", "lemma (in finite_group) bigger_subgroup_is_group:\n  assumes \"subgroup H G\" \"card H \\<ge> order G\"\n  shows \"H = carrier G\"", "lemma (in finite_group) finite_generate:\n  assumes \"A \\<subseteq> carrier G\"\n  shows \"finite (generate G A)\"", "lemma (in finite_group) generate_induct[consumes 1, case_names base adjoin]:\n  assumes \"A0 \\<subseteq> carrier G\"\n  assumes \"A0 \\<subseteq> carrier G \\<Longrightarrow> P (G\\<lparr>carrier := generate G A0\\<rparr>)\"\n  assumes \"\\<And>a A. \\<lbrakk>A \\<subseteq> carrier G; a \\<in> carrier G - generate G A; A0 \\<subseteq> A;\n           P (G\\<lparr>carrier := generate G A\\<rparr>)\\<rbrakk> \\<Longrightarrow> P (G\\<lparr>carrier := generate G (A \\<union> {a})\\<rparr>)\"\n  shows \"P G\"", "lemma (in finite_comm_group) iso_imp_finite_comm:\n  assumes \"G \\<cong> H\" \"group H\"\n  shows \"finite_comm_group H\"", "lemma (in finite_comm_group) finite_comm_FactGroup:\n  assumes \"subgroup H G\"\n  shows \"finite_comm_group (G Mod H)\"", "lemma (in finite_comm_group) subgroup_imp_finite_comm_group:\n  assumes \"subgroup H G\"\n  shows   \"finite_comm_group (G\\<lparr>carrier := H\\<rparr>)\"", "lemma (in cyclic_group) elem_is_gen_pow:\n  assumes \"x \\<in> carrier G\"\n  shows \"\\<exists>n :: int. x = gen [^] n\"", "lemma (in group) cyclic_groupI0:\n  assumes \"a \\<in> carrier G\" \"carrier G = generate G {a}\"\n  shows \"cyclic_group G a\"", "lemma (in group) cyclic_groupI1:\n  assumes \"a \\<in> carrier G\" \"carrier G \\<subseteq> generate G {a}\"\n  shows \"cyclic_group G a\"", "lemma (in group) cyclic_groupI2:\n  assumes \"a \\<in> carrier G\"\n  shows \"cyclic_group (G\\<lparr>carrier := generate G {a}\\<rparr>) a\"", "lemma (in cyclic_group) ord_gen_is_group_order:\n  shows \"ord gen = order G\"", "lemma (in finite_group) element_ord_generates_cyclic:\n  assumes \"a \\<in> carrier G\" \"ord a = order G\"\n  shows \"cyclic_group G a\"", "lemma (in group) prime_order_group_is_cyc:\n  assumes \"Factorial_Ring.prime (order G)\"\n  obtains g where \"cyclic_group G g\"", "lemma (in cyclic_group) generator_induct [consumes 1, case_names generate inv]:\n  assumes x: \"x \\<in> carrier G\"\n  assumes IH1: \"\\<And>n::nat. P (gen [^] n)\"\n  assumes IH2: \"\\<And>x. x \\<in> carrier G \\<Longrightarrow> P x \\<Longrightarrow> P (inv x)\"\n  shows   \"P x\"", "lemma (in finite_cyclic_group) ord_gen_gt_zero:\n  \"ord gen > 0\"", "lemma (in finite_cyclic_group) generator_induct0 [consumes 1, case_names one step]:\n  assumes x: \"x \\<in> carrier G\"\n  assumes IH1: \"P \\<one>\"\n  assumes IH2: \"\\<And>x. \\<lbrakk>x \\<in> carrier G; P x\\<rbrakk> \\<Longrightarrow> P (x \\<otimes> gen)\"\n  shows   \"P x\"", "lemma (in finite_cyclic_group) generator_induct1 [consumes 1, case_names gen step]:\n  assumes x: \"x \\<in> carrier G\"\n  assumes IH1: \"P gen\"\n  assumes IH2: \"\\<And>x. \\<lbrakk>x \\<in> carrier G; P x\\<rbrakk> \\<Longrightarrow> P (x \\<otimes> gen)\"\n  shows   \"P x\"", "lemma (in group) get_exp_self_fulfills:\n  assumes \"a \\<in> carrier G\"\n  shows \"a = a [^] get_exp a a\"", "lemma (in group) get_exp_self:\n  assumes \"a \\<in> carrier G\"\n  shows \"get_exp a a mod ord a = (1::int) mod ord a\"", "lemma (in cyclic_group) get_exp_fulfills:\n  assumes \"a \\<in> carrier G\"\n  shows \"a = gen [^] get_exp gen a\"", "lemma (in cyclic_group) get_exp_non_zero:\n  assumes\"b \\<in> carrier G\" \"b \\<noteq> \\<one>\"\n  shows \"get_exp gen b \\<noteq> 0\"", "lemma (in cyclic_group) get_exp_mult_mod:\n  assumes \"a \\<in> carrier G\" \"b \\<in> carrier G\"\n  shows \"get_exp gen (a \\<otimes> b) mod (ord gen) = (get_exp gen a + get_exp gen b) mod (ord gen)\"", "lemma (in group) iso_cyclic_groups_generate:\n  assumes \"a \\<in> carrier G\" \"b \\<in> carrier H\" \"group.ord G a = group.ord H b\" \"group H\"\n  shows \"{f. \\<forall>k \\<in> (UNIV::int set). f (a [^] k) = b [^]\\<^bsub>H\\<^esub> k}\n         \\<subseteq> iso (G\\<lparr>carrier := generate G {a}\\<rparr>) (H\\<lparr>carrier := generate H {b}\\<rparr>)\"", "lemma (in cyclic_group) iso_cyclic_groups_same_order:\n  assumes \"cyclic_group H h\" \"order G = order H\"\n  shows \"G \\<cong> H\"", "lemma Zn_neq1_cyclic_group:\n  assumes \"n \\<noteq> 1\"\n  shows \"cyclic_group (Z n) 1\"", "lemma Z1_cyclic_group: \"cyclic_group (Z 1) 0\"", "lemma Zn_cyclic_group:\n  obtains x where \"cyclic_group (Z n) x\"", "lemma Zn_order: \"order (Z n) = n\"", "lemma (in cyclic_group) Zn_iso:\n  assumes \"order G = n\"\n  shows \"G \\<cong> Z n\""], "translations": [["", "lemma (in finite_group) ord_pos: \n  assumes \"x \\<in> carrier G\"\n  shows   \"ord x > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < ord x", "using ord_ge_1[of x] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (carrier G); x \\<in> carrier G\\<rbrakk>\n  \\<Longrightarrow> 1 \\<le> ord x\n  x \\<in> carrier G\n\ngoal (1 subgoal):\n 1. 0 < ord x", "by auto"], ["", "lemma (in finite_group) order_gt_0 [simp,intro]: \"order G > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < order G", "by (subst order_gt_0_iff_finite) auto"], ["", "lemma (in finite_group) finite_ord_conv_Least:\n  assumes \"x \\<in> carrier G\"\n  shows \"ord x = (LEAST n::nat. 0 < n \\<and> x [^] n = \\<one>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord x = (LEAST n. 0 < n \\<and> x [^] n = \\<one>)", "using pow_order_eq_1 order_gt_0_iff_finite ord_conv_Least assms"], ["proof (prove)\nusing this:\n  ?a \\<in> carrier G \\<Longrightarrow> ?a [^] order G = \\<one>\n  (0 < order G) = finite (carrier G)\n  \\<lbrakk>?x \\<in> carrier G; \\<exists>n>0. ?x [^] n = \\<one>\\<rbrakk>\n  \\<Longrightarrow> ord ?x = (LEAST n. 0 < n \\<and> ?x [^] n = \\<one>)\n  x \\<in> carrier G\n\ngoal (1 subgoal):\n 1. ord x = (LEAST n. 0 < n \\<and> x [^] n = \\<one>)", "by auto"], ["", "lemma (in finite_group) non_trivial_group_ord_gr_1:\n  assumes \"carrier G \\<noteq> {\\<one>}\"\n  shows \"\\<exists>e \\<in> carrier G. ord e > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>carrier G. 1 < ord e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>carrier G. 1 < ord e", "from one_closed"], ["proof (chain)\npicking this:\n  \\<one> \\<in> carrier G", "obtain e where e: \"e \\<noteq> \\<one>\" \"e \\<in> carrier G\""], ["proof (prove)\nusing this:\n  \\<one> \\<in> carrier G\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>e \\<noteq> \\<one>; e \\<in> carrier G\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms carrier_not_empty"], ["proof (prove)\nusing this:\n  \\<one> \\<in> carrier G\n  carrier G \\<noteq> {\\<one>}\n  carrier G \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>e \\<noteq> \\<one>; e \\<in> carrier G\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  e \\<noteq> \\<one>\n  e \\<in> carrier G\n\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>carrier G. 1 < ord e", "thus ?thesis"], ["proof (prove)\nusing this:\n  e \\<noteq> \\<one>\n  e \\<in> carrier G\n\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>carrier G. 1 < ord e", "using ord_eq_1[of e] le_neq_implies_less ord_ge_1"], ["proof (prove)\nusing this:\n  e \\<noteq> \\<one>\n  e \\<in> carrier G\n  e \\<in> carrier G \\<Longrightarrow> (ord e = 1) = (e = \\<one>)\n  \\<lbrakk>?m \\<le> ?n; ?m \\<noteq> ?n\\<rbrakk> \\<Longrightarrow> ?m < ?n\n  \\<lbrakk>finite (carrier G); ?a \\<in> carrier G\\<rbrakk>\n  \\<Longrightarrow> 1 \\<le> ord ?a\n\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>carrier G. 1 < ord e", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>e\\<in>carrier G. 1 < ord e\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Manuel Eberl *)"], ["", "lemma (in finite_group) max_order_elem:\n  obtains a where \"a \\<in> carrier G\" \"\\<forall>x \\<in> carrier G. ord x \\<le> ord a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> carrier G;\n         \\<forall>x\\<in>carrier G. ord x \\<le> ord a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> carrier G;\n         \\<forall>x\\<in>carrier G. ord x \\<le> ord a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<exists>x. x \\<in> carrier G \\<and> (\\<forall>y. y \\<in> carrier G \\<longrightarrow> ord y \\<le> ord x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> carrier G \\<and>\n       (\\<forall>y. y \\<in> carrier G \\<longrightarrow> ord y \\<le> ord x)", "proof (rule ex_has_greatest_nat[of _ \\<one> _ \"order G + 1\"], safe)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<one> \\<in> carrier G\n 2. \\<And>y. y \\<in> carrier G \\<Longrightarrow> ord y < order G + 1", "show \"\\<one> \\<in> carrier G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<one> \\<in> carrier G", "by auto"], ["proof (state)\nthis:\n  \\<one> \\<in> carrier G\n\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> carrier G \\<Longrightarrow> ord y < order G + 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> carrier G \\<Longrightarrow> ord y < order G + 1", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> carrier G \\<Longrightarrow> ord y < order G + 1", "assume \"x \\<in> carrier G\""], ["proof (state)\nthis:\n  x \\<in> carrier G\n\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> carrier G \\<Longrightarrow> ord y < order G + 1", "hence \"ord x \\<le> order G\""], ["proof (prove)\nusing this:\n  x \\<in> carrier G\n\ngoal (1 subgoal):\n 1. ord x \\<le> order G", "by (intro ord_le_group_order fin)"], ["proof (state)\nthis:\n  ord x \\<le> order G\n\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> carrier G \\<Longrightarrow> ord y < order G + 1", "also"], ["proof (state)\nthis:\n  ord x \\<le> order G\n\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> carrier G \\<Longrightarrow> ord y < order G + 1", "have \"\\<dots> < order G + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order G < order G + 1", "by simp"], ["proof (state)\nthis:\n  order G < order G + 1\n\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> carrier G \\<Longrightarrow> ord y < order G + 1", "finally"], ["proof (chain)\npicking this:\n  ord x < order G + 1", "show \"ord x < order G + 1\""], ["proof (prove)\nusing this:\n  ord x < order G + 1\n\ngoal (1 subgoal):\n 1. ord x < order G + 1", "."], ["proof (state)\nthis:\n  ord x < order G + 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x.\n     x \\<in> carrier G \\<and>\n     (\\<forall>y. y \\<in> carrier G \\<longrightarrow> ord y \\<le> ord x)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> carrier G;\n         \\<forall>x\\<in>carrier G. ord x \\<le> ord a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>x.\n     x \\<in> carrier G \\<and>\n     (\\<forall>y. y \\<in> carrier G \\<longrightarrow> ord y \\<le> ord x)\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  \\<exists>x.\n     x \\<in> carrier G \\<and>\n     (\\<forall>y. y \\<in> carrier G \\<longrightarrow> ord y \\<le> ord x)\n  \\<lbrakk>?a \\<in> carrier G;\n   \\<forall>x\\<in>carrier G. ord x \\<le> ord ?a\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in finite_group) iso_imp_finite:\n  assumes \"G \\<cong> H\" \"group H\"\n  shows \"finite_group H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_group H", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_group H", "interpret H: group H"], ["proof (prove)\ngoal (1 subgoal):\n 1. Group.group H", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_group H", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_group H", "proof(unfold_locales)"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (carrier H)", "show \"finite (carrier H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (carrier H)", "using iso_same_card[OF assms(1)]"], ["proof (prove)\nusing this:\n  card (carrier G) = card (carrier H)\n\ngoal (1 subgoal):\n 1. finite (carrier H)", "by (metis card_gt_0_iff order_def order_gt_0)"], ["proof (state)\nthis:\n  finite (carrier H)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite_group H\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in finite_group) finite_FactGroup:\n  assumes \"H \\<lhd> G\"\n  shows \"finite_group (G Mod H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_group (G Mod H)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_group (G Mod H)", "interpret H: normal H G"], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<lhd> G", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_group (G Mod H)", "interpret Mod: group \"G Mod H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Group.group (G Mod H)", "using H.factorgroup_is_group"], ["proof (prove)\nusing this:\n  Group.group (G Mod H)\n\ngoal (1 subgoal):\n 1. Group.group (G Mod H)", "."], ["proof (state)\ngoal (1 subgoal):\n 1. finite_group (G Mod H)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_group (G Mod H)", "by (unfold_locales, unfold FactGroup_def RCOSETS_def, simp)"], ["proof (state)\nthis:\n  finite_group (G Mod H)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in finite_group) bigger_subgroup_is_group:\n  assumes \"subgroup H G\" \"card H \\<ge> order G\"\n  shows \"H = carrier G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H = carrier G", "using subgroup.subset fin assms"], ["proof (prove)\nusing this:\n  subgroup ?H ?G \\<Longrightarrow> ?H \\<subseteq> carrier ?G\n  finite (carrier G)\n  subgroup H G\n  order G \\<le> card H\n\ngoal (1 subgoal):\n 1. H = carrier G", "by (metis card_seteq order_def)"], ["", "text \\<open>All generated subgroups of a finite group are obviously also finite.\\<close>"], ["", "lemma (in finite_group) finite_generate:\n  assumes \"A \\<subseteq> carrier G\"\n  shows \"finite (generate G A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (generate G A)", "using generate_incl[of A] rev_finite_subset[of \"carrier G\" \"generate G A\"] assms"], ["proof (prove)\nusing this:\n  A \\<subseteq> carrier G \\<Longrightarrow>\n  generate G A \\<subseteq> carrier G\n  \\<lbrakk>finite (carrier G); generate G A \\<subseteq> carrier G\\<rbrakk>\n  \\<Longrightarrow> finite (generate G A)\n  A \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. finite (generate G A)", "by simp"], ["", "text \\<open>We also provide an induction rule for finite groups inspired by Manuel Eberl's AFP entry\n\"Dirichlet L-Functions and Dirichlet's Theorem\" and the contained theory \"Group\\_Adjoin\". A property\nthat is true for a subgroup generated by some set and stays true when adjoining an element, is also\ntrue for the whole group.\\<close>"], ["", "lemma (in finite_group) generate_induct[consumes 1, case_names base adjoin]:\n  assumes \"A0 \\<subseteq> carrier G\"\n  assumes \"A0 \\<subseteq> carrier G \\<Longrightarrow> P (G\\<lparr>carrier := generate G A0\\<rparr>)\"\n  assumes \"\\<And>a A. \\<lbrakk>A \\<subseteq> carrier G; a \\<in> carrier G - generate G A; A0 \\<subseteq> A;\n           P (G\\<lparr>carrier := generate G A\\<rparr>)\\<rbrakk> \\<Longrightarrow> P (G\\<lparr>carrier := generate G (A \\<union> {a})\\<rparr>)\"\n  shows \"P G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P G", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P G", "define A where A: \"A = carrier G\""], ["proof (state)\nthis:\n  A = carrier G\n\ngoal (1 subgoal):\n 1. P G", "hence gA: \"generate G A = carrier G\""], ["proof (prove)\nusing this:\n  A = carrier G\n\ngoal (1 subgoal):\n 1. generate G A = carrier G", "using generate_incl[of \"carrier G\"] generate_sincl[of \"carrier G\"]"], ["proof (prove)\nusing this:\n  A = carrier G\n  carrier G \\<subseteq> carrier G \\<Longrightarrow>\n  generate G (carrier G) \\<subseteq> carrier G\n  carrier G \\<subseteq> generate G (carrier G)\n\ngoal (1 subgoal):\n 1. generate G A = carrier G", "by simp"], ["proof (state)\nthis:\n  generate G A = carrier G\n\ngoal (1 subgoal):\n 1. P G", "hence \"finite A\""], ["proof (prove)\nusing this:\n  generate G A = carrier G\n\ngoal (1 subgoal):\n 1. finite A", "using fin A"], ["proof (prove)\nusing this:\n  generate G A = carrier G\n  finite (carrier G)\n  A = carrier G\n\ngoal (1 subgoal):\n 1. finite A", "by argo"], ["proof (state)\nthis:\n  finite A\n\ngoal (1 subgoal):\n 1. P G", "moreover"], ["proof (state)\nthis:\n  finite A\n\ngoal (1 subgoal):\n 1. P G", "have \"A0 \\<subseteq> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A0 \\<subseteq> A", "using assms(1) A"], ["proof (prove)\nusing this:\n  A0 \\<subseteq> carrier G\n  A = carrier G\n\ngoal (1 subgoal):\n 1. A0 \\<subseteq> A", "by argo"], ["proof (state)\nthis:\n  A0 \\<subseteq> A\n\ngoal (1 subgoal):\n 1. P G", "moreover"], ["proof (state)\nthis:\n  A0 \\<subseteq> A\n\ngoal (1 subgoal):\n 1. P G", "have \"A \\<subseteq> carrier G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> carrier G", "using A"], ["proof (prove)\nusing this:\n  A = carrier G\n\ngoal (1 subgoal):\n 1. A \\<subseteq> carrier G", "by simp"], ["proof (state)\nthis:\n  A \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. P G", "moreover"], ["proof (state)\nthis:\n  A \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. P G", "have \"generate G A0 \\<subseteq> generate G A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generate G A0 \\<subseteq> generate G A", "using gA generate_incl[OF assms(1)]"], ["proof (prove)\nusing this:\n  generate G A = carrier G\n  generate G A0 \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. generate G A0 \\<subseteq> generate G A", "by argo"], ["proof (state)\nthis:\n  generate G A0 \\<subseteq> generate G A\n\ngoal (1 subgoal):\n 1. P G", "ultimately"], ["proof (chain)\npicking this:\n  finite A\n  A0 \\<subseteq> A\n  A \\<subseteq> carrier G\n  generate G A0 \\<subseteq> generate G A", "have \"P (G\\<lparr>carrier := generate G A\\<rparr>)\""], ["proof (prove)\nusing this:\n  finite A\n  A0 \\<subseteq> A\n  A \\<subseteq> carrier G\n  generate G A0 \\<subseteq> generate G A\n\ngoal (1 subgoal):\n 1. P (G\\<lparr>carrier := generate G A\\<rparr>)", "using assms(2, 3)"], ["proof (prove)\nusing this:\n  finite A\n  A0 \\<subseteq> A\n  A \\<subseteq> carrier G\n  generate G A0 \\<subseteq> generate G A\n  A0 \\<subseteq> carrier G \\<Longrightarrow>\n  P (G\\<lparr>carrier := generate G A0\\<rparr>)\n  \\<lbrakk>?A \\<subseteq> carrier G; ?a \\<in> carrier G - generate G ?A;\n   A0 \\<subseteq> ?A; P (G\\<lparr>carrier := generate G ?A\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> P (G\\<lparr>carrier :=\n                                  generate G (?A \\<union> {?a})\\<rparr>)\n\ngoal (1 subgoal):\n 1. P (G\\<lparr>carrier := generate G A\\<rparr>)", "proof (induction \"A\" taking: card rule: measure_induct_rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>card y < card x; finite y; A0 \\<subseteq> y;\n                    y \\<subseteq> carrier G;\n                    generate G A0 \\<subseteq> generate G y;\n                    A0 \\<subseteq> carrier G \\<Longrightarrow>\n                    P (G\\<lparr>carrier := generate G A0\\<rparr>);\n                    \\<And>A a.\n                       \\<lbrakk>A \\<subseteq> carrier G;\n                        a \\<in> carrier G - generate G A; A0 \\<subseteq> A;\n                        P (G\\<lparr>carrier :=\ngenerate G A\\<rparr>)\\<rbrakk>\n                       \\<Longrightarrow> P\n    (G\\<lparr>carrier := generate G (A \\<union> {a})\\<rparr>)\\<rbrakk>\n                   \\<Longrightarrow> P\n(G\\<lparr>carrier := generate G y\\<rparr>);\n        finite x; A0 \\<subseteq> x; x \\<subseteq> carrier G;\n        generate G A0 \\<subseteq> generate G x;\n        A0 \\<subseteq> carrier G \\<Longrightarrow>\n        P (G\\<lparr>carrier := generate G A0\\<rparr>);\n        \\<And>A a.\n           \\<lbrakk>A \\<subseteq> carrier G;\n            a \\<in> carrier G - generate G A; A0 \\<subseteq> A;\n            P (G\\<lparr>carrier := generate G A\\<rparr>)\\<rbrakk>\n           \\<Longrightarrow> P (G\\<lparr>carrier :=\n     generate G (A \\<union> {a})\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> P (G\\<lparr>carrier := generate G x\\<rparr>)", "case (less A)"], ["proof (state)\nthis:\n  \\<lbrakk>card ?y < card A; finite ?y; A0 \\<subseteq> ?y;\n   ?y \\<subseteq> carrier G; generate G A0 \\<subseteq> generate G ?y;\n   A0 \\<subseteq> carrier G \\<Longrightarrow>\n   P (G\\<lparr>carrier := generate G A0\\<rparr>);\n   \\<And>A a.\n      \\<lbrakk>A \\<subseteq> carrier G; a \\<in> carrier G - generate G A;\n       A0 \\<subseteq> A;\n       P (G\\<lparr>carrier := generate G A\\<rparr>)\\<rbrakk>\n      \\<Longrightarrow> P (G\\<lparr>carrier :=\ngenerate G (A \\<union> {a})\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> P (G\\<lparr>carrier := generate G ?y\\<rparr>)\n  finite A\n  A0 \\<subseteq> A\n  A \\<subseteq> carrier G\n  generate G A0 \\<subseteq> generate G A\n  A0 \\<subseteq> carrier G \\<Longrightarrow>\n  P (G\\<lparr>carrier := generate G A0\\<rparr>)\n  \\<lbrakk>?A \\<subseteq> carrier G; ?a \\<in> carrier G - generate G ?A;\n   A0 \\<subseteq> ?A; P (G\\<lparr>carrier := generate G ?A\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> P (G\\<lparr>carrier :=\n                                  generate G (?A \\<union> {?a})\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>card y < card x; finite y; A0 \\<subseteq> y;\n                    y \\<subseteq> carrier G;\n                    generate G A0 \\<subseteq> generate G y;\n                    A0 \\<subseteq> carrier G \\<Longrightarrow>\n                    P (G\\<lparr>carrier := generate G A0\\<rparr>);\n                    \\<And>A a.\n                       \\<lbrakk>A \\<subseteq> carrier G;\n                        a \\<in> carrier G - generate G A; A0 \\<subseteq> A;\n                        P (G\\<lparr>carrier :=\ngenerate G A\\<rparr>)\\<rbrakk>\n                       \\<Longrightarrow> P\n    (G\\<lparr>carrier := generate G (A \\<union> {a})\\<rparr>)\\<rbrakk>\n                   \\<Longrightarrow> P\n(G\\<lparr>carrier := generate G y\\<rparr>);\n        finite x; A0 \\<subseteq> x; x \\<subseteq> carrier G;\n        generate G A0 \\<subseteq> generate G x;\n        A0 \\<subseteq> carrier G \\<Longrightarrow>\n        P (G\\<lparr>carrier := generate G A0\\<rparr>);\n        \\<And>A a.\n           \\<lbrakk>A \\<subseteq> carrier G;\n            a \\<in> carrier G - generate G A; A0 \\<subseteq> A;\n            P (G\\<lparr>carrier := generate G A\\<rparr>)\\<rbrakk>\n           \\<Longrightarrow> P (G\\<lparr>carrier :=\n     generate G (A \\<union> {a})\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> P (G\\<lparr>carrier := generate G x\\<rparr>)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>card ?y < card A; finite ?y; A0 \\<subseteq> ?y;\n   ?y \\<subseteq> carrier G; generate G A0 \\<subseteq> generate G ?y;\n   A0 \\<subseteq> carrier G \\<Longrightarrow>\n   P (G\\<lparr>carrier := generate G A0\\<rparr>);\n   \\<And>A a.\n      \\<lbrakk>A \\<subseteq> carrier G; a \\<in> carrier G - generate G A;\n       A0 \\<subseteq> A;\n       P (G\\<lparr>carrier := generate G A\\<rparr>)\\<rbrakk>\n      \\<Longrightarrow> P (G\\<lparr>carrier :=\ngenerate G (A \\<union> {a})\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> P (G\\<lparr>carrier := generate G ?y\\<rparr>)\n  finite A\n  A0 \\<subseteq> A\n  A \\<subseteq> carrier G\n  generate G A0 \\<subseteq> generate G A\n  A0 \\<subseteq> carrier G \\<Longrightarrow>\n  P (G\\<lparr>carrier := generate G A0\\<rparr>)\n  \\<lbrakk>?A \\<subseteq> carrier G; ?a \\<in> carrier G - generate G ?A;\n   A0 \\<subseteq> ?A; P (G\\<lparr>carrier := generate G ?A\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> P (G\\<lparr>carrier :=\n                                  generate G (?A \\<union> {?a})\\<rparr>)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>card ?y < card A; finite ?y; A0 \\<subseteq> ?y;\n   ?y \\<subseteq> carrier G; generate G A0 \\<subseteq> generate G ?y;\n   A0 \\<subseteq> carrier G \\<Longrightarrow>\n   P (G\\<lparr>carrier := generate G A0\\<rparr>);\n   \\<And>A a.\n      \\<lbrakk>A \\<subseteq> carrier G; a \\<in> carrier G - generate G A;\n       A0 \\<subseteq> A;\n       P (G\\<lparr>carrier := generate G A\\<rparr>)\\<rbrakk>\n      \\<Longrightarrow> P (G\\<lparr>carrier :=\ngenerate G (A \\<union> {a})\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> P (G\\<lparr>carrier := generate G ?y\\<rparr>)\n  finite A\n  A0 \\<subseteq> A\n  A \\<subseteq> carrier G\n  generate G A0 \\<subseteq> generate G A\n  A0 \\<subseteq> carrier G \\<Longrightarrow>\n  P (G\\<lparr>carrier := generate G A0\\<rparr>)\n  \\<lbrakk>?A \\<subseteq> carrier G; ?a \\<in> carrier G - generate G ?A;\n   A0 \\<subseteq> ?A; P (G\\<lparr>carrier := generate G ?A\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> P (G\\<lparr>carrier :=\n                                  generate G (?A \\<union> {?a})\\<rparr>)\n\ngoal (1 subgoal):\n 1. P (G\\<lparr>carrier := generate G A\\<rparr>)", "proof(cases \"generate G A0 = generate G A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>y.\n                \\<lbrakk>card y < card A; finite y; A0 \\<subseteq> y;\n                 y \\<subseteq> carrier G;\n                 generate G A0 \\<subseteq> generate G y;\n                 A0 \\<subseteq> carrier G \\<Longrightarrow>\n                 P (G\\<lparr>carrier := generate G A0\\<rparr>);\n                 \\<And>A a.\n                    \\<lbrakk>A \\<subseteq> carrier G;\n                     a \\<in> carrier G - generate G A; A0 \\<subseteq> A;\n                     P (G\\<lparr>carrier := generate G A\\<rparr>)\\<rbrakk>\n                    \\<Longrightarrow> P\n (G\\<lparr>carrier := generate G (A \\<union> {a})\\<rparr>)\\<rbrakk>\n                \\<Longrightarrow> P (G\\<lparr>carrier :=\n          generate G y\\<rparr>);\n     finite A; A0 \\<subseteq> A; A \\<subseteq> carrier G;\n     generate G A0 \\<subseteq> generate G A;\n     A0 \\<subseteq> carrier G \\<Longrightarrow>\n     P (G\\<lparr>carrier := generate G A0\\<rparr>);\n     \\<And>A a.\n        \\<lbrakk>A \\<subseteq> carrier G; a \\<in> carrier G - generate G A;\n         A0 \\<subseteq> A;\n         P (G\\<lparr>carrier := generate G A\\<rparr>)\\<rbrakk>\n        \\<Longrightarrow> P (G\\<lparr>carrier :=\n  generate G (A \\<union> {a})\\<rparr>);\n     generate G A0 = generate G A\\<rbrakk>\n    \\<Longrightarrow> P (G\\<lparr>carrier := generate G A\\<rparr>)\n 2. \\<lbrakk>\\<And>y.\n                \\<lbrakk>card y < card A; finite y; A0 \\<subseteq> y;\n                 y \\<subseteq> carrier G;\n                 generate G A0 \\<subseteq> generate G y;\n                 A0 \\<subseteq> carrier G \\<Longrightarrow>\n                 P (G\\<lparr>carrier := generate G A0\\<rparr>);\n                 \\<And>A a.\n                    \\<lbrakk>A \\<subseteq> carrier G;\n                     a \\<in> carrier G - generate G A; A0 \\<subseteq> A;\n                     P (G\\<lparr>carrier := generate G A\\<rparr>)\\<rbrakk>\n                    \\<Longrightarrow> P\n (G\\<lparr>carrier := generate G (A \\<union> {a})\\<rparr>)\\<rbrakk>\n                \\<Longrightarrow> P (G\\<lparr>carrier :=\n          generate G y\\<rparr>);\n     finite A; A0 \\<subseteq> A; A \\<subseteq> carrier G;\n     generate G A0 \\<subseteq> generate G A;\n     A0 \\<subseteq> carrier G \\<Longrightarrow>\n     P (G\\<lparr>carrier := generate G A0\\<rparr>);\n     \\<And>A a.\n        \\<lbrakk>A \\<subseteq> carrier G; a \\<in> carrier G - generate G A;\n         A0 \\<subseteq> A;\n         P (G\\<lparr>carrier := generate G A\\<rparr>)\\<rbrakk>\n        \\<Longrightarrow> P (G\\<lparr>carrier :=\n  generate G (A \\<union> {a})\\<rparr>);\n     generate G A0 \\<noteq> generate G A\\<rbrakk>\n    \\<Longrightarrow> P (G\\<lparr>carrier := generate G A\\<rparr>)", "case True"], ["proof (state)\nthis:\n  generate G A0 = generate G A\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>y.\n                \\<lbrakk>card y < card A; finite y; A0 \\<subseteq> y;\n                 y \\<subseteq> carrier G;\n                 generate G A0 \\<subseteq> generate G y;\n                 A0 \\<subseteq> carrier G \\<Longrightarrow>\n                 P (G\\<lparr>carrier := generate G A0\\<rparr>);\n                 \\<And>A a.\n                    \\<lbrakk>A \\<subseteq> carrier G;\n                     a \\<in> carrier G - generate G A; A0 \\<subseteq> A;\n                     P (G\\<lparr>carrier := generate G A\\<rparr>)\\<rbrakk>\n                    \\<Longrightarrow> P\n (G\\<lparr>carrier := generate G (A \\<union> {a})\\<rparr>)\\<rbrakk>\n                \\<Longrightarrow> P (G\\<lparr>carrier :=\n          generate G y\\<rparr>);\n     finite A; A0 \\<subseteq> A; A \\<subseteq> carrier G;\n     generate G A0 \\<subseteq> generate G A;\n     A0 \\<subseteq> carrier G \\<Longrightarrow>\n     P (G\\<lparr>carrier := generate G A0\\<rparr>);\n     \\<And>A a.\n        \\<lbrakk>A \\<subseteq> carrier G; a \\<in> carrier G - generate G A;\n         A0 \\<subseteq> A;\n         P (G\\<lparr>carrier := generate G A\\<rparr>)\\<rbrakk>\n        \\<Longrightarrow> P (G\\<lparr>carrier :=\n  generate G (A \\<union> {a})\\<rparr>);\n     generate G A0 = generate G A\\<rbrakk>\n    \\<Longrightarrow> P (G\\<lparr>carrier := generate G A\\<rparr>)\n 2. \\<lbrakk>\\<And>y.\n                \\<lbrakk>card y < card A; finite y; A0 \\<subseteq> y;\n                 y \\<subseteq> carrier G;\n                 generate G A0 \\<subseteq> generate G y;\n                 A0 \\<subseteq> carrier G \\<Longrightarrow>\n                 P (G\\<lparr>carrier := generate G A0\\<rparr>);\n                 \\<And>A a.\n                    \\<lbrakk>A \\<subseteq> carrier G;\n                     a \\<in> carrier G - generate G A; A0 \\<subseteq> A;\n                     P (G\\<lparr>carrier := generate G A\\<rparr>)\\<rbrakk>\n                    \\<Longrightarrow> P\n (G\\<lparr>carrier := generate G (A \\<union> {a})\\<rparr>)\\<rbrakk>\n                \\<Longrightarrow> P (G\\<lparr>carrier :=\n          generate G y\\<rparr>);\n     finite A; A0 \\<subseteq> A; A \\<subseteq> carrier G;\n     generate G A0 \\<subseteq> generate G A;\n     A0 \\<subseteq> carrier G \\<Longrightarrow>\n     P (G\\<lparr>carrier := generate G A0\\<rparr>);\n     \\<And>A a.\n        \\<lbrakk>A \\<subseteq> carrier G; a \\<in> carrier G - generate G A;\n         A0 \\<subseteq> A;\n         P (G\\<lparr>carrier := generate G A\\<rparr>)\\<rbrakk>\n        \\<Longrightarrow> P (G\\<lparr>carrier :=\n  generate G (A \\<union> {a})\\<rparr>);\n     generate G A0 \\<noteq> generate G A\\<rbrakk>\n    \\<Longrightarrow> P (G\\<lparr>carrier := generate G A\\<rparr>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  generate G A0 = generate G A\n\ngoal (1 subgoal):\n 1. P (G\\<lparr>carrier := generate G A\\<rparr>)", "using less"], ["proof (prove)\nusing this:\n  generate G A0 = generate G A\n  \\<lbrakk>card ?y < card A; finite ?y; A0 \\<subseteq> ?y;\n   ?y \\<subseteq> carrier G; generate G A0 \\<subseteq> generate G ?y;\n   A0 \\<subseteq> carrier G \\<Longrightarrow>\n   P (G\\<lparr>carrier := generate G A0\\<rparr>);\n   \\<And>A a.\n      \\<lbrakk>A \\<subseteq> carrier G; a \\<in> carrier G - generate G A;\n       A0 \\<subseteq> A;\n       P (G\\<lparr>carrier := generate G A\\<rparr>)\\<rbrakk>\n      \\<Longrightarrow> P (G\\<lparr>carrier :=\ngenerate G (A \\<union> {a})\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> P (G\\<lparr>carrier := generate G ?y\\<rparr>)\n  finite A\n  A0 \\<subseteq> A\n  A \\<subseteq> carrier G\n  generate G A0 \\<subseteq> generate G A\n  A0 \\<subseteq> carrier G \\<Longrightarrow>\n  P (G\\<lparr>carrier := generate G A0\\<rparr>)\n  \\<lbrakk>?A \\<subseteq> carrier G; ?a \\<in> carrier G - generate G ?A;\n   A0 \\<subseteq> ?A; P (G\\<lparr>carrier := generate G ?A\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> P (G\\<lparr>carrier :=\n                                  generate G (?A \\<union> {?a})\\<rparr>)\n\ngoal (1 subgoal):\n 1. P (G\\<lparr>carrier := generate G A\\<rparr>)", "by force"], ["proof (state)\nthis:\n  P (G\\<lparr>carrier := generate G A\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>y.\n                \\<lbrakk>card y < card A; finite y; A0 \\<subseteq> y;\n                 y \\<subseteq> carrier G;\n                 generate G A0 \\<subseteq> generate G y;\n                 A0 \\<subseteq> carrier G \\<Longrightarrow>\n                 P (G\\<lparr>carrier := generate G A0\\<rparr>);\n                 \\<And>A a.\n                    \\<lbrakk>A \\<subseteq> carrier G;\n                     a \\<in> carrier G - generate G A; A0 \\<subseteq> A;\n                     P (G\\<lparr>carrier := generate G A\\<rparr>)\\<rbrakk>\n                    \\<Longrightarrow> P\n (G\\<lparr>carrier := generate G (A \\<union> {a})\\<rparr>)\\<rbrakk>\n                \\<Longrightarrow> P (G\\<lparr>carrier :=\n          generate G y\\<rparr>);\n     finite A; A0 \\<subseteq> A; A \\<subseteq> carrier G;\n     generate G A0 \\<subseteq> generate G A;\n     A0 \\<subseteq> carrier G \\<Longrightarrow>\n     P (G\\<lparr>carrier := generate G A0\\<rparr>);\n     \\<And>A a.\n        \\<lbrakk>A \\<subseteq> carrier G; a \\<in> carrier G - generate G A;\n         A0 \\<subseteq> A;\n         P (G\\<lparr>carrier := generate G A\\<rparr>)\\<rbrakk>\n        \\<Longrightarrow> P (G\\<lparr>carrier :=\n  generate G (A \\<union> {a})\\<rparr>);\n     generate G A0 \\<noteq> generate G A\\<rbrakk>\n    \\<Longrightarrow> P (G\\<lparr>carrier := generate G A\\<rparr>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>y.\n                \\<lbrakk>card y < card A; finite y; A0 \\<subseteq> y;\n                 y \\<subseteq> carrier G;\n                 generate G A0 \\<subseteq> generate G y;\n                 A0 \\<subseteq> carrier G \\<Longrightarrow>\n                 P (G\\<lparr>carrier := generate G A0\\<rparr>);\n                 \\<And>A a.\n                    \\<lbrakk>A \\<subseteq> carrier G;\n                     a \\<in> carrier G - generate G A; A0 \\<subseteq> A;\n                     P (G\\<lparr>carrier := generate G A\\<rparr>)\\<rbrakk>\n                    \\<Longrightarrow> P\n (G\\<lparr>carrier := generate G (A \\<union> {a})\\<rparr>)\\<rbrakk>\n                \\<Longrightarrow> P (G\\<lparr>carrier :=\n          generate G y\\<rparr>);\n     finite A; A0 \\<subseteq> A; A \\<subseteq> carrier G;\n     generate G A0 \\<subseteq> generate G A;\n     A0 \\<subseteq> carrier G \\<Longrightarrow>\n     P (G\\<lparr>carrier := generate G A0\\<rparr>);\n     \\<And>A a.\n        \\<lbrakk>A \\<subseteq> carrier G; a \\<in> carrier G - generate G A;\n         A0 \\<subseteq> A;\n         P (G\\<lparr>carrier := generate G A\\<rparr>)\\<rbrakk>\n        \\<Longrightarrow> P (G\\<lparr>carrier :=\n  generate G (A \\<union> {a})\\<rparr>);\n     generate G A0 \\<noteq> generate G A\\<rbrakk>\n    \\<Longrightarrow> P (G\\<lparr>carrier := generate G A\\<rparr>)", "case gA0: False"], ["proof (state)\nthis:\n  generate G A0 \\<noteq> generate G A\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>y.\n                \\<lbrakk>card y < card A; finite y; A0 \\<subseteq> y;\n                 y \\<subseteq> carrier G;\n                 generate G A0 \\<subseteq> generate G y;\n                 A0 \\<subseteq> carrier G \\<Longrightarrow>\n                 P (G\\<lparr>carrier := generate G A0\\<rparr>);\n                 \\<And>A a.\n                    \\<lbrakk>A \\<subseteq> carrier G;\n                     a \\<in> carrier G - generate G A; A0 \\<subseteq> A;\n                     P (G\\<lparr>carrier := generate G A\\<rparr>)\\<rbrakk>\n                    \\<Longrightarrow> P\n (G\\<lparr>carrier := generate G (A \\<union> {a})\\<rparr>)\\<rbrakk>\n                \\<Longrightarrow> P (G\\<lparr>carrier :=\n          generate G y\\<rparr>);\n     finite A; A0 \\<subseteq> A; A \\<subseteq> carrier G;\n     generate G A0 \\<subseteq> generate G A;\n     A0 \\<subseteq> carrier G \\<Longrightarrow>\n     P (G\\<lparr>carrier := generate G A0\\<rparr>);\n     \\<And>A a.\n        \\<lbrakk>A \\<subseteq> carrier G; a \\<in> carrier G - generate G A;\n         A0 \\<subseteq> A;\n         P (G\\<lparr>carrier := generate G A\\<rparr>)\\<rbrakk>\n        \\<Longrightarrow> P (G\\<lparr>carrier :=\n  generate G (A \\<union> {a})\\<rparr>);\n     generate G A0 \\<noteq> generate G A\\<rbrakk>\n    \\<Longrightarrow> P (G\\<lparr>carrier := generate G A\\<rparr>)", "with less(3)"], ["proof (chain)\npicking this:\n  A0 \\<subseteq> A\n  generate G A0 \\<noteq> generate G A", "have s: \"A0 \\<subset> A\""], ["proof (prove)\nusing this:\n  A0 \\<subseteq> A\n  generate G A0 \\<noteq> generate G A\n\ngoal (1 subgoal):\n 1. A0 \\<subset> A", "by blast"], ["proof (state)\nthis:\n  A0 \\<subset> A\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>y.\n                \\<lbrakk>card y < card A; finite y; A0 \\<subseteq> y;\n                 y \\<subseteq> carrier G;\n                 generate G A0 \\<subseteq> generate G y;\n                 A0 \\<subseteq> carrier G \\<Longrightarrow>\n                 P (G\\<lparr>carrier := generate G A0\\<rparr>);\n                 \\<And>A a.\n                    \\<lbrakk>A \\<subseteq> carrier G;\n                     a \\<in> carrier G - generate G A; A0 \\<subseteq> A;\n                     P (G\\<lparr>carrier := generate G A\\<rparr>)\\<rbrakk>\n                    \\<Longrightarrow> P\n (G\\<lparr>carrier := generate G (A \\<union> {a})\\<rparr>)\\<rbrakk>\n                \\<Longrightarrow> P (G\\<lparr>carrier :=\n          generate G y\\<rparr>);\n     finite A; A0 \\<subseteq> A; A \\<subseteq> carrier G;\n     generate G A0 \\<subseteq> generate G A;\n     A0 \\<subseteq> carrier G \\<Longrightarrow>\n     P (G\\<lparr>carrier := generate G A0\\<rparr>);\n     \\<And>A a.\n        \\<lbrakk>A \\<subseteq> carrier G; a \\<in> carrier G - generate G A;\n         A0 \\<subseteq> A;\n         P (G\\<lparr>carrier := generate G A\\<rparr>)\\<rbrakk>\n        \\<Longrightarrow> P (G\\<lparr>carrier :=\n  generate G (A \\<union> {a})\\<rparr>);\n     generate G A0 \\<noteq> generate G A\\<rbrakk>\n    \\<Longrightarrow> P (G\\<lparr>carrier := generate G A\\<rparr>)", "then"], ["proof (chain)\npicking this:\n  A0 \\<subset> A", "obtain a where a: \"a \\<in> A - A0\""], ["proof (prove)\nusing this:\n  A0 \\<subset> A\n\ngoal (1 subgoal):\n 1. (\\<And>a. a \\<in> A - A0 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  a \\<in> A - A0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>y.\n                \\<lbrakk>card y < card A; finite y; A0 \\<subseteq> y;\n                 y \\<subseteq> carrier G;\n                 generate G A0 \\<subseteq> generate G y;\n                 A0 \\<subseteq> carrier G \\<Longrightarrow>\n                 P (G\\<lparr>carrier := generate G A0\\<rparr>);\n                 \\<And>A a.\n                    \\<lbrakk>A \\<subseteq> carrier G;\n                     a \\<in> carrier G - generate G A; A0 \\<subseteq> A;\n                     P (G\\<lparr>carrier := generate G A\\<rparr>)\\<rbrakk>\n                    \\<Longrightarrow> P\n (G\\<lparr>carrier := generate G (A \\<union> {a})\\<rparr>)\\<rbrakk>\n                \\<Longrightarrow> P (G\\<lparr>carrier :=\n          generate G y\\<rparr>);\n     finite A; A0 \\<subseteq> A; A \\<subseteq> carrier G;\n     generate G A0 \\<subseteq> generate G A;\n     A0 \\<subseteq> carrier G \\<Longrightarrow>\n     P (G\\<lparr>carrier := generate G A0\\<rparr>);\n     \\<And>A a.\n        \\<lbrakk>A \\<subseteq> carrier G; a \\<in> carrier G - generate G A;\n         A0 \\<subseteq> A;\n         P (G\\<lparr>carrier := generate G A\\<rparr>)\\<rbrakk>\n        \\<Longrightarrow> P (G\\<lparr>carrier :=\n  generate G (A \\<union> {a})\\<rparr>);\n     generate G A0 \\<noteq> generate G A\\<rbrakk>\n    \\<Longrightarrow> P (G\\<lparr>carrier := generate G A\\<rparr>)", "have P1: \"P (G\\<lparr>carrier := generate G (A - {a})\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (G\\<lparr>carrier := generate G (A - {a})\\<rparr>)", "proof(rule less(1))"], ["proof (state)\ngoal (7 subgoals):\n 1. card (A - {a}) < card A\n 2. finite (A - {a})\n 3. A0 \\<subseteq> A - {a}\n 4. A - {a} \\<subseteq> carrier G\n 5. generate G A0 \\<subseteq> generate G (A - {a})\n 6. A0 \\<subseteq> carrier G \\<Longrightarrow>\n    P (G\\<lparr>carrier := generate G A0\\<rparr>)\n 7. \\<And>A a.\n       \\<lbrakk>A \\<subseteq> carrier G; a \\<in> carrier G - generate G A;\n        A0 \\<subseteq> A;\n        P (G\\<lparr>carrier := generate G A\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> P (G\\<lparr>carrier :=\n generate G (A \\<union> {a})\\<rparr>)", "show \"card (A - {a}) < card A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (A - {a}) < card A", "using a less(2)"], ["proof (prove)\nusing this:\n  a \\<in> A - A0\n  finite A\n\ngoal (1 subgoal):\n 1. card (A - {a}) < card A", "by (meson DiffD1 card_Diff1_less)"], ["proof (state)\nthis:\n  card (A - {a}) < card A\n\ngoal (6 subgoals):\n 1. finite (A - {a})\n 2. A0 \\<subseteq> A - {a}\n 3. A - {a} \\<subseteq> carrier G\n 4. generate G A0 \\<subseteq> generate G (A - {a})\n 5. A0 \\<subseteq> carrier G \\<Longrightarrow>\n    P (G\\<lparr>carrier := generate G A0\\<rparr>)\n 6. \\<And>A a.\n       \\<lbrakk>A \\<subseteq> carrier G; a \\<in> carrier G - generate G A;\n        A0 \\<subseteq> A;\n        P (G\\<lparr>carrier := generate G A\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> P (G\\<lparr>carrier :=\n generate G (A \\<union> {a})\\<rparr>)", "show \"A0 \\<subseteq> A - {a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A0 \\<subseteq> A - {a}", "using a s"], ["proof (prove)\nusing this:\n  a \\<in> A - A0\n  A0 \\<subset> A\n\ngoal (1 subgoal):\n 1. A0 \\<subseteq> A - {a}", "by blast"], ["proof (state)\nthis:\n  A0 \\<subseteq> A - {a}\n\ngoal (5 subgoals):\n 1. finite (A - {a})\n 2. A - {a} \\<subseteq> carrier G\n 3. generate G A0 \\<subseteq> generate G (A - {a})\n 4. A0 \\<subseteq> carrier G \\<Longrightarrow>\n    P (G\\<lparr>carrier := generate G A0\\<rparr>)\n 5. \\<And>A a.\n       \\<lbrakk>A \\<subseteq> carrier G; a \\<in> carrier G - generate G A;\n        A0 \\<subseteq> A;\n        P (G\\<lparr>carrier := generate G A\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> P (G\\<lparr>carrier :=\n generate G (A \\<union> {a})\\<rparr>)", "thus \"generate G A0 \\<subseteq> generate G (A - {a})\""], ["proof (prove)\nusing this:\n  A0 \\<subseteq> A - {a}\n\ngoal (1 subgoal):\n 1. generate G A0 \\<subseteq> generate G (A - {a})", "using mono_generate"], ["proof (prove)\nusing this:\n  A0 \\<subseteq> A - {a}\n  ?K \\<subseteq> ?H \\<Longrightarrow>\n  generate G ?K \\<subseteq> generate G ?H\n\ngoal (1 subgoal):\n 1. generate G A0 \\<subseteq> generate G (A - {a})", "by presburger"], ["proof (state)\nthis:\n  generate G A0 \\<subseteq> generate G (A - {a})\n\ngoal (4 subgoals):\n 1. finite (A - {a})\n 2. A - {a} \\<subseteq> carrier G\n 3. A0 \\<subseteq> carrier G \\<Longrightarrow>\n    P (G\\<lparr>carrier := generate G A0\\<rparr>)\n 4. \\<And>A a.\n       \\<lbrakk>A \\<subseteq> carrier G; a \\<in> carrier G - generate G A;\n        A0 \\<subseteq> A;\n        P (G\\<lparr>carrier := generate G A\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> P (G\\<lparr>carrier :=\n generate G (A \\<union> {a})\\<rparr>)", "qed (use less a s in auto)"], ["proof (state)\nthis:\n  P (G\\<lparr>carrier := generate G (A - {a})\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>y.\n                \\<lbrakk>card y < card A; finite y; A0 \\<subseteq> y;\n                 y \\<subseteq> carrier G;\n                 generate G A0 \\<subseteq> generate G y;\n                 A0 \\<subseteq> carrier G \\<Longrightarrow>\n                 P (G\\<lparr>carrier := generate G A0\\<rparr>);\n                 \\<And>A a.\n                    \\<lbrakk>A \\<subseteq> carrier G;\n                     a \\<in> carrier G - generate G A; A0 \\<subseteq> A;\n                     P (G\\<lparr>carrier := generate G A\\<rparr>)\\<rbrakk>\n                    \\<Longrightarrow> P\n (G\\<lparr>carrier := generate G (A \\<union> {a})\\<rparr>)\\<rbrakk>\n                \\<Longrightarrow> P (G\\<lparr>carrier :=\n          generate G y\\<rparr>);\n     finite A; A0 \\<subseteq> A; A \\<subseteq> carrier G;\n     generate G A0 \\<subseteq> generate G A;\n     A0 \\<subseteq> carrier G \\<Longrightarrow>\n     P (G\\<lparr>carrier := generate G A0\\<rparr>);\n     \\<And>A a.\n        \\<lbrakk>A \\<subseteq> carrier G; a \\<in> carrier G - generate G A;\n         A0 \\<subseteq> A;\n         P (G\\<lparr>carrier := generate G A\\<rparr>)\\<rbrakk>\n        \\<Longrightarrow> P (G\\<lparr>carrier :=\n  generate G (A \\<union> {a})\\<rparr>);\n     generate G A0 \\<noteq> generate G A\\<rbrakk>\n    \\<Longrightarrow> P (G\\<lparr>carrier := generate G A\\<rparr>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (G\\<lparr>carrier := generate G A\\<rparr>)", "proof (cases \"generate G A = generate G (A - {a})\")"], ["proof (state)\ngoal (2 subgoals):\n 1. generate G A = generate G (A - {a}) \\<Longrightarrow>\n    P (G\\<lparr>carrier := generate G A\\<rparr>)\n 2. generate G A \\<noteq> generate G (A - {a}) \\<Longrightarrow>\n    P (G\\<lparr>carrier := generate G A\\<rparr>)", "case True"], ["proof (state)\nthis:\n  generate G A = generate G (A - {a})\n\ngoal (2 subgoals):\n 1. generate G A = generate G (A - {a}) \\<Longrightarrow>\n    P (G\\<lparr>carrier := generate G A\\<rparr>)\n 2. generate G A \\<noteq> generate G (A - {a}) \\<Longrightarrow>\n    P (G\\<lparr>carrier := generate G A\\<rparr>)", "then"], ["proof (chain)\npicking this:\n  generate G A = generate G (A - {a})", "show ?thesis"], ["proof (prove)\nusing this:\n  generate G A = generate G (A - {a})\n\ngoal (1 subgoal):\n 1. P (G\\<lparr>carrier := generate G A\\<rparr>)", "using P1"], ["proof (prove)\nusing this:\n  generate G A = generate G (A - {a})\n  P (G\\<lparr>carrier := generate G (A - {a})\\<rparr>)\n\ngoal (1 subgoal):\n 1. P (G\\<lparr>carrier := generate G A\\<rparr>)", "by simp"], ["proof (state)\nthis:\n  P (G\\<lparr>carrier := generate G A\\<rparr>)\n\ngoal (1 subgoal):\n 1. generate G A \\<noteq> generate G (A - {a}) \\<Longrightarrow>\n    P (G\\<lparr>carrier := generate G A\\<rparr>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. generate G A \\<noteq> generate G (A - {a}) \\<Longrightarrow>\n    P (G\\<lparr>carrier := generate G A\\<rparr>)", "case False"], ["proof (state)\nthis:\n  generate G A \\<noteq> generate G (A - {a})\n\ngoal (1 subgoal):\n 1. generate G A \\<noteq> generate G (A - {a}) \\<Longrightarrow>\n    P (G\\<lparr>carrier := generate G A\\<rparr>)", "have \"a \\<in> carrier G - generate G (A - {a})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> carrier G - generate G (A - {a})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<in> carrier G - generate G (A - {a})", "have \"a \\<notin> generate G (A - {a})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<notin> generate G (A - {a})", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<in> generate G (A - {a}) \\<Longrightarrow> False", "assume a2: \"a \\<in> generate G (A - {a})\""], ["proof (state)\nthis:\n  a \\<in> generate G (A - {a})\n\ngoal (1 subgoal):\n 1. a \\<in> generate G (A - {a}) \\<Longrightarrow> False", "have \"generate G (A - {a}) = generate G A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generate G (A - {a}) = generate G A", "proof (rule equalityI)"], ["proof (state)\ngoal (2 subgoals):\n 1. generate G (A - {a}) \\<subseteq> generate G A\n 2. generate G A \\<subseteq> generate G (A - {a})", "show \"generate G (A - {a}) \\<subseteq> generate G A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generate G (A - {a}) \\<subseteq> generate G A", "using mono_generate"], ["proof (prove)\nusing this:\n  ?K \\<subseteq> ?H \\<Longrightarrow>\n  generate G ?K \\<subseteq> generate G ?H\n\ngoal (1 subgoal):\n 1. generate G (A - {a}) \\<subseteq> generate G A", "by auto"], ["proof (state)\nthis:\n  generate G (A - {a}) \\<subseteq> generate G A\n\ngoal (1 subgoal):\n 1. generate G A \\<subseteq> generate G (A - {a})", "show \"generate G A \\<subseteq> generate G (A - {a})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generate G A \\<subseteq> generate G (A - {a})", "proof(subst (2) generate_idem[symmetric])"], ["proof (state)\ngoal (2 subgoals):\n 1. A - {a} \\<subseteq> carrier G\n 2. generate G A \\<subseteq> generate G (generate G (A - {a}))", "show \"generate G A \\<subseteq> generate G (generate G (A - {a}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generate G A \\<subseteq> generate G (generate G (A - {a}))", "by (intro mono_generate, use generate_sincl[of \"A - {a}\"] a2 in blast)"], ["proof (state)\nthis:\n  generate G A \\<subseteq> generate G (generate G (A - {a}))\n\ngoal (1 subgoal):\n 1. A - {a} \\<subseteq> carrier G", "qed (use less in auto)"], ["proof (state)\nthis:\n  generate G A \\<subseteq> generate G (A - {a})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  generate G (A - {a}) = generate G A\n\ngoal (1 subgoal):\n 1. a \\<in> generate G (A - {a}) \\<Longrightarrow> False", "with False"], ["proof (chain)\npicking this:\n  generate G A \\<noteq> generate G (A - {a})\n  generate G (A - {a}) = generate G A", "show False"], ["proof (prove)\nusing this:\n  generate G A \\<noteq> generate G (A - {a})\n  generate G (A - {a}) = generate G A\n\ngoal (1 subgoal):\n 1. False", "by argo"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a \\<notin> generate G (A - {a})\n\ngoal (1 subgoal):\n 1. a \\<in> carrier G - generate G (A - {a})", "with a less"], ["proof (chain)\npicking this:\n  a \\<in> A - A0\n  \\<lbrakk>card ?y < card A; finite ?y; A0 \\<subseteq> ?y;\n   ?y \\<subseteq> carrier G; generate G A0 \\<subseteq> generate G ?y;\n   A0 \\<subseteq> carrier G \\<Longrightarrow>\n   P (G\\<lparr>carrier := generate G A0\\<rparr>);\n   \\<And>A a.\n      \\<lbrakk>A \\<subseteq> carrier G; a \\<in> carrier G - generate G A;\n       A0 \\<subseteq> A;\n       P (G\\<lparr>carrier := generate G A\\<rparr>)\\<rbrakk>\n      \\<Longrightarrow> P (G\\<lparr>carrier :=\ngenerate G (A \\<union> {a})\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> P (G\\<lparr>carrier := generate G ?y\\<rparr>)\n  finite A\n  A0 \\<subseteq> A\n  A \\<subseteq> carrier G\n  generate G A0 \\<subseteq> generate G A\n  A0 \\<subseteq> carrier G \\<Longrightarrow>\n  P (G\\<lparr>carrier := generate G A0\\<rparr>)\n  \\<lbrakk>?A \\<subseteq> carrier G; ?a \\<in> carrier G - generate G ?A;\n   A0 \\<subseteq> ?A; P (G\\<lparr>carrier := generate G ?A\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> P (G\\<lparr>carrier :=\n                                  generate G (?A \\<union> {?a})\\<rparr>)\n  a \\<notin> generate G (A - {a})", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<in> A - A0\n  \\<lbrakk>card ?y < card A; finite ?y; A0 \\<subseteq> ?y;\n   ?y \\<subseteq> carrier G; generate G A0 \\<subseteq> generate G ?y;\n   A0 \\<subseteq> carrier G \\<Longrightarrow>\n   P (G\\<lparr>carrier := generate G A0\\<rparr>);\n   \\<And>A a.\n      \\<lbrakk>A \\<subseteq> carrier G; a \\<in> carrier G - generate G A;\n       A0 \\<subseteq> A;\n       P (G\\<lparr>carrier := generate G A\\<rparr>)\\<rbrakk>\n      \\<Longrightarrow> P (G\\<lparr>carrier :=\ngenerate G (A \\<union> {a})\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> P (G\\<lparr>carrier := generate G ?y\\<rparr>)\n  finite A\n  A0 \\<subseteq> A\n  A \\<subseteq> carrier G\n  generate G A0 \\<subseteq> generate G A\n  A0 \\<subseteq> carrier G \\<Longrightarrow>\n  P (G\\<lparr>carrier := generate G A0\\<rparr>)\n  \\<lbrakk>?A \\<subseteq> carrier G; ?a \\<in> carrier G - generate G ?A;\n   A0 \\<subseteq> ?A; P (G\\<lparr>carrier := generate G ?A\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> P (G\\<lparr>carrier :=\n                                  generate G (?A \\<union> {?a})\\<rparr>)\n  a \\<notin> generate G (A - {a})\n\ngoal (1 subgoal):\n 1. a \\<in> carrier G - generate G (A - {a})", "by fast"], ["proof (state)\nthis:\n  a \\<in> carrier G - generate G (A - {a})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a \\<in> carrier G - generate G (A - {a})\n\ngoal (1 subgoal):\n 1. generate G A \\<noteq> generate G (A - {a}) \\<Longrightarrow>\n    P (G\\<lparr>carrier := generate G A\\<rparr>)", "from less(7)[OF _ this _ P1] less(4) s a"], ["proof (chain)\npicking this:\n  \\<lbrakk>A - {a} \\<subseteq> carrier G; A0 \\<subseteq> A - {a}\\<rbrakk>\n  \\<Longrightarrow> P (G\\<lparr>carrier :=\n                                  generate G (A - {a} \\<union> {a})\\<rparr>)\n  A \\<subseteq> carrier G\n  A0 \\<subset> A\n  a \\<in> A - A0", "have \"P (G\\<lparr>carrier := generate G (A - {a} \\<union> {a})\\<rparr>)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>A - {a} \\<subseteq> carrier G; A0 \\<subseteq> A - {a}\\<rbrakk>\n  \\<Longrightarrow> P (G\\<lparr>carrier :=\n                                  generate G (A - {a} \\<union> {a})\\<rparr>)\n  A \\<subseteq> carrier G\n  A0 \\<subset> A\n  a \\<in> A - A0\n\ngoal (1 subgoal):\n 1. P (G\\<lparr>carrier := generate G (A - {a} \\<union> {a})\\<rparr>)", "by blast"], ["proof (state)\nthis:\n  P (G\\<lparr>carrier := generate G (A - {a} \\<union> {a})\\<rparr>)\n\ngoal (1 subgoal):\n 1. generate G A \\<noteq> generate G (A - {a}) \\<Longrightarrow>\n    P (G\\<lparr>carrier := generate G A\\<rparr>)", "moreover"], ["proof (state)\nthis:\n  P (G\\<lparr>carrier := generate G (A - {a} \\<union> {a})\\<rparr>)\n\ngoal (1 subgoal):\n 1. generate G A \\<noteq> generate G (A - {a}) \\<Longrightarrow>\n    P (G\\<lparr>carrier := generate G A\\<rparr>)", "have \"A - {a} \\<union> {a} = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A - {a} \\<union> {a} = A", "using a"], ["proof (prove)\nusing this:\n  a \\<in> A - A0\n\ngoal (1 subgoal):\n 1. A - {a} \\<union> {a} = A", "by blast"], ["proof (state)\nthis:\n  A - {a} \\<union> {a} = A\n\ngoal (1 subgoal):\n 1. generate G A \\<noteq> generate G (A - {a}) \\<Longrightarrow>\n    P (G\\<lparr>carrier := generate G A\\<rparr>)", "ultimately"], ["proof (chain)\npicking this:\n  P (G\\<lparr>carrier := generate G (A - {a} \\<union> {a})\\<rparr>)\n  A - {a} \\<union> {a} = A", "show ?thesis"], ["proof (prove)\nusing this:\n  P (G\\<lparr>carrier := generate G (A - {a} \\<union> {a})\\<rparr>)\n  A - {a} \\<union> {a} = A\n\ngoal (1 subgoal):\n 1. P (G\\<lparr>carrier := generate G A\\<rparr>)", "by auto"], ["proof (state)\nthis:\n  P (G\\<lparr>carrier := generate G A\\<rparr>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P (G\\<lparr>carrier := generate G A\\<rparr>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P (G\\<lparr>carrier := generate G A\\<rparr>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P (G\\<lparr>carrier := generate G A\\<rparr>)\n\ngoal (1 subgoal):\n 1. P G", "with gA"], ["proof (chain)\npicking this:\n  generate G A = carrier G\n  P (G\\<lparr>carrier := generate G A\\<rparr>)", "show ?thesis"], ["proof (prove)\nusing this:\n  generate G A = carrier G\n  P (G\\<lparr>carrier := generate G A\\<rparr>)\n\ngoal (1 subgoal):\n 1. P G", "by simp"], ["proof (state)\nthis:\n  P G\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Finite abelian groups\\<close>"], ["", "text \\<open>Another trivial locale: the finite abelian group with some trivial facts.\\<close>"], ["", "locale finite_comm_group = finite_group + comm_group"], ["", "lemma (in finite_comm_group) iso_imp_finite_comm:\n  assumes \"G \\<cong> H\" \"group H\"\n  shows \"finite_comm_group H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_comm_group H", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_comm_group H", "interpret H: group H"], ["proof (prove)\ngoal (1 subgoal):\n 1. Group.group H", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_comm_group H", "interpret H: comm_group H"], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_group H", "by (intro iso_imp_comm_group[OF assms(1)], unfold_locales)"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_comm_group H", "interpret H: finite_group H"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_group H", "by (intro iso_imp_finite[OF assms(1)], unfold_locales)"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_comm_group H", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_comm_group H", "by unfold_locales"], ["proof (state)\nthis:\n  finite_comm_group H\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in finite_comm_group) finite_comm_FactGroup:\n  assumes \"subgroup H G\"\n  shows \"finite_comm_group (G Mod H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_comm_group (G Mod H)", "unfolding finite_comm_group_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_group (G Mod H) \\<and> comm_group (G Mod H)", "proof(safe)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite_group (G Mod H)\n 2. comm_group (G Mod H)", "show \"finite_group (G Mod H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_group (G Mod H)", "using finite_FactGroup[OF subgroup_imp_normal[OF assms]]"], ["proof (prove)\nusing this:\n  finite_group (G Mod H)\n\ngoal (1 subgoal):\n 1. finite_group (G Mod H)", "."], ["proof (state)\nthis:\n  finite_group (G Mod H)\n\ngoal (1 subgoal):\n 1. comm_group (G Mod H)", "show \"comm_group (G Mod H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_group (G Mod H)", "by (simp add: abelian_FactGroup assms)"], ["proof (state)\nthis:\n  comm_group (G Mod H)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Manuel Eberl *)"], ["", "lemma (in finite_comm_group) subgroup_imp_finite_comm_group:\n  assumes \"subgroup H G\"\n  shows   \"finite_comm_group (G\\<lparr>carrier := H\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_comm_group (G\\<lparr>carrier := H\\<rparr>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_comm_group (G\\<lparr>carrier := H\\<rparr>)", "interpret G': group \"G\\<lparr>carrier := H\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Group.group (G\\<lparr>carrier := H\\<rparr>)", "by (intro subgroup_imp_group) fact+"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_comm_group (G\\<lparr>carrier := H\\<rparr>)", "interpret H: subgroup H G"], ["proof (prove)\ngoal (1 subgoal):\n 1. subgroup H G", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. finite_comm_group (G\\<lparr>carrier := H\\<rparr>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_comm_group (G\\<lparr>carrier := H\\<rparr>)", "by standard (use finite_subset[OF H.subset] in \\<open>auto simp: m_comm\\<close>)"], ["proof (state)\nthis:\n  finite_comm_group (G\\<lparr>carrier := H\\<rparr>)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Cyclic groups\\<close>"], ["", "text \\<open>Now, the central notion of a cyclic group is introduced: a group generated\nby a single element.\\<close>"], ["", "locale cyclic_group = group +\n  fixes gen :: \"'a\"\n  assumes gen_closed[intro, simp]: \"gen \\<in> carrier G\"\n  assumes generator: \"carrier G = generate G {gen}\""], ["", "lemma (in cyclic_group) elem_is_gen_pow:\n  assumes \"x \\<in> carrier G\"\n  shows \"\\<exists>n :: int. x = gen [^] n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. x = gen [^] n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n. x = gen [^] n", "from generator"], ["proof (chain)\npicking this:\n  carrier G = generate G {gen}", "have x_g:\"x \\<in> generate G {gen}\""], ["proof (prove)\nusing this:\n  carrier G = generate G {gen}\n\ngoal (1 subgoal):\n 1. x \\<in> generate G {gen}", "using assms"], ["proof (prove)\nusing this:\n  carrier G = generate G {gen}\n  x \\<in> carrier G\n\ngoal (1 subgoal):\n 1. x \\<in> generate G {gen}", "by fast"], ["proof (state)\nthis:\n  x \\<in> generate G {gen}\n\ngoal (1 subgoal):\n 1. \\<exists>n. x = gen [^] n", "with generate_pow[of gen]"], ["proof (chain)\npicking this:\n  gen \\<in> carrier G \\<Longrightarrow>\n  generate G {gen} = {gen [^] k |k. k \\<in> UNIV}\n  x \\<in> generate G {gen}", "show ?thesis"], ["proof (prove)\nusing this:\n  gen \\<in> carrier G \\<Longrightarrow>\n  generate G {gen} = {gen [^] k |k. k \\<in> UNIV}\n  x \\<in> generate G {gen}\n\ngoal (1 subgoal):\n 1. \\<exists>n. x = gen [^] n", "using gen_closed"], ["proof (prove)\nusing this:\n  gen \\<in> carrier G \\<Longrightarrow>\n  generate G {gen} = {gen [^] k |k. k \\<in> UNIV}\n  x \\<in> generate G {gen}\n  gen \\<in> carrier G\n\ngoal (1 subgoal):\n 1. \\<exists>n. x = gen [^] n", "by blast"], ["proof (state)\nthis:\n  \\<exists>n. x = gen [^] n\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Every cyclic group is commutative/abelian.\\<close>"], ["", "sublocale cyclic_group \\<subseteq> comm_group"], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_group G", "proof(unfold_locales)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier G; y \\<in> carrier G\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes> y = y \\<otimes> x", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier G; y \\<in> carrier G\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes> y = y \\<otimes> x", "assume \"x \\<in> carrier G\" \"y \\<in> carrier G\""], ["proof (state)\nthis:\n  x \\<in> carrier G\n  y \\<in> carrier G\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier G; y \\<in> carrier G\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes> y = y \\<otimes> x", "then"], ["proof (chain)\npicking this:\n  x \\<in> carrier G\n  y \\<in> carrier G", "obtain a b where ab:\"x = gen [^] (a::int)\" \"y = gen [^] (b::int)\""], ["proof (prove)\nusing this:\n  x \\<in> carrier G\n  y \\<in> carrier G\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>x = gen [^] a; y = gen [^] b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using elem_is_gen_pow"], ["proof (prove)\nusing this:\n  x \\<in> carrier G\n  y \\<in> carrier G\n  ?x \\<in> carrier G \\<Longrightarrow> \\<exists>n. ?x = gen [^] n\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>x = gen [^] a; y = gen [^] b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by presburger"], ["proof (state)\nthis:\n  x = gen [^] a\n  y = gen [^] b\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier G; y \\<in> carrier G\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes> y = y \\<otimes> x", "then"], ["proof (chain)\npicking this:\n  x = gen [^] a\n  y = gen [^] b", "have \"x \\<otimes> y = gen [^] (a + b)\""], ["proof (prove)\nusing this:\n  x = gen [^] a\n  y = gen [^] b\n\ngoal (1 subgoal):\n 1. x \\<otimes> y = gen [^] (a + b)", "by (simp add: int_pow_mult)"], ["proof (state)\nthis:\n  x \\<otimes> y = gen [^] (a + b)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier G; y \\<in> carrier G\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes> y = y \\<otimes> x", "also"], ["proof (state)\nthis:\n  x \\<otimes> y = gen [^] (a + b)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier G; y \\<in> carrier G\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes> y = y \\<otimes> x", "have \"\\<dots> = y \\<otimes> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen [^] (a + b) = y \\<otimes> x", "using ab int_pow_mult"], ["proof (prove)\nusing this:\n  x = gen [^] a\n  y = gen [^] b\n  ?x \\<in> carrier G \\<Longrightarrow>\n  ?x [^] (?i + ?j) = ?x [^] ?i \\<otimes> ?x [^] ?j\n\ngoal (1 subgoal):\n 1. gen [^] (a + b) = y \\<otimes> x", "by (metis add.commute gen_closed)"], ["proof (state)\nthis:\n  gen [^] (a + b) = y \\<otimes> x\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier G; y \\<in> carrier G\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes> y = y \\<otimes> x", "finally"], ["proof (chain)\npicking this:\n  x \\<otimes> y = y \\<otimes> x", "show \"x \\<otimes> y = y \\<otimes> x\""], ["proof (prove)\nusing this:\n  x \\<otimes> y = y \\<otimes> x\n\ngoal (1 subgoal):\n 1. x \\<otimes> y = y \\<otimes> x", "."], ["proof (state)\nthis:\n  x \\<otimes> y = y \\<otimes> x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Some trivial intro rules for showing that a group is cyclic.\\<close>"], ["", "lemma (in group) cyclic_groupI0:\n  assumes \"a \\<in> carrier G\" \"carrier G = generate G {a}\"\n  shows \"cyclic_group G a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_And_Cyclic_Groups.cyclic_group G a", "using assms"], ["proof (prove)\nusing this:\n  a \\<in> carrier G\n  carrier G = generate G {a}\n\ngoal (1 subgoal):\n 1. Finite_And_Cyclic_Groups.cyclic_group G a", "by (unfold_locales; auto)"], ["", "lemma (in group) cyclic_groupI1:\n  assumes \"a \\<in> carrier G\" \"carrier G \\<subseteq> generate G {a}\"\n  shows \"cyclic_group G a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_And_Cyclic_Groups.cyclic_group G a", "using assms"], ["proof (prove)\nusing this:\n  a \\<in> carrier G\n  carrier G \\<subseteq> generate G {a}\n\ngoal (1 subgoal):\n 1. Finite_And_Cyclic_Groups.cyclic_group G a", "by (unfold_locales, use generate_incl[of \"{a}\"] in auto)"], ["", "lemma (in group) cyclic_groupI2:\n  assumes \"a \\<in> carrier G\"\n  shows \"cyclic_group (G\\<lparr>carrier := generate G {a}\\<rparr>) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_And_Cyclic_Groups.cyclic_group\n     (G\\<lparr>carrier := generate G {a}\\<rparr>) a", "proof (intro group.cyclic_groupI0)"], ["proof (state)\ngoal (3 subgoals):\n 1. Group.group (G\\<lparr>carrier := generate G {a}\\<rparr>)\n 2. a \\<in> carrier (G\\<lparr>carrier := generate G {a}\\<rparr>)\n 3. carrier (G\\<lparr>carrier := generate G {a}\\<rparr>) =\n    generate (G\\<lparr>carrier := generate G {a}\\<rparr>) {a}", "show \"group (G\\<lparr>carrier := generate G {a}\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Group.group (G\\<lparr>carrier := generate G {a}\\<rparr>)", "by (intro subgroup.subgroup_is_group group.generate_is_subgroup, use assms in simp_all)"], ["proof (state)\nthis:\n  Group.group (G\\<lparr>carrier := generate G {a}\\<rparr>)\n\ngoal (2 subgoals):\n 1. a \\<in> carrier (G\\<lparr>carrier := generate G {a}\\<rparr>)\n 2. carrier (G\\<lparr>carrier := generate G {a}\\<rparr>) =\n    generate (G\\<lparr>carrier := generate G {a}\\<rparr>) {a}", "show \"a \\<in> carrier (G\\<lparr>carrier := generate G {a}\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> carrier (G\\<lparr>carrier := generate G {a}\\<rparr>)", "using generate.incl[of a \"{a}\"]"], ["proof (prove)\nusing this:\n  a \\<in> {a} \\<Longrightarrow> a \\<in> generate ?G {a}\n\ngoal (1 subgoal):\n 1. a \\<in> carrier (G\\<lparr>carrier := generate G {a}\\<rparr>)", "by auto"], ["proof (state)\nthis:\n  a \\<in> carrier (G\\<lparr>carrier := generate G {a}\\<rparr>)\n\ngoal (1 subgoal):\n 1. carrier (G\\<lparr>carrier := generate G {a}\\<rparr>) =\n    generate (G\\<lparr>carrier := generate G {a}\\<rparr>) {a}", "show \"carrier (G\\<lparr>carrier := generate G {a}\\<rparr>) = generate (G\\<lparr>carrier := generate G {a}\\<rparr>) {a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. carrier (G\\<lparr>carrier := generate G {a}\\<rparr>) =\n    generate (G\\<lparr>carrier := generate G {a}\\<rparr>) {a}", "using assms"], ["proof (prove)\nusing this:\n  a \\<in> carrier G\n\ngoal (1 subgoal):\n 1. carrier (G\\<lparr>carrier := generate G {a}\\<rparr>) =\n    generate (G\\<lparr>carrier := generate G {a}\\<rparr>) {a}", "by (simp add: generate_consistent generate.incl group.generate_is_subgroup)"], ["proof (state)\nthis:\n  carrier (G\\<lparr>carrier := generate G {a}\\<rparr>) =\n  generate (G\\<lparr>carrier := generate G {a}\\<rparr>) {a}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The order of the generating element is always the same as the group order.\\<close>"], ["", "lemma (in cyclic_group) ord_gen_is_group_order:\n  shows \"ord gen = order G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord gen = order G", "proof (cases \"finite (carrier G)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (carrier G) \\<Longrightarrow> ord gen = order G\n 2. infinite (carrier G) \\<Longrightarrow> ord gen = order G", "case True"], ["proof (state)\nthis:\n  finite (carrier G)\n\ngoal (2 subgoals):\n 1. finite (carrier G) \\<Longrightarrow> ord gen = order G\n 2. infinite (carrier G) \\<Longrightarrow> ord gen = order G", "with generator"], ["proof (chain)\npicking this:\n  carrier G = generate G {gen}\n  finite (carrier G)", "show \"ord gen = order G\""], ["proof (prove)\nusing this:\n  carrier G = generate G {gen}\n  finite (carrier G)\n\ngoal (1 subgoal):\n 1. ord gen = order G", "using generate_pow_card[of gen] order_def[of G] gen_closed"], ["proof (prove)\nusing this:\n  carrier G = generate G {gen}\n  finite (carrier G)\n  gen \\<in> carrier G \\<Longrightarrow> ord gen = card (generate G {gen})\n  order G = card (carrier G)\n  gen \\<in> carrier G\n\ngoal (1 subgoal):\n 1. ord gen = order G", "by simp"], ["proof (state)\nthis:\n  ord gen = order G\n\ngoal (1 subgoal):\n 1. infinite (carrier G) \\<Longrightarrow> ord gen = order G", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite (carrier G) \\<Longrightarrow> ord gen = order G", "case False"], ["proof (state)\nthis:\n  infinite (carrier G)\n\ngoal (1 subgoal):\n 1. infinite (carrier G) \\<Longrightarrow> ord gen = order G", "thus ?thesis"], ["proof (prove)\nusing this:\n  infinite (carrier G)\n\ngoal (1 subgoal):\n 1. ord gen = order G", "using generate_pow_card generator order_def[of G] card_eq_0_iff[of \"carrier G\"]"], ["proof (prove)\nusing this:\n  infinite (carrier G)\n  ?a \\<in> carrier G \\<Longrightarrow> ord ?a = card (generate G {?a})\n  carrier G = generate G {gen}\n  order G = card (carrier G)\n  (card (carrier G) = 0) = (carrier G = {} \\<or> infinite (carrier G))\n\ngoal (1 subgoal):\n 1. ord gen = order G", "by force"], ["proof (state)\nthis:\n  ord gen = order G\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>In the case of a finite group, it is sufficient to have one element of group order to know\nthat the group is cyclic.\\<close>"], ["", "lemma (in finite_group) element_ord_generates_cyclic:\n  assumes \"a \\<in> carrier G\" \"ord a = order G\"\n  shows \"cyclic_group G a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_And_Cyclic_Groups.cyclic_group G a", "proof (unfold_locales)"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<in> carrier G\n 2. carrier G = generate G {a}", "show \"a \\<in> carrier G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> carrier G", "using assms(1)"], ["proof (prove)\nusing this:\n  a \\<in> carrier G\n\ngoal (1 subgoal):\n 1. a \\<in> carrier G", "by simp"], ["proof (state)\nthis:\n  a \\<in> carrier G\n\ngoal (1 subgoal):\n 1. carrier G = generate G {a}", "show \"carrier G = generate G {a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. carrier G = generate G {a}", "using assms bigger_subgroup_is_group[OF generate_is_subgroup]"], ["proof (prove)\nusing this:\n  a \\<in> carrier G\n  ord a = order G\n  \\<lbrakk>?H1 \\<subseteq> carrier G;\n   order G \\<le> card (generate G ?H1)\\<rbrakk>\n  \\<Longrightarrow> generate G ?H1 = carrier G\n\ngoal (1 subgoal):\n 1. carrier G = generate G {a}", "by (metis empty_subsetI fin generate_pow_card insert_subset ord_le_group_order)"], ["proof (state)\nthis:\n  carrier G = generate G {a}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Another useful fact is that a group of prime order is also cyclic.\\<close>"], ["", "lemma (in group) prime_order_group_is_cyc:\n  assumes \"Factorial_Ring.prime (order G)\"\n  obtains g where \"cyclic_group G g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>g.\n        Finite_And_Cyclic_Groups.cyclic_group G g \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof (unfold_locales)"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>g.\n        Finite_And_Cyclic_Groups.cyclic_group G g \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "obtain p where order_p: \"order G = p\" and p_prime: \"Factorial_Ring.prime p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>order G = p; normalization_semidom_class.prime p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  normalization_semidom_class.prime (order G)\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>order G = p; normalization_semidom_class.prime p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  order G = p\n  normalization_semidom_class.prime p\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        Finite_And_Cyclic_Groups.cyclic_group G g \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  order G = p\n  normalization_semidom_class.prime p", "have \"card (carrier G) \\<ge> 2\""], ["proof (prove)\nusing this:\n  order G = p\n  normalization_semidom_class.prime p\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (carrier G)", "by (simp add: order_def prime_ge_2_nat)"], ["proof (state)\nthis:\n  2 \\<le> card (carrier G)\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        Finite_And_Cyclic_Groups.cyclic_group G g \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  2 \\<le> card (carrier G)", "obtain a where a_in: \"a \\<in> carrier G\" and a_not_one: \"a \\<noteq> \\<one>\""], ["proof (prove)\nusing this:\n  2 \\<le> card (carrier G)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> carrier G; a \\<noteq> \\<one>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using one_unique"], ["proof (prove)\nusing this:\n  2 \\<le> card (carrier G)\n  \\<lbrakk>?u \\<in> carrier G;\n   \\<And>x. x \\<in> carrier G \\<Longrightarrow> ?u \\<otimes> x = x\\<rbrakk>\n  \\<Longrightarrow> ?u = \\<one>\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> carrier G; a \\<noteq> \\<one>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (no_types, lifting) card_2_iff' obtain_subset_with_card_n subset_iff)"], ["proof (state)\nthis:\n  a \\<in> carrier G\n  a \\<noteq> \\<one>\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        Finite_And_Cyclic_Groups.cyclic_group G g \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "interpret fin: finite_group G"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_group G", "using assms order_gt_0_iff_finite"], ["proof (prove)\nusing this:\n  normalization_semidom_class.prime (order G)\n  (0 < order G) = finite (carrier G)\n\ngoal (1 subgoal):\n 1. finite_group G", "unfolding order_def"], ["proof (prove)\nusing this:\n  normalization_semidom_class.prime (card (carrier G))\n  (0 < card (carrier G)) = finite (carrier G)\n\ngoal (1 subgoal):\n 1. finite_group G", "by unfold_locales auto"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>g.\n        Finite_And_Cyclic_Groups.cyclic_group G g \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have \"ord a dvd p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord a dvd p", "using a_in order_p ord_dvd_group_order"], ["proof (prove)\nusing this:\n  a \\<in> carrier G\n  order G = p\n  ?a \\<in> carrier G \\<Longrightarrow> ord ?a dvd order G\n\ngoal (1 subgoal):\n 1. ord a dvd p", "by blast"], ["proof (state)\nthis:\n  ord a dvd p\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        Finite_And_Cyclic_Groups.cyclic_group G g \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "hence \"ord a = p\""], ["proof (prove)\nusing this:\n  ord a dvd p\n\ngoal (1 subgoal):\n 1. ord a = p", "using prime_nat_iff[of p] p_prime ord_eq_1 a_in a_not_one"], ["proof (prove)\nusing this:\n  ord a dvd p\n  normalization_semidom_class.prime p =\n  (1 < p \\<and> (\\<forall>m. m dvd p \\<longrightarrow> m = 1 \\<or> m = p))\n  normalization_semidom_class.prime p\n  ?x \\<in> carrier G \\<Longrightarrow> (ord ?x = 1) = (?x = \\<one>)\n  a \\<in> carrier G\n  a \\<noteq> \\<one>\n\ngoal (1 subgoal):\n 1. ord a = p", "by blast"], ["proof (state)\nthis:\n  ord a = p\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        Finite_And_Cyclic_Groups.cyclic_group G g \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  ord a = p", "interpret cyclic_group G a"], ["proof (prove)\nusing this:\n  ord a = p\n\ngoal (1 subgoal):\n 1. Finite_And_Cyclic_Groups.cyclic_group G a", "using fin.element_ord_generates_cyclic order_p a_in"], ["proof (prove)\nusing this:\n  ord a = p\n  \\<lbrakk>?a \\<in> carrier G; ord ?a = order G\\<rbrakk>\n  \\<Longrightarrow> Finite_And_Cyclic_Groups.cyclic_group G ?a\n  order G = p\n  a \\<in> carrier G\n\ngoal (1 subgoal):\n 1. Finite_And_Cyclic_Groups.cyclic_group G a", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>g.\n        Finite_And_Cyclic_Groups.cyclic_group G g \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using that cyclic_group_axioms"], ["proof (prove)\nusing this:\n  Finite_And_Cyclic_Groups.cyclic_group G ?g \\<Longrightarrow> thesis\n  Finite_And_Cyclic_Groups.cyclic_group G a\n\ngoal (1 subgoal):\n 1. thesis", "."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>What follows is an induction principle for cyclic groups: a predicate is true for all elements\nof the group if it is true for all elements that can be formed by the generating element by just\nmultiplication and if it also holds under the forming of the inverse (as we by this cover\nall elements of the group),\\<close>"], ["", "(* Manuel Eberl *)"], ["", "lemma (in cyclic_group) generator_induct [consumes 1, case_names generate inv]:\n  assumes x: \"x \\<in> carrier G\"\n  assumes IH1: \"\\<And>n::nat. P (gen [^] n)\"\n  assumes IH2: \"\\<And>x. x \\<in> carrier G \\<Longrightarrow> P x \\<Longrightarrow> P (inv x)\"\n  shows   \"P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P x", "from x"], ["proof (chain)\npicking this:\n  x \\<in> carrier G", "obtain n :: int where n: \"x = gen [^] n\""], ["proof (prove)\nusing this:\n  x \\<in> carrier G\n\ngoal (1 subgoal):\n 1. (\\<And>n. x = gen [^] n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using elem_is_gen_pow[of x]"], ["proof (prove)\nusing this:\n  x \\<in> carrier G\n  x \\<in> carrier G \\<Longrightarrow> \\<exists>n. x = gen [^] n\n\ngoal (1 subgoal):\n 1. (\\<And>n. x = gen [^] n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = gen [^] n\n\ngoal (1 subgoal):\n 1. P x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P x", "proof (cases \"n \\<ge> 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> n \\<Longrightarrow> P x\n 2. \\<not> 0 \\<le> n \\<Longrightarrow> P x", "case True"], ["proof (state)\nthis:\n  0 \\<le> n\n\ngoal (2 subgoals):\n 1. 0 \\<le> n \\<Longrightarrow> P x\n 2. \\<not> 0 \\<le> n \\<Longrightarrow> P x", "have \"P (gen [^] nat n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (gen [^] nat n)", "by (rule IH1)"], ["proof (state)\nthis:\n  P (gen [^] nat n)\n\ngoal (2 subgoals):\n 1. 0 \\<le> n \\<Longrightarrow> P x\n 2. \\<not> 0 \\<le> n \\<Longrightarrow> P x", "with True n"], ["proof (chain)\npicking this:\n  0 \\<le> n\n  x = gen [^] n\n  P (gen [^] nat n)", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> n\n  x = gen [^] n\n  P (gen [^] nat n)\n\ngoal (1 subgoal):\n 1. P x", "by simp"], ["proof (state)\nthis:\n  P x\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> n \\<Longrightarrow> P x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> n \\<Longrightarrow> P x", "case False"], ["proof (state)\nthis:\n  \\<not> 0 \\<le> n\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> n \\<Longrightarrow> P x", "have \"P (inv (gen [^] nat (-n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (inv (gen [^] nat (- n)))", "by (intro IH1 IH2) auto"], ["proof (state)\nthis:\n  P (inv (gen [^] nat (- n)))\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> n \\<Longrightarrow> P x", "also"], ["proof (state)\nthis:\n  P (inv (gen [^] nat (- n)))\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> n \\<Longrightarrow> P x", "have \"gen [^] nat (-n) = gen [^] (-n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen [^] nat (- n) = gen [^] - n", "using False"], ["proof (prove)\nusing this:\n  \\<not> 0 \\<le> n\n\ngoal (1 subgoal):\n 1. gen [^] nat (- n) = gen [^] - n", "by simp"], ["proof (state)\nthis:\n  gen [^] nat (- n) = gen [^] - n\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> n \\<Longrightarrow> P x", "also"], ["proof (state)\nthis:\n  gen [^] nat (- n) = gen [^] - n\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> n \\<Longrightarrow> P x", "have \"inv \\<dots> = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv (gen [^] - n) = x", "using n"], ["proof (prove)\nusing this:\n  x = gen [^] n\n\ngoal (1 subgoal):\n 1. inv (gen [^] - n) = x", "by (simp add: int_pow_neg)"], ["proof (state)\nthis:\n  inv (gen [^] - n) = x\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> n \\<Longrightarrow> P x", "finally"], ["proof (chain)\npicking this:\n  P x", "show ?thesis"], ["proof (prove)\nusing this:\n  P x\n\ngoal (1 subgoal):\n 1. P x", "."], ["proof (state)\nthis:\n  P x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P x\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Finite cyclic groups\\<close>"], ["", "text \\<open>Additionally, the notion of the finite cyclic group is introduced.\\<close>"], ["", "locale finite_cyclic_group = finite_group + cyclic_group"], ["", "sublocale finite_cyclic_group \\<subseteq> finite_comm_group"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_comm_group G", "by unfold_locales"], ["", "lemma (in finite_cyclic_group) ord_gen_gt_zero:\n  \"ord gen > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < ord gen", "using ord_ge_1[OF fin gen_closed]"], ["proof (prove)\nusing this:\n  1 \\<le> ord gen\n\ngoal (1 subgoal):\n 1. 0 < ord gen", "by simp"], ["", "text \\<open>In order to prove something about an element in a finite abelian group, it is possible to show\nthis property for the neutral element or the generating element and inductively for the elements\nthat are formed by multiplying with the generator.\\<close>"], ["", "lemma (in finite_cyclic_group) generator_induct0 [consumes 1, case_names one step]:\n  assumes x: \"x \\<in> carrier G\"\n  assumes IH1: \"P \\<one>\"\n  assumes IH2: \"\\<And>x. \\<lbrakk>x \\<in> carrier G; P x\\<rbrakk> \\<Longrightarrow> P (x \\<otimes> gen)\"\n  shows   \"P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P x", "from ord_gen_gt_zero generate_nat_pow[OF _ gen_closed]"], ["proof (chain)\npicking this:\n  0 < ord gen\n  ord gen \\<noteq> 0 \\<Longrightarrow>\n  generate G {gen} = {gen [^] k |k. k \\<in> {0..ord gen - 1}}", "obtain n::nat where n: \"x = gen [^] n\""], ["proof (prove)\nusing this:\n  0 < ord gen\n  ord gen \\<noteq> 0 \\<Longrightarrow>\n  generate G {gen} = {gen [^] k |k. k \\<in> {0..ord gen - 1}}\n\ngoal (1 subgoal):\n 1. (\\<And>n. x = gen [^] n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using generator x"], ["proof (prove)\nusing this:\n  0 < ord gen\n  ord gen \\<noteq> 0 \\<Longrightarrow>\n  generate G {gen} = {gen [^] k |k. k \\<in> {0..ord gen - 1}}\n  carrier G = generate G {gen}\n  x \\<in> carrier G\n\ngoal (1 subgoal):\n 1. (\\<And>n. x = gen [^] n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x = gen [^] n\n\ngoal (1 subgoal):\n 1. P x", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = gen [^] n\n\ngoal (1 subgoal):\n 1. P x", "by (induction n arbitrary: x, use assms in auto)"], ["proof (state)\nthis:\n  P x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in finite_cyclic_group) generator_induct1 [consumes 1, case_names gen step]:\n  assumes x: \"x \\<in> carrier G\"\n  assumes IH1: \"P gen\"\n  assumes IH2: \"\\<And>x. \\<lbrakk>x \\<in> carrier G; P x\\<rbrakk> \\<Longrightarrow> P (x \\<otimes> gen)\"\n  shows   \"P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P x", "proof(rule generator_induct0[OF x])"], ["proof (state)\ngoal (2 subgoals):\n 1. P \\<one>\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> carrier G; P x\\<rbrakk>\n       \\<Longrightarrow> P (x \\<otimes> gen)", "show \"\\<And>x. \\<lbrakk>x \\<in> carrier G; P x\\<rbrakk> \\<Longrightarrow> P (x \\<otimes> gen)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> carrier G; P x\\<rbrakk>\n       \\<Longrightarrow> P (x \\<otimes> gen)", "using IH2"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> carrier G; P ?x\\<rbrakk>\n  \\<Longrightarrow> P (?x \\<otimes> gen)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> carrier G; P x\\<rbrakk>\n       \\<Longrightarrow> P (x \\<otimes> gen)", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> carrier G; P ?x\\<rbrakk>\n  \\<Longrightarrow> P (?x \\<otimes> gen)\n\ngoal (1 subgoal):\n 1. P \\<one>", "have \"P x\" if \"n > 0\" \"x = gen [^] n\" for n::nat and x"], ["proof (prove)\ngoal (1 subgoal):\n 1. P x", "using that"], ["proof (prove)\nusing this:\n  0 < n\n  x = gen [^] n\n\ngoal (1 subgoal):\n 1. P x", "by (induction n arbitrary: x; use assms in fastforce)"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?n; ?x = gen [^] ?n\\<rbrakk> \\<Longrightarrow> P ?x\n\ngoal (1 subgoal):\n 1. P \\<one>", "from this[OF ord_pos[OF gen_closed] pow_ord_eq_1[OF gen_closed, symmetric]]"], ["proof (chain)\npicking this:\n  P \\<one>", "show \"P \\<one>\""], ["proof (prove)\nusing this:\n  P \\<one>\n\ngoal (1 subgoal):\n 1. P \\<one>", "."], ["proof (state)\nthis:\n  P \\<one>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>\\<open>get_exp\\<close> - discrete logarithm\\<close>"], ["", "text \\<open>What now follows is the discrete logarithm for groups. It is used at several times througout\nthis entry and is initially used to show that two cyclic groups of the same order are isomorphic.\\<close>"], ["", "definition (in group) get_exp where\n  \"get_exp g = (\\<lambda>a. SOME k::int. a = g [^] k)\""], ["", "text \\<open>For each element with itself as the basis the discrete logarithm indeed does what expected.\nThis is not the strongest possible statement, but sufficient for our needs.\\<close>"], ["", "lemma (in group) get_exp_self_fulfills:\n  assumes \"a \\<in> carrier G\"\n  shows \"a = a [^] get_exp a a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = a [^] get_exp a a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a = a [^] get_exp a a", "have \"a = a [^] (1::int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = a [^] 1", "using assms"], ["proof (prove)\nusing this:\n  a \\<in> carrier G\n\ngoal (1 subgoal):\n 1. a = a [^] 1", "by auto"], ["proof (state)\nthis:\n  a = a [^] 1\n\ngoal (1 subgoal):\n 1. a = a [^] get_exp a a", "moreover"], ["proof (state)\nthis:\n  a = a [^] 1\n\ngoal (1 subgoal):\n 1. a = a [^] get_exp a a", "have \"a [^] (1::int) = a [^] (SOME x::int. a [^] (1::int) = a [^] x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a [^] 1 = a [^] (SOME x. a [^] 1 = a [^] x)", "by (intro someI_ex[of \"\\<lambda>x::int. a [^] (1::int) = a [^] x\"]; blast)"], ["proof (state)\nthis:\n  a [^] 1 = a [^] (SOME x. a [^] 1 = a [^] x)\n\ngoal (1 subgoal):\n 1. a = a [^] get_exp a a", "ultimately"], ["proof (chain)\npicking this:\n  a = a [^] 1\n  a [^] 1 = a [^] (SOME x. a [^] 1 = a [^] x)", "show ?thesis"], ["proof (prove)\nusing this:\n  a = a [^] 1\n  a [^] 1 = a [^] (SOME x. a [^] 1 = a [^] x)\n\ngoal (1 subgoal):\n 1. a = a [^] get_exp a a", "unfolding get_exp_def"], ["proof (prove)\nusing this:\n  a = a [^] 1\n  a [^] 1 = a [^] (SOME x. a [^] 1 = a [^] x)\n\ngoal (1 subgoal):\n 1. a = a [^] (SOME k. a = a [^] k)", "by simp"], ["proof (state)\nthis:\n  a = a [^] get_exp a a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in group) get_exp_self:\n  assumes \"a \\<in> carrier G\"\n  shows \"get_exp a a mod ord a = (1::int) mod ord a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get_exp a a mod int (ord a) = 1 mod int (ord a)", "by (intro pow_eq_int_mod[OF assms], use get_exp_self_fulfills[OF assms] assms in auto)"], ["", "text \\<open>For cyclic groups, the discrete logarithm \"works\" for every element.\\<close>"], ["", "lemma (in cyclic_group) get_exp_fulfills:\n  assumes \"a \\<in> carrier G\"\n  shows \"a = gen [^] get_exp gen a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = gen [^] get_exp gen a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a = gen [^] get_exp gen a", "from elem_is_gen_pow[OF assms]"], ["proof (chain)\npicking this:\n  \\<exists>n. a = gen [^] n", "obtain k::int where k: \"a = gen [^] k\""], ["proof (prove)\nusing this:\n  \\<exists>n. a = gen [^] n\n\ngoal (1 subgoal):\n 1. (\\<And>k. a = gen [^] k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  a = gen [^] k\n\ngoal (1 subgoal):\n 1. a = gen [^] get_exp gen a", "moreover"], ["proof (state)\nthis:\n  a = gen [^] k\n\ngoal (1 subgoal):\n 1. a = gen [^] get_exp gen a", "have \"gen [^] k = gen [^] (SOME x::int. gen [^] k = gen [^] x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen [^] k = gen [^] (SOME x. gen [^] k = gen [^] x)", "by(intro someI_ex[of \"\\<lambda>x::int. gen [^] k = gen [^] x\"]; blast)"], ["proof (state)\nthis:\n  gen [^] k = gen [^] (SOME x. gen [^] k = gen [^] x)\n\ngoal (1 subgoal):\n 1. a = gen [^] get_exp gen a", "ultimately"], ["proof (chain)\npicking this:\n  a = gen [^] k\n  gen [^] k = gen [^] (SOME x. gen [^] k = gen [^] x)", "show ?thesis"], ["proof (prove)\nusing this:\n  a = gen [^] k\n  gen [^] k = gen [^] (SOME x. gen [^] k = gen [^] x)\n\ngoal (1 subgoal):\n 1. a = gen [^] get_exp gen a", "unfolding get_exp_def"], ["proof (prove)\nusing this:\n  a = gen [^] k\n  gen [^] k = gen [^] (SOME x. gen [^] k = gen [^] x)\n\ngoal (1 subgoal):\n 1. a = gen [^] (SOME k. a = gen [^] k)", "by blast"], ["proof (state)\nthis:\n  a = gen [^] get_exp gen a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in cyclic_group) get_exp_non_zero:\n  assumes\"b \\<in> carrier G\" \"b \\<noteq> \\<one>\"\n  shows \"get_exp gen b \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get_exp gen b \\<noteq> 0", "using assms get_exp_fulfills[OF assms(1)]"], ["proof (prove)\nusing this:\n  b \\<in> carrier G\n  b \\<noteq> \\<one>\n  b = gen [^] get_exp gen b\n\ngoal (1 subgoal):\n 1. get_exp gen b \\<noteq> 0", "by auto"], ["", "text \\<open>One well-known logarithmic identity.\\<close>"], ["", "lemma (in cyclic_group) get_exp_mult_mod:\n  assumes \"a \\<in> carrier G\" \"b \\<in> carrier G\"\n  shows \"get_exp gen (a \\<otimes> b) mod (ord gen) = (get_exp gen a + get_exp gen b) mod (ord gen)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get_exp gen (a \\<otimes> b) mod int (ord gen) =\n    (get_exp gen a + get_exp gen b) mod int (ord gen)", "proof (intro pow_eq_int_mod[OF gen_closed])"], ["proof (state)\ngoal (1 subgoal):\n 1. gen [^] get_exp gen (a \\<otimes> b) =\n    gen [^] (get_exp gen a + get_exp gen b)", "from get_exp_fulfills[of \"a \\<otimes> b\"]"], ["proof (chain)\npicking this:\n  a \\<otimes> b \\<in> carrier G \\<Longrightarrow>\n  a \\<otimes> b = gen [^] get_exp gen (a \\<otimes> b)", "have \"gen [^] get_exp gen (a \\<otimes> b) = a \\<otimes> b\""], ["proof (prove)\nusing this:\n  a \\<otimes> b \\<in> carrier G \\<Longrightarrow>\n  a \\<otimes> b = gen [^] get_exp gen (a \\<otimes> b)\n\ngoal (1 subgoal):\n 1. gen [^] get_exp gen (a \\<otimes> b) = a \\<otimes> b", "using assms"], ["proof (prove)\nusing this:\n  a \\<otimes> b \\<in> carrier G \\<Longrightarrow>\n  a \\<otimes> b = gen [^] get_exp gen (a \\<otimes> b)\n  a \\<in> carrier G\n  b \\<in> carrier G\n\ngoal (1 subgoal):\n 1. gen [^] get_exp gen (a \\<otimes> b) = a \\<otimes> b", "by simp"], ["proof (state)\nthis:\n  gen [^] get_exp gen (a \\<otimes> b) = a \\<otimes> b\n\ngoal (1 subgoal):\n 1. gen [^] get_exp gen (a \\<otimes> b) =\n    gen [^] (get_exp gen a + get_exp gen b)", "moreover"], ["proof (state)\nthis:\n  gen [^] get_exp gen (a \\<otimes> b) = a \\<otimes> b\n\ngoal (1 subgoal):\n 1. gen [^] get_exp gen (a \\<otimes> b) =\n    gen [^] (get_exp gen a + get_exp gen b)", "have \"gen [^] (get_exp gen a + get_exp gen b) = a \\<otimes> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen [^] (get_exp gen a + get_exp gen b) = a \\<otimes> b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gen [^] (get_exp gen a + get_exp gen b) = a \\<otimes> b", "have \"gen [^] (get_exp gen a + get_exp gen b) = gen [^] (get_exp gen a) \\<otimes> gen [^] (get_exp gen b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen [^] (get_exp gen a + get_exp gen b) =\n    gen [^] get_exp gen a \\<otimes> gen [^] get_exp gen b", "using int_pow_mult"], ["proof (prove)\nusing this:\n  ?x \\<in> carrier G \\<Longrightarrow>\n  ?x [^] (?i + ?j) = ?x [^] ?i \\<otimes> ?x [^] ?j\n\ngoal (1 subgoal):\n 1. gen [^] (get_exp gen a + get_exp gen b) =\n    gen [^] get_exp gen a \\<otimes> gen [^] get_exp gen b", "by blast"], ["proof (state)\nthis:\n  gen [^] (get_exp gen a + get_exp gen b) =\n  gen [^] get_exp gen a \\<otimes> gen [^] get_exp gen b\n\ngoal (1 subgoal):\n 1. gen [^] (get_exp gen a + get_exp gen b) = a \\<otimes> b", "with get_exp_fulfills assms"], ["proof (chain)\npicking this:\n  ?a \\<in> carrier G \\<Longrightarrow> ?a = gen [^] get_exp gen ?a\n  a \\<in> carrier G\n  b \\<in> carrier G\n  gen [^] (get_exp gen a + get_exp gen b) =\n  gen [^] get_exp gen a \\<otimes> gen [^] get_exp gen b", "show ?thesis"], ["proof (prove)\nusing this:\n  ?a \\<in> carrier G \\<Longrightarrow> ?a = gen [^] get_exp gen ?a\n  a \\<in> carrier G\n  b \\<in> carrier G\n  gen [^] (get_exp gen a + get_exp gen b) =\n  gen [^] get_exp gen a \\<otimes> gen [^] get_exp gen b\n\ngoal (1 subgoal):\n 1. gen [^] (get_exp gen a + get_exp gen b) = a \\<otimes> b", "by simp"], ["proof (state)\nthis:\n  gen [^] (get_exp gen a + get_exp gen b) = a \\<otimes> b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gen [^] (get_exp gen a + get_exp gen b) = a \\<otimes> b\n\ngoal (1 subgoal):\n 1. gen [^] get_exp gen (a \\<otimes> b) =\n    gen [^] (get_exp gen a + get_exp gen b)", "ultimately"], ["proof (chain)\npicking this:\n  gen [^] get_exp gen (a \\<otimes> b) = a \\<otimes> b\n  gen [^] (get_exp gen a + get_exp gen b) = a \\<otimes> b", "show \"gen [^] get_exp gen (a \\<otimes> b) = gen [^] (get_exp gen a + get_exp gen b)\""], ["proof (prove)\nusing this:\n  gen [^] get_exp gen (a \\<otimes> b) = a \\<otimes> b\n  gen [^] (get_exp gen a + get_exp gen b) = a \\<otimes> b\n\ngoal (1 subgoal):\n 1. gen [^] get_exp gen (a \\<otimes> b) =\n    gen [^] (get_exp gen a + get_exp gen b)", "by simp"], ["proof (state)\nthis:\n  gen [^] get_exp gen (a \\<otimes> b) =\n  gen [^] (get_exp gen a + get_exp gen b)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We now show that all functions from a group generated by 'a' to a group generated by 'b'\nthat map elements from $a^k$ to $b^k$ in the other group are in fact isomorphisms between these two\ngroups.\\<close>"], ["", "lemma (in group) iso_cyclic_groups_generate:\n  assumes \"a \\<in> carrier G\" \"b \\<in> carrier H\" \"group.ord G a = group.ord H b\" \"group H\"\n  shows \"{f. \\<forall>k \\<in> (UNIV::int set). f (a [^] k) = b [^]\\<^bsub>H\\<^esub> k}\n         \\<subseteq> iso (G\\<lparr>carrier := generate G {a}\\<rparr>) (H\\<lparr>carrier := generate H {b}\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {f. \\<forall>k\\<in>UNIV. f (a [^] k) = b [^]\\<^bsub>H\\<^esub> k}\n    \\<subseteq> Group.iso (G\\<lparr>carrier := generate G {a}\\<rparr>)\n                 (H\\<lparr>carrier := generate H {b}\\<rparr>)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {f. \\<forall>k\\<in>UNIV.\n                      f (a [^] k) =\n                      b [^]\\<^bsub>H\\<^esub> k} \\<Longrightarrow>\n       x \\<in> Group.iso (G\\<lparr>carrier := generate G {a}\\<rparr>)\n                (H\\<lparr>carrier := generate H {b}\\<rparr>)", "interpret H: group H"], ["proof (prove)\ngoal (1 subgoal):\n 1. Group.group H", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {f. \\<forall>k\\<in>UNIV.\n                      f (a [^] k) =\n                      b [^]\\<^bsub>H\\<^esub> k} \\<Longrightarrow>\n       x \\<in> Group.iso (G\\<lparr>carrier := generate G {a}\\<rparr>)\n                (H\\<lparr>carrier := generate H {b}\\<rparr>)", "let ?A = \"G\\<lparr>carrier := generate G {a}\\<rparr>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {f. \\<forall>k\\<in>UNIV.\n                      f (a [^] k) =\n                      b [^]\\<^bsub>H\\<^esub> k} \\<Longrightarrow>\n       x \\<in> Group.iso (G\\<lparr>carrier := generate G {a}\\<rparr>)\n                (H\\<lparr>carrier := generate H {b}\\<rparr>)", "let ?B = \"H\\<lparr>carrier := generate H {b}\\<rparr>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {f. \\<forall>k\\<in>UNIV.\n                      f (a [^] k) =\n                      b [^]\\<^bsub>H\\<^esub> k} \\<Longrightarrow>\n       x \\<in> Group.iso (G\\<lparr>carrier := generate G {a}\\<rparr>)\n                (H\\<lparr>carrier := generate H {b}\\<rparr>)", "interpret A: cyclic_group ?A a"], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_And_Cyclic_Groups.cyclic_group\n     (G\\<lparr>carrier := generate G {a}\\<rparr>) a", "by (intro group.cyclic_groupI2; use assms(1) in simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {f. \\<forall>k\\<in>UNIV.\n                      f (a [^] k) =\n                      b [^]\\<^bsub>H\\<^esub> k} \\<Longrightarrow>\n       x \\<in> Group.iso (G\\<lparr>carrier := generate G {a}\\<rparr>)\n                (H\\<lparr>carrier := generate H {b}\\<rparr>)", "interpret B: cyclic_group ?B b"], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_And_Cyclic_Groups.cyclic_group\n     (H\\<lparr>carrier := generate H {b}\\<rparr>) b", "by (intro group.cyclic_groupI2; use assms(2) in simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {f. \\<forall>k\\<in>UNIV.\n                      f (a [^] k) =\n                      b [^]\\<^bsub>H\\<^esub> k} \\<Longrightarrow>\n       x \\<in> Group.iso (G\\<lparr>carrier := generate G {a}\\<rparr>)\n                (H\\<lparr>carrier := generate H {b}\\<rparr>)", "have sA: \"subgroup (generate G {a}) G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subgroup (generate G {a}) G", "by (intro generate_is_subgroup, use assms(1) in simp)"], ["proof (state)\nthis:\n  subgroup (generate G {a}) G\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {f. \\<forall>k\\<in>UNIV.\n                      f (a [^] k) =\n                      b [^]\\<^bsub>H\\<^esub> k} \\<Longrightarrow>\n       x \\<in> Group.iso (G\\<lparr>carrier := generate G {a}\\<rparr>)\n                (H\\<lparr>carrier := generate H {b}\\<rparr>)", "have sB: \"subgroup (generate H {b}) H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subgroup (generate H {b}) H", "by (intro H.generate_is_subgroup, use assms(2) in simp)"], ["proof (state)\nthis:\n  subgroup (generate H {b}) H\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {f. \\<forall>k\\<in>UNIV.\n                      f (a [^] k) =\n                      b [^]\\<^bsub>H\\<^esub> k} \\<Longrightarrow>\n       x \\<in> Group.iso (G\\<lparr>carrier := generate G {a}\\<rparr>)\n                (H\\<lparr>carrier := generate H {b}\\<rparr>)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {f. \\<forall>k\\<in>UNIV.\n                      f (a [^] k) =\n                      b [^]\\<^bsub>H\\<^esub> k} \\<Longrightarrow>\n       x \\<in> Group.iso (G\\<lparr>carrier := generate G {a}\\<rparr>)\n                (H\\<lparr>carrier := generate H {b}\\<rparr>)", "assume x: \"x \\<in> {f. \\<forall>k\\<in>(UNIV::int set). f (a [^] k) = b [^]\\<^bsub>H\\<^esub> k}\""], ["proof (state)\nthis:\n  x \\<in> {f. \\<forall>k\\<in>UNIV. f (a [^] k) = b [^]\\<^bsub>H\\<^esub> k}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {f. \\<forall>k\\<in>UNIV.\n                      f (a [^] k) =\n                      b [^]\\<^bsub>H\\<^esub> k} \\<Longrightarrow>\n       x \\<in> Group.iso (G\\<lparr>carrier := generate G {a}\\<rparr>)\n                (H\\<lparr>carrier := generate H {b}\\<rparr>)", "have hom: \"x \\<in> hom ?A ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> hom (G\\<lparr>carrier := generate G {a}\\<rparr>)\n             (H\\<lparr>carrier := generate H {b}\\<rparr>)", "proof (intro homI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> carrier\n                 (G\\<lparr>carrier :=\n                             generate G {a}\\<rparr>) \\<Longrightarrow>\n       x xa \\<in> carrier (H\\<lparr>carrier := generate H {b}\\<rparr>)\n 2. \\<And>xa y.\n       \\<lbrakk>xa \\<in> carrier\n                          (G\\<lparr>carrier := generate G {a}\\<rparr>);\n        y \\<in> carrier\n                 (G\\<lparr>carrier := generate G {a}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> x (xa \\<otimes>\\<^bsub>G\\<lparr>carrier := generate G {a}\\<rparr>\\<^esub>\n                            y) =\n                         x xa \\<otimes>\\<^bsub>H\\<lparr>carrier := generate H {b}\\<rparr>\\<^esub>\n                         x y", "fix c"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> carrier\n                 (G\\<lparr>carrier :=\n                             generate G {a}\\<rparr>) \\<Longrightarrow>\n       x xa \\<in> carrier (H\\<lparr>carrier := generate H {b}\\<rparr>)\n 2. \\<And>xa y.\n       \\<lbrakk>xa \\<in> carrier\n                          (G\\<lparr>carrier := generate G {a}\\<rparr>);\n        y \\<in> carrier\n                 (G\\<lparr>carrier := generate G {a}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> x (xa \\<otimes>\\<^bsub>G\\<lparr>carrier := generate G {a}\\<rparr>\\<^esub>\n                            y) =\n                         x xa \\<otimes>\\<^bsub>H\\<lparr>carrier := generate H {b}\\<rparr>\\<^esub>\n                         x y", "assume c: \"c \\<in> carrier ?A\""], ["proof (state)\nthis:\n  c \\<in> carrier (G\\<lparr>carrier := generate G {a}\\<rparr>)\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> carrier\n                 (G\\<lparr>carrier :=\n                             generate G {a}\\<rparr>) \\<Longrightarrow>\n       x xa \\<in> carrier (H\\<lparr>carrier := generate H {b}\\<rparr>)\n 2. \\<And>xa y.\n       \\<lbrakk>xa \\<in> carrier\n                          (G\\<lparr>carrier := generate G {a}\\<rparr>);\n        y \\<in> carrier\n                 (G\\<lparr>carrier := generate G {a}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> x (xa \\<otimes>\\<^bsub>G\\<lparr>carrier := generate G {a}\\<rparr>\\<^esub>\n                            y) =\n                         x xa \\<otimes>\\<^bsub>H\\<lparr>carrier := generate H {b}\\<rparr>\\<^esub>\n                         x y", "from A.elem_is_gen_pow[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>n.\n     c = a [^]\\<^bsub>G\\<lparr>carrier := generate G {a}\\<rparr>\\<^esub> n", "obtain k::int where k: \"c = a [^] k\""], ["proof (prove)\nusing this:\n  \\<exists>n.\n     c = a [^]\\<^bsub>G\\<lparr>carrier := generate G {a}\\<rparr>\\<^esub> n\n\ngoal (1 subgoal):\n 1. (\\<And>k. c = a [^] k \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using int_pow_consistent[OF sA generate.incl[of a]]"], ["proof (prove)\nusing this:\n  \\<exists>n.\n     c = a [^]\\<^bsub>G\\<lparr>carrier := generate G {a}\\<rparr>\\<^esub> n\n  a \\<in> {a} \\<Longrightarrow>\n  a [^] ?n =\n  a [^]\\<^bsub>G\\<lparr>carrier := generate G {a}\\<rparr>\\<^esub> ?n\n\ngoal (1 subgoal):\n 1. (\\<And>k. c = a [^] k \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  c = a [^] k\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> carrier\n                 (G\\<lparr>carrier :=\n                             generate G {a}\\<rparr>) \\<Longrightarrow>\n       x xa \\<in> carrier (H\\<lparr>carrier := generate H {b}\\<rparr>)\n 2. \\<And>xa y.\n       \\<lbrakk>xa \\<in> carrier\n                          (G\\<lparr>carrier := generate G {a}\\<rparr>);\n        y \\<in> carrier\n                 (G\\<lparr>carrier := generate G {a}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> x (xa \\<otimes>\\<^bsub>G\\<lparr>carrier := generate G {a}\\<rparr>\\<^esub>\n                            y) =\n                         x xa \\<otimes>\\<^bsub>H\\<lparr>carrier := generate H {b}\\<rparr>\\<^esub>\n                         x y", "with x"], ["proof (chain)\npicking this:\n  x \\<in> {f. \\<forall>k\\<in>UNIV. f (a [^] k) = b [^]\\<^bsub>H\\<^esub> k}\n  c = a [^] k", "have \"x c = b [^]\\<^bsub>H\\<^esub> k\""], ["proof (prove)\nusing this:\n  x \\<in> {f. \\<forall>k\\<in>UNIV. f (a [^] k) = b [^]\\<^bsub>H\\<^esub> k}\n  c = a [^] k\n\ngoal (1 subgoal):\n 1. x c = b [^]\\<^bsub>H\\<^esub> k", "by blast"], ["proof (state)\nthis:\n  x c = b [^]\\<^bsub>H\\<^esub> k\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> carrier\n                 (G\\<lparr>carrier :=\n                             generate G {a}\\<rparr>) \\<Longrightarrow>\n       x xa \\<in> carrier (H\\<lparr>carrier := generate H {b}\\<rparr>)\n 2. \\<And>xa y.\n       \\<lbrakk>xa \\<in> carrier\n                          (G\\<lparr>carrier := generate G {a}\\<rparr>);\n        y \\<in> carrier\n                 (G\\<lparr>carrier := generate G {a}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> x (xa \\<otimes>\\<^bsub>G\\<lparr>carrier := generate G {a}\\<rparr>\\<^esub>\n                            y) =\n                         x xa \\<otimes>\\<^bsub>H\\<lparr>carrier := generate H {b}\\<rparr>\\<^esub>\n                         x y", "thus \"x c \\<in> carrier ?B\""], ["proof (prove)\nusing this:\n  x c = b [^]\\<^bsub>H\\<^esub> k\n\ngoal (1 subgoal):\n 1. x c \\<in> carrier (H\\<lparr>carrier := generate H {b}\\<rparr>)", "using B.int_pow_closed H.int_pow_consistent[OF sB] generate.incl[of b \"{b}\" H]"], ["proof (prove)\nusing this:\n  x c = b [^]\\<^bsub>H\\<^esub> k\n  ?x \\<in> carrier\n            (H\\<lparr>carrier := generate H {b}\\<rparr>) \\<Longrightarrow>\n  ?x [^]\\<^bsub>H\\<lparr>carrier := generate H {b}\\<rparr>\\<^esub> ?i\n  \\<in> carrier (H\\<lparr>carrier := generate H {b}\\<rparr>)\n  ?x \\<in> generate H {b} \\<Longrightarrow>\n  ?x [^]\\<^bsub>H\\<^esub> ?n =\n  ?x [^]\\<^bsub>H\\<lparr>carrier := generate H {b}\\<rparr>\\<^esub> ?n\n  b \\<in> {b} \\<Longrightarrow> b \\<in> generate H {b}\n\ngoal (1 subgoal):\n 1. x c \\<in> carrier (H\\<lparr>carrier := generate H {b}\\<rparr>)", "by simp"], ["proof (state)\nthis:\n  x c \\<in> carrier (H\\<lparr>carrier := generate H {b}\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> carrier\n                          (G\\<lparr>carrier := generate G {a}\\<rparr>);\n        y \\<in> carrier\n                 (G\\<lparr>carrier := generate G {a}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> x (xa \\<otimes>\\<^bsub>G\\<lparr>carrier := generate G {a}\\<rparr>\\<^esub>\n                            y) =\n                         x xa \\<otimes>\\<^bsub>H\\<lparr>carrier := generate H {b}\\<rparr>\\<^esub>\n                         x y", "fix d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> carrier\n                          (G\\<lparr>carrier := generate G {a}\\<rparr>);\n        y \\<in> carrier\n                 (G\\<lparr>carrier := generate G {a}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> x (xa \\<otimes>\\<^bsub>G\\<lparr>carrier := generate G {a}\\<rparr>\\<^esub>\n                            y) =\n                         x xa \\<otimes>\\<^bsub>H\\<lparr>carrier := generate H {b}\\<rparr>\\<^esub>\n                         x y", "assume d: \"d \\<in> carrier ?A\""], ["proof (state)\nthis:\n  d \\<in> carrier (G\\<lparr>carrier := generate G {a}\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> carrier\n                          (G\\<lparr>carrier := generate G {a}\\<rparr>);\n        y \\<in> carrier\n                 (G\\<lparr>carrier := generate G {a}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> x (xa \\<otimes>\\<^bsub>G\\<lparr>carrier := generate G {a}\\<rparr>\\<^esub>\n                            y) =\n                         x xa \\<otimes>\\<^bsub>H\\<lparr>carrier := generate H {b}\\<rparr>\\<^esub>\n                         x y", "from A.elem_is_gen_pow[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>n.\n     d = a [^]\\<^bsub>G\\<lparr>carrier := generate G {a}\\<rparr>\\<^esub> n", "obtain l::int where l: \"d = a [^] l\""], ["proof (prove)\nusing this:\n  \\<exists>n.\n     d = a [^]\\<^bsub>G\\<lparr>carrier := generate G {a}\\<rparr>\\<^esub> n\n\ngoal (1 subgoal):\n 1. (\\<And>l. d = a [^] l \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using int_pow_consistent[OF sA generate.incl[of a]]"], ["proof (prove)\nusing this:\n  \\<exists>n.\n     d = a [^]\\<^bsub>G\\<lparr>carrier := generate G {a}\\<rparr>\\<^esub> n\n  a \\<in> {a} \\<Longrightarrow>\n  a [^] ?n =\n  a [^]\\<^bsub>G\\<lparr>carrier := generate G {a}\\<rparr>\\<^esub> ?n\n\ngoal (1 subgoal):\n 1. (\\<And>l. d = a [^] l \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  d = a [^] l\n\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> carrier\n                          (G\\<lparr>carrier := generate G {a}\\<rparr>);\n        y \\<in> carrier\n                 (G\\<lparr>carrier := generate G {a}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> x (xa \\<otimes>\\<^bsub>G\\<lparr>carrier := generate G {a}\\<rparr>\\<^esub>\n                            y) =\n                         x xa \\<otimes>\\<^bsub>H\\<lparr>carrier := generate H {b}\\<rparr>\\<^esub>\n                         x y", "with k"], ["proof (chain)\npicking this:\n  c = a [^] k\n  d = a [^] l", "have \"c \\<otimes> d = a [^] (k + l)\""], ["proof (prove)\nusing this:\n  c = a [^] k\n  d = a [^] l\n\ngoal (1 subgoal):\n 1. c \\<otimes> d = a [^] (k + l)", "by (simp add: int_pow_mult assms(1))"], ["proof (state)\nthis:\n  c \\<otimes> d = a [^] (k + l)\n\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> carrier\n                          (G\\<lparr>carrier := generate G {a}\\<rparr>);\n        y \\<in> carrier\n                 (G\\<lparr>carrier := generate G {a}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> x (xa \\<otimes>\\<^bsub>G\\<lparr>carrier := generate G {a}\\<rparr>\\<^esub>\n                            y) =\n                         x xa \\<otimes>\\<^bsub>H\\<lparr>carrier := generate H {b}\\<rparr>\\<^esub>\n                         x y", "with x"], ["proof (chain)\npicking this:\n  x \\<in> {f. \\<forall>k\\<in>UNIV. f (a [^] k) = b [^]\\<^bsub>H\\<^esub> k}\n  c \\<otimes> d = a [^] (k + l)", "have \"x (c \\<otimes>\\<^bsub>?A\\<^esub> d) = b [^]\\<^bsub>H\\<^esub> (k + l)\""], ["proof (prove)\nusing this:\n  x \\<in> {f. \\<forall>k\\<in>UNIV. f (a [^] k) = b [^]\\<^bsub>H\\<^esub> k}\n  c \\<otimes> d = a [^] (k + l)\n\ngoal (1 subgoal):\n 1. x (c \\<otimes>\\<^bsub>G\\<lparr>carrier := generate G {a}\\<rparr>\\<^esub>\n       d) =\n    b [^]\\<^bsub>H\\<^esub> (k + l)", "by simp"], ["proof (state)\nthis:\n  x (c \\<otimes>\\<^bsub>G\\<lparr>carrier := generate G {a}\\<rparr>\\<^esub>\n     d) =\n  b [^]\\<^bsub>H\\<^esub> (k + l)\n\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> carrier\n                          (G\\<lparr>carrier := generate G {a}\\<rparr>);\n        y \\<in> carrier\n                 (G\\<lparr>carrier := generate G {a}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> x (xa \\<otimes>\\<^bsub>G\\<lparr>carrier := generate G {a}\\<rparr>\\<^esub>\n                            y) =\n                         x xa \\<otimes>\\<^bsub>H\\<lparr>carrier := generate H {b}\\<rparr>\\<^esub>\n                         x y", "also"], ["proof (state)\nthis:\n  x (c \\<otimes>\\<^bsub>G\\<lparr>carrier := generate G {a}\\<rparr>\\<^esub>\n     d) =\n  b [^]\\<^bsub>H\\<^esub> (k + l)\n\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> carrier\n                          (G\\<lparr>carrier := generate G {a}\\<rparr>);\n        y \\<in> carrier\n                 (G\\<lparr>carrier := generate G {a}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> x (xa \\<otimes>\\<^bsub>G\\<lparr>carrier := generate G {a}\\<rparr>\\<^esub>\n                            y) =\n                         x xa \\<otimes>\\<^bsub>H\\<lparr>carrier := generate H {b}\\<rparr>\\<^esub>\n                         x y", "have \"\\<dots> = b [^]\\<^bsub>H\\<^esub> k \\<otimes>\\<^bsub>H\\<^esub> b [^]\\<^bsub>H\\<^esub> l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b [^]\\<^bsub>H\\<^esub> (k + l) =\n    b [^]\\<^bsub>H\\<^esub> k \\<otimes>\\<^bsub>H\\<^esub>\n    b [^]\\<^bsub>H\\<^esub> l", "by (simp add: H.int_pow_mult assms(2))"], ["proof (state)\nthis:\n  b [^]\\<^bsub>H\\<^esub> (k + l) =\n  b [^]\\<^bsub>H\\<^esub> k \\<otimes>\\<^bsub>H\\<^esub>\n  b [^]\\<^bsub>H\\<^esub> l\n\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> carrier\n                          (G\\<lparr>carrier := generate G {a}\\<rparr>);\n        y \\<in> carrier\n                 (G\\<lparr>carrier := generate G {a}\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> x (xa \\<otimes>\\<^bsub>G\\<lparr>carrier := generate G {a}\\<rparr>\\<^esub>\n                            y) =\n                         x xa \\<otimes>\\<^bsub>H\\<lparr>carrier := generate H {b}\\<rparr>\\<^esub>\n                         x y", "finally"], ["proof (chain)\npicking this:\n  x (c \\<otimes>\\<^bsub>G\\<lparr>carrier := generate G {a}\\<rparr>\\<^esub>\n     d) =\n  b [^]\\<^bsub>H\\<^esub> k \\<otimes>\\<^bsub>H\\<^esub>\n  b [^]\\<^bsub>H\\<^esub> l", "show \"x (c \\<otimes>\\<^bsub>?A\\<^esub> d) = x c \\<otimes>\\<^bsub>?B\\<^esub> x d\""], ["proof (prove)\nusing this:\n  x (c \\<otimes>\\<^bsub>G\\<lparr>carrier := generate G {a}\\<rparr>\\<^esub>\n     d) =\n  b [^]\\<^bsub>H\\<^esub> k \\<otimes>\\<^bsub>H\\<^esub>\n  b [^]\\<^bsub>H\\<^esub> l\n\ngoal (1 subgoal):\n 1. x (c \\<otimes>\\<^bsub>G\\<lparr>carrier := generate G {a}\\<rparr>\\<^esub>\n       d) =\n    x c \\<otimes>\\<^bsub>H\\<lparr>carrier := generate H {b}\\<rparr>\\<^esub>\n    x d", "using x k l"], ["proof (prove)\nusing this:\n  x (c \\<otimes>\\<^bsub>G\\<lparr>carrier := generate G {a}\\<rparr>\\<^esub>\n     d) =\n  b [^]\\<^bsub>H\\<^esub> k \\<otimes>\\<^bsub>H\\<^esub>\n  b [^]\\<^bsub>H\\<^esub> l\n  x \\<in> {f. \\<forall>k\\<in>UNIV. f (a [^] k) = b [^]\\<^bsub>H\\<^esub> k}\n  c = a [^] k\n  d = a [^] l\n\ngoal (1 subgoal):\n 1. x (c \\<otimes>\\<^bsub>G\\<lparr>carrier := generate G {a}\\<rparr>\\<^esub>\n       d) =\n    x c \\<otimes>\\<^bsub>H\\<lparr>carrier := generate H {b}\\<rparr>\\<^esub>\n    x d", "by simp"], ["proof (state)\nthis:\n  x (c \\<otimes>\\<^bsub>G\\<lparr>carrier := generate G {a}\\<rparr>\\<^esub>\n     d) =\n  x c \\<otimes>\\<^bsub>H\\<lparr>carrier := generate H {b}\\<rparr>\\<^esub>\n  x d\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> hom (G\\<lparr>carrier := generate G {a}\\<rparr>)\n           (H\\<lparr>carrier := generate H {b}\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {f. \\<forall>k\\<in>UNIV.\n                      f (a [^] k) =\n                      b [^]\\<^bsub>H\\<^esub> k} \\<Longrightarrow>\n       x \\<in> Group.iso (G\\<lparr>carrier := generate G {a}\\<rparr>)\n                (H\\<lparr>carrier := generate H {b}\\<rparr>)", "then"], ["proof (chain)\npicking this:\n  x \\<in> hom (G\\<lparr>carrier := generate G {a}\\<rparr>)\n           (H\\<lparr>carrier := generate H {b}\\<rparr>)", "interpret xgh: group_hom ?A ?B x"], ["proof (prove)\nusing this:\n  x \\<in> hom (G\\<lparr>carrier := generate G {a}\\<rparr>)\n           (H\\<lparr>carrier := generate H {b}\\<rparr>)\n\ngoal (1 subgoal):\n 1. group_hom (G\\<lparr>carrier := generate G {a}\\<rparr>)\n     (H\\<lparr>carrier := generate H {b}\\<rparr>) x", "unfolding group_hom_def group_hom_axioms_def"], ["proof (prove)\nusing this:\n  x \\<in> hom (G\\<lparr>carrier := generate G {a}\\<rparr>)\n           (H\\<lparr>carrier := generate H {b}\\<rparr>)\n\ngoal (1 subgoal):\n 1. Group.group (G\\<lparr>carrier := generate G {a}\\<rparr>) \\<and>\n    Group.group (H\\<lparr>carrier := generate H {b}\\<rparr>) \\<and>\n    x \\<in> hom (G\\<lparr>carrier := generate G {a}\\<rparr>)\n             (H\\<lparr>carrier := generate H {b}\\<rparr>)", "by blast"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {f. \\<forall>k\\<in>UNIV.\n                      f (a [^] k) =\n                      b [^]\\<^bsub>H\\<^esub> k} \\<Longrightarrow>\n       x \\<in> Group.iso (G\\<lparr>carrier := generate G {a}\\<rparr>)\n                (H\\<lparr>carrier := generate H {b}\\<rparr>)", "have \"kernel ?A ?B x = {\\<one>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kernel (G\\<lparr>carrier := generate G {a}\\<rparr>)\n     (H\\<lparr>carrier := generate H {b}\\<rparr>) x =\n    {\\<one>}", "proof(intro equalityI)"], ["proof (state)\ngoal (2 subgoals):\n 1. kernel (G\\<lparr>carrier := generate G {a}\\<rparr>)\n     (H\\<lparr>carrier := generate H {b}\\<rparr>) x\n    \\<subseteq> {\\<one>}\n 2. {\\<one>}\n    \\<subseteq> kernel (G\\<lparr>carrier := generate G {a}\\<rparr>)\n                 (H\\<lparr>carrier := generate H {b}\\<rparr>) x", "show \"{\\<one>} \\<subseteq> kernel ?A ?B x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<one>}\n    \\<subseteq> kernel (G\\<lparr>carrier := generate G {a}\\<rparr>)\n                 (H\\<lparr>carrier := generate H {b}\\<rparr>) x", "using xgh.one_in_kernel"], ["proof (prove)\nusing this:\n  \\<one>\\<^bsub>G\\<lparr>carrier := generate G {a}\\<rparr>\\<^esub>\n  \\<in> kernel (G\\<lparr>carrier := generate G {a}\\<rparr>)\n         (H\\<lparr>carrier := generate H {b}\\<rparr>) x\n\ngoal (1 subgoal):\n 1. {\\<one>}\n    \\<subseteq> kernel (G\\<lparr>carrier := generate G {a}\\<rparr>)\n                 (H\\<lparr>carrier := generate H {b}\\<rparr>) x", "by auto"], ["proof (state)\nthis:\n  {\\<one>}\n  \\<subseteq> kernel (G\\<lparr>carrier := generate G {a}\\<rparr>)\n               (H\\<lparr>carrier := generate H {b}\\<rparr>) x\n\ngoal (1 subgoal):\n 1. kernel (G\\<lparr>carrier := generate G {a}\\<rparr>)\n     (H\\<lparr>carrier := generate H {b}\\<rparr>) x\n    \\<subseteq> {\\<one>}", "have \"c = \\<one>\" if \"c \\<in> kernel ?A ?B x\" for c"], ["proof (prove)\ngoal (1 subgoal):\n 1. c = \\<one>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c = \\<one>", "from that"], ["proof (chain)\npicking this:\n  c \\<in> kernel (G\\<lparr>carrier := generate G {a}\\<rparr>)\n           (H\\<lparr>carrier := generate H {b}\\<rparr>) x", "have c: \"c \\<in> carrier ?A\""], ["proof (prove)\nusing this:\n  c \\<in> kernel (G\\<lparr>carrier := generate G {a}\\<rparr>)\n           (H\\<lparr>carrier := generate H {b}\\<rparr>) x\n\ngoal (1 subgoal):\n 1. c \\<in> carrier (G\\<lparr>carrier := generate G {a}\\<rparr>)", "unfolding kernel_def"], ["proof (prove)\nusing this:\n  c \\<in> {xa \\<in> carrier (G\\<lparr>carrier := generate G {a}\\<rparr>).\n           x xa =\n           \\<one>\\<^bsub>H\\<lparr>carrier := generate H {b}\\<rparr>\\<^esub>}\n\ngoal (1 subgoal):\n 1. c \\<in> carrier (G\\<lparr>carrier := generate G {a}\\<rparr>)", "by blast"], ["proof (state)\nthis:\n  c \\<in> carrier (G\\<lparr>carrier := generate G {a}\\<rparr>)\n\ngoal (1 subgoal):\n 1. c = \\<one>", "from A.elem_is_gen_pow[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>n.\n     c = a [^]\\<^bsub>G\\<lparr>carrier := generate G {a}\\<rparr>\\<^esub> n", "obtain k::int where k: \"c = a [^] k\""], ["proof (prove)\nusing this:\n  \\<exists>n.\n     c = a [^]\\<^bsub>G\\<lparr>carrier := generate G {a}\\<rparr>\\<^esub> n\n\ngoal (1 subgoal):\n 1. (\\<And>k. c = a [^] k \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using int_pow_consistent[OF sA generate.incl[of a]]"], ["proof (prove)\nusing this:\n  \\<exists>n.\n     c = a [^]\\<^bsub>G\\<lparr>carrier := generate G {a}\\<rparr>\\<^esub> n\n  a \\<in> {a} \\<Longrightarrow>\n  a [^] ?n =\n  a [^]\\<^bsub>G\\<lparr>carrier := generate G {a}\\<rparr>\\<^esub> ?n\n\ngoal (1 subgoal):\n 1. (\\<And>k. c = a [^] k \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  c = a [^] k\n\ngoal (1 subgoal):\n 1. c = \\<one>", "moreover"], ["proof (state)\nthis:\n  c = a [^] k\n\ngoal (1 subgoal):\n 1. c = \\<one>", "have \"x c = \\<one>\\<^bsub>H\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x c = \\<one>\\<^bsub>H\\<^esub>", "using that x"], ["proof (prove)\nusing this:\n  c \\<in> kernel (G\\<lparr>carrier := generate G {a}\\<rparr>)\n           (H\\<lparr>carrier := generate H {b}\\<rparr>) x\n  x \\<in> {f. \\<forall>k\\<in>UNIV. f (a [^] k) = b [^]\\<^bsub>H\\<^esub> k}\n\ngoal (1 subgoal):\n 1. x c = \\<one>\\<^bsub>H\\<^esub>", "unfolding kernel_def"], ["proof (prove)\nusing this:\n  c \\<in> {xa \\<in> carrier (G\\<lparr>carrier := generate G {a}\\<rparr>).\n           x xa =\n           \\<one>\\<^bsub>H\\<lparr>carrier := generate H {b}\\<rparr>\\<^esub>}\n  x \\<in> {f. \\<forall>k\\<in>UNIV. f (a [^] k) = b [^]\\<^bsub>H\\<^esub> k}\n\ngoal (1 subgoal):\n 1. x c = \\<one>\\<^bsub>H\\<^esub>", "by auto"], ["proof (state)\nthis:\n  x c = \\<one>\\<^bsub>H\\<^esub>\n\ngoal (1 subgoal):\n 1. c = \\<one>", "ultimately"], ["proof (chain)\npicking this:\n  c = a [^] k\n  x c = \\<one>\\<^bsub>H\\<^esub>", "have \"\\<one>\\<^bsub>H\\<^esub> = b [^]\\<^bsub>H\\<^esub> k\""], ["proof (prove)\nusing this:\n  c = a [^] k\n  x c = \\<one>\\<^bsub>H\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<one>\\<^bsub>H\\<^esub> = b [^]\\<^bsub>H\\<^esub> k", "using x"], ["proof (prove)\nusing this:\n  c = a [^] k\n  x c = \\<one>\\<^bsub>H\\<^esub>\n  x \\<in> {f. \\<forall>k\\<in>UNIV. f (a [^] k) = b [^]\\<^bsub>H\\<^esub> k}\n\ngoal (1 subgoal):\n 1. \\<one>\\<^bsub>H\\<^esub> = b [^]\\<^bsub>H\\<^esub> k", "by simp"], ["proof (state)\nthis:\n  \\<one>\\<^bsub>H\\<^esub> = b [^]\\<^bsub>H\\<^esub> k\n\ngoal (1 subgoal):\n 1. c = \\<one>", "with assms(3)"], ["proof (chain)\npicking this:\n  ord a = H.ord b\n  \\<one>\\<^bsub>H\\<^esub> = b [^]\\<^bsub>H\\<^esub> k", "have \"a [^] k = \\<one>\""], ["proof (prove)\nusing this:\n  ord a = H.ord b\n  \\<one>\\<^bsub>H\\<^esub> = b [^]\\<^bsub>H\\<^esub> k\n\ngoal (1 subgoal):\n 1. a [^] k = \\<one>", "using int_pow_eq_id[OF assms(1), of k] H.int_pow_eq_id[OF assms(2), of k]"], ["proof (prove)\nusing this:\n  ord a = H.ord b\n  \\<one>\\<^bsub>H\\<^esub> = b [^]\\<^bsub>H\\<^esub> k\n  (a [^] k = \\<one>) = (int (ord a) dvd k)\n  (b [^]\\<^bsub>H\\<^esub> k = \\<one>\\<^bsub>H\\<^esub>) =\n  (int (H.ord b) dvd k)\n\ngoal (1 subgoal):\n 1. a [^] k = \\<one>", "by simp"], ["proof (state)\nthis:\n  a [^] k = \\<one>\n\ngoal (1 subgoal):\n 1. c = \\<one>", "thus \"c = \\<one>\""], ["proof (prove)\nusing this:\n  a [^] k = \\<one>\n\ngoal (1 subgoal):\n 1. c = \\<one>", "using k"], ["proof (prove)\nusing this:\n  a [^] k = \\<one>\n  c = a [^] k\n\ngoal (1 subgoal):\n 1. c = \\<one>", "by blast"], ["proof (state)\nthis:\n  c = \\<one>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?c \\<in> kernel (G\\<lparr>carrier := generate G {a}\\<rparr>)\n            (H\\<lparr>carrier := generate H {b}\\<rparr>) x \\<Longrightarrow>\n  ?c = \\<one>\n\ngoal (1 subgoal):\n 1. kernel (G\\<lparr>carrier := generate G {a}\\<rparr>)\n     (H\\<lparr>carrier := generate H {b}\\<rparr>) x\n    \\<subseteq> {\\<one>}", "thus \"kernel ?A ?B x \\<subseteq> {\\<one>}\""], ["proof (prove)\nusing this:\n  ?c \\<in> kernel (G\\<lparr>carrier := generate G {a}\\<rparr>)\n            (H\\<lparr>carrier := generate H {b}\\<rparr>) x \\<Longrightarrow>\n  ?c = \\<one>\n\ngoal (1 subgoal):\n 1. kernel (G\\<lparr>carrier := generate G {a}\\<rparr>)\n     (H\\<lparr>carrier := generate H {b}\\<rparr>) x\n    \\<subseteq> {\\<one>}", "by blast"], ["proof (state)\nthis:\n  kernel (G\\<lparr>carrier := generate G {a}\\<rparr>)\n   (H\\<lparr>carrier := generate H {b}\\<rparr>) x\n  \\<subseteq> {\\<one>}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  kernel (G\\<lparr>carrier := generate G {a}\\<rparr>)\n   (H\\<lparr>carrier := generate H {b}\\<rparr>) x =\n  {\\<one>}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {f. \\<forall>k\\<in>UNIV.\n                      f (a [^] k) =\n                      b [^]\\<^bsub>H\\<^esub> k} \\<Longrightarrow>\n       x \\<in> Group.iso (G\\<lparr>carrier := generate G {a}\\<rparr>)\n                (H\\<lparr>carrier := generate H {b}\\<rparr>)", "moreover"], ["proof (state)\nthis:\n  kernel (G\\<lparr>carrier := generate G {a}\\<rparr>)\n   (H\\<lparr>carrier := generate H {b}\\<rparr>) x =\n  {\\<one>}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {f. \\<forall>k\\<in>UNIV.\n                      f (a [^] k) =\n                      b [^]\\<^bsub>H\\<^esub> k} \\<Longrightarrow>\n       x \\<in> Group.iso (G\\<lparr>carrier := generate G {a}\\<rparr>)\n                (H\\<lparr>carrier := generate H {b}\\<rparr>)", "have \"carrier ?B \\<subseteq> x ` carrier ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. carrier (H\\<lparr>carrier := generate H {b}\\<rparr>)\n    \\<subseteq> x ` carrier (G\\<lparr>carrier := generate G {a}\\<rparr>)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> carrier\n                 (H\\<lparr>carrier :=\n                             generate H {b}\\<rparr>) \\<Longrightarrow>\n       xa \\<in> x ` carrier (G\\<lparr>carrier := generate G {a}\\<rparr>)", "fix c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> carrier\n                 (H\\<lparr>carrier :=\n                             generate H {b}\\<rparr>) \\<Longrightarrow>\n       xa \\<in> x ` carrier (G\\<lparr>carrier := generate G {a}\\<rparr>)", "assume c: \"c \\<in> carrier ?B\""], ["proof (state)\nthis:\n  c \\<in> carrier (H\\<lparr>carrier := generate H {b}\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> carrier\n                 (H\\<lparr>carrier :=\n                             generate H {b}\\<rparr>) \\<Longrightarrow>\n       xa \\<in> x ` carrier (G\\<lparr>carrier := generate G {a}\\<rparr>)", "from B.elem_is_gen_pow[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>n.\n     c = b [^]\\<^bsub>H\\<lparr>carrier := generate H {b}\\<rparr>\\<^esub> n", "obtain k::int where k: \"c = b [^]\\<^bsub>H\\<^esub> k\""], ["proof (prove)\nusing this:\n  \\<exists>n.\n     c = b [^]\\<^bsub>H\\<lparr>carrier := generate H {b}\\<rparr>\\<^esub> n\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        c = b [^]\\<^bsub>H\\<^esub> k \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using H.int_pow_consistent[OF sB generate.incl[of b]]"], ["proof (prove)\nusing this:\n  \\<exists>n.\n     c = b [^]\\<^bsub>H\\<lparr>carrier := generate H {b}\\<rparr>\\<^esub> n\n  b \\<in> {b} \\<Longrightarrow>\n  b [^]\\<^bsub>H\\<^esub> ?n =\n  b [^]\\<^bsub>H\\<lparr>carrier := generate H {b}\\<rparr>\\<^esub> ?n\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        c = b [^]\\<^bsub>H\\<^esub> k \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c = b [^]\\<^bsub>H\\<^esub> k\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> carrier\n                 (H\\<lparr>carrier :=\n                             generate H {b}\\<rparr>) \\<Longrightarrow>\n       xa \\<in> x ` carrier (G\\<lparr>carrier := generate G {a}\\<rparr>)", "then"], ["proof (chain)\npicking this:\n  c = b [^]\\<^bsub>H\\<^esub> k", "have \"x (a [^] k) = c\""], ["proof (prove)\nusing this:\n  c = b [^]\\<^bsub>H\\<^esub> k\n\ngoal (1 subgoal):\n 1. x (a [^] k) = c", "using x"], ["proof (prove)\nusing this:\n  c = b [^]\\<^bsub>H\\<^esub> k\n  x \\<in> {f. \\<forall>k\\<in>UNIV. f (a [^] k) = b [^]\\<^bsub>H\\<^esub> k}\n\ngoal (1 subgoal):\n 1. x (a [^] k) = c", "by blast"], ["proof (state)\nthis:\n  x (a [^] k) = c\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> carrier\n                 (H\\<lparr>carrier :=\n                             generate H {b}\\<rparr>) \\<Longrightarrow>\n       xa \\<in> x ` carrier (G\\<lparr>carrier := generate G {a}\\<rparr>)", "moreover"], ["proof (state)\nthis:\n  x (a [^] k) = c\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> carrier\n                 (H\\<lparr>carrier :=\n                             generate H {b}\\<rparr>) \\<Longrightarrow>\n       xa \\<in> x ` carrier (G\\<lparr>carrier := generate G {a}\\<rparr>)", "have \"a [^] k \\<in> carrier ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a [^] k \\<in> carrier (G\\<lparr>carrier := generate G {a}\\<rparr>)", "using int_pow_consistent[OF sA generate.incl[of a]] A.int_pow_closed generate.incl[of a]"], ["proof (prove)\nusing this:\n  a \\<in> {a} \\<Longrightarrow>\n  a [^] ?n =\n  a [^]\\<^bsub>G\\<lparr>carrier := generate G {a}\\<rparr>\\<^esub> ?n\n  ?x \\<in> carrier\n            (G\\<lparr>carrier := generate G {a}\\<rparr>) \\<Longrightarrow>\n  ?x [^]\\<^bsub>G\\<lparr>carrier := generate G {a}\\<rparr>\\<^esub> ?i\n  \\<in> carrier (G\\<lparr>carrier := generate G {a}\\<rparr>)\n  a \\<in> ?H \\<Longrightarrow> a \\<in> generate ?G ?H\n\ngoal (1 subgoal):\n 1. a [^] k \\<in> carrier (G\\<lparr>carrier := generate G {a}\\<rparr>)", "by fastforce"], ["proof (state)\nthis:\n  a [^] k \\<in> carrier (G\\<lparr>carrier := generate G {a}\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> carrier\n                 (H\\<lparr>carrier :=\n                             generate H {b}\\<rparr>) \\<Longrightarrow>\n       xa \\<in> x ` carrier (G\\<lparr>carrier := generate G {a}\\<rparr>)", "ultimately"], ["proof (chain)\npicking this:\n  x (a [^] k) = c\n  a [^] k \\<in> carrier (G\\<lparr>carrier := generate G {a}\\<rparr>)", "show \"c \\<in> x ` carrier ?A\""], ["proof (prove)\nusing this:\n  x (a [^] k) = c\n  a [^] k \\<in> carrier (G\\<lparr>carrier := generate G {a}\\<rparr>)\n\ngoal (1 subgoal):\n 1. c \\<in> x ` carrier (G\\<lparr>carrier := generate G {a}\\<rparr>)", "by blast"], ["proof (state)\nthis:\n  c \\<in> x ` carrier (G\\<lparr>carrier := generate G {a}\\<rparr>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  carrier (H\\<lparr>carrier := generate H {b}\\<rparr>)\n  \\<subseteq> x ` carrier (G\\<lparr>carrier := generate G {a}\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {f. \\<forall>k\\<in>UNIV.\n                      f (a [^] k) =\n                      b [^]\\<^bsub>H\\<^esub> k} \\<Longrightarrow>\n       x \\<in> Group.iso (G\\<lparr>carrier := generate G {a}\\<rparr>)\n                (H\\<lparr>carrier := generate H {b}\\<rparr>)", "ultimately"], ["proof (chain)\npicking this:\n  kernel (G\\<lparr>carrier := generate G {a}\\<rparr>)\n   (H\\<lparr>carrier := generate H {b}\\<rparr>) x =\n  {\\<one>}\n  carrier (H\\<lparr>carrier := generate H {b}\\<rparr>)\n  \\<subseteq> x ` carrier (G\\<lparr>carrier := generate G {a}\\<rparr>)", "show \"x \\<in> iso ?A ?B\""], ["proof (prove)\nusing this:\n  kernel (G\\<lparr>carrier := generate G {a}\\<rparr>)\n   (H\\<lparr>carrier := generate H {b}\\<rparr>) x =\n  {\\<one>}\n  carrier (H\\<lparr>carrier := generate H {b}\\<rparr>)\n  \\<subseteq> x ` carrier (G\\<lparr>carrier := generate G {a}\\<rparr>)\n\ngoal (1 subgoal):\n 1. x \\<in> Group.iso (G\\<lparr>carrier := generate G {a}\\<rparr>)\n             (H\\<lparr>carrier := generate H {b}\\<rparr>)", "using hom xgh.iso_iff"], ["proof (prove)\nusing this:\n  kernel (G\\<lparr>carrier := generate G {a}\\<rparr>)\n   (H\\<lparr>carrier := generate H {b}\\<rparr>) x =\n  {\\<one>}\n  carrier (H\\<lparr>carrier := generate H {b}\\<rparr>)\n  \\<subseteq> x ` carrier (G\\<lparr>carrier := generate G {a}\\<rparr>)\n  x \\<in> hom (G\\<lparr>carrier := generate G {a}\\<rparr>)\n           (H\\<lparr>carrier := generate H {b}\\<rparr>)\n  (x \\<in> Group.iso (G\\<lparr>carrier := generate G {a}\\<rparr>)\n            (H\\<lparr>carrier := generate H {b}\\<rparr>)) =\n  (carrier (H\\<lparr>carrier := generate H {b}\\<rparr>)\n   \\<subseteq> x `\n               carrier (G\\<lparr>carrier := generate G {a}\\<rparr>) \\<and>\n   (\\<forall>xa\\<in>carrier (G\\<lparr>carrier := generate G {a}\\<rparr>).\n       x xa =\n       \\<one>\\<^bsub>H\\<lparr>carrier := generate H {b}\\<rparr>\\<^esub> \\<longrightarrow>\n       xa =\n       \\<one>\\<^bsub>G\\<lparr>carrier := generate G {a}\\<rparr>\\<^esub>))\n\ngoal (1 subgoal):\n 1. x \\<in> Group.iso (G\\<lparr>carrier := generate G {a}\\<rparr>)\n             (H\\<lparr>carrier := generate H {b}\\<rparr>)", "unfolding kernel_def"], ["proof (prove)\nusing this:\n  {xa \\<in> carrier (G\\<lparr>carrier := generate G {a}\\<rparr>).\n   x xa =\n   \\<one>\\<^bsub>H\\<lparr>carrier := generate H {b}\\<rparr>\\<^esub>} =\n  {\\<one>}\n  carrier (H\\<lparr>carrier := generate H {b}\\<rparr>)\n  \\<subseteq> x ` carrier (G\\<lparr>carrier := generate G {a}\\<rparr>)\n  x \\<in> hom (G\\<lparr>carrier := generate G {a}\\<rparr>)\n           (H\\<lparr>carrier := generate H {b}\\<rparr>)\n  (x \\<in> Group.iso (G\\<lparr>carrier := generate G {a}\\<rparr>)\n            (H\\<lparr>carrier := generate H {b}\\<rparr>)) =\n  (carrier (H\\<lparr>carrier := generate H {b}\\<rparr>)\n   \\<subseteq> x `\n               carrier (G\\<lparr>carrier := generate G {a}\\<rparr>) \\<and>\n   (\\<forall>xa\\<in>carrier (G\\<lparr>carrier := generate G {a}\\<rparr>).\n       x xa =\n       \\<one>\\<^bsub>H\\<lparr>carrier := generate H {b}\\<rparr>\\<^esub> \\<longrightarrow>\n       xa =\n       \\<one>\\<^bsub>G\\<lparr>carrier := generate G {a}\\<rparr>\\<^esub>))\n\ngoal (1 subgoal):\n 1. x \\<in> Group.iso (G\\<lparr>carrier := generate G {a}\\<rparr>)\n             (H\\<lparr>carrier := generate H {b}\\<rparr>)", "by auto"], ["proof (state)\nthis:\n  x \\<in> Group.iso (G\\<lparr>carrier := generate G {a}\\<rparr>)\n           (H\\<lparr>carrier := generate H {b}\\<rparr>)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>This is then used to derive the isomorphism of two cyclic groups of the same order as a\ndirect consequence.\\<close>"], ["", "lemma (in cyclic_group) iso_cyclic_groups_same_order:\n  assumes \"cyclic_group H h\" \"order G = order H\"\n  shows \"G \\<cong> H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<cong> H", "proof(intro is_isoI)"], ["proof (state)\ngoal (1 subgoal):\n 1. ?h \\<in> Group.iso G H", "interpret H: cyclic_group H h"], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_And_Cyclic_Groups.cyclic_group H h", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. ?h \\<in> Group.iso G H", "define f where \"f = (\\<lambda>a. h [^]\\<^bsub>H\\<^esub> get_exp gen a)\""], ["proof (state)\nthis:\n  f = (\\<lambda>a. h [^]\\<^bsub>H\\<^esub> get_exp gen a)\n\ngoal (1 subgoal):\n 1. ?h \\<in> Group.iso G H", "from assms(2)"], ["proof (chain)\npicking this:\n  order G = order H", "have o: \"ord gen = H.ord h\""], ["proof (prove)\nusing this:\n  order G = order H\n\ngoal (1 subgoal):\n 1. ord gen = H.ord h", "using ord_gen_is_group_order H.ord_gen_is_group_order"], ["proof (prove)\nusing this:\n  order G = order H\n  ord gen = order G\n  H.ord h = order H\n\ngoal (1 subgoal):\n 1. ord gen = H.ord h", "by simp"], ["proof (state)\nthis:\n  ord gen = H.ord h\n\ngoal (1 subgoal):\n 1. ?h \\<in> Group.iso G H", "have \"\\<forall>k \\<in> (UNIV::int set). f (gen [^] k) = h [^]\\<^bsub>H\\<^esub> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k\\<in>UNIV. f (gen [^] k) = h [^]\\<^bsub>H\\<^esub> k", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in> UNIV \\<Longrightarrow>\n       f (gen [^] k) = h [^]\\<^bsub>H\\<^esub> k", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in> UNIV \\<Longrightarrow>\n       f (gen [^] k) = h [^]\\<^bsub>H\\<^esub> k", "assume k: \"k \\<in> (UNIV::int set)\""], ["proof (state)\nthis:\n  k \\<in> UNIV\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in> UNIV \\<Longrightarrow>\n       f (gen [^] k) = h [^]\\<^bsub>H\\<^esub> k", "have \"gen [^] k = gen [^] (SOME x::int. gen [^] k = gen [^] x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen [^] k = gen [^] (SOME x. gen [^] k = gen [^] x)", "by(intro someI_ex[of \"\\<lambda>x::int. gen [^] k = gen [^] x\"]; blast)"], ["proof (state)\nthis:\n  gen [^] k = gen [^] (SOME x. gen [^] k = gen [^] x)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in> UNIV \\<Longrightarrow>\n       f (gen [^] k) = h [^]\\<^bsub>H\\<^esub> k", "moreover"], ["proof (state)\nthis:\n  gen [^] k = gen [^] (SOME x. gen [^] k = gen [^] x)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in> UNIV \\<Longrightarrow>\n       f (gen [^] k) = h [^]\\<^bsub>H\\<^esub> k", "have \"(SOME x::int. gen [^] k = gen [^] x) = (SOME x::int. h [^]\\<^bsub>H\\<^esub> k = h [^]\\<^bsub>H\\<^esub> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SOME x. gen [^] k = gen [^] x) =\n    (SOME x. h [^]\\<^bsub>H\\<^esub> k = h [^]\\<^bsub>H\\<^esub> x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (SOME x. gen [^] k = gen [^] x) =\n    (SOME x. h [^]\\<^bsub>H\\<^esub> k = h [^]\\<^bsub>H\\<^esub> x)", "have \"gen [^] k = gen [^] x \\<longleftrightarrow> h [^]\\<^bsub>H\\<^esub> k = h [^]\\<^bsub>H\\<^esub> x\" for x::int"], ["proof (prove)\ngoal (1 subgoal):\n 1. (gen [^] k = gen [^] x) =\n    (h [^]\\<^bsub>H\\<^esub> k = h [^]\\<^bsub>H\\<^esub> x)", "by (simp add: o group.int_pow_eq)"], ["proof (state)\nthis:\n  (gen [^] k = gen [^] ?x) =\n  (h [^]\\<^bsub>H\\<^esub> k = h [^]\\<^bsub>H\\<^esub> ?x)\n\ngoal (1 subgoal):\n 1. (SOME x. gen [^] k = gen [^] x) =\n    (SOME x. h [^]\\<^bsub>H\\<^esub> k = h [^]\\<^bsub>H\\<^esub> x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (gen [^] k = gen [^] ?x) =\n  (h [^]\\<^bsub>H\\<^esub> k = h [^]\\<^bsub>H\\<^esub> ?x)\n\ngoal (1 subgoal):\n 1. (SOME x. gen [^] k = gen [^] x) =\n    (SOME x. h [^]\\<^bsub>H\\<^esub> k = h [^]\\<^bsub>H\\<^esub> x)", "by simp"], ["proof (state)\nthis:\n  (SOME x. gen [^] k = gen [^] x) =\n  (SOME x. h [^]\\<^bsub>H\\<^esub> k = h [^]\\<^bsub>H\\<^esub> x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (SOME x. gen [^] k = gen [^] x) =\n  (SOME x. h [^]\\<^bsub>H\\<^esub> k = h [^]\\<^bsub>H\\<^esub> x)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in> UNIV \\<Longrightarrow>\n       f (gen [^] k) = h [^]\\<^bsub>H\\<^esub> k", "moreover"], ["proof (state)\nthis:\n  (SOME x. gen [^] k = gen [^] x) =\n  (SOME x. h [^]\\<^bsub>H\\<^esub> k = h [^]\\<^bsub>H\\<^esub> x)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in> UNIV \\<Longrightarrow>\n       f (gen [^] k) = h [^]\\<^bsub>H\\<^esub> k", "have \"h [^]\\<^bsub>H\\<^esub> k = h [^]\\<^bsub>H\\<^esub> (SOME x::int. h [^]\\<^bsub>H\\<^esub> k = h [^]\\<^bsub>H\\<^esub> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h [^]\\<^bsub>H\\<^esub> k =\n    h [^]\\<^bsub>H\\<^esub>\n    (SOME x. h [^]\\<^bsub>H\\<^esub> k = h [^]\\<^bsub>H\\<^esub> x)", "by(intro someI_ex[of \"\\<lambda>x::int. h [^]\\<^bsub>H\\<^esub> k = h [^]\\<^bsub>H\\<^esub> x\"]; blast)"], ["proof (state)\nthis:\n  h [^]\\<^bsub>H\\<^esub> k =\n  h [^]\\<^bsub>H\\<^esub>\n  (SOME x. h [^]\\<^bsub>H\\<^esub> k = h [^]\\<^bsub>H\\<^esub> x)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in> UNIV \\<Longrightarrow>\n       f (gen [^] k) = h [^]\\<^bsub>H\\<^esub> k", "ultimately"], ["proof (chain)\npicking this:\n  gen [^] k = gen [^] (SOME x. gen [^] k = gen [^] x)\n  (SOME x. gen [^] k = gen [^] x) =\n  (SOME x. h [^]\\<^bsub>H\\<^esub> k = h [^]\\<^bsub>H\\<^esub> x)\n  h [^]\\<^bsub>H\\<^esub> k =\n  h [^]\\<^bsub>H\\<^esub>\n  (SOME x. h [^]\\<^bsub>H\\<^esub> k = h [^]\\<^bsub>H\\<^esub> x)", "show \"f (gen [^] k) = h [^]\\<^bsub>H\\<^esub> k\""], ["proof (prove)\nusing this:\n  gen [^] k = gen [^] (SOME x. gen [^] k = gen [^] x)\n  (SOME x. gen [^] k = gen [^] x) =\n  (SOME x. h [^]\\<^bsub>H\\<^esub> k = h [^]\\<^bsub>H\\<^esub> x)\n  h [^]\\<^bsub>H\\<^esub> k =\n  h [^]\\<^bsub>H\\<^esub>\n  (SOME x. h [^]\\<^bsub>H\\<^esub> k = h [^]\\<^bsub>H\\<^esub> x)\n\ngoal (1 subgoal):\n 1. f (gen [^] k) = h [^]\\<^bsub>H\\<^esub> k", "unfolding f_def get_exp_def"], ["proof (prove)\nusing this:\n  gen [^] k = gen [^] (SOME x. gen [^] k = gen [^] x)\n  (SOME x. gen [^] k = gen [^] x) =\n  (SOME x. h [^]\\<^bsub>H\\<^esub> k = h [^]\\<^bsub>H\\<^esub> x)\n  h [^]\\<^bsub>H\\<^esub> k =\n  h [^]\\<^bsub>H\\<^esub>\n  (SOME x. h [^]\\<^bsub>H\\<^esub> k = h [^]\\<^bsub>H\\<^esub> x)\n\ngoal (1 subgoal):\n 1. h [^]\\<^bsub>H\\<^esub> (SOME ka. gen [^] k = gen [^] ka) =\n    h [^]\\<^bsub>H\\<^esub> k", "by metis"], ["proof (state)\nthis:\n  f (gen [^] k) = h [^]\\<^bsub>H\\<^esub> k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>k\\<in>UNIV. f (gen [^] k) = h [^]\\<^bsub>H\\<^esub> k\n\ngoal (1 subgoal):\n 1. ?h \\<in> Group.iso G H", "thus \"f \\<in> iso G H\""], ["proof (prove)\nusing this:\n  \\<forall>k\\<in>UNIV. f (gen [^] k) = h [^]\\<^bsub>H\\<^esub> k\n\ngoal (1 subgoal):\n 1. f \\<in> Group.iso G H", "using iso_cyclic_groups_generate[OF gen_closed H.gen_closed o H.is_group]"], ["proof (prove)\nusing this:\n  \\<forall>k\\<in>UNIV. f (gen [^] k) = h [^]\\<^bsub>H\\<^esub> k\n  {f. \\<forall>k\\<in>UNIV. f (gen [^] k) = h [^]\\<^bsub>H\\<^esub> k}\n  \\<subseteq> Group.iso (G\\<lparr>carrier := generate G {gen}\\<rparr>)\n               (H\\<lparr>carrier := generate H {h}\\<rparr>)\n\ngoal (1 subgoal):\n 1. f \\<in> Group.iso G H", "by (auto simp flip: generator H.generator)"], ["proof (state)\nthis:\n  f \\<in> Group.iso G H\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Integer modular groups\\<close>"], ["", "text \\<open>We show that \\<open>integer_mod_group\\<close> (written as \\<open>Z n\\<close>) is in fact a cyclic group.\nFor $n \\neq 1$ it is generated by $1$ and in the other case by $0$.\\<close>"], ["", "notation integer_mod_group (\"Z\")"], ["", "lemma Zn_neq1_cyclic_group:\n  assumes \"n \\<noteq> 1\"\n  shows \"cyclic_group (Z n) 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_And_Cyclic_Groups.cyclic_group (Z n) 1", "proof(unfold cyclic_group_def cyclic_group_axioms_def, safe)"], ["proof (state)\ngoal (4 subgoals):\n 1. Group.group (Z n)\n 2. 1 \\<in> carrier (Z n)\n 3. \\<And>x.\n       x \\<in> carrier (Z n) \\<Longrightarrow> x \\<in> generate (Z n) {1}\n 4. \\<And>x.\n       x \\<in> generate (Z n) {1} \\<Longrightarrow> x \\<in> carrier (Z n)", "show \"group (Z n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Group.group (Z n)", "using group_integer_mod_group"], ["proof (prove)\nusing this:\n  Group.group (Z ?n)\n\ngoal (1 subgoal):\n 1. Group.group (Z n)", "."], ["proof (state)\nthis:\n  Group.group (Z n)\n\ngoal (3 subgoals):\n 1. 1 \\<in> carrier (Z n)\n 2. \\<And>x.\n       x \\<in> carrier (Z n) \\<Longrightarrow> x \\<in> generate (Z n) {1}\n 3. \\<And>x.\n       x \\<in> generate (Z n) {1} \\<Longrightarrow> x \\<in> carrier (Z n)", "then"], ["proof (chain)\npicking this:\n  Group.group (Z n)", "interpret group \"Z n\""], ["proof (prove)\nusing this:\n  Group.group (Z n)\n\ngoal (1 subgoal):\n 1. Group.group (Z n)", "."], ["proof (state)\ngoal (3 subgoals):\n 1. 1 \\<in> carrier (Z n)\n 2. \\<And>x.\n       x \\<in> carrier (Z n) \\<Longrightarrow> x \\<in> generate (Z n) {1}\n 3. \\<And>x.\n       x \\<in> generate (Z n) {1} \\<Longrightarrow> x \\<in> carrier (Z n)", "show oc: \"1 \\<in> carrier (Z n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<in> carrier (Z n)", "unfolding integer_mod_group_def integer_group_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<in> carrier\n             (if n = 0\n              then \\<lparr>carrier = UNIV, monoid.mult = (+),\n                      one = 0\\<rparr>\n              else \\<lparr>carrier = {0..<int n},\n                      monoid.mult = \\<lambda>x y. (x + y) mod int n,\n                      one = 0\\<rparr>)", "using assms"], ["proof (prove)\nusing this:\n  n \\<noteq> 1\n\ngoal (1 subgoal):\n 1. 1 \\<in> carrier\n             (if n = 0\n              then \\<lparr>carrier = UNIV, monoid.mult = (+),\n                      one = 0\\<rparr>\n              else \\<lparr>carrier = {0..<int n},\n                      monoid.mult = \\<lambda>x y. (x + y) mod int n,\n                      one = 0\\<rparr>)", "by force"], ["proof (state)\nthis:\n  1 \\<in> carrier (Z n)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> carrier (Z n) \\<Longrightarrow> x \\<in> generate (Z n) {1}\n 2. \\<And>x.\n       x \\<in> generate (Z n) {1} \\<Longrightarrow> x \\<in> carrier (Z n)", "show \"x \\<in> generate (Z n) {1}\" if \"x \\<in> carrier (Z n)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> generate (Z n) {1}", "using generate_pow[OF oc] that int_pow_integer_mod_group solve_equation subgroup_self"], ["proof (prove)\nusing this:\n  generate (Z n) {1} = {1 [^]\\<^bsub>Z n\\<^esub> k |k. k \\<in> UNIV}\n  x \\<in> carrier (Z n)\n  ?x [^]\\<^bsub>Z ?n\\<^esub> ?m = ?m * ?x mod int ?n\n  \\<lbrakk>subgroup ?H (Z n); ?x \\<in> ?H; ?y \\<in> ?H\\<rbrakk>\n  \\<Longrightarrow> \\<exists>h\\<in>?H.\n                       ?y = h \\<otimes>\\<^bsub>Z n\\<^esub> ?x\n  subgroup (carrier (Z n)) (Z n)\n\ngoal (1 subgoal):\n 1. x \\<in> generate (Z n) {1}", "by fastforce"], ["proof (state)\nthis:\n  ?x \\<in> carrier (Z n) \\<Longrightarrow> ?x \\<in> generate (Z n) {1}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> generate (Z n) {1} \\<Longrightarrow> x \\<in> carrier (Z n)", "show \"x \\<in> carrier (Z n)\" if \"x \\<in> generate (Z n) {1}\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> carrier (Z n)", "using generate_incl[of \"{1}\"] that oc"], ["proof (prove)\nusing this:\n  {1} \\<subseteq> carrier (Z n) \\<Longrightarrow>\n  generate (Z n) {1} \\<subseteq> carrier (Z n)\n  x \\<in> generate (Z n) {1}\n  1 \\<in> carrier (Z n)\n\ngoal (1 subgoal):\n 1. x \\<in> carrier (Z n)", "by fast"], ["proof (state)\nthis:\n  ?x \\<in> generate (Z n) {1} \\<Longrightarrow> ?x \\<in> carrier (Z n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Z1_cyclic_group: \"cyclic_group (Z 1) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_And_Cyclic_Groups.cyclic_group (Z 1) 0", "proof(unfold cyclic_group_def cyclic_group_axioms_def, safe)"], ["proof (state)\ngoal (4 subgoals):\n 1. Group.group (Z 1)\n 2. 0 \\<in> carrier (Z 1)\n 3. \\<And>x.\n       x \\<in> carrier (Z 1) \\<Longrightarrow> x \\<in> generate (Z 1) {0}\n 4. \\<And>x.\n       x \\<in> generate (Z 1) {0} \\<Longrightarrow> x \\<in> carrier (Z 1)", "show \"group (Z 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Group.group (Z 1)", "using group_integer_mod_group"], ["proof (prove)\nusing this:\n  Group.group (Z ?n)\n\ngoal (1 subgoal):\n 1. Group.group (Z 1)", "."], ["proof (state)\nthis:\n  Group.group (Z 1)\n\ngoal (3 subgoals):\n 1. 0 \\<in> carrier (Z 1)\n 2. \\<And>x.\n       x \\<in> carrier (Z 1) \\<Longrightarrow> x \\<in> generate (Z 1) {0}\n 3. \\<And>x.\n       x \\<in> generate (Z 1) {0} \\<Longrightarrow> x \\<in> carrier (Z 1)", "then"], ["proof (chain)\npicking this:\n  Group.group (Z 1)", "interpret group \"Z 1\""], ["proof (prove)\nusing this:\n  Group.group (Z 1)\n\ngoal (1 subgoal):\n 1. Group.group (Z 1)", "."], ["proof (state)\ngoal (3 subgoals):\n 1. 0 \\<in> carrier (Z 1)\n 2. \\<And>x.\n       x \\<in> carrier (Z 1) \\<Longrightarrow> x \\<in> generate (Z 1) {0}\n 3. \\<And>x.\n       x \\<in> generate (Z 1) {0} \\<Longrightarrow> x \\<in> carrier (Z 1)", "show \"0 \\<in> carrier (Z 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> carrier (Z 1)", "unfolding integer_mod_group_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> carrier\n             (if 1 = 0 then integer_group\n              else \\<lparr>carrier = {0..<int 1},\n                      monoid.mult = \\<lambda>x y. (x + y) mod int 1,\n                      one = 0\\<rparr>)", "by simp"], ["proof (state)\nthis:\n  0 \\<in> carrier (Z 1)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> carrier (Z 1) \\<Longrightarrow> x \\<in> generate (Z 1) {0}\n 2. \\<And>x.\n       x \\<in> generate (Z 1) {0} \\<Longrightarrow> x \\<in> carrier (Z 1)", "thus \"x \\<in> carrier (Z 1)\" if \"x \\<in> generate (Z 1) {0}\" for x"], ["proof (prove)\nusing this:\n  0 \\<in> carrier (Z 1)\n\ngoal (1 subgoal):\n 1. x \\<in> carrier (Z 1)", "using generate_incl[of \"{0}\"] that"], ["proof (prove)\nusing this:\n  0 \\<in> carrier (Z 1)\n  {0} \\<subseteq> carrier (Z 1) \\<Longrightarrow>\n  generate (Z 1) {0} \\<subseteq> carrier (Z 1)\n  x \\<in> generate (Z 1) {0}\n\ngoal (1 subgoal):\n 1. x \\<in> carrier (Z 1)", "by fast"], ["proof (state)\nthis:\n  ?x \\<in> generate (Z 1) {0} \\<Longrightarrow> ?x \\<in> carrier (Z 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier (Z 1) \\<Longrightarrow> x \\<in> generate (Z 1) {0}", "show \"x \\<in> generate (Z 1) {0}\" if \"x \\<in> carrier (Z 1)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> generate (Z 1) {0}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> generate (Z 1) {0}", "from that"], ["proof (chain)\npicking this:\n  x \\<in> carrier (Z 1)", "have \"x = 0\""], ["proof (prove)\nusing this:\n  x \\<in> carrier (Z 1)\n\ngoal (1 subgoal):\n 1. x = 0", "unfolding integer_mod_group_def"], ["proof (prove)\nusing this:\n  x \\<in> carrier\n           (if 1 = 0 then integer_group\n            else \\<lparr>carrier = {0..<int 1},\n                    monoid.mult = \\<lambda>x y. (x + y) mod int 1,\n                    one = 0\\<rparr>)\n\ngoal (1 subgoal):\n 1. x = 0", "by auto"], ["proof (state)\nthis:\n  x = 0\n\ngoal (1 subgoal):\n 1. x \\<in> generate (Z 1) {0}", "with generate.one[of \"Z 1\" \"{0}\"]"], ["proof (chain)\npicking this:\n  \\<one>\\<^bsub>Z 1\\<^esub> \\<in> generate (Z 1) {0}\n  x = 0", "show \"x \\<in> generate (Z 1) {0}\""], ["proof (prove)\nusing this:\n  \\<one>\\<^bsub>Z 1\\<^esub> \\<in> generate (Z 1) {0}\n  x = 0\n\ngoal (1 subgoal):\n 1. x \\<in> generate (Z 1) {0}", "unfolding integer_mod_group_def"], ["proof (prove)\nusing this:\n  \\<one>\\<^bsub>if 1 = 0 then integer_group else \\<lparr>carrier = {0..<int 1}, monoid.mult = \\<lambda>x y. (x + y) mod int 1, one = 0\\<rparr>\\<^esub>\n  \\<in> generate\n         (if 1 = 0 then integer_group\n          else \\<lparr>carrier = {0..<int 1},\n                  monoid.mult = \\<lambda>x y. (x + y) mod int 1,\n                  one = 0\\<rparr>)\n         {0}\n  x = 0\n\ngoal (1 subgoal):\n 1. x \\<in> generate\n             (if 1 = 0 then integer_group\n              else \\<lparr>carrier = {0..<int 1},\n                      monoid.mult = \\<lambda>x y. (x + y) mod int 1,\n                      one = 0\\<rparr>)\n             {0}", "by simp"], ["proof (state)\nthis:\n  x \\<in> generate (Z 1) {0}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> carrier (Z 1) \\<Longrightarrow> ?x \\<in> generate (Z 1) {0}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Zn_cyclic_group:\n  obtains x where \"cyclic_group (Z n) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        Finite_And_Cyclic_Groups.cyclic_group (Z n) x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Z1_cyclic_group Zn_neq1_cyclic_group"], ["proof (prove)\nusing this:\n  Finite_And_Cyclic_Groups.cyclic_group (Z 1) 0\n  ?n \\<noteq> 1 \\<Longrightarrow>\n  Finite_And_Cyclic_Groups.cyclic_group (Z ?n) 1\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        Finite_And_Cyclic_Groups.cyclic_group (Z n) x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["", "text \\<open>Moreover, its order is just $n$.\\<close>"], ["", "lemma Zn_order: \"order (Z n) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order (Z n) = n", "by (unfold integer_mod_group_def integer_group_def order_def, auto)"], ["", "text \\<open>Consequently, \\<open>Z n\\<close> is isomorphic to any cyclic group of order $n$.\\<close>"], ["", "lemma (in cyclic_group) Zn_iso:\n  assumes \"order G = n\"\n  shows \"G \\<cong> Z n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<cong> Z n", "using Zn_order Zn_cyclic_group iso_cyclic_groups_same_order assms"], ["proof (prove)\nusing this:\n  order (Z ?n) = ?n\n  (\\<And>x.\n      Finite_And_Cyclic_Groups.cyclic_group (Z ?n) x \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis\n  \\<lbrakk>Finite_And_Cyclic_Groups.cyclic_group ?H ?h;\n   order G = order ?H\\<rbrakk>\n  \\<Longrightarrow> G \\<cong> ?H\n  order G = n\n\ngoal (1 subgoal):\n 1. G \\<cong> Z n", "by metis"], ["", "no_notation integer_mod_group (\"Z\")"], ["", "end"]]}