{"file_name": "/home/qj213/afp-2021-10-22/thys/Finitely_Generated_Abelian_Groups/Finitely_Generated_Abelian_Groups.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Finitely_Generated_Abelian_Groups", "problem_names": ["lemma (in comm_group) ex_idirgen:\n  fixes A :: \"'a set\"\n  assumes \"finite A\" \"A \\<subseteq> carrier G\"\n  shows \"\\<exists>gs. set gs \\<subseteq> generate G A \\<and> distinct gs \\<and> is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set gs)\n            \\<and> successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\"\n  (is \"?t A\")", "lemma (in comm_group) fundamental_subgr:\n  fixes A :: \"'a set\"\n  assumes \"finite A\" \"A \\<subseteq> carrier G\"\n  obtains gs where\n    \"set gs \\<subseteq> generate G A\" \"distinct gs\" \"is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set gs)\"\n    \"successively (dvd) (map ord gs)\" \"card (set gs) \\<le> card A\"", "theorem (in fin_gen_comm_group) invariant_factor_decomposition_idirprod:\n  obtains gs where\n    \"set gs \\<subseteq> carrier G\" \"distinct gs\" \"is_idirprod (carrier G) (\\<lambda>g. generate G {g}) (set gs)\"\n    \"successively (dvd) (map ord gs)\" \"card (set gs) \\<le> card gen\" \"\\<one> \\<notin> set gs\"", "lemma Zn_iso_DirProds_prime_powers:\n  assumes \"n \\<noteq> 0\"\n  shows \"Z n \\<cong> DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)\" (is \"Z n \\<cong> ?DP\")", "lemma Zn_iso_DirProds_prime_powers':\n  assumes \"n \\<noteq> 0\"\n  shows \"Z n \\<cong> DirProds (\\<lambda>p. Z p) ((\\<lambda>p. p ^ multiplicity p n) ` (prime_factors n))\" (is \"Z n \\<cong> ?DP\")", "lemma (in finite_comm_group) cyclic_product:\n  obtains ns where \"DirProds (\\<lambda>n. Z (ns!n)) {..<length ns} \\<cong> G\" \"\\<forall>n\\<in>set ns. n\\<noteq>0\""], "translations": [["", "lemma (in comm_group) ex_idirgen:\n  fixes A :: \"'a set\"\n  assumes \"finite A\" \"A \\<subseteq> carrier G\"\n  shows \"\\<exists>gs. set gs \\<subseteq> generate G A \\<and> distinct gs \\<and> is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set gs)\n            \\<and> successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\"\n  (is \"?t A\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  A \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "proof (induction \"card A\" arbitrary: A rule: nat_less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>\\<forall>m<card A.\n                   \\<forall>x.\n                      m = card x \\<longrightarrow>\n                      finite x \\<longrightarrow>\n                      x \\<subseteq> carrier G \\<longrightarrow>\n                      (\\<exists>gs.\n                          set gs \\<subseteq> generate G x \\<and>\n                          cycle gs \\<and>\n                          is_idirprod (generate G x)\n                           (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                          successively (dvd) (map ord gs) \\<and>\n                          card (set gs) \\<le> card x);\n        finite A; A \\<subseteq> carrier G\\<rbrakk>\n       \\<Longrightarrow> \\<exists>gs.\n                            set gs \\<subseteq> generate G A \\<and>\n                            cycle gs \\<and>\n                            is_idirprod (generate G A)\n                             (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                            successively (dvd) (map ord gs) \\<and>\n                            card (set gs) \\<le> card A", "case i: 1"], ["proof (state)\nthis:\n  \\<forall>m<card A.\n     \\<forall>x.\n        m = card x \\<longrightarrow>\n        finite x \\<longrightarrow>\n        x \\<subseteq> carrier G \\<longrightarrow>\n        (\\<exists>gs.\n            set gs \\<subseteq> generate G x \\<and>\n            cycle gs \\<and>\n            is_idirprod (generate G x) (\\<lambda>g. generate G {g})\n             (set gs) \\<and>\n            successively (dvd) (map ord gs) \\<and>\n            card (set gs) \\<le> card x)\n  finite A\n  A \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>\\<forall>m<card A.\n                   \\<forall>x.\n                      m = card x \\<longrightarrow>\n                      finite x \\<longrightarrow>\n                      x \\<subseteq> carrier G \\<longrightarrow>\n                      (\\<exists>gs.\n                          set gs \\<subseteq> generate G x \\<and>\n                          cycle gs \\<and>\n                          is_idirprod (generate G x)\n                           (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                          successively (dvd) (map ord gs) \\<and>\n                          card (set gs) \\<le> card x);\n        finite A; A \\<subseteq> carrier G\\<rbrakk>\n       \\<Longrightarrow> \\<exists>gs.\n                            set gs \\<subseteq> generate G A \\<and>\n                            cycle gs \\<and>\n                            is_idirprod (generate G A)\n                             (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                            successively (dvd) (map ord gs) \\<and>\n                            card (set gs) \\<le> card A", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "proof (cases \"relations A = {restrict (\\<lambda>_. 0::int) A}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. relations A = {\\<lambda>_\\<in>A. 0} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 2. relations A \\<noteq> {\\<lambda>_\\<in>A. 0} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "(* only trivial relation *)"], ["proof (state)\ngoal (2 subgoals):\n 1. relations A = {\\<lambda>_\\<in>A. 0} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 2. relations A \\<noteq> {\\<lambda>_\\<in>A. 0} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "case True"], ["proof (state)\nthis:\n  relations A = {\\<lambda>_\\<in>A. 0}\n\ngoal (2 subgoals):\n 1. relations A = {\\<lambda>_\\<in>A. 0} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 2. relations A \\<noteq> {\\<lambda>_\\<in>A. 0} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "have fi: \"finite A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A", "by fact"], ["proof (state)\nthis:\n  finite A\n\ngoal (2 subgoals):\n 1. relations A = {\\<lambda>_\\<in>A. 0} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 2. relations A \\<noteq> {\\<lambda>_\\<in>A. 0} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "then"], ["proof (chain)\npicking this:\n  finite A", "obtain gs where gs: \"set gs = A\" \"distinct gs\""], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. (\\<And>gs.\n        \\<lbrakk>set gs = A; cycle gs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson finite_distinct_list)"], ["proof (state)\nthis:\n  set gs = A\n  cycle gs\n\ngoal (2 subgoals):\n 1. relations A = {\\<lambda>_\\<in>A. 0} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 2. relations A \\<noteq> {\\<lambda>_\\<in>A. 0} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "have o: \"ord g = 0\" if \"g \\<in> set gs\" for g"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord g = 0", "by (intro relations_zero_imp_ord_zero[OF that], use i(3) that True gs in auto)"], ["proof (state)\nthis:\n  ?g2 \\<in> set gs \\<Longrightarrow> ord ?g2 = 0\n\ngoal (2 subgoals):\n 1. relations A = {\\<lambda>_\\<in>A. 0} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 2. relations A \\<noteq> {\\<lambda>_\\<in>A. 0} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "have m: \"map ord gs = replicate (length gs) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map ord gs = replicate (length gs) 0", "using o"], ["proof (prove)\nusing this:\n  ?g2 \\<in> set gs \\<Longrightarrow> ord ?g2 = 0\n\ngoal (1 subgoal):\n 1. map ord gs = replicate (length gs) 0", "by (induction gs; auto)"], ["proof (state)\nthis:\n  map ord gs = replicate (length gs) 0\n\ngoal (2 subgoals):\n 1. relations A = {\\<lambda>_\\<in>A. 0} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 2. relations A \\<noteq> {\\<lambda>_\\<in>A. 0} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "proof(intro exI conjI subsetI)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x. x \\<in> set ?gs \\<Longrightarrow> x \\<in> generate G A\n 2. cycle ?gs\n 3. is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set ?gs)\n 4. successively (dvd) (map ord ?gs)\n 5. card (set ?gs) \\<le> card A", "show \"\\<And>x. x \\<in> set gs \\<Longrightarrow> x \\<in> generate G A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set gs \\<Longrightarrow> x \\<in> generate G A", "using gs generate.incl[of _ A G]"], ["proof (prove)\nusing this:\n  set gs = A\n  cycle gs\n  ?h \\<in> A \\<Longrightarrow> ?h \\<in> generate G A\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set gs \\<Longrightarrow> x \\<in> generate G A", "by blast"], ["proof (state)\nthis:\n  ?x2 \\<in> set gs \\<Longrightarrow> ?x2 \\<in> generate G A\n\ngoal (4 subgoals):\n 1. cycle gs\n 2. is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set gs)\n 3. successively (dvd) (map ord gs)\n 4. card (set gs) \\<le> card A", "show \"distinct gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cycle gs", "by fact"], ["proof (state)\nthis:\n  cycle gs\n\ngoal (3 subgoals):\n 1. is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set gs)\n 2. successively (dvd) (map ord gs)\n 3. card (set gs) \\<le> card A", "show \"is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set gs)", "proof(unfold is_idirprod_def, intro conjI, rule)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i. i \\<in> set gs \\<Longrightarrow> generate G {i} \\<lhd> G\n 2. generate G A = IDirProds G (\\<lambda>g. generate G {g}) (set gs)\n 3. compl_fam (\\<lambda>g. generate G {g}) (set gs)", "show \"generate G {g} \\<lhd> G\" if \"g \\<in> set gs\" for g"], ["proof (prove)\ngoal (1 subgoal):\n 1. generate G {g} \\<lhd> G", "by (intro subgroup_imp_normal, use that generate_is_subgroup i(3) gs in auto)"], ["proof (state)\nthis:\n  ?g2 \\<in> set gs \\<Longrightarrow> generate G {?g2} \\<lhd> G\n\ngoal (2 subgoals):\n 1. generate G A = IDirProds G (\\<lambda>g. generate G {g}) (set gs)\n 2. compl_fam (\\<lambda>g. generate G {g}) (set gs)", "show \"generate G A = IDirProds G (\\<lambda>g. generate G {g}) (set gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generate G A = IDirProds G (\\<lambda>g. generate G {g}) (set gs)", "unfolding IDirProds_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. generate G A = generate G (\\<Union>g\\<in>set gs. generate G {g})", "by (subst gs(1), use generate_idem_Un i(3) in blast)"], ["proof (state)\nthis:\n  generate G A = IDirProds G (\\<lambda>g. generate G {g}) (set gs)\n\ngoal (1 subgoal):\n 1. compl_fam (\\<lambda>g. generate G {g}) (set gs)", "show \"compl_fam (\\<lambda>g. generate G {g}) (set gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compl_fam (\\<lambda>g. generate G {g}) (set gs)", "using compl_fam_iff_relations_triv[OF i(2, 3)] o gs(1) True"], ["proof (prove)\nusing this:\n  \\<forall>g\\<in>A. ord g = 0 \\<Longrightarrow>\n  (relations A = {\\<lambda>_\\<in>A. 0}) =\n  compl_fam (\\<lambda>g. generate G {g}) A\n  ?g2 \\<in> set gs \\<Longrightarrow> ord ?g2 = 0\n  set gs = A\n  relations A = {\\<lambda>_\\<in>A. 0}\n\ngoal (1 subgoal):\n 1. compl_fam (\\<lambda>g. generate G {g}) (set gs)", "by blast"], ["proof (state)\nthis:\n  compl_fam (\\<lambda>g. generate G {g}) (set gs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set gs)\n\ngoal (2 subgoals):\n 1. successively (dvd) (map ord gs)\n 2. card (set gs) \\<le> card A", "show \"successively (dvd) (map ord gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. successively (dvd) (map ord gs)", "using m"], ["proof (prove)\nusing this:\n  map ord gs = replicate (length gs) 0\n\ngoal (1 subgoal):\n 1. successively (dvd) (map ord gs)", "proof (induction gs)"], ["proof (state)\ngoal (2 subgoals):\n 1. map ord [] = replicate (length []) 0 \\<Longrightarrow>\n    successively (dvd) (map ord [])\n 2. \\<And>a gs.\n       \\<lbrakk>map ord gs = replicate (length gs) 0 \\<Longrightarrow>\n                successively (dvd) (map ord gs);\n        map ord (a # gs) = replicate (length (a # gs)) 0\\<rbrakk>\n       \\<Longrightarrow> successively (dvd) (map ord (a # gs))", "case c: (Cons a gs)"], ["proof (state)\nthis:\n  map ord gs = replicate (length gs) 0 \\<Longrightarrow>\n  successively (dvd) (map ord gs)\n  map ord (a # gs) = replicate (length (a # gs)) 0\n\ngoal (2 subgoals):\n 1. map ord [] = replicate (length []) 0 \\<Longrightarrow>\n    successively (dvd) (map ord [])\n 2. \\<And>a gs.\n       \\<lbrakk>map ord gs = replicate (length gs) 0 \\<Longrightarrow>\n                successively (dvd) (map ord gs);\n        map ord (a # gs) = replicate (length (a # gs)) 0\\<rbrakk>\n       \\<Longrightarrow> successively (dvd) (map ord (a # gs))", "thus ?case"], ["proof (prove)\nusing this:\n  map ord gs = replicate (length gs) 0 \\<Longrightarrow>\n  successively (dvd) (map ord gs)\n  map ord (a # gs) = replicate (length (a # gs)) 0\n\ngoal (1 subgoal):\n 1. successively (dvd) (map ord (a # gs))", "by(cases gs; simp)"], ["proof (state)\nthis:\n  successively (dvd) (map ord (a # gs))\n\ngoal (1 subgoal):\n 1. map ord [] = replicate (length []) 0 \\<Longrightarrow>\n    successively (dvd) (map ord [])", "qed simp"], ["proof (state)\nthis:\n  successively (dvd) (map ord gs)\n\ngoal (1 subgoal):\n 1. card (set gs) \\<le> card A", "show \"card (set gs) \\<le> card A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set gs) \\<le> card A", "using gs"], ["proof (prove)\nusing this:\n  set gs = A\n  cycle gs\n\ngoal (1 subgoal):\n 1. card (set gs) \\<le> card A", "by blast"], ["proof (state)\nthis:\n  card (set gs) \\<le> card A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>gs.\n     set gs \\<subseteq> generate G A \\<and>\n     cycle gs \\<and>\n     is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set gs) \\<and>\n     successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n\ngoal (1 subgoal):\n 1. relations A \\<noteq> {\\<lambda>_\\<in>A. 0} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. relations A \\<noteq> {\\<lambda>_\\<in>A. 0} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "case ntrel: False"], ["proof (state)\nthis:\n  relations A \\<noteq> {\\<lambda>_\\<in>A. 0}\n\ngoal (1 subgoal):\n 1. relations A \\<noteq> {\\<lambda>_\\<in>A. 0} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "then"], ["proof (chain)\npicking this:\n  relations A \\<noteq> {\\<lambda>_\\<in>A. 0}", "have Ane: \"A \\<noteq> {}\""], ["proof (prove)\nusing this:\n  relations A \\<noteq> {\\<lambda>_\\<in>A. 0}\n\ngoal (1 subgoal):\n 1. A \\<noteq> {}", "using i(2) triv_rel[of A]"], ["proof (prove)\nusing this:\n  relations A \\<noteq> {\\<lambda>_\\<in>A. 0}\n  finite A\n  (\\<lambda>_\\<in>A. 0) \\<in> relations A\n\ngoal (1 subgoal):\n 1. A \\<noteq> {}", "unfolding relations_def extensional_def"], ["proof (prove)\nusing this:\n  {f. (\\<Otimes>a\\<in>A. a [^] f a) = \\<one>} \\<inter>\n  {f. \\<forall>x. x \\<notin> A \\<longrightarrow> f x = undefined} \\<noteq>\n  {\\<lambda>_\\<in>A. 0}\n  finite A\n  (\\<lambda>_\\<in>A. 0)\n  \\<in> {f. (\\<Otimes>a\\<in>A. a [^] f a) = \\<one>} \\<inter>\n        {f. \\<forall>x. x \\<notin> A \\<longrightarrow> f x = undefined}\n\ngoal (1 subgoal):\n 1. A \\<noteq> {}", "by fastforce"], ["proof (state)\nthis:\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. relations A \\<noteq> {\\<lambda>_\\<in>A. 0} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "from ntrel"], ["proof (chain)\npicking this:\n  relations A \\<noteq> {\\<lambda>_\\<in>A. 0}", "obtain a where a: \"a \\<in> A\" \"\\<exists>r \\<in>relations A. r a \\<noteq> 0\""], ["proof (prove)\nusing this:\n  relations A \\<noteq> {\\<lambda>_\\<in>A. 0}\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> A;\n         \\<exists>r\\<in>relations A. r a \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using i(2) triv_rel[of A]"], ["proof (prove)\nusing this:\n  relations A \\<noteq> {\\<lambda>_\\<in>A. 0}\n  finite A\n  (\\<lambda>_\\<in>A. 0) \\<in> relations A\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> A;\n         \\<exists>r\\<in>relations A. r a \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding relations_def extensional_def"], ["proof (prove)\nusing this:\n  {f. (\\<Otimes>a\\<in>A. a [^] f a) = \\<one>} \\<inter>\n  {f. \\<forall>x. x \\<notin> A \\<longrightarrow> f x = undefined} \\<noteq>\n  {\\<lambda>_\\<in>A. 0}\n  finite A\n  (\\<lambda>_\\<in>A. 0)\n  \\<in> {f. (\\<Otimes>a\\<in>A. a [^] f a) = \\<one>} \\<inter>\n        {f. \\<forall>x. x \\<notin> A \\<longrightarrow> f x = undefined}\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> A;\n         \\<exists>r\\<in>{f. (\\<Otimes>a\\<in>A. a [^] f a) = \\<one>} \\<inter>\n                        {f. \\<forall>x.\n                               x \\<notin> A \\<longrightarrow>\n                               f x = undefined}.\n            r a \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  a \\<in> A\n  \\<exists>r\\<in>relations A. r a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. relations A \\<noteq> {\\<lambda>_\\<in>A. 0} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "hence ac: \"a \\<in> carrier G\""], ["proof (prove)\nusing this:\n  a \\<in> A\n  \\<exists>r\\<in>relations A. r a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a \\<in> carrier G", "using i(3)"], ["proof (prove)\nusing this:\n  a \\<in> A\n  \\<exists>r\\<in>relations A. r a \\<noteq> 0\n  A \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. a \\<in> carrier G", "by blast"], ["proof (state)\nthis:\n  a \\<in> carrier G\n\ngoal (1 subgoal):\n 1. relations A \\<noteq> {\\<lambda>_\\<in>A. 0} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "have iH: \"\\<And>B.\\<lbrakk>card B < card A; finite B; B \\<subseteq> carrier G\\<rbrakk> \\<Longrightarrow> ?t B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>B.\n       \\<lbrakk>card B < card A; finite B; B \\<subseteq> carrier G\\<rbrakk>\n       \\<Longrightarrow> \\<exists>gs.\n                            set gs \\<subseteq> generate G B \\<and>\n                            cycle gs \\<and>\n                            is_idirprod (generate G B)\n                             (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                            successively (dvd) (map ord gs) \\<and>\n                            card (set gs) \\<le> card B", "using i(1)"], ["proof (prove)\nusing this:\n  \\<forall>m<card A.\n     \\<forall>x.\n        m = card x \\<longrightarrow>\n        finite x \\<longrightarrow>\n        x \\<subseteq> carrier G \\<longrightarrow>\n        (\\<exists>gs.\n            set gs \\<subseteq> generate G x \\<and>\n            cycle gs \\<and>\n            is_idirprod (generate G x) (\\<lambda>g. generate G {g})\n             (set gs) \\<and>\n            successively (dvd) (map ord gs) \\<and>\n            card (set gs) \\<le> card x)\n\ngoal (1 subgoal):\n 1. \\<And>B.\n       \\<lbrakk>card B < card A; finite B; B \\<subseteq> carrier G\\<rbrakk>\n       \\<Longrightarrow> \\<exists>gs.\n                            set gs \\<subseteq> generate G B \\<and>\n                            cycle gs \\<and>\n                            is_idirprod (generate G B)\n                             (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                            successively (dvd) (map ord gs) \\<and>\n                            card (set gs) \\<le> card B", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>card ?B2 < card A; finite ?B2; ?B2 \\<subseteq> carrier G\\<rbrakk>\n  \\<Longrightarrow> \\<exists>gs.\n                       set gs \\<subseteq> generate G ?B2 \\<and>\n                       cycle gs \\<and>\n                       is_idirprod (generate G ?B2)\n                        (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                       successively (dvd) (map ord gs) \\<and>\n                       card (set gs) \\<le> card ?B2\n\ngoal (1 subgoal):\n 1. relations A \\<noteq> {\\<lambda>_\\<in>A. 0} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "have iH2: \"\\<And>B. \\<lbrakk>?t B; generate G A = generate G B; card B < card A\\<rbrakk> \\<Longrightarrow> ?t A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>B.\n       \\<lbrakk>\\<exists>gs.\n                   set gs \\<subseteq> generate G B \\<and>\n                   cycle gs \\<and>\n                   is_idirprod (generate G B) (\\<lambda>g. generate G {g})\n                    (set gs) \\<and>\n                   successively (dvd) (map ord gs) \\<and>\n                   card (set gs) \\<le> card B;\n        generate G A = generate G B; card B < card A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>gs.\n                            set gs \\<subseteq> generate G A \\<and>\n                            cycle gs \\<and>\n                            is_idirprod (generate G A)\n                             (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                            successively (dvd) (map ord gs) \\<and>\n                            card (set gs) \\<le> card A", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>\\<exists>gs.\n              set gs \\<subseteq> generate G ?B2 \\<and>\n              cycle gs \\<and>\n              is_idirprod (generate G ?B2) (\\<lambda>g. generate G {g})\n               (set gs) \\<and>\n              successively (dvd) (map ord gs) \\<and>\n              card (set gs) \\<le> card ?B2;\n   generate G A = generate G ?B2; card ?B2 < card A\\<rbrakk>\n  \\<Longrightarrow> \\<exists>gs.\n                       set gs \\<subseteq> generate G A \\<and>\n                       cycle gs \\<and>\n                       is_idirprod (generate G A)\n                        (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                       successively (dvd) (map ord gs) \\<and>\n                       card (set gs) \\<le> card A\n\ngoal (1 subgoal):\n 1. relations A \\<noteq> {\\<lambda>_\\<in>A. 0} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "proof(cases \"inv a \\<in> (A - {a})\")"], ["proof (state)\ngoal (2 subgoals):\n 1. inv a \\<in> A - {a} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 2. inv a \\<notin> A - {a} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "case True"], ["proof (state)\nthis:\n  inv a \\<in> A - {a}\n\ngoal (2 subgoals):\n 1. inv a \\<in> A - {a} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 2. inv a \\<notin> A - {a} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "have \"generate G A = generate G (A - {a})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generate G A = generate G (A - {a})", "proof(intro generate_subset_eqI[OF i(3)])"], ["proof (state)\ngoal (2 subgoals):\n 1. A - {a} \\<subseteq> A\n 2. A - (A - {a}) \\<subseteq> generate G (A - {a})", "show \"A - (A - {a}) \\<subseteq> generate G (A - {a})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A - (A - {a}) \\<subseteq> generate G (A - {a})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A - (A - {a}) \\<subseteq> generate G (A - {a})", "have \"A - (A - {a}) = {a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A - (A - {a}) = {a}", "using a True"], ["proof (prove)\nusing this:\n  a \\<in> A\n  \\<exists>r\\<in>relations A. r a \\<noteq> 0\n  inv a \\<in> A - {a}\n\ngoal (1 subgoal):\n 1. A - (A - {a}) = {a}", "by auto"], ["proof (state)\nthis:\n  A - (A - {a}) = {a}\n\ngoal (1 subgoal):\n 1. A - (A - {a}) \\<subseteq> generate G (A - {a})", "also"], ["proof (state)\nthis:\n  A - (A - {a}) = {a}\n\ngoal (1 subgoal):\n 1. A - (A - {a}) \\<subseteq> generate G (A - {a})", "have \"\\<dots> \\<subseteq> generate G {inv a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a} \\<subseteq> generate G {inv a}", "using generate.inv[of \"inv a\" \"{inv a}\" G] ac"], ["proof (prove)\nusing this:\n  inv a \\<in> {inv a} \\<Longrightarrow> inv (inv a) \\<in> generate G {inv a}\n  a \\<in> carrier G\n\ngoal (1 subgoal):\n 1. {a} \\<subseteq> generate G {inv a}", "by simp"], ["proof (state)\nthis:\n  {a} \\<subseteq> generate G {inv a}\n\ngoal (1 subgoal):\n 1. A - (A - {a}) \\<subseteq> generate G (A - {a})", "also"], ["proof (state)\nthis:\n  {a} \\<subseteq> generate G {inv a}\n\ngoal (1 subgoal):\n 1. A - (A - {a}) \\<subseteq> generate G (A - {a})", "have \"\\<dots> \\<subseteq> generate G (A - {a})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generate G {inv a} \\<subseteq> generate G (A - {a})", "by (intro mono_generate, use True in simp)"], ["proof (state)\nthis:\n  generate G {inv a} \\<subseteq> generate G (A - {a})\n\ngoal (1 subgoal):\n 1. A - (A - {a}) \\<subseteq> generate G (A - {a})", "finally"], ["proof (chain)\npicking this:\n  A - (A - {a}) \\<subseteq> generate G (A - {a})", "show ?thesis"], ["proof (prove)\nusing this:\n  A - (A - {a}) \\<subseteq> generate G (A - {a})\n\ngoal (1 subgoal):\n 1. A - (A - {a}) \\<subseteq> generate G (A - {a})", "."], ["proof (state)\nthis:\n  A - (A - {a}) \\<subseteq> generate G (A - {a})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A - (A - {a}) \\<subseteq> generate G (A - {a})\n\ngoal (1 subgoal):\n 1. A - {a} \\<subseteq> A", "qed simp"], ["proof (state)\nthis:\n  generate G A = generate G (A - {a})\n\ngoal (2 subgoals):\n 1. inv a \\<in> A - {a} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 2. inv a \\<notin> A - {a} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "moreover"], ["proof (state)\nthis:\n  generate G A = generate G (A - {a})\n\ngoal (2 subgoals):\n 1. inv a \\<in> A - {a} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 2. inv a \\<notin> A - {a} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "have \"?t (A - {a})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>gs.\n       set gs \\<subseteq> generate G (A - {a}) \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G (A - {a})) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and>\n       card (set gs) \\<le> card (A - {a})", "by (intro iH[of \"A - {a}\"], use i(2, 3) a(1) in auto, meson Ane card_gt_0_iff diff_Suc_less)"], ["proof (state)\nthis:\n  \\<exists>gs.\n     set gs \\<subseteq> generate G (A - {a}) \\<and>\n     cycle gs \\<and>\n     is_idirprod (generate G (A - {a})) (\\<lambda>g. generate G {g})\n      (set gs) \\<and>\n     successively (dvd) (map ord gs) \\<and>\n     card (set gs) \\<le> card (A - {a})\n\ngoal (2 subgoals):\n 1. inv a \\<in> A - {a} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 2. inv a \\<notin> A - {a} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "ultimately"], ["proof (chain)\npicking this:\n  generate G A = generate G (A - {a})\n  \\<exists>gs.\n     set gs \\<subseteq> generate G (A - {a}) \\<and>\n     cycle gs \\<and>\n     is_idirprod (generate G (A - {a})) (\\<lambda>g. generate G {g})\n      (set gs) \\<and>\n     successively (dvd) (map ord gs) \\<and>\n     card (set gs) \\<le> card (A - {a})", "show ?thesis"], ["proof (prove)\nusing this:\n  generate G A = generate G (A - {a})\n  \\<exists>gs.\n     set gs \\<subseteq> generate G (A - {a}) \\<and>\n     cycle gs \\<and>\n     is_idirprod (generate G (A - {a})) (\\<lambda>g. generate G {g})\n      (set gs) \\<and>\n     successively (dvd) (map ord gs) \\<and>\n     card (set gs) \\<le> card (A - {a})\n\ngoal (1 subgoal):\n 1. \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "using card.remove[OF i(2) a(1)]"], ["proof (prove)\nusing this:\n  generate G A = generate G (A - {a})\n  \\<exists>gs.\n     set gs \\<subseteq> generate G (A - {a}) \\<and>\n     cycle gs \\<and>\n     is_idirprod (generate G (A - {a})) (\\<lambda>g. generate G {g})\n      (set gs) \\<and>\n     successively (dvd) (map ord gs) \\<and>\n     card (set gs) \\<le> card (A - {a})\n  card A = Suc (card (A - {a}))\n\ngoal (1 subgoal):\n 1. \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>gs.\n     set gs \\<subseteq> generate G A \\<and>\n     cycle gs \\<and>\n     is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set gs) \\<and>\n     successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n\ngoal (1 subgoal):\n 1. inv a \\<notin> A - {a} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. inv a \\<notin> A - {a} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "case inv: False"], ["proof (state)\nthis:\n  inv a \\<notin> A - {a}\n\ngoal (1 subgoal):\n 1. inv a \\<notin> A - {a} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "define n where n: \"n = card A\""], ["proof (state)\nthis:\n  n = card A\n\ngoal (1 subgoal):\n 1. inv a \\<notin> A - {a} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "define all_gens where\n        \"all_gens = {gs\\<in>Pow (generate G A). finite gs \\<and> card gs \\<le> n \\<and> generate G gs = generate G A}\""], ["proof (state)\nthis:\n  all_gens =\n  {gs \\<in> Pow (generate G A).\n   finite gs \\<and> card gs \\<le> n \\<and> generate G gs = generate G A}\n\ngoal (1 subgoal):\n 1. inv a \\<notin> A - {a} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "define exps where \"exps = (\\<Union>gs'\\<in>all_gens. \\<Union>rel\\<in>relations gs'. nat ` {e\\<in>rel`gs'. e > 0})\""], ["proof (state)\nthis:\n  exps =\n  (\\<Union>gs'\\<in>all_gens.\n      \\<Union>rel\\<in>relations gs'. nat ` {e \\<in> rel ` gs'. 0 < e})\n\ngoal (1 subgoal):\n 1. inv a \\<notin> A - {a} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "define min_exp where \"min_exp = Inf exps\""], ["proof (state)\nthis:\n  min_exp = Inf exps\n\ngoal (1 subgoal):\n 1. inv a \\<notin> A - {a} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "have \"exps \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exps \\<noteq> {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. exps \\<noteq> {}", "let ?B = \"A - {a} \\<union> {inv a}\""], ["proof (state)\ngoal (1 subgoal):\n 1. exps \\<noteq> {}", "have \"A \\<in> all_gens\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> all_gens", "unfolding all_gens_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> {gs \\<in> Pow (generate G A).\n             finite gs \\<and>\n             card gs \\<le> n \\<and> generate G gs = generate G A}", "using generate.incl n i(2)"], ["proof (prove)\nusing this:\n  ?h \\<in> ?H \\<Longrightarrow> ?h \\<in> generate ?G ?H\n  n = card A\n  finite A\n\ngoal (1 subgoal):\n 1. A \\<in> {gs \\<in> Pow (generate G A).\n             finite gs \\<and>\n             card gs \\<le> n \\<and> generate G gs = generate G A}", "by fast"], ["proof (state)\nthis:\n  A \\<in> all_gens\n\ngoal (1 subgoal):\n 1. exps \\<noteq> {}", "moreover"], ["proof (state)\nthis:\n  A \\<in> all_gens\n\ngoal (1 subgoal):\n 1. exps \\<noteq> {}", "have \"?B \\<in> all_gens\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A - {a} \\<union> {inv a} \\<in> all_gens", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A - {a} \\<union> {inv a} \\<in> all_gens", "have \"card (A - {a}) = n - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (A - {a}) = n - 1", "using a n"], ["proof (prove)\nusing this:\n  a \\<in> A\n  \\<exists>r\\<in>relations A. r a \\<noteq> 0\n  n = card A\n\ngoal (1 subgoal):\n 1. card (A - {a}) = n - 1", "by (meson card_Diff_singleton_if i(2))"], ["proof (state)\nthis:\n  card (A - {a}) = n - 1\n\ngoal (1 subgoal):\n 1. A - {a} \\<union> {inv a} \\<in> all_gens", "hence \"card ?B = n\""], ["proof (prove)\nusing this:\n  card (A - {a}) = n - 1\n\ngoal (1 subgoal):\n 1. card (A - {a} \\<union> {inv a}) = n", "using inv i(2, 3) n a(1)"], ["proof (prove)\nusing this:\n  card (A - {a}) = n - 1\n  inv a \\<notin> A - {a}\n  finite A\n  A \\<subseteq> carrier G\n  n = card A\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. card (A - {a} \\<union> {inv a}) = n", "by (metis Un_empty_right Un_insert_right card.remove card_insert_disjoint finite_Diff)"], ["proof (state)\nthis:\n  card (A - {a} \\<union> {inv a}) = n\n\ngoal (1 subgoal):\n 1. A - {a} \\<union> {inv a} \\<in> all_gens", "moreover"], ["proof (state)\nthis:\n  card (A - {a} \\<union> {inv a}) = n\n\ngoal (1 subgoal):\n 1. A - {a} \\<union> {inv a} \\<in> all_gens", "have \"generate G A = generate G ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generate G A = generate G (A - {a} \\<union> {inv a})", "proof(intro generate_one_switched_eqI[OF i(3) a(1), of _ \"inv a\"])"], ["proof (state)\ngoal (3 subgoals):\n 1. A - {a} \\<union> {inv a} = A - {a} \\<union> {inv a}\n 2. inv a \\<in> generate G A\n 3. a \\<in> generate G (A - {a} \\<union> {inv a})", "show \"inv a \\<in> generate G A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv a \\<in> generate G A", "using generate.inv[OF a(1), of G]"], ["proof (prove)\nusing this:\n  inv a \\<in> generate G A\n\ngoal (1 subgoal):\n 1. inv a \\<in> generate G A", "."], ["proof (state)\nthis:\n  inv a \\<in> generate G A\n\ngoal (2 subgoals):\n 1. A - {a} \\<union> {inv a} = A - {a} \\<union> {inv a}\n 2. a \\<in> generate G (A - {a} \\<union> {inv a})", "show \"a \\<in> generate G ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> generate G (A - {a} \\<union> {inv a})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<in> generate G (A - {a} \\<union> {inv a})", "have \"a \\<in> generate G {inv a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> generate G {inv a}", "using generate.inv[of \"inv a\" \"{inv a}\" G] ac"], ["proof (prove)\nusing this:\n  inv a \\<in> {inv a} \\<Longrightarrow> inv (inv a) \\<in> generate G {inv a}\n  a \\<in> carrier G\n\ngoal (1 subgoal):\n 1. a \\<in> generate G {inv a}", "by simp"], ["proof (state)\nthis:\n  a \\<in> generate G {inv a}\n\ngoal (1 subgoal):\n 1. a \\<in> generate G (A - {a} \\<union> {inv a})", "also"], ["proof (state)\nthis:\n  a \\<in> generate G {inv a}\n\ngoal (1 subgoal):\n 1. a \\<in> generate G (A - {a} \\<union> {inv a})", "have \"\\<dots> \\<subseteq> generate G ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generate G {inv a} \\<subseteq> generate G (A - {a} \\<union> {inv a})", "by (intro mono_generate, blast)"], ["proof (state)\nthis:\n  generate G {inv a} \\<subseteq> generate G (A - {a} \\<union> {inv a})\n\ngoal (1 subgoal):\n 1. a \\<in> generate G (A - {a} \\<union> {inv a})", "finally"], ["proof (chain)\npicking this:\n  a \\<in> generate G (A - {a} \\<union> {inv a})", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<in> generate G (A - {a} \\<union> {inv a})\n\ngoal (1 subgoal):\n 1. a \\<in> generate G (A - {a} \\<union> {inv a})", "."], ["proof (state)\nthis:\n  a \\<in> generate G (A - {a} \\<union> {inv a})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a \\<in> generate G (A - {a} \\<union> {inv a})\n\ngoal (1 subgoal):\n 1. A - {a} \\<union> {inv a} = A - {a} \\<union> {inv a}", "qed simp"], ["proof (state)\nthis:\n  generate G A = generate G (A - {a} \\<union> {inv a})\n\ngoal (1 subgoal):\n 1. A - {a} \\<union> {inv a} \\<in> all_gens", "moreover"], ["proof (state)\nthis:\n  generate G A = generate G (A - {a} \\<union> {inv a})\n\ngoal (1 subgoal):\n 1. A - {a} \\<union> {inv a} \\<in> all_gens", "hence \"?B \\<subseteq> generate G A\""], ["proof (prove)\nusing this:\n  generate G A = generate G (A - {a} \\<union> {inv a})\n\ngoal (1 subgoal):\n 1. A - {a} \\<union> {inv a} \\<subseteq> generate G A", "using generate_sincl"], ["proof (prove)\nusing this:\n  generate G A = generate G (A - {a} \\<union> {inv a})\n  ?A \\<subseteq> generate G ?A\n\ngoal (1 subgoal):\n 1. A - {a} \\<union> {inv a} \\<subseteq> generate G A", "by simp"], ["proof (state)\nthis:\n  A - {a} \\<union> {inv a} \\<subseteq> generate G A\n\ngoal (1 subgoal):\n 1. A - {a} \\<union> {inv a} \\<in> all_gens", "ultimately"], ["proof (chain)\npicking this:\n  card (A - {a} \\<union> {inv a}) = n\n  generate G A = generate G (A - {a} \\<union> {inv a})\n  A - {a} \\<union> {inv a} \\<subseteq> generate G A", "show ?thesis"], ["proof (prove)\nusing this:\n  card (A - {a} \\<union> {inv a}) = n\n  generate G A = generate G (A - {a} \\<union> {inv a})\n  A - {a} \\<union> {inv a} \\<subseteq> generate G A\n\ngoal (1 subgoal):\n 1. A - {a} \\<union> {inv a} \\<in> all_gens", "unfolding all_gens_def"], ["proof (prove)\nusing this:\n  card (A - {a} \\<union> {inv a}) = n\n  generate G A = generate G (A - {a} \\<union> {inv a})\n  A - {a} \\<union> {inv a} \\<subseteq> generate G A\n\ngoal (1 subgoal):\n 1. A - {a} \\<union> {inv a}\n    \\<in> {gs \\<in> Pow (generate G A).\n           finite gs \\<and>\n           card gs \\<le> n \\<and> generate G gs = generate G A}", "using i(2)"], ["proof (prove)\nusing this:\n  card (A - {a} \\<union> {inv a}) = n\n  generate G A = generate G (A - {a} \\<union> {inv a})\n  A - {a} \\<union> {inv a} \\<subseteq> generate G A\n  finite A\n\ngoal (1 subgoal):\n 1. A - {a} \\<union> {inv a}\n    \\<in> {gs \\<in> Pow (generate G A).\n           finite gs \\<and>\n           card gs \\<le> n \\<and> generate G gs = generate G A}", "by blast"], ["proof (state)\nthis:\n  A - {a} \\<union> {inv a} \\<in> all_gens\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A - {a} \\<union> {inv a} \\<in> all_gens\n\ngoal (1 subgoal):\n 1. exps \\<noteq> {}", "moreover"], ["proof (state)\nthis:\n  A - {a} \\<union> {inv a} \\<in> all_gens\n\ngoal (1 subgoal):\n 1. exps \\<noteq> {}", "have \"(\\<exists>r \\<in> relations A. r a > 0) \\<or> (\\<exists>r \\<in> relations ?B. r (inv a) > 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>r\\<in>relations A. 0 < r a) \\<or>\n    (\\<exists>r\\<in>relations (A - {a} \\<union> {inv a}). 0 < r (inv a))", "proof(cases \"\\<exists>r \\<in> relations A. r a > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>r\\<in>relations A. 0 < r a \\<Longrightarrow>\n    (\\<exists>r\\<in>relations A. 0 < r a) \\<or>\n    (\\<exists>r\\<in>relations (A - {a} \\<union> {inv a}). 0 < r (inv a))\n 2. \\<not> (\\<exists>r\\<in>relations A. 0 < r a) \\<Longrightarrow>\n    (\\<exists>r\\<in>relations A. 0 < r a) \\<or>\n    (\\<exists>r\\<in>relations (A - {a} \\<union> {inv a}). 0 < r (inv a))", "case True"], ["proof (state)\nthis:\n  \\<exists>r\\<in>relations A. 0 < r a\n\ngoal (2 subgoals):\n 1. \\<exists>r\\<in>relations A. 0 < r a \\<Longrightarrow>\n    (\\<exists>r\\<in>relations A. 0 < r a) \\<or>\n    (\\<exists>r\\<in>relations (A - {a} \\<union> {inv a}). 0 < r (inv a))\n 2. \\<not> (\\<exists>r\\<in>relations A. 0 < r a) \\<Longrightarrow>\n    (\\<exists>r\\<in>relations A. 0 < r a) \\<or>\n    (\\<exists>r\\<in>relations (A - {a} \\<union> {inv a}). 0 < r (inv a))", "then"], ["proof (chain)\npicking this:\n  \\<exists>r\\<in>relations A. 0 < r a", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>r\\<in>relations A. 0 < r a\n\ngoal (1 subgoal):\n 1. (\\<exists>r\\<in>relations A. 0 < r a) \\<or>\n    (\\<exists>r\\<in>relations (A - {a} \\<union> {inv a}). 0 < r (inv a))", "by blast"], ["proof (state)\nthis:\n  (\\<exists>r\\<in>relations A. 0 < r a) \\<or>\n  (\\<exists>r\\<in>relations (A - {a} \\<union> {inv a}). 0 < r (inv a))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>r\\<in>relations A. 0 < r a) \\<Longrightarrow>\n    (\\<exists>r\\<in>relations A. 0 < r a) \\<or>\n    (\\<exists>r\\<in>relations (A - {a} \\<union> {inv a}). 0 < r (inv a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>r\\<in>relations A. 0 < r a) \\<Longrightarrow>\n    (\\<exists>r\\<in>relations A. 0 < r a) \\<or>\n    (\\<exists>r\\<in>relations (A - {a} \\<union> {inv a}). 0 < r (inv a))", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>r\\<in>relations A. 0 < r a)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>r\\<in>relations A. 0 < r a) \\<Longrightarrow>\n    (\\<exists>r\\<in>relations A. 0 < r a) \\<or>\n    (\\<exists>r\\<in>relations (A - {a} \\<union> {inv a}). 0 < r (inv a))", "with a"], ["proof (chain)\npicking this:\n  a \\<in> A\n  \\<exists>r\\<in>relations A. r a \\<noteq> 0\n  \\<not> (\\<exists>r\\<in>relations A. 0 < r a)", "obtain r where r: \"r \\<in> relations A\" \"r a < 0\""], ["proof (prove)\nusing this:\n  a \\<in> A\n  \\<exists>r\\<in>relations A. r a \\<noteq> 0\n  \\<not> (\\<exists>r\\<in>relations A. 0 < r a)\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>r \\<in> relations A; r a < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  r \\<in> relations A\n  r a < 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>r\\<in>relations A. 0 < r a) \\<Longrightarrow>\n    (\\<exists>r\\<in>relations A. 0 < r a) \\<or>\n    (\\<exists>r\\<in>relations (A - {a} \\<union> {inv a}). 0 < r (inv a))", "have rc: \"(\\<lambda>x. x [^] r x) \\<in> A \\<rightarrow> carrier G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. x [^] r x) \\<in> A \\<rightarrow> carrier G", "using i(3) int_pow_closed"], ["proof (prove)\nusing this:\n  A \\<subseteq> carrier G\n  ?x \\<in> carrier G \\<Longrightarrow> ?x [^] ?i \\<in> carrier G\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. x [^] r x) \\<in> A \\<rightarrow> carrier G", "by fast"], ["proof (state)\nthis:\n  (\\<lambda>x. x [^] r x) \\<in> A \\<rightarrow> carrier G\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>r\\<in>relations A. 0 < r a) \\<Longrightarrow>\n    (\\<exists>r\\<in>relations A. 0 < r a) \\<or>\n    (\\<exists>r\\<in>relations (A - {a} \\<union> {inv a}). 0 < r (inv a))", "let ?r = \"restrict (r(inv a := - r a)) ?B\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>r\\<in>relations A. 0 < r a) \\<Longrightarrow>\n    (\\<exists>r\\<in>relations A. 0 < r a) \\<or>\n    (\\<exists>r\\<in>relations (A - {a} \\<union> {inv a}). 0 < r (inv a))", "have \"?r \\<in> relations ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a})\n    \\<in> relations (A - {a} \\<union> {inv a})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<Otimes>aa\\<in>A - {a} \\<union>\n                     {inv a}. aa [^]\n                              restrict (r(inv a := - r a))\n                               (A - {a} \\<union> {inv a}) aa) =\n    \\<one>\n 2. restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a})\n    \\<in> extensional (A - {a} \\<union> {inv a})", "have \"finprod G (\\<lambda>x. x [^] ?r x) ?B = finprod G (\\<lambda>x. x [^] r x) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Otimes>x\\<in>A - {a} \\<union>\n                    {inv a}. x [^]\n                             restrict (r(inv a := - r a))\n                              (A - {a} \\<union> {inv a}) x) =\n    (\\<Otimes>x\\<in>A. x [^] r x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Otimes>x\\<in>A - {a} \\<union>\n                    {inv a}. x [^]\n                             restrict (r(inv a := - r a))\n                              (A - {a} \\<union> {inv a}) x) =\n    (\\<Otimes>x\\<in>A. x [^] r x)", "have \"finprod G (\\<lambda>x. x [^] ?r x) ?B\n                  = finprod G (\\<lambda>x. x [^] ?r x) (insert (inv a) (A - {a}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Otimes>x\\<in>A - {a} \\<union>\n                    {inv a}. x [^]\n                             restrict (r(inv a := - r a))\n                              (A - {a} \\<union> {inv a}) x) =\n    (\\<Otimes>x\\<in>insert (inv a)\n                     (A -\n                      {a}). x [^]\n                            restrict (r(inv a := - r a))\n                             (A - {a} \\<union> {inv a}) x)", "by simp"], ["proof (state)\nthis:\n  (\\<Otimes>x\\<in>A - {a} \\<union>\n                  {inv a}. x [^]\n                           restrict (r(inv a := - r a))\n                            (A - {a} \\<union> {inv a}) x) =\n  (\\<Otimes>x\\<in>insert (inv a)\n                   (A -\n                    {a}). x [^]\n                          restrict (r(inv a := - r a))\n                           (A - {a} \\<union> {inv a}) x)\n\ngoal (1 subgoal):\n 1. (\\<Otimes>x\\<in>A - {a} \\<union>\n                    {inv a}. x [^]\n                             restrict (r(inv a := - r a))\n                              (A - {a} \\<union> {inv a}) x) =\n    (\\<Otimes>x\\<in>A. x [^] r x)", "also"], ["proof (state)\nthis:\n  (\\<Otimes>x\\<in>A - {a} \\<union>\n                  {inv a}. x [^]\n                           restrict (r(inv a := - r a))\n                            (A - {a} \\<union> {inv a}) x) =\n  (\\<Otimes>x\\<in>insert (inv a)\n                   (A -\n                    {a}). x [^]\n                          restrict (r(inv a := - r a))\n                           (A - {a} \\<union> {inv a}) x)\n\ngoal (1 subgoal):\n 1. (\\<Otimes>x\\<in>A - {a} \\<union>\n                    {inv a}. x [^]\n                             restrict (r(inv a := - r a))\n                              (A - {a} \\<union> {inv a}) x) =\n    (\\<Otimes>x\\<in>A. x [^] r x)", "have \"\\<dots> = (inv a) [^] ?r (inv a) \\<otimes> finprod G (\\<lambda>x. x [^] ?r x) (A - {a})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Otimes>x\\<in>insert (inv a)\n                     (A -\n                      {a}). x [^]\n                            restrict (r(inv a := - r a))\n                             (A - {a} \\<union> {inv a}) x) =\n    inv a [^]\n    restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a})\n     (inv a) \\<otimes>\n    (\\<Otimes>x\\<in>A -\n                    {a}. x [^]\n                         restrict (r(inv a := - r a))\n                          (A - {a} \\<union> {inv a}) x)", "proof(intro finprod_insert[OF _ inv])"], ["proof (state)\ngoal (3 subgoals):\n 1. finite (A - {a})\n 2. (\\<lambda>x.\n        x [^] restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a}) x)\n    \\<in> A - {a} \\<rightarrow> carrier G\n 3. inv a [^]\n    restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a}) (inv a)\n    \\<in> carrier G", "show \"finite (A - {a})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (A - {a})", "using i(2)"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. finite (A - {a})", "by fast"], ["proof (state)\nthis:\n  finite (A - {a})\n\ngoal (2 subgoals):\n 1. (\\<lambda>x.\n        x [^] restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a}) x)\n    \\<in> A - {a} \\<rightarrow> carrier G\n 2. inv a [^]\n    restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a}) (inv a)\n    \\<in> carrier G", "show \"inv a [^] ?r (inv a) \\<in> carrier G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv a [^]\n    restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a}) (inv a)\n    \\<in> carrier G", "using int_pow_closed[OF inv_closed[OF ac]]"], ["proof (prove)\nusing this:\n  inv a [^] ?i \\<in> carrier G\n\ngoal (1 subgoal):\n 1. inv a [^]\n    restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a}) (inv a)\n    \\<in> carrier G", "by fast"], ["proof (state)\nthis:\n  inv a [^] restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a}) (inv a)\n  \\<in> carrier G\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        x [^] restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a}) x)\n    \\<in> A - {a} \\<rightarrow> carrier G", "show \"(\\<lambda>x. x [^] ?r x) \\<in> A - {a} \\<rightarrow> carrier G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        x [^] restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a}) x)\n    \\<in> A - {a} \\<rightarrow> carrier G", "using int_pow_closed i(3)"], ["proof (prove)\nusing this:\n  ?x \\<in> carrier G \\<Longrightarrow> ?x [^] ?i \\<in> carrier G\n  A \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        x [^] restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a}) x)\n    \\<in> A - {a} \\<rightarrow> carrier G", "by fast"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      x [^] restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a}) x)\n  \\<in> A - {a} \\<rightarrow> carrier G\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Otimes>x\\<in>insert (inv a)\n                   (A -\n                    {a}). x [^]\n                          restrict (r(inv a := - r a))\n                           (A - {a} \\<union> {inv a}) x) =\n  inv a [^]\n  restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a}) (inv a) \\<otimes>\n  (\\<Otimes>x\\<in>A -\n                  {a}. x [^]\n                       restrict (r(inv a := - r a))\n                        (A - {a} \\<union> {inv a}) x)\n\ngoal (1 subgoal):\n 1. (\\<Otimes>x\\<in>A - {a} \\<union>\n                    {inv a}. x [^]\n                             restrict (r(inv a := - r a))\n                              (A - {a} \\<union> {inv a}) x) =\n    (\\<Otimes>x\\<in>A. x [^] r x)", "also"], ["proof (state)\nthis:\n  (\\<Otimes>x\\<in>insert (inv a)\n                   (A -\n                    {a}). x [^]\n                          restrict (r(inv a := - r a))\n                           (A - {a} \\<union> {inv a}) x) =\n  inv a [^]\n  restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a}) (inv a) \\<otimes>\n  (\\<Otimes>x\\<in>A -\n                  {a}. x [^]\n                       restrict (r(inv a := - r a))\n                        (A - {a} \\<union> {inv a}) x)\n\ngoal (1 subgoal):\n 1. (\\<Otimes>x\\<in>A - {a} \\<union>\n                    {inv a}. x [^]\n                             restrict (r(inv a := - r a))\n                              (A - {a} \\<union> {inv a}) x) =\n    (\\<Otimes>x\\<in>A. x [^] r x)", "have \"\\<dots> = a [^] r a \\<otimes> finprod G (\\<lambda>x. x [^] r x) (A - {a})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv a [^]\n    restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a})\n     (inv a) \\<otimes>\n    (\\<Otimes>x\\<in>A -\n                    {a}. x [^]\n                         restrict (r(inv a := - r a))\n                          (A - {a} \\<union> {inv a}) x) =\n    a [^] r a \\<otimes> (\\<Otimes>x\\<in>A - {a}. x [^] r x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inv a [^]\n    restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a})\n     (inv a) \\<otimes>\n    (\\<Otimes>x\\<in>A -\n                    {a}. x [^]\n                         restrict (r(inv a := - r a))\n                          (A - {a} \\<union> {inv a}) x) =\n    a [^] r a \\<otimes> (\\<Otimes>x\\<in>A - {a}. x [^] r x)", "have \"(inv a) [^] ?r (inv a) = a [^] r a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv a [^]\n    restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a}) (inv a) =\n    a [^] r a", "by (simp add: int_pow_inv int_pow_neg ac)"], ["proof (state)\nthis:\n  inv a [^]\n  restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a}) (inv a) =\n  a [^] r a\n\ngoal (1 subgoal):\n 1. inv a [^]\n    restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a})\n     (inv a) \\<otimes>\n    (\\<Otimes>x\\<in>A -\n                    {a}. x [^]\n                         restrict (r(inv a := - r a))\n                          (A - {a} \\<union> {inv a}) x) =\n    a [^] r a \\<otimes> (\\<Otimes>x\\<in>A - {a}. x [^] r x)", "moreover"], ["proof (state)\nthis:\n  inv a [^]\n  restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a}) (inv a) =\n  a [^] r a\n\ngoal (1 subgoal):\n 1. inv a [^]\n    restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a})\n     (inv a) \\<otimes>\n    (\\<Otimes>x\\<in>A -\n                    {a}. x [^]\n                         restrict (r(inv a := - r a))\n                          (A - {a} \\<union> {inv a}) x) =\n    a [^] r a \\<otimes> (\\<Otimes>x\\<in>A - {a}. x [^] r x)", "have \"finprod G (\\<lambda>x. x [^] r x) (A - {a})\n                             = finprod G (\\<lambda>x. x [^] ?r x) (A - {a})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Otimes>x\\<in>A - {a}. x [^] r x) =\n    (\\<Otimes>x\\<in>A -\n                    {a}. x [^]\n                         restrict (r(inv a := - r a))\n                          (A - {a} \\<union> {inv a}) x)", "proof(intro finprod_cong)"], ["proof (state)\ngoal (3 subgoals):\n 1. A - {a} = A - {a}\n 2. ((\\<lambda>x. x [^] r x) \\<in> A - {a} \\<rightarrow> carrier G) = True\n 3. \\<And>i.\n       i \\<in> A - {a} =simp=>\n       i [^] r i =\n       i [^] restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a}) i", "show \"((\\<lambda>x. x [^] r x) \\<in> A - {a} \\<rightarrow> carrier G) = True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. x [^] r x) \\<in> A - {a} \\<rightarrow> carrier G) = True", "using rc"], ["proof (prove)\nusing this:\n  (\\<lambda>x. x [^] r x) \\<in> A \\<rightarrow> carrier G\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. x [^] r x) \\<in> A - {a} \\<rightarrow> carrier G) = True", "by blast"], ["proof (state)\nthis:\n  ((\\<lambda>x. x [^] r x) \\<in> A - {a} \\<rightarrow> carrier G) = True\n\ngoal (2 subgoals):\n 1. A - {a} = A - {a}\n 2. \\<And>i.\n       i \\<in> A - {a} =simp=>\n       i [^] r i =\n       i [^] restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a}) i", "have \"i [^] r i = i [^] ?r i\" if \"i \\<in> A - {a}\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. i [^] r i =\n    i [^] restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a}) i", "using that inv"], ["proof (prove)\nusing this:\n  i \\<in> A - {a}\n  inv a \\<notin> A - {a}\n\ngoal (1 subgoal):\n 1. i [^] r i =\n    i [^] restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a}) i", "by auto"], ["proof (state)\nthis:\n  ?i2 \\<in> A - {a} \\<Longrightarrow>\n  ?i2 [^] r ?i2 =\n  ?i2 [^] restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a}) ?i2\n\ngoal (2 subgoals):\n 1. A - {a} = A - {a}\n 2. \\<And>i.\n       i \\<in> A - {a} =simp=>\n       i [^] r i =\n       i [^] restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a}) i", "thus \"\\<And>i. i \\<in> A - {a} =simp=> i [^] r i = i [^] restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a}) i\""], ["proof (prove)\nusing this:\n  ?i2 \\<in> A - {a} \\<Longrightarrow>\n  ?i2 [^] r ?i2 =\n  ?i2 [^] restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a}) ?i2\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> A - {a} =simp=>\n       i [^] r i =\n       i [^] restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a}) i", "by algebra"], ["proof (state)\nthis:\n  ?i2 \\<in> A - {a} =simp=>\n  ?i2 [^] r ?i2 =\n  ?i2 [^] restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a}) ?i2\n\ngoal (1 subgoal):\n 1. A - {a} = A - {a}", "qed simp"], ["proof (state)\nthis:\n  (\\<Otimes>x\\<in>A - {a}. x [^] r x) =\n  (\\<Otimes>x\\<in>A -\n                  {a}. x [^]\n                       restrict (r(inv a := - r a))\n                        (A - {a} \\<union> {inv a}) x)\n\ngoal (1 subgoal):\n 1. inv a [^]\n    restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a})\n     (inv a) \\<otimes>\n    (\\<Otimes>x\\<in>A -\n                    {a}. x [^]\n                         restrict (r(inv a := - r a))\n                          (A - {a} \\<union> {inv a}) x) =\n    a [^] r a \\<otimes> (\\<Otimes>x\\<in>A - {a}. x [^] r x)", "ultimately"], ["proof (chain)\npicking this:\n  inv a [^]\n  restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a}) (inv a) =\n  a [^] r a\n  (\\<Otimes>x\\<in>A - {a}. x [^] r x) =\n  (\\<Otimes>x\\<in>A -\n                  {a}. x [^]\n                       restrict (r(inv a := - r a))\n                        (A - {a} \\<union> {inv a}) x)", "show ?thesis"], ["proof (prove)\nusing this:\n  inv a [^]\n  restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a}) (inv a) =\n  a [^] r a\n  (\\<Otimes>x\\<in>A - {a}. x [^] r x) =\n  (\\<Otimes>x\\<in>A -\n                  {a}. x [^]\n                       restrict (r(inv a := - r a))\n                        (A - {a} \\<union> {inv a}) x)\n\ngoal (1 subgoal):\n 1. inv a [^]\n    restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a})\n     (inv a) \\<otimes>\n    (\\<Otimes>x\\<in>A -\n                    {a}. x [^]\n                         restrict (r(inv a := - r a))\n                          (A - {a} \\<union> {inv a}) x) =\n    a [^] r a \\<otimes> (\\<Otimes>x\\<in>A - {a}. x [^] r x)", "by argo"], ["proof (state)\nthis:\n  inv a [^]\n  restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a}) (inv a) \\<otimes>\n  (\\<Otimes>x\\<in>A -\n                  {a}. x [^]\n                       restrict (r(inv a := - r a))\n                        (A - {a} \\<union> {inv a}) x) =\n  a [^] r a \\<otimes> (\\<Otimes>x\\<in>A - {a}. x [^] r x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inv a [^]\n  restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a}) (inv a) \\<otimes>\n  (\\<Otimes>x\\<in>A -\n                  {a}. x [^]\n                       restrict (r(inv a := - r a))\n                        (A - {a} \\<union> {inv a}) x) =\n  a [^] r a \\<otimes> (\\<Otimes>x\\<in>A - {a}. x [^] r x)\n\ngoal (1 subgoal):\n 1. (\\<Otimes>x\\<in>A - {a} \\<union>\n                    {inv a}. x [^]\n                             restrict (r(inv a := - r a))\n                              (A - {a} \\<union> {inv a}) x) =\n    (\\<Otimes>x\\<in>A. x [^] r x)", "also"], ["proof (state)\nthis:\n  inv a [^]\n  restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a}) (inv a) \\<otimes>\n  (\\<Otimes>x\\<in>A -\n                  {a}. x [^]\n                       restrict (r(inv a := - r a))\n                        (A - {a} \\<union> {inv a}) x) =\n  a [^] r a \\<otimes> (\\<Otimes>x\\<in>A - {a}. x [^] r x)\n\ngoal (1 subgoal):\n 1. (\\<Otimes>x\\<in>A - {a} \\<union>\n                    {inv a}. x [^]\n                             restrict (r(inv a := - r a))\n                              (A - {a} \\<union> {inv a}) x) =\n    (\\<Otimes>x\\<in>A. x [^] r x)", "have \"\\<dots> = finprod G (\\<lambda>x. x [^] r x) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a [^] r a \\<otimes> (\\<Otimes>x\\<in>A - {a}. x [^] r x) =\n    (\\<Otimes>x\\<in>A. x [^] r x)", "by (intro finprod_minus[symmetric, OF a(1) rc i(2)])"], ["proof (state)\nthis:\n  a [^] r a \\<otimes> (\\<Otimes>x\\<in>A - {a}. x [^] r x) =\n  (\\<Otimes>x\\<in>A. x [^] r x)\n\ngoal (1 subgoal):\n 1. (\\<Otimes>x\\<in>A - {a} \\<union>\n                    {inv a}. x [^]\n                             restrict (r(inv a := - r a))\n                              (A - {a} \\<union> {inv a}) x) =\n    (\\<Otimes>x\\<in>A. x [^] r x)", "finally"], ["proof (chain)\npicking this:\n  (\\<Otimes>x\\<in>A - {a} \\<union>\n                  {inv a}. x [^]\n                           restrict (r(inv a := - r a))\n                            (A - {a} \\<union> {inv a}) x) =\n  (\\<Otimes>x\\<in>A. x [^] r x)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Otimes>x\\<in>A - {a} \\<union>\n                  {inv a}. x [^]\n                           restrict (r(inv a := - r a))\n                            (A - {a} \\<union> {inv a}) x) =\n  (\\<Otimes>x\\<in>A. x [^] r x)\n\ngoal (1 subgoal):\n 1. (\\<Otimes>x\\<in>A - {a} \\<union>\n                    {inv a}. x [^]\n                             restrict (r(inv a := - r a))\n                              (A - {a} \\<union> {inv a}) x) =\n    (\\<Otimes>x\\<in>A. x [^] r x)", "."], ["proof (state)\nthis:\n  (\\<Otimes>x\\<in>A - {a} \\<union>\n                  {inv a}. x [^]\n                           restrict (r(inv a := - r a))\n                            (A - {a} \\<union> {inv a}) x) =\n  (\\<Otimes>x\\<in>A. x [^] r x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Otimes>x\\<in>A - {a} \\<union>\n                  {inv a}. x [^]\n                           restrict (r(inv a := - r a))\n                            (A - {a} \\<union> {inv a}) x) =\n  (\\<Otimes>x\\<in>A. x [^] r x)\n\ngoal (2 subgoals):\n 1. (\\<Otimes>aa\\<in>A - {a} \\<union>\n                     {inv a}. aa [^]\n                              restrict (r(inv a := - r a))\n                               (A - {a} \\<union> {inv a}) aa) =\n    \\<one>\n 2. restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a})\n    \\<in> extensional (A - {a} \\<union> {inv a})", "also"], ["proof (state)\nthis:\n  (\\<Otimes>x\\<in>A - {a} \\<union>\n                  {inv a}. x [^]\n                           restrict (r(inv a := - r a))\n                            (A - {a} \\<union> {inv a}) x) =\n  (\\<Otimes>x\\<in>A. x [^] r x)\n\ngoal (2 subgoals):\n 1. (\\<Otimes>aa\\<in>A - {a} \\<union>\n                     {inv a}. aa [^]\n                              restrict (r(inv a := - r a))\n                               (A - {a} \\<union> {inv a}) aa) =\n    \\<one>\n 2. restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a})\n    \\<in> extensional (A - {a} \\<union> {inv a})", "have \"\\<dots> = \\<one>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Otimes>x\\<in>A. x [^] r x) = \\<one>", "using r"], ["proof (prove)\nusing this:\n  r \\<in> relations A\n  r a < 0\n\ngoal (1 subgoal):\n 1. (\\<Otimes>x\\<in>A. x [^] r x) = \\<one>", "unfolding relations_def"], ["proof (prove)\nusing this:\n  r \\<in> {f. (\\<Otimes>a\\<in>A. a [^] f a) = \\<one>} \\<inter> extensional A\n  r a < 0\n\ngoal (1 subgoal):\n 1. (\\<Otimes>x\\<in>A. x [^] r x) = \\<one>", "by fast"], ["proof (state)\nthis:\n  (\\<Otimes>x\\<in>A. x [^] r x) = \\<one>\n\ngoal (2 subgoals):\n 1. (\\<Otimes>aa\\<in>A - {a} \\<union>\n                     {inv a}. aa [^]\n                              restrict (r(inv a := - r a))\n                               (A - {a} \\<union> {inv a}) aa) =\n    \\<one>\n 2. restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a})\n    \\<in> extensional (A - {a} \\<union> {inv a})", "finally"], ["proof (chain)\npicking this:\n  (\\<Otimes>x\\<in>A - {a} \\<union>\n                  {inv a}. x [^]\n                           restrict (r(inv a := - r a))\n                            (A - {a} \\<union> {inv a}) x) =\n  \\<one>", "show \"finprod G (\\<lambda>x. x [^] ?r x) ?B = \\<one>\""], ["proof (prove)\nusing this:\n  (\\<Otimes>x\\<in>A - {a} \\<union>\n                  {inv a}. x [^]\n                           restrict (r(inv a := - r a))\n                            (A - {a} \\<union> {inv a}) x) =\n  \\<one>\n\ngoal (1 subgoal):\n 1. (\\<Otimes>x\\<in>A - {a} \\<union>\n                    {inv a}. x [^]\n                             restrict (r(inv a := - r a))\n                              (A - {a} \\<union> {inv a}) x) =\n    \\<one>", "."], ["proof (state)\nthis:\n  (\\<Otimes>x\\<in>A - {a} \\<union>\n                  {inv a}. x [^]\n                           restrict (r(inv a := - r a))\n                            (A - {a} \\<union> {inv a}) x) =\n  \\<one>\n\ngoal (1 subgoal):\n 1. restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a})\n    \\<in> extensional (A - {a} \\<union> {inv a})", "qed simp"], ["proof (state)\nthis:\n  restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a})\n  \\<in> relations (A - {a} \\<union> {inv a})\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>r\\<in>relations A. 0 < r a) \\<Longrightarrow>\n    (\\<exists>r\\<in>relations A. 0 < r a) \\<or>\n    (\\<exists>r\\<in>relations (A - {a} \\<union> {inv a}). 0 < r (inv a))", "then"], ["proof (chain)\npicking this:\n  restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a})\n  \\<in> relations (A - {a} \\<union> {inv a})", "show ?thesis"], ["proof (prove)\nusing this:\n  restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a})\n  \\<in> relations (A - {a} \\<union> {inv a})\n\ngoal (1 subgoal):\n 1. (\\<exists>r\\<in>relations A. 0 < r a) \\<or>\n    (\\<exists>r\\<in>relations (A - {a} \\<union> {inv a}). 0 < r (inv a))", "using r"], ["proof (prove)\nusing this:\n  restrict (r(inv a := - r a)) (A - {a} \\<union> {inv a})\n  \\<in> relations (A - {a} \\<union> {inv a})\n  r \\<in> relations A\n  r a < 0\n\ngoal (1 subgoal):\n 1. (\\<exists>r\\<in>relations A. 0 < r a) \\<or>\n    (\\<exists>r\\<in>relations (A - {a} \\<union> {inv a}). 0 < r (inv a))", "by fastforce"], ["proof (state)\nthis:\n  (\\<exists>r\\<in>relations A. 0 < r a) \\<or>\n  (\\<exists>r\\<in>relations (A - {a} \\<union> {inv a}). 0 < r (inv a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>r\\<in>relations A. 0 < r a) \\<or>\n  (\\<exists>r\\<in>relations (A - {a} \\<union> {inv a}). 0 < r (inv a))\n\ngoal (1 subgoal):\n 1. exps \\<noteq> {}", "ultimately"], ["proof (chain)\npicking this:\n  A \\<in> all_gens\n  A - {a} \\<union> {inv a} \\<in> all_gens\n  (\\<exists>r\\<in>relations A. 0 < r a) \\<or>\n  (\\<exists>r\\<in>relations (A - {a} \\<union> {inv a}). 0 < r (inv a))", "show ?thesis"], ["proof (prove)\nusing this:\n  A \\<in> all_gens\n  A - {a} \\<union> {inv a} \\<in> all_gens\n  (\\<exists>r\\<in>relations A. 0 < r a) \\<or>\n  (\\<exists>r\\<in>relations (A - {a} \\<union> {inv a}). 0 < r (inv a))\n\ngoal (1 subgoal):\n 1. exps \\<noteq> {}", "unfolding exps_def"], ["proof (prove)\nusing this:\n  A \\<in> all_gens\n  A - {a} \\<union> {inv a} \\<in> all_gens\n  (\\<exists>r\\<in>relations A. 0 < r a) \\<or>\n  (\\<exists>r\\<in>relations (A - {a} \\<union> {inv a}). 0 < r (inv a))\n\ngoal (1 subgoal):\n 1. (\\<Union>gs'\\<in>all_gens.\n        \\<Union>rel\\<in>relations gs'.\n           nat ` {e \\<in> rel ` gs'. 0 < e}) \\<noteq>\n    {}", "using a"], ["proof (prove)\nusing this:\n  A \\<in> all_gens\n  A - {a} \\<union> {inv a} \\<in> all_gens\n  (\\<exists>r\\<in>relations A. 0 < r a) \\<or>\n  (\\<exists>r\\<in>relations (A - {a} \\<union> {inv a}). 0 < r (inv a))\n  a \\<in> A\n  \\<exists>r\\<in>relations A. r a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<Union>gs'\\<in>all_gens.\n        \\<Union>rel\\<in>relations gs'.\n           nat ` {e \\<in> rel ` gs'. 0 < e}) \\<noteq>\n    {}", "by blast"], ["proof (state)\nthis:\n  exps \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  exps \\<noteq> {}\n\ngoal (1 subgoal):\n 1. inv a \\<notin> A - {a} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "hence me: \"min_exp \\<in> exps\""], ["proof (prove)\nusing this:\n  exps \\<noteq> {}\n\ngoal (1 subgoal):\n 1. min_exp \\<in> exps", "unfolding min_exp_def"], ["proof (prove)\nusing this:\n  exps \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Inf exps \\<in> exps", "using Inf_nat_def1"], ["proof (prove)\nusing this:\n  exps \\<noteq> {}\n  ?K \\<noteq> {} \\<Longrightarrow> Inf ?K \\<in> ?K\n\ngoal (1 subgoal):\n 1. Inf exps \\<in> exps", "by force"], ["proof (state)\nthis:\n  min_exp \\<in> exps\n\ngoal (1 subgoal):\n 1. inv a \\<notin> A - {a} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "from cInf_lower min_exp_def"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x \\<in> ?X; bdd_below ?X\\<rbrakk>\n  \\<Longrightarrow> Inf ?X \\<le> ?x\n  min_exp = Inf exps", "have le: \"\\<And>x. x \\<in> exps \\<Longrightarrow> min_exp \\<le> x\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> ?X; bdd_below ?X\\<rbrakk>\n  \\<Longrightarrow> Inf ?X \\<le> ?x\n  min_exp = Inf exps\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> exps \\<Longrightarrow> min_exp \\<le> x", "by blast"], ["proof (state)\nthis:\n  ?x2 \\<in> exps \\<Longrightarrow> min_exp \\<le> ?x2\n\ngoal (1 subgoal):\n 1. inv a \\<notin> A - {a} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "from me"], ["proof (chain)\npicking this:\n  min_exp \\<in> exps", "obtain gs rel g\n        where gr: \"gs \\<in> all_gens\" \"rel \\<in> relations gs\" \"g \\<in> gs\" \"rel g = min_exp\" \"min_exp > 0\""], ["proof (prove)\nusing this:\n  min_exp \\<in> exps\n\ngoal (1 subgoal):\n 1. (\\<And>gs rel g.\n        \\<lbrakk>gs \\<in> all_gens; rel \\<in> relations gs; g \\<in> gs;\n         rel g = int min_exp; 0 < min_exp\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding exps_def"], ["proof (prove)\nusing this:\n  min_exp\n  \\<in> (\\<Union>gs'\\<in>all_gens.\n            \\<Union>rel\\<in>relations gs'. nat ` {e \\<in> rel ` gs'. 0 < e})\n\ngoal (1 subgoal):\n 1. (\\<And>gs rel g.\n        \\<lbrakk>gs \\<in> all_gens; rel \\<in> relations gs; g \\<in> gs;\n         rel g = int min_exp; 0 < min_exp\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  gs \\<in> all_gens\n  rel \\<in> relations gs\n  g \\<in> gs\n  rel g = int min_exp\n  0 < min_exp\n\ngoal (1 subgoal):\n 1. inv a \\<notin> A - {a} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "from gr(1)"], ["proof (chain)\npicking this:\n  gs \\<in> all_gens", "have cgs: \"card gs \\<le> card A\""], ["proof (prove)\nusing this:\n  gs \\<in> all_gens\n\ngoal (1 subgoal):\n 1. card gs \\<le> card A", "unfolding all_gens_def n"], ["proof (prove)\nusing this:\n  gs \\<in> {gs \\<in> Pow (generate G A).\n            finite gs \\<and>\n            card gs \\<le> card A \\<and> generate G gs = generate G A}\n\ngoal (1 subgoal):\n 1. card gs \\<le> card A", "by blast"], ["proof (state)\nthis:\n  card gs \\<le> card A\n\ngoal (1 subgoal):\n 1. inv a \\<notin> A - {a} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "with gr(3)"], ["proof (chain)\npicking this:\n  g \\<in> gs\n  card gs \\<le> card A", "have cgsg: \"card (gs - {g}) < card A\""], ["proof (prove)\nusing this:\n  g \\<in> gs\n  card gs \\<le> card A\n\ngoal (1 subgoal):\n 1. card (gs - {g}) < card A", "by (metis Ane card.infinite card_Diff1_less card_gt_0_iff finite.emptyI\n                  finite.insertI finite_Diff2 i.prems(1) le_neq_implies_less less_trans)"], ["proof (state)\nthis:\n  card (gs - {g}) < card A\n\ngoal (1 subgoal):\n 1. inv a \\<notin> A - {a} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "from gr(1)"], ["proof (chain)\npicking this:\n  gs \\<in> all_gens", "have fgs: \"finite gs\" and gsg: \"generate G gs = generate G A\""], ["proof (prove)\nusing this:\n  gs \\<in> all_gens\n\ngoal (1 subgoal):\n 1. finite gs &&& generate G gs = generate G A", "unfolding all_gens_def n"], ["proof (prove)\nusing this:\n  gs \\<in> {gs \\<in> Pow (generate G A).\n            finite gs \\<and>\n            card gs \\<le> card A \\<and> generate G gs = generate G A}\n\ngoal (1 subgoal):\n 1. finite gs &&& generate G gs = generate G A", "using i(2) card.infinite Ane"], ["proof (prove)\nusing this:\n  gs \\<in> {gs \\<in> Pow (generate G A).\n            finite gs \\<and>\n            card gs \\<le> card A \\<and> generate G gs = generate G A}\n  finite A\n  infinite ?A \\<Longrightarrow> card ?A = 0\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. finite gs &&& generate G gs = generate G A", "by force+"], ["proof (state)\nthis:\n  finite gs\n  generate G gs = generate G A\n\ngoal (1 subgoal):\n 1. inv a \\<notin> A - {a} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "from gsg"], ["proof (chain)\npicking this:\n  generate G gs = generate G A", "have gsc: \"gs \\<subseteq> carrier G\""], ["proof (prove)\nusing this:\n  generate G gs = generate G A\n\ngoal (1 subgoal):\n 1. gs \\<subseteq> carrier G", "unfolding all_gens_def"], ["proof (prove)\nusing this:\n  generate G gs = generate G A\n\ngoal (1 subgoal):\n 1. gs \\<subseteq> carrier G", "using generate_incl[OF i(3)] generate_sincl[of gs]"], ["proof (prove)\nusing this:\n  generate G gs = generate G A\n  generate G A \\<subseteq> carrier G\n  gs \\<subseteq> generate G gs\n\ngoal (1 subgoal):\n 1. gs \\<subseteq> carrier G", "by simp"], ["proof (state)\nthis:\n  gs \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. inv a \\<notin> A - {a} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "hence gc: \"g \\<in> carrier G\""], ["proof (prove)\nusing this:\n  gs \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. g \\<in> carrier G", "using gr(3)"], ["proof (prove)\nusing this:\n  gs \\<subseteq> carrier G\n  g \\<in> gs\n\ngoal (1 subgoal):\n 1. g \\<in> carrier G", "by blast"], ["proof (state)\nthis:\n  g \\<in> carrier G\n\ngoal (1 subgoal):\n 1. inv a \\<notin> A - {a} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "have ihgsg: \"?t (gs - {g})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>gsa.\n       set gsa \\<subseteq> generate G (gs - {g}) \\<and>\n       cycle gsa \\<and>\n       is_idirprod (generate G (gs - {g})) (\\<lambda>g. generate G {g})\n        (set gsa) \\<and>\n       successively (dvd) (map ord gsa) \\<and>\n       card (set gsa) \\<le> card (gs - {g})", "by (intro iH, use cgs fgs gsc gr(3) cgsg in auto)"], ["proof (state)\nthis:\n  \\<exists>gsa.\n     set gsa \\<subseteq> generate G (gs - {g}) \\<and>\n     cycle gsa \\<and>\n     is_idirprod (generate G (gs - {g})) (\\<lambda>g. generate G {g})\n      (set gsa) \\<and>\n     successively (dvd) (map ord gsa) \\<and>\n     card (set gsa) \\<le> card (gs - {g})\n\ngoal (1 subgoal):\n 1. inv a \\<notin> A - {a} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "then"], ["proof (chain)\npicking this:\n  \\<exists>gsa.\n     set gsa \\<subseteq> generate G (gs - {g}) \\<and>\n     cycle gsa \\<and>\n     is_idirprod (generate G (gs - {g})) (\\<lambda>g. generate G {g})\n      (set gsa) \\<and>\n     successively (dvd) (map ord gsa) \\<and>\n     card (set gsa) \\<le> card (gs - {g})", "obtain hs where\n        hs: \"set hs \\<subseteq> generate G (gs - {g})\" \"distinct hs\"\n            \"is_idirprod (generate G (gs - {g})) (\\<lambda>g. generate G {g}) (set hs)\"\n            \"successively (dvd) (map ord hs)\" \"card (set hs) \\<le> card (gs - {g})\""], ["proof (prove)\nusing this:\n  \\<exists>gsa.\n     set gsa \\<subseteq> generate G (gs - {g}) \\<and>\n     cycle gsa \\<and>\n     is_idirprod (generate G (gs - {g})) (\\<lambda>g. generate G {g})\n      (set gsa) \\<and>\n     successively (dvd) (map ord gsa) \\<and>\n     card (set gsa) \\<le> card (gs - {g})\n\ngoal (1 subgoal):\n 1. (\\<And>hs.\n        \\<lbrakk>set hs \\<subseteq> generate G (gs - {g}); cycle hs;\n         is_idirprod (generate G (gs - {g})) (\\<lambda>g. generate G {g})\n          (set hs);\n         successively (dvd) (map ord hs);\n         card (set hs) \\<le> card (gs - {g})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  set hs \\<subseteq> generate G (gs - {g})\n  cycle hs\n  is_idirprod (generate G (gs - {g})) (\\<lambda>g. generate G {g}) (set hs)\n  successively (dvd) (map ord hs)\n  card (set hs) \\<le> card (gs - {g})\n\ngoal (1 subgoal):\n 1. inv a \\<notin> A - {a} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "hence hsc: \"set hs \\<subseteq> carrier G\""], ["proof (prove)\nusing this:\n  set hs \\<subseteq> generate G (gs - {g})\n  cycle hs\n  is_idirprod (generate G (gs - {g})) (\\<lambda>g. generate G {g}) (set hs)\n  successively (dvd) (map ord hs)\n  card (set hs) \\<le> card (gs - {g})\n\ngoal (1 subgoal):\n 1. set hs \\<subseteq> carrier G", "using generate_sincl[of \"set hs\"] generate_incl[of \"gs - {g}\"] gsc"], ["proof (prove)\nusing this:\n  set hs \\<subseteq> generate G (gs - {g})\n  cycle hs\n  is_idirprod (generate G (gs - {g})) (\\<lambda>g. generate G {g}) (set hs)\n  successively (dvd) (map ord hs)\n  card (set hs) \\<le> card (gs - {g})\n  set hs \\<subseteq> generate G (set hs)\n  gs - {g} \\<subseteq> carrier G \\<Longrightarrow>\n  generate G (gs - {g}) \\<subseteq> carrier G\n  gs \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. set hs \\<subseteq> carrier G", "by blast"], ["proof (state)\nthis:\n  set hs \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. inv a \\<notin> A - {a} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "from hs(3)"], ["proof (chain)\npicking this:\n  is_idirprod (generate G (gs - {g})) (\\<lambda>g. generate G {g}) (set hs)", "have ghs: \"generate G (gs - {g}) = generate G (set hs)\""], ["proof (prove)\nusing this:\n  is_idirprod (generate G (gs - {g})) (\\<lambda>g. generate G {g}) (set hs)\n\ngoal (1 subgoal):\n 1. generate G (gs - {g}) = generate G (set hs)", "unfolding is_idirprod_def IDirProds_def"], ["proof (prove)\nusing this:\n  (\\<forall>i\\<in>set hs. generate G {i} \\<lhd> G) \\<and>\n  generate G (gs - {g}) =\n  generate G (\\<Union>g\\<in>set hs. generate G {g}) \\<and>\n  compl_fam (\\<lambda>g. generate G {g}) (set hs)\n\ngoal (1 subgoal):\n 1. generate G (gs - {g}) = generate G (set hs)", "using generate_idem_Un[OF hsc]"], ["proof (prove)\nusing this:\n  (\\<forall>i\\<in>set hs. generate G {i} \\<lhd> G) \\<and>\n  generate G (gs - {g}) =\n  generate G (\\<Union>g\\<in>set hs. generate G {g}) \\<and>\n  compl_fam (\\<lambda>g. generate G {g}) (set hs)\n  generate G (\\<Union>x\\<in>set hs. generate G {x}) = generate G (set hs)\n\ngoal (1 subgoal):\n 1. generate G (gs - {g}) = generate G (set hs)", "by argo"], ["proof (state)\nthis:\n  generate G (gs - {g}) = generate G (set hs)\n\ngoal (1 subgoal):\n 1. inv a \\<notin> A - {a} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "have dvot: \"?t A \\<or> (\\<forall>e\\<in>rel`gs. rel g dvd e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>gs.\n        set gs \\<subseteq> generate G A \\<and>\n        cycle gs \\<and>\n        is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n         (set gs) \\<and>\n        successively (dvd) (map ord gs) \\<and>\n        card (set gs) \\<le> card A) \\<or>\n    (\\<forall>e\\<in>rel ` gs. rel g dvd e)", "proof(intro disjCI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>e\\<in>rel ` gs. rel g dvd e) \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "assume na: \"\\<not> (\\<forall>e\\<in>rel ` gs. rel g dvd e)\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>e\\<in>rel ` gs. rel g dvd e)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>e\\<in>rel ` gs. rel g dvd e) \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "have \"\\<And>x. \\<lbrakk>x \\<in> gs; \\<not>rel g dvd rel x\\<rbrakk> \\<Longrightarrow> ?t A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>gs.\n                            set gs \\<subseteq> generate G A \\<and>\n                            cycle gs \\<and>\n                            is_idirprod (generate G A)\n                             (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                            successively (dvd) (map ord gs) \\<and>\n                            card (set gs) \\<le> card A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>gs.\n                            set gs \\<subseteq> generate G A \\<and>\n                            cycle gs \\<and>\n                            is_idirprod (generate G A)\n                             (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                            successively (dvd) (map ord gs) \\<and>\n                            card (set gs) \\<le> card A", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>gs.\n                            set gs \\<subseteq> generate G A \\<and>\n                            cycle gs \\<and>\n                            is_idirprod (generate G A)\n                             (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                            successively (dvd) (map ord gs) \\<and>\n                            card (set gs) \\<le> card A", "assume x: \"x \\<in> gs\" \"\\<not> rel g dvd rel x\""], ["proof (state)\nthis:\n  x \\<in> gs\n  \\<not> rel g dvd rel x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>gs.\n                            set gs \\<subseteq> generate G A \\<and>\n                            cycle gs \\<and>\n                            is_idirprod (generate G A)\n                             (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                            successively (dvd) (map ord gs) \\<and>\n                            card (set gs) \\<le> card A", "hence xng: \"x \\<noteq> g\""], ["proof (prove)\nusing this:\n  x \\<in> gs\n  \\<not> rel g dvd rel x\n\ngoal (1 subgoal):\n 1. x \\<noteq> g", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> g\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>gs.\n                            set gs \\<subseteq> generate G A \\<and>\n                            cycle gs \\<and>\n                            is_idirprod (generate G A)\n                             (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                            successively (dvd) (map ord gs) \\<and>\n                            card (set gs) \\<le> card A", "from x"], ["proof (chain)\npicking this:\n  x \\<in> gs\n  \\<not> rel g dvd rel x", "have xc: \"x \\<in> carrier G\""], ["proof (prove)\nusing this:\n  x \\<in> gs\n  \\<not> rel g dvd rel x\n\ngoal (1 subgoal):\n 1. x \\<in> carrier G", "using gsc"], ["proof (prove)\nusing this:\n  x \\<in> gs\n  \\<not> rel g dvd rel x\n  gs \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. x \\<in> carrier G", "by blast"], ["proof (state)\nthis:\n  x \\<in> carrier G\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>gs.\n                            set gs \\<subseteq> generate G A \\<and>\n                            cycle gs \\<and>\n                            is_idirprod (generate G A)\n                             (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                            successively (dvd) (map ord gs) \\<and>\n                            card (set gs) \\<le> card A", "have rg: \"rel g > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < rel g", "using gr"], ["proof (prove)\nusing this:\n  gs \\<in> all_gens\n  rel \\<in> relations gs\n  g \\<in> gs\n  rel g = int min_exp\n  0 < min_exp\n\ngoal (1 subgoal):\n 1. 0 < rel g", "by simp"], ["proof (state)\nthis:\n  0 < rel g\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>gs.\n                            set gs \\<subseteq> generate G A \\<and>\n                            cycle gs \\<and>\n                            is_idirprod (generate G A)\n                             (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                            successively (dvd) (map ord gs) \\<and>\n                            card (set gs) \\<le> card A", "define r::int where r: \"r = rel x mod rel g\""], ["proof (state)\nthis:\n  r = rel x mod rel g\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>gs.\n                            set gs \\<subseteq> generate G A \\<and>\n                            cycle gs \\<and>\n                            is_idirprod (generate G A)\n                             (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                            successively (dvd) (map ord gs) \\<and>\n                            card (set gs) \\<le> card A", "define q::int where q: \"q = rel x div rel g\""], ["proof (state)\nthis:\n  q = rel x div rel g\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>gs.\n                            set gs \\<subseteq> generate G A \\<and>\n                            cycle gs \\<and>\n                            is_idirprod (generate G A)\n                             (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                            successively (dvd) (map ord gs) \\<and>\n                            card (set gs) \\<le> card A", "from r rg x"], ["proof (chain)\npicking this:\n  r = rel x mod rel g\n  0 < rel g\n  x \\<in> gs\n  \\<not> rel g dvd rel x", "have \"r > 0\""], ["proof (prove)\nusing this:\n  r = rel x mod rel g\n  0 < rel g\n  x \\<in> gs\n  \\<not> rel g dvd rel x\n\ngoal (1 subgoal):\n 1. 0 < r", "using mod_int_pos_iff[of \"rel x\" \"rel g\"] mod_eq_0_iff_dvd"], ["proof (prove)\nusing this:\n  r = rel x mod rel g\n  0 < rel g\n  x \\<in> gs\n  \\<not> rel g dvd rel x\n  (0 \\<le> rel x mod rel g) =\n  (rel g dvd rel x \\<or> rel g = 0 \\<and> 0 \\<le> rel x \\<or> 0 < rel g)\n  (?a mod ?b = (0::?'a)) = (?b dvd ?a)\n\ngoal (1 subgoal):\n 1. 0 < r", "by force"], ["proof (state)\nthis:\n  0 < r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>gs.\n                            set gs \\<subseteq> generate G A \\<and>\n                            cycle gs \\<and>\n                            is_idirprod (generate G A)\n                             (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                            successively (dvd) (map ord gs) \\<and>\n                            card (set gs) \\<le> card A", "moreover"], ["proof (state)\nthis:\n  0 < r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>gs.\n                            set gs \\<subseteq> generate G A \\<and>\n                            cycle gs \\<and>\n                            is_idirprod (generate G A)\n                             (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                            successively (dvd) (map ord gs) \\<and>\n                            card (set gs) \\<le> card A", "have \"r < rel g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r < rel g", "using r rg Euclidean_Division.pos_mod_bound"], ["proof (prove)\nusing this:\n  r = rel x mod rel g\n  0 < rel g\n  0 < ?l \\<Longrightarrow> ?k mod ?l < ?l\n\ngoal (1 subgoal):\n 1. r < rel g", "by blast"], ["proof (state)\nthis:\n  r < rel g\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>gs.\n                            set gs \\<subseteq> generate G A \\<and>\n                            cycle gs \\<and>\n                            is_idirprod (generate G A)\n                             (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                            successively (dvd) (map ord gs) \\<and>\n                            card (set gs) \\<le> card A", "moreover"], ["proof (state)\nthis:\n  r < rel g\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>gs.\n                            set gs \\<subseteq> generate G A \\<and>\n                            cycle gs \\<and>\n                            is_idirprod (generate G A)\n                             (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                            successively (dvd) (map ord gs) \\<and>\n                            card (set gs) \\<le> card A", "have \"rel x = q * rel g + r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel x = q * rel g + r", "using r q"], ["proof (prove)\nusing this:\n  r = rel x mod rel g\n  q = rel x div rel g\n\ngoal (1 subgoal):\n 1. rel x = q * rel g + r", "by presburger"], ["proof (state)\nthis:\n  rel x = q * rel g + r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>gs.\n                            set gs \\<subseteq> generate G A \\<and>\n                            cycle gs \\<and>\n                            is_idirprod (generate G A)\n                             (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                            successively (dvd) (map ord gs) \\<and>\n                            card (set gs) \\<le> card A", "ultimately"], ["proof (chain)\npicking this:\n  0 < r\n  r < rel g\n  rel x = q * rel g + r", "have rq: \"rel x = q * (rel g) + r\" \"0 < r\" \"r < rel g\""], ["proof (prove)\nusing this:\n  0 < r\n  r < rel g\n  rel x = q * rel g + r\n\ngoal (1 subgoal):\n 1. rel x = q * rel g + r &&& 0 < r &&& r < rel g", "by auto"], ["proof (state)\nthis:\n  rel x = q * rel g + r\n  0 < r\n  r < rel g\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>gs.\n                            set gs \\<subseteq> generate G A \\<and>\n                            cycle gs \\<and>\n                            is_idirprod (generate G A)\n                             (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                            successively (dvd) (map ord gs) \\<and>\n                            card (set gs) \\<le> card A", "define t where t: \"t = g \\<otimes> x [^] q\""], ["proof (state)\nthis:\n  t = g \\<otimes> x [^] q\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>gs.\n                            set gs \\<subseteq> generate G A \\<and>\n                            cycle gs \\<and>\n                            is_idirprod (generate G A)\n                             (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                            successively (dvd) (map ord gs) \\<and>\n                            card (set gs) \\<le> card A", "hence tc: \"t \\<in> carrier G\""], ["proof (prove)\nusing this:\n  t = g \\<otimes> x [^] q\n\ngoal (1 subgoal):\n 1. t \\<in> carrier G", "using gsc gr(3) x"], ["proof (prove)\nusing this:\n  t = g \\<otimes> x [^] q\n  gs \\<subseteq> carrier G\n  g \\<in> gs\n  x \\<in> gs\n  \\<not> rel g dvd rel x\n\ngoal (1 subgoal):\n 1. t \\<in> carrier G", "by fast"], ["proof (state)\nthis:\n  t \\<in> carrier G\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>gs.\n                            set gs \\<subseteq> generate G A \\<and>\n                            cycle gs \\<and>\n                            is_idirprod (generate G A)\n                             (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                            successively (dvd) (map ord gs) \\<and>\n                            card (set gs) \\<le> card A", "define s where s: \"s = gs - {g} \\<union> {t}\""], ["proof (state)\nthis:\n  s = gs - {g} \\<union> {t}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>gs.\n                            set gs \\<subseteq> generate G A \\<and>\n                            cycle gs \\<and>\n                            is_idirprod (generate G A)\n                             (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                            successively (dvd) (map ord gs) \\<and>\n                            card (set gs) \\<le> card A", "hence fs: \"finite s\""], ["proof (prove)\nusing this:\n  s = gs - {g} \\<union> {t}\n\ngoal (1 subgoal):\n 1. finite s", "using fgs"], ["proof (prove)\nusing this:\n  s = gs - {g} \\<union> {t}\n  finite gs\n\ngoal (1 subgoal):\n 1. finite s", "by blast"], ["proof (state)\nthis:\n  finite s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>gs.\n                            set gs \\<subseteq> generate G A \\<and>\n                            cycle gs \\<and>\n                            is_idirprod (generate G A)\n                             (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                            successively (dvd) (map ord gs) \\<and>\n                            card (set gs) \\<le> card A", "have sc: \"s \\<subseteq> carrier G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<subseteq> carrier G", "using s tc gsc"], ["proof (prove)\nusing this:\n  s = gs - {g} \\<union> {t}\n  t \\<in> carrier G\n  gs \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. s \\<subseteq> carrier G", "by blast"], ["proof (state)\nthis:\n  s \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>gs.\n                            set gs \\<subseteq> generate G A \\<and>\n                            cycle gs \\<and>\n                            is_idirprod (generate G A)\n                             (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                            successively (dvd) (map ord gs) \\<and>\n                            card (set gs) \\<le> card A", "have g: \"generate G gs = generate G s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generate G gs = generate G s", "proof(unfold s, intro generate_one_switched_eqI[OF gsc gr(3), of _ t])"], ["proof (state)\ngoal (3 subgoals):\n 1. gs - {g} \\<union> {t} = gs - {g} \\<union> {t}\n 2. t \\<in> generate G gs\n 3. g \\<in> generate G (gs - {g} \\<union> {t})", "show \"t \\<in> generate G gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> generate G gs", "proof(unfold t, intro generate.eng)"], ["proof (state)\ngoal (2 subgoals):\n 1. g \\<in> generate G gs\n 2. x [^] q \\<in> generate G gs", "show \"g \\<in> generate G gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<in> generate G gs", "using gr(3) generate.incl"], ["proof (prove)\nusing this:\n  g \\<in> gs\n  ?h \\<in> ?H \\<Longrightarrow> ?h \\<in> generate ?G ?H\n\ngoal (1 subgoal):\n 1. g \\<in> generate G gs", "by fast"], ["proof (state)\nthis:\n  g \\<in> generate G gs\n\ngoal (1 subgoal):\n 1. x [^] q \\<in> generate G gs", "show \"x [^] q \\<in> generate G gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x [^] q \\<in> generate G gs", "using x generate_pow[OF xc] generate_sincl[of \"{x}\"] mono_generate[of \"{x}\" gs]"], ["proof (prove)\nusing this:\n  x \\<in> gs\n  \\<not> rel g dvd rel x\n  generate G {x} = {x [^] k |k. k \\<in> UNIV}\n  {x} \\<subseteq> generate G {x}\n  {x} \\<subseteq> gs \\<Longrightarrow>\n  generate G {x} \\<subseteq> generate G gs\n\ngoal (1 subgoal):\n 1. x [^] q \\<in> generate G gs", "by fast"], ["proof (state)\nthis:\n  x [^] q \\<in> generate G gs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t \\<in> generate G gs\n\ngoal (2 subgoals):\n 1. gs - {g} \\<union> {t} = gs - {g} \\<union> {t}\n 2. g \\<in> generate G (gs - {g} \\<union> {t})", "show \"g \\<in> generate G (gs - {g} \\<union> {t})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<in> generate G (gs - {g} \\<union> {t})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. g \\<in> generate G (gs - {g} \\<union> {t})", "have gti: \"g = t \\<otimes> inv (x [^] q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g = t \\<otimes> inv (x [^] q)", "using inv_solve_right[OF gc tc int_pow_closed[OF xc, of q]] t"], ["proof (prove)\nusing this:\n  (g = t \\<otimes> inv (x [^] q)) = (t = g \\<otimes> x [^] q)\n  t = g \\<otimes> x [^] q\n\ngoal (1 subgoal):\n 1. g = t \\<otimes> inv (x [^] q)", "by blast"], ["proof (state)\nthis:\n  g = t \\<otimes> inv (x [^] q)\n\ngoal (1 subgoal):\n 1. g \\<in> generate G (gs - {g} \\<union> {t})", "moreover"], ["proof (state)\nthis:\n  g = t \\<otimes> inv (x [^] q)\n\ngoal (1 subgoal):\n 1. g \\<in> generate G (gs - {g} \\<union> {t})", "have \"t \\<in> generate G (gs - {g} \\<union> {t})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> generate G (gs - {g} \\<union> {t})", "by (intro generate.incl[of t], simp)"], ["proof (state)\nthis:\n  t \\<in> generate G (gs - {g} \\<union> {t})\n\ngoal (1 subgoal):\n 1. g \\<in> generate G (gs - {g} \\<union> {t})", "moreover"], ["proof (state)\nthis:\n  t \\<in> generate G (gs - {g} \\<union> {t})\n\ngoal (1 subgoal):\n 1. g \\<in> generate G (gs - {g} \\<union> {t})", "have \"inv (x [^] q) \\<in> generate G (gs - {g})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv (x [^] q) \\<in> generate G (gs - {g})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inv (x [^] q) \\<in> generate G (gs - {g})", "have \"x [^] q \\<in> generate G {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x [^] q \\<in> generate G {x}", "using generate_pow[OF xc]"], ["proof (prove)\nusing this:\n  generate G {x} = {x [^] k |k. k \\<in> UNIV}\n\ngoal (1 subgoal):\n 1. x [^] q \\<in> generate G {x}", "by blast"], ["proof (state)\nthis:\n  x [^] q \\<in> generate G {x}\n\ngoal (1 subgoal):\n 1. inv (x [^] q) \\<in> generate G (gs - {g})", "from generate_m_inv_closed[OF _ this] xc"], ["proof (chain)\npicking this:\n  {x} \\<subseteq> carrier G \\<Longrightarrow>\n  inv (x [^] q) \\<in> generate G {x}\n  x \\<in> carrier G", "have \"inv (x [^] q) \\<in> generate G {x}\""], ["proof (prove)\nusing this:\n  {x} \\<subseteq> carrier G \\<Longrightarrow>\n  inv (x [^] q) \\<in> generate G {x}\n  x \\<in> carrier G\n\ngoal (1 subgoal):\n 1. inv (x [^] q) \\<in> generate G {x}", "by blast"], ["proof (state)\nthis:\n  inv (x [^] q) \\<in> generate G {x}\n\ngoal (1 subgoal):\n 1. inv (x [^] q) \\<in> generate G (gs - {g})", "moreover"], ["proof (state)\nthis:\n  inv (x [^] q) \\<in> generate G {x}\n\ngoal (1 subgoal):\n 1. inv (x [^] q) \\<in> generate G (gs - {g})", "have \"generate G {x} \\<subseteq> generate G (gs - {g})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generate G {x} \\<subseteq> generate G (gs - {g})", "by (intro mono_generate, use x a in force)"], ["proof (state)\nthis:\n  generate G {x} \\<subseteq> generate G (gs - {g})\n\ngoal (1 subgoal):\n 1. inv (x [^] q) \\<in> generate G (gs - {g})", "finally"], ["proof (chain)\npicking this:\n  inv (x [^] q) \\<in> generate G (gs - {g})", "show ?thesis"], ["proof (prove)\nusing this:\n  inv (x [^] q) \\<in> generate G (gs - {g})\n\ngoal (1 subgoal):\n 1. inv (x [^] q) \\<in> generate G (gs - {g})", "."], ["proof (state)\nthis:\n  inv (x [^] q) \\<in> generate G (gs - {g})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inv (x [^] q) \\<in> generate G (gs - {g})\n\ngoal (1 subgoal):\n 1. g \\<in> generate G (gs - {g} \\<union> {t})", "ultimately"], ["proof (chain)\npicking this:\n  g = t \\<otimes> inv (x [^] q)\n  t \\<in> generate G (gs - {g} \\<union> {t})\n  inv (x [^] q) \\<in> generate G (gs - {g})", "show ?thesis"], ["proof (prove)\nusing this:\n  g = t \\<otimes> inv (x [^] q)\n  t \\<in> generate G (gs - {g} \\<union> {t})\n  inv (x [^] q) \\<in> generate G (gs - {g})\n\ngoal (1 subgoal):\n 1. g \\<in> generate G (gs - {g} \\<union> {t})", "using generate.eng mono_generate[of \"gs - {g}\" \"gs - {g} \\<union> {t}\"]"], ["proof (prove)\nusing this:\n  g = t \\<otimes> inv (x [^] q)\n  t \\<in> generate G (gs - {g} \\<union> {t})\n  inv (x [^] q) \\<in> generate G (gs - {g})\n  \\<lbrakk>?h1.0 \\<in> generate ?G ?H; ?h2.0 \\<in> generate ?G ?H\\<rbrakk>\n  \\<Longrightarrow> ?h1.0 \\<otimes>\\<^bsub>?G\\<^esub> ?h2.0\n                    \\<in> generate ?G ?H\n  gs - {g} \\<subseteq> gs - {g} \\<union> {t} \\<Longrightarrow>\n  generate G (gs - {g}) \\<subseteq> generate G (gs - {g} \\<union> {t})\n\ngoal (1 subgoal):\n 1. g \\<in> generate G (gs - {g} \\<union> {t})", "by fast"], ["proof (state)\nthis:\n  g \\<in> generate G (gs - {g} \\<union> {t})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  g \\<in> generate G (gs - {g} \\<union> {t})\n\ngoal (1 subgoal):\n 1. gs - {g} \\<union> {t} = gs - {g} \\<union> {t}", "qed simp"], ["proof (state)\nthis:\n  generate G gs = generate G s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>gs.\n                            set gs \\<subseteq> generate G A \\<and>\n                            cycle gs \\<and>\n                            is_idirprod (generate G A)\n                             (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                            successively (dvd) (map ord gs) \\<and>\n                            card (set gs) \\<le> card A", "show \"\\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x\\<rbrakk> \\<Longrightarrow> ?t A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gs.\n                         set gs \\<subseteq> generate G A \\<and>\n                         cycle gs \\<and>\n                         is_idirprod (generate G A)\n                          (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                         successively (dvd) (map ord gs) \\<and>\n                         card (set gs) \\<le> card A", "proof (cases \"t \\<in> gs - {g}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x; t \\<in> gs - {g}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gs.\n                         set gs \\<subseteq> generate G A \\<and>\n                         cycle gs \\<and>\n                         is_idirprod (generate G A)\n                          (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                         successively (dvd) (map ord gs) \\<and>\n                         card (set gs) \\<le> card A\n 2. \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x;\n     t \\<notin> gs - {g}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gs.\n                         set gs \\<subseteq> generate G A \\<and>\n                         cycle gs \\<and>\n                         is_idirprod (generate G A)\n                          (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                         successively (dvd) (map ord gs) \\<and>\n                         card (set gs) \\<le> card A", "case xt: True"], ["proof (state)\nthis:\n  t \\<in> gs - {g}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x; t \\<in> gs - {g}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gs.\n                         set gs \\<subseteq> generate G A \\<and>\n                         cycle gs \\<and>\n                         is_idirprod (generate G A)\n                          (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                         successively (dvd) (map ord gs) \\<and>\n                         card (set gs) \\<le> card A\n 2. \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x;\n     t \\<notin> gs - {g}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gs.\n                         set gs \\<subseteq> generate G A \\<and>\n                         cycle gs \\<and>\n                         is_idirprod (generate G A)\n                          (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                         successively (dvd) (map ord gs) \\<and>\n                         card (set gs) \\<le> card A", "from xt"], ["proof (chain)\npicking this:\n  t \\<in> gs - {g}", "have gts: \"s = gs - {g}\""], ["proof (prove)\nusing this:\n  t \\<in> gs - {g}\n\ngoal (1 subgoal):\n 1. s = gs - {g}", "using x s"], ["proof (prove)\nusing this:\n  t \\<in> gs - {g}\n  x \\<in> gs\n  \\<not> rel g dvd rel x\n  s = gs - {g} \\<union> {t}\n\ngoal (1 subgoal):\n 1. s = gs - {g}", "by auto"], ["proof (state)\nthis:\n  s = gs - {g}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x; t \\<in> gs - {g}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gs.\n                         set gs \\<subseteq> generate G A \\<and>\n                         cycle gs \\<and>\n                         is_idirprod (generate G A)\n                          (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                         successively (dvd) (map ord gs) \\<and>\n                         card (set gs) \\<le> card A\n 2. \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x;\n     t \\<notin> gs - {g}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gs.\n                         set gs \\<subseteq> generate G A \\<and>\n                         cycle gs \\<and>\n                         is_idirprod (generate G A)\n                          (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                         successively (dvd) (map ord gs) \\<and>\n                         card (set gs) \\<le> card A", "moreover"], ["proof (state)\nthis:\n  s = gs - {g}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x; t \\<in> gs - {g}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gs.\n                         set gs \\<subseteq> generate G A \\<and>\n                         cycle gs \\<and>\n                         is_idirprod (generate G A)\n                          (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                         successively (dvd) (map ord gs) \\<and>\n                         card (set gs) \\<le> card A\n 2. \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x;\n     t \\<notin> gs - {g}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gs.\n                         set gs \\<subseteq> generate G A \\<and>\n                         cycle gs \\<and>\n                         is_idirprod (generate G A)\n                          (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                         successively (dvd) (map ord gs) \\<and>\n                         card (set gs) \\<le> card A", "have \"card (gs - {g}) < card gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (gs - {g}) < card gs", "using fgs gr(3)"], ["proof (prove)\nusing this:\n  finite gs\n  g \\<in> gs\n\ngoal (1 subgoal):\n 1. card (gs - {g}) < card gs", "by (meson card_Diff1_less)"], ["proof (state)\nthis:\n  card (gs - {g}) < card gs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x; t \\<in> gs - {g}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gs.\n                         set gs \\<subseteq> generate G A \\<and>\n                         cycle gs \\<and>\n                         is_idirprod (generate G A)\n                          (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                         successively (dvd) (map ord gs) \\<and>\n                         card (set gs) \\<le> card A\n 2. \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x;\n     t \\<notin> gs - {g}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gs.\n                         set gs \\<subseteq> generate G A \\<and>\n                         cycle gs \\<and>\n                         is_idirprod (generate G A)\n                          (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                         successively (dvd) (map ord gs) \\<and>\n                         card (set gs) \\<le> card A", "ultimately"], ["proof (chain)\npicking this:\n  s = gs - {g}\n  card (gs - {g}) < card gs", "have \"card (set hs) < card A\""], ["proof (prove)\nusing this:\n  s = gs - {g}\n  card (gs - {g}) < card gs\n\ngoal (1 subgoal):\n 1. card (set hs) < card A", "using hs(5) cgs"], ["proof (prove)\nusing this:\n  s = gs - {g}\n  card (gs - {g}) < card gs\n  card (set hs) \\<le> card (gs - {g})\n  card gs \\<le> card A\n\ngoal (1 subgoal):\n 1. card (set hs) < card A", "by simp"], ["proof (state)\nthis:\n  card (set hs) < card A\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x; t \\<in> gs - {g}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gs.\n                         set gs \\<subseteq> generate G A \\<and>\n                         cycle gs \\<and>\n                         is_idirprod (generate G A)\n                          (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                         successively (dvd) (map ord gs) \\<and>\n                         card (set gs) \\<le> card A\n 2. \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x;\n     t \\<notin> gs - {g}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gs.\n                         set gs \\<subseteq> generate G A \\<and>\n                         cycle gs \\<and>\n                         is_idirprod (generate G A)\n                          (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                         successively (dvd) (map ord gs) \\<and>\n                         card (set gs) \\<le> card A", "moreover"], ["proof (state)\nthis:\n  card (set hs) < card A\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x; t \\<in> gs - {g}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gs.\n                         set gs \\<subseteq> generate G A \\<and>\n                         cycle gs \\<and>\n                         is_idirprod (generate G A)\n                          (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                         successively (dvd) (map ord gs) \\<and>\n                         card (set gs) \\<le> card A\n 2. \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x;\n     t \\<notin> gs - {g}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gs.\n                         set gs \\<subseteq> generate G A \\<and>\n                         cycle gs \\<and>\n                         is_idirprod (generate G A)\n                          (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                         successively (dvd) (map ord gs) \\<and>\n                         card (set gs) \\<le> card A", "have \"set hs \\<subseteq> generate G (set hs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set hs \\<subseteq> generate G (set hs)", "using generate_sincl"], ["proof (prove)\nusing this:\n  ?A \\<subseteq> generate G ?A\n\ngoal (1 subgoal):\n 1. set hs \\<subseteq> generate G (set hs)", "by simp"], ["proof (state)\nthis:\n  set hs \\<subseteq> generate G (set hs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x; t \\<in> gs - {g}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gs.\n                         set gs \\<subseteq> generate G A \\<and>\n                         cycle gs \\<and>\n                         is_idirprod (generate G A)\n                          (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                         successively (dvd) (map ord gs) \\<and>\n                         card (set gs) \\<le> card A\n 2. \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x;\n     t \\<notin> gs - {g}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gs.\n                         set gs \\<subseteq> generate G A \\<and>\n                         cycle gs \\<and>\n                         is_idirprod (generate G A)\n                          (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                         successively (dvd) (map ord gs) \\<and>\n                         card (set gs) \\<le> card A", "moreover"], ["proof (state)\nthis:\n  set hs \\<subseteq> generate G (set hs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x; t \\<in> gs - {g}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gs.\n                         set gs \\<subseteq> generate G A \\<and>\n                         cycle gs \\<and>\n                         is_idirprod (generate G A)\n                          (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                         successively (dvd) (map ord gs) \\<and>\n                         card (set gs) \\<le> card A\n 2. \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x;\n     t \\<notin> gs - {g}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gs.\n                         set gs \\<subseteq> generate G A \\<and>\n                         cycle gs \\<and>\n                         is_idirprod (generate G A)\n                          (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                         successively (dvd) (map ord gs) \\<and>\n                         card (set gs) \\<le> card A", "have \"distinct hs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cycle hs", "by fact"], ["proof (state)\nthis:\n  cycle hs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x; t \\<in> gs - {g}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gs.\n                         set gs \\<subseteq> generate G A \\<and>\n                         cycle gs \\<and>\n                         is_idirprod (generate G A)\n                          (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                         successively (dvd) (map ord gs) \\<and>\n                         card (set gs) \\<le> card A\n 2. \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x;\n     t \\<notin> gs - {g}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gs.\n                         set gs \\<subseteq> generate G A \\<and>\n                         cycle gs \\<and>\n                         is_idirprod (generate G A)\n                          (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                         successively (dvd) (map ord gs) \\<and>\n                         card (set gs) \\<le> card A", "moreover"], ["proof (state)\nthis:\n  cycle hs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x; t \\<in> gs - {g}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gs.\n                         set gs \\<subseteq> generate G A \\<and>\n                         cycle gs \\<and>\n                         is_idirprod (generate G A)\n                          (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                         successively (dvd) (map ord gs) \\<and>\n                         card (set gs) \\<le> card A\n 2. \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x;\n     t \\<notin> gs - {g}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gs.\n                         set gs \\<subseteq> generate G A \\<and>\n                         cycle gs \\<and>\n                         is_idirprod (generate G A)\n                          (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                         successively (dvd) (map ord gs) \\<and>\n                         card (set gs) \\<le> card A", "have \"is_idirprod (generate G (set hs)) (\\<lambda>g. generate G {g}) (set hs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_idirprod (generate G (set hs)) (\\<lambda>g. generate G {g}) (set hs)", "using hs ghs"], ["proof (prove)\nusing this:\n  set hs \\<subseteq> generate G (gs - {g})\n  cycle hs\n  is_idirprod (generate G (gs - {g})) (\\<lambda>g. generate G {g}) (set hs)\n  successively (dvd) (map ord hs)\n  card (set hs) \\<le> card (gs - {g})\n  generate G (gs - {g}) = generate G (set hs)\n\ngoal (1 subgoal):\n 1. is_idirprod (generate G (set hs)) (\\<lambda>g. generate G {g}) (set hs)", "unfolding is_idirprod_def"], ["proof (prove)\nusing this:\n  set hs \\<subseteq> generate G (gs - {g})\n  cycle hs\n  (\\<forall>i\\<in>set hs. generate G {i} \\<lhd> G) \\<and>\n  generate G (gs - {g}) =\n  IDirProds G (\\<lambda>g. generate G {g}) (set hs) \\<and>\n  compl_fam (\\<lambda>g. generate G {g}) (set hs)\n  successively (dvd) (map ord hs)\n  card (set hs) \\<le> card (gs - {g})\n  generate G (gs - {g}) = generate G (set hs)\n\ngoal (1 subgoal):\n 1. (\\<forall>i\\<in>set hs. generate G {i} \\<lhd> G) \\<and>\n    generate G (set hs) =\n    IDirProds G (\\<lambda>g. generate G {g}) (set hs) \\<and>\n    compl_fam (\\<lambda>g. generate G {g}) (set hs)", "by blast"], ["proof (state)\nthis:\n  is_idirprod (generate G (set hs)) (\\<lambda>g. generate G {g}) (set hs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x; t \\<in> gs - {g}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gs.\n                         set gs \\<subseteq> generate G A \\<and>\n                         cycle gs \\<and>\n                         is_idirprod (generate G A)\n                          (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                         successively (dvd) (map ord gs) \\<and>\n                         card (set gs) \\<le> card A\n 2. \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x;\n     t \\<notin> gs - {g}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gs.\n                         set gs \\<subseteq> generate G A \\<and>\n                         cycle gs \\<and>\n                         is_idirprod (generate G A)\n                          (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                         successively (dvd) (map ord gs) \\<and>\n                         card (set gs) \\<le> card A", "moreover"], ["proof (state)\nthis:\n  is_idirprod (generate G (set hs)) (\\<lambda>g. generate G {g}) (set hs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x; t \\<in> gs - {g}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gs.\n                         set gs \\<subseteq> generate G A \\<and>\n                         cycle gs \\<and>\n                         is_idirprod (generate G A)\n                          (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                         successively (dvd) (map ord gs) \\<and>\n                         card (set gs) \\<le> card A\n 2. \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x;\n     t \\<notin> gs - {g}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gs.\n                         set gs \\<subseteq> generate G A \\<and>\n                         cycle gs \\<and>\n                         is_idirprod (generate G A)\n                          (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                         successively (dvd) (map ord gs) \\<and>\n                         card (set gs) \\<le> card A", "have \"generate G A = generate G (set hs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generate G A = generate G (set hs)", "using g gts ghs gsg"], ["proof (prove)\nusing this:\n  generate G gs = generate G s\n  s = gs - {g}\n  generate G (gs - {g}) = generate G (set hs)\n  generate G gs = generate G A\n\ngoal (1 subgoal):\n 1. generate G A = generate G (set hs)", "by argo"], ["proof (state)\nthis:\n  generate G A = generate G (set hs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x; t \\<in> gs - {g}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gs.\n                         set gs \\<subseteq> generate G A \\<and>\n                         cycle gs \\<and>\n                         is_idirprod (generate G A)\n                          (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                         successively (dvd) (map ord gs) \\<and>\n                         card (set gs) \\<le> card A\n 2. \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x;\n     t \\<notin> gs - {g}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gs.\n                         set gs \\<subseteq> generate G A \\<and>\n                         cycle gs \\<and>\n                         is_idirprod (generate G A)\n                          (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                         successively (dvd) (map ord gs) \\<and>\n                         card (set gs) \\<le> card A", "moreover"], ["proof (state)\nthis:\n  generate G A = generate G (set hs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x; t \\<in> gs - {g}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gs.\n                         set gs \\<subseteq> generate G A \\<and>\n                         cycle gs \\<and>\n                         is_idirprod (generate G A)\n                          (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                         successively (dvd) (map ord gs) \\<and>\n                         card (set gs) \\<le> card A\n 2. \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x;\n     t \\<notin> gs - {g}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gs.\n                         set gs \\<subseteq> generate G A \\<and>\n                         cycle gs \\<and>\n                         is_idirprod (generate G A)\n                          (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                         successively (dvd) (map ord gs) \\<and>\n                         card (set gs) \\<le> card A", "have \"successively (dvd) (map ord hs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. successively (dvd) (map ord hs)", "by fact"], ["proof (state)\nthis:\n  successively (dvd) (map ord hs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x; t \\<in> gs - {g}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gs.\n                         set gs \\<subseteq> generate G A \\<and>\n                         cycle gs \\<and>\n                         is_idirprod (generate G A)\n                          (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                         successively (dvd) (map ord gs) \\<and>\n                         card (set gs) \\<le> card A\n 2. \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x;\n     t \\<notin> gs - {g}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gs.\n                         set gs \\<subseteq> generate G A \\<and>\n                         cycle gs \\<and>\n                         is_idirprod (generate G A)\n                          (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                         successively (dvd) (map ord gs) \\<and>\n                         card (set gs) \\<le> card A", "ultimately"], ["proof (chain)\npicking this:\n  card (set hs) < card A\n  set hs \\<subseteq> generate G (set hs)\n  cycle hs\n  is_idirprod (generate G (set hs)) (\\<lambda>g. generate G {g}) (set hs)\n  generate G A = generate G (set hs)\n  successively (dvd) (map ord hs)", "show \"?t A\""], ["proof (prove)\nusing this:\n  card (set hs) < card A\n  set hs \\<subseteq> generate G (set hs)\n  cycle hs\n  is_idirprod (generate G (set hs)) (\\<lambda>g. generate G {g}) (set hs)\n  generate G A = generate G (set hs)\n  successively (dvd) (map ord hs)\n\ngoal (1 subgoal):\n 1. \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "using iH2"], ["proof (prove)\nusing this:\n  card (set hs) < card A\n  set hs \\<subseteq> generate G (set hs)\n  cycle hs\n  is_idirprod (generate G (set hs)) (\\<lambda>g. generate G {g}) (set hs)\n  generate G A = generate G (set hs)\n  successively (dvd) (map ord hs)\n  \\<lbrakk>\\<exists>gs.\n              set gs \\<subseteq> generate G ?B2 \\<and>\n              cycle gs \\<and>\n              is_idirprod (generate G ?B2) (\\<lambda>g. generate G {g})\n               (set gs) \\<and>\n              successively (dvd) (map ord gs) \\<and>\n              card (set gs) \\<le> card ?B2;\n   generate G A = generate G ?B2; card ?B2 < card A\\<rbrakk>\n  \\<Longrightarrow> \\<exists>gs.\n                       set gs \\<subseteq> generate G A \\<and>\n                       cycle gs \\<and>\n                       is_idirprod (generate G A)\n                        (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                       successively (dvd) (map ord gs) \\<and>\n                       card (set gs) \\<le> card A\n\ngoal (1 subgoal):\n 1. \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "by blast"], ["proof (state)\nthis:\n  \\<exists>gs.\n     set gs \\<subseteq> generate G A \\<and>\n     cycle gs \\<and>\n     is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set gs) \\<and>\n     successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x;\n     t \\<notin> gs - {g}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gs.\n                         set gs \\<subseteq> generate G A \\<and>\n                         cycle gs \\<and>\n                         is_idirprod (generate G A)\n                          (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                         successively (dvd) (map ord gs) \\<and>\n                         card (set gs) \\<le> card A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x;\n     t \\<notin> gs - {g}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gs.\n                         set gs \\<subseteq> generate G A \\<and>\n                         cycle gs \\<and>\n                         is_idirprod (generate G A)\n                          (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                         successively (dvd) (map ord gs) \\<and>\n                         card (set gs) \\<le> card A", "case tngsg: False"], ["proof (state)\nthis:\n  t \\<notin> gs - {g}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x;\n     t \\<notin> gs - {g}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gs.\n                         set gs \\<subseteq> generate G A \\<and>\n                         cycle gs \\<and>\n                         is_idirprod (generate G A)\n                          (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                         successively (dvd) (map ord gs) \\<and>\n                         card (set gs) \\<le> card A", "hence xnt: \"x \\<noteq> t\""], ["proof (prove)\nusing this:\n  t \\<notin> gs - {g}\n\ngoal (1 subgoal):\n 1. x \\<noteq> t", "using x xng"], ["proof (prove)\nusing this:\n  t \\<notin> gs - {g}\n  x \\<in> gs\n  \\<not> rel g dvd rel x\n  x \\<noteq> g\n\ngoal (1 subgoal):\n 1. x \\<noteq> t", "by blast"], ["proof (state)\nthis:\n  x \\<noteq> t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x;\n     t \\<notin> gs - {g}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gs.\n                         set gs \\<subseteq> generate G A \\<and>\n                         cycle gs \\<and>\n                         is_idirprod (generate G A)\n                          (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                         successively (dvd) (map ord gs) \\<and>\n                         card (set gs) \\<le> card A", "have \"rel g dvd rel x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel g dvd rel x", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> rel g dvd rel x \\<Longrightarrow> False", "have \"nat r \\<in> exps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat r \\<in> exps", "unfolding exps_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat r\n    \\<in> (\\<Union>gs'\\<in>all_gens.\n              \\<Union>rel\\<in>relations gs'.\n                 nat ` {e \\<in> rel ` gs'. 0 < e})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ?a \\<in> all_gens\n 2. nat r\n    \\<in> (\\<Union>rel\\<in>relations ?a. nat ` {e \\<in> rel ` ?a. 0 < e})", "show \"s \\<in> all_gens\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> all_gens", "unfolding all_gens_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> {gs \\<in> Pow (generate G A).\n             finite gs \\<and>\n             card gs \\<le> n \\<and> generate G gs = generate G A}", "using gsg g fgs generate_sincl[of s] switch_elem_card_le[OF gr(3), of t] cgs n s"], ["proof (prove)\nusing this:\n  generate G gs = generate G A\n  generate G gs = generate G s\n  finite gs\n  s \\<subseteq> generate G s\n  card (gs - {g} \\<union> {t}) \\<le> card gs\n  card gs \\<le> card A\n  n = card A\n  s = gs - {g} \\<union> {t}\n\ngoal (1 subgoal):\n 1. s \\<in> {gs \\<in> Pow (generate G A).\n             finite gs \\<and>\n             card gs \\<le> n \\<and> generate G gs = generate G A}", "by auto"], ["proof (state)\nthis:\n  s \\<in> all_gens\n\ngoal (1 subgoal):\n 1. nat r\n    \\<in> (\\<Union>rel\\<in>relations s. nat ` {e \\<in> rel ` s. 0 < e})", "have xs: \"x \\<in> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> s", "using s xng x(1)"], ["proof (prove)\nusing this:\n  s = gs - {g} \\<union> {t}\n  x \\<noteq> g\n  x \\<in> gs\n\ngoal (1 subgoal):\n 1. x \\<in> s", "by blast"], ["proof (state)\nthis:\n  x \\<in> s\n\ngoal (1 subgoal):\n 1. nat r\n    \\<in> (\\<Union>rel\\<in>relations s. nat ` {e \\<in> rel ` s. 0 < e})", "have ts: \"t \\<in> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> s", "using s"], ["proof (prove)\nusing this:\n  s = gs - {g} \\<union> {t}\n\ngoal (1 subgoal):\n 1. t \\<in> s", "by fast"], ["proof (state)\nthis:\n  t \\<in> s\n\ngoal (1 subgoal):\n 1. nat r\n    \\<in> (\\<Union>rel\\<in>relations s. nat ` {e \\<in> rel ` s. 0 < e})", "show \"nat r \\<in> (\\<Union>rel\\<in>relations s. nat ` {e \\<in> rel ` s. 0 < e})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat r\n    \\<in> (\\<Union>rel\\<in>relations s. nat ` {e \\<in> rel ` s. 0 < e})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ?a \\<in> relations s\n 2. nat r \\<in> nat ` {e \\<in> ?a ` s. 0 < e}", "let ?r = \"restrict (rel(x := r, t := rel g)) s\""], ["proof (state)\ngoal (2 subgoals):\n 1. ?a \\<in> relations s\n 2. nat r \\<in> nat ` {e \\<in> ?a ` s. 0 < e}", "show \"?r \\<in> relations s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict (rel(x := r, t := rel g)) s \\<in> relations s", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<Otimes>a\\<in>s. a [^] restrict (rel(x := r, t := rel g)) s a) =\n    \\<one>\n 2. restrict (rel(x := r, t := rel g)) s \\<in> extensional s", "have \"finprod G (\\<lambda>x. x [^] ?r x) s = finprod G (\\<lambda>x. x [^] rel x) gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n    (\\<Otimes>x\\<in>gs. x [^] rel x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n    (\\<Otimes>x\\<in>gs. x [^] rel x)", "have \"finprod G (\\<lambda>x. x [^] ?r x) s = x [^] r \\<otimes> (t [^] rel g \\<otimes> finprod G (\\<lambda>x. x [^] rel x) (gs - {g} - {x}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n    x [^] r \\<otimes>\n    (t [^] rel g \\<otimes> (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n    x [^] r \\<otimes>\n    (t [^] rel g \\<otimes> (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x))", "have \"finprod G (\\<lambda>x. x [^] ?r x) s = x [^] ?r x \\<otimes> finprod G (\\<lambda>x. x [^] ?r x) (s - {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n    x [^] restrict (rel(x := r, t := rel g)) s x \\<otimes>\n    (\\<Otimes>xa\\<in>s -\n                     {x}. xa [^] restrict (rel(x := r, t := rel g)) s xa)", "by (intro finprod_minus[OF xs _ fs], use sc in auto)"], ["proof (state)\nthis:\n  (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n  x [^] restrict (rel(x := r, t := rel g)) s x \\<otimes>\n  (\\<Otimes>xa\\<in>s - {x}. xa [^] restrict (rel(x := r, t := rel g)) s xa)\n\ngoal (1 subgoal):\n 1. (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n    x [^] r \\<otimes>\n    (t [^] rel g \\<otimes> (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x))", "moreover"], ["proof (state)\nthis:\n  (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n  x [^] restrict (rel(x := r, t := rel g)) s x \\<otimes>\n  (\\<Otimes>xa\\<in>s - {x}. xa [^] restrict (rel(x := r, t := rel g)) s xa)\n\ngoal (1 subgoal):\n 1. (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n    x [^] r \\<otimes>\n    (t [^] rel g \\<otimes> (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x))", "have \"finprod G (\\<lambda>x. x [^] ?r x) (s - {x}) = t [^] ?r t \\<otimes> finprod G (\\<lambda>x. x [^] ?r x) (s - {x} - {t})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Otimes>xa\\<in>s -\n                     {x}. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n    t [^] restrict (rel(x := r, t := rel g)) s t \\<otimes>\n    (\\<Otimes>xa\\<in>s - {x} -\n                     {t}. xa [^] restrict (rel(x := r, t := rel g)) s xa)", "by (intro finprod_minus, use ts xnt fs sc in auto)"], ["proof (state)\nthis:\n  (\\<Otimes>xa\\<in>s -\n                   {x}. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n  t [^] restrict (rel(x := r, t := rel g)) s t \\<otimes>\n  (\\<Otimes>xa\\<in>s - {x} -\n                   {t}. xa [^] restrict (rel(x := r, t := rel g)) s xa)\n\ngoal (1 subgoal):\n 1. (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n    x [^] r \\<otimes>\n    (t [^] rel g \\<otimes> (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x))", "moreover"], ["proof (state)\nthis:\n  (\\<Otimes>xa\\<in>s -\n                   {x}. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n  t [^] restrict (rel(x := r, t := rel g)) s t \\<otimes>\n  (\\<Otimes>xa\\<in>s - {x} -\n                   {t}. xa [^] restrict (rel(x := r, t := rel g)) s xa)\n\ngoal (1 subgoal):\n 1. (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n    x [^] r \\<otimes>\n    (t [^] rel g \\<otimes> (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x))", "have \"finprod G (\\<lambda>x. x [^] ?r x) (s - {x} - {t}) = finprod G (\\<lambda>x. x [^] rel x) (s - {x} - {t})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Otimes>xa\\<in>s - {x} -\n                     {t}. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n    (\\<Otimes>x\\<in>s - {x} - {t}. x [^] rel x)", "unfolding s"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Otimes>xa\\<in>gs - {g} \\<union> {t} - {x} -\n                     {t}. xa [^]\n                          restrict (rel(x := r, t := rel g))\n                           (gs - {g} \\<union> {t}) xa) =\n    (\\<Otimes>x\\<in>gs - {g} \\<union> {t} - {x} - {t}. x [^] rel x)", "by (intro finprod_cong',  use gsc in auto)"], ["proof (state)\nthis:\n  (\\<Otimes>xa\\<in>s - {x} -\n                   {t}. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n  (\\<Otimes>x\\<in>s - {x} - {t}. x [^] rel x)\n\ngoal (1 subgoal):\n 1. (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n    x [^] r \\<otimes>\n    (t [^] rel g \\<otimes> (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x))", "moreover"], ["proof (state)\nthis:\n  (\\<Otimes>xa\\<in>s - {x} -\n                   {t}. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n  (\\<Otimes>x\\<in>s - {x} - {t}. x [^] rel x)\n\ngoal (1 subgoal):\n 1. (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n    x [^] r \\<otimes>\n    (t [^] rel g \\<otimes> (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x))", "have \"s - {x} - {t} = gs - {g} - {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s - {x} - {t} = gs - {g} - {x}", "unfolding s"], ["proof (prove)\ngoal (1 subgoal):\n 1. gs - {g} \\<union> {t} - {x} - {t} = gs - {g} - {x}", "using tngsg"], ["proof (prove)\nusing this:\n  t \\<notin> gs - {g}\n\ngoal (1 subgoal):\n 1. gs - {g} \\<union> {t} - {x} - {t} = gs - {g} - {x}", "by blast"], ["proof (state)\nthis:\n  s - {x} - {t} = gs - {g} - {x}\n\ngoal (1 subgoal):\n 1. (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n    x [^] r \\<otimes>\n    (t [^] rel g \\<otimes> (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x))", "moreover"], ["proof (state)\nthis:\n  s - {x} - {t} = gs - {g} - {x}\n\ngoal (1 subgoal):\n 1. (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n    x [^] r \\<otimes>\n    (t [^] rel g \\<otimes> (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x))", "hence \"finprod G (\\<lambda>x. x [^] rel x) (s - {x} - {t}) = finprod G (\\<lambda>x. x [^] rel x) (gs - {g} - {x})\""], ["proof (prove)\nusing this:\n  s - {x} - {t} = gs - {g} - {x}\n\ngoal (1 subgoal):\n 1. (\\<Otimes>x\\<in>s - {x} - {t}. x [^] rel x) =\n    (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x)", "by simp"], ["proof (state)\nthis:\n  (\\<Otimes>x\\<in>s - {x} - {t}. x [^] rel x) =\n  (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x)\n\ngoal (1 subgoal):\n 1. (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n    x [^] r \\<otimes>\n    (t [^] rel g \\<otimes> (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x))", "moreover"], ["proof (state)\nthis:\n  (\\<Otimes>x\\<in>s - {x} - {t}. x [^] rel x) =\n  (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x)\n\ngoal (1 subgoal):\n 1. (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n    x [^] r \\<otimes>\n    (t [^] rel g \\<otimes> (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x))", "have \"x [^] ?r x = x [^] r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x [^] restrict (rel(x := r, t := rel g)) s x = x [^] r", "using xs xnt"], ["proof (prove)\nusing this:\n  x \\<in> s\n  x \\<noteq> t\n\ngoal (1 subgoal):\n 1. x [^] restrict (rel(x := r, t := rel g)) s x = x [^] r", "by auto"], ["proof (state)\nthis:\n  x [^] restrict (rel(x := r, t := rel g)) s x = x [^] r\n\ngoal (1 subgoal):\n 1. (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n    x [^] r \\<otimes>\n    (t [^] rel g \\<otimes> (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x))", "moreover"], ["proof (state)\nthis:\n  x [^] restrict (rel(x := r, t := rel g)) s x = x [^] r\n\ngoal (1 subgoal):\n 1. (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n    x [^] r \\<otimes>\n    (t [^] rel g \\<otimes> (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x))", "have \"t [^] ?r t = t [^] rel g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t [^] restrict (rel(x := r, t := rel g)) s t = t [^] rel g", "using ts"], ["proof (prove)\nusing this:\n  t \\<in> s\n\ngoal (1 subgoal):\n 1. t [^] restrict (rel(x := r, t := rel g)) s t = t [^] rel g", "by simp"], ["proof (state)\nthis:\n  t [^] restrict (rel(x := r, t := rel g)) s t = t [^] rel g\n\ngoal (1 subgoal):\n 1. (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n    x [^] r \\<otimes>\n    (t [^] rel g \\<otimes> (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x))", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n  x [^] restrict (rel(x := r, t := rel g)) s x \\<otimes>\n  (\\<Otimes>xa\\<in>s - {x}. xa [^] restrict (rel(x := r, t := rel g)) s xa)\n  (\\<Otimes>xa\\<in>s -\n                   {x}. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n  t [^] restrict (rel(x := r, t := rel g)) s t \\<otimes>\n  (\\<Otimes>xa\\<in>s - {x} -\n                   {t}. xa [^] restrict (rel(x := r, t := rel g)) s xa)\n  (\\<Otimes>xa\\<in>s - {x} -\n                   {t}. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n  (\\<Otimes>x\\<in>s - {x} - {t}. x [^] rel x)\n  s - {x} - {t} = gs - {g} - {x}\n  (\\<Otimes>x\\<in>s - {x} - {t}. x [^] rel x) =\n  (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x)\n  x [^] restrict (rel(x := r, t := rel g)) s x = x [^] r\n  t [^] restrict (rel(x := r, t := rel g)) s t = t [^] rel g", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n  x [^] restrict (rel(x := r, t := rel g)) s x \\<otimes>\n  (\\<Otimes>xa\\<in>s - {x}. xa [^] restrict (rel(x := r, t := rel g)) s xa)\n  (\\<Otimes>xa\\<in>s -\n                   {x}. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n  t [^] restrict (rel(x := r, t := rel g)) s t \\<otimes>\n  (\\<Otimes>xa\\<in>s - {x} -\n                   {t}. xa [^] restrict (rel(x := r, t := rel g)) s xa)\n  (\\<Otimes>xa\\<in>s - {x} -\n                   {t}. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n  (\\<Otimes>x\\<in>s - {x} - {t}. x [^] rel x)\n  s - {x} - {t} = gs - {g} - {x}\n  (\\<Otimes>x\\<in>s - {x} - {t}. x [^] rel x) =\n  (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x)\n  x [^] restrict (rel(x := r, t := rel g)) s x = x [^] r\n  t [^] restrict (rel(x := r, t := rel g)) s t = t [^] rel g\n\ngoal (1 subgoal):\n 1. (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n    x [^] r \\<otimes>\n    (t [^] rel g \\<otimes> (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x))", "by argo"], ["proof (state)\nthis:\n  (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n  x [^] r \\<otimes>\n  (t [^] rel g \\<otimes> (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n  x [^] r \\<otimes>\n  (t [^] rel g \\<otimes> (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x))\n\ngoal (1 subgoal):\n 1. (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n    (\\<Otimes>x\\<in>gs. x [^] rel x)", "also"], ["proof (state)\nthis:\n  (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n  x [^] r \\<otimes>\n  (t [^] rel g \\<otimes> (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x))\n\ngoal (1 subgoal):\n 1. (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n    (\\<Otimes>x\\<in>gs. x [^] rel x)", "have \"\\<dots> = x [^] r \\<otimes> t [^] rel g \\<otimes> finprod G (\\<lambda>x. x [^] rel x) (gs - {g} - {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x [^] r \\<otimes>\n    (t [^] rel g \\<otimes> (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x)) =\n    x [^] r \\<otimes> t [^] rel g \\<otimes>\n    (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x)", "by (intro m_assoc[symmetric], use xc tc in simp_all, intro finprod_closed, use gsc in fast)"], ["proof (state)\nthis:\n  x [^] r \\<otimes>\n  (t [^] rel g \\<otimes> (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x)) =\n  x [^] r \\<otimes> t [^] rel g \\<otimes>\n  (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x)\n\ngoal (1 subgoal):\n 1. (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n    (\\<Otimes>x\\<in>gs. x [^] rel x)", "also"], ["proof (state)\nthis:\n  x [^] r \\<otimes>\n  (t [^] rel g \\<otimes> (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x)) =\n  x [^] r \\<otimes> t [^] rel g \\<otimes>\n  (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x)\n\ngoal (1 subgoal):\n 1. (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n    (\\<Otimes>x\\<in>gs. x [^] rel x)", "have \"\\<dots> = g [^] rel g \\<otimes> x [^] rel x \\<otimes> finprod G (\\<lambda>x. x [^] rel x) (gs - {g} - {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x [^] r \\<otimes> t [^] rel g \\<otimes>\n    (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x) =\n    g [^] rel g \\<otimes> x [^] rel x \\<otimes>\n    (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x [^] r \\<otimes> t [^] rel g \\<otimes>\n    (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x) =\n    g [^] rel g \\<otimes> x [^] rel x \\<otimes>\n    (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x)", "have \"x [^] r \\<otimes> t [^] rel g = g [^] rel g \\<otimes> x [^] rel x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x [^] r \\<otimes> t [^] rel g = g [^] rel g \\<otimes> x [^] rel x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x [^] r \\<otimes> t [^] rel g = g [^] rel g \\<otimes> x [^] rel x", "have \"x [^] r \\<otimes> t [^] rel g = x [^] r \\<otimes> (g \\<otimes> x [^] q) [^] rel g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x [^] r \\<otimes> t [^] rel g =\n    x [^] r \\<otimes> (g \\<otimes> x [^] q) [^] rel g", "using t"], ["proof (prove)\nusing this:\n  t = g \\<otimes> x [^] q\n\ngoal (1 subgoal):\n 1. x [^] r \\<otimes> t [^] rel g =\n    x [^] r \\<otimes> (g \\<otimes> x [^] q) [^] rel g", "by blast"], ["proof (state)\nthis:\n  x [^] r \\<otimes> t [^] rel g =\n  x [^] r \\<otimes> (g \\<otimes> x [^] q) [^] rel g\n\ngoal (1 subgoal):\n 1. x [^] r \\<otimes> t [^] rel g = g [^] rel g \\<otimes> x [^] rel x", "also"], ["proof (state)\nthis:\n  x [^] r \\<otimes> t [^] rel g =\n  x [^] r \\<otimes> (g \\<otimes> x [^] q) [^] rel g\n\ngoal (1 subgoal):\n 1. x [^] r \\<otimes> t [^] rel g = g [^] rel g \\<otimes> x [^] rel x", "have \"\\<dots> = x [^] r \\<otimes> x [^] (q * rel g) \\<otimes> g [^] rel g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x [^] r \\<otimes> (g \\<otimes> x [^] q) [^] rel g =\n    x [^] r \\<otimes> x [^] (q * rel g) \\<otimes> g [^] rel g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x [^] r \\<otimes> (g \\<otimes> x [^] q) [^] rel g =\n    x [^] r \\<otimes> x [^] (q * rel g) \\<otimes> g [^] rel g", "have \"(g \\<otimes> x [^] q) [^] rel g = g [^] rel g \\<otimes> (x [^] q) [^] rel g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g \\<otimes> x [^] q) [^] rel g =\n    g [^] rel g \\<otimes> (x [^] q) [^] rel g", "using gc xc int_pow_distrib"], ["proof (prove)\nusing this:\n  g \\<in> carrier G\n  x \\<in> carrier G\n  \\<lbrakk>?x \\<in> carrier G; ?y \\<in> carrier G\\<rbrakk>\n  \\<Longrightarrow> (?x \\<otimes> ?y) [^] ?i = ?x [^] ?i \\<otimes> ?y [^] ?i\n\ngoal (1 subgoal):\n 1. (g \\<otimes> x [^] q) [^] rel g =\n    g [^] rel g \\<otimes> (x [^] q) [^] rel g", "by auto"], ["proof (state)\nthis:\n  (g \\<otimes> x [^] q) [^] rel g =\n  g [^] rel g \\<otimes> (x [^] q) [^] rel g\n\ngoal (1 subgoal):\n 1. x [^] r \\<otimes> (g \\<otimes> x [^] q) [^] rel g =\n    x [^] r \\<otimes> x [^] (q * rel g) \\<otimes> g [^] rel g", "moreover"], ["proof (state)\nthis:\n  (g \\<otimes> x [^] q) [^] rel g =\n  g [^] rel g \\<otimes> (x [^] q) [^] rel g\n\ngoal (1 subgoal):\n 1. x [^] r \\<otimes> (g \\<otimes> x [^] q) [^] rel g =\n    x [^] r \\<otimes> x [^] (q * rel g) \\<otimes> g [^] rel g", "have \"(x [^] q) [^] rel g = x [^] (q * rel g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x [^] q) [^] rel g = x [^] (q * rel g)", "using xc int_pow_pow"], ["proof (prove)\nusing this:\n  x \\<in> carrier G\n  ?x \\<in> carrier G \\<Longrightarrow> (?x [^] ?n) [^] ?m = ?x [^] (?n * ?m)\n\ngoal (1 subgoal):\n 1. (x [^] q) [^] rel g = x [^] (q * rel g)", "by auto"], ["proof (state)\nthis:\n  (x [^] q) [^] rel g = x [^] (q * rel g)\n\ngoal (1 subgoal):\n 1. x [^] r \\<otimes> (g \\<otimes> x [^] q) [^] rel g =\n    x [^] r \\<otimes> x [^] (q * rel g) \\<otimes> g [^] rel g", "moreover"], ["proof (state)\nthis:\n  (x [^] q) [^] rel g = x [^] (q * rel g)\n\ngoal (1 subgoal):\n 1. x [^] r \\<otimes> (g \\<otimes> x [^] q) [^] rel g =\n    x [^] r \\<otimes> x [^] (q * rel g) \\<otimes> g [^] rel g", "have \"g [^] rel g \\<otimes> x [^] (q * rel g) = x [^] (q * rel g) \\<otimes> g [^] rel g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g [^] rel g \\<otimes> x [^] (q * rel g) =\n    x [^] (q * rel g) \\<otimes> g [^] rel g", "using m_comm[OF int_pow_closed[OF xc] int_pow_closed[OF gc]]"], ["proof (prove)\nusing this:\n  x [^] ?i2 \\<otimes> g [^] ?i1 = g [^] ?i1 \\<otimes> x [^] ?i2\n\ngoal (1 subgoal):\n 1. g [^] rel g \\<otimes> x [^] (q * rel g) =\n    x [^] (q * rel g) \\<otimes> g [^] rel g", "by simp"], ["proof (state)\nthis:\n  g [^] rel g \\<otimes> x [^] (q * rel g) =\n  x [^] (q * rel g) \\<otimes> g [^] rel g\n\ngoal (1 subgoal):\n 1. x [^] r \\<otimes> (g \\<otimes> x [^] q) [^] rel g =\n    x [^] r \\<otimes> x [^] (q * rel g) \\<otimes> g [^] rel g", "ultimately"], ["proof (chain)\npicking this:\n  (g \\<otimes> x [^] q) [^] rel g =\n  g [^] rel g \\<otimes> (x [^] q) [^] rel g\n  (x [^] q) [^] rel g = x [^] (q * rel g)\n  g [^] rel g \\<otimes> x [^] (q * rel g) =\n  x [^] (q * rel g) \\<otimes> g [^] rel g", "have \"(g \\<otimes> x [^] q) [^] rel g = x [^] (q * rel g) \\<otimes> g [^] rel g\""], ["proof (prove)\nusing this:\n  (g \\<otimes> x [^] q) [^] rel g =\n  g [^] rel g \\<otimes> (x [^] q) [^] rel g\n  (x [^] q) [^] rel g = x [^] (q * rel g)\n  g [^] rel g \\<otimes> x [^] (q * rel g) =\n  x [^] (q * rel g) \\<otimes> g [^] rel g\n\ngoal (1 subgoal):\n 1. (g \\<otimes> x [^] q) [^] rel g =\n    x [^] (q * rel g) \\<otimes> g [^] rel g", "by argo"], ["proof (state)\nthis:\n  (g \\<otimes> x [^] q) [^] rel g = x [^] (q * rel g) \\<otimes> g [^] rel g\n\ngoal (1 subgoal):\n 1. x [^] r \\<otimes> (g \\<otimes> x [^] q) [^] rel g =\n    x [^] r \\<otimes> x [^] (q * rel g) \\<otimes> g [^] rel g", "thus ?thesis"], ["proof (prove)\nusing this:\n  (g \\<otimes> x [^] q) [^] rel g = x [^] (q * rel g) \\<otimes> g [^] rel g\n\ngoal (1 subgoal):\n 1. x [^] r \\<otimes> (g \\<otimes> x [^] q) [^] rel g =\n    x [^] r \\<otimes> x [^] (q * rel g) \\<otimes> g [^] rel g", "by (simp add: gc m_assoc xc)"], ["proof (state)\nthis:\n  x [^] r \\<otimes> (g \\<otimes> x [^] q) [^] rel g =\n  x [^] r \\<otimes> x [^] (q * rel g) \\<otimes> g [^] rel g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x [^] r \\<otimes> (g \\<otimes> x [^] q) [^] rel g =\n  x [^] r \\<otimes> x [^] (q * rel g) \\<otimes> g [^] rel g\n\ngoal (1 subgoal):\n 1. x [^] r \\<otimes> t [^] rel g = g [^] rel g \\<otimes> x [^] rel x", "also"], ["proof (state)\nthis:\n  x [^] r \\<otimes> (g \\<otimes> x [^] q) [^] rel g =\n  x [^] r \\<otimes> x [^] (q * rel g) \\<otimes> g [^] rel g\n\ngoal (1 subgoal):\n 1. x [^] r \\<otimes> t [^] rel g = g [^] rel g \\<otimes> x [^] rel x", "have \"\\<dots> = x [^] rel x \\<otimes> g [^] rel g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x [^] r \\<otimes> x [^] (q * rel g) \\<otimes> g [^] rel g =\n    x [^] rel x \\<otimes> g [^] rel g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x [^] r \\<otimes> x [^] (q * rel g) \\<otimes> g [^] rel g =\n    x [^] rel x \\<otimes> g [^] rel g", "have \"x [^] r \\<otimes> x [^] (q * rel g) = x [^] (q * rel g + r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x [^] r \\<otimes> x [^] (q * rel g) = x [^] (q * rel g + r)", "by (simp add: add.commute int_pow_mult xc)"], ["proof (state)\nthis:\n  x [^] r \\<otimes> x [^] (q * rel g) = x [^] (q * rel g + r)\n\ngoal (1 subgoal):\n 1. x [^] r \\<otimes> x [^] (q * rel g) \\<otimes> g [^] rel g =\n    x [^] rel x \\<otimes> g [^] rel g", "also"], ["proof (state)\nthis:\n  x [^] r \\<otimes> x [^] (q * rel g) = x [^] (q * rel g + r)\n\ngoal (1 subgoal):\n 1. x [^] r \\<otimes> x [^] (q * rel g) \\<otimes> g [^] rel g =\n    x [^] rel x \\<otimes> g [^] rel g", "have \"\\<dots> = x [^] rel x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x [^] (q * rel g + r) = x [^] rel x", "using rq"], ["proof (prove)\nusing this:\n  rel x = q * rel g + r\n  0 < r\n  r < rel g\n\ngoal (1 subgoal):\n 1. x [^] (q * rel g + r) = x [^] rel x", "by argo"], ["proof (state)\nthis:\n  x [^] (q * rel g + r) = x [^] rel x\n\ngoal (1 subgoal):\n 1. x [^] r \\<otimes> x [^] (q * rel g) \\<otimes> g [^] rel g =\n    x [^] rel x \\<otimes> g [^] rel g", "finally"], ["proof (chain)\npicking this:\n  x [^] r \\<otimes> x [^] (q * rel g) = x [^] rel x", "show ?thesis"], ["proof (prove)\nusing this:\n  x [^] r \\<otimes> x [^] (q * rel g) = x [^] rel x\n\ngoal (1 subgoal):\n 1. x [^] r \\<otimes> x [^] (q * rel g) \\<otimes> g [^] rel g =\n    x [^] rel x \\<otimes> g [^] rel g", "by argo"], ["proof (state)\nthis:\n  x [^] r \\<otimes> x [^] (q * rel g) \\<otimes> g [^] rel g =\n  x [^] rel x \\<otimes> g [^] rel g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x [^] r \\<otimes> x [^] (q * rel g) \\<otimes> g [^] rel g =\n  x [^] rel x \\<otimes> g [^] rel g\n\ngoal (1 subgoal):\n 1. x [^] r \\<otimes> t [^] rel g = g [^] rel g \\<otimes> x [^] rel x", "finally"], ["proof (chain)\npicking this:\n  x [^] r \\<otimes> t [^] rel g = x [^] rel x \\<otimes> g [^] rel g", "show ?thesis"], ["proof (prove)\nusing this:\n  x [^] r \\<otimes> t [^] rel g = x [^] rel x \\<otimes> g [^] rel g\n\ngoal (1 subgoal):\n 1. x [^] r \\<otimes> t [^] rel g = g [^] rel g \\<otimes> x [^] rel x", "by (simp add: gc m_comm xc)"], ["proof (state)\nthis:\n  x [^] r \\<otimes> t [^] rel g = g [^] rel g \\<otimes> x [^] rel x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x [^] r \\<otimes> t [^] rel g = g [^] rel g \\<otimes> x [^] rel x\n\ngoal (1 subgoal):\n 1. x [^] r \\<otimes> t [^] rel g \\<otimes>\n    (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x) =\n    g [^] rel g \\<otimes> x [^] rel x \\<otimes>\n    (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x [^] r \\<otimes> t [^] rel g = g [^] rel g \\<otimes> x [^] rel x\n\ngoal (1 subgoal):\n 1. x [^] r \\<otimes> t [^] rel g \\<otimes>\n    (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x) =\n    g [^] rel g \\<otimes> x [^] rel x \\<otimes>\n    (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x)", "by simp"], ["proof (state)\nthis:\n  x [^] r \\<otimes> t [^] rel g \\<otimes>\n  (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x) =\n  g [^] rel g \\<otimes> x [^] rel x \\<otimes>\n  (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x [^] r \\<otimes> t [^] rel g \\<otimes>\n  (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x) =\n  g [^] rel g \\<otimes> x [^] rel x \\<otimes>\n  (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x)\n\ngoal (1 subgoal):\n 1. (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n    (\\<Otimes>x\\<in>gs. x [^] rel x)", "also"], ["proof (state)\nthis:\n  x [^] r \\<otimes> t [^] rel g \\<otimes>\n  (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x) =\n  g [^] rel g \\<otimes> x [^] rel x \\<otimes>\n  (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x)\n\ngoal (1 subgoal):\n 1. (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n    (\\<Otimes>x\\<in>gs. x [^] rel x)", "have \"\\<dots> = g [^] rel g \\<otimes> (x [^] rel x \\<otimes> finprod G (\\<lambda>x. x [^] rel x) (gs - {g} - {x}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g [^] rel g \\<otimes> x [^] rel x \\<otimes>\n    (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x) =\n    g [^] rel g \\<otimes>\n    (x [^] rel x \\<otimes> (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x))", "by (intro m_assoc, use xc gc in simp_all, intro finprod_closed, use gsc in fast)"], ["proof (state)\nthis:\n  g [^] rel g \\<otimes> x [^] rel x \\<otimes>\n  (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x) =\n  g [^] rel g \\<otimes>\n  (x [^] rel x \\<otimes> (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x))\n\ngoal (1 subgoal):\n 1. (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n    (\\<Otimes>x\\<in>gs. x [^] rel x)", "also"], ["proof (state)\nthis:\n  g [^] rel g \\<otimes> x [^] rel x \\<otimes>\n  (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x) =\n  g [^] rel g \\<otimes>\n  (x [^] rel x \\<otimes> (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x))\n\ngoal (1 subgoal):\n 1. (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n    (\\<Otimes>x\\<in>gs. x [^] rel x)", "have \"\\<dots> = g [^] rel g \\<otimes> finprod G (\\<lambda>x. x [^] rel x) (gs - {g})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g [^] rel g \\<otimes>\n    (x [^] rel x \\<otimes> (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x)) =\n    g [^] rel g \\<otimes> (\\<Otimes>x\\<in>gs - {g}. x [^] rel x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. g [^] rel g \\<otimes>\n    (x [^] rel x \\<otimes> (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x)) =\n    g [^] rel g \\<otimes> (\\<Otimes>x\\<in>gs - {g}. x [^] rel x)", "have \"finprod G (\\<lambda>x. x [^] rel x) (gs - {g}) = x [^] rel x \\<otimes> finprod G (\\<lambda>x. x [^] rel x) (gs - {g} - {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Otimes>x\\<in>gs - {g}. x [^] rel x) =\n    x [^] rel x \\<otimes> (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x)", "by (intro finprod_minus, use xng x(1) fgs gsc in auto)"], ["proof (state)\nthis:\n  (\\<Otimes>x\\<in>gs - {g}. x [^] rel x) =\n  x [^] rel x \\<otimes> (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x)\n\ngoal (1 subgoal):\n 1. g [^] rel g \\<otimes>\n    (x [^] rel x \\<otimes> (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x)) =\n    g [^] rel g \\<otimes> (\\<Otimes>x\\<in>gs - {g}. x [^] rel x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<Otimes>x\\<in>gs - {g}. x [^] rel x) =\n  x [^] rel x \\<otimes> (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x)\n\ngoal (1 subgoal):\n 1. g [^] rel g \\<otimes>\n    (x [^] rel x \\<otimes> (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x)) =\n    g [^] rel g \\<otimes> (\\<Otimes>x\\<in>gs - {g}. x [^] rel x)", "by argo"], ["proof (state)\nthis:\n  g [^] rel g \\<otimes>\n  (x [^] rel x \\<otimes> (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x)) =\n  g [^] rel g \\<otimes> (\\<Otimes>x\\<in>gs - {g}. x [^] rel x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  g [^] rel g \\<otimes>\n  (x [^] rel x \\<otimes> (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x)) =\n  g [^] rel g \\<otimes> (\\<Otimes>x\\<in>gs - {g}. x [^] rel x)\n\ngoal (1 subgoal):\n 1. (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n    (\\<Otimes>x\\<in>gs. x [^] rel x)", "also"], ["proof (state)\nthis:\n  g [^] rel g \\<otimes>\n  (x [^] rel x \\<otimes> (\\<Otimes>x\\<in>gs - {g} - {x}. x [^] rel x)) =\n  g [^] rel g \\<otimes> (\\<Otimes>x\\<in>gs - {g}. x [^] rel x)\n\ngoal (1 subgoal):\n 1. (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n    (\\<Otimes>x\\<in>gs. x [^] rel x)", "have \"\\<dots> = finprod G (\\<lambda>x. x [^] rel x) gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g [^] rel g \\<otimes> (\\<Otimes>x\\<in>gs - {g}. x [^] rel x) =\n    (\\<Otimes>x\\<in>gs. x [^] rel x)", "by (intro finprod_minus[symmetric, OF gr(3) _ fgs], use gsc in auto)"], ["proof (state)\nthis:\n  g [^] rel g \\<otimes> (\\<Otimes>x\\<in>gs - {g}. x [^] rel x) =\n  (\\<Otimes>x\\<in>gs. x [^] rel x)\n\ngoal (1 subgoal):\n 1. (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n    (\\<Otimes>x\\<in>gs. x [^] rel x)", "finally"], ["proof (chain)\npicking this:\n  (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n  (\\<Otimes>x\\<in>gs. x [^] rel x)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n  (\\<Otimes>x\\<in>gs. x [^] rel x)\n\ngoal (1 subgoal):\n 1. (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n    (\\<Otimes>x\\<in>gs. x [^] rel x)", "."], ["proof (state)\nthis:\n  (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n  (\\<Otimes>x\\<in>gs. x [^] rel x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n  (\\<Otimes>x\\<in>gs. x [^] rel x)\n\ngoal (2 subgoals):\n 1. (\\<Otimes>a\\<in>s. a [^] restrict (rel(x := r, t := rel g)) s a) =\n    \\<one>\n 2. restrict (rel(x := r, t := rel g)) s \\<in> extensional s", "thus \"finprod G (\\<lambda>x. x [^] ?r x) s = \\<one>\""], ["proof (prove)\nusing this:\n  (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n  (\\<Otimes>x\\<in>gs. x [^] rel x)\n\ngoal (1 subgoal):\n 1. (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n    \\<one>", "using gr(2)"], ["proof (prove)\nusing this:\n  (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n  (\\<Otimes>x\\<in>gs. x [^] rel x)\n  rel \\<in> relations gs\n\ngoal (1 subgoal):\n 1. (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n    \\<one>", "unfolding relations_def"], ["proof (prove)\nusing this:\n  (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n  (\\<Otimes>x\\<in>gs. x [^] rel x)\n  rel\n  \\<in> {f. (\\<Otimes>a\\<in>gs. a [^] f a) = \\<one>} \\<inter> extensional gs\n\ngoal (1 subgoal):\n 1. (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n    \\<one>", "by simp"], ["proof (state)\nthis:\n  (\\<Otimes>xa\\<in>s. xa [^] restrict (rel(x := r, t := rel g)) s xa) =\n  \\<one>\n\ngoal (1 subgoal):\n 1. restrict (rel(x := r, t := rel g)) s \\<in> extensional s", "qed auto"], ["proof (state)\nthis:\n  restrict (rel(x := r, t := rel g)) s \\<in> relations s\n\ngoal (1 subgoal):\n 1. nat r\n    \\<in> nat ` {e \\<in> restrict (rel(x := r, t := rel g)) s ` s. 0 < e}", "show \"nat r \\<in> nat ` {e \\<in> ?r ` s. 0 < e}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat r\n    \\<in> nat ` {e \\<in> restrict (rel(x := r, t := rel g)) s ` s. 0 < e}", "using xs xnt rq(2)"], ["proof (prove)\nusing this:\n  x \\<in> s\n  x \\<noteq> t\n  0 < r\n\ngoal (1 subgoal):\n 1. nat r\n    \\<in> nat ` {e \\<in> restrict (rel(x := r, t := rel g)) s ` s. 0 < e}", "by fastforce"], ["proof (state)\nthis:\n  nat r\n  \\<in> nat ` {e \\<in> restrict (rel(x := r, t := rel g)) s ` s. 0 < e}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nat r \\<in> (\\<Union>rel\\<in>relations s. nat ` {e \\<in> rel ` s. 0 < e})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nat r \\<in> exps\n\ngoal (1 subgoal):\n 1. \\<not> rel g dvd rel x \\<Longrightarrow> False", "from le[OF this] rq(3) gr(4, 5)"], ["proof (chain)\npicking this:\n  min_exp \\<le> nat r\n  r < rel g\n  rel g = int min_exp\n  0 < min_exp", "show False"], ["proof (prove)\nusing this:\n  min_exp \\<le> nat r\n  r < rel g\n  rel g = int min_exp\n  0 < min_exp\n\ngoal (1 subgoal):\n 1. False", "by linarith"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rel g dvd rel x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x;\n     t \\<notin> gs - {g}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gs.\n                         set gs \\<subseteq> generate G A \\<and>\n                         cycle gs \\<and>\n                         is_idirprod (generate G A)\n                          (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                         successively (dvd) (map ord gs) \\<and>\n                         card (set gs) \\<le> card A", "thus \"\\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x\\<rbrakk> \\<Longrightarrow> ?t A\""], ["proof (prove)\nusing this:\n  rel g dvd rel x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gs.\n                         set gs \\<subseteq> generate G A \\<and>\n                         cycle gs \\<and>\n                         is_idirprod (generate G A)\n                          (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                         successively (dvd) (map ord gs) \\<and>\n                         card (set gs) \\<le> card A", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x\\<rbrakk>\n  \\<Longrightarrow> \\<exists>gs.\n                       set gs \\<subseteq> generate G A \\<and>\n                       cycle gs \\<and>\n                       is_idirprod (generate G A)\n                        (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                       successively (dvd) (map ord gs) \\<and>\n                       card (set gs) \\<le> card A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<in> gs; \\<not> rel g dvd rel x\\<rbrakk>\n  \\<Longrightarrow> \\<exists>gs.\n                       set gs \\<subseteq> generate G A \\<and>\n                       cycle gs \\<and>\n                       is_idirprod (generate G A)\n                        (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                       successively (dvd) (map ord gs) \\<and>\n                       card (set gs) \\<le> card A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?x2 \\<in> gs; \\<not> rel g dvd rel ?x2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>gs.\n                       set gs \\<subseteq> generate G A \\<and>\n                       cycle gs \\<and>\n                       is_idirprod (generate G A)\n                        (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                       successively (dvd) (map ord gs) \\<and>\n                       card (set gs) \\<le> card A\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>e\\<in>rel ` gs. rel g dvd e) \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "thus \"?t A\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x2 \\<in> gs; \\<not> rel g dvd rel ?x2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>gs.\n                       set gs \\<subseteq> generate G A \\<and>\n                       cycle gs \\<and>\n                       is_idirprod (generate G A)\n                        (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                       successively (dvd) (map ord gs) \\<and>\n                       card (set gs) \\<le> card A\n\ngoal (1 subgoal):\n 1. \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "using na"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x2 \\<in> gs; \\<not> rel g dvd rel ?x2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>gs.\n                       set gs \\<subseteq> generate G A \\<and>\n                       cycle gs \\<and>\n                       is_idirprod (generate G A)\n                        (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                       successively (dvd) (map ord gs) \\<and>\n                       card (set gs) \\<le> card A\n  \\<not> (\\<forall>e\\<in>rel ` gs. rel g dvd e)\n\ngoal (1 subgoal):\n 1. \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "by blast"], ["proof (state)\nthis:\n  \\<exists>gs.\n     set gs \\<subseteq> generate G A \\<and>\n     cycle gs \\<and>\n     is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set gs) \\<and>\n     successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>gs.\n      set gs \\<subseteq> generate G A \\<and>\n      cycle gs \\<and>\n      is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n       (set gs) \\<and>\n      successively (dvd) (map ord gs) \\<and>\n      card (set gs) \\<le> card A) \\<or>\n  (\\<forall>e\\<in>rel ` gs. rel g dvd e)\n\ngoal (1 subgoal):\n 1. inv a \\<notin> A - {a} \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "show \"?t A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "proof (cases \"\\<forall>e\\<in>rel`gs. rel g dvd e\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>e\\<in>rel ` gs. rel g dvd e \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 2. \\<not> (\\<forall>e\\<in>rel ` gs. rel g dvd e) \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "case dv: True"], ["proof (state)\nthis:\n  \\<forall>e\\<in>rel ` gs. rel g dvd e\n\ngoal (2 subgoals):\n 1. \\<forall>e\\<in>rel ` gs. rel g dvd e \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 2. \\<not> (\\<forall>e\\<in>rel ` gs. rel g dvd e) \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "define tau where \"tau = finprod G (\\<lambda>x. x [^] ((rel x) div rel g)) gs\""], ["proof (state)\nthis:\n  tau = (\\<Otimes>x\\<in>gs. x [^] (rel x div rel g))\n\ngoal (2 subgoals):\n 1. \\<forall>e\\<in>rel ` gs. rel g dvd e \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 2. \\<not> (\\<forall>e\\<in>rel ` gs. rel g dvd e) \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "have tc: \"tau \\<in> carrier G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tau \\<in> carrier G", "by (subst tau_def, intro finprod_closed[of \"(\\<lambda>x. x [^] ((rel x) div rel g))\" gs], use gsc in fast)"], ["proof (state)\nthis:\n  tau \\<in> carrier G\n\ngoal (2 subgoals):\n 1. \\<forall>e\\<in>rel ` gs. rel g dvd e \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 2. \\<not> (\\<forall>e\\<in>rel ` gs. rel g dvd e) \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "have gts: \"generate G gs = generate G (gs - {g} \\<union> {tau})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generate G gs = generate G (gs - {g} \\<union> {tau})", "proof(intro generate_one_switched_eqI[OF gsc gr(3), of _ tau])"], ["proof (state)\ngoal (3 subgoals):\n 1. gs - {g} \\<union> {tau} = gs - {g} \\<union> {tau}\n 2. tau \\<in> generate G gs\n 3. g \\<in> generate G (gs - {g} \\<union> {tau})", "show \"tau \\<in> generate G gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tau \\<in> generate G gs", "by (subst generate_eq_finprod_Pi_int_image[OF fgs gsc], unfold tau_def, fast)"], ["proof (state)\nthis:\n  tau \\<in> generate G gs\n\ngoal (2 subgoals):\n 1. gs - {g} \\<union> {tau} = gs - {g} \\<union> {tau}\n 2. g \\<in> generate G (gs - {g} \\<union> {tau})", "show \"g \\<in> generate G (gs - {g} \\<union> {tau})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<in> generate G (gs - {g} \\<union> {tau})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. g \\<in> generate G (gs - {g} \\<union> {tau})", "have \"tau = g \\<otimes> finprod G (\\<lambda>x. x [^] ((rel x) div rel g)) (gs - {g})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tau = g \\<otimes> (\\<Otimes>x\\<in>gs - {g}. x [^] (rel x div rel g))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. tau = g \\<otimes> (\\<Otimes>x\\<in>gs - {g}. x [^] (rel x div rel g))", "have \"finprod G (\\<lambda>x. x [^] ((rel x) div rel g)) gs = g [^] (rel g div rel g) \\<otimes> finprod G (\\<lambda>x. x [^] ((rel x) div rel g)) (gs - {g})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Otimes>x\\<in>gs. x [^] (rel x div rel g)) =\n    g [^] (rel g div rel g) \\<otimes>\n    (\\<Otimes>x\\<in>gs - {g}. x [^] (rel x div rel g))", "by (intro finprod_minus[OF gr(3) _ fgs], use gsc in fast)"], ["proof (state)\nthis:\n  (\\<Otimes>x\\<in>gs. x [^] (rel x div rel g)) =\n  g [^] (rel g div rel g) \\<otimes>\n  (\\<Otimes>x\\<in>gs - {g}. x [^] (rel x div rel g))\n\ngoal (1 subgoal):\n 1. tau = g \\<otimes> (\\<Otimes>x\\<in>gs - {g}. x [^] (rel x div rel g))", "moreover"], ["proof (state)\nthis:\n  (\\<Otimes>x\\<in>gs. x [^] (rel x div rel g)) =\n  g [^] (rel g div rel g) \\<otimes>\n  (\\<Otimes>x\\<in>gs - {g}. x [^] (rel x div rel g))\n\ngoal (1 subgoal):\n 1. tau = g \\<otimes> (\\<Otimes>x\\<in>gs - {g}. x [^] (rel x div rel g))", "have \"g [^] (rel g div rel g) = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g [^] (rel g div rel g) = g", "using gr gsc"], ["proof (prove)\nusing this:\n  gs \\<in> all_gens\n  rel \\<in> relations gs\n  g \\<in> gs\n  rel g = int min_exp\n  0 < min_exp\n  gs \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. g [^] (rel g div rel g) = g", "by auto"], ["proof (state)\nthis:\n  g [^] (rel g div rel g) = g\n\ngoal (1 subgoal):\n 1. tau = g \\<otimes> (\\<Otimes>x\\<in>gs - {g}. x [^] (rel x div rel g))", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Otimes>x\\<in>gs. x [^] (rel x div rel g)) =\n  g [^] (rel g div rel g) \\<otimes>\n  (\\<Otimes>x\\<in>gs - {g}. x [^] (rel x div rel g))\n  g [^] (rel g div rel g) = g", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Otimes>x\\<in>gs. x [^] (rel x div rel g)) =\n  g [^] (rel g div rel g) \\<otimes>\n  (\\<Otimes>x\\<in>gs - {g}. x [^] (rel x div rel g))\n  g [^] (rel g div rel g) = g\n\ngoal (1 subgoal):\n 1. tau = g \\<otimes> (\\<Otimes>x\\<in>gs - {g}. x [^] (rel x div rel g))", "unfolding tau_def"], ["proof (prove)\nusing this:\n  (\\<Otimes>x\\<in>gs. x [^] (rel x div rel g)) =\n  g [^] (rel g div rel g) \\<otimes>\n  (\\<Otimes>x\\<in>gs - {g}. x [^] (rel x div rel g))\n  g [^] (rel g div rel g) = g\n\ngoal (1 subgoal):\n 1. (\\<Otimes>x\\<in>gs. x [^] (rel x div rel g)) =\n    g \\<otimes> (\\<Otimes>x\\<in>gs - {g}. x [^] (rel x div rel g))", "by argo"], ["proof (state)\nthis:\n  tau = g \\<otimes> (\\<Otimes>x\\<in>gs - {g}. x [^] (rel x div rel g))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  tau = g \\<otimes> (\\<Otimes>x\\<in>gs - {g}. x [^] (rel x div rel g))\n\ngoal (1 subgoal):\n 1. g \\<in> generate G (gs - {g} \\<union> {tau})", "hence gti: \"g = tau \\<otimes> inv finprod G (\\<lambda>x. x [^] ((rel x) div rel g)) (gs - {g})\""], ["proof (prove)\nusing this:\n  tau = g \\<otimes> (\\<Otimes>x\\<in>gs - {g}. x [^] (rel x div rel g))\n\ngoal (1 subgoal):\n 1. g = tau \\<otimes> inv (\\<Otimes>x\\<in>gs - {g}. x [^] (rel x div rel g))", "using inv_solve_right[OF gc tc finprod_closed[of \"(\\<lambda>x. x [^] ((rel x) div rel g))\" \"gs - {g}\"]] gsc"], ["proof (prove)\nusing this:\n  tau = g \\<otimes> (\\<Otimes>x\\<in>gs - {g}. x [^] (rel x div rel g))\n  (\\<lambda>x. x [^] (rel x div rel g))\n  \\<in> gs - {g} \\<rightarrow> carrier G \\<Longrightarrow>\n  (g =\n   tau \\<otimes> inv (\\<Otimes>x\\<in>gs - {g}. x [^] (rel x div rel g))) =\n  (tau = g \\<otimes> (\\<Otimes>x\\<in>gs - {g}. x [^] (rel x div rel g)))\n  gs \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. g = tau \\<otimes> inv (\\<Otimes>x\\<in>gs - {g}. x [^] (rel x div rel g))", "by fast"], ["proof (state)\nthis:\n  g = tau \\<otimes> inv (\\<Otimes>x\\<in>gs - {g}. x [^] (rel x div rel g))\n\ngoal (1 subgoal):\n 1. g \\<in> generate G (gs - {g} \\<union> {tau})", "have \"tau \\<in> generate G (gs - {g} \\<union> {tau})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tau \\<in> generate G (gs - {g} \\<union> {tau})", "by (intro generate.incl[of tau], simp)"], ["proof (state)\nthis:\n  tau \\<in> generate G (gs - {g} \\<union> {tau})\n\ngoal (1 subgoal):\n 1. g \\<in> generate G (gs - {g} \\<union> {tau})", "moreover"], ["proof (state)\nthis:\n  tau \\<in> generate G (gs - {g} \\<union> {tau})\n\ngoal (1 subgoal):\n 1. g \\<in> generate G (gs - {g} \\<union> {tau})", "have \"inv finprod G (\\<lambda>x. x [^] ((rel x) div rel g)) (gs - {g}) \\<in> generate G (gs - {g})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv (\\<Otimes>x\\<in>gs - {g}. x [^] (rel x div rel g))\n    \\<in> generate G (gs - {g})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inv (\\<Otimes>x\\<in>gs - {g}. x [^] (rel x div rel g))\n    \\<in> generate G (gs - {g})", "have \"finprod G (\\<lambda>x. x [^] ((rel x) div rel g)) (gs - {g}) \\<in> generate G (gs - {g})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Otimes>x\\<in>gs - {g}. x [^] (rel x div rel g))\n    \\<in> generate G (gs - {g})", "using generate_eq_finprod_Pi_int_image[of \"gs - {g}\"] fgs gsc"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (gs - {g}); gs - {g} \\<subseteq> carrier G\\<rbrakk>\n  \\<Longrightarrow> generate G (gs - {g}) =\n                    (\\<lambda>x. \\<Otimes>g\\<in>gs - {g}. g [^] x g) `\n                    (gs - {g} \\<rightarrow> UNIV)\n  finite gs\n  gs \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. (\\<Otimes>x\\<in>gs - {g}. x [^] (rel x div rel g))\n    \\<in> generate G (gs - {g})", "by fast"], ["proof (state)\nthis:\n  (\\<Otimes>x\\<in>gs - {g}. x [^] (rel x div rel g))\n  \\<in> generate G (gs - {g})\n\ngoal (1 subgoal):\n 1. inv (\\<Otimes>x\\<in>gs - {g}. x [^] (rel x div rel g))\n    \\<in> generate G (gs - {g})", "from  generate_m_inv_closed[OF _ this] gsc"], ["proof (chain)\npicking this:\n  gs - {g} \\<subseteq> carrier G \\<Longrightarrow>\n  inv (\\<Otimes>x\\<in>gs - {g}. x [^] (rel x div rel g))\n  \\<in> generate G (gs - {g})\n  gs \\<subseteq> carrier G", "show ?thesis"], ["proof (prove)\nusing this:\n  gs - {g} \\<subseteq> carrier G \\<Longrightarrow>\n  inv (\\<Otimes>x\\<in>gs - {g}. x [^] (rel x div rel g))\n  \\<in> generate G (gs - {g})\n  gs \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. inv (\\<Otimes>x\\<in>gs - {g}. x [^] (rel x div rel g))\n    \\<in> generate G (gs - {g})", "by blast"], ["proof (state)\nthis:\n  inv (\\<Otimes>x\\<in>gs - {g}. x [^] (rel x div rel g))\n  \\<in> generate G (gs - {g})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inv (\\<Otimes>x\\<in>gs - {g}. x [^] (rel x div rel g))\n  \\<in> generate G (gs - {g})\n\ngoal (1 subgoal):\n 1. g \\<in> generate G (gs - {g} \\<union> {tau})", "ultimately"], ["proof (chain)\npicking this:\n  tau \\<in> generate G (gs - {g} \\<union> {tau})\n  inv (\\<Otimes>x\\<in>gs - {g}. x [^] (rel x div rel g))\n  \\<in> generate G (gs - {g})", "show ?thesis"], ["proof (prove)\nusing this:\n  tau \\<in> generate G (gs - {g} \\<union> {tau})\n  inv (\\<Otimes>x\\<in>gs - {g}. x [^] (rel x div rel g))\n  \\<in> generate G (gs - {g})\n\ngoal (1 subgoal):\n 1. g \\<in> generate G (gs - {g} \\<union> {tau})", "by (subst gti, intro generate.eng, use mono_generate[of \"gs - {g}\"] in auto)"], ["proof (state)\nthis:\n  g \\<in> generate G (gs - {g} \\<union> {tau})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  g \\<in> generate G (gs - {g} \\<union> {tau})\n\ngoal (1 subgoal):\n 1. gs - {g} \\<union> {tau} = gs - {g} \\<union> {tau}", "qed simp"], ["proof (state)\nthis:\n  generate G gs = generate G (gs - {g} \\<union> {tau})\n\ngoal (2 subgoals):\n 1. \\<forall>e\\<in>rel ` gs. rel g dvd e \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 2. \\<not> (\\<forall>e\\<in>rel ` gs. rel g dvd e) \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "with gr(1)"], ["proof (chain)\npicking this:\n  gs \\<in> all_gens\n  generate G gs = generate G (gs - {g} \\<union> {tau})", "have gt: \"generate G (gs - {g} \\<union> {tau}) = generate G A\""], ["proof (prove)\nusing this:\n  gs \\<in> all_gens\n  generate G gs = generate G (gs - {g} \\<union> {tau})\n\ngoal (1 subgoal):\n 1. generate G (gs - {g} \\<union> {tau}) = generate G A", "unfolding all_gens_def"], ["proof (prove)\nusing this:\n  gs \\<in> {gs \\<in> Pow (generate G A).\n            finite gs \\<and>\n            card gs \\<le> n \\<and> generate G gs = generate G A}\n  generate G gs = generate G (gs - {g} \\<union> {tau})\n\ngoal (1 subgoal):\n 1. generate G (gs - {g} \\<union> {tau}) = generate G A", "by blast"], ["proof (state)\nthis:\n  generate G (gs - {g} \\<union> {tau}) = generate G A\n\ngoal (2 subgoals):\n 1. \\<forall>e\\<in>rel ` gs. rel g dvd e \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 2. \\<not> (\\<forall>e\\<in>rel ` gs. rel g dvd e) \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "have trgo: \"tau [^] rel g = \\<one>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tau [^] rel g = \\<one>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. tau [^] rel g = \\<one>", "have \"tau [^] rel g = finprod G (\\<lambda>x. x [^] ((rel x) div rel g)) gs [^] rel g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tau [^] rel g = (\\<Otimes>x\\<in>gs. x [^] (rel x div rel g)) [^] rel g", "unfolding tau_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Otimes>x\\<in>gs. x [^] (rel x div rel g)) [^] rel g =\n    (\\<Otimes>x\\<in>gs. x [^] (rel x div rel g)) [^] rel g", "by blast"], ["proof (state)\nthis:\n  tau [^] rel g = (\\<Otimes>x\\<in>gs. x [^] (rel x div rel g)) [^] rel g\n\ngoal (1 subgoal):\n 1. tau [^] rel g = \\<one>", "also"], ["proof (state)\nthis:\n  tau [^] rel g = (\\<Otimes>x\\<in>gs. x [^] (rel x div rel g)) [^] rel g\n\ngoal (1 subgoal):\n 1. tau [^] rel g = \\<one>", "have \"\\<dots> = finprod G ((\\<lambda>x. x [^] rel g) \\<circ> (\\<lambda>x. x [^] ((rel x) div rel g))) gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Otimes>x\\<in>gs. x [^] (rel x div rel g)) [^] rel g =\n    finprod G\n     ((\\<lambda>x. x [^] rel g) \\<circ>\n      (\\<lambda>x. x [^] (rel x div rel g)))\n     gs", "by (intro finprod_exp, use gsc in auto)"], ["proof (state)\nthis:\n  (\\<Otimes>x\\<in>gs. x [^] (rel x div rel g)) [^] rel g =\n  finprod G\n   ((\\<lambda>x. x [^] rel g) \\<circ> (\\<lambda>x. x [^] (rel x div rel g)))\n   gs\n\ngoal (1 subgoal):\n 1. tau [^] rel g = \\<one>", "also"], ["proof (state)\nthis:\n  (\\<Otimes>x\\<in>gs. x [^] (rel x div rel g)) [^] rel g =\n  finprod G\n   ((\\<lambda>x. x [^] rel g) \\<circ> (\\<lambda>x. x [^] (rel x div rel g)))\n   gs\n\ngoal (1 subgoal):\n 1. tau [^] rel g = \\<one>", "have \"\\<dots> = finprod G (\\<lambda>a. a [^] rel a) gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finprod G\n     ((\\<lambda>x. x [^] rel g) \\<circ>\n      (\\<lambda>x. x [^] (rel x div rel g)))\n     gs =\n    (\\<Otimes>a\\<in>gs. a [^] rel a)", "proof(intro finprod_cong')"], ["proof (state)\ngoal (3 subgoals):\n 1. gs = gs\n 2. (\\<lambda>a. a [^] rel a) \\<in> gs \\<rightarrow> carrier G\n 3. \\<And>i.\n       i \\<in> gs \\<Longrightarrow>\n       ((\\<lambda>x. x [^] rel g) \\<circ>\n        (\\<lambda>x. x [^] (rel x div rel g)))\n        i =\n       i [^] rel i", "show \"((\\<lambda>x. x [^] rel g) \\<circ> (\\<lambda>x. x [^] ((rel x) div rel g))) x = x [^] rel x\" if \"x \\<in> gs\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. x [^] rel g) \\<circ>\n     (\\<lambda>x. x [^] (rel x div rel g)))\n     x =\n    x [^] rel x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. x [^] rel g) \\<circ>\n     (\\<lambda>x. x [^] (rel x div rel g)))\n     x =\n    x [^] rel x", "have \"((\\<lambda>x. x [^] rel g) \\<circ> (\\<lambda>x. x [^] ((rel x) div rel g))) x = x [^] (((rel x) div rel g) * rel g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. x [^] rel g) \\<circ>\n     (\\<lambda>x. x [^] (rel x div rel g)))\n     x =\n    x [^] (rel x div rel g * rel g)", "using that gsc int_pow_pow"], ["proof (prove)\nusing this:\n  x \\<in> gs\n  gs \\<subseteq> carrier G\n  ?x \\<in> carrier G \\<Longrightarrow> (?x [^] ?n) [^] ?m = ?x [^] (?n * ?m)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. x [^] rel g) \\<circ>\n     (\\<lambda>x. x [^] (rel x div rel g)))\n     x =\n    x [^] (rel x div rel g * rel g)", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>x. x [^] rel g) \\<circ> (\\<lambda>x. x [^] (rel x div rel g)))\n   x =\n  x [^] (rel x div rel g * rel g)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. x [^] rel g) \\<circ>\n     (\\<lambda>x. x [^] (rel x div rel g)))\n     x =\n    x [^] rel x", "also"], ["proof (state)\nthis:\n  ((\\<lambda>x. x [^] rel g) \\<circ> (\\<lambda>x. x [^] (rel x div rel g)))\n   x =\n  x [^] (rel x div rel g * rel g)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. x [^] rel g) \\<circ>\n     (\\<lambda>x. x [^] (rel x div rel g)))\n     x =\n    x [^] rel x", "have \"\\<dots> = x [^] rel x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x [^] (rel x div rel g * rel g) = x [^] rel x", "using dv that"], ["proof (prove)\nusing this:\n  \\<forall>e\\<in>rel ` gs. rel g dvd e\n  x \\<in> gs\n\ngoal (1 subgoal):\n 1. x [^] (rel x div rel g * rel g) = x [^] rel x", "by auto"], ["proof (state)\nthis:\n  x [^] (rel x div rel g * rel g) = x [^] rel x\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. x [^] rel g) \\<circ>\n     (\\<lambda>x. x [^] (rel x div rel g)))\n     x =\n    x [^] rel x", "finally"], ["proof (chain)\npicking this:\n  ((\\<lambda>x. x [^] rel g) \\<circ> (\\<lambda>x. x [^] (rel x div rel g)))\n   x =\n  x [^] rel x", "show ?thesis"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. x [^] rel g) \\<circ> (\\<lambda>x. x [^] (rel x div rel g)))\n   x =\n  x [^] rel x\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. x [^] rel g) \\<circ>\n     (\\<lambda>x. x [^] (rel x div rel g)))\n     x =\n    x [^] rel x", "."], ["proof (state)\nthis:\n  ((\\<lambda>x. x [^] rel g) \\<circ> (\\<lambda>x. x [^] (rel x div rel g)))\n   x =\n  x [^] rel x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x2 \\<in> gs \\<Longrightarrow>\n  ((\\<lambda>x. x [^] rel g) \\<circ> (\\<lambda>x. x [^] (rel x div rel g)))\n   ?x2 =\n  ?x2 [^] rel ?x2\n\ngoal (2 subgoals):\n 1. gs = gs\n 2. (\\<lambda>a. a [^] rel a) \\<in> gs \\<rightarrow> carrier G", "qed (use gsc in auto)"], ["proof (state)\nthis:\n  finprod G\n   ((\\<lambda>x. x [^] rel g) \\<circ> (\\<lambda>x. x [^] (rel x div rel g)))\n   gs =\n  (\\<Otimes>a\\<in>gs. a [^] rel a)\n\ngoal (1 subgoal):\n 1. tau [^] rel g = \\<one>", "also"], ["proof (state)\nthis:\n  finprod G\n   ((\\<lambda>x. x [^] rel g) \\<circ> (\\<lambda>x. x [^] (rel x div rel g)))\n   gs =\n  (\\<Otimes>a\\<in>gs. a [^] rel a)\n\ngoal (1 subgoal):\n 1. tau [^] rel g = \\<one>", "have \"\\<dots> = \\<one>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Otimes>a\\<in>gs. a [^] rel a) = \\<one>", "using gr(2)"], ["proof (prove)\nusing this:\n  rel \\<in> relations gs\n\ngoal (1 subgoal):\n 1. (\\<Otimes>a\\<in>gs. a [^] rel a) = \\<one>", "unfolding relations_def"], ["proof (prove)\nusing this:\n  rel\n  \\<in> {f. (\\<Otimes>a\\<in>gs. a [^] f a) = \\<one>} \\<inter> extensional gs\n\ngoal (1 subgoal):\n 1. (\\<Otimes>a\\<in>gs. a [^] rel a) = \\<one>", "by blast"], ["proof (state)\nthis:\n  (\\<Otimes>a\\<in>gs. a [^] rel a) = \\<one>\n\ngoal (1 subgoal):\n 1. tau [^] rel g = \\<one>", "finally"], ["proof (chain)\npicking this:\n  tau [^] rel g = \\<one>", "show ?thesis"], ["proof (prove)\nusing this:\n  tau [^] rel g = \\<one>\n\ngoal (1 subgoal):\n 1. tau [^] rel g = \\<one>", "."], ["proof (state)\nthis:\n  tau [^] rel g = \\<one>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  tau [^] rel g = \\<one>\n\ngoal (2 subgoals):\n 1. \\<forall>e\\<in>rel ` gs. rel g dvd e \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 2. \\<not> (\\<forall>e\\<in>rel ` gs. rel g dvd e) \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "hence otdrg: \"ord tau dvd rel g\""], ["proof (prove)\nusing this:\n  tau [^] rel g = \\<one>\n\ngoal (1 subgoal):\n 1. int (ord tau) dvd rel g", "using tc int_pow_eq_id"], ["proof (prove)\nusing this:\n  tau [^] rel g = \\<one>\n  tau \\<in> carrier G\n  ?x \\<in> carrier G \\<Longrightarrow>\n  (?x [^] ?i = \\<one>) = (int (ord ?x) dvd ?i)\n\ngoal (1 subgoal):\n 1. int (ord tau) dvd rel g", "by force"], ["proof (state)\nthis:\n  int (ord tau) dvd rel g\n\ngoal (2 subgoals):\n 1. \\<forall>e\\<in>rel ` gs. rel g dvd e \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 2. \\<not> (\\<forall>e\\<in>rel ` gs. rel g dvd e) \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "have ot: \"ord tau = rel g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (ord tau) = rel g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (ord tau) = rel g", "from gr(4, 5)"], ["proof (chain)\npicking this:\n  rel g = int min_exp\n  0 < min_exp", "have \"rel g > 0\""], ["proof (prove)\nusing this:\n  rel g = int min_exp\n  0 < min_exp\n\ngoal (1 subgoal):\n 1. 0 < rel g", "by simp"], ["proof (state)\nthis:\n  0 < rel g\n\ngoal (1 subgoal):\n 1. int (ord tau) = rel g", "with otdrg"], ["proof (chain)\npicking this:\n  int (ord tau) dvd rel g\n  0 < rel g", "have \"ord tau \\<le> rel g\""], ["proof (prove)\nusing this:\n  int (ord tau) dvd rel g\n  0 < rel g\n\ngoal (1 subgoal):\n 1. int (ord tau) \\<le> rel g", "by (meson zdvd_imp_le)"], ["proof (state)\nthis:\n  int (ord tau) \\<le> rel g\n\ngoal (1 subgoal):\n 1. int (ord tau) = rel g", "moreover"], ["proof (state)\nthis:\n  int (ord tau) \\<le> rel g\n\ngoal (1 subgoal):\n 1. int (ord tau) = rel g", "have \"\\<not>ord tau < rel g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> int (ord tau) < rel g", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. int (ord tau) < rel g \\<Longrightarrow> False", "assume a: \"int (ord tau) < rel g\""], ["proof (state)\nthis:\n  int (ord tau) < rel g\n\ngoal (1 subgoal):\n 1. int (ord tau) < rel g \\<Longrightarrow> False", "define T where T: \"T = gs - {g} \\<union> {tau}\""], ["proof (state)\nthis:\n  T = gs - {g} \\<union> {tau}\n\ngoal (1 subgoal):\n 1. int (ord tau) < rel g \\<Longrightarrow> False", "hence tT: \"tau \\<in> T\""], ["proof (prove)\nusing this:\n  T = gs - {g} \\<union> {tau}\n\ngoal (1 subgoal):\n 1. tau \\<in> T", "by blast"], ["proof (state)\nthis:\n  tau \\<in> T\n\ngoal (1 subgoal):\n 1. int (ord tau) < rel g \\<Longrightarrow> False", "let ?r = \"restrict ((\\<lambda>_.(0::int))(tau := int(ord tau))) T\""], ["proof (state)\ngoal (1 subgoal):\n 1. int (ord tau) < rel g \\<Longrightarrow> False", "from T"], ["proof (chain)\npicking this:\n  T = gs - {g} \\<union> {tau}", "have \"T \\<in> all_gens\""], ["proof (prove)\nusing this:\n  T = gs - {g} \\<union> {tau}\n\ngoal (1 subgoal):\n 1. T \\<in> all_gens", "using gt generate_sincl[of \"gs - {g} \\<union> {tau}\"] switch_elem_card_le[OF gr(3), of tau] fgs cgs n"], ["proof (prove)\nusing this:\n  T = gs - {g} \\<union> {tau}\n  generate G (gs - {g} \\<union> {tau}) = generate G A\n  gs - {g} \\<union> {tau} \\<subseteq> generate G (gs - {g} \\<union> {tau})\n  card (gs - {g} \\<union> {tau}) \\<le> card gs\n  finite gs\n  card gs \\<le> card A\n  n = card A\n\ngoal (1 subgoal):\n 1. T \\<in> all_gens", "unfolding all_gens_def"], ["proof (prove)\nusing this:\n  T = gs - {g} \\<union> {tau}\n  generate G (gs - {g} \\<union> {tau}) = generate G A\n  gs - {g} \\<union> {tau} \\<subseteq> generate G (gs - {g} \\<union> {tau})\n  card (gs - {g} \\<union> {tau}) \\<le> card gs\n  finite gs\n  card gs \\<le> card A\n  n = card A\n\ngoal (1 subgoal):\n 1. T \\<in> {gs \\<in> Pow (generate G A).\n             finite gs \\<and>\n             card gs \\<le> n \\<and> generate G gs = generate G A}", "by auto"], ["proof (state)\nthis:\n  T \\<in> all_gens\n\ngoal (1 subgoal):\n 1. int (ord tau) < rel g \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  T \\<in> all_gens\n\ngoal (1 subgoal):\n 1. int (ord tau) < rel g \\<Longrightarrow> False", "have \"?r \\<in> relations T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict ((\\<lambda>_. 0)(tau := int (ord tau))) T \\<in> relations T", "proof(intro in_relationsI finprod_one_eqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> T \\<Longrightarrow>\n       x [^] restrict ((\\<lambda>_. 0)(tau := int (ord tau))) T x = \\<one>\n 2. restrict ((\\<lambda>_. 0)(tau := int (ord tau))) T \\<in> extensional T", "have \"tau [^] int (ord tau) = \\<one>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tau [^] int (ord tau) = \\<one>", "using tc pow_ord_eq_1[OF tc] int_pow_int"], ["proof (prove)\nusing this:\n  tau \\<in> carrier G\n  tau [^] ord tau = \\<one>\n  ?x [^]\\<^bsub>?G\\<^esub> int ?n = ?x [^]\\<^bsub>?G\\<^esub> ?n\n\ngoal (1 subgoal):\n 1. tau [^] int (ord tau) = \\<one>", "by metis"], ["proof (state)\nthis:\n  tau [^] int (ord tau) = \\<one>\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> T \\<Longrightarrow>\n       x [^] restrict ((\\<lambda>_. 0)(tau := int (ord tau))) T x = \\<one>\n 2. restrict ((\\<lambda>_. 0)(tau := int (ord tau))) T \\<in> extensional T", "thus \"x [^] ?r x = \\<one>\" if \"x \\<in> T\" for x"], ["proof (prove)\nusing this:\n  tau [^] int (ord tau) = \\<one>\n\ngoal (1 subgoal):\n 1. x [^] restrict ((\\<lambda>_. 0)(tau := int (ord tau))) T x = \\<one>", "using tT that"], ["proof (prove)\nusing this:\n  tau [^] int (ord tau) = \\<one>\n  tau \\<in> T\n  x \\<in> T\n\ngoal (1 subgoal):\n 1. x [^] restrict ((\\<lambda>_. 0)(tau := int (ord tau))) T x = \\<one>", "by(cases \"\\<not>x = tau\", auto)"], ["proof (state)\nthis:\n  ?x2 \\<in> T \\<Longrightarrow>\n  ?x2 [^] restrict ((\\<lambda>_. 0)(tau := int (ord tau))) T ?x2 = \\<one>\n\ngoal (1 subgoal):\n 1. restrict ((\\<lambda>_. 0)(tau := int (ord tau))) T \\<in> extensional T", "qed auto"], ["proof (state)\nthis:\n  restrict ((\\<lambda>_. 0)(tau := int (ord tau))) T \\<in> relations T\n\ngoal (1 subgoal):\n 1. int (ord tau) < rel g \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  restrict ((\\<lambda>_. 0)(tau := int (ord tau))) T \\<in> relations T\n\ngoal (1 subgoal):\n 1. int (ord tau) < rel g \\<Longrightarrow> False", "have \"?r tau = ord tau\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict ((\\<lambda>_. 0)(tau := int (ord tau))) T tau = int (ord tau)", "using tT"], ["proof (prove)\nusing this:\n  tau \\<in> T\n\ngoal (1 subgoal):\n 1. restrict ((\\<lambda>_. 0)(tau := int (ord tau))) T tau = int (ord tau)", "by auto"], ["proof (state)\nthis:\n  restrict ((\\<lambda>_. 0)(tau := int (ord tau))) T tau = int (ord tau)\n\ngoal (1 subgoal):\n 1. int (ord tau) < rel g \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  restrict ((\\<lambda>_. 0)(tau := int (ord tau))) T tau = int (ord tau)\n\ngoal (1 subgoal):\n 1. int (ord tau) < rel g \\<Longrightarrow> False", "have \"ord tau > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < ord tau", "using dvd_nat_bounds gr(4) gr(5) int_dvd_int_iff otdrg"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?p; ?n dvd ?p\\<rbrakk>\n  \\<Longrightarrow> 0 < ?n \\<and> ?n \\<le> ?p\n  rel g = int min_exp\n  0 < min_exp\n  (int ?m dvd int ?n) = (?m dvd ?n)\n  int (ord tau) dvd rel g\n\ngoal (1 subgoal):\n 1. 0 < ord tau", "by presburger"], ["proof (state)\nthis:\n  0 < ord tau\n\ngoal (1 subgoal):\n 1. int (ord tau) < rel g \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  T \\<in> all_gens\n  restrict ((\\<lambda>_. 0)(tau := int (ord tau))) T \\<in> relations T\n  restrict ((\\<lambda>_. 0)(tau := int (ord tau))) T tau = int (ord tau)\n  0 < ord tau", "have \"ord tau \\<in> exps\""], ["proof (prove)\nusing this:\n  T \\<in> all_gens\n  restrict ((\\<lambda>_. 0)(tau := int (ord tau))) T \\<in> relations T\n  restrict ((\\<lambda>_. 0)(tau := int (ord tau))) T tau = int (ord tau)\n  0 < ord tau\n\ngoal (1 subgoal):\n 1. ord tau \\<in> exps", "unfolding exps_def"], ["proof (prove)\nusing this:\n  T \\<in> all_gens\n  restrict ((\\<lambda>_. 0)(tau := int (ord tau))) T \\<in> relations T\n  restrict ((\\<lambda>_. 0)(tau := int (ord tau))) T tau = int (ord tau)\n  0 < ord tau\n\ngoal (1 subgoal):\n 1. ord tau\n    \\<in> (\\<Union>gs'\\<in>all_gens.\n              \\<Union>rel\\<in>relations gs'.\n                 nat ` {e \\<in> rel ` gs'. 0 < e})", "using tT"], ["proof (prove)\nusing this:\n  T \\<in> all_gens\n  restrict ((\\<lambda>_. 0)(tau := int (ord tau))) T \\<in> relations T\n  restrict ((\\<lambda>_. 0)(tau := int (ord tau))) T tau = int (ord tau)\n  0 < ord tau\n  tau \\<in> T\n\ngoal (1 subgoal):\n 1. ord tau\n    \\<in> (\\<Union>gs'\\<in>all_gens.\n              \\<Union>rel\\<in>relations gs'.\n                 nat ` {e \\<in> rel ` gs'. 0 < e})", "by (auto, force)"], ["proof (state)\nthis:\n  ord tau \\<in> exps\n\ngoal (1 subgoal):\n 1. int (ord tau) < rel g \\<Longrightarrow> False", "with le a gr(4)"], ["proof (chain)\npicking this:\n  ?x2 \\<in> exps \\<Longrightarrow> min_exp \\<le> ?x2\n  int (ord tau) < rel g\n  rel g = int min_exp\n  ord tau \\<in> exps", "show False"], ["proof (prove)\nusing this:\n  ?x2 \\<in> exps \\<Longrightarrow> min_exp \\<le> ?x2\n  int (ord tau) < rel g\n  rel g = int min_exp\n  ord tau \\<in> exps\n\ngoal (1 subgoal):\n 1. False", "by force"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> int (ord tau) < rel g\n\ngoal (1 subgoal):\n 1. int (ord tau) = rel g", "ultimately"], ["proof (chain)\npicking this:\n  int (ord tau) \\<le> rel g\n  \\<not> int (ord tau) < rel g", "show ?thesis"], ["proof (prove)\nusing this:\n  int (ord tau) \\<le> rel g\n  \\<not> int (ord tau) < rel g\n\ngoal (1 subgoal):\n 1. int (ord tau) = rel g", "by auto"], ["proof (state)\nthis:\n  int (ord tau) = rel g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  int (ord tau) = rel g\n\ngoal (2 subgoals):\n 1. \\<forall>e\\<in>rel ` gs. rel g dvd e \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 2. \\<not> (\\<forall>e\\<in>rel ` gs. rel g dvd e) \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "hence otnz: \"ord tau \\<noteq> 0\""], ["proof (prove)\nusing this:\n  int (ord tau) = rel g\n\ngoal (1 subgoal):\n 1. ord tau \\<noteq> 0", "using gr me exps_def"], ["proof (prove)\nusing this:\n  int (ord tau) = rel g\n  gs \\<in> all_gens\n  rel \\<in> relations gs\n  g \\<in> gs\n  rel g = int min_exp\n  0 < min_exp\n  min_exp \\<in> exps\n  exps =\n  (\\<Union>gs'\\<in>all_gens.\n      \\<Union>rel\\<in>relations gs'. nat ` {e \\<in> rel ` gs'. 0 < e})\n\ngoal (1 subgoal):\n 1. ord tau \\<noteq> 0", "by linarith"], ["proof (state)\nthis:\n  ord tau \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<forall>e\\<in>rel ` gs. rel g dvd e \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 2. \\<not> (\\<forall>e\\<in>rel ` gs. rel g dvd e) \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "define l where l: \"l = tau#hs\""], ["proof (state)\nthis:\n  l = tau # hs\n\ngoal (2 subgoals):\n 1. \\<forall>e\\<in>rel ` gs. rel g dvd e \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 2. \\<not> (\\<forall>e\\<in>rel ` gs. rel g dvd e) \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "hence ls: \"set l = set hs \\<union> {tau}\""], ["proof (prove)\nusing this:\n  l = tau # hs\n\ngoal (1 subgoal):\n 1. set l = set hs \\<union> {tau}", "by auto"], ["proof (state)\nthis:\n  set l = set hs \\<union> {tau}\n\ngoal (2 subgoals):\n 1. \\<forall>e\\<in>rel ` gs. rel g dvd e \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 2. \\<not> (\\<forall>e\\<in>rel ` gs. rel g dvd e) \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "with hsc tc"], ["proof (chain)\npicking this:\n  set hs \\<subseteq> carrier G\n  tau \\<in> carrier G\n  set l = set hs \\<union> {tau}", "have slc: \"set l \\<subseteq> carrier G\""], ["proof (prove)\nusing this:\n  set hs \\<subseteq> carrier G\n  tau \\<in> carrier G\n  set l = set hs \\<union> {tau}\n\ngoal (1 subgoal):\n 1. set l \\<subseteq> carrier G", "by auto"], ["proof (state)\nthis:\n  set l \\<subseteq> carrier G\n\ngoal (2 subgoals):\n 1. \\<forall>e\\<in>rel ` gs. rel g dvd e \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 2. \\<not> (\\<forall>e\\<in>rel ` gs. rel g dvd e) \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "have gAhst: \"generate G A = generate G (set hs \\<union> {tau})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generate G A = generate G (set hs \\<union> {tau})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. generate G A = generate G (set hs \\<union> {tau})", "have \"generate G A = generate G (gs - {g} \\<union> {tau})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generate G A = generate G (gs - {g} \\<union> {tau})", "using gt"], ["proof (prove)\nusing this:\n  generate G (gs - {g} \\<union> {tau}) = generate G A\n\ngoal (1 subgoal):\n 1. generate G A = generate G (gs - {g} \\<union> {tau})", "by simp"], ["proof (state)\nthis:\n  generate G A = generate G (gs - {g} \\<union> {tau})\n\ngoal (1 subgoal):\n 1. generate G A = generate G (set hs \\<union> {tau})", "also"], ["proof (state)\nthis:\n  generate G A = generate G (gs - {g} \\<union> {tau})\n\ngoal (1 subgoal):\n 1. generate G A = generate G (set hs \\<union> {tau})", "have \"\\<dots> = generate G (set hs \\<union> {tau})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generate G (gs - {g} \\<union> {tau}) =\n    generate G (set hs \\<union> {tau})", "by (rule generate_subset_change_eqI, use hsc gsc tc ghs in auto)"], ["proof (state)\nthis:\n  generate G (gs - {g} \\<union> {tau}) = generate G (set hs \\<union> {tau})\n\ngoal (1 subgoal):\n 1. generate G A = generate G (set hs \\<union> {tau})", "finally"], ["proof (chain)\npicking this:\n  generate G A = generate G (set hs \\<union> {tau})", "show ?thesis"], ["proof (prove)\nusing this:\n  generate G A = generate G (set hs \\<union> {tau})\n\ngoal (1 subgoal):\n 1. generate G A = generate G (set hs \\<union> {tau})", "."], ["proof (state)\nthis:\n  generate G A = generate G (set hs \\<union> {tau})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  generate G A = generate G (set hs \\<union> {tau})\n\ngoal (2 subgoals):\n 1. \\<forall>e\\<in>rel ` gs. rel g dvd e \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 2. \\<not> (\\<forall>e\\<in>rel ` gs. rel g dvd e) \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "have glgA: \"generate G (set l) = generate G A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generate G (set l) = generate G A", "using gAhst ls"], ["proof (prove)\nusing this:\n  generate G A = generate G (set hs \\<union> {tau})\n  set l = set hs \\<union> {tau}\n\ngoal (1 subgoal):\n 1. generate G (set l) = generate G A", "by simp"], ["proof (state)\nthis:\n  generate G (set l) = generate G A\n\ngoal (2 subgoals):\n 1. \\<forall>e\\<in>rel ` gs. rel g dvd e \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 2. \\<not> (\\<forall>e\\<in>rel ` gs. rel g dvd e) \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "have lgA: \"set l \\<subseteq> generate G A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set l \\<subseteq> generate G A", "using ls gt gts hs(1)\n                mono_generate[of \"gs - {g}\" gs] generate.incl[of tau \"gs - {g} \\<union> {tau}\"]"], ["proof (prove)\nusing this:\n  set l = set hs \\<union> {tau}\n  generate G (gs - {g} \\<union> {tau}) = generate G A\n  generate G gs = generate G (gs - {g} \\<union> {tau})\n  set hs \\<subseteq> generate G (gs - {g})\n  gs - {g} \\<subseteq> gs \\<Longrightarrow>\n  generate G (gs - {g}) \\<subseteq> generate G gs\n  tau \\<in> gs - {g} \\<union> {tau} \\<Longrightarrow>\n  tau \\<in> generate ?G (gs - {g} \\<union> {tau})\n\ngoal (1 subgoal):\n 1. set l \\<subseteq> generate G A", "by fast"], ["proof (state)\nthis:\n  set l \\<subseteq> generate G A\n\ngoal (2 subgoals):\n 1. \\<forall>e\\<in>rel ` gs. rel g dvd e \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 2. \\<not> (\\<forall>e\\<in>rel ` gs. rel g dvd e) \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "proof (cases \"ord tau = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ord tau = 1 \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 2. ord tau \\<noteq> 1 \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "case True"], ["proof (state)\nthis:\n  ord tau = 1\n\ngoal (2 subgoals):\n 1. ord tau = 1 \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 2. ord tau \\<noteq> 1 \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "hence \"tau = \\<one>\""], ["proof (prove)\nusing this:\n  ord tau = 1\n\ngoal (1 subgoal):\n 1. tau = \\<one>", "using ord_eq_1 tc"], ["proof (prove)\nusing this:\n  ord tau = 1\n  ?x \\<in> carrier G \\<Longrightarrow> (ord ?x = 1) = (?x = \\<one>)\n  tau \\<in> carrier G\n\ngoal (1 subgoal):\n 1. tau = \\<one>", "by blast"], ["proof (state)\nthis:\n  tau = \\<one>\n\ngoal (2 subgoals):\n 1. ord tau = 1 \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 2. ord tau \\<noteq> 1 \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "hence \"generate G A = generate G (gs - {g})\""], ["proof (prove)\nusing this:\n  tau = \\<one>\n\ngoal (1 subgoal):\n 1. generate G A = generate G (gs - {g})", "using gAhst generate_one_irrel hs(3) ghs"], ["proof (prove)\nusing this:\n  tau = \\<one>\n  generate G A = generate G (set hs \\<union> {tau})\n  generate G ?A = generate G (?A \\<union> {\\<one>})\n  is_idirprod (generate G (gs - {g})) (\\<lambda>g. generate G {g}) (set hs)\n  generate G (gs - {g}) = generate G (set hs)\n\ngoal (1 subgoal):\n 1. generate G A = generate G (gs - {g})", "by auto"], ["proof (state)\nthis:\n  generate G A = generate G (gs - {g})\n\ngoal (2 subgoals):\n 1. ord tau = 1 \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 2. ord tau \\<noteq> 1 \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "from iH2[OF ihgsg this cgsg]"], ["proof (chain)\npicking this:\n  \\<exists>gs.\n     set gs \\<subseteq> generate G A \\<and>\n     cycle gs \\<and>\n     is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set gs) \\<and>\n     successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>gs.\n     set gs \\<subseteq> generate G A \\<and>\n     cycle gs \\<and>\n     is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set gs) \\<and>\n     successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n\ngoal (1 subgoal):\n 1. \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "."], ["proof (state)\nthis:\n  \\<exists>gs.\n     set gs \\<subseteq> generate G A \\<and>\n     cycle gs \\<and>\n     is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set gs) \\<and>\n     successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n\ngoal (1 subgoal):\n 1. ord tau \\<noteq> 1 \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ord tau \\<noteq> 1 \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "case otau: False"], ["proof (state)\nthis:\n  ord tau \\<noteq> 1\n\ngoal (1 subgoal):\n 1. ord tau \\<noteq> 1 \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "consider (nd) \"\\<not>distinct l\" | (ltn) \"length l < n \\<and> distinct l\" | (dn) \"length l = n \\<and> distinct l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> cycle l \\<Longrightarrow> thesis;\n     length l < n \\<and> cycle l \\<Longrightarrow> thesis;\n     length l = n \\<and> cycle l \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> cycle l \\<Longrightarrow> thesis;\n     length l < n \\<and> cycle l \\<Longrightarrow> thesis;\n     length l = n \\<and> cycle l \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"length l \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length l \\<le> n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length l \\<le> n", "have \"length l = length hs + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length l = length hs + 1", "using l"], ["proof (prove)\nusing this:\n  l = tau # hs\n\ngoal (1 subgoal):\n 1. length l = length hs + 1", "by simp"], ["proof (state)\nthis:\n  length l = length hs + 1\n\ngoal (1 subgoal):\n 1. length l \\<le> n", "moreover"], ["proof (state)\nthis:\n  length l = length hs + 1\n\ngoal (1 subgoal):\n 1. length l \\<le> n", "have \"length hs \\<le> card (gs - {g})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length hs \\<le> card (gs - {g})", "using hs(2, 5)"], ["proof (prove)\nusing this:\n  cycle hs\n  card (set hs) \\<le> card (gs - {g})\n\ngoal (1 subgoal):\n 1. length hs \\<le> card (gs - {g})", "by (metis distinct_card)"], ["proof (state)\nthis:\n  length hs \\<le> card (gs - {g})\n\ngoal (1 subgoal):\n 1. length l \\<le> n", "moreover"], ["proof (state)\nthis:\n  length hs \\<le> card (gs - {g})\n\ngoal (1 subgoal):\n 1. length l \\<le> n", "have \"card (gs - {g}) + 1 \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (gs - {g}) + 1 \\<le> n", "using n cgsg gr(3) fgs Ane i(2)"], ["proof (prove)\nusing this:\n  n = card A\n  card (gs - {g}) < card A\n  g \\<in> gs\n  finite gs\n  A \\<noteq> {}\n  finite A\n\ngoal (1 subgoal):\n 1. card (gs - {g}) + 1 \\<le> n", "by (simp add: card_gt_0_iff)"], ["proof (state)\nthis:\n  card (gs - {g}) + 1 \\<le> n\n\ngoal (1 subgoal):\n 1. length l \\<le> n", "ultimately"], ["proof (chain)\npicking this:\n  length l = length hs + 1\n  length hs \\<le> card (gs - {g})\n  card (gs - {g}) + 1 \\<le> n", "show ?thesis"], ["proof (prove)\nusing this:\n  length l = length hs + 1\n  length hs \\<le> card (gs - {g})\n  card (gs - {g}) + 1 \\<le> n\n\ngoal (1 subgoal):\n 1. length l \\<le> n", "by linarith"], ["proof (state)\nthis:\n  length l \\<le> n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length l \\<le> n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> cycle l \\<Longrightarrow> thesis;\n     length l < n \\<and> cycle l \\<Longrightarrow> thesis;\n     length l = n \\<and> cycle l \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus \"\\<lbrakk>\\<not> distinct l \\<Longrightarrow> thesis; length l < n \\<and> distinct l \\<Longrightarrow> thesis; length l = n \\<and> distinct l \\<Longrightarrow> thesis\\<rbrakk> \\<Longrightarrow> thesis\""], ["proof (prove)\nusing this:\n  length l \\<le> n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> cycle l \\<Longrightarrow> thesis;\n     length l < n \\<and> cycle l \\<Longrightarrow> thesis;\n     length l = n \\<and> cycle l \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> cycle l \\<Longrightarrow> thesis;\n   length l < n \\<and> cycle l \\<Longrightarrow> thesis;\n   length l = n \\<and> cycle l \\<Longrightarrow> thesis\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> cycle l \\<Longrightarrow> ?thesis2;\n   length l < n \\<and> cycle l \\<Longrightarrow> ?thesis2;\n   length l = n \\<and> cycle l \\<Longrightarrow> ?thesis2\\<rbrakk>\n  \\<Longrightarrow> ?thesis2\n\ngoal (1 subgoal):\n 1. ord tau \\<noteq> 1 \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> cycle l \\<Longrightarrow> ?thesis2;\n   length l < n \\<and> cycle l \\<Longrightarrow> ?thesis2;\n   length l = n \\<and> cycle l \\<Longrightarrow> ?thesis2\\<rbrakk>\n  \\<Longrightarrow> ?thesis2\n\ngoal (1 subgoal):\n 1. \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "proof(cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<not> cycle l \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 2. length l < n \\<and> cycle l \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 3. length l = n \\<and> cycle l \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "case nd"], ["proof (state)\nthis:\n  \\<not> cycle l\n\ngoal (3 subgoals):\n 1. \\<not> cycle l \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 2. length l < n \\<and> cycle l \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 3. length l = n \\<and> cycle l \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "with hs(2) l"], ["proof (chain)\npicking this:\n  cycle hs\n  l = tau # hs\n  \\<not> cycle l", "have ths: \"set hs = set hs \\<union> {tau}\""], ["proof (prove)\nusing this:\n  cycle hs\n  l = tau # hs\n  \\<not> cycle l\n\ngoal (1 subgoal):\n 1. set hs = set hs \\<union> {tau}", "by auto"], ["proof (state)\nthis:\n  set hs = set hs \\<union> {tau}\n\ngoal (3 subgoals):\n 1. \\<not> cycle l \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 2. length l < n \\<and> cycle l \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 3. length l = n \\<and> cycle l \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "hence \"set l = set hs\""], ["proof (prove)\nusing this:\n  set hs = set hs \\<union> {tau}\n\ngoal (1 subgoal):\n 1. set l = set hs", "using l"], ["proof (prove)\nusing this:\n  set hs = set hs \\<union> {tau}\n  l = tau # hs\n\ngoal (1 subgoal):\n 1. set l = set hs", "by auto"], ["proof (state)\nthis:\n  set l = set hs\n\ngoal (3 subgoals):\n 1. \\<not> cycle l \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 2. length l < n \\<and> cycle l \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 3. length l = n \\<and> cycle l \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "hence \"generate G (gs - {g}) = generate G A\""], ["proof (prove)\nusing this:\n  set l = set hs\n\ngoal (1 subgoal):\n 1. generate G (gs - {g}) = generate G A", "using gAhst ths ghs"], ["proof (prove)\nusing this:\n  set l = set hs\n  generate G A = generate G (set hs \\<union> {tau})\n  set hs = set hs \\<union> {tau}\n  generate G (gs - {g}) = generate G (set hs)\n\ngoal (1 subgoal):\n 1. generate G (gs - {g}) = generate G A", "by argo"], ["proof (state)\nthis:\n  generate G (gs - {g}) = generate G A\n\ngoal (3 subgoals):\n 1. \\<not> cycle l \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 2. length l < n \\<and> cycle l \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 3. length l = n \\<and> cycle l \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "moreover"], ["proof (state)\nthis:\n  generate G (gs - {g}) = generate G A\n\ngoal (3 subgoals):\n 1. \\<not> cycle l \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 2. length l < n \\<and> cycle l \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 3. length l = n \\<and> cycle l \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "have \"card (set hs) \\<le> card A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set hs) \\<le> card A", "by (metis Diff_iff card_mono cgs dual_order.trans fgs hs(5) subsetI)"], ["proof (state)\nthis:\n  card (set hs) \\<le> card A\n\ngoal (3 subgoals):\n 1. \\<not> cycle l \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 2. length l < n \\<and> cycle l \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 3. length l = n \\<and> cycle l \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "ultimately"], ["proof (chain)\npicking this:\n  generate G (gs - {g}) = generate G A\n  card (set hs) \\<le> card A", "show ?thesis"], ["proof (prove)\nusing this:\n  generate G (gs - {g}) = generate G A\n  card (set hs) \\<le> card A\n\ngoal (1 subgoal):\n 1. \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "using hs"], ["proof (prove)\nusing this:\n  generate G (gs - {g}) = generate G A\n  card (set hs) \\<le> card A\n  set hs \\<subseteq> generate G (gs - {g})\n  cycle hs\n  is_idirprod (generate G (gs - {g})) (\\<lambda>g. generate G {g}) (set hs)\n  successively (dvd) (map ord hs)\n  card (set hs) \\<le> card (gs - {g})\n\ngoal (1 subgoal):\n 1. \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "by auto"], ["proof (state)\nthis:\n  \\<exists>gs.\n     set gs \\<subseteq> generate G A \\<and>\n     cycle gs \\<and>\n     is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set gs) \\<and>\n     successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n\ngoal (2 subgoals):\n 1. length l < n \\<and> cycle l \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 2. length l = n \\<and> cycle l \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. length l < n \\<and> cycle l \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 2. length l = n \\<and> cycle l \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "case ltn"], ["proof (state)\nthis:\n  length l < n \\<and> cycle l\n\ngoal (2 subgoals):\n 1. length l < n \\<and> cycle l \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 2. length l = n \\<and> cycle l \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "then"], ["proof (chain)\npicking this:\n  length l < n \\<and> cycle l", "have cl: \"card (set l) < card A\""], ["proof (prove)\nusing this:\n  length l < n \\<and> cycle l\n\ngoal (1 subgoal):\n 1. card (set l) < card A", "using n"], ["proof (prove)\nusing this:\n  length l < n \\<and> cycle l\n  n = card A\n\ngoal (1 subgoal):\n 1. card (set l) < card A", "by (metis distinct_card)"], ["proof (state)\nthis:\n  card (set l) < card A\n\ngoal (2 subgoals):\n 1. length l < n \\<and> cycle l \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 2. length l = n \\<and> cycle l \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "from iH[OF this] hsc tc ls"], ["proof (chain)\npicking this:\n  \\<lbrakk>finite (set l); set l \\<subseteq> carrier G\\<rbrakk>\n  \\<Longrightarrow> \\<exists>gs.\n                       set gs \\<subseteq> generate G (set l) \\<and>\n                       cycle gs \\<and>\n                       is_idirprod (generate G (set l))\n                        (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                       successively (dvd) (map ord gs) \\<and>\n                       card (set gs) \\<le> card (set l)\n  set hs \\<subseteq> carrier G\n  tau \\<in> carrier G\n  set l = set hs \\<union> {tau}", "have \"?t (set l)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (set l); set l \\<subseteq> carrier G\\<rbrakk>\n  \\<Longrightarrow> \\<exists>gs.\n                       set gs \\<subseteq> generate G (set l) \\<and>\n                       cycle gs \\<and>\n                       is_idirprod (generate G (set l))\n                        (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                       successively (dvd) (map ord gs) \\<and>\n                       card (set gs) \\<le> card (set l)\n  set hs \\<subseteq> carrier G\n  tau \\<in> carrier G\n  set l = set hs \\<union> {tau}\n\ngoal (1 subgoal):\n 1. \\<exists>gs.\n       set gs \\<subseteq> generate G (set l) \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G (set l)) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and>\n       card (set gs) \\<le> card (set l)", "by blast"], ["proof (state)\nthis:\n  \\<exists>gs.\n     set gs \\<subseteq> generate G (set l) \\<and>\n     cycle gs \\<and>\n     is_idirprod (generate G (set l)) (\\<lambda>g. generate G {g})\n      (set gs) \\<and>\n     successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card (set l)\n\ngoal (2 subgoals):\n 1. length l < n \\<and> cycle l \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n 2. length l = n \\<and> cycle l \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>gs.\n     set gs \\<subseteq> generate G (set l) \\<and>\n     cycle gs \\<and>\n     is_idirprod (generate G (set l)) (\\<lambda>g. generate G {g})\n      (set gs) \\<and>\n     successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card (set l)\n\ngoal (1 subgoal):\n 1. \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "by (subst (1 2) gAhst, use cl ls in fastforce)"], ["proof (state)\nthis:\n  \\<exists>gs.\n     set gs \\<subseteq> generate G A \\<and>\n     cycle gs \\<and>\n     is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set gs) \\<and>\n     successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n\ngoal (1 subgoal):\n 1. length l = n \\<and> cycle l \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. length l = n \\<and> cycle l \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "case dn"], ["proof (state)\nthis:\n  length l = n \\<and> cycle l\n\ngoal (1 subgoal):\n 1. length l = n \\<and> cycle l \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "hence ln: \"length l = n\" and dl: \"distinct l\""], ["proof (prove)\nusing this:\n  length l = n \\<and> cycle l\n\ngoal (1 subgoal):\n 1. length l = n &&& cycle l", "by auto"], ["proof (state)\nthis:\n  length l = n\n  cycle l\n\ngoal (1 subgoal):\n 1. length l = n \\<and> cycle l \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "have c: \"complementary (generate G {tau}) (generate G (gs - {g}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complementary (generate G {tau}) (generate G (gs - {g}))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. complementary (generate G {tau}) (generate G (gs - {g}))", "have \"x = \\<one>\" if \"x \\<in> generate G {tau} \\<inter> generate G (set hs)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = \\<one>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x = \\<one>", "from that generate_incl[OF hsc]"], ["proof (chain)\npicking this:\n  x \\<in> generate G {tau} \\<inter> generate G (set hs)\n  generate G (set hs) \\<subseteq> carrier G", "have xc: \"x \\<in> carrier G\""], ["proof (prove)\nusing this:\n  x \\<in> generate G {tau} \\<inter> generate G (set hs)\n  generate G (set hs) \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. x \\<in> carrier G", "by blast"], ["proof (state)\nthis:\n  x \\<in> carrier G\n\ngoal (1 subgoal):\n 1. x = \\<one>", "from that"], ["proof (chain)\npicking this:\n  x \\<in> generate G {tau} \\<inter> generate G (set hs)", "have xgt: \"x \\<in> generate G {tau}\" and xgs: \"x \\<in> generate G (set hs)\""], ["proof (prove)\nusing this:\n  x \\<in> generate G {tau} \\<inter> generate G (set hs)\n\ngoal (1 subgoal):\n 1. x \\<in> generate G {tau} &&& x \\<in> generate G (set hs)", "by auto"], ["proof (state)\nthis:\n  x \\<in> generate G {tau}\n  x \\<in> generate G (set hs)\n\ngoal (1 subgoal):\n 1. x = \\<one>", "from generate_nat_pow[OF otnz tc] xgt"], ["proof (chain)\npicking this:\n  generate G {tau} = {tau [^] k |k. k \\<in> {0..ord tau - 1}}\n  x \\<in> generate G {tau}", "have \"\\<exists>a. a \\<ge> 0 \\<and> a < ord tau \\<and> x = tau [^] a\""], ["proof (prove)\nusing this:\n  generate G {tau} = {tau [^] k |k. k \\<in> {0..ord tau - 1}}\n  x \\<in> generate G {tau}\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<ge>0. a < ord tau \\<and> x = tau [^] a", "unfolding atLeastAtMost_def atLeast_def atMost_def"], ["proof (prove)\nusing this:\n  generate G {tau} =\n  {tau [^] k |k. k \\<in> {x. 0 \\<le> x} \\<inter> {x. x \\<le> ord tau - 1}}\n  x \\<in> generate G {tau}\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<ge>0. a < ord tau \\<and> x = tau [^] a", "by (auto, metis Suc_pred less_Suc_eq_le neq0_conv otnz)"], ["proof (state)\nthis:\n  \\<exists>a\\<ge>0. a < ord tau \\<and> x = tau [^] a\n\ngoal (1 subgoal):\n 1. x = \\<one>", "then"], ["proof (chain)\npicking this:\n  \\<exists>a\\<ge>0. a < ord tau \\<and> x = tau [^] a", "obtain a where a: \"0 \\<le> a\" \"a < ord tau\" \"x = tau [^] a\""], ["proof (prove)\nusing this:\n  \\<exists>a\\<ge>0. a < ord tau \\<and> x = tau [^] a\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>0 \\<le> a; a < ord tau; x = tau [^] a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  0 \\<le> a\n  a < ord tau\n  x = tau [^] a\n\ngoal (1 subgoal):\n 1. x = \\<one>", "then"], ["proof (chain)\npicking this:\n  0 \\<le> a\n  a < ord tau\n  x = tau [^] a", "have ix: \"inv x \\<in> generate G (set hs)\""], ["proof (prove)\nusing this:\n  0 \\<le> a\n  a < ord tau\n  x = tau [^] a\n\ngoal (1 subgoal):\n 1. inv x \\<in> generate G (set hs)", "using xgs generate_m_inv_closed ghs hsc"], ["proof (prove)\nusing this:\n  0 \\<le> a\n  a < ord tau\n  x = tau [^] a\n  x \\<in> generate G (set hs)\n  \\<lbrakk>?H \\<subseteq> carrier G; ?h \\<in> generate G ?H\\<rbrakk>\n  \\<Longrightarrow> inv ?h \\<in> generate G ?H\n  generate G (gs - {g}) = generate G (set hs)\n  set hs \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. inv x \\<in> generate G (set hs)", "by blast"], ["proof (state)\nthis:\n  inv x \\<in> generate G (set hs)\n\ngoal (1 subgoal):\n 1. x = \\<one>", "with generate_eq_finprod_Pi_int_image[OF _ hsc]"], ["proof (chain)\npicking this:\n  finite (set hs) \\<Longrightarrow>\n  generate G (set hs) =\n  (\\<lambda>x. \\<Otimes>g\\<in>set hs. g [^] x g) `\n  (set hs \\<rightarrow> UNIV)\n  inv x \\<in> generate G (set hs)", "obtain f where\n                  f: \"f \\<in> Pi (set hs) (\\<lambda>_. (UNIV::int set))\" \"inv x = finprod G (\\<lambda>g. g [^] f g) (set hs)\""], ["proof (prove)\nusing this:\n  finite (set hs) \\<Longrightarrow>\n  generate G (set hs) =\n  (\\<lambda>x. \\<Otimes>g\\<in>set hs. g [^] x g) `\n  (set hs \\<rightarrow> UNIV)\n  inv x \\<in> generate G (set hs)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> set hs \\<rightarrow> UNIV;\n         inv x = (\\<Otimes>g\\<in>set hs. g [^] f g)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  f \\<in> set hs \\<rightarrow> UNIV\n  inv x = (\\<Otimes>g\\<in>set hs. g [^] f g)\n\ngoal (1 subgoal):\n 1. x = \\<one>", "let ?f = \"restrict (f(tau := a)) (set l)\""], ["proof (state)\ngoal (1 subgoal):\n 1. x = \\<one>", "have fr: \"?f \\<in> relations (set l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict (f(tau := int a)) (set l) \\<in> relations (set l)", "proof(intro in_relationsI)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<Otimes>a\\<in>set l. a [^] restrict (f(tau := int a)) (set l) a) =\n    \\<one>\n 2. restrict (f(tau := int a)) (set l) \\<in> extensional (set l)", "from ls dl l"], ["proof (chain)\npicking this:\n  set l = set hs \\<union> {tau}\n  cycle l\n  l = tau # hs", "have sh: \"set hs = set l - {tau}\""], ["proof (prove)\nusing this:\n  set l = set hs \\<union> {tau}\n  cycle l\n  l = tau # hs\n\ngoal (1 subgoal):\n 1. set hs = set l - {tau}", "by auto"], ["proof (state)\nthis:\n  set hs = set l - {tau}\n\ngoal (2 subgoals):\n 1. (\\<Otimes>a\\<in>set l. a [^] restrict (f(tau := int a)) (set l) a) =\n    \\<one>\n 2. restrict (f(tau := int a)) (set l) \\<in> extensional (set l)", "have \"finprod G (\\<lambda>a. a [^] ?f a) (set l) = tau [^] ?f tau \\<otimes> finprod G (\\<lambda>a. a [^] ?f a) (set hs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Otimes>a\\<in>set l. a [^] restrict (f(tau := int a)) (set l) a) =\n    tau [^] restrict (f(tau := int a)) (set l) tau \\<otimes>\n    (\\<Otimes>a\\<in>set hs. a [^] restrict (f(tau := int a)) (set l) a)", "by (subst sh, intro finprod_minus, use l slc in auto)"], ["proof (state)\nthis:\n  (\\<Otimes>a\\<in>set l. a [^] restrict (f(tau := int a)) (set l) a) =\n  tau [^] restrict (f(tau := int a)) (set l) tau \\<otimes>\n  (\\<Otimes>a\\<in>set hs. a [^] restrict (f(tau := int a)) (set l) a)\n\ngoal (2 subgoals):\n 1. (\\<Otimes>a\\<in>set l. a [^] restrict (f(tau := int a)) (set l) a) =\n    \\<one>\n 2. restrict (f(tau := int a)) (set l) \\<in> extensional (set l)", "moreover"], ["proof (state)\nthis:\n  (\\<Otimes>a\\<in>set l. a [^] restrict (f(tau := int a)) (set l) a) =\n  tau [^] restrict (f(tau := int a)) (set l) tau \\<otimes>\n  (\\<Otimes>a\\<in>set hs. a [^] restrict (f(tau := int a)) (set l) a)\n\ngoal (2 subgoals):\n 1. (\\<Otimes>a\\<in>set l. a [^] restrict (f(tau := int a)) (set l) a) =\n    \\<one>\n 2. restrict (f(tau := int a)) (set l) \\<in> extensional (set l)", "have \"tau [^] ?f tau = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tau [^] restrict (f(tau := int a)) (set l) tau = x", "using a l int_pow_int"], ["proof (prove)\nusing this:\n  0 \\<le> a\n  a < ord tau\n  x = tau [^] a\n  l = tau # hs\n  ?x [^]\\<^bsub>?G\\<^esub> int ?n = ?x [^]\\<^bsub>?G\\<^esub> ?n\n\ngoal (1 subgoal):\n 1. tau [^] restrict (f(tau := int a)) (set l) tau = x", "by fastforce"], ["proof (state)\nthis:\n  tau [^] restrict (f(tau := int a)) (set l) tau = x\n\ngoal (2 subgoals):\n 1. (\\<Otimes>a\\<in>set l. a [^] restrict (f(tau := int a)) (set l) a) =\n    \\<one>\n 2. restrict (f(tau := int a)) (set l) \\<in> extensional (set l)", "moreover"], ["proof (state)\nthis:\n  tau [^] restrict (f(tau := int a)) (set l) tau = x\n\ngoal (2 subgoals):\n 1. (\\<Otimes>a\\<in>set l. a [^] restrict (f(tau := int a)) (set l) a) =\n    \\<one>\n 2. restrict (f(tau := int a)) (set l) \\<in> extensional (set l)", "have \"finprod G (\\<lambda>a. a [^] ?f a) (set hs) = finprod G (\\<lambda>g. g [^] f g) (set hs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Otimes>a\\<in>set hs. a [^] restrict (f(tau := int a)) (set l) a) =\n    (\\<Otimes>g\\<in>set hs. g [^] f g)", "by (intro finprod_cong', use slc dl l in auto)"], ["proof (state)\nthis:\n  (\\<Otimes>a\\<in>set hs. a [^] restrict (f(tau := int a)) (set l) a) =\n  (\\<Otimes>g\\<in>set hs. g [^] f g)\n\ngoal (2 subgoals):\n 1. (\\<Otimes>a\\<in>set l. a [^] restrict (f(tau := int a)) (set l) a) =\n    \\<one>\n 2. restrict (f(tau := int a)) (set l) \\<in> extensional (set l)", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Otimes>a\\<in>set l. a [^] restrict (f(tau := int a)) (set l) a) =\n  tau [^] restrict (f(tau := int a)) (set l) tau \\<otimes>\n  (\\<Otimes>a\\<in>set hs. a [^] restrict (f(tau := int a)) (set l) a)\n  tau [^] restrict (f(tau := int a)) (set l) tau = x\n  (\\<Otimes>a\\<in>set hs. a [^] restrict (f(tau := int a)) (set l) a) =\n  (\\<Otimes>g\\<in>set hs. g [^] f g)", "have \"finprod G (\\<lambda>a. a [^] ?f a) (set l) = x \\<otimes> inv x\""], ["proof (prove)\nusing this:\n  (\\<Otimes>a\\<in>set l. a [^] restrict (f(tau := int a)) (set l) a) =\n  tau [^] restrict (f(tau := int a)) (set l) tau \\<otimes>\n  (\\<Otimes>a\\<in>set hs. a [^] restrict (f(tau := int a)) (set l) a)\n  tau [^] restrict (f(tau := int a)) (set l) tau = x\n  (\\<Otimes>a\\<in>set hs. a [^] restrict (f(tau := int a)) (set l) a) =\n  (\\<Otimes>g\\<in>set hs. g [^] f g)\n\ngoal (1 subgoal):\n 1. (\\<Otimes>a\\<in>set l. a [^] restrict (f(tau := int a)) (set l) a) =\n    x \\<otimes> inv x", "using f"], ["proof (prove)\nusing this:\n  (\\<Otimes>a\\<in>set l. a [^] restrict (f(tau := int a)) (set l) a) =\n  tau [^] restrict (f(tau := int a)) (set l) tau \\<otimes>\n  (\\<Otimes>a\\<in>set hs. a [^] restrict (f(tau := int a)) (set l) a)\n  tau [^] restrict (f(tau := int a)) (set l) tau = x\n  (\\<Otimes>a\\<in>set hs. a [^] restrict (f(tau := int a)) (set l) a) =\n  (\\<Otimes>g\\<in>set hs. g [^] f g)\n  f \\<in> set hs \\<rightarrow> UNIV\n  inv x = (\\<Otimes>g\\<in>set hs. g [^] f g)\n\ngoal (1 subgoal):\n 1. (\\<Otimes>a\\<in>set l. a [^] restrict (f(tau := int a)) (set l) a) =\n    x \\<otimes> inv x", "by argo"], ["proof (state)\nthis:\n  (\\<Otimes>a\\<in>set l. a [^] restrict (f(tau := int a)) (set l) a) =\n  x \\<otimes> inv x\n\ngoal (2 subgoals):\n 1. (\\<Otimes>a\\<in>set l. a [^] restrict (f(tau := int a)) (set l) a) =\n    \\<one>\n 2. restrict (f(tau := int a)) (set l) \\<in> extensional (set l)", "thus \"finprod G (\\<lambda>a. a [^] ?f a) (set l) = \\<one>\""], ["proof (prove)\nusing this:\n  (\\<Otimes>a\\<in>set l. a [^] restrict (f(tau := int a)) (set l) a) =\n  x \\<otimes> inv x\n\ngoal (1 subgoal):\n 1. (\\<Otimes>a\\<in>set l. a [^] restrict (f(tau := int a)) (set l) a) =\n    \\<one>", "using xc"], ["proof (prove)\nusing this:\n  (\\<Otimes>a\\<in>set l. a [^] restrict (f(tau := int a)) (set l) a) =\n  x \\<otimes> inv x\n  x \\<in> carrier G\n\ngoal (1 subgoal):\n 1. (\\<Otimes>a\\<in>set l. a [^] restrict (f(tau := int a)) (set l) a) =\n    \\<one>", "by auto"], ["proof (state)\nthis:\n  (\\<Otimes>a\\<in>set l. a [^] restrict (f(tau := int a)) (set l) a) =\n  \\<one>\n\ngoal (1 subgoal):\n 1. restrict (f(tau := int a)) (set l) \\<in> extensional (set l)", "qed blast"], ["proof (state)\nthis:\n  restrict (f(tau := int a)) (set l) \\<in> relations (set l)\n\ngoal (1 subgoal):\n 1. x = \\<one>", "have \"\\<not>a > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> 0 < a", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < a \\<Longrightarrow> False", "assume ag: \"0 < a\""], ["proof (state)\nthis:\n  0 < a\n\ngoal (1 subgoal):\n 1. 0 < a \\<Longrightarrow> False", "have \"set l \\<in> all_gens\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set l \\<in> all_gens", "unfolding all_gens_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set l\n    \\<in> {gs \\<in> Pow (generate G A).\n           finite gs \\<and>\n           card gs \\<le> n \\<and> generate G gs = generate G A}", "using glgA lgA dn distinct_card"], ["proof (prove)\nusing this:\n  generate G (set l) = generate G A\n  set l \\<subseteq> generate G A\n  length l = n \\<and> cycle l\n  cycle ?xs \\<Longrightarrow> card (set ?xs) = length ?xs\n\ngoal (1 subgoal):\n 1. set l\n    \\<in> {gs \\<in> Pow (generate G A).\n           finite gs \\<and>\n           card gs \\<le> n \\<and> generate G gs = generate G A}", "by fastforce"], ["proof (state)\nthis:\n  set l \\<in> all_gens\n\ngoal (1 subgoal):\n 1. 0 < a \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  set l \\<in> all_gens\n\ngoal (1 subgoal):\n 1. 0 < a \\<Longrightarrow> False", "have \"int a = ?f tau\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int a = restrict (f(tau := int a)) (set l) tau", "using l"], ["proof (prove)\nusing this:\n  l = tau # hs\n\ngoal (1 subgoal):\n 1. int a = restrict (f(tau := int a)) (set l) tau", "by auto"], ["proof (state)\nthis:\n  int a = restrict (f(tau := int a)) (set l) tau\n\ngoal (1 subgoal):\n 1. 0 < a \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  int a = restrict (f(tau := int a)) (set l) tau\n\ngoal (1 subgoal):\n 1. 0 < a \\<Longrightarrow> False", "have \"tau \\<in> set l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tau \\<in> set l", "using l"], ["proof (prove)\nusing this:\n  l = tau # hs\n\ngoal (1 subgoal):\n 1. tau \\<in> set l", "by simp"], ["proof (state)\nthis:\n  tau \\<in> set l\n\ngoal (1 subgoal):\n 1. 0 < a \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  set l \\<in> all_gens\n  int a = restrict (f(tau := int a)) (set l) tau\n  tau \\<in> set l", "have \"a \\<in> exps\""], ["proof (prove)\nusing this:\n  set l \\<in> all_gens\n  int a = restrict (f(tau := int a)) (set l) tau\n  tau \\<in> set l\n\ngoal (1 subgoal):\n 1. a \\<in> exps", "using fr ag"], ["proof (prove)\nusing this:\n  set l \\<in> all_gens\n  int a = restrict (f(tau := int a)) (set l) tau\n  tau \\<in> set l\n  restrict (f(tau := int a)) (set l) \\<in> relations (set l)\n  0 < a\n\ngoal (1 subgoal):\n 1. a \\<in> exps", "unfolding exps_def"], ["proof (prove)\nusing this:\n  set l \\<in> all_gens\n  int a = restrict (f(tau := int a)) (set l) tau\n  tau \\<in> set l\n  restrict (f(tau := int a)) (set l) \\<in> relations (set l)\n  0 < a\n\ngoal (1 subgoal):\n 1. a \\<in> (\\<Union>gs'\\<in>all_gens.\n                \\<Union>rel\\<in>relations gs'.\n                   nat ` {e \\<in> rel ` gs'. 0 < e})", "by (auto, force)"], ["proof (state)\nthis:\n  a \\<in> exps\n\ngoal (1 subgoal):\n 1. 0 < a \\<Longrightarrow> False", "from le[OF this] a(2) ot gr(4)"], ["proof (chain)\npicking this:\n  min_exp \\<le> a\n  a < ord tau\n  int (ord tau) = rel g\n  rel g = int min_exp", "show False"], ["proof (prove)\nusing this:\n  min_exp \\<le> a\n  a < ord tau\n  int (ord tau) = rel g\n  rel g = int min_exp\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> 0 < a\n\ngoal (1 subgoal):\n 1. x = \\<one>", "hence \"a = 0\""], ["proof (prove)\nusing this:\n  \\<not> 0 < a\n\ngoal (1 subgoal):\n 1. a = 0", "using a"], ["proof (prove)\nusing this:\n  \\<not> 0 < a\n  0 \\<le> a\n  a < ord tau\n  x = tau [^] a\n\ngoal (1 subgoal):\n 1. a = 0", "by blast"], ["proof (state)\nthis:\n  a = 0\n\ngoal (1 subgoal):\n 1. x = \\<one>", "thus \"x = \\<one>\""], ["proof (prove)\nusing this:\n  a = 0\n\ngoal (1 subgoal):\n 1. x = \\<one>", "using tc a"], ["proof (prove)\nusing this:\n  a = 0\n  tau \\<in> carrier G\n  0 \\<le> a\n  a < ord tau\n  x = tau [^] a\n\ngoal (1 subgoal):\n 1. x = \\<one>", "by force"], ["proof (state)\nthis:\n  x = \\<one>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x2 \\<in> generate G {tau} \\<inter> generate G (set hs) \\<Longrightarrow>\n  ?x2 = \\<one>\n\ngoal (1 subgoal):\n 1. complementary (generate G {tau}) (generate G (gs - {g}))", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?x2 \\<in> generate G {tau} \\<inter> generate G (set hs) \\<Longrightarrow>\n  ?x2 = \\<one>\n\ngoal (1 subgoal):\n 1. complementary (generate G {tau}) (generate G (gs - {g}))", "unfolding complementary_def"], ["proof (prove)\nusing this:\n  ?x2 \\<in> generate G {tau} \\<inter> generate G (set hs) \\<Longrightarrow>\n  ?x2 = \\<one>\n\ngoal (1 subgoal):\n 1. generate G {tau} \\<inter> generate G (gs - {g}) = {\\<one>}", "using generate.one ghs"], ["proof (prove)\nusing this:\n  ?x2 \\<in> generate G {tau} \\<inter> generate G (set hs) \\<Longrightarrow>\n  ?x2 = \\<one>\n  \\<one>\\<^bsub>?G\\<^esub> \\<in> generate ?G ?H\n  generate G (gs - {g}) = generate G (set hs)\n\ngoal (1 subgoal):\n 1. generate G {tau} \\<inter> generate G (gs - {g}) = {\\<one>}", "by blast"], ["proof (state)\nthis:\n  complementary (generate G {tau}) (generate G (gs - {g}))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  complementary (generate G {tau}) (generate G (gs - {g}))\n\ngoal (1 subgoal):\n 1. length l = n \\<and> cycle l \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "moreover"], ["proof (state)\nthis:\n  complementary (generate G {tau}) (generate G (gs - {g}))\n\ngoal (1 subgoal):\n 1. length l = n \\<and> cycle l \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "have idl: \"is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set l)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set l)", "have \"is_idirprod (generate G (set hs \\<union> {tau})) (\\<lambda>g. generate G {g}) (set hs \\<union> {tau})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_idirprod (generate G (set hs \\<union> {tau}))\n     (\\<lambda>g. generate G {g}) (set hs \\<union> {tau})", "by (intro idirprod_generate_ind, use tc hsc hs(3) ghs c in auto)"], ["proof (state)\nthis:\n  is_idirprod (generate G (set hs \\<union> {tau}))\n   (\\<lambda>g. generate G {g}) (set hs \\<union> {tau})\n\ngoal (1 subgoal):\n 1. is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set l)", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_idirprod (generate G (set hs \\<union> {tau}))\n   (\\<lambda>g. generate G {g}) (set hs \\<union> {tau})\n\ngoal (1 subgoal):\n 1. is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set l)", "using ls gAhst"], ["proof (prove)\nusing this:\n  is_idirprod (generate G (set hs \\<union> {tau}))\n   (\\<lambda>g. generate G {g}) (set hs \\<union> {tau})\n  set l = set hs \\<union> {tau}\n  generate G A = generate G (set hs \\<union> {tau})\n\ngoal (1 subgoal):\n 1. is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set l)", "by auto"], ["proof (state)\nthis:\n  is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set l)\n\ngoal (1 subgoal):\n 1. length l = n \\<and> cycle l \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "moreover"], ["proof (state)\nthis:\n  is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set l)\n\ngoal (1 subgoal):\n 1. length l = n \\<and> cycle l \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "have \"\\<not>?t A \\<Longrightarrow> successively (dvd) (map ord l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and>\n       card (set gs) \\<le> card A \\<Longrightarrow>\n    successively (dvd) (map ord l)", "proof (cases hs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<nexists>gs.\n                set gs \\<subseteq> generate G A \\<and>\n                cycle gs \\<and>\n                is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n                 (set gs) \\<and>\n                successively (dvd) (map ord gs) \\<and>\n                card (set gs) \\<le> card A;\n     hs = []\\<rbrakk>\n    \\<Longrightarrow> successively (dvd) (map ord l)\n 2. \\<And>a list.\n       \\<lbrakk>\\<nexists>gs.\n                   set gs \\<subseteq> generate G A \\<and>\n                   cycle gs \\<and>\n                   is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n                    (set gs) \\<and>\n                   successively (dvd) (map ord gs) \\<and>\n                   card (set gs) \\<le> card A;\n        hs = a # list\\<rbrakk>\n       \\<Longrightarrow> successively (dvd) (map ord l)", "case Nil"], ["proof (state)\nthis:\n  hs = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<nexists>gs.\n                set gs \\<subseteq> generate G A \\<and>\n                cycle gs \\<and>\n                is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n                 (set gs) \\<and>\n                successively (dvd) (map ord gs) \\<and>\n                card (set gs) \\<le> card A;\n     hs = []\\<rbrakk>\n    \\<Longrightarrow> successively (dvd) (map ord l)\n 2. \\<And>a list.\n       \\<lbrakk>\\<nexists>gs.\n                   set gs \\<subseteq> generate G A \\<and>\n                   cycle gs \\<and>\n                   is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n                    (set gs) \\<and>\n                   successively (dvd) (map ord gs) \\<and>\n                   card (set gs) \\<le> card A;\n        hs = a # list\\<rbrakk>\n       \\<Longrightarrow> successively (dvd) (map ord l)", "thus ?thesis"], ["proof (prove)\nusing this:\n  hs = []\n\ngoal (1 subgoal):\n 1. successively (dvd) (map ord l)", "using l"], ["proof (prove)\nusing this:\n  hs = []\n  l = tau # hs\n\ngoal (1 subgoal):\n 1. successively (dvd) (map ord l)", "by simp"], ["proof (state)\nthis:\n  successively (dvd) (map ord l)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<nexists>gs.\n                   set gs \\<subseteq> generate G A \\<and>\n                   cycle gs \\<and>\n                   is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n                    (set gs) \\<and>\n                   successively (dvd) (map ord gs) \\<and>\n                   card (set gs) \\<le> card A;\n        hs = a # list\\<rbrakk>\n       \\<Longrightarrow> successively (dvd) (map ord l)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<nexists>gs.\n                   set gs \\<subseteq> generate G A \\<and>\n                   cycle gs \\<and>\n                   is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n                    (set gs) \\<and>\n                   successively (dvd) (map ord gs) \\<and>\n                   card (set gs) \\<le> card A;\n        hs = a # list\\<rbrakk>\n       \\<Longrightarrow> successively (dvd) (map ord l)", "case (Cons a list)"], ["proof (state)\nthis:\n  hs = a # list\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<nexists>gs.\n                   set gs \\<subseteq> generate G A \\<and>\n                   cycle gs \\<and>\n                   is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n                    (set gs) \\<and>\n                   successively (dvd) (map ord gs) \\<and>\n                   card (set gs) \\<le> card A;\n        hs = a # list\\<rbrakk>\n       \\<Longrightarrow> successively (dvd) (map ord l)", "hence ac: \"a \\<in> carrier G\""], ["proof (prove)\nusing this:\n  hs = a # list\n\ngoal (1 subgoal):\n 1. a \\<in> carrier G", "using hsc"], ["proof (prove)\nusing this:\n  hs = a # list\n  set hs \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. a \\<in> carrier G", "by auto"], ["proof (state)\nthis:\n  a \\<in> carrier G\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<nexists>gs.\n                   set gs \\<subseteq> generate G A \\<and>\n                   cycle gs \\<and>\n                   is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n                    (set gs) \\<and>\n                   successively (dvd) (map ord gs) \\<and>\n                   card (set gs) \\<le> card A;\n        hs = a # list\\<rbrakk>\n       \\<Longrightarrow> successively (dvd) (map ord l)", "assume nA: \"\\<not>?t A\""], ["proof (state)\nthis:\n  \\<nexists>gs.\n     set gs \\<subseteq> generate G A \\<and>\n     cycle gs \\<and>\n     is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set gs) \\<and>\n     successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<nexists>gs.\n                   set gs \\<subseteq> generate G A \\<and>\n                   cycle gs \\<and>\n                   is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n                    (set gs) \\<and>\n                   successively (dvd) (map ord gs) \\<and>\n                   card (set gs) \\<le> card A;\n        hs = a # list\\<rbrakk>\n       \\<Longrightarrow> successively (dvd) (map ord l)", "have \"ord tau dvd ord a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord tau dvd ord a", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ord tau dvd ord a \\<Longrightarrow> False", "assume nd: \"\\<not> ord tau dvd ord a\""], ["proof (state)\nthis:\n  \\<not> ord tau dvd ord a\n\ngoal (1 subgoal):\n 1. \\<not> ord tau dvd ord a \\<Longrightarrow> False", "have \"int (ord tau) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < int (ord tau)", "using otnz"], ["proof (prove)\nusing this:\n  ord tau \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < int (ord tau)", "by simp"], ["proof (state)\nthis:\n  0 < int (ord tau)\n\ngoal (1 subgoal):\n 1. \\<not> ord tau dvd ord a \\<Longrightarrow> False", "with nd"], ["proof (chain)\npicking this:\n  \\<not> ord tau dvd ord a\n  0 < int (ord tau)", "obtain r q::int where rq: \"ord a = q * (ord tau) + r\" \"0 < r\" \"r < ord tau\""], ["proof (prove)\nusing this:\n  \\<not> ord tau dvd ord a\n  0 < int (ord tau)\n\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        \\<lbrakk>int (ord a) = q * int (ord tau) + r; 0 < r;\n         r < int (ord tau)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Euclidean_Division.pos_mod_bound div_mult_mod_eq mod_int_pos_iff mod_0_imp_dvd"], ["proof (prove)\nusing this:\n  \\<not> ord tau dvd ord a\n  0 < int (ord tau)\n  0 < ?l \\<Longrightarrow> ?k mod ?l < ?l\n  ?a div ?b * ?b + ?a mod ?b = ?a\n  (0 \\<le> ?k mod ?l) =\n  (?l dvd ?k \\<or> ?l = 0 \\<and> 0 \\<le> ?k \\<or> 0 < ?l)\n  ?a mod ?b = (0::?'a) \\<Longrightarrow> ?b dvd ?a\n\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        \\<lbrakk>int (ord a) = q * int (ord tau) + r; 0 < r;\n         r < int (ord tau)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis linorder_not_le of_nat_le_0_iff of_nat_mod)"], ["proof (state)\nthis:\n  int (ord a) = q * int (ord tau) + r\n  0 < r\n  r < int (ord tau)\n\ngoal (1 subgoal):\n 1. \\<not> ord tau dvd ord a \\<Longrightarrow> False", "define b where b: \"b = tau \\<otimes> a [^] q\""], ["proof (state)\nthis:\n  b = tau \\<otimes> a [^] q\n\ngoal (1 subgoal):\n 1. \\<not> ord tau dvd ord a \\<Longrightarrow> False", "hence bc: \"b \\<in> carrier G\""], ["proof (prove)\nusing this:\n  b = tau \\<otimes> a [^] q\n\ngoal (1 subgoal):\n 1. b \\<in> carrier G", "using hsc tc Cons"], ["proof (prove)\nusing this:\n  b = tau \\<otimes> a [^] q\n  set hs \\<subseteq> carrier G\n  tau \\<in> carrier G\n  hs = a # list\n\ngoal (1 subgoal):\n 1. b \\<in> carrier G", "by auto"], ["proof (state)\nthis:\n  b \\<in> carrier G\n\ngoal (1 subgoal):\n 1. \\<not> ord tau dvd ord a \\<Longrightarrow> False", "have g: \"generate G (set (b#hs)) = generate G (set l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generate G (set (b # hs)) = generate G (set l)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. generate G (set (b # hs)) = generate G (set l)", "have se: \"set (b#hs) = set l - {tau} \\<union> {b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (b # hs) = set l - {tau} \\<union> {b}", "using l Cons dl"], ["proof (prove)\nusing this:\n  l = tau # hs\n  hs = a # list\n  cycle l\n\ngoal (1 subgoal):\n 1. set (b # hs) = set l - {tau} \\<union> {b}", "by auto"], ["proof (state)\nthis:\n  set (b # hs) = set l - {tau} \\<union> {b}\n\ngoal (1 subgoal):\n 1. generate G (set (b # hs)) = generate G (set l)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. generate G (set (b # hs)) = generate G (set l)", "proof(subst se, intro generate_one_switched_eqI[symmetric, of _ tau _ b])"], ["proof (state)\ngoal (5 subgoals):\n 1. set l \\<subseteq> carrier G\n 2. tau \\<in> set l\n 3. set l - {tau} \\<union> {b} = set l - {tau} \\<union> {b}\n 4. b \\<in> generate G (set l)\n 5. tau \\<in> generate G (set l - {tau} \\<union> {b})", "show \"b \\<in> generate G (set l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> generate G (set l)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<in> generate G (set l)", "have \"tau \\<in> generate G (set l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tau \\<in> generate G (set l)", "using l generate.incl[of tau \"set l\"]"], ["proof (prove)\nusing this:\n  l = tau # hs\n  tau \\<in> set l \\<Longrightarrow> tau \\<in> generate ?G (set l)\n\ngoal (1 subgoal):\n 1. tau \\<in> generate G (set l)", "by auto"], ["proof (state)\nthis:\n  tau \\<in> generate G (set l)\n\ngoal (1 subgoal):\n 1. b \\<in> generate G (set l)", "moreover"], ["proof (state)\nthis:\n  tau \\<in> generate G (set l)\n\ngoal (1 subgoal):\n 1. b \\<in> generate G (set l)", "have \"a [^] q \\<in> generate G (set l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a [^] q \\<in> generate G (set l)", "using mono_generate[of \"{a}\" \"set l\"] generate_pow[OF ac] Cons l"], ["proof (prove)\nusing this:\n  {a} \\<subseteq> set l \\<Longrightarrow>\n  generate G {a} \\<subseteq> generate G (set l)\n  generate G {a} = {a [^] k |k. k \\<in> UNIV}\n  hs = a # list\n  l = tau # hs\n\ngoal (1 subgoal):\n 1. a [^] q \\<in> generate G (set l)", "by auto"], ["proof (state)\nthis:\n  a [^] q \\<in> generate G (set l)\n\ngoal (1 subgoal):\n 1. b \\<in> generate G (set l)", "ultimately"], ["proof (chain)\npicking this:\n  tau \\<in> generate G (set l)\n  a [^] q \\<in> generate G (set l)", "show ?thesis"], ["proof (prove)\nusing this:\n  tau \\<in> generate G (set l)\n  a [^] q \\<in> generate G (set l)\n\ngoal (1 subgoal):\n 1. b \\<in> generate G (set l)", "using b generate.eng"], ["proof (prove)\nusing this:\n  tau \\<in> generate G (set l)\n  a [^] q \\<in> generate G (set l)\n  b = tau \\<otimes> a [^] q\n  \\<lbrakk>?h1.0 \\<in> generate ?G ?H; ?h2.0 \\<in> generate ?G ?H\\<rbrakk>\n  \\<Longrightarrow> ?h1.0 \\<otimes>\\<^bsub>?G\\<^esub> ?h2.0\n                    \\<in> generate ?G ?H\n\ngoal (1 subgoal):\n 1. b \\<in> generate G (set l)", "by fast"], ["proof (state)\nthis:\n  b \\<in> generate G (set l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b \\<in> generate G (set l)\n\ngoal (4 subgoals):\n 1. set l \\<subseteq> carrier G\n 2. tau \\<in> set l\n 3. set l - {tau} \\<union> {b} = set l - {tau} \\<union> {b}\n 4. tau \\<in> generate G (set l - {tau} \\<union> {b})", "show \"tau \\<in> generate G (set l - {tau} \\<union> {b})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tau \\<in> generate G (set l - {tau} \\<union> {b})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. tau \\<in> generate G (set l - {tau} \\<union> {b})", "have \"tau = b \\<otimes> inv(a [^] q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tau = b \\<otimes> inv (a [^] q)", "by (simp add: ac b m_assoc tc)"], ["proof (state)\nthis:\n  tau = b \\<otimes> inv (a [^] q)\n\ngoal (1 subgoal):\n 1. tau \\<in> generate G (set l - {tau} \\<union> {b})", "moreover"], ["proof (state)\nthis:\n  tau = b \\<otimes> inv (a [^] q)\n\ngoal (1 subgoal):\n 1. tau \\<in> generate G (set l - {tau} \\<union> {b})", "have \"b \\<in> generate G (set l - {tau} \\<union> {b})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> generate G (set l - {tau} \\<union> {b})", "using generate.incl[of b \"set l - {tau} \\<union> {b}\"]"], ["proof (prove)\nusing this:\n  b \\<in> set l - {tau} \\<union> {b} \\<Longrightarrow>\n  b \\<in> generate ?G (set l - {tau} \\<union> {b})\n\ngoal (1 subgoal):\n 1. b \\<in> generate G (set l - {tau} \\<union> {b})", "by blast"], ["proof (state)\nthis:\n  b \\<in> generate G (set l - {tau} \\<union> {b})\n\ngoal (1 subgoal):\n 1. tau \\<in> generate G (set l - {tau} \\<union> {b})", "moreover"], ["proof (state)\nthis:\n  b \\<in> generate G (set l - {tau} \\<union> {b})\n\ngoal (1 subgoal):\n 1. tau \\<in> generate G (set l - {tau} \\<union> {b})", "have \"inv(a [^] q) \\<in> generate G (set l - {tau} \\<union> {b})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv (a [^] q) \\<in> generate G (set l - {tau} \\<union> {b})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inv (a [^] q) \\<in> generate G (set l - {tau} \\<union> {b})", "have \"generate G {a} \\<subseteq> generate G (set l - {tau} \\<union> {b})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generate G {a} \\<subseteq> generate G (set l - {tau} \\<union> {b})", "using mono_generate[of \"{a}\" \"set l - {tau} \\<union> {b}\"] dl Cons l"], ["proof (prove)\nusing this:\n  {a} \\<subseteq> set l - {tau} \\<union> {b} \\<Longrightarrow>\n  generate G {a} \\<subseteq> generate G (set l - {tau} \\<union> {b})\n  cycle l\n  hs = a # list\n  l = tau # hs\n\ngoal (1 subgoal):\n 1. generate G {a} \\<subseteq> generate G (set l - {tau} \\<union> {b})", "by auto"], ["proof (state)\nthis:\n  generate G {a} \\<subseteq> generate G (set l - {tau} \\<union> {b})\n\ngoal (1 subgoal):\n 1. inv (a [^] q) \\<in> generate G (set l - {tau} \\<union> {b})", "moreover"], ["proof (state)\nthis:\n  generate G {a} \\<subseteq> generate G (set l - {tau} \\<union> {b})\n\ngoal (1 subgoal):\n 1. inv (a [^] q) \\<in> generate G (set l - {tau} \\<union> {b})", "have \"inv(a [^] q) \\<in> generate G {a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv (a [^] q) \\<in> generate G {a}", "by (subst generate_pow[OF ac], subst int_pow_neg[OF ac, of q, symmetric], blast)"], ["proof (state)\nthis:\n  inv (a [^] q) \\<in> generate G {a}\n\ngoal (1 subgoal):\n 1. inv (a [^] q) \\<in> generate G (set l - {tau} \\<union> {b})", "ultimately"], ["proof (chain)\npicking this:\n  generate G {a} \\<subseteq> generate G (set l - {tau} \\<union> {b})\n  inv (a [^] q) \\<in> generate G {a}", "show ?thesis"], ["proof (prove)\nusing this:\n  generate G {a} \\<subseteq> generate G (set l - {tau} \\<union> {b})\n  inv (a [^] q) \\<in> generate G {a}\n\ngoal (1 subgoal):\n 1. inv (a [^] q) \\<in> generate G (set l - {tau} \\<union> {b})", "by fast"], ["proof (state)\nthis:\n  inv (a [^] q) \\<in> generate G (set l - {tau} \\<union> {b})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inv (a [^] q) \\<in> generate G (set l - {tau} \\<union> {b})\n\ngoal (1 subgoal):\n 1. tau \\<in> generate G (set l - {tau} \\<union> {b})", "ultimately"], ["proof (chain)\npicking this:\n  tau = b \\<otimes> inv (a [^] q)\n  b \\<in> generate G (set l - {tau} \\<union> {b})\n  inv (a [^] q) \\<in> generate G (set l - {tau} \\<union> {b})", "show ?thesis"], ["proof (prove)\nusing this:\n  tau = b \\<otimes> inv (a [^] q)\n  b \\<in> generate G (set l - {tau} \\<union> {b})\n  inv (a [^] q) \\<in> generate G (set l - {tau} \\<union> {b})\n\ngoal (1 subgoal):\n 1. tau \\<in> generate G (set l - {tau} \\<union> {b})", "using generate.eng"], ["proof (prove)\nusing this:\n  tau = b \\<otimes> inv (a [^] q)\n  b \\<in> generate G (set l - {tau} \\<union> {b})\n  inv (a [^] q) \\<in> generate G (set l - {tau} \\<union> {b})\n  \\<lbrakk>?h1.0 \\<in> generate ?G ?H; ?h2.0 \\<in> generate ?G ?H\\<rbrakk>\n  \\<Longrightarrow> ?h1.0 \\<otimes>\\<^bsub>?G\\<^esub> ?h2.0\n                    \\<in> generate ?G ?H\n\ngoal (1 subgoal):\n 1. tau \\<in> generate G (set l - {tau} \\<union> {b})", "by fast"], ["proof (state)\nthis:\n  tau \\<in> generate G (set l - {tau} \\<union> {b})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  tau \\<in> generate G (set l - {tau} \\<union> {b})\n\ngoal (3 subgoals):\n 1. set l \\<subseteq> carrier G\n 2. tau \\<in> set l\n 3. set l - {tau} \\<union> {b} = set l - {tau} \\<union> {b}", "qed (use bc tc hsc dl Cons l in auto)"], ["proof (state)\nthis:\n  generate G (set (b # hs)) = generate G (set l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  generate G (set (b # hs)) = generate G (set l)\n\ngoal (1 subgoal):\n 1. \\<not> ord tau dvd ord a \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases \"card (set (b#hs)) \\<noteq> n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. card (set (b # hs)) \\<noteq> n \\<Longrightarrow> False\n 2. \\<not> card (set (b # hs)) \\<noteq> n \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  card (set (b # hs)) \\<noteq> n\n\ngoal (2 subgoals):\n 1. card (set (b # hs)) \\<noteq> n \\<Longrightarrow> False\n 2. \\<not> card (set (b # hs)) \\<noteq> n \\<Longrightarrow> False", "hence cln: \"card (set (b#hs)) < n\""], ["proof (prove)\nusing this:\n  card (set (b # hs)) \\<noteq> n\n\ngoal (1 subgoal):\n 1. card (set (b # hs)) < n", "using l Cons ln"], ["proof (prove)\nusing this:\n  card (set (b # hs)) \\<noteq> n\n  l = tau # hs\n  hs = a # list\n  length l = n\n\ngoal (1 subgoal):\n 1. card (set (b # hs)) < n", "by (metis card_length list.size(4) nat_less_le)"], ["proof (state)\nthis:\n  card (set (b # hs)) < n\n\ngoal (2 subgoals):\n 1. card (set (b # hs)) \\<noteq> n \\<Longrightarrow> False\n 2. \\<not> card (set (b # hs)) \\<noteq> n \\<Longrightarrow> False", "hence seq: \"set (b#hs) = set hs\""], ["proof (prove)\nusing this:\n  card (set (b # hs)) < n\n\ngoal (1 subgoal):\n 1. set (b # hs) = set hs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (set (b # hs)) < n \\<Longrightarrow> set (b # hs) = set hs", "from dn l Cons True"], ["proof (chain)\npicking this:\n  length l = n \\<and> cycle l\n  l = tau # hs\n  hs = a # list\n  card (set (b # hs)) \\<noteq> n", "have \"b \\<in> set hs\""], ["proof (prove)\nusing this:\n  length l = n \\<and> cycle l\n  l = tau # hs\n  hs = a # list\n  card (set (b # hs)) \\<noteq> n\n\ngoal (1 subgoal):\n 1. b \\<in> set hs", "by (metis distinct.simps(2) distinct_card list.size(4))"], ["proof (state)\nthis:\n  b \\<in> set hs\n\ngoal (1 subgoal):\n 1. card (set (b # hs)) < n \\<Longrightarrow> set (b # hs) = set hs", "thus ?thesis"], ["proof (prove)\nusing this:\n  b \\<in> set hs\n\ngoal (1 subgoal):\n 1. set (b # hs) = set hs", "by auto"], ["proof (state)\nthis:\n  set (b # hs) = set hs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (b # hs) = set hs\n\ngoal (2 subgoals):\n 1. card (set (b # hs)) \\<noteq> n \\<Longrightarrow> False\n 2. \\<not> card (set (b # hs)) \\<noteq> n \\<Longrightarrow> False", "with cln"], ["proof (chain)\npicking this:\n  card (set (b # hs)) < n\n  set (b # hs) = set hs", "have clA: \"card (set hs) < card A\""], ["proof (prove)\nusing this:\n  card (set (b # hs)) < n\n  set (b # hs) = set hs\n\ngoal (1 subgoal):\n 1. card (set hs) < card A", "using n"], ["proof (prove)\nusing this:\n  card (set (b # hs)) < n\n  set (b # hs) = set hs\n  n = card A\n\ngoal (1 subgoal):\n 1. card (set hs) < card A", "by auto"], ["proof (state)\nthis:\n  card (set hs) < card A\n\ngoal (2 subgoals):\n 1. card (set (b # hs)) \\<noteq> n \\<Longrightarrow> False\n 2. \\<not> card (set (b # hs)) \\<noteq> n \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  card (set hs) < card A\n\ngoal (2 subgoals):\n 1. card (set (b # hs)) \\<noteq> n \\<Longrightarrow> False\n 2. \\<not> card (set (b # hs)) \\<noteq> n \\<Longrightarrow> False", "have \"set hs \\<subseteq> generate G (set hs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set hs \\<subseteq> generate G (set hs)", "using generate_sincl"], ["proof (prove)\nusing this:\n  ?A \\<subseteq> generate G ?A\n\ngoal (1 subgoal):\n 1. set hs \\<subseteq> generate G (set hs)", "by simp"], ["proof (state)\nthis:\n  set hs \\<subseteq> generate G (set hs)\n\ngoal (2 subgoals):\n 1. card (set (b # hs)) \\<noteq> n \\<Longrightarrow> False\n 2. \\<not> card (set (b # hs)) \\<noteq> n \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  set hs \\<subseteq> generate G (set hs)\n\ngoal (2 subgoals):\n 1. card (set (b # hs)) \\<noteq> n \\<Longrightarrow> False\n 2. \\<not> card (set (b # hs)) \\<noteq> n \\<Longrightarrow> False", "have \"distinct hs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cycle hs", "by fact"], ["proof (state)\nthis:\n  cycle hs\n\ngoal (2 subgoals):\n 1. card (set (b # hs)) \\<noteq> n \\<Longrightarrow> False\n 2. \\<not> card (set (b # hs)) \\<noteq> n \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  cycle hs\n\ngoal (2 subgoals):\n 1. card (set (b # hs)) \\<noteq> n \\<Longrightarrow> False\n 2. \\<not> card (set (b # hs)) \\<noteq> n \\<Longrightarrow> False", "have \"is_idirprod (generate G (set hs)) (\\<lambda>g. generate G {g}) (set hs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_idirprod (generate G (set hs)) (\\<lambda>g. generate G {g}) (set hs)", "by (intro is_idirprod_generate, use hs[unfolded is_idirprod_def] hsc in auto)"], ["proof (state)\nthis:\n  is_idirprod (generate G (set hs)) (\\<lambda>g. generate G {g}) (set hs)\n\ngoal (2 subgoals):\n 1. card (set (b # hs)) \\<noteq> n \\<Longrightarrow> False\n 2. \\<not> card (set (b # hs)) \\<noteq> n \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  is_idirprod (generate G (set hs)) (\\<lambda>g. generate G {g}) (set hs)\n\ngoal (2 subgoals):\n 1. card (set (b # hs)) \\<noteq> n \\<Longrightarrow> False\n 2. \\<not> card (set (b # hs)) \\<noteq> n \\<Longrightarrow> False", "have \"generate G A = generate G (set hs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generate G A = generate G (set hs)", "using glgA g seq"], ["proof (prove)\nusing this:\n  generate G (set l) = generate G A\n  generate G (set (b # hs)) = generate G (set l)\n  set (b # hs) = set hs\n\ngoal (1 subgoal):\n 1. generate G A = generate G (set hs)", "by argo"], ["proof (state)\nthis:\n  generate G A = generate G (set hs)\n\ngoal (2 subgoals):\n 1. card (set (b # hs)) \\<noteq> n \\<Longrightarrow> False\n 2. \\<not> card (set (b # hs)) \\<noteq> n \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  generate G A = generate G (set hs)\n\ngoal (2 subgoals):\n 1. card (set (b # hs)) \\<noteq> n \\<Longrightarrow> False\n 2. \\<not> card (set (b # hs)) \\<noteq> n \\<Longrightarrow> False", "have \"successively (dvd) (map ord hs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. successively (dvd) (map ord hs)", "by fact"], ["proof (state)\nthis:\n  successively (dvd) (map ord hs)\n\ngoal (2 subgoals):\n 1. card (set (b # hs)) \\<noteq> n \\<Longrightarrow> False\n 2. \\<not> card (set (b # hs)) \\<noteq> n \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  card (set hs) < card A\n  set hs \\<subseteq> generate G (set hs)\n  cycle hs\n  is_idirprod (generate G (set hs)) (\\<lambda>g. generate G {g}) (set hs)\n  generate G A = generate G (set hs)\n  successively (dvd) (map ord hs)", "show False"], ["proof (prove)\nusing this:\n  card (set hs) < card A\n  set hs \\<subseteq> generate G (set hs)\n  cycle hs\n  is_idirprod (generate G (set hs)) (\\<lambda>g. generate G {g}) (set hs)\n  generate G A = generate G (set hs)\n  successively (dvd) (map ord hs)\n\ngoal (1 subgoal):\n 1. False", "using iH2 nA"], ["proof (prove)\nusing this:\n  card (set hs) < card A\n  set hs \\<subseteq> generate G (set hs)\n  cycle hs\n  is_idirprod (generate G (set hs)) (\\<lambda>g. generate G {g}) (set hs)\n  generate G A = generate G (set hs)\n  successively (dvd) (map ord hs)\n  \\<lbrakk>\\<exists>gs.\n              set gs \\<subseteq> generate G ?B2 \\<and>\n              cycle gs \\<and>\n              is_idirprod (generate G ?B2) (\\<lambda>g. generate G {g})\n               (set gs) \\<and>\n              successively (dvd) (map ord gs) \\<and>\n              card (set gs) \\<le> card ?B2;\n   generate G A = generate G ?B2; card ?B2 < card A\\<rbrakk>\n  \\<Longrightarrow> \\<exists>gs.\n                       set gs \\<subseteq> generate G A \\<and>\n                       cycle gs \\<and>\n                       is_idirprod (generate G A)\n                        (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                       successively (dvd) (map ord gs) \\<and>\n                       card (set gs) \\<le> card A\n  \\<nexists>gs.\n     set gs \\<subseteq> generate G A \\<and>\n     cycle gs \\<and>\n     is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set gs) \\<and>\n     successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> card (set (b # hs)) \\<noteq> n \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> card (set (b # hs)) \\<noteq> n \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  \\<not> card (set (b # hs)) \\<noteq> n\n\ngoal (1 subgoal):\n 1. \\<not> card (set (b # hs)) \\<noteq> n \\<Longrightarrow> False", "hence anb: \"a \\<noteq> b\""], ["proof (prove)\nusing this:\n  \\<not> card (set (b # hs)) \\<noteq> n\n\ngoal (1 subgoal):\n 1. a \\<noteq> b", "by (metis card_distinct distinct_length_2_or_more l list.size(4) ln local.Cons)"], ["proof (state)\nthis:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. \\<not> card (set (b # hs)) \\<noteq> n \\<Longrightarrow> False", "have \"nat r \\<in> exps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat r \\<in> exps", "unfolding exps_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat r\n    \\<in> (\\<Union>gs'\\<in>all_gens.\n              \\<Union>rel\\<in>relations gs'.\n                 nat ` {e \\<in> rel ` gs'. 0 < e})", "proof(rule)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?a \\<in> all_gens\n 2. nat r\n    \\<in> (\\<Union>rel\\<in>relations ?a. nat ` {e \\<in> rel ` ?a. 0 < e})", "show \"set (b#hs) \\<in> all_gens\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (b # hs) \\<in> all_gens", "unfolding all_gens_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (b # hs)\n    \\<in> {gs \\<in> Pow (generate G A).\n           finite gs \\<and>\n           card gs \\<le> n \\<and> generate G gs = generate G A}", "using gAhst g ls generate_sincl[of \"set (b#hs)\"] False"], ["proof (prove)\nusing this:\n  generate G A = generate G (set hs \\<union> {tau})\n  generate G (set (b # hs)) = generate G (set l)\n  set l = set hs \\<union> {tau}\n  set (b # hs) \\<subseteq> generate G (set (b # hs))\n  \\<not> card (set (b # hs)) \\<noteq> n\n\ngoal (1 subgoal):\n 1. set (b # hs)\n    \\<in> {gs \\<in> Pow (generate G A).\n           finite gs \\<and>\n           card gs \\<le> n \\<and> generate G gs = generate G A}", "by simp"], ["proof (state)\nthis:\n  set (b # hs) \\<in> all_gens\n\ngoal (1 subgoal):\n 1. nat r\n    \\<in> (\\<Union>rel\\<in>relations (set (b # hs)).\n              nat ` {e \\<in> rel ` set (b # hs). 0 < e})", "let ?r = \"restrict ((\\<lambda>_. 0::int)(b := ord tau, a := r)) (set (b#hs))\""], ["proof (state)\ngoal (1 subgoal):\n 1. nat r\n    \\<in> (\\<Union>rel\\<in>relations (set (b # hs)).\n              nat ` {e \\<in> rel ` set (b # hs). 0 < e})", "have \"?r \\<in> relations (set (b#hs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs))\n    \\<in> relations (set (b # hs))", "proof(intro in_relationsI)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<Otimes>a\\<in>set (b #\n                         hs). a [^]\n                              restrict\n                               ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                               (set (b # hs)) a) =\n    \\<one>\n 2. restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs))\n    \\<in> extensional (set (b # hs))", "show \"finprod G (\\<lambda>x. x [^] ?r x) (set (b#hs)) = \\<one>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Otimes>x\\<in>set (b #\n                         hs). x [^]\n                              restrict\n                               ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                               (set (b # hs)) x) =\n    \\<one>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Otimes>x\\<in>set (b #\n                         hs). x [^]\n                              restrict\n                               ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                               (set (b # hs)) x) =\n    \\<one>", "have \"finprod G (\\<lambda>x. x [^] ?r x) (set (b#hs)) = b [^] ?r b \\<otimes> finprod G (\\<lambda>x. x[^] ?r x) (set (b#hs) - {b})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Otimes>x\\<in>set (b #\n                         hs). x [^]\n                              restrict\n                               ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                               (set (b # hs)) x) =\n    b [^]\n    restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs))\n     b \\<otimes>\n    (\\<Otimes>x\\<in>set (b # hs) -\n                    {b}. x [^]\n                         restrict\n                          ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                          (set (b # hs)) x)", "by (intro finprod_minus, use hsc Cons bc in auto)"], ["proof (state)\nthis:\n  (\\<Otimes>x\\<in>set (b #\n                       hs). x [^]\n                            restrict\n                             ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                             (set (b # hs)) x) =\n  b [^]\n  restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs))\n   b \\<otimes>\n  (\\<Otimes>x\\<in>set (b # hs) -\n                  {b}. x [^]\n                       restrict\n                        ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                        (set (b # hs)) x)\n\ngoal (1 subgoal):\n 1. (\\<Otimes>x\\<in>set (b #\n                         hs). x [^]\n                              restrict\n                               ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                               (set (b # hs)) x) =\n    \\<one>", "moreover"], ["proof (state)\nthis:\n  (\\<Otimes>x\\<in>set (b #\n                       hs). x [^]\n                            restrict\n                             ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                             (set (b # hs)) x) =\n  b [^]\n  restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs))\n   b \\<otimes>\n  (\\<Otimes>x\\<in>set (b # hs) -\n                  {b}. x [^]\n                       restrict\n                        ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                        (set (b # hs)) x)\n\ngoal (1 subgoal):\n 1. (\\<Otimes>x\\<in>set (b #\n                         hs). x [^]\n                              restrict\n                               ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                               (set (b # hs)) x) =\n    \\<one>", "have \"finprod G (\\<lambda>x. x[^] ?r x) (set (b#hs) - {b}) = a [^] ?r a \\<otimes> finprod G (\\<lambda>x. x[^] ?r x) (set (b#hs) - {b} - {a})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Otimes>x\\<in>set (b # hs) -\n                    {b}. x [^]\n                         restrict\n                          ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                          (set (b # hs)) x) =\n    a [^]\n    restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs))\n     a \\<otimes>\n    (\\<Otimes>x\\<in>set (b # hs) - {b} -\n                    {a}. x [^]\n                         restrict\n                          ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                          (set (b # hs)) x)", "by (intro finprod_minus, use hsc Cons False n anb in auto)"], ["proof (state)\nthis:\n  (\\<Otimes>x\\<in>set (b # hs) -\n                  {b}. x [^]\n                       restrict\n                        ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                        (set (b # hs)) x) =\n  a [^]\n  restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs))\n   a \\<otimes>\n  (\\<Otimes>x\\<in>set (b # hs) - {b} -\n                  {a}. x [^]\n                       restrict\n                        ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                        (set (b # hs)) x)\n\ngoal (1 subgoal):\n 1. (\\<Otimes>x\\<in>set (b #\n                         hs). x [^]\n                              restrict\n                               ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                               (set (b # hs)) x) =\n    \\<one>", "moreover"], ["proof (state)\nthis:\n  (\\<Otimes>x\\<in>set (b # hs) -\n                  {b}. x [^]\n                       restrict\n                        ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                        (set (b # hs)) x) =\n  a [^]\n  restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs))\n   a \\<otimes>\n  (\\<Otimes>x\\<in>set (b # hs) - {b} -\n                  {a}. x [^]\n                       restrict\n                        ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                        (set (b # hs)) x)\n\ngoal (1 subgoal):\n 1. (\\<Otimes>x\\<in>set (b #\n                         hs). x [^]\n                              restrict\n                               ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                               (set (b # hs)) x) =\n    \\<one>", "have \"finprod G (\\<lambda>x. x[^] ?r x) (set (b#hs) - {b} - {a}) = \\<one>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Otimes>x\\<in>set (b # hs) - {b} -\n                    {a}. x [^]\n                         restrict\n                          ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                          (set (b # hs)) x) =\n    \\<one>", "by (intro finprod_one_eqI, simp)"], ["proof (state)\nthis:\n  (\\<Otimes>x\\<in>set (b # hs) - {b} -\n                  {a}. x [^]\n                       restrict\n                        ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                        (set (b # hs)) x) =\n  \\<one>\n\ngoal (1 subgoal):\n 1. (\\<Otimes>x\\<in>set (b #\n                         hs). x [^]\n                              restrict\n                               ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                               (set (b # hs)) x) =\n    \\<one>", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Otimes>x\\<in>set (b #\n                       hs). x [^]\n                            restrict\n                             ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                             (set (b # hs)) x) =\n  b [^]\n  restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs))\n   b \\<otimes>\n  (\\<Otimes>x\\<in>set (b # hs) -\n                  {b}. x [^]\n                       restrict\n                        ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                        (set (b # hs)) x)\n  (\\<Otimes>x\\<in>set (b # hs) -\n                  {b}. x [^]\n                       restrict\n                        ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                        (set (b # hs)) x) =\n  a [^]\n  restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs))\n   a \\<otimes>\n  (\\<Otimes>x\\<in>set (b # hs) - {b} -\n                  {a}. x [^]\n                       restrict\n                        ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                        (set (b # hs)) x)\n  (\\<Otimes>x\\<in>set (b # hs) - {b} -\n                  {a}. x [^]\n                       restrict\n                        ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                        (set (b # hs)) x) =\n  \\<one>", "have \"finprod G (\\<lambda>x. x [^] ?r x) (set (b#hs)) = b [^] ?r b \\<otimes> (a [^] ?r a \\<otimes> \\<one>)\""], ["proof (prove)\nusing this:\n  (\\<Otimes>x\\<in>set (b #\n                       hs). x [^]\n                            restrict\n                             ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                             (set (b # hs)) x) =\n  b [^]\n  restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs))\n   b \\<otimes>\n  (\\<Otimes>x\\<in>set (b # hs) -\n                  {b}. x [^]\n                       restrict\n                        ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                        (set (b # hs)) x)\n  (\\<Otimes>x\\<in>set (b # hs) -\n                  {b}. x [^]\n                       restrict\n                        ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                        (set (b # hs)) x) =\n  a [^]\n  restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs))\n   a \\<otimes>\n  (\\<Otimes>x\\<in>set (b # hs) - {b} -\n                  {a}. x [^]\n                       restrict\n                        ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                        (set (b # hs)) x)\n  (\\<Otimes>x\\<in>set (b # hs) - {b} -\n                  {a}. x [^]\n                       restrict\n                        ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                        (set (b # hs)) x) =\n  \\<one>\n\ngoal (1 subgoal):\n 1. (\\<Otimes>x\\<in>set (b #\n                         hs). x [^]\n                              restrict\n                               ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                               (set (b # hs)) x) =\n    b [^]\n    restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs))\n     b \\<otimes>\n    (a [^]\n     restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs))\n      a \\<otimes>\n     \\<one>)", "by argo"], ["proof (state)\nthis:\n  (\\<Otimes>x\\<in>set (b #\n                       hs). x [^]\n                            restrict\n                             ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                             (set (b # hs)) x) =\n  b [^]\n  restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs))\n   b \\<otimes>\n  (a [^]\n   restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs))\n    a \\<otimes>\n   \\<one>)\n\ngoal (1 subgoal):\n 1. (\\<Otimes>x\\<in>set (b #\n                         hs). x [^]\n                              restrict\n                               ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                               (set (b # hs)) x) =\n    \\<one>", "also"], ["proof (state)\nthis:\n  (\\<Otimes>x\\<in>set (b #\n                       hs). x [^]\n                            restrict\n                             ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                             (set (b # hs)) x) =\n  b [^]\n  restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs))\n   b \\<otimes>\n  (a [^]\n   restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs))\n    a \\<otimes>\n   \\<one>)\n\ngoal (1 subgoal):\n 1. (\\<Otimes>x\\<in>set (b #\n                         hs). x [^]\n                              restrict\n                               ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                               (set (b # hs)) x) =\n    \\<one>", "have \"\\<dots> = b [^] ?r b \\<otimes> a [^] ?r a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b [^]\n    restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs))\n     b \\<otimes>\n    (a [^]\n     restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs))\n      a \\<otimes>\n     \\<one>) =\n    b [^]\n    restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs))\n     b \\<otimes>\n    a [^]\n    restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs)) a", "using Cons hsc"], ["proof (prove)\nusing this:\n  hs = a # list\n  set hs \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. b [^]\n    restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs))\n     b \\<otimes>\n    (a [^]\n     restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs))\n      a \\<otimes>\n     \\<one>) =\n    b [^]\n    restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs))\n     b \\<otimes>\n    a [^]\n    restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs)) a", "by simp"], ["proof (state)\nthis:\n  b [^]\n  restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs))\n   b \\<otimes>\n  (a [^]\n   restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs))\n    a \\<otimes>\n   \\<one>) =\n  b [^]\n  restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs))\n   b \\<otimes>\n  a [^]\n  restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs)) a\n\ngoal (1 subgoal):\n 1. (\\<Otimes>x\\<in>set (b #\n                         hs). x [^]\n                              restrict\n                               ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                               (set (b # hs)) x) =\n    \\<one>", "also"], ["proof (state)\nthis:\n  b [^]\n  restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs))\n   b \\<otimes>\n  (a [^]\n   restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs))\n    a \\<otimes>\n   \\<one>) =\n  b [^]\n  restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs))\n   b \\<otimes>\n  a [^]\n  restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs)) a\n\ngoal (1 subgoal):\n 1. (\\<Otimes>x\\<in>set (b #\n                         hs). x [^]\n                              restrict\n                               ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                               (set (b # hs)) x) =\n    \\<one>", "have \"\\<dots> = b [^] int(ord tau) \\<otimes> a [^] r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b [^]\n    restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs))\n     b \\<otimes>\n    a [^]\n    restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs))\n     a =\n    b [^] int (ord tau) \\<otimes> a [^] r", "using anb Cons"], ["proof (prove)\nusing this:\n  a \\<noteq> b\n  hs = a # list\n\ngoal (1 subgoal):\n 1. b [^]\n    restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs))\n     b \\<otimes>\n    a [^]\n    restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs))\n     a =\n    b [^] int (ord tau) \\<otimes> a [^] r", "by simp"], ["proof (state)\nthis:\n  b [^]\n  restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs))\n   b \\<otimes>\n  a [^]\n  restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs)) a =\n  b [^] int (ord tau) \\<otimes> a [^] r\n\ngoal (1 subgoal):\n 1. (\\<Otimes>x\\<in>set (b #\n                         hs). x [^]\n                              restrict\n                               ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                               (set (b # hs)) x) =\n    \\<one>", "also"], ["proof (state)\nthis:\n  b [^]\n  restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs))\n   b \\<otimes>\n  a [^]\n  restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs)) a =\n  b [^] int (ord tau) \\<otimes> a [^] r\n\ngoal (1 subgoal):\n 1. (\\<Otimes>x\\<in>set (b #\n                         hs). x [^]\n                              restrict\n                               ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                               (set (b # hs)) x) =\n    \\<one>", "have \"\\<dots> = \\<one>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b [^] int (ord tau) \\<otimes> a [^] r = \\<one>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. b [^] int (ord tau) \\<otimes> a [^] r = \\<one>", "have \"b [^] int (ord tau) = tau [^] int (ord tau) \\<otimes> (a [^] q) [^] int (ord tau)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b [^] int (ord tau) =\n    tau [^] int (ord tau) \\<otimes> (a [^] q) [^] int (ord tau)", "using b bc hsc int_pow_distrib local.Cons tc"], ["proof (prove)\nusing this:\n  b = tau \\<otimes> a [^] q\n  b \\<in> carrier G\n  set hs \\<subseteq> carrier G\n  \\<lbrakk>?x \\<in> carrier G; ?y \\<in> carrier G\\<rbrakk>\n  \\<Longrightarrow> (?x \\<otimes> ?y) [^] ?i = ?x [^] ?i \\<otimes> ?y [^] ?i\n  hs = a # list\n  tau \\<in> carrier G\n\ngoal (1 subgoal):\n 1. b [^] int (ord tau) =\n    tau [^] int (ord tau) \\<otimes> (a [^] q) [^] int (ord tau)", "by force"], ["proof (state)\nthis:\n  b [^] int (ord tau) =\n  tau [^] int (ord tau) \\<otimes> (a [^] q) [^] int (ord tau)\n\ngoal (1 subgoal):\n 1. b [^] int (ord tau) \\<otimes> a [^] r = \\<one>", "also"], ["proof (state)\nthis:\n  b [^] int (ord tau) =\n  tau [^] int (ord tau) \\<otimes> (a [^] q) [^] int (ord tau)\n\ngoal (1 subgoal):\n 1. b [^] int (ord tau) \\<otimes> a [^] r = \\<one>", "have \"\\<dots> = (a [^] q) [^] int (ord tau)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tau [^] int (ord tau) \\<otimes> (a [^] q) [^] int (ord tau) =\n    (a [^] q) [^] int (ord tau)", "using trgo hsc local.Cons ot"], ["proof (prove)\nusing this:\n  tau [^] rel g = \\<one>\n  set hs \\<subseteq> carrier G\n  hs = a # list\n  int (ord tau) = rel g\n\ngoal (1 subgoal):\n 1. tau [^] int (ord tau) \\<otimes> (a [^] q) [^] int (ord tau) =\n    (a [^] q) [^] int (ord tau)", "by force"], ["proof (state)\nthis:\n  tau [^] int (ord tau) \\<otimes> (a [^] q) [^] int (ord tau) =\n  (a [^] q) [^] int (ord tau)\n\ngoal (1 subgoal):\n 1. b [^] int (ord tau) \\<otimes> a [^] r = \\<one>", "finally"], ["proof (chain)\npicking this:\n  b [^] int (ord tau) = (a [^] q) [^] int (ord tau)", "have \"b [^] int (ord tau) \\<otimes> a [^] r = (a [^] q) [^] int (ord tau) \\<otimes> a [^] r\""], ["proof (prove)\nusing this:\n  b [^] int (ord tau) = (a [^] q) [^] int (ord tau)\n\ngoal (1 subgoal):\n 1. b [^] int (ord tau) \\<otimes> a [^] r =\n    (a [^] q) [^] int (ord tau) \\<otimes> a [^] r", "by argo"], ["proof (state)\nthis:\n  b [^] int (ord tau) \\<otimes> a [^] r =\n  (a [^] q) [^] int (ord tau) \\<otimes> a [^] r\n\ngoal (1 subgoal):\n 1. b [^] int (ord tau) \\<otimes> a [^] r = \\<one>", "also"], ["proof (state)\nthis:\n  b [^] int (ord tau) \\<otimes> a [^] r =\n  (a [^] q) [^] int (ord tau) \\<otimes> a [^] r\n\ngoal (1 subgoal):\n 1. b [^] int (ord tau) \\<otimes> a [^] r = \\<one>", "have \"\\<dots> = a [^] (q * int (ord tau) + r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a [^] q) [^] int (ord tau) \\<otimes> a [^] r =\n    a [^] (q * int (ord tau) + r)", "using Cons hsc"], ["proof (prove)\nusing this:\n  hs = a # list\n  set hs \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. (a [^] q) [^] int (ord tau) \\<otimes> a [^] r =\n    a [^] (q * int (ord tau) + r)", "by (metis comm_group_axioms comm_group_def group.int_pow_pow\n                                      int_pow_mult list.set_intros(1) subsetD)"], ["proof (state)\nthis:\n  (a [^] q) [^] int (ord tau) \\<otimes> a [^] r =\n  a [^] (q * int (ord tau) + r)\n\ngoal (1 subgoal):\n 1. b [^] int (ord tau) \\<otimes> a [^] r = \\<one>", "also"], ["proof (state)\nthis:\n  (a [^] q) [^] int (ord tau) \\<otimes> a [^] r =\n  a [^] (q * int (ord tau) + r)\n\ngoal (1 subgoal):\n 1. b [^] int (ord tau) \\<otimes> a [^] r = \\<one>", "have \"\\<dots> = a [^] int (ord a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a [^] (q * int (ord tau) + r) = a [^] int (ord a)", "using rq"], ["proof (prove)\nusing this:\n  int (ord a) = q * int (ord tau) + r\n  0 < r\n  r < int (ord tau)\n\ngoal (1 subgoal):\n 1. a [^] (q * int (ord tau) + r) = a [^] int (ord a)", "by argo"], ["proof (state)\nthis:\n  a [^] (q * int (ord tau) + r) = a [^] int (ord a)\n\ngoal (1 subgoal):\n 1. b [^] int (ord tau) \\<otimes> a [^] r = \\<one>", "finally"], ["proof (chain)\npicking this:\n  b [^] int (ord tau) \\<otimes> a [^] r = a [^] int (ord a)", "show ?thesis"], ["proof (prove)\nusing this:\n  b [^] int (ord tau) \\<otimes> a [^] r = a [^] int (ord a)\n\ngoal (1 subgoal):\n 1. b [^] int (ord tau) \\<otimes> a [^] r = \\<one>", "using Cons hsc int_pow_eq_id"], ["proof (prove)\nusing this:\n  b [^] int (ord tau) \\<otimes> a [^] r = a [^] int (ord a)\n  hs = a # list\n  set hs \\<subseteq> carrier G\n  ?x \\<in> carrier G \\<Longrightarrow>\n  (?x [^] ?i = \\<one>) = (int (ord ?x) dvd ?i)\n\ngoal (1 subgoal):\n 1. b [^] int (ord tau) \\<otimes> a [^] r = \\<one>", "by simp"], ["proof (state)\nthis:\n  b [^] int (ord tau) \\<otimes> a [^] r = \\<one>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b [^] int (ord tau) \\<otimes> a [^] r = \\<one>\n\ngoal (1 subgoal):\n 1. (\\<Otimes>x\\<in>set (b #\n                         hs). x [^]\n                              restrict\n                               ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                               (set (b # hs)) x) =\n    \\<one>", "finally"], ["proof (chain)\npicking this:\n  (\\<Otimes>x\\<in>set (b #\n                       hs). x [^]\n                            restrict\n                             ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                             (set (b # hs)) x) =\n  \\<one>", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Otimes>x\\<in>set (b #\n                       hs). x [^]\n                            restrict\n                             ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                             (set (b # hs)) x) =\n  \\<one>\n\ngoal (1 subgoal):\n 1. (\\<Otimes>x\\<in>set (b #\n                         hs). x [^]\n                              restrict\n                               ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                               (set (b # hs)) x) =\n    \\<one>", "."], ["proof (state)\nthis:\n  (\\<Otimes>x\\<in>set (b #\n                       hs). x [^]\n                            restrict\n                             ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                             (set (b # hs)) x) =\n  \\<one>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Otimes>x\\<in>set (b #\n                       hs). x [^]\n                            restrict\n                             ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                             (set (b # hs)) x) =\n  \\<one>\n\ngoal (1 subgoal):\n 1. restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs))\n    \\<in> extensional (set (b # hs))", "qed simp"], ["proof (state)\nthis:\n  restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs))\n  \\<in> relations (set (b # hs))\n\ngoal (1 subgoal):\n 1. nat r\n    \\<in> (\\<Union>rel\\<in>relations (set (b # hs)).\n              nat ` {e \\<in> rel ` set (b # hs). 0 < e})", "moreover"], ["proof (state)\nthis:\n  restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs))\n  \\<in> relations (set (b # hs))\n\ngoal (1 subgoal):\n 1. nat r\n    \\<in> (\\<Union>rel\\<in>relations (set (b # hs)).\n              nat ` {e \\<in> rel ` set (b # hs). 0 < e})", "have \"r \\<in> {e \\<in> ?r ` set (b # hs). 0 < e}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<in> {e \\<in> restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                      (set (b # hs)) `\n                     set (b # hs).\n             0 < e}", "proof (rule, rule, rule)"], ["proof (state)\ngoal (3 subgoals):\n 1. r =\n    restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs))\n     ?x5\n 2. ?x5 \\<in> set (b # hs)\n 3. 0 < r", "show \"0 < r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < r", "by fact"], ["proof (state)\nthis:\n  0 < r\n\ngoal (2 subgoals):\n 1. r =\n    restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs))\n     ?x5\n 2. ?x5 \\<in> set (b # hs)", "show \"a \\<in> set (b#hs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> set (b # hs)", "using Cons"], ["proof (prove)\nusing this:\n  hs = a # list\n\ngoal (1 subgoal):\n 1. a \\<in> set (b # hs)", "by simp"], ["proof (state)\nthis:\n  a \\<in> set (b # hs)\n\ngoal (1 subgoal):\n 1. r =\n    restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs)) a", "thus \"r = ?r a\""], ["proof (prove)\nusing this:\n  a \\<in> set (b # hs)\n\ngoal (1 subgoal):\n 1. r =\n    restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs)) a", "by auto"], ["proof (state)\nthis:\n  r =\n  restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs)) a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  r \\<in> {e \\<in> restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                    (set (b # hs)) `\n                   set (b # hs).\n           0 < e}\n\ngoal (1 subgoal):\n 1. nat r\n    \\<in> (\\<Union>rel\\<in>relations (set (b # hs)).\n              nat ` {e \\<in> rel ` set (b # hs). 0 < e})", "ultimately"], ["proof (chain)\npicking this:\n  restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs))\n  \\<in> relations (set (b # hs))\n  r \\<in> {e \\<in> restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                    (set (b # hs)) `\n                   set (b # hs).\n           0 < e}", "show \"nat r \\<in> (\\<Union>rel\\<in>relations (set (b # hs)). nat ` {e \\<in> rel ` set (b # hs). 0 < e})\""], ["proof (prove)\nusing this:\n  restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r)) (set (b # hs))\n  \\<in> relations (set (b # hs))\n  r \\<in> {e \\<in> restrict ((\\<lambda>_. 0)(b := int (ord tau), a := r))\n                    (set (b # hs)) `\n                   set (b # hs).\n           0 < e}\n\ngoal (1 subgoal):\n 1. nat r\n    \\<in> (\\<Union>rel\\<in>relations (set (b # hs)).\n              nat ` {e \\<in> rel ` set (b # hs). 0 < e})", "by fast"], ["proof (state)\nthis:\n  nat r\n  \\<in> (\\<Union>rel\\<in>relations (set (b # hs)).\n            nat ` {e \\<in> rel ` set (b # hs). 0 < e})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nat r \\<in> exps\n\ngoal (1 subgoal):\n 1. \\<not> card (set (b # hs)) \\<noteq> n \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  nat r \\<in> exps\n\ngoal (1 subgoal):\n 1. \\<not> card (set (b # hs)) \\<noteq> n \\<Longrightarrow> False", "have \"nat r < min_exp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat r < min_exp", "using ot rq(2, 3) gr(4)"], ["proof (prove)\nusing this:\n  int (ord tau) = rel g\n  0 < r\n  r < int (ord tau)\n  rel g = int min_exp\n\ngoal (1 subgoal):\n 1. nat r < min_exp", "by linarith"], ["proof (state)\nthis:\n  nat r < min_exp\n\ngoal (1 subgoal):\n 1. \\<not> card (set (b # hs)) \\<noteq> n \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  nat r \\<in> exps\n  nat r < min_exp", "show False"], ["proof (prove)\nusing this:\n  nat r \\<in> exps\n  nat r < min_exp\n\ngoal (1 subgoal):\n 1. False", "using le"], ["proof (prove)\nusing this:\n  nat r \\<in> exps\n  nat r < min_exp\n  ?x2 \\<in> exps \\<Longrightarrow> min_exp \\<le> ?x2\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ord tau dvd ord a\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<nexists>gs.\n                   set gs \\<subseteq> generate G A \\<and>\n                   cycle gs \\<and>\n                   is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n                    (set gs) \\<and>\n                   successively (dvd) (map ord gs) \\<and>\n                   card (set gs) \\<le> card A;\n        hs = a # list\\<rbrakk>\n       \\<Longrightarrow> successively (dvd) (map ord l)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ord tau dvd ord a\n\ngoal (1 subgoal):\n 1. successively (dvd) (map ord l)", "using hs(4) Cons l"], ["proof (prove)\nusing this:\n  ord tau dvd ord a\n  successively (dvd) (map ord hs)\n  hs = a # list\n  l = tau # hs\n\ngoal (1 subgoal):\n 1. successively (dvd) (map ord l)", "by simp"], ["proof (state)\nthis:\n  successively (dvd) (map ord l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<nexists>gs.\n     set gs \\<subseteq> generate G A \\<and>\n     cycle gs \\<and>\n     is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set gs) \\<and>\n     successively (dvd) (map ord gs) \\<and>\n     card (set gs) \\<le> card A \\<Longrightarrow>\n  successively (dvd) (map ord l)\n\ngoal (1 subgoal):\n 1. length l = n \\<and> cycle l \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "ultimately"], ["proof (chain)\npicking this:\n  complementary (generate G {tau}) (generate G (gs - {g}))\n  is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set l)\n  \\<nexists>gs.\n     set gs \\<subseteq> generate G A \\<and>\n     cycle gs \\<and>\n     is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set gs) \\<and>\n     successively (dvd) (map ord gs) \\<and>\n     card (set gs) \\<le> card A \\<Longrightarrow>\n  successively (dvd) (map ord l)", "show ?thesis"], ["proof (prove)\nusing this:\n  complementary (generate G {tau}) (generate G (gs - {g}))\n  is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set l)\n  \\<nexists>gs.\n     set gs \\<subseteq> generate G A \\<and>\n     cycle gs \\<and>\n     is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set gs) \\<and>\n     successively (dvd) (map ord gs) \\<and>\n     card (set gs) \\<le> card A \\<Longrightarrow>\n  successively (dvd) (map ord l)\n\ngoal (1 subgoal):\n 1. \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "using lgA n dn"], ["proof (prove)\nusing this:\n  complementary (generate G {tau}) (generate G (gs - {g}))\n  is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set l)\n  \\<nexists>gs.\n     set gs \\<subseteq> generate G A \\<and>\n     cycle gs \\<and>\n     is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set gs) \\<and>\n     successively (dvd) (map ord gs) \\<and>\n     card (set gs) \\<le> card A \\<Longrightarrow>\n  successively (dvd) (map ord l)\n  set l \\<subseteq> generate G A\n  n = card A\n  length l = n \\<and> cycle l\n\ngoal (1 subgoal):\n 1. \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "by (metis card_length)"], ["proof (state)\nthis:\n  \\<exists>gs.\n     set gs \\<subseteq> generate G A \\<and>\n     cycle gs \\<and>\n     is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set gs) \\<and>\n     successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>gs.\n     set gs \\<subseteq> generate G A \\<and>\n     cycle gs \\<and>\n     is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set gs) \\<and>\n     successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>gs.\n     set gs \\<subseteq> generate G A \\<and>\n     cycle gs \\<and>\n     is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set gs) \\<and>\n     successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>e\\<in>rel ` gs. rel g dvd e) \\<Longrightarrow>\n    \\<exists>gs.\n       set gs \\<subseteq> generate G A \\<and>\n       cycle gs \\<and>\n       is_idirprod (generate G A) (\\<lambda>g. generate G {g})\n        (set gs) \\<and>\n       successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A", "qed (use dvot in blast)"], ["proof (state)\nthis:\n  \\<exists>gs.\n     set gs \\<subseteq> generate G A \\<and>\n     cycle gs \\<and>\n     is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set gs) \\<and>\n     successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>gs.\n     set gs \\<subseteq> generate G A \\<and>\n     cycle gs \\<and>\n     is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set gs) \\<and>\n     successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>gs.\n     set gs \\<subseteq> generate G A \\<and>\n     cycle gs \\<and>\n     is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set gs) \\<and>\n     successively (dvd) (map ord gs) \\<and> card (set gs) \\<le> card A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in comm_group) fundamental_subgr:\n  fixes A :: \"'a set\"\n  assumes \"finite A\" \"A \\<subseteq> carrier G\"\n  obtains gs where\n    \"set gs \\<subseteq> generate G A\" \"distinct gs\" \"is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set gs)\"\n    \"successively (dvd) (map ord gs)\" \"card (set gs) \\<le> card A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>gs.\n        \\<lbrakk>set gs \\<subseteq> generate G A; cycle gs;\n         is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set gs);\n         successively (dvd) (map ord gs);\n         card (set gs) \\<le> card A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms ex_idirgen"], ["proof (prove)\nusing this:\n  finite A\n  A \\<subseteq> carrier G\n  \\<lbrakk>finite ?A; ?A \\<subseteq> carrier G\\<rbrakk>\n  \\<Longrightarrow> \\<exists>gs.\n                       set gs \\<subseteq> generate G ?A \\<and>\n                       cycle gs \\<and>\n                       is_idirprod (generate G ?A)\n                        (\\<lambda>g. generate G {g}) (set gs) \\<and>\n                       successively (dvd) (map ord gs) \\<and>\n                       card (set gs) \\<le> card ?A\n\ngoal (1 subgoal):\n 1. (\\<And>gs.\n        \\<lbrakk>set gs \\<subseteq> generate G A; cycle gs;\n         is_idirprod (generate G A) (\\<lambda>g. generate G {g}) (set gs);\n         successively (dvd) (map ord gs);\n         card (set gs) \\<le> card A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by meson"], ["", "text \\<open>As every group is a subgroup of itself, the theorem follows directly. However, for reasons of\nconvenience and uniqueness (although not completely proved), we strengthen the result by proving\nthat the decomposition can be done without having the trivial factor in the product.\nWe formulate the theorem in various ways: firstly, the invariant factor decomposition.\\<close>"], ["", "theorem (in fin_gen_comm_group) invariant_factor_decomposition_idirprod:\n  obtains gs where\n    \"set gs \\<subseteq> carrier G\" \"distinct gs\" \"is_idirprod (carrier G) (\\<lambda>g. generate G {g}) (set gs)\"\n    \"successively (dvd) (map ord gs)\" \"card (set gs) \\<le> card gen\" \"\\<one> \\<notin> set gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>gs.\n        \\<lbrakk>set gs \\<subseteq> carrier G; cycle gs;\n         is_idirprod (carrier G) (\\<lambda>g. generate G {g}) (set gs);\n         successively (dvd) (map ord gs); card (set gs) \\<le> card gen;\n         \\<one> \\<notin> set gs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>gs.\n        \\<lbrakk>set gs \\<subseteq> carrier G; cycle gs;\n         is_idirprod (carrier G) (\\<lambda>g. generate G {g}) (set gs);\n         successively (dvd) (map ord gs); card (set gs) \\<le> card gen;\n         \\<one> \\<notin> set gs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from fundamental_subgr[OF fin_gen gens_closed]"], ["proof (chain)\npicking this:\n  (\\<And>gs.\n      \\<lbrakk>set gs \\<subseteq> generate G gen; cycle gs;\n       is_idirprod (generate G gen) (\\<lambda>g. generate G {g}) (set gs);\n       successively (dvd) (map ord gs);\n       card (set gs) \\<le> card gen\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain gs where\n  gs: \"set gs \\<subseteq> carrier G\" \"distinct gs\" \"is_idirprod (carrier G) (\\<lambda>g. generate G {g}) (set gs)\"\n    \"successively (dvd) (map ord gs)\" \"card (set gs) \\<le> card gen\""], ["proof (prove)\nusing this:\n  (\\<And>gs.\n      \\<lbrakk>set gs \\<subseteq> generate G gen; cycle gs;\n       is_idirprod (generate G gen) (\\<lambda>g. generate G {g}) (set gs);\n       successively (dvd) (map ord gs);\n       card (set gs) \\<le> card gen\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>gs.\n        \\<lbrakk>set gs \\<subseteq> carrier G; cycle gs;\n         is_idirprod (carrier G) (\\<lambda>g. generate G {g}) (set gs);\n         successively (dvd) (map ord gs);\n         card (set gs) \\<le> card gen\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using generators"], ["proof (prove)\nusing this:\n  (\\<And>gs.\n      \\<lbrakk>set gs \\<subseteq> generate G gen; cycle gs;\n       is_idirprod (generate G gen) (\\<lambda>g. generate G {g}) (set gs);\n       successively (dvd) (map ord gs);\n       card (set gs) \\<le> card gen\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n  carrier G = generate G gen\n\ngoal (1 subgoal):\n 1. (\\<And>gs.\n        \\<lbrakk>set gs \\<subseteq> carrier G; cycle gs;\n         is_idirprod (carrier G) (\\<lambda>g. generate G {g}) (set gs);\n         successively (dvd) (map ord gs);\n         card (set gs) \\<le> card gen\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  set gs \\<subseteq> carrier G\n  cycle gs\n  is_idirprod (carrier G) (\\<lambda>g. generate G {g}) (set gs)\n  successively (dvd) (map ord gs)\n  card (set gs) \\<le> card gen\n\ngoal (1 subgoal):\n 1. (\\<And>gs.\n        \\<lbrakk>set gs \\<subseteq> carrier G; cycle gs;\n         is_idirprod (carrier G) (\\<lambda>g. generate G {g}) (set gs);\n         successively (dvd) (map ord gs); card (set gs) \\<le> card gen;\n         \\<one> \\<notin> set gs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence cf: \"compl_fam (\\<lambda>g. generate G {g}) (set gs)\""], ["proof (prove)\nusing this:\n  set gs \\<subseteq> carrier G\n  cycle gs\n  is_idirprod (carrier G) (\\<lambda>g. generate G {g}) (set gs)\n  successively (dvd) (map ord gs)\n  card (set gs) \\<le> card gen\n\ngoal (1 subgoal):\n 1. compl_fam (\\<lambda>g. generate G {g}) (set gs)", "by simp"], ["proof (state)\nthis:\n  compl_fam (\\<lambda>g. generate G {g}) (set gs)\n\ngoal (1 subgoal):\n 1. (\\<And>gs.\n        \\<lbrakk>set gs \\<subseteq> carrier G; cycle gs;\n         is_idirprod (carrier G) (\\<lambda>g. generate G {g}) (set gs);\n         successively (dvd) (map ord gs); card (set gs) \\<le> card gen;\n         \\<one> \\<notin> set gs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?r = \"remove1 \\<one> gs\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>gs.\n        \\<lbrakk>set gs \\<subseteq> carrier G; cycle gs;\n         is_idirprod (carrier G) (\\<lambda>g. generate G {g}) (set gs);\n         successively (dvd) (map ord gs); card (set gs) \\<le> card gen;\n         \\<one> \\<notin> set gs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have r: \"set ?r = set gs - {\\<one>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (remove1 \\<one> gs) = set gs - {\\<one>}", "using gs"], ["proof (prove)\nusing this:\n  set gs \\<subseteq> carrier G\n  cycle gs\n  is_idirprod (carrier G) (\\<lambda>g. generate G {g}) (set gs)\n  successively (dvd) (map ord gs)\n  card (set gs) \\<le> card gen\n\ngoal (1 subgoal):\n 1. set (remove1 \\<one> gs) = set gs - {\\<one>}", "by auto"], ["proof (state)\nthis:\n  set (remove1 \\<one> gs) = set gs - {\\<one>}\n\ngoal (1 subgoal):\n 1. (\\<And>gs.\n        \\<lbrakk>set gs \\<subseteq> carrier G; cycle gs;\n         is_idirprod (carrier G) (\\<lambda>g. generate G {g}) (set gs);\n         successively (dvd) (map ord gs); card (set gs) \\<le> card gen;\n         \\<one> \\<notin> set gs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"set ?r \\<subseteq> carrier G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (remove1 \\<one> gs) \\<subseteq> carrier G", "using gs"], ["proof (prove)\nusing this:\n  set gs \\<subseteq> carrier G\n  cycle gs\n  is_idirprod (carrier G) (\\<lambda>g. generate G {g}) (set gs)\n  successively (dvd) (map ord gs)\n  card (set gs) \\<le> card gen\n\ngoal (1 subgoal):\n 1. set (remove1 \\<one> gs) \\<subseteq> carrier G", "by auto"], ["proof (state)\nthis:\n  set (remove1 \\<one> gs) \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. (\\<And>gs.\n        \\<lbrakk>set gs \\<subseteq> carrier G; cycle gs;\n         is_idirprod (carrier G) (\\<lambda>g. generate G {g}) (set gs);\n         successively (dvd) (map ord gs); card (set gs) \\<le> card gen;\n         \\<one> \\<notin> set gs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  set (remove1 \\<one> gs) \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. (\\<And>gs.\n        \\<lbrakk>set gs \\<subseteq> carrier G; cycle gs;\n         is_idirprod (carrier G) (\\<lambda>g. generate G {g}) (set gs);\n         successively (dvd) (map ord gs); card (set gs) \\<le> card gen;\n         \\<one> \\<notin> set gs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"distinct ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cycle (remove1 \\<one> gs)", "using gs"], ["proof (prove)\nusing this:\n  set gs \\<subseteq> carrier G\n  cycle gs\n  is_idirprod (carrier G) (\\<lambda>g. generate G {g}) (set gs)\n  successively (dvd) (map ord gs)\n  card (set gs) \\<le> card gen\n\ngoal (1 subgoal):\n 1. cycle (remove1 \\<one> gs)", "by auto"], ["proof (state)\nthis:\n  cycle (remove1 \\<one> gs)\n\ngoal (1 subgoal):\n 1. (\\<And>gs.\n        \\<lbrakk>set gs \\<subseteq> carrier G; cycle gs;\n         is_idirprod (carrier G) (\\<lambda>g. generate G {g}) (set gs);\n         successively (dvd) (map ord gs); card (set gs) \\<le> card gen;\n         \\<one> \\<notin> set gs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  cycle (remove1 \\<one> gs)\n\ngoal (1 subgoal):\n 1. (\\<And>gs.\n        \\<lbrakk>set gs \\<subseteq> carrier G; cycle gs;\n         is_idirprod (carrier G) (\\<lambda>g. generate G {g}) (set gs);\n         successively (dvd) (map ord gs); card (set gs) \\<le> card gen;\n         \\<one> \\<notin> set gs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"is_idirprod (carrier G) (\\<lambda>g. generate G {g}) (set ?r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_idirprod (carrier G) (\\<lambda>g. generate G {g})\n     (set (remove1 \\<one> gs))", "proof (intro is_idirprod_generate)"], ["proof (state)\ngoal (3 subgoals):\n 1. carrier G = generate G (set (remove1 \\<one> gs))\n 2. set (remove1 \\<one> gs) \\<subseteq> carrier G\n 3. compl_fam (\\<lambda>g. generate G {g}) (set (remove1 \\<one> gs))", "show \"set ?r \\<subseteq> carrier G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (remove1 \\<one> gs) \\<subseteq> carrier G", "using gs"], ["proof (prove)\nusing this:\n  set gs \\<subseteq> carrier G\n  cycle gs\n  is_idirprod (carrier G) (\\<lambda>g. generate G {g}) (set gs)\n  successively (dvd) (map ord gs)\n  card (set gs) \\<le> card gen\n\ngoal (1 subgoal):\n 1. set (remove1 \\<one> gs) \\<subseteq> carrier G", "by auto"], ["proof (state)\nthis:\n  set (remove1 \\<one> gs) \\<subseteq> carrier G\n\ngoal (2 subgoals):\n 1. carrier G = generate G (set (remove1 \\<one> gs))\n 2. compl_fam (\\<lambda>g. generate G {g}) (set (remove1 \\<one> gs))", "show \"compl_fam (\\<lambda>g. generate G {g}) (set (remove1 \\<one> gs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compl_fam (\\<lambda>g. generate G {g}) (set (remove1 \\<one> gs))", "by (rule compl_fam_generate_subset[OF cf gs(1)], use set_remove1_subset in fastforce)"], ["proof (state)\nthis:\n  compl_fam (\\<lambda>g. generate G {g}) (set (remove1 \\<one> gs))\n\ngoal (1 subgoal):\n 1. carrier G = generate G (set (remove1 \\<one> gs))", "show \"carrier G = generate G (set ?r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. carrier G = generate G (set (remove1 \\<one> gs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. carrier G = generate G (set (remove1 \\<one> gs))", "have \"generate G (set ?r) = generate G (set gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generate G (set (remove1 \\<one> gs)) = generate G (set gs)", "using generate_one_irrel' r"], ["proof (prove)\nusing this:\n  generate G ?A = generate G (?A - {\\<one>})\n  set (remove1 \\<one> gs) = set gs - {\\<one>}\n\ngoal (1 subgoal):\n 1. generate G (set (remove1 \\<one> gs)) = generate G (set gs)", "by simp"], ["proof (state)\nthis:\n  generate G (set (remove1 \\<one> gs)) = generate G (set gs)\n\ngoal (1 subgoal):\n 1. carrier G = generate G (set (remove1 \\<one> gs))", "with gs(3)"], ["proof (chain)\npicking this:\n  is_idirprod (carrier G) (\\<lambda>g. generate G {g}) (set gs)\n  generate G (set (remove1 \\<one> gs)) = generate G (set gs)", "show ?thesis"], ["proof (prove)\nusing this:\n  is_idirprod (carrier G) (\\<lambda>g. generate G {g}) (set gs)\n  generate G (set (remove1 \\<one> gs)) = generate G (set gs)\n\ngoal (1 subgoal):\n 1. carrier G = generate G (set (remove1 \\<one> gs))", "by simp"], ["proof (state)\nthis:\n  carrier G = generate G (set (remove1 \\<one> gs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  carrier G = generate G (set (remove1 \\<one> gs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_idirprod (carrier G) (\\<lambda>g. generate G {g})\n   (set (remove1 \\<one> gs))\n\ngoal (1 subgoal):\n 1. (\\<And>gs.\n        \\<lbrakk>set gs \\<subseteq> carrier G; cycle gs;\n         is_idirprod (carrier G) (\\<lambda>g. generate G {g}) (set gs);\n         successively (dvd) (map ord gs); card (set gs) \\<le> card gen;\n         \\<one> \\<notin> set gs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  is_idirprod (carrier G) (\\<lambda>g. generate G {g})\n   (set (remove1 \\<one> gs))\n\ngoal (1 subgoal):\n 1. (\\<And>gs.\n        \\<lbrakk>set gs \\<subseteq> carrier G; cycle gs;\n         is_idirprod (carrier G) (\\<lambda>g. generate G {g}) (set gs);\n         successively (dvd) (map ord gs); card (set gs) \\<le> card gen;\n         \\<one> \\<notin> set gs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"successively (dvd) (map ord ?r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. successively (dvd) (map ord (remove1 \\<one> gs))", "proof (cases gs)"], ["proof (state)\ngoal (2 subgoals):\n 1. gs = [] \\<Longrightarrow>\n    successively (dvd) (map ord (remove1 \\<one> gs))\n 2. \\<And>a list.\n       gs = a # list \\<Longrightarrow>\n       successively (dvd) (map ord (remove1 \\<one> gs))", "case (Cons a list)"], ["proof (state)\nthis:\n  gs = a # list\n\ngoal (2 subgoals):\n 1. gs = [] \\<Longrightarrow>\n    successively (dvd) (map ord (remove1 \\<one> gs))\n 2. \\<And>a list.\n       gs = a # list \\<Longrightarrow>\n       successively (dvd) (map ord (remove1 \\<one> gs))", "have r: \"(map ord (remove1 \\<one> gs)) = remove1 1 (map ord gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map ord (remove1 \\<one> gs) = remove1 1 (map ord gs)", "using gs(1)"], ["proof (prove)\nusing this:\n  set gs \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. map ord (remove1 \\<one> gs) = remove1 1 (map ord gs)", "proof(induction gs)"], ["proof (state)\ngoal (2 subgoals):\n 1. set [] \\<subseteq> carrier G \\<Longrightarrow>\n    map ord (remove1 \\<one> []) = remove1 1 (map ord [])\n 2. \\<And>a gs.\n       \\<lbrakk>set gs \\<subseteq> carrier G \\<Longrightarrow>\n                map ord (remove1 \\<one> gs) = remove1 1 (map ord gs);\n        set (a # gs) \\<subseteq> carrier G\\<rbrakk>\n       \\<Longrightarrow> map ord (remove1 \\<one> (a # gs)) =\n                         remove1 1 (map ord (a # gs))", "case (Cons a gs)"], ["proof (state)\nthis:\n  set gs \\<subseteq> carrier G \\<Longrightarrow>\n  map ord (remove1 \\<one> gs) = remove1 1 (map ord gs)\n  set (a # gs) \\<subseteq> carrier G\n\ngoal (2 subgoals):\n 1. set [] \\<subseteq> carrier G \\<Longrightarrow>\n    map ord (remove1 \\<one> []) = remove1 1 (map ord [])\n 2. \\<And>a gs.\n       \\<lbrakk>set gs \\<subseteq> carrier G \\<Longrightarrow>\n                map ord (remove1 \\<one> gs) = remove1 1 (map ord gs);\n        set (a # gs) \\<subseteq> carrier G\\<rbrakk>\n       \\<Longrightarrow> map ord (remove1 \\<one> (a # gs)) =\n                         remove1 1 (map ord (a # gs))", "hence \"a \\<in> carrier G\""], ["proof (prove)\nusing this:\n  set gs \\<subseteq> carrier G \\<Longrightarrow>\n  map ord (remove1 \\<one> gs) = remove1 1 (map ord gs)\n  set (a # gs) \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. a \\<in> carrier G", "by simp"], ["proof (state)\nthis:\n  a \\<in> carrier G\n\ngoal (2 subgoals):\n 1. set [] \\<subseteq> carrier G \\<Longrightarrow>\n    map ord (remove1 \\<one> []) = remove1 1 (map ord [])\n 2. \\<And>a gs.\n       \\<lbrakk>set gs \\<subseteq> carrier G \\<Longrightarrow>\n                map ord (remove1 \\<one> gs) = remove1 1 (map ord gs);\n        set (a # gs) \\<subseteq> carrier G\\<rbrakk>\n       \\<Longrightarrow> map ord (remove1 \\<one> (a # gs)) =\n                         remove1 1 (map ord (a # gs))", "with Cons ord_eq_1[OF this]"], ["proof (chain)\npicking this:\n  set gs \\<subseteq> carrier G \\<Longrightarrow>\n  map ord (remove1 \\<one> gs) = remove1 1 (map ord gs)\n  set (a # gs) \\<subseteq> carrier G\n  (ord a = 1) = (a = \\<one>)\n  a \\<in> carrier G", "show ?case"], ["proof (prove)\nusing this:\n  set gs \\<subseteq> carrier G \\<Longrightarrow>\n  map ord (remove1 \\<one> gs) = remove1 1 (map ord gs)\n  set (a # gs) \\<subseteq> carrier G\n  (ord a = 1) = (a = \\<one>)\n  a \\<in> carrier G\n\ngoal (1 subgoal):\n 1. map ord (remove1 \\<one> (a # gs)) = remove1 1 (map ord (a # gs))", "by auto"], ["proof (state)\nthis:\n  map ord (remove1 \\<one> (a # gs)) = remove1 1 (map ord (a # gs))\n\ngoal (1 subgoal):\n 1. set [] \\<subseteq> carrier G \\<Longrightarrow>\n    map ord (remove1 \\<one> []) = remove1 1 (map ord [])", "qed simp"], ["proof (state)\nthis:\n  map ord (remove1 \\<one> gs) = remove1 1 (map ord gs)\n\ngoal (2 subgoals):\n 1. gs = [] \\<Longrightarrow>\n    successively (dvd) (map ord (remove1 \\<one> gs))\n 2. \\<And>a list.\n       gs = a # list \\<Longrightarrow>\n       successively (dvd) (map ord (remove1 \\<one> gs))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. successively (dvd) (map ord (remove1 \\<one> gs))", "by (unfold r,\n                     rule transp_successively_remove1[OF _ gs(4), unfolded transp_def],\n                     auto)"], ["proof (state)\nthis:\n  successively (dvd) (map ord (remove1 \\<one> gs))\n\ngoal (1 subgoal):\n 1. gs = [] \\<Longrightarrow>\n    successively (dvd) (map ord (remove1 \\<one> gs))", "qed simp"], ["proof (state)\nthis:\n  successively (dvd) (map ord (remove1 \\<one> gs))\n\ngoal (1 subgoal):\n 1. (\\<And>gs.\n        \\<lbrakk>set gs \\<subseteq> carrier G; cycle gs;\n         is_idirprod (carrier G) (\\<lambda>g. generate G {g}) (set gs);\n         successively (dvd) (map ord gs); card (set gs) \\<le> card gen;\n         \\<one> \\<notin> set gs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  successively (dvd) (map ord (remove1 \\<one> gs))\n\ngoal (1 subgoal):\n 1. (\\<And>gs.\n        \\<lbrakk>set gs \\<subseteq> carrier G; cycle gs;\n         is_idirprod (carrier G) (\\<lambda>g. generate G {g}) (set gs);\n         successively (dvd) (map ord gs); card (set gs) \\<le> card gen;\n         \\<one> \\<notin> set gs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"card (set ?r) \\<le> card gen\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set (remove1 \\<one> gs)) \\<le> card gen", "using gs(5) r"], ["proof (prove)\nusing this:\n  card (set gs) \\<le> card gen\n  set (remove1 \\<one> gs) = set gs - {\\<one>}\n\ngoal (1 subgoal):\n 1. card (set (remove1 \\<one> gs)) \\<le> card gen", "by (metis List.finite_set card_Diff1_le dual_order.trans)"], ["proof (state)\nthis:\n  card (set (remove1 \\<one> gs)) \\<le> card gen\n\ngoal (1 subgoal):\n 1. (\\<And>gs.\n        \\<lbrakk>set gs \\<subseteq> carrier G; cycle gs;\n         is_idirprod (carrier G) (\\<lambda>g. generate G {g}) (set gs);\n         successively (dvd) (map ord gs); card (set gs) \\<le> card gen;\n         \\<one> \\<notin> set gs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  card (set (remove1 \\<one> gs)) \\<le> card gen\n\ngoal (1 subgoal):\n 1. (\\<And>gs.\n        \\<lbrakk>set gs \\<subseteq> carrier G; cycle gs;\n         is_idirprod (carrier G) (\\<lambda>g. generate G {g}) (set gs);\n         successively (dvd) (map ord gs); card (set gs) \\<le> card gen;\n         \\<one> \\<notin> set gs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<one> \\<notin> set ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<one> \\<notin> set (remove1 \\<one> gs)", "using gs(2)"], ["proof (prove)\nusing this:\n  cycle gs\n\ngoal (1 subgoal):\n 1. \\<one> \\<notin> set (remove1 \\<one> gs)", "by auto"], ["proof (state)\nthis:\n  \\<one> \\<notin> set (remove1 \\<one> gs)\n\ngoal (1 subgoal):\n 1. (\\<And>gs.\n        \\<lbrakk>set gs \\<subseteq> carrier G; cycle gs;\n         is_idirprod (carrier G) (\\<lambda>g. generate G {g}) (set gs);\n         successively (dvd) (map ord gs); card (set gs) \\<le> card gen;\n         \\<one> \\<notin> set gs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  set (remove1 \\<one> gs) \\<subseteq> carrier G\n  cycle (remove1 \\<one> gs)\n  is_idirprod (carrier G) (\\<lambda>g. generate G {g})\n   (set (remove1 \\<one> gs))\n  successively (dvd) (map ord (remove1 \\<one> gs))\n  card (set (remove1 \\<one> gs)) \\<le> card gen\n  \\<one> \\<notin> set (remove1 \\<one> gs)", "show ?thesis"], ["proof (prove)\nusing this:\n  set (remove1 \\<one> gs) \\<subseteq> carrier G\n  cycle (remove1 \\<one> gs)\n  is_idirprod (carrier G) (\\<lambda>g. generate G {g})\n   (set (remove1 \\<one> gs))\n  successively (dvd) (map ord (remove1 \\<one> gs))\n  card (set (remove1 \\<one> gs)) \\<le> card gen\n  \\<one> \\<notin> set (remove1 \\<one> gs)\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  set (remove1 \\<one> gs) \\<subseteq> carrier G\n  cycle (remove1 \\<one> gs)\n  is_idirprod (carrier G) (\\<lambda>g. generate G {g})\n   (set (remove1 \\<one> gs))\n  successively (dvd) (map ord (remove1 \\<one> gs))\n  card (set (remove1 \\<one> gs)) \\<le> card gen\n  \\<one> \\<notin> set (remove1 \\<one> gs)\n  \\<lbrakk>set ?gs2 \\<subseteq> carrier G; cycle ?gs2;\n   is_idirprod (carrier G) (\\<lambda>g. generate G {g}) (set ?gs2);\n   successively (dvd) (map ord ?gs2); card (set ?gs2) \\<le> card gen;\n   \\<one> \\<notin> set ?gs2\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary (in fin_gen_comm_group) invariant_factor_decomposition_dirprod:\n  obtains gs where\n    \"set gs \\<subseteq> carrier G\" \"distinct gs\"\n    \"DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>) (set gs) \\<cong> G\"\n    \"successively (dvd) (map ord gs)\" \"card (set gs) \\<le> card gen\"\n    \"compl_fam (\\<lambda>g. generate G {g}) (set gs)\" \"\\<one> \\<notin> set gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>gs.\n        \\<lbrakk>set gs \\<subseteq> carrier G; cycle gs;\n         DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n          (set gs) \\<cong>\n         G;\n         successively (dvd) (map ord gs); card (set gs) \\<le> card gen;\n         compl_fam (\\<lambda>g. generate G {g}) (set gs);\n         \\<one> \\<notin> set gs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>gs.\n        \\<lbrakk>set gs \\<subseteq> carrier G; cycle gs;\n         DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n          (set gs) \\<cong>\n         G;\n         successively (dvd) (map ord gs); card (set gs) \\<le> card gen;\n         compl_fam (\\<lambda>g. generate G {g}) (set gs);\n         \\<one> \\<notin> set gs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from invariant_factor_decomposition_idirprod"], ["proof (chain)\npicking this:\n  (\\<And>gs.\n      \\<lbrakk>set gs \\<subseteq> carrier G; cycle gs;\n       is_idirprod (carrier G) (\\<lambda>g. generate G {g}) (set gs);\n       successively (dvd) (map ord gs); card (set gs) \\<le> card gen;\n       \\<one> \\<notin> set gs\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain gs where\n    gs: \"set gs \\<subseteq> carrier G\" \"distinct gs\" \"is_idirprod (carrier G) (\\<lambda>g. generate G {g}) (set gs)\"\n        \"successively (dvd) (map ord gs)\" \"card (set gs) \\<le> card gen\" \"\\<one> \\<notin> set gs\""], ["proof (prove)\nusing this:\n  (\\<And>gs.\n      \\<lbrakk>set gs \\<subseteq> carrier G; cycle gs;\n       is_idirprod (carrier G) (\\<lambda>g. generate G {g}) (set gs);\n       successively (dvd) (map ord gs); card (set gs) \\<le> card gen;\n       \\<one> \\<notin> set gs\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>gs.\n        \\<lbrakk>set gs \\<subseteq> carrier G; cycle gs;\n         is_idirprod (carrier G) (\\<lambda>g. generate G {g}) (set gs);\n         successively (dvd) (map ord gs); card (set gs) \\<le> card gen;\n         \\<one> \\<notin> set gs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  set gs \\<subseteq> carrier G\n  cycle gs\n  is_idirprod (carrier G) (\\<lambda>g. generate G {g}) (set gs)\n  successively (dvd) (map ord gs)\n  card (set gs) \\<le> card gen\n  \\<one> \\<notin> set gs\n\ngoal (1 subgoal):\n 1. (\\<And>gs.\n        \\<lbrakk>set gs \\<subseteq> carrier G; cycle gs;\n         DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n          (set gs) \\<cong>\n         G;\n         successively (dvd) (map ord gs); card (set gs) \\<le> card gen;\n         compl_fam (\\<lambda>g. generate G {g}) (set gs);\n         \\<one> \\<notin> set gs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with cong_DirProds_IDirProds[OF gs(3)] gs"], ["proof (chain)\npicking this:\n  finite (set gs) \\<Longrightarrow>\n  DirProds (\\<lambda>i. G\\<lparr>carrier := generate G {i}\\<rparr>)\n   (set gs) \\<cong>\n  G\n  set gs \\<subseteq> carrier G\n  cycle gs\n  is_idirprod (carrier G) (\\<lambda>g. generate G {g}) (set gs)\n  successively (dvd) (map ord gs)\n  card (set gs) \\<le> card gen\n  \\<one> \\<notin> set gs\n  set gs \\<subseteq> carrier G\n  cycle gs\n  is_idirprod (carrier G) (\\<lambda>g. generate G {g}) (set gs)\n  successively (dvd) (map ord gs)\n  card (set gs) \\<le> card gen\n  \\<one> \\<notin> set gs", "have \"DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>) (set gs) \\<cong> G\""], ["proof (prove)\nusing this:\n  finite (set gs) \\<Longrightarrow>\n  DirProds (\\<lambda>i. G\\<lparr>carrier := generate G {i}\\<rparr>)\n   (set gs) \\<cong>\n  G\n  set gs \\<subseteq> carrier G\n  cycle gs\n  is_idirprod (carrier G) (\\<lambda>g. generate G {g}) (set gs)\n  successively (dvd) (map ord gs)\n  card (set gs) \\<le> card gen\n  \\<one> \\<notin> set gs\n  set gs \\<subseteq> carrier G\n  cycle gs\n  is_idirprod (carrier G) (\\<lambda>g. generate G {g}) (set gs)\n  successively (dvd) (map ord gs)\n  card (set gs) \\<le> card gen\n  \\<one> \\<notin> set gs\n\ngoal (1 subgoal):\n 1. DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n     (set gs) \\<cong>\n    G", "by blast"], ["proof (state)\nthis:\n  DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n   (set gs) \\<cong>\n  G\n\ngoal (1 subgoal):\n 1. (\\<And>gs.\n        \\<lbrakk>set gs \\<subseteq> carrier G; cycle gs;\n         DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n          (set gs) \\<cong>\n         G;\n         successively (dvd) (map ord gs); card (set gs) \\<le> card gen;\n         compl_fam (\\<lambda>g. generate G {g}) (set gs);\n         \\<one> \\<notin> set gs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with gs that"], ["proof (chain)\npicking this:\n  set gs \\<subseteq> carrier G\n  cycle gs\n  is_idirprod (carrier G) (\\<lambda>g. generate G {g}) (set gs)\n  successively (dvd) (map ord gs)\n  card (set gs) \\<le> card gen\n  \\<one> \\<notin> set gs\n  \\<lbrakk>set ?gs2 \\<subseteq> carrier G; cycle ?gs2;\n   DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n    (set ?gs2) \\<cong>\n   G;\n   successively (dvd) (map ord ?gs2); card (set ?gs2) \\<le> card gen;\n   compl_fam (\\<lambda>g. generate G {g}) (set ?gs2);\n   \\<one> \\<notin> set ?gs2\\<rbrakk>\n  \\<Longrightarrow> thesis\n  DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n   (set gs) \\<cong>\n  G", "show ?thesis"], ["proof (prove)\nusing this:\n  set gs \\<subseteq> carrier G\n  cycle gs\n  is_idirprod (carrier G) (\\<lambda>g. generate G {g}) (set gs)\n  successively (dvd) (map ord gs)\n  card (set gs) \\<le> card gen\n  \\<one> \\<notin> set gs\n  \\<lbrakk>set ?gs2 \\<subseteq> carrier G; cycle ?gs2;\n   DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n    (set ?gs2) \\<cong>\n   G;\n   successively (dvd) (map ord ?gs2); card (set ?gs2) \\<le> card gen;\n   compl_fam (\\<lambda>g. generate G {g}) (set ?gs2);\n   \\<one> \\<notin> set ?gs2\\<rbrakk>\n  \\<Longrightarrow> thesis\n  DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n   (set gs) \\<cong>\n  G\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary (in fin_gen_comm_group) invariant_factor_decomposition_dirprod_fam:\n  obtains Hs where\n    \"\\<And>H. H \\<in> set Hs \\<Longrightarrow> subgroup H G\" \"distinct Hs\"\n    \"DirProds (\\<lambda>H. G\\<lparr>carrier := H\\<rparr>) (set Hs) \\<cong> G\" \"successively (dvd) (map card Hs)\"\n    \"card (set Hs) \\<le> card gen\" \"compl_fam id (set Hs)\" \"{\\<one>} \\<notin> set Hs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Hs.\n        \\<lbrakk>\\<And>H. H \\<in> set Hs \\<Longrightarrow> subgroup H G;\n         cycle Hs;\n         DirProds (\\<lambda>H. G\\<lparr>carrier := H\\<rparr>)\n          (set Hs) \\<cong>\n         G;\n         successively (dvd) (map card Hs); card (set Hs) \\<le> card gen;\n         compl_fam id (set Hs); {\\<one>} \\<notin> set Hs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>Hs.\n        \\<lbrakk>\\<And>H. H \\<in> set Hs \\<Longrightarrow> subgroup H G;\n         cycle Hs;\n         DirProds (\\<lambda>H. G\\<lparr>carrier := H\\<rparr>)\n          (set Hs) \\<cong>\n         G;\n         successively (dvd) (map card Hs); card (set Hs) \\<le> card gen;\n         compl_fam id (set Hs); {\\<one>} \\<notin> set Hs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from invariant_factor_decomposition_dirprod"], ["proof (chain)\npicking this:\n  (\\<And>gs.\n      \\<lbrakk>set gs \\<subseteq> carrier G; cycle gs;\n       DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n        (set gs) \\<cong>\n       G;\n       successively (dvd) (map ord gs); card (set gs) \\<le> card gen;\n       compl_fam (\\<lambda>g. generate G {g}) (set gs);\n       \\<one> \\<notin> set gs\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain gs where\n  gs: \"set gs \\<subseteq> carrier G\" \"distinct gs\"\n      \"DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>) (set gs) \\<cong> G\"\n      \"successively (dvd) (map ord gs)\" \"card (set gs) \\<le> card gen\"\n      \"compl_fam (\\<lambda>g. generate G {g}) (set gs)\" \"\\<one> \\<notin> set gs\""], ["proof (prove)\nusing this:\n  (\\<And>gs.\n      \\<lbrakk>set gs \\<subseteq> carrier G; cycle gs;\n       DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n        (set gs) \\<cong>\n       G;\n       successively (dvd) (map ord gs); card (set gs) \\<le> card gen;\n       compl_fam (\\<lambda>g. generate G {g}) (set gs);\n       \\<one> \\<notin> set gs\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>gs.\n        \\<lbrakk>set gs \\<subseteq> carrier G; cycle gs;\n         DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n          (set gs) \\<cong>\n         G;\n         successively (dvd) (map ord gs); card (set gs) \\<le> card gen;\n         compl_fam (\\<lambda>g. generate G {g}) (set gs);\n         \\<one> \\<notin> set gs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  set gs \\<subseteq> carrier G\n  cycle gs\n  DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n   (set gs) \\<cong>\n  G\n  successively (dvd) (map ord gs)\n  card (set gs) \\<le> card gen\n  compl_fam (\\<lambda>g. generate G {g}) (set gs)\n  \\<one> \\<notin> set gs\n\ngoal (1 subgoal):\n 1. (\\<And>Hs.\n        \\<lbrakk>\\<And>H. H \\<in> set Hs \\<Longrightarrow> subgroup H G;\n         cycle Hs;\n         DirProds (\\<lambda>H. G\\<lparr>carrier := H\\<rparr>)\n          (set Hs) \\<cong>\n         G;\n         successively (dvd) (map card Hs); card (set Hs) \\<le> card gen;\n         compl_fam id (set Hs); {\\<one>} \\<notin> set Hs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?gen = \"(\\<lambda>g. generate G {g})\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>Hs.\n        \\<lbrakk>\\<And>H. H \\<in> set Hs \\<Longrightarrow> subgroup H G;\n         cycle Hs;\n         DirProds (\\<lambda>H. G\\<lparr>carrier := H\\<rparr>)\n          (set Hs) \\<cong>\n         G;\n         successively (dvd) (map card Hs); card (set Hs) \\<le> card gen;\n         compl_fam id (set Hs); {\\<one>} \\<notin> set Hs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?Hs = \"map (\\<lambda>g. ?gen g) gs\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>Hs.\n        \\<lbrakk>\\<And>H. H \\<in> set Hs \\<Longrightarrow> subgroup H G;\n         cycle Hs;\n         DirProds (\\<lambda>H. G\\<lparr>carrier := H\\<rparr>)\n          (set Hs) \\<cong>\n         G;\n         successively (dvd) (map card Hs); card (set Hs) \\<le> card gen;\n         compl_fam id (set Hs); {\\<one>} \\<notin> set Hs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"subgroup H G\" if \"H \\<in> set ?Hs\" for H"], ["proof (prove)\ngoal (1 subgoal):\n 1. subgroup H G", "using that gs"], ["proof (prove)\nusing this:\n  H \\<in> set (map (\\<lambda>g. generate G {g}) gs)\n  set gs \\<subseteq> carrier G\n  cycle gs\n  DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n   (set gs) \\<cong>\n  G\n  successively (dvd) (map ord gs)\n  card (set gs) \\<le> card gen\n  compl_fam (\\<lambda>g. generate G {g}) (set gs)\n  \\<one> \\<notin> set gs\n\ngoal (1 subgoal):\n 1. subgroup H G", "by (auto intro: generate_is_subgroup)"], ["proof (state)\nthis:\n  ?H2 \\<in> set (map (\\<lambda>g. generate G {g}) gs) \\<Longrightarrow>\n  subgroup ?H2 G\n\ngoal (1 subgoal):\n 1. (\\<And>Hs.\n        \\<lbrakk>\\<And>H. H \\<in> set Hs \\<Longrightarrow> subgroup H G;\n         cycle Hs;\n         DirProds (\\<lambda>H. G\\<lparr>carrier := H\\<rparr>)\n          (set Hs) \\<cong>\n         G;\n         successively (dvd) (map card Hs); card (set Hs) \\<le> card gen;\n         compl_fam id (set Hs); {\\<one>} \\<notin> set Hs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  ?H2 \\<in> set (map (\\<lambda>g. generate G {g}) gs) \\<Longrightarrow>\n  subgroup ?H2 G\n\ngoal (1 subgoal):\n 1. (\\<And>Hs.\n        \\<lbrakk>\\<And>H. H \\<in> set Hs \\<Longrightarrow> subgroup H G;\n         cycle Hs;\n         DirProds (\\<lambda>H. G\\<lparr>carrier := H\\<rparr>)\n          (set Hs) \\<cong>\n         G;\n         successively (dvd) (map card Hs); card (set Hs) \\<le> card gen;\n         compl_fam id (set Hs); {\\<one>} \\<notin> set Hs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"distinct ?Hs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cycle (map (\\<lambda>g. generate G {g}) gs)", "using compl_fam_imp_generate_inj[OF gs(1)] gs distinct_map"], ["proof (prove)\nusing this:\n  compl_fam (\\<lambda>g. generate G {g}) (set gs) \\<Longrightarrow>\n  inj_on (\\<lambda>g. generate G {g}) (set gs)\n  set gs \\<subseteq> carrier G\n  cycle gs\n  DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n   (set gs) \\<cong>\n  G\n  successively (dvd) (map ord gs)\n  card (set gs) \\<le> card gen\n  compl_fam (\\<lambda>g. generate G {g}) (set gs)\n  \\<one> \\<notin> set gs\n  cycle (map ?f ?xs) = (cycle ?xs \\<and> inj_on ?f (set ?xs))\n\ngoal (1 subgoal):\n 1. cycle (map (\\<lambda>g. generate G {g}) gs)", "by blast"], ["proof (state)\nthis:\n  cycle (map (\\<lambda>g. generate G {g}) gs)\n\ngoal (1 subgoal):\n 1. (\\<And>Hs.\n        \\<lbrakk>\\<And>H. H \\<in> set Hs \\<Longrightarrow> subgroup H G;\n         cycle Hs;\n         DirProds (\\<lambda>H. G\\<lparr>carrier := H\\<rparr>)\n          (set Hs) \\<cong>\n         G;\n         successively (dvd) (map card Hs); card (set Hs) \\<le> card gen;\n         compl_fam id (set Hs); {\\<one>} \\<notin> set Hs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  cycle (map (\\<lambda>g. generate G {g}) gs)\n\ngoal (1 subgoal):\n 1. (\\<And>Hs.\n        \\<lbrakk>\\<And>H. H \\<in> set Hs \\<Longrightarrow> subgroup H G;\n         cycle Hs;\n         DirProds (\\<lambda>H. G\\<lparr>carrier := H\\<rparr>)\n          (set Hs) \\<cong>\n         G;\n         successively (dvd) (map card Hs); card (set Hs) \\<le> card gen;\n         compl_fam id (set Hs); {\\<one>} \\<notin> set Hs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"DirProds (\\<lambda>H. G\\<lparr>carrier := H\\<rparr>) (set ?Hs) \\<cong> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DirProds (\\<lambda>H. G\\<lparr>carrier := H\\<rparr>)\n     (set (map (\\<lambda>g. generate G {g}) gs)) \\<cong>\n    G", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. DirProds (\\<lambda>H. G\\<lparr>carrier := H\\<rparr>)\n     (set (map (\\<lambda>g. generate G {g}) gs)) \\<cong>\n    G", "have gg: \"group (G\\<lparr>carrier := ?gen g\\<rparr>)\" if \"g \\<in> set gs\" for g"], ["proof (prove)\ngoal (1 subgoal):\n 1. Group.group (G\\<lparr>carrier := generate G {g}\\<rparr>)", "by (use gs that in \\<open>auto intro: subgroup.subgroup_is_group generate_is_subgroup\\<close>)"], ["proof (state)\nthis:\n  ?g2 \\<in> set gs \\<Longrightarrow>\n  Group.group (G\\<lparr>carrier := generate G {?g2}\\<rparr>)\n\ngoal (1 subgoal):\n 1. DirProds (\\<lambda>H. G\\<lparr>carrier := H\\<rparr>)\n     (set (map (\\<lambda>g. generate G {g}) gs)) \\<cong>\n    G", "then"], ["proof (chain)\npicking this:\n  ?g2 \\<in> set gs \\<Longrightarrow>\n  Group.group (G\\<lparr>carrier := generate G {?g2}\\<rparr>)", "interpret og: group \"DirProds (\\<lambda>g. G\\<lparr>carrier := ?gen g\\<rparr>) (set gs)\""], ["proof (prove)\nusing this:\n  ?g2 \\<in> set gs \\<Longrightarrow>\n  Group.group (G\\<lparr>carrier := generate G {?g2}\\<rparr>)\n\ngoal (1 subgoal):\n 1. Group.group\n     (DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n       (set gs))", "using DirProds_group_iff"], ["proof (prove)\nusing this:\n  ?g2 \\<in> set gs \\<Longrightarrow>\n  Group.group (G\\<lparr>carrier := generate G {?g2}\\<rparr>)\n  Group.group (DirProds ?G ?I) = (\\<forall>i\\<in>?I. Group.group (?G i))\n\ngoal (1 subgoal):\n 1. Group.group\n     (DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n       (set gs))", "by blast"], ["proof (state)\ngoal (1 subgoal):\n 1. DirProds (\\<lambda>H. G\\<lparr>carrier := H\\<rparr>)\n     (set (map (\\<lambda>g. generate G {g}) gs)) \\<cong>\n    G", "have \"DirProds (\\<lambda>g. G\\<lparr>carrier := ?gen g\\<rparr>) (set gs) \\<cong> DirProds (\\<lambda>H. G\\<lparr>carrier := H\\<rparr>) (set ?Hs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n     (set gs) \\<cong>\n    DirProds (\\<lambda>H. G\\<lparr>carrier := H\\<rparr>)\n     (set (map (\\<lambda>g. generate G {g}) gs))", "proof (intro DirProds_iso[of ?gen])"], ["proof (state)\ngoal (4 subgoals):\n 1. bij_betw (\\<lambda>g. generate G {g}) (set gs)\n     (set (map (\\<lambda>g. generate G {g}) gs))\n 2. \\<And>i.\n       i \\<in> set gs \\<Longrightarrow>\n       G\\<lparr>carrier := generate G {i}\\<rparr> \\<cong> G\n       \\<lparr>carrier := generate G {i}\\<rparr>\n 3. \\<And>i.\n       i \\<in> set gs \\<Longrightarrow>\n       Group.group (G\\<lparr>carrier := generate G {i}\\<rparr>)\n 4. \\<And>j.\n       j \\<in> set (map (\\<lambda>g. generate G {g}) gs) \\<Longrightarrow>\n       Group.group (G\\<lparr>carrier := j\\<rparr>)", "show \"bij_betw ?gen (set gs) (set ?Hs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (\\<lambda>g. generate G {g}) (set gs)\n     (set (map (\\<lambda>g. generate G {g}) gs))", "using \\<open>distinct ?Hs\\<close> gs(2) compl_fam_imp_generate_inj[OF gs(1, 6)]"], ["proof (prove)\nusing this:\n  cycle (map (\\<lambda>g. generate G {g}) gs)\n  cycle gs\n  inj_on (\\<lambda>g. generate G {g}) (set gs)\n\ngoal (1 subgoal):\n 1. bij_betw (\\<lambda>g. generate G {g}) (set gs)\n     (set (map (\\<lambda>g. generate G {g}) gs))", "by (simp add: bij_betw_def)"], ["proof (state)\nthis:\n  bij_betw (\\<lambda>g. generate G {g}) (set gs)\n   (set (map (\\<lambda>g. generate G {g}) gs))\n\ngoal (3 subgoals):\n 1. \\<And>i.\n       i \\<in> set gs \\<Longrightarrow>\n       G\\<lparr>carrier := generate G {i}\\<rparr> \\<cong> G\n       \\<lparr>carrier := generate G {i}\\<rparr>\n 2. \\<And>i.\n       i \\<in> set gs \\<Longrightarrow>\n       Group.group (G\\<lparr>carrier := generate G {i}\\<rparr>)\n 3. \\<And>j.\n       j \\<in> set (map (\\<lambda>g. generate G {g}) gs) \\<Longrightarrow>\n       Group.group (G\\<lparr>carrier := j\\<rparr>)", "show \"G\\<lparr>carrier := ?gen g\\<rparr> \\<cong> G\\<lparr>carrier := ?gen g\\<rparr>\" if \"g \\<in> set gs\" for g"], ["proof (prove)\ngoal (1 subgoal):\n 1. G\\<lparr>carrier := generate G {g}\\<rparr> \\<cong> G\n    \\<lparr>carrier := generate G {g}\\<rparr>", "by simp"], ["proof (state)\nthis:\n  ?g2 \\<in> set gs \\<Longrightarrow>\n  G\\<lparr>carrier := generate G {?g2}\\<rparr> \\<cong> G\n  \\<lparr>carrier := generate G {?g2}\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<in> set gs \\<Longrightarrow>\n       Group.group (G\\<lparr>carrier := generate G {i}\\<rparr>)\n 2. \\<And>j.\n       j \\<in> set (map (\\<lambda>g. generate G {g}) gs) \\<Longrightarrow>\n       Group.group (G\\<lparr>carrier := j\\<rparr>)", "show \"group (G\\<lparr>carrier := ?gen g\\<rparr>)\" if \"g \\<in> set gs\" for g"], ["proof (prove)\ngoal (1 subgoal):\n 1. Group.group (G\\<lparr>carrier := generate G {g}\\<rparr>)", "using that"], ["proof (prove)\nusing this:\n  g \\<in> set gs\n\ngoal (1 subgoal):\n 1. Group.group (G\\<lparr>carrier := generate G {g}\\<rparr>)", "by fact"], ["proof (state)\nthis:\n  ?g2 \\<in> set gs \\<Longrightarrow>\n  Group.group (G\\<lparr>carrier := generate G {?g2}\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> set (map (\\<lambda>g. generate G {g}) gs) \\<Longrightarrow>\n       Group.group (G\\<lparr>carrier := j\\<rparr>)", "show \"Group.group (G\\<lparr>carrier := H\\<rparr>)\" if \"H \\<in> set ?Hs\" for H"], ["proof (prove)\ngoal (1 subgoal):\n 1. Group.group (G\\<lparr>carrier := H\\<rparr>)", "by (use gs that in \\<open>auto intro: subgroup.subgroup_is_group generate_is_subgroup\\<close>)"], ["proof (state)\nthis:\n  ?H2 \\<in> set (map (\\<lambda>g. generate G {g}) gs) \\<Longrightarrow>\n  Group.group (G\\<lparr>carrier := ?H2\\<rparr>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n   (set gs) \\<cong>\n  DirProds (\\<lambda>H. G\\<lparr>carrier := H\\<rparr>)\n   (set (map (\\<lambda>g. generate G {g}) gs))\n\ngoal (1 subgoal):\n 1. DirProds (\\<lambda>H. G\\<lparr>carrier := H\\<rparr>)\n     (set (map (\\<lambda>g. generate G {g}) gs)) \\<cong>\n    G", "from group.iso_sym[OF og.is_group this]"], ["proof (chain)\npicking this:\n  DirProds (\\<lambda>H. G\\<lparr>carrier := H\\<rparr>)\n   (set (map (\\<lambda>g. generate G {g}) gs)) \\<cong>\n  DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>) (set gs)", "show ?thesis"], ["proof (prove)\nusing this:\n  DirProds (\\<lambda>H. G\\<lparr>carrier := H\\<rparr>)\n   (set (map (\\<lambda>g. generate G {g}) gs)) \\<cong>\n  DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>) (set gs)\n\ngoal (1 subgoal):\n 1. DirProds (\\<lambda>H. G\\<lparr>carrier := H\\<rparr>)\n     (set (map (\\<lambda>g. generate G {g}) gs)) \\<cong>\n    G", "using gs iso_trans"], ["proof (prove)\nusing this:\n  DirProds (\\<lambda>H. G\\<lparr>carrier := H\\<rparr>)\n   (set (map (\\<lambda>g. generate G {g}) gs)) \\<cong>\n  DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>) (set gs)\n  set gs \\<subseteq> carrier G\n  cycle gs\n  DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n   (set gs) \\<cong>\n  G\n  successively (dvd) (map ord gs)\n  card (set gs) \\<le> card gen\n  compl_fam (\\<lambda>g. generate G {g}) (set gs)\n  \\<one> \\<notin> set gs\n  \\<lbrakk>?G \\<cong> ?H; ?H \\<cong> ?I\\<rbrakk>\n  \\<Longrightarrow> ?G \\<cong> ?I\n\ngoal (1 subgoal):\n 1. DirProds (\\<lambda>H. G\\<lparr>carrier := H\\<rparr>)\n     (set (map (\\<lambda>g. generate G {g}) gs)) \\<cong>\n    G", "by blast"], ["proof (state)\nthis:\n  DirProds (\\<lambda>H. G\\<lparr>carrier := H\\<rparr>)\n   (set (map (\\<lambda>g. generate G {g}) gs)) \\<cong>\n  G\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  DirProds (\\<lambda>H. G\\<lparr>carrier := H\\<rparr>)\n   (set (map (\\<lambda>g. generate G {g}) gs)) \\<cong>\n  G\n\ngoal (1 subgoal):\n 1. (\\<And>Hs.\n        \\<lbrakk>\\<And>H. H \\<in> set Hs \\<Longrightarrow> subgroup H G;\n         cycle Hs;\n         DirProds (\\<lambda>H. G\\<lparr>carrier := H\\<rparr>)\n          (set Hs) \\<cong>\n         G;\n         successively (dvd) (map card Hs); card (set Hs) \\<le> card gen;\n         compl_fam id (set Hs); {\\<one>} \\<notin> set Hs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  DirProds (\\<lambda>H. G\\<lparr>carrier := H\\<rparr>)\n   (set (map (\\<lambda>g. generate G {g}) gs)) \\<cong>\n  G\n\ngoal (1 subgoal):\n 1. (\\<And>Hs.\n        \\<lbrakk>\\<And>H. H \\<in> set Hs \\<Longrightarrow> subgroup H G;\n         cycle Hs;\n         DirProds (\\<lambda>H. G\\<lparr>carrier := H\\<rparr>)\n          (set Hs) \\<cong>\n         G;\n         successively (dvd) (map card Hs); card (set Hs) \\<le> card gen;\n         compl_fam id (set Hs); {\\<one>} \\<notin> set Hs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"successively (dvd) (map card ?Hs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. successively (dvd) (map card (map (\\<lambda>g. generate G {g}) gs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. successively (dvd) (map card (map (\\<lambda>g. generate G {g}) gs))", "have \"card (generate G {g}) = ord g\" if \"g \\<in> set gs\" for g"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (generate G {g}) = ord g", "using generate_pow_card that gs(1)"], ["proof (prove)\nusing this:\n  ?a \\<in> carrier G \\<Longrightarrow> ord ?a = card (generate G {?a})\n  g \\<in> set gs\n  set gs \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. card (generate G {g}) = ord g", "by auto"], ["proof (state)\nthis:\n  ?g2 \\<in> set gs \\<Longrightarrow> card (generate G {?g2}) = ord ?g2\n\ngoal (1 subgoal):\n 1. successively (dvd) (map card (map (\\<lambda>g. generate G {g}) gs))", "hence \"map card ?Hs = map ord gs\""], ["proof (prove)\nusing this:\n  ?g2 \\<in> set gs \\<Longrightarrow> card (generate G {?g2}) = ord ?g2\n\ngoal (1 subgoal):\n 1. map card (map (\\<lambda>g. generate G {g}) gs) = map ord gs", "by simp"], ["proof (state)\nthis:\n  map card (map (\\<lambda>g. generate G {g}) gs) = map ord gs\n\ngoal (1 subgoal):\n 1. successively (dvd) (map card (map (\\<lambda>g. generate G {g}) gs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  map card (map (\\<lambda>g. generate G {g}) gs) = map ord gs\n\ngoal (1 subgoal):\n 1. successively (dvd) (map card (map (\\<lambda>g. generate G {g}) gs))", "using gs(4)"], ["proof (prove)\nusing this:\n  map card (map (\\<lambda>g. generate G {g}) gs) = map ord gs\n  successively (dvd) (map ord gs)\n\ngoal (1 subgoal):\n 1. successively (dvd) (map card (map (\\<lambda>g. generate G {g}) gs))", "by argo"], ["proof (state)\nthis:\n  successively (dvd) (map card (map (\\<lambda>g. generate G {g}) gs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  successively (dvd) (map card (map (\\<lambda>g. generate G {g}) gs))\n\ngoal (1 subgoal):\n 1. (\\<And>Hs.\n        \\<lbrakk>\\<And>H. H \\<in> set Hs \\<Longrightarrow> subgroup H G;\n         cycle Hs;\n         DirProds (\\<lambda>H. G\\<lparr>carrier := H\\<rparr>)\n          (set Hs) \\<cong>\n         G;\n         successively (dvd) (map card Hs); card (set Hs) \\<le> card gen;\n         compl_fam id (set Hs); {\\<one>} \\<notin> set Hs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  successively (dvd) (map card (map (\\<lambda>g. generate G {g}) gs))\n\ngoal (1 subgoal):\n 1. (\\<And>Hs.\n        \\<lbrakk>\\<And>H. H \\<in> set Hs \\<Longrightarrow> subgroup H G;\n         cycle Hs;\n         DirProds (\\<lambda>H. G\\<lparr>carrier := H\\<rparr>)\n          (set Hs) \\<cong>\n         G;\n         successively (dvd) (map card Hs); card (set Hs) \\<le> card gen;\n         compl_fam id (set Hs); {\\<one>} \\<notin> set Hs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"card (set ?Hs) \\<le> card gen\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set (map (\\<lambda>g. generate G {g}) gs)) \\<le> card gen", "using gs"], ["proof (prove)\nusing this:\n  set gs \\<subseteq> carrier G\n  cycle gs\n  DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n   (set gs) \\<cong>\n  G\n  successively (dvd) (map ord gs)\n  card (set gs) \\<le> card gen\n  compl_fam (\\<lambda>g. generate G {g}) (set gs)\n  \\<one> \\<notin> set gs\n\ngoal (1 subgoal):\n 1. card (set (map (\\<lambda>g. generate G {g}) gs)) \\<le> card gen", "by (metis \\<open>distinct ?Hs\\<close> distinct_card length_map)"], ["proof (state)\nthis:\n  card (set (map (\\<lambda>g. generate G {g}) gs)) \\<le> card gen\n\ngoal (1 subgoal):\n 1. (\\<And>Hs.\n        \\<lbrakk>\\<And>H. H \\<in> set Hs \\<Longrightarrow> subgroup H G;\n         cycle Hs;\n         DirProds (\\<lambda>H. G\\<lparr>carrier := H\\<rparr>)\n          (set Hs) \\<cong>\n         G;\n         successively (dvd) (map card Hs); card (set Hs) \\<le> card gen;\n         compl_fam id (set Hs); {\\<one>} \\<notin> set Hs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  card (set (map (\\<lambda>g. generate G {g}) gs)) \\<le> card gen\n\ngoal (1 subgoal):\n 1. (\\<And>Hs.\n        \\<lbrakk>\\<And>H. H \\<in> set Hs \\<Longrightarrow> subgroup H G;\n         cycle Hs;\n         DirProds (\\<lambda>H. G\\<lparr>carrier := H\\<rparr>)\n          (set Hs) \\<cong>\n         G;\n         successively (dvd) (map card Hs); card (set Hs) \\<le> card gen;\n         compl_fam id (set Hs); {\\<one>} \\<notin> set Hs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"compl_fam id (set ?Hs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compl_fam id (set (map (\\<lambda>g. generate G {g}) gs))", "using compl_fam_cong[OF _ compl_fam_imp_generate_inj[OF gs(1, 6)], of id]"], ["proof (prove)\nusing this:\n  compl_fam (id \\<circ> (\\<lambda>g. generate G {g}))\n   (set gs) \\<Longrightarrow>\n  compl_fam id ((\\<lambda>g. generate G {g}) ` set gs)\n\ngoal (1 subgoal):\n 1. compl_fam id (set (map (\\<lambda>g. generate G {g}) gs))", "using gs"], ["proof (prove)\nusing this:\n  compl_fam (id \\<circ> (\\<lambda>g. generate G {g}))\n   (set gs) \\<Longrightarrow>\n  compl_fam id ((\\<lambda>g. generate G {g}) ` set gs)\n  set gs \\<subseteq> carrier G\n  cycle gs\n  DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n   (set gs) \\<cong>\n  G\n  successively (dvd) (map ord gs)\n  card (set gs) \\<le> card gen\n  compl_fam (\\<lambda>g. generate G {g}) (set gs)\n  \\<one> \\<notin> set gs\n\ngoal (1 subgoal):\n 1. compl_fam id (set (map (\\<lambda>g. generate G {g}) gs))", "by auto"], ["proof (state)\nthis:\n  compl_fam id (set (map (\\<lambda>g. generate G {g}) gs))\n\ngoal (1 subgoal):\n 1. (\\<And>Hs.\n        \\<lbrakk>\\<And>H. H \\<in> set Hs \\<Longrightarrow> subgroup H G;\n         cycle Hs;\n         DirProds (\\<lambda>H. G\\<lparr>carrier := H\\<rparr>)\n          (set Hs) \\<cong>\n         G;\n         successively (dvd) (map card Hs); card (set Hs) \\<le> card gen;\n         compl_fam id (set Hs); {\\<one>} \\<notin> set Hs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  compl_fam id (set (map (\\<lambda>g. generate G {g}) gs))\n\ngoal (1 subgoal):\n 1. (\\<And>Hs.\n        \\<lbrakk>\\<And>H. H \\<in> set Hs \\<Longrightarrow> subgroup H G;\n         cycle Hs;\n         DirProds (\\<lambda>H. G\\<lparr>carrier := H\\<rparr>)\n          (set Hs) \\<cong>\n         G;\n         successively (dvd) (map card Hs); card (set Hs) \\<le> card gen;\n         compl_fam id (set Hs); {\\<one>} \\<notin> set Hs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"{\\<one>} \\<notin> set ?Hs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<one>} \\<notin> set (map (\\<lambda>g. generate G {g}) gs)", "using generate_singleton_one gs"], ["proof (prove)\nusing this:\n  generate G {?a} = {\\<one>} \\<Longrightarrow> ?a = \\<one>\n  set gs \\<subseteq> carrier G\n  cycle gs\n  DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n   (set gs) \\<cong>\n  G\n  successively (dvd) (map ord gs)\n  card (set gs) \\<le> card gen\n  compl_fam (\\<lambda>g. generate G {g}) (set gs)\n  \\<one> \\<notin> set gs\n\ngoal (1 subgoal):\n 1. {\\<one>} \\<notin> set (map (\\<lambda>g. generate G {g}) gs)", "by auto"], ["proof (state)\nthis:\n  {\\<one>} \\<notin> set (map (\\<lambda>g. generate G {g}) gs)\n\ngoal (1 subgoal):\n 1. (\\<And>Hs.\n        \\<lbrakk>\\<And>H. H \\<in> set Hs \\<Longrightarrow> subgroup H G;\n         cycle Hs;\n         DirProds (\\<lambda>H. G\\<lparr>carrier := H\\<rparr>)\n          (set Hs) \\<cong>\n         G;\n         successively (dvd) (map card Hs); card (set Hs) \\<le> card gen;\n         compl_fam id (set Hs); {\\<one>} \\<notin> set Hs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  ?H2 \\<in> set (map (\\<lambda>g. generate G {g}) gs) \\<Longrightarrow>\n  subgroup ?H2 G\n  cycle (map (\\<lambda>g. generate G {g}) gs)\n  DirProds (\\<lambda>H. G\\<lparr>carrier := H\\<rparr>)\n   (set (map (\\<lambda>g. generate G {g}) gs)) \\<cong>\n  G\n  successively (dvd) (map card (map (\\<lambda>g. generate G {g}) gs))\n  card (set (map (\\<lambda>g. generate G {g}) gs)) \\<le> card gen\n  compl_fam id (set (map (\\<lambda>g. generate G {g}) gs))\n  {\\<one>} \\<notin> set (map (\\<lambda>g. generate G {g}) gs)", "show ?thesis"], ["proof (prove)\nusing this:\n  ?H2 \\<in> set (map (\\<lambda>g. generate G {g}) gs) \\<Longrightarrow>\n  subgroup ?H2 G\n  cycle (map (\\<lambda>g. generate G {g}) gs)\n  DirProds (\\<lambda>H. G\\<lparr>carrier := H\\<rparr>)\n   (set (map (\\<lambda>g. generate G {g}) gs)) \\<cong>\n  G\n  successively (dvd) (map card (map (\\<lambda>g. generate G {g}) gs))\n  card (set (map (\\<lambda>g. generate G {g}) gs)) \\<le> card gen\n  compl_fam id (set (map (\\<lambda>g. generate G {g}) gs))\n  {\\<one>} \\<notin> set (map (\\<lambda>g. generate G {g}) gs)\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  ?H2 \\<in> set (map (\\<lambda>g. generate G {g}) gs) \\<Longrightarrow>\n  subgroup ?H2 G\n  cycle (map (\\<lambda>g. generate G {g}) gs)\n  DirProds (\\<lambda>H. G\\<lparr>carrier := H\\<rparr>)\n   (set (map (\\<lambda>g. generate G {g}) gs)) \\<cong>\n  G\n  successively (dvd) (map card (map (\\<lambda>g. generate G {g}) gs))\n  card (set (map (\\<lambda>g. generate G {g}) gs)) \\<le> card gen\n  compl_fam id (set (map (\\<lambda>g. generate G {g}) gs))\n  {\\<one>} \\<notin> set (map (\\<lambda>g. generate G {g}) gs)\n  \\<lbrakk>\\<And>H. H \\<in> set ?Hs2 \\<Longrightarrow> subgroup H G;\n   cycle ?Hs2;\n   DirProds (\\<lambda>H. G\\<lparr>carrier := H\\<rparr>) (set ?Hs2) \\<cong>\n   G;\n   successively (dvd) (map card ?Hs2); card (set ?Hs2) \\<le> card gen;\n   compl_fam id (set ?Hs2); {\\<one>} \\<notin> set ?Hs2\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Here, the invariant factor decomposition in its classical form.\\<close>"], ["", "corollary (in fin_gen_comm_group) invariant_factor_decomposition_Zn:\n  obtains ns where\n    \"DirProds (\\<lambda>n. Z (ns!n)) {..<length ns} \\<cong> G\" \"successively (dvd) ns\" \"length ns \\<le> card gen\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G;\n         successively (dvd) ns; length ns \\<le> card gen\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G;\n         successively (dvd) ns; length ns \\<le> card gen\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from invariant_factor_decomposition_dirprod"], ["proof (chain)\npicking this:\n  (\\<And>gs.\n      \\<lbrakk>set gs \\<subseteq> carrier G; cycle gs;\n       DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n        (set gs) \\<cong>\n       G;\n       successively (dvd) (map ord gs); card (set gs) \\<le> card gen;\n       compl_fam (\\<lambda>g. generate G {g}) (set gs);\n       \\<one> \\<notin> set gs\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain gs where\n      gs: \"set gs \\<subseteq> carrier G\" \"distinct gs\"\n          \"DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>) (set gs) \\<cong> G\"\n          \"successively (dvd) (map ord gs)\" \"card (set gs) \\<le> card gen\"\n          \"compl_fam (\\<lambda>g. generate G {g}) (set gs)\" \"\\<one> \\<notin> set gs\""], ["proof (prove)\nusing this:\n  (\\<And>gs.\n      \\<lbrakk>set gs \\<subseteq> carrier G; cycle gs;\n       DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n        (set gs) \\<cong>\n       G;\n       successively (dvd) (map ord gs); card (set gs) \\<le> card gen;\n       compl_fam (\\<lambda>g. generate G {g}) (set gs);\n       \\<one> \\<notin> set gs\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>gs.\n        \\<lbrakk>set gs \\<subseteq> carrier G; cycle gs;\n         DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n          (set gs) \\<cong>\n         G;\n         successively (dvd) (map ord gs); card (set gs) \\<le> card gen;\n         compl_fam (\\<lambda>g. generate G {g}) (set gs);\n         \\<one> \\<notin> set gs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  set gs \\<subseteq> carrier G\n  cycle gs\n  DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n   (set gs) \\<cong>\n  G\n  successively (dvd) (map ord gs)\n  card (set gs) \\<le> card gen\n  compl_fam (\\<lambda>g. generate G {g}) (set gs)\n  \\<one> \\<notin> set gs\n\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G;\n         successively (dvd) ns; length ns \\<le> card gen\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?DP = \"DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>) (set gs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G;\n         successively (dvd) ns; length ns \\<le> card gen\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<exists>ns. DirProds (\\<lambda>n. Z (ns!n)) {..<length ns} \\<cong> G\n           \\<and> successively (dvd) ns \\<and> length ns \\<le> card gen\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G \\<and>\n       successively (dvd) ns \\<and> length ns \\<le> card gen", "proof (cases gs, rule)"], ["proof (state)\ngoal (2 subgoals):\n 1. gs = [] \\<Longrightarrow>\n    DirProds (\\<lambda>n. Z (?ns1 ! n)) {..<length ?ns1} \\<cong> G \\<and>\n    successively (dvd) ?ns1 \\<and> length ?ns1 \\<le> card gen\n 2. \\<And>a list.\n       gs = a # list \\<Longrightarrow>\n       \\<exists>ns.\n          DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G \\<and>\n          successively (dvd) ns \\<and> length ns \\<le> card gen", "case Nil"], ["proof (state)\nthis:\n  gs = []\n\ngoal (2 subgoals):\n 1. gs = [] \\<Longrightarrow>\n    DirProds (\\<lambda>n. Z (?ns1 ! n)) {..<length ?ns1} \\<cong> G \\<and>\n    successively (dvd) ?ns1 \\<and> length ?ns1 \\<le> card gen\n 2. \\<And>a list.\n       gs = a # list \\<Longrightarrow>\n       \\<exists>ns.\n          DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G \\<and>\n          successively (dvd) ns \\<and> length ns \\<le> card gen", "from gs(3) Nil"], ["proof (chain)\npicking this:\n  DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n   (set gs) \\<cong>\n  G\n  gs = []", "have co: \"carrier ?DP = {\\<one>\\<^bsub>?DP\\<^esub>}\""], ["proof (prove)\nusing this:\n  DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n   (set gs) \\<cong>\n  G\n  gs = []\n\ngoal (1 subgoal):\n 1. carrier\n     (DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n       (set gs)) =\n    {\\<one>\\<^bsub>DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>) (set gs)\\<^esub>}", "unfolding DirProds_def"], ["proof (prove)\nusing this:\n  \\<lparr>carrier =\n            Pi\\<^sub>E (set gs)\n             (carrier \\<circ>\n              (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)),\n     monoid.mult =\n       \\<lambda>x y.\n          \\<lambda>i\\<in>set gs.\n             x i \\<otimes>\\<^bsub>G\\<lparr>carrier := generate G {i}\\<rparr>\\<^esub>\n             y i,\n     one =\n       \\<lambda>i\\<in>set gs.\n          \\<one>\\<^bsub>G\\<lparr>carrier := generate G {i}\\<rparr>\\<^esub>\\<rparr> \\<cong>\n  G\n  gs = []\n\ngoal (1 subgoal):\n 1. carrier\n     \\<lparr>carrier =\n               Pi\\<^sub>E (set gs)\n                (carrier \\<circ>\n                 (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)),\n        monoid.mult =\n          \\<lambda>x y.\n             \\<lambda>i\\<in>set gs.\n                x i \\<otimes>\\<^bsub>G\\<lparr>carrier := generate G {i}\\<rparr>\\<^esub>\n                y i,\n        one =\n          \\<lambda>i\\<in>set gs.\n             \\<one>\\<^bsub>G\\<lparr>carrier := generate G {i}\\<rparr>\\<^esub>\\<rparr> =\n    {\\<one>\\<^bsub>\\<lparr>carrier = Pi\\<^sub>E (set gs) (carrier \\<circ> (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)), monoid.mult = \\<lambda>x y. \\<lambda>i\\<in>set gs. x i \\<otimes>\\<^bsub>G\\<lparr>carrier := generate G {i}\\<rparr>\\<^esub> y i, one = \\<lambda>i\\<in>set gs. \\<one>\\<^bsub>G\\<lparr>carrier := generate G {i}\\<rparr>\\<^esub>\\<rparr>\\<^esub>}", "by auto"], ["proof (state)\nthis:\n  carrier\n   (DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n     (set gs)) =\n  {\\<one>\\<^bsub>DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>) (set gs)\\<^esub>}\n\ngoal (2 subgoals):\n 1. gs = [] \\<Longrightarrow>\n    DirProds (\\<lambda>n. Z (?ns1 ! n)) {..<length ?ns1} \\<cong> G \\<and>\n    successively (dvd) ?ns1 \\<and> length ?ns1 \\<le> card gen\n 2. \\<And>a list.\n       gs = a # list \\<Longrightarrow>\n       \\<exists>ns.\n          DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G \\<and>\n          successively (dvd) ns \\<and> length ns \\<le> card gen", "let ?ns = \"[]\""], ["proof (state)\ngoal (2 subgoals):\n 1. gs = [] \\<Longrightarrow>\n    DirProds (\\<lambda>n. Z (?ns1 ! n)) {..<length ?ns1} \\<cong> G \\<and>\n    successively (dvd) ?ns1 \\<and> length ?ns1 \\<le> card gen\n 2. \\<And>a list.\n       gs = a # list \\<Longrightarrow>\n       \\<exists>ns.\n          DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G \\<and>\n          successively (dvd) ns \\<and> length ns \\<le> card gen", "have \"DirProds (\\<lambda>n. Z ([] ! n)) {} \\<cong> ?DP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DirProds (\\<lambda>n. Z ([] ! n)) {} \\<cong>\n    DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n     (set gs)", "proof(intro triv_iso DirProds_is_group)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>i. i \\<in> {} \\<Longrightarrow> Group.group (Z ([] ! i))\n 2. \\<And>i.\n       i \\<in> set gs \\<Longrightarrow>\n       Group.group (G\\<lparr>carrier := generate G {i}\\<rparr>)\n 3. carrier (DirProds (\\<lambda>n. Z ([] ! n)) {}) =\n    {\\<one>\\<^bsub>DirProds (\\<lambda>n. Z ([] ! n)) {}\\<^esub>}\n 4. carrier\n     (DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n       (set gs)) =\n    {\\<one>\\<^bsub>DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>) (set gs)\\<^esub>}", "show \"carrier (DirProds (\\<lambda>n. Z ([] ! n)) {}) = {\\<one>\\<^bsub>DirProds (\\<lambda>n. Z ([] ! n)) {}\\<^esub>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. carrier (DirProds (\\<lambda>n. Z ([] ! n)) {}) =\n    {\\<one>\\<^bsub>DirProds (\\<lambda>n. Z ([] ! n)) {}\\<^esub>}", "using DirProds_empty"], ["proof (prove)\nusing this:\n  carrier (DirProds ?f {}) = {\\<one>\\<^bsub>DirProds ?f {}\\<^esub>}\n\ngoal (1 subgoal):\n 1. carrier (DirProds (\\<lambda>n. Z ([] ! n)) {}) =\n    {\\<one>\\<^bsub>DirProds (\\<lambda>n. Z ([] ! n)) {}\\<^esub>}", "by blast"], ["proof (state)\nthis:\n  carrier (DirProds (\\<lambda>n. Z ([] ! n)) {}) =\n  {\\<one>\\<^bsub>DirProds (\\<lambda>n. Z ([] ! n)) {}\\<^esub>}\n\ngoal (3 subgoals):\n 1. \\<And>i. i \\<in> {} \\<Longrightarrow> Group.group (Z ([] ! i))\n 2. \\<And>i.\n       i \\<in> set gs \\<Longrightarrow>\n       Group.group (G\\<lparr>carrier := generate G {i}\\<rparr>)\n 3. carrier\n     (DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n       (set gs)) =\n    {\\<one>\\<^bsub>DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>) (set gs)\\<^esub>}", "qed (use co group_integer_mod_group Nil in auto)"], ["proof (state)\nthis:\n  DirProds (\\<lambda>n. Z ([] ! n)) {} \\<cong>\n  DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>) (set gs)\n\ngoal (2 subgoals):\n 1. gs = [] \\<Longrightarrow>\n    DirProds (\\<lambda>n. Z (?ns1 ! n)) {..<length ?ns1} \\<cong> G \\<and>\n    successively (dvd) ?ns1 \\<and> length ?ns1 \\<le> card gen\n 2. \\<And>a list.\n       gs = a # list \\<Longrightarrow>\n       \\<exists>ns.\n          DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G \\<and>\n          successively (dvd) ns \\<and> length ns \\<le> card gen", "from that[of ?ns] gs co iso_trans[OF this gs(3)]"], ["proof (chain)\npicking this:\n  \\<lbrakk>DirProds (\\<lambda>n. Z ([] ! n)) {..<length []} \\<cong> G;\n   successively (dvd) []; length [] \\<le> card gen\\<rbrakk>\n  \\<Longrightarrow> thesis\n  set gs \\<subseteq> carrier G\n  cycle gs\n  DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n   (set gs) \\<cong>\n  G\n  successively (dvd) (map ord gs)\n  card (set gs) \\<le> card gen\n  compl_fam (\\<lambda>g. generate G {g}) (set gs)\n  \\<one> \\<notin> set gs\n  carrier\n   (DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n     (set gs)) =\n  {\\<one>\\<^bsub>DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>) (set gs)\\<^esub>}\n  DirProds (\\<lambda>n. Z ([] ! n)) {} \\<cong> G", "show \"DirProds (\\<lambda>n. Z (?ns ! n)) {..<length ?ns} \\<cong> G\n        \\<and> successively (dvd) ?ns \\<and> length ?ns \\<le> card gen\""], ["proof (prove)\nusing this:\n  \\<lbrakk>DirProds (\\<lambda>n. Z ([] ! n)) {..<length []} \\<cong> G;\n   successively (dvd) []; length [] \\<le> card gen\\<rbrakk>\n  \\<Longrightarrow> thesis\n  set gs \\<subseteq> carrier G\n  cycle gs\n  DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n   (set gs) \\<cong>\n  G\n  successively (dvd) (map ord gs)\n  card (set gs) \\<le> card gen\n  compl_fam (\\<lambda>g. generate G {g}) (set gs)\n  \\<one> \\<notin> set gs\n  carrier\n   (DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n     (set gs)) =\n  {\\<one>\\<^bsub>DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>) (set gs)\\<^esub>}\n  DirProds (\\<lambda>n. Z ([] ! n)) {} \\<cong> G\n\ngoal (1 subgoal):\n 1. DirProds (\\<lambda>n. Z ([] ! n)) {..<length []} \\<cong> G \\<and>\n    successively (dvd) [] \\<and> length [] \\<le> card gen", "unfolding lessThan_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>DirProds (\\<lambda>n. Z ([] ! n)) {x. x < length []} \\<cong> G;\n   successively (dvd) []; length [] \\<le> card gen\\<rbrakk>\n  \\<Longrightarrow> thesis\n  set gs \\<subseteq> carrier G\n  cycle gs\n  DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n   (set gs) \\<cong>\n  G\n  successively (dvd) (map ord gs)\n  card (set gs) \\<le> card gen\n  compl_fam (\\<lambda>g. generate G {g}) (set gs)\n  \\<one> \\<notin> set gs\n  carrier\n   (DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n     (set gs)) =\n  {\\<one>\\<^bsub>DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>) (set gs)\\<^esub>}\n  DirProds (\\<lambda>n. Z ([] ! n)) {} \\<cong> G\n\ngoal (1 subgoal):\n 1. DirProds (\\<lambda>n. Z ([] ! n)) {x. x < length []} \\<cong> G \\<and>\n    successively (dvd) [] \\<and> length [] \\<le> card gen", "by simp"], ["proof (state)\nthis:\n  DirProds (\\<lambda>n. Z ([] ! n)) {..<length []} \\<cong> G \\<and>\n  successively (dvd) [] \\<and> length [] \\<le> card gen\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       gs = a # list \\<Longrightarrow>\n       \\<exists>ns.\n          DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G \\<and>\n          successively (dvd) ns \\<and> length ns \\<le> card gen", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       gs = a # list \\<Longrightarrow>\n       \\<exists>ns.\n          DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G \\<and>\n          successively (dvd) ns \\<and> length ns \\<le> card gen", "case c: (Cons a list)"], ["proof (state)\nthis:\n  gs = a # list\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       gs = a # list \\<Longrightarrow>\n       \\<exists>ns.\n          DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G \\<and>\n          successively (dvd) ns \\<and> length ns \\<le> card gen", "let ?l = \"map ord gs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       gs = a # list \\<Longrightarrow>\n       \\<exists>ns.\n          DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G \\<and>\n          successively (dvd) ns \\<and> length ns \\<le> card gen", "from c"], ["proof (chain)\npicking this:\n  gs = a # list", "have l: \"length ?l > 0\""], ["proof (prove)\nusing this:\n  gs = a # list\n\ngoal (1 subgoal):\n 1. 0 < length (map ord gs)", "by auto"], ["proof (state)\nthis:\n  0 < length (map ord gs)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       gs = a # list \\<Longrightarrow>\n       \\<exists>ns.\n          DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G \\<and>\n          successively (dvd) ns \\<and> length ns \\<le> card gen", "have \"DirProds (\\<lambda>n. Z (?l ! n)) {..<length ?l} \\<cong> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DirProds (\\<lambda>n. Z (map ord gs ! n))\n     {..<length (map ord gs)} \\<cong>\n    G", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. DirProds (\\<lambda>n. Z (map ord gs ! n))\n     {..<length (map ord gs)} \\<cong>\n    G", "have \"DirProds (\\<lambda>n. Z (?l ! n)) {..<length ?l} \\<cong> ?DP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DirProds (\\<lambda>n. Z (map ord gs ! n))\n     {..<length (map ord gs)} \\<cong>\n    DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n     (set gs)", "proof(intro DirProds_iso[where ?f = \"\\<lambda>n. gs!n\"])"], ["proof (state)\ngoal (4 subgoals):\n 1. bij_betw ((!) gs) {..<length (map ord gs)} (set gs)\n 2. \\<And>i.\n       i \\<in> {..<length (map ord gs)} \\<Longrightarrow>\n       Z (map ord gs ! i) \\<cong> G\n       \\<lparr>carrier := generate G {gs ! i}\\<rparr>\n 3. \\<And>i.\n       i \\<in> {..<length (map ord gs)} \\<Longrightarrow>\n       Group.group (Z (map ord gs ! i))\n 4. \\<And>j.\n       j \\<in> set gs \\<Longrightarrow>\n       Group.group (G\\<lparr>carrier := generate G {j}\\<rparr>)", "show \"bij_betw ((!) gs) {..<length ?l} (set gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw ((!) gs) {..<length (map ord gs)} (set gs)", "using gs"], ["proof (prove)\nusing this:\n  set gs \\<subseteq> carrier G\n  cycle gs\n  DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n   (set gs) \\<cong>\n  G\n  successively (dvd) (map ord gs)\n  card (set gs) \\<le> card gen\n  compl_fam (\\<lambda>g. generate G {g}) (set gs)\n  \\<one> \\<notin> set gs\n\ngoal (1 subgoal):\n 1. bij_betw ((!) gs) {..<length (map ord gs)} (set gs)", "by (simp add: bij_betw_nth)"], ["proof (state)\nthis:\n  bij_betw ((!) gs) {..<length (map ord gs)} (set gs)\n\ngoal (3 subgoals):\n 1. \\<And>i.\n       i \\<in> {..<length (map ord gs)} \\<Longrightarrow>\n       Z (map ord gs ! i) \\<cong> G\n       \\<lparr>carrier := generate G {gs ! i}\\<rparr>\n 2. \\<And>i.\n       i \\<in> {..<length (map ord gs)} \\<Longrightarrow>\n       Group.group (Z (map ord gs ! i))\n 3. \\<And>j.\n       j \\<in> set gs \\<Longrightarrow>\n       Group.group (G\\<lparr>carrier := generate G {j}\\<rparr>)", "show \"Z (map ord gs ! i) \\<cong> G\\<lparr>carrier := generate G {gs ! i}\\<rparr>\" if \"i \\<in> {..<length ?l}\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. Z (map ord gs ! i) \\<cong> G\n    \\<lparr>carrier := generate G {gs ! i}\\<rparr>", "proof(rule group.iso_sym[OF subgroup.subgroup_is_group[OF generate_is_subgroup]\n                   cyclic_group.Zn_iso[OF cyclic_groupI2]])"], ["proof (state)\ngoal (4 subgoals):\n 1. {gs ! i} \\<subseteq> carrier G\n 2. Group.group G\n 3. gs ! i \\<in> carrier G\n 4. order (G\\<lparr>carrier := generate G {gs ! i}\\<rparr>) = map ord gs ! i", "show \"order (G\\<lparr>carrier := generate G {gs ! i}\\<rparr>) = map ord gs ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order (G\\<lparr>carrier := generate G {gs ! i}\\<rparr>) = map ord gs ! i", "unfolding order_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (carrier (G\\<lparr>carrier := generate G {gs ! i}\\<rparr>)) =\n    map ord gs ! i", "using that generate_pow_card[of \"gs ! i\"] gs(1)"], ["proof (prove)\nusing this:\n  i \\<in> {..<length (map ord gs)}\n  gs ! i \\<in> carrier G \\<Longrightarrow>\n  ord (gs ! i) = card (generate G {gs ! i})\n  set gs \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. card (carrier (G\\<lparr>carrier := generate G {gs ! i}\\<rparr>)) =\n    map ord gs ! i", "by force"], ["proof (state)\nthis:\n  order (G\\<lparr>carrier := generate G {gs ! i}\\<rparr>) = map ord gs ! i\n\ngoal (3 subgoals):\n 1. {gs ! i} \\<subseteq> carrier G\n 2. Group.group G\n 3. gs ! i \\<in> carrier G", "qed (use gs(1) that in auto)"], ["proof (state)\nthis:\n  ?i2 \\<in> {..<length (map ord gs)} \\<Longrightarrow>\n  Z (map ord gs ! ?i2) \\<cong> G\n  \\<lparr>carrier := generate G {gs ! ?i2}\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<in> {..<length (map ord gs)} \\<Longrightarrow>\n       Group.group (Z (map ord gs ! i))\n 2. \\<And>j.\n       j \\<in> set gs \\<Longrightarrow>\n       Group.group (G\\<lparr>carrier := generate G {j}\\<rparr>)", "show \"Group.group (Z (map ord gs ! i))\" if \"i \\<in> {..<length (map ord gs)}\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. Group.group (Z (map ord gs ! i))", "using group_integer_mod_group"], ["proof (prove)\nusing this:\n  Group.group (Z ?n)\n\ngoal (1 subgoal):\n 1. Group.group (Z (map ord gs ! i))", "by blast"], ["proof (state)\nthis:\n  ?i2 \\<in> {..<length (map ord gs)} \\<Longrightarrow>\n  Group.group (Z (map ord gs ! ?i2))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> set gs \\<Longrightarrow>\n       Group.group (G\\<lparr>carrier := generate G {j}\\<rparr>)", "show \"Group.group (G\\<lparr>carrier := generate G {g}\\<rparr>)\" if \"g \\<in> set gs\" for g"], ["proof (prove)\ngoal (1 subgoal):\n 1. Group.group (G\\<lparr>carrier := generate G {g}\\<rparr>)", "using that gs(1) subgroup.subgroup_is_group[OF generate_is_subgroup]"], ["proof (prove)\nusing this:\n  g \\<in> set gs\n  set gs \\<subseteq> carrier G\n  \\<lbrakk>?H1 \\<subseteq> carrier G; Group.group G\\<rbrakk>\n  \\<Longrightarrow> Group.group (G\\<lparr>carrier := generate G ?H1\\<rparr>)\n\ngoal (1 subgoal):\n 1. Group.group (G\\<lparr>carrier := generate G {g}\\<rparr>)", "by auto"], ["proof (state)\nthis:\n  ?g2 \\<in> set gs \\<Longrightarrow>\n  Group.group (G\\<lparr>carrier := generate G {?g2}\\<rparr>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  DirProds (\\<lambda>n. Z (map ord gs ! n)) {..<length (map ord gs)} \\<cong>\n  DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>) (set gs)\n\ngoal (1 subgoal):\n 1. DirProds (\\<lambda>n. Z (map ord gs ! n))\n     {..<length (map ord gs)} \\<cong>\n    G", "from iso_trans[OF this gs(3)]"], ["proof (chain)\npicking this:\n  DirProds (\\<lambda>n. Z (map ord gs ! n)) {..<length (map ord gs)} \\<cong>\n  G", "show ?thesis"], ["proof (prove)\nusing this:\n  DirProds (\\<lambda>n. Z (map ord gs ! n)) {..<length (map ord gs)} \\<cong>\n  G\n\ngoal (1 subgoal):\n 1. DirProds (\\<lambda>n. Z (map ord gs ! n))\n     {..<length (map ord gs)} \\<cong>\n    G", "."], ["proof (state)\nthis:\n  DirProds (\\<lambda>n. Z (map ord gs ! n)) {..<length (map ord gs)} \\<cong>\n  G\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  DirProds (\\<lambda>n. Z (map ord gs ! n)) {..<length (map ord gs)} \\<cong>\n  G\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       gs = a # list \\<Longrightarrow>\n       \\<exists>ns.\n          DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G \\<and>\n          successively (dvd) ns \\<and> length ns \\<le> card gen", "moreover"], ["proof (state)\nthis:\n  DirProds (\\<lambda>n. Z (map ord gs ! n)) {..<length (map ord gs)} \\<cong>\n  G\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       gs = a # list \\<Longrightarrow>\n       \\<exists>ns.\n          DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G \\<and>\n          successively (dvd) ns \\<and> length ns \\<le> card gen", "have \"length ?l \\<le> card gen\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map ord gs) \\<le> card gen", "using gs"], ["proof (prove)\nusing this:\n  set gs \\<subseteq> carrier G\n  cycle gs\n  DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n   (set gs) \\<cong>\n  G\n  successively (dvd) (map ord gs)\n  card (set gs) \\<le> card gen\n  compl_fam (\\<lambda>g. generate G {g}) (set gs)\n  \\<one> \\<notin> set gs\n\ngoal (1 subgoal):\n 1. length (map ord gs) \\<le> card gen", "by (metis distinct_card length_map)"], ["proof (state)\nthis:\n  length (map ord gs) \\<le> card gen\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       gs = a # list \\<Longrightarrow>\n       \\<exists>ns.\n          DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G \\<and>\n          successively (dvd) ns \\<and> length ns \\<le> card gen", "ultimately"], ["proof (chain)\npicking this:\n  DirProds (\\<lambda>n. Z (map ord gs ! n)) {..<length (map ord gs)} \\<cong>\n  G\n  length (map ord gs) \\<le> card gen", "show ?thesis"], ["proof (prove)\nusing this:\n  DirProds (\\<lambda>n. Z (map ord gs ! n)) {..<length (map ord gs)} \\<cong>\n  G\n  length (map ord gs) \\<le> card gen\n\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G \\<and>\n       successively (dvd) ns \\<and> length ns \\<le> card gen", "using gs c"], ["proof (prove)\nusing this:\n  DirProds (\\<lambda>n. Z (map ord gs ! n)) {..<length (map ord gs)} \\<cong>\n  G\n  length (map ord gs) \\<le> card gen\n  set gs \\<subseteq> carrier G\n  cycle gs\n  DirProds (\\<lambda>g. G\\<lparr>carrier := generate G {g}\\<rparr>)\n   (set gs) \\<cong>\n  G\n  successively (dvd) (map ord gs)\n  card (set gs) \\<le> card gen\n  compl_fam (\\<lambda>g. generate G {g}) (set gs)\n  \\<one> \\<notin> set gs\n  gs = a # list\n\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G \\<and>\n       successively (dvd) ns \\<and> length ns \\<le> card gen", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ns.\n     DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G \\<and>\n     successively (dvd) ns \\<and> length ns \\<le> card gen\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ns.\n     DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G \\<and>\n     successively (dvd) ns \\<and> length ns \\<le> card gen\n\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G;\n         successively (dvd) ns; length ns \\<le> card gen\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>ns.\n     DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G \\<and>\n     successively (dvd) ns \\<and> length ns \\<le> card gen\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  \\<exists>ns.\n     DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G \\<and>\n     successively (dvd) ns \\<and> length ns \\<le> card gen\n  \\<lbrakk>DirProds (\\<lambda>n. Z (?ns2 ! n)) {..<length ?ns2} \\<cong> G;\n   successively (dvd) ?ns2; length ?ns2 \\<le> card gen\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>As every \\<open>integer_mod_group\\<close> can be decomposed into a product of prime power groups,\nwe obtain (by using the fact that the direct product does not care about nestedness)\nthe primary decomposition.\\<close>"], ["", "lemma Zn_iso_DirProds_prime_powers:\n  assumes \"n \\<noteq> 0\"\n  shows \"Z n \\<cong> DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)\" (is \"Z n \\<cong> ?DP\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Z n \\<cong>\n    DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)", "proof (cases \"n = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    Z n \\<cong>\n    DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)\n 2. n \\<noteq> 1 \\<Longrightarrow>\n    Z n \\<cong>\n    DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)", "case True"], ["proof (state)\nthis:\n  n = 1\n\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    Z n \\<cong>\n    DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)\n 2. n \\<noteq> 1 \\<Longrightarrow>\n    Z n \\<cong>\n    DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Z n \\<cong>\n    DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)", "by (intro triv_iso[OF group_integer_mod_group DirProds_is_group],\n                   use DirProds_empty carrier_integer_mod_group True in auto)"], ["proof (state)\nthis:\n  Z n \\<cong>\n  DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 1 \\<Longrightarrow>\n    Z n \\<cong>\n    DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 1 \\<Longrightarrow>\n    Z n \\<cong>\n    DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)", "case nno: False"], ["proof (state)\nthis:\n  n \\<noteq> 1\n\ngoal (1 subgoal):\n 1. n \\<noteq> 1 \\<Longrightarrow>\n    Z n \\<cong>\n    DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)", "interpret DP: group ?DP"], ["proof (prove)\ngoal (1 subgoal):\n 1. Group.group\n     (DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n))", "by (intro DirProds_is_group, use group_integer_mod_group in blast)"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 1 \\<Longrightarrow>\n    Z n \\<cong>\n    DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)", "have \"order ?DP = prod (order \\<circ> (\\<lambda>p. Z (p ^ multiplicity p n))) (prime_factors n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order\n     (DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)) =\n    prod (order \\<circ> (\\<lambda>p. Z (p ^ multiplicity p n)))\n     (prime_factors n)", "by (intro DirProds_order, blast)"], ["proof (state)\nthis:\n  order\n   (DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)) =\n  prod (order \\<circ> (\\<lambda>p. Z (p ^ multiplicity p n)))\n   (prime_factors n)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 1 \\<Longrightarrow>\n    Z n \\<cong>\n    DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)", "also"], ["proof (state)\nthis:\n  order\n   (DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)) =\n  prod (order \\<circ> (\\<lambda>p. Z (p ^ multiplicity p n)))\n   (prime_factors n)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 1 \\<Longrightarrow>\n    Z n \\<cong>\n    DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)", "have \"\\<dots> = prod (\\<lambda>p. p ^ multiplicity p n) (prime_factors n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod (order \\<circ> (\\<lambda>p. Z (p ^ multiplicity p n)))\n     (prime_factors n) =\n    (\\<Prod>p\\<in>prime_factors n. p ^ multiplicity p n)", "using Zn_order"], ["proof (prove)\nusing this:\n  order (Z ?n) = ?n\n\ngoal (1 subgoal):\n 1. prod (order \\<circ> (\\<lambda>p. Z (p ^ multiplicity p n)))\n     (prime_factors n) =\n    (\\<Prod>p\\<in>prime_factors n. p ^ multiplicity p n)", "by simp"], ["proof (state)\nthis:\n  prod (order \\<circ> (\\<lambda>p. Z (p ^ multiplicity p n)))\n   (prime_factors n) =\n  (\\<Prod>p\\<in>prime_factors n. p ^ multiplicity p n)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 1 \\<Longrightarrow>\n    Z n \\<cong>\n    DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)", "also"], ["proof (state)\nthis:\n  prod (order \\<circ> (\\<lambda>p. Z (p ^ multiplicity p n)))\n   (prime_factors n) =\n  (\\<Prod>p\\<in>prime_factors n. p ^ multiplicity p n)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 1 \\<Longrightarrow>\n    Z n \\<cong>\n    DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)", "have n: \"\\<dots> = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>p\\<in>prime_factors n. p ^ multiplicity p n) = n", "using prod_prime_factors[OF assms]"], ["proof (prove)\nusing this:\n  (\\<Prod>p\\<in>prime_factors n. p ^ multiplicity p n) = normalize n\n\ngoal (1 subgoal):\n 1. (\\<Prod>p\\<in>prime_factors n. p ^ multiplicity p n) = n", "by simp"], ["proof (state)\nthis:\n  (\\<Prod>p\\<in>prime_factors n. p ^ multiplicity p n) = n\n\ngoal (1 subgoal):\n 1. n \\<noteq> 1 \\<Longrightarrow>\n    Z n \\<cong>\n    DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)", "finally"], ["proof (chain)\npicking this:\n  order\n   (DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)) =\n  n", "have oDP: \"order ?DP = n\""], ["proof (prove)\nusing this:\n  order\n   (DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)) =\n  n\n\ngoal (1 subgoal):\n 1. order\n     (DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)) =\n    n", "."], ["proof (state)\nthis:\n  order\n   (DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)) =\n  n\n\ngoal (1 subgoal):\n 1. n \\<noteq> 1 \\<Longrightarrow>\n    Z n \\<cong>\n    DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)", "then"], ["proof (chain)\npicking this:\n  order\n   (DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)) =\n  n", "interpret DP: finite_group ?DP"], ["proof (prove)\nusing this:\n  order\n   (DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)) =\n  n\n\ngoal (1 subgoal):\n 1. finite_group\n     (DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n))", "by (unfold_locales, unfold order_def, metis assms card.infinite)"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 1 \\<Longrightarrow>\n    Z n \\<cong>\n    DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)", "let ?f = \"\\<lambda>p\\<in>(prime_factors n). 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 1 \\<Longrightarrow>\n    Z n \\<cong>\n    DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)", "have fc: \"?f \\<in> carrier ?DP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>p\\<in>prime_factors n. 1)\n    \\<in> carrier\n           (DirProds (\\<lambda>p. Z (p ^ multiplicity p n))\n             (prime_factors n))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>p\\<in>prime_factors n. 1)\n    \\<in> carrier\n           (DirProds (\\<lambda>p. Z (p ^ multiplicity p n))\n             (prime_factors n))", "have p: \"0 < multiplicity p n\" if \"p \\<in> prime_factors n\" for p"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < multiplicity p n", "using prime_factors_multiplicity that"], ["proof (prove)\nusing this:\n  prime_factors ?n =\n  {p. normalization_semidom_class.prime p \\<and> 0 < multiplicity p ?n}\n  p \\<in># prime_factorization n\n\ngoal (1 subgoal):\n 1. 0 < multiplicity p n", "by auto"], ["proof (state)\nthis:\n  ?p2 \\<in># prime_factorization n \\<Longrightarrow> 0 < multiplicity ?p2 n\n\ngoal (1 subgoal):\n 1. (\\<lambda>p\\<in>prime_factors n. 1)\n    \\<in> carrier\n           (DirProds (\\<lambda>p. Z (p ^ multiplicity p n))\n             (prime_factors n))", "have pk: \"1 < p ^ k\" if \"Factorial_Ring.prime p\" \"0 < k\" for p k::nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < p ^ k", "using that one_less_power prime_gt_1_nat"], ["proof (prove)\nusing this:\n  normalization_semidom_class.prime p\n  0 < k\n  \\<lbrakk>(1::?'a) < ?a; 0 < ?n\\<rbrakk>\n  \\<Longrightarrow> (1::?'a) < ?a ^ ?n\n  normalization_semidom_class.prime ?p \\<Longrightarrow> 1 < ?p\n\ngoal (1 subgoal):\n 1. 1 < p ^ k", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>normalization_semidom_class.prime ?p2; 0 < ?k2\\<rbrakk>\n  \\<Longrightarrow> 1 < ?p2 ^ ?k2\n\ngoal (1 subgoal):\n 1. (\\<lambda>p\\<in>prime_factors n. 1)\n    \\<in> carrier\n           (DirProds (\\<lambda>p. Z (p ^ multiplicity p n))\n             (prime_factors n))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>p\\<in>prime_factors n. 1)\n    \\<in> carrier\n           (DirProds (\\<lambda>p. Z (p ^ multiplicity p n))\n             (prime_factors n))", "unfolding DirProds_def PiE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>p\\<in>prime_factors n. 1)\n    \\<in> carrier\n           \\<lparr>carrier =\n                     Pi (prime_factors n)\n                      (carrier \\<circ>\n                       (\\<lambda>p. Z (p ^ multiplicity p n))) \\<inter>\n                     extensional (prime_factors n),\n              monoid.mult =\n                \\<lambda>x y.\n                   \\<lambda>i\\<in>prime_factors n.\n                      x i \\<otimes>\\<^bsub>Z (i ^ multiplicity i n)\\<^esub>\n                      y i,\n              one =\n                \\<lambda>i\\<in>prime_factors n.\n                   \\<one>\\<^bsub>Z (i ^ multiplicity i n)\\<^esub>\\<rparr>", "by(use carrier_integer_mod_group assms nno pk p in auto,\n         metis in_prime_factors_iff nat_int of_nat_power one_less_nat_eq)"], ["proof (state)\nthis:\n  (\\<lambda>p\\<in>prime_factors n. 1)\n  \\<in> carrier\n         (DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>p\\<in>prime_factors n. 1)\n  \\<in> carrier\n         (DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n))\n\ngoal (1 subgoal):\n 1. n \\<noteq> 1 \\<Longrightarrow>\n    Z n \\<cong>\n    DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)", "have of: \"DP.ord ?f = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DP.ord (\\<lambda>p\\<in>prime_factors n. 1) = n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. DP.ord (\\<lambda>p\\<in>prime_factors n. 1) = n", "have \"n dvd j\" if j: \"?f [^]\\<^bsub>?DP\\<^esub> j = \\<one>\\<^bsub>?DP\\<^esub>\" for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. n dvd j", "proof (intro pairwise_coprime_dvd'[OF _ _ n[symmetric]])"], ["proof (state)\ngoal (3 subgoals):\n 1. finite (prime_factors n)\n 2. \\<And>i j.\n       \\<lbrakk>i \\<in># prime_factorization n;\n        j \\<in># prime_factorization n; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> coprime (i ^ multiplicity i n)\n                          (j ^ multiplicity j n)\n 3. \\<forall>a\\<in>#prime_factorization n. a ^ multiplicity a n dvd j", "show \"finite (prime_factors n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (prime_factors n)", "by simp"], ["proof (state)\nthis:\n  finite (prime_factors n)\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i \\<in># prime_factorization n;\n        j \\<in># prime_factorization n; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> coprime (i ^ multiplicity i n)\n                          (j ^ multiplicity j n)\n 2. \\<forall>a\\<in>#prime_factorization n. a ^ multiplicity a n dvd j", "show \"\\<forall>a\\<in>#prime_factorization n. a ^ multiplicity a n dvd j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>#prime_factorization n. a ^ multiplicity a n dvd j", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in># prime_factorization n \\<Longrightarrow>\n       a ^ multiplicity a n dvd j", "show \"p ^ multiplicity p n dvd j\" if \"p \\<in> prime_factors n\" for p"], ["proof (prove)\ngoal (1 subgoal):\n 1. p ^ multiplicity p n dvd j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p ^ multiplicity p n dvd j", "from j"], ["proof (chain)\npicking this:\n  (\\<lambda>p\\<in>prime_factors n.\n      1) [^]\\<^bsub>DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)\\<^esub>\n  j =\n  \\<one>\\<^bsub>DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)\\<^esub>", "have \"(?f [^]\\<^bsub>?DP\\<^esub> j) p = 0\""], ["proof (prove)\nusing this:\n  (\\<lambda>p\\<in>prime_factors n.\n      1) [^]\\<^bsub>DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)\\<^esub>\n  j =\n  \\<one>\\<^bsub>DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)\\<^esub>\n\ngoal (1 subgoal):\n 1. ((\\<lambda>p\\<in>prime_factors n.\n         1) [^]\\<^bsub>DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)\\<^esub>\n     j)\n     p =\n    0", "using that"], ["proof (prove)\nusing this:\n  (\\<lambda>p\\<in>prime_factors n.\n      1) [^]\\<^bsub>DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)\\<^esub>\n  j =\n  \\<one>\\<^bsub>DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)\\<^esub>\n  p \\<in># prime_factorization n\n\ngoal (1 subgoal):\n 1. ((\\<lambda>p\\<in>prime_factors n.\n         1) [^]\\<^bsub>DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)\\<^esub>\n     j)\n     p =\n    0", "unfolding DirProds_def one_integer_mod_group"], ["proof (prove)\nusing this:\n  (\\<lambda>p\\<in>prime_factors n.\n      1) [^]\\<^bsub>\\<lparr>carrier = Pi\\<^sub>E (prime_factors n) (carrier \\<circ> (\\<lambda>p. Z (p ^ multiplicity p n))), monoid.mult = \\<lambda>x y. \\<lambda>i\\<in>prime_factors n. x i \\<otimes>\\<^bsub>Z (i ^ multiplicity i n)\\<^esub> y i, one = \\<lambda>i\\<in>prime_factors n. 0\\<rparr>\\<^esub>\n  j =\n  \\<one>\\<^bsub>\\<lparr>carrier = Pi\\<^sub>E (prime_factors n) (carrier \\<circ> (\\<lambda>p. Z (p ^ multiplicity p n))), monoid.mult = \\<lambda>x y. \\<lambda>i\\<in>prime_factors n. x i \\<otimes>\\<^bsub>Z (i ^ multiplicity i n)\\<^esub> y i, one = \\<lambda>i\\<in>prime_factors n. 0\\<rparr>\\<^esub>\n  p \\<in># prime_factorization n\n\ngoal (1 subgoal):\n 1. ((\\<lambda>p\\<in>prime_factors n.\n         1) [^]\\<^bsub>\\<lparr>carrier = Pi\\<^sub>E (prime_factors n) (carrier \\<circ> (\\<lambda>p. Z (p ^ multiplicity p n))), monoid.mult = \\<lambda>x y. \\<lambda>i\\<in>prime_factors n. x i \\<otimes>\\<^bsub>Z (i ^ multiplicity i n)\\<^esub> y i, one = \\<lambda>i\\<in>prime_factors n. 0\\<rparr>\\<^esub>\n     j)\n     p =\n    0", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>p\\<in>prime_factors n.\n       1) [^]\\<^bsub>DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)\\<^esub>\n   j)\n   p =\n  0\n\ngoal (1 subgoal):\n 1. p ^ multiplicity p n dvd j", "hence \"?f p [^]\\<^bsub>Z (p ^ multiplicity p n)\\<^esub> j = 0\""], ["proof (prove)\nusing this:\n  ((\\<lambda>p\\<in>prime_factors n.\n       1) [^]\\<^bsub>DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)\\<^esub>\n   j)\n   p =\n  0\n\ngoal (1 subgoal):\n 1. (\\<lambda>p\\<in>prime_factors n. 1)\n     p [^]\\<^bsub>Z (p ^ multiplicity p n)\\<^esub>\n    j =\n    0", "using comp_exp_nat[OF that]"], ["proof (prove)\nusing this:\n  ((\\<lambda>p\\<in>prime_factors n.\n       1) [^]\\<^bsub>DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)\\<^esub>\n   j)\n   p =\n  0\n  (?x [^]\\<^bsub>DirProds ?G (prime_factors n)\\<^esub> ?k) p =\n  ?x p [^]\\<^bsub>?G p\\<^esub> ?k\n\ngoal (1 subgoal):\n 1. (\\<lambda>p\\<in>prime_factors n. 1)\n     p [^]\\<^bsub>Z (p ^ multiplicity p n)\\<^esub>\n    j =\n    0", "by metis"], ["proof (state)\nthis:\n  (\\<lambda>p\\<in>prime_factors n. 1)\n   p [^]\\<^bsub>Z (p ^ multiplicity p n)\\<^esub>\n  j =\n  0\n\ngoal (1 subgoal):\n 1. p ^ multiplicity p n dvd j", "hence \"group.ord (Z (p ^ multiplicity p n)) (?f p) dvd j\""], ["proof (prove)\nusing this:\n  (\\<lambda>p\\<in>prime_factors n. 1)\n   p [^]\\<^bsub>Z (p ^ multiplicity p n)\\<^esub>\n  j =\n  0\n\ngoal (1 subgoal):\n 1. group.ord (Z (p ^ multiplicity p n))\n     ((\\<lambda>p\\<in>prime_factors n. 1) p) dvd\n    j", "using comp_in_carr[OF fc that]"], ["proof (prove)\nusing this:\n  (\\<lambda>p\\<in>prime_factors n. 1)\n   p [^]\\<^bsub>Z (p ^ multiplicity p n)\\<^esub>\n  j =\n  0\n  (\\<lambda>p\\<in>prime_factors n. 1) p\n  \\<in> carrier (Z (p ^ multiplicity p n))\n\ngoal (1 subgoal):\n 1. group.ord (Z (p ^ multiplicity p n))\n     ((\\<lambda>p\\<in>prime_factors n. 1) p) dvd\n    j", "by (metis group.pow_eq_id group_integer_mod_group one_integer_mod_group)"], ["proof (state)\nthis:\n  group.ord (Z (p ^ multiplicity p n))\n   ((\\<lambda>p\\<in>prime_factors n. 1) p) dvd\n  j\n\ngoal (1 subgoal):\n 1. p ^ multiplicity p n dvd j", "moreover"], ["proof (state)\nthis:\n  group.ord (Z (p ^ multiplicity p n))\n   ((\\<lambda>p\\<in>prime_factors n. 1) p) dvd\n  j\n\ngoal (1 subgoal):\n 1. p ^ multiplicity p n dvd j", "have \"group.ord (Z (p ^ multiplicity p n)) (?f p) = p ^ multiplicity p n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. group.ord (Z (p ^ multiplicity p n))\n     ((\\<lambda>p\\<in>prime_factors n. 1) p) =\n    p ^ multiplicity p n", "by (metis (no_types, lifting) Zn_neq1_cyclic_group Zn_order comp_in_carr\n                                          cyclic_group.ord_gen_is_group_order fc integer_mod_group_1\n                                          restrict_apply' that)"], ["proof (state)\nthis:\n  group.ord (Z (p ^ multiplicity p n))\n   ((\\<lambda>p\\<in>prime_factors n. 1) p) =\n  p ^ multiplicity p n\n\ngoal (1 subgoal):\n 1. p ^ multiplicity p n dvd j", "ultimately"], ["proof (chain)\npicking this:\n  group.ord (Z (p ^ multiplicity p n))\n   ((\\<lambda>p\\<in>prime_factors n. 1) p) dvd\n  j\n  group.ord (Z (p ^ multiplicity p n))\n   ((\\<lambda>p\\<in>prime_factors n. 1) p) =\n  p ^ multiplicity p n", "show ?thesis"], ["proof (prove)\nusing this:\n  group.ord (Z (p ^ multiplicity p n))\n   ((\\<lambda>p\\<in>prime_factors n. 1) p) dvd\n  j\n  group.ord (Z (p ^ multiplicity p n))\n   ((\\<lambda>p\\<in>prime_factors n. 1) p) =\n  p ^ multiplicity p n\n\ngoal (1 subgoal):\n 1. p ^ multiplicity p n dvd j", "by simp"], ["proof (state)\nthis:\n  p ^ multiplicity p n dvd j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?p2 \\<in># prime_factorization n \\<Longrightarrow>\n  ?p2 ^ multiplicity ?p2 n dvd j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>a\\<in>#prime_factorization n. a ^ multiplicity a n dvd j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i \\<in># prime_factorization n;\n        j \\<in># prime_factorization n; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> coprime (i ^ multiplicity i n)\n                          (j ^ multiplicity j n)", "show \"coprime (i ^ multiplicity i n) (j ^ multiplicity j n)\"\n        if \"i \\<in># prime_factorization n\" \"j \\<in># prime_factorization n\" \"i \\<noteq> j\" for i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime (i ^ multiplicity i n) (j ^ multiplicity j n)", "using that diff_prime_power_imp_coprime"], ["proof (prove)\nusing this:\n  i \\<in># prime_factorization n\n  j \\<in># prime_factorization n\n  i \\<noteq> j\n  \\<lbrakk>?p \\<noteq> ?q; normalization_semidom_class.prime ?p;\n   normalization_semidom_class.prime ?q\\<rbrakk>\n  \\<Longrightarrow> coprime (?p ^ ?n) (?q ^ ?m)\n\ngoal (1 subgoal):\n 1. coprime (i ^ multiplicity i n) (j ^ multiplicity j n)", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 \\<in># prime_factorization n;\n   ?j2 \\<in># prime_factorization n; ?i2 \\<noteq> ?j2\\<rbrakk>\n  \\<Longrightarrow> coprime (?i2 ^ multiplicity ?i2 n)\n                     (?j2 ^ multiplicity ?j2 n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>p\\<in>prime_factors n.\n      1) [^]\\<^bsub>DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)\\<^esub>\n  ?j2 =\n  \\<one>\\<^bsub>DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)\\<^esub> \\<Longrightarrow>\n  n dvd ?j2\n\ngoal (1 subgoal):\n 1. DP.ord (\\<lambda>p\\<in>prime_factors n. 1) = n", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>p\\<in>prime_factors n.\n      1) [^]\\<^bsub>DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)\\<^esub>\n  ?j2 =\n  \\<one>\\<^bsub>DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)\\<^esub> \\<Longrightarrow>\n  n dvd ?j2\n\ngoal (1 subgoal):\n 1. DP.ord (\\<lambda>p\\<in>prime_factors n. 1) = n", "using fc DP.ord_dvd_group_order gcd_nat.asym oDP"], ["proof (prove)\nusing this:\n  (\\<lambda>p\\<in>prime_factors n.\n      1) [^]\\<^bsub>DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)\\<^esub>\n  ?j2 =\n  \\<one>\\<^bsub>DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)\\<^esub> \\<Longrightarrow>\n  n dvd ?j2\n  (\\<lambda>p\\<in>prime_factors n. 1)\n  \\<in> carrier\n         (DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n))\n  ?a \\<in> carrier\n            (DirProds (\\<lambda>p. Z (p ^ multiplicity p n))\n              (prime_factors n)) \\<Longrightarrow>\n  DP.ord ?a dvd\n  order (DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n))\n  \\<lbrakk>?a dvd ?b \\<and> ?a \\<noteq> ?b;\n   ?b dvd ?a \\<and> ?b \\<noteq> ?a\\<rbrakk>\n  \\<Longrightarrow> False\n  order\n   (DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)) =\n  n\n\ngoal (1 subgoal):\n 1. DP.ord (\\<lambda>p\\<in>prime_factors n. 1) = n", "by force"], ["proof (state)\nthis:\n  DP.ord (\\<lambda>p\\<in>prime_factors n. 1) = n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  DP.ord (\\<lambda>p\\<in>prime_factors n. 1) = n\n\ngoal (1 subgoal):\n 1. n \\<noteq> 1 \\<Longrightarrow>\n    Z n \\<cong>\n    DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)", "interpret DP: cyclic_group ?DP ?f"], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_And_Cyclic_Groups.cyclic_group\n     (DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n))\n     (\\<lambda>p\\<in>prime_factors n. 1)", "by (intro DP.element_ord_generates_cyclic, use of oDP fc in auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 1 \\<Longrightarrow>\n    Z n \\<cong>\n    DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Z n \\<cong>\n    DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)", "using DP.iso_sym[OF DP.Zn_iso[OF oDP]]"], ["proof (prove)\nusing this:\n  Z n \\<cong>\n  DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)\n\ngoal (1 subgoal):\n 1. Z n \\<cong>\n    DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)", "."], ["proof (state)\nthis:\n  Z n \\<cong>\n  DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Zn_iso_DirProds_prime_powers':\n  assumes \"n \\<noteq> 0\"\n  shows \"Z n \\<cong> DirProds (\\<lambda>p. Z p) ((\\<lambda>p. p ^ multiplicity p n) ` (prime_factors n))\" (is \"Z n \\<cong> ?DP\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Z n \\<cong>\n    DirProds Z ((\\<lambda>p. p ^ multiplicity p n) ` prime_factors n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Z n \\<cong>\n    DirProds Z ((\\<lambda>p. p ^ multiplicity p n) ` prime_factors n)", "have cp: \"(\\<lambda>p. Z (p ^ multiplicity p n)) = (\\<lambda>p. Z p) \\<circ> (\\<lambda>p. p ^ multiplicity p n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>p. Z (p ^ multiplicity p n)) =\n    Z \\<circ> (\\<lambda>p. p ^ multiplicity p n)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>p. Z (p ^ multiplicity p n)) =\n  Z \\<circ> (\\<lambda>p. p ^ multiplicity p n)\n\ngoal (1 subgoal):\n 1. Z n \\<cong>\n    DirProds Z ((\\<lambda>p. p ^ multiplicity p n) ` prime_factors n)", "have \"DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n) \\<cong> ?DP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DirProds (\\<lambda>p. Z (p ^ multiplicity p n))\n     (prime_factors n) \\<cong>\n    DirProds Z ((\\<lambda>p. p ^ multiplicity p n) ` prime_factors n)", "proof(subst cp, intro DirProds_iso2)"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on (\\<lambda>p. p ^ multiplicity p n) (prime_factors n)\n 2. Group.group\n     (DirProds Z ((\\<lambda>p. p ^ multiplicity p n) ` prime_factors n))", "show \"inj_on (\\<lambda>p. p ^ multiplicity p n) (prime_factors n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>p. p ^ multiplicity p n) (prime_factors n)", "by (intro inj_onI; simp add: prime_factors_multiplicity prime_power_inj'')"], ["proof (state)\nthis:\n  inj_on (\\<lambda>p. p ^ multiplicity p n) (prime_factors n)\n\ngoal (1 subgoal):\n 1. Group.group\n     (DirProds Z ((\\<lambda>p. p ^ multiplicity p n) ` prime_factors n))", "show \"group (DirProds Z ((\\<lambda>p. p ^ multiplicity p n) ` prime_factors n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Group.group\n     (DirProds Z ((\\<lambda>p. p ^ multiplicity p n) ` prime_factors n))", "by (intro DirProds_is_group, use group_integer_mod_group in auto)"], ["proof (state)\nthis:\n  Group.group\n   (DirProds Z ((\\<lambda>p. p ^ multiplicity p n) ` prime_factors n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n) \\<cong>\n  DirProds Z ((\\<lambda>p. p ^ multiplicity p n) ` prime_factors n)\n\ngoal (1 subgoal):\n 1. Z n \\<cong>\n    DirProds Z ((\\<lambda>p. p ^ multiplicity p n) ` prime_factors n)", "with Zn_iso_DirProds_prime_powers[OF assms]"], ["proof (chain)\npicking this:\n  Z n \\<cong>\n  DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)\n  DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n) \\<cong>\n  DirProds Z ((\\<lambda>p. p ^ multiplicity p n) ` prime_factors n)", "show ?thesis"], ["proof (prove)\nusing this:\n  Z n \\<cong>\n  DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)\n  DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n) \\<cong>\n  DirProds Z ((\\<lambda>p. p ^ multiplicity p n) ` prime_factors n)\n\ngoal (1 subgoal):\n 1. Z n \\<cong>\n    DirProds Z ((\\<lambda>p. p ^ multiplicity p n) ` prime_factors n)", "using Group.iso_trans"], ["proof (prove)\nusing this:\n  Z n \\<cong>\n  DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n)\n  DirProds (\\<lambda>p. Z (p ^ multiplicity p n)) (prime_factors n) \\<cong>\n  DirProds Z ((\\<lambda>p. p ^ multiplicity p n) ` prime_factors n)\n  \\<lbrakk>?G \\<cong> ?H; ?H \\<cong> ?I\\<rbrakk>\n  \\<Longrightarrow> ?G \\<cong> ?I\n\ngoal (1 subgoal):\n 1. Z n \\<cong>\n    DirProds Z ((\\<lambda>p. p ^ multiplicity p n) ` prime_factors n)", "by blast"], ["proof (state)\nthis:\n  Z n \\<cong>\n  DirProds Z ((\\<lambda>p. p ^ multiplicity p n) ` prime_factors n)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary (in fin_gen_comm_group) primary_decomposition_Zn:\n  obtains ns where\n    \"DirProds (\\<lambda>n. Z (ns!n)) {..<length ns} \\<cong> G\"\n    \"\\<forall>n\\<in>set ns. n = 0 \\<or> (\\<exists>p k. Factorial_Ring.prime p \\<and> k > 0 \\<and> n = p ^ k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G;\n         \\<forall>n\\<in>set ns.\n            n = 0 \\<or>\n            (\\<exists>p k.\n                normalization_semidom_class.prime p \\<and>\n                0 < k \\<and> n = p ^ k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G;\n         \\<forall>n\\<in>set ns.\n            n = 0 \\<or>\n            (\\<exists>p k.\n                normalization_semidom_class.prime p \\<and>\n                0 < k \\<and> n = p ^ k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from invariant_factor_decomposition_Zn"], ["proof (chain)\npicking this:\n  (\\<And>ns.\n      \\<lbrakk>DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G;\n       successively (dvd) ns; length ns \\<le> card gen\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain ms where\n    ms: \"DirProds (\\<lambda>m. Z (ms!m)) {..<length ms} \\<cong> G\" \"successively (dvd) ms\" \"length ms \\<le> card gen\""], ["proof (prove)\nusing this:\n  (\\<And>ns.\n      \\<lbrakk>DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G;\n       successively (dvd) ns; length ns \\<le> card gen\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>ms.\n        \\<lbrakk>DirProds (\\<lambda>m. Z (ms ! m)) {..<length ms} \\<cong> G;\n         successively (dvd) ms; length ms \\<le> card gen\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  DirProds (\\<lambda>m. Z (ms ! m)) {..<length ms} \\<cong> G\n  successively (dvd) ms\n  length ms \\<le> card gen\n\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G;\n         \\<forall>n\\<in>set ns.\n            n = 0 \\<or>\n            (\\<exists>p k.\n                normalization_semidom_class.prime p \\<and>\n                0 < k \\<and> n = p ^ k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?I = \"{..<length ms}\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G;\n         \\<forall>n\\<in>set ns.\n            n = 0 \\<or>\n            (\\<exists>p k.\n                normalization_semidom_class.prime p \\<and>\n                0 < k \\<and> n = p ^ k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?J = \"\\<lambda>i. if ms!i = 0 then {0} else (\\<lambda>p. p ^ multiplicity p (ms!i)) ` (prime_factors (ms!i))\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G;\n         \\<forall>n\\<in>set ns.\n            n = 0 \\<or>\n            (\\<exists>p k.\n                normalization_semidom_class.prime p \\<and>\n                0 < k \\<and> n = p ^ k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?G = \"\\<lambda>i. Z\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G;\n         \\<forall>n\\<in>set ns.\n            n = 0 \\<or>\n            (\\<exists>p k.\n                normalization_semidom_class.prime p \\<and>\n                0 < k \\<and> n = p ^ k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?f = \"\\<lambda>i. DirProds (?G i) (?J i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G;\n         \\<forall>n\\<in>set ns.\n            n = 0 \\<or>\n            (\\<exists>p k.\n                normalization_semidom_class.prime p \\<and>\n                0 < k \\<and> n = p ^ k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"DirProds (\\<lambda>m. Z (ms!m)) {..<length ms} \\<cong> DirProds ?f {..<length ms}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DirProds (\\<lambda>m. Z (ms ! m)) {..<length ms} \\<cong>\n    DirProds\n     (\\<lambda>i.\n         DirProds Z\n          (if ms ! i = 0 then {0}\n           else (\\<lambda>p. p ^ multiplicity p (ms ! i)) `\n                prime_factors (ms ! i)))\n     {..<length ms}", "proof (intro DirProds_iso[of id])"], ["proof (state)\ngoal (4 subgoals):\n 1. bij_betw id {..<length ms} {..<length ms}\n 2. \\<And>i.\n       i \\<in> {..<length ms} \\<Longrightarrow>\n       Z (ms ! i) \\<cong>\n       DirProds Z\n        (if ms ! id i = 0 then {0}\n         else (\\<lambda>p. p ^ multiplicity p (ms ! id i)) `\n              prime_factors (ms ! id i))\n 3. \\<And>i.\n       i \\<in> {..<length ms} \\<Longrightarrow> Group.group (Z (ms ! i))\n 4. \\<And>j.\n       j \\<in> {..<length ms} \\<Longrightarrow>\n       Group.group\n        (DirProds Z\n          (if ms ! j = 0 then {0}\n           else (\\<lambda>p. p ^ multiplicity p (ms ! j)) `\n                prime_factors (ms ! j)))", "show \"bij_betw id {..<length ms} {..<length ms}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw id {..<length ms} {..<length ms}", "by blast"], ["proof (state)\nthis:\n  bij_betw id {..<length ms} {..<length ms}\n\ngoal (3 subgoals):\n 1. \\<And>i.\n       i \\<in> {..<length ms} \\<Longrightarrow>\n       Z (ms ! i) \\<cong>\n       DirProds Z\n        (if ms ! id i = 0 then {0}\n         else (\\<lambda>p. p ^ multiplicity p (ms ! id i)) `\n              prime_factors (ms ! id i))\n 2. \\<And>i.\n       i \\<in> {..<length ms} \\<Longrightarrow> Group.group (Z (ms ! i))\n 3. \\<And>j.\n       j \\<in> {..<length ms} \\<Longrightarrow>\n       Group.group\n        (DirProds Z\n          (if ms ! j = 0 then {0}\n           else (\\<lambda>p. p ^ multiplicity p (ms ! j)) `\n                prime_factors (ms ! j)))", "show \"Z (ms ! i) \\<cong> ?f (id i)\" if \"i \\<in> {..<length ms}\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. Z (ms ! i) \\<cong>\n    DirProds Z\n     (if ms ! id i = 0 then {0}\n      else (\\<lambda>p. p ^ multiplicity p (ms ! id i)) `\n           prime_factors (ms ! id i))", "by (cases \"ms!i = 0\",\n          simp add: DirProds_one_cong_sym,\n          auto intro: Zn_iso_DirProds_prime_powers')"], ["proof (state)\nthis:\n  ?i3 \\<in> {..<length ms} \\<Longrightarrow>\n  Z (ms ! ?i3) \\<cong>\n  DirProds Z\n   (if ms ! id ?i3 = 0 then {0}\n    else (\\<lambda>p. p ^ multiplicity p (ms ! id ?i3)) `\n         prime_factors (ms ! id ?i3))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<in> {..<length ms} \\<Longrightarrow> Group.group (Z (ms ! i))\n 2. \\<And>j.\n       j \\<in> {..<length ms} \\<Longrightarrow>\n       Group.group\n        (DirProds Z\n          (if ms ! j = 0 then {0}\n           else (\\<lambda>p. p ^ multiplicity p (ms ! j)) `\n                prime_factors (ms ! j)))", "show \"\\<And>i. i \\<in> {..<length ms} \\<Longrightarrow> group (Z (ms ! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {..<length ms} \\<Longrightarrow> Group.group (Z (ms ! i))", "by auto"], ["proof (state)\nthis:\n  ?i3 \\<in> {..<length ms} \\<Longrightarrow> Group.group (Z (ms ! ?i3))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> {..<length ms} \\<Longrightarrow>\n       Group.group\n        (DirProds Z\n          (if ms ! j = 0 then {0}\n           else (\\<lambda>p. p ^ multiplicity p (ms ! j)) `\n                prime_factors (ms ! j)))", "show \"group (?f j)\" if \"j \\<in> {..<length ms}\" for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. Group.group\n     (DirProds Z\n       (if ms ! j = 0 then {0}\n        else (\\<lambda>p. p ^ multiplicity p (ms ! j)) `\n             prime_factors (ms ! j)))", "by (auto intro: DirProds_is_group)"], ["proof (state)\nthis:\n  ?j3 \\<in> {..<length ms} \\<Longrightarrow>\n  Group.group\n   (DirProds Z\n     (if ms ! ?j3 = 0 then {0}\n      else (\\<lambda>p. p ^ multiplicity p (ms ! ?j3)) `\n           prime_factors (ms ! ?j3)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  DirProds (\\<lambda>m. Z (ms ! m)) {..<length ms} \\<cong>\n  DirProds\n   (\\<lambda>i.\n       DirProds Z\n        (if ms ! i = 0 then {0}\n         else (\\<lambda>p. p ^ multiplicity p (ms ! i)) `\n              prime_factors (ms ! i)))\n   {..<length ms}\n\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G;\n         \\<forall>n\\<in>set ns.\n            n = 0 \\<or>\n            (\\<exists>p k.\n                normalization_semidom_class.prime p \\<and>\n                0 < k \\<and> n = p ^ k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  DirProds (\\<lambda>m. Z (ms ! m)) {..<length ms} \\<cong>\n  DirProds\n   (\\<lambda>i.\n       DirProds Z\n        (if ms ! i = 0 then {0}\n         else (\\<lambda>p. p ^ multiplicity p (ms ! i)) `\n              prime_factors (ms ! i)))\n   {..<length ms}\n\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G;\n         \\<forall>n\\<in>set ns.\n            n = 0 \\<or>\n            (\\<exists>p k.\n                normalization_semidom_class.prime p \\<and>\n                0 < k \\<and> n = p ^ k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> \\<cong> DirProds (\\<lambda>(i,j). ?G i j) (Sigma ?I ?J)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DirProds\n     (\\<lambda>i.\n         DirProds Z\n          (if ms ! i = 0 then {0}\n           else (\\<lambda>p. p ^ multiplicity p (ms ! i)) `\n                prime_factors (ms ! i)))\n     {..<length ms} \\<cong>\n    DirProds (\\<lambda>(i, j). Z j)\n     (SIGMA i:{..<length ms}.\n         if ms ! i = 0 then {0}\n         else (\\<lambda>p. p ^ multiplicity p (ms ! i)) `\n              prime_factors (ms ! i))", "by(rule DirProds_Sigma)"], ["proof (state)\nthis:\n  DirProds\n   (\\<lambda>i.\n       DirProds Z\n        (if ms ! i = 0 then {0}\n         else (\\<lambda>p. p ^ multiplicity p (ms ! i)) `\n              prime_factors (ms ! i)))\n   {..<length ms} \\<cong>\n  DirProds (\\<lambda>(i, j). Z j)\n   (SIGMA i:{..<length ms}.\n       if ms ! i = 0 then {0}\n       else (\\<lambda>p. p ^ multiplicity p (ms ! i)) `\n            prime_factors (ms ! i))\n\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G;\n         \\<forall>n\\<in>set ns.\n            n = 0 \\<or>\n            (\\<exists>p k.\n                normalization_semidom_class.prime p \\<and>\n                0 < k \\<and> n = p ^ k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  DirProds (\\<lambda>m. Z (ms ! m)) {..<length ms} \\<cong>\n  DirProds (\\<lambda>(i, j). Z j)\n   (SIGMA i:{..<length ms}.\n       if ms ! i = 0 then {0}\n       else (\\<lambda>p. p ^ multiplicity p (ms ! i)) `\n            prime_factors (ms ! i))", "have G1: \"G \\<cong> DirProds (\\<lambda>(i,j). ?G i j) (Sigma ?I ?J)\""], ["proof (prove)\nusing this:\n  DirProds (\\<lambda>m. Z (ms ! m)) {..<length ms} \\<cong>\n  DirProds (\\<lambda>(i, j). Z j)\n   (SIGMA i:{..<length ms}.\n       if ms ! i = 0 then {0}\n       else (\\<lambda>p. p ^ multiplicity p (ms ! i)) `\n            prime_factors (ms ! i))\n\ngoal (1 subgoal):\n 1. G \\<cong>\n    DirProds (\\<lambda>(i, j). Z j)\n     (SIGMA i:{..<length ms}.\n         if ms ! i = 0 then {0}\n         else (\\<lambda>p. p ^ multiplicity p (ms ! i)) `\n              prime_factors (ms ! i))", "using ms(1)"], ["proof (prove)\nusing this:\n  DirProds (\\<lambda>m. Z (ms ! m)) {..<length ms} \\<cong>\n  DirProds (\\<lambda>(i, j). Z j)\n   (SIGMA i:{..<length ms}.\n       if ms ! i = 0 then {0}\n       else (\\<lambda>p. p ^ multiplicity p (ms ! i)) `\n            prime_factors (ms ! i))\n  DirProds (\\<lambda>m. Z (ms ! m)) {..<length ms} \\<cong> G\n\ngoal (1 subgoal):\n 1. G \\<cong>\n    DirProds (\\<lambda>(i, j). Z j)\n     (SIGMA i:{..<length ms}.\n         if ms ! i = 0 then {0}\n         else (\\<lambda>p. p ^ multiplicity p (ms ! i)) `\n              prime_factors (ms ! i))", "by (metis (no_types, lifting) DirProds_is_group Group.iso_trans group.iso_sym group_integer_mod_group)"], ["proof (state)\nthis:\n  G \\<cong>\n  DirProds (\\<lambda>(i, j). Z j)\n   (SIGMA i:{..<length ms}.\n       if ms ! i = 0 then {0}\n       else (\\<lambda>p. p ^ multiplicity p (ms ! i)) `\n            prime_factors (ms ! i))\n\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G;\n         \\<forall>n\\<in>set ns.\n            n = 0 \\<or>\n            (\\<exists>p k.\n                normalization_semidom_class.prime p \\<and>\n                0 < k \\<and> n = p ^ k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<exists>ps. set ps = Sigma ?I ?J \\<and> distinct ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ps.\n       set ps =\n       (SIGMA i:{..<length ms}.\n           if ms ! i = 0 then {0}\n           else (\\<lambda>p. p ^ multiplicity p (ms ! i)) `\n                prime_factors (ms ! i)) \\<and>\n       cycle ps", "by(intro finite_distinct_list, auto)"], ["proof (state)\nthis:\n  \\<exists>ps.\n     set ps =\n     (SIGMA i:{..<length ms}.\n         if ms ! i = 0 then {0}\n         else (\\<lambda>p. p ^ multiplicity p (ms ! i)) `\n              prime_factors (ms ! i)) \\<and>\n     cycle ps\n\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G;\n         \\<forall>n\\<in>set ns.\n            n = 0 \\<or>\n            (\\<exists>p k.\n                normalization_semidom_class.prime p \\<and>\n                0 < k \\<and> n = p ^ k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<exists>ps.\n     set ps =\n     (SIGMA i:{..<length ms}.\n         if ms ! i = 0 then {0}\n         else (\\<lambda>p. p ^ multiplicity p (ms ! i)) `\n              prime_factors (ms ! i)) \\<and>\n     cycle ps", "obtain ps where ps: \"set ps = Sigma ?I ?J\" \"distinct ps\""], ["proof (prove)\nusing this:\n  \\<exists>ps.\n     set ps =\n     (SIGMA i:{..<length ms}.\n         if ms ! i = 0 then {0}\n         else (\\<lambda>p. p ^ multiplicity p (ms ! i)) `\n              prime_factors (ms ! i)) \\<and>\n     cycle ps\n\ngoal (1 subgoal):\n 1. (\\<And>ps.\n        \\<lbrakk>set ps =\n                 (SIGMA i:{..<length ms}.\n                     if ms ! i = 0 then {0}\n                     else (\\<lambda>p. p ^ multiplicity p (ms ! i)) `\n                          prime_factors (ms ! i));\n         cycle ps\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  set ps =\n  (SIGMA i:{..<length ms}.\n      if ms ! i = 0 then {0}\n      else (\\<lambda>p. p ^ multiplicity p (ms ! i)) `\n           prime_factors (ms ! i))\n  cycle ps\n\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G;\n         \\<forall>n\\<in>set ns.\n            n = 0 \\<or>\n            (\\<exists>p k.\n                normalization_semidom_class.prime p \\<and>\n                0 < k \\<and> n = p ^ k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define ns where ns: \"ns = map snd ps\""], ["proof (state)\nthis:\n  ns = map snd ps\n\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G;\n         \\<forall>n\\<in>set ns.\n            n = 0 \\<or>\n            (\\<exists>p k.\n                normalization_semidom_class.prime p \\<and>\n                0 < k \\<and> n = p ^ k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"DirProds (\\<lambda>n. Z (ns!n)) {..<length ns} \\<cong> DirProds (\\<lambda>(i,j). ?G i j) (Sigma ?I ?J)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong>\n    DirProds (\\<lambda>(i, j). Z j)\n     (SIGMA i:{..<length ms}.\n         if ms ! i = 0 then {0}\n         else (\\<lambda>p. p ^ multiplicity p (ms ! i)) `\n              prime_factors (ms ! i))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong>\n    DirProds (\\<lambda>(i, j). Z j)\n     (SIGMA i:{..<length ms}.\n         if ms ! i = 0 then {0}\n         else (\\<lambda>p. p ^ multiplicity p (ms ! i)) `\n              prime_factors (ms ! i))", "obtain b::\"nat \\<Rightarrow> (nat \\<times> nat)\"\n      where b: \"\\<forall>i<length ns. ns!i = snd (b i)\" \"bij_betw b {..<length ns} (Sigma ?I ?J)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>\\<forall>i<length ns. ns ! i = snd (b i);\n         bij_betw b {..<length ns}\n          (SIGMA i:{..<length ms}.\n              if ms ! i = 0 then {0}\n              else (\\<lambda>p. p ^ multiplicity p (ms ! i)) `\n                   prime_factors (ms ! i))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ns ps bij_betw_nth"], ["proof (prove)\nusing this:\n  ns = map snd ps\n  set ps =\n  (SIGMA i:{..<length ms}.\n      if ms ! i = 0 then {0}\n      else (\\<lambda>p. p ^ multiplicity p (ms ! i)) `\n           prime_factors (ms ! i))\n  cycle ps\n  \\<lbrakk>cycle ?xs; ?A = {..<length ?xs}; ?B = set ?xs\\<rbrakk>\n  \\<Longrightarrow> bij_betw ((!) ?xs) ?A ?B\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>\\<forall>i<length ns. ns ! i = snd (b i);\n         bij_betw b {..<length ns}\n          (SIGMA i:{..<length ms}.\n              if ms ! i = 0 then {0}\n              else (\\<lambda>p. p ^ multiplicity p (ms ! i)) `\n                   prime_factors (ms ! i))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>i<length ns. ns ! i = snd (b i)\n  bij_betw b {..<length ns}\n   (SIGMA i:{..<length ms}.\n       if ms ! i = 0 then {0}\n       else (\\<lambda>p. p ^ multiplicity p (ms ! i)) `\n            prime_factors (ms ! i))\n\ngoal (1 subgoal):\n 1. DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong>\n    DirProds (\\<lambda>(i, j). Z j)\n     (SIGMA i:{..<length ms}.\n         if ms ! i = 0 then {0}\n         else (\\<lambda>p. p ^ multiplicity p (ms ! i)) `\n              prime_factors (ms ! i))", "moreover"], ["proof (state)\nthis:\n  \\<forall>i<length ns. ns ! i = snd (b i)\n  bij_betw b {..<length ns}\n   (SIGMA i:{..<length ms}.\n       if ms ! i = 0 then {0}\n       else (\\<lambda>p. p ^ multiplicity p (ms ! i)) `\n            prime_factors (ms ! i))\n\ngoal (1 subgoal):\n 1. DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong>\n    DirProds (\\<lambda>(i, j). Z j)\n     (SIGMA i:{..<length ms}.\n         if ms ! i = 0 then {0}\n         else (\\<lambda>p. p ^ multiplicity p (ms ! i)) `\n              prime_factors (ms ! i))", "have \"Z (ns ! i) \\<cong> (case b i of (i, x) \\<Rightarrow> Z x)\" if \"i \\<in> {..<length ns}\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. Z (ns ! i) \\<cong> (case b i of (i, x) \\<Rightarrow> Z x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Z (ns ! i) \\<cong> (case b i of (i, x) \\<Rightarrow> Z x)", "have \"ns ! i = snd (b i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ns ! i = snd (b i)", "using b that"], ["proof (prove)\nusing this:\n  \\<forall>i<length ns. ns ! i = snd (b i)\n  bij_betw b {..<length ns}\n   (SIGMA i:{..<length ms}.\n       if ms ! i = 0 then {0}\n       else (\\<lambda>p. p ^ multiplicity p (ms ! i)) `\n            prime_factors (ms ! i))\n  i \\<in> {..<length ns}\n\ngoal (1 subgoal):\n 1. ns ! i = snd (b i)", "by blast"], ["proof (state)\nthis:\n  ns ! i = snd (b i)\n\ngoal (1 subgoal):\n 1. Z (ns ! i) \\<cong> (case b i of (i, x) \\<Rightarrow> Z x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ns ! i = snd (b i)\n\ngoal (1 subgoal):\n 1. Z (ns ! i) \\<cong> (case b i of (i, x) \\<Rightarrow> Z x)", "by (simp add: case_prod_beta)"], ["proof (state)\nthis:\n  Z (ns ! i) \\<cong> (case b i of (i, x) \\<Rightarrow> Z x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i3 \\<in> {..<length ns} \\<Longrightarrow>\n  Z (ns ! ?i3) \\<cong> (case b ?i3 of (i, x) \\<Rightarrow> Z x)\n\ngoal (1 subgoal):\n 1. DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong>\n    DirProds (\\<lambda>(i, j). Z j)\n     (SIGMA i:{..<length ms}.\n         if ms ! i = 0 then {0}\n         else (\\<lambda>p. p ^ multiplicity p (ms ! i)) `\n              prime_factors (ms ! i))", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>i<length ns. ns ! i = snd (b i)\n  bij_betw b {..<length ns}\n   (SIGMA i:{..<length ms}.\n       if ms ! i = 0 then {0}\n       else (\\<lambda>p. p ^ multiplicity p (ms ! i)) `\n            prime_factors (ms ! i))\n  ?i3 \\<in> {..<length ns} \\<Longrightarrow>\n  Z (ns ! ?i3) \\<cong> (case b ?i3 of (i, x) \\<Rightarrow> Z x)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>i<length ns. ns ! i = snd (b i)\n  bij_betw b {..<length ns}\n   (SIGMA i:{..<length ms}.\n       if ms ! i = 0 then {0}\n       else (\\<lambda>p. p ^ multiplicity p (ms ! i)) `\n            prime_factors (ms ! i))\n  ?i3 \\<in> {..<length ns} \\<Longrightarrow>\n  Z (ns ! ?i3) \\<cong> (case b ?i3 of (i, x) \\<Rightarrow> Z x)\n\ngoal (1 subgoal):\n 1. DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong>\n    DirProds (\\<lambda>(i, j). Z j)\n     (SIGMA i:{..<length ms}.\n         if ms ! i = 0 then {0}\n         else (\\<lambda>p. p ^ multiplicity p (ms ! i)) `\n              prime_factors (ms ! i))", "by (auto intro: DirProds_iso)"], ["proof (state)\nthis:\n  DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong>\n  DirProds (\\<lambda>(i, j). Z j)\n   (SIGMA i:{..<length ms}.\n       if ms ! i = 0 then {0}\n       else (\\<lambda>p. p ^ multiplicity p (ms ! i)) `\n            prime_factors (ms ! i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong>\n  DirProds (\\<lambda>(i, j). Z j)\n   (SIGMA i:{..<length ms}.\n       if ms ! i = 0 then {0}\n       else (\\<lambda>p. p ^ multiplicity p (ms ! i)) `\n            prime_factors (ms ! i))\n\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G;\n         \\<forall>n\\<in>set ns.\n            n = 0 \\<or>\n            (\\<exists>p k.\n                normalization_semidom_class.prime p \\<and>\n                0 < k \\<and> n = p ^ k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with G1"], ["proof (chain)\npicking this:\n  G \\<cong>\n  DirProds (\\<lambda>(i, j). Z j)\n   (SIGMA i:{..<length ms}.\n       if ms ! i = 0 then {0}\n       else (\\<lambda>p. p ^ multiplicity p (ms ! i)) `\n            prime_factors (ms ! i))\n  DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong>\n  DirProds (\\<lambda>(i, j). Z j)\n   (SIGMA i:{..<length ms}.\n       if ms ! i = 0 then {0}\n       else (\\<lambda>p. p ^ multiplicity p (ms ! i)) `\n            prime_factors (ms ! i))", "have \"DirProds (\\<lambda>n. Z (ns!n)) {..<length ns} \\<cong> G\""], ["proof (prove)\nusing this:\n  G \\<cong>\n  DirProds (\\<lambda>(i, j). Z j)\n   (SIGMA i:{..<length ms}.\n       if ms ! i = 0 then {0}\n       else (\\<lambda>p. p ^ multiplicity p (ms ! i)) `\n            prime_factors (ms ! i))\n  DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong>\n  DirProds (\\<lambda>(i, j). Z j)\n   (SIGMA i:{..<length ms}.\n       if ms ! i = 0 then {0}\n       else (\\<lambda>p. p ^ multiplicity p (ms ! i)) `\n            prime_factors (ms ! i))\n\ngoal (1 subgoal):\n 1. DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G", "using Group.iso_trans iso_sym"], ["proof (prove)\nusing this:\n  G \\<cong>\n  DirProds (\\<lambda>(i, j). Z j)\n   (SIGMA i:{..<length ms}.\n       if ms ! i = 0 then {0}\n       else (\\<lambda>p. p ^ multiplicity p (ms ! i)) `\n            prime_factors (ms ! i))\n  DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong>\n  DirProds (\\<lambda>(i, j). Z j)\n   (SIGMA i:{..<length ms}.\n       if ms ! i = 0 then {0}\n       else (\\<lambda>p. p ^ multiplicity p (ms ! i)) `\n            prime_factors (ms ! i))\n  \\<lbrakk>?G \\<cong> ?H; ?H \\<cong> ?I\\<rbrakk>\n  \\<Longrightarrow> ?G \\<cong> ?I\n  G \\<cong> ?H \\<Longrightarrow> ?H \\<cong> G\n\ngoal (1 subgoal):\n 1. DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G", "by blast"], ["proof (state)\nthis:\n  DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G\n\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G;\n         \\<forall>n\\<in>set ns.\n            n = 0 \\<or>\n            (\\<exists>p k.\n                normalization_semidom_class.prime p \\<and>\n                0 < k \\<and> n = p ^ k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G\n\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G;\n         \\<forall>n\\<in>set ns.\n            n = 0 \\<or>\n            (\\<exists>p k.\n                normalization_semidom_class.prime p \\<and>\n                0 < k \\<and> n = p ^ k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"n = 0 \\<or> (\\<exists>p k. Factorial_Ring.prime p \\<and> k > 0 \\<and> n = p ^ k)\" if \"n\\<in>set ns\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. n = 0 \\<or>\n    (\\<exists>p k.\n        normalization_semidom_class.prime p \\<and> 0 < k \\<and> n = p ^ k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. n = 0 \\<or>\n    (\\<exists>p k.\n        normalization_semidom_class.prime p \\<and> 0 < k \\<and> n = p ^ k)", "have \"k = 0 \\<or> (\\<exists>p\\<in>prime_factors (ms!i). k = p ^ multiplicity p (ms!i))\" if \"k \\<in> ?J i\" for k i"], ["proof (prove)\ngoal (1 subgoal):\n 1. k = 0 \\<or>\n    (\\<exists>p\\<in>#prime_factorization (ms ! i).\n        k = p ^ multiplicity p (ms ! i))", "by (cases \"ms!i = 0\", use that in auto)"], ["proof (state)\nthis:\n  ?k3\n  \\<in> (if ms ! ?i3 = 0 then {0}\n         else (\\<lambda>p. p ^ multiplicity p (ms ! ?i3)) `\n              prime_factors (ms ! ?i3)) \\<Longrightarrow>\n  ?k3 = 0 \\<or>\n  (\\<exists>p\\<in>#prime_factorization (ms ! ?i3).\n      ?k3 = p ^ multiplicity p (ms ! ?i3))\n\ngoal (1 subgoal):\n 1. n = 0 \\<or>\n    (\\<exists>p k.\n        normalization_semidom_class.prime p \\<and> 0 < k \\<and> n = p ^ k)", "with that ns ps"], ["proof (chain)\npicking this:\n  n \\<in> set ns\n  ns = map snd ps\n  set ps =\n  (SIGMA i:{..<length ms}.\n      if ms ! i = 0 then {0}\n      else (\\<lambda>p. p ^ multiplicity p (ms ! i)) `\n           prime_factors (ms ! i))\n  cycle ps\n  ?k3\n  \\<in> (if ms ! ?i3 = 0 then {0}\n         else (\\<lambda>p. p ^ multiplicity p (ms ! ?i3)) `\n              prime_factors (ms ! ?i3)) \\<Longrightarrow>\n  ?k3 = 0 \\<or>\n  (\\<exists>p\\<in>#prime_factorization (ms ! ?i3).\n      ?k3 = p ^ multiplicity p (ms ! ?i3))", "show ?thesis"], ["proof (prove)\nusing this:\n  n \\<in> set ns\n  ns = map snd ps\n  set ps =\n  (SIGMA i:{..<length ms}.\n      if ms ! i = 0 then {0}\n      else (\\<lambda>p. p ^ multiplicity p (ms ! i)) `\n           prime_factors (ms ! i))\n  cycle ps\n  ?k3\n  \\<in> (if ms ! ?i3 = 0 then {0}\n         else (\\<lambda>p. p ^ multiplicity p (ms ! ?i3)) `\n              prime_factors (ms ! ?i3)) \\<Longrightarrow>\n  ?k3 = 0 \\<or>\n  (\\<exists>p\\<in>#prime_factorization (ms ! ?i3).\n      ?k3 = p ^ multiplicity p (ms ! ?i3))\n\ngoal (1 subgoal):\n 1. n = 0 \\<or>\n    (\\<exists>p k.\n        normalization_semidom_class.prime p \\<and> 0 < k \\<and> n = p ^ k)", "by (auto, metis (no_types, lifting) mem_Collect_eq neq0_conv prime_factors_multiplicity)"], ["proof (state)\nthis:\n  n = 0 \\<or>\n  (\\<exists>p k.\n      normalization_semidom_class.prime p \\<and> 0 < k \\<and> n = p ^ k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?n3 \\<in> set ns \\<Longrightarrow>\n  ?n3 = 0 \\<or>\n  (\\<exists>p k.\n      normalization_semidom_class.prime p \\<and> 0 < k \\<and> ?n3 = p ^ k)\n\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G;\n         \\<forall>n\\<in>set ns.\n            n = 0 \\<or>\n            (\\<exists>p k.\n                normalization_semidom_class.prime p \\<and>\n                0 < k \\<and> n = p ^ k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G\n  ?n3 \\<in> set ns \\<Longrightarrow>\n  ?n3 = 0 \\<or>\n  (\\<exists>p k.\n      normalization_semidom_class.prime p \\<and> 0 < k \\<and> ?n3 = p ^ k)", "show\n  \"(\\<And>ns. \\<lbrakk>DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G;\n          \\<forall>n\\<in>set ns. n = 0 \\<or> (\\<exists>p k. Factorial_Ring.prime p \\<and> k > 0 \\<and> n = p ^ k)\\<rbrakk> \\<Longrightarrow> thesis)\n    \\<Longrightarrow> thesis\""], ["proof (prove)\nusing this:\n  DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G\n  ?n3 \\<in> set ns \\<Longrightarrow>\n  ?n3 = 0 \\<or>\n  (\\<exists>p k.\n      normalization_semidom_class.prime p \\<and> 0 < k \\<and> ?n3 = p ^ k)\n\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G;\n         \\<forall>n\\<in>set ns.\n            n = 0 \\<or>\n            (\\<exists>p k.\n                normalization_semidom_class.prime p \\<and>\n                0 < k \\<and> n = p ^ k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (\\<And>ns.\n      \\<lbrakk>DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G;\n       \\<forall>n\\<in>set ns.\n          n = 0 \\<or>\n          (\\<exists>p k.\n              normalization_semidom_class.prime p \\<and>\n              0 < k \\<and> n = p ^ k)\\<rbrakk>\n      \\<Longrightarrow> thesis) \\<Longrightarrow>\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>As every finite group is also finitely generated, it follows that a finite group can be\ndecomposed in a product of finite cyclic groups.\\<close>"], ["", "lemma (in finite_comm_group) cyclic_product:\n  obtains ns where \"DirProds (\\<lambda>n. Z (ns!n)) {..<length ns} \\<cong> G\" \"\\<forall>n\\<in>set ns. n\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G;\n         \\<forall>n\\<in>set ns. n \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G;\n         \\<forall>n\\<in>set ns. n \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from primary_decomposition_Zn"], ["proof (chain)\npicking this:\n  (\\<And>ns.\n      \\<lbrakk>DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G;\n       \\<forall>n\\<in>set ns.\n          n = 0 \\<or>\n          (\\<exists>p k.\n              normalization_semidom_class.prime p \\<and>\n              0 < k \\<and> n = p ^ k)\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain ns where\n    ns: \"DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G\"\n        \"\\<forall>n\\<in>set ns. n = 0 \\<or> (\\<exists>p k. normalization_semidom_class.prime p \\<and> 0 < k \\<and> n = p ^ k)\""], ["proof (prove)\nusing this:\n  (\\<And>ns.\n      \\<lbrakk>DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G;\n       \\<forall>n\\<in>set ns.\n          n = 0 \\<or>\n          (\\<exists>p k.\n              normalization_semidom_class.prime p \\<and>\n              0 < k \\<and> n = p ^ k)\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G;\n         \\<forall>n\\<in>set ns.\n            n = 0 \\<or>\n            (\\<exists>p k.\n                normalization_semidom_class.prime p \\<and>\n                0 < k \\<and> n = p ^ k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G\n  \\<forall>n\\<in>set ns.\n     n = 0 \\<or>\n     (\\<exists>p k.\n         normalization_semidom_class.prime p \\<and> 0 < k \\<and> n = p ^ k)\n\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G;\n         \\<forall>n\\<in>set ns. n \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"False\" if \"n \\<in> {..<length ns}\" \"ns!n = 0\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "from that"], ["proof (chain)\npicking this:\n  n \\<in> {..<length ns}\n  ns ! n = 0", "have \"order (DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns}) = 0\""], ["proof (prove)\nusing this:\n  n \\<in> {..<length ns}\n  ns ! n = 0\n\ngoal (1 subgoal):\n 1. order (DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns}) = 0", "using DirProds_order[of \"{..<length ns}\" \"\\<lambda>n. Z (ns!n)\"] Zn_order"], ["proof (prove)\nusing this:\n  n \\<in> {..<length ns}\n  ns ! n = 0\n  finite {..<length ns} \\<Longrightarrow>\n  order (DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns}) =\n  prod (order \\<circ> (\\<lambda>n. Z (ns ! n))) {..<length ns}\n  order (Z ?n) = ?n\n\ngoal (1 subgoal):\n 1. order (DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns}) = 0", "by auto"], ["proof (state)\nthis:\n  order (DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns}) = 0\n\ngoal (1 subgoal):\n 1. False", "with fin iso_same_card[OF ns(1)]"], ["proof (chain)\npicking this:\n  finite (carrier G)\n  card (carrier (DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns})) =\n  card (carrier G)\n  order (DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns}) = 0", "show False"], ["proof (prove)\nusing this:\n  finite (carrier G)\n  card (carrier (DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns})) =\n  card (carrier G)\n  order (DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns}) = 0\n\ngoal (1 subgoal):\n 1. False", "unfolding order_def"], ["proof (prove)\nusing this:\n  finite (carrier G)\n  card (carrier (DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns})) =\n  card (carrier G)\n  card (carrier (DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns})) = 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?n2 \\<in> {..<length ns}; ns ! ?n2 = 0\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G;\n         \\<forall>n\\<in>set ns. n \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"\\<forall>n\\<in>set ns. n\\<noteq>0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?n2 \\<in> {..<length ns}; ns ! ?n2 = 0\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<forall>n\\<in>set ns. n \\<noteq> 0", "by (metis in_set_conv_nth lessThan_iff)"], ["proof (state)\nthis:\n  \\<forall>n\\<in>set ns. n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G;\n         \\<forall>n\\<in>set ns. n \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with ns"], ["proof (chain)\npicking this:\n  DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G\n  \\<forall>n\\<in>set ns.\n     n = 0 \\<or>\n     (\\<exists>p k.\n         normalization_semidom_class.prime p \\<and> 0 < k \\<and> n = p ^ k)\n  \\<forall>n\\<in>set ns. n \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G\n  \\<forall>n\\<in>set ns.\n     n = 0 \\<or>\n     (\\<exists>p k.\n         normalization_semidom_class.prime p \\<and> 0 < k \\<and> n = p ^ k)\n  \\<forall>n\\<in>set ns. n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  DirProds (\\<lambda>n. Z (ns ! n)) {..<length ns} \\<cong> G\n  \\<forall>n\\<in>set ns.\n     n = 0 \\<or>\n     (\\<exists>p k.\n         normalization_semidom_class.prime p \\<and> 0 < k \\<and> n = p ^ k)\n  \\<forall>n\\<in>set ns. n \\<noteq> 0\n  \\<lbrakk>DirProds (\\<lambda>n. Z (?ns2 ! n)) {..<length ?ns2} \\<cong> G;\n   \\<forall>n\\<in>set ?ns2. n \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "no_notation integer_mod_group (\"Z\")"], ["", "end"]]}