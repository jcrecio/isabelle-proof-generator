{"file_name": "/home/qj213/afp-2021-10-22/thys/Finitely_Generated_Abelian_Groups/IDirProds.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Finitely_Generated_Abelian_Groups", "problem_names": ["lemma (in group) complementary_symm: \"complementary A B \\<longleftrightarrow> complementary B A\"", "lemma (in group) subgroup_carrier_complementary:\n  assumes \"complementary H J\" \"subgroup I (G\\<lparr>carrier := H\\<rparr>)\" \"subgroup K (G\\<lparr>carrier := J\\<rparr>)\"\n  shows \"complementary I K\"", "lemma (in group) subgroup_subset_complementary:\n  assumes \"subgroup H G\" \"subgroup J G\" \"subgroup I G\"\n  and \"I \\<subseteq> J\" \"complementary H J\"\nshows \"complementary H I\"", "lemma (in group) complementary_subgroup_iff:\n  assumes \"subgroup H G\"\n  shows \"complementary A B \\<longleftrightarrow> group.complementary (G\\<lparr>carrier := H\\<rparr>) A B\"", "lemma (in group) subgroups_card_coprime_imp_compl:\n  assumes \"subgroup H G\" \"subgroup J G\" \"coprime (card H) (card J)\"\n  shows \"complementary H J\"", "lemma (in group) prime_power_complementary_groups:\n  assumes \"Factorial_Ring.prime p\" \"Factorial_Ring.prime q\" \"p \\<noteq> q\"\n  and \"subgroup P G\" \"card P = p ^ x\"\n  and \"subgroup Q G\" \"card Q = q ^ y\"\n  shows \"complementary P Q\"", "lemma (in comm_group) compl_imp_diff_cosets:\n  assumes \"subgroup H G\" \"subgroup J G\" \"finite H\" \"finite J\"\n  and \"complementary H J\"\n  shows \"\\<And>a b. \\<lbrakk>a \\<in> J; b \\<in> J; a \\<noteq> b\\<rbrakk> \\<Longrightarrow> (H #> a) \\<noteq> (H #> b)\"", "lemma (in comm_group) finite_sub_card_eq_mult_imp_comp:\n  assumes \"subgroup H G\" \"subgroup J G\" \"finite H\" \"finite J\"\n  and \"card (H <#> J) = (card J * card H)\"\n  shows \"complementary H J\"", "lemma (in comm_group) finite_sub_comp_imp_card_eq_mult:\n  assumes \"subgroup H G\" \"subgroup J G\" \"finite H\" \"finite J\"\n  and \"complementary H J\"\nshows \"card (H <#> J) = card J * card H\"", "lemma (in comm_group) finite_sub_comp_iff_card_eq_mult:\n  assumes \"subgroup H G\" \"subgroup J G\" \"finite H\" \"finite J\"\n  shows \"card (H <#> J) = card J * card H  \\<longleftrightarrow> complementary H J\"", "lemma (in group) IDirProd_comm:\n  \"IDirProd G A B = IDirProd G B A\"", "lemma (in group) IDirProd_empty_right:\n  assumes \"A \\<subseteq> carrier G\"\n  shows \"IDirProd G A {} = generate G A\"", "lemma (in group) IDirProd_empty_left:\n  assumes \"A \\<subseteq> carrier G\"\n  shows \"IDirProd G {} A = generate G A\"", "lemma (in group) IDirProd_one_right:\n  assumes \"A \\<subseteq> carrier G\"\n  shows \"IDirProd G A {\\<one>} = generate G A\"", "lemma (in group) IDirProd_one_left:\n  assumes \"A \\<subseteq> carrier G\"\n  shows \"IDirProd G {\\<one>} A = generate G A\"", "lemma (in group) IDirProd_is_subgroup:\n  assumes \"Y \\<subseteq> carrier G\" \"Z \\<subseteq> carrier G\"\n  shows \"subgroup (IDirProd G Y Z) G\"", "lemma (in comm_group) IDirProd_eq_subgroup_mult:\n  assumes \"subgroup H G\" \"subgroup J G\"\n  shows \"IDirProd G H J = H <#> J\"", "lemma (in comm_group) finite_sub_comp_iff_card_eq_IDirProd:\n  assumes \"subgroup H G\" \"subgroup J G\" \"finite H\" \"finite J\"\n  shows \"card (IDirProd G H J) = card J * card H  \\<longleftrightarrow> complementary H J\"", "lemma (in group) IDirProds_incl:\n  assumes \"i \\<in> I\"\n  shows \"S i \\<subseteq> IDirProds G S I\"", "lemma (in group) IDirProds_empty:\n  \"IDirProds G S {} = {\\<one>}\"", "lemma (in group) IDirProds_is_subgroup:\n  assumes \"\\<Union>(S ` I) \\<subseteq> (carrier G)\"\n  shows \"subgroup (IDirProds G S I) G\"", "lemma (in group) IDirProds_subgroup_id: \"subgroup (S i) G \\<Longrightarrow> IDirProds G S {i} = S i\"", "lemma (in comm_group) IDirProds_Un:\n  assumes \"\\<forall>i\\<in>A. subgroup (S i) G\" \"\\<forall>j\\<in>B. subgroup (S j) G\"\n  shows   \"IDirProds G S (A \\<union> B) = IDirProds G S A <#> IDirProds G S B\"", "lemma (in comm_group) IDirProds_finite:\n  assumes \"finite I\" \"\\<forall>i\\<in>I. subgroup (S i) G\" \"\\<forall>i\\<in>I. finite (S i)\"\n  shows \"finite (IDirProds G S I)\"", "lemma (in comm_group) IDirProds_compl_imp_compl:\n  assumes \"\\<forall>i \\<in> I. subgroup (S i) G\" and \"subgroup H G\"\n  assumes \"complementary H (IDirProds G S I)\" \"i \\<in> I\"\n  shows   \"complementary H (S i)\"", "lemma (in comm_group) IDirProds_card:\n  assumes \"finite I\" \"\\<forall>i\\<in>I. subgroup (S i) G\"\n          \"\\<forall>i\\<in>I. finite (S i)\" \"pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y))) I\"\n  shows \"card (IDirProds G S I) = (\\<Prod>i \\<in> I. card (S i))\"", "lemma (in group) compl_fam_empty[simp]: \"compl_fam S {}\"", "lemma (in group) compl_fam_cong:\n  assumes \"compl_fam (f \\<circ> g) A\" \"inj_on g A\"\n  shows \"compl_fam f (g ` A)\"", "lemma (in comm_group) compl_fam_imp_generate_inj:\n  assumes \"gs \\<subseteq> carrier G\" \"compl_fam (\\<lambda>g. generate G {g}) gs\"\n  shows \"inj_on (\\<lambda>g. generate G {g}) gs\"", "lemma (in comm_group) compl_fam_generate_subset:\n  assumes \"compl_fam (\\<lambda>g. generate G {g}) gs\"\n          \"gs \\<subseteq> carrier G\" \"A \\<subseteq> gs\"\n  shows \"compl_fam (\\<lambda>g. generate G {g}) A\"", "lemma (in comm_group) is_idirprod_subgroup_suffices:\n  assumes \"A = IDirProds G S I\" \"\\<forall>i\\<in>I. subgroup (S i) G\" \"compl_fam S I\"\n  shows \"is_idirprod A S I\"", "lemma (in comm_group) is_idirprod_generate:\n  assumes \"A = generate G gs\" \"gs \\<subseteq> carrier G\" \"compl_fam (\\<lambda>g. generate G {g}) gs\"\n  shows \"is_idirprod A (\\<lambda>g. generate G {g}) gs\"", "lemma (in comm_group) is_idirprod_imp_compl_fam[simp]:\n  assumes \"is_idirprod A S I\"\n  shows \"compl_fam S I\"", "lemma (in comm_group) is_idirprod_generate_imp_generate[simp]:\n  assumes \"is_idirprod A (\\<lambda>g. generate G {g}) gs\"\n  shows \"A = generate G gs\""], "translations": [["", "lemma (in group) complementary_symm: \"complementary A B \\<longleftrightarrow> complementary B A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complementary A B = complementary B A", "unfolding complementary_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<inter> B = {\\<one>}) = (B \\<inter> A = {\\<one>})", "by blast"], ["", "lemma (in group) subgroup_carrier_complementary:\n  assumes \"complementary H J\" \"subgroup I (G\\<lparr>carrier := H\\<rparr>)\" \"subgroup K (G\\<lparr>carrier := J\\<rparr>)\"\n  shows \"complementary I K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complementary I K", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. complementary I K", "have \"\\<one> \\<in> I\"  \"\\<one> \\<in> K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<one> \\<in> I &&& \\<one> \\<in> K", "using subgroup.one_closed assms"], ["proof (prove)\nusing this:\n  subgroup ?H ?G \\<Longrightarrow> \\<one>\\<^bsub>?G\\<^esub> \\<in> ?H\n  complementary H J\n  subgroup I (G\\<lparr>carrier := H\\<rparr>)\n  subgroup K (G\\<lparr>carrier := J\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<one> \\<in> I &&& \\<one> \\<in> K", "by fastforce+"], ["proof (state)\nthis:\n  \\<one> \\<in> I\n  \\<one> \\<in> K\n\ngoal (1 subgoal):\n 1. complementary I K", "moreover"], ["proof (state)\nthis:\n  \\<one> \\<in> I\n  \\<one> \\<in> K\n\ngoal (1 subgoal):\n 1. complementary I K", "have \"I \\<inter> K \\<subseteq> H \\<inter> J\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<inter> K \\<subseteq> H \\<inter> J", "using subgroup.subset assms"], ["proof (prove)\nusing this:\n  subgroup ?H ?G \\<Longrightarrow> ?H \\<subseteq> carrier ?G\n  complementary H J\n  subgroup I (G\\<lparr>carrier := H\\<rparr>)\n  subgroup K (G\\<lparr>carrier := J\\<rparr>)\n\ngoal (1 subgoal):\n 1. I \\<inter> K \\<subseteq> H \\<inter> J", "by force"], ["proof (state)\nthis:\n  I \\<inter> K \\<subseteq> H \\<inter> J\n\ngoal (1 subgoal):\n 1. complementary I K", "ultimately"], ["proof (chain)\npicking this:\n  \\<one> \\<in> I\n  \\<one> \\<in> K\n  I \\<inter> K \\<subseteq> H \\<inter> J", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<one> \\<in> I\n  \\<one> \\<in> K\n  I \\<inter> K \\<subseteq> H \\<inter> J\n\ngoal (1 subgoal):\n 1. complementary I K", "using assms"], ["proof (prove)\nusing this:\n  \\<one> \\<in> I\n  \\<one> \\<in> K\n  I \\<inter> K \\<subseteq> H \\<inter> J\n  complementary H J\n  subgroup I (G\\<lparr>carrier := H\\<rparr>)\n  subgroup K (G\\<lparr>carrier := J\\<rparr>)\n\ngoal (1 subgoal):\n 1. complementary I K", "unfolding complementary_def"], ["proof (prove)\nusing this:\n  \\<one> \\<in> I\n  \\<one> \\<in> K\n  I \\<inter> K \\<subseteq> H \\<inter> J\n  H \\<inter> J = {\\<one>}\n  subgroup I (G\\<lparr>carrier := H\\<rparr>)\n  subgroup K (G\\<lparr>carrier := J\\<rparr>)\n\ngoal (1 subgoal):\n 1. I \\<inter> K = {\\<one>}", "by blast"], ["proof (state)\nthis:\n  complementary I K\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in group) subgroup_subset_complementary:\n  assumes \"subgroup H G\" \"subgroup J G\" \"subgroup I G\"\n  and \"I \\<subseteq> J\" \"complementary H J\"\nshows \"complementary H I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complementary H I", "by (intro subgroup_carrier_complementary[OF assms(5), of H I] subgroup_incl, use assms in auto)"], ["", "lemma (in group) complementary_subgroup_iff:\n  assumes \"subgroup H G\"\n  shows \"complementary A B \\<longleftrightarrow> group.complementary (G\\<lparr>carrier := H\\<rparr>) A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complementary A B =\n    group.complementary (G\\<lparr>carrier := H\\<rparr>) A B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. complementary A B =\n    group.complementary (G\\<lparr>carrier := H\\<rparr>) A B", "interpret H: group \"G\\<lparr>carrier := H\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Group.group (G\\<lparr>carrier := H\\<rparr>)", "using subgroup.subgroup_is_group assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>subgroup ?H ?G; Group.group ?G\\<rbrakk>\n  \\<Longrightarrow> Group.group (?G\\<lparr>carrier := ?H\\<rparr>)\n  subgroup H G\n\ngoal (1 subgoal):\n 1. Group.group (G\\<lparr>carrier := H\\<rparr>)", "by blast"], ["proof (state)\ngoal (1 subgoal):\n 1. complementary A B = H.complementary A B", "have \"\\<one>\\<^bsub>G\\<^esub> = \\<one>\\<^bsub>G\\<lparr>carrier := H\\<rparr>\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<one> = \\<one>\\<^bsub>G\\<lparr>carrier := H\\<rparr>\\<^esub>", "by simp"], ["proof (state)\nthis:\n  \\<one> = \\<one>\\<^bsub>G\\<lparr>carrier := H\\<rparr>\\<^esub>\n\ngoal (1 subgoal):\n 1. complementary A B = H.complementary A B", "then"], ["proof (chain)\npicking this:\n  \\<one> = \\<one>\\<^bsub>G\\<lparr>carrier := H\\<rparr>\\<^esub>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<one> = \\<one>\\<^bsub>G\\<lparr>carrier := H\\<rparr>\\<^esub>\n\ngoal (1 subgoal):\n 1. complementary A B = H.complementary A B", "unfolding complementary_def H.complementary_def"], ["proof (prove)\nusing this:\n  \\<one> = \\<one>\\<^bsub>G\\<lparr>carrier := H\\<rparr>\\<^esub>\n\ngoal (1 subgoal):\n 1. (A \\<inter> B = {\\<one>}) =\n    (A \\<inter> B = {\\<one>\\<^bsub>G\\<lparr>carrier := H\\<rparr>\\<^esub>})", "by simp"], ["proof (state)\nthis:\n  complementary A B = H.complementary A B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in group) subgroups_card_coprime_imp_compl:\n  assumes \"subgroup H G\" \"subgroup J G\" \"coprime (card H) (card J)\"\n  shows \"complementary H J\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complementary H J", "unfolding complementary_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<inter> J = {\\<one>}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. H \\<inter> J = {\\<one>}", "interpret JH: subgroup \"(H \\<inter> J)\" G"], ["proof (prove)\ngoal (1 subgoal):\n 1. subgroup (H \\<inter> J) G", "using assms subgroups_Inter_pair"], ["proof (prove)\nusing this:\n  subgroup H G\n  subgroup J G\n  coprime (card H) (card J)\n  \\<lbrakk>subgroup ?I G; subgroup ?J G\\<rbrakk>\n  \\<Longrightarrow> subgroup (?I \\<inter> ?J) G\n\ngoal (1 subgoal):\n 1. subgroup (H \\<inter> J) G", "by blast"], ["proof (state)\ngoal (1 subgoal):\n 1. H \\<inter> J = {\\<one>}", "from subgroups_card_coprime_inter_card_one[OF assms]"], ["proof (chain)\npicking this:\n  card (H \\<inter> J) = 1", "show \"H \\<inter> J = {\\<one>}\""], ["proof (prove)\nusing this:\n  card (H \\<inter> J) = 1\n\ngoal (1 subgoal):\n 1. H \\<inter> J = {\\<one>}", "using JH.one_closed"], ["proof (prove)\nusing this:\n  card (H \\<inter> J) = 1\n  \\<one> \\<in> H \\<inter> J\n\ngoal (1 subgoal):\n 1. H \\<inter> J = {\\<one>}", "by (metis card_1_singletonE singletonD)"], ["proof (state)\nthis:\n  H \\<inter> J = {\\<one>}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in group) prime_power_complementary_groups:\n  assumes \"Factorial_Ring.prime p\" \"Factorial_Ring.prime q\" \"p \\<noteq> q\"\n  and \"subgroup P G\" \"card P = p ^ x\"\n  and \"subgroup Q G\" \"card Q = q ^ y\"\n  shows \"complementary P Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complementary P Q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. complementary P Q", "from assms"], ["proof (chain)\npicking this:\n  normalization_semidom_class.prime p\n  normalization_semidom_class.prime q\n  p \\<noteq> q\n  subgroup P G\n  card P = p ^ x\n  subgroup Q G\n  card Q = q ^ y", "have \"coprime (card P) (card Q)\""], ["proof (prove)\nusing this:\n  normalization_semidom_class.prime p\n  normalization_semidom_class.prime q\n  p \\<noteq> q\n  subgroup P G\n  card P = p ^ x\n  subgroup Q G\n  card Q = q ^ y\n\ngoal (1 subgoal):\n 1. coprime (card P) (card Q)", "by (metis coprime_power_right_iff primes_coprime coprime_def)"], ["proof (state)\nthis:\n  coprime (card P) (card Q)\n\ngoal (1 subgoal):\n 1. complementary P Q", "then"], ["proof (chain)\npicking this:\n  coprime (card P) (card Q)", "show ?thesis"], ["proof (prove)\nusing this:\n  coprime (card P) (card Q)\n\ngoal (1 subgoal):\n 1. complementary P Q", "using subgroups_card_coprime_imp_compl assms complementary_def"], ["proof (prove)\nusing this:\n  coprime (card P) (card Q)\n  \\<lbrakk>subgroup ?H G; subgroup ?J G;\n   coprime (card ?H) (card ?J)\\<rbrakk>\n  \\<Longrightarrow> complementary ?H ?J\n  normalization_semidom_class.prime p\n  normalization_semidom_class.prime q\n  p \\<noteq> q\n  subgroup P G\n  card P = p ^ x\n  subgroup Q G\n  card Q = q ^ y\n  complementary ?H1.0 ?H2.0 = (?H1.0 \\<inter> ?H2.0 = {\\<one>})\n\ngoal (1 subgoal):\n 1. complementary P Q", "by blast"], ["proof (state)\nthis:\n  complementary P Q\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>With the previous work from the theory about set multiplication we can characterize\ncomplementarity of two subgroups in abelian groups by the cardinality of their product.\\<close>"], ["", "lemma (in comm_group) compl_imp_diff_cosets:\n  assumes \"subgroup H G\" \"subgroup J G\" \"finite H\" \"finite J\"\n  and \"complementary H J\"\n  shows \"\\<And>a b. \\<lbrakk>a \\<in> J; b \\<in> J; a \\<noteq> b\\<rbrakk> \\<Longrightarrow> (H #> a) \\<noteq> (H #> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> J; b \\<in> J; a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> H #> a \\<noteq> H #> b", "proof (rule ccontr; safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> J; b \\<in> J; a \\<noteq> b; \\<not> False;\n        H #> a = H #> b\\<rbrakk>\n       \\<Longrightarrow> False", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> J; b \\<in> J; a \\<noteq> b; \\<not> False;\n        H #> a = H #> b\\<rbrakk>\n       \\<Longrightarrow> False", "assume ab: \"a \\<in> J\" \"b \\<in> J\" \"a \\<noteq> b\""], ["proof (state)\nthis:\n  a \\<in> J\n  b \\<in> J\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> J; b \\<in> J; a \\<noteq> b; \\<not> False;\n        H #> a = H #> b\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  a \\<in> J\n  b \\<in> J\n  a \\<noteq> b", "have [simp]: \"a \\<in> carrier G\" \"b \\<in> carrier G\""], ["proof (prove)\nusing this:\n  a \\<in> J\n  b \\<in> J\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. a \\<in> carrier G &&& b \\<in> carrier G", "using assms subgroup.subset"], ["proof (prove)\nusing this:\n  a \\<in> J\n  b \\<in> J\n  a \\<noteq> b\n  subgroup H G\n  subgroup J G\n  finite H\n  finite J\n  complementary H J\n  subgroup ?H ?G \\<Longrightarrow> ?H \\<subseteq> carrier ?G\n\ngoal (1 subgoal):\n 1. a \\<in> carrier G &&& b \\<in> carrier G", "by auto"], ["proof (state)\nthis:\n  a \\<in> carrier G\n  b \\<in> carrier G\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> J; b \\<in> J; a \\<noteq> b; \\<not> False;\n        H #> a = H #> b\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"H #> a = H #> b\""], ["proof (state)\nthis:\n  H #> a = H #> b\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> J; b \\<in> J; a \\<noteq> b; \\<not> False;\n        H #> a = H #> b\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  H #> a = H #> b", "have \"a \\<otimes> inv b \\<in> H\""], ["proof (prove)\nusing this:\n  H #> a = H #> b\n\ngoal (1 subgoal):\n 1. a \\<otimes> inv b \\<in> H", "using assms(1, 2) ab"], ["proof (prove)\nusing this:\n  H #> a = H #> b\n  subgroup H G\n  subgroup J G\n  a \\<in> J\n  b \\<in> J\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. a \\<otimes> inv b \\<in> H", "by (metis comm_group_axioms comm_group_def rcos_self\n              subgroup.mem_carrier subgroup.rcos_module_imp)"], ["proof (state)\nthis:\n  a \\<otimes> inv b \\<in> H\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> J; b \\<in> J; a \\<noteq> b; \\<not> False;\n        H #> a = H #> b\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  a \\<otimes> inv b \\<in> H\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> J; b \\<in> J; a \\<noteq> b; \\<not> False;\n        H #> a = H #> b\\<rbrakk>\n       \\<Longrightarrow> False", "have \"a \\<otimes> inv b \\<in> J\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<otimes> inv b \\<in> J", "by (rule subgroup.m_closed[OF assms(2) ab(1) subgroup.m_inv_closed[OF assms(2) ab(2)]])"], ["proof (state)\nthis:\n  a \\<otimes> inv b \\<in> J\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> J; b \\<in> J; a \\<noteq> b; \\<not> False;\n        H #> a = H #> b\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  a \\<otimes> inv b \\<in> J\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> J; b \\<in> J; a \\<noteq> b; \\<not> False;\n        H #> a = H #> b\\<rbrakk>\n       \\<Longrightarrow> False", "have \"a \\<otimes> inv b \\<noteq> \\<one>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<otimes> inv b \\<noteq> \\<one>", "using ab inv_equality"], ["proof (prove)\nusing this:\n  a \\<in> J\n  b \\<in> J\n  a \\<noteq> b\n  \\<lbrakk>?y \\<otimes> ?x = \\<one>; ?x \\<in> carrier G;\n   ?y \\<in> carrier G\\<rbrakk>\n  \\<Longrightarrow> inv ?x = ?y\n\ngoal (1 subgoal):\n 1. a \\<otimes> inv b \\<noteq> \\<one>", "by fastforce"], ["proof (state)\nthis:\n  a \\<otimes> inv b \\<noteq> \\<one>\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> J; b \\<in> J; a \\<noteq> b; \\<not> False;\n        H #> a = H #> b\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  a \\<otimes> inv b \\<in> H\n  a \\<otimes> inv b \\<in> J\n  a \\<otimes> inv b \\<noteq> \\<one>", "have \"H \\<inter> J \\<noteq> {\\<one>}\""], ["proof (prove)\nusing this:\n  a \\<otimes> inv b \\<in> H\n  a \\<otimes> inv b \\<in> J\n  a \\<otimes> inv b \\<noteq> \\<one>\n\ngoal (1 subgoal):\n 1. H \\<inter> J \\<noteq> {\\<one>}", "by blast"], ["proof (state)\nthis:\n  H \\<inter> J \\<noteq> {\\<one>}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> J; b \\<in> J; a \\<noteq> b; \\<not> False;\n        H #> a = H #> b\\<rbrakk>\n       \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  H \\<inter> J \\<noteq> {\\<one>}\n\ngoal (1 subgoal):\n 1. False", "using assms(5)"], ["proof (prove)\nusing this:\n  H \\<inter> J \\<noteq> {\\<one>}\n  complementary H J\n\ngoal (1 subgoal):\n 1. False", "unfolding complementary_def"], ["proof (prove)\nusing this:\n  H \\<inter> J \\<noteq> {\\<one>}\n  H \\<inter> J = {\\<one>}\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in comm_group) finite_sub_card_eq_mult_imp_comp:\n  assumes \"subgroup H G\" \"subgroup J G\" \"finite H\" \"finite J\"\n  and \"card (H <#> J) = (card J * card H)\"\n  shows \"complementary H J\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complementary H J", "unfolding complementary_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<inter> J = {\\<one>}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. H \\<inter> J \\<noteq> {\\<one>} \\<Longrightarrow> False", "assume \"H \\<inter> J \\<noteq> {\\<one>}\""], ["proof (state)\nthis:\n  H \\<inter> J \\<noteq> {\\<one>}\n\ngoal (1 subgoal):\n 1. H \\<inter> J \\<noteq> {\\<one>} \\<Longrightarrow> False", "have \"\\<one> \\<in> H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<one> \\<in> H", "using subgroup.one_closed assms(1)"], ["proof (prove)\nusing this:\n  subgroup ?H ?G \\<Longrightarrow> \\<one>\\<^bsub>?G\\<^esub> \\<in> ?H\n  subgroup H G\n\ngoal (1 subgoal):\n 1. \\<one> \\<in> H", "by blast"], ["proof (state)\nthis:\n  \\<one> \\<in> H\n\ngoal (1 subgoal):\n 1. H \\<inter> J \\<noteq> {\\<one>} \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<one> \\<in> H\n\ngoal (1 subgoal):\n 1. H \\<inter> J \\<noteq> {\\<one>} \\<Longrightarrow> False", "have \"\\<one> \\<in> J\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<one> \\<in> J", "using subgroup.one_closed assms(2)"], ["proof (prove)\nusing this:\n  subgroup ?H ?G \\<Longrightarrow> \\<one>\\<^bsub>?G\\<^esub> \\<in> ?H\n  subgroup J G\n\ngoal (1 subgoal):\n 1. \\<one> \\<in> J", "by blast"], ["proof (state)\nthis:\n  \\<one> \\<in> J\n\ngoal (1 subgoal):\n 1. H \\<inter> J \\<noteq> {\\<one>} \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<one> \\<in> H\n  \\<one> \\<in> J", "have \"\\<one> \\<in> (H \\<inter> J)\""], ["proof (prove)\nusing this:\n  \\<one> \\<in> H\n  \\<one> \\<in> J\n\ngoal (1 subgoal):\n 1. \\<one> \\<in> H \\<inter> J", "by blast"], ["proof (state)\nthis:\n  \\<one> \\<in> H \\<inter> J\n\ngoal (1 subgoal):\n 1. H \\<inter> J \\<noteq> {\\<one>} \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<one> \\<in> H \\<inter> J", "obtain a where a_def: \"a \\<in> (H \\<inter> J) \\<and> a \\<noteq> \\<one>\""], ["proof (prove)\nusing this:\n  \\<one> \\<in> H \\<inter> J\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        a \\<in> H \\<inter> J \\<and> a \\<noteq> \\<one> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>H \\<inter> J \\<noteq> {\\<one>}\\<close>"], ["proof (prove)\nusing this:\n  \\<one> \\<in> H \\<inter> J\n  H \\<inter> J \\<noteq> {\\<one>}\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        a \\<in> H \\<inter> J \\<and> a \\<noteq> \\<one> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  a \\<in> H \\<inter> J \\<and> a \\<noteq> \\<one>\n\ngoal (1 subgoal):\n 1. H \\<inter> J \\<noteq> {\\<one>} \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  a \\<in> H \\<inter> J \\<and> a \\<noteq> \\<one>", "have aH: \"a \\<in> H\""], ["proof (prove)\nusing this:\n  a \\<in> H \\<inter> J \\<and> a \\<noteq> \\<one>\n\ngoal (1 subgoal):\n 1. a \\<in> H", "by blast"], ["proof (state)\nthis:\n  a \\<in> H\n\ngoal (1 subgoal):\n 1. H \\<inter> J \\<noteq> {\\<one>} \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  a \\<in> H", "have a_inv_H: \"inv a \\<in> H \\<and> inv a \\<noteq> \\<one>\""], ["proof (prove)\nusing this:\n  a \\<in> H\n\ngoal (1 subgoal):\n 1. inv a \\<in> H \\<and> inv a \\<noteq> \\<one>", "using assms(1)"], ["proof (prove)\nusing this:\n  a \\<in> H\n  subgroup H G\n\ngoal (1 subgoal):\n 1. inv a \\<in> H \\<and> inv a \\<noteq> \\<one>", "by (meson a_def inv_eq_1_iff subgroup.mem_carrier subgroupE(3))"], ["proof (state)\nthis:\n  inv a \\<in> H \\<and> inv a \\<noteq> \\<one>\n\ngoal (1 subgoal):\n 1. H \\<inter> J \\<noteq> {\\<one>} \\<Longrightarrow> False", "from a_def"], ["proof (chain)\npicking this:\n  a \\<in> H \\<inter> J \\<and> a \\<noteq> \\<one>", "have aJ: \"a \\<in> J\""], ["proof (prove)\nusing this:\n  a \\<in> H \\<inter> J \\<and> a \\<noteq> \\<one>\n\ngoal (1 subgoal):\n 1. a \\<in> J", "by blast"], ["proof (state)\nthis:\n  a \\<in> J\n\ngoal (1 subgoal):\n 1. H \\<inter> J \\<noteq> {\\<one>} \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  a \\<in> J", "have a_inv_J: \"inv a \\<in> J \\<and> inv a \\<noteq> \\<one>\""], ["proof (prove)\nusing this:\n  a \\<in> J\n\ngoal (1 subgoal):\n 1. inv a \\<in> J \\<and> inv a \\<noteq> \\<one>", "using assms(2)"], ["proof (prove)\nusing this:\n  a \\<in> J\n  subgroup J G\n\ngoal (1 subgoal):\n 1. inv a \\<in> J \\<and> inv a \\<noteq> \\<one>", "by (meson a_def inv_eq_1_iff subgroup.mem_carrier subgroupE(3))"], ["proof (state)\nthis:\n  inv a \\<in> J \\<and> inv a \\<noteq> \\<one>\n\ngoal (1 subgoal):\n 1. H \\<inter> J \\<noteq> {\\<one>} \\<Longrightarrow> False", "from a_def"], ["proof (chain)\npicking this:\n  a \\<in> H \\<inter> J \\<and> a \\<noteq> \\<one>", "have a_c: \"a \\<in> carrier G\""], ["proof (prove)\nusing this:\n  a \\<in> H \\<inter> J \\<and> a \\<noteq> \\<one>\n\ngoal (1 subgoal):\n 1. a \\<in> carrier G", "using subgroup.subset[of J G] assms(2)"], ["proof (prove)\nusing this:\n  a \\<in> H \\<inter> J \\<and> a \\<noteq> \\<one>\n  subgroup J G \\<Longrightarrow> J \\<subseteq> carrier G\n  subgroup J G\n\ngoal (1 subgoal):\n 1. a \\<in> carrier G", "by blast"], ["proof (state)\nthis:\n  a \\<in> carrier G\n\ngoal (1 subgoal):\n 1. H \\<inter> J \\<noteq> {\\<one>} \\<Longrightarrow> False", "from set_mult_card_eq_impl_empty_inter'[of H J]"], ["proof (chain)\npicking this:\n  \\<lbrakk>finite H; finite J; H \\<subseteq> carrier G;\n   J \\<subseteq> carrier G; card (H <#> J) = card H * card J; ?a \\<in> H;\n   ?b \\<in> H; ?a \\<noteq> ?b\\<rbrakk>\n  \\<Longrightarrow> (?a <# J) \\<inter> (?b <# J) = {}", "have empty: \"\\<And>a b. \\<lbrakk>a \\<in> H; b \\<in> H; a \\<noteq> b\\<rbrakk> \\<Longrightarrow> (l_coset G a J) \\<inter> (l_coset G b J) = {}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>finite H; finite J; H \\<subseteq> carrier G;\n   J \\<subseteq> carrier G; card (H <#> J) = card H * card J; ?a \\<in> H;\n   ?b \\<in> H; ?a \\<noteq> ?b\\<rbrakk>\n  \\<Longrightarrow> (?a <# J) \\<inter> (?b <# J) = {}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> H; b \\<in> H; a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> (a <# J) \\<inter> (b <# J) = {}", "using assms subgroup.subset[of _ G]"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite H; finite J; H \\<subseteq> carrier G;\n   J \\<subseteq> carrier G; card (H <#> J) = card H * card J; ?a \\<in> H;\n   ?b \\<in> H; ?a \\<noteq> ?b\\<rbrakk>\n  \\<Longrightarrow> (?a <# J) \\<inter> (?b <# J) = {}\n  subgroup H G\n  subgroup J G\n  finite H\n  finite J\n  card (H <#> J) = card J * card H\n  subgroup ?H G \\<Longrightarrow> ?H \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> H; b \\<in> H; a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> (a <# J) \\<inter> (b <# J) = {}", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<in> H; ?b \\<in> H; ?a \\<noteq> ?b\\<rbrakk>\n  \\<Longrightarrow> (?a <# J) \\<inter> (?b <# J) = {}\n\ngoal (1 subgoal):\n 1. H \\<inter> J \\<noteq> {\\<one>} \\<Longrightarrow> False", "have \"\\<one> \\<in> \\<one> <# J\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<one> \\<in> \\<one> <# J", "using \\<open>\\<one> \\<in> J\\<close>"], ["proof (prove)\nusing this:\n  \\<one> \\<in> J\n\ngoal (1 subgoal):\n 1. \\<one> \\<in> \\<one> <# J", "unfolding l_coset_def"], ["proof (prove)\nusing this:\n  \\<one> \\<in> J\n\ngoal (1 subgoal):\n 1. \\<one> \\<in> (\\<Union>h\\<in>J. {\\<one> \\<otimes> h})", "by force"], ["proof (state)\nthis:\n  \\<one> \\<in> \\<one> <# J\n\ngoal (1 subgoal):\n 1. H \\<inter> J \\<noteq> {\\<one>} \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<one> \\<in> \\<one> <# J\n\ngoal (1 subgoal):\n 1. H \\<inter> J \\<noteq> {\\<one>} \\<Longrightarrow> False", "have \"\\<one> \\<in> a <# J\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<one> \\<in> a <# J", "using a_inv_J aJ a_c assms \\<open>\\<one> \\<in> J\\<close> coset_join3"], ["proof (prove)\nusing this:\n  inv a \\<in> J \\<and> inv a \\<noteq> \\<one>\n  a \\<in> J\n  a \\<in> carrier G\n  subgroup H G\n  subgroup J G\n  finite H\n  finite J\n  card (H <#> J) = card J * card H\n  \\<one> \\<in> J\n  \\<lbrakk>?x \\<in> carrier G; subgroup ?H G; ?x \\<in> ?H\\<rbrakk>\n  \\<Longrightarrow> ?x <# ?H = ?H\n\ngoal (1 subgoal):\n 1. \\<one> \\<in> a <# J", "by blast"], ["proof (state)\nthis:\n  \\<one> \\<in> a <# J\n\ngoal (1 subgoal):\n 1. H \\<inter> J \\<noteq> {\\<one>} \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<one> \\<in> \\<one> <# J\n  \\<one> \\<in> a <# J", "have \"(l_coset G \\<one> J) \\<inter> (l_coset G a J) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<one> \\<in> \\<one> <# J\n  \\<one> \\<in> a <# J\n\ngoal (1 subgoal):\n 1. (\\<one> <# J) \\<inter> (a <# J) \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  (\\<one> <# J) \\<inter> (a <# J) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. H \\<inter> J \\<noteq> {\\<one>} \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  (\\<one> <# J) \\<inter> (a <# J) \\<noteq> {}", "show \"False\""], ["proof (prove)\nusing this:\n  (\\<one> <# J) \\<inter> (a <# J) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. False", "using empty[of \"\\<one>\" a] a_def aH \\<open>\\<one> \\<in> H\\<close>"], ["proof (prove)\nusing this:\n  (\\<one> <# J) \\<inter> (a <# J) \\<noteq> {}\n  \\<lbrakk>\\<one> \\<in> H; a \\<in> H; \\<one> \\<noteq> a\\<rbrakk>\n  \\<Longrightarrow> (\\<one> <# J) \\<inter> (a <# J) = {}\n  a \\<in> H \\<inter> J \\<and> a \\<noteq> \\<one>\n  a \\<in> H\n  \\<one> \\<in> H\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in comm_group) finite_sub_comp_imp_card_eq_mult:\n  assumes \"subgroup H G\" \"subgroup J G\" \"finite H\" \"finite J\"\n  and \"complementary H J\"\nshows \"card (H <#> J) = card J * card H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (H <#> J) = card J * card H", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (H <#> J) = card J * card H", "have carr: \"H \\<subseteq> carrier G\" \"J \\<subseteq> carrier G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<subseteq> carrier G &&& J \\<subseteq> carrier G", "using assms subgroup.subset"], ["proof (prove)\nusing this:\n  subgroup H G\n  subgroup J G\n  finite H\n  finite J\n  complementary H J\n  subgroup ?H ?G \\<Longrightarrow> ?H \\<subseteq> carrier ?G\n\ngoal (1 subgoal):\n 1. H \\<subseteq> carrier G &&& J \\<subseteq> carrier G", "by auto"], ["proof (state)\nthis:\n  H \\<subseteq> carrier G\n  J \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. card (H <#> J) = card J * card H", "from coset_neq_imp_empty_inter[OF assms(1)] compl_imp_diff_cosets[OF assms(1,2)]"], ["proof (chain)\npicking this:\n  \\<lbrakk>?a \\<in> carrier G; ?b \\<in> carrier G;\n   H #> ?a \\<noteq> H #> ?b\\<rbrakk>\n  \\<Longrightarrow> (H #> ?a) \\<inter> (H #> ?b) = {}\n  \\<lbrakk>finite H; finite J; complementary H J; ?a \\<in> J; ?b \\<in> J;\n   ?a \\<noteq> ?b\\<rbrakk>\n  \\<Longrightarrow> H #> ?a \\<noteq> H #> ?b", "have em_inter: \"\\<And>a b. \\<lbrakk>a \\<in> J; b \\<in> J; a \\<noteq> b\\<rbrakk> \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> carrier G; ?b \\<in> carrier G;\n   H #> ?a \\<noteq> H #> ?b\\<rbrakk>\n  \\<Longrightarrow> (H #> ?a) \\<inter> (H #> ?b) = {}\n  \\<lbrakk>finite H; finite J; complementary H J; ?a \\<in> J; ?b \\<in> J;\n   ?a \\<noteq> ?b\\<rbrakk>\n  \\<Longrightarrow> H #> ?a \\<noteq> H #> ?b\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> J; b \\<in> J; a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}", "by (meson assms subgroup.mem_carrier)"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<in> J; ?b \\<in> J; ?a \\<noteq> ?b\\<rbrakk>\n  \\<Longrightarrow> (H #> ?a) \\<inter> (H #> ?b) = {}\n\ngoal (1 subgoal):\n 1. card (H <#> J) = card J * card H", "have \"card (\\<Union>a\\<in>J. (H #> a)) = card J * card H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (\\<Union> ((#>) H ` J)) = card J * card H", "using assms(4) carr(2) em_inter"], ["proof (prove)\nusing this:\n  finite J\n  J \\<subseteq> carrier G\n  \\<lbrakk>?a \\<in> J; ?b \\<in> J; ?a \\<noteq> ?b\\<rbrakk>\n  \\<Longrightarrow> (H #> ?a) \\<inter> (H #> ?b) = {}\n\ngoal (1 subgoal):\n 1. card (\\<Union> ((#>) H ` J)) = card J * card H", "proof (induction J rule: finite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>{} \\<subseteq> carrier G;\n     \\<And>a b.\n        \\<lbrakk>a \\<in> {}; b \\<in> {}; a \\<noteq> b\\<rbrakk>\n        \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n    \\<Longrightarrow> card (\\<Union> ((#>) H ` {})) = card {} * card H\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> carrier G;\n         \\<And>a b.\n            \\<lbrakk>a \\<in> F; b \\<in> F; a \\<noteq> b\\<rbrakk>\n            \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n        \\<Longrightarrow> card (\\<Union> ((#>) H ` F)) = card F * card H;\n        insert x F \\<subseteq> carrier G;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> insert x F; b \\<in> insert x F;\n            a \\<noteq> b\\<rbrakk>\n           \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n       \\<Longrightarrow> card (\\<Union> ((#>) H ` insert x F)) =\n                         card (insert x F) * card H", "case empty"], ["proof (state)\nthis:\n  {} \\<subseteq> carrier G\n  \\<lbrakk>?a \\<in> {}; ?b \\<in> {}; ?a \\<noteq> ?b\\<rbrakk>\n  \\<Longrightarrow> (H #> ?a) \\<inter> (H #> ?b) = {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>{} \\<subseteq> carrier G;\n     \\<And>a b.\n        \\<lbrakk>a \\<in> {}; b \\<in> {}; a \\<noteq> b\\<rbrakk>\n        \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n    \\<Longrightarrow> card (\\<Union> ((#>) H ` {})) = card {} * card H\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> carrier G;\n         \\<And>a b.\n            \\<lbrakk>a \\<in> F; b \\<in> F; a \\<noteq> b\\<rbrakk>\n            \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n        \\<Longrightarrow> card (\\<Union> ((#>) H ` F)) = card F * card H;\n        insert x F \\<subseteq> carrier G;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> insert x F; b \\<in> insert x F;\n            a \\<noteq> b\\<rbrakk>\n           \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n       \\<Longrightarrow> card (\\<Union> ((#>) H ` insert x F)) =\n                         card (insert x F) * card H", "then"], ["proof (chain)\npicking this:\n  {} \\<subseteq> carrier G\n  \\<lbrakk>?a \\<in> {}; ?b \\<in> {}; ?a \\<noteq> ?b\\<rbrakk>\n  \\<Longrightarrow> (H #> ?a) \\<inter> (H #> ?b) = {}", "show ?case"], ["proof (prove)\nusing this:\n  {} \\<subseteq> carrier G\n  \\<lbrakk>?a \\<in> {}; ?b \\<in> {}; ?a \\<noteq> ?b\\<rbrakk>\n  \\<Longrightarrow> (H #> ?a) \\<inter> (H #> ?b) = {}\n\ngoal (1 subgoal):\n 1. card (\\<Union> ((#>) H ` {})) = card {} * card H", "by auto"], ["proof (state)\nthis:\n  card (\\<Union> ((#>) H ` {})) = card {} * card H\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> carrier G;\n         \\<And>a b.\n            \\<lbrakk>a \\<in> F; b \\<in> F; a \\<noteq> b\\<rbrakk>\n            \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n        \\<Longrightarrow> card (\\<Union> ((#>) H ` F)) = card F * card H;\n        insert x F \\<subseteq> carrier G;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> insert x F; b \\<in> insert x F;\n            a \\<noteq> b\\<rbrakk>\n           \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n       \\<Longrightarrow> card (\\<Union> ((#>) H ` insert x F)) =\n                         card (insert x F) * card H", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> carrier G;\n         \\<And>a b.\n            \\<lbrakk>a \\<in> F; b \\<in> F; a \\<noteq> b\\<rbrakk>\n            \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n        \\<Longrightarrow> card (\\<Union> ((#>) H ` F)) = card F * card H;\n        insert x F \\<subseteq> carrier G;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> insert x F; b \\<in> insert x F;\n            a \\<noteq> b\\<rbrakk>\n           \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n       \\<Longrightarrow> card (\\<Union> ((#>) H ` insert x F)) =\n                         card (insert x F) * card H", "case i: (insert x F)"], ["proof (state)\nthis:\n  finite F\n  x \\<notin> F\n  \\<lbrakk>F \\<subseteq> carrier G;\n   \\<And>a b.\n      \\<lbrakk>a \\<in> F; b \\<in> F; a \\<noteq> b\\<rbrakk>\n      \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n  \\<Longrightarrow> card (\\<Union> ((#>) H ` F)) = card F * card H\n  insert x F \\<subseteq> carrier G\n  \\<lbrakk>?a \\<in> insert x F; ?b \\<in> insert x F; ?a \\<noteq> ?b\\<rbrakk>\n  \\<Longrightarrow> (H #> ?a) \\<inter> (H #> ?b) = {}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> carrier G;\n         \\<And>a b.\n            \\<lbrakk>a \\<in> F; b \\<in> F; a \\<noteq> b\\<rbrakk>\n            \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n        \\<Longrightarrow> card (\\<Union> ((#>) H ` F)) = card F * card H;\n        insert x F \\<subseteq> carrier G;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> insert x F; b \\<in> insert x F;\n            a \\<noteq> b\\<rbrakk>\n           \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n       \\<Longrightarrow> card (\\<Union> ((#>) H ` insert x F)) =\n                         card (insert x F) * card H", "then"], ["proof (chain)\npicking this:\n  finite F\n  x \\<notin> F\n  \\<lbrakk>F \\<subseteq> carrier G;\n   \\<And>a b.\n      \\<lbrakk>a \\<in> F; b \\<in> F; a \\<noteq> b\\<rbrakk>\n      \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n  \\<Longrightarrow> card (\\<Union> ((#>) H ` F)) = card F * card H\n  insert x F \\<subseteq> carrier G\n  \\<lbrakk>?a \\<in> insert x F; ?b \\<in> insert x F; ?a \\<noteq> ?b\\<rbrakk>\n  \\<Longrightarrow> (H #> ?a) \\<inter> (H #> ?b) = {}", "have cF:\"card (\\<Union> ((#>) H ` F)) = card F * card H\""], ["proof (prove)\nusing this:\n  finite F\n  x \\<notin> F\n  \\<lbrakk>F \\<subseteq> carrier G;\n   \\<And>a b.\n      \\<lbrakk>a \\<in> F; b \\<in> F; a \\<noteq> b\\<rbrakk>\n      \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n  \\<Longrightarrow> card (\\<Union> ((#>) H ` F)) = card F * card H\n  insert x F \\<subseteq> carrier G\n  \\<lbrakk>?a \\<in> insert x F; ?b \\<in> insert x F; ?a \\<noteq> ?b\\<rbrakk>\n  \\<Longrightarrow> (H #> ?a) \\<inter> (H #> ?b) = {}\n\ngoal (1 subgoal):\n 1. card (\\<Union> ((#>) H ` F)) = card F * card H", "by blast"], ["proof (state)\nthis:\n  card (\\<Union> ((#>) H ` F)) = card F * card H\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> carrier G;\n         \\<And>a b.\n            \\<lbrakk>a \\<in> F; b \\<in> F; a \\<noteq> b\\<rbrakk>\n            \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n        \\<Longrightarrow> card (\\<Union> ((#>) H ` F)) = card F * card H;\n        insert x F \\<subseteq> carrier G;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> insert x F; b \\<in> insert x F;\n            a \\<noteq> b\\<rbrakk>\n           \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n       \\<Longrightarrow> card (\\<Union> ((#>) H ` insert x F)) =\n                         card (insert x F) * card H", "have xc[simp]: \"x \\<in> carrier G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> carrier G", "using i(4)"], ["proof (prove)\nusing this:\n  insert x F \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. x \\<in> carrier G", "by simp"], ["proof (state)\nthis:\n  x \\<in> carrier G\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> carrier G;\n         \\<And>a b.\n            \\<lbrakk>a \\<in> F; b \\<in> F; a \\<noteq> b\\<rbrakk>\n            \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n        \\<Longrightarrow> card (\\<Union> ((#>) H ` F)) = card F * card H;\n        insert x F \\<subseteq> carrier G;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> insert x F; b \\<in> insert x F;\n            a \\<noteq> b\\<rbrakk>\n           \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n       \\<Longrightarrow> card (\\<Union> ((#>) H ` insert x F)) =\n                         card (insert x F) * card H", "let ?J = \"insert x F\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> carrier G;\n         \\<And>a b.\n            \\<lbrakk>a \\<in> F; b \\<in> F; a \\<noteq> b\\<rbrakk>\n            \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n        \\<Longrightarrow> card (\\<Union> ((#>) H ` F)) = card F * card H;\n        insert x F \\<subseteq> carrier G;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> insert x F; b \\<in> insert x F;\n            a \\<noteq> b\\<rbrakk>\n           \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n       \\<Longrightarrow> card (\\<Union> ((#>) H ` insert x F)) =\n                         card (insert x F) * card H", "from i(2, 4, 5)"], ["proof (chain)\npicking this:\n  x \\<notin> F\n  insert x F \\<subseteq> carrier G\n  \\<lbrakk>?a \\<in> insert x F; ?b \\<in> insert x F; ?a \\<noteq> ?b\\<rbrakk>\n  \\<Longrightarrow> (H #> ?a) \\<inter> (H #> ?b) = {}", "have em:\"(H #> x) \\<inter> (\\<Union>y\\<in>F. (H #> y)) = {}\""], ["proof (prove)\nusing this:\n  x \\<notin> F\n  insert x F \\<subseteq> carrier G\n  \\<lbrakk>?a \\<in> insert x F; ?b \\<in> insert x F; ?a \\<noteq> ?b\\<rbrakk>\n  \\<Longrightarrow> (H #> ?a) \\<inter> (H #> ?b) = {}\n\ngoal (1 subgoal):\n 1. (H #> x) \\<inter> \\<Union> ((#>) H ` F) = {}", "by auto"], ["proof (state)\nthis:\n  (H #> x) \\<inter> \\<Union> ((#>) H ` F) = {}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> carrier G;\n         \\<And>a b.\n            \\<lbrakk>a \\<in> F; b \\<in> F; a \\<noteq> b\\<rbrakk>\n            \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n        \\<Longrightarrow> card (\\<Union> ((#>) H ` F)) = card F * card H;\n        insert x F \\<subseteq> carrier G;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> insert x F; b \\<in> insert x F;\n            a \\<noteq> b\\<rbrakk>\n           \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n       \\<Longrightarrow> card (\\<Union> ((#>) H ` insert x F)) =\n                         card (insert x F) * card H", "have \"finite (H #> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (H #> x)", "by (meson carr(1) rcosetsI rcosets_finite assms(3) xc)"], ["proof (state)\nthis:\n  finite (H #> x)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> carrier G;\n         \\<And>a b.\n            \\<lbrakk>a \\<in> F; b \\<in> F; a \\<noteq> b\\<rbrakk>\n            \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n        \\<Longrightarrow> card (\\<Union> ((#>) H ` F)) = card F * card H;\n        insert x F \\<subseteq> carrier G;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> insert x F; b \\<in> insert x F;\n            a \\<noteq> b\\<rbrakk>\n           \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n       \\<Longrightarrow> card (\\<Union> ((#>) H ` insert x F)) =\n                         card (insert x F) * card H", "moreover"], ["proof (state)\nthis:\n  finite (H #> x)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> carrier G;\n         \\<And>a b.\n            \\<lbrakk>a \\<in> F; b \\<in> F; a \\<noteq> b\\<rbrakk>\n            \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n        \\<Longrightarrow> card (\\<Union> ((#>) H ` F)) = card F * card H;\n        insert x F \\<subseteq> carrier G;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> insert x F; b \\<in> insert x F;\n            a \\<noteq> b\\<rbrakk>\n           \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n       \\<Longrightarrow> card (\\<Union> ((#>) H ` insert x F)) =\n                         card (insert x F) * card H", "have \"finite (H <#> F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (H <#> F)", "using set_mult_finite[OF assms(3) i(1) carr(1)] i(4)"], ["proof (prove)\nusing this:\n  F \\<subseteq> carrier G \\<Longrightarrow> finite (H <#> F)\n  insert x F \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. finite (H <#> F)", "by blast"], ["proof (state)\nthis:\n  finite (H <#> F)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> carrier G;\n         \\<And>a b.\n            \\<lbrakk>a \\<in> F; b \\<in> F; a \\<noteq> b\\<rbrakk>\n            \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n        \\<Longrightarrow> card (\\<Union> ((#>) H ` F)) = card F * card H;\n        insert x F \\<subseteq> carrier G;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> insert x F; b \\<in> insert x F;\n            a \\<noteq> b\\<rbrakk>\n           \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n       \\<Longrightarrow> card (\\<Union> ((#>) H ` insert x F)) =\n                         card (insert x F) * card H", "moreover"], ["proof (state)\nthis:\n  finite (H <#> F)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> carrier G;\n         \\<And>a b.\n            \\<lbrakk>a \\<in> F; b \\<in> F; a \\<noteq> b\\<rbrakk>\n            \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n        \\<Longrightarrow> card (\\<Union> ((#>) H ` F)) = card F * card H;\n        insert x F \\<subseteq> carrier G;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> insert x F; b \\<in> insert x F;\n            a \\<noteq> b\\<rbrakk>\n           \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n       \\<Longrightarrow> card (\\<Union> ((#>) H ` insert x F)) =\n                         card (insert x F) * card H", "have \"H <#> F = (\\<Union>a\\<in>F. (H #> a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H <#> F = \\<Union> ((#>) H ` F)", "unfolding set_mult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>h\\<in>H. \\<Union>k\\<in>F. {h \\<otimes> k}) =\n    \\<Union> ((#>) H ` F)", "using r_coset_def[of G H]"], ["proof (prove)\nusing this:\n  H #> ?a = (\\<Union>h\\<in>H. {h \\<otimes> ?a})\n\ngoal (1 subgoal):\n 1. (\\<Union>h\\<in>H. \\<Union>k\\<in>F. {h \\<otimes> k}) =\n    \\<Union> ((#>) H ` F)", "by auto"], ["proof (state)\nthis:\n  H <#> F = \\<Union> ((#>) H ` F)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> carrier G;\n         \\<And>a b.\n            \\<lbrakk>a \\<in> F; b \\<in> F; a \\<noteq> b\\<rbrakk>\n            \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n        \\<Longrightarrow> card (\\<Union> ((#>) H ` F)) = card F * card H;\n        insert x F \\<subseteq> carrier G;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> insert x F; b \\<in> insert x F;\n            a \\<noteq> b\\<rbrakk>\n           \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n       \\<Longrightarrow> card (\\<Union> ((#>) H ` insert x F)) =\n                         card (insert x F) * card H", "ultimately"], ["proof (chain)\npicking this:\n  finite (H #> x)\n  finite (H <#> F)\n  H <#> F = \\<Union> ((#>) H ` F)", "have \"card(H #> x) + card(\\<Union>y\\<in>F. (H #> y))\n                   = card((H #> x) \\<union> (\\<Union>y\\<in>F. (H #> y))) + card((H #> x) \\<inter> (\\<Union>y\\<in>F. (H #> y)))\""], ["proof (prove)\nusing this:\n  finite (H #> x)\n  finite (H <#> F)\n  H <#> F = \\<Union> ((#>) H ` F)\n\ngoal (1 subgoal):\n 1. card (H #> x) + card (\\<Union> ((#>) H ` F)) =\n    card ((H #> x) \\<union> \\<Union> ((#>) H ` F)) +\n    card ((H #> x) \\<inter> \\<Union> ((#>) H ` F))", "using card_Un_Int"], ["proof (prove)\nusing this:\n  finite (H #> x)\n  finite (H <#> F)\n  H <#> F = \\<Union> ((#>) H ` F)\n  \\<lbrakk>finite ?A; finite ?B\\<rbrakk>\n  \\<Longrightarrow> card ?A + card ?B =\n                    card (?A \\<union> ?B) + card (?A \\<inter> ?B)\n\ngoal (1 subgoal):\n 1. card (H #> x) + card (\\<Union> ((#>) H ` F)) =\n    card ((H #> x) \\<union> \\<Union> ((#>) H ` F)) +\n    card ((H #> x) \\<inter> \\<Union> ((#>) H ` F))", "by auto"], ["proof (state)\nthis:\n  card (H #> x) + card (\\<Union> ((#>) H ` F)) =\n  card ((H #> x) \\<union> \\<Union> ((#>) H ` F)) +\n  card ((H #> x) \\<inter> \\<Union> ((#>) H ` F))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> carrier G;\n         \\<And>a b.\n            \\<lbrakk>a \\<in> F; b \\<in> F; a \\<noteq> b\\<rbrakk>\n            \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n        \\<Longrightarrow> card (\\<Union> ((#>) H ` F)) = card F * card H;\n        insert x F \\<subseteq> carrier G;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> insert x F; b \\<in> insert x F;\n            a \\<noteq> b\\<rbrakk>\n           \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n       \\<Longrightarrow> card (\\<Union> ((#>) H ` insert x F)) =\n                         card (insert x F) * card H", "then"], ["proof (chain)\npicking this:\n  card (H #> x) + card (\\<Union> ((#>) H ` F)) =\n  card ((H #> x) \\<union> \\<Union> ((#>) H ` F)) +\n  card ((H #> x) \\<inter> \\<Union> ((#>) H ` F))", "have \"card(H #> x) + card(\\<Union>y\\<in>F. (H #> y)) = card((H #> x) \\<union> (\\<Union>y\\<in>F. (H #> y)))\""], ["proof (prove)\nusing this:\n  card (H #> x) + card (\\<Union> ((#>) H ` F)) =\n  card ((H #> x) \\<union> \\<Union> ((#>) H ` F)) +\n  card ((H #> x) \\<inter> \\<Union> ((#>) H ` F))\n\ngoal (1 subgoal):\n 1. card (H #> x) + card (\\<Union> ((#>) H ` F)) =\n    card ((H #> x) \\<union> \\<Union> ((#>) H ` F))", "using i(5) em"], ["proof (prove)\nusing this:\n  card (H #> x) + card (\\<Union> ((#>) H ` F)) =\n  card ((H #> x) \\<union> \\<Union> ((#>) H ` F)) +\n  card ((H #> x) \\<inter> \\<Union> ((#>) H ` F))\n  \\<lbrakk>?a \\<in> insert x F; ?b \\<in> insert x F; ?a \\<noteq> ?b\\<rbrakk>\n  \\<Longrightarrow> (H #> ?a) \\<inter> (H #> ?b) = {}\n  (H #> x) \\<inter> \\<Union> ((#>) H ` F) = {}\n\ngoal (1 subgoal):\n 1. card (H #> x) + card (\\<Union> ((#>) H ` F)) =\n    card ((H #> x) \\<union> \\<Union> ((#>) H ` F))", "by simp"], ["proof (state)\nthis:\n  card (H #> x) + card (\\<Union> ((#>) H ` F)) =\n  card ((H #> x) \\<union> \\<Union> ((#>) H ` F))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> carrier G;\n         \\<And>a b.\n            \\<lbrakk>a \\<in> F; b \\<in> F; a \\<noteq> b\\<rbrakk>\n            \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n        \\<Longrightarrow> card (\\<Union> ((#>) H ` F)) = card F * card H;\n        insert x F \\<subseteq> carrier G;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> insert x F; b \\<in> insert x F;\n            a \\<noteq> b\\<rbrakk>\n           \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n       \\<Longrightarrow> card (\\<Union> ((#>) H ` insert x F)) =\n                         card (insert x F) * card H", "moreover"], ["proof (state)\nthis:\n  card (H #> x) + card (\\<Union> ((#>) H ` F)) =\n  card ((H #> x) \\<union> \\<Union> ((#>) H ` F))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> carrier G;\n         \\<And>a b.\n            \\<lbrakk>a \\<in> F; b \\<in> F; a \\<noteq> b\\<rbrakk>\n            \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n        \\<Longrightarrow> card (\\<Union> ((#>) H ` F)) = card F * card H;\n        insert x F \\<subseteq> carrier G;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> insert x F; b \\<in> insert x F;\n            a \\<noteq> b\\<rbrakk>\n           \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n       \\<Longrightarrow> card (\\<Union> ((#>) H ` insert x F)) =\n                         card (insert x F) * card H", "have \"card (H #> x) = card H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (H #> x) = card H", "using card_rcosets_equal[of _ H] rcosetsI[of H] carr(1) xc"], ["proof (prove)\nusing this:\n  \\<lbrakk>?R \\<in> rcosets H; H \\<subseteq> carrier G\\<rbrakk>\n  \\<Longrightarrow> card H = card ?R\n  \\<lbrakk>H \\<subseteq> carrier G; ?x \\<in> carrier G\\<rbrakk>\n  \\<Longrightarrow> H #> ?x \\<in> rcosets H\n  H \\<subseteq> carrier G\n  x \\<in> carrier G\n\ngoal (1 subgoal):\n 1. card (H #> x) = card H", "by metis"], ["proof (state)\nthis:\n  card (H #> x) = card H\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> carrier G;\n         \\<And>a b.\n            \\<lbrakk>a \\<in> F; b \\<in> F; a \\<noteq> b\\<rbrakk>\n            \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n        \\<Longrightarrow> card (\\<Union> ((#>) H ` F)) = card F * card H;\n        insert x F \\<subseteq> carrier G;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> insert x F; b \\<in> insert x F;\n            a \\<noteq> b\\<rbrakk>\n           \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n       \\<Longrightarrow> card (\\<Union> ((#>) H ` insert x F)) =\n                         card (insert x F) * card H", "moreover"], ["proof (state)\nthis:\n  card (H #> x) = card H\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> carrier G;\n         \\<And>a b.\n            \\<lbrakk>a \\<in> F; b \\<in> F; a \\<noteq> b\\<rbrakk>\n            \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n        \\<Longrightarrow> card (\\<Union> ((#>) H ` F)) = card F * card H;\n        insert x F \\<subseteq> carrier G;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> insert x F; b \\<in> insert x F;\n            a \\<noteq> b\\<rbrakk>\n           \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n       \\<Longrightarrow> card (\\<Union> ((#>) H ` insert x F)) =\n                         card (insert x F) * card H", "have \"card (insert x F) * card H = card F * card H + card H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (insert x F) * card H = card F * card H + card H", "by (simp add: i)"], ["proof (state)\nthis:\n  card (insert x F) * card H = card F * card H + card H\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> carrier G;\n         \\<And>a b.\n            \\<lbrakk>a \\<in> F; b \\<in> F; a \\<noteq> b\\<rbrakk>\n            \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n        \\<Longrightarrow> card (\\<Union> ((#>) H ` F)) = card F * card H;\n        insert x F \\<subseteq> carrier G;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> insert x F; b \\<in> insert x F;\n            a \\<noteq> b\\<rbrakk>\n           \\<Longrightarrow> (H #> a) \\<inter> (H #> b) = {}\\<rbrakk>\n       \\<Longrightarrow> card (\\<Union> ((#>) H ` insert x F)) =\n                         card (insert x F) * card H", "ultimately"], ["proof (chain)\npicking this:\n  card (H #> x) + card (\\<Union> ((#>) H ` F)) =\n  card ((H #> x) \\<union> \\<Union> ((#>) H ` F))\n  card (H #> x) = card H\n  card (insert x F) * card H = card F * card H + card H", "show ?case"], ["proof (prove)\nusing this:\n  card (H #> x) + card (\\<Union> ((#>) H ` F)) =\n  card ((H #> x) \\<union> \\<Union> ((#>) H ` F))\n  card (H #> x) = card H\n  card (insert x F) * card H = card F * card H + card H\n\ngoal (1 subgoal):\n 1. card (\\<Union> ((#>) H ` insert x F)) = card (insert x F) * card H", "using cF"], ["proof (prove)\nusing this:\n  card (H #> x) + card (\\<Union> ((#>) H ` F)) =\n  card ((H #> x) \\<union> \\<Union> ((#>) H ` F))\n  card (H #> x) = card H\n  card (insert x F) * card H = card F * card H + card H\n  card (\\<Union> ((#>) H ` F)) = card F * card H\n\ngoal (1 subgoal):\n 1. card (\\<Union> ((#>) H ` insert x F)) = card (insert x F) * card H", "by simp"], ["proof (state)\nthis:\n  card (\\<Union> ((#>) H ` insert x F)) = card (insert x F) * card H\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card (\\<Union> ((#>) H ` J)) = card J * card H\n\ngoal (1 subgoal):\n 1. card (H <#> J) = card J * card H", "moreover"], ["proof (state)\nthis:\n  card (\\<Union> ((#>) H ` J)) = card J * card H\n\ngoal (1 subgoal):\n 1. card (H <#> J) = card J * card H", "have \"H <#> J = (\\<Union>a\\<in>J. (H #> a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H <#> J = \\<Union> ((#>) H ` J)", "unfolding set_mult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>h\\<in>H. \\<Union>k\\<in>J. {h \\<otimes> k}) =\n    \\<Union> ((#>) H ` J)", "using r_coset_def[of G H]"], ["proof (prove)\nusing this:\n  H #> ?a = (\\<Union>h\\<in>H. {h \\<otimes> ?a})\n\ngoal (1 subgoal):\n 1. (\\<Union>h\\<in>H. \\<Union>k\\<in>J. {h \\<otimes> k}) =\n    \\<Union> ((#>) H ` J)", "by auto"], ["proof (state)\nthis:\n  H <#> J = \\<Union> ((#>) H ` J)\n\ngoal (1 subgoal):\n 1. card (H <#> J) = card J * card H", "ultimately"], ["proof (chain)\npicking this:\n  card (\\<Union> ((#>) H ` J)) = card J * card H\n  H <#> J = \\<Union> ((#>) H ` J)", "show \"card (H <#> J) = card J * card H\""], ["proof (prove)\nusing this:\n  card (\\<Union> ((#>) H ` J)) = card J * card H\n  H <#> J = \\<Union> ((#>) H ` J)\n\ngoal (1 subgoal):\n 1. card (H <#> J) = card J * card H", "by argo"], ["proof (state)\nthis:\n  card (H <#> J) = card J * card H\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in comm_group) finite_sub_comp_iff_card_eq_mult:\n  assumes \"subgroup H G\" \"subgroup J G\" \"finite H\" \"finite J\"\n  shows \"card (H <#> J) = card J * card H  \\<longleftrightarrow> complementary H J\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (card (H <#> J) = card J * card H) = complementary H J", "using finite_sub_comp_imp_card_eq_mult[OF assms] finite_sub_card_eq_mult_imp_comp[OF assms]"], ["proof (prove)\nusing this:\n  complementary H J \\<Longrightarrow> card (H <#> J) = card J * card H\n  card (H <#> J) = card J * card H \\<Longrightarrow> complementary H J\n\ngoal (1 subgoal):\n 1. (card (H <#> J) = card J * card H) = complementary H J", "by blast"], ["", "subsection \\<open>\\<open>IDirProd\\<close> - binary internal direct product\\<close>"], ["", "text \\<open>We introduce the internal direct product formed by two subgroups (so in its binary form).\\<close>"], ["", "definition IDirProd :: \"('a, 'b) monoid_scheme \\<Rightarrow> 'a set \\<Rightarrow> 'a set \\<Rightarrow> 'a set\" where\n  \"IDirProd G Y Z = generate G (Y \\<union> Z)\""], ["", "text \\<open>Some trivial lemmas about the binary internal direct product.\\<close>"], ["", "lemma (in group) IDirProd_comm:\n  \"IDirProd G A B = IDirProd G B A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IDirProd G A B = IDirProd G B A", "unfolding IDirProd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. generate G (A \\<union> B) = generate G (B \\<union> A)", "by (simp add: sup_commute)"], ["", "lemma (in group) IDirProd_empty_right:\n  assumes \"A \\<subseteq> carrier G\"\n  shows \"IDirProd G A {} = generate G A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IDirProd G A {} = generate G A", "unfolding IDirProd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. generate G (A \\<union> {}) = generate G A", "by simp"], ["", "lemma (in group) IDirProd_empty_left:\n  assumes \"A \\<subseteq> carrier G\"\n  shows \"IDirProd G {} A = generate G A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IDirProd G {} A = generate G A", "unfolding IDirProd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. generate G ({} \\<union> A) = generate G A", "by simp"], ["", "lemma (in group) IDirProd_one_right:\n  assumes \"A \\<subseteq> carrier G\"\n  shows \"IDirProd G A {\\<one>} = generate G A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IDirProd G A {\\<one>} = generate G A", "unfolding IDirProd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. generate G (A \\<union> {\\<one>}) = generate G A", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. generate G (A \\<union> {\\<one>}) \\<subseteq> generate G A\n 2. generate G A \\<subseteq> generate G (A \\<union> {\\<one>})", "interpret sA: subgroup \"(generate G A)\" G"], ["proof (prove)\ngoal (1 subgoal):\n 1. subgroup (generate G A) G", "using assms generate_is_subgroup"], ["proof (prove)\nusing this:\n  A \\<subseteq> carrier G\n  ?H \\<subseteq> carrier G \\<Longrightarrow> subgroup (generate G ?H) G\n\ngoal (1 subgoal):\n 1. subgroup (generate G A) G", "by simp"], ["proof (state)\ngoal (2 subgoals):\n 1. generate G (A \\<union> {\\<one>}) \\<subseteq> generate G A\n 2. generate G A \\<subseteq> generate G (A \\<union> {\\<one>})", "interpret sAone: subgroup \"(generate G (A \\<union> {\\<one>}))\" G"], ["proof (prove)\ngoal (1 subgoal):\n 1. subgroup (generate G (A \\<union> {\\<one>})) G", "using assms generate_is_subgroup"], ["proof (prove)\nusing this:\n  A \\<subseteq> carrier G\n  ?H \\<subseteq> carrier G \\<Longrightarrow> subgroup (generate G ?H) G\n\ngoal (1 subgoal):\n 1. subgroup (generate G (A \\<union> {\\<one>})) G", "by simp"], ["proof (state)\ngoal (2 subgoals):\n 1. generate G (A \\<union> {\\<one>}) \\<subseteq> generate G A\n 2. generate G A \\<subseteq> generate G (A \\<union> {\\<one>})", "show \"generate G (A \\<union> {\\<one>}) \\<subseteq> generate G A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generate G (A \\<union> {\\<one>}) \\<subseteq> generate G A", "using generate_subgroup_incl[of \"A \\<union> {\\<one>}\" \"generate G A\"]\n          generate.incl assms sA.one_closed sA.subgroup_axioms"], ["proof (prove)\nusing this:\n  \\<lbrakk>A \\<union> {\\<one>} \\<subseteq> generate G A;\n   subgroup (generate G A) G\\<rbrakk>\n  \\<Longrightarrow> generate G (A \\<union> {\\<one>})\n                    \\<subseteq> generate G A\n  ?h \\<in> ?H \\<Longrightarrow> ?h \\<in> generate ?G ?H\n  A \\<subseteq> carrier G\n  \\<one> \\<in> generate G A\n  subgroup (generate G A) G\n\ngoal (1 subgoal):\n 1. generate G (A \\<union> {\\<one>}) \\<subseteq> generate G A", "by fast"], ["proof (state)\nthis:\n  generate G (A \\<union> {\\<one>}) \\<subseteq> generate G A\n\ngoal (1 subgoal):\n 1. generate G A \\<subseteq> generate G (A \\<union> {\\<one>})", "show \"generate G A \\<subseteq> generate G (A \\<union> {\\<one>})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generate G A \\<subseteq> generate G (A \\<union> {\\<one>})", "using mono_generate[of A \"A \\<union> {\\<one>}\"]"], ["proof (prove)\nusing this:\n  A \\<subseteq> A \\<union> {\\<one>} \\<Longrightarrow>\n  generate G A \\<subseteq> generate G (A \\<union> {\\<one>})\n\ngoal (1 subgoal):\n 1. generate G A \\<subseteq> generate G (A \\<union> {\\<one>})", "by blast"], ["proof (state)\nthis:\n  generate G A \\<subseteq> generate G (A \\<union> {\\<one>})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in group) IDirProd_one_left:\n  assumes \"A \\<subseteq> carrier G\"\n  shows \"IDirProd G {\\<one>} A = generate G A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IDirProd G {\\<one>} A = generate G A", "using IDirProd_one_right[of A] assms"], ["proof (prove)\nusing this:\n  A \\<subseteq> carrier G \\<Longrightarrow>\n  IDirProd G A {\\<one>} = generate G A\n  A \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. IDirProd G {\\<one>} A = generate G A", "unfolding IDirProd_def"], ["proof (prove)\nusing this:\n  A \\<subseteq> carrier G \\<Longrightarrow>\n  generate G (A \\<union> {\\<one>}) = generate G A\n  A \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. generate G ({\\<one>} \\<union> A) = generate G A", "by force"], ["", "lemma (in group) IDirProd_is_subgroup:\n  assumes \"Y \\<subseteq> carrier G\" \"Z \\<subseteq> carrier G\"\n  shows \"subgroup (IDirProd G Y Z) G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subgroup (IDirProd G Y Z) G", "unfolding IDirProd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. subgroup (generate G (Y \\<union> Z)) G", "using generate_is_subgroup[of \"Y \\<union> Z\"] assms"], ["proof (prove)\nusing this:\n  Y \\<union> Z \\<subseteq> carrier G \\<Longrightarrow>\n  subgroup (generate G (Y \\<union> Z)) G\n  Y \\<subseteq> carrier G\n  Z \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. subgroup (generate G (Y \\<union> Z)) G", "by simp"], ["", "text \\<open>Using the theory about set multiplication we can also show the connection of the underlying\nset in the internal direct product with the set multiplication in the case of an abelian group.\nTogether with the facts about complementarity and the set multiplication we can characterize\ncomplementarity by the cardinality of the internal direct product and vice versa.\\<close>"], ["", "lemma (in comm_group) IDirProd_eq_subgroup_mult:\n  assumes \"subgroup H G\" \"subgroup J G\"\n  shows \"IDirProd G H J = H <#> J\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IDirProd G H J = H <#> J", "unfolding IDirProd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. generate G (H \\<union> J) = H <#> J", "by (rule set_mult_eq_generate_subgroup[OF assms])"], ["", "lemma (in comm_group) finite_sub_comp_iff_card_eq_IDirProd:\n  assumes \"subgroup H G\" \"subgroup J G\" \"finite H\" \"finite J\"\n  shows \"card (IDirProd G H J) = card J * card H  \\<longleftrightarrow> complementary H J\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (card (IDirProd G H J) = card J * card H) = complementary H J", "using finite_sub_comp_iff_card_eq_mult IDirProd_eq_subgroup_mult assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>subgroup ?H G; subgroup ?J G; finite ?H; finite ?J\\<rbrakk>\n  \\<Longrightarrow> (card (?H <#> ?J) = card ?J * card ?H) =\n                    complementary ?H ?J\n  \\<lbrakk>subgroup ?H G; subgroup ?J G\\<rbrakk>\n  \\<Longrightarrow> IDirProd G ?H ?J = ?H <#> ?J\n  subgroup H G\n  subgroup J G\n  finite H\n  finite J\n\ngoal (1 subgoal):\n 1. (card (IDirProd G H J) = card J * card H) = complementary H J", "by presburger"], ["", "subsection \\<open>\\<open>IDirProds\\<close> - indexed internal direct product\\<close>"], ["", "text \\<open>The indexed version of the internal direct product acting on a family of subgroups.\\<close>"], ["", "definition IDirProds :: \"('a, 'b) monoid_scheme \\<Rightarrow> ('c \\<Rightarrow> 'a set) \\<Rightarrow> 'c set \\<Rightarrow> 'a set\" where\n  \"IDirProds G S I = generate G (\\<Union>(S ` I))\""], ["", "text \\<open>Lemmas about the indexed internal direct product.\\<close>"], ["", "lemma (in group) IDirProds_incl:\n  assumes \"i \\<in> I\"\n  shows \"S i \\<subseteq> IDirProds G S I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S i \\<subseteq> IDirProds G S I", "unfolding IDirProds_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. S i \\<subseteq> generate G (\\<Union> (S ` I))", "using assms generate.incl[of _ \"\\<Union>(S ` I)\" G]"], ["proof (prove)\nusing this:\n  i \\<in> I\n  ?h \\<in> \\<Union> (S ` I) \\<Longrightarrow>\n  ?h \\<in> generate G (\\<Union> (S ` I))\n\ngoal (1 subgoal):\n 1. S i \\<subseteq> generate G (\\<Union> (S ` I))", "by blast"], ["", "lemma (in group) IDirProds_empty:\n  \"IDirProds G S {} = {\\<one>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IDirProds G S {} = {\\<one>}", "unfolding IDirProds_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. generate G (\\<Union> (S ` {})) = {\\<one>}", "using generate_empty"], ["proof (prove)\nusing this:\n  generate G {} = {\\<one>}\n\ngoal (1 subgoal):\n 1. generate G (\\<Union> (S ` {})) = {\\<one>}", "by simp"], ["", "lemma (in group) IDirProds_is_subgroup:\n  assumes \"\\<Union>(S ` I) \\<subseteq> (carrier G)\"\n  shows \"subgroup (IDirProds G S I) G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subgroup (IDirProds G S I) G", "unfolding IDirProds_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. subgroup (generate G (\\<Union> (S ` I))) G", "using generate_is_subgroup[of \"\\<Union>(S ` I)\"] assms"], ["proof (prove)\nusing this:\n  \\<Union> (S ` I) \\<subseteq> carrier G \\<Longrightarrow>\n  subgroup (generate G (\\<Union> (S ` I))) G\n  \\<Union> (S ` I) \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. subgroup (generate G (\\<Union> (S ` I))) G", "by auto"], ["", "lemma (in group) IDirProds_subgroup_id: \"subgroup (S i) G \\<Longrightarrow> IDirProds G S {i} = S i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subgroup (S i) G \\<Longrightarrow> IDirProds G S {i} = S i", "by (simp add: generate_subgroup_id IDirProds_def)"], ["", "lemma (in comm_group) IDirProds_Un:\n  assumes \"\\<forall>i\\<in>A. subgroup (S i) G\" \"\\<forall>j\\<in>B. subgroup (S j) G\"\n  shows   \"IDirProds G S (A \\<union> B) = IDirProds G S A <#> IDirProds G S B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IDirProds G S (A \\<union> B) = IDirProds G S A <#> IDirProds G S B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. IDirProds G S (A \\<union> B) = IDirProds G S A <#> IDirProds G S B", "have subset: \"\\<Union> (S ` A) \\<subseteq> carrier G\" \"\\<Union> (S ` B) \\<subseteq> carrier G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (S ` A) \\<subseteq> carrier G &&&\n    \\<Union> (S ` B) \\<subseteq> carrier G", "using subgroup.subset assms(1, 2)"], ["proof (prove)\nusing this:\n  subgroup ?H ?G \\<Longrightarrow> ?H \\<subseteq> carrier ?G\n  \\<forall>i\\<in>A. subgroup (S i) G\n  \\<forall>j\\<in>B. subgroup (S j) G\n\ngoal (1 subgoal):\n 1. \\<Union> (S ` A) \\<subseteq> carrier G &&&\n    \\<Union> (S ` B) \\<subseteq> carrier G", "by blast+"], ["proof (state)\nthis:\n  \\<Union> (S ` A) \\<subseteq> carrier G\n  \\<Union> (S ` B) \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. IDirProds G S (A \\<union> B) = IDirProds G S A <#> IDirProds G S B", "have \"IDirProds G S A <#> IDirProds G S B = IDirProd G (IDirProds G S A) (IDirProds G S B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IDirProds G S A <#> IDirProds G S B =\n    IDirProd G (IDirProds G S A) (IDirProds G S B)", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>A. subgroup (S i) G\n  \\<forall>j\\<in>B. subgroup (S j) G\n\ngoal (1 subgoal):\n 1. IDirProds G S A <#> IDirProds G S B =\n    IDirProd G (IDirProds G S A) (IDirProds G S B)", "by (intro IDirProd_eq_subgroup_mult [symmetric] IDirProds_is_subgroup subset)"], ["proof (state)\nthis:\n  IDirProds G S A <#> IDirProds G S B =\n  IDirProd G (IDirProds G S A) (IDirProds G S B)\n\ngoal (1 subgoal):\n 1. IDirProds G S (A \\<union> B) = IDirProds G S A <#> IDirProds G S B", "also"], ["proof (state)\nthis:\n  IDirProds G S A <#> IDirProds G S B =\n  IDirProd G (IDirProds G S A) (IDirProds G S B)\n\ngoal (1 subgoal):\n 1. IDirProds G S (A \\<union> B) = IDirProds G S A <#> IDirProds G S B", "have \"\\<dots> = generate G (\\<Union> (S ` A) \\<union> IDirProds G S B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IDirProd G (IDirProds G S A) (IDirProds G S B) =\n    generate G (\\<Union> (S ` A) \\<union> IDirProds G S B)", "unfolding IDirProds_def IDirProd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. generate G\n     (generate G (\\<Union> (S ` A)) \\<union>\n      generate G (\\<Union> (S ` B))) =\n    generate G (\\<Union> (S ` A) \\<union> generate G (\\<Union> (S ` B)))", "by (intro generate_idem' generate_incl subset)"], ["proof (state)\nthis:\n  IDirProd G (IDirProds G S A) (IDirProds G S B) =\n  generate G (\\<Union> (S ` A) \\<union> IDirProds G S B)\n\ngoal (1 subgoal):\n 1. IDirProds G S (A \\<union> B) = IDirProds G S A <#> IDirProds G S B", "also"], ["proof (state)\nthis:\n  IDirProd G (IDirProds G S A) (IDirProds G S B) =\n  generate G (\\<Union> (S ` A) \\<union> IDirProds G S B)\n\ngoal (1 subgoal):\n 1. IDirProds G S (A \\<union> B) = IDirProds G S A <#> IDirProds G S B", "have \"\\<dots> = generate G (\\<Union>(S ` A) \\<union> \\<Union>(S ` B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generate G (\\<Union> (S ` A) \\<union> IDirProds G S B) =\n    generate G (\\<Union> (S ` A) \\<union> \\<Union> (S ` B))", "unfolding IDirProds_def IDirProd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. generate G (\\<Union> (S ` A) \\<union> generate G (\\<Union> (S ` B))) =\n    generate G (\\<Union> (S ` A) \\<union> \\<Union> (S ` B))", "by (intro generate_idem'_right generate_incl subset)"], ["proof (state)\nthis:\n  generate G (\\<Union> (S ` A) \\<union> IDirProds G S B) =\n  generate G (\\<Union> (S ` A) \\<union> \\<Union> (S ` B))\n\ngoal (1 subgoal):\n 1. IDirProds G S (A \\<union> B) = IDirProds G S A <#> IDirProds G S B", "also"], ["proof (state)\nthis:\n  generate G (\\<Union> (S ` A) \\<union> IDirProds G S B) =\n  generate G (\\<Union> (S ` A) \\<union> \\<Union> (S ` B))\n\ngoal (1 subgoal):\n 1. IDirProds G S (A \\<union> B) = IDirProds G S A <#> IDirProds G S B", "have \"\\<Union>(S ` A) \\<union> \\<Union>(S ` B) = \\<Union>(S ` (A \\<union> B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (S ` A) \\<union> \\<Union> (S ` B) =\n    \\<Union> (S ` (A \\<union> B))", "by blast"], ["proof (state)\nthis:\n  \\<Union> (S ` A) \\<union> \\<Union> (S ` B) = \\<Union> (S ` (A \\<union> B))\n\ngoal (1 subgoal):\n 1. IDirProds G S (A \\<union> B) = IDirProds G S A <#> IDirProds G S B", "also"], ["proof (state)\nthis:\n  \\<Union> (S ` A) \\<union> \\<Union> (S ` B) = \\<Union> (S ` (A \\<union> B))\n\ngoal (1 subgoal):\n 1. IDirProds G S (A \\<union> B) = IDirProds G S A <#> IDirProds G S B", "have \"generate G \\<dots> = IDirProds G S (A \\<union> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generate G (\\<Union> (S ` (A \\<union> B))) =\n    IDirProds G S (A \\<union> B)", "unfolding IDirProds_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. generate G (\\<Union> (S ` (A \\<union> B))) =\n    generate G (\\<Union> (S ` (A \\<union> B)))", ".."], ["proof (state)\nthis:\n  generate G (\\<Union> (S ` (A \\<union> B))) = IDirProds G S (A \\<union> B)\n\ngoal (1 subgoal):\n 1. IDirProds G S (A \\<union> B) = IDirProds G S A <#> IDirProds G S B", "finally"], ["proof (chain)\npicking this:\n  IDirProds G S A <#> IDirProds G S B = IDirProds G S (A \\<union> B)", "show ?thesis"], ["proof (prove)\nusing this:\n  IDirProds G S A <#> IDirProds G S B = IDirProds G S (A \\<union> B)\n\ngoal (1 subgoal):\n 1. IDirProds G S (A \\<union> B) = IDirProds G S A <#> IDirProds G S B", ".."], ["proof (state)\nthis:\n  IDirProds G S (A \\<union> B) = IDirProds G S A <#> IDirProds G S B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in comm_group) IDirProds_finite:\n  assumes \"finite I\" \"\\<forall>i\\<in>I. subgroup (S i) G\" \"\\<forall>i\\<in>I. finite (S i)\"\n  shows \"finite (IDirProds G S I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (IDirProds G S I)", "using assms"], ["proof (prove)\nusing this:\n  finite I\n  \\<forall>i\\<in>I. subgroup (S i) G\n  \\<forall>i\\<in>I. finite (S i)\n\ngoal (1 subgoal):\n 1. finite (IDirProds G S I)", "proof (induction I rule: finite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>i\\<in>{}. subgroup (S i) G;\n     \\<forall>i\\<in>{}. finite (S i)\\<rbrakk>\n    \\<Longrightarrow> finite (IDirProds G S {})\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>i\\<in>F. subgroup (S i) G;\n         \\<forall>i\\<in>F. finite (S i)\\<rbrakk>\n        \\<Longrightarrow> finite (IDirProds G S F);\n        \\<forall>i\\<in>insert x F. subgroup (S i) G;\n        \\<forall>i\\<in>insert x F. finite (S i)\\<rbrakk>\n       \\<Longrightarrow> finite (IDirProds G S (insert x F))", "case empty"], ["proof (state)\nthis:\n  \\<forall>i\\<in>{}. subgroup (S i) G\n  \\<forall>i\\<in>{}. finite (S i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>i\\<in>{}. subgroup (S i) G;\n     \\<forall>i\\<in>{}. finite (S i)\\<rbrakk>\n    \\<Longrightarrow> finite (IDirProds G S {})\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>i\\<in>F. subgroup (S i) G;\n         \\<forall>i\\<in>F. finite (S i)\\<rbrakk>\n        \\<Longrightarrow> finite (IDirProds G S F);\n        \\<forall>i\\<in>insert x F. subgroup (S i) G;\n        \\<forall>i\\<in>insert x F. finite (S i)\\<rbrakk>\n       \\<Longrightarrow> finite (IDirProds G S (insert x F))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>{}. subgroup (S i) G\n  \\<forall>i\\<in>{}. finite (S i)\n\ngoal (1 subgoal):\n 1. finite (IDirProds G S {})", "using IDirProds_empty[of S]"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>{}. subgroup (S i) G\n  \\<forall>i\\<in>{}. finite (S i)\n  IDirProds G S {} = {\\<one>}\n\ngoal (1 subgoal):\n 1. finite (IDirProds G S {})", "by simp"], ["proof (state)\nthis:\n  finite (IDirProds G S {})\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>i\\<in>F. subgroup (S i) G;\n         \\<forall>i\\<in>F. finite (S i)\\<rbrakk>\n        \\<Longrightarrow> finite (IDirProds G S F);\n        \\<forall>i\\<in>insert x F. subgroup (S i) G;\n        \\<forall>i\\<in>insert x F. finite (S i)\\<rbrakk>\n       \\<Longrightarrow> finite (IDirProds G S (insert x F))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>i\\<in>F. subgroup (S i) G;\n         \\<forall>i\\<in>F. finite (S i)\\<rbrakk>\n        \\<Longrightarrow> finite (IDirProds G S F);\n        \\<forall>i\\<in>insert x F. subgroup (S i) G;\n        \\<forall>i\\<in>insert x F. finite (S i)\\<rbrakk>\n       \\<Longrightarrow> finite (IDirProds G S (insert x F))", "case i: (insert x I)"], ["proof (state)\nthis:\n  finite I\n  x \\<notin> I\n  \\<lbrakk>\\<forall>i\\<in>I. subgroup (S i) G;\n   \\<forall>i\\<in>I. finite (S i)\\<rbrakk>\n  \\<Longrightarrow> finite (IDirProds G S I)\n  \\<forall>i\\<in>insert x I. subgroup (S i) G\n  \\<forall>i\\<in>insert x I. finite (S i)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>i\\<in>F. subgroup (S i) G;\n         \\<forall>i\\<in>F. finite (S i)\\<rbrakk>\n        \\<Longrightarrow> finite (IDirProds G S F);\n        \\<forall>i\\<in>insert x F. subgroup (S i) G;\n        \\<forall>i\\<in>insert x F. finite (S i)\\<rbrakk>\n       \\<Longrightarrow> finite (IDirProds G S (insert x F))", "interpret Sx: subgroup \"S x\" G"], ["proof (prove)\ngoal (1 subgoal):\n 1. subgroup (S x) G", "using i"], ["proof (prove)\nusing this:\n  finite I\n  x \\<notin> I\n  \\<lbrakk>\\<forall>i\\<in>I. subgroup (S i) G;\n   \\<forall>i\\<in>I. finite (S i)\\<rbrakk>\n  \\<Longrightarrow> finite (IDirProds G S I)\n  \\<forall>i\\<in>insert x I. subgroup (S i) G\n  \\<forall>i\\<in>insert x I. finite (S i)\n\ngoal (1 subgoal):\n 1. subgroup (S x) G", "by blast"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>i\\<in>F. subgroup (S i) G;\n         \\<forall>i\\<in>F. finite (S i)\\<rbrakk>\n        \\<Longrightarrow> finite (IDirProds G S F);\n        \\<forall>i\\<in>insert x F. subgroup (S i) G;\n        \\<forall>i\\<in>insert x F. finite (S i)\\<rbrakk>\n       \\<Longrightarrow> finite (IDirProds G S (insert x F))", "have cx: \"(S x) \\<subseteq> carrier G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S x \\<subseteq> carrier G", "by force"], ["proof (state)\nthis:\n  S x \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>i\\<in>F. subgroup (S i) G;\n         \\<forall>i\\<in>F. finite (S i)\\<rbrakk>\n        \\<Longrightarrow> finite (IDirProds G S F);\n        \\<forall>i\\<in>insert x F. subgroup (S i) G;\n        \\<forall>i\\<in>insert x F. finite (S i)\\<rbrakk>\n       \\<Longrightarrow> finite (IDirProds G S (insert x F))", "have cI: \"\\<Union>(S ` I) \\<subseteq> carrier G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (S ` I) \\<subseteq> carrier G", "using i subgroup.subset"], ["proof (prove)\nusing this:\n  finite I\n  x \\<notin> I\n  \\<lbrakk>\\<forall>i\\<in>I. subgroup (S i) G;\n   \\<forall>i\\<in>I. finite (S i)\\<rbrakk>\n  \\<Longrightarrow> finite (IDirProds G S I)\n  \\<forall>i\\<in>insert x I. subgroup (S i) G\n  \\<forall>i\\<in>insert x I. finite (S i)\n  subgroup ?H ?G \\<Longrightarrow> ?H \\<subseteq> carrier ?G\n\ngoal (1 subgoal):\n 1. \\<Union> (S ` I) \\<subseteq> carrier G", "by blast"], ["proof (state)\nthis:\n  \\<Union> (S ` I) \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>i\\<in>F. subgroup (S i) G;\n         \\<forall>i\\<in>F. finite (S i)\\<rbrakk>\n        \\<Longrightarrow> finite (IDirProds G S F);\n        \\<forall>i\\<in>insert x F. subgroup (S i) G;\n        \\<forall>i\\<in>insert x F. finite (S i)\\<rbrakk>\n       \\<Longrightarrow> finite (IDirProds G S (insert x F))", "interpret subgroup \"IDirProds G S I\" G"], ["proof (prove)\ngoal (1 subgoal):\n 1. subgroup (IDirProds G S I) G", "using IDirProds_is_subgroup[OF cI]"], ["proof (prove)\nusing this:\n  subgroup (IDirProds G S I) G\n\ngoal (1 subgoal):\n 1. subgroup (IDirProds G S I) G", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>i\\<in>F. subgroup (S i) G;\n         \\<forall>i\\<in>F. finite (S i)\\<rbrakk>\n        \\<Longrightarrow> finite (IDirProds G S F);\n        \\<forall>i\\<in>insert x F. subgroup (S i) G;\n        \\<forall>i\\<in>insert x F. finite (S i)\\<rbrakk>\n       \\<Longrightarrow> finite (IDirProds G S (insert x F))", "have cIP: \"(IDirProds G S I) \\<subseteq> carrier G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IDirProds G S I \\<subseteq> carrier G", "by force"], ["proof (state)\nthis:\n  IDirProds G S I \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>i\\<in>F. subgroup (S i) G;\n         \\<forall>i\\<in>F. finite (S i)\\<rbrakk>\n        \\<Longrightarrow> finite (IDirProds G S F);\n        \\<forall>i\\<in>insert x F. subgroup (S i) G;\n        \\<forall>i\\<in>insert x F. finite (S i)\\<rbrakk>\n       \\<Longrightarrow> finite (IDirProds G S (insert x F))", "from i"], ["proof (chain)\npicking this:\n  finite I\n  x \\<notin> I\n  \\<lbrakk>\\<forall>i\\<in>I. subgroup (S i) G;\n   \\<forall>i\\<in>I. finite (S i)\\<rbrakk>\n  \\<Longrightarrow> finite (IDirProds G S I)\n  \\<forall>i\\<in>insert x I. subgroup (S i) G\n  \\<forall>i\\<in>insert x I. finite (S i)", "have f: \"finite (S x)\" \"finite (IDirProds G S I)\" \"finite {x}\""], ["proof (prove)\nusing this:\n  finite I\n  x \\<notin> I\n  \\<lbrakk>\\<forall>i\\<in>I. subgroup (S i) G;\n   \\<forall>i\\<in>I. finite (S i)\\<rbrakk>\n  \\<Longrightarrow> finite (IDirProds G S I)\n  \\<forall>i\\<in>insert x I. subgroup (S i) G\n  \\<forall>i\\<in>insert x I. finite (S i)\n\ngoal (1 subgoal):\n 1. finite (S x) &&& finite (IDirProds G S I) &&& finite {x}", "by blast+"], ["proof (state)\nthis:\n  finite (S x)\n  finite (IDirProds G S I)\n  finite {x}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>i\\<in>F. subgroup (S i) G;\n         \\<forall>i\\<in>F. finite (S i)\\<rbrakk>\n        \\<Longrightarrow> finite (IDirProds G S F);\n        \\<forall>i\\<in>insert x F. subgroup (S i) G;\n        \\<forall>i\\<in>insert x F. finite (S i)\\<rbrakk>\n       \\<Longrightarrow> finite (IDirProds G S (insert x F))", "from IDirProds_Un[of \"{x}\" S I]"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>i\\<in>{x}. subgroup (S i) G;\n   \\<forall>j\\<in>I. subgroup (S j) G\\<rbrakk>\n  \\<Longrightarrow> IDirProds G S ({x} \\<union> I) =\n                    IDirProds G S {x} <#> IDirProds G S I", "have \"IDirProds G S ({x} \\<union> I) = IDirProds G S {x} <#> IDirProds G S I\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>i\\<in>{x}. subgroup (S i) G;\n   \\<forall>j\\<in>I. subgroup (S j) G\\<rbrakk>\n  \\<Longrightarrow> IDirProds G S ({x} \\<union> I) =\n                    IDirProds G S {x} <#> IDirProds G S I\n\ngoal (1 subgoal):\n 1. IDirProds G S ({x} \\<union> I) = IDirProds G S {x} <#> IDirProds G S I", "using i"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>i\\<in>{x}. subgroup (S i) G;\n   \\<forall>j\\<in>I. subgroup (S j) G\\<rbrakk>\n  \\<Longrightarrow> IDirProds G S ({x} \\<union> I) =\n                    IDirProds G S {x} <#> IDirProds G S I\n  finite I\n  x \\<notin> I\n  \\<lbrakk>\\<forall>i\\<in>I. subgroup (S i) G;\n   \\<forall>i\\<in>I. finite (S i)\\<rbrakk>\n  \\<Longrightarrow> finite (IDirProds G S I)\n  \\<forall>i\\<in>insert x I. subgroup (S i) G\n  \\<forall>i\\<in>insert x I. finite (S i)\n\ngoal (1 subgoal):\n 1. IDirProds G S ({x} \\<union> I) = IDirProds G S {x} <#> IDirProds G S I", "by blast"], ["proof (state)\nthis:\n  IDirProds G S ({x} \\<union> I) = IDirProds G S {x} <#> IDirProds G S I\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>i\\<in>F. subgroup (S i) G;\n         \\<forall>i\\<in>F. finite (S i)\\<rbrakk>\n        \\<Longrightarrow> finite (IDirProds G S F);\n        \\<forall>i\\<in>insert x F. subgroup (S i) G;\n        \\<forall>i\\<in>insert x F. finite (S i)\\<rbrakk>\n       \\<Longrightarrow> finite (IDirProds G S (insert x F))", "also"], ["proof (state)\nthis:\n  IDirProds G S ({x} \\<union> I) = IDirProds G S {x} <#> IDirProds G S I\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>i\\<in>F. subgroup (S i) G;\n         \\<forall>i\\<in>F. finite (S i)\\<rbrakk>\n        \\<Longrightarrow> finite (IDirProds G S F);\n        \\<forall>i\\<in>insert x F. subgroup (S i) G;\n        \\<forall>i\\<in>insert x F. finite (S i)\\<rbrakk>\n       \\<Longrightarrow> finite (IDirProds G S (insert x F))", "have \"\\<dots> = S x <#> IDirProds G S I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IDirProds G S {x} <#> IDirProds G S I = S x <#> IDirProds G S I", "using IDirProds_subgroup_id[of S x] Sx.subgroup_axioms"], ["proof (prove)\nusing this:\n  subgroup (S x) G \\<Longrightarrow> IDirProds G S {x} = S x\n  subgroup (S x) G\n\ngoal (1 subgoal):\n 1. IDirProds G S {x} <#> IDirProds G S I = S x <#> IDirProds G S I", "by force"], ["proof (state)\nthis:\n  IDirProds G S {x} <#> IDirProds G S I = S x <#> IDirProds G S I\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>i\\<in>F. subgroup (S i) G;\n         \\<forall>i\\<in>F. finite (S i)\\<rbrakk>\n        \\<Longrightarrow> finite (IDirProds G S F);\n        \\<forall>i\\<in>insert x F. subgroup (S i) G;\n        \\<forall>i\\<in>insert x F. finite (S i)\\<rbrakk>\n       \\<Longrightarrow> finite (IDirProds G S (insert x F))", "also"], ["proof (state)\nthis:\n  IDirProds G S {x} <#> IDirProds G S I = S x <#> IDirProds G S I\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>i\\<in>F. subgroup (S i) G;\n         \\<forall>i\\<in>F. finite (S i)\\<rbrakk>\n        \\<Longrightarrow> finite (IDirProds G S F);\n        \\<forall>i\\<in>insert x F. subgroup (S i) G;\n        \\<forall>i\\<in>insert x F. finite (S i)\\<rbrakk>\n       \\<Longrightarrow> finite (IDirProds G S (insert x F))", "have \"finite (\\<dots>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (S x <#> IDirProds G S I)", "using set_mult_finite[OF f(1, 2) cx cIP]"], ["proof (prove)\nusing this:\n  finite (S x <#> IDirProds G S I)\n\ngoal (1 subgoal):\n 1. finite (S x <#> IDirProds G S I)", "."], ["proof (state)\nthis:\n  finite (S x <#> IDirProds G S I)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>i\\<in>F. subgroup (S i) G;\n         \\<forall>i\\<in>F. finite (S i)\\<rbrakk>\n        \\<Longrightarrow> finite (IDirProds G S F);\n        \\<forall>i\\<in>insert x F. subgroup (S i) G;\n        \\<forall>i\\<in>insert x F. finite (S i)\\<rbrakk>\n       \\<Longrightarrow> finite (IDirProds G S (insert x F))", "finally"], ["proof (chain)\npicking this:\n  finite (IDirProds G S ({x} \\<union> I))", "show ?case"], ["proof (prove)\nusing this:\n  finite (IDirProds G S ({x} \\<union> I))\n\ngoal (1 subgoal):\n 1. finite (IDirProds G S (insert x I))", "unfolding insert_def"], ["proof (prove)\nusing this:\n  finite (IDirProds G S ({xa. xa = x} \\<union> {} \\<union> I))\n\ngoal (1 subgoal):\n 1. finite (IDirProds G S ({xa. xa = x} \\<union> I))", "by simp"], ["proof (state)\nthis:\n  finite (IDirProds G S (insert x I))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in comm_group) IDirProds_compl_imp_compl:\n  assumes \"\\<forall>i \\<in> I. subgroup (S i) G\" and \"subgroup H G\"\n  assumes \"complementary H (IDirProds G S I)\" \"i \\<in> I\"\n  shows   \"complementary H (S i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complementary H (S i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. complementary H (S i)", "have \"S i \\<subseteq> IDirProds G S I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S i \\<subseteq> IDirProds G S I", "using assms IDirProds_incl"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>I. subgroup (S i) G\n  subgroup H G\n  complementary H (IDirProds G S I)\n  i \\<in> I\n  ?i \\<in> ?I \\<Longrightarrow> ?S ?i \\<subseteq> IDirProds G ?S ?I\n\ngoal (1 subgoal):\n 1. S i \\<subseteq> IDirProds G S I", "by fast"], ["proof (state)\nthis:\n  S i \\<subseteq> IDirProds G S I\n\ngoal (1 subgoal):\n 1. complementary H (S i)", "then"], ["proof (chain)\npicking this:\n  S i \\<subseteq> IDirProds G S I", "have \"H \\<inter> (S i) \\<subseteq> H \\<inter> IDirProds G S I\""], ["proof (prove)\nusing this:\n  S i \\<subseteq> IDirProds G S I\n\ngoal (1 subgoal):\n 1. H \\<inter> S i \\<subseteq> H \\<inter> IDirProds G S I", "by blast"], ["proof (state)\nthis:\n  H \\<inter> S i \\<subseteq> H \\<inter> IDirProds G S I\n\ngoal (1 subgoal):\n 1. complementary H (S i)", "moreover"], ["proof (state)\nthis:\n  H \\<inter> S i \\<subseteq> H \\<inter> IDirProds G S I\n\ngoal (1 subgoal):\n 1. complementary H (S i)", "have \"\\<one> \\<in> H \\<inter> (S i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<one> \\<in> H \\<inter> S i", "using subgroup.one_closed assms"], ["proof (prove)\nusing this:\n  subgroup ?H ?G \\<Longrightarrow> \\<one>\\<^bsub>?G\\<^esub> \\<in> ?H\n  \\<forall>i\\<in>I. subgroup (S i) G\n  subgroup H G\n  complementary H (IDirProds G S I)\n  i \\<in> I\n\ngoal (1 subgoal):\n 1. \\<one> \\<in> H \\<inter> S i", "by auto"], ["proof (state)\nthis:\n  \\<one> \\<in> H \\<inter> S i\n\ngoal (1 subgoal):\n 1. complementary H (S i)", "ultimately"], ["proof (chain)\npicking this:\n  H \\<inter> S i \\<subseteq> H \\<inter> IDirProds G S I\n  \\<one> \\<in> H \\<inter> S i", "show \"complementary H (S i)\""], ["proof (prove)\nusing this:\n  H \\<inter> S i \\<subseteq> H \\<inter> IDirProds G S I\n  \\<one> \\<in> H \\<inter> S i\n\ngoal (1 subgoal):\n 1. complementary H (S i)", "using assms(3)"], ["proof (prove)\nusing this:\n  H \\<inter> S i \\<subseteq> H \\<inter> IDirProds G S I\n  \\<one> \\<in> H \\<inter> S i\n  complementary H (IDirProds G S I)\n\ngoal (1 subgoal):\n 1. complementary H (S i)", "unfolding complementary_def"], ["proof (prove)\nusing this:\n  H \\<inter> S i \\<subseteq> H \\<inter> IDirProds G S I\n  \\<one> \\<in> H \\<inter> S i\n  H \\<inter> IDirProds G S I = {\\<one>}\n\ngoal (1 subgoal):\n 1. H \\<inter> S i = {\\<one>}", "by blast"], ["proof (state)\nthis:\n  complementary H (S i)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Using the knowledge about the binary internal direct product, we can - in case that all\nsubgroups in the family have coprime orders - also derive the cardinality of the indexed internal\ndirect product.\\<close>"], ["", "lemma (in comm_group) IDirProds_card:\n  assumes \"finite I\" \"\\<forall>i\\<in>I. subgroup (S i) G\"\n          \"\\<forall>i\\<in>I. finite (S i)\" \"pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y))) I\"\n  shows \"card (IDirProds G S I) = (\\<Prod>i \\<in> I. card (S i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (IDirProds G S I) = (\\<Prod>i\\<in>I. card (S i))", "using assms"], ["proof (prove)\nusing this:\n  finite I\n  \\<forall>i\\<in>I. subgroup (S i) G\n  \\<forall>i\\<in>I. finite (S i)\n  pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y))) I\n\ngoal (1 subgoal):\n 1. card (IDirProds G S I) = (\\<Prod>i\\<in>I. card (S i))", "proof (induction I rule: finite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>i\\<in>{}. subgroup (S i) G;\n     \\<forall>i\\<in>{}. finite (S i);\n     pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y))) {}\\<rbrakk>\n    \\<Longrightarrow> card (IDirProds G S {}) =\n                      (\\<Prod>i\\<in>{}. card (S i))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>i\\<in>F. subgroup (S i) G;\n         \\<forall>i\\<in>F. finite (S i);\n         pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y)))\n          F\\<rbrakk>\n        \\<Longrightarrow> card (IDirProds G S F) =\n                          (\\<Prod>i\\<in>F. card (S i));\n        \\<forall>i\\<in>insert x F. subgroup (S i) G;\n        \\<forall>i\\<in>insert x F. finite (S i);\n        pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y)))\n         (insert x F)\\<rbrakk>\n       \\<Longrightarrow> card (IDirProds G S (insert x F)) =\n                         (\\<Prod>i\\<in>insert x F. card (S i))", "case empty"], ["proof (state)\nthis:\n  \\<forall>i\\<in>{}. subgroup (S i) G\n  \\<forall>i\\<in>{}. finite (S i)\n  pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y))) {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>i\\<in>{}. subgroup (S i) G;\n     \\<forall>i\\<in>{}. finite (S i);\n     pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y))) {}\\<rbrakk>\n    \\<Longrightarrow> card (IDirProds G S {}) =\n                      (\\<Prod>i\\<in>{}. card (S i))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>i\\<in>F. subgroup (S i) G;\n         \\<forall>i\\<in>F. finite (S i);\n         pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y)))\n          F\\<rbrakk>\n        \\<Longrightarrow> card (IDirProds G S F) =\n                          (\\<Prod>i\\<in>F. card (S i));\n        \\<forall>i\\<in>insert x F. subgroup (S i) G;\n        \\<forall>i\\<in>insert x F. finite (S i);\n        pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y)))\n         (insert x F)\\<rbrakk>\n       \\<Longrightarrow> card (IDirProds G S (insert x F)) =\n                         (\\<Prod>i\\<in>insert x F. card (S i))", "then"], ["proof (chain)\npicking this:\n  \\<forall>i\\<in>{}. subgroup (S i) G\n  \\<forall>i\\<in>{}. finite (S i)\n  pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y))) {}", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>{}. subgroup (S i) G\n  \\<forall>i\\<in>{}. finite (S i)\n  pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y))) {}\n\ngoal (1 subgoal):\n 1. card (IDirProds G S {}) = (\\<Prod>i\\<in>{}. card (S i))", "using IDirProds_empty[of S]"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>{}. subgroup (S i) G\n  \\<forall>i\\<in>{}. finite (S i)\n  pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y))) {}\n  IDirProds G S {} = {\\<one>}\n\ngoal (1 subgoal):\n 1. card (IDirProds G S {}) = (\\<Prod>i\\<in>{}. card (S i))", "by simp"], ["proof (state)\nthis:\n  card (IDirProds G S {}) = (\\<Prod>i\\<in>{}. card (S i))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>i\\<in>F. subgroup (S i) G;\n         \\<forall>i\\<in>F. finite (S i);\n         pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y)))\n          F\\<rbrakk>\n        \\<Longrightarrow> card (IDirProds G S F) =\n                          (\\<Prod>i\\<in>F. card (S i));\n        \\<forall>i\\<in>insert x F. subgroup (S i) G;\n        \\<forall>i\\<in>insert x F. finite (S i);\n        pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y)))\n         (insert x F)\\<rbrakk>\n       \\<Longrightarrow> card (IDirProds G S (insert x F)) =\n                         (\\<Prod>i\\<in>insert x F. card (S i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>i\\<in>F. subgroup (S i) G;\n         \\<forall>i\\<in>F. finite (S i);\n         pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y)))\n          F\\<rbrakk>\n        \\<Longrightarrow> card (IDirProds G S F) =\n                          (\\<Prod>i\\<in>F. card (S i));\n        \\<forall>i\\<in>insert x F. subgroup (S i) G;\n        \\<forall>i\\<in>insert x F. finite (S i);\n        pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y)))\n         (insert x F)\\<rbrakk>\n       \\<Longrightarrow> card (IDirProds G S (insert x F)) =\n                         (\\<Prod>i\\<in>insert x F. card (S i))", "case i: (insert x I)"], ["proof (state)\nthis:\n  finite I\n  x \\<notin> I\n  \\<lbrakk>\\<forall>i\\<in>I. subgroup (S i) G;\n   \\<forall>i\\<in>I. finite (S i);\n   pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y))) I\\<rbrakk>\n  \\<Longrightarrow> card (IDirProds G S I) = (\\<Prod>i\\<in>I. card (S i))\n  \\<forall>i\\<in>insert x I. subgroup (S i) G\n  \\<forall>i\\<in>insert x I. finite (S i)\n  pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y))) (insert x I)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>i\\<in>F. subgroup (S i) G;\n         \\<forall>i\\<in>F. finite (S i);\n         pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y)))\n          F\\<rbrakk>\n        \\<Longrightarrow> card (IDirProds G S F) =\n                          (\\<Prod>i\\<in>F. card (S i));\n        \\<forall>i\\<in>insert x F. subgroup (S i) G;\n        \\<forall>i\\<in>insert x F. finite (S i);\n        pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y)))\n         (insert x F)\\<rbrakk>\n       \\<Longrightarrow> card (IDirProds G S (insert x F)) =\n                         (\\<Prod>i\\<in>insert x F. card (S i))", "have sx: \"subgroup (S x) G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subgroup (S x) G", "using i(4)"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>insert x I. subgroup (S i) G\n\ngoal (1 subgoal):\n 1. subgroup (S x) G", "by blast"], ["proof (state)\nthis:\n  subgroup (S x) G\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>i\\<in>F. subgroup (S i) G;\n         \\<forall>i\\<in>F. finite (S i);\n         pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y)))\n          F\\<rbrakk>\n        \\<Longrightarrow> card (IDirProds G S F) =\n                          (\\<Prod>i\\<in>F. card (S i));\n        \\<forall>i\\<in>insert x F. subgroup (S i) G;\n        \\<forall>i\\<in>insert x F. finite (S i);\n        pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y)))\n         (insert x F)\\<rbrakk>\n       \\<Longrightarrow> card (IDirProds G S (insert x F)) =\n                         (\\<Prod>i\\<in>insert x F. card (S i))", "have cx: \"(S x) \\<subseteq> carrier G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S x \\<subseteq> carrier G", "using subgroup.subset[OF sx]"], ["proof (prove)\nusing this:\n  S x \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. S x \\<subseteq> carrier G", "."], ["proof (state)\nthis:\n  S x \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>i\\<in>F. subgroup (S i) G;\n         \\<forall>i\\<in>F. finite (S i);\n         pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y)))\n          F\\<rbrakk>\n        \\<Longrightarrow> card (IDirProds G S F) =\n                          (\\<Prod>i\\<in>F. card (S i));\n        \\<forall>i\\<in>insert x F. subgroup (S i) G;\n        \\<forall>i\\<in>insert x F. finite (S i);\n        pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y)))\n         (insert x F)\\<rbrakk>\n       \\<Longrightarrow> card (IDirProds G S (insert x F)) =\n                         (\\<Prod>i\\<in>insert x F. card (S i))", "have fx: \"finite (S x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (S x)", "using i"], ["proof (prove)\nusing this:\n  finite I\n  x \\<notin> I\n  \\<lbrakk>\\<forall>i\\<in>I. subgroup (S i) G;\n   \\<forall>i\\<in>I. finite (S i);\n   pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y))) I\\<rbrakk>\n  \\<Longrightarrow> card (IDirProds G S I) = (\\<Prod>i\\<in>I. card (S i))\n  \\<forall>i\\<in>insert x I. subgroup (S i) G\n  \\<forall>i\\<in>insert x I. finite (S i)\n  pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y))) (insert x I)\n\ngoal (1 subgoal):\n 1. finite (S x)", "by blast"], ["proof (state)\nthis:\n  finite (S x)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>i\\<in>F. subgroup (S i) G;\n         \\<forall>i\\<in>F. finite (S i);\n         pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y)))\n          F\\<rbrakk>\n        \\<Longrightarrow> card (IDirProds G S F) =\n                          (\\<Prod>i\\<in>F. card (S i));\n        \\<forall>i\\<in>insert x F. subgroup (S i) G;\n        \\<forall>i\\<in>insert x F. finite (S i);\n        pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y)))\n         (insert x F)\\<rbrakk>\n       \\<Longrightarrow> card (IDirProds G S (insert x F)) =\n                         (\\<Prod>i\\<in>insert x F. card (S i))", "have cI: \"\\<Union>(S ` I) \\<subseteq> carrier G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (S ` I) \\<subseteq> carrier G", "using subgroup.subset[of _ G] i(4)"], ["proof (prove)\nusing this:\n  subgroup ?H G \\<Longrightarrow> ?H \\<subseteq> carrier G\n  \\<forall>i\\<in>insert x I. subgroup (S i) G\n\ngoal (1 subgoal):\n 1. \\<Union> (S ` I) \\<subseteq> carrier G", "by blast"], ["proof (state)\nthis:\n  \\<Union> (S ` I) \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>i\\<in>F. subgroup (S i) G;\n         \\<forall>i\\<in>F. finite (S i);\n         pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y)))\n          F\\<rbrakk>\n        \\<Longrightarrow> card (IDirProds G S F) =\n                          (\\<Prod>i\\<in>F. card (S i));\n        \\<forall>i\\<in>insert x F. subgroup (S i) G;\n        \\<forall>i\\<in>insert x F. finite (S i);\n        pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y)))\n         (insert x F)\\<rbrakk>\n       \\<Longrightarrow> card (IDirProds G S (insert x F)) =\n                         (\\<Prod>i\\<in>insert x F. card (S i))", "from generate_is_subgroup[OF this]"], ["proof (chain)\npicking this:\n  subgroup (generate G (\\<Union> (S ` I))) G", "have sIP: \"subgroup (IDirProds G S I) G\""], ["proof (prove)\nusing this:\n  subgroup (generate G (\\<Union> (S ` I))) G\n\ngoal (1 subgoal):\n 1. subgroup (IDirProds G S I) G", "unfolding IDirProds_def"], ["proof (prove)\nusing this:\n  subgroup (generate G (\\<Union> (S ` I))) G\n\ngoal (1 subgoal):\n 1. subgroup (generate G (\\<Union> (S ` I))) G", "."], ["proof (state)\nthis:\n  subgroup (IDirProds G S I) G\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>i\\<in>F. subgroup (S i) G;\n         \\<forall>i\\<in>F. finite (S i);\n         pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y)))\n          F\\<rbrakk>\n        \\<Longrightarrow> card (IDirProds G S F) =\n                          (\\<Prod>i\\<in>F. card (S i));\n        \\<forall>i\\<in>insert x F. subgroup (S i) G;\n        \\<forall>i\\<in>insert x F. finite (S i);\n        pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y)))\n         (insert x F)\\<rbrakk>\n       \\<Longrightarrow> card (IDirProds G S (insert x F)) =\n                         (\\<Prod>i\\<in>insert x F. card (S i))", "then"], ["proof (chain)\npicking this:\n  subgroup (IDirProds G S I) G", "have cIP: \"(IDirProds G S I) \\<subseteq> carrier G\""], ["proof (prove)\nusing this:\n  subgroup (IDirProds G S I) G\n\ngoal (1 subgoal):\n 1. IDirProds G S I \\<subseteq> carrier G", "using subgroup.subset"], ["proof (prove)\nusing this:\n  subgroup (IDirProds G S I) G\n  subgroup ?H ?G \\<Longrightarrow> ?H \\<subseteq> carrier ?G\n\ngoal (1 subgoal):\n 1. IDirProds G S I \\<subseteq> carrier G", "by blast"], ["proof (state)\nthis:\n  IDirProds G S I \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>i\\<in>F. subgroup (S i) G;\n         \\<forall>i\\<in>F. finite (S i);\n         pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y)))\n          F\\<rbrakk>\n        \\<Longrightarrow> card (IDirProds G S F) =\n                          (\\<Prod>i\\<in>F. card (S i));\n        \\<forall>i\\<in>insert x F. subgroup (S i) G;\n        \\<forall>i\\<in>insert x F. finite (S i);\n        pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y)))\n         (insert x F)\\<rbrakk>\n       \\<Longrightarrow> card (IDirProds G S (insert x F)) =\n                         (\\<Prod>i\\<in>insert x F. card (S i))", "have fIP: \"finite (IDirProds G S I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (IDirProds G S I)", "using IDirProds_finite[OF i(1)] i"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>i\\<in>I. subgroup (?S i) G;\n   \\<forall>i\\<in>I. finite (?S i)\\<rbrakk>\n  \\<Longrightarrow> finite (IDirProds G ?S I)\n  finite I\n  x \\<notin> I\n  \\<lbrakk>\\<forall>i\\<in>I. subgroup (S i) G;\n   \\<forall>i\\<in>I. finite (S i);\n   pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y))) I\\<rbrakk>\n  \\<Longrightarrow> card (IDirProds G S I) = (\\<Prod>i\\<in>I. card (S i))\n  \\<forall>i\\<in>insert x I. subgroup (S i) G\n  \\<forall>i\\<in>insert x I. finite (S i)\n  pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y))) (insert x I)\n\ngoal (1 subgoal):\n 1. finite (IDirProds G S I)", "by blast"], ["proof (state)\nthis:\n  finite (IDirProds G S I)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>i\\<in>F. subgroup (S i) G;\n         \\<forall>i\\<in>F. finite (S i);\n         pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y)))\n          F\\<rbrakk>\n        \\<Longrightarrow> card (IDirProds G S F) =\n                          (\\<Prod>i\\<in>F. card (S i));\n        \\<forall>i\\<in>insert x F. subgroup (S i) G;\n        \\<forall>i\\<in>insert x F. finite (S i);\n        pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y)))\n         (insert x F)\\<rbrakk>\n       \\<Longrightarrow> card (IDirProds G S (insert x F)) =\n                         (\\<Prod>i\\<in>insert x F. card (S i))", "from i"], ["proof (chain)\npicking this:\n  finite I\n  x \\<notin> I\n  \\<lbrakk>\\<forall>i\\<in>I. subgroup (S i) G;\n   \\<forall>i\\<in>I. finite (S i);\n   pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y))) I\\<rbrakk>\n  \\<Longrightarrow> card (IDirProds G S I) = (\\<Prod>i\\<in>I. card (S i))\n  \\<forall>i\\<in>insert x I. subgroup (S i) G\n  \\<forall>i\\<in>insert x I. finite (S i)\n  pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y))) (insert x I)", "have ih: \"card (IDirProds G S I) = (\\<Prod>i\\<in>I. card (S i))\""], ["proof (prove)\nusing this:\n  finite I\n  x \\<notin> I\n  \\<lbrakk>\\<forall>i\\<in>I. subgroup (S i) G;\n   \\<forall>i\\<in>I. finite (S i);\n   pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y))) I\\<rbrakk>\n  \\<Longrightarrow> card (IDirProds G S I) = (\\<Prod>i\\<in>I. card (S i))\n  \\<forall>i\\<in>insert x I. subgroup (S i) G\n  \\<forall>i\\<in>insert x I. finite (S i)\n  pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y))) (insert x I)\n\ngoal (1 subgoal):\n 1. card (IDirProds G S I) = (\\<Prod>i\\<in>I. card (S i))", "unfolding pairwise_def"], ["proof (prove)\nusing this:\n  finite I\n  x \\<notin> I\n  \\<lbrakk>\\<forall>i\\<in>I. subgroup (S i) G;\n   \\<forall>i\\<in>I. finite (S i);\n   \\<forall>x\\<in>I.\n      \\<forall>y\\<in>I.\n         x \\<noteq> y \\<longrightarrow>\n         coprime (card (S x)) (card (S y))\\<rbrakk>\n  \\<Longrightarrow> card (IDirProds G S I) = (\\<Prod>i\\<in>I. card (S i))\n  \\<forall>i\\<in>insert x I. subgroup (S i) G\n  \\<forall>i\\<in>insert x I. finite (S i)\n  \\<forall>xa\\<in>insert x I.\n     \\<forall>y\\<in>insert x I.\n        xa \\<noteq> y \\<longrightarrow> coprime (card (S xa)) (card (S y))\n\ngoal (1 subgoal):\n 1. card (IDirProds G S I) = (\\<Prod>i\\<in>I. card (S i))", "by blast"], ["proof (state)\nthis:\n  card (IDirProds G S I) = (\\<Prod>i\\<in>I. card (S i))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>i\\<in>F. subgroup (S i) G;\n         \\<forall>i\\<in>F. finite (S i);\n         pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y)))\n          F\\<rbrakk>\n        \\<Longrightarrow> card (IDirProds G S F) =\n                          (\\<Prod>i\\<in>F. card (S i));\n        \\<forall>i\\<in>insert x F. subgroup (S i) G;\n        \\<forall>i\\<in>insert x F. finite (S i);\n        pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y)))\n         (insert x F)\\<rbrakk>\n       \\<Longrightarrow> card (IDirProds G S (insert x F)) =\n                         (\\<Prod>i\\<in>insert x F. card (S i))", "hence cop: \"coprime (card (IDirProds G S I)) (card (S x))\""], ["proof (prove)\nusing this:\n  card (IDirProds G S I) = (\\<Prod>i\\<in>I. card (S i))\n\ngoal (1 subgoal):\n 1. coprime (card (IDirProds G S I)) (card (S x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (IDirProds G S I) = (\\<Prod>i\\<in>I. card (S i)) \\<Longrightarrow>\n    coprime (card (IDirProds G S I)) (card (S x))", "have cFI0: \"card (IDirProds G S I) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (IDirProds G S I) \\<noteq> 0", "using finite_subgroup_card_neq_0[OF sIP fIP]"], ["proof (prove)\nusing this:\n  card (IDirProds G S I) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. card (IDirProds G S I) \\<noteq> 0", "."], ["proof (state)\nthis:\n  card (IDirProds G S I) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. card (IDirProds G S I) = (\\<Prod>i\\<in>I. card (S i)) \\<Longrightarrow>\n    coprime (card (IDirProds G S I)) (card (S x))", "moreover"], ["proof (state)\nthis:\n  card (IDirProds G S I) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. card (IDirProds G S I) = (\\<Prod>i\\<in>I. card (S i)) \\<Longrightarrow>\n    coprime (card (IDirProds G S I)) (card (S x))", "have cx0: \"card (S x) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (S x) \\<noteq> 0", "using finite_subgroup_card_neq_0[OF sx fx]"], ["proof (prove)\nusing this:\n  card (S x) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. card (S x) \\<noteq> 0", "."], ["proof (state)\nthis:\n  card (S x) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. card (IDirProds G S I) = (\\<Prod>i\\<in>I. card (S i)) \\<Longrightarrow>\n    coprime (card (IDirProds G S I)) (card (S x))", "moreover"], ["proof (state)\nthis:\n  card (S x) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. card (IDirProds G S I) = (\\<Prod>i\\<in>I. card (S i)) \\<Longrightarrow>\n    coprime (card (IDirProds G S I)) (card (S x))", "have  \"prime_factors (card (IDirProds G S I)) \\<inter> prime_factors (card (S x)) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_factors (card (IDirProds G S I)) \\<inter>\n    prime_factors (card (S x)) =\n    {}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. prime_factors (card (IDirProds G S I)) \\<inter>\n    prime_factors (card (S x)) \\<noteq>\n    {} \\<Longrightarrow>\n    False", "have n0: \"\\<And>i. i \\<in> I \\<Longrightarrow> card (S i) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> I \\<Longrightarrow> card (S i) \\<noteq> 0", "using finite_subgroup_card_neq_0 i(4, 5)"], ["proof (prove)\nusing this:\n  \\<lbrakk>subgroup ?H G; finite ?H\\<rbrakk>\n  \\<Longrightarrow> card ?H \\<noteq> 0\n  \\<forall>i\\<in>insert x I. subgroup (S i) G\n  \\<forall>i\\<in>insert x I. finite (S i)\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> I \\<Longrightarrow> card (S i) \\<noteq> 0", "by blast"], ["proof (state)\nthis:\n  ?i \\<in> I \\<Longrightarrow> card (S ?i) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. prime_factors (card (IDirProds G S I)) \\<inter>\n    prime_factors (card (S x)) \\<noteq>\n    {} \\<Longrightarrow>\n    False", "assume \"prime_factors (card (IDirProds G S I)) \\<inter> prime_factors (card (S x)) \\<noteq> {}\""], ["proof (state)\nthis:\n  prime_factors (card (IDirProds G S I)) \\<inter>\n  prime_factors (card (S x)) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. prime_factors (card (IDirProds G S I)) \\<inter>\n    prime_factors (card (S x)) \\<noteq>\n    {} \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  prime_factors (card (IDirProds G S I)) \\<inter>\n  prime_factors (card (S x)) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. prime_factors (card (IDirProds G S I)) \\<inter>\n    prime_factors (card (S x)) \\<noteq>\n    {} \\<Longrightarrow>\n    False", "have \"prime_factors (card (IDirProds G S I)) = \\<Union>(prime_factors ` (card \\<circ> S) ` I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_factors (card (IDirProds G S I)) =\n    \\<Union> (prime_factors ` (card \\<circ> S) ` I)", "using n0 prime_factors_Prod[OF i(1), of \"card \\<circ> S\"]"], ["proof (prove)\nusing this:\n  ?i \\<in> I \\<Longrightarrow> card (S ?i) \\<noteq> 0\n  (\\<And>a.\n      a \\<in> I \\<Longrightarrow>\n      (card \\<circ> S) a \\<noteq> 0) \\<Longrightarrow>\n  prime_factors (prod (card \\<circ> S) I) =\n  \\<Union> (prime_factors ` (card \\<circ> S) ` I)\n\ngoal (1 subgoal):\n 1. prime_factors (card (IDirProds G S I)) =\n    \\<Union> (prime_factors ` (card \\<circ> S) ` I)", "by (subst ih; simp)"], ["proof (state)\nthis:\n  prime_factors (card (IDirProds G S I)) =\n  \\<Union> (prime_factors ` (card \\<circ> S) ` I)\n\ngoal (1 subgoal):\n 1. prime_factors (card (IDirProds G S I)) \\<inter>\n    prime_factors (card (S x)) \\<noteq>\n    {} \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  prime_factors (card (IDirProds G S I)) =\n  \\<Union> (prime_factors ` (card \\<circ> S) ` I)\n\ngoal (1 subgoal):\n 1. prime_factors (card (IDirProds G S I)) \\<inter>\n    prime_factors (card (S x)) \\<noteq>\n    {} \\<Longrightarrow>\n    False", "have \"\\<And>i. i \\<in> I \\<Longrightarrow> prime_factors (card (S i)) \\<inter> prime_factors (card (S x)) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> I \\<Longrightarrow>\n       prime_factors (card (S i)) \\<inter> prime_factors (card (S x)) = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> I \\<Longrightarrow>\n       prime_factors (card (S i)) \\<inter> prime_factors (card (S x)) = {}", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> I \\<Longrightarrow>\n       prime_factors (card (S i)) \\<inter> prime_factors (card (S x)) = {}", "assume ind: \"i \\<in> I\""], ["proof (state)\nthis:\n  i \\<in> I\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> I \\<Longrightarrow>\n       prime_factors (card (S i)) \\<inter> prime_factors (card (S x)) = {}", "then"], ["proof (chain)\npicking this:\n  i \\<in> I", "have coPx: \"coprime (card (S i)) (card (S x))\""], ["proof (prove)\nusing this:\n  i \\<in> I\n\ngoal (1 subgoal):\n 1. coprime (card (S i)) (card (S x))", "using i(2, 6)"], ["proof (prove)\nusing this:\n  i \\<in> I\n  x \\<notin> I\n  pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y))) (insert x I)\n\ngoal (1 subgoal):\n 1. coprime (card (S i)) (card (S x))", "unfolding pairwise_def"], ["proof (prove)\nusing this:\n  i \\<in> I\n  x \\<notin> I\n  \\<forall>xa\\<in>insert x I.\n     \\<forall>y\\<in>insert x I.\n        xa \\<noteq> y \\<longrightarrow> coprime (card (S xa)) (card (S y))\n\ngoal (1 subgoal):\n 1. coprime (card (S i)) (card (S x))", "by auto"], ["proof (state)\nthis:\n  coprime (card (S i)) (card (S x))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> I \\<Longrightarrow>\n       prime_factors (card (S i)) \\<inter> prime_factors (card (S x)) = {}", "have \"card (S i) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (S i) \\<noteq> 0", "using n0 ind"], ["proof (prove)\nusing this:\n  ?i \\<in> I \\<Longrightarrow> card (S ?i) \\<noteq> 0\n  i \\<in> I\n\ngoal (1 subgoal):\n 1. card (S i) \\<noteq> 0", "by blast"], ["proof (state)\nthis:\n  card (S i) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> I \\<Longrightarrow>\n       prime_factors (card (S i)) \\<inter> prime_factors (card (S x)) = {}", "from coprime_eq_empty_prime_inter[OF this cx0]"], ["proof (chain)\npicking this:\n  coprime (card (S i)) (card (S x)) =\n  (prime_factors (card (S i)) \\<inter> prime_factors (card (S x)) = {})", "show \"prime_factors (card (S i)) \\<inter> prime_factors (card (S x)) = {}\""], ["proof (prove)\nusing this:\n  coprime (card (S i)) (card (S x)) =\n  (prime_factors (card (S i)) \\<inter> prime_factors (card (S x)) = {})\n\ngoal (1 subgoal):\n 1. prime_factors (card (S i)) \\<inter> prime_factors (card (S x)) = {}", "using coPx"], ["proof (prove)\nusing this:\n  coprime (card (S i)) (card (S x)) =\n  (prime_factors (card (S i)) \\<inter> prime_factors (card (S x)) = {})\n  coprime (card (S i)) (card (S x))\n\ngoal (1 subgoal):\n 1. prime_factors (card (S i)) \\<inter> prime_factors (card (S x)) = {}", "by blast"], ["proof (state)\nthis:\n  prime_factors (card (S i)) \\<inter> prime_factors (card (S x)) = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i \\<in> I \\<Longrightarrow>\n  prime_factors (card (S ?i)) \\<inter> prime_factors (card (S x)) = {}\n\ngoal (1 subgoal):\n 1. prime_factors (card (IDirProds G S I)) \\<inter>\n    prime_factors (card (S x)) \\<noteq>\n    {} \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  prime_factors (card (IDirProds G S I)) \\<inter>\n  prime_factors (card (S x)) \\<noteq>\n  {}\n  prime_factors (card (IDirProds G S I)) =\n  \\<Union> (prime_factors ` (card \\<circ> S) ` I)\n  ?i \\<in> I \\<Longrightarrow>\n  prime_factors (card (S ?i)) \\<inter> prime_factors (card (S x)) = {}", "show \"False\""], ["proof (prove)\nusing this:\n  prime_factors (card (IDirProds G S I)) \\<inter>\n  prime_factors (card (S x)) \\<noteq>\n  {}\n  prime_factors (card (IDirProds G S I)) =\n  \\<Union> (prime_factors ` (card \\<circ> S) ` I)\n  ?i \\<in> I \\<Longrightarrow>\n  prime_factors (card (S ?i)) \\<inter> prime_factors (card (S x)) = {}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prime_factors (card (IDirProds G S I)) \\<inter>\n  prime_factors (card (S x)) =\n  {}\n\ngoal (1 subgoal):\n 1. card (IDirProds G S I) = (\\<Prod>i\\<in>I. card (S i)) \\<Longrightarrow>\n    coprime (card (IDirProds G S I)) (card (S x))", "ultimately"], ["proof (chain)\npicking this:\n  card (IDirProds G S I) \\<noteq> 0\n  card (S x) \\<noteq> 0\n  prime_factors (card (IDirProds G S I)) \\<inter>\n  prime_factors (card (S x)) =\n  {}", "show ?thesis"], ["proof (prove)\nusing this:\n  card (IDirProds G S I) \\<noteq> 0\n  card (S x) \\<noteq> 0\n  prime_factors (card (IDirProds G S I)) \\<inter>\n  prime_factors (card (S x)) =\n  {}\n\ngoal (1 subgoal):\n 1. coprime (card (IDirProds G S I)) (card (S x))", "using coprime_eq_empty_prime_inter"], ["proof (prove)\nusing this:\n  card (IDirProds G S I) \\<noteq> 0\n  card (S x) \\<noteq> 0\n  prime_factors (card (IDirProds G S I)) \\<inter>\n  prime_factors (card (S x)) =\n  {}\n  \\<lbrakk>?n \\<noteq> 0; ?m \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> coprime ?n ?m =\n                    (prime_factors ?n \\<inter> prime_factors ?m = {})\n\ngoal (1 subgoal):\n 1. coprime (card (IDirProds G S I)) (card (S x))", "by blast"], ["proof (state)\nthis:\n  coprime (card (IDirProds G S I)) (card (S x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  coprime (card (IDirProds G S I)) (card (S x))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>i\\<in>F. subgroup (S i) G;\n         \\<forall>i\\<in>F. finite (S i);\n         pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y)))\n          F\\<rbrakk>\n        \\<Longrightarrow> card (IDirProds G S F) =\n                          (\\<Prod>i\\<in>F. card (S i));\n        \\<forall>i\\<in>insert x F. subgroup (S i) G;\n        \\<forall>i\\<in>insert x F. finite (S i);\n        pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y)))\n         (insert x F)\\<rbrakk>\n       \\<Longrightarrow> card (IDirProds G S (insert x F)) =\n                         (\\<Prod>i\\<in>insert x F. card (S i))", "have \"card (IDirProds G S (insert x I)) = card (S x) * card (IDirProds G S I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (IDirProds G S (insert x I)) = card (S x) * card (IDirProds G S I)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (IDirProds G S (insert x I)) = card (S x) * card (IDirProds G S I)", "from finite_sub_comp_iff_card_eq_IDirProd[OF sIP sx fIP fx]\n         subgroups_card_coprime_imp_compl[OF sIP sx cop]"], ["proof (chain)\npicking this:\n  (card (IDirProd G (IDirProds G S I) (S x)) =\n   card (S x) * card (IDirProds G S I)) =\n  complementary (IDirProds G S I) (S x)\n  complementary (IDirProds G S I) (S x)", "have \"card (IDirProd G (IDirProds G S I) (S x)) = card (S x) * card (IDirProds G S I)\""], ["proof (prove)\nusing this:\n  (card (IDirProd G (IDirProds G S I) (S x)) =\n   card (S x) * card (IDirProds G S I)) =\n  complementary (IDirProds G S I) (S x)\n  complementary (IDirProds G S I) (S x)\n\ngoal (1 subgoal):\n 1. card (IDirProd G (IDirProds G S I) (S x)) =\n    card (S x) * card (IDirProds G S I)", "by blast"], ["proof (state)\nthis:\n  card (IDirProd G (IDirProds G S I) (S x)) =\n  card (S x) * card (IDirProds G S I)\n\ngoal (1 subgoal):\n 1. card (IDirProds G S (insert x I)) = card (S x) * card (IDirProds G S I)", "moreover"], ["proof (state)\nthis:\n  card (IDirProd G (IDirProds G S I) (S x)) =\n  card (S x) * card (IDirProds G S I)\n\ngoal (1 subgoal):\n 1. card (IDirProds G S (insert x I)) = card (S x) * card (IDirProds G S I)", "have \"generate G (\\<Union> (S ` insert x I)) = generate G (generate G (\\<Union> (S ` I)) \\<union> S x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generate G (\\<Union> (S ` insert x I)) =\n    generate G (generate G (\\<Union> (S ` I)) \\<union> S x)", "by (simp add: Un_commute cI cx generate_idem'_right)"], ["proof (state)\nthis:\n  generate G (\\<Union> (S ` insert x I)) =\n  generate G (generate G (\\<Union> (S ` I)) \\<union> S x)\n\ngoal (1 subgoal):\n 1. card (IDirProds G S (insert x I)) = card (S x) * card (IDirProds G S I)", "ultimately"], ["proof (chain)\npicking this:\n  card (IDirProd G (IDirProds G S I) (S x)) =\n  card (S x) * card (IDirProds G S I)\n  generate G (\\<Union> (S ` insert x I)) =\n  generate G (generate G (\\<Union> (S ` I)) \\<union> S x)", "show ?thesis"], ["proof (prove)\nusing this:\n  card (IDirProd G (IDirProds G S I) (S x)) =\n  card (S x) * card (IDirProds G S I)\n  generate G (\\<Union> (S ` insert x I)) =\n  generate G (generate G (\\<Union> (S ` I)) \\<union> S x)\n\ngoal (1 subgoal):\n 1. card (IDirProds G S (insert x I)) = card (S x) * card (IDirProds G S I)", "unfolding IDirProds_def IDirProd_def"], ["proof (prove)\nusing this:\n  card (generate G (generate G (\\<Union> (S ` I)) \\<union> S x)) =\n  card (S x) * card (generate G (\\<Union> (S ` I)))\n  generate G (\\<Union> (S ` insert x I)) =\n  generate G (generate G (\\<Union> (S ` I)) \\<union> S x)\n\ngoal (1 subgoal):\n 1. card (generate G (\\<Union> (S ` insert x I))) =\n    card (S x) * card (generate G (\\<Union> (S ` I)))", "by argo"], ["proof (state)\nthis:\n  card (IDirProds G S (insert x I)) = card (S x) * card (IDirProds G S I)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card (IDirProds G S (insert x I)) = card (S x) * card (IDirProds G S I)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>i\\<in>F. subgroup (S i) G;\n         \\<forall>i\\<in>F. finite (S i);\n         pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y)))\n          F\\<rbrakk>\n        \\<Longrightarrow> card (IDirProds G S F) =\n                          (\\<Prod>i\\<in>F. card (S i));\n        \\<forall>i\\<in>insert x F. subgroup (S i) G;\n        \\<forall>i\\<in>insert x F. finite (S i);\n        pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y)))\n         (insert x F)\\<rbrakk>\n       \\<Longrightarrow> card (IDirProds G S (insert x F)) =\n                         (\\<Prod>i\\<in>insert x F. card (S i))", "also"], ["proof (state)\nthis:\n  card (IDirProds G S (insert x I)) = card (S x) * card (IDirProds G S I)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>i\\<in>F. subgroup (S i) G;\n         \\<forall>i\\<in>F. finite (S i);\n         pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y)))\n          F\\<rbrakk>\n        \\<Longrightarrow> card (IDirProds G S F) =\n                          (\\<Prod>i\\<in>F. card (S i));\n        \\<forall>i\\<in>insert x F. subgroup (S i) G;\n        \\<forall>i\\<in>insert x F. finite (S i);\n        pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y)))\n         (insert x F)\\<rbrakk>\n       \\<Longrightarrow> card (IDirProds G S (insert x F)) =\n                         (\\<Prod>i\\<in>insert x F. card (S i))", "have \"\\<dots> = card (S x) * prod (card \\<circ> S) I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (S x) * card (IDirProds G S I) =\n    card (S x) * prod (card \\<circ> S) I", "using ih"], ["proof (prove)\nusing this:\n  card (IDirProds G S I) = (\\<Prod>i\\<in>I. card (S i))\n\ngoal (1 subgoal):\n 1. card (S x) * card (IDirProds G S I) =\n    card (S x) * prod (card \\<circ> S) I", "by simp"], ["proof (state)\nthis:\n  card (S x) * card (IDirProds G S I) = card (S x) * prod (card \\<circ> S) I\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>i\\<in>F. subgroup (S i) G;\n         \\<forall>i\\<in>F. finite (S i);\n         pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y)))\n          F\\<rbrakk>\n        \\<Longrightarrow> card (IDirProds G S F) =\n                          (\\<Prod>i\\<in>F. card (S i));\n        \\<forall>i\\<in>insert x F. subgroup (S i) G;\n        \\<forall>i\\<in>insert x F. finite (S i);\n        pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y)))\n         (insert x F)\\<rbrakk>\n       \\<Longrightarrow> card (IDirProds G S (insert x F)) =\n                         (\\<Prod>i\\<in>insert x F. card (S i))", "also"], ["proof (state)\nthis:\n  card (S x) * card (IDirProds G S I) = card (S x) * prod (card \\<circ> S) I\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>i\\<in>F. subgroup (S i) G;\n         \\<forall>i\\<in>F. finite (S i);\n         pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y)))\n          F\\<rbrakk>\n        \\<Longrightarrow> card (IDirProds G S F) =\n                          (\\<Prod>i\\<in>F. card (S i));\n        \\<forall>i\\<in>insert x F. subgroup (S i) G;\n        \\<forall>i\\<in>insert x F. finite (S i);\n        pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y)))\n         (insert x F)\\<rbrakk>\n       \\<Longrightarrow> card (IDirProds G S (insert x F)) =\n                         (\\<Prod>i\\<in>insert x F. card (S i))", "have \"\\<dots> = prod (card \\<circ> S) ({x} \\<union> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (S x) * prod (card \\<circ> S) I =\n    prod (card \\<circ> S) ({x} \\<union> I)", "using i.hyps"], ["proof (prove)\nusing this:\n  finite I\n  x \\<notin> I\n\ngoal (1 subgoal):\n 1. card (S x) * prod (card \\<circ> S) I =\n    prod (card \\<circ> S) ({x} \\<union> I)", "by auto"], ["proof (state)\nthis:\n  card (S x) * prod (card \\<circ> S) I =\n  prod (card \\<circ> S) ({x} \\<union> I)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>i\\<in>F. subgroup (S i) G;\n         \\<forall>i\\<in>F. finite (S i);\n         pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y)))\n          F\\<rbrakk>\n        \\<Longrightarrow> card (IDirProds G S F) =\n                          (\\<Prod>i\\<in>F. card (S i));\n        \\<forall>i\\<in>insert x F. subgroup (S i) G;\n        \\<forall>i\\<in>insert x F. finite (S i);\n        pairwise (\\<lambda>x y. coprime (card (S x)) (card (S y)))\n         (insert x F)\\<rbrakk>\n       \\<Longrightarrow> card (IDirProds G S (insert x F)) =\n                         (\\<Prod>i\\<in>insert x F. card (S i))", "finally"], ["proof (chain)\npicking this:\n  card (IDirProds G S (insert x I)) = prod (card \\<circ> S) ({x} \\<union> I)", "show ?case"], ["proof (prove)\nusing this:\n  card (IDirProds G S (insert x I)) = prod (card \\<circ> S) ({x} \\<union> I)\n\ngoal (1 subgoal):\n 1. card (IDirProds G S (insert x I)) =\n    (\\<Prod>i\\<in>insert x I. card (S i))", "by simp"], ["proof (state)\nthis:\n  card (IDirProds G S (insert x I)) = (\\<Prod>i\\<in>insert x I. card (S i))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Complementary family of subgroups\""], ["", "text \\<open>The notion of a complementary family is introduced. Note that the subgroups are complementary\nnot only to the other subgroups but to the product of the other subgroups.\\<close>"], ["", "definition (in group) compl_fam :: \"('c \\<Rightarrow> 'a set) \\<Rightarrow> 'c set \\<Rightarrow> bool\" where\n  \"compl_fam S I = (\\<forall>i \\<in> I. complementary (S i) (IDirProds G S (I - {i})))\""], ["", "text \\<open>Some lemmas about \\<open>compl_fam\\<close>.\\<close>"], ["", "lemma (in group) compl_fam_empty[simp]: \"compl_fam S {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compl_fam S {}", "unfolding compl_fam_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{}. complementary (S i) (IDirProds G S ({} - {i}))", "by simp"], ["", "lemma (in group) compl_fam_cong:\n  assumes \"compl_fam (f \\<circ> g) A\" \"inj_on g A\"\n  shows \"compl_fam f (g ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compl_fam f (g ` A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. compl_fam f (g ` A)", "have \"((f \\<circ> g) ` (A - {i})) =  (f ` (g ` A - {g i}))\" if \"i \\<in> A\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<circ> g) ` (A - {i}) = f ` (g ` A - {g i})", "using assms that"], ["proof (prove)\nusing this:\n  compl_fam (f \\<circ> g) A\n  inj_on g A\n  i \\<in> A\n\ngoal (1 subgoal):\n 1. (f \\<circ> g) ` (A - {i}) = f ` (g ` A - {g i})", "unfolding inj_on_def comp_def"], ["proof (prove)\nusing this:\n  compl_fam (\\<lambda>x. f (g x)) A\n  \\<forall>x\\<in>A. \\<forall>y\\<in>A. g x = g y \\<longrightarrow> x = y\n  i \\<in> A\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. f (g x)) ` (A - {i}) = f ` (g ` A - {g i})", "by blast"], ["proof (state)\nthis:\n  ?i1 \\<in> A \\<Longrightarrow>\n  (f \\<circ> g) ` (A - {?i1}) = f ` (g ` A - {g ?i1})\n\ngoal (1 subgoal):\n 1. compl_fam f (g ` A)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?i1 \\<in> A \\<Longrightarrow>\n  (f \\<circ> g) ` (A - {?i1}) = f ` (g ` A - {g ?i1})\n\ngoal (1 subgoal):\n 1. compl_fam f (g ` A)", "using assms"], ["proof (prove)\nusing this:\n  ?i1 \\<in> A \\<Longrightarrow>\n  (f \\<circ> g) ` (A - {?i1}) = f ` (g ` A - {g ?i1})\n  compl_fam (f \\<circ> g) A\n  inj_on g A\n\ngoal (1 subgoal):\n 1. compl_fam f (g ` A)", "unfolding compl_fam_def IDirProds_def complementary_def"], ["proof (prove)\nusing this:\n  ?i1 \\<in> A \\<Longrightarrow>\n  (f \\<circ> g) ` (A - {?i1}) = f ` (g ` A - {g ?i1})\n  \\<forall>i\\<in>A.\n     (f \\<circ> g) i \\<inter>\n     generate G (\\<Union> ((f \\<circ> g) ` (A - {i}))) =\n     {\\<one>}\n  inj_on g A\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>g ` A.\n       f i \\<inter> generate G (\\<Union> (f ` (g ` A - {i}))) = {\\<one>}", "by simp"], ["proof (state)\nthis:\n  compl_fam f (g ` A)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We now connect \\<open>compl_fam\\<close> with \\<open>generate\\<close> as this will be its main application.\\<close>"], ["", "lemma (in comm_group) compl_fam_imp_generate_inj:\n  assumes \"gs \\<subseteq> carrier G\" \"compl_fam (\\<lambda>g. generate G {g}) gs\"\n  shows \"inj_on (\\<lambda>g. generate G {g}) gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>g. generate G {g}) gs", "proof(rule, rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> gs; y \\<in> gs; generate G {x} = generate G {y};\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> gs; y \\<in> gs; generate G {x} = generate G {y};\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "assume xy: \"x \\<in> gs\" \"y \\<in> gs\" \"x \\<noteq> y\""], ["proof (state)\nthis:\n  x \\<in> gs\n  y \\<in> gs\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> gs; y \\<in> gs; generate G {x} = generate G {y};\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "have gen: \"generate G (\\<Union>g\\<in>gs - {y}. generate G {g}) = generate G (gs - {y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generate G (\\<Union>g\\<in>gs - {y}. generate G {g}) =\n    generate G (gs - {y})", "by (intro generate_idem_Un, use assms in blast)"], ["proof (state)\nthis:\n  generate G (\\<Union>g\\<in>gs - {y}. generate G {g}) =\n  generate G (gs - {y})\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> gs; y \\<in> gs; generate G {x} = generate G {y};\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "assume g: \"generate G {x} = generate G {y}\""], ["proof (state)\nthis:\n  generate G {x} = generate G {y}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> gs; y \\<in> gs; generate G {x} = generate G {y};\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "with xy"], ["proof (chain)\npicking this:\n  x \\<in> gs\n  y \\<in> gs\n  x \\<noteq> y\n  generate G {x} = generate G {y}", "have \"generate G {y} \\<subseteq> generate G (gs - {y})\""], ["proof (prove)\nusing this:\n  x \\<in> gs\n  y \\<in> gs\n  x \\<noteq> y\n  generate G {x} = generate G {y}\n\ngoal (1 subgoal):\n 1. generate G {y} \\<subseteq> generate G (gs - {y})", "using mono_generate[of \"{x}\" \"gs - {y}\"]"], ["proof (prove)\nusing this:\n  x \\<in> gs\n  y \\<in> gs\n  x \\<noteq> y\n  generate G {x} = generate G {y}\n  {x} \\<subseteq> gs - {y} \\<Longrightarrow>\n  generate G {x} \\<subseteq> generate G (gs - {y})\n\ngoal (1 subgoal):\n 1. generate G {y} \\<subseteq> generate G (gs - {y})", "by auto"], ["proof (state)\nthis:\n  generate G {y} \\<subseteq> generate G (gs - {y})\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> gs; y \\<in> gs; generate G {x} = generate G {y};\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "with xy"], ["proof (chain)\npicking this:\n  x \\<in> gs\n  y \\<in> gs\n  x \\<noteq> y\n  generate G {y} \\<subseteq> generate G (gs - {y})", "have gyo: \"generate G {y} = {\\<one>}\""], ["proof (prove)\nusing this:\n  x \\<in> gs\n  y \\<in> gs\n  x \\<noteq> y\n  generate G {y} \\<subseteq> generate G (gs - {y})\n\ngoal (1 subgoal):\n 1. generate G {y} = {\\<one>}", "using assms(2) generate.one gen"], ["proof (prove)\nusing this:\n  x \\<in> gs\n  y \\<in> gs\n  x \\<noteq> y\n  generate G {y} \\<subseteq> generate G (gs - {y})\n  compl_fam (\\<lambda>g. generate G {g}) gs\n  \\<one>\\<^bsub>?G\\<^esub> \\<in> generate ?G ?H\n  generate G (\\<Union>g\\<in>gs - {y}. generate G {g}) =\n  generate G (gs - {y})\n\ngoal (1 subgoal):\n 1. generate G {y} = {\\<one>}", "unfolding compl_fam_def complementary_def IDirProds_def"], ["proof (prove)\nusing this:\n  x \\<in> gs\n  y \\<in> gs\n  x \\<noteq> y\n  generate G {y} \\<subseteq> generate G (gs - {y})\n  \\<forall>i\\<in>gs.\n     generate G {i} \\<inter>\n     generate G (\\<Union>g\\<in>gs - {i}. generate G {g}) =\n     {\\<one>}\n  \\<one>\\<^bsub>?G\\<^esub> \\<in> generate ?G ?H\n  generate G (\\<Union>g\\<in>gs - {y}. generate G {g}) =\n  generate G (gs - {y})\n\ngoal (1 subgoal):\n 1. generate G {y} = {\\<one>}", "by blast"], ["proof (state)\nthis:\n  generate G {y} = {\\<one>}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> gs; y \\<in> gs; generate G {x} = generate G {y};\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "hence yo: \"y = \\<one>\""], ["proof (prove)\nusing this:\n  generate G {y} = {\\<one>}\n\ngoal (1 subgoal):\n 1. y = \\<one>", "using generate_singleton_one"], ["proof (prove)\nusing this:\n  generate G {y} = {\\<one>}\n  generate G {?a} = {\\<one>} \\<Longrightarrow> ?a = \\<one>\n\ngoal (1 subgoal):\n 1. y = \\<one>", "by simp"], ["proof (state)\nthis:\n  y = \\<one>\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> gs; y \\<in> gs; generate G {x} = generate G {y};\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "from gyo g generate_singleton_one"], ["proof (chain)\npicking this:\n  generate G {y} = {\\<one>}\n  generate G {x} = generate G {y}\n  generate G {?a} = {\\<one>} \\<Longrightarrow> ?a = \\<one>", "have xo: \"x = \\<one>\""], ["proof (prove)\nusing this:\n  generate G {y} = {\\<one>}\n  generate G {x} = generate G {y}\n  generate G {?a} = {\\<one>} \\<Longrightarrow> ?a = \\<one>\n\ngoal (1 subgoal):\n 1. x = \\<one>", "by simp"], ["proof (state)\nthis:\n  x = \\<one>\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> gs; y \\<in> gs; generate G {x} = generate G {y};\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "from xy yo xo"], ["proof (chain)\npicking this:\n  x \\<in> gs\n  y \\<in> gs\n  x \\<noteq> y\n  y = \\<one>\n  x = \\<one>", "show False"], ["proof (prove)\nusing this:\n  x \\<in> gs\n  y \\<in> gs\n  x \\<noteq> y\n  y = \\<one>\n  x = \\<one>\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in comm_group) compl_fam_generate_subset:\n  assumes \"compl_fam (\\<lambda>g. generate G {g}) gs\"\n          \"gs \\<subseteq> carrier G\" \"A \\<subseteq> gs\"\n  shows \"compl_fam (\\<lambda>g. generate G {g}) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compl_fam (\\<lambda>g. generate G {g}) A", "proof(unfold compl_fam_def complementary_def IDirProds_def, subst generate_idem_Un)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i. A - {i} \\<subseteq> carrier G\n 2. \\<forall>i\\<in>A.\n       generate G {i} \\<inter> generate G (A - {i}) = {\\<one>}", "show \"\\<And>i. A - {i} \\<subseteq> carrier G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. A - {i} \\<subseteq> carrier G", "using assms"], ["proof (prove)\nusing this:\n  compl_fam (\\<lambda>g. generate G {g}) gs\n  gs \\<subseteq> carrier G\n  A \\<subseteq> gs\n\ngoal (1 subgoal):\n 1. \\<And>i. A - {i} \\<subseteq> carrier G", "by blast"], ["proof (state)\nthis:\n  A - {?i1} \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>A.\n       generate G {i} \\<inter> generate G (A - {i}) = {\\<one>}", "have \"generate G {i} \\<inter> generate G (A - {i}) = {\\<one>}\" if \"i \\<in> A\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. generate G {i} \\<inter> generate G (A - {i}) = {\\<one>}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. generate G {i} \\<inter> generate G (A - {i}) = {\\<one>}", "have \"\\<one> \\<in> generate G {i} \\<inter> generate G (A - {i})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<one> \\<in> generate G {i} \\<inter> generate G (A - {i})", "using generate.one"], ["proof (prove)\nusing this:\n  \\<one>\\<^bsub>?G\\<^esub> \\<in> generate ?G ?H\n\ngoal (1 subgoal):\n 1. \\<one> \\<in> generate G {i} \\<inter> generate G (A - {i})", "by blast"], ["proof (state)\nthis:\n  \\<one> \\<in> generate G {i} \\<inter> generate G (A - {i})\n\ngoal (1 subgoal):\n 1. generate G {i} \\<inter> generate G (A - {i}) = {\\<one>}", "moreover"], ["proof (state)\nthis:\n  \\<one> \\<in> generate G {i} \\<inter> generate G (A - {i})\n\ngoal (1 subgoal):\n 1. generate G {i} \\<inter> generate G (A - {i}) = {\\<one>}", "have \"generate G (A - {i}) \\<subseteq> generate G (gs - {i})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generate G (A - {i}) \\<subseteq> generate G (gs - {i})", "by (intro mono_generate, use assms in fast)"], ["proof (state)\nthis:\n  generate G (A - {i}) \\<subseteq> generate G (gs - {i})\n\ngoal (1 subgoal):\n 1. generate G {i} \\<inter> generate G (A - {i}) = {\\<one>}", "moreover"], ["proof (state)\nthis:\n  generate G (A - {i}) \\<subseteq> generate G (gs - {i})\n\ngoal (1 subgoal):\n 1. generate G {i} \\<inter> generate G (A - {i}) = {\\<one>}", "have \"generate G {i} \\<inter> generate G (gs - {i}) = {\\<one>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generate G {i} \\<inter> generate G (gs - {i}) = {\\<one>}", "using assms that generate_idem_Un[of \"gs - {i}\"]"], ["proof (prove)\nusing this:\n  compl_fam (\\<lambda>g. generate G {g}) gs\n  gs \\<subseteq> carrier G\n  A \\<subseteq> gs\n  i \\<in> A\n  gs - {i} \\<subseteq> carrier G \\<Longrightarrow>\n  generate G (\\<Union>x\\<in>gs - {i}. generate G {x}) =\n  generate G (gs - {i})\n\ngoal (1 subgoal):\n 1. generate G {i} \\<inter> generate G (gs - {i}) = {\\<one>}", "unfolding compl_fam_def IDirProds_def complementary_def"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>gs.\n     generate G {i} \\<inter>\n     generate G (\\<Union>g\\<in>gs - {i}. generate G {g}) =\n     {\\<one>}\n  gs \\<subseteq> carrier G\n  A \\<subseteq> gs\n  i \\<in> A\n  gs - {i} \\<subseteq> carrier G \\<Longrightarrow>\n  generate G (\\<Union>x\\<in>gs - {i}. generate G {x}) =\n  generate G (gs - {i})\n\ngoal (1 subgoal):\n 1. generate G {i} \\<inter> generate G (gs - {i}) = {\\<one>}", "by blast"], ["proof (state)\nthis:\n  generate G {i} \\<inter> generate G (gs - {i}) = {\\<one>}\n\ngoal (1 subgoal):\n 1. generate G {i} \\<inter> generate G (A - {i}) = {\\<one>}", "ultimately"], ["proof (chain)\npicking this:\n  \\<one> \\<in> generate G {i} \\<inter> generate G (A - {i})\n  generate G (A - {i}) \\<subseteq> generate G (gs - {i})\n  generate G {i} \\<inter> generate G (gs - {i}) = {\\<one>}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<one> \\<in> generate G {i} \\<inter> generate G (A - {i})\n  generate G (A - {i}) \\<subseteq> generate G (gs - {i})\n  generate G {i} \\<inter> generate G (gs - {i}) = {\\<one>}\n\ngoal (1 subgoal):\n 1. generate G {i} \\<inter> generate G (A - {i}) = {\\<one>}", "by blast"], ["proof (state)\nthis:\n  generate G {i} \\<inter> generate G (A - {i}) = {\\<one>}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i1 \\<in> A \\<Longrightarrow>\n  generate G {?i1} \\<inter> generate G (A - {?i1}) = {\\<one>}\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>A.\n       generate G {i} \\<inter> generate G (A - {i}) = {\\<one>}", "thus \"\\<forall>i\\<in>A. generate G {i} \\<inter> generate G (A - {i}) = {\\<one>}\""], ["proof (prove)\nusing this:\n  ?i1 \\<in> A \\<Longrightarrow>\n  generate G {?i1} \\<inter> generate G (A - {?i1}) = {\\<one>}\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>A.\n       generate G {i} \\<inter> generate G (A - {i}) = {\\<one>}", "by auto"], ["proof (state)\nthis:\n  \\<forall>i\\<in>A. generate G {i} \\<inter> generate G (A - {i}) = {\\<one>}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>\\<open>is_idirprod\\<close>\\<close>"], ["", "text \\<open>In order to identify a group as the internal direct product of a family of subgroups, they all\nhave to be normal subgroups, complementary to the product of the rest of the subgroups and generate\nall of the group - this is captured in the definition of \\<open>is_idirprod\\<close>.\\<close>"], ["", "definition (in group) is_idirprod :: \"'a set \\<Rightarrow> ('c \\<Rightarrow> 'a set) \\<Rightarrow> 'c set \\<Rightarrow> bool\" where\n  \"is_idirprod A S I = ((\\<forall>i \\<in> I. S i \\<lhd> G) \\<and> A = IDirProds G S I \\<and> compl_fam S I)\""], ["", "text \\<open>Very basic lemmas about \\<open>is_idirprod\\<close>.\\<close>"], ["", "lemma (in comm_group) is_idirprod_subgroup_suffices:\n  assumes \"A = IDirProds G S I\" \"\\<forall>i\\<in>I. subgroup (S i) G\" \"compl_fam S I\"\n  shows \"is_idirprod A S I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_idirprod A S I", "unfolding is_idirprod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i\\<in>I. S i \\<lhd> G) \\<and>\n    A = IDirProds G S I \\<and> compl_fam S I", "using assms subgroup_imp_normal"], ["proof (prove)\nusing this:\n  A = IDirProds G S I\n  \\<forall>i\\<in>I. subgroup (S i) G\n  compl_fam S I\n  subgroup ?A G \\<Longrightarrow> ?A \\<lhd> G\n\ngoal (1 subgoal):\n 1. (\\<forall>i\\<in>I. S i \\<lhd> G) \\<and>\n    A = IDirProds G S I \\<and> compl_fam S I", "by blast"], ["", "lemma (in comm_group) is_idirprod_generate:\n  assumes \"A = generate G gs\" \"gs \\<subseteq> carrier G\" \"compl_fam (\\<lambda>g. generate G {g}) gs\"\n  shows \"is_idirprod A (\\<lambda>g. generate G {g}) gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_idirprod A (\\<lambda>g. generate G {g}) gs", "proof(intro is_idirprod_subgroup_suffices)"], ["proof (state)\ngoal (3 subgoals):\n 1. A = IDirProds G (\\<lambda>g. generate G {g}) gs\n 2. \\<forall>i\\<in>gs. subgroup (generate G {i}) G\n 3. compl_fam (\\<lambda>g. generate G {g}) gs", "show \"A = IDirProds G (\\<lambda>g. generate G {g}) gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = IDirProds G (\\<lambda>g. generate G {g}) gs", "using assms generate_idem_Un[OF assms(2)]"], ["proof (prove)\nusing this:\n  A = generate G gs\n  gs \\<subseteq> carrier G\n  compl_fam (\\<lambda>g. generate G {g}) gs\n  generate G (\\<Union>x\\<in>gs. generate G {x}) = generate G gs\n\ngoal (1 subgoal):\n 1. A = IDirProds G (\\<lambda>g. generate G {g}) gs", "unfolding IDirProds_def"], ["proof (prove)\nusing this:\n  A = generate G gs\n  gs \\<subseteq> carrier G\n  compl_fam (\\<lambda>g. generate G {g}) gs\n  generate G (\\<Union>x\\<in>gs. generate G {x}) = generate G gs\n\ngoal (1 subgoal):\n 1. A = generate G (\\<Union>g\\<in>gs. generate G {g})", "by argo"], ["proof (state)\nthis:\n  A = IDirProds G (\\<lambda>g. generate G {g}) gs\n\ngoal (2 subgoals):\n 1. \\<forall>i\\<in>gs. subgroup (generate G {i}) G\n 2. compl_fam (\\<lambda>g. generate G {g}) gs", "show \"\\<forall>i\\<in>gs. subgroup (generate G {i}) G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>gs. subgroup (generate G {i}) G", "using assms generate_is_subgroup"], ["proof (prove)\nusing this:\n  A = generate G gs\n  gs \\<subseteq> carrier G\n  compl_fam (\\<lambda>g. generate G {g}) gs\n  ?H \\<subseteq> carrier G \\<Longrightarrow> subgroup (generate G ?H) G\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>gs. subgroup (generate G {i}) G", "by auto"], ["proof (state)\nthis:\n  \\<forall>i\\<in>gs. subgroup (generate G {i}) G\n\ngoal (1 subgoal):\n 1. compl_fam (\\<lambda>g. generate G {g}) gs", "show \"compl_fam (\\<lambda>g. generate G {g}) gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compl_fam (\\<lambda>g. generate G {g}) gs", "by fact"], ["proof (state)\nthis:\n  compl_fam (\\<lambda>g. generate G {g}) gs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in comm_group) is_idirprod_imp_compl_fam[simp]:\n  assumes \"is_idirprod A S I\"\n  shows \"compl_fam S I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compl_fam S I", "using assms"], ["proof (prove)\nusing this:\n  is_idirprod A S I\n\ngoal (1 subgoal):\n 1. compl_fam S I", "unfolding is_idirprod_def"], ["proof (prove)\nusing this:\n  (\\<forall>i\\<in>I. S i \\<lhd> G) \\<and>\n  A = IDirProds G S I \\<and> compl_fam S I\n\ngoal (1 subgoal):\n 1. compl_fam S I", "by blast"], ["", "lemma (in comm_group) is_idirprod_generate_imp_generate[simp]:\n  assumes \"is_idirprod A (\\<lambda>g. generate G {g}) gs\"\n  shows \"A = generate G gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = generate G gs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A = generate G gs", "have \"gs \\<subseteq> carrier G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gs \\<subseteq> carrier G", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> gs \\<Longrightarrow> x \\<in> carrier G", "show \"g \\<in> carrier G\" if \"g \\<in> gs\" for g"], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<in> carrier G", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. g \\<in> carrier G", "interpret g: subgroup \"generate G {g}\" G"], ["proof (prove)\ngoal (1 subgoal):\n 1. subgroup (generate G {g}) G", "using assms that normal_imp_subgroup"], ["proof (prove)\nusing this:\n  is_idirprod A (\\<lambda>g. generate G {g}) gs\n  g \\<in> gs\n  ?H \\<lhd> ?G \\<Longrightarrow> subgroup ?H ?G\n\ngoal (1 subgoal):\n 1. subgroup (generate G {g}) G", "unfolding is_idirprod_def"], ["proof (prove)\nusing this:\n  (\\<forall>i\\<in>gs. generate G {i} \\<lhd> G) \\<and>\n  A = IDirProds G (\\<lambda>g. generate G {g}) gs \\<and>\n  compl_fam (\\<lambda>g. generate G {g}) gs\n  g \\<in> gs\n  ?H \\<lhd> ?G \\<Longrightarrow> subgroup ?H ?G\n\ngoal (1 subgoal):\n 1. subgroup (generate G {g}) G", "by blast"], ["proof (state)\ngoal (1 subgoal):\n 1. g \\<in> carrier G", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<in> carrier G", "using g.subset generate.incl"], ["proof (prove)\nusing this:\n  generate G {g} \\<subseteq> carrier G\n  ?h \\<in> ?H \\<Longrightarrow> ?h \\<in> generate ?G ?H\n\ngoal (1 subgoal):\n 1. g \\<in> carrier G", "by fast"], ["proof (state)\nthis:\n  g \\<in> carrier G\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?g2 \\<in> gs \\<Longrightarrow> ?g2 \\<in> carrier G\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gs \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. A = generate G gs", "thus ?thesis"], ["proof (prove)\nusing this:\n  gs \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. A = generate G gs", "using assms generate_idem_Un"], ["proof (prove)\nusing this:\n  gs \\<subseteq> carrier G\n  is_idirprod A (\\<lambda>g. generate G {g}) gs\n  ?A \\<subseteq> carrier G \\<Longrightarrow>\n  generate G (\\<Union>x\\<in>?A. generate G {x}) = generate G ?A\n\ngoal (1 subgoal):\n 1. A = generate G gs", "unfolding is_idirprod_def IDirProds_def"], ["proof (prove)\nusing this:\n  gs \\<subseteq> carrier G\n  (\\<forall>i\\<in>gs. generate G {i} \\<lhd> G) \\<and>\n  A = generate G (\\<Union>g\\<in>gs. generate G {g}) \\<and>\n  compl_fam (\\<lambda>g. generate G {g}) gs\n  ?A \\<subseteq> carrier G \\<Longrightarrow>\n  generate G (\\<Union>x\\<in>?A. generate G {x}) = generate G ?A\n\ngoal (1 subgoal):\n 1. A = generate G gs", "by presburger"], ["proof (state)\nthis:\n  A = generate G gs\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}