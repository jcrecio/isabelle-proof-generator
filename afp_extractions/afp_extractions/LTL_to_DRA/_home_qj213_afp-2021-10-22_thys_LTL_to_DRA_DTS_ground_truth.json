{"file_name": "/home/qj213/afp-2021-10-22/thys/LTL_to_DRA/DTS.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/LTL_to_DRA", "problem_names": ["lemma run_foldl:\n  \"run \\<Delta> q\\<^sub>0 w i = foldl \\<Delta> q\\<^sub>0 (map w [0..<i])\"", "lemma run\\<^sub>t_foldl:\n  \"run\\<^sub>t \\<Delta> q\\<^sub>0 w i = (foldl \\<Delta> q\\<^sub>0 (map w [0..<i]), w i, foldl \\<Delta> q\\<^sub>0 (map w [0..<Suc i]))\"", "lemma reach_foldl_def:\n  assumes \"\\<Sigma> \\<noteq> {}\"\n  shows \"reach \\<Sigma> \\<delta> q\\<^sub>0 = {foldl \\<delta> q\\<^sub>0 w | w. set w \\<subseteq> \\<Sigma>}\"", "lemma reach\\<^sub>t_foldl_def:\n  \"reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0 = {(foldl \\<delta> q\\<^sub>0 w, \\<nu>, foldl \\<delta> q\\<^sub>0 (w@[\\<nu>])) | w \\<nu>. set w \\<subseteq> \\<Sigma> \\<and> \\<nu> \\<in> \\<Sigma>}\" (is \"?lhs = ?rhs\")", "lemma reach_card_0:\n  assumes \"\\<Sigma> \\<noteq> {}\"\n  shows \"infinite (reach \\<Sigma> \\<delta> q\\<^sub>0) \\<longleftrightarrow> card (reach \\<Sigma> \\<delta> q\\<^sub>0) = 0\"", "lemma reach\\<^sub>t_card_0:\n  assumes \"\\<Sigma> \\<noteq> {}\"\n  shows \"infinite (reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0) \\<longleftrightarrow> card (reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0) = 0\"", "lemma run_subseteq_reach:\n  assumes \"range w \\<subseteq> \\<Sigma>\"\n  shows \"range (run \\<delta> q\\<^sub>0 w) \\<subseteq> reach \\<Sigma> \\<delta> q\\<^sub>0\" \n    and \"range (run\\<^sub>t \\<delta> q\\<^sub>0 w) \\<subseteq> reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0\"", "lemma limit_subseteq_reach:\n  assumes \"range w \\<subseteq> \\<Sigma>\"\n  shows \"limit (run \\<delta> q\\<^sub>0 w) \\<subseteq> reach \\<Sigma> \\<delta> q\\<^sub>0\"\n    and \"limit (run\\<^sub>t \\<delta> q\\<^sub>0 w) \\<subseteq> reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0\"", "lemma run\\<^sub>t_finite:\n  assumes \"finite (reach \\<Sigma> \\<delta> q\\<^sub>0)\"\n  assumes \"finite \\<Sigma>\"\n  assumes \"range w \\<subseteq> \\<Sigma>\"\n  defines \"r \\<equiv> run\\<^sub>t \\<delta> q\\<^sub>0 w\"\n  shows \"finite (range r)\"", "lemma Q\\<^sub>L_reach:\n  assumes \"finite (reach (set \\<Sigma>) \\<delta> q\\<^sub>0)\"\n  shows \"Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 = reach (set \\<Sigma>) \\<delta> q\\<^sub>0\"", "lemma \\<delta>\\<^sub>L_reach: \n  assumes \"finite (reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0)\"\n  shows \"\\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 = reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0\"", "lemma reach_reach\\<^sub>t_fst:\n  \"reach \\<Sigma> \\<delta> q\\<^sub>0 = fst ` reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0\"", "lemma finite_reach:\n  \"finite (reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0) \\<Longrightarrow> finite (reach \\<Sigma> \\<delta> q\\<^sub>0)\"", "lemma finite_reach\\<^sub>t:\n  assumes \"finite (reach \\<Sigma> \\<delta> q\\<^sub>0)\"\n  assumes \"finite \\<Sigma>\"\n  shows \"finite (reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0)\"", "lemma Q\\<^sub>L_eq_\\<delta>\\<^sub>L:\n  assumes \"finite (reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0)\"\n  shows \"Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 = fst ` (\\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0)\"", "lemma simple_product_run:\n  fixes \\<delta>\\<^sub>1 \\<delta>\\<^sub>2 w q\\<^sub>1 q\\<^sub>2\n  defines \"\\<rho> \\<equiv> run (\\<delta>\\<^sub>1 \\<times> \\<delta>\\<^sub>2) (q\\<^sub>1, q\\<^sub>2) w\"\n  defines \"\\<rho>\\<^sub>1 \\<equiv> run \\<delta>\\<^sub>1 q\\<^sub>1 w\"\n  defines \"\\<rho>\\<^sub>2 \\<equiv> run \\<delta>\\<^sub>2 q\\<^sub>2 w\"\n  shows \"\\<rho> i = (\\<rho>\\<^sub>1 i, \\<rho>\\<^sub>2 i)\"", "theorem finite_reach_simple_product:\n  assumes \"finite (reach \\<Sigma> \\<delta>\\<^sub>1 q\\<^sub>1)\"\n  assumes \"finite (reach \\<Sigma> \\<delta>\\<^sub>2 q\\<^sub>2)\"\n  shows \"finite (reach \\<Sigma> (\\<delta>\\<^sub>1 \\<times> \\<delta>\\<^sub>2) (q\\<^sub>1, q\\<^sub>2))\"", "lemma product_run_None:\n  fixes \\<iota>\\<^sub>m \\<delta>\\<^sub>m w\n  defines \"\\<rho> \\<equiv> run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m w\"\n  assumes \"\\<iota>\\<^sub>m k = None\"\n  shows \"\\<rho> i k = None\"", "lemma product_run_Some:\n  fixes \\<iota>\\<^sub>m \\<delta>\\<^sub>m w q\\<^sub>0 k\n  defines \"\\<rho> \\<equiv> run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m w\"\n  defines \"\\<rho>' \\<equiv> run (\\<delta>\\<^sub>m k) q\\<^sub>0 w\"\n  assumes \"\\<iota>\\<^sub>m k = Some q\\<^sub>0\"\n  shows \"\\<rho> i k = Some (\\<rho>' i)\"", "theorem finite_reach_product:\n  assumes \"finite (dom \\<iota>\\<^sub>m)\"\n  assumes \"\\<And>x. x \\<in> dom \\<iota>\\<^sub>m \\<Longrightarrow> finite (reach \\<Sigma> (\\<delta>\\<^sub>m x) (the (\\<iota>\\<^sub>m x)))\"\n  shows \"finite (reach \\<Sigma> (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m)\"", "lemma embed_transition_snd_unfold:\n  \"embed_transition_snd t = {((x, fst t), fst (snd t), (y, snd (snd t))) | x y. True}\"", "lemma\n  fixes \\<delta>\\<^sub>1 \\<delta>\\<^sub>2 w q\\<^sub>1 q\\<^sub>2\n  defines \"\\<rho> \\<equiv> run\\<^sub>t (\\<delta>\\<^sub>1 \\<times> \\<delta>\\<^sub>2) (q\\<^sub>1, q\\<^sub>2) w\"\n  defines \"\\<rho>\\<^sub>1 \\<equiv> run\\<^sub>t \\<delta>\\<^sub>1 q\\<^sub>1 w\"\n  defines \"\\<rho>\\<^sub>2 \\<equiv> run\\<^sub>t \\<delta>\\<^sub>2 q\\<^sub>2 w\"\n  shows product_run_project_fst: \"project_transition_fst (\\<rho> i) = \\<rho>\\<^sub>1 i\" \n    and product_run_project_snd: \"project_transition_snd (\\<rho> i) = \\<rho>\\<^sub>2 i\"\n    and product_run_embed_fst: \"\\<rho> i \\<in> embed_transition_fst (\\<rho>\\<^sub>1 i)\"\n    and product_run_embed_snd: \"\\<rho> i \\<in> embed_transition_snd (\\<rho>\\<^sub>2 i)\"", "lemma \n  fixes \\<delta>\\<^sub>1 \\<delta>\\<^sub>2 w q\\<^sub>1 q\\<^sub>2\n  defines \"\\<rho> \\<equiv> run\\<^sub>t (\\<delta>\\<^sub>1 \\<times> \\<delta>\\<^sub>2) (q\\<^sub>1, q\\<^sub>2) w\"\n  defines \"\\<rho>\\<^sub>1 \\<equiv> run\\<^sub>t \\<delta>\\<^sub>1 q\\<^sub>1 w\"\n  defines \"\\<rho>\\<^sub>2 \\<equiv> run\\<^sub>t \\<delta>\\<^sub>2 q\\<^sub>2 w\"\n  assumes \"finite (range \\<rho>)\"\n  shows product_run_finite_fst: \"finite (range \\<rho>\\<^sub>1)\"\n    and product_run_finite_snd: \"finite (range \\<rho>\\<^sub>2)\"", "lemma \n  fixes \\<delta>\\<^sub>1 \\<delta>\\<^sub>2 w q\\<^sub>1 q\\<^sub>2\n  defines \"\\<rho> \\<equiv> run\\<^sub>t (\\<delta>\\<^sub>1 \\<times> \\<delta>\\<^sub>2) (q\\<^sub>1, q\\<^sub>2) w\"\n  defines \"\\<rho>\\<^sub>1 \\<equiv> run\\<^sub>t \\<delta>\\<^sub>1 q\\<^sub>1 w\"\n  assumes \"finite (range \\<rho>)\"\n  shows product_run_project_limit_fst: \"project_transition_fst ` limit \\<rho> = limit \\<rho>\\<^sub>1\"\n    and product_run_embed_limit_fst: \"limit \\<rho> \\<subseteq> \\<Union> (embed_transition_fst ` (limit \\<rho>\\<^sub>1))\"", "lemma \n  fixes \\<delta>\\<^sub>1 \\<delta>\\<^sub>2 w q\\<^sub>1 q\\<^sub>2\n  defines \"\\<rho> \\<equiv> run\\<^sub>t (\\<delta>\\<^sub>1 \\<times> \\<delta>\\<^sub>2) (q\\<^sub>1, q\\<^sub>2) w\"\n  defines \"\\<rho>\\<^sub>2 \\<equiv> run\\<^sub>t \\<delta>\\<^sub>2 q\\<^sub>2 w\"\n  assumes \"finite (range \\<rho>)\"\n  shows product_run_project_limit_snd: \"project_transition_snd ` limit \\<rho> = limit \\<rho>\\<^sub>2\"\n    and product_run_embed_limit_snd: \"limit \\<rho> \\<subseteq> \\<Union> (embed_transition_snd ` (limit \\<rho>\\<^sub>2))\"", "lemma \n  fixes \\<delta>\\<^sub>1 \\<delta>\\<^sub>2 w q\\<^sub>1 q\\<^sub>2\n  defines \"\\<rho> \\<equiv> run\\<^sub>t (\\<delta>\\<^sub>1 \\<times> \\<delta>\\<^sub>2) (q\\<^sub>1, q\\<^sub>2) w\"\n  defines \"\\<rho>\\<^sub>1 \\<equiv> run\\<^sub>t \\<delta>\\<^sub>1 q\\<^sub>1 w\"\n  defines \"\\<rho>\\<^sub>2 \\<equiv> run\\<^sub>t \\<delta>\\<^sub>2 q\\<^sub>2 w\"\n  assumes \"finite (range \\<rho>)\"\n  shows product_run_embed_limit_finiteness_fst: \"limit \\<rho> \\<inter> (\\<Union> (embed_transition_fst ` S)) = {} \\<longleftrightarrow> limit \\<rho>\\<^sub>1 \\<inter> S = {}\" (is \"?thesis1\")\n    and product_run_embed_limit_finiteness_snd: \"limit \\<rho> \\<inter> (\\<Union> (embed_transition_snd ` S')) = {} \\<longleftrightarrow> limit \\<rho>\\<^sub>2 \\<inter> S' = {}\" (is \"?thesis2\")", "lemma embed_transition_unfold:\n  \"embed_transition x t = {(m, fst (snd t), m') | m m'. m x = Some (fst t) \\<and> m' x = Some (snd (snd t))}\"", "lemma\n  fixes \\<iota>\\<^sub>m \\<delta>\\<^sub>m w q\\<^sub>0 \n  fixes x :: \"'a\"\n  defines \"\\<rho> \\<equiv> run\\<^sub>t (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m w\"\n  defines \"\\<rho>' \\<equiv> run\\<^sub>t (\\<delta>\\<^sub>m x) q\\<^sub>0 w\"\n  assumes \"\\<iota>\\<^sub>m x = Some q\\<^sub>0\"\n  shows product_run_project: \"\\<downharpoonleft>\\<^sub>x (\\<rho> i) = \\<rho>' i\" \n    and product_run_embed: \"\\<rho> i \\<in> \\<upharpoonleft>\\<^sub>x (\\<rho>' i)\"", "lemma \n  fixes \\<iota>\\<^sub>m \\<delta>\\<^sub>m w q\\<^sub>0 x\n  defines \"\\<rho> \\<equiv> run\\<^sub>t (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m w\"\n  defines \"\\<rho>' \\<equiv> run\\<^sub>t (\\<delta>\\<^sub>m x) q\\<^sub>0 w\"\n  assumes \"\\<iota>\\<^sub>m x = Some q\\<^sub>0\"\n  assumes \"finite (range \\<rho>)\"\n  shows product_run_project_limit: \"\\<downharpoonleft>\\<^sub>x ` limit \\<rho> = limit \\<rho>'\" \n    and product_run_embed_limit: \"limit \\<rho> \\<subseteq> \\<Union> (\\<upharpoonleft>\\<^sub>x ` (limit \\<rho>'))\"", "lemma product_run_embed_limit_finiteness:\n  fixes \\<iota>\\<^sub>m \\<delta>\\<^sub>m w q\\<^sub>0 k\n  defines \"\\<rho> \\<equiv> run\\<^sub>t (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m w\"\n  defines \"\\<rho>' \\<equiv> run\\<^sub>t (\\<delta>\\<^sub>m k) q\\<^sub>0 w\"\n  assumes \"\\<iota>\\<^sub>m k = Some q\\<^sub>0\"\n  assumes \"finite (range \\<rho>)\"\n  shows \"limit \\<rho> \\<inter> (\\<Union> (\\<upharpoonleft>\\<^sub>k ` S)) = {} \\<longleftrightarrow> limit \\<rho>' \\<inter> S = {}\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma product_parametric [transfer_rule]:\n  \"((A ===> B ===> C ===> B) ===> (A ===> rel_option B) ===> C ===> A ===> rel_option B) product product\"", "lemma run_parametric [transfer_rule]:\n  \"((A ===> B ===> A) ===> A ===> ((=) ===> B) ===> (=) ===> A) run run\"", "lemma reach_parametric [transfer_rule]:\n  assumes \"bi_total B\"\n  assumes \"bi_unique B\"\n  shows \"(rel_set B ===> (A ===> B ===> A) ===> A ===> rel_set A) reach reach\"", "lemma product_abs_run_None:\n  \"Mapping.lookup \\<iota>\\<^sub>m k = None \\<Longrightarrow> Mapping.lookup (run (\\<up>\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m w i) k = None\"", "lemma product_abs_run_Some:\n  \"Mapping.lookup \\<iota>\\<^sub>m k = Some q\\<^sub>0 \\<Longrightarrow> Mapping.lookup (run (\\<up>\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m w i) k = Some (run (\\<delta>\\<^sub>m k) q\\<^sub>0 w i)\"", "theorem finite_reach_product_abs:\n  assumes \"finite (Mapping.keys \\<iota>\\<^sub>m)\"\n  assumes \"\\<And>x. x \\<in> (Mapping.keys \\<iota>\\<^sub>m) \\<Longrightarrow> finite (reach \\<Sigma> (\\<delta>\\<^sub>m x) (the (Mapping.lookup \\<iota>\\<^sub>m x)))\"\n  shows \"finite (reach \\<Sigma> (\\<up>\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m)\""], "translations": [["", "lemma run_foldl:\n  \"run \\<Delta> q\\<^sub>0 w i = foldl \\<Delta> q\\<^sub>0 (map w [0..<i])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run \\<Delta> q\\<^sub>0 w i = foldl \\<Delta> q\\<^sub>0 (map w [0..<i])", "by (induction i; simp)"], ["", "lemma run\\<^sub>t_foldl:\n  \"run\\<^sub>t \\<Delta> q\\<^sub>0 w i = (foldl \\<Delta> q\\<^sub>0 (map w [0..<i]), w i, foldl \\<Delta> q\\<^sub>0 (map w [0..<Suc i]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run\\<^sub>t \\<Delta> q\\<^sub>0 w i =\n    (foldl \\<Delta> q\\<^sub>0 (map w [0..<i]), w i,\n     foldl \\<Delta> q\\<^sub>0 (map w [0..<Suc i]))", "unfolding run\\<^sub>t.simps run_foldl"], ["proof (prove)\ngoal (1 subgoal):\n 1. (foldl \\<Delta> q\\<^sub>0 (map w [0..<i]), w i,\n     foldl \\<Delta> q\\<^sub>0 (map w [0..<Suc i])) =\n    (foldl \\<Delta> q\\<^sub>0 (map w [0..<i]), w i,\n     foldl \\<Delta> q\\<^sub>0 (map w [0..<Suc i]))", ".."], ["", "subsection \\<open>Reachable States and Transitions\\<close>"], ["", "definition reach :: \"'a set \\<Rightarrow> ('b, 'a) DTS \\<Rightarrow> 'b \\<Rightarrow> 'b set\"\nwhere\n  \"reach \\<Sigma> \\<delta> q\\<^sub>0 = {run \\<delta> q\\<^sub>0 w n | w n. range w \\<subseteq> \\<Sigma>}\""], ["", "definition reach\\<^sub>t :: \"'a set \\<Rightarrow> ('b, 'a) DTS \\<Rightarrow> 'b \\<Rightarrow> ('b, 'a) transition set\"\nwhere\n  \"reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0 = {run\\<^sub>t \\<delta> q\\<^sub>0 w n | w n. range w \\<subseteq> \\<Sigma>}\""], ["", "lemma reach_foldl_def:\n  assumes \"\\<Sigma> \\<noteq> {}\"\n  shows \"reach \\<Sigma> \\<delta> q\\<^sub>0 = {foldl \\<delta> q\\<^sub>0 w | w. set w \\<subseteq> \\<Sigma>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach \\<Sigma> \\<delta> q\\<^sub>0 =\n    {foldl \\<delta> q\\<^sub>0 w |w. set w \\<subseteq> \\<Sigma>}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. reach \\<Sigma> \\<delta> q\\<^sub>0 =\n    {foldl \\<delta> q\\<^sub>0 w |w. set w \\<subseteq> \\<Sigma>}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. reach \\<Sigma> \\<delta> q\\<^sub>0 =\n    {foldl \\<delta> q\\<^sub>0 w |w. set w \\<subseteq> \\<Sigma>}", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. reach \\<Sigma> \\<delta> q\\<^sub>0 =\n    {foldl \\<delta> q\\<^sub>0 w |w. set w \\<subseteq> \\<Sigma>}", "assume \"set w \\<subseteq> \\<Sigma>\""], ["proof (state)\nthis:\n  set w \\<subseteq> \\<Sigma>\n\ngoal (1 subgoal):\n 1. reach \\<Sigma> \\<delta> q\\<^sub>0 =\n    {foldl \\<delta> q\\<^sub>0 w |w. set w \\<subseteq> \\<Sigma>}", "moreover"], ["proof (state)\nthis:\n  set w \\<subseteq> \\<Sigma>\n\ngoal (1 subgoal):\n 1. reach \\<Sigma> \\<delta> q\\<^sub>0 =\n    {foldl \\<delta> q\\<^sub>0 w |w. set w \\<subseteq> \\<Sigma>}", "obtain a where \"a \\<in> \\<Sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a. a \\<in> \\<Sigma> \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>\\<Sigma> \\<noteq> {}\\<close>"], ["proof (prove)\nusing this:\n  \\<Sigma> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>a. a \\<in> \\<Sigma> \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  a \\<in> \\<Sigma>\n\ngoal (1 subgoal):\n 1. reach \\<Sigma> \\<delta> q\\<^sub>0 =\n    {foldl \\<delta> q\\<^sub>0 w |w. set w \\<subseteq> \\<Sigma>}", "ultimately"], ["proof (chain)\npicking this:\n  set w \\<subseteq> \\<Sigma>\n  a \\<in> \\<Sigma>", "have \"foldl \\<delta> q\\<^sub>0 w = foldl \\<delta> q\\<^sub>0 (prefix (length w) (w \\<frown> (iter [a])))\" \n      and \"range (w \\<frown> (iter [a])) \\<subseteq> \\<Sigma>\""], ["proof (prove)\nusing this:\n  set w \\<subseteq> \\<Sigma>\n  a \\<in> \\<Sigma>\n\ngoal (1 subgoal):\n 1. foldl \\<delta> q\\<^sub>0 w =\n    foldl \\<delta> q\\<^sub>0\n     (prefix (length w) (w \\<frown> [a]\\<^sup>\\<omega>)) &&&\n    range (w \\<frown> [a]\\<^sup>\\<omega>) \\<subseteq> \\<Sigma>", "by (unfold prefix_conc_length, auto simp add: iter_def conc_def)"], ["proof (state)\nthis:\n  foldl \\<delta> q\\<^sub>0 w =\n  foldl \\<delta> q\\<^sub>0\n   (prefix (length w) (w \\<frown> [a]\\<^sup>\\<omega>))\n  range (w \\<frown> [a]\\<^sup>\\<omega>) \\<subseteq> \\<Sigma>\n\ngoal (1 subgoal):\n 1. reach \\<Sigma> \\<delta> q\\<^sub>0 =\n    {foldl \\<delta> q\\<^sub>0 w |w. set w \\<subseteq> \\<Sigma>}", "hence \"\\<exists>w' n. foldl \\<delta> q\\<^sub>0 w = run \\<delta> q\\<^sub>0 w' n \\<and> range w' \\<subseteq> \\<Sigma>\""], ["proof (prove)\nusing this:\n  foldl \\<delta> q\\<^sub>0 w =\n  foldl \\<delta> q\\<^sub>0\n   (prefix (length w) (w \\<frown> [a]\\<^sup>\\<omega>))\n  range (w \\<frown> [a]\\<^sup>\\<omega>) \\<subseteq> \\<Sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>w' n.\n       foldl \\<delta> q\\<^sub>0 w = run \\<delta> q\\<^sub>0 w' n \\<and>\n       range w' \\<subseteq> \\<Sigma>", "unfolding run_foldl subsequence_def"], ["proof (prove)\nusing this:\n  foldl \\<delta> q\\<^sub>0 w =\n  foldl \\<delta> q\\<^sub>0\n   (map (w \\<frown> [a]\\<^sup>\\<omega>) [0..<length w])\n  range (w \\<frown> [a]\\<^sup>\\<omega>) \\<subseteq> \\<Sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>w' n.\n       foldl \\<delta> q\\<^sub>0 w =\n       foldl \\<delta> q\\<^sub>0 (map w' [0..<n]) \\<and>\n       range w' \\<subseteq> \\<Sigma>", "by blast"], ["proof (state)\nthis:\n  \\<exists>w' n.\n     foldl \\<delta> q\\<^sub>0 w = run \\<delta> q\\<^sub>0 w' n \\<and>\n     range w' \\<subseteq> \\<Sigma>\n\ngoal (1 subgoal):\n 1. reach \\<Sigma> \\<delta> q\\<^sub>0 =\n    {foldl \\<delta> q\\<^sub>0 w |w. set w \\<subseteq> \\<Sigma>}", "}"], ["proof (state)\nthis:\n  set ?w2 \\<subseteq> \\<Sigma> \\<Longrightarrow>\n  \\<exists>w' n.\n     foldl \\<delta> q\\<^sub>0 ?w2 = run \\<delta> q\\<^sub>0 w' n \\<and>\n     range w' \\<subseteq> \\<Sigma>\n\ngoal (1 subgoal):\n 1. reach \\<Sigma> \\<delta> q\\<^sub>0 =\n    {foldl \\<delta> q\\<^sub>0 w |w. set w \\<subseteq> \\<Sigma>}", "thus ?thesis"], ["proof (prove)\nusing this:\n  set ?w2 \\<subseteq> \\<Sigma> \\<Longrightarrow>\n  \\<exists>w' n.\n     foldl \\<delta> q\\<^sub>0 ?w2 = run \\<delta> q\\<^sub>0 w' n \\<and>\n     range w' \\<subseteq> \\<Sigma>\n\ngoal (1 subgoal):\n 1. reach \\<Sigma> \\<delta> q\\<^sub>0 =\n    {foldl \\<delta> q\\<^sub>0 w |w. set w \\<subseteq> \\<Sigma>}", "by (fastforce simp add: reach_def run_foldl)"], ["proof (state)\nthis:\n  reach \\<Sigma> \\<delta> q\\<^sub>0 =\n  {foldl \\<delta> q\\<^sub>0 w |w. set w \\<subseteq> \\<Sigma>}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reach\\<^sub>t_foldl_def:\n  \"reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0 = {(foldl \\<delta> q\\<^sub>0 w, \\<nu>, foldl \\<delta> q\\<^sub>0 (w@[\\<nu>])) | w \\<nu>. set w \\<subseteq> \\<Sigma> \\<and> \\<nu> \\<in> \\<Sigma>}\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0 =\n    {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n      foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) |\n     w \\<nu>. set w \\<subseteq> \\<Sigma> \\<and> \\<nu> \\<in> \\<Sigma>}", "proof (cases \"\\<Sigma> \\<noteq> {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<Sigma> \\<noteq> {} \\<Longrightarrow>\n    reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0 =\n    {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n      foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) |\n     w \\<nu>. set w \\<subseteq> \\<Sigma> \\<and> \\<nu> \\<in> \\<Sigma>}\n 2. \\<not> \\<Sigma> \\<noteq> {} \\<Longrightarrow>\n    reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0 =\n    {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n      foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) |\n     w \\<nu>. set w \\<subseteq> \\<Sigma> \\<and> \\<nu> \\<in> \\<Sigma>}", "case True"], ["proof (state)\nthis:\n  \\<Sigma> \\<noteq> {}\n\ngoal (2 subgoals):\n 1. \\<Sigma> \\<noteq> {} \\<Longrightarrow>\n    reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0 =\n    {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n      foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) |\n     w \\<nu>. set w \\<subseteq> \\<Sigma> \\<and> \\<nu> \\<in> \\<Sigma>}\n 2. \\<not> \\<Sigma> \\<noteq> {} \\<Longrightarrow>\n    reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0 =\n    {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n      foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) |\n     w \\<nu>. set w \\<subseteq> \\<Sigma> \\<and> \\<nu> \\<in> \\<Sigma>}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0 =\n    {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n      foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) |\n     w \\<nu>. set w \\<subseteq> \\<Sigma> \\<and> \\<nu> \\<in> \\<Sigma>}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0\n    \\<subseteq> {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n                  foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) |\n                 w \\<nu>.\n                 set w \\<subseteq> \\<Sigma> \\<and> \\<nu> \\<in> \\<Sigma>}\n 2. {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n      foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) |\n     w \\<nu>. set w \\<subseteq> \\<Sigma> \\<and> \\<nu> \\<in> \\<Sigma>}\n    \\<subseteq> reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0\n    \\<subseteq> {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n                  foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) |\n                 w \\<nu>.\n                 set w \\<subseteq> \\<Sigma> \\<and> \\<nu> \\<in> \\<Sigma>}\n 2. {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n      foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) |\n     w \\<nu>. set w \\<subseteq> \\<Sigma> \\<and> \\<nu> \\<in> \\<Sigma>}\n    \\<subseteq> reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0", "fix w \\<nu>"], ["proof (state)\ngoal (2 subgoals):\n 1. reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0\n    \\<subseteq> {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n                  foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) |\n                 w \\<nu>.\n                 set w \\<subseteq> \\<Sigma> \\<and> \\<nu> \\<in> \\<Sigma>}\n 2. {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n      foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) |\n     w \\<nu>. set w \\<subseteq> \\<Sigma> \\<and> \\<nu> \\<in> \\<Sigma>}\n    \\<subseteq> reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0", "assume \"set w \\<subseteq> \\<Sigma>\" \"\\<nu> \\<in> \\<Sigma>\""], ["proof (state)\nthis:\n  set w \\<subseteq> \\<Sigma>\n  \\<nu> \\<in> \\<Sigma>\n\ngoal (2 subgoals):\n 1. reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0\n    \\<subseteq> {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n                  foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) |\n                 w \\<nu>.\n                 set w \\<subseteq> \\<Sigma> \\<and> \\<nu> \\<in> \\<Sigma>}\n 2. {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n      foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) |\n     w \\<nu>. set w \\<subseteq> \\<Sigma> \\<and> \\<nu> \\<in> \\<Sigma>}\n    \\<subseteq> reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0", "moreover"], ["proof (state)\nthis:\n  set w \\<subseteq> \\<Sigma>\n  \\<nu> \\<in> \\<Sigma>\n\ngoal (2 subgoals):\n 1. reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0\n    \\<subseteq> {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n                  foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) |\n                 w \\<nu>.\n                 set w \\<subseteq> \\<Sigma> \\<and> \\<nu> \\<in> \\<Sigma>}\n 2. {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n      foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) |\n     w \\<nu>. set w \\<subseteq> \\<Sigma> \\<and> \\<nu> \\<in> \\<Sigma>}\n    \\<subseteq> reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0", "obtain a where \"a \\<in> \\<Sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a. a \\<in> \\<Sigma> \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>\\<Sigma> \\<noteq> {}\\<close>"], ["proof (prove)\nusing this:\n  \\<Sigma> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>a. a \\<in> \\<Sigma> \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  a \\<in> \\<Sigma>\n\ngoal (2 subgoals):\n 1. reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0\n    \\<subseteq> {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n                  foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) |\n                 w \\<nu>.\n                 set w \\<subseteq> \\<Sigma> \\<and> \\<nu> \\<in> \\<Sigma>}\n 2. {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n      foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) |\n     w \\<nu>. set w \\<subseteq> \\<Sigma> \\<and> \\<nu> \\<in> \\<Sigma>}\n    \\<subseteq> reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0", "moreover"], ["proof (state)\nthis:\n  a \\<in> \\<Sigma>\n\ngoal (2 subgoals):\n 1. reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0\n    \\<subseteq> {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n                  foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) |\n                 w \\<nu>.\n                 set w \\<subseteq> \\<Sigma> \\<and> \\<nu> \\<in> \\<Sigma>}\n 2. {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n      foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) |\n     w \\<nu>. set w \\<subseteq> \\<Sigma> \\<and> \\<nu> \\<in> \\<Sigma>}\n    \\<subseteq> reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0", "have \"w = map (\\<lambda>n. if n < length w then w ! n else if n - length w = 0 then [\\<nu>] ! (n - length w) else a) [0..<length w]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w =\n    map (\\<lambda>n.\n            if n < length w then w ! n\n            else if n - length w = 0 then [\\<nu>] ! (n - length w) else a)\n     [0..<length w]", "by (simp add: nth_equalityI)"], ["proof (state)\nthis:\n  w =\n  map (\\<lambda>n.\n          if n < length w then w ! n\n          else if n - length w = 0 then [\\<nu>] ! (n - length w) else a)\n   [0..<length w]\n\ngoal (2 subgoals):\n 1. reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0\n    \\<subseteq> {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n                  foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) |\n                 w \\<nu>.\n                 set w \\<subseteq> \\<Sigma> \\<and> \\<nu> \\<in> \\<Sigma>}\n 2. {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n      foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) |\n     w \\<nu>. set w \\<subseteq> \\<Sigma> \\<and> \\<nu> \\<in> \\<Sigma>}\n    \\<subseteq> reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0", "ultimately"], ["proof (chain)\npicking this:\n  set w \\<subseteq> \\<Sigma>\n  \\<nu> \\<in> \\<Sigma>\n  a \\<in> \\<Sigma>\n  w =\n  map (\\<lambda>n.\n          if n < length w then w ! n\n          else if n - length w = 0 then [\\<nu>] ! (n - length w) else a)\n   [0..<length w]", "have \"foldl \\<delta> q\\<^sub>0 w = foldl \\<delta> q\\<^sub>0 (prefix (length w) ((w @ [\\<nu>]) \\<frown> (iter [a])))\" \n          and\"foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>]) = foldl \\<delta> q\\<^sub>0 (prefix (length (w @ [\\<nu>])) ((w @ [\\<nu>]) \\<frown> (iter [a])))\" \n          and \"range ((w @ [\\<nu>]) \\<frown> (iter [a])) \\<subseteq> \\<Sigma>\""], ["proof (prove)\nusing this:\n  set w \\<subseteq> \\<Sigma>\n  \\<nu> \\<in> \\<Sigma>\n  a \\<in> \\<Sigma>\n  w =\n  map (\\<lambda>n.\n          if n < length w then w ! n\n          else if n - length w = 0 then [\\<nu>] ! (n - length w) else a)\n   [0..<length w]\n\ngoal (1 subgoal):\n 1. foldl \\<delta> q\\<^sub>0 w =\n    foldl \\<delta> q\\<^sub>0\n     (prefix (length w) ((w @ [\\<nu>]) \\<frown> [a]\\<^sup>\\<omega>)) &&&\n    foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>]) =\n    foldl \\<delta> q\\<^sub>0\n     (prefix (length (w @ [\\<nu>]))\n       ((w @ [\\<nu>]) \\<frown> [a]\\<^sup>\\<omega>)) &&&\n    range ((w @ [\\<nu>]) \\<frown> [a]\\<^sup>\\<omega>) \\<subseteq> \\<Sigma>", "by (simp_all only: prefix_conc_length conc_conc[symmetric] iter_def)\n             (auto simp add: subsequence_def conc_def upt_Suc_append[OF le0])"], ["proof (state)\nthis:\n  foldl \\<delta> q\\<^sub>0 w =\n  foldl \\<delta> q\\<^sub>0\n   (prefix (length w) ((w @ [\\<nu>]) \\<frown> [a]\\<^sup>\\<omega>))\n  foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>]) =\n  foldl \\<delta> q\\<^sub>0\n   (prefix (length (w @ [\\<nu>]))\n     ((w @ [\\<nu>]) \\<frown> [a]\\<^sup>\\<omega>))\n  range ((w @ [\\<nu>]) \\<frown> [a]\\<^sup>\\<omega>) \\<subseteq> \\<Sigma>\n\ngoal (2 subgoals):\n 1. reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0\n    \\<subseteq> {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n                  foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) |\n                 w \\<nu>.\n                 set w \\<subseteq> \\<Sigma> \\<and> \\<nu> \\<in> \\<Sigma>}\n 2. {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n      foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) |\n     w \\<nu>. set w \\<subseteq> \\<Sigma> \\<and> \\<nu> \\<in> \\<Sigma>}\n    \\<subseteq> reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0", "moreover"], ["proof (state)\nthis:\n  foldl \\<delta> q\\<^sub>0 w =\n  foldl \\<delta> q\\<^sub>0\n   (prefix (length w) ((w @ [\\<nu>]) \\<frown> [a]\\<^sup>\\<omega>))\n  foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>]) =\n  foldl \\<delta> q\\<^sub>0\n   (prefix (length (w @ [\\<nu>]))\n     ((w @ [\\<nu>]) \\<frown> [a]\\<^sup>\\<omega>))\n  range ((w @ [\\<nu>]) \\<frown> [a]\\<^sup>\\<omega>) \\<subseteq> \\<Sigma>\n\ngoal (2 subgoals):\n 1. reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0\n    \\<subseteq> {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n                  foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) |\n                 w \\<nu>.\n                 set w \\<subseteq> \\<Sigma> \\<and> \\<nu> \\<in> \\<Sigma>}\n 2. {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n      foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) |\n     w \\<nu>. set w \\<subseteq> \\<Sigma> \\<and> \\<nu> \\<in> \\<Sigma>}\n    \\<subseteq> reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0", "have \"((w @ [\\<nu>]) \\<frown> (iter [a])) (length w) = \\<nu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((w @ [\\<nu>]) \\<frown> [a]\\<^sup>\\<omega>) (length w) = \\<nu>", "by (simp add: conc_def)"], ["proof (state)\nthis:\n  ((w @ [\\<nu>]) \\<frown> [a]\\<^sup>\\<omega>) (length w) = \\<nu>\n\ngoal (2 subgoals):\n 1. reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0\n    \\<subseteq> {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n                  foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) |\n                 w \\<nu>.\n                 set w \\<subseteq> \\<Sigma> \\<and> \\<nu> \\<in> \\<Sigma>}\n 2. {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n      foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) |\n     w \\<nu>. set w \\<subseteq> \\<Sigma> \\<and> \\<nu> \\<in> \\<Sigma>}\n    \\<subseteq> reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0", "ultimately"], ["proof (chain)\npicking this:\n  foldl \\<delta> q\\<^sub>0 w =\n  foldl \\<delta> q\\<^sub>0\n   (prefix (length w) ((w @ [\\<nu>]) \\<frown> [a]\\<^sup>\\<omega>))\n  foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>]) =\n  foldl \\<delta> q\\<^sub>0\n   (prefix (length (w @ [\\<nu>]))\n     ((w @ [\\<nu>]) \\<frown> [a]\\<^sup>\\<omega>))\n  range ((w @ [\\<nu>]) \\<frown> [a]\\<^sup>\\<omega>) \\<subseteq> \\<Sigma>\n  ((w @ [\\<nu>]) \\<frown> [a]\\<^sup>\\<omega>) (length w) = \\<nu>", "have \"\\<exists>w' n. (foldl \\<delta> q\\<^sub>0 w, \\<nu>, foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) = run\\<^sub>t \\<delta> q\\<^sub>0 w' n \\<and> range w' \\<subseteq> \\<Sigma>\""], ["proof (prove)\nusing this:\n  foldl \\<delta> q\\<^sub>0 w =\n  foldl \\<delta> q\\<^sub>0\n   (prefix (length w) ((w @ [\\<nu>]) \\<frown> [a]\\<^sup>\\<omega>))\n  foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>]) =\n  foldl \\<delta> q\\<^sub>0\n   (prefix (length (w @ [\\<nu>]))\n     ((w @ [\\<nu>]) \\<frown> [a]\\<^sup>\\<omega>))\n  range ((w @ [\\<nu>]) \\<frown> [a]\\<^sup>\\<omega>) \\<subseteq> \\<Sigma>\n  ((w @ [\\<nu>]) \\<frown> [a]\\<^sup>\\<omega>) (length w) = \\<nu>\n\ngoal (1 subgoal):\n 1. \\<exists>w' n.\n       (foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n        foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) =\n       run\\<^sub>t \\<delta> q\\<^sub>0 w' n \\<and>\n       range w' \\<subseteq> \\<Sigma>", "by (metis run\\<^sub>t_foldl length_append_singleton subsequence_def)"], ["proof (state)\nthis:\n  \\<exists>w' n.\n     (foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n      foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) =\n     run\\<^sub>t \\<delta> q\\<^sub>0 w' n \\<and>\n     range w' \\<subseteq> \\<Sigma>\n\ngoal (2 subgoals):\n 1. reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0\n    \\<subseteq> {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n                  foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) |\n                 w \\<nu>.\n                 set w \\<subseteq> \\<Sigma> \\<and> \\<nu> \\<in> \\<Sigma>}\n 2. {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n      foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) |\n     w \\<nu>. set w \\<subseteq> \\<Sigma> \\<and> \\<nu> \\<in> \\<Sigma>}\n    \\<subseteq> reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0", "}"], ["proof (state)\nthis:\n  \\<lbrakk>set ?w2 \\<subseteq> \\<Sigma>; ?\\<nu>2 \\<in> \\<Sigma>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>w' n.\n                       (foldl \\<delta> q\\<^sub>0 ?w2, ?\\<nu>2,\n                        foldl \\<delta> q\\<^sub>0 (?w2 @ [?\\<nu>2])) =\n                       run\\<^sub>t \\<delta> q\\<^sub>0 w' n \\<and>\n                       range w' \\<subseteq> \\<Sigma>\n\ngoal (2 subgoals):\n 1. reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0\n    \\<subseteq> {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n                  foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) |\n                 w \\<nu>.\n                 set w \\<subseteq> \\<Sigma> \\<and> \\<nu> \\<in> \\<Sigma>}\n 2. {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n      foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) |\n     w \\<nu>. set w \\<subseteq> \\<Sigma> \\<and> \\<nu> \\<in> \\<Sigma>}\n    \\<subseteq> reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0", "thus \"?lhs \\<supseteq> ?rhs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>set ?w2 \\<subseteq> \\<Sigma>; ?\\<nu>2 \\<in> \\<Sigma>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>w' n.\n                       (foldl \\<delta> q\\<^sub>0 ?w2, ?\\<nu>2,\n                        foldl \\<delta> q\\<^sub>0 (?w2 @ [?\\<nu>2])) =\n                       run\\<^sub>t \\<delta> q\\<^sub>0 w' n \\<and>\n                       range w' \\<subseteq> \\<Sigma>\n\ngoal (1 subgoal):\n 1. {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n      foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) |\n     w \\<nu>. set w \\<subseteq> \\<Sigma> \\<and> \\<nu> \\<in> \\<Sigma>}\n    \\<subseteq> reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0", "unfolding reach\\<^sub>t_def run\\<^sub>t.simps"], ["proof (prove)\nusing this:\n  \\<lbrakk>set ?w2 \\<subseteq> \\<Sigma>; ?\\<nu>2 \\<in> \\<Sigma>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>w' n.\n                       (foldl \\<delta> q\\<^sub>0 ?w2, ?\\<nu>2,\n                        foldl \\<delta> q\\<^sub>0 (?w2 @ [?\\<nu>2])) =\n                       (run \\<delta> q\\<^sub>0 w' n, w' n,\n                        run \\<delta> q\\<^sub>0 w' (Suc n)) \\<and>\n                       range w' \\<subseteq> \\<Sigma>\n\ngoal (1 subgoal):\n 1. {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n      foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) |\n     w \\<nu>. set w \\<subseteq> \\<Sigma> \\<and> \\<nu> \\<in> \\<Sigma>}\n    \\<subseteq> {(run \\<delta> q\\<^sub>0 w n, w n,\n                  run \\<delta> q\\<^sub>0 w (Suc n)) |\n                 w n. range w \\<subseteq> \\<Sigma>}", "by blast"], ["proof (state)\nthis:\n  {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n    foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) |\n   w \\<nu>. set w \\<subseteq> \\<Sigma> \\<and> \\<nu> \\<in> \\<Sigma>}\n  \\<subseteq> reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0\n\ngoal (1 subgoal):\n 1. reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0\n    \\<subseteq> {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n                  foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) |\n                 w \\<nu>.\n                 set w \\<subseteq> \\<Sigma> \\<and> \\<nu> \\<in> \\<Sigma>}", "qed (unfold reach\\<^sub>t_def run\\<^sub>t_foldl, fastforce simp add: upt_Suc_append)"], ["proof (state)\nthis:\n  reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0 =\n  {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n    foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) |\n   w \\<nu>. set w \\<subseteq> \\<Sigma> \\<and> \\<nu> \\<in> \\<Sigma>}\n\ngoal (1 subgoal):\n 1. \\<not> \\<Sigma> \\<noteq> {} \\<Longrightarrow>\n    reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0 =\n    {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n      foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) |\n     w \\<nu>. set w \\<subseteq> \\<Sigma> \\<and> \\<nu> \\<in> \\<Sigma>}", "qed (simp add: reach\\<^sub>t_def)"], ["", "lemma reach_card_0:\n  assumes \"\\<Sigma> \\<noteq> {}\"\n  shows \"infinite (reach \\<Sigma> \\<delta> q\\<^sub>0) \\<longleftrightarrow> card (reach \\<Sigma> \\<delta> q\\<^sub>0) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (reach \\<Sigma> \\<delta> q\\<^sub>0) =\n    (card (reach \\<Sigma> \\<delta> q\\<^sub>0) = 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite (reach \\<Sigma> \\<delta> q\\<^sub>0) =\n    (card (reach \\<Sigma> \\<delta> q\\<^sub>0) = 0)", "have \"{run \\<delta> q\\<^sub>0 w n | w n. range w \\<subseteq> \\<Sigma>} \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {run \\<delta> q\\<^sub>0 w n |w n. range w \\<subseteq> \\<Sigma>} \\<noteq>\n    {}", "using assms"], ["proof (prove)\nusing this:\n  \\<Sigma> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. {run \\<delta> q\\<^sub>0 w n |w n. range w \\<subseteq> \\<Sigma>} \\<noteq>\n    {}", "by fast"], ["proof (state)\nthis:\n  {run \\<delta> q\\<^sub>0 w n |w n. range w \\<subseteq> \\<Sigma>} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. infinite (reach \\<Sigma> \\<delta> q\\<^sub>0) =\n    (card (reach \\<Sigma> \\<delta> q\\<^sub>0) = 0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  {run \\<delta> q\\<^sub>0 w n |w n. range w \\<subseteq> \\<Sigma>} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. infinite (reach \\<Sigma> \\<delta> q\\<^sub>0) =\n    (card (reach \\<Sigma> \\<delta> q\\<^sub>0) = 0)", "unfolding reach_def card_eq_0_iff"], ["proof (prove)\nusing this:\n  {run \\<delta> q\\<^sub>0 w n |w n. range w \\<subseteq> \\<Sigma>} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. infinite\n     {run \\<delta> q\\<^sub>0 w n |w n. range w \\<subseteq> \\<Sigma>} =\n    ({run \\<delta> q\\<^sub>0 w n |w n. range w \\<subseteq> \\<Sigma>} =\n     {} \\<or>\n     infinite\n      {run \\<delta> q\\<^sub>0 w n |w n. range w \\<subseteq> \\<Sigma>})", "by auto"], ["proof (state)\nthis:\n  infinite (reach \\<Sigma> \\<delta> q\\<^sub>0) =\n  (card (reach \\<Sigma> \\<delta> q\\<^sub>0) = 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reach\\<^sub>t_card_0:\n  assumes \"\\<Sigma> \\<noteq> {}\"\n  shows \"infinite (reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0) \\<longleftrightarrow> card (reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0) =\n    (card (reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0) = 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite (reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0) =\n    (card (reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0) = 0)", "have \"{run\\<^sub>t \\<delta> q\\<^sub>0 w n | w n. range w \\<subseteq> \\<Sigma>} \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {run\\<^sub>t \\<delta> q\\<^sub>0 w n |w n.\n     range w \\<subseteq> \\<Sigma>} \\<noteq>\n    {}", "using assms"], ["proof (prove)\nusing this:\n  \\<Sigma> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. {run\\<^sub>t \\<delta> q\\<^sub>0 w n |w n.\n     range w \\<subseteq> \\<Sigma>} \\<noteq>\n    {}", "by fast"], ["proof (state)\nthis:\n  {run\\<^sub>t \\<delta> q\\<^sub>0 w n |w n.\n   range w \\<subseteq> \\<Sigma>} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. infinite (reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0) =\n    (card (reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0) = 0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  {run\\<^sub>t \\<delta> q\\<^sub>0 w n |w n.\n   range w \\<subseteq> \\<Sigma>} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. infinite (reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0) =\n    (card (reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0) = 0)", "unfolding reach\\<^sub>t_def card_eq_0_iff"], ["proof (prove)\nusing this:\n  {run\\<^sub>t \\<delta> q\\<^sub>0 w n |w n.\n   range w \\<subseteq> \\<Sigma>} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. infinite\n     {run\\<^sub>t \\<delta> q\\<^sub>0 w n |w n.\n      range w \\<subseteq> \\<Sigma>} =\n    ({run\\<^sub>t \\<delta> q\\<^sub>0 w n |w n.\n      range w \\<subseteq> \\<Sigma>} =\n     {} \\<or>\n     infinite\n      {run\\<^sub>t \\<delta> q\\<^sub>0 w n |w n.\n       range w \\<subseteq> \\<Sigma>})", "by blast"], ["proof (state)\nthis:\n  infinite (reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0) =\n  (card (reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0) = 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Relation to runs\\<close>"], ["", "lemma run_subseteq_reach:\n  assumes \"range w \\<subseteq> \\<Sigma>\"\n  shows \"range (run \\<delta> q\\<^sub>0 w) \\<subseteq> reach \\<Sigma> \\<delta> q\\<^sub>0\" \n    and \"range (run\\<^sub>t \\<delta> q\\<^sub>0 w) \\<subseteq> reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range (run \\<delta> q\\<^sub>0 w)\n    \\<subseteq> reach \\<Sigma> \\<delta> q\\<^sub>0 &&&\n    range (run\\<^sub>t \\<delta> q\\<^sub>0 w)\n    \\<subseteq> reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0", "using assms"], ["proof (prove)\nusing this:\n  range w \\<subseteq> \\<Sigma>\n\ngoal (1 subgoal):\n 1. range (run \\<delta> q\\<^sub>0 w)\n    \\<subseteq> reach \\<Sigma> \\<delta> q\\<^sub>0 &&&\n    range (run\\<^sub>t \\<delta> q\\<^sub>0 w)\n    \\<subseteq> reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0", "unfolding reach_def reach\\<^sub>t_def"], ["proof (prove)\nusing this:\n  range w \\<subseteq> \\<Sigma>\n\ngoal (1 subgoal):\n 1. range (run \\<delta> q\\<^sub>0 w)\n    \\<subseteq> {run \\<delta> q\\<^sub>0 w n |w n.\n                 range w \\<subseteq> \\<Sigma>} &&&\n    range (run\\<^sub>t \\<delta> q\\<^sub>0 w)\n    \\<subseteq> {run\\<^sub>t \\<delta> q\\<^sub>0 w n |w n.\n                 range w \\<subseteq> \\<Sigma>}", "by blast+"], ["", "lemma limit_subseteq_reach:\n  assumes \"range w \\<subseteq> \\<Sigma>\"\n  shows \"limit (run \\<delta> q\\<^sub>0 w) \\<subseteq> reach \\<Sigma> \\<delta> q\\<^sub>0\"\n    and \"limit (run\\<^sub>t \\<delta> q\\<^sub>0 w) \\<subseteq> reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. limit (run \\<delta> q\\<^sub>0 w)\n    \\<subseteq> reach \\<Sigma> \\<delta> q\\<^sub>0 &&&\n    limit (run\\<^sub>t \\<delta> q\\<^sub>0 w)\n    \\<subseteq> reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0", "using run_subseteq_reach[OF assms] limit_in_range"], ["proof (prove)\nusing this:\n  range (run ?\\<delta> ?q\\<^sub>0 w)\n  \\<subseteq> reach \\<Sigma> ?\\<delta> ?q\\<^sub>0\n  range (run\\<^sub>t ?\\<delta> ?q\\<^sub>0 w)\n  \\<subseteq> reach\\<^sub>t \\<Sigma> ?\\<delta> ?q\\<^sub>0\n  limit ?r \\<subseteq> range ?r\n\ngoal (1 subgoal):\n 1. limit (run \\<delta> q\\<^sub>0 w)\n    \\<subseteq> reach \\<Sigma> \\<delta> q\\<^sub>0 &&&\n    limit (run\\<^sub>t \\<delta> q\\<^sub>0 w)\n    \\<subseteq> reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0", "by fast+"], ["", "lemma run\\<^sub>t_finite:\n  assumes \"finite (reach \\<Sigma> \\<delta> q\\<^sub>0)\"\n  assumes \"finite \\<Sigma>\"\n  assumes \"range w \\<subseteq> \\<Sigma>\"\n  defines \"r \\<equiv> run\\<^sub>t \\<delta> q\\<^sub>0 w\"\n  shows \"finite (range r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (range r)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (range r)", "let ?S = \"(reach \\<Sigma> \\<delta> q\\<^sub>0) \\<times> \\<Sigma> \\<times> (reach \\<Sigma> \\<delta> q\\<^sub>0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite (range r)", "have \"\\<And>i. w i \\<in> \\<Sigma>\" and \"\\<And>i. set (map w [0..<i]) \\<subseteq> \\<Sigma>\" and \"\\<Sigma> \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i. w i \\<in> \\<Sigma>) &&&\n    (\\<And>i. set (map w [0..<i]) \\<subseteq> \\<Sigma>) &&&\n    \\<Sigma> \\<noteq> {}", "using \\<open>range w \\<subseteq> \\<Sigma>\\<close>"], ["proof (prove)\nusing this:\n  range w \\<subseteq> \\<Sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>i. w i \\<in> \\<Sigma>) &&&\n    (\\<And>i. set (map w [0..<i]) \\<subseteq> \\<Sigma>) &&&\n    \\<Sigma> \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  w ?i \\<in> \\<Sigma>\n  set (map w [0..<?i]) \\<subseteq> \\<Sigma>\n  \\<Sigma> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. finite (range r)", "hence \"\\<And>n. r n \\<in> ?S\""], ["proof (prove)\nusing this:\n  w ?i \\<in> \\<Sigma>\n  set (map w [0..<?i]) \\<subseteq> \\<Sigma>\n  \\<Sigma> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       r n\n       \\<in> reach \\<Sigma> \\<delta> q\\<^sub>0 \\<times>\n             \\<Sigma> \\<times> reach \\<Sigma> \\<delta> q\\<^sub>0", "unfolding run\\<^sub>t.simps run_foldl reach_foldl_def[OF \\<open>\\<Sigma> \\<noteq> {}\\<close>] r_def"], ["proof (prove)\nusing this:\n  w ?i \\<in> \\<Sigma>\n  set (map w [0..<?i]) \\<subseteq> \\<Sigma>\n  \\<Sigma> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (foldl \\<delta> q\\<^sub>0 (map w [0..<n]), w n,\n        foldl \\<delta> q\\<^sub>0 (map w [0..<Suc n]))\n       \\<in> {foldl \\<delta> q\\<^sub>0 w |w.\n              set w \\<subseteq> \\<Sigma>} \\<times>\n             \\<Sigma> \\<times>\n             {foldl \\<delta> q\\<^sub>0 w |w. set w \\<subseteq> \\<Sigma>}", "by blast"], ["proof (state)\nthis:\n  r ?n\n  \\<in> reach \\<Sigma> \\<delta> q\\<^sub>0 \\<times>\n        \\<Sigma> \\<times> reach \\<Sigma> \\<delta> q\\<^sub>0\n\ngoal (1 subgoal):\n 1. finite (range r)", "hence \"range r \\<subseteq> ?S\" and \"finite ?S\""], ["proof (prove)\nusing this:\n  r ?n\n  \\<in> reach \\<Sigma> \\<delta> q\\<^sub>0 \\<times>\n        \\<Sigma> \\<times> reach \\<Sigma> \\<delta> q\\<^sub>0\n\ngoal (1 subgoal):\n 1. range r\n    \\<subseteq> reach \\<Sigma> \\<delta> q\\<^sub>0 \\<times>\n                \\<Sigma> \\<times> reach \\<Sigma> \\<delta> q\\<^sub>0 &&&\n    finite\n     (reach \\<Sigma> \\<delta> q\\<^sub>0 \\<times>\n      \\<Sigma> \\<times> reach \\<Sigma> \\<delta> q\\<^sub>0)", "using assms"], ["proof (prove)\nusing this:\n  r ?n\n  \\<in> reach \\<Sigma> \\<delta> q\\<^sub>0 \\<times>\n        \\<Sigma> \\<times> reach \\<Sigma> \\<delta> q\\<^sub>0\n  finite (reach \\<Sigma> \\<delta> q\\<^sub>0)\n  finite \\<Sigma>\n  range w \\<subseteq> \\<Sigma>\n  r \\<equiv> run\\<^sub>t \\<delta> q\\<^sub>0 w\n\ngoal (1 subgoal):\n 1. range r\n    \\<subseteq> reach \\<Sigma> \\<delta> q\\<^sub>0 \\<times>\n                \\<Sigma> \\<times> reach \\<Sigma> \\<delta> q\\<^sub>0 &&&\n    finite\n     (reach \\<Sigma> \\<delta> q\\<^sub>0 \\<times>\n      \\<Sigma> \\<times> reach \\<Sigma> \\<delta> q\\<^sub>0)", "by blast+"], ["proof (state)\nthis:\n  range r\n  \\<subseteq> reach \\<Sigma> \\<delta> q\\<^sub>0 \\<times>\n              \\<Sigma> \\<times> reach \\<Sigma> \\<delta> q\\<^sub>0\n  finite\n   (reach \\<Sigma> \\<delta> q\\<^sub>0 \\<times>\n    \\<Sigma> \\<times> reach \\<Sigma> \\<delta> q\\<^sub>0)\n\ngoal (1 subgoal):\n 1. finite (range r)", "thus \"finite (range r)\""], ["proof (prove)\nusing this:\n  range r\n  \\<subseteq> reach \\<Sigma> \\<delta> q\\<^sub>0 \\<times>\n              \\<Sigma> \\<times> reach \\<Sigma> \\<delta> q\\<^sub>0\n  finite\n   (reach \\<Sigma> \\<delta> q\\<^sub>0 \\<times>\n    \\<Sigma> \\<times> reach \\<Sigma> \\<delta> q\\<^sub>0)\n\ngoal (1 subgoal):\n 1. finite (range r)", "by (blast dest: finite_subset)"], ["proof (state)\nthis:\n  finite (range r)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Compute reach Using DFS\\<close>"], ["", "definition Q\\<^sub>L :: \"'a list \\<Rightarrow> ('b, 'a) DTS \\<Rightarrow> 'b \\<Rightarrow> 'b set\"\nwhere\n  \"Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 = (if \\<Sigma> \\<noteq> [] then gen_dfs (\\<lambda>q. map (\\<delta> q) \\<Sigma>) Set.insert (\\<in>) {} [q\\<^sub>0] else {})\""], ["", "definition list_dfs :: \"(('a, 'b) transition \\<Rightarrow> ('a, 'b) transition list) \\<Rightarrow> ('a, 'b) transition list => ('a, 'b) transition list => ('a, 'b) transition list\"\nwhere\n  \"list_dfs succ S start \\<equiv> gen_dfs succ List.insert (\\<lambda>x xs. x \\<in> set xs) S start\""], ["", "definition \\<delta>\\<^sub>L :: \"'a list \\<Rightarrow> ('b, 'a) DTS \\<Rightarrow> 'b \\<Rightarrow> ('b, 'a) transition set\"\nwhere\n  \"\\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 = set ( \n    let \n      start = map (\\<lambda>\\<nu>. (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>)) \\<Sigma>; \n      succ = \\<lambda>(_, _, q). (map (\\<lambda>\\<nu>. (q, \\<nu>, \\<delta> q \\<nu>)) \\<Sigma>)\n    in \n      (list_dfs succ [] start))\""], ["", "lemma Q\\<^sub>L_reach:\n  assumes \"finite (reach (set \\<Sigma>) \\<delta> q\\<^sub>0)\"\n  shows \"Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 = reach (set \\<Sigma>) \\<delta> q\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0", "proof (cases \"\\<Sigma> \\<noteq> []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0\n 2. \\<not> \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0", "case True"], ["proof (state)\nthis:\n  \\<Sigma> \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0\n 2. \\<not> \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0", "hence reach_redef: \"reach (set \\<Sigma>) \\<delta> q\\<^sub>0 = {foldl \\<delta> q\\<^sub>0 w | w. set w \\<subseteq> set \\<Sigma>}\""], ["proof (prove)\nusing this:\n  \\<Sigma> \\<noteq> []\n\ngoal (1 subgoal):\n 1. reach (set \\<Sigma>) \\<delta> q\\<^sub>0 =\n    {foldl \\<delta> q\\<^sub>0 w |w. set w \\<subseteq> set \\<Sigma>}", "using reach_foldl_def[of \"set \\<Sigma>\"]"], ["proof (prove)\nusing this:\n  \\<Sigma> \\<noteq> []\n  set \\<Sigma> \\<noteq> {} \\<Longrightarrow>\n  reach (set \\<Sigma>) ?\\<delta> ?q\\<^sub>0 =\n  {foldl ?\\<delta> ?q\\<^sub>0 w |w. set w \\<subseteq> set \\<Sigma>}\n\ngoal (1 subgoal):\n 1. reach (set \\<Sigma>) \\<delta> q\\<^sub>0 =\n    {foldl \\<delta> q\\<^sub>0 w |w. set w \\<subseteq> set \\<Sigma>}", "unfolding set_empty[of \\<Sigma>, symmetric]"], ["proof (prove)\nusing this:\n  set \\<Sigma> \\<noteq> {}\n  set \\<Sigma> \\<noteq> {} \\<Longrightarrow>\n  reach (set \\<Sigma>) ?\\<delta> ?q\\<^sub>0 =\n  {foldl ?\\<delta> ?q\\<^sub>0 w |w. set w \\<subseteq> set \\<Sigma>}\n\ngoal (1 subgoal):\n 1. reach (set \\<Sigma>) \\<delta> q\\<^sub>0 =\n    {foldl \\<delta> q\\<^sub>0 w |w. set w \\<subseteq> set \\<Sigma>}", "by force"], ["proof (state)\nthis:\n  reach (set \\<Sigma>) \\<delta> q\\<^sub>0 =\n  {foldl \\<delta> q\\<^sub>0 w |w. set w \\<subseteq> set \\<Sigma>}\n\ngoal (2 subgoals):\n 1. \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0\n 2. \\<not> \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0", "{"], ["proof (state)\nthis:\n  reach (set \\<Sigma>) \\<delta> q\\<^sub>0 =\n  {foldl \\<delta> q\\<^sub>0 w |w. set w \\<subseteq> set \\<Sigma>}\n\ngoal (2 subgoals):\n 1. \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0\n 2. \\<not> \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0", "fix x w y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0\n 2. \\<not> \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0", "assume \"set w \\<subseteq> set \\<Sigma>\" \"x = foldl \\<delta> q\\<^sub>0 w\" \"y \\<in> set (map (\\<delta> x) \\<Sigma>)\""], ["proof (state)\nthis:\n  set w \\<subseteq> set \\<Sigma>\n  x = foldl \\<delta> q\\<^sub>0 w\n  y \\<in> set (map (\\<delta> x) \\<Sigma>)\n\ngoal (2 subgoals):\n 1. \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0\n 2. \\<not> \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0", "moreover"], ["proof (state)\nthis:\n  set w \\<subseteq> set \\<Sigma>\n  x = foldl \\<delta> q\\<^sub>0 w\n  y \\<in> set (map (\\<delta> x) \\<Sigma>)\n\ngoal (2 subgoals):\n 1. \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0\n 2. \\<not> \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0", "then"], ["proof (chain)\npicking this:\n  set w \\<subseteq> set \\<Sigma>\n  x = foldl \\<delta> q\\<^sub>0 w\n  y \\<in> set (map (\\<delta> x) \\<Sigma>)", "obtain \\<nu> where \"y = \\<delta> x \\<nu>\" and \"\\<nu> \\<in> set \\<Sigma>\""], ["proof (prove)\nusing this:\n  set w \\<subseteq> set \\<Sigma>\n  x = foldl \\<delta> q\\<^sub>0 w\n  y \\<in> set (map (\\<delta> x) \\<Sigma>)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<nu>.\n        \\<lbrakk>y = \\<delta> x \\<nu>; \\<nu> \\<in> set \\<Sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y = \\<delta> x \\<nu>\n  \\<nu> \\<in> set \\<Sigma>\n\ngoal (2 subgoals):\n 1. \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0\n 2. \\<not> \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0", "ultimately"], ["proof (chain)\npicking this:\n  set w \\<subseteq> set \\<Sigma>\n  x = foldl \\<delta> q\\<^sub>0 w\n  y \\<in> set (map (\\<delta> x) \\<Sigma>)\n  y = \\<delta> x \\<nu>\n  \\<nu> \\<in> set \\<Sigma>", "have \"y = foldl \\<delta> q\\<^sub>0 (w@[\\<nu>])\" and \"set (w@[\\<nu>]) \\<subseteq> set \\<Sigma>\""], ["proof (prove)\nusing this:\n  set w \\<subseteq> set \\<Sigma>\n  x = foldl \\<delta> q\\<^sub>0 w\n  y \\<in> set (map (\\<delta> x) \\<Sigma>)\n  y = \\<delta> x \\<nu>\n  \\<nu> \\<in> set \\<Sigma>\n\ngoal (1 subgoal):\n 1. y = foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>]) &&&\n    set (w @ [\\<nu>]) \\<subseteq> set \\<Sigma>", "by simp+"], ["proof (state)\nthis:\n  y = foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])\n  set (w @ [\\<nu>]) \\<subseteq> set \\<Sigma>\n\ngoal (2 subgoals):\n 1. \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0\n 2. \\<not> \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0", "hence \"\\<exists>w'. set w' \\<subseteq> set \\<Sigma> \\<and> y = foldl  \\<delta> q\\<^sub>0 w'\""], ["proof (prove)\nusing this:\n  y = foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])\n  set (w @ [\\<nu>]) \\<subseteq> set \\<Sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>w'.\n       set w' \\<subseteq> set \\<Sigma> \\<and>\n       y = foldl \\<delta> q\\<^sub>0 w'", "by blast"], ["proof (state)\nthis:\n  \\<exists>w'.\n     set w' \\<subseteq> set \\<Sigma> \\<and> y = foldl \\<delta> q\\<^sub>0 w'\n\ngoal (2 subgoals):\n 1. \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0\n 2. \\<not> \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0", "}"], ["proof (state)\nthis:\n  \\<lbrakk>set ?w2 \\<subseteq> set \\<Sigma>;\n   ?x2 = foldl \\<delta> q\\<^sub>0 ?w2;\n   ?y2 \\<in> set (map (\\<delta> ?x2) \\<Sigma>)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>w'.\n                       set w' \\<subseteq> set \\<Sigma> \\<and>\n                       ?y2 = foldl \\<delta> q\\<^sub>0 w'\n\ngoal (2 subgoals):\n 1. \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0\n 2. \\<not> \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0", "note extend_run = this"], ["proof (state)\nthis:\n  \\<lbrakk>set ?w2 \\<subseteq> set \\<Sigma>;\n   ?x2 = foldl \\<delta> q\\<^sub>0 ?w2;\n   ?y2 \\<in> set (map (\\<delta> ?x2) \\<Sigma>)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>w'.\n                       set w' \\<subseteq> set \\<Sigma> \\<and>\n                       ?y2 = foldl \\<delta> q\\<^sub>0 w'\n\ngoal (2 subgoals):\n 1. \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0\n 2. \\<not> \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0", "interpret DFS \"\\<lambda>q. map (\\<delta> q) \\<Sigma>\" \"\\<lambda>q. q \\<in> reach (set \\<Sigma>) \\<delta> q\\<^sub>0\" \"\\<lambda>S. S \\<subseteq> reach (set \\<Sigma>) \\<delta> q\\<^sub>0\" Set.insert \"(\\<in>)\" \"{}\" id"], ["proof (prove)\ngoal (1 subgoal):\n 1. DFS (\\<lambda>q. map (\\<delta> q) \\<Sigma>)\n     (\\<lambda>q. q \\<in> reach (set \\<Sigma>) \\<delta> q\\<^sub>0)\n     (\\<lambda>S. S \\<subseteq> reach (set \\<Sigma>) \\<delta> q\\<^sub>0)\n     insert (\\<in>) {} id", "apply (unfold_locales; auto simp add: member_rec reach_redef list_all_iff elim: extend_run)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q w.\n       \\<lbrakk>q \\<in> set \\<Sigma>;\n        set w \\<subseteq> set \\<Sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa.\n                            \\<delta> (foldl \\<delta> q\\<^sub>0 w) q =\n                            foldl \\<delta> q\\<^sub>0 wa \\<and>\n                            set wa \\<subseteq> set \\<Sigma>\n 2. finite {foldl \\<delta> q\\<^sub>0 w |w. set w \\<subseteq> set \\<Sigma>}", "apply (metis extend_run image_eqI set_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {foldl \\<delta> q\\<^sub>0 w |w. set w \\<subseteq> set \\<Sigma>}", "apply (metis assms[unfolded reach_redef])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0\n 2. \\<not> \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0", "have Nil1: \"set [] \\<subseteq> set \\<Sigma>\" and Nil2: \"q\\<^sub>0 = foldl \\<delta> q\\<^sub>0 []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set [] \\<subseteq> set \\<Sigma> &&&\n    q\\<^sub>0 = foldl \\<delta> q\\<^sub>0 []", "by simp+"], ["proof (state)\nthis:\n  set [] \\<subseteq> set \\<Sigma>\n  q\\<^sub>0 = foldl \\<delta> q\\<^sub>0 []\n\ngoal (2 subgoals):\n 1. \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0\n 2. \\<not> \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0", "have list_all_init: \"list_all (\\<lambda>q. q \\<in> reach (set \\<Sigma>) \\<delta> q\\<^sub>0) [q\\<^sub>0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>q. q \\<in> reach (set \\<Sigma>) \\<delta> q\\<^sub>0)\n     [q\\<^sub>0]", "unfolding list_all_iff list.set reach_redef"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>{q\\<^sub>0}.\n       q \\<in> {foldl \\<delta> q\\<^sub>0 w |w.\n                set w \\<subseteq> set \\<Sigma>}", "using Nil1 Nil2"], ["proof (prove)\nusing this:\n  set [] \\<subseteq> set \\<Sigma>\n  q\\<^sub>0 = foldl \\<delta> q\\<^sub>0 []\n\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>{q\\<^sub>0}.\n       q \\<in> {foldl \\<delta> q\\<^sub>0 w |w.\n                set w \\<subseteq> set \\<Sigma>}", "by blast"], ["proof (state)\nthis:\n  list_all (\\<lambda>q. q \\<in> reach (set \\<Sigma>) \\<delta> q\\<^sub>0)\n   [q\\<^sub>0]\n\ngoal (2 subgoals):\n 1. \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0\n 2. \\<not> \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0", "have \"reach (set \\<Sigma>) \\<delta> q\\<^sub>0 \\<subseteq> reachable {q\\<^sub>0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach (set \\<Sigma>) \\<delta> q\\<^sub>0\n    \\<subseteq> reachable {q\\<^sub>0}", "proof rule"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> reach (set \\<Sigma>) \\<delta> q\\<^sub>0 \\<Longrightarrow>\n       x \\<in> reachable {q\\<^sub>0}", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> reach (set \\<Sigma>) \\<delta> q\\<^sub>0 \\<Longrightarrow>\n       x \\<in> reachable {q\\<^sub>0}", "assume \"x \\<in> reach (set \\<Sigma>) \\<delta> q\\<^sub>0\""], ["proof (state)\nthis:\n  x \\<in> reach (set \\<Sigma>) \\<delta> q\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> reach (set \\<Sigma>) \\<delta> q\\<^sub>0 \\<Longrightarrow>\n       x \\<in> reachable {q\\<^sub>0}", "then"], ["proof (chain)\npicking this:\n  x \\<in> reach (set \\<Sigma>) \\<delta> q\\<^sub>0", "obtain w where x_def: \"x = foldl \\<delta> q\\<^sub>0 w\" and \"set w \\<subseteq> set \\<Sigma>\""], ["proof (prove)\nusing this:\n  x \\<in> reach (set \\<Sigma>) \\<delta> q\\<^sub>0\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>x = foldl \\<delta> q\\<^sub>0 w;\n         set w \\<subseteq> set \\<Sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding reach_redef"], ["proof (prove)\nusing this:\n  x \\<in> {foldl \\<delta> q\\<^sub>0 w |w. set w \\<subseteq> set \\<Sigma>}\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>x = foldl \\<delta> q\\<^sub>0 w;\n         set w \\<subseteq> set \\<Sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x = foldl \\<delta> q\\<^sub>0 w\n  set w \\<subseteq> set \\<Sigma>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> reach (set \\<Sigma>) \\<delta> q\\<^sub>0 \\<Longrightarrow>\n       x \\<in> reachable {q\\<^sub>0}", "hence \"foldl \\<delta> q\\<^sub>0 w \\<in> reachable {q\\<^sub>0}\""], ["proof (prove)\nusing this:\n  x = foldl \\<delta> q\\<^sub>0 w\n  set w \\<subseteq> set \\<Sigma>\n\ngoal (1 subgoal):\n 1. foldl \\<delta> q\\<^sub>0 w \\<in> reachable {q\\<^sub>0}", "proof (induction w arbitrary: x rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x = foldl \\<delta> q\\<^sub>0 [];\n        set [] \\<subseteq> set \\<Sigma>\\<rbrakk>\n       \\<Longrightarrow> foldl \\<delta> q\\<^sub>0 []\n                         \\<in> reachable {q\\<^sub>0}\n 2. \\<And>x xs xa.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x = foldl \\<delta> q\\<^sub>0 xs;\n                    set xs \\<subseteq> set \\<Sigma>\\<rbrakk>\n                   \\<Longrightarrow> foldl \\<delta> q\\<^sub>0 xs\n                                     \\<in> reachable {q\\<^sub>0};\n        xa = foldl \\<delta> q\\<^sub>0 (xs @ [x]);\n        set (xs @ [x]) \\<subseteq> set \\<Sigma>\\<rbrakk>\n       \\<Longrightarrow> foldl \\<delta> q\\<^sub>0 (xs @ [x])\n                         \\<in> reachable {q\\<^sub>0}", "case (snoc \\<nu> w)"], ["proof (state)\nthis:\n  \\<lbrakk>?x = foldl \\<delta> q\\<^sub>0 w;\n   set w \\<subseteq> set \\<Sigma>\\<rbrakk>\n  \\<Longrightarrow> foldl \\<delta> q\\<^sub>0 w \\<in> reachable {q\\<^sub>0}\n  x = foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])\n  set (w @ [\\<nu>]) \\<subseteq> set \\<Sigma>\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x = foldl \\<delta> q\\<^sub>0 [];\n        set [] \\<subseteq> set \\<Sigma>\\<rbrakk>\n       \\<Longrightarrow> foldl \\<delta> q\\<^sub>0 []\n                         \\<in> reachable {q\\<^sub>0}\n 2. \\<And>x xs xa.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x = foldl \\<delta> q\\<^sub>0 xs;\n                    set xs \\<subseteq> set \\<Sigma>\\<rbrakk>\n                   \\<Longrightarrow> foldl \\<delta> q\\<^sub>0 xs\n                                     \\<in> reachable {q\\<^sub>0};\n        xa = foldl \\<delta> q\\<^sub>0 (xs @ [x]);\n        set (xs @ [x]) \\<subseteq> set \\<Sigma>\\<rbrakk>\n       \\<Longrightarrow> foldl \\<delta> q\\<^sub>0 (xs @ [x])\n                         \\<in> reachable {q\\<^sub>0}", "hence \"foldl \\<delta> q\\<^sub>0 w \\<in> reachable {q\\<^sub>0}\" and \"\\<delta> (foldl \\<delta> q\\<^sub>0 w) \\<nu> \\<in> set (map (\\<delta> (foldl \\<delta> q\\<^sub>0 w)) \\<Sigma>)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x = foldl \\<delta> q\\<^sub>0 w;\n   set w \\<subseteq> set \\<Sigma>\\<rbrakk>\n  \\<Longrightarrow> foldl \\<delta> q\\<^sub>0 w \\<in> reachable {q\\<^sub>0}\n  x = foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])\n  set (w @ [\\<nu>]) \\<subseteq> set \\<Sigma>\n\ngoal (1 subgoal):\n 1. foldl \\<delta> q\\<^sub>0 w \\<in> reachable {q\\<^sub>0} &&&\n    \\<delta> (foldl \\<delta> q\\<^sub>0 w) \\<nu>\n    \\<in> set (map (\\<delta> (foldl \\<delta> q\\<^sub>0 w)) \\<Sigma>)", "by simp+"], ["proof (state)\nthis:\n  foldl \\<delta> q\\<^sub>0 w \\<in> reachable {q\\<^sub>0}\n  \\<delta> (foldl \\<delta> q\\<^sub>0 w) \\<nu>\n  \\<in> set (map (\\<delta> (foldl \\<delta> q\\<^sub>0 w)) \\<Sigma>)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x = foldl \\<delta> q\\<^sub>0 [];\n        set [] \\<subseteq> set \\<Sigma>\\<rbrakk>\n       \\<Longrightarrow> foldl \\<delta> q\\<^sub>0 []\n                         \\<in> reachable {q\\<^sub>0}\n 2. \\<And>x xs xa.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x = foldl \\<delta> q\\<^sub>0 xs;\n                    set xs \\<subseteq> set \\<Sigma>\\<rbrakk>\n                   \\<Longrightarrow> foldl \\<delta> q\\<^sub>0 xs\n                                     \\<in> reachable {q\\<^sub>0};\n        xa = foldl \\<delta> q\\<^sub>0 (xs @ [x]);\n        set (xs @ [x]) \\<subseteq> set \\<Sigma>\\<rbrakk>\n       \\<Longrightarrow> foldl \\<delta> q\\<^sub>0 (xs @ [x])\n                         \\<in> reachable {q\\<^sub>0}", "thus ?case"], ["proof (prove)\nusing this:\n  foldl \\<delta> q\\<^sub>0 w \\<in> reachable {q\\<^sub>0}\n  \\<delta> (foldl \\<delta> q\\<^sub>0 w) \\<nu>\n  \\<in> set (map (\\<delta> (foldl \\<delta> q\\<^sub>0 w)) \\<Sigma>)\n\ngoal (1 subgoal):\n 1. foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>]) \\<in> reachable {q\\<^sub>0}", "by (simp add: rtrancl.rtrancl_into_rtrancl reachable_def)"], ["proof (state)\nthis:\n  foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>]) \\<in> reachable {q\\<^sub>0}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x = foldl \\<delta> q\\<^sub>0 [];\n        set [] \\<subseteq> set \\<Sigma>\\<rbrakk>\n       \\<Longrightarrow> foldl \\<delta> q\\<^sub>0 []\n                         \\<in> reachable {q\\<^sub>0}", "qed (simp add: reachable_def)"], ["proof (state)\nthis:\n  foldl \\<delta> q\\<^sub>0 w \\<in> reachable {q\\<^sub>0}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> reach (set \\<Sigma>) \\<delta> q\\<^sub>0 \\<Longrightarrow>\n       x \\<in> reachable {q\\<^sub>0}", "thus \"x \\<in> reachable {q\\<^sub>0}\""], ["proof (prove)\nusing this:\n  foldl \\<delta> q\\<^sub>0 w \\<in> reachable {q\\<^sub>0}\n\ngoal (1 subgoal):\n 1. x \\<in> reachable {q\\<^sub>0}", "by (simp add: x_def)"], ["proof (state)\nthis:\n  x \\<in> reachable {q\\<^sub>0}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  reach (set \\<Sigma>) \\<delta> q\\<^sub>0 \\<subseteq> reachable {q\\<^sub>0}\n\ngoal (2 subgoals):\n 1. \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0\n 2. \\<not> \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0", "moreover"], ["proof (state)\nthis:\n  reach (set \\<Sigma>) \\<delta> q\\<^sub>0 \\<subseteq> reachable {q\\<^sub>0}\n\ngoal (2 subgoals):\n 1. \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0\n 2. \\<not> \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0", "have \"reachable {q\\<^sub>0} \\<subseteq> reach (set \\<Sigma>) \\<delta> q\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable {q\\<^sub>0}\n    \\<subseteq> reach (set \\<Sigma>) \\<delta> q\\<^sub>0", "proof rule"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> reachable {q\\<^sub>0} \\<Longrightarrow>\n       x \\<in> reach (set \\<Sigma>) \\<delta> q\\<^sub>0", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> reachable {q\\<^sub>0} \\<Longrightarrow>\n       x \\<in> reach (set \\<Sigma>) \\<delta> q\\<^sub>0", "assume \"x \\<in> reachable {q\\<^sub>0}\""], ["proof (state)\nthis:\n  x \\<in> reachable {q\\<^sub>0}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> reachable {q\\<^sub>0} \\<Longrightarrow>\n       x \\<in> reach (set \\<Sigma>) \\<delta> q\\<^sub>0", "hence \"(q\\<^sub>0, x) \\<in> {(x, y). y \\<in> set (map (\\<delta> x) \\<Sigma>)}\\<^sup>*\""], ["proof (prove)\nusing this:\n  x \\<in> reachable {q\\<^sub>0}\n\ngoal (1 subgoal):\n 1. (q\\<^sub>0, x)\n    \\<in> {(x, y). y \\<in> set (map (\\<delta> x) \\<Sigma>)}\\<^sup>*", "unfolding reachable_def"], ["proof (prove)\nusing this:\n  x \\<in> {(x, y). y \\<in> set (map (\\<delta> x) \\<Sigma>)}\\<^sup>* ``\n          {q\\<^sub>0}\n\ngoal (1 subgoal):\n 1. (q\\<^sub>0, x)\n    \\<in> {(x, y). y \\<in> set (map (\\<delta> x) \\<Sigma>)}\\<^sup>*", "by blast"], ["proof (state)\nthis:\n  (q\\<^sub>0, x)\n  \\<in> {(x, y). y \\<in> set (map (\\<delta> x) \\<Sigma>)}\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> reachable {q\\<^sub>0} \\<Longrightarrow>\n       x \\<in> reach (set \\<Sigma>) \\<delta> q\\<^sub>0", "thus \"x \\<in> reach (set \\<Sigma>) \\<delta> q\\<^sub>0\""], ["proof (prove)\nusing this:\n  (q\\<^sub>0, x)\n  \\<in> {(x, y). y \\<in> set (map (\\<delta> x) \\<Sigma>)}\\<^sup>*\n\ngoal (1 subgoal):\n 1. x \\<in> reach (set \\<Sigma>) \\<delta> q\\<^sub>0", "apply (induction)"], ["proof (prove)\ngoal (2 subgoals):\n 1. q\\<^sub>0 \\<in> reach (set \\<Sigma>) \\<delta> q\\<^sub>0\n 2. \\<And>y z.\n       \\<lbrakk>(q\\<^sub>0, y)\n                \\<in> {(x, y).\n                       y \\<in> set (map (\\<delta> x) \\<Sigma>)}\\<^sup>*;\n        (y, z) \\<in> {(x, y). y \\<in> set (map (\\<delta> x) \\<Sigma>)};\n        y \\<in> reach (set \\<Sigma>) \\<delta> q\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> z \\<in> reach (set \\<Sigma>) \\<delta> q\\<^sub>0", "apply (insert reach_redef Nil1 Nil2; blast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(q\\<^sub>0, y)\n                \\<in> {(x, y).\n                       y \\<in> set (map (\\<delta> x) \\<Sigma>)}\\<^sup>*;\n        (y, z) \\<in> {(x, y). y \\<in> set (map (\\<delta> x) \\<Sigma>)};\n        y \\<in> reach (set \\<Sigma>) \\<delta> q\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> z \\<in> reach (set \\<Sigma>) \\<delta> q\\<^sub>0", "apply (metis r_into_rtrancl succsr_def succsr_isNode)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  x \\<in> reach (set \\<Sigma>) \\<delta> q\\<^sub>0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  reachable {q\\<^sub>0} \\<subseteq> reach (set \\<Sigma>) \\<delta> q\\<^sub>0\n\ngoal (2 subgoals):\n 1. \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0\n 2. \\<not> \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0", "ultimately"], ["proof (chain)\npicking this:\n  reach (set \\<Sigma>) \\<delta> q\\<^sub>0 \\<subseteq> reachable {q\\<^sub>0}\n  reachable {q\\<^sub>0} \\<subseteq> reach (set \\<Sigma>) \\<delta> q\\<^sub>0", "have reachable_redef: \"reachable {q\\<^sub>0} = reach (set \\<Sigma>) \\<delta> q\\<^sub>0\""], ["proof (prove)\nusing this:\n  reach (set \\<Sigma>) \\<delta> q\\<^sub>0 \\<subseteq> reachable {q\\<^sub>0}\n  reachable {q\\<^sub>0} \\<subseteq> reach (set \\<Sigma>) \\<delta> q\\<^sub>0\n\ngoal (1 subgoal):\n 1. reachable {q\\<^sub>0} = reach (set \\<Sigma>) \\<delta> q\\<^sub>0", "by blast"], ["proof (state)\nthis:\n  reachable {q\\<^sub>0} = reach (set \\<Sigma>) \\<delta> q\\<^sub>0\n\ngoal (2 subgoals):\n 1. \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0\n 2. \\<not> \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0", "moreover"], ["proof (state)\nthis:\n  reachable {q\\<^sub>0} = reach (set \\<Sigma>) \\<delta> q\\<^sub>0\n\ngoal (2 subgoals):\n 1. \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0\n 2. \\<not> \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0", "have \"reachable {q\\<^sub>0} \\<subseteq> Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable {q\\<^sub>0} \\<subseteq> Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0", "using reachable_imp_dfs[OF _ list_all_init]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<in> reach (set \\<Sigma>) \\<delta> q\\<^sub>0;\n   ?y \\<in> reachable (set [q\\<^sub>0])\\<rbrakk>\n  \\<Longrightarrow> \\<exists>y'.\n                       id y' = id ?y \\<and> y' \\<in> dfs {} [q\\<^sub>0]\n\ngoal (1 subgoal):\n 1. reachable {q\\<^sub>0} \\<subseteq> Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0", "unfolding list.set reachable_redef"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<in> reach (set \\<Sigma>) \\<delta> q\\<^sub>0;\n   ?y \\<in> reach (set \\<Sigma>) \\<delta> q\\<^sub>0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>y'.\n                       id y' = id ?y \\<and> y' \\<in> dfs {} [q\\<^sub>0]\n\ngoal (1 subgoal):\n 1. reach (set \\<Sigma>) \\<delta> q\\<^sub>0\n    \\<subseteq> Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0", "unfolding  reach_redef Q\\<^sub>L_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<in> {foldl \\<delta> q\\<^sub>0 w |w.\n                     set w \\<subseteq> set \\<Sigma>};\n   ?y \\<in> {foldl \\<delta> q\\<^sub>0 w |w.\n             set w \\<subseteq> set \\<Sigma>}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>y'.\n                       id y' = id ?y \\<and> y' \\<in> dfs {} [q\\<^sub>0]\n\ngoal (1 subgoal):\n 1. {foldl \\<delta> q\\<^sub>0 w |w. set w \\<subseteq> set \\<Sigma>}\n    \\<subseteq> (if \\<Sigma> \\<noteq> [] then dfs {} [q\\<^sub>0] else {})", "using \\<open>\\<Sigma> \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<in> {foldl \\<delta> q\\<^sub>0 w |w.\n                     set w \\<subseteq> set \\<Sigma>};\n   ?y \\<in> {foldl \\<delta> q\\<^sub>0 w |w.\n             set w \\<subseteq> set \\<Sigma>}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>y'.\n                       id y' = id ?y \\<and> y' \\<in> dfs {} [q\\<^sub>0]\n  \\<Sigma> \\<noteq> []\n\ngoal (1 subgoal):\n 1. {foldl \\<delta> q\\<^sub>0 w |w. set w \\<subseteq> set \\<Sigma>}\n    \\<subseteq> (if \\<Sigma> \\<noteq> [] then dfs {} [q\\<^sub>0] else {})", "by auto"], ["proof (state)\nthis:\n  reachable {q\\<^sub>0} \\<subseteq> Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0\n\ngoal (2 subgoals):\n 1. \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0\n 2. \\<not> \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0", "moreover"], ["proof (state)\nthis:\n  reachable {q\\<^sub>0} \\<subseteq> Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0\n\ngoal (2 subgoals):\n 1. \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0\n 2. \\<not> \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0", "have \"Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 \\<subseteq> reach (set \\<Sigma>) \\<delta> q\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0\n    \\<subseteq> reach (set \\<Sigma>) \\<delta> q\\<^sub>0", "using dfs_invariant[of \"{}\", OF _ list_all_init]"], ["proof (prove)\nusing this:\n  {} \\<subseteq> reach (set \\<Sigma>) \\<delta> q\\<^sub>0 \\<Longrightarrow>\n  dfs {} [q\\<^sub>0] \\<subseteq> reach (set \\<Sigma>) \\<delta> q\\<^sub>0\n\ngoal (1 subgoal):\n 1. Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0\n    \\<subseteq> reach (set \\<Sigma>) \\<delta> q\\<^sub>0", "by (auto simp add: reach_redef Q\\<^sub>L_def)"], ["proof (state)\nthis:\n  Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0\n  \\<subseteq> reach (set \\<Sigma>) \\<delta> q\\<^sub>0\n\ngoal (2 subgoals):\n 1. \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0\n 2. \\<not> \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0", "ultimately"], ["proof (chain)\npicking this:\n  reachable {q\\<^sub>0} = reach (set \\<Sigma>) \\<delta> q\\<^sub>0\n  reachable {q\\<^sub>0} \\<subseteq> Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0\n  Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0\n  \\<subseteq> reach (set \\<Sigma>) \\<delta> q\\<^sub>0", "show ?thesis"], ["proof (prove)\nusing this:\n  reachable {q\\<^sub>0} = reach (set \\<Sigma>) \\<delta> q\\<^sub>0\n  reachable {q\\<^sub>0} \\<subseteq> Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0\n  Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0\n  \\<subseteq> reach (set \\<Sigma>) \\<delta> q\\<^sub>0\n\ngoal (1 subgoal):\n 1. Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0", "using \\<open>\\<Sigma> \\<noteq> []\\<close> dfs_invariant[of \"{}\", OF _ list_all_init]"], ["proof (prove)\nusing this:\n  reachable {q\\<^sub>0} = reach (set \\<Sigma>) \\<delta> q\\<^sub>0\n  reachable {q\\<^sub>0} \\<subseteq> Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0\n  Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0\n  \\<subseteq> reach (set \\<Sigma>) \\<delta> q\\<^sub>0\n  \\<Sigma> \\<noteq> []\n  {} \\<subseteq> reach (set \\<Sigma>) \\<delta> q\\<^sub>0 \\<Longrightarrow>\n  dfs {} [q\\<^sub>0] \\<subseteq> reach (set \\<Sigma>) \\<delta> q\\<^sub>0\n\ngoal (1 subgoal):\n 1. Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0", "by simp+"], ["proof (state)\nthis:\n  Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n  reach (set \\<Sigma>) \\<delta> q\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<not> \\<Sigma> \\<noteq> [] \\<Longrightarrow>\n    Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach (set \\<Sigma>) \\<delta> q\\<^sub>0", "qed (simp add: reach_def Q\\<^sub>L_def)"], ["", "lemma \\<delta>\\<^sub>L_reach: \n  assumes \"finite (reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0)\"\n  shows \"\\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 = reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "fix x w y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "assume \"set w \\<subseteq> set \\<Sigma>\" \"x = foldl \\<delta> q\\<^sub>0 w\" \"y \\<in> set (map (\\<delta> x) \\<Sigma>)\""], ["proof (state)\nthis:\n  set w \\<subseteq> set \\<Sigma>\n  x = foldl \\<delta> q\\<^sub>0 w\n  y \\<in> set (map (\\<delta> x) \\<Sigma>)\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "moreover"], ["proof (state)\nthis:\n  set w \\<subseteq> set \\<Sigma>\n  x = foldl \\<delta> q\\<^sub>0 w\n  y \\<in> set (map (\\<delta> x) \\<Sigma>)\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "then"], ["proof (chain)\npicking this:\n  set w \\<subseteq> set \\<Sigma>\n  x = foldl \\<delta> q\\<^sub>0 w\n  y \\<in> set (map (\\<delta> x) \\<Sigma>)", "obtain \\<nu> where \"y = \\<delta> x \\<nu>\" and \"\\<nu> \\<in> set \\<Sigma>\""], ["proof (prove)\nusing this:\n  set w \\<subseteq> set \\<Sigma>\n  x = foldl \\<delta> q\\<^sub>0 w\n  y \\<in> set (map (\\<delta> x) \\<Sigma>)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<nu>.\n        \\<lbrakk>y = \\<delta> x \\<nu>; \\<nu> \\<in> set \\<Sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y = \\<delta> x \\<nu>\n  \\<nu> \\<in> set \\<Sigma>\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "ultimately"], ["proof (chain)\npicking this:\n  set w \\<subseteq> set \\<Sigma>\n  x = foldl \\<delta> q\\<^sub>0 w\n  y \\<in> set (map (\\<delta> x) \\<Sigma>)\n  y = \\<delta> x \\<nu>\n  \\<nu> \\<in> set \\<Sigma>", "have \"y = foldl \\<delta> q\\<^sub>0 (w@[\\<nu>])\" and \"set (w@[\\<nu>]) \\<subseteq> set \\<Sigma>\""], ["proof (prove)\nusing this:\n  set w \\<subseteq> set \\<Sigma>\n  x = foldl \\<delta> q\\<^sub>0 w\n  y \\<in> set (map (\\<delta> x) \\<Sigma>)\n  y = \\<delta> x \\<nu>\n  \\<nu> \\<in> set \\<Sigma>\n\ngoal (1 subgoal):\n 1. y = foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>]) &&&\n    set (w @ [\\<nu>]) \\<subseteq> set \\<Sigma>", "by simp+"], ["proof (state)\nthis:\n  y = foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])\n  set (w @ [\\<nu>]) \\<subseteq> set \\<Sigma>\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "hence \"\\<exists>w'. set w' \\<subseteq> set \\<Sigma> \\<and> y = foldl  \\<delta> q\\<^sub>0 w'\""], ["proof (prove)\nusing this:\n  y = foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])\n  set (w @ [\\<nu>]) \\<subseteq> set \\<Sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>w'.\n       set w' \\<subseteq> set \\<Sigma> \\<and>\n       y = foldl \\<delta> q\\<^sub>0 w'", "by blast"], ["proof (state)\nthis:\n  \\<exists>w'.\n     set w' \\<subseteq> set \\<Sigma> \\<and> y = foldl \\<delta> q\\<^sub>0 w'\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "}"], ["proof (state)\nthis:\n  \\<lbrakk>set ?w2 \\<subseteq> set \\<Sigma>;\n   ?x2 = foldl \\<delta> q\\<^sub>0 ?w2;\n   ?y2 \\<in> set (map (\\<delta> ?x2) \\<Sigma>)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>w'.\n                       set w' \\<subseteq> set \\<Sigma> \\<and>\n                       ?y2 = foldl \\<delta> q\\<^sub>0 w'\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "note extend_run = this"], ["proof (state)\nthis:\n  \\<lbrakk>set ?w2 \\<subseteq> set \\<Sigma>;\n   ?x2 = foldl \\<delta> q\\<^sub>0 ?w2;\n   ?y2 \\<in> set (map (\\<delta> ?x2) \\<Sigma>)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>w'.\n                       set w' \\<subseteq> set \\<Sigma> \\<and>\n                       ?y2 = foldl \\<delta> q\\<^sub>0 w'\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "let ?succs = \"\\<lambda>(_, _, q). (map (\\<lambda>\\<nu>. (q, \\<nu>, \\<delta> q \\<nu>)) \\<Sigma>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "interpret DFS \"\\<lambda>(_, _, q). (map (\\<lambda>\\<nu>. (q, \\<nu>, \\<delta> q \\<nu>)) \\<Sigma>)\" \"\\<lambda>t. t \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0\" \"\\<lambda>S. set S \\<subseteq> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0\" List.insert \"\\<lambda>x xs. x \\<in> set xs\" \"[]\" id"], ["proof (prove)\ngoal (1 subgoal):\n 1. DFS (\\<lambda>(uu_, uu_, q).\n            map (\\<lambda>\\<nu>. (q, \\<nu>, \\<delta> q \\<nu>)) \\<Sigma>)\n     (\\<lambda>t. t \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0)\n     (\\<lambda>S.\n         set S \\<subseteq> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0)\n     List.insert (\\<lambda>x xs. x \\<in> set xs) [] id", "apply (unfold_locales; auto simp add: member_rec reach\\<^sub>t_foldl_def list_all_iff elim: extend_run)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w \\<nu> \\<nu>'.\n       \\<lbrakk>set w \\<subseteq> set \\<Sigma>; \\<nu> \\<in> set \\<Sigma>;\n        \\<nu>' \\<in> set \\<Sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>wa.\n                            \\<delta> (foldl \\<delta> q\\<^sub>0 w) \\<nu> =\n                            foldl \\<delta> q\\<^sub>0 wa \\<and>\n                            \\<delta>\n                             (\\<delta> (foldl \\<delta> q\\<^sub>0 w) \\<nu>)\n                             \\<nu>' =\n                            \\<delta> (foldl \\<delta> q\\<^sub>0 wa)\n                             \\<nu>' \\<and>\n                            set wa \\<subseteq> set \\<Sigma>\n 2. finite\n     {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n       \\<delta> (foldl \\<delta> q\\<^sub>0 w) \\<nu>) |\n      w \\<nu>.\n      set w \\<subseteq> set \\<Sigma> \\<and> \\<nu> \\<in> set \\<Sigma>}", "apply (metis extend_run image_eqI set_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n       \\<delta> (foldl \\<delta> q\\<^sub>0 w) \\<nu>) |\n      w \\<nu>.\n      set w \\<subseteq> set \\<Sigma> \\<and> \\<nu> \\<in> set \\<Sigma>}", "using  assms"], ["proof (prove)\nusing this:\n  finite (reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0)\n\ngoal (1 subgoal):\n 1. finite\n     {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n       \\<delta> (foldl \\<delta> q\\<^sub>0 w) \\<nu>) |\n      w \\<nu>.\n      set w \\<subseteq> set \\<Sigma> \\<and> \\<nu> \\<in> set \\<Sigma>}", "unfolding reach\\<^sub>t_foldl_def"], ["proof (prove)\nusing this:\n  finite\n   {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n     foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) |\n    w \\<nu>. set w \\<subseteq> set \\<Sigma> \\<and> \\<nu> \\<in> set \\<Sigma>}\n\ngoal (1 subgoal):\n 1. finite\n     {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n       \\<delta> (foldl \\<delta> q\\<^sub>0 w) \\<nu>) |\n      w \\<nu>.\n      set w \\<subseteq> set \\<Sigma> \\<and> \\<nu> \\<in> set \\<Sigma>}", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "have Nil1: \"set [] \\<subseteq> set \\<Sigma>\" and Nil2: \"q\\<^sub>0 = foldl \\<delta> q\\<^sub>0 []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set [] \\<subseteq> set \\<Sigma> &&&\n    q\\<^sub>0 = foldl \\<delta> q\\<^sub>0 []", "by simp+"], ["proof (state)\nthis:\n  set [] \\<subseteq> set \\<Sigma>\n  q\\<^sub>0 = foldl \\<delta> q\\<^sub>0 []\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "have list_all_init: \"list_all (\\<lambda>q. q \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0) (map (\\<lambda>\\<nu>. (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>)) \\<Sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>q. q \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0)\n     (map (\\<lambda>\\<nu>. (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n       \\<Sigma>)", "unfolding list_all_iff reach\\<^sub>t_foldl_def set_map image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>{y. \\<exists>x\\<in>set \\<Sigma>.\n                          y = (q\\<^sub>0, x, \\<delta> q\\<^sub>0 x)}.\n       q \\<in> {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n                 foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) |\n                w \\<nu>.\n                set w \\<subseteq> set \\<Sigma> \\<and>\n                \\<nu> \\<in> set \\<Sigma>}", "using Nil2"], ["proof (prove)\nusing this:\n  q\\<^sub>0 = foldl \\<delta> q\\<^sub>0 []\n\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>{y. \\<exists>x\\<in>set \\<Sigma>.\n                          y = (q\\<^sub>0, x, \\<delta> q\\<^sub>0 x)}.\n       q \\<in> {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n                 foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) |\n                w \\<nu>.\n                set w \\<subseteq> set \\<Sigma> \\<and>\n                \\<nu> \\<in> set \\<Sigma>}", "by fastforce"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>q. q \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0)\n   (map (\\<lambda>\\<nu>. (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n     \\<Sigma>)\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "let ?q\\<^sub>0 = \"set (map (\\<lambda>\\<nu>. (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>)) \\<Sigma>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "fix q \\<nu> q'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "assume \"(q, \\<nu>, q') \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0\""], ["proof (state)\nthis:\n  (q, \\<nu>, q') \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "then"], ["proof (chain)\npicking this:\n  (q, \\<nu>, q') \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "obtain w where q_def: \"q = foldl \\<delta> q\\<^sub>0 w\" and q'_def: \"q' = foldl \\<delta> q\\<^sub>0 (w@[\\<nu>])\" \n      and \"set w \\<subseteq> set \\<Sigma>\" and \"\\<nu> \\<in> set \\<Sigma>\""], ["proof (prove)\nusing this:\n  (q, \\<nu>, q') \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>q = foldl \\<delta> q\\<^sub>0 w;\n         q' = foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>]);\n         set w \\<subseteq> set \\<Sigma>; \\<nu> \\<in> set \\<Sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding reach\\<^sub>t_foldl_def"], ["proof (prove)\nusing this:\n  (q, \\<nu>, q')\n  \\<in> {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n          foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) |\n         w \\<nu>.\n         set w \\<subseteq> set \\<Sigma> \\<and> \\<nu> \\<in> set \\<Sigma>}\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>q = foldl \\<delta> q\\<^sub>0 w;\n         q' = foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>]);\n         set w \\<subseteq> set \\<Sigma>; \\<nu> \\<in> set \\<Sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  q = foldl \\<delta> q\\<^sub>0 w\n  q' = foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])\n  set w \\<subseteq> set \\<Sigma>\n  \\<nu> \\<in> set \\<Sigma>\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "hence \"(foldl \\<delta> q\\<^sub>0 w, \\<nu>, foldl \\<delta> q\\<^sub>0 (w@[\\<nu>])) \\<in> reachable ?q\\<^sub>0\""], ["proof (prove)\nusing this:\n  q = foldl \\<delta> q\\<^sub>0 w\n  q' = foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])\n  set w \\<subseteq> set \\<Sigma>\n  \\<nu> \\<in> set \\<Sigma>\n\ngoal (1 subgoal):\n 1. (foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n     foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>]))\n    \\<in> reachable\n           (set (map (\\<lambda>\\<nu>.\n                         (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                  \\<Sigma>))", "proof (induction w arbitrary: q q' \\<nu> rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q q' \\<nu>.\n       \\<lbrakk>q = foldl \\<delta> q\\<^sub>0 [];\n        q' = foldl \\<delta> q\\<^sub>0 ([] @ [\\<nu>]);\n        set [] \\<subseteq> set \\<Sigma>; \\<nu> \\<in> set \\<Sigma>\\<rbrakk>\n       \\<Longrightarrow> (foldl \\<delta> q\\<^sub>0 [], \\<nu>,\n                          foldl \\<delta> q\\<^sub>0 ([] @ [\\<nu>]))\n                         \\<in> reachable\n                                (set (map\n (\\<lambda>\\<nu>. (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>)) \\<Sigma>))\n 2. \\<And>x xs q q' \\<nu>.\n       \\<lbrakk>\\<And>q q' \\<nu>.\n                   \\<lbrakk>q = foldl \\<delta> q\\<^sub>0 xs;\n                    q' = foldl \\<delta> q\\<^sub>0 (xs @ [\\<nu>]);\n                    set xs \\<subseteq> set \\<Sigma>;\n                    \\<nu> \\<in> set \\<Sigma>\\<rbrakk>\n                   \\<Longrightarrow> (foldl \\<delta> q\\<^sub>0 xs, \\<nu>,\nfoldl \\<delta> q\\<^sub>0 (xs @ [\\<nu>]))\n                                     \\<in> reachable\n      (set (map (\\<lambda>\\<nu>.\n                    (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n             \\<Sigma>));\n        q = foldl \\<delta> q\\<^sub>0 (xs @ [x]);\n        q' = foldl \\<delta> q\\<^sub>0 ((xs @ [x]) @ [\\<nu>]);\n        set (xs @ [x]) \\<subseteq> set \\<Sigma>;\n        \\<nu> \\<in> set \\<Sigma>\\<rbrakk>\n       \\<Longrightarrow> (foldl \\<delta> q\\<^sub>0 (xs @ [x]), \\<nu>,\n                          foldl \\<delta> q\\<^sub>0 ((xs @ [x]) @ [\\<nu>]))\n                         \\<in> reachable\n                                (set (map\n (\\<lambda>\\<nu>. (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>)) \\<Sigma>))", "case (snoc \\<nu>' w)"], ["proof (state)\nthis:\n  \\<lbrakk>?q1 = foldl \\<delta> q\\<^sub>0 w;\n   ?q'1 = foldl \\<delta> q\\<^sub>0 (w @ [?\\<nu>1]);\n   set w \\<subseteq> set \\<Sigma>; ?\\<nu>1 \\<in> set \\<Sigma>\\<rbrakk>\n  \\<Longrightarrow> (foldl \\<delta> q\\<^sub>0 w, ?\\<nu>1,\n                     foldl \\<delta> q\\<^sub>0 (w @ [?\\<nu>1]))\n                    \\<in> reachable\n                           (set (map (\\<lambda>\\<nu>.\n   (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                                  \\<Sigma>))\n  q = foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>'])\n  q' = foldl \\<delta> q\\<^sub>0 ((w @ [\\<nu>']) @ [\\<nu>])\n  set (w @ [\\<nu>']) \\<subseteq> set \\<Sigma>\n  \\<nu> \\<in> set \\<Sigma>\n\ngoal (2 subgoals):\n 1. \\<And>q q' \\<nu>.\n       \\<lbrakk>q = foldl \\<delta> q\\<^sub>0 [];\n        q' = foldl \\<delta> q\\<^sub>0 ([] @ [\\<nu>]);\n        set [] \\<subseteq> set \\<Sigma>; \\<nu> \\<in> set \\<Sigma>\\<rbrakk>\n       \\<Longrightarrow> (foldl \\<delta> q\\<^sub>0 [], \\<nu>,\n                          foldl \\<delta> q\\<^sub>0 ([] @ [\\<nu>]))\n                         \\<in> reachable\n                                (set (map\n (\\<lambda>\\<nu>. (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>)) \\<Sigma>))\n 2. \\<And>x xs q q' \\<nu>.\n       \\<lbrakk>\\<And>q q' \\<nu>.\n                   \\<lbrakk>q = foldl \\<delta> q\\<^sub>0 xs;\n                    q' = foldl \\<delta> q\\<^sub>0 (xs @ [\\<nu>]);\n                    set xs \\<subseteq> set \\<Sigma>;\n                    \\<nu> \\<in> set \\<Sigma>\\<rbrakk>\n                   \\<Longrightarrow> (foldl \\<delta> q\\<^sub>0 xs, \\<nu>,\nfoldl \\<delta> q\\<^sub>0 (xs @ [\\<nu>]))\n                                     \\<in> reachable\n      (set (map (\\<lambda>\\<nu>.\n                    (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n             \\<Sigma>));\n        q = foldl \\<delta> q\\<^sub>0 (xs @ [x]);\n        q' = foldl \\<delta> q\\<^sub>0 ((xs @ [x]) @ [\\<nu>]);\n        set (xs @ [x]) \\<subseteq> set \\<Sigma>;\n        \\<nu> \\<in> set \\<Sigma>\\<rbrakk>\n       \\<Longrightarrow> (foldl \\<delta> q\\<^sub>0 (xs @ [x]), \\<nu>,\n                          foldl \\<delta> q\\<^sub>0 ((xs @ [x]) @ [\\<nu>]))\n                         \\<in> reachable\n                                (set (map\n (\\<lambda>\\<nu>. (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>)) \\<Sigma>))", "hence \"(foldl \\<delta> q\\<^sub>0 w, \\<nu>', foldl \\<delta> q\\<^sub>0 (w@[\\<nu>'])) \\<in> reachable ?q\\<^sub>0\" (is \"(?q, \\<nu>', ?q') \\<in> _\")\n          and \"\\<And>q. \\<delta> q \\<nu> \\<in> set (map (\\<delta> q) \\<Sigma>)\"\n          and \"\\<nu> \\<in> set \\<Sigma>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?q1 = foldl \\<delta> q\\<^sub>0 w;\n   ?q'1 = foldl \\<delta> q\\<^sub>0 (w @ [?\\<nu>1]);\n   set w \\<subseteq> set \\<Sigma>; ?\\<nu>1 \\<in> set \\<Sigma>\\<rbrakk>\n  \\<Longrightarrow> (foldl \\<delta> q\\<^sub>0 w, ?\\<nu>1,\n                     foldl \\<delta> q\\<^sub>0 (w @ [?\\<nu>1]))\n                    \\<in> reachable\n                           (set (map (\\<lambda>\\<nu>.\n   (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                                  \\<Sigma>))\n  q = foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>'])\n  q' = foldl \\<delta> q\\<^sub>0 ((w @ [\\<nu>']) @ [\\<nu>])\n  set (w @ [\\<nu>']) \\<subseteq> set \\<Sigma>\n  \\<nu> \\<in> set \\<Sigma>\n\ngoal (1 subgoal):\n 1. (foldl \\<delta> q\\<^sub>0 w, \\<nu>',\n     foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>']))\n    \\<in> reachable\n           (set (map (\\<lambda>\\<nu>.\n                         (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                  \\<Sigma>)) &&&\n    (\\<And>q. \\<delta> q \\<nu> \\<in> set (map (\\<delta> q) \\<Sigma>)) &&&\n    \\<nu> \\<in> set \\<Sigma>", "by simp+"], ["proof (state)\nthis:\n  (foldl \\<delta> q\\<^sub>0 w, \\<nu>',\n   foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>']))\n  \\<in> reachable\n         (set (map (\\<lambda>\\<nu>.\n                       (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                \\<Sigma>))\n  \\<delta> ?q1 \\<nu> \\<in> set (map (\\<delta> ?q1) \\<Sigma>)\n  \\<nu> \\<in> set \\<Sigma>\n\ngoal (2 subgoals):\n 1. \\<And>q q' \\<nu>.\n       \\<lbrakk>q = foldl \\<delta> q\\<^sub>0 [];\n        q' = foldl \\<delta> q\\<^sub>0 ([] @ [\\<nu>]);\n        set [] \\<subseteq> set \\<Sigma>; \\<nu> \\<in> set \\<Sigma>\\<rbrakk>\n       \\<Longrightarrow> (foldl \\<delta> q\\<^sub>0 [], \\<nu>,\n                          foldl \\<delta> q\\<^sub>0 ([] @ [\\<nu>]))\n                         \\<in> reachable\n                                (set (map\n (\\<lambda>\\<nu>. (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>)) \\<Sigma>))\n 2. \\<And>x xs q q' \\<nu>.\n       \\<lbrakk>\\<And>q q' \\<nu>.\n                   \\<lbrakk>q = foldl \\<delta> q\\<^sub>0 xs;\n                    q' = foldl \\<delta> q\\<^sub>0 (xs @ [\\<nu>]);\n                    set xs \\<subseteq> set \\<Sigma>;\n                    \\<nu> \\<in> set \\<Sigma>\\<rbrakk>\n                   \\<Longrightarrow> (foldl \\<delta> q\\<^sub>0 xs, \\<nu>,\nfoldl \\<delta> q\\<^sub>0 (xs @ [\\<nu>]))\n                                     \\<in> reachable\n      (set (map (\\<lambda>\\<nu>.\n                    (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n             \\<Sigma>));\n        q = foldl \\<delta> q\\<^sub>0 (xs @ [x]);\n        q' = foldl \\<delta> q\\<^sub>0 ((xs @ [x]) @ [\\<nu>]);\n        set (xs @ [x]) \\<subseteq> set \\<Sigma>;\n        \\<nu> \\<in> set \\<Sigma>\\<rbrakk>\n       \\<Longrightarrow> (foldl \\<delta> q\\<^sub>0 (xs @ [x]), \\<nu>,\n                          foldl \\<delta> q\\<^sub>0 ((xs @ [x]) @ [\\<nu>]))\n                         \\<in> reachable\n                                (set (map\n (\\<lambda>\\<nu>. (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>)) \\<Sigma>))", "then"], ["proof (chain)\npicking this:\n  (foldl \\<delta> q\\<^sub>0 w, \\<nu>',\n   foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>']))\n  \\<in> reachable\n         (set (map (\\<lambda>\\<nu>.\n                       (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                \\<Sigma>))\n  \\<delta> ?q1 \\<nu> \\<in> set (map (\\<delta> ?q1) \\<Sigma>)\n  \\<nu> \\<in> set \\<Sigma>", "obtain x\\<^sub>0 where 1: \"(x\\<^sub>0, (?q, \\<nu>', ?q')) \\<in> {(x, y). y \\<in> set (?succs x)}\\<^sup>*\" and 2: \"x\\<^sub>0 \\<in> ?q\\<^sub>0\""], ["proof (prove)\nusing this:\n  (foldl \\<delta> q\\<^sub>0 w, \\<nu>',\n   foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>']))\n  \\<in> reachable\n         (set (map (\\<lambda>\\<nu>.\n                       (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                \\<Sigma>))\n  \\<delta> ?q1 \\<nu> \\<in> set (map (\\<delta> ?q1) \\<Sigma>)\n  \\<nu> \\<in> set \\<Sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>x\\<^sub>0.\n        \\<lbrakk>(x\\<^sub>0, foldl \\<delta> q\\<^sub>0 w, \\<nu>',\n                  foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>']))\n                 \\<in> {(x, y).\n                        y \\<in> set (case x of\n                                     (uu_, uua_, q) \\<Rightarrow>\n map (\\<lambda>\\<nu>. (q, \\<nu>, \\<delta> q \\<nu>)) \\<Sigma>)}\\<^sup>*;\n         x\\<^sub>0\n         \\<in> set (map (\\<lambda>\\<nu>.\n                            (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                     \\<Sigma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding reachable_def"], ["proof (prove)\nusing this:\n  (foldl \\<delta> q\\<^sub>0 w, \\<nu>',\n   foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>']))\n  \\<in> {(x, y).\n         y \\<in> set (case x of\n                      (uu_, uua_, q) \\<Rightarrow>\n                        map (\\<lambda>\\<nu>. (q, \\<nu>, \\<delta> q \\<nu>))\n                         \\<Sigma>)}\\<^sup>* ``\n        set (map (\\<lambda>\\<nu>.\n                     (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n              \\<Sigma>)\n  \\<delta> ?q1 \\<nu> \\<in> set (map (\\<delta> ?q1) \\<Sigma>)\n  \\<nu> \\<in> set \\<Sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>x\\<^sub>0.\n        \\<lbrakk>(x\\<^sub>0, foldl \\<delta> q\\<^sub>0 w, \\<nu>',\n                  foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>']))\n                 \\<in> {(x, y).\n                        y \\<in> set (case x of\n                                     (uu_, uua_, q) \\<Rightarrow>\n map (\\<lambda>\\<nu>. (q, \\<nu>, \\<delta> q \\<nu>)) \\<Sigma>)}\\<^sup>*;\n         x\\<^sub>0\n         \\<in> set (map (\\<lambda>\\<nu>.\n                            (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                     \\<Sigma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (x\\<^sub>0, foldl \\<delta> q\\<^sub>0 w, \\<nu>',\n   foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>']))\n  \\<in> {(x, y).\n         y \\<in> set (case x of\n                      (uu_, uua_, q) \\<Rightarrow>\n                        map (\\<lambda>\\<nu>. (q, \\<nu>, \\<delta> q \\<nu>))\n                         \\<Sigma>)}\\<^sup>*\n  x\\<^sub>0\n  \\<in> set (map (\\<lambda>\\<nu>.\n                     (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n              \\<Sigma>)\n\ngoal (2 subgoals):\n 1. \\<And>q q' \\<nu>.\n       \\<lbrakk>q = foldl \\<delta> q\\<^sub>0 [];\n        q' = foldl \\<delta> q\\<^sub>0 ([] @ [\\<nu>]);\n        set [] \\<subseteq> set \\<Sigma>; \\<nu> \\<in> set \\<Sigma>\\<rbrakk>\n       \\<Longrightarrow> (foldl \\<delta> q\\<^sub>0 [], \\<nu>,\n                          foldl \\<delta> q\\<^sub>0 ([] @ [\\<nu>]))\n                         \\<in> reachable\n                                (set (map\n (\\<lambda>\\<nu>. (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>)) \\<Sigma>))\n 2. \\<And>x xs q q' \\<nu>.\n       \\<lbrakk>\\<And>q q' \\<nu>.\n                   \\<lbrakk>q = foldl \\<delta> q\\<^sub>0 xs;\n                    q' = foldl \\<delta> q\\<^sub>0 (xs @ [\\<nu>]);\n                    set xs \\<subseteq> set \\<Sigma>;\n                    \\<nu> \\<in> set \\<Sigma>\\<rbrakk>\n                   \\<Longrightarrow> (foldl \\<delta> q\\<^sub>0 xs, \\<nu>,\nfoldl \\<delta> q\\<^sub>0 (xs @ [\\<nu>]))\n                                     \\<in> reachable\n      (set (map (\\<lambda>\\<nu>.\n                    (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n             \\<Sigma>));\n        q = foldl \\<delta> q\\<^sub>0 (xs @ [x]);\n        q' = foldl \\<delta> q\\<^sub>0 ((xs @ [x]) @ [\\<nu>]);\n        set (xs @ [x]) \\<subseteq> set \\<Sigma>;\n        \\<nu> \\<in> set \\<Sigma>\\<rbrakk>\n       \\<Longrightarrow> (foldl \\<delta> q\\<^sub>0 (xs @ [x]), \\<nu>,\n                          foldl \\<delta> q\\<^sub>0 ((xs @ [x]) @ [\\<nu>]))\n                         \\<in> reachable\n                                (set (map\n (\\<lambda>\\<nu>. (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>)) \\<Sigma>))", "moreover"], ["proof (state)\nthis:\n  (x\\<^sub>0, foldl \\<delta> q\\<^sub>0 w, \\<nu>',\n   foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>']))\n  \\<in> {(x, y).\n         y \\<in> set (case x of\n                      (uu_, uua_, q) \\<Rightarrow>\n                        map (\\<lambda>\\<nu>. (q, \\<nu>, \\<delta> q \\<nu>))\n                         \\<Sigma>)}\\<^sup>*\n  x\\<^sub>0\n  \\<in> set (map (\\<lambda>\\<nu>.\n                     (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n              \\<Sigma>)\n\ngoal (2 subgoals):\n 1. \\<And>q q' \\<nu>.\n       \\<lbrakk>q = foldl \\<delta> q\\<^sub>0 [];\n        q' = foldl \\<delta> q\\<^sub>0 ([] @ [\\<nu>]);\n        set [] \\<subseteq> set \\<Sigma>; \\<nu> \\<in> set \\<Sigma>\\<rbrakk>\n       \\<Longrightarrow> (foldl \\<delta> q\\<^sub>0 [], \\<nu>,\n                          foldl \\<delta> q\\<^sub>0 ([] @ [\\<nu>]))\n                         \\<in> reachable\n                                (set (map\n (\\<lambda>\\<nu>. (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>)) \\<Sigma>))\n 2. \\<And>x xs q q' \\<nu>.\n       \\<lbrakk>\\<And>q q' \\<nu>.\n                   \\<lbrakk>q = foldl \\<delta> q\\<^sub>0 xs;\n                    q' = foldl \\<delta> q\\<^sub>0 (xs @ [\\<nu>]);\n                    set xs \\<subseteq> set \\<Sigma>;\n                    \\<nu> \\<in> set \\<Sigma>\\<rbrakk>\n                   \\<Longrightarrow> (foldl \\<delta> q\\<^sub>0 xs, \\<nu>,\nfoldl \\<delta> q\\<^sub>0 (xs @ [\\<nu>]))\n                                     \\<in> reachable\n      (set (map (\\<lambda>\\<nu>.\n                    (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n             \\<Sigma>));\n        q = foldl \\<delta> q\\<^sub>0 (xs @ [x]);\n        q' = foldl \\<delta> q\\<^sub>0 ((xs @ [x]) @ [\\<nu>]);\n        set (xs @ [x]) \\<subseteq> set \\<Sigma>;\n        \\<nu> \\<in> set \\<Sigma>\\<rbrakk>\n       \\<Longrightarrow> (foldl \\<delta> q\\<^sub>0 (xs @ [x]), \\<nu>,\n                          foldl \\<delta> q\\<^sub>0 ((xs @ [x]) @ [\\<nu>]))\n                         \\<in> reachable\n                                (set (map\n (\\<lambda>\\<nu>. (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>)) \\<Sigma>))", "have 3: \"((?q, \\<nu>', ?q'), (?q', \\<nu>, \\<delta> ?q' \\<nu>)) \\<in> {(x, y). y \\<in> set (?succs x)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((foldl \\<delta> q\\<^sub>0 w, \\<nu>',\n      foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>'])),\n     foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>']), \\<nu>,\n     \\<delta> (foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>'])) \\<nu>)\n    \\<in> {(x, y).\n           y \\<in> set (case x of\n                        (uu_, uua_, q) \\<Rightarrow>\n                          map (\\<lambda>\\<nu>. (q, \\<nu>, \\<delta> q \\<nu>))\n                           \\<Sigma>)}", "using snoc \\<open>\\<And>q. \\<delta> q \\<nu> \\<in> set (map (\\<delta> q) \\<Sigma>)\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?q1 = foldl \\<delta> q\\<^sub>0 w;\n   ?q'1 = foldl \\<delta> q\\<^sub>0 (w @ [?\\<nu>1]);\n   set w \\<subseteq> set \\<Sigma>; ?\\<nu>1 \\<in> set \\<Sigma>\\<rbrakk>\n  \\<Longrightarrow> (foldl \\<delta> q\\<^sub>0 w, ?\\<nu>1,\n                     foldl \\<delta> q\\<^sub>0 (w @ [?\\<nu>1]))\n                    \\<in> reachable\n                           (set (map (\\<lambda>\\<nu>.\n   (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                                  \\<Sigma>))\n  q = foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>'])\n  q' = foldl \\<delta> q\\<^sub>0 ((w @ [\\<nu>']) @ [\\<nu>])\n  set (w @ [\\<nu>']) \\<subseteq> set \\<Sigma>\n  \\<nu> \\<in> set \\<Sigma>\n  \\<delta> ?q \\<nu> \\<in> set (map (\\<delta> ?q) \\<Sigma>)\n\ngoal (1 subgoal):\n 1. ((foldl \\<delta> q\\<^sub>0 w, \\<nu>',\n      foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>'])),\n     foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>']), \\<nu>,\n     \\<delta> (foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>'])) \\<nu>)\n    \\<in> {(x, y).\n           y \\<in> set (case x of\n                        (uu_, uua_, q) \\<Rightarrow>\n                          map (\\<lambda>\\<nu>. (q, \\<nu>, \\<delta> q \\<nu>))\n                           \\<Sigma>)}", "by simp"], ["proof (state)\nthis:\n  ((foldl \\<delta> q\\<^sub>0 w, \\<nu>',\n    foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>'])),\n   foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>']), \\<nu>,\n   \\<delta> (foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>'])) \\<nu>)\n  \\<in> {(x, y).\n         y \\<in> set (case x of\n                      (uu_, uua_, q) \\<Rightarrow>\n                        map (\\<lambda>\\<nu>. (q, \\<nu>, \\<delta> q \\<nu>))\n                         \\<Sigma>)}\n\ngoal (2 subgoals):\n 1. \\<And>q q' \\<nu>.\n       \\<lbrakk>q = foldl \\<delta> q\\<^sub>0 [];\n        q' = foldl \\<delta> q\\<^sub>0 ([] @ [\\<nu>]);\n        set [] \\<subseteq> set \\<Sigma>; \\<nu> \\<in> set \\<Sigma>\\<rbrakk>\n       \\<Longrightarrow> (foldl \\<delta> q\\<^sub>0 [], \\<nu>,\n                          foldl \\<delta> q\\<^sub>0 ([] @ [\\<nu>]))\n                         \\<in> reachable\n                                (set (map\n (\\<lambda>\\<nu>. (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>)) \\<Sigma>))\n 2. \\<And>x xs q q' \\<nu>.\n       \\<lbrakk>\\<And>q q' \\<nu>.\n                   \\<lbrakk>q = foldl \\<delta> q\\<^sub>0 xs;\n                    q' = foldl \\<delta> q\\<^sub>0 (xs @ [\\<nu>]);\n                    set xs \\<subseteq> set \\<Sigma>;\n                    \\<nu> \\<in> set \\<Sigma>\\<rbrakk>\n                   \\<Longrightarrow> (foldl \\<delta> q\\<^sub>0 xs, \\<nu>,\nfoldl \\<delta> q\\<^sub>0 (xs @ [\\<nu>]))\n                                     \\<in> reachable\n      (set (map (\\<lambda>\\<nu>.\n                    (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n             \\<Sigma>));\n        q = foldl \\<delta> q\\<^sub>0 (xs @ [x]);\n        q' = foldl \\<delta> q\\<^sub>0 ((xs @ [x]) @ [\\<nu>]);\n        set (xs @ [x]) \\<subseteq> set \\<Sigma>;\n        \\<nu> \\<in> set \\<Sigma>\\<rbrakk>\n       \\<Longrightarrow> (foldl \\<delta> q\\<^sub>0 (xs @ [x]), \\<nu>,\n                          foldl \\<delta> q\\<^sub>0 ((xs @ [x]) @ [\\<nu>]))\n                         \\<in> reachable\n                                (set (map\n (\\<lambda>\\<nu>. (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>)) \\<Sigma>))", "ultimately"], ["proof (chain)\npicking this:\n  (x\\<^sub>0, foldl \\<delta> q\\<^sub>0 w, \\<nu>',\n   foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>']))\n  \\<in> {(x, y).\n         y \\<in> set (case x of\n                      (uu_, uua_, q) \\<Rightarrow>\n                        map (\\<lambda>\\<nu>. (q, \\<nu>, \\<delta> q \\<nu>))\n                         \\<Sigma>)}\\<^sup>*\n  x\\<^sub>0\n  \\<in> set (map (\\<lambda>\\<nu>.\n                     (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n              \\<Sigma>)\n  ((foldl \\<delta> q\\<^sub>0 w, \\<nu>',\n    foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>'])),\n   foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>']), \\<nu>,\n   \\<delta> (foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>'])) \\<nu>)\n  \\<in> {(x, y).\n         y \\<in> set (case x of\n                      (uu_, uua_, q) \\<Rightarrow>\n                        map (\\<lambda>\\<nu>. (q, \\<nu>, \\<delta> q \\<nu>))\n                         \\<Sigma>)}", "show ?case"], ["proof (prove)\nusing this:\n  (x\\<^sub>0, foldl \\<delta> q\\<^sub>0 w, \\<nu>',\n   foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>']))\n  \\<in> {(x, y).\n         y \\<in> set (case x of\n                      (uu_, uua_, q) \\<Rightarrow>\n                        map (\\<lambda>\\<nu>. (q, \\<nu>, \\<delta> q \\<nu>))\n                         \\<Sigma>)}\\<^sup>*\n  x\\<^sub>0\n  \\<in> set (map (\\<lambda>\\<nu>.\n                     (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n              \\<Sigma>)\n  ((foldl \\<delta> q\\<^sub>0 w, \\<nu>',\n    foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>'])),\n   foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>']), \\<nu>,\n   \\<delta> (foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>'])) \\<nu>)\n  \\<in> {(x, y).\n         y \\<in> set (case x of\n                      (uu_, uua_, q) \\<Rightarrow>\n                        map (\\<lambda>\\<nu>. (q, \\<nu>, \\<delta> q \\<nu>))\n                         \\<Sigma>)}\n\ngoal (1 subgoal):\n 1. (foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>']), \\<nu>,\n     foldl \\<delta> q\\<^sub>0 ((w @ [\\<nu>']) @ [\\<nu>]))\n    \\<in> reachable\n           (set (map (\\<lambda>\\<nu>.\n                         (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                  \\<Sigma>))", "using rtrancl.rtrancl_into_rtrancl[OF 1 3] 2"], ["proof (prove)\nusing this:\n  (x\\<^sub>0, foldl \\<delta> q\\<^sub>0 w, \\<nu>',\n   foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>']))\n  \\<in> {(x, y).\n         y \\<in> set (case x of\n                      (uu_, uua_, q) \\<Rightarrow>\n                        map (\\<lambda>\\<nu>. (q, \\<nu>, \\<delta> q \\<nu>))\n                         \\<Sigma>)}\\<^sup>*\n  x\\<^sub>0\n  \\<in> set (map (\\<lambda>\\<nu>.\n                     (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n              \\<Sigma>)\n  ((foldl \\<delta> q\\<^sub>0 w, \\<nu>',\n    foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>'])),\n   foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>']), \\<nu>,\n   \\<delta> (foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>'])) \\<nu>)\n  \\<in> {(x, y).\n         y \\<in> set (case x of\n                      (uu_, uua_, q) \\<Rightarrow>\n                        map (\\<lambda>\\<nu>. (q, \\<nu>, \\<delta> q \\<nu>))\n                         \\<Sigma>)}\n  (x\\<^sub>0, foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>']), \\<nu>,\n   \\<delta> (foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>'])) \\<nu>)\n  \\<in> {(x, y).\n         y \\<in> set (case x of\n                      (uu_, uua_, q) \\<Rightarrow>\n                        map (\\<lambda>\\<nu>. (q, \\<nu>, \\<delta> q \\<nu>))\n                         \\<Sigma>)}\\<^sup>*\n  x\\<^sub>0\n  \\<in> set (map (\\<lambda>\\<nu>.\n                     (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n              \\<Sigma>)\n\ngoal (1 subgoal):\n 1. (foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>']), \\<nu>,\n     foldl \\<delta> q\\<^sub>0 ((w @ [\\<nu>']) @ [\\<nu>]))\n    \\<in> reachable\n           (set (map (\\<lambda>\\<nu>.\n                         (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                  \\<Sigma>))", "unfolding reachable_def foldl_append foldl.simps"], ["proof (prove)\nusing this:\n  (x\\<^sub>0, foldl \\<delta> q\\<^sub>0 w, \\<nu>',\n   \\<delta> (foldl \\<delta> q\\<^sub>0 w) \\<nu>')\n  \\<in> {(x, y).\n         y \\<in> set (case x of\n                      (uu_, uua_, q) \\<Rightarrow>\n                        map (\\<lambda>\\<nu>. (q, \\<nu>, \\<delta> q \\<nu>))\n                         \\<Sigma>)}\\<^sup>*\n  x\\<^sub>0\n  \\<in> set (map (\\<lambda>\\<nu>.\n                     (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n              \\<Sigma>)\n  ((foldl \\<delta> q\\<^sub>0 w, \\<nu>',\n    \\<delta> (foldl \\<delta> q\\<^sub>0 w) \\<nu>'),\n   \\<delta> (foldl \\<delta> q\\<^sub>0 w) \\<nu>', \\<nu>,\n   \\<delta> (\\<delta> (foldl \\<delta> q\\<^sub>0 w) \\<nu>') \\<nu>)\n  \\<in> {(x, y).\n         y \\<in> set (case x of\n                      (uu_, uua_, q) \\<Rightarrow>\n                        map (\\<lambda>\\<nu>. (q, \\<nu>, \\<delta> q \\<nu>))\n                         \\<Sigma>)}\n  (x\\<^sub>0, \\<delta> (foldl \\<delta> q\\<^sub>0 w) \\<nu>', \\<nu>,\n   \\<delta> (\\<delta> (foldl \\<delta> q\\<^sub>0 w) \\<nu>') \\<nu>)\n  \\<in> {(x, y).\n         y \\<in> set (case x of\n                      (uu_, uua_, q) \\<Rightarrow>\n                        map (\\<lambda>\\<nu>. (q, \\<nu>, \\<delta> q \\<nu>))\n                         \\<Sigma>)}\\<^sup>*\n  x\\<^sub>0\n  \\<in> set (map (\\<lambda>\\<nu>.\n                     (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n              \\<Sigma>)\n\ngoal (1 subgoal):\n 1. (\\<delta> (foldl \\<delta> q\\<^sub>0 w) \\<nu>', \\<nu>,\n     \\<delta> (\\<delta> (foldl \\<delta> q\\<^sub>0 w) \\<nu>') \\<nu>)\n    \\<in> {(x, y).\n           y \\<in> set (case x of\n                        (uu_, uua_, q) \\<Rightarrow>\n                          map (\\<lambda>\\<nu>. (q, \\<nu>, \\<delta> q \\<nu>))\n                           \\<Sigma>)}\\<^sup>* ``\n          set (map (\\<lambda>\\<nu>.\n                       (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                \\<Sigma>)", "by auto"], ["proof (state)\nthis:\n  (foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>']), \\<nu>,\n   foldl \\<delta> q\\<^sub>0 ((w @ [\\<nu>']) @ [\\<nu>]))\n  \\<in> reachable\n         (set (map (\\<lambda>\\<nu>.\n                       (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                \\<Sigma>))\n\ngoal (1 subgoal):\n 1. \\<And>q q' \\<nu>.\n       \\<lbrakk>q = foldl \\<delta> q\\<^sub>0 [];\n        q' = foldl \\<delta> q\\<^sub>0 ([] @ [\\<nu>]);\n        set [] \\<subseteq> set \\<Sigma>; \\<nu> \\<in> set \\<Sigma>\\<rbrakk>\n       \\<Longrightarrow> (foldl \\<delta> q\\<^sub>0 [], \\<nu>,\n                          foldl \\<delta> q\\<^sub>0 ([] @ [\\<nu>]))\n                         \\<in> reachable\n                                (set (map\n (\\<lambda>\\<nu>. (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>)) \\<Sigma>))", "qed (auto simp add: reachable_def)"], ["proof (state)\nthis:\n  (foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n   foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>]))\n  \\<in> reachable\n         (set (map (\\<lambda>\\<nu>.\n                       (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                \\<Sigma>))\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "hence \"(q, \\<nu>, q') \\<in> reachable ?q\\<^sub>0\""], ["proof (prove)\nusing this:\n  (foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n   foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>]))\n  \\<in> reachable\n         (set (map (\\<lambda>\\<nu>.\n                       (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                \\<Sigma>))\n\ngoal (1 subgoal):\n 1. (q, \\<nu>, q')\n    \\<in> reachable\n           (set (map (\\<lambda>\\<nu>.\n                         (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                  \\<Sigma>))", "by (simp add: q_def q'_def)"], ["proof (state)\nthis:\n  (q, \\<nu>, q')\n  \\<in> reachable\n         (set (map (\\<lambda>\\<nu>.\n                       (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                \\<Sigma>))\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "}"], ["proof (state)\nthis:\n  (?q3, ?\\<nu>3, ?q'3)\n  \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0 \\<Longrightarrow>\n  (?q3, ?\\<nu>3, ?q'3)\n  \\<in> reachable\n         (set (map (\\<lambda>\\<nu>.\n                       (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                \\<Sigma>))\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "hence \"reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0 \\<subseteq> reachable ?q\\<^sub>0\""], ["proof (prove)\nusing this:\n  (?q3, ?\\<nu>3, ?q'3)\n  \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0 \\<Longrightarrow>\n  (?q3, ?\\<nu>3, ?q'3)\n  \\<in> reachable\n         (set (map (\\<lambda>\\<nu>.\n                       (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                \\<Sigma>))\n\ngoal (1 subgoal):\n 1. reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0\n    \\<subseteq> reachable\n                 (set (map (\\<lambda>\\<nu>.\n                               (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                        \\<Sigma>))", "by auto"], ["proof (state)\nthis:\n  reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0\n  \\<subseteq> reachable\n               (set (map (\\<lambda>\\<nu>.\n                             (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                      \\<Sigma>))\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "moreover"], ["proof (state)\nthis:\n  reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0\n  \\<subseteq> reachable\n               (set (map (\\<lambda>\\<nu>.\n                             (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                      \\<Sigma>))\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "{"], ["proof (state)\nthis:\n  reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0\n  \\<subseteq> reachable\n               (set (map (\\<lambda>\\<nu>.\n                             (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                      \\<Sigma>))\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "assume \"y \\<in> reachable ?q\\<^sub>0\""], ["proof (state)\nthis:\n  y \\<in> reachable\n           (set (map (\\<lambda>\\<nu>.\n                         (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                  \\<Sigma>))\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "then"], ["proof (chain)\npicking this:\n  y \\<in> reachable\n           (set (map (\\<lambda>\\<nu>.\n                         (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                  \\<Sigma>))", "obtain x where \"(x, y) \\<in> {(x, y). y \\<in> set (case x of (_, _, q) \\<Rightarrow> map (\\<lambda>\\<nu>. (q, \\<nu>, \\<delta> q \\<nu>)) \\<Sigma>)}\\<^sup>*\"\n      and \"x \\<in> ?q\\<^sub>0\""], ["proof (prove)\nusing this:\n  y \\<in> reachable\n           (set (map (\\<lambda>\\<nu>.\n                         (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                  \\<Sigma>))\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>(x, y)\n                 \\<in> {(x, y).\n                        y \\<in> set (case x of\n                                     (x, xa, q) \\<Rightarrow>\n map (\\<lambda>\\<nu>. (q, \\<nu>, \\<delta> q \\<nu>)) \\<Sigma>)}\\<^sup>*;\n         x \\<in> set (map (\\<lambda>\\<nu>.\n                              (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                       \\<Sigma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding reachable_def"], ["proof (prove)\nusing this:\n  y \\<in> {(x, y).\n           y \\<in> set (case x of\n                        (uu_, uua_, q) \\<Rightarrow>\n                          map (\\<lambda>\\<nu>. (q, \\<nu>, \\<delta> q \\<nu>))\n                           \\<Sigma>)}\\<^sup>* ``\n          set (map (\\<lambda>\\<nu>.\n                       (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                \\<Sigma>)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>(x, y)\n                 \\<in> {(x, y).\n                        y \\<in> set (case x of\n                                     (x, xa, q) \\<Rightarrow>\n map (\\<lambda>\\<nu>. (q, \\<nu>, \\<delta> q \\<nu>)) \\<Sigma>)}\\<^sup>*;\n         x \\<in> set (map (\\<lambda>\\<nu>.\n                              (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                       \\<Sigma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (x, y)\n  \\<in> {(x, y).\n         y \\<in> set (case x of\n                      (x, xa, q) \\<Rightarrow>\n                        map (\\<lambda>\\<nu>. (q, \\<nu>, \\<delta> q \\<nu>))\n                         \\<Sigma>)}\\<^sup>*\n  x \\<in> set (map (\\<lambda>\\<nu>.\n                       (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                \\<Sigma>)\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "hence \"y \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0\""], ["proof (prove)\nusing this:\n  (x, y)\n  \\<in> {(x, y).\n         y \\<in> set (case x of\n                      (x, xa, q) \\<Rightarrow>\n                        map (\\<lambda>\\<nu>. (q, \\<nu>, \\<delta> q \\<nu>))\n                         \\<Sigma>)}\\<^sup>*\n  x \\<in> set (map (\\<lambda>\\<nu>.\n                       (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                \\<Sigma>)\n\ngoal (1 subgoal):\n 1. y \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "proof induction"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> set (map (\\<lambda>\\<nu>.\n                         (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                  \\<Sigma>) \\<Longrightarrow>\n    x \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0\n 2. \\<And>y z.\n       \\<lbrakk>(x, y)\n                \\<in> {(x, y).\n                       y \\<in> set (case x of\n                                    (x, xa, q) \\<Rightarrow>\nmap (\\<lambda>\\<nu>. (q, \\<nu>, \\<delta> q \\<nu>)) \\<Sigma>)}\\<^sup>*;\n        (y, z)\n        \\<in> {(x, y).\n               y \\<in> set (case x of\n                            (x, xa, q) \\<Rightarrow>\n                              map (\\<lambda>\\<nu>.\n(q, \\<nu>, \\<delta> q \\<nu>))\n                               \\<Sigma>)};\n        x \\<in> set (map (\\<lambda>\\<nu>.\n                             (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                      \\<Sigma>) \\<Longrightarrow>\n        y \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0;\n        x \\<in> set (map (\\<lambda>\\<nu>.\n                             (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                      \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> z \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta>\n                                  q\\<^sub>0", "case base"], ["proof (state)\nthis:\n  x \\<in> set (map (\\<lambda>\\<nu>.\n                       (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                \\<Sigma>)\n\ngoal (2 subgoals):\n 1. x \\<in> set (map (\\<lambda>\\<nu>.\n                         (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                  \\<Sigma>) \\<Longrightarrow>\n    x \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0\n 2. \\<And>y z.\n       \\<lbrakk>(x, y)\n                \\<in> {(x, y).\n                       y \\<in> set (case x of\n                                    (x, xa, q) \\<Rightarrow>\nmap (\\<lambda>\\<nu>. (q, \\<nu>, \\<delta> q \\<nu>)) \\<Sigma>)}\\<^sup>*;\n        (y, z)\n        \\<in> {(x, y).\n               y \\<in> set (case x of\n                            (x, xa, q) \\<Rightarrow>\n                              map (\\<lambda>\\<nu>.\n(q, \\<nu>, \\<delta> q \\<nu>))\n                               \\<Sigma>)};\n        x \\<in> set (map (\\<lambda>\\<nu>.\n                             (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                      \\<Sigma>) \\<Longrightarrow>\n        y \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0;\n        x \\<in> set (map (\\<lambda>\\<nu>.\n                             (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                      \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> z \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta>\n                                  q\\<^sub>0", "have \"\\<forall>p ps. list_all p ps = (\\<forall>pa. pa \\<in> set ps \\<longrightarrow> p pa)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p ps.\n       list_all p ps = (\\<forall>pa. pa \\<in> set ps \\<longrightarrow> p pa)", "by (meson list_all_iff)"], ["proof (state)\nthis:\n  \\<forall>p ps.\n     list_all p ps = (\\<forall>pa. pa \\<in> set ps \\<longrightarrow> p pa)\n\ngoal (2 subgoals):\n 1. x \\<in> set (map (\\<lambda>\\<nu>.\n                         (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                  \\<Sigma>) \\<Longrightarrow>\n    x \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0\n 2. \\<And>y z.\n       \\<lbrakk>(x, y)\n                \\<in> {(x, y).\n                       y \\<in> set (case x of\n                                    (x, xa, q) \\<Rightarrow>\nmap (\\<lambda>\\<nu>. (q, \\<nu>, \\<delta> q \\<nu>)) \\<Sigma>)}\\<^sup>*;\n        (y, z)\n        \\<in> {(x, y).\n               y \\<in> set (case x of\n                            (x, xa, q) \\<Rightarrow>\n                              map (\\<lambda>\\<nu>.\n(q, \\<nu>, \\<delta> q \\<nu>))\n                               \\<Sigma>)};\n        x \\<in> set (map (\\<lambda>\\<nu>.\n                             (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                      \\<Sigma>) \\<Longrightarrow>\n        y \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0;\n        x \\<in> set (map (\\<lambda>\\<nu>.\n                             (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                      \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> z \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta>\n                                  q\\<^sub>0", "hence \"x \\<in> {(foldl \\<delta> (foldl \\<delta> q\\<^sub>0 []) bs, b, foldl \\<delta> (foldl \\<delta> q\\<^sub>0 []) (bs @ [b])) | bs b. set bs \\<subseteq> set \\<Sigma> \\<and> b \\<in> set \\<Sigma>}\""], ["proof (prove)\nusing this:\n  \\<forall>p ps.\n     list_all p ps = (\\<forall>pa. pa \\<in> set ps \\<longrightarrow> p pa)\n\ngoal (1 subgoal):\n 1. x \\<in> {(foldl \\<delta> (foldl \\<delta> q\\<^sub>0 []) bs, b,\n              foldl \\<delta> (foldl \\<delta> q\\<^sub>0 []) (bs @ [b])) |\n             bs b.\n             set bs \\<subseteq> set \\<Sigma> \\<and> b \\<in> set \\<Sigma>}", "using base"], ["proof (prove)\nusing this:\n  \\<forall>p ps.\n     list_all p ps = (\\<forall>pa. pa \\<in> set ps \\<longrightarrow> p pa)\n  x \\<in> set (map (\\<lambda>\\<nu>.\n                       (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                \\<Sigma>)\n\ngoal (1 subgoal):\n 1. x \\<in> {(foldl \\<delta> (foldl \\<delta> q\\<^sub>0 []) bs, b,\n              foldl \\<delta> (foldl \\<delta> q\\<^sub>0 []) (bs @ [b])) |\n             bs b.\n             set bs \\<subseteq> set \\<Sigma> \\<and> b \\<in> set \\<Sigma>}", "by (metis (no_types) Nil2 list_all_init reach\\<^sub>t_foldl_def)"], ["proof (state)\nthis:\n  x \\<in> {(foldl \\<delta> (foldl \\<delta> q\\<^sub>0 []) bs, b,\n            foldl \\<delta> (foldl \\<delta> q\\<^sub>0 []) (bs @ [b])) |\n           bs b.\n           set bs \\<subseteq> set \\<Sigma> \\<and> b \\<in> set \\<Sigma>}\n\ngoal (2 subgoals):\n 1. x \\<in> set (map (\\<lambda>\\<nu>.\n                         (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                  \\<Sigma>) \\<Longrightarrow>\n    x \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0\n 2. \\<And>y z.\n       \\<lbrakk>(x, y)\n                \\<in> {(x, y).\n                       y \\<in> set (case x of\n                                    (x, xa, q) \\<Rightarrow>\nmap (\\<lambda>\\<nu>. (q, \\<nu>, \\<delta> q \\<nu>)) \\<Sigma>)}\\<^sup>*;\n        (y, z)\n        \\<in> {(x, y).\n               y \\<in> set (case x of\n                            (x, xa, q) \\<Rightarrow>\n                              map (\\<lambda>\\<nu>.\n(q, \\<nu>, \\<delta> q \\<nu>))\n                               \\<Sigma>)};\n        x \\<in> set (map (\\<lambda>\\<nu>.\n                             (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                      \\<Sigma>) \\<Longrightarrow>\n        y \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0;\n        x \\<in> set (map (\\<lambda>\\<nu>.\n                             (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                      \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> z \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta>\n                                  q\\<^sub>0", "thus ?case"], ["proof (prove)\nusing this:\n  x \\<in> {(foldl \\<delta> (foldl \\<delta> q\\<^sub>0 []) bs, b,\n            foldl \\<delta> (foldl \\<delta> q\\<^sub>0 []) (bs @ [b])) |\n           bs b.\n           set bs \\<subseteq> set \\<Sigma> \\<and> b \\<in> set \\<Sigma>}\n\ngoal (1 subgoal):\n 1. x \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "unfolding reach\\<^sub>t_foldl_def"], ["proof (prove)\nusing this:\n  x \\<in> {(foldl \\<delta> (foldl \\<delta> q\\<^sub>0 []) bs, b,\n            foldl \\<delta> (foldl \\<delta> q\\<^sub>0 []) (bs @ [b])) |\n           bs b.\n           set bs \\<subseteq> set \\<Sigma> \\<and> b \\<in> set \\<Sigma>}\n\ngoal (1 subgoal):\n 1. x \\<in> {(foldl \\<delta> q\\<^sub>0 w, \\<nu>,\n              foldl \\<delta> q\\<^sub>0 (w @ [\\<nu>])) |\n             w \\<nu>.\n             set w \\<subseteq> set \\<Sigma> \\<and> \\<nu> \\<in> set \\<Sigma>}", "by auto"], ["proof (state)\nthis:\n  x \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y)\n                \\<in> {(x, y).\n                       y \\<in> set (case x of\n                                    (x, xa, q) \\<Rightarrow>\nmap (\\<lambda>\\<nu>. (q, \\<nu>, \\<delta> q \\<nu>)) \\<Sigma>)}\\<^sup>*;\n        (y, z)\n        \\<in> {(x, y).\n               y \\<in> set (case x of\n                            (x, xa, q) \\<Rightarrow>\n                              map (\\<lambda>\\<nu>.\n(q, \\<nu>, \\<delta> q \\<nu>))\n                               \\<Sigma>)};\n        x \\<in> set (map (\\<lambda>\\<nu>.\n                             (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                      \\<Sigma>) \\<Longrightarrow>\n        y \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0;\n        x \\<in> set (map (\\<lambda>\\<nu>.\n                             (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                      \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> z \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta>\n                                  q\\<^sub>0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y)\n                \\<in> {(x, y).\n                       y \\<in> set (case x of\n                                    (x, xa, q) \\<Rightarrow>\nmap (\\<lambda>\\<nu>. (q, \\<nu>, \\<delta> q \\<nu>)) \\<Sigma>)}\\<^sup>*;\n        (y, z)\n        \\<in> {(x, y).\n               y \\<in> set (case x of\n                            (x, xa, q) \\<Rightarrow>\n                              map (\\<lambda>\\<nu>.\n(q, \\<nu>, \\<delta> q \\<nu>))\n                               \\<Sigma>)};\n        x \\<in> set (map (\\<lambda>\\<nu>.\n                             (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                      \\<Sigma>) \\<Longrightarrow>\n        y \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0;\n        x \\<in> set (map (\\<lambda>\\<nu>.\n                             (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                      \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> z \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta>\n                                  q\\<^sub>0", "case (step x' y')"], ["proof (state)\nthis:\n  (x, x')\n  \\<in> {(x, y).\n         y \\<in> set (case x of\n                      (x, xa, q) \\<Rightarrow>\n                        map (\\<lambda>\\<nu>. (q, \\<nu>, \\<delta> q \\<nu>))\n                         \\<Sigma>)}\\<^sup>*\n  (x', y')\n  \\<in> {(x, y).\n         y \\<in> set (case x of\n                      (x, xa, q) \\<Rightarrow>\n                        map (\\<lambda>\\<nu>. (q, \\<nu>, \\<delta> q \\<nu>))\n                         \\<Sigma>)}\n  x \\<in> set (map (\\<lambda>\\<nu>.\n                       (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                \\<Sigma>) \\<Longrightarrow>\n  x' \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0\n  x \\<in> set (map (\\<lambda>\\<nu>.\n                       (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                \\<Sigma>)\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y)\n                \\<in> {(x, y).\n                       y \\<in> set (case x of\n                                    (x, xa, q) \\<Rightarrow>\nmap (\\<lambda>\\<nu>. (q, \\<nu>, \\<delta> q \\<nu>)) \\<Sigma>)}\\<^sup>*;\n        (y, z)\n        \\<in> {(x, y).\n               y \\<in> set (case x of\n                            (x, xa, q) \\<Rightarrow>\n                              map (\\<lambda>\\<nu>.\n(q, \\<nu>, \\<delta> q \\<nu>))\n                               \\<Sigma>)};\n        x \\<in> set (map (\\<lambda>\\<nu>.\n                             (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                      \\<Sigma>) \\<Longrightarrow>\n        y \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0;\n        x \\<in> set (map (\\<lambda>\\<nu>.\n                             (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                      \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> z \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta>\n                                  q\\<^sub>0", "thus ?case"], ["proof (prove)\nusing this:\n  (x, x')\n  \\<in> {(x, y).\n         y \\<in> set (case x of\n                      (x, xa, q) \\<Rightarrow>\n                        map (\\<lambda>\\<nu>. (q, \\<nu>, \\<delta> q \\<nu>))\n                         \\<Sigma>)}\\<^sup>*\n  (x', y')\n  \\<in> {(x, y).\n         y \\<in> set (case x of\n                      (x, xa, q) \\<Rightarrow>\n                        map (\\<lambda>\\<nu>. (q, \\<nu>, \\<delta> q \\<nu>))\n                         \\<Sigma>)}\n  x \\<in> set (map (\\<lambda>\\<nu>.\n                       (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                \\<Sigma>) \\<Longrightarrow>\n  x' \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0\n  x \\<in> set (map (\\<lambda>\\<nu>.\n                       (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                \\<Sigma>)\n\ngoal (1 subgoal):\n 1. y' \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "using succsr_def succsr_isNode"], ["proof (prove)\nusing this:\n  (x, x')\n  \\<in> {(x, y).\n         y \\<in> set (case x of\n                      (x, xa, q) \\<Rightarrow>\n                        map (\\<lambda>\\<nu>. (q, \\<nu>, \\<delta> q \\<nu>))\n                         \\<Sigma>)}\\<^sup>*\n  (x', y')\n  \\<in> {(x, y).\n         y \\<in> set (case x of\n                      (x, xa, q) \\<Rightarrow>\n                        map (\\<lambda>\\<nu>. (q, \\<nu>, \\<delta> q \\<nu>))\n                         \\<Sigma>)}\n  x \\<in> set (map (\\<lambda>\\<nu>.\n                       (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                \\<Sigma>) \\<Longrightarrow>\n  x' \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0\n  x \\<in> set (map (\\<lambda>\\<nu>.\n                       (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                \\<Sigma>)\n  succsr \\<equiv>\n  {(x, y).\n   y \\<in> set (case x of\n                (uu_, uua_, q) \\<Rightarrow>\n                  map (\\<lambda>\\<nu>. (q, \\<nu>, \\<delta> q \\<nu>))\n                   \\<Sigma>)}\n  \\<lbrakk>(?x, ?y) \\<in> succsr\\<^sup>*;\n   ?x \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0\\<rbrakk>\n  \\<Longrightarrow> ?y \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0\n\ngoal (1 subgoal):\n 1. y' \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "by blast"], ["proof (state)\nthis:\n  y' \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "}"], ["proof (state)\nthis:\n  ?y3\n  \\<in> reachable\n         (set (map (\\<lambda>\\<nu>.\n                       (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                \\<Sigma>)) \\<Longrightarrow>\n  ?y3 \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "hence \"reachable ?q\\<^sub>0 \\<subseteq> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0\""], ["proof (prove)\nusing this:\n  ?y3\n  \\<in> reachable\n         (set (map (\\<lambda>\\<nu>.\n                       (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                \\<Sigma>)) \\<Longrightarrow>\n  ?y3 \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0\n\ngoal (1 subgoal):\n 1. reachable\n     (set (map (\\<lambda>\\<nu>.\n                   (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n            \\<Sigma>))\n    \\<subseteq> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "by blast"], ["proof (state)\nthis:\n  reachable\n   (set (map (\\<lambda>\\<nu>. (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n          \\<Sigma>))\n  \\<subseteq> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "ultimately"], ["proof (chain)\npicking this:\n  reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0\n  \\<subseteq> reachable\n               (set (map (\\<lambda>\\<nu>.\n                             (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                      \\<Sigma>))\n  reachable\n   (set (map (\\<lambda>\\<nu>. (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n          \\<Sigma>))\n  \\<subseteq> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "have reachable_redef: \"reachable ?q\\<^sub>0 = reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0\""], ["proof (prove)\nusing this:\n  reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0\n  \\<subseteq> reachable\n               (set (map (\\<lambda>\\<nu>.\n                             (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                      \\<Sigma>))\n  reachable\n   (set (map (\\<lambda>\\<nu>. (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n          \\<Sigma>))\n  \\<subseteq> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0\n\ngoal (1 subgoal):\n 1. reachable\n     (set (map (\\<lambda>\\<nu>.\n                   (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n            \\<Sigma>)) =\n    reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "by blast"], ["proof (state)\nthis:\n  reachable\n   (set (map (\\<lambda>\\<nu>. (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n          \\<Sigma>)) =\n  reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "moreover"], ["proof (state)\nthis:\n  reachable\n   (set (map (\\<lambda>\\<nu>. (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n          \\<Sigma>)) =\n  reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "have \"reachable ?q\\<^sub>0 \\<subseteq> (\\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable\n     (set (map (\\<lambda>\\<nu>.\n                   (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n            \\<Sigma>))\n    \\<subseteq> \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0", "using reachable_imp_dfs[OF _ list_all_init]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0;\n   ?y \\<in> reachable\n             (set (map (\\<lambda>\\<nu>.\n                           (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n                    \\<Sigma>))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>y'.\n                       id y' = id ?y \\<and>\n                       y' \\<in> set (dfs []\n(map (\\<lambda>\\<nu>. (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n  \\<Sigma>))\n\ngoal (1 subgoal):\n 1. reachable\n     (set (map (\\<lambda>\\<nu>.\n                   (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n            \\<Sigma>))\n    \\<subseteq> \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0", "unfolding \\<delta>\\<^sub>L_def reachable_redef list_dfs_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0;\n   ?y \\<in> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>y'.\n                       id y' = id ?y \\<and>\n                       y' \\<in> set (dfs []\n(map (\\<lambda>\\<nu>. (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n  \\<Sigma>))\n\ngoal (1 subgoal):\n 1. reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0\n    \\<subseteq> set (let start =\n                           map (\\<lambda>\\<nu>.\n                                   (q\\<^sub>0, \\<nu>,\n                                    \\<delta> q\\<^sub>0 \\<nu>))\n                            \\<Sigma>;\n                         succ =\n                           \\<lambda>(uu_, uu_, q).\n                              map (\\<lambda>\\<nu>.\n(q, \\<nu>, \\<delta> q \\<nu>))\n                               \\<Sigma>\n                     in gen_dfs succ List.insert\n                         (\\<lambda>x xs. x \\<in> set xs) [] start)", "by (simp; blast)"], ["proof (state)\nthis:\n  reachable\n   (set (map (\\<lambda>\\<nu>. (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n          \\<Sigma>))\n  \\<subseteq> \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "moreover"], ["proof (state)\nthis:\n  reachable\n   (set (map (\\<lambda>\\<nu>. (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n          \\<Sigma>))\n  \\<subseteq> \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "have \"\\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 \\<subseteq> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0\n    \\<subseteq> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "using dfs_invariant[of \"[]\", OF _ list_all_init]"], ["proof (prove)\nusing this:\n  set []\n  \\<subseteq> reach\\<^sub>t (set \\<Sigma>) \\<delta>\n               q\\<^sub>0 \\<Longrightarrow>\n  set (dfs []\n        (map (\\<lambda>\\<nu>. (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n          \\<Sigma>))\n  \\<subseteq> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0\n    \\<subseteq> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "by (auto simp add: reach\\<^sub>t_foldl_def \\<delta>\\<^sub>L_def list_dfs_def)"], ["proof (state)\nthis:\n  \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0\n  \\<subseteq> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "ultimately"], ["proof (chain)\npicking this:\n  reachable\n   (set (map (\\<lambda>\\<nu>. (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n          \\<Sigma>)) =\n  reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0\n  reachable\n   (set (map (\\<lambda>\\<nu>. (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n          \\<Sigma>))\n  \\<subseteq> \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0\n  \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0\n  \\<subseteq> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "show ?thesis"], ["proof (prove)\nusing this:\n  reachable\n   (set (map (\\<lambda>\\<nu>. (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n          \\<Sigma>)) =\n  reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0\n  reachable\n   (set (map (\\<lambda>\\<nu>. (q\\<^sub>0, \\<nu>, \\<delta> q\\<^sub>0 \\<nu>))\n          \\<Sigma>))\n  \\<subseteq> \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0\n  \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0\n  \\<subseteq> reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", "by simp"], ["proof (state)\nthis:\n  \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n  reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reach_reach\\<^sub>t_fst:\n  \"reach \\<Sigma> \\<delta> q\\<^sub>0 = fst ` reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach \\<Sigma> \\<delta> q\\<^sub>0 =\n    fst ` reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0", "unfolding reach\\<^sub>t_def reach_def image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {run \\<delta> q\\<^sub>0 w n |w n.\n     {y. \\<exists>x\\<in>UNIV. y = w x} \\<subseteq> \\<Sigma>} =\n    {y. \\<exists>x\\<in>{run\\<^sub>t \\<delta> q\\<^sub>0 w n |w n.\n                        {y. \\<exists>x\\<in>UNIV. y = w x}\n                        \\<subseteq> \\<Sigma>}.\n           y = fst x}", "by fastforce"], ["", "lemma finite_reach:\n  \"finite (reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0) \\<Longrightarrow> finite (reach \\<Sigma> \\<delta> q\\<^sub>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0) \\<Longrightarrow>\n    finite (reach \\<Sigma> \\<delta> q\\<^sub>0)", "by (simp add: reach_reach\\<^sub>t_fst)"], ["", "lemma finite_reach\\<^sub>t:\n  assumes \"finite (reach \\<Sigma> \\<delta> q\\<^sub>0)\"\n  assumes \"finite \\<Sigma>\"\n  shows \"finite (reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0)", "have \"reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0 \\<subseteq> reach \\<Sigma> \\<delta> q\\<^sub>0 \\<times> \\<Sigma> \\<times> reach \\<Sigma> \\<delta> q\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0\n    \\<subseteq> reach \\<Sigma> \\<delta> q\\<^sub>0 \\<times>\n                \\<Sigma> \\<times> reach \\<Sigma> \\<delta> q\\<^sub>0", "unfolding reach\\<^sub>t_def reach_def run\\<^sub>t.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(run \\<delta> q\\<^sub>0 w n, w n, run \\<delta> q\\<^sub>0 w (Suc n)) |w\n     n. range w \\<subseteq> \\<Sigma>}\n    \\<subseteq> {run \\<delta> q\\<^sub>0 w n |w n.\n                 range w \\<subseteq> \\<Sigma>} \\<times>\n                \\<Sigma> \\<times>\n                {run \\<delta> q\\<^sub>0 w n |w n.\n                 range w \\<subseteq> \\<Sigma>}", "by blast"], ["proof (state)\nthis:\n  reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0\n  \\<subseteq> reach \\<Sigma> \\<delta> q\\<^sub>0 \\<times>\n              \\<Sigma> \\<times> reach \\<Sigma> \\<delta> q\\<^sub>0\n\ngoal (1 subgoal):\n 1. finite (reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0\n  \\<subseteq> reach \\<Sigma> \\<delta> q\\<^sub>0 \\<times>\n              \\<Sigma> \\<times> reach \\<Sigma> \\<delta> q\\<^sub>0\n\ngoal (1 subgoal):\n 1. finite (reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0)", "using assms finite_subset"], ["proof (prove)\nusing this:\n  reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0\n  \\<subseteq> reach \\<Sigma> \\<delta> q\\<^sub>0 \\<times>\n              \\<Sigma> \\<times> reach \\<Sigma> \\<delta> q\\<^sub>0\n  finite (reach \\<Sigma> \\<delta> q\\<^sub>0)\n  finite \\<Sigma>\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. finite (reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0)", "by blast"], ["proof (state)\nthis:\n  finite (reach\\<^sub>t \\<Sigma> \\<delta> q\\<^sub>0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Q\\<^sub>L_eq_\\<delta>\\<^sub>L:\n  assumes \"finite (reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0)\"\n  shows \"Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 = fst ` (\\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0 =\n    fst ` \\<delta>\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0", "unfolding set_map \\<delta>\\<^sub>L_reach[OF assms] Q\\<^sub>L_reach[OF finite_reach[OF assms]] reach_reach\\<^sub>t_fst"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0 =\n    fst ` reach\\<^sub>t (set \\<Sigma>) \\<delta> q\\<^sub>0", ".."], ["", "subsection \\<open>Product of DTS\\<close>"], ["", "fun simple_product :: \"('a, 'c) DTS \\<Rightarrow> ('b, 'c) DTS \\<Rightarrow> ('a \\<times> 'b, 'c) DTS\" (\"_ \\<times> _\")\nwhere\n  \"\\<delta>\\<^sub>1 \\<times> \\<delta>\\<^sub>2 = (\\<lambda>(q\\<^sub>1, q\\<^sub>2) \\<nu>. (\\<delta>\\<^sub>1 q\\<^sub>1 \\<nu>, \\<delta>\\<^sub>2 q\\<^sub>2 \\<nu>))\""], ["", "lemma simple_product_run:\n  fixes \\<delta>\\<^sub>1 \\<delta>\\<^sub>2 w q\\<^sub>1 q\\<^sub>2\n  defines \"\\<rho> \\<equiv> run (\\<delta>\\<^sub>1 \\<times> \\<delta>\\<^sub>2) (q\\<^sub>1, q\\<^sub>2) w\"\n  defines \"\\<rho>\\<^sub>1 \\<equiv> run \\<delta>\\<^sub>1 q\\<^sub>1 w\"\n  defines \"\\<rho>\\<^sub>2 \\<equiv> run \\<delta>\\<^sub>2 q\\<^sub>2 w\"\n  shows \"\\<rho> i = (\\<rho>\\<^sub>1 i, \\<rho>\\<^sub>2 i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<rho> i = (\\<rho>\\<^sub>1 i, \\<rho>\\<^sub>2 i)", "by (induction i) (insert assms, auto)"], ["", "theorem finite_reach_simple_product:\n  assumes \"finite (reach \\<Sigma> \\<delta>\\<^sub>1 q\\<^sub>1)\"\n  assumes \"finite (reach \\<Sigma> \\<delta>\\<^sub>2 q\\<^sub>2)\"\n  shows \"finite (reach \\<Sigma> (\\<delta>\\<^sub>1 \\<times> \\<delta>\\<^sub>2) (q\\<^sub>1, q\\<^sub>2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (reach \\<Sigma> \\<delta>\\<^sub>1 \\<times> \\<delta>\\<^sub>2\n       (q\\<^sub>1, q\\<^sub>2))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite\n     (reach \\<Sigma> \\<delta>\\<^sub>1 \\<times> \\<delta>\\<^sub>2\n       (q\\<^sub>1, q\\<^sub>2))", "have \"reach \\<Sigma> (\\<delta>\\<^sub>1 \\<times> \\<delta>\\<^sub>2) (q\\<^sub>1, q\\<^sub>2) \\<subseteq> reach \\<Sigma> \\<delta>\\<^sub>1 q\\<^sub>1 \\<times> reach \\<Sigma> \\<delta>\\<^sub>2 q\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach \\<Sigma> \\<delta>\\<^sub>1 \\<times> \\<delta>\\<^sub>2\n     (q\\<^sub>1, q\\<^sub>2)\n    \\<subseteq> reach \\<Sigma> \\<delta>\\<^sub>1 q\\<^sub>1 \\<times>\n                reach \\<Sigma> \\<delta>\\<^sub>2 q\\<^sub>2", "unfolding reach_def simple_product_run"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(run \\<delta>\\<^sub>1 q\\<^sub>1 w n,\n      run \\<delta>\\<^sub>2 q\\<^sub>2 w n) |\n     w n. range w \\<subseteq> \\<Sigma>}\n    \\<subseteq> {run \\<delta>\\<^sub>1 q\\<^sub>1 w n |w n.\n                 range w \\<subseteq> \\<Sigma>} \\<times>\n                {run \\<delta>\\<^sub>2 q\\<^sub>2 w n |w n.\n                 range w \\<subseteq> \\<Sigma>}", "by blast"], ["proof (state)\nthis:\n  reach \\<Sigma> \\<delta>\\<^sub>1 \\<times> \\<delta>\\<^sub>2\n   (q\\<^sub>1, q\\<^sub>2)\n  \\<subseteq> reach \\<Sigma> \\<delta>\\<^sub>1 q\\<^sub>1 \\<times>\n              reach \\<Sigma> \\<delta>\\<^sub>2 q\\<^sub>2\n\ngoal (1 subgoal):\n 1. finite\n     (reach \\<Sigma> \\<delta>\\<^sub>1 \\<times> \\<delta>\\<^sub>2\n       (q\\<^sub>1, q\\<^sub>2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  reach \\<Sigma> \\<delta>\\<^sub>1 \\<times> \\<delta>\\<^sub>2\n   (q\\<^sub>1, q\\<^sub>2)\n  \\<subseteq> reach \\<Sigma> \\<delta>\\<^sub>1 q\\<^sub>1 \\<times>\n              reach \\<Sigma> \\<delta>\\<^sub>2 q\\<^sub>2\n\ngoal (1 subgoal):\n 1. finite\n     (reach \\<Sigma> \\<delta>\\<^sub>1 \\<times> \\<delta>\\<^sub>2\n       (q\\<^sub>1, q\\<^sub>2))", "using assms finite_subset"], ["proof (prove)\nusing this:\n  reach \\<Sigma> \\<delta>\\<^sub>1 \\<times> \\<delta>\\<^sub>2\n   (q\\<^sub>1, q\\<^sub>2)\n  \\<subseteq> reach \\<Sigma> \\<delta>\\<^sub>1 q\\<^sub>1 \\<times>\n              reach \\<Sigma> \\<delta>\\<^sub>2 q\\<^sub>2\n  finite (reach \\<Sigma> \\<delta>\\<^sub>1 q\\<^sub>1)\n  finite (reach \\<Sigma> \\<delta>\\<^sub>2 q\\<^sub>2)\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. finite\n     (reach \\<Sigma> \\<delta>\\<^sub>1 \\<times> \\<delta>\\<^sub>2\n       (q\\<^sub>1, q\\<^sub>2))", "by blast"], ["proof (state)\nthis:\n  finite\n   (reach \\<Sigma> \\<delta>\\<^sub>1 \\<times> \\<delta>\\<^sub>2\n     (q\\<^sub>1, q\\<^sub>2))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>(Generalised) Product of DTS\\<close>"], ["", "fun product :: \"('a \\<Rightarrow> ('b, 'c) DTS) \\<Rightarrow> ('a \\<rightharpoonup> 'b, 'c) DTS\" (\"\\<Delta>\\<^sub>\\<times>\")\nwhere\n  \"\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m = (\\<lambda>q \\<nu>. (\\<lambda>x. case q x of None \\<Rightarrow> None | Some y \\<Rightarrow> Some (\\<delta>\\<^sub>m x y \\<nu>)))\""], ["", "lemma product_run_None:\n  fixes \\<iota>\\<^sub>m \\<delta>\\<^sub>m w\n  defines \"\\<rho> \\<equiv> run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m w\"\n  assumes \"\\<iota>\\<^sub>m k = None\"\n  shows \"\\<rho> i k = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<rho> i k = None", "by (induction i) (insert assms, auto)"], ["", "lemma product_run_Some:\n  fixes \\<iota>\\<^sub>m \\<delta>\\<^sub>m w q\\<^sub>0 k\n  defines \"\\<rho> \\<equiv> run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m w\"\n  defines \"\\<rho>' \\<equiv> run (\\<delta>\\<^sub>m k) q\\<^sub>0 w\"\n  assumes \"\\<iota>\\<^sub>m k = Some q\\<^sub>0\"\n  shows \"\\<rho> i k = Some (\\<rho>' i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<rho> i k = Some (\\<rho>' i)", "by (induction i) (insert assms, auto)"], ["", "theorem finite_reach_product:\n  assumes \"finite (dom \\<iota>\\<^sub>m)\"\n  assumes \"\\<And>x. x \\<in> dom \\<iota>\\<^sub>m \\<Longrightarrow> finite (reach \\<Sigma> (\\<delta>\\<^sub>m x) (the (\\<iota>\\<^sub>m x)))\"\n  shows \"finite (reach \\<Sigma> (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (reach \\<Sigma> (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n       \\<iota>\\<^sub>m)", "using assms(1,2)"], ["proof (prove)\nusing this:\n  finite (dom \\<iota>\\<^sub>m)\n  ?x \\<in> dom \\<iota>\\<^sub>m \\<Longrightarrow>\n  finite (reach \\<Sigma> (\\<delta>\\<^sub>m ?x) (the (\\<iota>\\<^sub>m ?x)))\n\ngoal (1 subgoal):\n 1. finite\n     (reach \\<Sigma> (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n       \\<iota>\\<^sub>m)", "proof (induction \"dom \\<iota>\\<^sub>m\" arbitrary: \\<iota>\\<^sub>m)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<iota>\\<^sub>m.\n       \\<lbrakk>{} = dom \\<iota>\\<^sub>m;\n        \\<And>x.\n           x \\<in> dom \\<iota>\\<^sub>m \\<Longrightarrow>\n           finite\n            (reach \\<Sigma> (\\<delta>\\<^sub>m x)\n              (the (\\<iota>\\<^sub>m x)))\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (reach \\<Sigma>\n                            (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                            \\<iota>\\<^sub>m)\n 2. \\<And>x F \\<iota>\\<^sub>m.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>\\<iota>\\<^sub>m.\n           \\<lbrakk>F = dom \\<iota>\\<^sub>m;\n            \\<And>x.\n               x \\<in> dom \\<iota>\\<^sub>m \\<Longrightarrow>\n               finite\n                (reach \\<Sigma> (\\<delta>\\<^sub>m x)\n                  (the (\\<iota>\\<^sub>m x)))\\<rbrakk>\n           \\<Longrightarrow> finite\n                              (reach \\<Sigma>\n                                (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                                \\<iota>\\<^sub>m);\n        insert x F = dom \\<iota>\\<^sub>m;\n        \\<And>x.\n           x \\<in> dom \\<iota>\\<^sub>m \\<Longrightarrow>\n           finite\n            (reach \\<Sigma> (\\<delta>\\<^sub>m x)\n              (the (\\<iota>\\<^sub>m x)))\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (reach \\<Sigma>\n                            (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                            \\<iota>\\<^sub>m)", "case empty"], ["proof (state)\nthis:\n  {} = dom \\<iota>\\<^sub>m\n  ?x \\<in> dom \\<iota>\\<^sub>m \\<Longrightarrow>\n  finite (reach \\<Sigma> (\\<delta>\\<^sub>m ?x) (the (\\<iota>\\<^sub>m ?x)))\n\ngoal (2 subgoals):\n 1. \\<And>\\<iota>\\<^sub>m.\n       \\<lbrakk>{} = dom \\<iota>\\<^sub>m;\n        \\<And>x.\n           x \\<in> dom \\<iota>\\<^sub>m \\<Longrightarrow>\n           finite\n            (reach \\<Sigma> (\\<delta>\\<^sub>m x)\n              (the (\\<iota>\\<^sub>m x)))\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (reach \\<Sigma>\n                            (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                            \\<iota>\\<^sub>m)\n 2. \\<And>x F \\<iota>\\<^sub>m.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>\\<iota>\\<^sub>m.\n           \\<lbrakk>F = dom \\<iota>\\<^sub>m;\n            \\<And>x.\n               x \\<in> dom \\<iota>\\<^sub>m \\<Longrightarrow>\n               finite\n                (reach \\<Sigma> (\\<delta>\\<^sub>m x)\n                  (the (\\<iota>\\<^sub>m x)))\\<rbrakk>\n           \\<Longrightarrow> finite\n                              (reach \\<Sigma>\n                                (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                                \\<iota>\\<^sub>m);\n        insert x F = dom \\<iota>\\<^sub>m;\n        \\<And>x.\n           x \\<in> dom \\<iota>\\<^sub>m \\<Longrightarrow>\n           finite\n            (reach \\<Sigma> (\\<delta>\\<^sub>m x)\n              (the (\\<iota>\\<^sub>m x)))\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (reach \\<Sigma>\n                            (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                            \\<iota>\\<^sub>m)", "hence \"\\<iota>\\<^sub>m = Map.empty\""], ["proof (prove)\nusing this:\n  {} = dom \\<iota>\\<^sub>m\n  ?x \\<in> dom \\<iota>\\<^sub>m \\<Longrightarrow>\n  finite (reach \\<Sigma> (\\<delta>\\<^sub>m ?x) (the (\\<iota>\\<^sub>m ?x)))\n\ngoal (1 subgoal):\n 1. \\<iota>\\<^sub>m = Map.empty", "by auto"], ["proof (state)\nthis:\n  \\<iota>\\<^sub>m = Map.empty\n\ngoal (2 subgoals):\n 1. \\<And>\\<iota>\\<^sub>m.\n       \\<lbrakk>{} = dom \\<iota>\\<^sub>m;\n        \\<And>x.\n           x \\<in> dom \\<iota>\\<^sub>m \\<Longrightarrow>\n           finite\n            (reach \\<Sigma> (\\<delta>\\<^sub>m x)\n              (the (\\<iota>\\<^sub>m x)))\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (reach \\<Sigma>\n                            (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                            \\<iota>\\<^sub>m)\n 2. \\<And>x F \\<iota>\\<^sub>m.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>\\<iota>\\<^sub>m.\n           \\<lbrakk>F = dom \\<iota>\\<^sub>m;\n            \\<And>x.\n               x \\<in> dom \\<iota>\\<^sub>m \\<Longrightarrow>\n               finite\n                (reach \\<Sigma> (\\<delta>\\<^sub>m x)\n                  (the (\\<iota>\\<^sub>m x)))\\<rbrakk>\n           \\<Longrightarrow> finite\n                              (reach \\<Sigma>\n                                (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                                \\<iota>\\<^sub>m);\n        insert x F = dom \\<iota>\\<^sub>m;\n        \\<And>x.\n           x \\<in> dom \\<iota>\\<^sub>m \\<Longrightarrow>\n           finite\n            (reach \\<Sigma> (\\<delta>\\<^sub>m x)\n              (the (\\<iota>\\<^sub>m x)))\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (reach \\<Sigma>\n                            (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                            \\<iota>\\<^sub>m)", "hence \"\\<And>w i. run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m w i = (\\<lambda>x. None)\""], ["proof (prove)\nusing this:\n  \\<iota>\\<^sub>m = Map.empty\n\ngoal (1 subgoal):\n 1. \\<And>w i.\n       run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m w i =\n       Map.empty", "using product_run_None"], ["proof (prove)\nusing this:\n  \\<iota>\\<^sub>m = Map.empty\n  ?\\<iota>\\<^sub>m ?k = None \\<Longrightarrow>\n  run (\\<Delta>\\<^sub>\\<times> ?\\<delta>\\<^sub>m) ?\\<iota>\\<^sub>m ?w ?i\n   ?k =\n  None\n\ngoal (1 subgoal):\n 1. \\<And>w i.\n       run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m w i =\n       Map.empty", "by fast"], ["proof (state)\nthis:\n  run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m ?w ?i =\n  Map.empty\n\ngoal (2 subgoals):\n 1. \\<And>\\<iota>\\<^sub>m.\n       \\<lbrakk>{} = dom \\<iota>\\<^sub>m;\n        \\<And>x.\n           x \\<in> dom \\<iota>\\<^sub>m \\<Longrightarrow>\n           finite\n            (reach \\<Sigma> (\\<delta>\\<^sub>m x)\n              (the (\\<iota>\\<^sub>m x)))\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (reach \\<Sigma>\n                            (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                            \\<iota>\\<^sub>m)\n 2. \\<And>x F \\<iota>\\<^sub>m.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>\\<iota>\\<^sub>m.\n           \\<lbrakk>F = dom \\<iota>\\<^sub>m;\n            \\<And>x.\n               x \\<in> dom \\<iota>\\<^sub>m \\<Longrightarrow>\n               finite\n                (reach \\<Sigma> (\\<delta>\\<^sub>m x)\n                  (the (\\<iota>\\<^sub>m x)))\\<rbrakk>\n           \\<Longrightarrow> finite\n                              (reach \\<Sigma>\n                                (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                                \\<iota>\\<^sub>m);\n        insert x F = dom \\<iota>\\<^sub>m;\n        \\<And>x.\n           x \\<in> dom \\<iota>\\<^sub>m \\<Longrightarrow>\n           finite\n            (reach \\<Sigma> (\\<delta>\\<^sub>m x)\n              (the (\\<iota>\\<^sub>m x)))\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (reach \\<Sigma>\n                            (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                            \\<iota>\\<^sub>m)", "thus ?case"], ["proof (prove)\nusing this:\n  run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m ?w ?i =\n  Map.empty\n\ngoal (1 subgoal):\n 1. finite\n     (reach \\<Sigma> (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n       \\<iota>\\<^sub>m)", "unfolding reach_def"], ["proof (prove)\nusing this:\n  run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m ?w ?i =\n  Map.empty\n\ngoal (1 subgoal):\n 1. finite\n     {run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m w n |w\n      n. range w \\<subseteq> \\<Sigma>}", "by simp"], ["proof (state)\nthis:\n  finite\n   (reach \\<Sigma> (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n     \\<iota>\\<^sub>m)\n\ngoal (1 subgoal):\n 1. \\<And>x F \\<iota>\\<^sub>m.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>\\<iota>\\<^sub>m.\n           \\<lbrakk>F = dom \\<iota>\\<^sub>m;\n            \\<And>x.\n               x \\<in> dom \\<iota>\\<^sub>m \\<Longrightarrow>\n               finite\n                (reach \\<Sigma> (\\<delta>\\<^sub>m x)\n                  (the (\\<iota>\\<^sub>m x)))\\<rbrakk>\n           \\<Longrightarrow> finite\n                              (reach \\<Sigma>\n                                (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                                \\<iota>\\<^sub>m);\n        insert x F = dom \\<iota>\\<^sub>m;\n        \\<And>x.\n           x \\<in> dom \\<iota>\\<^sub>m \\<Longrightarrow>\n           finite\n            (reach \\<Sigma> (\\<delta>\\<^sub>m x)\n              (the (\\<iota>\\<^sub>m x)))\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (reach \\<Sigma>\n                            (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                            \\<iota>\\<^sub>m)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F \\<iota>\\<^sub>m.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>\\<iota>\\<^sub>m.\n           \\<lbrakk>F = dom \\<iota>\\<^sub>m;\n            \\<And>x.\n               x \\<in> dom \\<iota>\\<^sub>m \\<Longrightarrow>\n               finite\n                (reach \\<Sigma> (\\<delta>\\<^sub>m x)\n                  (the (\\<iota>\\<^sub>m x)))\\<rbrakk>\n           \\<Longrightarrow> finite\n                              (reach \\<Sigma>\n                                (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                                \\<iota>\\<^sub>m);\n        insert x F = dom \\<iota>\\<^sub>m;\n        \\<And>x.\n           x \\<in> dom \\<iota>\\<^sub>m \\<Longrightarrow>\n           finite\n            (reach \\<Sigma> (\\<delta>\\<^sub>m x)\n              (the (\\<iota>\\<^sub>m x)))\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (reach \\<Sigma>\n                            (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                            \\<iota>\\<^sub>m)", "case (insert k K)"], ["proof (state)\nthis:\n  finite K\n  k \\<notin> K\n  \\<lbrakk>K = dom ?\\<iota>\\<^sub>m;\n   \\<And>x.\n      x \\<in> dom ?\\<iota>\\<^sub>m \\<Longrightarrow>\n      finite\n       (reach \\<Sigma> (\\<delta>\\<^sub>m x)\n         (the (?\\<iota>\\<^sub>m x)))\\<rbrakk>\n  \\<Longrightarrow> finite\n                     (reach \\<Sigma>\n                       (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                       ?\\<iota>\\<^sub>m)\n  insert k K = dom \\<iota>\\<^sub>m\n  ?x \\<in> dom \\<iota>\\<^sub>m \\<Longrightarrow>\n  finite (reach \\<Sigma> (\\<delta>\\<^sub>m ?x) (the (\\<iota>\\<^sub>m ?x)))\n\ngoal (1 subgoal):\n 1. \\<And>x F \\<iota>\\<^sub>m.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>\\<iota>\\<^sub>m.\n           \\<lbrakk>F = dom \\<iota>\\<^sub>m;\n            \\<And>x.\n               x \\<in> dom \\<iota>\\<^sub>m \\<Longrightarrow>\n               finite\n                (reach \\<Sigma> (\\<delta>\\<^sub>m x)\n                  (the (\\<iota>\\<^sub>m x)))\\<rbrakk>\n           \\<Longrightarrow> finite\n                              (reach \\<Sigma>\n                                (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                                \\<iota>\\<^sub>m);\n        insert x F = dom \\<iota>\\<^sub>m;\n        \\<And>x.\n           x \\<in> dom \\<iota>\\<^sub>m \\<Longrightarrow>\n           finite\n            (reach \\<Sigma> (\\<delta>\\<^sub>m x)\n              (the (\\<iota>\\<^sub>m x)))\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (reach \\<Sigma>\n                            (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                            \\<iota>\\<^sub>m)", "define f where \"f = (\\<lambda>(q :: 'b, m :: 'a \\<rightharpoonup> 'b). m(k := Some q))\""], ["proof (state)\nthis:\n  f = (\\<lambda>(q, m). m(k \\<mapsto> q))\n\ngoal (1 subgoal):\n 1. \\<And>x F \\<iota>\\<^sub>m.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>\\<iota>\\<^sub>m.\n           \\<lbrakk>F = dom \\<iota>\\<^sub>m;\n            \\<And>x.\n               x \\<in> dom \\<iota>\\<^sub>m \\<Longrightarrow>\n               finite\n                (reach \\<Sigma> (\\<delta>\\<^sub>m x)\n                  (the (\\<iota>\\<^sub>m x)))\\<rbrakk>\n           \\<Longrightarrow> finite\n                              (reach \\<Sigma>\n                                (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                                \\<iota>\\<^sub>m);\n        insert x F = dom \\<iota>\\<^sub>m;\n        \\<And>x.\n           x \\<in> dom \\<iota>\\<^sub>m \\<Longrightarrow>\n           finite\n            (reach \\<Sigma> (\\<delta>\\<^sub>m x)\n              (the (\\<iota>\\<^sub>m x)))\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (reach \\<Sigma>\n                            (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                            \\<iota>\\<^sub>m)", "define Reach where \"Reach = (reach \\<Sigma> (\\<delta>\\<^sub>m k) (the (\\<iota>\\<^sub>m k))) \\<times> ((reach \\<Sigma> (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) (\\<iota>\\<^sub>m(k := None))))\""], ["proof (state)\nthis:\n  Reach =\n  reach \\<Sigma> (\\<delta>\\<^sub>m k) (the (\\<iota>\\<^sub>m k)) \\<times>\n  reach \\<Sigma> (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n   (\\<iota>\\<^sub>m(k := None))\n\ngoal (1 subgoal):\n 1. \\<And>x F \\<iota>\\<^sub>m.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>\\<iota>\\<^sub>m.\n           \\<lbrakk>F = dom \\<iota>\\<^sub>m;\n            \\<And>x.\n               x \\<in> dom \\<iota>\\<^sub>m \\<Longrightarrow>\n               finite\n                (reach \\<Sigma> (\\<delta>\\<^sub>m x)\n                  (the (\\<iota>\\<^sub>m x)))\\<rbrakk>\n           \\<Longrightarrow> finite\n                              (reach \\<Sigma>\n                                (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                                \\<iota>\\<^sub>m);\n        insert x F = dom \\<iota>\\<^sub>m;\n        \\<And>x.\n           x \\<in> dom \\<iota>\\<^sub>m \\<Longrightarrow>\n           finite\n            (reach \\<Sigma> (\\<delta>\\<^sub>m x)\n              (the (\\<iota>\\<^sub>m x)))\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (reach \\<Sigma>\n                            (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                            \\<iota>\\<^sub>m)", "have \"(reach \\<Sigma> (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m) \\<subseteq> f ` Reach\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach \\<Sigma> (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n     \\<iota>\\<^sub>m\n    \\<subseteq> f ` Reach", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> reach \\<Sigma> (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                \\<iota>\\<^sub>m \\<Longrightarrow>\n       x \\<in> f ` Reach", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> reach \\<Sigma> (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                \\<iota>\\<^sub>m \\<Longrightarrow>\n       x \\<in> f ` Reach", "assume \"x \\<in> reach \\<Sigma> (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m\""], ["proof (state)\nthis:\n  x \\<in> reach \\<Sigma> (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n           \\<iota>\\<^sub>m\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> reach \\<Sigma> (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                \\<iota>\\<^sub>m \\<Longrightarrow>\n       x \\<in> f ` Reach", "then"], ["proof (chain)\npicking this:\n  x \\<in> reach \\<Sigma> (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n           \\<iota>\\<^sub>m", "obtain w n where x_def: \"x = run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m w n\" and \"range w \\<subseteq> \\<Sigma>\""], ["proof (prove)\nusing this:\n  x \\<in> reach \\<Sigma> (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n           \\<iota>\\<^sub>m\n\ngoal (1 subgoal):\n 1. (\\<And>w n.\n        \\<lbrakk>x =\n                 run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                  \\<iota>\\<^sub>m w n;\n         range w \\<subseteq> \\<Sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding reach_def"], ["proof (prove)\nusing this:\n  x \\<in> {run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m w\n            n |\n           w n. range w \\<subseteq> \\<Sigma>}\n\ngoal (1 subgoal):\n 1. (\\<And>w n.\n        \\<lbrakk>x =\n                 run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                  \\<iota>\\<^sub>m w n;\n         range w \\<subseteq> \\<Sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x = run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m w n\n  range w \\<subseteq> \\<Sigma>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> reach \\<Sigma> (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                \\<iota>\\<^sub>m \\<Longrightarrow>\n       x \\<in> f ` Reach", "{"], ["proof (state)\nthis:\n  x = run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m w n\n  range w \\<subseteq> \\<Sigma>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> reach \\<Sigma> (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                \\<iota>\\<^sub>m \\<Longrightarrow>\n       x \\<in> f ` Reach", "fix k'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> reach \\<Sigma> (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                \\<iota>\\<^sub>m \\<Longrightarrow>\n       x \\<in> f ` Reach", "have \"k' \\<notin> dom \\<iota>\\<^sub>m \\<Longrightarrow> x k' = run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) (\\<iota>\\<^sub>m(k := None)) w n k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k' \\<notin> dom \\<iota>\\<^sub>m \\<Longrightarrow>\n    x k' =\n    run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n     (\\<iota>\\<^sub>m(k := None)) w n k'", "unfolding x_def dom_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. k' \\<notin> {a. \\<iota>\\<^sub>m a \\<noteq> None} \\<Longrightarrow>\n    run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m w n k' =\n    run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n     (\\<iota>\\<^sub>m(k := None)) w n k'", "using product_run_None[of _ _ \\<delta>\\<^sub>m]"], ["proof (prove)\nusing this:\n  ?\\<iota>\\<^sub>m ?k = None \\<Longrightarrow>\n  run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) ?\\<iota>\\<^sub>m ?w ?i ?k =\n  None\n\ngoal (1 subgoal):\n 1. k' \\<notin> {a. \\<iota>\\<^sub>m a \\<noteq> None} \\<Longrightarrow>\n    run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m w n k' =\n    run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n     (\\<iota>\\<^sub>m(k := None)) w n k'", "by simp"], ["proof (state)\nthis:\n  k' \\<notin> dom \\<iota>\\<^sub>m \\<Longrightarrow>\n  x k' =\n  run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n   (\\<iota>\\<^sub>m(k := None)) w n k'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> reach \\<Sigma> (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                \\<iota>\\<^sub>m \\<Longrightarrow>\n       x \\<in> f ` Reach", "moreover"], ["proof (state)\nthis:\n  k' \\<notin> dom \\<iota>\\<^sub>m \\<Longrightarrow>\n  x k' =\n  run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n   (\\<iota>\\<^sub>m(k := None)) w n k'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> reach \\<Sigma> (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                \\<iota>\\<^sub>m \\<Longrightarrow>\n       x \\<in> f ` Reach", "have \"k' \\<in> dom \\<iota>\\<^sub>m - {k} \\<Longrightarrow> x k' = run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) (\\<iota>\\<^sub>m(k := None)) w n k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k' \\<in> dom \\<iota>\\<^sub>m - {k} \\<Longrightarrow>\n    x k' =\n    run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n     (\\<iota>\\<^sub>m(k := None)) w n k'", "unfolding x_def dom_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. k' \\<in> {a. \\<iota>\\<^sub>m a \\<noteq> None} - {k} \\<Longrightarrow>\n    run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m w n k' =\n    run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n     (\\<iota>\\<^sub>m(k := None)) w n k'", "using product_run_Some[of _ _ _ \\<delta>\\<^sub>m]"], ["proof (prove)\nusing this:\n  ?\\<iota>\\<^sub>m ?k = Some ?q\\<^sub>0 \\<Longrightarrow>\n  run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) ?\\<iota>\\<^sub>m ?w ?i ?k =\n  Some (run (\\<delta>\\<^sub>m ?k) ?q\\<^sub>0 ?w ?i)\n\ngoal (1 subgoal):\n 1. k' \\<in> {a. \\<iota>\\<^sub>m a \\<noteq> None} - {k} \\<Longrightarrow>\n    run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m w n k' =\n    run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n     (\\<iota>\\<^sub>m(k := None)) w n k'", "by auto"], ["proof (state)\nthis:\n  k' \\<in> dom \\<iota>\\<^sub>m - {k} \\<Longrightarrow>\n  x k' =\n  run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n   (\\<iota>\\<^sub>m(k := None)) w n k'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> reach \\<Sigma> (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                \\<iota>\\<^sub>m \\<Longrightarrow>\n       x \\<in> f ` Reach", "ultimately"], ["proof (chain)\npicking this:\n  k' \\<notin> dom \\<iota>\\<^sub>m \\<Longrightarrow>\n  x k' =\n  run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n   (\\<iota>\\<^sub>m(k := None)) w n k'\n  k' \\<in> dom \\<iota>\\<^sub>m - {k} \\<Longrightarrow>\n  x k' =\n  run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n   (\\<iota>\\<^sub>m(k := None)) w n k'", "have \"k' \\<noteq> k \\<Longrightarrow> x k' = run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) (\\<iota>\\<^sub>m(k := None)) w n k'\""], ["proof (prove)\nusing this:\n  k' \\<notin> dom \\<iota>\\<^sub>m \\<Longrightarrow>\n  x k' =\n  run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n   (\\<iota>\\<^sub>m(k := None)) w n k'\n  k' \\<in> dom \\<iota>\\<^sub>m - {k} \\<Longrightarrow>\n  x k' =\n  run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n   (\\<iota>\\<^sub>m(k := None)) w n k'\n\ngoal (1 subgoal):\n 1. k' \\<noteq> k \\<Longrightarrow>\n    x k' =\n    run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n     (\\<iota>\\<^sub>m(k := None)) w n k'", "by blast"], ["proof (state)\nthis:\n  k' \\<noteq> k \\<Longrightarrow>\n  x k' =\n  run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n   (\\<iota>\\<^sub>m(k := None)) w n k'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> reach \\<Sigma> (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                \\<iota>\\<^sub>m \\<Longrightarrow>\n       x \\<in> f ` Reach", "}"], ["proof (state)\nthis:\n  ?k'2 \\<noteq> k \\<Longrightarrow>\n  x ?k'2 =\n  run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n   (\\<iota>\\<^sub>m(k := None)) w n ?k'2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> reach \\<Sigma> (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                \\<iota>\\<^sub>m \\<Longrightarrow>\n       x \\<in> f ` Reach", "hence \"x(k := None) = run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) (\\<iota>\\<^sub>m(k := None)) w n\""], ["proof (prove)\nusing this:\n  ?k'2 \\<noteq> k \\<Longrightarrow>\n  x ?k'2 =\n  run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n   (\\<iota>\\<^sub>m(k := None)) w n ?k'2\n\ngoal (1 subgoal):\n 1. x(k := None) =\n    run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n     (\\<iota>\\<^sub>m(k := None)) w n", "using product_run_None[of _ _ \\<delta>\\<^sub>m]"], ["proof (prove)\nusing this:\n  ?k'2 \\<noteq> k \\<Longrightarrow>\n  x ?k'2 =\n  run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n   (\\<iota>\\<^sub>m(k := None)) w n ?k'2\n  ?\\<iota>\\<^sub>m ?k = None \\<Longrightarrow>\n  run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) ?\\<iota>\\<^sub>m ?w ?i ?k =\n  None\n\ngoal (1 subgoal):\n 1. x(k := None) =\n    run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n     (\\<iota>\\<^sub>m(k := None)) w n", "by auto"], ["proof (state)\nthis:\n  x(k := None) =\n  run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n   (\\<iota>\\<^sub>m(k := None)) w n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> reach \\<Sigma> (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                \\<iota>\\<^sub>m \\<Longrightarrow>\n       x \\<in> f ` Reach", "moreover"], ["proof (state)\nthis:\n  x(k := None) =\n  run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n   (\\<iota>\\<^sub>m(k := None)) w n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> reach \\<Sigma> (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                \\<iota>\\<^sub>m \\<Longrightarrow>\n       x \\<in> f ` Reach", "have \"x k = Some (run (\\<delta>\\<^sub>m k) (the (\\<iota>\\<^sub>m k)) w n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x k = Some (run (\\<delta>\\<^sub>m k) (the (\\<iota>\\<^sub>m k)) w n)", "unfolding x_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m w n k =\n    Some (run (\\<delta>\\<^sub>m k) (the (\\<iota>\\<^sub>m k)) w n)", "using product_run_Some[of \\<iota>\\<^sub>m k _ \\<delta>\\<^sub>m] insert.hyps(4)"], ["proof (prove)\nusing this:\n  \\<iota>\\<^sub>m k = Some ?q\\<^sub>0 \\<Longrightarrow>\n  run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m ?w ?i k =\n  Some (run (\\<delta>\\<^sub>m k) ?q\\<^sub>0 ?w ?i)\n  insert k K = dom \\<iota>\\<^sub>m\n\ngoal (1 subgoal):\n 1. run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m w n k =\n    Some (run (\\<delta>\\<^sub>m k) (the (\\<iota>\\<^sub>m k)) w n)", "by force"], ["proof (state)\nthis:\n  x k = Some (run (\\<delta>\\<^sub>m k) (the (\\<iota>\\<^sub>m k)) w n)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> reach \\<Sigma> (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                \\<iota>\\<^sub>m \\<Longrightarrow>\n       x \\<in> f ` Reach", "ultimately"], ["proof (chain)\npicking this:\n  x(k := None) =\n  run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n   (\\<iota>\\<^sub>m(k := None)) w n\n  x k = Some (run (\\<delta>\\<^sub>m k) (the (\\<iota>\\<^sub>m k)) w n)", "have \"(the (x k), x(k := None)) \\<in> Reach\""], ["proof (prove)\nusing this:\n  x(k := None) =\n  run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n   (\\<iota>\\<^sub>m(k := None)) w n\n  x k = Some (run (\\<delta>\\<^sub>m k) (the (\\<iota>\\<^sub>m k)) w n)\n\ngoal (1 subgoal):\n 1. (the (x k), x(k := None)) \\<in> Reach", "unfolding Reach_def reach_def"], ["proof (prove)\nusing this:\n  x(k := None) =\n  run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n   (\\<iota>\\<^sub>m(k := None)) w n\n  x k = Some (run (\\<delta>\\<^sub>m k) (the (\\<iota>\\<^sub>m k)) w n)\n\ngoal (1 subgoal):\n 1. (the (x k), x(k := None))\n    \\<in> {run (\\<delta>\\<^sub>m k) (the (\\<iota>\\<^sub>m k)) w n |w n.\n           range w \\<subseteq> \\<Sigma>} \\<times>\n          {run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n            (\\<iota>\\<^sub>m(k := None)) w n |\n           w n. range w \\<subseteq> \\<Sigma>}", "using \\<open>range w \\<subseteq> \\<Sigma>\\<close>"], ["proof (prove)\nusing this:\n  x(k := None) =\n  run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n   (\\<iota>\\<^sub>m(k := None)) w n\n  x k = Some (run (\\<delta>\\<^sub>m k) (the (\\<iota>\\<^sub>m k)) w n)\n  range w \\<subseteq> \\<Sigma>\n\ngoal (1 subgoal):\n 1. (the (x k), x(k := None))\n    \\<in> {run (\\<delta>\\<^sub>m k) (the (\\<iota>\\<^sub>m k)) w n |w n.\n           range w \\<subseteq> \\<Sigma>} \\<times>\n          {run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n            (\\<iota>\\<^sub>m(k := None)) w n |\n           w n. range w \\<subseteq> \\<Sigma>}", "by auto"], ["proof (state)\nthis:\n  (the (x k), x(k := None)) \\<in> Reach\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> reach \\<Sigma> (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                \\<iota>\\<^sub>m \\<Longrightarrow>\n       x \\<in> f ` Reach", "moreover"], ["proof (state)\nthis:\n  (the (x k), x(k := None)) \\<in> Reach\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> reach \\<Sigma> (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                \\<iota>\\<^sub>m \\<Longrightarrow>\n       x \\<in> f ` Reach", "have \"x = f (the (x k), x(k := None))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = f (the (x k), x(k := None))", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x =\n    (case (the (x k), x(k := None)) of\n     (q, m) \\<Rightarrow> m(k \\<mapsto> q))", "using \\<open>x k = Some (run (\\<delta>\\<^sub>m k) (the (\\<iota>\\<^sub>m k)) w n)\\<close>"], ["proof (prove)\nusing this:\n  x k = Some (run (\\<delta>\\<^sub>m k) (the (\\<iota>\\<^sub>m k)) w n)\n\ngoal (1 subgoal):\n 1. x =\n    (case (the (x k), x(k := None)) of\n     (q, m) \\<Rightarrow> m(k \\<mapsto> q))", "by auto"], ["proof (state)\nthis:\n  x = f (the (x k), x(k := None))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> reach \\<Sigma> (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                \\<iota>\\<^sub>m \\<Longrightarrow>\n       x \\<in> f ` Reach", "ultimately"], ["proof (chain)\npicking this:\n  (the (x k), x(k := None)) \\<in> Reach\n  x = f (the (x k), x(k := None))", "show \"x \\<in> f ` Reach\""], ["proof (prove)\nusing this:\n  (the (x k), x(k := None)) \\<in> Reach\n  x = f (the (x k), x(k := None))\n\ngoal (1 subgoal):\n 1. x \\<in> f ` Reach", "by simp"], ["proof (state)\nthis:\n  x \\<in> f ` Reach\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  reach \\<Sigma> (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m\n  \\<subseteq> f ` Reach\n\ngoal (1 subgoal):\n 1. \\<And>x F \\<iota>\\<^sub>m.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>\\<iota>\\<^sub>m.\n           \\<lbrakk>F = dom \\<iota>\\<^sub>m;\n            \\<And>x.\n               x \\<in> dom \\<iota>\\<^sub>m \\<Longrightarrow>\n               finite\n                (reach \\<Sigma> (\\<delta>\\<^sub>m x)\n                  (the (\\<iota>\\<^sub>m x)))\\<rbrakk>\n           \\<Longrightarrow> finite\n                              (reach \\<Sigma>\n                                (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                                \\<iota>\\<^sub>m);\n        insert x F = dom \\<iota>\\<^sub>m;\n        \\<And>x.\n           x \\<in> dom \\<iota>\\<^sub>m \\<Longrightarrow>\n           finite\n            (reach \\<Sigma> (\\<delta>\\<^sub>m x)\n              (the (\\<iota>\\<^sub>m x)))\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (reach \\<Sigma>\n                            (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                            \\<iota>\\<^sub>m)", "moreover"], ["proof (state)\nthis:\n  reach \\<Sigma> (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m\n  \\<subseteq> f ` Reach\n\ngoal (1 subgoal):\n 1. \\<And>x F \\<iota>\\<^sub>m.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>\\<iota>\\<^sub>m.\n           \\<lbrakk>F = dom \\<iota>\\<^sub>m;\n            \\<And>x.\n               x \\<in> dom \\<iota>\\<^sub>m \\<Longrightarrow>\n               finite\n                (reach \\<Sigma> (\\<delta>\\<^sub>m x)\n                  (the (\\<iota>\\<^sub>m x)))\\<rbrakk>\n           \\<Longrightarrow> finite\n                              (reach \\<Sigma>\n                                (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                                \\<iota>\\<^sub>m);\n        insert x F = dom \\<iota>\\<^sub>m;\n        \\<And>x.\n           x \\<in> dom \\<iota>\\<^sub>m \\<Longrightarrow>\n           finite\n            (reach \\<Sigma> (\\<delta>\\<^sub>m x)\n              (the (\\<iota>\\<^sub>m x)))\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (reach \\<Sigma>\n                            (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                            \\<iota>\\<^sub>m)", "have \"finite (reach \\<Sigma> (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) (\\<iota>\\<^sub>m (k := None)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (reach \\<Sigma> (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n       (\\<iota>\\<^sub>m(k := None)))", "using insert insert(3)[of \"\\<iota>\\<^sub>m (k:=None)\"]"], ["proof (prove)\nusing this:\n  finite K\n  k \\<notin> K\n  \\<lbrakk>K = dom ?\\<iota>\\<^sub>m;\n   \\<And>x.\n      x \\<in> dom ?\\<iota>\\<^sub>m \\<Longrightarrow>\n      finite\n       (reach \\<Sigma> (\\<delta>\\<^sub>m x)\n         (the (?\\<iota>\\<^sub>m x)))\\<rbrakk>\n  \\<Longrightarrow> finite\n                     (reach \\<Sigma>\n                       (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                       ?\\<iota>\\<^sub>m)\n  insert k K = dom \\<iota>\\<^sub>m\n  ?x \\<in> dom \\<iota>\\<^sub>m \\<Longrightarrow>\n  finite (reach \\<Sigma> (\\<delta>\\<^sub>m ?x) (the (\\<iota>\\<^sub>m ?x)))\n  \\<lbrakk>K = dom (\\<iota>\\<^sub>m(k := None));\n   \\<And>x.\n      x \\<in> dom (\\<iota>\\<^sub>m(k := None)) \\<Longrightarrow>\n      finite\n       (reach \\<Sigma> (\\<delta>\\<^sub>m x)\n         (the ((\\<iota>\\<^sub>m(k := None)) x)))\\<rbrakk>\n  \\<Longrightarrow> finite\n                     (reach \\<Sigma>\n                       (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                       (\\<iota>\\<^sub>m(k := None)))\n\ngoal (1 subgoal):\n 1. finite\n     (reach \\<Sigma> (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n       (\\<iota>\\<^sub>m(k := None)))", "by auto"], ["proof (state)\nthis:\n  finite\n   (reach \\<Sigma> (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n     (\\<iota>\\<^sub>m(k := None)))\n\ngoal (1 subgoal):\n 1. \\<And>x F \\<iota>\\<^sub>m.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>\\<iota>\\<^sub>m.\n           \\<lbrakk>F = dom \\<iota>\\<^sub>m;\n            \\<And>x.\n               x \\<in> dom \\<iota>\\<^sub>m \\<Longrightarrow>\n               finite\n                (reach \\<Sigma> (\\<delta>\\<^sub>m x)\n                  (the (\\<iota>\\<^sub>m x)))\\<rbrakk>\n           \\<Longrightarrow> finite\n                              (reach \\<Sigma>\n                                (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                                \\<iota>\\<^sub>m);\n        insert x F = dom \\<iota>\\<^sub>m;\n        \\<And>x.\n           x \\<in> dom \\<iota>\\<^sub>m \\<Longrightarrow>\n           finite\n            (reach \\<Sigma> (\\<delta>\\<^sub>m x)\n              (the (\\<iota>\\<^sub>m x)))\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (reach \\<Sigma>\n                            (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                            \\<iota>\\<^sub>m)", "hence \"finite Reach\""], ["proof (prove)\nusing this:\n  finite\n   (reach \\<Sigma> (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n     (\\<iota>\\<^sub>m(k := None)))\n\ngoal (1 subgoal):\n 1. finite Reach", "using insert Reach_def"], ["proof (prove)\nusing this:\n  finite\n   (reach \\<Sigma> (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n     (\\<iota>\\<^sub>m(k := None)))\n  finite K\n  k \\<notin> K\n  \\<lbrakk>K = dom ?\\<iota>\\<^sub>m;\n   \\<And>x.\n      x \\<in> dom ?\\<iota>\\<^sub>m \\<Longrightarrow>\n      finite\n       (reach \\<Sigma> (\\<delta>\\<^sub>m x)\n         (the (?\\<iota>\\<^sub>m x)))\\<rbrakk>\n  \\<Longrightarrow> finite\n                     (reach \\<Sigma>\n                       (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                       ?\\<iota>\\<^sub>m)\n  insert k K = dom \\<iota>\\<^sub>m\n  ?x \\<in> dom \\<iota>\\<^sub>m \\<Longrightarrow>\n  finite (reach \\<Sigma> (\\<delta>\\<^sub>m ?x) (the (\\<iota>\\<^sub>m ?x)))\n  Reach =\n  reach \\<Sigma> (\\<delta>\\<^sub>m k) (the (\\<iota>\\<^sub>m k)) \\<times>\n  reach \\<Sigma> (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n   (\\<iota>\\<^sub>m(k := None))\n\ngoal (1 subgoal):\n 1. finite Reach", "by blast"], ["proof (state)\nthis:\n  finite Reach\n\ngoal (1 subgoal):\n 1. \\<And>x F \\<iota>\\<^sub>m.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>\\<iota>\\<^sub>m.\n           \\<lbrakk>F = dom \\<iota>\\<^sub>m;\n            \\<And>x.\n               x \\<in> dom \\<iota>\\<^sub>m \\<Longrightarrow>\n               finite\n                (reach \\<Sigma> (\\<delta>\\<^sub>m x)\n                  (the (\\<iota>\\<^sub>m x)))\\<rbrakk>\n           \\<Longrightarrow> finite\n                              (reach \\<Sigma>\n                                (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                                \\<iota>\\<^sub>m);\n        insert x F = dom \\<iota>\\<^sub>m;\n        \\<And>x.\n           x \\<in> dom \\<iota>\\<^sub>m \\<Longrightarrow>\n           finite\n            (reach \\<Sigma> (\\<delta>\\<^sub>m x)\n              (the (\\<iota>\\<^sub>m x)))\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (reach \\<Sigma>\n                            (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                            \\<iota>\\<^sub>m)", "hence \"finite (f ` Reach)\""], ["proof (prove)\nusing this:\n  finite Reach\n\ngoal (1 subgoal):\n 1. finite (f ` Reach)", ".."], ["proof (state)\nthis:\n  finite (f ` Reach)\n\ngoal (1 subgoal):\n 1. \\<And>x F \\<iota>\\<^sub>m.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>\\<iota>\\<^sub>m.\n           \\<lbrakk>F = dom \\<iota>\\<^sub>m;\n            \\<And>x.\n               x \\<in> dom \\<iota>\\<^sub>m \\<Longrightarrow>\n               finite\n                (reach \\<Sigma> (\\<delta>\\<^sub>m x)\n                  (the (\\<iota>\\<^sub>m x)))\\<rbrakk>\n           \\<Longrightarrow> finite\n                              (reach \\<Sigma>\n                                (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                                \\<iota>\\<^sub>m);\n        insert x F = dom \\<iota>\\<^sub>m;\n        \\<And>x.\n           x \\<in> dom \\<iota>\\<^sub>m \\<Longrightarrow>\n           finite\n            (reach \\<Sigma> (\\<delta>\\<^sub>m x)\n              (the (\\<iota>\\<^sub>m x)))\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (reach \\<Sigma>\n                            (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                            \\<iota>\\<^sub>m)", "ultimately"], ["proof (chain)\npicking this:\n  reach \\<Sigma> (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m\n  \\<subseteq> f ` Reach\n  finite (f ` Reach)", "show ?case"], ["proof (prove)\nusing this:\n  reach \\<Sigma> (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m\n  \\<subseteq> f ` Reach\n  finite (f ` Reach)\n\ngoal (1 subgoal):\n 1. finite\n     (reach \\<Sigma> (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n       \\<iota>\\<^sub>m)", "by (rule finite_subset)"], ["proof (state)\nthis:\n  finite\n   (reach \\<Sigma> (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n     \\<iota>\\<^sub>m)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Simple Product Construction Helper Functions and Lemmas\\<close>"], ["", "fun embed_transition_fst :: \"('a, 'c) transition \\<Rightarrow> ('a \\<times> 'b, 'c) transition set\"\nwhere\n  \"embed_transition_fst (q, \\<nu>, q') = {((q, x), \\<nu>, (q', y)) | x y. True}\""], ["", "fun embed_transition_snd :: \"('b, 'c) transition \\<Rightarrow> ('a \\<times> 'b, 'c) transition set\"\nwhere\n  \"embed_transition_snd (q, \\<nu>, q') = {((x, q), \\<nu>, (y, q')) | x y. True}\""], ["", "lemma embed_transition_snd_unfold:\n  \"embed_transition_snd t = {((x, fst t), fst (snd t), (y, snd (snd t))) | x y. True}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. embed_transition_snd t =\n    {((x, fst t), fst (snd t), y, snd (snd t)) |x y. True}", "unfolding embed_transition_snd.simps[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. embed_transition_snd t =\n    embed_transition_snd (fst t, fst (snd t), snd (snd t))", "by simp"], ["", "fun project_transition_fst :: \"('a \\<times> 'b, 'c) transition \\<Rightarrow> ('a, 'c) transition\" \nwhere\n  \"project_transition_fst (x, \\<nu>, y) = (fst x, \\<nu>, fst y)\""], ["", "fun project_transition_snd :: \"('a \\<times> 'b, 'c) transition \\<Rightarrow> ('b, 'c) transition\" \nwhere\n  \"project_transition_snd (x, \\<nu>, y) = (snd x, \\<nu>, snd y)\""], ["", "lemma\n  fixes \\<delta>\\<^sub>1 \\<delta>\\<^sub>2 w q\\<^sub>1 q\\<^sub>2\n  defines \"\\<rho> \\<equiv> run\\<^sub>t (\\<delta>\\<^sub>1 \\<times> \\<delta>\\<^sub>2) (q\\<^sub>1, q\\<^sub>2) w\"\n  defines \"\\<rho>\\<^sub>1 \\<equiv> run\\<^sub>t \\<delta>\\<^sub>1 q\\<^sub>1 w\"\n  defines \"\\<rho>\\<^sub>2 \\<equiv> run\\<^sub>t \\<delta>\\<^sub>2 q\\<^sub>2 w\"\n  shows product_run_project_fst: \"project_transition_fst (\\<rho> i) = \\<rho>\\<^sub>1 i\" \n    and product_run_project_snd: \"project_transition_snd (\\<rho> i) = \\<rho>\\<^sub>2 i\"\n    and product_run_embed_fst: \"\\<rho> i \\<in> embed_transition_fst (\\<rho>\\<^sub>1 i)\"\n    and product_run_embed_snd: \"\\<rho> i \\<in> embed_transition_snd (\\<rho>\\<^sub>2 i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (project_transition_fst (\\<rho> i) = \\<rho>\\<^sub>1 i &&&\n     project_transition_snd (\\<rho> i) = \\<rho>\\<^sub>2 i) &&&\n    \\<rho> i \\<in> embed_transition_fst (\\<rho>\\<^sub>1 i) &&&\n    \\<rho> i \\<in> embed_transition_snd (\\<rho>\\<^sub>2 i)", "unfolding assms run\\<^sub>t.simps simple_product_run"], ["proof (prove)\ngoal (1 subgoal):\n 1. (project_transition_fst\n      ((run \\<delta>\\<^sub>1 q\\<^sub>1 w i,\n        run \\<delta>\\<^sub>2 q\\<^sub>2 w i),\n       w i, run \\<delta>\\<^sub>1 q\\<^sub>1 w (Suc i),\n       run \\<delta>\\<^sub>2 q\\<^sub>2 w (Suc i)) =\n     (run \\<delta>\\<^sub>1 q\\<^sub>1 w i, w i,\n      run \\<delta>\\<^sub>1 q\\<^sub>1 w (Suc i)) &&&\n     project_transition_snd\n      ((run \\<delta>\\<^sub>1 q\\<^sub>1 w i,\n        run \\<delta>\\<^sub>2 q\\<^sub>2 w i),\n       w i, run \\<delta>\\<^sub>1 q\\<^sub>1 w (Suc i),\n       run \\<delta>\\<^sub>2 q\\<^sub>2 w (Suc i)) =\n     (run \\<delta>\\<^sub>2 q\\<^sub>2 w i, w i,\n      run \\<delta>\\<^sub>2 q\\<^sub>2 w (Suc i))) &&&\n    ((run \\<delta>\\<^sub>1 q\\<^sub>1 w i,\n      run \\<delta>\\<^sub>2 q\\<^sub>2 w i),\n     w i, run \\<delta>\\<^sub>1 q\\<^sub>1 w (Suc i),\n     run \\<delta>\\<^sub>2 q\\<^sub>2 w (Suc i))\n    \\<in> embed_transition_fst\n           (run \\<delta>\\<^sub>1 q\\<^sub>1 w i, w i,\n            run \\<delta>\\<^sub>1 q\\<^sub>1 w (Suc i)) &&&\n    ((run \\<delta>\\<^sub>1 q\\<^sub>1 w i,\n      run \\<delta>\\<^sub>2 q\\<^sub>2 w i),\n     w i, run \\<delta>\\<^sub>1 q\\<^sub>1 w (Suc i),\n     run \\<delta>\\<^sub>2 q\\<^sub>2 w (Suc i))\n    \\<in> embed_transition_snd\n           (run \\<delta>\\<^sub>2 q\\<^sub>2 w i, w i,\n            run \\<delta>\\<^sub>2 q\\<^sub>2 w (Suc i))", "by simp_all"], ["", "lemma \n  fixes \\<delta>\\<^sub>1 \\<delta>\\<^sub>2 w q\\<^sub>1 q\\<^sub>2\n  defines \"\\<rho> \\<equiv> run\\<^sub>t (\\<delta>\\<^sub>1 \\<times> \\<delta>\\<^sub>2) (q\\<^sub>1, q\\<^sub>2) w\"\n  defines \"\\<rho>\\<^sub>1 \\<equiv> run\\<^sub>t \\<delta>\\<^sub>1 q\\<^sub>1 w\"\n  defines \"\\<rho>\\<^sub>2 \\<equiv> run\\<^sub>t \\<delta>\\<^sub>2 q\\<^sub>2 w\"\n  assumes \"finite (range \\<rho>)\"\n  shows product_run_finite_fst: \"finite (range \\<rho>\\<^sub>1)\"\n    and product_run_finite_snd: \"finite (range \\<rho>\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (range \\<rho>\\<^sub>1) &&& finite (range \\<rho>\\<^sub>2)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (range \\<rho>\\<^sub>1)\n 2. finite (range \\<rho>\\<^sub>2)", "have \"\\<And>k. project_transition_fst (\\<rho> k) = \\<rho>\\<^sub>1 k\"\n    and \"\\<And>k. project_transition_snd (\\<rho> k) = \\<rho>\\<^sub>2 k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k. project_transition_fst (\\<rho> k) = \\<rho>\\<^sub>1 k) &&&\n    (\\<And>k. project_transition_snd (\\<rho> k) = \\<rho>\\<^sub>2 k)", "unfolding assms product_run_project_fst product_run_project_snd"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        run\\<^sub>t \\<delta>\\<^sub>1 q\\<^sub>1 w k =\n        run\\<^sub>t \\<delta>\\<^sub>1 q\\<^sub>1 w k) &&&\n    (\\<And>k.\n        run\\<^sub>t \\<delta>\\<^sub>2 q\\<^sub>2 w k =\n        run\\<^sub>t \\<delta>\\<^sub>2 q\\<^sub>2 w k)", "by simp+"], ["proof (state)\nthis:\n  project_transition_fst (\\<rho> ?k) = \\<rho>\\<^sub>1 ?k\n  project_transition_snd (\\<rho> ?k) = \\<rho>\\<^sub>2 ?k\n\ngoal (2 subgoals):\n 1. finite (range \\<rho>\\<^sub>1)\n 2. finite (range \\<rho>\\<^sub>2)", "hence \"project_transition_fst ` range \\<rho> = range \\<rho>\\<^sub>1\"\n    and \"project_transition_snd ` range \\<rho> = range \\<rho>\\<^sub>2\""], ["proof (prove)\nusing this:\n  project_transition_fst (\\<rho> ?k) = \\<rho>\\<^sub>1 ?k\n  project_transition_snd (\\<rho> ?k) = \\<rho>\\<^sub>2 ?k\n\ngoal (1 subgoal):\n 1. project_transition_fst ` range \\<rho> = range \\<rho>\\<^sub>1 &&&\n    project_transition_snd ` range \\<rho> = range \\<rho>\\<^sub>2", "using range_composition[symmetric, of project_transition_fst \\<rho>]"], ["proof (prove)\nusing this:\n  project_transition_fst (\\<rho> ?k) = \\<rho>\\<^sub>1 ?k\n  project_transition_snd (\\<rho> ?k) = \\<rho>\\<^sub>2 ?k\n  project_transition_fst ` range \\<rho> =\n  range (\\<lambda>x. project_transition_fst (\\<rho> x))\n\ngoal (1 subgoal):\n 1. project_transition_fst ` range \\<rho> = range \\<rho>\\<^sub>1 &&&\n    project_transition_snd ` range \\<rho> = range \\<rho>\\<^sub>2", "using range_composition[symmetric, of project_transition_snd \\<rho>]"], ["proof (prove)\nusing this:\n  project_transition_fst (\\<rho> ?k) = \\<rho>\\<^sub>1 ?k\n  project_transition_snd (\\<rho> ?k) = \\<rho>\\<^sub>2 ?k\n  project_transition_fst ` range \\<rho> =\n  range (\\<lambda>x. project_transition_fst (\\<rho> x))\n  project_transition_snd ` range \\<rho> =\n  range (\\<lambda>x. project_transition_snd (\\<rho> x))\n\ngoal (1 subgoal):\n 1. project_transition_fst ` range \\<rho> = range \\<rho>\\<^sub>1 &&&\n    project_transition_snd ` range \\<rho> = range \\<rho>\\<^sub>2", "by presburger+"], ["proof (state)\nthis:\n  project_transition_fst ` range \\<rho> = range \\<rho>\\<^sub>1\n  project_transition_snd ` range \\<rho> = range \\<rho>\\<^sub>2\n\ngoal (2 subgoals):\n 1. finite (range \\<rho>\\<^sub>1)\n 2. finite (range \\<rho>\\<^sub>2)", "thus \"finite (range \\<rho>\\<^sub>1)\" and \"finite (range \\<rho>\\<^sub>2)\""], ["proof (prove)\nusing this:\n  project_transition_fst ` range \\<rho> = range \\<rho>\\<^sub>1\n  project_transition_snd ` range \\<rho> = range \\<rho>\\<^sub>2\n\ngoal (1 subgoal):\n 1. finite (range \\<rho>\\<^sub>1) &&& finite (range \\<rho>\\<^sub>2)", "using assms finite_imageI"], ["proof (prove)\nusing this:\n  project_transition_fst ` range \\<rho> = range \\<rho>\\<^sub>1\n  project_transition_snd ` range \\<rho> = range \\<rho>\\<^sub>2\n  \\<rho> \\<equiv>\n  run\\<^sub>t \\<delta>\\<^sub>1 \\<times> \\<delta>\\<^sub>2\n   (q\\<^sub>1, q\\<^sub>2) w\n  \\<rho>\\<^sub>1 \\<equiv> run\\<^sub>t \\<delta>\\<^sub>1 q\\<^sub>1 w\n  \\<rho>\\<^sub>2 \\<equiv> run\\<^sub>t \\<delta>\\<^sub>2 q\\<^sub>2 w\n  finite (range \\<rho>)\n  finite ?F \\<Longrightarrow> finite (?h ` ?F)\n\ngoal (1 subgoal):\n 1. finite (range \\<rho>\\<^sub>1) &&& finite (range \\<rho>\\<^sub>2)", "by metis+"], ["proof (state)\nthis:\n  finite (range \\<rho>\\<^sub>1)\n  finite (range \\<rho>\\<^sub>2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \n  fixes \\<delta>\\<^sub>1 \\<delta>\\<^sub>2 w q\\<^sub>1 q\\<^sub>2\n  defines \"\\<rho> \\<equiv> run\\<^sub>t (\\<delta>\\<^sub>1 \\<times> \\<delta>\\<^sub>2) (q\\<^sub>1, q\\<^sub>2) w\"\n  defines \"\\<rho>\\<^sub>1 \\<equiv> run\\<^sub>t \\<delta>\\<^sub>1 q\\<^sub>1 w\"\n  assumes \"finite (range \\<rho>)\"\n  shows product_run_project_limit_fst: \"project_transition_fst ` limit \\<rho> = limit \\<rho>\\<^sub>1\"\n    and product_run_embed_limit_fst: \"limit \\<rho> \\<subseteq> \\<Union> (embed_transition_fst ` (limit \\<rho>\\<^sub>1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. project_transition_fst ` limit \\<rho> = limit \\<rho>\\<^sub>1 &&&\n    limit \\<rho>\n    \\<subseteq> \\<Union> (embed_transition_fst ` limit \\<rho>\\<^sub>1)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. project_transition_fst ` limit \\<rho> = limit \\<rho>\\<^sub>1\n 2. limit \\<rho>\n    \\<subseteq> \\<Union> (embed_transition_fst ` limit \\<rho>\\<^sub>1)", "have \"finite (range \\<rho>\\<^sub>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (range \\<rho>\\<^sub>1)", "using assms product_run_finite_fst"], ["proof (prove)\nusing this:\n  \\<rho> \\<equiv>\n  run\\<^sub>t \\<delta>\\<^sub>1 \\<times> \\<delta>\\<^sub>2\n   (q\\<^sub>1, q\\<^sub>2) w\n  \\<rho>\\<^sub>1 \\<equiv> run\\<^sub>t \\<delta>\\<^sub>1 q\\<^sub>1 w\n  finite (range \\<rho>)\n  finite\n   (range\n     (run\\<^sub>t ?\\<delta>\\<^sub>1 \\<times> ?\\<delta>\\<^sub>2\n       (?q\\<^sub>1, ?q\\<^sub>2) ?w)) \\<Longrightarrow>\n  finite (range (run\\<^sub>t ?\\<delta>\\<^sub>1 ?q\\<^sub>1 ?w))\n\ngoal (1 subgoal):\n 1. finite (range \\<rho>\\<^sub>1)", "by metis"], ["proof (state)\nthis:\n  finite (range \\<rho>\\<^sub>1)\n\ngoal (2 subgoals):\n 1. project_transition_fst ` limit \\<rho> = limit \\<rho>\\<^sub>1\n 2. limit \\<rho>\n    \\<subseteq> \\<Union> (embed_transition_fst ` limit \\<rho>\\<^sub>1)", "then"], ["proof (chain)\npicking this:\n  finite (range \\<rho>\\<^sub>1)", "obtain i where \"limit \\<rho> = range (suffix i \\<rho>)\" and \"limit \\<rho>\\<^sub>1 = range (suffix i \\<rho>\\<^sub>1)\""], ["proof (prove)\nusing this:\n  finite (range \\<rho>\\<^sub>1)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>limit \\<rho> = range (suffix i \\<rho>);\n         limit \\<rho>\\<^sub>1 = range (suffix i \\<rho>\\<^sub>1)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using common_range_limit assms"], ["proof (prove)\nusing this:\n  finite (range \\<rho>\\<^sub>1)\n  \\<lbrakk>finite (range ?x); finite (range ?y);\n   \\<And>i.\n      \\<lbrakk>limit ?x = range (suffix i ?x);\n       limit ?y = range (suffix i ?y)\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  \\<rho> \\<equiv>\n  run\\<^sub>t \\<delta>\\<^sub>1 \\<times> \\<delta>\\<^sub>2\n   (q\\<^sub>1, q\\<^sub>2) w\n  \\<rho>\\<^sub>1 \\<equiv> run\\<^sub>t \\<delta>\\<^sub>1 q\\<^sub>1 w\n  finite (range \\<rho>)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>limit \\<rho> = range (suffix i \\<rho>);\n         limit \\<rho>\\<^sub>1 = range (suffix i \\<rho>\\<^sub>1)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  limit \\<rho> = range (suffix i \\<rho>)\n  limit \\<rho>\\<^sub>1 = range (suffix i \\<rho>\\<^sub>1)\n\ngoal (2 subgoals):\n 1. project_transition_fst ` limit \\<rho> = limit \\<rho>\\<^sub>1\n 2. limit \\<rho>\n    \\<subseteq> \\<Union> (embed_transition_fst ` limit \\<rho>\\<^sub>1)", "moreover"], ["proof (state)\nthis:\n  limit \\<rho> = range (suffix i \\<rho>)\n  limit \\<rho>\\<^sub>1 = range (suffix i \\<rho>\\<^sub>1)\n\ngoal (2 subgoals):\n 1. project_transition_fst ` limit \\<rho> = limit \\<rho>\\<^sub>1\n 2. limit \\<rho>\n    \\<subseteq> \\<Union> (embed_transition_fst ` limit \\<rho>\\<^sub>1)", "have \"\\<And>k. project_transition_fst (suffix i \\<rho> k) = (suffix i \\<rho>\\<^sub>1 k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       project_transition_fst (suffix i \\<rho> k) =\n       suffix i \\<rho>\\<^sub>1 k", "by (simp only: assms run\\<^sub>t.simps) (metis \\<rho>\\<^sub>1_def product_run_project_fst suffix_nth)"], ["proof (state)\nthis:\n  project_transition_fst (suffix i \\<rho> ?k) = suffix i \\<rho>\\<^sub>1 ?k\n\ngoal (2 subgoals):\n 1. project_transition_fst ` limit \\<rho> = limit \\<rho>\\<^sub>1\n 2. limit \\<rho>\n    \\<subseteq> \\<Union> (embed_transition_fst ` limit \\<rho>\\<^sub>1)", "hence \"project_transition_fst ` range (suffix i \\<rho>) = (range (suffix i \\<rho>\\<^sub>1))\""], ["proof (prove)\nusing this:\n  project_transition_fst (suffix i \\<rho> ?k) = suffix i \\<rho>\\<^sub>1 ?k\n\ngoal (1 subgoal):\n 1. project_transition_fst ` range (suffix i \\<rho>) =\n    range (suffix i \\<rho>\\<^sub>1)", "using range_composition[symmetric, of \"project_transition_fst\" \"suffix i \\<rho>\"]"], ["proof (prove)\nusing this:\n  project_transition_fst (suffix i \\<rho> ?k) = suffix i \\<rho>\\<^sub>1 ?k\n  project_transition_fst ` range (suffix i \\<rho>) =\n  range (\\<lambda>x. project_transition_fst (suffix i \\<rho> x))\n\ngoal (1 subgoal):\n 1. project_transition_fst ` range (suffix i \\<rho>) =\n    range (suffix i \\<rho>\\<^sub>1)", "by presburger"], ["proof (state)\nthis:\n  project_transition_fst ` range (suffix i \\<rho>) =\n  range (suffix i \\<rho>\\<^sub>1)\n\ngoal (2 subgoals):\n 1. project_transition_fst ` limit \\<rho> = limit \\<rho>\\<^sub>1\n 2. limit \\<rho>\n    \\<subseteq> \\<Union> (embed_transition_fst ` limit \\<rho>\\<^sub>1)", "moreover"], ["proof (state)\nthis:\n  project_transition_fst ` range (suffix i \\<rho>) =\n  range (suffix i \\<rho>\\<^sub>1)\n\ngoal (2 subgoals):\n 1. project_transition_fst ` limit \\<rho> = limit \\<rho>\\<^sub>1\n 2. limit \\<rho>\n    \\<subseteq> \\<Union> (embed_transition_fst ` limit \\<rho>\\<^sub>1)", "have \"\\<And>k. (suffix i \\<rho> k) \\<in> embed_transition_fst (suffix i \\<rho>\\<^sub>1 k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       suffix i \\<rho> k\n       \\<in> embed_transition_fst (suffix i \\<rho>\\<^sub>1 k)", "using assms product_run_embed_fst"], ["proof (prove)\nusing this:\n  \\<rho> \\<equiv>\n  run\\<^sub>t \\<delta>\\<^sub>1 \\<times> \\<delta>\\<^sub>2\n   (q\\<^sub>1, q\\<^sub>2) w\n  \\<rho>\\<^sub>1 \\<equiv> run\\<^sub>t \\<delta>\\<^sub>1 q\\<^sub>1 w\n  finite (range \\<rho>)\n  run\\<^sub>t ?\\<delta>\\<^sub>1 \\<times> ?\\<delta>\\<^sub>2\n   (?q\\<^sub>1, ?q\\<^sub>2) ?w ?i\n  \\<in> embed_transition_fst\n         (run\\<^sub>t ?\\<delta>\\<^sub>1 ?q\\<^sub>1 ?w ?i)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       suffix i \\<rho> k\n       \\<in> embed_transition_fst (suffix i \\<rho>\\<^sub>1 k)", "by simp"], ["proof (state)\nthis:\n  suffix i \\<rho> ?k \\<in> embed_transition_fst (suffix i \\<rho>\\<^sub>1 ?k)\n\ngoal (2 subgoals):\n 1. project_transition_fst ` limit \\<rho> = limit \\<rho>\\<^sub>1\n 2. limit \\<rho>\n    \\<subseteq> \\<Union> (embed_transition_fst ` limit \\<rho>\\<^sub>1)", "ultimately"], ["proof (chain)\npicking this:\n  limit \\<rho> = range (suffix i \\<rho>)\n  limit \\<rho>\\<^sub>1 = range (suffix i \\<rho>\\<^sub>1)\n  project_transition_fst ` range (suffix i \\<rho>) =\n  range (suffix i \\<rho>\\<^sub>1)\n  suffix i \\<rho> ?k \\<in> embed_transition_fst (suffix i \\<rho>\\<^sub>1 ?k)", "show \"project_transition_fst ` limit \\<rho> = limit \\<rho>\\<^sub>1\" \n    and \"limit \\<rho> \\<subseteq> \\<Union> (embed_transition_fst ` (limit \\<rho>\\<^sub>1))\""], ["proof (prove)\nusing this:\n  limit \\<rho> = range (suffix i \\<rho>)\n  limit \\<rho>\\<^sub>1 = range (suffix i \\<rho>\\<^sub>1)\n  project_transition_fst ` range (suffix i \\<rho>) =\n  range (suffix i \\<rho>\\<^sub>1)\n  suffix i \\<rho> ?k \\<in> embed_transition_fst (suffix i \\<rho>\\<^sub>1 ?k)\n\ngoal (1 subgoal):\n 1. project_transition_fst ` limit \\<rho> = limit \\<rho>\\<^sub>1 &&&\n    limit \\<rho>\n    \\<subseteq> \\<Union> (embed_transition_fst ` limit \\<rho>\\<^sub>1)", "by auto"], ["proof (state)\nthis:\n  project_transition_fst ` limit \\<rho> = limit \\<rho>\\<^sub>1\n  limit \\<rho>\n  \\<subseteq> \\<Union> (embed_transition_fst ` limit \\<rho>\\<^sub>1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \n  fixes \\<delta>\\<^sub>1 \\<delta>\\<^sub>2 w q\\<^sub>1 q\\<^sub>2\n  defines \"\\<rho> \\<equiv> run\\<^sub>t (\\<delta>\\<^sub>1 \\<times> \\<delta>\\<^sub>2) (q\\<^sub>1, q\\<^sub>2) w\"\n  defines \"\\<rho>\\<^sub>2 \\<equiv> run\\<^sub>t \\<delta>\\<^sub>2 q\\<^sub>2 w\"\n  assumes \"finite (range \\<rho>)\"\n  shows product_run_project_limit_snd: \"project_transition_snd ` limit \\<rho> = limit \\<rho>\\<^sub>2\"\n    and product_run_embed_limit_snd: \"limit \\<rho> \\<subseteq> \\<Union> (embed_transition_snd ` (limit \\<rho>\\<^sub>2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. project_transition_snd ` limit \\<rho> = limit \\<rho>\\<^sub>2 &&&\n    limit \\<rho>\n    \\<subseteq> \\<Union> (embed_transition_snd ` limit \\<rho>\\<^sub>2)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. project_transition_snd ` limit \\<rho> = limit \\<rho>\\<^sub>2\n 2. limit \\<rho>\n    \\<subseteq> \\<Union> (embed_transition_snd ` limit \\<rho>\\<^sub>2)", "have \"finite (range \\<rho>\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (range \\<rho>\\<^sub>2)", "using assms product_run_finite_snd"], ["proof (prove)\nusing this:\n  \\<rho> \\<equiv>\n  run\\<^sub>t \\<delta>\\<^sub>1 \\<times> \\<delta>\\<^sub>2\n   (q\\<^sub>1, q\\<^sub>2) w\n  \\<rho>\\<^sub>2 \\<equiv> run\\<^sub>t \\<delta>\\<^sub>2 q\\<^sub>2 w\n  finite (range \\<rho>)\n  finite\n   (range\n     (run\\<^sub>t ?\\<delta>\\<^sub>1 \\<times> ?\\<delta>\\<^sub>2\n       (?q\\<^sub>1, ?q\\<^sub>2) ?w)) \\<Longrightarrow>\n  finite (range (run\\<^sub>t ?\\<delta>\\<^sub>2 ?q\\<^sub>2 ?w))\n\ngoal (1 subgoal):\n 1. finite (range \\<rho>\\<^sub>2)", "by metis"], ["proof (state)\nthis:\n  finite (range \\<rho>\\<^sub>2)\n\ngoal (2 subgoals):\n 1. project_transition_snd ` limit \\<rho> = limit \\<rho>\\<^sub>2\n 2. limit \\<rho>\n    \\<subseteq> \\<Union> (embed_transition_snd ` limit \\<rho>\\<^sub>2)", "then"], ["proof (chain)\npicking this:\n  finite (range \\<rho>\\<^sub>2)", "obtain i where \"limit \\<rho> = range (suffix i \\<rho>)\" and \"limit \\<rho>\\<^sub>2 = range (suffix i \\<rho>\\<^sub>2)\""], ["proof (prove)\nusing this:\n  finite (range \\<rho>\\<^sub>2)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>limit \\<rho> = range (suffix i \\<rho>);\n         limit \\<rho>\\<^sub>2 = range (suffix i \\<rho>\\<^sub>2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using common_range_limit assms"], ["proof (prove)\nusing this:\n  finite (range \\<rho>\\<^sub>2)\n  \\<lbrakk>finite (range ?x); finite (range ?y);\n   \\<And>i.\n      \\<lbrakk>limit ?x = range (suffix i ?x);\n       limit ?y = range (suffix i ?y)\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  \\<rho> \\<equiv>\n  run\\<^sub>t \\<delta>\\<^sub>1 \\<times> \\<delta>\\<^sub>2\n   (q\\<^sub>1, q\\<^sub>2) w\n  \\<rho>\\<^sub>2 \\<equiv> run\\<^sub>t \\<delta>\\<^sub>2 q\\<^sub>2 w\n  finite (range \\<rho>)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>limit \\<rho> = range (suffix i \\<rho>);\n         limit \\<rho>\\<^sub>2 = range (suffix i \\<rho>\\<^sub>2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  limit \\<rho> = range (suffix i \\<rho>)\n  limit \\<rho>\\<^sub>2 = range (suffix i \\<rho>\\<^sub>2)\n\ngoal (2 subgoals):\n 1. project_transition_snd ` limit \\<rho> = limit \\<rho>\\<^sub>2\n 2. limit \\<rho>\n    \\<subseteq> \\<Union> (embed_transition_snd ` limit \\<rho>\\<^sub>2)", "moreover"], ["proof (state)\nthis:\n  limit \\<rho> = range (suffix i \\<rho>)\n  limit \\<rho>\\<^sub>2 = range (suffix i \\<rho>\\<^sub>2)\n\ngoal (2 subgoals):\n 1. project_transition_snd ` limit \\<rho> = limit \\<rho>\\<^sub>2\n 2. limit \\<rho>\n    \\<subseteq> \\<Union> (embed_transition_snd ` limit \\<rho>\\<^sub>2)", "have \"\\<And>k. project_transition_snd (suffix i \\<rho> k) = (suffix i \\<rho>\\<^sub>2 k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       project_transition_snd (suffix i \\<rho> k) =\n       suffix i \\<rho>\\<^sub>2 k", "by (simp only: assms run\\<^sub>t.simps) (metis \\<rho>\\<^sub>2_def product_run_project_snd suffix_nth)"], ["proof (state)\nthis:\n  project_transition_snd (suffix i \\<rho> ?k) = suffix i \\<rho>\\<^sub>2 ?k\n\ngoal (2 subgoals):\n 1. project_transition_snd ` limit \\<rho> = limit \\<rho>\\<^sub>2\n 2. limit \\<rho>\n    \\<subseteq> \\<Union> (embed_transition_snd ` limit \\<rho>\\<^sub>2)", "hence \"project_transition_snd ` range ((suffix i \\<rho>)) = (range (suffix i \\<rho>\\<^sub>2))\""], ["proof (prove)\nusing this:\n  project_transition_snd (suffix i \\<rho> ?k) = suffix i \\<rho>\\<^sub>2 ?k\n\ngoal (1 subgoal):\n 1. project_transition_snd ` range (suffix i \\<rho>) =\n    range (suffix i \\<rho>\\<^sub>2)", "using range_composition[symmetric, of \"project_transition_snd\" \"(suffix i \\<rho>)\"]"], ["proof (prove)\nusing this:\n  project_transition_snd (suffix i \\<rho> ?k) = suffix i \\<rho>\\<^sub>2 ?k\n  project_transition_snd ` range (suffix i \\<rho>) =\n  range (\\<lambda>x. project_transition_snd (suffix i \\<rho> x))\n\ngoal (1 subgoal):\n 1. project_transition_snd ` range (suffix i \\<rho>) =\n    range (suffix i \\<rho>\\<^sub>2)", "by presburger"], ["proof (state)\nthis:\n  project_transition_snd ` range (suffix i \\<rho>) =\n  range (suffix i \\<rho>\\<^sub>2)\n\ngoal (2 subgoals):\n 1. project_transition_snd ` limit \\<rho> = limit \\<rho>\\<^sub>2\n 2. limit \\<rho>\n    \\<subseteq> \\<Union> (embed_transition_snd ` limit \\<rho>\\<^sub>2)", "moreover"], ["proof (state)\nthis:\n  project_transition_snd ` range (suffix i \\<rho>) =\n  range (suffix i \\<rho>\\<^sub>2)\n\ngoal (2 subgoals):\n 1. project_transition_snd ` limit \\<rho> = limit \\<rho>\\<^sub>2\n 2. limit \\<rho>\n    \\<subseteq> \\<Union> (embed_transition_snd ` limit \\<rho>\\<^sub>2)", "have \"\\<And>k. (suffix i \\<rho> k) \\<in> embed_transition_snd (suffix i \\<rho>\\<^sub>2 k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       suffix i \\<rho> k\n       \\<in> embed_transition_snd (suffix i \\<rho>\\<^sub>2 k)", "using assms product_run_embed_snd"], ["proof (prove)\nusing this:\n  \\<rho> \\<equiv>\n  run\\<^sub>t \\<delta>\\<^sub>1 \\<times> \\<delta>\\<^sub>2\n   (q\\<^sub>1, q\\<^sub>2) w\n  \\<rho>\\<^sub>2 \\<equiv> run\\<^sub>t \\<delta>\\<^sub>2 q\\<^sub>2 w\n  finite (range \\<rho>)\n  run\\<^sub>t ?\\<delta>\\<^sub>1 \\<times> ?\\<delta>\\<^sub>2\n   (?q\\<^sub>1, ?q\\<^sub>2) ?w ?i\n  \\<in> embed_transition_snd\n         (run\\<^sub>t ?\\<delta>\\<^sub>2 ?q\\<^sub>2 ?w ?i)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       suffix i \\<rho> k\n       \\<in> embed_transition_snd (suffix i \\<rho>\\<^sub>2 k)", "by simp"], ["proof (state)\nthis:\n  suffix i \\<rho> ?k \\<in> embed_transition_snd (suffix i \\<rho>\\<^sub>2 ?k)\n\ngoal (2 subgoals):\n 1. project_transition_snd ` limit \\<rho> = limit \\<rho>\\<^sub>2\n 2. limit \\<rho>\n    \\<subseteq> \\<Union> (embed_transition_snd ` limit \\<rho>\\<^sub>2)", "ultimately"], ["proof (chain)\npicking this:\n  limit \\<rho> = range (suffix i \\<rho>)\n  limit \\<rho>\\<^sub>2 = range (suffix i \\<rho>\\<^sub>2)\n  project_transition_snd ` range (suffix i \\<rho>) =\n  range (suffix i \\<rho>\\<^sub>2)\n  suffix i \\<rho> ?k \\<in> embed_transition_snd (suffix i \\<rho>\\<^sub>2 ?k)", "show \"project_transition_snd ` limit \\<rho> = limit \\<rho>\\<^sub>2\" \n    and \"limit \\<rho> \\<subseteq> \\<Union> (embed_transition_snd ` (limit \\<rho>\\<^sub>2))\""], ["proof (prove)\nusing this:\n  limit \\<rho> = range (suffix i \\<rho>)\n  limit \\<rho>\\<^sub>2 = range (suffix i \\<rho>\\<^sub>2)\n  project_transition_snd ` range (suffix i \\<rho>) =\n  range (suffix i \\<rho>\\<^sub>2)\n  suffix i \\<rho> ?k \\<in> embed_transition_snd (suffix i \\<rho>\\<^sub>2 ?k)\n\ngoal (1 subgoal):\n 1. project_transition_snd ` limit \\<rho> = limit \\<rho>\\<^sub>2 &&&\n    limit \\<rho>\n    \\<subseteq> \\<Union> (embed_transition_snd ` limit \\<rho>\\<^sub>2)", "by auto"], ["proof (state)\nthis:\n  project_transition_snd ` limit \\<rho> = limit \\<rho>\\<^sub>2\n  limit \\<rho>\n  \\<subseteq> \\<Union> (embed_transition_snd ` limit \\<rho>\\<^sub>2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \n  fixes \\<delta>\\<^sub>1 \\<delta>\\<^sub>2 w q\\<^sub>1 q\\<^sub>2\n  defines \"\\<rho> \\<equiv> run\\<^sub>t (\\<delta>\\<^sub>1 \\<times> \\<delta>\\<^sub>2) (q\\<^sub>1, q\\<^sub>2) w\"\n  defines \"\\<rho>\\<^sub>1 \\<equiv> run\\<^sub>t \\<delta>\\<^sub>1 q\\<^sub>1 w\"\n  defines \"\\<rho>\\<^sub>2 \\<equiv> run\\<^sub>t \\<delta>\\<^sub>2 q\\<^sub>2 w\"\n  assumes \"finite (range \\<rho>)\"\n  shows product_run_embed_limit_finiteness_fst: \"limit \\<rho> \\<inter> (\\<Union> (embed_transition_fst ` S)) = {} \\<longleftrightarrow> limit \\<rho>\\<^sub>1 \\<inter> S = {}\" (is \"?thesis1\")\n    and product_run_embed_limit_finiteness_snd: \"limit \\<rho> \\<inter> (\\<Union> (embed_transition_snd ` S')) = {} \\<longleftrightarrow> limit \\<rho>\\<^sub>2 \\<inter> S' = {}\" (is \"?thesis2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (limit \\<rho> \\<inter> \\<Union> (embed_transition_fst ` S) = {}) =\n    (limit \\<rho>\\<^sub>1 \\<inter> S = {}) &&&\n    (limit \\<rho> \\<inter> \\<Union> (embed_transition_snd ` S') = {}) =\n    (limit \\<rho>\\<^sub>2 \\<inter> S' = {})", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. (limit \\<rho> \\<inter> \\<Union> (embed_transition_fst ` S) = {}) =\n    (limit \\<rho>\\<^sub>1 \\<inter> S = {})\n 2. (limit \\<rho> \\<inter> \\<Union> (embed_transition_snd ` S') = {}) =\n    (limit \\<rho>\\<^sub>2 \\<inter> S' = {})", "show ?thesis1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (limit \\<rho> \\<inter> \\<Union> (embed_transition_fst ` S) = {}) =\n    (limit \\<rho>\\<^sub>1 \\<inter> S = {})", "using assms product_run_project_limit_fst"], ["proof (prove)\nusing this:\n  \\<rho> \\<equiv>\n  run\\<^sub>t \\<delta>\\<^sub>1 \\<times> \\<delta>\\<^sub>2\n   (q\\<^sub>1, q\\<^sub>2) w\n  \\<rho>\\<^sub>1 \\<equiv> run\\<^sub>t \\<delta>\\<^sub>1 q\\<^sub>1 w\n  \\<rho>\\<^sub>2 \\<equiv> run\\<^sub>t \\<delta>\\<^sub>2 q\\<^sub>2 w\n  finite (range \\<rho>)\n  finite\n   (range\n     (run\\<^sub>t ?\\<delta>\\<^sub>1 \\<times> ?\\<delta>\\<^sub>2\n       (?q\\<^sub>1, ?q\\<^sub>2) ?w)) \\<Longrightarrow>\n  project_transition_fst `\n  limit\n   (run\\<^sub>t ?\\<delta>\\<^sub>1 \\<times> ?\\<delta>\\<^sub>2\n     (?q\\<^sub>1, ?q\\<^sub>2) ?w) =\n  limit (run\\<^sub>t ?\\<delta>\\<^sub>1 ?q\\<^sub>1 ?w)\n\ngoal (1 subgoal):\n 1. (limit \\<rho> \\<inter> \\<Union> (embed_transition_fst ` S) = {}) =\n    (limit \\<rho>\\<^sub>1 \\<inter> S = {})", "by fastforce"], ["proof (state)\nthis:\n  (limit \\<rho> \\<inter> \\<Union> (embed_transition_fst ` S) = {}) =\n  (limit \\<rho>\\<^sub>1 \\<inter> S = {})\n\ngoal (1 subgoal):\n 1. (limit \\<rho> \\<inter> \\<Union> (embed_transition_snd ` S') = {}) =\n    (limit \\<rho>\\<^sub>2 \\<inter> S' = {})", "show ?thesis2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (limit \\<rho> \\<inter> \\<Union> (embed_transition_snd ` S') = {}) =\n    (limit \\<rho>\\<^sub>2 \\<inter> S' = {})", "using assms product_run_project_limit_snd"], ["proof (prove)\nusing this:\n  \\<rho> \\<equiv>\n  run\\<^sub>t \\<delta>\\<^sub>1 \\<times> \\<delta>\\<^sub>2\n   (q\\<^sub>1, q\\<^sub>2) w\n  \\<rho>\\<^sub>1 \\<equiv> run\\<^sub>t \\<delta>\\<^sub>1 q\\<^sub>1 w\n  \\<rho>\\<^sub>2 \\<equiv> run\\<^sub>t \\<delta>\\<^sub>2 q\\<^sub>2 w\n  finite (range \\<rho>)\n  finite\n   (range\n     (run\\<^sub>t ?\\<delta>\\<^sub>1 \\<times> ?\\<delta>\\<^sub>2\n       (?q\\<^sub>1, ?q\\<^sub>2) ?w)) \\<Longrightarrow>\n  project_transition_snd `\n  limit\n   (run\\<^sub>t ?\\<delta>\\<^sub>1 \\<times> ?\\<delta>\\<^sub>2\n     (?q\\<^sub>1, ?q\\<^sub>2) ?w) =\n  limit (run\\<^sub>t ?\\<delta>\\<^sub>2 ?q\\<^sub>2 ?w)\n\ngoal (1 subgoal):\n 1. (limit \\<rho> \\<inter> \\<Union> (embed_transition_snd ` S') = {}) =\n    (limit \\<rho>\\<^sub>2 \\<inter> S' = {})", "by fastforce"], ["proof (state)\nthis:\n  (limit \\<rho> \\<inter> \\<Union> (embed_transition_snd ` S') = {}) =\n  (limit \\<rho>\\<^sub>2 \\<inter> S' = {})\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Product Construction Helper Functions and Lemmas\\<close>"], ["", "fun embed_transition :: \"'a \\<Rightarrow> ('b, 'c) transition \\<Rightarrow> ('a \\<rightharpoonup> 'b, 'c) transition set\" (\"\\<upharpoonleft>\\<^sub>_\")\nwhere\n  \"\\<upharpoonleft>\\<^sub>x (q, \\<nu>, q') = {(m, \\<nu>, m') | m m'. m x = Some q \\<and> m' x = Some q'}\""], ["", "fun project_transition :: \"'a \\<Rightarrow> ('a \\<rightharpoonup> 'b, 'c) transition \\<Rightarrow> ('b, 'c) transition\" (\"\\<downharpoonleft>\\<^sub>_\")\nwhere\n  \"\\<downharpoonleft>\\<^sub>x (m, \\<nu>, m') = (the (m x), \\<nu>, the (m' x))\""], ["", "fun embed_pair :: \"'a \\<Rightarrow> (('b, 'c) transition set \\<times> ('b, 'c) transition set) \\<Rightarrow> (('a \\<rightharpoonup> 'b, 'c) transition set \\<times> ('a \\<rightharpoonup> 'b, 'c) transition set)\" (\"\\<^bold>\\<upharpoonleft>\\<^sub>_\")\nwhere\n  \"\\<^bold>\\<upharpoonleft>\\<^sub>x (S, S') = (\\<Union>(\\<upharpoonleft>\\<^sub>x ` S), \\<Union>(\\<upharpoonleft>\\<^sub>x ` S'))\""], ["", "fun project_pair :: \"'a \\<Rightarrow> (('a \\<rightharpoonup> 'b, 'c) transition set \\<times> ('a \\<rightharpoonup> 'b, 'c) transition set) \\<Rightarrow> (('b, 'c) transition set \\<times> ('b, 'c) transition set)\" (\"\\<^bold>\\<downharpoonleft>\\<^sub>_\")\nwhere\n  \"\\<^bold>\\<downharpoonleft>\\<^sub>x (S, S') = (\\<downharpoonleft>\\<^sub>x ` S, \\<downharpoonleft>\\<^sub>x ` S')\""], ["", "lemma embed_transition_unfold:\n  \"embed_transition x t = {(m, fst (snd t), m') | m m'. m x = Some (fst t) \\<and> m' x = Some (snd (snd t))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<upharpoonleft>\\<^sub>x t =\n    {(m, fst (snd t), m') |m m'.\n     m x = Some (fst t) \\<and> m' x = Some (snd (snd t))}", "unfolding embed_transition.simps[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<upharpoonleft>\\<^sub>x t =\n    \\<upharpoonleft>\\<^sub>x (fst t, fst (snd t), snd (snd t))", "by simp"], ["", "lemma\n  fixes \\<iota>\\<^sub>m \\<delta>\\<^sub>m w q\\<^sub>0 \n  fixes x :: \"'a\"\n  defines \"\\<rho> \\<equiv> run\\<^sub>t (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m w\"\n  defines \"\\<rho>' \\<equiv> run\\<^sub>t (\\<delta>\\<^sub>m x) q\\<^sub>0 w\"\n  assumes \"\\<iota>\\<^sub>m x = Some q\\<^sub>0\"\n  shows product_run_project: \"\\<downharpoonleft>\\<^sub>x (\\<rho> i) = \\<rho>' i\" \n    and product_run_embed: \"\\<rho> i \\<in> \\<upharpoonleft>\\<^sub>x (\\<rho>' i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<downharpoonleft>\\<^sub>x (\\<rho> i) = \\<rho>' i &&&\n    \\<rho> i \\<in> \\<upharpoonleft>\\<^sub>x (\\<rho>' i)", "using assms product_run_Some[of _ _ _ \\<delta>\\<^sub>m]"], ["proof (prove)\nusing this:\n  \\<rho> \\<equiv>\n  run\\<^sub>t (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m w\n  \\<rho>' \\<equiv> run\\<^sub>t (\\<delta>\\<^sub>m x) q\\<^sub>0 w\n  \\<iota>\\<^sub>m x = Some q\\<^sub>0\n  ?\\<iota>\\<^sub>m ?k = Some ?q\\<^sub>0 \\<Longrightarrow>\n  run (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) ?\\<iota>\\<^sub>m ?w ?i ?k =\n  Some (run (\\<delta>\\<^sub>m ?k) ?q\\<^sub>0 ?w ?i)\n\ngoal (1 subgoal):\n 1. \\<downharpoonleft>\\<^sub>x (\\<rho> i) = \\<rho>' i &&&\n    \\<rho> i \\<in> \\<upharpoonleft>\\<^sub>x (\\<rho>' i)", "by simp+"], ["", "lemma \n  fixes \\<iota>\\<^sub>m \\<delta>\\<^sub>m w q\\<^sub>0 x\n  defines \"\\<rho> \\<equiv> run\\<^sub>t (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m w\"\n  defines \"\\<rho>' \\<equiv> run\\<^sub>t (\\<delta>\\<^sub>m x) q\\<^sub>0 w\"\n  assumes \"\\<iota>\\<^sub>m x = Some q\\<^sub>0\"\n  assumes \"finite (range \\<rho>)\"\n  shows product_run_project_limit: \"\\<downharpoonleft>\\<^sub>x ` limit \\<rho> = limit \\<rho>'\" \n    and product_run_embed_limit: \"limit \\<rho> \\<subseteq> \\<Union> (\\<upharpoonleft>\\<^sub>x ` (limit \\<rho>'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<downharpoonleft>\\<^sub>x ` limit \\<rho> = limit \\<rho>' &&&\n    limit \\<rho>\n    \\<subseteq> \\<Union> (\\<upharpoonleft>\\<^sub>x ` limit \\<rho>')", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<downharpoonleft>\\<^sub>x ` limit \\<rho> = limit \\<rho>'\n 2. limit \\<rho>\n    \\<subseteq> \\<Union> (\\<upharpoonleft>\\<^sub>x ` limit \\<rho>')", "have \"\\<And>k. \\<downharpoonleft>\\<^sub>x (\\<rho> k) = \\<rho>' k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k. \\<downharpoonleft>\\<^sub>x (\\<rho> k) = \\<rho>' k", "using assms product_run_embed[of _ _ _ \\<delta>\\<^sub>m]"], ["proof (prove)\nusing this:\n  \\<rho> \\<equiv>\n  run\\<^sub>t (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m w\n  \\<rho>' \\<equiv> run\\<^sub>t (\\<delta>\\<^sub>m x) q\\<^sub>0 w\n  \\<iota>\\<^sub>m x = Some q\\<^sub>0\n  finite (range \\<rho>)\n  ?\\<iota>\\<^sub>m ?x = Some ?q\\<^sub>0 \\<Longrightarrow>\n  run\\<^sub>t (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) ?\\<iota>\\<^sub>m ?w\n   ?i\n  \\<in> \\<upharpoonleft>\\<^sub>?x\n         (run\\<^sub>t (\\<delta>\\<^sub>m ?x) ?q\\<^sub>0 ?w ?i)\n\ngoal (1 subgoal):\n 1. \\<And>k. \\<downharpoonleft>\\<^sub>x (\\<rho> k) = \\<rho>' k", "by simp"], ["proof (state)\nthis:\n  \\<downharpoonleft>\\<^sub>x (\\<rho> ?k) = \\<rho>' ?k\n\ngoal (2 subgoals):\n 1. \\<downharpoonleft>\\<^sub>x ` limit \\<rho> = limit \\<rho>'\n 2. limit \\<rho>\n    \\<subseteq> \\<Union> (\\<upharpoonleft>\\<^sub>x ` limit \\<rho>')", "hence \"\\<downharpoonleft>\\<^sub>x ` range \\<rho> = range \\<rho>'\""], ["proof (prove)\nusing this:\n  \\<downharpoonleft>\\<^sub>x (\\<rho> ?k) = \\<rho>' ?k\n\ngoal (1 subgoal):\n 1. \\<downharpoonleft>\\<^sub>x ` range \\<rho> = range \\<rho>'", "using range_composition[symmetric, of \"\\<downharpoonleft>\\<^sub>x\" \\<rho>]"], ["proof (prove)\nusing this:\n  \\<downharpoonleft>\\<^sub>x (\\<rho> ?k) = \\<rho>' ?k\n  \\<downharpoonleft>\\<^sub>x ` range \\<rho> =\n  range (\\<lambda>xa. \\<downharpoonleft>\\<^sub>x (\\<rho> xa))\n\ngoal (1 subgoal):\n 1. \\<downharpoonleft>\\<^sub>x ` range \\<rho> = range \\<rho>'", "by presburger"], ["proof (state)\nthis:\n  \\<downharpoonleft>\\<^sub>x ` range \\<rho> = range \\<rho>'\n\ngoal (2 subgoals):\n 1. \\<downharpoonleft>\\<^sub>x ` limit \\<rho> = limit \\<rho>'\n 2. limit \\<rho>\n    \\<subseteq> \\<Union> (\\<upharpoonleft>\\<^sub>x ` limit \\<rho>')", "hence \"finite (range \\<rho>')\""], ["proof (prove)\nusing this:\n  \\<downharpoonleft>\\<^sub>x ` range \\<rho> = range \\<rho>'\n\ngoal (1 subgoal):\n 1. finite (range \\<rho>')", "using assms finite_imageI"], ["proof (prove)\nusing this:\n  \\<downharpoonleft>\\<^sub>x ` range \\<rho> = range \\<rho>'\n  \\<rho> \\<equiv>\n  run\\<^sub>t (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m w\n  \\<rho>' \\<equiv> run\\<^sub>t (\\<delta>\\<^sub>m x) q\\<^sub>0 w\n  \\<iota>\\<^sub>m x = Some q\\<^sub>0\n  finite (range \\<rho>)\n  finite ?F \\<Longrightarrow> finite (?h ` ?F)\n\ngoal (1 subgoal):\n 1. finite (range \\<rho>')", "by metis"], ["proof (state)\nthis:\n  finite (range \\<rho>')\n\ngoal (2 subgoals):\n 1. \\<downharpoonleft>\\<^sub>x ` limit \\<rho> = limit \\<rho>'\n 2. limit \\<rho>\n    \\<subseteq> \\<Union> (\\<upharpoonleft>\\<^sub>x ` limit \\<rho>')", "then"], ["proof (chain)\npicking this:\n  finite (range \\<rho>')", "obtain i where \"limit \\<rho> = range (suffix i \\<rho>)\" and \"limit \\<rho>' = range (suffix i \\<rho>')\""], ["proof (prove)\nusing this:\n  finite (range \\<rho>')\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>limit \\<rho> = range (suffix i \\<rho>);\n         limit \\<rho>' = range (suffix i \\<rho>')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using common_range_limit assms"], ["proof (prove)\nusing this:\n  finite (range \\<rho>')\n  \\<lbrakk>finite (range ?x); finite (range ?y);\n   \\<And>i.\n      \\<lbrakk>limit ?x = range (suffix i ?x);\n       limit ?y = range (suffix i ?y)\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  \\<rho> \\<equiv>\n  run\\<^sub>t (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m w\n  \\<rho>' \\<equiv> run\\<^sub>t (\\<delta>\\<^sub>m x) q\\<^sub>0 w\n  \\<iota>\\<^sub>m x = Some q\\<^sub>0\n  finite (range \\<rho>)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>limit \\<rho> = range (suffix i \\<rho>);\n         limit \\<rho>' = range (suffix i \\<rho>')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  limit \\<rho> = range (suffix i \\<rho>)\n  limit \\<rho>' = range (suffix i \\<rho>')\n\ngoal (2 subgoals):\n 1. \\<downharpoonleft>\\<^sub>x ` limit \\<rho> = limit \\<rho>'\n 2. limit \\<rho>\n    \\<subseteq> \\<Union> (\\<upharpoonleft>\\<^sub>x ` limit \\<rho>')", "moreover"], ["proof (state)\nthis:\n  limit \\<rho> = range (suffix i \\<rho>)\n  limit \\<rho>' = range (suffix i \\<rho>')\n\ngoal (2 subgoals):\n 1. \\<downharpoonleft>\\<^sub>x ` limit \\<rho> = limit \\<rho>'\n 2. limit \\<rho>\n    \\<subseteq> \\<Union> (\\<upharpoonleft>\\<^sub>x ` limit \\<rho>')", "have \"\\<And>k. \\<downharpoonleft>\\<^sub>x (suffix i \\<rho> k) = (suffix i \\<rho>' k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<downharpoonleft>\\<^sub>x (suffix i \\<rho> k) = suffix i \\<rho>' k", "using assms product_run_embed[of _ _ _ \\<delta>\\<^sub>m]"], ["proof (prove)\nusing this:\n  \\<rho> \\<equiv>\n  run\\<^sub>t (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m w\n  \\<rho>' \\<equiv> run\\<^sub>t (\\<delta>\\<^sub>m x) q\\<^sub>0 w\n  \\<iota>\\<^sub>m x = Some q\\<^sub>0\n  finite (range \\<rho>)\n  ?\\<iota>\\<^sub>m ?x = Some ?q\\<^sub>0 \\<Longrightarrow>\n  run\\<^sub>t (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) ?\\<iota>\\<^sub>m ?w\n   ?i\n  \\<in> \\<upharpoonleft>\\<^sub>?x\n         (run\\<^sub>t (\\<delta>\\<^sub>m ?x) ?q\\<^sub>0 ?w ?i)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<downharpoonleft>\\<^sub>x (suffix i \\<rho> k) = suffix i \\<rho>' k", "by simp"], ["proof (state)\nthis:\n  \\<downharpoonleft>\\<^sub>x (suffix i \\<rho> ?k) = suffix i \\<rho>' ?k\n\ngoal (2 subgoals):\n 1. \\<downharpoonleft>\\<^sub>x ` limit \\<rho> = limit \\<rho>'\n 2. limit \\<rho>\n    \\<subseteq> \\<Union> (\\<upharpoonleft>\\<^sub>x ` limit \\<rho>')", "hence \"\\<downharpoonleft>\\<^sub>x ` range ((suffix i \\<rho>)) = (range (suffix i \\<rho>'))\""], ["proof (prove)\nusing this:\n  \\<downharpoonleft>\\<^sub>x (suffix i \\<rho> ?k) = suffix i \\<rho>' ?k\n\ngoal (1 subgoal):\n 1. \\<downharpoonleft>\\<^sub>x ` range (suffix i \\<rho>) =\n    range (suffix i \\<rho>')", "using range_composition[symmetric, of \"\\<downharpoonleft>\\<^sub>x\" \"(suffix i  \\<rho>)\"]"], ["proof (prove)\nusing this:\n  \\<downharpoonleft>\\<^sub>x (suffix i \\<rho> ?k) = suffix i \\<rho>' ?k\n  \\<downharpoonleft>\\<^sub>x ` range (suffix i \\<rho>) =\n  range (\\<lambda>xa. \\<downharpoonleft>\\<^sub>x (suffix i \\<rho> xa))\n\ngoal (1 subgoal):\n 1. \\<downharpoonleft>\\<^sub>x ` range (suffix i \\<rho>) =\n    range (suffix i \\<rho>')", "by presburger"], ["proof (state)\nthis:\n  \\<downharpoonleft>\\<^sub>x ` range (suffix i \\<rho>) =\n  range (suffix i \\<rho>')\n\ngoal (2 subgoals):\n 1. \\<downharpoonleft>\\<^sub>x ` limit \\<rho> = limit \\<rho>'\n 2. limit \\<rho>\n    \\<subseteq> \\<Union> (\\<upharpoonleft>\\<^sub>x ` limit \\<rho>')", "moreover"], ["proof (state)\nthis:\n  \\<downharpoonleft>\\<^sub>x ` range (suffix i \\<rho>) =\n  range (suffix i \\<rho>')\n\ngoal (2 subgoals):\n 1. \\<downharpoonleft>\\<^sub>x ` limit \\<rho> = limit \\<rho>'\n 2. limit \\<rho>\n    \\<subseteq> \\<Union> (\\<upharpoonleft>\\<^sub>x ` limit \\<rho>')", "have \"\\<And>k. (suffix i \\<rho> k) \\<in> \\<upharpoonleft>\\<^sub>x (suffix i \\<rho>' k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       suffix i \\<rho> k \\<in> \\<upharpoonleft>\\<^sub>x (suffix i \\<rho>' k)", "using assms product_run_embed[of _ _ _ \\<delta>\\<^sub>m]"], ["proof (prove)\nusing this:\n  \\<rho> \\<equiv>\n  run\\<^sub>t (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m w\n  \\<rho>' \\<equiv> run\\<^sub>t (\\<delta>\\<^sub>m x) q\\<^sub>0 w\n  \\<iota>\\<^sub>m x = Some q\\<^sub>0\n  finite (range \\<rho>)\n  ?\\<iota>\\<^sub>m ?x = Some ?q\\<^sub>0 \\<Longrightarrow>\n  run\\<^sub>t (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) ?\\<iota>\\<^sub>m ?w\n   ?i\n  \\<in> \\<upharpoonleft>\\<^sub>?x\n         (run\\<^sub>t (\\<delta>\\<^sub>m ?x) ?q\\<^sub>0 ?w ?i)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       suffix i \\<rho> k \\<in> \\<upharpoonleft>\\<^sub>x (suffix i \\<rho>' k)", "by simp"], ["proof (state)\nthis:\n  suffix i \\<rho> ?k \\<in> \\<upharpoonleft>\\<^sub>x (suffix i \\<rho>' ?k)\n\ngoal (2 subgoals):\n 1. \\<downharpoonleft>\\<^sub>x ` limit \\<rho> = limit \\<rho>'\n 2. limit \\<rho>\n    \\<subseteq> \\<Union> (\\<upharpoonleft>\\<^sub>x ` limit \\<rho>')", "ultimately"], ["proof (chain)\npicking this:\n  limit \\<rho> = range (suffix i \\<rho>)\n  limit \\<rho>' = range (suffix i \\<rho>')\n  \\<downharpoonleft>\\<^sub>x ` range (suffix i \\<rho>) =\n  range (suffix i \\<rho>')\n  suffix i \\<rho> ?k \\<in> \\<upharpoonleft>\\<^sub>x (suffix i \\<rho>' ?k)", "show \"\\<downharpoonleft>\\<^sub>x ` limit \\<rho> = limit \\<rho>'\" and \"limit \\<rho> \\<subseteq> \\<Union> (\\<upharpoonleft>\\<^sub>x ` (limit \\<rho>'))\""], ["proof (prove)\nusing this:\n  limit \\<rho> = range (suffix i \\<rho>)\n  limit \\<rho>' = range (suffix i \\<rho>')\n  \\<downharpoonleft>\\<^sub>x ` range (suffix i \\<rho>) =\n  range (suffix i \\<rho>')\n  suffix i \\<rho> ?k \\<in> \\<upharpoonleft>\\<^sub>x (suffix i \\<rho>' ?k)\n\ngoal (1 subgoal):\n 1. \\<downharpoonleft>\\<^sub>x ` limit \\<rho> = limit \\<rho>' &&&\n    limit \\<rho>\n    \\<subseteq> \\<Union> (\\<upharpoonleft>\\<^sub>x ` limit \\<rho>')", "by auto"], ["proof (state)\nthis:\n  \\<downharpoonleft>\\<^sub>x ` limit \\<rho> = limit \\<rho>'\n  limit \\<rho>\n  \\<subseteq> \\<Union> (\\<upharpoonleft>\\<^sub>x ` limit \\<rho>')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma product_run_embed_limit_finiteness:\n  fixes \\<iota>\\<^sub>m \\<delta>\\<^sub>m w q\\<^sub>0 k\n  defines \"\\<rho> \\<equiv> run\\<^sub>t (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m w\"\n  defines \"\\<rho>' \\<equiv> run\\<^sub>t (\\<delta>\\<^sub>m k) q\\<^sub>0 w\"\n  assumes \"\\<iota>\\<^sub>m k = Some q\\<^sub>0\"\n  assumes \"finite (range \\<rho>)\"\n  shows \"limit \\<rho> \\<inter> (\\<Union> (\\<upharpoonleft>\\<^sub>k ` S)) = {} \\<longleftrightarrow> limit \\<rho>' \\<inter> S = {}\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (limit \\<rho> \\<inter> \\<Union> (\\<upharpoonleft>\\<^sub>k ` S) = {}) =\n    (limit \\<rho>' \\<inter> S = {})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (limit \\<rho> \\<inter> \\<Union> (\\<upharpoonleft>\\<^sub>k ` S) = {}) =\n    (limit \\<rho>' \\<inter> S = {})", "have \"\\<downharpoonleft>\\<^sub>k ` limit \\<rho> \\<inter> S \\<noteq> {} \\<longrightarrow> limit \\<rho> \\<inter> (\\<Union> (\\<upharpoonleft>\\<^sub>k ` S)) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<downharpoonleft>\\<^sub>k ` limit \\<rho> \\<inter> S \\<noteq>\n    {} \\<longrightarrow>\n    limit \\<rho> \\<inter> \\<Union> (\\<upharpoonleft>\\<^sub>k ` S) \\<noteq>\n    {}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<downharpoonleft>\\<^sub>k ` limit \\<rho> \\<inter> S \\<noteq>\n    {} \\<Longrightarrow>\n    limit \\<rho> \\<inter> \\<Union> (\\<upharpoonleft>\\<^sub>k ` S) \\<noteq>\n    {}", "assume \"\\<downharpoonleft>\\<^sub>k ` limit \\<rho> \\<inter> S \\<noteq> {}\""], ["proof (state)\nthis:\n  \\<downharpoonleft>\\<^sub>k ` limit \\<rho> \\<inter> S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<downharpoonleft>\\<^sub>k ` limit \\<rho> \\<inter> S \\<noteq>\n    {} \\<Longrightarrow>\n    limit \\<rho> \\<inter> \\<Union> (\\<upharpoonleft>\\<^sub>k ` S) \\<noteq>\n    {}", "then"], ["proof (chain)\npicking this:\n  \\<downharpoonleft>\\<^sub>k ` limit \\<rho> \\<inter> S \\<noteq> {}", "obtain q \\<nu> q' where \"(q, \\<nu>, q') \\<in> \\<downharpoonleft>\\<^sub>k ` limit \\<rho>\" and \"(q, \\<nu>, q') \\<in> S\""], ["proof (prove)\nusing this:\n  \\<downharpoonleft>\\<^sub>k ` limit \\<rho> \\<inter> S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>q \\<nu> q'.\n        \\<lbrakk>(q, \\<nu>, q')\n                 \\<in> \\<downharpoonleft>\\<^sub>k ` limit \\<rho>;\n         (q, \\<nu>, q') \\<in> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (q, \\<nu>, q') \\<in> \\<downharpoonleft>\\<^sub>k ` limit \\<rho>\n  (q, \\<nu>, q') \\<in> S\n\ngoal (1 subgoal):\n 1. \\<downharpoonleft>\\<^sub>k ` limit \\<rho> \\<inter> S \\<noteq>\n    {} \\<Longrightarrow>\n    limit \\<rho> \\<inter> \\<Union> (\\<upharpoonleft>\\<^sub>k ` S) \\<noteq>\n    {}", "moreover"], ["proof (state)\nthis:\n  (q, \\<nu>, q') \\<in> \\<downharpoonleft>\\<^sub>k ` limit \\<rho>\n  (q, \\<nu>, q') \\<in> S\n\ngoal (1 subgoal):\n 1. \\<downharpoonleft>\\<^sub>k ` limit \\<rho> \\<inter> S \\<noteq>\n    {} \\<Longrightarrow>\n    limit \\<rho> \\<inter> \\<Union> (\\<upharpoonleft>\\<^sub>k ` S) \\<noteq>\n    {}", "have \"\\<And>m \\<nu> m' i. (m, \\<nu>, m') = \\<rho> i \\<Longrightarrow> \\<exists>p p'. m k = Some p \\<and> m' k = Some p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m \\<nu> m' i.\n       (m, \\<nu>, m') = \\<rho> i \\<Longrightarrow>\n       \\<exists>p p'. m k = Some p \\<and> m' k = Some p'", "using assms product_run_Some[of \\<iota>\\<^sub>m , OF assms(3)]"], ["proof (prove)\nusing this:\n  \\<rho> \\<equiv>\n  run\\<^sub>t (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m w\n  \\<rho>' \\<equiv> run\\<^sub>t (\\<delta>\\<^sub>m k) q\\<^sub>0 w\n  \\<iota>\\<^sub>m k = Some q\\<^sub>0\n  finite (range \\<rho>)\n  run (\\<Delta>\\<^sub>\\<times> ?\\<delta>\\<^sub>m) \\<iota>\\<^sub>m ?w ?i k =\n  Some (run (?\\<delta>\\<^sub>m k) q\\<^sub>0 ?w ?i)\n\ngoal (1 subgoal):\n 1. \\<And>m \\<nu> m' i.\n       (m, \\<nu>, m') = \\<rho> i \\<Longrightarrow>\n       \\<exists>p p'. m k = Some p \\<and> m' k = Some p'", "by auto"], ["proof (state)\nthis:\n  (?m, ?\\<nu>, ?m') = \\<rho> ?i \\<Longrightarrow>\n  \\<exists>p p'. ?m k = Some p \\<and> ?m' k = Some p'\n\ngoal (1 subgoal):\n 1. \\<downharpoonleft>\\<^sub>k ` limit \\<rho> \\<inter> S \\<noteq>\n    {} \\<Longrightarrow>\n    limit \\<rho> \\<inter> \\<Union> (\\<upharpoonleft>\\<^sub>k ` S) \\<noteq>\n    {}", "hence \"\\<And>m \\<nu> m'. (m, \\<nu>, m') \\<in> limit \\<rho> \\<Longrightarrow> \\<exists>p p'. m k = Some p \\<and> m' k = Some p'\""], ["proof (prove)\nusing this:\n  (?m, ?\\<nu>, ?m') = \\<rho> ?i \\<Longrightarrow>\n  \\<exists>p p'. ?m k = Some p \\<and> ?m' k = Some p'\n\ngoal (1 subgoal):\n 1. \\<And>m \\<nu> m'.\n       (m, \\<nu>, m') \\<in> limit \\<rho> \\<Longrightarrow>\n       \\<exists>p p'. m k = Some p \\<and> m' k = Some p'", "using limit_in_range"], ["proof (prove)\nusing this:\n  (?m, ?\\<nu>, ?m') = \\<rho> ?i \\<Longrightarrow>\n  \\<exists>p p'. ?m k = Some p \\<and> ?m' k = Some p'\n  limit ?r \\<subseteq> range ?r\n\ngoal (1 subgoal):\n 1. \\<And>m \\<nu> m'.\n       (m, \\<nu>, m') \\<in> limit \\<rho> \\<Longrightarrow>\n       \\<exists>p p'. m k = Some p \\<and> m' k = Some p'", "by fast"], ["proof (state)\nthis:\n  (?m, ?\\<nu>, ?m') \\<in> limit \\<rho> \\<Longrightarrow>\n  \\<exists>p p'. ?m k = Some p \\<and> ?m' k = Some p'\n\ngoal (1 subgoal):\n 1. \\<downharpoonleft>\\<^sub>k ` limit \\<rho> \\<inter> S \\<noteq>\n    {} \\<Longrightarrow>\n    limit \\<rho> \\<inter> \\<Union> (\\<upharpoonleft>\\<^sub>k ` S) \\<noteq>\n    {}", "ultimately"], ["proof (chain)\npicking this:\n  (q, \\<nu>, q') \\<in> \\<downharpoonleft>\\<^sub>k ` limit \\<rho>\n  (q, \\<nu>, q') \\<in> S\n  (?m, ?\\<nu>, ?m') \\<in> limit \\<rho> \\<Longrightarrow>\n  \\<exists>p p'. ?m k = Some p \\<and> ?m' k = Some p'", "obtain m m' where \"m k = Some q\" and \"m' k = Some q'\" and \"(m, \\<nu>, m') \\<in> limit \\<rho>\""], ["proof (prove)\nusing this:\n  (q, \\<nu>, q') \\<in> \\<downharpoonleft>\\<^sub>k ` limit \\<rho>\n  (q, \\<nu>, q') \\<in> S\n  (?m, ?\\<nu>, ?m') \\<in> limit \\<rho> \\<Longrightarrow>\n  \\<exists>p p'. ?m k = Some p \\<and> ?m' k = Some p'\n\ngoal (1 subgoal):\n 1. (\\<And>m m'.\n        \\<lbrakk>m k = Some q; m' k = Some q';\n         (m, \\<nu>, m') \\<in> limit \\<rho>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  m k = Some q\n  m' k = Some q'\n  (m, \\<nu>, m') \\<in> limit \\<rho>\n\ngoal (1 subgoal):\n 1. \\<downharpoonleft>\\<^sub>k ` limit \\<rho> \\<inter> S \\<noteq>\n    {} \\<Longrightarrow>\n    limit \\<rho> \\<inter> \\<Union> (\\<upharpoonleft>\\<^sub>k ` S) \\<noteq>\n    {}", "moreover"], ["proof (state)\nthis:\n  m k = Some q\n  m' k = Some q'\n  (m, \\<nu>, m') \\<in> limit \\<rho>\n\ngoal (1 subgoal):\n 1. \\<downharpoonleft>\\<^sub>k ` limit \\<rho> \\<inter> S \\<noteq>\n    {} \\<Longrightarrow>\n    limit \\<rho> \\<inter> \\<Union> (\\<upharpoonleft>\\<^sub>k ` S) \\<noteq>\n    {}", "hence \"(m, \\<nu>, m') \\<in> \\<Union> (\\<upharpoonleft>\\<^sub>k ` S)\""], ["proof (prove)\nusing this:\n  m k = Some q\n  m' k = Some q'\n  (m, \\<nu>, m') \\<in> limit \\<rho>\n\ngoal (1 subgoal):\n 1. (m, \\<nu>, m') \\<in> \\<Union> (\\<upharpoonleft>\\<^sub>k ` S)", "using \\<open>(q, \\<nu>, q') \\<in> S\\<close>"], ["proof (prove)\nusing this:\n  m k = Some q\n  m' k = Some q'\n  (m, \\<nu>, m') \\<in> limit \\<rho>\n  (q, \\<nu>, q') \\<in> S\n\ngoal (1 subgoal):\n 1. (m, \\<nu>, m') \\<in> \\<Union> (\\<upharpoonleft>\\<^sub>k ` S)", "by force"], ["proof (state)\nthis:\n  (m, \\<nu>, m') \\<in> \\<Union> (\\<upharpoonleft>\\<^sub>k ` S)\n\ngoal (1 subgoal):\n 1. \\<downharpoonleft>\\<^sub>k ` limit \\<rho> \\<inter> S \\<noteq>\n    {} \\<Longrightarrow>\n    limit \\<rho> \\<inter> \\<Union> (\\<upharpoonleft>\\<^sub>k ` S) \\<noteq>\n    {}", "ultimately"], ["proof (chain)\npicking this:\n  m k = Some q\n  m' k = Some q'\n  (m, \\<nu>, m') \\<in> limit \\<rho>\n  (m, \\<nu>, m') \\<in> \\<Union> (\\<upharpoonleft>\\<^sub>k ` S)", "show \"limit \\<rho> \\<inter> (\\<Union> (\\<upharpoonleft>\\<^sub>k ` S)) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  m k = Some q\n  m' k = Some q'\n  (m, \\<nu>, m') \\<in> limit \\<rho>\n  (m, \\<nu>, m') \\<in> \\<Union> (\\<upharpoonleft>\\<^sub>k ` S)\n\ngoal (1 subgoal):\n 1. limit \\<rho> \\<inter> \\<Union> (\\<upharpoonleft>\\<^sub>k ` S) \\<noteq>\n    {}", "by blast"], ["proof (state)\nthis:\n  limit \\<rho> \\<inter> \\<Union> (\\<upharpoonleft>\\<^sub>k ` S) \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<downharpoonleft>\\<^sub>k ` limit \\<rho> \\<inter> S \\<noteq>\n  {} \\<longrightarrow>\n  limit \\<rho> \\<inter> \\<Union> (\\<upharpoonleft>\\<^sub>k ` S) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (limit \\<rho> \\<inter> \\<Union> (\\<upharpoonleft>\\<^sub>k ` S) = {}) =\n    (limit \\<rho>' \\<inter> S = {})", "hence \"?lhs \\<longleftrightarrow> \\<downharpoonleft>\\<^sub>k ` limit \\<rho> \\<inter> S = {}\""], ["proof (prove)\nusing this:\n  \\<downharpoonleft>\\<^sub>k ` limit \\<rho> \\<inter> S \\<noteq>\n  {} \\<longrightarrow>\n  limit \\<rho> \\<inter> \\<Union> (\\<upharpoonleft>\\<^sub>k ` S) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (limit \\<rho> \\<inter> \\<Union> (\\<upharpoonleft>\\<^sub>k ` S) = {}) =\n    (\\<downharpoonleft>\\<^sub>k ` limit \\<rho> \\<inter> S = {})", "by auto"], ["proof (state)\nthis:\n  (limit \\<rho> \\<inter> \\<Union> (\\<upharpoonleft>\\<^sub>k ` S) = {}) =\n  (\\<downharpoonleft>\\<^sub>k ` limit \\<rho> \\<inter> S = {})\n\ngoal (1 subgoal):\n 1. (limit \\<rho> \\<inter> \\<Union> (\\<upharpoonleft>\\<^sub>k ` S) = {}) =\n    (limit \\<rho>' \\<inter> S = {})", "also"], ["proof (state)\nthis:\n  (limit \\<rho> \\<inter> \\<Union> (\\<upharpoonleft>\\<^sub>k ` S) = {}) =\n  (\\<downharpoonleft>\\<^sub>k ` limit \\<rho> \\<inter> S = {})\n\ngoal (1 subgoal):\n 1. (limit \\<rho> \\<inter> \\<Union> (\\<upharpoonleft>\\<^sub>k ` S) = {}) =\n    (limit \\<rho>' \\<inter> S = {})", "have \"\\<dots> \\<longleftrightarrow> ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<downharpoonleft>\\<^sub>k ` limit \\<rho> \\<inter> S = {}) =\n    (limit \\<rho>' \\<inter> S = {})", "using assms product_run_project_limit[of _ _ _ \\<delta>\\<^sub>m]"], ["proof (prove)\nusing this:\n  \\<rho> \\<equiv>\n  run\\<^sub>t (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m w\n  \\<rho>' \\<equiv> run\\<^sub>t (\\<delta>\\<^sub>m k) q\\<^sub>0 w\n  \\<iota>\\<^sub>m k = Some q\\<^sub>0\n  finite (range \\<rho>)\n  \\<lbrakk>?\\<iota>\\<^sub>m ?x = Some ?q\\<^sub>0;\n   finite\n    (range\n      (run\\<^sub>t (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n        ?\\<iota>\\<^sub>m ?w))\\<rbrakk>\n  \\<Longrightarrow> \\<downharpoonleft>\\<^sub>?x `\n                    limit\n                     (run\\<^sub>t (\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n                       ?\\<iota>\\<^sub>m ?w) =\n                    limit (run\\<^sub>t (\\<delta>\\<^sub>m ?x) ?q\\<^sub>0 ?w)\n\ngoal (1 subgoal):\n 1. (\\<downharpoonleft>\\<^sub>k ` limit \\<rho> \\<inter> S = {}) =\n    (limit \\<rho>' \\<inter> S = {})", "by simp"], ["proof (state)\nthis:\n  (\\<downharpoonleft>\\<^sub>k ` limit \\<rho> \\<inter> S = {}) =\n  (limit \\<rho>' \\<inter> S = {})\n\ngoal (1 subgoal):\n 1. (limit \\<rho> \\<inter> \\<Union> (\\<upharpoonleft>\\<^sub>k ` S) = {}) =\n    (limit \\<rho>' \\<inter> S = {})", "finally"], ["proof (chain)\npicking this:\n  (limit \\<rho> \\<inter> \\<Union> (\\<upharpoonleft>\\<^sub>k ` S) = {}) =\n  (limit \\<rho>' \\<inter> S = {})", "show ?thesis"], ["proof (prove)\nusing this:\n  (limit \\<rho> \\<inter> \\<Union> (\\<upharpoonleft>\\<^sub>k ` S) = {}) =\n  (limit \\<rho>' \\<inter> S = {})\n\ngoal (1 subgoal):\n 1. (limit \\<rho> \\<inter> \\<Union> (\\<upharpoonleft>\\<^sub>k ` S) = {}) =\n    (limit \\<rho>' \\<inter> S = {})", "by simp"], ["proof (state)\nthis:\n  (limit \\<rho> \\<inter> \\<Union> (\\<upharpoonleft>\\<^sub>k ` S) = {}) =\n  (limit \\<rho>' \\<inter> S = {})\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Transfer Rules\\<close>"], ["", "context includes lifting_syntax\nbegin"], ["", "lemma product_parametric [transfer_rule]:\n  \"((A ===> B ===> C ===> B) ===> (A ===> rel_option B) ===> C ===> A ===> rel_option B) product product\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> B ===> C ===> B) ===>\n     (A ===> rel_option B) ===> C ===> A ===> rel_option B)\n     \\<Delta>\\<^sub>\\<times> \\<Delta>\\<^sub>\\<times>", "by (auto simp add: rel_fun_def rel_option_iff split: option.split)"], ["", "lemma run_parametric [transfer_rule]:\n  \"((A ===> B ===> A) ===> A ===> ((=) ===> B) ===> (=) ===> A) run run\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> B ===> A) ===> A ===> ((=) ===> B) ===> (=) ===> A) run run", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((A ===> B ===> A) ===> A ===> ((=) ===> B) ===> (=) ===> A) run run", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. ((A ===> B ===> A) ===> A ===> ((=) ===> B) ===> (=) ===> A) run run", "fix \\<delta> \\<delta>' q q' n w"], ["proof (state)\ngoal (1 subgoal):\n 1. ((A ===> B ===> A) ===> A ===> ((=) ===> B) ===> (=) ===> A) run run", "fix w' :: \"nat \\<Rightarrow> 'd\""], ["proof (state)\ngoal (1 subgoal):\n 1. ((A ===> B ===> A) ===> A ===> ((=) ===> B) ===> (=) ===> A) run run", "assume \"(A ===> B ===> A) \\<delta> \\<delta>'\" \"A q q'\" \"((=) ===> B) w w'\""], ["proof (state)\nthis:\n  (A ===> B ===> A) \\<delta> \\<delta>'\n  A q q'\n  ((=) ===> B) w w'\n\ngoal (1 subgoal):\n 1. ((A ===> B ===> A) ===> A ===> ((=) ===> B) ===> (=) ===> A) run run", "hence \"A (run \\<delta> q w n) (run \\<delta>' q' w' n)\""], ["proof (prove)\nusing this:\n  (A ===> B ===> A) \\<delta> \\<delta>'\n  A q q'\n  ((=) ===> B) w w'\n\ngoal (1 subgoal):\n 1. A (run \\<delta> q w n) (run \\<delta>' q' w' n)", "by (induction n) (simp_all add: rel_fun_def)"], ["proof (state)\nthis:\n  A (run \\<delta> q w n) (run \\<delta>' q' w' n)\n\ngoal (1 subgoal):\n 1. ((A ===> B ===> A) ===> A ===> ((=) ===> B) ===> (=) ===> A) run run", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(A ===> B ===> A) ?\\<delta>2 ?\\<delta>'2; A ?q2 ?q'2;\n   ((=) ===> B) ?w2 ?w'2\\<rbrakk>\n  \\<Longrightarrow> A (run ?\\<delta>2 ?q2 ?w2 ?n2)\n                     (run ?\\<delta>'2 ?q'2 ?w'2 ?n2)\n\ngoal (1 subgoal):\n 1. ((A ===> B ===> A) ===> A ===> ((=) ===> B) ===> (=) ===> A) run run", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(A ===> B ===> A) ?\\<delta>2 ?\\<delta>'2; A ?q2 ?q'2;\n   ((=) ===> B) ?w2 ?w'2\\<rbrakk>\n  \\<Longrightarrow> A (run ?\\<delta>2 ?q2 ?w2 ?n2)\n                     (run ?\\<delta>'2 ?q'2 ?w'2 ?n2)\n\ngoal (1 subgoal):\n 1. ((A ===> B ===> A) ===> A ===> ((=) ===> B) ===> (=) ===> A) run run", "by blast"], ["proof (state)\nthis:\n  ((A ===> B ===> A) ===> A ===> ((=) ===> B) ===> (=) ===> A) run run\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reach_parametric [transfer_rule]:\n  assumes \"bi_total B\"\n  assumes \"bi_unique B\"\n  shows \"(rel_set B ===> (A ===> B ===> A) ===> A ===> rel_set A) reach reach\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set B ===> (A ===> B ===> A) ===> A ===> rel_set A) reach reach", "proof standard+"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>rel_set B x y; (A ===> B ===> A) xa ya; A xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_set A (reach x xa xb) (reach y ya yb)", "fix \\<Sigma> \\<Sigma>' \\<delta> \\<delta>' q q'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>rel_set B x y; (A ===> B ===> A) xa ya; A xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_set A (reach x xa xb) (reach y ya yb)", "assume \"rel_set B \\<Sigma> \\<Sigma>'\" \"(A ===> B ===> A) \\<delta> \\<delta>'\" \"A q q'\""], ["proof (state)\nthis:\n  rel_set B \\<Sigma> \\<Sigma>'\n  (A ===> B ===> A) \\<delta> \\<delta>'\n  A q q'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>rel_set B x y; (A ===> B ===> A) xa ya; A xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_set A (reach x xa xb) (reach y ya yb)", "{"], ["proof (state)\nthis:\n  rel_set B \\<Sigma> \\<Sigma>'\n  (A ===> B ===> A) \\<delta> \\<delta>'\n  A q q'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>rel_set B x y; (A ===> B ===> A) xa ya; A xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_set A (reach x xa xb) (reach y ya yb)", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>rel_set B x y; (A ===> B ===> A) xa ya; A xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_set A (reach x xa xb) (reach y ya yb)", "assume \"z \\<in> reach \\<Sigma> \\<delta> q\""], ["proof (state)\nthis:\n  z \\<in> reach \\<Sigma> \\<delta> q\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>rel_set B x y; (A ===> B ===> A) xa ya; A xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_set A (reach x xa xb) (reach y ya yb)", "then"], ["proof (chain)\npicking this:\n  z \\<in> reach \\<Sigma> \\<delta> q", "obtain w n where \"z = run \\<delta> q w n\" and \"range w \\<subseteq> \\<Sigma>\""], ["proof (prove)\nusing this:\n  z \\<in> reach \\<Sigma> \\<delta> q\n\ngoal (1 subgoal):\n 1. (\\<And>w n.\n        \\<lbrakk>z = run \\<delta> q w n;\n         range w \\<subseteq> \\<Sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding reach_def"], ["proof (prove)\nusing this:\n  z \\<in> {run \\<delta> q w n |w n. range w \\<subseteq> \\<Sigma>}\n\ngoal (1 subgoal):\n 1. (\\<And>w n.\n        \\<lbrakk>z = run \\<delta> q w n;\n         range w \\<subseteq> \\<Sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  z = run \\<delta> q w n\n  range w \\<subseteq> \\<Sigma>\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>rel_set B x y; (A ===> B ===> A) xa ya; A xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_set A (reach x xa xb) (reach y ya yb)", "define w' where \"w' n = (SOME x. B (w n) x)\" for n"], ["proof (state)\nthis:\n  w' ?n = (SOME x. B (w ?n) x)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>rel_set B x y; (A ===> B ===> A) xa ya; A xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_set A (reach x xa xb) (reach y ya yb)", "have \"\\<And>n. w n \\<in> \\<Sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n. w n \\<in> \\<Sigma>", "using \\<open>range w \\<subseteq> \\<Sigma>\\<close>"], ["proof (prove)\nusing this:\n  range w \\<subseteq> \\<Sigma>\n\ngoal (1 subgoal):\n 1. \\<And>n. w n \\<in> \\<Sigma>", "by blast"], ["proof (state)\nthis:\n  w ?n \\<in> \\<Sigma>\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>rel_set B x y; (A ===> B ===> A) xa ya; A xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_set A (reach x xa xb) (reach y ya yb)", "hence \"\\<And>n. w' n \\<in> \\<Sigma>'\""], ["proof (prove)\nusing this:\n  w ?n \\<in> \\<Sigma>\n\ngoal (1 subgoal):\n 1. \\<And>n. w' n \\<in> \\<Sigma>'", "using assms \\<open>rel_set B \\<Sigma> \\<Sigma>'\\<close>"], ["proof (prove)\nusing this:\n  w ?n \\<in> \\<Sigma>\n  bi_total B\n  bi_unique B\n  rel_set B \\<Sigma> \\<Sigma>'\n\ngoal (1 subgoal):\n 1. \\<And>n. w' n \\<in> \\<Sigma>'", "by (simp add: w'_def bi_unique_def rel_set_def; metis someI)"], ["proof (state)\nthis:\n  w' ?n \\<in> \\<Sigma>'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>rel_set B x y; (A ===> B ===> A) xa ya; A xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_set A (reach x xa xb) (reach y ya yb)", "hence \"run \\<delta>' q' w' n \\<in> reach \\<Sigma>' \\<delta>' q'\""], ["proof (prove)\nusing this:\n  w' ?n \\<in> \\<Sigma>'\n\ngoal (1 subgoal):\n 1. run \\<delta>' q' w' n \\<in> reach \\<Sigma>' \\<delta>' q'", "unfolding reach_def"], ["proof (prove)\nusing this:\n  w' ?n \\<in> \\<Sigma>'\n\ngoal (1 subgoal):\n 1. run \\<delta>' q' w' n\n    \\<in> {run \\<delta>' q' w n |w n. range w \\<subseteq> \\<Sigma>'}", "by auto"], ["proof (state)\nthis:\n  run \\<delta>' q' w' n \\<in> reach \\<Sigma>' \\<delta>' q'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>rel_set B x y; (A ===> B ===> A) xa ya; A xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_set A (reach x xa xb) (reach y ya yb)", "moreover"], ["proof (state)\nthis:\n  run \\<delta>' q' w' n \\<in> reach \\<Sigma>' \\<delta>' q'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>rel_set B x y; (A ===> B ===> A) xa ya; A xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_set A (reach x xa xb) (reach y ya yb)", "have \"A z (run \\<delta>' q' w' n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A z (run \\<delta>' q' w' n)", "apply (unfold \\<open>z = run \\<delta> q w n\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. A (run \\<delta> q w n) (run \\<delta>' q' w' n)", "apply (insert \\<open>A q q'\\<close> \\<open>(A ===> B ===> A) \\<delta> \\<delta>'\\<close> assms(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A q q'; (A ===> B ===> A) \\<delta> \\<delta>';\n     bi_total B\\<rbrakk>\n    \\<Longrightarrow> A (run \\<delta> q w n) (run \\<delta>' q' w' n)", "apply (induction n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>A q q'; (A ===> B ===> A) \\<delta> \\<delta>';\n     bi_total B\\<rbrakk>\n    \\<Longrightarrow> A (run \\<delta> q w 0) (run \\<delta>' q' w' 0)\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>A q q'; (A ===> B ===> A) \\<delta> \\<delta>';\n                 bi_total B\\<rbrakk>\n                \\<Longrightarrow> A (run \\<delta> q w n)\n                                   (run \\<delta>' q' w' n);\n        A q q'; (A ===> B ===> A) \\<delta> \\<delta>'; bi_total B\\<rbrakk>\n       \\<Longrightarrow> A (run \\<delta> q w (Suc n))\n                          (run \\<delta>' q' w' (Suc n))", "apply (simp_all add: rel_fun_def bi_total_def w'_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>A (run \\<delta> q w n) (run \\<delta>' q' w' n); A q q';\n        \\<forall>x y.\n           A x y \\<longrightarrow>\n           (\\<forall>xa ya.\n               B xa ya \\<longrightarrow>\n               A (\\<delta> x xa) (\\<delta>' y ya));\n        (\\<forall>x. \\<exists>y. B x y) \\<and>\n        (\\<forall>y. \\<exists>x. B x y)\\<rbrakk>\n       \\<Longrightarrow> A (\\<delta> (run \\<delta> q w n) (w n))\n                          (\\<delta>' (run \\<delta>' q' w' n)\n                            (SOME x. B (w n) x))", "by (metis tfl_some)"], ["proof (state)\nthis:\n  A z (run \\<delta>' q' w' n)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>rel_set B x y; (A ===> B ===> A) xa ya; A xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_set A (reach x xa xb) (reach y ya yb)", "ultimately"], ["proof (chain)\npicking this:\n  run \\<delta>' q' w' n \\<in> reach \\<Sigma>' \\<delta>' q'\n  A z (run \\<delta>' q' w' n)", "have \"\\<exists>z' \\<in> reach \\<Sigma>' \\<delta>' q'. A z z'\""], ["proof (prove)\nusing this:\n  run \\<delta>' q' w' n \\<in> reach \\<Sigma>' \\<delta>' q'\n  A z (run \\<delta>' q' w' n)\n\ngoal (1 subgoal):\n 1. \\<exists>z'\\<in>reach \\<Sigma>' \\<delta>' q'. A z z'", "by blast"], ["proof (state)\nthis:\n  \\<exists>z'\\<in>reach \\<Sigma>' \\<delta>' q'. A z z'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>rel_set B x y; (A ===> B ===> A) xa ya; A xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_set A (reach x xa xb) (reach y ya yb)", "}"], ["proof (state)\nthis:\n  ?z2 \\<in> reach \\<Sigma> \\<delta> q \\<Longrightarrow>\n  \\<exists>z'\\<in>reach \\<Sigma>' \\<delta>' q'. A ?z2 z'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>rel_set B x y; (A ===> B ===> A) xa ya; A xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_set A (reach x xa xb) (reach y ya yb)", "moreover"], ["proof (state)\nthis:\n  ?z2 \\<in> reach \\<Sigma> \\<delta> q \\<Longrightarrow>\n  \\<exists>z'\\<in>reach \\<Sigma>' \\<delta>' q'. A ?z2 z'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>rel_set B x y; (A ===> B ===> A) xa ya; A xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_set A (reach x xa xb) (reach y ya yb)", "{"], ["proof (state)\nthis:\n  ?z2 \\<in> reach \\<Sigma> \\<delta> q \\<Longrightarrow>\n  \\<exists>z'\\<in>reach \\<Sigma>' \\<delta>' q'. A ?z2 z'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>rel_set B x y; (A ===> B ===> A) xa ya; A xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_set A (reach x xa xb) (reach y ya yb)", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>rel_set B x y; (A ===> B ===> A) xa ya; A xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_set A (reach x xa xb) (reach y ya yb)", "assume \"z \\<in> reach \\<Sigma>' \\<delta>' q'\""], ["proof (state)\nthis:\n  z \\<in> reach \\<Sigma>' \\<delta>' q'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>rel_set B x y; (A ===> B ===> A) xa ya; A xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_set A (reach x xa xb) (reach y ya yb)", "then"], ["proof (chain)\npicking this:\n  z \\<in> reach \\<Sigma>' \\<delta>' q'", "obtain w n where \"z = run \\<delta>' q' w n\" and \"range w \\<subseteq> \\<Sigma>'\""], ["proof (prove)\nusing this:\n  z \\<in> reach \\<Sigma>' \\<delta>' q'\n\ngoal (1 subgoal):\n 1. (\\<And>w n.\n        \\<lbrakk>z = run \\<delta>' q' w n;\n         range w \\<subseteq> \\<Sigma>'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding reach_def"], ["proof (prove)\nusing this:\n  z \\<in> {run \\<delta>' q' w n |w n. range w \\<subseteq> \\<Sigma>'}\n\ngoal (1 subgoal):\n 1. (\\<And>w n.\n        \\<lbrakk>z = run \\<delta>' q' w n;\n         range w \\<subseteq> \\<Sigma>'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  z = run \\<delta>' q' w n\n  range w \\<subseteq> \\<Sigma>'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>rel_set B x y; (A ===> B ===> A) xa ya; A xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_set A (reach x xa xb) (reach y ya yb)", "define w' where \"w' n = (SOME x. B x (w n))\" for n"], ["proof (state)\nthis:\n  w' ?n = (SOME x. B x (w ?n))\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>rel_set B x y; (A ===> B ===> A) xa ya; A xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_set A (reach x xa xb) (reach y ya yb)", "have \"\\<And>n. w n \\<in> \\<Sigma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n. w n \\<in> \\<Sigma>'", "using \\<open>range w \\<subseteq> \\<Sigma>'\\<close>"], ["proof (prove)\nusing this:\n  range w \\<subseteq> \\<Sigma>'\n\ngoal (1 subgoal):\n 1. \\<And>n. w n \\<in> \\<Sigma>'", "by blast"], ["proof (state)\nthis:\n  w ?n \\<in> \\<Sigma>'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>rel_set B x y; (A ===> B ===> A) xa ya; A xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_set A (reach x xa xb) (reach y ya yb)", "hence \"\\<And>n. w' n \\<in> \\<Sigma>\""], ["proof (prove)\nusing this:\n  w ?n \\<in> \\<Sigma>'\n\ngoal (1 subgoal):\n 1. \\<And>n. w' n \\<in> \\<Sigma>", "using assms \\<open>rel_set B \\<Sigma> \\<Sigma>'\\<close>"], ["proof (prove)\nusing this:\n  w ?n \\<in> \\<Sigma>'\n  bi_total B\n  bi_unique B\n  rel_set B \\<Sigma> \\<Sigma>'\n\ngoal (1 subgoal):\n 1. \\<And>n. w' n \\<in> \\<Sigma>", "by (simp add: w'_def bi_unique_def rel_set_def; metis someI)"], ["proof (state)\nthis:\n  w' ?n \\<in> \\<Sigma>\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>rel_set B x y; (A ===> B ===> A) xa ya; A xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_set A (reach x xa xb) (reach y ya yb)", "hence \"run \\<delta> q w' n \\<in> reach \\<Sigma> \\<delta> q\""], ["proof (prove)\nusing this:\n  w' ?n \\<in> \\<Sigma>\n\ngoal (1 subgoal):\n 1. run \\<delta> q w' n \\<in> reach \\<Sigma> \\<delta> q", "unfolding reach_def"], ["proof (prove)\nusing this:\n  w' ?n \\<in> \\<Sigma>\n\ngoal (1 subgoal):\n 1. run \\<delta> q w' n\n    \\<in> {run \\<delta> q w n |w n. range w \\<subseteq> \\<Sigma>}", "by auto"], ["proof (state)\nthis:\n  run \\<delta> q w' n \\<in> reach \\<Sigma> \\<delta> q\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>rel_set B x y; (A ===> B ===> A) xa ya; A xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_set A (reach x xa xb) (reach y ya yb)", "moreover"], ["proof (state)\nthis:\n  run \\<delta> q w' n \\<in> reach \\<Sigma> \\<delta> q\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>rel_set B x y; (A ===> B ===> A) xa ya; A xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_set A (reach x xa xb) (reach y ya yb)", "have \"A (run \\<delta> q w' n) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A (run \\<delta> q w' n) z", "apply (unfold \\<open>z = run \\<delta>' q' w n\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. A (run \\<delta> q w' n) (run \\<delta>' q' w n)", "apply (insert \\<open>A q q'\\<close> \\<open>(A ===> B ===> A) \\<delta> \\<delta>'\\<close> assms(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A q q'; (A ===> B ===> A) \\<delta> \\<delta>';\n     bi_total B\\<rbrakk>\n    \\<Longrightarrow> A (run \\<delta> q w' n) (run \\<delta>' q' w n)", "apply (induction n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>A q q'; (A ===> B ===> A) \\<delta> \\<delta>';\n     bi_total B\\<rbrakk>\n    \\<Longrightarrow> A (run \\<delta> q w' 0) (run \\<delta>' q' w 0)\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>A q q'; (A ===> B ===> A) \\<delta> \\<delta>';\n                 bi_total B\\<rbrakk>\n                \\<Longrightarrow> A (run \\<delta> q w' n)\n                                   (run \\<delta>' q' w n);\n        A q q'; (A ===> B ===> A) \\<delta> \\<delta>'; bi_total B\\<rbrakk>\n       \\<Longrightarrow> A (run \\<delta> q w' (Suc n))\n                          (run \\<delta>' q' w (Suc n))", "apply (simp_all add: rel_fun_def bi_total_def w'_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>A (run \\<delta> q w' n) (run \\<delta>' q' w n); A q q';\n        \\<forall>x y.\n           A x y \\<longrightarrow>\n           (\\<forall>xa ya.\n               B xa ya \\<longrightarrow>\n               A (\\<delta> x xa) (\\<delta>' y ya));\n        (\\<forall>x. \\<exists>y. B x y) \\<and>\n        (\\<forall>y. \\<exists>x. B x y)\\<rbrakk>\n       \\<Longrightarrow> A (\\<delta> (run \\<delta> q w' n)\n                             (SOME x. B x (w n)))\n                          (\\<delta>' (run \\<delta>' q' w n) (w n))", "by (metis tfl_some)"], ["proof (state)\nthis:\n  A (run \\<delta> q w' n) z\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>rel_set B x y; (A ===> B ===> A) xa ya; A xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_set A (reach x xa xb) (reach y ya yb)", "ultimately"], ["proof (chain)\npicking this:\n  run \\<delta> q w' n \\<in> reach \\<Sigma> \\<delta> q\n  A (run \\<delta> q w' n) z", "have \"\\<exists>z' \\<in> reach \\<Sigma> \\<delta> q. A z' z\""], ["proof (prove)\nusing this:\n  run \\<delta> q w' n \\<in> reach \\<Sigma> \\<delta> q\n  A (run \\<delta> q w' n) z\n\ngoal (1 subgoal):\n 1. \\<exists>z'\\<in>reach \\<Sigma> \\<delta> q. A z' z", "by blast"], ["proof (state)\nthis:\n  \\<exists>z'\\<in>reach \\<Sigma> \\<delta> q. A z' z\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>rel_set B x y; (A ===> B ===> A) xa ya; A xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_set A (reach x xa xb) (reach y ya yb)", "}"], ["proof (state)\nthis:\n  ?z2 \\<in> reach \\<Sigma>' \\<delta>' q' \\<Longrightarrow>\n  \\<exists>z'\\<in>reach \\<Sigma> \\<delta> q. A z' ?z2\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>rel_set B x y; (A ===> B ===> A) xa ya; A xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_set A (reach x xa xb) (reach y ya yb)", "ultimately"], ["proof (chain)\npicking this:\n  ?z2 \\<in> reach \\<Sigma> \\<delta> q \\<Longrightarrow>\n  \\<exists>z'\\<in>reach \\<Sigma>' \\<delta>' q'. A ?z2 z'\n  ?z2 \\<in> reach \\<Sigma>' \\<delta>' q' \\<Longrightarrow>\n  \\<exists>z'\\<in>reach \\<Sigma> \\<delta> q. A z' ?z2", "show \"rel_set A (reach \\<Sigma> \\<delta> q) (reach \\<Sigma>' \\<delta>' q')\""], ["proof (prove)\nusing this:\n  ?z2 \\<in> reach \\<Sigma> \\<delta> q \\<Longrightarrow>\n  \\<exists>z'\\<in>reach \\<Sigma>' \\<delta>' q'. A ?z2 z'\n  ?z2 \\<in> reach \\<Sigma>' \\<delta>' q' \\<Longrightarrow>\n  \\<exists>z'\\<in>reach \\<Sigma> \\<delta> q. A z' ?z2\n\ngoal (1 subgoal):\n 1. rel_set A (reach \\<Sigma> \\<delta> q) (reach \\<Sigma>' \\<delta>' q')", "unfolding rel_set_def"], ["proof (prove)\nusing this:\n  ?z2 \\<in> reach \\<Sigma> \\<delta> q \\<Longrightarrow>\n  \\<exists>z'\\<in>reach \\<Sigma>' \\<delta>' q'. A ?z2 z'\n  ?z2 \\<in> reach \\<Sigma>' \\<delta>' q' \\<Longrightarrow>\n  \\<exists>z'\\<in>reach \\<Sigma> \\<delta> q. A z' ?z2\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>reach \\<Sigma> \\<delta> q.\n        Bex (reach \\<Sigma>' \\<delta>' q') (A x)) \\<and>\n    (\\<forall>y\\<in>reach \\<Sigma>' \\<delta>' q'.\n        \\<exists>x\\<in>reach \\<Sigma> \\<delta> q. A x y)", "by blast"], ["proof (state)\nthis:\n  rel_set A (reach \\<Sigma> \\<delta> q) (reach \\<Sigma>' \\<delta>' q')\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Lift to Mapping\\<close>"], ["", "lift_definition product_abs :: \"('a \\<Rightarrow> ('b, 'c) DTS) \\<Rightarrow> (('a, 'b) mapping, 'c) DTS\" (\"\\<up>\\<Delta>\\<^sub>\\<times>\") is product \n  parametric product_parametric"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma product_abs_run_None:\n  \"Mapping.lookup \\<iota>\\<^sub>m k = None \\<Longrightarrow> Mapping.lookup (run (\\<up>\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m w i) k = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.lookup \\<iota>\\<^sub>m k = None \\<Longrightarrow>\n    Mapping.lookup\n     (run (\\<up>\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m w\n       i)\n     k =\n    None", "by (transfer; insert product_run_None)"], ["", "lemma product_abs_run_Some:\n  \"Mapping.lookup \\<iota>\\<^sub>m k = Some q\\<^sub>0 \\<Longrightarrow> Mapping.lookup (run (\\<up>\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m w i) k = Some (run (\\<delta>\\<^sub>m k) q\\<^sub>0 w i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.lookup \\<iota>\\<^sub>m k = Some q\\<^sub>0 \\<Longrightarrow>\n    Mapping.lookup\n     (run (\\<up>\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m w\n       i)\n     k =\n    Some (run (\\<delta>\\<^sub>m k) q\\<^sub>0 w i)", "by (transfer; insert product_run_Some)"], ["", "theorem finite_reach_product_abs:\n  assumes \"finite (Mapping.keys \\<iota>\\<^sub>m)\"\n  assumes \"\\<And>x. x \\<in> (Mapping.keys \\<iota>\\<^sub>m) \\<Longrightarrow> finite (reach \\<Sigma> (\\<delta>\\<^sub>m x) (the (Mapping.lookup \\<iota>\\<^sub>m x)))\"\n  shows \"finite (reach \\<Sigma> (\\<up>\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m) \\<iota>\\<^sub>m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (reach \\<Sigma> (\\<up>\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n       \\<iota>\\<^sub>m)", "using assms"], ["proof (prove)\nusing this:\n  finite (Mapping.keys \\<iota>\\<^sub>m)\n  ?x \\<in> Mapping.keys \\<iota>\\<^sub>m \\<Longrightarrow>\n  finite\n   (reach \\<Sigma> (\\<delta>\\<^sub>m ?x)\n     (the (Mapping.lookup \\<iota>\\<^sub>m ?x)))\n\ngoal (1 subgoal):\n 1. finite\n     (reach \\<Sigma> (\\<up>\\<Delta>\\<^sub>\\<times> \\<delta>\\<^sub>m)\n       \\<iota>\\<^sub>m)", "by (transfer; blast intro: finite_reach_product)"], ["", "end"]]}