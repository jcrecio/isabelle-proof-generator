{"file_name": "/home/qj213/afp-2021-10-22/thys/LTL_to_DRA/Auxiliary/List2.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/LTL_to_DRA", "problem_names": ["lemma remdups_fwd_acc_append[simp]:\n  \"remdups_fwd_acc Acc (xs@ys) = (remdups_fwd_acc Acc xs) @ (remdups_fwd_acc (Acc \\<union> set xs) ys)\"", "lemma remdups_fwd_acc_set[simp]:\n  \"set (remdups_fwd_acc Acc xs) = set xs - Acc\"", "lemma remdups_fwd_acc_distinct:\n  \"distinct (remdups_fwd_acc Acc xs)\"", "lemma remdups_fwd_acc_empty:\n  \"set xs \\<subseteq> Acc \\<longleftrightarrow> remdups_fwd_acc Acc xs = []\"", "lemma remdups_fwd_acc_drop:\n  \"set ys \\<subseteq> Acc \\<union> set xs \\<Longrightarrow> remdups_fwd_acc Acc (xs @ ys @ zs) = remdups_fwd_acc Acc (xs @ zs)\"", "lemma remdups_fwd_acc_filter:\n  \"remdups_fwd_acc Acc (filter P xs) = filter P (remdups_fwd_acc Acc xs)\"", "lemma remdups_fwd_eq:\n  \"remdups_fwd xs = (rev o remdups o rev) xs\"", "lemma remdups_fwd_set[simp]:\n  \"set (remdups_fwd xs) = set xs\"", "lemma remdups_fwd_distinct:\n  \"distinct (remdups_fwd xs)\"", "lemma remdups_fwd_filter:\n  \"remdups_fwd (filter P xs) = filter P (remdups_fwd xs)\"", "lemma map_splitE:\n  assumes \"map f xs = ys @ zs\"\n  obtains us vs where \"xs = us @ vs\" and \"map f us = ys\" and \"map f vs = zs\"", "lemma filter_split':\n  \"filter P xs = ys @ zs \\<Longrightarrow> \\<exists>us vs. xs = us @ vs \\<and> filter P us = ys \\<and> filter P vs = zs\"", "lemma filter_splitE:\n  assumes \"filter P xs = ys @ zs\"\n  obtains us vs where \"xs = us @ vs\" and \"filter P us = ys\" and \"filter P vs = zs\"", "lemma filter_map_splitE:\n  assumes \"filter P (map f xs) = ys @ zs\"\n  obtains us vs where \"xs = us @ vs\" and \"filter P (map f us) = ys\" and \"filter P (map f vs) = zs\"", "lemma filter_map_split_iff:\n  \"filter P (map f xs) = ys @ zs \\<longleftrightarrow> (\\<exists>us vs. xs = us @ vs \\<and> filter P (map f us) = ys \\<and> filter P (map f vs) = zs)\"", "lemma list_empty_prefix:\n  \"xs @ y # zs = y # us \\<Longrightarrow> y \\<notin> set xs \\<Longrightarrow> xs = []\"", "lemma remdups_fwd_split:\n  \"remdups_fwd_acc Acc xs = ys @ zs \\<Longrightarrow> \\<exists>us vs. xs = us @ vs \\<and> remdups_fwd_acc Acc us = ys \\<and> remdups_fwd_acc (Acc \\<union> set ys) vs = zs\"", "lemma remdups_fwd_split_exact:\n  assumes \"remdups_fwd_acc Acc xs = ys @ x # zs\"\n  shows \"\\<exists>us vs. xs = us @ x # vs \\<and> x \\<notin> Acc \\<and> x \\<notin> set ys \\<and> remdups_fwd_acc Acc us = ys \\<and> remdups_fwd_acc (Acc \\<union> set ys \\<union> {x}) vs = zs\"", "lemma remdups_fwd_split_exactE:\n  assumes \"remdups_fwd_acc Acc xs = ys @ x # zs\"\n  obtains us vs where \"xs = us @ x # vs\" and \"x \\<notin> set us\" and \"remdups_fwd_acc Acc us = ys\" and \"remdups_fwd_acc (Acc \\<union> set ys \\<union> {x}) vs = zs\"", "lemma remdups_fwd_split_exact_iff:\n  \"remdups_fwd_acc Acc xs = ys @ x # zs \\<longleftrightarrow> \n    (\\<exists>us vs. xs = us @ x # vs \\<and> x \\<notin> Acc \\<and> x \\<notin> set us \\<and> remdups_fwd_acc Acc us = ys \\<and> remdups_fwd_acc (Acc \\<union> set ys \\<union> {x}) vs = zs)\"", "lemma sorted_pre:\n  \"(\\<And>x y xs ys. zs = xs @ [x, y] @ ys \\<Longrightarrow> x \\<le> y) \\<Longrightarrow> sorted zs\"", "lemma sorted_list:\n  assumes \"x \\<in> set xs\" and \"y \\<in> set xs\"\n  assumes \"sorted (map f xs)\" and \"f x < f y\"\n  shows \"\\<exists>xs' xs'' xs'''. xs = xs' @ x # xs'' @ y # xs'''\"", "lemma takeWhile_foo:\n  \"x \\<notin> set ys \\<Longrightarrow> ys = takeWhile (\\<lambda>y. y \\<noteq> x) (ys @ x # zs)\"", "lemma takeWhile_split:\n  \"x \\<in> set xs \\<Longrightarrow> y \\<in> set (takeWhile (\\<lambda>y. y \\<noteq> x) xs) \\<Longrightarrow> \\<exists>xs' xs'' xs'''. xs = xs' @ y # xs'' @ x # xs'''\"", "lemma takeWhile_distinct:\n  \"distinct (xs' @ x # xs'') \\<Longrightarrow> y \\<in> set (takeWhile (\\<lambda>y. y \\<noteq> x) (xs' @ x # xs'')) \\<longleftrightarrow> y \\<in> set xs'\"", "lemma finite_lists_length_eqE:\n  assumes \"finite A\" \n  shows \"finite {xs. set xs = A \\<and> length xs = n}\"", "lemma finite_set2:\n  assumes \"card A = n\" and \"finite A\"\n  shows \"finite {xs. set xs = A \\<and> distinct xs}\"", "lemma set_list: \n  assumes \"finite (set ` XS)\"\n  assumes \"\\<And>xs. xs \\<in> XS \\<Longrightarrow> distinct xs\"\n  shows \"finite XS\"", "lemma set_foldl_append:\n  \"set (foldl (@) i xs) = set i \\<union> \\<Union>{set x | x. x \\<in> set xs}\"", "lemma foldl_break_append:\n  \"foldl_break f s a (xs @ ys) = (if s (foldl_break f s a xs) then foldl_break f s a xs else (foldl_break f s (foldl_break f s a xs) ys))\"", "lemma suffixes_append:\n  \"suffixes (xs @ ys) = (suffixes ys) @ (map (\\<lambda>zs. zs @ ys) (suffixes xs))\"", "lemma suffixes_alt_def:\n  \"suffixes xs = rev (prefix (length xs) (\\<lambda>i. drop i xs))\""], "translations": [["", "lemma remdups_fwd_acc_append[simp]:\n  \"remdups_fwd_acc Acc (xs@ys) = (remdups_fwd_acc Acc xs) @ (remdups_fwd_acc (Acc \\<union> set xs) ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remdups_fwd_acc Acc (xs @ ys) =\n    remdups_fwd_acc Acc xs @ remdups_fwd_acc (Acc \\<union> set xs) ys", "by (induction xs arbitrary: Acc) simp+"], ["", "lemma remdups_fwd_acc_set[simp]:\n  \"set (remdups_fwd_acc Acc xs) = set xs - Acc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (remdups_fwd_acc Acc xs) = set xs - Acc", "by (induction xs arbitrary: Acc) force+"], ["", "lemma remdups_fwd_acc_distinct:\n  \"distinct (remdups_fwd_acc Acc xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (remdups_fwd_acc Acc xs)", "by (induction xs arbitrary: Acc rule: rev_induct) simp+"], ["", "lemma remdups_fwd_acc_empty:\n  \"set xs \\<subseteq> Acc \\<longleftrightarrow> remdups_fwd_acc Acc xs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set xs \\<subseteq> Acc) = (remdups_fwd_acc Acc xs = [])", "by (metis remdups_fwd_acc_set set_empty Diff_eq_empty_iff Diff_eq_empty_iff)"], ["", "lemma remdups_fwd_acc_drop:\n  \"set ys \\<subseteq> Acc \\<union> set xs \\<Longrightarrow> remdups_fwd_acc Acc (xs @ ys @ zs) = remdups_fwd_acc Acc (xs @ zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ys \\<subseteq> Acc \\<union> set xs \\<Longrightarrow>\n    remdups_fwd_acc Acc (xs @ ys @ zs) = remdups_fwd_acc Acc (xs @ zs)", "by (simp add: remdups_fwd_acc_empty sup.absorb1)"], ["", "lemma remdups_fwd_acc_filter:\n  \"remdups_fwd_acc Acc (filter P xs) = filter P (remdups_fwd_acc Acc xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remdups_fwd_acc Acc (filter P xs) = filter P (remdups_fwd_acc Acc xs)", "by (induction xs rule: rev_induct) simp+"], ["", "fun remdups_fwd\nwhere\n  \"remdups_fwd xs = remdups_fwd_acc {} xs \""], ["", "lemma remdups_fwd_eq:\n  \"remdups_fwd xs = (rev o remdups o rev) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remdups_fwd xs = (rev \\<circ> remdups \\<circ> rev) xs", "by (induction xs rule: rev_induct) simp+"], ["", "lemma remdups_fwd_set[simp]:\n  \"set (remdups_fwd xs) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (remdups_fwd xs) = set xs", "by simp"], ["", "lemma remdups_fwd_distinct:\n  \"distinct (remdups_fwd xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (remdups_fwd xs)", "using remdups_fwd_acc_distinct"], ["proof (prove)\nusing this:\n  distinct (remdups_fwd_acc ?Acc ?xs)\n\ngoal (1 subgoal):\n 1. distinct (remdups_fwd xs)", "by simp"], ["", "lemma remdups_fwd_filter:\n  \"remdups_fwd (filter P xs) = filter P (remdups_fwd xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remdups_fwd (filter P xs) = filter P (remdups_fwd xs)", "using remdups_fwd_acc_filter"], ["proof (prove)\nusing this:\n  remdups_fwd_acc ?Acc (filter ?P ?xs) =\n  filter ?P (remdups_fwd_acc ?Acc ?xs)\n\ngoal (1 subgoal):\n 1. remdups_fwd (filter P xs) = filter P (remdups_fwd xs)", "by simp"], ["", "subsection \\<open>Split Lemmas\\<close>"], ["", "lemma map_splitE:\n  assumes \"map f xs = ys @ zs\"\n  obtains us vs where \"xs = us @ vs\" and \"map f us = ys\" and \"map f vs = zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>us vs.\n        \\<lbrakk>xs = us @ vs; map f us = ys; map f vs = zs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (insert assms; induction ys arbitrary: xs) \n     (simp_all add: map_eq_Cons_conv, metis append_Cons)"], ["", "lemma filter_split':\n  \"filter P xs = ys @ zs \\<Longrightarrow> \\<exists>us vs. xs = us @ vs \\<and> filter P us = ys \\<and> filter P vs = zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter P xs = ys @ zs \\<Longrightarrow>\n    \\<exists>us vs.\n       xs = us @ vs \\<and> filter P us = ys \\<and> filter P vs = zs", "proof (induction ys arbitrary: zs xs rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>zs xs.\n       filter P xs = [] @ zs \\<Longrightarrow>\n       \\<exists>us vs.\n          xs = us @ vs \\<and> filter P us = [] \\<and> filter P vs = zs\n 2. \\<And>x xs zs xsa.\n       \\<lbrakk>\\<And>zs xsa.\n                   filter P xsa = xs @ zs \\<Longrightarrow>\n                   \\<exists>us vs.\n                      xsa = us @ vs \\<and>\n                      filter P us = xs \\<and> filter P vs = zs;\n        filter P xsa = (xs @ [x]) @ zs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>us vs.\n                            xsa = us @ vs \\<and>\n                            filter P us = xs @ [x] \\<and> filter P vs = zs", "case (snoc y ys)"], ["proof (state)\nthis:\n  filter P ?xs = ys @ ?zs \\<Longrightarrow>\n  \\<exists>us vs.\n     ?xs = us @ vs \\<and> filter P us = ys \\<and> filter P vs = ?zs\n  filter P xs = (ys @ [y]) @ zs\n\ngoal (2 subgoals):\n 1. \\<And>zs xs.\n       filter P xs = [] @ zs \\<Longrightarrow>\n       \\<exists>us vs.\n          xs = us @ vs \\<and> filter P us = [] \\<and> filter P vs = zs\n 2. \\<And>x xs zs xsa.\n       \\<lbrakk>\\<And>zs xsa.\n                   filter P xsa = xs @ zs \\<Longrightarrow>\n                   \\<exists>us vs.\n                      xsa = us @ vs \\<and>\n                      filter P us = xs \\<and> filter P vs = zs;\n        filter P xsa = (xs @ [x]) @ zs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>us vs.\n                            xsa = us @ vs \\<and>\n                            filter P us = xs @ [x] \\<and> filter P vs = zs", "obtain us vs where \"xs = us @ vs\" and \"filter P us = ys\" and \"filter P vs = y # zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>us vs.\n        \\<lbrakk>xs = us @ vs; filter P us = ys;\n         filter P vs = y # zs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using snoc(1)[OF snoc(2)[unfolded append_assoc]]"], ["proof (prove)\nusing this:\n  \\<exists>us vs.\n     xs = us @ vs \\<and> filter P us = ys \\<and> filter P vs = [y] @ zs\n\ngoal (1 subgoal):\n 1. (\\<And>us vs.\n        \\<lbrakk>xs = us @ vs; filter P us = ys;\n         filter P vs = y # zs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  xs = us @ vs\n  filter P us = ys\n  filter P vs = y # zs\n\ngoal (2 subgoals):\n 1. \\<And>zs xs.\n       filter P xs = [] @ zs \\<Longrightarrow>\n       \\<exists>us vs.\n          xs = us @ vs \\<and> filter P us = [] \\<and> filter P vs = zs\n 2. \\<And>x xs zs xsa.\n       \\<lbrakk>\\<And>zs xsa.\n                   filter P xsa = xs @ zs \\<Longrightarrow>\n                   \\<exists>us vs.\n                      xsa = us @ vs \\<and>\n                      filter P us = xs \\<and> filter P vs = zs;\n        filter P xsa = (xs @ [x]) @ zs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>us vs.\n                            xsa = us @ vs \\<and>\n                            filter P us = xs @ [x] \\<and> filter P vs = zs", "moreover"], ["proof (state)\nthis:\n  xs = us @ vs\n  filter P us = ys\n  filter P vs = y # zs\n\ngoal (2 subgoals):\n 1. \\<And>zs xs.\n       filter P xs = [] @ zs \\<Longrightarrow>\n       \\<exists>us vs.\n          xs = us @ vs \\<and> filter P us = [] \\<and> filter P vs = zs\n 2. \\<And>x xs zs xsa.\n       \\<lbrakk>\\<And>zs xsa.\n                   filter P xsa = xs @ zs \\<Longrightarrow>\n                   \\<exists>us vs.\n                      xsa = us @ vs \\<and>\n                      filter P us = xs \\<and> filter P vs = zs;\n        filter P xsa = (xs @ [x]) @ zs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>us vs.\n                            xsa = us @ vs \\<and>\n                            filter P us = xs @ [x] \\<and> filter P vs = zs", "then"], ["proof (chain)\npicking this:\n  xs = us @ vs\n  filter P us = ys\n  filter P vs = y # zs", "obtain vs' vs'' where \"vs = vs' @ y # vs''\" and \"y \\<notin> set vs'\" and \"(\\<forall>u\\<in>set vs'. \\<not> P u)\" and \"filter P vs'' = zs\" and \"P y\""], ["proof (prove)\nusing this:\n  xs = us @ vs\n  filter P us = ys\n  filter P vs = y # zs\n\ngoal (1 subgoal):\n 1. (\\<And>vs' vs''.\n        \\<lbrakk>vs = vs' @ y # vs''; y \\<notin> set vs';\n         \\<forall>u\\<in>set vs'. \\<not> P u; filter P vs'' = zs;\n         P y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding filter_eq_Cons_iff"], ["proof (prove)\nusing this:\n  xs = us @ vs\n  filter P us = ys\n  \\<exists>us vsa.\n     vs = us @ y # vsa \\<and>\n     (\\<forall>u\\<in>set us. \\<not> P u) \\<and> P y \\<and> zs = filter P vsa\n\ngoal (1 subgoal):\n 1. (\\<And>vs' vs''.\n        \\<lbrakk>vs = vs' @ y # vs''; y \\<notin> set vs';\n         \\<forall>u\\<in>set vs'. \\<not> P u; filter P vs'' = zs;\n         P y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  vs = vs' @ y # vs''\n  y \\<notin> set vs'\n  \\<forall>u\\<in>set vs'. \\<not> P u\n  filter P vs'' = zs\n  P y\n\ngoal (2 subgoals):\n 1. \\<And>zs xs.\n       filter P xs = [] @ zs \\<Longrightarrow>\n       \\<exists>us vs.\n          xs = us @ vs \\<and> filter P us = [] \\<and> filter P vs = zs\n 2. \\<And>x xs zs xsa.\n       \\<lbrakk>\\<And>zs xsa.\n                   filter P xsa = xs @ zs \\<Longrightarrow>\n                   \\<exists>us vs.\n                      xsa = us @ vs \\<and>\n                      filter P us = xs \\<and> filter P vs = zs;\n        filter P xsa = (xs @ [x]) @ zs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>us vs.\n                            xsa = us @ vs \\<and>\n                            filter P us = xs @ [x] \\<and> filter P vs = zs", "ultimately"], ["proof (chain)\npicking this:\n  xs = us @ vs\n  filter P us = ys\n  filter P vs = y # zs\n  vs = vs' @ y # vs''\n  y \\<notin> set vs'\n  \\<forall>u\\<in>set vs'. \\<not> P u\n  filter P vs'' = zs\n  P y", "have \"xs = (us @ vs' @ [y]) @ vs''\" and \"filter P (us @ vs' @ [y]) = ys @ [y]\" and \"filter P (vs'') = zs\""], ["proof (prove)\nusing this:\n  xs = us @ vs\n  filter P us = ys\n  filter P vs = y # zs\n  vs = vs' @ y # vs''\n  y \\<notin> set vs'\n  \\<forall>u\\<in>set vs'. \\<not> P u\n  filter P vs'' = zs\n  P y\n\ngoal (1 subgoal):\n 1. xs = (us @ vs' @ [y]) @ vs'' &&&\n    filter P (us @ vs' @ [y]) = ys @ [y] &&& filter P vs'' = zs", "unfolding filter_append"], ["proof (prove)\nusing this:\n  xs = us @ vs\n  filter P us = ys\n  filter P vs = y # zs\n  vs = vs' @ y # vs''\n  y \\<notin> set vs'\n  \\<forall>u\\<in>set vs'. \\<not> P u\n  filter P vs'' = zs\n  P y\n\ngoal (1 subgoal):\n 1. xs = (us @ vs' @ [y]) @ vs'' &&&\n    filter P us @ filter P vs' @ filter P [y] = ys @ [y] &&&\n    filter P vs'' = zs", "by auto"], ["proof (state)\nthis:\n  xs = (us @ vs' @ [y]) @ vs''\n  filter P (us @ vs' @ [y]) = ys @ [y]\n  filter P vs'' = zs\n\ngoal (2 subgoals):\n 1. \\<And>zs xs.\n       filter P xs = [] @ zs \\<Longrightarrow>\n       \\<exists>us vs.\n          xs = us @ vs \\<and> filter P us = [] \\<and> filter P vs = zs\n 2. \\<And>x xs zs xsa.\n       \\<lbrakk>\\<And>zs xsa.\n                   filter P xsa = xs @ zs \\<Longrightarrow>\n                   \\<exists>us vs.\n                      xsa = us @ vs \\<and>\n                      filter P us = xs \\<and> filter P vs = zs;\n        filter P xsa = (xs @ [x]) @ zs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>us vs.\n                            xsa = us @ vs \\<and>\n                            filter P us = xs @ [x] \\<and> filter P vs = zs", "thus ?case"], ["proof (prove)\nusing this:\n  xs = (us @ vs' @ [y]) @ vs''\n  filter P (us @ vs' @ [y]) = ys @ [y]\n  filter P vs'' = zs\n\ngoal (1 subgoal):\n 1. \\<exists>us vs.\n       xs = us @ vs \\<and> filter P us = ys @ [y] \\<and> filter P vs = zs", "by blast"], ["proof (state)\nthis:\n  \\<exists>us vs.\n     xs = us @ vs \\<and> filter P us = ys @ [y] \\<and> filter P vs = zs\n\ngoal (1 subgoal):\n 1. \\<And>zs xs.\n       filter P xs = [] @ zs \\<Longrightarrow>\n       \\<exists>us vs.\n          xs = us @ vs \\<and> filter P us = [] \\<and> filter P vs = zs", "qed fastforce"], ["", "lemma filter_splitE:\n  assumes \"filter P xs = ys @ zs\"\n  obtains us vs where \"xs = us @ vs\" and \"filter P us = ys\" and \"filter P vs = zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>us vs.\n        \\<lbrakk>xs = us @ vs; filter P us = ys; filter P vs = zs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using filter_split'[OF assms]"], ["proof (prove)\nusing this:\n  \\<exists>us vs.\n     xs = us @ vs \\<and> filter P us = ys \\<and> filter P vs = zs\n\ngoal (1 subgoal):\n 1. (\\<And>us vs.\n        \\<lbrakk>xs = us @ vs; filter P us = ys; filter P vs = zs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["", "lemma filter_map_splitE:\n  assumes \"filter P (map f xs) = ys @ zs\"\n  obtains us vs where \"xs = us @ vs\" and \"filter P (map f us) = ys\" and \"filter P (map f vs) = zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>us vs.\n        \\<lbrakk>xs = us @ vs; filter P (map f us) = ys;\n         filter P (map f vs) = zs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  filter P (map f xs) = ys @ zs\n\ngoal (1 subgoal):\n 1. (\\<And>us vs.\n        \\<lbrakk>xs = us @ vs; filter P (map f us) = ys;\n         filter P (map f vs) = zs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce elim: filter_splitE map_splitE)"], ["", "lemma filter_map_split_iff:\n  \"filter P (map f xs) = ys @ zs \\<longleftrightarrow> (\\<exists>us vs. xs = us @ vs \\<and> filter P (map f us) = ys \\<and> filter P (map f vs) = zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (filter P (map f xs) = ys @ zs) =\n    (\\<exists>us vs.\n        xs = us @ vs \\<and>\n        filter P (map f us) = ys \\<and> filter P (map f vs) = zs)", "by (fastforce elim: filter_map_splitE)"], ["", "lemma list_empty_prefix:\n  \"xs @ y # zs = y # us \\<Longrightarrow> y \\<notin> set xs \\<Longrightarrow> xs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs @ y # zs = y # us; y \\<notin> set xs\\<rbrakk>\n    \\<Longrightarrow> xs = []", "by (metis hd_append2 list.sel(1) list.set_sel(1))"], ["", "lemma remdups_fwd_split:\n  \"remdups_fwd_acc Acc xs = ys @ zs \\<Longrightarrow> \\<exists>us vs. xs = us @ vs \\<and> remdups_fwd_acc Acc us = ys \\<and> remdups_fwd_acc (Acc \\<union> set ys) vs = zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remdups_fwd_acc Acc xs = ys @ zs \\<Longrightarrow>\n    \\<exists>us vs.\n       xs = us @ vs \\<and>\n       remdups_fwd_acc Acc us = ys \\<and>\n       remdups_fwd_acc (Acc \\<union> set ys) vs = zs", "proof (induction ys arbitrary: zs rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>zs.\n       remdups_fwd_acc Acc xs = [] @ zs \\<Longrightarrow>\n       \\<exists>us vs.\n          xs = us @ vs \\<and>\n          remdups_fwd_acc Acc us = [] \\<and>\n          remdups_fwd_acc (Acc \\<union> set []) vs = zs\n 2. \\<And>x xsa zs.\n       \\<lbrakk>\\<And>zs.\n                   remdups_fwd_acc Acc xs = xsa @ zs \\<Longrightarrow>\n                   \\<exists>us vs.\n                      xs = us @ vs \\<and>\n                      remdups_fwd_acc Acc us = xsa \\<and>\n                      remdups_fwd_acc (Acc \\<union> set xsa) vs = zs;\n        remdups_fwd_acc Acc xs = (xsa @ [x]) @ zs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>us vs.\n                            xs = us @ vs \\<and>\n                            remdups_fwd_acc Acc us = xsa @ [x] \\<and>\n                            remdups_fwd_acc (Acc \\<union> set (xsa @ [x]))\n                             vs =\n                            zs", "case (snoc y ys)"], ["proof (state)\nthis:\n  remdups_fwd_acc Acc xs = ys @ ?zs \\<Longrightarrow>\n  \\<exists>us vs.\n     xs = us @ vs \\<and>\n     remdups_fwd_acc Acc us = ys \\<and>\n     remdups_fwd_acc (Acc \\<union> set ys) vs = ?zs\n  remdups_fwd_acc Acc xs = (ys @ [y]) @ zs\n\ngoal (2 subgoals):\n 1. \\<And>zs.\n       remdups_fwd_acc Acc xs = [] @ zs \\<Longrightarrow>\n       \\<exists>us vs.\n          xs = us @ vs \\<and>\n          remdups_fwd_acc Acc us = [] \\<and>\n          remdups_fwd_acc (Acc \\<union> set []) vs = zs\n 2. \\<And>x xsa zs.\n       \\<lbrakk>\\<And>zs.\n                   remdups_fwd_acc Acc xs = xsa @ zs \\<Longrightarrow>\n                   \\<exists>us vs.\n                      xs = us @ vs \\<and>\n                      remdups_fwd_acc Acc us = xsa \\<and>\n                      remdups_fwd_acc (Acc \\<union> set xsa) vs = zs;\n        remdups_fwd_acc Acc xs = (xsa @ [x]) @ zs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>us vs.\n                            xs = us @ vs \\<and>\n                            remdups_fwd_acc Acc us = xsa @ [x] \\<and>\n                            remdups_fwd_acc (Acc \\<union> set (xsa @ [x]))\n                             vs =\n                            zs", "then"], ["proof (chain)\npicking this:\n  remdups_fwd_acc Acc xs = ys @ ?zs \\<Longrightarrow>\n  \\<exists>us vs.\n     xs = us @ vs \\<and>\n     remdups_fwd_acc Acc us = ys \\<and>\n     remdups_fwd_acc (Acc \\<union> set ys) vs = ?zs\n  remdups_fwd_acc Acc xs = (ys @ [y]) @ zs", "obtain us vs where \"xs = us @ vs\" \n      and \"remdups_fwd_acc Acc us = ys\" \n      and \"remdups_fwd_acc (Acc \\<union> set ys) vs = y # zs\""], ["proof (prove)\nusing this:\n  remdups_fwd_acc Acc xs = ys @ ?zs \\<Longrightarrow>\n  \\<exists>us vs.\n     xs = us @ vs \\<and>\n     remdups_fwd_acc Acc us = ys \\<and>\n     remdups_fwd_acc (Acc \\<union> set ys) vs = ?zs\n  remdups_fwd_acc Acc xs = (ys @ [y]) @ zs\n\ngoal (1 subgoal):\n 1. (\\<And>us vs.\n        \\<lbrakk>xs = us @ vs; remdups_fwd_acc Acc us = ys;\n         remdups_fwd_acc (Acc \\<union> set ys) vs = y # zs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs = us @ vs\n  remdups_fwd_acc Acc us = ys\n  remdups_fwd_acc (Acc \\<union> set ys) vs = y # zs\n\ngoal (2 subgoals):\n 1. \\<And>zs.\n       remdups_fwd_acc Acc xs = [] @ zs \\<Longrightarrow>\n       \\<exists>us vs.\n          xs = us @ vs \\<and>\n          remdups_fwd_acc Acc us = [] \\<and>\n          remdups_fwd_acc (Acc \\<union> set []) vs = zs\n 2. \\<And>x xsa zs.\n       \\<lbrakk>\\<And>zs.\n                   remdups_fwd_acc Acc xs = xsa @ zs \\<Longrightarrow>\n                   \\<exists>us vs.\n                      xs = us @ vs \\<and>\n                      remdups_fwd_acc Acc us = xsa \\<and>\n                      remdups_fwd_acc (Acc \\<union> set xsa) vs = zs;\n        remdups_fwd_acc Acc xs = (xsa @ [x]) @ zs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>us vs.\n                            xs = us @ vs \\<and>\n                            remdups_fwd_acc Acc us = xsa @ [x] \\<and>\n                            remdups_fwd_acc (Acc \\<union> set (xsa @ [x]))\n                             vs =\n                            zs", "moreover"], ["proof (state)\nthis:\n  xs = us @ vs\n  remdups_fwd_acc Acc us = ys\n  remdups_fwd_acc (Acc \\<union> set ys) vs = y # zs\n\ngoal (2 subgoals):\n 1. \\<And>zs.\n       remdups_fwd_acc Acc xs = [] @ zs \\<Longrightarrow>\n       \\<exists>us vs.\n          xs = us @ vs \\<and>\n          remdups_fwd_acc Acc us = [] \\<and>\n          remdups_fwd_acc (Acc \\<union> set []) vs = zs\n 2. \\<And>x xsa zs.\n       \\<lbrakk>\\<And>zs.\n                   remdups_fwd_acc Acc xs = xsa @ zs \\<Longrightarrow>\n                   \\<exists>us vs.\n                      xs = us @ vs \\<and>\n                      remdups_fwd_acc Acc us = xsa \\<and>\n                      remdups_fwd_acc (Acc \\<union> set xsa) vs = zs;\n        remdups_fwd_acc Acc xs = (xsa @ [x]) @ zs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>us vs.\n                            xs = us @ vs \\<and>\n                            remdups_fwd_acc Acc us = xsa @ [x] \\<and>\n                            remdups_fwd_acc (Acc \\<union> set (xsa @ [x]))\n                             vs =\n                            zs", "hence \"y \\<in> set vs\" and \"y \\<notin> Acc \\<union> set ys\""], ["proof (prove)\nusing this:\n  xs = us @ vs\n  remdups_fwd_acc Acc us = ys\n  remdups_fwd_acc (Acc \\<union> set ys) vs = y # zs\n\ngoal (1 subgoal):\n 1. y \\<in> set vs &&& y \\<notin> Acc \\<union> set ys", "using remdups_fwd_acc_set[of \"Acc \\<union> set ys\" vs]"], ["proof (prove)\nusing this:\n  xs = us @ vs\n  remdups_fwd_acc Acc us = ys\n  remdups_fwd_acc (Acc \\<union> set ys) vs = y # zs\n  set (remdups_fwd_acc (Acc \\<union> set ys) vs) =\n  set vs - (Acc \\<union> set ys)\n\ngoal (1 subgoal):\n 1. y \\<in> set vs &&& y \\<notin> Acc \\<union> set ys", "by auto"], ["proof (state)\nthis:\n  y \\<in> set vs\n  y \\<notin> Acc \\<union> set ys\n\ngoal (2 subgoals):\n 1. \\<And>zs.\n       remdups_fwd_acc Acc xs = [] @ zs \\<Longrightarrow>\n       \\<exists>us vs.\n          xs = us @ vs \\<and>\n          remdups_fwd_acc Acc us = [] \\<and>\n          remdups_fwd_acc (Acc \\<union> set []) vs = zs\n 2. \\<And>x xsa zs.\n       \\<lbrakk>\\<And>zs.\n                   remdups_fwd_acc Acc xs = xsa @ zs \\<Longrightarrow>\n                   \\<exists>us vs.\n                      xs = us @ vs \\<and>\n                      remdups_fwd_acc Acc us = xsa \\<and>\n                      remdups_fwd_acc (Acc \\<union> set xsa) vs = zs;\n        remdups_fwd_acc Acc xs = (xsa @ [x]) @ zs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>us vs.\n                            xs = us @ vs \\<and>\n                            remdups_fwd_acc Acc us = xsa @ [x] \\<and>\n                            remdups_fwd_acc (Acc \\<union> set (xsa @ [x]))\n                             vs =\n                            zs", "moreover"], ["proof (state)\nthis:\n  y \\<in> set vs\n  y \\<notin> Acc \\<union> set ys\n\ngoal (2 subgoals):\n 1. \\<And>zs.\n       remdups_fwd_acc Acc xs = [] @ zs \\<Longrightarrow>\n       \\<exists>us vs.\n          xs = us @ vs \\<and>\n          remdups_fwd_acc Acc us = [] \\<and>\n          remdups_fwd_acc (Acc \\<union> set []) vs = zs\n 2. \\<And>x xsa zs.\n       \\<lbrakk>\\<And>zs.\n                   remdups_fwd_acc Acc xs = xsa @ zs \\<Longrightarrow>\n                   \\<exists>us vs.\n                      xs = us @ vs \\<and>\n                      remdups_fwd_acc Acc us = xsa \\<and>\n                      remdups_fwd_acc (Acc \\<union> set xsa) vs = zs;\n        remdups_fwd_acc Acc xs = (xsa @ [x]) @ zs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>us vs.\n                            xs = us @ vs \\<and>\n                            remdups_fwd_acc Acc us = xsa @ [x] \\<and>\n                            remdups_fwd_acc (Acc \\<union> set (xsa @ [x]))\n                             vs =\n                            zs", "then"], ["proof (chain)\npicking this:\n  y \\<in> set vs\n  y \\<notin> Acc \\<union> set ys", "obtain vs' vs'' where \"vs = vs' @ y # vs''\" and \"y \\<notin> set vs'\""], ["proof (prove)\nusing this:\n  y \\<in> set vs\n  y \\<notin> Acc \\<union> set ys\n\ngoal (1 subgoal):\n 1. (\\<And>vs' vs''.\n        \\<lbrakk>vs = vs' @ y # vs''; y \\<notin> set vs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using split_list_first"], ["proof (prove)\nusing this:\n  y \\<in> set vs\n  y \\<notin> Acc \\<union> set ys\n  ?x \\<in> set ?xs \\<Longrightarrow>\n  \\<exists>ys zs. ?xs = ys @ ?x # zs \\<and> ?x \\<notin> set ys\n\ngoal (1 subgoal):\n 1. (\\<And>vs' vs''.\n        \\<lbrakk>vs = vs' @ y # vs''; y \\<notin> set vs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  vs = vs' @ y # vs''\n  y \\<notin> set vs'\n\ngoal (2 subgoals):\n 1. \\<And>zs.\n       remdups_fwd_acc Acc xs = [] @ zs \\<Longrightarrow>\n       \\<exists>us vs.\n          xs = us @ vs \\<and>\n          remdups_fwd_acc Acc us = [] \\<and>\n          remdups_fwd_acc (Acc \\<union> set []) vs = zs\n 2. \\<And>x xsa zs.\n       \\<lbrakk>\\<And>zs.\n                   remdups_fwd_acc Acc xs = xsa @ zs \\<Longrightarrow>\n                   \\<exists>us vs.\n                      xs = us @ vs \\<and>\n                      remdups_fwd_acc Acc us = xsa \\<and>\n                      remdups_fwd_acc (Acc \\<union> set xsa) vs = zs;\n        remdups_fwd_acc Acc xs = (xsa @ [x]) @ zs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>us vs.\n                            xs = us @ vs \\<and>\n                            remdups_fwd_acc Acc us = xsa @ [x] \\<and>\n                            remdups_fwd_acc (Acc \\<union> set (xsa @ [x]))\n                             vs =\n                            zs", "moreover"], ["proof (state)\nthis:\n  vs = vs' @ y # vs''\n  y \\<notin> set vs'\n\ngoal (2 subgoals):\n 1. \\<And>zs.\n       remdups_fwd_acc Acc xs = [] @ zs \\<Longrightarrow>\n       \\<exists>us vs.\n          xs = us @ vs \\<and>\n          remdups_fwd_acc Acc us = [] \\<and>\n          remdups_fwd_acc (Acc \\<union> set []) vs = zs\n 2. \\<And>x xsa zs.\n       \\<lbrakk>\\<And>zs.\n                   remdups_fwd_acc Acc xs = xsa @ zs \\<Longrightarrow>\n                   \\<exists>us vs.\n                      xs = us @ vs \\<and>\n                      remdups_fwd_acc Acc us = xsa \\<and>\n                      remdups_fwd_acc (Acc \\<union> set xsa) vs = zs;\n        remdups_fwd_acc Acc xs = (xsa @ [x]) @ zs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>us vs.\n                            xs = us @ vs \\<and>\n                            remdups_fwd_acc Acc us = xsa @ [x] \\<and>\n                            remdups_fwd_acc (Acc \\<union> set (xsa @ [x]))\n                             vs =\n                            zs", "hence \"remdups_fwd_acc (Acc \\<union> set ys) vs' = []\""], ["proof (prove)\nusing this:\n  vs = vs' @ y # vs''\n  y \\<notin> set vs'\n\ngoal (1 subgoal):\n 1. remdups_fwd_acc (Acc \\<union> set ys) vs' = []", "using \\<open>remdups_fwd_acc (Acc \\<union> set ys) vs = y # zs\\<close> \\<open>y \\<notin> Acc \\<union> set ys\\<close>"], ["proof (prove)\nusing this:\n  vs = vs' @ y # vs''\n  y \\<notin> set vs'\n  remdups_fwd_acc (Acc \\<union> set ys) vs = y # zs\n  y \\<notin> Acc \\<union> set ys\n\ngoal (1 subgoal):\n 1. remdups_fwd_acc (Acc \\<union> set ys) vs' = []", "by (force intro: list_empty_prefix)"], ["proof (state)\nthis:\n  remdups_fwd_acc (Acc \\<union> set ys) vs' = []\n\ngoal (2 subgoals):\n 1. \\<And>zs.\n       remdups_fwd_acc Acc xs = [] @ zs \\<Longrightarrow>\n       \\<exists>us vs.\n          xs = us @ vs \\<and>\n          remdups_fwd_acc Acc us = [] \\<and>\n          remdups_fwd_acc (Acc \\<union> set []) vs = zs\n 2. \\<And>x xsa zs.\n       \\<lbrakk>\\<And>zs.\n                   remdups_fwd_acc Acc xs = xsa @ zs \\<Longrightarrow>\n                   \\<exists>us vs.\n                      xs = us @ vs \\<and>\n                      remdups_fwd_acc Acc us = xsa \\<and>\n                      remdups_fwd_acc (Acc \\<union> set xsa) vs = zs;\n        remdups_fwd_acc Acc xs = (xsa @ [x]) @ zs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>us vs.\n                            xs = us @ vs \\<and>\n                            remdups_fwd_acc Acc us = xsa @ [x] \\<and>\n                            remdups_fwd_acc (Acc \\<union> set (xsa @ [x]))\n                             vs =\n                            zs", "ultimately"], ["proof (chain)\npicking this:\n  xs = us @ vs\n  remdups_fwd_acc Acc us = ys\n  remdups_fwd_acc (Acc \\<union> set ys) vs = y # zs\n  y \\<in> set vs\n  y \\<notin> Acc \\<union> set ys\n  vs = vs' @ y # vs''\n  y \\<notin> set vs'\n  remdups_fwd_acc (Acc \\<union> set ys) vs' = []", "have \"xs = (us @ vs' @ [y]) @ vs''\"\n      and \"remdups_fwd_acc Acc (us @ vs' @ [y]) = ys @ [y]\"\n      and \"remdups_fwd_acc (Acc \\<union> set (ys @ [y])) vs'' = zs\""], ["proof (prove)\nusing this:\n  xs = us @ vs\n  remdups_fwd_acc Acc us = ys\n  remdups_fwd_acc (Acc \\<union> set ys) vs = y # zs\n  y \\<in> set vs\n  y \\<notin> Acc \\<union> set ys\n  vs = vs' @ y # vs''\n  y \\<notin> set vs'\n  remdups_fwd_acc (Acc \\<union> set ys) vs' = []\n\ngoal (1 subgoal):\n 1. xs = (us @ vs' @ [y]) @ vs'' &&&\n    remdups_fwd_acc Acc (us @ vs' @ [y]) = ys @ [y] &&&\n    remdups_fwd_acc (Acc \\<union> set (ys @ [y])) vs'' = zs", "by (auto simp add: remdups_fwd_acc_empty sup.absorb1)"], ["proof (state)\nthis:\n  xs = (us @ vs' @ [y]) @ vs''\n  remdups_fwd_acc Acc (us @ vs' @ [y]) = ys @ [y]\n  remdups_fwd_acc (Acc \\<union> set (ys @ [y])) vs'' = zs\n\ngoal (2 subgoals):\n 1. \\<And>zs.\n       remdups_fwd_acc Acc xs = [] @ zs \\<Longrightarrow>\n       \\<exists>us vs.\n          xs = us @ vs \\<and>\n          remdups_fwd_acc Acc us = [] \\<and>\n          remdups_fwd_acc (Acc \\<union> set []) vs = zs\n 2. \\<And>x xsa zs.\n       \\<lbrakk>\\<And>zs.\n                   remdups_fwd_acc Acc xs = xsa @ zs \\<Longrightarrow>\n                   \\<exists>us vs.\n                      xs = us @ vs \\<and>\n                      remdups_fwd_acc Acc us = xsa \\<and>\n                      remdups_fwd_acc (Acc \\<union> set xsa) vs = zs;\n        remdups_fwd_acc Acc xs = (xsa @ [x]) @ zs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>us vs.\n                            xs = us @ vs \\<and>\n                            remdups_fwd_acc Acc us = xsa @ [x] \\<and>\n                            remdups_fwd_acc (Acc \\<union> set (xsa @ [x]))\n                             vs =\n                            zs", "thus ?case"], ["proof (prove)\nusing this:\n  xs = (us @ vs' @ [y]) @ vs''\n  remdups_fwd_acc Acc (us @ vs' @ [y]) = ys @ [y]\n  remdups_fwd_acc (Acc \\<union> set (ys @ [y])) vs'' = zs\n\ngoal (1 subgoal):\n 1. \\<exists>us vs.\n       xs = us @ vs \\<and>\n       remdups_fwd_acc Acc us = ys @ [y] \\<and>\n       remdups_fwd_acc (Acc \\<union> set (ys @ [y])) vs = zs", "by blast"], ["proof (state)\nthis:\n  \\<exists>us vs.\n     xs = us @ vs \\<and>\n     remdups_fwd_acc Acc us = ys @ [y] \\<and>\n     remdups_fwd_acc (Acc \\<union> set (ys @ [y])) vs = zs\n\ngoal (1 subgoal):\n 1. \\<And>zs.\n       remdups_fwd_acc Acc xs = [] @ zs \\<Longrightarrow>\n       \\<exists>us vs.\n          xs = us @ vs \\<and>\n          remdups_fwd_acc Acc us = [] \\<and>\n          remdups_fwd_acc (Acc \\<union> set []) vs = zs", "qed force"], ["", "lemma remdups_fwd_split_exact:\n  assumes \"remdups_fwd_acc Acc xs = ys @ x # zs\"\n  shows \"\\<exists>us vs. xs = us @ x # vs \\<and> x \\<notin> Acc \\<and> x \\<notin> set ys \\<and> remdups_fwd_acc Acc us = ys \\<and> remdups_fwd_acc (Acc \\<union> set ys \\<union> {x}) vs = zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>us vs.\n       xs = us @ x # vs \\<and>\n       x \\<notin> Acc \\<and>\n       x \\<notin> set ys \\<and>\n       remdups_fwd_acc Acc us = ys \\<and>\n       remdups_fwd_acc (Acc \\<union> set ys \\<union> {x}) vs = zs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>us vs.\n       xs = us @ x # vs \\<and>\n       x \\<notin> Acc \\<and>\n       x \\<notin> set ys \\<and>\n       remdups_fwd_acc Acc us = ys \\<and>\n       remdups_fwd_acc (Acc \\<union> set ys \\<union> {x}) vs = zs", "obtain us vs where \"xs = us @ vs\" and \"remdups_fwd_acc Acc us = ys\" and \"remdups_fwd_acc (Acc \\<union> set ys) vs = x # zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>us vs.\n        \\<lbrakk>xs = us @ vs; remdups_fwd_acc Acc us = ys;\n         remdups_fwd_acc (Acc \\<union> set ys) vs = x # zs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  remdups_fwd_acc Acc xs = ys @ x # zs\n\ngoal (1 subgoal):\n 1. (\\<And>us vs.\n        \\<lbrakk>xs = us @ vs; remdups_fwd_acc Acc us = ys;\n         remdups_fwd_acc (Acc \\<union> set ys) vs = x # zs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: remdups_fwd_split)"], ["proof (state)\nthis:\n  xs = us @ vs\n  remdups_fwd_acc Acc us = ys\n  remdups_fwd_acc (Acc \\<union> set ys) vs = x # zs\n\ngoal (1 subgoal):\n 1. \\<exists>us vs.\n       xs = us @ x # vs \\<and>\n       x \\<notin> Acc \\<and>\n       x \\<notin> set ys \\<and>\n       remdups_fwd_acc Acc us = ys \\<and>\n       remdups_fwd_acc (Acc \\<union> set ys \\<union> {x}) vs = zs", "moreover"], ["proof (state)\nthis:\n  xs = us @ vs\n  remdups_fwd_acc Acc us = ys\n  remdups_fwd_acc (Acc \\<union> set ys) vs = x # zs\n\ngoal (1 subgoal):\n 1. \\<exists>us vs.\n       xs = us @ x # vs \\<and>\n       x \\<notin> Acc \\<and>\n       x \\<notin> set ys \\<and>\n       remdups_fwd_acc Acc us = ys \\<and>\n       remdups_fwd_acc (Acc \\<union> set ys \\<union> {x}) vs = zs", "hence \"x \\<in> set vs\" and \"x \\<notin> Acc \\<union> set ys\""], ["proof (prove)\nusing this:\n  xs = us @ vs\n  remdups_fwd_acc Acc us = ys\n  remdups_fwd_acc (Acc \\<union> set ys) vs = x # zs\n\ngoal (1 subgoal):\n 1. x \\<in> set vs &&& x \\<notin> Acc \\<union> set ys", "using remdups_fwd_acc_set[of \"Acc \\<union> set ys\"]"], ["proof (prove)\nusing this:\n  xs = us @ vs\n  remdups_fwd_acc Acc us = ys\n  remdups_fwd_acc (Acc \\<union> set ys) vs = x # zs\n  set (remdups_fwd_acc (Acc \\<union> set ys) ?xs) =\n  set ?xs - (Acc \\<union> set ys)\n\ngoal (1 subgoal):\n 1. x \\<in> set vs &&& x \\<notin> Acc \\<union> set ys", "by (fastforce, metis (no_types) Diff_iff list.set_intros(1))"], ["proof (state)\nthis:\n  x \\<in> set vs\n  x \\<notin> Acc \\<union> set ys\n\ngoal (1 subgoal):\n 1. \\<exists>us vs.\n       xs = us @ x # vs \\<and>\n       x \\<notin> Acc \\<and>\n       x \\<notin> set ys \\<and>\n       remdups_fwd_acc Acc us = ys \\<and>\n       remdups_fwd_acc (Acc \\<union> set ys \\<union> {x}) vs = zs", "moreover"], ["proof (state)\nthis:\n  x \\<in> set vs\n  x \\<notin> Acc \\<union> set ys\n\ngoal (1 subgoal):\n 1. \\<exists>us vs.\n       xs = us @ x # vs \\<and>\n       x \\<notin> Acc \\<and>\n       x \\<notin> set ys \\<and>\n       remdups_fwd_acc Acc us = ys \\<and>\n       remdups_fwd_acc (Acc \\<union> set ys \\<union> {x}) vs = zs", "then"], ["proof (chain)\npicking this:\n  x \\<in> set vs\n  x \\<notin> Acc \\<union> set ys", "obtain vs' vs'' where \"vs = vs' @ x # vs''\" and \"x \\<notin> set vs'\""], ["proof (prove)\nusing this:\n  x \\<in> set vs\n  x \\<notin> Acc \\<union> set ys\n\ngoal (1 subgoal):\n 1. (\\<And>vs' vs''.\n        \\<lbrakk>vs = vs' @ x # vs''; x \\<notin> set vs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: split_list_first)"], ["proof (state)\nthis:\n  vs = vs' @ x # vs''\n  x \\<notin> set vs'\n\ngoal (1 subgoal):\n 1. \\<exists>us vs.\n       xs = us @ x # vs \\<and>\n       x \\<notin> Acc \\<and>\n       x \\<notin> set ys \\<and>\n       remdups_fwd_acc Acc us = ys \\<and>\n       remdups_fwd_acc (Acc \\<union> set ys \\<union> {x}) vs = zs", "moreover"], ["proof (state)\nthis:\n  vs = vs' @ x # vs''\n  x \\<notin> set vs'\n\ngoal (1 subgoal):\n 1. \\<exists>us vs.\n       xs = us @ x # vs \\<and>\n       x \\<notin> Acc \\<and>\n       x \\<notin> set ys \\<and>\n       remdups_fwd_acc Acc us = ys \\<and>\n       remdups_fwd_acc (Acc \\<union> set ys \\<union> {x}) vs = zs", "hence \"set vs' \\<subseteq> Acc \\<union> set ys\""], ["proof (prove)\nusing this:\n  vs = vs' @ x # vs''\n  x \\<notin> set vs'\n\ngoal (1 subgoal):\n 1. set vs' \\<subseteq> Acc \\<union> set ys", "using \\<open>remdups_fwd_acc (Acc \\<union> set ys) vs = x # zs\\<close> \\<open>x \\<notin> Acc \\<union> set ys\\<close>"], ["proof (prove)\nusing this:\n  vs = vs' @ x # vs''\n  x \\<notin> set vs'\n  remdups_fwd_acc (Acc \\<union> set ys) vs = x # zs\n  x \\<notin> Acc \\<union> set ys\n\ngoal (1 subgoal):\n 1. set vs' \\<subseteq> Acc \\<union> set ys", "unfolding remdups_fwd_acc_empty"], ["proof (prove)\nusing this:\n  vs = vs' @ x # vs''\n  x \\<notin> set vs'\n  remdups_fwd_acc (Acc \\<union> set ys) vs = x # zs\n  x \\<notin> Acc \\<union> set ys\n\ngoal (1 subgoal):\n 1. remdups_fwd_acc (Acc \\<union> set ys) vs' = []", "by (fastforce intro: list_empty_prefix)"], ["proof (state)\nthis:\n  set vs' \\<subseteq> Acc \\<union> set ys\n\ngoal (1 subgoal):\n 1. \\<exists>us vs.\n       xs = us @ x # vs \\<and>\n       x \\<notin> Acc \\<and>\n       x \\<notin> set ys \\<and>\n       remdups_fwd_acc Acc us = ys \\<and>\n       remdups_fwd_acc (Acc \\<union> set ys \\<union> {x}) vs = zs", "moreover"], ["proof (state)\nthis:\n  set vs' \\<subseteq> Acc \\<union> set ys\n\ngoal (1 subgoal):\n 1. \\<exists>us vs.\n       xs = us @ x # vs \\<and>\n       x \\<notin> Acc \\<and>\n       x \\<notin> set ys \\<and>\n       remdups_fwd_acc Acc us = ys \\<and>\n       remdups_fwd_acc (Acc \\<union> set ys \\<union> {x}) vs = zs", "hence \"remdups_fwd_acc (Acc \\<union> set ys) vs' = []\""], ["proof (prove)\nusing this:\n  set vs' \\<subseteq> Acc \\<union> set ys\n\ngoal (1 subgoal):\n 1. remdups_fwd_acc (Acc \\<union> set ys) vs' = []", "using remdups_fwd_acc_empty"], ["proof (prove)\nusing this:\n  set vs' \\<subseteq> Acc \\<union> set ys\n  (set ?xs \\<subseteq> ?Acc) = (remdups_fwd_acc ?Acc ?xs = [])\n\ngoal (1 subgoal):\n 1. remdups_fwd_acc (Acc \\<union> set ys) vs' = []", "by blast"], ["proof (state)\nthis:\n  remdups_fwd_acc (Acc \\<union> set ys) vs' = []\n\ngoal (1 subgoal):\n 1. \\<exists>us vs.\n       xs = us @ x # vs \\<and>\n       x \\<notin> Acc \\<and>\n       x \\<notin> set ys \\<and>\n       remdups_fwd_acc Acc us = ys \\<and>\n       remdups_fwd_acc (Acc \\<union> set ys \\<union> {x}) vs = zs", "ultimately"], ["proof (chain)\npicking this:\n  xs = us @ vs\n  remdups_fwd_acc Acc us = ys\n  remdups_fwd_acc (Acc \\<union> set ys) vs = x # zs\n  x \\<in> set vs\n  x \\<notin> Acc \\<union> set ys\n  vs = vs' @ x # vs''\n  x \\<notin> set vs'\n  set vs' \\<subseteq> Acc \\<union> set ys\n  remdups_fwd_acc (Acc \\<union> set ys) vs' = []", "have \"xs = (us @ vs') @ x # vs''\"\n    and \"remdups_fwd_acc Acc (us @ vs') = ys\"\n    and \"remdups_fwd_acc (Acc \\<union> set ys \\<union> {x}) vs'' = zs\""], ["proof (prove)\nusing this:\n  xs = us @ vs\n  remdups_fwd_acc Acc us = ys\n  remdups_fwd_acc (Acc \\<union> set ys) vs = x # zs\n  x \\<in> set vs\n  x \\<notin> Acc \\<union> set ys\n  vs = vs' @ x # vs''\n  x \\<notin> set vs'\n  set vs' \\<subseteq> Acc \\<union> set ys\n  remdups_fwd_acc (Acc \\<union> set ys) vs' = []\n\ngoal (1 subgoal):\n 1. xs = (us @ vs') @ x # vs'' &&&\n    remdups_fwd_acc Acc (us @ vs') = ys &&&\n    remdups_fwd_acc (Acc \\<union> set ys \\<union> {x}) vs'' = zs", "by (fastforce dest: sup.absorb1)+"], ["proof (state)\nthis:\n  xs = (us @ vs') @ x # vs''\n  remdups_fwd_acc Acc (us @ vs') = ys\n  remdups_fwd_acc (Acc \\<union> set ys \\<union> {x}) vs'' = zs\n\ngoal (1 subgoal):\n 1. \\<exists>us vs.\n       xs = us @ x # vs \\<and>\n       x \\<notin> Acc \\<and>\n       x \\<notin> set ys \\<and>\n       remdups_fwd_acc Acc us = ys \\<and>\n       remdups_fwd_acc (Acc \\<union> set ys \\<union> {x}) vs = zs", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = (us @ vs') @ x # vs''\n  remdups_fwd_acc Acc (us @ vs') = ys\n  remdups_fwd_acc (Acc \\<union> set ys \\<union> {x}) vs'' = zs\n\ngoal (1 subgoal):\n 1. \\<exists>us vs.\n       xs = us @ x # vs \\<and>\n       x \\<notin> Acc \\<and>\n       x \\<notin> set ys \\<and>\n       remdups_fwd_acc Acc us = ys \\<and>\n       remdups_fwd_acc (Acc \\<union> set ys \\<union> {x}) vs = zs", "using \\<open>x \\<notin> Acc \\<union> set ys\\<close>"], ["proof (prove)\nusing this:\n  xs = (us @ vs') @ x # vs''\n  remdups_fwd_acc Acc (us @ vs') = ys\n  remdups_fwd_acc (Acc \\<union> set ys \\<union> {x}) vs'' = zs\n  x \\<notin> Acc \\<union> set ys\n\ngoal (1 subgoal):\n 1. \\<exists>us vs.\n       xs = us @ x # vs \\<and>\n       x \\<notin> Acc \\<and>\n       x \\<notin> set ys \\<and>\n       remdups_fwd_acc Acc us = ys \\<and>\n       remdups_fwd_acc (Acc \\<union> set ys \\<union> {x}) vs = zs", "by blast"], ["proof (state)\nthis:\n  \\<exists>us vs.\n     xs = us @ x # vs \\<and>\n     x \\<notin> Acc \\<and>\n     x \\<notin> set ys \\<and>\n     remdups_fwd_acc Acc us = ys \\<and>\n     remdups_fwd_acc (Acc \\<union> set ys \\<union> {x}) vs = zs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma remdups_fwd_split_exactE:\n  assumes \"remdups_fwd_acc Acc xs = ys @ x # zs\"\n  obtains us vs where \"xs = us @ x # vs\" and \"x \\<notin> set us\" and \"remdups_fwd_acc Acc us = ys\" and \"remdups_fwd_acc (Acc \\<union> set ys \\<union> {x}) vs = zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>us vs.\n        \\<lbrakk>xs = us @ x # vs; x \\<notin> set us;\n         remdups_fwd_acc Acc us = ys;\n         remdups_fwd_acc (Acc \\<union> set ys \\<union> {x}) vs = zs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using remdups_fwd_split_exact[OF assms]"], ["proof (prove)\nusing this:\n  \\<exists>us vs.\n     xs = us @ x # vs \\<and>\n     x \\<notin> Acc \\<and>\n     x \\<notin> set ys \\<and>\n     remdups_fwd_acc Acc us = ys \\<and>\n     remdups_fwd_acc (Acc \\<union> set ys \\<union> {x}) vs = zs\n\ngoal (1 subgoal):\n 1. (\\<And>us vs.\n        \\<lbrakk>xs = us @ x # vs; x \\<notin> set us;\n         remdups_fwd_acc Acc us = ys;\n         remdups_fwd_acc (Acc \\<union> set ys \\<union> {x}) vs = zs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["", "lemma remdups_fwd_split_exact_iff:\n  \"remdups_fwd_acc Acc xs = ys @ x # zs \\<longleftrightarrow> \n    (\\<exists>us vs. xs = us @ x # vs \\<and> x \\<notin> Acc \\<and> x \\<notin> set us \\<and> remdups_fwd_acc Acc us = ys \\<and> remdups_fwd_acc (Acc \\<union> set ys \\<union> {x}) vs = zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (remdups_fwd_acc Acc xs = ys @ x # zs) =\n    (\\<exists>us vs.\n        xs = us @ x # vs \\<and>\n        x \\<notin> Acc \\<and>\n        x \\<notin> set us \\<and>\n        remdups_fwd_acc Acc us = ys \\<and>\n        remdups_fwd_acc (Acc \\<union> set ys \\<union> {x}) vs = zs)", "using remdups_fwd_split_exact"], ["proof (prove)\nusing this:\n  remdups_fwd_acc ?Acc ?xs = ?ys @ ?x # ?zs \\<Longrightarrow>\n  \\<exists>us vs.\n     ?xs = us @ ?x # vs \\<and>\n     ?x \\<notin> ?Acc \\<and>\n     ?x \\<notin> set ?ys \\<and>\n     remdups_fwd_acc ?Acc us = ?ys \\<and>\n     remdups_fwd_acc (?Acc \\<union> set ?ys \\<union> {?x}) vs = ?zs\n\ngoal (1 subgoal):\n 1. (remdups_fwd_acc Acc xs = ys @ x # zs) =\n    (\\<exists>us vs.\n        xs = us @ x # vs \\<and>\n        x \\<notin> Acc \\<and>\n        x \\<notin> set us \\<and>\n        remdups_fwd_acc Acc us = ys \\<and>\n        remdups_fwd_acc (Acc \\<union> set ys \\<union> {x}) vs = zs)", "by fastforce"], ["", "lemma sorted_pre:\n  \"(\\<And>x y xs ys. zs = xs @ [x, y] @ ys \\<Longrightarrow> x \\<le> y) \\<Longrightarrow> sorted zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y xs ys.\n        zs = xs @ [x, y] @ ys \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n    sorted zs", "apply (induction zs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>x y xs ys.\n        [] = xs @ [x, y] @ ys \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n    sorted []\n 2. \\<And>a zs.\n       \\<lbrakk>(\\<And>x y xs ys.\n                    zs = xs @ [x, y] @ ys \\<Longrightarrow>\n                    x \\<le> y) \\<Longrightarrow>\n                sorted zs;\n        \\<And>x y xs ys.\n           a # zs = xs @ [x, y] @ ys \\<Longrightarrow> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> sorted (a # zs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a zs.\n       \\<lbrakk>(\\<And>x y xs ys.\n                    zs = xs @ [x, y] @ ys \\<Longrightarrow>\n                    x \\<le> y) \\<Longrightarrow>\n                sorted zs;\n        \\<And>x y xs ys.\n           a # zs = xs @ [x, y] @ ys \\<Longrightarrow> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> sorted (a # zs)", "by (metis append_Nil append_Cons list.exhaust sorted1 sorted2)"], ["", "lemma sorted_list:\n  assumes \"x \\<in> set xs\" and \"y \\<in> set xs\"\n  assumes \"sorted (map f xs)\" and \"f x < f y\"\n  shows \"\\<exists>xs' xs'' xs'''. xs = xs' @ x # xs'' @ y # xs'''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs' xs'' xs'''. xs = xs' @ x # xs'' @ y # xs'''", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>xs' xs'' xs'''. xs = xs' @ x # xs'' @ y # xs'''", "obtain ys zs where \"xs = ys @ y # zs\" and \"y \\<notin> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ys zs.\n        \\<lbrakk>xs = ys @ y # zs; y \\<notin> set ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> set xs\n  y \\<in> set xs\n  sorted (map f xs)\n  f x < f y\n\ngoal (1 subgoal):\n 1. (\\<And>ys zs.\n        \\<lbrakk>xs = ys @ y # zs; y \\<notin> set ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: split_list_first)"], ["proof (state)\nthis:\n  xs = ys @ y # zs\n  y \\<notin> set ys\n\ngoal (1 subgoal):\n 1. \\<exists>xs' xs'' xs'''. xs = xs' @ x # xs'' @ y # xs'''", "moreover"], ["proof (state)\nthis:\n  xs = ys @ y # zs\n  y \\<notin> set ys\n\ngoal (1 subgoal):\n 1. \\<exists>xs' xs'' xs'''. xs = xs' @ x # xs'' @ y # xs'''", "hence \"sorted (map f (y # zs))\""], ["proof (prove)\nusing this:\n  xs = ys @ y # zs\n  y \\<notin> set ys\n\ngoal (1 subgoal):\n 1. sorted (map f (y # zs))", "using \\<open>sorted (map f xs)\\<close>"], ["proof (prove)\nusing this:\n  xs = ys @ y # zs\n  y \\<notin> set ys\n  sorted (map f xs)\n\ngoal (1 subgoal):\n 1. sorted (map f (y # zs))", "by (simp add: sorted_append)"], ["proof (state)\nthis:\n  sorted (map f (y # zs))\n\ngoal (1 subgoal):\n 1. \\<exists>xs' xs'' xs'''. xs = xs' @ x # xs'' @ y # xs'''", "hence \"\\<forall>x\\<in>set (map f (y # zs)). f y \\<le> x\""], ["proof (prove)\nusing this:\n  sorted (map f (y # zs))\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map f (y # zs)). f y \\<le> x", "by force"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (map f (y # zs)). f y \\<le> x\n\ngoal (1 subgoal):\n 1. \\<exists>xs' xs'' xs'''. xs = xs' @ x # xs'' @ y # xs'''", "hence \"\\<forall>x\\<in>set (y # zs). f y \\<le> f x\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (map f (y # zs)). f y \\<le> x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (y # zs). f y \\<le> f x", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (y # zs). f y \\<le> f x\n\ngoal (1 subgoal):\n 1. \\<exists>xs' xs'' xs'''. xs = xs' @ x # xs'' @ y # xs'''", "have \"x \\<in> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set ys", "apply (rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> set ys \\<Longrightarrow> False", "using \\<open>f x < f y\\<close> \\<open>x \\<in> set xs\\<close> \\<open>\\<forall>x\\<in>set (y # zs). f y \\<le> f x\\<close>"], ["proof (prove)\nusing this:\n  f x < f y\n  x \\<in> set xs\n  \\<forall>x\\<in>set (y # zs). f y \\<le> f x\n\ngoal (1 subgoal):\n 1. x \\<notin> set ys \\<Longrightarrow> False", "unfolding \\<open>xs = ys @ y # zs\\<close> set_append"], ["proof (prove)\nusing this:\n  f x < f y\n  x \\<in> set ys \\<union> set (y # zs)\n  \\<forall>x\\<in>set (y # zs). f y \\<le> f x\n\ngoal (1 subgoal):\n 1. x \\<notin> set ys \\<Longrightarrow> False", "by auto"], ["proof (state)\nthis:\n  x \\<in> set ys\n\ngoal (1 subgoal):\n 1. \\<exists>xs' xs'' xs'''. xs = xs' @ x # xs'' @ y # xs'''", "then"], ["proof (chain)\npicking this:\n  x \\<in> set ys", "obtain ys' zs' where \"ys = ys' @ x # zs'\""], ["proof (prove)\nusing this:\n  x \\<in> set ys\n\ngoal (1 subgoal):\n 1. (\\<And>ys' zs'.\n        ys = ys' @ x # zs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> set ys\n  x \\<in> set xs\n  y \\<in> set xs\n  sorted (map f xs)\n  f x < f y\n\ngoal (1 subgoal):\n 1. (\\<And>ys' zs'.\n        ys = ys' @ x # zs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: split_list_first)"], ["proof (state)\nthis:\n  ys = ys' @ x # zs'\n\ngoal (1 subgoal):\n 1. \\<exists>xs' xs'' xs'''. xs = xs' @ x # xs'' @ y # xs'''", "ultimately"], ["proof (chain)\npicking this:\n  xs = ys @ y # zs\n  y \\<notin> set ys\n  ys = ys' @ x # zs'", "show ?thesis"], ["proof (prove)\nusing this:\n  xs = ys @ y # zs\n  y \\<notin> set ys\n  ys = ys' @ x # zs'\n\ngoal (1 subgoal):\n 1. \\<exists>xs' xs'' xs'''. xs = xs' @ x # xs'' @ y # xs'''", "by auto"], ["proof (state)\nthis:\n  \\<exists>xs' xs'' xs'''. xs = xs' @ x # xs'' @ y # xs'''\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma takeWhile_foo:\n  \"x \\<notin> set ys \\<Longrightarrow> ys = takeWhile (\\<lambda>y. y \\<noteq> x) (ys @ x # zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> set ys \\<Longrightarrow>\n    ys = takeWhile (\\<lambda>y. y \\<noteq> x) (ys @ x # zs)", "by (metis (mono_tags, lifting) append_Nil2 takeWhile.simps(2) takeWhile_append2)"], ["", "lemma takeWhile_split:\n  \"x \\<in> set xs \\<Longrightarrow> y \\<in> set (takeWhile (\\<lambda>y. y \\<noteq> x) xs) \\<Longrightarrow> \\<exists>xs' xs'' xs'''. xs = xs' @ y # xs'' @ x # xs'''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set xs;\n     y \\<in> set (takeWhile (\\<lambda>y. y \\<noteq> x) xs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs' xs'' xs'''.\n                         xs = xs' @ y # xs'' @ x # xs'''", "using split_list_first"], ["proof (prove)\nusing this:\n  ?x \\<in> set ?xs \\<Longrightarrow>\n  \\<exists>ys zs. ?xs = ys @ ?x # zs \\<and> ?x \\<notin> set ys\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set xs;\n     y \\<in> set (takeWhile (\\<lambda>y. y \\<noteq> x) xs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs' xs'' xs'''.\n                         xs = xs' @ y # xs'' @ x # xs'''", "by (metis append_Cons append_assoc takeWhile_foo)"], ["", "lemma takeWhile_distinct:\n  \"distinct (xs' @ x # xs'') \\<Longrightarrow> y \\<in> set (takeWhile (\\<lambda>y. y \\<noteq> x) (xs' @ x # xs'')) \\<longleftrightarrow> y \\<in> set xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (xs' @ x # xs'') \\<Longrightarrow>\n    (y \\<in> set (takeWhile (\\<lambda>y. y \\<noteq> x) (xs' @ x # xs''))) =\n    (y \\<in> set xs')", "by (induction xs') simp+"], ["", "lemma finite_lists_length_eqE:\n  assumes \"finite A\" \n  shows \"finite {xs. set xs = A \\<and> length xs = n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {xs. set xs = A \\<and> length xs = n}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {xs. set xs = A \\<and> length xs = n}", "have \"{xs. set xs = A \\<and> length xs = n} \\<subseteq> {xs. set xs \\<subseteq> A \\<and> length xs = n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {xs. set xs = A \\<and> length xs = n}\n    \\<subseteq> {xs. set xs \\<subseteq> A \\<and> length xs = n}", "by blast"], ["proof (state)\nthis:\n  {xs. set xs = A \\<and> length xs = n}\n  \\<subseteq> {xs. set xs \\<subseteq> A \\<and> length xs = n}\n\ngoal (1 subgoal):\n 1. finite {xs. set xs = A \\<and> length xs = n}", "thus ?thesis"], ["proof (prove)\nusing this:\n  {xs. set xs = A \\<and> length xs = n}\n  \\<subseteq> {xs. set xs \\<subseteq> A \\<and> length xs = n}\n\ngoal (1 subgoal):\n 1. finite {xs. set xs = A \\<and> length xs = n}", "using finite_lists_length_eq[OF assms(1), of n]"], ["proof (prove)\nusing this:\n  {xs. set xs = A \\<and> length xs = n}\n  \\<subseteq> {xs. set xs \\<subseteq> A \\<and> length xs = n}\n  finite {xs. set xs \\<subseteq> A \\<and> length xs = n}\n\ngoal (1 subgoal):\n 1. finite {xs. set xs = A \\<and> length xs = n}", "using finite_subset"], ["proof (prove)\nusing this:\n  {xs. set xs = A \\<and> length xs = n}\n  \\<subseteq> {xs. set xs \\<subseteq> A \\<and> length xs = n}\n  finite {xs. set xs \\<subseteq> A \\<and> length xs = n}\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. finite {xs. set xs = A \\<and> length xs = n}", "by auto"], ["proof (state)\nthis:\n  finite {xs. set xs = A \\<and> length xs = n}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_set2:\n  assumes \"card A = n\" and \"finite A\"\n  shows \"finite {xs. set xs = A \\<and> distinct xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {xs. set xs = A \\<and> distinct xs}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {xs. set xs = A \\<and> distinct xs}", "have \"{xs. set xs = A \\<and> distinct xs} \\<subseteq> {xs. set xs = A \\<and> length xs = n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {xs. set xs = A \\<and> distinct xs}\n    \\<subseteq> {xs. set xs = A \\<and> length xs = n}", "using assms(1) distinct_card"], ["proof (prove)\nusing this:\n  card A = n\n  distinct ?xs \\<Longrightarrow> card (set ?xs) = length ?xs\n\ngoal (1 subgoal):\n 1. {xs. set xs = A \\<and> distinct xs}\n    \\<subseteq> {xs. set xs = A \\<and> length xs = n}", "by fastforce"], ["proof (state)\nthis:\n  {xs. set xs = A \\<and> distinct xs}\n  \\<subseteq> {xs. set xs = A \\<and> length xs = n}\n\ngoal (1 subgoal):\n 1. finite {xs. set xs = A \\<and> distinct xs}", "thus ?thesis"], ["proof (prove)\nusing this:\n  {xs. set xs = A \\<and> distinct xs}\n  \\<subseteq> {xs. set xs = A \\<and> length xs = n}\n\ngoal (1 subgoal):\n 1. finite {xs. set xs = A \\<and> distinct xs}", "by (metis (no_types, lifting) finite_lists_length_eqE[OF \\<open>finite A\\<close>, of n] finite_subset)"], ["proof (state)\nthis:\n  finite {xs. set xs = A \\<and> distinct xs}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_list: \n  assumes \"finite (set ` XS)\"\n  assumes \"\\<And>xs. xs \\<in> XS \\<Longrightarrow> distinct xs\"\n  shows \"finite XS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite XS", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite XS", "have \"XS \\<subseteq> {xs | xs. set xs \\<in> set ` XS \\<and> distinct xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. XS \\<subseteq> {xs |xs. set xs \\<in> set ` XS \\<and> distinct xs}", "using assms"], ["proof (prove)\nusing this:\n  finite (set ` XS)\n  ?xs \\<in> XS \\<Longrightarrow> distinct ?xs\n\ngoal (1 subgoal):\n 1. XS \\<subseteq> {xs |xs. set xs \\<in> set ` XS \\<and> distinct xs}", "by auto"], ["proof (state)\nthis:\n  XS \\<subseteq> {xs |xs. set xs \\<in> set ` XS \\<and> distinct xs}\n\ngoal (1 subgoal):\n 1. finite XS", "moreover"], ["proof (state)\nthis:\n  XS \\<subseteq> {xs |xs. set xs \\<in> set ` XS \\<and> distinct xs}\n\ngoal (1 subgoal):\n 1. finite XS", "have 1: \"{xs |xs. set xs \\<in> set ` XS \\<and> distinct xs} = \\<Union>{{xs | xs. set xs = A \\<and> distinct xs} | A. A \\<in> set ` XS}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {xs |xs. set xs \\<in> set ` XS \\<and> distinct xs} =\n    \\<Union> {{xs |xs. set xs = A \\<and> distinct xs} |A. A \\<in> set ` XS}", "by auto"], ["proof (state)\nthis:\n  {xs |xs. set xs \\<in> set ` XS \\<and> distinct xs} =\n  \\<Union> {{xs |xs. set xs = A \\<and> distinct xs} |A. A \\<in> set ` XS}\n\ngoal (1 subgoal):\n 1. finite XS", "have \"finite {xs |xs. set xs \\<in> set ` XS \\<and> distinct xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {xs |xs. set xs \\<in> set ` XS \\<and> distinct xs}", "using finite_set2[OF _ finite_set] distinct_card  assms(1)"], ["proof (prove)\nusing this:\n  card (set ?xs1) = ?n \\<Longrightarrow>\n  finite {xs. set xs = set ?xs1 \\<and> distinct xs}\n  distinct ?xs \\<Longrightarrow> card (set ?xs) = length ?xs\n  finite (set ` XS)\n\ngoal (1 subgoal):\n 1. finite {xs |xs. set xs \\<in> set ` XS \\<and> distinct xs}", "unfolding 1"], ["proof (prove)\nusing this:\n  card (set ?xs1) = ?n \\<Longrightarrow>\n  finite {xs. set xs = set ?xs1 \\<and> distinct xs}\n  distinct ?xs \\<Longrightarrow> card (set ?xs) = length ?xs\n  finite (set ` XS)\n\ngoal (1 subgoal):\n 1. finite\n     (\\<Union>\n       {{xs |xs. set xs = A \\<and> distinct xs} |A. A \\<in> set ` XS})", "by fastforce"], ["proof (state)\nthis:\n  finite {xs |xs. set xs \\<in> set ` XS \\<and> distinct xs}\n\ngoal (1 subgoal):\n 1. finite XS", "ultimately"], ["proof (chain)\npicking this:\n  XS \\<subseteq> {xs |xs. set xs \\<in> set ` XS \\<and> distinct xs}\n  finite {xs |xs. set xs \\<in> set ` XS \\<and> distinct xs}", "show ?thesis"], ["proof (prove)\nusing this:\n  XS \\<subseteq> {xs |xs. set xs \\<in> set ` XS \\<and> distinct xs}\n  finite {xs |xs. set xs \\<in> set ` XS \\<and> distinct xs}\n\ngoal (1 subgoal):\n 1. finite XS", "using finite_subset"], ["proof (prove)\nusing this:\n  XS \\<subseteq> {xs |xs. set xs \\<in> set ` XS \\<and> distinct xs}\n  finite {xs |xs. set xs \\<in> set ` XS \\<and> distinct xs}\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. finite XS", "by blast"], ["proof (state)\nthis:\n  finite XS\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_foldl_append:\n  \"set (foldl (@) i xs) = set i \\<union> \\<Union>{set x | x. x \\<in> set xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (foldl (@) i xs) =\n    set i \\<union> \\<Union> {set x |x. x \\<in> set xs}", "by (induction xs arbitrary: i) auto"], ["", "subsection \\<open>Short-circuited Version of @{const foldl}\\<close>"], ["", "fun foldl_break :: \"('b \\<Rightarrow> 'a \\<Rightarrow> 'b) \\<Rightarrow> ('b \\<Rightarrow> bool) \\<Rightarrow> 'b \\<Rightarrow> 'a list \\<Rightarrow> 'b\"\nwhere\n  \"foldl_break f s a [] = a\" \n| \"foldl_break f s a (x # xs) = (if s a then a else foldl_break f s (f a x) xs)\""], ["", "lemma foldl_break_append:\n  \"foldl_break f s a (xs @ ys) = (if s (foldl_break f s a xs) then foldl_break f s a xs else (foldl_break f s (foldl_break f s a xs) ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl_break f s a (xs @ ys) =\n    (if s (foldl_break f s a xs) then foldl_break f s a xs\n     else foldl_break f s (foldl_break f s a xs) ys)", "by (induction xs arbitrary: a) (cases ys, auto)"], ["", "subsection \\<open>Suffixes\\<close>\n\n\\<comment> \\<open>Non empty suffixes of finite words - specialised!\\<close>"], ["", "fun suffixes\nwhere\n  \"suffixes [] = []\"\n| \"suffixes (x#xs) = (suffixes xs) @ [x#xs]\""], ["", "lemma suffixes_append:\n  \"suffixes (xs @ ys) = (suffixes ys) @ (map (\\<lambda>zs. zs @ ys) (suffixes xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. suffixes (xs @ ys) =\n    suffixes ys @ map (\\<lambda>zs. zs @ ys) (suffixes xs)", "by (induction xs) simp_all"], ["", "lemma suffixes_alt_def:\n  \"suffixes xs = rev (prefix (length xs) (\\<lambda>i. drop i xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. suffixes xs = rev (prefix (length xs) (\\<lambda>i. drop i xs))", "proof (induction xs rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. suffixes [] = rev (prefix (length []) (\\<lambda>i. drop i []))\n 2. \\<And>x xs.\n       suffixes xs =\n       rev (prefix (length xs) (\\<lambda>i. drop i xs)) \\<Longrightarrow>\n       suffixes (xs @ [x]) =\n       rev (prefix (length (xs @ [x])) (\\<lambda>i. drop i (xs @ [x])))", "case (snoc x xs)"], ["proof (state)\nthis:\n  suffixes xs = rev (prefix (length xs) (\\<lambda>i. drop i xs))\n\ngoal (2 subgoals):\n 1. suffixes [] = rev (prefix (length []) (\\<lambda>i. drop i []))\n 2. \\<And>x xs.\n       suffixes xs =\n       rev (prefix (length xs) (\\<lambda>i. drop i xs)) \\<Longrightarrow>\n       suffixes (xs @ [x]) =\n       rev (prefix (length (xs @ [x])) (\\<lambda>i. drop i (xs @ [x])))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. suffixes (xs @ [x]) =\n    rev (prefix (length (xs @ [x])) (\\<lambda>i. drop i (xs @ [x])))", "by (simp add: subsequence_def suffixes_append snoc rev_map)"], ["proof (state)\nthis:\n  suffixes (xs @ [x]) =\n  rev (prefix (length (xs @ [x])) (\\<lambda>i. drop i (xs @ [x])))\n\ngoal (1 subgoal):\n 1. suffixes [] = rev (prefix (length []) (\\<lambda>i. drop i []))", "qed simp"], ["", "end"]]}