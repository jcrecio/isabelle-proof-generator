{"file_name": "/home/qj213/afp-2021-10-22/thys/LTL_to_DRA/Mojmir.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/LTL_to_DRA", "problem_names": ["lemma token_stays_in_final_states:\n  \"token_run x n \\<in> F \\<Longrightarrow> token_run x (n + m) \\<in> F\"", "lemma token_run_enter_final_states:\n  assumes \"token_run x n \\<in> F\"\n  shows \"\\<exists>m \\<ge> x. token_run x m \\<notin> F - {q\\<^sub>0} \\<and> token_run x (Suc m) \\<in> F\"", "lemma token_succeeds_alt_def:\n  \"token_succeeds x = (\\<forall>\\<^sub>\\<infinity>n. token_run x n \\<in> F)\"", "lemma token_fails_alt_def:\n  \"token_fails x = (\\<forall>\\<^sub>\\<infinity>n. sink (token_run x n) \\<and> token_run x n \\<notin> F)\"\n  (is \"?lhs = ?rhs\")", "lemma token_fails_alt_def_2:\n  \"token_fails x \\<longleftrightarrow> \\<not>token_succeeds x \\<and> \\<not>token_squats x\"", "lemma token_succeeds_run_merge:\n  \"x \\<le> n \\<Longrightarrow> y \\<le> n \\<Longrightarrow> token_run x n = token_run y n \\<Longrightarrow> token_succeeds x \\<Longrightarrow> token_succeeds y\"", "lemma token_squats_run_merge:\n  \"x \\<le> n \\<Longrightarrow> y \\<le> n \\<Longrightarrow> token_run x n = token_run y n \\<Longrightarrow> token_squats x \\<Longrightarrow> token_squats y\"", "lemma configuration_token_succeeds:\n  \"\\<lbrakk>x \\<in> configuration q n; y \\<in> configuration q n\\<rbrakk> \\<Longrightarrow> token_succeeds x = token_succeeds y\"", "lemma configuration_token_squats:\n  \"\\<lbrakk>x \\<in> configuration q n; y \\<in> configuration q n\\<rbrakk> \\<Longrightarrow> token_squats x = token_squats y\"", "lemma Mojmir_reject:\n  \"\\<not> accept \\<longleftrightarrow> (\\<exists>\\<^sub>\\<infinity>x. \\<not>token_succeeds x)\"", "lemma mojmir_accept_alt_def:\n  \"accept \\<longleftrightarrow> finite {x. \\<not>token_succeeds x}\"", "lemma mojmir_accept_initial:\n  \"q\\<^sub>0 \\<in> F \\<Longrightarrow> accept\"", "lemma merge_token_succeeds:\n  assumes \"(x, y) \\<in> merge i\"\n  shows \"token_succeeds x \\<longleftrightarrow> token_succeeds y\"", "lemma merge_subset:\n   \"i \\<le> j \\<Longrightarrow> merge i \\<subseteq> merge j\"", "lemma merge_finite:\n  \"i \\<le> j \\<Longrightarrow> finite (merge j) \\<Longrightarrow> finite (merge i)\"", "lemma merge_finite':\n  \"i < j \\<Longrightarrow> finite (merge j) \\<Longrightarrow> finite (merge i)\"", "lemma succeed_membership:\n  \"token_succeeds x \\<longleftrightarrow> (\\<exists>i. x \\<in> succeed i)\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma stable_rank_succeed:\n  assumes \"infinite (succeed i)\"\n      and \"x \\<in> succeed i\"\n      and \"q\\<^sub>0 \\<notin> F\"\n  shows \"\\<not>stable_rank x i\"", "lemma stable_rank_bounded:\n  assumes stable: \"stable_rank x j\"\n  assumes inf: \"infinite (succeed i)\"\n  assumes \"q\\<^sub>0 \\<notin> F\"\n  shows \"j < i\"", "lemma mojmir_accept_token_set_def1:\n  assumes \"accept\"\n  shows \"\\<exists>i < max_rank. finite fail \\<and> finite (merge i) \\<and> infinite (succeed i) \\<and> (\\<forall>j < i. finite (succeed j))\"", "lemma mojmir_accept_token_set_def2:\n  assumes \"finite fail\"\n      and \"finite (merge i)\"\n      and \"infinite (succeed i)\"\n  shows \"accept\"", "theorem mojmir_accept_iff_token_set_accept:\n  \"accept \\<longleftrightarrow> (\\<exists>i < max_rank. finite fail \\<and> finite (merge i) \\<and> infinite (succeed i))\"", "theorem mojmir_accept_iff_token_set_accept2:\n  \"accept \\<longleftrightarrow> (\\<exists>i < max_rank. finite fail \\<and> finite (merge i) \\<and> infinite (succeed i) \\<and> (\\<forall>j < i. finite (merge j) \\<and> finite (succeed j)))\"", "lemma finite_monotonic_image:\n  fixes A B :: \"nat set\"\n  assumes \"\\<And>i. i \\<in> A \\<Longrightarrow> i \\<le> f i\"\n  assumes \"f ` A = B\"\n  shows \"finite A \\<longleftrightarrow> finite B\"", "lemma finite_monotonic_image_pairs:\n  fixes A :: \"(nat \\<times> nat) set\"\n  fixes B :: \"nat set\"\n  assumes \"\\<And>i. i \\<in> A \\<Longrightarrow> (fst i) \\<le> f i + c\"\n  assumes \"\\<And>i. i \\<in> A \\<Longrightarrow> (snd i) \\<le> f i + d\"\n  assumes \"f ` A = B\"\n  shows \"finite A \\<longleftrightarrow> finite B\"", "lemma token_time_finite_rule:\n  fixes A B :: \"nat set\"\n  assumes unique:  \"\\<And>x y z. P x y \\<Longrightarrow> P x z \\<Longrightarrow> y = z\"\n      and existsA: \"\\<And>x. x \\<in> A \\<Longrightarrow> (\\<exists>y. P x y)\"\n      and existsB: \"\\<And>y. y \\<in> B \\<Longrightarrow> (\\<exists>x. P x y)\"\n      and inA:     \"\\<And>x y. P x y \\<Longrightarrow> x \\<in> A\"\n      and inB:     \"\\<And>x y. P x y \\<Longrightarrow> y \\<in> B\"\n      and mono:    \"\\<And>x y. P x y \\<Longrightarrow> x \\<le> y\"\n  shows \"finite A \\<longleftrightarrow> finite B\"", "lemma token_time_finite_pair_rule:\n  fixes A :: \"(nat \\<times> nat) set\"\n  fixes B :: \"nat set\"\n  assumes unique:  \"\\<And>x y z. P x y \\<Longrightarrow> P x z \\<Longrightarrow> y = z\"\n      and existsA: \"\\<And>x. x \\<in> A \\<Longrightarrow> (\\<exists>y. P x y)\"\n      and existsB: \"\\<And>y. y \\<in> B \\<Longrightarrow> (\\<exists>x. P x y)\"\n      and inA:     \"\\<And>x y. P x y \\<Longrightarrow> x \\<in> A\"\n      and inB:     \"\\<And>x y. P x y \\<Longrightarrow> y \\<in> B\"\n      and mono:    \"\\<And>x y. P x y \\<Longrightarrow> fst x \\<le> y + c \\<and> snd x \\<le> y + d\"\n  shows \"finite A \\<longleftrightarrow> finite B\"", "lemma fail_t_inclusion:\n  assumes \"x \\<le> n\"\n  assumes \"\\<not>sink (token_run x n)\"\n  assumes \"sink (token_run x (Suc n))\"\n  assumes \"token_run x (Suc n) \\<notin> F\"\n  shows \"n \\<in> fail_t\"", "lemma merge_t_inclusion:\n  assumes \"x \\<le> n\"\n  assumes \"(\\<exists>j'. token_run x n \\<noteq> token_run y n \\<and> y \\<le> n \\<and> state_rank (token_run y n) n = Some j') \\<or> y = Suc n\"\n  assumes \"token_run x (Suc n) = token_run y (Suc n)\"\n  assumes \"token_run x (Suc n) \\<notin> F\"\n  assumes \"state_rank (token_run x n) n = Some j\"\n  assumes \"j < i\"\n  shows \"n \\<in> merge_t i\"", "lemma succeed_t_inclusion:\n  assumes \"rank x n = Some i\"\n  assumes \"token_run x n \\<notin> F - {q\\<^sub>0}\"\n  assumes \"token_run x (Suc n) \\<in> F\"\n  shows \"n \\<in> succeed_t i\"", "lemma finite_fail_t:\n  \"finite fail = finite fail_t\"", "lemma finite_succeed_t':\n  assumes \"q\\<^sub>0 \\<notin> F\"\n  shows \"finite (succeed i) = finite (succeed_t i)\"", "lemma initial_in_F_token_run:\n  assumes \"q\\<^sub>0 \\<in> F\"\n  shows \"token_run x y \\<in> F\"", "lemma finite_succeed_t'':\n  assumes \"q\\<^sub>0 \\<in> F\"\n  shows \"finite (succeed i) = finite (succeed_t i)\"\n  (is \"?lhs = ?rhs\")", "lemma finite_succeed_t:\n  \"finite (succeed i) = finite (succeed_t i)\"", "lemma finite_merge_t:\n  \"finite (merge i) = finite (merge_t i)\"", "lemma token_iff_time_accept:\n  shows \"(finite fail \\<and> finite (merge i) \\<and> infinite (succeed i) \\<and> (\\<forall>j < i. finite (succeed j)))\n       = (finite fail_t \\<and> finite (merge_t i) \\<and> infinite (succeed_t i) \\<and> (\\<forall>j < i. finite (succeed_t j)))\"", "lemma stable_rank_at_ge:\n  \"n \\<le> m \\<Longrightarrow> stable_rank_at x n \\<Longrightarrow> stable_rank_at x m\"", "lemma stable_rank_equiv:\n  \"(\\<exists>i. stable_rank x i) = (\\<exists>n. stable_rank_at x n)\"", "lemma smallest_accepting_rank_properties:\n  assumes \"smallest_accepting_rank = Some i\"\n  shows \"accept\" \"finite fail\" \"finite (merge i)\" \"infinite (succeed i)\" \"\\<forall>j < i. finite (succeed j)\" \"i < max_rank\"", "lemma token_smallest_accepting_rank:\n  assumes \"smallest_accepting_rank = Some i\"\n  shows \"\\<forall>\\<^sub>\\<infinity>n. \\<forall>x. token_succeeds x \\<longleftrightarrow> (x > n \\<or> (\\<exists>j \\<ge> i. rank x n = Some j) \\<or> token_run x n \\<in> F)\"", "lemma succeeding_states:\n  assumes \"smallest_accepting_rank = Some i\"\n  shows \"\\<forall>\\<^sub>\\<infinity>n. \\<forall>q. ((\\<exists>x \\<in> configuration q n. token_succeeds x) \\<longrightarrow> q \\<in> \\<S> n) \\<and> (q \\<in> \\<S> n \\<longrightarrow> (\\<forall>x \\<in> configuration q n. token_succeeds x))\""], "translations": [["", "lemma token_stays_in_final_states:\n  \"token_run x n \\<in> F \\<Longrightarrow> token_run x (n + m) \\<in> F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. token_run x n \\<in> F \\<Longrightarrow> token_run x (n + m) \\<in> F", "proof (induction m)"], ["proof (state)\ngoal (2 subgoals):\n 1. token_run x n \\<in> F \\<Longrightarrow> token_run x (n + 0) \\<in> F\n 2. \\<And>m.\n       \\<lbrakk>token_run x n \\<in> F \\<Longrightarrow>\n                token_run x (n + m) \\<in> F;\n        token_run x n \\<in> F\\<rbrakk>\n       \\<Longrightarrow> token_run x (n + Suc m) \\<in> F", "case (Suc m)"], ["proof (state)\nthis:\n  token_run x n \\<in> F \\<Longrightarrow> token_run x (n + m) \\<in> F\n  token_run x n \\<in> F\n\ngoal (2 subgoals):\n 1. token_run x n \\<in> F \\<Longrightarrow> token_run x (n + 0) \\<in> F\n 2. \\<And>m.\n       \\<lbrakk>token_run x n \\<in> F \\<Longrightarrow>\n                token_run x (n + m) \\<in> F;\n        token_run x n \\<in> F\\<rbrakk>\n       \\<Longrightarrow> token_run x (n + Suc m) \\<in> F", "thus ?case"], ["proof (prove)\nusing this:\n  token_run x n \\<in> F \\<Longrightarrow> token_run x (n + m) \\<in> F\n  token_run x n \\<in> F\n\ngoal (1 subgoal):\n 1. token_run x (n + Suc m) \\<in> F", "proof (cases \"n + m < x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>token_run x n \\<in> F \\<Longrightarrow>\n             token_run x (n + m) \\<in> F;\n     token_run x n \\<in> F; n + m < x\\<rbrakk>\n    \\<Longrightarrow> token_run x (n + Suc m) \\<in> F\n 2. \\<lbrakk>token_run x n \\<in> F \\<Longrightarrow>\n             token_run x (n + m) \\<in> F;\n     token_run x n \\<in> F; \\<not> n + m < x\\<rbrakk>\n    \\<Longrightarrow> token_run x (n + Suc m) \\<in> F", "case False"], ["proof (state)\nthis:\n  \\<not> n + m < x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>token_run x n \\<in> F \\<Longrightarrow>\n             token_run x (n + m) \\<in> F;\n     token_run x n \\<in> F; n + m < x\\<rbrakk>\n    \\<Longrightarrow> token_run x (n + Suc m) \\<in> F\n 2. \\<lbrakk>token_run x n \\<in> F \\<Longrightarrow>\n             token_run x (n + m) \\<in> F;\n     token_run x n \\<in> F; \\<not> n + m < x\\<rbrakk>\n    \\<Longrightarrow> token_run x (n + Suc m) \\<in> F", "hence \"n + m \\<ge> x\""], ["proof (prove)\nusing this:\n  \\<not> n + m < x\n\ngoal (1 subgoal):\n 1. x \\<le> n + m", "by arith"], ["proof (state)\nthis:\n  x \\<le> n + m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>token_run x n \\<in> F \\<Longrightarrow>\n             token_run x (n + m) \\<in> F;\n     token_run x n \\<in> F; n + m < x\\<rbrakk>\n    \\<Longrightarrow> token_run x (n + Suc m) \\<in> F\n 2. \\<lbrakk>token_run x n \\<in> F \\<Longrightarrow>\n             token_run x (n + m) \\<in> F;\n     token_run x n \\<in> F; \\<not> n + m < x\\<rbrakk>\n    \\<Longrightarrow> token_run x (n + Suc m) \\<in> F", "then"], ["proof (chain)\npicking this:\n  x \\<le> n + m", "obtain j where \"n + m = x + j\""], ["proof (prove)\nusing this:\n  x \\<le> n + m\n\ngoal (1 subgoal):\n 1. (\\<And>j. n + m = x + j \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using le_Suc_ex"], ["proof (prove)\nusing this:\n  x \\<le> n + m\n  ?k \\<le> ?l \\<Longrightarrow> \\<exists>n. ?l = ?k + n\n\ngoal (1 subgoal):\n 1. (\\<And>j. n + m = x + j \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n + m = x + j\n\ngoal (2 subgoals):\n 1. \\<lbrakk>token_run x n \\<in> F \\<Longrightarrow>\n             token_run x (n + m) \\<in> F;\n     token_run x n \\<in> F; n + m < x\\<rbrakk>\n    \\<Longrightarrow> token_run x (n + Suc m) \\<in> F\n 2. \\<lbrakk>token_run x n \\<in> F \\<Longrightarrow>\n             token_run x (n + m) \\<in> F;\n     token_run x n \\<in> F; \\<not> n + m < x\\<rbrakk>\n    \\<Longrightarrow> token_run x (n + Suc m) \\<in> F", "hence \"\\<delta> (token_run x (n + m)) (suffix x w j) = token_run x (n + (Suc m))\""], ["proof (prove)\nusing this:\n  n + m = x + j\n\ngoal (1 subgoal):\n 1. \\<delta> (token_run x (n + m)) (suffix x w j) = token_run x (n + Suc m)", "unfolding suffix_def"], ["proof (prove)\nusing this:\n  n + m = x + j\n\ngoal (1 subgoal):\n 1. \\<delta> (token_run x (n + m)) (w (x + j)) = token_run x (n + Suc m)", "by fastforce"], ["proof (state)\nthis:\n  \\<delta> (token_run x (n + m)) (suffix x w j) = token_run x (n + Suc m)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>token_run x n \\<in> F \\<Longrightarrow>\n             token_run x (n + m) \\<in> F;\n     token_run x n \\<in> F; n + m < x\\<rbrakk>\n    \\<Longrightarrow> token_run x (n + Suc m) \\<in> F\n 2. \\<lbrakk>token_run x n \\<in> F \\<Longrightarrow>\n             token_run x (n + m) \\<in> F;\n     token_run x n \\<in> F; \\<not> n + m < x\\<rbrakk>\n    \\<Longrightarrow> token_run x (n + Suc m) \\<in> F", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<delta> (token_run x (n + m)) (suffix x w j) = token_run x (n + Suc m)\n\ngoal (1 subgoal):\n 1. token_run x (n + Suc m) \\<in> F", "using wellformed_F Suc suffix_nth"], ["proof (prove)\nusing this:\n  \\<delta> (token_run x (n + m)) (suffix x w j) = token_run x (n + Suc m)\n  ?q \\<in> F \\<Longrightarrow> \\<delta> ?q ?\\<nu> \\<in> F\n  token_run x n \\<in> F \\<Longrightarrow> token_run x (n + m) \\<in> F\n  token_run x n \\<in> F\n  suffix ?k ?x ?n = ?x (?k + ?n)\n\ngoal (1 subgoal):\n 1. token_run x (n + Suc m) \\<in> F", "by (metis (no_types, hide_lams))"], ["proof (state)\nthis:\n  token_run x (n + Suc m) \\<in> F\n\ngoal (1 subgoal):\n 1. \\<lbrakk>token_run x n \\<in> F \\<Longrightarrow>\n             token_run x (n + m) \\<in> F;\n     token_run x n \\<in> F; n + m < x\\<rbrakk>\n    \\<Longrightarrow> token_run x (n + Suc m) \\<in> F", "qed fastforce"], ["proof (state)\nthis:\n  token_run x (n + Suc m) \\<in> F\n\ngoal (1 subgoal):\n 1. token_run x n \\<in> F \\<Longrightarrow> token_run x (n + 0) \\<in> F", "qed simp"], ["", "lemma token_run_enter_final_states:\n  assumes \"token_run x n \\<in> F\"\n  shows \"\\<exists>m \\<ge> x. token_run x m \\<notin> F - {q\\<^sub>0} \\<and> token_run x (Suc m) \\<in> F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m\\<ge>x.\n       token_run x m \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc m) \\<in> F", "proof (cases \"x \\<le> n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<le> n \\<Longrightarrow>\n    \\<exists>m\\<ge>x.\n       token_run x m \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc m) \\<in> F\n 2. \\<not> x \\<le> n \\<Longrightarrow>\n    \\<exists>m\\<ge>x.\n       token_run x m \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc m) \\<in> F", "case True"], ["proof (state)\nthis:\n  x \\<le> n\n\ngoal (2 subgoals):\n 1. x \\<le> n \\<Longrightarrow>\n    \\<exists>m\\<ge>x.\n       token_run x m \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc m) \\<in> F\n 2. \\<not> x \\<le> n \\<Longrightarrow>\n    \\<exists>m\\<ge>x.\n       token_run x m \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc m) \\<in> F", "then"], ["proof (chain)\npicking this:\n  x \\<le> n", "obtain n' where \"token_run x (x + n') \\<in> F\""], ["proof (prove)\nusing this:\n  x \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<And>n'.\n        token_run x (x + n') \\<in> F \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  x \\<le> n\n  token_run x n \\<in> F\n\ngoal (1 subgoal):\n 1. (\\<And>n'.\n        token_run x (x + n') \\<in> F \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  token_run x (x + n') \\<in> F\n\ngoal (2 subgoals):\n 1. x \\<le> n \\<Longrightarrow>\n    \\<exists>m\\<ge>x.\n       token_run x m \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc m) \\<in> F\n 2. \\<not> x \\<le> n \\<Longrightarrow>\n    \\<exists>m\\<ge>x.\n       token_run x m \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc m) \\<in> F", "hence \"\\<exists>m. token_run x (x + m) \\<notin> F - {q\\<^sub>0} \\<and> token_run x (x + Suc m) \\<in> F\""], ["proof (prove)\nusing this:\n  token_run x (x + n') \\<in> F\n\ngoal (1 subgoal):\n 1. \\<exists>m.\n       token_run x (x + m) \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (x + Suc m) \\<in> F", "by (induction n') ((metis (erased, hide_lams) token_stays_in_final_states token_run_intial_state  Diff_iff Nat.add_0_right Suc_eq_plus1 insertCI ), blast)"], ["proof (state)\nthis:\n  \\<exists>m.\n     token_run x (x + m) \\<notin> F - {q\\<^sub>0} \\<and>\n     token_run x (x + Suc m) \\<in> F\n\ngoal (2 subgoals):\n 1. x \\<le> n \\<Longrightarrow>\n    \\<exists>m\\<ge>x.\n       token_run x m \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc m) \\<in> F\n 2. \\<not> x \\<le> n \\<Longrightarrow>\n    \\<exists>m\\<ge>x.\n       token_run x m \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc m) \\<in> F", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>m.\n     token_run x (x + m) \\<notin> F - {q\\<^sub>0} \\<and>\n     token_run x (x + Suc m) \\<in> F\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<ge>x.\n       token_run x m \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc m) \\<in> F", "by (metis add_Suc_right le_add1)"], ["proof (state)\nthis:\n  \\<exists>m\\<ge>x.\n     token_run x m \\<notin> F - {q\\<^sub>0} \\<and>\n     token_run x (Suc m) \\<in> F\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> n \\<Longrightarrow>\n    \\<exists>m\\<ge>x.\n       token_run x m \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc m) \\<in> F", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x \\<le> n \\<Longrightarrow>\n    \\<exists>m\\<ge>x.\n       token_run x m \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc m) \\<in> F", "case False"], ["proof (state)\nthis:\n  \\<not> x \\<le> n\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> n \\<Longrightarrow>\n    \\<exists>m\\<ge>x.\n       token_run x m \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc m) \\<in> F", "hence \"token_run x x \\<notin> F - {q\\<^sub>0}\" and \"token_run x (Suc x) \\<in> F\""], ["proof (prove)\nusing this:\n  \\<not> x \\<le> n\n\ngoal (1 subgoal):\n 1. token_run x x \\<notin> F - {q\\<^sub>0} &&& token_run x (Suc x) \\<in> F", "using assms wellformed_F"], ["proof (prove)\nusing this:\n  \\<not> x \\<le> n\n  token_run x n \\<in> F\n  ?q \\<in> F \\<Longrightarrow> \\<delta> ?q ?\\<nu> \\<in> F\n\ngoal (1 subgoal):\n 1. token_run x x \\<notin> F - {q\\<^sub>0} &&& token_run x (Suc x) \\<in> F", "by simp_all"], ["proof (state)\nthis:\n  token_run x x \\<notin> F - {q\\<^sub>0}\n  token_run x (Suc x) \\<in> F\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> n \\<Longrightarrow>\n    \\<exists>m\\<ge>x.\n       token_run x m \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc m) \\<in> F", "thus ?thesis"], ["proof (prove)\nusing this:\n  token_run x x \\<notin> F - {q\\<^sub>0}\n  token_run x (Suc x) \\<in> F\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<ge>x.\n       token_run x m \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc m) \\<in> F", "by blast"], ["proof (state)\nthis:\n  \\<exists>m\\<ge>x.\n     token_run x m \\<notin> F - {q\\<^sub>0} \\<and>\n     token_run x (Suc m) \\<in> F\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Token Properties\\<close>"], ["", "subsubsection \\<open>Alternative Definitions\\<close>"], ["", "lemma token_succeeds_alt_def:\n  \"token_succeeds x = (\\<forall>\\<^sub>\\<infinity>n. token_run x n \\<in> F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. token_succeeds x = (\\<forall>\\<^sub>\\<infinity>n. token_run x n \\<in> F)", "unfolding token_succeeds_def MOST_nat_le le_iff_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>n. token_run x n \\<in> F) =\n    (\\<exists>m.\n        \\<forall>n.\n           (\\<exists>c. n = m + c) \\<longrightarrow> token_run x n \\<in> F)", "using token_stays_in_final_states"], ["proof (prove)\nusing this:\n  token_run ?x ?n \\<in> F \\<Longrightarrow> token_run ?x (?n + ?m) \\<in> F\n\ngoal (1 subgoal):\n 1. (\\<exists>n. token_run x n \\<in> F) =\n    (\\<exists>m.\n        \\<forall>n.\n           (\\<exists>c. n = m + c) \\<longrightarrow> token_run x n \\<in> F)", "by blast"], ["", "lemma token_fails_alt_def:\n  \"token_fails x = (\\<forall>\\<^sub>\\<infinity>n. sink (token_run x n) \\<and> token_run x n \\<notin> F)\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. token_fails x =\n    (\\<forall>\\<^sub>\\<infinity>n.\n        sink (token_run x n) \\<and> token_run x n \\<notin> F)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. token_fails x \\<Longrightarrow>\n    \\<forall>\\<^sub>\\<infinity>n.\n       sink (token_run x n) \\<and> token_run x n \\<notin> F\n 2. \\<forall>\\<^sub>\\<infinity>n.\n       sink (token_run x n) \\<and>\n       token_run x n \\<notin> F \\<Longrightarrow>\n    token_fails x", "assume ?lhs"], ["proof (state)\nthis:\n  token_fails x\n\ngoal (2 subgoals):\n 1. token_fails x \\<Longrightarrow>\n    \\<forall>\\<^sub>\\<infinity>n.\n       sink (token_run x n) \\<and> token_run x n \\<notin> F\n 2. \\<forall>\\<^sub>\\<infinity>n.\n       sink (token_run x n) \\<and>\n       token_run x n \\<notin> F \\<Longrightarrow>\n    token_fails x", "then"], ["proof (chain)\npicking this:\n  token_fails x", "obtain n where \"sink (token_run x n)\" and \"token_run x n \\<notin> F\""], ["proof (prove)\nusing this:\n  token_fails x\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>sink (token_run x n); token_run x n \\<notin> F\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using token_fails_def"], ["proof (prove)\nusing this:\n  token_fails x\n  token_fails ?x =\n  (\\<exists>n. sink (token_run ?x n) \\<and> token_run ?x n \\<notin> F)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>sink (token_run x n); token_run x n \\<notin> F\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  sink (token_run x n)\n  token_run x n \\<notin> F\n\ngoal (2 subgoals):\n 1. token_fails x \\<Longrightarrow>\n    \\<forall>\\<^sub>\\<infinity>n.\n       sink (token_run x n) \\<and> token_run x n \\<notin> F\n 2. \\<forall>\\<^sub>\\<infinity>n.\n       sink (token_run x n) \\<and>\n       token_run x n \\<notin> F \\<Longrightarrow>\n    token_fails x", "hence \"\\<forall>m \\<ge> n. sink (token_run x m)\" and \"\\<forall>m \\<ge> n. token_run x m \\<notin> F\""], ["proof (prove)\nusing this:\n  sink (token_run x n)\n  token_run x n \\<notin> F\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<ge>n. sink (token_run x m) &&&\n    \\<forall>m\\<ge>n. token_run x m \\<notin> F", "using token_stays_in_sink"], ["proof (prove)\nusing this:\n  sink (token_run x n)\n  token_run x n \\<notin> F\n  \\<lbrakk>sink ?q; token_run ?x ?n = ?q\\<rbrakk>\n  \\<Longrightarrow> token_run ?x (?n + ?m) = ?q\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<ge>n. sink (token_run x m) &&&\n    \\<forall>m\\<ge>n. token_run x m \\<notin> F", "unfolding le_iff_add"], ["proof (prove)\nusing this:\n  sink (token_run x n)\n  token_run x n \\<notin> F\n  \\<lbrakk>sink ?q; token_run ?x ?n = ?q\\<rbrakk>\n  \\<Longrightarrow> token_run ?x (?n + ?m) = ?q\n\ngoal (1 subgoal):\n 1. \\<forall>m.\n       (\\<exists>c. m = n + c) \\<longrightarrow> sink (token_run x m) &&&\n    \\<forall>m.\n       (\\<exists>c. m = n + c) \\<longrightarrow> token_run x m \\<notin> F", "by auto"], ["proof (state)\nthis:\n  \\<forall>m\\<ge>n. sink (token_run x m)\n  \\<forall>m\\<ge>n. token_run x m \\<notin> F\n\ngoal (2 subgoals):\n 1. token_fails x \\<Longrightarrow>\n    \\<forall>\\<^sub>\\<infinity>n.\n       sink (token_run x n) \\<and> token_run x n \\<notin> F\n 2. \\<forall>\\<^sub>\\<infinity>n.\n       sink (token_run x n) \\<and>\n       token_run x n \\<notin> F \\<Longrightarrow>\n    token_fails x", "thus ?rhs"], ["proof (prove)\nusing this:\n  \\<forall>m\\<ge>n. sink (token_run x m)\n  \\<forall>m\\<ge>n. token_run x m \\<notin> F\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       sink (token_run x n) \\<and> token_run x n \\<notin> F", "unfolding MOST_nat_le"], ["proof (prove)\nusing this:\n  \\<forall>m\\<ge>n. sink (token_run x m)\n  \\<forall>m\\<ge>n. token_run x m \\<notin> F\n\ngoal (1 subgoal):\n 1. \\<exists>m.\n       \\<forall>n\\<ge>m.\n          sink (token_run x n) \\<and> token_run x n \\<notin> F", "by blast"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>\\<infinity>n.\n     sink (token_run x n) \\<and> token_run x n \\<notin> F\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       sink (token_run x n) \\<and>\n       token_run x n \\<notin> F \\<Longrightarrow>\n    token_fails x", "qed (unfold MOST_nat_le token_fails_def, blast)"], ["", "lemma token_fails_alt_def_2:\n  \"token_fails x \\<longleftrightarrow> \\<not>token_succeeds x \\<and> \\<not>token_squats x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. token_fails x = (\\<not> token_succeeds x \\<and> \\<not> token_squats x)", "by (metis add.commute token_fails_def token_squats_def token_stays_in_final_states token_stays_in_sink token_succeeds_def)"], ["", "subsubsection \\<open>Properties\\<close>"], ["", "lemma token_succeeds_run_merge:\n  \"x \\<le> n \\<Longrightarrow> y \\<le> n \\<Longrightarrow> token_run x n = token_run y n \\<Longrightarrow> token_succeeds x \\<Longrightarrow> token_succeeds y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> n; y \\<le> n; token_run x n = token_run y n;\n     token_succeeds x\\<rbrakk>\n    \\<Longrightarrow> token_succeeds y", "using token_run_merge token_stays_in_final_states add.commute"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?n; ?y \\<le> ?n;\n   token_run ?x ?n = token_run ?y ?n\\<rbrakk>\n  \\<Longrightarrow> token_run ?x (?n + ?m) = token_run ?y (?n + ?m)\n  token_run ?x ?n \\<in> F \\<Longrightarrow> token_run ?x (?n + ?m) \\<in> F\n  ?a + ?b = ?b + ?a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> n; y \\<le> n; token_run x n = token_run y n;\n     token_succeeds x\\<rbrakk>\n    \\<Longrightarrow> token_succeeds y", "unfolding token_succeeds_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?n; ?y \\<le> ?n;\n   token_run ?x ?n = token_run ?y ?n\\<rbrakk>\n  \\<Longrightarrow> token_run ?x (?n + ?m) = token_run ?y (?n + ?m)\n  token_run ?x ?n \\<in> F \\<Longrightarrow> token_run ?x (?n + ?m) \\<in> F\n  ?a + ?b = ?b + ?a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> n; y \\<le> n; token_run x n = token_run y n;\n     \\<exists>n. token_run x n \\<in> F\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n. token_run y n \\<in> F", "by metis"], ["", "lemma token_squats_run_merge:\n  \"x \\<le> n \\<Longrightarrow> y \\<le> n \\<Longrightarrow> token_run x n = token_run y n \\<Longrightarrow> token_squats x \\<Longrightarrow> token_squats y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> n; y \\<le> n; token_run x n = token_run y n;\n     token_squats x\\<rbrakk>\n    \\<Longrightarrow> token_squats y", "using token_run_merge token_stays_in_sink add.commute"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?n; ?y \\<le> ?n;\n   token_run ?x ?n = token_run ?y ?n\\<rbrakk>\n  \\<Longrightarrow> token_run ?x (?n + ?m) = token_run ?y (?n + ?m)\n  \\<lbrakk>sink ?q; token_run ?x ?n = ?q\\<rbrakk>\n  \\<Longrightarrow> token_run ?x (?n + ?m) = ?q\n  ?a + ?b = ?b + ?a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> n; y \\<le> n; token_run x n = token_run y n;\n     token_squats x\\<rbrakk>\n    \\<Longrightarrow> token_squats y", "unfolding token_squats_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?n; ?y \\<le> ?n;\n   token_run ?x ?n = token_run ?y ?n\\<rbrakk>\n  \\<Longrightarrow> token_run ?x (?n + ?m) = token_run ?y (?n + ?m)\n  \\<lbrakk>sink ?q; token_run ?x ?n = ?q\\<rbrakk>\n  \\<Longrightarrow> token_run ?x (?n + ?m) = ?q\n  ?a + ?b = ?b + ?a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> n; y \\<le> n; token_run x n = token_run y n;\n     \\<forall>n. \\<not> sink (token_run x n)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>n. \\<not> sink (token_run y n)", "by metis"], ["", "subsubsection \\<open>Pulled-Up Lemmas\\<close>"], ["", "lemma configuration_token_succeeds:\n  \"\\<lbrakk>x \\<in> configuration q n; y \\<in> configuration q n\\<rbrakk> \\<Longrightarrow> token_succeeds x = token_succeeds y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> configuration q n; y \\<in> configuration q n\\<rbrakk>\n    \\<Longrightarrow> token_succeeds x = token_succeeds y", "using token_succeeds_run_merge push_down_configuration_token_run"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?n; ?y \\<le> ?n; token_run ?x ?n = token_run ?y ?n;\n   token_succeeds ?x\\<rbrakk>\n  \\<Longrightarrow> token_succeeds ?y\n  \\<lbrakk>?x \\<in> configuration ?q ?n;\n   ?y \\<in> configuration ?q ?n\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?n \\<and>\n                    ?y \\<le> ?n \\<and> token_run ?x ?n = token_run ?y ?n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> configuration q n; y \\<in> configuration q n\\<rbrakk>\n    \\<Longrightarrow> token_succeeds x = token_succeeds y", "by meson"], ["", "lemma configuration_token_squats:\n  \"\\<lbrakk>x \\<in> configuration q n; y \\<in> configuration q n\\<rbrakk> \\<Longrightarrow> token_squats x = token_squats y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> configuration q n; y \\<in> configuration q n\\<rbrakk>\n    \\<Longrightarrow> token_squats x = token_squats y", "using token_squats_run_merge push_down_configuration_token_run"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?n; ?y \\<le> ?n; token_run ?x ?n = token_run ?y ?n;\n   token_squats ?x\\<rbrakk>\n  \\<Longrightarrow> token_squats ?y\n  \\<lbrakk>?x \\<in> configuration ?q ?n;\n   ?y \\<in> configuration ?q ?n\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?n \\<and>\n                    ?y \\<le> ?n \\<and> token_run ?x ?n = token_run ?y ?n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> configuration q n; y \\<in> configuration q n\\<rbrakk>\n    \\<Longrightarrow> token_squats x = token_squats y", "by meson"], ["", "subsection \\<open>Mojmir Acceptance\\<close>"], ["", "lemma Mojmir_reject:\n  \"\\<not> accept \\<longleftrightarrow> (\\<exists>\\<^sub>\\<infinity>x. \\<not>token_succeeds x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> accept\\<^sub>M) =\n    (\\<exists>\\<^sub>\\<infinity>x. \\<not> token_succeeds x)", "unfolding accept_def Alm_all_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> \\<not> (\\<exists>\\<^sub>\\<infinity>x.\n                       \\<not> token_succeeds x)) =\n    (\\<exists>\\<^sub>\\<infinity>x. \\<not> token_succeeds x)", "by blast"], ["", "lemma mojmir_accept_alt_def:\n  \"accept \\<longleftrightarrow> finite {x. \\<not>token_succeeds x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. accept\\<^sub>M = finite {x. \\<not> token_succeeds x}", "using Inf_many_def Mojmir_reject"], ["proof (prove)\nusing this:\n  Inf_many ?P = infinite {x. ?P x}\n  (\\<not> accept\\<^sub>M) =\n  (\\<exists>\\<^sub>\\<infinity>x. \\<not> token_succeeds x)\n\ngoal (1 subgoal):\n 1. accept\\<^sub>M = finite {x. \\<not> token_succeeds x}", "by blast"], ["", "lemma mojmir_accept_initial:\n  \"q\\<^sub>0 \\<in> F \\<Longrightarrow> accept\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q\\<^sub>0 \\<in> F \\<Longrightarrow> accept\\<^sub>M", "unfolding accept_def MOST_nat_le token_succeeds_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. q\\<^sub>0 \\<in> F \\<Longrightarrow>\n    \\<exists>m. \\<forall>n\\<ge>m. \\<exists>na. token_run n na \\<in> F", "using token_run_intial_state"], ["proof (prove)\nusing this:\n  token_run ?x ?x = q\\<^sub>0\n\ngoal (1 subgoal):\n 1. q\\<^sub>0 \\<in> F \\<Longrightarrow>\n    \\<exists>m. \\<forall>n\\<ge>m. \\<exists>na. token_run n na \\<in> F", "by metis"], ["", "subsection \\<open>Equivalent Acceptance Conditions\\<close>"], ["", "subsubsection \\<open>Token-Based Definitions\\<close>"], ["", "lemma merge_token_succeeds:\n  assumes \"(x, y) \\<in> merge i\"\n  shows \"token_succeeds x \\<longleftrightarrow> token_succeeds y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. token_succeeds x = token_succeeds y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. token_succeeds x = token_succeeds y", "obtain n j j' where \"token_run x (Suc n) = token_run y (Suc n)\"\n    and \"rank x n = Some j\" and \"rank y n = Some j' \\<or> y = Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n j j'.\n        \\<lbrakk>token_run x (Suc n) = token_run y (Suc n);\n         rank x n = Some j; rank y n = Some j' \\<or> y = Suc n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  (x, y) \\<in> local.merge i\n\ngoal (1 subgoal):\n 1. (\\<And>n j j'.\n        \\<lbrakk>token_run x (Suc n) = token_run y (Suc n);\n         rank x n = Some j; rank y n = Some j' \\<or> y = Suc n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding merge_def"], ["proof (prove)\nusing this:\n  (x, y)\n  \\<in> {uu_.\n         \\<exists>x y n j.\n            uu_ = (x, y) \\<and>\n            j < i \\<and>\n            (token_run x n \\<noteq> token_run y n \\<and>\n             rank y n \\<noteq> None \\<or>\n             y = Suc n) \\<and>\n            token_run x (Suc n) = token_run y (Suc n) \\<and>\n            token_run x (Suc n) \\<notin> F \\<and> rank x n = Some j}\n\ngoal (1 subgoal):\n 1. (\\<And>n j j'.\n        \\<lbrakk>token_run x (Suc n) = token_run y (Suc n);\n         rank x n = Some j; rank y n = Some j' \\<or> y = Suc n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  token_run x (Suc n) = token_run y (Suc n)\n  rank x n = Some j\n  rank y n = Some j' \\<or> y = Suc n\n\ngoal (1 subgoal):\n 1. token_succeeds x = token_succeeds y", "hence \"x \\<le> Suc n\" and \"y \\<le> Suc n\""], ["proof (prove)\nusing this:\n  token_run x (Suc n) = token_run y (Suc n)\n  rank x n = Some j\n  rank y n = Some j' \\<or> y = Suc n\n\ngoal (1 subgoal):\n 1. x \\<le> Suc n &&& y \\<le> Suc n", "using rank_Some_time le_Suc_eq"], ["proof (prove)\nusing this:\n  token_run x (Suc n) = token_run y (Suc n)\n  rank x n = Some j\n  rank y n = Some j' \\<or> y = Suc n\n  rank ?x ?n = Some ?j \\<Longrightarrow> ?x \\<le> ?n\n  (?m \\<le> Suc ?n) = (?m \\<le> ?n \\<or> ?m = Suc ?n)\n\ngoal (1 subgoal):\n 1. x \\<le> Suc n &&& y \\<le> Suc n", "by blast+"], ["proof (state)\nthis:\n  x \\<le> Suc n\n  y \\<le> Suc n\n\ngoal (1 subgoal):\n 1. token_succeeds x = token_succeeds y", "then"], ["proof (chain)\npicking this:\n  x \\<le> Suc n\n  y \\<le> Suc n", "obtain q where \"x \\<in> configuration q (Suc n)\" and \"y \\<in> configuration q (Suc n)\""], ["proof (prove)\nusing this:\n  x \\<le> Suc n\n  y \\<le> Suc n\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>x \\<in> configuration q (Suc n);\n         y \\<in> configuration q (Suc n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>token_run x (Suc n) = token_run y (Suc n)\\<close> pull_up_token_run_tokens"], ["proof (prove)\nusing this:\n  x \\<le> Suc n\n  y \\<le> Suc n\n  token_run x (Suc n) = token_run y (Suc n)\n  \\<lbrakk>?x \\<le> ?n; ?y \\<le> ?n;\n   token_run ?x ?n = token_run ?y ?n\\<rbrakk>\n  \\<Longrightarrow> \\<exists>q.\n                       ?x \\<in> configuration q ?n \\<and>\n                       ?y \\<in> configuration q ?n\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>x \\<in> configuration q (Suc n);\n         y \\<in> configuration q (Suc n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> configuration q (Suc n)\n  y \\<in> configuration q (Suc n)\n\ngoal (1 subgoal):\n 1. token_succeeds x = token_succeeds y", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> configuration q (Suc n)\n  y \\<in> configuration q (Suc n)\n\ngoal (1 subgoal):\n 1. token_succeeds x = token_succeeds y", "using configuration_token_succeeds"], ["proof (prove)\nusing this:\n  x \\<in> configuration q (Suc n)\n  y \\<in> configuration q (Suc n)\n  \\<lbrakk>?x \\<in> configuration ?q ?n;\n   ?y \\<in> configuration ?q ?n\\<rbrakk>\n  \\<Longrightarrow> token_succeeds ?x = token_succeeds ?y\n\ngoal (1 subgoal):\n 1. token_succeeds x = token_succeeds y", "by blast"], ["proof (state)\nthis:\n  token_succeeds x = token_succeeds y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma merge_subset:\n   \"i \\<le> j \\<Longrightarrow> merge i \\<subseteq> merge j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow> local.merge i \\<subseteq> local.merge j", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>i \\<le> j; x \\<in> local.merge i\\<rbrakk>\n       \\<Longrightarrow> x \\<in> local.merge j", "assume \"i \\<le> j\""], ["proof (state)\nthis:\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>i \\<le> j; x \\<in> local.merge i\\<rbrakk>\n       \\<Longrightarrow> x \\<in> local.merge j", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>i \\<le> j; x \\<in> local.merge i\\<rbrakk>\n       \\<Longrightarrow> x \\<in> local.merge j", "assume \"p \\<in> merge i\""], ["proof (state)\nthis:\n  p \\<in> local.merge i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>i \\<le> j; x \\<in> local.merge i\\<rbrakk>\n       \\<Longrightarrow> x \\<in> local.merge j", "then"], ["proof (chain)\npicking this:\n  p \\<in> local.merge i", "obtain x y n k where \"p = (x, y)\" and \"k < i\" and \"token_run x n \\<noteq> token_run y n \\<and> rank y n \\<noteq> None \\<or> y = Suc n\"\n    and \"token_run x (Suc n) = token_run y (Suc n)\" and \"token_run x (Suc n) \\<notin> F\" and \"rank x n = Some k\""], ["proof (prove)\nusing this:\n  p \\<in> local.merge i\n\ngoal (1 subgoal):\n 1. (\\<And>x y k n.\n        \\<lbrakk>p = (x, y); k < i;\n         token_run x n \\<noteq> token_run y n \\<and>\n         rank y n \\<noteq> None \\<or>\n         y = Suc n;\n         token_run x (Suc n) = token_run y (Suc n);\n         token_run x (Suc n) \\<notin> F; rank x n = Some k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding merge_def"], ["proof (prove)\nusing this:\n  p \\<in> {uu_.\n           \\<exists>x y n j.\n              uu_ = (x, y) \\<and>\n              j < i \\<and>\n              (token_run x n \\<noteq> token_run y n \\<and>\n               rank y n \\<noteq> None \\<or>\n               y = Suc n) \\<and>\n              token_run x (Suc n) = token_run y (Suc n) \\<and>\n              token_run x (Suc n) \\<notin> F \\<and> rank x n = Some j}\n\ngoal (1 subgoal):\n 1. (\\<And>x y k n.\n        \\<lbrakk>p = (x, y); k < i;\n         token_run x n \\<noteq> token_run y n \\<and>\n         rank y n \\<noteq> None \\<or>\n         y = Suc n;\n         token_run x (Suc n) = token_run y (Suc n);\n         token_run x (Suc n) \\<notin> F; rank x n = Some k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  p = (x, y)\n  k < i\n  token_run x n \\<noteq> token_run y n \\<and> rank y n \\<noteq> None \\<or>\n  y = Suc n\n  token_run x (Suc n) = token_run y (Suc n)\n  token_run x (Suc n) \\<notin> F\n  rank x n = Some k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>i \\<le> j; x \\<in> local.merge i\\<rbrakk>\n       \\<Longrightarrow> x \\<in> local.merge j", "moreover"], ["proof (state)\nthis:\n  p = (x, y)\n  k < i\n  token_run x n \\<noteq> token_run y n \\<and> rank y n \\<noteq> None \\<or>\n  y = Suc n\n  token_run x (Suc n) = token_run y (Suc n)\n  token_run x (Suc n) \\<notin> F\n  rank x n = Some k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>i \\<le> j; x \\<in> local.merge i\\<rbrakk>\n       \\<Longrightarrow> x \\<in> local.merge j", "hence \"k < j\""], ["proof (prove)\nusing this:\n  p = (x, y)\n  k < i\n  token_run x n \\<noteq> token_run y n \\<and> rank y n \\<noteq> None \\<or>\n  y = Suc n\n  token_run x (Suc n) = token_run y (Suc n)\n  token_run x (Suc n) \\<notin> F\n  rank x n = Some k\n\ngoal (1 subgoal):\n 1. k < j", "using \\<open>i \\<le> j\\<close>"], ["proof (prove)\nusing this:\n  p = (x, y)\n  k < i\n  token_run x n \\<noteq> token_run y n \\<and> rank y n \\<noteq> None \\<or>\n  y = Suc n\n  token_run x (Suc n) = token_run y (Suc n)\n  token_run x (Suc n) \\<notin> F\n  rank x n = Some k\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. k < j", "by simp"], ["proof (state)\nthis:\n  k < j\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>i \\<le> j; x \\<in> local.merge i\\<rbrakk>\n       \\<Longrightarrow> x \\<in> local.merge j", "ultimately"], ["proof (chain)\npicking this:\n  p = (x, y)\n  k < i\n  token_run x n \\<noteq> token_run y n \\<and> rank y n \\<noteq> None \\<or>\n  y = Suc n\n  token_run x (Suc n) = token_run y (Suc n)\n  token_run x (Suc n) \\<notin> F\n  rank x n = Some k\n  k < j", "have \"(x, y) \\<in> merge j\""], ["proof (prove)\nusing this:\n  p = (x, y)\n  k < i\n  token_run x n \\<noteq> token_run y n \\<and> rank y n \\<noteq> None \\<or>\n  y = Suc n\n  token_run x (Suc n) = token_run y (Suc n)\n  token_run x (Suc n) \\<notin> F\n  rank x n = Some k\n  k < j\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> local.merge j", "unfolding merge_def"], ["proof (prove)\nusing this:\n  p = (x, y)\n  k < i\n  token_run x n \\<noteq> token_run y n \\<and> rank y n \\<noteq> None \\<or>\n  y = Suc n\n  token_run x (Suc n) = token_run y (Suc n)\n  token_run x (Suc n) \\<notin> F\n  rank x n = Some k\n  k < j\n\ngoal (1 subgoal):\n 1. (x, y)\n    \\<in> {uu_.\n           \\<exists>x y n ja.\n              uu_ = (x, y) \\<and>\n              ja < j \\<and>\n              (token_run x n \\<noteq> token_run y n \\<and>\n               rank y n \\<noteq> None \\<or>\n               y = Suc n) \\<and>\n              token_run x (Suc n) = token_run y (Suc n) \\<and>\n              token_run x (Suc n) \\<notin> F \\<and> rank x n = Some ja}", "by blast"], ["proof (state)\nthis:\n  (x, y) \\<in> local.merge j\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>i \\<le> j; x \\<in> local.merge i\\<rbrakk>\n       \\<Longrightarrow> x \\<in> local.merge j", "thus \"p \\<in> merge j\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> local.merge j\n\ngoal (1 subgoal):\n 1. p \\<in> local.merge j", "using \\<open>p = (x, y)\\<close>"], ["proof (prove)\nusing this:\n  (x, y) \\<in> local.merge j\n  p = (x, y)\n\ngoal (1 subgoal):\n 1. p \\<in> local.merge j", "by simp"], ["proof (state)\nthis:\n  p \\<in> local.merge j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma merge_finite:\n  \"i \\<le> j \\<Longrightarrow> finite (merge j) \\<Longrightarrow> finite (merge i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> j; finite (local.merge j)\\<rbrakk>\n    \\<Longrightarrow> finite (local.merge i)", "using merge_subset"], ["proof (prove)\nusing this:\n  ?i \\<le> ?j \\<Longrightarrow> local.merge ?i \\<subseteq> local.merge ?j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> j; finite (local.merge j)\\<rbrakk>\n    \\<Longrightarrow> finite (local.merge i)", "by (blast intro: rev_finite_subset)"], ["", "lemma merge_finite':\n  \"i < j \\<Longrightarrow> finite (merge j) \\<Longrightarrow> finite (merge i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < j; finite (local.merge j)\\<rbrakk>\n    \\<Longrightarrow> finite (local.merge i)", "using merge_finite[of i j]"], ["proof (prove)\nusing this:\n  \\<lbrakk>i \\<le> j; finite (local.merge j)\\<rbrakk>\n  \\<Longrightarrow> finite (local.merge i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < j; finite (local.merge j)\\<rbrakk>\n    \\<Longrightarrow> finite (local.merge i)", "by force"], ["", "lemma succeed_membership:\n  \"token_succeeds x \\<longleftrightarrow> (\\<exists>i. x \\<in> succeed i)\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. token_succeeds x = (\\<exists>i. x \\<in> succeed i)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. token_succeeds x \\<Longrightarrow> \\<exists>i. x \\<in> succeed i\n 2. \\<exists>i. x \\<in> succeed i \\<Longrightarrow> token_succeeds x", "assume ?lhs"], ["proof (state)\nthis:\n  token_succeeds x\n\ngoal (2 subgoals):\n 1. token_succeeds x \\<Longrightarrow> \\<exists>i. x \\<in> succeed i\n 2. \\<exists>i. x \\<in> succeed i \\<Longrightarrow> token_succeeds x", "then"], ["proof (chain)\npicking this:\n  token_succeeds x", "obtain m where \"token_run x m \\<in> F\""], ["proof (prove)\nusing this:\n  token_succeeds x\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        token_run x m \\<in> F \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding token_succeeds_alt_def MOST_nat_le"], ["proof (prove)\nusing this:\n  \\<exists>m. \\<forall>n\\<ge>m. token_run x n \\<in> F\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        token_run x m \\<in> F \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  token_run x m \\<in> F\n\ngoal (2 subgoals):\n 1. token_succeeds x \\<Longrightarrow> \\<exists>i. x \\<in> succeed i\n 2. \\<exists>i. x \\<in> succeed i \\<Longrightarrow> token_succeeds x", "then"], ["proof (chain)\npicking this:\n  token_run x m \\<in> F", "obtain n where 1: \"token_run x n \\<notin> F - {q\\<^sub>0}\"\n    and 2: \"token_run x (Suc n) \\<in> F\" and \"x \\<le> n\""], ["proof (prove)\nusing this:\n  token_run x m \\<in> F\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>token_run x n \\<notin> F - {q\\<^sub>0};\n         token_run x (Suc n) \\<in> F; x \\<le> n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using token_run_enter_final_states"], ["proof (prove)\nusing this:\n  token_run x m \\<in> F\n  token_run ?x ?n \\<in> F \\<Longrightarrow>\n  \\<exists>m\\<ge>?x.\n     token_run ?x m \\<notin> F - {q\\<^sub>0} \\<and>\n     token_run ?x (Suc m) \\<in> F\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>token_run x n \\<notin> F - {q\\<^sub>0};\n         token_run x (Suc n) \\<in> F; x \\<le> n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  token_run x n \\<notin> F - {q\\<^sub>0}\n  token_run x (Suc n) \\<in> F\n  x \\<le> n\n\ngoal (2 subgoals):\n 1. token_succeeds x \\<Longrightarrow> \\<exists>i. x \\<in> succeed i\n 2. \\<exists>i. x \\<in> succeed i \\<Longrightarrow> token_succeeds x", "moreover"], ["proof (state)\nthis:\n  token_run x n \\<notin> F - {q\\<^sub>0}\n  token_run x (Suc n) \\<in> F\n  x \\<le> n\n\ngoal (2 subgoals):\n 1. token_succeeds x \\<Longrightarrow> \\<exists>i. x \\<in> succeed i\n 2. \\<exists>i. x \\<in> succeed i \\<Longrightarrow> token_succeeds x", "hence \"\\<not>sink (token_run x n)\""], ["proof (prove)\nusing this:\n  token_run x n \\<notin> F - {q\\<^sub>0}\n  token_run x (Suc n) \\<in> F\n  x \\<le> n\n\ngoal (1 subgoal):\n 1. \\<not> sink (token_run x n)", "proof (cases \"token_run x n \\<noteq> q\\<^sub>0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>token_run x n \\<notin> F - {q\\<^sub>0};\n     token_run x (Suc n) \\<in> F; x \\<le> n;\n     token_run x n \\<noteq> q\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> \\<not> sink (token_run x n)\n 2. \\<lbrakk>token_run x n \\<notin> F - {q\\<^sub>0};\n     token_run x (Suc n) \\<in> F; x \\<le> n;\n     \\<not> token_run x n \\<noteq> q\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> \\<not> sink (token_run x n)", "case True"], ["proof (state)\nthis:\n  token_run x n \\<noteq> q\\<^sub>0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>token_run x n \\<notin> F - {q\\<^sub>0};\n     token_run x (Suc n) \\<in> F; x \\<le> n;\n     token_run x n \\<noteq> q\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> \\<not> sink (token_run x n)\n 2. \\<lbrakk>token_run x n \\<notin> F - {q\\<^sub>0};\n     token_run x (Suc n) \\<in> F; x \\<le> n;\n     \\<not> token_run x n \\<noteq> q\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> \\<not> sink (token_run x n)", "hence \"token_run x n \\<notin> F\""], ["proof (prove)\nusing this:\n  token_run x n \\<noteq> q\\<^sub>0\n\ngoal (1 subgoal):\n 1. token_run x n \\<notin> F", "using \\<open>token_run x n \\<notin> F - {q\\<^sub>0}\\<close>"], ["proof (prove)\nusing this:\n  token_run x n \\<noteq> q\\<^sub>0\n  token_run x n \\<notin> F - {q\\<^sub>0}\n\ngoal (1 subgoal):\n 1. token_run x n \\<notin> F", "by blast"], ["proof (state)\nthis:\n  token_run x n \\<notin> F\n\ngoal (2 subgoals):\n 1. \\<lbrakk>token_run x n \\<notin> F - {q\\<^sub>0};\n     token_run x (Suc n) \\<in> F; x \\<le> n;\n     token_run x n \\<noteq> q\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> \\<not> sink (token_run x n)\n 2. \\<lbrakk>token_run x n \\<notin> F - {q\\<^sub>0};\n     token_run x (Suc n) \\<in> F; x \\<le> n;\n     \\<not> token_run x n \\<noteq> q\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> \\<not> sink (token_run x n)", "thus ?thesis"], ["proof (prove)\nusing this:\n  token_run x n \\<notin> F\n\ngoal (1 subgoal):\n 1. \\<not> sink (token_run x n)", "using \\<open>token_run x (Suc n) \\<in> F\\<close> token_stays_in_sink"], ["proof (prove)\nusing this:\n  token_run x n \\<notin> F\n  token_run x (Suc n) \\<in> F\n  \\<lbrakk>sink ?q; token_run ?x ?n = ?q\\<rbrakk>\n  \\<Longrightarrow> token_run ?x (?n + ?m) = ?q\n\ngoal (1 subgoal):\n 1. \\<not> sink (token_run x n)", "unfolding Suc_eq_plus1"], ["proof (prove)\nusing this:\n  token_run x n \\<notin> F\n  token_run x (n + 1) \\<in> F\n  \\<lbrakk>sink ?q; token_run ?x ?n = ?q\\<rbrakk>\n  \\<Longrightarrow> token_run ?x (?n + ?m) = ?q\n\ngoal (1 subgoal):\n 1. \\<not> sink (token_run x n)", "by metis"], ["proof (state)\nthis:\n  \\<not> sink (token_run x n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>token_run x n \\<notin> F - {q\\<^sub>0};\n     token_run x (Suc n) \\<in> F; x \\<le> n;\n     \\<not> token_run x n \\<noteq> q\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> \\<not> sink (token_run x n)", "qed (simp add: sink_def)"], ["proof (state)\nthis:\n  \\<not> sink (token_run x n)\n\ngoal (2 subgoals):\n 1. token_succeeds x \\<Longrightarrow> \\<exists>i. x \\<in> succeed i\n 2. \\<exists>i. x \\<in> succeed i \\<Longrightarrow> token_succeeds x", "then"], ["proof (chain)\npicking this:\n  \\<not> sink (token_run x n)", "obtain i where \"rank x n = Some i\""], ["proof (prove)\nusing this:\n  \\<not> sink (token_run x n)\n\ngoal (1 subgoal):\n 1. (\\<And>i. rank x n = Some i \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>x \\<le> n\\<close>"], ["proof (prove)\nusing this:\n  \\<not> sink (token_run x n)\n  x \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<And>i. rank x n = Some i \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  rank x n = Some i\n\ngoal (2 subgoals):\n 1. token_succeeds x \\<Longrightarrow> \\<exists>i. x \\<in> succeed i\n 2. \\<exists>i. x \\<in> succeed i \\<Longrightarrow> token_succeeds x", "ultimately"], ["proof (chain)\npicking this:\n  token_run x n \\<notin> F - {q\\<^sub>0}\n  token_run x (Suc n) \\<in> F\n  x \\<le> n\n  rank x n = Some i", "show ?rhs"], ["proof (prove)\nusing this:\n  token_run x n \\<notin> F - {q\\<^sub>0}\n  token_run x (Suc n) \\<in> F\n  x \\<le> n\n  rank x n = Some i\n\ngoal (1 subgoal):\n 1. \\<exists>i. x \\<in> succeed i", "unfolding succeed_def"], ["proof (prove)\nusing this:\n  token_run x n \\<notin> F - {q\\<^sub>0}\n  token_run x (Suc n) \\<in> F\n  x \\<le> n\n  rank x n = Some i\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       x \\<in> {x. \\<exists>n.\n                      rank x n = Some i \\<and>\n                      token_run x n \\<notin> F - {q\\<^sub>0} \\<and>\n                      token_run x (Suc n) \\<in> F}", "by blast"], ["proof (state)\nthis:\n  \\<exists>i. x \\<in> succeed i\n\ngoal (1 subgoal):\n 1. \\<exists>i. x \\<in> succeed i \\<Longrightarrow> token_succeeds x", "qed (unfold token_succeeds_def succeed_def, blast)"], ["", "lemma stable_rank_succeed:\n  assumes \"infinite (succeed i)\"\n      and \"x \\<in> succeed i\"\n      and \"q\\<^sub>0 \\<notin> F\"\n  shows \"\\<not>stable_rank x i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> stable_rank x i", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. stable_rank x i \\<Longrightarrow> False", "assume \"stable_rank x i\""], ["proof (state)\nthis:\n  stable_rank x i\n\ngoal (1 subgoal):\n 1. stable_rank x i \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  stable_rank x i", "obtain n where \"\\<forall>n' \\<ge> n. rank x n' = Some i\""], ["proof (prove)\nusing this:\n  stable_rank x i\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<forall>n'\\<ge>n. rank x n' = Some i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding stable_rank_def MOST_nat_le"], ["proof (prove)\nusing this:\n  \\<exists>m. \\<forall>n\\<ge>m. rank x n = Some i\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<forall>n'\\<ge>n. rank x n' = Some i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by rule"], ["proof (state)\nthis:\n  \\<forall>n'\\<ge>n. rank x n' = Some i\n\ngoal (1 subgoal):\n 1. stable_rank x i \\<Longrightarrow> False", "from assms(2)"], ["proof (chain)\npicking this:\n  x \\<in> succeed i", "obtain m where \"token_run x m \\<notin> F\"\n    and \"token_run x (Suc m) \\<in> F\"\n    and \"rank x m = Some i\""], ["proof (prove)\nusing this:\n  x \\<in> succeed i\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>token_run x m \\<notin> F; token_run x (Suc m) \\<in> F;\n         rank x m = Some i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(3)"], ["proof (prove)\nusing this:\n  x \\<in> succeed i\n  q\\<^sub>0 \\<notin> F\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>token_run x m \\<notin> F; token_run x (Suc m) \\<in> F;\n         rank x m = Some i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding succeed_def"], ["proof (prove)\nusing this:\n  x \\<in> {x. \\<exists>n.\n                 rank x n = Some i \\<and>\n                 token_run x n \\<notin> F - {q\\<^sub>0} \\<and>\n                 token_run x (Suc n) \\<in> F}\n  q\\<^sub>0 \\<notin> F\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>token_run x m \\<notin> F; token_run x (Suc m) \\<in> F;\n         rank x m = Some i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  token_run x m \\<notin> F\n  token_run x (Suc m) \\<in> F\n  rank x m = Some i\n\ngoal (1 subgoal):\n 1. stable_rank x i \\<Longrightarrow> False", "obtain y where \"y > max n m\" and \"y \\<in> succeed i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>max n m < y; y \\<in> succeed i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(1)"], ["proof (prove)\nusing this:\n  infinite (succeed i)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>max n m < y; y \\<in> succeed i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding infinite_nat_iff_unbounded"], ["proof (prove)\nusing this:\n  \\<forall>m. \\<exists>n>m. n \\<in> succeed i\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>max n m < y; y \\<in> succeed i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  max n m < y\n  y \\<in> succeed i\n\ngoal (1 subgoal):\n 1. stable_rank x i \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  max n m < y\n  y \\<in> succeed i", "obtain m' where \"token_run y m' \\<notin> F\"\n    and \"token_run y (Suc m') \\<in> F\"\n    and \"rank y m' = Some i\""], ["proof (prove)\nusing this:\n  max n m < y\n  y \\<in> succeed i\n\ngoal (1 subgoal):\n 1. (\\<And>m'.\n        \\<lbrakk>token_run y m' \\<notin> F; token_run y (Suc m') \\<in> F;\n         rank y m' = Some i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(3)"], ["proof (prove)\nusing this:\n  max n m < y\n  y \\<in> succeed i\n  q\\<^sub>0 \\<notin> F\n\ngoal (1 subgoal):\n 1. (\\<And>m'.\n        \\<lbrakk>token_run y m' \\<notin> F; token_run y (Suc m') \\<in> F;\n         rank y m' = Some i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding succeed_def"], ["proof (prove)\nusing this:\n  max n m < y\n  y \\<in> {x. \\<exists>n.\n                 rank x n = Some i \\<and>\n                 token_run x n \\<notin> F - {q\\<^sub>0} \\<and>\n                 token_run x (Suc n) \\<in> F}\n  q\\<^sub>0 \\<notin> F\n\ngoal (1 subgoal):\n 1. (\\<And>m'.\n        \\<lbrakk>token_run y m' \\<notin> F; token_run y (Suc m') \\<in> F;\n         rank y m' = Some i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  token_run y m' \\<notin> F\n  token_run y (Suc m') \\<in> F\n  rank y m' = Some i\n\ngoal (1 subgoal):\n 1. stable_rank x i \\<Longrightarrow> False", "moreover\n\n  \\<comment> \\<open>token has still rank i at m'\\<close>"], ["proof (state)\nthis:\n  token_run y m' \\<notin> F\n  token_run y (Suc m') \\<in> F\n  rank y m' = Some i\n\ngoal (1 subgoal):\n 1. stable_rank x i \\<Longrightarrow> False", "have \"m' \\<ge> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> m'", "using rank_Some_time[OF \\<open>rank y m' = Some i\\<close>] \\<open>y > max n m\\<close>"], ["proof (prove)\nusing this:\n  y \\<le> m'\n  max n m < y\n\ngoal (1 subgoal):\n 1. n \\<le> m'", "by force"], ["proof (state)\nthis:\n  n \\<le> m'\n\ngoal (1 subgoal):\n 1. stable_rank x i \\<Longrightarrow> False", "hence \"rank x m' = Some i\""], ["proof (prove)\nusing this:\n  n \\<le> m'\n\ngoal (1 subgoal):\n 1. rank x m' = Some i", "using  \\<open>\\<forall>n' \\<ge> n. rank x n' = Some i\\<close>"], ["proof (prove)\nusing this:\n  n \\<le> m'\n  \\<forall>n'\\<ge>n. rank x n' = Some i\n\ngoal (1 subgoal):\n 1. rank x m' = Some i", "by blast"], ["proof (state)\nthis:\n  rank x m' = Some i\n\ngoal (1 subgoal):\n 1. stable_rank x i \\<Longrightarrow> False", "moreover\n\n  \\<comment> \\<open>but x and y are not in the same state\\<close>"], ["proof (state)\nthis:\n  rank x m' = Some i\n\ngoal (1 subgoal):\n 1. stable_rank x i \\<Longrightarrow> False", "have \"m' \\<ge> Suc m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc m \\<le> m'", "using rank_Some_time[OF \\<open>rank y m' = Some i\\<close>] \\<open>y > max n m\\<close>"], ["proof (prove)\nusing this:\n  y \\<le> m'\n  max n m < y\n\ngoal (1 subgoal):\n 1. Suc m \\<le> m'", "by force"], ["proof (state)\nthis:\n  Suc m \\<le> m'\n\ngoal (1 subgoal):\n 1. stable_rank x i \\<Longrightarrow> False", "hence \"token_run x m' \\<in> F\""], ["proof (prove)\nusing this:\n  Suc m \\<le> m'\n\ngoal (1 subgoal):\n 1. token_run x m' \\<in> F", "using token_stays_in_final_states[OF \\<open>token_run x (Suc m) \\<in> F\\<close>]"], ["proof (prove)\nusing this:\n  Suc m \\<le> m'\n  token_run x (Suc m + ?m) \\<in> F\n\ngoal (1 subgoal):\n 1. token_run x m' \\<in> F", "unfolding le_iff_add"], ["proof (prove)\nusing this:\n  \\<exists>c. m' = Suc m + c\n  token_run x (Suc m + ?m) \\<in> F\n\ngoal (1 subgoal):\n 1. token_run x m' \\<in> F", "by fast"], ["proof (state)\nthis:\n  token_run x m' \\<in> F\n\ngoal (1 subgoal):\n 1. stable_rank x i \\<Longrightarrow> False", "with \\<open>token_run y m' \\<notin> F \\<close>"], ["proof (chain)\npicking this:\n  token_run y m' \\<notin> F\n  token_run x m' \\<in> F", "have \"token_run y m' \\<noteq> token_run x m'\""], ["proof (prove)\nusing this:\n  token_run y m' \\<notin> F\n  token_run x m' \\<in> F\n\ngoal (1 subgoal):\n 1. token_run y m' \\<noteq> token_run x m'", "by metis"], ["proof (state)\nthis:\n  token_run y m' \\<noteq> token_run x m'\n\ngoal (1 subgoal):\n 1. stable_rank x i \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  token_run y m' \\<notin> F\n  token_run y (Suc m') \\<in> F\n  rank y m' = Some i\n  rank x m' = Some i\n  token_run y m' \\<noteq> token_run x m'", "show \"False\""], ["proof (prove)\nusing this:\n  token_run y m' \\<notin> F\n  token_run y (Suc m') \\<in> F\n  rank y m' = Some i\n  rank x m' = Some i\n  token_run y m' \\<noteq> token_run x m'\n\ngoal (1 subgoal):\n 1. False", "using push_down_rank_tokens"], ["proof (prove)\nusing this:\n  token_run y m' \\<notin> F\n  token_run y (Suc m') \\<in> F\n  rank y m' = Some i\n  rank x m' = Some i\n  token_run y m' \\<noteq> token_run x m'\n  \\<lbrakk>rank ?x ?n = rank ?y ?n; rank ?x ?n = Some ?i\\<rbrakk>\n  \\<Longrightarrow> \\<exists>q.\n                       ?x \\<in> configuration q ?n \\<and>\n                       ?y \\<in> configuration q ?n\n\ngoal (1 subgoal):\n 1. False", "by force"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma stable_rank_bounded:\n  assumes stable: \"stable_rank x j\"\n  assumes inf: \"infinite (succeed i)\"\n  assumes \"q\\<^sub>0 \\<notin> F\"\n  shows \"j < i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. j < i", "from stable"], ["proof (chain)\npicking this:\n  stable_rank x j", "obtain m where \"\\<forall>m' \\<ge> m. rank x m' = Some j\""], ["proof (prove)\nusing this:\n  stable_rank x j\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<forall>m'\\<ge>m. rank x m' = Some j \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding stable_rank_def MOST_nat_le"], ["proof (prove)\nusing this:\n  \\<exists>m. \\<forall>n\\<ge>m. rank x n = Some j\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<forall>m'\\<ge>m. rank x m' = Some j \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by rule"], ["proof (state)\nthis:\n  \\<forall>m'\\<ge>m. rank x m' = Some j\n\ngoal (1 subgoal):\n 1. j < i", "from inf"], ["proof (chain)\npicking this:\n  infinite (succeed i)", "obtain y where \"y \\<ge> m\" and \"y \\<in> succeed i\""], ["proof (prove)\nusing this:\n  infinite (succeed i)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>m \\<le> y; y \\<in> succeed i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding infinite_nat_iff_unbounded_le"], ["proof (prove)\nusing this:\n  \\<forall>m. \\<exists>n\\<ge>m. n \\<in> succeed i\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>m \\<le> y; y \\<in> succeed i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by meson"], ["proof (state)\nthis:\n  m \\<le> y\n  y \\<in> succeed i\n\ngoal (1 subgoal):\n 1. j < i", "then"], ["proof (chain)\npicking this:\n  m \\<le> y\n  y \\<in> succeed i", "obtain n where \"rank y n = Some i\""], ["proof (prove)\nusing this:\n  m \\<le> y\n  y \\<in> succeed i\n\ngoal (1 subgoal):\n 1. (\\<And>n. rank y n = Some i \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding succeed_def MOST_nat_le"], ["proof (prove)\nusing this:\n  m \\<le> y\n  y \\<in> {x. \\<exists>n.\n                 rank x n = Some i \\<and>\n                 token_run x n \\<notin> F - {q\\<^sub>0} \\<and>\n                 token_run x (Suc n) \\<in> F}\n\ngoal (1 subgoal):\n 1. (\\<And>n. rank y n = Some i \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  rank y n = Some i\n\ngoal (1 subgoal):\n 1. j < i", "moreover"], ["proof (state)\nthis:\n  rank y n = Some i\n\ngoal (1 subgoal):\n 1. j < i", "hence \"n \\<ge> y\""], ["proof (prove)\nusing this:\n  rank y n = Some i\n\ngoal (1 subgoal):\n 1. y \\<le> n", "by (rule rank_Some_time)"], ["proof (state)\nthis:\n  y \\<le> n\n\ngoal (1 subgoal):\n 1. j < i", "hence \"rank x n = Some j\""], ["proof (prove)\nusing this:\n  y \\<le> n\n\ngoal (1 subgoal):\n 1. rank x n = Some j", "using \\<open>\\<forall>m' \\<ge> m. rank x m' = Some j\\<close> \\<open>y \\<ge> m\\<close>"], ["proof (prove)\nusing this:\n  y \\<le> n\n  \\<forall>m'\\<ge>m. rank x m' = Some j\n  m \\<le> y\n\ngoal (1 subgoal):\n 1. rank x n = Some j", "by fastforce"], ["proof (state)\nthis:\n  rank x n = Some j\n\ngoal (1 subgoal):\n 1. j < i", "ultimately\n\n  \\<comment> \\<open>In the case @{term \"i \\<le> j\"}, the token y has also to stabilise with @{term i} at @{term n}.\\<close>"], ["proof (chain)\npicking this:\n  rank y n = Some i\n  rank x n = Some j", "have \"i \\<le> j \\<Longrightarrow> stable_rank y i\""], ["proof (prove)\nusing this:\n  rank y n = Some i\n  rank x n = Some j\n\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow> stable_rank y i", "using stable"], ["proof (prove)\nusing this:\n  rank y n = Some i\n  rank x n = Some j\n  stable_rank x j\n\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow> stable_rank y i", "by (blast intro: stable_rank_tower)"], ["proof (state)\nthis:\n  i \\<le> j \\<Longrightarrow> stable_rank y i\n\ngoal (1 subgoal):\n 1. j < i", "thus \"j < i\""], ["proof (prove)\nusing this:\n  i \\<le> j \\<Longrightarrow> stable_rank y i\n\ngoal (1 subgoal):\n 1. j < i", "using stable_rank_succeed[OF inf \\<open>y \\<in> succeed i\\<close> \\<open>q\\<^sub>0 \\<notin> F\\<close>]"], ["proof (prove)\nusing this:\n  i \\<le> j \\<Longrightarrow> stable_rank y i\n  \\<not> stable_rank y i\n\ngoal (1 subgoal):\n 1. j < i", "by linarith"], ["proof (state)\nthis:\n  j < i\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open>Relation to Mojmir Acceptance\\<close>"], ["", "lemma mojmir_accept_token_set_def1:\n  assumes \"accept\"\n  shows \"\\<exists>i < max_rank. finite fail \\<and> finite (merge i) \\<and> infinite (succeed i) \\<and> (\\<forall>j < i. finite (succeed j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i<max_rank.\n       finite fail \\<and>\n       finite (local.merge i) \\<and>\n       infinite (succeed i) \\<and> (\\<forall>j<i. finite (succeed j))", "proof (rule+)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?i < max_rank\n 2. finite fail \\<and>\n    finite (local.merge ?i) \\<and>\n    infinite (succeed ?i) \\<and> (\\<forall>j<?i. finite (succeed j))", "define i where \"i = (LEAST k. infinite (succeed k))\""], ["proof (state)\nthis:\n  i = (LEAST k. infinite (succeed k))\n\ngoal (2 subgoals):\n 1. ?i < max_rank\n 2. finite fail \\<and>\n    finite (local.merge ?i) \\<and>\n    infinite (succeed ?i) \\<and> (\\<forall>j<?i. finite (succeed j))", "from assms"], ["proof (chain)\npicking this:\n  accept\\<^sub>M", "have \"infinite {t. token_succeeds t}\""], ["proof (prove)\nusing this:\n  accept\\<^sub>M\n\ngoal (1 subgoal):\n 1. infinite (Collect token_succeeds)", "unfolding mojmir_accept_alt_def"], ["proof (prove)\nusing this:\n  finite {x. \\<not> token_succeeds x}\n\ngoal (1 subgoal):\n 1. infinite (Collect token_succeeds)", "by force"], ["proof (state)\nthis:\n  infinite (Collect token_succeeds)\n\ngoal (2 subgoals):\n 1. ?i < max_rank\n 2. finite fail \\<and>\n    finite (local.merge ?i) \\<and>\n    infinite (succeed ?i) \\<and> (\\<forall>j<?i. finite (succeed j))", "moreover"], ["proof (state)\nthis:\n  infinite (Collect token_succeeds)\n\ngoal (2 subgoals):\n 1. ?i < max_rank\n 2. finite fail \\<and>\n    finite (local.merge ?i) \\<and>\n    infinite (succeed ?i) \\<and> (\\<forall>j<?i. finite (succeed j))", "have \"{x. token_succeeds x} = \\<Union>{succeed i | i. i < max_rank}\"\n    (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Collect token_succeeds = \\<Union> {succeed i |i. i < max_rank}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Collect token_succeeds = \\<Union> {succeed i |i. i < max_rank}", "have \"?lhs = \\<Union>{succeed i | i. True}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Collect token_succeeds = \\<Union> {succeed i |i. True}", "using succeed_membership"], ["proof (prove)\nusing this:\n  token_succeeds ?x = (\\<exists>i. ?x \\<in> succeed i)\n\ngoal (1 subgoal):\n 1. Collect token_succeeds = \\<Union> {succeed i |i. True}", "by blast"], ["proof (state)\nthis:\n  Collect token_succeeds = \\<Union> {succeed i |i. True}\n\ngoal (1 subgoal):\n 1. Collect token_succeeds = \\<Union> {succeed i |i. i < max_rank}", "also"], ["proof (state)\nthis:\n  Collect token_succeeds = \\<Union> {succeed i |i. True}\n\ngoal (1 subgoal):\n 1. Collect token_succeeds = \\<Union> {succeed i |i. i < max_rank}", "have \"\\<dots> = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> {succeed i |i. True} = \\<Union> {succeed i |i. i < max_rank}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<Union> {succeed i |i. True}\n    \\<subseteq> \\<Union> {succeed i |i. i < max_rank}\n 2. \\<Union> {succeed i |i. i < max_rank}\n    \\<subseteq> \\<Union> {succeed i |i. True}", "show \"\\<dots> \\<subseteq> ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> {succeed i |i. True}\n    \\<subseteq> \\<Union> {succeed i |i. i < max_rank}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> {succeed i |i. True} \\<Longrightarrow>\n       x \\<in> \\<Union> {succeed i |i. i < max_rank}", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> {succeed i |i. True} \\<Longrightarrow>\n       x \\<in> \\<Union> {succeed i |i. i < max_rank}", "assume \"x \\<in> \\<Union>{succeed i |i. True}\""], ["proof (state)\nthis:\n  x \\<in> \\<Union> {succeed i |i. True}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> {succeed i |i. True} \\<Longrightarrow>\n       x \\<in> \\<Union> {succeed i |i. i < max_rank}", "then"], ["proof (chain)\npicking this:\n  x \\<in> \\<Union> {succeed i |i. True}", "obtain i where \"x \\<in> succeed i\""], ["proof (prove)\nusing this:\n  x \\<in> \\<Union> {succeed i |i. True}\n\ngoal (1 subgoal):\n 1. (\\<And>i. x \\<in> succeed i \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> succeed i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> {succeed i |i. True} \\<Longrightarrow>\n       x \\<in> \\<Union> {succeed i |i. i < max_rank}", "moreover\n        \\<comment> \\<open>Obtain upper bound for succeed ranks\\<close>"], ["proof (state)\nthis:\n  x \\<in> succeed i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> {succeed i |i. True} \\<Longrightarrow>\n       x \\<in> \\<Union> {succeed i |i. i < max_rank}", "have \"\\<And>u. u \\<ge> max_rank \\<Longrightarrow> succeed u = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u. max_rank \\<le> u \\<Longrightarrow> succeed u = {}", "unfolding succeed_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u.\n       max_rank \\<le> u \\<Longrightarrow>\n       {x. \\<exists>n.\n              rank x n = Some u \\<and>\n              token_run x n \\<notin> F - {q\\<^sub>0} \\<and>\n              token_run x (Suc n) \\<in> F} =\n       {}", "using rank_upper_bound"], ["proof (prove)\nusing this:\n  rank ?x ?n = Some ?i \\<Longrightarrow> ?i < max_rank\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       max_rank \\<le> u \\<Longrightarrow>\n       {x. \\<exists>n.\n              rank x n = Some u \\<and>\n              token_run x n \\<notin> F - {q\\<^sub>0} \\<and>\n              token_run x (Suc n) \\<in> F} =\n       {}", "by fastforce"], ["proof (state)\nthis:\n  max_rank \\<le> ?u \\<Longrightarrow> succeed ?u = {}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> {succeed i |i. True} \\<Longrightarrow>\n       x \\<in> \\<Union> {succeed i |i. i < max_rank}", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> succeed i\n  max_rank \\<le> ?u \\<Longrightarrow> succeed ?u = {}", "show \"x \\<in> \\<Union>{succeed i |i. i < max_rank}\""], ["proof (prove)\nusing this:\n  x \\<in> succeed i\n  max_rank \\<le> ?u \\<Longrightarrow> succeed ?u = {}\n\ngoal (1 subgoal):\n 1. x \\<in> \\<Union> {succeed i |i. i < max_rank}", "by (cases \"i < max_rank\") (blast, simp)"], ["proof (state)\nthis:\n  x \\<in> \\<Union> {succeed i |i. i < max_rank}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Union> {succeed i |i. True}\n  \\<subseteq> \\<Union> {succeed i |i. i < max_rank}\n\ngoal (1 subgoal):\n 1. \\<Union> {succeed i |i. i < max_rank}\n    \\<subseteq> \\<Union> {succeed i |i. True}", "qed blast"], ["proof (state)\nthis:\n  \\<Union> {succeed i |i. True} = \\<Union> {succeed i |i. i < max_rank}\n\ngoal (1 subgoal):\n 1. Collect token_succeeds = \\<Union> {succeed i |i. i < max_rank}", "finally"], ["proof (chain)\npicking this:\n  Collect token_succeeds = \\<Union> {succeed i |i. i < max_rank}", "show ?thesis"], ["proof (prove)\nusing this:\n  Collect token_succeeds = \\<Union> {succeed i |i. i < max_rank}\n\ngoal (1 subgoal):\n 1. Collect token_succeeds = \\<Union> {succeed i |i. i < max_rank}", "."], ["proof (state)\nthis:\n  Collect token_succeeds = \\<Union> {succeed i |i. i < max_rank}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Collect token_succeeds = \\<Union> {succeed i |i. i < max_rank}\n\ngoal (2 subgoals):\n 1. ?i < max_rank\n 2. finite fail \\<and>\n    finite (local.merge ?i) \\<and>\n    infinite (succeed ?i) \\<and> (\\<forall>j<?i. finite (succeed j))", "ultimately"], ["proof (chain)\npicking this:\n  infinite (Collect token_succeeds)\n  Collect token_succeeds = \\<Union> {succeed i |i. i < max_rank}", "have \"\\<exists>j. infinite (succeed j)\""], ["proof (prove)\nusing this:\n  infinite (Collect token_succeeds)\n  Collect token_succeeds = \\<Union> {succeed i |i. i < max_rank}\n\ngoal (1 subgoal):\n 1. \\<exists>j. infinite (succeed j)", "by force"], ["proof (state)\nthis:\n  \\<exists>j. infinite (succeed j)\n\ngoal (2 subgoals):\n 1. ?i < max_rank\n 2. finite fail \\<and>\n    finite (local.merge ?i) \\<and>\n    infinite (succeed ?i) \\<and> (\\<forall>j<?i. finite (succeed j))", "hence \"infinite (succeed i)\" and \"\\<And>j. j < i \\<Longrightarrow> finite (succeed j)\""], ["proof (prove)\nusing this:\n  \\<exists>j. infinite (succeed j)\n\ngoal (1 subgoal):\n 1. infinite (succeed i) &&&\n    (\\<And>j. j < i \\<Longrightarrow> finite (succeed j))", "unfolding i_def"], ["proof (prove)\nusing this:\n  \\<exists>j. infinite (succeed j)\n\ngoal (1 subgoal):\n 1. infinite (succeed (LEAST k. infinite (succeed k))) &&&\n    (\\<And>j.\n        j < (LEAST k. infinite (succeed k)) \\<Longrightarrow>\n        finite (succeed j))", "by (metis LeastI_ex, metis not_less_Least)"], ["proof (state)\nthis:\n  infinite (succeed i)\n  ?j < i \\<Longrightarrow> finite (succeed ?j)\n\ngoal (2 subgoals):\n 1. ?i < max_rank\n 2. finite fail \\<and>\n    finite (local.merge ?i) \\<and>\n    infinite (succeed ?i) \\<and> (\\<forall>j<?i. finite (succeed j))", "hence fin_succeed_ranks: \"finite (\\<Union>{succeed j | j. j < i})\""], ["proof (prove)\nusing this:\n  infinite (succeed i)\n  ?j < i \\<Longrightarrow> finite (succeed ?j)\n\ngoal (1 subgoal):\n 1. finite (\\<Union> {succeed j |j. j < i})", "by auto\n\n  \\<comment> \\<open>@{term i} is bounded by @{term max_rank}\\<close>"], ["proof (state)\nthis:\n  finite (\\<Union> {succeed j |j. j < i})\n\ngoal (2 subgoals):\n 1. ?i < max_rank\n 2. finite fail \\<and>\n    finite (local.merge ?i) \\<and>\n    infinite (succeed ?i) \\<and> (\\<forall>j<?i. finite (succeed j))", "{"], ["proof (state)\nthis:\n  finite (\\<Union> {succeed j |j. j < i})\n\ngoal (2 subgoals):\n 1. ?i < max_rank\n 2. finite fail \\<and>\n    finite (local.merge ?i) \\<and>\n    infinite (succeed ?i) \\<and> (\\<forall>j<?i. finite (succeed j))", "obtain x where \"x \\<in> succeed i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> succeed i \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>infinite (succeed i)\\<close>"], ["proof (prove)\nusing this:\n  infinite (succeed i)\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> succeed i \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  x \\<in> succeed i\n\ngoal (2 subgoals):\n 1. ?i < max_rank\n 2. finite fail \\<and>\n    finite (local.merge ?i) \\<and>\n    infinite (succeed ?i) \\<and> (\\<forall>j<?i. finite (succeed j))", "then"], ["proof (chain)\npicking this:\n  x \\<in> succeed i", "obtain n where \"rank x n = Some i\""], ["proof (prove)\nusing this:\n  x \\<in> succeed i\n\ngoal (1 subgoal):\n 1. (\\<And>n. rank x n = Some i \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding succeed_def"], ["proof (prove)\nusing this:\n  x \\<in> {x. \\<exists>n.\n                 rank x n = Some i \\<and>\n                 token_run x n \\<notin> F - {q\\<^sub>0} \\<and>\n                 token_run x (Suc n) \\<in> F}\n\ngoal (1 subgoal):\n 1. (\\<And>n. rank x n = Some i \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  rank x n = Some i\n\ngoal (2 subgoals):\n 1. ?i < max_rank\n 2. finite fail \\<and>\n    finite (local.merge ?i) \\<and>\n    infinite (succeed ?i) \\<and> (\\<forall>j<?i. finite (succeed j))", "thus \"i < max_rank\""], ["proof (prove)\nusing this:\n  rank x n = Some i\n\ngoal (1 subgoal):\n 1. i < max_rank", "by (rule rank_upper_bound)"], ["proof (state)\nthis:\n  i < max_rank\n\ngoal (1 subgoal):\n 1. finite fail \\<and>\n    finite (local.merge (LEAST k. infinite (succeed k))) \\<and>\n    infinite (succeed (LEAST k. infinite (succeed k))) \\<and>\n    (\\<forall>j<LEAST k. infinite (succeed k). finite (succeed j))", "}"], ["proof (state)\nthis:\n  i < max_rank\n\ngoal (1 subgoal):\n 1. finite fail \\<and>\n    finite (local.merge (LEAST k. infinite (succeed k))) \\<and>\n    infinite (succeed (LEAST k. infinite (succeed k))) \\<and>\n    (\\<forall>j<LEAST k. infinite (succeed k). finite (succeed j))", "define S where \"S = {(x, y). token_succeeds x \\<and> token_succeeds y}\""], ["proof (state)\nthis:\n  S = {(x, y). token_succeeds x \\<and> token_succeeds y}\n\ngoal (1 subgoal):\n 1. finite fail \\<and>\n    finite (local.merge (LEAST k. infinite (succeed k))) \\<and>\n    infinite (succeed (LEAST k. infinite (succeed k))) \\<and>\n    (\\<forall>j<LEAST k. infinite (succeed k). finite (succeed j))", "have \"finite (merge i \\<inter> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (local.merge i \\<inter> S)", "proof (rule finite_product)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (fst ` (local.merge i \\<inter> S))\n 2. finite (snd ` (local.merge i \\<inter> S))", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (fst ` (local.merge i \\<inter> S))\n 2. finite (snd ` (local.merge i \\<inter> S))", "fix x y"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (fst ` (local.merge i \\<inter> S))\n 2. finite (snd ` (local.merge i \\<inter> S))", "assume \"(x, y) \\<in> (merge i \\<inter> S)\""], ["proof (state)\nthis:\n  (x, y) \\<in> local.merge i \\<inter> S\n\ngoal (2 subgoals):\n 1. finite (fst ` (local.merge i \\<inter> S))\n 2. finite (snd ` (local.merge i \\<inter> S))", "then"], ["proof (chain)\npicking this:\n  (x, y) \\<in> local.merge i \\<inter> S", "obtain n k k'' where \"k < i\"\n        and \"rank x n = Some k\"\n        and \"rank y n = Some k'' \\<or> y = Suc n\"\n        and \"token_run x (Suc n) \\<notin> F\"\n        and \"token_run x (Suc n) = token_run y (Suc n)\"\n        and \"token_succeeds x\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> local.merge i \\<inter> S\n\ngoal (1 subgoal):\n 1. (\\<And>k n k''.\n        \\<lbrakk>k < i; rank x n = Some k;\n         rank y n = Some k'' \\<or> y = Suc n;\n         token_run x (Suc n) \\<notin> F;\n         token_run x (Suc n) = token_run y (Suc n);\n         token_succeeds x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding merge_def S_def"], ["proof (prove)\nusing this:\n  (x, y)\n  \\<in> {uu_.\n         \\<exists>x y n j.\n            uu_ = (x, y) \\<and>\n            j < i \\<and>\n            (token_run x n \\<noteq> token_run y n \\<and>\n             rank y n \\<noteq> None \\<or>\n             y = Suc n) \\<and>\n            token_run x (Suc n) = token_run y (Suc n) \\<and>\n            token_run x (Suc n) \\<notin> F \\<and>\n            rank x n = Some j} \\<inter>\n        {(x, y). token_succeeds x \\<and> token_succeeds y}\n\ngoal (1 subgoal):\n 1. (\\<And>k n k''.\n        \\<lbrakk>k < i; rank x n = Some k;\n         rank y n = Some k'' \\<or> y = Suc n;\n         token_run x (Suc n) \\<notin> F;\n         token_run x (Suc n) = token_run y (Suc n);\n         token_succeeds x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  k < i\n  rank x n = Some k\n  rank y n = Some k'' \\<or> y = Suc n\n  token_run x (Suc n) \\<notin> F\n  token_run x (Suc n) = token_run y (Suc n)\n  token_succeeds x\n\ngoal (2 subgoals):\n 1. finite (fst ` (local.merge i \\<inter> S))\n 2. finite (snd ` (local.merge i \\<inter> S))", "then"], ["proof (chain)\npicking this:\n  k < i\n  rank x n = Some k\n  rank y n = Some k'' \\<or> y = Suc n\n  token_run x (Suc n) \\<notin> F\n  token_run x (Suc n) = token_run y (Suc n)\n  token_succeeds x", "obtain m where \"token_run x (Suc n + m) \\<notin> F\"\n        and \"token_run x (Suc (Suc n + m)) \\<in> F\""], ["proof (prove)\nusing this:\n  k < i\n  rank x n = Some k\n  rank y n = Some k'' \\<or> y = Suc n\n  token_run x (Suc n) \\<notin> F\n  token_run x (Suc n) = token_run y (Suc n)\n  token_succeeds x\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>token_run x (Suc n + m) \\<notin> F;\n         token_run x (Suc (Suc n + m)) \\<in> F\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Suc_eq_plus1 add.commute token_run_P[of \"\\<lambda>q. q \\<in> F\"] token_stays_in_final_states token_succeeds_def)"], ["proof (state)\nthis:\n  token_run x (Suc n + m) \\<notin> F\n  token_run x (Suc (Suc n + m)) \\<in> F\n\ngoal (2 subgoals):\n 1. finite (fst ` (local.merge i \\<inter> S))\n 2. finite (snd ` (local.merge i \\<inter> S))", "moreover"], ["proof (state)\nthis:\n  token_run x (Suc n + m) \\<notin> F\n  token_run x (Suc (Suc n + m)) \\<in> F\n\ngoal (2 subgoals):\n 1. finite (fst ` (local.merge i \\<inter> S))\n 2. finite (snd ` (local.merge i \\<inter> S))", "have \"x \\<le> Suc n\" and \"y \\<le> Suc n\" and \"x \\<le> Suc n + m\" and \"y \\<le> Suc n + m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> Suc n &&& y \\<le> Suc n) &&&\n    x \\<le> Suc n + m &&& y \\<le> Suc n + m", "using rank_Some_time \\<open>rank x n = Some k\\<close> \\<open>rank y n = Some k'' \\<or> y = Suc n\\<close>"], ["proof (prove)\nusing this:\n  rank ?x ?n = Some ?j \\<Longrightarrow> ?x \\<le> ?n\n  rank x n = Some k\n  rank y n = Some k'' \\<or> y = Suc n\n\ngoal (1 subgoal):\n 1. (x \\<le> Suc n &&& y \\<le> Suc n) &&&\n    x \\<le> Suc n + m &&& y \\<le> Suc n + m", "by fastforce+"], ["proof (state)\nthis:\n  x \\<le> Suc n\n  y \\<le> Suc n\n  x \\<le> Suc n + m\n  y \\<le> Suc n + m\n\ngoal (2 subgoals):\n 1. finite (fst ` (local.merge i \\<inter> S))\n 2. finite (snd ` (local.merge i \\<inter> S))", "hence \"token_run y (Suc n + m) \\<notin> F\" and \"token_run y (Suc (Suc n + m)) \\<in> F\""], ["proof (prove)\nusing this:\n  x \\<le> Suc n\n  y \\<le> Suc n\n  x \\<le> Suc n + m\n  y \\<le> Suc n + m\n\ngoal (1 subgoal):\n 1. token_run y (Suc n + m) \\<notin> F &&&\n    token_run y (Suc (Suc n + m)) \\<in> F", "using \\<open>token_run x (Suc n + m) \\<notin> F\\<close> \\<open>token_run x (Suc (Suc n + m)) \\<in> F\\<close> \\<open>token_run x (Suc n) = token_run y (Suc n)\\<close>"], ["proof (prove)\nusing this:\n  x \\<le> Suc n\n  y \\<le> Suc n\n  x \\<le> Suc n + m\n  y \\<le> Suc n + m\n  token_run x (Suc n + m) \\<notin> F\n  token_run x (Suc (Suc n + m)) \\<in> F\n  token_run x (Suc n) = token_run y (Suc n)\n\ngoal (1 subgoal):\n 1. token_run y (Suc n + m) \\<notin> F &&&\n    token_run y (Suc (Suc n + m)) \\<in> F", "using token_run_merge token_run_merge_Suc"], ["proof (prove)\nusing this:\n  x \\<le> Suc n\n  y \\<le> Suc n\n  x \\<le> Suc n + m\n  y \\<le> Suc n + m\n  token_run x (Suc n + m) \\<notin> F\n  token_run x (Suc (Suc n + m)) \\<in> F\n  token_run x (Suc n) = token_run y (Suc n)\n  \\<lbrakk>?x \\<le> ?n; ?y \\<le> ?n;\n   token_run ?x ?n = token_run ?y ?n\\<rbrakk>\n  \\<Longrightarrow> token_run ?x (?n + ?m) = token_run ?y (?n + ?m)\n  \\<lbrakk>?x \\<le> ?n; ?y \\<le> ?n;\n   token_run ?x ?n = token_run ?y ?n\\<rbrakk>\n  \\<Longrightarrow> token_run ?x (Suc ?n) = token_run ?y (Suc ?n)\n\ngoal (1 subgoal):\n 1. token_run y (Suc n + m) \\<notin> F &&&\n    token_run y (Suc (Suc n + m)) \\<in> F", "by metis+"], ["proof (state)\nthis:\n  token_run y (Suc n + m) \\<notin> F\n  token_run y (Suc (Suc n + m)) \\<in> F\n\ngoal (2 subgoals):\n 1. finite (fst ` (local.merge i \\<inter> S))\n 2. finite (snd ` (local.merge i \\<inter> S))", "moreover"], ["proof (state)\nthis:\n  token_run y (Suc n + m) \\<notin> F\n  token_run y (Suc (Suc n + m)) \\<in> F\n\ngoal (2 subgoals):\n 1. finite (fst ` (local.merge i \\<inter> S))\n 2. finite (snd ` (local.merge i \\<inter> S))", "have \"\\<not>sink (token_run x (Suc n + m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> sink (token_run x (Suc n + m))", "using \\<open>token_run x (Suc n + m) \\<notin> F\\<close> \\<open>token_run x (Suc(Suc n + m)) \\<in> F\\<close>"], ["proof (prove)\nusing this:\n  token_run x (Suc n + m) \\<notin> F\n  token_run x (Suc (Suc n + m)) \\<in> F\n\ngoal (1 subgoal):\n 1. \\<not> sink (token_run x (Suc n + m))", "using token_is_not_in_sink"], ["proof (prove)\nusing this:\n  token_run x (Suc n + m) \\<notin> F\n  token_run x (Suc (Suc n + m)) \\<in> F\n  \\<lbrakk>token_run ?x ?n \\<notin> ?A;\n   token_run ?x (Suc ?n) \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> \\<not> sink (token_run ?x ?n)\n\ngoal (1 subgoal):\n 1. \\<not> sink (token_run x (Suc n + m))", "by blast\n\n      \\<comment> \\<open>Obtain rank used to enter final\\<close>"], ["proof (state)\nthis:\n  \\<not> sink (token_run x (Suc n + m))\n\ngoal (2 subgoals):\n 1. finite (fst ` (local.merge i \\<inter> S))\n 2. finite (snd ` (local.merge i \\<inter> S))", "obtain k' where \"rank x (Suc n + m) = Some k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        rank x (Suc n + m) = Some k' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>\\<not>sink (token_run x (Suc n + m))\\<close> \\<open>x \\<le> Suc n + m\\<close>"], ["proof (prove)\nusing this:\n  \\<not> sink (token_run x (Suc n + m))\n  x \\<le> Suc n + m\n\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        rank x (Suc n + m) = Some k' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  rank x (Suc n + m) = Some k'\n\ngoal (2 subgoals):\n 1. finite (fst ` (local.merge i \\<inter> S))\n 2. finite (snd ` (local.merge i \\<inter> S))", "moreover"], ["proof (state)\nthis:\n  rank x (Suc n + m) = Some k'\n\ngoal (2 subgoals):\n 1. finite (fst ` (local.merge i \\<inter> S))\n 2. finite (snd ` (local.merge i \\<inter> S))", "hence \"rank y (Suc n + m) = Some k'\""], ["proof (prove)\nusing this:\n  rank x (Suc n + m) = Some k'\n\ngoal (1 subgoal):\n 1. rank y (Suc n + m) = Some k'", "by (metis \\<open>x \\<le> Suc n + m\\<close> \\<open>y \\<le> Suc n + m\\<close> token_run_merge \\<open>x \\<le> Suc n\\<close> \\<open>y \\<le> Suc n\\<close>\n                  \\<open>token_run x (Suc n) = token_run y (Suc n)\\<close> pull_up_token_run_tokens\n                  pull_up_configuration_rank[of x _ \"Suc n + m\" y])"], ["proof (state)\nthis:\n  rank y (Suc n + m) = Some k'\n\ngoal (2 subgoals):\n 1. finite (fst ` (local.merge i \\<inter> S))\n 2. finite (snd ` (local.merge i \\<inter> S))", "moreover\n\n      \\<comment> \\<open>Rank used to enter final states is strictly bounded by i\\<close>"], ["proof (state)\nthis:\n  rank y (Suc n + m) = Some k'\n\ngoal (2 subgoals):\n 1. finite (fst ` (local.merge i \\<inter> S))\n 2. finite (snd ` (local.merge i \\<inter> S))", "have \"k' < i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k' < i", "using \\<open>rank x (Suc n + m) = Some k'\\<close> rank_monotonic[OF \\<open>rank x n = Some k\\<close>] \\<open>k < i\\<close>"], ["proof (prove)\nusing this:\n  rank x (Suc n + m) = Some k'\n  rank x (n + ?m) = Some ?j \\<Longrightarrow> ?j \\<le> k\n  k < i\n\ngoal (1 subgoal):\n 1. k' < i", "unfolding add_Suc_shift"], ["proof (prove)\nusing this:\n  rank x (n + Suc m) = Some k'\n  rank x (n + ?m) = Some ?j \\<Longrightarrow> ?j \\<le> k\n  k < i\n\ngoal (1 subgoal):\n 1. k' < i", "by fastforce"], ["proof (state)\nthis:\n  k' < i\n\ngoal (2 subgoals):\n 1. finite (fst ` (local.merge i \\<inter> S))\n 2. finite (snd ` (local.merge i \\<inter> S))", "ultimately"], ["proof (chain)\npicking this:\n  token_run x (Suc n + m) \\<notin> F\n  token_run x (Suc (Suc n + m)) \\<in> F\n  token_run y (Suc n + m) \\<notin> F\n  token_run y (Suc (Suc n + m)) \\<in> F\n  rank x (Suc n + m) = Some k'\n  rank y (Suc n + m) = Some k'\n  k' < i", "have \"x \\<in> \\<Union>{succeed j | j. j < i}\" and \"y \\<in> \\<Union>{succeed j | j. j < i}\""], ["proof (prove)\nusing this:\n  token_run x (Suc n + m) \\<notin> F\n  token_run x (Suc (Suc n + m)) \\<in> F\n  token_run y (Suc n + m) \\<notin> F\n  token_run y (Suc (Suc n + m)) \\<in> F\n  rank x (Suc n + m) = Some k'\n  rank y (Suc n + m) = Some k'\n  k' < i\n\ngoal (1 subgoal):\n 1. x \\<in> \\<Union> {succeed j |j. j < i} &&&\n    y \\<in> \\<Union> {succeed j |j. j < i}", "unfolding succeed_def"], ["proof (prove)\nusing this:\n  token_run x (Suc n + m) \\<notin> F\n  token_run x (Suc (Suc n + m)) \\<in> F\n  token_run y (Suc n + m) \\<notin> F\n  token_run y (Suc (Suc n + m)) \\<in> F\n  rank x (Suc n + m) = Some k'\n  rank y (Suc n + m) = Some k'\n  k' < i\n\ngoal (1 subgoal):\n 1. x \\<in> \\<Union>\n             {{x. \\<exists>n.\n                     rank x n = Some j \\<and>\n                     token_run x n \\<notin> F - {q\\<^sub>0} \\<and>\n                     token_run x (Suc n) \\<in> F} |\n              j. j < i} &&&\n    y \\<in> \\<Union>\n             {{x. \\<exists>n.\n                     rank x n = Some j \\<and>\n                     token_run x n \\<notin> F - {q\\<^sub>0} \\<and>\n                     token_run x (Suc n) \\<in> F} |\n              j. j < i}", "by blast+"], ["proof (state)\nthis:\n  x \\<in> \\<Union> {succeed j |j. j < i}\n  y \\<in> \\<Union> {succeed j |j. j < i}\n\ngoal (2 subgoals):\n 1. finite (fst ` (local.merge i \\<inter> S))\n 2. finite (snd ` (local.merge i \\<inter> S))", "}"], ["proof (state)\nthis:\n  (?x2, ?y2) \\<in> local.merge i \\<inter> S \\<Longrightarrow>\n  ?x2 \\<in> \\<Union> {succeed j |j. j < i}\n  (?x2, ?y2) \\<in> local.merge i \\<inter> S \\<Longrightarrow>\n  ?y2 \\<in> \\<Union> {succeed j |j. j < i}\n\ngoal (2 subgoals):\n 1. finite (fst ` (local.merge i \\<inter> S))\n 2. finite (snd ` (local.merge i \\<inter> S))", "hence \"fst ` (merge i \\<inter> S) \\<subseteq> \\<Union>{succeed j | j. j < i}\" and \"snd ` (merge i \\<inter> S) \\<subseteq> \\<Union>{succeed j | j. j < i}\""], ["proof (prove)\nusing this:\n  (?x2, ?y2) \\<in> local.merge i \\<inter> S \\<Longrightarrow>\n  ?x2 \\<in> \\<Union> {succeed j |j. j < i}\n  (?x2, ?y2) \\<in> local.merge i \\<inter> S \\<Longrightarrow>\n  ?y2 \\<in> \\<Union> {succeed j |j. j < i}\n\ngoal (1 subgoal):\n 1. fst ` (local.merge i \\<inter> S)\n    \\<subseteq> \\<Union> {succeed j |j. j < i} &&&\n    snd ` (local.merge i \\<inter> S)\n    \\<subseteq> \\<Union> {succeed j |j. j < i}", "by force+"], ["proof (state)\nthis:\n  fst ` (local.merge i \\<inter> S)\n  \\<subseteq> \\<Union> {succeed j |j. j < i}\n  snd ` (local.merge i \\<inter> S)\n  \\<subseteq> \\<Union> {succeed j |j. j < i}\n\ngoal (2 subgoals):\n 1. finite (fst ` (local.merge i \\<inter> S))\n 2. finite (snd ` (local.merge i \\<inter> S))", "thus \"finite (fst ` (merge i \\<inter> S))\" and \"finite (snd ` (merge i \\<inter> S))\""], ["proof (prove)\nusing this:\n  fst ` (local.merge i \\<inter> S)\n  \\<subseteq> \\<Union> {succeed j |j. j < i}\n  snd ` (local.merge i \\<inter> S)\n  \\<subseteq> \\<Union> {succeed j |j. j < i}\n\ngoal (1 subgoal):\n 1. finite (fst ` (local.merge i \\<inter> S)) &&&\n    finite (snd ` (local.merge i \\<inter> S))", "using finite_subset[OF _ fin_succeed_ranks]"], ["proof (prove)\nusing this:\n  fst ` (local.merge i \\<inter> S)\n  \\<subseteq> \\<Union> {succeed j |j. j < i}\n  snd ` (local.merge i \\<inter> S)\n  \\<subseteq> \\<Union> {succeed j |j. j < i}\n  ?A \\<subseteq> \\<Union> {succeed j |j. j < i} \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. finite (fst ` (local.merge i \\<inter> S)) &&&\n    finite (snd ` (local.merge i \\<inter> S))", "by meson+"], ["proof (state)\nthis:\n  finite (fst ` (local.merge i \\<inter> S))\n  finite (snd ` (local.merge i \\<inter> S))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite (local.merge i \\<inter> S)\n\ngoal (1 subgoal):\n 1. finite fail \\<and>\n    finite (local.merge (LEAST k. infinite (succeed k))) \\<and>\n    infinite (succeed (LEAST k. infinite (succeed k))) \\<and>\n    (\\<forall>j<LEAST k. infinite (succeed k). finite (succeed j))", "moreover"], ["proof (state)\nthis:\n  finite (local.merge i \\<inter> S)\n\ngoal (1 subgoal):\n 1. finite fail \\<and>\n    finite (local.merge (LEAST k. infinite (succeed k))) \\<and>\n    infinite (succeed (LEAST k. infinite (succeed k))) \\<and>\n    (\\<forall>j<LEAST k. infinite (succeed k). finite (succeed j))", "have \"finite (merge i \\<inter> (UNIV - S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (local.merge i \\<inter> (UNIV - S))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (local.merge i \\<inter> (UNIV - S))", "obtain l where l_def: \"\\<forall>x \\<ge> l. token_succeeds x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<forall>x\\<ge>l. token_succeeds x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  accept\\<^sub>M\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<forall>x\\<ge>l. token_succeeds x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding accept_def MOST_nat_le"], ["proof (prove)\nusing this:\n  \\<exists>m. \\<forall>n\\<ge>m. token_succeeds n\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<forall>x\\<ge>l. token_succeeds x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<ge>l. token_succeeds x\n\ngoal (1 subgoal):\n 1. finite (local.merge i \\<inter> (UNIV - S))", "{"], ["proof (state)\nthis:\n  \\<forall>x\\<ge>l. token_succeeds x\n\ngoal (1 subgoal):\n 1. finite (local.merge i \\<inter> (UNIV - S))", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (local.merge i \\<inter> (UNIV - S))", "assume \"(x, y) \\<in> merge i \\<inter> (UNIV - S)\""], ["proof (state)\nthis:\n  (x, y) \\<in> local.merge i \\<inter> (UNIV - S)\n\ngoal (1 subgoal):\n 1. finite (local.merge i \\<inter> (UNIV - S))", "hence \"\\<not>token_succeeds x \\<or> \\<not>token_succeeds y\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> local.merge i \\<inter> (UNIV - S)\n\ngoal (1 subgoal):\n 1. \\<not> token_succeeds x \\<or> \\<not> token_succeeds y", "unfolding S_def"], ["proof (prove)\nusing this:\n  (x, y)\n  \\<in> local.merge i \\<inter>\n        (UNIV - {(x, y). token_succeeds x \\<and> token_succeeds y})\n\ngoal (1 subgoal):\n 1. \\<not> token_succeeds x \\<or> \\<not> token_succeeds y", "by simp"], ["proof (state)\nthis:\n  \\<not> token_succeeds x \\<or> \\<not> token_succeeds y\n\ngoal (1 subgoal):\n 1. finite (local.merge i \\<inter> (UNIV - S))", "hence \"\\<not>token_succeeds x \\<and> \\<not>token_succeeds y\""], ["proof (prove)\nusing this:\n  \\<not> token_succeeds x \\<or> \\<not> token_succeeds y\n\ngoal (1 subgoal):\n 1. \\<not> token_succeeds x \\<and> \\<not> token_succeeds y", "using merge_token_succeeds \\<open>(x, y) \\<in> merge i \\<inter> (UNIV - S)\\<close>"], ["proof (prove)\nusing this:\n  \\<not> token_succeeds x \\<or> \\<not> token_succeeds y\n  (?x, ?y) \\<in> local.merge ?i \\<Longrightarrow>\n  token_succeeds ?x = token_succeeds ?y\n  (x, y) \\<in> local.merge i \\<inter> (UNIV - S)\n\ngoal (1 subgoal):\n 1. \\<not> token_succeeds x \\<and> \\<not> token_succeeds y", "by blast"], ["proof (state)\nthis:\n  \\<not> token_succeeds x \\<and> \\<not> token_succeeds y\n\ngoal (1 subgoal):\n 1. finite (local.merge i \\<inter> (UNIV - S))", "hence \"x < l\" and \"y < l\""], ["proof (prove)\nusing this:\n  \\<not> token_succeeds x \\<and> \\<not> token_succeeds y\n\ngoal (1 subgoal):\n 1. x < l &&& y < l", "by (metis l_def le_eq_less_or_eq linear)+"], ["proof (state)\nthis:\n  x < l\n  y < l\n\ngoal (1 subgoal):\n 1. finite (local.merge i \\<inter> (UNIV - S))", "}"], ["proof (state)\nthis:\n  (?x2, ?y2) \\<in> local.merge i \\<inter> (UNIV - S) \\<Longrightarrow>\n  ?x2 < l\n  (?x2, ?y2) \\<in> local.merge i \\<inter> (UNIV - S) \\<Longrightarrow>\n  ?y2 < l\n\ngoal (1 subgoal):\n 1. finite (local.merge i \\<inter> (UNIV - S))", "hence \"merge i \\<inter> (UNIV - S) \\<subseteq> {0..l} \\<times> {0..l}\""], ["proof (prove)\nusing this:\n  (?x2, ?y2) \\<in> local.merge i \\<inter> (UNIV - S) \\<Longrightarrow>\n  ?x2 < l\n  (?x2, ?y2) \\<in> local.merge i \\<inter> (UNIV - S) \\<Longrightarrow>\n  ?y2 < l\n\ngoal (1 subgoal):\n 1. local.merge i \\<inter> (UNIV - S) \\<subseteq> {0..l} \\<times> {0..l}", "by fastforce"], ["proof (state)\nthis:\n  local.merge i \\<inter> (UNIV - S) \\<subseteq> {0..l} \\<times> {0..l}\n\ngoal (1 subgoal):\n 1. finite (local.merge i \\<inter> (UNIV - S))", "thus ?thesis"], ["proof (prove)\nusing this:\n  local.merge i \\<inter> (UNIV - S) \\<subseteq> {0..l} \\<times> {0..l}\n\ngoal (1 subgoal):\n 1. finite (local.merge i \\<inter> (UNIV - S))", "using finite_subset"], ["proof (prove)\nusing this:\n  local.merge i \\<inter> (UNIV - S) \\<subseteq> {0..l} \\<times> {0..l}\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. finite (local.merge i \\<inter> (UNIV - S))", "by blast"], ["proof (state)\nthis:\n  finite (local.merge i \\<inter> (UNIV - S))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite (local.merge i \\<inter> (UNIV - S))\n\ngoal (1 subgoal):\n 1. finite fail \\<and>\n    finite (local.merge (LEAST k. infinite (succeed k))) \\<and>\n    infinite (succeed (LEAST k. infinite (succeed k))) \\<and>\n    (\\<forall>j<LEAST k. infinite (succeed k). finite (succeed j))", "ultimately"], ["proof (chain)\npicking this:\n  finite (local.merge i \\<inter> S)\n  finite (local.merge i \\<inter> (UNIV - S))", "have \"finite (merge i)\""], ["proof (prove)\nusing this:\n  finite (local.merge i \\<inter> S)\n  finite (local.merge i \\<inter> (UNIV - S))\n\ngoal (1 subgoal):\n 1. finite (local.merge i)", "by (metis Int_Diff Un_Diff_Int finite_UnI inf_top_right)"], ["proof (state)\nthis:\n  finite (local.merge i)\n\ngoal (1 subgoal):\n 1. finite fail \\<and>\n    finite (local.merge (LEAST k. infinite (succeed k))) \\<and>\n    infinite (succeed (LEAST k. infinite (succeed k))) \\<and>\n    (\\<forall>j<LEAST k. infinite (succeed k). finite (succeed j))", "moreover"], ["proof (state)\nthis:\n  finite (local.merge i)\n\ngoal (1 subgoal):\n 1. finite fail \\<and>\n    finite (local.merge (LEAST k. infinite (succeed k))) \\<and>\n    infinite (succeed (LEAST k. infinite (succeed k))) \\<and>\n    (\\<forall>j<LEAST k. infinite (succeed k). finite (succeed j))", "have \"finite fail\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite fail", "by (metis assms mojmir_accept_alt_def fail_def token_fails_alt_def_2 infinite_nat_iff_unbounded_le mem_Collect_eq)"], ["proof (state)\nthis:\n  finite fail\n\ngoal (1 subgoal):\n 1. finite fail \\<and>\n    finite (local.merge (LEAST k. infinite (succeed k))) \\<and>\n    infinite (succeed (LEAST k. infinite (succeed k))) \\<and>\n    (\\<forall>j<LEAST k. infinite (succeed k). finite (succeed j))", "ultimately"], ["proof (chain)\npicking this:\n  finite (local.merge i)\n  finite fail", "show \"finite fail \\<and> finite (merge i) \\<and> infinite (succeed i) \\<and> (\\<forall>j < i. finite (succeed j))\""], ["proof (prove)\nusing this:\n  finite (local.merge i)\n  finite fail\n\ngoal (1 subgoal):\n 1. finite fail \\<and>\n    finite (local.merge i) \\<and>\n    infinite (succeed i) \\<and> (\\<forall>j<i. finite (succeed j))", "using \\<open>infinite (succeed i)\\<close> \\<open>\\<And>j. j < i \\<Longrightarrow> finite (succeed j)\\<close>"], ["proof (prove)\nusing this:\n  finite (local.merge i)\n  finite fail\n  infinite (succeed i)\n  ?j < i \\<Longrightarrow> finite (succeed ?j)\n\ngoal (1 subgoal):\n 1. finite fail \\<and>\n    finite (local.merge i) \\<and>\n    infinite (succeed i) \\<and> (\\<forall>j<i. finite (succeed j))", "by blast"], ["proof (state)\nthis:\n  finite fail \\<and>\n  finite (local.merge i) \\<and>\n  infinite (succeed i) \\<and> (\\<forall>j<i. finite (succeed j))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mojmir_accept_token_set_def2:\n  assumes \"finite fail\"\n      and \"finite (merge i)\"\n      and \"infinite (succeed i)\"\n  shows \"accept\""], ["proof (prove)\ngoal (1 subgoal):\n 1. accept\\<^sub>M", "proof (rule ccontr, cases \"q\\<^sub>0 \\<notin> F\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> accept\\<^sub>M; q\\<^sub>0 \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>\\<not> accept\\<^sub>M; \\<not> q\\<^sub>0 \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  q\\<^sub>0 \\<notin> F\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> accept\\<^sub>M; q\\<^sub>0 \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>\\<not> accept\\<^sub>M; \\<not> q\\<^sub>0 \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"\\<not> accept\""], ["proof (state)\nthis:\n  \\<not> accept\\<^sub>M\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> accept\\<^sub>M; q\\<^sub>0 \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>\\<not> accept\\<^sub>M; \\<not> q\\<^sub>0 \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<not> accept\\<^sub>M\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> accept\\<^sub>M; q\\<^sub>0 \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>\\<not> accept\\<^sub>M; \\<not> q\\<^sub>0 \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> False", "have \"finite {x. \\<not>token_succeeds x \\<and> \\<not>token_squats x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. \\<not> token_succeeds x \\<and> \\<not> token_squats x}", "using \\<open>finite fail\\<close>"], ["proof (prove)\nusing this:\n  finite fail\n\ngoal (1 subgoal):\n 1. finite {x. \\<not> token_succeeds x \\<and> \\<not> token_squats x}", "unfolding fail_def token_fails_alt_def_2[symmetric]"], ["proof (prove)\nusing this:\n  finite (Collect token_fails)\n\ngoal (1 subgoal):\n 1. finite (Collect token_fails)", "."], ["proof (state)\nthis:\n  finite {x. \\<not> token_succeeds x \\<and> \\<not> token_squats x}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> accept\\<^sub>M; q\\<^sub>0 \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>\\<not> accept\\<^sub>M; \\<not> q\\<^sub>0 \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  finite {x. \\<not> token_succeeds x \\<and> \\<not> token_squats x}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> accept\\<^sub>M; q\\<^sub>0 \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>\\<not> accept\\<^sub>M; \\<not> q\\<^sub>0 \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> False", "have X: \"{x. \\<not> token_succeeds x} = {x. \\<not> token_succeeds x \\<and> token_squats x} \\<union> {x. \\<not> token_succeeds x \\<and> \\<not> token_squats x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. \\<not> token_succeeds x} =\n    {x. \\<not> token_succeeds x \\<and> token_squats x} \\<union>\n    {x. \\<not> token_succeeds x \\<and> \\<not> token_squats x}", "by blast"], ["proof (state)\nthis:\n  {x. \\<not> token_succeeds x} =\n  {x. \\<not> token_succeeds x \\<and> token_squats x} \\<union>\n  {x. \\<not> token_succeeds x \\<and> \\<not> token_squats x}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> accept\\<^sub>M; q\\<^sub>0 \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>\\<not> accept\\<^sub>M; \\<not> q\\<^sub>0 \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> accept\\<^sub>M\n  finite {x. \\<not> token_succeeds x \\<and> \\<not> token_squats x}\n  {x. \\<not> token_succeeds x} =\n  {x. \\<not> token_succeeds x \\<and> token_squats x} \\<union>\n  {x. \\<not> token_succeeds x \\<and> \\<not> token_squats x}", "have inf: \"infinite {x. \\<not>token_succeeds x \\<and> token_squats x}\""], ["proof (prove)\nusing this:\n  \\<not> accept\\<^sub>M\n  finite {x. \\<not> token_succeeds x \\<and> \\<not> token_squats x}\n  {x. \\<not> token_succeeds x} =\n  {x. \\<not> token_succeeds x \\<and> token_squats x} \\<union>\n  {x. \\<not> token_succeeds x \\<and> \\<not> token_squats x}\n\ngoal (1 subgoal):\n 1. infinite {x. \\<not> token_succeeds x \\<and> token_squats x}", "unfolding mojmir_accept_alt_def X"], ["proof (prove)\nusing this:\n  infinite\n   ({x. \\<not> token_succeeds x \\<and> token_squats x} \\<union>\n    {x. \\<not> token_succeeds x \\<and> \\<not> token_squats x})\n  finite {x. \\<not> token_succeeds x \\<and> \\<not> token_squats x}\n  {x. \\<not> token_succeeds x \\<and> token_squats x} \\<union>\n  {x. \\<not> token_succeeds x \\<and> \\<not> token_squats x} =\n  {x. \\<not> token_succeeds x \\<and> token_squats x} \\<union>\n  {x. \\<not> token_succeeds x \\<and> \\<not> token_squats x}\n\ngoal (1 subgoal):\n 1. infinite {x. \\<not> token_succeeds x \\<and> token_squats x}", "by blast\n\n    \\<comment> \\<open>Obtain j, where j is the rank used by infinitely many configuration stabilising and not succeeding\\<close>"], ["proof (state)\nthis:\n  infinite {x. \\<not> token_succeeds x \\<and> token_squats x}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> accept\\<^sub>M; q\\<^sub>0 \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>\\<not> accept\\<^sub>M; \\<not> q\\<^sub>0 \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> False", "have \"{x. \\<not>token_succeeds x \\<and> token_squats x} = {x. \\<exists>j < i. \\<not>token_succeeds x \\<and> token_squats x \\<and> stable_rank x j}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. \\<not> token_succeeds x \\<and> token_squats x} =\n    {x. \\<exists>j<i.\n           \\<not> token_succeeds x \\<and>\n           token_squats x \\<and> stable_rank x j}", "using stable_rank_bounded \\<open>infinite (succeed i)\\<close> \\<open>q\\<^sub>0 \\<notin> F\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>stable_rank ?x ?j; infinite (succeed ?i);\n   q\\<^sub>0 \\<notin> F\\<rbrakk>\n  \\<Longrightarrow> ?j < ?i\n  infinite (succeed i)\n  q\\<^sub>0 \\<notin> F\n\ngoal (1 subgoal):\n 1. {x. \\<not> token_succeeds x \\<and> token_squats x} =\n    {x. \\<exists>j<i.\n           \\<not> token_succeeds x \\<and>\n           token_squats x \\<and> stable_rank x j}", "unfolding stable_rank_equiv_token_squats"], ["proof (prove)\nusing this:\n  \\<lbrakk>stable_rank ?x ?j; infinite (succeed ?i);\n   q\\<^sub>0 \\<notin> F\\<rbrakk>\n  \\<Longrightarrow> ?j < ?i\n  infinite (succeed i)\n  q\\<^sub>0 \\<notin> F\n\ngoal (1 subgoal):\n 1. {x. \\<not> token_succeeds x \\<and> Ex (stable_rank x)} =\n    {x. \\<exists>j<i.\n           \\<not> token_succeeds x \\<and>\n           Ex (stable_rank x) \\<and> stable_rank x j}", "by metis"], ["proof (state)\nthis:\n  {x. \\<not> token_succeeds x \\<and> token_squats x} =\n  {x. \\<exists>j<i.\n         \\<not> token_succeeds x \\<and>\n         token_squats x \\<and> stable_rank x j}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> accept\\<^sub>M; q\\<^sub>0 \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>\\<not> accept\\<^sub>M; \\<not> q\\<^sub>0 \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  {x. \\<not> token_succeeds x \\<and> token_squats x} =\n  {x. \\<exists>j<i.\n         \\<not> token_succeeds x \\<and>\n         token_squats x \\<and> stable_rank x j}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> accept\\<^sub>M; q\\<^sub>0 \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>\\<not> accept\\<^sub>M; \\<not> q\\<^sub>0 \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> False", "have \"\\<dots> = \\<Union>{{x.  \\<not>token_succeeds x \\<and> token_squats x \\<and> stable_rank x j} | j. j < i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. \\<exists>j<i.\n           \\<not> token_succeeds x \\<and>\n           token_squats x \\<and> stable_rank x j} =\n    \\<Union>\n     {{x. \\<not> token_succeeds x \\<and>\n          token_squats x \\<and> stable_rank x j} |\n      j. j < i}", "by blast"], ["proof (state)\nthis:\n  {x. \\<exists>j<i.\n         \\<not> token_succeeds x \\<and>\n         token_squats x \\<and> stable_rank x j} =\n  \\<Union>\n   {{x. \\<not> token_succeeds x \\<and>\n        token_squats x \\<and> stable_rank x j} |\n    j. j < i}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> accept\\<^sub>M; q\\<^sub>0 \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>\\<not> accept\\<^sub>M; \\<not> q\\<^sub>0 \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  {x. \\<not> token_succeeds x \\<and> token_squats x} =\n  \\<Union>\n   {{x. \\<not> token_succeeds x \\<and>\n        token_squats x \\<and> stable_rank x j} |\n    j. j < i}", "obtain j where \"j < i\" and \"infinite {t. \\<not>token_succeeds t \\<and> token_squats t \\<and> stable_rank t j}\"\n      (is \"infinite ?S\")"], ["proof (prove)\nusing this:\n  {x. \\<not> token_succeeds x \\<and> token_squats x} =\n  \\<Union>\n   {{x. \\<not> token_succeeds x \\<and>\n        token_squats x \\<and> stable_rank x j} |\n    j. j < i}\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>j < i;\n         infinite\n          {t. \\<not> token_succeeds t \\<and>\n              token_squats t \\<and> stable_rank t j}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using inf"], ["proof (prove)\nusing this:\n  {x. \\<not> token_succeeds x \\<and> token_squats x} =\n  \\<Union>\n   {{x. \\<not> token_succeeds x \\<and>\n        token_squats x \\<and> stable_rank x j} |\n    j. j < i}\n  infinite {x. \\<not> token_succeeds x \\<and> token_squats x}\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>j < i;\n         infinite\n          {t. \\<not> token_succeeds t \\<and>\n              token_squats t \\<and> stable_rank t j}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force\n\n    \\<comment> \\<open>Obtain such a token x\\<close>"], ["proof (state)\nthis:\n  j < i\n  infinite\n   {t. \\<not> token_succeeds t \\<and> token_squats t \\<and> stable_rank t j}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> accept\\<^sub>M; q\\<^sub>0 \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>\\<not> accept\\<^sub>M; \\<not> q\\<^sub>0 \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  j < i\n  infinite\n   {t. \\<not> token_succeeds t \\<and> token_squats t \\<and> stable_rank t j}", "obtain x where \"\\<not>token_succeeds x\" and \"token_squats x\" and \"stable_rank x j\""], ["proof (prove)\nusing this:\n  j < i\n  infinite\n   {t. \\<not> token_succeeds t \\<and> token_squats t \\<and> stable_rank t j}\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>\\<not> token_succeeds x; token_squats x;\n         stable_rank x j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding infinite_nat_iff_unbounded_le"], ["proof (prove)\nusing this:\n  j < i\n  \\<forall>m.\n     \\<exists>n\\<ge>m.\n        n \\<in> {t. \\<not> token_succeeds t \\<and>\n                    token_squats t \\<and> stable_rank t j}\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>\\<not> token_succeeds x; token_squats x;\n         stable_rank x j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<not> token_succeeds x\n  token_squats x\n  stable_rank x j\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> accept\\<^sub>M; q\\<^sub>0 \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>\\<not> accept\\<^sub>M; \\<not> q\\<^sub>0 \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> token_succeeds x\n  token_squats x\n  stable_rank x j", "obtain n where \"\\<forall>m \\<ge> n. rank x m = Some j\""], ["proof (prove)\nusing this:\n  \\<not> token_succeeds x\n  token_squats x\n  stable_rank x j\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<forall>m\\<ge>n. rank x m = Some j \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding stable_rank_def MOST_nat_le"], ["proof (prove)\nusing this:\n  \\<not> token_succeeds x\n  token_squats x\n  \\<exists>m. \\<forall>n\\<ge>m. rank x n = Some j\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<forall>m\\<ge>n. rank x m = Some j \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast\n\n    \\<comment> \\<open>All configuration with same stable rank are bought at some n with rank smaller i\\<close>"], ["proof (state)\nthis:\n  \\<forall>m\\<ge>n. rank x m = Some j\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> accept\\<^sub>M; q\\<^sub>0 \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>\\<not> accept\\<^sub>M; \\<not> q\\<^sub>0 \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> False", "have \"{(x, y) | y. y > n \\<and> stable_rank y j} \\<subseteq> merge i\"\n      (is \"?lhs \\<subseteq> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y) |y. n < y \\<and> stable_rank y j} \\<subseteq> local.merge i", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {(x, y) |y. n < y \\<and> stable_rank y j} \\<Longrightarrow>\n       xa \\<in> local.merge i", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {(x, y) |y. n < y \\<and> stable_rank y j} \\<Longrightarrow>\n       xa \\<in> local.merge i", "assume \"p \\<in> ?lhs\""], ["proof (state)\nthis:\n  p \\<in> {(x, y) |y. n < y \\<and> stable_rank y j}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {(x, y) |y. n < y \\<and> stable_rank y j} \\<Longrightarrow>\n       xa \\<in> local.merge i", "then"], ["proof (chain)\npicking this:\n  p \\<in> {(x, y) |y. n < y \\<and> stable_rank y j}", "obtain y where \"p = (x, y)\" and \"y > n\" and \"stable_rank y j\""], ["proof (prove)\nusing this:\n  p \\<in> {(x, y) |y. n < y \\<and> stable_rank y j}\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>p = (x, y); n < y; stable_rank y j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  p = (x, y)\n  n < y\n  stable_rank y j\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {(x, y) |y. n < y \\<and> stable_rank y j} \\<Longrightarrow>\n       xa \\<in> local.merge i", "hence \"x < y\" and \"x \\<noteq> y\""], ["proof (prove)\nusing this:\n  p = (x, y)\n  n < y\n  stable_rank y j\n\ngoal (1 subgoal):\n 1. x < y &&& x \\<noteq> y", "using rank_Some_time \\<open>\\<forall>n'\\<ge>n. rank x n' = Some j\\<close>"], ["proof (prove)\nusing this:\n  p = (x, y)\n  n < y\n  stable_rank y j\n  rank ?x ?n = Some ?j \\<Longrightarrow> ?x \\<le> ?n\n  \\<forall>n'\\<ge>n. rank x n' = Some j\n\ngoal (1 subgoal):\n 1. x < y &&& x \\<noteq> y", "by fastforce+"], ["proof (state)\nthis:\n  x < y\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {(x, y) |y. n < y \\<and> stable_rank y j} \\<Longrightarrow>\n       xa \\<in> local.merge i", "moreover\n\n      \\<comment> \\<open>Obtain a time n'' where x and y have the same rank\\<close>"], ["proof (state)\nthis:\n  x < y\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {(x, y) |y. n < y \\<and> stable_rank y j} \\<Longrightarrow>\n       xa \\<in> local.merge i", "obtain n'' where \"rank x n'' = Some j\" and \"rank y n'' = Some j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n''.\n        \\<lbrakk>rank x n'' = Some j; rank y n'' = Some j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>\\<forall>n'\\<ge>n. rank x n' = Some j\\<close> \\<open>stable_rank y j\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>n'\\<ge>n. rank x n' = Some j\n  stable_rank y j\n\ngoal (1 subgoal):\n 1. (\\<And>n''.\n        \\<lbrakk>rank x n'' = Some j; rank y n'' = Some j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding stable_rank_def MOST_nat_le"], ["proof (prove)\nusing this:\n  \\<forall>n'\\<ge>n. rank x n' = Some j\n  \\<exists>m. \\<forall>n\\<ge>m. rank y n = Some j\n\ngoal (1 subgoal):\n 1. (\\<And>n''.\n        \\<lbrakk>rank x n'' = Some j; rank y n'' = Some j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis add.commute le_add2)"], ["proof (state)\nthis:\n  rank x n'' = Some j\n  rank y n'' = Some j\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {(x, y) |y. n < y \\<and> stable_rank y j} \\<Longrightarrow>\n       xa \\<in> local.merge i", "hence \"token_run x n'' = token_run y n''\" and \"y \\<le> n''\""], ["proof (prove)\nusing this:\n  rank x n'' = Some j\n  rank y n'' = Some j\n\ngoal (1 subgoal):\n 1. token_run x n'' = token_run y n'' &&& y \\<le> n''", "using push_down_rank_tokens rank_Some_time[OF \\<open>rank y n'' = Some j\\<close>]"], ["proof (prove)\nusing this:\n  rank x n'' = Some j\n  rank y n'' = Some j\n  \\<lbrakk>rank ?x ?n = rank ?y ?n; rank ?x ?n = Some ?i\\<rbrakk>\n  \\<Longrightarrow> \\<exists>q.\n                       ?x \\<in> configuration q ?n \\<and>\n                       ?y \\<in> configuration q ?n\n  y \\<le> n''\n\ngoal (1 subgoal):\n 1. token_run x n'' = token_run y n'' &&& y \\<le> n''", "by simp_all\n\n      \\<comment> \\<open>Obtain the time n' where x merges y and proof all necessary properties\\<close>"], ["proof (state)\nthis:\n  token_run x n'' = token_run y n''\n  y \\<le> n''\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {(x, y) |y. n < y \\<and> stable_rank y j} \\<Longrightarrow>\n       xa \\<in> local.merge i", "then"], ["proof (chain)\npicking this:\n  token_run x n'' = token_run y n''\n  y \\<le> n''", "obtain n' where \"token_run x n' \\<noteq> token_run y n' \\<or> y = Suc n'\"\n        and \"token_run x (Suc n') = token_run y (Suc n')\" and \"y \\<le> Suc n'\""], ["proof (prove)\nusing this:\n  token_run x n'' = token_run y n''\n  y \\<le> n''\n\ngoal (1 subgoal):\n 1. (\\<And>n'.\n        \\<lbrakk>token_run x n' \\<noteq> token_run y n' \\<or> y = Suc n';\n         token_run x (Suc n') = token_run y (Suc n');\n         y \\<le> Suc n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using token_run_mergepoint[OF \\<open>x < y\\<close>] le_add_diff_inverse"], ["proof (prove)\nusing this:\n  token_run x n'' = token_run y n''\n  y \\<le> n''\n  \\<lbrakk>token_run x (y + ?n) = token_run y (y + ?n);\n   \\<And>m.\n      \\<lbrakk>x \\<le> Suc m; y \\<le> Suc m;\n       y = Suc m \\<or> token_run x m \\<noteq> token_run y m;\n       token_run x (Suc m) = token_run y (Suc m)\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  ?b \\<le> ?a \\<Longrightarrow> ?b + (?a - ?b) = ?a\n\ngoal (1 subgoal):\n 1. (\\<And>n'.\n        \\<lbrakk>token_run x n' \\<noteq> token_run y n' \\<or> y = Suc n';\n         token_run x (Suc n') = token_run y (Suc n');\n         y \\<le> Suc n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  token_run x n' \\<noteq> token_run y n' \\<or> y = Suc n'\n  token_run x (Suc n') = token_run y (Suc n')\n  y \\<le> Suc n'\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {(x, y) |y. n < y \\<and> stable_rank y j} \\<Longrightarrow>\n       xa \\<in> local.merge i", "moreover"], ["proof (state)\nthis:\n  token_run x n' \\<noteq> token_run y n' \\<or> y = Suc n'\n  token_run x (Suc n') = token_run y (Suc n')\n  y \\<le> Suc n'\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {(x, y) |y. n < y \\<and> stable_rank y j} \\<Longrightarrow>\n       xa \\<in> local.merge i", "hence \"(\\<exists>j'. rank y n' = Some j') \\<or> y = Suc n'\""], ["proof (prove)\nusing this:\n  token_run x n' \\<noteq> token_run y n' \\<or> y = Suc n'\n  token_run x (Suc n') = token_run y (Suc n')\n  y \\<le> Suc n'\n\ngoal (1 subgoal):\n 1. (\\<exists>j'. rank y n' = Some j') \\<or> y = Suc n'", "using \\<open>stable_rank y j\\<close> stable_rank_equiv_token_squats rank_token_squats"], ["proof (prove)\nusing this:\n  token_run x n' \\<noteq> token_run y n' \\<or> y = Suc n'\n  token_run x (Suc n') = token_run y (Suc n')\n  y \\<le> Suc n'\n  stable_rank y j\n  token_squats ?x = (\\<exists>i. stable_rank ?x i)\n  \\<lbrakk>token_squats ?x; ?x \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i. rank ?x ?n = Some i\n\ngoal (1 subgoal):\n 1. (\\<exists>j'. rank y n' = Some j') \\<or> y = Suc n'", "unfolding le_Suc_eq"], ["proof (prove)\nusing this:\n  token_run x n' \\<noteq> token_run y n' \\<or> y = Suc n'\n  token_run x (Suc n') = token_run y (Suc n')\n  y \\<le> n' \\<or> y = Suc n'\n  stable_rank y j\n  token_squats ?x = (\\<exists>i. stable_rank ?x i)\n  \\<lbrakk>token_squats ?x; ?x \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i. rank ?x ?n = Some i\n\ngoal (1 subgoal):\n 1. (\\<exists>j'. rank y n' = Some j') \\<or> y = Suc n'", "by blast"], ["proof (state)\nthis:\n  (\\<exists>j'. rank y n' = Some j') \\<or> y = Suc n'\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {(x, y) |y. n < y \\<and> stable_rank y j} \\<Longrightarrow>\n       xa \\<in> local.merge i", "moreover"], ["proof (state)\nthis:\n  (\\<exists>j'. rank y n' = Some j') \\<or> y = Suc n'\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {(x, y) |y. n < y \\<and> stable_rank y j} \\<Longrightarrow>\n       xa \\<in> local.merge i", "have \"rank x n' = Some j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank x n' = Some j", "using \\<open>\\<forall>n'\\<ge>n. rank x n' = Some j\\<close> \\<open>y \\<le> Suc n'\\<close> \\<open>y > n\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>n'\\<ge>n. rank x n' = Some j\n  y \\<le> Suc n'\n  n < y\n\ngoal (1 subgoal):\n 1. rank x n' = Some j", "by fastforce"], ["proof (state)\nthis:\n  rank x n' = Some j\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {(x, y) |y. n < y \\<and> stable_rank y j} \\<Longrightarrow>\n       xa \\<in> local.merge i", "moreover"], ["proof (state)\nthis:\n  rank x n' = Some j\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {(x, y) |y. n < y \\<and> stable_rank y j} \\<Longrightarrow>\n       xa \\<in> local.merge i", "have \"token_run x (Suc n') \\<notin> F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. token_run x (Suc n') \\<notin> F", "using \\<open>\\<not> token_succeeds x\\<close> token_succeeds_def"], ["proof (prove)\nusing this:\n  \\<not> token_succeeds x\n  token_succeeds ?x = (\\<exists>n. token_run ?x n \\<in> F)\n\ngoal (1 subgoal):\n 1. token_run x (Suc n') \\<notin> F", "by blast"], ["proof (state)\nthis:\n  token_run x (Suc n') \\<notin> F\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {(x, y) |y. n < y \\<and> stable_rank y j} \\<Longrightarrow>\n       xa \\<in> local.merge i", "ultimately"], ["proof (chain)\npicking this:\n  x < y\n  x \\<noteq> y\n  token_run x n' \\<noteq> token_run y n' \\<or> y = Suc n'\n  token_run x (Suc n') = token_run y (Suc n')\n  y \\<le> Suc n'\n  (\\<exists>j'. rank y n' = Some j') \\<or> y = Suc n'\n  rank x n' = Some j\n  token_run x (Suc n') \\<notin> F", "show \"p \\<in> ?rhs\""], ["proof (prove)\nusing this:\n  x < y\n  x \\<noteq> y\n  token_run x n' \\<noteq> token_run y n' \\<or> y = Suc n'\n  token_run x (Suc n') = token_run y (Suc n')\n  y \\<le> Suc n'\n  (\\<exists>j'. rank y n' = Some j') \\<or> y = Suc n'\n  rank x n' = Some j\n  token_run x (Suc n') \\<notin> F\n\ngoal (1 subgoal):\n 1. p \\<in> local.merge i", "unfolding merge_def \\<open>p = (x, y)\\<close>"], ["proof (prove)\nusing this:\n  x < y\n  x \\<noteq> y\n  token_run x n' \\<noteq> token_run y n' \\<or> y = Suc n'\n  token_run x (Suc n') = token_run y (Suc n')\n  y \\<le> Suc n'\n  (\\<exists>j'. rank y n' = Some j') \\<or> y = Suc n'\n  rank x n' = Some j\n  token_run x (Suc n') \\<notin> F\n\ngoal (1 subgoal):\n 1. (x, y)\n    \\<in> {uu_.\n           \\<exists>x y n j.\n              uu_ = (x, y) \\<and>\n              j < i \\<and>\n              (token_run x n \\<noteq> token_run y n \\<and>\n               rank y n \\<noteq> None \\<or>\n               y = Suc n) \\<and>\n              token_run x (Suc n) = token_run y (Suc n) \\<and>\n              token_run x (Suc n) \\<notin> F \\<and> rank x n = Some j}", "using \\<open>j < i\\<close>"], ["proof (prove)\nusing this:\n  x < y\n  x \\<noteq> y\n  token_run x n' \\<noteq> token_run y n' \\<or> y = Suc n'\n  token_run x (Suc n') = token_run y (Suc n')\n  y \\<le> Suc n'\n  (\\<exists>j'. rank y n' = Some j') \\<or> y = Suc n'\n  rank x n' = Some j\n  token_run x (Suc n') \\<notin> F\n  j < i\n\ngoal (1 subgoal):\n 1. (x, y)\n    \\<in> {uu_.\n           \\<exists>x y n j.\n              uu_ = (x, y) \\<and>\n              j < i \\<and>\n              (token_run x n \\<noteq> token_run y n \\<and>\n               rank y n \\<noteq> None \\<or>\n               y = Suc n) \\<and>\n              token_run x (Suc n) = token_run y (Suc n) \\<and>\n              token_run x (Suc n) \\<notin> F \\<and> rank x n = Some j}", "by blast"], ["proof (state)\nthis:\n  p \\<in> local.merge i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {(x, y) |y. n < y \\<and> stable_rank y j} \\<subseteq> local.merge i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> accept\\<^sub>M; q\\<^sub>0 \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>\\<not> accept\\<^sub>M; \\<not> q\\<^sub>0 \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> False", "moreover\n\n    \\<comment> \\<open>However, x merges infinitely many configuration\\<close>"], ["proof (state)\nthis:\n  {(x, y) |y. n < y \\<and> stable_rank y j} \\<subseteq> local.merge i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> accept\\<^sub>M; q\\<^sub>0 \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>\\<not> accept\\<^sub>M; \\<not> q\\<^sub>0 \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"infinite {(x, y) | y. y > n \\<and> stable_rank y j}\"\n      (is \"infinite ?S'\")"], ["proof (prove)\nusing this:\n  {(x, y) |y. n < y \\<and> stable_rank y j} \\<subseteq> local.merge i\n\ngoal (1 subgoal):\n 1. infinite {(x, y) |y. n < y \\<and> stable_rank y j}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {(x, y) |y. n < y \\<and> stable_rank y j}\n    \\<subseteq> local.merge i \\<Longrightarrow>\n    infinite {(x, y) |y. n < y \\<and> stable_rank y j}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. {(x, y) |y. n < y \\<and> stable_rank y j}\n    \\<subseteq> local.merge i \\<Longrightarrow>\n    infinite {(x, y) |y. n < y \\<and> stable_rank y j}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. {(x, y) |y. n < y \\<and> stable_rank y j}\n    \\<subseteq> local.merge i \\<Longrightarrow>\n    infinite {(x, y) |y. n < y \\<and> stable_rank y j}", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. {(x, y) |y. n < y \\<and> stable_rank y j}\n    \\<subseteq> local.merge i \\<Longrightarrow>\n    infinite {(x, y) |y. n < y \\<and> stable_rank y j}", "assume \"stable_rank y j\" and \"y > n\""], ["proof (state)\nthis:\n  stable_rank y j\n  n < y\n\ngoal (1 subgoal):\n 1. {(x, y) |y. n < y \\<and> stable_rank y j}\n    \\<subseteq> local.merge i \\<Longrightarrow>\n    infinite {(x, y) |y. n < y \\<and> stable_rank y j}", "then"], ["proof (chain)\npicking this:\n  stable_rank y j\n  n < y", "obtain n' where \"rank y n' = Some j\""], ["proof (prove)\nusing this:\n  stable_rank y j\n  n < y\n\ngoal (1 subgoal):\n 1. (\\<And>n'.\n        rank y n' = Some j \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding stable_rank_def MOST_nat_le"], ["proof (prove)\nusing this:\n  \\<exists>m. \\<forall>n\\<ge>m. rank y n = Some j\n  n < y\n\ngoal (1 subgoal):\n 1. (\\<And>n'.\n        rank y n' = Some j \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  rank y n' = Some j\n\ngoal (1 subgoal):\n 1. {(x, y) |y. n < y \\<and> stable_rank y j}\n    \\<subseteq> local.merge i \\<Longrightarrow>\n    infinite {(x, y) |y. n < y \\<and> stable_rank y j}", "moreover"], ["proof (state)\nthis:\n  rank y n' = Some j\n\ngoal (1 subgoal):\n 1. {(x, y) |y. n < y \\<and> stable_rank y j}\n    \\<subseteq> local.merge i \\<Longrightarrow>\n    infinite {(x, y) |y. n < y \\<and> stable_rank y j}", "hence \"y \\<le> n'\""], ["proof (prove)\nusing this:\n  rank y n' = Some j\n\ngoal (1 subgoal):\n 1. y \\<le> n'", "by (rule rank_Some_time)"], ["proof (state)\nthis:\n  y \\<le> n'\n\ngoal (1 subgoal):\n 1. {(x, y) |y. n < y \\<and> stable_rank y j}\n    \\<subseteq> local.merge i \\<Longrightarrow>\n    infinite {(x, y) |y. n < y \\<and> stable_rank y j}", "hence \"n' > n\""], ["proof (prove)\nusing this:\n  y \\<le> n'\n\ngoal (1 subgoal):\n 1. n < n'", "using \\<open>y > n\\<close>"], ["proof (prove)\nusing this:\n  y \\<le> n'\n  n < y\n\ngoal (1 subgoal):\n 1. n < n'", "by arith"], ["proof (state)\nthis:\n  n < n'\n\ngoal (1 subgoal):\n 1. {(x, y) |y. n < y \\<and> stable_rank y j}\n    \\<subseteq> local.merge i \\<Longrightarrow>\n    infinite {(x, y) |y. n < y \\<and> stable_rank y j}", "hence \"rank x n' = Some j\""], ["proof (prove)\nusing this:\n  n < n'\n\ngoal (1 subgoal):\n 1. rank x n' = Some j", "using \\<open>\\<forall>n' \\<ge> n. rank x n' = Some j\\<close>"], ["proof (prove)\nusing this:\n  n < n'\n  \\<forall>n'\\<ge>n. rank x n' = Some j\n\ngoal (1 subgoal):\n 1. rank x n' = Some j", "by simp"], ["proof (state)\nthis:\n  rank x n' = Some j\n\ngoal (1 subgoal):\n 1. {(x, y) |y. n < y \\<and> stable_rank y j}\n    \\<subseteq> local.merge i \\<Longrightarrow>\n    infinite {(x, y) |y. n < y \\<and> stable_rank y j}", "ultimately"], ["proof (chain)\npicking this:\n  rank y n' = Some j\n  rank x n' = Some j", "have \"\\<not>token_succeeds y\""], ["proof (prove)\nusing this:\n  rank y n' = Some j\n  rank x n' = Some j\n\ngoal (1 subgoal):\n 1. \\<not> token_succeeds y", "by (metis \\<open>\\<not>token_succeeds x\\<close> configuration_token_succeeds push_down_rank_tokens)"], ["proof (state)\nthis:\n  \\<not> token_succeeds y\n\ngoal (1 subgoal):\n 1. {(x, y) |y. n < y \\<and> stable_rank y j}\n    \\<subseteq> local.merge i \\<Longrightarrow>\n    infinite {(x, y) |y. n < y \\<and> stable_rank y j}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>stable_rank ?y2 j; n < ?y2\\<rbrakk>\n  \\<Longrightarrow> \\<not> token_succeeds ?y2\n\ngoal (1 subgoal):\n 1. {(x, y) |y. n < y \\<and> stable_rank y j}\n    \\<subseteq> local.merge i \\<Longrightarrow>\n    infinite {(x, y) |y. n < y \\<and> stable_rank y j}", "hence \"{y | y. y > n \\<and> stable_rank y j} = {y | y. token_squats y \\<and> \\<not>token_succeeds y \\<and> stable_rank y j \\<and>  y > n}\"\n          (is \"_ = ?S''\")"], ["proof (prove)\nusing this:\n  \\<lbrakk>stable_rank ?y2 j; n < ?y2\\<rbrakk>\n  \\<Longrightarrow> \\<not> token_succeeds ?y2\n\ngoal (1 subgoal):\n 1. {y |y. n < y \\<and> stable_rank y j} =\n    {y |y.\n     token_squats y \\<and>\n     \\<not> token_succeeds y \\<and> stable_rank y j \\<and> n < y}", "using stable_rank_equiv_token_squats"], ["proof (prove)\nusing this:\n  \\<lbrakk>stable_rank ?y2 j; n < ?y2\\<rbrakk>\n  \\<Longrightarrow> \\<not> token_succeeds ?y2\n  token_squats ?x = (\\<exists>i. stable_rank ?x i)\n\ngoal (1 subgoal):\n 1. {y |y. n < y \\<and> stable_rank y j} =\n    {y |y.\n     token_squats y \\<and>\n     \\<not> token_succeeds y \\<and> stable_rank y j \\<and> n < y}", "by blast"], ["proof (state)\nthis:\n  {y |y. n < y \\<and> stable_rank y j} =\n  {y |y.\n   token_squats y \\<and>\n   \\<not> token_succeeds y \\<and> stable_rank y j \\<and> n < y}\n\ngoal (1 subgoal):\n 1. {(x, y) |y. n < y \\<and> stable_rank y j}\n    \\<subseteq> local.merge i \\<Longrightarrow>\n    infinite {(x, y) |y. n < y \\<and> stable_rank y j}", "moreover"], ["proof (state)\nthis:\n  {y |y. n < y \\<and> stable_rank y j} =\n  {y |y.\n   token_squats y \\<and>\n   \\<not> token_succeeds y \\<and> stable_rank y j \\<and> n < y}\n\ngoal (1 subgoal):\n 1. {(x, y) |y. n < y \\<and> stable_rank y j}\n    \\<subseteq> local.merge i \\<Longrightarrow>\n    infinite {(x, y) |y. n < y \\<and> stable_rank y j}", "have \"finite {y | y. token_squats y \\<and> \\<not>token_succeeds y \\<and> stable_rank y j \\<and>  y \\<le> n}\"\n          (is \"finite ?S'''\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {y |y.\n      token_squats y \\<and>\n      \\<not> token_succeeds y \\<and> stable_rank y j \\<and> y \\<le> n}", "by simp"], ["proof (state)\nthis:\n  finite\n   {y |y.\n    token_squats y \\<and>\n    \\<not> token_succeeds y \\<and> stable_rank y j \\<and> y \\<le> n}\n\ngoal (1 subgoal):\n 1. {(x, y) |y. n < y \\<and> stable_rank y j}\n    \\<subseteq> local.merge i \\<Longrightarrow>\n    infinite {(x, y) |y. n < y \\<and> stable_rank y j}", "moreover"], ["proof (state)\nthis:\n  finite\n   {y |y.\n    token_squats y \\<and>\n    \\<not> token_succeeds y \\<and> stable_rank y j \\<and> y \\<le> n}\n\ngoal (1 subgoal):\n 1. {(x, y) |y. n < y \\<and> stable_rank y j}\n    \\<subseteq> local.merge i \\<Longrightarrow>\n    infinite {(x, y) |y. n < y \\<and> stable_rank y j}", "have \"?S = ?S'' \\<union> ?S'''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {t. \\<not> token_succeeds t \\<and>\n        token_squats t \\<and> stable_rank t j} =\n    {y |y.\n     token_squats y \\<and>\n     \\<not> token_succeeds y \\<and> stable_rank y j \\<and> n < y} \\<union>\n    {y |y.\n     token_squats y \\<and>\n     \\<not> token_succeeds y \\<and> stable_rank y j \\<and> y \\<le> n}", "by auto"], ["proof (state)\nthis:\n  {t. \\<not> token_succeeds t \\<and>\n      token_squats t \\<and> stable_rank t j} =\n  {y |y.\n   token_squats y \\<and>\n   \\<not> token_succeeds y \\<and> stable_rank y j \\<and> n < y} \\<union>\n  {y |y.\n   token_squats y \\<and>\n   \\<not> token_succeeds y \\<and> stable_rank y j \\<and> y \\<le> n}\n\ngoal (1 subgoal):\n 1. {(x, y) |y. n < y \\<and> stable_rank y j}\n    \\<subseteq> local.merge i \\<Longrightarrow>\n    infinite {(x, y) |y. n < y \\<and> stable_rank y j}", "ultimately"], ["proof (chain)\npicking this:\n  {y |y. n < y \\<and> stable_rank y j} =\n  {y |y.\n   token_squats y \\<and>\n   \\<not> token_succeeds y \\<and> stable_rank y j \\<and> n < y}\n  finite\n   {y |y.\n    token_squats y \\<and>\n    \\<not> token_succeeds y \\<and> stable_rank y j \\<and> y \\<le> n}\n  {t. \\<not> token_succeeds t \\<and>\n      token_squats t \\<and> stable_rank t j} =\n  {y |y.\n   token_squats y \\<and>\n   \\<not> token_succeeds y \\<and> stable_rank y j \\<and> n < y} \\<union>\n  {y |y.\n   token_squats y \\<and>\n   \\<not> token_succeeds y \\<and> stable_rank y j \\<and> y \\<le> n}", "have \"infinite {y | y. y > n \\<and> stable_rank y j}\""], ["proof (prove)\nusing this:\n  {y |y. n < y \\<and> stable_rank y j} =\n  {y |y.\n   token_squats y \\<and>\n   \\<not> token_succeeds y \\<and> stable_rank y j \\<and> n < y}\n  finite\n   {y |y.\n    token_squats y \\<and>\n    \\<not> token_succeeds y \\<and> stable_rank y j \\<and> y \\<le> n}\n  {t. \\<not> token_succeeds t \\<and>\n      token_squats t \\<and> stable_rank t j} =\n  {y |y.\n   token_squats y \\<and>\n   \\<not> token_succeeds y \\<and> stable_rank y j \\<and> n < y} \\<union>\n  {y |y.\n   token_squats y \\<and>\n   \\<not> token_succeeds y \\<and> stable_rank y j \\<and> y \\<le> n}\n\ngoal (1 subgoal):\n 1. infinite {y |y. n < y \\<and> stable_rank y j}", "using \\<open>infinite ?S\\<close>"], ["proof (prove)\nusing this:\n  {y |y. n < y \\<and> stable_rank y j} =\n  {y |y.\n   token_squats y \\<and>\n   \\<not> token_succeeds y \\<and> stable_rank y j \\<and> n < y}\n  finite\n   {y |y.\n    token_squats y \\<and>\n    \\<not> token_succeeds y \\<and> stable_rank y j \\<and> y \\<le> n}\n  {t. \\<not> token_succeeds t \\<and>\n      token_squats t \\<and> stable_rank t j} =\n  {y |y.\n   token_squats y \\<and>\n   \\<not> token_succeeds y \\<and> stable_rank y j \\<and> n < y} \\<union>\n  {y |y.\n   token_squats y \\<and>\n   \\<not> token_succeeds y \\<and> stable_rank y j \\<and> y \\<le> n}\n  infinite\n   {t. \\<not> token_succeeds t \\<and> token_squats t \\<and> stable_rank t j}\n\ngoal (1 subgoal):\n 1. infinite {y |y. n < y \\<and> stable_rank y j}", "by simp"], ["proof (state)\nthis:\n  infinite {y |y. n < y \\<and> stable_rank y j}\n\ngoal (1 subgoal):\n 1. {(x, y) |y. n < y \\<and> stable_rank y j}\n    \\<subseteq> local.merge i \\<Longrightarrow>\n    infinite {(x, y) |y. n < y \\<and> stable_rank y j}", "}"], ["proof (state)\nthis:\n  infinite {y |y. n < y \\<and> stable_rank y j}\n\ngoal (1 subgoal):\n 1. {(x, y) |y. n < y \\<and> stable_rank y j}\n    \\<subseteq> local.merge i \\<Longrightarrow>\n    infinite {(x, y) |y. n < y \\<and> stable_rank y j}", "moreover"], ["proof (state)\nthis:\n  infinite {y |y. n < y \\<and> stable_rank y j}\n\ngoal (1 subgoal):\n 1. {(x, y) |y. n < y \\<and> stable_rank y j}\n    \\<subseteq> local.merge i \\<Longrightarrow>\n    infinite {(x, y) |y. n < y \\<and> stable_rank y j}", "have \"{x} \\<times> {y. y > n \\<and> stable_rank y j} = ?S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x} \\<times> {y. n < y \\<and> stable_rank y j} =\n    {(x, y) |y. n < y \\<and> stable_rank y j}", "by auto"], ["proof (state)\nthis:\n  {x} \\<times> {y. n < y \\<and> stable_rank y j} =\n  {(x, y) |y. n < y \\<and> stable_rank y j}\n\ngoal (1 subgoal):\n 1. {(x, y) |y. n < y \\<and> stable_rank y j}\n    \\<subseteq> local.merge i \\<Longrightarrow>\n    infinite {(x, y) |y. n < y \\<and> stable_rank y j}", "ultimately"], ["proof (chain)\npicking this:\n  infinite {y |y. n < y \\<and> stable_rank y j}\n  {x} \\<times> {y. n < y \\<and> stable_rank y j} =\n  {(x, y) |y. n < y \\<and> stable_rank y j}", "show ?thesis"], ["proof (prove)\nusing this:\n  infinite {y |y. n < y \\<and> stable_rank y j}\n  {x} \\<times> {y. n < y \\<and> stable_rank y j} =\n  {(x, y) |y. n < y \\<and> stable_rank y j}\n\ngoal (1 subgoal):\n 1. infinite {(x, y) |y. n < y \\<and> stable_rank y j}", "by (metis empty_iff finite_cartesian_productD2 singletonI)"], ["proof (state)\nthis:\n  infinite {(x, y) |y. n < y \\<and> stable_rank y j}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  infinite {(x, y) |y. n < y \\<and> stable_rank y j}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> accept\\<^sub>M; q\\<^sub>0 \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>\\<not> accept\\<^sub>M; \\<not> q\\<^sub>0 \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  {(x, y) |y. n < y \\<and> stable_rank y j} \\<subseteq> local.merge i\n  infinite {(x, y) |y. n < y \\<and> stable_rank y j}", "have \"infinite (merge i)\""], ["proof (prove)\nusing this:\n  {(x, y) |y. n < y \\<and> stable_rank y j} \\<subseteq> local.merge i\n  infinite {(x, y) |y. n < y \\<and> stable_rank y j}\n\ngoal (1 subgoal):\n 1. infinite (local.merge i)", "by (rule infinite_super)"], ["proof (state)\nthis:\n  infinite (local.merge i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> accept\\<^sub>M; q\\<^sub>0 \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>\\<not> accept\\<^sub>M; \\<not> q\\<^sub>0 \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> False", "with \\<open>finite (merge i)\\<close>"], ["proof (chain)\npicking this:\n  finite (local.merge i)\n  infinite (local.merge i)", "show \"False\""], ["proof (prove)\nusing this:\n  finite (local.merge i)\n  infinite (local.merge i)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> accept\\<^sub>M; \\<not> q\\<^sub>0 \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> False", "qed (blast intro: mojmir_accept_initial)"], ["", "theorem mojmir_accept_iff_token_set_accept:\n  \"accept \\<longleftrightarrow> (\\<exists>i < max_rank. finite fail \\<and> finite (merge i) \\<and> infinite (succeed i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. accept\\<^sub>M =\n    (\\<exists>i<max_rank.\n        finite fail \\<and>\n        finite (local.merge i) \\<and> infinite (succeed i))", "using mojmir_accept_token_set_def1 mojmir_accept_token_set_def2"], ["proof (prove)\nusing this:\n  accept\\<^sub>M \\<Longrightarrow>\n  \\<exists>i<max_rank.\n     finite fail \\<and>\n     finite (local.merge i) \\<and>\n     infinite (succeed i) \\<and> (\\<forall>j<i. finite (succeed j))\n  \\<lbrakk>finite fail; finite (local.merge ?i);\n   infinite (succeed ?i)\\<rbrakk>\n  \\<Longrightarrow> accept\\<^sub>M\n\ngoal (1 subgoal):\n 1. accept\\<^sub>M =\n    (\\<exists>i<max_rank.\n        finite fail \\<and>\n        finite (local.merge i) \\<and> infinite (succeed i))", "by blast"], ["", "theorem mojmir_accept_iff_token_set_accept2:\n  \"accept \\<longleftrightarrow> (\\<exists>i < max_rank. finite fail \\<and> finite (merge i) \\<and> infinite (succeed i) \\<and> (\\<forall>j < i. finite (merge j) \\<and> finite (succeed j)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. accept\\<^sub>M =\n    (\\<exists>i<max_rank.\n        finite fail \\<and>\n        finite (local.merge i) \\<and>\n        infinite (succeed i) \\<and>\n        (\\<forall>j<i. finite (local.merge j) \\<and> finite (succeed j)))", "using mojmir_accept_token_set_def1 mojmir_accept_token_set_def2 merge_finite'"], ["proof (prove)\nusing this:\n  accept\\<^sub>M \\<Longrightarrow>\n  \\<exists>i<max_rank.\n     finite fail \\<and>\n     finite (local.merge i) \\<and>\n     infinite (succeed i) \\<and> (\\<forall>j<i. finite (succeed j))\n  \\<lbrakk>finite fail; finite (local.merge ?i);\n   infinite (succeed ?i)\\<rbrakk>\n  \\<Longrightarrow> accept\\<^sub>M\n  \\<lbrakk>?i < ?j; finite (local.merge ?j)\\<rbrakk>\n  \\<Longrightarrow> finite (local.merge ?i)\n\ngoal (1 subgoal):\n 1. accept\\<^sub>M =\n    (\\<exists>i<max_rank.\n        finite fail \\<and>\n        finite (local.merge i) \\<and>\n        infinite (succeed i) \\<and>\n        (\\<forall>j<i. finite (local.merge j) \\<and> finite (succeed j)))", "by blast"], ["", "subsubsection \\<open>Time-Based Definitions\\<close>\n\n\\<comment> \\<open>Proof Rules\\<close>"], ["", "lemma finite_monotonic_image:\n  fixes A B :: \"nat set\"\n  assumes \"\\<And>i. i \\<in> A \\<Longrightarrow> i \\<le> f i\"\n  assumes \"f ` A = B\"\n  shows \"finite A \\<longleftrightarrow> finite B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A = finite B", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow> finite B\n 2. finite B \\<Longrightarrow> finite A", "assume \"finite B\""], ["proof (state)\nthis:\n  finite B\n\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow> finite B\n 2. finite B \\<Longrightarrow> finite A", "thus \"finite A\""], ["proof (prove)\nusing this:\n  finite B\n\ngoal (1 subgoal):\n 1. finite A", "proof (cases \"B \\<noteq> {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite B; B \\<noteq> {}\\<rbrakk> \\<Longrightarrow> finite A\n 2. \\<lbrakk>finite B; \\<not> B \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> finite A", "case True"], ["proof (state)\nthis:\n  B \\<noteq> {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>finite B; B \\<noteq> {}\\<rbrakk> \\<Longrightarrow> finite A\n 2. \\<lbrakk>finite B; \\<not> B \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> finite A", "hence \"\\<And>i. i \\<in> A \\<Longrightarrow> i \\<le> Max B\""], ["proof (prove)\nusing this:\n  B \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> A \\<Longrightarrow> i \\<le> Max B", "by (metis assms Max_ge_iff \\<open>finite B\\<close> imageI)"], ["proof (state)\nthis:\n  ?i \\<in> A \\<Longrightarrow> ?i \\<le> Max B\n\ngoal (2 subgoals):\n 1. \\<lbrakk>finite B; B \\<noteq> {}\\<rbrakk> \\<Longrightarrow> finite A\n 2. \\<lbrakk>finite B; \\<not> B \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> finite A", "thus \"finite A\""], ["proof (prove)\nusing this:\n  ?i \\<in> A \\<Longrightarrow> ?i \\<le> Max B\n\ngoal (1 subgoal):\n 1. finite A", "unfolding finite_nat_set_iff_bounded_le"], ["proof (prove)\nusing this:\n  ?i \\<in> A \\<Longrightarrow> ?i \\<le> Max B\n\ngoal (1 subgoal):\n 1. \\<exists>m. \\<forall>n\\<in>A. n \\<le> m", "by blast"], ["proof (state)\nthis:\n  finite A\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite B; \\<not> B \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> finite A", "qed (metis assms(2) image_is_empty)"], ["proof (state)\nthis:\n  finite A\n\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow> finite B", "qed (metis assms(2) finite_imageI)"], ["", "lemma finite_monotonic_image_pairs:\n  fixes A :: \"(nat \\<times> nat) set\"\n  fixes B :: \"nat set\"\n  assumes \"\\<And>i. i \\<in> A \\<Longrightarrow> (fst i) \\<le> f i + c\"\n  assumes \"\\<And>i. i \\<in> A \\<Longrightarrow> (snd i) \\<le> f i + d\"\n  assumes \"f ` A = B\"\n  shows \"finite A \\<longleftrightarrow> finite B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A = finite B", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow> finite B\n 2. finite B \\<Longrightarrow> finite A", "assume \"finite B\""], ["proof (state)\nthis:\n  finite B\n\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow> finite B\n 2. finite B \\<Longrightarrow> finite A", "thus \"finite A\""], ["proof (prove)\nusing this:\n  finite B\n\ngoal (1 subgoal):\n 1. finite A", "proof (cases \"B \\<noteq> {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite B; B \\<noteq> {}\\<rbrakk> \\<Longrightarrow> finite A\n 2. \\<lbrakk>finite B; \\<not> B \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> finite A", "case True"], ["proof (state)\nthis:\n  B \\<noteq> {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>finite B; B \\<noteq> {}\\<rbrakk> \\<Longrightarrow> finite A\n 2. \\<lbrakk>finite B; \\<not> B \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> finite A", "hence \"\\<And>i. i \\<in> A \\<Longrightarrow> fst i \\<le> Max B + c \\<and> snd i \\<le> Max B + d\""], ["proof (prove)\nusing this:\n  B \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> A \\<Longrightarrow>\n       fst i \\<le> Max B + c \\<and> snd i \\<le> Max B + d", "by (metis assms Max_ge_iff \\<open>finite B\\<close> imageI le_diff_conv)"], ["proof (state)\nthis:\n  ?i \\<in> A \\<Longrightarrow>\n  fst ?i \\<le> Max B + c \\<and> snd ?i \\<le> Max B + d\n\ngoal (2 subgoals):\n 1. \\<lbrakk>finite B; B \\<noteq> {}\\<rbrakk> \\<Longrightarrow> finite A\n 2. \\<lbrakk>finite B; \\<not> B \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> finite A", "thus \"finite A\""], ["proof (prove)\nusing this:\n  ?i \\<in> A \\<Longrightarrow>\n  fst ?i \\<le> Max B + c \\<and> snd ?i \\<le> Max B + d\n\ngoal (1 subgoal):\n 1. finite A", "using finite_product[of A]"], ["proof (prove)\nusing this:\n  ?i \\<in> A \\<Longrightarrow>\n  fst ?i \\<le> Max B + c \\<and> snd ?i \\<le> Max B + d\n  \\<lbrakk>finite (fst ` A); finite (snd ` A)\\<rbrakk>\n  \\<Longrightarrow> finite A\n\ngoal (1 subgoal):\n 1. finite A", "unfolding finite_nat_set_iff_bounded_le"], ["proof (prove)\nusing this:\n  ?i \\<in> A \\<Longrightarrow>\n  fst ?i \\<le> Max B + c \\<and> snd ?i \\<le> Max B + d\n  \\<lbrakk>\\<exists>m. \\<forall>n\\<in>fst ` A. n \\<le> m;\n   \\<exists>m. \\<forall>n\\<in>snd ` A. n \\<le> m\\<rbrakk>\n  \\<Longrightarrow> finite A\n\ngoal (1 subgoal):\n 1. finite A", "by blast"], ["proof (state)\nthis:\n  finite A\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite B; \\<not> B \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> finite A", "qed (metis assms(3) finite.emptyI image_is_empty)"], ["proof (state)\nthis:\n  finite A\n\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow> finite B", "qed (metis assms(3) finite_imageI)"], ["", "lemma token_time_finite_rule:\n  fixes A B :: \"nat set\"\n  assumes unique:  \"\\<And>x y z. P x y \\<Longrightarrow> P x z \\<Longrightarrow> y = z\"\n      and existsA: \"\\<And>x. x \\<in> A \\<Longrightarrow> (\\<exists>y. P x y)\"\n      and existsB: \"\\<And>y. y \\<in> B \\<Longrightarrow> (\\<exists>x. P x y)\"\n      and inA:     \"\\<And>x y. P x y \\<Longrightarrow> x \\<in> A\"\n      and inB:     \"\\<And>x y. P x y \\<Longrightarrow> y \\<in> B\"\n      and mono:    \"\\<And>x y. P x y \\<Longrightarrow> x \\<le> y\"\n  shows \"finite A \\<longleftrightarrow> finite B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A = finite B", "proof (rule finite_monotonic_image)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i. i \\<in> A \\<Longrightarrow> i \\<le> ?f i\n 2. ?f ` A = B", "let ?f = \"(\\<lambda>x. if x \\<in> A then The (P x) else undefined)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i. i \\<in> A \\<Longrightarrow> i \\<le> ?f i\n 2. ?f ` A = B", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i. i \\<in> A \\<Longrightarrow> i \\<le> ?f i\n 2. ?f ` A = B", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i. i \\<in> A \\<Longrightarrow> i \\<le> ?f i\n 2. ?f ` A = B", "assume \"x \\<in> A\""], ["proof (state)\nthis:\n  x \\<in> A\n\ngoal (2 subgoals):\n 1. \\<And>i. i \\<in> A \\<Longrightarrow> i \\<le> ?f i\n 2. ?f ` A = B", "then"], ["proof (chain)\npicking this:\n  x \\<in> A", "obtain y where \"P x y\" and \"y = ?f x\""], ["proof (prove)\nusing this:\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>P x y;\n         y = (if x \\<in> A then The (P x) else undefined)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using existsA the_equality unique"], ["proof (prove)\nusing this:\n  x \\<in> A\n  ?x \\<in> A \\<Longrightarrow> \\<exists>y. P ?x y\n  \\<lbrakk>?P ?a; \\<And>x. ?P x \\<Longrightarrow> x = ?a\\<rbrakk>\n  \\<Longrightarrow> (THE x. ?P x) = ?a\n  \\<lbrakk>P ?x ?y; P ?x ?z\\<rbrakk> \\<Longrightarrow> ?y = ?z\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>P x y;\n         y = (if x \\<in> A then The (P x) else undefined)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  P x y\n  y = (if x \\<in> A then The (P x) else undefined)\n\ngoal (2 subgoals):\n 1. \\<And>i. i \\<in> A \\<Longrightarrow> i \\<le> ?f i\n 2. ?f ` A = B", "thus \"x \\<le> ?f x\""], ["proof (prove)\nusing this:\n  P x y\n  y = (if x \\<in> A then The (P x) else undefined)\n\ngoal (1 subgoal):\n 1. x \\<le> (if x \\<in> A then The (P x) else undefined)", "using mono"], ["proof (prove)\nusing this:\n  P x y\n  y = (if x \\<in> A then The (P x) else undefined)\n  P ?x ?y \\<Longrightarrow> ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. x \\<le> (if x \\<in> A then The (P x) else undefined)", "by blast"], ["proof (state)\nthis:\n  x \\<le> (if x \\<in> A then The (P x) else undefined)\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. if i \\<in> A then The (P i) else undefined) ` A = B", "}"], ["proof (state)\nthis:\n  ?x2 \\<in> A \\<Longrightarrow>\n  ?x2 \\<le> (if ?x2 \\<in> A then The (P ?x2) else undefined)\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. if i \\<in> A then The (P i) else undefined) ` A = B", "{"], ["proof (state)\nthis:\n  ?x2 \\<in> A \\<Longrightarrow>\n  ?x2 \\<le> (if ?x2 \\<in> A then The (P ?x2) else undefined)\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. if i \\<in> A then The (P i) else undefined) ` A = B", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>i. if i \\<in> A then The (P i) else undefined) ` A = B", "have \"y \\<in> ?f ` A \\<longleftrightarrow> (\\<exists>x. x \\<in> A \\<and> y = The (P x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y \\<in> (\\<lambda>x. if x \\<in> A then The (P x) else undefined) ` A) =\n    (\\<exists>x. x \\<in> A \\<and> y = The (P x))", "unfolding image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (y \\<in> {y. \\<exists>x\\<in>A.\n                    y = (if x \\<in> A then The (P x) else undefined)}) =\n    (\\<exists>x. x \\<in> A \\<and> y = The (P x))", "by force"], ["proof (state)\nthis:\n  (y \\<in> (\\<lambda>x. if x \\<in> A then The (P x) else undefined) ` A) =\n  (\\<exists>x. x \\<in> A \\<and> y = The (P x))\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. if i \\<in> A then The (P i) else undefined) ` A = B", "also"], ["proof (state)\nthis:\n  (y \\<in> (\\<lambda>x. if x \\<in> A then The (P x) else undefined) ` A) =\n  (\\<exists>x. x \\<in> A \\<and> y = The (P x))\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. if i \\<in> A then The (P i) else undefined) ` A = B", "have \"\\<dots> \\<longleftrightarrow> (\\<exists>x. P x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. x \\<in> A \\<and> y = The (P x)) = (\\<exists>x. P x y)", "by (metis inA existsA unique the_equality)"], ["proof (state)\nthis:\n  (\\<exists>x. x \\<in> A \\<and> y = The (P x)) = (\\<exists>x. P x y)\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. if i \\<in> A then The (P i) else undefined) ` A = B", "also"], ["proof (state)\nthis:\n  (\\<exists>x. x \\<in> A \\<and> y = The (P x)) = (\\<exists>x. P x y)\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. if i \\<in> A then The (P i) else undefined) ` A = B", "have \"\\<dots> \\<longleftrightarrow> y \\<in> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. P x y) = (y \\<in> B)", "using inB existsB"], ["proof (prove)\nusing this:\n  P ?x ?y \\<Longrightarrow> ?y \\<in> B\n  ?y \\<in> B \\<Longrightarrow> \\<exists>x. P x ?y\n\ngoal (1 subgoal):\n 1. (\\<exists>x. P x y) = (y \\<in> B)", "by blast"], ["proof (state)\nthis:\n  (\\<exists>x. P x y) = (y \\<in> B)\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. if i \\<in> A then The (P i) else undefined) ` A = B", "finally"], ["proof (chain)\npicking this:\n  (y \\<in> (\\<lambda>x. if x \\<in> A then The (P x) else undefined) ` A) =\n  (y \\<in> B)", "have \"y \\<in> ?f ` A \\<longleftrightarrow> y \\<in> B\""], ["proof (prove)\nusing this:\n  (y \\<in> (\\<lambda>x. if x \\<in> A then The (P x) else undefined) ` A) =\n  (y \\<in> B)\n\ngoal (1 subgoal):\n 1. (y \\<in> (\\<lambda>x. if x \\<in> A then The (P x) else undefined) ` A) =\n    (y \\<in> B)", "."], ["proof (state)\nthis:\n  (y \\<in> (\\<lambda>x. if x \\<in> A then The (P x) else undefined) ` A) =\n  (y \\<in> B)\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. if i \\<in> A then The (P i) else undefined) ` A = B", "}"], ["proof (state)\nthis:\n  (?y2 \\<in> (\\<lambda>x. if x \\<in> A then The (P x) else undefined) ` A) =\n  (?y2 \\<in> B)\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. if i \\<in> A then The (P i) else undefined) ` A = B", "thus \"?f ` A = B\""], ["proof (prove)\nusing this:\n  (?y2 \\<in> (\\<lambda>x. if x \\<in> A then The (P x) else undefined) ` A) =\n  (?y2 \\<in> B)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x \\<in> A then The (P x) else undefined) ` A = B", "by blast"], ["proof (state)\nthis:\n  (\\<lambda>x. if x \\<in> A then The (P x) else undefined) ` A = B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma token_time_finite_pair_rule:\n  fixes A :: \"(nat \\<times> nat) set\"\n  fixes B :: \"nat set\"\n  assumes unique:  \"\\<And>x y z. P x y \\<Longrightarrow> P x z \\<Longrightarrow> y = z\"\n      and existsA: \"\\<And>x. x \\<in> A \\<Longrightarrow> (\\<exists>y. P x y)\"\n      and existsB: \"\\<And>y. y \\<in> B \\<Longrightarrow> (\\<exists>x. P x y)\"\n      and inA:     \"\\<And>x y. P x y \\<Longrightarrow> x \\<in> A\"\n      and inB:     \"\\<And>x y. P x y \\<Longrightarrow> y \\<in> B\"\n      and mono:    \"\\<And>x y. P x y \\<Longrightarrow> fst x \\<le> y + c \\<and> snd x \\<le> y + d\"\n  shows \"finite A \\<longleftrightarrow> finite B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A = finite B", "proof (rule finite_monotonic_image_pairs)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i. i \\<in> A \\<Longrightarrow> fst i \\<le> ?f i + ?c\n 2. \\<And>i. i \\<in> A \\<Longrightarrow> snd i \\<le> ?f i + ?d\n 3. ?f ` A = B", "let ?f = \"(\\<lambda>x. if x \\<in> A then The (P x) else undefined)\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i. i \\<in> A \\<Longrightarrow> fst i \\<le> ?f i + ?c\n 2. \\<And>i. i \\<in> A \\<Longrightarrow> snd i \\<le> ?f i + ?d\n 3. ?f ` A = B", "{"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i. i \\<in> A \\<Longrightarrow> fst i \\<le> ?f i + ?c\n 2. \\<And>i. i \\<in> A \\<Longrightarrow> snd i \\<le> ?f i + ?d\n 3. ?f ` A = B", "fix x"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i. i \\<in> A \\<Longrightarrow> fst i \\<le> ?f i + ?c\n 2. \\<And>i. i \\<in> A \\<Longrightarrow> snd i \\<le> ?f i + ?d\n 3. ?f ` A = B", "assume \"x \\<in> A\""], ["proof (state)\nthis:\n  x \\<in> A\n\ngoal (3 subgoals):\n 1. \\<And>i. i \\<in> A \\<Longrightarrow> fst i \\<le> ?f i + ?c\n 2. \\<And>i. i \\<in> A \\<Longrightarrow> snd i \\<le> ?f i + ?d\n 3. ?f ` A = B", "then"], ["proof (chain)\npicking this:\n  x \\<in> A", "obtain y where \"P x y\" and \"y = ?f x\""], ["proof (prove)\nusing this:\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>P x y;\n         y = (if x \\<in> A then The (P x) else undefined)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using existsA the_equality unique"], ["proof (prove)\nusing this:\n  x \\<in> A\n  ?x \\<in> A \\<Longrightarrow> \\<exists>y. P ?x y\n  \\<lbrakk>?P ?a; \\<And>x. ?P x \\<Longrightarrow> x = ?a\\<rbrakk>\n  \\<Longrightarrow> (THE x. ?P x) = ?a\n  \\<lbrakk>P ?x ?y; P ?x ?z\\<rbrakk> \\<Longrightarrow> ?y = ?z\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>P x y;\n         y = (if x \\<in> A then The (P x) else undefined)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  P x y\n  y = (if x \\<in> A then The (P x) else undefined)\n\ngoal (3 subgoals):\n 1. \\<And>i. i \\<in> A \\<Longrightarrow> fst i \\<le> ?f i + ?c\n 2. \\<And>i. i \\<in> A \\<Longrightarrow> snd i \\<le> ?f i + ?d\n 3. ?f ` A = B", "thus \"fst x \\<le> ?f x + c\" and \"snd x \\<le> ?f x + d\""], ["proof (prove)\nusing this:\n  P x y\n  y = (if x \\<in> A then The (P x) else undefined)\n\ngoal (1 subgoal):\n 1. fst x \\<le> (if x \\<in> A then The (P x) else undefined) + c &&&\n    snd x \\<le> (if x \\<in> A then The (P x) else undefined) + d", "using mono"], ["proof (prove)\nusing this:\n  P x y\n  y = (if x \\<in> A then The (P x) else undefined)\n  P ?x ?y \\<Longrightarrow> fst ?x \\<le> ?y + c \\<and> snd ?x \\<le> ?y + d\n\ngoal (1 subgoal):\n 1. fst x \\<le> (if x \\<in> A then The (P x) else undefined) + c &&&\n    snd x \\<le> (if x \\<in> A then The (P x) else undefined) + d", "by blast+"], ["proof (state)\nthis:\n  fst x \\<le> (if x \\<in> A then The (P x) else undefined) + c\n  snd x \\<le> (if x \\<in> A then The (P x) else undefined) + d\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. if i \\<in> A then The (P i) else undefined) ` A = B", "}"], ["proof (state)\nthis:\n  ?x2 \\<in> A \\<Longrightarrow>\n  fst ?x2 \\<le> (if ?x2 \\<in> A then The (P ?x2) else undefined) + c\n  ?x2 \\<in> A \\<Longrightarrow>\n  snd ?x2 \\<le> (if ?x2 \\<in> A then The (P ?x2) else undefined) + d\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. if i \\<in> A then The (P i) else undefined) ` A = B", "{"], ["proof (state)\nthis:\n  ?x2 \\<in> A \\<Longrightarrow>\n  fst ?x2 \\<le> (if ?x2 \\<in> A then The (P ?x2) else undefined) + c\n  ?x2 \\<in> A \\<Longrightarrow>\n  snd ?x2 \\<le> (if ?x2 \\<in> A then The (P ?x2) else undefined) + d\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. if i \\<in> A then The (P i) else undefined) ` A = B", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>i. if i \\<in> A then The (P i) else undefined) ` A = B", "have \"y \\<in> ?f ` A \\<longleftrightarrow> (\\<exists>x. x \\<in> A \\<and> y = The (P x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y \\<in> (\\<lambda>x. if x \\<in> A then The (P x) else undefined) ` A) =\n    (\\<exists>x. x \\<in> A \\<and> y = The (P x))", "unfolding image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (y \\<in> {y. \\<exists>x\\<in>A.\n                    y = (if x \\<in> A then The (P x) else undefined)}) =\n    (\\<exists>x. x \\<in> A \\<and> y = The (P x))", "by force"], ["proof (state)\nthis:\n  (y \\<in> (\\<lambda>x. if x \\<in> A then The (P x) else undefined) ` A) =\n  (\\<exists>x. x \\<in> A \\<and> y = The (P x))\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. if i \\<in> A then The (P i) else undefined) ` A = B", "also"], ["proof (state)\nthis:\n  (y \\<in> (\\<lambda>x. if x \\<in> A then The (P x) else undefined) ` A) =\n  (\\<exists>x. x \\<in> A \\<and> y = The (P x))\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. if i \\<in> A then The (P i) else undefined) ` A = B", "have \"\\<dots> \\<longleftrightarrow> (\\<exists>x. P x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. x \\<in> A \\<and> y = The (P x)) = (\\<exists>x. P x y)", "by (metis inA existsA unique the_equality)"], ["proof (state)\nthis:\n  (\\<exists>x. x \\<in> A \\<and> y = The (P x)) = (\\<exists>x. P x y)\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. if i \\<in> A then The (P i) else undefined) ` A = B", "also"], ["proof (state)\nthis:\n  (\\<exists>x. x \\<in> A \\<and> y = The (P x)) = (\\<exists>x. P x y)\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. if i \\<in> A then The (P i) else undefined) ` A = B", "have \"\\<dots> \\<longleftrightarrow> y \\<in> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. P x y) = (y \\<in> B)", "using inB existsB"], ["proof (prove)\nusing this:\n  P ?x ?y \\<Longrightarrow> ?y \\<in> B\n  ?y \\<in> B \\<Longrightarrow> \\<exists>x. P x ?y\n\ngoal (1 subgoal):\n 1. (\\<exists>x. P x y) = (y \\<in> B)", "by blast"], ["proof (state)\nthis:\n  (\\<exists>x. P x y) = (y \\<in> B)\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. if i \\<in> A then The (P i) else undefined) ` A = B", "finally"], ["proof (chain)\npicking this:\n  (y \\<in> (\\<lambda>x. if x \\<in> A then The (P x) else undefined) ` A) =\n  (y \\<in> B)", "have \"y \\<in> ?f ` A \\<longleftrightarrow> y \\<in> B\""], ["proof (prove)\nusing this:\n  (y \\<in> (\\<lambda>x. if x \\<in> A then The (P x) else undefined) ` A) =\n  (y \\<in> B)\n\ngoal (1 subgoal):\n 1. (y \\<in> (\\<lambda>x. if x \\<in> A then The (P x) else undefined) ` A) =\n    (y \\<in> B)", "."], ["proof (state)\nthis:\n  (y \\<in> (\\<lambda>x. if x \\<in> A then The (P x) else undefined) ` A) =\n  (y \\<in> B)\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. if i \\<in> A then The (P i) else undefined) ` A = B", "}"], ["proof (state)\nthis:\n  (?y2 \\<in> (\\<lambda>x. if x \\<in> A then The (P x) else undefined) ` A) =\n  (?y2 \\<in> B)\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. if i \\<in> A then The (P i) else undefined) ` A = B", "thus \"?f ` A = B\""], ["proof (prove)\nusing this:\n  (?y2 \\<in> (\\<lambda>x. if x \\<in> A then The (P x) else undefined) ` A) =\n  (?y2 \\<in> B)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x \\<in> A then The (P x) else undefined) ` A = B", "by blast"], ["proof (state)\nthis:\n  (\\<lambda>x. if x \\<in> A then The (P x) else undefined) ` A = B\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open>Correspondence Between Token- and Time-Based Definitions\\<close>"], ["", "lemma fail_t_inclusion:\n  assumes \"x \\<le> n\"\n  assumes \"\\<not>sink (token_run x n)\"\n  assumes \"sink (token_run x (Suc n))\"\n  assumes \"token_run x (Suc n) \\<notin> F\"\n  shows \"n \\<in> fail_t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> fail_t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<in> fail_t", "define q q' where \"q = token_run x n\" and \"q' = token_run x (Suc n)\""], ["proof (state)\nthis:\n  q = token_run x n\n  q' = token_run x (Suc n)\n\ngoal (1 subgoal):\n 1. n \\<in> fail_t", "hence *: \"\\<not>sink q\" \"sink q'\" and \"q' \\<notin> F\""], ["proof (prove)\nusing this:\n  q = token_run x n\n  q' = token_run x (Suc n)\n\ngoal (1 subgoal):\n 1. (\\<not> sink q &&& sink q') &&& q' \\<notin> F", "using assms"], ["proof (prove)\nusing this:\n  q = token_run x n\n  q' = token_run x (Suc n)\n  x \\<le> n\n  \\<not> sink (token_run x n)\n  sink (token_run x (Suc n))\n  token_run x (Suc n) \\<notin> F\n\ngoal (1 subgoal):\n 1. (\\<not> sink q &&& sink q') &&& q' \\<notin> F", "by blast+"], ["proof (state)\nthis:\n  \\<not> sink q\n  sink q'\n  q' \\<notin> F\n\ngoal (1 subgoal):\n 1. n \\<in> fail_t", "moreover"], ["proof (state)\nthis:\n  \\<not> sink q\n  sink q'\n  q' \\<notin> F\n\ngoal (1 subgoal):\n 1. n \\<in> fail_t", "from *"], ["proof (chain)\npicking this:\n  \\<not> sink q\n  sink q'", "have **: \"state_rank q n \\<noteq> None\""], ["proof (prove)\nusing this:\n  \\<not> sink q\n  sink q'\n\ngoal (1 subgoal):\n 1. state_rank q n \\<noteq> None", "unfolding q_def"], ["proof (prove)\nusing this:\n  \\<not> sink (token_run x n)\n  sink q'\n\ngoal (1 subgoal):\n 1. state_rank (token_run x n) n \\<noteq> None", "by (metis oldest_token_always_def option.distinct(1) state_rank_None)"], ["proof (state)\nthis:\n  state_rank q n \\<noteq> None\n\ngoal (1 subgoal):\n 1. n \\<in> fail_t", "moreover"], ["proof (state)\nthis:\n  state_rank q n \\<noteq> None\n\ngoal (1 subgoal):\n 1. n \\<in> fail_t", "from **"], ["proof (chain)\npicking this:\n  state_rank q n \\<noteq> None", "have \"q' = \\<delta> q (w n)\""], ["proof (prove)\nusing this:\n  state_rank q n \\<noteq> None\n\ngoal (1 subgoal):\n 1. q' = \\<delta> q (w n)", "unfolding q_def q'_def"], ["proof (prove)\nusing this:\n  state_rank (token_run x n) n \\<noteq> None\n\ngoal (1 subgoal):\n 1. token_run x (Suc n) = \\<delta> (token_run x n) (w n)", "using assms(1) token_run_step'"], ["proof (prove)\nusing this:\n  state_rank (token_run x n) n \\<noteq> None\n  x \\<le> n\n  ?x \\<le> ?n \\<Longrightarrow>\n  token_run ?x (Suc ?n) = \\<delta> (token_run ?x ?n) (w ?n)\n\ngoal (1 subgoal):\n 1. token_run x (Suc n) = \\<delta> (token_run x n) (w n)", "by blast"], ["proof (state)\nthis:\n  q' = \\<delta> q (w n)\n\ngoal (1 subgoal):\n 1. n \\<in> fail_t", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> sink q\n  sink q'\n  q' \\<notin> F\n  state_rank q n \\<noteq> None\n  q' = \\<delta> q (w n)", "show \"n \\<in> fail_t\""], ["proof (prove)\nusing this:\n  \\<not> sink q\n  sink q'\n  q' \\<notin> F\n  state_rank q n \\<noteq> None\n  q' = \\<delta> q (w n)\n\ngoal (1 subgoal):\n 1. n \\<in> fail_t", "unfolding fail_t_def"], ["proof (prove)\nusing this:\n  \\<not> sink q\n  sink q'\n  q' \\<notin> F\n  state_rank q n \\<noteq> None\n  q' = \\<delta> q (w n)\n\ngoal (1 subgoal):\n 1. n \\<in> {n. \\<exists>q q'.\n                   state_rank q n \\<noteq> None \\<and>\n                   q' = \\<delta> q (w n) \\<and>\n                   q' \\<notin> F \\<and> sink q'}", "by blast"], ["proof (state)\nthis:\n  n \\<in> fail_t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma merge_t_inclusion:\n  assumes \"x \\<le> n\"\n  assumes \"(\\<exists>j'. token_run x n \\<noteq> token_run y n \\<and> y \\<le> n \\<and> state_rank (token_run y n) n = Some j') \\<or> y = Suc n\"\n  assumes \"token_run x (Suc n) = token_run y (Suc n)\"\n  assumes \"token_run x (Suc n) \\<notin> F\"\n  assumes \"state_rank (token_run x n) n = Some j\"\n  assumes \"j < i\"\n  shows \"n \\<in> merge_t i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> merge_t i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<in> merge_t i", "define q q' q''\n    where \"q = token_run x n\"\n      and \"q' = token_run x (Suc n)\"\n      and \"q'' = token_run y n\""], ["proof (state)\nthis:\n  q = token_run x n\n  q' = token_run x (Suc n)\n  q'' = token_run y n\n\ngoal (1 subgoal):\n 1. n \\<in> merge_t i", "have \"y \\<le> Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> Suc n", "using assms(2)"], ["proof (prove)\nusing this:\n  (\\<exists>j'.\n      token_run x n \\<noteq> token_run y n \\<and>\n      y \\<le> n \\<and> state_rank (token_run y n) n = Some j') \\<or>\n  y = Suc n\n\ngoal (1 subgoal):\n 1. y \\<le> Suc n", "by linarith"], ["proof (state)\nthis:\n  y \\<le> Suc n\n\ngoal (1 subgoal):\n 1. n \\<in> merge_t i", "hence \"(q' = \\<delta> q'' (w n) \\<and> state_rank q'' n \\<noteq> None \\<and> q'' \\<noteq> q) \\<or> q' = q\\<^sub>0\""], ["proof (prove)\nusing this:\n  y \\<le> Suc n\n\ngoal (1 subgoal):\n 1. q' = \\<delta> q'' (w n) \\<and>\n    state_rank q'' n \\<noteq> None \\<and> q'' \\<noteq> q \\<or>\n    q' = q\\<^sub>0", "unfolding q_def q'_def q''_def"], ["proof (prove)\nusing this:\n  y \\<le> Suc n\n\ngoal (1 subgoal):\n 1. token_run x (Suc n) = \\<delta> (token_run y n) (w n) \\<and>\n    state_rank (token_run y n) n \\<noteq> None \\<and>\n    token_run y n \\<noteq> token_run x n \\<or>\n    token_run x (Suc n) = q\\<^sub>0", "using assms(2-3)"], ["proof (prove)\nusing this:\n  y \\<le> Suc n\n  (\\<exists>j'.\n      token_run x n \\<noteq> token_run y n \\<and>\n      y \\<le> n \\<and> state_rank (token_run y n) n = Some j') \\<or>\n  y = Suc n\n  token_run x (Suc n) = token_run y (Suc n)\n\ngoal (1 subgoal):\n 1. token_run x (Suc n) = \\<delta> (token_run y n) (w n) \\<and>\n    state_rank (token_run y n) n \\<noteq> None \\<and>\n    token_run y n \\<noteq> token_run x n \\<or>\n    token_run x (Suc n) = q\\<^sub>0", "by (cases \"y = Suc n\") ((metis token_run_intial_state), (metis option.distinct(1) token_run_step))"], ["proof (state)\nthis:\n  q' = \\<delta> q'' (w n) \\<and>\n  state_rank q'' n \\<noteq> None \\<and> q'' \\<noteq> q \\<or>\n  q' = q\\<^sub>0\n\ngoal (1 subgoal):\n 1. n \\<in> merge_t i", "moreover"], ["proof (state)\nthis:\n  q' = \\<delta> q'' (w n) \\<and>\n  state_rank q'' n \\<noteq> None \\<and> q'' \\<noteq> q \\<or>\n  q' = q\\<^sub>0\n\ngoal (1 subgoal):\n 1. n \\<in> merge_t i", "have \"state_rank q n = Some j \\<and> j < i \\<and> q' = \\<delta> q (w n) \\<and> q' \\<notin> F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_rank q n = Some j \\<and>\n    j < i \\<and> q' = \\<delta> q (w n) \\<and> q' \\<notin> F", "unfolding q_def q'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. state_rank (token_run x n) n = Some j \\<and>\n    j < i \\<and>\n    token_run x (Suc n) = \\<delta> (token_run x n) (w n) \\<and>\n    token_run x (Suc n) \\<notin> F", "using token_run_step[OF assms(1)] assms(4-6)"], ["proof (prove)\nusing this:\n  \\<lbrakk>token_run x n = ?q'; ?q = \\<delta> ?q' (w n)\\<rbrakk>\n  \\<Longrightarrow> token_run x (Suc n) = ?q\n  token_run x (Suc n) \\<notin> F\n  state_rank (token_run x n) n = Some j\n  j < i\n\ngoal (1 subgoal):\n 1. state_rank (token_run x n) n = Some j \\<and>\n    j < i \\<and>\n    token_run x (Suc n) = \\<delta> (token_run x n) (w n) \\<and>\n    token_run x (Suc n) \\<notin> F", "by blast"], ["proof (state)\nthis:\n  state_rank q n = Some j \\<and>\n  j < i \\<and> q' = \\<delta> q (w n) \\<and> q' \\<notin> F\n\ngoal (1 subgoal):\n 1. n \\<in> merge_t i", "ultimately"], ["proof (chain)\npicking this:\n  q' = \\<delta> q'' (w n) \\<and>\n  state_rank q'' n \\<noteq> None \\<and> q'' \\<noteq> q \\<or>\n  q' = q\\<^sub>0\n  state_rank q n = Some j \\<and>\n  j < i \\<and> q' = \\<delta> q (w n) \\<and> q' \\<notin> F", "show \"n \\<in> merge_t i\""], ["proof (prove)\nusing this:\n  q' = \\<delta> q'' (w n) \\<and>\n  state_rank q'' n \\<noteq> None \\<and> q'' \\<noteq> q \\<or>\n  q' = q\\<^sub>0\n  state_rank q n = Some j \\<and>\n  j < i \\<and> q' = \\<delta> q (w n) \\<and> q' \\<notin> F\n\ngoal (1 subgoal):\n 1. n \\<in> merge_t i", "unfolding merge_t_def"], ["proof (prove)\nusing this:\n  q' = \\<delta> q'' (w n) \\<and>\n  state_rank q'' n \\<noteq> None \\<and> q'' \\<noteq> q \\<or>\n  q' = q\\<^sub>0\n  state_rank q n = Some j \\<and>\n  j < i \\<and> q' = \\<delta> q (w n) \\<and> q' \\<notin> F\n\ngoal (1 subgoal):\n 1. n \\<in> {n. \\<exists>q q' j.\n                   state_rank q n = Some j \\<and>\n                   j < i \\<and>\n                   q' = \\<delta> q (w n) \\<and>\n                   q' \\<notin> F \\<and>\n                   ((\\<exists>q''.\n                        q'' \\<noteq> q \\<and>\n                        q' = \\<delta> q'' (w n) \\<and>\n                        state_rank q'' n \\<noteq> None) \\<or>\n                    q' = q\\<^sub>0)}", "by blast"], ["proof (state)\nthis:\n  n \\<in> merge_t i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma succeed_t_inclusion:\n  assumes \"rank x n = Some i\"\n  assumes \"token_run x n \\<notin> F - {q\\<^sub>0}\"\n  assumes \"token_run x (Suc n) \\<in> F\"\n  shows \"n \\<in> succeed_t i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> succeed_t i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<in> succeed_t i", "define q where \"q = token_run x n\""], ["proof (state)\nthis:\n  q = token_run x n\n\ngoal (1 subgoal):\n 1. n \\<in> succeed_t i", "hence \"state_rank q n = Some i\" and \"q \\<notin> F - {q\\<^sub>0}\" and \"\\<delta> q (w n) \\<in> F\""], ["proof (prove)\nusing this:\n  q = token_run x n\n\ngoal (1 subgoal):\n 1. state_rank q n = Some i &&&\n    q \\<notin> F - {q\\<^sub>0} &&& \\<delta> q (w n) \\<in> F", "using token_run_step' rank_Some_time[OF assms(1)] assms rank_eq_state_rank"], ["proof (prove)\nusing this:\n  q = token_run x n\n  ?x \\<le> ?n \\<Longrightarrow>\n  token_run ?x (Suc ?n) = \\<delta> (token_run ?x ?n) (w ?n)\n  x \\<le> n\n  rank x n = Some i\n  token_run x n \\<notin> F - {q\\<^sub>0}\n  token_run x (Suc n) \\<in> F\n  ?x \\<le> ?n \\<Longrightarrow> rank ?x ?n = state_rank (token_run ?x ?n) ?n\n\ngoal (1 subgoal):\n 1. state_rank q n = Some i &&&\n    q \\<notin> F - {q\\<^sub>0} &&& \\<delta> q (w n) \\<in> F", "by auto"], ["proof (state)\nthis:\n  state_rank q n = Some i\n  q \\<notin> F - {q\\<^sub>0}\n  \\<delta> q (w n) \\<in> F\n\ngoal (1 subgoal):\n 1. n \\<in> succeed_t i", "thus \"n \\<in> succeed_t i\""], ["proof (prove)\nusing this:\n  state_rank q n = Some i\n  q \\<notin> F - {q\\<^sub>0}\n  \\<delta> q (w n) \\<in> F\n\ngoal (1 subgoal):\n 1. n \\<in> succeed_t i", "unfolding succeed_t_def"], ["proof (prove)\nusing this:\n  state_rank q n = Some i\n  q \\<notin> F - {q\\<^sub>0}\n  \\<delta> q (w n) \\<in> F\n\ngoal (1 subgoal):\n 1. n \\<in> {n. \\<exists>q.\n                   state_rank q n = Some i \\<and>\n                   q \\<notin> F - {q\\<^sub>0} \\<and>\n                   \\<delta> q (w n) \\<in> F}", "by blast"], ["proof (state)\nthis:\n  n \\<in> succeed_t i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_fail_t:\n  \"finite fail = finite fail_t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite fail = finite fail_t", "proof (rule token_time_finite_rule)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x y z. \\<lbrakk>?P x y; ?P x z\\<rbrakk> \\<Longrightarrow> y = z\n 2. \\<And>x. x \\<in> fail \\<Longrightarrow> \\<exists>y. ?P x y\n 3. \\<And>y. y \\<in> fail_t \\<Longrightarrow> \\<exists>x. ?P x y\n 4. \\<And>x y. ?P x y \\<Longrightarrow> x \\<in> fail\n 5. \\<And>x y. ?P x y \\<Longrightarrow> y \\<in> fail_t\n 6. \\<And>x y. ?P x y \\<Longrightarrow> x \\<le> y", "let ?P = \"(\\<lambda>x n. x \\<le> n\n    \\<and> \\<not>sink (token_run x n)\n    \\<and> sink (token_run x (Suc n))\n    \\<and> token_run x (Suc n) \\<notin> F)\""], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x y z. \\<lbrakk>?P x y; ?P x z\\<rbrakk> \\<Longrightarrow> y = z\n 2. \\<And>x. x \\<in> fail \\<Longrightarrow> \\<exists>y. ?P x y\n 3. \\<And>y. y \\<in> fail_t \\<Longrightarrow> \\<exists>x. ?P x y\n 4. \\<And>x y. ?P x y \\<Longrightarrow> x \\<in> fail\n 5. \\<And>x y. ?P x y \\<Longrightarrow> y \\<in> fail_t\n 6. \\<And>x y. ?P x y \\<Longrightarrow> x \\<le> y", "{"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x y z. \\<lbrakk>?P x y; ?P x z\\<rbrakk> \\<Longrightarrow> y = z\n 2. \\<And>x. x \\<in> fail \\<Longrightarrow> \\<exists>y. ?P x y\n 3. \\<And>y. y \\<in> fail_t \\<Longrightarrow> \\<exists>x. ?P x y\n 4. \\<And>x y. ?P x y \\<Longrightarrow> x \\<in> fail\n 5. \\<And>x y. ?P x y \\<Longrightarrow> y \\<in> fail_t\n 6. \\<And>x y. ?P x y \\<Longrightarrow> x \\<le> y", "fix x"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x y z. \\<lbrakk>?P x y; ?P x z\\<rbrakk> \\<Longrightarrow> y = z\n 2. \\<And>x. x \\<in> fail \\<Longrightarrow> \\<exists>y. ?P x y\n 3. \\<And>y. y \\<in> fail_t \\<Longrightarrow> \\<exists>x. ?P x y\n 4. \\<And>x y. ?P x y \\<Longrightarrow> x \\<in> fail\n 5. \\<And>x y. ?P x y \\<Longrightarrow> y \\<in> fail_t\n 6. \\<And>x y. ?P x y \\<Longrightarrow> x \\<le> y", "have \"\\<not>sink (token_run x x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> sink (token_run x x)", "unfolding sink_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (q\\<^sub>0 \\<noteq> token_run x x \\<and>\n            (\\<forall>\\<nu>\\<in>\\<Sigma>.\n                \\<delta> (token_run x x) \\<nu> = token_run x x))", "by simp"], ["proof (state)\nthis:\n  \\<not> sink (token_run x x)\n\ngoal (6 subgoals):\n 1. \\<And>x y z. \\<lbrakk>?P x y; ?P x z\\<rbrakk> \\<Longrightarrow> y = z\n 2. \\<And>x. x \\<in> fail \\<Longrightarrow> \\<exists>y. ?P x y\n 3. \\<And>y. y \\<in> fail_t \\<Longrightarrow> \\<exists>x. ?P x y\n 4. \\<And>x y. ?P x y \\<Longrightarrow> x \\<in> fail\n 5. \\<And>x y. ?P x y \\<Longrightarrow> y \\<in> fail_t\n 6. \\<And>x y. ?P x y \\<Longrightarrow> x \\<le> y", "assume \"x \\<in> fail\""], ["proof (state)\nthis:\n  x \\<in> fail\n\ngoal (6 subgoals):\n 1. \\<And>x y z. \\<lbrakk>?P x y; ?P x z\\<rbrakk> \\<Longrightarrow> y = z\n 2. \\<And>x. x \\<in> fail \\<Longrightarrow> \\<exists>y. ?P x y\n 3. \\<And>y. y \\<in> fail_t \\<Longrightarrow> \\<exists>x. ?P x y\n 4. \\<And>x y. ?P x y \\<Longrightarrow> x \\<in> fail\n 5. \\<And>x y. ?P x y \\<Longrightarrow> y \\<in> fail_t\n 6. \\<And>x y. ?P x y \\<Longrightarrow> x \\<le> y", "hence \"token_fails x\""], ["proof (prove)\nusing this:\n  x \\<in> fail\n\ngoal (1 subgoal):\n 1. token_fails x", "unfolding fail_def"], ["proof (prove)\nusing this:\n  x \\<in> Collect token_fails\n\ngoal (1 subgoal):\n 1. token_fails x", ".."], ["proof (state)\nthis:\n  token_fails x\n\ngoal (6 subgoals):\n 1. \\<And>x y z. \\<lbrakk>?P x y; ?P x z\\<rbrakk> \\<Longrightarrow> y = z\n 2. \\<And>x. x \\<in> fail \\<Longrightarrow> \\<exists>y. ?P x y\n 3. \\<And>y. y \\<in> fail_t \\<Longrightarrow> \\<exists>x. ?P x y\n 4. \\<And>x y. ?P x y \\<Longrightarrow> x \\<in> fail\n 5. \\<And>x y. ?P x y \\<Longrightarrow> y \\<in> fail_t\n 6. \\<And>x y. ?P x y \\<Longrightarrow> x \\<le> y", "moreover"], ["proof (state)\nthis:\n  token_fails x\n\ngoal (6 subgoals):\n 1. \\<And>x y z. \\<lbrakk>?P x y; ?P x z\\<rbrakk> \\<Longrightarrow> y = z\n 2. \\<And>x. x \\<in> fail \\<Longrightarrow> \\<exists>y. ?P x y\n 3. \\<And>y. y \\<in> fail_t \\<Longrightarrow> \\<exists>x. ?P x y\n 4. \\<And>x y. ?P x y \\<Longrightarrow> x \\<in> fail\n 5. \\<And>x y. ?P x y \\<Longrightarrow> y \\<in> fail_t\n 6. \\<And>x y. ?P x y \\<Longrightarrow> x \\<le> y", "then"], ["proof (chain)\npicking this:\n  token_fails x", "obtain y'' where \"sink (token_run x (Suc (x + y'')))\""], ["proof (prove)\nusing this:\n  token_fails x\n\ngoal (1 subgoal):\n 1. (\\<And>y''.\n        sink (token_run x (Suc (x + y''))) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding token_fails_alt_def MOST_nat"], ["proof (prove)\nusing this:\n  \\<exists>m.\n     \\<forall>n>m. sink (token_run x n) \\<and> token_run x n \\<notin> F\n\ngoal (1 subgoal):\n 1. (\\<And>y''.\n        sink (token_run x (Suc (x + y''))) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>\\<not> sink (token_run x x)\\<close> less_add_Suc2"], ["proof (prove)\nusing this:\n  \\<exists>m.\n     \\<forall>n>m. sink (token_run x n) \\<and> token_run x n \\<notin> F\n  \\<not> sink (token_run x x)\n  ?i < Suc (?m + ?i)\n\ngoal (1 subgoal):\n 1. (\\<And>y''.\n        sink (token_run x (Suc (x + y''))) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  sink (token_run x (Suc (x + y'')))\n\ngoal (6 subgoals):\n 1. \\<And>x y z. \\<lbrakk>?P x y; ?P x z\\<rbrakk> \\<Longrightarrow> y = z\n 2. \\<And>x. x \\<in> fail \\<Longrightarrow> \\<exists>y. ?P x y\n 3. \\<And>y. y \\<in> fail_t \\<Longrightarrow> \\<exists>x. ?P x y\n 4. \\<And>x y. ?P x y \\<Longrightarrow> x \\<in> fail\n 5. \\<And>x y. ?P x y \\<Longrightarrow> y \\<in> fail_t\n 6. \\<And>x y. ?P x y \\<Longrightarrow> x \\<le> y", "then"], ["proof (chain)\npicking this:\n  sink (token_run x (Suc (x + y'')))", "obtain y' where \"\\<not>sink (token_run x (x + y'))\" and \"sink (token_run x (Suc (x + y')))\""], ["proof (prove)\nusing this:\n  sink (token_run x (Suc (x + y'')))\n\ngoal (1 subgoal):\n 1. (\\<And>y'.\n        \\<lbrakk>\\<not> sink (token_run x (x + y'));\n         sink (token_run x (Suc (x + y')))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using token_run_P[of \"\\<lambda>q. sink q\", OF \\<open>\\<not>sink (token_run x x)\\<close>]"], ["proof (prove)\nusing this:\n  sink (token_run x (Suc (x + y'')))\n  sink (token_run x (Suc (x + ?m))) \\<Longrightarrow>\n  \\<exists>m'\\<le>?m.\n     \\<not> sink (token_run x (x + m')) \\<and>\n     sink (token_run x (Suc (x + m')))\n\ngoal (1 subgoal):\n 1. (\\<And>y'.\n        \\<lbrakk>\\<not> sink (token_run x (x + y'));\n         sink (token_run x (Suc (x + y')))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<not> sink (token_run x (x + y'))\n  sink (token_run x (Suc (x + y')))\n\ngoal (6 subgoals):\n 1. \\<And>x y z. \\<lbrakk>?P x y; ?P x z\\<rbrakk> \\<Longrightarrow> y = z\n 2. \\<And>x. x \\<in> fail \\<Longrightarrow> \\<exists>y. ?P x y\n 3. \\<And>y. y \\<in> fail_t \\<Longrightarrow> \\<exists>x. ?P x y\n 4. \\<And>x y. ?P x y \\<Longrightarrow> x \\<in> fail\n 5. \\<And>x y. ?P x y \\<Longrightarrow> y \\<in> fail_t\n 6. \\<And>x y. ?P x y \\<Longrightarrow> x \\<le> y", "ultimately"], ["proof (chain)\npicking this:\n  token_fails x\n  \\<not> sink (token_run x (x + y'))\n  sink (token_run x (Suc (x + y')))", "show \"\\<exists>y. ?P x y\""], ["proof (prove)\nusing this:\n  token_fails x\n  \\<not> sink (token_run x (x + y'))\n  sink (token_run x (Suc (x + y')))\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<ge>x.\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and> token_run x (Suc y) \\<notin> F", "using token_fails_alt_def_2 token_succeeds_def"], ["proof (prove)\nusing this:\n  token_fails x\n  \\<not> sink (token_run x (x + y'))\n  sink (token_run x (Suc (x + y')))\n  token_fails ?x = (\\<not> token_succeeds ?x \\<and> \\<not> token_squats ?x)\n  token_succeeds ?x = (\\<exists>n. token_run ?x n \\<in> F)\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<ge>x.\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and> token_run x (Suc y) \\<notin> F", "by (metis le_add1)"], ["proof (state)\nthis:\n  \\<exists>y\\<ge>x.\n     \\<not> sink (token_run x y) \\<and>\n     sink (token_run x (Suc y)) \\<and> token_run x (Suc y) \\<notin> F\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                \\<not> sink (token_run x y) \\<and>\n                sink (token_run x (Suc y)) \\<and>\n                token_run x (Suc y) \\<notin> F;\n        x \\<le> z \\<and>\n        \\<not> sink (token_run x z) \\<and>\n        sink (token_run x (Suc z)) \\<and>\n        token_run x (Suc z) \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> fail_t \\<Longrightarrow>\n       \\<exists>x\\<le>y.\n          \\<not> sink (token_run x y) \\<and>\n          sink (token_run x (Suc y)) \\<and> token_run x (Suc y) \\<notin> F\n 3. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       x \\<in> fail\n 4. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       y \\<in> fail_t\n 5. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       x \\<le> y", "}"], ["proof (state)\nthis:\n  ?x2 \\<in> fail \\<Longrightarrow>\n  \\<exists>y\\<ge>?x2.\n     \\<not> sink (token_run ?x2 y) \\<and>\n     sink (token_run ?x2 (Suc y)) \\<and> token_run ?x2 (Suc y) \\<notin> F\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                \\<not> sink (token_run x y) \\<and>\n                sink (token_run x (Suc y)) \\<and>\n                token_run x (Suc y) \\<notin> F;\n        x \\<le> z \\<and>\n        \\<not> sink (token_run x z) \\<and>\n        sink (token_run x (Suc z)) \\<and>\n        token_run x (Suc z) \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> fail_t \\<Longrightarrow>\n       \\<exists>x\\<le>y.\n          \\<not> sink (token_run x y) \\<and>\n          sink (token_run x (Suc y)) \\<and> token_run x (Suc y) \\<notin> F\n 3. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       x \\<in> fail\n 4. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       y \\<in> fail_t\n 5. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       x \\<le> y", "{"], ["proof (state)\nthis:\n  ?x2 \\<in> fail \\<Longrightarrow>\n  \\<exists>y\\<ge>?x2.\n     \\<not> sink (token_run ?x2 y) \\<and>\n     sink (token_run ?x2 (Suc y)) \\<and> token_run ?x2 (Suc y) \\<notin> F\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                \\<not> sink (token_run x y) \\<and>\n                sink (token_run x (Suc y)) \\<and>\n                token_run x (Suc y) \\<notin> F;\n        x \\<le> z \\<and>\n        \\<not> sink (token_run x z) \\<and>\n        sink (token_run x (Suc z)) \\<and>\n        token_run x (Suc z) \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> fail_t \\<Longrightarrow>\n       \\<exists>x\\<le>y.\n          \\<not> sink (token_run x y) \\<and>\n          sink (token_run x (Suc y)) \\<and> token_run x (Suc y) \\<notin> F\n 3. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       x \\<in> fail\n 4. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       y \\<in> fail_t\n 5. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       x \\<le> y", "fix y"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                \\<not> sink (token_run x y) \\<and>\n                sink (token_run x (Suc y)) \\<and>\n                token_run x (Suc y) \\<notin> F;\n        x \\<le> z \\<and>\n        \\<not> sink (token_run x z) \\<and>\n        sink (token_run x (Suc z)) \\<and>\n        token_run x (Suc z) \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> fail_t \\<Longrightarrow>\n       \\<exists>x\\<le>y.\n          \\<not> sink (token_run x y) \\<and>\n          sink (token_run x (Suc y)) \\<and> token_run x (Suc y) \\<notin> F\n 3. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       x \\<in> fail\n 4. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       y \\<in> fail_t\n 5. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       x \\<le> y", "assume \"y \\<in> fail_t\""], ["proof (state)\nthis:\n  y \\<in> fail_t\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                \\<not> sink (token_run x y) \\<and>\n                sink (token_run x (Suc y)) \\<and>\n                token_run x (Suc y) \\<notin> F;\n        x \\<le> z \\<and>\n        \\<not> sink (token_run x z) \\<and>\n        sink (token_run x (Suc z)) \\<and>\n        token_run x (Suc z) \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> fail_t \\<Longrightarrow>\n       \\<exists>x\\<le>y.\n          \\<not> sink (token_run x y) \\<and>\n          sink (token_run x (Suc y)) \\<and> token_run x (Suc y) \\<notin> F\n 3. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       x \\<in> fail\n 4. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       y \\<in> fail_t\n 5. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       x \\<le> y", "then"], ["proof (chain)\npicking this:\n  y \\<in> fail_t", "obtain q q' i where \"state_rank q y = Some i\" and \"q' = \\<delta> q (w y)\" and \"q' \\<notin> F\" and \"sink q'\""], ["proof (prove)\nusing this:\n  y \\<in> fail_t\n\ngoal (1 subgoal):\n 1. (\\<And>q i q'.\n        \\<lbrakk>state_rank q y = Some i; q' = \\<delta> q (w y);\n         q' \\<notin> F; sink q'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding fail_t_def"], ["proof (prove)\nusing this:\n  y \\<in> {n. \\<exists>q q'.\n                 state_rank q n \\<noteq> None \\<and>\n                 q' = \\<delta> q (w n) \\<and> q' \\<notin> F \\<and> sink q'}\n\ngoal (1 subgoal):\n 1. (\\<And>q i q'.\n        \\<lbrakk>state_rank q y = Some i; q' = \\<delta> q (w y);\n         q' \\<notin> F; sink q'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  state_rank q y = Some i\n  q' = \\<delta> q (w y)\n  q' \\<notin> F\n  sink q'\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                \\<not> sink (token_run x y) \\<and>\n                sink (token_run x (Suc y)) \\<and>\n                token_run x (Suc y) \\<notin> F;\n        x \\<le> z \\<and>\n        \\<not> sink (token_run x z) \\<and>\n        sink (token_run x (Suc z)) \\<and>\n        token_run x (Suc z) \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> fail_t \\<Longrightarrow>\n       \\<exists>x\\<le>y.\n          \\<not> sink (token_run x y) \\<and>\n          sink (token_run x (Suc y)) \\<and> token_run x (Suc y) \\<notin> F\n 3. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       x \\<in> fail\n 4. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       y \\<in> fail_t\n 5. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       x \\<le> y", "moreover"], ["proof (state)\nthis:\n  state_rank q y = Some i\n  q' = \\<delta> q (w y)\n  q' \\<notin> F\n  sink q'\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                \\<not> sink (token_run x y) \\<and>\n                sink (token_run x (Suc y)) \\<and>\n                token_run x (Suc y) \\<notin> F;\n        x \\<le> z \\<and>\n        \\<not> sink (token_run x z) \\<and>\n        sink (token_run x (Suc z)) \\<and>\n        token_run x (Suc z) \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> fail_t \\<Longrightarrow>\n       \\<exists>x\\<le>y.\n          \\<not> sink (token_run x y) \\<and>\n          sink (token_run x (Suc y)) \\<and> token_run x (Suc y) \\<notin> F\n 3. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       x \\<in> fail\n 4. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       y \\<in> fail_t\n 5. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       x \\<le> y", "then"], ["proof (chain)\npicking this:\n  state_rank q y = Some i\n  q' = \\<delta> q (w y)\n  q' \\<notin> F\n  sink q'", "obtain x where \"token_run x y = q\" and \"x \\<le> y\""], ["proof (prove)\nusing this:\n  state_rank q y = Some i\n  q' = \\<delta> q (w y)\n  q' \\<notin> F\n  sink q'\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>token_run x y = q; x \\<le> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: push_down_state_rank_token_run)"], ["proof (state)\nthis:\n  token_run x y = q\n  x \\<le> y\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                \\<not> sink (token_run x y) \\<and>\n                sink (token_run x (Suc y)) \\<and>\n                token_run x (Suc y) \\<notin> F;\n        x \\<le> z \\<and>\n        \\<not> sink (token_run x z) \\<and>\n        sink (token_run x (Suc z)) \\<and>\n        token_run x (Suc z) \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> fail_t \\<Longrightarrow>\n       \\<exists>x\\<le>y.\n          \\<not> sink (token_run x y) \\<and>\n          sink (token_run x (Suc y)) \\<and> token_run x (Suc y) \\<notin> F\n 3. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       x \\<in> fail\n 4. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       y \\<in> fail_t\n 5. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       x \\<le> y", "moreover"], ["proof (state)\nthis:\n  token_run x y = q\n  x \\<le> y\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                \\<not> sink (token_run x y) \\<and>\n                sink (token_run x (Suc y)) \\<and>\n                token_run x (Suc y) \\<notin> F;\n        x \\<le> z \\<and>\n        \\<not> sink (token_run x z) \\<and>\n        sink (token_run x (Suc z)) \\<and>\n        token_run x (Suc z) \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> fail_t \\<Longrightarrow>\n       \\<exists>x\\<le>y.\n          \\<not> sink (token_run x y) \\<and>\n          sink (token_run x (Suc y)) \\<and> token_run x (Suc y) \\<notin> F\n 3. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       x \\<in> fail\n 4. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       y \\<in> fail_t\n 5. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       x \\<le> y", "hence \"token_run x (Suc y) = q'\""], ["proof (prove)\nusing this:\n  token_run x y = q\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. token_run x (Suc y) = q'", "using token_run_step[OF _ _ \\<open>q' = \\<delta> q (w y)\\<close>]"], ["proof (prove)\nusing this:\n  token_run x y = q\n  x \\<le> y\n  \\<lbrakk>?x \\<le> y; token_run ?x y = q\\<rbrakk>\n  \\<Longrightarrow> token_run ?x (Suc y) = q'\n\ngoal (1 subgoal):\n 1. token_run x (Suc y) = q'", "by blast"], ["proof (state)\nthis:\n  token_run x (Suc y) = q'\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                \\<not> sink (token_run x y) \\<and>\n                sink (token_run x (Suc y)) \\<and>\n                token_run x (Suc y) \\<notin> F;\n        x \\<le> z \\<and>\n        \\<not> sink (token_run x z) \\<and>\n        sink (token_run x (Suc z)) \\<and>\n        token_run x (Suc z) \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> fail_t \\<Longrightarrow>\n       \\<exists>x\\<le>y.\n          \\<not> sink (token_run x y) \\<and>\n          sink (token_run x (Suc y)) \\<and> token_run x (Suc y) \\<notin> F\n 3. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       x \\<in> fail\n 4. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       y \\<in> fail_t\n 5. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       x \\<le> y", "ultimately"], ["proof (chain)\npicking this:\n  state_rank q y = Some i\n  q' = \\<delta> q (w y)\n  q' \\<notin> F\n  sink q'\n  token_run x y = q\n  x \\<le> y\n  token_run x (Suc y) = q'", "show \"\\<exists>x. ?P x y\""], ["proof (prove)\nusing this:\n  state_rank q y = Some i\n  q' = \\<delta> q (w y)\n  q' \\<notin> F\n  sink q'\n  token_run x y = q\n  x \\<le> y\n  token_run x (Suc y) = q'\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<le>y.\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and> token_run x (Suc y) \\<notin> F", "by (metis option.distinct(1) state_rank_sink)"], ["proof (state)\nthis:\n  \\<exists>x\\<le>y.\n     \\<not> sink (token_run x y) \\<and>\n     sink (token_run x (Suc y)) \\<and> token_run x (Suc y) \\<notin> F\n\ngoal (4 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                \\<not> sink (token_run x y) \\<and>\n                sink (token_run x (Suc y)) \\<and>\n                token_run x (Suc y) \\<notin> F;\n        x \\<le> z \\<and>\n        \\<not> sink (token_run x z) \\<and>\n        sink (token_run x (Suc z)) \\<and>\n        token_run x (Suc z) \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       x \\<in> fail\n 3. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       y \\<in> fail_t\n 4. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       x \\<le> y", "}"], ["proof (state)\nthis:\n  ?y2 \\<in> fail_t \\<Longrightarrow>\n  \\<exists>x\\<le>?y2.\n     \\<not> sink (token_run x ?y2) \\<and>\n     sink (token_run x (Suc ?y2)) \\<and> token_run x (Suc ?y2) \\<notin> F\n\ngoal (4 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                \\<not> sink (token_run x y) \\<and>\n                sink (token_run x (Suc y)) \\<and>\n                token_run x (Suc y) \\<notin> F;\n        x \\<le> z \\<and>\n        \\<not> sink (token_run x z) \\<and>\n        sink (token_run x (Suc z)) \\<and>\n        token_run x (Suc z) \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       x \\<in> fail\n 3. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       y \\<in> fail_t\n 4. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       x \\<le> y", "{"], ["proof (state)\nthis:\n  ?y2 \\<in> fail_t \\<Longrightarrow>\n  \\<exists>x\\<le>?y2.\n     \\<not> sink (token_run x ?y2) \\<and>\n     sink (token_run x (Suc ?y2)) \\<and> token_run x (Suc ?y2) \\<notin> F\n\ngoal (4 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                \\<not> sink (token_run x y) \\<and>\n                sink (token_run x (Suc y)) \\<and>\n                token_run x (Suc y) \\<notin> F;\n        x \\<le> z \\<and>\n        \\<not> sink (token_run x z) \\<and>\n        sink (token_run x (Suc z)) \\<and>\n        token_run x (Suc z) \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       x \\<in> fail\n 3. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       y \\<in> fail_t\n 4. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       x \\<le> y", "fix x y"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                \\<not> sink (token_run x y) \\<and>\n                sink (token_run x (Suc y)) \\<and>\n                token_run x (Suc y) \\<notin> F;\n        x \\<le> z \\<and>\n        \\<not> sink (token_run x z) \\<and>\n        sink (token_run x (Suc z)) \\<and>\n        token_run x (Suc z) \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       x \\<in> fail\n 3. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       y \\<in> fail_t\n 4. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       x \\<le> y", "assume \"?P x y\""], ["proof (state)\nthis:\n  x \\<le> y \\<and>\n  \\<not> sink (token_run x y) \\<and>\n  sink (token_run x (Suc y)) \\<and> token_run x (Suc y) \\<notin> F\n\ngoal (4 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                \\<not> sink (token_run x y) \\<and>\n                sink (token_run x (Suc y)) \\<and>\n                token_run x (Suc y) \\<notin> F;\n        x \\<le> z \\<and>\n        \\<not> sink (token_run x z) \\<and>\n        sink (token_run x (Suc z)) \\<and>\n        token_run x (Suc z) \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       x \\<in> fail\n 3. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       y \\<in> fail_t\n 4. \\<And>x y.\n       x \\<le> y \\<and>\n       \\<not> sink (token_run x y) \\<and>\n       sink (token_run x (Suc y)) \\<and>\n       token_run x (Suc y) \\<notin> F \\<Longrightarrow>\n       x \\<le> y", "thus \"x \\<in> fail\" and \"x \\<le> y\" and \"y \\<in> fail_t\""], ["proof (prove)\nusing this:\n  x \\<le> y \\<and>\n  \\<not> sink (token_run x y) \\<and>\n  sink (token_run x (Suc y)) \\<and> token_run x (Suc y) \\<notin> F\n\ngoal (1 subgoal):\n 1. x \\<in> fail &&& x \\<le> y &&& y \\<in> fail_t", "unfolding fail_def"], ["proof (prove)\nusing this:\n  x \\<le> y \\<and>\n  \\<not> sink (token_run x y) \\<and>\n  sink (token_run x (Suc y)) \\<and> token_run x (Suc y) \\<notin> F\n\ngoal (1 subgoal):\n 1. x \\<in> Collect token_fails &&& x \\<le> y &&& y \\<in> fail_t", "using token_fails_def fail_t_inclusion"], ["proof (prove)\nusing this:\n  x \\<le> y \\<and>\n  \\<not> sink (token_run x y) \\<and>\n  sink (token_run x (Suc y)) \\<and> token_run x (Suc y) \\<notin> F\n  token_fails ?x =\n  (\\<exists>n. sink (token_run ?x n) \\<and> token_run ?x n \\<notin> F)\n  \\<lbrakk>?x \\<le> ?n; \\<not> sink (token_run ?x ?n);\n   sink (token_run ?x (Suc ?n)); token_run ?x (Suc ?n) \\<notin> F\\<rbrakk>\n  \\<Longrightarrow> ?n \\<in> fail_t\n\ngoal (1 subgoal):\n 1. x \\<in> Collect token_fails &&& x \\<le> y &&& y \\<in> fail_t", "by blast+"], ["proof (state)\nthis:\n  x \\<in> fail\n  x \\<le> y\n  y \\<in> fail_t\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                \\<not> sink (token_run x y) \\<and>\n                sink (token_run x (Suc y)) \\<and>\n                token_run x (Suc y) \\<notin> F;\n        x \\<le> z \\<and>\n        \\<not> sink (token_run x z) \\<and>\n        sink (token_run x (Suc z)) \\<and>\n        token_run x (Suc z) \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> y = z", "}\n\n  \\<comment> \\<open>Uniqueness\\<close>"], ["proof (state)\nthis:\n  ?x2 \\<le> ?y2 \\<and>\n  \\<not> sink (token_run ?x2 ?y2) \\<and>\n  sink (token_run ?x2 (Suc ?y2)) \\<and>\n  token_run ?x2 (Suc ?y2) \\<notin> F \\<Longrightarrow>\n  ?x2 \\<in> fail\n  ?x2 \\<le> ?y2 \\<and>\n  \\<not> sink (token_run ?x2 ?y2) \\<and>\n  sink (token_run ?x2 (Suc ?y2)) \\<and>\n  token_run ?x2 (Suc ?y2) \\<notin> F \\<Longrightarrow>\n  ?x2 \\<le> ?y2\n  ?x2 \\<le> ?y2 \\<and>\n  \\<not> sink (token_run ?x2 ?y2) \\<and>\n  sink (token_run ?x2 (Suc ?y2)) \\<and>\n  token_run ?x2 (Suc ?y2) \\<notin> F \\<Longrightarrow>\n  ?y2 \\<in> fail_t\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                \\<not> sink (token_run x y) \\<and>\n                sink (token_run x (Suc y)) \\<and>\n                token_run x (Suc y) \\<notin> F;\n        x \\<le> z \\<and>\n        \\<not> sink (token_run x z) \\<and>\n        sink (token_run x (Suc z)) \\<and>\n        token_run x (Suc z) \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> y = z", "{"], ["proof (state)\nthis:\n  ?x2 \\<le> ?y2 \\<and>\n  \\<not> sink (token_run ?x2 ?y2) \\<and>\n  sink (token_run ?x2 (Suc ?y2)) \\<and>\n  token_run ?x2 (Suc ?y2) \\<notin> F \\<Longrightarrow>\n  ?x2 \\<in> fail\n  ?x2 \\<le> ?y2 \\<and>\n  \\<not> sink (token_run ?x2 ?y2) \\<and>\n  sink (token_run ?x2 (Suc ?y2)) \\<and>\n  token_run ?x2 (Suc ?y2) \\<notin> F \\<Longrightarrow>\n  ?x2 \\<le> ?y2\n  ?x2 \\<le> ?y2 \\<and>\n  \\<not> sink (token_run ?x2 ?y2) \\<and>\n  sink (token_run ?x2 (Suc ?y2)) \\<and>\n  token_run ?x2 (Suc ?y2) \\<notin> F \\<Longrightarrow>\n  ?y2 \\<in> fail_t\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                \\<not> sink (token_run x y) \\<and>\n                sink (token_run x (Suc y)) \\<and>\n                token_run x (Suc y) \\<notin> F;\n        x \\<le> z \\<and>\n        \\<not> sink (token_run x z) \\<and>\n        sink (token_run x (Suc z)) \\<and>\n        token_run x (Suc z) \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> y = z", "fix x y z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                \\<not> sink (token_run x y) \\<and>\n                sink (token_run x (Suc y)) \\<and>\n                token_run x (Suc y) \\<notin> F;\n        x \\<le> z \\<and>\n        \\<not> sink (token_run x z) \\<and>\n        sink (token_run x (Suc z)) \\<and>\n        token_run x (Suc z) \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> y = z", "assume \"?P x y\" and \"?P x z\""], ["proof (state)\nthis:\n  x \\<le> y \\<and>\n  \\<not> sink (token_run x y) \\<and>\n  sink (token_run x (Suc y)) \\<and> token_run x (Suc y) \\<notin> F\n  x \\<le> z \\<and>\n  \\<not> sink (token_run x z) \\<and>\n  sink (token_run x (Suc z)) \\<and> token_run x (Suc z) \\<notin> F\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                \\<not> sink (token_run x y) \\<and>\n                sink (token_run x (Suc y)) \\<and>\n                token_run x (Suc y) \\<notin> F;\n        x \\<le> z \\<and>\n        \\<not> sink (token_run x z) \\<and>\n        sink (token_run x (Suc z)) \\<and>\n        token_run x (Suc z) \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> y = z", "from \\<open>?P x y\\<close>"], ["proof (chain)\npicking this:\n  x \\<le> y \\<and>\n  \\<not> sink (token_run x y) \\<and>\n  sink (token_run x (Suc y)) \\<and> token_run x (Suc y) \\<notin> F", "have \"\\<not>sink (token_run x y)\" and \"sink (token_run x (Suc y))\""], ["proof (prove)\nusing this:\n  x \\<le> y \\<and>\n  \\<not> sink (token_run x y) \\<and>\n  sink (token_run x (Suc y)) \\<and> token_run x (Suc y) \\<notin> F\n\ngoal (1 subgoal):\n 1. \\<not> sink (token_run x y) &&& sink (token_run x (Suc y))", "by blast+"], ["proof (state)\nthis:\n  \\<not> sink (token_run x y)\n  sink (token_run x (Suc y))\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                \\<not> sink (token_run x y) \\<and>\n                sink (token_run x (Suc y)) \\<and>\n                token_run x (Suc y) \\<notin> F;\n        x \\<le> z \\<and>\n        \\<not> sink (token_run x z) \\<and>\n        sink (token_run x (Suc z)) \\<and>\n        token_run x (Suc z) \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> y = z", "moreover"], ["proof (state)\nthis:\n  \\<not> sink (token_run x y)\n  sink (token_run x (Suc y))\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                \\<not> sink (token_run x y) \\<and>\n                sink (token_run x (Suc y)) \\<and>\n                token_run x (Suc y) \\<notin> F;\n        x \\<le> z \\<and>\n        \\<not> sink (token_run x z) \\<and>\n        sink (token_run x (Suc z)) \\<and>\n        token_run x (Suc z) \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> y = z", "from \\<open>?P x z\\<close>"], ["proof (chain)\npicking this:\n  x \\<le> z \\<and>\n  \\<not> sink (token_run x z) \\<and>\n  sink (token_run x (Suc z)) \\<and> token_run x (Suc z) \\<notin> F", "have \"\\<not>sink (token_run x z)\" and \"sink (token_run x (Suc z))\""], ["proof (prove)\nusing this:\n  x \\<le> z \\<and>\n  \\<not> sink (token_run x z) \\<and>\n  sink (token_run x (Suc z)) \\<and> token_run x (Suc z) \\<notin> F\n\ngoal (1 subgoal):\n 1. \\<not> sink (token_run x z) &&& sink (token_run x (Suc z))", "by blast+"], ["proof (state)\nthis:\n  \\<not> sink (token_run x z)\n  sink (token_run x (Suc z))\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                \\<not> sink (token_run x y) \\<and>\n                sink (token_run x (Suc y)) \\<and>\n                token_run x (Suc y) \\<notin> F;\n        x \\<le> z \\<and>\n        \\<not> sink (token_run x z) \\<and>\n        sink (token_run x (Suc z)) \\<and>\n        token_run x (Suc z) \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> y = z", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> sink (token_run x y)\n  sink (token_run x (Suc y))\n  \\<not> sink (token_run x z)\n  sink (token_run x (Suc z))", "show \"y = z\""], ["proof (prove)\nusing this:\n  \\<not> sink (token_run x y)\n  sink (token_run x (Suc y))\n  \\<not> sink (token_run x z)\n  sink (token_run x (Suc z))\n\ngoal (1 subgoal):\n 1. y = z", "using token_stays_in_sink"], ["proof (prove)\nusing this:\n  \\<not> sink (token_run x y)\n  sink (token_run x (Suc y))\n  \\<not> sink (token_run x z)\n  sink (token_run x (Suc z))\n  \\<lbrakk>sink ?q; token_run ?x ?n = ?q\\<rbrakk>\n  \\<Longrightarrow> token_run ?x (?n + ?m) = ?q\n\ngoal (1 subgoal):\n 1. y = z", "by (cases y z rule: linorder_cases, simp_all)\n         (metis (no_types, lifting) Suc_leI le_add_diff_inverse)+"], ["proof (state)\nthis:\n  y = z\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?x2 \\<le> ?y2 \\<and>\n           \\<not> sink (token_run ?x2 ?y2) \\<and>\n           sink (token_run ?x2 (Suc ?y2)) \\<and>\n           token_run ?x2 (Suc ?y2) \\<notin> F;\n   ?x2 \\<le> ?z2 \\<and>\n   \\<not> sink (token_run ?x2 ?z2) \\<and>\n   sink (token_run ?x2 (Suc ?z2)) \\<and>\n   token_run ?x2 (Suc ?z2) \\<notin> F\\<rbrakk>\n  \\<Longrightarrow> ?y2 = ?z2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_succeed_t':\n  assumes \"q\\<^sub>0 \\<notin> F\"\n  shows \"finite (succeed i) = finite (succeed_t i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (succeed i) = finite (succeed_t i)", "proof (rule token_time_finite_rule)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x y z. \\<lbrakk>?P x y; ?P x z\\<rbrakk> \\<Longrightarrow> y = z\n 2. \\<And>x. x \\<in> succeed i \\<Longrightarrow> \\<exists>y. ?P x y\n 3. \\<And>y. y \\<in> succeed_t i \\<Longrightarrow> \\<exists>x. ?P x y\n 4. \\<And>x y. ?P x y \\<Longrightarrow> x \\<in> succeed i\n 5. \\<And>x y. ?P x y \\<Longrightarrow> y \\<in> succeed_t i\n 6. \\<And>x y. ?P x y \\<Longrightarrow> x \\<le> y", "let ?P = \"(\\<lambda>x n. x \\<le> n\n    \\<and> state_rank (token_run x n) n = Some i\n    \\<and> (token_run x n) \\<notin> F - {q\\<^sub>0}\n    \\<and> (token_run x (Suc n)) \\<in> F)\""], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x y z. \\<lbrakk>?P x y; ?P x z\\<rbrakk> \\<Longrightarrow> y = z\n 2. \\<And>x. x \\<in> succeed i \\<Longrightarrow> \\<exists>y. ?P x y\n 3. \\<And>y. y \\<in> succeed_t i \\<Longrightarrow> \\<exists>x. ?P x y\n 4. \\<And>x y. ?P x y \\<Longrightarrow> x \\<in> succeed i\n 5. \\<And>x y. ?P x y \\<Longrightarrow> y \\<in> succeed_t i\n 6. \\<And>x y. ?P x y \\<Longrightarrow> x \\<le> y", "{"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x y z. \\<lbrakk>?P x y; ?P x z\\<rbrakk> \\<Longrightarrow> y = z\n 2. \\<And>x. x \\<in> succeed i \\<Longrightarrow> \\<exists>y. ?P x y\n 3. \\<And>y. y \\<in> succeed_t i \\<Longrightarrow> \\<exists>x. ?P x y\n 4. \\<And>x y. ?P x y \\<Longrightarrow> x \\<in> succeed i\n 5. \\<And>x y. ?P x y \\<Longrightarrow> y \\<in> succeed_t i\n 6. \\<And>x y. ?P x y \\<Longrightarrow> x \\<le> y", "fix x"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x y z. \\<lbrakk>?P x y; ?P x z\\<rbrakk> \\<Longrightarrow> y = z\n 2. \\<And>x. x \\<in> succeed i \\<Longrightarrow> \\<exists>y. ?P x y\n 3. \\<And>y. y \\<in> succeed_t i \\<Longrightarrow> \\<exists>x. ?P x y\n 4. \\<And>x y. ?P x y \\<Longrightarrow> x \\<in> succeed i\n 5. \\<And>x y. ?P x y \\<Longrightarrow> y \\<in> succeed_t i\n 6. \\<And>x y. ?P x y \\<Longrightarrow> x \\<le> y", "assume \"x \\<in> succeed i\""], ["proof (state)\nthis:\n  x \\<in> succeed i\n\ngoal (6 subgoals):\n 1. \\<And>x y z. \\<lbrakk>?P x y; ?P x z\\<rbrakk> \\<Longrightarrow> y = z\n 2. \\<And>x. x \\<in> succeed i \\<Longrightarrow> \\<exists>y. ?P x y\n 3. \\<And>y. y \\<in> succeed_t i \\<Longrightarrow> \\<exists>x. ?P x y\n 4. \\<And>x y. ?P x y \\<Longrightarrow> x \\<in> succeed i\n 5. \\<And>x y. ?P x y \\<Longrightarrow> y \\<in> succeed_t i\n 6. \\<And>x y. ?P x y \\<Longrightarrow> x \\<le> y", "then"], ["proof (chain)\npicking this:\n  x \\<in> succeed i", "obtain y where \"token_run x y \\<notin> F - {q\\<^sub>0}\" and \"token_run x (Suc y) \\<in> F\" and \"rank x y = Some i\""], ["proof (prove)\nusing this:\n  x \\<in> succeed i\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>token_run x y \\<notin> F - {q\\<^sub>0};\n         token_run x (Suc y) \\<in> F; rank x y = Some i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding succeed_def"], ["proof (prove)\nusing this:\n  x \\<in> {x. \\<exists>n.\n                 rank x n = Some i \\<and>\n                 token_run x n \\<notin> F - {q\\<^sub>0} \\<and>\n                 token_run x (Suc n) \\<in> F}\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>token_run x y \\<notin> F - {q\\<^sub>0};\n         token_run x (Suc y) \\<in> F; rank x y = Some i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  token_run x y \\<notin> F - {q\\<^sub>0}\n  token_run x (Suc y) \\<in> F\n  rank x y = Some i\n\ngoal (6 subgoals):\n 1. \\<And>x y z. \\<lbrakk>?P x y; ?P x z\\<rbrakk> \\<Longrightarrow> y = z\n 2. \\<And>x. x \\<in> succeed i \\<Longrightarrow> \\<exists>y. ?P x y\n 3. \\<And>y. y \\<in> succeed_t i \\<Longrightarrow> \\<exists>x. ?P x y\n 4. \\<And>x y. ?P x y \\<Longrightarrow> x \\<in> succeed i\n 5. \\<And>x y. ?P x y \\<Longrightarrow> y \\<in> succeed_t i\n 6. \\<And>x y. ?P x y \\<Longrightarrow> x \\<le> y", "moreover"], ["proof (state)\nthis:\n  token_run x y \\<notin> F - {q\\<^sub>0}\n  token_run x (Suc y) \\<in> F\n  rank x y = Some i\n\ngoal (6 subgoals):\n 1. \\<And>x y z. \\<lbrakk>?P x y; ?P x z\\<rbrakk> \\<Longrightarrow> y = z\n 2. \\<And>x. x \\<in> succeed i \\<Longrightarrow> \\<exists>y. ?P x y\n 3. \\<And>y. y \\<in> succeed_t i \\<Longrightarrow> \\<exists>x. ?P x y\n 4. \\<And>x y. ?P x y \\<Longrightarrow> x \\<in> succeed i\n 5. \\<And>x y. ?P x y \\<Longrightarrow> y \\<in> succeed_t i\n 6. \\<And>x y. ?P x y \\<Longrightarrow> x \\<le> y", "hence \"rank (senior x y) y = Some i\""], ["proof (prove)\nusing this:\n  token_run x y \\<notin> F - {q\\<^sub>0}\n  token_run x (Suc y) \\<in> F\n  rank x y = Some i\n\ngoal (1 subgoal):\n 1. rank (senior x y) y = Some i", "using rank_Some_time[THEN rank_senior_senior]"], ["proof (prove)\nusing this:\n  token_run x y \\<notin> F - {q\\<^sub>0}\n  token_run x (Suc y) \\<in> F\n  rank x y = Some i\n  rank ?x ?n = Some ?j1 \\<Longrightarrow>\n  rank (senior ?x ?n) ?n = rank ?x ?n\n\ngoal (1 subgoal):\n 1. rank (senior x y) y = Some i", "by presburger"], ["proof (state)\nthis:\n  rank (senior x y) y = Some i\n\ngoal (6 subgoals):\n 1. \\<And>x y z. \\<lbrakk>?P x y; ?P x z\\<rbrakk> \\<Longrightarrow> y = z\n 2. \\<And>x. x \\<in> succeed i \\<Longrightarrow> \\<exists>y. ?P x y\n 3. \\<And>y. y \\<in> succeed_t i \\<Longrightarrow> \\<exists>x. ?P x y\n 4. \\<And>x y. ?P x y \\<Longrightarrow> x \\<in> succeed i\n 5. \\<And>x y. ?P x y \\<Longrightarrow> y \\<in> succeed_t i\n 6. \\<And>x y. ?P x y \\<Longrightarrow> x \\<le> y", "hence \"state_rank (token_run x y) y = Some i\""], ["proof (prove)\nusing this:\n  rank (senior x y) y = Some i\n\ngoal (1 subgoal):\n 1. state_rank (token_run x y) y = Some i", "unfolding state_rank_eq_rank senior.simps"], ["proof (prove)\nusing this:\n  rank (the (oldest_token (token_run x y) y)) y = Some i\n\ngoal (1 subgoal):\n 1. (case oldest_token (token_run x y) y of None \\<Rightarrow> None\n     | Some t \\<Rightarrow> rank t y) =\n    Some i", "by (metis oldest_token_always_def option.sel option.simps(5))"], ["proof (state)\nthis:\n  state_rank (token_run x y) y = Some i\n\ngoal (6 subgoals):\n 1. \\<And>x y z. \\<lbrakk>?P x y; ?P x z\\<rbrakk> \\<Longrightarrow> y = z\n 2. \\<And>x. x \\<in> succeed i \\<Longrightarrow> \\<exists>y. ?P x y\n 3. \\<And>y. y \\<in> succeed_t i \\<Longrightarrow> \\<exists>x. ?P x y\n 4. \\<And>x y. ?P x y \\<Longrightarrow> x \\<in> succeed i\n 5. \\<And>x y. ?P x y \\<Longrightarrow> y \\<in> succeed_t i\n 6. \\<And>x y. ?P x y \\<Longrightarrow> x \\<le> y", "ultimately"], ["proof (chain)\npicking this:\n  token_run x y \\<notin> F - {q\\<^sub>0}\n  token_run x (Suc y) \\<in> F\n  rank x y = Some i\n  state_rank (token_run x y) y = Some i", "show \"\\<exists>y. ?P x y\""], ["proof (prove)\nusing this:\n  token_run x y \\<notin> F - {q\\<^sub>0}\n  token_run x (Suc y) \\<in> F\n  rank x y = Some i\n  state_rank (token_run x y) y = Some i\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<ge>x.\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F", "using rank_Some_time"], ["proof (prove)\nusing this:\n  token_run x y \\<notin> F - {q\\<^sub>0}\n  token_run x (Suc y) \\<in> F\n  rank x y = Some i\n  state_rank (token_run x y) y = Some i\n  rank ?x ?n = Some ?j \\<Longrightarrow> ?x \\<le> ?n\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<ge>x.\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F", "by blast"], ["proof (state)\nthis:\n  \\<exists>y\\<ge>x.\n     state_rank (token_run x y) y = Some i \\<and>\n     token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n     token_run x (Suc y) \\<in> F\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                state_rank (token_run x y) y = Some i \\<and>\n                token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n                token_run x (Suc y) \\<in> F;\n        x \\<le> z \\<and>\n        state_rank (token_run x z) z = Some i \\<and>\n        token_run x z \\<notin> F - {q\\<^sub>0} \\<and>\n        token_run x (Suc z) \\<in> F\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> succeed_t i \\<Longrightarrow>\n       \\<exists>x\\<le>y.\n          state_rank (token_run x y) y = Some i \\<and>\n          token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n          token_run x (Suc y) \\<in> F\n 3. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       x \\<in> succeed i\n 4. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       y \\<in> succeed_t i\n 5. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       x \\<le> y", "}"], ["proof (state)\nthis:\n  ?x2 \\<in> succeed i \\<Longrightarrow>\n  \\<exists>y\\<ge>?x2.\n     state_rank (token_run ?x2 y) y = Some i \\<and>\n     token_run ?x2 y \\<notin> F - {q\\<^sub>0} \\<and>\n     token_run ?x2 (Suc y) \\<in> F\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                state_rank (token_run x y) y = Some i \\<and>\n                token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n                token_run x (Suc y) \\<in> F;\n        x \\<le> z \\<and>\n        state_rank (token_run x z) z = Some i \\<and>\n        token_run x z \\<notin> F - {q\\<^sub>0} \\<and>\n        token_run x (Suc z) \\<in> F\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> succeed_t i \\<Longrightarrow>\n       \\<exists>x\\<le>y.\n          state_rank (token_run x y) y = Some i \\<and>\n          token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n          token_run x (Suc y) \\<in> F\n 3. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       x \\<in> succeed i\n 4. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       y \\<in> succeed_t i\n 5. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       x \\<le> y", "{"], ["proof (state)\nthis:\n  ?x2 \\<in> succeed i \\<Longrightarrow>\n  \\<exists>y\\<ge>?x2.\n     state_rank (token_run ?x2 y) y = Some i \\<and>\n     token_run ?x2 y \\<notin> F - {q\\<^sub>0} \\<and>\n     token_run ?x2 (Suc y) \\<in> F\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                state_rank (token_run x y) y = Some i \\<and>\n                token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n                token_run x (Suc y) \\<in> F;\n        x \\<le> z \\<and>\n        state_rank (token_run x z) z = Some i \\<and>\n        token_run x z \\<notin> F - {q\\<^sub>0} \\<and>\n        token_run x (Suc z) \\<in> F\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> succeed_t i \\<Longrightarrow>\n       \\<exists>x\\<le>y.\n          state_rank (token_run x y) y = Some i \\<and>\n          token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n          token_run x (Suc y) \\<in> F\n 3. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       x \\<in> succeed i\n 4. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       y \\<in> succeed_t i\n 5. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       x \\<le> y", "fix y"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                state_rank (token_run x y) y = Some i \\<and>\n                token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n                token_run x (Suc y) \\<in> F;\n        x \\<le> z \\<and>\n        state_rank (token_run x z) z = Some i \\<and>\n        token_run x z \\<notin> F - {q\\<^sub>0} \\<and>\n        token_run x (Suc z) \\<in> F\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> succeed_t i \\<Longrightarrow>\n       \\<exists>x\\<le>y.\n          state_rank (token_run x y) y = Some i \\<and>\n          token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n          token_run x (Suc y) \\<in> F\n 3. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       x \\<in> succeed i\n 4. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       y \\<in> succeed_t i\n 5. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       x \\<le> y", "assume \"y \\<in> succeed_t i\""], ["proof (state)\nthis:\n  y \\<in> succeed_t i\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                state_rank (token_run x y) y = Some i \\<and>\n                token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n                token_run x (Suc y) \\<in> F;\n        x \\<le> z \\<and>\n        state_rank (token_run x z) z = Some i \\<and>\n        token_run x z \\<notin> F - {q\\<^sub>0} \\<and>\n        token_run x (Suc z) \\<in> F\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> succeed_t i \\<Longrightarrow>\n       \\<exists>x\\<le>y.\n          state_rank (token_run x y) y = Some i \\<and>\n          token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n          token_run x (Suc y) \\<in> F\n 3. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       x \\<in> succeed i\n 4. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       y \\<in> succeed_t i\n 5. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       x \\<le> y", "then"], ["proof (chain)\npicking this:\n  y \\<in> succeed_t i", "obtain q where \"state_rank q y = Some i\" and \"q \\<notin> F - {q\\<^sub>0}\" and \"(\\<delta> q (w y)) \\<in> F\""], ["proof (prove)\nusing this:\n  y \\<in> succeed_t i\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>state_rank q y = Some i; q \\<notin> F - {q\\<^sub>0};\n         \\<delta> q (w y) \\<in> F\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding succeed_t_def"], ["proof (prove)\nusing this:\n  y \\<in> {n. \\<exists>q.\n                 state_rank q n = Some i \\<and>\n                 q \\<notin> F - {q\\<^sub>0} \\<and> \\<delta> q (w n) \\<in> F}\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>state_rank q y = Some i; q \\<notin> F - {q\\<^sub>0};\n         \\<delta> q (w y) \\<in> F\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  state_rank q y = Some i\n  q \\<notin> F - {q\\<^sub>0}\n  \\<delta> q (w y) \\<in> F\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                state_rank (token_run x y) y = Some i \\<and>\n                token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n                token_run x (Suc y) \\<in> F;\n        x \\<le> z \\<and>\n        state_rank (token_run x z) z = Some i \\<and>\n        token_run x z \\<notin> F - {q\\<^sub>0} \\<and>\n        token_run x (Suc z) \\<in> F\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> succeed_t i \\<Longrightarrow>\n       \\<exists>x\\<le>y.\n          state_rank (token_run x y) y = Some i \\<and>\n          token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n          token_run x (Suc y) \\<in> F\n 3. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       x \\<in> succeed i\n 4. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       y \\<in> succeed_t i\n 5. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       x \\<le> y", "moreover"], ["proof (state)\nthis:\n  state_rank q y = Some i\n  q \\<notin> F - {q\\<^sub>0}\n  \\<delta> q (w y) \\<in> F\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                state_rank (token_run x y) y = Some i \\<and>\n                token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n                token_run x (Suc y) \\<in> F;\n        x \\<le> z \\<and>\n        state_rank (token_run x z) z = Some i \\<and>\n        token_run x z \\<notin> F - {q\\<^sub>0} \\<and>\n        token_run x (Suc z) \\<in> F\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> succeed_t i \\<Longrightarrow>\n       \\<exists>x\\<le>y.\n          state_rank (token_run x y) y = Some i \\<and>\n          token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n          token_run x (Suc y) \\<in> F\n 3. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       x \\<in> succeed i\n 4. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       y \\<in> succeed_t i\n 5. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       x \\<le> y", "then"], ["proof (chain)\npicking this:\n  state_rank q y = Some i\n  q \\<notin> F - {q\\<^sub>0}\n  \\<delta> q (w y) \\<in> F", "obtain x where \"q = token_run x y\" and \"x \\<le> y\""], ["proof (prove)\nusing this:\n  state_rank q y = Some i\n  q \\<notin> F - {q\\<^sub>0}\n  \\<delta> q (w y) \\<in> F\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>q = token_run x y; x \\<le> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis oldest_token_bounded push_down_oldest_token_token_run push_down_state_rank_oldest_token)"], ["proof (state)\nthis:\n  q = token_run x y\n  x \\<le> y\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                state_rank (token_run x y) y = Some i \\<and>\n                token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n                token_run x (Suc y) \\<in> F;\n        x \\<le> z \\<and>\n        state_rank (token_run x z) z = Some i \\<and>\n        token_run x z \\<notin> F - {q\\<^sub>0} \\<and>\n        token_run x (Suc z) \\<in> F\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> succeed_t i \\<Longrightarrow>\n       \\<exists>x\\<le>y.\n          state_rank (token_run x y) y = Some i \\<and>\n          token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n          token_run x (Suc y) \\<in> F\n 3. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       x \\<in> succeed i\n 4. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       y \\<in> succeed_t i\n 5. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       x \\<le> y", "moreover"], ["proof (state)\nthis:\n  q = token_run x y\n  x \\<le> y\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                state_rank (token_run x y) y = Some i \\<and>\n                token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n                token_run x (Suc y) \\<in> F;\n        x \\<le> z \\<and>\n        state_rank (token_run x z) z = Some i \\<and>\n        token_run x z \\<notin> F - {q\\<^sub>0} \\<and>\n        token_run x (Suc z) \\<in> F\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> succeed_t i \\<Longrightarrow>\n       \\<exists>x\\<le>y.\n          state_rank (token_run x y) y = Some i \\<and>\n          token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n          token_run x (Suc y) \\<in> F\n 3. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       x \\<in> succeed i\n 4. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       y \\<in> succeed_t i\n 5. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       x \\<le> y", "hence \"token_run x (Suc y) \\<in> F\""], ["proof (prove)\nusing this:\n  q = token_run x y\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. token_run x (Suc y) \\<in> F", "using token_run_step \\<open>(\\<delta> q (w y)) \\<in> F\\<close>"], ["proof (prove)\nusing this:\n  q = token_run x y\n  x \\<le> y\n  \\<lbrakk>?x \\<le> ?n; token_run ?x ?n = ?q';\n   ?q = \\<delta> ?q' (w ?n)\\<rbrakk>\n  \\<Longrightarrow> token_run ?x (Suc ?n) = ?q\n  \\<delta> q (w y) \\<in> F\n\ngoal (1 subgoal):\n 1. token_run x (Suc y) \\<in> F", "by simp"], ["proof (state)\nthis:\n  token_run x (Suc y) \\<in> F\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                state_rank (token_run x y) y = Some i \\<and>\n                token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n                token_run x (Suc y) \\<in> F;\n        x \\<le> z \\<and>\n        state_rank (token_run x z) z = Some i \\<and>\n        token_run x z \\<notin> F - {q\\<^sub>0} \\<and>\n        token_run x (Suc z) \\<in> F\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> succeed_t i \\<Longrightarrow>\n       \\<exists>x\\<le>y.\n          state_rank (token_run x y) y = Some i \\<and>\n          token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n          token_run x (Suc y) \\<in> F\n 3. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       x \\<in> succeed i\n 4. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       y \\<in> succeed_t i\n 5. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       x \\<le> y", "ultimately"], ["proof (chain)\npicking this:\n  state_rank q y = Some i\n  q \\<notin> F - {q\\<^sub>0}\n  \\<delta> q (w y) \\<in> F\n  q = token_run x y\n  x \\<le> y\n  token_run x (Suc y) \\<in> F", "show \"\\<exists>x. ?P x y\""], ["proof (prove)\nusing this:\n  state_rank q y = Some i\n  q \\<notin> F - {q\\<^sub>0}\n  \\<delta> q (w y) \\<in> F\n  q = token_run x y\n  x \\<le> y\n  token_run x (Suc y) \\<in> F\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<le>y.\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F", "by meson"], ["proof (state)\nthis:\n  \\<exists>x\\<le>y.\n     state_rank (token_run x y) y = Some i \\<and>\n     token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n     token_run x (Suc y) \\<in> F\n\ngoal (4 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                state_rank (token_run x y) y = Some i \\<and>\n                token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n                token_run x (Suc y) \\<in> F;\n        x \\<le> z \\<and>\n        state_rank (token_run x z) z = Some i \\<and>\n        token_run x z \\<notin> F - {q\\<^sub>0} \\<and>\n        token_run x (Suc z) \\<in> F\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       x \\<in> succeed i\n 3. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       y \\<in> succeed_t i\n 4. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       x \\<le> y", "}"], ["proof (state)\nthis:\n  ?y2 \\<in> succeed_t i \\<Longrightarrow>\n  \\<exists>x\\<le>?y2.\n     state_rank (token_run x ?y2) ?y2 = Some i \\<and>\n     token_run x ?y2 \\<notin> F - {q\\<^sub>0} \\<and>\n     token_run x (Suc ?y2) \\<in> F\n\ngoal (4 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                state_rank (token_run x y) y = Some i \\<and>\n                token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n                token_run x (Suc y) \\<in> F;\n        x \\<le> z \\<and>\n        state_rank (token_run x z) z = Some i \\<and>\n        token_run x z \\<notin> F - {q\\<^sub>0} \\<and>\n        token_run x (Suc z) \\<in> F\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       x \\<in> succeed i\n 3. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       y \\<in> succeed_t i\n 4. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       x \\<le> y", "{"], ["proof (state)\nthis:\n  ?y2 \\<in> succeed_t i \\<Longrightarrow>\n  \\<exists>x\\<le>?y2.\n     state_rank (token_run x ?y2) ?y2 = Some i \\<and>\n     token_run x ?y2 \\<notin> F - {q\\<^sub>0} \\<and>\n     token_run x (Suc ?y2) \\<in> F\n\ngoal (4 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                state_rank (token_run x y) y = Some i \\<and>\n                token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n                token_run x (Suc y) \\<in> F;\n        x \\<le> z \\<and>\n        state_rank (token_run x z) z = Some i \\<and>\n        token_run x z \\<notin> F - {q\\<^sub>0} \\<and>\n        token_run x (Suc z) \\<in> F\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       x \\<in> succeed i\n 3. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       y \\<in> succeed_t i\n 4. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       x \\<le> y", "fix x y"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                state_rank (token_run x y) y = Some i \\<and>\n                token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n                token_run x (Suc y) \\<in> F;\n        x \\<le> z \\<and>\n        state_rank (token_run x z) z = Some i \\<and>\n        token_run x z \\<notin> F - {q\\<^sub>0} \\<and>\n        token_run x (Suc z) \\<in> F\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       x \\<in> succeed i\n 3. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       y \\<in> succeed_t i\n 4. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       x \\<le> y", "assume \"?P x y\""], ["proof (state)\nthis:\n  x \\<le> y \\<and>\n  state_rank (token_run x y) y = Some i \\<and>\n  token_run x y \\<notin> F - {q\\<^sub>0} \\<and> token_run x (Suc y) \\<in> F\n\ngoal (4 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                state_rank (token_run x y) y = Some i \\<and>\n                token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n                token_run x (Suc y) \\<in> F;\n        x \\<le> z \\<and>\n        state_rank (token_run x z) z = Some i \\<and>\n        token_run x z \\<notin> F - {q\\<^sub>0} \\<and>\n        token_run x (Suc z) \\<in> F\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       x \\<in> succeed i\n 3. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       y \\<in> succeed_t i\n 4. \\<And>x y.\n       x \\<le> y \\<and>\n       state_rank (token_run x y) y = Some i \\<and>\n       token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n       token_run x (Suc y) \\<in> F \\<Longrightarrow>\n       x \\<le> y", "thus \"x \\<le> y\" and \"x \\<in> succeed i\" and \"y \\<in> succeed_t i\""], ["proof (prove)\nusing this:\n  x \\<le> y \\<and>\n  state_rank (token_run x y) y = Some i \\<and>\n  token_run x y \\<notin> F - {q\\<^sub>0} \\<and> token_run x (Suc y) \\<in> F\n\ngoal (1 subgoal):\n 1. x \\<le> y &&& x \\<in> succeed i &&& y \\<in> succeed_t i", "unfolding succeed_def"], ["proof (prove)\nusing this:\n  x \\<le> y \\<and>\n  state_rank (token_run x y) y = Some i \\<and>\n  token_run x y \\<notin> F - {q\\<^sub>0} \\<and> token_run x (Suc y) \\<in> F\n\ngoal (1 subgoal):\n 1. x \\<le> y &&&\n    x \\<in> {x. \\<exists>n.\n                   rank x n = Some i \\<and>\n                   token_run x n \\<notin> F - {q\\<^sub>0} \\<and>\n                   token_run x (Suc n) \\<in> F} &&&\n    y \\<in> succeed_t i", "using rank_eq_state_rank[of x y] succeed_t_inclusion"], ["proof (prove)\nusing this:\n  x \\<le> y \\<and>\n  state_rank (token_run x y) y = Some i \\<and>\n  token_run x y \\<notin> F - {q\\<^sub>0} \\<and> token_run x (Suc y) \\<in> F\n  x \\<le> y \\<Longrightarrow> rank x y = state_rank (token_run x y) y\n  \\<lbrakk>rank ?x ?n = Some ?i; token_run ?x ?n \\<notin> F - {q\\<^sub>0};\n   token_run ?x (Suc ?n) \\<in> F\\<rbrakk>\n  \\<Longrightarrow> ?n \\<in> succeed_t ?i\n\ngoal (1 subgoal):\n 1. x \\<le> y &&&\n    x \\<in> {x. \\<exists>n.\n                   rank x n = Some i \\<and>\n                   token_run x n \\<notin> F - {q\\<^sub>0} \\<and>\n                   token_run x (Suc n) \\<in> F} &&&\n    y \\<in> succeed_t i", "by (metis (mono_tags, lifting) mem_Collect_eq)+"], ["proof (state)\nthis:\n  x \\<le> y\n  x \\<in> succeed i\n  y \\<in> succeed_t i\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                state_rank (token_run x y) y = Some i \\<and>\n                token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n                token_run x (Suc y) \\<in> F;\n        x \\<le> z \\<and>\n        state_rank (token_run x z) z = Some i \\<and>\n        token_run x z \\<notin> F - {q\\<^sub>0} \\<and>\n        token_run x (Suc z) \\<in> F\\<rbrakk>\n       \\<Longrightarrow> y = z", "}\n\n  \\<comment> \\<open>Uniqueness\\<close>"], ["proof (state)\nthis:\n  ?x2 \\<le> ?y2 \\<and>\n  state_rank (token_run ?x2 ?y2) ?y2 = Some i \\<and>\n  token_run ?x2 ?y2 \\<notin> F - {q\\<^sub>0} \\<and>\n  token_run ?x2 (Suc ?y2) \\<in> F \\<Longrightarrow>\n  ?x2 \\<le> ?y2\n  ?x2 \\<le> ?y2 \\<and>\n  state_rank (token_run ?x2 ?y2) ?y2 = Some i \\<and>\n  token_run ?x2 ?y2 \\<notin> F - {q\\<^sub>0} \\<and>\n  token_run ?x2 (Suc ?y2) \\<in> F \\<Longrightarrow>\n  ?x2 \\<in> succeed i\n  ?x2 \\<le> ?y2 \\<and>\n  state_rank (token_run ?x2 ?y2) ?y2 = Some i \\<and>\n  token_run ?x2 ?y2 \\<notin> F - {q\\<^sub>0} \\<and>\n  token_run ?x2 (Suc ?y2) \\<in> F \\<Longrightarrow>\n  ?y2 \\<in> succeed_t i\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                state_rank (token_run x y) y = Some i \\<and>\n                token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n                token_run x (Suc y) \\<in> F;\n        x \\<le> z \\<and>\n        state_rank (token_run x z) z = Some i \\<and>\n        token_run x z \\<notin> F - {q\\<^sub>0} \\<and>\n        token_run x (Suc z) \\<in> F\\<rbrakk>\n       \\<Longrightarrow> y = z", "{"], ["proof (state)\nthis:\n  ?x2 \\<le> ?y2 \\<and>\n  state_rank (token_run ?x2 ?y2) ?y2 = Some i \\<and>\n  token_run ?x2 ?y2 \\<notin> F - {q\\<^sub>0} \\<and>\n  token_run ?x2 (Suc ?y2) \\<in> F \\<Longrightarrow>\n  ?x2 \\<le> ?y2\n  ?x2 \\<le> ?y2 \\<and>\n  state_rank (token_run ?x2 ?y2) ?y2 = Some i \\<and>\n  token_run ?x2 ?y2 \\<notin> F - {q\\<^sub>0} \\<and>\n  token_run ?x2 (Suc ?y2) \\<in> F \\<Longrightarrow>\n  ?x2 \\<in> succeed i\n  ?x2 \\<le> ?y2 \\<and>\n  state_rank (token_run ?x2 ?y2) ?y2 = Some i \\<and>\n  token_run ?x2 ?y2 \\<notin> F - {q\\<^sub>0} \\<and>\n  token_run ?x2 (Suc ?y2) \\<in> F \\<Longrightarrow>\n  ?y2 \\<in> succeed_t i\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                state_rank (token_run x y) y = Some i \\<and>\n                token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n                token_run x (Suc y) \\<in> F;\n        x \\<le> z \\<and>\n        state_rank (token_run x z) z = Some i \\<and>\n        token_run x z \\<notin> F - {q\\<^sub>0} \\<and>\n        token_run x (Suc z) \\<in> F\\<rbrakk>\n       \\<Longrightarrow> y = z", "fix x y z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                state_rank (token_run x y) y = Some i \\<and>\n                token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n                token_run x (Suc y) \\<in> F;\n        x \\<le> z \\<and>\n        state_rank (token_run x z) z = Some i \\<and>\n        token_run x z \\<notin> F - {q\\<^sub>0} \\<and>\n        token_run x (Suc z) \\<in> F\\<rbrakk>\n       \\<Longrightarrow> y = z", "assume \"?P x y\" and \"?P x z\""], ["proof (state)\nthis:\n  x \\<le> y \\<and>\n  state_rank (token_run x y) y = Some i \\<and>\n  token_run x y \\<notin> F - {q\\<^sub>0} \\<and> token_run x (Suc y) \\<in> F\n  x \\<le> z \\<and>\n  state_rank (token_run x z) z = Some i \\<and>\n  token_run x z \\<notin> F - {q\\<^sub>0} \\<and> token_run x (Suc z) \\<in> F\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                state_rank (token_run x y) y = Some i \\<and>\n                token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n                token_run x (Suc y) \\<in> F;\n        x \\<le> z \\<and>\n        state_rank (token_run x z) z = Some i \\<and>\n        token_run x z \\<notin> F - {q\\<^sub>0} \\<and>\n        token_run x (Suc z) \\<in> F\\<rbrakk>\n       \\<Longrightarrow> y = z", "from \\<open>?P x y\\<close>"], ["proof (chain)\npicking this:\n  x \\<le> y \\<and>\n  state_rank (token_run x y) y = Some i \\<and>\n  token_run x y \\<notin> F - {q\\<^sub>0} \\<and> token_run x (Suc y) \\<in> F", "have \"token_run x y \\<notin> F\" and \"token_run x (Suc y) \\<in> F\""], ["proof (prove)\nusing this:\n  x \\<le> y \\<and>\n  state_rank (token_run x y) y = Some i \\<and>\n  token_run x y \\<notin> F - {q\\<^sub>0} \\<and> token_run x (Suc y) \\<in> F\n\ngoal (1 subgoal):\n 1. token_run x y \\<notin> F &&& token_run x (Suc y) \\<in> F", "using \\<open>q\\<^sub>0 \\<notin> F\\<close>"], ["proof (prove)\nusing this:\n  x \\<le> y \\<and>\n  state_rank (token_run x y) y = Some i \\<and>\n  token_run x y \\<notin> F - {q\\<^sub>0} \\<and> token_run x (Suc y) \\<in> F\n  q\\<^sub>0 \\<notin> F\n\ngoal (1 subgoal):\n 1. token_run x y \\<notin> F &&& token_run x (Suc y) \\<in> F", "by auto"], ["proof (state)\nthis:\n  token_run x y \\<notin> F\n  token_run x (Suc y) \\<in> F\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                state_rank (token_run x y) y = Some i \\<and>\n                token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n                token_run x (Suc y) \\<in> F;\n        x \\<le> z \\<and>\n        state_rank (token_run x z) z = Some i \\<and>\n        token_run x z \\<notin> F - {q\\<^sub>0} \\<and>\n        token_run x (Suc z) \\<in> F\\<rbrakk>\n       \\<Longrightarrow> y = z", "moreover"], ["proof (state)\nthis:\n  token_run x y \\<notin> F\n  token_run x (Suc y) \\<in> F\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                state_rank (token_run x y) y = Some i \\<and>\n                token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n                token_run x (Suc y) \\<in> F;\n        x \\<le> z \\<and>\n        state_rank (token_run x z) z = Some i \\<and>\n        token_run x z \\<notin> F - {q\\<^sub>0} \\<and>\n        token_run x (Suc z) \\<in> F\\<rbrakk>\n       \\<Longrightarrow> y = z", "from \\<open>?P x z\\<close>"], ["proof (chain)\npicking this:\n  x \\<le> z \\<and>\n  state_rank (token_run x z) z = Some i \\<and>\n  token_run x z \\<notin> F - {q\\<^sub>0} \\<and> token_run x (Suc z) \\<in> F", "have \"token_run x z \\<notin> F\" and \"token_run x (Suc z) \\<in> F\""], ["proof (prove)\nusing this:\n  x \\<le> z \\<and>\n  state_rank (token_run x z) z = Some i \\<and>\n  token_run x z \\<notin> F - {q\\<^sub>0} \\<and> token_run x (Suc z) \\<in> F\n\ngoal (1 subgoal):\n 1. token_run x z \\<notin> F &&& token_run x (Suc z) \\<in> F", "using \\<open>q\\<^sub>0 \\<notin> F\\<close>"], ["proof (prove)\nusing this:\n  x \\<le> z \\<and>\n  state_rank (token_run x z) z = Some i \\<and>\n  token_run x z \\<notin> F - {q\\<^sub>0} \\<and> token_run x (Suc z) \\<in> F\n  q\\<^sub>0 \\<notin> F\n\ngoal (1 subgoal):\n 1. token_run x z \\<notin> F &&& token_run x (Suc z) \\<in> F", "by auto"], ["proof (state)\nthis:\n  token_run x z \\<notin> F\n  token_run x (Suc z) \\<in> F\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y \\<and>\n                state_rank (token_run x y) y = Some i \\<and>\n                token_run x y \\<notin> F - {q\\<^sub>0} \\<and>\n                token_run x (Suc y) \\<in> F;\n        x \\<le> z \\<and>\n        state_rank (token_run x z) z = Some i \\<and>\n        token_run x z \\<notin> F - {q\\<^sub>0} \\<and>\n        token_run x (Suc z) \\<in> F\\<rbrakk>\n       \\<Longrightarrow> y = z", "ultimately"], ["proof (chain)\npicking this:\n  token_run x y \\<notin> F\n  token_run x (Suc y) \\<in> F\n  token_run x z \\<notin> F\n  token_run x (Suc z) \\<in> F", "show \"y = z\""], ["proof (prove)\nusing this:\n  token_run x y \\<notin> F\n  token_run x (Suc y) \\<in> F\n  token_run x z \\<notin> F\n  token_run x (Suc z) \\<in> F\n\ngoal (1 subgoal):\n 1. y = z", "using token_stays_in_final_states"], ["proof (prove)\nusing this:\n  token_run x y \\<notin> F\n  token_run x (Suc y) \\<in> F\n  token_run x z \\<notin> F\n  token_run x (Suc z) \\<in> F\n  token_run ?x ?n \\<in> F \\<Longrightarrow> token_run ?x (?n + ?m) \\<in> F\n\ngoal (1 subgoal):\n 1. y = z", "by (cases y z rule: linorder_cases, simp_all)\n         (metis le_Suc_ex less_Suc_eq_le not_le)+"], ["proof (state)\nthis:\n  y = z\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?x2 \\<le> ?y2 \\<and>\n           state_rank (token_run ?x2 ?y2) ?y2 = Some i \\<and>\n           token_run ?x2 ?y2 \\<notin> F - {q\\<^sub>0} \\<and>\n           token_run ?x2 (Suc ?y2) \\<in> F;\n   ?x2 \\<le> ?z2 \\<and>\n   state_rank (token_run ?x2 ?z2) ?z2 = Some i \\<and>\n   token_run ?x2 ?z2 \\<notin> F - {q\\<^sub>0} \\<and>\n   token_run ?x2 (Suc ?z2) \\<in> F\\<rbrakk>\n  \\<Longrightarrow> ?y2 = ?z2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma initial_in_F_token_run:\n  assumes \"q\\<^sub>0 \\<in> F\"\n  shows \"token_run x y \\<in> F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. token_run x y \\<in> F", "using assms token_stays_in_final_states[of _ 0]"], ["proof (prove)\nusing this:\n  q\\<^sub>0 \\<in> F\n  token_run ?x 0 \\<in> F \\<Longrightarrow> token_run ?x (0 + ?m) \\<in> F\n\ngoal (1 subgoal):\n 1. token_run x y \\<in> F", "by fastforce"], ["", "lemma finite_succeed_t'':\n  assumes \"q\\<^sub>0 \\<in> F\"\n  shows \"finite (succeed i) = finite (succeed_t i)\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (succeed i) = finite (succeed_t i)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (succeed i) \\<Longrightarrow> finite (succeed_t i)\n 2. finite (succeed_t i) \\<Longrightarrow> finite (succeed i)", "have \"succeed_t i = {n. state_rank q\\<^sub>0 n = Some i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succeed_t i = {n. state_rank q\\<^sub>0 n = Some i}", "unfolding succeed_t_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {n. \\<exists>q.\n           state_rank q n = Some i \\<and>\n           q \\<notin> F - {q\\<^sub>0} \\<and> \\<delta> q (w n) \\<in> F} =\n    {n. state_rank q\\<^sub>0 n = Some i}", "using initial_in_F_token_run assms wellformed_F"], ["proof (prove)\nusing this:\n  q\\<^sub>0 \\<in> F \\<Longrightarrow> token_run ?x ?y \\<in> F\n  q\\<^sub>0 \\<in> F\n  ?q \\<in> F \\<Longrightarrow> \\<delta> ?q ?\\<nu> \\<in> F\n\ngoal (1 subgoal):\n 1. {n. \\<exists>q.\n           state_rank q n = Some i \\<and>\n           q \\<notin> F - {q\\<^sub>0} \\<and> \\<delta> q (w n) \\<in> F} =\n    {n. state_rank q\\<^sub>0 n = Some i}", "by auto"], ["proof (state)\nthis:\n  succeed_t i = {n. state_rank q\\<^sub>0 n = Some i}\n\ngoal (2 subgoals):\n 1. finite (succeed i) \\<Longrightarrow> finite (succeed_t i)\n 2. finite (succeed_t i) \\<Longrightarrow> finite (succeed i)", "also"], ["proof (state)\nthis:\n  succeed_t i = {n. state_rank q\\<^sub>0 n = Some i}\n\ngoal (2 subgoals):\n 1. finite (succeed i) \\<Longrightarrow> finite (succeed_t i)\n 2. finite (succeed_t i) \\<Longrightarrow> finite (succeed i)", "have \"... = {n. rank n n = Some i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {n. state_rank q\\<^sub>0 n = Some i} = {n. rank n n = Some i}", "unfolding rank_eq_state_rank[OF order_refl] token_run_intial_state"], ["proof (prove)\ngoal (1 subgoal):\n 1. {n. state_rank q\\<^sub>0 n = Some i} =\n    {n. state_rank q\\<^sub>0 n = Some i}", ".."], ["proof (state)\nthis:\n  {n. state_rank q\\<^sub>0 n = Some i} = {n. rank n n = Some i}\n\ngoal (2 subgoals):\n 1. finite (succeed i) \\<Longrightarrow> finite (succeed_t i)\n 2. finite (succeed_t i) \\<Longrightarrow> finite (succeed i)", "finally"], ["proof (chain)\npicking this:\n  succeed_t i = {n. rank n n = Some i}", "have succeed_t_alt_def: \"succeed_t i = {n. rank n n = Some i \\<and> token_run n n = q\\<^sub>0}\""], ["proof (prove)\nusing this:\n  succeed_t i = {n. rank n n = Some i}\n\ngoal (1 subgoal):\n 1. succeed_t i = {n. rank n n = Some i \\<and> token_run n n = q\\<^sub>0}", "by simp"], ["proof (state)\nthis:\n  succeed_t i = {n. rank n n = Some i \\<and> token_run n n = q\\<^sub>0}\n\ngoal (2 subgoals):\n 1. finite (succeed i) \\<Longrightarrow> finite (succeed_t i)\n 2. finite (succeed_t i) \\<Longrightarrow> finite (succeed i)", "have succeed_alt_def: \"succeed i = {x. \\<exists>n. rank x n = Some i \\<and> token_run x n = q\\<^sub>0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succeed i =\n    {x. \\<exists>n. rank x n = Some i \\<and> token_run x n = q\\<^sub>0}", "unfolding succeed_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. \\<exists>n.\n           rank x n = Some i \\<and>\n           token_run x n \\<notin> F - {q\\<^sub>0} \\<and>\n           token_run x (Suc n) \\<in> F} =\n    {x. \\<exists>n. rank x n = Some i \\<and> token_run x n = q\\<^sub>0}", "using initial_in_F_token_run[OF assms]"], ["proof (prove)\nusing this:\n  token_run ?x ?y \\<in> F\n\ngoal (1 subgoal):\n 1. {x. \\<exists>n.\n           rank x n = Some i \\<and>\n           token_run x n \\<notin> F - {q\\<^sub>0} \\<and>\n           token_run x (Suc n) \\<in> F} =\n    {x. \\<exists>n. rank x n = Some i \\<and> token_run x n = q\\<^sub>0}", "by auto"], ["proof (state)\nthis:\n  succeed i =\n  {x. \\<exists>n. rank x n = Some i \\<and> token_run x n = q\\<^sub>0}\n\ngoal (2 subgoals):\n 1. finite (succeed i) \\<Longrightarrow> finite (succeed_t i)\n 2. finite (succeed_t i) \\<Longrightarrow> finite (succeed i)", "{"], ["proof (state)\nthis:\n  succeed i =\n  {x. \\<exists>n. rank x n = Some i \\<and> token_run x n = q\\<^sub>0}\n\ngoal (2 subgoals):\n 1. finite (succeed i) \\<Longrightarrow> finite (succeed_t i)\n 2. finite (succeed_t i) \\<Longrightarrow> finite (succeed i)", "assume ?lhs"], ["proof (state)\nthis:\n  finite (succeed i)\n\ngoal (2 subgoals):\n 1. finite (succeed i) \\<Longrightarrow> finite (succeed_t i)\n 2. finite (succeed_t i) \\<Longrightarrow> finite (succeed i)", "moreover"], ["proof (state)\nthis:\n  finite (succeed i)\n\ngoal (2 subgoals):\n 1. finite (succeed i) \\<Longrightarrow> finite (succeed_t i)\n 2. finite (succeed_t i) \\<Longrightarrow> finite (succeed i)", "have \"succeed_t i \\<subseteq> succeed i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succeed_t i \\<subseteq> succeed i", "unfolding succeed_t_alt_def succeed_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {n. rank n n = Some i \\<and> token_run n n = q\\<^sub>0}\n    \\<subseteq> {x. \\<exists>n.\n                       rank x n = Some i \\<and> token_run x n = q\\<^sub>0}", "by blast"], ["proof (state)\nthis:\n  succeed_t i \\<subseteq> succeed i\n\ngoal (2 subgoals):\n 1. finite (succeed i) \\<Longrightarrow> finite (succeed_t i)\n 2. finite (succeed_t i) \\<Longrightarrow> finite (succeed i)", "ultimately"], ["proof (chain)\npicking this:\n  finite (succeed i)\n  succeed_t i \\<subseteq> succeed i", "show ?rhs"], ["proof (prove)\nusing this:\n  finite (succeed i)\n  succeed_t i \\<subseteq> succeed i\n\ngoal (1 subgoal):\n 1. finite (succeed_t i)", "by (rule rev_finite_subset)"], ["proof (state)\nthis:\n  finite (succeed_t i)\n\ngoal (1 subgoal):\n 1. finite (succeed_t i) \\<Longrightarrow> finite (succeed i)", "}"], ["proof (state)\nthis:\n  finite (succeed i) \\<Longrightarrow> finite (succeed_t i)\n\ngoal (1 subgoal):\n 1. finite (succeed_t i) \\<Longrightarrow> finite (succeed i)", "{"], ["proof (state)\nthis:\n  finite (succeed i) \\<Longrightarrow> finite (succeed_t i)\n\ngoal (1 subgoal):\n 1. finite (succeed_t i) \\<Longrightarrow> finite (succeed i)", "assume ?rhs"], ["proof (state)\nthis:\n  finite (succeed_t i)\n\ngoal (1 subgoal):\n 1. finite (succeed_t i) \\<Longrightarrow> finite (succeed i)", "then"], ["proof (chain)\npicking this:\n  finite (succeed_t i)", "obtain U where U_def: \"\\<And>x. x \\<in> succeed_t i \\<Longrightarrow> U \\<ge> x\""], ["proof (prove)\nusing this:\n  finite (succeed_t i)\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (\\<And>x.\n            x \\<in> succeed_t i \\<Longrightarrow>\n            x \\<le> U) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding finite_nat_set_iff_bounded_le"], ["proof (prove)\nusing this:\n  \\<exists>m. \\<forall>n\\<in>succeed_t i. n \\<le> m\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (\\<And>x.\n            x \\<in> succeed_t i \\<Longrightarrow>\n            x \\<le> U) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ?x \\<in> succeed_t i \\<Longrightarrow> ?x \\<le> U\n\ngoal (1 subgoal):\n 1. finite (succeed_t i) \\<Longrightarrow> finite (succeed i)", "{"], ["proof (state)\nthis:\n  ?x \\<in> succeed_t i \\<Longrightarrow> ?x \\<le> U\n\ngoal (1 subgoal):\n 1. finite (succeed_t i) \\<Longrightarrow> finite (succeed i)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (succeed_t i) \\<Longrightarrow> finite (succeed i)", "assume \"x \\<in> succeed i\""], ["proof (state)\nthis:\n  x \\<in> succeed i\n\ngoal (1 subgoal):\n 1. finite (succeed_t i) \\<Longrightarrow> finite (succeed i)", "then"], ["proof (chain)\npicking this:\n  x \\<in> succeed i", "obtain n where \"rank x n = Some i\" and \"token_run x n = q\\<^sub>0\""], ["proof (prove)\nusing this:\n  x \\<in> succeed i\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>rank x n = Some i; token_run x n = q\\<^sub>0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding succeed_alt_def"], ["proof (prove)\nusing this:\n  x \\<in> {x. \\<exists>n.\n                 rank x n = Some i \\<and> token_run x n = q\\<^sub>0}\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>rank x n = Some i; token_run x n = q\\<^sub>0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  rank x n = Some i\n  token_run x n = q\\<^sub>0\n\ngoal (1 subgoal):\n 1. finite (succeed_t i) \\<Longrightarrow> finite (succeed i)", "moreover"], ["proof (state)\nthis:\n  rank x n = Some i\n  token_run x n = q\\<^sub>0\n\ngoal (1 subgoal):\n 1. finite (succeed_t i) \\<Longrightarrow> finite (succeed i)", "hence \"x \\<le> n\""], ["proof (prove)\nusing this:\n  rank x n = Some i\n  token_run x n = q\\<^sub>0\n\ngoal (1 subgoal):\n 1. x \\<le> n", "by (blast dest: rank_Some_time)"], ["proof (state)\nthis:\n  x \\<le> n\n\ngoal (1 subgoal):\n 1. finite (succeed_t i) \\<Longrightarrow> finite (succeed i)", "moreover"], ["proof (state)\nthis:\n  x \\<le> n\n\ngoal (1 subgoal):\n 1. finite (succeed_t i) \\<Longrightarrow> finite (succeed i)", "hence \"rank n n = Some i\""], ["proof (prove)\nusing this:\n  x \\<le> n\n\ngoal (1 subgoal):\n 1. rank n n = Some i", "using \\<open>rank x n = Some i\\<close> \\<open>token_run x n = q\\<^sub>0\\<close>"], ["proof (prove)\nusing this:\n  x \\<le> n\n  rank x n = Some i\n  token_run x n = q\\<^sub>0\n\ngoal (1 subgoal):\n 1. rank n n = Some i", "by (metis order_refl token_run_intial_state[of n] pull_up_token_run_tokens pull_up_configuration_rank)"], ["proof (state)\nthis:\n  rank n n = Some i\n\ngoal (1 subgoal):\n 1. finite (succeed_t i) \\<Longrightarrow> finite (succeed i)", "hence \"n \\<in> succeed_t i\""], ["proof (prove)\nusing this:\n  rank n n = Some i\n\ngoal (1 subgoal):\n 1. n \\<in> succeed_t i", "unfolding succeed_t_alt_def"], ["proof (prove)\nusing this:\n  rank n n = Some i\n\ngoal (1 subgoal):\n 1. n \\<in> {n. rank n n = Some i \\<and> token_run n n = q\\<^sub>0}", "by simp"], ["proof (state)\nthis:\n  n \\<in> succeed_t i\n\ngoal (1 subgoal):\n 1. finite (succeed_t i) \\<Longrightarrow> finite (succeed i)", "ultimately"], ["proof (chain)\npicking this:\n  rank x n = Some i\n  token_run x n = q\\<^sub>0\n  x \\<le> n\n  n \\<in> succeed_t i", "have \"U \\<ge> x\""], ["proof (prove)\nusing this:\n  rank x n = Some i\n  token_run x n = q\\<^sub>0\n  x \\<le> n\n  n \\<in> succeed_t i\n\ngoal (1 subgoal):\n 1. x \\<le> U", "using U_def"], ["proof (prove)\nusing this:\n  rank x n = Some i\n  token_run x n = q\\<^sub>0\n  x \\<le> n\n  n \\<in> succeed_t i\n  ?x \\<in> succeed_t i \\<Longrightarrow> ?x \\<le> U\n\ngoal (1 subgoal):\n 1. x \\<le> U", "by fastforce"], ["proof (state)\nthis:\n  x \\<le> U\n\ngoal (1 subgoal):\n 1. finite (succeed_t i) \\<Longrightarrow> finite (succeed i)", "}"], ["proof (state)\nthis:\n  ?x2 \\<in> succeed i \\<Longrightarrow> ?x2 \\<le> U\n\ngoal (1 subgoal):\n 1. finite (succeed_t i) \\<Longrightarrow> finite (succeed i)", "thus ?lhs"], ["proof (prove)\nusing this:\n  ?x2 \\<in> succeed i \\<Longrightarrow> ?x2 \\<le> U\n\ngoal (1 subgoal):\n 1. finite (succeed i)", "unfolding finite_nat_set_iff_bounded_le"], ["proof (prove)\nusing this:\n  ?x2 \\<in> succeed i \\<Longrightarrow> ?x2 \\<le> U\n\ngoal (1 subgoal):\n 1. \\<exists>m. \\<forall>n\\<in>succeed i. n \\<le> m", "by blast"], ["proof (state)\nthis:\n  finite (succeed i)\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  finite (succeed_t i) \\<Longrightarrow> finite (succeed i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_succeed_t:\n  \"finite (succeed i) = finite (succeed_t i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (succeed i) = finite (succeed_t i)", "using finite_succeed_t' finite_succeed_t''"], ["proof (prove)\nusing this:\n  q\\<^sub>0 \\<notin> F \\<Longrightarrow>\n  finite (succeed ?i) = finite (succeed_t ?i)\n  q\\<^sub>0 \\<in> F \\<Longrightarrow>\n  finite (succeed ?i) = finite (succeed_t ?i)\n\ngoal (1 subgoal):\n 1. finite (succeed i) = finite (succeed_t i)", "by blast"], ["", "lemma finite_merge_t:\n  \"finite (merge i) = finite (merge_t i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (local.merge i) = finite (merge_t i)", "proof (rule token_time_finite_pair_rule)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x y z. \\<lbrakk>?P x y; ?P x z\\<rbrakk> \\<Longrightarrow> y = z\n 2. \\<And>x. x \\<in> local.merge i \\<Longrightarrow> \\<exists>y. ?P x y\n 3. \\<And>y. y \\<in> merge_t i \\<Longrightarrow> \\<exists>x. ?P x y\n 4. \\<And>x y. ?P x y \\<Longrightarrow> x \\<in> local.merge i\n 5. \\<And>x y. ?P x y \\<Longrightarrow> y \\<in> merge_t i\n 6. \\<And>x y.\n       ?P x y \\<Longrightarrow> fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "let ?P = \"(\\<lambda>(x, y) n. \\<exists>j. x \\<le> n\n    \\<and> ((\\<exists>j'. token_run x n \\<noteq> token_run y n \\<and> y \\<le> n \\<and> state_rank (token_run y n) n = Some j') \\<or> y = Suc n)\n    \\<and> token_run x (Suc n) = token_run y (Suc n)\n    \\<and> token_run x (Suc n) \\<notin> F\n    \\<and> state_rank (token_run x n) n = Some j\n    \\<and> j < i)\""], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x y z. \\<lbrakk>?P x y; ?P x z\\<rbrakk> \\<Longrightarrow> y = z\n 2. \\<And>x. x \\<in> local.merge i \\<Longrightarrow> \\<exists>y. ?P x y\n 3. \\<And>y. y \\<in> merge_t i \\<Longrightarrow> \\<exists>x. ?P x y\n 4. \\<And>x y. ?P x y \\<Longrightarrow> x \\<in> local.merge i\n 5. \\<And>x y. ?P x y \\<Longrightarrow> y \\<in> merge_t i\n 6. \\<And>x y.\n       ?P x y \\<Longrightarrow> fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "{"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x y z. \\<lbrakk>?P x y; ?P x z\\<rbrakk> \\<Longrightarrow> y = z\n 2. \\<And>x. x \\<in> local.merge i \\<Longrightarrow> \\<exists>y. ?P x y\n 3. \\<And>y. y \\<in> merge_t i \\<Longrightarrow> \\<exists>x. ?P x y\n 4. \\<And>x y. ?P x y \\<Longrightarrow> x \\<in> local.merge i\n 5. \\<And>x y. ?P x y \\<Longrightarrow> y \\<in> merge_t i\n 6. \\<And>x y.\n       ?P x y \\<Longrightarrow> fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "fix x"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x y z. \\<lbrakk>?P x y; ?P x z\\<rbrakk> \\<Longrightarrow> y = z\n 2. \\<And>x. x \\<in> local.merge i \\<Longrightarrow> \\<exists>y. ?P x y\n 3. \\<And>y. y \\<in> merge_t i \\<Longrightarrow> \\<exists>x. ?P x y\n 4. \\<And>x y. ?P x y \\<Longrightarrow> x \\<in> local.merge i\n 5. \\<And>x y. ?P x y \\<Longrightarrow> y \\<in> merge_t i\n 6. \\<And>x y.\n       ?P x y \\<Longrightarrow> fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "assume \"x \\<in> merge i\""], ["proof (state)\nthis:\n  x \\<in> local.merge i\n\ngoal (6 subgoals):\n 1. \\<And>x y z. \\<lbrakk>?P x y; ?P x z\\<rbrakk> \\<Longrightarrow> y = z\n 2. \\<And>x. x \\<in> local.merge i \\<Longrightarrow> \\<exists>y. ?P x y\n 3. \\<And>y. y \\<in> merge_t i \\<Longrightarrow> \\<exists>x. ?P x y\n 4. \\<And>x y. ?P x y \\<Longrightarrow> x \\<in> local.merge i\n 5. \\<And>x y. ?P x y \\<Longrightarrow> y \\<in> merge_t i\n 6. \\<And>x y.\n       ?P x y \\<Longrightarrow> fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "then"], ["proof (chain)\npicking this:\n  x \\<in> local.merge i", "obtain t t' n j where 1: \"x = (t, t')\"\n      and 3: \"(\\<exists>j'. token_run t n \\<noteq> token_run t' n \\<and> rank t' n = Some j') \\<or>  t' = Suc n\"\n      and 4: \"token_run t (Suc n) = token_run t' (Suc n)\"\n      and 5: \"token_run t (Suc n) \\<notin> F\"\n      and 6: \"rank t n = Some j\"\n      and 7:  \"j < i\""], ["proof (prove)\nusing this:\n  x \\<in> local.merge i\n\ngoal (1 subgoal):\n 1. (\\<And>t t' n j.\n        \\<lbrakk>x = (t, t');\n         (\\<exists>j'.\n             token_run t n \\<noteq> token_run t' n \\<and>\n             rank t' n = Some j') \\<or>\n         t' = Suc n;\n         token_run t (Suc n) = token_run t' (Suc n);\n         token_run t (Suc n) \\<notin> F; rank t n = Some j; j < i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding merge_def"], ["proof (prove)\nusing this:\n  x \\<in> {uu_.\n           \\<exists>x y n j.\n              uu_ = (x, y) \\<and>\n              j < i \\<and>\n              (token_run x n \\<noteq> token_run y n \\<and>\n               rank y n \\<noteq> None \\<or>\n               y = Suc n) \\<and>\n              token_run x (Suc n) = token_run y (Suc n) \\<and>\n              token_run x (Suc n) \\<notin> F \\<and> rank x n = Some j}\n\ngoal (1 subgoal):\n 1. (\\<And>t t' n j.\n        \\<lbrakk>x = (t, t');\n         (\\<exists>j'.\n             token_run t n \\<noteq> token_run t' n \\<and>\n             rank t' n = Some j') \\<or>\n         t' = Suc n;\n         token_run t (Suc n) = token_run t' (Suc n);\n         token_run t (Suc n) \\<notin> F; rank t n = Some j; j < i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x = (t, t')\n  (\\<exists>j'.\n      token_run t n \\<noteq> token_run t' n \\<and>\n      rank t' n = Some j') \\<or>\n  t' = Suc n\n  token_run t (Suc n) = token_run t' (Suc n)\n  token_run t (Suc n) \\<notin> F\n  rank t n = Some j\n  j < i\n\ngoal (6 subgoals):\n 1. \\<And>x y z. \\<lbrakk>?P x y; ?P x z\\<rbrakk> \\<Longrightarrow> y = z\n 2. \\<And>x. x \\<in> local.merge i \\<Longrightarrow> \\<exists>y. ?P x y\n 3. \\<And>y. y \\<in> merge_t i \\<Longrightarrow> \\<exists>x. ?P x y\n 4. \\<And>x y. ?P x y \\<Longrightarrow> x \\<in> local.merge i\n 5. \\<And>x y. ?P x y \\<Longrightarrow> y \\<in> merge_t i\n 6. \\<And>x y.\n       ?P x y \\<Longrightarrow> fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "moreover"], ["proof (state)\nthis:\n  x = (t, t')\n  (\\<exists>j'.\n      token_run t n \\<noteq> token_run t' n \\<and>\n      rank t' n = Some j') \\<or>\n  t' = Suc n\n  token_run t (Suc n) = token_run t' (Suc n)\n  token_run t (Suc n) \\<notin> F\n  rank t n = Some j\n  j < i\n\ngoal (6 subgoals):\n 1. \\<And>x y z. \\<lbrakk>?P x y; ?P x z\\<rbrakk> \\<Longrightarrow> y = z\n 2. \\<And>x. x \\<in> local.merge i \\<Longrightarrow> \\<exists>y. ?P x y\n 3. \\<And>y. y \\<in> merge_t i \\<Longrightarrow> \\<exists>x. ?P x y\n 4. \\<And>x y. ?P x y \\<Longrightarrow> x \\<in> local.merge i\n 5. \\<And>x y. ?P x y \\<Longrightarrow> y \\<in> merge_t i\n 6. \\<And>x y.\n       ?P x y \\<Longrightarrow> fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "hence 8: \"t \\<le> n\" and 9: \"t' \\<le> Suc n\""], ["proof (prove)\nusing this:\n  x = (t, t')\n  (\\<exists>j'.\n      token_run t n \\<noteq> token_run t' n \\<and>\n      rank t' n = Some j') \\<or>\n  t' = Suc n\n  token_run t (Suc n) = token_run t' (Suc n)\n  token_run t (Suc n) \\<notin> F\n  rank t n = Some j\n  j < i\n\ngoal (1 subgoal):\n 1. t \\<le> n &&& t' \\<le> Suc n", "using rank_Some_time le_Suc_eq"], ["proof (prove)\nusing this:\n  x = (t, t')\n  (\\<exists>j'.\n      token_run t n \\<noteq> token_run t' n \\<and>\n      rank t' n = Some j') \\<or>\n  t' = Suc n\n  token_run t (Suc n) = token_run t' (Suc n)\n  token_run t (Suc n) \\<notin> F\n  rank t n = Some j\n  j < i\n  rank ?x ?n = Some ?j \\<Longrightarrow> ?x \\<le> ?n\n  (?m \\<le> Suc ?n) = (?m \\<le> ?n \\<or> ?m = Suc ?n)\n\ngoal (1 subgoal):\n 1. t \\<le> n &&& t' \\<le> Suc n", "by blast+"], ["proof (state)\nthis:\n  t \\<le> n\n  t' \\<le> Suc n\n\ngoal (6 subgoals):\n 1. \\<And>x y z. \\<lbrakk>?P x y; ?P x z\\<rbrakk> \\<Longrightarrow> y = z\n 2. \\<And>x. x \\<in> local.merge i \\<Longrightarrow> \\<exists>y. ?P x y\n 3. \\<And>y. y \\<in> merge_t i \\<Longrightarrow> \\<exists>x. ?P x y\n 4. \\<And>x y. ?P x y \\<Longrightarrow> x \\<in> local.merge i\n 5. \\<And>x y. ?P x y \\<Longrightarrow> y \\<in> merge_t i\n 6. \\<And>x y.\n       ?P x y \\<Longrightarrow> fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "moreover"], ["proof (state)\nthis:\n  t \\<le> n\n  t' \\<le> Suc n\n\ngoal (6 subgoals):\n 1. \\<And>x y z. \\<lbrakk>?P x y; ?P x z\\<rbrakk> \\<Longrightarrow> y = z\n 2. \\<And>x. x \\<in> local.merge i \\<Longrightarrow> \\<exists>y. ?P x y\n 3. \\<And>y. y \\<in> merge_t i \\<Longrightarrow> \\<exists>x. ?P x y\n 4. \\<And>x y. ?P x y \\<Longrightarrow> x \\<in> local.merge i\n 5. \\<And>x y. ?P x y \\<Longrightarrow> y \\<in> merge_t i\n 6. \\<And>x y.\n       ?P x y \\<Longrightarrow> fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "hence 10: \"state_rank (token_run t n) n = Some j\""], ["proof (prove)\nusing this:\n  t \\<le> n\n  t' \\<le> Suc n\n\ngoal (1 subgoal):\n 1. state_rank (token_run t n) n = Some j", "using \\<open>rank t n = Some j\\<close> rank_eq_state_rank"], ["proof (prove)\nusing this:\n  t \\<le> n\n  t' \\<le> Suc n\n  rank t n = Some j\n  ?x \\<le> ?n \\<Longrightarrow> rank ?x ?n = state_rank (token_run ?x ?n) ?n\n\ngoal (1 subgoal):\n 1. state_rank (token_run t n) n = Some j", "by metis"], ["proof (state)\nthis:\n  state_rank (token_run t n) n = Some j\n\ngoal (6 subgoals):\n 1. \\<And>x y z. \\<lbrakk>?P x y; ?P x z\\<rbrakk> \\<Longrightarrow> y = z\n 2. \\<And>x. x \\<in> local.merge i \\<Longrightarrow> \\<exists>y. ?P x y\n 3. \\<And>y. y \\<in> merge_t i \\<Longrightarrow> \\<exists>x. ?P x y\n 4. \\<And>x y. ?P x y \\<Longrightarrow> x \\<in> local.merge i\n 5. \\<And>x y. ?P x y \\<Longrightarrow> y \\<in> merge_t i\n 6. \\<And>x y.\n       ?P x y \\<Longrightarrow> fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "ultimately"], ["proof (chain)\npicking this:\n  x = (t, t')\n  (\\<exists>j'.\n      token_run t n \\<noteq> token_run t' n \\<and>\n      rank t' n = Some j') \\<or>\n  t' = Suc n\n  token_run t (Suc n) = token_run t' (Suc n)\n  token_run t (Suc n) \\<notin> F\n  rank t n = Some j\n  j < i\n  t \\<le> n\n  t' \\<le> Suc n\n  state_rank (token_run t n) n = Some j", "show \"\\<exists>y. ?P x y\""], ["proof (prove)\nusing this:\n  x = (t, t')\n  (\\<exists>j'.\n      token_run t n \\<noteq> token_run t' n \\<and>\n      rank t' n = Some j') \\<or>\n  t' = Suc n\n  token_run t (Suc n) = token_run t' (Suc n)\n  token_run t (Suc n) \\<notin> F\n  rank t n = Some j\n  j < i\n  t \\<le> n\n  t' \\<le> Suc n\n  state_rank (token_run t n) n = Some j\n\ngoal (1 subgoal):\n 1. \\<exists>y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y", "proof (cases \"t' = Suc n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x = (t, t');\n     (\\<exists>j'.\n         token_run t n \\<noteq> token_run t' n \\<and>\n         rank t' n = Some j') \\<or>\n     t' = Suc n;\n     token_run t (Suc n) = token_run t' (Suc n);\n     token_run t (Suc n) \\<notin> F; rank t n = Some j; j < i; t \\<le> n;\n     t' \\<le> Suc n; state_rank (token_run t n) n = Some j;\n     t' = Suc n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y.\n                         (case x of\n                          (x, y) \\<Rightarrow>\n                            \\<lambda>n.\n                               \\<exists>j.\n                                  x \\<le> n \\<and>\n                                  ((\\<exists>j'.\n token_run x n \\<noteq> token_run y n \\<and>\n y \\<le> n \\<and> state_rank (token_run y n) n = Some j') \\<or>\n                                   y = Suc n) \\<and>\n                                  token_run x (Suc n) =\n                                  token_run y (Suc n) \\<and>\n                                  token_run x (Suc n) \\<notin> F \\<and>\n                                  state_rank (token_run x n) n =\n                                  Some j \\<and>\n                                  j < i)\n                          y\n 2. \\<lbrakk>x = (t, t');\n     (\\<exists>j'.\n         token_run t n \\<noteq> token_run t' n \\<and>\n         rank t' n = Some j') \\<or>\n     t' = Suc n;\n     token_run t (Suc n) = token_run t' (Suc n);\n     token_run t (Suc n) \\<notin> F; rank t n = Some j; j < i; t \\<le> n;\n     t' \\<le> Suc n; state_rank (token_run t n) n = Some j;\n     t' \\<noteq> Suc n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y.\n                         (case x of\n                          (x, y) \\<Rightarrow>\n                            \\<lambda>n.\n                               \\<exists>j.\n                                  x \\<le> n \\<and>\n                                  ((\\<exists>j'.\n token_run x n \\<noteq> token_run y n \\<and>\n y \\<le> n \\<and> state_rank (token_run y n) n = Some j') \\<or>\n                                   y = Suc n) \\<and>\n                                  token_run x (Suc n) =\n                                  token_run y (Suc n) \\<and>\n                                  token_run x (Suc n) \\<notin> F \\<and>\n                                  state_rank (token_run x n) n =\n                                  Some j \\<and>\n                                  j < i)\n                          y", "case False"], ["proof (state)\nthis:\n  t' \\<noteq> Suc n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x = (t, t');\n     (\\<exists>j'.\n         token_run t n \\<noteq> token_run t' n \\<and>\n         rank t' n = Some j') \\<or>\n     t' = Suc n;\n     token_run t (Suc n) = token_run t' (Suc n);\n     token_run t (Suc n) \\<notin> F; rank t n = Some j; j < i; t \\<le> n;\n     t' \\<le> Suc n; state_rank (token_run t n) n = Some j;\n     t' = Suc n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y.\n                         (case x of\n                          (x, y) \\<Rightarrow>\n                            \\<lambda>n.\n                               \\<exists>j.\n                                  x \\<le> n \\<and>\n                                  ((\\<exists>j'.\n token_run x n \\<noteq> token_run y n \\<and>\n y \\<le> n \\<and> state_rank (token_run y n) n = Some j') \\<or>\n                                   y = Suc n) \\<and>\n                                  token_run x (Suc n) =\n                                  token_run y (Suc n) \\<and>\n                                  token_run x (Suc n) \\<notin> F \\<and>\n                                  state_rank (token_run x n) n =\n                                  Some j \\<and>\n                                  j < i)\n                          y\n 2. \\<lbrakk>x = (t, t');\n     (\\<exists>j'.\n         token_run t n \\<noteq> token_run t' n \\<and>\n         rank t' n = Some j') \\<or>\n     t' = Suc n;\n     token_run t (Suc n) = token_run t' (Suc n);\n     token_run t (Suc n) \\<notin> F; rank t n = Some j; j < i; t \\<le> n;\n     t' \\<le> Suc n; state_rank (token_run t n) n = Some j;\n     t' \\<noteq> Suc n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y.\n                         (case x of\n                          (x, y) \\<Rightarrow>\n                            \\<lambda>n.\n                               \\<exists>j.\n                                  x \\<le> n \\<and>\n                                  ((\\<exists>j'.\n token_run x n \\<noteq> token_run y n \\<and>\n y \\<le> n \\<and> state_rank (token_run y n) n = Some j') \\<or>\n                                   y = Suc n) \\<and>\n                                  token_run x (Suc n) =\n                                  token_run y (Suc n) \\<and>\n                                  token_run x (Suc n) \\<notin> F \\<and>\n                                  state_rank (token_run x n) n =\n                                  Some j \\<and>\n                                  j < i)\n                          y", "hence \"t' \\<le> n\""], ["proof (prove)\nusing this:\n  t' \\<noteq> Suc n\n\ngoal (1 subgoal):\n 1. t' \\<le> n", "using \\<open>t' \\<le> Suc n\\<close>"], ["proof (prove)\nusing this:\n  t' \\<noteq> Suc n\n  t' \\<le> Suc n\n\ngoal (1 subgoal):\n 1. t' \\<le> n", "by simp"], ["proof (state)\nthis:\n  t' \\<le> n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x = (t, t');\n     (\\<exists>j'.\n         token_run t n \\<noteq> token_run t' n \\<and>\n         rank t' n = Some j') \\<or>\n     t' = Suc n;\n     token_run t (Suc n) = token_run t' (Suc n);\n     token_run t (Suc n) \\<notin> F; rank t n = Some j; j < i; t \\<le> n;\n     t' \\<le> Suc n; state_rank (token_run t n) n = Some j;\n     t' = Suc n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y.\n                         (case x of\n                          (x, y) \\<Rightarrow>\n                            \\<lambda>n.\n                               \\<exists>j.\n                                  x \\<le> n \\<and>\n                                  ((\\<exists>j'.\n token_run x n \\<noteq> token_run y n \\<and>\n y \\<le> n \\<and> state_rank (token_run y n) n = Some j') \\<or>\n                                   y = Suc n) \\<and>\n                                  token_run x (Suc n) =\n                                  token_run y (Suc n) \\<and>\n                                  token_run x (Suc n) \\<notin> F \\<and>\n                                  state_rank (token_run x n) n =\n                                  Some j \\<and>\n                                  j < i)\n                          y\n 2. \\<lbrakk>x = (t, t');\n     (\\<exists>j'.\n         token_run t n \\<noteq> token_run t' n \\<and>\n         rank t' n = Some j') \\<or>\n     t' = Suc n;\n     token_run t (Suc n) = token_run t' (Suc n);\n     token_run t (Suc n) \\<notin> F; rank t n = Some j; j < i; t \\<le> n;\n     t' \\<le> Suc n; state_rank (token_run t n) n = Some j;\n     t' \\<noteq> Suc n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y.\n                         (case x of\n                          (x, y) \\<Rightarrow>\n                            \\<lambda>n.\n                               \\<exists>j.\n                                  x \\<le> n \\<and>\n                                  ((\\<exists>j'.\n token_run x n \\<noteq> token_run y n \\<and>\n y \\<le> n \\<and> state_rank (token_run y n) n = Some j') \\<or>\n                                   y = Suc n) \\<and>\n                                  token_run x (Suc n) =\n                                  token_run y (Suc n) \\<and>\n                                  token_run x (Suc n) \\<notin> F \\<and>\n                                  state_rank (token_run x n) n =\n                                  Some j \\<and>\n                                  j < i)\n                          y", "with 1 3 4 5 7 8 10"], ["proof (chain)\npicking this:\n  x = (t, t')\n  (\\<exists>j'.\n      token_run t n \\<noteq> token_run t' n \\<and>\n      rank t' n = Some j') \\<or>\n  t' = Suc n\n  token_run t (Suc n) = token_run t' (Suc n)\n  token_run t (Suc n) \\<notin> F\n  j < i\n  t \\<le> n\n  state_rank (token_run t n) n = Some j\n  t' \\<le> n", "show ?thesis"], ["proof (prove)\nusing this:\n  x = (t, t')\n  (\\<exists>j'.\n      token_run t n \\<noteq> token_run t' n \\<and>\n      rank t' n = Some j') \\<or>\n  t' = Suc n\n  token_run t (Suc n) = token_run t' (Suc n)\n  token_run t (Suc n) \\<notin> F\n  j < i\n  t \\<le> n\n  state_rank (token_run t n) n = Some j\n  t' \\<le> n\n\ngoal (1 subgoal):\n 1. \\<exists>y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y", "unfolding rank_eq_state_rank[OF \\<open>t' \\<le> n\\<close>]"], ["proof (prove)\nusing this:\n  x = (t, t')\n  (\\<exists>j'.\n      token_run t n \\<noteq> token_run t' n \\<and>\n      state_rank (token_run t' n) n = Some j') \\<or>\n  t' = Suc n\n  token_run t (Suc n) = token_run t' (Suc n)\n  token_run t (Suc n) \\<notin> F\n  j < i\n  t \\<le> n\n  state_rank (token_run t n) n = Some j\n  t' \\<le> n\n\ngoal (1 subgoal):\n 1. \\<exists>y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y", "by blast"], ["proof (state)\nthis:\n  \\<exists>y.\n     (case x of\n      (x, y) \\<Rightarrow>\n        \\<lambda>n.\n           \\<exists>j.\n              x \\<le> n \\<and>\n              ((\\<exists>j'.\n                   token_run x n \\<noteq> token_run y n \\<and>\n                   y \\<le> n \\<and>\n                   state_rank (token_run y n) n = Some j') \\<or>\n               y = Suc n) \\<and>\n              token_run x (Suc n) = token_run y (Suc n) \\<and>\n              token_run x (Suc n) \\<notin> F \\<and>\n              state_rank (token_run x n) n = Some j \\<and> j < i)\n      y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (t, t');\n     (\\<exists>j'.\n         token_run t n \\<noteq> token_run t' n \\<and>\n         rank t' n = Some j') \\<or>\n     t' = Suc n;\n     token_run t (Suc n) = token_run t' (Suc n);\n     token_run t (Suc n) \\<notin> F; rank t n = Some j; j < i; t \\<le> n;\n     t' \\<le> Suc n; state_rank (token_run t n) n = Some j;\n     t' = Suc n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y.\n                         (case x of\n                          (x, y) \\<Rightarrow>\n                            \\<lambda>n.\n                               \\<exists>j.\n                                  x \\<le> n \\<and>\n                                  ((\\<exists>j'.\n token_run x n \\<noteq> token_run y n \\<and>\n y \\<le> n \\<and> state_rank (token_run y n) n = Some j') \\<or>\n                                   y = Suc n) \\<and>\n                                  token_run x (Suc n) =\n                                  token_run y (Suc n) \\<and>\n                                  token_run x (Suc n) \\<notin> F \\<and>\n                                  state_rank (token_run x n) n =\n                                  Some j \\<and>\n                                  j < i)\n                          y", "qed blast"], ["proof (state)\nthis:\n  \\<exists>y.\n     (case x of\n      (x, y) \\<Rightarrow>\n        \\<lambda>n.\n           \\<exists>j.\n              x \\<le> n \\<and>\n              ((\\<exists>j'.\n                   token_run x n \\<noteq> token_run y n \\<and>\n                   y \\<le> n \\<and>\n                   state_rank (token_run y n) n = Some j') \\<or>\n               y = Suc n) \\<and>\n              token_run x (Suc n) = token_run y (Suc n) \\<and>\n              token_run x (Suc n) \\<notin> F \\<and>\n              state_rank (token_run x n) n = Some j \\<and> j < i)\n      y\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> merge_t i \\<Longrightarrow>\n       \\<exists>x.\n          (case x of\n           (x, y) \\<Rightarrow>\n             \\<lambda>n.\n                \\<exists>j.\n                   x \\<le> n \\<and>\n                   ((\\<exists>j'.\n                        token_run x n \\<noteq> token_run y n \\<and>\n                        y \\<le> n \\<and>\n                        state_rank (token_run y n) n = Some j') \\<or>\n                    y = Suc n) \\<and>\n                   token_run x (Suc n) = token_run y (Suc n) \\<and>\n                   token_run x (Suc n) \\<notin> F \\<and>\n                   state_rank (token_run x n) n = Some j \\<and> j < i)\n           y\n 3. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       x \\<in> local.merge i\n 4. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       y \\<in> merge_t i\n 5. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "}"], ["proof (state)\nthis:\n  ?x2 \\<in> local.merge i \\<Longrightarrow>\n  \\<exists>y.\n     (case ?x2 of\n      (x, y) \\<Rightarrow>\n        \\<lambda>n.\n           \\<exists>j.\n              x \\<le> n \\<and>\n              ((\\<exists>j'.\n                   token_run x n \\<noteq> token_run y n \\<and>\n                   y \\<le> n \\<and>\n                   state_rank (token_run y n) n = Some j') \\<or>\n               y = Suc n) \\<and>\n              token_run x (Suc n) = token_run y (Suc n) \\<and>\n              token_run x (Suc n) \\<notin> F \\<and>\n              state_rank (token_run x n) n = Some j \\<and> j < i)\n      y\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> merge_t i \\<Longrightarrow>\n       \\<exists>x.\n          (case x of\n           (x, y) \\<Rightarrow>\n             \\<lambda>n.\n                \\<exists>j.\n                   x \\<le> n \\<and>\n                   ((\\<exists>j'.\n                        token_run x n \\<noteq> token_run y n \\<and>\n                        y \\<le> n \\<and>\n                        state_rank (token_run y n) n = Some j') \\<or>\n                    y = Suc n) \\<and>\n                   token_run x (Suc n) = token_run y (Suc n) \\<and>\n                   token_run x (Suc n) \\<notin> F \\<and>\n                   state_rank (token_run x n) n = Some j \\<and> j < i)\n           y\n 3. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       x \\<in> local.merge i\n 4. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       y \\<in> merge_t i\n 5. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "{"], ["proof (state)\nthis:\n  ?x2 \\<in> local.merge i \\<Longrightarrow>\n  \\<exists>y.\n     (case ?x2 of\n      (x, y) \\<Rightarrow>\n        \\<lambda>n.\n           \\<exists>j.\n              x \\<le> n \\<and>\n              ((\\<exists>j'.\n                   token_run x n \\<noteq> token_run y n \\<and>\n                   y \\<le> n \\<and>\n                   state_rank (token_run y n) n = Some j') \\<or>\n               y = Suc n) \\<and>\n              token_run x (Suc n) = token_run y (Suc n) \\<and>\n              token_run x (Suc n) \\<notin> F \\<and>\n              state_rank (token_run x n) n = Some j \\<and> j < i)\n      y\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> merge_t i \\<Longrightarrow>\n       \\<exists>x.\n          (case x of\n           (x, y) \\<Rightarrow>\n             \\<lambda>n.\n                \\<exists>j.\n                   x \\<le> n \\<and>\n                   ((\\<exists>j'.\n                        token_run x n \\<noteq> token_run y n \\<and>\n                        y \\<le> n \\<and>\n                        state_rank (token_run y n) n = Some j') \\<or>\n                    y = Suc n) \\<and>\n                   token_run x (Suc n) = token_run y (Suc n) \\<and>\n                   token_run x (Suc n) \\<notin> F \\<and>\n                   state_rank (token_run x n) n = Some j \\<and> j < i)\n           y\n 3. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       x \\<in> local.merge i\n 4. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       y \\<in> merge_t i\n 5. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "fix y"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> merge_t i \\<Longrightarrow>\n       \\<exists>x.\n          (case x of\n           (x, y) \\<Rightarrow>\n             \\<lambda>n.\n                \\<exists>j.\n                   x \\<le> n \\<and>\n                   ((\\<exists>j'.\n                        token_run x n \\<noteq> token_run y n \\<and>\n                        y \\<le> n \\<and>\n                        state_rank (token_run y n) n = Some j') \\<or>\n                    y = Suc n) \\<and>\n                   token_run x (Suc n) = token_run y (Suc n) \\<and>\n                   token_run x (Suc n) \\<notin> F \\<and>\n                   state_rank (token_run x n) n = Some j \\<and> j < i)\n           y\n 3. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       x \\<in> local.merge i\n 4. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       y \\<in> merge_t i\n 5. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "assume \"y \\<in> merge_t i\""], ["proof (state)\nthis:\n  y \\<in> merge_t i\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> merge_t i \\<Longrightarrow>\n       \\<exists>x.\n          (case x of\n           (x, y) \\<Rightarrow>\n             \\<lambda>n.\n                \\<exists>j.\n                   x \\<le> n \\<and>\n                   ((\\<exists>j'.\n                        token_run x n \\<noteq> token_run y n \\<and>\n                        y \\<le> n \\<and>\n                        state_rank (token_run y n) n = Some j') \\<or>\n                    y = Suc n) \\<and>\n                   token_run x (Suc n) = token_run y (Suc n) \\<and>\n                   token_run x (Suc n) \\<notin> F \\<and>\n                   state_rank (token_run x n) n = Some j \\<and> j < i)\n           y\n 3. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       x \\<in> local.merge i\n 4. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       y \\<in> merge_t i\n 5. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "then"], ["proof (chain)\npicking this:\n  y \\<in> merge_t i", "obtain q q' j where 1: \"state_rank q y = Some j\"\n      and 2: \"j < i\"\n      and 3: \"q' = \\<delta> q (w y)\"\n      and 4: \"q' \\<notin> F\"\n      and 5: \"(\\<exists>q''. q' = \\<delta> q'' (w y) \\<and> state_rank q'' y \\<noteq> None \\<and> q'' \\<noteq> q) \\<or> q' = q\\<^sub>0\""], ["proof (prove)\nusing this:\n  y \\<in> merge_t i\n\ngoal (1 subgoal):\n 1. (\\<And>q j q'.\n        \\<lbrakk>state_rank q y = Some j; j < i; q' = \\<delta> q (w y);\n         q' \\<notin> F;\n         (\\<exists>q''.\n             q' = \\<delta> q'' (w y) \\<and>\n             state_rank q'' y \\<noteq> None \\<and> q'' \\<noteq> q) \\<or>\n         q' = q\\<^sub>0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding merge_t_def"], ["proof (prove)\nusing this:\n  y \\<in> {n. \\<exists>q q' j.\n                 state_rank q n = Some j \\<and>\n                 j < i \\<and>\n                 q' = \\<delta> q (w n) \\<and>\n                 q' \\<notin> F \\<and>\n                 ((\\<exists>q''.\n                      q'' \\<noteq> q \\<and>\n                      q' = \\<delta> q'' (w n) \\<and>\n                      state_rank q'' n \\<noteq> None) \\<or>\n                  q' = q\\<^sub>0)}\n\ngoal (1 subgoal):\n 1. (\\<And>q j q'.\n        \\<lbrakk>state_rank q y = Some j; j < i; q' = \\<delta> q (w y);\n         q' \\<notin> F;\n         (\\<exists>q''.\n             q' = \\<delta> q'' (w y) \\<and>\n             state_rank q'' y \\<noteq> None \\<and> q'' \\<noteq> q) \\<or>\n         q' = q\\<^sub>0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  state_rank q y = Some j\n  j < i\n  q' = \\<delta> q (w y)\n  q' \\<notin> F\n  (\\<exists>q''.\n      q' = \\<delta> q'' (w y) \\<and>\n      state_rank q'' y \\<noteq> None \\<and> q'' \\<noteq> q) \\<or>\n  q' = q\\<^sub>0\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> merge_t i \\<Longrightarrow>\n       \\<exists>x.\n          (case x of\n           (x, y) \\<Rightarrow>\n             \\<lambda>n.\n                \\<exists>j.\n                   x \\<le> n \\<and>\n                   ((\\<exists>j'.\n                        token_run x n \\<noteq> token_run y n \\<and>\n                        y \\<le> n \\<and>\n                        state_rank (token_run y n) n = Some j') \\<or>\n                    y = Suc n) \\<and>\n                   token_run x (Suc n) = token_run y (Suc n) \\<and>\n                   token_run x (Suc n) \\<notin> F \\<and>\n                   state_rank (token_run x n) n = Some j \\<and> j < i)\n           y\n 3. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       x \\<in> local.merge i\n 4. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       y \\<in> merge_t i\n 5. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "then"], ["proof (chain)\npicking this:\n  state_rank q y = Some j\n  j < i\n  q' = \\<delta> q (w y)\n  q' \\<notin> F\n  (\\<exists>q''.\n      q' = \\<delta> q'' (w y) \\<and>\n      state_rank q'' y \\<noteq> None \\<and> q'' \\<noteq> q) \\<or>\n  q' = q\\<^sub>0", "obtain t where 6: \"q = token_run t y\" and 7: \"t \\<le> y\""], ["proof (prove)\nusing this:\n  state_rank q y = Some j\n  j < i\n  q' = \\<delta> q (w y)\n  q' \\<notin> F\n  (\\<exists>q''.\n      q' = \\<delta> q'' (w y) \\<and>\n      state_rank q'' y \\<noteq> None \\<and> q'' \\<noteq> q) \\<or>\n  q' = q\\<^sub>0\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>q = token_run t y; t \\<le> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using push_down_state_rank_token_run"], ["proof (prove)\nusing this:\n  state_rank q y = Some j\n  j < i\n  q' = \\<delta> q (w y)\n  q' \\<notin> F\n  (\\<exists>q''.\n      q' = \\<delta> q'' (w y) \\<and>\n      state_rank q'' y \\<noteq> None \\<and> q'' \\<noteq> q) \\<or>\n  q' = q\\<^sub>0\n  state_rank ?q ?n = Some ?i \\<Longrightarrow>\n  \\<exists>x. token_run x ?n = ?q \\<and> x \\<le> ?n\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>q = token_run t y; t \\<le> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  q = token_run t y\n  t \\<le> y\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> merge_t i \\<Longrightarrow>\n       \\<exists>x.\n          (case x of\n           (x, y) \\<Rightarrow>\n             \\<lambda>n.\n                \\<exists>j.\n                   x \\<le> n \\<and>\n                   ((\\<exists>j'.\n                        token_run x n \\<noteq> token_run y n \\<and>\n                        y \\<le> n \\<and>\n                        state_rank (token_run y n) n = Some j') \\<or>\n                    y = Suc n) \\<and>\n                   token_run x (Suc n) = token_run y (Suc n) \\<and>\n                   token_run x (Suc n) \\<notin> F \\<and>\n                   state_rank (token_run x n) n = Some j \\<and> j < i)\n           y\n 3. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       x \\<in> local.merge i\n 4. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       y \\<in> merge_t i\n 5. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "hence 8: \"q' = token_run t (Suc y)\""], ["proof (prove)\nusing this:\n  q = token_run t y\n  t \\<le> y\n\ngoal (1 subgoal):\n 1. q' = token_run t (Suc y)", "unfolding \\<open>q' = \\<delta> q (w y)\\<close>"], ["proof (prove)\nusing this:\n  q = token_run t y\n  t \\<le> y\n\ngoal (1 subgoal):\n 1. \\<delta> q (w y) = token_run t (Suc y)", "using token_run_step"], ["proof (prove)\nusing this:\n  q = token_run t y\n  t \\<le> y\n  \\<lbrakk>?x \\<le> ?n; token_run ?x ?n = ?q';\n   ?q = \\<delta> ?q' (w ?n)\\<rbrakk>\n  \\<Longrightarrow> token_run ?x (Suc ?n) = ?q\n\ngoal (1 subgoal):\n 1. \\<delta> q (w y) = token_run t (Suc y)", "by simp"], ["proof (state)\nthis:\n  q' = token_run t (Suc y)\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> merge_t i \\<Longrightarrow>\n       \\<exists>x.\n          (case x of\n           (x, y) \\<Rightarrow>\n             \\<lambda>n.\n                \\<exists>j.\n                   x \\<le> n \\<and>\n                   ((\\<exists>j'.\n                        token_run x n \\<noteq> token_run y n \\<and>\n                        y \\<le> n \\<and>\n                        state_rank (token_run y n) n = Some j') \\<or>\n                    y = Suc n) \\<and>\n                   token_run x (Suc n) = token_run y (Suc n) \\<and>\n                   token_run x (Suc n) \\<notin> F \\<and>\n                   state_rank (token_run x n) n = Some j \\<and> j < i)\n           y\n 3. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       x \\<in> local.merge i\n 4. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       y \\<in> merge_t i\n 5. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "{"], ["proof (state)\nthis:\n  q' = token_run t (Suc y)\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> merge_t i \\<Longrightarrow>\n       \\<exists>x.\n          (case x of\n           (x, y) \\<Rightarrow>\n             \\<lambda>n.\n                \\<exists>j.\n                   x \\<le> n \\<and>\n                   ((\\<exists>j'.\n                        token_run x n \\<noteq> token_run y n \\<and>\n                        y \\<le> n \\<and>\n                        state_rank (token_run y n) n = Some j') \\<or>\n                    y = Suc n) \\<and>\n                   token_run x (Suc n) = token_run y (Suc n) \\<and>\n                   token_run x (Suc n) \\<notin> F \\<and>\n                   state_rank (token_run x n) n = Some j \\<and> j < i)\n           y\n 3. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       x \\<in> local.merge i\n 4. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       y \\<in> merge_t i\n 5. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "assume \"q' = q\\<^sub>0\""], ["proof (state)\nthis:\n  q' = q\\<^sub>0\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> merge_t i \\<Longrightarrow>\n       \\<exists>x.\n          (case x of\n           (x, y) \\<Rightarrow>\n             \\<lambda>n.\n                \\<exists>j.\n                   x \\<le> n \\<and>\n                   ((\\<exists>j'.\n                        token_run x n \\<noteq> token_run y n \\<and>\n                        y \\<le> n \\<and>\n                        state_rank (token_run y n) n = Some j') \\<or>\n                    y = Suc n) \\<and>\n                   token_run x (Suc n) = token_run y (Suc n) \\<and>\n                   token_run x (Suc n) \\<notin> F \\<and>\n                   state_rank (token_run x n) n = Some j \\<and> j < i)\n           y\n 3. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       x \\<in> local.merge i\n 4. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       y \\<in> merge_t i\n 5. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "hence \"token_run t (Suc y) = token_run (Suc y) (Suc y)\""], ["proof (prove)\nusing this:\n  q' = q\\<^sub>0\n\ngoal (1 subgoal):\n 1. token_run t (Suc y) = token_run (Suc y) (Suc y)", "unfolding 8"], ["proof (prove)\nusing this:\n  token_run t (Suc y) = q\\<^sub>0\n\ngoal (1 subgoal):\n 1. token_run t (Suc y) = token_run (Suc y) (Suc y)", "by simp"], ["proof (state)\nthis:\n  token_run t (Suc y) = token_run (Suc y) (Suc y)\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> merge_t i \\<Longrightarrow>\n       \\<exists>x.\n          (case x of\n           (x, y) \\<Rightarrow>\n             \\<lambda>n.\n                \\<exists>j.\n                   x \\<le> n \\<and>\n                   ((\\<exists>j'.\n                        token_run x n \\<noteq> token_run y n \\<and>\n                        y \\<le> n \\<and>\n                        state_rank (token_run y n) n = Some j') \\<or>\n                    y = Suc n) \\<and>\n                   token_run x (Suc n) = token_run y (Suc n) \\<and>\n                   token_run x (Suc n) \\<notin> F \\<and>\n                   state_rank (token_run x n) n = Some j \\<and> j < i)\n           y\n 3. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       x \\<in> local.merge i\n 4. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       y \\<in> merge_t i\n 5. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "moreover"], ["proof (state)\nthis:\n  token_run t (Suc y) = token_run (Suc y) (Suc y)\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> merge_t i \\<Longrightarrow>\n       \\<exists>x.\n          (case x of\n           (x, y) \\<Rightarrow>\n             \\<lambda>n.\n                \\<exists>j.\n                   x \\<le> n \\<and>\n                   ((\\<exists>j'.\n                        token_run x n \\<noteq> token_run y n \\<and>\n                        y \\<le> n \\<and>\n                        state_rank (token_run y n) n = Some j') \\<or>\n                    y = Suc n) \\<and>\n                   token_run x (Suc n) = token_run y (Suc n) \\<and>\n                   token_run x (Suc n) \\<notin> F \\<and>\n                   state_rank (token_run x n) n = Some j \\<and> j < i)\n           y\n 3. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       x \\<in> local.merge i\n 4. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       y \\<in> merge_t i\n 5. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "then"], ["proof (chain)\npicking this:\n  token_run t (Suc y) = token_run (Suc y) (Suc y)", "obtain x where \"x = (t, Suc y)\""], ["proof (prove)\nusing this:\n  token_run t (Suc y) = token_run (Suc y) (Suc y)\n\ngoal (1 subgoal):\n 1. (\\<And>x. x = (t, Suc y) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  x = (t, Suc y)\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> merge_t i \\<Longrightarrow>\n       \\<exists>x.\n          (case x of\n           (x, y) \\<Rightarrow>\n             \\<lambda>n.\n                \\<exists>j.\n                   x \\<le> n \\<and>\n                   ((\\<exists>j'.\n                        token_run x n \\<noteq> token_run y n \\<and>\n                        y \\<le> n \\<and>\n                        state_rank (token_run y n) n = Some j') \\<or>\n                    y = Suc n) \\<and>\n                   token_run x (Suc n) = token_run y (Suc n) \\<and>\n                   token_run x (Suc n) \\<notin> F \\<and>\n                   state_rank (token_run x n) n = Some j \\<and> j < i)\n           y\n 3. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       x \\<in> local.merge i\n 4. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       y \\<in> merge_t i\n 5. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "ultimately"], ["proof (chain)\npicking this:\n  token_run t (Suc y) = token_run (Suc y) (Suc y)\n  x = (t, Suc y)", "have \"?P x y\""], ["proof (prove)\nusing this:\n  token_run t (Suc y) = token_run (Suc y) (Suc y)\n  x = (t, Suc y)\n\ngoal (1 subgoal):\n 1. (case x of\n     (x, y) \\<Rightarrow>\n       \\<lambda>n.\n          \\<exists>j.\n             x \\<le> n \\<and>\n             ((\\<exists>j'.\n                  token_run x n \\<noteq> token_run y n \\<and>\n                  y \\<le> n \\<and>\n                  state_rank (token_run y n) n = Some j') \\<or>\n              y = Suc n) \\<and>\n             token_run x (Suc n) = token_run y (Suc n) \\<and>\n             token_run x (Suc n) \\<notin> F \\<and>\n             state_rank (token_run x n) n = Some j \\<and> j < i)\n     y", "using 1 2 3 4 5 7"], ["proof (prove)\nusing this:\n  token_run t (Suc y) = token_run (Suc y) (Suc y)\n  x = (t, Suc y)\n  state_rank q y = Some j\n  j < i\n  q' = \\<delta> q (w y)\n  q' \\<notin> F\n  (\\<exists>q''.\n      q' = \\<delta> q'' (w y) \\<and>\n      state_rank q'' y \\<noteq> None \\<and> q'' \\<noteq> q) \\<or>\n  q' = q\\<^sub>0\n  t \\<le> y\n\ngoal (1 subgoal):\n 1. (case x of\n     (x, y) \\<Rightarrow>\n       \\<lambda>n.\n          \\<exists>j.\n             x \\<le> n \\<and>\n             ((\\<exists>j'.\n                  token_run x n \\<noteq> token_run y n \\<and>\n                  y \\<le> n \\<and>\n                  state_rank (token_run y n) n = Some j') \\<or>\n              y = Suc n) \\<and>\n             token_run x (Suc n) = token_run y (Suc n) \\<and>\n             token_run x (Suc n) \\<notin> F \\<and>\n             state_rank (token_run x n) n = Some j \\<and> j < i)\n     y", "unfolding 6 8"], ["proof (prove)\nusing this:\n  token_run t (Suc y) = token_run (Suc y) (Suc y)\n  x = (t, Suc y)\n  state_rank (token_run t y) y = Some j\n  j < i\n  token_run t (Suc y) = \\<delta> (token_run t y) (w y)\n  token_run t (Suc y) \\<notin> F\n  (\\<exists>q''.\n      token_run t (Suc y) = \\<delta> q'' (w y) \\<and>\n      state_rank q'' y \\<noteq> None \\<and>\n      q'' \\<noteq> token_run t y) \\<or>\n  token_run t (Suc y) = q\\<^sub>0\n  t \\<le> y\n\ngoal (1 subgoal):\n 1. (case x of\n     (x, y) \\<Rightarrow>\n       \\<lambda>n.\n          \\<exists>j.\n             x \\<le> n \\<and>\n             ((\\<exists>j'.\n                  token_run x n \\<noteq> token_run y n \\<and>\n                  y \\<le> n \\<and>\n                  state_rank (token_run y n) n = Some j') \\<or>\n              y = Suc n) \\<and>\n             token_run x (Suc n) = token_run y (Suc n) \\<and>\n             token_run x (Suc n) \\<notin> F \\<and>\n             state_rank (token_run x n) n = Some j \\<and> j < i)\n     y", "by force"], ["proof (state)\nthis:\n  (case x of\n   (x, y) \\<Rightarrow>\n     \\<lambda>n.\n        \\<exists>j.\n           x \\<le> n \\<and>\n           ((\\<exists>j'.\n                token_run x n \\<noteq> token_run y n \\<and>\n                y \\<le> n \\<and>\n                state_rank (token_run y n) n = Some j') \\<or>\n            y = Suc n) \\<and>\n           token_run x (Suc n) = token_run y (Suc n) \\<and>\n           token_run x (Suc n) \\<notin> F \\<and>\n           state_rank (token_run x n) n = Some j \\<and> j < i)\n   y\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> merge_t i \\<Longrightarrow>\n       \\<exists>x.\n          (case x of\n           (x, y) \\<Rightarrow>\n             \\<lambda>n.\n                \\<exists>j.\n                   x \\<le> n \\<and>\n                   ((\\<exists>j'.\n                        token_run x n \\<noteq> token_run y n \\<and>\n                        y \\<le> n \\<and>\n                        state_rank (token_run y n) n = Some j') \\<or>\n                    y = Suc n) \\<and>\n                   token_run x (Suc n) = token_run y (Suc n) \\<and>\n                   token_run x (Suc n) \\<notin> F \\<and>\n                   state_rank (token_run x n) n = Some j \\<and> j < i)\n           y\n 3. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       x \\<in> local.merge i\n 4. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       y \\<in> merge_t i\n 5. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "hence \"\\<exists>x. ?P x y\""], ["proof (prove)\nusing this:\n  (case x of\n   (x, y) \\<Rightarrow>\n     \\<lambda>n.\n        \\<exists>j.\n           x \\<le> n \\<and>\n           ((\\<exists>j'.\n                token_run x n \\<noteq> token_run y n \\<and>\n                y \\<le> n \\<and>\n                state_rank (token_run y n) n = Some j') \\<or>\n            y = Suc n) \\<and>\n           token_run x (Suc n) = token_run y (Suc n) \\<and>\n           token_run x (Suc n) \\<notin> F \\<and>\n           state_rank (token_run x n) n = Some j \\<and> j < i)\n   y\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y", "by blast"], ["proof (state)\nthis:\n  \\<exists>x.\n     (case x of\n      (x, y) \\<Rightarrow>\n        \\<lambda>n.\n           \\<exists>j.\n              x \\<le> n \\<and>\n              ((\\<exists>j'.\n                   token_run x n \\<noteq> token_run y n \\<and>\n                   y \\<le> n \\<and>\n                   state_rank (token_run y n) n = Some j') \\<or>\n               y = Suc n) \\<and>\n              token_run x (Suc n) = token_run y (Suc n) \\<and>\n              token_run x (Suc n) \\<notin> F \\<and>\n              state_rank (token_run x n) n = Some j \\<and> j < i)\n      y\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> merge_t i \\<Longrightarrow>\n       \\<exists>x.\n          (case x of\n           (x, y) \\<Rightarrow>\n             \\<lambda>n.\n                \\<exists>j.\n                   x \\<le> n \\<and>\n                   ((\\<exists>j'.\n                        token_run x n \\<noteq> token_run y n \\<and>\n                        y \\<le> n \\<and>\n                        state_rank (token_run y n) n = Some j') \\<or>\n                    y = Suc n) \\<and>\n                   token_run x (Suc n) = token_run y (Suc n) \\<and>\n                   token_run x (Suc n) \\<notin> F \\<and>\n                   state_rank (token_run x n) n = Some j \\<and> j < i)\n           y\n 3. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       x \\<in> local.merge i\n 4. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       y \\<in> merge_t i\n 5. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "}"], ["proof (state)\nthis:\n  q' = q\\<^sub>0 \\<Longrightarrow>\n  \\<exists>x.\n     (case x of\n      (x, y) \\<Rightarrow>\n        \\<lambda>n.\n           \\<exists>j.\n              x \\<le> n \\<and>\n              ((\\<exists>j'.\n                   token_run x n \\<noteq> token_run y n \\<and>\n                   y \\<le> n \\<and>\n                   state_rank (token_run y n) n = Some j') \\<or>\n               y = Suc n) \\<and>\n              token_run x (Suc n) = token_run y (Suc n) \\<and>\n              token_run x (Suc n) \\<notin> F \\<and>\n              state_rank (token_run x n) n = Some j \\<and> j < i)\n      y\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> merge_t i \\<Longrightarrow>\n       \\<exists>x.\n          (case x of\n           (x, y) \\<Rightarrow>\n             \\<lambda>n.\n                \\<exists>j.\n                   x \\<le> n \\<and>\n                   ((\\<exists>j'.\n                        token_run x n \\<noteq> token_run y n \\<and>\n                        y \\<le> n \\<and>\n                        state_rank (token_run y n) n = Some j') \\<or>\n                    y = Suc n) \\<and>\n                   token_run x (Suc n) = token_run y (Suc n) \\<and>\n                   token_run x (Suc n) \\<notin> F \\<and>\n                   state_rank (token_run x n) n = Some j \\<and> j < i)\n           y\n 3. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       x \\<in> local.merge i\n 4. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       y \\<in> merge_t i\n 5. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "moreover"], ["proof (state)\nthis:\n  q' = q\\<^sub>0 \\<Longrightarrow>\n  \\<exists>x.\n     (case x of\n      (x, y) \\<Rightarrow>\n        \\<lambda>n.\n           \\<exists>j.\n              x \\<le> n \\<and>\n              ((\\<exists>j'.\n                   token_run x n \\<noteq> token_run y n \\<and>\n                   y \\<le> n \\<and>\n                   state_rank (token_run y n) n = Some j') \\<or>\n               y = Suc n) \\<and>\n              token_run x (Suc n) = token_run y (Suc n) \\<and>\n              token_run x (Suc n) \\<notin> F \\<and>\n              state_rank (token_run x n) n = Some j \\<and> j < i)\n      y\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> merge_t i \\<Longrightarrow>\n       \\<exists>x.\n          (case x of\n           (x, y) \\<Rightarrow>\n             \\<lambda>n.\n                \\<exists>j.\n                   x \\<le> n \\<and>\n                   ((\\<exists>j'.\n                        token_run x n \\<noteq> token_run y n \\<and>\n                        y \\<le> n \\<and>\n                        state_rank (token_run y n) n = Some j') \\<or>\n                    y = Suc n) \\<and>\n                   token_run x (Suc n) = token_run y (Suc n) \\<and>\n                   token_run x (Suc n) \\<notin> F \\<and>\n                   state_rank (token_run x n) n = Some j \\<and> j < i)\n           y\n 3. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       x \\<in> local.merge i\n 4. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       y \\<in> merge_t i\n 5. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "{"], ["proof (state)\nthis:\n  q' = q\\<^sub>0 \\<Longrightarrow>\n  \\<exists>x.\n     (case x of\n      (x, y) \\<Rightarrow>\n        \\<lambda>n.\n           \\<exists>j.\n              x \\<le> n \\<and>\n              ((\\<exists>j'.\n                   token_run x n \\<noteq> token_run y n \\<and>\n                   y \\<le> n \\<and>\n                   state_rank (token_run y n) n = Some j') \\<or>\n               y = Suc n) \\<and>\n              token_run x (Suc n) = token_run y (Suc n) \\<and>\n              token_run x (Suc n) \\<notin> F \\<and>\n              state_rank (token_run x n) n = Some j \\<and> j < i)\n      y\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> merge_t i \\<Longrightarrow>\n       \\<exists>x.\n          (case x of\n           (x, y) \\<Rightarrow>\n             \\<lambda>n.\n                \\<exists>j.\n                   x \\<le> n \\<and>\n                   ((\\<exists>j'.\n                        token_run x n \\<noteq> token_run y n \\<and>\n                        y \\<le> n \\<and>\n                        state_rank (token_run y n) n = Some j') \\<or>\n                    y = Suc n) \\<and>\n                   token_run x (Suc n) = token_run y (Suc n) \\<and>\n                   token_run x (Suc n) \\<notin> F \\<and>\n                   state_rank (token_run x n) n = Some j \\<and> j < i)\n           y\n 3. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       x \\<in> local.merge i\n 4. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       y \\<in> merge_t i\n 5. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "assume \"q' \\<noteq> q\\<^sub>0\""], ["proof (state)\nthis:\n  q' \\<noteq> q\\<^sub>0\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> merge_t i \\<Longrightarrow>\n       \\<exists>x.\n          (case x of\n           (x, y) \\<Rightarrow>\n             \\<lambda>n.\n                \\<exists>j.\n                   x \\<le> n \\<and>\n                   ((\\<exists>j'.\n                        token_run x n \\<noteq> token_run y n \\<and>\n                        y \\<le> n \\<and>\n                        state_rank (token_run y n) n = Some j') \\<or>\n                    y = Suc n) \\<and>\n                   token_run x (Suc n) = token_run y (Suc n) \\<and>\n                   token_run x (Suc n) \\<notin> F \\<and>\n                   state_rank (token_run x n) n = Some j \\<and> j < i)\n           y\n 3. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       x \\<in> local.merge i\n 4. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       y \\<in> merge_t i\n 5. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "then"], ["proof (chain)\npicking this:\n  q' \\<noteq> q\\<^sub>0", "obtain q'' j' where 9: \"q' = \\<delta> q'' (w y)\"\n        and \"state_rank q'' y = Some j'\"\n        and \"q'' \\<noteq> q\""], ["proof (prove)\nusing this:\n  q' \\<noteq> q\\<^sub>0\n\ngoal (1 subgoal):\n 1. (\\<And>q'' j'.\n        \\<lbrakk>q' = \\<delta> q'' (w y); state_rank q'' y = Some j';\n         q'' \\<noteq> q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 5"], ["proof (prove)\nusing this:\n  q' \\<noteq> q\\<^sub>0\n  (\\<exists>q''.\n      q' = \\<delta> q'' (w y) \\<and>\n      state_rank q'' y \\<noteq> None \\<and> q'' \\<noteq> q) \\<or>\n  q' = q\\<^sub>0\n\ngoal (1 subgoal):\n 1. (\\<And>q'' j'.\n        \\<lbrakk>q' = \\<delta> q'' (w y); state_rank q'' y = Some j';\n         q'' \\<noteq> q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  q' = \\<delta> q'' (w y)\n  state_rank q'' y = Some j'\n  q'' \\<noteq> q\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> merge_t i \\<Longrightarrow>\n       \\<exists>x.\n          (case x of\n           (x, y) \\<Rightarrow>\n             \\<lambda>n.\n                \\<exists>j.\n                   x \\<le> n \\<and>\n                   ((\\<exists>j'.\n                        token_run x n \\<noteq> token_run y n \\<and>\n                        y \\<le> n \\<and>\n                        state_rank (token_run y n) n = Some j') \\<or>\n                    y = Suc n) \\<and>\n                   token_run x (Suc n) = token_run y (Suc n) \\<and>\n                   token_run x (Suc n) \\<notin> F \\<and>\n                   state_rank (token_run x n) n = Some j \\<and> j < i)\n           y\n 3. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       x \\<in> local.merge i\n 4. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       y \\<in> merge_t i\n 5. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "moreover"], ["proof (state)\nthis:\n  q' = \\<delta> q'' (w y)\n  state_rank q'' y = Some j'\n  q'' \\<noteq> q\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> merge_t i \\<Longrightarrow>\n       \\<exists>x.\n          (case x of\n           (x, y) \\<Rightarrow>\n             \\<lambda>n.\n                \\<exists>j.\n                   x \\<le> n \\<and>\n                   ((\\<exists>j'.\n                        token_run x n \\<noteq> token_run y n \\<and>\n                        y \\<le> n \\<and>\n                        state_rank (token_run y n) n = Some j') \\<or>\n                    y = Suc n) \\<and>\n                   token_run x (Suc n) = token_run y (Suc n) \\<and>\n                   token_run x (Suc n) \\<notin> F \\<and>\n                   state_rank (token_run x n) n = Some j \\<and> j < i)\n           y\n 3. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       x \\<in> local.merge i\n 4. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       y \\<in> merge_t i\n 5. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "then"], ["proof (chain)\npicking this:\n  q' = \\<delta> q'' (w y)\n  state_rank q'' y = Some j'\n  q'' \\<noteq> q", "obtain t' where 12: \"q'' = token_run t' y\" and \"t' \\<le> y\""], ["proof (prove)\nusing this:\n  q' = \\<delta> q'' (w y)\n  state_rank q'' y = Some j'\n  q'' \\<noteq> q\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>q'' = token_run t' y; t' \\<le> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: push_down_state_rank_token_run)"], ["proof (state)\nthis:\n  q'' = token_run t' y\n  t' \\<le> y\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> merge_t i \\<Longrightarrow>\n       \\<exists>x.\n          (case x of\n           (x, y) \\<Rightarrow>\n             \\<lambda>n.\n                \\<exists>j.\n                   x \\<le> n \\<and>\n                   ((\\<exists>j'.\n                        token_run x n \\<noteq> token_run y n \\<and>\n                        y \\<le> n \\<and>\n                        state_rank (token_run y n) n = Some j') \\<or>\n                    y = Suc n) \\<and>\n                   token_run x (Suc n) = token_run y (Suc n) \\<and>\n                   token_run x (Suc n) \\<notin> F \\<and>\n                   state_rank (token_run x n) n = Some j \\<and> j < i)\n           y\n 3. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       x \\<in> local.merge i\n 4. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       y \\<in> merge_t i\n 5. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "moreover"], ["proof (state)\nthis:\n  q'' = token_run t' y\n  t' \\<le> y\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> merge_t i \\<Longrightarrow>\n       \\<exists>x.\n          (case x of\n           (x, y) \\<Rightarrow>\n             \\<lambda>n.\n                \\<exists>j.\n                   x \\<le> n \\<and>\n                   ((\\<exists>j'.\n                        token_run x n \\<noteq> token_run y n \\<and>\n                        y \\<le> n \\<and>\n                        state_rank (token_run y n) n = Some j') \\<or>\n                    y = Suc n) \\<and>\n                   token_run x (Suc n) = token_run y (Suc n) \\<and>\n                   token_run x (Suc n) \\<notin> F \\<and>\n                   state_rank (token_run x n) n = Some j \\<and> j < i)\n           y\n 3. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       x \\<in> local.merge i\n 4. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       y \\<in> merge_t i\n 5. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "hence \"token_run t (Suc y) = token_run t' (Suc y)\""], ["proof (prove)\nusing this:\n  q'' = token_run t' y\n  t' \\<le> y\n\ngoal (1 subgoal):\n 1. token_run t (Suc y) = token_run t' (Suc y)", "using 8 9 token_run_step"], ["proof (prove)\nusing this:\n  q'' = token_run t' y\n  t' \\<le> y\n  q' = token_run t (Suc y)\n  q' = \\<delta> q'' (w y)\n  \\<lbrakk>?x \\<le> ?n; token_run ?x ?n = ?q';\n   ?q = \\<delta> ?q' (w ?n)\\<rbrakk>\n  \\<Longrightarrow> token_run ?x (Suc ?n) = ?q\n\ngoal (1 subgoal):\n 1. token_run t (Suc y) = token_run t' (Suc y)", "by presburger"], ["proof (state)\nthis:\n  token_run t (Suc y) = token_run t' (Suc y)\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> merge_t i \\<Longrightarrow>\n       \\<exists>x.\n          (case x of\n           (x, y) \\<Rightarrow>\n             \\<lambda>n.\n                \\<exists>j.\n                   x \\<le> n \\<and>\n                   ((\\<exists>j'.\n                        token_run x n \\<noteq> token_run y n \\<and>\n                        y \\<le> n \\<and>\n                        state_rank (token_run y n) n = Some j') \\<or>\n                    y = Suc n) \\<and>\n                   token_run x (Suc n) = token_run y (Suc n) \\<and>\n                   token_run x (Suc n) \\<notin> F \\<and>\n                   state_rank (token_run x n) n = Some j \\<and> j < i)\n           y\n 3. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       x \\<in> local.merge i\n 4. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       y \\<in> merge_t i\n 5. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "moreover"], ["proof (state)\nthis:\n  token_run t (Suc y) = token_run t' (Suc y)\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> merge_t i \\<Longrightarrow>\n       \\<exists>x.\n          (case x of\n           (x, y) \\<Rightarrow>\n             \\<lambda>n.\n                \\<exists>j.\n                   x \\<le> n \\<and>\n                   ((\\<exists>j'.\n                        token_run x n \\<noteq> token_run y n \\<and>\n                        y \\<le> n \\<and>\n                        state_rank (token_run y n) n = Some j') \\<or>\n                    y = Suc n) \\<and>\n                   token_run x (Suc n) = token_run y (Suc n) \\<and>\n                   token_run x (Suc n) \\<notin> F \\<and>\n                   state_rank (token_run x n) n = Some j \\<and> j < i)\n           y\n 3. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       x \\<in> local.merge i\n 4. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       y \\<in> merge_t i\n 5. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "have \"token_run t y \\<noteq> token_run t' y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. token_run t y \\<noteq> token_run t' y", "using \\<open>q'' \\<noteq> q\\<close>"], ["proof (prove)\nusing this:\n  q'' \\<noteq> q\n\ngoal (1 subgoal):\n 1. token_run t y \\<noteq> token_run t' y", "unfolding 6 12"], ["proof (prove)\nusing this:\n  token_run t' y \\<noteq> token_run t y\n\ngoal (1 subgoal):\n 1. token_run t y \\<noteq> token_run t' y", ".."], ["proof (state)\nthis:\n  token_run t y \\<noteq> token_run t' y\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> merge_t i \\<Longrightarrow>\n       \\<exists>x.\n          (case x of\n           (x, y) \\<Rightarrow>\n             \\<lambda>n.\n                \\<exists>j.\n                   x \\<le> n \\<and>\n                   ((\\<exists>j'.\n                        token_run x n \\<noteq> token_run y n \\<and>\n                        y \\<le> n \\<and>\n                        state_rank (token_run y n) n = Some j') \\<or>\n                    y = Suc n) \\<and>\n                   token_run x (Suc n) = token_run y (Suc n) \\<and>\n                   token_run x (Suc n) \\<notin> F \\<and>\n                   state_rank (token_run x n) n = Some j \\<and> j < i)\n           y\n 3. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       x \\<in> local.merge i\n 4. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       y \\<in> merge_t i\n 5. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "moreover"], ["proof (state)\nthis:\n  token_run t y \\<noteq> token_run t' y\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> merge_t i \\<Longrightarrow>\n       \\<exists>x.\n          (case x of\n           (x, y) \\<Rightarrow>\n             \\<lambda>n.\n                \\<exists>j.\n                   x \\<le> n \\<and>\n                   ((\\<exists>j'.\n                        token_run x n \\<noteq> token_run y n \\<and>\n                        y \\<le> n \\<and>\n                        state_rank (token_run y n) n = Some j') \\<or>\n                    y = Suc n) \\<and>\n                   token_run x (Suc n) = token_run y (Suc n) \\<and>\n                   token_run x (Suc n) \\<notin> F \\<and>\n                   state_rank (token_run x n) n = Some j \\<and> j < i)\n           y\n 3. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       x \\<in> local.merge i\n 4. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       y \\<in> merge_t i\n 5. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "then"], ["proof (chain)\npicking this:\n  token_run t y \\<noteq> token_run t' y", "obtain x where \"x = (t, t')\""], ["proof (prove)\nusing this:\n  token_run t y \\<noteq> token_run t' y\n\ngoal (1 subgoal):\n 1. (\\<And>x. x = (t, t') \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by simp"], ["proof (state)\nthis:\n  x = (t, t')\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> merge_t i \\<Longrightarrow>\n       \\<exists>x.\n          (case x of\n           (x, y) \\<Rightarrow>\n             \\<lambda>n.\n                \\<exists>j.\n                   x \\<le> n \\<and>\n                   ((\\<exists>j'.\n                        token_run x n \\<noteq> token_run y n \\<and>\n                        y \\<le> n \\<and>\n                        state_rank (token_run y n) n = Some j') \\<or>\n                    y = Suc n) \\<and>\n                   token_run x (Suc n) = token_run y (Suc n) \\<and>\n                   token_run x (Suc n) \\<notin> F \\<and>\n                   state_rank (token_run x n) n = Some j \\<and> j < i)\n           y\n 3. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       x \\<in> local.merge i\n 4. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       y \\<in> merge_t i\n 5. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "ultimately"], ["proof (chain)\npicking this:\n  q' = \\<delta> q'' (w y)\n  state_rank q'' y = Some j'\n  q'' \\<noteq> q\n  q'' = token_run t' y\n  t' \\<le> y\n  token_run t (Suc y) = token_run t' (Suc y)\n  token_run t y \\<noteq> token_run t' y\n  x = (t, t')", "have \"?P x y\""], ["proof (prove)\nusing this:\n  q' = \\<delta> q'' (w y)\n  state_rank q'' y = Some j'\n  q'' \\<noteq> q\n  q'' = token_run t' y\n  t' \\<le> y\n  token_run t (Suc y) = token_run t' (Suc y)\n  token_run t y \\<noteq> token_run t' y\n  x = (t, t')\n\ngoal (1 subgoal):\n 1. (case x of\n     (x, y) \\<Rightarrow>\n       \\<lambda>n.\n          \\<exists>j.\n             x \\<le> n \\<and>\n             ((\\<exists>j'.\n                  token_run x n \\<noteq> token_run y n \\<and>\n                  y \\<le> n \\<and>\n                  state_rank (token_run y n) n = Some j') \\<or>\n              y = Suc n) \\<and>\n             token_run x (Suc n) = token_run y (Suc n) \\<and>\n             token_run x (Suc n) \\<notin> F \\<and>\n             state_rank (token_run x n) n = Some j \\<and> j < i)\n     y", "using 1 2 4 7"], ["proof (prove)\nusing this:\n  q' = \\<delta> q'' (w y)\n  state_rank q'' y = Some j'\n  q'' \\<noteq> q\n  q'' = token_run t' y\n  t' \\<le> y\n  token_run t (Suc y) = token_run t' (Suc y)\n  token_run t y \\<noteq> token_run t' y\n  x = (t, t')\n  state_rank q y = Some j\n  j < i\n  q' \\<notin> F\n  t \\<le> y\n\ngoal (1 subgoal):\n 1. (case x of\n     (x, y) \\<Rightarrow>\n       \\<lambda>n.\n          \\<exists>j.\n             x \\<le> n \\<and>\n             ((\\<exists>j'.\n                  token_run x n \\<noteq> token_run y n \\<and>\n                  y \\<le> n \\<and>\n                  state_rank (token_run y n) n = Some j') \\<or>\n              y = Suc n) \\<and>\n             token_run x (Suc n) = token_run y (Suc n) \\<and>\n             token_run x (Suc n) \\<notin> F \\<and>\n             state_rank (token_run x n) n = Some j \\<and> j < i)\n     y", "unfolding 6 8"], ["proof (prove)\nusing this:\n  token_run t (Suc y) = \\<delta> q'' (w y)\n  state_rank q'' y = Some j'\n  q'' \\<noteq> token_run t y\n  q'' = token_run t' y\n  t' \\<le> y\n  token_run t (Suc y) = token_run t' (Suc y)\n  token_run t y \\<noteq> token_run t' y\n  x = (t, t')\n  state_rank (token_run t y) y = Some j\n  j < i\n  token_run t (Suc y) \\<notin> F\n  t \\<le> y\n\ngoal (1 subgoal):\n 1. (case x of\n     (x, y) \\<Rightarrow>\n       \\<lambda>n.\n          \\<exists>j.\n             x \\<le> n \\<and>\n             ((\\<exists>j'.\n                  token_run x n \\<noteq> token_run y n \\<and>\n                  y \\<le> n \\<and>\n                  state_rank (token_run y n) n = Some j') \\<or>\n              y = Suc n) \\<and>\n             token_run x (Suc n) = token_run y (Suc n) \\<and>\n             token_run x (Suc n) \\<notin> F \\<and>\n             state_rank (token_run x n) n = Some j \\<and> j < i)\n     y", "by fast"], ["proof (state)\nthis:\n  (case x of\n   (x, y) \\<Rightarrow>\n     \\<lambda>n.\n        \\<exists>j.\n           x \\<le> n \\<and>\n           ((\\<exists>j'.\n                token_run x n \\<noteq> token_run y n \\<and>\n                y \\<le> n \\<and>\n                state_rank (token_run y n) n = Some j') \\<or>\n            y = Suc n) \\<and>\n           token_run x (Suc n) = token_run y (Suc n) \\<and>\n           token_run x (Suc n) \\<notin> F \\<and>\n           state_rank (token_run x n) n = Some j \\<and> j < i)\n   y\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> merge_t i \\<Longrightarrow>\n       \\<exists>x.\n          (case x of\n           (x, y) \\<Rightarrow>\n             \\<lambda>n.\n                \\<exists>j.\n                   x \\<le> n \\<and>\n                   ((\\<exists>j'.\n                        token_run x n \\<noteq> token_run y n \\<and>\n                        y \\<le> n \\<and>\n                        state_rank (token_run y n) n = Some j') \\<or>\n                    y = Suc n) \\<and>\n                   token_run x (Suc n) = token_run y (Suc n) \\<and>\n                   token_run x (Suc n) \\<notin> F \\<and>\n                   state_rank (token_run x n) n = Some j \\<and> j < i)\n           y\n 3. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       x \\<in> local.merge i\n 4. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       y \\<in> merge_t i\n 5. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "hence \"\\<exists>x. ?P x y\""], ["proof (prove)\nusing this:\n  (case x of\n   (x, y) \\<Rightarrow>\n     \\<lambda>n.\n        \\<exists>j.\n           x \\<le> n \\<and>\n           ((\\<exists>j'.\n                token_run x n \\<noteq> token_run y n \\<and>\n                y \\<le> n \\<and>\n                state_rank (token_run y n) n = Some j') \\<or>\n            y = Suc n) \\<and>\n           token_run x (Suc n) = token_run y (Suc n) \\<and>\n           token_run x (Suc n) \\<notin> F \\<and>\n           state_rank (token_run x n) n = Some j \\<and> j < i)\n   y\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y", "by blast"], ["proof (state)\nthis:\n  \\<exists>x.\n     (case x of\n      (x, y) \\<Rightarrow>\n        \\<lambda>n.\n           \\<exists>j.\n              x \\<le> n \\<and>\n              ((\\<exists>j'.\n                   token_run x n \\<noteq> token_run y n \\<and>\n                   y \\<le> n \\<and>\n                   state_rank (token_run y n) n = Some j') \\<or>\n               y = Suc n) \\<and>\n              token_run x (Suc n) = token_run y (Suc n) \\<and>\n              token_run x (Suc n) \\<notin> F \\<and>\n              state_rank (token_run x n) n = Some j \\<and> j < i)\n      y\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> merge_t i \\<Longrightarrow>\n       \\<exists>x.\n          (case x of\n           (x, y) \\<Rightarrow>\n             \\<lambda>n.\n                \\<exists>j.\n                   x \\<le> n \\<and>\n                   ((\\<exists>j'.\n                        token_run x n \\<noteq> token_run y n \\<and>\n                        y \\<le> n \\<and>\n                        state_rank (token_run y n) n = Some j') \\<or>\n                    y = Suc n) \\<and>\n                   token_run x (Suc n) = token_run y (Suc n) \\<and>\n                   token_run x (Suc n) \\<notin> F \\<and>\n                   state_rank (token_run x n) n = Some j \\<and> j < i)\n           y\n 3. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       x \\<in> local.merge i\n 4. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       y \\<in> merge_t i\n 5. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "}"], ["proof (state)\nthis:\n  q' \\<noteq> q\\<^sub>0 \\<Longrightarrow>\n  \\<exists>x.\n     (case x of\n      (x, y) \\<Rightarrow>\n        \\<lambda>n.\n           \\<exists>j.\n              x \\<le> n \\<and>\n              ((\\<exists>j'.\n                   token_run x n \\<noteq> token_run y n \\<and>\n                   y \\<le> n \\<and>\n                   state_rank (token_run y n) n = Some j') \\<or>\n               y = Suc n) \\<and>\n              token_run x (Suc n) = token_run y (Suc n) \\<and>\n              token_run x (Suc n) \\<notin> F \\<and>\n              state_rank (token_run x n) n = Some j \\<and> j < i)\n      y\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>y.\n       y \\<in> merge_t i \\<Longrightarrow>\n       \\<exists>x.\n          (case x of\n           (x, y) \\<Rightarrow>\n             \\<lambda>n.\n                \\<exists>j.\n                   x \\<le> n \\<and>\n                   ((\\<exists>j'.\n                        token_run x n \\<noteq> token_run y n \\<and>\n                        y \\<le> n \\<and>\n                        state_rank (token_run y n) n = Some j') \\<or>\n                    y = Suc n) \\<and>\n                   token_run x (Suc n) = token_run y (Suc n) \\<and>\n                   token_run x (Suc n) \\<notin> F \\<and>\n                   state_rank (token_run x n) n = Some j \\<and> j < i)\n           y\n 3. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       x \\<in> local.merge i\n 4. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       y \\<in> merge_t i\n 5. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "ultimately"], ["proof (chain)\npicking this:\n  q' = q\\<^sub>0 \\<Longrightarrow>\n  \\<exists>x.\n     (case x of\n      (x, y) \\<Rightarrow>\n        \\<lambda>n.\n           \\<exists>j.\n              x \\<le> n \\<and>\n              ((\\<exists>j'.\n                   token_run x n \\<noteq> token_run y n \\<and>\n                   y \\<le> n \\<and>\n                   state_rank (token_run y n) n = Some j') \\<or>\n               y = Suc n) \\<and>\n              token_run x (Suc n) = token_run y (Suc n) \\<and>\n              token_run x (Suc n) \\<notin> F \\<and>\n              state_rank (token_run x n) n = Some j \\<and> j < i)\n      y\n  q' \\<noteq> q\\<^sub>0 \\<Longrightarrow>\n  \\<exists>x.\n     (case x of\n      (x, y) \\<Rightarrow>\n        \\<lambda>n.\n           \\<exists>j.\n              x \\<le> n \\<and>\n              ((\\<exists>j'.\n                   token_run x n \\<noteq> token_run y n \\<and>\n                   y \\<le> n \\<and>\n                   state_rank (token_run y n) n = Some j') \\<or>\n               y = Suc n) \\<and>\n              token_run x (Suc n) = token_run y (Suc n) \\<and>\n              token_run x (Suc n) \\<notin> F \\<and>\n              state_rank (token_run x n) n = Some j \\<and> j < i)\n      y", "show \"\\<exists>x. ?P x y\""], ["proof (prove)\nusing this:\n  q' = q\\<^sub>0 \\<Longrightarrow>\n  \\<exists>x.\n     (case x of\n      (x, y) \\<Rightarrow>\n        \\<lambda>n.\n           \\<exists>j.\n              x \\<le> n \\<and>\n              ((\\<exists>j'.\n                   token_run x n \\<noteq> token_run y n \\<and>\n                   y \\<le> n \\<and>\n                   state_rank (token_run y n) n = Some j') \\<or>\n               y = Suc n) \\<and>\n              token_run x (Suc n) = token_run y (Suc n) \\<and>\n              token_run x (Suc n) \\<notin> F \\<and>\n              state_rank (token_run x n) n = Some j \\<and> j < i)\n      y\n  q' \\<noteq> q\\<^sub>0 \\<Longrightarrow>\n  \\<exists>x.\n     (case x of\n      (x, y) \\<Rightarrow>\n        \\<lambda>n.\n           \\<exists>j.\n              x \\<le> n \\<and>\n              ((\\<exists>j'.\n                   token_run x n \\<noteq> token_run y n \\<and>\n                   y \\<le> n \\<and>\n                   state_rank (token_run y n) n = Some j') \\<or>\n               y = Suc n) \\<and>\n              token_run x (Suc n) = token_run y (Suc n) \\<and>\n              token_run x (Suc n) \\<notin> F \\<and>\n              state_rank (token_run x n) n = Some j \\<and> j < i)\n      y\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y", "by blast"], ["proof (state)\nthis:\n  \\<exists>x.\n     (case x of\n      (x, y) \\<Rightarrow>\n        \\<lambda>n.\n           \\<exists>j.\n              x \\<le> n \\<and>\n              ((\\<exists>j'.\n                   token_run x n \\<noteq> token_run y n \\<and>\n                   y \\<le> n \\<and>\n                   state_rank (token_run y n) n = Some j') \\<or>\n               y = Suc n) \\<and>\n              token_run x (Suc n) = token_run y (Suc n) \\<and>\n              token_run x (Suc n) \\<notin> F \\<and>\n              state_rank (token_run x n) n = Some j \\<and> j < i)\n      y\n\ngoal (4 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       x \\<in> local.merge i\n 3. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       y \\<in> merge_t i\n 4. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "}"], ["proof (state)\nthis:\n  ?y2 \\<in> merge_t i \\<Longrightarrow>\n  \\<exists>x.\n     (case x of\n      (x, y) \\<Rightarrow>\n        \\<lambda>n.\n           \\<exists>j.\n              x \\<le> n \\<and>\n              ((\\<exists>j'.\n                   token_run x n \\<noteq> token_run y n \\<and>\n                   y \\<le> n \\<and>\n                   state_rank (token_run y n) n = Some j') \\<or>\n               y = Suc n) \\<and>\n              token_run x (Suc n) = token_run y (Suc n) \\<and>\n              token_run x (Suc n) \\<notin> F \\<and>\n              state_rank (token_run x n) n = Some j \\<and> j < i)\n      ?y2\n\ngoal (4 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       x \\<in> local.merge i\n 3. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       y \\<in> merge_t i\n 4. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "{"], ["proof (state)\nthis:\n  ?y2 \\<in> merge_t i \\<Longrightarrow>\n  \\<exists>x.\n     (case x of\n      (x, y) \\<Rightarrow>\n        \\<lambda>n.\n           \\<exists>j.\n              x \\<le> n \\<and>\n              ((\\<exists>j'.\n                   token_run x n \\<noteq> token_run y n \\<and>\n                   y \\<le> n \\<and>\n                   state_rank (token_run y n) n = Some j') \\<or>\n               y = Suc n) \\<and>\n              token_run x (Suc n) = token_run y (Suc n) \\<and>\n              token_run x (Suc n) \\<notin> F \\<and>\n              state_rank (token_run x n) n = Some j \\<and> j < i)\n      ?y2\n\ngoal (4 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       x \\<in> local.merge i\n 3. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       y \\<in> merge_t i\n 4. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "fix x y"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       x \\<in> local.merge i\n 3. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       y \\<in> merge_t i\n 4. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "assume \"?P x y\""], ["proof (state)\nthis:\n  (case x of\n   (x, y) \\<Rightarrow>\n     \\<lambda>n.\n        \\<exists>j.\n           x \\<le> n \\<and>\n           ((\\<exists>j'.\n                token_run x n \\<noteq> token_run y n \\<and>\n                y \\<le> n \\<and>\n                state_rank (token_run y n) n = Some j') \\<or>\n            y = Suc n) \\<and>\n           token_run x (Suc n) = token_run y (Suc n) \\<and>\n           token_run x (Suc n) \\<notin> F \\<and>\n           state_rank (token_run x n) n = Some j \\<and> j < i)\n   y\n\ngoal (4 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       x \\<in> local.merge i\n 3. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       y \\<in> merge_t i\n 4. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "then"], ["proof (chain)\npicking this:\n  (case x of\n   (x, y) \\<Rightarrow>\n     \\<lambda>n.\n        \\<exists>j.\n           x \\<le> n \\<and>\n           ((\\<exists>j'.\n                token_run x n \\<noteq> token_run y n \\<and>\n                y \\<le> n \\<and>\n                state_rank (token_run y n) n = Some j') \\<or>\n            y = Suc n) \\<and>\n           token_run x (Suc n) = token_run y (Suc n) \\<and>\n           token_run x (Suc n) \\<notin> F \\<and>\n           state_rank (token_run x n) n = Some j \\<and> j < i)\n   y", "obtain t t' j where 1: \"x = (t, t')\"\n      and 3: \"t \\<le> y\"\n      and 4: \"(\\<exists>j'. token_run t y \\<noteq> token_run t' y \\<and> t' \\<le> y \\<and> state_rank (token_run t' y) y = Some j') \\<or> t' = Suc y\"\n      and 5: \"token_run t (Suc y) = token_run t' (Suc y)\"\n      and 6: \"token_run t (Suc y) \\<notin> F\"\n      and 7: \"state_rank (token_run t y) y = Some j\"\n      and 8: \"j < i\""], ["proof (prove)\nusing this:\n  (case x of\n   (x, y) \\<Rightarrow>\n     \\<lambda>n.\n        \\<exists>j.\n           x \\<le> n \\<and>\n           ((\\<exists>j'.\n                token_run x n \\<noteq> token_run y n \\<and>\n                y \\<le> n \\<and>\n                state_rank (token_run y n) n = Some j') \\<or>\n            y = Suc n) \\<and>\n           token_run x (Suc n) = token_run y (Suc n) \\<and>\n           token_run x (Suc n) \\<notin> F \\<and>\n           state_rank (token_run x n) n = Some j \\<and> j < i)\n   y\n\ngoal (1 subgoal):\n 1. (\\<And>t t' j.\n        \\<lbrakk>x = (t, t'); t \\<le> y;\n         (\\<exists>j'.\n             token_run t y \\<noteq> token_run t' y \\<and>\n             t' \\<le> y \\<and>\n             state_rank (token_run t' y) y = Some j') \\<or>\n         t' = Suc y;\n         token_run t (Suc y) = token_run t' (Suc y);\n         token_run t (Suc y) \\<notin> F;\n         state_rank (token_run t y) y = Some j; j < i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x = (t, t')\n  t \\<le> y\n  (\\<exists>j'.\n      token_run t y \\<noteq> token_run t' y \\<and>\n      t' \\<le> y \\<and> state_rank (token_run t' y) y = Some j') \\<or>\n  t' = Suc y\n  token_run t (Suc y) = token_run t' (Suc y)\n  token_run t (Suc y) \\<notin> F\n  state_rank (token_run t y) y = Some j\n  j < i\n\ngoal (4 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       x \\<in> local.merge i\n 3. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       y \\<in> merge_t i\n 4. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "thus \"x \\<in> merge i\""], ["proof (prove)\nusing this:\n  x = (t, t')\n  t \\<le> y\n  (\\<exists>j'.\n      token_run t y \\<noteq> token_run t' y \\<and>\n      t' \\<le> y \\<and> state_rank (token_run t' y) y = Some j') \\<or>\n  t' = Suc y\n  token_run t (Suc y) = token_run t' (Suc y)\n  token_run t (Suc y) \\<notin> F\n  state_rank (token_run t y) y = Some j\n  j < i\n\ngoal (1 subgoal):\n 1. x \\<in> local.merge i", "proof (cases \"t' = Suc y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x = (t, t'); t \\<le> y;\n     (\\<exists>j'.\n         token_run t y \\<noteq> token_run t' y \\<and>\n         t' \\<le> y \\<and> state_rank (token_run t' y) y = Some j') \\<or>\n     t' = Suc y;\n     token_run t (Suc y) = token_run t' (Suc y);\n     token_run t (Suc y) \\<notin> F; state_rank (token_run t y) y = Some j;\n     j < i; t' = Suc y\\<rbrakk>\n    \\<Longrightarrow> x \\<in> local.merge i\n 2. \\<lbrakk>x = (t, t'); t \\<le> y;\n     (\\<exists>j'.\n         token_run t y \\<noteq> token_run t' y \\<and>\n         t' \\<le> y \\<and> state_rank (token_run t' y) y = Some j') \\<or>\n     t' = Suc y;\n     token_run t (Suc y) = token_run t' (Suc y);\n     token_run t (Suc y) \\<notin> F; state_rank (token_run t y) y = Some j;\n     j < i; t' \\<noteq> Suc y\\<rbrakk>\n    \\<Longrightarrow> x \\<in> local.merge i", "case False"], ["proof (state)\nthis:\n  t' \\<noteq> Suc y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x = (t, t'); t \\<le> y;\n     (\\<exists>j'.\n         token_run t y \\<noteq> token_run t' y \\<and>\n         t' \\<le> y \\<and> state_rank (token_run t' y) y = Some j') \\<or>\n     t' = Suc y;\n     token_run t (Suc y) = token_run t' (Suc y);\n     token_run t (Suc y) \\<notin> F; state_rank (token_run t y) y = Some j;\n     j < i; t' = Suc y\\<rbrakk>\n    \\<Longrightarrow> x \\<in> local.merge i\n 2. \\<lbrakk>x = (t, t'); t \\<le> y;\n     (\\<exists>j'.\n         token_run t y \\<noteq> token_run t' y \\<and>\n         t' \\<le> y \\<and> state_rank (token_run t' y) y = Some j') \\<or>\n     t' = Suc y;\n     token_run t (Suc y) = token_run t' (Suc y);\n     token_run t (Suc y) \\<notin> F; state_rank (token_run t y) y = Some j;\n     j < i; t' \\<noteq> Suc y\\<rbrakk>\n    \\<Longrightarrow> x \\<in> local.merge i", "hence \"t' \\<le> y\""], ["proof (prove)\nusing this:\n  t' \\<noteq> Suc y\n\ngoal (1 subgoal):\n 1. t' \\<le> y", "using 4"], ["proof (prove)\nusing this:\n  t' \\<noteq> Suc y\n  (\\<exists>j'.\n      token_run t y \\<noteq> token_run t' y \\<and>\n      t' \\<le> y \\<and> state_rank (token_run t' y) y = Some j') \\<or>\n  t' = Suc y\n\ngoal (1 subgoal):\n 1. t' \\<le> y", "by blast"], ["proof (state)\nthis:\n  t' \\<le> y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x = (t, t'); t \\<le> y;\n     (\\<exists>j'.\n         token_run t y \\<noteq> token_run t' y \\<and>\n         t' \\<le> y \\<and> state_rank (token_run t' y) y = Some j') \\<or>\n     t' = Suc y;\n     token_run t (Suc y) = token_run t' (Suc y);\n     token_run t (Suc y) \\<notin> F; state_rank (token_run t y) y = Some j;\n     j < i; t' = Suc y\\<rbrakk>\n    \\<Longrightarrow> x \\<in> local.merge i\n 2. \\<lbrakk>x = (t, t'); t \\<le> y;\n     (\\<exists>j'.\n         token_run t y \\<noteq> token_run t' y \\<and>\n         t' \\<le> y \\<and> state_rank (token_run t' y) y = Some j') \\<or>\n     t' = Suc y;\n     token_run t (Suc y) = token_run t' (Suc y);\n     token_run t (Suc y) \\<notin> F; state_rank (token_run t y) y = Some j;\n     j < i; t' \\<noteq> Suc y\\<rbrakk>\n    \\<Longrightarrow> x \\<in> local.merge i", "thus ?thesis"], ["proof (prove)\nusing this:\n  t' \\<le> y\n\ngoal (1 subgoal):\n 1. x \\<in> local.merge i", "using 1 3 4 5 6 7 8"], ["proof (prove)\nusing this:\n  t' \\<le> y\n  x = (t, t')\n  t \\<le> y\n  (\\<exists>j'.\n      token_run t y \\<noteq> token_run t' y \\<and>\n      t' \\<le> y \\<and> state_rank (token_run t' y) y = Some j') \\<or>\n  t' = Suc y\n  token_run t (Suc y) = token_run t' (Suc y)\n  token_run t (Suc y) \\<notin> F\n  state_rank (token_run t y) y = Some j\n  j < i\n\ngoal (1 subgoal):\n 1. x \\<in> local.merge i", "unfolding merge_def"], ["proof (prove)\nusing this:\n  t' \\<le> y\n  x = (t, t')\n  t \\<le> y\n  (\\<exists>j'.\n      token_run t y \\<noteq> token_run t' y \\<and>\n      t' \\<le> y \\<and> state_rank (token_run t' y) y = Some j') \\<or>\n  t' = Suc y\n  token_run t (Suc y) = token_run t' (Suc y)\n  token_run t (Suc y) \\<notin> F\n  state_rank (token_run t y) y = Some j\n  j < i\n\ngoal (1 subgoal):\n 1. x \\<in> {uu_.\n             \\<exists>x y n j.\n                uu_ = (x, y) \\<and>\n                j < i \\<and>\n                (token_run x n \\<noteq> token_run y n \\<and>\n                 rank y n \\<noteq> None \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and> rank x n = Some j}", "unfolding rank_eq_state_rank[OF \\<open>t' \\<le> y\\<close>, symmetric] rank_eq_state_rank[OF \\<open>t \\<le> y\\<close>, symmetric]"], ["proof (prove)\nusing this:\n  t' \\<le> y\n  x = (t, t')\n  t \\<le> y\n  (\\<exists>j'.\n      token_run t y \\<noteq> token_run t' y \\<and>\n      t' \\<le> y \\<and> rank t' y = Some j') \\<or>\n  t' = Suc y\n  token_run t (Suc y) = token_run t' (Suc y)\n  token_run t (Suc y) \\<notin> F\n  rank t y = Some j\n  j < i\n\ngoal (1 subgoal):\n 1. x \\<in> {uu_.\n             \\<exists>x y n j.\n                uu_ = (x, y) \\<and>\n                j < i \\<and>\n                (token_run x n \\<noteq> token_run y n \\<and>\n                 rank y n \\<noteq> None \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and> rank x n = Some j}", "by blast"], ["proof (state)\nthis:\n  x \\<in> local.merge i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = (t, t'); t \\<le> y;\n     (\\<exists>j'.\n         token_run t y \\<noteq> token_run t' y \\<and>\n         t' \\<le> y \\<and> state_rank (token_run t' y) y = Some j') \\<or>\n     t' = Suc y;\n     token_run t (Suc y) = token_run t' (Suc y);\n     token_run t (Suc y) \\<notin> F; state_rank (token_run t y) y = Some j;\n     j < i; t' = Suc y\\<rbrakk>\n    \\<Longrightarrow> x \\<in> local.merge i", "qed (unfold rank_eq_state_rank[OF \\<open>t \\<le> y\\<close>, symmetric] merge_def, blast)"], ["proof (state)\nthis:\n  x \\<in> local.merge i\n\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       y \\<in> merge_t i\n 3. \\<And>x y.\n       (case x of\n        (x, y) \\<Rightarrow>\n          \\<lambda>n.\n             \\<exists>j.\n                x \\<le> n \\<and>\n                ((\\<exists>j'.\n                     token_run x n \\<noteq> token_run y n \\<and>\n                     y \\<le> n \\<and>\n                     state_rank (token_run y n) n = Some j') \\<or>\n                 y = Suc n) \\<and>\n                token_run x (Suc n) = token_run y (Suc n) \\<and>\n                token_run x (Suc n) \\<notin> F \\<and>\n                state_rank (token_run x n) n = Some j \\<and> j < i)\n        y \\<Longrightarrow>\n       fst x \\<le> y + ?c \\<and> snd x \\<le> y + ?d", "show \"y \\<in> merge_t i\" and \"fst x \\<le> y + 0 \\<and> snd x \\<le> y + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> merge_t i &&& fst x \\<le> y + 0 \\<and> snd x \\<le> y + 1", "using merge_t_inclusion \\<open>?P x y\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?n;\n   (\\<exists>j'.\n       token_run ?x ?n \\<noteq> token_run ?y ?n \\<and>\n       ?y \\<le> ?n \\<and> state_rank (token_run ?y ?n) ?n = Some j') \\<or>\n   ?y = Suc ?n;\n   token_run ?x (Suc ?n) = token_run ?y (Suc ?n);\n   token_run ?x (Suc ?n) \\<notin> F;\n   state_rank (token_run ?x ?n) ?n = Some ?j; ?j < ?i\\<rbrakk>\n  \\<Longrightarrow> ?n \\<in> merge_t ?i\n  (case x of\n   (x, y) \\<Rightarrow>\n     \\<lambda>n.\n        \\<exists>j.\n           x \\<le> n \\<and>\n           ((\\<exists>j'.\n                token_run x n \\<noteq> token_run y n \\<and>\n                y \\<le> n \\<and>\n                state_rank (token_run y n) n = Some j') \\<or>\n            y = Suc n) \\<and>\n           token_run x (Suc n) = token_run y (Suc n) \\<and>\n           token_run x (Suc n) \\<notin> F \\<and>\n           state_rank (token_run x n) n = Some j \\<and> j < i)\n   y\n\ngoal (1 subgoal):\n 1. y \\<in> merge_t i &&& fst x \\<le> y + 0 \\<and> snd x \\<le> y + 1", "by force+"], ["proof (state)\nthis:\n  y \\<in> merge_t i\n  fst x \\<le> y + 0 \\<and> snd x \\<le> y + 1\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z", "}\n\n  \\<comment> \\<open>Uniqueness\\<close>"], ["proof (state)\nthis:\n  (case ?x2 of\n   (x, y) \\<Rightarrow>\n     \\<lambda>n.\n        \\<exists>j.\n           x \\<le> n \\<and>\n           ((\\<exists>j'.\n                token_run x n \\<noteq> token_run y n \\<and>\n                y \\<le> n \\<and>\n                state_rank (token_run y n) n = Some j') \\<or>\n            y = Suc n) \\<and>\n           token_run x (Suc n) = token_run y (Suc n) \\<and>\n           token_run x (Suc n) \\<notin> F \\<and>\n           state_rank (token_run x n) n = Some j \\<and> j < i)\n   ?y2 \\<Longrightarrow>\n  ?y2 \\<in> merge_t i\n  (case ?x2 of\n   (x, y) \\<Rightarrow>\n     \\<lambda>n.\n        \\<exists>j.\n           x \\<le> n \\<and>\n           ((\\<exists>j'.\n                token_run x n \\<noteq> token_run y n \\<and>\n                y \\<le> n \\<and>\n                state_rank (token_run y n) n = Some j') \\<or>\n            y = Suc n) \\<and>\n           token_run x (Suc n) = token_run y (Suc n) \\<and>\n           token_run x (Suc n) \\<notin> F \\<and>\n           state_rank (token_run x n) n = Some j \\<and> j < i)\n   ?y2 \\<Longrightarrow>\n  fst ?x2 \\<le> ?y2 + 0 \\<and> snd ?x2 \\<le> ?y2 + 1\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z", "{"], ["proof (state)\nthis:\n  (case ?x2 of\n   (x, y) \\<Rightarrow>\n     \\<lambda>n.\n        \\<exists>j.\n           x \\<le> n \\<and>\n           ((\\<exists>j'.\n                token_run x n \\<noteq> token_run y n \\<and>\n                y \\<le> n \\<and>\n                state_rank (token_run y n) n = Some j') \\<or>\n            y = Suc n) \\<and>\n           token_run x (Suc n) = token_run y (Suc n) \\<and>\n           token_run x (Suc n) \\<notin> F \\<and>\n           state_rank (token_run x n) n = Some j \\<and> j < i)\n   ?y2 \\<Longrightarrow>\n  ?y2 \\<in> merge_t i\n  (case ?x2 of\n   (x, y) \\<Rightarrow>\n     \\<lambda>n.\n        \\<exists>j.\n           x \\<le> n \\<and>\n           ((\\<exists>j'.\n                token_run x n \\<noteq> token_run y n \\<and>\n                y \\<le> n \\<and>\n                state_rank (token_run y n) n = Some j') \\<or>\n            y = Suc n) \\<and>\n           token_run x (Suc n) = token_run y (Suc n) \\<and>\n           token_run x (Suc n) \\<notin> F \\<and>\n           state_rank (token_run x n) n = Some j \\<and> j < i)\n   ?y2 \\<Longrightarrow>\n  fst ?x2 \\<le> ?y2 + 0 \\<and> snd ?x2 \\<le> ?y2 + 1\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z", "fix x y z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z", "assume \"?P x y\" and \"?P x z\""], ["proof (state)\nthis:\n  (case x of\n   (x, y) \\<Rightarrow>\n     \\<lambda>n.\n        \\<exists>j.\n           x \\<le> n \\<and>\n           ((\\<exists>j'.\n                token_run x n \\<noteq> token_run y n \\<and>\n                y \\<le> n \\<and>\n                state_rank (token_run y n) n = Some j') \\<or>\n            y = Suc n) \\<and>\n           token_run x (Suc n) = token_run y (Suc n) \\<and>\n           token_run x (Suc n) \\<notin> F \\<and>\n           state_rank (token_run x n) n = Some j \\<and> j < i)\n   y\n  (case x of\n   (x, y) \\<Rightarrow>\n     \\<lambda>n.\n        \\<exists>j.\n           x \\<le> n \\<and>\n           ((\\<exists>j'.\n                token_run x n \\<noteq> token_run y n \\<and>\n                y \\<le> n \\<and>\n                state_rank (token_run y n) n = Some j') \\<or>\n            y = Suc n) \\<and>\n           token_run x (Suc n) = token_run y (Suc n) \\<and>\n           token_run x (Suc n) \\<notin> F \\<and>\n           state_rank (token_run x n) n = Some j \\<and> j < i)\n   z\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z", "then"], ["proof (chain)\npicking this:\n  (case x of\n   (x, y) \\<Rightarrow>\n     \\<lambda>n.\n        \\<exists>j.\n           x \\<le> n \\<and>\n           ((\\<exists>j'.\n                token_run x n \\<noteq> token_run y n \\<and>\n                y \\<le> n \\<and>\n                state_rank (token_run y n) n = Some j') \\<or>\n            y = Suc n) \\<and>\n           token_run x (Suc n) = token_run y (Suc n) \\<and>\n           token_run x (Suc n) \\<notin> F \\<and>\n           state_rank (token_run x n) n = Some j \\<and> j < i)\n   y\n  (case x of\n   (x, y) \\<Rightarrow>\n     \\<lambda>n.\n        \\<exists>j.\n           x \\<le> n \\<and>\n           ((\\<exists>j'.\n                token_run x n \\<noteq> token_run y n \\<and>\n                y \\<le> n \\<and>\n                state_rank (token_run y n) n = Some j') \\<or>\n            y = Suc n) \\<and>\n           token_run x (Suc n) = token_run y (Suc n) \\<and>\n           token_run x (Suc n) \\<notin> F \\<and>\n           state_rank (token_run x n) n = Some j \\<and> j < i)\n   z", "obtain t t' where \"x = (t, t')\""], ["proof (prove)\nusing this:\n  (case x of\n   (x, y) \\<Rightarrow>\n     \\<lambda>n.\n        \\<exists>j.\n           x \\<le> n \\<and>\n           ((\\<exists>j'.\n                token_run x n \\<noteq> token_run y n \\<and>\n                y \\<le> n \\<and>\n                state_rank (token_run y n) n = Some j') \\<or>\n            y = Suc n) \\<and>\n           token_run x (Suc n) = token_run y (Suc n) \\<and>\n           token_run x (Suc n) \\<notin> F \\<and>\n           state_rank (token_run x n) n = Some j \\<and> j < i)\n   y\n  (case x of\n   (x, y) \\<Rightarrow>\n     \\<lambda>n.\n        \\<exists>j.\n           x \\<le> n \\<and>\n           ((\\<exists>j'.\n                token_run x n \\<noteq> token_run y n \\<and>\n                y \\<le> n \\<and>\n                state_rank (token_run y n) n = Some j') \\<or>\n            y = Suc n) \\<and>\n           token_run x (Suc n) = token_run y (Suc n) \\<and>\n           token_run x (Suc n) \\<notin> F \\<and>\n           state_rank (token_run x n) n = Some j \\<and> j < i)\n   z\n\ngoal (1 subgoal):\n 1. (\\<And>t t'. x = (t, t') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x = (t, t')\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z", "from \\<open>?P x y\\<close>[unfolded \\<open>x = (t, t')\\<close>]"], ["proof (chain)\npicking this:\n  (case (t, t') of\n   (x, y) \\<Rightarrow>\n     \\<lambda>n.\n        \\<exists>j.\n           x \\<le> n \\<and>\n           ((\\<exists>j'.\n                token_run x n \\<noteq> token_run y n \\<and>\n                y \\<le> n \\<and>\n                state_rank (token_run y n) n = Some j') \\<or>\n            y = Suc n) \\<and>\n           token_run x (Suc n) = token_run y (Suc n) \\<and>\n           token_run x (Suc n) \\<notin> F \\<and>\n           state_rank (token_run x n) n = Some j \\<and> j < i)\n   y", "have y1: \"t \\<le> y\"\n      and y2: \"(token_run t y \\<noteq> token_run t' y \\<and> t' \\<le> y) \\<or> t' = Suc y\"\n      and y3: \"token_run t (Suc y) = token_run t' (Suc y)\""], ["proof (prove)\nusing this:\n  (case (t, t') of\n   (x, y) \\<Rightarrow>\n     \\<lambda>n.\n        \\<exists>j.\n           x \\<le> n \\<and>\n           ((\\<exists>j'.\n                token_run x n \\<noteq> token_run y n \\<and>\n                y \\<le> n \\<and>\n                state_rank (token_run y n) n = Some j') \\<or>\n            y = Suc n) \\<and>\n           token_run x (Suc n) = token_run y (Suc n) \\<and>\n           token_run x (Suc n) \\<notin> F \\<and>\n           state_rank (token_run x n) n = Some j \\<and> j < i)\n   y\n\ngoal (1 subgoal):\n 1. t \\<le> y &&&\n    token_run t y \\<noteq> token_run t' y \\<and> t' \\<le> y \\<or>\n    t' = Suc y &&&\n    token_run t (Suc y) = token_run t' (Suc y)", "by blast+"], ["proof (state)\nthis:\n  t \\<le> y\n  token_run t y \\<noteq> token_run t' y \\<and> t' \\<le> y \\<or> t' = Suc y\n  token_run t (Suc y) = token_run t' (Suc y)\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z", "moreover"], ["proof (state)\nthis:\n  t \\<le> y\n  token_run t y \\<noteq> token_run t' y \\<and> t' \\<le> y \\<or> t' = Suc y\n  token_run t (Suc y) = token_run t' (Suc y)\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z", "from \\<open>?P x z\\<close>[unfolded \\<open>x = (t, t')\\<close>]"], ["proof (chain)\npicking this:\n  (case (t, t') of\n   (x, y) \\<Rightarrow>\n     \\<lambda>n.\n        \\<exists>j.\n           x \\<le> n \\<and>\n           ((\\<exists>j'.\n                token_run x n \\<noteq> token_run y n \\<and>\n                y \\<le> n \\<and>\n                state_rank (token_run y n) n = Some j') \\<or>\n            y = Suc n) \\<and>\n           token_run x (Suc n) = token_run y (Suc n) \\<and>\n           token_run x (Suc n) \\<notin> F \\<and>\n           state_rank (token_run x n) n = Some j \\<and> j < i)\n   z", "have z1: \"t \\<le> z\"\n      and z2: \"(token_run t z \\<noteq> token_run t' z \\<and> t' \\<le> z) \\<or> t' = Suc z\"\n      and z3: \"token_run t (Suc z) = token_run t' (Suc z)\""], ["proof (prove)\nusing this:\n  (case (t, t') of\n   (x, y) \\<Rightarrow>\n     \\<lambda>n.\n        \\<exists>j.\n           x \\<le> n \\<and>\n           ((\\<exists>j'.\n                token_run x n \\<noteq> token_run y n \\<and>\n                y \\<le> n \\<and>\n                state_rank (token_run y n) n = Some j') \\<or>\n            y = Suc n) \\<and>\n           token_run x (Suc n) = token_run y (Suc n) \\<and>\n           token_run x (Suc n) \\<notin> F \\<and>\n           state_rank (token_run x n) n = Some j \\<and> j < i)\n   z\n\ngoal (1 subgoal):\n 1. t \\<le> z &&&\n    token_run t z \\<noteq> token_run t' z \\<and> t' \\<le> z \\<or>\n    t' = Suc z &&&\n    token_run t (Suc z) = token_run t' (Suc z)", "by blast+"], ["proof (state)\nthis:\n  t \\<le> z\n  token_run t z \\<noteq> token_run t' z \\<and> t' \\<le> z \\<or> t' = Suc z\n  token_run t (Suc z) = token_run t' (Suc z)\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z", "moreover"], ["proof (state)\nthis:\n  t \\<le> z\n  token_run t z \\<noteq> token_run t' z \\<and> t' \\<le> z \\<or> t' = Suc z\n  token_run t (Suc z) = token_run t' (Suc z)\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z", "have y4: \"t' \\<le> Suc y\" and z4: \"t' \\<le> Suc z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t' \\<le> Suc y &&& t' \\<le> Suc z", "using y2 z2"], ["proof (prove)\nusing this:\n  token_run t y \\<noteq> token_run t' y \\<and> t' \\<le> y \\<or> t' = Suc y\n  token_run t z \\<noteq> token_run t' z \\<and> t' \\<le> z \\<or> t' = Suc z\n\ngoal (1 subgoal):\n 1. t' \\<le> Suc y &&& t' \\<le> Suc z", "by linarith+"], ["proof (state)\nthis:\n  t' \\<le> Suc y\n  t' \\<le> Suc z\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(case x of\n                 (x, y) \\<Rightarrow>\n                   \\<lambda>n.\n                      \\<exists>j.\n                         x \\<le> n \\<and>\n                         ((\\<exists>j'.\n                              token_run x n \\<noteq> token_run y n \\<and>\n                              y \\<le> n \\<and>\n                              state_rank (token_run y n) n = Some j') \\<or>\n                          y = Suc n) \\<and>\n                         token_run x (Suc n) = token_run y (Suc n) \\<and>\n                         token_run x (Suc n) \\<notin> F \\<and>\n                         state_rank (token_run x n) n = Some j \\<and> j < i)\n                 y;\n        (case x of\n         (x, y) \\<Rightarrow>\n           \\<lambda>n.\n              \\<exists>j.\n                 x \\<le> n \\<and>\n                 ((\\<exists>j'.\n                      token_run x n \\<noteq> token_run y n \\<and>\n                      y \\<le> n \\<and>\n                      state_rank (token_run y n) n = Some j') \\<or>\n                  y = Suc n) \\<and>\n                 token_run x (Suc n) = token_run y (Suc n) \\<and>\n                 token_run x (Suc n) \\<notin> F \\<and>\n                 state_rank (token_run x n) n = Some j \\<and> j < i)\n         z\\<rbrakk>\n       \\<Longrightarrow> y = z", "ultimately"], ["proof (chain)\npicking this:\n  t \\<le> y\n  token_run t y \\<noteq> token_run t' y \\<and> t' \\<le> y \\<or> t' = Suc y\n  token_run t (Suc y) = token_run t' (Suc y)\n  t \\<le> z\n  token_run t z \\<noteq> token_run t' z \\<and> t' \\<le> z \\<or> t' = Suc z\n  token_run t (Suc z) = token_run t' (Suc z)\n  t' \\<le> Suc y\n  t' \\<le> Suc z", "show \"y = z\""], ["proof (prove)\nusing this:\n  t \\<le> y\n  token_run t y \\<noteq> token_run t' y \\<and> t' \\<le> y \\<or> t' = Suc y\n  token_run t (Suc y) = token_run t' (Suc y)\n  t \\<le> z\n  token_run t z \\<noteq> token_run t' z \\<and> t' \\<le> z \\<or> t' = Suc z\n  token_run t (Suc z) = token_run t' (Suc z)\n  t' \\<le> Suc y\n  t' \\<le> Suc z\n\ngoal (1 subgoal):\n 1. y = z", "proof (cases y z rule: linorder_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>t \\<le> y;\n     token_run t y \\<noteq> token_run t' y \\<and> t' \\<le> y \\<or>\n     t' = Suc y;\n     token_run t (Suc y) = token_run t' (Suc y); t \\<le> z;\n     token_run t z \\<noteq> token_run t' z \\<and> t' \\<le> z \\<or>\n     t' = Suc z;\n     token_run t (Suc z) = token_run t' (Suc z); t' \\<le> Suc y;\n     t' \\<le> Suc z; y < z\\<rbrakk>\n    \\<Longrightarrow> y = z\n 2. \\<lbrakk>t \\<le> y;\n     token_run t y \\<noteq> token_run t' y \\<and> t' \\<le> y \\<or>\n     t' = Suc y;\n     token_run t (Suc y) = token_run t' (Suc y); t \\<le> z;\n     token_run t z \\<noteq> token_run t' z \\<and> t' \\<le> z \\<or>\n     t' = Suc z;\n     token_run t (Suc z) = token_run t' (Suc z); t' \\<le> Suc y;\n     t' \\<le> Suc z; y = z\\<rbrakk>\n    \\<Longrightarrow> y = z\n 3. \\<lbrakk>t \\<le> y;\n     token_run t y \\<noteq> token_run t' y \\<and> t' \\<le> y \\<or>\n     t' = Suc y;\n     token_run t (Suc y) = token_run t' (Suc y); t \\<le> z;\n     token_run t z \\<noteq> token_run t' z \\<and> t' \\<le> z \\<or>\n     t' = Suc z;\n     token_run t (Suc z) = token_run t' (Suc z); t' \\<le> Suc y;\n     t' \\<le> Suc z; z < y\\<rbrakk>\n    \\<Longrightarrow> y = z", "case less"], ["proof (state)\nthis:\n  y < z\n\ngoal (3 subgoals):\n 1. \\<lbrakk>t \\<le> y;\n     token_run t y \\<noteq> token_run t' y \\<and> t' \\<le> y \\<or>\n     t' = Suc y;\n     token_run t (Suc y) = token_run t' (Suc y); t \\<le> z;\n     token_run t z \\<noteq> token_run t' z \\<and> t' \\<le> z \\<or>\n     t' = Suc z;\n     token_run t (Suc z) = token_run t' (Suc z); t' \\<le> Suc y;\n     t' \\<le> Suc z; y < z\\<rbrakk>\n    \\<Longrightarrow> y = z\n 2. \\<lbrakk>t \\<le> y;\n     token_run t y \\<noteq> token_run t' y \\<and> t' \\<le> y \\<or>\n     t' = Suc y;\n     token_run t (Suc y) = token_run t' (Suc y); t \\<le> z;\n     token_run t z \\<noteq> token_run t' z \\<and> t' \\<le> z \\<or>\n     t' = Suc z;\n     token_run t (Suc z) = token_run t' (Suc z); t' \\<le> Suc y;\n     t' \\<le> Suc z; y = z\\<rbrakk>\n    \\<Longrightarrow> y = z\n 3. \\<lbrakk>t \\<le> y;\n     token_run t y \\<noteq> token_run t' y \\<and> t' \\<le> y \\<or>\n     t' = Suc y;\n     token_run t (Suc y) = token_run t' (Suc y); t \\<le> z;\n     token_run t z \\<noteq> token_run t' z \\<and> t' \\<le> z \\<or>\n     t' = Suc z;\n     token_run t (Suc z) = token_run t' (Suc z); t' \\<le> Suc y;\n     t' \\<le> Suc z; z < y\\<rbrakk>\n    \\<Longrightarrow> y = z", "then"], ["proof (chain)\npicking this:\n  y < z", "obtain d where \"Suc y + d = z\""], ["proof (prove)\nusing this:\n  y < z\n\ngoal (1 subgoal):\n 1. (\\<And>d. Suc y + d = z \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis add_Suc_right add_Suc_shift less_imp_Suc_add)"], ["proof (state)\nthis:\n  Suc y + d = z\n\ngoal (3 subgoals):\n 1. \\<lbrakk>t \\<le> y;\n     token_run t y \\<noteq> token_run t' y \\<and> t' \\<le> y \\<or>\n     t' = Suc y;\n     token_run t (Suc y) = token_run t' (Suc y); t \\<le> z;\n     token_run t z \\<noteq> token_run t' z \\<and> t' \\<le> z \\<or>\n     t' = Suc z;\n     token_run t (Suc z) = token_run t' (Suc z); t' \\<le> Suc y;\n     t' \\<le> Suc z; y < z\\<rbrakk>\n    \\<Longrightarrow> y = z\n 2. \\<lbrakk>t \\<le> y;\n     token_run t y \\<noteq> token_run t' y \\<and> t' \\<le> y \\<or>\n     t' = Suc y;\n     token_run t (Suc y) = token_run t' (Suc y); t \\<le> z;\n     token_run t z \\<noteq> token_run t' z \\<and> t' \\<le> z \\<or>\n     t' = Suc z;\n     token_run t (Suc z) = token_run t' (Suc z); t' \\<le> Suc y;\n     t' \\<le> Suc z; y = z\\<rbrakk>\n    \\<Longrightarrow> y = z\n 3. \\<lbrakk>t \\<le> y;\n     token_run t y \\<noteq> token_run t' y \\<and> t' \\<le> y \\<or>\n     t' = Suc y;\n     token_run t (Suc y) = token_run t' (Suc y); t \\<le> z;\n     token_run t z \\<noteq> token_run t' z \\<and> t' \\<le> z \\<or>\n     t' = Suc z;\n     token_run t (Suc z) = token_run t' (Suc z); t' \\<le> Suc y;\n     t' \\<le> Suc z; z < y\\<rbrakk>\n    \\<Longrightarrow> y = z", "thus ?thesis"], ["proof (prove)\nusing this:\n  Suc y + d = z\n\ngoal (1 subgoal):\n 1. y = z", "using y1 y2 z2 token_run_merge[OF _ y4 y3]"], ["proof (prove)\nusing this:\n  Suc y + d = z\n  t \\<le> y\n  token_run t y \\<noteq> token_run t' y \\<and> t' \\<le> y \\<or> t' = Suc y\n  token_run t z \\<noteq> token_run t' z \\<and> t' \\<le> z \\<or> t' = Suc z\n  t \\<le> Suc y \\<Longrightarrow>\n  token_run t (Suc y + ?m) = token_run t' (Suc y + ?m)\n\ngoal (1 subgoal):\n 1. y = z", "by auto"], ["proof (state)\nthis:\n  y = z\n\ngoal (2 subgoals):\n 1. \\<lbrakk>t \\<le> y;\n     token_run t y \\<noteq> token_run t' y \\<and> t' \\<le> y \\<or>\n     t' = Suc y;\n     token_run t (Suc y) = token_run t' (Suc y); t \\<le> z;\n     token_run t z \\<noteq> token_run t' z \\<and> t' \\<le> z \\<or>\n     t' = Suc z;\n     token_run t (Suc z) = token_run t' (Suc z); t' \\<le> Suc y;\n     t' \\<le> Suc z; y = z\\<rbrakk>\n    \\<Longrightarrow> y = z\n 2. \\<lbrakk>t \\<le> y;\n     token_run t y \\<noteq> token_run t' y \\<and> t' \\<le> y \\<or>\n     t' = Suc y;\n     token_run t (Suc y) = token_run t' (Suc y); t \\<le> z;\n     token_run t z \\<noteq> token_run t' z \\<and> t' \\<le> z \\<or>\n     t' = Suc z;\n     token_run t (Suc z) = token_run t' (Suc z); t' \\<le> Suc y;\n     t' \\<le> Suc z; z < y\\<rbrakk>\n    \\<Longrightarrow> y = z", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>t \\<le> y;\n     token_run t y \\<noteq> token_run t' y \\<and> t' \\<le> y \\<or>\n     t' = Suc y;\n     token_run t (Suc y) = token_run t' (Suc y); t \\<le> z;\n     token_run t z \\<noteq> token_run t' z \\<and> t' \\<le> z \\<or>\n     t' = Suc z;\n     token_run t (Suc z) = token_run t' (Suc z); t' \\<le> Suc y;\n     t' \\<le> Suc z; y = z\\<rbrakk>\n    \\<Longrightarrow> y = z\n 2. \\<lbrakk>t \\<le> y;\n     token_run t y \\<noteq> token_run t' y \\<and> t' \\<le> y \\<or>\n     t' = Suc y;\n     token_run t (Suc y) = token_run t' (Suc y); t \\<le> z;\n     token_run t z \\<noteq> token_run t' z \\<and> t' \\<le> z \\<or>\n     t' = Suc z;\n     token_run t (Suc z) = token_run t' (Suc z); t' \\<le> Suc y;\n     t' \\<le> Suc z; z < y\\<rbrakk>\n    \\<Longrightarrow> y = z", "case greater"], ["proof (state)\nthis:\n  z < y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>t \\<le> y;\n     token_run t y \\<noteq> token_run t' y \\<and> t' \\<le> y \\<or>\n     t' = Suc y;\n     token_run t (Suc y) = token_run t' (Suc y); t \\<le> z;\n     token_run t z \\<noteq> token_run t' z \\<and> t' \\<le> z \\<or>\n     t' = Suc z;\n     token_run t (Suc z) = token_run t' (Suc z); t' \\<le> Suc y;\n     t' \\<le> Suc z; y = z\\<rbrakk>\n    \\<Longrightarrow> y = z\n 2. \\<lbrakk>t \\<le> y;\n     token_run t y \\<noteq> token_run t' y \\<and> t' \\<le> y \\<or>\n     t' = Suc y;\n     token_run t (Suc y) = token_run t' (Suc y); t \\<le> z;\n     token_run t z \\<noteq> token_run t' z \\<and> t' \\<le> z \\<or>\n     t' = Suc z;\n     token_run t (Suc z) = token_run t' (Suc z); t' \\<le> Suc y;\n     t' \\<le> Suc z; z < y\\<rbrakk>\n    \\<Longrightarrow> y = z", "then"], ["proof (chain)\npicking this:\n  z < y", "obtain d where \"Suc z + d = y\""], ["proof (prove)\nusing this:\n  z < y\n\ngoal (1 subgoal):\n 1. (\\<And>d. Suc z + d = y \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis add_Suc_right add_Suc_shift less_imp_Suc_add)"], ["proof (state)\nthis:\n  Suc z + d = y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>t \\<le> y;\n     token_run t y \\<noteq> token_run t' y \\<and> t' \\<le> y \\<or>\n     t' = Suc y;\n     token_run t (Suc y) = token_run t' (Suc y); t \\<le> z;\n     token_run t z \\<noteq> token_run t' z \\<and> t' \\<le> z \\<or>\n     t' = Suc z;\n     token_run t (Suc z) = token_run t' (Suc z); t' \\<le> Suc y;\n     t' \\<le> Suc z; y = z\\<rbrakk>\n    \\<Longrightarrow> y = z\n 2. \\<lbrakk>t \\<le> y;\n     token_run t y \\<noteq> token_run t' y \\<and> t' \\<le> y \\<or>\n     t' = Suc y;\n     token_run t (Suc y) = token_run t' (Suc y); t \\<le> z;\n     token_run t z \\<noteq> token_run t' z \\<and> t' \\<le> z \\<or>\n     t' = Suc z;\n     token_run t (Suc z) = token_run t' (Suc z); t' \\<le> Suc y;\n     t' \\<le> Suc z; z < y\\<rbrakk>\n    \\<Longrightarrow> y = z", "thus ?thesis"], ["proof (prove)\nusing this:\n  Suc z + d = y\n\ngoal (1 subgoal):\n 1. y = z", "using z1 y2 z2 token_run_merge[OF _ z4 z3]"], ["proof (prove)\nusing this:\n  Suc z + d = y\n  t \\<le> z\n  token_run t y \\<noteq> token_run t' y \\<and> t' \\<le> y \\<or> t' = Suc y\n  token_run t z \\<noteq> token_run t' z \\<and> t' \\<le> z \\<or> t' = Suc z\n  t \\<le> Suc z \\<Longrightarrow>\n  token_run t (Suc z + ?m) = token_run t' (Suc z + ?m)\n\ngoal (1 subgoal):\n 1. y = z", "by auto"], ["proof (state)\nthis:\n  y = z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<le> y;\n     token_run t y \\<noteq> token_run t' y \\<and> t' \\<le> y \\<or>\n     t' = Suc y;\n     token_run t (Suc y) = token_run t' (Suc y); t \\<le> z;\n     token_run t z \\<noteq> token_run t' z \\<and> t' \\<le> z \\<or>\n     t' = Suc z;\n     token_run t (Suc z) = token_run t' (Suc z); t' \\<le> Suc y;\n     t' \\<le> Suc z; y = z\\<rbrakk>\n    \\<Longrightarrow> y = z", "qed"], ["proof (state)\nthis:\n  y = z\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(case ?x2 of\n            (x, y) \\<Rightarrow>\n              \\<lambda>n.\n                 \\<exists>j.\n                    x \\<le> n \\<and>\n                    ((\\<exists>j'.\n                         token_run x n \\<noteq> token_run y n \\<and>\n                         y \\<le> n \\<and>\n                         state_rank (token_run y n) n = Some j') \\<or>\n                     y = Suc n) \\<and>\n                    token_run x (Suc n) = token_run y (Suc n) \\<and>\n                    token_run x (Suc n) \\<notin> F \\<and>\n                    state_rank (token_run x n) n = Some j \\<and> j < i)\n            ?y2;\n   (case ?x2 of\n    (x, y) \\<Rightarrow>\n      \\<lambda>n.\n         \\<exists>j.\n            x \\<le> n \\<and>\n            ((\\<exists>j'.\n                 token_run x n \\<noteq> token_run y n \\<and>\n                 y \\<le> n \\<and>\n                 state_rank (token_run y n) n = Some j') \\<or>\n             y = Suc n) \\<and>\n            token_run x (Suc n) = token_run y (Suc n) \\<and>\n            token_run x (Suc n) \\<notin> F \\<and>\n            state_rank (token_run x n) n = Some j \\<and> j < i)\n    ?z2\\<rbrakk>\n  \\<Longrightarrow> ?y2 = ?z2\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Relation to Mojmir Acceptance\\<close>"], ["", "lemma token_iff_time_accept:\n  shows \"(finite fail \\<and> finite (merge i) \\<and> infinite (succeed i) \\<and> (\\<forall>j < i. finite (succeed j)))\n       = (finite fail_t \\<and> finite (merge_t i) \\<and> infinite (succeed_t i) \\<and> (\\<forall>j < i. finite (succeed_t j)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (finite fail \\<and>\n     finite (local.merge i) \\<and>\n     infinite (succeed i) \\<and> (\\<forall>j<i. finite (succeed j))) =\n    (finite fail_t \\<and>\n     finite (merge_t i) \\<and>\n     infinite (succeed_t i) \\<and> (\\<forall>j<i. finite (succeed_t j)))", "unfolding finite_fail_t finite_merge_t finite_succeed_t"], ["proof (prove)\ngoal (1 subgoal):\n 1. (finite fail_t \\<and>\n     finite (merge_t i) \\<and>\n     infinite (succeed_t i) \\<and> (\\<forall>j<i. finite (succeed_t j))) =\n    (finite fail_t \\<and>\n     finite (merge_t i) \\<and>\n     infinite (succeed_t i) \\<and> (\\<forall>j<i. finite (succeed_t j)))", "by simp"], ["", "subsection \\<open>Succeeding Tokens (Alternative Definition)\\<close>"], ["", "definition stable_rank_at :: \"nat \\<Rightarrow> nat \\<Rightarrow> bool\"\nwhere\n  \"stable_rank_at x n \\<equiv> \\<exists>i. \\<forall>m \\<ge> n. rank x m = Some i\""], ["", "lemma stable_rank_at_ge:\n  \"n \\<le> m \\<Longrightarrow> stable_rank_at x n \\<Longrightarrow> stable_rank_at x m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> m; stable_rank_at x n\\<rbrakk>\n    \\<Longrightarrow> stable_rank_at x m", "unfolding stable_rank_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> m;\n     \\<exists>i. \\<forall>m\\<ge>n. rank x m = Some i\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i. \\<forall>ma\\<ge>m. rank x ma = Some i", "by fastforce"], ["", "lemma stable_rank_equiv:\n  \"(\\<exists>i. stable_rank x i) = (\\<exists>n. stable_rank_at x n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>i. stable_rank x i) = (\\<exists>n. stable_rank_at x n)", "unfolding stable_rank_def MOST_nat_le stable_rank_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>i m. \\<forall>n\\<ge>m. rank x n = Some i) =\n    (\\<exists>n i. \\<forall>m\\<ge>n. rank x m = Some i)", "by blast"], ["", "lemma smallest_accepting_rank_properties:\n  assumes \"smallest_accepting_rank = Some i\"\n  shows \"accept\" \"finite fail\" \"finite (merge i)\" \"infinite (succeed i)\" \"\\<forall>j < i. finite (succeed j)\" \"i < max_rank\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (accept\\<^sub>M &&& finite fail &&& finite (local.merge i)) &&&\n    infinite (succeed i) &&&\n    \\<forall>j<i. finite (succeed j) &&& i < max_rank", "proof -"], ["proof (state)\ngoal (6 subgoals):\n 1. accept\\<^sub>M\n 2. finite fail\n 3. finite (local.merge i)\n 4. infinite (succeed i)\n 5. \\<forall>j<i. finite (succeed j)\n 6. i < max_rank", "from assms"], ["proof (chain)\npicking this:\n  smallest_accepting_rank = Some i", "show \"accept\""], ["proof (prove)\nusing this:\n  smallest_accepting_rank = Some i\n\ngoal (1 subgoal):\n 1. accept\\<^sub>M", "unfolding smallest_accepting_rank_def"], ["proof (prove)\nusing this:\n  (if accept\\<^sub>M\n   then Some\n         (LEAST i.\n             finite fail \\<and>\n             finite (local.merge i) \\<and> infinite (succeed i))\n   else None) =\n  Some i\n\ngoal (1 subgoal):\n 1. accept\\<^sub>M", "using option.distinct(1)"], ["proof (prove)\nusing this:\n  (if accept\\<^sub>M\n   then Some\n         (LEAST i.\n             finite fail \\<and>\n             finite (local.merge i) \\<and> infinite (succeed i))\n   else None) =\n  Some i\n  None \\<noteq> Some ?x2.0\n\ngoal (1 subgoal):\n 1. accept\\<^sub>M", "by metis"], ["proof (state)\nthis:\n  accept\\<^sub>M\n\ngoal (5 subgoals):\n 1. finite fail\n 2. finite (local.merge i)\n 3. infinite (succeed i)\n 4. \\<forall>j<i. finite (succeed j)\n 5. i < max_rank", "then"], ["proof (chain)\npicking this:\n  accept\\<^sub>M", "obtain i' where \"finite fail\" and \"finite (merge i')\" and \"infinite (succeed i')\"\n    and \"\\<forall>j < i'. finite (succeed j)\" and \"i' < max_rank\""], ["proof (prove)\nusing this:\n  accept\\<^sub>M\n\ngoal (1 subgoal):\n 1. (\\<And>i'.\n        \\<lbrakk>finite fail; finite (local.merge i');\n         infinite (succeed i'); \\<forall>j<i'. finite (succeed j);\n         i' < max_rank\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding mojmir_accept_iff_token_set_accept2"], ["proof (prove)\nusing this:\n  \\<exists>i<max_rank.\n     finite fail \\<and>\n     finite (local.merge i) \\<and>\n     infinite (succeed i) \\<and>\n     (\\<forall>j<i. finite (local.merge j) \\<and> finite (succeed j))\n\ngoal (1 subgoal):\n 1. (\\<And>i'.\n        \\<lbrakk>finite fail; finite (local.merge i');\n         infinite (succeed i'); \\<forall>j<i'. finite (succeed j);\n         i' < max_rank\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  finite fail\n  finite (local.merge i')\n  infinite (succeed i')\n  \\<forall>j<i'. finite (succeed j)\n  i' < max_rank\n\ngoal (5 subgoals):\n 1. finite fail\n 2. finite (local.merge i)\n 3. infinite (succeed i)\n 4. \\<forall>j<i. finite (succeed j)\n 5. i < max_rank", "moreover"], ["proof (state)\nthis:\n  finite fail\n  finite (local.merge i')\n  infinite (succeed i')\n  \\<forall>j<i'. finite (succeed j)\n  i' < max_rank\n\ngoal (5 subgoals):\n 1. finite fail\n 2. finite (local.merge i)\n 3. infinite (succeed i)\n 4. \\<forall>j<i. finite (succeed j)\n 5. i < max_rank", "hence \"\\<And>y. finite fail \\<and> finite (merge y) \\<and> infinite (succeed y) \\<longrightarrow> i' \\<le> y\""], ["proof (prove)\nusing this:\n  finite fail\n  finite (local.merge i')\n  infinite (succeed i')\n  \\<forall>j<i'. finite (succeed j)\n  i' < max_rank\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       finite fail \\<and>\n       finite (local.merge y) \\<and> infinite (succeed y) \\<longrightarrow>\n       i' \\<le> y", "using not_le"], ["proof (prove)\nusing this:\n  finite fail\n  finite (local.merge i')\n  infinite (succeed i')\n  \\<forall>j<i'. finite (succeed j)\n  i' < max_rank\n  (\\<not> ?x \\<le> ?y) = (?y < ?x)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       finite fail \\<and>\n       finite (local.merge y) \\<and> infinite (succeed y) \\<longrightarrow>\n       i' \\<le> y", "by blast"], ["proof (state)\nthis:\n  finite fail \\<and>\n  finite (local.merge ?y) \\<and> infinite (succeed ?y) \\<longrightarrow>\n  i' \\<le> ?y\n\ngoal (5 subgoals):\n 1. finite fail\n 2. finite (local.merge i)\n 3. infinite (succeed i)\n 4. \\<forall>j<i. finite (succeed j)\n 5. i < max_rank", "ultimately"], ["proof (chain)\npicking this:\n  finite fail\n  finite (local.merge i')\n  infinite (succeed i')\n  \\<forall>j<i'. finite (succeed j)\n  i' < max_rank\n  finite fail \\<and>\n  finite (local.merge ?y) \\<and> infinite (succeed ?y) \\<longrightarrow>\n  i' \\<le> ?y", "have \"(LEAST i. finite fail \\<and> finite (merge i) \\<and> infinite (succeed i)) = i'\""], ["proof (prove)\nusing this:\n  finite fail\n  finite (local.merge i')\n  infinite (succeed i')\n  \\<forall>j<i'. finite (succeed j)\n  i' < max_rank\n  finite fail \\<and>\n  finite (local.merge ?y) \\<and> infinite (succeed ?y) \\<longrightarrow>\n  i' \\<le> ?y\n\ngoal (1 subgoal):\n 1. (LEAST i.\n        finite fail \\<and>\n        finite (local.merge i) \\<and> infinite (succeed i)) =\n    i'", "using le_antisym"], ["proof (prove)\nusing this:\n  finite fail\n  finite (local.merge i')\n  infinite (succeed i')\n  \\<forall>j<i'. finite (succeed j)\n  i' < max_rank\n  finite fail \\<and>\n  finite (local.merge ?y) \\<and> infinite (succeed ?y) \\<longrightarrow>\n  i' \\<le> ?y\n  \\<lbrakk>?m \\<le> ?n; ?n \\<le> ?m\\<rbrakk> \\<Longrightarrow> ?m = ?n\n\ngoal (1 subgoal):\n 1. (LEAST i.\n        finite fail \\<and>\n        finite (local.merge i) \\<and> infinite (succeed i)) =\n    i'", "unfolding Least_def"], ["proof (prove)\nusing this:\n  finite fail\n  finite (local.merge i')\n  infinite (succeed i')\n  \\<forall>j<i'. finite (succeed j)\n  i' < max_rank\n  finite fail \\<and>\n  finite (local.merge ?y) \\<and> infinite (succeed ?y) \\<longrightarrow>\n  i' \\<le> ?y\n  \\<lbrakk>?m \\<le> ?n; ?n \\<le> ?m\\<rbrakk> \\<Longrightarrow> ?m = ?n\n\ngoal (1 subgoal):\n 1. (THE x.\n        (finite fail \\<and>\n         finite (local.merge x) \\<and> infinite (succeed x)) \\<and>\n        (\\<forall>y.\n            finite fail \\<and>\n            finite (local.merge y) \\<and>\n            infinite (succeed y) \\<longrightarrow>\n            x \\<le> y)) =\n    i'", "by (blast dest: the_equality[of _ i'])"], ["proof (state)\nthis:\n  (LEAST i.\n      finite fail \\<and>\n      finite (local.merge i) \\<and> infinite (succeed i)) =\n  i'\n\ngoal (5 subgoals):\n 1. finite fail\n 2. finite (local.merge i)\n 3. infinite (succeed i)\n 4. \\<forall>j<i. finite (succeed j)\n 5. i < max_rank", "hence \"i' = i\""], ["proof (prove)\nusing this:\n  (LEAST i.\n      finite fail \\<and>\n      finite (local.merge i) \\<and> infinite (succeed i)) =\n  i'\n\ngoal (1 subgoal):\n 1. i' = i", "using \\<open>smallest_accepting_rank = Some i\\<close> \\<open>accept\\<close>"], ["proof (prove)\nusing this:\n  (LEAST i.\n      finite fail \\<and>\n      finite (local.merge i) \\<and> infinite (succeed i)) =\n  i'\n  smallest_accepting_rank = Some i\n  accept\\<^sub>M\n\ngoal (1 subgoal):\n 1. i' = i", "unfolding smallest_accepting_rank_def"], ["proof (prove)\nusing this:\n  (LEAST i.\n      finite fail \\<and>\n      finite (local.merge i) \\<and> infinite (succeed i)) =\n  i'\n  (if accept\\<^sub>M\n   then Some\n         (LEAST i.\n             finite fail \\<and>\n             finite (local.merge i) \\<and> infinite (succeed i))\n   else None) =\n  Some i\n  accept\\<^sub>M\n\ngoal (1 subgoal):\n 1. i' = i", "by simp"], ["proof (state)\nthis:\n  i' = i\n\ngoal (5 subgoals):\n 1. finite fail\n 2. finite (local.merge i)\n 3. infinite (succeed i)\n 4. \\<forall>j<i. finite (succeed j)\n 5. i < max_rank", "thus \"finite fail\" and \"finite (merge i)\" and \"infinite (succeed i)\"\n    and \"\\<forall>j < i. finite (succeed j)\" and \"i < max_rank\""], ["proof (prove)\nusing this:\n  i' = i\n\ngoal (1 subgoal):\n 1. (finite fail &&& finite (local.merge i)) &&&\n    infinite (succeed i) &&&\n    \\<forall>j<i. finite (succeed j) &&& i < max_rank", "using \\<open>finite fail\\<close> \\<open>finite (merge i')\\<close> \\<open>infinite (succeed i')\\<close>"], ["proof (prove)\nusing this:\n  i' = i\n  finite fail\n  finite (local.merge i')\n  infinite (succeed i')\n\ngoal (1 subgoal):\n 1. (finite fail &&& finite (local.merge i)) &&&\n    infinite (succeed i) &&&\n    \\<forall>j<i. finite (succeed j) &&& i < max_rank", "using \\<open>\\<forall>j < i'. finite (succeed j)\\<close> \\<open>i' < max_rank\\<close>"], ["proof (prove)\nusing this:\n  i' = i\n  finite fail\n  finite (local.merge i')\n  infinite (succeed i')\n  \\<forall>j<i'. finite (succeed j)\n  i' < max_rank\n\ngoal (1 subgoal):\n 1. (finite fail &&& finite (local.merge i)) &&&\n    infinite (succeed i) &&&\n    \\<forall>j<i. finite (succeed j) &&& i < max_rank", "by simp+"], ["proof (state)\nthis:\n  finite fail\n  finite (local.merge i)\n  infinite (succeed i)\n  \\<forall>j<i. finite (succeed j)\n  i < max_rank\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma token_smallest_accepting_rank:\n  assumes \"smallest_accepting_rank = Some i\"\n  shows \"\\<forall>\\<^sub>\\<infinity>n. \\<forall>x. token_succeeds x \\<longleftrightarrow> (x > n \\<or> (\\<exists>j \\<ge> i. rank x n = Some j) \\<or> token_run x n \\<in> F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "from assms"], ["proof (chain)\npicking this:\n  smallest_accepting_rank = Some i", "have \"accept\" \"finite fail\" \"infinite (succeed i)\" \"\\<forall>j < i. finite (succeed j)\""], ["proof (prove)\nusing this:\n  smallest_accepting_rank = Some i\n\ngoal (1 subgoal):\n 1. (accept\\<^sub>M &&& finite fail) &&&\n    infinite (succeed i) &&& \\<forall>j<i. finite (succeed j)", "using smallest_accepting_rank_properties"], ["proof (prove)\nusing this:\n  smallest_accepting_rank = Some i\n  smallest_accepting_rank = Some ?i \\<Longrightarrow> accept\\<^sub>M\n  smallest_accepting_rank = Some ?i \\<Longrightarrow> finite fail\n  smallest_accepting_rank = Some ?i \\<Longrightarrow>\n  finite (local.merge ?i)\n  smallest_accepting_rank = Some ?i \\<Longrightarrow> infinite (succeed ?i)\n  smallest_accepting_rank = Some ?i \\<Longrightarrow>\n  \\<forall>j<?i. finite (succeed j)\n  smallest_accepting_rank = Some ?i \\<Longrightarrow> ?i < max_rank\n\ngoal (1 subgoal):\n 1. (accept\\<^sub>M &&& finite fail) &&&\n    infinite (succeed i) &&& \\<forall>j<i. finite (succeed j)", "by blast+"], ["proof (state)\nthis:\n  accept\\<^sub>M\n  finite fail\n  infinite (succeed i)\n  \\<forall>j<i. finite (succeed j)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "then"], ["proof (chain)\npicking this:\n  accept\\<^sub>M\n  finite fail\n  infinite (succeed i)\n  \\<forall>j<i. finite (succeed j)", "obtain n\\<^sub>1 where n\\<^sub>1_def: \"\\<forall>x \\<ge> n\\<^sub>1. token_succeeds x\""], ["proof (prove)\nusing this:\n  accept\\<^sub>M\n  finite fail\n  infinite (succeed i)\n  \\<forall>j<i. finite (succeed j)\n\ngoal (1 subgoal):\n 1. (\\<And>n\\<^sub>1.\n        \\<forall>x\\<ge>n\\<^sub>1. token_succeeds x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding accept_def MOST_nat_le"], ["proof (prove)\nusing this:\n  \\<exists>m. \\<forall>n\\<ge>m. token_succeeds n\n  finite fail\n  infinite (succeed i)\n  \\<forall>j<i. finite (succeed j)\n\ngoal (1 subgoal):\n 1. (\\<And>n\\<^sub>1.\n        \\<forall>x\\<ge>n\\<^sub>1. token_succeeds x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<ge>n\\<^sub>1. token_succeeds x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "define n\\<^sub>2 where \"n\\<^sub>2 = Suc (Max (fail_t \\<union> \\<Union>{succeed_t j | j. j < i}))\" (is \"_ = Suc (Max ?S)\")"], ["proof (state)\nthis:\n  n\\<^sub>2 = Suc (Max (fail_t \\<union> \\<Union> {succeed_t j |j. j < i}))\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "define n\\<^sub>3 where \"n\\<^sub>3 = Max ({LEAST m. stable_rank_at x m | x. x < n\\<^sub>1 \\<and> token_squats x})\" (is \"_ = Max ?S'\")"], ["proof (state)\nthis:\n  n\\<^sub>3 =\n  Max {LEAST m. stable_rank_at x m |x. x < n\\<^sub>1 \\<and> token_squats x}\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "define n where \"n = Max {n\\<^sub>1, n\\<^sub>2, n\\<^sub>3}\""], ["proof (state)\nthis:\n  n = Max {n\\<^sub>1, n\\<^sub>2, n\\<^sub>3}\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "have \"finite ?S\" and \"finite ?S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (fail_t \\<union> \\<Union> {succeed_t j |j. j < i}) &&&\n    finite\n     {LEAST m. stable_rank_at x m |x. x < n\\<^sub>1 \\<and> token_squats x}", "using \\<open>finite fail\\<close> \\<open>\\<forall>j < i. finite (succeed j)\\<close>"], ["proof (prove)\nusing this:\n  finite fail\n  \\<forall>j<i. finite (succeed j)\n\ngoal (1 subgoal):\n 1. finite (fail_t \\<union> \\<Union> {succeed_t j |j. j < i}) &&&\n    finite\n     {LEAST m. stable_rank_at x m |x. x < n\\<^sub>1 \\<and> token_squats x}", "unfolding finite_fail_t finite_succeed_t"], ["proof (prove)\nusing this:\n  finite fail_t\n  \\<forall>j<i. finite (succeed_t j)\n\ngoal (1 subgoal):\n 1. finite (fail_t \\<union> \\<Union> {succeed_t j |j. j < i}) &&&\n    finite\n     {LEAST m. stable_rank_at x m |x. x < n\\<^sub>1 \\<and> token_squats x}", "by fastforce+"], ["proof (state)\nthis:\n  finite (fail_t \\<union> \\<Union> {succeed_t j |j. j < i})\n  finite\n   {LEAST m. stable_rank_at x m |x. x < n\\<^sub>1 \\<and> token_squats x}\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "{"], ["proof (state)\nthis:\n  finite (fail_t \\<union> \\<Union> {succeed_t j |j. j < i})\n  finite\n   {LEAST m. stable_rank_at x m |x. x < n\\<^sub>1 \\<and> token_squats x}\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "assume \"x < n\\<^sub>1\" \"token_squats x\""], ["proof (state)\nthis:\n  x < n\\<^sub>1\n  token_squats x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "hence \"(LEAST m. stable_rank_at x m) \\<in> ?S'\" (is \"?m \\<in> _\")"], ["proof (prove)\nusing this:\n  x < n\\<^sub>1\n  token_squats x\n\ngoal (1 subgoal):\n 1. (LEAST m. stable_rank_at x m)\n    \\<in> {LEAST m. stable_rank_at x m |x.\n           x < n\\<^sub>1 \\<and> token_squats x}", "by blast"], ["proof (state)\nthis:\n  (LEAST m. stable_rank_at x m)\n  \\<in> {LEAST m. stable_rank_at x m |x.\n         x < n\\<^sub>1 \\<and> token_squats x}\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "hence \"?m \\<le> n\\<^sub>3\""], ["proof (prove)\nusing this:\n  (LEAST m. stable_rank_at x m)\n  \\<in> {LEAST m. stable_rank_at x m |x.\n         x < n\\<^sub>1 \\<and> token_squats x}\n\ngoal (1 subgoal):\n 1. (LEAST m. stable_rank_at x m) \\<le> n\\<^sub>3", "using Max.coboundedI[OF \\<open>finite ?S'\\<close>] n\\<^sub>3_def"], ["proof (prove)\nusing this:\n  (LEAST m. stable_rank_at x m)\n  \\<in> {LEAST m. stable_rank_at x m |x.\n         x < n\\<^sub>1 \\<and> token_squats x}\n  ?a \\<in> {LEAST m. stable_rank_at x m |x.\n            x < n\\<^sub>1 \\<and> token_squats x} \\<Longrightarrow>\n  ?a \\<le> Max {LEAST m. stable_rank_at x m |x.\n                x < n\\<^sub>1 \\<and> token_squats x}\n  n\\<^sub>3 =\n  Max {LEAST m. stable_rank_at x m |x. x < n\\<^sub>1 \\<and> token_squats x}\n\ngoal (1 subgoal):\n 1. (LEAST m. stable_rank_at x m) \\<le> n\\<^sub>3", "by simp"], ["proof (state)\nthis:\n  (LEAST m. stable_rank_at x m) \\<le> n\\<^sub>3\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "moreover"], ["proof (state)\nthis:\n  (LEAST m. stable_rank_at x m) \\<le> n\\<^sub>3\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "obtain k where \"stable_rank x k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k. stable_rank x k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>x < n\\<^sub>1\\<close> \\<open>token_squats x\\<close> stable_rank_equiv_token_squats"], ["proof (prove)\nusing this:\n  x < n\\<^sub>1\n  token_squats x\n  token_squats ?x = (\\<exists>i. stable_rank ?x i)\n\ngoal (1 subgoal):\n 1. (\\<And>k. stable_rank x k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  stable_rank x k\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "hence \"stable_rank_at x ?m\""], ["proof (prove)\nusing this:\n  stable_rank x k\n\ngoal (1 subgoal):\n 1. stable_rank_at x (LEAST m. stable_rank_at x m)", "by (metis stable_rank_equiv LeastI)"], ["proof (state)\nthis:\n  stable_rank_at x (LEAST m. stable_rank_at x m)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "ultimately"], ["proof (chain)\npicking this:\n  (LEAST m. stable_rank_at x m) \\<le> n\\<^sub>3\n  stable_rank_at x (LEAST m. stable_rank_at x m)", "have \"stable_rank_at x n\\<^sub>3\""], ["proof (prove)\nusing this:\n  (LEAST m. stable_rank_at x m) \\<le> n\\<^sub>3\n  stable_rank_at x (LEAST m. stable_rank_at x m)\n\ngoal (1 subgoal):\n 1. stable_rank_at x n\\<^sub>3", "by (rule stable_rank_at_ge)"], ["proof (state)\nthis:\n  stable_rank_at x n\\<^sub>3\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "hence \"\\<exists>i. \\<forall>m' \\<ge> n. rank x m' = Some i\""], ["proof (prove)\nusing this:\n  stable_rank_at x n\\<^sub>3\n\ngoal (1 subgoal):\n 1. \\<exists>i. \\<forall>m'\\<ge>n. rank x m' = Some i", "unfolding n_def stable_rank_at_def"], ["proof (prove)\nusing this:\n  \\<exists>i. \\<forall>m\\<ge>n\\<^sub>3. rank x m = Some i\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       \\<forall>m'\\<ge>Max {n\\<^sub>1, n\\<^sub>2, n\\<^sub>3}.\n          rank x m' = Some i", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>i. \\<forall>m'\\<ge>n. rank x m' = Some i\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?x2 < n\\<^sub>1; token_squats ?x2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i. \\<forall>m'\\<ge>n. rank ?x2 m' = Some i\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "note Stable = this"], ["proof (state)\nthis:\n  \\<lbrakk>?x2 < n\\<^sub>1; token_squats ?x2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i. \\<forall>m'\\<ge>n. rank ?x2 m' = Some i\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "have \"\\<And>m j. j < i \\<Longrightarrow> m \\<in> succeed_t j \\<Longrightarrow> m < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m j.\n       \\<lbrakk>j < i; m \\<in> succeed_t j\\<rbrakk> \\<Longrightarrow> m < n", "using Max.coboundedI[OF \\<open>finite ?S\\<close>]"], ["proof (prove)\nusing this:\n  ?a \\<in> fail_t \\<union>\n           \\<Union> {succeed_t j |j. j < i} \\<Longrightarrow>\n  ?a \\<le> Max (fail_t \\<union> \\<Union> {succeed_t j |j. j < i})\n\ngoal (1 subgoal):\n 1. \\<And>m j.\n       \\<lbrakk>j < i; m \\<in> succeed_t j\\<rbrakk> \\<Longrightarrow> m < n", "unfolding n_def n\\<^sub>2_def"], ["proof (prove)\nusing this:\n  ?a \\<in> fail_t \\<union>\n           \\<Union> {succeed_t j |j. j < i} \\<Longrightarrow>\n  ?a \\<le> Max (fail_t \\<union> \\<Union> {succeed_t j |j. j < i})\n\ngoal (1 subgoal):\n 1. \\<And>m j.\n       \\<lbrakk>j < i; m \\<in> succeed_t j\\<rbrakk>\n       \\<Longrightarrow> m < Max {n\\<^sub>1,\n                                  Suc (Max\n  (fail_t \\<union> \\<Union> {succeed_t j |j. j < i})),\n                                  n\\<^sub>3}", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>?j < i; ?m \\<in> succeed_t ?j\\<rbrakk> \\<Longrightarrow> ?m < n\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "hence Succeed: \"\\<And>m j x. n \\<le> m \\<Longrightarrow> token_run x m \\<notin> F - {q\\<^sub>0} \\<Longrightarrow> token_run x (Suc m) \\<in> F \\<Longrightarrow> rank x m = Some j \\<Longrightarrow> i \\<le> j\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?j < i; ?m \\<in> succeed_t ?j\\<rbrakk> \\<Longrightarrow> ?m < n\n\ngoal (1 subgoal):\n 1. \\<And>m j x.\n       \\<lbrakk>n \\<le> m; token_run x m \\<notin> F - {q\\<^sub>0};\n        token_run x (Suc m) \\<in> F; rank x m = Some j\\<rbrakk>\n       \\<Longrightarrow> i \\<le> j", "by (metis not_le succeed_t_inclusion)"], ["proof (state)\nthis:\n  \\<lbrakk>n \\<le> ?m; token_run ?x ?m \\<notin> F - {q\\<^sub>0};\n   token_run ?x (Suc ?m) \\<in> F; rank ?x ?m = Some ?j\\<rbrakk>\n  \\<Longrightarrow> i \\<le> ?j\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "have \"\\<And>m. m \\<in> fail_t \\<Longrightarrow> m < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m. m \\<in> fail_t \\<Longrightarrow> m < n", "using Max.coboundedI[OF \\<open>finite ?S\\<close>]"], ["proof (prove)\nusing this:\n  ?a \\<in> fail_t \\<union>\n           \\<Union> {succeed_t j |j. j < i} \\<Longrightarrow>\n  ?a \\<le> Max (fail_t \\<union> \\<Union> {succeed_t j |j. j < i})\n\ngoal (1 subgoal):\n 1. \\<And>m. m \\<in> fail_t \\<Longrightarrow> m < n", "unfolding n_def n\\<^sub>2_def"], ["proof (prove)\nusing this:\n  ?a \\<in> fail_t \\<union>\n           \\<Union> {succeed_t j |j. j < i} \\<Longrightarrow>\n  ?a \\<le> Max (fail_t \\<union> \\<Union> {succeed_t j |j. j < i})\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       m \\<in> fail_t \\<Longrightarrow>\n       m < Max {n\\<^sub>1,\n                Suc (Max (fail_t \\<union>\n                          \\<Union> {succeed_t j |j. j < i})),\n                n\\<^sub>3}", "by fastforce"], ["proof (state)\nthis:\n  ?m \\<in> fail_t \\<Longrightarrow> ?m < n\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "hence Fail: \"\\<And>m x. n \\<le> m \\<Longrightarrow> x \\<le> m \\<Longrightarrow> sink (token_run x m) \\<or> \\<not>sink (token_run x (Suc m)) \\<or> \\<not>token_run x (Suc m) \\<notin> F\""], ["proof (prove)\nusing this:\n  ?m \\<in> fail_t \\<Longrightarrow> ?m < n\n\ngoal (1 subgoal):\n 1. \\<And>m x.\n       \\<lbrakk>n \\<le> m; x \\<le> m\\<rbrakk>\n       \\<Longrightarrow> sink (token_run x m) \\<or>\n                         \\<not> sink (token_run x (Suc m)) \\<or>\n                         \\<not> token_run x (Suc m) \\<notin> F", "using fail_t_inclusion"], ["proof (prove)\nusing this:\n  ?m \\<in> fail_t \\<Longrightarrow> ?m < n\n  \\<lbrakk>?x \\<le> ?n; \\<not> sink (token_run ?x ?n);\n   sink (token_run ?x (Suc ?n)); token_run ?x (Suc ?n) \\<notin> F\\<rbrakk>\n  \\<Longrightarrow> ?n \\<in> fail_t\n\ngoal (1 subgoal):\n 1. \\<And>m x.\n       \\<lbrakk>n \\<le> m; x \\<le> m\\<rbrakk>\n       \\<Longrightarrow> sink (token_run x m) \\<or>\n                         \\<not> sink (token_run x (Suc m)) \\<or>\n                         \\<not> token_run x (Suc m) \\<notin> F", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>n \\<le> ?m; ?x \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> sink (token_run ?x ?m) \\<or>\n                    \\<not> sink (token_run ?x (Suc ?m)) \\<or>\n                    \\<not> token_run ?x (Suc ?m) \\<notin> F\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>n \\<le> ?m; ?x \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> sink (token_run ?x ?m) \\<or>\n                    \\<not> sink (token_run ?x (Suc ?m)) \\<or>\n                    \\<not> token_run ?x (Suc ?m) \\<notin> F\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "fix m x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "assume \"m \\<ge> n\" \"m \\<ge> x\""], ["proof (state)\nthis:\n  n \\<le> m\n  x \\<le> m\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "moreover"], ["proof (state)\nthis:\n  n \\<le> m\n  x \\<le> m\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "{"], ["proof (state)\nthis:\n  n \\<le> m\n  x \\<le> m\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "assume \"token_succeeds x\" \"token_run x m \\<notin> F\""], ["proof (state)\nthis:\n  token_succeeds x\n  token_run x m \\<notin> F\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "then"], ["proof (chain)\npicking this:\n  token_succeeds x\n  token_run x m \\<notin> F", "obtain m' where \"x \\<le> m'\" and \"token_run x m' \\<notin> F - {q\\<^sub>0}\" and \"token_run x (Suc m') \\<in> F\""], ["proof (prove)\nusing this:\n  token_succeeds x\n  token_run x m \\<notin> F\n\ngoal (1 subgoal):\n 1. (\\<And>m'.\n        \\<lbrakk>x \\<le> m'; token_run x m' \\<notin> F - {q\\<^sub>0};\n         token_run x (Suc m') \\<in> F\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using token_run_enter_final_states"], ["proof (prove)\nusing this:\n  token_succeeds x\n  token_run x m \\<notin> F\n  token_run ?x ?n \\<in> F \\<Longrightarrow>\n  \\<exists>m\\<ge>?x.\n     token_run ?x m \\<notin> F - {q\\<^sub>0} \\<and>\n     token_run ?x (Suc m) \\<in> F\n\ngoal (1 subgoal):\n 1. (\\<And>m'.\n        \\<lbrakk>x \\<le> m'; token_run x m' \\<notin> F - {q\\<^sub>0};\n         token_run x (Suc m') \\<in> F\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding token_succeeds_def"], ["proof (prove)\nusing this:\n  \\<exists>n. token_run x n \\<in> F\n  token_run x m \\<notin> F\n  token_run ?x ?n \\<in> F \\<Longrightarrow>\n  \\<exists>m\\<ge>?x.\n     token_run ?x m \\<notin> F - {q\\<^sub>0} \\<and>\n     token_run ?x (Suc m) \\<in> F\n\ngoal (1 subgoal):\n 1. (\\<And>m'.\n        \\<lbrakk>x \\<le> m'; token_run x m' \\<notin> F - {q\\<^sub>0};\n         token_run x (Suc m') \\<in> F\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by meson"], ["proof (state)\nthis:\n  x \\<le> m'\n  token_run x m' \\<notin> F - {q\\<^sub>0}\n  token_run x (Suc m') \\<in> F\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "moreover"], ["proof (state)\nthis:\n  x \\<le> m'\n  token_run x m' \\<notin> F - {q\\<^sub>0}\n  token_run x (Suc m') \\<in> F\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "hence \"\\<not>sink (token_run x m')\""], ["proof (prove)\nusing this:\n  x \\<le> m'\n  token_run x m' \\<notin> F - {q\\<^sub>0}\n  token_run x (Suc m') \\<in> F\n\ngoal (1 subgoal):\n 1. \\<not> sink (token_run x m')", "by (metis Diff_empty Diff_insert0 \\<open>token_run x m \\<notin> F\\<close> initial_in_F_token_run token_is_not_in_sink)"], ["proof (state)\nthis:\n  \\<not> sink (token_run x m')\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "ultimately"], ["proof (chain)\npicking this:\n  x \\<le> m'\n  token_run x m' \\<notin> F - {q\\<^sub>0}\n  token_run x (Suc m') \\<in> F\n  \\<not> sink (token_run x m')", "obtain j' where \"rank x m' = Some j'\""], ["proof (prove)\nusing this:\n  x \\<le> m'\n  token_run x m' \\<notin> F - {q\\<^sub>0}\n  token_run x (Suc m') \\<in> F\n  \\<not> sink (token_run x m')\n\ngoal (1 subgoal):\n 1. (\\<And>j'.\n        rank x m' = Some j' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  rank x m' = Some j'\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "moreover"], ["proof (state)\nthis:\n  rank x m' = Some j'\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "have \"m \\<le> m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> m'", "by (metis \\<open>token_run x m \\<notin> F\\<close> token_stays_in_final_states[OF \\<open>token_run x (Suc m') \\<in> F\\<close>] add_Suc_right add_Suc_shift less_imp_Suc_add not_le)"], ["proof (state)\nthis:\n  m \\<le> m'\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "moreover"], ["proof (state)\nthis:\n  m \\<le> m'\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "hence \"m' \\<ge> n\""], ["proof (prove)\nusing this:\n  m \\<le> m'\n\ngoal (1 subgoal):\n 1. n \\<le> m'", "using \\<open>x \\<le> m\\<close> \\<open>m \\<ge> n\\<close>"], ["proof (prove)\nusing this:\n  m \\<le> m'\n  x \\<le> m\n  n \\<le> m\n\ngoal (1 subgoal):\n 1. n \\<le> m'", "by simp"], ["proof (state)\nthis:\n  n \\<le> m'\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "hence \"j' \\<ge> i\""], ["proof (prove)\nusing this:\n  n \\<le> m'\n\ngoal (1 subgoal):\n 1. i \\<le> j'", "using Succeed[OF _ \\<open>token_run x m' \\<notin> F - {q\\<^sub>0}\\<close> \\<open>token_run x (Suc m') \\<in> F\\<close> \\<open>rank x m' = Some j'\\<close>]"], ["proof (prove)\nusing this:\n  n \\<le> m'\n  n \\<le> m' \\<Longrightarrow> i \\<le> j'\n\ngoal (1 subgoal):\n 1. i \\<le> j'", "by blast"], ["proof (state)\nthis:\n  i \\<le> j'\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "moreover"], ["proof (state)\nthis:\n  i \\<le> j'\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "obtain k where \"rank x x = Some k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k. rank x x = Some k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using rank_initial[of x]"], ["proof (prove)\nusing this:\n  \\<exists>i. rank x x = Some i\n\ngoal (1 subgoal):\n 1. (\\<And>k. rank x x = Some k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  rank x x = Some k\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "ultimately"], ["proof (chain)\npicking this:\n  rank x m' = Some j'\n  m \\<le> m'\n  i \\<le> j'\n  rank x x = Some k", "obtain j where \"rank x m = Some j\""], ["proof (prove)\nusing this:\n  rank x m' = Some j'\n  m \\<le> m'\n  i \\<le> j'\n  rank x x = Some k\n\ngoal (1 subgoal):\n 1. (\\<And>j. rank x m = Some j \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis rank_continuous[OF \\<open>rank x x = Some k\\<close>, of \"m' - x\"] \\<open>x \\<le> m'\\<close> \\<open>x \\<le> m\\<close> diff_le_mono le_add_diff_inverse)"], ["proof (state)\nthis:\n  rank x m = Some j\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "hence \"\\<exists>j \\<ge> i. rank x m = Some j\""], ["proof (prove)\nusing this:\n  rank x m = Some j\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>i. rank x m = Some j", "using rank_monotonic \\<open>rank x m' = Some j'\\<close> \\<open>j' \\<ge> i\\<close> \\<open>m \\<le> m'\\<close>[THEN le_Suc_ex]"], ["proof (prove)\nusing this:\n  rank x m = Some j\n  \\<lbrakk>rank ?x ?n = Some ?i; rank ?x (?n + ?m) = Some ?j\\<rbrakk>\n  \\<Longrightarrow> ?j \\<le> ?i\n  rank x m' = Some j'\n  i \\<le> j'\n  \\<exists>n. m' = m + n\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>i. rank x m = Some j", "by (blast dest: le_Suc_ex trans_le_add1)"], ["proof (state)\nthis:\n  \\<exists>j\\<ge>i. rank x m = Some j\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>token_succeeds x; token_run x m \\<notin> F\\<rbrakk>\n  \\<Longrightarrow> \\<exists>j\\<ge>i. rank x m = Some j\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>token_succeeds x; token_run x m \\<notin> F\\<rbrakk>\n  \\<Longrightarrow> \\<exists>j\\<ge>i. rank x m = Some j\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>token_succeeds x; token_run x m \\<notin> F\\<rbrakk>\n  \\<Longrightarrow> \\<exists>j\\<ge>i. rank x m = Some j\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "assume \"\\<not>token_succeeds x\""], ["proof (state)\nthis:\n  \\<not> token_succeeds x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "hence \"\\<And>m. token_run x m \\<notin> F\""], ["proof (prove)\nusing this:\n  \\<not> token_succeeds x\n\ngoal (1 subgoal):\n 1. \\<And>m. token_run x m \\<notin> F", "unfolding token_succeeds_def"], ["proof (prove)\nusing this:\n  \\<nexists>n. token_run x n \\<in> F\n\ngoal (1 subgoal):\n 1. \\<And>m. token_run x m \\<notin> F", "by blast"], ["proof (state)\nthis:\n  token_run x ?m \\<notin> F\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "moreover"], ["proof (state)\nthis:\n  token_run x ?m \\<notin> F\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "have \"\\<not>(\\<exists>j \\<ge> i. rank x m = Some j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j\\<ge>i. rank x m = Some j)", "proof (cases \"token_squats x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. token_squats x \\<Longrightarrow>\n    \\<not> (\\<exists>j\\<ge>i. rank x m = Some j)\n 2. \\<not> token_squats x \\<Longrightarrow>\n    \\<not> (\\<exists>j\\<ge>i. rank x m = Some j)", "case True\n          \\<comment> \\<open>The token already stabilised\\<close>"], ["proof (state)\nthis:\n  token_squats x\n\ngoal (2 subgoals):\n 1. token_squats x \\<Longrightarrow>\n    \\<not> (\\<exists>j\\<ge>i. rank x m = Some j)\n 2. \\<not> token_squats x \\<Longrightarrow>\n    \\<not> (\\<exists>j\\<ge>i. rank x m = Some j)", "have \"x < n\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < n\\<^sub>1", "using \\<open>\\<not>token_succeeds x\\<close> n\\<^sub>1_def"], ["proof (prove)\nusing this:\n  \\<not> token_succeeds x\n  \\<forall>x\\<ge>n\\<^sub>1. token_succeeds x\n\ngoal (1 subgoal):\n 1. x < n\\<^sub>1", "by (metis not_le)"], ["proof (state)\nthis:\n  x < n\\<^sub>1\n\ngoal (2 subgoals):\n 1. token_squats x \\<Longrightarrow>\n    \\<not> (\\<exists>j\\<ge>i. rank x m = Some j)\n 2. \\<not> token_squats x \\<Longrightarrow>\n    \\<not> (\\<exists>j\\<ge>i. rank x m = Some j)", "then"], ["proof (chain)\npicking this:\n  x < n\\<^sub>1", "obtain k where \"\\<forall>m' \\<ge> n. rank x m' = Some k\""], ["proof (prove)\nusing this:\n  x < n\\<^sub>1\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<forall>m'\\<ge>n. rank x m' = Some k \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Stable[OF _ True]"], ["proof (prove)\nusing this:\n  x < n\\<^sub>1\n  x < n\\<^sub>1 \\<Longrightarrow>\n  \\<exists>i. \\<forall>m'\\<ge>n. rank x m' = Some i\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<forall>m'\\<ge>n. rank x m' = Some k \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>m'\\<ge>n. rank x m' = Some k\n\ngoal (2 subgoals):\n 1. token_squats x \\<Longrightarrow>\n    \\<not> (\\<exists>j\\<ge>i. rank x m = Some j)\n 2. \\<not> token_squats x \\<Longrightarrow>\n    \\<not> (\\<exists>j\\<ge>i. rank x m = Some j)", "moreover"], ["proof (state)\nthis:\n  \\<forall>m'\\<ge>n. rank x m' = Some k\n\ngoal (2 subgoals):\n 1. token_squats x \\<Longrightarrow>\n    \\<not> (\\<exists>j\\<ge>i. rank x m = Some j)\n 2. \\<not> token_squats x \\<Longrightarrow>\n    \\<not> (\\<exists>j\\<ge>i. rank x m = Some j)", "hence \"stable_rank x k\""], ["proof (prove)\nusing this:\n  \\<forall>m'\\<ge>n. rank x m' = Some k\n\ngoal (1 subgoal):\n 1. stable_rank x k", "unfolding stable_rank_def MOST_nat_le"], ["proof (prove)\nusing this:\n  \\<forall>m'\\<ge>n. rank x m' = Some k\n\ngoal (1 subgoal):\n 1. \\<exists>m. \\<forall>n\\<ge>m. rank x n = Some k", "by blast"], ["proof (state)\nthis:\n  stable_rank x k\n\ngoal (2 subgoals):\n 1. token_squats x \\<Longrightarrow>\n    \\<not> (\\<exists>j\\<ge>i. rank x m = Some j)\n 2. \\<not> token_squats x \\<Longrightarrow>\n    \\<not> (\\<exists>j\\<ge>i. rank x m = Some j)", "moreover"], ["proof (state)\nthis:\n  stable_rank x k\n\ngoal (2 subgoals):\n 1. token_squats x \\<Longrightarrow>\n    \\<not> (\\<exists>j\\<ge>i. rank x m = Some j)\n 2. \\<not> token_squats x \\<Longrightarrow>\n    \\<not> (\\<exists>j\\<ge>i. rank x m = Some j)", "have \"q\\<^sub>0 \\<notin> F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q\\<^sub>0 \\<notin> F", "by (metis \\<open>\\<And>m. token_run x m \\<notin> F\\<close> initial_in_F_token_run)"], ["proof (state)\nthis:\n  q\\<^sub>0 \\<notin> F\n\ngoal (2 subgoals):\n 1. token_squats x \\<Longrightarrow>\n    \\<not> (\\<exists>j\\<ge>i. rank x m = Some j)\n 2. \\<not> token_squats x \\<Longrightarrow>\n    \\<not> (\\<exists>j\\<ge>i. rank x m = Some j)", "ultimately\n          \\<comment> \\<open>Hence the rank is smaller than i\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>m'\\<ge>n. rank x m' = Some k\n  stable_rank x k\n  q\\<^sub>0 \\<notin> F", "have \"k < i\" and \"rank x m = Some k\""], ["proof (prove)\nusing this:\n  \\<forall>m'\\<ge>n. rank x m' = Some k\n  stable_rank x k\n  q\\<^sub>0 \\<notin> F\n\ngoal (1 subgoal):\n 1. k < i &&& rank x m = Some k", "using stable_rank_bounded \\<open>infinite (succeed i)\\<close> \\<open>n \\<le> m\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>m'\\<ge>n. rank x m' = Some k\n  stable_rank x k\n  q\\<^sub>0 \\<notin> F\n  \\<lbrakk>stable_rank ?x ?j; infinite (succeed ?i);\n   q\\<^sub>0 \\<notin> F\\<rbrakk>\n  \\<Longrightarrow> ?j < ?i\n  infinite (succeed i)\n  n \\<le> m\n\ngoal (1 subgoal):\n 1. k < i &&& rank x m = Some k", "by blast+"], ["proof (state)\nthis:\n  k < i\n  rank x m = Some k\n\ngoal (2 subgoals):\n 1. token_squats x \\<Longrightarrow>\n    \\<not> (\\<exists>j\\<ge>i. rank x m = Some j)\n 2. \\<not> token_squats x \\<Longrightarrow>\n    \\<not> (\\<exists>j\\<ge>i. rank x m = Some j)", "thus ?thesis"], ["proof (prove)\nusing this:\n  k < i\n  rank x m = Some k\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j\\<ge>i. rank x m = Some j)", "by simp"], ["proof (state)\nthis:\n  \\<not> (\\<exists>j\\<ge>i. rank x m = Some j)\n\ngoal (1 subgoal):\n 1. \\<not> token_squats x \\<Longrightarrow>\n    \\<not> (\\<exists>j\\<ge>i. rank x m = Some j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> token_squats x \\<Longrightarrow>\n    \\<not> (\\<exists>j\\<ge>i. rank x m = Some j)", "case False\n          \\<comment> \\<open>Then token is already in a sink\\<close>"], ["proof (state)\nthis:\n  \\<not> token_squats x\n\ngoal (1 subgoal):\n 1. \\<not> token_squats x \\<Longrightarrow>\n    \\<not> (\\<exists>j\\<ge>i. rank x m = Some j)", "have \"sink (token_run x m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sink (token_run x m)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> sink (token_run x m) \\<Longrightarrow> False", "assume \"\\<not>sink (token_run x m)\""], ["proof (state)\nthis:\n  \\<not> sink (token_run x m)\n\ngoal (1 subgoal):\n 1. \\<not> sink (token_run x m) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<not> sink (token_run x m)\n\ngoal (1 subgoal):\n 1. \\<not> sink (token_run x m) \\<Longrightarrow> False", "obtain m' where \"m < m'\" and \"sink (token_run x m')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m'.\n        \\<lbrakk>m < m'; sink (token_run x m')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis False token_squats_def le_add2 not_le not_less_eq_eq token_stays_in_sink)"], ["proof (state)\nthis:\n  m < m'\n  sink (token_run x m')\n\ngoal (1 subgoal):\n 1. \\<not> sink (token_run x m) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> sink (token_run x m)\n  m < m'\n  sink (token_run x m')", "obtain m'' where \"m \\<le> m''\" and  \"\\<not>sink (token_run x m'')\" and \"sink (token_run x (Suc m''))\""], ["proof (prove)\nusing this:\n  \\<not> sink (token_run x m)\n  m < m'\n  sink (token_run x m')\n\ngoal (1 subgoal):\n 1. (\\<And>m''.\n        \\<lbrakk>m \\<le> m''; \\<not> sink (token_run x m'');\n         sink (token_run x (Suc m''))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis le_add1 less_imp_Suc_add token_run_P)"], ["proof (state)\nthis:\n  m \\<le> m''\n  \\<not> sink (token_run x m'')\n  sink (token_run x (Suc m''))\n\ngoal (1 subgoal):\n 1. \\<not> sink (token_run x m) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  m \\<le> m''\n  \\<not> sink (token_run x m'')\n  sink (token_run x (Suc m''))\n\ngoal (1 subgoal):\n 1. False", "by (metis Fail \\<open>\\<And>m. token_run x m \\<notin> F\\<close> \\<open>n \\<le> m\\<close> \\<open>x \\<le> m\\<close> le_trans)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed\n          \\<comment> \\<open>Hence there is no rank\\<close>"], ["proof (state)\nthis:\n  sink (token_run x m)\n\ngoal (1 subgoal):\n 1. \\<not> token_squats x \\<Longrightarrow>\n    \\<not> (\\<exists>j\\<ge>i. rank x m = Some j)", "thus ?thesis"], ["proof (prove)\nusing this:\n  sink (token_run x m)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j\\<ge>i. rank x m = Some j)", "by simp"], ["proof (state)\nthis:\n  \\<not> (\\<exists>j\\<ge>i. rank x m = Some j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (\\<exists>j\\<ge>i. rank x m = Some j)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "ultimately"], ["proof (chain)\npicking this:\n  token_run x ?m \\<notin> F\n  \\<not> (\\<exists>j\\<ge>i. rank x m = Some j)", "have \"\\<not>(\\<exists>j \\<ge> i. rank x m = Some j) \\<and> token_run x m \\<notin> F\""], ["proof (prove)\nusing this:\n  token_run x ?m \\<notin> F\n  \\<not> (\\<exists>j\\<ge>i. rank x m = Some j)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j\\<ge>i. rank x m = Some j) \\<and>\n    token_run x m \\<notin> F", "by blast"], ["proof (state)\nthis:\n  \\<not> (\\<exists>j\\<ge>i. rank x m = Some j) \\<and>\n  token_run x m \\<notin> F\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "}"], ["proof (state)\nthis:\n  \\<not> token_succeeds x \\<Longrightarrow>\n  \\<not> (\\<exists>j\\<ge>i. rank x m = Some j) \\<and>\n  token_run x m \\<notin> F\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "ultimately"], ["proof (chain)\npicking this:\n  n \\<le> m\n  x \\<le> m\n  \\<lbrakk>token_succeeds x; token_run x m \\<notin> F\\<rbrakk>\n  \\<Longrightarrow> \\<exists>j\\<ge>i. rank x m = Some j\n  \\<not> token_succeeds x \\<Longrightarrow>\n  \\<not> (\\<exists>j\\<ge>i. rank x m = Some j) \\<and>\n  token_run x m \\<notin> F", "have \"(\\<exists>j \\<ge> i. rank x m = Some j) \\<or> token_run x m \\<in> F \\<longleftrightarrow> token_succeeds x\""], ["proof (prove)\nusing this:\n  n \\<le> m\n  x \\<le> m\n  \\<lbrakk>token_succeeds x; token_run x m \\<notin> F\\<rbrakk>\n  \\<Longrightarrow> \\<exists>j\\<ge>i. rank x m = Some j\n  \\<not> token_succeeds x \\<Longrightarrow>\n  \\<not> (\\<exists>j\\<ge>i. rank x m = Some j) \\<and>\n  token_run x m \\<notin> F\n\ngoal (1 subgoal):\n 1. ((\\<exists>j\\<ge>i. rank x m = Some j) \\<or> token_run x m \\<in> F) =\n    token_succeeds x", "by (cases \"token_succeeds x\") (blast, simp)"], ["proof (state)\nthis:\n  ((\\<exists>j\\<ge>i. rank x m = Some j) \\<or> token_run x m \\<in> F) =\n  token_succeeds x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>n \\<le> ?m2; ?x2 \\<le> ?m2\\<rbrakk>\n  \\<Longrightarrow> ((\\<exists>j\\<ge>i. rank ?x2 ?m2 = Some j) \\<or>\n                     token_run ?x2 ?m2 \\<in> F) =\n                    token_succeeds ?x2\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "moreover\n  \\<comment> \\<open>By definition of n all tokens @{term \"\\<And>x. x \\<ge> n\"} succeed\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>n \\<le> ?m2; ?x2 \\<le> ?m2\\<rbrakk>\n  \\<Longrightarrow> ((\\<exists>j\\<ge>i. rank ?x2 ?m2 = Some j) \\<or>\n                     token_run ?x2 ?m2 \\<in> F) =\n                    token_succeeds ?x2\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "have \"\\<And>m x. m \\<ge> n \\<Longrightarrow> \\<not>x \\<le> m \\<Longrightarrow> token_succeeds x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m x.\n       \\<lbrakk>n \\<le> m; \\<not> x \\<le> m\\<rbrakk>\n       \\<Longrightarrow> token_succeeds x", "using n_def n\\<^sub>1_def"], ["proof (prove)\nusing this:\n  n = Max {n\\<^sub>1, n\\<^sub>2, n\\<^sub>3}\n  \\<forall>x\\<ge>n\\<^sub>1. token_succeeds x\n\ngoal (1 subgoal):\n 1. \\<And>m x.\n       \\<lbrakk>n \\<le> m; \\<not> x \\<le> m\\<rbrakk>\n       \\<Longrightarrow> token_succeeds x", "by force"], ["proof (state)\nthis:\n  \\<lbrakk>n \\<le> ?m; \\<not> ?x \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> token_succeeds ?x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>n \\<le> ?m2; ?x2 \\<le> ?m2\\<rbrakk>\n  \\<Longrightarrow> ((\\<exists>j\\<ge>i. rank ?x2 ?m2 = Some j) \\<or>\n                     token_run ?x2 ?m2 \\<in> F) =\n                    token_succeeds ?x2\n  \\<lbrakk>n \\<le> ?m; \\<not> ?x \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> token_succeeds ?x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>n \\<le> ?m2; ?x2 \\<le> ?m2\\<rbrakk>\n  \\<Longrightarrow> ((\\<exists>j\\<ge>i. rank ?x2 ?m2 = Some j) \\<or>\n                     token_run ?x2 ?m2 \\<in> F) =\n                    token_succeeds ?x2\n  \\<lbrakk>n \\<le> ?m; \\<not> ?x \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> token_succeeds ?x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>x.\n          token_succeeds x =\n          (n < x \\<or>\n           (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n           token_run x n \\<in> F)", "unfolding MOST_nat_le not_le[symmetric]"], ["proof (prove)\nusing this:\n  \\<lbrakk>n \\<le> ?m2; ?x2 \\<le> ?m2\\<rbrakk>\n  \\<Longrightarrow> ((\\<exists>j\\<ge>i. rank ?x2 ?m2 = Some j) \\<or>\n                     token_run ?x2 ?m2 \\<in> F) =\n                    token_succeeds ?x2\n  \\<lbrakk>n \\<le> ?m; \\<not> ?x \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> token_succeeds ?x\n\ngoal (1 subgoal):\n 1. \\<exists>m.\n       \\<forall>n\\<ge>m.\n          \\<forall>x.\n             token_succeeds x =\n             (\\<not> x \\<le> n \\<or>\n              (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n              token_run x n \\<in> F)", "by blast"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>\\<infinity>n.\n     \\<forall>x.\n        token_succeeds x =\n        (n < x \\<or>\n         (\\<exists>j\\<ge>i. rank x n = Some j) \\<or> token_run x n \\<in> F)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma succeeding_states:\n  assumes \"smallest_accepting_rank = Some i\"\n  shows \"\\<forall>\\<^sub>\\<infinity>n. \\<forall>q. ((\\<exists>x \\<in> configuration q n. token_succeeds x) \\<longrightarrow> q \\<in> \\<S> n) \\<and> (q \\<in> \\<S> n \\<longrightarrow> (\\<forall>x \\<in> configuration q n. token_succeeds x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>q.\n          (Bex (configuration q n) token_succeeds \\<longrightarrow>\n           q \\<in> \\<S> n) \\<and>\n          (q \\<in> \\<S> n \\<longrightarrow>\n           Ball (configuration q n) token_succeeds)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>q.\n          (Bex (configuration q n) token_succeeds \\<longrightarrow>\n           q \\<in> \\<S> n) \\<and>\n          (q \\<in> \\<S> n \\<longrightarrow>\n           Ball (configuration q n) token_succeeds)", "obtain n where n_def: \"\\<And>m x. m \\<ge> n \\<Longrightarrow> token_succeeds x = (x > m \\<or> (\\<exists>j \\<ge> i. rank x m = Some j) \\<or> token_run x m \\<in> F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        (\\<And>m x.\n            n \\<le> m \\<Longrightarrow>\n            token_succeeds x =\n            (m < x \\<or>\n             (\\<exists>j\\<ge>i. rank x m = Some j) \\<or>\n             token_run x m \\<in> F)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using token_smallest_accepting_rank[OF assms]"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>\\<infinity>n.\n     \\<forall>x.\n        token_succeeds x =\n        (n < x \\<or>\n         (\\<exists>j\\<ge>i. rank x n = Some j) \\<or> token_run x n \\<in> F)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        (\\<And>m x.\n            n \\<le> m \\<Longrightarrow>\n            token_succeeds x =\n            (m < x \\<or>\n             (\\<exists>j\\<ge>i. rank x m = Some j) \\<or>\n             token_run x m \\<in> F)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding MOST_nat_le"], ["proof (prove)\nusing this:\n  \\<exists>m.\n     \\<forall>n\\<ge>m.\n        \\<forall>x.\n           token_succeeds x =\n           (n < x \\<or>\n            (\\<exists>j\\<ge>i. rank x n = Some j) \\<or>\n            token_run x n \\<in> F)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        (\\<And>m x.\n            n \\<le> m \\<Longrightarrow>\n            token_succeeds x =\n            (m < x \\<or>\n             (\\<exists>j\\<ge>i. rank x m = Some j) \\<or>\n             token_run x m \\<in> F)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  n \\<le> ?m \\<Longrightarrow>\n  token_succeeds ?x =\n  (?m < ?x \\<or>\n   (\\<exists>j\\<ge>i. rank ?x ?m = Some j) \\<or> token_run ?x ?m \\<in> F)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>q.\n          (Bex (configuration q n) token_succeeds \\<longrightarrow>\n           q \\<in> \\<S> n) \\<and>\n          (q \\<in> \\<S> n \\<longrightarrow>\n           Ball (configuration q n) token_succeeds)", "{"], ["proof (state)\nthis:\n  n \\<le> ?m \\<Longrightarrow>\n  token_succeeds ?x =\n  (?m < ?x \\<or>\n   (\\<exists>j\\<ge>i. rank ?x ?m = Some j) \\<or> token_run ?x ?m \\<in> F)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>q.\n          (Bex (configuration q n) token_succeeds \\<longrightarrow>\n           q \\<in> \\<S> n) \\<and>\n          (q \\<in> \\<S> n \\<longrightarrow>\n           Ball (configuration q n) token_succeeds)", "fix m q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>q.\n          (Bex (configuration q n) token_succeeds \\<longrightarrow>\n           q \\<in> \\<S> n) \\<and>\n          (q \\<in> \\<S> n \\<longrightarrow>\n           Ball (configuration q n) token_succeeds)", "assume \"m \\<ge> n\" \"q \\<notin> F\" \"\\<exists>x \\<in> configuration q m. token_succeeds x\""], ["proof (state)\nthis:\n  n \\<le> m\n  q \\<notin> F\n  Bex (configuration q m) token_succeeds\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>q.\n          (Bex (configuration q n) token_succeeds \\<longrightarrow>\n           q \\<in> \\<S> n) \\<and>\n          (q \\<in> \\<S> n \\<longrightarrow>\n           Ball (configuration q n) token_succeeds)", "moreover"], ["proof (state)\nthis:\n  n \\<le> m\n  q \\<notin> F\n  Bex (configuration q m) token_succeeds\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>q.\n          (Bex (configuration q n) token_succeeds \\<longrightarrow>\n           q \\<in> \\<S> n) \\<and>\n          (q \\<in> \\<S> n \\<longrightarrow>\n           Ball (configuration q n) token_succeeds)", "then"], ["proof (chain)\npicking this:\n  n \\<le> m\n  q \\<notin> F\n  Bex (configuration q m) token_succeeds", "obtain x where \"token_run x m = q\" and \"x \\<le> m\" and \"token_succeeds x\""], ["proof (prove)\nusing this:\n  n \\<le> m\n  q \\<notin> F\n  Bex (configuration q m) token_succeeds\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>token_run x m = q; x \\<le> m; token_succeeds x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  token_run x m = q\n  x \\<le> m\n  token_succeeds x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>q.\n          (Bex (configuration q n) token_succeeds \\<longrightarrow>\n           q \\<in> \\<S> n) \\<and>\n          (q \\<in> \\<S> n \\<longrightarrow>\n           Ball (configuration q n) token_succeeds)", "ultimately"], ["proof (chain)\npicking this:\n  n \\<le> m\n  q \\<notin> F\n  Bex (configuration q m) token_succeeds\n  token_run x m = q\n  x \\<le> m\n  token_succeeds x", "have \"\\<exists>j \\<ge> i. rank x m = Some j\""], ["proof (prove)\nusing this:\n  n \\<le> m\n  q \\<notin> F\n  Bex (configuration q m) token_succeeds\n  token_run x m = q\n  x \\<le> m\n  token_succeeds x\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>i. rank x m = Some j", "using n_def"], ["proof (prove)\nusing this:\n  n \\<le> m\n  q \\<notin> F\n  Bex (configuration q m) token_succeeds\n  token_run x m = q\n  x \\<le> m\n  token_succeeds x\n  n \\<le> ?m \\<Longrightarrow>\n  token_succeeds ?x =\n  (?m < ?x \\<or>\n   (\\<exists>j\\<ge>i. rank ?x ?m = Some j) \\<or> token_run ?x ?m \\<in> F)\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>i. rank x m = Some j", "by simp"], ["proof (state)\nthis:\n  \\<exists>j\\<ge>i. rank x m = Some j\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>q.\n          (Bex (configuration q n) token_succeeds \\<longrightarrow>\n           q \\<in> \\<S> n) \\<and>\n          (q \\<in> \\<S> n \\<longrightarrow>\n           Ball (configuration q n) token_succeeds)", "hence \"\\<exists>j \\<ge> i. state_rank q m = Some j\""], ["proof (prove)\nusing this:\n  \\<exists>j\\<ge>i. rank x m = Some j\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>i. state_rank q m = Some j", "using rank_eq_state_rank \\<open>x \\<le> m\\<close> \\<open>token_run x m = q\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>j\\<ge>i. rank x m = Some j\n  ?x \\<le> ?n \\<Longrightarrow> rank ?x ?n = state_rank (token_run ?x ?n) ?n\n  x \\<le> m\n  token_run x m = q\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>i. state_rank q m = Some j", "by metis"], ["proof (state)\nthis:\n  \\<exists>j\\<ge>i. state_rank q m = Some j\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>q.\n          (Bex (configuration q n) token_succeeds \\<longrightarrow>\n           q \\<in> \\<S> n) \\<and>\n          (q \\<in> \\<S> n \\<longrightarrow>\n           Ball (configuration q n) token_succeeds)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>n \\<le> ?m2; ?q2 \\<notin> F;\n   Bex (configuration ?q2 ?m2) token_succeeds\\<rbrakk>\n  \\<Longrightarrow> \\<exists>j\\<ge>i. state_rank ?q2 ?m2 = Some j\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>q.\n          (Bex (configuration q n) token_succeeds \\<longrightarrow>\n           q \\<in> \\<S> n) \\<and>\n          (q \\<in> \\<S> n \\<longrightarrow>\n           Ball (configuration q n) token_succeeds)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>n \\<le> ?m2; ?q2 \\<notin> F;\n   Bex (configuration ?q2 ?m2) token_succeeds\\<rbrakk>\n  \\<Longrightarrow> \\<exists>j\\<ge>i. state_rank ?q2 ?m2 = Some j\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>q.\n          (Bex (configuration q n) token_succeeds \\<longrightarrow>\n           q \\<in> \\<S> n) \\<and>\n          (q \\<in> \\<S> n \\<longrightarrow>\n           Ball (configuration q n) token_succeeds)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>n \\<le> ?m2; ?q2 \\<notin> F;\n   Bex (configuration ?q2 ?m2) token_succeeds\\<rbrakk>\n  \\<Longrightarrow> \\<exists>j\\<ge>i. state_rank ?q2 ?m2 = Some j\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>q.\n          (Bex (configuration q n) token_succeeds \\<longrightarrow>\n           q \\<in> \\<S> n) \\<and>\n          (q \\<in> \\<S> n \\<longrightarrow>\n           Ball (configuration q n) token_succeeds)", "fix m q x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>q.\n          (Bex (configuration q n) token_succeeds \\<longrightarrow>\n           q \\<in> \\<S> n) \\<and>\n          (q \\<in> \\<S> n \\<longrightarrow>\n           Ball (configuration q n) token_succeeds)", "assume \"m \\<ge> n\" \"x \\<in> configuration q m\""], ["proof (state)\nthis:\n  n \\<le> m\n  x \\<in> configuration q m\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>q.\n          (Bex (configuration q n) token_succeeds \\<longrightarrow>\n           q \\<in> \\<S> n) \\<and>\n          (q \\<in> \\<S> n \\<longrightarrow>\n           Ball (configuration q n) token_succeeds)", "hence \"x \\<le> m\" and \"token_run x m = q\""], ["proof (prove)\nusing this:\n  n \\<le> m\n  x \\<in> configuration q m\n\ngoal (1 subgoal):\n 1. x \\<le> m &&& token_run x m = q", "by simp+"], ["proof (state)\nthis:\n  x \\<le> m\n  token_run x m = q\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>q.\n          (Bex (configuration q n) token_succeeds \\<longrightarrow>\n           q \\<in> \\<S> n) \\<and>\n          (q \\<in> \\<S> n \\<longrightarrow>\n           Ball (configuration q n) token_succeeds)", "moreover"], ["proof (state)\nthis:\n  x \\<le> m\n  token_run x m = q\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>q.\n          (Bex (configuration q n) token_succeeds \\<longrightarrow>\n           q \\<in> \\<S> n) \\<and>\n          (q \\<in> \\<S> n \\<longrightarrow>\n           Ball (configuration q n) token_succeeds)", "assume \"q \\<in> \\<S> m\""], ["proof (state)\nthis:\n  q \\<in> \\<S> m\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>q.\n          (Bex (configuration q n) token_succeeds \\<longrightarrow>\n           q \\<in> \\<S> n) \\<and>\n          (q \\<in> \\<S> n \\<longrightarrow>\n           Ball (configuration q n) token_succeeds)", "hence \"(\\<exists>j \\<ge> i. state_rank q m = Some j) \\<or> q \\<in> F\""], ["proof (prove)\nusing this:\n  q \\<in> \\<S> m\n\ngoal (1 subgoal):\n 1. (\\<exists>j\\<ge>i. state_rank q m = Some j) \\<or> q \\<in> F", "using assms"], ["proof (prove)\nusing this:\n  q \\<in> \\<S> m\n  smallest_accepting_rank = Some i\n\ngoal (1 subgoal):\n 1. (\\<exists>j\\<ge>i. state_rank q m = Some j) \\<or> q \\<in> F", "by fastforce"], ["proof (state)\nthis:\n  (\\<exists>j\\<ge>i. state_rank q m = Some j) \\<or> q \\<in> F\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>q.\n          (Bex (configuration q n) token_succeeds \\<longrightarrow>\n           q \\<in> \\<S> n) \\<and>\n          (q \\<in> \\<S> n \\<longrightarrow>\n           Ball (configuration q n) token_succeeds)", "ultimately"], ["proof (chain)\npicking this:\n  x \\<le> m\n  token_run x m = q\n  (\\<exists>j\\<ge>i. state_rank q m = Some j) \\<or> q \\<in> F", "have \"(\\<exists>j \\<ge> i. rank x m = Some j) \\<or> q \\<in> F\""], ["proof (prove)\nusing this:\n  x \\<le> m\n  token_run x m = q\n  (\\<exists>j\\<ge>i. state_rank q m = Some j) \\<or> q \\<in> F\n\ngoal (1 subgoal):\n 1. (\\<exists>j\\<ge>i. rank x m = Some j) \\<or> q \\<in> F", "using rank_eq_state_rank"], ["proof (prove)\nusing this:\n  x \\<le> m\n  token_run x m = q\n  (\\<exists>j\\<ge>i. state_rank q m = Some j) \\<or> q \\<in> F\n  ?x \\<le> ?n \\<Longrightarrow> rank ?x ?n = state_rank (token_run ?x ?n) ?n\n\ngoal (1 subgoal):\n 1. (\\<exists>j\\<ge>i. rank x m = Some j) \\<or> q \\<in> F", "by presburger"], ["proof (state)\nthis:\n  (\\<exists>j\\<ge>i. rank x m = Some j) \\<or> q \\<in> F\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>q.\n          (Bex (configuration q n) token_succeeds \\<longrightarrow>\n           q \\<in> \\<S> n) \\<and>\n          (q \\<in> \\<S> n \\<longrightarrow>\n           Ball (configuration q n) token_succeeds)", "hence \"token_succeeds x\""], ["proof (prove)\nusing this:\n  (\\<exists>j\\<ge>i. rank x m = Some j) \\<or> q \\<in> F\n\ngoal (1 subgoal):\n 1. token_succeeds x", "unfolding n_def[OF \\<open>m \\<ge> n\\<close>] \\<open>token_run x m = q\\<close>"], ["proof (prove)\nusing this:\n  (\\<exists>j\\<ge>i. rank x m = Some j) \\<or> q \\<in> F\n\ngoal (1 subgoal):\n 1. m < x \\<or> (\\<exists>j\\<ge>i. rank x m = Some j) \\<or> q \\<in> F", "by presburger"], ["proof (state)\nthis:\n  token_succeeds x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>q.\n          (Bex (configuration q n) token_succeeds \\<longrightarrow>\n           q \\<in> \\<S> n) \\<and>\n          (q \\<in> \\<S> n \\<longrightarrow>\n           Ball (configuration q n) token_succeeds)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>n \\<le> ?m2; ?x2 \\<in> configuration ?q2 ?m2;\n   ?q2 \\<in> \\<S> ?m2\\<rbrakk>\n  \\<Longrightarrow> token_succeeds ?x2\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>q.\n          (Bex (configuration q n) token_succeeds \\<longrightarrow>\n           q \\<in> \\<S> n) \\<and>\n          (q \\<in> \\<S> n \\<longrightarrow>\n           Ball (configuration q n) token_succeeds)", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>n \\<le> ?m2; ?q2 \\<notin> F;\n   Bex (configuration ?q2 ?m2) token_succeeds\\<rbrakk>\n  \\<Longrightarrow> \\<exists>j\\<ge>i. state_rank ?q2 ?m2 = Some j\n  \\<lbrakk>n \\<le> ?m2; ?x2 \\<in> configuration ?q2 ?m2;\n   ?q2 \\<in> \\<S> ?m2\\<rbrakk>\n  \\<Longrightarrow> token_succeeds ?x2", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>n \\<le> ?m2; ?q2 \\<notin> F;\n   Bex (configuration ?q2 ?m2) token_succeeds\\<rbrakk>\n  \\<Longrightarrow> \\<exists>j\\<ge>i. state_rank ?q2 ?m2 = Some j\n  \\<lbrakk>n \\<le> ?m2; ?x2 \\<in> configuration ?q2 ?m2;\n   ?q2 \\<in> \\<S> ?m2\\<rbrakk>\n  \\<Longrightarrow> token_succeeds ?x2\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>n.\n       \\<forall>q.\n          (Bex (configuration q n) token_succeeds \\<longrightarrow>\n           q \\<in> \\<S> n) \\<and>\n          (q \\<in> \\<S> n \\<longrightarrow>\n           Ball (configuration q n) token_succeeds)", "unfolding MOST_nat_le \\<S>.simps assms option.sel"], ["proof (prove)\nusing this:\n  \\<lbrakk>n \\<le> ?m2; ?q2 \\<notin> F;\n   Bex (configuration ?q2 ?m2) token_succeeds\\<rbrakk>\n  \\<Longrightarrow> \\<exists>j\\<ge>i. state_rank ?q2 ?m2 = Some j\n  \\<lbrakk>n \\<le> ?m2; ?x2 \\<in> configuration ?q2 ?m2;\n   ?q2\n   \\<in> F \\<union>\n         {q. \\<exists>j\\<ge>i. state_rank q ?m2 = Some j}\\<rbrakk>\n  \\<Longrightarrow> token_succeeds ?x2\n\ngoal (1 subgoal):\n 1. \\<exists>m.\n       \\<forall>n\\<ge>m.\n          \\<forall>q.\n             (Bex (configuration q n) token_succeeds \\<longrightarrow>\n              q \\<in> F \\<union>\n                      {q. \\<exists>j\\<ge>i. state_rank q n = Some j}) \\<and>\n             (q \\<in> F \\<union>\n                      {q. \\<exists>j\\<ge>i.\n                             state_rank q n = Some j} \\<longrightarrow>\n              Ball (configuration q n) token_succeeds)", "by blast"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>\\<infinity>n.\n     \\<forall>q.\n        (Bex (configuration q n) token_succeeds \\<longrightarrow>\n         q \\<in> \\<S> n) \\<and>\n        (q \\<in> \\<S> n \\<longrightarrow>\n         Ball (configuration q n) token_succeeds)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}