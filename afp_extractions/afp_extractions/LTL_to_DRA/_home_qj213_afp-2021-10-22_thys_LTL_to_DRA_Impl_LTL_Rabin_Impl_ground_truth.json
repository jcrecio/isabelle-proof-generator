{"file_name": "/home/qj213/afp-2021-10-22/thys/LTL_to_DRA/Impl/LTL_Rabin_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/LTL_to_DRA", "problem_names": ["lemma mappings\\<^sub>C_code:\n  \"mappings\\<^sub>C \\<Sigma> \\<phi> = (\n    let \n      Gs = G_list \\<phi>; \n      max_rank = Mapping.lookup (Mapping.tabulate Gs (max_rank_of\\<^sub>C \\<Sigma>))\n    in \n      set (concat (map (mapping_generator_list (\\<lambda>x. [0 ..< the (max_rank x)])) (subseqs Gs))))\"\n  (is \"?lhs = ?rhs\")", "lemma reach_delta_initial:\n  assumes \"(x, y) \\<in> reach \\<Sigma> (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>)\"\n  assumes \"\\<chi> \\<in> \\<^bold>G \\<phi>\"\n  shows \"Mapping.lookup y \\<chi> \\<noteq> None\" (is ?t1)\n    and \"distinct (the (Mapping.lookup y \\<chi>))\" (is ?t2)", "lemma finite_reach\\<^sub>C:\n  \"finite (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>))\"", "lemma max_rank_of\\<^sub>C_eq:\n  assumes \"\\<Sigma> = set \\<Sigma>'\"\n  shows \"max_rank_of\\<^sub>C \\<Sigma>' \\<psi> = max_rank_of \\<Sigma> \\<psi>\"", "lemma reachable_transitions\\<^sub>C_eq:\n  assumes \"\\<Sigma> = set \\<Sigma>'\"\n  shows \"reachable_transitions\\<^sub>C \\<Sigma>' \\<phi> = reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>)\"", "lemma run_abstraction_correct:\n  \"run (delta \\<Sigma>) (initial \\<phi>) w = abstract_state o (run (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>) w)\"", "lemma \n  assumes \"t \\<in> reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>)\"\n  assumes \"\\<chi> \\<in> \\<^bold>G \\<phi>\"\n  shows Acc_fin\\<^sub>C_correct: \n    \"abstract_transition t \\<in> Acc_fin \\<Sigma> \\<pi> \\<chi> \\<longleftrightarrow> Acc_fin\\<^sub>C \\<Sigma> (Mapping.Mapping \\<pi>) \\<chi> t\" (is ?t1)\n    and Acc_inf\\<^sub>C_correct: \n    \"abstract_transition t \\<in> Acc_inf \\<pi> \\<chi> \\<longleftrightarrow> Acc_inf\\<^sub>C (Mapping.Mapping \\<pi>) \\<chi> t\" (is ?t2)", "theorem ltl_to_generalized_rabin\\<^sub>C_correct:\n  assumes \"\\<Sigma> = set \\<Sigma>'\"\n  shows \"accept\\<^sub>G\\<^sub>R (ltl_to_generalized_rabin \\<Sigma> \\<phi>) w \\<longleftrightarrow> accept\\<^sub>G\\<^sub>R_LTS (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w\" \n  (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma M_fin\\<^sub>C_af_correct:\n  assumes \"t \\<in> reach\\<^sub>t \\<Sigma> (ltl_to_rabin_base_code_def.delta\\<^sub>C \\<up>af \\<up>af\\<^sub>G Abs \\<Sigma>) (ltl_to_rabin_base_code_def.initial\\<^sub>C Abs Abs \\<phi>)\"\n  assumes \"dom \\<pi> \\<subseteq> \\<^bold>G \\<phi>\"\n  shows \"abstract_transition t \\<in> M_fin \\<pi> = M_fin\\<^sub>C_af \\<phi> (Mapping.Mapping \\<pi>) t\"", "theorem ltl_to_generalized_rabin\\<^sub>C_af_correct:\n  assumes \"range w \\<subseteq> set \\<Sigma>\"\n  shows \"w \\<Turnstile> \\<phi> \\<longleftrightarrow> accept\\<^sub>G\\<^sub>R_LTS (ltl_to_generalized_rabin\\<^sub>C_af \\<Sigma> \\<phi>) w\" \n  (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma M_fin\\<^sub>C_af\\<^sub>\\<UU>_correct:\n  assumes \"t \\<in> reach\\<^sub>t \\<Sigma> (ltl_to_rabin_base_code_def.delta\\<^sub>C \\<up>af\\<^sub>\\<UU> \\<up>af\\<^sub>G\\<^sub>\\<UU> (Abs \\<circ> Unf\\<^sub>G) \\<Sigma>) (ltl_to_rabin_base_code_def.initial\\<^sub>C (Abs \\<circ> Unf) (Abs \\<circ> Unf\\<^sub>G) \\<phi>)\"\n  assumes \"dom \\<pi> \\<subseteq> \\<^bold>G \\<phi>\"\n  shows \"abstract_transition t \\<in> M\\<^sub>\\<UU>_fin \\<pi> = M_fin\\<^sub>C_af\\<^sub>\\<UU> \\<phi> (Mapping.Mapping \\<pi>) t\"", "theorem ltl_to_generalized_rabin\\<^sub>C_af\\<^sub>\\<UU>_correct:\n  assumes \"range w \\<subseteq> set \\<Sigma>\"\n  shows \"w \\<Turnstile> \\<phi> \\<longleftrightarrow> accept\\<^sub>G\\<^sub>R_LTS (ltl_to_generalized_rabin\\<^sub>C_af\\<^sub>\\<UU> \\<Sigma> \\<phi>) w\" \n  (is \"?lhs \\<longleftrightarrow> ?rhs\")"], "translations": [["", "lemma mappings\\<^sub>C_code:\n  \"mappings\\<^sub>C \\<Sigma> \\<phi> = (\n    let \n      Gs = G_list \\<phi>; \n      max_rank = Mapping.lookup (Mapping.tabulate Gs (max_rank_of\\<^sub>C \\<Sigma>))\n    in \n      set (concat (map (mapping_generator_list (\\<lambda>x. [0 ..< the (max_rank x)])) (subseqs Gs))))\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. mappings\\<^sub>C \\<Sigma> \\<phi> =\n    (let Gs = G_list \\<phi>;\n         max_rank =\n           Mapping.lookup\n            (Mapping.tabulate Gs (max_rank_of\\<^sub>C \\<Sigma>))\n     in set (concat\n              (map (mapping_generator_list\n                     (\\<lambda>x. [0..<the (max_rank x)]))\n                (subseqs Gs))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mappings\\<^sub>C \\<Sigma> \\<phi> =\n    (let Gs = G_list \\<phi>;\n         max_rank =\n           Mapping.lookup\n            (Mapping.tabulate Gs (max_rank_of\\<^sub>C \\<Sigma>))\n     in set (concat\n              (map (mapping_generator_list\n                     (\\<lambda>x. [0..<the (max_rank x)]))\n                (subseqs Gs))))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. mappings\\<^sub>C \\<Sigma> \\<phi> =\n    (let Gs = G_list \\<phi>;\n         max_rank =\n           Mapping.lookup\n            (Mapping.tabulate Gs (max_rank_of\\<^sub>C \\<Sigma>))\n     in set (concat\n              (map (mapping_generator_list\n                     (\\<lambda>x. [0..<the (max_rank x)]))\n                (subseqs Gs))))", "fix xs :: \"'a ltl list\""], ["proof (state)\ngoal (1 subgoal):\n 1. mappings\\<^sub>C \\<Sigma> \\<phi> =\n    (let Gs = G_list \\<phi>;\n         max_rank =\n           Mapping.lookup\n            (Mapping.tabulate Gs (max_rank_of\\<^sub>C \\<Sigma>))\n     in set (concat\n              (map (mapping_generator_list\n                     (\\<lambda>x. [0..<the (max_rank x)]))\n                (subseqs Gs))))", "have subset_G: \"\\<And>x. x \\<in> set (subseqs (xs)) \\<Longrightarrow> set x \\<subseteq> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (subseqs xs) \\<Longrightarrow> set x \\<subseteq> set xs", "apply (induction xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set (subseqs []) \\<Longrightarrow> set x \\<subseteq> set []\n 2. \\<And>a xs x.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set (subseqs xs) \\<Longrightarrow>\n                   set x \\<subseteq> set xs;\n        x \\<in> set (subseqs (a # xs))\\<rbrakk>\n       \\<Longrightarrow> set x \\<subseteq> set (a # xs)", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs x.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set (subseqs xs) \\<Longrightarrow>\n                   set x \\<subseteq> set xs;\n        x \\<in> set (subseqs (a # xs))\\<rbrakk>\n       \\<Longrightarrow> set x \\<subseteq> set (a # xs)", "by (insert subseqs_powset; blast)"], ["proof (state)\nthis:\n  ?x17 \\<in> set (subseqs xs) \\<Longrightarrow> set ?x17 \\<subseteq> set xs\n\ngoal (1 subgoal):\n 1. mappings\\<^sub>C \\<Sigma> \\<phi> =\n    (let Gs = G_list \\<phi>;\n         max_rank =\n           Mapping.lookup\n            (Mapping.tabulate Gs (max_rank_of\\<^sub>C \\<Sigma>))\n     in set (concat\n              (map (mapping_generator_list\n                     (\\<lambda>x. [0..<the (max_rank x)]))\n                (subseqs Gs))))", "}"], ["proof (state)\nthis:\n  ?x17 \\<in> set (subseqs ?xs20) \\<Longrightarrow>\n  set ?x17 \\<subseteq> set ?xs20\n\ngoal (1 subgoal):\n 1. mappings\\<^sub>C \\<Sigma> \\<phi> =\n    (let Gs = G_list \\<phi>;\n         max_rank =\n           Mapping.lookup\n            (Mapping.tabulate Gs (max_rank_of\\<^sub>C \\<Sigma>))\n     in set (concat\n              (map (mapping_generator_list\n                     (\\<lambda>x. [0..<the (max_rank x)]))\n                (subseqs Gs))))", "hence subset_G: \"\\<And>x. x \\<in> set (subseqs (G_list \\<phi>)) \\<Longrightarrow> set x \\<subseteq> \\<^bold>G \\<phi>\""], ["proof (prove)\nusing this:\n  ?x17 \\<in> set (subseqs ?xs20) \\<Longrightarrow>\n  set ?x17 \\<subseteq> set ?xs20\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (subseqs (G_list \\<phi>)) \\<Longrightarrow>\n       set x \\<subseteq> \\<^bold>G \\<phi>", "unfolding G_eq_G_list"], ["proof (prove)\nusing this:\n  ?x17 \\<in> set (subseqs ?xs20) \\<Longrightarrow>\n  set ?x17 \\<subseteq> set ?xs20\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (subseqs (G_list \\<phi>)) \\<Longrightarrow>\n       set x \\<subseteq> set (G_list \\<phi>)", "by auto"], ["proof (state)\nthis:\n  ?x17 \\<in> set (subseqs (G_list \\<phi>)) \\<Longrightarrow>\n  set ?x17 \\<subseteq> \\<^bold>G \\<phi>\n\ngoal (1 subgoal):\n 1. mappings\\<^sub>C \\<Sigma> \\<phi> =\n    (let Gs = G_list \\<phi>;\n         max_rank =\n           Mapping.lookup\n            (Mapping.tabulate Gs (max_rank_of\\<^sub>C \\<Sigma>))\n     in set (concat\n              (map (mapping_generator_list\n                     (\\<lambda>x. [0..<the (max_rank x)]))\n                (subseqs Gs))))", "have \"?lhs = \\<Union>{{\\<pi>. Mapping.keys \\<pi> = xs \\<and> (\\<forall>\\<chi>\\<in>Mapping.keys \\<pi>. the (Mapping.lookup \\<pi> \\<chi>) < max_rank_of\\<^sub>C \\<Sigma> \\<chi>)} | xs. xs \\<in> set ` (set (subseqs (G_list \\<phi>)))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mappings\\<^sub>C \\<Sigma> \\<phi> =\n    \\<Union>\n     {{\\<pi>.\n       Mapping.keys \\<pi> = xs \\<and>\n       (\\<forall>\\<chi>\\<in>Mapping.keys \\<pi>.\n           the (Mapping.lookup \\<pi> \\<chi>)\n           < max_rank_of\\<^sub>C \\<Sigma> \\<chi>)} |\n      xs. xs \\<in> set ` set (subseqs (G_list \\<phi>))}", "unfolding mappings\\<^sub>C_def G_eq_G_list subseqs_powset"], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<pi>.\n     Mapping.keys \\<pi> \\<subseteq> set (G_list \\<phi>) \\<and>\n     (\\<forall>\\<chi>\\<in>Mapping.keys \\<pi>.\n         the (Mapping.lookup \\<pi> \\<chi>)\n         < max_rank_of\\<^sub>C \\<Sigma> \\<chi>)} =\n    \\<Union>\n     {{\\<pi>.\n       Mapping.keys \\<pi> = xs \\<and>\n       (\\<forall>\\<chi>\\<in>Mapping.keys \\<pi>.\n           the (Mapping.lookup \\<pi> \\<chi>)\n           < max_rank_of\\<^sub>C \\<Sigma> \\<chi>)} |\n      xs. xs \\<in> Pow (set (G_list \\<phi>))}", "by auto"], ["proof (state)\nthis:\n  mappings\\<^sub>C \\<Sigma> \\<phi> =\n  \\<Union>\n   {{\\<pi>.\n     Mapping.keys \\<pi> = xs \\<and>\n     (\\<forall>\\<chi>\\<in>Mapping.keys \\<pi>.\n         the (Mapping.lookup \\<pi> \\<chi>)\n         < max_rank_of\\<^sub>C \\<Sigma> \\<chi>)} |\n    xs. xs \\<in> set ` set (subseqs (G_list \\<phi>))}\n\ngoal (1 subgoal):\n 1. mappings\\<^sub>C \\<Sigma> \\<phi> =\n    (let Gs = G_list \\<phi>;\n         max_rank =\n           Mapping.lookup\n            (Mapping.tabulate Gs (max_rank_of\\<^sub>C \\<Sigma>))\n     in set (concat\n              (map (mapping_generator_list\n                     (\\<lambda>x. [0..<the (max_rank x)]))\n                (subseqs Gs))))", "also"], ["proof (state)\nthis:\n  mappings\\<^sub>C \\<Sigma> \\<phi> =\n  \\<Union>\n   {{\\<pi>.\n     Mapping.keys \\<pi> = xs \\<and>\n     (\\<forall>\\<chi>\\<in>Mapping.keys \\<pi>.\n         the (Mapping.lookup \\<pi> \\<chi>)\n         < max_rank_of\\<^sub>C \\<Sigma> \\<chi>)} |\n    xs. xs \\<in> set ` set (subseqs (G_list \\<phi>))}\n\ngoal (1 subgoal):\n 1. mappings\\<^sub>C \\<Sigma> \\<phi> =\n    (let Gs = G_list \\<phi>;\n         max_rank =\n           Mapping.lookup\n            (Mapping.tabulate Gs (max_rank_of\\<^sub>C \\<Sigma>))\n     in set (concat\n              (map (mapping_generator_list\n                     (\\<lambda>x. [0..<the (max_rank x)]))\n                (subseqs Gs))))", "have \"\\<dots> = \\<Union>{{\\<pi>. Mapping.keys \\<pi> = set xs \\<and> (\\<forall>\\<chi> \\<in> set xs. the (Mapping.lookup \\<pi> \\<chi>) < max_rank_of\\<^sub>C \\<Sigma> \\<chi>)} |\n       xs. xs \\<in> set (subseqs (G_list \\<phi>))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     {{\\<pi>.\n       Mapping.keys \\<pi> = xs \\<and>\n       (\\<forall>\\<chi>\\<in>Mapping.keys \\<pi>.\n           the (Mapping.lookup \\<pi> \\<chi>)\n           < max_rank_of\\<^sub>C \\<Sigma> \\<chi>)} |\n      xs. xs \\<in> set ` set (subseqs (G_list \\<phi>))} =\n    \\<Union>\n     {{\\<pi>.\n       Mapping.keys \\<pi> = set xs \\<and>\n       (\\<forall>\\<chi>\\<in>set xs.\n           the (Mapping.lookup \\<pi> \\<chi>)\n           < max_rank_of\\<^sub>C \\<Sigma> \\<chi>)} |\n      xs. xs \\<in> set (subseqs (G_list \\<phi>))}", "by auto"], ["proof (state)\nthis:\n  \\<Union>\n   {{\\<pi>.\n     Mapping.keys \\<pi> = xs \\<and>\n     (\\<forall>\\<chi>\\<in>Mapping.keys \\<pi>.\n         the (Mapping.lookup \\<pi> \\<chi>)\n         < max_rank_of\\<^sub>C \\<Sigma> \\<chi>)} |\n    xs. xs \\<in> set ` set (subseqs (G_list \\<phi>))} =\n  \\<Union>\n   {{\\<pi>.\n     Mapping.keys \\<pi> = set xs \\<and>\n     (\\<forall>\\<chi>\\<in>set xs.\n         the (Mapping.lookup \\<pi> \\<chi>)\n         < max_rank_of\\<^sub>C \\<Sigma> \\<chi>)} |\n    xs. xs \\<in> set (subseqs (G_list \\<phi>))}\n\ngoal (1 subgoal):\n 1. mappings\\<^sub>C \\<Sigma> \\<phi> =\n    (let Gs = G_list \\<phi>;\n         max_rank =\n           Mapping.lookup\n            (Mapping.tabulate Gs (max_rank_of\\<^sub>C \\<Sigma>))\n     in set (concat\n              (map (mapping_generator_list\n                     (\\<lambda>x. [0..<the (max_rank x)]))\n                (subseqs Gs))))", "also"], ["proof (state)\nthis:\n  \\<Union>\n   {{\\<pi>.\n     Mapping.keys \\<pi> = xs \\<and>\n     (\\<forall>\\<chi>\\<in>Mapping.keys \\<pi>.\n         the (Mapping.lookup \\<pi> \\<chi>)\n         < max_rank_of\\<^sub>C \\<Sigma> \\<chi>)} |\n    xs. xs \\<in> set ` set (subseqs (G_list \\<phi>))} =\n  \\<Union>\n   {{\\<pi>.\n     Mapping.keys \\<pi> = set xs \\<and>\n     (\\<forall>\\<chi>\\<in>set xs.\n         the (Mapping.lookup \\<pi> \\<chi>)\n         < max_rank_of\\<^sub>C \\<Sigma> \\<chi>)} |\n    xs. xs \\<in> set (subseqs (G_list \\<phi>))}\n\ngoal (1 subgoal):\n 1. mappings\\<^sub>C \\<Sigma> \\<phi> =\n    (let Gs = G_list \\<phi>;\n         max_rank =\n           Mapping.lookup\n            (Mapping.tabulate Gs (max_rank_of\\<^sub>C \\<Sigma>))\n     in set (concat\n              (map (mapping_generator_list\n                     (\\<lambda>x. [0..<the (max_rank x)]))\n                (subseqs Gs))))", "have \"\\<dots> = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     {{\\<pi>.\n       Mapping.keys \\<pi> = set xs \\<and>\n       (\\<forall>\\<chi>\\<in>set xs.\n           the (Mapping.lookup \\<pi> \\<chi>)\n           < max_rank_of\\<^sub>C \\<Sigma> \\<chi>)} |\n      xs. xs \\<in> set (subseqs (G_list \\<phi>))} =\n    (let Gs = G_list \\<phi>;\n         max_rank =\n           Mapping.lookup\n            (Mapping.tabulate Gs (max_rank_of\\<^sub>C \\<Sigma>))\n     in set (concat\n              (map (mapping_generator_list\n                     (\\<lambda>x. [0..<the (max_rank x)]))\n                (subseqs Gs))))", "using subset_G"], ["proof (prove)\nusing this:\n  ?x17 \\<in> set (subseqs (G_list \\<phi>)) \\<Longrightarrow>\n  set ?x17 \\<subseteq> \\<^bold>G \\<phi>\n\ngoal (1 subgoal):\n 1. \\<Union>\n     {{\\<pi>.\n       Mapping.keys \\<pi> = set xs \\<and>\n       (\\<forall>\\<chi>\\<in>set xs.\n           the (Mapping.lookup \\<pi> \\<chi>)\n           < max_rank_of\\<^sub>C \\<Sigma> \\<chi>)} |\n      xs. xs \\<in> set (subseqs (G_list \\<phi>))} =\n    (let Gs = G_list \\<phi>;\n         max_rank =\n           Mapping.lookup\n            (Mapping.tabulate Gs (max_rank_of\\<^sub>C \\<Sigma>))\n     in set (concat\n              (map (mapping_generator_list\n                     (\\<lambda>x. [0..<the (max_rank x)]))\n                (subseqs Gs))))", "by (auto simp add: Let_def mapping_generator_code [symmetric]\n        lookup_tabulate G_eq_G_list [symmetric] mapping_generator_set_eq\n        cong del: SUP_cong_simp; blast)"], ["proof (state)\nthis:\n  \\<Union>\n   {{\\<pi>.\n     Mapping.keys \\<pi> = set xs \\<and>\n     (\\<forall>\\<chi>\\<in>set xs.\n         the (Mapping.lookup \\<pi> \\<chi>)\n         < max_rank_of\\<^sub>C \\<Sigma> \\<chi>)} |\n    xs. xs \\<in> set (subseqs (G_list \\<phi>))} =\n  (let Gs = G_list \\<phi>;\n       max_rank =\n         Mapping.lookup (Mapping.tabulate Gs (max_rank_of\\<^sub>C \\<Sigma>))\n   in set (concat\n            (map (mapping_generator_list\n                   (\\<lambda>x. [0..<the (max_rank x)]))\n              (subseqs Gs))))\n\ngoal (1 subgoal):\n 1. mappings\\<^sub>C \\<Sigma> \\<phi> =\n    (let Gs = G_list \\<phi>;\n         max_rank =\n           Mapping.lookup\n            (Mapping.tabulate Gs (max_rank_of\\<^sub>C \\<Sigma>))\n     in set (concat\n              (map (mapping_generator_list\n                     (\\<lambda>x. [0..<the (max_rank x)]))\n                (subseqs Gs))))", "finally"], ["proof (chain)\npicking this:\n  mappings\\<^sub>C \\<Sigma> \\<phi> =\n  (let Gs = G_list \\<phi>;\n       max_rank =\n         Mapping.lookup (Mapping.tabulate Gs (max_rank_of\\<^sub>C \\<Sigma>))\n   in set (concat\n            (map (mapping_generator_list\n                   (\\<lambda>x. [0..<the (max_rank x)]))\n              (subseqs Gs))))", "show ?thesis"], ["proof (prove)\nusing this:\n  mappings\\<^sub>C \\<Sigma> \\<phi> =\n  (let Gs = G_list \\<phi>;\n       max_rank =\n         Mapping.lookup (Mapping.tabulate Gs (max_rank_of\\<^sub>C \\<Sigma>))\n   in set (concat\n            (map (mapping_generator_list\n                   (\\<lambda>x. [0..<the (max_rank x)]))\n              (subseqs Gs))))\n\ngoal (1 subgoal):\n 1. mappings\\<^sub>C \\<Sigma> \\<phi> =\n    (let Gs = G_list \\<phi>;\n         max_rank =\n           Mapping.lookup\n            (Mapping.tabulate Gs (max_rank_of\\<^sub>C \\<Sigma>))\n     in set (concat\n              (map (mapping_generator_list\n                     (\\<lambda>x. [0..<the (max_rank x)]))\n                (subseqs Gs))))", "by simp"], ["proof (state)\nthis:\n  mappings\\<^sub>C \\<Sigma> \\<phi> =\n  (let Gs = G_list \\<phi>;\n       max_rank =\n         Mapping.lookup (Mapping.tabulate Gs (max_rank_of\\<^sub>C \\<Sigma>))\n   in set (concat\n            (map (mapping_generator_list\n                   (\\<lambda>x. [0..<the (max_rank x)]))\n              (subseqs Gs))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reach_delta_initial:\n  assumes \"(x, y) \\<in> reach \\<Sigma> (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>)\"\n  assumes \"\\<chi> \\<in> \\<^bold>G \\<phi>\"\n  shows \"Mapping.lookup y \\<chi> \\<noteq> None\" (is ?t1)\n    and \"distinct (the (Mapping.lookup y \\<chi>))\" (is ?t2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.lookup y \\<chi> \\<noteq> None &&&\n    distinct (the (Mapping.lookup y \\<chi>))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. Mapping.lookup y \\<chi> \\<noteq> None\n 2. distinct (the (Mapping.lookup y \\<chi>))", "from assms(1)"], ["proof (chain)\npicking this:\n  (x, y)\n  \\<in> reach \\<Sigma> (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>)", "obtain w i where y_def: \"y = run (\\<up>\\<Delta>\\<^sub>\\<times> (nxt \\<Sigma> \\<delta>\\<^sub>M o q\\<^sub>0\\<^sub>M o theG)) (Mapping.tabulate (G_list \\<phi>) (init o q\\<^sub>0\\<^sub>M o theG)) w i\""], ["proof (prove)\nusing this:\n  (x, y)\n  \\<in> reach \\<Sigma> (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>)\n\ngoal (1 subgoal):\n 1. (\\<And>w i.\n        y =\n        run (\\<up>\\<Delta>\\<^sub>\\<times>\n              (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ>\n               q\\<^sub>0\\<^sub>M \\<circ>\n               theG))\n         (Mapping.tabulate (G_list \\<phi>)\n           (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n         w i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding reach_def delta\\<^sub>C.simps initial\\<^sub>C.simps simple_product_run"], ["proof (prove)\nusing this:\n  (x, y)\n  \\<in> {(run \\<delta> (q\\<^sub>0 \\<phi>) w n,\n          run (\\<up>\\<Delta>\\<^sub>\\<times>\n                (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ>\n                 q\\<^sub>0\\<^sub>M \\<circ>\n                 theG))\n           (Mapping.tabulate (G_list \\<phi>)\n             (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n           w n) |\n         w n. range w \\<subseteq> \\<Sigma>}\n\ngoal (1 subgoal):\n 1. (\\<And>w i.\n        y =\n        run (\\<up>\\<Delta>\\<^sub>\\<times>\n              (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ>\n               q\\<^sub>0\\<^sub>M \\<circ>\n               theG))\n         (Mapping.tabulate (G_list \\<phi>)\n           (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n         w i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  y =\n  run (\\<up>\\<Delta>\\<^sub>\\<times>\n        (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n         theG))\n   (Mapping.tabulate (G_list \\<phi>)\n     (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n   w i\n\ngoal (2 subgoals):\n 1. Mapping.lookup y \\<chi> \\<noteq> None\n 2. distinct (the (Mapping.lookup y \\<chi>))", "from assms(2) nxt_run_distinct"], ["proof (chain)\npicking this:\n  \\<chi> \\<in> \\<^bold>G \\<phi>\n  distinct\n   (run (nxt ?\\<Sigma> ?\\<Delta> ?q\\<^sub>0) (init ?q\\<^sub>0) ?w ?n)", "show ?t1"], ["proof (prove)\nusing this:\n  \\<chi> \\<in> \\<^bold>G \\<phi>\n  distinct\n   (run (nxt ?\\<Sigma> ?\\<Delta> ?q\\<^sub>0) (init ?q\\<^sub>0) ?w ?n)\n\ngoal (1 subgoal):\n 1. Mapping.lookup y \\<chi> \\<noteq> None", "unfolding y_def"], ["proof (prove)\nusing this:\n  \\<chi> \\<in> \\<^bold>G \\<phi>\n  distinct\n   (run (nxt ?\\<Sigma> ?\\<Delta> ?q\\<^sub>0) (init ?q\\<^sub>0) ?w ?n)\n\ngoal (1 subgoal):\n 1. Mapping.lookup\n     (run (\\<up>\\<Delta>\\<^sub>\\<times>\n            (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n             theG))\n       (Mapping.tabulate (G_list \\<phi>)\n         (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n       w i)\n     \\<chi> \\<noteq>\n    None", "using product_abs_run_Some[of \"Mapping.tabulate (G_list \\<phi>) (init o q\\<^sub>0\\<^sub>M o theG)\" \\<chi>]"], ["proof (prove)\nusing this:\n  \\<chi> \\<in> \\<^bold>G \\<phi>\n  distinct\n   (run (nxt ?\\<Sigma> ?\\<Delta> ?q\\<^sub>0) (init ?q\\<^sub>0) ?w ?n)\n  Mapping.lookup\n   (Mapping.tabulate (G_list \\<phi>)\n     (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n   \\<chi> =\n  Some ?q\\<^sub>0 \\<Longrightarrow>\n  Mapping.lookup\n   (run (\\<up>\\<Delta>\\<^sub>\\<times> ?\\<delta>\\<^sub>m)\n     (Mapping.tabulate (G_list \\<phi>)\n       (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n     ?w ?i)\n   \\<chi> =\n  Some (run (?\\<delta>\\<^sub>m \\<chi>) ?q\\<^sub>0 ?w ?i)\n\ngoal (1 subgoal):\n 1. Mapping.lookup\n     (run (\\<up>\\<Delta>\\<^sub>\\<times>\n            (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n             theG))\n       (Mapping.tabulate (G_list \\<phi>)\n         (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n       w i)\n     \\<chi> \\<noteq>\n    None", "unfolding G_eq_G_list"], ["proof (prove)\nusing this:\n  \\<chi> \\<in> set (G_list \\<phi>)\n  distinct\n   (run (nxt ?\\<Sigma> ?\\<Delta> ?q\\<^sub>0) (init ?q\\<^sub>0) ?w ?n)\n  Mapping.lookup\n   (Mapping.tabulate (G_list \\<phi>)\n     (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n   \\<chi> =\n  Some ?q\\<^sub>0 \\<Longrightarrow>\n  Mapping.lookup\n   (run (\\<up>\\<Delta>\\<^sub>\\<times> ?\\<delta>\\<^sub>m)\n     (Mapping.tabulate (G_list \\<phi>)\n       (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n     ?w ?i)\n   \\<chi> =\n  Some (run (?\\<delta>\\<^sub>m \\<chi>) ?q\\<^sub>0 ?w ?i)\n\ngoal (1 subgoal):\n 1. Mapping.lookup\n     (run (\\<up>\\<Delta>\\<^sub>\\<times>\n            (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n             theG))\n       (Mapping.tabulate (G_list \\<phi>)\n         (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n       w i)\n     \\<chi> \\<noteq>\n    None", "unfolding lookup_tabulate"], ["proof (prove)\nusing this:\n  \\<chi> \\<in> set (G_list \\<phi>)\n  distinct\n   (run (nxt ?\\<Sigma> ?\\<Delta> ?q\\<^sub>0) (init ?q\\<^sub>0) ?w ?n)\n  (if \\<chi> \\<in> set (G_list \\<phi>)\n   then Some ((init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG) \\<chi>)\n   else None) =\n  Some ?q\\<^sub>0 \\<Longrightarrow>\n  Mapping.lookup\n   (run (\\<up>\\<Delta>\\<^sub>\\<times> ?\\<delta>\\<^sub>m)\n     (Mapping.tabulate (G_list \\<phi>)\n       (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n     ?w ?i)\n   \\<chi> =\n  Some (run (?\\<delta>\\<^sub>m \\<chi>) ?q\\<^sub>0 ?w ?i)\n\ngoal (1 subgoal):\n 1. Mapping.lookup\n     (run (\\<up>\\<Delta>\\<^sub>\\<times>\n            (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n             theG))\n       (Mapping.tabulate (G_list \\<phi>)\n         (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n       w i)\n     \\<chi> \\<noteq>\n    None", "by fastforce"], ["proof (state)\nthis:\n  Mapping.lookup y \\<chi> \\<noteq> None\n\ngoal (1 subgoal):\n 1. distinct (the (Mapping.lookup y \\<chi>))", "with nxt_run_distinct"], ["proof (chain)\npicking this:\n  distinct\n   (run (nxt ?\\<Sigma> ?\\<Delta> ?q\\<^sub>0) (init ?q\\<^sub>0) ?w ?n)\n  Mapping.lookup y \\<chi> \\<noteq> None", "show ?t2"], ["proof (prove)\nusing this:\n  distinct\n   (run (nxt ?\\<Sigma> ?\\<Delta> ?q\\<^sub>0) (init ?q\\<^sub>0) ?w ?n)\n  Mapping.lookup y \\<chi> \\<noteq> None\n\ngoal (1 subgoal):\n 1. distinct (the (Mapping.lookup y \\<chi>))", "unfolding y_def"], ["proof (prove)\nusing this:\n  distinct\n   (run (nxt ?\\<Sigma> ?\\<Delta> ?q\\<^sub>0) (init ?q\\<^sub>0) ?w ?n)\n  Mapping.lookup\n   (run (\\<up>\\<Delta>\\<^sub>\\<times>\n          (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n           theG))\n     (Mapping.tabulate (G_list \\<phi>)\n       (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n     w i)\n   \\<chi> \\<noteq>\n  None\n\ngoal (1 subgoal):\n 1. distinct\n     (the (Mapping.lookup\n            (run (\\<up>\\<Delta>\\<^sub>\\<times>\n                   (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ>\n                    q\\<^sub>0\\<^sub>M \\<circ>\n                    theG))\n              (Mapping.tabulate (G_list \\<phi>)\n                (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n              w i)\n            \\<chi>))", "using lookup_tabulate"], ["proof (prove)\nusing this:\n  distinct\n   (run (nxt ?\\<Sigma> ?\\<Delta> ?q\\<^sub>0) (init ?q\\<^sub>0) ?w ?n)\n  Mapping.lookup\n   (run (\\<up>\\<Delta>\\<^sub>\\<times>\n          (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n           theG))\n     (Mapping.tabulate (G_list \\<phi>)\n       (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n     w i)\n   \\<chi> \\<noteq>\n  None\n  Mapping.lookup (Mapping.tabulate ?xs ?f) ?x =\n  (if ?x \\<in> set ?xs then Some (?f ?x) else None)\n\ngoal (1 subgoal):\n 1. distinct\n     (the (Mapping.lookup\n            (run (\\<up>\\<Delta>\\<^sub>\\<times>\n                   (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ>\n                    q\\<^sub>0\\<^sub>M \\<circ>\n                    theG))\n              (Mapping.tabulate (G_list \\<phi>)\n                (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n              w i)\n            \\<chi>))", "by (metis (no_types) G_eq_G_list assms(2) comp_eq_dest_lhs option.sel product_abs_run_Some)"], ["proof (state)\nthis:\n  distinct (the (Mapping.lookup y \\<chi>))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \\<open>Correctness\\<close>"], ["", "fun abstract_state :: \"'x \\<times> ('y, 'z list) mapping \\<Rightarrow> 'x \\<times> ('y \\<rightharpoonup> 'z \\<rightharpoonup> nat)\" \nwhere\n  \"abstract_state (a, b) = (a, (map_option rk) o (Mapping.lookup b))\""], ["", "fun abstract_transition\nwhere\n  \"abstract_transition (q, \\<nu>, q') = (abstract_state q, \\<nu>, abstract_state q')\""], ["", "locale ltl_to_rabin_base_code = ltl_to_rabin_base + ltl_to_rabin_base_code_def + \n  assumes \n    M_fin\\<^sub>C_correct: \"\\<lbrakk>t \\<in> reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>); dom \\<pi> \\<subseteq> \\<^bold>G \\<phi>\\<rbrakk> \\<Longrightarrow>\n      abstract_transition t \\<in> M_fin \\<pi> = M_fin\\<^sub>C \\<phi> (Mapping.Mapping \\<pi>) t\"\nbegin"], ["", "lemma finite_reach\\<^sub>C:\n  \"finite (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n       (initial\\<^sub>C \\<phi>))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite\n     (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n       (initial\\<^sub>C \\<phi>))", "note finite_reach'"], ["proof (state)\nthis:\n  finite (reach \\<Sigma> \\<delta> (q\\<^sub>0 ?\\<phi>))\n\ngoal (1 subgoal):\n 1. finite\n     (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n       (initial\\<^sub>C \\<phi>))", "moreover"], ["proof (state)\nthis:\n  finite (reach \\<Sigma> \\<delta> (q\\<^sub>0 ?\\<phi>))\n\ngoal (1 subgoal):\n 1. finite\n     (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n       (initial\\<^sub>C \\<phi>))", "have \"(\\<And>x. x \\<in> \\<^bold>G \\<phi> \\<Longrightarrow> finite (reach \\<Sigma> ((nxt \\<Sigma> \\<delta>\\<^sub>M o q\\<^sub>0\\<^sub>M o theG) x) ((init o q\\<^sub>0\\<^sub>M o theG) x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<^bold>G \\<phi> \\<Longrightarrow>\n       finite\n        (reach \\<Sigma>\n          ((nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n            theG)\n            x)\n          ((init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG) x))", "using semi_mojmir.finite_Q[OF semi_mojmir]"], ["proof (prove)\nusing this:\n  finite\n   (semi_mojmir_def.Q\\<^sub>E \\<Sigma> \\<delta>\\<^sub>M\n     (q\\<^sub>0\\<^sub>M ?\\<psi>1))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<^bold>G \\<phi> \\<Longrightarrow>\n       finite\n        (reach \\<Sigma>\n          ((nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n            theG)\n            x)\n          ((init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG) x))", "unfolding G_eq_G_list semi_mojmir_def.Q\\<^sub>E_def"], ["proof (prove)\nusing this:\n  finite\n   (reach \\<Sigma>\n     (nxt \\<Sigma> \\<delta>\\<^sub>M (q\\<^sub>0\\<^sub>M ?\\<psi>1))\n     (init (q\\<^sub>0\\<^sub>M ?\\<psi>1)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (G_list \\<phi>) \\<Longrightarrow>\n       finite\n        (reach \\<Sigma>\n          ((nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n            theG)\n            x)\n          ((init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG) x))", "by simp"], ["proof (state)\nthis:\n  ?x17 \\<in> \\<^bold>G \\<phi> \\<Longrightarrow>\n  finite\n   (reach \\<Sigma>\n     ((nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG)\n       ?x17)\n     ((init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG) ?x17))\n\ngoal (1 subgoal):\n 1. finite\n     (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n       (initial\\<^sub>C \\<phi>))", "hence \"finite (reach \\<Sigma> (\\<up>\\<Delta>\\<^sub>\\<times> (nxt \\<Sigma> \\<delta>\\<^sub>M o q\\<^sub>0\\<^sub>M o theG)) (Mapping.tabulate (G_list \\<phi>) (init o q\\<^sub>0\\<^sub>M o theG)))\""], ["proof (prove)\nusing this:\n  ?x17 \\<in> \\<^bold>G \\<phi> \\<Longrightarrow>\n  finite\n   (reach \\<Sigma>\n     ((nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG)\n       ?x17)\n     ((init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG) ?x17))\n\ngoal (1 subgoal):\n 1. finite\n     (reach \\<Sigma>\n       (\\<up>\\<Delta>\\<^sub>\\<times>\n         (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n          theG))\n       (Mapping.tabulate (G_list \\<phi>)\n         (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG)))", "by (metis (no_types) finite_reach_product_abs[OF finite_keys_tabulate] G_eq_G_list  keys_tabulate lookup_tabulate_Some)"], ["proof (state)\nthis:\n  finite\n   (reach \\<Sigma>\n     (\\<up>\\<Delta>\\<^sub>\\<times>\n       (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n        theG))\n     (Mapping.tabulate (G_list \\<phi>)\n       (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG)))\n\ngoal (1 subgoal):\n 1. finite\n     (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n       (initial\\<^sub>C \\<phi>))", "ultimately"], ["proof (chain)\npicking this:\n  finite (reach \\<Sigma> \\<delta> (q\\<^sub>0 ?\\<phi>))\n  finite\n   (reach \\<Sigma>\n     (\\<up>\\<Delta>\\<^sub>\\<times>\n       (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n        theG))\n     (Mapping.tabulate (G_list \\<phi>)\n       (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG)))", "have \"finite (reach \\<Sigma> (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>))\""], ["proof (prove)\nusing this:\n  finite (reach \\<Sigma> \\<delta> (q\\<^sub>0 ?\\<phi>))\n  finite\n   (reach \\<Sigma>\n     (\\<up>\\<Delta>\\<^sub>\\<times>\n       (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n        theG))\n     (Mapping.tabulate (G_list \\<phi>)\n       (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG)))\n\ngoal (1 subgoal):\n 1. finite\n     (reach \\<Sigma> (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>))", "using finite_reach_simple_product"], ["proof (prove)\nusing this:\n  finite (reach \\<Sigma> \\<delta> (q\\<^sub>0 ?\\<phi>))\n  finite\n   (reach \\<Sigma>\n     (\\<up>\\<Delta>\\<^sub>\\<times>\n       (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n        theG))\n     (Mapping.tabulate (G_list \\<phi>)\n       (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG)))\n  \\<lbrakk>finite (reach ?\\<Sigma> ?\\<delta>\\<^sub>1 ?q\\<^sub>1);\n   finite (reach ?\\<Sigma> ?\\<delta>\\<^sub>2 ?q\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> finite\n                     (reach ?\\<Sigma>\n                       ?\\<delta>\\<^sub>1 \\<times> ?\\<delta>\\<^sub>2\n                       (?q\\<^sub>1, ?q\\<^sub>2))\n\ngoal (1 subgoal):\n 1. finite\n     (reach \\<Sigma> (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>))", "by fastforce"], ["proof (state)\nthis:\n  finite (reach \\<Sigma> (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>))\n\ngoal (1 subgoal):\n 1. finite\n     (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n       (initial\\<^sub>C \\<phi>))", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite (reach \\<Sigma> (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>))\n\ngoal (1 subgoal):\n 1. finite\n     (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n       (initial\\<^sub>C \\<phi>))", "using finite_\\<Sigma>"], ["proof (prove)\nusing this:\n  finite (reach \\<Sigma> (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>))\n  finite \\<Sigma>\n\ngoal (1 subgoal):\n 1. finite\n     (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n       (initial\\<^sub>C \\<phi>))", "by (simp add: finite_reach\\<^sub>t)"], ["proof (state)\nthis:\n  finite\n   (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n     (initial\\<^sub>C \\<phi>))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma max_rank_of\\<^sub>C_eq:\n  assumes \"\\<Sigma> = set \\<Sigma>'\"\n  shows \"max_rank_of\\<^sub>C \\<Sigma>' \\<psi> = max_rank_of \\<Sigma> \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_rank_of\\<^sub>C \\<Sigma>' \\<psi> = max_rank_of \\<Sigma> \\<psi>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. max_rank_of\\<^sub>C \\<Sigma>' \\<psi> = max_rank_of \\<Sigma> \\<psi>", "interpret \\<MM>: semi_mojmir \"set \\<Sigma>'\" \\<delta>\\<^sub>M \"q\\<^sub>0\\<^sub>M (theG \\<psi>)\" w"], ["proof (prove)\ngoal (1 subgoal):\n 1. semi_mojmir (set \\<Sigma>') \\<delta>\\<^sub>M\n     (q\\<^sub>0\\<^sub>M (theG \\<psi>)) w", "using semi_mojmir assms"], ["proof (prove)\nusing this:\n  semi_mojmir \\<Sigma> \\<delta>\\<^sub>M (q\\<^sub>0\\<^sub>M ?\\<psi>) w\n  \\<Sigma> = set \\<Sigma>'\n\ngoal (1 subgoal):\n 1. semi_mojmir (set \\<Sigma>') \\<delta>\\<^sub>M\n     (q\\<^sub>0\\<^sub>M (theG \\<psi>)) w", "by force"], ["proof (state)\ngoal (1 subgoal):\n 1. max_rank_of\\<^sub>C \\<Sigma>' \\<psi> = max_rank_of \\<Sigma> \\<psi>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. max_rank_of\\<^sub>C \\<Sigma>' \\<psi> = max_rank_of \\<Sigma> \\<psi>", "unfolding max_rank_of_def max_rank_of\\<^sub>C_def Q\\<^sub>L_reach[OF \\<MM>.finite_reach] semi_mojmir_def.max_rank_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     (Set.filter (Not \\<circ> \\<MM>.sink)\n       (reach (set \\<Sigma>') \\<delta>\\<^sub>M\n         (q\\<^sub>0\\<^sub>M (theG \\<psi>)))) =\n    card\n     (reach \\<Sigma> \\<delta>\\<^sub>M (q\\<^sub>0\\<^sub>M (theG \\<psi>)) -\n      Collect\n       (semi_mojmir_def.sink \\<Sigma> \\<delta>\\<^sub>M\n         (q\\<^sub>0\\<^sub>M (theG \\<psi>))))", "by (simp add: Set.filter_def set_diff_eq assms)"], ["proof (state)\nthis:\n  max_rank_of\\<^sub>C \\<Sigma>' \\<psi> = max_rank_of \\<Sigma> \\<psi>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reachable_transitions\\<^sub>C_eq:\n  assumes \"\\<Sigma> = set \\<Sigma>'\"\n  shows \"reachable_transitions\\<^sub>C \\<Sigma>' \\<phi> = reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable_transitions\\<^sub>C \\<Sigma>' \\<phi> =\n    reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>)", "by (simp only: reachable_transitions\\<^sub>C_def \\<delta>\\<^sub>L_reach[OF finite_reach\\<^sub>C[unfolded assms]] assms)"], ["", "lemma run_abstraction_correct:\n  \"run (delta \\<Sigma>) (initial \\<phi>) w = abstract_state o (run (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>) w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run (delta \\<Sigma>) (initial \\<phi>) w =\n    abstract_state \\<circ>\n    run (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>) w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. run (delta \\<Sigma>) (initial \\<phi>) w =\n    abstract_state \\<circ>\n    run (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>) w", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. run (delta \\<Sigma>) (initial \\<phi>) w =\n    abstract_state \\<circ>\n    run (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>) w", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. run (delta \\<Sigma>) (initial \\<phi>) w =\n    abstract_state \\<circ>\n    run (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>) w", "let ?\\<delta>\\<^sub>2 = \"\\<Delta>\\<^sub>\\<times> (\\<lambda>\\<chi>. semi_mojmir_def.step \\<Sigma> \\<delta>\\<^sub>M (q\\<^sub>0\\<^sub>M (theG \\<chi>)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. run (delta \\<Sigma>) (initial \\<phi>) w =\n    abstract_state \\<circ>\n    run (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>) w", "let ?q\\<^sub>2 = \"\\<iota>\\<^sub>\\<times> (\\<^bold>G \\<phi>) (\\<lambda>\\<chi>. semi_mojmir_def.initial (q\\<^sub>0\\<^sub>M (theG \\<chi>)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. run (delta \\<Sigma>) (initial \\<phi>) w =\n    abstract_state \\<circ>\n    run (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>) w", "let ?\\<delta>\\<^sub>2' = \"\\<up>\\<Delta>\\<^sub>\\<times> (nxt \\<Sigma> \\<delta>\\<^sub>M o q\\<^sub>0\\<^sub>M o theG)\""], ["proof (state)\ngoal (1 subgoal):\n 1. run (delta \\<Sigma>) (initial \\<phi>) w =\n    abstract_state \\<circ>\n    run (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>) w", "let ?q\\<^sub>2' = \"Mapping.tabulate (G_list \\<phi>) (init o q\\<^sub>0\\<^sub>M o theG)\""], ["proof (state)\ngoal (1 subgoal):\n 1. run (delta \\<Sigma>) (initial \\<phi>) w =\n    abstract_state \\<circ>\n    run (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>) w", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. run (delta \\<Sigma>) (initial \\<phi>) w =\n    abstract_state \\<circ>\n    run (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>) w", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. run (delta \\<Sigma>) (initial \\<phi>) w =\n    abstract_state \\<circ>\n    run (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>) w", "assume \"q \\<notin> \\<^bold>G \\<phi>\""], ["proof (state)\nthis:\n  q \\<notin> \\<^bold>G \\<phi>\n\ngoal (1 subgoal):\n 1. run (delta \\<Sigma>) (initial \\<phi>) w =\n    abstract_state \\<circ>\n    run (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>) w", "hence \"?q\\<^sub>2 q = None\" and \"Mapping.lookup (run ?\\<delta>\\<^sub>2' ?q\\<^sub>2' w i) q = None\""], ["proof (prove)\nusing this:\n  q \\<notin> \\<^bold>G \\<phi>\n\ngoal (1 subgoal):\n 1. \\<iota>\\<^sub>\\<times> (\\<^bold>G \\<phi>)\n     (\\<lambda>\\<chi>.\n         semi_mojmir_def.initial (q\\<^sub>0\\<^sub>M (theG \\<chi>)))\n     q =\n    None &&&\n    Mapping.lookup\n     (run (\\<up>\\<Delta>\\<^sub>\\<times>\n            (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n             theG))\n       (Mapping.tabulate (G_list \\<phi>)\n         (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n       w i)\n     q =\n    None", "using G_eq_G_list product_abs_run_None"], ["proof (prove)\nusing this:\n  q \\<notin> \\<^bold>G \\<phi>\n  \\<^bold>G ?\\<phi> = set (G_list ?\\<phi>)\n  Mapping.lookup ?\\<iota>\\<^sub>m ?k = None \\<Longrightarrow>\n  Mapping.lookup\n   (run (\\<up>\\<Delta>\\<^sub>\\<times> ?\\<delta>\\<^sub>m) ?\\<iota>\\<^sub>m ?w\n     ?i)\n   ?k =\n  None\n\ngoal (1 subgoal):\n 1. \\<iota>\\<^sub>\\<times> (\\<^bold>G \\<phi>)\n     (\\<lambda>\\<chi>.\n         semi_mojmir_def.initial (q\\<^sub>0\\<^sub>M (theG \\<chi>)))\n     q =\n    None &&&\n    Mapping.lookup\n     (run (\\<up>\\<Delta>\\<^sub>\\<times>\n            (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n             theG))\n       (Mapping.tabulate (G_list \\<phi>)\n         (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n       w i)\n     q =\n    None", "by (simp, metis domIff keys_dom_lookup keys_tabulate)"], ["proof (state)\nthis:\n  \\<iota>\\<^sub>\\<times> (\\<^bold>G \\<phi>)\n   (\\<lambda>\\<chi>.\n       semi_mojmir_def.initial (q\\<^sub>0\\<^sub>M (theG \\<chi>)))\n   q =\n  None\n  Mapping.lookup\n   (run (\\<up>\\<Delta>\\<^sub>\\<times>\n          (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n           theG))\n     (Mapping.tabulate (G_list \\<phi>)\n       (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n     w i)\n   q =\n  None\n\ngoal (1 subgoal):\n 1. run (delta \\<Sigma>) (initial \\<phi>) w =\n    abstract_state \\<circ>\n    run (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>) w", "hence \"run ?\\<delta>\\<^sub>2 ?q\\<^sub>2 w i q = (\\<lambda>m. (map_option rk) o (Mapping.lookup m)) (run ?\\<delta>\\<^sub>2' ?q\\<^sub>2' w i) q\""], ["proof (prove)\nusing this:\n  \\<iota>\\<^sub>\\<times> (\\<^bold>G \\<phi>)\n   (\\<lambda>\\<chi>.\n       semi_mojmir_def.initial (q\\<^sub>0\\<^sub>M (theG \\<chi>)))\n   q =\n  None\n  Mapping.lookup\n   (run (\\<up>\\<Delta>\\<^sub>\\<times>\n          (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n           theG))\n     (Mapping.tabulate (G_list \\<phi>)\n       (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n     w i)\n   q =\n  None\n\ngoal (1 subgoal):\n 1. run (\\<Delta>\\<^sub>\\<times>\n          (\\<lambda>\\<chi>.\n              semi_mojmir_def.step \\<Sigma> \\<delta>\\<^sub>M\n               (q\\<^sub>0\\<^sub>M (theG \\<chi>))))\n     (\\<iota>\\<^sub>\\<times> (\\<^bold>G \\<phi>)\n       (\\<lambda>\\<chi>.\n           semi_mojmir_def.initial (q\\<^sub>0\\<^sub>M (theG \\<chi>))))\n     w i q =\n    (map_option rk \\<circ>\n     Mapping.lookup\n      (run (\\<up>\\<Delta>\\<^sub>\\<times>\n             (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ>\n              q\\<^sub>0\\<^sub>M \\<circ>\n              theG))\n        (Mapping.tabulate (G_list \\<phi>)\n          (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n        w i))\n     q", "using product_run_None"], ["proof (prove)\nusing this:\n  \\<iota>\\<^sub>\\<times> (\\<^bold>G \\<phi>)\n   (\\<lambda>\\<chi>.\n       semi_mojmir_def.initial (q\\<^sub>0\\<^sub>M (theG \\<chi>)))\n   q =\n  None\n  Mapping.lookup\n   (run (\\<up>\\<Delta>\\<^sub>\\<times>\n          (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n           theG))\n     (Mapping.tabulate (G_list \\<phi>)\n       (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n     w i)\n   q =\n  None\n  ?\\<iota>\\<^sub>m ?k = None \\<Longrightarrow>\n  run (\\<Delta>\\<^sub>\\<times> ?\\<delta>\\<^sub>m) ?\\<iota>\\<^sub>m ?w ?i\n   ?k =\n  None\n\ngoal (1 subgoal):\n 1. run (\\<Delta>\\<^sub>\\<times>\n          (\\<lambda>\\<chi>.\n              semi_mojmir_def.step \\<Sigma> \\<delta>\\<^sub>M\n               (q\\<^sub>0\\<^sub>M (theG \\<chi>))))\n     (\\<iota>\\<^sub>\\<times> (\\<^bold>G \\<phi>)\n       (\\<lambda>\\<chi>.\n           semi_mojmir_def.initial (q\\<^sub>0\\<^sub>M (theG \\<chi>))))\n     w i q =\n    (map_option rk \\<circ>\n     Mapping.lookup\n      (run (\\<up>\\<Delta>\\<^sub>\\<times>\n             (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ>\n              q\\<^sub>0\\<^sub>M \\<circ>\n              theG))\n        (Mapping.tabulate (G_list \\<phi>)\n          (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n        w i))\n     q", "by (simp del: nxt.simps rk.simps)"], ["proof (state)\nthis:\n  run (\\<Delta>\\<^sub>\\<times>\n        (\\<lambda>\\<chi>.\n            semi_mojmir_def.step \\<Sigma> \\<delta>\\<^sub>M\n             (q\\<^sub>0\\<^sub>M (theG \\<chi>))))\n   (\\<iota>\\<^sub>\\<times> (\\<^bold>G \\<phi>)\n     (\\<lambda>\\<chi>.\n         semi_mojmir_def.initial (q\\<^sub>0\\<^sub>M (theG \\<chi>))))\n   w i q =\n  (map_option rk \\<circ>\n   Mapping.lookup\n    (run (\\<up>\\<Delta>\\<^sub>\\<times>\n           (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n            theG))\n      (Mapping.tabulate (G_list \\<phi>)\n        (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n      w i))\n   q\n\ngoal (1 subgoal):\n 1. run (delta \\<Sigma>) (initial \\<phi>) w =\n    abstract_state \\<circ>\n    run (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>) w", "}"], ["proof (state)\nthis:\n  ?q19 \\<notin> \\<^bold>G \\<phi> \\<Longrightarrow>\n  run (\\<Delta>\\<^sub>\\<times>\n        (\\<lambda>\\<chi>.\n            semi_mojmir_def.step \\<Sigma> \\<delta>\\<^sub>M\n             (q\\<^sub>0\\<^sub>M (theG \\<chi>))))\n   (\\<iota>\\<^sub>\\<times> (\\<^bold>G \\<phi>)\n     (\\<lambda>\\<chi>.\n         semi_mojmir_def.initial (q\\<^sub>0\\<^sub>M (theG \\<chi>))))\n   w i ?q19 =\n  (map_option rk \\<circ>\n   Mapping.lookup\n    (run (\\<up>\\<Delta>\\<^sub>\\<times>\n           (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n            theG))\n      (Mapping.tabulate (G_list \\<phi>)\n        (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n      w i))\n   ?q19\n\ngoal (1 subgoal):\n 1. run (delta \\<Sigma>) (initial \\<phi>) w =\n    abstract_state \\<circ>\n    run (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>) w", "moreover"], ["proof (state)\nthis:\n  ?q19 \\<notin> \\<^bold>G \\<phi> \\<Longrightarrow>\n  run (\\<Delta>\\<^sub>\\<times>\n        (\\<lambda>\\<chi>.\n            semi_mojmir_def.step \\<Sigma> \\<delta>\\<^sub>M\n             (q\\<^sub>0\\<^sub>M (theG \\<chi>))))\n   (\\<iota>\\<^sub>\\<times> (\\<^bold>G \\<phi>)\n     (\\<lambda>\\<chi>.\n         semi_mojmir_def.initial (q\\<^sub>0\\<^sub>M (theG \\<chi>))))\n   w i ?q19 =\n  (map_option rk \\<circ>\n   Mapping.lookup\n    (run (\\<up>\\<Delta>\\<^sub>\\<times>\n           (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n            theG))\n      (Mapping.tabulate (G_list \\<phi>)\n        (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n      w i))\n   ?q19\n\ngoal (1 subgoal):\n 1. run (delta \\<Sigma>) (initial \\<phi>) w =\n    abstract_state \\<circ>\n    run (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>) w", "{"], ["proof (state)\nthis:\n  ?q19 \\<notin> \\<^bold>G \\<phi> \\<Longrightarrow>\n  run (\\<Delta>\\<^sub>\\<times>\n        (\\<lambda>\\<chi>.\n            semi_mojmir_def.step \\<Sigma> \\<delta>\\<^sub>M\n             (q\\<^sub>0\\<^sub>M (theG \\<chi>))))\n   (\\<iota>\\<^sub>\\<times> (\\<^bold>G \\<phi>)\n     (\\<lambda>\\<chi>.\n         semi_mojmir_def.initial (q\\<^sub>0\\<^sub>M (theG \\<chi>))))\n   w i ?q19 =\n  (map_option rk \\<circ>\n   Mapping.lookup\n    (run (\\<up>\\<Delta>\\<^sub>\\<times>\n           (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n            theG))\n      (Mapping.tabulate (G_list \\<phi>)\n        (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n      w i))\n   ?q19\n\ngoal (1 subgoal):\n 1. run (delta \\<Sigma>) (initial \\<phi>) w =\n    abstract_state \\<circ>\n    run (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>) w", "fix q j"], ["proof (state)\ngoal (1 subgoal):\n 1. run (delta \\<Sigma>) (initial \\<phi>) w =\n    abstract_state \\<circ>\n    run (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>) w", "assume \"q \\<in> \\<^bold>G \\<phi>\""], ["proof (state)\nthis:\n  q \\<in> \\<^bold>G \\<phi>\n\ngoal (1 subgoal):\n 1. run (delta \\<Sigma>) (initial \\<phi>) w =\n    abstract_state \\<circ>\n    run (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>) w", "hence init: \"?q\\<^sub>2 q = Some (semi_mojmir_def.initial (q\\<^sub>0\\<^sub>M (theG q)))\" \n        and \"Mapping.lookup (run ?\\<delta>\\<^sub>2' ?q\\<^sub>2' w i) q = Some (run ((nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG) q) ((init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG) q) w i)\""], ["proof (prove)\nusing this:\n  q \\<in> \\<^bold>G \\<phi>\n\ngoal (1 subgoal):\n 1. \\<iota>\\<^sub>\\<times> (\\<^bold>G \\<phi>)\n     (\\<lambda>\\<chi>.\n         semi_mojmir_def.initial (q\\<^sub>0\\<^sub>M (theG \\<chi>)))\n     q =\n    Some (semi_mojmir_def.initial (q\\<^sub>0\\<^sub>M (theG q))) &&&\n    Mapping.lookup\n     (run (\\<up>\\<Delta>\\<^sub>\\<times>\n            (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n             theG))\n       (Mapping.tabulate (G_list \\<phi>)\n         (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n       w i)\n     q =\n    Some\n     (run ((nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n            theG)\n            q)\n       ((init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG) q) w i)", "apply (simp del: nxt.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.lookup\n     (run (\\<up>\\<Delta>\\<^sub>\\<times>\n            (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n             theG))\n       (Mapping.tabulate (G_list \\<phi>)\n         (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n       w i)\n     q =\n    Some\n     (run ((nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n            theG)\n            q)\n       ((init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG) q) w i)", "apply (metis G_eq_G_list \\<open>q \\<in> \\<^bold>G \\<phi>\\<close> lookup_tabulate product_abs_run_Some)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<iota>\\<^sub>\\<times> (\\<^bold>G \\<phi>)\n   (\\<lambda>\\<chi>.\n       semi_mojmir_def.initial (q\\<^sub>0\\<^sub>M (theG \\<chi>)))\n   q =\n  Some (semi_mojmir_def.initial (q\\<^sub>0\\<^sub>M (theG q)))\n  Mapping.lookup\n   (run (\\<up>\\<Delta>\\<^sub>\\<times>\n          (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n           theG))\n     (Mapping.tabulate (G_list \\<phi>)\n       (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n     w i)\n   q =\n  Some\n   (run ((nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n          theG)\n          q)\n     ((init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG) q) w i)\n\ngoal (1 subgoal):\n 1. run (delta \\<Sigma>) (initial \\<phi>) w =\n    abstract_state \\<circ>\n    run (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>) w", "hence \"run ?\\<delta>\\<^sub>2 ?q\\<^sub>2 w i q = (\\<lambda>m. (map_option rk) o (Mapping.lookup m)) (run ?\\<delta>\\<^sub>2' ?q\\<^sub>2' w i) q\""], ["proof (prove)\nusing this:\n  \\<iota>\\<^sub>\\<times> (\\<^bold>G \\<phi>)\n   (\\<lambda>\\<chi>.\n       semi_mojmir_def.initial (q\\<^sub>0\\<^sub>M (theG \\<chi>)))\n   q =\n  Some (semi_mojmir_def.initial (q\\<^sub>0\\<^sub>M (theG q)))\n  Mapping.lookup\n   (run (\\<up>\\<Delta>\\<^sub>\\<times>\n          (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n           theG))\n     (Mapping.tabulate (G_list \\<phi>)\n       (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n     w i)\n   q =\n  Some\n   (run ((nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n          theG)\n          q)\n     ((init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG) q) w i)\n\ngoal (1 subgoal):\n 1. run (\\<Delta>\\<^sub>\\<times>\n          (\\<lambda>\\<chi>.\n              semi_mojmir_def.step \\<Sigma> \\<delta>\\<^sub>M\n               (q\\<^sub>0\\<^sub>M (theG \\<chi>))))\n     (\\<iota>\\<^sub>\\<times> (\\<^bold>G \\<phi>)\n       (\\<lambda>\\<chi>.\n           semi_mojmir_def.initial (q\\<^sub>0\\<^sub>M (theG \\<chi>))))\n     w i q =\n    (map_option rk \\<circ>\n     Mapping.lookup\n      (run (\\<up>\\<Delta>\\<^sub>\\<times>\n             (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ>\n              q\\<^sub>0\\<^sub>M \\<circ>\n              theG))\n        (Mapping.tabulate (G_list \\<phi>)\n          (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n        w i))\n     q", "unfolding product_run_Some[of \"\\<iota>\\<^sub>\\<times> (\\<^bold>G \\<phi>) (\\<lambda>\\<chi>. semi_mojmir_def.initial (q\\<^sub>0\\<^sub>M (theG \\<chi>)))\" q, OF init]"], ["proof (prove)\nusing this:\n  \\<iota>\\<^sub>\\<times> (\\<^bold>G \\<phi>)\n   (\\<lambda>\\<chi>.\n       semi_mojmir_def.initial (q\\<^sub>0\\<^sub>M (theG \\<chi>)))\n   q =\n  Some (semi_mojmir_def.initial (q\\<^sub>0\\<^sub>M (theG q)))\n  Mapping.lookup\n   (run (\\<up>\\<Delta>\\<^sub>\\<times>\n          (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n           theG))\n     (Mapping.tabulate (G_list \\<phi>)\n       (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n     w i)\n   q =\n  Some\n   (run ((nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n          theG)\n          q)\n     ((init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG) q) w i)\n\ngoal (1 subgoal):\n 1. Some\n     (run (semi_mojmir_def.step \\<Sigma> \\<delta>\\<^sub>M\n            (q\\<^sub>0\\<^sub>M (theG q)))\n       (semi_mojmir_def.initial (q\\<^sub>0\\<^sub>M (theG q))) w i) =\n    (map_option rk \\<circ>\n     Mapping.lookup\n      (run (\\<up>\\<Delta>\\<^sub>\\<times>\n             (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ>\n              q\\<^sub>0\\<^sub>M \\<circ>\n              theG))\n        (Mapping.tabulate (G_list \\<phi>)\n          (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n        w i))\n     q", "by (simp del: product.simps nxt.simps rk.simps; unfold map_of_map semi_mojmir.nxt_run_step_run[OF semi_mojmir]; simp)"], ["proof (state)\nthis:\n  run (\\<Delta>\\<^sub>\\<times>\n        (\\<lambda>\\<chi>.\n            semi_mojmir_def.step \\<Sigma> \\<delta>\\<^sub>M\n             (q\\<^sub>0\\<^sub>M (theG \\<chi>))))\n   (\\<iota>\\<^sub>\\<times> (\\<^bold>G \\<phi>)\n     (\\<lambda>\\<chi>.\n         semi_mojmir_def.initial (q\\<^sub>0\\<^sub>M (theG \\<chi>))))\n   w i q =\n  (map_option rk \\<circ>\n   Mapping.lookup\n    (run (\\<up>\\<Delta>\\<^sub>\\<times>\n           (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n            theG))\n      (Mapping.tabulate (G_list \\<phi>)\n        (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n      w i))\n   q\n\ngoal (1 subgoal):\n 1. run (delta \\<Sigma>) (initial \\<phi>) w =\n    abstract_state \\<circ>\n    run (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>) w", "}"], ["proof (state)\nthis:\n  ?q19 \\<in> \\<^bold>G \\<phi> \\<Longrightarrow>\n  run (\\<Delta>\\<^sub>\\<times>\n        (\\<lambda>\\<chi>.\n            semi_mojmir_def.step \\<Sigma> \\<delta>\\<^sub>M\n             (q\\<^sub>0\\<^sub>M (theG \\<chi>))))\n   (\\<iota>\\<^sub>\\<times> (\\<^bold>G \\<phi>)\n     (\\<lambda>\\<chi>.\n         semi_mojmir_def.initial (q\\<^sub>0\\<^sub>M (theG \\<chi>))))\n   w i ?q19 =\n  (map_option rk \\<circ>\n   Mapping.lookup\n    (run (\\<up>\\<Delta>\\<^sub>\\<times>\n           (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n            theG))\n      (Mapping.tabulate (G_list \\<phi>)\n        (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n      w i))\n   ?q19\n\ngoal (1 subgoal):\n 1. run (delta \\<Sigma>) (initial \\<phi>) w =\n    abstract_state \\<circ>\n    run (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>) w", "ultimately"], ["proof (chain)\npicking this:\n  ?q19 \\<notin> \\<^bold>G \\<phi> \\<Longrightarrow>\n  run (\\<Delta>\\<^sub>\\<times>\n        (\\<lambda>\\<chi>.\n            semi_mojmir_def.step \\<Sigma> \\<delta>\\<^sub>M\n             (q\\<^sub>0\\<^sub>M (theG \\<chi>))))\n   (\\<iota>\\<^sub>\\<times> (\\<^bold>G \\<phi>)\n     (\\<lambda>\\<chi>.\n         semi_mojmir_def.initial (q\\<^sub>0\\<^sub>M (theG \\<chi>))))\n   w i ?q19 =\n  (map_option rk \\<circ>\n   Mapping.lookup\n    (run (\\<up>\\<Delta>\\<^sub>\\<times>\n           (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n            theG))\n      (Mapping.tabulate (G_list \\<phi>)\n        (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n      w i))\n   ?q19\n  ?q19 \\<in> \\<^bold>G \\<phi> \\<Longrightarrow>\n  run (\\<Delta>\\<^sub>\\<times>\n        (\\<lambda>\\<chi>.\n            semi_mojmir_def.step \\<Sigma> \\<delta>\\<^sub>M\n             (q\\<^sub>0\\<^sub>M (theG \\<chi>))))\n   (\\<iota>\\<^sub>\\<times> (\\<^bold>G \\<phi>)\n     (\\<lambda>\\<chi>.\n         semi_mojmir_def.initial (q\\<^sub>0\\<^sub>M (theG \\<chi>))))\n   w i ?q19 =\n  (map_option rk \\<circ>\n   Mapping.lookup\n    (run (\\<up>\\<Delta>\\<^sub>\\<times>\n           (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n            theG))\n      (Mapping.tabulate (G_list \\<phi>)\n        (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n      w i))\n   ?q19", "have \"run ?\\<delta>\\<^sub>2 ?q\\<^sub>2 w i = (\\<lambda>m. (map_option rk) o (Mapping.lookup m)) (run ?\\<delta>\\<^sub>2' ?q\\<^sub>2' w i)\""], ["proof (prove)\nusing this:\n  ?q19 \\<notin> \\<^bold>G \\<phi> \\<Longrightarrow>\n  run (\\<Delta>\\<^sub>\\<times>\n        (\\<lambda>\\<chi>.\n            semi_mojmir_def.step \\<Sigma> \\<delta>\\<^sub>M\n             (q\\<^sub>0\\<^sub>M (theG \\<chi>))))\n   (\\<iota>\\<^sub>\\<times> (\\<^bold>G \\<phi>)\n     (\\<lambda>\\<chi>.\n         semi_mojmir_def.initial (q\\<^sub>0\\<^sub>M (theG \\<chi>))))\n   w i ?q19 =\n  (map_option rk \\<circ>\n   Mapping.lookup\n    (run (\\<up>\\<Delta>\\<^sub>\\<times>\n           (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n            theG))\n      (Mapping.tabulate (G_list \\<phi>)\n        (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n      w i))\n   ?q19\n  ?q19 \\<in> \\<^bold>G \\<phi> \\<Longrightarrow>\n  run (\\<Delta>\\<^sub>\\<times>\n        (\\<lambda>\\<chi>.\n            semi_mojmir_def.step \\<Sigma> \\<delta>\\<^sub>M\n             (q\\<^sub>0\\<^sub>M (theG \\<chi>))))\n   (\\<iota>\\<^sub>\\<times> (\\<^bold>G \\<phi>)\n     (\\<lambda>\\<chi>.\n         semi_mojmir_def.initial (q\\<^sub>0\\<^sub>M (theG \\<chi>))))\n   w i ?q19 =\n  (map_option rk \\<circ>\n   Mapping.lookup\n    (run (\\<up>\\<Delta>\\<^sub>\\<times>\n           (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n            theG))\n      (Mapping.tabulate (G_list \\<phi>)\n        (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n      w i))\n   ?q19\n\ngoal (1 subgoal):\n 1. run (\\<Delta>\\<^sub>\\<times>\n          (\\<lambda>\\<chi>.\n              semi_mojmir_def.step \\<Sigma> \\<delta>\\<^sub>M\n               (q\\<^sub>0\\<^sub>M (theG \\<chi>))))\n     (\\<iota>\\<^sub>\\<times> (\\<^bold>G \\<phi>)\n       (\\<lambda>\\<chi>.\n           semi_mojmir_def.initial (q\\<^sub>0\\<^sub>M (theG \\<chi>))))\n     w i =\n    map_option rk \\<circ>\n    Mapping.lookup\n     (run (\\<up>\\<Delta>\\<^sub>\\<times>\n            (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n             theG))\n       (Mapping.tabulate (G_list \\<phi>)\n         (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n       w i)", "by blast"], ["proof (state)\nthis:\n  run (\\<Delta>\\<^sub>\\<times>\n        (\\<lambda>\\<chi>.\n            semi_mojmir_def.step \\<Sigma> \\<delta>\\<^sub>M\n             (q\\<^sub>0\\<^sub>M (theG \\<chi>))))\n   (\\<iota>\\<^sub>\\<times> (\\<^bold>G \\<phi>)\n     (\\<lambda>\\<chi>.\n         semi_mojmir_def.initial (q\\<^sub>0\\<^sub>M (theG \\<chi>))))\n   w i =\n  map_option rk \\<circ>\n  Mapping.lookup\n   (run (\\<up>\\<Delta>\\<^sub>\\<times>\n          (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n           theG))\n     (Mapping.tabulate (G_list \\<phi>)\n       (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n     w i)\n\ngoal (1 subgoal):\n 1. run (delta \\<Sigma>) (initial \\<phi>) w =\n    abstract_state \\<circ>\n    run (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>) w", "}"], ["proof (state)\nthis:\n  run (\\<Delta>\\<^sub>\\<times>\n        (\\<lambda>\\<chi>.\n            semi_mojmir_def.step \\<Sigma> \\<delta>\\<^sub>M\n             (q\\<^sub>0\\<^sub>M (theG \\<chi>))))\n   (\\<iota>\\<^sub>\\<times> (\\<^bold>G \\<phi>)\n     (\\<lambda>\\<chi>.\n         semi_mojmir_def.initial (q\\<^sub>0\\<^sub>M (theG \\<chi>))))\n   w ?i19 =\n  map_option rk \\<circ>\n  Mapping.lookup\n   (run (\\<up>\\<Delta>\\<^sub>\\<times>\n          (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n           theG))\n     (Mapping.tabulate (G_list \\<phi>)\n       (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n     w ?i19)\n\ngoal (1 subgoal):\n 1. run (delta \\<Sigma>) (initial \\<phi>) w =\n    abstract_state \\<circ>\n    run (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>) w", "hence \"\\<And>i. run (delta \\<Sigma>) (initial \\<phi>) w i = abstract_state (run (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>) w i)\""], ["proof (prove)\nusing this:\n  run (\\<Delta>\\<^sub>\\<times>\n        (\\<lambda>\\<chi>.\n            semi_mojmir_def.step \\<Sigma> \\<delta>\\<^sub>M\n             (q\\<^sub>0\\<^sub>M (theG \\<chi>))))\n   (\\<iota>\\<^sub>\\<times> (\\<^bold>G \\<phi>)\n     (\\<lambda>\\<chi>.\n         semi_mojmir_def.initial (q\\<^sub>0\\<^sub>M (theG \\<chi>))))\n   w ?i19 =\n  map_option rk \\<circ>\n  Mapping.lookup\n   (run (\\<up>\\<Delta>\\<^sub>\\<times>\n          (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n           theG))\n     (Mapping.tabulate (G_list \\<phi>)\n       (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n     w ?i19)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       run (delta \\<Sigma>) (initial \\<phi>) w i =\n       abstract_state\n        (run (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>) w i)", "using finite_\\<Sigma> bounded_w"], ["proof (prove)\nusing this:\n  run (\\<Delta>\\<^sub>\\<times>\n        (\\<lambda>\\<chi>.\n            semi_mojmir_def.step \\<Sigma> \\<delta>\\<^sub>M\n             (q\\<^sub>0\\<^sub>M (theG \\<chi>))))\n   (\\<iota>\\<^sub>\\<times> (\\<^bold>G \\<phi>)\n     (\\<lambda>\\<chi>.\n         semi_mojmir_def.initial (q\\<^sub>0\\<^sub>M (theG \\<chi>))))\n   w ?i19 =\n  map_option rk \\<circ>\n  Mapping.lookup\n   (run (\\<up>\\<Delta>\\<^sub>\\<times>\n          (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n           theG))\n     (Mapping.tabulate (G_list \\<phi>)\n       (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n     w ?i19)\n  finite \\<Sigma>\n  range w \\<subseteq> \\<Sigma>\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       run (delta \\<Sigma>) (initial \\<phi>) w i =\n       abstract_state\n        (run (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>) w i)", "by (simp add: simple_product_run comp_def del: simple_product.simps)"], ["proof (state)\nthis:\n  run (delta \\<Sigma>) (initial \\<phi>) w ?i17 =\n  abstract_state\n   (run (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>) w ?i17)\n\ngoal (1 subgoal):\n 1. run (delta \\<Sigma>) (initial \\<phi>) w =\n    abstract_state \\<circ>\n    run (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>) w", "thus ?thesis"], ["proof (prove)\nusing this:\n  run (delta \\<Sigma>) (initial \\<phi>) w ?i17 =\n  abstract_state\n   (run (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>) w ?i17)\n\ngoal (1 subgoal):\n 1. run (delta \\<Sigma>) (initial \\<phi>) w =\n    abstract_state \\<circ>\n    run (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>) w", "by auto"], ["proof (state)\nthis:\n  run (delta \\<Sigma>) (initial \\<phi>) w =\n  abstract_state \\<circ>\n  run (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>) w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \n  assumes \"t \\<in> reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>)\"\n  assumes \"\\<chi> \\<in> \\<^bold>G \\<phi>\"\n  shows Acc_fin\\<^sub>C_correct: \n    \"abstract_transition t \\<in> Acc_fin \\<Sigma> \\<pi> \\<chi> \\<longleftrightarrow> Acc_fin\\<^sub>C \\<Sigma> (Mapping.Mapping \\<pi>) \\<chi> t\" (is ?t1)\n    and Acc_inf\\<^sub>C_correct: \n    \"abstract_transition t \\<in> Acc_inf \\<pi> \\<chi> \\<longleftrightarrow> Acc_inf\\<^sub>C (Mapping.Mapping \\<pi>) \\<chi> t\" (is ?t2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (abstract_transition t \\<in> Acc_fin \\<Sigma> \\<pi> \\<chi>) =\n    Acc_fin\\<^sub>C \\<Sigma> (mapping.Mapping \\<pi>) \\<chi> t &&&\n    (abstract_transition t \\<in> Acc_inf \\<pi> \\<chi>) =\n    Acc_inf\\<^sub>C (mapping.Mapping \\<pi>) \\<chi> t", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. (abstract_transition t \\<in> Acc_fin \\<Sigma> \\<pi> \\<chi>) =\n    Acc_fin\\<^sub>C \\<Sigma> (mapping.Mapping \\<pi>) \\<chi> t\n 2. (abstract_transition t \\<in> Acc_inf \\<pi> \\<chi>) =\n    Acc_inf\\<^sub>C (mapping.Mapping \\<pi>) \\<chi> t", "obtain x y \\<nu> z z' where t_def [simp]: \"t = ((x, y), \\<nu>, (z, z'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y \\<nu> z z'.\n        t = ((x, y), \\<nu>, z, z') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod.collapse)"], ["proof (state)\nthis:\n  t = ((x, y), \\<nu>, z, z')\n\ngoal (2 subgoals):\n 1. (abstract_transition t \\<in> Acc_fin \\<Sigma> \\<pi> \\<chi>) =\n    Acc_fin\\<^sub>C \\<Sigma> (mapping.Mapping \\<pi>) \\<chi> t\n 2. (abstract_transition t \\<in> Acc_inf \\<pi> \\<chi>) =\n    Acc_inf\\<^sub>C (mapping.Mapping \\<pi>) \\<chi> t", "have \"(x, y) \\<in> reach \\<Sigma> (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>)\"\n    and \"(z, z') \\<in> reach \\<Sigma> (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y)\n    \\<in> reach \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n           (initial\\<^sub>C \\<phi>) &&&\n    (z, z')\n    \\<in> reach \\<Sigma> (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>)", "using assms(1)"], ["proof (prove)\nusing this:\n  t \\<in> reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n           (initial\\<^sub>C \\<phi>)\n\ngoal (1 subgoal):\n 1. (x, y)\n    \\<in> reach \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n           (initial\\<^sub>C \\<phi>) &&&\n    (z, z')\n    \\<in> reach \\<Sigma> (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>)", "unfolding reach\\<^sub>t_def reach_def run\\<^sub>t.simps t_def"], ["proof (prove)\nusing this:\n  ((x, y), \\<nu>, z, z')\n  \\<in> {(run (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>) w n, w n,\n          run (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>) w (Suc n)) |\n         w n. range w \\<subseteq> \\<Sigma>}\n\ngoal (1 subgoal):\n 1. (x, y)\n    \\<in> {run (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>) w n |w n.\n           range w \\<subseteq> \\<Sigma>} &&&\n    (z, z')\n    \\<in> {run (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>) w n |w n.\n           range w \\<subseteq> \\<Sigma>}", "by blast+"], ["proof (state)\nthis:\n  (x, y)\n  \\<in> reach \\<Sigma> (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>)\n  (z, z')\n  \\<in> reach \\<Sigma> (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>)\n\ngoal (2 subgoals):\n 1. (abstract_transition t \\<in> Acc_fin \\<Sigma> \\<pi> \\<chi>) =\n    Acc_fin\\<^sub>C \\<Sigma> (mapping.Mapping \\<pi>) \\<chi> t\n 2. (abstract_transition t \\<in> Acc_inf \\<pi> \\<chi>) =\n    Acc_inf\\<^sub>C (mapping.Mapping \\<pi>) \\<chi> t", "then"], ["proof (chain)\npicking this:\n  (x, y)\n  \\<in> reach \\<Sigma> (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>)\n  (z, z')\n  \\<in> reach \\<Sigma> (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>)", "obtain m m' where [simp]: \"Mapping.lookup y \\<chi> = Some m\" \n    and \"Mapping.lookup y \\<chi> \\<noteq> None\" \n    and [simp]: \"Mapping.lookup z' \\<chi> = Some m'\""], ["proof (prove)\nusing this:\n  (x, y)\n  \\<in> reach \\<Sigma> (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>)\n  (z, z')\n  \\<in> reach \\<Sigma> (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>)\n\ngoal (1 subgoal):\n 1. (\\<And>m m'.\n        \\<lbrakk>Mapping.lookup y \\<chi> = Some m;\n         Mapping.lookup y \\<chi> \\<noteq> None;\n         Mapping.lookup z' \\<chi> = Some m'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2)"], ["proof (prove)\nusing this:\n  (x, y)\n  \\<in> reach \\<Sigma> (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>)\n  (z, z')\n  \\<in> reach \\<Sigma> (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>)\n  \\<chi> \\<in> \\<^bold>G \\<phi>\n\ngoal (1 subgoal):\n 1. (\\<And>m m'.\n        \\<lbrakk>Mapping.lookup y \\<chi> = Some m;\n         Mapping.lookup y \\<chi> \\<noteq> None;\n         Mapping.lookup z' \\<chi> = Some m'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: reach_delta_initial)+"], ["proof (state)\nthis:\n  Mapping.lookup y \\<chi> = Some m\n  Mapping.lookup y \\<chi> \\<noteq> None\n  Mapping.lookup z' \\<chi> = Some m'\n\ngoal (2 subgoals):\n 1. (abstract_transition t \\<in> Acc_fin \\<Sigma> \\<pi> \\<chi>) =\n    Acc_fin\\<^sub>C \\<Sigma> (mapping.Mapping \\<pi>) \\<chi> t\n 2. (abstract_transition t \\<in> Acc_inf \\<pi> \\<chi>) =\n    Acc_inf\\<^sub>C (mapping.Mapping \\<pi>) \\<chi> t", "have FF [simp]: \"fail_filt \\<Sigma> \\<delta>\\<^sub>M (q\\<^sub>0\\<^sub>M (theG \\<chi>)) (ltl_prop_entails_abs (dom \\<pi>)) (the (Mapping.lookup y \\<chi>), \\<nu>, []) \n    = ((the (map_option rk (Mapping.lookup y \\<chi>)), \\<nu>, (\\<lambda>x. Some 0)) \\<in> mojmir_to_rabin_def.fail\\<^sub>R \\<Sigma> \\<delta>\\<^sub>M (q\\<^sub>0\\<^sub>M (theG \\<chi>)) {q. dom \\<pi> \\<up>\\<Turnstile>\\<^sub>P q})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fail_filt \\<Sigma> \\<delta>\\<^sub>M (q\\<^sub>0\\<^sub>M (theG \\<chi>))\n     (ltl_prop_entails_abs (dom \\<pi>))\n     (the (Mapping.lookup y \\<chi>), \\<nu>, []) =\n    ((the (map_option rk (Mapping.lookup y \\<chi>)), \\<nu>,\n      \\<lambda>x. Some 0)\n     \\<in> mojmir_to_rabin_def.fail\\<^sub>R \\<Sigma> \\<delta>\\<^sub>M\n            (q\\<^sub>0\\<^sub>M (theG \\<chi>))\n            {q. dom \\<pi> \\<up>\\<Turnstile>\\<^sub>P q})", "unfolding option.map_sel[OF \\<open>Mapping.lookup y \\<chi> \\<noteq> None\\<close>] fail_filt_eq[where y = \"[]\", symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. fail_filt \\<Sigma> \\<delta>\\<^sub>M (q\\<^sub>0\\<^sub>M (theG \\<chi>))\n     (ltl_prop_entails_abs (dom \\<pi>))\n     (the (Mapping.lookup y \\<chi>), \\<nu>, []) =\n    fail_filt \\<Sigma> \\<delta>\\<^sub>M (q\\<^sub>0\\<^sub>M (theG \\<chi>))\n     (ltl_prop_entails_abs (dom \\<pi>))\n     (the (Mapping.lookup y \\<chi>), \\<nu>, [])", "by simp"], ["proof (state)\nthis:\n  fail_filt \\<Sigma> \\<delta>\\<^sub>M (q\\<^sub>0\\<^sub>M (theG \\<chi>))\n   (ltl_prop_entails_abs (dom \\<pi>))\n   (the (Mapping.lookup y \\<chi>), \\<nu>, []) =\n  ((the (map_option rk (Mapping.lookup y \\<chi>)), \\<nu>,\n    \\<lambda>x. Some 0)\n   \\<in> mojmir_to_rabin_def.fail\\<^sub>R \\<Sigma> \\<delta>\\<^sub>M\n          (q\\<^sub>0\\<^sub>M (theG \\<chi>))\n          {q. dom \\<pi> \\<up>\\<Turnstile>\\<^sub>P q})\n\ngoal (2 subgoals):\n 1. (abstract_transition t \\<in> Acc_fin \\<Sigma> \\<pi> \\<chi>) =\n    Acc_fin\\<^sub>C \\<Sigma> (mapping.Mapping \\<pi>) \\<chi> t\n 2. (abstract_transition t \\<in> Acc_inf \\<pi> \\<chi>) =\n    Acc_inf\\<^sub>C (mapping.Mapping \\<pi>) \\<chi> t", "have MF [simp]: \"\\<And>i. merge_filt \\<delta>\\<^sub>M (q\\<^sub>0\\<^sub>M (theG \\<chi>)) (ltl_prop_entails_abs (dom \\<pi>)) i (the (Mapping.lookup y \\<chi>), \\<nu>, [])\n    = ((the (map_option rk (Mapping.lookup y \\<chi>)), \\<nu>, (\\<lambda>x. Some 0)) \\<in> mojmir_to_rabin_def.merge\\<^sub>R \\<delta>\\<^sub>M (q\\<^sub>0\\<^sub>M (theG \\<chi>)) {q. dom \\<pi> \\<up>\\<Turnstile>\\<^sub>P q} i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       merge_filt \\<delta>\\<^sub>M (q\\<^sub>0\\<^sub>M (theG \\<chi>))\n        (ltl_prop_entails_abs (dom \\<pi>)) i\n        (the (Mapping.lookup y \\<chi>), \\<nu>, []) =\n       ((the (map_option rk (Mapping.lookup y \\<chi>)), \\<nu>,\n         \\<lambda>x. Some 0)\n        \\<in> mojmir_to_rabin_def.merge\\<^sub>R \\<delta>\\<^sub>M\n               (q\\<^sub>0\\<^sub>M (theG \\<chi>))\n               {q. dom \\<pi> \\<up>\\<Turnstile>\\<^sub>P q} i)", "unfolding option.map_sel[OF \\<open>Mapping.lookup y \\<chi> \\<noteq> None\\<close>] merge_filt_eq[where y = \"[]\", symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       merge_filt \\<delta>\\<^sub>M (q\\<^sub>0\\<^sub>M (theG \\<chi>))\n        (ltl_prop_entails_abs (dom \\<pi>)) i\n        (the (Mapping.lookup y \\<chi>), \\<nu>, []) =\n       merge_filt \\<delta>\\<^sub>M (q\\<^sub>0\\<^sub>M (theG \\<chi>))\n        (ltl_prop_entails_abs (dom \\<pi>)) i\n        (the (Mapping.lookup y \\<chi>), \\<nu>, [])", "by simp"], ["proof (state)\nthis:\n  merge_filt \\<delta>\\<^sub>M (q\\<^sub>0\\<^sub>M (theG \\<chi>))\n   (ltl_prop_entails_abs (dom \\<pi>)) ?i17\n   (the (Mapping.lookup y \\<chi>), \\<nu>, []) =\n  ((the (map_option rk (Mapping.lookup y \\<chi>)), \\<nu>,\n    \\<lambda>x. Some 0)\n   \\<in> mojmir_to_rabin_def.merge\\<^sub>R \\<delta>\\<^sub>M\n          (q\\<^sub>0\\<^sub>M (theG \\<chi>))\n          {q. dom \\<pi> \\<up>\\<Turnstile>\\<^sub>P q} ?i17)\n\ngoal (2 subgoals):\n 1. (abstract_transition t \\<in> Acc_fin \\<Sigma> \\<pi> \\<chi>) =\n    Acc_fin\\<^sub>C \\<Sigma> (mapping.Mapping \\<pi>) \\<chi> t\n 2. (abstract_transition t \\<in> Acc_inf \\<pi> \\<chi>) =\n    Acc_inf\\<^sub>C (mapping.Mapping \\<pi>) \\<chi> t", "have SF [simp]: \"\\<And>i. succeed_filt \\<delta>\\<^sub>M (q\\<^sub>0\\<^sub>M (theG \\<chi>)) (ltl_prop_entails_abs (dom \\<pi>)) i (the (Mapping.lookup y \\<chi>), \\<nu>, [])\n    = ((the (map_option rk (Mapping.lookup y \\<chi>)), \\<nu>, (\\<lambda>x. Some 0)) \\<in> mojmir_to_rabin_def.succeed\\<^sub>R \\<delta>\\<^sub>M (q\\<^sub>0\\<^sub>M (theG \\<chi>)) {q. dom \\<pi> \\<up>\\<Turnstile>\\<^sub>P q} i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       succeed_filt \\<delta>\\<^sub>M (q\\<^sub>0\\<^sub>M (theG \\<chi>))\n        (ltl_prop_entails_abs (dom \\<pi>)) i\n        (the (Mapping.lookup y \\<chi>), \\<nu>, []) =\n       ((the (map_option rk (Mapping.lookup y \\<chi>)), \\<nu>,\n         \\<lambda>x. Some 0)\n        \\<in> mojmir_to_rabin_def.succeed\\<^sub>R \\<delta>\\<^sub>M\n               (q\\<^sub>0\\<^sub>M (theG \\<chi>))\n               {q. dom \\<pi> \\<up>\\<Turnstile>\\<^sub>P q} i)", "unfolding option.map_sel[OF \\<open>Mapping.lookup y \\<chi> \\<noteq> None\\<close>] succeed_filt_eq[where y = \"[]\", symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       succeed_filt \\<delta>\\<^sub>M (q\\<^sub>0\\<^sub>M (theG \\<chi>))\n        (ltl_prop_entails_abs (dom \\<pi>)) i\n        (the (Mapping.lookup y \\<chi>), \\<nu>, []) =\n       succeed_filt \\<delta>\\<^sub>M (q\\<^sub>0\\<^sub>M (theG \\<chi>))\n        (ltl_prop_entails_abs (dom \\<pi>)) i\n        (the (Mapping.lookup y \\<chi>), \\<nu>, [])", "by simp"], ["proof (state)\nthis:\n  succeed_filt \\<delta>\\<^sub>M (q\\<^sub>0\\<^sub>M (theG \\<chi>))\n   (ltl_prop_entails_abs (dom \\<pi>)) ?i17\n   (the (Mapping.lookup y \\<chi>), \\<nu>, []) =\n  ((the (map_option rk (Mapping.lookup y \\<chi>)), \\<nu>,\n    \\<lambda>x. Some 0)\n   \\<in> mojmir_to_rabin_def.succeed\\<^sub>R \\<delta>\\<^sub>M\n          (q\\<^sub>0\\<^sub>M (theG \\<chi>))\n          {q. dom \\<pi> \\<up>\\<Turnstile>\\<^sub>P q} ?i17)\n\ngoal (2 subgoals):\n 1. (abstract_transition t \\<in> Acc_fin \\<Sigma> \\<pi> \\<chi>) =\n    Acc_fin\\<^sub>C \\<Sigma> (mapping.Mapping \\<pi>) \\<chi> t\n 2. (abstract_transition t \\<in> Acc_inf \\<pi> \\<chi>) =\n    Acc_inf\\<^sub>C (mapping.Mapping \\<pi>) \\<chi> t", "note mojmir_to_rabin_def.fail\\<^sub>R_def [simp]"], ["proof (state)\nthis:\n  mojmir_to_rabin_def.fail\\<^sub>R ?\\<Sigma> ?\\<delta> ?q\\<^sub>0 ?F =\n  {uu_.\n   \\<exists>r \\<nu> s q q'.\n      uu_ = (r, \\<nu>, s) \\<and>\n      r q \\<noteq> None \\<and>\n      q' = ?\\<delta> q \\<nu> \\<and>\n      q' \\<notin> ?F \\<and>\n      semi_mojmir_def.sink ?\\<Sigma> ?\\<delta> ?q\\<^sub>0 q'}\n\ngoal (2 subgoals):\n 1. (abstract_transition t \\<in> Acc_fin \\<Sigma> \\<pi> \\<chi>) =\n    Acc_fin\\<^sub>C \\<Sigma> (mapping.Mapping \\<pi>) \\<chi> t\n 2. (abstract_transition t \\<in> Acc_inf \\<pi> \\<chi>) =\n    Acc_inf\\<^sub>C (mapping.Mapping \\<pi>) \\<chi> t", "note mojmir_to_rabin_def.merge\\<^sub>R_def [simp]"], ["proof (state)\nthis:\n  mojmir_to_rabin_def.merge\\<^sub>R ?\\<delta> ?q\\<^sub>0 ?F ?i =\n  {uu_.\n   \\<exists>r \\<nu> s q q' j.\n      uu_ = (r, \\<nu>, s) \\<and>\n      r q = Some j \\<and>\n      j < ?i \\<and>\n      q' = ?\\<delta> q \\<nu> \\<and>\n      ((\\<exists>q''.\n           q' = ?\\<delta> q'' \\<nu> \\<and>\n           r q'' \\<noteq> None \\<and> q'' \\<noteq> q) \\<or>\n       q' = ?q\\<^sub>0) \\<and>\n      q' \\<notin> ?F}\n\ngoal (2 subgoals):\n 1. (abstract_transition t \\<in> Acc_fin \\<Sigma> \\<pi> \\<chi>) =\n    Acc_fin\\<^sub>C \\<Sigma> (mapping.Mapping \\<pi>) \\<chi> t\n 2. (abstract_transition t \\<in> Acc_inf \\<pi> \\<chi>) =\n    Acc_inf\\<^sub>C (mapping.Mapping \\<pi>) \\<chi> t", "note mojmir_to_rabin_def.succeed\\<^sub>R_def [simp]"], ["proof (state)\nthis:\n  mojmir_to_rabin_def.succeed\\<^sub>R ?\\<delta> ?q\\<^sub>0 ?F ?i =\n  {uu_.\n   \\<exists>r \\<nu> s q.\n      uu_ = (r, \\<nu>, s) \\<and>\n      r q = Some ?i \\<and>\n      q \\<notin> ?F - {?q\\<^sub>0} \\<and> ?\\<delta> q \\<nu> \\<in> ?F}\n\ngoal (2 subgoals):\n 1. (abstract_transition t \\<in> Acc_fin \\<Sigma> \\<pi> \\<chi>) =\n    Acc_fin\\<^sub>C \\<Sigma> (mapping.Mapping \\<pi>) \\<chi> t\n 2. (abstract_transition t \\<in> Acc_inf \\<pi> \\<chi>) =\n    Acc_inf\\<^sub>C (mapping.Mapping \\<pi>) \\<chi> t", "show ?t1 and ?t2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (abstract_transition t \\<in> Acc_fin \\<Sigma> \\<pi> \\<chi>) =\n    Acc_fin\\<^sub>C \\<Sigma> (mapping.Mapping \\<pi>) \\<chi> t &&&\n    (abstract_transition t \\<in> Acc_inf \\<pi> \\<chi>) =\n    Acc_inf\\<^sub>C (mapping.Mapping \\<pi>) \\<chi> t", "by (simp_all add: Let_def keys.abs_eq lookup.abs_eq del: rk.simps) \n       (rule; metis option.distinct(1) option.sel option.collapse rk_facts(1))+"], ["proof (state)\nthis:\n  (abstract_transition t \\<in> Acc_fin \\<Sigma> \\<pi> \\<chi>) =\n  Acc_fin\\<^sub>C \\<Sigma> (mapping.Mapping \\<pi>) \\<chi> t\n  (abstract_transition t \\<in> Acc_inf \\<pi> \\<chi>) =\n  Acc_inf\\<^sub>C (mapping.Mapping \\<pi>) \\<chi> t\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem ltl_to_generalized_rabin\\<^sub>C_correct:\n  assumes \"\\<Sigma> = set \\<Sigma>'\"\n  shows \"accept\\<^sub>G\\<^sub>R (ltl_to_generalized_rabin \\<Sigma> \\<phi>) w \\<longleftrightarrow> accept\\<^sub>G\\<^sub>R_LTS (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w\" \n  (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w =\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w\n 2. accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w", "let ?\\<delta> = \"delta \\<Sigma>\""], ["proof (state)\ngoal (2 subgoals):\n 1. accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w\n 2. accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w", "let ?q\\<^sub>0 = \"initial \\<phi>\""], ["proof (state)\ngoal (2 subgoals):\n 1. accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w\n 2. accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w", "let ?\\<delta>\\<^sub>C = \"delta\\<^sub>C \\<Sigma>\""], ["proof (state)\ngoal (2 subgoals):\n 1. accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w\n 2. accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w", "let ?q\\<^sub>0\\<^sub>C = \"initial\\<^sub>C \\<phi>\""], ["proof (state)\ngoal (2 subgoals):\n 1. accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w\n 2. accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w", "let ?reach\\<^sub>C = \"reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>)\""], ["proof (state)\ngoal (2 subgoals):\n 1. accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w\n 2. accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w", "note reachable_transitions\\<^sub>C_simp[simp] = reachable_transitions\\<^sub>C_eq[OF assms]"], ["proof (state)\nthis:\n  reachable_transitions\\<^sub>C \\<Sigma>' ?\\<phi> =\n  reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C ?\\<phi>)\n\ngoal (2 subgoals):\n 1. accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w\n 2. accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w", "note max_rank_of\\<^sub>C_simp[simp] = max_rank_of\\<^sub>C_eq[OF assms]"], ["proof (state)\nthis:\n  max_rank_of\\<^sub>C \\<Sigma>' ?\\<psi> = max_rank_of \\<Sigma> ?\\<psi>\n\ngoal (2 subgoals):\n 1. accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w\n 2. accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w", "{"], ["proof (state)\nthis:\n  max_rank_of\\<^sub>C \\<Sigma>' ?\\<psi> = max_rank_of \\<Sigma> ?\\<psi>\n\ngoal (2 subgoals):\n 1. accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w\n 2. accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w", "fix \\<pi> :: \"'a ltl \\<Rightarrow> nat option\""], ["proof (state)\ngoal (2 subgoals):\n 1. accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w\n 2. accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w", "assume \\<pi>_wellformed: \"dom \\<pi> \\<subseteq> \\<^bold>G \\<phi>\""], ["proof (state)\nthis:\n  dom \\<pi> \\<subseteq> \\<^bold>G \\<phi>\n\ngoal (2 subgoals):\n 1. accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w\n 2. accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w", "let ?F = \"(M_fin \\<pi> \\<union> \\<Union>{Acc_fin \\<Sigma> \\<pi> \\<chi> | \\<chi>. \\<chi> \\<in> dom \\<pi>}, {Acc_inf \\<pi> \\<chi> | \\<chi>. \\<chi> \\<in> dom \\<pi>})\""], ["proof (state)\ngoal (2 subgoals):\n 1. accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w\n 2. accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w", "let ?fin = \"{t. M_fin\\<^sub>C \\<phi> (Mapping.Mapping \\<pi>) t} \\<union> {t. \\<exists>\\<chi> \\<in> dom \\<pi>. Acc_fin\\<^sub>C \\<Sigma> (Mapping.Mapping \\<pi>) \\<chi> t}\""], ["proof (state)\ngoal (2 subgoals):\n 1. accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w\n 2. accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w", "let ?inf = \"{{t. Acc_inf\\<^sub>C (Mapping.Mapping \\<pi>) \\<chi> t} | \\<chi>. \\<chi> \\<in> dom \\<pi>}\""], ["proof (state)\ngoal (2 subgoals):\n 1. accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w\n 2. accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w", "have finite_reach': \"finite (reach\\<^sub>t \\<Sigma> (delta \\<Sigma>) (initial \\<phi>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (reach\\<^sub>t \\<Sigma> (delta \\<Sigma>) (initial \\<phi>))", "by (meson finite_reach finite_\\<Sigma> finite_reach\\<^sub>t)"], ["proof (state)\nthis:\n  finite (reach\\<^sub>t \\<Sigma> (delta \\<Sigma>) (initial \\<phi>))\n\ngoal (2 subgoals):\n 1. accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w\n 2. accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w", "have run_abstraction_correct': \n      \"run\\<^sub>t (delta \\<Sigma>) (initial \\<phi>) w = abstract_transition o (run\\<^sub>t (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>) w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run\\<^sub>t (delta \\<Sigma>) (initial \\<phi>) w =\n    abstract_transition \\<circ>\n    run\\<^sub>t (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>) w", "using run_abstraction_correct comp_def"], ["proof (prove)\nusing this:\n  run (delta \\<Sigma>) (initial ?\\<phi>) w =\n  abstract_state \\<circ>\n  run (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C ?\\<phi>) w\n  ?f \\<circ> ?g = (\\<lambda>x. ?f (?g x))\n\ngoal (1 subgoal):\n 1. run\\<^sub>t (delta \\<Sigma>) (initial \\<phi>) w =\n    abstract_transition \\<circ>\n    run\\<^sub>t (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>) w", "by auto"], ["proof (state)\nthis:\n  run\\<^sub>t (delta \\<Sigma>) (initial \\<phi>) w =\n  abstract_transition \\<circ>\n  run\\<^sub>t (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>) w\n\ngoal (2 subgoals):\n 1. accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w\n 2. accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w", "have \"accepting_pair\\<^sub>G\\<^sub>R ?\\<delta> ?q\\<^sub>0 ?F w \\<longleftrightarrow> accepting_pair\\<^sub>G\\<^sub>R ?\\<delta>\\<^sub>C  ?q\\<^sub>0\\<^sub>C (?fin, ?inf) w\" (is \"?l \\<longleftrightarrow> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. accepting_pair\\<^sub>G\\<^sub>R (delta \\<Sigma>) (initial \\<phi>)\n     (M_fin \\<pi> \\<union>\n      \\<Union>\n       {Acc_fin \\<Sigma> \\<pi> \\<chi> |\\<chi>. \\<chi> \\<in> dom \\<pi>},\n      {Acc_inf \\<pi> \\<chi> |\\<chi>. \\<chi> \\<in> dom \\<pi>})\n     w =\n    accepting_pair\\<^sub>G\\<^sub>R (delta\\<^sub>C \\<Sigma>)\n     (initial\\<^sub>C \\<phi>)\n     ({t. M_fin\\<^sub>C \\<phi> (mapping.Mapping \\<pi>) t} \\<union>\n      {t. \\<exists>\\<chi>\\<in>dom \\<pi>.\n             Acc_fin\\<^sub>C \\<Sigma> (mapping.Mapping \\<pi>) \\<chi> t},\n      {{t. Acc_inf\\<^sub>C (mapping.Mapping \\<pi>) \\<chi> t} |\\<chi>.\n       \\<chi> \\<in> dom \\<pi>})\n     w", "by (rule accepting_pair\\<^sub>G\\<^sub>R_abstract[OF finite_reach' finite_reach\\<^sub>C bounded_w];\n          insert \\<open>dom \\<pi> \\<subseteq> \\<^bold>G \\<phi>\\<close> M_fin\\<^sub>C_correct Acc_fin\\<^sub>C_correct Acc_inf\\<^sub>C_correct run_abstraction_correct'; blast)"], ["proof (state)\nthis:\n  accepting_pair\\<^sub>G\\<^sub>R (delta \\<Sigma>) (initial \\<phi>)\n   (M_fin \\<pi> \\<union>\n    \\<Union>\n     {Acc_fin \\<Sigma> \\<pi> \\<chi> |\\<chi>. \\<chi> \\<in> dom \\<pi>},\n    {Acc_inf \\<pi> \\<chi> |\\<chi>. \\<chi> \\<in> dom \\<pi>})\n   w =\n  accepting_pair\\<^sub>G\\<^sub>R (delta\\<^sub>C \\<Sigma>)\n   (initial\\<^sub>C \\<phi>)\n   ({t. M_fin\\<^sub>C \\<phi> (mapping.Mapping \\<pi>) t} \\<union>\n    {t. \\<exists>\\<chi>\\<in>dom \\<pi>.\n           Acc_fin\\<^sub>C \\<Sigma> (mapping.Mapping \\<pi>) \\<chi> t},\n    {{t. Acc_inf\\<^sub>C (mapping.Mapping \\<pi>) \\<chi> t} |\\<chi>.\n     \\<chi> \\<in> dom \\<pi>})\n   w\n\ngoal (2 subgoals):\n 1. accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w\n 2. accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w", "also"], ["proof (state)\nthis:\n  accepting_pair\\<^sub>G\\<^sub>R (delta \\<Sigma>) (initial \\<phi>)\n   (M_fin \\<pi> \\<union>\n    \\<Union>\n     {Acc_fin \\<Sigma> \\<pi> \\<chi> |\\<chi>. \\<chi> \\<in> dom \\<pi>},\n    {Acc_inf \\<pi> \\<chi> |\\<chi>. \\<chi> \\<in> dom \\<pi>})\n   w =\n  accepting_pair\\<^sub>G\\<^sub>R (delta\\<^sub>C \\<Sigma>)\n   (initial\\<^sub>C \\<phi>)\n   ({t. M_fin\\<^sub>C \\<phi> (mapping.Mapping \\<pi>) t} \\<union>\n    {t. \\<exists>\\<chi>\\<in>dom \\<pi>.\n           Acc_fin\\<^sub>C \\<Sigma> (mapping.Mapping \\<pi>) \\<chi> t},\n    {{t. Acc_inf\\<^sub>C (mapping.Mapping \\<pi>) \\<chi> t} |\\<chi>.\n     \\<chi> \\<in> dom \\<pi>})\n   w\n\ngoal (2 subgoals):\n 1. accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w\n 2. accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w", "have \"\\<dots> \\<longleftrightarrow> accepting_pair\\<^sub>G\\<^sub>R_LTS ?reach\\<^sub>C ?q\\<^sub>0\\<^sub>C (?fin \\<inter> ?reach\\<^sub>C, (\\<lambda>I. I \\<inter> ?reach\\<^sub>C) ` ?inf) w\" (is \"_ \\<longleftrightarrow> ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. accepting_pair\\<^sub>G\\<^sub>R (delta\\<^sub>C \\<Sigma>)\n     (initial\\<^sub>C \\<phi>)\n     ({t. M_fin\\<^sub>C \\<phi> (mapping.Mapping \\<pi>) t} \\<union>\n      {t. \\<exists>\\<chi>\\<in>dom \\<pi>.\n             Acc_fin\\<^sub>C \\<Sigma> (mapping.Mapping \\<pi>) \\<chi> t},\n      {{t. Acc_inf\\<^sub>C (mapping.Mapping \\<pi>) \\<chi> t} |\\<chi>.\n       \\<chi> \\<in> dom \\<pi>})\n     w =\n    accepting_pair\\<^sub>G\\<^sub>R_LTS\n     (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n       (initial\\<^sub>C \\<phi>))\n     (initial\\<^sub>C \\<phi>)\n     (({t. M_fin\\<^sub>C \\<phi> (mapping.Mapping \\<pi>) t} \\<union>\n       {t. \\<exists>\\<chi>\\<in>dom \\<pi>.\n              Acc_fin\\<^sub>C \\<Sigma> (mapping.Mapping \\<pi>) \\<chi>\n               t}) \\<inter>\n      reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n       (initial\\<^sub>C \\<phi>),\n      (\\<lambda>I.\n          I \\<inter>\n          reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n           (initial\\<^sub>C \\<phi>)) `\n      {{t. Acc_inf\\<^sub>C (mapping.Mapping \\<pi>) \\<chi> t} |\\<chi>.\n       \\<chi> \\<in> dom \\<pi>})\n     w", "using bounded_w"], ["proof (prove)\nusing this:\n  range w \\<subseteq> \\<Sigma>\n\ngoal (1 subgoal):\n 1. accepting_pair\\<^sub>G\\<^sub>R (delta\\<^sub>C \\<Sigma>)\n     (initial\\<^sub>C \\<phi>)\n     ({t. M_fin\\<^sub>C \\<phi> (mapping.Mapping \\<pi>) t} \\<union>\n      {t. \\<exists>\\<chi>\\<in>dom \\<pi>.\n             Acc_fin\\<^sub>C \\<Sigma> (mapping.Mapping \\<pi>) \\<chi> t},\n      {{t. Acc_inf\\<^sub>C (mapping.Mapping \\<pi>) \\<chi> t} |\\<chi>.\n       \\<chi> \\<in> dom \\<pi>})\n     w =\n    accepting_pair\\<^sub>G\\<^sub>R_LTS\n     (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n       (initial\\<^sub>C \\<phi>))\n     (initial\\<^sub>C \\<phi>)\n     (({t. M_fin\\<^sub>C \\<phi> (mapping.Mapping \\<pi>) t} \\<union>\n       {t. \\<exists>\\<chi>\\<in>dom \\<pi>.\n              Acc_fin\\<^sub>C \\<Sigma> (mapping.Mapping \\<pi>) \\<chi>\n               t}) \\<inter>\n      reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n       (initial\\<^sub>C \\<phi>),\n      (\\<lambda>I.\n          I \\<inter>\n          reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n           (initial\\<^sub>C \\<phi>)) `\n      {{t. Acc_inf\\<^sub>C (mapping.Mapping \\<pi>) \\<chi> t} |\\<chi>.\n       \\<chi> \\<in> dom \\<pi>})\n     w", "by (simp only: accepting_pair\\<^sub>G\\<^sub>R_LTS[symmetric] accepting_pair\\<^sub>G\\<^sub>R_restrict[symmetric])"], ["proof (state)\nthis:\n  accepting_pair\\<^sub>G\\<^sub>R (delta\\<^sub>C \\<Sigma>)\n   (initial\\<^sub>C \\<phi>)\n   ({t. M_fin\\<^sub>C \\<phi> (mapping.Mapping \\<pi>) t} \\<union>\n    {t. \\<exists>\\<chi>\\<in>dom \\<pi>.\n           Acc_fin\\<^sub>C \\<Sigma> (mapping.Mapping \\<pi>) \\<chi> t},\n    {{t. Acc_inf\\<^sub>C (mapping.Mapping \\<pi>) \\<chi> t} |\\<chi>.\n     \\<chi> \\<in> dom \\<pi>})\n   w =\n  accepting_pair\\<^sub>G\\<^sub>R_LTS\n   (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n     (initial\\<^sub>C \\<phi>))\n   (initial\\<^sub>C \\<phi>)\n   (({t. M_fin\\<^sub>C \\<phi> (mapping.Mapping \\<pi>) t} \\<union>\n     {t. \\<exists>\\<chi>\\<in>dom \\<pi>.\n            Acc_fin\\<^sub>C \\<Sigma> (mapping.Mapping \\<pi>) \\<chi>\n             t}) \\<inter>\n    reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n     (initial\\<^sub>C \\<phi>),\n    (\\<lambda>I.\n        I \\<inter>\n        reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n         (initial\\<^sub>C \\<phi>)) `\n    {{t. Acc_inf\\<^sub>C (mapping.Mapping \\<pi>) \\<chi> t} |\\<chi>.\n     \\<chi> \\<in> dom \\<pi>})\n   w\n\ngoal (2 subgoals):\n 1. accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w\n 2. accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w", "finally"], ["proof (chain)\npicking this:\n  accepting_pair\\<^sub>G\\<^sub>R (delta \\<Sigma>) (initial \\<phi>)\n   (M_fin \\<pi> \\<union>\n    \\<Union>\n     {Acc_fin \\<Sigma> \\<pi> \\<chi> |\\<chi>. \\<chi> \\<in> dom \\<pi>},\n    {Acc_inf \\<pi> \\<chi> |\\<chi>. \\<chi> \\<in> dom \\<pi>})\n   w =\n  accepting_pair\\<^sub>G\\<^sub>R_LTS\n   (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n     (initial\\<^sub>C \\<phi>))\n   (initial\\<^sub>C \\<phi>)\n   (({t. M_fin\\<^sub>C \\<phi> (mapping.Mapping \\<pi>) t} \\<union>\n     {t. \\<exists>\\<chi>\\<in>dom \\<pi>.\n            Acc_fin\\<^sub>C \\<Sigma> (mapping.Mapping \\<pi>) \\<chi>\n             t}) \\<inter>\n    reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n     (initial\\<^sub>C \\<phi>),\n    (\\<lambda>I.\n        I \\<inter>\n        reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n         (initial\\<^sub>C \\<phi>)) `\n    {{t. Acc_inf\\<^sub>C (mapping.Mapping \\<pi>) \\<chi> t} |\\<chi>.\n     \\<chi> \\<in> dom \\<pi>})\n   w", "have \"?l \\<longleftrightarrow> ?r\""], ["proof (prove)\nusing this:\n  accepting_pair\\<^sub>G\\<^sub>R (delta \\<Sigma>) (initial \\<phi>)\n   (M_fin \\<pi> \\<union>\n    \\<Union>\n     {Acc_fin \\<Sigma> \\<pi> \\<chi> |\\<chi>. \\<chi> \\<in> dom \\<pi>},\n    {Acc_inf \\<pi> \\<chi> |\\<chi>. \\<chi> \\<in> dom \\<pi>})\n   w =\n  accepting_pair\\<^sub>G\\<^sub>R_LTS\n   (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n     (initial\\<^sub>C \\<phi>))\n   (initial\\<^sub>C \\<phi>)\n   (({t. M_fin\\<^sub>C \\<phi> (mapping.Mapping \\<pi>) t} \\<union>\n     {t. \\<exists>\\<chi>\\<in>dom \\<pi>.\n            Acc_fin\\<^sub>C \\<Sigma> (mapping.Mapping \\<pi>) \\<chi>\n             t}) \\<inter>\n    reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n     (initial\\<^sub>C \\<phi>),\n    (\\<lambda>I.\n        I \\<inter>\n        reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n         (initial\\<^sub>C \\<phi>)) `\n    {{t. Acc_inf\\<^sub>C (mapping.Mapping \\<pi>) \\<chi> t} |\\<chi>.\n     \\<chi> \\<in> dom \\<pi>})\n   w\n\ngoal (1 subgoal):\n 1. accepting_pair\\<^sub>G\\<^sub>R (delta \\<Sigma>) (initial \\<phi>)\n     (M_fin \\<pi> \\<union>\n      \\<Union>\n       {Acc_fin \\<Sigma> \\<pi> \\<chi> |\\<chi>. \\<chi> \\<in> dom \\<pi>},\n      {Acc_inf \\<pi> \\<chi> |\\<chi>. \\<chi> \\<in> dom \\<pi>})\n     w =\n    accepting_pair\\<^sub>G\\<^sub>R_LTS\n     (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n       (initial\\<^sub>C \\<phi>))\n     (initial\\<^sub>C \\<phi>)\n     (({t. M_fin\\<^sub>C \\<phi> (mapping.Mapping \\<pi>) t} \\<union>\n       {t. \\<exists>\\<chi>\\<in>dom \\<pi>.\n              Acc_fin\\<^sub>C \\<Sigma> (mapping.Mapping \\<pi>) \\<chi>\n               t}) \\<inter>\n      reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n       (initial\\<^sub>C \\<phi>),\n      (\\<lambda>I.\n          I \\<inter>\n          reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n           (initial\\<^sub>C \\<phi>)) `\n      {{t. Acc_inf\\<^sub>C (mapping.Mapping \\<pi>) \\<chi> t} |\\<chi>.\n       \\<chi> \\<in> dom \\<pi>})\n     w", "."], ["proof (state)\nthis:\n  accepting_pair\\<^sub>G\\<^sub>R (delta \\<Sigma>) (initial \\<phi>)\n   (M_fin \\<pi> \\<union>\n    \\<Union>\n     {Acc_fin \\<Sigma> \\<pi> \\<chi> |\\<chi>. \\<chi> \\<in> dom \\<pi>},\n    {Acc_inf \\<pi> \\<chi> |\\<chi>. \\<chi> \\<in> dom \\<pi>})\n   w =\n  accepting_pair\\<^sub>G\\<^sub>R_LTS\n   (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n     (initial\\<^sub>C \\<phi>))\n   (initial\\<^sub>C \\<phi>)\n   (({t. M_fin\\<^sub>C \\<phi> (mapping.Mapping \\<pi>) t} \\<union>\n     {t. \\<exists>\\<chi>\\<in>dom \\<pi>.\n            Acc_fin\\<^sub>C \\<Sigma> (mapping.Mapping \\<pi>) \\<chi>\n             t}) \\<inter>\n    reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n     (initial\\<^sub>C \\<phi>),\n    (\\<lambda>I.\n        I \\<inter>\n        reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n         (initial\\<^sub>C \\<phi>)) `\n    {{t. Acc_inf\\<^sub>C (mapping.Mapping \\<pi>) \\<chi> t} |\\<chi>.\n     \\<chi> \\<in> dom \\<pi>})\n   w\n\ngoal (2 subgoals):\n 1. accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w\n 2. accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w", "}"], ["proof (state)\nthis:\n  dom ?\\<pi>19 \\<subseteq> \\<^bold>G \\<phi> \\<Longrightarrow>\n  accepting_pair\\<^sub>G\\<^sub>R (delta \\<Sigma>) (initial \\<phi>)\n   (M_fin ?\\<pi>19 \\<union>\n    \\<Union>\n     {Acc_fin \\<Sigma> ?\\<pi>19 \\<chi> |\\<chi>. \\<chi> \\<in> dom ?\\<pi>19},\n    {Acc_inf ?\\<pi>19 \\<chi> |\\<chi>. \\<chi> \\<in> dom ?\\<pi>19})\n   w =\n  accepting_pair\\<^sub>G\\<^sub>R_LTS\n   (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n     (initial\\<^sub>C \\<phi>))\n   (initial\\<^sub>C \\<phi>)\n   (({t. M_fin\\<^sub>C \\<phi> (mapping.Mapping ?\\<pi>19) t} \\<union>\n     {t. \\<exists>\\<chi>\\<in>dom ?\\<pi>19.\n            Acc_fin\\<^sub>C \\<Sigma> (mapping.Mapping ?\\<pi>19) \\<chi>\n             t}) \\<inter>\n    reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n     (initial\\<^sub>C \\<phi>),\n    (\\<lambda>I.\n        I \\<inter>\n        reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n         (initial\\<^sub>C \\<phi>)) `\n    {{t. Acc_inf\\<^sub>C (mapping.Mapping ?\\<pi>19) \\<chi> t} |\\<chi>.\n     \\<chi> \\<in> dom ?\\<pi>19})\n   w\n\ngoal (2 subgoals):\n 1. accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w\n 2. accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w", "note X = this"], ["proof (state)\nthis:\n  dom ?\\<pi>19 \\<subseteq> \\<^bold>G \\<phi> \\<Longrightarrow>\n  accepting_pair\\<^sub>G\\<^sub>R (delta \\<Sigma>) (initial \\<phi>)\n   (M_fin ?\\<pi>19 \\<union>\n    \\<Union>\n     {Acc_fin \\<Sigma> ?\\<pi>19 \\<chi> |\\<chi>. \\<chi> \\<in> dom ?\\<pi>19},\n    {Acc_inf ?\\<pi>19 \\<chi> |\\<chi>. \\<chi> \\<in> dom ?\\<pi>19})\n   w =\n  accepting_pair\\<^sub>G\\<^sub>R_LTS\n   (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n     (initial\\<^sub>C \\<phi>))\n   (initial\\<^sub>C \\<phi>)\n   (({t. M_fin\\<^sub>C \\<phi> (mapping.Mapping ?\\<pi>19) t} \\<union>\n     {t. \\<exists>\\<chi>\\<in>dom ?\\<pi>19.\n            Acc_fin\\<^sub>C \\<Sigma> (mapping.Mapping ?\\<pi>19) \\<chi>\n             t}) \\<inter>\n    reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n     (initial\\<^sub>C \\<phi>),\n    (\\<lambda>I.\n        I \\<inter>\n        reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n         (initial\\<^sub>C \\<phi>)) `\n    {{t. Acc_inf\\<^sub>C (mapping.Mapping ?\\<pi>19) \\<chi> t} |\\<chi>.\n     \\<chi> \\<in> dom ?\\<pi>19})\n   w\n\ngoal (2 subgoals):\n 1. accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w\n 2. accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w", "{"], ["proof (state)\nthis:\n  dom ?\\<pi>19 \\<subseteq> \\<^bold>G \\<phi> \\<Longrightarrow>\n  accepting_pair\\<^sub>G\\<^sub>R (delta \\<Sigma>) (initial \\<phi>)\n   (M_fin ?\\<pi>19 \\<union>\n    \\<Union>\n     {Acc_fin \\<Sigma> ?\\<pi>19 \\<chi> |\\<chi>. \\<chi> \\<in> dom ?\\<pi>19},\n    {Acc_inf ?\\<pi>19 \\<chi> |\\<chi>. \\<chi> \\<in> dom ?\\<pi>19})\n   w =\n  accepting_pair\\<^sub>G\\<^sub>R_LTS\n   (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n     (initial\\<^sub>C \\<phi>))\n   (initial\\<^sub>C \\<phi>)\n   (({t. M_fin\\<^sub>C \\<phi> (mapping.Mapping ?\\<pi>19) t} \\<union>\n     {t. \\<exists>\\<chi>\\<in>dom ?\\<pi>19.\n            Acc_fin\\<^sub>C \\<Sigma> (mapping.Mapping ?\\<pi>19) \\<chi>\n             t}) \\<inter>\n    reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n     (initial\\<^sub>C \\<phi>),\n    (\\<lambda>I.\n        I \\<inter>\n        reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n         (initial\\<^sub>C \\<phi>)) `\n    {{t. Acc_inf\\<^sub>C (mapping.Mapping ?\\<pi>19) \\<chi> t} |\\<chi>.\n     \\<chi> \\<in> dom ?\\<pi>19})\n   w\n\ngoal (2 subgoals):\n 1. accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w\n 2. accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w", "assume ?lhs"], ["proof (state)\nthis:\n  accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w\n\ngoal (2 subgoals):\n 1. accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w\n 2. accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w", "then"], ["proof (chain)\npicking this:\n  accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w", "obtain \\<pi> where 1: \"dom \\<pi> \\<subseteq> \\<^bold>G \\<phi>\" \n      and 2: \"\\<And>\\<chi>. \\<chi> \\<in> dom \\<pi> \\<Longrightarrow> the (\\<pi> \\<chi>) < max_rank_of \\<Sigma> \\<chi>\"\n      and 3: \"accepting_pair\\<^sub>G\\<^sub>R (delta \\<Sigma>) (initial \\<phi>) (M_fin \\<pi> \\<union> \\<Union>{Acc_fin \\<Sigma> \\<pi> \\<chi> |\\<chi>. \\<chi> \\<in> dom \\<pi>}, {Acc_inf \\<pi> \\<chi> |\\<chi>. \\<chi> \\<in> dom \\<pi>}) w\""], ["proof (prove)\nusing this:\n  accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w\n\ngoal (1 subgoal):\n 1. (\\<And>\\<pi>.\n        \\<lbrakk>dom \\<pi> \\<subseteq> \\<^bold>G \\<phi>;\n         \\<And>\\<chi>.\n            \\<chi> \\<in> dom \\<pi> \\<Longrightarrow>\n            the (\\<pi> \\<chi>) < max_rank_of \\<Sigma> \\<chi>;\n         accepting_pair\\<^sub>G\\<^sub>R (delta \\<Sigma>) (initial \\<phi>)\n          (M_fin \\<pi> \\<union>\n           \\<Union>\n            {Acc_fin \\<Sigma> \\<pi> \\<chi> |\\<chi>. \\<chi> \\<in> dom \\<pi>},\n           {Acc_inf \\<pi> \\<chi> |\\<chi>. \\<chi> \\<in> dom \\<pi>})\n          w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  dom \\<pi> \\<subseteq> \\<^bold>G \\<phi>\n  ?\\<chi>17 \\<in> dom \\<pi> \\<Longrightarrow>\n  the (\\<pi> ?\\<chi>17) < max_rank_of \\<Sigma> ?\\<chi>17\n  accepting_pair\\<^sub>G\\<^sub>R (delta \\<Sigma>) (initial \\<phi>)\n   (M_fin \\<pi> \\<union>\n    \\<Union>\n     {Acc_fin \\<Sigma> \\<pi> \\<chi> |\\<chi>. \\<chi> \\<in> dom \\<pi>},\n    {Acc_inf \\<pi> \\<chi> |\\<chi>. \\<chi> \\<in> dom \\<pi>})\n   w\n\ngoal (2 subgoals):\n 1. accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w\n 2. accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w", "define \\<pi>' where \"\\<pi>' = Mapping.Mapping \\<pi>\""], ["proof (state)\nthis:\n  \\<pi>' = mapping.Mapping \\<pi>\n\ngoal (2 subgoals):\n 1. accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w\n 2. accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w", "have \"dom \\<pi> = Mapping.keys \\<pi>'\" and \"\\<pi> = Mapping.lookup \\<pi>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom \\<pi> = Mapping.keys \\<pi>' &&& \\<pi> = Mapping.lookup \\<pi>'", "by (simp_all add: keys.abs_eq lookup.abs_eq \\<pi>'_def)"], ["proof (state)\nthis:\n  dom \\<pi> = Mapping.keys \\<pi>'\n  \\<pi> = Mapping.lookup \\<pi>'\n\ngoal (2 subgoals):\n 1. accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w\n 2. accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w", "have acc_pair_LTS: \"accepting_pair\\<^sub>G\\<^sub>R_LTS ?reach\\<^sub>C ?q\\<^sub>0\\<^sub>C (({t. M_fin\\<^sub>C \\<phi> \\<pi>' t} \\<union> {t. \\<exists>\\<chi> \\<in> Mapping.keys \\<pi>'. Acc_fin\\<^sub>C \\<Sigma> \\<pi>' \\<chi> t}) \\<inter> ?reach\\<^sub>C,\n        (\\<lambda>I. I \\<inter> ?reach\\<^sub>C) ` {{t. Acc_inf\\<^sub>C \\<pi>' \\<chi> t} | \\<chi>. \\<chi> \\<in> Mapping.keys \\<pi>'}) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. accepting_pair\\<^sub>G\\<^sub>R_LTS\n     (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n       (initial\\<^sub>C \\<phi>))\n     (initial\\<^sub>C \\<phi>)\n     (({t. M_fin\\<^sub>C \\<phi> \\<pi>' t} \\<union>\n       {t. \\<exists>\\<chi>\\<in>Mapping.keys \\<pi>'.\n              Acc_fin\\<^sub>C \\<Sigma> \\<pi>' \\<chi> t}) \\<inter>\n      reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n       (initial\\<^sub>C \\<phi>),\n      (\\<lambda>I.\n          I \\<inter>\n          reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n           (initial\\<^sub>C \\<phi>)) `\n      {{t. Acc_inf\\<^sub>C \\<pi>' \\<chi> t} |\\<chi>.\n       \\<chi> \\<in> Mapping.keys \\<pi>'})\n     w", "using 3"], ["proof (prove)\nusing this:\n  accepting_pair\\<^sub>G\\<^sub>R (delta \\<Sigma>) (initial \\<phi>)\n   (M_fin \\<pi> \\<union>\n    \\<Union>\n     {Acc_fin \\<Sigma> \\<pi> \\<chi> |\\<chi>. \\<chi> \\<in> dom \\<pi>},\n    {Acc_inf \\<pi> \\<chi> |\\<chi>. \\<chi> \\<in> dom \\<pi>})\n   w\n\ngoal (1 subgoal):\n 1. accepting_pair\\<^sub>G\\<^sub>R_LTS\n     (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n       (initial\\<^sub>C \\<phi>))\n     (initial\\<^sub>C \\<phi>)\n     (({t. M_fin\\<^sub>C \\<phi> \\<pi>' t} \\<union>\n       {t. \\<exists>\\<chi>\\<in>Mapping.keys \\<pi>'.\n              Acc_fin\\<^sub>C \\<Sigma> \\<pi>' \\<chi> t}) \\<inter>\n      reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n       (initial\\<^sub>C \\<phi>),\n      (\\<lambda>I.\n          I \\<inter>\n          reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n           (initial\\<^sub>C \\<phi>)) `\n      {{t. Acc_inf\\<^sub>C \\<pi>' \\<chi> t} |\\<chi>.\n       \\<chi> \\<in> Mapping.keys \\<pi>'})\n     w", "unfolding X[OF 1]"], ["proof (prove)\nusing this:\n  accepting_pair\\<^sub>G\\<^sub>R_LTS\n   (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n     (initial\\<^sub>C \\<phi>))\n   (initial\\<^sub>C \\<phi>)\n   ((Collect (M_fin\\<^sub>C \\<phi> (mapping.Mapping \\<pi>)) \\<union>\n     {t. \\<exists>\\<chi>\\<in>dom \\<pi>.\n            Acc_fin\\<^sub>C \\<Sigma> (mapping.Mapping \\<pi>) \\<chi>\n             t}) \\<inter>\n    reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n     (initial\\<^sub>C \\<phi>),\n    (\\<lambda>I.\n        I \\<inter>\n        reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n         (initial\\<^sub>C \\<phi>)) `\n    {Collect (Acc_inf\\<^sub>C (mapping.Mapping \\<pi>) \\<chi>) |\\<chi>.\n     \\<chi> \\<in> dom \\<pi>})\n   w\n\ngoal (1 subgoal):\n 1. accepting_pair\\<^sub>G\\<^sub>R_LTS\n     (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n       (initial\\<^sub>C \\<phi>))\n     (initial\\<^sub>C \\<phi>)\n     (({t. M_fin\\<^sub>C \\<phi> \\<pi>' t} \\<union>\n       {t. \\<exists>\\<chi>\\<in>Mapping.keys \\<pi>'.\n              Acc_fin\\<^sub>C \\<Sigma> \\<pi>' \\<chi> t}) \\<inter>\n      reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n       (initial\\<^sub>C \\<phi>),\n      (\\<lambda>I.\n          I \\<inter>\n          reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n           (initial\\<^sub>C \\<phi>)) `\n      {{t. Acc_inf\\<^sub>C \\<pi>' \\<chi> t} |\\<chi>.\n       \\<chi> \\<in> Mapping.keys \\<pi>'})\n     w", "unfolding \\<open>dom \\<pi> = Mapping.keys \\<pi>'\\<close> \\<pi>'_def[symmetric]"], ["proof (prove)\nusing this:\n  accepting_pair\\<^sub>G\\<^sub>R_LTS\n   (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n     (initial\\<^sub>C \\<phi>))\n   (initial\\<^sub>C \\<phi>)\n   ((Collect (M_fin\\<^sub>C \\<phi> \\<pi>') \\<union>\n     {t. \\<exists>\\<chi>\\<in>Mapping.keys \\<pi>'.\n            Acc_fin\\<^sub>C \\<Sigma> \\<pi>' \\<chi> t}) \\<inter>\n    reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n     (initial\\<^sub>C \\<phi>),\n    (\\<lambda>I.\n        I \\<inter>\n        reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n         (initial\\<^sub>C \\<phi>)) `\n    {Collect (Acc_inf\\<^sub>C \\<pi>' \\<chi>) |\\<chi>.\n     \\<chi> \\<in> Mapping.keys \\<pi>'})\n   w\n\ngoal (1 subgoal):\n 1. accepting_pair\\<^sub>G\\<^sub>R_LTS\n     (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n       (initial\\<^sub>C \\<phi>))\n     (initial\\<^sub>C \\<phi>)\n     (({t. M_fin\\<^sub>C \\<phi> \\<pi>' t} \\<union>\n       {t. \\<exists>\\<chi>\\<in>Mapping.keys \\<pi>'.\n              Acc_fin\\<^sub>C \\<Sigma> \\<pi>' \\<chi> t}) \\<inter>\n      reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n       (initial\\<^sub>C \\<phi>),\n      (\\<lambda>I.\n          I \\<inter>\n          reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n           (initial\\<^sub>C \\<phi>)) `\n      {{t. Acc_inf\\<^sub>C \\<pi>' \\<chi> t} |\\<chi>.\n       \\<chi> \\<in> Mapping.keys \\<pi>'})\n     w", "by simp"], ["proof (state)\nthis:\n  accepting_pair\\<^sub>G\\<^sub>R_LTS\n   (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n     (initial\\<^sub>C \\<phi>))\n   (initial\\<^sub>C \\<phi>)\n   (({t. M_fin\\<^sub>C \\<phi> \\<pi>' t} \\<union>\n     {t. \\<exists>\\<chi>\\<in>Mapping.keys \\<pi>'.\n            Acc_fin\\<^sub>C \\<Sigma> \\<pi>' \\<chi> t}) \\<inter>\n    reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n     (initial\\<^sub>C \\<phi>),\n    (\\<lambda>I.\n        I \\<inter>\n        reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n         (initial\\<^sub>C \\<phi>)) `\n    {{t. Acc_inf\\<^sub>C \\<pi>' \\<chi> t} |\\<chi>.\n     \\<chi> \\<in> Mapping.keys \\<pi>'})\n   w\n\ngoal (2 subgoals):\n 1. accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w\n 2. accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w", "show ?rhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w", "apply (unfold ltl_to_generalized_rabin\\<^sub>C.simps Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. accept\\<^sub>G\\<^sub>R_LTS\n     (reachable_transitions\\<^sub>C \\<Sigma>' \\<phi>,\n      initial\\<^sub>C \\<phi>,\n      (\\<lambda>\\<pi>.\n          (Set.filter\n            (\\<lambda>t.\n                M_fin\\<^sub>C \\<phi> \\<pi> t \\<or>\n                (\\<exists>\\<chi>\\<in>Mapping.keys \\<pi>.\n                    Acc_fin\\<^sub>C (set \\<Sigma>') \\<pi> \\<chi> t))\n            (reachable_transitions\\<^sub>C \\<Sigma>' \\<phi>),\n           (\\<lambda>\\<chi>.\n               Set.filter (Acc_inf\\<^sub>C \\<pi> \\<chi>)\n                (reachable_transitions\\<^sub>C \\<Sigma>' \\<phi>)) `\n           Mapping.keys \\<pi>)) `\n      mappings\\<^sub>C \\<Sigma>' \\<phi>)\n     w", "apply (intro accept\\<^sub>G\\<^sub>R_LTS_I)"], ["proof (prove)\ngoal (2 subgoals):\n 1. accepting_pair\\<^sub>G\\<^sub>R_LTS\n     (reachable_transitions\\<^sub>C \\<Sigma>' \\<phi>)\n     (initial\\<^sub>C \\<phi>) (?F, ?\\<I>) w\n 2. (?F, ?\\<I>)\n    \\<in> (\\<lambda>\\<pi>.\n              (Set.filter\n                (\\<lambda>t.\n                    M_fin\\<^sub>C \\<phi> \\<pi> t \\<or>\n                    (\\<exists>\\<chi>\\<in>Mapping.keys \\<pi>.\n                        Acc_fin\\<^sub>C (set \\<Sigma>') \\<pi> \\<chi> t))\n                (reachable_transitions\\<^sub>C \\<Sigma>' \\<phi>),\n               (\\<lambda>\\<chi>.\n                   Set.filter (Acc_inf\\<^sub>C \\<pi> \\<chi>)\n                    (reachable_transitions\\<^sub>C \\<Sigma>' \\<phi>)) `\n               Mapping.keys \\<pi>)) `\n          mappings\\<^sub>C \\<Sigma>' \\<phi>", "apply (insert acc_pair_LTS; auto simp add: assms[symmetric] mappings\\<^sub>C_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (({t. M_fin\\<^sub>C \\<phi> \\<pi>' t} \\<union>\n      {t. \\<exists>\\<chi>\\<in>Mapping.keys \\<pi>'.\n             Acc_fin\\<^sub>C \\<Sigma> \\<pi>' \\<chi> t}) \\<inter>\n     reach\\<^sub>t \\<Sigma>\n      (\\<lambda>(q\\<^sub>1, q\\<^sub>2) \\<nu>.\n          (\\<delta> q\\<^sub>1 \\<nu>,\n           \\<up>\\<Delta>\\<^sub>\\<times>\n            (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n             theG)\n            q\\<^sub>2 \\<nu>))\n      (q\\<^sub>0 \\<phi>,\n       Mapping.tabulate (G_list \\<phi>)\n        (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG)),\n     (\\<lambda>x.\n         x \\<inter>\n         reach\\<^sub>t \\<Sigma>\n          (\\<lambda>(q\\<^sub>1, q\\<^sub>2) \\<nu>.\n              (\\<delta> q\\<^sub>1 \\<nu>,\n               \\<up>\\<Delta>\\<^sub>\\<times>\n                (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ>\n                 q\\<^sub>0\\<^sub>M \\<circ>\n                 theG)\n                q\\<^sub>2 \\<nu>))\n          (q\\<^sub>0 \\<phi>,\n           Mapping.tabulate (G_list \\<phi>)\n            (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))) `\n     {{t. Acc_inf\\<^sub>C \\<pi>' \\<chi> t} |\\<chi>.\n      \\<chi> \\<in> Mapping.keys \\<pi>'})\n    \\<in> (\\<lambda>\\<pi>.\n              (Set.filter\n                (\\<lambda>t.\n                    M_fin\\<^sub>C \\<phi> \\<pi> t \\<or>\n                    (\\<exists>\\<chi>\\<in>Mapping.keys \\<pi>.\n                        Acc_fin\\<^sub>C (set \\<Sigma>') \\<pi> \\<chi> t))\n                (reachable_transitions\\<^sub>C \\<Sigma>' \\<phi>),\n               (\\<lambda>\\<chi>.\n                   Set.filter (Acc_inf\\<^sub>C \\<pi> \\<chi>)\n                    (reachable_transitions\\<^sub>C \\<Sigma>' \\<phi>)) `\n               Mapping.keys \\<pi>)) `\n          mappings\\<^sub>C \\<Sigma>' \\<phi>", "apply (insert 1 2; unfold  \\<open>dom \\<pi> = Mapping.keys \\<pi>'\\<close>; unfold \\<open>\\<pi> = Mapping.lookup \\<pi>'\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Mapping.keys \\<pi>' \\<subseteq> \\<^bold>G \\<phi>;\n     \\<And>\\<chi>.\n        \\<chi> \\<in> Mapping.keys \\<pi>' \\<Longrightarrow>\n        the (Mapping.lookup \\<pi>' \\<chi>)\n        < max_rank_of \\<Sigma> \\<chi>\\<rbrakk>\n    \\<Longrightarrow> (({t. M_fin\\<^sub>C \\<phi> \\<pi>' t} \\<union>\n                        {t. \\<exists>\\<chi>\\<in>Mapping.keys \\<pi>'.\n                               Acc_fin\\<^sub>C \\<Sigma> \\<pi>' \\<chi>\n                                t}) \\<inter>\n                       reach\\<^sub>t \\<Sigma>\n                        (\\<lambda>(q\\<^sub>1, q\\<^sub>2) \\<nu>.\n                            (\\<delta> q\\<^sub>1 \\<nu>,\n                             \\<up>\\<Delta>\\<^sub>\\<times>\n                              (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ>\n                               q\\<^sub>0\\<^sub>M \\<circ>\n                               theG)\n                              q\\<^sub>2 \\<nu>))\n                        (q\\<^sub>0 \\<phi>,\n                         Mapping.tabulate (G_list \\<phi>)\n                          (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG)),\n                       (\\<lambda>x.\n                           x \\<inter>\n                           reach\\<^sub>t \\<Sigma>\n                            (\\<lambda>(q\\<^sub>1, q\\<^sub>2) \\<nu>.\n                                (\\<delta> q\\<^sub>1 \\<nu>,\n                                 \\<up>\\<Delta>\\<^sub>\\<times>\n                                  (nxt \\<Sigma> \\<delta>\\<^sub>M \\<circ>\n                                   q\\<^sub>0\\<^sub>M \\<circ>\n                                   theG)\n                                  q\\<^sub>2 \\<nu>))\n                            (q\\<^sub>0 \\<phi>,\n                             Mapping.tabulate (G_list \\<phi>)\n                              (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n                               theG))) `\n                       {{t. Acc_inf\\<^sub>C \\<pi>' \\<chi> t} |\\<chi>.\n                        \\<chi> \\<in> Mapping.keys \\<pi>'})\n                      \\<in> (\\<lambda>\\<pi>.\n                                (Set.filter\n                                  (\\<lambda>t.\nM_fin\\<^sub>C \\<phi> \\<pi> t \\<or>\n(\\<exists>\\<chi>\\<in>Mapping.keys \\<pi>.\n    Acc_fin\\<^sub>C (set \\<Sigma>') \\<pi> \\<chi> t))\n                                  (reachable_transitions\\<^sub>C \\<Sigma>'\n                                    \\<phi>),\n                                 (\\<lambda>\\<chi>.\n                                     Set.filter\n(Acc_inf\\<^sub>C \\<pi> \\<chi>)\n(reachable_transitions\\<^sub>C \\<Sigma>' \\<phi>)) `\n                                 Mapping.keys \\<pi>)) `\n                            mappings\\<^sub>C \\<Sigma>' \\<phi>", "by (auto simp add: assms[symmetric] Set.filter_def image_def mappings\\<^sub>C_def)"], ["proof (state)\nthis:\n  accept\\<^sub>G\\<^sub>R_LTS\n   (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w\n\ngoal (1 subgoal):\n 1. accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w", "}"], ["proof (state)\nthis:\n  accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w \\<Longrightarrow>\n  accept\\<^sub>G\\<^sub>R_LTS\n   (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w\n\ngoal (1 subgoal):\n 1. accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w", "moreover"], ["proof (state)\nthis:\n  accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w \\<Longrightarrow>\n  accept\\<^sub>G\\<^sub>R_LTS\n   (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w\n\ngoal (1 subgoal):\n 1. accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w", "{"], ["proof (state)\nthis:\n  accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w \\<Longrightarrow>\n  accept\\<^sub>G\\<^sub>R_LTS\n   (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w\n\ngoal (1 subgoal):\n 1. accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w", "assume ?rhs"], ["proof (state)\nthis:\n  accept\\<^sub>G\\<^sub>R_LTS\n   (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w\n\ngoal (1 subgoal):\n 1. accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w", "obtain Fin Inf where \"(Fin, Inf) \\<in> snd (snd (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>))\"\n      and 4: \"accepting_pair\\<^sub>G\\<^sub>R_LTS ?reach\\<^sub>C (initial\\<^sub>C \\<phi>) (Fin, Inf) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Fin Inf.\n        \\<lbrakk>(Fin, Inf)\n                 \\<in> snd (snd (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>'\n                                  \\<phi>));\n         accepting_pair\\<^sub>G\\<^sub>R_LTS\n          (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n            (initial\\<^sub>C \\<phi>))\n          (initial\\<^sub>C \\<phi>) (Fin, Inf) w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using accept\\<^sub>G\\<^sub>R_LTS_E[OF \\<open>?rhs\\<close>]"], ["proof (prove)\nusing this:\n  (\\<And>F I.\n      \\<lbrakk>(F, I)\n               \\<in> snd (snd (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>'\n                                \\<phi>));\n       accepting_pair\\<^sub>G\\<^sub>R_LTS\n        (fst (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>))\n        (fst (snd (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>)))\n        (F, I) w\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>Fin Inf.\n        \\<lbrakk>(Fin, Inf)\n                 \\<in> snd (snd (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>'\n                                  \\<phi>));\n         accepting_pair\\<^sub>G\\<^sub>R_LTS\n          (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n            (initial\\<^sub>C \\<phi>))\n          (initial\\<^sub>C \\<phi>) (Fin, Inf) w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (simp add: Let_def assms del: accept\\<^sub>G\\<^sub>R_LTS.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Fin Inf.\n                \\<lbrakk>(Fin, Inf)\n                         \\<in> (\\<lambda>x.\n                                   (Set.filter\n                                     (\\<lambda>t.\n   M_fin\\<^sub>C \\<phi> x t \\<or>\n   (\\<exists>\\<chi>\\<in>Mapping.keys x.\n       Acc_fin\\<^sub>C (set \\<Sigma>') x \\<chi> t))\n                                     (reach\\<^sub>t (set \\<Sigma>')\n (\\<lambda>(q\\<^sub>1, q\\<^sub>2) \\<nu>.\n     (\\<delta> q\\<^sub>1 \\<nu>,\n      \\<up>\\<Delta>\\<^sub>\\<times>\n       (nxt (set \\<Sigma>') \\<delta>\\<^sub>M \\<circ>\n        q\\<^sub>0\\<^sub>M \\<circ>\n        theG)\n       q\\<^sub>2 \\<nu>))\n (q\\<^sub>0 \\<phi>,\n  Mapping.tabulate (G_list \\<phi>)\n   (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))),\n                                    (\\<lambda>\\<chi>.\n  Set.filter (Acc_inf\\<^sub>C x \\<chi>)\n   (reach\\<^sub>t (set \\<Sigma>')\n     (\\<lambda>(q\\<^sub>1, q\\<^sub>2) \\<nu>.\n         (\\<delta> q\\<^sub>1 \\<nu>,\n          \\<up>\\<Delta>\\<^sub>\\<times>\n           (nxt (set \\<Sigma>') \\<delta>\\<^sub>M \\<circ>\n            q\\<^sub>0\\<^sub>M \\<circ>\n            theG)\n           q\\<^sub>2 \\<nu>))\n     (q\\<^sub>0 \\<phi>,\n      Mapping.tabulate (G_list \\<phi>)\n       (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG)))) `\n                                    Mapping.keys x)) `\n                               mappings\\<^sub>C \\<Sigma>' \\<phi>;\n                 accepting_pair\\<^sub>G\\<^sub>R_LTS\n                  (reach\\<^sub>t (set \\<Sigma>')\n                    (\\<lambda>(q\\<^sub>1, q\\<^sub>2) \\<nu>.\n                        (\\<delta> q\\<^sub>1 \\<nu>,\n                         \\<up>\\<Delta>\\<^sub>\\<times>\n                          (nxt (set \\<Sigma>') \\<delta>\\<^sub>M \\<circ>\n                           q\\<^sub>0\\<^sub>M \\<circ>\n                           theG)\n                          q\\<^sub>2 \\<nu>))\n                    (q\\<^sub>0 \\<phi>,\n                     Mapping.tabulate (G_list \\<phi>)\n                      (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG)))\n                  (q\\<^sub>0 \\<phi>,\n                   Mapping.tabulate (G_list \\<phi>)\n                    (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n                  (Fin, Inf) w\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>thesis.\n        (\\<And>F I.\n            \\<lbrakk>(F, I)\n                     \\<in> (\\<lambda>x.\n                               (Set.filter\n                                 (\\<lambda>t.\n                                     M_fin\\<^sub>C \\<phi> x t \\<or>\n                                     (\\<exists>\\<chi>\\<in>Mapping.keys x.\n   Acc_fin\\<^sub>C (set \\<Sigma>') x \\<chi> t))\n                                 (reach\\<^sub>t (set \\<Sigma>')\n                                   (\\<lambda>(q\\<^sub>1, q\\<^sub>2) \\<nu>.\n (\\<delta> q\\<^sub>1 \\<nu>,\n  \\<up>\\<Delta>\\<^sub>\\<times>\n   (nxt (set \\<Sigma>') \\<delta>\\<^sub>M \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\n    theG)\n   q\\<^sub>2 \\<nu>))\n                                   (q\\<^sub>0 \\<phi>,\n                                    Mapping.tabulate (G_list \\<phi>)\n                                     (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ>\ntheG))),\n                                (\\<lambda>\\<chi>.\n                                    Set.filter (Acc_inf\\<^sub>C x \\<chi>)\n                                     (reach\\<^sub>t (set \\<Sigma>')\n (\\<lambda>(q\\<^sub>1, q\\<^sub>2) \\<nu>.\n     (\\<delta> q\\<^sub>1 \\<nu>,\n      \\<up>\\<Delta>\\<^sub>\\<times>\n       (nxt (set \\<Sigma>') \\<delta>\\<^sub>M \\<circ>\n        q\\<^sub>0\\<^sub>M \\<circ>\n        theG)\n       q\\<^sub>2 \\<nu>))\n (q\\<^sub>0 \\<phi>,\n  Mapping.tabulate (G_list \\<phi>)\n   (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG)))) `\n                                Mapping.keys x)) `\n                           mappings\\<^sub>C \\<Sigma>' \\<phi>;\n             accepting_pair\\<^sub>G\\<^sub>R_LTS\n              (reach\\<^sub>t (set \\<Sigma>')\n                (\\<lambda>(q\\<^sub>1, q\\<^sub>2) \\<nu>.\n                    (\\<delta> q\\<^sub>1 \\<nu>,\n                     \\<up>\\<Delta>\\<^sub>\\<times>\n                      (nxt (set \\<Sigma>') \\<delta>\\<^sub>M \\<circ>\n                       q\\<^sub>0\\<^sub>M \\<circ>\n                       theG)\n                      q\\<^sub>2 \\<nu>))\n                (q\\<^sub>0 \\<phi>,\n                 Mapping.tabulate (G_list \\<phi>)\n                  (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG)))\n              (q\\<^sub>0 \\<phi>,\n               Mapping.tabulate (G_list \\<phi>)\n                (init \\<circ> q\\<^sub>0\\<^sub>M \\<circ> theG))\n              (F, I) w\\<rbrakk>\n            \\<Longrightarrow> thesis) \\<Longrightarrow>\n        thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  (Fin, Inf)\n  \\<in> snd (snd (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>))\n  accepting_pair\\<^sub>G\\<^sub>R_LTS\n   (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n     (initial\\<^sub>C \\<phi>))\n   (initial\\<^sub>C \\<phi>) (Fin, Inf) w\n\ngoal (1 subgoal):\n 1. accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w", "then"], ["proof (chain)\npicking this:\n  (Fin, Inf)\n  \\<in> snd (snd (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>))\n  accepting_pair\\<^sub>G\\<^sub>R_LTS\n   (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n     (initial\\<^sub>C \\<phi>))\n   (initial\\<^sub>C \\<phi>) (Fin, Inf) w", "obtain \\<pi> where Y: \"(Fin, Inf) = (Set.filter (\\<lambda>t. M_fin\\<^sub>C \\<phi> \\<pi> t \\<or> (\\<exists>\\<chi> \\<in> Mapping.keys \\<pi>. Acc_fin\\<^sub>C \\<Sigma> \\<pi> \\<chi> t)) ?reach\\<^sub>C,\n        (\\<lambda>\\<chi>. Set.filter (Acc_inf\\<^sub>C \\<pi> \\<chi>) ?reach\\<^sub>C) ` (Mapping.keys \\<pi>))\"\n        and 1: \"Mapping.keys \\<pi> \\<subseteq> \\<^bold>G \\<phi>\" and 2: \"\\<And>\\<chi>. \\<chi> \\<in> Mapping.keys \\<pi> \\<Longrightarrow> the (Mapping.lookup \\<pi> \\<chi>) < max_rank_of \\<Sigma> \\<chi>\""], ["proof (prove)\nusing this:\n  (Fin, Inf)\n  \\<in> snd (snd (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>))\n  accepting_pair\\<^sub>G\\<^sub>R_LTS\n   (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n     (initial\\<^sub>C \\<phi>))\n   (initial\\<^sub>C \\<phi>) (Fin, Inf) w\n\ngoal (1 subgoal):\n 1. (\\<And>\\<pi>.\n        \\<lbrakk>(Fin, Inf) =\n                 (Set.filter\n                   (\\<lambda>t.\n                       M_fin\\<^sub>C \\<phi> \\<pi> t \\<or>\n                       (\\<exists>\\<chi>\\<in>Mapping.keys \\<pi>.\n                           Acc_fin\\<^sub>C \\<Sigma> \\<pi> \\<chi> t))\n                   (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n                     (initial\\<^sub>C \\<phi>)),\n                  (\\<lambda>\\<chi>.\n                      Set.filter (Acc_inf\\<^sub>C \\<pi> \\<chi>)\n                       (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n                         (initial\\<^sub>C \\<phi>))) `\n                  Mapping.keys \\<pi>);\n         Mapping.keys \\<pi> \\<subseteq> \\<^bold>G \\<phi>;\n         \\<And>\\<chi>.\n            \\<chi> \\<in> Mapping.keys \\<pi> \\<Longrightarrow>\n            the (Mapping.lookup \\<pi> \\<chi>)\n            < max_rank_of \\<Sigma> \\<chi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding ltl_to_generalized_rabin\\<^sub>C.simps Let_def fst_conv snd_conv mappings\\<^sub>C_def assms reachable_transitions\\<^sub>C_simp max_rank_of\\<^sub>C_simp"], ["proof (prove)\nusing this:\n  (Fin, Inf)\n  \\<in> (\\<lambda>\\<pi>.\n            (Set.filter\n              (\\<lambda>t.\n                  M_fin\\<^sub>C \\<phi> \\<pi> t \\<or>\n                  (\\<exists>\\<chi>\\<in>Mapping.keys \\<pi>.\n                      Acc_fin\\<^sub>C (set \\<Sigma>') \\<pi> \\<chi> t))\n              (reach\\<^sub>t (set \\<Sigma>') (delta\\<^sub>C (set \\<Sigma>'))\n                (initial\\<^sub>C \\<phi>)),\n             (\\<lambda>\\<chi>.\n                 Set.filter (Acc_inf\\<^sub>C \\<pi> \\<chi>)\n                  (reach\\<^sub>t (set \\<Sigma>')\n                    (delta\\<^sub>C (set \\<Sigma>'))\n                    (initial\\<^sub>C \\<phi>))) `\n             Mapping.keys \\<pi>)) `\n        {\\<pi>.\n         Mapping.keys \\<pi> \\<subseteq> \\<^bold>G \\<phi> \\<and>\n         (\\<forall>\\<chi>\\<in>Mapping.keys \\<pi>.\n             the (Mapping.lookup \\<pi> \\<chi>)\n             < max_rank_of (set \\<Sigma>') \\<chi>)}\n  accepting_pair\\<^sub>G\\<^sub>R_LTS\n   (reach\\<^sub>t (set \\<Sigma>') (delta\\<^sub>C (set \\<Sigma>'))\n     (initial\\<^sub>C \\<phi>))\n   (initial\\<^sub>C \\<phi>) (Fin, Inf) w\n\ngoal (1 subgoal):\n 1. (\\<And>\\<pi>.\n        \\<lbrakk>(Fin, Inf) =\n                 (Set.filter\n                   (\\<lambda>t.\n                       M_fin\\<^sub>C \\<phi> \\<pi> t \\<or>\n                       (\\<exists>\\<chi>\\<in>Mapping.keys \\<pi>.\n                           Acc_fin\\<^sub>C (set \\<Sigma>') \\<pi> \\<chi> t))\n                   (reach\\<^sub>t (set \\<Sigma>')\n                     (delta\\<^sub>C (set \\<Sigma>'))\n                     (initial\\<^sub>C \\<phi>)),\n                  (\\<lambda>\\<chi>.\n                      Set.filter (Acc_inf\\<^sub>C \\<pi> \\<chi>)\n                       (reach\\<^sub>t (set \\<Sigma>')\n                         (delta\\<^sub>C (set \\<Sigma>'))\n                         (initial\\<^sub>C \\<phi>))) `\n                  Mapping.keys \\<pi>);\n         Mapping.keys \\<pi> \\<subseteq> \\<^bold>G \\<phi>;\n         \\<And>\\<chi>.\n            \\<chi> \\<in> Mapping.keys \\<pi> \\<Longrightarrow>\n            the (Mapping.lookup \\<pi> \\<chi>)\n            < max_rank_of (set \\<Sigma>') \\<chi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (Fin, Inf) =\n  (Set.filter\n    (\\<lambda>t.\n        M_fin\\<^sub>C \\<phi> \\<pi> t \\<or>\n        (\\<exists>\\<chi>\\<in>Mapping.keys \\<pi>.\n            Acc_fin\\<^sub>C \\<Sigma> \\<pi> \\<chi> t))\n    (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n      (initial\\<^sub>C \\<phi>)),\n   (\\<lambda>\\<chi>.\n       Set.filter (Acc_inf\\<^sub>C \\<pi> \\<chi>)\n        (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n          (initial\\<^sub>C \\<phi>))) `\n   Mapping.keys \\<pi>)\n  Mapping.keys \\<pi> \\<subseteq> \\<^bold>G \\<phi>\n  ?\\<chi>17 \\<in> Mapping.keys \\<pi> \\<Longrightarrow>\n  the (Mapping.lookup \\<pi> ?\\<chi>17) < max_rank_of \\<Sigma> ?\\<chi>17\n\ngoal (1 subgoal):\n 1. accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w", "define \\<pi>' where \"\\<pi>' = Mapping.rep \\<pi>\""], ["proof (state)\nthis:\n  \\<pi>' = mapping.rep \\<pi>\n\ngoal (1 subgoal):\n 1. accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w", "have \"dom \\<pi>' = Mapping.keys \\<pi>\" and \"Mapping.Mapping \\<pi>' = \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom \\<pi>' = Mapping.keys \\<pi> &&& mapping.Mapping \\<pi>' = \\<pi>", "by (simp_all add: \\<pi>'_def mapping.rep_inverse keys.rep_eq)"], ["proof (state)\nthis:\n  dom \\<pi>' = Mapping.keys \\<pi>\n  mapping.Mapping \\<pi>' = \\<pi>\n\ngoal (1 subgoal):\n 1. accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w", "have 1: \"dom \\<pi>' \\<subseteq> \\<^bold>G \\<phi>\" and 2: \"\\<And>\\<chi>. \\<chi> \\<in> dom \\<pi>' \\<Longrightarrow> the (\\<pi>' \\<chi>) < max_rank_of \\<Sigma> \\<chi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom \\<pi>' \\<subseteq> \\<^bold>G \\<phi> &&&\n    (\\<And>\\<chi>.\n        \\<chi> \\<in> dom \\<pi>' \\<Longrightarrow>\n        the (\\<pi>' \\<chi>) < max_rank_of \\<Sigma> \\<chi>)", "using 1 2"], ["proof (prove)\nusing this:\n  Mapping.keys \\<pi> \\<subseteq> \\<^bold>G \\<phi>\n  ?\\<chi>17 \\<in> Mapping.keys \\<pi> \\<Longrightarrow>\n  the (Mapping.lookup \\<pi> ?\\<chi>17) < max_rank_of \\<Sigma> ?\\<chi>17\n\ngoal (1 subgoal):\n 1. dom \\<pi>' \\<subseteq> \\<^bold>G \\<phi> &&&\n    (\\<And>\\<chi>.\n        \\<chi> \\<in> dom \\<pi>' \\<Longrightarrow>\n        the (\\<pi>' \\<chi>) < max_rank_of \\<Sigma> \\<chi>)", "unfolding  \\<pi>'_def Mapping.keys.rep_eq Mapping.mapping.rep_inverse"], ["proof (prove)\nusing this:\n  dom (mapping.rep \\<pi>) \\<subseteq> \\<^bold>G \\<phi>\n  ?\\<chi>17 \\<in> dom (mapping.rep \\<pi>) \\<Longrightarrow>\n  the (Mapping.lookup \\<pi> ?\\<chi>17) < max_rank_of \\<Sigma> ?\\<chi>17\n\ngoal (1 subgoal):\n 1. dom (mapping.rep \\<pi>) \\<subseteq> \\<^bold>G \\<phi> &&&\n    (\\<And>\\<chi>.\n        \\<chi> \\<in> dom (mapping.rep \\<pi>) \\<Longrightarrow>\n        the (mapping.rep \\<pi> \\<chi>) < max_rank_of \\<Sigma> \\<chi>)", "by (simp add: lookup.rep_eq)+"], ["proof (state)\nthis:\n  dom \\<pi>' \\<subseteq> \\<^bold>G \\<phi>\n  ?\\<chi>17 \\<in> dom \\<pi>' \\<Longrightarrow>\n  the (\\<pi>' ?\\<chi>17) < max_rank_of \\<Sigma> ?\\<chi>17\n\ngoal (1 subgoal):\n 1. accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w", "moreover"], ["proof (state)\nthis:\n  dom \\<pi>' \\<subseteq> \\<^bold>G \\<phi>\n  ?\\<chi>17 \\<in> dom \\<pi>' \\<Longrightarrow>\n  the (\\<pi>' ?\\<chi>17) < max_rank_of \\<Sigma> ?\\<chi>17\n\ngoal (1 subgoal):\n 1. accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w", "have \"({a \\<in> reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>). M_fin\\<^sub>C \\<phi> \\<pi> a \\<or> (\\<exists>\\<chi>\\<in>Mapping.keys \\<pi>. Acc_fin\\<^sub>C \\<Sigma> \\<pi> \\<chi> a)}, {y. \\<exists>x\\<in>Mapping.keys \\<pi>. y = {a \\<in> reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>). Acc_inf\\<^sub>C \\<pi> x a}})\n      = ((Collect (M_fin\\<^sub>C \\<phi> \\<pi>) \\<union> {t. \\<exists>\\<chi>\\<in>Mapping.keys \\<pi>. Acc_fin\\<^sub>C \\<Sigma> \\<pi> \\<chi> t}) \\<inter> reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>), {y. \\<exists>x\\<in>{Collect (Acc_inf\\<^sub>C \\<pi> \\<chi>) |\\<chi>. \\<chi> \\<in> Mapping.keys \\<pi>}. y = x \\<inter> reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({a \\<in> reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n               (initial\\<^sub>C \\<phi>).\n      M_fin\\<^sub>C \\<phi> \\<pi> a \\<or>\n      (\\<exists>\\<chi>\\<in>Mapping.keys \\<pi>.\n          Acc_fin\\<^sub>C \\<Sigma> \\<pi> \\<chi> a)},\n     {y. \\<exists>x\\<in>Mapping.keys \\<pi>.\n            y =\n            {a \\<in> reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n                      (initial\\<^sub>C \\<phi>).\n             Acc_inf\\<^sub>C \\<pi> x a}}) =\n    ((Collect (M_fin\\<^sub>C \\<phi> \\<pi>) \\<union>\n      {t. \\<exists>\\<chi>\\<in>Mapping.keys \\<pi>.\n             Acc_fin\\<^sub>C \\<Sigma> \\<pi> \\<chi> t}) \\<inter>\n     reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n      (initial\\<^sub>C \\<phi>),\n     {y. \\<exists>x\\<in>{Collect (Acc_inf\\<^sub>C \\<pi> \\<chi>) |\\<chi>.\n                         \\<chi> \\<in> Mapping.keys \\<pi>}.\n            y =\n            x \\<inter>\n            reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n             (initial\\<^sub>C \\<phi>)})", "by auto"], ["proof (state)\nthis:\n  ({a \\<in> reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n             (initial\\<^sub>C \\<phi>).\n    M_fin\\<^sub>C \\<phi> \\<pi> a \\<or>\n    (\\<exists>\\<chi>\\<in>Mapping.keys \\<pi>.\n        Acc_fin\\<^sub>C \\<Sigma> \\<pi> \\<chi> a)},\n   {y. \\<exists>x\\<in>Mapping.keys \\<pi>.\n          y =\n          {a \\<in> reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n                    (initial\\<^sub>C \\<phi>).\n           Acc_inf\\<^sub>C \\<pi> x a}}) =\n  ((Collect (M_fin\\<^sub>C \\<phi> \\<pi>) \\<union>\n    {t. \\<exists>\\<chi>\\<in>Mapping.keys \\<pi>.\n           Acc_fin\\<^sub>C \\<Sigma> \\<pi> \\<chi> t}) \\<inter>\n   reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>),\n   {y. \\<exists>x\\<in>{Collect (Acc_inf\\<^sub>C \\<pi> \\<chi>) |\\<chi>.\n                       \\<chi> \\<in> Mapping.keys \\<pi>}.\n          y =\n          x \\<inter>\n          reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n           (initial\\<^sub>C \\<phi>)})\n\ngoal (1 subgoal):\n 1. accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w", "hence \"accepting_pair\\<^sub>G\\<^sub>R (delta \\<Sigma>) (initial \\<phi>) (M_fin \\<pi>' \\<union> \\<Union>{Acc_fin \\<Sigma> \\<pi>' \\<chi> | \\<chi>. \\<chi> \\<in> dom \\<pi>'}, {Acc_inf \\<pi>' \\<chi> | \\<chi>. \\<chi> \\<in> dom \\<pi>'}) w\""], ["proof (prove)\nusing this:\n  ({a \\<in> reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n             (initial\\<^sub>C \\<phi>).\n    M_fin\\<^sub>C \\<phi> \\<pi> a \\<or>\n    (\\<exists>\\<chi>\\<in>Mapping.keys \\<pi>.\n        Acc_fin\\<^sub>C \\<Sigma> \\<pi> \\<chi> a)},\n   {y. \\<exists>x\\<in>Mapping.keys \\<pi>.\n          y =\n          {a \\<in> reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n                    (initial\\<^sub>C \\<phi>).\n           Acc_inf\\<^sub>C \\<pi> x a}}) =\n  ((Collect (M_fin\\<^sub>C \\<phi> \\<pi>) \\<union>\n    {t. \\<exists>\\<chi>\\<in>Mapping.keys \\<pi>.\n           Acc_fin\\<^sub>C \\<Sigma> \\<pi> \\<chi> t}) \\<inter>\n   reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>),\n   {y. \\<exists>x\\<in>{Collect (Acc_inf\\<^sub>C \\<pi> \\<chi>) |\\<chi>.\n                       \\<chi> \\<in> Mapping.keys \\<pi>}.\n          y =\n          x \\<inter>\n          reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n           (initial\\<^sub>C \\<phi>)})\n\ngoal (1 subgoal):\n 1. accepting_pair\\<^sub>G\\<^sub>R (delta \\<Sigma>) (initial \\<phi>)\n     (M_fin \\<pi>' \\<union>\n      \\<Union>\n       {Acc_fin \\<Sigma> \\<pi>' \\<chi> |\\<chi>. \\<chi> \\<in> dom \\<pi>'},\n      {Acc_inf \\<pi>' \\<chi> |\\<chi>. \\<chi> \\<in> dom \\<pi>'})\n     w", "unfolding X[OF 1]"], ["proof (prove)\nusing this:\n  ({a \\<in> reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n             (initial\\<^sub>C \\<phi>).\n    M_fin\\<^sub>C \\<phi> \\<pi> a \\<or>\n    (\\<exists>\\<chi>\\<in>Mapping.keys \\<pi>.\n        Acc_fin\\<^sub>C \\<Sigma> \\<pi> \\<chi> a)},\n   {y. \\<exists>x\\<in>Mapping.keys \\<pi>.\n          y =\n          {a \\<in> reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n                    (initial\\<^sub>C \\<phi>).\n           Acc_inf\\<^sub>C \\<pi> x a}}) =\n  ((Collect (M_fin\\<^sub>C \\<phi> \\<pi>) \\<union>\n    {t. \\<exists>\\<chi>\\<in>Mapping.keys \\<pi>.\n           Acc_fin\\<^sub>C \\<Sigma> \\<pi> \\<chi> t}) \\<inter>\n   reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>),\n   {y. \\<exists>x\\<in>{Collect (Acc_inf\\<^sub>C \\<pi> \\<chi>) |\\<chi>.\n                       \\<chi> \\<in> Mapping.keys \\<pi>}.\n          y =\n          x \\<inter>\n          reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n           (initial\\<^sub>C \\<phi>)})\n\ngoal (1 subgoal):\n 1. accepting_pair\\<^sub>G\\<^sub>R_LTS\n     (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n       (initial\\<^sub>C \\<phi>))\n     (initial\\<^sub>C \\<phi>)\n     ((Collect (M_fin\\<^sub>C \\<phi> (mapping.Mapping \\<pi>')) \\<union>\n       {t. \\<exists>\\<chi>\\<in>dom \\<pi>'.\n              Acc_fin\\<^sub>C \\<Sigma> (mapping.Mapping \\<pi>') \\<chi>\n               t}) \\<inter>\n      reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n       (initial\\<^sub>C \\<phi>),\n      (\\<lambda>I.\n          I \\<inter>\n          reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n           (initial\\<^sub>C \\<phi>)) `\n      {Collect (Acc_inf\\<^sub>C (mapping.Mapping \\<pi>') \\<chi>) |\\<chi>.\n       \\<chi> \\<in> dom \\<pi>'})\n     w", "using 4"], ["proof (prove)\nusing this:\n  ({a \\<in> reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n             (initial\\<^sub>C \\<phi>).\n    M_fin\\<^sub>C \\<phi> \\<pi> a \\<or>\n    (\\<exists>\\<chi>\\<in>Mapping.keys \\<pi>.\n        Acc_fin\\<^sub>C \\<Sigma> \\<pi> \\<chi> a)},\n   {y. \\<exists>x\\<in>Mapping.keys \\<pi>.\n          y =\n          {a \\<in> reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n                    (initial\\<^sub>C \\<phi>).\n           Acc_inf\\<^sub>C \\<pi> x a}}) =\n  ((Collect (M_fin\\<^sub>C \\<phi> \\<pi>) \\<union>\n    {t. \\<exists>\\<chi>\\<in>Mapping.keys \\<pi>.\n           Acc_fin\\<^sub>C \\<Sigma> \\<pi> \\<chi> t}) \\<inter>\n   reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>),\n   {y. \\<exists>x\\<in>{Collect (Acc_inf\\<^sub>C \\<pi> \\<chi>) |\\<chi>.\n                       \\<chi> \\<in> Mapping.keys \\<pi>}.\n          y =\n          x \\<inter>\n          reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n           (initial\\<^sub>C \\<phi>)})\n  accepting_pair\\<^sub>G\\<^sub>R_LTS\n   (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n     (initial\\<^sub>C \\<phi>))\n   (initial\\<^sub>C \\<phi>) (Fin, Inf) w\n\ngoal (1 subgoal):\n 1. accepting_pair\\<^sub>G\\<^sub>R_LTS\n     (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n       (initial\\<^sub>C \\<phi>))\n     (initial\\<^sub>C \\<phi>)\n     ((Collect (M_fin\\<^sub>C \\<phi> (mapping.Mapping \\<pi>')) \\<union>\n       {t. \\<exists>\\<chi>\\<in>dom \\<pi>'.\n              Acc_fin\\<^sub>C \\<Sigma> (mapping.Mapping \\<pi>') \\<chi>\n               t}) \\<inter>\n      reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n       (initial\\<^sub>C \\<phi>),\n      (\\<lambda>I.\n          I \\<inter>\n          reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n           (initial\\<^sub>C \\<phi>)) `\n      {Collect (Acc_inf\\<^sub>C (mapping.Mapping \\<pi>') \\<chi>) |\\<chi>.\n       \\<chi> \\<in> dom \\<pi>'})\n     w", "unfolding Y Set.filter_def"], ["proof (prove)\nusing this:\n  ({a \\<in> reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n             (initial\\<^sub>C \\<phi>).\n    M_fin\\<^sub>C \\<phi> \\<pi> a \\<or>\n    (\\<exists>\\<chi>\\<in>Mapping.keys \\<pi>.\n        Acc_fin\\<^sub>C \\<Sigma> \\<pi> \\<chi> a)},\n   {y. \\<exists>x\\<in>Mapping.keys \\<pi>.\n          y =\n          {a \\<in> reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n                    (initial\\<^sub>C \\<phi>).\n           Acc_inf\\<^sub>C \\<pi> x a}}) =\n  ((Collect (M_fin\\<^sub>C \\<phi> \\<pi>) \\<union>\n    {t. \\<exists>\\<chi>\\<in>Mapping.keys \\<pi>.\n           Acc_fin\\<^sub>C \\<Sigma> \\<pi> \\<chi> t}) \\<inter>\n   reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>),\n   {y. \\<exists>x\\<in>{Collect (Acc_inf\\<^sub>C \\<pi> \\<chi>) |\\<chi>.\n                       \\<chi> \\<in> Mapping.keys \\<pi>}.\n          y =\n          x \\<inter>\n          reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n           (initial\\<^sub>C \\<phi>)})\n  accepting_pair\\<^sub>G\\<^sub>R_LTS\n   (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n     (initial\\<^sub>C \\<phi>))\n   (initial\\<^sub>C \\<phi>)\n   ({a \\<in> reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n              (initial\\<^sub>C \\<phi>).\n     M_fin\\<^sub>C \\<phi> \\<pi> a \\<or>\n     (\\<exists>\\<chi>\\<in>Mapping.keys \\<pi>.\n         Acc_fin\\<^sub>C \\<Sigma> \\<pi> \\<chi> a)},\n    (\\<lambda>\\<chi>.\n        {a \\<in> reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n                  (initial\\<^sub>C \\<phi>).\n         Acc_inf\\<^sub>C \\<pi> \\<chi> a}) `\n    Mapping.keys \\<pi>)\n   w\n\ngoal (1 subgoal):\n 1. accepting_pair\\<^sub>G\\<^sub>R_LTS\n     (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n       (initial\\<^sub>C \\<phi>))\n     (initial\\<^sub>C \\<phi>)\n     ((Collect (M_fin\\<^sub>C \\<phi> (mapping.Mapping \\<pi>')) \\<union>\n       {t. \\<exists>\\<chi>\\<in>dom \\<pi>'.\n              Acc_fin\\<^sub>C \\<Sigma> (mapping.Mapping \\<pi>') \\<chi>\n               t}) \\<inter>\n      reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n       (initial\\<^sub>C \\<phi>),\n      (\\<lambda>I.\n          I \\<inter>\n          reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n           (initial\\<^sub>C \\<phi>)) `\n      {Collect (Acc_inf\\<^sub>C (mapping.Mapping \\<pi>') \\<chi>) |\\<chi>.\n       \\<chi> \\<in> dom \\<pi>'})\n     w", "unfolding \\<open>dom \\<pi>' = Mapping.keys \\<pi>\\<close> \\<open>Mapping.Mapping \\<pi>' = \\<pi>\\<close> image_def"], ["proof (prove)\nusing this:\n  ({a \\<in> reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n             (initial\\<^sub>C \\<phi>).\n    M_fin\\<^sub>C \\<phi> \\<pi> a \\<or>\n    (\\<exists>\\<chi>\\<in>Mapping.keys \\<pi>.\n        Acc_fin\\<^sub>C \\<Sigma> \\<pi> \\<chi> a)},\n   {y. \\<exists>x\\<in>Mapping.keys \\<pi>.\n          y =\n          {a \\<in> reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n                    (initial\\<^sub>C \\<phi>).\n           Acc_inf\\<^sub>C \\<pi> x a}}) =\n  ((Collect (M_fin\\<^sub>C \\<phi> \\<pi>) \\<union>\n    {t. \\<exists>\\<chi>\\<in>Mapping.keys \\<pi>.\n           Acc_fin\\<^sub>C \\<Sigma> \\<pi> \\<chi> t}) \\<inter>\n   reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>) (initial\\<^sub>C \\<phi>),\n   {y. \\<exists>x\\<in>{Collect (Acc_inf\\<^sub>C \\<pi> \\<chi>) |\\<chi>.\n                       \\<chi> \\<in> Mapping.keys \\<pi>}.\n          y =\n          x \\<inter>\n          reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n           (initial\\<^sub>C \\<phi>)})\n  accepting_pair\\<^sub>G\\<^sub>R_LTS\n   (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n     (initial\\<^sub>C \\<phi>))\n   (initial\\<^sub>C \\<phi>)\n   ({a \\<in> reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n              (initial\\<^sub>C \\<phi>).\n     M_fin\\<^sub>C \\<phi> \\<pi> a \\<or>\n     (\\<exists>\\<chi>\\<in>Mapping.keys \\<pi>.\n         Acc_fin\\<^sub>C \\<Sigma> \\<pi> \\<chi> a)},\n    {y. \\<exists>x\\<in>Mapping.keys \\<pi>.\n           y =\n           {a \\<in> reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n                     (initial\\<^sub>C \\<phi>).\n            Acc_inf\\<^sub>C \\<pi> x a}})\n   w\n\ngoal (1 subgoal):\n 1. accepting_pair\\<^sub>G\\<^sub>R_LTS\n     (reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n       (initial\\<^sub>C \\<phi>))\n     (initial\\<^sub>C \\<phi>)\n     ((Collect (M_fin\\<^sub>C \\<phi> \\<pi>) \\<union>\n       {t. \\<exists>\\<chi>\\<in>Mapping.keys \\<pi>.\n              Acc_fin\\<^sub>C \\<Sigma> \\<pi> \\<chi> t}) \\<inter>\n      reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n       (initial\\<^sub>C \\<phi>),\n      {y. \\<exists>x\\<in>{Collect (Acc_inf\\<^sub>C \\<pi> \\<chi>) |\\<chi>.\n                          \\<chi> \\<in> Mapping.keys \\<pi>}.\n             y =\n             x \\<inter>\n             reach\\<^sub>t \\<Sigma> (delta\\<^sub>C \\<Sigma>)\n              (initial\\<^sub>C \\<phi>)})\n     w", "by simp"], ["proof (state)\nthis:\n  accepting_pair\\<^sub>G\\<^sub>R (delta \\<Sigma>) (initial \\<phi>)\n   (M_fin \\<pi>' \\<union>\n    \\<Union>\n     {Acc_fin \\<Sigma> \\<pi>' \\<chi> |\\<chi>. \\<chi> \\<in> dom \\<pi>'},\n    {Acc_inf \\<pi>' \\<chi> |\\<chi>. \\<chi> \\<in> dom \\<pi>'})\n   w\n\ngoal (1 subgoal):\n 1. accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w \\<Longrightarrow>\n    accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w", "ultimately"], ["proof (chain)\npicking this:\n  dom \\<pi>' \\<subseteq> \\<^bold>G \\<phi>\n  ?\\<chi>17 \\<in> dom \\<pi>' \\<Longrightarrow>\n  the (\\<pi>' ?\\<chi>17) < max_rank_of \\<Sigma> ?\\<chi>17\n  accepting_pair\\<^sub>G\\<^sub>R (delta \\<Sigma>) (initial \\<phi>)\n   (M_fin \\<pi>' \\<union>\n    \\<Union>\n     {Acc_fin \\<Sigma> \\<pi>' \\<chi> |\\<chi>. \\<chi> \\<in> dom \\<pi>'},\n    {Acc_inf \\<pi>' \\<chi> |\\<chi>. \\<chi> \\<in> dom \\<pi>'})\n   w", "show ?lhs"], ["proof (prove)\nusing this:\n  dom \\<pi>' \\<subseteq> \\<^bold>G \\<phi>\n  ?\\<chi>17 \\<in> dom \\<pi>' \\<Longrightarrow>\n  the (\\<pi>' ?\\<chi>17) < max_rank_of \\<Sigma> ?\\<chi>17\n  accepting_pair\\<^sub>G\\<^sub>R (delta \\<Sigma>) (initial \\<phi>)\n   (M_fin \\<pi>' \\<union>\n    \\<Union>\n     {Acc_fin \\<Sigma> \\<pi>' \\<chi> |\\<chi>. \\<chi> \\<in> dom \\<pi>'},\n    {Acc_inf \\<pi>' \\<chi> |\\<chi>. \\<chi> \\<in> dom \\<pi>'})\n   w\n\ngoal (1 subgoal):\n 1. accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w", "unfolding ltl_to_generalized_rabin.simps"], ["proof (prove)\nusing this:\n  dom \\<pi>' \\<subseteq> \\<^bold>G \\<phi>\n  ?\\<chi>17 \\<in> dom \\<pi>' \\<Longrightarrow>\n  the (\\<pi>' ?\\<chi>17) < max_rank_of \\<Sigma> ?\\<chi>17\n  accepting_pair\\<^sub>G\\<^sub>R (delta \\<Sigma>) (initial \\<phi>)\n   (M_fin \\<pi>' \\<union>\n    \\<Union>\n     {Acc_fin \\<Sigma> \\<pi>' \\<chi> |\\<chi>. \\<chi> \\<in> dom \\<pi>'},\n    {Acc_inf \\<pi>' \\<chi> |\\<chi>. \\<chi> \\<in> dom \\<pi>'})\n   w\n\ngoal (1 subgoal):\n 1. accept\\<^sub>G\\<^sub>R\n     (delta \\<Sigma>, initial \\<phi>, rabin_pairs \\<Sigma> \\<phi>) w", "by (intro Rabin.accept\\<^sub>G\\<^sub>R_I, blast; auto)"], ["proof (state)\nthis:\n  accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  accept\\<^sub>G\\<^sub>R_LTS\n   (ltl_to_generalized_rabin\\<^sub>C \\<Sigma>' \\<phi>) w \\<Longrightarrow>\n  accept\\<^sub>G\\<^sub>R (\\<A> \\<Sigma> \\<phi>) w\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Generalized Deterministic Rabin Automaton (af)\\<close>"], ["", "definition M_fin\\<^sub>C_af_lhs :: \"'a ltl \\<Rightarrow> ('a ltl, nat) mapping \\<Rightarrow> ('a ltl, ('a ltl\\<^sub>P list)) mapping \\<Rightarrow> 'a ltl\\<^sub>P\"\nwhere\n  \"M_fin\\<^sub>C_af_lhs \\<phi> \\<pi> m' \\<equiv> \n    let\n      \\<G> = Mapping.keys \\<pi>;\n      \\<G>\\<^sub>L = filter (\\<lambda>x. x \\<in> \\<G>) (G_list \\<phi>);\n      mk_conj = \\<lambda>\\<chi>. foldl and_abs (Abs \\<chi>) (map (\\<up>eval\\<^sub>G \\<G>) (drop (the (Mapping.lookup \\<pi> \\<chi>)) (the (Mapping.lookup m' \\<chi>))))\n    in \n      \\<up>And (map mk_conj \\<G>\\<^sub>L)\""], ["", "fun M_fin\\<^sub>C_af :: \"'a ltl \\<Rightarrow> ('a ltl, nat) mapping \\<Rightarrow> ('a ltl\\<^sub>P \\<times> (('a ltl, ('a ltl\\<^sub>P list)) mapping), 'a set) transition \\<Rightarrow> bool\"\nwhere\n  \"M_fin\\<^sub>C_af \\<phi> \\<pi> ((\\<phi>', m'), _) = Not ((M_fin\\<^sub>C_af_lhs \\<phi> \\<pi> m') \\<up>\\<longrightarrow>\\<^sub>P  \\<phi>')\""], ["", "lemma M_fin\\<^sub>C_af_correct:\n  assumes \"t \\<in> reach\\<^sub>t \\<Sigma> (ltl_to_rabin_base_code_def.delta\\<^sub>C \\<up>af \\<up>af\\<^sub>G Abs \\<Sigma>) (ltl_to_rabin_base_code_def.initial\\<^sub>C Abs Abs \\<phi>)\"\n  assumes \"dom \\<pi> \\<subseteq> \\<^bold>G \\<phi>\"\n  shows \"abstract_transition t \\<in> M_fin \\<pi> = M_fin\\<^sub>C_af \\<phi> (Mapping.Mapping \\<pi>) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (abstract_transition t \\<in> M_fin \\<pi>) =\n    M_fin\\<^sub>C_af \\<phi> (mapping.Mapping \\<pi>) t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (abstract_transition t \\<in> M_fin \\<pi>) =\n    M_fin\\<^sub>C_af \\<phi> (mapping.Mapping \\<pi>) t", "let ?delta = \"ltl_to_rabin_base_code_def.delta\\<^sub>C \\<up>af \\<up>af\\<^sub>G Abs \\<Sigma>\""], ["proof (state)\ngoal (1 subgoal):\n 1. (abstract_transition t \\<in> M_fin \\<pi>) =\n    M_fin\\<^sub>C_af \\<phi> (mapping.Mapping \\<pi>) t", "let ?initial = \"ltl_to_rabin_base_code_def.initial\\<^sub>C Abs Abs \\<phi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. (abstract_transition t \\<in> M_fin \\<pi>) =\n    M_fin\\<^sub>C_af \\<phi> (mapping.Mapping \\<pi>) t", "obtain x y \\<nu> z z' where t_def [simp]: \"t = ((x, y), \\<nu>, (z, z'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y \\<nu> z z'.\n        t = ((x, y), \\<nu>, z, z') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod.collapse)"], ["proof (state)\nthis:\n  t = ((x, y), \\<nu>, z, z')\n\ngoal (1 subgoal):\n 1. (abstract_transition t \\<in> M_fin \\<pi>) =\n    M_fin\\<^sub>C_af \\<phi> (mapping.Mapping \\<pi>) t", "have \"(x, y) \\<in> reach \\<Sigma> ?delta ?initial\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y)\n    \\<in> reach \\<Sigma>\n           (ltl_to_rabin_base_code_def.delta\\<^sub>C \\<up>af \\<up>af\\<^sub>G\n             Abs \\<Sigma>)\n           (ltl_to_rabin_base_code_def.initial\\<^sub>C Abs Abs \\<phi>)", "using assms(1)"], ["proof (prove)\nusing this:\n  t \\<in> reach\\<^sub>t \\<Sigma>\n           (ltl_to_rabin_base_code_def.delta\\<^sub>C \\<up>af \\<up>af\\<^sub>G\n             Abs \\<Sigma>)\n           (ltl_to_rabin_base_code_def.initial\\<^sub>C Abs Abs \\<phi>)\n\ngoal (1 subgoal):\n 1. (x, y)\n    \\<in> reach \\<Sigma>\n           (ltl_to_rabin_base_code_def.delta\\<^sub>C \\<up>af \\<up>af\\<^sub>G\n             Abs \\<Sigma>)\n           (ltl_to_rabin_base_code_def.initial\\<^sub>C Abs Abs \\<phi>)", "by (simp add: reach\\<^sub>t_def reach_def; blast)"], ["proof (state)\nthis:\n  (x, y)\n  \\<in> reach \\<Sigma>\n         (ltl_to_rabin_base_code_def.delta\\<^sub>C \\<up>af \\<up>af\\<^sub>G\n           Abs \\<Sigma>)\n         (ltl_to_rabin_base_code_def.initial\\<^sub>C Abs Abs \\<phi>)\n\ngoal (1 subgoal):\n 1. (abstract_transition t \\<in> M_fin \\<pi>) =\n    M_fin\\<^sub>C_af \\<phi> (mapping.Mapping \\<pi>) t", "hence N1: \"\\<And>\\<chi>. \\<chi> \\<in> dom \\<pi> \\<Longrightarrow> Mapping.lookup y \\<chi> \\<noteq> None\"\n    and D1: \"\\<And>\\<chi>. \\<chi> \\<in> dom \\<pi> \\<Longrightarrow> distinct (the (Mapping.lookup y \\<chi>))\""], ["proof (prove)\nusing this:\n  (x, y)\n  \\<in> reach \\<Sigma>\n         (ltl_to_rabin_base_code_def.delta\\<^sub>C \\<up>af \\<up>af\\<^sub>G\n           Abs \\<Sigma>)\n         (ltl_to_rabin_base_code_def.initial\\<^sub>C Abs Abs \\<phi>)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<chi>.\n        \\<chi> \\<in> dom \\<pi> \\<Longrightarrow>\n        Mapping.lookup y \\<chi> \\<noteq> None) &&&\n    (\\<And>\\<chi>.\n        \\<chi> \\<in> dom \\<pi> \\<Longrightarrow>\n        distinct (the (Mapping.lookup y \\<chi>)))", "using assms(2)"], ["proof (prove)\nusing this:\n  (x, y)\n  \\<in> reach \\<Sigma>\n         (ltl_to_rabin_base_code_def.delta\\<^sub>C \\<up>af \\<up>af\\<^sub>G\n           Abs \\<Sigma>)\n         (ltl_to_rabin_base_code_def.initial\\<^sub>C Abs Abs \\<phi>)\n  dom \\<pi> \\<subseteq> \\<^bold>G \\<phi>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<chi>.\n        \\<chi> \\<in> dom \\<pi> \\<Longrightarrow>\n        Mapping.lookup y \\<chi> \\<noteq> None) &&&\n    (\\<And>\\<chi>.\n        \\<chi> \\<in> dom \\<pi> \\<Longrightarrow>\n        distinct (the (Mapping.lookup y \\<chi>)))", "by (blast dest: ltl_to_rabin_base_code_def.reach_delta_initial)+"], ["proof (state)\nthis:\n  ?\\<chi> \\<in> dom \\<pi> \\<Longrightarrow>\n  Mapping.lookup y ?\\<chi> \\<noteq> None\n  ?\\<chi> \\<in> dom \\<pi> \\<Longrightarrow>\n  distinct (the (Mapping.lookup y ?\\<chi>))\n\ngoal (1 subgoal):\n 1. (abstract_transition t \\<in> M_fin \\<pi>) =\n    M_fin\\<^sub>C_af \\<phi> (mapping.Mapping \\<pi>) t", "{"], ["proof (state)\nthis:\n  ?\\<chi> \\<in> dom \\<pi> \\<Longrightarrow>\n  Mapping.lookup y ?\\<chi> \\<noteq> None\n  ?\\<chi> \\<in> dom \\<pi> \\<Longrightarrow>\n  distinct (the (Mapping.lookup y ?\\<chi>))\n\ngoal (1 subgoal):\n 1. (abstract_transition t \\<in> M_fin \\<pi>) =\n    M_fin\\<^sub>C_af \\<phi> (mapping.Mapping \\<pi>) t", "fix S"], ["proof (state)\ngoal (1 subgoal):\n 1. (abstract_transition t \\<in> M_fin \\<pi>) =\n    M_fin\\<^sub>C_af \\<phi> (mapping.Mapping \\<pi>) t", "let ?m' = \"\\<lambda>\\<chi>. map_option rk (Mapping.lookup y \\<chi>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (abstract_transition t \\<in> M_fin \\<pi>) =\n    M_fin\\<^sub>C_af \\<phi> (mapping.Mapping \\<pi>) t", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (abstract_transition t \\<in> M_fin \\<pi>) =\n    M_fin\\<^sub>C_af \\<phi> (mapping.Mapping \\<pi>) t", "fix \\<chi>"], ["proof (state)\ngoal (1 subgoal):\n 1. (abstract_transition t \\<in> M_fin \\<pi>) =\n    M_fin\\<^sub>C_af \\<phi> (mapping.Mapping \\<pi>) t", "assume \"\\<chi> \\<in> dom \\<pi>\""], ["proof (state)\nthis:\n  \\<chi> \\<in> dom \\<pi>\n\ngoal (1 subgoal):\n 1. (abstract_transition t \\<in> M_fin \\<pi>) =\n    M_fin\\<^sub>C_af \\<phi> (mapping.Mapping \\<pi>) t", "hence \"S \\<up>\\<Turnstile>\\<^sub>P (foldl and_abs (Abs \\<chi>) (map (\\<up>eval\\<^sub>G (dom \\<pi>)) (drop (the (\\<pi> \\<chi>)) (the (Mapping.lookup y \\<chi>)))))\n         \\<longleftrightarrow> S \\<up>\\<Turnstile>\\<^sub>P (Abs \\<chi>) \\<and> (\\<forall>q. (\\<exists>j \\<ge> the (\\<pi> \\<chi>). the (?m' \\<chi>) q = Some j) \\<longrightarrow> S \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>) q)\""], ["proof (prove)\nusing this:\n  \\<chi> \\<in> dom \\<pi>\n\ngoal (1 subgoal):\n 1. S \\<up>\\<Turnstile>\\<^sub>P foldl and_abs (Abs \\<chi>)\n                                 (map (\\<up>eval\\<^sub>G (dom \\<pi>))\n                                   (drop (the (\\<pi> \\<chi>))\n                                     (the (Mapping.lookup y \\<chi>)))) =\n    (S \\<up>\\<Turnstile>\\<^sub>P Abs \\<chi> \\<and>\n     (\\<forall>q.\n         (\\<exists>j\\<ge>the (\\<pi> \\<chi>).\n             the (map_option rk (Mapping.lookup y \\<chi>)) q =\n             Some j) \\<longrightarrow>\n         S \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>) q))", "using D1[THEN drop_rk, of _ \"the (\\<pi> \\<chi>)\"] N1[THEN option.map_sel, of _ rk]"], ["proof (prove)\nusing this:\n  \\<chi> \\<in> dom \\<pi>\n  ?\\<chi>1 \\<in> dom \\<pi> \\<Longrightarrow>\n  set (drop (the (\\<pi> \\<chi>)) (the (Mapping.lookup y ?\\<chi>1))) =\n  {q. \\<exists>j\\<ge>the (\\<pi> \\<chi>).\n         rk (the (Mapping.lookup y ?\\<chi>1)) q = Some j}\n  ?\\<chi>1 \\<in> dom \\<pi> \\<Longrightarrow>\n  the (map_option rk (Mapping.lookup y ?\\<chi>1)) =\n  rk (the (Mapping.lookup y ?\\<chi>1))\n\ngoal (1 subgoal):\n 1. S \\<up>\\<Turnstile>\\<^sub>P foldl and_abs (Abs \\<chi>)\n                                 (map (\\<up>eval\\<^sub>G (dom \\<pi>))\n                                   (drop (the (\\<pi> \\<chi>))\n                                     (the (Mapping.lookup y \\<chi>)))) =\n    (S \\<up>\\<Turnstile>\\<^sub>P Abs \\<chi> \\<and>\n     (\\<forall>q.\n         (\\<exists>j\\<ge>the (\\<pi> \\<chi>).\n             the (map_option rk (Mapping.lookup y \\<chi>)) q =\n             Some j) \\<longrightarrow>\n         S \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>) q))", "by (auto simp add: foldl_LTLAnd_prop_entailment_abs)"], ["proof (state)\nthis:\n  S \\<up>\\<Turnstile>\\<^sub>P foldl and_abs (Abs \\<chi>)\n                               (map (\\<up>eval\\<^sub>G (dom \\<pi>))\n                                 (drop (the (\\<pi> \\<chi>))\n                                   (the (Mapping.lookup y \\<chi>)))) =\n  (S \\<up>\\<Turnstile>\\<^sub>P Abs \\<chi> \\<and>\n   (\\<forall>q.\n       (\\<exists>j\\<ge>the (\\<pi> \\<chi>).\n           the (map_option rk (Mapping.lookup y \\<chi>)) q =\n           Some j) \\<longrightarrow>\n       S \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>) q))\n\ngoal (1 subgoal):\n 1. (abstract_transition t \\<in> M_fin \\<pi>) =\n    M_fin\\<^sub>C_af \\<phi> (mapping.Mapping \\<pi>) t", "}"], ["proof (state)\nthis:\n  ?\\<chi>2 \\<in> dom \\<pi> \\<Longrightarrow>\n  S \\<up>\\<Turnstile>\\<^sub>P foldl and_abs (Abs ?\\<chi>2)\n                               (map (\\<up>eval\\<^sub>G (dom \\<pi>))\n                                 (drop (the (\\<pi> ?\\<chi>2))\n                                   (the (Mapping.lookup y ?\\<chi>2)))) =\n  (S \\<up>\\<Turnstile>\\<^sub>P Abs ?\\<chi>2 \\<and>\n   (\\<forall>q.\n       (\\<exists>j\\<ge>the (\\<pi> ?\\<chi>2).\n           the (map_option rk (Mapping.lookup y ?\\<chi>2)) q =\n           Some j) \\<longrightarrow>\n       S \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>) q))\n\ngoal (1 subgoal):\n 1. (abstract_transition t \\<in> M_fin \\<pi>) =\n    M_fin\\<^sub>C_af \\<phi> (mapping.Mapping \\<pi>) t", "hence \"S \\<up>\\<Turnstile>\\<^sub>P (M_fin\\<^sub>C_af_lhs \\<phi> (Mapping.Mapping \\<pi>) y)\n      \\<longleftrightarrow> (\\<forall>\\<chi> \\<in> dom \\<pi>. S \\<up>\\<Turnstile>\\<^sub>P (Abs \\<chi>) \\<and> (\\<forall>q. (\\<exists>j \\<ge> the (\\<pi> \\<chi>). the (?m' \\<chi>) q = Some j) \\<longrightarrow> S \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>) q))\""], ["proof (prove)\nusing this:\n  ?\\<chi>2 \\<in> dom \\<pi> \\<Longrightarrow>\n  S \\<up>\\<Turnstile>\\<^sub>P foldl and_abs (Abs ?\\<chi>2)\n                               (map (\\<up>eval\\<^sub>G (dom \\<pi>))\n                                 (drop (the (\\<pi> ?\\<chi>2))\n                                   (the (Mapping.lookup y ?\\<chi>2)))) =\n  (S \\<up>\\<Turnstile>\\<^sub>P Abs ?\\<chi>2 \\<and>\n   (\\<forall>q.\n       (\\<exists>j\\<ge>the (\\<pi> ?\\<chi>2).\n           the (map_option rk (Mapping.lookup y ?\\<chi>2)) q =\n           Some j) \\<longrightarrow>\n       S \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>) q))\n\ngoal (1 subgoal):\n 1. S \\<up>\\<Turnstile>\\<^sub>P M_fin\\<^sub>C_af_lhs \\<phi>\n                                 (mapping.Mapping \\<pi>) y =\n    (\\<forall>\\<chi>\\<in>dom \\<pi>.\n        S \\<up>\\<Turnstile>\\<^sub>P Abs \\<chi> \\<and>\n        (\\<forall>q.\n            (\\<exists>j\\<ge>the (\\<pi> \\<chi>).\n                the (map_option rk (Mapping.lookup y \\<chi>)) q =\n                Some j) \\<longrightarrow>\n            S \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>) q))", "unfolding M_fin\\<^sub>C_af_lhs_def Let_def And_prop_entailment_abs set_map Ball_def keys.abs_eq lookup.abs_eq"], ["proof (prove)\nusing this:\n  ?\\<chi>2 \\<in> dom \\<pi> \\<Longrightarrow>\n  S \\<up>\\<Turnstile>\\<^sub>P foldl and_abs (Abs ?\\<chi>2)\n                               (map (\\<up>eval\\<^sub>G (dom \\<pi>))\n                                 (drop (the (\\<pi> ?\\<chi>2))\n                                   (the (Mapping.lookup y ?\\<chi>2)))) =\n  (S \\<up>\\<Turnstile>\\<^sub>P Abs ?\\<chi>2 \\<and>\n   (\\<forall>q.\n       (\\<exists>j\\<ge>the (\\<pi> ?\\<chi>2).\n           the (map_option rk (Mapping.lookup y ?\\<chi>2)) q =\n           Some j) \\<longrightarrow>\n       S \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>) q))\n\ngoal (1 subgoal):\n 1. (\\<forall>x.\n        x \\<in> (\\<lambda>\\<chi>.\n                    foldl and_abs (Abs \\<chi>)\n                     (map (\\<up>eval\\<^sub>G (dom \\<pi>))\n                       (drop (the (\\<pi> \\<chi>))\n                         (the (Mapping.lookup y \\<chi>))))) `\n                set (filter (\\<lambda>x. x \\<in> dom \\<pi>)\n                      (G_list \\<phi>)) \\<longrightarrow>\n        S \\<up>\\<Turnstile>\\<^sub>P x) =\n    (\\<forall>x.\n        x \\<in> dom \\<pi> \\<longrightarrow>\n        S \\<up>\\<Turnstile>\\<^sub>P Abs x \\<and>\n        (\\<forall>q.\n            (\\<exists>j\\<ge>the (\\<pi> x).\n                the (map_option rk (Mapping.lookup y x)) q =\n                Some j) \\<longrightarrow>\n            S \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>) q))", "using assms(2)"], ["proof (prove)\nusing this:\n  ?\\<chi>2 \\<in> dom \\<pi> \\<Longrightarrow>\n  S \\<up>\\<Turnstile>\\<^sub>P foldl and_abs (Abs ?\\<chi>2)\n                               (map (\\<up>eval\\<^sub>G (dom \\<pi>))\n                                 (drop (the (\\<pi> ?\\<chi>2))\n                                   (the (Mapping.lookup y ?\\<chi>2)))) =\n  (S \\<up>\\<Turnstile>\\<^sub>P Abs ?\\<chi>2 \\<and>\n   (\\<forall>q.\n       (\\<exists>j\\<ge>the (\\<pi> ?\\<chi>2).\n           the (map_option rk (Mapping.lookup y ?\\<chi>2)) q =\n           Some j) \\<longrightarrow>\n       S \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>) q))\n  dom \\<pi> \\<subseteq> \\<^bold>G \\<phi>\n\ngoal (1 subgoal):\n 1. (\\<forall>x.\n        x \\<in> (\\<lambda>\\<chi>.\n                    foldl and_abs (Abs \\<chi>)\n                     (map (\\<up>eval\\<^sub>G (dom \\<pi>))\n                       (drop (the (\\<pi> \\<chi>))\n                         (the (Mapping.lookup y \\<chi>))))) `\n                set (filter (\\<lambda>x. x \\<in> dom \\<pi>)\n                      (G_list \\<phi>)) \\<longrightarrow>\n        S \\<up>\\<Turnstile>\\<^sub>P x) =\n    (\\<forall>x.\n        x \\<in> dom \\<pi> \\<longrightarrow>\n        S \\<up>\\<Turnstile>\\<^sub>P Abs x \\<and>\n        (\\<forall>q.\n            (\\<exists>j\\<ge>the (\\<pi> x).\n                the (map_option rk (Mapping.lookup y x)) q =\n                Some j) \\<longrightarrow>\n            S \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>) q))", "by (simp add: image_def inter_set_filter[symmetric] G_eq_G_list[symmetric]; blast)"], ["proof (state)\nthis:\n  S \\<up>\\<Turnstile>\\<^sub>P M_fin\\<^sub>C_af_lhs \\<phi>\n                               (mapping.Mapping \\<pi>) y =\n  (\\<forall>\\<chi>\\<in>dom \\<pi>.\n      S \\<up>\\<Turnstile>\\<^sub>P Abs \\<chi> \\<and>\n      (\\<forall>q.\n          (\\<exists>j\\<ge>the (\\<pi> \\<chi>).\n              the (map_option rk (Mapping.lookup y \\<chi>)) q =\n              Some j) \\<longrightarrow>\n          S \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>) q))\n\ngoal (1 subgoal):\n 1. (abstract_transition t \\<in> M_fin \\<pi>) =\n    M_fin\\<^sub>C_af \\<phi> (mapping.Mapping \\<pi>) t", "}"], ["proof (state)\nthis:\n  ?S2 \\<up>\\<Turnstile>\\<^sub>P M_fin\\<^sub>C_af_lhs \\<phi>\n                                 (mapping.Mapping \\<pi>) y =\n  (\\<forall>\\<chi>\\<in>dom \\<pi>.\n      ?S2 \\<up>\\<Turnstile>\\<^sub>P Abs \\<chi> \\<and>\n      (\\<forall>q.\n          (\\<exists>j\\<ge>the (\\<pi> \\<chi>).\n              the (map_option rk (Mapping.lookup y \\<chi>)) q =\n              Some j) \\<longrightarrow>\n          ?S2 \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>) q))\n\ngoal (1 subgoal):\n 1. (abstract_transition t \\<in> M_fin \\<pi>) =\n    M_fin\\<^sub>C_af \\<phi> (mapping.Mapping \\<pi>) t", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?S2 \\<up>\\<Turnstile>\\<^sub>P M_fin\\<^sub>C_af_lhs \\<phi>\n                                 (mapping.Mapping \\<pi>) y =\n  (\\<forall>\\<chi>\\<in>dom \\<pi>.\n      ?S2 \\<up>\\<Turnstile>\\<^sub>P Abs \\<chi> \\<and>\n      (\\<forall>q.\n          (\\<exists>j\\<ge>the (\\<pi> \\<chi>).\n              the (map_option rk (Mapping.lookup y \\<chi>)) q =\n              Some j) \\<longrightarrow>\n          ?S2 \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>) q))\n\ngoal (1 subgoal):\n 1. (abstract_transition t \\<in> M_fin \\<pi>) =\n    M_fin\\<^sub>C_af \\<phi> (mapping.Mapping \\<pi>) t", "by (simp add: ltl_prop_implies_def ltl_prop_implies_abs_def ltl_prop_entails_abs_def)"], ["proof (state)\nthis:\n  (abstract_transition t \\<in> M_fin \\<pi>) =\n  M_fin\\<^sub>C_af \\<phi> (mapping.Mapping \\<pi>) t\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \n  \"ltl_to_generalized_rabin\\<^sub>C_af \\<equiv> ltl_to_rabin_base_code_def.ltl_to_generalized_rabin\\<^sub>C \\<up>af \\<up>af\\<^sub>G Abs Abs M_fin\\<^sub>C_af\""], ["", "theorem ltl_to_generalized_rabin\\<^sub>C_af_correct:\n  assumes \"range w \\<subseteq> set \\<Sigma>\"\n  shows \"w \\<Turnstile> \\<phi> \\<longleftrightarrow> accept\\<^sub>G\\<^sub>R_LTS (ltl_to_generalized_rabin\\<^sub>C_af \\<Sigma> \\<phi>) w\" \n  (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<Turnstile> \\<phi> =\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C_af \\<Sigma> \\<phi>) w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. w \\<Turnstile> \\<phi> =\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C_af \\<Sigma> \\<phi>) w", "have X: \"ltl_to_rabin_base_code \\<up>af \\<up>af\\<^sub>G Abs Abs M_fin (set \\<Sigma>) w M_fin\\<^sub>C_af\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltl_to_rabin_base_code \\<up>af \\<up>af\\<^sub>G Abs Abs M_fin\n     (set \\<Sigma>) w M_fin\\<^sub>C_af", "using ltl_to_generalized_rabin_af_wellformed[OF finite_set assms] M_fin\\<^sub>C_af_correct assms"], ["proof (prove)\nusing this:\n  ltl_to_rabin_af (set \\<Sigma>) w\n  \\<lbrakk>?t \\<in> reach\\<^sub>t ?\\<Sigma>\n                     (ltl_to_rabin_base_code_def.delta\\<^sub>C \\<up>af\n                       \\<up>af\\<^sub>G Abs ?\\<Sigma>)\n                     (ltl_to_rabin_base_code_def.initial\\<^sub>C Abs Abs\n                       ?\\<phi>);\n   dom ?\\<pi> \\<subseteq> \\<^bold>G ?\\<phi>\\<rbrakk>\n  \\<Longrightarrow> (abstract_transition ?t \\<in> M_fin ?\\<pi>) =\n                    M_fin\\<^sub>C_af ?\\<phi> (mapping.Mapping ?\\<pi>) ?t\n  range w \\<subseteq> set \\<Sigma>\n\ngoal (1 subgoal):\n 1. ltl_to_rabin_base_code \\<up>af \\<up>af\\<^sub>G Abs Abs M_fin\n     (set \\<Sigma>) w M_fin\\<^sub>C_af", "unfolding ltl_to_rabin_af_def ltl_to_rabin_base_code_def ltl_to_rabin_base_code_axioms_def"], ["proof (prove)\nusing this:\n  ltl_to_rabin_base \\<up>af \\<up>af\\<^sub>G Abs Abs M_fin (set \\<Sigma>) w\n  \\<lbrakk>?t \\<in> reach\\<^sub>t ?\\<Sigma>\n                     (ltl_to_rabin_base_code_def.delta\\<^sub>C \\<up>af\n                       \\<up>af\\<^sub>G Abs ?\\<Sigma>)\n                     (ltl_to_rabin_base_code_def.initial\\<^sub>C Abs Abs\n                       ?\\<phi>);\n   dom ?\\<pi> \\<subseteq> \\<^bold>G ?\\<phi>\\<rbrakk>\n  \\<Longrightarrow> (abstract_transition ?t \\<in> M_fin ?\\<pi>) =\n                    M_fin\\<^sub>C_af ?\\<phi> (mapping.Mapping ?\\<pi>) ?t\n  range w \\<subseteq> set \\<Sigma>\n\ngoal (1 subgoal):\n 1. ltl_to_rabin_base \\<up>af \\<up>af\\<^sub>G Abs Abs M_fin (set \\<Sigma>)\n     w \\<and>\n    (\\<forall>t \\<phi> \\<pi>.\n        t \\<in> reach\\<^sub>t (set \\<Sigma>)\n                 (ltl_to_rabin_base_code_def.delta\\<^sub>C \\<up>af\n                   \\<up>af\\<^sub>G Abs (set \\<Sigma>))\n                 (ltl_to_rabin_base_code_def.initial\\<^sub>C Abs Abs\n                   \\<phi>) \\<longrightarrow>\n        dom \\<pi> \\<subseteq> \\<^bold>G \\<phi> \\<longrightarrow>\n        (abstract_transition t \\<in> M_fin \\<pi>) =\n        M_fin\\<^sub>C_af \\<phi> (mapping.Mapping \\<pi>) t)", "by blast"], ["proof (state)\nthis:\n  ltl_to_rabin_base_code \\<up>af \\<up>af\\<^sub>G Abs Abs M_fin\n   (set \\<Sigma>) w M_fin\\<^sub>C_af\n\ngoal (1 subgoal):\n 1. w \\<Turnstile> \\<phi> =\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C_af \\<Sigma> \\<phi>) w", "have \"?lhs \\<longleftrightarrow> accept\\<^sub>G\\<^sub>R (ltl_to_generalized_rabin_af (set \\<Sigma>) \\<phi>) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<Turnstile> \\<phi> =\n    accept\\<^sub>G\\<^sub>R\n     (ltl_to_generalized_rabin_af (set \\<Sigma>) \\<phi>) w", "using assms ltl_to_generalized_rabin_af_correct"], ["proof (prove)\nusing this:\n  range w \\<subseteq> set \\<Sigma>\n  \\<lbrakk>finite ?\\<Sigma>; range ?w \\<subseteq> ?\\<Sigma>\\<rbrakk>\n  \\<Longrightarrow> ?w \\<Turnstile> ?\\<phi> =\n                    accept\\<^sub>G\\<^sub>R\n                     (ltl_to_generalized_rabin_af ?\\<Sigma> ?\\<phi>) ?w\n\ngoal (1 subgoal):\n 1. w \\<Turnstile> \\<phi> =\n    accept\\<^sub>G\\<^sub>R\n     (ltl_to_generalized_rabin_af (set \\<Sigma>) \\<phi>) w", "by auto"], ["proof (state)\nthis:\n  w \\<Turnstile> \\<phi> =\n  accept\\<^sub>G\\<^sub>R (ltl_to_generalized_rabin_af (set \\<Sigma>) \\<phi>)\n   w\n\ngoal (1 subgoal):\n 1. w \\<Turnstile> \\<phi> =\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C_af \\<Sigma> \\<phi>) w", "also"], ["proof (state)\nthis:\n  w \\<Turnstile> \\<phi> =\n  accept\\<^sub>G\\<^sub>R (ltl_to_generalized_rabin_af (set \\<Sigma>) \\<phi>)\n   w\n\ngoal (1 subgoal):\n 1. w \\<Turnstile> \\<phi> =\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C_af \\<Sigma> \\<phi>) w", "have \"\\<dots> \\<longleftrightarrow> ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. accept\\<^sub>G\\<^sub>R\n     (ltl_to_generalized_rabin_af (set \\<Sigma>) \\<phi>) w =\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C_af \\<Sigma> \\<phi>) w", "using ltl_to_rabin_base_code.ltl_to_generalized_rabin\\<^sub>C_correct[OF X]"], ["proof (prove)\nusing this:\n  set \\<Sigma> = set ?\\<Sigma>' \\<Longrightarrow>\n  accept\\<^sub>G\\<^sub>R\n   (ltl_to_rabin_base_def.ltl_to_generalized_rabin \\<up>af \\<up>af\\<^sub>G\n     Abs Abs M_fin (set \\<Sigma>) ?\\<phi>)\n   w =\n  accept\\<^sub>G\\<^sub>R_LTS\n   (ltl_to_rabin_base_code_def.ltl_to_generalized_rabin\\<^sub>C \\<up>af\n     \\<up>af\\<^sub>G Abs Abs M_fin\\<^sub>C_af ?\\<Sigma>' ?\\<phi>)\n   w\n\ngoal (1 subgoal):\n 1. accept\\<^sub>G\\<^sub>R\n     (ltl_to_generalized_rabin_af (set \\<Sigma>) \\<phi>) w =\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C_af \\<Sigma> \\<phi>) w", "unfolding ltl_to_generalized_rabin\\<^sub>C_af_def"], ["proof (prove)\nusing this:\n  set \\<Sigma> = set ?\\<Sigma>' \\<Longrightarrow>\n  accept\\<^sub>G\\<^sub>R\n   (ltl_to_rabin_base_def.ltl_to_generalized_rabin \\<up>af \\<up>af\\<^sub>G\n     Abs Abs M_fin (set \\<Sigma>) ?\\<phi>)\n   w =\n  accept\\<^sub>G\\<^sub>R_LTS\n   (ltl_to_rabin_base_code_def.ltl_to_generalized_rabin\\<^sub>C \\<up>af\n     \\<up>af\\<^sub>G Abs Abs M_fin\\<^sub>C_af ?\\<Sigma>' ?\\<phi>)\n   w\n\ngoal (1 subgoal):\n 1. accept\\<^sub>G\\<^sub>R\n     (ltl_to_generalized_rabin_af (set \\<Sigma>) \\<phi>) w =\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_rabin_base_code_def.ltl_to_generalized_rabin\\<^sub>C \\<up>af\n       \\<up>af\\<^sub>G Abs Abs M_fin\\<^sub>C_af \\<Sigma> \\<phi>)\n     w", "by simp"], ["proof (state)\nthis:\n  accept\\<^sub>G\\<^sub>R (ltl_to_generalized_rabin_af (set \\<Sigma>) \\<phi>)\n   w =\n  accept\\<^sub>G\\<^sub>R_LTS\n   (ltl_to_generalized_rabin\\<^sub>C_af \\<Sigma> \\<phi>) w\n\ngoal (1 subgoal):\n 1. w \\<Turnstile> \\<phi> =\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C_af \\<Sigma> \\<phi>) w", "finally"], ["proof (chain)\npicking this:\n  w \\<Turnstile> \\<phi> =\n  accept\\<^sub>G\\<^sub>R_LTS\n   (ltl_to_generalized_rabin\\<^sub>C_af \\<Sigma> \\<phi>) w", "show ?thesis"], ["proof (prove)\nusing this:\n  w \\<Turnstile> \\<phi> =\n  accept\\<^sub>G\\<^sub>R_LTS\n   (ltl_to_generalized_rabin\\<^sub>C_af \\<Sigma> \\<phi>) w\n\ngoal (1 subgoal):\n 1. w \\<Turnstile> \\<phi> =\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C_af \\<Sigma> \\<phi>) w", "."], ["proof (state)\nthis:\n  w \\<Turnstile> \\<phi> =\n  accept\\<^sub>G\\<^sub>R_LTS\n   (ltl_to_generalized_rabin\\<^sub>C_af \\<Sigma> \\<phi>) w\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Generalized Deterministic Rabin Automaton (eager af)\\<close>"], ["", "definition M_fin\\<^sub>C_af\\<^sub>\\<UU>_lhs :: \"'a ltl \\<Rightarrow> ('a ltl, nat) mapping \\<Rightarrow> ('a ltl, ('a ltl\\<^sub>P list)) mapping \\<Rightarrow> 'a set \\<Rightarrow> 'a ltl\\<^sub>P\"\nwhere\n  \"M_fin\\<^sub>C_af\\<^sub>\\<UU>_lhs \\<phi> \\<pi> m' \\<nu> \\<equiv> \n    let\n      \\<G> = Mapping.keys \\<pi>;\n      \\<G>\\<^sub>L = filter (\\<lambda>x. x \\<in> \\<G>) (G_list \\<phi>);\n      mk_conj = \\<lambda>\\<chi>. foldl and_abs (and_abs (Abs \\<chi>) (\\<up>eval\\<^sub>G \\<G> (Abs (theG \\<chi>)))) (map (\\<up>eval\\<^sub>G \\<G> o (\\<lambda>q. \\<up>step q \\<nu>)) (drop (the (Mapping.lookup \\<pi> \\<chi>)) (the (Mapping.lookup m' \\<chi>))))\n    in \n      \\<up>And (map mk_conj \\<G>\\<^sub>L)\""], ["", "fun M_fin\\<^sub>C_af\\<^sub>\\<UU> :: \"'a ltl \\<Rightarrow> ('a ltl, nat) mapping \\<Rightarrow> ('a ltl\\<^sub>P \\<times> (('a ltl, ('a ltl\\<^sub>P list)) mapping), 'a set) transition \\<Rightarrow> bool\"\nwhere\n  \"M_fin\\<^sub>C_af\\<^sub>\\<UU> \\<phi> \\<pi> ((\\<phi>', m'), \\<nu>, _) = Not ((M_fin\\<^sub>C_af\\<^sub>\\<UU>_lhs \\<phi> \\<pi> m' \\<nu>) \\<up>\\<longrightarrow>\\<^sub>P (\\<up>step \\<phi>' \\<nu>))\""], ["", "lemma M_fin\\<^sub>C_af\\<^sub>\\<UU>_correct:\n  assumes \"t \\<in> reach\\<^sub>t \\<Sigma> (ltl_to_rabin_base_code_def.delta\\<^sub>C \\<up>af\\<^sub>\\<UU> \\<up>af\\<^sub>G\\<^sub>\\<UU> (Abs \\<circ> Unf\\<^sub>G) \\<Sigma>) (ltl_to_rabin_base_code_def.initial\\<^sub>C (Abs \\<circ> Unf) (Abs \\<circ> Unf\\<^sub>G) \\<phi>)\"\n  assumes \"dom \\<pi> \\<subseteq> \\<^bold>G \\<phi>\"\n  shows \"abstract_transition t \\<in> M\\<^sub>\\<UU>_fin \\<pi> = M_fin\\<^sub>C_af\\<^sub>\\<UU> \\<phi> (Mapping.Mapping \\<pi>) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (abstract_transition t \\<in> M\\<^sub>\\<UU>_fin \\<pi>) =\n    M_fin\\<^sub>C_af\\<^sub>\\<UU> \\<phi> (mapping.Mapping \\<pi>) t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (abstract_transition t \\<in> M\\<^sub>\\<UU>_fin \\<pi>) =\n    M_fin\\<^sub>C_af\\<^sub>\\<UU> \\<phi> (mapping.Mapping \\<pi>) t", "let ?delta = \"ltl_to_rabin_base_code_def.delta\\<^sub>C \\<up>af\\<^sub>\\<UU> \\<up>af\\<^sub>G\\<^sub>\\<UU> (Abs \\<circ> Unf\\<^sub>G) \\<Sigma>\""], ["proof (state)\ngoal (1 subgoal):\n 1. (abstract_transition t \\<in> M\\<^sub>\\<UU>_fin \\<pi>) =\n    M_fin\\<^sub>C_af\\<^sub>\\<UU> \\<phi> (mapping.Mapping \\<pi>) t", "let ?initial = \"ltl_to_rabin_base_code_def.initial\\<^sub>C (Abs \\<circ> Unf) (Abs \\<circ> Unf\\<^sub>G) \\<phi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. (abstract_transition t \\<in> M\\<^sub>\\<UU>_fin \\<pi>) =\n    M_fin\\<^sub>C_af\\<^sub>\\<UU> \\<phi> (mapping.Mapping \\<pi>) t", "obtain x y \\<nu> z z' where t_def [simp]: \"t = ((x, y), \\<nu>, (z, z'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y \\<nu> z z'.\n        t = ((x, y), \\<nu>, z, z') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod.collapse)"], ["proof (state)\nthis:\n  t = ((x, y), \\<nu>, z, z')\n\ngoal (1 subgoal):\n 1. (abstract_transition t \\<in> M\\<^sub>\\<UU>_fin \\<pi>) =\n    M_fin\\<^sub>C_af\\<^sub>\\<UU> \\<phi> (mapping.Mapping \\<pi>) t", "have \"(x, y) \\<in> reach \\<Sigma> ?delta ?initial\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y)\n    \\<in> reach \\<Sigma>\n           (ltl_to_rabin_base_code_def.delta\\<^sub>C \\<up>af\\<^sub>\\<UU>\n             \\<up>af\\<^sub>G\\<^sub>\\<UU> (Abs \\<circ> Unf\\<^sub>G) \\<Sigma>)\n           (ltl_to_rabin_base_code_def.initial\\<^sub>C (Abs \\<circ> Unf)\n             (Abs \\<circ> Unf\\<^sub>G) \\<phi>)", "using assms(1)"], ["proof (prove)\nusing this:\n  t \\<in> reach\\<^sub>t \\<Sigma>\n           (ltl_to_rabin_base_code_def.delta\\<^sub>C \\<up>af\\<^sub>\\<UU>\n             \\<up>af\\<^sub>G\\<^sub>\\<UU> (Abs \\<circ> Unf\\<^sub>G) \\<Sigma>)\n           (ltl_to_rabin_base_code_def.initial\\<^sub>C (Abs \\<circ> Unf)\n             (Abs \\<circ> Unf\\<^sub>G) \\<phi>)\n\ngoal (1 subgoal):\n 1. (x, y)\n    \\<in> reach \\<Sigma>\n           (ltl_to_rabin_base_code_def.delta\\<^sub>C \\<up>af\\<^sub>\\<UU>\n             \\<up>af\\<^sub>G\\<^sub>\\<UU> (Abs \\<circ> Unf\\<^sub>G) \\<Sigma>)\n           (ltl_to_rabin_base_code_def.initial\\<^sub>C (Abs \\<circ> Unf)\n             (Abs \\<circ> Unf\\<^sub>G) \\<phi>)", "by (simp add: reach\\<^sub>t_def reach_def; blast)"], ["proof (state)\nthis:\n  (x, y)\n  \\<in> reach \\<Sigma>\n         (ltl_to_rabin_base_code_def.delta\\<^sub>C \\<up>af\\<^sub>\\<UU>\n           \\<up>af\\<^sub>G\\<^sub>\\<UU> (Abs \\<circ> Unf\\<^sub>G) \\<Sigma>)\n         (ltl_to_rabin_base_code_def.initial\\<^sub>C (Abs \\<circ> Unf)\n           (Abs \\<circ> Unf\\<^sub>G) \\<phi>)\n\ngoal (1 subgoal):\n 1. (abstract_transition t \\<in> M\\<^sub>\\<UU>_fin \\<pi>) =\n    M_fin\\<^sub>C_af\\<^sub>\\<UU> \\<phi> (mapping.Mapping \\<pi>) t", "hence N1: \"\\<And>\\<chi>. \\<chi> \\<in> dom \\<pi> \\<Longrightarrow> Mapping.lookup y \\<chi> \\<noteq> None\"\n    and D1: \"\\<And>\\<chi>. \\<chi> \\<in> dom \\<pi> \\<Longrightarrow> distinct (the (Mapping.lookup y \\<chi>))\""], ["proof (prove)\nusing this:\n  (x, y)\n  \\<in> reach \\<Sigma>\n         (ltl_to_rabin_base_code_def.delta\\<^sub>C \\<up>af\\<^sub>\\<UU>\n           \\<up>af\\<^sub>G\\<^sub>\\<UU> (Abs \\<circ> Unf\\<^sub>G) \\<Sigma>)\n         (ltl_to_rabin_base_code_def.initial\\<^sub>C (Abs \\<circ> Unf)\n           (Abs \\<circ> Unf\\<^sub>G) \\<phi>)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<chi>.\n        \\<chi> \\<in> dom \\<pi> \\<Longrightarrow>\n        Mapping.lookup y \\<chi> \\<noteq> None) &&&\n    (\\<And>\\<chi>.\n        \\<chi> \\<in> dom \\<pi> \\<Longrightarrow>\n        distinct (the (Mapping.lookup y \\<chi>)))", "using assms(2)"], ["proof (prove)\nusing this:\n  (x, y)\n  \\<in> reach \\<Sigma>\n         (ltl_to_rabin_base_code_def.delta\\<^sub>C \\<up>af\\<^sub>\\<UU>\n           \\<up>af\\<^sub>G\\<^sub>\\<UU> (Abs \\<circ> Unf\\<^sub>G) \\<Sigma>)\n         (ltl_to_rabin_base_code_def.initial\\<^sub>C (Abs \\<circ> Unf)\n           (Abs \\<circ> Unf\\<^sub>G) \\<phi>)\n  dom \\<pi> \\<subseteq> \\<^bold>G \\<phi>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<chi>.\n        \\<chi> \\<in> dom \\<pi> \\<Longrightarrow>\n        Mapping.lookup y \\<chi> \\<noteq> None) &&&\n    (\\<And>\\<chi>.\n        \\<chi> \\<in> dom \\<pi> \\<Longrightarrow>\n        distinct (the (Mapping.lookup y \\<chi>)))", "by (blast dest: ltl_to_rabin_base_code_def.reach_delta_initial)+"], ["proof (state)\nthis:\n  ?\\<chi> \\<in> dom \\<pi> \\<Longrightarrow>\n  Mapping.lookup y ?\\<chi> \\<noteq> None\n  ?\\<chi> \\<in> dom \\<pi> \\<Longrightarrow>\n  distinct (the (Mapping.lookup y ?\\<chi>))\n\ngoal (1 subgoal):\n 1. (abstract_transition t \\<in> M\\<^sub>\\<UU>_fin \\<pi>) =\n    M_fin\\<^sub>C_af\\<^sub>\\<UU> \\<phi> (mapping.Mapping \\<pi>) t", "{"], ["proof (state)\nthis:\n  ?\\<chi> \\<in> dom \\<pi> \\<Longrightarrow>\n  Mapping.lookup y ?\\<chi> \\<noteq> None\n  ?\\<chi> \\<in> dom \\<pi> \\<Longrightarrow>\n  distinct (the (Mapping.lookup y ?\\<chi>))\n\ngoal (1 subgoal):\n 1. (abstract_transition t \\<in> M\\<^sub>\\<UU>_fin \\<pi>) =\n    M_fin\\<^sub>C_af\\<^sub>\\<UU> \\<phi> (mapping.Mapping \\<pi>) t", "fix S"], ["proof (state)\ngoal (1 subgoal):\n 1. (abstract_transition t \\<in> M\\<^sub>\\<UU>_fin \\<pi>) =\n    M_fin\\<^sub>C_af\\<^sub>\\<UU> \\<phi> (mapping.Mapping \\<pi>) t", "let ?m' = \"\\<lambda>\\<chi>. map_option rk (Mapping.lookup y \\<chi>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (abstract_transition t \\<in> M\\<^sub>\\<UU>_fin \\<pi>) =\n    M_fin\\<^sub>C_af\\<^sub>\\<UU> \\<phi> (mapping.Mapping \\<pi>) t", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (abstract_transition t \\<in> M\\<^sub>\\<UU>_fin \\<pi>) =\n    M_fin\\<^sub>C_af\\<^sub>\\<UU> \\<phi> (mapping.Mapping \\<pi>) t", "fix \\<chi>"], ["proof (state)\ngoal (1 subgoal):\n 1. (abstract_transition t \\<in> M\\<^sub>\\<UU>_fin \\<pi>) =\n    M_fin\\<^sub>C_af\\<^sub>\\<UU> \\<phi> (mapping.Mapping \\<pi>) t", "assume \"\\<chi> \\<in> dom \\<pi>\""], ["proof (state)\nthis:\n  \\<chi> \\<in> dom \\<pi>\n\ngoal (1 subgoal):\n 1. (abstract_transition t \\<in> M\\<^sub>\\<UU>_fin \\<pi>) =\n    M_fin\\<^sub>C_af\\<^sub>\\<UU> \\<phi> (mapping.Mapping \\<pi>) t", "hence \"S \\<up>\\<Turnstile>\\<^sub>P (foldl and_abs (and_abs (Abs \\<chi>) (\\<up>eval\\<^sub>G (dom \\<pi>) (Abs (theG \\<chi>)))) (map (\\<up>eval\\<^sub>G (dom \\<pi>) o (\\<lambda>q. \\<up>step q \\<nu>)) (drop (the (\\<pi> \\<chi>)) (the (Mapping.lookup y \\<chi>)))))\n         \\<longleftrightarrow> S \\<up>\\<Turnstile>\\<^sub>P Abs \\<chi> \\<and> S \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>) (Abs (theG \\<chi>)) \\<and> (\\<forall>q. (\\<exists>j \\<ge> the (\\<pi> \\<chi>). the (?m' \\<chi>) q = Some j) \\<longrightarrow> S \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>) (\\<up>step q \\<nu>))\""], ["proof (prove)\nusing this:\n  \\<chi> \\<in> dom \\<pi>\n\ngoal (1 subgoal):\n 1. S \\<up>\\<Turnstile>\\<^sub>P foldl and_abs\n                                 Abs \\<chi> \\<up>and \\<up>eval\\<^sub>G\n                (dom \\<pi>) (Abs (theG \\<chi>))\n                                 (map (\\<up>eval\\<^sub>G (dom \\<pi>) \\<circ>\n (\\<lambda>q. \\<up>step q \\<nu>))\n                                   (drop (the (\\<pi> \\<chi>))\n                                     (the (Mapping.lookup y \\<chi>)))) =\n    (S \\<up>\\<Turnstile>\\<^sub>P Abs \\<chi> \\<and>\n     S \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>)\n                                  (Abs (theG \\<chi>)) \\<and>\n     (\\<forall>q.\n         (\\<exists>j\\<ge>the (\\<pi> \\<chi>).\n             the (map_option rk (Mapping.lookup y \\<chi>)) q =\n             Some j) \\<longrightarrow>\n         S \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>)\n(\\<up>step q \\<nu>)))", "using D1[THEN drop_rk, of _ \"the (\\<pi> \\<chi>)\"] N1[THEN option.map_sel, of _ rk]"], ["proof (prove)\nusing this:\n  \\<chi> \\<in> dom \\<pi>\n  ?\\<chi>1 \\<in> dom \\<pi> \\<Longrightarrow>\n  set (drop (the (\\<pi> \\<chi>)) (the (Mapping.lookup y ?\\<chi>1))) =\n  {q. \\<exists>j\\<ge>the (\\<pi> \\<chi>).\n         rk (the (Mapping.lookup y ?\\<chi>1)) q = Some j}\n  ?\\<chi>1 \\<in> dom \\<pi> \\<Longrightarrow>\n  the (map_option rk (Mapping.lookup y ?\\<chi>1)) =\n  rk (the (Mapping.lookup y ?\\<chi>1))\n\ngoal (1 subgoal):\n 1. S \\<up>\\<Turnstile>\\<^sub>P foldl and_abs\n                                 Abs \\<chi> \\<up>and \\<up>eval\\<^sub>G\n                (dom \\<pi>) (Abs (theG \\<chi>))\n                                 (map (\\<up>eval\\<^sub>G (dom \\<pi>) \\<circ>\n (\\<lambda>q. \\<up>step q \\<nu>))\n                                   (drop (the (\\<pi> \\<chi>))\n                                     (the (Mapping.lookup y \\<chi>)))) =\n    (S \\<up>\\<Turnstile>\\<^sub>P Abs \\<chi> \\<and>\n     S \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>)\n                                  (Abs (theG \\<chi>)) \\<and>\n     (\\<forall>q.\n         (\\<exists>j\\<ge>the (\\<pi> \\<chi>).\n             the (map_option rk (Mapping.lookup y \\<chi>)) q =\n             Some j) \\<longrightarrow>\n         S \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>)\n(\\<up>step q \\<nu>)))", "by (auto simp add: foldl_LTLAnd_prop_entailment_abs and_abs_conjunction simp del: rk.simps)"], ["proof (state)\nthis:\n  S \\<up>\\<Turnstile>\\<^sub>P foldl and_abs\n                               Abs \\<chi> \\<up>and \\<up>eval\\<^sub>G\n              (dom \\<pi>) (Abs (theG \\<chi>))\n                               (map (\\<up>eval\\<^sub>G (dom \\<pi>) \\<circ>\n                                     (\\<lambda>q. \\<up>step q \\<nu>))\n                                 (drop (the (\\<pi> \\<chi>))\n                                   (the (Mapping.lookup y \\<chi>)))) =\n  (S \\<up>\\<Turnstile>\\<^sub>P Abs \\<chi> \\<and>\n   S \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>)\n                                (Abs (theG \\<chi>)) \\<and>\n   (\\<forall>q.\n       (\\<exists>j\\<ge>the (\\<pi> \\<chi>).\n           the (map_option rk (Mapping.lookup y \\<chi>)) q =\n           Some j) \\<longrightarrow>\n       S \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>)\n                                    (\\<up>step q \\<nu>)))\n\ngoal (1 subgoal):\n 1. (abstract_transition t \\<in> M\\<^sub>\\<UU>_fin \\<pi>) =\n    M_fin\\<^sub>C_af\\<^sub>\\<UU> \\<phi> (mapping.Mapping \\<pi>) t", "}"], ["proof (state)\nthis:\n  ?\\<chi>2 \\<in> dom \\<pi> \\<Longrightarrow>\n  S \\<up>\\<Turnstile>\\<^sub>P foldl and_abs\n                               Abs ?\\<chi>2 \\<up>and \\<up>eval\\<^sub>G\n                (dom \\<pi>) (Abs (theG ?\\<chi>2))\n                               (map (\\<up>eval\\<^sub>G (dom \\<pi>) \\<circ>\n                                     (\\<lambda>q. \\<up>step q \\<nu>))\n                                 (drop (the (\\<pi> ?\\<chi>2))\n                                   (the (Mapping.lookup y ?\\<chi>2)))) =\n  (S \\<up>\\<Turnstile>\\<^sub>P Abs ?\\<chi>2 \\<and>\n   S \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>)\n                                (Abs (theG ?\\<chi>2)) \\<and>\n   (\\<forall>q.\n       (\\<exists>j\\<ge>the (\\<pi> ?\\<chi>2).\n           the (map_option rk (Mapping.lookup y ?\\<chi>2)) q =\n           Some j) \\<longrightarrow>\n       S \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>)\n                                    (\\<up>step q \\<nu>)))\n\ngoal (1 subgoal):\n 1. (abstract_transition t \\<in> M\\<^sub>\\<UU>_fin \\<pi>) =\n    M_fin\\<^sub>C_af\\<^sub>\\<UU> \\<phi> (mapping.Mapping \\<pi>) t", "hence \"S \\<up>\\<Turnstile>\\<^sub>P (M_fin\\<^sub>C_af\\<^sub>\\<UU>_lhs \\<phi> (Mapping.Mapping \\<pi>) y \\<nu>)\n      \\<longleftrightarrow> ((\\<forall>\\<chi> \\<in> dom \\<pi>. (S \\<up>\\<Turnstile>\\<^sub>P Abs \\<chi> \\<and> S \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>) (Abs (theG \\<chi>)) \\<and> (\\<forall>q. (\\<exists>j \\<ge> the (\\<pi> \\<chi>). the (?m' \\<chi>) q = Some j) \\<longrightarrow> S \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>) (\\<up>step q \\<nu>)))))\""], ["proof (prove)\nusing this:\n  ?\\<chi>2 \\<in> dom \\<pi> \\<Longrightarrow>\n  S \\<up>\\<Turnstile>\\<^sub>P foldl and_abs\n                               Abs ?\\<chi>2 \\<up>and \\<up>eval\\<^sub>G\n                (dom \\<pi>) (Abs (theG ?\\<chi>2))\n                               (map (\\<up>eval\\<^sub>G (dom \\<pi>) \\<circ>\n                                     (\\<lambda>q. \\<up>step q \\<nu>))\n                                 (drop (the (\\<pi> ?\\<chi>2))\n                                   (the (Mapping.lookup y ?\\<chi>2)))) =\n  (S \\<up>\\<Turnstile>\\<^sub>P Abs ?\\<chi>2 \\<and>\n   S \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>)\n                                (Abs (theG ?\\<chi>2)) \\<and>\n   (\\<forall>q.\n       (\\<exists>j\\<ge>the (\\<pi> ?\\<chi>2).\n           the (map_option rk (Mapping.lookup y ?\\<chi>2)) q =\n           Some j) \\<longrightarrow>\n       S \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>)\n                                    (\\<up>step q \\<nu>)))\n\ngoal (1 subgoal):\n 1. S \\<up>\\<Turnstile>\\<^sub>P M_fin\\<^sub>C_af\\<^sub>\\<UU>_lhs \\<phi>\n                                 (mapping.Mapping \\<pi>) y \\<nu> =\n    (\\<forall>\\<chi>\\<in>dom \\<pi>.\n        S \\<up>\\<Turnstile>\\<^sub>P Abs \\<chi> \\<and>\n        S \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>)\n                                     (Abs (theG \\<chi>)) \\<and>\n        (\\<forall>q.\n            (\\<exists>j\\<ge>the (\\<pi> \\<chi>).\n                the (map_option rk (Mapping.lookup y \\<chi>)) q =\n                Some j) \\<longrightarrow>\n            S \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>)\n   (\\<up>step q \\<nu>)))", "unfolding M_fin\\<^sub>C_af\\<^sub>\\<UU>_lhs_def Let_def And_prop_entailment_abs set_map Ball_def keys.abs_eq lookup.abs_eq"], ["proof (prove)\nusing this:\n  ?\\<chi>2 \\<in> dom \\<pi> \\<Longrightarrow>\n  S \\<up>\\<Turnstile>\\<^sub>P foldl and_abs\n                               Abs ?\\<chi>2 \\<up>and \\<up>eval\\<^sub>G\n                (dom \\<pi>) (Abs (theG ?\\<chi>2))\n                               (map (\\<up>eval\\<^sub>G (dom \\<pi>) \\<circ>\n                                     (\\<lambda>q. \\<up>step q \\<nu>))\n                                 (drop (the (\\<pi> ?\\<chi>2))\n                                   (the (Mapping.lookup y ?\\<chi>2)))) =\n  (S \\<up>\\<Turnstile>\\<^sub>P Abs ?\\<chi>2 \\<and>\n   S \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>)\n                                (Abs (theG ?\\<chi>2)) \\<and>\n   (\\<forall>q.\n       (\\<exists>j\\<ge>the (\\<pi> ?\\<chi>2).\n           the (map_option rk (Mapping.lookup y ?\\<chi>2)) q =\n           Some j) \\<longrightarrow>\n       S \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>)\n                                    (\\<up>step q \\<nu>)))\n\ngoal (1 subgoal):\n 1. (\\<forall>x.\n        x \\<in> (\\<lambda>\\<chi>.\n                    foldl and_abs\n                     Abs \\<chi> \\<up>and \\<up>eval\\<^sub>G (dom \\<pi>)\n    (Abs (theG \\<chi>))\n                     (map (\\<up>eval\\<^sub>G (dom \\<pi>) \\<circ>\n                           (\\<lambda>q. \\<up>step q \\<nu>))\n                       (drop (the (\\<pi> \\<chi>))\n                         (the (Mapping.lookup y \\<chi>))))) `\n                set (filter (\\<lambda>x. x \\<in> dom \\<pi>)\n                      (G_list \\<phi>)) \\<longrightarrow>\n        S \\<up>\\<Turnstile>\\<^sub>P x) =\n    (\\<forall>x.\n        x \\<in> dom \\<pi> \\<longrightarrow>\n        S \\<up>\\<Turnstile>\\<^sub>P Abs x \\<and>\n        S \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>)\n                                     (Abs (theG x)) \\<and>\n        (\\<forall>q.\n            (\\<exists>j\\<ge>the (\\<pi> x).\n                the (map_option rk (Mapping.lookup y x)) q =\n                Some j) \\<longrightarrow>\n            S \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>)\n   (\\<up>step q \\<nu>)))", "using assms(2)"], ["proof (prove)\nusing this:\n  ?\\<chi>2 \\<in> dom \\<pi> \\<Longrightarrow>\n  S \\<up>\\<Turnstile>\\<^sub>P foldl and_abs\n                               Abs ?\\<chi>2 \\<up>and \\<up>eval\\<^sub>G\n                (dom \\<pi>) (Abs (theG ?\\<chi>2))\n                               (map (\\<up>eval\\<^sub>G (dom \\<pi>) \\<circ>\n                                     (\\<lambda>q. \\<up>step q \\<nu>))\n                                 (drop (the (\\<pi> ?\\<chi>2))\n                                   (the (Mapping.lookup y ?\\<chi>2)))) =\n  (S \\<up>\\<Turnstile>\\<^sub>P Abs ?\\<chi>2 \\<and>\n   S \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>)\n                                (Abs (theG ?\\<chi>2)) \\<and>\n   (\\<forall>q.\n       (\\<exists>j\\<ge>the (\\<pi> ?\\<chi>2).\n           the (map_option rk (Mapping.lookup y ?\\<chi>2)) q =\n           Some j) \\<longrightarrow>\n       S \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>)\n                                    (\\<up>step q \\<nu>)))\n  dom \\<pi> \\<subseteq> \\<^bold>G \\<phi>\n\ngoal (1 subgoal):\n 1. (\\<forall>x.\n        x \\<in> (\\<lambda>\\<chi>.\n                    foldl and_abs\n                     Abs \\<chi> \\<up>and \\<up>eval\\<^sub>G (dom \\<pi>)\n    (Abs (theG \\<chi>))\n                     (map (\\<up>eval\\<^sub>G (dom \\<pi>) \\<circ>\n                           (\\<lambda>q. \\<up>step q \\<nu>))\n                       (drop (the (\\<pi> \\<chi>))\n                         (the (Mapping.lookup y \\<chi>))))) `\n                set (filter (\\<lambda>x. x \\<in> dom \\<pi>)\n                      (G_list \\<phi>)) \\<longrightarrow>\n        S \\<up>\\<Turnstile>\\<^sub>P x) =\n    (\\<forall>x.\n        x \\<in> dom \\<pi> \\<longrightarrow>\n        S \\<up>\\<Turnstile>\\<^sub>P Abs x \\<and>\n        S \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>)\n                                     (Abs (theG x)) \\<and>\n        (\\<forall>q.\n            (\\<exists>j\\<ge>the (\\<pi> x).\n                the (map_option rk (Mapping.lookup y x)) q =\n                Some j) \\<longrightarrow>\n            S \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>)\n   (\\<up>step q \\<nu>)))", "by (simp add: image_def inter_set_filter[symmetric] G_eq_G_list[symmetric]; blast)"], ["proof (state)\nthis:\n  S \\<up>\\<Turnstile>\\<^sub>P M_fin\\<^sub>C_af\\<^sub>\\<UU>_lhs \\<phi>\n                               (mapping.Mapping \\<pi>) y \\<nu> =\n  (\\<forall>\\<chi>\\<in>dom \\<pi>.\n      S \\<up>\\<Turnstile>\\<^sub>P Abs \\<chi> \\<and>\n      S \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>)\n                                   (Abs (theG \\<chi>)) \\<and>\n      (\\<forall>q.\n          (\\<exists>j\\<ge>the (\\<pi> \\<chi>).\n              the (map_option rk (Mapping.lookup y \\<chi>)) q =\n              Some j) \\<longrightarrow>\n          S \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>)\n (\\<up>step q \\<nu>)))\n\ngoal (1 subgoal):\n 1. (abstract_transition t \\<in> M\\<^sub>\\<UU>_fin \\<pi>) =\n    M_fin\\<^sub>C_af\\<^sub>\\<UU> \\<phi> (mapping.Mapping \\<pi>) t", "}"], ["proof (state)\nthis:\n  ?S2 \\<up>\\<Turnstile>\\<^sub>P M_fin\\<^sub>C_af\\<^sub>\\<UU>_lhs \\<phi>\n                                 (mapping.Mapping \\<pi>) y \\<nu> =\n  (\\<forall>\\<chi>\\<in>dom \\<pi>.\n      ?S2 \\<up>\\<Turnstile>\\<^sub>P Abs \\<chi> \\<and>\n      ?S2 \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>)\n                                     (Abs (theG \\<chi>)) \\<and>\n      (\\<forall>q.\n          (\\<exists>j\\<ge>the (\\<pi> \\<chi>).\n              the (map_option rk (Mapping.lookup y \\<chi>)) q =\n              Some j) \\<longrightarrow>\n          ?S2 \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>)\n   (\\<up>step q \\<nu>)))\n\ngoal (1 subgoal):\n 1. (abstract_transition t \\<in> M\\<^sub>\\<UU>_fin \\<pi>) =\n    M_fin\\<^sub>C_af\\<^sub>\\<UU> \\<phi> (mapping.Mapping \\<pi>) t", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?S2 \\<up>\\<Turnstile>\\<^sub>P M_fin\\<^sub>C_af\\<^sub>\\<UU>_lhs \\<phi>\n                                 (mapping.Mapping \\<pi>) y \\<nu> =\n  (\\<forall>\\<chi>\\<in>dom \\<pi>.\n      ?S2 \\<up>\\<Turnstile>\\<^sub>P Abs \\<chi> \\<and>\n      ?S2 \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>)\n                                     (Abs (theG \\<chi>)) \\<and>\n      (\\<forall>q.\n          (\\<exists>j\\<ge>the (\\<pi> \\<chi>).\n              the (map_option rk (Mapping.lookup y \\<chi>)) q =\n              Some j) \\<longrightarrow>\n          ?S2 \\<up>\\<Turnstile>\\<^sub>P \\<up>eval\\<^sub>G (dom \\<pi>)\n   (\\<up>step q \\<nu>)))\n\ngoal (1 subgoal):\n 1. (abstract_transition t \\<in> M\\<^sub>\\<UU>_fin \\<pi>) =\n    M_fin\\<^sub>C_af\\<^sub>\\<UU> \\<phi> (mapping.Mapping \\<pi>) t", "by (simp add: ltl_prop_implies_def ltl_prop_implies_abs_def ltl_prop_entails_abs_def)"], ["proof (state)\nthis:\n  (abstract_transition t \\<in> M\\<^sub>\\<UU>_fin \\<pi>) =\n  M_fin\\<^sub>C_af\\<^sub>\\<UU> \\<phi> (mapping.Mapping \\<pi>) t\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \n  \"ltl_to_generalized_rabin\\<^sub>C_af\\<^sub>\\<UU> \\<equiv> ltl_to_rabin_base_code_def.ltl_to_generalized_rabin\\<^sub>C \\<up>af\\<^sub>\\<UU> \\<up>af\\<^sub>G\\<^sub>\\<UU> (Abs \\<circ> Unf) (Abs \\<circ> Unf\\<^sub>G) M_fin\\<^sub>C_af\\<^sub>\\<UU>\""], ["", "theorem ltl_to_generalized_rabin\\<^sub>C_af\\<^sub>\\<UU>_correct:\n  assumes \"range w \\<subseteq> set \\<Sigma>\"\n  shows \"w \\<Turnstile> \\<phi> \\<longleftrightarrow> accept\\<^sub>G\\<^sub>R_LTS (ltl_to_generalized_rabin\\<^sub>C_af\\<^sub>\\<UU> \\<Sigma> \\<phi>) w\" \n  (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<Turnstile> \\<phi> =\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C_af\\<^sub>\\<UU> \\<Sigma> \\<phi>) w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. w \\<Turnstile> \\<phi> =\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C_af\\<^sub>\\<UU> \\<Sigma> \\<phi>) w", "have X: \"ltl_to_rabin_base_code \\<up>af\\<^sub>\\<UU> \\<up>af\\<^sub>G\\<^sub>\\<UU> (Abs \\<circ> Unf) (Abs \\<circ> Unf\\<^sub>G) M\\<^sub>\\<UU>_fin (set \\<Sigma>) w M_fin\\<^sub>C_af\\<^sub>\\<UU>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltl_to_rabin_base_code \\<up>af\\<^sub>\\<UU> \\<up>af\\<^sub>G\\<^sub>\\<UU>\n     (Abs \\<circ> Unf) (Abs \\<circ> Unf\\<^sub>G) M\\<^sub>\\<UU>_fin\n     (set \\<Sigma>) w M_fin\\<^sub>C_af\\<^sub>\\<UU>", "using ltl_to_generalized_rabin_af\\<^sub>\\<UU>_wellformed[OF finite_set assms] M_fin\\<^sub>C_af\\<^sub>\\<UU>_correct assms"], ["proof (prove)\nusing this:\n  ltl_to_rabin_af_unf (set \\<Sigma>) w\n  \\<lbrakk>?t \\<in> reach\\<^sub>t ?\\<Sigma>\n                     (ltl_to_rabin_base_code_def.delta\\<^sub>C\n                       \\<up>af\\<^sub>\\<UU> \\<up>af\\<^sub>G\\<^sub>\\<UU>\n                       (Abs \\<circ> Unf\\<^sub>G) ?\\<Sigma>)\n                     (ltl_to_rabin_base_code_def.initial\\<^sub>C\n                       (Abs \\<circ> Unf) (Abs \\<circ> Unf\\<^sub>G) ?\\<phi>);\n   dom ?\\<pi> \\<subseteq> \\<^bold>G ?\\<phi>\\<rbrakk>\n  \\<Longrightarrow> (abstract_transition ?t\n                     \\<in> M\\<^sub>\\<UU>_fin ?\\<pi>) =\n                    M_fin\\<^sub>C_af\\<^sub>\\<UU> ?\\<phi>\n                     (mapping.Mapping ?\\<pi>) ?t\n  range w \\<subseteq> set \\<Sigma>\n\ngoal (1 subgoal):\n 1. ltl_to_rabin_base_code \\<up>af\\<^sub>\\<UU> \\<up>af\\<^sub>G\\<^sub>\\<UU>\n     (Abs \\<circ> Unf) (Abs \\<circ> Unf\\<^sub>G) M\\<^sub>\\<UU>_fin\n     (set \\<Sigma>) w M_fin\\<^sub>C_af\\<^sub>\\<UU>", "unfolding ltl_to_rabin_af_unf_def ltl_to_rabin_base_code_def ltl_to_rabin_base_code_axioms_def"], ["proof (prove)\nusing this:\n  ltl_to_rabin_base \\<up>af\\<^sub>\\<UU> \\<up>af\\<^sub>G\\<^sub>\\<UU>\n   (Abs \\<circ> Unf) (Abs \\<circ> Unf\\<^sub>G) M\\<^sub>\\<UU>_fin\n   (set \\<Sigma>) w\n  \\<lbrakk>?t \\<in> reach\\<^sub>t ?\\<Sigma>\n                     (ltl_to_rabin_base_code_def.delta\\<^sub>C\n                       \\<up>af\\<^sub>\\<UU> \\<up>af\\<^sub>G\\<^sub>\\<UU>\n                       (Abs \\<circ> Unf\\<^sub>G) ?\\<Sigma>)\n                     (ltl_to_rabin_base_code_def.initial\\<^sub>C\n                       (Abs \\<circ> Unf) (Abs \\<circ> Unf\\<^sub>G) ?\\<phi>);\n   dom ?\\<pi> \\<subseteq> \\<^bold>G ?\\<phi>\\<rbrakk>\n  \\<Longrightarrow> (abstract_transition ?t\n                     \\<in> M\\<^sub>\\<UU>_fin ?\\<pi>) =\n                    M_fin\\<^sub>C_af\\<^sub>\\<UU> ?\\<phi>\n                     (mapping.Mapping ?\\<pi>) ?t\n  range w \\<subseteq> set \\<Sigma>\n\ngoal (1 subgoal):\n 1. ltl_to_rabin_base \\<up>af\\<^sub>\\<UU> \\<up>af\\<^sub>G\\<^sub>\\<UU>\n     (Abs \\<circ> Unf) (Abs \\<circ> Unf\\<^sub>G) M\\<^sub>\\<UU>_fin\n     (set \\<Sigma>) w \\<and>\n    (\\<forall>t \\<phi> \\<pi>.\n        t \\<in> reach\\<^sub>t (set \\<Sigma>)\n                 (ltl_to_rabin_base_code_def.delta\\<^sub>C\n                   \\<up>af\\<^sub>\\<UU> \\<up>af\\<^sub>G\\<^sub>\\<UU>\n                   (Abs \\<circ> Unf\\<^sub>G) (set \\<Sigma>))\n                 (ltl_to_rabin_base_code_def.initial\\<^sub>C\n                   (Abs \\<circ> Unf) (Abs \\<circ> Unf\\<^sub>G)\n                   \\<phi>) \\<longrightarrow>\n        dom \\<pi> \\<subseteq> \\<^bold>G \\<phi> \\<longrightarrow>\n        (abstract_transition t \\<in> M\\<^sub>\\<UU>_fin \\<pi>) =\n        M_fin\\<^sub>C_af\\<^sub>\\<UU> \\<phi> (mapping.Mapping \\<pi>) t)", "by blast"], ["proof (state)\nthis:\n  ltl_to_rabin_base_code \\<up>af\\<^sub>\\<UU> \\<up>af\\<^sub>G\\<^sub>\\<UU>\n   (Abs \\<circ> Unf) (Abs \\<circ> Unf\\<^sub>G) M\\<^sub>\\<UU>_fin\n   (set \\<Sigma>) w M_fin\\<^sub>C_af\\<^sub>\\<UU>\n\ngoal (1 subgoal):\n 1. w \\<Turnstile> \\<phi> =\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C_af\\<^sub>\\<UU> \\<Sigma> \\<phi>) w", "have \"?lhs \\<longleftrightarrow> accept\\<^sub>G\\<^sub>R (ltl_to_generalized_rabin_af\\<^sub>\\<UU> (set \\<Sigma>) \\<phi>) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<Turnstile> \\<phi> =\n    accept\\<^sub>G\\<^sub>R\n     (ltl_to_generalized_rabin_af\\<^sub>\\<UU> (set \\<Sigma>) \\<phi>) w", "using assms ltl_to_generalized_rabin_af\\<^sub>\\<UU>_correct"], ["proof (prove)\nusing this:\n  range w \\<subseteq> set \\<Sigma>\n  \\<lbrakk>finite ?\\<Sigma>; range ?w \\<subseteq> ?\\<Sigma>\\<rbrakk>\n  \\<Longrightarrow> ?w \\<Turnstile> ?\\<phi> =\n                    accept\\<^sub>G\\<^sub>R\n                     (ltl_to_generalized_rabin_af\\<^sub>\\<UU> ?\\<Sigma>\n                       ?\\<phi>)\n                     ?w\n\ngoal (1 subgoal):\n 1. w \\<Turnstile> \\<phi> =\n    accept\\<^sub>G\\<^sub>R\n     (ltl_to_generalized_rabin_af\\<^sub>\\<UU> (set \\<Sigma>) \\<phi>) w", "by auto"], ["proof (state)\nthis:\n  w \\<Turnstile> \\<phi> =\n  accept\\<^sub>G\\<^sub>R\n   (ltl_to_generalized_rabin_af\\<^sub>\\<UU> (set \\<Sigma>) \\<phi>) w\n\ngoal (1 subgoal):\n 1. w \\<Turnstile> \\<phi> =\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C_af\\<^sub>\\<UU> \\<Sigma> \\<phi>) w", "also"], ["proof (state)\nthis:\n  w \\<Turnstile> \\<phi> =\n  accept\\<^sub>G\\<^sub>R\n   (ltl_to_generalized_rabin_af\\<^sub>\\<UU> (set \\<Sigma>) \\<phi>) w\n\ngoal (1 subgoal):\n 1. w \\<Turnstile> \\<phi> =\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C_af\\<^sub>\\<UU> \\<Sigma> \\<phi>) w", "have \"\\<dots> \\<longleftrightarrow> ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. accept\\<^sub>G\\<^sub>R\n     (ltl_to_generalized_rabin_af\\<^sub>\\<UU> (set \\<Sigma>) \\<phi>) w =\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C_af\\<^sub>\\<UU> \\<Sigma> \\<phi>) w", "using ltl_to_rabin_base_code.ltl_to_generalized_rabin\\<^sub>C_correct[OF X]"], ["proof (prove)\nusing this:\n  set \\<Sigma> = set ?\\<Sigma>' \\<Longrightarrow>\n  accept\\<^sub>G\\<^sub>R\n   (ltl_to_rabin_base_def.ltl_to_generalized_rabin \\<up>af\\<^sub>\\<UU>\n     \\<up>af\\<^sub>G\\<^sub>\\<UU> (Abs \\<circ> Unf) (Abs \\<circ> Unf\\<^sub>G)\n     M\\<^sub>\\<UU>_fin (set \\<Sigma>) ?\\<phi>)\n   w =\n  accept\\<^sub>G\\<^sub>R_LTS\n   (ltl_to_rabin_base_code_def.ltl_to_generalized_rabin\\<^sub>C\n     \\<up>af\\<^sub>\\<UU> \\<up>af\\<^sub>G\\<^sub>\\<UU> (Abs \\<circ> Unf)\n     (Abs \\<circ> Unf\\<^sub>G) M_fin\\<^sub>C_af\\<^sub>\\<UU> ?\\<Sigma>'\n     ?\\<phi>)\n   w\n\ngoal (1 subgoal):\n 1. accept\\<^sub>G\\<^sub>R\n     (ltl_to_generalized_rabin_af\\<^sub>\\<UU> (set \\<Sigma>) \\<phi>) w =\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C_af\\<^sub>\\<UU> \\<Sigma> \\<phi>) w", "unfolding ltl_to_generalized_rabin\\<^sub>C_af\\<^sub>\\<UU>_def"], ["proof (prove)\nusing this:\n  set \\<Sigma> = set ?\\<Sigma>' \\<Longrightarrow>\n  accept\\<^sub>G\\<^sub>R\n   (ltl_to_rabin_base_def.ltl_to_generalized_rabin \\<up>af\\<^sub>\\<UU>\n     \\<up>af\\<^sub>G\\<^sub>\\<UU> (Abs \\<circ> Unf) (Abs \\<circ> Unf\\<^sub>G)\n     M\\<^sub>\\<UU>_fin (set \\<Sigma>) ?\\<phi>)\n   w =\n  accept\\<^sub>G\\<^sub>R_LTS\n   (ltl_to_rabin_base_code_def.ltl_to_generalized_rabin\\<^sub>C\n     \\<up>af\\<^sub>\\<UU> \\<up>af\\<^sub>G\\<^sub>\\<UU> (Abs \\<circ> Unf)\n     (Abs \\<circ> Unf\\<^sub>G) M_fin\\<^sub>C_af\\<^sub>\\<UU> ?\\<Sigma>'\n     ?\\<phi>)\n   w\n\ngoal (1 subgoal):\n 1. accept\\<^sub>G\\<^sub>R\n     (ltl_to_generalized_rabin_af\\<^sub>\\<UU> (set \\<Sigma>) \\<phi>) w =\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_rabin_base_code_def.ltl_to_generalized_rabin\\<^sub>C\n       \\<up>af\\<^sub>\\<UU> \\<up>af\\<^sub>G\\<^sub>\\<UU> (Abs \\<circ> Unf)\n       (Abs \\<circ> Unf\\<^sub>G) M_fin\\<^sub>C_af\\<^sub>\\<UU> \\<Sigma>\n       \\<phi>)\n     w", "by simp"], ["proof (state)\nthis:\n  accept\\<^sub>G\\<^sub>R\n   (ltl_to_generalized_rabin_af\\<^sub>\\<UU> (set \\<Sigma>) \\<phi>) w =\n  accept\\<^sub>G\\<^sub>R_LTS\n   (ltl_to_generalized_rabin\\<^sub>C_af\\<^sub>\\<UU> \\<Sigma> \\<phi>) w\n\ngoal (1 subgoal):\n 1. w \\<Turnstile> \\<phi> =\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C_af\\<^sub>\\<UU> \\<Sigma> \\<phi>) w", "finally"], ["proof (chain)\npicking this:\n  w \\<Turnstile> \\<phi> =\n  accept\\<^sub>G\\<^sub>R_LTS\n   (ltl_to_generalized_rabin\\<^sub>C_af\\<^sub>\\<UU> \\<Sigma> \\<phi>) w", "show ?thesis"], ["proof (prove)\nusing this:\n  w \\<Turnstile> \\<phi> =\n  accept\\<^sub>G\\<^sub>R_LTS\n   (ltl_to_generalized_rabin\\<^sub>C_af\\<^sub>\\<UU> \\<Sigma> \\<phi>) w\n\ngoal (1 subgoal):\n 1. w \\<Turnstile> \\<phi> =\n    accept\\<^sub>G\\<^sub>R_LTS\n     (ltl_to_generalized_rabin\\<^sub>C_af\\<^sub>\\<UU> \\<Sigma> \\<phi>) w", "."], ["proof (state)\nthis:\n  w \\<Turnstile> \\<phi> =\n  accept\\<^sub>G\\<^sub>R_LTS\n   (ltl_to_generalized_rabin\\<^sub>C_af\\<^sub>\\<UU> \\<Sigma> \\<phi>) w\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}