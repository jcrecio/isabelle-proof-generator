{"file_name": "/home/qj213/afp-2021-10-22/thys/LTL_to_DRA/Impl/Mojmir_Rabin_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/LTL_to_DRA", "problem_names": ["lemma nxt_run_distinct:\n  \"distinct (run (nxt \\<Sigma> \\<Delta> q\\<^sub>0) (init q\\<^sub>0) w n)\"", "lemma nxt_run_reverse_step:\n  fixes \\<Sigma> \\<delta> q\\<^sub>0 w\n  defines \"r \\<equiv> run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\" \n  assumes \"q \\<in> set (r (Suc n))\"\n  assumes \"q \\<noteq> q\\<^sub>0\"\n  shows \"\\<exists>q' \\<in> set (r n). \\<delta> q' (w n) = q\"", "lemma nxt_run_sink_free:\n  \"q \\<in> set (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w n) \\<Longrightarrow> \\<not>semi_mojmir_def.sink \\<Sigma> \\<delta> q\\<^sub>0 q\"", "lemma rk_bounded:\n  \"rk xs x = Some i \\<Longrightarrow> i < length xs\"", "lemma rk_facts:\n  \"x \\<in> set xs \\<longleftrightarrow> rk xs x \\<noteq> None\"\n  \"x \\<in> set xs \\<longleftrightarrow> (\\<exists>i. rk xs x = Some i)\"", "lemma rk_split:\n  \"y \\<notin> set xs \\<Longrightarrow> rk (xs @ y # zs) y = Some (length xs)\"", "lemma rk_split_card:\n  \"y \\<notin> set xs \\<Longrightarrow> distinct xs \\<Longrightarrow> rk (xs @ y # zs) y = Some (card (set xs))\"", "lemma rk_split_card_takeWhile:\n  assumes \"x \\<in> set xs\"\n  assumes \"distinct xs\"\n  shows \"rk xs x = Some (card (set (takeWhile (\\<lambda>y. y \\<noteq> x) xs)))\"", "lemma take_rk:\n  assumes \"distinct xs\"\n  shows \"set (take i xs) = {q. \\<exists>j < i. rk xs q = Some j}\" \n  (is \"?rhs = ?lhs\")", "lemma drop_rk:\n  assumes \"distinct xs\"\n  shows \"set (drop i xs) = {q. \\<exists>j \\<ge> i. rk xs q = Some j}\"", "lemma (in semi_mojmir) nxt_run_configuration:\n  defines \"r \\<equiv> run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\"\n  shows \"q \\<in> set (r n) \\<longleftrightarrow> \\<not>sink q \\<and> configuration q n \\<noteq> {}\"", "lemma (in semi_mojmir) nxt_run_sorted:\n  defines \"r \\<equiv> run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\" \n  shows \"sorted (map (\\<lambda>q. the (oldest_token q n)) (r n))\"", "lemma (in semi_mojmir) nxt_run_senior_states: \n  defines \"r \\<equiv> run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\" \n  assumes \"\\<not>sink q\"\n  assumes \"configuration q n \\<noteq> {}\" \n  shows \"senior_states q n = set (takeWhile (\\<lambda>q'. q' \\<noteq> q) (r n))\" \n  (is \"?lhs = ?rhs\")", "lemma (in semi_mojmir) nxt_run_state_rank:\n  \"state_rank q n = rk (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w n) q\"", "lemma (in semi_mojmir) nxt_foldl_state_rank:\n  \"state_rank q n = rk (foldl (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) (map w [0..<n])) q\"", "lemma (in semi_mojmir) nxt_run_step_run:\n  \"run step initial w = rk o (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w)\"", "lemma (in semi_mojmir) finite_Q:\n  \"finite Q\\<^sub>E\"", "lemma (in mojmir_to_rabin_def) filt_equiv:\n  \"(rk x, \\<nu>, y) \\<in> fail\\<^sub>R \\<longleftrightarrow> fail_filt \\<Sigma> \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) (x, \\<nu>, y')\"\n  \"(rk x, \\<nu>, y) \\<in> succeed\\<^sub>R i \\<longleftrightarrow> succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i (x, \\<nu>, y')\"\n  \"(rk x, \\<nu>, y) \\<in> merge\\<^sub>R i \\<longleftrightarrow> merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i (x, \\<nu>, y')\"", "lemma fail_filt_eq: \n  \"fail_filt \\<Sigma> \\<delta> q\\<^sub>0 P (x, \\<nu>, y) \\<longleftrightarrow> (rk x, \\<nu>, y') \\<in> mojmir_to_rabin_def.fail\\<^sub>R \\<Sigma> \\<delta> q\\<^sub>0 {x. P x}\"", "lemma merge_filt_eq: \n  \"merge_filt \\<delta> q\\<^sub>0 P i (x, \\<nu>, y) \\<longleftrightarrow> (rk x, \\<nu>, y') \\<in> mojmir_to_rabin_def.merge\\<^sub>R \\<delta> q\\<^sub>0 {x. P x} i\"", "lemma succeed_filt_eq: \n  \"succeed_filt \\<delta> q\\<^sub>0 P i (x, \\<nu>, y) \\<longleftrightarrow> (rk x, \\<nu>, y') \\<in> mojmir_to_rabin_def.succeed\\<^sub>R \\<delta> q\\<^sub>0 {x. P x} i\"", "theorem (in mojmir_to_rabin) rabin_accept_iff_rabin_list_accept_rank:\n  \"accepting_pair\\<^sub>R \\<delta>\\<^sub>\\<R> q\\<^sub>\\<R> (Acc\\<^sub>\\<R> i) w \\<longleftrightarrow> accepting_pair\\<^sub>R (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) ({t. fail_filt \\<Sigma> \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) t} \\<union> {t. merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t}, {t. succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t}) w\"\n  (is \"accepting_pair\\<^sub>R \\<delta>\\<^sub>\\<R> q\\<^sub>\\<R> (?F, ?I) w \\<longleftrightarrow> accepting_pair\\<^sub>R (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) (?F', ?I') w\")", "lemma rk_eq_index_option [code]:\n  \"rk xs x = index_option 0 xs x\"", "lemma (in mojmir) max_rank_card:\n  assumes \"\\<Sigma> = set \\<Sigma>'\"\n  shows \"max_rank = card (Set.filter (Not o semi_mojmir_def.sink (set \\<Sigma>') \\<delta> q\\<^sub>0) (Q\\<^sub>L \\<Sigma>' \\<delta> q\\<^sub>0))\"", "theorem (in mojmir_to_rabin) exec_correct:\n  assumes \"\\<Sigma> = set \\<Sigma>'\"\n  shows \"accept \\<longleftrightarrow> accept\\<^sub>R_LTS (mojmir_to_rabin_exec \\<Sigma>' \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F)) w\" (is \"?lhs \\<longleftrightarrow> ?rhs\")"], "translations": [["", "lemma nxt_run_distinct:\n  \"distinct (run (nxt \\<Sigma> \\<Delta> q\\<^sub>0) (init q\\<^sub>0) w n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (run (nxt \\<Sigma> \\<Delta> q\\<^sub>0) (init q\\<^sub>0) w n)", "by (cases n; simp del: remdups_fwd.simps; metis (no_types) remdups_fwd_distinct)"], ["", "lemma nxt_run_reverse_step:\n  fixes \\<Sigma> \\<delta> q\\<^sub>0 w\n  defines \"r \\<equiv> run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\" \n  assumes \"q \\<in> set (r (Suc n))\"\n  assumes \"q \\<noteq> q\\<^sub>0\"\n  shows \"\\<exists>q' \\<in> set (r n). \\<delta> q' (w n) = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q'\\<in>set (r n). \\<delta> q' (w n) = q", "using assms(2-3)"], ["proof (prove)\nusing this:\n  q \\<in> set (r (Suc n))\n  q \\<noteq> q\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<exists>q'\\<in>set (r n). \\<delta> q' (w n) = q", "unfolding r_def run.simps nxt.simps remdups_fwd_set"], ["proof (prove)\nusing this:\n  q \\<in> set (filter\n                (\\<lambda>q.\n                    \\<not> semi_mojmir_def.sink \\<Sigma> \\<delta> q\\<^sub>0\n                            q)\n                (map (\\<lambda>q. \\<delta> q (w n))\n                  (run (\\<lambda>qs \\<nu>.\n                           remdups_fwd\n                            (filter\n                              (\\<lambda>q.\n                                  \\<not> semi_mojmir_def.sink \\<Sigma>\n    \\<delta> q\\<^sub>0 q)\n                              (map (\\<lambda>q. \\<delta> q \\<nu>) qs) @\n                             [q\\<^sub>0]))\n                    (init q\\<^sub>0) w n)) @\n               [q\\<^sub>0])\n  q \\<noteq> q\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<exists>q'\\<in>set (run (\\<lambda>qs \\<nu>.\n                                 remdups_fwd\n                                  (filter\n                                    (\\<lambda>q.\n  \\<not> semi_mojmir_def.sink \\<Sigma> \\<delta> q\\<^sub>0 q)\n                                    (map (\\<lambda>q. \\<delta> q \\<nu>)\nqs) @\n                                   [q\\<^sub>0]))\n                          (init q\\<^sub>0) w n).\n       \\<delta> q' (w n) = q", "by auto"], ["", "lemma nxt_run_sink_free:\n  \"q \\<in> set (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w n) \\<Longrightarrow> \\<not>semi_mojmir_def.sink \\<Sigma> \\<delta> q\\<^sub>0 q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> set (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n                  n) \\<Longrightarrow>\n    \\<not> semi_mojmir_def.sink \\<Sigma> \\<delta> q\\<^sub>0 q", "by (induction n) (simp_all add: semi_mojmir_def.sink_def del: remdups_fwd.simps, blast)"], ["", "subsubsection \\<open>rk Properties\\<close>"], ["", "lemma rk_bounded:\n  \"rk xs x = Some i \\<Longrightarrow> i < length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rk xs x = Some i \\<Longrightarrow> i < length xs", "by (simp add: Let_def) (metis index_conv_size_if_notin index_less_size_conv option.distinct(1) option.inject)"], ["", "lemma rk_facts:\n  \"x \\<in> set xs \\<longleftrightarrow> rk xs x \\<noteq> None\"\n  \"x \\<in> set xs \\<longleftrightarrow> (\\<exists>i. rk xs x = Some i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> set xs) = (rk xs x \\<noteq> None) &&&\n    (x \\<in> set xs) = (\\<exists>i. rk xs x = Some i)", "using rk_bounded"], ["proof (prove)\nusing this:\n  rk ?xs ?x = Some ?i \\<Longrightarrow> ?i < length ?xs\n\ngoal (1 subgoal):\n 1. (x \\<in> set xs) = (rk xs x \\<noteq> None) &&&\n    (x \\<in> set xs) = (\\<exists>i. rk xs x = Some i)", "by (simp add: index_size_conv)+"], ["", "lemma rk_split:\n  \"y \\<notin> set xs \\<Longrightarrow> rk (xs @ y # zs) y = Some (length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<notin> set xs \\<Longrightarrow>\n    rk (xs @ y # zs) y = Some (length xs)", "by (induction xs) auto"], ["", "lemma rk_split_card:\n  \"y \\<notin> set xs \\<Longrightarrow> distinct xs \\<Longrightarrow> rk (xs @ y # zs) y = Some (card (set xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<notin> set xs; distinct xs\\<rbrakk>\n    \\<Longrightarrow> rk (xs @ y # zs) y = Some (card (set xs))", "using rk_split"], ["proof (prove)\nusing this:\n  ?y \\<notin> set ?xs \\<Longrightarrow>\n  rk (?xs @ ?y # ?zs) ?y = Some (length ?xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<notin> set xs; distinct xs\\<rbrakk>\n    \\<Longrightarrow> rk (xs @ y # zs) y = Some (card (set xs))", "by (metis length_remdups_card_conv remdups_id_iff_distinct)"], ["", "lemma rk_split_card_takeWhile:\n  assumes \"x \\<in> set xs\"\n  assumes \"distinct xs\"\n  shows \"rk xs x = Some (card (set (takeWhile (\\<lambda>y. y \\<noteq> x) xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rk xs x = Some (card (set (takeWhile (\\<lambda>y. y \\<noteq> x) xs)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rk xs x = Some (card (set (takeWhile (\\<lambda>y. y \\<noteq> x) xs)))", "obtain ys zs where \"xs = ys @ x # zs\" and \"x \\<notin> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ys zs.\n        \\<lbrakk>xs = ys @ x # zs; x \\<notin> set ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> set xs\n  distinct xs\n\ngoal (1 subgoal):\n 1. (\\<And>ys zs.\n        \\<lbrakk>xs = ys @ x # zs; x \\<notin> set ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: split_list_first)"], ["proof (state)\nthis:\n  xs = ys @ x # zs\n  x \\<notin> set ys\n\ngoal (1 subgoal):\n 1. rk xs x = Some (card (set (takeWhile (\\<lambda>y. y \\<noteq> x) xs)))", "moreover"], ["proof (state)\nthis:\n  xs = ys @ x # zs\n  x \\<notin> set ys\n\ngoal (1 subgoal):\n 1. rk xs x = Some (card (set (takeWhile (\\<lambda>y. y \\<noteq> x) xs)))", "hence \"distinct ys\" and \"ys = takeWhile (\\<lambda>y. y \\<noteq> x) xs\""], ["proof (prove)\nusing this:\n  xs = ys @ x # zs\n  x \\<notin> set ys\n\ngoal (1 subgoal):\n 1. distinct ys &&& ys = takeWhile (\\<lambda>y. y \\<noteq> x) xs", "using takeWhile_foo assms"], ["proof (prove)\nusing this:\n  xs = ys @ x # zs\n  x \\<notin> set ys\n  ?x \\<notin> set ?ys \\<Longrightarrow>\n  ?ys = takeWhile (\\<lambda>y. y \\<noteq> ?x) (?ys @ ?x # ?zs)\n  x \\<in> set xs\n  distinct xs\n\ngoal (1 subgoal):\n 1. distinct ys &&& ys = takeWhile (\\<lambda>y. y \\<noteq> x) xs", "by (simp, fast)"], ["proof (state)\nthis:\n  distinct ys\n  ys = takeWhile (\\<lambda>y. y \\<noteq> x) xs\n\ngoal (1 subgoal):\n 1. rk xs x = Some (card (set (takeWhile (\\<lambda>y. y \\<noteq> x) xs)))", "ultimately"], ["proof (chain)\npicking this:\n  xs = ys @ x # zs\n  x \\<notin> set ys\n  distinct ys\n  ys = takeWhile (\\<lambda>y. y \\<noteq> x) xs", "show ?thesis"], ["proof (prove)\nusing this:\n  xs = ys @ x # zs\n  x \\<notin> set ys\n  distinct ys\n  ys = takeWhile (\\<lambda>y. y \\<noteq> x) xs\n\ngoal (1 subgoal):\n 1. rk xs x = Some (card (set (takeWhile (\\<lambda>y. y \\<noteq> x) xs)))", "using rk_split_card"], ["proof (prove)\nusing this:\n  xs = ys @ x # zs\n  x \\<notin> set ys\n  distinct ys\n  ys = takeWhile (\\<lambda>y. y \\<noteq> x) xs\n  \\<lbrakk>?y \\<notin> set ?xs; distinct ?xs\\<rbrakk>\n  \\<Longrightarrow> rk (?xs @ ?y # ?zs) ?y = Some (card (set ?xs))\n\ngoal (1 subgoal):\n 1. rk xs x = Some (card (set (takeWhile (\\<lambda>y. y \\<noteq> x) xs)))", "by metis"], ["proof (state)\nthis:\n  rk xs x = Some (card (set (takeWhile (\\<lambda>y. y \\<noteq> x) xs)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma take_rk:\n  assumes \"distinct xs\"\n  shows \"set (take i xs) = {q. \\<exists>j < i. rk xs q = Some j}\" \n  (is \"?rhs = ?lhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (take i xs) = {q. \\<exists>j<i. rk xs q = Some j}", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n\ngoal (1 subgoal):\n 1. set (take i xs) = {q. \\<exists>j<i. rk xs q = Some j}", "proof (induction i arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       distinct xs \\<Longrightarrow>\n       set (take 0 xs) = {q. \\<exists>j<0. rk xs q = Some j}\n 2. \\<And>i xs.\n       \\<lbrakk>\\<And>xs.\n                   distinct xs \\<Longrightarrow>\n                   set (take i xs) = {q. \\<exists>j<i. rk xs q = Some j};\n        distinct xs\\<rbrakk>\n       \\<Longrightarrow> set (take (Suc i) xs) =\n                         {q. \\<exists>j<Suc i. rk xs q = Some j}", "case (Suc i)"], ["proof (state)\nthis:\n  distinct ?xs \\<Longrightarrow>\n  set (take i ?xs) = {q. \\<exists>j<i. rk ?xs q = Some j}\n  distinct xs\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       distinct xs \\<Longrightarrow>\n       set (take 0 xs) = {q. \\<exists>j<0. rk xs q = Some j}\n 2. \\<And>i xs.\n       \\<lbrakk>\\<And>xs.\n                   distinct xs \\<Longrightarrow>\n                   set (take i xs) = {q. \\<exists>j<i. rk xs q = Some j};\n        distinct xs\\<rbrakk>\n       \\<Longrightarrow> set (take (Suc i) xs) =\n                         {q. \\<exists>j<Suc i. rk xs q = Some j}", "thus ?case"], ["proof (prove)\nusing this:\n  distinct ?xs \\<Longrightarrow>\n  set (take i ?xs) = {q. \\<exists>j<i. rk ?xs q = Some j}\n  distinct xs\n\ngoal (1 subgoal):\n 1. set (take (Suc i) xs) = {q. \\<exists>j<Suc i. rk xs q = Some j}", "proof (induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>xs.\n                distinct xs \\<Longrightarrow>\n                set (take i xs) = {q. \\<exists>j<i. rk xs q = Some j};\n     distinct []\\<rbrakk>\n    \\<Longrightarrow> set (take (Suc i) []) =\n                      {q. \\<exists>j<Suc i. rk [] q = Some j}\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>\\<And>xs.\n                            distinct xs \\<Longrightarrow>\n                            set (take i xs) =\n                            {q. \\<exists>j<i. rk xs q = Some j};\n                 distinct xs\\<rbrakk>\n                \\<Longrightarrow> set (take (Suc i) xs) =\n                                  {q. \\<exists>j<Suc i. rk xs q = Some j};\n        \\<And>xs.\n           distinct xs \\<Longrightarrow>\n           set (take i xs) = {q. \\<exists>j<i. rk xs q = Some j};\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> set (take (Suc i) (a # xs)) =\n                         {q. \\<exists>j<Suc i. rk (a # xs) q = Some j}", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>xs.\n              distinct xs \\<Longrightarrow>\n              set (take i xs) = {q. \\<exists>j<i. rk xs q = Some j};\n   distinct xs\\<rbrakk>\n  \\<Longrightarrow> set (take (Suc i) xs) =\n                    {q. \\<exists>j<Suc i. rk xs q = Some j}\n  distinct ?xs \\<Longrightarrow>\n  set (take i ?xs) = {q. \\<exists>j<i. rk ?xs q = Some j}\n  distinct (x # xs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>xs.\n                distinct xs \\<Longrightarrow>\n                set (take i xs) = {q. \\<exists>j<i. rk xs q = Some j};\n     distinct []\\<rbrakk>\n    \\<Longrightarrow> set (take (Suc i) []) =\n                      {q. \\<exists>j<Suc i. rk [] q = Some j}\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>\\<And>xs.\n                            distinct xs \\<Longrightarrow>\n                            set (take i xs) =\n                            {q. \\<exists>j<i. rk xs q = Some j};\n                 distinct xs\\<rbrakk>\n                \\<Longrightarrow> set (take (Suc i) xs) =\n                                  {q. \\<exists>j<Suc i. rk xs q = Some j};\n        \\<And>xs.\n           distinct xs \\<Longrightarrow>\n           set (take i xs) = {q. \\<exists>j<i. rk xs q = Some j};\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> set (take (Suc i) (a # xs)) =\n                         {q. \\<exists>j<Suc i. rk (a # xs) q = Some j}", "have \"set (take (Suc i) (x # xs)) = {x} \\<union> set (take i xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (take (Suc i) (x # xs)) = {x} \\<union> set (take i xs)", "by simp"], ["proof (state)\nthis:\n  set (take (Suc i) (x # xs)) = {x} \\<union> set (take i xs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>xs.\n                distinct xs \\<Longrightarrow>\n                set (take i xs) = {q. \\<exists>j<i. rk xs q = Some j};\n     distinct []\\<rbrakk>\n    \\<Longrightarrow> set (take (Suc i) []) =\n                      {q. \\<exists>j<Suc i. rk [] q = Some j}\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>\\<And>xs.\n                            distinct xs \\<Longrightarrow>\n                            set (take i xs) =\n                            {q. \\<exists>j<i. rk xs q = Some j};\n                 distinct xs\\<rbrakk>\n                \\<Longrightarrow> set (take (Suc i) xs) =\n                                  {q. \\<exists>j<Suc i. rk xs q = Some j};\n        \\<And>xs.\n           distinct xs \\<Longrightarrow>\n           set (take i xs) = {q. \\<exists>j<i. rk xs q = Some j};\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> set (take (Suc i) (a # xs)) =\n                         {q. \\<exists>j<Suc i. rk (a # xs) q = Some j}", "also"], ["proof (state)\nthis:\n  set (take (Suc i) (x # xs)) = {x} \\<union> set (take i xs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>xs.\n                distinct xs \\<Longrightarrow>\n                set (take i xs) = {q. \\<exists>j<i. rk xs q = Some j};\n     distinct []\\<rbrakk>\n    \\<Longrightarrow> set (take (Suc i) []) =\n                      {q. \\<exists>j<Suc i. rk [] q = Some j}\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>\\<And>xs.\n                            distinct xs \\<Longrightarrow>\n                            set (take i xs) =\n                            {q. \\<exists>j<i. rk xs q = Some j};\n                 distinct xs\\<rbrakk>\n                \\<Longrightarrow> set (take (Suc i) xs) =\n                                  {q. \\<exists>j<Suc i. rk xs q = Some j};\n        \\<And>xs.\n           distinct xs \\<Longrightarrow>\n           set (take i xs) = {q. \\<exists>j<i. rk xs q = Some j};\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> set (take (Suc i) (a # xs)) =\n                         {q. \\<exists>j<Suc i. rk (a # xs) q = Some j}", "have \"\\<dots> = {x} \\<union> {q. \\<exists>j < i. rk xs q = Some j}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x} \\<union> set (take i xs) =\n    {x} \\<union> {q. \\<exists>j<i. rk xs q = Some j}", "using Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>xs.\n              distinct xs \\<Longrightarrow>\n              set (take i xs) = {q. \\<exists>j<i. rk xs q = Some j};\n   distinct xs\\<rbrakk>\n  \\<Longrightarrow> set (take (Suc i) xs) =\n                    {q. \\<exists>j<Suc i. rk xs q = Some j}\n  distinct ?xs \\<Longrightarrow>\n  set (take i ?xs) = {q. \\<exists>j<i. rk ?xs q = Some j}\n  distinct (x # xs)\n\ngoal (1 subgoal):\n 1. {x} \\<union> set (take i xs) =\n    {x} \\<union> {q. \\<exists>j<i. rk xs q = Some j}", "by simp"], ["proof (state)\nthis:\n  {x} \\<union> set (take i xs) =\n  {x} \\<union> {q. \\<exists>j<i. rk xs q = Some j}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>xs.\n                distinct xs \\<Longrightarrow>\n                set (take i xs) = {q. \\<exists>j<i. rk xs q = Some j};\n     distinct []\\<rbrakk>\n    \\<Longrightarrow> set (take (Suc i) []) =\n                      {q. \\<exists>j<Suc i. rk [] q = Some j}\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>\\<And>xs.\n                            distinct xs \\<Longrightarrow>\n                            set (take i xs) =\n                            {q. \\<exists>j<i. rk xs q = Some j};\n                 distinct xs\\<rbrakk>\n                \\<Longrightarrow> set (take (Suc i) xs) =\n                                  {q. \\<exists>j<Suc i. rk xs q = Some j};\n        \\<And>xs.\n           distinct xs \\<Longrightarrow>\n           set (take i xs) = {q. \\<exists>j<i. rk xs q = Some j};\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> set (take (Suc i) (a # xs)) =\n                         {q. \\<exists>j<Suc i. rk (a # xs) q = Some j}", "finally"], ["proof (chain)\npicking this:\n  set (take (Suc i) (x # xs)) =\n  {x} \\<union> {q. \\<exists>j<i. rk xs q = Some j}", "show ?case"], ["proof (prove)\nusing this:\n  set (take (Suc i) (x # xs)) =\n  {x} \\<union> {q. \\<exists>j<i. rk xs q = Some j}\n\ngoal (1 subgoal):\n 1. set (take (Suc i) (x # xs)) =\n    {q. \\<exists>j<Suc i. rk (x # xs) q = Some j}", "by force"], ["proof (state)\nthis:\n  set (take (Suc i) (x # xs)) =\n  {q. \\<exists>j<Suc i. rk (x # xs) q = Some j}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs.\n                distinct xs \\<Longrightarrow>\n                set (take i xs) = {q. \\<exists>j<i. rk xs q = Some j};\n     distinct []\\<rbrakk>\n    \\<Longrightarrow> set (take (Suc i) []) =\n                      {q. \\<exists>j<Suc i. rk [] q = Some j}", "qed simp"], ["proof (state)\nthis:\n  set (take (Suc i) xs) = {q. \\<exists>j<Suc i. rk xs q = Some j}\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       distinct xs \\<Longrightarrow>\n       set (take 0 xs) = {q. \\<exists>j<0. rk xs q = Some j}", "qed simp"], ["", "lemma drop_rk:\n  assumes \"distinct xs\"\n  shows \"set (drop i xs) = {q. \\<exists>j \\<ge> i. rk xs q = Some j}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (drop i xs) = {q. \\<exists>j\\<ge>i. rk xs q = Some j}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (drop i xs) = {q. \\<exists>j\\<ge>i. rk xs q = Some j}", "have \"set xs = {q. \\<exists>j. rk xs q = Some j}\" (is \"_ = ?U\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs = {q. \\<exists>j. rk xs q = Some j}", "using rk_facts(2)[of _ xs]"], ["proof (prove)\nusing this:\n  (?x \\<in> set xs) = (\\<exists>i. rk xs ?x = Some i)\n\ngoal (1 subgoal):\n 1. set xs = {q. \\<exists>j. rk xs q = Some j}", "by blast"], ["proof (state)\nthis:\n  set xs = {q. \\<exists>j. rk xs q = Some j}\n\ngoal (1 subgoal):\n 1. set (drop i xs) = {q. \\<exists>j\\<ge>i. rk xs q = Some j}", "moreover"], ["proof (state)\nthis:\n  set xs = {q. \\<exists>j. rk xs q = Some j}\n\ngoal (1 subgoal):\n 1. set (drop i xs) = {q. \\<exists>j\\<ge>i. rk xs q = Some j}", "have \"?U = {q. \\<exists>j \\<ge> i. rk xs q = Some j} \\<union> {q. \\<exists>j < i. rk xs q = Some j}\"\n    and \"{} = {q. \\<exists>j \\<ge> i. rk xs q = Some j} \\<inter> {q. \\<exists>j < i. rk xs q = Some j}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {q. \\<exists>j. rk xs q = Some j} =\n    {q. \\<exists>j\\<ge>i. rk xs q = Some j} \\<union>\n    {q. \\<exists>j<i. rk xs q = Some j} &&&\n    {} =\n    {q. \\<exists>j\\<ge>i. rk xs q = Some j} \\<inter>\n    {q. \\<exists>j<i. rk xs q = Some j}", "by auto"], ["proof (state)\nthis:\n  {q. \\<exists>j. rk xs q = Some j} =\n  {q. \\<exists>j\\<ge>i. rk xs q = Some j} \\<union>\n  {q. \\<exists>j<i. rk xs q = Some j}\n  {} =\n  {q. \\<exists>j\\<ge>i. rk xs q = Some j} \\<inter>\n  {q. \\<exists>j<i. rk xs q = Some j}\n\ngoal (1 subgoal):\n 1. set (drop i xs) = {q. \\<exists>j\\<ge>i. rk xs q = Some j}", "moreover"], ["proof (state)\nthis:\n  {q. \\<exists>j. rk xs q = Some j} =\n  {q. \\<exists>j\\<ge>i. rk xs q = Some j} \\<union>\n  {q. \\<exists>j<i. rk xs q = Some j}\n  {} =\n  {q. \\<exists>j\\<ge>i. rk xs q = Some j} \\<inter>\n  {q. \\<exists>j<i. rk xs q = Some j}\n\ngoal (1 subgoal):\n 1. set (drop i xs) = {q. \\<exists>j\\<ge>i. rk xs q = Some j}", "have \"set xs = set (drop i xs) \\<union> set (take i xs)\"\n    and \"{} = set (drop i xs) \\<inter> set (take i xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs = set (drop i xs) \\<union> set (take i xs) &&&\n    {} = set (drop i xs) \\<inter> set (take i xs)", "by (metis assms append_take_drop_id inf_sup_aci(1,5) distinct_append set_append)+"], ["proof (state)\nthis:\n  set xs = set (drop i xs) \\<union> set (take i xs)\n  {} = set (drop i xs) \\<inter> set (take i xs)\n\ngoal (1 subgoal):\n 1. set (drop i xs) = {q. \\<exists>j\\<ge>i. rk xs q = Some j}", "ultimately"], ["proof (chain)\npicking this:\n  set xs = {q. \\<exists>j. rk xs q = Some j}\n  {q. \\<exists>j. rk xs q = Some j} =\n  {q. \\<exists>j\\<ge>i. rk xs q = Some j} \\<union>\n  {q. \\<exists>j<i. rk xs q = Some j}\n  {} =\n  {q. \\<exists>j\\<ge>i. rk xs q = Some j} \\<inter>\n  {q. \\<exists>j<i. rk xs q = Some j}\n  set xs = set (drop i xs) \\<union> set (take i xs)\n  {} = set (drop i xs) \\<inter> set (take i xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  set xs = {q. \\<exists>j. rk xs q = Some j}\n  {q. \\<exists>j. rk xs q = Some j} =\n  {q. \\<exists>j\\<ge>i. rk xs q = Some j} \\<union>\n  {q. \\<exists>j<i. rk xs q = Some j}\n  {} =\n  {q. \\<exists>j\\<ge>i. rk xs q = Some j} \\<inter>\n  {q. \\<exists>j<i. rk xs q = Some j}\n  set xs = set (drop i xs) \\<union> set (take i xs)\n  {} = set (drop i xs) \\<inter> set (take i xs)\n\ngoal (1 subgoal):\n 1. set (drop i xs) = {q. \\<exists>j\\<ge>i. rk xs q = Some j}", "using take_rk[OF assms]"], ["proof (prove)\nusing this:\n  set xs = {q. \\<exists>j. rk xs q = Some j}\n  {q. \\<exists>j. rk xs q = Some j} =\n  {q. \\<exists>j\\<ge>i. rk xs q = Some j} \\<union>\n  {q. \\<exists>j<i. rk xs q = Some j}\n  {} =\n  {q. \\<exists>j\\<ge>i. rk xs q = Some j} \\<inter>\n  {q. \\<exists>j<i. rk xs q = Some j}\n  set xs = set (drop i xs) \\<union> set (take i xs)\n  {} = set (drop i xs) \\<inter> set (take i xs)\n  set (take ?i xs) = {q. \\<exists>j<?i. rk xs q = Some j}\n\ngoal (1 subgoal):\n 1. set (drop i xs) = {q. \\<exists>j\\<ge>i. rk xs q = Some j}", "by blast"], ["proof (state)\nthis:\n  set (drop i xs) = {q. \\<exists>j\\<ge>i. rk xs q = Some j}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Relation to (Semi) Mojmir Automata\\<close>"], ["", "lemma (in semi_mojmir) nxt_run_configuration:\n  defines \"r \\<equiv> run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\"\n  shows \"q \\<in> set (r n) \\<longleftrightarrow> \\<not>sink q \\<and> configuration q n \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (q \\<in> set (r n)) =\n    (\\<not> sink q \\<and> configuration q n \\<noteq> {})", "proof (induction n arbitrary: q)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q.\n       (q \\<in> set (r 0)) =\n       (\\<not> sink q \\<and> configuration q 0 \\<noteq> {})\n 2. \\<And>n q.\n       (\\<And>q.\n           (q \\<in> set (r n)) =\n           (\\<not> sink q \\<and>\n            configuration q n \\<noteq> {})) \\<Longrightarrow>\n       (q \\<in> set (r (Suc n))) =\n       (\\<not> sink q \\<and> configuration q (Suc n) \\<noteq> {})", "case (Suc n)"], ["proof (state)\nthis:\n  (?q \\<in> set (r n)) =\n  (\\<not> sink ?q \\<and> configuration ?q n \\<noteq> {})\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       (q \\<in> set (r 0)) =\n       (\\<not> sink q \\<and> configuration q 0 \\<noteq> {})\n 2. \\<And>n q.\n       (\\<And>q.\n           (q \\<in> set (r n)) =\n           (\\<not> sink q \\<and>\n            configuration q n \\<noteq> {})) \\<Longrightarrow>\n       (q \\<in> set (r (Suc n))) =\n       (\\<not> sink q \\<and> configuration q (Suc n) \\<noteq> {})", "thus ?case"], ["proof (prove)\nusing this:\n  (?q \\<in> set (r n)) =\n  (\\<not> sink ?q \\<and> configuration ?q n \\<noteq> {})\n\ngoal (1 subgoal):\n 1. (q \\<in> set (r (Suc n))) =\n    (\\<not> sink q \\<and> configuration q (Suc n) \\<noteq> {})", "proof (cases \"q \\<noteq> q\\<^sub>0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>q.\n                (q \\<in> set (r n)) =\n                (\\<not> sink q \\<and> configuration q n \\<noteq> {});\n     q \\<noteq> q\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (q \\<in> set (r (Suc n))) =\n                      (\\<not> sink q \\<and>\n                       configuration q (Suc n) \\<noteq> {})\n 2. \\<lbrakk>\\<And>q.\n                (q \\<in> set (r n)) =\n                (\\<not> sink q \\<and> configuration q n \\<noteq> {});\n     \\<not> q \\<noteq> q\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (q \\<in> set (r (Suc n))) =\n                      (\\<not> sink q \\<and>\n                       configuration q (Suc n) \\<noteq> {})", "case True"], ["proof (state)\nthis:\n  q \\<noteq> q\\<^sub>0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>q.\n                (q \\<in> set (r n)) =\n                (\\<not> sink q \\<and> configuration q n \\<noteq> {});\n     q \\<noteq> q\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (q \\<in> set (r (Suc n))) =\n                      (\\<not> sink q \\<and>\n                       configuration q (Suc n) \\<noteq> {})\n 2. \\<lbrakk>\\<And>q.\n                (q \\<in> set (r n)) =\n                (\\<not> sink q \\<and> configuration q n \\<noteq> {});\n     \\<not> q \\<noteq> q\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (q \\<in> set (r (Suc n))) =\n                      (\\<not> sink q \\<and>\n                       configuration q (Suc n) \\<noteq> {})", "{"], ["proof (state)\nthis:\n  q \\<noteq> q\\<^sub>0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>q.\n                (q \\<in> set (r n)) =\n                (\\<not> sink q \\<and> configuration q n \\<noteq> {});\n     q \\<noteq> q\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (q \\<in> set (r (Suc n))) =\n                      (\\<not> sink q \\<and>\n                       configuration q (Suc n) \\<noteq> {})\n 2. \\<lbrakk>\\<And>q.\n                (q \\<in> set (r n)) =\n                (\\<not> sink q \\<and> configuration q n \\<noteq> {});\n     \\<not> q \\<noteq> q\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (q \\<in> set (r (Suc n))) =\n                      (\\<not> sink q \\<and>\n                       configuration q (Suc n) \\<noteq> {})", "assume \"q \\<in> set (r (Suc n))\""], ["proof (state)\nthis:\n  q \\<in> set (r (Suc n))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>q.\n                (q \\<in> set (r n)) =\n                (\\<not> sink q \\<and> configuration q n \\<noteq> {});\n     q \\<noteq> q\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (q \\<in> set (r (Suc n))) =\n                      (\\<not> sink q \\<and>\n                       configuration q (Suc n) \\<noteq> {})\n 2. \\<lbrakk>\\<And>q.\n                (q \\<in> set (r n)) =\n                (\\<not> sink q \\<and> configuration q n \\<noteq> {});\n     \\<not> q \\<noteq> q\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (q \\<in> set (r (Suc n))) =\n                      (\\<not> sink q \\<and>\n                       configuration q (Suc n) \\<noteq> {})", "hence \"\\<not> sink q\""], ["proof (prove)\nusing this:\n  q \\<in> set (r (Suc n))\n\ngoal (1 subgoal):\n 1. \\<not> sink q", "using r_def nxt_run_sink_free"], ["proof (prove)\nusing this:\n  q \\<in> set (r (Suc n))\n  r \\<equiv> run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n  ?q \\<in> set (run (nxt ?\\<Sigma> ?\\<delta> ?q\\<^sub>0) (init ?q\\<^sub>0)\n                 ?w ?n) \\<Longrightarrow>\n  \\<not> semi_mojmir_def.sink ?\\<Sigma> ?\\<delta> ?q\\<^sub>0 ?q\n\ngoal (1 subgoal):\n 1. \\<not> sink q", "by metis"], ["proof (state)\nthis:\n  \\<not> sink q\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>q.\n                (q \\<in> set (r n)) =\n                (\\<not> sink q \\<and> configuration q n \\<noteq> {});\n     q \\<noteq> q\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (q \\<in> set (r (Suc n))) =\n                      (\\<not> sink q \\<and>\n                       configuration q (Suc n) \\<noteq> {})\n 2. \\<lbrakk>\\<And>q.\n                (q \\<in> set (r n)) =\n                (\\<not> sink q \\<and> configuration q n \\<noteq> {});\n     \\<not> q \\<noteq> q\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (q \\<in> set (r (Suc n))) =\n                      (\\<not> sink q \\<and>\n                       configuration q (Suc n) \\<noteq> {})", "moreover"], ["proof (state)\nthis:\n  \\<not> sink q\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>q.\n                (q \\<in> set (r n)) =\n                (\\<not> sink q \\<and> configuration q n \\<noteq> {});\n     q \\<noteq> q\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (q \\<in> set (r (Suc n))) =\n                      (\\<not> sink q \\<and>\n                       configuration q (Suc n) \\<noteq> {})\n 2. \\<lbrakk>\\<And>q.\n                (q \\<in> set (r n)) =\n                (\\<not> sink q \\<and> configuration q n \\<noteq> {});\n     \\<not> q \\<noteq> q\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (q \\<in> set (r (Suc n))) =\n                      (\\<not> sink q \\<and>\n                       configuration q (Suc n) \\<noteq> {})", "obtain q' where \"q' \\<in> set (r n)\" and \"\\<delta> q' (w n) = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        \\<lbrakk>q' \\<in> set (r n); \\<delta> q' (w n) = q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>q \\<in> set (r (Suc n))\\<close> nxt_run_reverse_step[OF _ \\<open>q \\<noteq> q\\<^sub>0\\<close>]"], ["proof (prove)\nusing this:\n  q \\<in> set (r (Suc n))\n  q \\<in> set (run (nxt ?\\<Sigma> ?\\<delta> q\\<^sub>0) (init q\\<^sub>0) ?w\n                (Suc ?n)) \\<Longrightarrow>\n  \\<exists>q'\\<in>set (run (nxt ?\\<Sigma> ?\\<delta> q\\<^sub>0)\n                        (init q\\<^sub>0) ?w ?n).\n     ?\\<delta> q' (?w ?n) = q\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        \\<lbrakk>q' \\<in> set (r n); \\<delta> q' (w n) = q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding r_def"], ["proof (prove)\nusing this:\n  q \\<in> set (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n                (Suc n))\n  q \\<in> set (run (nxt ?\\<Sigma> ?\\<delta> q\\<^sub>0) (init q\\<^sub>0) ?w\n                (Suc ?n)) \\<Longrightarrow>\n  \\<exists>q'\\<in>set (run (nxt ?\\<Sigma> ?\\<delta> q\\<^sub>0)\n                        (init q\\<^sub>0) ?w ?n).\n     ?\\<delta> q' (?w ?n) = q\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        \\<lbrakk>q' \\<in> set (run (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n                                (init q\\<^sub>0) w n);\n         \\<delta> q' (w n) = q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  q' \\<in> set (r n)\n  \\<delta> q' (w n) = q\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>q.\n                (q \\<in> set (r n)) =\n                (\\<not> sink q \\<and> configuration q n \\<noteq> {});\n     q \\<noteq> q\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (q \\<in> set (r (Suc n))) =\n                      (\\<not> sink q \\<and>\n                       configuration q (Suc n) \\<noteq> {})\n 2. \\<lbrakk>\\<And>q.\n                (q \\<in> set (r n)) =\n                (\\<not> sink q \\<and> configuration q n \\<noteq> {});\n     \\<not> q \\<noteq> q\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (q \\<in> set (r (Suc n))) =\n                      (\\<not> sink q \\<and>\n                       configuration q (Suc n) \\<noteq> {})", "hence \"configuration q (Suc n) \\<noteq> {}\" and \"\\<not> sink q\""], ["proof (prove)\nusing this:\n  q' \\<in> set (r n)\n  \\<delta> q' (w n) = q\n\ngoal (1 subgoal):\n 1. configuration q (Suc n) \\<noteq> {} &&& \\<not> sink q", "unfolding configuration_step_eq[OF True] Suc"], ["proof (prove)\nusing this:\n  \\<not> sink q' \\<and> configuration q' n \\<noteq> {}\n  \\<delta> q' (w n) = q\n\ngoal (1 subgoal):\n 1. \\<Union> {configuration q' n |q'. q = \\<delta> q' (w n)} \\<noteq> {} &&&\n    \\<not> sink q", "using True \\<open>\\<not> sink q\\<close>"], ["proof (prove)\nusing this:\n  \\<not> sink q' \\<and> configuration q' n \\<noteq> {}\n  \\<delta> q' (w n) = q\n  q \\<noteq> q\\<^sub>0\n  \\<not> sink q\n\ngoal (1 subgoal):\n 1. \\<Union> {configuration q' n |q'. q = \\<delta> q' (w n)} \\<noteq> {} &&&\n    \\<not> sink q", "by auto"], ["proof (state)\nthis:\n  configuration q (Suc n) \\<noteq> {}\n  \\<not> sink q\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>q.\n                (q \\<in> set (r n)) =\n                (\\<not> sink q \\<and> configuration q n \\<noteq> {});\n     q \\<noteq> q\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (q \\<in> set (r (Suc n))) =\n                      (\\<not> sink q \\<and>\n                       configuration q (Suc n) \\<noteq> {})\n 2. \\<lbrakk>\\<And>q.\n                (q \\<in> set (r n)) =\n                (\\<not> sink q \\<and> configuration q n \\<noteq> {});\n     \\<not> q \\<noteq> q\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (q \\<in> set (r (Suc n))) =\n                      (\\<not> sink q \\<and>\n                       configuration q (Suc n) \\<noteq> {})", "}"], ["proof (state)\nthis:\n  q \\<in> set (r (Suc n)) \\<Longrightarrow>\n  configuration q (Suc n) \\<noteq> {}\n  q \\<in> set (r (Suc n)) \\<Longrightarrow> \\<not> sink q\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>q.\n                (q \\<in> set (r n)) =\n                (\\<not> sink q \\<and> configuration q n \\<noteq> {});\n     q \\<noteq> q\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (q \\<in> set (r (Suc n))) =\n                      (\\<not> sink q \\<and>\n                       configuration q (Suc n) \\<noteq> {})\n 2. \\<lbrakk>\\<And>q.\n                (q \\<in> set (r n)) =\n                (\\<not> sink q \\<and> configuration q n \\<noteq> {});\n     \\<not> q \\<noteq> q\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (q \\<in> set (r (Suc n))) =\n                      (\\<not> sink q \\<and>\n                       configuration q (Suc n) \\<noteq> {})", "moreover"], ["proof (state)\nthis:\n  q \\<in> set (r (Suc n)) \\<Longrightarrow>\n  configuration q (Suc n) \\<noteq> {}\n  q \\<in> set (r (Suc n)) \\<Longrightarrow> \\<not> sink q\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>q.\n                (q \\<in> set (r n)) =\n                (\\<not> sink q \\<and> configuration q n \\<noteq> {});\n     q \\<noteq> q\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (q \\<in> set (r (Suc n))) =\n                      (\\<not> sink q \\<and>\n                       configuration q (Suc n) \\<noteq> {})\n 2. \\<lbrakk>\\<And>q.\n                (q \\<in> set (r n)) =\n                (\\<not> sink q \\<and> configuration q n \\<noteq> {});\n     \\<not> q \\<noteq> q\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (q \\<in> set (r (Suc n))) =\n                      (\\<not> sink q \\<and>\n                       configuration q (Suc n) \\<noteq> {})", "{"], ["proof (state)\nthis:\n  q \\<in> set (r (Suc n)) \\<Longrightarrow>\n  configuration q (Suc n) \\<noteq> {}\n  q \\<in> set (r (Suc n)) \\<Longrightarrow> \\<not> sink q\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>q.\n                (q \\<in> set (r n)) =\n                (\\<not> sink q \\<and> configuration q n \\<noteq> {});\n     q \\<noteq> q\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (q \\<in> set (r (Suc n))) =\n                      (\\<not> sink q \\<and>\n                       configuration q (Suc n) \\<noteq> {})\n 2. \\<lbrakk>\\<And>q.\n                (q \\<in> set (r n)) =\n                (\\<not> sink q \\<and> configuration q n \\<noteq> {});\n     \\<not> q \\<noteq> q\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (q \\<in> set (r (Suc n))) =\n                      (\\<not> sink q \\<and>\n                       configuration q (Suc n) \\<noteq> {})", "assume \"\\<not>sink q\" and \"configuration q (Suc n) \\<noteq> {}\""], ["proof (state)\nthis:\n  \\<not> sink q\n  configuration q (Suc n) \\<noteq> {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>q.\n                (q \\<in> set (r n)) =\n                (\\<not> sink q \\<and> configuration q n \\<noteq> {});\n     q \\<noteq> q\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (q \\<in> set (r (Suc n))) =\n                      (\\<not> sink q \\<and>\n                       configuration q (Suc n) \\<noteq> {})\n 2. \\<lbrakk>\\<And>q.\n                (q \\<in> set (r n)) =\n                (\\<not> sink q \\<and> configuration q n \\<noteq> {});\n     \\<not> q \\<noteq> q\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (q \\<in> set (r (Suc n))) =\n                      (\\<not> sink q \\<and>\n                       configuration q (Suc n) \\<noteq> {})", "then"], ["proof (chain)\npicking this:\n  \\<not> sink q\n  configuration q (Suc n) \\<noteq> {}", "obtain q' where \"configuration q' n \\<noteq> {}\" and \"\\<delta> q' (w n) = q\""], ["proof (prove)\nusing this:\n  \\<not> sink q\n  configuration q (Suc n) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        \\<lbrakk>configuration q' n \\<noteq> {};\n         \\<delta> q' (w n) = q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding configuration_step_eq[OF True]"], ["proof (prove)\nusing this:\n  \\<not> sink q\n  \\<Union> {configuration q' n |q'. q = \\<delta> q' (w n)} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        \\<lbrakk>configuration q' n \\<noteq> {};\n         \\<delta> q' (w n) = q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  configuration q' n \\<noteq> {}\n  \\<delta> q' (w n) = q\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>q.\n                (q \\<in> set (r n)) =\n                (\\<not> sink q \\<and> configuration q n \\<noteq> {});\n     q \\<noteq> q\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (q \\<in> set (r (Suc n))) =\n                      (\\<not> sink q \\<and>\n                       configuration q (Suc n) \\<noteq> {})\n 2. \\<lbrakk>\\<And>q.\n                (q \\<in> set (r n)) =\n                (\\<not> sink q \\<and> configuration q n \\<noteq> {});\n     \\<not> q \\<noteq> q\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (q \\<in> set (r (Suc n))) =\n                      (\\<not> sink q \\<and>\n                       configuration q (Suc n) \\<noteq> {})", "moreover"], ["proof (state)\nthis:\n  configuration q' n \\<noteq> {}\n  \\<delta> q' (w n) = q\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>q.\n                (q \\<in> set (r n)) =\n                (\\<not> sink q \\<and> configuration q n \\<noteq> {});\n     q \\<noteq> q\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (q \\<in> set (r (Suc n))) =\n                      (\\<not> sink q \\<and>\n                       configuration q (Suc n) \\<noteq> {})\n 2. \\<lbrakk>\\<And>q.\n                (q \\<in> set (r n)) =\n                (\\<not> sink q \\<and> configuration q n \\<noteq> {});\n     \\<not> q \\<noteq> q\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (q \\<in> set (r (Suc n))) =\n                      (\\<not> sink q \\<and>\n                       configuration q (Suc n) \\<noteq> {})", "hence \"\\<not>sink q'\""], ["proof (prove)\nusing this:\n  configuration q' n \\<noteq> {}\n  \\<delta> q' (w n) = q\n\ngoal (1 subgoal):\n 1. \\<not> sink q'", "using \\<open>\\<not>sink q\\<close> sink_rev_step assms"], ["proof (prove)\nusing this:\n  configuration q' n \\<noteq> {}\n  \\<delta> q' (w n) = q\n  \\<not> sink q\n  \\<lbrakk>\\<not> sink ?q; ?q = \\<delta> ?q' ?\\<nu>;\n   ?\\<nu> \\<in> \\<Sigma>\\<rbrakk>\n  \\<Longrightarrow> \\<not> sink ?q'\n  \\<lbrakk>\\<not> sink ?q; ?q = \\<delta> ?q' (w ?i)\\<rbrakk>\n  \\<Longrightarrow> \\<not> sink ?q'\n  r \\<equiv> run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n\ngoal (1 subgoal):\n 1. \\<not> sink q'", "by blast"], ["proof (state)\nthis:\n  \\<not> sink q'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>q.\n                (q \\<in> set (r n)) =\n                (\\<not> sink q \\<and> configuration q n \\<noteq> {});\n     q \\<noteq> q\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (q \\<in> set (r (Suc n))) =\n                      (\\<not> sink q \\<and>\n                       configuration q (Suc n) \\<noteq> {})\n 2. \\<lbrakk>\\<And>q.\n                (q \\<in> set (r n)) =\n                (\\<not> sink q \\<and> configuration q n \\<noteq> {});\n     \\<not> q \\<noteq> q\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (q \\<in> set (r (Suc n))) =\n                      (\\<not> sink q \\<and>\n                       configuration q (Suc n) \\<noteq> {})", "ultimately"], ["proof (chain)\npicking this:\n  configuration q' n \\<noteq> {}\n  \\<delta> q' (w n) = q\n  \\<not> sink q'", "have \"q' \\<in> set (r n)\""], ["proof (prove)\nusing this:\n  configuration q' n \\<noteq> {}\n  \\<delta> q' (w n) = q\n  \\<not> sink q'\n\ngoal (1 subgoal):\n 1. q' \\<in> set (r n)", "unfolding Suc"], ["proof (prove)\nusing this:\n  configuration q' n \\<noteq> {}\n  \\<delta> q' (w n) = q\n  \\<not> sink q'\n\ngoal (1 subgoal):\n 1. \\<not> sink q' \\<and> configuration q' n \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  q' \\<in> set (r n)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>q.\n                (q \\<in> set (r n)) =\n                (\\<not> sink q \\<and> configuration q n \\<noteq> {});\n     q \\<noteq> q\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (q \\<in> set (r (Suc n))) =\n                      (\\<not> sink q \\<and>\n                       configuration q (Suc n) \\<noteq> {})\n 2. \\<lbrakk>\\<And>q.\n                (q \\<in> set (r n)) =\n                (\\<not> sink q \\<and> configuration q n \\<noteq> {});\n     \\<not> q \\<noteq> q\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (q \\<in> set (r (Suc n))) =\n                      (\\<not> sink q \\<and>\n                       configuration q (Suc n) \\<noteq> {})", "hence \"q \\<in> set (r (Suc n))\""], ["proof (prove)\nusing this:\n  q' \\<in> set (r n)\n\ngoal (1 subgoal):\n 1. q \\<in> set (r (Suc n))", "using \\<open>\\<delta> q' (w n) = q\\<close> \\<open>\\<not>sink q\\<close>"], ["proof (prove)\nusing this:\n  q' \\<in> set (r n)\n  \\<delta> q' (w n) = q\n  \\<not> sink q\n\ngoal (1 subgoal):\n 1. q \\<in> set (r (Suc n))", "unfolding r_def run.simps set_filter comp_def remdups_fwd_set set_map set_append image_def"], ["proof (prove)\nusing this:\n  q' \\<in> set (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w n)\n  \\<delta> q' (w n) = q\n  \\<not> sink q\n\ngoal (1 subgoal):\n 1. q \\<in> set (nxt \\<Sigma> \\<delta> q\\<^sub>0\n                  (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n                    n)\n                  (w n))", "unfolding r_def[symmetric]"], ["proof (prove)\nusing this:\n  q' \\<in> set (r n)\n  \\<delta> q' (w n) = q\n  \\<not> sink q\n\ngoal (1 subgoal):\n 1. q \\<in> set (nxt \\<Sigma> \\<delta> q\\<^sub>0 (r n) (w n))", "by auto"], ["proof (state)\nthis:\n  q \\<in> set (r (Suc n))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>q.\n                (q \\<in> set (r n)) =\n                (\\<not> sink q \\<and> configuration q n \\<noteq> {});\n     q \\<noteq> q\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (q \\<in> set (r (Suc n))) =\n                      (\\<not> sink q \\<and>\n                       configuration q (Suc n) \\<noteq> {})\n 2. \\<lbrakk>\\<And>q.\n                (q \\<in> set (r n)) =\n                (\\<not> sink q \\<and> configuration q n \\<noteq> {});\n     \\<not> q \\<noteq> q\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (q \\<in> set (r (Suc n))) =\n                      (\\<not> sink q \\<and>\n                       configuration q (Suc n) \\<noteq> {})", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> sink q; configuration q (Suc n) \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> q \\<in> set (r (Suc n))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>q.\n                (q \\<in> set (r n)) =\n                (\\<not> sink q \\<and> configuration q n \\<noteq> {});\n     q \\<noteq> q\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (q \\<in> set (r (Suc n))) =\n                      (\\<not> sink q \\<and>\n                       configuration q (Suc n) \\<noteq> {})\n 2. \\<lbrakk>\\<And>q.\n                (q \\<in> set (r n)) =\n                (\\<not> sink q \\<and> configuration q n \\<noteq> {});\n     \\<not> q \\<noteq> q\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (q \\<in> set (r (Suc n))) =\n                      (\\<not> sink q \\<and>\n                       configuration q (Suc n) \\<noteq> {})", "ultimately"], ["proof (chain)\npicking this:\n  q \\<in> set (r (Suc n)) \\<Longrightarrow>\n  configuration q (Suc n) \\<noteq> {}\n  q \\<in> set (r (Suc n)) \\<Longrightarrow> \\<not> sink q\n  \\<lbrakk>\\<not> sink q; configuration q (Suc n) \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> q \\<in> set (r (Suc n))", "show ?thesis"], ["proof (prove)\nusing this:\n  q \\<in> set (r (Suc n)) \\<Longrightarrow>\n  configuration q (Suc n) \\<noteq> {}\n  q \\<in> set (r (Suc n)) \\<Longrightarrow> \\<not> sink q\n  \\<lbrakk>\\<not> sink q; configuration q (Suc n) \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> q \\<in> set (r (Suc n))\n\ngoal (1 subgoal):\n 1. (q \\<in> set (r (Suc n))) =\n    (\\<not> sink q \\<and> configuration q (Suc n) \\<noteq> {})", "by blast"], ["proof (state)\nthis:\n  (q \\<in> set (r (Suc n))) =\n  (\\<not> sink q \\<and> configuration q (Suc n) \\<noteq> {})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>q.\n                (q \\<in> set (r n)) =\n                (\\<not> sink q \\<and> configuration q n \\<noteq> {});\n     \\<not> q \\<noteq> q\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (q \\<in> set (r (Suc n))) =\n                      (\\<not> sink q \\<and>\n                       configuration q (Suc n) \\<noteq> {})", "qed (insert assms, auto simp add: r_def sink_def)"], ["proof (state)\nthis:\n  (q \\<in> set (r (Suc n))) =\n  (\\<not> sink q \\<and> configuration q (Suc n) \\<noteq> {})\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       (q \\<in> set (r 0)) =\n       (\\<not> sink q \\<and> configuration q 0 \\<noteq> {})", "qed (insert assms, auto simp add: r_def sink_def)"], ["", "lemma (in semi_mojmir) nxt_run_sorted:\n  defines \"r \\<equiv> run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\" \n  shows \"sorted (map (\\<lambda>q. the (oldest_token q n)) (r n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (map (\\<lambda>q. the (oldest_token q n)) (r n))", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. sorted (map (\\<lambda>q. the (oldest_token q 0)) (r 0))\n 2. \\<And>n.\n       sorted\n        (map (\\<lambda>q. the (oldest_token q n)) (r n)) \\<Longrightarrow>\n       sorted (map (\\<lambda>q. the (oldest_token q (Suc n))) (r (Suc n)))", "case (Suc n)"], ["proof (state)\nthis:\n  sorted (map (\\<lambda>q. the (oldest_token q n)) (r n))\n\ngoal (2 subgoals):\n 1. sorted (map (\\<lambda>q. the (oldest_token q 0)) (r 0))\n 2. \\<And>n.\n       sorted\n        (map (\\<lambda>q. the (oldest_token q n)) (r n)) \\<Longrightarrow>\n       sorted (map (\\<lambda>q. the (oldest_token q (Suc n))) (r (Suc n)))", "let ?f_n = \"\\<lambda>q. the (oldest_token q n)\""], ["proof (state)\ngoal (2 subgoals):\n 1. sorted (map (\\<lambda>q. the (oldest_token q 0)) (r 0))\n 2. \\<And>n.\n       sorted\n        (map (\\<lambda>q. the (oldest_token q n)) (r n)) \\<Longrightarrow>\n       sorted (map (\\<lambda>q. the (oldest_token q (Suc n))) (r (Suc n)))", "let ?f_Suc_n = \"\\<lambda>q. the (oldest_token q (Suc n))\""], ["proof (state)\ngoal (2 subgoals):\n 1. sorted (map (\\<lambda>q. the (oldest_token q 0)) (r 0))\n 2. \\<And>n.\n       sorted\n        (map (\\<lambda>q. the (oldest_token q n)) (r n)) \\<Longrightarrow>\n       sorted (map (\\<lambda>q. the (oldest_token q (Suc n))) (r (Suc n)))", "let ?step = \"filter (\\<lambda>q. \\<not>sink q) ((map (\\<lambda>q. \\<delta> q (w n)) (r n)) @ [q\\<^sub>0])\""], ["proof (state)\ngoal (2 subgoals):\n 1. sorted (map (\\<lambda>q. the (oldest_token q 0)) (r 0))\n 2. \\<And>n.\n       sorted\n        (map (\\<lambda>q. the (oldest_token q n)) (r n)) \\<Longrightarrow>\n       sorted (map (\\<lambda>q. the (oldest_token q (Suc n))) (r (Suc n)))", "have \"\\<And>q p qs ps. remdups_fwd ?step = qs @ q # p # ps \\<Longrightarrow> ?f_Suc_n q \\<le> ?f_Suc_n p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q p qs ps.\n       remdups_fwd\n        (filter (\\<lambda>q. \\<not> sink q)\n          (map (\\<lambda>q. \\<delta> q (w n)) (r n) @ [q\\<^sub>0])) =\n       qs @ q # p # ps \\<Longrightarrow>\n       the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q p qs ps.\n       remdups_fwd\n        (filter (\\<lambda>q. \\<not> sink q)\n          (map (\\<lambda>q. \\<delta> q (w n)) (r n) @ [q\\<^sub>0])) =\n       qs @ q # p # ps \\<Longrightarrow>\n       the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "fix q qs p ps"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q p qs ps.\n       remdups_fwd\n        (filter (\\<lambda>q. \\<not> sink q)\n          (map (\\<lambda>q. \\<delta> q (w n)) (r n) @ [q\\<^sub>0])) =\n       qs @ q # p # ps \\<Longrightarrow>\n       the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "assume \"remdups_fwd ?step = qs @ q # p # ps\""], ["proof (state)\nthis:\n  remdups_fwd\n   (filter (\\<lambda>q. \\<not> sink q)\n     (map (\\<lambda>q. \\<delta> q (w n)) (r n) @ [q\\<^sub>0])) =\n  qs @ q # p # ps\n\ngoal (1 subgoal):\n 1. \\<And>q p qs ps.\n       remdups_fwd\n        (filter (\\<lambda>q. \\<not> sink q)\n          (map (\\<lambda>q. \\<delta> q (w n)) (r n) @ [q\\<^sub>0])) =\n       qs @ q # p # ps \\<Longrightarrow>\n       the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "then"], ["proof (chain)\npicking this:\n  remdups_fwd\n   (filter (\\<lambda>q. \\<not> sink q)\n     (map (\\<lambda>q. \\<delta> q (w n)) (r n) @ [q\\<^sub>0])) =\n  qs @ q # p # ps", "obtain zs zs' zs'' where step_def: \"?step = zs @ q # zs' @ p # zs''\"\n        and \"remdups_fwd zs = qs\" \n        and \"remdups_fwd_acc (set qs \\<union> {q}) zs' = []\" \n        and \"remdups_fwd_acc (set qs \\<union> {q, p}) zs'' = ps\" \n        and \"q \\<notin> set zs\" \n        and \"p \\<notin> set zs \\<union> {q}\""], ["proof (prove)\nusing this:\n  remdups_fwd\n   (filter (\\<lambda>q. \\<not> sink q)\n     (map (\\<lambda>q. \\<delta> q (w n)) (r n) @ [q\\<^sub>0])) =\n  qs @ q # p # ps\n\ngoal (1 subgoal):\n 1. (\\<And>zs zs' zs''.\n        \\<lbrakk>filter (\\<lambda>q. \\<not> sink q)\n                  (map (\\<lambda>q. \\<delta> q (w n)) (r n) @ [q\\<^sub>0]) =\n                 zs @ q # zs' @ p # zs'';\n         remdups_fwd zs = qs;\n         remdups_fwd_acc (set qs \\<union> {q}) zs' = [];\n         remdups_fwd_acc (set qs \\<union> {q, p}) zs'' = ps;\n         q \\<notin> set zs; p \\<notin> set zs \\<union> {q}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding remdups_fwd.simps remdups_fwd_split_exact_iff remdups_fwd_split_exact_iff[where ?ys = \"[]\", simplified] insert_commute"], ["proof (prove)\nusing this:\n  \\<exists>us vs.\n     filter (\\<lambda>q. \\<not> sink q)\n      (map (\\<lambda>q. \\<delta> q (w n)) (r n) @ [q\\<^sub>0]) =\n     us @ q # vs \\<and>\n     q \\<notin> {} \\<and>\n     q \\<notin> set us \\<and>\n     remdups_fwd_acc {} us = qs \\<and>\n     (\\<exists>us vsa.\n         vs = us @ p # vsa \\<and>\n         p \\<notin> {} \\<union> set qs \\<union> {q} \\<and>\n         p \\<notin> set us \\<and>\n         remdups_fwd_acc ({} \\<union> set qs \\<union> {q}) us = [] \\<and>\n         remdups_fwd_acc (insert p ({} \\<union> set qs \\<union> {q})) vsa =\n         ps)\n\ngoal (1 subgoal):\n 1. (\\<And>zs zs' zs''.\n        \\<lbrakk>filter (\\<lambda>q. \\<not> sink q)\n                  (map (\\<lambda>q. \\<delta> q (w n)) (r n) @ [q\\<^sub>0]) =\n                 zs @ q # zs' @ p # zs'';\n         remdups_fwd_acc {} zs = qs;\n         remdups_fwd_acc (set qs \\<union> {q}) zs' = [];\n         remdups_fwd_acc (set qs \\<union> {p, q}) zs'' = ps;\n         q \\<notin> set zs; p \\<notin> set zs \\<union> {q}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  filter (\\<lambda>q. \\<not> sink q)\n   (map (\\<lambda>q. \\<delta> q (w n)) (r n) @ [q\\<^sub>0]) =\n  zs @ q # zs' @ p # zs''\n  remdups_fwd zs = qs\n  remdups_fwd_acc (set qs \\<union> {q}) zs' = []\n  remdups_fwd_acc (set qs \\<union> {q, p}) zs'' = ps\n  q \\<notin> set zs\n  p \\<notin> set zs \\<union> {q}\n\ngoal (1 subgoal):\n 1. \\<And>q p qs ps.\n       remdups_fwd\n        (filter (\\<lambda>q. \\<not> sink q)\n          (map (\\<lambda>q. \\<delta> q (w n)) (r n) @ [q\\<^sub>0])) =\n       qs @ q # p # ps \\<Longrightarrow>\n       the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "hence  \"p \\<notin> set zs \\<union> set zs' \\<union> {q}\"\n        and \"q \\<noteq> p\""], ["proof (prove)\nusing this:\n  filter (\\<lambda>q. \\<not> sink q)\n   (map (\\<lambda>q. \\<delta> q (w n)) (r n) @ [q\\<^sub>0]) =\n  zs @ q # zs' @ p # zs''\n  remdups_fwd zs = qs\n  remdups_fwd_acc (set qs \\<union> {q}) zs' = []\n  remdups_fwd_acc (set qs \\<union> {q, p}) zs'' = ps\n  q \\<notin> set zs\n  p \\<notin> set zs \\<union> {q}\n\ngoal (1 subgoal):\n 1. p \\<notin> set zs \\<union> set zs' \\<union> {q} &&& q \\<noteq> p", "unfolding remdups_fwd_acc_empty[symmetric]"], ["proof (prove)\nusing this:\n  filter (\\<lambda>q. \\<not> sink q)\n   (map (\\<lambda>q. \\<delta> q (w n)) (r n) @ [q\\<^sub>0]) =\n  zs @ q # zs' @ p # zs''\n  remdups_fwd zs = qs\n  set zs' \\<subseteq> set qs \\<union> {q}\n  remdups_fwd_acc (set qs \\<union> {q, p}) zs'' = ps\n  q \\<notin> set zs\n  p \\<notin> set zs \\<union> {q}\n\ngoal (1 subgoal):\n 1. p \\<notin> set zs \\<union> set zs' \\<union> {q} &&& q \\<noteq> p", "by auto"], ["proof (state)\nthis:\n  p \\<notin> set zs \\<union> set zs' \\<union> {q}\n  q \\<noteq> p\n\ngoal (1 subgoal):\n 1. \\<And>q p qs ps.\n       remdups_fwd\n        (filter (\\<lambda>q. \\<not> sink q)\n          (map (\\<lambda>q. \\<delta> q (w n)) (r n) @ [q\\<^sub>0])) =\n       qs @ q # p # ps \\<Longrightarrow>\n       the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "hence  \"p \\<notin> set zs \\<union> set zs' \\<union> set [q]\""], ["proof (prove)\nusing this:\n  p \\<notin> set zs \\<union> set zs' \\<union> {q}\n  q \\<noteq> p\n\ngoal (1 subgoal):\n 1. p \\<notin> set zs \\<union> set zs' \\<union> set [q]", "by simp"], ["proof (state)\nthis:\n  p \\<notin> set zs \\<union> set zs' \\<union> set [q]\n\ngoal (1 subgoal):\n 1. \\<And>q p qs ps.\n       remdups_fwd\n        (filter (\\<lambda>q. \\<not> sink q)\n          (map (\\<lambda>q. \\<delta> q (w n)) (r n) @ [q\\<^sub>0])) =\n       qs @ q # p # ps \\<Longrightarrow>\n       the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "hence \"{q, p} \\<subseteq> set ?step\""], ["proof (prove)\nusing this:\n  p \\<notin> set zs \\<union> set zs' \\<union> set [q]\n\ngoal (1 subgoal):\n 1. {q, p}\n    \\<subseteq> set (filter (\\<lambda>q. \\<not> sink q)\n                      (map (\\<lambda>q. \\<delta> q (w n)) (r n) @\n                       [q\\<^sub>0]))", "using step_def"], ["proof (prove)\nusing this:\n  p \\<notin> set zs \\<union> set zs' \\<union> set [q]\n  filter (\\<lambda>q. \\<not> sink q)\n   (map (\\<lambda>q. \\<delta> q (w n)) (r n) @ [q\\<^sub>0]) =\n  zs @ q # zs' @ p # zs''\n\ngoal (1 subgoal):\n 1. {q, p}\n    \\<subseteq> set (filter (\\<lambda>q. \\<not> sink q)\n                      (map (\\<lambda>q. \\<delta> q (w n)) (r n) @\n                       [q\\<^sub>0]))", "by simp"], ["proof (state)\nthis:\n  {q, p}\n  \\<subseteq> set (filter (\\<lambda>q. \\<not> sink q)\n                    (map (\\<lambda>q. \\<delta> q (w n)) (r n) @\n                     [q\\<^sub>0]))\n\ngoal (1 subgoal):\n 1. \\<And>q p qs ps.\n       remdups_fwd\n        (filter (\\<lambda>q. \\<not> sink q)\n          (map (\\<lambda>q. \\<delta> q (w n)) (r n) @ [q\\<^sub>0])) =\n       qs @ q # p # ps \\<Longrightarrow>\n       the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "hence \"\\<not> sink q\" and \"\\<not> sink p\""], ["proof (prove)\nusing this:\n  {q, p}\n  \\<subseteq> set (filter (\\<lambda>q. \\<not> sink q)\n                    (map (\\<lambda>q. \\<delta> q (w n)) (r n) @\n                     [q\\<^sub>0]))\n\ngoal (1 subgoal):\n 1. \\<not> sink q &&& \\<not> sink p", "unfolding set_map set_filter"], ["proof (prove)\nusing this:\n  {q, p}\n  \\<subseteq> {x \\<in> set (map (\\<lambda>q. \\<delta> q (w n)) (r n) @\n                            [q\\<^sub>0]).\n               \\<not> sink x}\n\ngoal (1 subgoal):\n 1. \\<not> sink q &&& \\<not> sink p", "by blast+"], ["proof (state)\nthis:\n  \\<not> sink q\n  \\<not> sink p\n\ngoal (1 subgoal):\n 1. \\<And>q p qs ps.\n       remdups_fwd\n        (filter (\\<lambda>q. \\<not> sink q)\n          (map (\\<lambda>q. \\<delta> q (w n)) (r n) @ [q\\<^sub>0])) =\n       qs @ q # p # ps \\<Longrightarrow>\n       the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "show \"?f_Suc_n q \\<le> ?f_Suc_n p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "proof (cases \"zs'' = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. zs'' = [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))\n 2. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "case True"], ["proof (state)\nthis:\n  zs'' = []\n\ngoal (2 subgoals):\n 1. zs'' = [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))\n 2. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "hence \"p = q\\<^sub>0\" and q_def: \"filter (\\<lambda>q. \\<not>sink q) (map (\\<lambda>q. \\<delta> q (w n)) (r n)) = zs @ [q] @ zs'\""], ["proof (prove)\nusing this:\n  zs'' = []\n\ngoal (1 subgoal):\n 1. p = q\\<^sub>0 &&&\n    filter (\\<lambda>q. \\<not> sink q)\n     (map (\\<lambda>q. \\<delta> q (w n)) (r n)) =\n    zs @ [q] @ zs'", "using step_def"], ["proof (prove)\nusing this:\n  zs'' = []\n  filter (\\<lambda>q. \\<not> sink q)\n   (map (\\<lambda>q. \\<delta> q (w n)) (r n) @ [q\\<^sub>0]) =\n  zs @ q # zs' @ p # zs''\n\ngoal (1 subgoal):\n 1. p = q\\<^sub>0 &&&\n    filter (\\<lambda>q. \\<not> sink q)\n     (map (\\<lambda>q. \\<delta> q (w n)) (r n)) =\n    zs @ [q] @ zs'", "unfolding sink_def"], ["proof (prove)\nusing this:\n  zs'' = []\n  filter\n   (\\<lambda>q.\n       \\<not> (q\\<^sub>0 \\<noteq> q \\<and>\n               (\\<forall>\\<nu>\\<in>\\<Sigma>. \\<delta> q \\<nu> = q)))\n   (map (\\<lambda>q. \\<delta> q (w n)) (r n) @ [q\\<^sub>0]) =\n  zs @ q # zs' @ p # zs''\n\ngoal (1 subgoal):\n 1. p = q\\<^sub>0 &&&\n    filter\n     (\\<lambda>q.\n         \\<not> (q\\<^sub>0 \\<noteq> q \\<and>\n                 (\\<forall>\\<nu>\\<in>\\<Sigma>. \\<delta> q \\<nu> = q)))\n     (map (\\<lambda>q. \\<delta> q (w n)) (r n)) =\n    zs @ [q] @ zs'", "by simp+"], ["proof (state)\nthis:\n  p = q\\<^sub>0\n  filter (\\<lambda>q. \\<not> sink q)\n   (map (\\<lambda>q. \\<delta> q (w n)) (r n)) =\n  zs @ [q] @ zs'\n\ngoal (2 subgoals):\n 1. zs'' = [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))\n 2. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "hence \"q\\<^sub>0 \\<notin> set (filter (\\<lambda>q. \\<not>sink q) (map (\\<lambda>q. \\<delta> q (w n)) (r n)))\""], ["proof (prove)\nusing this:\n  p = q\\<^sub>0\n  filter (\\<lambda>q. \\<not> sink q)\n   (map (\\<lambda>q. \\<delta> q (w n)) (r n)) =\n  zs @ [q] @ zs'\n\ngoal (1 subgoal):\n 1. q\\<^sub>0\n    \\<notin> set (filter (\\<lambda>q. \\<not> sink q)\n                   (map (\\<lambda>q. \\<delta> q (w n)) (r n)))", "using \\<open>p \\<notin> set zs \\<union> set zs' \\<union> {q}\\<close>"], ["proof (prove)\nusing this:\n  p = q\\<^sub>0\n  filter (\\<lambda>q. \\<not> sink q)\n   (map (\\<lambda>q. \\<delta> q (w n)) (r n)) =\n  zs @ [q] @ zs'\n  p \\<notin> set zs \\<union> set zs' \\<union> {q}\n\ngoal (1 subgoal):\n 1. q\\<^sub>0\n    \\<notin> set (filter (\\<lambda>q. \\<not> sink q)\n                   (map (\\<lambda>q. \\<delta> q (w n)) (r n)))", "unfolding \\<open>p = q\\<^sub>0\\<close> sink_def"], ["proof (prove)\nusing this:\n  q\\<^sub>0 = q\\<^sub>0\n  filter\n   (\\<lambda>q.\n       \\<not> (q\\<^sub>0 \\<noteq> q \\<and>\n               (\\<forall>\\<nu>\\<in>\\<Sigma>. \\<delta> q \\<nu> = q)))\n   (map (\\<lambda>q. \\<delta> q (w n)) (r n)) =\n  zs @ [q] @ zs'\n  q\\<^sub>0 \\<notin> set zs \\<union> set zs' \\<union> {q}\n\ngoal (1 subgoal):\n 1. q\\<^sub>0\n    \\<notin> set (filter\n                   (\\<lambda>q.\n                       \\<not> (q\\<^sub>0 \\<noteq> q \\<and>\n                               (\\<forall>\\<nu>\\<in>\\<Sigma>.\n                                   \\<delta> q \\<nu> = q)))\n                   (map (\\<lambda>q. \\<delta> q (w n)) (r n)))", "by simp"], ["proof (state)\nthis:\n  q\\<^sub>0\n  \\<notin> set (filter (\\<lambda>q. \\<not> sink q)\n                 (map (\\<lambda>q. \\<delta> q (w n)) (r n)))\n\ngoal (2 subgoals):\n 1. zs'' = [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))\n 2. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "hence \"q\\<^sub>0 \\<notin> (\\<lambda>q. \\<delta> q (w n)) ` {q'. configuration q' n \\<noteq> {}}\""], ["proof (prove)\nusing this:\n  q\\<^sub>0\n  \\<notin> set (filter (\\<lambda>q. \\<not> sink q)\n                 (map (\\<lambda>q. \\<delta> q (w n)) (r n)))\n\ngoal (1 subgoal):\n 1. q\\<^sub>0\n    \\<notin> (\\<lambda>q. \\<delta> q (w n)) `\n             {q'. configuration q' n \\<noteq> {}}", "using nxt_run_configuration bounded_w"], ["proof (prove)\nusing this:\n  q\\<^sub>0\n  \\<notin> set (filter (\\<lambda>q. \\<not> sink q)\n                 (map (\\<lambda>q. \\<delta> q (w n)) (r n)))\n  (?q \\<in> set (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n                  ?n)) =\n  (\\<not> sink ?q \\<and> configuration ?q ?n \\<noteq> {})\n  range w \\<subseteq> \\<Sigma>\n\ngoal (1 subgoal):\n 1. q\\<^sub>0\n    \\<notin> (\\<lambda>q. \\<delta> q (w n)) `\n             {q'. configuration q' n \\<noteq> {}}", "unfolding set_map set_filter r_def sink_def init.simps"], ["proof (prove)\nusing this:\n  q\\<^sub>0\n  \\<notin> {x \\<in> (\\<lambda>q. \\<delta> q (w n)) `\n                    set (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) [q\\<^sub>0] w\n                          n).\n            \\<not> (q\\<^sub>0 \\<noteq> x \\<and>\n                    (\\<forall>\\<nu>\\<in>\\<Sigma>. \\<delta> x \\<nu> = x))}\n  (?q \\<in> set (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) [q\\<^sub>0] w ?n)) =\n  (\\<not> (q\\<^sub>0 \\<noteq> ?q \\<and>\n           (\\<forall>\\<nu>\\<in>\\<Sigma>. \\<delta> ?q \\<nu> = ?q)) \\<and>\n   configuration ?q ?n \\<noteq> {})\n  range w \\<subseteq> \\<Sigma>\n\ngoal (1 subgoal):\n 1. q\\<^sub>0\n    \\<notin> (\\<lambda>q. \\<delta> q (w n)) `\n             {q'. configuration q' n \\<noteq> {}}", "by blast"], ["proof (state)\nthis:\n  q\\<^sub>0\n  \\<notin> (\\<lambda>q. \\<delta> q (w n)) `\n           {q'. configuration q' n \\<noteq> {}}\n\ngoal (2 subgoals):\n 1. zs'' = [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))\n 2. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "hence \"configuration p (Suc n) = {Suc n}\""], ["proof (prove)\nusing this:\n  q\\<^sub>0\n  \\<notin> (\\<lambda>q. \\<delta> q (w n)) `\n           {q'. configuration q' n \\<noteq> {}}\n\ngoal (1 subgoal):\n 1. configuration p (Suc n) = {Suc n}", "using assms"], ["proof (prove)\nusing this:\n  q\\<^sub>0\n  \\<notin> (\\<lambda>q. \\<delta> q (w n)) `\n           {q'. configuration q' n \\<noteq> {}}\n  r \\<equiv> run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n\ngoal (1 subgoal):\n 1. configuration p (Suc n) = {Suc n}", "unfolding \\<open>p = q\\<^sub>0\\<close>"], ["proof (prove)\nusing this:\n  q\\<^sub>0\n  \\<notin> (\\<lambda>q. \\<delta> q (w n)) `\n           {q'. configuration q' n \\<noteq> {}}\n  r \\<equiv> run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n\ngoal (1 subgoal):\n 1. configuration q\\<^sub>0 (Suc n) = {Suc n}", "using configuration_step_eq_q\\<^sub>0"], ["proof (prove)\nusing this:\n  q\\<^sub>0\n  \\<notin> (\\<lambda>q. \\<delta> q (w n)) `\n           {q'. configuration q' n \\<noteq> {}}\n  r \\<equiv> run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n  configuration q\\<^sub>0 (Suc ?n) =\n  {Suc ?n} \\<union>\n  \\<Union> {configuration q' ?n |q'. q\\<^sub>0 = \\<delta> q' (w ?n)}\n\ngoal (1 subgoal):\n 1. configuration q\\<^sub>0 (Suc n) = {Suc n}", "by blast"], ["proof (state)\nthis:\n  configuration p (Suc n) = {Suc n}\n\ngoal (2 subgoals):\n 1. zs'' = [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))\n 2. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "hence \"?f_Suc_n p = Suc n\""], ["proof (prove)\nusing this:\n  configuration p (Suc n) = {Suc n}\n\ngoal (1 subgoal):\n 1. the (oldest_token p (Suc n)) = Suc n", "using assms"], ["proof (prove)\nusing this:\n  configuration p (Suc n) = {Suc n}\n  r \\<equiv> run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n\ngoal (1 subgoal):\n 1. the (oldest_token p (Suc n)) = Suc n", "by force"], ["proof (state)\nthis:\n  the (oldest_token p (Suc n)) = Suc n\n\ngoal (2 subgoals):\n 1. zs'' = [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))\n 2. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "moreover"], ["proof (state)\nthis:\n  the (oldest_token p (Suc n)) = Suc n\n\ngoal (2 subgoals):\n 1. zs'' = [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))\n 2. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "have \"q \\<in> (\\<lambda>q. \\<delta> q (w n)) ` set (r n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> (\\<lambda>q. \\<delta> q (w n)) ` set (r n)", "using  \\<open>p \\<notin> set zs \\<union> set zs' \\<union> {q}\\<close> image_set"], ["proof (prove)\nusing this:\n  p \\<notin> set zs \\<union> set zs' \\<union> {q}\n  ?f ` set ?xs = set (map ?f ?xs)\n\ngoal (1 subgoal):\n 1. q \\<in> (\\<lambda>q. \\<delta> q (w n)) ` set (r n)", "unfolding filter_map_split_iff[of \"(\\<lambda>q. \\<not> sink q)\" \"\\<lambda>q. \\<delta> q (w n)\"]"], ["proof (prove)\nusing this:\n  p \\<notin> set zs \\<union> set zs' \\<union> {q}\n  ?f ` set ?xs = set (map ?f ?xs)\n\ngoal (1 subgoal):\n 1. q \\<in> (\\<lambda>q. \\<delta> q (w n)) ` set (r n)", "by (metis (no_types, lifting) Un_insert_right \\<open>p = q\\<^sub>0\\<close>  \\<open>{q, p} \\<subseteq> set [q\\<leftarrow>map (\\<lambda>q. \\<delta> q (w n)) (r n) @ [q\\<^sub>0] . \\<not> sink q]\\<close> append_Nil2 insert_iff insert_subset list.simps(15) mem_Collect_eq set_append set_filter)"], ["proof (state)\nthis:\n  q \\<in> (\\<lambda>q. \\<delta> q (w n)) ` set (r n)\n\ngoal (2 subgoals):\n 1. zs'' = [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))\n 2. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "hence \"q \\<in> (\\<lambda>q. \\<delta> q (w n)) ` {q'. configuration q' n \\<noteq> {}}\""], ["proof (prove)\nusing this:\n  q \\<in> (\\<lambda>q. \\<delta> q (w n)) ` set (r n)\n\ngoal (1 subgoal):\n 1. q \\<in> (\\<lambda>q. \\<delta> q (w n)) `\n            {q'. configuration q' n \\<noteq> {}}", "using nxt_run_configuration"], ["proof (prove)\nusing this:\n  q \\<in> (\\<lambda>q. \\<delta> q (w n)) ` set (r n)\n  (?q \\<in> set (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n                  ?n)) =\n  (\\<not> sink ?q \\<and> configuration ?q ?n \\<noteq> {})\n\ngoal (1 subgoal):\n 1. q \\<in> (\\<lambda>q. \\<delta> q (w n)) `\n            {q'. configuration q' n \\<noteq> {}}", "unfolding r_def"], ["proof (prove)\nusing this:\n  q \\<in> (\\<lambda>q. \\<delta> q (w n)) `\n          set (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w n)\n  (?q \\<in> set (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n                  ?n)) =\n  (\\<not> sink ?q \\<and> configuration ?q ?n \\<noteq> {})\n\ngoal (1 subgoal):\n 1. q \\<in> (\\<lambda>q. \\<delta> q (w n)) `\n            {q'. configuration q' n \\<noteq> {}}", "by auto"], ["proof (state)\nthis:\n  q \\<in> (\\<lambda>q. \\<delta> q (w n)) `\n          {q'. configuration q' n \\<noteq> {}}\n\ngoal (2 subgoals):\n 1. zs'' = [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))\n 2. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "hence \"configuration q (Suc n) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  q \\<in> (\\<lambda>q. \\<delta> q (w n)) `\n          {q'. configuration q' n \\<noteq> {}}\n\ngoal (1 subgoal):\n 1. configuration q (Suc n) \\<noteq> {}", "using configuration_step assms"], ["proof (prove)\nusing this:\n  q \\<in> (\\<lambda>q. \\<delta> q (w n)) `\n          {q'. configuration q' n \\<noteq> {}}\n  \\<lbrakk>?x \\<in> configuration ?q' ?n; ?q = \\<delta> ?q' (w ?n)\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> configuration ?q (Suc ?n)\n  r \\<equiv> run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n\ngoal (1 subgoal):\n 1. configuration q (Suc n) \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  configuration q (Suc n) \\<noteq> {}\n\ngoal (2 subgoals):\n 1. zs'' = [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))\n 2. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "hence \"?f_Suc_n q \\<le> Suc n\""], ["proof (prove)\nusing this:\n  configuration q (Suc n) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. the (oldest_token q (Suc n)) \\<le> Suc n", "using assms oldest_token_bounded[of q \"Suc n\"]"], ["proof (prove)\nusing this:\n  configuration q (Suc n) \\<noteq> {}\n  r \\<equiv> run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n  oldest_token q (Suc n) = Some ?x \\<Longrightarrow> ?x \\<le> Suc n\n\ngoal (1 subgoal):\n 1. the (oldest_token q (Suc n)) \\<le> Suc n", "by (simp del: configuration.simps)"], ["proof (state)\nthis:\n  the (oldest_token q (Suc n)) \\<le> Suc n\n\ngoal (2 subgoals):\n 1. zs'' = [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))\n 2. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "ultimately"], ["proof (chain)\npicking this:\n  the (oldest_token p (Suc n)) = Suc n\n  the (oldest_token q (Suc n)) \\<le> Suc n", "show \"?f_Suc_n q \\<le> ?f_Suc_n p\""], ["proof (prove)\nusing this:\n  the (oldest_token p (Suc n)) = Suc n\n  the (oldest_token q (Suc n)) \\<le> Suc n\n\ngoal (1 subgoal):\n 1. the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "by presburger"], ["proof (state)\nthis:\n  the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "case False"], ["proof (state)\nthis:\n  zs'' \\<noteq> []\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "hence X: \"filter (\\<lambda>q. \\<not>sink q) (map (\\<lambda>q. \\<delta> q (w n)) (r n)) = zs @ [q] @ zs' @ [p] @ butlast zs''\""], ["proof (prove)\nusing this:\n  zs'' \\<noteq> []\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>q. \\<not> sink q)\n     (map (\\<lambda>q. \\<delta> q (w n)) (r n)) =\n    zs @ [q] @ zs' @ [p] @ butlast zs''", "using step_def"], ["proof (prove)\nusing this:\n  zs'' \\<noteq> []\n  filter (\\<lambda>q. \\<not> sink q)\n   (map (\\<lambda>q. \\<delta> q (w n)) (r n) @ [q\\<^sub>0]) =\n  zs @ q # zs' @ p # zs''\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>q. \\<not> sink q)\n     (map (\\<lambda>q. \\<delta> q (w n)) (r n)) =\n    zs @ [q] @ zs' @ [p] @ butlast zs''", "unfolding map_append filter_append sink_def"], ["proof (prove)\nusing this:\n  zs'' \\<noteq> []\n  filter\n   (\\<lambda>q.\n       \\<not> (q\\<^sub>0 \\<noteq> q \\<and>\n               (\\<forall>\\<nu>\\<in>\\<Sigma>. \\<delta> q \\<nu> = q)))\n   (map (\\<lambda>q. \\<delta> q (w n)) (r n)) @\n  filter\n   (\\<lambda>q.\n       \\<not> (q\\<^sub>0 \\<noteq> q \\<and>\n               (\\<forall>\\<nu>\\<in>\\<Sigma>. \\<delta> q \\<nu> = q)))\n   [q\\<^sub>0] =\n  zs @ q # zs' @ p # zs''\n\ngoal (1 subgoal):\n 1. filter\n     (\\<lambda>q.\n         \\<not> (q\\<^sub>0 \\<noteq> q \\<and>\n                 (\\<forall>\\<nu>\\<in>\\<Sigma>. \\<delta> q \\<nu> = q)))\n     (map (\\<lambda>q. \\<delta> q (w n)) (r n)) =\n    zs @ [q] @ zs' @ [p] @ butlast zs''", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>zs'' \\<noteq> [];\n     filter\n      (\\<lambda>q.\n          q\\<^sub>0 = q \\<or>\n          (\\<exists>\\<nu>\\<in>\\<Sigma>. \\<delta> q \\<nu> \\<noteq> q))\n      (map (\\<lambda>q. \\<delta> q (w n)) (r n)) @\n     [q\\<^sub>0] =\n     zs @ q # zs' @ p # zs''\\<rbrakk>\n    \\<Longrightarrow> filter\n                       (\\<lambda>q.\n                           q\\<^sub>0 = q \\<or>\n                           (\\<exists>\\<nu>\\<in>\\<Sigma>.\n                               \\<delta> q \\<nu> \\<noteq> q))\n                       (map (\\<lambda>q. \\<delta> q (w n)) (r n)) =\n                      zs @ q # zs' @ p # butlast zs''", "by (metis (no_types, lifting) butlast.simps(2) list.distinct(1) butlast_append append_is_Nil_conv butlast_snoc)"], ["proof (state)\nthis:\n  filter (\\<lambda>q. \\<not> sink q)\n   (map (\\<lambda>q. \\<delta> q (w n)) (r n)) =\n  zs @ [q] @ zs' @ [p] @ butlast zs''\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "(* Slow *)"], ["proof (state)\nthis:\n  filter (\\<lambda>q. \\<not> sink q)\n   (map (\\<lambda>q. \\<delta> q (w n)) (r n)) =\n  zs @ [q] @ zs' @ [p] @ butlast zs''\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "obtain qs' sq' sp' ps' ps'' where r_def': \"r n = qs' @ sq' @ ps' @ sp' @ ps''\"\n            and 1: \"filter (\\<lambda>q. \\<not>sink q) (map (\\<lambda>q. \\<delta> q (w n)) qs') = zs\"\n            and 2: \"filter (\\<lambda>q. \\<not>sink q) (map (\\<lambda>q. \\<delta> q (w n)) sq') = [q]\"\n            and 3: \"filter (\\<lambda>q. \\<not>sink q) (map (\\<lambda>q. \\<delta> q (w n)) ps') = zs'\"\n            and \"filter (\\<lambda>q. \\<not>sink q) (map (\\<lambda>q. \\<delta> q (w n)) sp') = [p]\"\n            and \"filter (\\<lambda>q. \\<not>sink q) (map (\\<lambda>q. \\<delta> q (w n)) ps'') = butlast zs''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>qs' sq' ps' sp' ps''.\n        \\<lbrakk>r n = qs' @ sq' @ ps' @ sp' @ ps'';\n         filter (\\<lambda>q. \\<not> sink q)\n          (map (\\<lambda>q. \\<delta> q (w n)) qs') =\n         zs;\n         filter (\\<lambda>q. \\<not> sink q)\n          (map (\\<lambda>q. \\<delta> q (w n)) sq') =\n         [q];\n         filter (\\<lambda>q. \\<not> sink q)\n          (map (\\<lambda>q. \\<delta> q (w n)) ps') =\n         zs';\n         filter (\\<lambda>q. \\<not> sink q)\n          (map (\\<lambda>q. \\<delta> q (w n)) sp') =\n         [p];\n         filter (\\<lambda>q. \\<not> sink q)\n          (map (\\<lambda>q. \\<delta> q (w n)) ps'') =\n         butlast zs''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using X"], ["proof (prove)\nusing this:\n  filter (\\<lambda>q. \\<not> sink q)\n   (map (\\<lambda>q. \\<delta> q (w n)) (r n)) =\n  zs @ [q] @ zs' @ [p] @ butlast zs''\n\ngoal (1 subgoal):\n 1. (\\<And>qs' sq' ps' sp' ps''.\n        \\<lbrakk>r n = qs' @ sq' @ ps' @ sp' @ ps'';\n         filter (\\<lambda>q. \\<not> sink q)\n          (map (\\<lambda>q. \\<delta> q (w n)) qs') =\n         zs;\n         filter (\\<lambda>q. \\<not> sink q)\n          (map (\\<lambda>q. \\<delta> q (w n)) sq') =\n         [q];\n         filter (\\<lambda>q. \\<not> sink q)\n          (map (\\<lambda>q. \\<delta> q (w n)) ps') =\n         zs';\n         filter (\\<lambda>q. \\<not> sink q)\n          (map (\\<lambda>q. \\<delta> q (w n)) sp') =\n         [p];\n         filter (\\<lambda>q. \\<not> sink q)\n          (map (\\<lambda>q. \\<delta> q (w n)) ps'') =\n         butlast zs''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding filter_map_split_iff"], ["proof (prove)\nusing this:\n  \\<exists>us vs.\n     r n = us @ vs \\<and>\n     filter (\\<lambda>q. \\<not> sink q)\n      (map (\\<lambda>q. \\<delta> q (w n)) us) =\n     zs \\<and>\n     (\\<exists>us vsa.\n         vs = us @ vsa \\<and>\n         filter (\\<lambda>q. \\<not> sink q)\n          (map (\\<lambda>q. \\<delta> q (w n)) us) =\n         [q] \\<and>\n         (\\<exists>us vs.\n             vsa = us @ vs \\<and>\n             filter (\\<lambda>q. \\<not> sink q)\n              (map (\\<lambda>q. \\<delta> q (w n)) us) =\n             zs' \\<and>\n             (\\<exists>us vsa.\n                 vs = us @ vsa \\<and>\n                 filter (\\<lambda>q. \\<not> sink q)\n                  (map (\\<lambda>q. \\<delta> q (w n)) us) =\n                 [p] \\<and>\n                 filter (\\<lambda>q. \\<not> sink q)\n                  (map (\\<lambda>q. \\<delta> q (w n)) vsa) =\n                 butlast zs'')))\n\ngoal (1 subgoal):\n 1. (\\<And>qs' sq' ps' sp' ps''.\n        \\<lbrakk>r n = qs' @ sq' @ ps' @ sp' @ ps'';\n         filter (\\<lambda>q. \\<not> sink q)\n          (map (\\<lambda>q. \\<delta> q (w n)) qs') =\n         zs;\n         filter (\\<lambda>q. \\<not> sink q)\n          (map (\\<lambda>q. \\<delta> q (w n)) sq') =\n         [q];\n         filter (\\<lambda>q. \\<not> sink q)\n          (map (\\<lambda>q. \\<delta> q (w n)) ps') =\n         zs';\n         filter (\\<lambda>q. \\<not> sink q)\n          (map (\\<lambda>q. \\<delta> q (w n)) sp') =\n         [p];\n         filter (\\<lambda>q. \\<not> sink q)\n          (map (\\<lambda>q. \\<delta> q (w n)) ps'') =\n         butlast zs''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast)"], ["proof (state)\nthis:\n  r n = qs' @ sq' @ ps' @ sp' @ ps''\n  filter (\\<lambda>q. \\<not> sink q)\n   (map (\\<lambda>q. \\<delta> q (w n)) qs') =\n  zs\n  filter (\\<lambda>q. \\<not> sink q)\n   (map (\\<lambda>q. \\<delta> q (w n)) sq') =\n  [q]\n  filter (\\<lambda>q. \\<not> sink q)\n   (map (\\<lambda>q. \\<delta> q (w n)) ps') =\n  zs'\n  filter (\\<lambda>q. \\<not> sink q)\n   (map (\\<lambda>q. \\<delta> q (w n)) sp') =\n  [p]\n  filter (\\<lambda>q. \\<not> sink q)\n   (map (\\<lambda>q. \\<delta> q (w n)) ps'') =\n  butlast zs''\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "hence 21: \"Set.filter (\\<lambda>q. \\<not>sink q) ((\\<lambda>q. \\<delta> q (w n)) ` set sq') = {q}\"\n            and 41: \"Set.filter (\\<lambda>q. \\<not>sink q) ((\\<lambda>q. \\<delta> q (w n)) ` set sp') = {p}\""], ["proof (prove)\nusing this:\n  r n = qs' @ sq' @ ps' @ sp' @ ps''\n  filter (\\<lambda>q. \\<not> sink q)\n   (map (\\<lambda>q. \\<delta> q (w n)) qs') =\n  zs\n  filter (\\<lambda>q. \\<not> sink q)\n   (map (\\<lambda>q. \\<delta> q (w n)) sq') =\n  [q]\n  filter (\\<lambda>q. \\<not> sink q)\n   (map (\\<lambda>q. \\<delta> q (w n)) ps') =\n  zs'\n  filter (\\<lambda>q. \\<not> sink q)\n   (map (\\<lambda>q. \\<delta> q (w n)) sp') =\n  [p]\n  filter (\\<lambda>q. \\<not> sink q)\n   (map (\\<lambda>q. \\<delta> q (w n)) ps'') =\n  butlast zs''\n\ngoal (1 subgoal):\n 1. Set.filter (\\<lambda>q. \\<not> sink q)\n     ((\\<lambda>q. \\<delta> q (w n)) ` set sq') =\n    {q} &&&\n    Set.filter (\\<lambda>q. \\<not> sink q)\n     ((\\<lambda>q. \\<delta> q (w n)) ` set sp') =\n    {p}", "by (metis filter_set image_set list.set(1) list.simps(15))+"], ["proof (state)\nthis:\n  Set.filter (\\<lambda>q. \\<not> sink q)\n   ((\\<lambda>q. \\<delta> q (w n)) ` set sq') =\n  {q}\n  Set.filter (\\<lambda>q. \\<not> sink q)\n   ((\\<lambda>q. \\<delta> q (w n)) ` set sp') =\n  {p}\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "from 21"], ["proof (chain)\npicking this:\n  Set.filter (\\<lambda>q. \\<not> sink q)\n   ((\\<lambda>q. \\<delta> q (w n)) ` set sq') =\n  {q}", "obtain q' where \"q' \\<in> set sq'\" and \"\\<not> sink q'\" and \"q = \\<delta> q' (w n)\""], ["proof (prove)\nusing this:\n  Set.filter (\\<lambda>q. \\<not> sink q)\n   ((\\<lambda>q. \\<delta> q (w n)) ` set sq') =\n  {q}\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        \\<lbrakk>q' \\<in> set sq'; \\<not> sink q';\n         q = \\<delta> q' (w n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using sink_rev_step(2)[OF \\<open>\\<not> sink q\\<close>, of _ n]"], ["proof (prove)\nusing this:\n  Set.filter (\\<lambda>q. \\<not> sink q)\n   ((\\<lambda>q. \\<delta> q (w n)) ` set sq') =\n  {q}\n  q = \\<delta> ?q' (w n) \\<Longrightarrow> \\<not> sink ?q'\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        \\<lbrakk>q' \\<in> set sq'; \\<not> sink q';\n         q = \\<delta> q' (w n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  q' \\<in> set sq'\n  \\<not> sink q'\n  q = \\<delta> q' (w n)\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "from 41"], ["proof (chain)\npicking this:\n  Set.filter (\\<lambda>q. \\<not> sink q)\n   ((\\<lambda>q. \\<delta> q (w n)) ` set sp') =\n  {p}", "obtain p' where \"p' \\<in> set sp'\" and \"\\<not> sink p'\" and \"p = \\<delta> p' (w n)\""], ["proof (prove)\nusing this:\n  Set.filter (\\<lambda>q. \\<not> sink q)\n   ((\\<lambda>q. \\<delta> q (w n)) ` set sp') =\n  {p}\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        \\<lbrakk>p' \\<in> set sp'; \\<not> sink p';\n         p = \\<delta> p' (w n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using sink_rev_step(2)[OF \\<open>\\<not> sink p\\<close>, of _ n]"], ["proof (prove)\nusing this:\n  Set.filter (\\<lambda>q. \\<not> sink q)\n   ((\\<lambda>q. \\<delta> q (w n)) ` set sp') =\n  {p}\n  p = \\<delta> ?q' (w n) \\<Longrightarrow> \\<not> sink ?q'\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        \\<lbrakk>p' \\<in> set sp'; \\<not> sink p';\n         p = \\<delta> p' (w n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  p' \\<in> set sp'\n  \\<not> sink p'\n  p = \\<delta> p' (w n)\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "from Suc"], ["proof (chain)\npicking this:\n  sorted (map (\\<lambda>q. the (oldest_token q n)) (r n))", "have \"?f_n q' \\<le> ?f_n p'\""], ["proof (prove)\nusing this:\n  sorted (map (\\<lambda>q. the (oldest_token q n)) (r n))\n\ngoal (1 subgoal):\n 1. the (oldest_token q' n) \\<le> the (oldest_token p' n)", "unfolding r_def' map_append sorted_append set_append set_map"], ["proof (prove)\nusing this:\n  sorted (map (\\<lambda>q. the (oldest_token q n)) qs') \\<and>\n  (sorted (map (\\<lambda>q. the (oldest_token q n)) sq') \\<and>\n   (sorted (map (\\<lambda>q. the (oldest_token q n)) ps') \\<and>\n    (sorted (map (\\<lambda>q. the (oldest_token q n)) sp') \\<and>\n     sorted (map (\\<lambda>q. the (oldest_token q n)) ps'') \\<and>\n     (\\<forall>x\\<in>(\\<lambda>q. the (oldest_token q n)) ` set sp'.\n         Ball ((\\<lambda>q. the (oldest_token q n)) ` set ps'')\n          ((\\<le>) x))) \\<and>\n    (\\<forall>x\\<in>(\\<lambda>q. the (oldest_token q n)) ` set ps'.\n        Ball\n         ((\\<lambda>q. the (oldest_token q n)) ` set sp' \\<union>\n          (\\<lambda>q. the (oldest_token q n)) ` set ps'')\n         ((\\<le>) x))) \\<and>\n   (\\<forall>x\\<in>(\\<lambda>q. the (oldest_token q n)) ` set sq'.\n       Ball\n        ((\\<lambda>q. the (oldest_token q n)) ` set ps' \\<union>\n         ((\\<lambda>q. the (oldest_token q n)) ` set sp' \\<union>\n          (\\<lambda>q. the (oldest_token q n)) ` set ps''))\n        ((\\<le>) x))) \\<and>\n  (\\<forall>x\\<in>(\\<lambda>q. the (oldest_token q n)) ` set qs'.\n      Ball\n       ((\\<lambda>q. the (oldest_token q n)) ` set sq' \\<union>\n        ((\\<lambda>q. the (oldest_token q n)) ` set ps' \\<union>\n         ((\\<lambda>q. the (oldest_token q n)) ` set sp' \\<union>\n          (\\<lambda>q. the (oldest_token q n)) ` set ps'')))\n       ((\\<le>) x))\n\ngoal (1 subgoal):\n 1. the (oldest_token q' n) \\<le> the (oldest_token p' n)", "using \\<open>q' \\<in> set sq'\\<close> \\<open>p' \\<in> set sp'\\<close>"], ["proof (prove)\nusing this:\n  sorted (map (\\<lambda>q. the (oldest_token q n)) qs') \\<and>\n  (sorted (map (\\<lambda>q. the (oldest_token q n)) sq') \\<and>\n   (sorted (map (\\<lambda>q. the (oldest_token q n)) ps') \\<and>\n    (sorted (map (\\<lambda>q. the (oldest_token q n)) sp') \\<and>\n     sorted (map (\\<lambda>q. the (oldest_token q n)) ps'') \\<and>\n     (\\<forall>x\\<in>(\\<lambda>q. the (oldest_token q n)) ` set sp'.\n         Ball ((\\<lambda>q. the (oldest_token q n)) ` set ps'')\n          ((\\<le>) x))) \\<and>\n    (\\<forall>x\\<in>(\\<lambda>q. the (oldest_token q n)) ` set ps'.\n        Ball\n         ((\\<lambda>q. the (oldest_token q n)) ` set sp' \\<union>\n          (\\<lambda>q. the (oldest_token q n)) ` set ps'')\n         ((\\<le>) x))) \\<and>\n   (\\<forall>x\\<in>(\\<lambda>q. the (oldest_token q n)) ` set sq'.\n       Ball\n        ((\\<lambda>q. the (oldest_token q n)) ` set ps' \\<union>\n         ((\\<lambda>q. the (oldest_token q n)) ` set sp' \\<union>\n          (\\<lambda>q. the (oldest_token q n)) ` set ps''))\n        ((\\<le>) x))) \\<and>\n  (\\<forall>x\\<in>(\\<lambda>q. the (oldest_token q n)) ` set qs'.\n      Ball\n       ((\\<lambda>q. the (oldest_token q n)) ` set sq' \\<union>\n        ((\\<lambda>q. the (oldest_token q n)) ` set ps' \\<union>\n         ((\\<lambda>q. the (oldest_token q n)) ` set sp' \\<union>\n          (\\<lambda>q. the (oldest_token q n)) ` set ps'')))\n       ((\\<le>) x))\n  q' \\<in> set sq'\n  p' \\<in> set sp'\n\ngoal (1 subgoal):\n 1. the (oldest_token q' n) \\<le> the (oldest_token p' n)", "by auto"], ["proof (state)\nthis:\n  the (oldest_token q' n) \\<le> the (oldest_token p' n)\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "moreover"], ["proof (state)\nthis:\n  the (oldest_token q' n) \\<le> the (oldest_token p' n)\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "{"], ["proof (state)\nthis:\n  the (oldest_token q' n) \\<le> the (oldest_token p' n)\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "have \"oldest_token q' n \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oldest_token q' n \\<noteq> None", "using nxt_run_configuration option.distinct(1) r_def r_def'  \\<open>q' \\<in> set sq'\\<close> \\<open>p' \\<in> set sp'\\<close> set_append"], ["proof (prove)\nusing this:\n  (?q \\<in> set (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n                  ?n)) =\n  (\\<not> sink ?q \\<and> configuration ?q ?n \\<noteq> {})\n  None \\<noteq> Some ?x2.0\n  r \\<equiv> run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n  r n = qs' @ sq' @ ps' @ sp' @ ps''\n  q' \\<in> set sq'\n  p' \\<in> set sp'\n  set (?xs @ ?ys) = set ?xs \\<union> set ?ys\n\ngoal (1 subgoal):\n 1. oldest_token q' n \\<noteq> None", "unfolding init.simps oldest_token.simps"], ["proof (prove)\nusing this:\n  (?q \\<in> set (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) [q\\<^sub>0] w ?n)) =\n  (\\<not> sink ?q \\<and> configuration ?q ?n \\<noteq> {})\n  None \\<noteq> Some ?x2.0\n  r \\<equiv> run (nxt \\<Sigma> \\<delta> q\\<^sub>0) [q\\<^sub>0] w\n  r n = qs' @ sq' @ ps' @ sp' @ ps''\n  q' \\<in> set sq'\n  p' \\<in> set sp'\n  set (?xs @ ?ys) = set ?xs \\<union> set ?ys\n\ngoal (1 subgoal):\n 1. (if configuration q' n \\<noteq> {} then Some (Min (configuration q' n))\n     else None) \\<noteq>\n    None", "by (metis UnCI)"], ["proof (state)\nthis:\n  oldest_token q' n \\<noteq> None\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "moreover"], ["proof (state)\nthis:\n  oldest_token q' n \\<noteq> None\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "hence \"oldest_token q (Suc n) \\<noteq> None\""], ["proof (prove)\nusing this:\n  oldest_token q' n \\<noteq> None\n\ngoal (1 subgoal):\n 1. oldest_token q (Suc n) \\<noteq> None", "using \\<open>q = \\<delta> q' (w n)\\<close>"], ["proof (prove)\nusing this:\n  oldest_token q' n \\<noteq> None\n  q = \\<delta> q' (w n)\n\ngoal (1 subgoal):\n 1. oldest_token q (Suc n) \\<noteq> None", "by (metis oldest_token.simps option.distinct(1) configuration_step_non_empty)"], ["proof (state)\nthis:\n  oldest_token q (Suc n) \\<noteq> None\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "ultimately"], ["proof (chain)\npicking this:\n  oldest_token q' n \\<noteq> None\n  oldest_token q (Suc n) \\<noteq> None", "obtain x y where x_def: \"oldest_token q' n = Some x\"  \n              and y_def: \"oldest_token q (Suc n) = Some y\""], ["proof (prove)\nusing this:\n  oldest_token q' n \\<noteq> None\n  oldest_token q (Suc n) \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>oldest_token q' n = Some x;\n         oldest_token q (Suc n) = Some y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  oldest_token q' n = Some x\n  oldest_token q (Suc n) = Some y\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "moreover"], ["proof (state)\nthis:\n  oldest_token q' n = Some x\n  oldest_token q (Suc n) = Some y\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "hence \"x \\<le> n\" and \"token_run x n = q'\""], ["proof (prove)\nusing this:\n  oldest_token q' n = Some x\n  oldest_token q (Suc n) = Some y\n\ngoal (1 subgoal):\n 1. x \\<le> n &&& token_run x n = q'", "using oldest_token_bounded push_down_oldest_token_token_run assms"], ["proof (prove)\nusing this:\n  oldest_token q' n = Some x\n  oldest_token q (Suc n) = Some y\n  oldest_token ?q ?n = Some ?x \\<Longrightarrow> ?x \\<le> ?n\n  oldest_token ?q ?n = Some ?x \\<Longrightarrow> token_run ?x ?n = ?q\n  r \\<equiv> run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n\ngoal (1 subgoal):\n 1. x \\<le> n &&& token_run x n = q'", "by blast+"], ["proof (state)\nthis:\n  x \\<le> n\n  token_run x n = q'\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "moreover"], ["proof (state)\nthis:\n  x \\<le> n\n  token_run x n = q'\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "hence \"token_run x (Suc n) = q\""], ["proof (prove)\nusing this:\n  x \\<le> n\n  token_run x n = q'\n\ngoal (1 subgoal):\n 1. token_run x (Suc n) = q", "using \\<open>q = \\<delta> q' (w n)\\<close>"], ["proof (prove)\nusing this:\n  x \\<le> n\n  token_run x n = q'\n  q = \\<delta> q' (w n)\n\ngoal (1 subgoal):\n 1. token_run x (Suc n) = q", "by (rule token_run_step)"], ["proof (state)\nthis:\n  token_run x (Suc n) = q\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "ultimately"], ["proof (chain)\npicking this:\n  oldest_token q' n = Some x\n  oldest_token q (Suc n) = Some y\n  x \\<le> n\n  token_run x n = q'\n  token_run x (Suc n) = q", "have \"x \\<ge> y\""], ["proof (prove)\nusing this:\n  oldest_token q' n = Some x\n  oldest_token q (Suc n) = Some y\n  x \\<le> n\n  token_run x n = q'\n  token_run x (Suc n) = q\n\ngoal (1 subgoal):\n 1. y \\<le> x", "using oldest_token_monotonic_Suc assms"], ["proof (prove)\nusing this:\n  oldest_token q' n = Some x\n  oldest_token q (Suc n) = Some y\n  x \\<le> n\n  token_run x n = q'\n  token_run x (Suc n) = q\n  \\<lbrakk>?x \\<le> ?n; oldest_token (token_run ?x ?n) ?n = Some ?i;\n   oldest_token (token_run ?x (Suc ?n)) (Suc ?n) = Some ?j\\<rbrakk>\n  \\<Longrightarrow> ?j \\<le> ?i\n  r \\<equiv> run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n\ngoal (1 subgoal):\n 1. y \\<le> x", "by blast"], ["proof (state)\nthis:\n  y \\<le> x\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "moreover"], ["proof (state)\nthis:\n  y \\<le> x\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "{"], ["proof (state)\nthis:\n  y \\<le> x\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "have \"\\<And>q''. q = \\<delta> q'' (w n) \\<Longrightarrow> q'' \\<notin> set qs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q''. q = \\<delta> q'' (w n) \\<Longrightarrow> q'' \\<notin> set qs'", "using \\<open>q \\<notin> set zs\\<close>"], ["proof (prove)\nusing this:\n  q \\<notin> set zs\n\ngoal (1 subgoal):\n 1. \\<And>q''. q = \\<delta> q'' (w n) \\<Longrightarrow> q'' \\<notin> set qs'", "unfolding \\<open>filter (\\<lambda>q. \\<not>sink q) (map (\\<lambda>q. \\<delta> q (w n)) qs') = zs\\<close>[symmetric] set_map set_filter"], ["proof (prove)\nusing this:\n  q \\<notin> {x \\<in> (\\<lambda>q. \\<delta> q (w n)) ` set qs'.\n              \\<not> sink x}\n\ngoal (1 subgoal):\n 1. \\<And>q''. q = \\<delta> q'' (w n) \\<Longrightarrow> q'' \\<notin> set qs'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q''.\n       \\<lbrakk>q = \\<delta> q'' (w n);\n        \\<delta> q'' (w n)\n        \\<in> (\\<lambda>q. \\<delta> q (w n)) ` set qs' \\<longrightarrow>\n        sink (\\<delta> q'' (w n))\\<rbrakk>\n       \\<Longrightarrow> q'' \\<notin> set qs'", "using \\<open>\\<not> sink q\\<close>"], ["proof (prove)\nusing this:\n  \\<not> sink q\n\ngoal (1 subgoal):\n 1. \\<And>q''.\n       \\<lbrakk>q = \\<delta> q'' (w n);\n        \\<delta> q'' (w n)\n        \\<in> (\\<lambda>q. \\<delta> q (w n)) ` set qs' \\<longrightarrow>\n        sink (\\<delta> q'' (w n))\\<rbrakk>\n       \\<Longrightarrow> q'' \\<notin> set qs'", "by blast"], ["proof (state)\nthis:\n  q = \\<delta> ?q'' (w n) \\<Longrightarrow> ?q'' \\<notin> set qs'\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "moreover"], ["proof (state)\nthis:\n  q = \\<delta> ?q'' (w n) \\<Longrightarrow> ?q'' \\<notin> set qs'\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "{"], ["proof (state)\nthis:\n  q = \\<delta> ?q'' (w n) \\<Longrightarrow> ?q'' \\<notin> set qs'\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "obtain us vs where 1: \"map (\\<lambda>q. \\<delta> q (w n)) sq' = us @ [q] @ vs\" and \"\\<forall>u\\<in>set us. sink u\" and \"[] = [q\\<leftarrow>vs . \\<not> sink q]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>us vs.\n        \\<lbrakk>map (\\<lambda>q. \\<delta> q (w n)) sq' = us @ [q] @ vs;\n         Ball (set us) sink;\n         [] = filter (\\<lambda>q. \\<not> sink q) vs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>filter (\\<lambda>q. \\<not>sink q) (map (\\<lambda>q. \\<delta> q (w n)) sq') = [q]\\<close>"], ["proof (prove)\nusing this:\n  filter (\\<lambda>q. \\<not> sink q)\n   (map (\\<lambda>q. \\<delta> q (w n)) sq') =\n  [q]\n\ngoal (1 subgoal):\n 1. (\\<And>us vs.\n        \\<lbrakk>map (\\<lambda>q. \\<delta> q (w n)) sq' = us @ [q] @ vs;\n         Ball (set us) sink;\n         [] = filter (\\<lambda>q. \\<not> sink q) vs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding filter_eq_Cons_iff"], ["proof (prove)\nusing this:\n  \\<exists>us vs.\n     map (\\<lambda>q. \\<delta> q (w n)) sq' = us @ q # vs \\<and>\n     (\\<forall>u\\<in>set us. \\<not> \\<not> sink u) \\<and>\n     \\<not> sink q \\<and> [] = filter (\\<lambda>q. \\<not> sink q) vs\n\ngoal (1 subgoal):\n 1. (\\<And>us vs.\n        \\<lbrakk>map (\\<lambda>q. \\<delta> q (w n)) sq' = us @ [q] @ vs;\n         Ball (set us) sink;\n         [] = filter (\\<lambda>q. \\<not> sink q) vs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  map (\\<lambda>q. \\<delta> q (w n)) sq' = us @ [q] @ vs\n  Ball (set us) sink\n  [] = filter (\\<lambda>q. \\<not> sink q) vs\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "moreover"], ["proof (state)\nthis:\n  map (\\<lambda>q. \\<delta> q (w n)) sq' = us @ [q] @ vs\n  Ball (set us) sink\n  [] = filter (\\<lambda>q. \\<not> sink q) vs\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "hence \"\\<And>q''. q'' \\<in> (set us) \\<union> (set vs) \\<Longrightarrow> sink q''\""], ["proof (prove)\nusing this:\n  map (\\<lambda>q. \\<delta> q (w n)) sq' = us @ [q] @ vs\n  Ball (set us) sink\n  [] = filter (\\<lambda>q. \\<not> sink q) vs\n\ngoal (1 subgoal):\n 1. \\<And>q''. q'' \\<in> set us \\<union> set vs \\<Longrightarrow> sink q''", "by (metis UnE filter_empty_conv)"], ["proof (state)\nthis:\n  ?q'' \\<in> set us \\<union> set vs \\<Longrightarrow> sink ?q''\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "hence \"q \\<notin> (set us) \\<union> (set vs)\""], ["proof (prove)\nusing this:\n  ?q'' \\<in> set us \\<union> set vs \\<Longrightarrow> sink ?q''\n\ngoal (1 subgoal):\n 1. q \\<notin> set us \\<union> set vs", "using \\<open>\\<not> sink q\\<close>"], ["proof (prove)\nusing this:\n  ?q'' \\<in> set us \\<union> set vs \\<Longrightarrow> sink ?q''\n  \\<not> sink q\n\ngoal (1 subgoal):\n 1. q \\<notin> set us \\<union> set vs", "by blast"], ["proof (state)\nthis:\n  q \\<notin> set us \\<union> set vs\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "ultimately"], ["proof (chain)\npicking this:\n  map (\\<lambda>q. \\<delta> q (w n)) sq' = us @ [q] @ vs\n  Ball (set us) sink\n  [] = filter (\\<lambda>q. \\<not> sink q) vs\n  q \\<notin> set us \\<union> set vs", "have \"\\<And>q''. q'' \\<in> (set sq' - {q'}) \\<Longrightarrow> \\<delta> q'' (w n) \\<noteq> q\""], ["proof (prove)\nusing this:\n  map (\\<lambda>q. \\<delta> q (w n)) sq' = us @ [q] @ vs\n  Ball (set us) sink\n  [] = filter (\\<lambda>q. \\<not> sink q) vs\n  q \\<notin> set us \\<union> set vs\n\ngoal (1 subgoal):\n 1. \\<And>q''.\n       q'' \\<in> set sq' - {q'} \\<Longrightarrow>\n       \\<delta> q'' (w n) \\<noteq> q", "using 1 \\<open>q = \\<delta> q' (w n)\\<close> \\<open>q' \\<in> set sq'\\<close>"], ["proof (prove)\nusing this:\n  map (\\<lambda>q. \\<delta> q (w n)) sq' = us @ [q] @ vs\n  Ball (set us) sink\n  [] = filter (\\<lambda>q. \\<not> sink q) vs\n  q \\<notin> set us \\<union> set vs\n  map (\\<lambda>q. \\<delta> q (w n)) sq' = us @ [q] @ vs\n  q = \\<delta> q' (w n)\n  q' \\<in> set sq'\n\ngoal (1 subgoal):\n 1. \\<And>q''.\n       q'' \\<in> set sq' - {q'} \\<Longrightarrow>\n       \\<delta> q'' (w n) \\<noteq> q", "by (fastforce dest: split_list elim: map_splitE)"], ["proof (state)\nthis:\n  ?q'' \\<in> set sq' - {q'} \\<Longrightarrow> \\<delta> ?q'' (w n) \\<noteq> q\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "}"], ["proof (state)\nthis:\n  ?q''5 \\<in> set sq' - {q'} \\<Longrightarrow>\n  \\<delta> ?q''5 (w n) \\<noteq> q\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "ultimately"], ["proof (chain)\npicking this:\n  q = \\<delta> ?q'' (w n) \\<Longrightarrow> ?q'' \\<notin> set qs'\n  ?q''5 \\<in> set sq' - {q'} \\<Longrightarrow>\n  \\<delta> ?q''5 (w n) \\<noteq> q", "have \"\\<And>q''. q = \\<delta> q'' (w n) \\<Longrightarrow> configuration q'' n \\<noteq> {} \\<Longrightarrow> q'' \\<in> set (ps' @ sp' @ ps'') \\<or> q'' = q'\""], ["proof (prove)\nusing this:\n  q = \\<delta> ?q'' (w n) \\<Longrightarrow> ?q'' \\<notin> set qs'\n  ?q''5 \\<in> set sq' - {q'} \\<Longrightarrow>\n  \\<delta> ?q''5 (w n) \\<noteq> q\n\ngoal (1 subgoal):\n 1. \\<And>q''.\n       \\<lbrakk>q = \\<delta> q'' (w n);\n        configuration q'' n \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> q'' \\<in> set (ps' @ sp' @ ps'') \\<or> q'' = q'", "using nxt_run_configuration[of _ n] \\<open>\\<not> sink q\\<close> sink_rev_step"], ["proof (prove)\nusing this:\n  q = \\<delta> ?q'' (w n) \\<Longrightarrow> ?q'' \\<notin> set qs'\n  ?q''5 \\<in> set sq' - {q'} \\<Longrightarrow>\n  \\<delta> ?q''5 (w n) \\<noteq> q\n  (?q \\<in> set (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n                  n)) =\n  (\\<not> sink ?q \\<and> configuration ?q n \\<noteq> {})\n  \\<not> sink q\n  \\<lbrakk>\\<not> sink ?q; ?q = \\<delta> ?q' ?\\<nu>;\n   ?\\<nu> \\<in> \\<Sigma>\\<rbrakk>\n  \\<Longrightarrow> \\<not> sink ?q'\n  \\<lbrakk>\\<not> sink ?q; ?q = \\<delta> ?q' (w ?i)\\<rbrakk>\n  \\<Longrightarrow> \\<not> sink ?q'\n\ngoal (1 subgoal):\n 1. \\<And>q''.\n       \\<lbrakk>q = \\<delta> q'' (w n);\n        configuration q'' n \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> q'' \\<in> set (ps' @ sp' @ ps'') \\<or> q'' = q'", "unfolding r_def'[unfolded r_def] set_append"], ["proof (prove)\nusing this:\n  q = \\<delta> ?q'' (w n) \\<Longrightarrow> ?q'' \\<notin> set qs'\n  ?q''5 \\<in> set sq' - {q'} \\<Longrightarrow>\n  \\<delta> ?q''5 (w n) \\<noteq> q\n  (?q \\<in> set qs' \\<union>\n            (set sq' \\<union>\n             (set ps' \\<union> (set sp' \\<union> set ps'')))) =\n  (\\<not> sink ?q \\<and> configuration ?q n \\<noteq> {})\n  \\<not> sink q\n  \\<lbrakk>\\<not> sink ?q; ?q = \\<delta> ?q' ?\\<nu>;\n   ?\\<nu> \\<in> \\<Sigma>\\<rbrakk>\n  \\<Longrightarrow> \\<not> sink ?q'\n  \\<lbrakk>\\<not> sink ?q; ?q = \\<delta> ?q' (w ?i)\\<rbrakk>\n  \\<Longrightarrow> \\<not> sink ?q'\n\ngoal (1 subgoal):\n 1. \\<And>q''.\n       \\<lbrakk>q = \\<delta> q'' (w n);\n        configuration q'' n \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> q''\n                         \\<in> set ps' \\<union>\n                               (set sp' \\<union> set ps'') \\<or>\n                         q'' = q'", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>q = \\<delta> ?q'' (w n);\n   configuration ?q'' n \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> ?q'' \\<in> set (ps' @ sp' @ ps'') \\<or> ?q'' = q'\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>q = \\<delta> ?q'' (w n);\n   configuration ?q'' n \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> ?q'' \\<in> set (ps' @ sp' @ ps'') \\<or> ?q'' = q'\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "have \"\\<And>q''. q'' \\<in> set (ps' @ sp' @ ps'') \\<Longrightarrow> x \\<le> ?f_n q''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q''.\n       q'' \\<in> set (ps' @ sp' @ ps'') \\<Longrightarrow>\n       x \\<le> the (oldest_token q'' n)", "using x_def"], ["proof (prove)\nusing this:\n  oldest_token q' n = Some x\n\ngoal (1 subgoal):\n 1. \\<And>q''.\n       q'' \\<in> set (ps' @ sp' @ ps'') \\<Longrightarrow>\n       x \\<le> the (oldest_token q'' n)", "using Suc"], ["proof (prove)\nusing this:\n  oldest_token q' n = Some x\n  sorted (map (\\<lambda>q. the (oldest_token q n)) (r n))\n\ngoal (1 subgoal):\n 1. \\<And>q''.\n       q'' \\<in> set (ps' @ sp' @ ps'') \\<Longrightarrow>\n       x \\<le> the (oldest_token q'' n)", "unfolding r_def' map_append sorted_append set_append set_map"], ["proof (prove)\nusing this:\n  oldest_token q' n = Some x\n  sorted (map (\\<lambda>q. the (oldest_token q n)) qs') \\<and>\n  (sorted (map (\\<lambda>q. the (oldest_token q n)) sq') \\<and>\n   (sorted (map (\\<lambda>q. the (oldest_token q n)) ps') \\<and>\n    (sorted (map (\\<lambda>q. the (oldest_token q n)) sp') \\<and>\n     sorted (map (\\<lambda>q. the (oldest_token q n)) ps'') \\<and>\n     (\\<forall>x\\<in>(\\<lambda>q. the (oldest_token q n)) ` set sp'.\n         Ball ((\\<lambda>q. the (oldest_token q n)) ` set ps'')\n          ((\\<le>) x))) \\<and>\n    (\\<forall>x\\<in>(\\<lambda>q. the (oldest_token q n)) ` set ps'.\n        Ball\n         ((\\<lambda>q. the (oldest_token q n)) ` set sp' \\<union>\n          (\\<lambda>q. the (oldest_token q n)) ` set ps'')\n         ((\\<le>) x))) \\<and>\n   (\\<forall>x\\<in>(\\<lambda>q. the (oldest_token q n)) ` set sq'.\n       Ball\n        ((\\<lambda>q. the (oldest_token q n)) ` set ps' \\<union>\n         ((\\<lambda>q. the (oldest_token q n)) ` set sp' \\<union>\n          (\\<lambda>q. the (oldest_token q n)) ` set ps''))\n        ((\\<le>) x))) \\<and>\n  (\\<forall>x\\<in>(\\<lambda>q. the (oldest_token q n)) ` set qs'.\n      Ball\n       ((\\<lambda>q. the (oldest_token q n)) ` set sq' \\<union>\n        ((\\<lambda>q. the (oldest_token q n)) ` set ps' \\<union>\n         ((\\<lambda>q. the (oldest_token q n)) ` set sp' \\<union>\n          (\\<lambda>q. the (oldest_token q n)) ` set ps'')))\n       ((\\<le>) x))\n\ngoal (1 subgoal):\n 1. \\<And>q''.\n       q''\n       \\<in> set ps' \\<union> (set sp' \\<union> set ps'') \\<Longrightarrow>\n       x \\<le> the (oldest_token q'' n)", "using \\<open>q' \\<in> set sq'\\<close> \\<open>p' \\<in> set sp'\\<close>"], ["proof (prove)\nusing this:\n  oldest_token q' n = Some x\n  sorted (map (\\<lambda>q. the (oldest_token q n)) qs') \\<and>\n  (sorted (map (\\<lambda>q. the (oldest_token q n)) sq') \\<and>\n   (sorted (map (\\<lambda>q. the (oldest_token q n)) ps') \\<and>\n    (sorted (map (\\<lambda>q. the (oldest_token q n)) sp') \\<and>\n     sorted (map (\\<lambda>q. the (oldest_token q n)) ps'') \\<and>\n     (\\<forall>x\\<in>(\\<lambda>q. the (oldest_token q n)) ` set sp'.\n         Ball ((\\<lambda>q. the (oldest_token q n)) ` set ps'')\n          ((\\<le>) x))) \\<and>\n    (\\<forall>x\\<in>(\\<lambda>q. the (oldest_token q n)) ` set ps'.\n        Ball\n         ((\\<lambda>q. the (oldest_token q n)) ` set sp' \\<union>\n          (\\<lambda>q. the (oldest_token q n)) ` set ps'')\n         ((\\<le>) x))) \\<and>\n   (\\<forall>x\\<in>(\\<lambda>q. the (oldest_token q n)) ` set sq'.\n       Ball\n        ((\\<lambda>q. the (oldest_token q n)) ` set ps' \\<union>\n         ((\\<lambda>q. the (oldest_token q n)) ` set sp' \\<union>\n          (\\<lambda>q. the (oldest_token q n)) ` set ps''))\n        ((\\<le>) x))) \\<and>\n  (\\<forall>x\\<in>(\\<lambda>q. the (oldest_token q n)) ` set qs'.\n      Ball\n       ((\\<lambda>q. the (oldest_token q n)) ` set sq' \\<union>\n        ((\\<lambda>q. the (oldest_token q n)) ` set ps' \\<union>\n         ((\\<lambda>q. the (oldest_token q n)) ` set sp' \\<union>\n          (\\<lambda>q. the (oldest_token q n)) ` set ps'')))\n       ((\\<le>) x))\n  q' \\<in> set sq'\n  p' \\<in> set sp'\n\ngoal (1 subgoal):\n 1. \\<And>q''.\n       q''\n       \\<in> set ps' \\<union> (set sp' \\<union> set ps'') \\<Longrightarrow>\n       x \\<le> the (oldest_token q'' n)", "apply (simp del: oldest_token.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q''.\n       \\<lbrakk>q'' \\<in> set ps' \\<or>\n                q'' \\<in> set sp' \\<or> q'' \\<in> set ps'';\n        oldest_token q' n = Some x;\n        sorted (map (\\<lambda>q. the (oldest_token q n)) qs') \\<and>\n        sorted (map (\\<lambda>q. the (oldest_token q n)) sq') \\<and>\n        sorted (map (\\<lambda>q. the (oldest_token q n)) ps') \\<and>\n        sorted (map (\\<lambda>q. the (oldest_token q n)) sp') \\<and>\n        sorted (map (\\<lambda>q. the (oldest_token q n)) ps'') \\<and>\n        (\\<forall>x\\<in>set sp'.\n            \\<forall>xa\\<in>set ps''.\n               the (oldest_token x n) \\<le> the (oldest_token xa n)) \\<and>\n        (\\<forall>x\\<in>set ps'.\n            Ball\n             ((\\<lambda>q. the (oldest_token q n)) ` set sp' \\<union>\n              (\\<lambda>q. the (oldest_token q n)) ` set ps'')\n             ((\\<le>) (the (oldest_token x n)))) \\<and>\n        (\\<forall>x\\<in>set sq'.\n            Ball\n             ((\\<lambda>q. the (oldest_token q n)) ` set ps' \\<union>\n              ((\\<lambda>q. the (oldest_token q n)) ` set sp' \\<union>\n               (\\<lambda>q. the (oldest_token q n)) ` set ps''))\n             ((\\<le>) (the (oldest_token x n)))) \\<and>\n        (\\<forall>x\\<in>set qs'.\n            Ball\n             ((\\<lambda>q. the (oldest_token q n)) ` set sq' \\<union>\n              ((\\<lambda>q. the (oldest_token q n)) ` set ps' \\<union>\n               ((\\<lambda>q. the (oldest_token q n)) ` set sp' \\<union>\n                (\\<lambda>q. the (oldest_token q n)) ` set ps'')))\n             ((\\<le>) (the (oldest_token x n))));\n        q' \\<in> set sq'; p' \\<in> set sp'\\<rbrakk>\n       \\<Longrightarrow> x \\<le> the (oldest_token q'' n)", "by fastforce"], ["proof (state)\nthis:\n  ?q'' \\<in> set (ps' @ sp' @ ps'') \\<Longrightarrow>\n  x \\<le> the (oldest_token ?q'' n)\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "moreover"], ["proof (state)\nthis:\n  ?q'' \\<in> set (ps' @ sp' @ ps'') \\<Longrightarrow>\n  x \\<le> the (oldest_token ?q'' n)\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "have \"\\<And>q''. q'' = q' \\<Longrightarrow> x \\<le> ?f_n q''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q''. q'' = q' \\<Longrightarrow> x \\<le> the (oldest_token q'' n)", "using x_def"], ["proof (prove)\nusing this:\n  oldest_token q' n = Some x\n\ngoal (1 subgoal):\n 1. \\<And>q''. q'' = q' \\<Longrightarrow> x \\<le> the (oldest_token q'' n)", "by simp"], ["proof (state)\nthis:\n  ?q'' = q' \\<Longrightarrow> x \\<le> the (oldest_token ?q'' n)\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "moreover"], ["proof (state)\nthis:\n  ?q'' = q' \\<Longrightarrow> x \\<le> the (oldest_token ?q'' n)\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "have \"\\<And>q'' x. x \\<in> configuration q'' n \\<Longrightarrow> the (oldest_token q'' n) \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q'' x.\n       x \\<in> configuration q'' n \\<Longrightarrow>\n       the (oldest_token q'' n) \\<le> x", "using assms"], ["proof (prove)\nusing this:\n  r \\<equiv> run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n\ngoal (1 subgoal):\n 1. \\<And>q'' x.\n       x \\<in> configuration q'' n \\<Longrightarrow>\n       the (oldest_token q'' n) \\<le> x", "by auto"], ["proof (state)\nthis:\n  ?x \\<in> configuration ?q'' n \\<Longrightarrow>\n  the (oldest_token ?q'' n) \\<le> ?x\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>q = \\<delta> ?q'' (w n);\n   configuration ?q'' n \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> ?q'' \\<in> set (ps' @ sp' @ ps'') \\<or> ?q'' = q'\n  ?q'' \\<in> set (ps' @ sp' @ ps'') \\<Longrightarrow>\n  x \\<le> the (oldest_token ?q'' n)\n  ?q'' = q' \\<Longrightarrow> x \\<le> the (oldest_token ?q'' n)\n  ?x \\<in> configuration ?q'' n \\<Longrightarrow>\n  the (oldest_token ?q'' n) \\<le> ?x", "have \"\\<And>z. z \\<in> \\<Union>{configuration q' n |q'. q = \\<delta> q' (w n)} \\<Longrightarrow> x \\<le> z\""], ["proof (prove)\nusing this:\n  \\<lbrakk>q = \\<delta> ?q'' (w n);\n   configuration ?q'' n \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> ?q'' \\<in> set (ps' @ sp' @ ps'') \\<or> ?q'' = q'\n  ?q'' \\<in> set (ps' @ sp' @ ps'') \\<Longrightarrow>\n  x \\<le> the (oldest_token ?q'' n)\n  ?q'' = q' \\<Longrightarrow> x \\<le> the (oldest_token ?q'' n)\n  ?x \\<in> configuration ?q'' n \\<Longrightarrow>\n  the (oldest_token ?q'' n) \\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<in> \\<Union>\n                {configuration q' n |q'.\n                 q = \\<delta> q' (w n)} \\<Longrightarrow>\n       x \\<le> z", "by fastforce"], ["proof (state)\nthis:\n  ?z \\<in> \\<Union>\n            {configuration q' n |q'.\n             q = \\<delta> q' (w n)} \\<Longrightarrow>\n  x \\<le> ?z\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "}"], ["proof (state)\nthis:\n  ?z \\<in> \\<Union>\n            {configuration q' n |q'.\n             q = \\<delta> q' (w n)} \\<Longrightarrow>\n  x \\<le> ?z\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "hence \"\\<And>z. z \\<in> configuration q (Suc n) \\<Longrightarrow> x \\<le> z\""], ["proof (prove)\nusing this:\n  ?z \\<in> \\<Union>\n            {configuration q' n |q'.\n             q = \\<delta> q' (w n)} \\<Longrightarrow>\n  x \\<le> ?z\n\ngoal (1 subgoal):\n 1. \\<And>z. z \\<in> configuration q (Suc n) \\<Longrightarrow> x \\<le> z", "unfolding configuration_step_eq_unified"], ["proof (prove)\nusing this:\n  ?z \\<in> \\<Union>\n            {configuration q' n |q'.\n             q = \\<delta> q' (w n)} \\<Longrightarrow>\n  x \\<le> ?z\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<in> \\<Union>\n                {configuration q' n |q'. q = \\<delta> q' (w n)} \\<union>\n               (if q = q\\<^sub>0 then {Suc n} else {}) \\<Longrightarrow>\n       x \\<le> z", "using \\<open>x \\<le> n\\<close>"], ["proof (prove)\nusing this:\n  ?z \\<in> \\<Union>\n            {configuration q' n |q'.\n             q = \\<delta> q' (w n)} \\<Longrightarrow>\n  x \\<le> ?z\n  x \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<in> \\<Union>\n                {configuration q' n |q'. q = \\<delta> q' (w n)} \\<union>\n               (if q = q\\<^sub>0 then {Suc n} else {}) \\<Longrightarrow>\n       x \\<le> z", "by (cases \"q = q\\<^sub>0\"; auto)"], ["proof (state)\nthis:\n  ?z \\<in> configuration q (Suc n) \\<Longrightarrow> x \\<le> ?z\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "hence \"x \\<le> y\""], ["proof (prove)\nusing this:\n  ?z \\<in> configuration q (Suc n) \\<Longrightarrow> x \\<le> ?z\n\ngoal (1 subgoal):\n 1. x \\<le> y", "using y_def Min.boundedI configuration_finite"], ["proof (prove)\nusing this:\n  ?z \\<in> configuration q (Suc n) \\<Longrightarrow> x \\<le> ?z\n  oldest_token q (Suc n) = Some y\n  \\<lbrakk>finite ?A; ?A \\<noteq> {};\n   \\<And>a. a \\<in> ?A \\<Longrightarrow> ?x \\<le> a\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> Min ?A\n  finite (configuration ?q ?n)\n\ngoal (1 subgoal):\n 1. x \\<le> y", "using push_down_oldest_token_configuration"], ["proof (prove)\nusing this:\n  ?z \\<in> configuration q (Suc n) \\<Longrightarrow> x \\<le> ?z\n  oldest_token q (Suc n) = Some y\n  \\<lbrakk>finite ?A; ?A \\<noteq> {};\n   \\<And>a. a \\<in> ?A \\<Longrightarrow> ?x \\<le> a\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> Min ?A\n  finite (configuration ?q ?n)\n  oldest_token ?q ?n = Some ?x \\<Longrightarrow>\n  ?x \\<in> configuration ?q ?n\n\ngoal (1 subgoal):\n 1. x \\<le> y", "by presburger"], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "ultimately"], ["proof (chain)\npicking this:\n  y \\<le> x\n  x \\<le> y", "have \"?f_n q' = ?f_Suc_n q\""], ["proof (prove)\nusing this:\n  y \\<le> x\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. the (oldest_token q' n) = the (oldest_token q (Suc n))", "using x_def y_def"], ["proof (prove)\nusing this:\n  y \\<le> x\n  x \\<le> y\n  oldest_token q' n = Some x\n  oldest_token q (Suc n) = Some y\n\ngoal (1 subgoal):\n 1. the (oldest_token q' n) = the (oldest_token q (Suc n))", "by fastforce"], ["proof (state)\nthis:\n  the (oldest_token q' n) = the (oldest_token q (Suc n))\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "}"], ["proof (state)\nthis:\n  the (oldest_token q' n) = the (oldest_token q (Suc n))\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "moreover"], ["proof (state)\nthis:\n  the (oldest_token q' n) = the (oldest_token q (Suc n))\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "{"], ["proof (state)\nthis:\n  the (oldest_token q' n) = the (oldest_token q (Suc n))\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "have \"oldest_token p' n \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oldest_token p' n \\<noteq> None", "using nxt_run_configuration oldest_token.simps option.distinct(1) r_def r_def'  \\<open>q' \\<in> set sq'\\<close> \\<open>p' \\<in> set sp'\\<close> set_append"], ["proof (prove)\nusing this:\n  (?q \\<in> set (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n                  ?n)) =\n  (\\<not> sink ?q \\<and> configuration ?q ?n \\<noteq> {})\n  oldest_token ?q ?n =\n  (if configuration ?q ?n \\<noteq> {} then Some (Min (configuration ?q ?n))\n   else None)\n  None \\<noteq> Some ?x2.0\n  r \\<equiv> run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n  r n = qs' @ sq' @ ps' @ sp' @ ps''\n  q' \\<in> set sq'\n  p' \\<in> set sp'\n  set (?xs @ ?ys) = set ?xs \\<union> set ?ys\n\ngoal (1 subgoal):\n 1. oldest_token p' n \\<noteq> None", "unfolding init.simps"], ["proof (prove)\nusing this:\n  (?q \\<in> set (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) [q\\<^sub>0] w ?n)) =\n  (\\<not> sink ?q \\<and> configuration ?q ?n \\<noteq> {})\n  oldest_token ?q ?n =\n  (if configuration ?q ?n \\<noteq> {} then Some (Min (configuration ?q ?n))\n   else None)\n  None \\<noteq> Some ?x2.0\n  r \\<equiv> run (nxt \\<Sigma> \\<delta> q\\<^sub>0) [q\\<^sub>0] w\n  r n = qs' @ sq' @ ps' @ sp' @ ps''\n  q' \\<in> set sq'\n  p' \\<in> set sp'\n  set (?xs @ ?ys) = set ?xs \\<union> set ?ys\n\ngoal (1 subgoal):\n 1. oldest_token p' n \\<noteq> None", "by (metis UnCI)"], ["proof (state)\nthis:\n  oldest_token p' n \\<noteq> None\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "moreover"], ["proof (state)\nthis:\n  oldest_token p' n \\<noteq> None\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "hence \"oldest_token p (Suc n) \\<noteq> None\""], ["proof (prove)\nusing this:\n  oldest_token p' n \\<noteq> None\n\ngoal (1 subgoal):\n 1. oldest_token p (Suc n) \\<noteq> None", "using \\<open>p = \\<delta> p' (w n)\\<close>"], ["proof (prove)\nusing this:\n  oldest_token p' n \\<noteq> None\n  p = \\<delta> p' (w n)\n\ngoal (1 subgoal):\n 1. oldest_token p (Suc n) \\<noteq> None", "by (metis oldest_token.simps option.distinct(1) configuration_step_non_empty)"], ["proof (state)\nthis:\n  oldest_token p (Suc n) \\<noteq> None\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "ultimately"], ["proof (chain)\npicking this:\n  oldest_token p' n \\<noteq> None\n  oldest_token p (Suc n) \\<noteq> None", "obtain x y where x_def: \"oldest_token p' n = Some x\"  \n              and y_def: \"oldest_token p (Suc n) = Some y\""], ["proof (prove)\nusing this:\n  oldest_token p' n \\<noteq> None\n  oldest_token p (Suc n) \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>oldest_token p' n = Some x;\n         oldest_token p (Suc n) = Some y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  oldest_token p' n = Some x\n  oldest_token p (Suc n) = Some y\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "moreover"], ["proof (state)\nthis:\n  oldest_token p' n = Some x\n  oldest_token p (Suc n) = Some y\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "hence \"x \\<le> n\" and \"token_run x n = p'\""], ["proof (prove)\nusing this:\n  oldest_token p' n = Some x\n  oldest_token p (Suc n) = Some y\n\ngoal (1 subgoal):\n 1. x \\<le> n &&& token_run x n = p'", "using oldest_token_bounded push_down_oldest_token_token_run assms"], ["proof (prove)\nusing this:\n  oldest_token p' n = Some x\n  oldest_token p (Suc n) = Some y\n  oldest_token ?q ?n = Some ?x \\<Longrightarrow> ?x \\<le> ?n\n  oldest_token ?q ?n = Some ?x \\<Longrightarrow> token_run ?x ?n = ?q\n  r \\<equiv> run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n\ngoal (1 subgoal):\n 1. x \\<le> n &&& token_run x n = p'", "by blast+"], ["proof (state)\nthis:\n  x \\<le> n\n  token_run x n = p'\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "moreover"], ["proof (state)\nthis:\n  x \\<le> n\n  token_run x n = p'\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "hence \"token_run x (Suc n) = p\""], ["proof (prove)\nusing this:\n  x \\<le> n\n  token_run x n = p'\n\ngoal (1 subgoal):\n 1. token_run x (Suc n) = p", "using \\<open>p = \\<delta> p' (w n)\\<close> assms token_run_step"], ["proof (prove)\nusing this:\n  x \\<le> n\n  token_run x n = p'\n  p = \\<delta> p' (w n)\n  r \\<equiv> run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n  \\<lbrakk>?x \\<le> ?n; token_run ?x ?n = ?q';\n   ?q = \\<delta> ?q' (w ?n)\\<rbrakk>\n  \\<Longrightarrow> token_run ?x (Suc ?n) = ?q\n\ngoal (1 subgoal):\n 1. token_run x (Suc n) = p", "by simp"], ["proof (state)\nthis:\n  token_run x (Suc n) = p\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "ultimately"], ["proof (chain)\npicking this:\n  oldest_token p' n = Some x\n  oldest_token p (Suc n) = Some y\n  x \\<le> n\n  token_run x n = p'\n  token_run x (Suc n) = p", "have \"x \\<ge> y\""], ["proof (prove)\nusing this:\n  oldest_token p' n = Some x\n  oldest_token p (Suc n) = Some y\n  x \\<le> n\n  token_run x n = p'\n  token_run x (Suc n) = p\n\ngoal (1 subgoal):\n 1. y \\<le> x", "using oldest_token_monotonic_Suc assms"], ["proof (prove)\nusing this:\n  oldest_token p' n = Some x\n  oldest_token p (Suc n) = Some y\n  x \\<le> n\n  token_run x n = p'\n  token_run x (Suc n) = p\n  \\<lbrakk>?x \\<le> ?n; oldest_token (token_run ?x ?n) ?n = Some ?i;\n   oldest_token (token_run ?x (Suc ?n)) (Suc ?n) = Some ?j\\<rbrakk>\n  \\<Longrightarrow> ?j \\<le> ?i\n  r \\<equiv> run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n\ngoal (1 subgoal):\n 1. y \\<le> x", "by blast"], ["proof (state)\nthis:\n  y \\<le> x\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "moreover"], ["proof (state)\nthis:\n  y \\<le> x\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "{"], ["proof (state)\nthis:\n  y \\<le> x\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "have \"\\<And>q''. p = \\<delta> q'' (w n) \\<Longrightarrow> q'' \\<notin> set qs' \\<union> set sq' \\<union> set ps'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q''.\n       p = \\<delta> q'' (w n) \\<Longrightarrow>\n       q'' \\<notin> set qs' \\<union> set sq' \\<union> set ps'", "using \\<open>p \\<notin> set zs \\<union> set zs' \\<union> set [q]\\<close> \\<open>\\<not> sink p\\<close>"], ["proof (prove)\nusing this:\n  p \\<notin> set zs \\<union> set zs' \\<union> set [q]\n  \\<not> sink p\n\ngoal (1 subgoal):\n 1. \\<And>q''.\n       p = \\<delta> q'' (w n) \\<Longrightarrow>\n       q'' \\<notin> set qs' \\<union> set sq' \\<union> set ps'", "unfolding 1[symmetric] 2[symmetric] 3[symmetric] set_map set_filter"], ["proof (prove)\nusing this:\n  p \\<notin> {x \\<in> (\\<lambda>q. \\<delta> q (w n)) ` set qs'.\n              \\<not> sink x} \\<union>\n             {x \\<in> (\\<lambda>q. \\<delta> q (w n)) ` set ps'.\n              \\<not> sink x} \\<union>\n             {x \\<in> (\\<lambda>q. \\<delta> q (w n)) ` set sq'.\n              \\<not> sink x}\n  \\<not> sink p\n\ngoal (1 subgoal):\n 1. \\<And>q''.\n       p = \\<delta> q'' (w n) \\<Longrightarrow>\n       q'' \\<notin> set qs' \\<union> set sq' \\<union> set ps'", "by blast"], ["proof (state)\nthis:\n  p = \\<delta> ?q'' (w n) \\<Longrightarrow>\n  ?q'' \\<notin> set qs' \\<union> set sq' \\<union> set ps'\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "moreover"], ["proof (state)\nthis:\n  p = \\<delta> ?q'' (w n) \\<Longrightarrow>\n  ?q'' \\<notin> set qs' \\<union> set sq' \\<union> set ps'\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "{"], ["proof (state)\nthis:\n  p = \\<delta> ?q'' (w n) \\<Longrightarrow>\n  ?q'' \\<notin> set qs' \\<union> set sq' \\<union> set ps'\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "obtain us vs where 1: \"map (\\<lambda>q. \\<delta> q (w n)) sp' = us @ [p] @ vs\" and \"\\<forall>u\\<in>set us. sink u\" and \"[] = [q\\<leftarrow>vs . \\<not> sink q]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>us vs.\n        \\<lbrakk>map (\\<lambda>q. \\<delta> q (w n)) sp' = us @ [p] @ vs;\n         Ball (set us) sink;\n         [] = filter (\\<lambda>q. \\<not> sink q) vs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>filter (\\<lambda>q. \\<not>sink q) (map (\\<lambda>q. \\<delta> q (w n)) sp') = [p]\\<close>"], ["proof (prove)\nusing this:\n  filter (\\<lambda>q. \\<not> sink q)\n   (map (\\<lambda>q. \\<delta> q (w n)) sp') =\n  [p]\n\ngoal (1 subgoal):\n 1. (\\<And>us vs.\n        \\<lbrakk>map (\\<lambda>q. \\<delta> q (w n)) sp' = us @ [p] @ vs;\n         Ball (set us) sink;\n         [] = filter (\\<lambda>q. \\<not> sink q) vs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding filter_eq_Cons_iff"], ["proof (prove)\nusing this:\n  \\<exists>us vs.\n     map (\\<lambda>q. \\<delta> q (w n)) sp' = us @ p # vs \\<and>\n     (\\<forall>u\\<in>set us. \\<not> \\<not> sink u) \\<and>\n     \\<not> sink p \\<and> [] = filter (\\<lambda>q. \\<not> sink q) vs\n\ngoal (1 subgoal):\n 1. (\\<And>us vs.\n        \\<lbrakk>map (\\<lambda>q. \\<delta> q (w n)) sp' = us @ [p] @ vs;\n         Ball (set us) sink;\n         [] = filter (\\<lambda>q. \\<not> sink q) vs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  map (\\<lambda>q. \\<delta> q (w n)) sp' = us @ [p] @ vs\n  Ball (set us) sink\n  [] = filter (\\<lambda>q. \\<not> sink q) vs\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "moreover"], ["proof (state)\nthis:\n  map (\\<lambda>q. \\<delta> q (w n)) sp' = us @ [p] @ vs\n  Ball (set us) sink\n  [] = filter (\\<lambda>q. \\<not> sink q) vs\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "hence \"\\<And>q''. q'' \\<in> (set us) \\<union> (set vs) \\<Longrightarrow> sink q''\""], ["proof (prove)\nusing this:\n  map (\\<lambda>q. \\<delta> q (w n)) sp' = us @ [p] @ vs\n  Ball (set us) sink\n  [] = filter (\\<lambda>q. \\<not> sink q) vs\n\ngoal (1 subgoal):\n 1. \\<And>q''. q'' \\<in> set us \\<union> set vs \\<Longrightarrow> sink q''", "by (metis UnE filter_empty_conv)"], ["proof (state)\nthis:\n  ?q'' \\<in> set us \\<union> set vs \\<Longrightarrow> sink ?q''\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "hence \"p \\<notin> (set us) \\<union> (set vs)\""], ["proof (prove)\nusing this:\n  ?q'' \\<in> set us \\<union> set vs \\<Longrightarrow> sink ?q''\n\ngoal (1 subgoal):\n 1. p \\<notin> set us \\<union> set vs", "using \\<open>\\<not> sink p\\<close>"], ["proof (prove)\nusing this:\n  ?q'' \\<in> set us \\<union> set vs \\<Longrightarrow> sink ?q''\n  \\<not> sink p\n\ngoal (1 subgoal):\n 1. p \\<notin> set us \\<union> set vs", "by blast"], ["proof (state)\nthis:\n  p \\<notin> set us \\<union> set vs\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "ultimately"], ["proof (chain)\npicking this:\n  map (\\<lambda>q. \\<delta> q (w n)) sp' = us @ [p] @ vs\n  Ball (set us) sink\n  [] = filter (\\<lambda>q. \\<not> sink q) vs\n  p \\<notin> set us \\<union> set vs", "have \"\\<And>q''. q'' \\<in> (set sp' - {p'}) \\<Longrightarrow> \\<delta> q'' (w n) \\<noteq> p\""], ["proof (prove)\nusing this:\n  map (\\<lambda>q. \\<delta> q (w n)) sp' = us @ [p] @ vs\n  Ball (set us) sink\n  [] = filter (\\<lambda>q. \\<not> sink q) vs\n  p \\<notin> set us \\<union> set vs\n\ngoal (1 subgoal):\n 1. \\<And>q''.\n       q'' \\<in> set sp' - {p'} \\<Longrightarrow>\n       \\<delta> q'' (w n) \\<noteq> p", "using 1 \\<open>p = \\<delta> p' (w n)\\<close> \\<open>p' \\<in> set sp'\\<close>"], ["proof (prove)\nusing this:\n  map (\\<lambda>q. \\<delta> q (w n)) sp' = us @ [p] @ vs\n  Ball (set us) sink\n  [] = filter (\\<lambda>q. \\<not> sink q) vs\n  p \\<notin> set us \\<union> set vs\n  map (\\<lambda>q. \\<delta> q (w n)) sp' = us @ [p] @ vs\n  p = \\<delta> p' (w n)\n  p' \\<in> set sp'\n\ngoal (1 subgoal):\n 1. \\<And>q''.\n       q'' \\<in> set sp' - {p'} \\<Longrightarrow>\n       \\<delta> q'' (w n) \\<noteq> p", "by (fastforce dest: split_list elim: map_splitE)"], ["proof (state)\nthis:\n  ?q'' \\<in> set sp' - {p'} \\<Longrightarrow> \\<delta> ?q'' (w n) \\<noteq> p\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "}"], ["proof (state)\nthis:\n  ?q''5 \\<in> set sp' - {p'} \\<Longrightarrow>\n  \\<delta> ?q''5 (w n) \\<noteq> p\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "ultimately"], ["proof (chain)\npicking this:\n  p = \\<delta> ?q'' (w n) \\<Longrightarrow>\n  ?q'' \\<notin> set qs' \\<union> set sq' \\<union> set ps'\n  ?q''5 \\<in> set sp' - {p'} \\<Longrightarrow>\n  \\<delta> ?q''5 (w n) \\<noteq> p", "have \"\\<And>q''. p = \\<delta> q'' (w n) \\<Longrightarrow> configuration q'' n \\<noteq> {} \\<Longrightarrow> q'' \\<in> set ps'' \\<or> q'' = p'\""], ["proof (prove)\nusing this:\n  p = \\<delta> ?q'' (w n) \\<Longrightarrow>\n  ?q'' \\<notin> set qs' \\<union> set sq' \\<union> set ps'\n  ?q''5 \\<in> set sp' - {p'} \\<Longrightarrow>\n  \\<delta> ?q''5 (w n) \\<noteq> p\n\ngoal (1 subgoal):\n 1. \\<And>q''.\n       \\<lbrakk>p = \\<delta> q'' (w n);\n        configuration q'' n \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> q'' \\<in> set ps'' \\<or> q'' = p'", "using nxt_run_configuration[of _ n]  \\<open>\\<not> sink p\\<close>[THEN sink_rev_step(2)]"], ["proof (prove)\nusing this:\n  p = \\<delta> ?q'' (w n) \\<Longrightarrow>\n  ?q'' \\<notin> set qs' \\<union> set sq' \\<union> set ps'\n  ?q''5 \\<in> set sp' - {p'} \\<Longrightarrow>\n  \\<delta> ?q''5 (w n) \\<noteq> p\n  (?q \\<in> set (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n                  n)) =\n  (\\<not> sink ?q \\<and> configuration ?q n \\<noteq> {})\n  p = \\<delta> ?q' (w ?i) \\<Longrightarrow> \\<not> sink ?q'\n\ngoal (1 subgoal):\n 1. \\<And>q''.\n       \\<lbrakk>p = \\<delta> q'' (w n);\n        configuration q'' n \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> q'' \\<in> set ps'' \\<or> q'' = p'", "unfolding r_def'[unfolded r_def] set_append"], ["proof (prove)\nusing this:\n  p = \\<delta> ?q'' (w n) \\<Longrightarrow>\n  ?q'' \\<notin> set qs' \\<union> set sq' \\<union> set ps'\n  ?q''5 \\<in> set sp' - {p'} \\<Longrightarrow>\n  \\<delta> ?q''5 (w n) \\<noteq> p\n  (?q \\<in> set qs' \\<union>\n            (set sq' \\<union>\n             (set ps' \\<union> (set sp' \\<union> set ps'')))) =\n  (\\<not> sink ?q \\<and> configuration ?q n \\<noteq> {})\n  p = \\<delta> ?q' (w ?i) \\<Longrightarrow> \\<not> sink ?q'\n\ngoal (1 subgoal):\n 1. \\<And>q''.\n       \\<lbrakk>p = \\<delta> q'' (w n);\n        configuration q'' n \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> q'' \\<in> set ps'' \\<or> q'' = p'", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>p = \\<delta> ?q'' (w n);\n   configuration ?q'' n \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> ?q'' \\<in> set ps'' \\<or> ?q'' = p'\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>p = \\<delta> ?q'' (w n);\n   configuration ?q'' n \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> ?q'' \\<in> set ps'' \\<or> ?q'' = p'\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "have \"\\<And>q''. q'' \\<in> set ps'' \\<Longrightarrow> x \\<le> ?f_n q''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q''.\n       q'' \\<in> set ps'' \\<Longrightarrow> x \\<le> the (oldest_token q'' n)", "using x_def"], ["proof (prove)\nusing this:\n  oldest_token p' n = Some x\n\ngoal (1 subgoal):\n 1. \\<And>q''.\n       q'' \\<in> set ps'' \\<Longrightarrow> x \\<le> the (oldest_token q'' n)", "using Suc"], ["proof (prove)\nusing this:\n  oldest_token p' n = Some x\n  sorted (map (\\<lambda>q. the (oldest_token q n)) (r n))\n\ngoal (1 subgoal):\n 1. \\<And>q''.\n       q'' \\<in> set ps'' \\<Longrightarrow> x \\<le> the (oldest_token q'' n)", "unfolding r_def' map_append sorted_append set_append set_map"], ["proof (prove)\nusing this:\n  oldest_token p' n = Some x\n  sorted (map (\\<lambda>q. the (oldest_token q n)) qs') \\<and>\n  (sorted (map (\\<lambda>q. the (oldest_token q n)) sq') \\<and>\n   (sorted (map (\\<lambda>q. the (oldest_token q n)) ps') \\<and>\n    (sorted (map (\\<lambda>q. the (oldest_token q n)) sp') \\<and>\n     sorted (map (\\<lambda>q. the (oldest_token q n)) ps'') \\<and>\n     (\\<forall>x\\<in>(\\<lambda>q. the (oldest_token q n)) ` set sp'.\n         Ball ((\\<lambda>q. the (oldest_token q n)) ` set ps'')\n          ((\\<le>) x))) \\<and>\n    (\\<forall>x\\<in>(\\<lambda>q. the (oldest_token q n)) ` set ps'.\n        Ball\n         ((\\<lambda>q. the (oldest_token q n)) ` set sp' \\<union>\n          (\\<lambda>q. the (oldest_token q n)) ` set ps'')\n         ((\\<le>) x))) \\<and>\n   (\\<forall>x\\<in>(\\<lambda>q. the (oldest_token q n)) ` set sq'.\n       Ball\n        ((\\<lambda>q. the (oldest_token q n)) ` set ps' \\<union>\n         ((\\<lambda>q. the (oldest_token q n)) ` set sp' \\<union>\n          (\\<lambda>q. the (oldest_token q n)) ` set ps''))\n        ((\\<le>) x))) \\<and>\n  (\\<forall>x\\<in>(\\<lambda>q. the (oldest_token q n)) ` set qs'.\n      Ball\n       ((\\<lambda>q. the (oldest_token q n)) ` set sq' \\<union>\n        ((\\<lambda>q. the (oldest_token q n)) ` set ps' \\<union>\n         ((\\<lambda>q. the (oldest_token q n)) ` set sp' \\<union>\n          (\\<lambda>q. the (oldest_token q n)) ` set ps'')))\n       ((\\<le>) x))\n\ngoal (1 subgoal):\n 1. \\<And>q''.\n       q'' \\<in> set ps'' \\<Longrightarrow> x \\<le> the (oldest_token q'' n)", "using \\<open>q' \\<in> set sq'\\<close> \\<open>p' \\<in> set sp'\\<close>"], ["proof (prove)\nusing this:\n  oldest_token p' n = Some x\n  sorted (map (\\<lambda>q. the (oldest_token q n)) qs') \\<and>\n  (sorted (map (\\<lambda>q. the (oldest_token q n)) sq') \\<and>\n   (sorted (map (\\<lambda>q. the (oldest_token q n)) ps') \\<and>\n    (sorted (map (\\<lambda>q. the (oldest_token q n)) sp') \\<and>\n     sorted (map (\\<lambda>q. the (oldest_token q n)) ps'') \\<and>\n     (\\<forall>x\\<in>(\\<lambda>q. the (oldest_token q n)) ` set sp'.\n         Ball ((\\<lambda>q. the (oldest_token q n)) ` set ps'')\n          ((\\<le>) x))) \\<and>\n    (\\<forall>x\\<in>(\\<lambda>q. the (oldest_token q n)) ` set ps'.\n        Ball\n         ((\\<lambda>q. the (oldest_token q n)) ` set sp' \\<union>\n          (\\<lambda>q. the (oldest_token q n)) ` set ps'')\n         ((\\<le>) x))) \\<and>\n   (\\<forall>x\\<in>(\\<lambda>q. the (oldest_token q n)) ` set sq'.\n       Ball\n        ((\\<lambda>q. the (oldest_token q n)) ` set ps' \\<union>\n         ((\\<lambda>q. the (oldest_token q n)) ` set sp' \\<union>\n          (\\<lambda>q. the (oldest_token q n)) ` set ps''))\n        ((\\<le>) x))) \\<and>\n  (\\<forall>x\\<in>(\\<lambda>q. the (oldest_token q n)) ` set qs'.\n      Ball\n       ((\\<lambda>q. the (oldest_token q n)) ` set sq' \\<union>\n        ((\\<lambda>q. the (oldest_token q n)) ` set ps' \\<union>\n         ((\\<lambda>q. the (oldest_token q n)) ` set sp' \\<union>\n          (\\<lambda>q. the (oldest_token q n)) ` set ps'')))\n       ((\\<le>) x))\n  q' \\<in> set sq'\n  p' \\<in> set sp'\n\ngoal (1 subgoal):\n 1. \\<And>q''.\n       q'' \\<in> set ps'' \\<Longrightarrow> x \\<le> the (oldest_token q'' n)", "apply (simp del: oldest_token.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q''.\n       \\<lbrakk>q'' \\<in> set ps''; oldest_token p' n = Some x;\n        sorted (map (\\<lambda>q. the (oldest_token q n)) qs') \\<and>\n        sorted (map (\\<lambda>q. the (oldest_token q n)) sq') \\<and>\n        sorted (map (\\<lambda>q. the (oldest_token q n)) ps') \\<and>\n        sorted (map (\\<lambda>q. the (oldest_token q n)) sp') \\<and>\n        sorted (map (\\<lambda>q. the (oldest_token q n)) ps'') \\<and>\n        (\\<forall>x\\<in>set sp'.\n            \\<forall>xa\\<in>set ps''.\n               the (oldest_token x n) \\<le> the (oldest_token xa n)) \\<and>\n        (\\<forall>x\\<in>set ps'.\n            Ball\n             ((\\<lambda>q. the (oldest_token q n)) ` set sp' \\<union>\n              (\\<lambda>q. the (oldest_token q n)) ` set ps'')\n             ((\\<le>) (the (oldest_token x n)))) \\<and>\n        (\\<forall>x\\<in>set sq'.\n            Ball\n             ((\\<lambda>q. the (oldest_token q n)) ` set ps' \\<union>\n              ((\\<lambda>q. the (oldest_token q n)) ` set sp' \\<union>\n               (\\<lambda>q. the (oldest_token q n)) ` set ps''))\n             ((\\<le>) (the (oldest_token x n)))) \\<and>\n        (\\<forall>x\\<in>set qs'.\n            Ball\n             ((\\<lambda>q. the (oldest_token q n)) ` set sq' \\<union>\n              ((\\<lambda>q. the (oldest_token q n)) ` set ps' \\<union>\n               ((\\<lambda>q. the (oldest_token q n)) ` set sp' \\<union>\n                (\\<lambda>q. the (oldest_token q n)) ` set ps'')))\n             ((\\<le>) (the (oldest_token x n))));\n        q' \\<in> set sq'; p' \\<in> set sp'\\<rbrakk>\n       \\<Longrightarrow> x \\<le> the (oldest_token q'' n)", "by fastforce"], ["proof (state)\nthis:\n  ?q'' \\<in> set ps'' \\<Longrightarrow> x \\<le> the (oldest_token ?q'' n)\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "moreover"], ["proof (state)\nthis:\n  ?q'' \\<in> set ps'' \\<Longrightarrow> x \\<le> the (oldest_token ?q'' n)\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "have \"\\<And>q''. q'' = p' \\<Longrightarrow> x \\<le> ?f_n q''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q''. q'' = p' \\<Longrightarrow> x \\<le> the (oldest_token q'' n)", "using x_def"], ["proof (prove)\nusing this:\n  oldest_token p' n = Some x\n\ngoal (1 subgoal):\n 1. \\<And>q''. q'' = p' \\<Longrightarrow> x \\<le> the (oldest_token q'' n)", "by simp"], ["proof (state)\nthis:\n  ?q'' = p' \\<Longrightarrow> x \\<le> the (oldest_token ?q'' n)\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "moreover"], ["proof (state)\nthis:\n  ?q'' = p' \\<Longrightarrow> x \\<le> the (oldest_token ?q'' n)\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "have \"\\<And>q'' x. x \\<in> configuration q'' n \\<Longrightarrow> the (oldest_token q'' n) \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q'' x.\n       x \\<in> configuration q'' n \\<Longrightarrow>\n       the (oldest_token q'' n) \\<le> x", "using assms"], ["proof (prove)\nusing this:\n  r \\<equiv> run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n\ngoal (1 subgoal):\n 1. \\<And>q'' x.\n       x \\<in> configuration q'' n \\<Longrightarrow>\n       the (oldest_token q'' n) \\<le> x", "by auto"], ["proof (state)\nthis:\n  ?x \\<in> configuration ?q'' n \\<Longrightarrow>\n  the (oldest_token ?q'' n) \\<le> ?x\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>p = \\<delta> ?q'' (w n);\n   configuration ?q'' n \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> ?q'' \\<in> set ps'' \\<or> ?q'' = p'\n  ?q'' \\<in> set ps'' \\<Longrightarrow> x \\<le> the (oldest_token ?q'' n)\n  ?q'' = p' \\<Longrightarrow> x \\<le> the (oldest_token ?q'' n)\n  ?x \\<in> configuration ?q'' n \\<Longrightarrow>\n  the (oldest_token ?q'' n) \\<le> ?x", "have \"\\<And>z. z \\<in> \\<Union>{configuration p' n |p'. p = \\<delta> p' (w n)} \\<Longrightarrow> x \\<le> z\""], ["proof (prove)\nusing this:\n  \\<lbrakk>p = \\<delta> ?q'' (w n);\n   configuration ?q'' n \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> ?q'' \\<in> set ps'' \\<or> ?q'' = p'\n  ?q'' \\<in> set ps'' \\<Longrightarrow> x \\<le> the (oldest_token ?q'' n)\n  ?q'' = p' \\<Longrightarrow> x \\<le> the (oldest_token ?q'' n)\n  ?x \\<in> configuration ?q'' n \\<Longrightarrow>\n  the (oldest_token ?q'' n) \\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<in> \\<Union>\n                {configuration p' n |p'.\n                 p = \\<delta> p' (w n)} \\<Longrightarrow>\n       x \\<le> z", "by fastforce"], ["proof (state)\nthis:\n  ?z \\<in> \\<Union>\n            {configuration p' n |p'.\n             p = \\<delta> p' (w n)} \\<Longrightarrow>\n  x \\<le> ?z\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "}"], ["proof (state)\nthis:\n  ?z \\<in> \\<Union>\n            {configuration p' n |p'.\n             p = \\<delta> p' (w n)} \\<Longrightarrow>\n  x \\<le> ?z\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "hence \"\\<And>z. z \\<in> configuration p (Suc n) \\<Longrightarrow> x \\<le> z\""], ["proof (prove)\nusing this:\n  ?z \\<in> \\<Union>\n            {configuration p' n |p'.\n             p = \\<delta> p' (w n)} \\<Longrightarrow>\n  x \\<le> ?z\n\ngoal (1 subgoal):\n 1. \\<And>z. z \\<in> configuration p (Suc n) \\<Longrightarrow> x \\<le> z", "unfolding configuration_step_eq_unified"], ["proof (prove)\nusing this:\n  ?z \\<in> \\<Union>\n            {configuration p' n |p'.\n             p = \\<delta> p' (w n)} \\<Longrightarrow>\n  x \\<le> ?z\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<in> \\<Union>\n                {configuration q' n |q'. p = \\<delta> q' (w n)} \\<union>\n               (if p = q\\<^sub>0 then {Suc n} else {}) \\<Longrightarrow>\n       x \\<le> z", "using \\<open>x \\<le> n\\<close>"], ["proof (prove)\nusing this:\n  ?z \\<in> \\<Union>\n            {configuration p' n |p'.\n             p = \\<delta> p' (w n)} \\<Longrightarrow>\n  x \\<le> ?z\n  x \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<in> \\<Union>\n                {configuration q' n |q'. p = \\<delta> q' (w n)} \\<union>\n               (if p = q\\<^sub>0 then {Suc n} else {}) \\<Longrightarrow>\n       x \\<le> z", "by (cases \"p = q\\<^sub>0\"; auto)"], ["proof (state)\nthis:\n  ?z \\<in> configuration p (Suc n) \\<Longrightarrow> x \\<le> ?z\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "hence \"x \\<le> y\""], ["proof (prove)\nusing this:\n  ?z \\<in> configuration p (Suc n) \\<Longrightarrow> x \\<le> ?z\n\ngoal (1 subgoal):\n 1. x \\<le> y", "using y_def Min.boundedI configuration_finite"], ["proof (prove)\nusing this:\n  ?z \\<in> configuration p (Suc n) \\<Longrightarrow> x \\<le> ?z\n  oldest_token p (Suc n) = Some y\n  \\<lbrakk>finite ?A; ?A \\<noteq> {};\n   \\<And>a. a \\<in> ?A \\<Longrightarrow> ?x \\<le> a\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> Min ?A\n  finite (configuration ?q ?n)\n\ngoal (1 subgoal):\n 1. x \\<le> y", "using push_down_oldest_token_configuration"], ["proof (prove)\nusing this:\n  ?z \\<in> configuration p (Suc n) \\<Longrightarrow> x \\<le> ?z\n  oldest_token p (Suc n) = Some y\n  \\<lbrakk>finite ?A; ?A \\<noteq> {};\n   \\<And>a. a \\<in> ?A \\<Longrightarrow> ?x \\<le> a\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> Min ?A\n  finite (configuration ?q ?n)\n  oldest_token ?q ?n = Some ?x \\<Longrightarrow>\n  ?x \\<in> configuration ?q ?n\n\ngoal (1 subgoal):\n 1. x \\<le> y", "by presburger"], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "ultimately"], ["proof (chain)\npicking this:\n  y \\<le> x\n  x \\<le> y", "have \"?f_n p' = ?f_Suc_n p\""], ["proof (prove)\nusing this:\n  y \\<le> x\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. the (oldest_token p' n) = the (oldest_token p (Suc n))", "using x_def y_def"], ["proof (prove)\nusing this:\n  y \\<le> x\n  x \\<le> y\n  oldest_token p' n = Some x\n  oldest_token p (Suc n) = Some y\n\ngoal (1 subgoal):\n 1. the (oldest_token p' n) = the (oldest_token p (Suc n))", "by fastforce"], ["proof (state)\nthis:\n  the (oldest_token p' n) = the (oldest_token p (Suc n))\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "}"], ["proof (state)\nthis:\n  the (oldest_token p' n) = the (oldest_token p (Suc n))\n\ngoal (1 subgoal):\n 1. zs'' \\<noteq> [] \\<Longrightarrow>\n    the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "ultimately"], ["proof (chain)\npicking this:\n  the (oldest_token q' n) \\<le> the (oldest_token p' n)\n  the (oldest_token q' n) = the (oldest_token q (Suc n))\n  the (oldest_token p' n) = the (oldest_token p (Suc n))", "show ?thesis"], ["proof (prove)\nusing this:\n  the (oldest_token q' n) \\<le> the (oldest_token p' n)\n  the (oldest_token q' n) = the (oldest_token q (Suc n))\n  the (oldest_token p' n) = the (oldest_token p (Suc n))\n\ngoal (1 subgoal):\n 1. the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))", "by presburger"], ["proof (state)\nthis:\n  the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  the (oldest_token q (Suc n)) \\<le> the (oldest_token p (Suc n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  remdups_fwd\n   (filter (\\<lambda>q. \\<not> sink q)\n     (map (\\<lambda>q. \\<delta> q (w n)) (r n) @ [q\\<^sub>0])) =\n  ?qs @ ?q # ?p # ?ps \\<Longrightarrow>\n  the (oldest_token ?q (Suc n)) \\<le> the (oldest_token ?p (Suc n))\n\ngoal (2 subgoals):\n 1. sorted (map (\\<lambda>q. the (oldest_token q 0)) (r 0))\n 2. \\<And>n.\n       sorted\n        (map (\\<lambda>q. the (oldest_token q n)) (r n)) \\<Longrightarrow>\n       sorted (map (\\<lambda>q. the (oldest_token q (Suc n))) (r (Suc n)))", "hence \"\\<And>x y xs ys. map ?f_Suc_n (remdups_fwd ?step) = xs @ [x, y] @ ys \\<Longrightarrow> x \\<le> y\""], ["proof (prove)\nusing this:\n  remdups_fwd\n   (filter (\\<lambda>q. \\<not> sink q)\n     (map (\\<lambda>q. \\<delta> q (w n)) (r n) @ [q\\<^sub>0])) =\n  ?qs @ ?q # ?p # ?ps \\<Longrightarrow>\n  the (oldest_token ?q (Suc n)) \\<le> the (oldest_token ?p (Suc n))\n\ngoal (1 subgoal):\n 1. \\<And>x y xs ys.\n       map (\\<lambda>q. the (oldest_token q (Suc n)))\n        (remdups_fwd\n          (filter (\\<lambda>q. \\<not> sink q)\n            (map (\\<lambda>q. \\<delta> q (w n)) (r n) @ [q\\<^sub>0]))) =\n       xs @ [x, y] @ ys \\<Longrightarrow>\n       x \\<le> y", "by (auto elim: map_splitE simp del: remdups_fwd.simps)"], ["proof (state)\nthis:\n  map (\\<lambda>q. the (oldest_token q (Suc n)))\n   (remdups_fwd\n     (filter (\\<lambda>q. \\<not> sink q)\n       (map (\\<lambda>q. \\<delta> q (w n)) (r n) @ [q\\<^sub>0]))) =\n  ?xs @ [?x, ?y] @ ?ys \\<Longrightarrow>\n  ?x \\<le> ?y\n\ngoal (2 subgoals):\n 1. sorted (map (\\<lambda>q. the (oldest_token q 0)) (r 0))\n 2. \\<And>n.\n       sorted\n        (map (\\<lambda>q. the (oldest_token q n)) (r n)) \\<Longrightarrow>\n       sorted (map (\\<lambda>q. the (oldest_token q (Suc n))) (r (Suc n)))", "hence \"sorted (map ?f_Suc_n (remdups_fwd (?step)))\""], ["proof (prove)\nusing this:\n  map (\\<lambda>q. the (oldest_token q (Suc n)))\n   (remdups_fwd\n     (filter (\\<lambda>q. \\<not> sink q)\n       (map (\\<lambda>q. \\<delta> q (w n)) (r n) @ [q\\<^sub>0]))) =\n  ?xs @ [?x, ?y] @ ?ys \\<Longrightarrow>\n  ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. sorted\n     (map (\\<lambda>q. the (oldest_token q (Suc n)))\n       (remdups_fwd\n         (filter (\\<lambda>q. \\<not> sink q)\n           (map (\\<lambda>q. \\<delta> q (w n)) (r n) @ [q\\<^sub>0]))))", "using sorted_pre"], ["proof (prove)\nusing this:\n  map (\\<lambda>q. the (oldest_token q (Suc n)))\n   (remdups_fwd\n     (filter (\\<lambda>q. \\<not> sink q)\n       (map (\\<lambda>q. \\<delta> q (w n)) (r n) @ [q\\<^sub>0]))) =\n  ?xs @ [?x, ?y] @ ?ys \\<Longrightarrow>\n  ?x \\<le> ?y\n  (\\<And>x y xs ys.\n      ?zs = xs @ [x, y] @ ys \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n  sorted ?zs\n\ngoal (1 subgoal):\n 1. sorted\n     (map (\\<lambda>q. the (oldest_token q (Suc n)))\n       (remdups_fwd\n         (filter (\\<lambda>q. \\<not> sink q)\n           (map (\\<lambda>q. \\<delta> q (w n)) (r n) @ [q\\<^sub>0]))))", "by metis"], ["proof (state)\nthis:\n  sorted\n   (map (\\<lambda>q. the (oldest_token q (Suc n)))\n     (remdups_fwd\n       (filter (\\<lambda>q. \\<not> sink q)\n         (map (\\<lambda>q. \\<delta> q (w n)) (r n) @ [q\\<^sub>0]))))\n\ngoal (2 subgoals):\n 1. sorted (map (\\<lambda>q. the (oldest_token q 0)) (r 0))\n 2. \\<And>n.\n       sorted\n        (map (\\<lambda>q. the (oldest_token q n)) (r n)) \\<Longrightarrow>\n       sorted (map (\\<lambda>q. the (oldest_token q (Suc n))) (r (Suc n)))", "thus ?case"], ["proof (prove)\nusing this:\n  sorted\n   (map (\\<lambda>q. the (oldest_token q (Suc n)))\n     (remdups_fwd\n       (filter (\\<lambda>q. \\<not> sink q)\n         (map (\\<lambda>q. \\<delta> q (w n)) (r n) @ [q\\<^sub>0]))))\n\ngoal (1 subgoal):\n 1. sorted (map (\\<lambda>q. the (oldest_token q (Suc n))) (r (Suc n)))", "by (simp add: r_def sink_def)"], ["proof (state)\nthis:\n  sorted (map (\\<lambda>q. the (oldest_token q (Suc n))) (r (Suc n)))\n\ngoal (1 subgoal):\n 1. sorted (map (\\<lambda>q. the (oldest_token q 0)) (r 0))", "qed (simp add: r_def)"], ["", "lemma (in semi_mojmir) nxt_run_senior_states: \n  defines \"r \\<equiv> run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\" \n  assumes \"\\<not>sink q\"\n  assumes \"configuration q n \\<noteq> {}\" \n  shows \"senior_states q n = set (takeWhile (\\<lambda>q'. q' \\<noteq> q) (r n))\" \n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. senior_states q n = set (takeWhile (\\<lambda>q'. q' \\<noteq> q) (r n))", "proof (rule set_eqI, rule)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> senior_states q n \\<Longrightarrow>\n       x \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q) (r n))\n 2. \\<And>x.\n       x \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q)\n                     (r n)) \\<Longrightarrow>\n       x \\<in> senior_states q n", "fix q'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> senior_states q n \\<Longrightarrow>\n       x \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q) (r n))\n 2. \\<And>x.\n       x \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q)\n                     (r n)) \\<Longrightarrow>\n       x \\<in> senior_states q n", "assume q'_def: \"q' \\<in> senior_states q n\""], ["proof (state)\nthis:\n  q' \\<in> senior_states q n\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> senior_states q n \\<Longrightarrow>\n       x \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q) (r n))\n 2. \\<And>x.\n       x \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q)\n                     (r n)) \\<Longrightarrow>\n       x \\<in> senior_states q n", "then"], ["proof (chain)\npicking this:\n  q' \\<in> senior_states q n", "obtain x y where \"oldest_token q' n = Some y\" and \"oldest_token q n = Some x\" and \"y < x\""], ["proof (prove)\nusing this:\n  q' \\<in> senior_states q n\n\ngoal (1 subgoal):\n 1. (\\<And>y x.\n        \\<lbrakk>oldest_token q' n = Some y; oldest_token q n = Some x;\n         y < x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using senior_states.simps"], ["proof (prove)\nusing this:\n  q' \\<in> senior_states q n\n  senior_states ?q ?n =\n  {p. \\<exists>x y.\n         oldest_token p ?n = Some y \\<and>\n         oldest_token ?q ?n = Some x \\<and> y < x \\<and> \\<not> sink p}\n\ngoal (1 subgoal):\n 1. (\\<And>y x.\n        \\<lbrakk>oldest_token q' n = Some y; oldest_token q n = Some x;\n         y < x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  q' \\<in> senior_states q n\n  senior_states ?q ?n =\n  {p. \\<exists>x y.\n         oldest_token p ?n = Some y \\<and>\n         oldest_token ?q ?n = Some x \\<and> y < x \\<and> \\<not> sink p}\n  r \\<equiv> run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n  \\<not> sink q\n  configuration q n \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>y x.\n        \\<lbrakk>oldest_token q' n = Some y; oldest_token q n = Some x;\n         y < x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  oldest_token q' n = Some y\n  oldest_token q n = Some x\n  y < x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> senior_states q n \\<Longrightarrow>\n       x \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q) (r n))\n 2. \\<And>x.\n       x \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q)\n                     (r n)) \\<Longrightarrow>\n       x \\<in> senior_states q n", "hence \"the (oldest_token q' n) < the (oldest_token q n)\""], ["proof (prove)\nusing this:\n  oldest_token q' n = Some y\n  oldest_token q n = Some x\n  y < x\n\ngoal (1 subgoal):\n 1. the (oldest_token q' n) < the (oldest_token q n)", "by fastforce"], ["proof (state)\nthis:\n  the (oldest_token q' n) < the (oldest_token q n)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> senior_states q n \\<Longrightarrow>\n       x \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q) (r n))\n 2. \\<And>x.\n       x \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q)\n                     (r n)) \\<Longrightarrow>\n       x \\<in> senior_states q n", "moreover"], ["proof (state)\nthis:\n  the (oldest_token q' n) < the (oldest_token q n)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> senior_states q n \\<Longrightarrow>\n       x \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q) (r n))\n 2. \\<And>x.\n       x \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q)\n                     (r n)) \\<Longrightarrow>\n       x \\<in> senior_states q n", "hence \"\\<not>sink q'\" and \"configuration q' n \\<noteq> {}\""], ["proof (prove)\nusing this:\n  the (oldest_token q' n) < the (oldest_token q n)\n\ngoal (1 subgoal):\n 1. \\<not> sink q' &&& configuration q' n \\<noteq> {}", "using q'_def option.distinct(1) \\<open>oldest_token q' n = Some y\\<close> \n     oldest_token.simps"], ["proof (prove)\nusing this:\n  the (oldest_token q' n) < the (oldest_token q n)\n  q' \\<in> senior_states q n\n  None \\<noteq> Some ?x2.0\n  oldest_token q' n = Some y\n  oldest_token ?q ?n =\n  (if configuration ?q ?n \\<noteq> {} then Some (Min (configuration ?q ?n))\n   else None)\n\ngoal (1 subgoal):\n 1. \\<not> sink q' &&& configuration q' n \\<noteq> {}", "using assms"], ["proof (prove)\nusing this:\n  the (oldest_token q' n) < the (oldest_token q n)\n  q' \\<in> senior_states q n\n  None \\<noteq> Some ?x2.0\n  oldest_token q' n = Some y\n  oldest_token ?q ?n =\n  (if configuration ?q ?n \\<noteq> {} then Some (Min (configuration ?q ?n))\n   else None)\n  r \\<equiv> run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n  \\<not> sink q\n  configuration q n \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> sink q' &&& configuration q' n \\<noteq> {}", "by (force, metis)"], ["proof (state)\nthis:\n  \\<not> sink q'\n  configuration q' n \\<noteq> {}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> senior_states q n \\<Longrightarrow>\n       x \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q) (r n))\n 2. \\<And>x.\n       x \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q)\n                     (r n)) \\<Longrightarrow>\n       x \\<in> senior_states q n", "hence \"q' \\<in> set (r n)\" and \"q \\<in> set (r n)\""], ["proof (prove)\nusing this:\n  \\<not> sink q'\n  configuration q' n \\<noteq> {}\n\ngoal (1 subgoal):\n 1. q' \\<in> set (r n) &&& q \\<in> set (r n)", "using nxt_run_configuration assms"], ["proof (prove)\nusing this:\n  \\<not> sink q'\n  configuration q' n \\<noteq> {}\n  (?q \\<in> set (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n                  ?n)) =\n  (\\<not> sink ?q \\<and> configuration ?q ?n \\<noteq> {})\n  r \\<equiv> run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n  \\<not> sink q\n  configuration q n \\<noteq> {}\n\ngoal (1 subgoal):\n 1. q' \\<in> set (r n) &&& q \\<in> set (r n)", "by blast+"], ["proof (state)\nthis:\n  q' \\<in> set (r n)\n  q \\<in> set (r n)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> senior_states q n \\<Longrightarrow>\n       x \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q) (r n))\n 2. \\<And>x.\n       x \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q)\n                     (r n)) \\<Longrightarrow>\n       x \\<in> senior_states q n", "moreover"], ["proof (state)\nthis:\n  q' \\<in> set (r n)\n  q \\<in> set (r n)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> senior_states q n \\<Longrightarrow>\n       x \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q) (r n))\n 2. \\<And>x.\n       x \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q)\n                     (r n)) \\<Longrightarrow>\n       x \\<in> senior_states q n", "have \"distinct (r n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (r n)", "unfolding r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w n)", "using nxt_run_distinct"], ["proof (prove)\nusing this:\n  distinct\n   (run (nxt ?\\<Sigma> ?\\<Delta> ?q\\<^sub>0) (init ?q\\<^sub>0) ?w ?n)\n\ngoal (1 subgoal):\n 1. distinct (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w n)", "by fast"], ["proof (state)\nthis:\n  distinct (r n)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> senior_states q n \\<Longrightarrow>\n       x \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q) (r n))\n 2. \\<And>x.\n       x \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q)\n                     (r n)) \\<Longrightarrow>\n       x \\<in> senior_states q n", "ultimately"], ["proof (chain)\npicking this:\n  the (oldest_token q' n) < the (oldest_token q n)\n  q' \\<in> set (r n)\n  q \\<in> set (r n)\n  distinct (r n)", "obtain r' r'' r''' where r_alt_def: \"r n = r' @ q' # r'' @ q # r'''\""], ["proof (prove)\nusing this:\n  the (oldest_token q' n) < the (oldest_token q n)\n  q' \\<in> set (r n)\n  q \\<in> set (r n)\n  distinct (r n)\n\ngoal (1 subgoal):\n 1. (\\<And>r' r'' r'''.\n        r n = r' @ q' # r'' @ q # r''' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using sorted_list[OF _ _ nxt_run_sorted] assms"], ["proof (prove)\nusing this:\n  the (oldest_token q' n) < the (oldest_token q n)\n  q' \\<in> set (r n)\n  q \\<in> set (r n)\n  distinct (r n)\n  \\<lbrakk>?x \\<in> set (run (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n                          (init q\\<^sub>0) w ?n1);\n   ?y \\<in> set (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n                  ?n1);\n   the (oldest_token ?x ?n1) < the (oldest_token ?y ?n1)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs' xs'' xs'''.\n                       run (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n                        (init q\\<^sub>0) w ?n1 =\n                       xs' @ ?x # xs'' @ ?y # xs'''\n  r \\<equiv> run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n  \\<not> sink q\n  configuration q n \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>r' r'' r'''.\n        r n = r' @ q' # r'' @ q # r''' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding r_def"], ["proof (prove)\nusing this:\n  the (oldest_token q' n) < the (oldest_token q n)\n  q' \\<in> set (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w n)\n  q \\<in> set (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w n)\n  distinct (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w n)\n  \\<lbrakk>?x \\<in> set (run (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n                          (init q\\<^sub>0) w ?n1);\n   ?y \\<in> set (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n                  ?n1);\n   the (oldest_token ?x ?n1) < the (oldest_token ?y ?n1)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs' xs'' xs'''.\n                       run (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n                        (init q\\<^sub>0) w ?n1 =\n                       xs' @ ?x # xs'' @ ?y # xs'''\n  run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w \\<equiv>\n  run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n  \\<not> sink q\n  configuration q n \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>r' r'' r'''.\n        run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w n =\n        r' @ q' # r'' @ q # r''' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by presburger"], ["proof (state)\nthis:\n  r n = r' @ q' # r'' @ q # r'''\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> senior_states q n \\<Longrightarrow>\n       x \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q) (r n))\n 2. \\<And>x.\n       x \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q)\n                     (r n)) \\<Longrightarrow>\n       x \\<in> senior_states q n", "hence \"q' \\<in> set (r' @ q' # r'')\""], ["proof (prove)\nusing this:\n  r n = r' @ q' # r'' @ q # r'''\n\ngoal (1 subgoal):\n 1. q' \\<in> set (r' @ q' # r'')", "by simp"], ["proof (state)\nthis:\n  q' \\<in> set (r' @ q' # r'')\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> senior_states q n \\<Longrightarrow>\n       x \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q) (r n))\n 2. \\<And>x.\n       x \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q)\n                     (r n)) \\<Longrightarrow>\n       x \\<in> senior_states q n", "thus \"q' \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q) (r n))\""], ["proof (prove)\nusing this:\n  q' \\<in> set (r' @ q' # r'')\n\ngoal (1 subgoal):\n 1. q' \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q) (r n))", "using \\<open>distinct (r n)\\<close> takeWhile_distinct[of \"r' @ q' # r''\" q r''' q']"], ["proof (prove)\nusing this:\n  q' \\<in> set (r' @ q' # r'')\n  distinct (r n)\n  distinct ((r' @ q' # r'') @ q # r''') \\<Longrightarrow>\n  (q' \\<in> set (takeWhile (\\<lambda>y. y \\<noteq> q)\n                  ((r' @ q' # r'') @ q # r'''))) =\n  (q' \\<in> set (r' @ q' # r''))\n\ngoal (1 subgoal):\n 1. q' \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q) (r n))", "unfolding r_alt_def"], ["proof (prove)\nusing this:\n  q' \\<in> set (r' @ q' # r'')\n  distinct (r' @ q' # r'' @ q # r''')\n  distinct ((r' @ q' # r'') @ q # r''') \\<Longrightarrow>\n  (q' \\<in> set (takeWhile (\\<lambda>y. y \\<noteq> q)\n                  ((r' @ q' # r'') @ q # r'''))) =\n  (q' \\<in> set (r' @ q' # r''))\n\ngoal (1 subgoal):\n 1. q' \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q)\n                   (r' @ q' # r'' @ q # r'''))", "by simp"], ["proof (state)\nthis:\n  q' \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q) (r n))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q)\n                     (r n)) \\<Longrightarrow>\n       x \\<in> senior_states q n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q)\n                     (r n)) \\<Longrightarrow>\n       x \\<in> senior_states q n", "fix q'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q)\n                     (r n)) \\<Longrightarrow>\n       x \\<in> senior_states q n", "assume q'_def: \"q' \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q) (r n))\""], ["proof (state)\nthis:\n  q' \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q) (r n))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q)\n                     (r n)) \\<Longrightarrow>\n       x \\<in> senior_states q n", "moreover"], ["proof (state)\nthis:\n  q' \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q) (r n))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q)\n                     (r n)) \\<Longrightarrow>\n       x \\<in> senior_states q n", "hence \"q' \\<in> set (r n)\""], ["proof (prove)\nusing this:\n  q' \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q) (r n))\n\ngoal (1 subgoal):\n 1. q' \\<in> set (r n)", "by (blast dest: set_takeWhileD)+"], ["proof (state)\nthis:\n  q' \\<in> set (r n)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q)\n                     (r n)) \\<Longrightarrow>\n       x \\<in> senior_states q n", "hence 5: \"\\<not> sink q'\""], ["proof (prove)\nusing this:\n  q' \\<in> set (r n)\n\ngoal (1 subgoal):\n 1. \\<not> sink q'", "using nxt_run_configuration assms"], ["proof (prove)\nusing this:\n  q' \\<in> set (r n)\n  (?q \\<in> set (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n                  ?n)) =\n  (\\<not> sink ?q \\<and> configuration ?q ?n \\<noteq> {})\n  r \\<equiv> run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n  \\<not> sink q\n  configuration q n \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> sink q'", "by simp"], ["proof (state)\nthis:\n  \\<not> sink q'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q)\n                     (r n)) \\<Longrightarrow>\n       x \\<in> senior_states q n", "have \"q \\<in> set (r n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> set (r n)", "using nxt_run_configuration assms"], ["proof (prove)\nusing this:\n  (?q \\<in> set (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n                  ?n)) =\n  (\\<not> sink ?q \\<and> configuration ?q ?n \\<noteq> {})\n  r \\<equiv> run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n  \\<not> sink q\n  configuration q n \\<noteq> {}\n\ngoal (1 subgoal):\n 1. q \\<in> set (r n)", "by blast+"], ["proof (state)\nthis:\n  q \\<in> set (r n)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q)\n                     (r n)) \\<Longrightarrow>\n       x \\<in> senior_states q n", "ultimately"], ["proof (chain)\npicking this:\n  q' \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q) (r n))\n  q \\<in> set (r n)", "obtain  r' r'' r''' where r_alt_def: \"r n = r' @ q' # r'' @ q # r'''\""], ["proof (prove)\nusing this:\n  q' \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q) (r n))\n  q \\<in> set (r n)\n\ngoal (1 subgoal):\n 1. (\\<And>r' r'' r'''.\n        r n = r' @ q' # r'' @ q # r''' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using takeWhile_split"], ["proof (prove)\nusing this:\n  q' \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q) (r n))\n  q \\<in> set (r n)\n  \\<lbrakk>?x \\<in> set ?xs;\n   ?y \\<in> set (takeWhile (\\<lambda>y. y \\<noteq> ?x) ?xs)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs' xs'' xs'''.\n                       ?xs = xs' @ ?y # xs'' @ ?x # xs'''\n\ngoal (1 subgoal):\n 1. (\\<And>r' r'' r'''.\n        r n = r' @ q' # r'' @ q # r''' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  r n = r' @ q' # r'' @ q # r'''\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q)\n                     (r n)) \\<Longrightarrow>\n       x \\<in> senior_states q n", "have \"distinct (r n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (r n)", "unfolding r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w n)", "using nxt_run_distinct"], ["proof (prove)\nusing this:\n  distinct\n   (run (nxt ?\\<Sigma> ?\\<Delta> ?q\\<^sub>0) (init ?q\\<^sub>0) ?w ?n)\n\ngoal (1 subgoal):\n 1. distinct (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w n)", "by fast"], ["proof (state)\nthis:\n  distinct (r n)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q)\n                     (r n)) \\<Longrightarrow>\n       x \\<in> senior_states q n", "have 1: \"the (oldest_token q' n) \\<le> the (oldest_token q n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the (oldest_token q' n) \\<le> the (oldest_token q n)", "using nxt_run_sorted[of n, unfolded r_def[symmetric]] assms"], ["proof (prove)\nusing this:\n  sorted (map (\\<lambda>q. the (oldest_token q n)) (r n))\n  r \\<equiv> run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n  \\<not> sink q\n  configuration q n \\<noteq> {}\n\ngoal (1 subgoal):\n 1. the (oldest_token q' n) \\<le> the (oldest_token q n)", "unfolding r_alt_def map_append list.map"], ["proof (prove)\nusing this:\n  sorted\n   (map (\\<lambda>q. the (oldest_token q n)) r' @\n    the (oldest_token q' n) #\n    map (\\<lambda>q. the (oldest_token q n)) r'' @\n    the (oldest_token q n) # map (\\<lambda>q. the (oldest_token q n)) r''')\n  r \\<equiv> run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n  \\<not> sink q\n  configuration q n \\<noteq> {}\n\ngoal (1 subgoal):\n 1. the (oldest_token q' n) \\<le> the (oldest_token q n)", "unfolding sorted_append"], ["proof (prove)\nusing this:\n  sorted (map (\\<lambda>q. the (oldest_token q n)) r') \\<and>\n  sorted\n   (the (oldest_token q' n) #\n    map (\\<lambda>q. the (oldest_token q n)) r'' @\n    the (oldest_token q n) #\n    map (\\<lambda>q. the (oldest_token q n)) r''') \\<and>\n  (\\<forall>x\\<in>set (map (\\<lambda>q. the (oldest_token q n)) r').\n      Ball\n       (set (the (oldest_token q' n) #\n             map (\\<lambda>q. the (oldest_token q n)) r'' @\n             the (oldest_token q n) #\n             map (\\<lambda>q. the (oldest_token q n)) r'''))\n       ((\\<le>) x))\n  r \\<equiv> run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n  \\<not> sink q\n  configuration q n \\<noteq> {}\n\ngoal (1 subgoal):\n 1. the (oldest_token q' n) \\<le> the (oldest_token q n)", "by (simp del: oldest_token.simps)"], ["proof (state)\nthis:\n  the (oldest_token q' n) \\<le> the (oldest_token q n)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q)\n                     (r n)) \\<Longrightarrow>\n       x \\<in> senior_states q n", "have \"q \\<noteq> q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> q'", "using \\<open>distinct (r n)\\<close> r_alt_def"], ["proof (prove)\nusing this:\n  distinct (r n)\n  r n = r' @ q' # r'' @ q # r'''\n\ngoal (1 subgoal):\n 1. q \\<noteq> q'", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> q'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q)\n                     (r n)) \\<Longrightarrow>\n       x \\<in> senior_states q n", "moreover"], ["proof (state)\nthis:\n  q \\<noteq> q'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q)\n                     (r n)) \\<Longrightarrow>\n       x \\<in> senior_states q n", "have 2: \"oldest_token q' n \\<noteq> None\" and 3: \"oldest_token q n \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oldest_token q' n \\<noteq> None &&& oldest_token q n \\<noteq> None", "using assms \\<open>q' \\<in> set (r n)\\<close> nxt_run_configuration"], ["proof (prove)\nusing this:\n  r \\<equiv> run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n  \\<not> sink q\n  configuration q n \\<noteq> {}\n  q' \\<in> set (r n)\n  (?q \\<in> set (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n                  ?n)) =\n  (\\<not> sink ?q \\<and> configuration ?q ?n \\<noteq> {})\n\ngoal (1 subgoal):\n 1. oldest_token q' n \\<noteq> None &&& oldest_token q n \\<noteq> None", "by force+"], ["proof (state)\nthis:\n  oldest_token q' n \\<noteq> None\n  oldest_token q n \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q)\n                     (r n)) \\<Longrightarrow>\n       x \\<in> senior_states q n", "ultimately"], ["proof (chain)\npicking this:\n  q \\<noteq> q'\n  oldest_token q' n \\<noteq> None\n  oldest_token q n \\<noteq> None", "have 4: \"the (oldest_token q' n) \\<noteq> the (oldest_token q n)\""], ["proof (prove)\nusing this:\n  q \\<noteq> q'\n  oldest_token q' n \\<noteq> None\n  oldest_token q n \\<noteq> None\n\ngoal (1 subgoal):\n 1. the (oldest_token q' n) \\<noteq> the (oldest_token q n)", "by (metis oldest_token_equal option.collapse)"], ["proof (state)\nthis:\n  the (oldest_token q' n) \\<noteq> the (oldest_token q n)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (takeWhile (\\<lambda>q'. q' \\<noteq> q)\n                     (r n)) \\<Longrightarrow>\n       x \\<in> senior_states q n", "show \"q' \\<in> senior_states q n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q' \\<in> senior_states q n", "using 1 2 3 4 5 assms"], ["proof (prove)\nusing this:\n  the (oldest_token q' n) \\<le> the (oldest_token q n)\n  oldest_token q' n \\<noteq> None\n  oldest_token q n \\<noteq> None\n  the (oldest_token q' n) \\<noteq> the (oldest_token q n)\n  \\<not> sink q'\n  r \\<equiv> run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n  \\<not> sink q\n  configuration q n \\<noteq> {}\n\ngoal (1 subgoal):\n 1. q' \\<in> senior_states q n", "by fastforce"], ["proof (state)\nthis:\n  q' \\<in> senior_states q n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in semi_mojmir) nxt_run_state_rank:\n  \"state_rank q n = rk (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w n) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_rank q n =\n    rk (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w n) q", "by (cases \"\\<not>sink q \\<and> configuration q n \\<noteq> {}\", unfold state_rank.simps) \n     (metis nxt_run_senior_states rk_split_card_takeWhile nxt_run_distinct nxt_run_configuration, metis nxt_run_configuration rk_facts(1))"], ["", "lemma (in semi_mojmir) nxt_foldl_state_rank:\n  \"state_rank q n = rk (foldl (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) (map w [0..<n])) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_rank q n =\n    rk (foldl (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0)\n         (map w [0..<n]))\n     q", "unfolding nxt_run_state_rank run_foldl"], ["proof (prove)\ngoal (1 subgoal):\n 1. rk (foldl (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0)\n         (map w [0..<n]))\n     q =\n    rk (foldl (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0)\n         (map w [0..<n]))\n     q", ".."], ["", "lemma (in semi_mojmir) nxt_run_step_run:\n  \"run step initial w = rk o (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run step initial w =\n    rk \\<circ> run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w", "using nxt_run_state_rank state_rank_step_foldl[unfolded run_foldl[symmetric]]"], ["proof (prove)\nusing this:\n  state_rank ?q ?n =\n  rk (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w ?n) ?q\n  (\\<lambda>q. state_rank q ?n) = run step initial w ?n\n\ngoal (1 subgoal):\n 1. run step initial w =\n    rk \\<circ> run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w", "unfolding comp_def"], ["proof (prove)\nusing this:\n  state_rank ?q ?n =\n  rk (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w ?n) ?q\n  (\\<lambda>q. state_rank q ?n) = run step initial w ?n\n\ngoal (1 subgoal):\n 1. run step initial w =\n    (\\<lambda>x.\n        rk (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w x))", "by presburger"], ["", "definition (in semi_mojmir_def) Q\\<^sub>E\nwhere\n  \"Q\\<^sub>E \\<equiv> reach \\<Sigma> (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0)\""], ["", "lemma (in semi_mojmir) finite_Q:\n  \"finite Q\\<^sub>E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite Q\\<^sub>E", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite Q\\<^sub>E", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. finite Q\\<^sub>E", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. finite Q\\<^sub>E", "fix w :: \"nat \\<Rightarrow> 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite Q\\<^sub>E", "assume \"range w \\<subseteq> \\<Sigma>\""], ["proof (state)\nthis:\n  range w \\<subseteq> \\<Sigma>\n\ngoal (1 subgoal):\n 1. finite Q\\<^sub>E", "then"], ["proof (chain)\npicking this:\n  range w \\<subseteq> \\<Sigma>", "interpret \\<HH>: semi_mojmir \\<Sigma> \\<delta> q\\<^sub>0 w"], ["proof (prove)\nusing this:\n  range w \\<subseteq> \\<Sigma>\n\ngoal (1 subgoal):\n 1. semi_mojmir \\<Sigma> \\<delta> q\\<^sub>0 w", "using finite_reach finite_\\<Sigma>"], ["proof (prove)\nusing this:\n  range w \\<subseteq> \\<Sigma>\n  finite (reach \\<Sigma> \\<delta> q\\<^sub>0)\n  finite \\<Sigma>\n\ngoal (1 subgoal):\n 1. semi_mojmir \\<Sigma> \\<delta> q\\<^sub>0 w", "by (unfold_locales, blast)"], ["proof (state)\ngoal (1 subgoal):\n 1. finite \\<HH>.Q\\<^sub>E", "have \"set (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w i) \\<subseteq> {\\<HH>.token_run j i | j. j \\<le> i}\" (is \"?S1 \\<subseteq> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w i)\n    \\<subseteq> {\\<HH>.token_run j i |j. j \\<le> i}", "using \\<HH>.nxt_run_configuration"], ["proof (prove)\nusing this:\n  (?q \\<in> set (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n                  ?n)) =\n  (\\<not> \\<HH>.sink ?q \\<and> \\<HH>.configuration ?q ?n \\<noteq> {})\n\ngoal (1 subgoal):\n 1. set (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w i)\n    \\<subseteq> {\\<HH>.token_run j i |j. j \\<le> i}", "by auto"], ["proof (state)\nthis:\n  set (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w i)\n  \\<subseteq> {\\<HH>.token_run j i |j. j \\<le> i}\n\ngoal (1 subgoal):\n 1. finite \\<HH>.Q\\<^sub>E", "also"], ["proof (state)\nthis:\n  set (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w i)\n  \\<subseteq> {\\<HH>.token_run j i |j. j \\<le> i}\n\ngoal (1 subgoal):\n 1. finite \\<HH>.Q\\<^sub>E", "have \"\\<dots> \\<subseteq> reach \\<Sigma> \\<delta> q\\<^sub>0\" (is \"_ \\<subseteq> ?S2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<HH>.token_run j i |j. j \\<le> i}\n    \\<subseteq> reach \\<Sigma> \\<delta> q\\<^sub>0", "unfolding reach_def token_run.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<HH>.token_run j i |j. j \\<le> i}\n    \\<subseteq> {run \\<delta> q\\<^sub>0 w n |w n.\n                 range w \\<subseteq> \\<Sigma>}", "using \\<open>range w \\<subseteq> \\<Sigma>\\<close>"], ["proof (prove)\nusing this:\n  range w \\<subseteq> \\<Sigma>\n\ngoal (1 subgoal):\n 1. {\\<HH>.token_run j i |j. j \\<le> i}\n    \\<subseteq> {run \\<delta> q\\<^sub>0 w n |w n.\n                 range w \\<subseteq> \\<Sigma>}", "by fastforce"], ["proof (state)\nthis:\n  {\\<HH>.token_run j i |j. j \\<le> i}\n  \\<subseteq> reach \\<Sigma> \\<delta> q\\<^sub>0\n\ngoal (1 subgoal):\n 1. finite \\<HH>.Q\\<^sub>E", "finally"], ["proof (chain)\npicking this:\n  set (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w i)\n  \\<subseteq> reach \\<Sigma> \\<delta> q\\<^sub>0", "have \"?S1 \\<subseteq> ?S2\""], ["proof (prove)\nusing this:\n  set (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w i)\n  \\<subseteq> reach \\<Sigma> \\<delta> q\\<^sub>0\n\ngoal (1 subgoal):\n 1. set (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w i)\n    \\<subseteq> reach \\<Sigma> \\<delta> q\\<^sub>0", "."], ["proof (state)\nthis:\n  set (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w i)\n  \\<subseteq> reach \\<Sigma> \\<delta> q\\<^sub>0\n\ngoal (1 subgoal):\n 1. finite \\<HH>.Q\\<^sub>E", "}"], ["proof (state)\nthis:\n  range ?wa2 \\<subseteq> \\<Sigma> \\<Longrightarrow>\n  set (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) ?wa2 ?i2)\n  \\<subseteq> reach \\<Sigma> \\<delta> q\\<^sub>0\n\ngoal (1 subgoal):\n 1. finite Q\\<^sub>E", "hence \"set ` Q\\<^sub>E \\<subseteq> Pow (reach \\<Sigma> \\<delta> q\\<^sub>0)\""], ["proof (prove)\nusing this:\n  range ?wa2 \\<subseteq> \\<Sigma> \\<Longrightarrow>\n  set (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) ?wa2 ?i2)\n  \\<subseteq> reach \\<Sigma> \\<delta> q\\<^sub>0\n\ngoal (1 subgoal):\n 1. set ` Q\\<^sub>E \\<subseteq> Pow (reach \\<Sigma> \\<delta> q\\<^sub>0)", "unfolding Q\\<^sub>E_def reach_def"], ["proof (prove)\nusing this:\n  range ?wa2 \\<subseteq> \\<Sigma> \\<Longrightarrow>\n  set (run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) ?wa2 ?i2)\n  \\<subseteq> {run \\<delta> q\\<^sub>0 w n |w n.\n               range w \\<subseteq> \\<Sigma>}\n\ngoal (1 subgoal):\n 1. set `\n    {run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w n |w n.\n     range w \\<subseteq> \\<Sigma>}\n    \\<subseteq> Pow {run \\<delta> q\\<^sub>0 w n |w n.\n                     range w \\<subseteq> \\<Sigma>}", "by blast"], ["proof (state)\nthis:\n  set ` Q\\<^sub>E \\<subseteq> Pow (reach \\<Sigma> \\<delta> q\\<^sub>0)\n\ngoal (1 subgoal):\n 1. finite Q\\<^sub>E", "hence \"finite (set ` Q\\<^sub>E)\""], ["proof (prove)\nusing this:\n  set ` Q\\<^sub>E \\<subseteq> Pow (reach \\<Sigma> \\<delta> q\\<^sub>0)\n\ngoal (1 subgoal):\n 1. finite (set ` Q\\<^sub>E)", "using finite_reach"], ["proof (prove)\nusing this:\n  set ` Q\\<^sub>E \\<subseteq> Pow (reach \\<Sigma> \\<delta> q\\<^sub>0)\n  finite (reach \\<Sigma> \\<delta> q\\<^sub>0)\n\ngoal (1 subgoal):\n 1. finite (set ` Q\\<^sub>E)", "by (blast dest: finite_subset)"], ["proof (state)\nthis:\n  finite (set ` Q\\<^sub>E)\n\ngoal (1 subgoal):\n 1. finite Q\\<^sub>E", "moreover"], ["proof (state)\nthis:\n  finite (set ` Q\\<^sub>E)\n\ngoal (1 subgoal):\n 1. finite Q\\<^sub>E", "have \"\\<And>xs. xs \\<in> Q\\<^sub>E \\<Longrightarrow> distinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs. xs \\<in> Q\\<^sub>E \\<Longrightarrow> distinct xs", "unfolding Q\\<^sub>E_def reach_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> {run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n                  n |\n                 w n. range w \\<subseteq> \\<Sigma>} \\<Longrightarrow>\n       distinct xs", "using nxt_run_distinct"], ["proof (prove)\nusing this:\n  distinct\n   (run (nxt ?\\<Sigma> ?\\<Delta> ?q\\<^sub>0) (init ?q\\<^sub>0) ?w ?n)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> {run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n                  n |\n                 w n. range w \\<subseteq> \\<Sigma>} \\<Longrightarrow>\n       distinct xs", "by fastforce"], ["proof (state)\nthis:\n  ?xs \\<in> Q\\<^sub>E \\<Longrightarrow> distinct ?xs\n\ngoal (1 subgoal):\n 1. finite Q\\<^sub>E", "ultimately"], ["proof (chain)\npicking this:\n  finite (set ` Q\\<^sub>E)\n  ?xs \\<in> Q\\<^sub>E \\<Longrightarrow> distinct ?xs", "show \"finite Q\\<^sub>E\""], ["proof (prove)\nusing this:\n  finite (set ` Q\\<^sub>E)\n  ?xs \\<in> Q\\<^sub>E \\<Longrightarrow> distinct ?xs\n\ngoal (1 subgoal):\n 1. finite Q\\<^sub>E", "using set_list"], ["proof (prove)\nusing this:\n  finite (set ` Q\\<^sub>E)\n  ?xs \\<in> Q\\<^sub>E \\<Longrightarrow> distinct ?xs\n  \\<lbrakk>finite (set ` ?XS);\n   \\<And>xs. xs \\<in> ?XS \\<Longrightarrow> distinct xs\\<rbrakk>\n  \\<Longrightarrow> finite ?XS\n\ngoal (1 subgoal):\n 1. finite Q\\<^sub>E", "by auto"], ["proof (state)\nthis:\n  finite Q\\<^sub>E\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in mojmir_to_rabin_def) filt_equiv:\n  \"(rk x, \\<nu>, y) \\<in> fail\\<^sub>R \\<longleftrightarrow> fail_filt \\<Sigma> \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) (x, \\<nu>, y')\"\n  \"(rk x, \\<nu>, y) \\<in> succeed\\<^sub>R i \\<longleftrightarrow> succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i (x, \\<nu>, y')\"\n  \"(rk x, \\<nu>, y) \\<in> merge\\<^sub>R i \\<longleftrightarrow> merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i (x, \\<nu>, y')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((rk x, \\<nu>, y) \\<in> fail\\<^sub>R) =\n    fail_filt \\<Sigma> \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F)\n     (x, \\<nu>, y') &&&\n    ((rk x, \\<nu>, y) \\<in> succeed\\<^sub>R i) =\n    succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i\n     (x, \\<nu>, y') &&&\n    ((rk x, \\<nu>, y) \\<in> merge\\<^sub>R i) =\n    merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i (x, \\<nu>, y')", "by (simp add: fail\\<^sub>R_def succeed\\<^sub>R_def merge\\<^sub>R_def del: rk.simps; metis (no_types, lifting) option.sel rk_facts(2))+"], ["", "lemma fail_filt_eq: \n  \"fail_filt \\<Sigma> \\<delta> q\\<^sub>0 P (x, \\<nu>, y) \\<longleftrightarrow> (rk x, \\<nu>, y') \\<in> mojmir_to_rabin_def.fail\\<^sub>R \\<Sigma> \\<delta> q\\<^sub>0 {x. P x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fail_filt \\<Sigma> \\<delta> q\\<^sub>0 P (x, \\<nu>, y) =\n    ((rk x, \\<nu>, y')\n     \\<in> mojmir_to_rabin_def.fail\\<^sub>R \\<Sigma> \\<delta> q\\<^sub>0\n            {x. P x})", "unfolding mojmir_to_rabin_def.filt_equiv(1)[where y' = y]"], ["proof (prove)\ngoal (1 subgoal):\n 1. fail_filt \\<Sigma> \\<delta> q\\<^sub>0 P (x, \\<nu>, y) =\n    fail_filt \\<Sigma> \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> Collect P)\n     (x, \\<nu>, y)", "by simp"], ["", "lemma merge_filt_eq: \n  \"merge_filt \\<delta> q\\<^sub>0 P i (x, \\<nu>, y) \\<longleftrightarrow> (rk x, \\<nu>, y') \\<in> mojmir_to_rabin_def.merge\\<^sub>R \\<delta> q\\<^sub>0 {x. P x} i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_filt \\<delta> q\\<^sub>0 P i (x, \\<nu>, y) =\n    ((rk x, \\<nu>, y')\n     \\<in> mojmir_to_rabin_def.merge\\<^sub>R \\<delta> q\\<^sub>0 {x. P x} i)", "unfolding mojmir_to_rabin_def.filt_equiv(3)[where y' = y]"], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_filt \\<delta> q\\<^sub>0 P i (x, \\<nu>, y) =\n    merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> Collect P) i\n     (x, \\<nu>, y)", "by simp"], ["", "lemma succeed_filt_eq: \n  \"succeed_filt \\<delta> q\\<^sub>0 P i (x, \\<nu>, y) \\<longleftrightarrow> (rk x, \\<nu>, y') \\<in> mojmir_to_rabin_def.succeed\\<^sub>R \\<delta> q\\<^sub>0 {x. P x} i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succeed_filt \\<delta> q\\<^sub>0 P i (x, \\<nu>, y) =\n    ((rk x, \\<nu>, y')\n     \\<in> mojmir_to_rabin_def.succeed\\<^sub>R \\<delta> q\\<^sub>0 {x. P x}\n            i)", "unfolding mojmir_to_rabin_def.filt_equiv(2)[where y' = y]"], ["proof (prove)\ngoal (1 subgoal):\n 1. succeed_filt \\<delta> q\\<^sub>0 P i (x, \\<nu>, y) =\n    succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> Collect P) i\n     (x, \\<nu>, y)", "by simp"], ["", "theorem (in mojmir_to_rabin) rabin_accept_iff_rabin_list_accept_rank:\n  \"accepting_pair\\<^sub>R \\<delta>\\<^sub>\\<R> q\\<^sub>\\<R> (Acc\\<^sub>\\<R> i) w \\<longleftrightarrow> accepting_pair\\<^sub>R (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) ({t. fail_filt \\<Sigma> \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) t} \\<union> {t. merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t}, {t. succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t}) w\"\n  (is \"accepting_pair\\<^sub>R \\<delta>\\<^sub>\\<R> q\\<^sub>\\<R> (?F, ?I) w \\<longleftrightarrow> accepting_pair\\<^sub>R (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) (?F', ?I') w\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. accepting_pair\\<^sub>R \\<delta>\\<^sub>\\<R> q\\<^sub>\\<R>\n     (fail\\<^sub>R \\<union> merge\\<^sub>R i, succeed\\<^sub>R i) w =\n    accepting_pair\\<^sub>R (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n     (init q\\<^sub>0)\n     ({t. fail_filt \\<Sigma> \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F)\n           t} \\<union>\n      {t. merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t},\n      {t. succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t})\n     w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. accepting_pair\\<^sub>R \\<delta>\\<^sub>\\<R> q\\<^sub>\\<R>\n     (fail\\<^sub>R \\<union> merge\\<^sub>R i, succeed\\<^sub>R i) w =\n    accepting_pair\\<^sub>R (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n     (init q\\<^sub>0)\n     ({t. fail_filt \\<Sigma> \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F)\n           t} \\<union>\n      {t. merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t},\n      {t. succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t})\n     w", "have \"finite (reach\\<^sub>t \\<Sigma> \\<delta>\\<^sub>\\<R> q\\<^sub>\\<R>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (reach\\<^sub>t \\<Sigma> \\<delta>\\<^sub>\\<R> q\\<^sub>\\<R>)", "using wellformed_\\<R> finite_\\<Sigma> finite_reach\\<^sub>t"], ["proof (prove)\nusing this:\n  finite Q\\<^sub>R\n  finite \\<Sigma>\n  \\<lbrakk>finite (reach ?\\<Sigma> ?\\<delta> ?q\\<^sub>0);\n   finite ?\\<Sigma>\\<rbrakk>\n  \\<Longrightarrow> finite (reach\\<^sub>t ?\\<Sigma> ?\\<delta> ?q\\<^sub>0)\n\ngoal (1 subgoal):\n 1. finite (reach\\<^sub>t \\<Sigma> \\<delta>\\<^sub>\\<R> q\\<^sub>\\<R>)", "by fast"], ["proof (state)\nthis:\n  finite (reach\\<^sub>t \\<Sigma> \\<delta>\\<^sub>\\<R> q\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. accepting_pair\\<^sub>R \\<delta>\\<^sub>\\<R> q\\<^sub>\\<R>\n     (fail\\<^sub>R \\<union> merge\\<^sub>R i, succeed\\<^sub>R i) w =\n    accepting_pair\\<^sub>R (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n     (init q\\<^sub>0)\n     ({t. fail_filt \\<Sigma> \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F)\n           t} \\<union>\n      {t. merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t},\n      {t. succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t})\n     w", "moreover"], ["proof (state)\nthis:\n  finite (reach\\<^sub>t \\<Sigma> \\<delta>\\<^sub>\\<R> q\\<^sub>\\<R>)\n\ngoal (1 subgoal):\n 1. accepting_pair\\<^sub>R \\<delta>\\<^sub>\\<R> q\\<^sub>\\<R>\n     (fail\\<^sub>R \\<union> merge\\<^sub>R i, succeed\\<^sub>R i) w =\n    accepting_pair\\<^sub>R (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n     (init q\\<^sub>0)\n     ({t. fail_filt \\<Sigma> \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F)\n           t} \\<union>\n      {t. merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t},\n      {t. succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t})\n     w", "have \"finite (reach\\<^sub>t \\<Sigma> (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (reach\\<^sub>t \\<Sigma> (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n       (init q\\<^sub>0))", "using finite_Q finite_\\<Sigma> finite_reach\\<^sub>t"], ["proof (prove)\nusing this:\n  finite Q\\<^sub>E\n  finite \\<Sigma>\n  \\<lbrakk>finite (reach ?\\<Sigma> ?\\<delta> ?q\\<^sub>0);\n   finite ?\\<Sigma>\\<rbrakk>\n  \\<Longrightarrow> finite (reach\\<^sub>t ?\\<Sigma> ?\\<delta> ?q\\<^sub>0)\n\ngoal (1 subgoal):\n 1. finite\n     (reach\\<^sub>t \\<Sigma> (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n       (init q\\<^sub>0))", "by (auto simp add: Q\\<^sub>E_def)"], ["proof (state)\nthis:\n  finite\n   (reach\\<^sub>t \\<Sigma> (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n     (init q\\<^sub>0))\n\ngoal (1 subgoal):\n 1. accepting_pair\\<^sub>R \\<delta>\\<^sub>\\<R> q\\<^sub>\\<R>\n     (fail\\<^sub>R \\<union> merge\\<^sub>R i, succeed\\<^sub>R i) w =\n    accepting_pair\\<^sub>R (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n     (init q\\<^sub>0)\n     ({t. fail_filt \\<Sigma> \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F)\n           t} \\<union>\n      {t. merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t},\n      {t. succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t})\n     w", "moreover"], ["proof (state)\nthis:\n  finite\n   (reach\\<^sub>t \\<Sigma> (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n     (init q\\<^sub>0))\n\ngoal (1 subgoal):\n 1. accepting_pair\\<^sub>R \\<delta>\\<^sub>\\<R> q\\<^sub>\\<R>\n     (fail\\<^sub>R \\<union> merge\\<^sub>R i, succeed\\<^sub>R i) w =\n    accepting_pair\\<^sub>R (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n     (init q\\<^sub>0)\n     ({t. fail_filt \\<Sigma> \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F)\n           t} \\<union>\n      {t. merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t},\n      {t. succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t})\n     w", "have \"run\\<^sub>t step initial w = (\\<lambda>(x, \\<nu>, y). (rk x, \\<nu>, rk y)) o (run\\<^sub>t (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run\\<^sub>t \\<delta>\\<^sub>\\<R> q\\<^sub>\\<R> w =\n    (\\<lambda>(x, \\<nu>, y). (rk x, \\<nu>, rk y)) \\<circ>\n    run\\<^sub>t (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w", "using nxt_run_step_run"], ["proof (prove)\nusing this:\n  run \\<delta>\\<^sub>\\<R> q\\<^sub>\\<R> w =\n  rk \\<circ> run (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n\ngoal (1 subgoal):\n 1. run\\<^sub>t \\<delta>\\<^sub>\\<R> q\\<^sub>\\<R> w =\n    (\\<lambda>(x, \\<nu>, y). (rk x, \\<nu>, rk y)) \\<circ>\n    run\\<^sub>t (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w", "by auto"], ["proof (state)\nthis:\n  run\\<^sub>t \\<delta>\\<^sub>\\<R> q\\<^sub>\\<R> w =\n  (\\<lambda>(x, \\<nu>, y). (rk x, \\<nu>, rk y)) \\<circ>\n  run\\<^sub>t (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n\ngoal (1 subgoal):\n 1. accepting_pair\\<^sub>R \\<delta>\\<^sub>\\<R> q\\<^sub>\\<R>\n     (fail\\<^sub>R \\<union> merge\\<^sub>R i, succeed\\<^sub>R i) w =\n    accepting_pair\\<^sub>R (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n     (init q\\<^sub>0)\n     ({t. fail_filt \\<Sigma> \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F)\n           t} \\<union>\n      {t. merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t},\n      {t. succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t})\n     w", "moreover"], ["proof (state)\nthis:\n  run\\<^sub>t \\<delta>\\<^sub>\\<R> q\\<^sub>\\<R> w =\n  (\\<lambda>(x, \\<nu>, y). (rk x, \\<nu>, rk y)) \\<circ>\n  run\\<^sub>t (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n\ngoal (1 subgoal):\n 1. accepting_pair\\<^sub>R \\<delta>\\<^sub>\\<R> q\\<^sub>\\<R>\n     (fail\\<^sub>R \\<union> merge\\<^sub>R i, succeed\\<^sub>R i) w =\n    accepting_pair\\<^sub>R (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n     (init q\\<^sub>0)\n     ({t. fail_filt \\<Sigma> \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F)\n           t} \\<union>\n      {t. merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t},\n      {t. succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t})\n     w", "note bounded_w filt_equiv"], ["proof (state)\nthis:\n  range w \\<subseteq> \\<Sigma>\n  ((rk ?x, ?\\<nu>, ?y) \\<in> fail\\<^sub>R) =\n  fail_filt \\<Sigma> \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F)\n   (?x, ?\\<nu>, ?y')\n  ((rk ?x, ?\\<nu>, ?y) \\<in> succeed\\<^sub>R ?i) =\n  succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) ?i\n   (?x, ?\\<nu>, ?y')\n  ((rk ?x, ?\\<nu>, ?y) \\<in> merge\\<^sub>R ?i) =\n  merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) ?i (?x, ?\\<nu>, ?y')\n\ngoal (1 subgoal):\n 1. accepting_pair\\<^sub>R \\<delta>\\<^sub>\\<R> q\\<^sub>\\<R>\n     (fail\\<^sub>R \\<union> merge\\<^sub>R i, succeed\\<^sub>R i) w =\n    accepting_pair\\<^sub>R (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n     (init q\\<^sub>0)\n     ({t. fail_filt \\<Sigma> \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F)\n           t} \\<union>\n      {t. merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t},\n      {t. succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t})\n     w", "ultimately"], ["proof (chain)\npicking this:\n  finite (reach\\<^sub>t \\<Sigma> \\<delta>\\<^sub>\\<R> q\\<^sub>\\<R>)\n  finite\n   (reach\\<^sub>t \\<Sigma> (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n     (init q\\<^sub>0))\n  run\\<^sub>t \\<delta>\\<^sub>\\<R> q\\<^sub>\\<R> w =\n  (\\<lambda>(x, \\<nu>, y). (rk x, \\<nu>, rk y)) \\<circ>\n  run\\<^sub>t (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n  range w \\<subseteq> \\<Sigma>\n  ((rk ?x, ?\\<nu>, ?y) \\<in> fail\\<^sub>R) =\n  fail_filt \\<Sigma> \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F)\n   (?x, ?\\<nu>, ?y')\n  ((rk ?x, ?\\<nu>, ?y) \\<in> succeed\\<^sub>R ?i) =\n  succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) ?i\n   (?x, ?\\<nu>, ?y')\n  ((rk ?x, ?\\<nu>, ?y) \\<in> merge\\<^sub>R ?i) =\n  merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) ?i (?x, ?\\<nu>, ?y')", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (reach\\<^sub>t \\<Sigma> \\<delta>\\<^sub>\\<R> q\\<^sub>\\<R>)\n  finite\n   (reach\\<^sub>t \\<Sigma> (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n     (init q\\<^sub>0))\n  run\\<^sub>t \\<delta>\\<^sub>\\<R> q\\<^sub>\\<R> w =\n  (\\<lambda>(x, \\<nu>, y). (rk x, \\<nu>, rk y)) \\<circ>\n  run\\<^sub>t (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0) w\n  range w \\<subseteq> \\<Sigma>\n  ((rk ?x, ?\\<nu>, ?y) \\<in> fail\\<^sub>R) =\n  fail_filt \\<Sigma> \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F)\n   (?x, ?\\<nu>, ?y')\n  ((rk ?x, ?\\<nu>, ?y) \\<in> succeed\\<^sub>R ?i) =\n  succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) ?i\n   (?x, ?\\<nu>, ?y')\n  ((rk ?x, ?\\<nu>, ?y) \\<in> merge\\<^sub>R ?i) =\n  merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) ?i (?x, ?\\<nu>, ?y')\n\ngoal (1 subgoal):\n 1. accepting_pair\\<^sub>R \\<delta>\\<^sub>\\<R> q\\<^sub>\\<R>\n     (fail\\<^sub>R \\<union> merge\\<^sub>R i, succeed\\<^sub>R i) w =\n    accepting_pair\\<^sub>R (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n     (init q\\<^sub>0)\n     ({t. fail_filt \\<Sigma> \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F)\n           t} \\<union>\n      {t. merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t},\n      {t. succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t})\n     w", "by (intro accepting_pair\\<^sub>R_abstract) auto"], ["proof (state)\nthis:\n  accepting_pair\\<^sub>R \\<delta>\\<^sub>\\<R> q\\<^sub>\\<R>\n   (fail\\<^sub>R \\<union> merge\\<^sub>R i, succeed\\<^sub>R i) w =\n  accepting_pair\\<^sub>R (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0)\n   ({t. fail_filt \\<Sigma> \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F)\n         t} \\<union>\n    {t. merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t},\n    {t. succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t})\n   w\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Compute Rabin Automata List Representation\\<close>"], ["", "fun mojmir_to_rabin_exec\nwhere\n  \"mojmir_to_rabin_exec \\<Sigma> \\<delta> q\\<^sub>0 F = (\n    let \n      q\\<^sub>0' = init q\\<^sub>0;\n      \\<delta>' = \\<delta>\\<^sub>L \\<Sigma> (nxt (set \\<Sigma>) \\<delta> q\\<^sub>0) q\\<^sub>0';\n      max_rank = card (Set.filter (Not o semi_mojmir_def.sink (set \\<Sigma>) \\<delta> q\\<^sub>0) (Q\\<^sub>L \\<Sigma> \\<delta> q\\<^sub>0));\n      fail = Set.filter (fail_filt (set \\<Sigma>) \\<delta> q\\<^sub>0 F) \\<delta>';\n      merge = (\\<lambda>i. Set.filter (merge_filt \\<delta> q\\<^sub>0 F i) \\<delta>');\n      succeed = (\\<lambda>i. Set.filter (succeed_filt \\<delta> q\\<^sub>0 F i) \\<delta>')\n    in\n      (\\<delta>', q\\<^sub>0', (\\<lambda>i. (fail \\<union> (merge i), succeed i)) ` {0..<max_rank}))\""], ["", "subsection \\<open>Code Generation\\<close>\n\n\\<comment> \\<open>Setup missing equations for code generator\\<close>"], ["", "declare semi_mojmir_def.sink_def [code]\n\n\\<comment> \\<open>Drop computation of length by different code equation\\<close>"], ["", "fun index_option ::  \"nat \\<Rightarrow> 'a list \\<Rightarrow> 'a \\<Rightarrow> nat option\"\nwhere\n  \"index_option n [] y = None\"\n| \"index_option n (x # xs) y = (if x = y then Some n else index_option (Suc n) xs y)\""], ["", "declare rk.simps [code del]"], ["", "lemma rk_eq_index_option [code]:\n  \"rk xs x = index_option 0 xs x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rk xs x = index_option 0 xs x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rk xs x = index_option 0 xs x", "have A: \"\\<And>n. x \\<in> set xs \\<Longrightarrow> index xs x + n = the (index_option n xs x)\"\n   and B: \"\\<And>n. x \\<notin> set xs \\<longleftrightarrow> index_option n xs x = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        x \\<in> set xs \\<Longrightarrow>\n        List_Index.index xs x + n = the (index_option n xs x)) &&&\n    (\\<And>n. (x \\<notin> set xs) = (index_option n xs x = None))", "by (induction xs) (auto, metis add_Suc_right)"], ["proof (state)\nthis:\n  x \\<in> set xs \\<Longrightarrow>\n  List_Index.index xs x + ?n = the (index_option ?n xs x)\n  (x \\<notin> set xs) = (index_option ?n xs x = None)\n\ngoal (1 subgoal):\n 1. rk xs x = index_option 0 xs x", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> set xs \\<Longrightarrow>\n  List_Index.index xs x + ?n = the (index_option ?n xs x)\n  (x \\<notin> set xs) = (index_option ?n xs x = None)\n\ngoal (1 subgoal):\n 1. rk xs x = index_option 0 xs x", "proof (cases \"x \\<in> set xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>n.\n                x \\<in> set xs \\<Longrightarrow>\n                List_Index.index xs x + n = the (index_option n xs x);\n     \\<And>n. (x \\<notin> set xs) = (index_option n xs x = None);\n     x \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> rk xs x = index_option 0 xs x\n 2. \\<lbrakk>\\<And>n.\n                x \\<in> set xs \\<Longrightarrow>\n                List_Index.index xs x + n = the (index_option n xs x);\n     \\<And>n. (x \\<notin> set xs) = (index_option n xs x = None);\n     x \\<notin> set xs\\<rbrakk>\n    \\<Longrightarrow> rk xs x = index_option 0 xs x", "case True"], ["proof (state)\nthis:\n  x \\<in> set xs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>n.\n                x \\<in> set xs \\<Longrightarrow>\n                List_Index.index xs x + n = the (index_option n xs x);\n     \\<And>n. (x \\<notin> set xs) = (index_option n xs x = None);\n     x \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> rk xs x = index_option 0 xs x\n 2. \\<lbrakk>\\<And>n.\n                x \\<in> set xs \\<Longrightarrow>\n                List_Index.index xs x + n = the (index_option n xs x);\n     \\<And>n. (x \\<notin> set xs) = (index_option n xs x = None);\n     x \\<notin> set xs\\<rbrakk>\n    \\<Longrightarrow> rk xs x = index_option 0 xs x", "moreover"], ["proof (state)\nthis:\n  x \\<in> set xs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>n.\n                x \\<in> set xs \\<Longrightarrow>\n                List_Index.index xs x + n = the (index_option n xs x);\n     \\<And>n. (x \\<notin> set xs) = (index_option n xs x = None);\n     x \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> rk xs x = index_option 0 xs x\n 2. \\<lbrakk>\\<And>n.\n                x \\<in> set xs \\<Longrightarrow>\n                List_Index.index xs x + n = the (index_option n xs x);\n     \\<And>n. (x \\<notin> set xs) = (index_option n xs x = None);\n     x \\<notin> set xs\\<rbrakk>\n    \\<Longrightarrow> rk xs x = index_option 0 xs x", "hence \"index xs x = the (index_option 0 xs x)\""], ["proof (prove)\nusing this:\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. List_Index.index xs x = the (index_option 0 xs x)", "using A[OF True, of 0]"], ["proof (prove)\nusing this:\n  x \\<in> set xs\n  List_Index.index xs x + 0 = the (index_option 0 xs x)\n\ngoal (1 subgoal):\n 1. List_Index.index xs x = the (index_option 0 xs x)", "by simp"], ["proof (state)\nthis:\n  List_Index.index xs x = the (index_option 0 xs x)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>n.\n                x \\<in> set xs \\<Longrightarrow>\n                List_Index.index xs x + n = the (index_option n xs x);\n     \\<And>n. (x \\<notin> set xs) = (index_option n xs x = None);\n     x \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> rk xs x = index_option 0 xs x\n 2. \\<lbrakk>\\<And>n.\n                x \\<in> set xs \\<Longrightarrow>\n                List_Index.index xs x + n = the (index_option n xs x);\n     \\<And>n. (x \\<notin> set xs) = (index_option n xs x = None);\n     x \\<notin> set xs\\<rbrakk>\n    \\<Longrightarrow> rk xs x = index_option 0 xs x", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> set xs\n  List_Index.index xs x = the (index_option 0 xs x)", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> set xs\n  List_Index.index xs x = the (index_option 0 xs x)\n\ngoal (1 subgoal):\n 1. rk xs x = index_option 0 xs x", "unfolding rk.simps"], ["proof (prove)\nusing this:\n  x \\<in> set xs\n  List_Index.index xs x = the (index_option 0 xs x)\n\ngoal (1 subgoal):\n 1. (let i = List_Index.index xs x\n     in if i \\<noteq> length xs then Some i else None) =\n    index_option 0 xs x", "by (metis (mono_tags, lifting) B True index_less_size_conv less_irrefl option.collapse)"], ["proof (state)\nthis:\n  rk xs x = index_option 0 xs x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n.\n                x \\<in> set xs \\<Longrightarrow>\n                List_Index.index xs x + n = the (index_option n xs x);\n     \\<And>n. (x \\<notin> set xs) = (index_option n xs x = None);\n     x \\<notin> set xs\\<rbrakk>\n    \\<Longrightarrow> rk xs x = index_option 0 xs x", "qed simp"], ["proof (state)\nthis:\n  rk xs x = index_option 0 xs x\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open>Check Code Export\\<close>"], ["", "export_code init nxt fail_filt succeed_filt merge_filt mojmir_to_rabin_exec checking"], ["", "lemma (in mojmir) max_rank_card:\n  assumes \"\\<Sigma> = set \\<Sigma>'\"\n  shows \"max_rank = card (Set.filter (Not o semi_mojmir_def.sink (set \\<Sigma>') \\<delta> q\\<^sub>0) (Q\\<^sub>L \\<Sigma>' \\<delta> q\\<^sub>0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_rank =\n    card\n     (Set.filter\n       (Not \\<circ> semi_mojmir_def.sink (set \\<Sigma>') \\<delta> q\\<^sub>0)\n       (Q\\<^sub>L \\<Sigma>' \\<delta> q\\<^sub>0))", "unfolding max_rank_def Q\\<^sub>L_reach[OF finite_reach[unfolded \\<open>\\<Sigma> = set \\<Sigma>'\\<close>]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (reach \\<Sigma> \\<delta> q\\<^sub>0 - Collect sink) =\n    card\n     (Set.filter\n       (Not \\<circ> semi_mojmir_def.sink (set \\<Sigma>') \\<delta> q\\<^sub>0)\n       (reach (set \\<Sigma>') \\<delta> q\\<^sub>0))", "by (simp add: Set.filter_def set_diff_eq assms(1))"], ["", "theorem (in mojmir_to_rabin) exec_correct:\n  assumes \"\\<Sigma> = set \\<Sigma>'\"\n  shows \"accept \\<longleftrightarrow> accept\\<^sub>R_LTS (mojmir_to_rabin_exec \\<Sigma>' \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F)) w\" (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. accept\\<^sub>M =\n    accept\\<^sub>R_LTS\n     (mojmir_to_rabin_exec \\<Sigma>' \\<delta> q\\<^sub>0\n       (\\<lambda>x. x \\<in> F))\n     w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. accept\\<^sub>M =\n    accept\\<^sub>R_LTS\n     (mojmir_to_rabin_exec \\<Sigma>' \\<delta> q\\<^sub>0\n       (\\<lambda>x. x \\<in> F))\n     w", "have F1: \"finite (reach \\<Sigma> (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (reach \\<Sigma> (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0))", "using finite_Q"], ["proof (prove)\nusing this:\n  finite Q\\<^sub>E\n\ngoal (1 subgoal):\n 1. finite\n     (reach \\<Sigma> (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0))", "by (simp add: Q\\<^sub>E_def)"], ["proof (state)\nthis:\n  finite (reach \\<Sigma> (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0))\n\ngoal (1 subgoal):\n 1. accept\\<^sub>M =\n    accept\\<^sub>R_LTS\n     (mojmir_to_rabin_exec \\<Sigma>' \\<delta> q\\<^sub>0\n       (\\<lambda>x. x \\<in> F))\n     w", "hence F2: \"finite (reach\\<^sub>t \\<Sigma> (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0))\""], ["proof (prove)\nusing this:\n  finite (reach \\<Sigma> (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0))\n\ngoal (1 subgoal):\n 1. finite\n     (reach\\<^sub>t \\<Sigma> (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n       (init q\\<^sub>0))", "using finite_\\<Sigma>"], ["proof (prove)\nusing this:\n  finite (reach \\<Sigma> (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0))\n  finite \\<Sigma>\n\ngoal (1 subgoal):\n 1. finite\n     (reach\\<^sub>t \\<Sigma> (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n       (init q\\<^sub>0))", "by (rule finite_reach\\<^sub>t)"], ["proof (state)\nthis:\n  finite\n   (reach\\<^sub>t \\<Sigma> (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n     (init q\\<^sub>0))\n\ngoal (1 subgoal):\n 1. accept\\<^sub>M =\n    accept\\<^sub>R_LTS\n     (mojmir_to_rabin_exec \\<Sigma>' \\<delta> q\\<^sub>0\n       (\\<lambda>x. x \\<in> F))\n     w", "let ?\\<delta>' = \"\\<delta>\\<^sub>L \\<Sigma>' (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. accept\\<^sub>M =\n    accept\\<^sub>R_LTS\n     (mojmir_to_rabin_exec \\<Sigma>' \\<delta> q\\<^sub>0\n       (\\<lambda>x. x \\<in> F))\n     w", "have \\<delta>'_Def: \"?\\<delta>' = reach\\<^sub>t \\<Sigma> (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>L \\<Sigma>' (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n     (init q\\<^sub>0) =\n    reach\\<^sub>t \\<Sigma> (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n     (init q\\<^sub>0)", "using \\<delta>\\<^sub>L_reach[OF F2[unfolded assms]]"], ["proof (prove)\nusing this:\n  \\<delta>\\<^sub>L \\<Sigma>' (nxt (set \\<Sigma>') \\<delta> q\\<^sub>0)\n   (init q\\<^sub>0) =\n  reach\\<^sub>t (set \\<Sigma>') (nxt (set \\<Sigma>') \\<delta> q\\<^sub>0)\n   (init q\\<^sub>0)\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>L \\<Sigma>' (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n     (init q\\<^sub>0) =\n    reach\\<^sub>t \\<Sigma> (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n     (init q\\<^sub>0)", "unfolding  assms"], ["proof (prove)\nusing this:\n  \\<delta>\\<^sub>L \\<Sigma>' (nxt (set \\<Sigma>') \\<delta> q\\<^sub>0)\n   (init q\\<^sub>0) =\n  reach\\<^sub>t (set \\<Sigma>') (nxt (set \\<Sigma>') \\<delta> q\\<^sub>0)\n   (init q\\<^sub>0)\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>L \\<Sigma>' (nxt (set \\<Sigma>') \\<delta> q\\<^sub>0)\n     (init q\\<^sub>0) =\n    reach\\<^sub>t (set \\<Sigma>') (nxt (set \\<Sigma>') \\<delta> q\\<^sub>0)\n     (init q\\<^sub>0)", "by simp"], ["proof (state)\nthis:\n  \\<delta>\\<^sub>L \\<Sigma>' (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n   (init q\\<^sub>0) =\n  reach\\<^sub>t \\<Sigma> (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0)\n\ngoal (1 subgoal):\n 1. accept\\<^sub>M =\n    accept\\<^sub>R_LTS\n     (mojmir_to_rabin_exec \\<Sigma>' \\<delta> q\\<^sub>0\n       (\\<lambda>x. x \\<in> F))\n     w", "have 3: \"snd (snd ((mojmir_to_rabin_exec \\<Sigma>' \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F)))) \n    = {(({t. fail_filt \\<Sigma> \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) t} \\<union> {t. merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t}) \\<inter> reach\\<^sub>t \\<Sigma> (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0), \n        {t. succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t}  \\<inter> reach\\<^sub>t \\<Sigma> (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0)) | i. i < max_rank}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (snd (mojmir_to_rabin_exec \\<Sigma>' \\<delta> q\\<^sub>0\n               (\\<lambda>x. x \\<in> F))) =\n    {(({t. fail_filt \\<Sigma> \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F)\n            t} \\<union>\n       {t. merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i\n            t}) \\<inter>\n      reach\\<^sub>t \\<Sigma> (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n       (init q\\<^sub>0),\n      {t. succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i\n           t} \\<inter>\n      reach\\<^sub>t \\<Sigma> (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n       (init q\\<^sub>0)) |\n     i. i < max_rank}", "unfolding assms mojmir_to_rabin_exec.simps Let_def fst_conv snd_conv set_map \\<delta>'_Def[unfolded assms] max_rank_card[OF assms, symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i.\n        (Set.filter\n          (fail_filt (set \\<Sigma>') \\<delta> q\\<^sub>0\n            (\\<lambda>x. x \\<in> F))\n          (reach\\<^sub>t (set \\<Sigma>')\n            (nxt (set \\<Sigma>') \\<delta> q\\<^sub>0)\n            (init q\\<^sub>0)) \\<union>\n         Set.filter\n          (merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i)\n          (reach\\<^sub>t (set \\<Sigma>')\n            (nxt (set \\<Sigma>') \\<delta> q\\<^sub>0) (init q\\<^sub>0)),\n         Set.filter\n          (succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i)\n          (reach\\<^sub>t (set \\<Sigma>')\n            (nxt (set \\<Sigma>') \\<delta> q\\<^sub>0) (init q\\<^sub>0)))) `\n    {0..<semi_mojmir_def.max_rank (set \\<Sigma>') \\<delta> q\\<^sub>0} =\n    {(({t. fail_filt (set \\<Sigma>') \\<delta> q\\<^sub>0\n            (\\<lambda>x. x \\<in> F) t} \\<union>\n       {t. merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i\n            t}) \\<inter>\n      reach\\<^sub>t (set \\<Sigma>') (nxt (set \\<Sigma>') \\<delta> q\\<^sub>0)\n       (init q\\<^sub>0),\n      {t. succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i\n           t} \\<inter>\n      reach\\<^sub>t (set \\<Sigma>') (nxt (set \\<Sigma>') \\<delta> q\\<^sub>0)\n       (init q\\<^sub>0)) |\n     i. i < semi_mojmir_def.max_rank (set \\<Sigma>') \\<delta> q\\<^sub>0}", "unfolding assms[symmetric] Set.filter_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i.\n        ({a \\<in> reach\\<^sub>t \\<Sigma> (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n                   (init q\\<^sub>0).\n          fail_filt \\<Sigma> \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F)\n           a} \\<union>\n         {a \\<in> reach\\<^sub>t \\<Sigma> (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n                   (init q\\<^sub>0).\n          merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i a},\n         {a \\<in> reach\\<^sub>t \\<Sigma> (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n                   (init q\\<^sub>0).\n          succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i a})) `\n    {0..<max_rank} =\n    {(({t. fail_filt \\<Sigma> \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F)\n            t} \\<union>\n       {t. merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i\n            t}) \\<inter>\n      reach\\<^sub>t \\<Sigma> (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n       (init q\\<^sub>0),\n      {t. succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i\n           t} \\<inter>\n      reach\\<^sub>t \\<Sigma> (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n       (init q\\<^sub>0)) |\n     i. i < max_rank}", "by auto"], ["proof (state)\nthis:\n  snd (snd (mojmir_to_rabin_exec \\<Sigma>' \\<delta> q\\<^sub>0\n             (\\<lambda>x. x \\<in> F))) =\n  {(({t. fail_filt \\<Sigma> \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F)\n          t} \\<union>\n     {t. merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i\n          t}) \\<inter>\n    reach\\<^sub>t \\<Sigma> (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n     (init q\\<^sub>0),\n    {t. succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i\n         t} \\<inter>\n    reach\\<^sub>t \\<Sigma> (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n     (init q\\<^sub>0)) |\n   i. i < max_rank}\n\ngoal (1 subgoal):\n 1. accept\\<^sub>M =\n    accept\\<^sub>R_LTS\n     (mojmir_to_rabin_exec \\<Sigma>' \\<delta> q\\<^sub>0\n       (\\<lambda>x. x \\<in> F))\n     w", "have \"?lhs \\<longleftrightarrow> accept\\<^sub>R (\\<delta>\\<^sub>\\<R>, q\\<^sub>\\<R>, {(Acc\\<^sub>\\<R> i) | i. i < max_rank}) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. accept\\<^sub>M =\n    accept\\<^sub>R\n     (\\<delta>\\<^sub>\\<R>, q\\<^sub>\\<R>,\n      {(fail\\<^sub>R \\<union> merge\\<^sub>R i, succeed\\<^sub>R i) |i.\n       i < max_rank})\n     w", "using mojmir_accept_iff_rabin_accept"], ["proof (prove)\nusing this:\n  accept\\<^sub>M =\n  accept\\<^sub>R\n   (\\<delta>\\<^sub>\\<R>, q\\<^sub>\\<R>,\n    {(fail\\<^sub>R \\<union> merge\\<^sub>R j, succeed\\<^sub>R j) |j.\n     j < max_rank})\n   w\n\ngoal (1 subgoal):\n 1. accept\\<^sub>M =\n    accept\\<^sub>R\n     (\\<delta>\\<^sub>\\<R>, q\\<^sub>\\<R>,\n      {(fail\\<^sub>R \\<union> merge\\<^sub>R i, succeed\\<^sub>R i) |i.\n       i < max_rank})\n     w", "by blast"], ["proof (state)\nthis:\n  accept\\<^sub>M =\n  accept\\<^sub>R\n   (\\<delta>\\<^sub>\\<R>, q\\<^sub>\\<R>,\n    {(fail\\<^sub>R \\<union> merge\\<^sub>R i, succeed\\<^sub>R i) |i.\n     i < max_rank})\n   w\n\ngoal (1 subgoal):\n 1. accept\\<^sub>M =\n    accept\\<^sub>R_LTS\n     (mojmir_to_rabin_exec \\<Sigma>' \\<delta> q\\<^sub>0\n       (\\<lambda>x. x \\<in> F))\n     w", "moreover"], ["proof (state)\nthis:\n  accept\\<^sub>M =\n  accept\\<^sub>R\n   (\\<delta>\\<^sub>\\<R>, q\\<^sub>\\<R>,\n    {(fail\\<^sub>R \\<union> merge\\<^sub>R i, succeed\\<^sub>R i) |i.\n     i < max_rank})\n   w\n\ngoal (1 subgoal):\n 1. accept\\<^sub>M =\n    accept\\<^sub>R_LTS\n     (mojmir_to_rabin_exec \\<Sigma>' \\<delta> q\\<^sub>0\n       (\\<lambda>x. x \\<in> F))\n     w", "have \"\\<dots> \\<longleftrightarrow> accept\\<^sub>R (nxt \\<Sigma> \\<delta> q\\<^sub>0, init q\\<^sub>0, {({t. fail_filt \\<Sigma> \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) t} \\<union> {t. merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t}, {t. succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t}) | i. i < max_rank}) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. accept\\<^sub>R\n     (\\<delta>\\<^sub>\\<R>, q\\<^sub>\\<R>,\n      {(fail\\<^sub>R \\<union> merge\\<^sub>R i, succeed\\<^sub>R i) |i.\n       i < max_rank})\n     w =\n    accept\\<^sub>R\n     (nxt \\<Sigma> \\<delta> q\\<^sub>0, init q\\<^sub>0,\n      {({t. fail_filt \\<Sigma> \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F)\n             t} \\<union>\n        {t. merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t},\n        {t. succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t}) |\n       i. i < max_rank})\n     w", "unfolding accept\\<^sub>R_def fst_conv snd_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>P\\<in>{(fail\\<^sub>R \\<union> merge\\<^sub>R i,\n                      succeed\\<^sub>R i) |\n                     i. i < max_rank}.\n        accepting_pair\\<^sub>R \\<delta>\\<^sub>\\<R> q\\<^sub>\\<R> P w) =\n    (\\<exists>P\\<in>{(Collect\n                       (fail_filt \\<Sigma> \\<delta> q\\<^sub>0\n                         (\\<lambda>x. x \\<in> F)) \\<union>\n                      Collect\n                       (merge_filt \\<delta> q\\<^sub>0\n                         (\\<lambda>x. x \\<in> F) i),\n                      Collect\n                       (succeed_filt \\<delta> q\\<^sub>0\n                         (\\<lambda>x. x \\<in> F) i)) |\n                     i. i < max_rank}.\n        accepting_pair\\<^sub>R (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n         (init q\\<^sub>0) P w)", "using rabin_accept_iff_rabin_list_accept_rank"], ["proof (prove)\nusing this:\n  accepting_pair\\<^sub>R \\<delta>\\<^sub>\\<R> q\\<^sub>\\<R>\n   (fail\\<^sub>R \\<union> merge\\<^sub>R ?i, succeed\\<^sub>R ?i) w =\n  accepting_pair\\<^sub>R (nxt \\<Sigma> \\<delta> q\\<^sub>0) (init q\\<^sub>0)\n   ({t. fail_filt \\<Sigma> \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F)\n         t} \\<union>\n    {t. merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) ?i t},\n    {t. succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) ?i t})\n   w\n\ngoal (1 subgoal):\n 1. (\\<exists>P\\<in>{(fail\\<^sub>R \\<union> merge\\<^sub>R i,\n                      succeed\\<^sub>R i) |\n                     i. i < max_rank}.\n        accepting_pair\\<^sub>R \\<delta>\\<^sub>\\<R> q\\<^sub>\\<R> P w) =\n    (\\<exists>P\\<in>{(Collect\n                       (fail_filt \\<Sigma> \\<delta> q\\<^sub>0\n                         (\\<lambda>x. x \\<in> F)) \\<union>\n                      Collect\n                       (merge_filt \\<delta> q\\<^sub>0\n                         (\\<lambda>x. x \\<in> F) i),\n                      Collect\n                       (succeed_filt \\<delta> q\\<^sub>0\n                         (\\<lambda>x. x \\<in> F) i)) |\n                     i. i < max_rank}.\n        accepting_pair\\<^sub>R (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n         (init q\\<^sub>0) P w)", "by blast"], ["proof (state)\nthis:\n  accept\\<^sub>R\n   (\\<delta>\\<^sub>\\<R>, q\\<^sub>\\<R>,\n    {(fail\\<^sub>R \\<union> merge\\<^sub>R i, succeed\\<^sub>R i) |i.\n     i < max_rank})\n   w =\n  accept\\<^sub>R\n   (nxt \\<Sigma> \\<delta> q\\<^sub>0, init q\\<^sub>0,\n    {({t. fail_filt \\<Sigma> \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F)\n           t} \\<union>\n      {t. merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t},\n      {t. succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t}) |\n     i. i < max_rank})\n   w\n\ngoal (1 subgoal):\n 1. accept\\<^sub>M =\n    accept\\<^sub>R_LTS\n     (mojmir_to_rabin_exec \\<Sigma>' \\<delta> q\\<^sub>0\n       (\\<lambda>x. x \\<in> F))\n     w", "moreover"], ["proof (state)\nthis:\n  accept\\<^sub>R\n   (\\<delta>\\<^sub>\\<R>, q\\<^sub>\\<R>,\n    {(fail\\<^sub>R \\<union> merge\\<^sub>R i, succeed\\<^sub>R i) |i.\n     i < max_rank})\n   w =\n  accept\\<^sub>R\n   (nxt \\<Sigma> \\<delta> q\\<^sub>0, init q\\<^sub>0,\n    {({t. fail_filt \\<Sigma> \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F)\n           t} \\<union>\n      {t. merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t},\n      {t. succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t}) |\n     i. i < max_rank})\n   w\n\ngoal (1 subgoal):\n 1. accept\\<^sub>M =\n    accept\\<^sub>R_LTS\n     (mojmir_to_rabin_exec \\<Sigma>' \\<delta> q\\<^sub>0\n       (\\<lambda>x. x \\<in> F))\n     w", "have \"\\<dots> \\<longleftrightarrow> ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. accept\\<^sub>R\n     (nxt \\<Sigma> \\<delta> q\\<^sub>0, init q\\<^sub>0,\n      {({t. fail_filt \\<Sigma> \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F)\n             t} \\<union>\n        {t. merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t},\n        {t. succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t}) |\n       i. i < max_rank})\n     w =\n    accept\\<^sub>R_LTS\n     (mojmir_to_rabin_exec \\<Sigma>' \\<delta> q\\<^sub>0\n       (\\<lambda>x. x \\<in> F))\n     w", "apply (subst accept\\<^sub>R_restrict[OF bounded_w])"], ["proof (prove)\ngoal (1 subgoal):\n 1. accept\\<^sub>R\n     (nxt \\<Sigma> \\<delta> q\\<^sub>0, init q\\<^sub>0,\n      {((Collect\n          (fail_filt \\<Sigma> \\<delta> q\\<^sub>0\n            (\\<lambda>x. x \\<in> F)) \\<union>\n         Collect\n          (merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F)\n            x)) \\<inter>\n        reach\\<^sub>t \\<Sigma> (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n         (init q\\<^sub>0),\n        Collect\n         (succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F)\n           x) \\<inter>\n        reach\\<^sub>t \\<Sigma> (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n         (init q\\<^sub>0)) |\n       x. x < max_rank})\n     w =\n    accept\\<^sub>R_LTS\n     (mojmir_to_rabin_exec \\<Sigma>' \\<delta> q\\<^sub>0\n       (\\<lambda>x. x \\<in> F))\n     w", "unfolding 3[unfolded mojmir_to_rabin_exec.simps Let_def snd_conv, symmetric] assms[symmetric] mojmir_to_rabin_exec.simps Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. accept\\<^sub>R\n     (nxt \\<Sigma> \\<delta> q\\<^sub>0, init q\\<^sub>0,\n      (\\<lambda>x.\n          (Set.filter\n            (fail_filt \\<Sigma> \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F))\n            (\\<delta>\\<^sub>L \\<Sigma>' (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n              (init q\\<^sub>0)) \\<union>\n           Set.filter\n            (merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) x)\n            (\\<delta>\\<^sub>L \\<Sigma>' (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n              (init q\\<^sub>0)),\n           Set.filter\n            (succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) x)\n            (\\<delta>\\<^sub>L \\<Sigma>' (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n              (init q\\<^sub>0)))) `\n      {0..<card\n            (Set.filter (Not \\<circ> sink)\n              (Q\\<^sub>L \\<Sigma>' \\<delta> q\\<^sub>0))})\n     w =\n    accept\\<^sub>R_LTS\n     (\\<delta>\\<^sub>L \\<Sigma>' (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n       (init q\\<^sub>0),\n      init q\\<^sub>0,\n      (\\<lambda>i.\n          (Set.filter\n            (fail_filt \\<Sigma> \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F))\n            (\\<delta>\\<^sub>L \\<Sigma>' (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n              (init q\\<^sub>0)) \\<union>\n           Set.filter\n            (merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i)\n            (\\<delta>\\<^sub>L \\<Sigma>' (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n              (init q\\<^sub>0)),\n           Set.filter\n            (succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i)\n            (\\<delta>\\<^sub>L \\<Sigma>' (nxt \\<Sigma> \\<delta> q\\<^sub>0)\n              (init q\\<^sub>0)))) `\n      {0..<card\n            (Set.filter (Not \\<circ> sink)\n              (Q\\<^sub>L \\<Sigma>' \\<delta> q\\<^sub>0))})\n     w", "unfolding assms \\<delta>'_Def[unfolded assms]"], ["proof (prove)\ngoal (1 subgoal):\n 1. accept\\<^sub>R\n     (nxt (set \\<Sigma>') \\<delta> q\\<^sub>0, init q\\<^sub>0,\n      (\\<lambda>x.\n          (Set.filter\n            (fail_filt (set \\<Sigma>') \\<delta> q\\<^sub>0\n              (\\<lambda>x. x \\<in> F))\n            (reach\\<^sub>t (set \\<Sigma>')\n              (nxt (set \\<Sigma>') \\<delta> q\\<^sub>0)\n              (init q\\<^sub>0)) \\<union>\n           Set.filter\n            (merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) x)\n            (reach\\<^sub>t (set \\<Sigma>')\n              (nxt (set \\<Sigma>') \\<delta> q\\<^sub>0) (init q\\<^sub>0)),\n           Set.filter\n            (succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) x)\n            (reach\\<^sub>t (set \\<Sigma>')\n              (nxt (set \\<Sigma>') \\<delta> q\\<^sub>0) (init q\\<^sub>0)))) `\n      {0..<card\n            (Set.filter\n              (Not \\<circ>\n               semi_mojmir_def.sink (set \\<Sigma>') \\<delta> q\\<^sub>0)\n              (Q\\<^sub>L \\<Sigma>' \\<delta> q\\<^sub>0))})\n     w =\n    accept\\<^sub>R_LTS\n     (reach\\<^sub>t (set \\<Sigma>') (nxt (set \\<Sigma>') \\<delta> q\\<^sub>0)\n       (init q\\<^sub>0),\n      init q\\<^sub>0,\n      (\\<lambda>i.\n          (Set.filter\n            (fail_filt (set \\<Sigma>') \\<delta> q\\<^sub>0\n              (\\<lambda>x. x \\<in> F))\n            (reach\\<^sub>t (set \\<Sigma>')\n              (nxt (set \\<Sigma>') \\<delta> q\\<^sub>0)\n              (init q\\<^sub>0)) \\<union>\n           Set.filter\n            (merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i)\n            (reach\\<^sub>t (set \\<Sigma>')\n              (nxt (set \\<Sigma>') \\<delta> q\\<^sub>0) (init q\\<^sub>0)),\n           Set.filter\n            (succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i)\n            (reach\\<^sub>t (set \\<Sigma>')\n              (nxt (set \\<Sigma>') \\<delta> q\\<^sub>0) (init q\\<^sub>0)))) `\n      {0..<card\n            (Set.filter\n              (Not \\<circ>\n               semi_mojmir_def.sink (set \\<Sigma>') \\<delta> q\\<^sub>0)\n              (Q\\<^sub>L \\<Sigma>' \\<delta> q\\<^sub>0))})\n     w", "unfolding accept\\<^sub>R_LTS[OF bounded_w[unfolded assms], symmetric, unfolded assms]"], ["proof (prove)\ngoal (1 subgoal):\n 1. accept\\<^sub>R\n     (nxt (set \\<Sigma>') \\<delta> q\\<^sub>0, init q\\<^sub>0,\n      (\\<lambda>x.\n          (Set.filter\n            (fail_filt (set \\<Sigma>') \\<delta> q\\<^sub>0\n              (\\<lambda>x. x \\<in> F))\n            (reach\\<^sub>t (set \\<Sigma>')\n              (nxt (set \\<Sigma>') \\<delta> q\\<^sub>0)\n              (init q\\<^sub>0)) \\<union>\n           Set.filter\n            (merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) x)\n            (reach\\<^sub>t (set \\<Sigma>')\n              (nxt (set \\<Sigma>') \\<delta> q\\<^sub>0) (init q\\<^sub>0)),\n           Set.filter\n            (succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) x)\n            (reach\\<^sub>t (set \\<Sigma>')\n              (nxt (set \\<Sigma>') \\<delta> q\\<^sub>0) (init q\\<^sub>0)))) `\n      {0..<card\n            (Set.filter\n              (Not \\<circ>\n               semi_mojmir_def.sink (set \\<Sigma>') \\<delta> q\\<^sub>0)\n              (Q\\<^sub>L \\<Sigma>' \\<delta> q\\<^sub>0))})\n     w =\n    accept\\<^sub>R\n     (nxt (set \\<Sigma>') \\<delta> q\\<^sub>0, init q\\<^sub>0,\n      (\\<lambda>i.\n          (Set.filter\n            (fail_filt (set \\<Sigma>') \\<delta> q\\<^sub>0\n              (\\<lambda>x. x \\<in> F))\n            (reach\\<^sub>t (set \\<Sigma>')\n              (nxt (set \\<Sigma>') \\<delta> q\\<^sub>0)\n              (init q\\<^sub>0)) \\<union>\n           Set.filter\n            (merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i)\n            (reach\\<^sub>t (set \\<Sigma>')\n              (nxt (set \\<Sigma>') \\<delta> q\\<^sub>0) (init q\\<^sub>0)),\n           Set.filter\n            (succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i)\n            (reach\\<^sub>t (set \\<Sigma>')\n              (nxt (set \\<Sigma>') \\<delta> q\\<^sub>0) (init q\\<^sub>0)))) `\n      {0..<card\n            (Set.filter\n              (Not \\<circ>\n               semi_mojmir_def.sink (set \\<Sigma>') \\<delta> q\\<^sub>0)\n              (Q\\<^sub>L \\<Sigma>' \\<delta> q\\<^sub>0))})\n     w", "by simp"], ["proof (state)\nthis:\n  accept\\<^sub>R\n   (nxt \\<Sigma> \\<delta> q\\<^sub>0, init q\\<^sub>0,\n    {({t. fail_filt \\<Sigma> \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F)\n           t} \\<union>\n      {t. merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t},\n      {t. succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t}) |\n     i. i < max_rank})\n   w =\n  accept\\<^sub>R_LTS\n   (mojmir_to_rabin_exec \\<Sigma>' \\<delta> q\\<^sub>0\n     (\\<lambda>x. x \\<in> F))\n   w\n\ngoal (1 subgoal):\n 1. accept\\<^sub>M =\n    accept\\<^sub>R_LTS\n     (mojmir_to_rabin_exec \\<Sigma>' \\<delta> q\\<^sub>0\n       (\\<lambda>x. x \\<in> F))\n     w", "ultimately"], ["proof (chain)\npicking this:\n  accept\\<^sub>M =\n  accept\\<^sub>R\n   (\\<delta>\\<^sub>\\<R>, q\\<^sub>\\<R>,\n    {(fail\\<^sub>R \\<union> merge\\<^sub>R i, succeed\\<^sub>R i) |i.\n     i < max_rank})\n   w\n  accept\\<^sub>R\n   (\\<delta>\\<^sub>\\<R>, q\\<^sub>\\<R>,\n    {(fail\\<^sub>R \\<union> merge\\<^sub>R i, succeed\\<^sub>R i) |i.\n     i < max_rank})\n   w =\n  accept\\<^sub>R\n   (nxt \\<Sigma> \\<delta> q\\<^sub>0, init q\\<^sub>0,\n    {({t. fail_filt \\<Sigma> \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F)\n           t} \\<union>\n      {t. merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t},\n      {t. succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t}) |\n     i. i < max_rank})\n   w\n  accept\\<^sub>R\n   (nxt \\<Sigma> \\<delta> q\\<^sub>0, init q\\<^sub>0,\n    {({t. fail_filt \\<Sigma> \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F)\n           t} \\<union>\n      {t. merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t},\n      {t. succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t}) |\n     i. i < max_rank})\n   w =\n  accept\\<^sub>R_LTS\n   (mojmir_to_rabin_exec \\<Sigma>' \\<delta> q\\<^sub>0\n     (\\<lambda>x. x \\<in> F))\n   w", "show ?thesis"], ["proof (prove)\nusing this:\n  accept\\<^sub>M =\n  accept\\<^sub>R\n   (\\<delta>\\<^sub>\\<R>, q\\<^sub>\\<R>,\n    {(fail\\<^sub>R \\<union> merge\\<^sub>R i, succeed\\<^sub>R i) |i.\n     i < max_rank})\n   w\n  accept\\<^sub>R\n   (\\<delta>\\<^sub>\\<R>, q\\<^sub>\\<R>,\n    {(fail\\<^sub>R \\<union> merge\\<^sub>R i, succeed\\<^sub>R i) |i.\n     i < max_rank})\n   w =\n  accept\\<^sub>R\n   (nxt \\<Sigma> \\<delta> q\\<^sub>0, init q\\<^sub>0,\n    {({t. fail_filt \\<Sigma> \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F)\n           t} \\<union>\n      {t. merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t},\n      {t. succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t}) |\n     i. i < max_rank})\n   w\n  accept\\<^sub>R\n   (nxt \\<Sigma> \\<delta> q\\<^sub>0, init q\\<^sub>0,\n    {({t. fail_filt \\<Sigma> \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F)\n           t} \\<union>\n      {t. merge_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t},\n      {t. succeed_filt \\<delta> q\\<^sub>0 (\\<lambda>x. x \\<in> F) i t}) |\n     i. i < max_rank})\n   w =\n  accept\\<^sub>R_LTS\n   (mojmir_to_rabin_exec \\<Sigma>' \\<delta> q\\<^sub>0\n     (\\<lambda>x. x \\<in> F))\n   w\n\ngoal (1 subgoal):\n 1. accept\\<^sub>M =\n    accept\\<^sub>R_LTS\n     (mojmir_to_rabin_exec \\<Sigma>' \\<delta> q\\<^sub>0\n       (\\<lambda>x. x \\<in> F))\n     w", "by blast"], ["proof (state)\nthis:\n  accept\\<^sub>M =\n  accept\\<^sub>R_LTS\n   (mojmir_to_rabin_exec \\<Sigma>' \\<delta> q\\<^sub>0\n     (\\<lambda>x. x \\<in> F))\n   w\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}