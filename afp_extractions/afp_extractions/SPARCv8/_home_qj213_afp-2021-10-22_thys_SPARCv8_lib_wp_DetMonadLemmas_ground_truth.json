{"file_name": "/home/qj213/afp-2021-10-22/thys/SPARCv8/lib/wp/DetMonadLemmas.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/SPARCv8", "problem_names": ["lemma bind_cong[fundef_cong]:\n  \"\\<lbrakk> f = f'; \\<And>v s s'. (v, s') = fst (f' s) \\<Longrightarrow> g v s' = g' v s' \\<rbrakk> \\<Longrightarrow> f >>= g = f' >>= g'\"", "lemma bind_apply_cong [fundef_cong]:\n  \"\\<lbrakk> f s = f' s'; \\<And>rv st. (rv, st) = fst (f' s') \\<Longrightarrow> g rv st = g' rv st \\<rbrakk>\n       \\<Longrightarrow> (f >>= g) s = (f' >>= g') s'\"", "lemma bindE_cong[fundef_cong]:\n  \"\\<lbrakk> M = M' ; \\<And>v s s'. (Inr v, s') = fst (M' s) \\<Longrightarrow> N v s' = N' v s' \\<rbrakk> \\<Longrightarrow> bindE M N = bindE M' N'\"", "lemma bindE_apply_cong[fundef_cong]:\n  \"\\<lbrakk> f s = f' s'; \\<And>rv st. (Inr rv, st) = fst (f' s') \\<Longrightarrow> g rv st = g' rv st \\<rbrakk> \n  \\<Longrightarrow> (f >>=E g) s = (f' >>=E g') s'\"", "lemma K_bind_apply_cong[fundef_cong]:\n  \"\\<lbrakk> f st = f' st' \\<rbrakk> \\<Longrightarrow> K_bind f arg st = K_bind f' arg' st'\"", "lemma when_apply_cong[fundef_cong]:\n  \"\\<lbrakk> C = C'; s = s'; C' \\<Longrightarrow> m s' = m' s' \\<rbrakk> \\<Longrightarrow> whenE C m s = whenE C' m' s'\"", "lemma unless_apply_cong[fundef_cong]:\n  \"\\<lbrakk> C = C'; s = s'; \\<not> C' \\<Longrightarrow> m s' = m' s' \\<rbrakk> \\<Longrightarrow> unlessE C m s = unlessE C' m' s'\"", "lemma whenE_apply_cong[fundef_cong]:\n  \"\\<lbrakk> C = C'; s = s'; C' \\<Longrightarrow> m s' = m' s' \\<rbrakk> \\<Longrightarrow> whenE C m s = whenE C' m' s'\"", "lemma unlessE_apply_cong[fundef_cong]:\n  \"\\<lbrakk> C = C'; s = s'; \\<not> C' \\<Longrightarrow> m s' = m' s' \\<rbrakk> \\<Longrightarrow> unlessE C m s = unlessE C' m' s'\"", "lemma nested_bind [simp]:\n  \"do x \\<leftarrow> do y \\<leftarrow> f; return (g y) od; h x od =\n   do y \\<leftarrow> f; h (g y) od\"", "lemma assert_True [simp]:\n  \"assert True >>= f = f ()\"", "lemma when_True_bind [simp]:\n  \"when1 True g >>= f = g >>= f\"", "lemma whenE_False_bind [simp]:\n  \"whenE False g >>=E f = f ()\"", "lemma whenE_True_bind [simp]:\n  \"whenE True g >>=E f = g >>=E f\"", "lemma when_True [simp]: \"when1 True X = X\"", "lemma when_False [simp]: \"when1 False X = return ()\"", "lemma unless_False [simp]: \"unless False X = X\"", "lemma unless_True [simp]: \"unless True X = return ()\"", "lemma unlessE_whenE:\n  \"unlessE P = whenE (~P)\"", "lemma unless_when:\n  \"unless P = when1 (~P)\"", "lemma gets_to_return [simp]: \"gets (\\<lambda>s. v) = return v\"", "lemma liftE_handleE' [simp]: \"((liftE a) <handle2> b) = liftE a\"", "lemma liftE_handleE [simp]: \"((liftE a) <handle> b) = liftE a\"", "lemma condition_split:\n  \"P (condition C a b s) = ((((C s) \\<longrightarrow> P (a s)) \\<and> (\\<not> (C s) \\<longrightarrow> P (b s))))\"", "lemma condition_split_asm:\n  \"P (condition C a b s) = (\\<not> (C s \\<and> \\<not> P (a s) \\<or> \\<not> C s \\<and> \\<not> P (b s)))\"", "lemmas condition_splits = condition_split condition_split_asm", "lemma condition_true_triv [simp]:\n  \"condition (\\<lambda>_. True) A B = A\"", "lemma condition_false_triv [simp]:\n  \"condition (\\<lambda>_. False) A B = B\"", "lemma condition_true: \"\\<lbrakk> P s \\<rbrakk> \\<Longrightarrow> condition P A B s = A s\"", "lemma condition_false: \"\\<lbrakk> \\<not> P s \\<rbrakk> \\<Longrightarrow> condition P A B s = B s\"", "lemma valid_make_schematic_post:\n  \"(\\<forall>s0. \\<lbrace> \\<lambda>s. P s0 s \\<rbrace> f \\<lbrace> \\<lambda>rv s. Q s0 rv s \\<rbrace>) \\<Longrightarrow>\n   \\<lbrace> \\<lambda>s. \\<exists>s0. P s0 s \\<and> (\\<forall>rv s'. Q s0 rv s' \\<longrightarrow> Q' rv s') \\<rbrace> f \\<lbrace> Q' \\<rbrace>\"", "lemma validNF_make_schematic_post:\n  \"(\\<forall>s0. \\<lbrace> \\<lambda>s. P s0 s \\<rbrace> f \\<lbrace> \\<lambda>rv s. Q s0 rv s \\<rbrace>!) \\<Longrightarrow>\n   \\<lbrace> \\<lambda>s. \\<exists>s0. P s0 s \\<and> (\\<forall>rv s'. Q s0 rv s' \\<longrightarrow> Q' rv s') \\<rbrace> f \\<lbrace> Q' \\<rbrace>!\"", "lemma validE_make_schematic_post:\n  \"(\\<forall>s0. \\<lbrace> \\<lambda>s. P s0 s \\<rbrace> f \\<lbrace> \\<lambda>rv s. Q s0 rv s \\<rbrace>, \\<lbrace> \\<lambda>rv s. E s0 rv s \\<rbrace>) \\<Longrightarrow>\n   \\<lbrace> \\<lambda>s. \\<exists>s0. P s0 s \\<and> (\\<forall>rv s'. Q s0 rv s' \\<longrightarrow> Q' rv s')\n        \\<and> (\\<forall>rv s'. E s0 rv s' \\<longrightarrow> E' rv s') \\<rbrace> f \\<lbrace> Q' \\<rbrace>, \\<lbrace> E' \\<rbrace>\"", "lemma validE_NF_make_schematic_post:\n  \"(\\<forall>s0. \\<lbrace> \\<lambda>s. P s0 s \\<rbrace> f \\<lbrace> \\<lambda>rv s. Q s0 rv s \\<rbrace>, \\<lbrace> \\<lambda>rv s. E s0 rv s \\<rbrace>!) \\<Longrightarrow>\n   \\<lbrace> \\<lambda>s. \\<exists>s0. P s0 s \\<and> (\\<forall>rv s'. Q s0 rv s' \\<longrightarrow> Q' rv s')\n        \\<and> (\\<forall>rv s'. E s0 rv s' \\<longrightarrow> E' rv s') \\<rbrace> f \\<lbrace> Q' \\<rbrace>, \\<lbrace> E' \\<rbrace>!\"", "lemma validNF_conjD1: \"\\<lbrace> P \\<rbrace> f \\<lbrace> \\<lambda>rv s. Q rv s \\<and> Q' rv s \\<rbrace>! \\<Longrightarrow> \\<lbrace> P \\<rbrace> f \\<lbrace> Q \\<rbrace>!\"", "lemma validNF_conjD2: \"\\<lbrace> P \\<rbrace> f \\<lbrace> \\<lambda>rv s. Q rv s \\<and> Q' rv s \\<rbrace>! \\<Longrightarrow> \\<lbrace> P \\<rbrace> f \\<lbrace> Q' \\<rbrace>!\"", "lemma exec_gets:\n  \"(gets f >>= m) s = m (f s) s\"", "lemma in_gets:\n  \"(r, s') = fst (gets f s) = (r = f s \\<and> s' = s)\""], "translations": [["", "lemma bind_cong[fundef_cong]:\n  \"\\<lbrakk> f = f'; \\<And>v s s'. (v, s') = fst (f' s) \\<Longrightarrow> g v s' = g' v s' \\<rbrakk> \\<Longrightarrow> f >>= g = f' >>= g'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f = f';\n     \\<And>v s s'.\n        (v, s') = fst (f' s) \\<Longrightarrow> g v s' = g' v s'\\<rbrakk>\n    \\<Longrightarrow> f >>= g = f' >>= g'", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>f = f';\n        \\<And>v s s'.\n           (v, s') = fst (f' s) \\<Longrightarrow> g v s' = g' v s'\\<rbrakk>\n       \\<Longrightarrow> (f >>= g) x = (f' >>= g') x", "apply (auto simp: bind_def h1_def h2_def Let_def split_def intro: rev_image_eqI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bind_apply_cong [fundef_cong]:\n  \"\\<lbrakk> f s = f' s'; \\<And>rv st. (rv, st) = fst (f' s') \\<Longrightarrow> g rv st = g' rv st \\<rbrakk>\n       \\<Longrightarrow> (f >>= g) s = (f' >>= g') s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f s = f' s';\n     \\<And>rv st.\n        (rv, st) = fst (f' s') \\<Longrightarrow> g rv st = g' rv st\\<rbrakk>\n    \\<Longrightarrow> (f >>= g) s = (f' >>= g') s'", "apply (simp add: bind_def h1_def h2_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f s = f' s';\n     \\<And>rv st.\n        (rv, st) = fst (f' s') \\<Longrightarrow> g rv st = g' rv st\\<rbrakk>\n    \\<Longrightarrow> (let fs = f' s';\n                           v = case fst fs of (x, xa) \\<Rightarrow> g x xa\n                       in (fst v, snd v \\<or> snd fs)) =\n                      (let fs = f' s';\n                           v = case fst fs of (x, xa) \\<Rightarrow> g' x xa\n                       in (fst v, snd v \\<or> snd fs))", "apply (auto simp: split_def intro: SUP_cong [OF refl] intro: rev_image_eqI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bindE_cong[fundef_cong]:\n  \"\\<lbrakk> M = M' ; \\<And>v s s'. (Inr v, s') = fst (M' s) \\<Longrightarrow> N v s' = N' v s' \\<rbrakk> \\<Longrightarrow> bindE M N = bindE M' N'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>M = M';\n     \\<And>v s s'.\n        (Inr v, s') = fst (M' s) \\<Longrightarrow> N v s' = N' v s'\\<rbrakk>\n    \\<Longrightarrow> M >>=E N = M' >>=E N'", "apply (simp add: bindE_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>M = M';\n     \\<And>v s s'.\n        (Inr v, s') = fst (M' s) \\<Longrightarrow> N v s' = N' v s'\\<rbrakk>\n    \\<Longrightarrow> M' >>= lift N = M' >>= lift N'", "apply (rule bind_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>M = M';\n     \\<And>v s s'.\n        (Inr v, s') = fst (M' s) \\<Longrightarrow> N v s' = N' v s'\\<rbrakk>\n    \\<Longrightarrow> M' = M'\n 2. \\<And>v s s'.\n       \\<lbrakk>M = M';\n        \\<And>v s s'.\n           (Inr v, s') = fst (M' s) \\<Longrightarrow> N v s' = N' v s';\n        (v, s') = fst (M' s)\\<rbrakk>\n       \\<Longrightarrow> lift N v s' = lift N' v s'", "apply (rule refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v s s'.\n       \\<lbrakk>M = M';\n        \\<And>v s s'.\n           (Inr v, s') = fst (M' s) \\<Longrightarrow> N v s' = N' v s';\n        (v, s') = fst (M' s)\\<rbrakk>\n       \\<Longrightarrow> lift N v s' = lift N' v s'", "apply (unfold lift_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v s s'.\n       \\<lbrakk>M = M';\n        \\<And>v s s'.\n           (Inr v, s') = fst (M' s) \\<Longrightarrow> N v s' = N' v s';\n        (v, s') = fst (M' s)\\<rbrakk>\n       \\<Longrightarrow> (case v of Inl e \\<Rightarrow> throwError e\n                          | Inr v' \\<Rightarrow> N v')\n                          s' =\n                         (case v of Inl e \\<Rightarrow> throwError e\n                          | Inr v' \\<Rightarrow> N' v')\n                          s'", "apply (case_tac v, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bindE_apply_cong[fundef_cong]:\n  \"\\<lbrakk> f s = f' s'; \\<And>rv st. (Inr rv, st) = fst (f' s') \\<Longrightarrow> g rv st = g' rv st \\<rbrakk> \n  \\<Longrightarrow> (f >>=E g) s = (f' >>=E g') s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f s = f' s';\n     \\<And>rv st.\n        (Inr rv, st) = fst (f' s') \\<Longrightarrow>\n        g rv st = g' rv st\\<rbrakk>\n    \\<Longrightarrow> (f >>=E g) s = (f' >>=E g') s'", "apply (simp add: bindE_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f s = f' s';\n     \\<And>rv st.\n        (Inr rv, st) = fst (f' s') \\<Longrightarrow>\n        g rv st = g' rv st\\<rbrakk>\n    \\<Longrightarrow> (f >>= lift g) s = (f' >>= lift g') s'", "apply (rule bind_apply_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>f s = f' s';\n     \\<And>rv st.\n        (Inr rv, st) = fst (f' s') \\<Longrightarrow>\n        g rv st = g' rv st\\<rbrakk>\n    \\<Longrightarrow> f s = f' s'\n 2. \\<And>rv st.\n       \\<lbrakk>f s = f' s';\n        \\<And>rv st.\n           (Inr rv, st) = fst (f' s') \\<Longrightarrow> g rv st = g' rv st;\n        (rv, st) = fst (f' s')\\<rbrakk>\n       \\<Longrightarrow> lift g rv st = lift g' rv st", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rv st.\n       \\<lbrakk>f s = f' s';\n        \\<And>rv st.\n           (Inr rv, st) = fst (f' s') \\<Longrightarrow> g rv st = g' rv st;\n        (rv, st) = fst (f' s')\\<rbrakk>\n       \\<Longrightarrow> lift g rv st = lift g' rv st", "apply (case_tac rv, simp_all add: lift_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma K_bind_apply_cong[fundef_cong]:\n  \"\\<lbrakk> f st = f' st' \\<rbrakk> \\<Longrightarrow> K_bind f arg st = K_bind f' arg' st'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f st = f' st' \\<Longrightarrow> K_bind f arg st = K_bind f' arg' st'", "by simp"], ["", "lemma when_apply_cong[fundef_cong]:\n  \"\\<lbrakk> C = C'; s = s'; C' \\<Longrightarrow> m s' = m' s' \\<rbrakk> \\<Longrightarrow> whenE C m s = whenE C' m' s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C = C'; s = s'; C' \\<Longrightarrow> m s' = m' s'\\<rbrakk>\n    \\<Longrightarrow> whenE C m s = whenE C' m' s'", "by (simp add: whenE_def)"], ["", "lemma unless_apply_cong[fundef_cong]:\n  \"\\<lbrakk> C = C'; s = s'; \\<not> C' \\<Longrightarrow> m s' = m' s' \\<rbrakk> \\<Longrightarrow> unlessE C m s = unlessE C' m' s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C = C'; s = s';\n     \\<not> C' \\<Longrightarrow> m s' = m' s'\\<rbrakk>\n    \\<Longrightarrow> unlessE C m s = unlessE C' m' s'", "by (simp add: unlessE_def)"], ["", "lemma whenE_apply_cong[fundef_cong]:\n  \"\\<lbrakk> C = C'; s = s'; C' \\<Longrightarrow> m s' = m' s' \\<rbrakk> \\<Longrightarrow> whenE C m s = whenE C' m' s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C = C'; s = s'; C' \\<Longrightarrow> m s' = m' s'\\<rbrakk>\n    \\<Longrightarrow> whenE C m s = whenE C' m' s'", "by (simp add: whenE_def)"], ["", "lemma unlessE_apply_cong[fundef_cong]:\n  \"\\<lbrakk> C = C'; s = s'; \\<not> C' \\<Longrightarrow> m s' = m' s' \\<rbrakk> \\<Longrightarrow> unlessE C m s = unlessE C' m' s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C = C'; s = s';\n     \\<not> C' \\<Longrightarrow> m s' = m' s'\\<rbrakk>\n    \\<Longrightarrow> unlessE C m s = unlessE C' m' s'", "by (simp add: unlessE_def)"], ["", "subsection \"Simplifying Monads\""], ["", "lemma nested_bind [simp]:\n  \"do x \\<leftarrow> do y \\<leftarrow> f; return (g y) od; h x od =\n   do y \\<leftarrow> f; h (g y) od\""], ["proof (prove)\ngoal (1 subgoal):\n 1. do y \\<leftarrow> f;\n       return (g y)\n    od >>=\n    h =\n    do y \\<leftarrow> f;\n       h (g y)\n    od", "apply (clarsimp simp add: bind_def h1_def h2_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s.\n        let fs = let fs = f s;\n                     v = case fst fs of (a, x) \\<Rightarrow> return (g a) x\n                 in (fst v, snd v \\<or> snd fs);\n            v = case fst fs of (x, xa) \\<Rightarrow> h x xa\n        in (fst v, snd v \\<or> snd fs)) =\n    (\\<lambda>s.\n        let fs = f s; v = case fst fs of (a, x) \\<Rightarrow> h (g a) x\n        in (fst v, snd v \\<or> snd fs))", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       (let fs = let fs = f s;\n                     v = case fst fs of (a, x) \\<Rightarrow> return (g a) x\n                 in (fst v, snd v \\<or> snd fs);\n            v = case fst fs of (x, xa) \\<Rightarrow> h x xa\n        in (fst v, snd v \\<or> snd fs)) =\n       (let fs = f s; v = case fst fs of (a, x) \\<Rightarrow> h (g a) x\n        in (fst v, snd v \\<or> snd fs))", "apply (clarsimp simp add: Let_def split_def return_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma assert_True [simp]:\n  \"assert True >>= f = f ()\""], ["proof (prove)\ngoal (1 subgoal):\n 1. assert True >>= f = f ()", "by (simp add: assert_def)"], ["", "lemma when_True_bind [simp]:\n  \"when1 True g >>= f = g >>= f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. when1 True g >>= f = g >>= f", "by (simp add: when1_def bind_def return_def)"], ["", "lemma whenE_False_bind [simp]:\n  \"whenE False g >>=E f = f ()\""], ["proof (prove)\ngoal (1 subgoal):\n 1. whenE False g >>=E f = f ()", "by (simp add: whenE_def bindE_def returnOk_def lift_def)"], ["", "lemma whenE_True_bind [simp]:\n  \"whenE True g >>=E f = g >>=E f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. whenE True g >>=E f = g >>=E f", "by (simp add: whenE_def bindE_def returnOk_def lift_def)"], ["", "lemma when_True [simp]: \"when1 True X = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. when1 True X = X", "by (clarsimp simp: when1_def)"], ["", "lemma when_False [simp]: \"when1 False X = return ()\""], ["proof (prove)\ngoal (1 subgoal):\n 1. when1 False X = return ()", "by (clarsimp simp: when1_def)"], ["", "lemma unless_False [simp]: \"unless False X = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unless False X = X", "by (clarsimp simp: unless_def)"], ["", "lemma unless_True [simp]: \"unless True X = return ()\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unless True X = return ()", "by (clarsimp simp: unless_def)"], ["", "lemma unlessE_whenE:\n  \"unlessE P = whenE (~P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unlessE P = whenE (\\<not> P)", "by (rule ext)+ (simp add: unlessE_def whenE_def)"], ["", "lemma unless_when:\n  \"unless P = when1 (~P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unless P = when1 (\\<not> P)", "by (rule ext)+ (simp add: unless_def when1_def)"], ["", "lemma gets_to_return [simp]: \"gets (\\<lambda>s. v) = return v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gets (\\<lambda>s. v) = return v", "by (clarsimp simp: gets_def put_def get_def bind_def h1_def h2_def return_def)"], ["", "lemma liftE_handleE' [simp]: \"((liftE a) <handle2> b) = liftE a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (liftE a <handle2> b) = liftE a", "apply (clarsimp simp: liftE_def handleE'_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma liftE_handleE [simp]: \"((liftE a) <handle> b) = liftE a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (liftE a <handle> b) = liftE a", "apply (unfold handleE_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (liftE a <handle2> b) = liftE a", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma condition_split:\n  \"P (condition C a b s) = ((((C s) \\<longrightarrow> P (a s)) \\<and> (\\<not> (C s) \\<longrightarrow> P (b s))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (condition C\n         a\n         b\n        s) =\n    ((C s \\<longrightarrow> P (a s)) \\<and>\n     (\\<not> C s \\<longrightarrow> P (b s)))", "apply (clarsimp simp: condition_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma condition_split_asm:\n  \"P (condition C a b s) = (\\<not> (C s \\<and> \\<not> P (a s) \\<or> \\<not> C s \\<and> \\<not> P (b s)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (condition C\n         a\n         b\n        s) =\n    (\\<not> (C s \\<and> \\<not> P (a s) \\<or>\n             \\<not> C s \\<and> \\<not> P (b s)))", "apply (clarsimp simp: condition_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas condition_splits = condition_split condition_split_asm"], ["", "lemma condition_true_triv [simp]:\n  \"condition (\\<lambda>_. True) A B = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. condition (\\<lambda>_. True)\n      A\n      B =\n    A", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. condition (\\<lambda>_. True)\n               A\n               B\n              x =\n             A x", "apply (clarsimp split: condition_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma condition_false_triv [simp]:\n  \"condition (\\<lambda>_. False) A B = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. condition (\\<lambda>_. False)\n      A\n      B =\n    B", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. condition (\\<lambda>_. False)\n               A\n               B\n              x =\n             B x", "apply (clarsimp split: condition_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma condition_true: \"\\<lbrakk> P s \\<rbrakk> \\<Longrightarrow> condition P A B s = A s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P s \\<Longrightarrow> condition P\n                            A\n                            B\n                           s =\n                          A s", "apply (clarsimp simp: condition_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma condition_false: \"\\<lbrakk> \\<not> P s \\<rbrakk> \\<Longrightarrow> condition P A B s = B s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> P s \\<Longrightarrow> condition P\n                                   A\n                                   B\n                                  s =\n                                 B s", "apply (clarsimp simp: condition_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "section \"Low-level monadic reasoning\""], ["", "lemma valid_make_schematic_post:\n  \"(\\<forall>s0. \\<lbrace> \\<lambda>s. P s0 s \\<rbrace> f \\<lbrace> \\<lambda>rv s. Q s0 rv s \\<rbrace>) \\<Longrightarrow>\n   \\<lbrace> \\<lambda>s. \\<exists>s0. P s0 s \\<and> (\\<forall>rv s'. Q s0 rv s' \\<longrightarrow> Q' rv s') \\<rbrace> f \\<lbrace> Q' \\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s0. \\<lbrace>P s0\\<rbrace> f \n       \\<lbrace>Q s0\\<rbrace> \\<Longrightarrow>\n    \\<lbrace>\\<lambda>s.\n                \\<exists>s0.\n                   P s0 s \\<and>\n                   (\\<forall>rv s'.\n                       Q s0 rv s' \\<longrightarrow> Q' rv s')\\<rbrace>\n    f \\<lbrace>Q'\\<rbrace>", "by (auto simp add: valid_def no_fail_def split: prod.splits)"], ["", "lemma validNF_make_schematic_post:\n  \"(\\<forall>s0. \\<lbrace> \\<lambda>s. P s0 s \\<rbrace> f \\<lbrace> \\<lambda>rv s. Q s0 rv s \\<rbrace>!) \\<Longrightarrow>\n   \\<lbrace> \\<lambda>s. \\<exists>s0. P s0 s \\<and> (\\<forall>rv s'. Q s0 rv s' \\<longrightarrow> Q' rv s') \\<rbrace> f \\<lbrace> Q' \\<rbrace>!\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s0. \\<lbrace>P s0\\<rbrace> f \n       \\<lbrace>Q s0\\<rbrace>! \\<Longrightarrow>\n    \\<lbrace>\\<lambda>s.\n                \\<exists>s0.\n                   P s0 s \\<and>\n                   (\\<forall>rv s'.\n                       Q s0 rv s' \\<longrightarrow> Q' rv s')\\<rbrace>\n    f \\<lbrace>Q'\\<rbrace>!", "by (auto simp add: valid_def validNF_def no_fail_def split: prod.splits)"], ["", "lemma validE_make_schematic_post:\n  \"(\\<forall>s0. \\<lbrace> \\<lambda>s. P s0 s \\<rbrace> f \\<lbrace> \\<lambda>rv s. Q s0 rv s \\<rbrace>, \\<lbrace> \\<lambda>rv s. E s0 rv s \\<rbrace>) \\<Longrightarrow>\n   \\<lbrace> \\<lambda>s. \\<exists>s0. P s0 s \\<and> (\\<forall>rv s'. Q s0 rv s' \\<longrightarrow> Q' rv s')\n        \\<and> (\\<forall>rv s'. E s0 rv s' \\<longrightarrow> E' rv s') \\<rbrace> f \\<lbrace> Q' \\<rbrace>, \\<lbrace> E' \\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s0. \\<lbrace>P s0\\<rbrace> f \n       \\<lbrace>Q s0\\<rbrace>, \\<lbrace>E s0\\<rbrace> \\<Longrightarrow>\n    \\<lbrace>\\<lambda>s.\n                \\<exists>s0.\n                   P s0 s \\<and>\n                   (\\<forall>rv s'.\n                       Q s0 rv s' \\<longrightarrow> Q' rv s') \\<and>\n                   (\\<forall>rv s'.\n                       E s0 rv s' \\<longrightarrow> E' rv s')\\<rbrace>\n    f \\<lbrace>Q'\\<rbrace>, \\<lbrace>E'\\<rbrace>", "by (auto simp add: validE_def valid_def no_fail_def split: prod.splits sum.splits)"], ["", "lemma validE_NF_make_schematic_post:\n  \"(\\<forall>s0. \\<lbrace> \\<lambda>s. P s0 s \\<rbrace> f \\<lbrace> \\<lambda>rv s. Q s0 rv s \\<rbrace>, \\<lbrace> \\<lambda>rv s. E s0 rv s \\<rbrace>!) \\<Longrightarrow>\n   \\<lbrace> \\<lambda>s. \\<exists>s0. P s0 s \\<and> (\\<forall>rv s'. Q s0 rv s' \\<longrightarrow> Q' rv s')\n        \\<and> (\\<forall>rv s'. E s0 rv s' \\<longrightarrow> E' rv s') \\<rbrace> f \\<lbrace> Q' \\<rbrace>, \\<lbrace> E' \\<rbrace>!\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s0. \\<lbrace>P s0\\<rbrace> f \n       \\<lbrace>Q s0\\<rbrace>, \\<lbrace>E s0\\<rbrace>! \\<Longrightarrow>\n    \\<lbrace>\\<lambda>s.\n                \\<exists>s0.\n                   P s0 s \\<and>\n                   (\\<forall>rv s'.\n                       Q s0 rv s' \\<longrightarrow> Q' rv s') \\<and>\n                   (\\<forall>rv s'.\n                       E s0 rv s' \\<longrightarrow> E' rv s')\\<rbrace>\n    f \\<lbrace>Q'\\<rbrace>, \\<lbrace>E'\\<rbrace>!", "by (auto simp add: validE_NF_def validE_def valid_def no_fail_def split: prod.splits sum.splits)"], ["", "lemma validNF_conjD1: \"\\<lbrace> P \\<rbrace> f \\<lbrace> \\<lambda>rv s. Q rv s \\<and> Q' rv s \\<rbrace>! \\<Longrightarrow> \\<lbrace> P \\<rbrace> f \\<lbrace> Q \\<rbrace>!\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>P\\<rbrace> f \n    \\<lbrace>\\<lambda>rv s.\n                Q rv s \\<and> Q' rv s\\<rbrace>! \\<Longrightarrow>\n    \\<lbrace>P\\<rbrace> f \\<lbrace>Q\\<rbrace>!", "by (fastforce simp: validNF_def valid_def no_fail_def)"], ["", "lemma validNF_conjD2: \"\\<lbrace> P \\<rbrace> f \\<lbrace> \\<lambda>rv s. Q rv s \\<and> Q' rv s \\<rbrace>! \\<Longrightarrow> \\<lbrace> P \\<rbrace> f \\<lbrace> Q' \\<rbrace>!\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>P\\<rbrace> f \n    \\<lbrace>\\<lambda>rv s.\n                Q rv s \\<and> Q' rv s\\<rbrace>! \\<Longrightarrow>\n    \\<lbrace>P\\<rbrace> f \\<lbrace>Q'\\<rbrace>!", "by (fastforce simp: validNF_def valid_def no_fail_def)"], ["", "lemma exec_gets:\n  \"(gets f >>= m) s = m (f s) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gets f >>= m) s = m (f s) s", "by (simp add: simpler_gets_def bind_def h1_def h2_def)"], ["", "lemma in_gets:\n  \"(r, s') = fst (gets f s) = (r = f s \\<and> s' = s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((r, s') = fst (gets f s)) = (r = f s \\<and> s' = s)", "by (simp add: simpler_gets_def)"], ["", "end"]]}