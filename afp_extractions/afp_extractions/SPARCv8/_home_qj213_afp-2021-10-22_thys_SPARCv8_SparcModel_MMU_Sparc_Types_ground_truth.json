{"file_name": "/home/qj213/afp-2021-10-22/thys/SPARCv8/SparcModel_MMU/Sparc_Types.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/SPARCv8", "problem_names": ["lemma MMU_register_induct: \n  \"P CR \\<Longrightarrow> P CTP \\<Longrightarrow> P CNR \\<Longrightarrow> P FTSR \\<Longrightarrow> P FAR \n   \\<Longrightarrow> P x\"", "lemma UNIV_MMU_register [no_atp]: \"UNIV = {CR, CTP, CNR, FTSR, FAR}\"", "lemma set_list_of_set: \"finite s \\<Longrightarrow> set (list_of_set s) = s\""], "translations": [["", "lemma MMU_register_induct: \n  \"P CR \\<Longrightarrow> P CTP \\<Longrightarrow> P CNR \\<Longrightarrow> P FTSR \\<Longrightarrow> P FAR \n   \\<Longrightarrow> P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P CR; P CTP; P CNR; P FTSR; P FAR\\<rbrakk>\n    \\<Longrightarrow> P x", "by (cases x) auto"], ["", "lemma UNIV_MMU_register [no_atp]: \"UNIV = {CR, CTP, CNR, FTSR, FAR}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = {CR, CTP, CNR, FTSR, FAR}", "apply (safe)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> UNIV; x \\<noteq> CR; x \\<noteq> CTP; x \\<noteq> CNR;\n        x \\<noteq> FTSR; x \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> x = FAR\n 2. \\<And>x. CR \\<in> UNIV\n 3. \\<And>x. CTP \\<in> UNIV\n 4. \\<And>x. CNR \\<in> UNIV\n 5. \\<And>x. FTSR \\<in> UNIV\n 6. \\<And>x. FAR \\<in> UNIV", "apply (case_tac x)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> UNIV; x \\<noteq> CR; x \\<noteq> CTP; x \\<noteq> CNR;\n        x \\<noteq> FTSR; x \\<notin> {}; x = CR\\<rbrakk>\n       \\<Longrightarrow> x = FAR\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> UNIV; x \\<noteq> CR; x \\<noteq> CTP; x \\<noteq> CNR;\n        x \\<noteq> FTSR; x \\<notin> {}; x = CTP\\<rbrakk>\n       \\<Longrightarrow> x = FAR\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> UNIV; x \\<noteq> CR; x \\<noteq> CTP; x \\<noteq> CNR;\n        x \\<noteq> FTSR; x \\<notin> {}; x = CNR\\<rbrakk>\n       \\<Longrightarrow> x = FAR\n 4. \\<And>x.\n       \\<lbrakk>x \\<in> UNIV; x \\<noteq> CR; x \\<noteq> CTP; x \\<noteq> CNR;\n        x \\<noteq> FTSR; x \\<notin> {}; x = FTSR\\<rbrakk>\n       \\<Longrightarrow> x = FAR\n 5. \\<And>x.\n       \\<lbrakk>x \\<in> UNIV; x \\<noteq> CR; x \\<noteq> CTP; x \\<noteq> CNR;\n        x \\<noteq> FTSR; x \\<notin> {}; x = FAR\\<rbrakk>\n       \\<Longrightarrow> x = FAR\n 6. \\<And>x. CR \\<in> UNIV\n 7. \\<And>x. CTP \\<in> UNIV\n 8. \\<And>x. CNR \\<in> UNIV\n 9. \\<And>x. FTSR \\<in> UNIV\n 10. \\<And>x. FAR \\<in> UNIV", "apply (auto intro:MMU_register_induct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "instantiation MMU_register :: enum begin"], ["", "definition \"enum_MMU_register = [ CR, CTP, CNR, FTSR, FAR ]\""], ["", "definition\n  \"enum_all_MMU_register P \\<longleftrightarrow> P CR \\<and> P CTP \\<and> P CNR \\<and> P FTSR \\<and> P FAR \""], ["", "definition\n  \"enum_ex_MMU_register P \\<longleftrightarrow> P CR \\<or> P CTP \\<or> P CNR \\<or> P FTSR \\<or> P FAR\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(MMU_register, enum_class)", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. UNIV = set enum_class.enum\n 2. distinct enum_class.enum\n 3. \\<And>P. enum_class.enum_all P = Ball UNIV P\n 4. \\<And>P. enum_class.enum_ex P = Bex UNIV P", "qed (simp_all only: enum_MMU_register_def enum_all_MMU_register_def \n                      enum_ex_MMU_register_def UNIV_MMU_register, simp_all)"], ["", "end"], ["", "type_synonym MMU_context = \"MMU_register \\<Rightarrow> machine_word\""], ["", "text \\<open>\\<open>PTE_flags\\<close> is the last 8 bits of a PTE. See page 242 of SPARCv8 manual.\n\\<^item> C - bit 7\n\\<^item> M - bit 6,\n\\<^item> R - bit 5\n\\<^item> ACC - bit 4~2\n\\<^item> ET - bit 1~0.\\<close>"], ["", "type_synonym PTE_flags = word8"], ["", "text \\<open>\n  @{term CPU_register} datatype is an enumeration with the CPU registers defined in the SPARC V8 \n  architecture.\n\\<close>"], ["", "datatype CPU_register = \n   PSR   \\<comment> \\<open>Processor State Register\\<close>\n | WIM   \\<comment> \\<open>Window Invalid Mask\\<close>\n | TBR   \\<comment> \\<open>Trap Base Register\\<close>\n | Y     \\<comment> \\<open>Multiply/Divide Register\\<close>\n | PC    \\<comment> \\<open>Program Counter\\<close>\n | nPC   \\<comment> \\<open>next Program Counter\\<close>\n | DTQ   \\<comment> \\<open>Deferred-Trap Queue\\<close>\n | FSR   \\<comment> \\<open>Floating-Point State Register\\<close>\n | FQ    \\<comment> \\<open>Floating-Point Deferred-Trap Queue\\<close>\n | CSR   \\<comment> \\<open>Coprocessor State Register\\<close>\n | CQ    \\<comment> \\<open>Coprocessor Deferred-Trap Queue\\<close>\n (*| CCR   --   \"Cache Control Register\"*)\n | ASR \"word5\"  \\<comment> \\<open>Ancillary State Register\\<close>"], ["", "text \\<open>The following two functions are dummies since we will not use \n        ASRs. Future formalisation may add more details to this.\\<close>"], ["", "definition privileged_ASR :: \"word5 \\<Rightarrow> bool\"\nwhere\n\"privileged_ASR r \\<equiv> False\n\""], ["", "definition illegal_instruction_ASR :: \"word5 \\<Rightarrow> bool\"\nwhere\n\"illegal_instruction_ASR r \\<equiv> False\n\""], ["", "definition get_tt :: \"word32 \\<Rightarrow> word8\"\nwhere\n\"get_tt tbr \\<equiv>\n  ucast (((AND) tbr 0b00000000000000000000111111110000) >> 4)\n\""], ["", "text \\<open>Write the tt field of the TBR register. \n        Return the new value of TBR.\\<close>"], ["", "definition write_tt :: \"word8 \\<Rightarrow> word32 \\<Rightarrow> word32\"\nwhere\n\"write_tt new_tt_val tbr_val \\<equiv>\n  let tmp = (AND) tbr_val 0b111111111111111111111000000001111 in\n      (OR) tmp (((ucast new_tt_val)::word32) << 4)\n\""], ["", "text \\<open>Get the nth bit of WIM. This equals ((AND) WIM $2^n$). \n        N.B. the first bit of WIM is the 0th bit.\\<close>"], ["", "definition get_WIM_bit :: \"nat \\<Rightarrow> word32 \\<Rightarrow> word1\"\nwhere\n\"get_WIM_bit n wim \\<equiv>\n  let mask = ((ucast (0b1::word1))::word32) << n in\n  ucast (((AND) mask wim) >> n)\n\""], ["", "definition get_CWP :: \"word32 \\<Rightarrow> word5\"\nwhere\n\"get_CWP psr \\<equiv> \n  ucast ((AND) psr 0b00000000000000000000000000011111) \n\""], ["", "definition get_ET :: \"word32 \\<Rightarrow> word1\"\nwhere\n\"get_ET psr \\<equiv> \n  ucast (((AND) psr 0b00000000000000000000000000100000) >> 5) \n\""], ["", "definition get_PIL :: \"word32 \\<Rightarrow> word4\"\nwhere\n\"get_PIL psr \\<equiv> \n  ucast (((AND) psr 0b00000000000000000000111100000000) >> 8) \n\""], ["", "definition get_PS :: \"word32 \\<Rightarrow> word1\"\nwhere\n\"get_PS psr \\<equiv> \n  ucast (((AND) psr 0b00000000000000000000000001000000) >> 6) \n\""], ["", "definition get_S :: \"word32 \\<Rightarrow> word1\"\nwhere\n\"get_S psr \\<equiv> \n  \\<^cancel>\\<open>ucast (((AND) psr 0b00000000000000000000000010000000) >> 7)\\<close>\n  if ((AND) psr (0b00000000000000000000000010000000::word32)) = 0 then 0\n  else 1\n\""], ["", "definition get_icc_N :: \"word32 \\<Rightarrow> word1\"\nwhere\n\"get_icc_N psr \\<equiv>\n  ucast (((AND) psr 0b00000000100000000000000000000000) >> 23)\n\""], ["", "definition get_icc_Z :: \"word32 \\<Rightarrow> word1\"\nwhere\n\"get_icc_Z psr \\<equiv>\n  ucast (((AND) psr 0b00000000010000000000000000000000) >> 22)\n\""], ["", "definition get_icc_V :: \"word32 \\<Rightarrow> word1\"\nwhere\n\"get_icc_V psr \\<equiv>\n  ucast (((AND) psr 0b00000000001000000000000000000000) >> 21)\n\""], ["", "definition get_icc_C :: \"word32 \\<Rightarrow> word1\"\nwhere\n\"get_icc_C psr \\<equiv>\n  ucast (((AND) psr 0b00000000000100000000000000000000) >> 20)\n\""], ["", "definition update_S :: \"word1 \\<Rightarrow> word32 \\<Rightarrow> word32\"\nwhere\n\"update_S s_val psr_val \\<equiv>\n  let tmp0 = (AND) psr_val 0b11111111111111111111111101111111 in\n  (OR) tmp0 (((ucast s_val)::word32) << 7)\n\""], ["", "text \\<open>Update the CWP field of PSR. \n        Return the new value of PSR.\\<close>"], ["", "definition update_CWP :: \"word5 \\<Rightarrow> word32 \\<Rightarrow> word32\"\nwhere\n\"update_CWP cwp_val psr_val \\<equiv>\n  let tmp0 = (AND) psr_val (0b11111111111111111111111111100000::word32);\n      s_val = ((ucast (get_S psr_val))::word1)\n  in\n  if s_val = 0 then  \n    (AND) ((OR) tmp0 ((ucast cwp_val)::word32)) (0b11111111111111111111111101111111::word32)\n  else\n    (OR) ((OR) tmp0 ((ucast cwp_val)::word32)) (0b00000000000000000000000010000000::word32)\n\""], ["", "text \\<open>Update the the ET, CWP, and S fields of PSR. \n        Return the new value of PSR.\\<close>"], ["", "definition update_PSR_rett :: \"word5 \\<Rightarrow> word1 \\<Rightarrow> word1 \\<Rightarrow> word32 \\<Rightarrow> word32\"\nwhere\n\"update_PSR_rett cwp_val et_val s_val psr_val \\<equiv>\n  let tmp0 = (AND) psr_val 0b11111111111111111111111101000000;\n      tmp1 = (OR) tmp0 ((ucast cwp_val)::word32);\n      tmp2 = (OR) tmp1 (((ucast et_val)::word32) << 5); \n      tmp3 = (OR) tmp2 (((ucast s_val)::word32) << 7)\n  in  \n  tmp3\n\""], ["", "definition update_PSR_exe_trap :: \"word5 \\<Rightarrow> word1 \\<Rightarrow> word1 \\<Rightarrow> word32 \\<Rightarrow> word32\"\nwhere\n\"update_PSR_exe_trap cwp_val et_val ps_val psr_val \\<equiv>\n  let tmp0 = (AND) psr_val 0b11111111111111111111111110000000;\n      tmp1 = (OR) tmp0 ((ucast cwp_val)::word32);\n      tmp2 = (OR) tmp1 (((ucast et_val)::word32) << 5); \n      tmp3 = (OR) tmp2 (((ucast ps_val)::word32) << 6)\n  in  \n  tmp3\n\""], ["", "text \\<open>Update the N, Z, V, C fields of PSR. \n        Return the new value of PSR.\\<close>"], ["", "definition update_PSR_icc :: \"word1 \\<Rightarrow> word1 \\<Rightarrow> word1 \\<Rightarrow> word1 \\<Rightarrow> word32 \\<Rightarrow> word32\"\nwhere\n\"update_PSR_icc n_val z_val v_val c_val psr_val \\<equiv>\n  let\n      n_val_32 = if n_val = 0 then 0 \n                 else       (0b00000000100000000000000000000000::word32); \n      z_val_32 = if z_val = 0 then 0 \n                 else       (0b00000000010000000000000000000000::word32); \n      v_val_32 = if v_val = 0 then 0 \n                 else       (0b00000000001000000000000000000000::word32);\n      c_val_32 = if c_val = 0 then 0 \n                 else       (0b00000000000100000000000000000000::word32);\n      tmp0 = (AND) psr_val (0b11111111000011111111111111111111::word32);\n      tmp1 = (OR) tmp0 n_val_32;\n      tmp2 = (OR) tmp1 z_val_32;\n      tmp3 = (OR) tmp2 v_val_32;\n      tmp4 = (OR) tmp3 c_val_32\n  in\n  tmp4\n\""], ["", "text \\<open>Update the ET, PIL fields of PSR. \n        Return the new value of PSR.\\<close>"], ["", "definition update_PSR_et_pil :: \"word1 \\<Rightarrow> word4 \\<Rightarrow> word32 \\<Rightarrow> word32\"\nwhere\n\"update_PSR_et_pil et pil psr_val \\<equiv>\n  let tmp0 = (AND) psr_val 0b111111111111111111111000011011111;\n      tmp1 = (OR) tmp0 (((ucast et)::word32) << 5);\n      tmp2 = (OR) tmp1 (((ucast pil)::word32) << 8)\n  in\n  tmp2\n\""], ["", "text \\<open>\n   SPARC V8 architecture is organized in windows of 32 user registers.\n   The data stored in a register is defined as a 32 bits word @{term reg_type}:\n\\<close>"], ["", "type_synonym reg_type = \"word32\""], ["", "text \\<open>\n  The access to the value of a CPU register of type @{term CPU_register} is\n  defined by a total function @{term cpu_context}\n\\<close>"], ["", "type_synonym cpu_context = \"CPU_register \\<Rightarrow> reg_type\""], ["", "text \\<open>\n  User registers are defined with the type @{term user_reg} represented by a 5 bits word.\n\\<close>"], ["", "type_synonym user_reg_type = \"word5\""], ["", "definition PSR_S ::\"reg_type\"\nwhere \"PSR_S \\<equiv> 6\""], ["", "text \\<open>\n  Each window context is defined by a total function @{term window_context} from @{term user_register} \n  to @{term reg_type} (32 bits word storing the actual value of the register).\n\\<close>"], ["", "type_synonym window_context = \"user_reg_type \\<Rightarrow> reg_type\""], ["", "text \\<open>\n  The number of windows is implementation dependent. \n  The LEON architecture is composed of 16 different windows (a 4 bits word).\n\\<close>"], ["", "definition NWINDOWS :: \"int\"\nwhere \"NWINDOWS \\<equiv> 8\""], ["", "text \\<open>Maximum number of windows is 32 in SPARCv8.\\<close>"], ["", "type_synonym ('a) window_size = \"'a word\""], ["", "text \\<open>\nFinally the user context is defined by another total function @{term user_context} from \n@{term window_size} to @{term window_context}. That is, the user context is a function taking as\nargument a register set window and a register within that window, and it returns the value stored\nin that user register.\n\\<close>"], ["", "type_synonym ('a) user_context = \"('a) window_size \\<Rightarrow> window_context\""], ["", "datatype sys_reg = \n         CCR    \\<comment> \\<open>Cache control register\\<close>\n        |ICCR   \\<comment> \\<open>Instruction cache configuration register\\<close>\n        |DCCR   \\<comment> \\<open>Data cache configuration register\\<close>"], ["", "type_synonym sys_context = \"sys_reg \\<Rightarrow> reg_type\""], ["", "text\\<open>\nThe memory model is defined by a total function from 32 bits words to 8 bits words\n\\<close>"], ["", "type_synonym asi_type = \"word8\""], ["", "text \\<open>\n The memory is defined as a function from page address to page, which is also defined\n  as a function from physical address to @{term \"machine_word\"}\n\\<close>"], ["", "type_synonym mem_val_type = \"word8\""], ["", "type_synonym mem_context = \"asi_type \\<Rightarrow> phys_address \\<Rightarrow> mem_val_type option\""], ["", "type_synonym cache_tag = \"word20\""], ["", "type_synonym cache_line_size = \"word12\""], ["", "type_synonym cache_type = \"(cache_tag \\<times> cache_line_size)\""], ["", "type_synonym cache_context = \"cache_type \\<Rightarrow> mem_val_type option\""], ["", "text \\<open>The delayed-write pool generated from write state register instructions.\\<close>"], ["", "type_synonym delayed_write_pool = \"(int \\<times> reg_type \\<times> CPU_register) list\""], ["", "definition DELAYNUM :: \"int\"\nwhere \"DELAYNUM \\<equiv> 0\""], ["", "text \\<open>Convert a set to a list.\\<close>"], ["", "definition list_of_set :: \"'a set \\<Rightarrow> 'a list\"\n  where \"list_of_set s = (SOME l. set l = s)\""], ["", "lemma set_list_of_set: \"finite s \\<Longrightarrow> set (list_of_set s) = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite s \\<Longrightarrow> set (list_of_set s) = s", "unfolding list_of_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite s \\<Longrightarrow> set (SOME l. set l = s) = s", "by (metis (mono_tags) finite_list some_eq_ex)"], ["", "type_synonym ANNUL = \"bool\""], ["", "type_synonym RESET_TRAP = \"bool\""], ["", "type_synonym EXECUTE_MODE = \"bool\""], ["", "type_synonym RESET_MODE = \"bool\""], ["", "type_synonym ERROR_MODE = \"bool\""], ["", "type_synonym TICC_TRAP_TYPE = \"word7\""], ["", "type_synonym INTERRUPT_LEVEL = \"word3\""], ["", "type_synonym STORE_BARRIER_PENDING = \"bool\""], ["", "text \\<open>The processor asserts this signal to ensure that the\nmemory system will not process another SWAP or\nLDSTUB operation to the same memory byte.\\<close>"], ["", "type_synonym pb_block_ldst_byte = \"virtua_address \\<Rightarrow> bool\""], ["", "text\\<open>The processor asserts this signal to ensure that the\nmemory system will not process another SWAP or\nLDSTUB operation to the same memory word.\\<close>"], ["", "type_synonym pb_block_ldst_word = \"virtua_address \\<Rightarrow> bool\""], ["", "record sparc_state_var =\nannul:: ANNUL\nresett:: RESET_TRAP\nexe:: EXECUTE_MODE\nreset:: RESET_MODE\nerr:: ERROR_MODE\nticc:: TICC_TRAP_TYPE\nitrpt_lvl:: INTERRUPT_LEVEL\nst_bar:: STORE_BARRIER_PENDING\natm_ldst_byte:: pb_block_ldst_byte\natm_ldst_word:: pb_block_ldst_word"], ["", "definition get_annul :: \"sparc_state_var \\<Rightarrow> bool\"\nwhere \"get_annul v \\<equiv> annul v\""], ["", "definition get_reset_trap :: \"sparc_state_var \\<Rightarrow> bool\"\nwhere \"get_reset_trap v \\<equiv> resett v\""], ["", "definition get_exe_mode :: \"sparc_state_var \\<Rightarrow> bool\"\nwhere \"get_exe_mode v \\<equiv> exe v\""], ["", "definition get_reset_mode :: \"sparc_state_var \\<Rightarrow> bool\"\nwhere \"get_reset_mode v \\<equiv> reset v\""], ["", "definition get_err_mode :: \"sparc_state_var \\<Rightarrow> bool\"\nwhere \"get_err_mode v \\<equiv> err v\""], ["", "definition get_ticc_trap_type :: \"sparc_state_var \\<Rightarrow> word7\"\nwhere \"get_ticc_trap_type v \\<equiv> ticc v\""], ["", "definition get_interrupt_level :: \"sparc_state_var \\<Rightarrow> word3\"\nwhere \"get_interrupt_level v \\<equiv> itrpt_lvl v\""], ["", "definition get_store_barrier_pending :: \"sparc_state_var \\<Rightarrow> bool\"\nwhere \"get_store_barrier_pending v \\<equiv> st_bar v\""], ["", "definition write_annul :: \"bool \\<Rightarrow> sparc_state_var \\<Rightarrow> sparc_state_var\"\nwhere \"write_annul b v \\<equiv> v\\<lparr>annul := b\\<rparr>\""], ["", "definition write_reset_trap :: \"bool \\<Rightarrow> sparc_state_var \\<Rightarrow> sparc_state_var\"\nwhere \"write_reset_trap b v \\<equiv> v\\<lparr>resett := b\\<rparr>\""], ["", "definition write_exe_mode :: \"bool \\<Rightarrow> sparc_state_var \\<Rightarrow> sparc_state_var\"\nwhere \"write_exe_mode b v \\<equiv> v\\<lparr>exe := b\\<rparr>\""], ["", "definition write_reset_mode :: \"bool \\<Rightarrow> sparc_state_var \\<Rightarrow> sparc_state_var\"\nwhere \"write_reset_mode b v \\<equiv> v\\<lparr>reset := b\\<rparr>\""], ["", "definition write_err_mode :: \"bool \\<Rightarrow> sparc_state_var \\<Rightarrow> sparc_state_var\"\nwhere \"write_err_mode b v \\<equiv> v\\<lparr>err := b\\<rparr>\""], ["", "definition write_ticc_trap_type :: \"word7 \\<Rightarrow> sparc_state_var \\<Rightarrow> sparc_state_var\"\nwhere \"write_ticc_trap_type w v \\<equiv> v\\<lparr>ticc := w\\<rparr>\""], ["", "definition write_interrupt_level :: \"word3 \\<Rightarrow> sparc_state_var \\<Rightarrow> sparc_state_var\"\nwhere \"write_interrupt_level w v \\<equiv> v\\<lparr>itrpt_lvl := w\\<rparr>\""], ["", "definition write_store_barrier_pending :: \"bool \\<Rightarrow> sparc_state_var \\<Rightarrow> sparc_state_var\"\nwhere \"write_store_barrier_pending b v \\<equiv> v\\<lparr>st_bar := b\\<rparr>\""], ["", "text \\<open>Given a word7 value, find the highest bit,\n        and fill the left bits to be the highest bit.\\<close>"], ["", "definition sign_ext7::\"word7 \\<Rightarrow> word32\"\nwhere\n\"sign_ext7 w \\<equiv> \n  let highest_bit = ((AND) w 0b1000000) >> 6 in\n  if highest_bit = 0 then\n    (ucast w)::word32\n  else (OR) ((ucast w)::word32) 0b11111111111111111111111110000000\n\""], ["", "definition zero_ext8 :: \"word8 \\<Rightarrow> word32\"\nwhere\n\"zero_ext8 w \\<equiv> (ucast w)::word32\n\""], ["", "text \\<open>Given a word8 value, find the highest bit,\n        and fill the left bits to be the highest bit.\\<close>"], ["", "definition sign_ext8::\"word8 \\<Rightarrow> word32\"\nwhere\n\"sign_ext8 w \\<equiv> \n  let highest_bit = ((AND) w 0b10000000) >> 7 in\n  if highest_bit = 0 then\n    (ucast w)::word32\n  else (OR) ((ucast w)::word32) 0b11111111111111111111111100000000\n\""], ["", "text \\<open>Given a word13 value, find the highest bit,\n        and fill the left bits to be the highest bit.\\<close>"], ["", "definition sign_ext13::\"word13 \\<Rightarrow> word32\"\nwhere\n\"sign_ext13 w \\<equiv> \n  let highest_bit = ((AND) w 0b1000000000000) >> 12 in\n  if highest_bit = 0 then\n    (ucast w)::word32\n  else (OR) ((ucast w)::word32) 0b11111111111111111110000000000000\n\""], ["", "definition zero_ext16 :: \"word16 \\<Rightarrow> word32\"\nwhere\n\"zero_ext16 w \\<equiv> (ucast w)::word32\n\""], ["", "text \\<open>Given a word16 value, find the highest bit,\n        and fill the left bits to be the highest bit.\\<close>"], ["", "definition sign_ext16::\"word16 \\<Rightarrow> word32\"\nwhere\n\"sign_ext16 w \\<equiv> \n  let highest_bit = ((AND) w 0b1000000000000000) >> 15 in\n  if highest_bit = 0 then\n    (ucast w)::word32\n  else (OR) ((ucast w)::word32) 0b11111111111111110000000000000000\n\""], ["", "text \\<open>Given a word22 value, find the highest bit,\n        and fill the left bits to tbe the highest bit.\\<close>"], ["", "definition sign_ext22::\"word22 \\<Rightarrow> word32\"\nwhere\n\"sign_ext22 w \\<equiv>\n  let highest_bit = ((AND) w 0b1000000000000000000000) >> 21 in\n  if highest_bit = 0 then\n    (ucast w)::word32\n  else (OR) ((ucast w)::word32) 0b11111111110000000000000000000000\n\""], ["", "text \\<open>Given a word24 value, find the highest bit,\n        and fill the left bits to tbe the highest bit.\\<close>"], ["", "definition sign_ext24::\"word24 \\<Rightarrow> word32\"\nwhere\n\"sign_ext24 w \\<equiv>\n  let highest_bit = ((AND) w 0b100000000000000000000000) >> 23 in\n  if highest_bit = 0 then\n    (ucast w)::word32\n  else (OR) ((ucast w)::word32) 0b11111111000000000000000000000000\n\""], ["", "text\\<open>\nOperations to be defined.\nThe SPARC V8 architecture is composed of the following set of instructions:\n  \\<^item> Load Integer Instructions\n  \\<^item> Load Floating-point Instructions\n  \\<^item> Load Coprocessor Instructions\n  \\<^item> Store Integer Instructions\n  \\<^item> Store Floating-point Instructions\n  \\<^item> Store Coprocessor Instructions\n  \\<^item> Atomic Load-Store Unsigned Byte Instructions\n  \\<^item> SWAP Register With Memory Instruction\n  \\<^item> SETHI Instructions\n  \\<^item> NOP Instruction\n  \\<^item> Logical Instructions\n  \\<^item> Shift Instructions\n  \\<^item> Add Instructions\n  \\<^item> Tagged Add Instructions\n  \\<^item> Subtract Instructions\n  \\<^item> Tagged Subtract Instructions\n  \\<^item> Multiply Step Instruction\n  \\<^item> Multiply Instructions\n  \\<^item> Divide Instructions\n  \\<^item> SAVE and RESTORE Instructions\n  \\<^item> Branch on Integer Condition Codes Instructions\n  \\<^item> Branch on Floating-point Condition Codes Instructions\n  \\<^item> Branch on Coprocessor Condition Codes Instructions\n  \\<^item> Call and Link Instruction\n  \\<^item> Jump and Link Instruction\n  \\<^item> Return from Trap Instruction\n  \\<^item> Trap on Integer Condition Codes Instructions\n  \\<^item> Read State Register Instructions\n  \\<^item> Write State Register Instructions\n  \\<^item> STBAR Instruction\n  \\<^item> Unimplemented Instruction\n  \\<^item> Flush Instruction Memory\n  \\<^item> Floating-point Operate (FPop) Instructions\n  \\<^item> Convert Integer to Floating point Instructions\n  \\<^item> Convert Floating point to Integer Instructions\n  \\<^item> Convert Between Floating-point Formats Instructions\n  \\<^item> Floating-point Move Instructions\n  \\<^item> Floating-point Square Root Instructions\n  \\<^item> Floating-point Add and Subtract Instructions\n  \\<^item> Floating-point Multiply and Divide Instructions\n  \\<^item> Floating-point Compare Instructions\n  \\<^item> Coprocessor Operate Instructions\n\\<close>"], ["", "text \\<open>The CALL instruction.\\<close>"], ["", "datatype call_type = CALL \\<comment> \\<open>Call and Link\\<close>"], ["", "text \\<open>The SETHI instruction.\\<close>"], ["", "datatype sethi_type = SETHI    \\<comment> \\<open>Set High 22 bits of r Register\\<close>"], ["", "text \\<open>The NOP instruction.\\<close>"], ["", "datatype nop_type = NOP      \\<comment> \\<open>No Operation\\<close>"], ["", "text \\<open>The Branch on integer condition codes instructions.\\<close>"], ["", "datatype bicc_type = \n  BE       \\<comment> \\<open>Branch on Equal\\<close>\n | BNE      \\<comment> \\<open>Branch on Not Equal\\<close>\n | BGU      \\<comment> \\<open>Branch on Greater Unsigned\\<close>\n | BLE      \\<comment> \\<open>Branch on Less or Equal\\<close>\n | BL       \\<comment> \\<open>Branch on Less\\<close>\n | BGE      \\<comment> \\<open>Branch on Greater or Equal\\<close>\n | BNEG     \\<comment> \\<open>Branch on Negative\\<close>\n | BG       \\<comment> \\<open>Branch on Greater\\<close>\n | BCS      \\<comment> \\<open>Branch on Carry Set (Less than, Unsigned)\\<close>\n | BLEU     \\<comment> \\<open>Branch on Less or Equal Unsigned\\<close>\n | BCC      \\<comment> \\<open>Branch on Carry Clear (Greater than or Equal, Unsigned)\\<close>\n | BA       \\<comment> \\<open>Branch Always\\<close>\n | BN       \\<comment> \\<open>Branch Never\\<close> \\<comment> \\<open>Added for unconditional branches\\<close>\n | BPOS     \\<comment> \\<open>Branch on Positive\\<close>\n | BVC      \\<comment> \\<open>Branch on Overflow Clear\\<close>\n | BVS      \\<comment> \\<open>Branch on Overflow Set\\<close>"], ["", "text \\<open>Memory instructions. That is, load and store.\\<close>"], ["", "datatype load_store_type =\n  LDSB     \\<comment> \\<open>Load Signed Byte\\<close>\n | LDUB     \\<comment> \\<open>Load Unsigned Byte\\<close>\n | LDUBA    \\<comment> \\<open>Load Unsigned Byte from Alternate space\\<close>\n | LDUH     \\<comment> \\<open>Load Unsigned Halfword\\<close>\n | LD       \\<comment> \\<open>Load Word\\<close>\n | LDA      \\<comment> \\<open>Load Word from Alternate space\\<close>\n | LDD      \\<comment> \\<open>Load Doubleword\\<close>\n | STB      \\<comment> \\<open>Store Byte\\<close>\n | STH      \\<comment> \\<open>Store Halfword\\<close>\n | ST       \\<comment> \\<open>Store Word\\<close>\n | STA      \\<comment> \\<open>Store Word into Alternate space\\<close>\n | STD      \\<comment> \\<open>Store Doubleword\\<close>\n | LDSBA    \\<comment> \\<open>Load Signed Byte from Alternate space\\<close>\n | LDSH     \\<comment> \\<open>Load Signed Halfword\\<close>\n | LDSHA    \\<comment> \\<open>Load Signed Halfword from Alternate space\\<close>\n | LDUHA    \\<comment> \\<open>Load Unsigned Halfword from Alternate space\\<close>\n | LDDA     \\<comment> \\<open>Load Doubleword from Alternate space\\<close>\n | STBA     \\<comment> \\<open>Store Byte into Alternate space\\<close>\n | STHA     \\<comment> \\<open>Store Halfword into Alternate space\\<close>\n | STDA     \\<comment> \\<open>Store Doubleword into Alternate space\\<close>\n | LDSTUB   \\<comment> \\<open>Atomic Load Store Unsigned Byte\\<close>\n | LDSTUBA  \\<comment> \\<open>Atomic Load Store Unsinged Byte in Alternate space\\<close>\n | SWAP     \\<comment> \\<open>Swap r Register with Mmemory\\<close>\n | SWAPA    \\<comment> \\<open>Swap r Register with Mmemory in Alternate space\\<close>\n | FLUSH    \\<comment> \\<open>Flush Instruction Memory\\<close>\n | STBAR    \\<comment> \\<open>Store Barrier\\<close>"], ["", "text \\<open>Arithmetic instructions.\\<close>"], ["", "datatype arith_type =\n  ADD      \\<comment> \\<open>Add\\<close>\n | ADDcc    \\<comment> \\<open>Add and modify icc\\<close>\n | ADDX     \\<comment> \\<open>Add with Carry\\<close>\n | SUB      \\<comment> \\<open>Subtract\\<close>\n | SUBcc    \\<comment> \\<open>Subtract and modify icc\\<close>\n | SUBX     \\<comment> \\<open>Subtract with Carry\\<close>\n | UMUL     \\<comment> \\<open>Unsigned Integer Multiply\\<close>\n | SMUL     \\<comment> \\<open>Signed Integer Multiply\\<close>\n | SMULcc   \\<comment> \\<open>Signed Integer Multiply and modify icc\\<close>\n | UDIV     \\<comment> \\<open>Unsigned Integer Divide\\<close>\n | UDIVcc   \\<comment> \\<open>Unsigned Integer Divide and modify icc\\<close>\n | SDIV     \\<comment> \\<open>Signed Integer Divide\\<close> \n | ADDXcc   \\<comment> \\<open>Add with Carry and modify icc\\<close>\n | TADDcc   \\<comment> \\<open>Tagged Add and modify icc\\<close>\n | TADDccTV \\<comment> \\<open>Tagged Add and modify icc and Trap on overflow\\<close>\n | SUBXcc   \\<comment> \\<open>Subtract with Carry and modify icc\\<close>\n | TSUBcc   \\<comment> \\<open>Tagged Subtract and modify icc\\<close>\n | TSUBccTV \\<comment> \\<open>Tagged Subtract and modify icc and Trap on overflow\\<close>\n | MULScc   \\<comment> \\<open>Multiply Step and modify icc\\<close>\n | UMULcc   \\<comment> \\<open>Unsigned Integer Multiply and modify icc\\<close>\n | SDIVcc   \\<comment> \\<open>Signed Integer Divide and modify icc\\<close>"], ["", "text \\<open>Logical instructions.\\<close>"], ["", "datatype logic_type =\n  ANDs      \\<comment> \\<open>And\\<close>\n | ANDcc    \\<comment> \\<open>And and modify icc\\<close>\n | ANDN     \\<comment> \\<open>And Not\\<close>\n | ANDNcc   \\<comment> \\<open>And Not and modify icc\\<close>\n | ORs       \\<comment> \\<open>Inclusive-Or\\<close>\n | ORcc     \\<comment> \\<open>Inclusive-Or and modify icc\\<close>\n | ORN      \\<comment> \\<open>Inclusive Or Not\\<close>\n | XORs      \\<comment> \\<open>Exclusive-Or\\<close>\n | XNOR     \\<comment> \\<open>Exclusive-Nor\\<close>\n | ORNcc    \\<comment> \\<open>Inclusive-Or Not and modify icc\\<close>\n | XORcc    \\<comment> \\<open>Exclusive-Or and modify icc\\<close>\n | XNORcc   \\<comment> \\<open>Exclusive-Nor and modify icc\\<close>"], ["", "text \\<open>Shift instructions.\\<close>"], ["", "datatype shift_type =\n  SLL      \\<comment> \\<open>Shift Left Logical\\<close>\n | SRL      \\<comment> \\<open>Shift Right Logical\\<close>\n | SRA      \\<comment> \\<open>Shift Right Arithmetic\\<close>"], ["", "text \\<open>Other Control-transfer instructions.\\<close>"], ["", "datatype ctrl_type = \n  JMPL     \\<comment> \\<open>Jump and Link\\<close>\n | RETT     \\<comment> \\<open>Return from Trap\\<close>\n | SAVE     \\<comment> \\<open>Save caller's window\\<close>\n | RESTORE  \\<comment> \\<open>Restore caller's window\\<close>"], ["", "text \\<open>Access state registers instructions.\\<close>"], ["", "datatype sreg_type =\n  RDASR    \\<comment> \\<open>Read Ancillary State Register\\<close>\n | RDY      \\<comment> \\<open>Read Y Register\\<close>\n | RDPSR    \\<comment> \\<open>Read Processor State Register\\<close>\n | RDWIM    \\<comment> \\<open>Read Window Invalid Mask Register\\<close>\n | RDTBR    \\<comment> \\<open>Read Trap Base Regiser\\<close>\n | WRASR    \\<comment> \\<open>Write Ancillary State Register\\<close>\n | WRY      \\<comment> \\<open>Write Y Register\\<close>\n | WRPSR    \\<comment> \\<open>Write Processor State Register\\<close>\n | WRWIM    \\<comment> \\<open>Write Window Invalid Mask Register\\<close>\n | WRTBR    \\<comment> \\<open>Write Trap Base Register\\<close>"], ["", "text \\<open>Unimplemented instruction.\\<close>"], ["", "datatype uimp_type = UNIMP    \\<comment> \\<open>Unimplemented\\<close>"], ["", "text \\<open>Trap on integer condition code instructions.\\<close>"], ["", "datatype ticc_type =\n TA       \\<comment> \\<open>Trap Always\\<close>\n | TN       \\<comment> \\<open>Trap Never\\<close>\n | TNE      \\<comment> \\<open>Trap on Not Equal\\<close>\n | TE       \\<comment> \\<open>Trap on Equal\\<close>\n | TG       \\<comment> \\<open>Trap on Greater\\<close>\n | TLE      \\<comment> \\<open>Trap on Less or Equal\\<close>\n | TGE      \\<comment> \\<open>Trap on Greater or Equal\\<close>\n | TL       \\<comment> \\<open>Trap on Less\\<close>\n | TGU      \\<comment> \\<open>Trap on Greater Unsigned\\<close>\n | TLEU     \\<comment> \\<open>Trap on Less or Equal Unsigned\\<close>\n | TCC      \\<comment> \\<open>Trap on Carry Clear (Greater than or Equal, Unsigned)\\<close>\n | TCS      \\<comment> \\<open>Trap on Carry Set (Less Than, Unsigned)\\<close>\n | TPOS     \\<comment> \\<open>Trap on Postive\\<close>\n | TNEG     \\<comment> \\<open>Trap on Negative\\<close>\n | TVC      \\<comment> \\<open>Trap on Overflow Clear\\<close>\n | TVS      \\<comment> \\<open>Trap on Overflow Set\\<close>"], ["", "datatype sparc_operation =\n  call_type call_type\n | sethi_type sethi_type\n | nop_type nop_type\n | bicc_type bicc_type\n | load_store_type load_store_type\n | arith_type arith_type\n | logic_type logic_type\n | shift_type shift_type\n | ctrl_type ctrl_type\n | sreg_type sreg_type\n | uimp_type uimp_type\n | ticc_type ticc_type"], ["", "datatype Trap = \nreset \n|data_store_error\n|instruction_access_MMU_miss\n|instruction_access_error\n|r_register_access_error\n|instruction_access_exception\n|privileged_instruction\n|illegal_instruction\n|unimplemented_FLUSH\n|watchpoint_detected\n|fp_disabled\n|cp_disabled\n|window_overflow\n|window_underflow\n|mem_address_not_aligned\n|fp_exception\n|cp_exception\n|data_access_error\n|data_access_MMU_miss\n|data_access_exception\n|tag_overflow\n|division_by_zero\n|trap_instruction\n|interrupt_level_n"], ["", "datatype Exception =\n\\<comment> \\<open>The following are processor states that are not in the instruction model,\\<close>\n\\<comment> \\<open>but we MAY want to deal with these from hardware perspective.\\<close>\n\\<^cancel>\\<open>|execute_mode\\<close>\n\\<^cancel>\\<open>|reset_mode\\<close>\n\\<^cancel>\\<open>|error_mode\\<close>\n\\<comment> \\<open>The following are self-defined exceptions.\\<close>\ninvalid_cond_f2\n|invalid_op2_f2\n|illegal_instruction2 \\<comment> \\<open>when \\<open>i = 0\\<close> for load/store not from alternate space\\<close>\n|invalid_op3_f3_op11\n|case_impossible\n|invalid_op3_f3_op10\n|invalid_op_f3\n|unsupported_instruction\n|fetch_instruction_error\n|invalid_trap_cond"], ["", "end"]]}