{"file_name": "/home/qj213/afp-2021-10-22/thys/SPARCv8/lib/wp/DetMonad.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/SPARCv8", "problem_names": ["lemma simpler_gets_def: \"gets f = (\\<lambda>s. ((f s, s), False))\"", "lemma simpler_modify_def:\n  \"modify f = (\\<lambda>s. (((), f s), False))\"", "lemma return_bind [simp]: \"(return x >>= f) = f x\"", "lemma bind_return [simp]: \"(m >>= return) = m\"", "lemma bind_assoc: \n  fixes m :: \"('a,'b) det_monad\"\n  fixes f :: \"'b \\<Rightarrow> ('a,'c) det_monad\"\n  fixes g :: \"'c \\<Rightarrow> ('a,'d) det_monad\"\n  shows \"(m >>= f) >>= g  =  m >>= (\\<lambda>x. f x >>= g)\"", "lemma liftE_def2:\n  \"liftE f = (\\<lambda>s. ((\\<lambda>(v,s'). (Inr v, s'))  (fst (f s)), snd (f s)))\"", "lemma returnOk_bindE [simp]: \"(returnOk x >>=E f) = f x\"", "lemma lift_return [simp]:\n  \"lift (return \\<circ> Inr) = return\"", "lemma bindE_returnOk [simp]: \"(m >>=E returnOk) = m\"", "lemma bindE_assoc:\n  \"(m >>=E f) >>=E g = m >>=E (\\<lambda>x. f x >>=E g)\"", "lemma returnOk_liftE:\n  \"returnOk x = liftE (return x)\"", "lemma throwError_bindE [simp]:\n  \"(throwError E >>=E f) = throwError E\"", "lemma \"do x \\<leftarrow> return 1; \n          return (2::nat); \n          return x \n       od = \n       return 1 >>= \n       (\\<lambda>x. return (2::nat) >>= \n            K_bind (return x))\"", "lemma \"do x \\<leftarrow> return 1; \n          return 2; \n          return x \n       od = return 1\"", "lemma \"doE x \\<leftarrow> returnOk 1; \n           returnOk (2::nat); \n           returnOk x \n       odE =\n       returnOk 1 >>=E \n       (\\<lambda>x. returnOk (2::nat) >>=E \n            K_bind (returnOk x))\"", "lemma \"doE x \\<leftarrow> returnOk 1; \n           returnOk 2; \n           returnOk x \n       odE = returnOk 1\"", "lemma validE_NF_alt_def:\n  \"\\<lbrace> P \\<rbrace> B \\<lbrace> Q \\<rbrace>,\\<lbrace> E \\<rbrace>! = \\<lbrace> P \\<rbrace> B \\<lbrace> \\<lambda>v s. case v of Inl e \\<Rightarrow> E e s | Inr r \\<Rightarrow> Q r s \\<rbrace>!\""], "translations": [["", "lemma simpler_gets_def: \"gets f = (\\<lambda>s. ((f s, s), False))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gets f = (\\<lambda>s. ((f s, s), False))", "apply (simp add: gets_def return_def bind_def h1_def h2_def get_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma simpler_modify_def:\n  \"modify f = (\\<lambda>s. (((), f s), False))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. modify f = (\\<lambda>s. (((), f s), False))", "by (simp add: modify_def bind_def h1_def h2_def get_def put_def)"], ["", "text \\<open>Execute the given monad when the condition is true, \n  return \\<open>()\\<close> otherwise.\\<close>"], ["", "definition\n  when1 :: \"bool \\<Rightarrow> ('s, unit) det_monad \\<Rightarrow> \n           ('s, unit) det_monad\" where \n  \"when1 P m \\<equiv> if P then m else return ()\""], ["", "text \\<open>Execute the given monad unless the condition is true, \n  return \\<open>()\\<close> otherwise.\\<close>"], ["", "definition \n  unless :: \"bool \\<Rightarrow> ('s, unit) det_monad \\<Rightarrow> \n            ('s, unit) det_monad\" where\n  \"unless P m \\<equiv> when1 (\\<not>P) m\""], ["", "text \\<open>\n  Perform a test on the current state, performing the left monad if\n  the result is true or the right monad if the result is false.\n\\<close>"], ["", "definition\n  condition :: \"('s \\<Rightarrow> bool) \\<Rightarrow> ('s, 'r) det_monad \\<Rightarrow> ('s, 'r) det_monad \\<Rightarrow> ('s, 'r) det_monad\"\nwhere\n  \"condition P L R \\<equiv> \\<lambda>s. if (P s) then (L s) else (R s)\""], ["", "notation (output)\n  condition  (\"(condition (_)//  (_)//  (_))\" [1000,1000,1000] 1000)"], ["", "subsection \\<open>The Monad Laws\\<close>"], ["", "text \\<open>Each monad satisfies at least the following three laws.\\<close>"], ["", "text \\<open>@{term return} is absorbed at the left of a @{term bind}, \n  applying the return value directly:\\<close>"], ["", "lemma return_bind [simp]: \"(return x >>= f) = f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. return x >>= f = f x", "by (simp add: return_def bind_def h1_def h2_def)"], ["", "text \\<open>@{term return} is absorbed on the right of a @{term bind}\\<close>"], ["", "lemma bind_return [simp]: \"(m >>= return) = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m >>= return = m", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (m >>= return) x = m x", "apply (simp add: bind_def h1_def h2_def return_def split_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>@{term bind} is associative\\<close>"], ["", "lemma bind_assoc: \n  fixes m :: \"('a,'b) det_monad\"\n  fixes f :: \"'b \\<Rightarrow> ('a,'c) det_monad\"\n  fixes g :: \"'c \\<Rightarrow> ('a,'d) det_monad\"\n  shows \"(m >>= f) >>= g  =  m >>= (\\<lambda>x. f x >>= g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m >>= f >>= g = m >>= (\\<lambda>x. f x >>= g)", "apply (unfold bind_def h1_def h2_def Let_def split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s.\n        (fst (g (fst (fst (fst (f (fst (fst (m s))) (snd (fst (m s)))),\n                           snd (f (fst (fst (m s))) (snd (fst (m s)))) \\<or>\n                           snd (m s))))\n               (snd (fst (fst (f (fst (fst (m s))) (snd (fst (m s)))),\n                          snd (f (fst (fst (m s))) (snd (fst (m s)))) \\<or>\n                          snd (m s))))),\n         snd (g (fst (fst (fst (f (fst (fst (m s))) (snd (fst (m s)))),\n                           snd (f (fst (fst (m s))) (snd (fst (m s)))) \\<or>\n                           snd (m s))))\n               (snd (fst (fst (f (fst (fst (m s))) (snd (fst (m s)))),\n                          snd (f (fst (fst (m s))) (snd (fst (m s)))) \\<or>\n                          snd (m s))))) \\<or>\n         snd (fst (f (fst (fst (m s))) (snd (fst (m s)))),\n              snd (f (fst (fst (m s))) (snd (fst (m s)))) \\<or>\n              snd (m s)))) =\n    (\\<lambda>s.\n        (fst (fst (g (fst (fst (f (fst (fst (m s))) (snd (fst (m s))))))\n                    (snd (fst (f (fst (fst (m s))) (snd (fst (m s))))))),\n              snd (g (fst (fst (f (fst (fst (m s))) (snd (fst (m s))))))\n                    (snd (fst (f (fst (fst (m s)))\n                                (snd (fst (m s))))))) \\<or>\n              snd (f (fst (fst (m s))) (snd (fst (m s))))),\n         snd (fst (g (fst (fst (f (fst (fst (m s))) (snd (fst (m s))))))\n                    (snd (fst (f (fst (fst (m s))) (snd (fst (m s))))))),\n              snd (g (fst (fst (f (fst (fst (m s))) (snd (fst (m s))))))\n                    (snd (fst (f (fst (fst (m s)))\n                                (snd (fst (m s))))))) \\<or>\n              snd (f (fst (fst (m s))) (snd (fst (m s))))) \\<or>\n         snd (m s)))", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       (fst (g (fst (fst (fst (f (fst (fst (m s))) (snd (fst (m s)))),\n                          snd (f (fst (fst (m s))) (snd (fst (m s)))) \\<or>\n                          snd (m s))))\n              (snd (fst (fst (f (fst (fst (m s))) (snd (fst (m s)))),\n                         snd (f (fst (fst (m s))) (snd (fst (m s)))) \\<or>\n                         snd (m s))))),\n        snd (g (fst (fst (fst (f (fst (fst (m s))) (snd (fst (m s)))),\n                          snd (f (fst (fst (m s))) (snd (fst (m s)))) \\<or>\n                          snd (m s))))\n              (snd (fst (fst (f (fst (fst (m s))) (snd (fst (m s)))),\n                         snd (f (fst (fst (m s))) (snd (fst (m s)))) \\<or>\n                         snd (m s))))) \\<or>\n        snd (fst (f (fst (fst (m s))) (snd (fst (m s)))),\n             snd (f (fst (fst (m s))) (snd (fst (m s)))) \\<or> snd (m s))) =\n       (fst (fst (g (fst (fst (f (fst (fst (m s))) (snd (fst (m s))))))\n                   (snd (fst (f (fst (fst (m s))) (snd (fst (m s))))))),\n             snd (g (fst (fst (f (fst (fst (m s))) (snd (fst (m s))))))\n                   (snd (fst (f (fst (fst (m s)))\n                               (snd (fst (m s))))))) \\<or>\n             snd (f (fst (fst (m s))) (snd (fst (m s))))),\n        snd (fst (g (fst (fst (f (fst (fst (m s))) (snd (fst (m s))))))\n                   (snd (fst (f (fst (fst (m s))) (snd (fst (m s))))))),\n             snd (g (fst (fst (f (fst (fst (m s))) (snd (fst (m s))))))\n                   (snd (fst (f (fst (fst (m s)))\n                               (snd (fst (m s))))))) \\<or>\n             snd (f (fst (fst (m s))) (snd (fst (m s))))) \\<or>\n        snd (m s))", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "section \\<open>Adding Exceptions\\<close>"], ["", "text \\<open>\n  The type @{typ \"('s,'a) det_monad\"} gives us determinism and\n  failure. We now extend this monad with exceptional return values\n  that abort normal execution, but can be handled explicitly.\n  We use the sum type to indicate exceptions. \n\n  In @{typ \"('s, 'e + 'a) det_monad\"}, @{typ \"'s\"} is the state,\n  @{typ 'e} is an exception, and @{typ 'a} is a normal return value.\n\n  This new type itself forms a monad again. Since type classes in \n  Isabelle are not powerful enough to express the class of monads,\n  we provide new names for the @{term return} and @{term bind} functions\n  in this monad. We call them \\<open>returnOk\\<close> (for normal return values)\n  and \\<open>bindE\\<close> (for composition). We also define \\<open>throwError\\<close>\n  to return an exceptional value.\n\\<close>"], ["", "definition\n  returnOk :: \"'a \\<Rightarrow> ('s, 'e + 'a) det_monad\" where\n  \"returnOk \\<equiv> return o Inr\""], ["", "definition\n  throwError :: \"'e \\<Rightarrow> ('s, 'e + 'a) det_monad\" where\n  \"throwError \\<equiv> return o Inl\""], ["", "text \\<open>\n  Lifting a function over the exception type: if the input is an\n  exception, return that exception; otherwise continue execution.\n\\<close>"], ["", "definition\n  lift :: \"('a \\<Rightarrow> ('s, 'e + 'b) det_monad) \\<Rightarrow> \n           'e +'a \\<Rightarrow> ('s, 'e + 'b) det_monad\"\nwhere\n  \"lift f v \\<equiv> case v of Inl e \\<Rightarrow> throwError e\n                      | Inr v' \\<Rightarrow> f v'\""], ["", "text \\<open>\n  The definition of @{term bind} in the exception monad (new\n  name \\<open>bindE\\<close>): the same as normal @{term bind}, but \n  the right-hand side is skipped if the left-hand side\n  produced an exception.\n\\<close>"], ["", "definition\n  bindE :: \"('s, 'e + 'a) det_monad \\<Rightarrow> \n            ('a \\<Rightarrow> ('s, 'e + 'b) det_monad) \\<Rightarrow> \n            ('s, 'e + 'b) det_monad\"  (infixl \">>=E\" 60)\nwhere\n  \"bindE f g \\<equiv> bind f (lift g)\""], ["", "text \\<open>\n  Lifting a normal deterministic monad into the \n  exception monad is achieved by always returning its\n  result as normal result and never throwing an exception.\n\\<close>"], ["", "definition\n  liftE :: \"('s,'a) det_monad \\<Rightarrow> ('s, 'e+'a) det_monad\"\nwhere\n  \"liftE f \\<equiv> f >>= (\\<lambda>r. return (Inr r))\""], ["", "text \\<open>\n  Since the underlying type and \\<open>return\\<close> function changed, \n  we need new definitions for when and unless:\n\\<close>"], ["", "definition\n  whenE :: \"bool \\<Rightarrow> ('s, 'e + unit) det_monad \\<Rightarrow> \n            ('s, 'e + unit) det_monad\" \n  where\n  \"whenE P f \\<equiv> if P then f else returnOk ()\""], ["", "definition\n  unlessE :: \"bool \\<Rightarrow> ('s, 'e + unit) det_monad \\<Rightarrow> \n            ('s, 'e + unit) det_monad\" \n  where\n  \"unlessE P f \\<equiv> if P then returnOk () else f\""], ["", "text \\<open>\n  Throwing an exception when the parameter is @{term None}, otherwise\n  returning @{term \"v\"} for @{term \"Some v\"}.\n\\<close>"], ["", "definition\n  throw_opt :: \"'e \\<Rightarrow> 'a option \\<Rightarrow> ('s, 'e + 'a) det_monad\" where\n  \"throw_opt ex x \\<equiv> \n  case x of None \\<Rightarrow> throwError ex | Some v \\<Rightarrow> returnOk v\""], ["", "subsection \"Monad Laws for the Exception Monad\""], ["", "text \\<open>More direct definition of @{const liftE}:\\<close>"], ["", "lemma liftE_def2:\n  \"liftE f = (\\<lambda>s. ((\\<lambda>(v,s'). (Inr v, s'))  (fst (f s)), snd (f s)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liftE f =\n    (\\<lambda>s.\n        (case fst (f s) of (v, s') \\<Rightarrow> (Inr v, s'), snd (f s)))", "by (auto simp: Let_def liftE_def return_def split_def bind_def h1_def h2_def)"], ["", "text \\<open>Left @{const returnOk} absorbtion over @{term bindE}:\\<close>"], ["", "lemma returnOk_bindE [simp]: \"(returnOk x >>=E f) = f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. returnOk x >>=E f = f x", "apply (unfold bindE_def returnOk_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (return \\<circ> Inr) x >>= lift f = f x", "apply (clarsimp simp: lift_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lift_return [simp]:\n  \"lift (return \\<circ> Inr) = return\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift (return \\<circ> Inr) = return", "by (rule ext)\n     (simp add: lift_def throwError_def split: sum.splits)"], ["", "text \\<open>Right @{const returnOk} absorbtion over @{term bindE}:\\<close>"], ["", "lemma bindE_returnOk [simp]: \"(m >>=E returnOk) = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m >>=E returnOk = m", "by (simp add: bindE_def returnOk_def)"], ["", "text \\<open>Associativity of @{const bindE}:\\<close>"], ["", "lemma bindE_assoc:\n  \"(m >>=E f) >>=E g = m >>=E (\\<lambda>x. f x >>=E g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m >>=E f >>=E g = m >>=E (\\<lambda>x. f x >>=E g)", "apply (simp add: bindE_def bind_assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m >>= (\\<lambda>x. lift f x >>= lift g) =\n    m >>= lift (\\<lambda>x. f x >>= lift g)", "apply (rule arg_cong [where f=\"\\<lambda>x. m >>= x\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. lift f x >>= lift g) = lift (\\<lambda>x. f x >>= lift g)", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. lift f x >>= lift g = lift (\\<lambda>x. f x >>= lift g) x", "apply (case_tac x, simp_all add: lift_def throwError_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>@{const returnOk} could also be defined via @{const liftE}:\\<close>"], ["", "lemma returnOk_liftE:\n  \"returnOk x = liftE (return x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. returnOk x = liftE (return x)", "by (simp add: liftE_def returnOk_def)"], ["", "text \\<open>Execution after throwing an exception is skipped:\\<close>"], ["", "lemma throwError_bindE [simp]:\n  \"(throwError E >>=E f) = throwError E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. throwError E >>=E f = throwError E", "by (simp add: bindE_def bind_def h1_def h2_def throwError_def lift_def return_def)"], ["", "section \"Syntax\""], ["", "text \\<open>This section defines traditional Haskell-like do-syntax \n  for the state monad in Isabelle.\\<close>"], ["", "subsection \"Syntax for the Nondeterministic State Monad\""], ["", "text \\<open>We use \\<open>K_bind\\<close> to syntactically indicate the \n  case where the return argument of the left side of a @{term bind}\n  is ignored\\<close>"], ["", "definition\n  K_bind_def [iff]: \"K_bind \\<equiv> \\<lambda>x y. x\""], ["", "nonterminal\n  dobinds and dobind and nobind"], ["", "syntax\n  \"_dobind\"    :: \"[pttrn, 'a] => dobind\"             (\"(_ \\<leftarrow>/ _)\" 10)\n  \"\"           :: \"dobind => dobinds\"                 (\"_\")\n  \"_nobind\"    :: \"'a => dobind\"                      (\"_\")\n  \"_dobinds\"   :: \"[dobind, dobinds] => dobinds\"      (\"(_);//(_)\")\n\n  \"_do\"        :: \"[dobinds, 'a] => 'a\"               (\"(do ((_);//(_))//od)\" 100)"], ["", "translations\n  \"_do (_dobinds b bs) e\"  == \"_do b (_do bs e)\"\n  \"_do (_nobind b) e\"      == \"b >>= (CONST K_bind e)\"\n  \"do x \\<leftarrow> a; e od\"        == \"a >>= (\\<lambda>x. e)\""], ["", "text \\<open>Syntax examples:\\<close>"], ["", "lemma \"do x \\<leftarrow> return 1; \n          return (2::nat); \n          return x \n       od = \n       return 1 >>= \n       (\\<lambda>x. return (2::nat) >>= \n            K_bind (return x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. do x \\<leftarrow> return (1::'b);\n       return 2;\n       return x\n    od =\n    do x \\<leftarrow> return (1::'b);\n       return 2;\n       return x\n    od", "by (rule refl)"], ["", "lemma \"do x \\<leftarrow> return 1; \n          return 2; \n          return x \n       od = return 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. do x \\<leftarrow> return (1::'b);\n       return (2::'c);\n       return x\n    od =\n    return (1::'b)", "by simp"], ["", "subsection \"Syntax for the Exception Monad\""], ["", "text \\<open>\n  Since the exception monad is a different type, we\n  need to syntactically distinguish it in the syntax.\n  We use \\<open>doE\\<close>/\\<open>odE\\<close> for this, but can re-use\n  most of the productions from \\<open>do\\<close>/\\<open>od\\<close>\n  above.\n\\<close>"], ["", "syntax\n  \"_doE\" :: \"[dobinds, 'a] => 'a\"  (\"(doE ((_);//(_))//odE)\" 100)"], ["", "translations\n  \"_doE (_dobinds b bs) e\"  == \"_doE b (_doE bs e)\"\n  \"_doE (_nobind b) e\"      == \"b >>=E (CONST K_bind e)\"\n  \"doE x \\<leftarrow> a; e odE\"       == \"a >>=E (\\<lambda>x. e)\""], ["", "text \\<open>Syntax examples:\\<close>"], ["", "lemma \"doE x \\<leftarrow> returnOk 1; \n           returnOk (2::nat); \n           returnOk x \n       odE =\n       returnOk 1 >>=E \n       (\\<lambda>x. returnOk (2::nat) >>=E \n            K_bind (returnOk x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. doE x \\<leftarrow> returnOk (1::'c);\n        returnOk 2;\n        returnOk x\n    odE =\n    doE x \\<leftarrow> returnOk (1::'c);\n        returnOk 2;\n        returnOk x\n    odE", "by (rule refl)"], ["", "lemma \"doE x \\<leftarrow> returnOk 1; \n           returnOk 2; \n           returnOk x \n       odE = returnOk 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. doE x \\<leftarrow> returnOk (1::'c);\n        returnOk (2::'d);\n        returnOk x\n    odE =\n    returnOk (1::'c)", "by simp"], ["", "section \"Library of Monadic Functions and Combinators\""], ["", "text \\<open>Lifting a normal function into the monad type:\\<close>"], ["", "definition\n  liftM :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> ('s,'a) det_monad \\<Rightarrow> ('s, 'b) det_monad\"\nwhere\n  \"liftM f m \\<equiv> do x \\<leftarrow> m; return (f x) od\""], ["", "text \\<open>The same for the exception monad:\\<close>"], ["", "definition\n  liftME :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> ('s,'e+'a) det_monad \\<Rightarrow> ('s,'e+'b) det_monad\"\nwhere\n  \"liftME f m \\<equiv> doE x \\<leftarrow> m; returnOk (f x) odE\""], ["", "text \\<open>\n  Run a sequence of monads from left to right, ignoring return values.\\<close>"], ["", "definition\n  sequence_x :: \"('s, 'a) det_monad list \\<Rightarrow> ('s, unit) det_monad\" \nwhere\n  \"sequence_x xs \\<equiv> foldr (\\<lambda>x y. x >>= (\\<lambda>_. y)) xs (return ())\""], ["", "text \\<open>\n  Map a monadic function over a list by applying it to each element\n  of the list from left to right, ignoring return values.\n\\<close>"], ["", "definition\n  mapM_x :: \"('a \\<Rightarrow> ('s,'b) det_monad) \\<Rightarrow> 'a list \\<Rightarrow> ('s, unit) det_monad\"\nwhere\n  \"mapM_x f xs \\<equiv> sequence_x (map f xs)\""], ["", "text \\<open>\n  Map a monadic function with two parameters over two lists,\n  going through both lists simultaneously, left to right, ignoring\n  return values.\n\\<close>"], ["", "definition\n  zipWithM_x :: \"('a \\<Rightarrow> 'b \\<Rightarrow> ('s,'c) det_monad) \\<Rightarrow> \n                 'a list \\<Rightarrow> 'b list \\<Rightarrow> ('s, unit) det_monad\"\nwhere\n  \"zipWithM_x f xs ys \\<equiv> sequence_x (zipWith f xs ys)\""], ["", "text \\<open>The same three functions as above, but returning a list of\nreturn values instead of \\<open>unit\\<close>\\<close>"], ["", "definition\n  sequence :: \"('s, 'a) det_monad list \\<Rightarrow> ('s, 'a list) det_monad\" \nwhere\n  \"sequence xs \\<equiv> let mcons = (\\<lambda>p q. p >>= (\\<lambda>x. q >>= (\\<lambda>y. return (x#y))))\n                 in foldr mcons xs (return [])\""], ["", "definition\n  mapM :: \"('a \\<Rightarrow> ('s,'b) det_monad) \\<Rightarrow> 'a list \\<Rightarrow> ('s, 'b list) det_monad\"\nwhere\n  \"mapM f xs \\<equiv> sequence (map f xs)\""], ["", "definition\n  zipWithM :: \"('a \\<Rightarrow> 'b \\<Rightarrow> ('s,'c) det_monad) \\<Rightarrow> \n                 'a list \\<Rightarrow> 'b list \\<Rightarrow> ('s, 'c list) det_monad\"\nwhere\n  \"zipWithM f xs ys \\<equiv> sequence (zipWith f xs ys)\""], ["", "definition\n  foldM :: \"('b \\<Rightarrow> 'a \\<Rightarrow> ('s, 'a) det_monad) \\<Rightarrow> 'b list \\<Rightarrow> 'a \\<Rightarrow> ('s, 'a) det_monad\" \nwhere\n  \"foldM m xs a \\<equiv> foldr (\\<lambda>p q. q >>= m p) xs (return a) \""], ["", "text \\<open>The sequence and map functions above for the exception monad,\nwith and without lists of return value\\<close>"], ["", "definition\n  sequenceE_x :: \"('s, 'e+'a) det_monad list \\<Rightarrow> ('s, 'e+unit) det_monad\" \nwhere\n  \"sequenceE_x xs \\<equiv> foldr (\\<lambda>x y. doE _ \\<leftarrow> x; y odE) xs (returnOk ())\""], ["", "definition\n  mapME_x :: \"('a \\<Rightarrow> ('s,'e+'b) det_monad) \\<Rightarrow> 'a list \\<Rightarrow> \n              ('s,'e+unit) det_monad\"\nwhere\n  \"mapME_x f xs \\<equiv> sequenceE_x (map f xs)\""], ["", "definition\n  sequenceE :: \"('s, 'e+'a) det_monad list \\<Rightarrow> ('s, 'e+'a list) det_monad\" \nwhere\n  \"sequenceE xs \\<equiv> let mcons = (\\<lambda>p q. p >>=E (\\<lambda>x. q >>=E (\\<lambda>y. returnOk (x#y))))\n                 in foldr mcons xs (returnOk [])\""], ["", "definition\n  mapME :: \"('a \\<Rightarrow> ('s,'e+'b) det_monad) \\<Rightarrow> 'a list \\<Rightarrow> \n              ('s,'e+'b list) det_monad\"\nwhere\n  \"mapME f xs \\<equiv> sequenceE (map f xs)\""], ["", "text \\<open>Filtering a list using a monadic function as predicate:\\<close>"], ["", "primrec\n  filterM :: \"('a \\<Rightarrow> ('s, bool) det_monad) \\<Rightarrow> 'a list \\<Rightarrow> ('s, 'a list) det_monad\"\nwhere\n  \"filterM P []       = return []\"\n| \"filterM P (x # xs) = do\n     b  \\<leftarrow> P x;\n     ys \\<leftarrow> filterM P xs; \n     return (if b then (x # ys) else ys)\n   od\""], ["", "section \"Catching and Handling Exceptions\""], ["", "text \\<open>\n  Turning an exception monad into a normal state monad\n  by catching and handling any potential exceptions:\n\\<close>"], ["", "definition\n  catch :: \"('s, 'e + 'a) det_monad \\<Rightarrow>\n            ('e \\<Rightarrow> ('s, 'a) det_monad) \\<Rightarrow>\n            ('s, 'a) det_monad\" (infix \"<catch>\" 10)\nwhere\n  \"f <catch> handler \\<equiv>\n     do x \\<leftarrow> f;\n        case x of\n          Inr b \\<Rightarrow> return b\n        | Inl e \\<Rightarrow> handler e\n     od\""], ["", "text \\<open>\n  Handling exceptions, but staying in the exception monad.\n  The handler may throw a type of exceptions different from\n  the left side.\n\\<close>"], ["", "definition\n  handleE' :: \"('s, 'e1 + 'a) det_monad \\<Rightarrow>\n               ('e1 \\<Rightarrow> ('s, 'e2 + 'a) det_monad) \\<Rightarrow>\n               ('s, 'e2 + 'a) det_monad\" (infix \"<handle2>\" 10)\nwhere\n  \"f <handle2> handler \\<equiv>\n   do\n      v \\<leftarrow> f;\n      case v of\n        Inl e \\<Rightarrow> handler e\n      | Inr v' \\<Rightarrow> return (Inr v')\n   od\""], ["", "text \\<open>\n  A type restriction of the above that is used more commonly in\n  practice: the exception handle (potentially) throws exception\n  of the same type as the left-hand side.\n\\<close>"], ["", "definition\n  handleE :: \"('s, 'x + 'a) det_monad \\<Rightarrow> \n              ('x \\<Rightarrow> ('s, 'x + 'a) det_monad) \\<Rightarrow> \n              ('s, 'x + 'a) det_monad\" (infix \"<handle>\" 10)\nwhere\n  \"handleE \\<equiv> handleE'\""], ["", "text \\<open>\n  Handling exceptions, and additionally providing a continuation\n  if the left-hand side throws no exception:\n\\<close>"], ["", "definition\n  handle_elseE :: \"('s, 'e + 'a) det_monad \\<Rightarrow>\n                   ('e \\<Rightarrow> ('s, 'ee + 'b) det_monad) \\<Rightarrow>\n                   ('a \\<Rightarrow> ('s, 'ee + 'b) det_monad) \\<Rightarrow>\n                   ('s, 'ee + 'b) det_monad\"\n  (\"_ <handle> _ <else> _\" 10)\nwhere\n  \"f <handle> handler <else> continue \\<equiv>\n   do v \\<leftarrow> f;\n   case v of Inl e  \\<Rightarrow> handler e\n           | Inr v' \\<Rightarrow> continue v'\n   od\""], ["", "section \"Hoare Logic\""], ["", "subsection \"Validity\""], ["", "text \\<open>This section defines a Hoare logic for partial correctness for\n  the deterministic state monad as well as the exception monad.\n  The logic talks only about the behaviour part of the monad and ignores\n  the failure flag.\n\n  The logic is defined semantically. Rules work directly on the\n  validity predicate.\n\n  In the deterministic state monad, validity is a triple of precondition,\n  monad, and postcondition. The precondition is a function from state to \n  bool (a state predicate), the postcondition is a function from return value\n  to state to bool. A triple is valid if for all states that satisfy the\n  precondition, all result values and result states that are returned by\n  the monad satisfy the postcondition. Note that if the computation returns\n  the empty set, the triple is trivially valid. This means @{term \"assert P\"} \n  does not require us to prove that @{term P} holds, but rather allows us\n  to assume @{term P}! Proving non-failure is done via separate predicate and\n  calculus (see below).\n\\<close>"], ["", "definition\n  valid :: \"('s \\<Rightarrow> bool) \\<Rightarrow> ('s,'a) det_monad \\<Rightarrow> ('a \\<Rightarrow> 's \\<Rightarrow> bool) \\<Rightarrow> bool\" \n  (\"\\<lbrace>_\\<rbrace>/ _ /\\<lbrace>_\\<rbrace>\")\nwhere\n  \"\\<lbrace>P\\<rbrace> f \\<lbrace>Q\\<rbrace> \\<equiv> \\<forall>s. P s \\<longrightarrow> (\\<forall>r s'. ((r,s') = fst (f s) \\<longrightarrow> Q r s'))\""], ["", "text \\<open>\n  Validity for the exception monad is similar and build on the standard \n  validity above. Instead of one postcondition, we have two: one for\n  normal and one for exceptional results.\n\\<close>"], ["", "definition\n  validE :: \"('s \\<Rightarrow> bool) \\<Rightarrow> ('s, 'a + 'b) det_monad \\<Rightarrow> \n             ('b \\<Rightarrow> 's \\<Rightarrow> bool) \\<Rightarrow> \n             ('a \\<Rightarrow> 's \\<Rightarrow> bool) \\<Rightarrow> bool\" \n(\"\\<lbrace>_\\<rbrace>/ _ /(\\<lbrace>_\\<rbrace>,/ \\<lbrace>_\\<rbrace>)\")\nwhere\n  \"\\<lbrace>P\\<rbrace> f \\<lbrace>Q\\<rbrace>,\\<lbrace>E\\<rbrace> \\<equiv> \\<lbrace>P\\<rbrace> f \\<lbrace> \\<lambda>v s. case v of Inr r \\<Rightarrow> Q r s | Inl e \\<Rightarrow> E e s \\<rbrace>\""], ["", "text \\<open>\n  The following two instantiations are convenient to separate reasoning\n  for exceptional and normal case.\n\\<close>"], ["", "definition\n  validE_R :: \"('s \\<Rightarrow> bool) \\<Rightarrow> ('s, 'e + 'a) det_monad \\<Rightarrow> \n               ('a \\<Rightarrow> 's \\<Rightarrow> bool) \\<Rightarrow> bool\"\n   (\"\\<lbrace>_\\<rbrace>/ _ /\\<lbrace>_\\<rbrace>, -\")\nwhere\n \"\\<lbrace>P\\<rbrace> f \\<lbrace>Q\\<rbrace>,- \\<equiv> validE P f Q (\\<lambda>x y. True)\""], ["", "definition\n  validE_E :: \"('s \\<Rightarrow> bool) \\<Rightarrow>  ('s, 'e + 'a) det_monad \\<Rightarrow> \n               ('e \\<Rightarrow> 's \\<Rightarrow> bool) \\<Rightarrow> bool\"\n   (\"\\<lbrace>_\\<rbrace>/ _ /-, \\<lbrace>_\\<rbrace>\")\nwhere\n \"\\<lbrace>P\\<rbrace> f -,\\<lbrace>Q\\<rbrace> \\<equiv> validE P f (\\<lambda>x y. True) Q\""], ["", "text \\<open>Abbreviations for trivial preconditions:\\<close>"], ["", "abbreviation(input)\n  top :: \"'a \\<Rightarrow> bool\" (\"\\<top>\")\nwhere\n  \"\\<top> \\<equiv> \\<lambda>_. True\""], ["", "abbreviation(input)\n  bottom :: \"'a \\<Rightarrow> bool\" (\"\\<bottom>\")\nwhere\n  \"\\<bottom> \\<equiv> \\<lambda>_. False\""], ["", "text \\<open>Abbreviations for trivial postconditions (taking two arguments):\\<close>"], ["", "abbreviation(input)\n  toptop :: \"'a \\<Rightarrow> 'b \\<Rightarrow> bool\" (\"\\<top>\\<top>\")\nwhere\n \"\\<top>\\<top> \\<equiv> \\<lambda>_ _. True\""], ["", "abbreviation(input)\n  botbot :: \"'a \\<Rightarrow> 'b \\<Rightarrow> bool\" (\"\\<bottom>\\<bottom>\")\nwhere\n \"\\<bottom>\\<bottom> \\<equiv> \\<lambda>_ _. False\""], ["", "text \\<open>\n  Lifting \\<open>\\<and>\\<close> and \\<open>\\<or>\\<close> over two arguments. \n  Lifting \\<open>\\<and>\\<close> and \\<open>\\<or>\\<close> over one argument is already\n  defined (written \\<open>and\\<close> and \\<open>or\\<close>).\n\\<close>"], ["", "definition\n  bipred_conj :: \"('a \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> 'b \\<Rightarrow> bool)\" \n  (infixl \"And\" 96)\nwhere\n  \"bipred_conj P Q \\<equiv> \\<lambda>x y. P x y \\<and> Q x y\""], ["", "definition\n  bipred_disj :: \"('a \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> 'b \\<Rightarrow> bool)\" \n  (infixl \"Or\" 91)\nwhere\n  \"bipred_disj P Q \\<equiv> \\<lambda>x y. P x y \\<or> Q x y\""], ["", "subsection \"Determinism\""], ["", "text \\<open>A monad of type \\<open>det_monad\\<close> is deterministic iff it\nreturns exactly one state and result and does not fail\\<close>"], ["", "definition\n  det :: \"('a,'s) det_monad \\<Rightarrow> bool\"\nwhere\n  \"det f \\<equiv> \\<forall>s. \\<exists>r. f s = (r,False)\""], ["", "text \\<open>A deterministic \\<open>det_monad\\<close> can be turned\n  into a normal state monad:\\<close>"], ["", "definition\n  the_run_state :: \"('s,'a) det_monad \\<Rightarrow> 's \\<Rightarrow> 'a \\<times> 's\"\nwhere\n  \"the_run_state M \\<equiv> \\<lambda>s. THE s'. fst (M s) = s'\""], ["", "subsection \"Non-Failure\""], ["", "text \\<open>\n  With the failure flag, we can formulate non-failure separately\n  from validity. A monad \\<open>m\\<close> does not fail under precondition\n  \\<open>P\\<close>, if for no start state in that precondition it sets\n  the failure flag.\n\\<close>"], ["", "definition\n  no_fail :: \"('s \\<Rightarrow> bool) \\<Rightarrow> ('s,'a) det_monad \\<Rightarrow> bool\"\nwhere\n  \"no_fail P m \\<equiv> \\<forall>s. P s \\<longrightarrow> \\<not> (snd (m s))\""], ["", "text \\<open>\n  It is often desired to prove non-failure and a Hoare triple\n  simultaneously, as the reasoning is often similar. The following\n  definitions allow such reasoning to take place.\n\\<close>"], ["", "definition\n  validNF ::\"('s \\<Rightarrow> bool) \\<Rightarrow> ('s,'a) det_monad \\<Rightarrow> ('a \\<Rightarrow> 's \\<Rightarrow> bool) \\<Rightarrow> bool\"\n      (\"\\<lbrace>_\\<rbrace>/ _ /\\<lbrace>_\\<rbrace>!\")\nwhere\n  \"validNF P f Q \\<equiv> valid P f Q \\<and> no_fail P f\""], ["", "definition\n  validE_NF :: \"('s \\<Rightarrow> bool) \\<Rightarrow> ('s, 'a + 'b) det_monad \\<Rightarrow>\n             ('b \\<Rightarrow> 's \\<Rightarrow> bool) \\<Rightarrow>\n             ('a \\<Rightarrow> 's \\<Rightarrow> bool) \\<Rightarrow> bool\"\n  (\"\\<lbrace>_\\<rbrace>/ _ /(\\<lbrace>_\\<rbrace>,/ \\<lbrace>_\\<rbrace>!)\")\nwhere\n  \"validE_NF P f Q E \\<equiv> validE P f Q E \\<and> no_fail P f\""], ["", "lemma validE_NF_alt_def:\n  \"\\<lbrace> P \\<rbrace> B \\<lbrace> Q \\<rbrace>,\\<lbrace> E \\<rbrace>! = \\<lbrace> P \\<rbrace> B \\<lbrace> \\<lambda>v s. case v of Inl e \\<Rightarrow> E e s | Inr r \\<Rightarrow> Q r s \\<rbrace>!\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>P\\<rbrace> B \\<lbrace>Q\\<rbrace>, \\<lbrace>E\\<rbrace>! =\n    \\<lbrace>P\\<rbrace> B \n    \\<lbrace>\\<lambda>v s.\n                case v of Inl e \\<Rightarrow> E e s\n                | Inr r \\<Rightarrow> Q r s\\<rbrace>!", "by (clarsimp simp: validE_NF_def validE_def validNF_def)"], ["", "section \"Basic exception reasoning\""], ["", "text \\<open>\n  The following predicates \\<open>no_throw\\<close> and \\<open>no_return\\<close> allow\n  reasoning that functions in the exception monad either do\n  no throw an exception or never return normally.\n\\<close>"], ["", "definition \"no_throw P A \\<equiv> \\<lbrace> P \\<rbrace> A \\<lbrace> \\<lambda>_ _. True \\<rbrace>,\\<lbrace> \\<lambda>_ _. False \\<rbrace>\""], ["", "definition \"no_return P A \\<equiv> \\<lbrace> P \\<rbrace> A \\<lbrace>\\<lambda>_ _. False\\<rbrace>,\\<lbrace>\\<lambda>_ _. True \\<rbrace>\""], ["", "end"]]}