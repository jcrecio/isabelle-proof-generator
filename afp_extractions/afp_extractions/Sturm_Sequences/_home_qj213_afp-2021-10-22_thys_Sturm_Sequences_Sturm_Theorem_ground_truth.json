{"file_name": "/home/qj213/afp-2021-10-22/thys/Sturm_Sequences/Sturm_Theorem.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Sturm_Sequences", "problem_names": ["lemma sign_changes_distrib:\n  \"poly p x \\<noteq> 0 \\<Longrightarrow>\n      sign_changes (ps\\<^sub>1 @ [p] @ ps\\<^sub>2) x =\n      sign_changes (ps\\<^sub>1 @ [p]) x + sign_changes ([p] @ ps\\<^sub>2) x\"", "lemma sign_changes_cong:\n  assumes \"length ps = length ps'\"\n  assumes \"\\<forall>i < length ps. sgn (poly (ps!i) x) = sgn (poly (ps'!i) y)\"\n  shows \"sign_changes ps x = sign_changes ps' y\"", "lemma sign_changes_cong':\n  assumes \"\\<forall>p \\<in> set ps. sgn (poly p x) = sgn (poly p y)\"\n  shows \"sign_changes ps x = sign_changes ps y\"", "lemma sign_changes_sturm_triple:\n  assumes \"poly p x \\<noteq> 0\" and \"sgn (poly r x) = - sgn (poly p x)\"\n  shows \"sign_changes [p,q,r] x = 1\"", "lemma quasi_sturm_seq: \"quasi_sturm_seq ps\"", "lemma ps_first_two:\n    obtains q ps' where \"ps = p # q # ps'\"", "lemma ps_first: \"ps ! 0 = p\"", "lemma [simp]: \"p \\<in> set ps\"", "lemma [simp]: \"\\<not>quasi_sturm_seq []\"", "lemma quasi_sturm_seq_Cons:\n  assumes \"quasi_sturm_seq (p#ps)\" and \"ps \\<noteq> []\"\n  shows \"quasi_sturm_seq ps\"", "lemma sturm_adjacent_root_aux:\n  assumes \"i < length (ps :: real poly list) - 1\"\n  assumes \"poly (ps ! i) x = 0\" and \"poly (ps ! (i + 1)) x = 0\"\n  assumes \"\\<And>i x. \\<lbrakk>i < length ps - 2; poly (ps ! (i+1)) x = 0\\<rbrakk>\n                   \\<Longrightarrow> sgn (poly (ps ! (i+2)) x) = - sgn (poly (ps ! i) x)\"\n  shows \"\\<forall>j\\<le>i+1. poly (ps ! j) x = 0\"", "lemma (in quasi_sturm_seq) split_sign_changes_subset[dest]:\n  \"ps' \\<in> set (split_sign_changes ps x) \\<Longrightarrow> set ps' \\<subseteq> set ps\"", "lemma (in quasi_sturm_seq) split_sign_changes_induct:\n  \"\\<lbrakk>\\<And>p x. P [p] x; \\<And>p q x. quasi_sturm_seq [p,q] \\<Longrightarrow> P [p,q] x;\n    \\<And>p q r ps x. quasi_sturm_seq (p#q#r#ps) \\<Longrightarrow>\n       \\<lbrakk>poly p x \\<noteq> 0 \\<Longrightarrow> poly q x = 0 \\<Longrightarrow> P (r#ps) x;\n        poly q x \\<noteq> 0 \\<Longrightarrow> P (q#r#ps) x;\n        poly p x = 0 \\<Longrightarrow> P (q#r#ps) x\\<rbrakk>\n           \\<Longrightarrow> P (p#q#r#ps) x\\<rbrakk> \\<Longrightarrow> P ps x\"", "lemma (in quasi_sturm_seq) split_sign_changes_correct:\n  assumes \"poly (hd ps) x\\<^sub>0 \\<noteq> 0\"\n  defines \"sign_changes' \\<equiv> \\<lambda>ps x.\n               \\<Sum>ps'\\<leftarrow>split_sign_changes ps x. sign_changes ps' x\"\n  shows \"sign_changes' ps x\\<^sub>0 = sign_changes ps x\\<^sub>0\"", "lemma (in quasi_sturm_seq) split_sign_changes_correct_nbh:\n  assumes \"poly (hd ps) x\\<^sub>0 \\<noteq> 0\"\n  defines \"sign_changes' \\<equiv> \\<lambda>x\\<^sub>0 ps x.\n               \\<Sum>ps'\\<leftarrow>split_sign_changes ps x\\<^sub>0. sign_changes ps' x\"\n  shows \"eventually (\\<lambda>x. sign_changes' x\\<^sub>0 ps x = sign_changes ps x) (at x\\<^sub>0)\"", "lemma (in quasi_sturm_seq) hd_nonzero_imp_sign_changes_const_aux:\n  assumes \"poly (hd ps) x\\<^sub>0 \\<noteq> 0\" and \"ps' \\<in> set (split_sign_changes ps x\\<^sub>0)\"\n  shows \"eventually (\\<lambda>x. sign_changes ps' x = sign_changes ps' x\\<^sub>0) (at x\\<^sub>0)\"", "lemma (in quasi_sturm_seq) hd_nonzero_imp_sign_changes_const:\n  assumes \"poly (hd ps) x\\<^sub>0 \\<noteq> 0\"\n  shows \"eventually (\\<lambda>x. sign_changes ps x = sign_changes ps x\\<^sub>0) (at x\\<^sub>0)\"", "lemma (in sturm_seq) p_nonzero_imp_sign_changes_const:\n  \"poly p x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n       eventually (\\<lambda>x. sign_changes ps x = sign_changes ps x\\<^sub>0) (at x\\<^sub>0)\"", "lemma (in sturm_seq) p_zero:\n  assumes \"poly p x\\<^sub>0 = 0\" \"p \\<noteq> 0\"\n  shows \"eventually (\\<lambda>x. sign_changes ps x =\n      sign_changes ps x\\<^sub>0 + (if x<x\\<^sub>0 then 1 else 0)) (at x\\<^sub>0)\"", "lemma count_roots_between_aux:\n  assumes \"a \\<le> b\"\n  assumes \"\\<forall>x::real. a < x \\<and> x \\<le> b \\<longrightarrow> eventually (\\<lambda>\\<xi>. f \\<xi> = (f x::nat)) (at x)\"\n  shows \"\\<forall>x. a < x \\<and> x \\<le> b \\<longrightarrow> f x = f b\"", "theorem (in sturm_seq) count_roots_between:\n  assumes [simp]: \"p \\<noteq> 0\" \"a \\<le> b\"\n  shows \"sign_changes ps a - sign_changes ps b =\n             card {x. x > a \\<and> x \\<le> b \\<and> poly p x = 0}\"", "lemma (in sturm_seq) count_roots_above:\n  assumes \"p \\<noteq> 0\"\n  shows \"sign_changes ps a - sign_changes_inf ps =\n             card {x. x > a \\<and> poly p x = 0}\"", "lemma (in sturm_seq) count_roots_below:\n  assumes \"p \\<noteq> 0\"\n  shows \"sign_changes_neg_inf ps - sign_changes ps a =\n             card {x. x \\<le> a \\<and> poly p x = 0}\"", "lemma (in sturm_seq) count_roots:\n  assumes \"p \\<noteq> 0\"\n  shows \"sign_changes_neg_inf ps - sign_changes_inf ps =\n             card {x. poly p x = 0}\"", "lemma degree_mod_less': \"degree q \\<noteq> 0 \\<Longrightarrow> degree (p mod q) < degree q\"", "lemma sturm_0[simp]: \"sturm 0 = [0,0]\"", "lemma [simp]: \"sturm_aux p q = [] \\<longleftrightarrow> False\"", "lemma sturm_neq_Nil[simp]: \"sturm p \\<noteq> []\"", "lemma [simp]: \"hd (sturm p) = p\"", "lemma [simp]: \"p \\<in> set (sturm p)\"", "lemma [simp]: \"length (sturm p) \\<ge> 2\"", "lemma [simp]: \"degree (last (sturm p)) = 0\"", "lemma [simp]: \"sturm_aux p q ! 0 = p\"", "lemma [simp]: \"sturm_aux p q ! Suc 0 = q\"", "lemma [simp]: \"sturm p ! 0 = p\"", "lemma [simp]: \"sturm p ! Suc 0 = pderiv p\"", "lemma sturm_indices:\n  assumes \"i < length (sturm p) - 2\"\n  shows \"sturm p!(i+2) = -(sturm p!i mod sturm p!(i+1))\"", "lemma sturm_aux_gcd: \"r \\<in> set (sturm_aux p q) \\<Longrightarrow> gcd p q dvd r\"", "lemma sturm_gcd: \"r \\<in> set (sturm p) \\<Longrightarrow> gcd p (pderiv p) dvd r\"", "lemma sturm_adjacent_root_propagate_left:\n  assumes \"i < length (sturm (p :: real poly)) - 1\"\n  assumes \"poly (sturm p ! i) x = 0\"\n      and \"poly (sturm p ! (i + 1)) x = 0\"\n  shows \"\\<forall>j\\<le>i+1. poly (sturm p ! j) x = 0\"", "lemma sturm_adjacent_root_not_squarefree:\n  assumes \"i < length (sturm (p :: real poly)) - 1\"\n          \"poly (sturm p ! i) x = 0\" \"poly (sturm p ! (i + 1)) x = 0\"\n  shows \"\\<not>rsquarefree p\"", "lemma sturm_firsttwo_signs_aux:\n  assumes \"(p :: real poly) \\<noteq> 0\" \"q \\<noteq> 0\"\n  assumes q_pderiv:\n      \"eventually (\\<lambda>x. sgn (poly q x) = sgn (poly (pderiv p) x)) (at x\\<^sub>0)\"\n  assumes p_0: \"poly p (x\\<^sub>0::real) = 0\"\n  shows \"eventually (\\<lambda>x. sgn (poly (p*q) x) = (if x > x\\<^sub>0 then 1 else -1)) (at x\\<^sub>0)\"", "lemma sturm_firsttwo_signs:\n  fixes ps :: \"real poly list\"\n  assumes squarefree: \"rsquarefree p\"\n  assumes p_0: \"poly p (x\\<^sub>0::real) = 0\"\n  shows \"eventually (\\<lambda>x. sgn (poly (p * sturm p ! 1) x) =\n             (if x > x\\<^sub>0 then 1 else -1)) (at x\\<^sub>0)\"", "lemma sturm_signs:\n  assumes squarefree: \"rsquarefree p\"\n  assumes i_in_range: \"i < length (sturm (p :: real poly)) - 2\"\n  assumes q_0: \"poly (sturm p ! (i+1)) x = 0\" (is \"poly ?q x = 0\")\n  shows \"poly (sturm p ! (i+2)) x * poly (sturm p ! i) x < 0\"\n            (is \"poly ?p x * poly ?r x < 0\")", "lemma sturm_seq_sturm[simp]:\n   assumes \"rsquarefree p\"\n   shows \"sturm_seq (sturm p) p\"", "lemma sturm_squarefree_not_Nil[simp]: \"sturm_squarefree p \\<noteq> []\"", "lemma sturm_seq_sturm_squarefree:\n  assumes [simp]: \"p \\<noteq> 0\"\n  defines [simp]: \"p' \\<equiv> p div gcd p (pderiv p)\"\n  shows \"sturm_seq (sturm_squarefree p) p'\"", "lemma sturm_squarefree'_adjacent_root_propagate_left:\n  assumes \"p \\<noteq> 0\"\n  assumes \"i < length (sturm_squarefree' (p :: real poly)) - 1\"\n  assumes \"poly (sturm_squarefree' p ! i) x = 0\"\n      and \"poly (sturm_squarefree' p ! (i + 1)) x = 0\"\n  shows \"\\<forall>j\\<le>i+1. poly (sturm_squarefree' p ! j) x = 0\"", "lemma sturm_squarefree'_adjacent_roots:\n  assumes \"p \\<noteq> 0\"\n           \"i < length (sturm_squarefree' (p :: real poly)) - 1\"\n          \"poly (sturm_squarefree' p ! i) x = 0\"\n          \"poly (sturm_squarefree' p ! (i + 1)) x = 0\"\n  shows False", "lemma sturm_squarefree'_signs:\n  assumes \"p \\<noteq> 0\"\n  assumes i_in_range: \"i < length (sturm_squarefree' (p :: real poly)) - 2\"\n  assumes q_0: \"poly (sturm_squarefree' p ! (i+1)) x = 0\" (is \"poly ?q x = 0\")\n  shows \"poly (sturm_squarefree' p ! (i+2)) x *\n         poly (sturm_squarefree' p ! i) x < 0\"\n            (is \"poly ?r x * poly ?p x < 0\")", "lemma sturm_seq_sturm_squarefree':\n  assumes \"(p :: real poly) \\<noteq> 0\"\n  defines \"d \\<equiv> gcd p (pderiv p)\"\n  shows \"sturm_seq (sturm_squarefree' p) (p div d)\"\n      (is \"sturm_seq ?ps' ?p'\")", "lemma sign_changes_mult_aux:\n  assumes \"d \\<noteq> (0::real)\"\n  shows \"length (remdups_adj (filter (\\<lambda>x. x \\<noteq> 0) (map ((*) d \\<circ> f) xs))) =\n         length (remdups_adj (filter (\\<lambda>x. x \\<noteq> 0) (map f xs)))\"", "lemma sturm_sturm_squarefree'_same_sign_changes:\n  fixes p :: \"real poly\"\n  defines \"ps \\<equiv> sturm p\" and \"ps' \\<equiv> sturm_squarefree' p\"\n  shows \"poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n             sign_changes ps' x = sign_changes ps x\"\n        \"p \\<noteq> 0 \\<Longrightarrow> sign_changes_inf ps' = sign_changes_inf ps\"\n        \"p \\<noteq> 0 \\<Longrightarrow> sign_changes_neg_inf ps' = sign_changes_neg_inf ps\"", "lemma count_roots_between_correct:\n  \"count_roots_between p a b = card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}\"", "lemma count_roots_correct:\n  fixes p :: \"real poly\"\n  shows \"count_roots p = card {x. poly p x = 0}\" (is \"_ = card ?S\")", "lemma count_roots_above_correct:\n  fixes p :: \"real poly\"\n  shows \"count_roots_above p a = card {x. x > a \\<and> poly p x = 0}\"\n         (is \"_ = card ?S\")", "lemma count_roots_below_correct:\n  fixes p :: \"real poly\"\n  shows \"count_roots_below p a = card {x. x \\<le> a \\<and> poly p x = 0}\"\n         (is \"_ = card ?S\")", "lemma count_roots_between[code]:\n  \"count_roots_between p a b =\n     (let q = pderiv p\n       in if a > b \\<or> p = 0 then 0\n       else if (poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0) \\<and> (poly p b \\<noteq> 0 \\<or> poly q b \\<noteq> 0)\n            then (let ps = sturm p\n                   in sign_changes ps a - sign_changes ps b)\n            else (let ps = sturm_squarefree p\n                   in sign_changes ps a - sign_changes ps b))\"", "lemma count_roots_code[code]:\n  \"count_roots (p::real poly) =\n    (if p = 0 then 0\n     else let ps = sturm p\n           in sign_changes_neg_inf ps - sign_changes_inf ps)\"", "lemma count_roots_above_code[code]:\n  \"count_roots_above p a =\n     (let q = pderiv p\n       in if p = 0 then 0\n       else if poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0\n            then (let ps = sturm p\n                   in sign_changes ps a - sign_changes_inf ps)\n            else (let ps = sturm_squarefree p\n                   in sign_changes ps a - sign_changes_inf ps))\"", "lemma count_roots_below_code[code]:\n  \"count_roots_below p a =\n     (let q = pderiv p\n       in if p = 0 then 0\n       else if poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0\n            then (let ps = sturm p\n                   in sign_changes_neg_inf ps - sign_changes ps a)\n            else (let ps = sturm_squarefree p\n                   in sign_changes_neg_inf ps - sign_changes ps a))\""], "translations": [["", "lemma sign_changes_distrib:\n  \"poly p x \\<noteq> 0 \\<Longrightarrow>\n      sign_changes (ps\\<^sub>1 @ [p] @ ps\\<^sub>2) x =\n      sign_changes (ps\\<^sub>1 @ [p]) x + sign_changes ([p] @ ps\\<^sub>2) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p x \\<noteq> 0 \\<Longrightarrow>\n    sign_changes (ps\\<^sub>1 @ [p] @ ps\\<^sub>2) x =\n    sign_changes (ps\\<^sub>1 @ [p]) x + sign_changes ([p] @ ps\\<^sub>2) x", "by (simp add: sign_changes_def sgn_zero_iff, subst remdups_adj_append, simp)"], ["", "text \\<open>\n  The following two congruences state that the number of sign changes is the same\n  if all the involved signs are the same.\n\\<close>"], ["", "lemma sign_changes_cong:\n  assumes \"length ps = length ps'\"\n  assumes \"\\<forall>i < length ps. sgn (poly (ps!i) x) = sgn (poly (ps'!i) y)\"\n  shows \"sign_changes ps x = sign_changes ps' y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes ps x = sign_changes ps' y", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. sign_changes ps x = sign_changes ps' y", "from assms(2)"], ["proof (chain)\npicking this:\n  \\<forall>i<length ps. sgn (poly (ps ! i) x) = sgn (poly (ps' ! i) y)", "have A: \"map (\\<lambda>p. sgn (poly p x)) ps = map (\\<lambda>p. sgn (poly p y)) ps'\""], ["proof (prove)\nusing this:\n  \\<forall>i<length ps. sgn (poly (ps ! i) x) = sgn (poly (ps' ! i) y)\n\ngoal (1 subgoal):\n 1. map (\\<lambda>p. sgn (poly p x)) ps =\n    map (\\<lambda>p. sgn (poly p y)) ps'", "proof (induction rule: list_induct2[OF assms(1)])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>i<length [].\n       sgn (poly ([] ! i) x) = sgn (poly ([] ! i) y) \\<Longrightarrow>\n    map (\\<lambda>p. sgn (poly p x)) [] =\n    map (\\<lambda>p. sgn (poly p y)) []\n 2. \\<And>xa xs ya ys.\n       \\<lbrakk>length xs = length ys;\n        \\<forall>i<length xs.\n           sgn (poly (xs ! i) x) = sgn (poly (ys ! i) y) \\<Longrightarrow>\n        map (\\<lambda>p. sgn (poly p x)) xs =\n        map (\\<lambda>p. sgn (poly p y)) ys;\n        \\<forall>i<length (xa # xs).\n           sgn (poly ((xa # xs) ! i) x) =\n           sgn (poly ((ya # ys) ! i) y)\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>p. sgn (poly p x)) (xa # xs) =\n                         map (\\<lambda>p. sgn (poly p y)) (ya # ys)", "case 1"], ["proof (state)\nthis:\n  \\<forall>i<length []. sgn (poly ([] ! i) x) = sgn (poly ([] ! i) y)\n\ngoal (2 subgoals):\n 1. \\<forall>i<length [].\n       sgn (poly ([] ! i) x) = sgn (poly ([] ! i) y) \\<Longrightarrow>\n    map (\\<lambda>p. sgn (poly p x)) [] =\n    map (\\<lambda>p. sgn (poly p y)) []\n 2. \\<And>xa xs ya ys.\n       \\<lbrakk>length xs = length ys;\n        \\<forall>i<length xs.\n           sgn (poly (xs ! i) x) = sgn (poly (ys ! i) y) \\<Longrightarrow>\n        map (\\<lambda>p. sgn (poly p x)) xs =\n        map (\\<lambda>p. sgn (poly p y)) ys;\n        \\<forall>i<length (xa # xs).\n           sgn (poly ((xa # xs) ! i) x) =\n           sgn (poly ((ya # ys) ! i) y)\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>p. sgn (poly p x)) (xa # xs) =\n                         map (\\<lambda>p. sgn (poly p y)) (ya # ys)", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<length []. sgn (poly ([] ! i) x) = sgn (poly ([] ! i) y)", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>i<length []. sgn (poly ([] ! i) x) = sgn (poly ([] ! i) y)\n\ngoal (1 subgoal):\n 1. map (\\<lambda>p. sgn (poly p x)) [] =\n    map (\\<lambda>p. sgn (poly p y)) []", "by simp"], ["proof (state)\nthis:\n  map (\\<lambda>p. sgn (poly p x)) [] = map (\\<lambda>p. sgn (poly p y)) []\n\ngoal (1 subgoal):\n 1. \\<And>xa xs ya ys.\n       \\<lbrakk>length xs = length ys;\n        \\<forall>i<length xs.\n           sgn (poly (xs ! i) x) = sgn (poly (ys ! i) y) \\<Longrightarrow>\n        map (\\<lambda>p. sgn (poly p x)) xs =\n        map (\\<lambda>p. sgn (poly p y)) ys;\n        \\<forall>i<length (xa # xs).\n           sgn (poly ((xa # xs) ! i) x) =\n           sgn (poly ((ya # ys) ! i) y)\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>p. sgn (poly p x)) (xa # xs) =\n                         map (\\<lambda>p. sgn (poly p y)) (ya # ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xs ya ys.\n       \\<lbrakk>length xs = length ys;\n        \\<forall>i<length xs.\n           sgn (poly (xs ! i) x) = sgn (poly (ys ! i) y) \\<Longrightarrow>\n        map (\\<lambda>p. sgn (poly p x)) xs =\n        map (\\<lambda>p. sgn (poly p y)) ys;\n        \\<forall>i<length (xa # xs).\n           sgn (poly ((xa # xs) ! i) x) =\n           sgn (poly ((ya # ys) ! i) y)\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>p. sgn (poly p x)) (xa # xs) =\n                         map (\\<lambda>p. sgn (poly p y)) (ya # ys)", "case (2 p ps p' ps')"], ["proof (state)\nthis:\n  length ps = length ps'\n  \\<forall>i<length ps.\n     sgn (poly (ps ! i) x) = sgn (poly (ps' ! i) y) \\<Longrightarrow>\n  map (\\<lambda>p. sgn (poly p x)) ps = map (\\<lambda>p. sgn (poly p y)) ps'\n  \\<forall>i<length (p # ps).\n     sgn (poly ((p # ps) ! i) x) = sgn (poly ((p' # ps') ! i) y)\n\ngoal (1 subgoal):\n 1. \\<And>xa xs ya ys.\n       \\<lbrakk>length xs = length ys;\n        \\<forall>i<length xs.\n           sgn (poly (xs ! i) x) = sgn (poly (ys ! i) y) \\<Longrightarrow>\n        map (\\<lambda>p. sgn (poly p x)) xs =\n        map (\\<lambda>p. sgn (poly p y)) ys;\n        \\<forall>i<length (xa # xs).\n           sgn (poly ((xa # xs) ! i) x) =\n           sgn (poly ((ya # ys) ! i) y)\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>p. sgn (poly p x)) (xa # xs) =\n                         map (\\<lambda>p. sgn (poly p y)) (ya # ys)", "from 2(3)"], ["proof (chain)\npicking this:\n  \\<forall>i<length (p # ps).\n     sgn (poly ((p # ps) ! i) x) = sgn (poly ((p' # ps') ! i) y)", "have \"\\<forall>i<length ps. sgn (poly (ps ! i) x) =\n                         sgn (poly (ps' ! i) y)\""], ["proof (prove)\nusing this:\n  \\<forall>i<length (p # ps).\n     sgn (poly ((p # ps) ! i) x) = sgn (poly ((p' # ps') ! i) y)\n\ngoal (1 subgoal):\n 1. \\<forall>i<length ps. sgn (poly (ps ! i) x) = sgn (poly (ps' ! i) y)", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<length ps. sgn (poly (ps ! i) x) = sgn (poly (ps' ! i) y)\n\ngoal (1 subgoal):\n 1. \\<And>xa xs ya ys.\n       \\<lbrakk>length xs = length ys;\n        \\<forall>i<length xs.\n           sgn (poly (xs ! i) x) = sgn (poly (ys ! i) y) \\<Longrightarrow>\n        map (\\<lambda>p. sgn (poly p x)) xs =\n        map (\\<lambda>p. sgn (poly p y)) ys;\n        \\<forall>i<length (xa # xs).\n           sgn (poly ((xa # xs) ! i) x) =\n           sgn (poly ((ya # ys) ! i) y)\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>p. sgn (poly p x)) (xa # xs) =\n                         map (\\<lambda>p. sgn (poly p y)) (ya # ys)", "from 2(2)[OF this] 2(3)"], ["proof (chain)\npicking this:\n  map (\\<lambda>p. sgn (poly p x)) ps = map (\\<lambda>p. sgn (poly p y)) ps'\n  \\<forall>i<length (p # ps).\n     sgn (poly ((p # ps) ! i) x) = sgn (poly ((p' # ps') ! i) y)", "show ?case"], ["proof (prove)\nusing this:\n  map (\\<lambda>p. sgn (poly p x)) ps = map (\\<lambda>p. sgn (poly p y)) ps'\n  \\<forall>i<length (p # ps).\n     sgn (poly ((p # ps) ! i) x) = sgn (poly ((p' # ps') ! i) y)\n\ngoal (1 subgoal):\n 1. map (\\<lambda>p. sgn (poly p x)) (p # ps) =\n    map (\\<lambda>p. sgn (poly p y)) (p' # ps')", "by auto"], ["proof (state)\nthis:\n  map (\\<lambda>p. sgn (poly p x)) (p # ps) =\n  map (\\<lambda>p. sgn (poly p y)) (p' # ps')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map (\\<lambda>p. sgn (poly p x)) ps = map (\\<lambda>p. sgn (poly p y)) ps'\n\ngoal (1 subgoal):\n 1. sign_changes ps x = sign_changes ps' y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes ps x = sign_changes ps' y", "unfolding sign_changes_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (remdups_adj\n       (filter (\\<lambda>x. x \\<noteq> 0)\n         (map (\\<lambda>p. sgn (poly p x)) ps))) -\n    1 =\n    length\n     (remdups_adj\n       (filter (\\<lambda>x. x \\<noteq> 0)\n         (map (\\<lambda>p. sgn (poly p y)) ps'))) -\n    1", "by (simp add: A)"], ["proof (state)\nthis:\n  sign_changes ps x = sign_changes ps' y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sign_changes_cong':\n  assumes \"\\<forall>p \\<in> set ps. sgn (poly p x) = sgn (poly p y)\"\n  shows \"sign_changes ps x = sign_changes ps y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes ps x = sign_changes ps y", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set ps. sgn (poly p x) = sgn (poly p y)\n\ngoal (1 subgoal):\n 1. sign_changes ps x = sign_changes ps y", "by (intro sign_changes_cong, simp_all)"], ["", "text \\<open>\n  For a sequence of polynomials of length 3, if the first and the third\n  polynomial have opposite and nonzero sign at some $x$, the number of\n  sign changes is always 1, irrespective of the sign of the second\n  polynomial.\n\\<close>"], ["", "lemma sign_changes_sturm_triple:\n  assumes \"poly p x \\<noteq> 0\" and \"sgn (poly r x) = - sgn (poly p x)\"\n  shows \"sign_changes [p,q,r] x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes [p, q, r] x = 1", "unfolding sign_changes_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (remdups_adj\n       (filter (\\<lambda>x. x \\<noteq> 0)\n         (map (\\<lambda>p. sgn (poly p x)) [p, q, r]))) -\n    1 =\n    1", "by (insert assms, auto simp: sgn_real_def)"], ["", "text \\<open>\n  Finally, we define two additional functions that count the sign changes ``at infinity''.\n\\<close>"], ["", "definition sign_changes_inf where\n\"sign_changes_inf ps =\n    length (remdups_adj (filter (\\<lambda>x. x \\<noteq> 0) (map poly_inf ps))) - 1\""], ["", "definition sign_changes_neg_inf where\n\"sign_changes_neg_inf ps =\n    length (remdups_adj (filter (\\<lambda>x. x \\<noteq> 0) (map poly_neg_inf ps))) - 1\""], ["", "subsection \\<open>Definition of Sturm sequences locale\\<close>"], ["", "text \\<open>\n  We first define the notion of a ``Quasi-Sturm sequence'', which is a weakening of\n  a Sturm sequence that captures the properties that are fulfilled by a nonempty\n  suffix of a Sturm sequence:\n  \\begin{itemize}\n    \\item The sequence is nonempty.\n    \\item The last polynomial does not change its sign.\n    \\item If the middle one of three adjacent polynomials has a root at $x$, the other\n          two have opposite and nonzero signs at $x$.\n  \\end{itemize}\n\\<close>"], ["", "locale quasi_sturm_seq =\n  fixes ps :: \"(real poly) list\"\n  assumes last_ps_sgn_const[simp]:\n      \"\\<And>x y. sgn (poly (last ps) x) = sgn (poly (last ps) y)\"\n  assumes ps_not_Nil[simp]: \"ps \\<noteq> []\"\n  assumes signs: \"\\<And>i x. \\<lbrakk>i < length ps - 2; poly (ps ! (i+1)) x = 0\\<rbrakk>\n                     \\<Longrightarrow> (poly (ps ! (i+2)) x) * (poly (ps ! i) x) < 0\""], ["", "text \\<open>\n  Now we define a Sturm sequence $p_1,\\ldots,p_n$ of a polynomial $p$ in the following way:\n  \\begin{itemize}\n    \\item The sequence contains at least two elements.\n    \\item $p$ is the first polynomial, i.\\,e. $p_1 = p$.\n    \\item At any root $x$ of $p$, $p_2$ and $p$ have opposite sign left of $x$ and\n          the same sign right of $x$ in some neighbourhood around $x$.\n    \\item The first two polynomials in the sequence have no common roots.\n    \\item If the middle one of three adjacent polynomials has a root at $x$, the other\n          two have opposite and nonzero signs at $x$.\n  \\end{itemize}\n\\<close>"], ["", "locale sturm_seq = quasi_sturm_seq +\n  fixes p :: \"real poly\"\n  assumes hd_ps_p[simp]: \"hd ps = p\"\n  assumes length_ps_ge_2[simp]: \"length ps \\<ge> 2\"\n  assumes deriv: \"\\<And>x\\<^sub>0. poly p x\\<^sub>0 = 0 \\<Longrightarrow>\n      eventually (\\<lambda>x. sgn (poly (p * ps!1) x) =\n                      (if x > x\\<^sub>0 then 1 else -1)) (at x\\<^sub>0)\"\n  assumes p_squarefree: \"\\<And>x. \\<not>(poly p x = 0 \\<and> poly (ps!1) x = 0)\"\nbegin"], ["", "text \\<open>\n    Any Sturm sequence is obviously a Quasi-Sturm sequence.\n\\<close>"], ["", "lemma quasi_sturm_seq: \"quasi_sturm_seq ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quasi_sturm_seq ps", ".."], ["", "(*<*)"], ["", "lemma ps_first_two:\n    obtains q ps' where \"ps = p # q # ps'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q ps'.\n        ps = p # q # ps' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using hd_ps_p length_ps_ge_2"], ["proof (prove)\nusing this:\n  hd ps = p\n  2 \\<le> length ps\n\ngoal (1 subgoal):\n 1. (\\<And>q ps'.\n        ps = p # q # ps' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases ps, simp, clarsimp, rename_tac ps', case_tac ps', auto)"], ["", "lemma ps_first: \"ps ! 0 = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ps ! 0 = p", "by (rule ps_first_two, simp)"], ["", "lemma [simp]: \"p \\<in> set ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> set ps", "using hd_in_set[OF ps_not_Nil]"], ["proof (prove)\nusing this:\n  hd ps \\<in> set ps\n\ngoal (1 subgoal):\n 1. p \\<in> set ps", "by simp"], ["", "(*>*)"], ["", "end"], ["", "(*<*)"], ["", "lemma [simp]: \"\\<not>quasi_sturm_seq []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> quasi_sturm_seq []", "by (simp add: quasi_sturm_seq_def)"], ["", "(*>*)"], ["", "text \\<open>\n  Any suffix of a Quasi-Sturm sequence is again a Quasi-Sturm sequence.\n\\<close>"], ["", "lemma quasi_sturm_seq_Cons:\n  assumes \"quasi_sturm_seq (p#ps)\" and \"ps \\<noteq> []\"\n  shows \"quasi_sturm_seq ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quasi_sturm_seq ps", "proof (unfold_locales)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y. sgn (poly (last ps) x) = sgn (poly (last ps) y)\n 2. ps \\<noteq> []\n 3. \\<And>i x.\n       \\<lbrakk>i < length ps - 2; poly (ps ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (ps ! (i + 2)) x * poly (ps ! i) x < 0", "show \"ps \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ps \\<noteq> []", "by fact"], ["proof (state)\nthis:\n  ps \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>x y. sgn (poly (last ps) x) = sgn (poly (last ps) y)\n 2. \\<And>i x.\n       \\<lbrakk>i < length ps - 2; poly (ps ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (ps ! (i + 2)) x * poly (ps ! i) x < 0", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y. sgn (poly (last ps) x) = sgn (poly (last ps) y)\n 2. \\<And>i x.\n       \\<lbrakk>i < length ps - 2; poly (ps ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (ps ! (i + 2)) x * poly (ps ! i) x < 0", "from assms(1)"], ["proof (chain)\npicking this:\n  quasi_sturm_seq (p # ps)", "interpret quasi_sturm_seq \"p#ps\""], ["proof (prove)\nusing this:\n  quasi_sturm_seq (p # ps)\n\ngoal (1 subgoal):\n 1. quasi_sturm_seq (p # ps)", "."], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y. sgn (poly (last ps) x) = sgn (poly (last ps) y)\n 2. \\<And>i x.\n       \\<lbrakk>i < length ps - 2; poly (ps ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (ps ! (i + 2)) x * poly (ps ! i) x < 0", "fix x y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y. sgn (poly (last ps) x) = sgn (poly (last ps) y)\n 2. \\<And>i x.\n       \\<lbrakk>i < length ps - 2; poly (ps ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (ps ! (i + 2)) x * poly (ps ! i) x < 0", "from last_ps_sgn_const and \\<open>ps \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  sgn (poly (last (p # ps)) ?x) = sgn (poly (last (p # ps)) ?y)\n  ps \\<noteq> []", "show \"sgn (poly (last ps) x) = sgn (poly (last ps) y)\""], ["proof (prove)\nusing this:\n  sgn (poly (last (p # ps)) ?x) = sgn (poly (last (p # ps)) ?y)\n  ps \\<noteq> []\n\ngoal (1 subgoal):\n 1. sgn (poly (last ps) x) = sgn (poly (last ps) y)", "by simp_all"], ["proof (state)\nthis:\n  sgn (poly (last ps) x) = sgn (poly (last ps) y)\n\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i < length ps - 2; poly (ps ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (ps ! (i + 2)) x * poly (ps ! i) x < 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i < length ps - 2; poly (ps ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (ps ! (i + 2)) x * poly (ps ! i) x < 0", "from assms(1)"], ["proof (chain)\npicking this:\n  quasi_sturm_seq (p # ps)", "interpret quasi_sturm_seq \"p#ps\""], ["proof (prove)\nusing this:\n  quasi_sturm_seq (p # ps)\n\ngoal (1 subgoal):\n 1. quasi_sturm_seq (p # ps)", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i < length ps - 2; poly (ps ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (ps ! (i + 2)) x * poly (ps ! i) x < 0", "fix i x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i < length ps - 2; poly (ps ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (ps ! (i + 2)) x * poly (ps ! i) x < 0", "assume \"i < length ps - 2\" and \"poly (ps ! (i+1)) x = 0\""], ["proof (state)\nthis:\n  i < length ps - 2\n  poly (ps ! (i + 1)) x = 0\n\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i < length ps - 2; poly (ps ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (ps ! (i + 2)) x * poly (ps ! i) x < 0", "with signs[of \"i+1\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>i + 1 < length (p # ps) - 2;\n   poly ((p # ps) ! (i + 1 + 1)) ?x = 0\\<rbrakk>\n  \\<Longrightarrow> poly ((p # ps) ! (i + 1 + 2)) ?x *\n                    poly ((p # ps) ! (i + 1)) ?x\n                    < 0\n  i < length ps - 2\n  poly (ps ! (i + 1)) x = 0", "show \"poly (ps ! (i+2)) x * poly (ps ! i) x < 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>i + 1 < length (p # ps) - 2;\n   poly ((p # ps) ! (i + 1 + 1)) ?x = 0\\<rbrakk>\n  \\<Longrightarrow> poly ((p # ps) ! (i + 1 + 2)) ?x *\n                    poly ((p # ps) ! (i + 1)) ?x\n                    < 0\n  i < length ps - 2\n  poly (ps ! (i + 1)) x = 0\n\ngoal (1 subgoal):\n 1. poly (ps ! (i + 2)) x * poly (ps ! i) x < 0", "by simp"], ["proof (state)\nthis:\n  poly (ps ! (i + 2)) x * poly (ps ! i) x < 0\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Auxiliary lemmas about roots and sign changes\\<close>"], ["", "lemma sturm_adjacent_root_aux:\n  assumes \"i < length (ps :: real poly list) - 1\"\n  assumes \"poly (ps ! i) x = 0\" and \"poly (ps ! (i + 1)) x = 0\"\n  assumes \"\\<And>i x. \\<lbrakk>i < length ps - 2; poly (ps ! (i+1)) x = 0\\<rbrakk>\n                   \\<Longrightarrow> sgn (poly (ps ! (i+2)) x) = - sgn (poly (ps ! i) x)\"\n  shows \"\\<forall>j\\<le>i+1. poly (ps ! j) x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j\\<le>i + 1. poly (ps ! j) x = 0", "using assms"], ["proof (prove)\nusing this:\n  i < length ps - 1\n  poly (ps ! i) x = 0\n  poly (ps ! (i + 1)) x = 0\n  \\<lbrakk>?i < length ps - 2; poly (ps ! (?i + 1)) ?x = 0\\<rbrakk>\n  \\<Longrightarrow> sgn (poly (ps ! (?i + 2)) ?x) =\n                    - sgn (poly (ps ! ?i) ?x)\n\ngoal (1 subgoal):\n 1. \\<forall>j\\<le>i + 1. poly (ps ! j) x = 0", "proof (induction i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < length ps - 1; poly (ps ! 0) x = 0;\n     poly (ps ! (0 + 1)) x = 0;\n     \\<And>i x.\n        \\<lbrakk>i < length ps - 2; poly (ps ! (i + 1)) x = 0\\<rbrakk>\n        \\<Longrightarrow> sgn (poly (ps ! (i + 2)) x) =\n                          - sgn (poly (ps ! i) x)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>j\\<le>0 + 1. poly (ps ! j) x = 0\n 2. \\<And>i.\n       \\<lbrakk>\\<lbrakk>i < length ps - 1; poly (ps ! i) x = 0;\n                 poly (ps ! (i + 1)) x = 0;\n                 \\<And>i x.\n                    \\<lbrakk>i < length ps - 2;\n                     poly (ps ! (i + 1)) x = 0\\<rbrakk>\n                    \\<Longrightarrow> sgn (poly (ps ! (i + 2)) x) =\n- sgn (poly (ps ! i) x)\\<rbrakk>\n                \\<Longrightarrow> \\<forall>j\\<le>i + 1. poly (ps ! j) x = 0;\n        Suc i < length ps - 1; poly (ps ! Suc i) x = 0;\n        poly (ps ! (Suc i + 1)) x = 0;\n        \\<And>i x.\n           \\<lbrakk>i < length ps - 2; poly (ps ! (i + 1)) x = 0\\<rbrakk>\n           \\<Longrightarrow> sgn (poly (ps ! (i + 2)) x) =\n                             - sgn (poly (ps ! i) x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j\\<le>Suc i + 1. poly (ps ! j) x = 0", "case 0"], ["proof (state)\nthis:\n  0 < length ps - 1\n  poly (ps ! 0) x = 0\n  poly (ps ! (0 + 1)) x = 0\n  \\<lbrakk>?i < length ps - 2; poly (ps ! (?i + 1)) ?x = 0\\<rbrakk>\n  \\<Longrightarrow> sgn (poly (ps ! (?i + 2)) ?x) =\n                    - sgn (poly (ps ! ?i) ?x)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < length ps - 1; poly (ps ! 0) x = 0;\n     poly (ps ! (0 + 1)) x = 0;\n     \\<And>i x.\n        \\<lbrakk>i < length ps - 2; poly (ps ! (i + 1)) x = 0\\<rbrakk>\n        \\<Longrightarrow> sgn (poly (ps ! (i + 2)) x) =\n                          - sgn (poly (ps ! i) x)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>j\\<le>0 + 1. poly (ps ! j) x = 0\n 2. \\<And>i.\n       \\<lbrakk>\\<lbrakk>i < length ps - 1; poly (ps ! i) x = 0;\n                 poly (ps ! (i + 1)) x = 0;\n                 \\<And>i x.\n                    \\<lbrakk>i < length ps - 2;\n                     poly (ps ! (i + 1)) x = 0\\<rbrakk>\n                    \\<Longrightarrow> sgn (poly (ps ! (i + 2)) x) =\n- sgn (poly (ps ! i) x)\\<rbrakk>\n                \\<Longrightarrow> \\<forall>j\\<le>i + 1. poly (ps ! j) x = 0;\n        Suc i < length ps - 1; poly (ps ! Suc i) x = 0;\n        poly (ps ! (Suc i + 1)) x = 0;\n        \\<And>i x.\n           \\<lbrakk>i < length ps - 2; poly (ps ! (i + 1)) x = 0\\<rbrakk>\n           \\<Longrightarrow> sgn (poly (ps ! (i + 2)) x) =\n                             - sgn (poly (ps ! i) x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j\\<le>Suc i + 1. poly (ps ! j) x = 0", "thus ?case"], ["proof (prove)\nusing this:\n  0 < length ps - 1\n  poly (ps ! 0) x = 0\n  poly (ps ! (0 + 1)) x = 0\n  \\<lbrakk>?i < length ps - 2; poly (ps ! (?i + 1)) ?x = 0\\<rbrakk>\n  \\<Longrightarrow> sgn (poly (ps ! (?i + 2)) ?x) =\n                    - sgn (poly (ps ! ?i) ?x)\n\ngoal (1 subgoal):\n 1. \\<forall>j\\<le>0 + 1. poly (ps ! j) x = 0", "by (clarsimp, rename_tac j, case_tac j, simp_all)"], ["proof (state)\nthis:\n  \\<forall>j\\<le>0 + 1. poly (ps ! j) x = 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<lbrakk>i < length ps - 1; poly (ps ! i) x = 0;\n                 poly (ps ! (i + 1)) x = 0;\n                 \\<And>i x.\n                    \\<lbrakk>i < length ps - 2;\n                     poly (ps ! (i + 1)) x = 0\\<rbrakk>\n                    \\<Longrightarrow> sgn (poly (ps ! (i + 2)) x) =\n- sgn (poly (ps ! i) x)\\<rbrakk>\n                \\<Longrightarrow> \\<forall>j\\<le>i + 1. poly (ps ! j) x = 0;\n        Suc i < length ps - 1; poly (ps ! Suc i) x = 0;\n        poly (ps ! (Suc i + 1)) x = 0;\n        \\<And>i x.\n           \\<lbrakk>i < length ps - 2; poly (ps ! (i + 1)) x = 0\\<rbrakk>\n           \\<Longrightarrow> sgn (poly (ps ! (i + 2)) x) =\n                             - sgn (poly (ps ! i) x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j\\<le>Suc i + 1. poly (ps ! j) x = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<lbrakk>i < length ps - 1; poly (ps ! i) x = 0;\n                 poly (ps ! (i + 1)) x = 0;\n                 \\<And>i x.\n                    \\<lbrakk>i < length ps - 2;\n                     poly (ps ! (i + 1)) x = 0\\<rbrakk>\n                    \\<Longrightarrow> sgn (poly (ps ! (i + 2)) x) =\n- sgn (poly (ps ! i) x)\\<rbrakk>\n                \\<Longrightarrow> \\<forall>j\\<le>i + 1. poly (ps ! j) x = 0;\n        Suc i < length ps - 1; poly (ps ! Suc i) x = 0;\n        poly (ps ! (Suc i + 1)) x = 0;\n        \\<And>i x.\n           \\<lbrakk>i < length ps - 2; poly (ps ! (i + 1)) x = 0\\<rbrakk>\n           \\<Longrightarrow> sgn (poly (ps ! (i + 2)) x) =\n                             - sgn (poly (ps ! i) x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j\\<le>Suc i + 1. poly (ps ! j) x = 0", "case (Suc i)"], ["proof (state)\nthis:\n  \\<lbrakk>i < length ps - 1; poly (ps ! i) x = 0;\n   poly (ps ! (i + 1)) x = 0;\n   \\<And>i x.\n      \\<lbrakk>i < length ps - 2; poly (ps ! (i + 1)) x = 0\\<rbrakk>\n      \\<Longrightarrow> sgn (poly (ps ! (i + 2)) x) =\n                        - sgn (poly (ps ! i) x)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>j\\<le>i + 1. poly (ps ! j) x = 0\n  Suc i < length ps - 1\n  poly (ps ! Suc i) x = 0\n  poly (ps ! (Suc i + 1)) x = 0\n  \\<lbrakk>?i < length ps - 2; poly (ps ! (?i + 1)) ?x = 0\\<rbrakk>\n  \\<Longrightarrow> sgn (poly (ps ! (?i + 2)) ?x) =\n                    - sgn (poly (ps ! ?i) ?x)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<lbrakk>i < length ps - 1; poly (ps ! i) x = 0;\n                 poly (ps ! (i + 1)) x = 0;\n                 \\<And>i x.\n                    \\<lbrakk>i < length ps - 2;\n                     poly (ps ! (i + 1)) x = 0\\<rbrakk>\n                    \\<Longrightarrow> sgn (poly (ps ! (i + 2)) x) =\n- sgn (poly (ps ! i) x)\\<rbrakk>\n                \\<Longrightarrow> \\<forall>j\\<le>i + 1. poly (ps ! j) x = 0;\n        Suc i < length ps - 1; poly (ps ! Suc i) x = 0;\n        poly (ps ! (Suc i + 1)) x = 0;\n        \\<And>i x.\n           \\<lbrakk>i < length ps - 2; poly (ps ! (i + 1)) x = 0\\<rbrakk>\n           \\<Longrightarrow> sgn (poly (ps ! (i + 2)) x) =\n                             - sgn (poly (ps ! i) x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j\\<le>Suc i + 1. poly (ps ! j) x = 0", "from Suc.prems(1,2)"], ["proof (chain)\npicking this:\n  Suc i < length ps - 1\n  poly (ps ! Suc i) x = 0", "have \"sgn (poly (ps ! (i + 2)) x) = - sgn (poly (ps ! i) x)\""], ["proof (prove)\nusing this:\n  Suc i < length ps - 1\n  poly (ps ! Suc i) x = 0\n\ngoal (1 subgoal):\n 1. sgn (poly (ps ! (i + 2)) x) = - sgn (poly (ps ! i) x)", "by (intro assms(4)) simp_all"], ["proof (state)\nthis:\n  sgn (poly (ps ! (i + 2)) x) = - sgn (poly (ps ! i) x)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<lbrakk>i < length ps - 1; poly (ps ! i) x = 0;\n                 poly (ps ! (i + 1)) x = 0;\n                 \\<And>i x.\n                    \\<lbrakk>i < length ps - 2;\n                     poly (ps ! (i + 1)) x = 0\\<rbrakk>\n                    \\<Longrightarrow> sgn (poly (ps ! (i + 2)) x) =\n- sgn (poly (ps ! i) x)\\<rbrakk>\n                \\<Longrightarrow> \\<forall>j\\<le>i + 1. poly (ps ! j) x = 0;\n        Suc i < length ps - 1; poly (ps ! Suc i) x = 0;\n        poly (ps ! (Suc i + 1)) x = 0;\n        \\<And>i x.\n           \\<lbrakk>i < length ps - 2; poly (ps ! (i + 1)) x = 0\\<rbrakk>\n           \\<Longrightarrow> sgn (poly (ps ! (i + 2)) x) =\n                             - sgn (poly (ps ! i) x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j\\<le>Suc i + 1. poly (ps ! j) x = 0", "with Suc.prems(3)"], ["proof (chain)\npicking this:\n  poly (ps ! (Suc i + 1)) x = 0\n  sgn (poly (ps ! (i + 2)) x) = - sgn (poly (ps ! i) x)", "have \"poly (ps ! i) x = 0\""], ["proof (prove)\nusing this:\n  poly (ps ! (Suc i + 1)) x = 0\n  sgn (poly (ps ! (i + 2)) x) = - sgn (poly (ps ! i) x)\n\ngoal (1 subgoal):\n 1. poly (ps ! i) x = 0", "by (simp add: sgn_zero_iff)"], ["proof (state)\nthis:\n  poly (ps ! i) x = 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<lbrakk>i < length ps - 1; poly (ps ! i) x = 0;\n                 poly (ps ! (i + 1)) x = 0;\n                 \\<And>i x.\n                    \\<lbrakk>i < length ps - 2;\n                     poly (ps ! (i + 1)) x = 0\\<rbrakk>\n                    \\<Longrightarrow> sgn (poly (ps ! (i + 2)) x) =\n- sgn (poly (ps ! i) x)\\<rbrakk>\n                \\<Longrightarrow> \\<forall>j\\<le>i + 1. poly (ps ! j) x = 0;\n        Suc i < length ps - 1; poly (ps ! Suc i) x = 0;\n        poly (ps ! (Suc i + 1)) x = 0;\n        \\<And>i x.\n           \\<lbrakk>i < length ps - 2; poly (ps ! (i + 1)) x = 0\\<rbrakk>\n           \\<Longrightarrow> sgn (poly (ps ! (i + 2)) x) =\n                             - sgn (poly (ps ! i) x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j\\<le>Suc i + 1. poly (ps ! j) x = 0", "with Suc.prems"], ["proof (chain)\npicking this:\n  Suc i < length ps - 1\n  poly (ps ! Suc i) x = 0\n  poly (ps ! (Suc i + 1)) x = 0\n  \\<lbrakk>?i < length ps - 2; poly (ps ! (?i + 1)) ?x = 0\\<rbrakk>\n  \\<Longrightarrow> sgn (poly (ps ! (?i + 2)) ?x) =\n                    - sgn (poly (ps ! ?i) ?x)\n  poly (ps ! i) x = 0", "have \"\\<forall>j\\<le>i+1. poly (ps ! j) x = 0\""], ["proof (prove)\nusing this:\n  Suc i < length ps - 1\n  poly (ps ! Suc i) x = 0\n  poly (ps ! (Suc i + 1)) x = 0\n  \\<lbrakk>?i < length ps - 2; poly (ps ! (?i + 1)) ?x = 0\\<rbrakk>\n  \\<Longrightarrow> sgn (poly (ps ! (?i + 2)) ?x) =\n                    - sgn (poly (ps ! ?i) ?x)\n  poly (ps ! i) x = 0\n\ngoal (1 subgoal):\n 1. \\<forall>j\\<le>i + 1. poly (ps ! j) x = 0", "by (intro Suc.IH, simp_all)"], ["proof (state)\nthis:\n  \\<forall>j\\<le>i + 1. poly (ps ! j) x = 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<lbrakk>i < length ps - 1; poly (ps ! i) x = 0;\n                 poly (ps ! (i + 1)) x = 0;\n                 \\<And>i x.\n                    \\<lbrakk>i < length ps - 2;\n                     poly (ps ! (i + 1)) x = 0\\<rbrakk>\n                    \\<Longrightarrow> sgn (poly (ps ! (i + 2)) x) =\n- sgn (poly (ps ! i) x)\\<rbrakk>\n                \\<Longrightarrow> \\<forall>j\\<le>i + 1. poly (ps ! j) x = 0;\n        Suc i < length ps - 1; poly (ps ! Suc i) x = 0;\n        poly (ps ! (Suc i + 1)) x = 0;\n        \\<And>i x.\n           \\<lbrakk>i < length ps - 2; poly (ps ! (i + 1)) x = 0\\<rbrakk>\n           \\<Longrightarrow> sgn (poly (ps ! (i + 2)) x) =\n                             - sgn (poly (ps ! i) x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j\\<le>Suc i + 1. poly (ps ! j) x = 0", "with Suc.prems(3)"], ["proof (chain)\npicking this:\n  poly (ps ! (Suc i + 1)) x = 0\n  \\<forall>j\\<le>i + 1. poly (ps ! j) x = 0", "show ?case"], ["proof (prove)\nusing this:\n  poly (ps ! (Suc i + 1)) x = 0\n  \\<forall>j\\<le>i + 1. poly (ps ! j) x = 0\n\ngoal (1 subgoal):\n 1. \\<forall>j\\<le>Suc i + 1. poly (ps ! j) x = 0", "by (clarsimp, rename_tac j, case_tac \"j = Suc (Suc i)\", simp_all)"], ["proof (state)\nthis:\n  \\<forall>j\\<le>Suc i + 1. poly (ps ! j) x = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  This function splits the sign list of a Sturm sequence at a\n  position @{term x} that is not a root of @{term p} into a\n  list of sublists such that the number of sign changes within\n  every sublist is constant in the neighbourhood of @{term x},\n  thus proving that the total number is also constant.\n\\<close>"], ["", "fun split_sign_changes where\n\"split_sign_changes [p] (x :: real) = [[p]]\" |\n\"split_sign_changes [p,q] x = [[p,q]]\" |\n\"split_sign_changes (p#q#r#ps) x =\n    (if poly p x \\<noteq> 0 \\<and> poly q x = 0 then\n       [p,q,r] # split_sign_changes (r#ps) x\n     else\n       [p,q] # split_sign_changes (q#r#ps) x)\""], ["", "lemma (in quasi_sturm_seq) split_sign_changes_subset[dest]:\n  \"ps' \\<in> set (split_sign_changes ps x) \\<Longrightarrow> set ps' \\<subseteq> set ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ps' \\<in> set (split_sign_changes ps x) \\<Longrightarrow>\n    set ps' \\<subseteq> set ps", "apply (insert ps_not_Nil)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ps' \\<in> set (split_sign_changes ps x);\n     ps \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> set ps' \\<subseteq> set ps", "apply (induction ps x rule: split_sign_changes.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>p x.\n       \\<lbrakk>ps' \\<in> set (split_sign_changes [p] x);\n        [p] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> set ps' \\<subseteq> set [p]\n 2. \\<And>p q x.\n       \\<lbrakk>ps' \\<in> set (split_sign_changes [p, q] x);\n        [p, q] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> set ps' \\<subseteq> set [p, q]\n 3. \\<And>p q r ps x.\n       \\<lbrakk>\\<lbrakk>poly p x \\<noteq> 0 \\<and> poly q x = 0;\n                 ps' \\<in> set (split_sign_changes (r # ps) x);\n                 r # ps \\<noteq> []\\<rbrakk>\n                \\<Longrightarrow> set ps' \\<subseteq> set (r # ps);\n        \\<lbrakk>\\<not> (poly p x \\<noteq> 0 \\<and> poly q x = 0);\n         ps' \\<in> set (split_sign_changes (q # r # ps) x);\n         q # r # ps \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> set ps' \\<subseteq> set (q # r # ps);\n        ps' \\<in> set (split_sign_changes (p # q # r # ps) x);\n        p # q # r # ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> set ps' \\<subseteq> set (p # q # r # ps)\n 4. \\<And>b.\n       \\<lbrakk>ps' \\<in> set (split_sign_changes [] b);\n        [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> set ps' \\<subseteq> set []", "apply (simp, simp, rename_tac p q r ps x,\n       case_tac \"poly p x \\<noteq> 0 \\<and> poly q x = 0\", auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\n  A custom induction rule for @{term split_sign_changes} that\n  uses the fact that all the intermediate parameters in calls\n  of @{term split_sign_changes} are quasi-Sturm sequences.\n\\<close>"], ["", "lemma (in quasi_sturm_seq) split_sign_changes_induct:\n  \"\\<lbrakk>\\<And>p x. P [p] x; \\<And>p q x. quasi_sturm_seq [p,q] \\<Longrightarrow> P [p,q] x;\n    \\<And>p q r ps x. quasi_sturm_seq (p#q#r#ps) \\<Longrightarrow>\n       \\<lbrakk>poly p x \\<noteq> 0 \\<Longrightarrow> poly q x = 0 \\<Longrightarrow> P (r#ps) x;\n        poly q x \\<noteq> 0 \\<Longrightarrow> P (q#r#ps) x;\n        poly p x = 0 \\<Longrightarrow> P (q#r#ps) x\\<rbrakk>\n           \\<Longrightarrow> P (p#q#r#ps) x\\<rbrakk> \\<Longrightarrow> P ps x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p x. P [p] x;\n     \\<And>p q x. quasi_sturm_seq [p, q] \\<Longrightarrow> P [p, q] x;\n     \\<And>p q r ps x.\n        \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n         \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0\\<rbrakk>\n         \\<Longrightarrow> P (r # ps) x;\n         poly q x \\<noteq> 0 \\<Longrightarrow> P (q # r # ps) x;\n         poly p x = 0 \\<Longrightarrow> P (q # r # ps) x\\<rbrakk>\n        \\<Longrightarrow> P (p # q # r # ps) x\\<rbrakk>\n    \\<Longrightarrow> P ps x", "proof goal_cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p x. P [p] x;\n     \\<And>p q x. quasi_sturm_seq [p, q] \\<Longrightarrow> P [p, q] x;\n     \\<And>p q r ps x.\n        \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n         \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0\\<rbrakk>\n         \\<Longrightarrow> P (r # ps) x;\n         poly q x \\<noteq> 0 \\<Longrightarrow> P (q # r # ps) x;\n         poly p x = 0 \\<Longrightarrow> P (q # r # ps) x\\<rbrakk>\n        \\<Longrightarrow> P (p # q # r # ps) x\\<rbrakk>\n    \\<Longrightarrow> P ps x", "case prems: 1"], ["proof (state)\nthis:\n  P [?p] ?x\n  quasi_sturm_seq [?p, ?q] \\<Longrightarrow> P [?p, ?q] ?x\n  \\<lbrakk>quasi_sturm_seq (?p # ?q # ?r # ?ps);\n   \\<lbrakk>poly ?p ?x \\<noteq> 0; poly ?q ?x = 0\\<rbrakk>\n   \\<Longrightarrow> P (?r # ?ps) ?x;\n   poly ?q ?x \\<noteq> 0 \\<Longrightarrow> P (?q # ?r # ?ps) ?x;\n   poly ?p ?x = 0 \\<Longrightarrow> P (?q # ?r # ?ps) ?x\\<rbrakk>\n  \\<Longrightarrow> P (?p # ?q # ?r # ?ps) ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p x. P [p] x;\n     \\<And>p q x. quasi_sturm_seq [p, q] \\<Longrightarrow> P [p, q] x;\n     \\<And>p q r ps x.\n        \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n         \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0\\<rbrakk>\n         \\<Longrightarrow> P (r # ps) x;\n         poly q x \\<noteq> 0 \\<Longrightarrow> P (q # r # ps) x;\n         poly p x = 0 \\<Longrightarrow> P (q # r # ps) x\\<rbrakk>\n        \\<Longrightarrow> P (p # q # r # ps) x\\<rbrakk>\n    \\<Longrightarrow> P ps x", "have \"quasi_sturm_seq ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quasi_sturm_seq ps", ".."], ["proof (state)\nthis:\n  quasi_sturm_seq ps\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p x. P [p] x;\n     \\<And>p q x. quasi_sturm_seq [p, q] \\<Longrightarrow> P [p, q] x;\n     \\<And>p q r ps x.\n        \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n         \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0\\<rbrakk>\n         \\<Longrightarrow> P (r # ps) x;\n         poly q x \\<noteq> 0 \\<Longrightarrow> P (q # r # ps) x;\n         poly p x = 0 \\<Longrightarrow> P (q # r # ps) x\\<rbrakk>\n        \\<Longrightarrow> P (p # q # r # ps) x\\<rbrakk>\n    \\<Longrightarrow> P ps x", "with prems"], ["proof (chain)\npicking this:\n  P [?p] ?x\n  quasi_sturm_seq [?p, ?q] \\<Longrightarrow> P [?p, ?q] ?x\n  \\<lbrakk>quasi_sturm_seq (?p # ?q # ?r # ?ps);\n   \\<lbrakk>poly ?p ?x \\<noteq> 0; poly ?q ?x = 0\\<rbrakk>\n   \\<Longrightarrow> P (?r # ?ps) ?x;\n   poly ?q ?x \\<noteq> 0 \\<Longrightarrow> P (?q # ?r # ?ps) ?x;\n   poly ?p ?x = 0 \\<Longrightarrow> P (?q # ?r # ?ps) ?x\\<rbrakk>\n  \\<Longrightarrow> P (?p # ?q # ?r # ?ps) ?x\n  quasi_sturm_seq ps", "show ?thesis"], ["proof (prove)\nusing this:\n  P [?p] ?x\n  quasi_sturm_seq [?p, ?q] \\<Longrightarrow> P [?p, ?q] ?x\n  \\<lbrakk>quasi_sturm_seq (?p # ?q # ?r # ?ps);\n   \\<lbrakk>poly ?p ?x \\<noteq> 0; poly ?q ?x = 0\\<rbrakk>\n   \\<Longrightarrow> P (?r # ?ps) ?x;\n   poly ?q ?x \\<noteq> 0 \\<Longrightarrow> P (?q # ?r # ?ps) ?x;\n   poly ?p ?x = 0 \\<Longrightarrow> P (?q # ?r # ?ps) ?x\\<rbrakk>\n  \\<Longrightarrow> P (?p # ?q # ?r # ?ps) ?x\n  quasi_sturm_seq ps\n\ngoal (1 subgoal):\n 1. P ps x", "proof (induction ps x rule: split_sign_changes.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>p x.\n       \\<lbrakk>\\<And>p x. P [p] x;\n        \\<And>p q x. quasi_sturm_seq [p, q] \\<Longrightarrow> P [p, q] x;\n        \\<And>p q r ps x.\n           \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n            \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0\\<rbrakk>\n            \\<Longrightarrow> P (r # ps) x;\n            poly q x \\<noteq> 0 \\<Longrightarrow> P (q # r # ps) x;\n            poly p x = 0 \\<Longrightarrow> P (q # r # ps) x\\<rbrakk>\n           \\<Longrightarrow> P (p # q # r # ps) x;\n        quasi_sturm_seq [p]\\<rbrakk>\n       \\<Longrightarrow> P [p] x\n 2. \\<And>p q x.\n       \\<lbrakk>\\<And>p x. P [p] x;\n        \\<And>p q x. quasi_sturm_seq [p, q] \\<Longrightarrow> P [p, q] x;\n        \\<And>p q r ps x.\n           \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n            \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0\\<rbrakk>\n            \\<Longrightarrow> P (r # ps) x;\n            poly q x \\<noteq> 0 \\<Longrightarrow> P (q # r # ps) x;\n            poly p x = 0 \\<Longrightarrow> P (q # r # ps) x\\<rbrakk>\n           \\<Longrightarrow> P (p # q # r # ps) x;\n        quasi_sturm_seq [p, q]\\<rbrakk>\n       \\<Longrightarrow> P [p, q] x\n 3. \\<And>p q r ps x.\n       \\<lbrakk>\\<lbrakk>poly p x \\<noteq> 0 \\<and> poly q x = 0;\n                 \\<And>p x. P [p] x;\n                 \\<And>p q x.\n                    quasi_sturm_seq [p, q] \\<Longrightarrow> P [p, q] x;\n                 \\<And>p q r ps x.\n                    \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n                     \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0\\<rbrakk>\n                     \\<Longrightarrow> P (r # ps) x;\n                     poly q x \\<noteq> 0 \\<Longrightarrow> P (q # r # ps) x;\n                     poly p x = 0 \\<Longrightarrow>\n                     P (q # r # ps) x\\<rbrakk>\n                    \\<Longrightarrow> P (p # q # r # ps) x;\n                 quasi_sturm_seq (r # ps)\\<rbrakk>\n                \\<Longrightarrow> P (r # ps) x;\n        \\<lbrakk>\\<not> (poly p x \\<noteq> 0 \\<and> poly q x = 0);\n         \\<And>p x. P [p] x;\n         \\<And>p q x. quasi_sturm_seq [p, q] \\<Longrightarrow> P [p, q] x;\n         \\<And>p q r ps x.\n            \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n             \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0\\<rbrakk>\n             \\<Longrightarrow> P (r # ps) x;\n             poly q x \\<noteq> 0 \\<Longrightarrow> P (q # r # ps) x;\n             poly p x = 0 \\<Longrightarrow> P (q # r # ps) x\\<rbrakk>\n            \\<Longrightarrow> P (p # q # r # ps) x;\n         quasi_sturm_seq (q # r # ps)\\<rbrakk>\n        \\<Longrightarrow> P (q # r # ps) x;\n        \\<And>p x. P [p] x;\n        \\<And>p q x. quasi_sturm_seq [p, q] \\<Longrightarrow> P [p, q] x;\n        \\<And>p q r ps x.\n           \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n            \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0\\<rbrakk>\n            \\<Longrightarrow> P (r # ps) x;\n            poly q x \\<noteq> 0 \\<Longrightarrow> P (q # r # ps) x;\n            poly p x = 0 \\<Longrightarrow> P (q # r # ps) x\\<rbrakk>\n           \\<Longrightarrow> P (p # q # r # ps) x;\n        quasi_sturm_seq (p # q # r # ps)\\<rbrakk>\n       \\<Longrightarrow> P (p # q # r # ps) x\n 4. \\<And>b.\n       \\<lbrakk>\\<And>p x. P [p] x;\n        \\<And>p q x. quasi_sturm_seq [p, q] \\<Longrightarrow> P [p, q] x;\n        \\<And>p q r ps x.\n           \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n            \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0\\<rbrakk>\n            \\<Longrightarrow> P (r # ps) x;\n            poly q x \\<noteq> 0 \\<Longrightarrow> P (q # r # ps) x;\n            poly p x = 0 \\<Longrightarrow> P (q # r # ps) x\\<rbrakk>\n           \\<Longrightarrow> P (p # q # r # ps) x;\n        quasi_sturm_seq []\\<rbrakk>\n       \\<Longrightarrow> P [] b", "case (3 p q r ps x)"], ["proof (state)\nthis:\n  \\<lbrakk>poly p x \\<noteq> 0 \\<and> poly q x = 0; \\<And>p x. P [p] x;\n   \\<And>p q x. quasi_sturm_seq [p, q] \\<Longrightarrow> P [p, q] x;\n   \\<And>p q r ps x.\n      \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n       \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0\\<rbrakk>\n       \\<Longrightarrow> P (r # ps) x;\n       poly q x \\<noteq> 0 \\<Longrightarrow> P (q # r # ps) x;\n       poly p x = 0 \\<Longrightarrow> P (q # r # ps) x\\<rbrakk>\n      \\<Longrightarrow> P (p # q # r # ps) x;\n   quasi_sturm_seq (r # ps)\\<rbrakk>\n  \\<Longrightarrow> P (r # ps) x\n  \\<lbrakk>\\<not> (poly p x \\<noteq> 0 \\<and> poly q x = 0);\n   \\<And>p x. P [p] x;\n   \\<And>p q x. quasi_sturm_seq [p, q] \\<Longrightarrow> P [p, q] x;\n   \\<And>p q r ps x.\n      \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n       \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0\\<rbrakk>\n       \\<Longrightarrow> P (r # ps) x;\n       poly q x \\<noteq> 0 \\<Longrightarrow> P (q # r # ps) x;\n       poly p x = 0 \\<Longrightarrow> P (q # r # ps) x\\<rbrakk>\n      \\<Longrightarrow> P (p # q # r # ps) x;\n   quasi_sturm_seq (q # r # ps)\\<rbrakk>\n  \\<Longrightarrow> P (q # r # ps) x\n  P [?p] ?x\n  quasi_sturm_seq [?p, ?q] \\<Longrightarrow> P [?p, ?q] ?x\n  \\<lbrakk>quasi_sturm_seq (?p # ?q # ?r # ?ps);\n   \\<lbrakk>poly ?p ?x \\<noteq> 0; poly ?q ?x = 0\\<rbrakk>\n   \\<Longrightarrow> P (?r # ?ps) ?x;\n   poly ?q ?x \\<noteq> 0 \\<Longrightarrow> P (?q # ?r # ?ps) ?x;\n   poly ?p ?x = 0 \\<Longrightarrow> P (?q # ?r # ?ps) ?x\\<rbrakk>\n  \\<Longrightarrow> P (?p # ?q # ?r # ?ps) ?x\n  quasi_sturm_seq (p # q # r # ps)\n\ngoal (4 subgoals):\n 1. \\<And>p x.\n       \\<lbrakk>\\<And>p x. P [p] x;\n        \\<And>p q x. quasi_sturm_seq [p, q] \\<Longrightarrow> P [p, q] x;\n        \\<And>p q r ps x.\n           \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n            \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0\\<rbrakk>\n            \\<Longrightarrow> P (r # ps) x;\n            poly q x \\<noteq> 0 \\<Longrightarrow> P (q # r # ps) x;\n            poly p x = 0 \\<Longrightarrow> P (q # r # ps) x\\<rbrakk>\n           \\<Longrightarrow> P (p # q # r # ps) x;\n        quasi_sturm_seq [p]\\<rbrakk>\n       \\<Longrightarrow> P [p] x\n 2. \\<And>p q x.\n       \\<lbrakk>\\<And>p x. P [p] x;\n        \\<And>p q x. quasi_sturm_seq [p, q] \\<Longrightarrow> P [p, q] x;\n        \\<And>p q r ps x.\n           \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n            \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0\\<rbrakk>\n            \\<Longrightarrow> P (r # ps) x;\n            poly q x \\<noteq> 0 \\<Longrightarrow> P (q # r # ps) x;\n            poly p x = 0 \\<Longrightarrow> P (q # r # ps) x\\<rbrakk>\n           \\<Longrightarrow> P (p # q # r # ps) x;\n        quasi_sturm_seq [p, q]\\<rbrakk>\n       \\<Longrightarrow> P [p, q] x\n 3. \\<And>p q r ps x.\n       \\<lbrakk>\\<lbrakk>poly p x \\<noteq> 0 \\<and> poly q x = 0;\n                 \\<And>p x. P [p] x;\n                 \\<And>p q x.\n                    quasi_sturm_seq [p, q] \\<Longrightarrow> P [p, q] x;\n                 \\<And>p q r ps x.\n                    \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n                     \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0\\<rbrakk>\n                     \\<Longrightarrow> P (r # ps) x;\n                     poly q x \\<noteq> 0 \\<Longrightarrow> P (q # r # ps) x;\n                     poly p x = 0 \\<Longrightarrow>\n                     P (q # r # ps) x\\<rbrakk>\n                    \\<Longrightarrow> P (p # q # r # ps) x;\n                 quasi_sturm_seq (r # ps)\\<rbrakk>\n                \\<Longrightarrow> P (r # ps) x;\n        \\<lbrakk>\\<not> (poly p x \\<noteq> 0 \\<and> poly q x = 0);\n         \\<And>p x. P [p] x;\n         \\<And>p q x. quasi_sturm_seq [p, q] \\<Longrightarrow> P [p, q] x;\n         \\<And>p q r ps x.\n            \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n             \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0\\<rbrakk>\n             \\<Longrightarrow> P (r # ps) x;\n             poly q x \\<noteq> 0 \\<Longrightarrow> P (q # r # ps) x;\n             poly p x = 0 \\<Longrightarrow> P (q # r # ps) x\\<rbrakk>\n            \\<Longrightarrow> P (p # q # r # ps) x;\n         quasi_sturm_seq (q # r # ps)\\<rbrakk>\n        \\<Longrightarrow> P (q # r # ps) x;\n        \\<And>p x. P [p] x;\n        \\<And>p q x. quasi_sturm_seq [p, q] \\<Longrightarrow> P [p, q] x;\n        \\<And>p q r ps x.\n           \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n            \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0\\<rbrakk>\n            \\<Longrightarrow> P (r # ps) x;\n            poly q x \\<noteq> 0 \\<Longrightarrow> P (q # r # ps) x;\n            poly p x = 0 \\<Longrightarrow> P (q # r # ps) x\\<rbrakk>\n           \\<Longrightarrow> P (p # q # r # ps) x;\n        quasi_sturm_seq (p # q # r # ps)\\<rbrakk>\n       \\<Longrightarrow> P (p # q # r # ps) x\n 4. \\<And>b.\n       \\<lbrakk>\\<And>p x. P [p] x;\n        \\<And>p q x. quasi_sturm_seq [p, q] \\<Longrightarrow> P [p, q] x;\n        \\<And>p q r ps x.\n           \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n            \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0\\<rbrakk>\n            \\<Longrightarrow> P (r # ps) x;\n            poly q x \\<noteq> 0 \\<Longrightarrow> P (q # r # ps) x;\n            poly p x = 0 \\<Longrightarrow> P (q # r # ps) x\\<rbrakk>\n           \\<Longrightarrow> P (p # q # r # ps) x;\n        quasi_sturm_seq []\\<rbrakk>\n       \\<Longrightarrow> P [] b", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (p # q # r # ps) x", "proof (rule 3(5)[OF 3(6)])"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0\\<rbrakk>\n    \\<Longrightarrow> P (r # ps) x\n 2. poly q x \\<noteq> 0 \\<Longrightarrow> P (q # r # ps) x\n 3. poly p x = 0 \\<Longrightarrow> P (q # r # ps) x", "assume A: \"poly p x \\<noteq> 0\" \"poly q x = 0\""], ["proof (state)\nthis:\n  poly p x \\<noteq> 0\n  poly q x = 0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0\\<rbrakk>\n    \\<Longrightarrow> P (r # ps) x\n 2. poly q x \\<noteq> 0 \\<Longrightarrow> P (q # r # ps) x\n 3. poly p x = 0 \\<Longrightarrow> P (q # r # ps) x", "from 3(6)"], ["proof (chain)\npicking this:\n  quasi_sturm_seq (p # q # r # ps)", "have \"quasi_sturm_seq (r#ps)\""], ["proof (prove)\nusing this:\n  quasi_sturm_seq (p # q # r # ps)\n\ngoal (1 subgoal):\n 1. quasi_sturm_seq (r # ps)", "by (force dest: quasi_sturm_seq_Cons)"], ["proof (state)\nthis:\n  quasi_sturm_seq (r # ps)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0\\<rbrakk>\n    \\<Longrightarrow> P (r # ps) x\n 2. poly q x \\<noteq> 0 \\<Longrightarrow> P (q # r # ps) x\n 3. poly p x = 0 \\<Longrightarrow> P (q # r # ps) x", "with 3 A"], ["proof (chain)\npicking this:\n  \\<lbrakk>poly p x \\<noteq> 0 \\<and> poly q x = 0; \\<And>p x. P [p] x;\n   \\<And>p q x. quasi_sturm_seq [p, q] \\<Longrightarrow> P [p, q] x;\n   \\<And>p q r ps x.\n      \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n       \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0\\<rbrakk>\n       \\<Longrightarrow> P (r # ps) x;\n       poly q x \\<noteq> 0 \\<Longrightarrow> P (q # r # ps) x;\n       poly p x = 0 \\<Longrightarrow> P (q # r # ps) x\\<rbrakk>\n      \\<Longrightarrow> P (p # q # r # ps) x;\n   quasi_sturm_seq (r # ps)\\<rbrakk>\n  \\<Longrightarrow> P (r # ps) x\n  \\<lbrakk>\\<not> (poly p x \\<noteq> 0 \\<and> poly q x = 0);\n   \\<And>p x. P [p] x;\n   \\<And>p q x. quasi_sturm_seq [p, q] \\<Longrightarrow> P [p, q] x;\n   \\<And>p q r ps x.\n      \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n       \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0\\<rbrakk>\n       \\<Longrightarrow> P (r # ps) x;\n       poly q x \\<noteq> 0 \\<Longrightarrow> P (q # r # ps) x;\n       poly p x = 0 \\<Longrightarrow> P (q # r # ps) x\\<rbrakk>\n      \\<Longrightarrow> P (p # q # r # ps) x;\n   quasi_sturm_seq (q # r # ps)\\<rbrakk>\n  \\<Longrightarrow> P (q # r # ps) x\n  P [?p] ?x\n  quasi_sturm_seq [?p, ?q] \\<Longrightarrow> P [?p, ?q] ?x\n  \\<lbrakk>quasi_sturm_seq (?p # ?q # ?r # ?ps);\n   \\<lbrakk>poly ?p ?x \\<noteq> 0; poly ?q ?x = 0\\<rbrakk>\n   \\<Longrightarrow> P (?r # ?ps) ?x;\n   poly ?q ?x \\<noteq> 0 \\<Longrightarrow> P (?q # ?r # ?ps) ?x;\n   poly ?p ?x = 0 \\<Longrightarrow> P (?q # ?r # ?ps) ?x\\<rbrakk>\n  \\<Longrightarrow> P (?p # ?q # ?r # ?ps) ?x\n  quasi_sturm_seq (p # q # r # ps)\n  poly p x \\<noteq> 0\n  poly q x = 0\n  quasi_sturm_seq (r # ps)", "show \"P (r # ps) x\""], ["proof (prove)\nusing this:\n  \\<lbrakk>poly p x \\<noteq> 0 \\<and> poly q x = 0; \\<And>p x. P [p] x;\n   \\<And>p q x. quasi_sturm_seq [p, q] \\<Longrightarrow> P [p, q] x;\n   \\<And>p q r ps x.\n      \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n       \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0\\<rbrakk>\n       \\<Longrightarrow> P (r # ps) x;\n       poly q x \\<noteq> 0 \\<Longrightarrow> P (q # r # ps) x;\n       poly p x = 0 \\<Longrightarrow> P (q # r # ps) x\\<rbrakk>\n      \\<Longrightarrow> P (p # q # r # ps) x;\n   quasi_sturm_seq (r # ps)\\<rbrakk>\n  \\<Longrightarrow> P (r # ps) x\n  \\<lbrakk>\\<not> (poly p x \\<noteq> 0 \\<and> poly q x = 0);\n   \\<And>p x. P [p] x;\n   \\<And>p q x. quasi_sturm_seq [p, q] \\<Longrightarrow> P [p, q] x;\n   \\<And>p q r ps x.\n      \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n       \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0\\<rbrakk>\n       \\<Longrightarrow> P (r # ps) x;\n       poly q x \\<noteq> 0 \\<Longrightarrow> P (q # r # ps) x;\n       poly p x = 0 \\<Longrightarrow> P (q # r # ps) x\\<rbrakk>\n      \\<Longrightarrow> P (p # q # r # ps) x;\n   quasi_sturm_seq (q # r # ps)\\<rbrakk>\n  \\<Longrightarrow> P (q # r # ps) x\n  P [?p] ?x\n  quasi_sturm_seq [?p, ?q] \\<Longrightarrow> P [?p, ?q] ?x\n  \\<lbrakk>quasi_sturm_seq (?p # ?q # ?r # ?ps);\n   \\<lbrakk>poly ?p ?x \\<noteq> 0; poly ?q ?x = 0\\<rbrakk>\n   \\<Longrightarrow> P (?r # ?ps) ?x;\n   poly ?q ?x \\<noteq> 0 \\<Longrightarrow> P (?q # ?r # ?ps) ?x;\n   poly ?p ?x = 0 \\<Longrightarrow> P (?q # ?r # ?ps) ?x\\<rbrakk>\n  \\<Longrightarrow> P (?p # ?q # ?r # ?ps) ?x\n  quasi_sturm_seq (p # q # r # ps)\n  poly p x \\<noteq> 0\n  poly q x = 0\n  quasi_sturm_seq (r # ps)\n\ngoal (1 subgoal):\n 1. P (r # ps) x", "by blast"], ["proof (state)\nthis:\n  P (r # ps) x\n\ngoal (2 subgoals):\n 1. poly q x \\<noteq> 0 \\<Longrightarrow> P (q # r # ps) x\n 2. poly p x = 0 \\<Longrightarrow> P (q # r # ps) x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. poly q x \\<noteq> 0 \\<Longrightarrow> P (q # r # ps) x\n 2. poly p x = 0 \\<Longrightarrow> P (q # r # ps) x", "assume A: \"poly q x \\<noteq> 0\""], ["proof (state)\nthis:\n  poly q x \\<noteq> 0\n\ngoal (2 subgoals):\n 1. poly q x \\<noteq> 0 \\<Longrightarrow> P (q # r # ps) x\n 2. poly p x = 0 \\<Longrightarrow> P (q # r # ps) x", "from 3(6)"], ["proof (chain)\npicking this:\n  quasi_sturm_seq (p # q # r # ps)", "have \"quasi_sturm_seq (q#r#ps)\""], ["proof (prove)\nusing this:\n  quasi_sturm_seq (p # q # r # ps)\n\ngoal (1 subgoal):\n 1. quasi_sturm_seq (q # r # ps)", "by (force dest: quasi_sturm_seq_Cons)"], ["proof (state)\nthis:\n  quasi_sturm_seq (q # r # ps)\n\ngoal (2 subgoals):\n 1. poly q x \\<noteq> 0 \\<Longrightarrow> P (q # r # ps) x\n 2. poly p x = 0 \\<Longrightarrow> P (q # r # ps) x", "with 3 A"], ["proof (chain)\npicking this:\n  \\<lbrakk>poly p x \\<noteq> 0 \\<and> poly q x = 0; \\<And>p x. P [p] x;\n   \\<And>p q x. quasi_sturm_seq [p, q] \\<Longrightarrow> P [p, q] x;\n   \\<And>p q r ps x.\n      \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n       \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0\\<rbrakk>\n       \\<Longrightarrow> P (r # ps) x;\n       poly q x \\<noteq> 0 \\<Longrightarrow> P (q # r # ps) x;\n       poly p x = 0 \\<Longrightarrow> P (q # r # ps) x\\<rbrakk>\n      \\<Longrightarrow> P (p # q # r # ps) x;\n   quasi_sturm_seq (r # ps)\\<rbrakk>\n  \\<Longrightarrow> P (r # ps) x\n  \\<lbrakk>\\<not> (poly p x \\<noteq> 0 \\<and> poly q x = 0);\n   \\<And>p x. P [p] x;\n   \\<And>p q x. quasi_sturm_seq [p, q] \\<Longrightarrow> P [p, q] x;\n   \\<And>p q r ps x.\n      \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n       \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0\\<rbrakk>\n       \\<Longrightarrow> P (r # ps) x;\n       poly q x \\<noteq> 0 \\<Longrightarrow> P (q # r # ps) x;\n       poly p x = 0 \\<Longrightarrow> P (q # r # ps) x\\<rbrakk>\n      \\<Longrightarrow> P (p # q # r # ps) x;\n   quasi_sturm_seq (q # r # ps)\\<rbrakk>\n  \\<Longrightarrow> P (q # r # ps) x\n  P [?p] ?x\n  quasi_sturm_seq [?p, ?q] \\<Longrightarrow> P [?p, ?q] ?x\n  \\<lbrakk>quasi_sturm_seq (?p # ?q # ?r # ?ps);\n   \\<lbrakk>poly ?p ?x \\<noteq> 0; poly ?q ?x = 0\\<rbrakk>\n   \\<Longrightarrow> P (?r # ?ps) ?x;\n   poly ?q ?x \\<noteq> 0 \\<Longrightarrow> P (?q # ?r # ?ps) ?x;\n   poly ?p ?x = 0 \\<Longrightarrow> P (?q # ?r # ?ps) ?x\\<rbrakk>\n  \\<Longrightarrow> P (?p # ?q # ?r # ?ps) ?x\n  quasi_sturm_seq (p # q # r # ps)\n  poly q x \\<noteq> 0\n  quasi_sturm_seq (q # r # ps)", "show \"P (q # r # ps) x\""], ["proof (prove)\nusing this:\n  \\<lbrakk>poly p x \\<noteq> 0 \\<and> poly q x = 0; \\<And>p x. P [p] x;\n   \\<And>p q x. quasi_sturm_seq [p, q] \\<Longrightarrow> P [p, q] x;\n   \\<And>p q r ps x.\n      \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n       \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0\\<rbrakk>\n       \\<Longrightarrow> P (r # ps) x;\n       poly q x \\<noteq> 0 \\<Longrightarrow> P (q # r # ps) x;\n       poly p x = 0 \\<Longrightarrow> P (q # r # ps) x\\<rbrakk>\n      \\<Longrightarrow> P (p # q # r # ps) x;\n   quasi_sturm_seq (r # ps)\\<rbrakk>\n  \\<Longrightarrow> P (r # ps) x\n  \\<lbrakk>\\<not> (poly p x \\<noteq> 0 \\<and> poly q x = 0);\n   \\<And>p x. P [p] x;\n   \\<And>p q x. quasi_sturm_seq [p, q] \\<Longrightarrow> P [p, q] x;\n   \\<And>p q r ps x.\n      \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n       \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0\\<rbrakk>\n       \\<Longrightarrow> P (r # ps) x;\n       poly q x \\<noteq> 0 \\<Longrightarrow> P (q # r # ps) x;\n       poly p x = 0 \\<Longrightarrow> P (q # r # ps) x\\<rbrakk>\n      \\<Longrightarrow> P (p # q # r # ps) x;\n   quasi_sturm_seq (q # r # ps)\\<rbrakk>\n  \\<Longrightarrow> P (q # r # ps) x\n  P [?p] ?x\n  quasi_sturm_seq [?p, ?q] \\<Longrightarrow> P [?p, ?q] ?x\n  \\<lbrakk>quasi_sturm_seq (?p # ?q # ?r # ?ps);\n   \\<lbrakk>poly ?p ?x \\<noteq> 0; poly ?q ?x = 0\\<rbrakk>\n   \\<Longrightarrow> P (?r # ?ps) ?x;\n   poly ?q ?x \\<noteq> 0 \\<Longrightarrow> P (?q # ?r # ?ps) ?x;\n   poly ?p ?x = 0 \\<Longrightarrow> P (?q # ?r # ?ps) ?x\\<rbrakk>\n  \\<Longrightarrow> P (?p # ?q # ?r # ?ps) ?x\n  quasi_sturm_seq (p # q # r # ps)\n  poly q x \\<noteq> 0\n  quasi_sturm_seq (q # r # ps)\n\ngoal (1 subgoal):\n 1. P (q # r # ps) x", "by blast"], ["proof (state)\nthis:\n  P (q # r # ps) x\n\ngoal (1 subgoal):\n 1. poly p x = 0 \\<Longrightarrow> P (q # r # ps) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. poly p x = 0 \\<Longrightarrow> P (q # r # ps) x", "assume A: \"poly p x = 0\""], ["proof (state)\nthis:\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. poly p x = 0 \\<Longrightarrow> P (q # r # ps) x", "from 3(6)"], ["proof (chain)\npicking this:\n  quasi_sturm_seq (p # q # r # ps)", "have \"quasi_sturm_seq (q#r#ps)\""], ["proof (prove)\nusing this:\n  quasi_sturm_seq (p # q # r # ps)\n\ngoal (1 subgoal):\n 1. quasi_sturm_seq (q # r # ps)", "by (force dest: quasi_sturm_seq_Cons)"], ["proof (state)\nthis:\n  quasi_sturm_seq (q # r # ps)\n\ngoal (1 subgoal):\n 1. poly p x = 0 \\<Longrightarrow> P (q # r # ps) x", "with 3 A"], ["proof (chain)\npicking this:\n  \\<lbrakk>poly p x \\<noteq> 0 \\<and> poly q x = 0; \\<And>p x. P [p] x;\n   \\<And>p q x. quasi_sturm_seq [p, q] \\<Longrightarrow> P [p, q] x;\n   \\<And>p q r ps x.\n      \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n       \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0\\<rbrakk>\n       \\<Longrightarrow> P (r # ps) x;\n       poly q x \\<noteq> 0 \\<Longrightarrow> P (q # r # ps) x;\n       poly p x = 0 \\<Longrightarrow> P (q # r # ps) x\\<rbrakk>\n      \\<Longrightarrow> P (p # q # r # ps) x;\n   quasi_sturm_seq (r # ps)\\<rbrakk>\n  \\<Longrightarrow> P (r # ps) x\n  \\<lbrakk>\\<not> (poly p x \\<noteq> 0 \\<and> poly q x = 0);\n   \\<And>p x. P [p] x;\n   \\<And>p q x. quasi_sturm_seq [p, q] \\<Longrightarrow> P [p, q] x;\n   \\<And>p q r ps x.\n      \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n       \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0\\<rbrakk>\n       \\<Longrightarrow> P (r # ps) x;\n       poly q x \\<noteq> 0 \\<Longrightarrow> P (q # r # ps) x;\n       poly p x = 0 \\<Longrightarrow> P (q # r # ps) x\\<rbrakk>\n      \\<Longrightarrow> P (p # q # r # ps) x;\n   quasi_sturm_seq (q # r # ps)\\<rbrakk>\n  \\<Longrightarrow> P (q # r # ps) x\n  P [?p] ?x\n  quasi_sturm_seq [?p, ?q] \\<Longrightarrow> P [?p, ?q] ?x\n  \\<lbrakk>quasi_sturm_seq (?p # ?q # ?r # ?ps);\n   \\<lbrakk>poly ?p ?x \\<noteq> 0; poly ?q ?x = 0\\<rbrakk>\n   \\<Longrightarrow> P (?r # ?ps) ?x;\n   poly ?q ?x \\<noteq> 0 \\<Longrightarrow> P (?q # ?r # ?ps) ?x;\n   poly ?p ?x = 0 \\<Longrightarrow> P (?q # ?r # ?ps) ?x\\<rbrakk>\n  \\<Longrightarrow> P (?p # ?q # ?r # ?ps) ?x\n  quasi_sturm_seq (p # q # r # ps)\n  poly p x = 0\n  quasi_sturm_seq (q # r # ps)", "show \"P (q # r # ps) x\""], ["proof (prove)\nusing this:\n  \\<lbrakk>poly p x \\<noteq> 0 \\<and> poly q x = 0; \\<And>p x. P [p] x;\n   \\<And>p q x. quasi_sturm_seq [p, q] \\<Longrightarrow> P [p, q] x;\n   \\<And>p q r ps x.\n      \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n       \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0\\<rbrakk>\n       \\<Longrightarrow> P (r # ps) x;\n       poly q x \\<noteq> 0 \\<Longrightarrow> P (q # r # ps) x;\n       poly p x = 0 \\<Longrightarrow> P (q # r # ps) x\\<rbrakk>\n      \\<Longrightarrow> P (p # q # r # ps) x;\n   quasi_sturm_seq (r # ps)\\<rbrakk>\n  \\<Longrightarrow> P (r # ps) x\n  \\<lbrakk>\\<not> (poly p x \\<noteq> 0 \\<and> poly q x = 0);\n   \\<And>p x. P [p] x;\n   \\<And>p q x. quasi_sturm_seq [p, q] \\<Longrightarrow> P [p, q] x;\n   \\<And>p q r ps x.\n      \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n       \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0\\<rbrakk>\n       \\<Longrightarrow> P (r # ps) x;\n       poly q x \\<noteq> 0 \\<Longrightarrow> P (q # r # ps) x;\n       poly p x = 0 \\<Longrightarrow> P (q # r # ps) x\\<rbrakk>\n      \\<Longrightarrow> P (p # q # r # ps) x;\n   quasi_sturm_seq (q # r # ps)\\<rbrakk>\n  \\<Longrightarrow> P (q # r # ps) x\n  P [?p] ?x\n  quasi_sturm_seq [?p, ?q] \\<Longrightarrow> P [?p, ?q] ?x\n  \\<lbrakk>quasi_sturm_seq (?p # ?q # ?r # ?ps);\n   \\<lbrakk>poly ?p ?x \\<noteq> 0; poly ?q ?x = 0\\<rbrakk>\n   \\<Longrightarrow> P (?r # ?ps) ?x;\n   poly ?q ?x \\<noteq> 0 \\<Longrightarrow> P (?q # ?r # ?ps) ?x;\n   poly ?p ?x = 0 \\<Longrightarrow> P (?q # ?r # ?ps) ?x\\<rbrakk>\n  \\<Longrightarrow> P (?p # ?q # ?r # ?ps) ?x\n  quasi_sturm_seq (p # q # r # ps)\n  poly p x = 0\n  quasi_sturm_seq (q # r # ps)\n\ngoal (1 subgoal):\n 1. P (q # r # ps) x", "by blast"], ["proof (state)\nthis:\n  P (q # r # ps) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P (p # q # r # ps) x\n\ngoal (3 subgoals):\n 1. \\<And>p x.\n       \\<lbrakk>\\<And>p x. P [p] x;\n        \\<And>p q x. quasi_sturm_seq [p, q] \\<Longrightarrow> P [p, q] x;\n        \\<And>p q r ps x.\n           \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n            \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0\\<rbrakk>\n            \\<Longrightarrow> P (r # ps) x;\n            poly q x \\<noteq> 0 \\<Longrightarrow> P (q # r # ps) x;\n            poly p x = 0 \\<Longrightarrow> P (q # r # ps) x\\<rbrakk>\n           \\<Longrightarrow> P (p # q # r # ps) x;\n        quasi_sturm_seq [p]\\<rbrakk>\n       \\<Longrightarrow> P [p] x\n 2. \\<And>p q x.\n       \\<lbrakk>\\<And>p x. P [p] x;\n        \\<And>p q x. quasi_sturm_seq [p, q] \\<Longrightarrow> P [p, q] x;\n        \\<And>p q r ps x.\n           \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n            \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0\\<rbrakk>\n            \\<Longrightarrow> P (r # ps) x;\n            poly q x \\<noteq> 0 \\<Longrightarrow> P (q # r # ps) x;\n            poly p x = 0 \\<Longrightarrow> P (q # r # ps) x\\<rbrakk>\n           \\<Longrightarrow> P (p # q # r # ps) x;\n        quasi_sturm_seq [p, q]\\<rbrakk>\n       \\<Longrightarrow> P [p, q] x\n 3. \\<And>b.\n       \\<lbrakk>\\<And>p x. P [p] x;\n        \\<And>p q x. quasi_sturm_seq [p, q] \\<Longrightarrow> P [p, q] x;\n        \\<And>p q r ps x.\n           \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n            \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0\\<rbrakk>\n            \\<Longrightarrow> P (r # ps) x;\n            poly q x \\<noteq> 0 \\<Longrightarrow> P (q # r # ps) x;\n            poly p x = 0 \\<Longrightarrow> P (q # r # ps) x\\<rbrakk>\n           \\<Longrightarrow> P (p # q # r # ps) x;\n        quasi_sturm_seq []\\<rbrakk>\n       \\<Longrightarrow> P [] b", "qed simp_all"], ["proof (state)\nthis:\n  P ps x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The total number of sign changes in the split list is the same\n  as the number of sign changes in the original list.\n\\<close>"], ["", "lemma (in quasi_sturm_seq) split_sign_changes_correct:\n  assumes \"poly (hd ps) x\\<^sub>0 \\<noteq> 0\"\n  defines \"sign_changes' \\<equiv> \\<lambda>ps x.\n               \\<Sum>ps'\\<leftarrow>split_sign_changes ps x. sign_changes ps' x\"\n  shows \"sign_changes' ps x\\<^sub>0 = sign_changes ps x\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes' ps x\\<^sub>0 = sign_changes ps x\\<^sub>0", "using assms(1)"], ["proof (prove)\nusing this:\n  poly (hd ps) x\\<^sub>0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sign_changes' ps x\\<^sub>0 = sign_changes ps x\\<^sub>0", "proof (induction x\\<^sub>0 rule: split_sign_changes_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>p x.\n       poly (hd [p]) x \\<noteq> 0 \\<Longrightarrow>\n       sign_changes' [p] x = sign_changes [p] x\n 2. \\<And>p q x.\n       \\<lbrakk>quasi_sturm_seq [p, q];\n        poly (hd [p, q]) x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> sign_changes' [p, q] x = sign_changes [p, q] x\n 3. \\<And>p q r ps x.\n       \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n        \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0;\n         poly (hd (r # ps)) x \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> sign_changes' (r # ps) x =\n                          sign_changes (r # ps) x;\n        \\<lbrakk>poly q x \\<noteq> 0;\n         poly (hd (q # r # ps)) x \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> sign_changes' (q # r # ps) x =\n                          sign_changes (q # r # ps) x;\n        \\<lbrakk>poly p x = 0; poly (hd (q # r # ps)) x \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> sign_changes' (q # r # ps) x =\n                          sign_changes (q # r # ps) x;\n        poly (hd (p # q # r # ps)) x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> sign_changes' (p # q # r # ps) x =\n                         sign_changes (p # q # r # ps) x", "case (3 p q r ps x\\<^sub>0)"], ["proof (state)\nthis:\n  quasi_sturm_seq (p # q # r # ps)\n  \\<lbrakk>poly p x\\<^sub>0 \\<noteq> 0; poly q x\\<^sub>0 = 0;\n   poly (hd (r # ps)) x\\<^sub>0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sign_changes' (r # ps) x\\<^sub>0 =\n                    sign_changes (r # ps) x\\<^sub>0\n  \\<lbrakk>poly q x\\<^sub>0 \\<noteq> 0;\n   poly (hd (q # r # ps)) x\\<^sub>0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sign_changes' (q # r # ps) x\\<^sub>0 =\n                    sign_changes (q # r # ps) x\\<^sub>0\n  \\<lbrakk>poly p x\\<^sub>0 = 0;\n   poly (hd (q # r # ps)) x\\<^sub>0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sign_changes' (q # r # ps) x\\<^sub>0 =\n                    sign_changes (q # r # ps) x\\<^sub>0\n  poly (hd (p # q # r # ps)) x\\<^sub>0 \\<noteq> 0\n\ngoal (3 subgoals):\n 1. \\<And>p x.\n       poly (hd [p]) x \\<noteq> 0 \\<Longrightarrow>\n       sign_changes' [p] x = sign_changes [p] x\n 2. \\<And>p q x.\n       \\<lbrakk>quasi_sturm_seq [p, q];\n        poly (hd [p, q]) x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> sign_changes' [p, q] x = sign_changes [p, q] x\n 3. \\<And>p q r ps x.\n       \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n        \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0;\n         poly (hd (r # ps)) x \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> sign_changes' (r # ps) x =\n                          sign_changes (r # ps) x;\n        \\<lbrakk>poly q x \\<noteq> 0;\n         poly (hd (q # r # ps)) x \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> sign_changes' (q # r # ps) x =\n                          sign_changes (q # r # ps) x;\n        \\<lbrakk>poly p x = 0; poly (hd (q # r # ps)) x \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> sign_changes' (q # r # ps) x =\n                          sign_changes (q # r # ps) x;\n        poly (hd (p # q # r # ps)) x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> sign_changes' (p # q # r # ps) x =\n                         sign_changes (p # q # r # ps) x", "hence \"poly p x\\<^sub>0 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  quasi_sturm_seq (p # q # r # ps)\n  \\<lbrakk>poly p x\\<^sub>0 \\<noteq> 0; poly q x\\<^sub>0 = 0;\n   poly (hd (r # ps)) x\\<^sub>0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sign_changes' (r # ps) x\\<^sub>0 =\n                    sign_changes (r # ps) x\\<^sub>0\n  \\<lbrakk>poly q x\\<^sub>0 \\<noteq> 0;\n   poly (hd (q # r # ps)) x\\<^sub>0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sign_changes' (q # r # ps) x\\<^sub>0 =\n                    sign_changes (q # r # ps) x\\<^sub>0\n  \\<lbrakk>poly p x\\<^sub>0 = 0;\n   poly (hd (q # r # ps)) x\\<^sub>0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sign_changes' (q # r # ps) x\\<^sub>0 =\n                    sign_changes (q # r # ps) x\\<^sub>0\n  poly (hd (p # q # r # ps)) x\\<^sub>0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly p x\\<^sub>0 \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  poly p x\\<^sub>0 \\<noteq> 0\n\ngoal (3 subgoals):\n 1. \\<And>p x.\n       poly (hd [p]) x \\<noteq> 0 \\<Longrightarrow>\n       sign_changes' [p] x = sign_changes [p] x\n 2. \\<And>p q x.\n       \\<lbrakk>quasi_sturm_seq [p, q];\n        poly (hd [p, q]) x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> sign_changes' [p, q] x = sign_changes [p, q] x\n 3. \\<And>p q r ps x.\n       \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n        \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0;\n         poly (hd (r # ps)) x \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> sign_changes' (r # ps) x =\n                          sign_changes (r # ps) x;\n        \\<lbrakk>poly q x \\<noteq> 0;\n         poly (hd (q # r # ps)) x \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> sign_changes' (q # r # ps) x =\n                          sign_changes (q # r # ps) x;\n        \\<lbrakk>poly p x = 0; poly (hd (q # r # ps)) x \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> sign_changes' (q # r # ps) x =\n                          sign_changes (q # r # ps) x;\n        poly (hd (p # q # r # ps)) x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> sign_changes' (p # q # r # ps) x =\n                         sign_changes (p # q # r # ps) x", "note IH = 3(2,3,4)"], ["proof (state)\nthis:\n  \\<lbrakk>poly p x\\<^sub>0 \\<noteq> 0; poly q x\\<^sub>0 = 0;\n   poly (hd (r # ps)) x\\<^sub>0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sign_changes' (r # ps) x\\<^sub>0 =\n                    sign_changes (r # ps) x\\<^sub>0\n  \\<lbrakk>poly q x\\<^sub>0 \\<noteq> 0;\n   poly (hd (q # r # ps)) x\\<^sub>0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sign_changes' (q # r # ps) x\\<^sub>0 =\n                    sign_changes (q # r # ps) x\\<^sub>0\n  \\<lbrakk>poly p x\\<^sub>0 = 0;\n   poly (hd (q # r # ps)) x\\<^sub>0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sign_changes' (q # r # ps) x\\<^sub>0 =\n                    sign_changes (q # r # ps) x\\<^sub>0\n\ngoal (3 subgoals):\n 1. \\<And>p x.\n       poly (hd [p]) x \\<noteq> 0 \\<Longrightarrow>\n       sign_changes' [p] x = sign_changes [p] x\n 2. \\<And>p q x.\n       \\<lbrakk>quasi_sturm_seq [p, q];\n        poly (hd [p, q]) x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> sign_changes' [p, q] x = sign_changes [p, q] x\n 3. \\<And>p q r ps x.\n       \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n        \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0;\n         poly (hd (r # ps)) x \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> sign_changes' (r # ps) x =\n                          sign_changes (r # ps) x;\n        \\<lbrakk>poly q x \\<noteq> 0;\n         poly (hd (q # r # ps)) x \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> sign_changes' (q # r # ps) x =\n                          sign_changes (q # r # ps) x;\n        \\<lbrakk>poly p x = 0; poly (hd (q # r # ps)) x \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> sign_changes' (q # r # ps) x =\n                          sign_changes (q # r # ps) x;\n        poly (hd (p # q # r # ps)) x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> sign_changes' (p # q # r # ps) x =\n                         sign_changes (p # q # r # ps) x", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes' (p # q # r # ps) x\\<^sub>0 =\n    sign_changes (p # q # r # ps) x\\<^sub>0", "proof (cases \"poly q x\\<^sub>0 = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. poly q x\\<^sub>0 = 0 \\<Longrightarrow>\n    sign_changes' (p # q # r # ps) x\\<^sub>0 =\n    sign_changes (p # q # r # ps) x\\<^sub>0\n 2. poly q x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n    sign_changes' (p # q # r # ps) x\\<^sub>0 =\n    sign_changes (p # q # r # ps) x\\<^sub>0", "case True"], ["proof (state)\nthis:\n  poly q x\\<^sub>0 = 0\n\ngoal (2 subgoals):\n 1. poly q x\\<^sub>0 = 0 \\<Longrightarrow>\n    sign_changes' (p # q # r # ps) x\\<^sub>0 =\n    sign_changes (p # q # r # ps) x\\<^sub>0\n 2. poly q x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n    sign_changes' (p # q # r # ps) x\\<^sub>0 =\n    sign_changes (p # q # r # ps) x\\<^sub>0", "from 3"], ["proof (chain)\npicking this:\n  quasi_sturm_seq (p # q # r # ps)\n  \\<lbrakk>poly p x\\<^sub>0 \\<noteq> 0; poly q x\\<^sub>0 = 0;\n   poly (hd (r # ps)) x\\<^sub>0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sign_changes' (r # ps) x\\<^sub>0 =\n                    sign_changes (r # ps) x\\<^sub>0\n  \\<lbrakk>poly q x\\<^sub>0 \\<noteq> 0;\n   poly (hd (q # r # ps)) x\\<^sub>0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sign_changes' (q # r # ps) x\\<^sub>0 =\n                    sign_changes (q # r # ps) x\\<^sub>0\n  \\<lbrakk>poly p x\\<^sub>0 = 0;\n   poly (hd (q # r # ps)) x\\<^sub>0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sign_changes' (q # r # ps) x\\<^sub>0 =\n                    sign_changes (q # r # ps) x\\<^sub>0\n  poly (hd (p # q # r # ps)) x\\<^sub>0 \\<noteq> 0", "interpret quasi_sturm_seq \"p#q#r#ps\""], ["proof (prove)\nusing this:\n  quasi_sturm_seq (p # q # r # ps)\n  \\<lbrakk>poly p x\\<^sub>0 \\<noteq> 0; poly q x\\<^sub>0 = 0;\n   poly (hd (r # ps)) x\\<^sub>0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sign_changes' (r # ps) x\\<^sub>0 =\n                    sign_changes (r # ps) x\\<^sub>0\n  \\<lbrakk>poly q x\\<^sub>0 \\<noteq> 0;\n   poly (hd (q # r # ps)) x\\<^sub>0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sign_changes' (q # r # ps) x\\<^sub>0 =\n                    sign_changes (q # r # ps) x\\<^sub>0\n  \\<lbrakk>poly p x\\<^sub>0 = 0;\n   poly (hd (q # r # ps)) x\\<^sub>0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sign_changes' (q # r # ps) x\\<^sub>0 =\n                    sign_changes (q # r # ps) x\\<^sub>0\n  poly (hd (p # q # r # ps)) x\\<^sub>0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. quasi_sturm_seq (p # q # r # ps)", "by simp"], ["proof (state)\ngoal (2 subgoals):\n 1. poly q x\\<^sub>0 = 0 \\<Longrightarrow>\n    sign_changes' (p # q # r # ps) x\\<^sub>0 =\n    sign_changes (p # q # r # ps) x\\<^sub>0\n 2. poly q x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n    sign_changes' (p # q # r # ps) x\\<^sub>0 =\n    sign_changes (p # q # r # ps) x\\<^sub>0", "from signs[of 0] and True"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < length (p # q # r # ps) - 2;\n   poly ((p # q # r # ps) ! (0 + 1)) ?x = 0\\<rbrakk>\n  \\<Longrightarrow> poly ((p # q # r # ps) ! (0 + 2)) ?x *\n                    poly ((p # q # r # ps) ! 0) ?x\n                    < 0\n  poly q x\\<^sub>0 = 0", "have\n           sgn_r_x0: \"poly r x\\<^sub>0 * poly p x\\<^sub>0 < 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < length (p # q # r # ps) - 2;\n   poly ((p # q # r # ps) ! (0 + 1)) ?x = 0\\<rbrakk>\n  \\<Longrightarrow> poly ((p # q # r # ps) ! (0 + 2)) ?x *\n                    poly ((p # q # r # ps) ! 0) ?x\n                    < 0\n  poly q x\\<^sub>0 = 0\n\ngoal (1 subgoal):\n 1. poly r x\\<^sub>0 * poly p x\\<^sub>0 < 0", "by simp"], ["proof (state)\nthis:\n  poly r x\\<^sub>0 * poly p x\\<^sub>0 < 0\n\ngoal (2 subgoals):\n 1. poly q x\\<^sub>0 = 0 \\<Longrightarrow>\n    sign_changes' (p # q # r # ps) x\\<^sub>0 =\n    sign_changes (p # q # r # ps) x\\<^sub>0\n 2. poly q x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n    sign_changes' (p # q # r # ps) x\\<^sub>0 =\n    sign_changes (p # q # r # ps) x\\<^sub>0", "with 3"], ["proof (chain)\npicking this:\n  quasi_sturm_seq (p # q # r # ps)\n  \\<lbrakk>poly p x\\<^sub>0 \\<noteq> 0; poly q x\\<^sub>0 = 0;\n   poly (hd (r # ps)) x\\<^sub>0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sign_changes' (r # ps) x\\<^sub>0 =\n                    sign_changes (r # ps) x\\<^sub>0\n  \\<lbrakk>poly q x\\<^sub>0 \\<noteq> 0;\n   poly (hd (q # r # ps)) x\\<^sub>0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sign_changes' (q # r # ps) x\\<^sub>0 =\n                    sign_changes (q # r # ps) x\\<^sub>0\n  \\<lbrakk>poly p x\\<^sub>0 = 0;\n   poly (hd (q # r # ps)) x\\<^sub>0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sign_changes' (q # r # ps) x\\<^sub>0 =\n                    sign_changes (q # r # ps) x\\<^sub>0\n  poly (hd (p # q # r # ps)) x\\<^sub>0 \\<noteq> 0\n  poly r x\\<^sub>0 * poly p x\\<^sub>0 < 0", "have \"poly r x\\<^sub>0 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  quasi_sturm_seq (p # q # r # ps)\n  \\<lbrakk>poly p x\\<^sub>0 \\<noteq> 0; poly q x\\<^sub>0 = 0;\n   poly (hd (r # ps)) x\\<^sub>0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sign_changes' (r # ps) x\\<^sub>0 =\n                    sign_changes (r # ps) x\\<^sub>0\n  \\<lbrakk>poly q x\\<^sub>0 \\<noteq> 0;\n   poly (hd (q # r # ps)) x\\<^sub>0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sign_changes' (q # r # ps) x\\<^sub>0 =\n                    sign_changes (q # r # ps) x\\<^sub>0\n  \\<lbrakk>poly p x\\<^sub>0 = 0;\n   poly (hd (q # r # ps)) x\\<^sub>0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sign_changes' (q # r # ps) x\\<^sub>0 =\n                    sign_changes (q # r # ps) x\\<^sub>0\n  poly (hd (p # q # r # ps)) x\\<^sub>0 \\<noteq> 0\n  poly r x\\<^sub>0 * poly p x\\<^sub>0 < 0\n\ngoal (1 subgoal):\n 1. poly r x\\<^sub>0 \\<noteq> 0", "by force"], ["proof (state)\nthis:\n  poly r x\\<^sub>0 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. poly q x\\<^sub>0 = 0 \\<Longrightarrow>\n    sign_changes' (p # q # r # ps) x\\<^sub>0 =\n    sign_changes (p # q # r # ps) x\\<^sub>0\n 2. poly q x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n    sign_changes' (p # q # r # ps) x\\<^sub>0 =\n    sign_changes (p # q # r # ps) x\\<^sub>0", "from sign_changes_distrib[OF this, of \"[p,q]\" ps]"], ["proof (chain)\npicking this:\n  sign_changes ([p, q] @ [r] @ ps) x\\<^sub>0 =\n  sign_changes ([p, q] @ [r]) x\\<^sub>0 + sign_changes ([r] @ ps) x\\<^sub>0", "have \"sign_changes (p#q#r#ps) x\\<^sub>0 =\n                  sign_changes ([p, q, r]) x\\<^sub>0 + sign_changes (r # ps) x\\<^sub>0\""], ["proof (prove)\nusing this:\n  sign_changes ([p, q] @ [r] @ ps) x\\<^sub>0 =\n  sign_changes ([p, q] @ [r]) x\\<^sub>0 + sign_changes ([r] @ ps) x\\<^sub>0\n\ngoal (1 subgoal):\n 1. sign_changes (p # q # r # ps) x\\<^sub>0 =\n    sign_changes [p, q, r] x\\<^sub>0 + sign_changes (r # ps) x\\<^sub>0", "by simp"], ["proof (state)\nthis:\n  sign_changes (p # q # r # ps) x\\<^sub>0 =\n  sign_changes [p, q, r] x\\<^sub>0 + sign_changes (r # ps) x\\<^sub>0\n\ngoal (2 subgoals):\n 1. poly q x\\<^sub>0 = 0 \\<Longrightarrow>\n    sign_changes' (p # q # r # ps) x\\<^sub>0 =\n    sign_changes (p # q # r # ps) x\\<^sub>0\n 2. poly q x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n    sign_changes' (p # q # r # ps) x\\<^sub>0 =\n    sign_changes (p # q # r # ps) x\\<^sub>0", "also"], ["proof (state)\nthis:\n  sign_changes (p # q # r # ps) x\\<^sub>0 =\n  sign_changes [p, q, r] x\\<^sub>0 + sign_changes (r # ps) x\\<^sub>0\n\ngoal (2 subgoals):\n 1. poly q x\\<^sub>0 = 0 \\<Longrightarrow>\n    sign_changes' (p # q # r # ps) x\\<^sub>0 =\n    sign_changes (p # q # r # ps) x\\<^sub>0\n 2. poly q x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n    sign_changes' (p # q # r # ps) x\\<^sub>0 =\n    sign_changes (p # q # r # ps) x\\<^sub>0", "have \"sign_changes (r#ps) x\\<^sub>0 = sign_changes' (r#ps) x\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes (r # ps) x\\<^sub>0 = sign_changes' (r # ps) x\\<^sub>0", "using \\<open>poly q x\\<^sub>0 = 0\\<close> \\<open>poly p x\\<^sub>0 \\<noteq> 0\\<close> 3(5)\\<open>poly r x\\<^sub>0 \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  poly q x\\<^sub>0 = 0\n  poly p x\\<^sub>0 \\<noteq> 0\n  poly (hd (p # q # r # ps)) x\\<^sub>0 \\<noteq> 0\n  poly r x\\<^sub>0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sign_changes (r # ps) x\\<^sub>0 = sign_changes' (r # ps) x\\<^sub>0", "by (intro IH(1)[symmetric], simp_all)"], ["proof (state)\nthis:\n  sign_changes (r # ps) x\\<^sub>0 = sign_changes' (r # ps) x\\<^sub>0\n\ngoal (2 subgoals):\n 1. poly q x\\<^sub>0 = 0 \\<Longrightarrow>\n    sign_changes' (p # q # r # ps) x\\<^sub>0 =\n    sign_changes (p # q # r # ps) x\\<^sub>0\n 2. poly q x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n    sign_changes' (p # q # r # ps) x\\<^sub>0 =\n    sign_changes (p # q # r # ps) x\\<^sub>0", "finally"], ["proof (chain)\npicking this:\n  sign_changes (p # q # r # ps) x\\<^sub>0 =\n  sign_changes [p, q, r] x\\<^sub>0 + sign_changes' (r # ps) x\\<^sub>0", "show ?thesis"], ["proof (prove)\nusing this:\n  sign_changes (p # q # r # ps) x\\<^sub>0 =\n  sign_changes [p, q, r] x\\<^sub>0 + sign_changes' (r # ps) x\\<^sub>0\n\ngoal (1 subgoal):\n 1. sign_changes' (p # q # r # ps) x\\<^sub>0 =\n    sign_changes (p # q # r # ps) x\\<^sub>0", "unfolding sign_changes'_def"], ["proof (prove)\nusing this:\n  sign_changes (p # q # r # ps) x\\<^sub>0 =\n  sign_changes [p, q, r] x\\<^sub>0 +\n  (\\<Sum>ps'\\<leftarrow>split_sign_changes (r # ps)\n                         x\\<^sub>0. sign_changes ps' x\\<^sub>0)\n\ngoal (1 subgoal):\n 1. (\\<Sum>ps'\\<leftarrow>split_sign_changes (p # q # r # ps)\n                           x\\<^sub>0. sign_changes ps' x\\<^sub>0) =\n    sign_changes (p # q # r # ps) x\\<^sub>0", "using True \\<open>poly p x\\<^sub>0 \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  sign_changes (p # q # r # ps) x\\<^sub>0 =\n  sign_changes [p, q, r] x\\<^sub>0 +\n  (\\<Sum>ps'\\<leftarrow>split_sign_changes (r # ps)\n                         x\\<^sub>0. sign_changes ps' x\\<^sub>0)\n  poly q x\\<^sub>0 = 0\n  poly p x\\<^sub>0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>ps'\\<leftarrow>split_sign_changes (p # q # r # ps)\n                           x\\<^sub>0. sign_changes ps' x\\<^sub>0) =\n    sign_changes (p # q # r # ps) x\\<^sub>0", "by simp"], ["proof (state)\nthis:\n  sign_changes' (p # q # r # ps) x\\<^sub>0 =\n  sign_changes (p # q # r # ps) x\\<^sub>0\n\ngoal (1 subgoal):\n 1. poly q x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n    sign_changes' (p # q # r # ps) x\\<^sub>0 =\n    sign_changes (p # q # r # ps) x\\<^sub>0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. poly q x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n    sign_changes' (p # q # r # ps) x\\<^sub>0 =\n    sign_changes (p # q # r # ps) x\\<^sub>0", "case False"], ["proof (state)\nthis:\n  poly q x\\<^sub>0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly q x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n    sign_changes' (p # q # r # ps) x\\<^sub>0 =\n    sign_changes (p # q # r # ps) x\\<^sub>0", "from sign_changes_distrib[OF this, of \"[p]\" \"r#ps\"]"], ["proof (chain)\npicking this:\n  sign_changes ([p] @ [q] @ r # ps) x\\<^sub>0 =\n  sign_changes ([p] @ [q]) x\\<^sub>0 + sign_changes ([q] @ r # ps) x\\<^sub>0", "have \"sign_changes (p#q#r#ps) x\\<^sub>0 =\n                  sign_changes ([p,q]) x\\<^sub>0 + sign_changes (q#r#ps) x\\<^sub>0\""], ["proof (prove)\nusing this:\n  sign_changes ([p] @ [q] @ r # ps) x\\<^sub>0 =\n  sign_changes ([p] @ [q]) x\\<^sub>0 + sign_changes ([q] @ r # ps) x\\<^sub>0\n\ngoal (1 subgoal):\n 1. sign_changes (p # q # r # ps) x\\<^sub>0 =\n    sign_changes [p, q] x\\<^sub>0 + sign_changes (q # r # ps) x\\<^sub>0", "by simp"], ["proof (state)\nthis:\n  sign_changes (p # q # r # ps) x\\<^sub>0 =\n  sign_changes [p, q] x\\<^sub>0 + sign_changes (q # r # ps) x\\<^sub>0\n\ngoal (1 subgoal):\n 1. poly q x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n    sign_changes' (p # q # r # ps) x\\<^sub>0 =\n    sign_changes (p # q # r # ps) x\\<^sub>0", "also"], ["proof (state)\nthis:\n  sign_changes (p # q # r # ps) x\\<^sub>0 =\n  sign_changes [p, q] x\\<^sub>0 + sign_changes (q # r # ps) x\\<^sub>0\n\ngoal (1 subgoal):\n 1. poly q x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n    sign_changes' (p # q # r # ps) x\\<^sub>0 =\n    sign_changes (p # q # r # ps) x\\<^sub>0", "have \"sign_changes (q#r#ps) x\\<^sub>0 = sign_changes' (q#r#ps) x\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes (q # r # ps) x\\<^sub>0 =\n    sign_changes' (q # r # ps) x\\<^sub>0", "using \\<open>poly q x\\<^sub>0 \\<noteq> 0\\<close> \\<open>poly p x\\<^sub>0 \\<noteq> 0\\<close> 3(5)"], ["proof (prove)\nusing this:\n  poly q x\\<^sub>0 \\<noteq> 0\n  poly p x\\<^sub>0 \\<noteq> 0\n  poly (hd (p # q # r # ps)) x\\<^sub>0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sign_changes (q # r # ps) x\\<^sub>0 =\n    sign_changes' (q # r # ps) x\\<^sub>0", "by (intro IH(2)[symmetric], simp_all)"], ["proof (state)\nthis:\n  sign_changes (q # r # ps) x\\<^sub>0 = sign_changes' (q # r # ps) x\\<^sub>0\n\ngoal (1 subgoal):\n 1. poly q x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n    sign_changes' (p # q # r # ps) x\\<^sub>0 =\n    sign_changes (p # q # r # ps) x\\<^sub>0", "finally"], ["proof (chain)\npicking this:\n  sign_changes (p # q # r # ps) x\\<^sub>0 =\n  sign_changes [p, q] x\\<^sub>0 + sign_changes' (q # r # ps) x\\<^sub>0", "show ?thesis"], ["proof (prove)\nusing this:\n  sign_changes (p # q # r # ps) x\\<^sub>0 =\n  sign_changes [p, q] x\\<^sub>0 + sign_changes' (q # r # ps) x\\<^sub>0\n\ngoal (1 subgoal):\n 1. sign_changes' (p # q # r # ps) x\\<^sub>0 =\n    sign_changes (p # q # r # ps) x\\<^sub>0", "unfolding sign_changes'_def"], ["proof (prove)\nusing this:\n  sign_changes (p # q # r # ps) x\\<^sub>0 =\n  sign_changes [p, q] x\\<^sub>0 +\n  (\\<Sum>ps'\\<leftarrow>split_sign_changes (q # r # ps)\n                         x\\<^sub>0. sign_changes ps' x\\<^sub>0)\n\ngoal (1 subgoal):\n 1. (\\<Sum>ps'\\<leftarrow>split_sign_changes (p # q # r # ps)\n                           x\\<^sub>0. sign_changes ps' x\\<^sub>0) =\n    sign_changes (p # q # r # ps) x\\<^sub>0", "using False"], ["proof (prove)\nusing this:\n  sign_changes (p # q # r # ps) x\\<^sub>0 =\n  sign_changes [p, q] x\\<^sub>0 +\n  (\\<Sum>ps'\\<leftarrow>split_sign_changes (q # r # ps)\n                         x\\<^sub>0. sign_changes ps' x\\<^sub>0)\n  poly q x\\<^sub>0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>ps'\\<leftarrow>split_sign_changes (p # q # r # ps)\n                           x\\<^sub>0. sign_changes ps' x\\<^sub>0) =\n    sign_changes (p # q # r # ps) x\\<^sub>0", "by simp"], ["proof (state)\nthis:\n  sign_changes' (p # q # r # ps) x\\<^sub>0 =\n  sign_changes (p # q # r # ps) x\\<^sub>0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sign_changes' (p # q # r # ps) x\\<^sub>0 =\n  sign_changes (p # q # r # ps) x\\<^sub>0\n\ngoal (2 subgoals):\n 1. \\<And>p x.\n       poly (hd [p]) x \\<noteq> 0 \\<Longrightarrow>\n       sign_changes' [p] x = sign_changes [p] x\n 2. \\<And>p q x.\n       \\<lbrakk>quasi_sturm_seq [p, q];\n        poly (hd [p, q]) x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> sign_changes' [p, q] x = sign_changes [p, q] x", "qed (simp_all add: sign_changes_def sign_changes'_def)"], ["", "text \\<open>\n  We now prove that if $p(x)\\neq 0$, the number of sign changes of a Sturm sequence of $p$\n  at $x$ is constant in a neighbourhood of $x$.\n\\<close>"], ["", "lemma (in quasi_sturm_seq) split_sign_changes_correct_nbh:\n  assumes \"poly (hd ps) x\\<^sub>0 \\<noteq> 0\"\n  defines \"sign_changes' \\<equiv> \\<lambda>x\\<^sub>0 ps x.\n               \\<Sum>ps'\\<leftarrow>split_sign_changes ps x\\<^sub>0. sign_changes ps' x\"\n  shows \"eventually (\\<lambda>x. sign_changes' x\\<^sub>0 ps x = sign_changes ps x) (at x\\<^sub>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes' x\\<^sub>0 ps x = sign_changes ps x", "proof (rule eventually_mono)"], ["proof (state)\ngoal (2 subgoals):\n 1. eventually ?P (at x\\<^sub>0)\n 2. \\<And>x.\n       ?P x \\<Longrightarrow>\n       sign_changes' x\\<^sub>0 ps x = sign_changes ps x", "show \"eventually (\\<lambda>x. \\<forall>p\\<in>{p \\<in> set ps. poly p x\\<^sub>0 \\<noteq> 0}. sgn (poly p x) = sgn (poly p x\\<^sub>0)) (at x\\<^sub>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       \\<forall>p\\<in>{p \\<in> set ps. poly p x\\<^sub>0 \\<noteq> 0}.\n          sgn (poly p x) = sgn (poly p x\\<^sub>0)", "by (rule eventually_ball_finite, auto intro: poly_neighbourhood_same_sign)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     \\<forall>p\\<in>{p \\<in> set ps. poly p x\\<^sub>0 \\<noteq> 0}.\n        sgn (poly p x) = sgn (poly p x\\<^sub>0)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>p\\<in>{p \\<in> set ps. poly p x\\<^sub>0 \\<noteq> 0}.\n          sgn (poly p x) = sgn (poly p x\\<^sub>0) \\<Longrightarrow>\n       sign_changes' x\\<^sub>0 ps x = sign_changes ps x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>p\\<in>{p \\<in> set ps. poly p x\\<^sub>0 \\<noteq> 0}.\n          sgn (poly p x) = sgn (poly p x\\<^sub>0) \\<Longrightarrow>\n       sign_changes' x\\<^sub>0 ps x = sign_changes ps x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>p\\<in>{p \\<in> set ps. poly p x\\<^sub>0 \\<noteq> 0}.\n          sgn (poly p x) = sgn (poly p x\\<^sub>0) \\<Longrightarrow>\n       sign_changes' x\\<^sub>0 ps x = sign_changes ps x", "show \"(\\<forall>p\\<in>{p \\<in> set ps. poly p x\\<^sub>0 \\<noteq> 0}. sgn (poly p x) = sgn (poly p x\\<^sub>0)) \\<Longrightarrow>\n        sign_changes' x\\<^sub>0 ps x = sign_changes ps x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>{p \\<in> set ps. poly p x\\<^sub>0 \\<noteq> 0}.\n       sgn (poly p x) = sgn (poly p x\\<^sub>0) \\<Longrightarrow>\n    sign_changes' x\\<^sub>0 ps x = sign_changes ps x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>{p \\<in> set ps. poly p x\\<^sub>0 \\<noteq> 0}.\n       sgn (poly p x) = sgn (poly p x\\<^sub>0) \\<Longrightarrow>\n    sign_changes' x\\<^sub>0 ps x = sign_changes ps x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>{p \\<in> set ps. poly p x\\<^sub>0 \\<noteq> 0}.\n       sgn (poly p x__) = sgn (poly p x\\<^sub>0) \\<Longrightarrow>\n    sign_changes' x\\<^sub>0 ps x__ = sign_changes ps x__", "assume nbh: \"\\<forall>p\\<in>{p \\<in> set ps. poly p x\\<^sub>0 \\<noteq> 0}. sgn (poly p x) = sgn (poly p x\\<^sub>0)\""], ["proof (state)\nthis:\n  \\<forall>p\\<in>{p \\<in> set ps. poly p x\\<^sub>0 \\<noteq> 0}.\n     sgn (poly p x) = sgn (poly p x\\<^sub>0)\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>{p \\<in> set ps. poly p x\\<^sub>0 \\<noteq> 0}.\n       sgn (poly p x__) = sgn (poly p x\\<^sub>0) \\<Longrightarrow>\n    sign_changes' x\\<^sub>0 ps x__ = sign_changes ps x__", "thus \"sign_changes' x\\<^sub>0 ps x = sign_changes ps x\""], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>{p \\<in> set ps. poly p x\\<^sub>0 \\<noteq> 0}.\n     sgn (poly p x) = sgn (poly p x\\<^sub>0)\n\ngoal (1 subgoal):\n 1. sign_changes' x\\<^sub>0 ps x = sign_changes ps x", "using assms(1)"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>{p \\<in> set ps. poly p x\\<^sub>0 \\<noteq> 0}.\n     sgn (poly p x) = sgn (poly p x\\<^sub>0)\n  poly (hd ps) x\\<^sub>0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sign_changes' x\\<^sub>0 ps x = sign_changes ps x", "proof (induction x\\<^sub>0 rule: split_sign_changes_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>p x.\n       \\<lbrakk>\\<forall>p\\<in>{pa \\<in> set [p]. poly pa x \\<noteq> 0}.\n                   sgn (poly p x) = sgn (poly p x);\n        poly (hd [p]) x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> sign_changes' x [p] x = sign_changes [p] x\n 2. \\<And>p q x.\n       \\<lbrakk>quasi_sturm_seq [p, q];\n        \\<forall>p\\<in>{pa \\<in> set [p, q]. poly pa x \\<noteq> 0}.\n           sgn (poly p x) = sgn (poly p x);\n        poly (hd [p, q]) x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> sign_changes' x [p, q] x = sign_changes [p, q] x\n 3. \\<And>p q r ps x.\n       \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n        \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0;\n         \\<forall>p\\<in>{p \\<in> set (r # ps). poly p x \\<noteq> 0}.\n            sgn (poly p x) = sgn (poly p x);\n         poly (hd (r # ps)) x \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> sign_changes' x (r # ps) x =\n                          sign_changes (r # ps) x;\n        \\<lbrakk>poly q x \\<noteq> 0;\n         \\<forall>p\\<in>{p \\<in> set (q # r # ps). poly p x \\<noteq> 0}.\n            sgn (poly p x) = sgn (poly p x);\n         poly (hd (q # r # ps)) x \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> sign_changes' x (q # r # ps) x =\n                          sign_changes (q # r # ps) x;\n        \\<lbrakk>poly p x = 0;\n         \\<forall>p\\<in>{p \\<in> set (q # r # ps). poly p x \\<noteq> 0}.\n            sgn (poly p x) = sgn (poly p x);\n         poly (hd (q # r # ps)) x \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> sign_changes' x (q # r # ps) x =\n                          sign_changes (q # r # ps) x;\n        \\<forall>p\\<in>{pa \\<in> set (p # q # r # ps).\n                        poly pa x \\<noteq> 0}.\n           sgn (poly p x) = sgn (poly p x);\n        poly (hd (p # q # r # ps)) x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> sign_changes' x (p # q # r # ps) x =\n                         sign_changes (p # q # r # ps) x", "case (3 p q r ps x\\<^sub>0)"], ["proof (state)\nthis:\n  quasi_sturm_seq (p # q # r # ps)\n  \\<lbrakk>poly p x\\<^sub>0 \\<noteq> 0; poly q x\\<^sub>0 = 0;\n   \\<forall>p\\<in>{p \\<in> set (r # ps). poly p x\\<^sub>0 \\<noteq> 0}.\n      sgn (poly p x) = sgn (poly p x\\<^sub>0);\n   poly (hd (r # ps)) x\\<^sub>0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sign_changes' x\\<^sub>0 (r # ps) x =\n                    sign_changes (r # ps) x\n  \\<lbrakk>poly q x\\<^sub>0 \\<noteq> 0;\n   \\<forall>p\\<in>{p \\<in> set (q # r # ps). poly p x\\<^sub>0 \\<noteq> 0}.\n      sgn (poly p x) = sgn (poly p x\\<^sub>0);\n   poly (hd (q # r # ps)) x\\<^sub>0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sign_changes' x\\<^sub>0 (q # r # ps) x =\n                    sign_changes (q # r # ps) x\n  \\<lbrakk>poly p x\\<^sub>0 = 0;\n   \\<forall>p\\<in>{p \\<in> set (q # r # ps). poly p x\\<^sub>0 \\<noteq> 0}.\n      sgn (poly p x) = sgn (poly p x\\<^sub>0);\n   poly (hd (q # r # ps)) x\\<^sub>0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sign_changes' x\\<^sub>0 (q # r # ps) x =\n                    sign_changes (q # r # ps) x\n  \\<forall>p\\<in>{pa \\<in> set (p # q # r # ps).\n                  poly pa x\\<^sub>0 \\<noteq> 0}.\n     sgn (poly p x) = sgn (poly p x\\<^sub>0)\n  poly (hd (p # q # r # ps)) x\\<^sub>0 \\<noteq> 0\n\ngoal (3 subgoals):\n 1. \\<And>p x.\n       \\<lbrakk>\\<forall>p\\<in>{pa \\<in> set [p]. poly pa x \\<noteq> 0}.\n                   sgn (poly p x) = sgn (poly p x);\n        poly (hd [p]) x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> sign_changes' x [p] x = sign_changes [p] x\n 2. \\<And>p q x.\n       \\<lbrakk>quasi_sturm_seq [p, q];\n        \\<forall>p\\<in>{pa \\<in> set [p, q]. poly pa x \\<noteq> 0}.\n           sgn (poly p x) = sgn (poly p x);\n        poly (hd [p, q]) x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> sign_changes' x [p, q] x = sign_changes [p, q] x\n 3. \\<And>p q r ps x.\n       \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n        \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0;\n         \\<forall>p\\<in>{p \\<in> set (r # ps). poly p x \\<noteq> 0}.\n            sgn (poly p x) = sgn (poly p x);\n         poly (hd (r # ps)) x \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> sign_changes' x (r # ps) x =\n                          sign_changes (r # ps) x;\n        \\<lbrakk>poly q x \\<noteq> 0;\n         \\<forall>p\\<in>{p \\<in> set (q # r # ps). poly p x \\<noteq> 0}.\n            sgn (poly p x) = sgn (poly p x);\n         poly (hd (q # r # ps)) x \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> sign_changes' x (q # r # ps) x =\n                          sign_changes (q # r # ps) x;\n        \\<lbrakk>poly p x = 0;\n         \\<forall>p\\<in>{p \\<in> set (q # r # ps). poly p x \\<noteq> 0}.\n            sgn (poly p x) = sgn (poly p x);\n         poly (hd (q # r # ps)) x \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> sign_changes' x (q # r # ps) x =\n                          sign_changes (q # r # ps) x;\n        \\<forall>p\\<in>{pa \\<in> set (p # q # r # ps).\n                        poly pa x \\<noteq> 0}.\n           sgn (poly p x) = sgn (poly p x);\n        poly (hd (p # q # r # ps)) x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> sign_changes' x (p # q # r # ps) x =\n                         sign_changes (p # q # r # ps) x", "hence \"poly p x\\<^sub>0 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  quasi_sturm_seq (p # q # r # ps)\n  \\<lbrakk>poly p x\\<^sub>0 \\<noteq> 0; poly q x\\<^sub>0 = 0;\n   \\<forall>p\\<in>{p \\<in> set (r # ps). poly p x\\<^sub>0 \\<noteq> 0}.\n      sgn (poly p x) = sgn (poly p x\\<^sub>0);\n   poly (hd (r # ps)) x\\<^sub>0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sign_changes' x\\<^sub>0 (r # ps) x =\n                    sign_changes (r # ps) x\n  \\<lbrakk>poly q x\\<^sub>0 \\<noteq> 0;\n   \\<forall>p\\<in>{p \\<in> set (q # r # ps). poly p x\\<^sub>0 \\<noteq> 0}.\n      sgn (poly p x) = sgn (poly p x\\<^sub>0);\n   poly (hd (q # r # ps)) x\\<^sub>0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sign_changes' x\\<^sub>0 (q # r # ps) x =\n                    sign_changes (q # r # ps) x\n  \\<lbrakk>poly p x\\<^sub>0 = 0;\n   \\<forall>p\\<in>{p \\<in> set (q # r # ps). poly p x\\<^sub>0 \\<noteq> 0}.\n      sgn (poly p x) = sgn (poly p x\\<^sub>0);\n   poly (hd (q # r # ps)) x\\<^sub>0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sign_changes' x\\<^sub>0 (q # r # ps) x =\n                    sign_changes (q # r # ps) x\n  \\<forall>p\\<in>{pa \\<in> set (p # q # r # ps).\n                  poly pa x\\<^sub>0 \\<noteq> 0}.\n     sgn (poly p x) = sgn (poly p x\\<^sub>0)\n  poly (hd (p # q # r # ps)) x\\<^sub>0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly p x\\<^sub>0 \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  poly p x\\<^sub>0 \\<noteq> 0\n\ngoal (3 subgoals):\n 1. \\<And>p x.\n       \\<lbrakk>\\<forall>p\\<in>{pa \\<in> set [p]. poly pa x \\<noteq> 0}.\n                   sgn (poly p x) = sgn (poly p x);\n        poly (hd [p]) x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> sign_changes' x [p] x = sign_changes [p] x\n 2. \\<And>p q x.\n       \\<lbrakk>quasi_sturm_seq [p, q];\n        \\<forall>p\\<in>{pa \\<in> set [p, q]. poly pa x \\<noteq> 0}.\n           sgn (poly p x) = sgn (poly p x);\n        poly (hd [p, q]) x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> sign_changes' x [p, q] x = sign_changes [p, q] x\n 3. \\<And>p q r ps x.\n       \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n        \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0;\n         \\<forall>p\\<in>{p \\<in> set (r # ps). poly p x \\<noteq> 0}.\n            sgn (poly p x) = sgn (poly p x);\n         poly (hd (r # ps)) x \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> sign_changes' x (r # ps) x =\n                          sign_changes (r # ps) x;\n        \\<lbrakk>poly q x \\<noteq> 0;\n         \\<forall>p\\<in>{p \\<in> set (q # r # ps). poly p x \\<noteq> 0}.\n            sgn (poly p x) = sgn (poly p x);\n         poly (hd (q # r # ps)) x \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> sign_changes' x (q # r # ps) x =\n                          sign_changes (q # r # ps) x;\n        \\<lbrakk>poly p x = 0;\n         \\<forall>p\\<in>{p \\<in> set (q # r # ps). poly p x \\<noteq> 0}.\n            sgn (poly p x) = sgn (poly p x);\n         poly (hd (q # r # ps)) x \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> sign_changes' x (q # r # ps) x =\n                          sign_changes (q # r # ps) x;\n        \\<forall>p\\<in>{pa \\<in> set (p # q # r # ps).\n                        poly pa x \\<noteq> 0}.\n           sgn (poly p x) = sgn (poly p x);\n        poly (hd (p # q # r # ps)) x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> sign_changes' x (p # q # r # ps) x =\n                         sign_changes (p # q # r # ps) x", "note IH = 3(2,3,4)"], ["proof (state)\nthis:\n  \\<lbrakk>poly p x\\<^sub>0 \\<noteq> 0; poly q x\\<^sub>0 = 0;\n   \\<forall>p\\<in>{p \\<in> set (r # ps). poly p x\\<^sub>0 \\<noteq> 0}.\n      sgn (poly p x) = sgn (poly p x\\<^sub>0);\n   poly (hd (r # ps)) x\\<^sub>0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sign_changes' x\\<^sub>0 (r # ps) x =\n                    sign_changes (r # ps) x\n  \\<lbrakk>poly q x\\<^sub>0 \\<noteq> 0;\n   \\<forall>p\\<in>{p \\<in> set (q # r # ps). poly p x\\<^sub>0 \\<noteq> 0}.\n      sgn (poly p x) = sgn (poly p x\\<^sub>0);\n   poly (hd (q # r # ps)) x\\<^sub>0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sign_changes' x\\<^sub>0 (q # r # ps) x =\n                    sign_changes (q # r # ps) x\n  \\<lbrakk>poly p x\\<^sub>0 = 0;\n   \\<forall>p\\<in>{p \\<in> set (q # r # ps). poly p x\\<^sub>0 \\<noteq> 0}.\n      sgn (poly p x) = sgn (poly p x\\<^sub>0);\n   poly (hd (q # r # ps)) x\\<^sub>0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sign_changes' x\\<^sub>0 (q # r # ps) x =\n                    sign_changes (q # r # ps) x\n\ngoal (3 subgoals):\n 1. \\<And>p x.\n       \\<lbrakk>\\<forall>p\\<in>{pa \\<in> set [p]. poly pa x \\<noteq> 0}.\n                   sgn (poly p x) = sgn (poly p x);\n        poly (hd [p]) x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> sign_changes' x [p] x = sign_changes [p] x\n 2. \\<And>p q x.\n       \\<lbrakk>quasi_sturm_seq [p, q];\n        \\<forall>p\\<in>{pa \\<in> set [p, q]. poly pa x \\<noteq> 0}.\n           sgn (poly p x) = sgn (poly p x);\n        poly (hd [p, q]) x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> sign_changes' x [p, q] x = sign_changes [p, q] x\n 3. \\<And>p q r ps x.\n       \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n        \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0;\n         \\<forall>p\\<in>{p \\<in> set (r # ps). poly p x \\<noteq> 0}.\n            sgn (poly p x) = sgn (poly p x);\n         poly (hd (r # ps)) x \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> sign_changes' x (r # ps) x =\n                          sign_changes (r # ps) x;\n        \\<lbrakk>poly q x \\<noteq> 0;\n         \\<forall>p\\<in>{p \\<in> set (q # r # ps). poly p x \\<noteq> 0}.\n            sgn (poly p x) = sgn (poly p x);\n         poly (hd (q # r # ps)) x \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> sign_changes' x (q # r # ps) x =\n                          sign_changes (q # r # ps) x;\n        \\<lbrakk>poly p x = 0;\n         \\<forall>p\\<in>{p \\<in> set (q # r # ps). poly p x \\<noteq> 0}.\n            sgn (poly p x) = sgn (poly p x);\n         poly (hd (q # r # ps)) x \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> sign_changes' x (q # r # ps) x =\n                          sign_changes (q # r # ps) x;\n        \\<forall>p\\<in>{pa \\<in> set (p # q # r # ps).\n                        poly pa x \\<noteq> 0}.\n           sgn (poly p x) = sgn (poly p x);\n        poly (hd (p # q # r # ps)) x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> sign_changes' x (p # q # r # ps) x =\n                         sign_changes (p # q # r # ps) x", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes' x\\<^sub>0 (p # q # r # ps) x =\n    sign_changes (p # q # r # ps) x", "proof (cases \"poly q x\\<^sub>0 = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. poly q x\\<^sub>0 = 0 \\<Longrightarrow>\n    sign_changes' x\\<^sub>0 (p # q # r # ps) x =\n    sign_changes (p # q # r # ps) x\n 2. poly q x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n    sign_changes' x\\<^sub>0 (p # q # r # ps) x =\n    sign_changes (p # q # r # ps) x", "case True"], ["proof (state)\nthis:\n  poly q x\\<^sub>0 = 0\n\ngoal (2 subgoals):\n 1. poly q x\\<^sub>0 = 0 \\<Longrightarrow>\n    sign_changes' x\\<^sub>0 (p # q # r # ps) x =\n    sign_changes (p # q # r # ps) x\n 2. poly q x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n    sign_changes' x\\<^sub>0 (p # q # r # ps) x =\n    sign_changes (p # q # r # ps) x", "from 3"], ["proof (chain)\npicking this:\n  quasi_sturm_seq (p # q # r # ps)\n  \\<lbrakk>poly p x\\<^sub>0 \\<noteq> 0; poly q x\\<^sub>0 = 0;\n   \\<forall>p\\<in>{p \\<in> set (r # ps). poly p x\\<^sub>0 \\<noteq> 0}.\n      sgn (poly p x) = sgn (poly p x\\<^sub>0);\n   poly (hd (r # ps)) x\\<^sub>0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sign_changes' x\\<^sub>0 (r # ps) x =\n                    sign_changes (r # ps) x\n  \\<lbrakk>poly q x\\<^sub>0 \\<noteq> 0;\n   \\<forall>p\\<in>{p \\<in> set (q # r # ps). poly p x\\<^sub>0 \\<noteq> 0}.\n      sgn (poly p x) = sgn (poly p x\\<^sub>0);\n   poly (hd (q # r # ps)) x\\<^sub>0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sign_changes' x\\<^sub>0 (q # r # ps) x =\n                    sign_changes (q # r # ps) x\n  \\<lbrakk>poly p x\\<^sub>0 = 0;\n   \\<forall>p\\<in>{p \\<in> set (q # r # ps). poly p x\\<^sub>0 \\<noteq> 0}.\n      sgn (poly p x) = sgn (poly p x\\<^sub>0);\n   poly (hd (q # r # ps)) x\\<^sub>0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sign_changes' x\\<^sub>0 (q # r # ps) x =\n                    sign_changes (q # r # ps) x\n  \\<forall>p\\<in>{pa \\<in> set (p # q # r # ps).\n                  poly pa x\\<^sub>0 \\<noteq> 0}.\n     sgn (poly p x) = sgn (poly p x\\<^sub>0)\n  poly (hd (p # q # r # ps)) x\\<^sub>0 \\<noteq> 0", "interpret quasi_sturm_seq \"p#q#r#ps\""], ["proof (prove)\nusing this:\n  quasi_sturm_seq (p # q # r # ps)\n  \\<lbrakk>poly p x\\<^sub>0 \\<noteq> 0; poly q x\\<^sub>0 = 0;\n   \\<forall>p\\<in>{p \\<in> set (r # ps). poly p x\\<^sub>0 \\<noteq> 0}.\n      sgn (poly p x) = sgn (poly p x\\<^sub>0);\n   poly (hd (r # ps)) x\\<^sub>0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sign_changes' x\\<^sub>0 (r # ps) x =\n                    sign_changes (r # ps) x\n  \\<lbrakk>poly q x\\<^sub>0 \\<noteq> 0;\n   \\<forall>p\\<in>{p \\<in> set (q # r # ps). poly p x\\<^sub>0 \\<noteq> 0}.\n      sgn (poly p x) = sgn (poly p x\\<^sub>0);\n   poly (hd (q # r # ps)) x\\<^sub>0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sign_changes' x\\<^sub>0 (q # r # ps) x =\n                    sign_changes (q # r # ps) x\n  \\<lbrakk>poly p x\\<^sub>0 = 0;\n   \\<forall>p\\<in>{p \\<in> set (q # r # ps). poly p x\\<^sub>0 \\<noteq> 0}.\n      sgn (poly p x) = sgn (poly p x\\<^sub>0);\n   poly (hd (q # r # ps)) x\\<^sub>0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sign_changes' x\\<^sub>0 (q # r # ps) x =\n                    sign_changes (q # r # ps) x\n  \\<forall>p\\<in>{pa \\<in> set (p # q # r # ps).\n                  poly pa x\\<^sub>0 \\<noteq> 0}.\n     sgn (poly p x) = sgn (poly p x\\<^sub>0)\n  poly (hd (p # q # r # ps)) x\\<^sub>0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. quasi_sturm_seq (p # q # r # ps)", "by simp"], ["proof (state)\ngoal (2 subgoals):\n 1. poly q x\\<^sub>0 = 0 \\<Longrightarrow>\n    sign_changes' x\\<^sub>0 (p # q # r # ps) x =\n    sign_changes (p # q # r # ps) x\n 2. poly q x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n    sign_changes' x\\<^sub>0 (p # q # r # ps) x =\n    sign_changes (p # q # r # ps) x", "from signs[of 0] and True"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < length (p # q # r # ps) - 2;\n   poly ((p # q # r # ps) ! (0 + 1)) ?x = 0\\<rbrakk>\n  \\<Longrightarrow> poly ((p # q # r # ps) ! (0 + 2)) ?x *\n                    poly ((p # q # r # ps) ! 0) ?x\n                    < 0\n  poly q x\\<^sub>0 = 0", "have\n               sgn_r_x0: \"poly r x\\<^sub>0 * poly p x\\<^sub>0 < 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < length (p # q # r # ps) - 2;\n   poly ((p # q # r # ps) ! (0 + 1)) ?x = 0\\<rbrakk>\n  \\<Longrightarrow> poly ((p # q # r # ps) ! (0 + 2)) ?x *\n                    poly ((p # q # r # ps) ! 0) ?x\n                    < 0\n  poly q x\\<^sub>0 = 0\n\ngoal (1 subgoal):\n 1. poly r x\\<^sub>0 * poly p x\\<^sub>0 < 0", "by simp"], ["proof (state)\nthis:\n  poly r x\\<^sub>0 * poly p x\\<^sub>0 < 0\n\ngoal (2 subgoals):\n 1. poly q x\\<^sub>0 = 0 \\<Longrightarrow>\n    sign_changes' x\\<^sub>0 (p # q # r # ps) x =\n    sign_changes (p # q # r # ps) x\n 2. poly q x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n    sign_changes' x\\<^sub>0 (p # q # r # ps) x =\n    sign_changes (p # q # r # ps) x", "with 3"], ["proof (chain)\npicking this:\n  quasi_sturm_seq (p # q # r # ps)\n  \\<lbrakk>poly p x\\<^sub>0 \\<noteq> 0; poly q x\\<^sub>0 = 0;\n   \\<forall>p\\<in>{p \\<in> set (r # ps). poly p x\\<^sub>0 \\<noteq> 0}.\n      sgn (poly p x) = sgn (poly p x\\<^sub>0);\n   poly (hd (r # ps)) x\\<^sub>0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sign_changes' x\\<^sub>0 (r # ps) x =\n                    sign_changes (r # ps) x\n  \\<lbrakk>poly q x\\<^sub>0 \\<noteq> 0;\n   \\<forall>p\\<in>{p \\<in> set (q # r # ps). poly p x\\<^sub>0 \\<noteq> 0}.\n      sgn (poly p x) = sgn (poly p x\\<^sub>0);\n   poly (hd (q # r # ps)) x\\<^sub>0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sign_changes' x\\<^sub>0 (q # r # ps) x =\n                    sign_changes (q # r # ps) x\n  \\<lbrakk>poly p x\\<^sub>0 = 0;\n   \\<forall>p\\<in>{p \\<in> set (q # r # ps). poly p x\\<^sub>0 \\<noteq> 0}.\n      sgn (poly p x) = sgn (poly p x\\<^sub>0);\n   poly (hd (q # r # ps)) x\\<^sub>0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sign_changes' x\\<^sub>0 (q # r # ps) x =\n                    sign_changes (q # r # ps) x\n  \\<forall>p\\<in>{pa \\<in> set (p # q # r # ps).\n                  poly pa x\\<^sub>0 \\<noteq> 0}.\n     sgn (poly p x) = sgn (poly p x\\<^sub>0)\n  poly (hd (p # q # r # ps)) x\\<^sub>0 \\<noteq> 0\n  poly r x\\<^sub>0 * poly p x\\<^sub>0 < 0", "have \"poly r x\\<^sub>0 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  quasi_sturm_seq (p # q # r # ps)\n  \\<lbrakk>poly p x\\<^sub>0 \\<noteq> 0; poly q x\\<^sub>0 = 0;\n   \\<forall>p\\<in>{p \\<in> set (r # ps). poly p x\\<^sub>0 \\<noteq> 0}.\n      sgn (poly p x) = sgn (poly p x\\<^sub>0);\n   poly (hd (r # ps)) x\\<^sub>0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sign_changes' x\\<^sub>0 (r # ps) x =\n                    sign_changes (r # ps) x\n  \\<lbrakk>poly q x\\<^sub>0 \\<noteq> 0;\n   \\<forall>p\\<in>{p \\<in> set (q # r # ps). poly p x\\<^sub>0 \\<noteq> 0}.\n      sgn (poly p x) = sgn (poly p x\\<^sub>0);\n   poly (hd (q # r # ps)) x\\<^sub>0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sign_changes' x\\<^sub>0 (q # r # ps) x =\n                    sign_changes (q # r # ps) x\n  \\<lbrakk>poly p x\\<^sub>0 = 0;\n   \\<forall>p\\<in>{p \\<in> set (q # r # ps). poly p x\\<^sub>0 \\<noteq> 0}.\n      sgn (poly p x) = sgn (poly p x\\<^sub>0);\n   poly (hd (q # r # ps)) x\\<^sub>0 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sign_changes' x\\<^sub>0 (q # r # ps) x =\n                    sign_changes (q # r # ps) x\n  \\<forall>p\\<in>{pa \\<in> set (p # q # r # ps).\n                  poly pa x\\<^sub>0 \\<noteq> 0}.\n     sgn (poly p x) = sgn (poly p x\\<^sub>0)\n  poly (hd (p # q # r # ps)) x\\<^sub>0 \\<noteq> 0\n  poly r x\\<^sub>0 * poly p x\\<^sub>0 < 0\n\ngoal (1 subgoal):\n 1. poly r x\\<^sub>0 \\<noteq> 0", "by force"], ["proof (state)\nthis:\n  poly r x\\<^sub>0 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. poly q x\\<^sub>0 = 0 \\<Longrightarrow>\n    sign_changes' x\\<^sub>0 (p # q # r # ps) x =\n    sign_changes (p # q # r # ps) x\n 2. poly q x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n    sign_changes' x\\<^sub>0 (p # q # r # ps) x =\n    sign_changes (p # q # r # ps) x", "with nbh 3(5)"], ["proof (chain)\npicking this:\n  \\<forall>p\\<in>{p \\<in> set ps. poly p x\\<^sub>0 \\<noteq> 0}.\n     sgn (poly p x) = sgn (poly p x\\<^sub>0)\n  \\<forall>p\\<in>{pa \\<in> set (p # q # r # ps).\n                  poly pa x\\<^sub>0 \\<noteq> 0}.\n     sgn (poly p x) = sgn (poly p x\\<^sub>0)\n  poly r x\\<^sub>0 \\<noteq> 0", "have \"poly r x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>{p \\<in> set ps. poly p x\\<^sub>0 \\<noteq> 0}.\n     sgn (poly p x) = sgn (poly p x\\<^sub>0)\n  \\<forall>p\\<in>{pa \\<in> set (p # q # r # ps).\n                  poly pa x\\<^sub>0 \\<noteq> 0}.\n     sgn (poly p x) = sgn (poly p x\\<^sub>0)\n  poly r x\\<^sub>0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly r x \\<noteq> 0", "by (auto simp: sgn_zero_iff)"], ["proof (state)\nthis:\n  poly r x \\<noteq> 0\n\ngoal (2 subgoals):\n 1. poly q x\\<^sub>0 = 0 \\<Longrightarrow>\n    sign_changes' x\\<^sub>0 (p # q # r # ps) x =\n    sign_changes (p # q # r # ps) x\n 2. poly q x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n    sign_changes' x\\<^sub>0 (p # q # r # ps) x =\n    sign_changes (p # q # r # ps) x", "from sign_changes_distrib[OF this, of \"[p,q]\" ps]"], ["proof (chain)\npicking this:\n  sign_changes ([p, q] @ [r] @ ps) x =\n  sign_changes ([p, q] @ [r]) x + sign_changes ([r] @ ps) x", "have \"sign_changes (p#q#r#ps) x =\n                      sign_changes ([p, q, r]) x + sign_changes (r # ps) x\""], ["proof (prove)\nusing this:\n  sign_changes ([p, q] @ [r] @ ps) x =\n  sign_changes ([p, q] @ [r]) x + sign_changes ([r] @ ps) x\n\ngoal (1 subgoal):\n 1. sign_changes (p # q # r # ps) x =\n    sign_changes [p, q, r] x + sign_changes (r # ps) x", "by simp"], ["proof (state)\nthis:\n  sign_changes (p # q # r # ps) x =\n  sign_changes [p, q, r] x + sign_changes (r # ps) x\n\ngoal (2 subgoals):\n 1. poly q x\\<^sub>0 = 0 \\<Longrightarrow>\n    sign_changes' x\\<^sub>0 (p # q # r # ps) x =\n    sign_changes (p # q # r # ps) x\n 2. poly q x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n    sign_changes' x\\<^sub>0 (p # q # r # ps) x =\n    sign_changes (p # q # r # ps) x", "also"], ["proof (state)\nthis:\n  sign_changes (p # q # r # ps) x =\n  sign_changes [p, q, r] x + sign_changes (r # ps) x\n\ngoal (2 subgoals):\n 1. poly q x\\<^sub>0 = 0 \\<Longrightarrow>\n    sign_changes' x\\<^sub>0 (p # q # r # ps) x =\n    sign_changes (p # q # r # ps) x\n 2. poly q x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n    sign_changes' x\\<^sub>0 (p # q # r # ps) x =\n    sign_changes (p # q # r # ps) x", "have \"sign_changes (r#ps) x = sign_changes' x\\<^sub>0 (r#ps) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes (r # ps) x = sign_changes' x\\<^sub>0 (r # ps) x", "using \\<open>poly q x\\<^sub>0 = 0\\<close> nbh \\<open>poly p x\\<^sub>0 \\<noteq> 0\\<close> 3(5)\\<open>poly r x\\<^sub>0 \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  poly q x\\<^sub>0 = 0\n  \\<forall>p\\<in>{p \\<in> set ps. poly p x\\<^sub>0 \\<noteq> 0}.\n     sgn (poly p x) = sgn (poly p x\\<^sub>0)\n  poly p x\\<^sub>0 \\<noteq> 0\n  \\<forall>p\\<in>{pa \\<in> set (p # q # r # ps).\n                  poly pa x\\<^sub>0 \\<noteq> 0}.\n     sgn (poly p x) = sgn (poly p x\\<^sub>0)\n  poly r x\\<^sub>0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sign_changes (r # ps) x = sign_changes' x\\<^sub>0 (r # ps) x", "by (intro IH(1)[symmetric], simp_all)"], ["proof (state)\nthis:\n  sign_changes (r # ps) x = sign_changes' x\\<^sub>0 (r # ps) x\n\ngoal (2 subgoals):\n 1. poly q x\\<^sub>0 = 0 \\<Longrightarrow>\n    sign_changes' x\\<^sub>0 (p # q # r # ps) x =\n    sign_changes (p # q # r # ps) x\n 2. poly q x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n    sign_changes' x\\<^sub>0 (p # q # r # ps) x =\n    sign_changes (p # q # r # ps) x", "finally"], ["proof (chain)\npicking this:\n  sign_changes (p # q # r # ps) x =\n  sign_changes [p, q, r] x + sign_changes' x\\<^sub>0 (r # ps) x", "show ?thesis"], ["proof (prove)\nusing this:\n  sign_changes (p # q # r # ps) x =\n  sign_changes [p, q, r] x + sign_changes' x\\<^sub>0 (r # ps) x\n\ngoal (1 subgoal):\n 1. sign_changes' x\\<^sub>0 (p # q # r # ps) x =\n    sign_changes (p # q # r # ps) x", "unfolding sign_changes'_def"], ["proof (prove)\nusing this:\n  sign_changes (p # q # r # ps) x =\n  sign_changes [p, q, r] x +\n  (\\<Sum>ps'\\<leftarrow>split_sign_changes (r # ps)\n                         x\\<^sub>0. sign_changes ps' x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>ps'\\<leftarrow>split_sign_changes (p # q # r # ps)\n                           x\\<^sub>0. sign_changes ps' x) =\n    sign_changes (p # q # r # ps) x", "using True \\<open>poly p x\\<^sub>0 \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  sign_changes (p # q # r # ps) x =\n  sign_changes [p, q, r] x +\n  (\\<Sum>ps'\\<leftarrow>split_sign_changes (r # ps)\n                         x\\<^sub>0. sign_changes ps' x)\n  poly q x\\<^sub>0 = 0\n  poly p x\\<^sub>0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>ps'\\<leftarrow>split_sign_changes (p # q # r # ps)\n                           x\\<^sub>0. sign_changes ps' x) =\n    sign_changes (p # q # r # ps) x", "by simp"], ["proof (state)\nthis:\n  sign_changes' x\\<^sub>0 (p # q # r # ps) x =\n  sign_changes (p # q # r # ps) x\n\ngoal (1 subgoal):\n 1. poly q x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n    sign_changes' x\\<^sub>0 (p # q # r # ps) x =\n    sign_changes (p # q # r # ps) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. poly q x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n    sign_changes' x\\<^sub>0 (p # q # r # ps) x =\n    sign_changes (p # q # r # ps) x", "case False"], ["proof (state)\nthis:\n  poly q x\\<^sub>0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly q x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n    sign_changes' x\\<^sub>0 (p # q # r # ps) x =\n    sign_changes (p # q # r # ps) x", "with nbh 3(5)"], ["proof (chain)\npicking this:\n  \\<forall>p\\<in>{p \\<in> set ps. poly p x\\<^sub>0 \\<noteq> 0}.\n     sgn (poly p x) = sgn (poly p x\\<^sub>0)\n  \\<forall>p\\<in>{pa \\<in> set (p # q # r # ps).\n                  poly pa x\\<^sub>0 \\<noteq> 0}.\n     sgn (poly p x) = sgn (poly p x\\<^sub>0)\n  poly q x\\<^sub>0 \\<noteq> 0", "have \"poly q x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>{p \\<in> set ps. poly p x\\<^sub>0 \\<noteq> 0}.\n     sgn (poly p x) = sgn (poly p x\\<^sub>0)\n  \\<forall>p\\<in>{pa \\<in> set (p # q # r # ps).\n                  poly pa x\\<^sub>0 \\<noteq> 0}.\n     sgn (poly p x) = sgn (poly p x\\<^sub>0)\n  poly q x\\<^sub>0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly q x \\<noteq> 0", "by (auto simp: sgn_zero_iff)"], ["proof (state)\nthis:\n  poly q x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly q x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n    sign_changes' x\\<^sub>0 (p # q # r # ps) x =\n    sign_changes (p # q # r # ps) x", "from sign_changes_distrib[OF this, of \"[p]\" \"r#ps\"]"], ["proof (chain)\npicking this:\n  sign_changes ([p] @ [q] @ r # ps) x =\n  sign_changes ([p] @ [q]) x + sign_changes ([q] @ r # ps) x", "have \"sign_changes (p#q#r#ps) x =\n                      sign_changes ([p,q]) x + sign_changes (q#r#ps) x\""], ["proof (prove)\nusing this:\n  sign_changes ([p] @ [q] @ r # ps) x =\n  sign_changes ([p] @ [q]) x + sign_changes ([q] @ r # ps) x\n\ngoal (1 subgoal):\n 1. sign_changes (p # q # r # ps) x =\n    sign_changes [p, q] x + sign_changes (q # r # ps) x", "by simp"], ["proof (state)\nthis:\n  sign_changes (p # q # r # ps) x =\n  sign_changes [p, q] x + sign_changes (q # r # ps) x\n\ngoal (1 subgoal):\n 1. poly q x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n    sign_changes' x\\<^sub>0 (p # q # r # ps) x =\n    sign_changes (p # q # r # ps) x", "also"], ["proof (state)\nthis:\n  sign_changes (p # q # r # ps) x =\n  sign_changes [p, q] x + sign_changes (q # r # ps) x\n\ngoal (1 subgoal):\n 1. poly q x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n    sign_changes' x\\<^sub>0 (p # q # r # ps) x =\n    sign_changes (p # q # r # ps) x", "have \"sign_changes (q#r#ps) x = sign_changes' x\\<^sub>0 (q#r#ps) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes (q # r # ps) x = sign_changes' x\\<^sub>0 (q # r # ps) x", "using \\<open>poly q x\\<^sub>0 \\<noteq> 0\\<close> nbh \\<open>poly p x\\<^sub>0 \\<noteq> 0\\<close> 3(5)"], ["proof (prove)\nusing this:\n  poly q x\\<^sub>0 \\<noteq> 0\n  \\<forall>p\\<in>{p \\<in> set ps. poly p x\\<^sub>0 \\<noteq> 0}.\n     sgn (poly p x) = sgn (poly p x\\<^sub>0)\n  poly p x\\<^sub>0 \\<noteq> 0\n  \\<forall>p\\<in>{pa \\<in> set (p # q # r # ps).\n                  poly pa x\\<^sub>0 \\<noteq> 0}.\n     sgn (poly p x) = sgn (poly p x\\<^sub>0)\n\ngoal (1 subgoal):\n 1. sign_changes (q # r # ps) x = sign_changes' x\\<^sub>0 (q # r # ps) x", "by (intro IH(2)[symmetric], simp_all)"], ["proof (state)\nthis:\n  sign_changes (q # r # ps) x = sign_changes' x\\<^sub>0 (q # r # ps) x\n\ngoal (1 subgoal):\n 1. poly q x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n    sign_changes' x\\<^sub>0 (p # q # r # ps) x =\n    sign_changes (p # q # r # ps) x", "finally"], ["proof (chain)\npicking this:\n  sign_changes (p # q # r # ps) x =\n  sign_changes [p, q] x + sign_changes' x\\<^sub>0 (q # r # ps) x", "show ?thesis"], ["proof (prove)\nusing this:\n  sign_changes (p # q # r # ps) x =\n  sign_changes [p, q] x + sign_changes' x\\<^sub>0 (q # r # ps) x\n\ngoal (1 subgoal):\n 1. sign_changes' x\\<^sub>0 (p # q # r # ps) x =\n    sign_changes (p # q # r # ps) x", "unfolding sign_changes'_def"], ["proof (prove)\nusing this:\n  sign_changes (p # q # r # ps) x =\n  sign_changes [p, q] x +\n  (\\<Sum>ps'\\<leftarrow>split_sign_changes (q # r # ps)\n                         x\\<^sub>0. sign_changes ps' x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>ps'\\<leftarrow>split_sign_changes (p # q # r # ps)\n                           x\\<^sub>0. sign_changes ps' x) =\n    sign_changes (p # q # r # ps) x", "using False"], ["proof (prove)\nusing this:\n  sign_changes (p # q # r # ps) x =\n  sign_changes [p, q] x +\n  (\\<Sum>ps'\\<leftarrow>split_sign_changes (q # r # ps)\n                         x\\<^sub>0. sign_changes ps' x)\n  poly q x\\<^sub>0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>ps'\\<leftarrow>split_sign_changes (p # q # r # ps)\n                           x\\<^sub>0. sign_changes ps' x) =\n    sign_changes (p # q # r # ps) x", "by simp"], ["proof (state)\nthis:\n  sign_changes' x\\<^sub>0 (p # q # r # ps) x =\n  sign_changes (p # q # r # ps) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sign_changes' x\\<^sub>0 (p # q # r # ps) x =\n  sign_changes (p # q # r # ps) x\n\ngoal (2 subgoals):\n 1. \\<And>p x.\n       \\<lbrakk>\\<forall>p\\<in>{pa \\<in> set [p]. poly pa x \\<noteq> 0}.\n                   sgn (poly p x) = sgn (poly p x);\n        poly (hd [p]) x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> sign_changes' x [p] x = sign_changes [p] x\n 2. \\<And>p q x.\n       \\<lbrakk>quasi_sturm_seq [p, q];\n        \\<forall>p\\<in>{pa \\<in> set [p, q]. poly pa x \\<noteq> 0}.\n           sgn (poly p x) = sgn (poly p x);\n        poly (hd [p, q]) x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> sign_changes' x [p, q] x = sign_changes [p, q] x", "qed (simp_all add: sign_changes_def sign_changes'_def)"], ["proof (state)\nthis:\n  sign_changes' x\\<^sub>0 ps x = sign_changes ps x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>p\\<in>{p \\<in> set ps. poly p x\\<^sub>0 \\<noteq> 0}.\n     sgn (poly p x) = sgn (poly p x\\<^sub>0) \\<Longrightarrow>\n  sign_changes' x\\<^sub>0 ps x = sign_changes ps x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in quasi_sturm_seq) hd_nonzero_imp_sign_changes_const_aux:\n  assumes \"poly (hd ps) x\\<^sub>0 \\<noteq> 0\" and \"ps' \\<in> set (split_sign_changes ps x\\<^sub>0)\"\n  shows \"eventually (\\<lambda>x. sign_changes ps' x = sign_changes ps' x\\<^sub>0) (at x\\<^sub>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0", "using assms"], ["proof (prove)\nusing this:\n  poly (hd ps) x\\<^sub>0 \\<noteq> 0\n  ps' \\<in> set (split_sign_changes ps x\\<^sub>0)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0", "proof (induction x\\<^sub>0 rule: split_sign_changes_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>p x.\n       \\<lbrakk>poly (hd [p]) x \\<noteq> 0;\n        ps' \\<in> set (split_sign_changes [p] x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                            sign_changes ps' xa = sign_changes ps' x\n 2. \\<And>p q x.\n       \\<lbrakk>quasi_sturm_seq [p, q]; poly (hd [p, q]) x \\<noteq> 0;\n        ps' \\<in> set (split_sign_changes [p, q] x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                            sign_changes ps' xa = sign_changes ps' x\n 3. \\<And>p q r ps x.\n       \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n        \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0;\n         poly (hd (r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        \\<lbrakk>poly q x \\<noteq> 0; poly (hd (q # r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (q # r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        \\<lbrakk>poly p x = 0; poly (hd (q # r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (q # r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        poly (hd (p # q # r # ps)) x \\<noteq> 0;\n        ps' \\<in> set (split_sign_changes (p # q # r # ps) x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                            sign_changes ps' xa = sign_changes ps' x", "case (1 p x)"], ["proof (state)\nthis:\n  poly (hd [p]) x \\<noteq> 0\n  ps' \\<in> set (split_sign_changes [p] x)\n\ngoal (3 subgoals):\n 1. \\<And>p x.\n       \\<lbrakk>poly (hd [p]) x \\<noteq> 0;\n        ps' \\<in> set (split_sign_changes [p] x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                            sign_changes ps' xa = sign_changes ps' x\n 2. \\<And>p q x.\n       \\<lbrakk>quasi_sturm_seq [p, q]; poly (hd [p, q]) x \\<noteq> 0;\n        ps' \\<in> set (split_sign_changes [p, q] x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                            sign_changes ps' xa = sign_changes ps' x\n 3. \\<And>p q r ps x.\n       \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n        \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0;\n         poly (hd (r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        \\<lbrakk>poly q x \\<noteq> 0; poly (hd (q # r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (q # r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        \\<lbrakk>poly p x = 0; poly (hd (q # r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (q # r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        poly (hd (p # q # r # ps)) x \\<noteq> 0;\n        ps' \\<in> set (split_sign_changes (p # q # r # ps) x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                            sign_changes ps' xa = sign_changes ps' x", "thus ?case"], ["proof (prove)\nusing this:\n  poly (hd [p]) x \\<noteq> 0\n  ps' \\<in> set (split_sign_changes [p] x)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F xa in at x. sign_changes ps' xa = sign_changes ps' x", "by (simp add: sign_changes_def)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F xa in at x. sign_changes ps' xa = sign_changes ps' x\n\ngoal (2 subgoals):\n 1. \\<And>p q x.\n       \\<lbrakk>quasi_sturm_seq [p, q]; poly (hd [p, q]) x \\<noteq> 0;\n        ps' \\<in> set (split_sign_changes [p, q] x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                            sign_changes ps' xa = sign_changes ps' x\n 2. \\<And>p q r ps x.\n       \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n        \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0;\n         poly (hd (r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        \\<lbrakk>poly q x \\<noteq> 0; poly (hd (q # r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (q # r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        \\<lbrakk>poly p x = 0; poly (hd (q # r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (q # r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        poly (hd (p # q # r # ps)) x \\<noteq> 0;\n        ps' \\<in> set (split_sign_changes (p # q # r # ps) x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                            sign_changes ps' xa = sign_changes ps' x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p q x.\n       \\<lbrakk>quasi_sturm_seq [p, q]; poly (hd [p, q]) x \\<noteq> 0;\n        ps' \\<in> set (split_sign_changes [p, q] x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                            sign_changes ps' xa = sign_changes ps' x\n 2. \\<And>p q r ps x.\n       \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n        \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0;\n         poly (hd (r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        \\<lbrakk>poly q x \\<noteq> 0; poly (hd (q # r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (q # r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        \\<lbrakk>poly p x = 0; poly (hd (q # r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (q # r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        poly (hd (p # q # r # ps)) x \\<noteq> 0;\n        ps' \\<in> set (split_sign_changes (p # q # r # ps) x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                            sign_changes ps' xa = sign_changes ps' x", "case (2 p q x\\<^sub>0)"], ["proof (state)\nthis:\n  quasi_sturm_seq [p, q]\n  poly (hd [p, q]) x\\<^sub>0 \\<noteq> 0\n  ps' \\<in> set (split_sign_changes [p, q] x\\<^sub>0)\n\ngoal (2 subgoals):\n 1. \\<And>p q x.\n       \\<lbrakk>quasi_sturm_seq [p, q]; poly (hd [p, q]) x \\<noteq> 0;\n        ps' \\<in> set (split_sign_changes [p, q] x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                            sign_changes ps' xa = sign_changes ps' x\n 2. \\<And>p q r ps x.\n       \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n        \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0;\n         poly (hd (r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        \\<lbrakk>poly q x \\<noteq> 0; poly (hd (q # r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (q # r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        \\<lbrakk>poly p x = 0; poly (hd (q # r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (q # r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        poly (hd (p # q # r # ps)) x \\<noteq> 0;\n        ps' \\<in> set (split_sign_changes (p # q # r # ps) x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                            sign_changes ps' xa = sign_changes ps' x", "hence [simp]: \"ps' = [p,q]\""], ["proof (prove)\nusing this:\n  quasi_sturm_seq [p, q]\n  poly (hd [p, q]) x\\<^sub>0 \\<noteq> 0\n  ps' \\<in> set (split_sign_changes [p, q] x\\<^sub>0)\n\ngoal (1 subgoal):\n 1. ps' = [p, q]", "by simp"], ["proof (state)\nthis:\n  ps' = [p, q]\n\ngoal (2 subgoals):\n 1. \\<And>p q x.\n       \\<lbrakk>quasi_sturm_seq [p, q]; poly (hd [p, q]) x \\<noteq> 0;\n        ps' \\<in> set (split_sign_changes [p, q] x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                            sign_changes ps' xa = sign_changes ps' x\n 2. \\<And>p q r ps x.\n       \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n        \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0;\n         poly (hd (r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        \\<lbrakk>poly q x \\<noteq> 0; poly (hd (q # r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (q # r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        \\<lbrakk>poly p x = 0; poly (hd (q # r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (q # r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        poly (hd (p # q # r # ps)) x \\<noteq> 0;\n        ps' \\<in> set (split_sign_changes (p # q # r # ps) x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                            sign_changes ps' xa = sign_changes ps' x", "from 2"], ["proof (chain)\npicking this:\n  quasi_sturm_seq [p, q]\n  poly (hd [p, q]) x\\<^sub>0 \\<noteq> 0\n  ps' \\<in> set (split_sign_changes [p, q] x\\<^sub>0)", "have \"poly p x\\<^sub>0 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  quasi_sturm_seq [p, q]\n  poly (hd [p, q]) x\\<^sub>0 \\<noteq> 0\n  ps' \\<in> set (split_sign_changes [p, q] x\\<^sub>0)\n\ngoal (1 subgoal):\n 1. poly p x\\<^sub>0 \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  poly p x\\<^sub>0 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>p q x.\n       \\<lbrakk>quasi_sturm_seq [p, q]; poly (hd [p, q]) x \\<noteq> 0;\n        ps' \\<in> set (split_sign_changes [p, q] x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                            sign_changes ps' xa = sign_changes ps' x\n 2. \\<And>p q r ps x.\n       \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n        \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0;\n         poly (hd (r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        \\<lbrakk>poly q x \\<noteq> 0; poly (hd (q # r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (q # r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        \\<lbrakk>poly p x = 0; poly (hd (q # r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (q # r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        poly (hd (p # q # r # ps)) x \\<noteq> 0;\n        ps' \\<in> set (split_sign_changes (p # q # r # ps) x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                            sign_changes ps' xa = sign_changes ps' x", "from 2(1)"], ["proof (chain)\npicking this:\n  quasi_sturm_seq [p, q]", "interpret quasi_sturm_seq \"[p,q]\""], ["proof (prove)\nusing this:\n  quasi_sturm_seq [p, q]\n\ngoal (1 subgoal):\n 1. quasi_sturm_seq [p, q]", "."], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p q x.\n       \\<lbrakk>quasi_sturm_seq [p, q]; poly (hd [p, q]) x \\<noteq> 0;\n        ps' \\<in> set (split_sign_changes [p, q] x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                            sign_changes ps' xa = sign_changes ps' x\n 2. \\<And>p q r ps x.\n       \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n        \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0;\n         poly (hd (r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        \\<lbrakk>poly q x \\<noteq> 0; poly (hd (q # r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (q # r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        \\<lbrakk>poly p x = 0; poly (hd (q # r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (q # r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        poly (hd (p # q # r # ps)) x \\<noteq> 0;\n        ps' \\<in> set (split_sign_changes (p # q # r # ps) x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                            sign_changes ps' xa = sign_changes ps' x", "from poly_neighbourhood_same_sign[OF \\<open>poly p x\\<^sub>0 \\<noteq> 0\\<close>]"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     sgn (poly p x) = sgn (poly p x\\<^sub>0)", "have \"eventually (\\<lambda>x. sgn (poly p x) = sgn (poly p x\\<^sub>0)) (at x\\<^sub>0)\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     sgn (poly p x) = sgn (poly p x\\<^sub>0)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sgn (poly p x) = sgn (poly p x\\<^sub>0)", "."], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     sgn (poly p x) = sgn (poly p x\\<^sub>0)\n\ngoal (2 subgoals):\n 1. \\<And>p q x.\n       \\<lbrakk>quasi_sturm_seq [p, q]; poly (hd [p, q]) x \\<noteq> 0;\n        ps' \\<in> set (split_sign_changes [p, q] x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                            sign_changes ps' xa = sign_changes ps' x\n 2. \\<And>p q r ps x.\n       \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n        \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0;\n         poly (hd (r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        \\<lbrakk>poly q x \\<noteq> 0; poly (hd (q # r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (q # r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        \\<lbrakk>poly p x = 0; poly (hd (q # r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (q # r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        poly (hd (p # q # r # ps)) x \\<noteq> 0;\n        ps' \\<in> set (split_sign_changes (p # q # r # ps) x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                            sign_changes ps' xa = sign_changes ps' x", "moreover"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     sgn (poly p x) = sgn (poly p x\\<^sub>0)\n\ngoal (2 subgoals):\n 1. \\<And>p q x.\n       \\<lbrakk>quasi_sturm_seq [p, q]; poly (hd [p, q]) x \\<noteq> 0;\n        ps' \\<in> set (split_sign_changes [p, q] x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                            sign_changes ps' xa = sign_changes ps' x\n 2. \\<And>p q r ps x.\n       \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n        \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0;\n         poly (hd (r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        \\<lbrakk>poly q x \\<noteq> 0; poly (hd (q # r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (q # r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        \\<lbrakk>poly p x = 0; poly (hd (q # r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (q # r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        poly (hd (p # q # r # ps)) x \\<noteq> 0;\n        ps' \\<in> set (split_sign_changes (p # q # r # ps) x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                            sign_changes ps' xa = sign_changes ps' x", "from last_ps_sgn_const"], ["proof (chain)\npicking this:\n  sgn (poly (last [p, q]) ?x) = sgn (poly (last [p, q]) ?y)", "have sgn_q: \"\\<And>x. sgn (poly q x) = sgn (poly q x\\<^sub>0)\""], ["proof (prove)\nusing this:\n  sgn (poly (last [p, q]) ?x) = sgn (poly (last [p, q]) ?y)\n\ngoal (1 subgoal):\n 1. \\<And>x. sgn (poly q x) = sgn (poly q x\\<^sub>0)", "by simp"], ["proof (state)\nthis:\n  sgn (poly q ?x) = sgn (poly q x\\<^sub>0)\n\ngoal (2 subgoals):\n 1. \\<And>p q x.\n       \\<lbrakk>quasi_sturm_seq [p, q]; poly (hd [p, q]) x \\<noteq> 0;\n        ps' \\<in> set (split_sign_changes [p, q] x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                            sign_changes ps' xa = sign_changes ps' x\n 2. \\<And>p q r ps x.\n       \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n        \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0;\n         poly (hd (r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        \\<lbrakk>poly q x \\<noteq> 0; poly (hd (q # r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (q # r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        \\<lbrakk>poly p x = 0; poly (hd (q # r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (q # r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        poly (hd (p # q # r # ps)) x \\<noteq> 0;\n        ps' \\<in> set (split_sign_changes (p # q # r # ps) x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                            sign_changes ps' xa = sign_changes ps' x", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     sgn (poly p x) = sgn (poly p x\\<^sub>0)\n  sgn (poly q ?x) = sgn (poly q x\\<^sub>0)", "have A:  \"eventually (\\<lambda>x. \\<forall>p\\<in>set[p,q]. sgn (poly p x) =\n                           sgn (poly p x\\<^sub>0)) (at x\\<^sub>0)\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     sgn (poly p x) = sgn (poly p x\\<^sub>0)\n  sgn (poly q ?x) = sgn (poly q x\\<^sub>0)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       \\<forall>p\\<in>set [p, q]. sgn (poly p x) = sgn (poly p x\\<^sub>0)", "by simp"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     \\<forall>p\\<in>set [p, q]. sgn (poly p x) = sgn (poly p x\\<^sub>0)\n\ngoal (2 subgoals):\n 1. \\<And>p q x.\n       \\<lbrakk>quasi_sturm_seq [p, q]; poly (hd [p, q]) x \\<noteq> 0;\n        ps' \\<in> set (split_sign_changes [p, q] x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                            sign_changes ps' xa = sign_changes ps' x\n 2. \\<And>p q r ps x.\n       \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n        \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0;\n         poly (hd (r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        \\<lbrakk>poly q x \\<noteq> 0; poly (hd (q # r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (q # r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        \\<lbrakk>poly p x = 0; poly (hd (q # r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (q # r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        poly (hd (p # q # r # ps)) x \\<noteq> 0;\n        ps' \\<in> set (split_sign_changes (p # q # r # ps) x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                            sign_changes ps' xa = sign_changes ps' x", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     \\<forall>p\\<in>set [p, q]. sgn (poly p x) = sgn (poly p x\\<^sub>0)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0", "by (force intro: eventually_mono[OF A]\n                                sign_changes_cong')"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     sign_changes ps' x = sign_changes ps' x\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>p q r ps x.\n       \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n        \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0;\n         poly (hd (r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        \\<lbrakk>poly q x \\<noteq> 0; poly (hd (q # r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (q # r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        \\<lbrakk>poly p x = 0; poly (hd (q # r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (q # r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        poly (hd (p # q # r # ps)) x \\<noteq> 0;\n        ps' \\<in> set (split_sign_changes (p # q # r # ps) x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                            sign_changes ps' xa = sign_changes ps' x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q r ps x.\n       \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n        \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0;\n         poly (hd (r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        \\<lbrakk>poly q x \\<noteq> 0; poly (hd (q # r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (q # r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        \\<lbrakk>poly p x = 0; poly (hd (q # r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (q # r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        poly (hd (p # q # r # ps)) x \\<noteq> 0;\n        ps' \\<in> set (split_sign_changes (p # q # r # ps) x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                            sign_changes ps' xa = sign_changes ps' x", "case (3 p q r ps'' x\\<^sub>0)"], ["proof (state)\nthis:\n  quasi_sturm_seq (p # q # r # ps'')\n  \\<lbrakk>poly p x\\<^sub>0 \\<noteq> 0; poly q x\\<^sub>0 = 0;\n   poly (hd (r # ps'')) x\\<^sub>0 \\<noteq> 0;\n   ps' \\<in> set (split_sign_changes (r # ps'') x\\<^sub>0)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>\\<^sub>F x in at x\\<^sub>0.\n                       sign_changes ps' x = sign_changes ps' x\\<^sub>0\n  \\<lbrakk>poly q x\\<^sub>0 \\<noteq> 0;\n   poly (hd (q # r # ps'')) x\\<^sub>0 \\<noteq> 0;\n   ps' \\<in> set (split_sign_changes (q # r # ps'') x\\<^sub>0)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>\\<^sub>F x in at x\\<^sub>0.\n                       sign_changes ps' x = sign_changes ps' x\\<^sub>0\n  \\<lbrakk>poly p x\\<^sub>0 = 0;\n   poly (hd (q # r # ps'')) x\\<^sub>0 \\<noteq> 0;\n   ps' \\<in> set (split_sign_changes (q # r # ps'') x\\<^sub>0)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>\\<^sub>F x in at x\\<^sub>0.\n                       sign_changes ps' x = sign_changes ps' x\\<^sub>0\n  poly (hd (p # q # r # ps'')) x\\<^sub>0 \\<noteq> 0\n  ps' \\<in> set (split_sign_changes (p # q # r # ps'') x\\<^sub>0)\n\ngoal (1 subgoal):\n 1. \\<And>p q r ps x.\n       \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n        \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0;\n         poly (hd (r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        \\<lbrakk>poly q x \\<noteq> 0; poly (hd (q # r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (q # r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        \\<lbrakk>poly p x = 0; poly (hd (q # r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (q # r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        poly (hd (p # q # r # ps)) x \\<noteq> 0;\n        ps' \\<in> set (split_sign_changes (p # q # r # ps) x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                            sign_changes ps' xa = sign_changes ps' x", "hence p_not_0: \"poly p x\\<^sub>0 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  quasi_sturm_seq (p # q # r # ps'')\n  \\<lbrakk>poly p x\\<^sub>0 \\<noteq> 0; poly q x\\<^sub>0 = 0;\n   poly (hd (r # ps'')) x\\<^sub>0 \\<noteq> 0;\n   ps' \\<in> set (split_sign_changes (r # ps'') x\\<^sub>0)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>\\<^sub>F x in at x\\<^sub>0.\n                       sign_changes ps' x = sign_changes ps' x\\<^sub>0\n  \\<lbrakk>poly q x\\<^sub>0 \\<noteq> 0;\n   poly (hd (q # r # ps'')) x\\<^sub>0 \\<noteq> 0;\n   ps' \\<in> set (split_sign_changes (q # r # ps'') x\\<^sub>0)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>\\<^sub>F x in at x\\<^sub>0.\n                       sign_changes ps' x = sign_changes ps' x\\<^sub>0\n  \\<lbrakk>poly p x\\<^sub>0 = 0;\n   poly (hd (q # r # ps'')) x\\<^sub>0 \\<noteq> 0;\n   ps' \\<in> set (split_sign_changes (q # r # ps'') x\\<^sub>0)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>\\<^sub>F x in at x\\<^sub>0.\n                       sign_changes ps' x = sign_changes ps' x\\<^sub>0\n  poly (hd (p # q # r # ps'')) x\\<^sub>0 \\<noteq> 0\n  ps' \\<in> set (split_sign_changes (p # q # r # ps'') x\\<^sub>0)\n\ngoal (1 subgoal):\n 1. poly p x\\<^sub>0 \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  poly p x\\<^sub>0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>p q r ps x.\n       \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n        \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0;\n         poly (hd (r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        \\<lbrakk>poly q x \\<noteq> 0; poly (hd (q # r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (q # r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        \\<lbrakk>poly p x = 0; poly (hd (q # r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (q # r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        poly (hd (p # q # r # ps)) x \\<noteq> 0;\n        ps' \\<in> set (split_sign_changes (p # q # r # ps) x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                            sign_changes ps' xa = sign_changes ps' x", "note sturm = 3(1)"], ["proof (state)\nthis:\n  quasi_sturm_seq (p # q # r # ps'')\n\ngoal (1 subgoal):\n 1. \\<And>p q r ps x.\n       \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n        \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0;\n         poly (hd (r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        \\<lbrakk>poly q x \\<noteq> 0; poly (hd (q # r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (q # r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        \\<lbrakk>poly p x = 0; poly (hd (q # r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (q # r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        poly (hd (p # q # r # ps)) x \\<noteq> 0;\n        ps' \\<in> set (split_sign_changes (p # q # r # ps) x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                            sign_changes ps' xa = sign_changes ps' x", "note IH = 3(2,3)"], ["proof (state)\nthis:\n  \\<lbrakk>poly p x\\<^sub>0 \\<noteq> 0; poly q x\\<^sub>0 = 0;\n   poly (hd (r # ps'')) x\\<^sub>0 \\<noteq> 0;\n   ps' \\<in> set (split_sign_changes (r # ps'') x\\<^sub>0)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>\\<^sub>F x in at x\\<^sub>0.\n                       sign_changes ps' x = sign_changes ps' x\\<^sub>0\n  \\<lbrakk>poly q x\\<^sub>0 \\<noteq> 0;\n   poly (hd (q # r # ps'')) x\\<^sub>0 \\<noteq> 0;\n   ps' \\<in> set (split_sign_changes (q # r # ps'') x\\<^sub>0)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>\\<^sub>F x in at x\\<^sub>0.\n                       sign_changes ps' x = sign_changes ps' x\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>p q r ps x.\n       \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n        \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0;\n         poly (hd (r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        \\<lbrakk>poly q x \\<noteq> 0; poly (hd (q # r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (q # r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        \\<lbrakk>poly p x = 0; poly (hd (q # r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (q # r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        poly (hd (p # q # r # ps)) x \\<noteq> 0;\n        ps' \\<in> set (split_sign_changes (p # q # r # ps) x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                            sign_changes ps' xa = sign_changes ps' x", "note ps''_props = 3(6)"], ["proof (state)\nthis:\n  ps' \\<in> set (split_sign_changes (p # q # r # ps'') x\\<^sub>0)\n\ngoal (1 subgoal):\n 1. \\<And>p q r ps x.\n       \\<lbrakk>quasi_sturm_seq (p # q # r # ps);\n        \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0;\n         poly (hd (r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        \\<lbrakk>poly q x \\<noteq> 0; poly (hd (q # r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (q # r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        \\<lbrakk>poly p x = 0; poly (hd (q # r # ps)) x \\<noteq> 0;\n         ps' \\<in> set (split_sign_changes (q # r # ps) x)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                             sign_changes ps' xa = sign_changes ps' x;\n        poly (hd (p # q # r # ps)) x \\<noteq> 0;\n        ps' \\<in> set (split_sign_changes (p # q # r # ps) x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F xa in at x.\n                            sign_changes ps' xa = sign_changes ps' x", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0", "proof (cases \"poly q x\\<^sub>0 = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. poly q x\\<^sub>0 = 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0\n 2. poly q x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0", "case True"], ["proof (state)\nthis:\n  poly q x\\<^sub>0 = 0\n\ngoal (2 subgoals):\n 1. poly q x\\<^sub>0 = 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0\n 2. poly q x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0", "note q_0 = this"], ["proof (state)\nthis:\n  poly q x\\<^sub>0 = 0\n\ngoal (2 subgoals):\n 1. poly q x\\<^sub>0 = 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0\n 2. poly q x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0", "from sturm"], ["proof (chain)\npicking this:\n  quasi_sturm_seq (p # q # r # ps'')", "interpret quasi_sturm_seq \"p#q#r#ps''\""], ["proof (prove)\nusing this:\n  quasi_sturm_seq (p # q # r # ps'')\n\ngoal (1 subgoal):\n 1. quasi_sturm_seq (p # q # r # ps'')", "."], ["proof (state)\ngoal (2 subgoals):\n 1. poly q x\\<^sub>0 = 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0\n 2. poly q x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0", "from signs[of 0] and q_0"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < length (p # q # r # ps'') - 2;\n   poly ((p # q # r # ps'') ! (0 + 1)) ?x = 0\\<rbrakk>\n  \\<Longrightarrow> poly ((p # q # r # ps'') ! (0 + 2)) ?x *\n                    poly ((p # q # r # ps'') ! 0) ?x\n                    < 0\n  poly q x\\<^sub>0 = 0", "have signs': \"poly r x\\<^sub>0 * poly p x\\<^sub>0 < 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < length (p # q # r # ps'') - 2;\n   poly ((p # q # r # ps'') ! (0 + 1)) ?x = 0\\<rbrakk>\n  \\<Longrightarrow> poly ((p # q # r # ps'') ! (0 + 2)) ?x *\n                    poly ((p # q # r # ps'') ! 0) ?x\n                    < 0\n  poly q x\\<^sub>0 = 0\n\ngoal (1 subgoal):\n 1. poly r x\\<^sub>0 * poly p x\\<^sub>0 < 0", "by simp"], ["proof (state)\nthis:\n  poly r x\\<^sub>0 * poly p x\\<^sub>0 < 0\n\ngoal (2 subgoals):\n 1. poly q x\\<^sub>0 = 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0\n 2. poly q x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0", "with p_not_0"], ["proof (chain)\npicking this:\n  poly p x\\<^sub>0 \\<noteq> 0\n  poly r x\\<^sub>0 * poly p x\\<^sub>0 < 0", "have r_not_0: \"poly r x\\<^sub>0 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  poly p x\\<^sub>0 \\<noteq> 0\n  poly r x\\<^sub>0 * poly p x\\<^sub>0 < 0\n\ngoal (1 subgoal):\n 1. poly r x\\<^sub>0 \\<noteq> 0", "by force"], ["proof (state)\nthis:\n  poly r x\\<^sub>0 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. poly q x\\<^sub>0 = 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0\n 2. poly q x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0", "proof (cases \"ps' \\<in> set (split_sign_changes (r # ps'') x\\<^sub>0)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ps'\n    \\<in> set (split_sign_changes (r # ps'') x\\<^sub>0) \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0\n 2. ps'\n    \\<notin> set (split_sign_changes (r # ps'') x\\<^sub>0) \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0", "case True"], ["proof (state)\nthis:\n  ps' \\<in> set (split_sign_changes (r # ps'') x\\<^sub>0)\n\ngoal (2 subgoals):\n 1. ps'\n    \\<in> set (split_sign_changes (r # ps'') x\\<^sub>0) \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0\n 2. ps'\n    \\<notin> set (split_sign_changes (r # ps'') x\\<^sub>0) \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0", "by (rule IH(1), fact, fact, simp add: r_not_0, fact)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     sign_changes ps' x = sign_changes ps' x\\<^sub>0\n\ngoal (1 subgoal):\n 1. ps'\n    \\<notin> set (split_sign_changes (r # ps'') x\\<^sub>0) \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ps'\n    \\<notin> set (split_sign_changes (r # ps'') x\\<^sub>0) \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0", "case False"], ["proof (state)\nthis:\n  ps' \\<notin> set (split_sign_changes (r # ps'') x\\<^sub>0)\n\ngoal (1 subgoal):\n 1. ps'\n    \\<notin> set (split_sign_changes (r # ps'') x\\<^sub>0) \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0", "with ps''_props p_not_0 q_0"], ["proof (chain)\npicking this:\n  ps' \\<in> set (split_sign_changes (p # q # r # ps'') x\\<^sub>0)\n  poly p x\\<^sub>0 \\<noteq> 0\n  poly q x\\<^sub>0 = 0\n  ps' \\<notin> set (split_sign_changes (r # ps'') x\\<^sub>0)", "have ps'_props: \"ps' = [p,q,r]\""], ["proof (prove)\nusing this:\n  ps' \\<in> set (split_sign_changes (p # q # r # ps'') x\\<^sub>0)\n  poly p x\\<^sub>0 \\<noteq> 0\n  poly q x\\<^sub>0 = 0\n  ps' \\<notin> set (split_sign_changes (r # ps'') x\\<^sub>0)\n\ngoal (1 subgoal):\n 1. ps' = [p, q, r]", "by simp"], ["proof (state)\nthis:\n  ps' = [p, q, r]\n\ngoal (1 subgoal):\n 1. ps'\n    \\<notin> set (split_sign_changes (r # ps'') x\\<^sub>0) \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0", "from signs[of 0] and q_0"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < length (p # q # r # ps'') - 2;\n   poly ((p # q # r # ps'') ! (0 + 1)) ?x = 0\\<rbrakk>\n  \\<Longrightarrow> poly ((p # q # r # ps'') ! (0 + 2)) ?x *\n                    poly ((p # q # r # ps'') ! 0) ?x\n                    < 0\n  poly q x\\<^sub>0 = 0", "have sgn_r: \"poly r x\\<^sub>0 * poly p x\\<^sub>0 < 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < length (p # q # r # ps'') - 2;\n   poly ((p # q # r # ps'') ! (0 + 1)) ?x = 0\\<rbrakk>\n  \\<Longrightarrow> poly ((p # q # r # ps'') ! (0 + 2)) ?x *\n                    poly ((p # q # r # ps'') ! 0) ?x\n                    < 0\n  poly q x\\<^sub>0 = 0\n\ngoal (1 subgoal):\n 1. poly r x\\<^sub>0 * poly p x\\<^sub>0 < 0", "by simp"], ["proof (state)\nthis:\n  poly r x\\<^sub>0 * poly p x\\<^sub>0 < 0\n\ngoal (1 subgoal):\n 1. ps'\n    \\<notin> set (split_sign_changes (r # ps'') x\\<^sub>0) \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0", "from p_not_0 sgn_r"], ["proof (chain)\npicking this:\n  poly p x\\<^sub>0 \\<noteq> 0\n  poly r x\\<^sub>0 * poly p x\\<^sub>0 < 0", "have A: \"eventually (\\<lambda>x. sgn (poly p x) = sgn (poly p x\\<^sub>0) \\<and>\n                                     sgn (poly r x) = sgn (poly r x\\<^sub>0)) (at x\\<^sub>0)\""], ["proof (prove)\nusing this:\n  poly p x\\<^sub>0 \\<noteq> 0\n  poly r x\\<^sub>0 * poly p x\\<^sub>0 < 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sgn (poly p x) = sgn (poly p x\\<^sub>0) \\<and>\n       sgn (poly r x) = sgn (poly r x\\<^sub>0)", "by (intro eventually_conj poly_neighbourhood_same_sign,\n                      simp_all add: r_not_0)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     sgn (poly p x) = sgn (poly p x\\<^sub>0) \\<and>\n     sgn (poly r x) = sgn (poly r x\\<^sub>0)\n\ngoal (1 subgoal):\n 1. ps'\n    \\<notin> set (split_sign_changes (r # ps'') x\\<^sub>0) \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0", "proof (rule eventually_mono[OF A], clarify,\n                   subst ps'_props, subst sign_changes_sturm_triple)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sgn (poly p x) = sgn (poly p x\\<^sub>0);\n        sgn (poly r x) = sgn (poly r x\\<^sub>0)\\<rbrakk>\n       \\<Longrightarrow> poly p x \\<noteq> 0\n 2. \\<And>x.\n       \\<lbrakk>sgn (poly p x) = sgn (poly p x\\<^sub>0);\n        sgn (poly r x) = sgn (poly r x\\<^sub>0)\\<rbrakk>\n       \\<Longrightarrow> sgn (poly r x) = - sgn (poly p x)\n 3. \\<And>x.\n       \\<lbrakk>sgn (poly p x) = sgn (poly p x\\<^sub>0);\n        sgn (poly r x) = sgn (poly r x\\<^sub>0)\\<rbrakk>\n       \\<Longrightarrow> 1 = sign_changes ps' x\\<^sub>0", "fix x"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sgn (poly p x) = sgn (poly p x\\<^sub>0);\n        sgn (poly r x) = sgn (poly r x\\<^sub>0)\\<rbrakk>\n       \\<Longrightarrow> poly p x \\<noteq> 0\n 2. \\<And>x.\n       \\<lbrakk>sgn (poly p x) = sgn (poly p x\\<^sub>0);\n        sgn (poly r x) = sgn (poly r x\\<^sub>0)\\<rbrakk>\n       \\<Longrightarrow> sgn (poly r x) = - sgn (poly p x)\n 3. \\<And>x.\n       \\<lbrakk>sgn (poly p x) = sgn (poly p x\\<^sub>0);\n        sgn (poly r x) = sgn (poly r x\\<^sub>0)\\<rbrakk>\n       \\<Longrightarrow> 1 = sign_changes ps' x\\<^sub>0", "assume A: \"sgn (poly p x) = sgn (poly p x\\<^sub>0)\"\n                       and B: \"sgn (poly r x) = sgn (poly r x\\<^sub>0)\""], ["proof (state)\nthis:\n  sgn (poly p x) = sgn (poly p x\\<^sub>0)\n  sgn (poly r x) = sgn (poly r x\\<^sub>0)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sgn (poly p x) = sgn (poly p x\\<^sub>0);\n        sgn (poly r x) = sgn (poly r x\\<^sub>0)\\<rbrakk>\n       \\<Longrightarrow> poly p x \\<noteq> 0\n 2. \\<And>x.\n       \\<lbrakk>sgn (poly p x) = sgn (poly p x\\<^sub>0);\n        sgn (poly r x) = sgn (poly r x\\<^sub>0)\\<rbrakk>\n       \\<Longrightarrow> sgn (poly r x) = - sgn (poly p x)\n 3. \\<And>x.\n       \\<lbrakk>sgn (poly p x) = sgn (poly p x\\<^sub>0);\n        sgn (poly r x) = sgn (poly r x\\<^sub>0)\\<rbrakk>\n       \\<Longrightarrow> 1 = sign_changes ps' x\\<^sub>0", "have prod_neg: \"\\<And>a (b::real). \\<lbrakk>a>0; b>0; a*b<0\\<rbrakk> \\<Longrightarrow> False\"\n                             \"\\<And>a (b::real). \\<lbrakk>a<0; b<0; a*b<0\\<rbrakk> \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>0 < a; 0 < b; a * b < 0\\<rbrakk>\n        \\<Longrightarrow> False) &&&\n    (\\<And>a b.\n        \\<lbrakk>a < 0; b < 0; a * b < 0\\<rbrakk> \\<Longrightarrow> False)", "by (drule mult_pos_pos, simp, simp,\n                      drule mult_neg_neg, simp, simp)"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?a; 0 < ?b; ?a * ?b < 0\\<rbrakk> \\<Longrightarrow> False\n  \\<lbrakk>?a < 0; ?b < 0; ?a * ?b < 0\\<rbrakk> \\<Longrightarrow> False\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sgn (poly p x) = sgn (poly p x\\<^sub>0);\n        sgn (poly r x) = sgn (poly r x\\<^sub>0)\\<rbrakk>\n       \\<Longrightarrow> poly p x \\<noteq> 0\n 2. \\<And>x.\n       \\<lbrakk>sgn (poly p x) = sgn (poly p x\\<^sub>0);\n        sgn (poly r x) = sgn (poly r x\\<^sub>0)\\<rbrakk>\n       \\<Longrightarrow> sgn (poly r x) = - sgn (poly p x)\n 3. \\<And>x.\n       \\<lbrakk>sgn (poly p x) = sgn (poly p x\\<^sub>0);\n        sgn (poly r x) = sgn (poly r x\\<^sub>0)\\<rbrakk>\n       \\<Longrightarrow> 1 = sign_changes ps' x\\<^sub>0", "from A and \\<open>poly p x\\<^sub>0 \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  sgn (poly p x) = sgn (poly p x\\<^sub>0)\n  poly p x\\<^sub>0 \\<noteq> 0", "show \"poly p x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  sgn (poly p x) = sgn (poly p x\\<^sub>0)\n  poly p x\\<^sub>0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly p x \\<noteq> 0", "by (force simp: sgn_zero_iff)"], ["proof (state)\nthis:\n  poly p x \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sgn (poly p x) = sgn (poly p x\\<^sub>0);\n        sgn (poly r x) = sgn (poly r x\\<^sub>0)\\<rbrakk>\n       \\<Longrightarrow> sgn (poly r x) = - sgn (poly p x)\n 2. \\<And>x.\n       \\<lbrakk>sgn (poly p x) = sgn (poly p x\\<^sub>0);\n        sgn (poly r x) = sgn (poly r x\\<^sub>0)\\<rbrakk>\n       \\<Longrightarrow> 1 = sign_changes ps' x\\<^sub>0", "with sgn_r p_not_0 r_not_0 A B"], ["proof (chain)\npicking this:\n  poly r x\\<^sub>0 * poly p x\\<^sub>0 < 0\n  poly p x\\<^sub>0 \\<noteq> 0\n  poly r x\\<^sub>0 \\<noteq> 0\n  sgn (poly p x) = sgn (poly p x\\<^sub>0)\n  sgn (poly r x) = sgn (poly r x\\<^sub>0)\n  poly p x \\<noteq> 0", "have \"poly r x * poly p x < 0\" \"poly r x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  poly r x\\<^sub>0 * poly p x\\<^sub>0 < 0\n  poly p x\\<^sub>0 \\<noteq> 0\n  poly r x\\<^sub>0 \\<noteq> 0\n  sgn (poly p x) = sgn (poly p x\\<^sub>0)\n  sgn (poly r x) = sgn (poly r x\\<^sub>0)\n  poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly r x * poly p x < 0 &&& poly r x \\<noteq> 0", "by (metis sgn_less sgn_mult, metis sgn_0_0)"], ["proof (state)\nthis:\n  poly r x * poly p x < 0\n  poly r x \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sgn (poly p x) = sgn (poly p x\\<^sub>0);\n        sgn (poly r x) = sgn (poly r x\\<^sub>0)\\<rbrakk>\n       \\<Longrightarrow> sgn (poly r x) = - sgn (poly p x)\n 2. \\<And>x.\n       \\<lbrakk>sgn (poly p x) = sgn (poly p x\\<^sub>0);\n        sgn (poly r x) = sgn (poly r x\\<^sub>0)\\<rbrakk>\n       \\<Longrightarrow> 1 = sign_changes ps' x\\<^sub>0", "with sgn_r"], ["proof (chain)\npicking this:\n  poly r x\\<^sub>0 * poly p x\\<^sub>0 < 0\n  poly r x * poly p x < 0\n  poly r x \\<noteq> 0", "show sgn_r': \"sgn (poly r x) = - sgn (poly p x)\""], ["proof (prove)\nusing this:\n  poly r x\\<^sub>0 * poly p x\\<^sub>0 < 0\n  poly r x * poly p x < 0\n  poly r x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sgn (poly r x) = - sgn (poly p x)", "apply (simp add: sgn_real_def not_le not_less\n                             split: if_split_asm, intro conjI impI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>poly r x\\<^sub>0 * poly p x\\<^sub>0 < 0;\n     poly r x * poly p x < 0; poly r x \\<noteq> 0;\n     poly r x\\<^sub>0 * poly p x\\<^sub>0 < 0; poly r x * poly p x < 0;\n     poly r x \\<noteq> 0; 0 < poly p x\\<rbrakk>\n    \\<Longrightarrow> poly r x \\<le> 0\n 2. \\<lbrakk>poly r x\\<^sub>0 * poly p x\\<^sub>0 < 0;\n     poly r x * poly p x < 0; poly r x \\<noteq> 0;\n     poly r x\\<^sub>0 * poly p x\\<^sub>0 < 0; poly r x * poly p x < 0;\n     poly r x \\<noteq> 0; poly p x \\<le> 0; poly p x = 0\\<rbrakk>\n    \\<Longrightarrow> poly r x \\<le> 0\n 3. \\<lbrakk>poly r x\\<^sub>0 * poly p x\\<^sub>0 < 0;\n     poly r x * poly p x < 0; poly r x \\<noteq> 0;\n     poly r x\\<^sub>0 * poly p x\\<^sub>0 < 0; poly r x * poly p x < 0;\n     poly r x \\<noteq> 0; poly p x \\<le> 0; poly p x = 0\\<rbrakk>\n    \\<Longrightarrow> 0 < poly r x\n 4. \\<lbrakk>poly r x\\<^sub>0 * poly p x\\<^sub>0 < 0;\n     poly r x * poly p x < 0; poly r x \\<noteq> 0;\n     poly r x\\<^sub>0 * poly p x\\<^sub>0 < 0; poly r x * poly p x < 0;\n     poly r x \\<noteq> 0; poly p x \\<le> 0; poly p x \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> 0 < poly r x", "using prod_neg[of \"poly r x\" \"poly p x\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < poly r x; 0 < poly p x; poly r x * poly p x < 0\\<rbrakk>\n  \\<Longrightarrow> False\n  \\<lbrakk>poly r x < 0; poly p x < 0; poly r x * poly p x < 0\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (4 subgoals):\n 1. \\<lbrakk>poly r x\\<^sub>0 * poly p x\\<^sub>0 < 0;\n     poly r x * poly p x < 0; poly r x \\<noteq> 0;\n     poly r x\\<^sub>0 * poly p x\\<^sub>0 < 0; poly r x * poly p x < 0;\n     poly r x \\<noteq> 0; 0 < poly p x\\<rbrakk>\n    \\<Longrightarrow> poly r x \\<le> 0\n 2. \\<lbrakk>poly r x\\<^sub>0 * poly p x\\<^sub>0 < 0;\n     poly r x * poly p x < 0; poly r x \\<noteq> 0;\n     poly r x\\<^sub>0 * poly p x\\<^sub>0 < 0; poly r x * poly p x < 0;\n     poly r x \\<noteq> 0; poly p x \\<le> 0; poly p x = 0\\<rbrakk>\n    \\<Longrightarrow> poly r x \\<le> 0\n 3. \\<lbrakk>poly r x\\<^sub>0 * poly p x\\<^sub>0 < 0;\n     poly r x * poly p x < 0; poly r x \\<noteq> 0;\n     poly r x\\<^sub>0 * poly p x\\<^sub>0 < 0; poly r x * poly p x < 0;\n     poly r x \\<noteq> 0; poly p x \\<le> 0; poly p x = 0\\<rbrakk>\n    \\<Longrightarrow> 0 < poly r x\n 4. \\<lbrakk>poly r x\\<^sub>0 * poly p x\\<^sub>0 < 0;\n     poly r x * poly p x < 0; poly r x \\<noteq> 0;\n     poly r x\\<^sub>0 * poly p x\\<^sub>0 < 0; poly r x * poly p x < 0;\n     poly r x \\<noteq> 0; poly p x \\<le> 0; poly p x \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> 0 < poly r x", "apply force+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sgn (poly r x) = - sgn (poly p x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>sgn (poly p x) = sgn (poly p x\\<^sub>0);\n        sgn (poly r x) = sgn (poly r x\\<^sub>0)\\<rbrakk>\n       \\<Longrightarrow> 1 = sign_changes ps' x\\<^sub>0", "show \"1 = sign_changes ps' x\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 = sign_changes ps' x\\<^sub>0", "by (subst ps'_props, subst sign_changes_sturm_triple,\n                      fact, metis A B sgn_r', simp)"], ["proof (state)\nthis:\n  1 = sign_changes ps' x\\<^sub>0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     sign_changes ps' x = sign_changes ps' x\\<^sub>0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     sign_changes ps' x = sign_changes ps' x\\<^sub>0\n\ngoal (1 subgoal):\n 1. poly q x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. poly q x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0", "case False"], ["proof (state)\nthis:\n  poly q x\\<^sub>0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly q x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0", "note q_not_0 = this"], ["proof (state)\nthis:\n  poly q x\\<^sub>0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly q x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0", "proof (cases \"ps' \\<in> set (split_sign_changes (q # r # ps'') x\\<^sub>0)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ps'\n    \\<in> set (split_sign_changes (q # r # ps'')\n                x\\<^sub>0) \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0\n 2. ps'\n    \\<notin> set (split_sign_changes (q # r # ps'')\n                   x\\<^sub>0) \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0", "case True"], ["proof (state)\nthis:\n  ps' \\<in> set (split_sign_changes (q # r # ps'') x\\<^sub>0)\n\ngoal (2 subgoals):\n 1. ps'\n    \\<in> set (split_sign_changes (q # r # ps'')\n                x\\<^sub>0) \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0\n 2. ps'\n    \\<notin> set (split_sign_changes (q # r # ps'')\n                   x\\<^sub>0) \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0", "by (rule IH(2), fact, simp add: q_not_0, fact)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     sign_changes ps' x = sign_changes ps' x\\<^sub>0\n\ngoal (1 subgoal):\n 1. ps'\n    \\<notin> set (split_sign_changes (q # r # ps'')\n                   x\\<^sub>0) \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ps'\n    \\<notin> set (split_sign_changes (q # r # ps'')\n                   x\\<^sub>0) \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0", "case False"], ["proof (state)\nthis:\n  ps' \\<notin> set (split_sign_changes (q # r # ps'') x\\<^sub>0)\n\ngoal (1 subgoal):\n 1. ps'\n    \\<notin> set (split_sign_changes (q # r # ps'')\n                   x\\<^sub>0) \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0", "with ps''_props and q_not_0"], ["proof (chain)\npicking this:\n  ps' \\<in> set (split_sign_changes (p # q # r # ps'') x\\<^sub>0)\n  poly q x\\<^sub>0 \\<noteq> 0\n  ps' \\<notin> set (split_sign_changes (q # r # ps'') x\\<^sub>0)", "have \"ps' = [p, q]\""], ["proof (prove)\nusing this:\n  ps' \\<in> set (split_sign_changes (p # q # r # ps'') x\\<^sub>0)\n  poly q x\\<^sub>0 \\<noteq> 0\n  ps' \\<notin> set (split_sign_changes (q # r # ps'') x\\<^sub>0)\n\ngoal (1 subgoal):\n 1. ps' = [p, q]", "by simp"], ["proof (state)\nthis:\n  ps' = [p, q]\n\ngoal (1 subgoal):\n 1. ps'\n    \\<notin> set (split_sign_changes (q # r # ps'')\n                   x\\<^sub>0) \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0", "hence [simp]: \"\\<forall>p\\<in>set ps'. poly p x\\<^sub>0 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  ps' = [p, q]\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set ps'. poly p x\\<^sub>0 \\<noteq> 0", "using q_not_0 p_not_0"], ["proof (prove)\nusing this:\n  ps' = [p, q]\n  poly q x\\<^sub>0 \\<noteq> 0\n  poly p x\\<^sub>0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set ps'. poly p x\\<^sub>0 \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set ps'. poly p x\\<^sub>0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ps'\n    \\<notin> set (split_sign_changes (q # r # ps'')\n                   x\\<^sub>0) \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0", "proof (rule eventually_mono)"], ["proof (state)\ngoal (2 subgoals):\n 1. eventually ?P (at x\\<^sub>0)\n 2. \\<And>x.\n       ?P x \\<Longrightarrow>\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. eventually ?P (at x\\<^sub>0)\n 2. \\<And>x.\n       ?P x \\<Longrightarrow>\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0", "assume \"\\<forall>p\\<in>set ps'. sgn (poly p x) = sgn (poly p x\\<^sub>0)\""], ["proof (state)\nthis:\n  \\<forall>p\\<in>set ps'. sgn (poly p x) = sgn (poly p x\\<^sub>0)\n\ngoal (2 subgoals):\n 1. eventually ?P (at x\\<^sub>0)\n 2. \\<And>x.\n       ?P x \\<Longrightarrow>\n       sign_changes ps' x = sign_changes ps' x\\<^sub>0", "thus \"sign_changes ps' x = sign_changes ps' x\\<^sub>0\""], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set ps'. sgn (poly p x) = sgn (poly p x\\<^sub>0)\n\ngoal (1 subgoal):\n 1. sign_changes ps' x = sign_changes ps' x\\<^sub>0", "by (rule sign_changes_cong')"], ["proof (state)\nthis:\n  sign_changes ps' x = sign_changes ps' x\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       \\<forall>p\\<in>set ps'. sgn (poly p x) = sgn (poly p x\\<^sub>0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       \\<forall>p\\<in>set ps'. sgn (poly p x) = sgn (poly p x\\<^sub>0)", "show \"eventually (\\<lambda>x. \\<forall>p\\<in>set ps'.\n                        sgn (poly p x) = sgn (poly p x\\<^sub>0)) (at x\\<^sub>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       \\<forall>p\\<in>set ps'. sgn (poly p x) = sgn (poly p x\\<^sub>0)", "by (force intro: eventually_ball_finite\n                                   poly_neighbourhood_same_sign)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     \\<forall>p\\<in>set ps'. sgn (poly p x) = sgn (poly p x\\<^sub>0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     sign_changes ps' x = sign_changes ps' x\\<^sub>0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     sign_changes ps' x = sign_changes ps' x\\<^sub>0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     sign_changes ps' x = sign_changes ps' x\\<^sub>0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in quasi_sturm_seq) hd_nonzero_imp_sign_changes_const:\n  assumes \"poly (hd ps) x\\<^sub>0 \\<noteq> 0\"\n  shows \"eventually (\\<lambda>x. sign_changes ps x = sign_changes ps x\\<^sub>0) (at x\\<^sub>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps x = sign_changes ps x\\<^sub>0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps x = sign_changes ps x\\<^sub>0", "let ?pss = \"split_sign_changes ps x\\<^sub>0\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps x = sign_changes ps x\\<^sub>0", "let ?f = \"\\<lambda>pss x. \\<Sum>ps'\\<leftarrow>pss. sign_changes ps' x\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps x = sign_changes ps x\\<^sub>0", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps x = sign_changes ps x\\<^sub>0", "fix pss"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps x = sign_changes ps x\\<^sub>0", "assume \"\\<And>ps'. ps'\\<in>set pss \\<Longrightarrow>\n        eventually (\\<lambda>x. sign_changes ps' x = sign_changes ps' x\\<^sub>0) (at x\\<^sub>0)\""], ["proof (state)\nthis:\n  ?ps' \\<in> set pss \\<Longrightarrow>\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     sign_changes ?ps' x = sign_changes ?ps' x\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps x = sign_changes ps x\\<^sub>0", "hence \"eventually (\\<lambda>x. ?f pss x = ?f pss x\\<^sub>0) (at x\\<^sub>0)\""], ["proof (prove)\nusing this:\n  ?ps' \\<in> set pss \\<Longrightarrow>\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     sign_changes ?ps' x = sign_changes ?ps' x\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       (\\<Sum>ps'\\<leftarrow>pss. sign_changes ps' x) =\n       (\\<Sum>ps'\\<leftarrow>pss. sign_changes ps' x\\<^sub>0)", "proof (induction pss)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>ps'.\n        ps' \\<in> set [] \\<Longrightarrow>\n        \\<forall>\\<^sub>F x in at x\\<^sub>0.\n           sign_changes ps' x =\n           sign_changes ps' x\\<^sub>0) \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       (\\<Sum>ps'\\<leftarrow>[]. sign_changes ps' x) =\n       (\\<Sum>ps'\\<leftarrow>[]. sign_changes ps' x\\<^sub>0)\n 2. \\<And>a pss.\n       \\<lbrakk>(\\<And>ps'.\n                    ps' \\<in> set pss \\<Longrightarrow>\n                    \\<forall>\\<^sub>F x in at x\\<^sub>0.\n                       sign_changes ps' x =\n                       sign_changes ps' x\\<^sub>0) \\<Longrightarrow>\n                \\<forall>\\<^sub>F x in at x\\<^sub>0.\n                   (\\<Sum>ps'\\<leftarrow>pss. sign_changes ps' x) =\n                   (\\<Sum>ps'\\<leftarrow>pss. sign_changes ps' x\\<^sub>0);\n        \\<And>ps'.\n           ps' \\<in> set (a # pss) \\<Longrightarrow>\n           \\<forall>\\<^sub>F x in at x\\<^sub>0.\n              sign_changes ps' x = sign_changes ps' x\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F x in at x\\<^sub>0.\n                            (\\<Sum>ps'\\<leftarrow>a #\n            pss. sign_changes ps' x) =\n                            (\\<Sum>ps'\\<leftarrow>a #\n            pss. sign_changes ps' x\\<^sub>0)", "case (Cons ps' pss)"], ["proof (state)\nthis:\n  (\\<And>ps'.\n      ps' \\<in> set pss \\<Longrightarrow>\n      \\<forall>\\<^sub>F x in at x\\<^sub>0.\n         sign_changes ps' x = sign_changes ps' x\\<^sub>0) \\<Longrightarrow>\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     (\\<Sum>ps'\\<leftarrow>pss. sign_changes ps' x) =\n     (\\<Sum>ps'\\<leftarrow>pss. sign_changes ps' x\\<^sub>0)\n  ?ps' \\<in> set (ps' # pss) \\<Longrightarrow>\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     sign_changes ?ps' x = sign_changes ?ps' x\\<^sub>0\n\ngoal (2 subgoals):\n 1. (\\<And>ps'.\n        ps' \\<in> set [] \\<Longrightarrow>\n        \\<forall>\\<^sub>F x in at x\\<^sub>0.\n           sign_changes ps' x =\n           sign_changes ps' x\\<^sub>0) \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       (\\<Sum>ps'\\<leftarrow>[]. sign_changes ps' x) =\n       (\\<Sum>ps'\\<leftarrow>[]. sign_changes ps' x\\<^sub>0)\n 2. \\<And>a pss.\n       \\<lbrakk>(\\<And>ps'.\n                    ps' \\<in> set pss \\<Longrightarrow>\n                    \\<forall>\\<^sub>F x in at x\\<^sub>0.\n                       sign_changes ps' x =\n                       sign_changes ps' x\\<^sub>0) \\<Longrightarrow>\n                \\<forall>\\<^sub>F x in at x\\<^sub>0.\n                   (\\<Sum>ps'\\<leftarrow>pss. sign_changes ps' x) =\n                   (\\<Sum>ps'\\<leftarrow>pss. sign_changes ps' x\\<^sub>0);\n        \\<And>ps'.\n           ps' \\<in> set (a # pss) \\<Longrightarrow>\n           \\<forall>\\<^sub>F x in at x\\<^sub>0.\n              sign_changes ps' x = sign_changes ps' x\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F x in at x\\<^sub>0.\n                            (\\<Sum>ps'\\<leftarrow>a #\n            pss. sign_changes ps' x) =\n                            (\\<Sum>ps'\\<leftarrow>a #\n            pss. sign_changes ps' x\\<^sub>0)", "then"], ["proof (chain)\npicking this:\n  (\\<And>ps'.\n      ps' \\<in> set pss \\<Longrightarrow>\n      \\<forall>\\<^sub>F x in at x\\<^sub>0.\n         sign_changes ps' x = sign_changes ps' x\\<^sub>0) \\<Longrightarrow>\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     (\\<Sum>ps'\\<leftarrow>pss. sign_changes ps' x) =\n     (\\<Sum>ps'\\<leftarrow>pss. sign_changes ps' x\\<^sub>0)\n  ?ps' \\<in> set (ps' # pss) \\<Longrightarrow>\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     sign_changes ?ps' x = sign_changes ?ps' x\\<^sub>0", "show ?case"], ["proof (prove)\nusing this:\n  (\\<And>ps'.\n      ps' \\<in> set pss \\<Longrightarrow>\n      \\<forall>\\<^sub>F x in at x\\<^sub>0.\n         sign_changes ps' x = sign_changes ps' x\\<^sub>0) \\<Longrightarrow>\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     (\\<Sum>ps'\\<leftarrow>pss. sign_changes ps' x) =\n     (\\<Sum>ps'\\<leftarrow>pss. sign_changes ps' x\\<^sub>0)\n  ?ps' \\<in> set (ps' # pss) \\<Longrightarrow>\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     sign_changes ?ps' x = sign_changes ?ps' x\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       (\\<Sum>ps'\\<leftarrow>ps' # pss. sign_changes ps' x) =\n       (\\<Sum>ps'\\<leftarrow>ps' # pss. sign_changes ps' x\\<^sub>0)", "apply (rule eventually_mono[OF eventually_conj])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ps'.\n       ps' \\<in> set pss \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sign_changes ps' x = sign_changes ps' x\\<^sub>0\n 2. ?ps'2 \\<in> set (ps' # pss)\n 3. \\<And>x.\n       (\\<Sum>ps'\\<leftarrow>pss. sign_changes ps' x) =\n       (\\<Sum>ps'\\<leftarrow>pss. sign_changes ps' x\\<^sub>0) \\<and>\n       sign_changes ?ps'2 x = sign_changes ?ps'2 x\\<^sub>0 \\<Longrightarrow>\n       (\\<Sum>ps'\\<leftarrow>ps' # pss. sign_changes ps' x) =\n       (\\<Sum>ps'\\<leftarrow>ps' # pss. sign_changes ps' x\\<^sub>0)", "apply (auto simp add: Cons.prems)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     (\\<Sum>ps'\\<leftarrow>ps' # pss. sign_changes ps' x) =\n     (\\<Sum>ps'\\<leftarrow>ps' # pss. sign_changes ps' x\\<^sub>0)\n\ngoal (1 subgoal):\n 1. (\\<And>ps'.\n        ps' \\<in> set [] \\<Longrightarrow>\n        \\<forall>\\<^sub>F x in at x\\<^sub>0.\n           sign_changes ps' x =\n           sign_changes ps' x\\<^sub>0) \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       (\\<Sum>ps'\\<leftarrow>[]. sign_changes ps' x) =\n       (\\<Sum>ps'\\<leftarrow>[]. sign_changes ps' x\\<^sub>0)", "qed simp"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     (\\<Sum>ps'\\<leftarrow>pss. sign_changes ps' x) =\n     (\\<Sum>ps'\\<leftarrow>pss. sign_changes ps' x\\<^sub>0)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps x = sign_changes ps x\\<^sub>0", "}"], ["proof (state)\nthis:\n  (\\<And>ps'.\n      ps' \\<in> set ?pss2 \\<Longrightarrow>\n      \\<forall>\\<^sub>F x in at x\\<^sub>0.\n         sign_changes ps' x = sign_changes ps' x\\<^sub>0) \\<Longrightarrow>\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     (\\<Sum>ps'\\<leftarrow>?pss2. sign_changes ps' x) =\n     (\\<Sum>ps'\\<leftarrow>?pss2. sign_changes ps' x\\<^sub>0)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps x = sign_changes ps x\\<^sub>0", "note A = this[of ?pss]"], ["proof (state)\nthis:\n  (\\<And>ps'.\n      ps' \\<in> set (split_sign_changes ps x\\<^sub>0) \\<Longrightarrow>\n      \\<forall>\\<^sub>F x in at x\\<^sub>0.\n         sign_changes ps' x = sign_changes ps' x\\<^sub>0) \\<Longrightarrow>\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     (\\<Sum>ps'\\<leftarrow>split_sign_changes ps\n                            x\\<^sub>0. sign_changes ps' x) =\n     (\\<Sum>ps'\\<leftarrow>split_sign_changes ps\n                            x\\<^sub>0. sign_changes ps' x\\<^sub>0)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps x = sign_changes ps x\\<^sub>0", "have B: \"eventually (\\<lambda>x. ?f ?pss x = ?f ?pss x\\<^sub>0) (at x\\<^sub>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       (\\<Sum>ps'\\<leftarrow>split_sign_changes ps\n                              x\\<^sub>0. sign_changes ps' x) =\n       (\\<Sum>ps'\\<leftarrow>split_sign_changes ps\n                              x\\<^sub>0. sign_changes ps' x\\<^sub>0)", "by (rule A, rule hd_nonzero_imp_sign_changes_const_aux[OF assms], simp)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     (\\<Sum>ps'\\<leftarrow>split_sign_changes ps\n                            x\\<^sub>0. sign_changes ps' x) =\n     (\\<Sum>ps'\\<leftarrow>split_sign_changes ps\n                            x\\<^sub>0. sign_changes ps' x\\<^sub>0)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps x = sign_changes ps x\\<^sub>0", "note C = split_sign_changes_correct_nbh[OF assms]"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     (\\<Sum>ps'\\<leftarrow>split_sign_changes ps\n                            x\\<^sub>0. sign_changes ps' x) =\n     sign_changes ps x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps x = sign_changes ps x\\<^sub>0", "note D = split_sign_changes_correct[OF assms]"], ["proof (state)\nthis:\n  (\\<Sum>ps'\\<leftarrow>split_sign_changes ps\n                         x\\<^sub>0. sign_changes ps' x\\<^sub>0) =\n  sign_changes ps x\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps x = sign_changes ps x\\<^sub>0", "note E = eventually_conj[OF B C]"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     (\\<Sum>ps'\\<leftarrow>split_sign_changes ps\n                            x\\<^sub>0. sign_changes ps' x) =\n     (\\<Sum>ps'\\<leftarrow>split_sign_changes ps\n                            x\\<^sub>0. sign_changes ps' x\\<^sub>0) \\<and>\n     (\\<Sum>ps'\\<leftarrow>split_sign_changes ps\n                            x\\<^sub>0. sign_changes ps' x) =\n     sign_changes ps x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps x = sign_changes ps x\\<^sub>0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps x = sign_changes ps x\\<^sub>0", "by (rule eventually_mono[OF E], auto simp: D)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     sign_changes ps x = sign_changes ps x\\<^sub>0\n\ngoal:\nNo subgoals!", "qed"], ["", "(*<*)"], ["", "hide_fact quasi_sturm_seq.split_sign_changes_correct_nbh"], ["", "hide_fact quasi_sturm_seq.hd_nonzero_imp_sign_changes_const_aux"], ["", "(*>*)"], ["", "lemma (in sturm_seq) p_nonzero_imp_sign_changes_const:\n  \"poly p x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n       eventually (\\<lambda>x. sign_changes ps x = sign_changes ps x\\<^sub>0) (at x\\<^sub>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps x = sign_changes ps x\\<^sub>0", "using hd_nonzero_imp_sign_changes_const"], ["proof (prove)\nusing this:\n  poly (hd ps) ?x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n  \\<forall>\\<^sub>F x in at ?x\\<^sub>0.\n     sign_changes ps x = sign_changes ps ?x\\<^sub>0\n\ngoal (1 subgoal):\n 1. poly p x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps x = sign_changes ps x\\<^sub>0", "by simp"], ["", "text \\<open>\n  If $x$ is a root of $p$ and $p$ is not the zero polynomial, the\n  number of sign changes of a Sturm chain of $p$ decreases by 1 at $x$.\n\\<close>"], ["", "lemma (in sturm_seq) p_zero:\n  assumes \"poly p x\\<^sub>0 = 0\" \"p \\<noteq> 0\"\n  shows \"eventually (\\<lambda>x. sign_changes ps x =\n      sign_changes ps x\\<^sub>0 + (if x<x\\<^sub>0 then 1 else 0)) (at x\\<^sub>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps x =\n       sign_changes ps x\\<^sub>0 + (if x < x\\<^sub>0 then 1 else 0)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps x =\n       sign_changes ps x\\<^sub>0 + (if x < x\\<^sub>0 then 1 else 0)", "from ps_first_two"], ["proof (chain)\npicking this:\n  (\\<And>q ps'.\n      ps = p # q # ps' \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain q ps' where [simp]: \"ps = p#q#ps'\""], ["proof (prove)\nusing this:\n  (\\<And>q ps'.\n      ps = p # q # ps' \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>q ps'.\n        ps = p # q # ps' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  ps = p # q # ps'\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps x =\n       sign_changes ps x\\<^sub>0 + (if x < x\\<^sub>0 then 1 else 0)", "hence \"ps!1 = q\""], ["proof (prove)\nusing this:\n  ps = p # q # ps'\n\ngoal (1 subgoal):\n 1. ps ! 1 = q", "by simp"], ["proof (state)\nthis:\n  ps ! 1 = q\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps x =\n       sign_changes ps x\\<^sub>0 + (if x < x\\<^sub>0 then 1 else 0)", "have \"eventually (\\<lambda>x. x \\<noteq> x\\<^sub>0) (at x\\<^sub>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0. x \\<noteq> x\\<^sub>0", "by (simp add: eventually_at, rule exI[of _ 1], simp)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at x\\<^sub>0. x \\<noteq> x\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps x =\n       sign_changes ps x\\<^sub>0 + (if x < x\\<^sub>0 then 1 else 0)", "moreover"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at x\\<^sub>0. x \\<noteq> x\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps x =\n       sign_changes ps x\\<^sub>0 + (if x < x\\<^sub>0 then 1 else 0)", "from p_squarefree and assms(1)"], ["proof (chain)\npicking this:\n  \\<not> (poly p ?x = 0 \\<and> poly (ps ! 1) ?x = 0)\n  poly p x\\<^sub>0 = 0", "have \"poly q x\\<^sub>0 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> (poly p ?x = 0 \\<and> poly (ps ! 1) ?x = 0)\n  poly p x\\<^sub>0 = 0\n\ngoal (1 subgoal):\n 1. poly q x\\<^sub>0 \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  poly q x\\<^sub>0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps x =\n       sign_changes ps x\\<^sub>0 + (if x < x\\<^sub>0 then 1 else 0)", "{"], ["proof (state)\nthis:\n  poly q x\\<^sub>0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps x =\n       sign_changes ps x\\<^sub>0 + (if x < x\\<^sub>0 then 1 else 0)", "have A: \"quasi_sturm_seq ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quasi_sturm_seq ps", ".."], ["proof (state)\nthis:\n  quasi_sturm_seq ps\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps x =\n       sign_changes ps x\\<^sub>0 + (if x < x\\<^sub>0 then 1 else 0)", "with quasi_sturm_seq_Cons[of p \"q#ps'\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>quasi_sturm_seq (p # q # ps'); q # ps' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> quasi_sturm_seq (q # ps')\n  quasi_sturm_seq ps", "interpret quasi_sturm_seq \"q#ps'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>quasi_sturm_seq (p # q # ps'); q # ps' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> quasi_sturm_seq (q # ps')\n  quasi_sturm_seq ps\n\ngoal (1 subgoal):\n 1. quasi_sturm_seq (q # ps')", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps x =\n       sign_changes ps x\\<^sub>0 + (if x < x\\<^sub>0 then 1 else 0)", "from \\<open>poly q x\\<^sub>0 \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  poly q x\\<^sub>0 \\<noteq> 0", "have \"eventually (\\<lambda>x. sign_changes (q#ps') x =\n                                     sign_changes (q#ps') x\\<^sub>0) (at x\\<^sub>0)\""], ["proof (prove)\nusing this:\n  poly q x\\<^sub>0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes (q # ps') x = sign_changes (q # ps') x\\<^sub>0", "using hd_nonzero_imp_sign_changes_const[where x\\<^sub>0=x\\<^sub>0]"], ["proof (prove)\nusing this:\n  poly q x\\<^sub>0 \\<noteq> 0\n  poly (hd (q # ps')) x\\<^sub>0 \\<noteq> 0 \\<Longrightarrow>\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     sign_changes (q # ps') x = sign_changes (q # ps') x\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes (q # ps') x = sign_changes (q # ps') x\\<^sub>0", "by simp"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     sign_changes (q # ps') x = sign_changes (q # ps') x\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps x =\n       sign_changes ps x\\<^sub>0 + (if x < x\\<^sub>0 then 1 else 0)", "}"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     sign_changes (q # ps') x = sign_changes (q # ps') x\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps x =\n       sign_changes ps x\\<^sub>0 + (if x < x\\<^sub>0 then 1 else 0)", "moreover"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     sign_changes (q # ps') x = sign_changes (q # ps') x\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps x =\n       sign_changes ps x\\<^sub>0 + (if x < x\\<^sub>0 then 1 else 0)", "note poly_neighbourhood_without_roots[OF assms(2)] deriv[OF assms(1)]"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at ?x\\<^sub>0. poly p x \\<noteq> 0\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     sgn (poly (p * ps ! 1) x) = (if x\\<^sub>0 < x then 1 else - 1)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps x =\n       sign_changes ps x\\<^sub>0 + (if x < x\\<^sub>0 then 1 else 0)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in at x\\<^sub>0. x \\<noteq> x\\<^sub>0\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     sign_changes (q # ps') x = sign_changes (q # ps') x\\<^sub>0\n  \\<forall>\\<^sub>F x in at ?x\\<^sub>0. poly p x \\<noteq> 0\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     sgn (poly (p * ps ! 1) x) = (if x\\<^sub>0 < x then 1 else - 1)", "have A: \"eventually (\\<lambda>x. x \\<noteq> x\\<^sub>0 \\<and> poly p x \\<noteq> 0 \\<and>\n                   sgn (poly (p*ps!1) x) = (if x > x\\<^sub>0 then 1 else -1) \\<and>\n                   sign_changes (q#ps') x = sign_changes (q#ps') x\\<^sub>0) (at x\\<^sub>0)\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at x\\<^sub>0. x \\<noteq> x\\<^sub>0\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     sign_changes (q # ps') x = sign_changes (q # ps') x\\<^sub>0\n  \\<forall>\\<^sub>F x in at ?x\\<^sub>0. poly p x \\<noteq> 0\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     sgn (poly (p * ps ! 1) x) = (if x\\<^sub>0 < x then 1 else - 1)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       x \\<noteq> x\\<^sub>0 \\<and>\n       poly p x \\<noteq> 0 \\<and>\n       sgn (poly (p * ps ! 1) x) = (if x\\<^sub>0 < x then 1 else - 1) \\<and>\n       sign_changes (q # ps') x = sign_changes (q # ps') x\\<^sub>0", "by (simp only: \\<open>ps!1 = q\\<close>, intro eventually_conj)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     x \\<noteq> x\\<^sub>0 \\<and>\n     poly p x \\<noteq> 0 \\<and>\n     sgn (poly (p * ps ! 1) x) = (if x\\<^sub>0 < x then 1 else - 1) \\<and>\n     sign_changes (q # ps') x = sign_changes (q # ps') x\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps x =\n       sign_changes ps x\\<^sub>0 + (if x < x\\<^sub>0 then 1 else 0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sign_changes ps x =\n       sign_changes ps x\\<^sub>0 + (if x < x\\<^sub>0 then 1 else 0)", "proof (rule eventually_mono[OF A], clarify, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> x\\<^sub>0; poly p x \\<noteq> 0;\n        sgn (poly (p * ps ! 1) x) = (if x\\<^sub>0 < x then 1 else - 1);\n        sign_changes (q # ps') x = sign_changes (q # ps') x\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> sign_changes ps x =\n                         sign_changes ps x\\<^sub>0 +\n                         (if x < x\\<^sub>0 then 1 else 0)", "case prems: (1 x)"], ["proof (state)\nthis:\n  x \\<noteq> x\\<^sub>0\n  poly p x \\<noteq> 0\n  sgn (poly (p * ps ! 1) x) = (if x\\<^sub>0 < x then 1 else - 1)\n  sign_changes (q # ps') x = sign_changes (q # ps') x\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> x\\<^sub>0; poly p x \\<noteq> 0;\n        sgn (poly (p * ps ! 1) x) = (if x\\<^sub>0 < x then 1 else - 1);\n        sign_changes (q # ps') x = sign_changes (q # ps') x\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> sign_changes ps x =\n                         sign_changes ps x\\<^sub>0 +\n                         (if x < x\\<^sub>0 then 1 else 0)", "from zero_less_mult_pos"], ["proof (chain)\npicking this:\n  \\<lbrakk>(0::?'a) < ?a * ?b; (0::?'a) < ?a\\<rbrakk>\n  \\<Longrightarrow> (0::?'a) < ?b", "have zero_less_mult_pos':\n        \"\\<And>a b. \\<lbrakk>(0::real) < a*b; 0 < b\\<rbrakk> \\<Longrightarrow> 0 < a\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(0::?'a) < ?a * ?b; (0::?'a) < ?a\\<rbrakk>\n  \\<Longrightarrow> (0::?'a) < ?b\n\ngoal (1 subgoal):\n 1. \\<And>a b. \\<lbrakk>0 < a * b; 0 < b\\<rbrakk> \\<Longrightarrow> 0 < a", "by (subgoal_tac \"a*b = b*a\", auto)"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?a * ?b; 0 < ?b\\<rbrakk> \\<Longrightarrow> 0 < ?a\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> x\\<^sub>0; poly p x \\<noteq> 0;\n        sgn (poly (p * ps ! 1) x) = (if x\\<^sub>0 < x then 1 else - 1);\n        sign_changes (q # ps') x = sign_changes (q # ps') x\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> sign_changes ps x =\n                         sign_changes ps x\\<^sub>0 +\n                         (if x < x\\<^sub>0 then 1 else 0)", "from prems"], ["proof (chain)\npicking this:\n  x \\<noteq> x\\<^sub>0\n  poly p x \\<noteq> 0\n  sgn (poly (p * ps ! 1) x) = (if x\\<^sub>0 < x then 1 else - 1)\n  sign_changes (q # ps') x = sign_changes (q # ps') x\\<^sub>0", "have \"poly q x \\<noteq> 0\" and q_sgn: \"sgn (poly q x) =\n              (if x < x\\<^sub>0 then -sgn (poly p x) else sgn (poly p x))\""], ["proof (prove)\nusing this:\n  x \\<noteq> x\\<^sub>0\n  poly p x \\<noteq> 0\n  sgn (poly (p * ps ! 1) x) = (if x\\<^sub>0 < x then 1 else - 1)\n  sign_changes (q # ps') x = sign_changes (q # ps') x\\<^sub>0\n\ngoal (1 subgoal):\n 1. poly q x \\<noteq> 0 &&&\n    sgn (poly q x) =\n    (if x < x\\<^sub>0 then - sgn (poly p x) else sgn (poly p x))", "by (auto simp add: sgn_real_def elim: linorder_neqE_linordered_idom\n                 dest: mult_neg_neg zero_less_mult_pos\n                 zero_less_mult_pos' split: if_split_asm)"], ["proof (state)\nthis:\n  poly q x \\<noteq> 0\n  sgn (poly q x) =\n  (if x < x\\<^sub>0 then - sgn (poly p x) else sgn (poly p x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> x\\<^sub>0; poly p x \\<noteq> 0;\n        sgn (poly (p * ps ! 1) x) = (if x\\<^sub>0 < x then 1 else - 1);\n        sign_changes (q # ps') x = sign_changes (q # ps') x\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> sign_changes ps x =\n                         sign_changes ps x\\<^sub>0 +\n                         (if x < x\\<^sub>0 then 1 else 0)", "from sign_changes_distrib[OF \\<open>poly q x \\<noteq> 0\\<close>, of \"[p]\" ps']"], ["proof (chain)\npicking this:\n  sign_changes ([p] @ [q] @ ps') x =\n  sign_changes ([p] @ [q]) x + sign_changes ([q] @ ps') x", "have \"sign_changes ps x = sign_changes [p,q] x + sign_changes (q#ps') x\""], ["proof (prove)\nusing this:\n  sign_changes ([p] @ [q] @ ps') x =\n  sign_changes ([p] @ [q]) x + sign_changes ([q] @ ps') x\n\ngoal (1 subgoal):\n 1. sign_changes ps x = sign_changes [p, q] x + sign_changes (q # ps') x", "by simp"], ["proof (state)\nthis:\n  sign_changes ps x = sign_changes [p, q] x + sign_changes (q # ps') x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> x\\<^sub>0; poly p x \\<noteq> 0;\n        sgn (poly (p * ps ! 1) x) = (if x\\<^sub>0 < x then 1 else - 1);\n        sign_changes (q # ps') x = sign_changes (q # ps') x\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> sign_changes ps x =\n                         sign_changes ps x\\<^sub>0 +\n                         (if x < x\\<^sub>0 then 1 else 0)", "also"], ["proof (state)\nthis:\n  sign_changes ps x = sign_changes [p, q] x + sign_changes (q # ps') x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> x\\<^sub>0; poly p x \\<noteq> 0;\n        sgn (poly (p * ps ! 1) x) = (if x\\<^sub>0 < x then 1 else - 1);\n        sign_changes (q # ps') x = sign_changes (q # ps') x\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> sign_changes ps x =\n                         sign_changes ps x\\<^sub>0 +\n                         (if x < x\\<^sub>0 then 1 else 0)", "from q_sgn and \\<open>poly p x \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  sgn (poly q x) =\n  (if x < x\\<^sub>0 then - sgn (poly p x) else sgn (poly p x))\n  poly p x \\<noteq> 0", "have \"sign_changes [p,q] x = (if x<x\\<^sub>0 then 1 else 0)\""], ["proof (prove)\nusing this:\n  sgn (poly q x) =\n  (if x < x\\<^sub>0 then - sgn (poly p x) else sgn (poly p x))\n  poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sign_changes [p, q] x = (if x < x\\<^sub>0 then 1 else 0)", "by (simp add: sign_changes_def sgn_zero_iff split: if_split_asm)"], ["proof (state)\nthis:\n  sign_changes [p, q] x = (if x < x\\<^sub>0 then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> x\\<^sub>0; poly p x \\<noteq> 0;\n        sgn (poly (p * ps ! 1) x) = (if x\\<^sub>0 < x then 1 else - 1);\n        sign_changes (q # ps') x = sign_changes (q # ps') x\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> sign_changes ps x =\n                         sign_changes ps x\\<^sub>0 +\n                         (if x < x\\<^sub>0 then 1 else 0)", "also"], ["proof (state)\nthis:\n  sign_changes [p, q] x = (if x < x\\<^sub>0 then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> x\\<^sub>0; poly p x \\<noteq> 0;\n        sgn (poly (p * ps ! 1) x) = (if x\\<^sub>0 < x then 1 else - 1);\n        sign_changes (q # ps') x = sign_changes (q # ps') x\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> sign_changes ps x =\n                         sign_changes ps x\\<^sub>0 +\n                         (if x < x\\<^sub>0 then 1 else 0)", "note prems(4)"], ["proof (state)\nthis:\n  sign_changes (q # ps') x = sign_changes (q # ps') x\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> x\\<^sub>0; poly p x \\<noteq> 0;\n        sgn (poly (p * ps ! 1) x) = (if x\\<^sub>0 < x then 1 else - 1);\n        sign_changes (q # ps') x = sign_changes (q # ps') x\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> sign_changes ps x =\n                         sign_changes ps x\\<^sub>0 +\n                         (if x < x\\<^sub>0 then 1 else 0)", "also"], ["proof (state)\nthis:\n  sign_changes (q # ps') x = sign_changes (q # ps') x\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> x\\<^sub>0; poly p x \\<noteq> 0;\n        sgn (poly (p * ps ! 1) x) = (if x\\<^sub>0 < x then 1 else - 1);\n        sign_changes (q # ps') x = sign_changes (q # ps') x\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> sign_changes ps x =\n                         sign_changes ps x\\<^sub>0 +\n                         (if x < x\\<^sub>0 then 1 else 0)", "from assms(1)"], ["proof (chain)\npicking this:\n  poly p x\\<^sub>0 = 0", "have \"sign_changes (q#ps') x\\<^sub>0 = sign_changes ps x\\<^sub>0\""], ["proof (prove)\nusing this:\n  poly p x\\<^sub>0 = 0\n\ngoal (1 subgoal):\n 1. sign_changes (q # ps') x\\<^sub>0 = sign_changes ps x\\<^sub>0", "by (simp add: sign_changes_def)"], ["proof (state)\nthis:\n  sign_changes (q # ps') x\\<^sub>0 = sign_changes ps x\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> x\\<^sub>0; poly p x \\<noteq> 0;\n        sgn (poly (p * ps ! 1) x) = (if x\\<^sub>0 < x then 1 else - 1);\n        sign_changes (q # ps') x = sign_changes (q # ps') x\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> sign_changes ps x =\n                         sign_changes ps x\\<^sub>0 +\n                         (if x < x\\<^sub>0 then 1 else 0)", "finally"], ["proof (chain)\npicking this:\n  sign_changes ps x =\n  (if x < x\\<^sub>0 then 1 else 0) + sign_changes ps x\\<^sub>0", "show ?case"], ["proof (prove)\nusing this:\n  sign_changes ps x =\n  (if x < x\\<^sub>0 then 1 else 0) + sign_changes ps x\\<^sub>0\n\ngoal (1 subgoal):\n 1. sign_changes ps x =\n    sign_changes ps x\\<^sub>0 + (if x < x\\<^sub>0 then 1 else 0)", "by simp"], ["proof (state)\nthis:\n  sign_changes ps x =\n  sign_changes ps x\\<^sub>0 + (if x < x\\<^sub>0 then 1 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     sign_changes ps x =\n     sign_changes ps x\\<^sub>0 + (if x < x\\<^sub>0 then 1 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  With these two results, we can now show that if $p$ is nonzero, the number\n  of roots in an interval of the form $(a;b]$ is the difference of the sign changes\n  of a Sturm sequence of $p$ at $a$ and $b$.\\\\\n  First, however, we prove the following auxiliary lemma that shows that\n  if a function $f: \\RR\\to\\NN$ is locally constant at any $x\\in(a;b]$, it is constant\n  across the entire interval $(a;b]$:\n\\<close>"], ["", "lemma count_roots_between_aux:\n  assumes \"a \\<le> b\"\n  assumes \"\\<forall>x::real. a < x \\<and> x \\<le> b \\<longrightarrow> eventually (\\<lambda>\\<xi>. f \\<xi> = (f x::nat)) (at x)\"\n  shows \"\\<forall>x. a < x \\<and> x \\<le> b \\<longrightarrow> f x = f b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. a < x \\<and> x \\<le> b \\<longrightarrow> f x = f b", "proof (clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<lbrakk>a < x; x \\<le> b\\<rbrakk> \\<Longrightarrow> f x = f b", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<lbrakk>a < x; x \\<le> b\\<rbrakk> \\<Longrightarrow> f x = f b", "assume \"x > a\" \"x \\<le> b\""], ["proof (state)\nthis:\n  a < x\n  x \\<le> b\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<lbrakk>a < x; x \\<le> b\\<rbrakk> \\<Longrightarrow> f x = f b", "with assms"], ["proof (chain)\npicking this:\n  a \\<le> b\n  \\<forall>x.\n     a < x \\<and> x \\<le> b \\<longrightarrow>\n     (\\<forall>\\<^sub>F \\<xi> in at x. f \\<xi> = f x)\n  a < x\n  x \\<le> b", "have \"\\<forall>x'. x \\<le> x' \\<and> x' \\<le> b \\<longrightarrow>\n                       eventually (\\<lambda>\\<xi>. f \\<xi> = f x') (at x')\""], ["proof (prove)\nusing this:\n  a \\<le> b\n  \\<forall>x.\n     a < x \\<and> x \\<le> b \\<longrightarrow>\n     (\\<forall>\\<^sub>F \\<xi> in at x. f \\<xi> = f x)\n  a < x\n  x \\<le> b\n\ngoal (1 subgoal):\n 1. \\<forall>x'.\n       x \\<le> x' \\<and> x' \\<le> b \\<longrightarrow>\n       (\\<forall>\\<^sub>F \\<xi> in at x'. f \\<xi> = f x')", "by auto"], ["proof (state)\nthis:\n  \\<forall>x'.\n     x \\<le> x' \\<and> x' \\<le> b \\<longrightarrow>\n     (\\<forall>\\<^sub>F \\<xi> in at x'. f \\<xi> = f x')\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<lbrakk>a < x; x \\<le> b\\<rbrakk> \\<Longrightarrow> f x = f b", "from fun_eq_in_ivl[OF \\<open>x \\<le> b\\<close> this]"], ["proof (chain)\npicking this:\n  f x = f b", "show \"f x = f b\""], ["proof (prove)\nusing this:\n  f x = f b\n\ngoal (1 subgoal):\n 1. f x = f b", "."], ["proof (state)\nthis:\n  f x = f b\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Now we can prove the actual root-counting theorem:\n\\<close>"], ["", "theorem (in sturm_seq) count_roots_between:\n  assumes [simp]: \"p \\<noteq> 0\" \"a \\<le> b\"\n  shows \"sign_changes ps a - sign_changes ps b =\n             card {x. x > a \\<and> x \\<le> b \\<and> poly p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes ps a - sign_changes ps b =\n    card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. sign_changes ps a - sign_changes ps b =\n    card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}", "have \"sign_changes ps a - int (sign_changes ps b) =\n             card {x. x > a \\<and> x \\<le> b \\<and> poly p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (sign_changes ps a) - int (sign_changes ps b) =\n    int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})", "using \\<open>a \\<le> b\\<close>"], ["proof (prove)\nusing this:\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. int (sign_changes ps a) - int (sign_changes ps b) =\n    int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})", "proof (induction \"card {x. x > a \\<and> x \\<le> b \\<and> poly p x = 0}\" arbitrary: a b\n             rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>card\n                             {x. aa < x \\<and>\n                                 x \\<le> ba \\<and> poly p x = 0}\n                            < card\n                               {x. a < x \\<and>\n                                   x \\<le> b \\<and> poly p x = 0};\n                    aa \\<le> ba\\<rbrakk>\n                   \\<Longrightarrow> int (sign_changes ps aa) -\n                                     int (sign_changes ps ba) =\n                                     int\n(card {x. aa < x \\<and> x \\<le> ba \\<and> poly p x = 0});\n        a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> int (sign_changes ps a) - int (sign_changes ps b) =\n                         int (card\n                               {x. a < x \\<and>\n                                   x \\<le> b \\<and> poly p x = 0})", "case (less a b)"], ["proof (state)\nthis:\n  \\<lbrakk>card {x. ?a < x \\<and> x \\<le> ?b \\<and> poly p x = 0}\n           < card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0};\n   ?a \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> int (sign_changes ps ?a) - int (sign_changes ps ?b) =\n                    int (card\n                          {x. ?a < x \\<and> x \\<le> ?b \\<and> poly p x = 0})\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>card\n                             {x. aa < x \\<and>\n                                 x \\<le> ba \\<and> poly p x = 0}\n                            < card\n                               {x. a < x \\<and>\n                                   x \\<le> b \\<and> poly p x = 0};\n                    aa \\<le> ba\\<rbrakk>\n                   \\<Longrightarrow> int (sign_changes ps aa) -\n                                     int (sign_changes ps ba) =\n                                     int\n(card {x. aa < x \\<and> x \\<le> ba \\<and> poly p x = 0});\n        a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> int (sign_changes ps a) - int (sign_changes ps b) =\n                         int (card\n                               {x. a < x \\<and>\n                                   x \\<le> b \\<and> poly p x = 0})", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (sign_changes ps a) - int (sign_changes ps b) =\n    int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})", "proof (cases \"\\<exists>x. a < x \\<and> x \\<le> b \\<and> poly p x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>x>a. x \\<le> b \\<and> poly p x = 0 \\<Longrightarrow>\n    int (sign_changes ps a) - int (sign_changes ps b) =\n    int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})\n 2. \\<not> (\\<exists>x>a. x \\<le> b \\<and> poly p x = 0) \\<Longrightarrow>\n    int (sign_changes ps a) - int (sign_changes ps b) =\n    int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>x>a. x \\<le> b \\<and> poly p x = 0)\n\ngoal (2 subgoals):\n 1. \\<exists>x>a. x \\<le> b \\<and> poly p x = 0 \\<Longrightarrow>\n    int (sign_changes ps a) - int (sign_changes ps b) =\n    int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})\n 2. \\<not> (\\<exists>x>a. x \\<le> b \\<and> poly p x = 0) \\<Longrightarrow>\n    int (sign_changes ps a) - int (sign_changes ps b) =\n    int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})", "hence no_roots: \"{x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} = {}\"\n              (is \"?roots=_\")"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>x>a. x \\<le> b \\<and> poly p x = 0)\n\ngoal (1 subgoal):\n 1. {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} = {}", "by auto"], ["proof (state)\nthis:\n  {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} = {}\n\ngoal (2 subgoals):\n 1. \\<exists>x>a. x \\<le> b \\<and> poly p x = 0 \\<Longrightarrow>\n    int (sign_changes ps a) - int (sign_changes ps b) =\n    int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})\n 2. \\<not> (\\<exists>x>a. x \\<le> b \\<and> poly p x = 0) \\<Longrightarrow>\n    int (sign_changes ps a) - int (sign_changes ps b) =\n    int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})", "hence card_roots: \"card ?roots = (0::int)\""], ["proof (prove)\nusing this:\n  {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} = {}\n\ngoal (1 subgoal):\n 1. int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}) = 0", "by (subst no_roots, simp)"], ["proof (state)\nthis:\n  int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}) = 0\n\ngoal (2 subgoals):\n 1. \\<exists>x>a. x \\<le> b \\<and> poly p x = 0 \\<Longrightarrow>\n    int (sign_changes ps a) - int (sign_changes ps b) =\n    int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})\n 2. \\<not> (\\<exists>x>a. x \\<le> b \\<and> poly p x = 0) \\<Longrightarrow>\n    int (sign_changes ps a) - int (sign_changes ps b) =\n    int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (sign_changes ps a) - int (sign_changes ps b) =\n    int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})", "proof (simp only: card_roots eq_iff_diff_eq_0[symmetric] of_nat_eq_iff,\n                 cases \"poly p a = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. poly p a = 0 \\<Longrightarrow> sign_changes ps a = sign_changes ps b\n 2. poly p a \\<noteq> 0 \\<Longrightarrow>\n    sign_changes ps a = sign_changes ps b", "case False"], ["proof (state)\nthis:\n  poly p a \\<noteq> 0\n\ngoal (2 subgoals):\n 1. poly p a = 0 \\<Longrightarrow> sign_changes ps a = sign_changes ps b\n 2. poly p a \\<noteq> 0 \\<Longrightarrow>\n    sign_changes ps a = sign_changes ps b", "with no_roots"], ["proof (chain)\npicking this:\n  {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} = {}\n  poly p a \\<noteq> 0", "show \"sign_changes ps a = sign_changes ps b\""], ["proof (prove)\nusing this:\n  {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} = {}\n  poly p a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sign_changes ps a = sign_changes ps b", "by (force intro: fun_eq_in_ivl \\<open>a \\<le> b\\<close>\n                                   p_nonzero_imp_sign_changes_const)"], ["proof (state)\nthis:\n  sign_changes ps a = sign_changes ps b\n\ngoal (1 subgoal):\n 1. poly p a = 0 \\<Longrightarrow> sign_changes ps a = sign_changes ps b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. poly p a = 0 \\<Longrightarrow> sign_changes ps a = sign_changes ps b", "case True"], ["proof (state)\nthis:\n  poly p a = 0\n\ngoal (1 subgoal):\n 1. poly p a = 0 \\<Longrightarrow> sign_changes ps a = sign_changes ps b", "have A: \"\\<forall>x. a < x \\<and> x \\<le> b \\<longrightarrow> sign_changes ps x = sign_changes ps b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       a < x \\<and> x \\<le> b \\<longrightarrow>\n       sign_changes ps x = sign_changes ps b", "apply (rule count_roots_between_aux, fact, clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>a < x; x \\<le> b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F \\<xi> in at x.\n                            sign_changes ps \\<xi> = sign_changes ps x", "apply (rule p_nonzero_imp_sign_changes_const)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>a < x; x \\<le> b\\<rbrakk>\n       \\<Longrightarrow> poly p x \\<noteq> 0", "apply (insert False, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>x.\n     a < x \\<and> x \\<le> b \\<longrightarrow>\n     sign_changes ps x = sign_changes ps b\n\ngoal (1 subgoal):\n 1. poly p a = 0 \\<Longrightarrow> sign_changes ps a = sign_changes ps b", "have \"eventually (\\<lambda>x. x > a \\<longrightarrow>\n                        sign_changes ps x = sign_changes ps a) (at a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at a.\n       a < x \\<longrightarrow> sign_changes ps x = sign_changes ps a", "apply (rule eventually_mono [OF p_zero[OF \\<open>poly p a = 0\\<close> \\<open>p \\<noteq> 0\\<close>]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       sign_changes ps x =\n       sign_changes ps a + (if x < a then 1 else 0) \\<Longrightarrow>\n       a < x \\<longrightarrow> sign_changes ps x = sign_changes ps a", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at a.\n     a < x \\<longrightarrow> sign_changes ps x = sign_changes ps a\n\ngoal (1 subgoal):\n 1. poly p a = 0 \\<Longrightarrow> sign_changes ps a = sign_changes ps b", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in at a.\n     a < x \\<longrightarrow> sign_changes ps x = sign_changes ps a", "obtain \\<delta> where \\<delta>_props:\n                  \"\\<delta> > 0\" \"\\<forall>x. x > a \\<and> x < a+\\<delta> \\<longrightarrow>\n                                   sign_changes ps x = sign_changes ps a\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at a.\n     a < x \\<longrightarrow> sign_changes ps x = sign_changes ps a\n\ngoal (1 subgoal):\n 1. (\\<And>\\<delta>.\n        \\<lbrakk>0 < \\<delta>;\n         \\<forall>x.\n            a < x \\<and> x < a + \\<delta> \\<longrightarrow>\n            sign_changes ps x = sign_changes ps a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: eventually_at dist_real_def)"], ["proof (state)\nthis:\n  0 < \\<delta>\n  \\<forall>x.\n     a < x \\<and> x < a + \\<delta> \\<longrightarrow>\n     sign_changes ps x = sign_changes ps a\n\ngoal (1 subgoal):\n 1. poly p a = 0 \\<Longrightarrow> sign_changes ps a = sign_changes ps b", "show \"sign_changes ps a = sign_changes ps b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes ps a = sign_changes ps b", "proof (cases \"a = b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow> sign_changes ps a = sign_changes ps b\n 2. a \\<noteq> b \\<Longrightarrow> sign_changes ps a = sign_changes ps b", "case False"], ["proof (state)\nthis:\n  a \\<noteq> b\n\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow> sign_changes ps a = sign_changes ps b\n 2. a \\<noteq> b \\<Longrightarrow> sign_changes ps a = sign_changes ps b", "define x where \"x = min (a+\\<delta>/2) b\""], ["proof (state)\nthis:\n  x = min (a + \\<delta> / 2) b\n\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow> sign_changes ps a = sign_changes ps b\n 2. a \\<noteq> b \\<Longrightarrow> sign_changes ps a = sign_changes ps b", "with False"], ["proof (chain)\npicking this:\n  a \\<noteq> b\n  x = min (a + \\<delta> / 2) b", "have \"a < x\" \"x < a+\\<delta>\" \"x \\<le> b\""], ["proof (prove)\nusing this:\n  a \\<noteq> b\n  x = min (a + \\<delta> / 2) b\n\ngoal (1 subgoal):\n 1. a < x &&& x < a + \\<delta> &&& x \\<le> b", "using \\<open>\\<delta> > 0\\<close> \\<open>a \\<le> b\\<close>"], ["proof (prove)\nusing this:\n  a \\<noteq> b\n  x = min (a + \\<delta> / 2) b\n  0 < \\<delta>\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. a < x &&& x < a + \\<delta> &&& x \\<le> b", "by simp_all"], ["proof (state)\nthis:\n  a < x\n  x < a + \\<delta>\n  x \\<le> b\n\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow> sign_changes ps a = sign_changes ps b\n 2. a \\<noteq> b \\<Longrightarrow> sign_changes ps a = sign_changes ps b", "from \\<delta>_props \\<open>a < x\\<close> \\<open>x < a+\\<delta>\\<close>"], ["proof (chain)\npicking this:\n  0 < \\<delta>\n  \\<forall>x.\n     a < x \\<and> x < a + \\<delta> \\<longrightarrow>\n     sign_changes ps x = sign_changes ps a\n  a < x\n  x < a + \\<delta>", "have \"sign_changes ps a = sign_changes ps x\""], ["proof (prove)\nusing this:\n  0 < \\<delta>\n  \\<forall>x.\n     a < x \\<and> x < a + \\<delta> \\<longrightarrow>\n     sign_changes ps x = sign_changes ps a\n  a < x\n  x < a + \\<delta>\n\ngoal (1 subgoal):\n 1. sign_changes ps a = sign_changes ps x", "by simp"], ["proof (state)\nthis:\n  sign_changes ps a = sign_changes ps x\n\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow> sign_changes ps a = sign_changes ps b\n 2. a \\<noteq> b \\<Longrightarrow> sign_changes ps a = sign_changes ps b", "also"], ["proof (state)\nthis:\n  sign_changes ps a = sign_changes ps x\n\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow> sign_changes ps a = sign_changes ps b\n 2. a \\<noteq> b \\<Longrightarrow> sign_changes ps a = sign_changes ps b", "from A \\<open>a < x\\<close> \\<open>x \\<le> b\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>x.\n     a < x \\<and> x \\<le> b \\<longrightarrow>\n     sign_changes ps x = sign_changes ps b\n  a < x\n  x \\<le> b", "have \"... = sign_changes ps b\""], ["proof (prove)\nusing this:\n  \\<forall>x.\n     a < x \\<and> x \\<le> b \\<longrightarrow>\n     sign_changes ps x = sign_changes ps b\n  a < x\n  x \\<le> b\n\ngoal (1 subgoal):\n 1. sign_changes ps x = sign_changes ps b", "by blast"], ["proof (state)\nthis:\n  sign_changes ps x = sign_changes ps b\n\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow> sign_changes ps a = sign_changes ps b\n 2. a \\<noteq> b \\<Longrightarrow> sign_changes ps a = sign_changes ps b", "finally"], ["proof (chain)\npicking this:\n  sign_changes ps a = sign_changes ps b", "show ?thesis"], ["proof (prove)\nusing this:\n  sign_changes ps a = sign_changes ps b\n\ngoal (1 subgoal):\n 1. sign_changes ps a = sign_changes ps b", "."], ["proof (state)\nthis:\n  sign_changes ps a = sign_changes ps b\n\ngoal (1 subgoal):\n 1. a = b \\<Longrightarrow> sign_changes ps a = sign_changes ps b", "qed simp"], ["proof (state)\nthis:\n  sign_changes ps a = sign_changes ps b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  int (sign_changes ps a) - int (sign_changes ps b) =\n  int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x \\<le> b \\<and> poly p x = 0 \\<Longrightarrow>\n    int (sign_changes ps a) - int (sign_changes ps b) =\n    int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x>a. x \\<le> b \\<and> poly p x = 0 \\<Longrightarrow>\n    int (sign_changes ps a) - int (sign_changes ps b) =\n    int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})", "case True"], ["proof (state)\nthis:\n  \\<exists>x>a. x \\<le> b \\<and> poly p x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x \\<le> b \\<and> poly p x = 0 \\<Longrightarrow>\n    int (sign_changes ps a) - int (sign_changes ps b) =\n    int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})", "from poly_roots_finite[OF assms(1)]"], ["proof (chain)\npicking this:\n  finite {x. poly p x = 0}", "have fin: \"finite {x. x > a \\<and> x \\<le> b \\<and> poly p x = 0}\""], ["proof (prove)\nusing this:\n  finite {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. finite {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}", "by (force intro: finite_subset)"], ["proof (state)\nthis:\n  finite {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x \\<le> b \\<and> poly p x = 0 \\<Longrightarrow>\n    int (sign_changes ps a) - int (sign_changes ps b) =\n    int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})", "from True"], ["proof (chain)\npicking this:\n  \\<exists>x>a. x \\<le> b \\<and> poly p x = 0", "have \"{x. x > a \\<and> x \\<le> b \\<and> poly p x = 0} \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<exists>x>a. x \\<le> b \\<and> poly p x = 0\n\ngoal (1 subgoal):\n 1. {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x \\<le> b \\<and> poly p x = 0 \\<Longrightarrow>\n    int (sign_changes ps a) - int (sign_changes ps b) =\n    int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})", "with fin"], ["proof (chain)\npicking this:\n  finite {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}\n  {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} \\<noteq> {}", "have card_greater_0:\n              \"card {x. x > a \\<and> x \\<le> b \\<and> poly p x = 0} > 0\""], ["proof (prove)\nusing this:\n  finite {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}\n  {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. 0 < card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}", "by fastforce"], ["proof (state)\nthis:\n  0 < card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x \\<le> b \\<and> poly p x = 0 \\<Longrightarrow>\n    int (sign_changes ps a) - int (sign_changes ps b) =\n    int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})", "define x\\<^sub>2 where \"x\\<^sub>2 = Min {x. x > a \\<and> x \\<le> b \\<and> poly p x = 0}\""], ["proof (state)\nthis:\n  x\\<^sub>2 = Min {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x \\<le> b \\<and> poly p x = 0 \\<Longrightarrow>\n    int (sign_changes ps a) - int (sign_changes ps b) =\n    int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})", "from Min_in[OF fin] and True"], ["proof (chain)\npicking this:\n  {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} \\<noteq>\n  {} \\<Longrightarrow>\n  Min {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}\n  \\<in> {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}\n  \\<exists>x>a. x \\<le> b \\<and> poly p x = 0", "have x\\<^sub>2_props: \"x\\<^sub>2 > a\" \"x\\<^sub>2 \\<le> b\" \"poly p x\\<^sub>2 = 0\""], ["proof (prove)\nusing this:\n  {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} \\<noteq>\n  {} \\<Longrightarrow>\n  Min {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}\n  \\<in> {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}\n  \\<exists>x>a. x \\<le> b \\<and> poly p x = 0\n\ngoal (1 subgoal):\n 1. a < x\\<^sub>2 &&& x\\<^sub>2 \\<le> b &&& poly p x\\<^sub>2 = 0", "unfolding x\\<^sub>2_def"], ["proof (prove)\nusing this:\n  {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} \\<noteq>\n  {} \\<Longrightarrow>\n  Min {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}\n  \\<in> {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}\n  \\<exists>x>a. x \\<le> b \\<and> poly p x = 0\n\ngoal (1 subgoal):\n 1. a < Min {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} &&&\n    Min {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} \\<le> b &&&\n    poly p (Min {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}) = 0", "by blast+"], ["proof (state)\nthis:\n  a < x\\<^sub>2\n  x\\<^sub>2 \\<le> b\n  poly p x\\<^sub>2 = 0\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x \\<le> b \\<and> poly p x = 0 \\<Longrightarrow>\n    int (sign_changes ps a) - int (sign_changes ps b) =\n    int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})", "from Min_le[OF fin] x\\<^sub>2_props"], ["proof (chain)\npicking this:\n  ?x \\<in> {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} \\<Longrightarrow>\n  Min {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} \\<le> ?x\n  a < x\\<^sub>2\n  x\\<^sub>2 \\<le> b\n  poly p x\\<^sub>2 = 0", "have x\\<^sub>2_le: \"\\<And>x'. \\<lbrakk>x' > a; x' \\<le> b; poly p x' = 0\\<rbrakk> \\<Longrightarrow> x\\<^sub>2 \\<le> x'\""], ["proof (prove)\nusing this:\n  ?x \\<in> {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} \\<Longrightarrow>\n  Min {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} \\<le> ?x\n  a < x\\<^sub>2\n  x\\<^sub>2 \\<le> b\n  poly p x\\<^sub>2 = 0\n\ngoal (1 subgoal):\n 1. \\<And>x'.\n       \\<lbrakk>a < x'; x' \\<le> b; poly p x' = 0\\<rbrakk>\n       \\<Longrightarrow> x\\<^sub>2 \\<le> x'", "unfolding x\\<^sub>2_def"], ["proof (prove)\nusing this:\n  ?x \\<in> {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} \\<Longrightarrow>\n  Min {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} \\<le> ?x\n  a < Min {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}\n  Min {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} \\<le> b\n  poly p (Min {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}) = 0\n\ngoal (1 subgoal):\n 1. \\<And>x'.\n       \\<lbrakk>a < x'; x' \\<le> b; poly p x' = 0\\<rbrakk>\n       \\<Longrightarrow> Min {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}\n                         \\<le> x'", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>a < ?x'; ?x' \\<le> b; poly p ?x' = 0\\<rbrakk>\n  \\<Longrightarrow> x\\<^sub>2 \\<le> ?x'\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x \\<le> b \\<and> poly p x = 0 \\<Longrightarrow>\n    int (sign_changes ps a) - int (sign_changes ps b) =\n    int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})", "have left: \"{x. a < x \\<and> x \\<le> x\\<^sub>2 \\<and> poly p x = 0} = {x\\<^sub>2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. a < x \\<and> x \\<le> x\\<^sub>2 \\<and> poly p x = 0} = {x\\<^sub>2}", "using x\\<^sub>2_props x\\<^sub>2_le"], ["proof (prove)\nusing this:\n  a < x\\<^sub>2\n  x\\<^sub>2 \\<le> b\n  poly p x\\<^sub>2 = 0\n  \\<lbrakk>a < ?x'; ?x' \\<le> b; poly p ?x' = 0\\<rbrakk>\n  \\<Longrightarrow> x\\<^sub>2 \\<le> ?x'\n\ngoal (1 subgoal):\n 1. {x. a < x \\<and> x \\<le> x\\<^sub>2 \\<and> poly p x = 0} = {x\\<^sub>2}", "by force"], ["proof (state)\nthis:\n  {x. a < x \\<and> x \\<le> x\\<^sub>2 \\<and> poly p x = 0} = {x\\<^sub>2}\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x \\<le> b \\<and> poly p x = 0 \\<Longrightarrow>\n    int (sign_changes ps a) - int (sign_changes ps b) =\n    int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})", "hence [simp]: \"card {x. a < x \\<and> x \\<le> x\\<^sub>2 \\<and> poly p x = 0} = 1\""], ["proof (prove)\nusing this:\n  {x. a < x \\<and> x \\<le> x\\<^sub>2 \\<and> poly p x = 0} = {x\\<^sub>2}\n\ngoal (1 subgoal):\n 1. card {x. a < x \\<and> x \\<le> x\\<^sub>2 \\<and> poly p x = 0} = 1", "by simp"], ["proof (state)\nthis:\n  card {x. a < x \\<and> x \\<le> x\\<^sub>2 \\<and> poly p x = 0} = 1\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x \\<le> b \\<and> poly p x = 0 \\<Longrightarrow>\n    int (sign_changes ps a) - int (sign_changes ps b) =\n    int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})", "from p_zero[OF \\<open>poly p x\\<^sub>2 = 0\\<close> \\<open>p \\<noteq> 0\\<close>,\n              unfolded eventually_at dist_real_def]"], ["proof (chain)\npicking this:\n  \\<exists>d>0.\n     \\<forall>x\\<in>UNIV.\n        x \\<noteq> x\\<^sub>2 \\<and>\n        \\<bar>x - x\\<^sub>2\\<bar> < d \\<longrightarrow>\n        sign_changes ps x =\n        sign_changes ps x\\<^sub>2 + (if x < x\\<^sub>2 then 1 else 0)", "guess \\<epsilon>"], ["proof (prove)\nusing this:\n  \\<exists>d>0.\n     \\<forall>x\\<in>UNIV.\n        x \\<noteq> x\\<^sub>2 \\<and>\n        \\<bar>x - x\\<^sub>2\\<bar> < d \\<longrightarrow>\n        sign_changes ps x =\n        sign_changes ps x\\<^sub>2 + (if x < x\\<^sub>2 then 1 else 0)\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  0 < \\<epsilon> \\<and>\n  (\\<forall>x\\<in>UNIV.\n      x \\<noteq> x\\<^sub>2 \\<and>\n      \\<bar>x - x\\<^sub>2\\<bar> < \\<epsilon> \\<longrightarrow>\n      sign_changes ps x =\n      sign_changes ps x\\<^sub>2 + (if x < x\\<^sub>2 then 1 else 0))\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x \\<le> b \\<and> poly p x = 0 \\<Longrightarrow>\n    int (sign_changes ps a) - int (sign_changes ps b) =\n    int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})", "hence \\<epsilon>_props: \"\\<epsilon> > 0\"\n              \"\\<forall>x. x \\<noteq> x\\<^sub>2 \\<and> \\<bar>x - x\\<^sub>2\\<bar> < \\<epsilon> \\<longrightarrow>\n                   sign_changes ps x = sign_changes ps x\\<^sub>2 +\n                       (if x < x\\<^sub>2 then 1 else 0)\""], ["proof (prove)\nusing this:\n  0 < \\<epsilon> \\<and>\n  (\\<forall>x\\<in>UNIV.\n      x \\<noteq> x\\<^sub>2 \\<and>\n      \\<bar>x - x\\<^sub>2\\<bar> < \\<epsilon> \\<longrightarrow>\n      sign_changes ps x =\n      sign_changes ps x\\<^sub>2 + (if x < x\\<^sub>2 then 1 else 0))\n\ngoal (1 subgoal):\n 1. 0 < \\<epsilon> &&&\n    \\<forall>x.\n       x \\<noteq> x\\<^sub>2 \\<and>\n       \\<bar>x - x\\<^sub>2\\<bar> < \\<epsilon> \\<longrightarrow>\n       sign_changes ps x =\n       sign_changes ps x\\<^sub>2 + (if x < x\\<^sub>2 then 1 else 0)", "by auto"], ["proof (state)\nthis:\n  0 < \\<epsilon>\n  \\<forall>x.\n     x \\<noteq> x\\<^sub>2 \\<and>\n     \\<bar>x - x\\<^sub>2\\<bar> < \\<epsilon> \\<longrightarrow>\n     sign_changes ps x =\n     sign_changes ps x\\<^sub>2 + (if x < x\\<^sub>2 then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x \\<le> b \\<and> poly p x = 0 \\<Longrightarrow>\n    int (sign_changes ps a) - int (sign_changes ps b) =\n    int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})", "define x\\<^sub>1 where \"x\\<^sub>1 = max (x\\<^sub>2 - \\<epsilon> / 2) a\""], ["proof (state)\nthis:\n  x\\<^sub>1 = max (x\\<^sub>2 - \\<epsilon> / 2) a\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x \\<le> b \\<and> poly p x = 0 \\<Longrightarrow>\n    int (sign_changes ps a) - int (sign_changes ps b) =\n    int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})", "have \"\\<bar>x\\<^sub>1 - x\\<^sub>2\\<bar> < \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>x\\<^sub>1 - x\\<^sub>2\\<bar> < \\<epsilon>", "using \\<open>\\<epsilon> > 0\\<close> x\\<^sub>2_props"], ["proof (prove)\nusing this:\n  0 < \\<epsilon>\n  a < x\\<^sub>2\n  x\\<^sub>2 \\<le> b\n  poly p x\\<^sub>2 = 0\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<^sub>1 - x\\<^sub>2\\<bar> < \\<epsilon>", "by (simp add: x\\<^sub>1_def)"], ["proof (state)\nthis:\n  \\<bar>x\\<^sub>1 - x\\<^sub>2\\<bar> < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x \\<le> b \\<and> poly p x = 0 \\<Longrightarrow>\n    int (sign_changes ps a) - int (sign_changes ps b) =\n    int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})", "hence \"sign_changes ps x\\<^sub>1 =\n              (if x\\<^sub>1 < x\\<^sub>2 then sign_changes ps x\\<^sub>2 + 1 else sign_changes ps x\\<^sub>2)\""], ["proof (prove)\nusing this:\n  \\<bar>x\\<^sub>1 - x\\<^sub>2\\<bar> < \\<epsilon>\n\ngoal (1 subgoal):\n 1. sign_changes ps x\\<^sub>1 =\n    (if x\\<^sub>1 < x\\<^sub>2 then sign_changes ps x\\<^sub>2 + 1\n     else sign_changes ps x\\<^sub>2)", "using \\<epsilon>_props(2)"], ["proof (prove)\nusing this:\n  \\<bar>x\\<^sub>1 - x\\<^sub>2\\<bar> < \\<epsilon>\n  \\<forall>x.\n     x \\<noteq> x\\<^sub>2 \\<and>\n     \\<bar>x - x\\<^sub>2\\<bar> < \\<epsilon> \\<longrightarrow>\n     sign_changes ps x =\n     sign_changes ps x\\<^sub>2 + (if x < x\\<^sub>2 then 1 else 0)\n\ngoal (1 subgoal):\n 1. sign_changes ps x\\<^sub>1 =\n    (if x\\<^sub>1 < x\\<^sub>2 then sign_changes ps x\\<^sub>2 + 1\n     else sign_changes ps x\\<^sub>2)", "by (cases \"x\\<^sub>1 = x\\<^sub>2\", auto)"], ["proof (state)\nthis:\n  sign_changes ps x\\<^sub>1 =\n  (if x\\<^sub>1 < x\\<^sub>2 then sign_changes ps x\\<^sub>2 + 1\n   else sign_changes ps x\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x \\<le> b \\<and> poly p x = 0 \\<Longrightarrow>\n    int (sign_changes ps a) - int (sign_changes ps b) =\n    int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})", "hence \"sign_changes ps x\\<^sub>1 - sign_changes ps x\\<^sub>2 = 1\""], ["proof (prove)\nusing this:\n  sign_changes ps x\\<^sub>1 =\n  (if x\\<^sub>1 < x\\<^sub>2 then sign_changes ps x\\<^sub>2 + 1\n   else sign_changes ps x\\<^sub>2)\n\ngoal (1 subgoal):\n 1. sign_changes ps x\\<^sub>1 - sign_changes ps x\\<^sub>2 = 1", "unfolding x\\<^sub>1_def"], ["proof (prove)\nusing this:\n  sign_changes ps (max (x\\<^sub>2 - \\<epsilon> / 2) a) =\n  (if max (x\\<^sub>2 - \\<epsilon> / 2) a < x\\<^sub>2\n   then sign_changes ps x\\<^sub>2 + 1 else sign_changes ps x\\<^sub>2)\n\ngoal (1 subgoal):\n 1. sign_changes ps (max (x\\<^sub>2 - \\<epsilon> / 2) a) -\n    sign_changes ps x\\<^sub>2 =\n    1", "using x\\<^sub>2_props \\<open>\\<epsilon> > 0\\<close>"], ["proof (prove)\nusing this:\n  sign_changes ps (max (x\\<^sub>2 - \\<epsilon> / 2) a) =\n  (if max (x\\<^sub>2 - \\<epsilon> / 2) a < x\\<^sub>2\n   then sign_changes ps x\\<^sub>2 + 1 else sign_changes ps x\\<^sub>2)\n  a < x\\<^sub>2\n  x\\<^sub>2 \\<le> b\n  poly p x\\<^sub>2 = 0\n  0 < \\<epsilon>\n\ngoal (1 subgoal):\n 1. sign_changes ps (max (x\\<^sub>2 - \\<epsilon> / 2) a) -\n    sign_changes ps x\\<^sub>2 =\n    1", "by simp"], ["proof (state)\nthis:\n  sign_changes ps x\\<^sub>1 - sign_changes ps x\\<^sub>2 = 1\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x \\<le> b \\<and> poly p x = 0 \\<Longrightarrow>\n    int (sign_changes ps a) - int (sign_changes ps b) =\n    int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})", "also"], ["proof (state)\nthis:\n  sign_changes ps x\\<^sub>1 - sign_changes ps x\\<^sub>2 = 1\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x \\<le> b \\<and> poly p x = 0 \\<Longrightarrow>\n    int (sign_changes ps a) - int (sign_changes ps b) =\n    int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})", "have \"x\\<^sub>2 \\<notin> {x. a < x \\<and> x \\<le> x\\<^sub>1 \\<and> poly p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sub>2\n    \\<notin> {x. a < x \\<and> x \\<le> x\\<^sub>1 \\<and> poly p x = 0}", "unfolding x\\<^sub>1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sub>2\n    \\<notin> {x. a < x \\<and>\n                 x \\<le> max (x\\<^sub>2 - \\<epsilon> / 2) a \\<and>\n                 poly p x = 0}", "using \\<open>\\<epsilon> > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < \\<epsilon>\n\ngoal (1 subgoal):\n 1. x\\<^sub>2\n    \\<notin> {x. a < x \\<and>\n                 x \\<le> max (x\\<^sub>2 - \\<epsilon> / 2) a \\<and>\n                 poly p x = 0}", "by force"], ["proof (state)\nthis:\n  x\\<^sub>2 \\<notin> {x. a < x \\<and> x \\<le> x\\<^sub>1 \\<and> poly p x = 0}\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x \\<le> b \\<and> poly p x = 0 \\<Longrightarrow>\n    int (sign_changes ps a) - int (sign_changes ps b) =\n    int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})", "with left"], ["proof (chain)\npicking this:\n  {x. a < x \\<and> x \\<le> x\\<^sub>2 \\<and> poly p x = 0} = {x\\<^sub>2}\n  x\\<^sub>2 \\<notin> {x. a < x \\<and> x \\<le> x\\<^sub>1 \\<and> poly p x = 0}", "have \"{x. a < x \\<and> x \\<le> x\\<^sub>1 \\<and> poly p x = 0} = {}\""], ["proof (prove)\nusing this:\n  {x. a < x \\<and> x \\<le> x\\<^sub>2 \\<and> poly p x = 0} = {x\\<^sub>2}\n  x\\<^sub>2 \\<notin> {x. a < x \\<and> x \\<le> x\\<^sub>1 \\<and> poly p x = 0}\n\ngoal (1 subgoal):\n 1. {x. a < x \\<and> x \\<le> x\\<^sub>1 \\<and> poly p x = 0} = {}", "by force"], ["proof (state)\nthis:\n  {x. a < x \\<and> x \\<le> x\\<^sub>1 \\<and> poly p x = 0} = {}\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x \\<le> b \\<and> poly p x = 0 \\<Longrightarrow>\n    int (sign_changes ps a) - int (sign_changes ps b) =\n    int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})", "with less(1)[of a x\\<^sub>1]"], ["proof (chain)\npicking this:\n  \\<lbrakk>card {x. a < x \\<and> x \\<le> x\\<^sub>1 \\<and> poly p x = 0}\n           < card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0};\n   a \\<le> x\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> int (sign_changes ps a) -\n                    int (sign_changes ps x\\<^sub>1) =\n                    int (card\n                          {x. a < x \\<and>\n                              x \\<le> x\\<^sub>1 \\<and> poly p x = 0})\n  {x. a < x \\<and> x \\<le> x\\<^sub>1 \\<and> poly p x = 0} = {}", "have \"sign_changes ps x\\<^sub>1 = sign_changes ps a\""], ["proof (prove)\nusing this:\n  \\<lbrakk>card {x. a < x \\<and> x \\<le> x\\<^sub>1 \\<and> poly p x = 0}\n           < card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0};\n   a \\<le> x\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> int (sign_changes ps a) -\n                    int (sign_changes ps x\\<^sub>1) =\n                    int (card\n                          {x. a < x \\<and>\n                              x \\<le> x\\<^sub>1 \\<and> poly p x = 0})\n  {x. a < x \\<and> x \\<le> x\\<^sub>1 \\<and> poly p x = 0} = {}\n\ngoal (1 subgoal):\n 1. sign_changes ps x\\<^sub>1 = sign_changes ps a", "unfolding x\\<^sub>1_def \\<open>\\<epsilon> > 0\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>card\n            {x. a < x \\<and>\n                x \\<le> max (x\\<^sub>2 - \\<epsilon> / 2) a \\<and>\n                poly p x = 0}\n           < card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0};\n   a \\<le> max (x\\<^sub>2 - \\<epsilon> / 2) a\\<rbrakk>\n  \\<Longrightarrow> int (sign_changes ps a) -\n                    int (sign_changes ps\n                          (max (x\\<^sub>2 - \\<epsilon> / 2) a)) =\n                    int (card\n                          {x. a < x \\<and>\n                              x \\<le> max (x\\<^sub>2 - \\<epsilon> / 2)\n a \\<and>\n                              poly p x = 0})\n  {x. a < x \\<and>\n      x \\<le> max (x\\<^sub>2 - \\<epsilon> / 2) a \\<and> poly p x = 0} =\n  {}\n\ngoal (1 subgoal):\n 1. sign_changes ps (max (x\\<^sub>2 - \\<epsilon> / 2) a) = sign_changes ps a", "by (force simp: card_greater_0)"], ["proof (state)\nthis:\n  sign_changes ps x\\<^sub>1 = sign_changes ps a\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x \\<le> b \\<and> poly p x = 0 \\<Longrightarrow>\n    int (sign_changes ps a) - int (sign_changes ps b) =\n    int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})", "finally"], ["proof (chain)\npicking this:\n  sign_changes ps a - sign_changes ps x\\<^sub>2 = 1", "have signs_left:\n              \"sign_changes ps a - int (sign_changes ps x\\<^sub>2) = 1\""], ["proof (prove)\nusing this:\n  sign_changes ps a - sign_changes ps x\\<^sub>2 = 1\n\ngoal (1 subgoal):\n 1. int (sign_changes ps a) - int (sign_changes ps x\\<^sub>2) = 1", "by simp"], ["proof (state)\nthis:\n  int (sign_changes ps a) - int (sign_changes ps x\\<^sub>2) = 1\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x \\<le> b \\<and> poly p x = 0 \\<Longrightarrow>\n    int (sign_changes ps a) - int (sign_changes ps b) =\n    int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})", "have \"{x. x > a \\<and> x \\<le> b \\<and> poly p x = 0} =\n                {x. a < x \\<and> x \\<le> x\\<^sub>2 \\<and> poly p x = 0} \\<union>\n                {x. x\\<^sub>2 < x \\<and> x \\<le> b \\<and> poly p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} =\n    {x. a < x \\<and> x \\<le> x\\<^sub>2 \\<and> poly p x = 0} \\<union>\n    {x. x\\<^sub>2 < x \\<and> x \\<le> b \\<and> poly p x = 0}", "using x\\<^sub>2_props"], ["proof (prove)\nusing this:\n  a < x\\<^sub>2\n  x\\<^sub>2 \\<le> b\n  poly p x\\<^sub>2 = 0\n\ngoal (1 subgoal):\n 1. {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} =\n    {x. a < x \\<and> x \\<le> x\\<^sub>2 \\<and> poly p x = 0} \\<union>\n    {x. x\\<^sub>2 < x \\<and> x \\<le> b \\<and> poly p x = 0}", "by auto"], ["proof (state)\nthis:\n  {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} =\n  {x. a < x \\<and> x \\<le> x\\<^sub>2 \\<and> poly p x = 0} \\<union>\n  {x. x\\<^sub>2 < x \\<and> x \\<le> b \\<and> poly p x = 0}\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x \\<le> b \\<and> poly p x = 0 \\<Longrightarrow>\n    int (sign_changes ps a) - int (sign_changes ps b) =\n    int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})", "also"], ["proof (state)\nthis:\n  {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} =\n  {x. a < x \\<and> x \\<le> x\\<^sub>2 \\<and> poly p x = 0} \\<union>\n  {x. x\\<^sub>2 < x \\<and> x \\<le> b \\<and> poly p x = 0}\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x \\<le> b \\<and> poly p x = 0 \\<Longrightarrow>\n    int (sign_changes ps a) - int (sign_changes ps b) =\n    int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})", "note left"], ["proof (state)\nthis:\n  {x. a < x \\<and> x \\<le> x\\<^sub>2 \\<and> poly p x = 0} = {x\\<^sub>2}\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x \\<le> b \\<and> poly p x = 0 \\<Longrightarrow>\n    int (sign_changes ps a) - int (sign_changes ps b) =\n    int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})", "finally"], ["proof (chain)\npicking this:\n  {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} =\n  {x\\<^sub>2} \\<union>\n  {x. x\\<^sub>2 < x \\<and> x \\<le> b \\<and> poly p x = 0}", "have A: \"card {x. x\\<^sub>2 < x \\<and> x \\<le> b \\<and> poly p x = 0} + 1 =\n              card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}\""], ["proof (prove)\nusing this:\n  {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} =\n  {x\\<^sub>2} \\<union>\n  {x. x\\<^sub>2 < x \\<and> x \\<le> b \\<and> poly p x = 0}\n\ngoal (1 subgoal):\n 1. card {x. x\\<^sub>2 < x \\<and> x \\<le> b \\<and> poly p x = 0} + 1 =\n    card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}", "using fin"], ["proof (prove)\nusing this:\n  {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} =\n  {x\\<^sub>2} \\<union>\n  {x. x\\<^sub>2 < x \\<and> x \\<le> b \\<and> poly p x = 0}\n  finite {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}\n\ngoal (1 subgoal):\n 1. card {x. x\\<^sub>2 < x \\<and> x \\<le> b \\<and> poly p x = 0} + 1 =\n    card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}", "by simp"], ["proof (state)\nthis:\n  card {x. x\\<^sub>2 < x \\<and> x \\<le> b \\<and> poly p x = 0} + 1 =\n  card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x \\<le> b \\<and> poly p x = 0 \\<Longrightarrow>\n    int (sign_changes ps a) - int (sign_changes ps b) =\n    int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})", "hence \"card {x. x\\<^sub>2 < x \\<and> x \\<le> b \\<and> poly p x = 0} <\n                 card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}\""], ["proof (prove)\nusing this:\n  card {x. x\\<^sub>2 < x \\<and> x \\<le> b \\<and> poly p x = 0} + 1 =\n  card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}\n\ngoal (1 subgoal):\n 1. card {x. x\\<^sub>2 < x \\<and> x \\<le> b \\<and> poly p x = 0}\n    < card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}", "by simp"], ["proof (state)\nthis:\n  card {x. x\\<^sub>2 < x \\<and> x \\<le> b \\<and> poly p x = 0}\n  < card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x \\<le> b \\<and> poly p x = 0 \\<Longrightarrow>\n    int (sign_changes ps a) - int (sign_changes ps b) =\n    int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})", "from less(1)[OF this x\\<^sub>2_props(2)] and A"], ["proof (chain)\npicking this:\n  int (sign_changes ps x\\<^sub>2) - int (sign_changes ps b) =\n  int (card {x. x\\<^sub>2 < x \\<and> x \\<le> b \\<and> poly p x = 0})\n  card {x. x\\<^sub>2 < x \\<and> x \\<le> b \\<and> poly p x = 0} + 1 =\n  card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}", "have signs_right: \"sign_changes ps x\\<^sub>2 - int (sign_changes ps b) + 1 =\n                  card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}\""], ["proof (prove)\nusing this:\n  int (sign_changes ps x\\<^sub>2) - int (sign_changes ps b) =\n  int (card {x. x\\<^sub>2 < x \\<and> x \\<le> b \\<and> poly p x = 0})\n  card {x. x\\<^sub>2 < x \\<and> x \\<le> b \\<and> poly p x = 0} + 1 =\n  card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}\n\ngoal (1 subgoal):\n 1. int (sign_changes ps x\\<^sub>2) - int (sign_changes ps b) + 1 =\n    int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})", "by simp"], ["proof (state)\nthis:\n  int (sign_changes ps x\\<^sub>2) - int (sign_changes ps b) + 1 =\n  int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x \\<le> b \\<and> poly p x = 0 \\<Longrightarrow>\n    int (sign_changes ps a) - int (sign_changes ps b) =\n    int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})", "from signs_left and signs_right"], ["proof (chain)\npicking this:\n  int (sign_changes ps a) - int (sign_changes ps x\\<^sub>2) = 1\n  int (sign_changes ps x\\<^sub>2) - int (sign_changes ps b) + 1 =\n  int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})", "show ?thesis"], ["proof (prove)\nusing this:\n  int (sign_changes ps a) - int (sign_changes ps x\\<^sub>2) = 1\n  int (sign_changes ps x\\<^sub>2) - int (sign_changes ps b) + 1 =\n  int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})\n\ngoal (1 subgoal):\n 1. int (sign_changes ps a) - int (sign_changes ps b) =\n    int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})", "by simp"], ["proof (state)\nthis:\n  int (sign_changes ps a) - int (sign_changes ps b) =\n  int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  int (sign_changes ps a) - int (sign_changes ps b) =\n  int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  int (sign_changes ps a) - int (sign_changes ps b) =\n  int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})\n\ngoal (1 subgoal):\n 1. sign_changes ps a - sign_changes ps b =\n    card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}", "thus ?thesis"], ["proof (prove)\nusing this:\n  int (sign_changes ps a) - int (sign_changes ps b) =\n  int (card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0})\n\ngoal (1 subgoal):\n 1. sign_changes ps a - sign_changes ps b =\n    card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}", "by simp"], ["proof (state)\nthis:\n  sign_changes ps a - sign_changes ps b =\n  card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  By applying this result to a sufficiently large upper bound, we can effectively count\n  the number of roots ``between $a$ and infinity'', i.\\,e. the roots greater than $a$:\n\\<close>"], ["", "lemma (in sturm_seq) count_roots_above:\n  assumes \"p \\<noteq> 0\"\n  shows \"sign_changes ps a - sign_changes_inf ps =\n             card {x. x > a \\<and> poly p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes ps a - sign_changes_inf ps =\n    card {x. a < x \\<and> poly p x = 0}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. sign_changes ps a - sign_changes_inf ps =\n    card {x. a < x \\<and> poly p x = 0}", "have \"p \\<in> set ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> set ps", "using hd_in_set[OF ps_not_Nil]"], ["proof (prove)\nusing this:\n  hd ps \\<in> set ps\n\ngoal (1 subgoal):\n 1. p \\<in> set ps", "by simp"], ["proof (state)\nthis:\n  p \\<in> set ps\n\ngoal (1 subgoal):\n 1. sign_changes ps a - sign_changes_inf ps =\n    card {x. a < x \\<and> poly p x = 0}", "have \"finite (set ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set ps)", "by simp"], ["proof (state)\nthis:\n  finite (set ps)\n\ngoal (1 subgoal):\n 1. sign_changes ps a - sign_changes_inf ps =\n    card {x. a < x \\<and> poly p x = 0}", "from polys_inf_sign_thresholds[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>l u.\n      \\<lbrakk>l \\<le> u;\n       \\<And>p.\n          \\<lbrakk>p \\<in> set ps; p \\<noteq> 0\\<rbrakk>\n          \\<Longrightarrow> {x. l < x \\<and>\n                                x \\<le> u \\<and> poly p x = 0} =\n                            {x. poly p x = 0};\n       \\<And>p x.\n          \\<lbrakk>p \\<in> set ps; u \\<le> x\\<rbrakk>\n          \\<Longrightarrow> sgn (poly p x) = poly_inf p;\n       \\<And>p x.\n          \\<lbrakk>p \\<in> set ps; x \\<le> l\\<rbrakk>\n          \\<Longrightarrow> sgn (poly p x) = poly_neg_inf p\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "guess l u"], ["proof (prove)\nusing this:\n  (\\<And>l u.\n      \\<lbrakk>l \\<le> u;\n       \\<And>p.\n          \\<lbrakk>p \\<in> set ps; p \\<noteq> 0\\<rbrakk>\n          \\<Longrightarrow> {x. l < x \\<and>\n                                x \\<le> u \\<and> poly p x = 0} =\n                            {x. poly p x = 0};\n       \\<And>p x.\n          \\<lbrakk>p \\<in> set ps; u \\<le> x\\<rbrakk>\n          \\<Longrightarrow> sgn (poly p x) = poly_inf p;\n       \\<And>p x.\n          \\<lbrakk>p \\<in> set ps; x \\<le> l\\<rbrakk>\n          \\<Longrightarrow> sgn (poly p x) = poly_neg_inf p\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. thesis", "."], ["proof (state)\nthis:\n  l \\<le> u\n  \\<lbrakk>?p \\<in> set ps; ?p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> {x. l < x \\<and> x \\<le> u \\<and> poly ?p x = 0} =\n                    {x. poly ?p x = 0}\n  \\<lbrakk>?p \\<in> set ps; u \\<le> ?x\\<rbrakk>\n  \\<Longrightarrow> sgn (poly ?p ?x) = poly_inf ?p\n  \\<lbrakk>?p \\<in> set ps; ?x \\<le> l\\<rbrakk>\n  \\<Longrightarrow> sgn (poly ?p ?x) = poly_neg_inf ?p\n\ngoal (1 subgoal):\n 1. sign_changes ps a - sign_changes_inf ps =\n    card {x. a < x \\<and> poly p x = 0}", "note lu_props = this"], ["proof (state)\nthis:\n  l \\<le> u\n  \\<lbrakk>?p \\<in> set ps; ?p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> {x. l < x \\<and> x \\<le> u \\<and> poly ?p x = 0} =\n                    {x. poly ?p x = 0}\n  \\<lbrakk>?p \\<in> set ps; u \\<le> ?x\\<rbrakk>\n  \\<Longrightarrow> sgn (poly ?p ?x) = poly_inf ?p\n  \\<lbrakk>?p \\<in> set ps; ?x \\<le> l\\<rbrakk>\n  \\<Longrightarrow> sgn (poly ?p ?x) = poly_neg_inf ?p\n\ngoal (1 subgoal):\n 1. sign_changes ps a - sign_changes_inf ps =\n    card {x. a < x \\<and> poly p x = 0}", "let ?u = \"max a u\""], ["proof (state)\ngoal (1 subgoal):\n 1. sign_changes ps a - sign_changes_inf ps =\n    card {x. a < x \\<and> poly p x = 0}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. sign_changes ps a - sign_changes_inf ps =\n    card {x. a < x \\<and> poly p x = 0}", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. sign_changes ps a - sign_changes_inf ps =\n    card {x. a < x \\<and> poly p x = 0}", "assume \"poly p x = 0\""], ["proof (state)\nthis:\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. sign_changes ps a - sign_changes_inf ps =\n    card {x. a < x \\<and> poly p x = 0}", "hence \"x \\<le> ?u\""], ["proof (prove)\nusing this:\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. x \\<le> max a u", "using lu_props(3)[OF \\<open>p \\<in> set ps\\<close>, of x] \\<open>p \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  poly p x = 0\n  u \\<le> x \\<Longrightarrow> sgn (poly p x) = poly_inf p\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<le> max a u", "by (cases \"u \\<le> x\", auto simp: sgn_zero_iff)"], ["proof (state)\nthis:\n  x \\<le> max a u\n\ngoal (1 subgoal):\n 1. sign_changes ps a - sign_changes_inf ps =\n    card {x. a < x \\<and> poly p x = 0}", "}"], ["proof (state)\nthis:\n  poly p ?x2 = 0 \\<Longrightarrow> ?x2 \\<le> max a u\n\ngoal (1 subgoal):\n 1. sign_changes ps a - sign_changes_inf ps =\n    card {x. a < x \\<and> poly p x = 0}", "note [simp] = this"], ["proof (state)\nthis:\n  poly p ?x2 = 0 \\<Longrightarrow> ?x2 \\<le> max a u\n\ngoal (1 subgoal):\n 1. sign_changes ps a - sign_changes_inf ps =\n    card {x. a < x \\<and> poly p x = 0}", "from lu_props"], ["proof (chain)\npicking this:\n  l \\<le> u\n  \\<lbrakk>?p \\<in> set ps; ?p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> {x. l < x \\<and> x \\<le> u \\<and> poly ?p x = 0} =\n                    {x. poly ?p x = 0}\n  \\<lbrakk>?p \\<in> set ps; u \\<le> ?x\\<rbrakk>\n  \\<Longrightarrow> sgn (poly ?p ?x) = poly_inf ?p\n  \\<lbrakk>?p \\<in> set ps; ?x \\<le> l\\<rbrakk>\n  \\<Longrightarrow> sgn (poly ?p ?x) = poly_neg_inf ?p", "have \"map (\\<lambda>p. sgn (poly p ?u)) ps = map poly_inf ps\""], ["proof (prove)\nusing this:\n  l \\<le> u\n  \\<lbrakk>?p \\<in> set ps; ?p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> {x. l < x \\<and> x \\<le> u \\<and> poly ?p x = 0} =\n                    {x. poly ?p x = 0}\n  \\<lbrakk>?p \\<in> set ps; u \\<le> ?x\\<rbrakk>\n  \\<Longrightarrow> sgn (poly ?p ?x) = poly_inf ?p\n  \\<lbrakk>?p \\<in> set ps; ?x \\<le> l\\<rbrakk>\n  \\<Longrightarrow> sgn (poly ?p ?x) = poly_neg_inf ?p\n\ngoal (1 subgoal):\n 1. map (\\<lambda>p. sgn (poly p (max a u))) ps = map poly_inf ps", "by simp"], ["proof (state)\nthis:\n  map (\\<lambda>p. sgn (poly p (max a u))) ps = map poly_inf ps\n\ngoal (1 subgoal):\n 1. sign_changes ps a - sign_changes_inf ps =\n    card {x. a < x \\<and> poly p x = 0}", "hence \"sign_changes ps a - sign_changes_inf ps =\n             sign_changes ps a - sign_changes ps ?u\""], ["proof (prove)\nusing this:\n  map (\\<lambda>p. sgn (poly p (max a u))) ps = map poly_inf ps\n\ngoal (1 subgoal):\n 1. sign_changes ps a - sign_changes_inf ps =\n    sign_changes ps a - sign_changes ps (max a u)", "by (simp_all only: sign_changes_def sign_changes_inf_def)"], ["proof (state)\nthis:\n  sign_changes ps a - sign_changes_inf ps =\n  sign_changes ps a - sign_changes ps (max a u)\n\ngoal (1 subgoal):\n 1. sign_changes ps a - sign_changes_inf ps =\n    card {x. a < x \\<and> poly p x = 0}", "also"], ["proof (state)\nthis:\n  sign_changes ps a - sign_changes_inf ps =\n  sign_changes ps a - sign_changes ps (max a u)\n\ngoal (1 subgoal):\n 1. sign_changes ps a - sign_changes_inf ps =\n    card {x. a < x \\<and> poly p x = 0}", "from count_roots_between[OF assms] lu_props"], ["proof (chain)\npicking this:\n  ?a \\<le> ?b \\<Longrightarrow>\n  sign_changes ps ?a - sign_changes ps ?b =\n  card {x. ?a < x \\<and> x \\<le> ?b \\<and> poly p x = 0}\n  l \\<le> u\n  \\<lbrakk>?p \\<in> set ps; ?p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> {x. l < x \\<and> x \\<le> u \\<and> poly ?p x = 0} =\n                    {x. poly ?p x = 0}\n  \\<lbrakk>?p \\<in> set ps; u \\<le> ?x\\<rbrakk>\n  \\<Longrightarrow> sgn (poly ?p ?x) = poly_inf ?p\n  \\<lbrakk>?p \\<in> set ps; ?x \\<le> l\\<rbrakk>\n  \\<Longrightarrow> sgn (poly ?p ?x) = poly_neg_inf ?p", "have \"... =  card {x. a < x \\<and> x \\<le> ?u \\<and> poly p x = 0}\""], ["proof (prove)\nusing this:\n  ?a \\<le> ?b \\<Longrightarrow>\n  sign_changes ps ?a - sign_changes ps ?b =\n  card {x. ?a < x \\<and> x \\<le> ?b \\<and> poly p x = 0}\n  l \\<le> u\n  \\<lbrakk>?p \\<in> set ps; ?p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> {x. l < x \\<and> x \\<le> u \\<and> poly ?p x = 0} =\n                    {x. poly ?p x = 0}\n  \\<lbrakk>?p \\<in> set ps; u \\<le> ?x\\<rbrakk>\n  \\<Longrightarrow> sgn (poly ?p ?x) = poly_inf ?p\n  \\<lbrakk>?p \\<in> set ps; ?x \\<le> l\\<rbrakk>\n  \\<Longrightarrow> sgn (poly ?p ?x) = poly_neg_inf ?p\n\ngoal (1 subgoal):\n 1. sign_changes ps a - sign_changes ps (max a u) =\n    card {x. a < x \\<and> x \\<le> max a u \\<and> poly p x = 0}", "by simp"], ["proof (state)\nthis:\n  sign_changes ps a - sign_changes ps (max a u) =\n  card {x. a < x \\<and> x \\<le> max a u \\<and> poly p x = 0}\n\ngoal (1 subgoal):\n 1. sign_changes ps a - sign_changes_inf ps =\n    card {x. a < x \\<and> poly p x = 0}", "also"], ["proof (state)\nthis:\n  sign_changes ps a - sign_changes ps (max a u) =\n  card {x. a < x \\<and> x \\<le> max a u \\<and> poly p x = 0}\n\ngoal (1 subgoal):\n 1. sign_changes ps a - sign_changes_inf ps =\n    card {x. a < x \\<and> poly p x = 0}", "have \"{x. a < x \\<and> x \\<le> ?u \\<and> poly p x = 0} = {x. a < x \\<and> poly p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. a < x \\<and> x \\<le> max a u \\<and> poly p x = 0} =\n    {x. a < x \\<and> poly p x = 0}", "using lu_props"], ["proof (prove)\nusing this:\n  l \\<le> u\n  \\<lbrakk>?p \\<in> set ps; ?p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> {x. l < x \\<and> x \\<le> u \\<and> poly ?p x = 0} =\n                    {x. poly ?p x = 0}\n  \\<lbrakk>?p \\<in> set ps; u \\<le> ?x\\<rbrakk>\n  \\<Longrightarrow> sgn (poly ?p ?x) = poly_inf ?p\n  \\<lbrakk>?p \\<in> set ps; ?x \\<le> l\\<rbrakk>\n  \\<Longrightarrow> sgn (poly ?p ?x) = poly_neg_inf ?p\n\ngoal (1 subgoal):\n 1. {x. a < x \\<and> x \\<le> max a u \\<and> poly p x = 0} =\n    {x. a < x \\<and> poly p x = 0}", "by auto"], ["proof (state)\nthis:\n  {x. a < x \\<and> x \\<le> max a u \\<and> poly p x = 0} =\n  {x. a < x \\<and> poly p x = 0}\n\ngoal (1 subgoal):\n 1. sign_changes ps a - sign_changes_inf ps =\n    card {x. a < x \\<and> poly p x = 0}", "finally"], ["proof (chain)\npicking this:\n  sign_changes ps a - sign_changes_inf ps =\n  card {x. a < x \\<and> poly p x = 0}", "show ?thesis"], ["proof (prove)\nusing this:\n  sign_changes ps a - sign_changes_inf ps =\n  card {x. a < x \\<and> poly p x = 0}\n\ngoal (1 subgoal):\n 1. sign_changes ps a - sign_changes_inf ps =\n    card {x. a < x \\<and> poly p x = 0}", "."], ["proof (state)\nthis:\n  sign_changes ps a - sign_changes_inf ps =\n  card {x. a < x \\<and> poly p x = 0}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The same works analogously for the number of roots below $a$ and the\n  total number of roots.\n\\<close>"], ["", "lemma (in sturm_seq) count_roots_below:\n  assumes \"p \\<noteq> 0\"\n  shows \"sign_changes_neg_inf ps - sign_changes ps a =\n             card {x. x \\<le> a \\<and> poly p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes_neg_inf ps - sign_changes ps a =\n    card {x. x \\<le> a \\<and> poly p x = 0}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. sign_changes_neg_inf ps - sign_changes ps a =\n    card {x. x \\<le> a \\<and> poly p x = 0}", "have \"p \\<in> set ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> set ps", "using hd_in_set[OF ps_not_Nil]"], ["proof (prove)\nusing this:\n  hd ps \\<in> set ps\n\ngoal (1 subgoal):\n 1. p \\<in> set ps", "by simp"], ["proof (state)\nthis:\n  p \\<in> set ps\n\ngoal (1 subgoal):\n 1. sign_changes_neg_inf ps - sign_changes ps a =\n    card {x. x \\<le> a \\<and> poly p x = 0}", "have \"finite (set ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set ps)", "by simp"], ["proof (state)\nthis:\n  finite (set ps)\n\ngoal (1 subgoal):\n 1. sign_changes_neg_inf ps - sign_changes ps a =\n    card {x. x \\<le> a \\<and> poly p x = 0}", "from polys_inf_sign_thresholds[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>l u.\n      \\<lbrakk>l \\<le> u;\n       \\<And>p.\n          \\<lbrakk>p \\<in> set ps; p \\<noteq> 0\\<rbrakk>\n          \\<Longrightarrow> {x. l < x \\<and>\n                                x \\<le> u \\<and> poly p x = 0} =\n                            {x. poly p x = 0};\n       \\<And>p x.\n          \\<lbrakk>p \\<in> set ps; u \\<le> x\\<rbrakk>\n          \\<Longrightarrow> sgn (poly p x) = poly_inf p;\n       \\<And>p x.\n          \\<lbrakk>p \\<in> set ps; x \\<le> l\\<rbrakk>\n          \\<Longrightarrow> sgn (poly p x) = poly_neg_inf p\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "guess l u"], ["proof (prove)\nusing this:\n  (\\<And>l u.\n      \\<lbrakk>l \\<le> u;\n       \\<And>p.\n          \\<lbrakk>p \\<in> set ps; p \\<noteq> 0\\<rbrakk>\n          \\<Longrightarrow> {x. l < x \\<and>\n                                x \\<le> u \\<and> poly p x = 0} =\n                            {x. poly p x = 0};\n       \\<And>p x.\n          \\<lbrakk>p \\<in> set ps; u \\<le> x\\<rbrakk>\n          \\<Longrightarrow> sgn (poly p x) = poly_inf p;\n       \\<And>p x.\n          \\<lbrakk>p \\<in> set ps; x \\<le> l\\<rbrakk>\n          \\<Longrightarrow> sgn (poly p x) = poly_neg_inf p\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. thesis", "."], ["proof (state)\nthis:\n  l \\<le> u\n  \\<lbrakk>?p \\<in> set ps; ?p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> {x. l < x \\<and> x \\<le> u \\<and> poly ?p x = 0} =\n                    {x. poly ?p x = 0}\n  \\<lbrakk>?p \\<in> set ps; u \\<le> ?x\\<rbrakk>\n  \\<Longrightarrow> sgn (poly ?p ?x) = poly_inf ?p\n  \\<lbrakk>?p \\<in> set ps; ?x \\<le> l\\<rbrakk>\n  \\<Longrightarrow> sgn (poly ?p ?x) = poly_neg_inf ?p\n\ngoal (1 subgoal):\n 1. sign_changes_neg_inf ps - sign_changes ps a =\n    card {x. x \\<le> a \\<and> poly p x = 0}", "note lu_props = this"], ["proof (state)\nthis:\n  l \\<le> u\n  \\<lbrakk>?p \\<in> set ps; ?p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> {x. l < x \\<and> x \\<le> u \\<and> poly ?p x = 0} =\n                    {x. poly ?p x = 0}\n  \\<lbrakk>?p \\<in> set ps; u \\<le> ?x\\<rbrakk>\n  \\<Longrightarrow> sgn (poly ?p ?x) = poly_inf ?p\n  \\<lbrakk>?p \\<in> set ps; ?x \\<le> l\\<rbrakk>\n  \\<Longrightarrow> sgn (poly ?p ?x) = poly_neg_inf ?p\n\ngoal (1 subgoal):\n 1. sign_changes_neg_inf ps - sign_changes ps a =\n    card {x. x \\<le> a \\<and> poly p x = 0}", "let ?l = \"min a l\""], ["proof (state)\ngoal (1 subgoal):\n 1. sign_changes_neg_inf ps - sign_changes ps a =\n    card {x. x \\<le> a \\<and> poly p x = 0}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. sign_changes_neg_inf ps - sign_changes ps a =\n    card {x. x \\<le> a \\<and> poly p x = 0}", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. sign_changes_neg_inf ps - sign_changes ps a =\n    card {x. x \\<le> a \\<and> poly p x = 0}", "assume \"poly p x = 0\""], ["proof (state)\nthis:\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. sign_changes_neg_inf ps - sign_changes ps a =\n    card {x. x \\<le> a \\<and> poly p x = 0}", "hence \"x > ?l\""], ["proof (prove)\nusing this:\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. min a l < x", "using lu_props(4)[OF \\<open>p \\<in> set ps\\<close>, of x] \\<open>p \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  poly p x = 0\n  x \\<le> l \\<Longrightarrow> sgn (poly p x) = poly_neg_inf p\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. min a l < x", "by (cases \"l < x\", auto simp: sgn_zero_iff)"], ["proof (state)\nthis:\n  min a l < x\n\ngoal (1 subgoal):\n 1. sign_changes_neg_inf ps - sign_changes ps a =\n    card {x. x \\<le> a \\<and> poly p x = 0}", "}"], ["proof (state)\nthis:\n  poly p ?x2 = 0 \\<Longrightarrow> min a l < ?x2\n\ngoal (1 subgoal):\n 1. sign_changes_neg_inf ps - sign_changes ps a =\n    card {x. x \\<le> a \\<and> poly p x = 0}", "note [simp] = this"], ["proof (state)\nthis:\n  poly p ?x2 = 0 \\<Longrightarrow> min a l < ?x2\n\ngoal (1 subgoal):\n 1. sign_changes_neg_inf ps - sign_changes ps a =\n    card {x. x \\<le> a \\<and> poly p x = 0}", "from lu_props"], ["proof (chain)\npicking this:\n  l \\<le> u\n  \\<lbrakk>?p \\<in> set ps; ?p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> {x. l < x \\<and> x \\<le> u \\<and> poly ?p x = 0} =\n                    {x. poly ?p x = 0}\n  \\<lbrakk>?p \\<in> set ps; u \\<le> ?x\\<rbrakk>\n  \\<Longrightarrow> sgn (poly ?p ?x) = poly_inf ?p\n  \\<lbrakk>?p \\<in> set ps; ?x \\<le> l\\<rbrakk>\n  \\<Longrightarrow> sgn (poly ?p ?x) = poly_neg_inf ?p", "have \"map (\\<lambda>p. sgn (poly p ?l)) ps = map poly_neg_inf ps\""], ["proof (prove)\nusing this:\n  l \\<le> u\n  \\<lbrakk>?p \\<in> set ps; ?p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> {x. l < x \\<and> x \\<le> u \\<and> poly ?p x = 0} =\n                    {x. poly ?p x = 0}\n  \\<lbrakk>?p \\<in> set ps; u \\<le> ?x\\<rbrakk>\n  \\<Longrightarrow> sgn (poly ?p ?x) = poly_inf ?p\n  \\<lbrakk>?p \\<in> set ps; ?x \\<le> l\\<rbrakk>\n  \\<Longrightarrow> sgn (poly ?p ?x) = poly_neg_inf ?p\n\ngoal (1 subgoal):\n 1. map (\\<lambda>p. sgn (poly p (min a l))) ps = map poly_neg_inf ps", "by simp"], ["proof (state)\nthis:\n  map (\\<lambda>p. sgn (poly p (min a l))) ps = map poly_neg_inf ps\n\ngoal (1 subgoal):\n 1. sign_changes_neg_inf ps - sign_changes ps a =\n    card {x. x \\<le> a \\<and> poly p x = 0}", "hence \"sign_changes_neg_inf ps - sign_changes ps a =\n             sign_changes ps ?l - sign_changes ps a\""], ["proof (prove)\nusing this:\n  map (\\<lambda>p. sgn (poly p (min a l))) ps = map poly_neg_inf ps\n\ngoal (1 subgoal):\n 1. sign_changes_neg_inf ps - sign_changes ps a =\n    sign_changes ps (min a l) - sign_changes ps a", "by (simp_all only: sign_changes_def sign_changes_neg_inf_def)"], ["proof (state)\nthis:\n  sign_changes_neg_inf ps - sign_changes ps a =\n  sign_changes ps (min a l) - sign_changes ps a\n\ngoal (1 subgoal):\n 1. sign_changes_neg_inf ps - sign_changes ps a =\n    card {x. x \\<le> a \\<and> poly p x = 0}", "also"], ["proof (state)\nthis:\n  sign_changes_neg_inf ps - sign_changes ps a =\n  sign_changes ps (min a l) - sign_changes ps a\n\ngoal (1 subgoal):\n 1. sign_changes_neg_inf ps - sign_changes ps a =\n    card {x. x \\<le> a \\<and> poly p x = 0}", "from count_roots_between[OF assms] lu_props"], ["proof (chain)\npicking this:\n  ?a \\<le> ?b \\<Longrightarrow>\n  sign_changes ps ?a - sign_changes ps ?b =\n  card {x. ?a < x \\<and> x \\<le> ?b \\<and> poly p x = 0}\n  l \\<le> u\n  \\<lbrakk>?p \\<in> set ps; ?p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> {x. l < x \\<and> x \\<le> u \\<and> poly ?p x = 0} =\n                    {x. poly ?p x = 0}\n  \\<lbrakk>?p \\<in> set ps; u \\<le> ?x\\<rbrakk>\n  \\<Longrightarrow> sgn (poly ?p ?x) = poly_inf ?p\n  \\<lbrakk>?p \\<in> set ps; ?x \\<le> l\\<rbrakk>\n  \\<Longrightarrow> sgn (poly ?p ?x) = poly_neg_inf ?p", "have \"... =  card {x. ?l < x \\<and> x \\<le> a \\<and> poly p x = 0}\""], ["proof (prove)\nusing this:\n  ?a \\<le> ?b \\<Longrightarrow>\n  sign_changes ps ?a - sign_changes ps ?b =\n  card {x. ?a < x \\<and> x \\<le> ?b \\<and> poly p x = 0}\n  l \\<le> u\n  \\<lbrakk>?p \\<in> set ps; ?p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> {x. l < x \\<and> x \\<le> u \\<and> poly ?p x = 0} =\n                    {x. poly ?p x = 0}\n  \\<lbrakk>?p \\<in> set ps; u \\<le> ?x\\<rbrakk>\n  \\<Longrightarrow> sgn (poly ?p ?x) = poly_inf ?p\n  \\<lbrakk>?p \\<in> set ps; ?x \\<le> l\\<rbrakk>\n  \\<Longrightarrow> sgn (poly ?p ?x) = poly_neg_inf ?p\n\ngoal (1 subgoal):\n 1. sign_changes ps (min a l) - sign_changes ps a =\n    card {x. min a l < x \\<and> x \\<le> a \\<and> poly p x = 0}", "by simp"], ["proof (state)\nthis:\n  sign_changes ps (min a l) - sign_changes ps a =\n  card {x. min a l < x \\<and> x \\<le> a \\<and> poly p x = 0}\n\ngoal (1 subgoal):\n 1. sign_changes_neg_inf ps - sign_changes ps a =\n    card {x. x \\<le> a \\<and> poly p x = 0}", "also"], ["proof (state)\nthis:\n  sign_changes ps (min a l) - sign_changes ps a =\n  card {x. min a l < x \\<and> x \\<le> a \\<and> poly p x = 0}\n\ngoal (1 subgoal):\n 1. sign_changes_neg_inf ps - sign_changes ps a =\n    card {x. x \\<le> a \\<and> poly p x = 0}", "have \"{x. ?l < x \\<and> x \\<le> a \\<and> poly p x = 0} = {x. a \\<ge> x \\<and> poly p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. min a l < x \\<and> x \\<le> a \\<and> poly p x = 0} =\n    {x. x \\<le> a \\<and> poly p x = 0}", "using lu_props"], ["proof (prove)\nusing this:\n  l \\<le> u\n  \\<lbrakk>?p \\<in> set ps; ?p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> {x. l < x \\<and> x \\<le> u \\<and> poly ?p x = 0} =\n                    {x. poly ?p x = 0}\n  \\<lbrakk>?p \\<in> set ps; u \\<le> ?x\\<rbrakk>\n  \\<Longrightarrow> sgn (poly ?p ?x) = poly_inf ?p\n  \\<lbrakk>?p \\<in> set ps; ?x \\<le> l\\<rbrakk>\n  \\<Longrightarrow> sgn (poly ?p ?x) = poly_neg_inf ?p\n\ngoal (1 subgoal):\n 1. {x. min a l < x \\<and> x \\<le> a \\<and> poly p x = 0} =\n    {x. x \\<le> a \\<and> poly p x = 0}", "by auto"], ["proof (state)\nthis:\n  {x. min a l < x \\<and> x \\<le> a \\<and> poly p x = 0} =\n  {x. x \\<le> a \\<and> poly p x = 0}\n\ngoal (1 subgoal):\n 1. sign_changes_neg_inf ps - sign_changes ps a =\n    card {x. x \\<le> a \\<and> poly p x = 0}", "finally"], ["proof (chain)\npicking this:\n  sign_changes_neg_inf ps - sign_changes ps a =\n  card {x. x \\<le> a \\<and> poly p x = 0}", "show ?thesis"], ["proof (prove)\nusing this:\n  sign_changes_neg_inf ps - sign_changes ps a =\n  card {x. x \\<le> a \\<and> poly p x = 0}\n\ngoal (1 subgoal):\n 1. sign_changes_neg_inf ps - sign_changes ps a =\n    card {x. x \\<le> a \\<and> poly p x = 0}", "."], ["proof (state)\nthis:\n  sign_changes_neg_inf ps - sign_changes ps a =\n  card {x. x \\<le> a \\<and> poly p x = 0}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in sturm_seq) count_roots:\n  assumes \"p \\<noteq> 0\"\n  shows \"sign_changes_neg_inf ps - sign_changes_inf ps =\n             card {x. poly p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes_neg_inf ps - sign_changes_inf ps = card {x. poly p x = 0}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. sign_changes_neg_inf ps - sign_changes_inf ps = card {x. poly p x = 0}", "have \"finite (set ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set ps)", "by simp"], ["proof (state)\nthis:\n  finite (set ps)\n\ngoal (1 subgoal):\n 1. sign_changes_neg_inf ps - sign_changes_inf ps = card {x. poly p x = 0}", "from polys_inf_sign_thresholds[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>l u.\n      \\<lbrakk>l \\<le> u;\n       \\<And>p.\n          \\<lbrakk>p \\<in> set ps; p \\<noteq> 0\\<rbrakk>\n          \\<Longrightarrow> {x. l < x \\<and>\n                                x \\<le> u \\<and> poly p x = 0} =\n                            {x. poly p x = 0};\n       \\<And>p x.\n          \\<lbrakk>p \\<in> set ps; u \\<le> x\\<rbrakk>\n          \\<Longrightarrow> sgn (poly p x) = poly_inf p;\n       \\<And>p x.\n          \\<lbrakk>p \\<in> set ps; x \\<le> l\\<rbrakk>\n          \\<Longrightarrow> sgn (poly p x) = poly_neg_inf p\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "guess l u"], ["proof (prove)\nusing this:\n  (\\<And>l u.\n      \\<lbrakk>l \\<le> u;\n       \\<And>p.\n          \\<lbrakk>p \\<in> set ps; p \\<noteq> 0\\<rbrakk>\n          \\<Longrightarrow> {x. l < x \\<and>\n                                x \\<le> u \\<and> poly p x = 0} =\n                            {x. poly p x = 0};\n       \\<And>p x.\n          \\<lbrakk>p \\<in> set ps; u \\<le> x\\<rbrakk>\n          \\<Longrightarrow> sgn (poly p x) = poly_inf p;\n       \\<And>p x.\n          \\<lbrakk>p \\<in> set ps; x \\<le> l\\<rbrakk>\n          \\<Longrightarrow> sgn (poly p x) = poly_neg_inf p\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. thesis", "."], ["proof (state)\nthis:\n  l \\<le> u\n  \\<lbrakk>?p \\<in> set ps; ?p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> {x. l < x \\<and> x \\<le> u \\<and> poly ?p x = 0} =\n                    {x. poly ?p x = 0}\n  \\<lbrakk>?p \\<in> set ps; u \\<le> ?x\\<rbrakk>\n  \\<Longrightarrow> sgn (poly ?p ?x) = poly_inf ?p\n  \\<lbrakk>?p \\<in> set ps; ?x \\<le> l\\<rbrakk>\n  \\<Longrightarrow> sgn (poly ?p ?x) = poly_neg_inf ?p\n\ngoal (1 subgoal):\n 1. sign_changes_neg_inf ps - sign_changes_inf ps = card {x. poly p x = 0}", "note lu_props = this"], ["proof (state)\nthis:\n  l \\<le> u\n  \\<lbrakk>?p \\<in> set ps; ?p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> {x. l < x \\<and> x \\<le> u \\<and> poly ?p x = 0} =\n                    {x. poly ?p x = 0}\n  \\<lbrakk>?p \\<in> set ps; u \\<le> ?x\\<rbrakk>\n  \\<Longrightarrow> sgn (poly ?p ?x) = poly_inf ?p\n  \\<lbrakk>?p \\<in> set ps; ?x \\<le> l\\<rbrakk>\n  \\<Longrightarrow> sgn (poly ?p ?x) = poly_neg_inf ?p\n\ngoal (1 subgoal):\n 1. sign_changes_neg_inf ps - sign_changes_inf ps = card {x. poly p x = 0}", "from lu_props"], ["proof (chain)\npicking this:\n  l \\<le> u\n  \\<lbrakk>?p \\<in> set ps; ?p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> {x. l < x \\<and> x \\<le> u \\<and> poly ?p x = 0} =\n                    {x. poly ?p x = 0}\n  \\<lbrakk>?p \\<in> set ps; u \\<le> ?x\\<rbrakk>\n  \\<Longrightarrow> sgn (poly ?p ?x) = poly_inf ?p\n  \\<lbrakk>?p \\<in> set ps; ?x \\<le> l\\<rbrakk>\n  \\<Longrightarrow> sgn (poly ?p ?x) = poly_neg_inf ?p", "have \"map (\\<lambda>p. sgn (poly p l)) ps = map poly_neg_inf ps\"\n         \"map (\\<lambda>p. sgn (poly p u)) ps = map poly_inf ps\""], ["proof (prove)\nusing this:\n  l \\<le> u\n  \\<lbrakk>?p \\<in> set ps; ?p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> {x. l < x \\<and> x \\<le> u \\<and> poly ?p x = 0} =\n                    {x. poly ?p x = 0}\n  \\<lbrakk>?p \\<in> set ps; u \\<le> ?x\\<rbrakk>\n  \\<Longrightarrow> sgn (poly ?p ?x) = poly_inf ?p\n  \\<lbrakk>?p \\<in> set ps; ?x \\<le> l\\<rbrakk>\n  \\<Longrightarrow> sgn (poly ?p ?x) = poly_neg_inf ?p\n\ngoal (1 subgoal):\n 1. map (\\<lambda>p. sgn (poly p l)) ps = map poly_neg_inf ps &&&\n    map (\\<lambda>p. sgn (poly p u)) ps = map poly_inf ps", "by simp_all"], ["proof (state)\nthis:\n  map (\\<lambda>p. sgn (poly p l)) ps = map poly_neg_inf ps\n  map (\\<lambda>p. sgn (poly p u)) ps = map poly_inf ps\n\ngoal (1 subgoal):\n 1. sign_changes_neg_inf ps - sign_changes_inf ps = card {x. poly p x = 0}", "hence \"sign_changes_neg_inf ps - sign_changes_inf ps =\n             sign_changes ps l - sign_changes ps u\""], ["proof (prove)\nusing this:\n  map (\\<lambda>p. sgn (poly p l)) ps = map poly_neg_inf ps\n  map (\\<lambda>p. sgn (poly p u)) ps = map poly_inf ps\n\ngoal (1 subgoal):\n 1. sign_changes_neg_inf ps - sign_changes_inf ps =\n    sign_changes ps l - sign_changes ps u", "by (simp_all only: sign_changes_def sign_changes_inf_def\n                         sign_changes_neg_inf_def)"], ["proof (state)\nthis:\n  sign_changes_neg_inf ps - sign_changes_inf ps =\n  sign_changes ps l - sign_changes ps u\n\ngoal (1 subgoal):\n 1. sign_changes_neg_inf ps - sign_changes_inf ps = card {x. poly p x = 0}", "also"], ["proof (state)\nthis:\n  sign_changes_neg_inf ps - sign_changes_inf ps =\n  sign_changes ps l - sign_changes ps u\n\ngoal (1 subgoal):\n 1. sign_changes_neg_inf ps - sign_changes_inf ps = card {x. poly p x = 0}", "from count_roots_between[OF assms] lu_props"], ["proof (chain)\npicking this:\n  ?a \\<le> ?b \\<Longrightarrow>\n  sign_changes ps ?a - sign_changes ps ?b =\n  card {x. ?a < x \\<and> x \\<le> ?b \\<and> poly p x = 0}\n  l \\<le> u\n  \\<lbrakk>?p \\<in> set ps; ?p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> {x. l < x \\<and> x \\<le> u \\<and> poly ?p x = 0} =\n                    {x. poly ?p x = 0}\n  \\<lbrakk>?p \\<in> set ps; u \\<le> ?x\\<rbrakk>\n  \\<Longrightarrow> sgn (poly ?p ?x) = poly_inf ?p\n  \\<lbrakk>?p \\<in> set ps; ?x \\<le> l\\<rbrakk>\n  \\<Longrightarrow> sgn (poly ?p ?x) = poly_neg_inf ?p", "have \"... =  card {x. l < x \\<and> x \\<le> u \\<and> poly p x = 0}\""], ["proof (prove)\nusing this:\n  ?a \\<le> ?b \\<Longrightarrow>\n  sign_changes ps ?a - sign_changes ps ?b =\n  card {x. ?a < x \\<and> x \\<le> ?b \\<and> poly p x = 0}\n  l \\<le> u\n  \\<lbrakk>?p \\<in> set ps; ?p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> {x. l < x \\<and> x \\<le> u \\<and> poly ?p x = 0} =\n                    {x. poly ?p x = 0}\n  \\<lbrakk>?p \\<in> set ps; u \\<le> ?x\\<rbrakk>\n  \\<Longrightarrow> sgn (poly ?p ?x) = poly_inf ?p\n  \\<lbrakk>?p \\<in> set ps; ?x \\<le> l\\<rbrakk>\n  \\<Longrightarrow> sgn (poly ?p ?x) = poly_neg_inf ?p\n\ngoal (1 subgoal):\n 1. sign_changes ps l - sign_changes ps u =\n    card {x. l < x \\<and> x \\<le> u \\<and> poly p x = 0}", "by simp"], ["proof (state)\nthis:\n  sign_changes ps l - sign_changes ps u =\n  card {x. l < x \\<and> x \\<le> u \\<and> poly p x = 0}\n\ngoal (1 subgoal):\n 1. sign_changes_neg_inf ps - sign_changes_inf ps = card {x. poly p x = 0}", "also"], ["proof (state)\nthis:\n  sign_changes ps l - sign_changes ps u =\n  card {x. l < x \\<and> x \\<le> u \\<and> poly p x = 0}\n\ngoal (1 subgoal):\n 1. sign_changes_neg_inf ps - sign_changes_inf ps = card {x. poly p x = 0}", "have \"{x. l < x \\<and> x \\<le> u \\<and> poly p x = 0} = {x. poly p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. l < x \\<and> x \\<le> u \\<and> poly p x = 0} = {x. poly p x = 0}", "using lu_props assms"], ["proof (prove)\nusing this:\n  l \\<le> u\n  \\<lbrakk>?p \\<in> set ps; ?p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> {x. l < x \\<and> x \\<le> u \\<and> poly ?p x = 0} =\n                    {x. poly ?p x = 0}\n  \\<lbrakk>?p \\<in> set ps; u \\<le> ?x\\<rbrakk>\n  \\<Longrightarrow> sgn (poly ?p ?x) = poly_inf ?p\n  \\<lbrakk>?p \\<in> set ps; ?x \\<le> l\\<rbrakk>\n  \\<Longrightarrow> sgn (poly ?p ?x) = poly_neg_inf ?p\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. {x. l < x \\<and> x \\<le> u \\<and> poly p x = 0} = {x. poly p x = 0}", "by simp"], ["proof (state)\nthis:\n  {x. l < x \\<and> x \\<le> u \\<and> poly p x = 0} = {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. sign_changes_neg_inf ps - sign_changes_inf ps = card {x. poly p x = 0}", "finally"], ["proof (chain)\npicking this:\n  sign_changes_neg_inf ps - sign_changes_inf ps = card {x. poly p x = 0}", "show ?thesis"], ["proof (prove)\nusing this:\n  sign_changes_neg_inf ps - sign_changes_inf ps = card {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. sign_changes_neg_inf ps - sign_changes_inf ps = card {x. poly p x = 0}", "."], ["proof (state)\nthis:\n  sign_changes_neg_inf ps - sign_changes_inf ps = card {x. poly p x = 0}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Constructing Sturm sequences\\<close>"], ["", "subsection \\<open>The canonical Sturm sequence\\<close>"], ["", "text \\<open>\n  In this subsection, we will present the canonical Sturm sequence construction for\n  a polynomial $p$ without multiple roots that is very similar to the Euclidean\n  algorithm:\n  $$p_i = \\begin{cases}\n    p & \\text{for}\\ i = 1\\\\\n    p' & \\text{for}\\ i = 2\\\\\n    -p_{i-2}\\ \\text{mod}\\ p_{i-1} & \\text{otherwise}\n  \\end{cases}$$\n  We break off the sequence at the first constant polynomial.\n\\<close>"], ["", "(*<*)"], ["", "lemma degree_mod_less': \"degree q \\<noteq> 0 \\<Longrightarrow> degree (p mod q) < degree q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree q \\<noteq> 0 \\<Longrightarrow> degree (p mod q) < degree q", "by (metis degree_0 degree_mod_less not_gr0)"], ["", "(*>*)"], ["", "function sturm_aux where\n\"sturm_aux (p :: real poly) q =\n    (if degree q = 0 then [p,q] else p # sturm_aux q (-(p mod q)))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>p q. x = (p, q) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>p q pa qa.\n       (p, q) = (pa, qa) \\<Longrightarrow>\n       (if degree q = 0 then [p, q]\n        else p # sturm_aux_sumC (q, - (p mod q))) =\n       (if degree qa = 0 then [pa, qa]\n        else pa # sturm_aux_sumC (qa, - (pa mod qa)))", "by (pat_completeness, simp_all)"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All sturm_aux_dom", "by (relation \"measure (degree \\<circ> snd)\",\n                simp_all add: o_def degree_mod_less')"], ["", "(*<*)"], ["", "declare sturm_aux.simps[simp del]"], ["", "(*>*)"], ["", "definition sturm where \"sturm p = sturm_aux p (pderiv p)\""], ["", "text \\<open>Next, we show some simple facts about this construction:\\<close>"], ["", "lemma sturm_0[simp]: \"sturm 0 = [0,0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sturm 0 = [0, 0]", "by (unfold sturm_def, subst sturm_aux.simps, simp)"], ["", "lemma [simp]: \"sturm_aux p q = [] \\<longleftrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sturm_aux p q = []) = False", "by (induction p q rule: sturm_aux.induct, subst sturm_aux.simps, auto)"], ["", "lemma sturm_neq_Nil[simp]: \"sturm p \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sturm p \\<noteq> []", "unfolding sturm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sturm_aux p (pderiv p) \\<noteq> []", "by simp"], ["", "lemma [simp]: \"hd (sturm p) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (sturm p) = p", "unfolding sturm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (sturm_aux p (pderiv p)) = p", "by (subst sturm_aux.simps, simp)"], ["", "lemma [simp]: \"p \\<in> set (sturm p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> set (sturm p)", "using hd_in_set[OF sturm_neq_Nil]"], ["proof (prove)\nusing this:\n  hd (sturm ?p1) \\<in> set (sturm ?p1)\n\ngoal (1 subgoal):\n 1. p \\<in> set (sturm p)", "by simp"], ["", "lemma [simp]: \"length (sturm p) \\<ge> 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<le> length (sturm p)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 \\<le> length (sturm p)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 \\<le> length (sturm p)", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 \\<le> length (sturm p)", "have \"length (sturm_aux p q) \\<ge> 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<le> length (sturm_aux p q)", "by (induction p q rule: sturm_aux.induct, subst sturm_aux.simps, auto)"], ["proof (state)\nthis:\n  2 \\<le> length (sturm_aux p q)\n\ngoal (1 subgoal):\n 1. 2 \\<le> length (sturm p)", "}"], ["proof (state)\nthis:\n  2 \\<le> length (sturm_aux p ?q2)\n\ngoal (1 subgoal):\n 1. 2 \\<le> length (sturm p)", "thus ?thesis"], ["proof (prove)\nusing this:\n  2 \\<le> length (sturm_aux p ?q2)\n\ngoal (1 subgoal):\n 1. 2 \\<le> length (sturm p)", "unfolding sturm_def"], ["proof (prove)\nusing this:\n  2 \\<le> length (sturm_aux p ?q2)\n\ngoal (1 subgoal):\n 1. 2 \\<le> length (sturm_aux p (pderiv p))", "."], ["proof (state)\nthis:\n  2 \\<le> length (sturm p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma [simp]: \"degree (last (sturm p)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (last (sturm p)) = 0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. degree (last (sturm p)) = 0", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. degree (last (sturm p)) = 0", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. degree (last (sturm p)) = 0", "have \"degree (last (sturm_aux p q)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (last (sturm_aux p q)) = 0", "by (induction p q rule: sturm_aux.induct, subst sturm_aux.simps, simp)"], ["proof (state)\nthis:\n  degree (last (sturm_aux p q)) = 0\n\ngoal (1 subgoal):\n 1. degree (last (sturm p)) = 0", "}"], ["proof (state)\nthis:\n  degree (last (sturm_aux p ?q2)) = 0\n\ngoal (1 subgoal):\n 1. degree (last (sturm p)) = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  degree (last (sturm_aux p ?q2)) = 0\n\ngoal (1 subgoal):\n 1. degree (last (sturm p)) = 0", "unfolding sturm_def"], ["proof (prove)\nusing this:\n  degree (last (sturm_aux p ?q2)) = 0\n\ngoal (1 subgoal):\n 1. degree (last (sturm_aux p (pderiv p))) = 0", "."], ["proof (state)\nthis:\n  degree (last (sturm p)) = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma [simp]: \"sturm_aux p q ! 0 = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sturm_aux p q ! 0 = p", "by (subst sturm_aux.simps, simp)"], ["", "lemma [simp]: \"sturm_aux p q ! Suc 0 = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sturm_aux p q ! Suc 0 = q", "by (subst sturm_aux.simps, simp)"], ["", "lemma [simp]: \"sturm p ! 0 = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sturm p ! 0 = p", "unfolding sturm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sturm_aux p (pderiv p) ! 0 = p", "by simp"], ["", "lemma [simp]: \"sturm p ! Suc 0 = pderiv p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sturm p ! Suc 0 = pderiv p", "unfolding sturm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sturm_aux p (pderiv p) ! Suc 0 = pderiv p", "by simp"], ["", "lemma sturm_indices:\n  assumes \"i < length (sturm p) - 2\"\n  shows \"sturm p!(i+2) = -(sturm p!i mod sturm p!(i+1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sturm p ! (i + 2) = - (sturm p ! i mod sturm p ! (i + 1))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. sturm p ! (i + 2) = - (sturm p ! i mod sturm p ! (i + 1))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. sturm p ! (i + 2) = - (sturm p ! i mod sturm p ! (i + 1))", "fix ps q"], ["proof (state)\ngoal (1 subgoal):\n 1. sturm p ! (i + 2) = - (sturm p ! i mod sturm p ! (i + 1))", "have \"\\<lbrakk>ps = sturm_aux p q; i < length ps - 2\\<rbrakk>\n            \\<Longrightarrow> ps!(i+2) = -(ps!i mod ps!(i+1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ps = sturm_aux p q; i < length ps - 2\\<rbrakk>\n    \\<Longrightarrow> ps ! (i + 2) = - (ps ! i mod ps ! (i + 1))", "proof (induction p q arbitrary: ps i rule: sturm_aux.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q ps i.\n       \\<lbrakk>\\<And>ps i.\n                   \\<lbrakk>degree q \\<noteq> 0;\n                    ps = sturm_aux q (- (p mod q));\n                    i < length ps - 2\\<rbrakk>\n                   \\<Longrightarrow> ps ! (i + 2) =\n                                     - (ps ! i mod ps ! (i + 1));\n        ps = sturm_aux p q; i < length ps - 2\\<rbrakk>\n       \\<Longrightarrow> ps ! (i + 2) = - (ps ! i mod ps ! (i + 1))", "case (1 p q)"], ["proof (state)\nthis:\n  \\<lbrakk>degree q \\<noteq> 0; ?ps = sturm_aux q (- (p mod q));\n   ?i < length ?ps - 2\\<rbrakk>\n  \\<Longrightarrow> ?ps ! (?i + 2) = - (?ps ! ?i mod ?ps ! (?i + 1))\n  ps = sturm_aux p q\n  i < length ps - 2\n\ngoal (1 subgoal):\n 1. \\<And>p q ps i.\n       \\<lbrakk>\\<And>ps i.\n                   \\<lbrakk>degree q \\<noteq> 0;\n                    ps = sturm_aux q (- (p mod q));\n                    i < length ps - 2\\<rbrakk>\n                   \\<Longrightarrow> ps ! (i + 2) =\n                                     - (ps ! i mod ps ! (i + 1));\n        ps = sturm_aux p q; i < length ps - 2\\<rbrakk>\n       \\<Longrightarrow> ps ! (i + 2) = - (ps ! i mod ps ! (i + 1))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ps ! (i + 2) = - (ps ! i mod ps ! (i + 1))", "proof (cases \"i = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> ps ! (i + 2) = - (ps ! i mod ps ! (i + 1))\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    ps ! (i + 2) = - (ps ! i mod ps ! (i + 1))", "case False"], ["proof (state)\nthis:\n  i \\<noteq> 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> ps ! (i + 2) = - (ps ! i mod ps ! (i + 1))\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    ps ! (i + 2) = - (ps ! i mod ps ! (i + 1))", "then"], ["proof (chain)\npicking this:\n  i \\<noteq> 0", "obtain i' where [simp]: \"i = Suc i'\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>i'. i = Suc i' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases i, simp_all)"], ["proof (state)\nthis:\n  i = Suc i'\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> ps ! (i + 2) = - (ps ! i mod ps ! (i + 1))\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    ps ! (i + 2) = - (ps ! i mod ps ! (i + 1))", "hence \"length ps \\<ge> 4\""], ["proof (prove)\nusing this:\n  i = Suc i'\n\ngoal (1 subgoal):\n 1. 4 \\<le> length ps", "using 1"], ["proof (prove)\nusing this:\n  i = Suc i'\n  \\<lbrakk>degree q \\<noteq> 0; ?ps = sturm_aux q (- (p mod q));\n   ?i < length ?ps - 2\\<rbrakk>\n  \\<Longrightarrow> ?ps ! (?i + 2) = - (?ps ! ?i mod ?ps ! (?i + 1))\n  ps = sturm_aux p q\n  i < length ps - 2\n\ngoal (1 subgoal):\n 1. 4 \\<le> length ps", "by simp"], ["proof (state)\nthis:\n  4 \\<le> length ps\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> ps ! (i + 2) = - (ps ! i mod ps ! (i + 1))\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    ps ! (i + 2) = - (ps ! i mod ps ! (i + 1))", "with 1(2)"], ["proof (chain)\npicking this:\n  ps = sturm_aux p q\n  4 \\<le> length ps", "have deg: \"degree q \\<noteq> 0\""], ["proof (prove)\nusing this:\n  ps = sturm_aux p q\n  4 \\<le> length ps\n\ngoal (1 subgoal):\n 1. degree q \\<noteq> 0", "by (subst (asm) sturm_aux.simps, simp split: if_split_asm)"], ["proof (state)\nthis:\n  degree q \\<noteq> 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> ps ! (i + 2) = - (ps ! i mod ps ! (i + 1))\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    ps ! (i + 2) = - (ps ! i mod ps ! (i + 1))", "with 1(2)"], ["proof (chain)\npicking this:\n  ps = sturm_aux p q\n  degree q \\<noteq> 0", "obtain ps' where [simp]: \"ps = p # ps'\""], ["proof (prove)\nusing this:\n  ps = sturm_aux p q\n  degree q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>ps'. ps = p # ps' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (subst (asm) sturm_aux.simps, simp)"], ["proof (state)\nthis:\n  ps = p # ps'\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> ps ! (i + 2) = - (ps ! i mod ps ! (i + 1))\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    ps ! (i + 2) = - (ps ! i mod ps ! (i + 1))", "with 1(2) deg"], ["proof (chain)\npicking this:\n  ps = sturm_aux p q\n  degree q \\<noteq> 0\n  ps = p # ps'", "have ps': \"ps' = sturm_aux q (-(p mod q))\""], ["proof (prove)\nusing this:\n  ps = sturm_aux p q\n  degree q \\<noteq> 0\n  ps = p # ps'\n\ngoal (1 subgoal):\n 1. ps' = sturm_aux q (- (p mod q))", "by (subst (asm) sturm_aux.simps, simp)"], ["proof (state)\nthis:\n  ps' = sturm_aux q (- (p mod q))\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> ps ! (i + 2) = - (ps ! i mod ps ! (i + 1))\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    ps ! (i + 2) = - (ps ! i mod ps ! (i + 1))", "from \\<open>length ps \\<ge> 4\\<close> and \\<open>ps = p # ps'\\<close> 1(3) False"], ["proof (chain)\npicking this:\n  4 \\<le> length ps\n  ps = p # ps'\n  i < length ps - 2\n  i \\<noteq> 0", "have \"i - 1 < length ps' - 2\""], ["proof (prove)\nusing this:\n  4 \\<le> length ps\n  ps = p # ps'\n  i < length ps - 2\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i - 1 < length ps' - 2", "by simp"], ["proof (state)\nthis:\n  i - 1 < length ps' - 2\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> ps ! (i + 2) = - (ps ! i mod ps ! (i + 1))\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    ps ! (i + 2) = - (ps ! i mod ps ! (i + 1))", "from 1(1)[OF deg ps' this]"], ["proof (chain)\npicking this:\n  ps' ! (i - 1 + 2) = - (ps' ! (i - 1) mod ps' ! (i - 1 + 1))", "show ?thesis"], ["proof (prove)\nusing this:\n  ps' ! (i - 1 + 2) = - (ps' ! (i - 1) mod ps' ! (i - 1 + 1))\n\ngoal (1 subgoal):\n 1. ps ! (i + 2) = - (ps ! i mod ps ! (i + 1))", "by simp"], ["proof (state)\nthis:\n  ps ! (i + 2) = - (ps ! i mod ps ! (i + 1))\n\ngoal (1 subgoal):\n 1. i = 0 \\<Longrightarrow> ps ! (i + 2) = - (ps ! i mod ps ! (i + 1))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i = 0 \\<Longrightarrow> ps ! (i + 2) = - (ps ! i mod ps ! (i + 1))", "case True"], ["proof (state)\nthis:\n  i = 0\n\ngoal (1 subgoal):\n 1. i = 0 \\<Longrightarrow> ps ! (i + 2) = - (ps ! i mod ps ! (i + 1))", "with 1(3)"], ["proof (chain)\npicking this:\n  i < length ps - 2\n  i = 0", "have \"length ps \\<ge> 3\""], ["proof (prove)\nusing this:\n  i < length ps - 2\n  i = 0\n\ngoal (1 subgoal):\n 1. 3 \\<le> length ps", "by simp"], ["proof (state)\nthis:\n  3 \\<le> length ps\n\ngoal (1 subgoal):\n 1. i = 0 \\<Longrightarrow> ps ! (i + 2) = - (ps ! i mod ps ! (i + 1))", "with 1(2)"], ["proof (chain)\npicking this:\n  ps = sturm_aux p q\n  3 \\<le> length ps", "have \"degree q \\<noteq> 0\""], ["proof (prove)\nusing this:\n  ps = sturm_aux p q\n  3 \\<le> length ps\n\ngoal (1 subgoal):\n 1. degree q \\<noteq> 0", "by (subst (asm) sturm_aux.simps, simp split: if_split_asm)"], ["proof (state)\nthis:\n  degree q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i = 0 \\<Longrightarrow> ps ! (i + 2) = - (ps ! i mod ps ! (i + 1))", "with 1(2)"], ["proof (chain)\npicking this:\n  ps = sturm_aux p q\n  degree q \\<noteq> 0", "have [simp]: \"sturm_aux p q ! Suc (Suc 0) = -(p mod q)\""], ["proof (prove)\nusing this:\n  ps = sturm_aux p q\n  degree q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sturm_aux p q ! Suc (Suc 0) = - (p mod q)", "by (subst sturm_aux.simps, simp)"], ["proof (state)\nthis:\n  sturm_aux p q ! Suc (Suc 0) = - (p mod q)\n\ngoal (1 subgoal):\n 1. i = 0 \\<Longrightarrow> ps ! (i + 2) = - (ps ! i mod ps ! (i + 1))", "from True"], ["proof (chain)\npicking this:\n  i = 0", "have \"ps!i = p\" \"ps!(i+1) = q\" \"ps!(i+2) = -(p mod q)\""], ["proof (prove)\nusing this:\n  i = 0\n\ngoal (1 subgoal):\n 1. ps ! i = p &&& ps ! (i + 1) = q &&& ps ! (i + 2) = - (p mod q)", "by (simp_all add: 1(2))"], ["proof (state)\nthis:\n  ps ! i = p\n  ps ! (i + 1) = q\n  ps ! (i + 2) = - (p mod q)\n\ngoal (1 subgoal):\n 1. i = 0 \\<Longrightarrow> ps ! (i + 2) = - (ps ! i mod ps ! (i + 1))", "thus ?thesis"], ["proof (prove)\nusing this:\n  ps ! i = p\n  ps ! (i + 1) = q\n  ps ! (i + 2) = - (p mod q)\n\ngoal (1 subgoal):\n 1. ps ! (i + 2) = - (ps ! i mod ps ! (i + 1))", "by simp"], ["proof (state)\nthis:\n  ps ! (i + 2) = - (ps ! i mod ps ! (i + 1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ps ! (i + 2) = - (ps ! i mod ps ! (i + 1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>ps = sturm_aux p q; i < length ps - 2\\<rbrakk>\n  \\<Longrightarrow> ps ! (i + 2) = - (ps ! i mod ps ! (i + 1))\n\ngoal (1 subgoal):\n 1. sturm p ! (i + 2) = - (sturm p ! i mod sturm p ! (i + 1))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?ps2 = sturm_aux p ?q2; i < length ?ps2 - 2\\<rbrakk>\n  \\<Longrightarrow> ?ps2 ! (i + 2) = - (?ps2 ! i mod ?ps2 ! (i + 1))\n\ngoal (1 subgoal):\n 1. sturm p ! (i + 2) = - (sturm p ! i mod sturm p ! (i + 1))", "from this[OF sturm_def assms]"], ["proof (chain)\npicking this:\n  sturm p ! (i + 2) = - (sturm p ! i mod sturm p ! (i + 1))", "show ?thesis"], ["proof (prove)\nusing this:\n  sturm p ! (i + 2) = - (sturm p ! i mod sturm p ! (i + 1))\n\ngoal (1 subgoal):\n 1. sturm p ! (i + 2) = - (sturm p ! i mod sturm p ! (i + 1))", "."], ["proof (state)\nthis:\n  sturm p ! (i + 2) = - (sturm p ! i mod sturm p ! (i + 1))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  If the Sturm sequence construction is applied to polynomials $p$ and $q$,\n  the greatest common divisor of $p$ and $q$ a divisor of every element in the\n  sequence. This is obvious from the similarity to Euclid's algorithm for\n  computing the GCD.\n\\<close>"], ["", "lemma sturm_aux_gcd: \"r \\<in> set (sturm_aux p q) \\<Longrightarrow> gcd p q dvd r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<in> set (sturm_aux p q) \\<Longrightarrow> gcd p q dvd r", "proof (induction p q rule: sturm_aux.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>\\<lbrakk>degree q \\<noteq> 0;\n                 r \\<in> set (sturm_aux q (- (p mod q)))\\<rbrakk>\n                \\<Longrightarrow> gcd q (- (p mod q)) dvd r;\n        r \\<in> set (sturm_aux p q)\\<rbrakk>\n       \\<Longrightarrow> gcd p q dvd r", "case (1 p q)"], ["proof (state)\nthis:\n  \\<lbrakk>degree q \\<noteq> 0;\n   r \\<in> set (sturm_aux q (- (p mod q)))\\<rbrakk>\n  \\<Longrightarrow> gcd q (- (p mod q)) dvd r\n  r \\<in> set (sturm_aux p q)\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>\\<lbrakk>degree q \\<noteq> 0;\n                 r \\<in> set (sturm_aux q (- (p mod q)))\\<rbrakk>\n                \\<Longrightarrow> gcd q (- (p mod q)) dvd r;\n        r \\<in> set (sturm_aux p q)\\<rbrakk>\n       \\<Longrightarrow> gcd p q dvd r", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd p q dvd r", "proof (cases \"r = p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. r = p \\<Longrightarrow> gcd p q dvd r\n 2. r \\<noteq> p \\<Longrightarrow> gcd p q dvd r", "case False"], ["proof (state)\nthis:\n  r \\<noteq> p\n\ngoal (2 subgoals):\n 1. r = p \\<Longrightarrow> gcd p q dvd r\n 2. r \\<noteq> p \\<Longrightarrow> gcd p q dvd r", "with 1(2)"], ["proof (chain)\npicking this:\n  r \\<in> set (sturm_aux p q)\n  r \\<noteq> p", "have r: \"r \\<in> set (sturm_aux q (-(p mod q)))\""], ["proof (prove)\nusing this:\n  r \\<in> set (sturm_aux p q)\n  r \\<noteq> p\n\ngoal (1 subgoal):\n 1. r \\<in> set (sturm_aux q (- (p mod q)))", "by (subst (asm) sturm_aux.simps, simp split: if_split_asm,\n              subst sturm_aux.simps, simp)"], ["proof (state)\nthis:\n  r \\<in> set (sturm_aux q (- (p mod q)))\n\ngoal (2 subgoals):\n 1. r = p \\<Longrightarrow> gcd p q dvd r\n 2. r \\<noteq> p \\<Longrightarrow> gcd p q dvd r", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd p q dvd r", "proof (cases \"degree q = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. degree q = 0 \\<Longrightarrow> gcd p q dvd r\n 2. degree q \\<noteq> 0 \\<Longrightarrow> gcd p q dvd r", "case False"], ["proof (state)\nthis:\n  degree q \\<noteq> 0\n\ngoal (2 subgoals):\n 1. degree q = 0 \\<Longrightarrow> gcd p q dvd r\n 2. degree q \\<noteq> 0 \\<Longrightarrow> gcd p q dvd r", "hence \"q \\<noteq> 0\""], ["proof (prove)\nusing this:\n  degree q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "by force"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (2 subgoals):\n 1. degree q = 0 \\<Longrightarrow> gcd p q dvd r\n 2. degree q \\<noteq> 0 \\<Longrightarrow> gcd p q dvd r", "with 1(1) [OF False r]"], ["proof (chain)\npicking this:\n  gcd q (- (p mod q)) dvd r\n  q \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  gcd q (- (p mod q)) dvd r\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. gcd p q dvd r", "by (simp add: gcd_mod_right ac_simps)"], ["proof (state)\nthis:\n  gcd p q dvd r\n\ngoal (1 subgoal):\n 1. degree q = 0 \\<Longrightarrow> gcd p q dvd r", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. degree q = 0 \\<Longrightarrow> gcd p q dvd r", "case True"], ["proof (state)\nthis:\n  degree q = 0\n\ngoal (1 subgoal):\n 1. degree q = 0 \\<Longrightarrow> gcd p q dvd r", "with 1(2) and \\<open>r \\<noteq> p\\<close>"], ["proof (chain)\npicking this:\n  r \\<in> set (sturm_aux p q)\n  r \\<noteq> p\n  degree q = 0", "have \"r = q\""], ["proof (prove)\nusing this:\n  r \\<in> set (sturm_aux p q)\n  r \\<noteq> p\n  degree q = 0\n\ngoal (1 subgoal):\n 1. r = q", "by (subst (asm) sturm_aux.simps, simp)"], ["proof (state)\nthis:\n  r = q\n\ngoal (1 subgoal):\n 1. degree q = 0 \\<Longrightarrow> gcd p q dvd r", "thus ?thesis"], ["proof (prove)\nusing this:\n  r = q\n\ngoal (1 subgoal):\n 1. gcd p q dvd r", "by simp"], ["proof (state)\nthis:\n  gcd p q dvd r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gcd p q dvd r\n\ngoal (1 subgoal):\n 1. r = p \\<Longrightarrow> gcd p q dvd r", "qed simp"], ["proof (state)\nthis:\n  gcd p q dvd r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sturm_gcd: \"r \\<in> set (sturm p) \\<Longrightarrow> gcd p (pderiv p) dvd r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<in> set (sturm p) \\<Longrightarrow> gcd p (pderiv p) dvd r", "unfolding sturm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<in> set (sturm_aux p (pderiv p)) \\<Longrightarrow>\n    gcd p (pderiv p) dvd r", "by (rule sturm_aux_gcd)"], ["", "text \\<open>\n  If two adjacent polynomials in the result of the canonical Sturm chain construction\n  both have a root at some $x$, this $x$ is a root of all polynomials in the sequence.\n\\<close>"], ["", "lemma sturm_adjacent_root_propagate_left:\n  assumes \"i < length (sturm (p :: real poly)) - 1\"\n  assumes \"poly (sturm p ! i) x = 0\"\n      and \"poly (sturm p ! (i + 1)) x = 0\"\n  shows \"\\<forall>j\\<le>i+1. poly (sturm p ! j) x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j\\<le>i + 1. poly (sturm p ! j) x = 0", "using assms(2)"], ["proof (prove)\nusing this:\n  poly (sturm p ! i) x = 0\n\ngoal (1 subgoal):\n 1. \\<forall>j\\<le>i + 1. poly (sturm p ! j) x = 0", "proof (intro sturm_adjacent_root_aux[OF assms(1,2,3)], goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia xa.\n       \\<lbrakk>poly (sturm p ! i) x = 0; ia < length (sturm p) - 2;\n        poly (sturm p ! (ia + 1)) xa = 0\\<rbrakk>\n       \\<Longrightarrow> sgn (poly (sturm p ! (ia + 2)) xa) =\n                         - sgn (poly (sturm p ! ia) xa)", "case prems: (1 i x)"], ["proof (state)\nthis:\n  poly (sturm p ! i) x = 0\n  i < length (sturm p) - 2\n  poly (sturm p ! (i + 1)) x = 0\n\ngoal (1 subgoal):\n 1. \\<And>ia xa.\n       \\<lbrakk>poly (sturm p ! i) x = 0; ia < length (sturm p) - 2;\n        poly (sturm p ! (ia + 1)) xa = 0\\<rbrakk>\n       \\<Longrightarrow> sgn (poly (sturm p ! (ia + 2)) xa) =\n                         - sgn (poly (sturm p ! ia) xa)", "let ?p = \"sturm p ! i\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia xa.\n       \\<lbrakk>poly (sturm p ! i) x = 0; ia < length (sturm p) - 2;\n        poly (sturm p ! (ia + 1)) xa = 0\\<rbrakk>\n       \\<Longrightarrow> sgn (poly (sturm p ! (ia + 2)) xa) =\n                         - sgn (poly (sturm p ! ia) xa)", "let ?q = \"sturm p ! (i + 1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia xa.\n       \\<lbrakk>poly (sturm p ! i) x = 0; ia < length (sturm p) - 2;\n        poly (sturm p ! (ia + 1)) xa = 0\\<rbrakk>\n       \\<Longrightarrow> sgn (poly (sturm p ! (ia + 2)) xa) =\n                         - sgn (poly (sturm p ! ia) xa)", "let ?r = \"sturm p ! (i + 2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia xa.\n       \\<lbrakk>poly (sturm p ! i) x = 0; ia < length (sturm p) - 2;\n        poly (sturm p ! (ia + 1)) xa = 0\\<rbrakk>\n       \\<Longrightarrow> sgn (poly (sturm p ! (ia + 2)) xa) =\n                         - sgn (poly (sturm p ! ia) xa)", "from sturm_indices[OF prems(2)]"], ["proof (chain)\npicking this:\n  sturm p ! (i + 2) = - (sturm p ! i mod sturm p ! (i + 1))", "have \"?p = ?p div ?q * ?q - ?r\""], ["proof (prove)\nusing this:\n  sturm p ! (i + 2) = - (sturm p ! i mod sturm p ! (i + 1))\n\ngoal (1 subgoal):\n 1. sturm p ! i =\n    sturm p ! i div sturm p ! (i + 1) * sturm p ! (i + 1) -\n    sturm p ! (i + 2)", "by (simp add: div_mult_mod_eq)"], ["proof (state)\nthis:\n  sturm p ! i =\n  sturm p ! i div sturm p ! (i + 1) * sturm p ! (i + 1) - sturm p ! (i + 2)\n\ngoal (1 subgoal):\n 1. \\<And>ia xa.\n       \\<lbrakk>poly (sturm p ! i) x = 0; ia < length (sturm p) - 2;\n        poly (sturm p ! (ia + 1)) xa = 0\\<rbrakk>\n       \\<Longrightarrow> sgn (poly (sturm p ! (ia + 2)) xa) =\n                         - sgn (poly (sturm p ! ia) xa)", "hence \"poly ?p x = poly (?p div ?q * ?q - ?r) x\""], ["proof (prove)\nusing this:\n  sturm p ! i =\n  sturm p ! i div sturm p ! (i + 1) * sturm p ! (i + 1) - sturm p ! (i + 2)\n\ngoal (1 subgoal):\n 1. poly (sturm p ! i) x =\n    poly\n     (sturm p ! i div sturm p ! (i + 1) * sturm p ! (i + 1) -\n      sturm p ! (i + 2))\n     x", "by simp"], ["proof (state)\nthis:\n  poly (sturm p ! i) x =\n  poly\n   (sturm p ! i div sturm p ! (i + 1) * sturm p ! (i + 1) -\n    sturm p ! (i + 2))\n   x\n\ngoal (1 subgoal):\n 1. \\<And>ia xa.\n       \\<lbrakk>poly (sturm p ! i) x = 0; ia < length (sturm p) - 2;\n        poly (sturm p ! (ia + 1)) xa = 0\\<rbrakk>\n       \\<Longrightarrow> sgn (poly (sturm p ! (ia + 2)) xa) =\n                         - sgn (poly (sturm p ! ia) xa)", "hence \"poly ?p x = -poly ?r x\""], ["proof (prove)\nusing this:\n  poly (sturm p ! i) x =\n  poly\n   (sturm p ! i div sturm p ! (i + 1) * sturm p ! (i + 1) -\n    sturm p ! (i + 2))\n   x\n\ngoal (1 subgoal):\n 1. poly (sturm p ! i) x = - poly (sturm p ! (i + 2)) x", "using prems(3)"], ["proof (prove)\nusing this:\n  poly (sturm p ! i) x =\n  poly\n   (sturm p ! i div sturm p ! (i + 1) * sturm p ! (i + 1) -\n    sturm p ! (i + 2))\n   x\n  poly (sturm p ! (i + 1)) x = 0\n\ngoal (1 subgoal):\n 1. poly (sturm p ! i) x = - poly (sturm p ! (i + 2)) x", "by simp"], ["proof (state)\nthis:\n  poly (sturm p ! i) x = - poly (sturm p ! (i + 2)) x\n\ngoal (1 subgoal):\n 1. \\<And>ia xa.\n       \\<lbrakk>poly (sturm p ! i) x = 0; ia < length (sturm p) - 2;\n        poly (sturm p ! (ia + 1)) xa = 0\\<rbrakk>\n       \\<Longrightarrow> sgn (poly (sturm p ! (ia + 2)) xa) =\n                         - sgn (poly (sturm p ! ia) xa)", "thus ?case"], ["proof (prove)\nusing this:\n  poly (sturm p ! i) x = - poly (sturm p ! (i + 2)) x\n\ngoal (1 subgoal):\n 1. sgn (poly (sturm p ! (i + 2)) x) = - sgn (poly (sturm p ! i) x)", "by (simp add: sgn_minus)"], ["proof (state)\nthis:\n  sgn (poly (sturm p ! (i + 2)) x) = - sgn (poly (sturm p ! i) x)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Consequently, if this is the case in the canonical Sturm chain of $p$,\n  $p$ must have multiple roots.\n\\<close>"], ["", "lemma sturm_adjacent_root_not_squarefree:\n  assumes \"i < length (sturm (p :: real poly)) - 1\"\n          \"poly (sturm p ! i) x = 0\" \"poly (sturm p ! (i + 1)) x = 0\"\n  shows \"\\<not>rsquarefree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> rsquarefree p", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> rsquarefree p", "from sturm_adjacent_root_propagate_left[OF assms]"], ["proof (chain)\npicking this:\n  \\<forall>j\\<le>i + 1. poly (sturm p ! j) x = 0", "have \"poly p x = 0\" \"poly (pderiv p) x = 0\""], ["proof (prove)\nusing this:\n  \\<forall>j\\<le>i + 1. poly (sturm p ! j) x = 0\n\ngoal (1 subgoal):\n 1. poly p x = 0 &&& poly (pderiv p) x = 0", "by auto"], ["proof (state)\nthis:\n  poly p x = 0\n  poly (pderiv p) x = 0\n\ngoal (1 subgoal):\n 1. \\<not> rsquarefree p", "thus ?thesis"], ["proof (prove)\nusing this:\n  poly p x = 0\n  poly (pderiv p) x = 0\n\ngoal (1 subgoal):\n 1. \\<not> rsquarefree p", "by (auto simp: rsquarefree_roots)"], ["proof (state)\nthis:\n  \\<not> rsquarefree p\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Since the second element of the sequence is chosen to be the derivative of $p$,\n  $p_1$ and $p_2$ fulfil the property demanded by the definition of a Sturm sequence\n  that they locally have opposite sign left of a root $x$ of $p$ and the same sign\n  to the right of $x$.\n\\<close>"], ["", "lemma sturm_firsttwo_signs_aux:\n  assumes \"(p :: real poly) \\<noteq> 0\" \"q \\<noteq> 0\"\n  assumes q_pderiv:\n      \"eventually (\\<lambda>x. sgn (poly q x) = sgn (poly (pderiv p) x)) (at x\\<^sub>0)\"\n  assumes p_0: \"poly p (x\\<^sub>0::real) = 0\"\n  shows \"eventually (\\<lambda>x. sgn (poly (p*q) x) = (if x > x\\<^sub>0 then 1 else -1)) (at x\\<^sub>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)", "have A: \"eventually (\\<lambda>x. poly p x \\<noteq> 0 \\<and> poly q x \\<noteq> 0 \\<and>\n               sgn (poly q x) = sgn (poly (pderiv p) x)) (at x\\<^sub>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       poly p x \\<noteq> 0 \\<and>\n       poly q x \\<noteq> 0 \\<and> sgn (poly q x) = sgn (poly (pderiv p) x)", "using \\<open>p \\<noteq> 0\\<close>  \\<open>q \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       poly p x \\<noteq> 0 \\<and>\n       poly q x \\<noteq> 0 \\<and> sgn (poly q x) = sgn (poly (pderiv p) x)", "by (intro poly_neighbourhood_same_sign q_pderiv\n                poly_neighbourhood_without_roots eventually_conj)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     poly p x \\<noteq> 0 \\<and>\n     poly q x \\<noteq> 0 \\<and> sgn (poly q x) = sgn (poly (pderiv p) x)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     poly p x \\<noteq> 0 \\<and>\n     poly q x \\<noteq> 0 \\<and> sgn (poly q x) = sgn (poly (pderiv p) x)", "obtain \\<epsilon> where \\<epsilon>_props: \"\\<epsilon> > 0\" \"\\<forall>x. x \\<noteq> x\\<^sub>0 \\<and> \\<bar>x - x\\<^sub>0\\<bar> < \\<epsilon> \\<longrightarrow>\n      poly p x \\<noteq> 0 \\<and> poly q x \\<noteq> 0 \\<and> sgn (poly (pderiv p) x) = sgn (poly q x)\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     poly p x \\<noteq> 0 \\<and>\n     poly q x \\<noteq> 0 \\<and> sgn (poly q x) = sgn (poly (pderiv p) x)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<epsilon>.\n        \\<lbrakk>0 < \\<epsilon>;\n         \\<forall>x.\n            x \\<noteq> x\\<^sub>0 \\<and>\n            \\<bar>x - x\\<^sub>0\\<bar> < \\<epsilon> \\<longrightarrow>\n            poly p x \\<noteq> 0 \\<and>\n            poly q x \\<noteq> 0 \\<and>\n            sgn (poly (pderiv p) x) = sgn (poly q x)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: eventually_at dist_real_def)"], ["proof (state)\nthis:\n  0 < \\<epsilon>\n  \\<forall>x.\n     x \\<noteq> x\\<^sub>0 \\<and>\n     \\<bar>x - x\\<^sub>0\\<bar> < \\<epsilon> \\<longrightarrow>\n     poly p x \\<noteq> 0 \\<and>\n     poly q x \\<noteq> 0 \\<and> sgn (poly (pderiv p) x) = sgn (poly q x)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)", "have sqr_pos: \"\\<And>x::real. x \\<noteq> 0 \\<Longrightarrow> sgn x * sgn x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<noteq> 0 \\<Longrightarrow> sgn x * sgn x = 1", "by (auto simp: sgn_real_def)"], ["proof (state)\nthis:\n  ?x \\<noteq> 0 \\<Longrightarrow> sgn ?x * sgn ?x = 1\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)", "proof (simp only: eventually_at dist_real_def, rule exI[of _ \\<epsilon>],\n         intro conjI, fact \\<open>\\<epsilon> > 0\\<close>, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> UNIV; x \\<noteq> x\\<^sub>0;\n        \\<bar>x - x\\<^sub>0\\<bar> < \\<epsilon>\\<rbrakk>\n       \\<Longrightarrow> sgn (poly (p * q) x) =\n                         (if x\\<^sub>0 < x then 1 else - 1)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> UNIV; x \\<noteq> x\\<^sub>0;\n        \\<bar>x - x\\<^sub>0\\<bar> < \\<epsilon>\\<rbrakk>\n       \\<Longrightarrow> sgn (poly (p * q) x) =\n                         (if x\\<^sub>0 < x then 1 else - 1)", "assume \"x \\<noteq> x\\<^sub>0\" \"\\<bar>x - x\\<^sub>0\\<bar> < \\<epsilon>\""], ["proof (state)\nthis:\n  x \\<noteq> x\\<^sub>0\n  \\<bar>x - x\\<^sub>0\\<bar> < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> UNIV; x \\<noteq> x\\<^sub>0;\n        \\<bar>x - x\\<^sub>0\\<bar> < \\<epsilon>\\<rbrakk>\n       \\<Longrightarrow> sgn (poly (p * q) x) =\n                         (if x\\<^sub>0 < x then 1 else - 1)", "with \\<epsilon>_props"], ["proof (chain)\npicking this:\n  0 < \\<epsilon>\n  \\<forall>x.\n     x \\<noteq> x\\<^sub>0 \\<and>\n     \\<bar>x - x\\<^sub>0\\<bar> < \\<epsilon> \\<longrightarrow>\n     poly p x \\<noteq> 0 \\<and>\n     poly q x \\<noteq> 0 \\<and> sgn (poly (pderiv p) x) = sgn (poly q x)\n  x \\<noteq> x\\<^sub>0\n  \\<bar>x - x\\<^sub>0\\<bar> < \\<epsilon>", "have [simp]: \"poly p x \\<noteq> 0\" \"poly q x \\<noteq> 0\"\n        \"sgn (poly (pderiv p) x) = sgn (poly q x)\""], ["proof (prove)\nusing this:\n  0 < \\<epsilon>\n  \\<forall>x.\n     x \\<noteq> x\\<^sub>0 \\<and>\n     \\<bar>x - x\\<^sub>0\\<bar> < \\<epsilon> \\<longrightarrow>\n     poly p x \\<noteq> 0 \\<and>\n     poly q x \\<noteq> 0 \\<and> sgn (poly (pderiv p) x) = sgn (poly q x)\n  x \\<noteq> x\\<^sub>0\n  \\<bar>x - x\\<^sub>0\\<bar> < \\<epsilon>\n\ngoal (1 subgoal):\n 1. poly p x \\<noteq> 0 &&&\n    poly q x \\<noteq> 0 &&& sgn (poly (pderiv p) x) = sgn (poly q x)", "by auto"], ["proof (state)\nthis:\n  poly p x \\<noteq> 0\n  poly q x \\<noteq> 0\n  sgn (poly (pderiv p) x) = sgn (poly q x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> UNIV; x \\<noteq> x\\<^sub>0;\n        \\<bar>x - x\\<^sub>0\\<bar> < \\<epsilon>\\<rbrakk>\n       \\<Longrightarrow> sgn (poly (p * q) x) =\n                         (if x\\<^sub>0 < x then 1 else - 1)", "show \"sgn (poly (p*q) x) = (if x > x\\<^sub>0 then 1 else -1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)", "proof (cases \"x \\<ge> x\\<^sub>0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x\\<^sub>0 \\<le> x \\<Longrightarrow>\n    sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)\n 2. \\<not> x\\<^sub>0 \\<le> x \\<Longrightarrow>\n    sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)", "case True"], ["proof (state)\nthis:\n  x\\<^sub>0 \\<le> x\n\ngoal (2 subgoals):\n 1. x\\<^sub>0 \\<le> x \\<Longrightarrow>\n    sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)\n 2. \\<not> x\\<^sub>0 \\<le> x \\<Longrightarrow>\n    sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)", "with \\<open>x \\<noteq> x\\<^sub>0\\<close>"], ["proof (chain)\npicking this:\n  x \\<noteq> x\\<^sub>0\n  x\\<^sub>0 \\<le> x", "have \"x > x\\<^sub>0\""], ["proof (prove)\nusing this:\n  x \\<noteq> x\\<^sub>0\n  x\\<^sub>0 \\<le> x\n\ngoal (1 subgoal):\n 1. x\\<^sub>0 < x", "by simp"], ["proof (state)\nthis:\n  x\\<^sub>0 < x\n\ngoal (2 subgoals):\n 1. x\\<^sub>0 \\<le> x \\<Longrightarrow>\n    sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)\n 2. \\<not> x\\<^sub>0 \\<le> x \\<Longrightarrow>\n    sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)", "from poly_MVT[OF this, of p]"], ["proof (chain)\npicking this:\n  \\<exists>xa>x\\<^sub>0.\n     xa < x \\<and>\n     poly p x - poly p x\\<^sub>0 = (x - x\\<^sub>0) * poly (pderiv p) xa", "guess \\<xi>"], ["proof (prove)\nusing this:\n  \\<exists>xa>x\\<^sub>0.\n     xa < x \\<and>\n     poly p x - poly p x\\<^sub>0 = (x - x\\<^sub>0) * poly (pderiv p) xa\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  x\\<^sub>0 < \\<xi> \\<and>\n  \\<xi> < x \\<and>\n  poly p x - poly p x\\<^sub>0 = (x - x\\<^sub>0) * poly (pderiv p) \\<xi>\n\ngoal (2 subgoals):\n 1. x\\<^sub>0 \\<le> x \\<Longrightarrow>\n    sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)\n 2. \\<not> x\\<^sub>0 \\<le> x \\<Longrightarrow>\n    sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)", "note \\<xi>_props = this"], ["proof (state)\nthis:\n  x\\<^sub>0 < \\<xi> \\<and>\n  \\<xi> < x \\<and>\n  poly p x - poly p x\\<^sub>0 = (x - x\\<^sub>0) * poly (pderiv p) \\<xi>\n\ngoal (2 subgoals):\n 1. x\\<^sub>0 \\<le> x \\<Longrightarrow>\n    sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)\n 2. \\<not> x\\<^sub>0 \\<le> x \\<Longrightarrow>\n    sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)", "with \\<open>\\<bar>x - x\\<^sub>0\\<bar> < \\<epsilon>\\<close> \\<open>poly p x\\<^sub>0 = 0\\<close> \\<open>x > x\\<^sub>0\\<close> \\<epsilon>_props"], ["proof (chain)\npicking this:\n  \\<bar>x - x\\<^sub>0\\<bar> < \\<epsilon>\n  poly p x\\<^sub>0 = 0\n  x\\<^sub>0 < x\n  0 < \\<epsilon>\n  \\<forall>x.\n     x \\<noteq> x\\<^sub>0 \\<and>\n     \\<bar>x - x\\<^sub>0\\<bar> < \\<epsilon> \\<longrightarrow>\n     poly p x \\<noteq> 0 \\<and>\n     poly q x \\<noteq> 0 \\<and> sgn (poly (pderiv p) x) = sgn (poly q x)\n  x\\<^sub>0 < \\<xi> \\<and>\n  \\<xi> < x \\<and>\n  poly p x - poly p x\\<^sub>0 = (x - x\\<^sub>0) * poly (pderiv p) \\<xi>", "have \"\\<bar>\\<xi> - x\\<^sub>0\\<bar> < \\<epsilon>\" \"sgn (poly p x) = sgn (x - x\\<^sub>0) * sgn (poly q \\<xi>)\""], ["proof (prove)\nusing this:\n  \\<bar>x - x\\<^sub>0\\<bar> < \\<epsilon>\n  poly p x\\<^sub>0 = 0\n  x\\<^sub>0 < x\n  0 < \\<epsilon>\n  \\<forall>x.\n     x \\<noteq> x\\<^sub>0 \\<and>\n     \\<bar>x - x\\<^sub>0\\<bar> < \\<epsilon> \\<longrightarrow>\n     poly p x \\<noteq> 0 \\<and>\n     poly q x \\<noteq> 0 \\<and> sgn (poly (pderiv p) x) = sgn (poly q x)\n  x\\<^sub>0 < \\<xi> \\<and>\n  \\<xi> < x \\<and>\n  poly p x - poly p x\\<^sub>0 = (x - x\\<^sub>0) * poly (pderiv p) \\<xi>\n\ngoal (1 subgoal):\n 1. \\<bar>\\<xi> - x\\<^sub>0\\<bar> < \\<epsilon> &&&\n    sgn (poly p x) = sgn (x - x\\<^sub>0) * sgn (poly q \\<xi>)", "by (auto simp add: q_pderiv sgn_mult)"], ["proof (state)\nthis:\n  \\<bar>\\<xi> - x\\<^sub>0\\<bar> < \\<epsilon>\n  sgn (poly p x) = sgn (x - x\\<^sub>0) * sgn (poly q \\<xi>)\n\ngoal (2 subgoals):\n 1. x\\<^sub>0 \\<le> x \\<Longrightarrow>\n    sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)\n 2. \\<not> x\\<^sub>0 \\<le> x \\<Longrightarrow>\n    sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)", "moreover"], ["proof (state)\nthis:\n  \\<bar>\\<xi> - x\\<^sub>0\\<bar> < \\<epsilon>\n  sgn (poly p x) = sgn (x - x\\<^sub>0) * sgn (poly q \\<xi>)\n\ngoal (2 subgoals):\n 1. x\\<^sub>0 \\<le> x \\<Longrightarrow>\n    sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)\n 2. \\<not> x\\<^sub>0 \\<le> x \\<Longrightarrow>\n    sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)", "from \\<xi>_props \\<epsilon>_props \\<open>\\<bar>x - x\\<^sub>0\\<bar> < \\<epsilon>\\<close>"], ["proof (chain)\npicking this:\n  x\\<^sub>0 < \\<xi> \\<and>\n  \\<xi> < x \\<and>\n  poly p x - poly p x\\<^sub>0 = (x - x\\<^sub>0) * poly (pderiv p) \\<xi>\n  0 < \\<epsilon>\n  \\<forall>x.\n     x \\<noteq> x\\<^sub>0 \\<and>\n     \\<bar>x - x\\<^sub>0\\<bar> < \\<epsilon> \\<longrightarrow>\n     poly p x \\<noteq> 0 \\<and>\n     poly q x \\<noteq> 0 \\<and> sgn (poly (pderiv p) x) = sgn (poly q x)\n  \\<bar>x - x\\<^sub>0\\<bar> < \\<epsilon>", "have \"\\<forall>t. \\<xi> \\<le> t \\<and> t \\<le> x \\<longrightarrow> poly q t \\<noteq> 0\""], ["proof (prove)\nusing this:\n  x\\<^sub>0 < \\<xi> \\<and>\n  \\<xi> < x \\<and>\n  poly p x - poly p x\\<^sub>0 = (x - x\\<^sub>0) * poly (pderiv p) \\<xi>\n  0 < \\<epsilon>\n  \\<forall>x.\n     x \\<noteq> x\\<^sub>0 \\<and>\n     \\<bar>x - x\\<^sub>0\\<bar> < \\<epsilon> \\<longrightarrow>\n     poly p x \\<noteq> 0 \\<and>\n     poly q x \\<noteq> 0 \\<and> sgn (poly (pderiv p) x) = sgn (poly q x)\n  \\<bar>x - x\\<^sub>0\\<bar> < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<forall>t.\n       \\<xi> \\<le> t \\<and> t \\<le> x \\<longrightarrow> poly q t \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>t.\n     \\<xi> \\<le> t \\<and> t \\<le> x \\<longrightarrow> poly q t \\<noteq> 0\n\ngoal (2 subgoals):\n 1. x\\<^sub>0 \\<le> x \\<Longrightarrow>\n    sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)\n 2. \\<not> x\\<^sub>0 \\<le> x \\<Longrightarrow>\n    sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)", "hence \"sgn (poly q \\<xi>) = sgn (poly q x)\""], ["proof (prove)\nusing this:\n  \\<forall>t.\n     \\<xi> \\<le> t \\<and> t \\<le> x \\<longrightarrow> poly q t \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sgn (poly q \\<xi>) = sgn (poly q x)", "using \\<xi>_props \\<epsilon>_props"], ["proof (prove)\nusing this:\n  \\<forall>t.\n     \\<xi> \\<le> t \\<and> t \\<le> x \\<longrightarrow> poly q t \\<noteq> 0\n  x\\<^sub>0 < \\<xi> \\<and>\n  \\<xi> < x \\<and>\n  poly p x - poly p x\\<^sub>0 = (x - x\\<^sub>0) * poly (pderiv p) \\<xi>\n  0 < \\<epsilon>\n  \\<forall>x.\n     x \\<noteq> x\\<^sub>0 \\<and>\n     \\<bar>x - x\\<^sub>0\\<bar> < \\<epsilon> \\<longrightarrow>\n     poly p x \\<noteq> 0 \\<and>\n     poly q x \\<noteq> 0 \\<and> sgn (poly (pderiv p) x) = sgn (poly q x)\n\ngoal (1 subgoal):\n 1. sgn (poly q \\<xi>) = sgn (poly q x)", "by (intro no_roots_inbetween_imp_same_sign, simp_all)"], ["proof (state)\nthis:\n  sgn (poly q \\<xi>) = sgn (poly q x)\n\ngoal (2 subgoals):\n 1. x\\<^sub>0 \\<le> x \\<Longrightarrow>\n    sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)\n 2. \\<not> x\\<^sub>0 \\<le> x \\<Longrightarrow>\n    sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)", "ultimately"], ["proof (chain)\npicking this:\n  \\<bar>\\<xi> - x\\<^sub>0\\<bar> < \\<epsilon>\n  sgn (poly p x) = sgn (x - x\\<^sub>0) * sgn (poly q \\<xi>)\n  sgn (poly q \\<xi>) = sgn (poly q x)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>\\<xi> - x\\<^sub>0\\<bar> < \\<epsilon>\n  sgn (poly p x) = sgn (x - x\\<^sub>0) * sgn (poly q \\<xi>)\n  sgn (poly q \\<xi>) = sgn (poly q x)\n\ngoal (1 subgoal):\n 1. sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)", "using True \\<open>x \\<noteq> x\\<^sub>0\\<close> \\<epsilon>_props \\<xi>_props"], ["proof (prove)\nusing this:\n  \\<bar>\\<xi> - x\\<^sub>0\\<bar> < \\<epsilon>\n  sgn (poly p x) = sgn (x - x\\<^sub>0) * sgn (poly q \\<xi>)\n  sgn (poly q \\<xi>) = sgn (poly q x)\n  x\\<^sub>0 \\<le> x\n  x \\<noteq> x\\<^sub>0\n  0 < \\<epsilon>\n  \\<forall>x.\n     x \\<noteq> x\\<^sub>0 \\<and>\n     \\<bar>x - x\\<^sub>0\\<bar> < \\<epsilon> \\<longrightarrow>\n     poly p x \\<noteq> 0 \\<and>\n     poly q x \\<noteq> 0 \\<and> sgn (poly (pderiv p) x) = sgn (poly q x)\n  x\\<^sub>0 < \\<xi> \\<and>\n  \\<xi> < x \\<and>\n  poly p x - poly p x\\<^sub>0 = (x - x\\<^sub>0) * poly (pderiv p) \\<xi>\n\ngoal (1 subgoal):\n 1. sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)", "by (auto simp: sgn_mult sqr_pos)"], ["proof (state)\nthis:\n  sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)\n\ngoal (1 subgoal):\n 1. \\<not> x\\<^sub>0 \\<le> x \\<Longrightarrow>\n    sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x\\<^sub>0 \\<le> x \\<Longrightarrow>\n    sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)", "case False"], ["proof (state)\nthis:\n  \\<not> x\\<^sub>0 \\<le> x\n\ngoal (1 subgoal):\n 1. \\<not> x\\<^sub>0 \\<le> x \\<Longrightarrow>\n    sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)", "hence \"x < x\\<^sub>0\""], ["proof (prove)\nusing this:\n  \\<not> x\\<^sub>0 \\<le> x\n\ngoal (1 subgoal):\n 1. x < x\\<^sub>0", "by simp"], ["proof (state)\nthis:\n  x < x\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<not> x\\<^sub>0 \\<le> x \\<Longrightarrow>\n    sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)", "hence sgn: \"sgn (x - x\\<^sub>0) = -1\""], ["proof (prove)\nusing this:\n  x < x\\<^sub>0\n\ngoal (1 subgoal):\n 1. sgn (x - x\\<^sub>0) = - 1", "by simp"], ["proof (state)\nthis:\n  sgn (x - x\\<^sub>0) = - 1\n\ngoal (1 subgoal):\n 1. \\<not> x\\<^sub>0 \\<le> x \\<Longrightarrow>\n    sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)", "from poly_MVT[OF \\<open>x < x\\<^sub>0\\<close>, of p]"], ["proof (chain)\npicking this:\n  \\<exists>xa>x.\n     xa < x\\<^sub>0 \\<and>\n     poly p x\\<^sub>0 - poly p x = (x\\<^sub>0 - x) * poly (pderiv p) xa", "guess \\<xi>"], ["proof (prove)\nusing this:\n  \\<exists>xa>x.\n     xa < x\\<^sub>0 \\<and>\n     poly p x\\<^sub>0 - poly p x = (x\\<^sub>0 - x) * poly (pderiv p) xa\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  x < \\<xi> \\<and>\n  \\<xi> < x\\<^sub>0 \\<and>\n  poly p x\\<^sub>0 - poly p x = (x\\<^sub>0 - x) * poly (pderiv p) \\<xi>\n\ngoal (1 subgoal):\n 1. \\<not> x\\<^sub>0 \\<le> x \\<Longrightarrow>\n    sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)", "note \\<xi>_props = this"], ["proof (state)\nthis:\n  x < \\<xi> \\<and>\n  \\<xi> < x\\<^sub>0 \\<and>\n  poly p x\\<^sub>0 - poly p x = (x\\<^sub>0 - x) * poly (pderiv p) \\<xi>\n\ngoal (1 subgoal):\n 1. \\<not> x\\<^sub>0 \\<le> x \\<Longrightarrow>\n    sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)", "with \\<open>\\<bar>x - x\\<^sub>0\\<bar> < \\<epsilon>\\<close> \\<open>poly p x\\<^sub>0 = 0\\<close> \\<open>x < x\\<^sub>0\\<close> \\<epsilon>_props"], ["proof (chain)\npicking this:\n  \\<bar>x - x\\<^sub>0\\<bar> < \\<epsilon>\n  poly p x\\<^sub>0 = 0\n  x < x\\<^sub>0\n  0 < \\<epsilon>\n  \\<forall>x.\n     x \\<noteq> x\\<^sub>0 \\<and>\n     \\<bar>x - x\\<^sub>0\\<bar> < \\<epsilon> \\<longrightarrow>\n     poly p x \\<noteq> 0 \\<and>\n     poly q x \\<noteq> 0 \\<and> sgn (poly (pderiv p) x) = sgn (poly q x)\n  x < \\<xi> \\<and>\n  \\<xi> < x\\<^sub>0 \\<and>\n  poly p x\\<^sub>0 - poly p x = (x\\<^sub>0 - x) * poly (pderiv p) \\<xi>", "have \"\\<bar>\\<xi> - x\\<^sub>0\\<bar> < \\<epsilon>\" \"poly p x = (x - x\\<^sub>0) * poly (pderiv p) \\<xi>\"\n                 \"poly p \\<xi> \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<bar>x - x\\<^sub>0\\<bar> < \\<epsilon>\n  poly p x\\<^sub>0 = 0\n  x < x\\<^sub>0\n  0 < \\<epsilon>\n  \\<forall>x.\n     x \\<noteq> x\\<^sub>0 \\<and>\n     \\<bar>x - x\\<^sub>0\\<bar> < \\<epsilon> \\<longrightarrow>\n     poly p x \\<noteq> 0 \\<and>\n     poly q x \\<noteq> 0 \\<and> sgn (poly (pderiv p) x) = sgn (poly q x)\n  x < \\<xi> \\<and>\n  \\<xi> < x\\<^sub>0 \\<and>\n  poly p x\\<^sub>0 - poly p x = (x\\<^sub>0 - x) * poly (pderiv p) \\<xi>\n\ngoal (1 subgoal):\n 1. \\<bar>\\<xi> - x\\<^sub>0\\<bar> < \\<epsilon> &&&\n    poly p x = (x - x\\<^sub>0) * poly (pderiv p) \\<xi> &&&\n    poly p \\<xi> \\<noteq> 0", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  \\<bar>\\<xi> - x\\<^sub>0\\<bar> < \\<epsilon>\n  poly p x = (x - x\\<^sub>0) * poly (pderiv p) \\<xi>\n  poly p \\<xi> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> x\\<^sub>0 \\<le> x \\<Longrightarrow>\n    sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)", "hence \"sgn (poly p x) = sgn (x - x\\<^sub>0) * sgn (poly q \\<xi>)\""], ["proof (prove)\nusing this:\n  \\<bar>\\<xi> - x\\<^sub>0\\<bar> < \\<epsilon>\n  poly p x = (x - x\\<^sub>0) * poly (pderiv p) \\<xi>\n  poly p \\<xi> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sgn (poly p x) = sgn (x - x\\<^sub>0) * sgn (poly q \\<xi>)", "using \\<epsilon>_props \\<xi>_props"], ["proof (prove)\nusing this:\n  \\<bar>\\<xi> - x\\<^sub>0\\<bar> < \\<epsilon>\n  poly p x = (x - x\\<^sub>0) * poly (pderiv p) \\<xi>\n  poly p \\<xi> \\<noteq> 0\n  0 < \\<epsilon>\n  \\<forall>x.\n     x \\<noteq> x\\<^sub>0 \\<and>\n     \\<bar>x - x\\<^sub>0\\<bar> < \\<epsilon> \\<longrightarrow>\n     poly p x \\<noteq> 0 \\<and>\n     poly q x \\<noteq> 0 \\<and> sgn (poly (pderiv p) x) = sgn (poly q x)\n  x < \\<xi> \\<and>\n  \\<xi> < x\\<^sub>0 \\<and>\n  poly p x\\<^sub>0 - poly p x = (x\\<^sub>0 - x) * poly (pderiv p) \\<xi>\n\ngoal (1 subgoal):\n 1. sgn (poly p x) = sgn (x - x\\<^sub>0) * sgn (poly q \\<xi>)", "by (auto simp: q_pderiv sgn_mult)"], ["proof (state)\nthis:\n  sgn (poly p x) = sgn (x - x\\<^sub>0) * sgn (poly q \\<xi>)\n\ngoal (1 subgoal):\n 1. \\<not> x\\<^sub>0 \\<le> x \\<Longrightarrow>\n    sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)", "moreover"], ["proof (state)\nthis:\n  sgn (poly p x) = sgn (x - x\\<^sub>0) * sgn (poly q \\<xi>)\n\ngoal (1 subgoal):\n 1. \\<not> x\\<^sub>0 \\<le> x \\<Longrightarrow>\n    sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)", "from \\<xi>_props \\<epsilon>_props \\<open>\\<bar>x - x\\<^sub>0\\<bar> < \\<epsilon>\\<close>"], ["proof (chain)\npicking this:\n  x < \\<xi> \\<and>\n  \\<xi> < x\\<^sub>0 \\<and>\n  poly p x\\<^sub>0 - poly p x = (x\\<^sub>0 - x) * poly (pderiv p) \\<xi>\n  0 < \\<epsilon>\n  \\<forall>x.\n     x \\<noteq> x\\<^sub>0 \\<and>\n     \\<bar>x - x\\<^sub>0\\<bar> < \\<epsilon> \\<longrightarrow>\n     poly p x \\<noteq> 0 \\<and>\n     poly q x \\<noteq> 0 \\<and> sgn (poly (pderiv p) x) = sgn (poly q x)\n  \\<bar>x - x\\<^sub>0\\<bar> < \\<epsilon>", "have \"\\<forall>t. x \\<le> t \\<and> t \\<le> \\<xi> \\<longrightarrow> poly q t \\<noteq> 0\""], ["proof (prove)\nusing this:\n  x < \\<xi> \\<and>\n  \\<xi> < x\\<^sub>0 \\<and>\n  poly p x\\<^sub>0 - poly p x = (x\\<^sub>0 - x) * poly (pderiv p) \\<xi>\n  0 < \\<epsilon>\n  \\<forall>x.\n     x \\<noteq> x\\<^sub>0 \\<and>\n     \\<bar>x - x\\<^sub>0\\<bar> < \\<epsilon> \\<longrightarrow>\n     poly p x \\<noteq> 0 \\<and>\n     poly q x \\<noteq> 0 \\<and> sgn (poly (pderiv p) x) = sgn (poly q x)\n  \\<bar>x - x\\<^sub>0\\<bar> < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<forall>t.\n       x \\<le> t \\<and> t \\<le> \\<xi> \\<longrightarrow> poly q t \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>t.\n     x \\<le> t \\<and> t \\<le> \\<xi> \\<longrightarrow> poly q t \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> x\\<^sub>0 \\<le> x \\<Longrightarrow>\n    sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)", "hence \"sgn (poly q \\<xi>) = sgn (poly q x)\""], ["proof (prove)\nusing this:\n  \\<forall>t.\n     x \\<le> t \\<and> t \\<le> \\<xi> \\<longrightarrow> poly q t \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sgn (poly q \\<xi>) = sgn (poly q x)", "using \\<xi>_props \\<epsilon>_props"], ["proof (prove)\nusing this:\n  \\<forall>t.\n     x \\<le> t \\<and> t \\<le> \\<xi> \\<longrightarrow> poly q t \\<noteq> 0\n  x < \\<xi> \\<and>\n  \\<xi> < x\\<^sub>0 \\<and>\n  poly p x\\<^sub>0 - poly p x = (x\\<^sub>0 - x) * poly (pderiv p) \\<xi>\n  0 < \\<epsilon>\n  \\<forall>x.\n     x \\<noteq> x\\<^sub>0 \\<and>\n     \\<bar>x - x\\<^sub>0\\<bar> < \\<epsilon> \\<longrightarrow>\n     poly p x \\<noteq> 0 \\<and>\n     poly q x \\<noteq> 0 \\<and> sgn (poly (pderiv p) x) = sgn (poly q x)\n\ngoal (1 subgoal):\n 1. sgn (poly q \\<xi>) = sgn (poly q x)", "by (rule_tac sym, intro no_roots_inbetween_imp_same_sign, simp_all)"], ["proof (state)\nthis:\n  sgn (poly q \\<xi>) = sgn (poly q x)\n\ngoal (1 subgoal):\n 1. \\<not> x\\<^sub>0 \\<le> x \\<Longrightarrow>\n    sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)", "ultimately"], ["proof (chain)\npicking this:\n  sgn (poly p x) = sgn (x - x\\<^sub>0) * sgn (poly q \\<xi>)\n  sgn (poly q \\<xi>) = sgn (poly q x)", "show ?thesis"], ["proof (prove)\nusing this:\n  sgn (poly p x) = sgn (x - x\\<^sub>0) * sgn (poly q \\<xi>)\n  sgn (poly q \\<xi>) = sgn (poly q x)\n\ngoal (1 subgoal):\n 1. sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)", "using False \\<open>x \\<noteq> x\\<^sub>0\\<close>"], ["proof (prove)\nusing this:\n  sgn (poly p x) = sgn (x - x\\<^sub>0) * sgn (poly q \\<xi>)\n  sgn (poly q \\<xi>) = sgn (poly q x)\n  \\<not> x\\<^sub>0 \\<le> x\n  x \\<noteq> x\\<^sub>0\n\ngoal (1 subgoal):\n 1. sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)", "by (auto simp: sgn_mult sqr_pos)"], ["proof (state)\nthis:\n  sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     sgn (poly (p * q) x) = (if x\\<^sub>0 < x then 1 else - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sturm_firsttwo_signs:\n  fixes ps :: \"real poly list\"\n  assumes squarefree: \"rsquarefree p\"\n  assumes p_0: \"poly p (x\\<^sub>0::real) = 0\"\n  shows \"eventually (\\<lambda>x. sgn (poly (p * sturm p ! 1) x) =\n             (if x > x\\<^sub>0 then 1 else -1)) (at x\\<^sub>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sgn (poly (p * sturm p ! 1) x) = (if x\\<^sub>0 < x then 1 else - 1)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sgn (poly (p * sturm p ! 1) x) = (if x\\<^sub>0 < x then 1 else - 1)", "from assms"], ["proof (chain)\npicking this:\n  rsquarefree p\n  poly p x\\<^sub>0 = 0", "have [simp]: \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  rsquarefree p\n  poly p x\\<^sub>0 = 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by (auto simp add: rsquarefree_roots)"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sgn (poly (p * sturm p ! 1) x) = (if x\\<^sub>0 < x then 1 else - 1)", "with squarefree p_0"], ["proof (chain)\npicking this:\n  rsquarefree p\n  poly p x\\<^sub>0 = 0\n  p \\<noteq> 0", "have [simp]: \"pderiv p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  rsquarefree p\n  poly p x\\<^sub>0 = 0\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pderiv p \\<noteq> 0", "by (auto simp  add:rsquarefree_roots)"], ["proof (state)\nthis:\n  pderiv p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sgn (poly (p * sturm p ! 1) x) = (if x\\<^sub>0 < x then 1 else - 1)", "from assms"], ["proof (chain)\npicking this:\n  rsquarefree p\n  poly p x\\<^sub>0 = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  rsquarefree p\n  poly p x\\<^sub>0 = 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sgn (poly (p * sturm p ! 1) x) = (if x\\<^sub>0 < x then 1 else - 1)", "by (intro sturm_firsttwo_signs_aux,\n          simp_all add: rsquarefree_roots)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     sgn (poly (p * sturm p ! 1) x) = (if x\\<^sub>0 < x then 1 else - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The construction also obviously fulfils the property about three\n  adjacent polynomials in the sequence.\n\\<close>"], ["", "lemma sturm_signs:\n  assumes squarefree: \"rsquarefree p\"\n  assumes i_in_range: \"i < length (sturm (p :: real poly)) - 2\"\n  assumes q_0: \"poly (sturm p ! (i+1)) x = 0\" (is \"poly ?q x = 0\")\n  shows \"poly (sturm p ! (i+2)) x * poly (sturm p ! i) x < 0\"\n            (is \"poly ?p x * poly ?r x < 0\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (sturm p ! (i + 2)) x * poly (sturm p ! i) x < 0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. poly (sturm p ! (i + 2)) x * poly (sturm p ! i) x < 0", "from sturm_indices[OF i_in_range]"], ["proof (chain)\npicking this:\n  sturm p ! (i + 2) = - (sturm p ! i mod sturm p ! (i + 1))", "have \"sturm p ! (i+2) = - (sturm p ! i mod sturm p ! (i+1))\"\n           (is \"?r = - (?p mod ?q)\")"], ["proof (prove)\nusing this:\n  sturm p ! (i + 2) = - (sturm p ! i mod sturm p ! (i + 1))\n\ngoal (1 subgoal):\n 1. sturm p ! (i + 2) = - (sturm p ! i mod sturm p ! (i + 1))", "."], ["proof (state)\nthis:\n  sturm p ! (i + 2) = - (sturm p ! i mod sturm p ! (i + 1))\n\ngoal (1 subgoal):\n 1. poly (sturm p ! (i + 2)) x * poly (sturm p ! i) x < 0", "hence \"-?r = ?p mod ?q\""], ["proof (prove)\nusing this:\n  sturm p ! (i + 2) = - (sturm p ! i mod sturm p ! (i + 1))\n\ngoal (1 subgoal):\n 1. - sturm p ! (i + 2) = sturm p ! i mod sturm p ! (i + 1)", "by simp"], ["proof (state)\nthis:\n  - sturm p ! (i + 2) = sturm p ! i mod sturm p ! (i + 1)\n\ngoal (1 subgoal):\n 1. poly (sturm p ! (i + 2)) x * poly (sturm p ! i) x < 0", "with div_mult_mod_eq[of ?p ?q]"], ["proof (chain)\npicking this:\n  sturm p ! i div sturm p ! (i + 1) * sturm p ! (i + 1) +\n  sturm p ! i mod sturm p ! (i + 1) =\n  sturm p ! i\n  - sturm p ! (i + 2) = sturm p ! i mod sturm p ! (i + 1)", "have \"?p div ?q * ?q - ?r = ?p\""], ["proof (prove)\nusing this:\n  sturm p ! i div sturm p ! (i + 1) * sturm p ! (i + 1) +\n  sturm p ! i mod sturm p ! (i + 1) =\n  sturm p ! i\n  - sturm p ! (i + 2) = sturm p ! i mod sturm p ! (i + 1)\n\ngoal (1 subgoal):\n 1. sturm p ! i div sturm p ! (i + 1) * sturm p ! (i + 1) -\n    sturm p ! (i + 2) =\n    sturm p ! i", "by simp"], ["proof (state)\nthis:\n  sturm p ! i div sturm p ! (i + 1) * sturm p ! (i + 1) -\n  sturm p ! (i + 2) =\n  sturm p ! i\n\ngoal (1 subgoal):\n 1. poly (sturm p ! (i + 2)) x * poly (sturm p ! i) x < 0", "hence \"poly (?p div ?q) x * poly ?q x - poly ?r x = poly ?p x\""], ["proof (prove)\nusing this:\n  sturm p ! i div sturm p ! (i + 1) * sturm p ! (i + 1) -\n  sturm p ! (i + 2) =\n  sturm p ! i\n\ngoal (1 subgoal):\n 1. poly (sturm p ! i div sturm p ! (i + 1)) x *\n    poly (sturm p ! (i + 1)) x -\n    poly (sturm p ! (i + 2)) x =\n    poly (sturm p ! i) x", "by (metis poly_diff poly_mult)"], ["proof (state)\nthis:\n  poly (sturm p ! i div sturm p ! (i + 1)) x * poly (sturm p ! (i + 1)) x -\n  poly (sturm p ! (i + 2)) x =\n  poly (sturm p ! i) x\n\ngoal (1 subgoal):\n 1. poly (sturm p ! (i + 2)) x * poly (sturm p ! i) x < 0", "with q_0"], ["proof (chain)\npicking this:\n  poly (sturm p ! (i + 1)) x = 0\n  poly (sturm p ! i div sturm p ! (i + 1)) x * poly (sturm p ! (i + 1)) x -\n  poly (sturm p ! (i + 2)) x =\n  poly (sturm p ! i) x", "have r_x: \"poly ?r x = -poly ?p x\""], ["proof (prove)\nusing this:\n  poly (sturm p ! (i + 1)) x = 0\n  poly (sturm p ! i div sturm p ! (i + 1)) x * poly (sturm p ! (i + 1)) x -\n  poly (sturm p ! (i + 2)) x =\n  poly (sturm p ! i) x\n\ngoal (1 subgoal):\n 1. poly (sturm p ! (i + 2)) x = - poly (sturm p ! i) x", "by simp"], ["proof (state)\nthis:\n  poly (sturm p ! (i + 2)) x = - poly (sturm p ! i) x\n\ngoal (1 subgoal):\n 1. poly (sturm p ! (i + 2)) x * poly (sturm p ! i) x < 0", "moreover"], ["proof (state)\nthis:\n  poly (sturm p ! (i + 2)) x = - poly (sturm p ! i) x\n\ngoal (1 subgoal):\n 1. poly (sturm p ! (i + 2)) x * poly (sturm p ! i) x < 0", "have sqr_pos: \"\\<And>x::real. x \\<noteq> 0 \\<Longrightarrow> x * x > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<noteq> 0 \\<Longrightarrow> 0 < x * x", "apply (case_tac \"x \\<ge> 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> 0; 0 \\<le> x\\<rbrakk> \\<Longrightarrow> 0 < x * x\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> 0; \\<not> 0 \\<le> x\\<rbrakk>\n       \\<Longrightarrow> 0 < x * x", "by (simp_all add: mult_neg_neg)"], ["proof (state)\nthis:\n  ?x \\<noteq> 0 \\<Longrightarrow> 0 < ?x * ?x\n\ngoal (1 subgoal):\n 1. poly (sturm p ! (i + 2)) x * poly (sturm p ! i) x < 0", "from sturm_adjacent_root_not_squarefree[of i p] assms r_x"], ["proof (chain)\npicking this:\n  \\<lbrakk>i < length (sturm p) - 1; poly (sturm p ! i) ?x = 0;\n   poly (sturm p ! (i + 1)) ?x = 0\\<rbrakk>\n  \\<Longrightarrow> \\<not> rsquarefree p\n  rsquarefree p\n  i < length (sturm p) - 2\n  poly (sturm p ! (i + 1)) x = 0\n  poly (sturm p ! (i + 2)) x = - poly (sturm p ! i) x", "have \"poly ?p x * poly ?p x > 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>i < length (sturm p) - 1; poly (sturm p ! i) ?x = 0;\n   poly (sturm p ! (i + 1)) ?x = 0\\<rbrakk>\n  \\<Longrightarrow> \\<not> rsquarefree p\n  rsquarefree p\n  i < length (sturm p) - 2\n  poly (sturm p ! (i + 1)) x = 0\n  poly (sturm p ! (i + 2)) x = - poly (sturm p ! i) x\n\ngoal (1 subgoal):\n 1. 0 < poly (sturm p ! i) x * poly (sturm p ! i) x", "by (force intro: sqr_pos)"], ["proof (state)\nthis:\n  0 < poly (sturm p ! i) x * poly (sturm p ! i) x\n\ngoal (1 subgoal):\n 1. poly (sturm p ! (i + 2)) x * poly (sturm p ! i) x < 0", "ultimately"], ["proof (chain)\npicking this:\n  poly (sturm p ! (i + 2)) x = - poly (sturm p ! i) x\n  0 < poly (sturm p ! i) x * poly (sturm p ! i) x", "show \"poly ?r x * poly ?p x < 0\""], ["proof (prove)\nusing this:\n  poly (sturm p ! (i + 2)) x = - poly (sturm p ! i) x\n  0 < poly (sturm p ! i) x * poly (sturm p ! i) x\n\ngoal (1 subgoal):\n 1. poly (sturm p ! (i + 2)) x * poly (sturm p ! i) x < 0", "by simp"], ["proof (state)\nthis:\n  poly (sturm p ! (i + 2)) x * poly (sturm p ! i) x < 0\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Finally, if $p$ contains no multiple roots, @{term \"sturm p\"}, i.e.\n  the canonical Sturm sequence for $p$, is a Sturm sequence\n  and can be used to determine the number of roots of $p$.\n\\<close>"], ["", "lemma sturm_seq_sturm[simp]:\n   assumes \"rsquarefree p\"\n   shows \"sturm_seq (sturm p) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sturm_seq (sturm p) p", "proof"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>x y. sgn (poly (last (sturm p)) x) = sgn (poly (last (sturm p)) y)\n 2. sturm p \\<noteq> []\n 3. \\<And>i x.\n       \\<lbrakk>i < length (sturm p) - 2;\n        poly (sturm p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (sturm p ! (i + 2)) x * poly (sturm p ! i) x\n                         < 0\n 4. hd (sturm p) = p\n 5. 2 \\<le> length (sturm p)\n 6. \\<And>x\\<^sub>0.\n       poly p x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p * sturm p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)\n 7. \\<And>x. \\<not> (poly p x = 0 \\<and> poly (sturm p ! 1) x = 0)", "show \"sturm p \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sturm p \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  sturm p \\<noteq> []\n\ngoal (6 subgoals):\n 1. \\<And>x y. sgn (poly (last (sturm p)) x) = sgn (poly (last (sturm p)) y)\n 2. \\<And>i x.\n       \\<lbrakk>i < length (sturm p) - 2;\n        poly (sturm p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (sturm p ! (i + 2)) x * poly (sturm p ! i) x\n                         < 0\n 3. hd (sturm p) = p\n 4. 2 \\<le> length (sturm p)\n 5. \\<And>x\\<^sub>0.\n       poly p x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p * sturm p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)\n 6. \\<And>x. \\<not> (poly p x = 0 \\<and> poly (sturm p ! 1) x = 0)", "show \"hd (sturm p) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (sturm p) = p", "by simp"], ["proof (state)\nthis:\n  hd (sturm p) = p\n\ngoal (5 subgoals):\n 1. \\<And>x y. sgn (poly (last (sturm p)) x) = sgn (poly (last (sturm p)) y)\n 2. \\<And>i x.\n       \\<lbrakk>i < length (sturm p) - 2;\n        poly (sturm p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (sturm p ! (i + 2)) x * poly (sturm p ! i) x\n                         < 0\n 3. 2 \\<le> length (sturm p)\n 4. \\<And>x\\<^sub>0.\n       poly p x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p * sturm p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)\n 5. \\<And>x. \\<not> (poly p x = 0 \\<and> poly (sturm p ! 1) x = 0)", "show \"length (sturm p) \\<ge> 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<le> length (sturm p)", "by simp"], ["proof (state)\nthis:\n  2 \\<le> length (sturm p)\n\ngoal (4 subgoals):\n 1. \\<And>x y. sgn (poly (last (sturm p)) x) = sgn (poly (last (sturm p)) y)\n 2. \\<And>i x.\n       \\<lbrakk>i < length (sturm p) - 2;\n        poly (sturm p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (sturm p ! (i + 2)) x * poly (sturm p ! i) x\n                         < 0\n 3. \\<And>x\\<^sub>0.\n       poly p x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p * sturm p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)\n 4. \\<And>x. \\<not> (poly p x = 0 \\<and> poly (sturm p ! 1) x = 0)", "from assms"], ["proof (chain)\npicking this:\n  rsquarefree p", "show \"\\<And>x. \\<not>(poly p x = 0 \\<and> poly (sturm p ! 1) x = 0)\""], ["proof (prove)\nusing this:\n  rsquarefree p\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<not> (poly p x = 0 \\<and> poly (sturm p ! 1) x = 0)", "by (simp add: rsquarefree_roots)"], ["proof (state)\nthis:\n  \\<not> (poly p ?x = 0 \\<and> poly (sturm p ! 1) ?x = 0)\n\ngoal (3 subgoals):\n 1. \\<And>x y. sgn (poly (last (sturm p)) x) = sgn (poly (last (sturm p)) y)\n 2. \\<And>i x.\n       \\<lbrakk>i < length (sturm p) - 2;\n        poly (sturm p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (sturm p ! (i + 2)) x * poly (sturm p ! i) x\n                         < 0\n 3. \\<And>x\\<^sub>0.\n       poly p x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p * sturm p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y. sgn (poly (last (sturm p)) x) = sgn (poly (last (sturm p)) y)\n 2. \\<And>i x.\n       \\<lbrakk>i < length (sturm p) - 2;\n        poly (sturm p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (sturm p ! (i + 2)) x * poly (sturm p ! i) x\n                         < 0\n 3. \\<And>x\\<^sub>0.\n       poly p x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p * sturm p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)", "fix x :: real and y :: real"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y. sgn (poly (last (sturm p)) x) = sgn (poly (last (sturm p)) y)\n 2. \\<And>i x.\n       \\<lbrakk>i < length (sturm p) - 2;\n        poly (sturm p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (sturm p ! (i + 2)) x * poly (sturm p ! i) x\n                         < 0\n 3. \\<And>x\\<^sub>0.\n       poly p x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p * sturm p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)", "have \"degree (last (sturm p)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (last (sturm p)) = 0", "by simp"], ["proof (state)\nthis:\n  degree (last (sturm p)) = 0\n\ngoal (3 subgoals):\n 1. \\<And>x y. sgn (poly (last (sturm p)) x) = sgn (poly (last (sturm p)) y)\n 2. \\<And>i x.\n       \\<lbrakk>i < length (sturm p) - 2;\n        poly (sturm p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (sturm p ! (i + 2)) x * poly (sturm p ! i) x\n                         < 0\n 3. \\<And>x\\<^sub>0.\n       poly p x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p * sturm p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)", "then"], ["proof (chain)\npicking this:\n  degree (last (sturm p)) = 0", "obtain c where \"last (sturm p) = [:c:]\""], ["proof (prove)\nusing this:\n  degree (last (sturm p)) = 0\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        last (sturm p) = [:c:] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"last (sturm p)\", simp split: if_split_asm)"], ["proof (state)\nthis:\n  last (sturm p) = [:c:]\n\ngoal (3 subgoals):\n 1. \\<And>x y. sgn (poly (last (sturm p)) x) = sgn (poly (last (sturm p)) y)\n 2. \\<And>i x.\n       \\<lbrakk>i < length (sturm p) - 2;\n        poly (sturm p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (sturm p ! (i + 2)) x * poly (sturm p ! i) x\n                         < 0\n 3. \\<And>x\\<^sub>0.\n       poly p x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p * sturm p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)", "thus \"\\<And>x y. sgn (poly (last (sturm p)) x) =\n            sgn (poly (last (sturm p)) y)\""], ["proof (prove)\nusing this:\n  last (sturm p) = [:c:]\n\ngoal (1 subgoal):\n 1. \\<And>x y. sgn (poly (last (sturm p)) x) = sgn (poly (last (sturm p)) y)", "by simp"], ["proof (state)\nthis:\n  sgn (poly (last (sturm p)) ?x) = sgn (poly (last (sturm p)) ?y)\n\ngoal (2 subgoals):\n 1. \\<And>i x.\n       \\<lbrakk>i < length (sturm p) - 2;\n        poly (sturm p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (sturm p ! (i + 2)) x * poly (sturm p ! i) x\n                         < 0\n 2. \\<And>x\\<^sub>0.\n       poly p x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p * sturm p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i x.\n       \\<lbrakk>i < length (sturm p) - 2;\n        poly (sturm p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (sturm p ! (i + 2)) x * poly (sturm p ! i) x\n                         < 0\n 2. \\<And>x\\<^sub>0.\n       poly p x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p * sturm p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)", "from sturm_firsttwo_signs[OF assms]"], ["proof (chain)\npicking this:\n  poly p ?x\\<^sub>0 = 0 \\<Longrightarrow>\n  \\<forall>\\<^sub>F x in at ?x\\<^sub>0.\n     sgn (poly (p * sturm p ! 1) x) = (if ?x\\<^sub>0 < x then 1 else - 1)", "show \"\\<And>x\\<^sub>0. poly p x\\<^sub>0 = 0 \\<Longrightarrow>\n         eventually (\\<lambda>x. sgn (poly (p*sturm p ! 1) x) =\n                         (if x > x\\<^sub>0 then 1 else -1)) (at x\\<^sub>0)\""], ["proof (prove)\nusing this:\n  poly p ?x\\<^sub>0 = 0 \\<Longrightarrow>\n  \\<forall>\\<^sub>F x in at ?x\\<^sub>0.\n     sgn (poly (p * sturm p ! 1) x) = (if ?x\\<^sub>0 < x then 1 else - 1)\n\ngoal (1 subgoal):\n 1. \\<And>x\\<^sub>0.\n       poly p x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p * sturm p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)", "by simp"], ["proof (state)\nthis:\n  poly p ?x\\<^sub>0 = 0 \\<Longrightarrow>\n  \\<forall>\\<^sub>F x in at ?x\\<^sub>0.\n     sgn (poly (p * sturm p ! 1) x) = (if ?x\\<^sub>0 < x then 1 else - 1)\n\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i < length (sturm p) - 2;\n        poly (sturm p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (sturm p ! (i + 2)) x * poly (sturm p ! i) x\n                         < 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i < length (sturm p) - 2;\n        poly (sturm p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (sturm p ! (i + 2)) x * poly (sturm p ! i) x\n                         < 0", "from sturm_signs[OF assms]"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i < length (sturm p) - 2;\n   poly (sturm p ! (?i + 1)) ?x = 0\\<rbrakk>\n  \\<Longrightarrow> poly (sturm p ! (?i + 2)) ?x * poly (sturm p ! ?i) ?x\n                    < 0", "show \"\\<And>i x. \\<lbrakk>i < length (sturm p) - 2; poly (sturm p ! (i + 1)) x = 0\\<rbrakk>\n          \\<Longrightarrow> poly (sturm p ! (i + 2)) x * poly (sturm p ! i) x < 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < length (sturm p) - 2;\n   poly (sturm p ! (?i + 1)) ?x = 0\\<rbrakk>\n  \\<Longrightarrow> poly (sturm p ! (?i + 2)) ?x * poly (sturm p ! ?i) ?x\n                    < 0\n\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i < length (sturm p) - 2;\n        poly (sturm p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (sturm p ! (i + 2)) x * poly (sturm p ! i) x\n                         < 0", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>?i < length (sturm p) - 2;\n   poly (sturm p ! (?i + 1)) ?x = 0\\<rbrakk>\n  \\<Longrightarrow> poly (sturm p ! (?i + 2)) ?x * poly (sturm p ! ?i) ?x\n                    < 0\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Canonical squarefree Sturm sequence\\<close>"], ["", "text \\<open>\n  The previous construction does not work for polynomials with multiple roots,\n  but we can simply ``divide away'' multiple roots by dividing $p$ by the\n  GCD of $p$ and $p'$. The resulting polynomial has the same roots as $p$,\n  but with multiplicity 1, allowing us to again use the canonical construction.\n\\<close>"], ["", "definition sturm_squarefree where\n  \"sturm_squarefree p = sturm (p div (gcd p (pderiv p)))\""], ["", "lemma sturm_squarefree_not_Nil[simp]: \"sturm_squarefree p \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sturm_squarefree p \\<noteq> []", "by (simp add: sturm_squarefree_def)"], ["", "lemma sturm_seq_sturm_squarefree:\n  assumes [simp]: \"p \\<noteq> 0\"\n  defines [simp]: \"p' \\<equiv> p div gcd p (pderiv p)\"\n  shows \"sturm_seq (sturm_squarefree p) p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sturm_seq (sturm_squarefree p) p'", "proof"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>x y.\n       sgn (poly (last (sturm_squarefree p)) x) =\n       sgn (poly (last (sturm_squarefree p)) y)\n 2. sturm_squarefree p \\<noteq> []\n 3. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree p) - 2;\n        poly (sturm_squarefree p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (sturm_squarefree p ! (i + 2)) x *\n                         poly (sturm_squarefree p ! i) x\n                         < 0\n 4. hd (sturm_squarefree p) = p'\n 5. 2 \\<le> length (sturm_squarefree p)\n 6. \\<And>x\\<^sub>0.\n       poly p' x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p' * sturm_squarefree p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)\n 7. \\<And>x.\n       \\<not> (poly p' x = 0 \\<and> poly (sturm_squarefree p ! 1) x = 0)", "have \"rsquarefree p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rsquarefree p'", "proof (subst rsquarefree_roots, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>poly p' a = 0; poly (pderiv p') a = 0\\<rbrakk>\n       \\<Longrightarrow> False", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>poly p' a = 0; poly (pderiv p') a = 0\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"poly p' x = 0\" \"poly (pderiv p') x = 0\""], ["proof (state)\nthis:\n  poly p' x = 0\n  poly (pderiv p') x = 0\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>poly p' a = 0; poly (pderiv p') a = 0\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"[:-x,1:] dvd gcd p' (pderiv p')\""], ["proof (prove)\nusing this:\n  poly p' x = 0\n  poly (pderiv p') x = 0\n\ngoal (1 subgoal):\n 1. [:- x, 1:] dvd gcd p' (pderiv p')", "by (simp add: poly_eq_0_iff_dvd)"], ["proof (state)\nthis:\n  [:- x, 1:] dvd gcd p' (pderiv p')\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>poly p' a = 0; poly (pderiv p') a = 0\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  [:- x, 1:] dvd gcd p' (pderiv p')\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>poly p' a = 0; poly (pderiv p') a = 0\\<rbrakk>\n       \\<Longrightarrow> False", "from poly_div_gcd_squarefree(1)[OF assms(1)]"], ["proof (chain)\npicking this:\n  coprime (p div gcd p (pderiv p)) (pderiv (p div gcd p (pderiv p)))", "have \"gcd p' (pderiv p') = 1\""], ["proof (prove)\nusing this:\n  coprime (p div gcd p (pderiv p)) (pderiv (p div gcd p (pderiv p)))\n\ngoal (1 subgoal):\n 1. gcd p' (pderiv p') = 1", "by simp"], ["proof (state)\nthis:\n  gcd p' (pderiv p') = 1\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>poly p' a = 0; poly (pderiv p') a = 0\\<rbrakk>\n       \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  is_unit [:- x, 1:]", "show False"], ["proof (prove)\nusing this:\n  is_unit [:- x, 1:]\n\ngoal (1 subgoal):\n 1. False", "by (simp add: poly_eq_0_iff_dvd[symmetric])"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rsquarefree p'\n\ngoal (7 subgoals):\n 1. \\<And>x y.\n       sgn (poly (last (sturm_squarefree p)) x) =\n       sgn (poly (last (sturm_squarefree p)) y)\n 2. sturm_squarefree p \\<noteq> []\n 3. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree p) - 2;\n        poly (sturm_squarefree p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (sturm_squarefree p ! (i + 2)) x *\n                         poly (sturm_squarefree p ! i) x\n                         < 0\n 4. hd (sturm_squarefree p) = p'\n 5. 2 \\<le> length (sturm_squarefree p)\n 6. \\<And>x\\<^sub>0.\n       poly p' x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p' * sturm_squarefree p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)\n 7. \\<And>x.\n       \\<not> (poly p' x = 0 \\<and> poly (sturm_squarefree p ! 1) x = 0)", "from sturm_seq_sturm[OF \\<open>rsquarefree p'\\<close>]"], ["proof (chain)\npicking this:\n  sturm_seq (sturm p') p'", "interpret sturm_seq: sturm_seq \"sturm_squarefree p\" p'"], ["proof (prove)\nusing this:\n  sturm_seq (sturm p') p'\n\ngoal (1 subgoal):\n 1. sturm_seq (sturm_squarefree p) p'", "by (simp add: sturm_squarefree_def)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>x y.\n       sgn (poly (last (sturm_squarefree p)) x) =\n       sgn (poly (last (sturm_squarefree p)) y)\n 2. sturm_squarefree p \\<noteq> []\n 3. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree p) - 2;\n        poly (sturm_squarefree p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (sturm_squarefree p ! (i + 2)) x *\n                         poly (sturm_squarefree p ! i) x\n                         < 0\n 4. hd (sturm_squarefree p) = p'\n 5. 2 \\<le> length (sturm_squarefree p)\n 6. \\<And>x\\<^sub>0.\n       poly p' x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p' * sturm_squarefree p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)\n 7. \\<And>x.\n       \\<not> (poly p' x = 0 \\<and> poly (sturm_squarefree p ! 1) x = 0)", "show \"\\<And>x y. sgn (poly (last (sturm_squarefree p)) x) =\n      sgn (poly (last (sturm_squarefree p)) y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       sgn (poly (last (sturm_squarefree p)) x) =\n       sgn (poly (last (sturm_squarefree p)) y)", "by simp"], ["proof (state)\nthis:\n  sgn (poly (last (sturm_squarefree p)) ?x) =\n  sgn (poly (last (sturm_squarefree p)) ?y)\n\ngoal (6 subgoals):\n 1. sturm_squarefree p \\<noteq> []\n 2. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree p) - 2;\n        poly (sturm_squarefree p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (sturm_squarefree p ! (i + 2)) x *\n                         poly (sturm_squarefree p ! i) x\n                         < 0\n 3. hd (sturm_squarefree p) = p'\n 4. 2 \\<le> length (sturm_squarefree p)\n 5. \\<And>x\\<^sub>0.\n       poly p' x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p' * sturm_squarefree p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)\n 6. \\<And>x.\n       \\<not> (poly p' x = 0 \\<and> poly (sturm_squarefree p ! 1) x = 0)", "show \"sturm_squarefree p \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sturm_squarefree p \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  sturm_squarefree p \\<noteq> []\n\ngoal (5 subgoals):\n 1. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree p) - 2;\n        poly (sturm_squarefree p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (sturm_squarefree p ! (i + 2)) x *\n                         poly (sturm_squarefree p ! i) x\n                         < 0\n 2. hd (sturm_squarefree p) = p'\n 3. 2 \\<le> length (sturm_squarefree p)\n 4. \\<And>x\\<^sub>0.\n       poly p' x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p' * sturm_squarefree p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)\n 5. \\<And>x.\n       \\<not> (poly p' x = 0 \\<and> poly (sturm_squarefree p ! 1) x = 0)", "show \"hd (sturm_squarefree p) = p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (sturm_squarefree p) = p'", "by (simp add: sturm_squarefree_def)"], ["proof (state)\nthis:\n  hd (sturm_squarefree p) = p'\n\ngoal (4 subgoals):\n 1. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree p) - 2;\n        poly (sturm_squarefree p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (sturm_squarefree p ! (i + 2)) x *\n                         poly (sturm_squarefree p ! i) x\n                         < 0\n 2. 2 \\<le> length (sturm_squarefree p)\n 3. \\<And>x\\<^sub>0.\n       poly p' x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p' * sturm_squarefree p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)\n 4. \\<And>x.\n       \\<not> (poly p' x = 0 \\<and> poly (sturm_squarefree p ! 1) x = 0)", "show \"length (sturm_squarefree p) \\<ge> 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<le> length (sturm_squarefree p)", "by simp"], ["proof (state)\nthis:\n  2 \\<le> length (sturm_squarefree p)\n\ngoal (3 subgoals):\n 1. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree p) - 2;\n        poly (sturm_squarefree p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (sturm_squarefree p ! (i + 2)) x *\n                         poly (sturm_squarefree p ! i) x\n                         < 0\n 2. \\<And>x\\<^sub>0.\n       poly p' x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p' * sturm_squarefree p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)\n 3. \\<And>x.\n       \\<not> (poly p' x = 0 \\<and> poly (sturm_squarefree p ! 1) x = 0)", "have [simp]: \"sturm_squarefree p ! 0 = p'\"\n               \"sturm_squarefree p ! Suc 0 = pderiv p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sturm_squarefree p ! 0 = p' &&& sturm_squarefree p ! Suc 0 = pderiv p'", "by (simp_all add: sturm_squarefree_def)"], ["proof (state)\nthis:\n  sturm_squarefree p ! 0 = p'\n  sturm_squarefree p ! Suc 0 = pderiv p'\n\ngoal (3 subgoals):\n 1. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree p) - 2;\n        poly (sturm_squarefree p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (sturm_squarefree p ! (i + 2)) x *\n                         poly (sturm_squarefree p ! i) x\n                         < 0\n 2. \\<And>x\\<^sub>0.\n       poly p' x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p' * sturm_squarefree p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)\n 3. \\<And>x.\n       \\<not> (poly p' x = 0 \\<and> poly (sturm_squarefree p ! 1) x = 0)", "from \\<open>rsquarefree p'\\<close>"], ["proof (chain)\npicking this:\n  rsquarefree p'", "show \"\\<And>x. \\<not> (poly p' x = 0 \\<and> poly (sturm_squarefree p ! 1) x = 0)\""], ["proof (prove)\nusing this:\n  rsquarefree p'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<not> (poly p' x = 0 \\<and> poly (sturm_squarefree p ! 1) x = 0)", "by (simp add: rsquarefree_roots)"], ["proof (state)\nthis:\n  \\<not> (poly p' ?x = 0 \\<and> poly (sturm_squarefree p ! 1) ?x = 0)\n\ngoal (2 subgoals):\n 1. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree p) - 2;\n        poly (sturm_squarefree p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (sturm_squarefree p ! (i + 2)) x *\n                         poly (sturm_squarefree p ! i) x\n                         < 0\n 2. \\<And>x\\<^sub>0.\n       poly p' x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p' * sturm_squarefree p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)", "from sturm_seq.signs"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i < length (sturm_squarefree p) - 2;\n   poly (sturm_squarefree p ! (?i + 1)) ?x = 0\\<rbrakk>\n  \\<Longrightarrow> poly (sturm_squarefree p ! (?i + 2)) ?x *\n                    poly (sturm_squarefree p ! ?i) ?x\n                    < 0", "show \"\\<And>i x. \\<lbrakk>i < length (sturm_squarefree p) - 2;\n                                 poly (sturm_squarefree p ! (i + 1)) x = 0\\<rbrakk>\n                                 \\<Longrightarrow> poly (sturm_squarefree p ! (i + 2)) x *\n                                         poly (sturm_squarefree p ! i) x < 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < length (sturm_squarefree p) - 2;\n   poly (sturm_squarefree p ! (?i + 1)) ?x = 0\\<rbrakk>\n  \\<Longrightarrow> poly (sturm_squarefree p ! (?i + 2)) ?x *\n                    poly (sturm_squarefree p ! ?i) ?x\n                    < 0\n\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree p) - 2;\n        poly (sturm_squarefree p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (sturm_squarefree p ! (i + 2)) x *\n                         poly (sturm_squarefree p ! i) x\n                         < 0", "."], ["proof (state)\nthis:\n  \\<lbrakk>?i < length (sturm_squarefree p) - 2;\n   poly (sturm_squarefree p ! (?i + 1)) ?x = 0\\<rbrakk>\n  \\<Longrightarrow> poly (sturm_squarefree p ! (?i + 2)) ?x *\n                    poly (sturm_squarefree p ! ?i) ?x\n                    < 0\n\ngoal (1 subgoal):\n 1. \\<And>x\\<^sub>0.\n       poly p' x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p' * sturm_squarefree p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)", "from sturm_seq.deriv"], ["proof (chain)\npicking this:\n  poly p' ?x\\<^sub>0 = 0 \\<Longrightarrow>\n  \\<forall>\\<^sub>F x in at ?x\\<^sub>0.\n     sgn (poly (p' * sturm_squarefree p ! 1) x) =\n     (if ?x\\<^sub>0 < x then 1 else - 1)", "show \"\\<And>x\\<^sub>0. poly p' x\\<^sub>0 = 0 \\<Longrightarrow>\n         eventually (\\<lambda>x. sgn (poly (p' * sturm_squarefree p ! 1) x) =\n                         (if x > x\\<^sub>0 then 1 else -1)) (at x\\<^sub>0)\""], ["proof (prove)\nusing this:\n  poly p' ?x\\<^sub>0 = 0 \\<Longrightarrow>\n  \\<forall>\\<^sub>F x in at ?x\\<^sub>0.\n     sgn (poly (p' * sturm_squarefree p ! 1) x) =\n     (if ?x\\<^sub>0 < x then 1 else - 1)\n\ngoal (1 subgoal):\n 1. \\<And>x\\<^sub>0.\n       poly p' x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p' * sturm_squarefree p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)", "."], ["proof (state)\nthis:\n  poly p' ?x\\<^sub>0 = 0 \\<Longrightarrow>\n  \\<forall>\\<^sub>F x in at ?x\\<^sub>0.\n     sgn (poly (p' * sturm_squarefree p ! 1) x) =\n     (if ?x\\<^sub>0 < x then 1 else - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Optimisation for multiple roots\\<close>"], ["", "text \\<open>\n  We can also define the following non-canonical Sturm sequence that\n  is obtained by taking the canonical Sturm sequence of $p$\n  (possibly with multiple roots) and then dividing the entire\n  sequence by the GCD of $p$ and its derivative.\n\\<close>"], ["", "definition sturm_squarefree' where\n\"sturm_squarefree' p = (let d = gcd p (pderiv p)\n                         in map (\\<lambda>p'. p' div d) (sturm p))\""], ["", "text \\<open>\n  This construction also has all the desired properties:\n\\<close>"], ["", "lemma sturm_squarefree'_adjacent_root_propagate_left:\n  assumes \"p \\<noteq> 0\"\n  assumes \"i < length (sturm_squarefree' (p :: real poly)) - 1\"\n  assumes \"poly (sturm_squarefree' p ! i) x = 0\"\n      and \"poly (sturm_squarefree' p ! (i + 1)) x = 0\"\n  shows \"\\<forall>j\\<le>i+1. poly (sturm_squarefree' p ! j) x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j\\<le>i + 1. poly (sturm_squarefree' p ! j) x = 0", "proof (intro sturm_adjacent_root_aux[OF assms(2,3,4)], goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree' p) - 2;\n        poly (sturm_squarefree' p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> sgn (poly (sturm_squarefree' p ! (i + 2)) x) =\n                         - sgn (poly (sturm_squarefree' p ! i) x)", "case prems: (1 i x)"], ["proof (state)\nthis:\n  i < length (sturm_squarefree' p) - 2\n  poly (sturm_squarefree' p ! (i + 1)) x = 0\n\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree' p) - 2;\n        poly (sturm_squarefree' p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> sgn (poly (sturm_squarefree' p ! (i + 2)) x) =\n                         - sgn (poly (sturm_squarefree' p ! i) x)", "define q where \"q = sturm p ! i\""], ["proof (state)\nthis:\n  q = sturm p ! i\n\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree' p) - 2;\n        poly (sturm_squarefree' p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> sgn (poly (sturm_squarefree' p ! (i + 2)) x) =\n                         - sgn (poly (sturm_squarefree' p ! i) x)", "define r where \"r = sturm p ! (Suc i)\""], ["proof (state)\nthis:\n  r = sturm p ! Suc i\n\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree' p) - 2;\n        poly (sturm_squarefree' p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> sgn (poly (sturm_squarefree' p ! (i + 2)) x) =\n                         - sgn (poly (sturm_squarefree' p ! i) x)", "define s where \"s = sturm p ! (Suc (Suc i))\""], ["proof (state)\nthis:\n  s = sturm p ! Suc (Suc i)\n\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree' p) - 2;\n        poly (sturm_squarefree' p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> sgn (poly (sturm_squarefree' p ! (i + 2)) x) =\n                         - sgn (poly (sturm_squarefree' p ! i) x)", "define d where \"d = gcd p (pderiv p)\""], ["proof (state)\nthis:\n  d = gcd p (pderiv p)\n\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree' p) - 2;\n        poly (sturm_squarefree' p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> sgn (poly (sturm_squarefree' p ! (i + 2)) x) =\n                         - sgn (poly (sturm_squarefree' p ! i) x)", "define q' r' s' where \"q' = q div d\" and \"r' = r div d\" and \"s' = s div d\""], ["proof (state)\nthis:\n  q' = q div d\n  r' = r div d\n  s' = s div d\n\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree' p) - 2;\n        poly (sturm_squarefree' p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> sgn (poly (sturm_squarefree' p ! (i + 2)) x) =\n                         - sgn (poly (sturm_squarefree' p ! i) x)", "from \\<open>p \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "have \"d \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. d \\<noteq> 0", "unfolding d_def"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. gcd p (pderiv p) \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree' p) - 2;\n        poly (sturm_squarefree' p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> sgn (poly (sturm_squarefree' p ! (i + 2)) x) =\n                         - sgn (poly (sturm_squarefree' p ! i) x)", "from prems(1)"], ["proof (chain)\npicking this:\n  i < length (sturm_squarefree' p) - 2", "have i_in_range: \"i < length (sturm p) - 2\""], ["proof (prove)\nusing this:\n  i < length (sturm_squarefree' p) - 2\n\ngoal (1 subgoal):\n 1. i < length (sturm p) - 2", "unfolding sturm_squarefree'_def Let_def"], ["proof (prove)\nusing this:\n  i < length (map (\\<lambda>p'. p' div gcd p (pderiv p)) (sturm p)) - 2\n\ngoal (1 subgoal):\n 1. i < length (sturm p) - 2", "by simp"], ["proof (state)\nthis:\n  i < length (sturm p) - 2\n\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree' p) - 2;\n        poly (sturm_squarefree' p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> sgn (poly (sturm_squarefree' p ! (i + 2)) x) =\n                         - sgn (poly (sturm_squarefree' p ! i) x)", "have [simp]: \"d dvd q\" \"d dvd r\" \"d dvd s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d dvd q &&& d dvd r &&& d dvd s", "unfolding q_def r_def s_def d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd p (pderiv p) dvd sturm p ! i &&&\n    gcd p (pderiv p) dvd sturm p ! Suc i &&&\n    gcd p (pderiv p) dvd sturm p ! Suc (Suc i)", "using i_in_range"], ["proof (prove)\nusing this:\n  i < length (sturm p) - 2\n\ngoal (1 subgoal):\n 1. gcd p (pderiv p) dvd sturm p ! i &&&\n    gcd p (pderiv p) dvd sturm p ! Suc i &&&\n    gcd p (pderiv p) dvd sturm p ! Suc (Suc i)", "by (auto intro: sturm_gcd)"], ["proof (state)\nthis:\n  d dvd q\n  d dvd r\n  d dvd s\n\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree' p) - 2;\n        poly (sturm_squarefree' p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> sgn (poly (sturm_squarefree' p ! (i + 2)) x) =\n                         - sgn (poly (sturm_squarefree' p ! i) x)", "hence qrs_simps: \"q = q' * d\" \"r = r' * d\" \"s = s' * d\""], ["proof (prove)\nusing this:\n  d dvd q\n  d dvd r\n  d dvd s\n\ngoal (1 subgoal):\n 1. q = q' * d &&& r = r' * d &&& s = s' * d", "unfolding q'_def r'_def s'_def"], ["proof (prove)\nusing this:\n  d dvd q\n  d dvd r\n  d dvd s\n\ngoal (1 subgoal):\n 1. q = q div d * d &&& r = r div d * d &&& s = s div d * d", "by (simp_all)"], ["proof (state)\nthis:\n  q = q' * d\n  r = r' * d\n  s = s' * d\n\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree' p) - 2;\n        poly (sturm_squarefree' p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> sgn (poly (sturm_squarefree' p ! (i + 2)) x) =\n                         - sgn (poly (sturm_squarefree' p ! i) x)", "with prems(2) i_in_range"], ["proof (chain)\npicking this:\n  poly (sturm_squarefree' p ! (i + 1)) x = 0\n  i < length (sturm p) - 2\n  q = q' * d\n  r = r' * d\n  s = s' * d", "have r'_0: \"poly r' x = 0\""], ["proof (prove)\nusing this:\n  poly (sturm_squarefree' p ! (i + 1)) x = 0\n  i < length (sturm p) - 2\n  q = q' * d\n  r = r' * d\n  s = s' * d\n\ngoal (1 subgoal):\n 1. poly r' x = 0", "unfolding r'_def r_def d_def sturm_squarefree'_def Let_def"], ["proof (prove)\nusing this:\n  poly (map (\\<lambda>p'. p' div gcd p (pderiv p)) (sturm p) ! (i + 1)) x =\n  0\n  i < length (sturm p) - 2\n  q = q' * gcd p (pderiv p)\n  sturm p ! Suc i = sturm p ! Suc i div gcd p (pderiv p) * gcd p (pderiv p)\n  s = s' * gcd p (pderiv p)\n\ngoal (1 subgoal):\n 1. poly (sturm p ! Suc i div gcd p (pderiv p)) x = 0", "by simp"], ["proof (state)\nthis:\n  poly r' x = 0\n\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree' p) - 2;\n        poly (sturm_squarefree' p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> sgn (poly (sturm_squarefree' p ! (i + 2)) x) =\n                         - sgn (poly (sturm_squarefree' p ! i) x)", "hence r_0: \"poly r x = 0\""], ["proof (prove)\nusing this:\n  poly r' x = 0\n\ngoal (1 subgoal):\n 1. poly r x = 0", "by (simp add: \\<open>r = r' * d\\<close>)"], ["proof (state)\nthis:\n  poly r x = 0\n\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree' p) - 2;\n        poly (sturm_squarefree' p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> sgn (poly (sturm_squarefree' p ! (i + 2)) x) =\n                         - sgn (poly (sturm_squarefree' p ! i) x)", "from sturm_indices[OF i_in_range]"], ["proof (chain)\npicking this:\n  sturm p ! (i + 2) = - (sturm p ! i mod sturm p ! (i + 1))", "have \"q = q div r * r - s\""], ["proof (prove)\nusing this:\n  sturm p ! (i + 2) = - (sturm p ! i mod sturm p ! (i + 1))\n\ngoal (1 subgoal):\n 1. q = q div r * r - s", "unfolding q_def r_def s_def"], ["proof (prove)\nusing this:\n  sturm p ! (i + 2) = - (sturm p ! i mod sturm p ! (i + 1))\n\ngoal (1 subgoal):\n 1. sturm p ! i =\n    sturm p ! i div sturm p ! Suc i * sturm p ! Suc i -\n    sturm p ! Suc (Suc i)", "by (simp add: div_mult_mod_eq)"], ["proof (state)\nthis:\n  q = q div r * r - s\n\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree' p) - 2;\n        poly (sturm_squarefree' p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> sgn (poly (sturm_squarefree' p ! (i + 2)) x) =\n                         - sgn (poly (sturm_squarefree' p ! i) x)", "hence \"q' = (q div r * r - s) div d\""], ["proof (prove)\nusing this:\n  q = q div r * r - s\n\ngoal (1 subgoal):\n 1. q' = (q div r * r - s) div d", "by (simp add: q'_def)"], ["proof (state)\nthis:\n  q' = (q div r * r - s) div d\n\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree' p) - 2;\n        poly (sturm_squarefree' p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> sgn (poly (sturm_squarefree' p ! (i + 2)) x) =\n                         - sgn (poly (sturm_squarefree' p ! i) x)", "also"], ["proof (state)\nthis:\n  q' = (q div r * r - s) div d\n\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree' p) - 2;\n        poly (sturm_squarefree' p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> sgn (poly (sturm_squarefree' p ! (i + 2)) x) =\n                         - sgn (poly (sturm_squarefree' p ! i) x)", "have \"... = (q div r * r) div d - s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (q div r * r - s) div d = q div r * r div d - s'", "by (simp add: s'_def poly_div_diff_left)"], ["proof (state)\nthis:\n  (q div r * r - s) div d = q div r * r div d - s'\n\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree' p) - 2;\n        poly (sturm_squarefree' p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> sgn (poly (sturm_squarefree' p ! (i + 2)) x) =\n                         - sgn (poly (sturm_squarefree' p ! i) x)", "also"], ["proof (state)\nthis:\n  (q div r * r - s) div d = q div r * r div d - s'\n\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree' p) - 2;\n        poly (sturm_squarefree' p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> sgn (poly (sturm_squarefree' p ! (i + 2)) x) =\n                         - sgn (poly (sturm_squarefree' p ! i) x)", "have \"... = q div r * r' - s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q div r * r div d - s' = q div r * r' - s'", "using dvd_div_mult[OF \\<open>d dvd r\\<close>, of \"q div r\"]"], ["proof (prove)\nusing this:\n  r div d * (q div r) = r * (q div r) div d\n\ngoal (1 subgoal):\n 1. q div r * r div d - s' = q div r * r' - s'", "by (simp add: algebra_simps r'_def)"], ["proof (state)\nthis:\n  q div r * r div d - s' = q div r * r' - s'\n\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree' p) - 2;\n        poly (sturm_squarefree' p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> sgn (poly (sturm_squarefree' p ! (i + 2)) x) =\n                         - sgn (poly (sturm_squarefree' p ! i) x)", "also"], ["proof (state)\nthis:\n  q div r * r div d - s' = q div r * r' - s'\n\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree' p) - 2;\n        poly (sturm_squarefree' p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> sgn (poly (sturm_squarefree' p ! (i + 2)) x) =\n                         - sgn (poly (sturm_squarefree' p ! i) x)", "have \"q div r = q' div r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q div r = q' div r'", "by (simp add: qrs_simps \\<open>d \\<noteq> 0\\<close>)"], ["proof (state)\nthis:\n  q div r = q' div r'\n\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree' p) - 2;\n        poly (sturm_squarefree' p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> sgn (poly (sturm_squarefree' p ! (i + 2)) x) =\n                         - sgn (poly (sturm_squarefree' p ! i) x)", "finally"], ["proof (chain)\npicking this:\n  q' = q' div r' * r' - s'", "have \"poly q' x = poly (q' div r' * r' - s') x\""], ["proof (prove)\nusing this:\n  q' = q' div r' * r' - s'\n\ngoal (1 subgoal):\n 1. poly q' x = poly (q' div r' * r' - s') x", "by simp"], ["proof (state)\nthis:\n  poly q' x = poly (q' div r' * r' - s') x\n\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree' p) - 2;\n        poly (sturm_squarefree' p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> sgn (poly (sturm_squarefree' p ! (i + 2)) x) =\n                         - sgn (poly (sturm_squarefree' p ! i) x)", "also"], ["proof (state)\nthis:\n  poly q' x = poly (q' div r' * r' - s') x\n\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree' p) - 2;\n        poly (sturm_squarefree' p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> sgn (poly (sturm_squarefree' p ! (i + 2)) x) =\n                         - sgn (poly (sturm_squarefree' p ! i) x)", "from r'_0"], ["proof (chain)\npicking this:\n  poly r' x = 0", "have \"... = -poly s' x\""], ["proof (prove)\nusing this:\n  poly r' x = 0\n\ngoal (1 subgoal):\n 1. poly (q' div r' * r' - s') x = - poly s' x", "by simp"], ["proof (state)\nthis:\n  poly (q' div r' * r' - s') x = - poly s' x\n\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree' p) - 2;\n        poly (sturm_squarefree' p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> sgn (poly (sturm_squarefree' p ! (i + 2)) x) =\n                         - sgn (poly (sturm_squarefree' p ! i) x)", "finally"], ["proof (chain)\npicking this:\n  poly q' x = - poly s' x", "have \"poly s' x = -poly q' x\""], ["proof (prove)\nusing this:\n  poly q' x = - poly s' x\n\ngoal (1 subgoal):\n 1. poly s' x = - poly q' x", "by simp"], ["proof (state)\nthis:\n  poly s' x = - poly q' x\n\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree' p) - 2;\n        poly (sturm_squarefree' p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> sgn (poly (sturm_squarefree' p ! (i + 2)) x) =\n                         - sgn (poly (sturm_squarefree' p ! i) x)", "thus ?case"], ["proof (prove)\nusing this:\n  poly s' x = - poly q' x\n\ngoal (1 subgoal):\n 1. sgn (poly (sturm_squarefree' p ! (i + 2)) x) =\n    - sgn (poly (sturm_squarefree' p ! i) x)", "using i_in_range"], ["proof (prove)\nusing this:\n  poly s' x = - poly q' x\n  i < length (sturm p) - 2\n\ngoal (1 subgoal):\n 1. sgn (poly (sturm_squarefree' p ! (i + 2)) x) =\n    - sgn (poly (sturm_squarefree' p ! i) x)", "unfolding q'_def s'_def q_def s_def sturm_squarefree'_def Let_def"], ["proof (prove)\nusing this:\n  poly (sturm p ! Suc (Suc i) div d) x = - poly (sturm p ! i div d) x\n  i < length (sturm p) - 2\n\ngoal (1 subgoal):\n 1. sgn (poly\n          (map (\\<lambda>p'. p' div gcd p (pderiv p)) (sturm p) ! (i + 2))\n          x) =\n    - sgn (poly (map (\\<lambda>p'. p' div gcd p (pderiv p)) (sturm p) ! i)\n            x)", "by (simp add: d_def sgn_minus)"], ["proof (state)\nthis:\n  sgn (poly (sturm_squarefree' p ! (i + 2)) x) =\n  - sgn (poly (sturm_squarefree' p ! i) x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sturm_squarefree'_adjacent_roots:\n  assumes \"p \\<noteq> 0\"\n           \"i < length (sturm_squarefree' (p :: real poly)) - 1\"\n          \"poly (sturm_squarefree' p ! i) x = 0\"\n          \"poly (sturm_squarefree' p ! (i + 1)) x = 0\"\n  shows False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "define d where \"d = gcd p (pderiv p)\""], ["proof (state)\nthis:\n  d = gcd p (pderiv p)\n\ngoal (1 subgoal):\n 1. False", "from sturm_squarefree'_adjacent_root_propagate_left[OF assms]"], ["proof (chain)\npicking this:\n  \\<forall>j\\<le>i + 1. poly (sturm_squarefree' p ! j) x = 0", "have \"poly (sturm_squarefree' p ! 0) x = 0\"\n           \"poly (sturm_squarefree' p ! 1) x = 0\""], ["proof (prove)\nusing this:\n  \\<forall>j\\<le>i + 1. poly (sturm_squarefree' p ! j) x = 0\n\ngoal (1 subgoal):\n 1. poly (sturm_squarefree' p ! 0) x = 0 &&&\n    poly (sturm_squarefree' p ! 1) x = 0", "by auto"], ["proof (state)\nthis:\n  poly (sturm_squarefree' p ! 0) x = 0\n  poly (sturm_squarefree' p ! 1) x = 0\n\ngoal (1 subgoal):\n 1. False", "hence \"poly (p div d) x = 0\" \"poly (pderiv p div d) x = 0\""], ["proof (prove)\nusing this:\n  poly (sturm_squarefree' p ! 0) x = 0\n  poly (sturm_squarefree' p ! 1) x = 0\n\ngoal (1 subgoal):\n 1. poly (p div d) x = 0 &&& poly (pderiv p div d) x = 0", "using assms(2)"], ["proof (prove)\nusing this:\n  poly (sturm_squarefree' p ! 0) x = 0\n  poly (sturm_squarefree' p ! 1) x = 0\n  i < length (sturm_squarefree' p) - 1\n\ngoal (1 subgoal):\n 1. poly (p div d) x = 0 &&& poly (pderiv p div d) x = 0", "unfolding sturm_squarefree'_def Let_def d_def"], ["proof (prove)\nusing this:\n  poly (map (\\<lambda>p'. p' div gcd p (pderiv p)) (sturm p) ! 0) x = 0\n  poly (map (\\<lambda>p'. p' div gcd p (pderiv p)) (sturm p) ! 1) x = 0\n  i < length (map (\\<lambda>p'. p' div gcd p (pderiv p)) (sturm p)) - 1\n\ngoal (1 subgoal):\n 1. poly (p div gcd p (pderiv p)) x = 0 &&&\n    poly (pderiv p div gcd p (pderiv p)) x = 0", "by auto"], ["proof (state)\nthis:\n  poly (p div d) x = 0\n  poly (pderiv p div d) x = 0\n\ngoal (1 subgoal):\n 1. False", "moreover"], ["proof (state)\nthis:\n  poly (p div d) x = 0\n  poly (pderiv p div d) x = 0\n\ngoal (1 subgoal):\n 1. False", "from div_gcd_coprime assms(1)"], ["proof (chain)\npicking this:\n  ?a \\<noteq> (0::?'a) \\<or> ?b \\<noteq> (0::?'a) \\<Longrightarrow>\n  coprime (?a div gcd ?a ?b) (?b div gcd ?a ?b)\n  p \\<noteq> 0", "have \"coprime (p div d) (pderiv p div d)\""], ["proof (prove)\nusing this:\n  ?a \\<noteq> (0::?'a) \\<or> ?b \\<noteq> (0::?'a) \\<Longrightarrow>\n  coprime (?a div gcd ?a ?b) (?b div gcd ?a ?b)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. coprime (p div d) (pderiv p div d)", "unfolding d_def"], ["proof (prove)\nusing this:\n  ?a \\<noteq> (0::?'a) \\<or> ?b \\<noteq> (0::?'a) \\<Longrightarrow>\n  coprime (?a div gcd ?a ?b) (?b div gcd ?a ?b)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. coprime (p div gcd p (pderiv p)) (pderiv p div gcd p (pderiv p))", "by auto"], ["proof (state)\nthis:\n  coprime (p div d) (pderiv p div d)\n\ngoal (1 subgoal):\n 1. False", "ultimately"], ["proof (chain)\npicking this:\n  poly (p div d) x = 0\n  poly (pderiv p div d) x = 0\n  coprime (p div d) (pderiv p div d)", "show False"], ["proof (prove)\nusing this:\n  poly (p div d) x = 0\n  poly (pderiv p div d) x = 0\n  coprime (p div d) (pderiv p div d)\n\ngoal (1 subgoal):\n 1. False", "using coprime_imp_no_common_roots"], ["proof (prove)\nusing this:\n  poly (p div d) x = 0\n  poly (pderiv p div d) x = 0\n  coprime (p div d) (pderiv p div d)\n  coprime ?p ?q \\<Longrightarrow>\n  \\<not> (poly ?p ?x = (0::?'a) \\<and> poly ?q ?x = (0::?'a))\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sturm_squarefree'_signs:\n  assumes \"p \\<noteq> 0\"\n  assumes i_in_range: \"i < length (sturm_squarefree' (p :: real poly)) - 2\"\n  assumes q_0: \"poly (sturm_squarefree' p ! (i+1)) x = 0\" (is \"poly ?q x = 0\")\n  shows \"poly (sturm_squarefree' p ! (i+2)) x *\n         poly (sturm_squarefree' p ! i) x < 0\"\n            (is \"poly ?r x * poly ?p x < 0\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (sturm_squarefree' p ! (i + 2)) x *\n    poly (sturm_squarefree' p ! i) x\n    < 0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. poly (sturm_squarefree' p ! (i + 2)) x *\n    poly (sturm_squarefree' p ! i) x\n    < 0", "define d where \"d = gcd p (pderiv p)\""], ["proof (state)\nthis:\n  d = gcd p (pderiv p)\n\ngoal (1 subgoal):\n 1. poly (sturm_squarefree' p ! (i + 2)) x *\n    poly (sturm_squarefree' p ! i) x\n    < 0", "with \\<open>p \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  d = gcd p (pderiv p)", "have [simp]: \"d \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  d = gcd p (pderiv p)\n\ngoal (1 subgoal):\n 1. d \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly (sturm_squarefree' p ! (i + 2)) x *\n    poly (sturm_squarefree' p ! i) x\n    < 0", "from poly_div_gcd_squarefree(1)[OF \\<open>p \\<noteq> 0\\<close>]\n       coprime_imp_no_common_roots"], ["proof (chain)\npicking this:\n  coprime (p div gcd p (pderiv p)) (pderiv (p div gcd p (pderiv p)))\n  coprime ?p ?q \\<Longrightarrow>\n  \\<not> (poly ?p ?x = (0::?'a) \\<and> poly ?q ?x = (0::?'a))", "have rsquarefree: \"rsquarefree (p div d)\""], ["proof (prove)\nusing this:\n  coprime (p div gcd p (pderiv p)) (pderiv (p div gcd p (pderiv p)))\n  coprime ?p ?q \\<Longrightarrow>\n  \\<not> (poly ?p ?x = (0::?'a) \\<and> poly ?q ?x = (0::?'a))\n\ngoal (1 subgoal):\n 1. rsquarefree (p div d)", "by (auto simp: rsquarefree_roots d_def)"], ["proof (state)\nthis:\n  rsquarefree (p div d)\n\ngoal (1 subgoal):\n 1. poly (sturm_squarefree' p ! (i + 2)) x *\n    poly (sturm_squarefree' p ! i) x\n    < 0", "from i_in_range"], ["proof (chain)\npicking this:\n  i < length (sturm_squarefree' p) - 2", "have i_in_range': \"i < length (sturm p) - 2\""], ["proof (prove)\nusing this:\n  i < length (sturm_squarefree' p) - 2\n\ngoal (1 subgoal):\n 1. i < length (sturm p) - 2", "unfolding sturm_squarefree'_def"], ["proof (prove)\nusing this:\n  i < length\n       (let d = gcd p (pderiv p) in map (\\<lambda>p'. p' div d) (sturm p)) -\n      2\n\ngoal (1 subgoal):\n 1. i < length (sturm p) - 2", "by simp"], ["proof (state)\nthis:\n  i < length (sturm p) - 2\n\ngoal (1 subgoal):\n 1. poly (sturm_squarefree' p ! (i + 2)) x *\n    poly (sturm_squarefree' p ! i) x\n    < 0", "hence \"d dvd (sturm p ! i)\" (is \"d dvd ?p'\")\n        \"d dvd (sturm p ! (Suc i))\" (is \"d dvd ?q'\")\n        \"d dvd (sturm p ! (Suc (Suc i)))\" (is \"d dvd ?r'\")"], ["proof (prove)\nusing this:\n  i < length (sturm p) - 2\n\ngoal (1 subgoal):\n 1. d dvd sturm p ! i &&&\n    d dvd sturm p ! Suc i &&& d dvd sturm p ! Suc (Suc i)", "unfolding d_def"], ["proof (prove)\nusing this:\n  i < length (sturm p) - 2\n\ngoal (1 subgoal):\n 1. gcd p (pderiv p) dvd sturm p ! i &&&\n    gcd p (pderiv p) dvd sturm p ! Suc i &&&\n    gcd p (pderiv p) dvd sturm p ! Suc (Suc i)", "by (auto intro: sturm_gcd)"], ["proof (state)\nthis:\n  d dvd sturm p ! i\n  d dvd sturm p ! Suc i\n  d dvd sturm p ! Suc (Suc i)\n\ngoal (1 subgoal):\n 1. poly (sturm_squarefree' p ! (i + 2)) x *\n    poly (sturm_squarefree' p ! i) x\n    < 0", "hence pqr_simps: \"?p' = ?p * d\" \"?q' = ?q * d\" \"?r' = ?r * d\""], ["proof (prove)\nusing this:\n  d dvd sturm p ! i\n  d dvd sturm p ! Suc i\n  d dvd sturm p ! Suc (Suc i)\n\ngoal (1 subgoal):\n 1. sturm p ! i = sturm_squarefree' p ! i * d &&&\n    sturm p ! Suc i = sturm_squarefree' p ! (i + 1) * d &&&\n    sturm p ! Suc (Suc i) = sturm_squarefree' p ! (i + 2) * d", "unfolding sturm_squarefree'_def Let_def d_def"], ["proof (prove)\nusing this:\n  gcd p (pderiv p) dvd sturm p ! i\n  gcd p (pderiv p) dvd sturm p ! Suc i\n  gcd p (pderiv p) dvd sturm p ! Suc (Suc i)\n\ngoal (1 subgoal):\n 1. sturm p ! i =\n    map (\\<lambda>p'. p' div gcd p (pderiv p)) (sturm p) ! i *\n    gcd p (pderiv p) &&&\n    sturm p ! Suc i =\n    map (\\<lambda>p'. p' div gcd p (pderiv p)) (sturm p) ! (i + 1) *\n    gcd p (pderiv p) &&&\n    sturm p ! Suc (Suc i) =\n    map (\\<lambda>p'. p' div gcd p (pderiv p)) (sturm p) ! (i + 2) *\n    gcd p (pderiv p)", "using i_in_range'"], ["proof (prove)\nusing this:\n  gcd p (pderiv p) dvd sturm p ! i\n  gcd p (pderiv p) dvd sturm p ! Suc i\n  gcd p (pderiv p) dvd sturm p ! Suc (Suc i)\n  i < length (sturm p) - 2\n\ngoal (1 subgoal):\n 1. sturm p ! i =\n    map (\\<lambda>p'. p' div gcd p (pderiv p)) (sturm p) ! i *\n    gcd p (pderiv p) &&&\n    sturm p ! Suc i =\n    map (\\<lambda>p'. p' div gcd p (pderiv p)) (sturm p) ! (i + 1) *\n    gcd p (pderiv p) &&&\n    sturm p ! Suc (Suc i) =\n    map (\\<lambda>p'. p' div gcd p (pderiv p)) (sturm p) ! (i + 2) *\n    gcd p (pderiv p)", "by (auto simp: dvd_div_mult_self)"], ["proof (state)\nthis:\n  sturm p ! i = sturm_squarefree' p ! i * d\n  sturm p ! Suc i = sturm_squarefree' p ! (i + 1) * d\n  sturm p ! Suc (Suc i) = sturm_squarefree' p ! (i + 2) * d\n\ngoal (1 subgoal):\n 1. poly (sturm_squarefree' p ! (i + 2)) x *\n    poly (sturm_squarefree' p ! i) x\n    < 0", "with q_0"], ["proof (chain)\npicking this:\n  poly (sturm_squarefree' p ! (i + 1)) x = 0\n  sturm p ! i = sturm_squarefree' p ! i * d\n  sturm p ! Suc i = sturm_squarefree' p ! (i + 1) * d\n  sturm p ! Suc (Suc i) = sturm_squarefree' p ! (i + 2) * d", "have q'_0: \"poly ?q' x = 0\""], ["proof (prove)\nusing this:\n  poly (sturm_squarefree' p ! (i + 1)) x = 0\n  sturm p ! i = sturm_squarefree' p ! i * d\n  sturm p ! Suc i = sturm_squarefree' p ! (i + 1) * d\n  sturm p ! Suc (Suc i) = sturm_squarefree' p ! (i + 2) * d\n\ngoal (1 subgoal):\n 1. poly (sturm p ! Suc i) x = 0", "by simp"], ["proof (state)\nthis:\n  poly (sturm p ! Suc i) x = 0\n\ngoal (1 subgoal):\n 1. poly (sturm_squarefree' p ! (i + 2)) x *\n    poly (sturm_squarefree' p ! i) x\n    < 0", "from sturm_indices[OF i_in_range']"], ["proof (chain)\npicking this:\n  sturm p ! (i + 2) = - (sturm p ! i mod sturm p ! (i + 1))", "have \"sturm p ! (i+2) = - (sturm p ! i mod sturm p ! (i+1))\""], ["proof (prove)\nusing this:\n  sturm p ! (i + 2) = - (sturm p ! i mod sturm p ! (i + 1))\n\ngoal (1 subgoal):\n 1. sturm p ! (i + 2) = - (sturm p ! i mod sturm p ! (i + 1))", "."], ["proof (state)\nthis:\n  sturm p ! (i + 2) = - (sturm p ! i mod sturm p ! (i + 1))\n\ngoal (1 subgoal):\n 1. poly (sturm_squarefree' p ! (i + 2)) x *\n    poly (sturm_squarefree' p ! i) x\n    < 0", "hence \"-?r' = ?p' mod ?q'\""], ["proof (prove)\nusing this:\n  sturm p ! (i + 2) = - (sturm p ! i mod sturm p ! (i + 1))\n\ngoal (1 subgoal):\n 1. - sturm p ! Suc (Suc i) = sturm p ! i mod sturm p ! Suc i", "by simp"], ["proof (state)\nthis:\n  - sturm p ! Suc (Suc i) = sturm p ! i mod sturm p ! Suc i\n\ngoal (1 subgoal):\n 1. poly (sturm_squarefree' p ! (i + 2)) x *\n    poly (sturm_squarefree' p ! i) x\n    < 0", "with div_mult_mod_eq[of ?p' ?q']"], ["proof (chain)\npicking this:\n  sturm p ! i div sturm p ! Suc i * sturm p ! Suc i +\n  sturm p ! i mod sturm p ! Suc i =\n  sturm p ! i\n  - sturm p ! Suc (Suc i) = sturm p ! i mod sturm p ! Suc i", "have \"?p' div ?q' * ?q' - ?r' = ?p'\""], ["proof (prove)\nusing this:\n  sturm p ! i div sturm p ! Suc i * sturm p ! Suc i +\n  sturm p ! i mod sturm p ! Suc i =\n  sturm p ! i\n  - sturm p ! Suc (Suc i) = sturm p ! i mod sturm p ! Suc i\n\ngoal (1 subgoal):\n 1. sturm p ! i div sturm p ! Suc i * sturm p ! Suc i -\n    sturm p ! Suc (Suc i) =\n    sturm p ! i", "by simp"], ["proof (state)\nthis:\n  sturm p ! i div sturm p ! Suc i * sturm p ! Suc i -\n  sturm p ! Suc (Suc i) =\n  sturm p ! i\n\ngoal (1 subgoal):\n 1. poly (sturm_squarefree' p ! (i + 2)) x *\n    poly (sturm_squarefree' p ! i) x\n    < 0", "hence \"d*(?p div ?q * ?q - ?r) = d* ?p\""], ["proof (prove)\nusing this:\n  sturm p ! i div sturm p ! Suc i * sturm p ! Suc i -\n  sturm p ! Suc (Suc i) =\n  sturm p ! i\n\ngoal (1 subgoal):\n 1. d *\n    (sturm_squarefree' p ! i div sturm_squarefree' p ! (i + 1) *\n     sturm_squarefree' p ! (i + 1) -\n     sturm_squarefree' p ! (i + 2)) =\n    d * sturm_squarefree' p ! i", "by (simp add: pqr_simps algebra_simps)"], ["proof (state)\nthis:\n  d *\n  (sturm_squarefree' p ! i div sturm_squarefree' p ! (i + 1) *\n   sturm_squarefree' p ! (i + 1) -\n   sturm_squarefree' p ! (i + 2)) =\n  d * sturm_squarefree' p ! i\n\ngoal (1 subgoal):\n 1. poly (sturm_squarefree' p ! (i + 2)) x *\n    poly (sturm_squarefree' p ! i) x\n    < 0", "hence \"?p div ?q * ?q - ?r = ?p\""], ["proof (prove)\nusing this:\n  d *\n  (sturm_squarefree' p ! i div sturm_squarefree' p ! (i + 1) *\n   sturm_squarefree' p ! (i + 1) -\n   sturm_squarefree' p ! (i + 2)) =\n  d * sturm_squarefree' p ! i\n\ngoal (1 subgoal):\n 1. sturm_squarefree' p ! i div sturm_squarefree' p ! (i + 1) *\n    sturm_squarefree' p ! (i + 1) -\n    sturm_squarefree' p ! (i + 2) =\n    sturm_squarefree' p ! i", "by simp"], ["proof (state)\nthis:\n  sturm_squarefree' p ! i div sturm_squarefree' p ! (i + 1) *\n  sturm_squarefree' p ! (i + 1) -\n  sturm_squarefree' p ! (i + 2) =\n  sturm_squarefree' p ! i\n\ngoal (1 subgoal):\n 1. poly (sturm_squarefree' p ! (i + 2)) x *\n    poly (sturm_squarefree' p ! i) x\n    < 0", "hence \"poly (?p div ?q) x * poly ?q x - poly ?r x = poly ?p x\""], ["proof (prove)\nusing this:\n  sturm_squarefree' p ! i div sturm_squarefree' p ! (i + 1) *\n  sturm_squarefree' p ! (i + 1) -\n  sturm_squarefree' p ! (i + 2) =\n  sturm_squarefree' p ! i\n\ngoal (1 subgoal):\n 1. poly (sturm_squarefree' p ! i div sturm_squarefree' p ! (i + 1)) x *\n    poly (sturm_squarefree' p ! (i + 1)) x -\n    poly (sturm_squarefree' p ! (i + 2)) x =\n    poly (sturm_squarefree' p ! i) x", "by (metis poly_diff poly_mult)"], ["proof (state)\nthis:\n  poly (sturm_squarefree' p ! i div sturm_squarefree' p ! (i + 1)) x *\n  poly (sturm_squarefree' p ! (i + 1)) x -\n  poly (sturm_squarefree' p ! (i + 2)) x =\n  poly (sturm_squarefree' p ! i) x\n\ngoal (1 subgoal):\n 1. poly (sturm_squarefree' p ! (i + 2)) x *\n    poly (sturm_squarefree' p ! i) x\n    < 0", "with q_0"], ["proof (chain)\npicking this:\n  poly (sturm_squarefree' p ! (i + 1)) x = 0\n  poly (sturm_squarefree' p ! i div sturm_squarefree' p ! (i + 1)) x *\n  poly (sturm_squarefree' p ! (i + 1)) x -\n  poly (sturm_squarefree' p ! (i + 2)) x =\n  poly (sturm_squarefree' p ! i) x", "have r_x: \"poly ?r x = -poly ?p x\""], ["proof (prove)\nusing this:\n  poly (sturm_squarefree' p ! (i + 1)) x = 0\n  poly (sturm_squarefree' p ! i div sturm_squarefree' p ! (i + 1)) x *\n  poly (sturm_squarefree' p ! (i + 1)) x -\n  poly (sturm_squarefree' p ! (i + 2)) x =\n  poly (sturm_squarefree' p ! i) x\n\ngoal (1 subgoal):\n 1. poly (sturm_squarefree' p ! (i + 2)) x =\n    - poly (sturm_squarefree' p ! i) x", "by simp"], ["proof (state)\nthis:\n  poly (sturm_squarefree' p ! (i + 2)) x =\n  - poly (sturm_squarefree' p ! i) x\n\ngoal (1 subgoal):\n 1. poly (sturm_squarefree' p ! (i + 2)) x *\n    poly (sturm_squarefree' p ! i) x\n    < 0", "from sturm_squarefree'_adjacent_roots[OF \\<open>p \\<noteq> 0\\<close>] i_in_range q_0"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i < length (sturm_squarefree' p) - 1;\n   poly (sturm_squarefree' p ! ?i) ?x = 0;\n   poly (sturm_squarefree' p ! (?i + 1)) ?x = 0\\<rbrakk>\n  \\<Longrightarrow> False\n  i < length (sturm_squarefree' p) - 2\n  poly (sturm_squarefree' p ! (i + 1)) x = 0", "have \"poly ?p x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < length (sturm_squarefree' p) - 1;\n   poly (sturm_squarefree' p ! ?i) ?x = 0;\n   poly (sturm_squarefree' p ! (?i + 1)) ?x = 0\\<rbrakk>\n  \\<Longrightarrow> False\n  i < length (sturm_squarefree' p) - 2\n  poly (sturm_squarefree' p ! (i + 1)) x = 0\n\ngoal (1 subgoal):\n 1. poly (sturm_squarefree' p ! i) x \\<noteq> 0", "by force"], ["proof (state)\nthis:\n  poly (sturm_squarefree' p ! i) x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly (sturm_squarefree' p ! (i + 2)) x *\n    poly (sturm_squarefree' p ! i) x\n    < 0", "moreover"], ["proof (state)\nthis:\n  poly (sturm_squarefree' p ! i) x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly (sturm_squarefree' p ! (i + 2)) x *\n    poly (sturm_squarefree' p ! i) x\n    < 0", "have sqr_pos: \"\\<And>x::real. x \\<noteq> 0 \\<Longrightarrow> x * x > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<noteq> 0 \\<Longrightarrow> 0 < x * x", "apply (case_tac \"x \\<ge> 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> 0; 0 \\<le> x\\<rbrakk> \\<Longrightarrow> 0 < x * x\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> 0; \\<not> 0 \\<le> x\\<rbrakk>\n       \\<Longrightarrow> 0 < x * x", "by (simp_all add: mult_neg_neg)"], ["proof (state)\nthis:\n  ?x \\<noteq> 0 \\<Longrightarrow> 0 < ?x * ?x\n\ngoal (1 subgoal):\n 1. poly (sturm_squarefree' p ! (i + 2)) x *\n    poly (sturm_squarefree' p ! i) x\n    < 0", "ultimately"], ["proof (chain)\npicking this:\n  poly (sturm_squarefree' p ! i) x \\<noteq> 0\n  ?x \\<noteq> 0 \\<Longrightarrow> 0 < ?x * ?x", "show ?thesis"], ["proof (prove)\nusing this:\n  poly (sturm_squarefree' p ! i) x \\<noteq> 0\n  ?x \\<noteq> 0 \\<Longrightarrow> 0 < ?x * ?x\n\ngoal (1 subgoal):\n 1. poly (sturm_squarefree' p ! (i + 2)) x *\n    poly (sturm_squarefree' p ! i) x\n    < 0", "using r_x"], ["proof (prove)\nusing this:\n  poly (sturm_squarefree' p ! i) x \\<noteq> 0\n  ?x \\<noteq> 0 \\<Longrightarrow> 0 < ?x * ?x\n  poly (sturm_squarefree' p ! (i + 2)) x =\n  - poly (sturm_squarefree' p ! i) x\n\ngoal (1 subgoal):\n 1. poly (sturm_squarefree' p ! (i + 2)) x *\n    poly (sturm_squarefree' p ! i) x\n    < 0", "by simp"], ["proof (state)\nthis:\n  poly (sturm_squarefree' p ! (i + 2)) x * poly (sturm_squarefree' p ! i) x\n  < 0\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  This approach indeed also yields a valid squarefree Sturm sequence\n  for the polynomial $p/\\text{gcd}(p,p')$.\n\\<close>"], ["", "lemma sturm_seq_sturm_squarefree':\n  assumes \"(p :: real poly) \\<noteq> 0\"\n  defines \"d \\<equiv> gcd p (pderiv p)\"\n  shows \"sturm_seq (sturm_squarefree' p) (p div d)\"\n      (is \"sturm_seq ?ps' ?p'\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. sturm_seq (sturm_squarefree' p) (p div d)", "proof"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>x y.\n       sgn (poly (last (sturm_squarefree' p)) x) =\n       sgn (poly (last (sturm_squarefree' p)) y)\n 2. sturm_squarefree' p \\<noteq> []\n 3. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree' p) - 2;\n        poly (sturm_squarefree' p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (sturm_squarefree' p ! (i + 2)) x *\n                         poly (sturm_squarefree' p ! i) x\n                         < 0\n 4. hd (sturm_squarefree' p) = p div d\n 5. 2 \\<le> length (sturm_squarefree' p)\n 6. \\<And>x\\<^sub>0.\n       poly (p div d) x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p div d * sturm_squarefree' p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)\n 7. \\<And>x.\n       \\<not> (poly (p div d) x = 0 \\<and>\n               poly (sturm_squarefree' p ! 1) x = 0)", "show \"?ps' \\<noteq> []\" \"hd ?ps' = ?p'\" \"2 \\<le> length ?ps'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sturm_squarefree' p \\<noteq> [] &&&\n    hd (sturm_squarefree' p) = p div d &&&\n    2 \\<le> length (sturm_squarefree' p)", "by (simp_all add: sturm_squarefree'_def d_def hd_map)"], ["proof (state)\nthis:\n  sturm_squarefree' p \\<noteq> []\n  hd (sturm_squarefree' p) = p div d\n  2 \\<le> length (sturm_squarefree' p)\n\ngoal (4 subgoals):\n 1. \\<And>x y.\n       sgn (poly (last (sturm_squarefree' p)) x) =\n       sgn (poly (last (sturm_squarefree' p)) y)\n 2. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree' p) - 2;\n        poly (sturm_squarefree' p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (sturm_squarefree' p ! (i + 2)) x *\n                         poly (sturm_squarefree' p ! i) x\n                         < 0\n 3. \\<And>x\\<^sub>0.\n       poly (p div d) x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p div d * sturm_squarefree' p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)\n 4. \\<And>x.\n       \\<not> (poly (p div d) x = 0 \\<and>\n               poly (sturm_squarefree' p ! 1) x = 0)", "from assms"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  d \\<equiv> gcd p (pderiv p)", "have \"d \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  d \\<equiv> gcd p (pderiv p)\n\ngoal (1 subgoal):\n 1. d \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  d \\<noteq> 0\n\ngoal (4 subgoals):\n 1. \\<And>x y.\n       sgn (poly (last (sturm_squarefree' p)) x) =\n       sgn (poly (last (sturm_squarefree' p)) y)\n 2. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree' p) - 2;\n        poly (sturm_squarefree' p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (sturm_squarefree' p ! (i + 2)) x *\n                         poly (sturm_squarefree' p ! i) x\n                         < 0\n 3. \\<And>x\\<^sub>0.\n       poly (p div d) x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p div d * sturm_squarefree' p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)\n 4. \\<And>x.\n       \\<not> (poly (p div d) x = 0 \\<and>\n               poly (sturm_squarefree' p ! 1) x = 0)", "{"], ["proof (state)\nthis:\n  d \\<noteq> 0\n\ngoal (4 subgoals):\n 1. \\<And>x y.\n       sgn (poly (last (sturm_squarefree' p)) x) =\n       sgn (poly (last (sturm_squarefree' p)) y)\n 2. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree' p) - 2;\n        poly (sturm_squarefree' p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (sturm_squarefree' p ! (i + 2)) x *\n                         poly (sturm_squarefree' p ! i) x\n                         < 0\n 3. \\<And>x\\<^sub>0.\n       poly (p div d) x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p div d * sturm_squarefree' p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)\n 4. \\<And>x.\n       \\<not> (poly (p div d) x = 0 \\<and>\n               poly (sturm_squarefree' p ! 1) x = 0)", "have \"d dvd last (sturm p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d dvd last (sturm p)", "unfolding d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd p (pderiv p) dvd last (sturm p)", "by (rule sturm_gcd, simp)"], ["proof (state)\nthis:\n  d dvd last (sturm p)\n\ngoal (4 subgoals):\n 1. \\<And>x y.\n       sgn (poly (last (sturm_squarefree' p)) x) =\n       sgn (poly (last (sturm_squarefree' p)) y)\n 2. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree' p) - 2;\n        poly (sturm_squarefree' p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (sturm_squarefree' p ! (i + 2)) x *\n                         poly (sturm_squarefree' p ! i) x\n                         < 0\n 3. \\<And>x\\<^sub>0.\n       poly (p div d) x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p div d * sturm_squarefree' p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)\n 4. \\<And>x.\n       \\<not> (poly (p div d) x = 0 \\<and>\n               poly (sturm_squarefree' p ! 1) x = 0)", "hence *: \"last (sturm p) = last ?ps' * d\""], ["proof (prove)\nusing this:\n  d dvd last (sturm p)\n\ngoal (1 subgoal):\n 1. last (sturm p) = last (sturm_squarefree' p) * d", "by (simp add: sturm_squarefree'_def last_map d_def dvd_div_mult_self)"], ["proof (state)\nthis:\n  last (sturm p) = last (sturm_squarefree' p) * d\n\ngoal (4 subgoals):\n 1. \\<And>x y.\n       sgn (poly (last (sturm_squarefree' p)) x) =\n       sgn (poly (last (sturm_squarefree' p)) y)\n 2. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree' p) - 2;\n        poly (sturm_squarefree' p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (sturm_squarefree' p ! (i + 2)) x *\n                         poly (sturm_squarefree' p ! i) x\n                         < 0\n 3. \\<And>x\\<^sub>0.\n       poly (p div d) x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p div d * sturm_squarefree' p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)\n 4. \\<And>x.\n       \\<not> (poly (p div d) x = 0 \\<and>\n               poly (sturm_squarefree' p ! 1) x = 0)", "then"], ["proof (chain)\npicking this:\n  last (sturm p) = last (sturm_squarefree' p) * d", "have \"last ?ps' dvd last (sturm p)\""], ["proof (prove)\nusing this:\n  last (sturm p) = last (sturm_squarefree' p) * d\n\ngoal (1 subgoal):\n 1. last (sturm_squarefree' p) dvd last (sturm p)", "by simp"], ["proof (state)\nthis:\n  last (sturm_squarefree' p) dvd last (sturm p)\n\ngoal (4 subgoals):\n 1. \\<And>x y.\n       sgn (poly (last (sturm_squarefree' p)) x) =\n       sgn (poly (last (sturm_squarefree' p)) y)\n 2. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree' p) - 2;\n        poly (sturm_squarefree' p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (sturm_squarefree' p ! (i + 2)) x *\n                         poly (sturm_squarefree' p ! i) x\n                         < 0\n 3. \\<And>x\\<^sub>0.\n       poly (p div d) x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p div d * sturm_squarefree' p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)\n 4. \\<And>x.\n       \\<not> (poly (p div d) x = 0 \\<and>\n               poly (sturm_squarefree' p ! 1) x = 0)", "with * dvd_imp_degree_le[OF this]"], ["proof (chain)\npicking this:\n  last (sturm p) = last (sturm_squarefree' p) * d\n  last (sturm p) \\<noteq> 0 \\<Longrightarrow>\n  degree (last (sturm_squarefree' p)) \\<le> degree (last (sturm p))\n  last (sturm_squarefree' p) dvd last (sturm p)", "have \"degree (last ?ps') \\<le> degree (last (sturm p))\""], ["proof (prove)\nusing this:\n  last (sturm p) = last (sturm_squarefree' p) * d\n  last (sturm p) \\<noteq> 0 \\<Longrightarrow>\n  degree (last (sturm_squarefree' p)) \\<le> degree (last (sturm p))\n  last (sturm_squarefree' p) dvd last (sturm p)\n\ngoal (1 subgoal):\n 1. degree (last (sturm_squarefree' p)) \\<le> degree (last (sturm p))", "using \\<open>d \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  last (sturm p) = last (sturm_squarefree' p) * d\n  last (sturm p) \\<noteq> 0 \\<Longrightarrow>\n  degree (last (sturm_squarefree' p)) \\<le> degree (last (sturm p))\n  last (sturm_squarefree' p) dvd last (sturm p)\n  d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (last (sturm_squarefree' p)) \\<le> degree (last (sturm p))", "by (cases \"last ?ps' = 0\") auto"], ["proof (state)\nthis:\n  degree (last (sturm_squarefree' p)) \\<le> degree (last (sturm p))\n\ngoal (4 subgoals):\n 1. \\<And>x y.\n       sgn (poly (last (sturm_squarefree' p)) x) =\n       sgn (poly (last (sturm_squarefree' p)) y)\n 2. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree' p) - 2;\n        poly (sturm_squarefree' p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (sturm_squarefree' p ! (i + 2)) x *\n                         poly (sturm_squarefree' p ! i) x\n                         < 0\n 3. \\<And>x\\<^sub>0.\n       poly (p div d) x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p div d * sturm_squarefree' p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)\n 4. \\<And>x.\n       \\<not> (poly (p div d) x = 0 \\<and>\n               poly (sturm_squarefree' p ! 1) x = 0)", "hence \"degree (last ?ps') = 0\""], ["proof (prove)\nusing this:\n  degree (last (sturm_squarefree' p)) \\<le> degree (last (sturm p))\n\ngoal (1 subgoal):\n 1. degree (last (sturm_squarefree' p)) = 0", "by simp"], ["proof (state)\nthis:\n  degree (last (sturm_squarefree' p)) = 0\n\ngoal (4 subgoals):\n 1. \\<And>x y.\n       sgn (poly (last (sturm_squarefree' p)) x) =\n       sgn (poly (last (sturm_squarefree' p)) y)\n 2. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree' p) - 2;\n        poly (sturm_squarefree' p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (sturm_squarefree' p ! (i + 2)) x *\n                         poly (sturm_squarefree' p ! i) x\n                         < 0\n 3. \\<And>x\\<^sub>0.\n       poly (p div d) x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p div d * sturm_squarefree' p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)\n 4. \\<And>x.\n       \\<not> (poly (p div d) x = 0 \\<and>\n               poly (sturm_squarefree' p ! 1) x = 0)", "then"], ["proof (chain)\npicking this:\n  degree (last (sturm_squarefree' p)) = 0", "obtain c where \"last ?ps' = [:c:]\""], ["proof (prove)\nusing this:\n  degree (last (sturm_squarefree' p)) = 0\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        last (sturm_squarefree' p) = [:c:] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"last ?ps'\", simp split: if_split_asm)"], ["proof (state)\nthis:\n  last (sturm_squarefree' p) = [:c:]\n\ngoal (4 subgoals):\n 1. \\<And>x y.\n       sgn (poly (last (sturm_squarefree' p)) x) =\n       sgn (poly (last (sturm_squarefree' p)) y)\n 2. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree' p) - 2;\n        poly (sturm_squarefree' p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (sturm_squarefree' p ! (i + 2)) x *\n                         poly (sturm_squarefree' p ! i) x\n                         < 0\n 3. \\<And>x\\<^sub>0.\n       poly (p div d) x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p div d * sturm_squarefree' p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)\n 4. \\<And>x.\n       \\<not> (poly (p div d) x = 0 \\<and>\n               poly (sturm_squarefree' p ! 1) x = 0)", "thus \"\\<And>x y. sgn (poly (last ?ps') x) = sgn (poly (last ?ps') y)\""], ["proof (prove)\nusing this:\n  last (sturm_squarefree' p) = [:c:]\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       sgn (poly (last (sturm_squarefree' p)) x) =\n       sgn (poly (last (sturm_squarefree' p)) y)", "by simp"], ["proof (state)\nthis:\n  sgn (poly (last (sturm_squarefree' p)) ?x) =\n  sgn (poly (last (sturm_squarefree' p)) ?y)\n\ngoal (3 subgoals):\n 1. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree' p) - 2;\n        poly (sturm_squarefree' p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (sturm_squarefree' p ! (i + 2)) x *\n                         poly (sturm_squarefree' p ! i) x\n                         < 0\n 2. \\<And>x\\<^sub>0.\n       poly (p div d) x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p div d * sturm_squarefree' p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)\n 3. \\<And>x.\n       \\<not> (poly (p div d) x = 0 \\<and>\n               poly (sturm_squarefree' p ! 1) x = 0)", "}"], ["proof (state)\nthis:\n  sgn (poly (last (sturm_squarefree' p)) ?x5) =\n  sgn (poly (last (sturm_squarefree' p)) ?y5)\n\ngoal (3 subgoals):\n 1. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree' p) - 2;\n        poly (sturm_squarefree' p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (sturm_squarefree' p ! (i + 2)) x *\n                         poly (sturm_squarefree' p ! i) x\n                         < 0\n 2. \\<And>x\\<^sub>0.\n       poly (p div d) x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p div d * sturm_squarefree' p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)\n 3. \\<And>x.\n       \\<not> (poly (p div d) x = 0 \\<and>\n               poly (sturm_squarefree' p ! 1) x = 0)", "have squarefree: \"rsquarefree ?p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rsquarefree (p div d)", "using \\<open>p \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. rsquarefree (p div d)", "by (subst rsquarefree_roots, unfold d_def,\n        intro allI coprime_imp_no_common_roots poly_div_gcd_squarefree)"], ["proof (state)\nthis:\n  rsquarefree (p div d)\n\ngoal (3 subgoals):\n 1. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree' p) - 2;\n        poly (sturm_squarefree' p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (sturm_squarefree' p ! (i + 2)) x *\n                         poly (sturm_squarefree' p ! i) x\n                         < 0\n 2. \\<And>x\\<^sub>0.\n       poly (p div d) x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p div d * sturm_squarefree' p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)\n 3. \\<And>x.\n       \\<not> (poly (p div d) x = 0 \\<and>\n               poly (sturm_squarefree' p ! 1) x = 0)", "have [simp]: \"sturm_squarefree' p ! Suc 0 = pderiv p div d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sturm_squarefree' p ! Suc 0 = pderiv p div d", "unfolding sturm_squarefree'_def Let_def sturm_def d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>p'. p' div gcd p (pderiv p)) (sturm_aux p (pderiv p)) !\n    Suc 0 =\n    pderiv p div gcd p (pderiv p)", "by (subst sturm_aux.simps, simp)"], ["proof (state)\nthis:\n  sturm_squarefree' p ! Suc 0 = pderiv p div d\n\ngoal (3 subgoals):\n 1. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree' p) - 2;\n        poly (sturm_squarefree' p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (sturm_squarefree' p ! (i + 2)) x *\n                         poly (sturm_squarefree' p ! i) x\n                         < 0\n 2. \\<And>x\\<^sub>0.\n       poly (p div d) x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p div d * sturm_squarefree' p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)\n 3. \\<And>x.\n       \\<not> (poly (p div d) x = 0 \\<and>\n               poly (sturm_squarefree' p ! 1) x = 0)", "have coprime: \"coprime ?p' (pderiv p div d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime (p div d) (pderiv p div d)", "unfolding d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime (p div gcd p (pderiv p)) (pderiv p div gcd p (pderiv p))", "using div_gcd_coprime \\<open>p \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  ?a \\<noteq> (0::?'a) \\<or> ?b \\<noteq> (0::?'a) \\<Longrightarrow>\n  coprime (?a div gcd ?a ?b) (?b div gcd ?a ?b)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. coprime (p div gcd p (pderiv p)) (pderiv p div gcd p (pderiv p))", "by blast"], ["proof (state)\nthis:\n  coprime (p div d) (pderiv p div d)\n\ngoal (3 subgoals):\n 1. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree' p) - 2;\n        poly (sturm_squarefree' p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (sturm_squarefree' p ! (i + 2)) x *\n                         poly (sturm_squarefree' p ! i) x\n                         < 0\n 2. \\<And>x\\<^sub>0.\n       poly (p div d) x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p div d * sturm_squarefree' p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)\n 3. \\<And>x.\n       \\<not> (poly (p div d) x = 0 \\<and>\n               poly (sturm_squarefree' p ! 1) x = 0)", "thus squarefree':\n      \"\\<And>x. \\<not> (poly (p div d) x = 0 \\<and> poly (sturm_squarefree' p ! 1) x = 0)\""], ["proof (prove)\nusing this:\n  coprime (p div d) (pderiv p div d)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<not> (poly (p div d) x = 0 \\<and>\n               poly (sturm_squarefree' p ! 1) x = 0)", "using coprime_imp_no_common_roots"], ["proof (prove)\nusing this:\n  coprime (p div d) (pderiv p div d)\n  coprime ?p ?q \\<Longrightarrow>\n  \\<not> (poly ?p ?x = (0::?'a) \\<and> poly ?q ?x = (0::?'a))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<not> (poly (p div d) x = 0 \\<and>\n               poly (sturm_squarefree' p ! 1) x = 0)", "by simp"], ["proof (state)\nthis:\n  \\<not> (poly (p div d) ?x = 0 \\<and>\n          poly (sturm_squarefree' p ! 1) ?x = 0)\n\ngoal (2 subgoals):\n 1. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree' p) - 2;\n        poly (sturm_squarefree' p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (sturm_squarefree' p ! (i + 2)) x *\n                         poly (sturm_squarefree' p ! i) x\n                         < 0\n 2. \\<And>x\\<^sub>0.\n       poly (p div d) x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p div d * sturm_squarefree' p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)", "from sturm_squarefree'_signs[OF \\<open>p \\<noteq> 0\\<close>]"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i < length (sturm_squarefree' p) - 2;\n   poly (sturm_squarefree' p ! (?i + 1)) ?x = 0\\<rbrakk>\n  \\<Longrightarrow> poly (sturm_squarefree' p ! (?i + 2)) ?x *\n                    poly (sturm_squarefree' p ! ?i) ?x\n                    < 0", "show \"\\<And>i x. \\<lbrakk>i < length ?ps' - 2; poly (?ps' ! (i + 1)) x = 0\\<rbrakk>\n                \\<Longrightarrow> poly (?ps' ! (i + 2)) x * poly (?ps' ! i) x < 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < length (sturm_squarefree' p) - 2;\n   poly (sturm_squarefree' p ! (?i + 1)) ?x = 0\\<rbrakk>\n  \\<Longrightarrow> poly (sturm_squarefree' p ! (?i + 2)) ?x *\n                    poly (sturm_squarefree' p ! ?i) ?x\n                    < 0\n\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i < length (sturm_squarefree' p) - 2;\n        poly (sturm_squarefree' p ! (i + 1)) x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (sturm_squarefree' p ! (i + 2)) x *\n                         poly (sturm_squarefree' p ! i) x\n                         < 0", "."], ["proof (state)\nthis:\n  \\<lbrakk>?i < length (sturm_squarefree' p) - 2;\n   poly (sturm_squarefree' p ! (?i + 1)) ?x = 0\\<rbrakk>\n  \\<Longrightarrow> poly (sturm_squarefree' p ! (?i + 2)) ?x *\n                    poly (sturm_squarefree' p ! ?i) ?x\n                    < 0\n\ngoal (1 subgoal):\n 1. \\<And>x\\<^sub>0.\n       poly (p div d) x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p div d * sturm_squarefree' p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)", "have [simp]: \"?p' \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p div d \\<noteq> 0", "using squarefree"], ["proof (prove)\nusing this:\n  rsquarefree (p div d)\n\ngoal (1 subgoal):\n 1. p div d \\<noteq> 0", "by (simp add: rsquarefree_def)"], ["proof (state)\nthis:\n  p div d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x\\<^sub>0.\n       poly (p div d) x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p div d * sturm_squarefree' p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)", "have A: \"?p' = ?ps' ! 0\" \"pderiv p div d = ?ps' ! 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p div d = sturm_squarefree' p ! 0 &&&\n    pderiv p div d = sturm_squarefree' p ! 1", "by (simp_all add: sturm_squarefree'_def Let_def d_def sturm_def,\n          subst sturm_aux.simps, simp)"], ["proof (state)\nthis:\n  p div d = sturm_squarefree' p ! 0\n  pderiv p div d = sturm_squarefree' p ! 1\n\ngoal (1 subgoal):\n 1. \\<And>x\\<^sub>0.\n       poly (p div d) x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p div d * sturm_squarefree' p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)", "have [simp]: \"?ps' ! 0 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sturm_squarefree' p ! 0 \\<noteq> 0", "using squarefree"], ["proof (prove)\nusing this:\n  rsquarefree (p div d)\n\ngoal (1 subgoal):\n 1. sturm_squarefree' p ! 0 \\<noteq> 0", "by (auto simp: A rsquarefree_def)"], ["proof (state)\nthis:\n  sturm_squarefree' p ! 0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x\\<^sub>0.\n       poly (p div d) x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p div d * sturm_squarefree' p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)", "fix x\\<^sub>0 :: real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x\\<^sub>0.\n       poly (p div d) x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p div d * sturm_squarefree' p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)", "assume \"poly ?p' x\\<^sub>0 = 0\""], ["proof (state)\nthis:\n  poly (p div d) x\\<^sub>0 = 0\n\ngoal (1 subgoal):\n 1. \\<And>x\\<^sub>0.\n       poly (p div d) x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p div d * sturm_squarefree' p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)", "hence \"poly p x\\<^sub>0 = 0\""], ["proof (prove)\nusing this:\n  poly (p div d) x\\<^sub>0 = 0\n\ngoal (1 subgoal):\n 1. poly p x\\<^sub>0 = 0", "using poly_div_gcd_squarefree(2)[OF \\<open>p \\<noteq> 0\\<close>]"], ["proof (prove)\nusing this:\n  poly (p div d) x\\<^sub>0 = 0\n  (poly (p div gcd p (pderiv p)) ?x = 0) = (poly p ?x = 0)\n\ngoal (1 subgoal):\n 1. poly p x\\<^sub>0 = 0", "unfolding d_def"], ["proof (prove)\nusing this:\n  poly (p div gcd p (pderiv p)) x\\<^sub>0 = 0\n  (poly (p div gcd p (pderiv p)) ?x = 0) = (poly p ?x = 0)\n\ngoal (1 subgoal):\n 1. poly p x\\<^sub>0 = 0", "by simp"], ["proof (state)\nthis:\n  poly p x\\<^sub>0 = 0\n\ngoal (1 subgoal):\n 1. \\<And>x\\<^sub>0.\n       poly (p div d) x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p div d * sturm_squarefree' p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)", "hence \"pderiv p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  poly p x\\<^sub>0 = 0\n\ngoal (1 subgoal):\n 1. pderiv p \\<noteq> 0", "using \\<open>p \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  poly p x\\<^sub>0 = 0\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pderiv p \\<noteq> 0", "by (auto dest: pderiv_iszero)"], ["proof (state)\nthis:\n  pderiv p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x\\<^sub>0.\n       poly (p div d) x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p div d * sturm_squarefree' p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)", "with \\<open>p \\<noteq> 0\\<close> \\<open>poly p x\\<^sub>0 = 0\\<close>"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  poly p x\\<^sub>0 = 0\n  pderiv p \\<noteq> 0", "have A: \"eventually (\\<lambda>x. sgn (poly (p * pderiv p) x) =\n                              (if x\\<^sub>0 < x then 1 else -1)) (at x\\<^sub>0)\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  poly p x\\<^sub>0 = 0\n  pderiv p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sgn (poly (p * pderiv p) x) = (if x\\<^sub>0 < x then 1 else - 1)", "by (intro sturm_firsttwo_signs_aux, simp_all)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     sgn (poly (p * pderiv p) x) = (if x\\<^sub>0 < x then 1 else - 1)\n\ngoal (1 subgoal):\n 1. \\<And>x\\<^sub>0.\n       poly (p div d) x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p div d * sturm_squarefree' p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)", "note ev = eventually_conj[OF A poly_neighbourhood_without_roots[OF \\<open>d \\<noteq> 0\\<close>]]"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     sgn (poly (p * pderiv p) x) = (if x\\<^sub>0 < x then 1 else - 1) \\<and>\n     poly d x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x\\<^sub>0.\n       poly (p div d) x\\<^sub>0 = 0 \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at x\\<^sub>0.\n          sgn (poly (p div d * sturm_squarefree' p ! 1) x) =\n          (if x\\<^sub>0 < x then 1 else - 1)", "show \"eventually (\\<lambda>x. sgn (poly (p div d * sturm_squarefree' p ! 1) x) =\n                        (if x\\<^sub>0 < x then 1 else -1)) (at x\\<^sub>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x\\<^sub>0.\n       sgn (poly (p div d * sturm_squarefree' p ! 1) x) =\n       (if x\\<^sub>0 < x then 1 else - 1)", "proof (rule eventually_mono[OF ev], goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       sgn (poly (p * pderiv p) x) =\n       (if x\\<^sub>0 < x then 1 else - 1) \\<and>\n       poly d x \\<noteq> 0 \\<Longrightarrow>\n       sgn (poly (p div d * sturm_squarefree' p ! 1) x) =\n       (if x\\<^sub>0 < x then 1 else - 1)", "have [intro]:\n          \"\\<And>a (b::real). b \\<noteq> 0 \\<Longrightarrow> a < 0 \\<Longrightarrow> a / (b * b) < 0\"\n          \"\\<And>a (b::real). b \\<noteq> 0 \\<Longrightarrow> a > 0 \\<Longrightarrow> a / (b * b) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>b \\<noteq> 0; a < 0\\<rbrakk>\n        \\<Longrightarrow> a / (b * b) < 0) &&&\n    (\\<And>a b.\n        \\<lbrakk>b \\<noteq> 0; 0 < a\\<rbrakk>\n        \\<Longrightarrow> 0 < a / (b * b))", "by ((case_tac \"b > 0\",\n              auto simp: mult_neg_neg field_simps) [])+"], ["proof (state)\nthis:\n  \\<lbrakk>?b \\<noteq> 0; ?a < 0\\<rbrakk>\n  \\<Longrightarrow> ?a / (?b * ?b) < 0\n  \\<lbrakk>?b \\<noteq> 0; 0 < ?a\\<rbrakk>\n  \\<Longrightarrow> 0 < ?a / (?b * ?b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       sgn (poly (p * pderiv p) x) =\n       (if x\\<^sub>0 < x then 1 else - 1) \\<and>\n       poly d x \\<noteq> 0 \\<Longrightarrow>\n       sgn (poly (p div d * sturm_squarefree' p ! 1) x) =\n       (if x\\<^sub>0 < x then 1 else - 1)", "case prems: (1 x)"], ["proof (state)\nthis:\n  sgn (poly (p * pderiv p) x) = (if x\\<^sub>0 < x then 1 else - 1) \\<and>\n  poly d x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       sgn (poly (p * pderiv p) x) =\n       (if x\\<^sub>0 < x then 1 else - 1) \\<and>\n       poly d x \\<noteq> 0 \\<Longrightarrow>\n       sgn (poly (p div d * sturm_squarefree' p ! 1) x) =\n       (if x\\<^sub>0 < x then 1 else - 1)", "hence  [simp]: \"poly d x * poly d x > 0\""], ["proof (prove)\nusing this:\n  sgn (poly (p * pderiv p) x) = (if x\\<^sub>0 < x then 1 else - 1) \\<and>\n  poly d x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < poly d x * poly d x", "by (cases \"poly d x > 0\", auto simp: mult_neg_neg)"], ["proof (state)\nthis:\n  0 < poly d x * poly d x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       sgn (poly (p * pderiv p) x) =\n       (if x\\<^sub>0 < x then 1 else - 1) \\<and>\n       poly d x \\<noteq> 0 \\<Longrightarrow>\n       sgn (poly (p div d * sturm_squarefree' p ! 1) x) =\n       (if x\\<^sub>0 < x then 1 else - 1)", "from poly_div_gcd_squarefree_aux(2)[OF \\<open>pderiv p \\<noteq> 0\\<close>]"], ["proof (chain)\npicking this:\n  (poly (p div gcd p (pderiv p)) ?x = 0) = (poly p ?x = 0)", "have \"poly (p div d) x = 0 \\<longleftrightarrow> poly p x = 0\""], ["proof (prove)\nusing this:\n  (poly (p div gcd p (pderiv p)) ?x = 0) = (poly p ?x = 0)\n\ngoal (1 subgoal):\n 1. (poly (p div d) x = 0) = (poly p x = 0)", "by (simp add: d_def)"], ["proof (state)\nthis:\n  (poly (p div d) x = 0) = (poly p x = 0)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       sgn (poly (p * pderiv p) x) =\n       (if x\\<^sub>0 < x then 1 else - 1) \\<and>\n       poly d x \\<noteq> 0 \\<Longrightarrow>\n       sgn (poly (p div d * sturm_squarefree' p ! 1) x) =\n       (if x\\<^sub>0 < x then 1 else - 1)", "moreover"], ["proof (state)\nthis:\n  (poly (p div d) x = 0) = (poly p x = 0)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       sgn (poly (p * pderiv p) x) =\n       (if x\\<^sub>0 < x then 1 else - 1) \\<and>\n       poly d x \\<noteq> 0 \\<Longrightarrow>\n       sgn (poly (p div d * sturm_squarefree' p ! 1) x) =\n       (if x\\<^sub>0 < x then 1 else - 1)", "have \"d dvd p\" \"d dvd pderiv p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d dvd p &&& d dvd pderiv p", "unfolding d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd p (pderiv p) dvd p &&& gcd p (pderiv p) dvd pderiv p", "by simp_all"], ["proof (state)\nthis:\n  d dvd p\n  d dvd pderiv p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       sgn (poly (p * pderiv p) x) =\n       (if x\\<^sub>0 < x then 1 else - 1) \\<and>\n       poly d x \\<noteq> 0 \\<Longrightarrow>\n       sgn (poly (p div d * sturm_squarefree' p ! 1) x) =\n       (if x\\<^sub>0 < x then 1 else - 1)", "ultimately"], ["proof (chain)\npicking this:\n  (poly (p div d) x = 0) = (poly p x = 0)\n  d dvd p\n  d dvd pderiv p", "show ?case"], ["proof (prove)\nusing this:\n  (poly (p div d) x = 0) = (poly p x = 0)\n  d dvd p\n  d dvd pderiv p\n\ngoal (1 subgoal):\n 1. sgn (poly (p div d * sturm_squarefree' p ! 1) x) =\n    (if x\\<^sub>0 < x then 1 else - 1)", "using prems"], ["proof (prove)\nusing this:\n  (poly (p div d) x = 0) = (poly p x = 0)\n  d dvd p\n  d dvd pderiv p\n  sgn (poly (p * pderiv p) x) = (if x\\<^sub>0 < x then 1 else - 1) \\<and>\n  poly d x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sgn (poly (p div d * sturm_squarefree' p ! 1) x) =\n    (if x\\<^sub>0 < x then 1 else - 1)", "by (auto simp: sgn_real_def poly_div not_less[symmetric]\n                         zero_less_divide_iff split: if_split_asm)"], ["proof (state)\nthis:\n  sgn (poly (p div d * sturm_squarefree' p ! 1) x) =\n  (if x\\<^sub>0 < x then 1 else - 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at x\\<^sub>0.\n     sgn (poly (p div d * sturm_squarefree' p ! 1) x) =\n     (if x\\<^sub>0 < x then 1 else - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  This construction is obviously more expensive to compute than the one that \\emph{first}\n  divides $p$ by $\\text{gcd}(p,p')$ and \\emph{then} applies the canonical construction.\n  In this construction, we \\emph{first} compute the canonical Sturm sequence of $p$ as if\n  it had no multiple roots and \\emph{then} divide by the GCD.\n  However, it can be seen quite easily that unless $x$ is a multiple root of $p$,\n  i.\\,e. as long as $\\text{gcd}(P,P')\\neq 0$, the number of sign changes in a sequence of\n  polynomials does not actually change when we divide the polynomials by $\\text{gcd}(p,p')$.\\\\\n  There\\-fore we can use the ca\\-no\\-ni\\-cal Sturm se\\-quence even in the non-square\\-free\n  case as long as the borders of the interval we are interested in are not multiple roots\n  of the polynomial.\n\\<close>"], ["", "lemma sign_changes_mult_aux:\n  assumes \"d \\<noteq> (0::real)\"\n  shows \"length (remdups_adj (filter (\\<lambda>x. x \\<noteq> 0) (map ((*) d \\<circ> f) xs))) =\n         length (remdups_adj (filter (\\<lambda>x. x \\<noteq> 0) (map f xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (remdups_adj\n       (filter (\\<lambda>x. x \\<noteq> 0) (map ((*) d \\<circ> f) xs))) =\n    length (remdups_adj (filter (\\<lambda>x. x \\<noteq> 0) (map f xs)))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. length\n     (remdups_adj\n       (filter (\\<lambda>x. x \\<noteq> 0) (map ((*) d \\<circ> f) xs))) =\n    length (remdups_adj (filter (\\<lambda>x. x \\<noteq> 0) (map f xs)))", "from assms"], ["proof (chain)\npicking this:\n  d \\<noteq> 0", "have inj: \"inj ((*) d)\""], ["proof (prove)\nusing this:\n  d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. inj ((*) d)", "by (auto intro: injI)"], ["proof (state)\nthis:\n  inj ((*) d)\n\ngoal (1 subgoal):\n 1. length\n     (remdups_adj\n       (filter (\\<lambda>x. x \\<noteq> 0) (map ((*) d \\<circ> f) xs))) =\n    length (remdups_adj (filter (\\<lambda>x. x \\<noteq> 0) (map f xs)))", "from assms"], ["proof (chain)\npicking this:\n  d \\<noteq> 0", "have [simp]: \"filter (\\<lambda>x. ((*) d \\<circ> f) x \\<noteq> 0) = filter (\\<lambda>x. f x \\<noteq> 0)\"\n                          \"filter ((\\<lambda>x. x \\<noteq> 0) \\<circ> f) = filter (\\<lambda>x. f x \\<noteq> 0)\""], ["proof (prove)\nusing this:\n  d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. ((*) d \\<circ> f) x \\<noteq> 0) =\n    filter (\\<lambda>x. f x \\<noteq> 0) &&&\n    filter ((\\<lambda>x. x \\<noteq> 0) \\<circ> f) =\n    filter (\\<lambda>x. f x \\<noteq> 0)", "by (simp_all add: o_def)"], ["proof (state)\nthis:\n  filter (\\<lambda>x. ((*) d \\<circ> f) x \\<noteq> 0) =\n  filter (\\<lambda>x. f x \\<noteq> 0)\n  filter ((\\<lambda>x. x \\<noteq> 0) \\<circ> f) =\n  filter (\\<lambda>x. f x \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. length\n     (remdups_adj\n       (filter (\\<lambda>x. x \\<noteq> 0) (map ((*) d \\<circ> f) xs))) =\n    length (remdups_adj (filter (\\<lambda>x. x \\<noteq> 0) (map f xs)))", "have \"filter (\\<lambda>x. x \\<noteq> 0) (map ((*) d \\<circ> f) xs) =\n        map ((*) d \\<circ> f) (filter (\\<lambda>x. ((*) d \\<circ> f) x \\<noteq> 0) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<noteq> 0) (map ((*) d \\<circ> f) xs) =\n    map ((*) d \\<circ> f)\n     (filter (\\<lambda>x. ((*) d \\<circ> f) x \\<noteq> 0) xs)", "by (simp add: filter_map o_def)"], ["proof (state)\nthis:\n  filter (\\<lambda>x. x \\<noteq> 0) (map ((*) d \\<circ> f) xs) =\n  map ((*) d \\<circ> f)\n   (filter (\\<lambda>x. ((*) d \\<circ> f) x \\<noteq> 0) xs)\n\ngoal (1 subgoal):\n 1. length\n     (remdups_adj\n       (filter (\\<lambda>x. x \\<noteq> 0) (map ((*) d \\<circ> f) xs))) =\n    length (remdups_adj (filter (\\<lambda>x. x \\<noteq> 0) (map f xs)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  filter (\\<lambda>x. x \\<noteq> 0) (map ((*) d \\<circ> f) xs) =\n  map ((*) d \\<circ> f)\n   (filter (\\<lambda>x. ((*) d \\<circ> f) x \\<noteq> 0) xs)\n\ngoal (1 subgoal):\n 1. length\n     (remdups_adj\n       (filter (\\<lambda>x. x \\<noteq> 0) (map ((*) d \\<circ> f) xs))) =\n    length (remdups_adj (filter (\\<lambda>x. x \\<noteq> 0) (map f xs)))", "using remdups_adj_map_injective[OF inj] assms"], ["proof (prove)\nusing this:\n  filter (\\<lambda>x. x \\<noteq> 0) (map ((*) d \\<circ> f) xs) =\n  map ((*) d \\<circ> f)\n   (filter (\\<lambda>x. ((*) d \\<circ> f) x \\<noteq> 0) xs)\n  remdups_adj (map ((*) d) ?xs) = map ((*) d) (remdups_adj ?xs)\n  d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. length\n     (remdups_adj\n       (filter (\\<lambda>x. x \\<noteq> 0) (map ((*) d \\<circ> f) xs))) =\n    length (remdups_adj (filter (\\<lambda>x. x \\<noteq> 0) (map f xs)))", "by (simp add: filter_map map_map[symmetric] del: map_map)"], ["proof (state)\nthis:\n  length\n   (remdups_adj\n     (filter (\\<lambda>x. x \\<noteq> 0) (map ((*) d \\<circ> f) xs))) =\n  length (remdups_adj (filter (\\<lambda>x. x \\<noteq> 0) (map f xs)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sturm_sturm_squarefree'_same_sign_changes:\n  fixes p :: \"real poly\"\n  defines \"ps \\<equiv> sturm p\" and \"ps' \\<equiv> sturm_squarefree' p\"\n  shows \"poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n             sign_changes ps' x = sign_changes ps x\"\n        \"p \\<noteq> 0 \\<Longrightarrow> sign_changes_inf ps' = sign_changes_inf ps\"\n        \"p \\<noteq> 0 \\<Longrightarrow> sign_changes_neg_inf ps' = sign_changes_neg_inf ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly p x \\<noteq> 0 \\<or>\n     poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n     sign_changes ps' x = sign_changes ps x) &&&\n    (p \\<noteq> 0 \\<Longrightarrow>\n     sign_changes_inf ps' = sign_changes_inf ps) &&&\n    (p \\<noteq> 0 \\<Longrightarrow>\n     sign_changes_neg_inf ps' = sign_changes_neg_inf ps)", "proof-"], ["proof (state)\ngoal (3 subgoals):\n 1. poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n    sign_changes ps' x = sign_changes ps x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 3. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "define d where \"d = gcd p (pderiv p)\""], ["proof (state)\nthis:\n  d = gcd p (pderiv p)\n\ngoal (3 subgoals):\n 1. poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n    sign_changes ps' x = sign_changes ps x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 3. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "define p' where \"p' = p div d\""], ["proof (state)\nthis:\n  p' = p div d\n\ngoal (3 subgoals):\n 1. poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n    sign_changes ps' x = sign_changes ps x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 3. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "define s' where \"s' = poly_inf d\""], ["proof (state)\nthis:\n  s' = poly_inf d\n\ngoal (3 subgoals):\n 1. poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n    sign_changes ps' x = sign_changes ps x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 3. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "define s'' where \"s'' = poly_neg_inf d\""], ["proof (state)\nthis:\n  s'' = poly_neg_inf d\n\ngoal (3 subgoals):\n 1. poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n    sign_changes ps' x = sign_changes ps x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 3. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "{"], ["proof (state)\nthis:\n  s'' = poly_neg_inf d\n\ngoal (3 subgoals):\n 1. poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n    sign_changes ps' x = sign_changes ps x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 3. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "fix x :: real and q :: \"real poly\""], ["proof (state)\ngoal (3 subgoals):\n 1. poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n    sign_changes ps' x = sign_changes ps x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 3. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "assume \"q \\<in> set ps\""], ["proof (state)\nthis:\n  q \\<in> set ps\n\ngoal (3 subgoals):\n 1. poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n    sign_changes ps' x = sign_changes ps x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 3. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "hence \"d dvd q\""], ["proof (prove)\nusing this:\n  q \\<in> set ps\n\ngoal (1 subgoal):\n 1. d dvd q", "unfolding d_def ps_def"], ["proof (prove)\nusing this:\n  q \\<in> set (sturm p)\n\ngoal (1 subgoal):\n 1. gcd p (pderiv p) dvd q", "using sturm_gcd"], ["proof (prove)\nusing this:\n  q \\<in> set (sturm p)\n  ?r \\<in> set (sturm ?p) \\<Longrightarrow> gcd ?p (pderiv ?p) dvd ?r\n\ngoal (1 subgoal):\n 1. gcd p (pderiv p) dvd q", "by simp"], ["proof (state)\nthis:\n  d dvd q\n\ngoal (3 subgoals):\n 1. poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n    sign_changes ps' x = sign_changes ps x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 3. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "hence q_prod: \"q = (q div d) * d\""], ["proof (prove)\nusing this:\n  d dvd q\n\ngoal (1 subgoal):\n 1. q = q div d * d", "unfolding p'_def d_def"], ["proof (prove)\nusing this:\n  gcd p (pderiv p) dvd q\n\ngoal (1 subgoal):\n 1. q = q div gcd p (pderiv p) * gcd p (pderiv p)", "by (simp add: algebra_simps dvd_mult_div_cancel)"], ["proof (state)\nthis:\n  q = q div d * d\n\ngoal (3 subgoals):\n 1. poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n    sign_changes ps' x = sign_changes ps x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 3. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "have \"poly q x = poly d x * poly (q div d) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly q x = poly d x * poly (q div d) x", "by (subst q_prod, simp)"], ["proof (state)\nthis:\n  poly q x = poly d x * poly (q div d) x\n\ngoal (3 subgoals):\n 1. poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n    sign_changes ps' x = sign_changes ps x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 3. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "hence s1: \"sgn (poly q x) = sgn (poly d x) * sgn (poly (q div d) x)\""], ["proof (prove)\nusing this:\n  poly q x = poly d x * poly (q div d) x\n\ngoal (1 subgoal):\n 1. sgn (poly q x) = sgn (poly d x) * sgn (poly (q div d) x)", "by (subst q_prod, simp add: sgn_mult)"], ["proof (state)\nthis:\n  sgn (poly q x) = sgn (poly d x) * sgn (poly (q div d) x)\n\ngoal (3 subgoals):\n 1. poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n    sign_changes ps' x = sign_changes ps x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 3. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "from poly_inf_mult"], ["proof (chain)\npicking this:\n  poly_inf (?p * ?q) = poly_inf ?p * poly_inf ?q\n  poly_neg_inf (?p * ?q) = poly_neg_inf ?p * poly_neg_inf ?q", "have s2: \"poly_inf q = s' * poly_inf (q div d)\""], ["proof (prove)\nusing this:\n  poly_inf (?p * ?q) = poly_inf ?p * poly_inf ?q\n  poly_neg_inf (?p * ?q) = poly_neg_inf ?p * poly_neg_inf ?q\n\ngoal (1 subgoal):\n 1. poly_inf q = s' * poly_inf (q div d)", "unfolding s'_def"], ["proof (prove)\nusing this:\n  poly_inf (?p * ?q) = poly_inf ?p * poly_inf ?q\n  poly_neg_inf (?p * ?q) = poly_neg_inf ?p * poly_neg_inf ?q\n\ngoal (1 subgoal):\n 1. poly_inf q = poly_inf d * poly_inf (q div d)", "by (subst q_prod, simp)"], ["proof (state)\nthis:\n  poly_inf q = s' * poly_inf (q div d)\n\ngoal (3 subgoals):\n 1. poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n    sign_changes ps' x = sign_changes ps x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 3. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "from poly_inf_mult"], ["proof (chain)\npicking this:\n  poly_inf (?p * ?q) = poly_inf ?p * poly_inf ?q\n  poly_neg_inf (?p * ?q) = poly_neg_inf ?p * poly_neg_inf ?q", "have s3: \"poly_neg_inf q = s'' * poly_neg_inf (q div d)\""], ["proof (prove)\nusing this:\n  poly_inf (?p * ?q) = poly_inf ?p * poly_inf ?q\n  poly_neg_inf (?p * ?q) = poly_neg_inf ?p * poly_neg_inf ?q\n\ngoal (1 subgoal):\n 1. poly_neg_inf q = s'' * poly_neg_inf (q div d)", "unfolding s''_def"], ["proof (prove)\nusing this:\n  poly_inf (?p * ?q) = poly_inf ?p * poly_inf ?q\n  poly_neg_inf (?p * ?q) = poly_neg_inf ?p * poly_neg_inf ?q\n\ngoal (1 subgoal):\n 1. poly_neg_inf q = poly_neg_inf d * poly_neg_inf (q div d)", "by (subst q_prod, simp)"], ["proof (state)\nthis:\n  poly_neg_inf q = s'' * poly_neg_inf (q div d)\n\ngoal (3 subgoals):\n 1. poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n    sign_changes ps' x = sign_changes ps x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 3. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "note s1 s2 s3"], ["proof (state)\nthis:\n  sgn (poly q x) = sgn (poly d x) * sgn (poly (q div d) x)\n  poly_inf q = s' * poly_inf (q div d)\n  poly_neg_inf q = s'' * poly_neg_inf (q div d)\n\ngoal (3 subgoals):\n 1. poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n    sign_changes ps' x = sign_changes ps x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 3. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "}"], ["proof (state)\nthis:\n  ?q2 \\<in> set ps \\<Longrightarrow>\n  sgn (poly ?q2 ?xa2) = sgn (poly d ?xa2) * sgn (poly (?q2 div d) ?xa2)\n  ?q2 \\<in> set ps \\<Longrightarrow>\n  poly_inf ?q2 = s' * poly_inf (?q2 div d)\n  ?q2 \\<in> set ps \\<Longrightarrow>\n  poly_neg_inf ?q2 = s'' * poly_neg_inf (?q2 div d)\n\ngoal (3 subgoals):\n 1. poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n    sign_changes ps' x = sign_changes ps x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 3. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "note signs = this"], ["proof (state)\nthis:\n  ?q2 \\<in> set ps \\<Longrightarrow>\n  sgn (poly ?q2 ?xa2) = sgn (poly d ?xa2) * sgn (poly (?q2 div d) ?xa2)\n  ?q2 \\<in> set ps \\<Longrightarrow>\n  poly_inf ?q2 = s' * poly_inf (?q2 div d)\n  ?q2 \\<in> set ps \\<Longrightarrow>\n  poly_neg_inf ?q2 = s'' * poly_neg_inf (?q2 div d)\n\ngoal (3 subgoals):\n 1. poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n    sign_changes ps' x = sign_changes ps x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 3. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "{"], ["proof (state)\nthis:\n  ?q2 \\<in> set ps \\<Longrightarrow>\n  sgn (poly ?q2 ?xa2) = sgn (poly d ?xa2) * sgn (poly (?q2 div d) ?xa2)\n  ?q2 \\<in> set ps \\<Longrightarrow>\n  poly_inf ?q2 = s' * poly_inf (?q2 div d)\n  ?q2 \\<in> set ps \\<Longrightarrow>\n  poly_neg_inf ?q2 = s'' * poly_neg_inf (?q2 div d)\n\ngoal (3 subgoals):\n 1. poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n    sign_changes ps' x = sign_changes ps x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 3. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "fix f :: \"real poly \\<Rightarrow> real\" and s :: real"], ["proof (state)\ngoal (3 subgoals):\n 1. poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n    sign_changes ps' x = sign_changes ps x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 3. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "assume f: \"\\<And>q. q \\<in> set ps \\<Longrightarrow> f q = s * f (q div d)\" and s: \"s \\<noteq> 0\""], ["proof (state)\nthis:\n  ?q \\<in> set ps \\<Longrightarrow> f ?q = s * f (?q div d)\n  s \\<noteq> 0\n\ngoal (3 subgoals):\n 1. poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n    sign_changes ps' x = sign_changes ps x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 3. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "hence \"inverse s \\<noteq> 0\""], ["proof (prove)\nusing this:\n  ?q \\<in> set ps \\<Longrightarrow> f ?q = s * f (?q div d)\n  s \\<noteq> 0\n\ngoal (1 subgoal):\n 1. inverse s \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  inverse s \\<noteq> 0\n\ngoal (3 subgoals):\n 1. poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n    sign_changes ps' x = sign_changes ps x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 3. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "{"], ["proof (state)\nthis:\n  inverse s \\<noteq> 0\n\ngoal (3 subgoals):\n 1. poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n    sign_changes ps' x = sign_changes ps x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 3. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "fix q"], ["proof (state)\ngoal (3 subgoals):\n 1. poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n    sign_changes ps' x = sign_changes ps x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 3. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "assume \"q \\<in> set ps\""], ["proof (state)\nthis:\n  q \\<in> set ps\n\ngoal (3 subgoals):\n 1. poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n    sign_changes ps' x = sign_changes ps x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 3. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "hence \"f (q div d) = inverse s * f q\""], ["proof (prove)\nusing this:\n  q \\<in> set ps\n\ngoal (1 subgoal):\n 1. f (q div d) = inverse s * f q", "by (subst f[of q], simp_all add: s)"], ["proof (state)\nthis:\n  f (q div d) = inverse s * f q\n\ngoal (3 subgoals):\n 1. poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n    sign_changes ps' x = sign_changes ps x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 3. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "}"], ["proof (state)\nthis:\n  ?q2 \\<in> set ps \\<Longrightarrow> f (?q2 div d) = inverse s * f ?q2\n\ngoal (3 subgoals):\n 1. poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n    sign_changes ps' x = sign_changes ps x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 3. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "note f' = this"], ["proof (state)\nthis:\n  ?q2 \\<in> set ps \\<Longrightarrow> f (?q2 div d) = inverse s * f ?q2\n\ngoal (3 subgoals):\n 1. poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n    sign_changes ps' x = sign_changes ps x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 3. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "have \"length (remdups_adj [x\\<leftarrow>map f (map (\\<lambda>q. q div d) ps). x \\<noteq> 0]) - 1 =\n           length (remdups_adj [x\\<leftarrow>map (\\<lambda>q. f (q div d)) ps . x \\<noteq> 0]) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (remdups_adj\n       (filter (\\<lambda>x. x \\<noteq> 0)\n         (map f (map (\\<lambda>q. q div d) ps)))) -\n    1 =\n    length\n     (remdups_adj\n       (filter (\\<lambda>x. x \\<noteq> 0)\n         (map (\\<lambda>q. f (q div d)) ps))) -\n    1", "by (simp only: sign_changes_def o_def map_map)"], ["proof (state)\nthis:\n  length\n   (remdups_adj\n     (filter (\\<lambda>x. x \\<noteq> 0)\n       (map f (map (\\<lambda>q. q div d) ps)))) -\n  1 =\n  length\n   (remdups_adj\n     (filter (\\<lambda>x. x \\<noteq> 0)\n       (map (\\<lambda>q. f (q div d)) ps))) -\n  1\n\ngoal (3 subgoals):\n 1. poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n    sign_changes ps' x = sign_changes ps x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 3. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "also"], ["proof (state)\nthis:\n  length\n   (remdups_adj\n     (filter (\\<lambda>x. x \\<noteq> 0)\n       (map f (map (\\<lambda>q. q div d) ps)))) -\n  1 =\n  length\n   (remdups_adj\n     (filter (\\<lambda>x. x \\<noteq> 0)\n       (map (\\<lambda>q. f (q div d)) ps))) -\n  1\n\ngoal (3 subgoals):\n 1. poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n    sign_changes ps' x = sign_changes ps x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 3. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "have \"map (\\<lambda>q. q div d) ps = ps'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>q. q div d) ps = ps'", "by (simp add: ps_def ps'_def sturm_squarefree'_def Let_def d_def)"], ["proof (state)\nthis:\n  map (\\<lambda>q. q div d) ps = ps'\n\ngoal (3 subgoals):\n 1. poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n    sign_changes ps' x = sign_changes ps x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 3. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "also"], ["proof (state)\nthis:\n  map (\\<lambda>q. q div d) ps = ps'\n\ngoal (3 subgoals):\n 1. poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n    sign_changes ps' x = sign_changes ps x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 3. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "from f'"], ["proof (chain)\npicking this:\n  ?q2 \\<in> set ps \\<Longrightarrow> f (?q2 div d) = inverse s * f ?q2", "have \"map (\\<lambda>q. f (q div d)) ps =\n                      map (\\<lambda>x. ((*)(inverse s) \\<circ> f) x) ps\""], ["proof (prove)\nusing this:\n  ?q2 \\<in> set ps \\<Longrightarrow> f (?q2 div d) = inverse s * f ?q2\n\ngoal (1 subgoal):\n 1. map (\\<lambda>q. f (q div d)) ps = map ((*) (inverse s) \\<circ> f) ps", "by (simp add: o_def)"], ["proof (state)\nthis:\n  map (\\<lambda>q. f (q div d)) ps = map ((*) (inverse s) \\<circ> f) ps\n\ngoal (3 subgoals):\n 1. poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n    sign_changes ps' x = sign_changes ps x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 3. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "also"], ["proof (state)\nthis:\n  map (\\<lambda>q. f (q div d)) ps = map ((*) (inverse s) \\<circ> f) ps\n\ngoal (3 subgoals):\n 1. poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n    sign_changes ps' x = sign_changes ps x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 3. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "note sign_changes_mult_aux[OF \\<open>inverse s \\<noteq> 0\\<close>, of f ps]"], ["proof (state)\nthis:\n  length\n   (remdups_adj\n     (filter (\\<lambda>x. x \\<noteq> 0)\n       (map ((*) (inverse s) \\<circ> f) ps))) =\n  length (remdups_adj (filter (\\<lambda>x. x \\<noteq> 0) (map f ps)))\n\ngoal (3 subgoals):\n 1. poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n    sign_changes ps' x = sign_changes ps x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 3. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "finally"], ["proof (chain)\npicking this:\n  length (remdups_adj (filter (\\<lambda>x. x \\<noteq> 0) (map f ps'))) - 1 =\n  length (remdups_adj (filter (\\<lambda>x. x \\<noteq> 0) (map f ps))) - 1", "have\n        \"length (remdups_adj [x\\<leftarrow>map f ps' . x \\<noteq> 0]) - 1 =\n         length (remdups_adj [x\\<leftarrow>map f ps . x \\<noteq> 0]) - 1\""], ["proof (prove)\nusing this:\n  length (remdups_adj (filter (\\<lambda>x. x \\<noteq> 0) (map f ps'))) - 1 =\n  length (remdups_adj (filter (\\<lambda>x. x \\<noteq> 0) (map f ps))) - 1\n\ngoal (1 subgoal):\n 1. length (remdups_adj (filter (\\<lambda>x. x \\<noteq> 0) (map f ps'))) -\n    1 =\n    length (remdups_adj (filter (\\<lambda>x. x \\<noteq> 0) (map f ps))) - 1", "by simp"], ["proof (state)\nthis:\n  length (remdups_adj (filter (\\<lambda>x. x \\<noteq> 0) (map f ps'))) - 1 =\n  length (remdups_adj (filter (\\<lambda>x. x \\<noteq> 0) (map f ps))) - 1\n\ngoal (3 subgoals):\n 1. poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n    sign_changes ps' x = sign_changes ps x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 3. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>q.\n              q \\<in> set ps \\<Longrightarrow> ?f2 q = ?s2 * ?f2 (q div d);\n   ?s2 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> length\n                     (remdups_adj\n                       (filter (\\<lambda>x. x \\<noteq> 0) (map ?f2 ps'))) -\n                    1 =\n                    length\n                     (remdups_adj\n                       (filter (\\<lambda>x. x \\<noteq> 0) (map ?f2 ps))) -\n                    1\n\ngoal (3 subgoals):\n 1. poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n    sign_changes ps' x = sign_changes ps x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 3. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "note length_remdups_adj = this"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>q.\n              q \\<in> set ps \\<Longrightarrow> ?f2 q = ?s2 * ?f2 (q div d);\n   ?s2 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> length\n                     (remdups_adj\n                       (filter (\\<lambda>x. x \\<noteq> 0) (map ?f2 ps'))) -\n                    1 =\n                    length\n                     (remdups_adj\n                       (filter (\\<lambda>x. x \\<noteq> 0) (map ?f2 ps))) -\n                    1\n\ngoal (3 subgoals):\n 1. poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n    sign_changes ps' x = sign_changes ps x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 3. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "{"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>q.\n              q \\<in> set ps \\<Longrightarrow> ?f2 q = ?s2 * ?f2 (q div d);\n   ?s2 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> length\n                     (remdups_adj\n                       (filter (\\<lambda>x. x \\<noteq> 0) (map ?f2 ps'))) -\n                    1 =\n                    length\n                     (remdups_adj\n                       (filter (\\<lambda>x. x \\<noteq> 0) (map ?f2 ps))) -\n                    1\n\ngoal (3 subgoals):\n 1. poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n    sign_changes ps' x = sign_changes ps x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 3. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "fix x"], ["proof (state)\ngoal (3 subgoals):\n 1. poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n    sign_changes ps' x = sign_changes ps x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 3. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "assume A: \"poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0\""], ["proof (state)\nthis:\n  poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0\n\ngoal (3 subgoals):\n 1. poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n    sign_changes ps' x = sign_changes ps x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 3. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "have \"d dvd p\" \"d dvd pderiv p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d dvd p &&& d dvd pderiv p", "unfolding d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd p (pderiv p) dvd p &&& gcd p (pderiv p) dvd pderiv p", "by simp_all"], ["proof (state)\nthis:\n  d dvd p\n  d dvd pderiv p\n\ngoal (3 subgoals):\n 1. poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n    sign_changes ps' x = sign_changes ps x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 3. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "with A"], ["proof (chain)\npicking this:\n  poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0\n  d dvd p\n  d dvd pderiv p", "have \"sgn (poly d x) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0\n  d dvd p\n  d dvd pderiv p\n\ngoal (1 subgoal):\n 1. sgn (poly d x) \\<noteq> 0", "by (auto simp add: sgn_zero_iff elim: dvdE)"], ["proof (state)\nthis:\n  sgn (poly d x) \\<noteq> 0\n\ngoal (3 subgoals):\n 1. poly p x \\<noteq> 0 \\<or> poly (pderiv p) x \\<noteq> 0 \\<Longrightarrow>\n    sign_changes ps' x = sign_changes ps x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 3. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "thus \"sign_changes ps' x = sign_changes ps x\""], ["proof (prove)\nusing this:\n  sgn (poly d x) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sign_changes ps' x = sign_changes ps x", "using signs(1)"], ["proof (prove)\nusing this:\n  sgn (poly d x) \\<noteq> 0\n  ?q2 \\<in> set ps \\<Longrightarrow>\n  sgn (poly ?q2 ?xa2) = sgn (poly d ?xa2) * sgn (poly (?q2 div d) ?xa2)\n\ngoal (1 subgoal):\n 1. sign_changes ps' x = sign_changes ps x", "unfolding sign_changes_def"], ["proof (prove)\nusing this:\n  sgn (poly d x) \\<noteq> 0\n  ?q2 \\<in> set ps \\<Longrightarrow>\n  sgn (poly ?q2 ?xa2) = sgn (poly d ?xa2) * sgn (poly (?q2 div d) ?xa2)\n\ngoal (1 subgoal):\n 1. length\n     (remdups_adj\n       (filter (\\<lambda>x. x \\<noteq> 0)\n         (map (\\<lambda>p. sgn (poly p x)) ps'))) -\n    1 =\n    length\n     (remdups_adj\n       (filter (\\<lambda>x. x \\<noteq> 0)\n         (map (\\<lambda>p. sgn (poly p x)) ps))) -\n    1", "by (intro length_remdups_adj[of \"\\<lambda>q. sgn (poly q x)\"], simp_all)"], ["proof (state)\nthis:\n  sign_changes ps' x = sign_changes ps x\n\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "}"], ["proof (state)\nthis:\n  poly p ?xa2 \\<noteq> 0 \\<or>\n  poly (pderiv p) ?xa2 \\<noteq> 0 \\<Longrightarrow>\n  sign_changes ps' ?xa2 = sign_changes ps ?xa2\n\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "assume \"p \\<noteq> 0\""], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "hence \"d \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. d \\<noteq> 0", "unfolding d_def"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. gcd p (pderiv p) \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  d \\<noteq> 0\n\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "hence \"s' \\<noteq> 0\" \"s'' \\<noteq> 0\""], ["proof (prove)\nusing this:\n  d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. s' \\<noteq> 0 &&& s'' \\<noteq> 0", "unfolding s'_def s''_def"], ["proof (prove)\nusing this:\n  d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly_inf d \\<noteq> 0 &&& poly_neg_inf d \\<noteq> 0", "by simp_all"], ["proof (state)\nthis:\n  s' \\<noteq> 0\n  s'' \\<noteq> 0\n\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_inf ps' = sign_changes_inf ps\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "from length_remdups_adj[of poly_inf s', OF signs(2) \\<open>s' \\<noteq> 0\\<close>]"], ["proof (chain)\npicking this:\n  (\\<And>q.\n      q \\<in> set ps \\<Longrightarrow> q \\<in> set ps) \\<Longrightarrow>\n  length\n   (remdups_adj (filter (\\<lambda>x. x \\<noteq> 0) (map poly_inf ps'))) -\n  1 =\n  length\n   (remdups_adj (filter (\\<lambda>x. x \\<noteq> 0) (map poly_inf ps))) -\n  1", "show \"sign_changes_inf ps' = sign_changes_inf ps\""], ["proof (prove)\nusing this:\n  (\\<And>q.\n      q \\<in> set ps \\<Longrightarrow> q \\<in> set ps) \\<Longrightarrow>\n  length\n   (remdups_adj (filter (\\<lambda>x. x \\<noteq> 0) (map poly_inf ps'))) -\n  1 =\n  length\n   (remdups_adj (filter (\\<lambda>x. x \\<noteq> 0) (map poly_inf ps))) -\n  1\n\ngoal (1 subgoal):\n 1. sign_changes_inf ps' = sign_changes_inf ps", "unfolding sign_changes_inf_def"], ["proof (prove)\nusing this:\n  (\\<And>q.\n      q \\<in> set ps \\<Longrightarrow> q \\<in> set ps) \\<Longrightarrow>\n  length\n   (remdups_adj (filter (\\<lambda>x. x \\<noteq> 0) (map poly_inf ps'))) -\n  1 =\n  length\n   (remdups_adj (filter (\\<lambda>x. x \\<noteq> 0) (map poly_inf ps))) -\n  1\n\ngoal (1 subgoal):\n 1. length\n     (remdups_adj (filter (\\<lambda>x. x \\<noteq> 0) (map poly_inf ps'))) -\n    1 =\n    length\n     (remdups_adj (filter (\\<lambda>x. x \\<noteq> 0) (map poly_inf ps))) -\n    1", "."], ["proof (state)\nthis:\n  sign_changes_inf ps' = sign_changes_inf ps\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "from length_remdups_adj[of poly_neg_inf s'', OF signs(3) \\<open>s'' \\<noteq> 0\\<close>]"], ["proof (chain)\npicking this:\n  (\\<And>q.\n      q \\<in> set ps \\<Longrightarrow> q \\<in> set ps) \\<Longrightarrow>\n  length\n   (remdups_adj\n     (filter (\\<lambda>x. x \\<noteq> 0) (map poly_neg_inf ps'))) -\n  1 =\n  length\n   (remdups_adj (filter (\\<lambda>x. x \\<noteq> 0) (map poly_neg_inf ps))) -\n  1", "show \"sign_changes_neg_inf ps' = sign_changes_neg_inf ps\""], ["proof (prove)\nusing this:\n  (\\<And>q.\n      q \\<in> set ps \\<Longrightarrow> q \\<in> set ps) \\<Longrightarrow>\n  length\n   (remdups_adj\n     (filter (\\<lambda>x. x \\<noteq> 0) (map poly_neg_inf ps'))) -\n  1 =\n  length\n   (remdups_adj (filter (\\<lambda>x. x \\<noteq> 0) (map poly_neg_inf ps))) -\n  1\n\ngoal (1 subgoal):\n 1. sign_changes_neg_inf ps' = sign_changes_neg_inf ps", "unfolding sign_changes_neg_inf_def"], ["proof (prove)\nusing this:\n  (\\<And>q.\n      q \\<in> set ps \\<Longrightarrow> q \\<in> set ps) \\<Longrightarrow>\n  length\n   (remdups_adj\n     (filter (\\<lambda>x. x \\<noteq> 0) (map poly_neg_inf ps'))) -\n  1 =\n  length\n   (remdups_adj (filter (\\<lambda>x. x \\<noteq> 0) (map poly_neg_inf ps))) -\n  1\n\ngoal (1 subgoal):\n 1. length\n     (remdups_adj\n       (filter (\\<lambda>x. x \\<noteq> 0) (map poly_neg_inf ps'))) -\n    1 =\n    length\n     (remdups_adj\n       (filter (\\<lambda>x. x \\<noteq> 0) (map poly_neg_inf ps))) -\n    1", "."], ["proof (state)\nthis:\n  sign_changes_neg_inf ps' = sign_changes_neg_inf ps\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Root-counting functions\\<close>"], ["", "text \\<open>\n  With all these results, we can now define functions that count roots\n  in bounded and unbounded intervals:\n\\<close>"], ["", "definition count_roots_between where\n\"count_roots_between p a b = (if a \\<le> b \\<and> p \\<noteq> 0 then\n  (let ps = sturm_squarefree p\n    in sign_changes ps a - sign_changes ps b) else 0)\""], ["", "definition count_roots where\n\"count_roots p = (if (p::real poly) = 0 then 0 else\n  (let ps = sturm_squarefree p\n    in sign_changes_neg_inf ps - sign_changes_inf ps))\""], ["", "definition count_roots_above where\n\"count_roots_above p a = (if (p::real poly) = 0 then 0 else\n  (let ps = sturm_squarefree p\n    in sign_changes ps a - sign_changes_inf ps))\""], ["", "definition count_roots_below where\n\"count_roots_below p a = (if (p::real poly) = 0 then 0 else\n  (let ps = sturm_squarefree p\n    in sign_changes_neg_inf ps - sign_changes ps a))\""], ["", "lemma count_roots_between_correct:\n  \"count_roots_between p a b = card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_roots_between p a b =\n    card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}", "proof (cases \"p \\<noteq> 0 \\<and> a \\<le> b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<and> a \\<le> b \\<Longrightarrow>\n    count_roots_between p a b =\n    card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}\n 2. \\<not> (p \\<noteq> 0 \\<and> a \\<le> b) \\<Longrightarrow>\n    count_roots_between p a b =\n    card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}", "case False"], ["proof (state)\nthis:\n  \\<not> (p \\<noteq> 0 \\<and> a \\<le> b)\n\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<and> a \\<le> b \\<Longrightarrow>\n    count_roots_between p a b =\n    card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}\n 2. \\<not> (p \\<noteq> 0 \\<and> a \\<le> b) \\<Longrightarrow>\n    count_roots_between p a b =\n    card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}", "note False' = this"], ["proof (state)\nthis:\n  \\<not> (p \\<noteq> 0 \\<and> a \\<le> b)\n\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<and> a \\<le> b \\<Longrightarrow>\n    count_roots_between p a b =\n    card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}\n 2. \\<not> (p \\<noteq> 0 \\<and> a \\<le> b) \\<Longrightarrow>\n    count_roots_between p a b =\n    card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}", "hence \"card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} = 0\""], ["proof (prove)\nusing this:\n  \\<not> (p \\<noteq> 0 \\<and> a \\<le> b)\n\ngoal (1 subgoal):\n 1. card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} = 0", "proof (cases \"a < b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (p \\<noteq> 0 \\<and> a \\<le> b); a < b\\<rbrakk>\n    \\<Longrightarrow> card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} =\n                      0\n 2. \\<lbrakk>\\<not> (p \\<noteq> 0 \\<and> a \\<le> b); \\<not> a < b\\<rbrakk>\n    \\<Longrightarrow> card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} =\n                      0", "case True"], ["proof (state)\nthis:\n  a < b\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (p \\<noteq> 0 \\<and> a \\<le> b); a < b\\<rbrakk>\n    \\<Longrightarrow> card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} =\n                      0\n 2. \\<lbrakk>\\<not> (p \\<noteq> 0 \\<and> a \\<le> b); \\<not> a < b\\<rbrakk>\n    \\<Longrightarrow> card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} =\n                      0", "with False"], ["proof (chain)\npicking this:\n  \\<not> (p \\<noteq> 0 \\<and> a \\<le> b)\n  a < b", "have [simp]: \"p = 0\""], ["proof (prove)\nusing this:\n  \\<not> (p \\<noteq> 0 \\<and> a \\<le> b)\n  a < b\n\ngoal (1 subgoal):\n 1. p = 0", "by simp"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (p \\<noteq> 0 \\<and> a \\<le> b); a < b\\<rbrakk>\n    \\<Longrightarrow> card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} =\n                      0\n 2. \\<lbrakk>\\<not> (p \\<noteq> 0 \\<and> a \\<le> b); \\<not> a < b\\<rbrakk>\n    \\<Longrightarrow> card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} =\n                      0", "have subset: \"{a<..<b} \\<subseteq> {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a<..<b} \\<subseteq> {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}", "by auto"], ["proof (state)\nthis:\n  {a<..<b} \\<subseteq> {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (p \\<noteq> 0 \\<and> a \\<le> b); a < b\\<rbrakk>\n    \\<Longrightarrow> card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} =\n                      0\n 2. \\<lbrakk>\\<not> (p \\<noteq> 0 \\<and> a \\<le> b); \\<not> a < b\\<rbrakk>\n    \\<Longrightarrow> card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} =\n                      0", "from infinite_Ioo[OF True]"], ["proof (chain)\npicking this:\n  infinite {a<..<b}", "have \"\\<not>finite {a<..<b}\""], ["proof (prove)\nusing this:\n  infinite {a<..<b}\n\ngoal (1 subgoal):\n 1. infinite {a<..<b}", "."], ["proof (state)\nthis:\n  infinite {a<..<b}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (p \\<noteq> 0 \\<and> a \\<le> b); a < b\\<rbrakk>\n    \\<Longrightarrow> card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} =\n                      0\n 2. \\<lbrakk>\\<not> (p \\<noteq> 0 \\<and> a \\<le> b); \\<not> a < b\\<rbrakk>\n    \\<Longrightarrow> card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} =\n                      0", "hence \"\\<not>finite {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}\""], ["proof (prove)\nusing this:\n  infinite {a<..<b}\n\ngoal (1 subgoal):\n 1. infinite {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}", "using finite_subset[OF subset]"], ["proof (prove)\nusing this:\n  infinite {a<..<b}\n  finite {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} \\<Longrightarrow>\n  finite {a<..<b}\n\ngoal (1 subgoal):\n 1. infinite {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}", "by blast"], ["proof (state)\nthis:\n  infinite {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (p \\<noteq> 0 \\<and> a \\<le> b); a < b\\<rbrakk>\n    \\<Longrightarrow> card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} =\n                      0\n 2. \\<lbrakk>\\<not> (p \\<noteq> 0 \\<and> a \\<le> b); \\<not> a < b\\<rbrakk>\n    \\<Longrightarrow> card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} =\n                      0", "thus ?thesis"], ["proof (prove)\nusing this:\n  infinite {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}\n\ngoal (1 subgoal):\n 1. card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} = 0", "by simp"], ["proof (state)\nthis:\n  card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (p \\<noteq> 0 \\<and> a \\<le> b); \\<not> a < b\\<rbrakk>\n    \\<Longrightarrow> card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} =\n                      0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (p \\<noteq> 0 \\<and> a \\<le> b); \\<not> a < b\\<rbrakk>\n    \\<Longrightarrow> card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} =\n                      0", "case False"], ["proof (state)\nthis:\n  \\<not> a < b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (p \\<noteq> 0 \\<and> a \\<le> b); \\<not> a < b\\<rbrakk>\n    \\<Longrightarrow> card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} =\n                      0", "with False'"], ["proof (chain)\npicking this:\n  \\<not> (p \\<noteq> 0 \\<and> a \\<le> b)\n  \\<not> a < b", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (p \\<noteq> 0 \\<and> a \\<le> b)\n  \\<not> a < b\n\ngoal (1 subgoal):\n 1. card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} = 0", "by (auto simp: not_less card_eq_0_iff)"], ["proof (state)\nthis:\n  card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} = 0\n\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<and> a \\<le> b \\<Longrightarrow>\n    count_roots_between p a b =\n    card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}\n 2. \\<not> (p \\<noteq> 0 \\<and> a \\<le> b) \\<Longrightarrow>\n    count_roots_between p a b =\n    card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}", "thus ?thesis"], ["proof (prove)\nusing this:\n  card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} = 0\n\ngoal (1 subgoal):\n 1. count_roots_between p a b =\n    card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}", "unfolding count_roots_between_def Let_def"], ["proof (prove)\nusing this:\n  card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} = 0\n\ngoal (1 subgoal):\n 1. (if a \\<le> b \\<and> p \\<noteq> 0\n     then sign_changes (sturm_squarefree p) a -\n          sign_changes (sturm_squarefree p) b\n     else 0) =\n    card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}", "using False"], ["proof (prove)\nusing this:\n  card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} = 0\n  \\<not> (p \\<noteq> 0 \\<and> a \\<le> b)\n\ngoal (1 subgoal):\n 1. (if a \\<le> b \\<and> p \\<noteq> 0\n     then sign_changes (sturm_squarefree p) a -\n          sign_changes (sturm_squarefree p) b\n     else 0) =\n    card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}", "by auto"], ["proof (state)\nthis:\n  count_roots_between p a b =\n  card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<and> a \\<le> b \\<Longrightarrow>\n    count_roots_between p a b =\n    card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<and> a \\<le> b \\<Longrightarrow>\n    count_roots_between p a b =\n    card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}", "case True"], ["proof (state)\nthis:\n  p \\<noteq> 0 \\<and> a \\<le> b\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<and> a \\<le> b \\<Longrightarrow>\n    count_roots_between p a b =\n    card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}", "hence \"p \\<noteq> 0\" \"a \\<le> b\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0 \\<and> a \\<le> b\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 &&& a \\<le> b", "by simp_all"], ["proof (state)\nthis:\n  p \\<noteq> 0\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<and> a \\<le> b \\<Longrightarrow>\n    count_roots_between p a b =\n    card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}", "define p' where \"p' = p div (gcd p (pderiv p))\""], ["proof (state)\nthis:\n  p' = p div gcd p (pderiv p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<and> a \\<le> b \\<Longrightarrow>\n    count_roots_between p a b =\n    card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}", "from poly_div_gcd_squarefree(1)[OF \\<open>p \\<noteq> 0\\<close>]"], ["proof (chain)\npicking this:\n  coprime (p div gcd p (pderiv p)) (pderiv (p div gcd p (pderiv p)))", "have \"p' \\<noteq> 0\""], ["proof (prove)\nusing this:\n  coprime (p div gcd p (pderiv p)) (pderiv (p div gcd p (pderiv p)))\n\ngoal (1 subgoal):\n 1. p' \\<noteq> 0", "unfolding p'_def"], ["proof (prove)\nusing this:\n  coprime (p div gcd p (pderiv p)) (pderiv (p div gcd p (pderiv p)))\n\ngoal (1 subgoal):\n 1. p div gcd p (pderiv p) \\<noteq> 0", "by clarsimp"], ["proof (state)\nthis:\n  p' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<and> a \\<le> b \\<Longrightarrow>\n    count_roots_between p a b =\n    card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}", "from sturm_seq_sturm_squarefree[OF \\<open>p \\<noteq> 0\\<close>]"], ["proof (chain)\npicking this:\n  sturm_seq (sturm_squarefree p) (p div gcd p (pderiv p))", "interpret sturm_seq \"sturm_squarefree p\" p'"], ["proof (prove)\nusing this:\n  sturm_seq (sturm_squarefree p) (p div gcd p (pderiv p))\n\ngoal (1 subgoal):\n 1. sturm_seq (sturm_squarefree p) p'", "unfolding p'_def"], ["proof (prove)\nusing this:\n  sturm_seq (sturm_squarefree p) (p div gcd p (pderiv p))\n\ngoal (1 subgoal):\n 1. sturm_seq (sturm_squarefree p) (p div gcd p (pderiv p))", "."], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<and> a \\<le> b \\<Longrightarrow>\n    count_roots_between p a b =\n    card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}", "from poly_roots_finite[OF \\<open>p' \\<noteq> 0\\<close>]"], ["proof (chain)\npicking this:\n  finite {x. poly p' x = 0}", "have \"finite {x. a < x \\<and> x \\<le> b \\<and> poly p' x = 0}\""], ["proof (prove)\nusing this:\n  finite {x. poly p' x = 0}\n\ngoal (1 subgoal):\n 1. finite {x. a < x \\<and> x \\<le> b \\<and> poly p' x = 0}", "by fast"], ["proof (state)\nthis:\n  finite {x. a < x \\<and> x \\<le> b \\<and> poly p' x = 0}\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<and> a \\<le> b \\<Longrightarrow>\n    count_roots_between p a b =\n    card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}", "have \"count_roots_between p a b = card {x. a < x \\<and> x \\<le> b \\<and> poly p' x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_roots_between p a b =\n    card {x. a < x \\<and> x \\<le> b \\<and> poly p' x = 0}", "unfolding count_roots_between_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if a \\<le> b \\<and> p \\<noteq> 0\n     then sign_changes (sturm_squarefree p) a -\n          sign_changes (sturm_squarefree p) b\n     else 0) =\n    card {x. a < x \\<and> x \\<le> b \\<and> poly p' x = 0}", "using True count_roots_between[OF \\<open>p' \\<noteq> 0\\<close> \\<open>a \\<le> b\\<close>]"], ["proof (prove)\nusing this:\n  p \\<noteq> 0 \\<and> a \\<le> b\n  sign_changes (sturm_squarefree p) a -\n  sign_changes (sturm_squarefree p) b =\n  card {x. a < x \\<and> x \\<le> b \\<and> poly p' x = 0}\n\ngoal (1 subgoal):\n 1. (if a \\<le> b \\<and> p \\<noteq> 0\n     then sign_changes (sturm_squarefree p) a -\n          sign_changes (sturm_squarefree p) b\n     else 0) =\n    card {x. a < x \\<and> x \\<le> b \\<and> poly p' x = 0}", "by simp"], ["proof (state)\nthis:\n  count_roots_between p a b =\n  card {x. a < x \\<and> x \\<le> b \\<and> poly p' x = 0}\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<and> a \\<le> b \\<Longrightarrow>\n    count_roots_between p a b =\n    card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}", "also"], ["proof (state)\nthis:\n  count_roots_between p a b =\n  card {x. a < x \\<and> x \\<le> b \\<and> poly p' x = 0}\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<and> a \\<le> b \\<Longrightarrow>\n    count_roots_between p a b =\n    card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}", "from poly_div_gcd_squarefree(2)[OF \\<open>p \\<noteq> 0\\<close>]"], ["proof (chain)\npicking this:\n  (poly (p div gcd p (pderiv p)) ?x = 0) = (poly p ?x = 0)", "have \"{x. a < x \\<and> x \\<le> b \\<and> poly p' x = 0} =\n            {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}\""], ["proof (prove)\nusing this:\n  (poly (p div gcd p (pderiv p)) ?x = 0) = (poly p ?x = 0)\n\ngoal (1 subgoal):\n 1. {x. a < x \\<and> x \\<le> b \\<and> poly p' x = 0} =\n    {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}", "unfolding p'_def"], ["proof (prove)\nusing this:\n  (poly (p div gcd p (pderiv p)) ?x = 0) = (poly p ?x = 0)\n\ngoal (1 subgoal):\n 1. {x. a < x \\<and> x \\<le> b \\<and> poly (p div gcd p (pderiv p)) x = 0} =\n    {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}", "by blast"], ["proof (state)\nthis:\n  {x. a < x \\<and> x \\<le> b \\<and> poly p' x = 0} =\n  {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<and> a \\<le> b \\<Longrightarrow>\n    count_roots_between p a b =\n    card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}", "finally"], ["proof (chain)\npicking this:\n  count_roots_between p a b =\n  card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}", "show ?thesis"], ["proof (prove)\nusing this:\n  count_roots_between p a b =\n  card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}\n\ngoal (1 subgoal):\n 1. count_roots_between p a b =\n    card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}", "."], ["proof (state)\nthis:\n  count_roots_between p a b =\n  card {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma count_roots_correct:\n  fixes p :: \"real poly\"\n  shows \"count_roots p = card {x. poly p x = 0}\" (is \"_ = card ?S\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. count_roots p = card {x. poly p x = 0}", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> count_roots p = card {x. poly p x = 0}\n 2. p \\<noteq> 0 \\<Longrightarrow> count_roots p = card {x. poly p x = 0}", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> count_roots p = card {x. poly p x = 0}\n 2. p \\<noteq> 0 \\<Longrightarrow> count_roots p = card {x. poly p x = 0}", "with finite_subset[of \"{0<..<1}\" ?S]"], ["proof (chain)\npicking this:\n  \\<lbrakk>{0<..<1} \\<subseteq> {x. poly p x = 0};\n   finite {x. poly p x = 0}\\<rbrakk>\n  \\<Longrightarrow> finite {0<..<1}\n  p = 0", "have \"\\<not>finite {x. poly p x = 0}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>{0<..<1} \\<subseteq> {x. poly p x = 0};\n   finite {x. poly p x = 0}\\<rbrakk>\n  \\<Longrightarrow> finite {0<..<1}\n  p = 0\n\ngoal (1 subgoal):\n 1. infinite {x. poly p x = 0}", "by (auto simp: infinite_Ioo)"], ["proof (state)\nthis:\n  infinite {x. poly p x = 0}\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> count_roots p = card {x. poly p x = 0}\n 2. p \\<noteq> 0 \\<Longrightarrow> count_roots p = card {x. poly p x = 0}", "thus ?thesis"], ["proof (prove)\nusing this:\n  infinite {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. count_roots p = card {x. poly p x = 0}", "by (simp add: count_roots_def True)"], ["proof (state)\nthis:\n  count_roots p = card {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> count_roots p = card {x. poly p x = 0}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> count_roots p = card {x. poly p x = 0}", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> count_roots p = card {x. poly p x = 0}", "define p' where \"p' = p div (gcd p (pderiv p))\""], ["proof (state)\nthis:\n  p' = p div gcd p (pderiv p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> count_roots p = card {x. poly p x = 0}", "from poly_div_gcd_squarefree(1)[OF \\<open>p \\<noteq> 0\\<close>]"], ["proof (chain)\npicking this:\n  coprime (p div gcd p (pderiv p)) (pderiv (p div gcd p (pderiv p)))", "have \"p' \\<noteq> 0\""], ["proof (prove)\nusing this:\n  coprime (p div gcd p (pderiv p)) (pderiv (p div gcd p (pderiv p)))\n\ngoal (1 subgoal):\n 1. p' \\<noteq> 0", "unfolding p'_def"], ["proof (prove)\nusing this:\n  coprime (p div gcd p (pderiv p)) (pderiv (p div gcd p (pderiv p)))\n\ngoal (1 subgoal):\n 1. p div gcd p (pderiv p) \\<noteq> 0", "by clarsimp"], ["proof (state)\nthis:\n  p' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> count_roots p = card {x. poly p x = 0}", "from sturm_seq_sturm_squarefree[OF \\<open>p \\<noteq> 0\\<close>]"], ["proof (chain)\npicking this:\n  sturm_seq (sturm_squarefree p) (p div gcd p (pderiv p))", "interpret sturm_seq \"sturm_squarefree p\" p'"], ["proof (prove)\nusing this:\n  sturm_seq (sturm_squarefree p) (p div gcd p (pderiv p))\n\ngoal (1 subgoal):\n 1. sturm_seq (sturm_squarefree p) p'", "unfolding p'_def"], ["proof (prove)\nusing this:\n  sturm_seq (sturm_squarefree p) (p div gcd p (pderiv p))\n\ngoal (1 subgoal):\n 1. sturm_seq (sturm_squarefree p) (p div gcd p (pderiv p))", "."], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> count_roots p = card {x. poly p x = 0}", "from count_roots[OF \\<open>p' \\<noteq> 0\\<close>]"], ["proof (chain)\npicking this:\n  sign_changes_neg_inf (sturm_squarefree p) -\n  sign_changes_inf (sturm_squarefree p) =\n  card {x. poly p' x = 0}", "have \"count_roots p = card {x. poly p' x = 0}\""], ["proof (prove)\nusing this:\n  sign_changes_neg_inf (sturm_squarefree p) -\n  sign_changes_inf (sturm_squarefree p) =\n  card {x. poly p' x = 0}\n\ngoal (1 subgoal):\n 1. count_roots p = card {x. poly p' x = 0}", "unfolding count_roots_def Let_def"], ["proof (prove)\nusing this:\n  sign_changes_neg_inf (sturm_squarefree p) -\n  sign_changes_inf (sturm_squarefree p) =\n  card {x. poly p' x = 0}\n\ngoal (1 subgoal):\n 1. (if p = 0 then 0\n     else sign_changes_neg_inf (sturm_squarefree p) -\n          sign_changes_inf (sturm_squarefree p)) =\n    card {x. poly p' x = 0}", "by (simp add: \\<open>p \\<noteq> 0\\<close>)"], ["proof (state)\nthis:\n  count_roots p = card {x. poly p' x = 0}\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> count_roots p = card {x. poly p x = 0}", "also"], ["proof (state)\nthis:\n  count_roots p = card {x. poly p' x = 0}\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> count_roots p = card {x. poly p x = 0}", "from poly_div_gcd_squarefree(2)[OF \\<open>p \\<noteq> 0\\<close>]"], ["proof (chain)\npicking this:\n  (poly (p div gcd p (pderiv p)) ?x = 0) = (poly p ?x = 0)", "have \"{x. poly p' x = 0} = {x. poly p x = 0}\""], ["proof (prove)\nusing this:\n  (poly (p div gcd p (pderiv p)) ?x = 0) = (poly p ?x = 0)\n\ngoal (1 subgoal):\n 1. {x. poly p' x = 0} = {x. poly p x = 0}", "unfolding p'_def"], ["proof (prove)\nusing this:\n  (poly (p div gcd p (pderiv p)) ?x = 0) = (poly p ?x = 0)\n\ngoal (1 subgoal):\n 1. {x. poly (p div gcd p (pderiv p)) x = 0} = {x. poly p x = 0}", "by blast"], ["proof (state)\nthis:\n  {x. poly p' x = 0} = {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> count_roots p = card {x. poly p x = 0}", "finally"], ["proof (chain)\npicking this:\n  count_roots p = card {x. poly p x = 0}", "show ?thesis"], ["proof (prove)\nusing this:\n  count_roots p = card {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. count_roots p = card {x. poly p x = 0}", "."], ["proof (state)\nthis:\n  count_roots p = card {x. poly p x = 0}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma count_roots_above_correct:\n  fixes p :: \"real poly\"\n  shows \"count_roots_above p a = card {x. x > a \\<and> poly p x = 0}\"\n         (is \"_ = card ?S\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. count_roots_above p a = card {x. a < x \\<and> poly p x = 0}", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    count_roots_above p a = card {x. a < x \\<and> poly p x = 0}\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots_above p a = card {x. a < x \\<and> poly p x = 0}", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    count_roots_above p a = card {x. a < x \\<and> poly p x = 0}\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots_above p a = card {x. a < x \\<and> poly p x = 0}", "with finite_subset[of \"{a<..<a+1}\" ?S]"], ["proof (chain)\npicking this:\n  \\<lbrakk>{a<..<a + 1} \\<subseteq> {x. a < x \\<and> poly p x = 0};\n   finite {x. a < x \\<and> poly p x = 0}\\<rbrakk>\n  \\<Longrightarrow> finite {a<..<a + 1}\n  p = 0", "have \"\\<not>finite {x. x > a \\<and> poly p x = 0}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>{a<..<a + 1} \\<subseteq> {x. a < x \\<and> poly p x = 0};\n   finite {x. a < x \\<and> poly p x = 0}\\<rbrakk>\n  \\<Longrightarrow> finite {a<..<a + 1}\n  p = 0\n\ngoal (1 subgoal):\n 1. infinite {x. a < x \\<and> poly p x = 0}", "by (auto simp: infinite_Ioo subset_eq)"], ["proof (state)\nthis:\n  infinite {x. a < x \\<and> poly p x = 0}\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    count_roots_above p a = card {x. a < x \\<and> poly p x = 0}\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots_above p a = card {x. a < x \\<and> poly p x = 0}", "thus ?thesis"], ["proof (prove)\nusing this:\n  infinite {x. a < x \\<and> poly p x = 0}\n\ngoal (1 subgoal):\n 1. count_roots_above p a = card {x. a < x \\<and> poly p x = 0}", "by (simp add: count_roots_above_def True)"], ["proof (state)\nthis:\n  count_roots_above p a = card {x. a < x \\<and> poly p x = 0}\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots_above p a = card {x. a < x \\<and> poly p x = 0}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots_above p a = card {x. a < x \\<and> poly p x = 0}", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots_above p a = card {x. a < x \\<and> poly p x = 0}", "define p' where \"p' = p div (gcd p (pderiv p))\""], ["proof (state)\nthis:\n  p' = p div gcd p (pderiv p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots_above p a = card {x. a < x \\<and> poly p x = 0}", "from poly_div_gcd_squarefree(1)[OF \\<open>p \\<noteq> 0\\<close>]"], ["proof (chain)\npicking this:\n  coprime (p div gcd p (pderiv p)) (pderiv (p div gcd p (pderiv p)))", "have \"p' \\<noteq> 0\""], ["proof (prove)\nusing this:\n  coprime (p div gcd p (pderiv p)) (pderiv (p div gcd p (pderiv p)))\n\ngoal (1 subgoal):\n 1. p' \\<noteq> 0", "unfolding p'_def"], ["proof (prove)\nusing this:\n  coprime (p div gcd p (pderiv p)) (pderiv (p div gcd p (pderiv p)))\n\ngoal (1 subgoal):\n 1. p div gcd p (pderiv p) \\<noteq> 0", "by clarsimp"], ["proof (state)\nthis:\n  p' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots_above p a = card {x. a < x \\<and> poly p x = 0}", "from sturm_seq_sturm_squarefree[OF \\<open>p \\<noteq> 0\\<close>]"], ["proof (chain)\npicking this:\n  sturm_seq (sturm_squarefree p) (p div gcd p (pderiv p))", "interpret sturm_seq \"sturm_squarefree p\" p'"], ["proof (prove)\nusing this:\n  sturm_seq (sturm_squarefree p) (p div gcd p (pderiv p))\n\ngoal (1 subgoal):\n 1. sturm_seq (sturm_squarefree p) p'", "unfolding p'_def"], ["proof (prove)\nusing this:\n  sturm_seq (sturm_squarefree p) (p div gcd p (pderiv p))\n\ngoal (1 subgoal):\n 1. sturm_seq (sturm_squarefree p) (p div gcd p (pderiv p))", "."], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots_above p a = card {x. a < x \\<and> poly p x = 0}", "from count_roots_above[OF \\<open>p' \\<noteq> 0\\<close>]"], ["proof (chain)\npicking this:\n  sign_changes (sturm_squarefree p) ?a -\n  sign_changes_inf (sturm_squarefree p) =\n  card {x. ?a < x \\<and> poly p' x = 0}", "have \"count_roots_above p a = card {x. x > a \\<and> poly p' x = 0}\""], ["proof (prove)\nusing this:\n  sign_changes (sturm_squarefree p) ?a -\n  sign_changes_inf (sturm_squarefree p) =\n  card {x. ?a < x \\<and> poly p' x = 0}\n\ngoal (1 subgoal):\n 1. count_roots_above p a = card {x. a < x \\<and> poly p' x = 0}", "unfolding count_roots_above_def Let_def"], ["proof (prove)\nusing this:\n  sign_changes (sturm_squarefree p) ?a -\n  sign_changes_inf (sturm_squarefree p) =\n  card {x. ?a < x \\<and> poly p' x = 0}\n\ngoal (1 subgoal):\n 1. (if p = 0 then 0\n     else sign_changes (sturm_squarefree p) a -\n          sign_changes_inf (sturm_squarefree p)) =\n    card {x. a < x \\<and> poly p' x = 0}", "by (simp add: \\<open>p \\<noteq> 0\\<close>)"], ["proof (state)\nthis:\n  count_roots_above p a = card {x. a < x \\<and> poly p' x = 0}\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots_above p a = card {x. a < x \\<and> poly p x = 0}", "also"], ["proof (state)\nthis:\n  count_roots_above p a = card {x. a < x \\<and> poly p' x = 0}\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots_above p a = card {x. a < x \\<and> poly p x = 0}", "from poly_div_gcd_squarefree(2)[OF \\<open>p \\<noteq> 0\\<close>]"], ["proof (chain)\npicking this:\n  (poly (p div gcd p (pderiv p)) ?x = 0) = (poly p ?x = 0)", "have \"{x. x > a \\<and> poly p' x = 0} = {x. x > a \\<and> poly p x = 0}\""], ["proof (prove)\nusing this:\n  (poly (p div gcd p (pderiv p)) ?x = 0) = (poly p ?x = 0)\n\ngoal (1 subgoal):\n 1. {x. a < x \\<and> poly p' x = 0} = {x. a < x \\<and> poly p x = 0}", "unfolding p'_def"], ["proof (prove)\nusing this:\n  (poly (p div gcd p (pderiv p)) ?x = 0) = (poly p ?x = 0)\n\ngoal (1 subgoal):\n 1. {x. a < x \\<and> poly (p div gcd p (pderiv p)) x = 0} =\n    {x. a < x \\<and> poly p x = 0}", "by blast"], ["proof (state)\nthis:\n  {x. a < x \\<and> poly p' x = 0} = {x. a < x \\<and> poly p x = 0}\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots_above p a = card {x. a < x \\<and> poly p x = 0}", "finally"], ["proof (chain)\npicking this:\n  count_roots_above p a = card {x. a < x \\<and> poly p x = 0}", "show ?thesis"], ["proof (prove)\nusing this:\n  count_roots_above p a = card {x. a < x \\<and> poly p x = 0}\n\ngoal (1 subgoal):\n 1. count_roots_above p a = card {x. a < x \\<and> poly p x = 0}", "."], ["proof (state)\nthis:\n  count_roots_above p a = card {x. a < x \\<and> poly p x = 0}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma count_roots_below_correct:\n  fixes p :: \"real poly\"\n  shows \"count_roots_below p a = card {x. x \\<le> a \\<and> poly p x = 0}\"\n         (is \"_ = card ?S\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. count_roots_below p a = card {x. x \\<le> a \\<and> poly p x = 0}", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    count_roots_below p a = card {x. x \\<le> a \\<and> poly p x = 0}\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots_below p a = card {x. x \\<le> a \\<and> poly p x = 0}", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    count_roots_below p a = card {x. x \\<le> a \\<and> poly p x = 0}\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots_below p a = card {x. x \\<le> a \\<and> poly p x = 0}", "with finite_subset[of \"{a - 1<..<a}\" ?S]"], ["proof (chain)\npicking this:\n  \\<lbrakk>{a - 1<..<a} \\<subseteq> {x. x \\<le> a \\<and> poly p x = 0};\n   finite {x. x \\<le> a \\<and> poly p x = 0}\\<rbrakk>\n  \\<Longrightarrow> finite {a - 1<..<a}\n  p = 0", "have \"\\<not>finite {x. x \\<le> a \\<and> poly p x = 0}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>{a - 1<..<a} \\<subseteq> {x. x \\<le> a \\<and> poly p x = 0};\n   finite {x. x \\<le> a \\<and> poly p x = 0}\\<rbrakk>\n  \\<Longrightarrow> finite {a - 1<..<a}\n  p = 0\n\ngoal (1 subgoal):\n 1. infinite {x. x \\<le> a \\<and> poly p x = 0}", "by (auto simp: infinite_Ioo subset_eq)"], ["proof (state)\nthis:\n  infinite {x. x \\<le> a \\<and> poly p x = 0}\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    count_roots_below p a = card {x. x \\<le> a \\<and> poly p x = 0}\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots_below p a = card {x. x \\<le> a \\<and> poly p x = 0}", "thus ?thesis"], ["proof (prove)\nusing this:\n  infinite {x. x \\<le> a \\<and> poly p x = 0}\n\ngoal (1 subgoal):\n 1. count_roots_below p a = card {x. x \\<le> a \\<and> poly p x = 0}", "by (simp add: count_roots_below_def True)"], ["proof (state)\nthis:\n  count_roots_below p a = card {x. x \\<le> a \\<and> poly p x = 0}\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots_below p a = card {x. x \\<le> a \\<and> poly p x = 0}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots_below p a = card {x. x \\<le> a \\<and> poly p x = 0}", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots_below p a = card {x. x \\<le> a \\<and> poly p x = 0}", "define p' where \"p' = p div (gcd p (pderiv p))\""], ["proof (state)\nthis:\n  p' = p div gcd p (pderiv p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots_below p a = card {x. x \\<le> a \\<and> poly p x = 0}", "from poly_div_gcd_squarefree(1)[OF \\<open>p \\<noteq> 0\\<close>]"], ["proof (chain)\npicking this:\n  coprime (p div gcd p (pderiv p)) (pderiv (p div gcd p (pderiv p)))", "have \"p' \\<noteq> 0\""], ["proof (prove)\nusing this:\n  coprime (p div gcd p (pderiv p)) (pderiv (p div gcd p (pderiv p)))\n\ngoal (1 subgoal):\n 1. p' \\<noteq> 0", "unfolding p'_def"], ["proof (prove)\nusing this:\n  coprime (p div gcd p (pderiv p)) (pderiv (p div gcd p (pderiv p)))\n\ngoal (1 subgoal):\n 1. p div gcd p (pderiv p) \\<noteq> 0", "by clarsimp"], ["proof (state)\nthis:\n  p' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots_below p a = card {x. x \\<le> a \\<and> poly p x = 0}", "from sturm_seq_sturm_squarefree[OF \\<open>p \\<noteq> 0\\<close>]"], ["proof (chain)\npicking this:\n  sturm_seq (sturm_squarefree p) (p div gcd p (pderiv p))", "interpret sturm_seq \"sturm_squarefree p\" p'"], ["proof (prove)\nusing this:\n  sturm_seq (sturm_squarefree p) (p div gcd p (pderiv p))\n\ngoal (1 subgoal):\n 1. sturm_seq (sturm_squarefree p) p'", "unfolding p'_def"], ["proof (prove)\nusing this:\n  sturm_seq (sturm_squarefree p) (p div gcd p (pderiv p))\n\ngoal (1 subgoal):\n 1. sturm_seq (sturm_squarefree p) (p div gcd p (pderiv p))", "."], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots_below p a = card {x. x \\<le> a \\<and> poly p x = 0}", "from count_roots_below[OF \\<open>p' \\<noteq> 0\\<close>]"], ["proof (chain)\npicking this:\n  sign_changes_neg_inf (sturm_squarefree p) -\n  sign_changes (sturm_squarefree p) ?a =\n  card {x. x \\<le> ?a \\<and> poly p' x = 0}", "have \"count_roots_below p a = card {x. x \\<le> a \\<and> poly p' x = 0}\""], ["proof (prove)\nusing this:\n  sign_changes_neg_inf (sturm_squarefree p) -\n  sign_changes (sturm_squarefree p) ?a =\n  card {x. x \\<le> ?a \\<and> poly p' x = 0}\n\ngoal (1 subgoal):\n 1. count_roots_below p a = card {x. x \\<le> a \\<and> poly p' x = 0}", "unfolding count_roots_below_def Let_def"], ["proof (prove)\nusing this:\n  sign_changes_neg_inf (sturm_squarefree p) -\n  sign_changes (sturm_squarefree p) ?a =\n  card {x. x \\<le> ?a \\<and> poly p' x = 0}\n\ngoal (1 subgoal):\n 1. (if p = 0 then 0\n     else sign_changes_neg_inf (sturm_squarefree p) -\n          sign_changes (sturm_squarefree p) a) =\n    card {x. x \\<le> a \\<and> poly p' x = 0}", "by (simp add: \\<open>p \\<noteq> 0\\<close>)"], ["proof (state)\nthis:\n  count_roots_below p a = card {x. x \\<le> a \\<and> poly p' x = 0}\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots_below p a = card {x. x \\<le> a \\<and> poly p x = 0}", "also"], ["proof (state)\nthis:\n  count_roots_below p a = card {x. x \\<le> a \\<and> poly p' x = 0}\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots_below p a = card {x. x \\<le> a \\<and> poly p x = 0}", "from poly_div_gcd_squarefree(2)[OF \\<open>p \\<noteq> 0\\<close>]"], ["proof (chain)\npicking this:\n  (poly (p div gcd p (pderiv p)) ?x = 0) = (poly p ?x = 0)", "have \"{x. x \\<le> a \\<and> poly p' x = 0} = {x. x \\<le> a \\<and> poly p x = 0}\""], ["proof (prove)\nusing this:\n  (poly (p div gcd p (pderiv p)) ?x = 0) = (poly p ?x = 0)\n\ngoal (1 subgoal):\n 1. {x. x \\<le> a \\<and> poly p' x = 0} = {x. x \\<le> a \\<and> poly p x = 0}", "unfolding p'_def"], ["proof (prove)\nusing this:\n  (poly (p div gcd p (pderiv p)) ?x = 0) = (poly p ?x = 0)\n\ngoal (1 subgoal):\n 1. {x. x \\<le> a \\<and> poly (p div gcd p (pderiv p)) x = 0} =\n    {x. x \\<le> a \\<and> poly p x = 0}", "by blast"], ["proof (state)\nthis:\n  {x. x \\<le> a \\<and> poly p' x = 0} = {x. x \\<le> a \\<and> poly p x = 0}\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots_below p a = card {x. x \\<le> a \\<and> poly p x = 0}", "finally"], ["proof (chain)\npicking this:\n  count_roots_below p a = card {x. x \\<le> a \\<and> poly p x = 0}", "show ?thesis"], ["proof (prove)\nusing this:\n  count_roots_below p a = card {x. x \\<le> a \\<and> poly p x = 0}\n\ngoal (1 subgoal):\n 1. count_roots_below p a = card {x. x \\<le> a \\<and> poly p x = 0}", "."], ["proof (state)\nthis:\n  count_roots_below p a = card {x. x \\<le> a \\<and> poly p x = 0}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The optimisation explained above can be used to prove more efficient code equations that\n  use the more efficient construction in the case that the interval borders are not\n  multiple roots:\n\\<close>"], ["", "lemma count_roots_between[code]:\n  \"count_roots_between p a b =\n     (let q = pderiv p\n       in if a > b \\<or> p = 0 then 0\n       else if (poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0) \\<and> (poly p b \\<noteq> 0 \\<or> poly q b \\<noteq> 0)\n            then (let ps = sturm p\n                   in sign_changes ps a - sign_changes ps b)\n            else (let ps = sturm_squarefree p\n                   in sign_changes ps a - sign_changes ps b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_roots_between p a b =\n    (let q = pderiv p\n     in if b < a \\<or> p = 0 then 0\n        else if (poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0) \\<and>\n                (poly p b \\<noteq> 0 \\<or> poly q b \\<noteq> 0)\n             then let ps = sturm p in sign_changes ps a - sign_changes ps b\n             else let ps = sturm_squarefree p\n                  in sign_changes ps a - sign_changes ps b)", "proof (cases \"a > b \\<or> p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. b < a \\<or> p = 0 \\<Longrightarrow>\n    count_roots_between p a b =\n    (let q = pderiv p\n     in if b < a \\<or> p = 0 then 0\n        else if (poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0) \\<and>\n                (poly p b \\<noteq> 0 \\<or> poly q b \\<noteq> 0)\n             then let ps = sturm p in sign_changes ps a - sign_changes ps b\n             else let ps = sturm_squarefree p\n                  in sign_changes ps a - sign_changes ps b)\n 2. \\<not> (b < a \\<or> p = 0) \\<Longrightarrow>\n    count_roots_between p a b =\n    (let q = pderiv p\n     in if b < a \\<or> p = 0 then 0\n        else if (poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0) \\<and>\n                (poly p b \\<noteq> 0 \\<or> poly q b \\<noteq> 0)\n             then let ps = sturm p in sign_changes ps a - sign_changes ps b\n             else let ps = sturm_squarefree p\n                  in sign_changes ps a - sign_changes ps b)", "case True"], ["proof (state)\nthis:\n  b < a \\<or> p = 0\n\ngoal (2 subgoals):\n 1. b < a \\<or> p = 0 \\<Longrightarrow>\n    count_roots_between p a b =\n    (let q = pderiv p\n     in if b < a \\<or> p = 0 then 0\n        else if (poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0) \\<and>\n                (poly p b \\<noteq> 0 \\<or> poly q b \\<noteq> 0)\n             then let ps = sturm p in sign_changes ps a - sign_changes ps b\n             else let ps = sturm_squarefree p\n                  in sign_changes ps a - sign_changes ps b)\n 2. \\<not> (b < a \\<or> p = 0) \\<Longrightarrow>\n    count_roots_between p a b =\n    (let q = pderiv p\n     in if b < a \\<or> p = 0 then 0\n        else if (poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0) \\<and>\n                (poly p b \\<noteq> 0 \\<or> poly q b \\<noteq> 0)\n             then let ps = sturm p in sign_changes ps a - sign_changes ps b\n             else let ps = sturm_squarefree p\n                  in sign_changes ps a - sign_changes ps b)", "thus ?thesis"], ["proof (prove)\nusing this:\n  b < a \\<or> p = 0\n\ngoal (1 subgoal):\n 1. count_roots_between p a b =\n    (let q = pderiv p\n     in if b < a \\<or> p = 0 then 0\n        else if (poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0) \\<and>\n                (poly p b \\<noteq> 0 \\<or> poly q b \\<noteq> 0)\n             then let ps = sturm p in sign_changes ps a - sign_changes ps b\n             else let ps = sturm_squarefree p\n                  in sign_changes ps a - sign_changes ps b)", "by (auto simp add: count_roots_between_def Let_def)"], ["proof (state)\nthis:\n  count_roots_between p a b =\n  (let q = pderiv p\n   in if b < a \\<or> p = 0 then 0\n      else if (poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0) \\<and>\n              (poly p b \\<noteq> 0 \\<or> poly q b \\<noteq> 0)\n           then let ps = sturm p in sign_changes ps a - sign_changes ps b\n           else let ps = sturm_squarefree p\n                in sign_changes ps a - sign_changes ps b)\n\ngoal (1 subgoal):\n 1. \\<not> (b < a \\<or> p = 0) \\<Longrightarrow>\n    count_roots_between p a b =\n    (let q = pderiv p\n     in if b < a \\<or> p = 0 then 0\n        else if (poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0) \\<and>\n                (poly p b \\<noteq> 0 \\<or> poly q b \\<noteq> 0)\n             then let ps = sturm p in sign_changes ps a - sign_changes ps b\n             else let ps = sturm_squarefree p\n                  in sign_changes ps a - sign_changes ps b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (b < a \\<or> p = 0) \\<Longrightarrow>\n    count_roots_between p a b =\n    (let q = pderiv p\n     in if b < a \\<or> p = 0 then 0\n        else if (poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0) \\<and>\n                (poly p b \\<noteq> 0 \\<or> poly q b \\<noteq> 0)\n             then let ps = sturm p in sign_changes ps a - sign_changes ps b\n             else let ps = sturm_squarefree p\n                  in sign_changes ps a - sign_changes ps b)", "case False"], ["proof (state)\nthis:\n  \\<not> (b < a \\<or> p = 0)\n\ngoal (1 subgoal):\n 1. \\<not> (b < a \\<or> p = 0) \\<Longrightarrow>\n    count_roots_between p a b =\n    (let q = pderiv p\n     in if b < a \\<or> p = 0 then 0\n        else if (poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0) \\<and>\n                (poly p b \\<noteq> 0 \\<or> poly q b \\<noteq> 0)\n             then let ps = sturm p in sign_changes ps a - sign_changes ps b\n             else let ps = sturm_squarefree p\n                  in sign_changes ps a - sign_changes ps b)", "note False1 = this"], ["proof (state)\nthis:\n  \\<not> (b < a \\<or> p = 0)\n\ngoal (1 subgoal):\n 1. \\<not> (b < a \\<or> p = 0) \\<Longrightarrow>\n    count_roots_between p a b =\n    (let q = pderiv p\n     in if b < a \\<or> p = 0 then 0\n        else if (poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0) \\<and>\n                (poly p b \\<noteq> 0 \\<or> poly q b \\<noteq> 0)\n             then let ps = sturm p in sign_changes ps a - sign_changes ps b\n             else let ps = sturm_squarefree p\n                  in sign_changes ps a - sign_changes ps b)", "hence \"a \\<le> b\" \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> (b < a \\<or> p = 0)\n\ngoal (1 subgoal):\n 1. a \\<le> b &&& p \\<noteq> 0", "by simp_all"], ["proof (state)\nthis:\n  a \\<le> b\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (b < a \\<or> p = 0) \\<Longrightarrow>\n    count_roots_between p a b =\n    (let q = pderiv p\n     in if b < a \\<or> p = 0 then 0\n        else if (poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0) \\<and>\n                (poly p b \\<noteq> 0 \\<or> poly q b \\<noteq> 0)\n             then let ps = sturm p in sign_changes ps a - sign_changes ps b\n             else let ps = sturm_squarefree p\n                  in sign_changes ps a - sign_changes ps b)", "thus ?thesis"], ["proof (prove)\nusing this:\n  a \\<le> b\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. count_roots_between p a b =\n    (let q = pderiv p\n     in if b < a \\<or> p = 0 then 0\n        else if (poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0) \\<and>\n                (poly p b \\<noteq> 0 \\<or> poly q b \\<noteq> 0)\n             then let ps = sturm p in sign_changes ps a - sign_changes ps b\n             else let ps = sturm_squarefree p\n                  in sign_changes ps a - sign_changes ps b)", "proof (cases \"(poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0) \\<and>\n                  (poly p b \\<noteq> 0 \\<or> poly (pderiv p) b \\<noteq> 0)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<le> b; p \\<noteq> 0;\n     (poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0) \\<and>\n     (poly p b \\<noteq> 0 \\<or> poly (pderiv p) b \\<noteq> 0)\\<rbrakk>\n    \\<Longrightarrow> count_roots_between p a b =\n                      (let q = pderiv p\n                       in if b < a \\<or> p = 0 then 0\n                          else if (poly p a \\<noteq> 0 \\<or>\n                                   poly q a \\<noteq> 0) \\<and>\n                                  (poly p b \\<noteq> 0 \\<or>\n                                   poly q b \\<noteq> 0)\n                               then let ps = sturm p\n                                    in sign_changes ps a - sign_changes ps b\n                               else let ps = sturm_squarefree p\n                                    in sign_changes ps a -\n sign_changes ps b)\n 2. \\<lbrakk>a \\<le> b; p \\<noteq> 0;\n     \\<not> ((poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0) \\<and>\n             (poly p b \\<noteq> 0 \\<or>\n              poly (pderiv p) b \\<noteq> 0))\\<rbrakk>\n    \\<Longrightarrow> count_roots_between p a b =\n                      (let q = pderiv p\n                       in if b < a \\<or> p = 0 then 0\n                          else if (poly p a \\<noteq> 0 \\<or>\n                                   poly q a \\<noteq> 0) \\<and>\n                                  (poly p b \\<noteq> 0 \\<or>\n                                   poly q b \\<noteq> 0)\n                               then let ps = sturm p\n                                    in sign_changes ps a - sign_changes ps b\n                               else let ps = sturm_squarefree p\n                                    in sign_changes ps a -\n sign_changes ps b)", "case False"], ["proof (state)\nthis:\n  \\<not> ((poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0) \\<and>\n          (poly p b \\<noteq> 0 \\<or> poly (pderiv p) b \\<noteq> 0))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<le> b; p \\<noteq> 0;\n     (poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0) \\<and>\n     (poly p b \\<noteq> 0 \\<or> poly (pderiv p) b \\<noteq> 0)\\<rbrakk>\n    \\<Longrightarrow> count_roots_between p a b =\n                      (let q = pderiv p\n                       in if b < a \\<or> p = 0 then 0\n                          else if (poly p a \\<noteq> 0 \\<or>\n                                   poly q a \\<noteq> 0) \\<and>\n                                  (poly p b \\<noteq> 0 \\<or>\n                                   poly q b \\<noteq> 0)\n                               then let ps = sturm p\n                                    in sign_changes ps a - sign_changes ps b\n                               else let ps = sturm_squarefree p\n                                    in sign_changes ps a -\n sign_changes ps b)\n 2. \\<lbrakk>a \\<le> b; p \\<noteq> 0;\n     \\<not> ((poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0) \\<and>\n             (poly p b \\<noteq> 0 \\<or>\n              poly (pderiv p) b \\<noteq> 0))\\<rbrakk>\n    \\<Longrightarrow> count_roots_between p a b =\n                      (let q = pderiv p\n                       in if b < a \\<or> p = 0 then 0\n                          else if (poly p a \\<noteq> 0 \\<or>\n                                   poly q a \\<noteq> 0) \\<and>\n                                  (poly p b \\<noteq> 0 \\<or>\n                                   poly q b \\<noteq> 0)\n                               then let ps = sturm p\n                                    in sign_changes ps a - sign_changes ps b\n                               else let ps = sturm_squarefree p\n                                    in sign_changes ps a -\n sign_changes ps b)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> ((poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0) \\<and>\n          (poly p b \\<noteq> 0 \\<or> poly (pderiv p) b \\<noteq> 0))\n\ngoal (1 subgoal):\n 1. count_roots_between p a b =\n    (let q = pderiv p\n     in if b < a \\<or> p = 0 then 0\n        else if (poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0) \\<and>\n                (poly p b \\<noteq> 0 \\<or> poly q b \\<noteq> 0)\n             then let ps = sturm p in sign_changes ps a - sign_changes ps b\n             else let ps = sturm_squarefree p\n                  in sign_changes ps a - sign_changes ps b)", "using False1"], ["proof (prove)\nusing this:\n  \\<not> ((poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0) \\<and>\n          (poly p b \\<noteq> 0 \\<or> poly (pderiv p) b \\<noteq> 0))\n  \\<not> (b < a \\<or> p = 0)\n\ngoal (1 subgoal):\n 1. count_roots_between p a b =\n    (let q = pderiv p\n     in if b < a \\<or> p = 0 then 0\n        else if (poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0) \\<and>\n                (poly p b \\<noteq> 0 \\<or> poly q b \\<noteq> 0)\n             then let ps = sturm p in sign_changes ps a - sign_changes ps b\n             else let ps = sturm_squarefree p\n                  in sign_changes ps a - sign_changes ps b)", "by (auto simp add: Let_def count_roots_between_def)"], ["proof (state)\nthis:\n  count_roots_between p a b =\n  (let q = pderiv p\n   in if b < a \\<or> p = 0 then 0\n      else if (poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0) \\<and>\n              (poly p b \\<noteq> 0 \\<or> poly q b \\<noteq> 0)\n           then let ps = sturm p in sign_changes ps a - sign_changes ps b\n           else let ps = sturm_squarefree p\n                in sign_changes ps a - sign_changes ps b)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> b; p \\<noteq> 0;\n     (poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0) \\<and>\n     (poly p b \\<noteq> 0 \\<or> poly (pderiv p) b \\<noteq> 0)\\<rbrakk>\n    \\<Longrightarrow> count_roots_between p a b =\n                      (let q = pderiv p\n                       in if b < a \\<or> p = 0 then 0\n                          else if (poly p a \\<noteq> 0 \\<or>\n                                   poly q a \\<noteq> 0) \\<and>\n                                  (poly p b \\<noteq> 0 \\<or>\n                                   poly q b \\<noteq> 0)\n                               then let ps = sturm p\n                                    in sign_changes ps a - sign_changes ps b\n                               else let ps = sturm_squarefree p\n                                    in sign_changes ps a -\n sign_changes ps b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> b; p \\<noteq> 0;\n     (poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0) \\<and>\n     (poly p b \\<noteq> 0 \\<or> poly (pderiv p) b \\<noteq> 0)\\<rbrakk>\n    \\<Longrightarrow> count_roots_between p a b =\n                      (let q = pderiv p\n                       in if b < a \\<or> p = 0 then 0\n                          else if (poly p a \\<noteq> 0 \\<or>\n                                   poly q a \\<noteq> 0) \\<and>\n                                  (poly p b \\<noteq> 0 \\<or>\n                                   poly q b \\<noteq> 0)\n                               then let ps = sturm p\n                                    in sign_changes ps a - sign_changes ps b\n                               else let ps = sturm_squarefree p\n                                    in sign_changes ps a -\n sign_changes ps b)", "case True"], ["proof (state)\nthis:\n  (poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0) \\<and>\n  (poly p b \\<noteq> 0 \\<or> poly (pderiv p) b \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> b; p \\<noteq> 0;\n     (poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0) \\<and>\n     (poly p b \\<noteq> 0 \\<or> poly (pderiv p) b \\<noteq> 0)\\<rbrakk>\n    \\<Longrightarrow> count_roots_between p a b =\n                      (let q = pderiv p\n                       in if b < a \\<or> p = 0 then 0\n                          else if (poly p a \\<noteq> 0 \\<or>\n                                   poly q a \\<noteq> 0) \\<and>\n                                  (poly p b \\<noteq> 0 \\<or>\n                                   poly q b \\<noteq> 0)\n                               then let ps = sturm p\n                                    in sign_changes ps a - sign_changes ps b\n                               else let ps = sturm_squarefree p\n                                    in sign_changes ps a -\n sign_changes ps b)", "hence A: \"poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\" and\n            B: \"poly p b \\<noteq> 0 \\<or> poly (pderiv p) b \\<noteq> 0\""], ["proof (prove)\nusing this:\n  (poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0) \\<and>\n  (poly p b \\<noteq> 0 \\<or> poly (pderiv p) b \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0 &&&\n    poly p b \\<noteq> 0 \\<or> poly (pderiv p) b \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\n  poly p b \\<noteq> 0 \\<or> poly (pderiv p) b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> b; p \\<noteq> 0;\n     (poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0) \\<and>\n     (poly p b \\<noteq> 0 \\<or> poly (pderiv p) b \\<noteq> 0)\\<rbrakk>\n    \\<Longrightarrow> count_roots_between p a b =\n                      (let q = pderiv p\n                       in if b < a \\<or> p = 0 then 0\n                          else if (poly p a \\<noteq> 0 \\<or>\n                                   poly q a \\<noteq> 0) \\<and>\n                                  (poly p b \\<noteq> 0 \\<or>\n                                   poly q b \\<noteq> 0)\n                               then let ps = sturm p\n                                    in sign_changes ps a - sign_changes ps b\n                               else let ps = sturm_squarefree p\n                                    in sign_changes ps a -\n sign_changes ps b)", "define d where \"d = gcd p (pderiv p)\""], ["proof (state)\nthis:\n  d = gcd p (pderiv p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> b; p \\<noteq> 0;\n     (poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0) \\<and>\n     (poly p b \\<noteq> 0 \\<or> poly (pderiv p) b \\<noteq> 0)\\<rbrakk>\n    \\<Longrightarrow> count_roots_between p a b =\n                      (let q = pderiv p\n                       in if b < a \\<or> p = 0 then 0\n                          else if (poly p a \\<noteq> 0 \\<or>\n                                   poly q a \\<noteq> 0) \\<and>\n                                  (poly p b \\<noteq> 0 \\<or>\n                                   poly q b \\<noteq> 0)\n                               then let ps = sturm p\n                                    in sign_changes ps a - sign_changes ps b\n                               else let ps = sturm_squarefree p\n                                    in sign_changes ps a -\n sign_changes ps b)", "from \\<open>p \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "have [simp]: \"p div d \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p div d \\<noteq> 0", "using poly_div_gcd_squarefree(1)[OF \\<open>p \\<noteq> 0\\<close>]"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  coprime (p div gcd p (pderiv p)) (pderiv (p div gcd p (pderiv p)))\n\ngoal (1 subgoal):\n 1. p div d \\<noteq> 0", "by (auto simp add: d_def)"], ["proof (state)\nthis:\n  p div d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> b; p \\<noteq> 0;\n     (poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0) \\<and>\n     (poly p b \\<noteq> 0 \\<or> poly (pderiv p) b \\<noteq> 0)\\<rbrakk>\n    \\<Longrightarrow> count_roots_between p a b =\n                      (let q = pderiv p\n                       in if b < a \\<or> p = 0 then 0\n                          else if (poly p a \\<noteq> 0 \\<or>\n                                   poly q a \\<noteq> 0) \\<and>\n                                  (poly p b \\<noteq> 0 \\<or>\n                                   poly q b \\<noteq> 0)\n                               then let ps = sturm p\n                                    in sign_changes ps a - sign_changes ps b\n                               else let ps = sturm_squarefree p\n                                    in sign_changes ps a -\n sign_changes ps b)", "from sturm_seq_sturm_squarefree'[OF \\<open>p \\<noteq> 0\\<close>]"], ["proof (chain)\npicking this:\n  sturm_seq (sturm_squarefree' p) (p div gcd p (pderiv p))", "interpret sturm_seq \"sturm_squarefree' p\" \"p div d\""], ["proof (prove)\nusing this:\n  sturm_seq (sturm_squarefree' p) (p div gcd p (pderiv p))\n\ngoal (1 subgoal):\n 1. sturm_seq (sturm_squarefree' p) (p div d)", "unfolding sturm_squarefree'_def Let_def d_def"], ["proof (prove)\nusing this:\n  sturm_seq (map (\\<lambda>p'. p' div gcd p (pderiv p)) (sturm p))\n   (p div gcd p (pderiv p))\n\ngoal (1 subgoal):\n 1. sturm_seq (map (\\<lambda>p'. p' div gcd p (pderiv p)) (sturm p))\n     (p div gcd p (pderiv p))", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> b; p \\<noteq> 0;\n     (poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0) \\<and>\n     (poly p b \\<noteq> 0 \\<or> poly (pderiv p) b \\<noteq> 0)\\<rbrakk>\n    \\<Longrightarrow> count_roots_between p a b =\n                      (let q = pderiv p\n                       in if b < a \\<or> p = 0 then 0\n                          else if (poly p a \\<noteq> 0 \\<or>\n                                   poly q a \\<noteq> 0) \\<and>\n                                  (poly p b \\<noteq> 0 \\<or>\n                                   poly q b \\<noteq> 0)\n                               then let ps = sturm p\n                                    in sign_changes ps a - sign_changes ps b\n                               else let ps = sturm_squarefree p\n                                    in sign_changes ps a -\n sign_changes ps b)", "note count_roots_between_correct"], ["proof (state)\nthis:\n  count_roots_between ?p ?a ?b =\n  card {x. ?a < x \\<and> x \\<le> ?b \\<and> poly ?p x = 0}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> b; p \\<noteq> 0;\n     (poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0) \\<and>\n     (poly p b \\<noteq> 0 \\<or> poly (pderiv p) b \\<noteq> 0)\\<rbrakk>\n    \\<Longrightarrow> count_roots_between p a b =\n                      (let q = pderiv p\n                       in if b < a \\<or> p = 0 then 0\n                          else if (poly p a \\<noteq> 0 \\<or>\n                                   poly q a \\<noteq> 0) \\<and>\n                                  (poly p b \\<noteq> 0 \\<or>\n                                   poly q b \\<noteq> 0)\n                               then let ps = sturm p\n                                    in sign_changes ps a - sign_changes ps b\n                               else let ps = sturm_squarefree p\n                                    in sign_changes ps a -\n sign_changes ps b)", "also"], ["proof (state)\nthis:\n  count_roots_between ?p ?a ?b =\n  card {x. ?a < x \\<and> x \\<le> ?b \\<and> poly ?p x = 0}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> b; p \\<noteq> 0;\n     (poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0) \\<and>\n     (poly p b \\<noteq> 0 \\<or> poly (pderiv p) b \\<noteq> 0)\\<rbrakk>\n    \\<Longrightarrow> count_roots_between p a b =\n                      (let q = pderiv p\n                       in if b < a \\<or> p = 0 then 0\n                          else if (poly p a \\<noteq> 0 \\<or>\n                                   poly q a \\<noteq> 0) \\<and>\n                                  (poly p b \\<noteq> 0 \\<or>\n                                   poly q b \\<noteq> 0)\n                               then let ps = sturm p\n                                    in sign_changes ps a - sign_changes ps b\n                               else let ps = sturm_squarefree p\n                                    in sign_changes ps a -\n sign_changes ps b)", "have \"{x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} =\n                 {x. a < x \\<and> x \\<le> b \\<and> poly (p div d) x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} =\n    {x. a < x \\<and> x \\<le> b \\<and> poly (p div d) x = 0}", "unfolding d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} =\n    {x. a < x \\<and> x \\<le> b \\<and> poly (p div gcd p (pderiv p)) x = 0}", "using poly_div_gcd_squarefree(2)[OF \\<open>p \\<noteq> 0\\<close>]"], ["proof (prove)\nusing this:\n  (poly (p div gcd p (pderiv p)) ?x = 0) = (poly p ?x = 0)\n\ngoal (1 subgoal):\n 1. {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} =\n    {x. a < x \\<and> x \\<le> b \\<and> poly (p div gcd p (pderiv p)) x = 0}", "by simp"], ["proof (state)\nthis:\n  {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} =\n  {x. a < x \\<and> x \\<le> b \\<and> poly (p div d) x = 0}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> b; p \\<noteq> 0;\n     (poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0) \\<and>\n     (poly p b \\<noteq> 0 \\<or> poly (pderiv p) b \\<noteq> 0)\\<rbrakk>\n    \\<Longrightarrow> count_roots_between p a b =\n                      (let q = pderiv p\n                       in if b < a \\<or> p = 0 then 0\n                          else if (poly p a \\<noteq> 0 \\<or>\n                                   poly q a \\<noteq> 0) \\<and>\n                                  (poly p b \\<noteq> 0 \\<or>\n                                   poly q b \\<noteq> 0)\n                               then let ps = sturm p\n                                    in sign_changes ps a - sign_changes ps b\n                               else let ps = sturm_squarefree p\n                                    in sign_changes ps a -\n sign_changes ps b)", "also"], ["proof (state)\nthis:\n  {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} =\n  {x. a < x \\<and> x \\<le> b \\<and> poly (p div d) x = 0}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> b; p \\<noteq> 0;\n     (poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0) \\<and>\n     (poly p b \\<noteq> 0 \\<or> poly (pderiv p) b \\<noteq> 0)\\<rbrakk>\n    \\<Longrightarrow> count_roots_between p a b =\n                      (let q = pderiv p\n                       in if b < a \\<or> p = 0 then 0\n                          else if (poly p a \\<noteq> 0 \\<or>\n                                   poly q a \\<noteq> 0) \\<and>\n                                  (poly p b \\<noteq> 0 \\<or>\n                                   poly q b \\<noteq> 0)\n                               then let ps = sturm p\n                                    in sign_changes ps a - sign_changes ps b\n                               else let ps = sturm_squarefree p\n                                    in sign_changes ps a -\n sign_changes ps b)", "note count_roots_between[OF \\<open>p div d \\<noteq> 0\\<close> \\<open>a \\<le> b\\<close>, symmetric]"], ["proof (state)\nthis:\n  card {x. a < x \\<and> x \\<le> b \\<and> poly (p div d) x = 0} =\n  sign_changes (sturm_squarefree' p) a -\n  sign_changes (sturm_squarefree' p) b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> b; p \\<noteq> 0;\n     (poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0) \\<and>\n     (poly p b \\<noteq> 0 \\<or> poly (pderiv p) b \\<noteq> 0)\\<rbrakk>\n    \\<Longrightarrow> count_roots_between p a b =\n                      (let q = pderiv p\n                       in if b < a \\<or> p = 0 then 0\n                          else if (poly p a \\<noteq> 0 \\<or>\n                                   poly q a \\<noteq> 0) \\<and>\n                                  (poly p b \\<noteq> 0 \\<or>\n                                   poly q b \\<noteq> 0)\n                               then let ps = sturm p\n                                    in sign_changes ps a - sign_changes ps b\n                               else let ps = sturm_squarefree p\n                                    in sign_changes ps a -\n sign_changes ps b)", "also"], ["proof (state)\nthis:\n  card {x. a < x \\<and> x \\<le> b \\<and> poly (p div d) x = 0} =\n  sign_changes (sturm_squarefree' p) a -\n  sign_changes (sturm_squarefree' p) b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> b; p \\<noteq> 0;\n     (poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0) \\<and>\n     (poly p b \\<noteq> 0 \\<or> poly (pderiv p) b \\<noteq> 0)\\<rbrakk>\n    \\<Longrightarrow> count_roots_between p a b =\n                      (let q = pderiv p\n                       in if b < a \\<or> p = 0 then 0\n                          else if (poly p a \\<noteq> 0 \\<or>\n                                   poly q a \\<noteq> 0) \\<and>\n                                  (poly p b \\<noteq> 0 \\<or>\n                                   poly q b \\<noteq> 0)\n                               then let ps = sturm p\n                                    in sign_changes ps a - sign_changes ps b\n                               else let ps = sturm_squarefree p\n                                    in sign_changes ps a -\n sign_changes ps b)", "note sturm_sturm_squarefree'_same_sign_changes(1)[OF A]"], ["proof (state)\nthis:\n  sign_changes (sturm_squarefree' p) a = sign_changes (sturm p) a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> b; p \\<noteq> 0;\n     (poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0) \\<and>\n     (poly p b \\<noteq> 0 \\<or> poly (pderiv p) b \\<noteq> 0)\\<rbrakk>\n    \\<Longrightarrow> count_roots_between p a b =\n                      (let q = pderiv p\n                       in if b < a \\<or> p = 0 then 0\n                          else if (poly p a \\<noteq> 0 \\<or>\n                                   poly q a \\<noteq> 0) \\<and>\n                                  (poly p b \\<noteq> 0 \\<or>\n                                   poly q b \\<noteq> 0)\n                               then let ps = sturm p\n                                    in sign_changes ps a - sign_changes ps b\n                               else let ps = sturm_squarefree p\n                                    in sign_changes ps a -\n sign_changes ps b)", "also"], ["proof (state)\nthis:\n  sign_changes (sturm_squarefree' p) a = sign_changes (sturm p) a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> b; p \\<noteq> 0;\n     (poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0) \\<and>\n     (poly p b \\<noteq> 0 \\<or> poly (pderiv p) b \\<noteq> 0)\\<rbrakk>\n    \\<Longrightarrow> count_roots_between p a b =\n                      (let q = pderiv p\n                       in if b < a \\<or> p = 0 then 0\n                          else if (poly p a \\<noteq> 0 \\<or>\n                                   poly q a \\<noteq> 0) \\<and>\n                                  (poly p b \\<noteq> 0 \\<or>\n                                   poly q b \\<noteq> 0)\n                               then let ps = sturm p\n                                    in sign_changes ps a - sign_changes ps b\n                               else let ps = sturm_squarefree p\n                                    in sign_changes ps a -\n sign_changes ps b)", "note sturm_sturm_squarefree'_same_sign_changes(1)[OF B]"], ["proof (state)\nthis:\n  sign_changes (sturm_squarefree' p) b = sign_changes (sturm p) b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> b; p \\<noteq> 0;\n     (poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0) \\<and>\n     (poly p b \\<noteq> 0 \\<or> poly (pderiv p) b \\<noteq> 0)\\<rbrakk>\n    \\<Longrightarrow> count_roots_between p a b =\n                      (let q = pderiv p\n                       in if b < a \\<or> p = 0 then 0\n                          else if (poly p a \\<noteq> 0 \\<or>\n                                   poly q a \\<noteq> 0) \\<and>\n                                  (poly p b \\<noteq> 0 \\<or>\n                                   poly q b \\<noteq> 0)\n                               then let ps = sturm p\n                                    in sign_changes ps a - sign_changes ps b\n                               else let ps = sturm_squarefree p\n                                    in sign_changes ps a -\n sign_changes ps b)", "finally"], ["proof (chain)\npicking this:\n  count_roots_between p a b =\n  sign_changes (sturm p) a - sign_changes (sturm p) b", "show ?thesis"], ["proof (prove)\nusing this:\n  count_roots_between p a b =\n  sign_changes (sturm p) a - sign_changes (sturm p) b\n\ngoal (1 subgoal):\n 1. count_roots_between p a b =\n    (let q = pderiv p\n     in if b < a \\<or> p = 0 then 0\n        else if (poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0) \\<and>\n                (poly p b \\<noteq> 0 \\<or> poly q b \\<noteq> 0)\n             then let ps = sturm p in sign_changes ps a - sign_changes ps b\n             else let ps = sturm_squarefree p\n                  in sign_changes ps a - sign_changes ps b)", "using True False"], ["proof (prove)\nusing this:\n  count_roots_between p a b =\n  sign_changes (sturm p) a - sign_changes (sturm p) b\n  (poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0) \\<and>\n  (poly p b \\<noteq> 0 \\<or> poly (pderiv p) b \\<noteq> 0)\n  \\<not> (b < a \\<or> p = 0)\n\ngoal (1 subgoal):\n 1. count_roots_between p a b =\n    (let q = pderiv p\n     in if b < a \\<or> p = 0 then 0\n        else if (poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0) \\<and>\n                (poly p b \\<noteq> 0 \\<or> poly q b \\<noteq> 0)\n             then let ps = sturm p in sign_changes ps a - sign_changes ps b\n             else let ps = sturm_squarefree p\n                  in sign_changes ps a - sign_changes ps b)", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  count_roots_between p a b =\n  (let q = pderiv p\n   in if b < a \\<or> p = 0 then 0\n      else if (poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0) \\<and>\n              (poly p b \\<noteq> 0 \\<or> poly q b \\<noteq> 0)\n           then let ps = sturm p in sign_changes ps a - sign_changes ps b\n           else let ps = sturm_squarefree p\n                in sign_changes ps a - sign_changes ps b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  count_roots_between p a b =\n  (let q = pderiv p\n   in if b < a \\<or> p = 0 then 0\n      else if (poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0) \\<and>\n              (poly p b \\<noteq> 0 \\<or> poly q b \\<noteq> 0)\n           then let ps = sturm p in sign_changes ps a - sign_changes ps b\n           else let ps = sturm_squarefree p\n                in sign_changes ps a - sign_changes ps b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma count_roots_code[code]:\n  \"count_roots (p::real poly) =\n    (if p = 0 then 0\n     else let ps = sturm p\n           in sign_changes_neg_inf ps - sign_changes_inf ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_roots p =\n    (if p = 0 then 0\n     else let ps = sturm p in sign_changes_neg_inf ps - sign_changes_inf ps)", "proof (cases \"p = 0\", simp add: count_roots_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots p =\n    (if p = 0 then 0\n     else let ps = sturm p in sign_changes_neg_inf ps - sign_changes_inf ps)", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots p =\n    (if p = 0 then 0\n     else let ps = sturm p in sign_changes_neg_inf ps - sign_changes_inf ps)", "define d where \"d = gcd p (pderiv p)\""], ["proof (state)\nthis:\n  d = gcd p (pderiv p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots p =\n    (if p = 0 then 0\n     else let ps = sturm p in sign_changes_neg_inf ps - sign_changes_inf ps)", "from \\<open>p \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "have [simp]: \"p div d \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p div d \\<noteq> 0", "using poly_div_gcd_squarefree(1)[OF \\<open>p \\<noteq> 0\\<close>]"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  coprime (p div gcd p (pderiv p)) (pderiv (p div gcd p (pderiv p)))\n\ngoal (1 subgoal):\n 1. p div d \\<noteq> 0", "by (auto simp add: d_def)"], ["proof (state)\nthis:\n  p div d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots p =\n    (if p = 0 then 0\n     else let ps = sturm p in sign_changes_neg_inf ps - sign_changes_inf ps)", "from sturm_seq_sturm_squarefree'[OF \\<open>p \\<noteq> 0\\<close>]"], ["proof (chain)\npicking this:\n  sturm_seq (sturm_squarefree' p) (p div gcd p (pderiv p))", "interpret sturm_seq \"sturm_squarefree' p\" \"p div d\""], ["proof (prove)\nusing this:\n  sturm_seq (sturm_squarefree' p) (p div gcd p (pderiv p))\n\ngoal (1 subgoal):\n 1. sturm_seq (sturm_squarefree' p) (p div d)", "unfolding sturm_squarefree'_def Let_def d_def"], ["proof (prove)\nusing this:\n  sturm_seq (map (\\<lambda>p'. p' div gcd p (pderiv p)) (sturm p))\n   (p div gcd p (pderiv p))\n\ngoal (1 subgoal):\n 1. sturm_seq (map (\\<lambda>p'. p' div gcd p (pderiv p)) (sturm p))\n     (p div gcd p (pderiv p))", "."], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots p =\n    (if p = 0 then 0\n     else let ps = sturm p in sign_changes_neg_inf ps - sign_changes_inf ps)", "note count_roots_correct"], ["proof (state)\nthis:\n  count_roots ?p = card {x. poly ?p x = 0}\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots p =\n    (if p = 0 then 0\n     else let ps = sturm p in sign_changes_neg_inf ps - sign_changes_inf ps)", "also"], ["proof (state)\nthis:\n  count_roots ?p = card {x. poly ?p x = 0}\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots p =\n    (if p = 0 then 0\n     else let ps = sturm p in sign_changes_neg_inf ps - sign_changes_inf ps)", "have \"{x. poly p x = 0} = {x. poly (p div d) x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = {x. poly (p div d) x = 0}", "unfolding d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = {x. poly (p div gcd p (pderiv p)) x = 0}", "using poly_div_gcd_squarefree(2)[OF \\<open>p \\<noteq> 0\\<close>]"], ["proof (prove)\nusing this:\n  (poly (p div gcd p (pderiv p)) ?x = 0) = (poly p ?x = 0)\n\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = {x. poly (p div gcd p (pderiv p)) x = 0}", "by simp"], ["proof (state)\nthis:\n  {x. poly p x = 0} = {x. poly (p div d) x = 0}\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots p =\n    (if p = 0 then 0\n     else let ps = sturm p in sign_changes_neg_inf ps - sign_changes_inf ps)", "also"], ["proof (state)\nthis:\n  {x. poly p x = 0} = {x. poly (p div d) x = 0}\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots p =\n    (if p = 0 then 0\n     else let ps = sturm p in sign_changes_neg_inf ps - sign_changes_inf ps)", "note count_roots[OF \\<open>p div d \\<noteq> 0\\<close>, symmetric]"], ["proof (state)\nthis:\n  card {x. poly (p div d) x = 0} =\n  sign_changes_neg_inf (sturm_squarefree' p) -\n  sign_changes_inf (sturm_squarefree' p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots p =\n    (if p = 0 then 0\n     else let ps = sturm p in sign_changes_neg_inf ps - sign_changes_inf ps)", "also"], ["proof (state)\nthis:\n  card {x. poly (p div d) x = 0} =\n  sign_changes_neg_inf (sturm_squarefree' p) -\n  sign_changes_inf (sturm_squarefree' p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots p =\n    (if p = 0 then 0\n     else let ps = sturm p in sign_changes_neg_inf ps - sign_changes_inf ps)", "note sturm_sturm_squarefree'_same_sign_changes(2)[OF \\<open>p \\<noteq> 0\\<close>]"], ["proof (state)\nthis:\n  sign_changes_inf (sturm_squarefree' p) = sign_changes_inf (sturm p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots p =\n    (if p = 0 then 0\n     else let ps = sturm p in sign_changes_neg_inf ps - sign_changes_inf ps)", "also"], ["proof (state)\nthis:\n  sign_changes_inf (sturm_squarefree' p) = sign_changes_inf (sturm p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots p =\n    (if p = 0 then 0\n     else let ps = sturm p in sign_changes_neg_inf ps - sign_changes_inf ps)", "note sturm_sturm_squarefree'_same_sign_changes(3)[OF \\<open>p \\<noteq> 0\\<close>]"], ["proof (state)\nthis:\n  sign_changes_neg_inf (sturm_squarefree' p) =\n  sign_changes_neg_inf (sturm p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots p =\n    (if p = 0 then 0\n     else let ps = sturm p in sign_changes_neg_inf ps - sign_changes_inf ps)", "finally"], ["proof (chain)\npicking this:\n  count_roots p =\n  sign_changes_neg_inf (sturm p) - sign_changes_inf (sturm p)", "show ?thesis"], ["proof (prove)\nusing this:\n  count_roots p =\n  sign_changes_neg_inf (sturm p) - sign_changes_inf (sturm p)\n\ngoal (1 subgoal):\n 1. count_roots p =\n    (if p = 0 then 0\n     else let ps = sturm p in sign_changes_neg_inf ps - sign_changes_inf ps)", "using False"], ["proof (prove)\nusing this:\n  count_roots p =\n  sign_changes_neg_inf (sturm p) - sign_changes_inf (sturm p)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. count_roots p =\n    (if p = 0 then 0\n     else let ps = sturm p in sign_changes_neg_inf ps - sign_changes_inf ps)", "unfolding Let_def"], ["proof (prove)\nusing this:\n  count_roots p =\n  sign_changes_neg_inf (sturm p) - sign_changes_inf (sturm p)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. count_roots p =\n    (if p = 0 then 0\n     else sign_changes_neg_inf (sturm p) - sign_changes_inf (sturm p))", "by simp"], ["proof (state)\nthis:\n  count_roots p =\n  (if p = 0 then 0\n   else let ps = sturm p in sign_changes_neg_inf ps - sign_changes_inf ps)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma count_roots_above_code[code]:\n  \"count_roots_above p a =\n     (let q = pderiv p\n       in if p = 0 then 0\n       else if poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0\n            then (let ps = sturm p\n                   in sign_changes ps a - sign_changes_inf ps)\n            else (let ps = sturm_squarefree p\n                   in sign_changes ps a - sign_changes_inf ps))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_roots_above p a =\n    (let q = pderiv p\n     in if p = 0 then 0\n        else if poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0\n             then let ps = sturm p\n                  in sign_changes ps a - sign_changes_inf ps\n             else let ps = sturm_squarefree p\n                  in sign_changes ps a - sign_changes_inf ps)", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    count_roots_above p a =\n    (let q = pderiv p\n     in if p = 0 then 0\n        else if poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0\n             then let ps = sturm p\n                  in sign_changes ps a - sign_changes_inf ps\n             else let ps = sturm_squarefree p\n                  in sign_changes ps a - sign_changes_inf ps)\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots_above p a =\n    (let q = pderiv p\n     in if p = 0 then 0\n        else if poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0\n             then let ps = sturm p\n                  in sign_changes ps a - sign_changes_inf ps\n             else let ps = sturm_squarefree p\n                  in sign_changes ps a - sign_changes_inf ps)", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    count_roots_above p a =\n    (let q = pderiv p\n     in if p = 0 then 0\n        else if poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0\n             then let ps = sturm p\n                  in sign_changes ps a - sign_changes_inf ps\n             else let ps = sturm_squarefree p\n                  in sign_changes ps a - sign_changes_inf ps)\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots_above p a =\n    (let q = pderiv p\n     in if p = 0 then 0\n        else if poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0\n             then let ps = sturm p\n                  in sign_changes ps a - sign_changes_inf ps\n             else let ps = sturm_squarefree p\n                  in sign_changes ps a - sign_changes_inf ps)", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. count_roots_above p a =\n    (let q = pderiv p\n     in if p = 0 then 0\n        else if poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0\n             then let ps = sturm p\n                  in sign_changes ps a - sign_changes_inf ps\n             else let ps = sturm_squarefree p\n                  in sign_changes ps a - sign_changes_inf ps)", "by (auto simp add: count_roots_above_def Let_def)"], ["proof (state)\nthis:\n  count_roots_above p a =\n  (let q = pderiv p\n   in if p = 0 then 0\n      else if poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0\n           then let ps = sturm p in sign_changes ps a - sign_changes_inf ps\n           else let ps = sturm_squarefree p\n                in sign_changes ps a - sign_changes_inf ps)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots_above p a =\n    (let q = pderiv p\n     in if p = 0 then 0\n        else if poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0\n             then let ps = sturm p\n                  in sign_changes ps a - sign_changes_inf ps\n             else let ps = sturm_squarefree p\n                  in sign_changes ps a - sign_changes_inf ps)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots_above p a =\n    (let q = pderiv p\n     in if p = 0 then 0\n        else if poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0\n             then let ps = sturm p\n                  in sign_changes ps a - sign_changes_inf ps\n             else let ps = sturm_squarefree p\n                  in sign_changes ps a - sign_changes_inf ps)", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots_above p a =\n    (let q = pderiv p\n     in if p = 0 then 0\n        else if poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0\n             then let ps = sturm p\n                  in sign_changes ps a - sign_changes_inf ps\n             else let ps = sturm_squarefree p\n                  in sign_changes ps a - sign_changes_inf ps)", "note False1 = this"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots_above p a =\n    (let q = pderiv p\n     in if p = 0 then 0\n        else if poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0\n             then let ps = sturm p\n                  in sign_changes ps a - sign_changes_inf ps\n             else let ps = sturm_squarefree p\n                  in sign_changes ps a - sign_changes_inf ps)", "hence \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by simp_all"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots_above p a =\n    (let q = pderiv p\n     in if p = 0 then 0\n        else if poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0\n             then let ps = sturm p\n                  in sign_changes ps a - sign_changes_inf ps\n             else let ps = sturm_squarefree p\n                  in sign_changes ps a - sign_changes_inf ps)", "thus ?thesis"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. count_roots_above p a =\n    (let q = pderiv p\n     in if p = 0 then 0\n        else if poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0\n             then let ps = sturm p\n                  in sign_changes ps a - sign_changes_inf ps\n             else let ps = sturm_squarefree p\n                  in sign_changes ps a - sign_changes_inf ps)", "proof (cases \"(poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>p \\<noteq> 0;\n     poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> count_roots_above p a =\n                      (let q = pderiv p\n                       in if p = 0 then 0\n                          else if poly p a \\<noteq> 0 \\<or>\n                                  poly q a \\<noteq> 0\n                               then let ps = sturm p\n                                    in sign_changes ps a -\n sign_changes_inf ps\n                               else let ps = sturm_squarefree p\n                                    in sign_changes ps a -\n sign_changes_inf ps)\n 2. \\<lbrakk>p \\<noteq> 0;\n     \\<not> (poly p a \\<noteq> 0 \\<or>\n             poly (pderiv p) a \\<noteq> 0)\\<rbrakk>\n    \\<Longrightarrow> count_roots_above p a =\n                      (let q = pderiv p\n                       in if p = 0 then 0\n                          else if poly p a \\<noteq> 0 \\<or>\n                                  poly q a \\<noteq> 0\n                               then let ps = sturm p\n                                    in sign_changes ps a -\n sign_changes_inf ps\n                               else let ps = sturm_squarefree p\n                                    in sign_changes ps a -\n sign_changes_inf ps)", "case False"], ["proof (state)\nthis:\n  \\<not> (poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>p \\<noteq> 0;\n     poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> count_roots_above p a =\n                      (let q = pderiv p\n                       in if p = 0 then 0\n                          else if poly p a \\<noteq> 0 \\<or>\n                                  poly q a \\<noteq> 0\n                               then let ps = sturm p\n                                    in sign_changes ps a -\n sign_changes_inf ps\n                               else let ps = sturm_squarefree p\n                                    in sign_changes ps a -\n sign_changes_inf ps)\n 2. \\<lbrakk>p \\<noteq> 0;\n     \\<not> (poly p a \\<noteq> 0 \\<or>\n             poly (pderiv p) a \\<noteq> 0)\\<rbrakk>\n    \\<Longrightarrow> count_roots_above p a =\n                      (let q = pderiv p\n                       in if p = 0 then 0\n                          else if poly p a \\<noteq> 0 \\<or>\n                                  poly q a \\<noteq> 0\n                               then let ps = sturm p\n                                    in sign_changes ps a -\n sign_changes_inf ps\n                               else let ps = sturm_squarefree p\n                                    in sign_changes ps a -\n sign_changes_inf ps)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. count_roots_above p a =\n    (let q = pderiv p\n     in if p = 0 then 0\n        else if poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0\n             then let ps = sturm p\n                  in sign_changes ps a - sign_changes_inf ps\n             else let ps = sturm_squarefree p\n                  in sign_changes ps a - sign_changes_inf ps)", "using False1"], ["proof (prove)\nusing this:\n  \\<not> (poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. count_roots_above p a =\n    (let q = pderiv p\n     in if p = 0 then 0\n        else if poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0\n             then let ps = sturm p\n                  in sign_changes ps a - sign_changes_inf ps\n             else let ps = sturm_squarefree p\n                  in sign_changes ps a - sign_changes_inf ps)", "by (auto simp add: Let_def count_roots_above_def)"], ["proof (state)\nthis:\n  count_roots_above p a =\n  (let q = pderiv p\n   in if p = 0 then 0\n      else if poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0\n           then let ps = sturm p in sign_changes ps a - sign_changes_inf ps\n           else let ps = sturm_squarefree p\n                in sign_changes ps a - sign_changes_inf ps)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0;\n     poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> count_roots_above p a =\n                      (let q = pderiv p\n                       in if p = 0 then 0\n                          else if poly p a \\<noteq> 0 \\<or>\n                                  poly q a \\<noteq> 0\n                               then let ps = sturm p\n                                    in sign_changes ps a -\n sign_changes_inf ps\n                               else let ps = sturm_squarefree p\n                                    in sign_changes ps a -\n sign_changes_inf ps)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0;\n     poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> count_roots_above p a =\n                      (let q = pderiv p\n                       in if p = 0 then 0\n                          else if poly p a \\<noteq> 0 \\<or>\n                                  poly q a \\<noteq> 0\n                               then let ps = sturm p\n                                    in sign_changes ps a -\n sign_changes_inf ps\n                               else let ps = sturm_squarefree p\n                                    in sign_changes ps a -\n sign_changes_inf ps)", "case True"], ["proof (state)\nthis:\n  poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0;\n     poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> count_roots_above p a =\n                      (let q = pderiv p\n                       in if p = 0 then 0\n                          else if poly p a \\<noteq> 0 \\<or>\n                                  poly q a \\<noteq> 0\n                               then let ps = sturm p\n                                    in sign_changes ps a -\n sign_changes_inf ps\n                               else let ps = sturm_squarefree p\n                                    in sign_changes ps a -\n sign_changes_inf ps)", "hence A: \"poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\""], ["proof (prove)\nusing this:\n  poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0;\n     poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> count_roots_above p a =\n                      (let q = pderiv p\n                       in if p = 0 then 0\n                          else if poly p a \\<noteq> 0 \\<or>\n                                  poly q a \\<noteq> 0\n                               then let ps = sturm p\n                                    in sign_changes ps a -\n sign_changes_inf ps\n                               else let ps = sturm_squarefree p\n                                    in sign_changes ps a -\n sign_changes_inf ps)", "define d where \"d = gcd p (pderiv p)\""], ["proof (state)\nthis:\n  d = gcd p (pderiv p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0;\n     poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> count_roots_above p a =\n                      (let q = pderiv p\n                       in if p = 0 then 0\n                          else if poly p a \\<noteq> 0 \\<or>\n                                  poly q a \\<noteq> 0\n                               then let ps = sturm p\n                                    in sign_changes ps a -\n sign_changes_inf ps\n                               else let ps = sturm_squarefree p\n                                    in sign_changes ps a -\n sign_changes_inf ps)", "from \\<open>p \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "have [simp]: \"p div d \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p div d \\<noteq> 0", "using poly_div_gcd_squarefree(1)[OF \\<open>p \\<noteq> 0\\<close>]"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  coprime (p div gcd p (pderiv p)) (pderiv (p div gcd p (pderiv p)))\n\ngoal (1 subgoal):\n 1. p div d \\<noteq> 0", "by (auto simp add: d_def)"], ["proof (state)\nthis:\n  p div d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0;\n     poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> count_roots_above p a =\n                      (let q = pderiv p\n                       in if p = 0 then 0\n                          else if poly p a \\<noteq> 0 \\<or>\n                                  poly q a \\<noteq> 0\n                               then let ps = sturm p\n                                    in sign_changes ps a -\n sign_changes_inf ps\n                               else let ps = sturm_squarefree p\n                                    in sign_changes ps a -\n sign_changes_inf ps)", "from sturm_seq_sturm_squarefree'[OF \\<open>p \\<noteq> 0\\<close>]"], ["proof (chain)\npicking this:\n  sturm_seq (sturm_squarefree' p) (p div gcd p (pderiv p))", "interpret sturm_seq \"sturm_squarefree' p\" \"p div d\""], ["proof (prove)\nusing this:\n  sturm_seq (sturm_squarefree' p) (p div gcd p (pderiv p))\n\ngoal (1 subgoal):\n 1. sturm_seq (sturm_squarefree' p) (p div d)", "unfolding sturm_squarefree'_def Let_def d_def"], ["proof (prove)\nusing this:\n  sturm_seq (map (\\<lambda>p'. p' div gcd p (pderiv p)) (sturm p))\n   (p div gcd p (pderiv p))\n\ngoal (1 subgoal):\n 1. sturm_seq (map (\\<lambda>p'. p' div gcd p (pderiv p)) (sturm p))\n     (p div gcd p (pderiv p))", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0;\n     poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> count_roots_above p a =\n                      (let q = pderiv p\n                       in if p = 0 then 0\n                          else if poly p a \\<noteq> 0 \\<or>\n                                  poly q a \\<noteq> 0\n                               then let ps = sturm p\n                                    in sign_changes ps a -\n sign_changes_inf ps\n                               else let ps = sturm_squarefree p\n                                    in sign_changes ps a -\n sign_changes_inf ps)", "note count_roots_above_correct"], ["proof (state)\nthis:\n  count_roots_above ?p ?a = card {x. ?a < x \\<and> poly ?p x = 0}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0;\n     poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> count_roots_above p a =\n                      (let q = pderiv p\n                       in if p = 0 then 0\n                          else if poly p a \\<noteq> 0 \\<or>\n                                  poly q a \\<noteq> 0\n                               then let ps = sturm p\n                                    in sign_changes ps a -\n sign_changes_inf ps\n                               else let ps = sturm_squarefree p\n                                    in sign_changes ps a -\n sign_changes_inf ps)", "also"], ["proof (state)\nthis:\n  count_roots_above ?p ?a = card {x. ?a < x \\<and> poly ?p x = 0}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0;\n     poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> count_roots_above p a =\n                      (let q = pderiv p\n                       in if p = 0 then 0\n                          else if poly p a \\<noteq> 0 \\<or>\n                                  poly q a \\<noteq> 0\n                               then let ps = sturm p\n                                    in sign_changes ps a -\n sign_changes_inf ps\n                               else let ps = sturm_squarefree p\n                                    in sign_changes ps a -\n sign_changes_inf ps)", "have \"{x. a < x \\<and> poly p x = 0} =\n                 {x. a < x \\<and> poly (p div d) x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. a < x \\<and> poly p x = 0} = {x. a < x \\<and> poly (p div d) x = 0}", "unfolding d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. a < x \\<and> poly p x = 0} =\n    {x. a < x \\<and> poly (p div gcd p (pderiv p)) x = 0}", "using poly_div_gcd_squarefree(2)[OF \\<open>p \\<noteq> 0\\<close>]"], ["proof (prove)\nusing this:\n  (poly (p div gcd p (pderiv p)) ?x = 0) = (poly p ?x = 0)\n\ngoal (1 subgoal):\n 1. {x. a < x \\<and> poly p x = 0} =\n    {x. a < x \\<and> poly (p div gcd p (pderiv p)) x = 0}", "by simp"], ["proof (state)\nthis:\n  {x. a < x \\<and> poly p x = 0} = {x. a < x \\<and> poly (p div d) x = 0}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0;\n     poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> count_roots_above p a =\n                      (let q = pderiv p\n                       in if p = 0 then 0\n                          else if poly p a \\<noteq> 0 \\<or>\n                                  poly q a \\<noteq> 0\n                               then let ps = sturm p\n                                    in sign_changes ps a -\n sign_changes_inf ps\n                               else let ps = sturm_squarefree p\n                                    in sign_changes ps a -\n sign_changes_inf ps)", "also"], ["proof (state)\nthis:\n  {x. a < x \\<and> poly p x = 0} = {x. a < x \\<and> poly (p div d) x = 0}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0;\n     poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> count_roots_above p a =\n                      (let q = pderiv p\n                       in if p = 0 then 0\n                          else if poly p a \\<noteq> 0 \\<or>\n                                  poly q a \\<noteq> 0\n                               then let ps = sturm p\n                                    in sign_changes ps a -\n sign_changes_inf ps\n                               else let ps = sturm_squarefree p\n                                    in sign_changes ps a -\n sign_changes_inf ps)", "note count_roots_above[OF \\<open>p div d \\<noteq> 0\\<close>, symmetric]"], ["proof (state)\nthis:\n  card {x. ?a < x \\<and> poly (p div d) x = 0} =\n  sign_changes (sturm_squarefree' p) ?a -\n  sign_changes_inf (sturm_squarefree' p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0;\n     poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> count_roots_above p a =\n                      (let q = pderiv p\n                       in if p = 0 then 0\n                          else if poly p a \\<noteq> 0 \\<or>\n                                  poly q a \\<noteq> 0\n                               then let ps = sturm p\n                                    in sign_changes ps a -\n sign_changes_inf ps\n                               else let ps = sturm_squarefree p\n                                    in sign_changes ps a -\n sign_changes_inf ps)", "also"], ["proof (state)\nthis:\n  card {x. ?a < x \\<and> poly (p div d) x = 0} =\n  sign_changes (sturm_squarefree' p) ?a -\n  sign_changes_inf (sturm_squarefree' p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0;\n     poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> count_roots_above p a =\n                      (let q = pderiv p\n                       in if p = 0 then 0\n                          else if poly p a \\<noteq> 0 \\<or>\n                                  poly q a \\<noteq> 0\n                               then let ps = sturm p\n                                    in sign_changes ps a -\n sign_changes_inf ps\n                               else let ps = sturm_squarefree p\n                                    in sign_changes ps a -\n sign_changes_inf ps)", "note sturm_sturm_squarefree'_same_sign_changes(1)[OF A]"], ["proof (state)\nthis:\n  sign_changes (sturm_squarefree' p) a = sign_changes (sturm p) a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0;\n     poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> count_roots_above p a =\n                      (let q = pderiv p\n                       in if p = 0 then 0\n                          else if poly p a \\<noteq> 0 \\<or>\n                                  poly q a \\<noteq> 0\n                               then let ps = sturm p\n                                    in sign_changes ps a -\n sign_changes_inf ps\n                               else let ps = sturm_squarefree p\n                                    in sign_changes ps a -\n sign_changes_inf ps)", "also"], ["proof (state)\nthis:\n  sign_changes (sturm_squarefree' p) a = sign_changes (sturm p) a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0;\n     poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> count_roots_above p a =\n                      (let q = pderiv p\n                       in if p = 0 then 0\n                          else if poly p a \\<noteq> 0 \\<or>\n                                  poly q a \\<noteq> 0\n                               then let ps = sturm p\n                                    in sign_changes ps a -\n sign_changes_inf ps\n                               else let ps = sturm_squarefree p\n                                    in sign_changes ps a -\n sign_changes_inf ps)", "note sturm_sturm_squarefree'_same_sign_changes(2)[OF \\<open>p \\<noteq> 0\\<close>]"], ["proof (state)\nthis:\n  sign_changes_inf (sturm_squarefree' p) = sign_changes_inf (sturm p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0;\n     poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> count_roots_above p a =\n                      (let q = pderiv p\n                       in if p = 0 then 0\n                          else if poly p a \\<noteq> 0 \\<or>\n                                  poly q a \\<noteq> 0\n                               then let ps = sturm p\n                                    in sign_changes ps a -\n sign_changes_inf ps\n                               else let ps = sturm_squarefree p\n                                    in sign_changes ps a -\n sign_changes_inf ps)", "finally"], ["proof (chain)\npicking this:\n  count_roots_above p a =\n  sign_changes (sturm p) a - sign_changes_inf (sturm p)", "show ?thesis"], ["proof (prove)\nusing this:\n  count_roots_above p a =\n  sign_changes (sturm p) a - sign_changes_inf (sturm p)\n\ngoal (1 subgoal):\n 1. count_roots_above p a =\n    (let q = pderiv p\n     in if p = 0 then 0\n        else if poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0\n             then let ps = sturm p\n                  in sign_changes ps a - sign_changes_inf ps\n             else let ps = sturm_squarefree p\n                  in sign_changes ps a - sign_changes_inf ps)", "using True False"], ["proof (prove)\nusing this:\n  count_roots_above p a =\n  sign_changes (sturm p) a - sign_changes_inf (sturm p)\n  poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. count_roots_above p a =\n    (let q = pderiv p\n     in if p = 0 then 0\n        else if poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0\n             then let ps = sturm p\n                  in sign_changes ps a - sign_changes_inf ps\n             else let ps = sturm_squarefree p\n                  in sign_changes ps a - sign_changes_inf ps)", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  count_roots_above p a =\n  (let q = pderiv p\n   in if p = 0 then 0\n      else if poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0\n           then let ps = sturm p in sign_changes ps a - sign_changes_inf ps\n           else let ps = sturm_squarefree p\n                in sign_changes ps a - sign_changes_inf ps)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  count_roots_above p a =\n  (let q = pderiv p\n   in if p = 0 then 0\n      else if poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0\n           then let ps = sturm p in sign_changes ps a - sign_changes_inf ps\n           else let ps = sturm_squarefree p\n                in sign_changes ps a - sign_changes_inf ps)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma count_roots_below_code[code]:\n  \"count_roots_below p a =\n     (let q = pderiv p\n       in if p = 0 then 0\n       else if poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0\n            then (let ps = sturm p\n                   in sign_changes_neg_inf ps - sign_changes ps a)\n            else (let ps = sturm_squarefree p\n                   in sign_changes_neg_inf ps - sign_changes ps a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_roots_below p a =\n    (let q = pderiv p\n     in if p = 0 then 0\n        else if poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0\n             then let ps = sturm p\n                  in sign_changes_neg_inf ps - sign_changes ps a\n             else let ps = sturm_squarefree p\n                  in sign_changes_neg_inf ps - sign_changes ps a)", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    count_roots_below p a =\n    (let q = pderiv p\n     in if p = 0 then 0\n        else if poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0\n             then let ps = sturm p\n                  in sign_changes_neg_inf ps - sign_changes ps a\n             else let ps = sturm_squarefree p\n                  in sign_changes_neg_inf ps - sign_changes ps a)\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots_below p a =\n    (let q = pderiv p\n     in if p = 0 then 0\n        else if poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0\n             then let ps = sturm p\n                  in sign_changes_neg_inf ps - sign_changes ps a\n             else let ps = sturm_squarefree p\n                  in sign_changes_neg_inf ps - sign_changes ps a)", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    count_roots_below p a =\n    (let q = pderiv p\n     in if p = 0 then 0\n        else if poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0\n             then let ps = sturm p\n                  in sign_changes_neg_inf ps - sign_changes ps a\n             else let ps = sturm_squarefree p\n                  in sign_changes_neg_inf ps - sign_changes ps a)\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots_below p a =\n    (let q = pderiv p\n     in if p = 0 then 0\n        else if poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0\n             then let ps = sturm p\n                  in sign_changes_neg_inf ps - sign_changes ps a\n             else let ps = sturm_squarefree p\n                  in sign_changes_neg_inf ps - sign_changes ps a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. count_roots_below p a =\n    (let q = pderiv p\n     in if p = 0 then 0\n        else if poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0\n             then let ps = sturm p\n                  in sign_changes_neg_inf ps - sign_changes ps a\n             else let ps = sturm_squarefree p\n                  in sign_changes_neg_inf ps - sign_changes ps a)", "by (auto simp add: count_roots_below_def Let_def)"], ["proof (state)\nthis:\n  count_roots_below p a =\n  (let q = pderiv p\n   in if p = 0 then 0\n      else if poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0\n           then let ps = sturm p\n                in sign_changes_neg_inf ps - sign_changes ps a\n           else let ps = sturm_squarefree p\n                in sign_changes_neg_inf ps - sign_changes ps a)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots_below p a =\n    (let q = pderiv p\n     in if p = 0 then 0\n        else if poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0\n             then let ps = sturm p\n                  in sign_changes_neg_inf ps - sign_changes ps a\n             else let ps = sturm_squarefree p\n                  in sign_changes_neg_inf ps - sign_changes ps a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots_below p a =\n    (let q = pderiv p\n     in if p = 0 then 0\n        else if poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0\n             then let ps = sturm p\n                  in sign_changes_neg_inf ps - sign_changes ps a\n             else let ps = sturm_squarefree p\n                  in sign_changes_neg_inf ps - sign_changes ps a)", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots_below p a =\n    (let q = pderiv p\n     in if p = 0 then 0\n        else if poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0\n             then let ps = sturm p\n                  in sign_changes_neg_inf ps - sign_changes ps a\n             else let ps = sturm_squarefree p\n                  in sign_changes_neg_inf ps - sign_changes ps a)", "note False1 = this"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots_below p a =\n    (let q = pderiv p\n     in if p = 0 then 0\n        else if poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0\n             then let ps = sturm p\n                  in sign_changes_neg_inf ps - sign_changes ps a\n             else let ps = sturm_squarefree p\n                  in sign_changes_neg_inf ps - sign_changes ps a)", "hence \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by simp_all"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    count_roots_below p a =\n    (let q = pderiv p\n     in if p = 0 then 0\n        else if poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0\n             then let ps = sturm p\n                  in sign_changes_neg_inf ps - sign_changes ps a\n             else let ps = sturm_squarefree p\n                  in sign_changes_neg_inf ps - sign_changes ps a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. count_roots_below p a =\n    (let q = pderiv p\n     in if p = 0 then 0\n        else if poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0\n             then let ps = sturm p\n                  in sign_changes_neg_inf ps - sign_changes ps a\n             else let ps = sturm_squarefree p\n                  in sign_changes_neg_inf ps - sign_changes ps a)", "proof (cases \"(poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>p \\<noteq> 0;\n     poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> count_roots_below p a =\n                      (let q = pderiv p\n                       in if p = 0 then 0\n                          else if poly p a \\<noteq> 0 \\<or>\n                                  poly q a \\<noteq> 0\n                               then let ps = sturm p\n                                    in sign_changes_neg_inf ps -\n sign_changes ps a\n                               else let ps = sturm_squarefree p\n                                    in sign_changes_neg_inf ps -\n sign_changes ps a)\n 2. \\<lbrakk>p \\<noteq> 0;\n     \\<not> (poly p a \\<noteq> 0 \\<or>\n             poly (pderiv p) a \\<noteq> 0)\\<rbrakk>\n    \\<Longrightarrow> count_roots_below p a =\n                      (let q = pderiv p\n                       in if p = 0 then 0\n                          else if poly p a \\<noteq> 0 \\<or>\n                                  poly q a \\<noteq> 0\n                               then let ps = sturm p\n                                    in sign_changes_neg_inf ps -\n sign_changes ps a\n                               else let ps = sturm_squarefree p\n                                    in sign_changes_neg_inf ps -\n sign_changes ps a)", "case False"], ["proof (state)\nthis:\n  \\<not> (poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>p \\<noteq> 0;\n     poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> count_roots_below p a =\n                      (let q = pderiv p\n                       in if p = 0 then 0\n                          else if poly p a \\<noteq> 0 \\<or>\n                                  poly q a \\<noteq> 0\n                               then let ps = sturm p\n                                    in sign_changes_neg_inf ps -\n sign_changes ps a\n                               else let ps = sturm_squarefree p\n                                    in sign_changes_neg_inf ps -\n sign_changes ps a)\n 2. \\<lbrakk>p \\<noteq> 0;\n     \\<not> (poly p a \\<noteq> 0 \\<or>\n             poly (pderiv p) a \\<noteq> 0)\\<rbrakk>\n    \\<Longrightarrow> count_roots_below p a =\n                      (let q = pderiv p\n                       in if p = 0 then 0\n                          else if poly p a \\<noteq> 0 \\<or>\n                                  poly q a \\<noteq> 0\n                               then let ps = sturm p\n                                    in sign_changes_neg_inf ps -\n sign_changes ps a\n                               else let ps = sturm_squarefree p\n                                    in sign_changes_neg_inf ps -\n sign_changes ps a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. count_roots_below p a =\n    (let q = pderiv p\n     in if p = 0 then 0\n        else if poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0\n             then let ps = sturm p\n                  in sign_changes_neg_inf ps - sign_changes ps a\n             else let ps = sturm_squarefree p\n                  in sign_changes_neg_inf ps - sign_changes ps a)", "using False1"], ["proof (prove)\nusing this:\n  \\<not> (poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. count_roots_below p a =\n    (let q = pderiv p\n     in if p = 0 then 0\n        else if poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0\n             then let ps = sturm p\n                  in sign_changes_neg_inf ps - sign_changes ps a\n             else let ps = sturm_squarefree p\n                  in sign_changes_neg_inf ps - sign_changes ps a)", "by (auto simp add: Let_def count_roots_below_def)"], ["proof (state)\nthis:\n  count_roots_below p a =\n  (let q = pderiv p\n   in if p = 0 then 0\n      else if poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0\n           then let ps = sturm p\n                in sign_changes_neg_inf ps - sign_changes ps a\n           else let ps = sturm_squarefree p\n                in sign_changes_neg_inf ps - sign_changes ps a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0;\n     poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> count_roots_below p a =\n                      (let q = pderiv p\n                       in if p = 0 then 0\n                          else if poly p a \\<noteq> 0 \\<or>\n                                  poly q a \\<noteq> 0\n                               then let ps = sturm p\n                                    in sign_changes_neg_inf ps -\n sign_changes ps a\n                               else let ps = sturm_squarefree p\n                                    in sign_changes_neg_inf ps -\n sign_changes ps a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0;\n     poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> count_roots_below p a =\n                      (let q = pderiv p\n                       in if p = 0 then 0\n                          else if poly p a \\<noteq> 0 \\<or>\n                                  poly q a \\<noteq> 0\n                               then let ps = sturm p\n                                    in sign_changes_neg_inf ps -\n sign_changes ps a\n                               else let ps = sturm_squarefree p\n                                    in sign_changes_neg_inf ps -\n sign_changes ps a)", "case True"], ["proof (state)\nthis:\n  poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0;\n     poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> count_roots_below p a =\n                      (let q = pderiv p\n                       in if p = 0 then 0\n                          else if poly p a \\<noteq> 0 \\<or>\n                                  poly q a \\<noteq> 0\n                               then let ps = sturm p\n                                    in sign_changes_neg_inf ps -\n sign_changes ps a\n                               else let ps = sturm_squarefree p\n                                    in sign_changes_neg_inf ps -\n sign_changes ps a)", "hence A: \"poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\""], ["proof (prove)\nusing this:\n  poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0;\n     poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> count_roots_below p a =\n                      (let q = pderiv p\n                       in if p = 0 then 0\n                          else if poly p a \\<noteq> 0 \\<or>\n                                  poly q a \\<noteq> 0\n                               then let ps = sturm p\n                                    in sign_changes_neg_inf ps -\n sign_changes ps a\n                               else let ps = sturm_squarefree p\n                                    in sign_changes_neg_inf ps -\n sign_changes ps a)", "define d where \"d = gcd p (pderiv p)\""], ["proof (state)\nthis:\n  d = gcd p (pderiv p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0;\n     poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> count_roots_below p a =\n                      (let q = pderiv p\n                       in if p = 0 then 0\n                          else if poly p a \\<noteq> 0 \\<or>\n                                  poly q a \\<noteq> 0\n                               then let ps = sturm p\n                                    in sign_changes_neg_inf ps -\n sign_changes ps a\n                               else let ps = sturm_squarefree p\n                                    in sign_changes_neg_inf ps -\n sign_changes ps a)", "from \\<open>p \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "have [simp]: \"p div d \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p div d \\<noteq> 0", "using poly_div_gcd_squarefree(1)[OF \\<open>p \\<noteq> 0\\<close>]"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  coprime (p div gcd p (pderiv p)) (pderiv (p div gcd p (pderiv p)))\n\ngoal (1 subgoal):\n 1. p div d \\<noteq> 0", "by (auto simp add: d_def)"], ["proof (state)\nthis:\n  p div d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0;\n     poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> count_roots_below p a =\n                      (let q = pderiv p\n                       in if p = 0 then 0\n                          else if poly p a \\<noteq> 0 \\<or>\n                                  poly q a \\<noteq> 0\n                               then let ps = sturm p\n                                    in sign_changes_neg_inf ps -\n sign_changes ps a\n                               else let ps = sturm_squarefree p\n                                    in sign_changes_neg_inf ps -\n sign_changes ps a)", "from sturm_seq_sturm_squarefree'[OF \\<open>p \\<noteq> 0\\<close>]"], ["proof (chain)\npicking this:\n  sturm_seq (sturm_squarefree' p) (p div gcd p (pderiv p))", "interpret sturm_seq \"sturm_squarefree' p\" \"p div d\""], ["proof (prove)\nusing this:\n  sturm_seq (sturm_squarefree' p) (p div gcd p (pderiv p))\n\ngoal (1 subgoal):\n 1. sturm_seq (sturm_squarefree' p) (p div d)", "unfolding sturm_squarefree'_def Let_def d_def"], ["proof (prove)\nusing this:\n  sturm_seq (map (\\<lambda>p'. p' div gcd p (pderiv p)) (sturm p))\n   (p div gcd p (pderiv p))\n\ngoal (1 subgoal):\n 1. sturm_seq (map (\\<lambda>p'. p' div gcd p (pderiv p)) (sturm p))\n     (p div gcd p (pderiv p))", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0;\n     poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> count_roots_below p a =\n                      (let q = pderiv p\n                       in if p = 0 then 0\n                          else if poly p a \\<noteq> 0 \\<or>\n                                  poly q a \\<noteq> 0\n                               then let ps = sturm p\n                                    in sign_changes_neg_inf ps -\n sign_changes ps a\n                               else let ps = sturm_squarefree p\n                                    in sign_changes_neg_inf ps -\n sign_changes ps a)", "note count_roots_below_correct"], ["proof (state)\nthis:\n  count_roots_below ?p ?a = card {x. x \\<le> ?a \\<and> poly ?p x = 0}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0;\n     poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> count_roots_below p a =\n                      (let q = pderiv p\n                       in if p = 0 then 0\n                          else if poly p a \\<noteq> 0 \\<or>\n                                  poly q a \\<noteq> 0\n                               then let ps = sturm p\n                                    in sign_changes_neg_inf ps -\n sign_changes ps a\n                               else let ps = sturm_squarefree p\n                                    in sign_changes_neg_inf ps -\n sign_changes ps a)", "also"], ["proof (state)\nthis:\n  count_roots_below ?p ?a = card {x. x \\<le> ?a \\<and> poly ?p x = 0}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0;\n     poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> count_roots_below p a =\n                      (let q = pderiv p\n                       in if p = 0 then 0\n                          else if poly p a \\<noteq> 0 \\<or>\n                                  poly q a \\<noteq> 0\n                               then let ps = sturm p\n                                    in sign_changes_neg_inf ps -\n sign_changes ps a\n                               else let ps = sturm_squarefree p\n                                    in sign_changes_neg_inf ps -\n sign_changes ps a)", "have \"{x. x \\<le> a \\<and> poly p x = 0} =\n                 {x. x \\<le> a \\<and> poly (p div d) x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. x \\<le> a \\<and> poly p x = 0} =\n    {x. x \\<le> a \\<and> poly (p div d) x = 0}", "unfolding d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. x \\<le> a \\<and> poly p x = 0} =\n    {x. x \\<le> a \\<and> poly (p div gcd p (pderiv p)) x = 0}", "using poly_div_gcd_squarefree(2)[OF \\<open>p \\<noteq> 0\\<close>]"], ["proof (prove)\nusing this:\n  (poly (p div gcd p (pderiv p)) ?x = 0) = (poly p ?x = 0)\n\ngoal (1 subgoal):\n 1. {x. x \\<le> a \\<and> poly p x = 0} =\n    {x. x \\<le> a \\<and> poly (p div gcd p (pderiv p)) x = 0}", "by simp"], ["proof (state)\nthis:\n  {x. x \\<le> a \\<and> poly p x = 0} =\n  {x. x \\<le> a \\<and> poly (p div d) x = 0}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0;\n     poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> count_roots_below p a =\n                      (let q = pderiv p\n                       in if p = 0 then 0\n                          else if poly p a \\<noteq> 0 \\<or>\n                                  poly q a \\<noteq> 0\n                               then let ps = sturm p\n                                    in sign_changes_neg_inf ps -\n sign_changes ps a\n                               else let ps = sturm_squarefree p\n                                    in sign_changes_neg_inf ps -\n sign_changes ps a)", "also"], ["proof (state)\nthis:\n  {x. x \\<le> a \\<and> poly p x = 0} =\n  {x. x \\<le> a \\<and> poly (p div d) x = 0}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0;\n     poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> count_roots_below p a =\n                      (let q = pderiv p\n                       in if p = 0 then 0\n                          else if poly p a \\<noteq> 0 \\<or>\n                                  poly q a \\<noteq> 0\n                               then let ps = sturm p\n                                    in sign_changes_neg_inf ps -\n sign_changes ps a\n                               else let ps = sturm_squarefree p\n                                    in sign_changes_neg_inf ps -\n sign_changes ps a)", "note count_roots_below[OF \\<open>p div d \\<noteq> 0\\<close>, symmetric]"], ["proof (state)\nthis:\n  card {x. x \\<le> ?a \\<and> poly (p div d) x = 0} =\n  sign_changes_neg_inf (sturm_squarefree' p) -\n  sign_changes (sturm_squarefree' p) ?a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0;\n     poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> count_roots_below p a =\n                      (let q = pderiv p\n                       in if p = 0 then 0\n                          else if poly p a \\<noteq> 0 \\<or>\n                                  poly q a \\<noteq> 0\n                               then let ps = sturm p\n                                    in sign_changes_neg_inf ps -\n sign_changes ps a\n                               else let ps = sturm_squarefree p\n                                    in sign_changes_neg_inf ps -\n sign_changes ps a)", "also"], ["proof (state)\nthis:\n  card {x. x \\<le> ?a \\<and> poly (p div d) x = 0} =\n  sign_changes_neg_inf (sturm_squarefree' p) -\n  sign_changes (sturm_squarefree' p) ?a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0;\n     poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> count_roots_below p a =\n                      (let q = pderiv p\n                       in if p = 0 then 0\n                          else if poly p a \\<noteq> 0 \\<or>\n                                  poly q a \\<noteq> 0\n                               then let ps = sturm p\n                                    in sign_changes_neg_inf ps -\n sign_changes ps a\n                               else let ps = sturm_squarefree p\n                                    in sign_changes_neg_inf ps -\n sign_changes ps a)", "note sturm_sturm_squarefree'_same_sign_changes(1)[OF A]"], ["proof (state)\nthis:\n  sign_changes (sturm_squarefree' p) a = sign_changes (sturm p) a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0;\n     poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> count_roots_below p a =\n                      (let q = pderiv p\n                       in if p = 0 then 0\n                          else if poly p a \\<noteq> 0 \\<or>\n                                  poly q a \\<noteq> 0\n                               then let ps = sturm p\n                                    in sign_changes_neg_inf ps -\n sign_changes ps a\n                               else let ps = sturm_squarefree p\n                                    in sign_changes_neg_inf ps -\n sign_changes ps a)", "also"], ["proof (state)\nthis:\n  sign_changes (sturm_squarefree' p) a = sign_changes (sturm p) a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0;\n     poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> count_roots_below p a =\n                      (let q = pderiv p\n                       in if p = 0 then 0\n                          else if poly p a \\<noteq> 0 \\<or>\n                                  poly q a \\<noteq> 0\n                               then let ps = sturm p\n                                    in sign_changes_neg_inf ps -\n sign_changes ps a\n                               else let ps = sturm_squarefree p\n                                    in sign_changes_neg_inf ps -\n sign_changes ps a)", "note sturm_sturm_squarefree'_same_sign_changes(3)[OF \\<open>p \\<noteq> 0\\<close>]"], ["proof (state)\nthis:\n  sign_changes_neg_inf (sturm_squarefree' p) =\n  sign_changes_neg_inf (sturm p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0;\n     poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> count_roots_below p a =\n                      (let q = pderiv p\n                       in if p = 0 then 0\n                          else if poly p a \\<noteq> 0 \\<or>\n                                  poly q a \\<noteq> 0\n                               then let ps = sturm p\n                                    in sign_changes_neg_inf ps -\n sign_changes ps a\n                               else let ps = sturm_squarefree p\n                                    in sign_changes_neg_inf ps -\n sign_changes ps a)", "finally"], ["proof (chain)\npicking this:\n  count_roots_below p a =\n  sign_changes_neg_inf (sturm p) - sign_changes (sturm p) a", "show ?thesis"], ["proof (prove)\nusing this:\n  count_roots_below p a =\n  sign_changes_neg_inf (sturm p) - sign_changes (sturm p) a\n\ngoal (1 subgoal):\n 1. count_roots_below p a =\n    (let q = pderiv p\n     in if p = 0 then 0\n        else if poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0\n             then let ps = sturm p\n                  in sign_changes_neg_inf ps - sign_changes ps a\n             else let ps = sturm_squarefree p\n                  in sign_changes_neg_inf ps - sign_changes ps a)", "using True False"], ["proof (prove)\nusing this:\n  count_roots_below p a =\n  sign_changes_neg_inf (sturm p) - sign_changes (sturm p) a\n  poly p a \\<noteq> 0 \\<or> poly (pderiv p) a \\<noteq> 0\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. count_roots_below p a =\n    (let q = pderiv p\n     in if p = 0 then 0\n        else if poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0\n             then let ps = sturm p\n                  in sign_changes_neg_inf ps - sign_changes ps a\n             else let ps = sturm_squarefree p\n                  in sign_changes_neg_inf ps - sign_changes ps a)", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  count_roots_below p a =\n  (let q = pderiv p\n   in if p = 0 then 0\n      else if poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0\n           then let ps = sturm p\n                in sign_changes_neg_inf ps - sign_changes ps a\n           else let ps = sturm_squarefree p\n                in sign_changes_neg_inf ps - sign_changes ps a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  count_roots_below p a =\n  (let q = pderiv p\n   in if p = 0 then 0\n      else if poly p a \\<noteq> 0 \\<or> poly q a \\<noteq> 0\n           then let ps = sturm p\n                in sign_changes_neg_inf ps - sign_changes ps a\n           else let ps = sturm_squarefree p\n                in sign_changes_neg_inf ps - sign_changes ps a)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}