{"file_name": "/home/qj213/afp-2021-10-22/thys/Closest_Pair_Points/Common.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Closest_Pair_Points", "problem_names": ["lemma time_distrib_bind:\n  \"time (bind_tm tm f) = time tm + time (f (val tm))\"", "lemmas time_simps = time_distrib_bind tick_def", "lemma bind_tm_cong[fundef_cong]:\n  assumes \"\\<And>v. v = val n \\<Longrightarrow> f v = g v\" \"m = n\"\n  shows \"bind_tm m f = bind_tm n g\"", "lemma bigo_measure_trans:\n  fixes t :: \"'a \\<Rightarrow> real\" and t' :: \"nat \\<Rightarrow> real\" and m :: \"'a \\<Rightarrow> nat\" and f ::\"nat \\<Rightarrow> real\"\n  assumes \"\\<And>x. x \\<in> A \\<Longrightarrow> t x \\<le> (t' o m) x\"\n      and \"t' \\<in> O(f)\"\n      and \"\\<And>x. x \\<in> A \\<Longrightarrow> 0 \\<le> t x\"\n  shows \"t \\<in> O[m going_to at_top within A](f o m)\"", "lemma const_1_bigo_n_ln_n:\n  \"(\\<lambda>(n::nat). 1) \\<in> O(\\<lambda>n. n * ln n)\"", "lemma set_take_drop_i_le_j:\n  \"i \\<le> j \\<Longrightarrow> set xs = set (take j xs) \\<union> set (drop i xs)\"", "lemma set_take_drop:\n  \"set xs = set (take n xs) \\<union> set (drop n xs)\"", "lemma sorted_wrt_take_drop:\n  \"sorted_wrt f xs \\<Longrightarrow> \\<forall>x \\<in> set (take n xs). \\<forall>y \\<in> set (drop n xs). f x y\"", "lemma sorted_wrt_hd_less:\n  assumes \"sorted_wrt f xs\" \"\\<And>x. f x x\"\n  shows \"\\<forall>x \\<in> set xs. f (hd xs) x\"", "lemma sorted_wrt_hd_less_take:\n  assumes \"sorted_wrt f (x # xs)\" \"\\<And>x. f x x\"\n  shows \"\\<forall>y \\<in> set (take n (x # xs)). f x y\"", "lemma sorted_wrt_take_less_hd_drop:\n  assumes \"sorted_wrt f xs\" \"n < length xs\"\n  shows \"\\<forall>x \\<in> set (take n xs). f x (hd (drop n xs))\"", "lemma sorted_wrt_hd_drop_less_drop:\n  assumes \"sorted_wrt f xs\" \"\\<And>x. f x x\"\n  shows \"\\<forall>x \\<in> set (drop n xs). f (hd (drop n xs)) x\"", "lemma length_filter_P_impl_Q:\n   \"(\\<And>x. P x \\<Longrightarrow> Q x) \\<Longrightarrow> length (filter P xs) \\<le> length (filter Q xs)\"", "lemma filter_Un:\n  \"set xs = A \\<union> B \\<Longrightarrow> set (filter P xs) = { x \\<in> A. P x } \\<union> { x \\<in> B. P x }\"", "lemma length_eq_val_length_tm:\n  \"val (length_tm xs) = length xs\"", "lemma time_length_tm:\n  \"time (length_tm xs) = length xs + 1\"", "lemma length_conv_length_it':\n  \"length xs + acc = length_it' acc xs\"", "lemma length_conv_length_it[code_unfold]:\n  \"length xs = length_it xs\"", "lemma rev_conv_rev_it':\n  \"rev xs @ acc = rev_it' acc xs\"", "lemma rev_conv_rev_it[code_unfold]:\n  \"rev xs = rev_it xs\"", "lemma take_eq_val_take_tm:\n  \"val (take_tm n xs) = take n xs\"", "lemma time_take_tm:\n  \"time (take_tm n xs) = min n (length xs) + 1\"", "lemma filter_eq_val_filter_tm:\n  \"val (filter_tm P xs) = filter P xs\"", "lemma time_filter_tm:\n  \"time (filter_tm P xs) = length xs + 1\"", "lemma filter_conv_filter_it':\n  \"rev acc @ filter P xs = filter_it' acc P xs\"", "lemma filter_conv_filter_it[code_unfold]:\n  \"filter P xs = filter_it P xs\"", "lemma split_at_eq_val_split_at_tm:\n  \"val (split_at_tm n xs) = split_at n xs\"", "lemma split_at_take_drop_conv:\n  \"split_at n xs = (take n xs, drop n xs)\"", "lemma time_split_at_tm:\n  \"time (split_at_tm n xs) = min n (length xs) + 1\"", "lemma split_at_conv_split_at_it':\n  assumes \"(ts, ds) = split_at n xs\" \"(ts', ds') = split_at_it' acc n xs\"\n  shows \"rev acc @ ts = ts'\"\n    and \"ds = ds'\"", "lemma split_at_conv_split_at_it_prod:\n  assumes \"(ts, ds) = split_at n xs\" \"(ts', ds') = split_at_it n xs\"\n  shows \"(ts, ds) = (ts', ds')\"", "lemma split_at_conv_split_at_it[code_unfold]:\n  \"split_at n xs = split_at_it n xs\"", "lemma merge_eq_val_merge_tm:\n  \"val (merge_tm f xs ys) = merge f xs ys\"", "lemma length_merge:\n  \"length (merge f xs ys) = length xs + length ys\"", "lemma set_merge:\n  \"set (merge f xs ys) = set xs \\<union> set ys\"", "lemma distinct_merge:\n  assumes \"set xs \\<inter> set ys = {}\" \"distinct xs\" \"distinct ys\"\n  shows \"distinct (merge f xs ys)\"", "lemma sorted_merge:\n  assumes \"P = (\\<lambda>x y. f x \\<le> f y)\"\n  shows \"sorted_wrt P (merge f xs ys) \\<longleftrightarrow> sorted_wrt P xs \\<and> sorted_wrt P ys\"", "lemma mergesort_eq_val_mergesort_tm:\n  \"val (mergesort_tm f xs) = mergesort f xs\"", "lemma sorted_wrt_mergesort:\n  \"sorted_wrt (\\<lambda>x y. f x \\<le> f y) (mergesort f xs)\"", "lemma set_mergesort:\n  \"set (mergesort f xs) = set xs\"", "lemma length_mergesort:\n  \"length (mergesort f xs) = length xs\"", "lemma distinct_mergesort:\n  \"distinct xs \\<Longrightarrow> distinct (mergesort f xs)\"", "lemmas mergesort = sorted_wrt_mergesort set_mergesort length_mergesort distinct_mergesort", "lemma sorted_fst_take_less_hd_drop:\n  assumes \"sorted_fst ps\" \"n < length ps\"\n  shows \"\\<forall>p \\<in> set (take n ps). fst p \\<le> fst (hd (drop n ps))\"", "lemma sorted_fst_hd_drop_less_drop:\n  assumes \"sorted_fst ps\"\n  shows \"\\<forall>p \\<in> set (drop n ps). fst (hd (drop n ps)) \\<le> fst p\"", "lemma time_merge_tm:\n  \"time (merge_tm f xs ys) \\<le> length xs + length ys + 1\"", "lemma mergesort_recurrence_nonneg[simp]:\n  \"0 \\<le> mergesort_recurrence n\"", "lemma time_mergesort_conv_mergesort_recurrence:\n  \"time (mergesort_tm f xs) \\<le> mergesort_recurrence (length xs)\"", "theorem mergesort_recurrence:\n  \"mergesort_recurrence \\<in> \\<Theta>(\\<lambda>n. n * ln n)\"", "theorem time_mergesort_tm_bigo:\n  \"(\\<lambda>xs. time (mergesort_tm f xs)) \\<in> O[length going_to at_top]((\\<lambda>n. n * ln n) o length)\"", "lemma merge_xs_Nil[simp]:\n  \"merge f xs [] = xs\"", "lemma merge_conv_merge_it':\n  \"rev acc @ merge f xs ys = merge_it' f acc xs ys\"", "lemma merge_conv_merge_it[code_unfold]:\n  \"merge f xs ys = merge_it f xs ys\"", "lemma sparse_identity:\n  assumes \"sparse \\<delta> (set ps)\" \"\\<forall>p \\<in> set ps. \\<delta> \\<le> dist p\\<^sub>0 p\"\n  shows \"sparse \\<delta> (set (p\\<^sub>0 # ps))\"", "lemma sparse_update:\n  assumes \"sparse \\<delta> (set ps)\"\n  assumes \"dist p\\<^sub>0 p\\<^sub>1 \\<le> \\<delta>\" \"\\<forall>p \\<in> set ps. dist p\\<^sub>0 p\\<^sub>1 \\<le> dist p\\<^sub>0 p\"\n  shows \"sparse (dist p\\<^sub>0 p\\<^sub>1) (set (p\\<^sub>0 # ps))\"", "lemma sparse_mono:\n  \"sparse \\<Delta> P \\<Longrightarrow> \\<delta> \\<le> \\<Delta> \\<Longrightarrow> sparse \\<delta> P\"", "lemma dist_transform:\n  fixes p :: point and \\<delta> :: real and l :: int\n  shows \"dist p (l, snd p) < \\<delta> \\<longleftrightarrow> l - \\<delta> < fst p \\<and> fst p < l + \\<delta>\"", "lemma dist_eq_sqrt_dist_code:\n  fixes p\\<^sub>0 :: point\n  shows \"dist p\\<^sub>0 p\\<^sub>1 = sqrt (dist_code p\\<^sub>0 p\\<^sub>1)\"", "lemma dist_eq_dist_code_lt:\n  fixes p\\<^sub>0 :: point\n  shows \"dist p\\<^sub>0 p\\<^sub>1 < dist p\\<^sub>2 p\\<^sub>3 \\<longleftrightarrow> dist_code p\\<^sub>0 p\\<^sub>1 < dist_code p\\<^sub>2 p\\<^sub>3\"", "lemma dist_eq_dist_code_le:\n  fixes p\\<^sub>0 :: point\n  shows \"dist p\\<^sub>0 p\\<^sub>1 \\<le> dist p\\<^sub>2 p\\<^sub>3 \\<longleftrightarrow> dist_code p\\<^sub>0 p\\<^sub>1 \\<le> dist_code p\\<^sub>2 p\\<^sub>3\"", "lemma dist_eq_dist_code_abs_lt:\n  fixes p\\<^sub>0 :: point\n  shows \"\\<bar>c\\<bar> < dist p\\<^sub>0 p\\<^sub>1 \\<longleftrightarrow> c\\<^sup>2 < dist_code p\\<^sub>0 p\\<^sub>1\"", "lemma dist_eq_dist_code_abs_le:\n  fixes p\\<^sub>0 :: point\n  shows \"dist p\\<^sub>0 p\\<^sub>1 \\<le> \\<bar>c\\<bar> \\<longleftrightarrow> dist_code p\\<^sub>0 p\\<^sub>1 \\<le> c\\<^sup>2\"", "lemma dist_fst_abs:\n  fixes p :: point and l :: int\n  shows \"dist p (l, snd p) = \\<bar>fst p - l\\<bar>\"", "lemma find_closest_bf_eq_val_find_closest_bf_tm:\n  \"val (find_closest_bf_tm p ps) = find_closest_bf p ps\"", "lemma find_closest_bf_set:\n  \"0 < length ps \\<Longrightarrow> find_closest_bf p ps \\<in> set ps\"", "lemma find_closest_bf_dist:\n  \"\\<forall>q \\<in> set ps. dist p (find_closest_bf p ps) \\<le> dist p q\"", "lemma closest_pair_bf_eq_val_closest_pair_bf_tm:\n  \"val (closest_pair_bf_tm ps) = closest_pair_bf ps\"", "lemma closest_pair_bf_c0:\n  \"1 < length ps \\<Longrightarrow> (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf ps \\<Longrightarrow> c\\<^sub>0 \\<in> set ps\"", "lemma closest_pair_bf_c1:\n  \"1 < length ps \\<Longrightarrow> (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf ps \\<Longrightarrow> c\\<^sub>1 \\<in> set ps\"", "lemma closest_pair_bf_c0_ne_c1:\n  \"1 < length ps \\<Longrightarrow> distinct ps \\<Longrightarrow> (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf ps \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1\"", "lemmas closest_pair_bf_c0_c1 = closest_pair_bf_c0 closest_pair_bf_c1 closest_pair_bf_c0_ne_c1", "lemma closest_pair_bf_dist:\n  assumes \"1 < length ps\" \"(c\\<^sub>0, c\\<^sub>1) = closest_pair_bf ps\"\n  shows \"sparse (dist c\\<^sub>0 c\\<^sub>1) (set ps)\"", "lemma time_find_closest_bf_tm:\n  \"time (find_closest_bf_tm p ps) \\<le> length ps + 1\"", "lemma time_closest_pair_bf_tm:\n  \"time (closest_pair_bf_tm ps) \\<le> length ps * length ps + 1\"", "lemma find_closest_bf_code_dist_eq:\n  \"0 < length ps \\<Longrightarrow> (\\<delta>, c) = find_closest_bf_code p ps \\<Longrightarrow> \\<delta> = dist_code p c\"", "lemma find_closest_bf_code_eq:\n  \"0 < length ps \\<Longrightarrow> c = find_closest_bf p ps \\<Longrightarrow> (\\<delta>', c') = find_closest_bf_code p ps \\<Longrightarrow> c = c'\"", "lemma closest_pair_bf_code_dist_eq:\n  \"1 < length ps \\<Longrightarrow> (\\<delta>, c\\<^sub>0, c\\<^sub>1) = closest_pair_bf_code ps \\<Longrightarrow> \\<delta> = dist_code c\\<^sub>0 c\\<^sub>1\"", "lemma closest_pair_bf_code_eq:\n  assumes \"1 < length ps\" \n  assumes \"(c\\<^sub>0, c\\<^sub>1) = closest_pair_bf ps\" \"(\\<delta>', c\\<^sub>0', c\\<^sub>1') = closest_pair_bf_code ps\"\n  shows \"c\\<^sub>0 = c\\<^sub>0' \\<and> c\\<^sub>1 = c\\<^sub>1'\"", "lemma set_band_filter_aux:\n  fixes \\<delta> :: real and ps :: \"point list\"\n  assumes \"p\\<^sub>0 \\<in> ps\\<^sub>L\" \"p\\<^sub>1 \\<in> ps\\<^sub>R\" \"p\\<^sub>0 \\<noteq> p\\<^sub>1\" \"dist p\\<^sub>0 p\\<^sub>1 < \\<delta>\" \"set ps = ps\\<^sub>L \\<union> ps\\<^sub>R\"\n  assumes \"\\<forall>p \\<in> ps\\<^sub>L. fst p \\<le> l\" \"\\<forall>p \\<in> ps\\<^sub>R. l \\<le> fst p\"\n  assumes \"ps' = filter (\\<lambda>p. l - \\<delta> < fst p \\<and> fst p < l + \\<delta>) ps\"\n  shows \"p\\<^sub>0 \\<in> set ps' \\<and> p\\<^sub>1 \\<in> set ps'\"", "lemma set_band_filter:\n  fixes \\<delta> :: real and ps :: \"point list\"\n  assumes \"p\\<^sub>0 \\<in> set ps\" \"p\\<^sub>1 \\<in> set ps\" \"p\\<^sub>0 \\<noteq> p\\<^sub>1\" \"dist p\\<^sub>0 p\\<^sub>1 < \\<delta>\" \"set ps = ps\\<^sub>L \\<union> ps\\<^sub>R\"\n  assumes \"sparse \\<delta> ps\\<^sub>L\" \"sparse \\<delta> ps\\<^sub>R\"\n  assumes \"\\<forall>p \\<in> ps\\<^sub>L. fst p \\<le> l\" \"\\<forall>p \\<in> ps\\<^sub>R. l \\<le> fst p\"\n  assumes \"ps' = filter (\\<lambda>p. l - \\<delta> < fst p \\<and> fst p < l + \\<delta>) ps\"\n  shows \"p\\<^sub>0 \\<in> set ps' \\<and> p\\<^sub>1 \\<in> set ps'\"", "lemma cbox_2D: \n  fixes x\\<^sub>0 :: real and y\\<^sub>0 :: real\n  shows \"cbox (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>1, y\\<^sub>1) = { (x, y). x\\<^sub>0 \\<le> x \\<and> x \\<le> x\\<^sub>1 \\<and> y\\<^sub>0 \\<le> y \\<and> y \\<le> y\\<^sub>1 }\"", "lemma mem_cbox_2D:\n  fixes x :: real and y :: real\n  shows \"x\\<^sub>0 \\<le> x \\<and> x \\<le> x\\<^sub>1 \\<and> y\\<^sub>0 \\<le> y \\<and> y \\<le> y\\<^sub>1 \\<longleftrightarrow> (x, y) \\<in> cbox (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>1, y\\<^sub>1)\"", "lemma cbox_top_un:\n  fixes x\\<^sub>0 :: real and y\\<^sub>0 :: real\n  assumes \"y\\<^sub>0 \\<le> y\\<^sub>1\" \"y\\<^sub>1 \\<le> y\\<^sub>2\"\n  shows \"cbox (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>1, y\\<^sub>1) \\<union> cbox (x\\<^sub>0, y\\<^sub>1) (x\\<^sub>1, y\\<^sub>2) = cbox (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>1, y\\<^sub>2)\"", "lemma cbox_right_un:\n  fixes x\\<^sub>0 :: real and y\\<^sub>0 :: real\n  assumes \"x\\<^sub>0 \\<le> x\\<^sub>1\" \"x\\<^sub>1 \\<le> x\\<^sub>2\"\n  shows \"cbox (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>1, y\\<^sub>1) \\<union> cbox (x\\<^sub>1, y\\<^sub>0) (x\\<^sub>2, y\\<^sub>1) = cbox (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>2, y\\<^sub>1)\"", "lemma cbox_max_dist:\n  assumes \"p\\<^sub>0 = (x, y)\" \"p\\<^sub>1 = (x + \\<delta>, y + \\<delta>)\"\n  assumes \"(x\\<^sub>0, y\\<^sub>0) \\<in> cbox p\\<^sub>0 p\\<^sub>1\" \"(x\\<^sub>1, y\\<^sub>1) \\<in> cbox p\\<^sub>0 p\\<^sub>1\" \"0 \\<le> \\<delta>\"\n  shows \"dist (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>1, y\\<^sub>1) \\<le> sqrt 2 * \\<delta>\"", "lemma card_le_1_if_pairwise_eq:\n  assumes \"\\<forall>x \\<in> S. \\<forall>y \\<in> S. x = y\"\n  shows \"card S \\<le> 1\"", "lemma card_Int_if_either_in:\n  assumes \"\\<forall>x \\<in> S. \\<forall>y \\<in> S. x = y \\<or> x \\<notin> T \\<or> y \\<notin> T\" \n  shows \"card (S \\<inter> T) \\<le> 1\"", "lemma card_Int_Un_le_Sum_card_Int:\n  assumes \"finite S\"\n  shows \"card (A \\<inter> \\<Union>S) \\<le> (\\<Sum>B \\<in> S. card (A \\<inter> B))\"", "lemma pigeonhole:\n  assumes \"finite T\" \"S \\<subseteq> \\<Union>T\" \"card T < card S\"\n  shows \"\\<exists>x \\<in> S. \\<exists>y \\<in> S. \\<exists>X \\<in> T. x \\<noteq> y \\<and> x \\<in> X \\<and> y \\<in> X\"", "lemma max_points_square:\n  assumes \"\\<forall>p \\<in> ps. p \\<in> cbox (x, y) (x + \\<delta>, y + \\<delta>)\" \"sparse \\<delta> ps\" \"0 \\<le> \\<delta>\"\n  shows \"card ps \\<le> 4\""], "translations": [["", "lemma time_distrib_bind:\n  \"time (bind_tm tm f) = time tm + time (f (val tm))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. time (tm \\<bind> f) = time tm + time (f (Time_Monad.val tm))", "unfolding bind_tm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. time\n     (case tm of\n      ??.Time_Monad.tm.TM u m \\<Rightarrow>\n        case f u of\n        ??.Time_Monad.tm.TM v n \\<Rightarrow>\n          ??.Time_Monad.tm.TM v (m + n)) =\n    time tm + time (f (Time_Monad.val tm))", "by (simp split: tm.split)"], ["", "lemmas time_simps = time_distrib_bind tick_def"], ["", "lemma bind_tm_cong[fundef_cong]:\n  assumes \"\\<And>v. v = val n \\<Longrightarrow> f v = g v\" \"m = n\"\n  shows \"bind_tm m f = bind_tm n g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> f = n \\<bind> g", "using assms"], ["proof (prove)\nusing this:\n  ?v = Time_Monad.val n \\<Longrightarrow> f ?v = g ?v\n  m = n\n\ngoal (1 subgoal):\n 1. m \\<bind> f = n \\<bind> g", "unfolding bind_tm_def"], ["proof (prove)\nusing this:\n  ?v = Time_Monad.val n \\<Longrightarrow> f ?v = g ?v\n  m = n\n\ngoal (1 subgoal):\n 1. (case m of\n     ??.Time_Monad.tm.TM u m \\<Rightarrow>\n       case f u of\n       ??.Time_Monad.tm.TM v n \\<Rightarrow>\n         ??.Time_Monad.tm.TM v (m + n)) =\n    (case n of\n     ??.Time_Monad.tm.TM u m \\<Rightarrow>\n       case g u of\n       ??.Time_Monad.tm.TM v n \\<Rightarrow> ??.Time_Monad.tm.TM v (m + n))", "by (auto split: tm.split)"], ["", "subsubsection \"Landau Auxiliary\""], ["", "text \\<open>\n  The following lemma expresses a procedure for deriving complexity properties of\n  the form @{prop\"t \\<in> O[m going_to at_top within A](f o m)\"} where\n    \\<^item> \\<open>t\\<close> is a (timing) function on same data domain (e.g. lists),\n    \\<^item> \\<open>m\\<close> is a measure function on that data domain (e.g. length),\n    \\<^item> \\<open>t'\\<close> is a function on @{typ nat},\n    \\<^item> \\<open>A\\<close> is the set of valid inputs for the data domain.\n  One needs to show that\n    \\<^item> \\<open>t\\<close> is bounded by @{term \"t' o m\"} for valid inputs\n    \\<^item> @{prop\"t' \\<in> O(f)\"}\n  to conclude the overall property @{prop\"t \\<in> O[m going_to at_top within A](f o m)\"}.\n\\<close>"], ["", "lemma bigo_measure_trans:\n  fixes t :: \"'a \\<Rightarrow> real\" and t' :: \"nat \\<Rightarrow> real\" and m :: \"'a \\<Rightarrow> nat\" and f ::\"nat \\<Rightarrow> real\"\n  assumes \"\\<And>x. x \\<in> A \\<Longrightarrow> t x \\<le> (t' o m) x\"\n      and \"t' \\<in> O(f)\"\n      and \"\\<And>x. x \\<in> A \\<Longrightarrow> 0 \\<le> t x\"\n  shows \"t \\<in> O[m going_to at_top within A](f o m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> O[m going_to sequentially within A](f \\<circ> m)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<in> O[m going_to sequentially within A](f \\<circ> m)", "have 0: \"\\<And>x. x \\<in> A \\<Longrightarrow> 0 \\<le> (t' o m) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A \\<Longrightarrow> 0 \\<le> (t' \\<circ> m) x", "by (meson assms(1,3) order_trans)"], ["proof (state)\nthis:\n  ?x \\<in> A \\<Longrightarrow> 0 \\<le> (t' \\<circ> m) ?x\n\ngoal (1 subgoal):\n 1. t \\<in> O[m going_to sequentially within A](f \\<circ> m)", "have 1: \"t \\<in> O[m going_to at_top within A](t' o m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> O[m going_to sequentially within A](t' \\<circ> m)", "apply(rule bigoI[where c=1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in m going_to sequentially within A.\n       norm (t x) \\<le> 1 * norm ((t' \\<circ> m) x)", "using assms 0"], ["proof (prove)\nusing this:\n  ?x \\<in> A \\<Longrightarrow> t ?x \\<le> (t' \\<circ> m) ?x\n  t' \\<in> O(f)\n  ?x \\<in> A \\<Longrightarrow> 0 \\<le> t ?x\n  ?x \\<in> A \\<Longrightarrow> 0 \\<le> (t' \\<circ> m) ?x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in m going_to sequentially within A.\n       norm (t x) \\<le> 1 * norm ((t' \\<circ> m) x)", "by (simp add: eventually_inf_principal going_to_within_def)"], ["proof (state)\nthis:\n  t \\<in> O[m going_to sequentially within A](t' \\<circ> m)\n\ngoal (1 subgoal):\n 1. t \\<in> O[m going_to sequentially within A](f \\<circ> m)", "have 2: \"t' o m \\<in> O[m going_to at_top](f o m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t' \\<circ> m \\<in> O[m going_to sequentially](f \\<circ> m)", "unfolding o_def going_to_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. t' (m x))\n    \\<in> O[filtercomap m sequentially](\\<lambda>x. f (m x))", "by(rule landau_o.big.filtercomap[OF assms(2)])"], ["proof (state)\nthis:\n  t' \\<circ> m \\<in> O[m going_to sequentially](f \\<circ> m)\n\ngoal (1 subgoal):\n 1. t \\<in> O[m going_to sequentially within A](f \\<circ> m)", "have 3: \"t' o m \\<in> O[m going_to at_top within A](f o m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t' \\<circ> m \\<in> O[m going_to sequentially within A](f \\<circ> m)", "using landau_o.big.filter_mono[OF _2] going_to_mono[OF _subset_UNIV]"], ["proof (prove)\nusing this:\n  ?F1.0 \\<le> m going_to sequentially \\<Longrightarrow>\n  t' \\<circ> m \\<in> O[?F1.0](f \\<circ> m)\n  ?F \\<le> ?G \\<Longrightarrow>\n  ?f going_to ?F within ?A \\<le> ?f going_to ?G\n\ngoal (1 subgoal):\n 1. t' \\<circ> m \\<in> O[m going_to sequentially within A](f \\<circ> m)", "by blast"], ["proof (state)\nthis:\n  t' \\<circ> m \\<in> O[m going_to sequentially within A](f \\<circ> m)\n\ngoal (1 subgoal):\n 1. t \\<in> O[m going_to sequentially within A](f \\<circ> m)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> O[m going_to sequentially within A](f \\<circ> m)", "by(rule landau_o.big_trans[OF 1 3])"], ["proof (state)\nthis:\n  t \\<in> O[m going_to sequentially within A](f \\<circ> m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma const_1_bigo_n_ln_n:\n  \"(\\<lambda>(n::nat). 1) \\<in> O(\\<lambda>n. n * ln n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. 1) \\<in> O(\\<lambda>n. real n * ln (real n))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>n. 1) \\<in> O(\\<lambda>n. real n * ln (real n))", "have \"\\<exists>N. \\<forall>(n::nat) \\<ge> N. (\\<lambda>x. 1 \\<le> x * ln x) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>N. \\<forall>n\\<ge>N. 1 \\<le> real n * ln (real n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>N. \\<forall>n\\<ge>N. 1 \\<le> real n * ln (real n)", "have \"\\<forall>(n::nat) \\<ge> 3. (\\<lambda>x. 1 \\<le> x * ln x) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n\\<ge>3. 1 \\<le> real n * ln (real n)", "proof standard"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. 3 \\<le> n \\<longrightarrow> 1 \\<le> real n * ln (real n)", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. 3 \\<le> n \\<longrightarrow> 1 \\<le> real n * ln (real n)", "show \"3 \\<le> n \\<longrightarrow> 1 \\<le> real n * ln (real n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 3 \\<le> n \\<longrightarrow> 1 \\<le> real n * ln (real n)", "proof standard"], ["proof (state)\ngoal (1 subgoal):\n 1. 3 \\<le> n \\<Longrightarrow> 1 \\<le> real n * ln (real n)", "assume \"3 \\<le> n\""], ["proof (state)\nthis:\n  3 \\<le> n\n\ngoal (1 subgoal):\n 1. 3 \\<le> n \\<Longrightarrow> 1 \\<le> real n * ln (real n)", "hence \"1 \\<le> real n\""], ["proof (prove)\nusing this:\n  3 \\<le> n\n\ngoal (1 subgoal):\n 1. 1 \\<le> real n", "by simp"], ["proof (state)\nthis:\n  1 \\<le> real n\n\ngoal (1 subgoal):\n 1. 3 \\<le> n \\<Longrightarrow> 1 \\<le> real n * ln (real n)", "moreover"], ["proof (state)\nthis:\n  1 \\<le> real n\n\ngoal (1 subgoal):\n 1. 3 \\<le> n \\<Longrightarrow> 1 \\<le> real n * ln (real n)", "have \"1 \\<le> ln (real n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> ln (real n)", "using ln_ln_nonneg' \\<open>3 \\<le> n\\<close>"], ["proof (prove)\nusing this:\n  3 \\<le> ?x \\<Longrightarrow> 0 \\<le> ln (ln (real ?x))\n  3 \\<le> n\n\ngoal (1 subgoal):\n 1. 1 \\<le> ln (real n)", "by simp"], ["proof (state)\nthis:\n  1 \\<le> ln (real n)\n\ngoal (1 subgoal):\n 1. 3 \\<le> n \\<Longrightarrow> 1 \\<le> real n * ln (real n)", "ultimately"], ["proof (chain)\npicking this:\n  1 \\<le> real n\n  1 \\<le> ln (real n)", "show \"1 \\<le> real n * ln (real n)\""], ["proof (prove)\nusing this:\n  1 \\<le> real n\n  1 \\<le> ln (real n)\n\ngoal (1 subgoal):\n 1. 1 \\<le> real n * ln (real n)", "by (auto simp: order_trans)"], ["proof (state)\nthis:\n  1 \\<le> real n * ln (real n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  3 \\<le> n \\<longrightarrow> 1 \\<le> real n * ln (real n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>n\\<ge>3. 1 \\<le> real n * ln (real n)\n\ngoal (1 subgoal):\n 1. \\<exists>N. \\<forall>n\\<ge>N. 1 \\<le> real n * ln (real n)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>n\\<ge>3. 1 \\<le> real n * ln (real n)\n\ngoal (1 subgoal):\n 1. \\<exists>N. \\<forall>n\\<ge>N. 1 \\<le> real n * ln (real n)", "by blast"], ["proof (state)\nthis:\n  \\<exists>N. \\<forall>n\\<ge>N. 1 \\<le> real n * ln (real n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>N. \\<forall>n\\<ge>N. 1 \\<le> real n * ln (real n)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. 1) \\<in> O(\\<lambda>n. real n * ln (real n))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>N. \\<forall>n\\<ge>N. 1 \\<le> real n * ln (real n)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. 1) \\<in> O(\\<lambda>n. real n * ln (real n))", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n. 1) \\<in> O(\\<lambda>n. real n * ln (real n))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"Miscellaneous Lemmas\""], ["", "lemma set_take_drop_i_le_j:\n  \"i \\<le> j \\<Longrightarrow> set xs = set (take j xs) \\<union> set (drop i xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow>\n    set xs = set (take j xs) \\<union> set (drop i xs)", "proof (induction xs arbitrary: i j)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       i \\<le> j \\<Longrightarrow>\n       set [] = set (take j []) \\<union> set (drop i [])\n 2. \\<And>a xs i j.\n       \\<lbrakk>\\<And>i j.\n                   i \\<le> j \\<Longrightarrow>\n                   set xs = set (take j xs) \\<union> set (drop i xs);\n        i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> set (a # xs) =\n                         set (take j (a # xs)) \\<union>\n                         set (drop i (a # xs))", "case (Cons x xs)"], ["proof (state)\nthis:\n  ?i \\<le> ?j \\<Longrightarrow>\n  set xs = set (take ?j xs) \\<union> set (drop ?i xs)\n  i \\<le> j\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       i \\<le> j \\<Longrightarrow>\n       set [] = set (take j []) \\<union> set (drop i [])\n 2. \\<And>a xs i j.\n       \\<lbrakk>\\<And>i j.\n                   i \\<le> j \\<Longrightarrow>\n                   set xs = set (take j xs) \\<union> set (drop i xs);\n        i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> set (a # xs) =\n                         set (take j (a # xs)) \\<union>\n                         set (drop i (a # xs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (x # xs) = set (take j (x # xs)) \\<union> set (drop i (x # xs))", "proof (cases \"i = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    set (x # xs) = set (take j (x # xs)) \\<union> set (drop i (x # xs))\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    set (x # xs) = set (take j (x # xs)) \\<union> set (drop i (x # xs))", "case True"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    set (x # xs) = set (take j (x # xs)) \\<union> set (drop i (x # xs))\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    set (x # xs) = set (take j (x # xs)) \\<union> set (drop i (x # xs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  i = 0\n\ngoal (1 subgoal):\n 1. set (x # xs) = set (take j (x # xs)) \\<union> set (drop i (x # xs))", "using set_take_subset"], ["proof (prove)\nusing this:\n  i = 0\n  set (take ?n ?xs) \\<subseteq> set ?xs\n\ngoal (1 subgoal):\n 1. set (x # xs) = set (take j (x # xs)) \\<union> set (drop i (x # xs))", "by force"], ["proof (state)\nthis:\n  set (x # xs) = set (take j (x # xs)) \\<union> set (drop i (x # xs))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    set (x # xs) = set (take j (x # xs)) \\<union> set (drop i (x # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    set (x # xs) = set (take j (x # xs)) \\<union> set (drop i (x # xs))", "case False"], ["proof (state)\nthis:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    set (x # xs) = set (take j (x # xs)) \\<union> set (drop i (x # xs))", "hence \"set xs = set (take (j - 1) xs) \\<union> set (drop (i - 1) xs)\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. set xs = set (take (j - 1) xs) \\<union> set (drop (i - 1) xs)", "by (simp add: Cons diff_le_mono)"], ["proof (state)\nthis:\n  set xs = set (take (j - 1) xs) \\<union> set (drop (i - 1) xs)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    set (x # xs) = set (take j (x # xs)) \\<union> set (drop i (x # xs))", "moreover"], ["proof (state)\nthis:\n  set xs = set (take (j - 1) xs) \\<union> set (drop (i - 1) xs)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    set (x # xs) = set (take j (x # xs)) \\<union> set (drop i (x # xs))", "have \"set (take j (x # xs)) = insert x (set (take (j - 1) xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (take j (x # xs)) = insert x (set (take (j - 1) xs))", "using False Cons.prems"], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. set (take j (x # xs)) = insert x (set (take (j - 1) xs))", "by (auto simp: take_Cons')"], ["proof (state)\nthis:\n  set (take j (x # xs)) = insert x (set (take (j - 1) xs))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    set (x # xs) = set (take j (x # xs)) \\<union> set (drop i (x # xs))", "moreover"], ["proof (state)\nthis:\n  set (take j (x # xs)) = insert x (set (take (j - 1) xs))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    set (x # xs) = set (take j (x # xs)) \\<union> set (drop i (x # xs))", "have \"set (drop i (x # xs)) = set (drop (i - 1) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (drop i (x # xs)) = set (drop (i - 1) xs)", "using False Cons.prems"], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. set (drop i (x # xs)) = set (drop (i - 1) xs)", "by (auto simp: drop_Cons')"], ["proof (state)\nthis:\n  set (drop i (x # xs)) = set (drop (i - 1) xs)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    set (x # xs) = set (take j (x # xs)) \\<union> set (drop i (x # xs))", "ultimately"], ["proof (chain)\npicking this:\n  set xs = set (take (j - 1) xs) \\<union> set (drop (i - 1) xs)\n  set (take j (x # xs)) = insert x (set (take (j - 1) xs))\n  set (drop i (x # xs)) = set (drop (i - 1) xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  set xs = set (take (j - 1) xs) \\<union> set (drop (i - 1) xs)\n  set (take j (x # xs)) = insert x (set (take (j - 1) xs))\n  set (drop i (x # xs)) = set (drop (i - 1) xs)\n\ngoal (1 subgoal):\n 1. set (x # xs) = set (take j (x # xs)) \\<union> set (drop i (x # xs))", "by auto"], ["proof (state)\nthis:\n  set (x # xs) = set (take j (x # xs)) \\<union> set (drop i (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (x # xs) = set (take j (x # xs)) \\<union> set (drop i (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       i \\<le> j \\<Longrightarrow>\n       set [] = set (take j []) \\<union> set (drop i [])", "qed simp"], ["", "lemma set_take_drop:\n  \"set xs = set (take n xs) \\<union> set (drop n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs = set (take n xs) \\<union> set (drop n xs)", "using set_take_drop_i_le_j"], ["proof (prove)\nusing this:\n  ?i \\<le> ?j \\<Longrightarrow>\n  set ?xs = set (take ?j ?xs) \\<union> set (drop ?i ?xs)\n\ngoal (1 subgoal):\n 1. set xs = set (take n xs) \\<union> set (drop n xs)", "by fast"], ["", "lemma sorted_wrt_take_drop:\n  \"sorted_wrt f xs \\<Longrightarrow> \\<forall>x \\<in> set (take n xs). \\<forall>y \\<in> set (drop n xs). f x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt f xs \\<Longrightarrow>\n    \\<forall>x\\<in>set (take n xs). \\<forall>y\\<in>set (drop n xs). f x y", "using sorted_wrt_append[of f \"take n xs\" \"drop n xs\"]"], ["proof (prove)\nusing this:\n  sorted_wrt f (take n xs @ drop n xs) =\n  (sorted_wrt f (take n xs) \\<and>\n   sorted_wrt f (drop n xs) \\<and>\n   (\\<forall>x\\<in>set (take n xs). \\<forall>y\\<in>set (drop n xs). f x y))\n\ngoal (1 subgoal):\n 1. sorted_wrt f xs \\<Longrightarrow>\n    \\<forall>x\\<in>set (take n xs). \\<forall>y\\<in>set (drop n xs). f x y", "by simp"], ["", "lemma sorted_wrt_hd_less:\n  assumes \"sorted_wrt f xs\" \"\\<And>x. f x x\"\n  shows \"\\<forall>x \\<in> set xs. f (hd xs) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs. f (hd xs) x", "using assms"], ["proof (prove)\nusing this:\n  sorted_wrt f xs\n  f ?x ?x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs. f (hd xs) x", "by (cases xs) auto"], ["", "lemma sorted_wrt_hd_less_take:\n  assumes \"sorted_wrt f (x # xs)\" \"\\<And>x. f x x\"\n  shows \"\\<forall>y \\<in> set (take n (x # xs)). f x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set (take n (x # xs)). f x y", "using assms sorted_wrt_hd_less in_set_takeD"], ["proof (prove)\nusing this:\n  sorted_wrt f (x # xs)\n  f ?x ?x\n  \\<lbrakk>sorted_wrt ?f ?xs; \\<And>x. ?f x x\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set ?xs. ?f (hd ?xs) x\n  ?x \\<in> set (take ?n ?xs) \\<Longrightarrow> ?x \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set (take n (x # xs)). f x y", "by fastforce"], ["", "lemma sorted_wrt_take_less_hd_drop:\n  assumes \"sorted_wrt f xs\" \"n < length xs\"\n  shows \"\\<forall>x \\<in> set (take n xs). f x (hd (drop n xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (take n xs). f x (hd (drop n xs))", "using sorted_wrt_take_drop assms"], ["proof (prove)\nusing this:\n  sorted_wrt ?f ?xs \\<Longrightarrow>\n  \\<forall>x\\<in>set (take ?n ?xs). \\<forall>y\\<in>set (drop ?n ?xs). ?f x y\n  sorted_wrt f xs\n  n < length xs\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (take n xs). f x (hd (drop n xs))", "by fastforce"], ["", "lemma sorted_wrt_hd_drop_less_drop:\n  assumes \"sorted_wrt f xs\" \"\\<And>x. f x x\"\n  shows \"\\<forall>x \\<in> set (drop n xs). f (hd (drop n xs)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (drop n xs). f (hd (drop n xs)) x", "using assms sorted_wrt_drop sorted_wrt_hd_less"], ["proof (prove)\nusing this:\n  sorted_wrt f xs\n  f ?x ?x\n  sorted_wrt ?f ?xs \\<Longrightarrow> sorted_wrt ?f (drop ?n ?xs)\n  \\<lbrakk>sorted_wrt ?f ?xs; \\<And>x. ?f x x\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set ?xs. ?f (hd ?xs) x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (drop n xs). f (hd (drop n xs)) x", "by blast"], ["", "lemma length_filter_P_impl_Q:\n   \"(\\<And>x. P x \\<Longrightarrow> Q x) \\<Longrightarrow> length (filter P xs) \\<le> length (filter Q xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. P x \\<Longrightarrow> Q x) \\<Longrightarrow>\n    length (filter P xs) \\<le> length (filter Q xs)", "by (induction xs) auto"], ["", "lemma filter_Un:\n  \"set xs = A \\<union> B \\<Longrightarrow> set (filter P xs) = { x \\<in> A. P x } \\<union> { x \\<in> B. P x }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs = A \\<union> B \\<Longrightarrow>\n    set (filter P xs) = {x \\<in> A. P x} \\<union> {x \\<in> B. P x}", "by (induction xs) (auto, metis UnI1 insert_iff, metis UnI2 insert_iff)"], ["", "subsubsection \\<open>@{const length}\\<close>"], ["", "fun length_tm :: \"'a list \\<Rightarrow> nat tm\" where\n  \"length_tm [] =1 return 0\"\n| \"length_tm (x # xs) =1\n    do {\n      l <- length_tm xs;\n      return (1 + l)\n    }\""], ["", "lemma length_eq_val_length_tm:\n  \"val (length_tm xs) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Time_Monad.val (length_tm xs) = length xs", "by (induction xs) auto"], ["", "lemma time_length_tm:\n  \"time (length_tm xs) = length xs + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. time (length_tm xs) = length xs + 1", "by (induction xs) (auto simp: time_simps)"], ["", "fun length_it' :: \"nat \\<Rightarrow> 'a list \\<Rightarrow> nat\" where\n  \"length_it' acc [] = acc\"\n| \"length_it' acc (x#xs) = length_it' (acc+1) xs\""], ["", "definition length_it :: \"'a list \\<Rightarrow> nat\" where\n  \"length_it xs = length_it' 0 xs\""], ["", "lemma length_conv_length_it':\n  \"length xs + acc = length_it' acc xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs + acc = length_it' acc xs", "by (induction acc xs rule: length_it'.induct) auto"], ["", "lemma length_conv_length_it[code_unfold]:\n  \"length xs = length_it xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = length_it xs", "unfolding length_it_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = length_it' 0 xs", "using length_conv_length_it' add_0_right"], ["proof (prove)\nusing this:\n  length ?xs + ?acc = length_it' ?acc ?xs\n  ?a + (0::?'a) = ?a\n\ngoal (1 subgoal):\n 1. length xs = length_it' 0 xs", "by metis"], ["", "subsubsection \\<open>@{const rev}\\<close>"], ["", "fun rev_it' :: \"'a list \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n  \"rev_it' acc [] = acc\"\n| \"rev_it' acc (x#xs) = rev_it' (x#acc) xs\""], ["", "definition rev_it :: \"'a list \\<Rightarrow> 'a list\" where\n  \"rev_it xs = rev_it' [] xs\""], ["", "lemma rev_conv_rev_it':\n  \"rev xs @ acc = rev_it' acc xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev xs @ acc = rev_it' acc xs", "by (induction acc xs rule: rev_it'.induct) auto"], ["", "lemma rev_conv_rev_it[code_unfold]:\n  \"rev xs = rev_it xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev xs = rev_it xs", "unfolding rev_it_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rev xs = rev_it' [] xs", "using rev_conv_rev_it' append_Nil2"], ["proof (prove)\nusing this:\n  rev ?xs @ ?acc = rev_it' ?acc ?xs\n  ?xs @ [] = ?xs\n\ngoal (1 subgoal):\n 1. rev xs = rev_it' [] xs", "by metis"], ["", "subsubsection \\<open>@{const take}\\<close>"], ["", "fun take_tm :: \"nat \\<Rightarrow> 'a list \\<Rightarrow> 'a list tm\" where\n  \"take_tm n [] =1 return []\"\n| \"take_tm n (x # xs) =1\n    (case n of\n       0 \\<Rightarrow> return []\n     | Suc m \\<Rightarrow> do {\n         ys <- take_tm m xs;\n         return (x # ys)\n       }\n    )\""], ["", "lemma take_eq_val_take_tm:\n  \"val (take_tm n xs) = take n xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Time_Monad.val (take_tm n xs) = take n xs", "by (induction xs arbitrary: n) (auto split: nat.split)"], ["", "lemma time_take_tm:\n  \"time (take_tm n xs) = min n (length xs) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. time (take_tm n xs) = min n (length xs) + 1", "by (induction xs arbitrary: n) (auto simp: time_simps split: nat.split)"], ["", "subsubsection \\<open>@{const filter}\\<close>"], ["", "fun filter_tm :: \"('a \\<Rightarrow> bool) \\<Rightarrow> 'a list \\<Rightarrow> 'a list tm\" where\n  \"filter_tm P [] =1 return []\"\n| \"filter_tm P (x # xs) =1\n    (if P x then\n       do {\n         ys <- filter_tm P xs;\n         return (x # ys)\n       }\n     else\n       filter_tm P xs\n    )\""], ["", "lemma filter_eq_val_filter_tm:\n  \"val (filter_tm P xs) = filter P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Time_Monad.val (filter_tm P xs) = filter P xs", "by (induction xs) auto"], ["", "lemma time_filter_tm:\n  \"time (filter_tm P xs) = length xs + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. time (filter_tm P xs) = length xs + 1", "by (induction xs) (auto simp: time_simps)"], ["", "fun filter_it' :: \"'a list \\<Rightarrow> ('a \\<Rightarrow> bool) \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n  \"filter_it' acc P [] = rev acc\"\n| \"filter_it' acc P (x#xs) = (\n    if P x then\n      filter_it' (x#acc) P xs\n    else\n      filter_it' acc P xs\n  )\""], ["", "definition filter_it :: \"('a \\<Rightarrow> bool) \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n  \"filter_it P xs = filter_it' [] P xs\""], ["", "lemma filter_conv_filter_it':\n  \"rev acc @ filter P xs = filter_it' acc P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev acc @ filter P xs = filter_it' acc P xs", "by (induction acc P xs rule: filter_it'.induct) auto"], ["", "lemma filter_conv_filter_it[code_unfold]:\n  \"filter P xs = filter_it P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter P xs = filter_it P xs", "unfolding filter_it_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter P xs = filter_it' [] P xs", "using filter_conv_filter_it' append_Nil rev.simps(1)"], ["proof (prove)\nusing this:\n  rev ?acc @ filter ?P ?xs = filter_it' ?acc ?P ?xs\n  [] @ ?ys = ?ys\n  rev [] = []\n\ngoal (1 subgoal):\n 1. filter P xs = filter_it' [] P xs", "by metis"], ["", "subsubsection \\<open>\\<open>split_at\\<close>\\<close>"], ["", "fun split_at_tm :: \"nat \\<Rightarrow> 'a list \\<Rightarrow> ('a list \\<times> 'a list) tm\" where\n  \"split_at_tm n [] =1 return ([], [])\"\n| \"split_at_tm n (x # xs) =1 (\n    case n of\n      0 \\<Rightarrow> return ([], x # xs)\n    | Suc m \\<Rightarrow>\n      do {\n        (xs', ys') <- split_at_tm m xs;\n        return (x # xs', ys')\n      }\n  )\""], ["", "fun split_at :: \"nat \\<Rightarrow> 'a list \\<Rightarrow> 'a list \\<times> 'a list\" where\n  \"split_at n [] = ([], [])\"\n| \"split_at n (x # xs) = (\n    case n of \n      0 \\<Rightarrow> ([], x # xs)\n    | Suc m \\<Rightarrow> \n        let (xs', ys') = split_at m xs in\n        (x # xs', ys')\n  )\""], ["", "lemma split_at_eq_val_split_at_tm:\n  \"val (split_at_tm n xs) = split_at n xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Time_Monad.val (split_at_tm n xs) = split_at n xs", "by (induction xs arbitrary: n) (auto split: nat.split prod.split)"], ["", "lemma split_at_take_drop_conv:\n  \"split_at n xs = (take n xs, drop n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. split_at n xs = (take n xs, drop n xs)", "by (induction xs arbitrary: n) (auto simp: split: nat.split)"], ["", "lemma time_split_at_tm:\n  \"time (split_at_tm n xs) = min n (length xs) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. time (split_at_tm n xs) = min n (length xs) + 1", "by (induction xs arbitrary: n) (auto simp: time_simps split: nat.split prod.split)"], ["", "fun split_at_it' :: \"'a list \\<Rightarrow> nat \\<Rightarrow> 'a list \\<Rightarrow> ('a list * 'a list)\" where\n  \"split_at_it' acc n [] = (rev acc, [])\"\n| \"split_at_it' acc n (x#xs) = (\n    case n of\n      0 \\<Rightarrow> (rev acc, x#xs)\n    | Suc m \\<Rightarrow> split_at_it' (x#acc) m xs\n  )\""], ["", "definition split_at_it :: \"nat \\<Rightarrow> 'a list \\<Rightarrow> ('a list * 'a list)\" where\n  \"split_at_it n xs = split_at_it' [] n xs\""], ["", "lemma split_at_conv_split_at_it':\n  assumes \"(ts, ds) = split_at n xs\" \"(ts', ds') = split_at_it' acc n xs\"\n  shows \"rev acc @ ts = ts'\"\n    and \"ds = ds'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev acc @ ts = ts' &&& ds = ds'", "using assms"], ["proof (prove)\nusing this:\n  (ts, ds) = split_at n xs\n  (ts', ds') = split_at_it' acc n xs\n\ngoal (1 subgoal):\n 1. rev acc @ ts = ts' &&& ds = ds'", "by (induction acc n xs arbitrary: ts rule: split_at_it'.induct)\n     (auto simp: split: prod.splits nat.splits)"], ["", "lemma split_at_conv_split_at_it_prod:\n  assumes \"(ts, ds) = split_at n xs\" \"(ts', ds') = split_at_it n xs\"\n  shows \"(ts, ds) = (ts', ds')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ts, ds) = (ts', ds')", "using assms"], ["proof (prove)\nusing this:\n  (ts, ds) = split_at n xs\n  (ts', ds') = split_at_it n xs\n\ngoal (1 subgoal):\n 1. (ts, ds) = (ts', ds')", "unfolding split_at_it_def"], ["proof (prove)\nusing this:\n  (ts, ds) = split_at n xs\n  (ts', ds') = split_at_it' [] n xs\n\ngoal (1 subgoal):\n 1. (ts, ds) = (ts', ds')", "using split_at_conv_split_at_it' rev.simps(1) append_Nil"], ["proof (prove)\nusing this:\n  (ts, ds) = split_at n xs\n  (ts', ds') = split_at_it' [] n xs\n  \\<lbrakk>(?ts, ?ds) = split_at ?n ?xs;\n   (?ts', ?ds') = split_at_it' ?acc ?n ?xs\\<rbrakk>\n  \\<Longrightarrow> rev ?acc @ ?ts = ?ts'\n  \\<lbrakk>(?ts, ?ds) = split_at ?n ?xs;\n   (?ts', ?ds') = split_at_it' ?acc ?n ?xs\\<rbrakk>\n  \\<Longrightarrow> ?ds = ?ds'\n  rev [] = []\n  [] @ ?ys = ?ys\n\ngoal (1 subgoal):\n 1. (ts, ds) = (ts', ds')", "by fast+"], ["", "lemma split_at_conv_split_at_it[code_unfold]:\n  \"split_at n xs = split_at_it n xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. split_at n xs = split_at_it n xs", "using split_at_conv_split_at_it_prod surj_pair"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?ts, ?ds) = split_at ?n ?xs;\n   (?ts', ?ds') = split_at_it ?n ?xs\\<rbrakk>\n  \\<Longrightarrow> (?ts, ?ds) = (?ts', ?ds')\n  \\<exists>x y. ?p = (x, y)\n\ngoal (1 subgoal):\n 1. split_at n xs = split_at_it n xs", "by metis"], ["", "declare split_at_tm.simps [simp del]"], ["", "declare split_at.simps [simp del]"], ["", "subsection \"Mergesort\""], ["", "subsubsection \"Functional Correctness Proof\""], ["", "definition sorted_fst :: \"point list \\<Rightarrow> bool\" where\n  \"sorted_fst ps = sorted_wrt (\\<lambda>p\\<^sub>0 p\\<^sub>1. fst p\\<^sub>0 \\<le> fst p\\<^sub>1) ps\""], ["", "definition sorted_snd :: \"point list \\<Rightarrow> bool\" where\n  \"sorted_snd ps = sorted_wrt (\\<lambda>p\\<^sub>0 p\\<^sub>1. snd p\\<^sub>0 \\<le> snd p\\<^sub>1) ps\""], ["", "fun merge_tm :: \"('b \\<Rightarrow> 'a::linorder) \\<Rightarrow> 'b list \\<Rightarrow> 'b list \\<Rightarrow> 'b list tm\" where\n  \"merge_tm f (x # xs) (y # ys) =1 (\n    if f x \\<le> f y then\n      do {\n        tl <- merge_tm f xs (y # ys);\n        return (x # tl)\n      }\n    else\n      do {\n        tl <- merge_tm f (x # xs) ys;\n        return (y # tl)\n      }\n  )\"\n| \"merge_tm f [] ys =1 return ys\"\n| \"merge_tm f xs [] =1 return xs\""], ["", "fun merge :: \"('b \\<Rightarrow> 'a::linorder) \\<Rightarrow> 'b list \\<Rightarrow> 'b list \\<Rightarrow> 'b list\" where\n  \"merge f (x # xs) (y # ys) = (\n    if f x \\<le> f y then\n      x # merge f xs (y # ys)\n    else\n      y # merge f (x # xs) ys\n  )\"\n| \"merge f [] ys = ys\"\n| \"merge f xs [] = xs\""], ["", "lemma merge_eq_val_merge_tm:\n  \"val (merge_tm f xs ys) = merge f xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Time_Monad.val (merge_tm f xs ys) = Common.merge f xs ys", "by (induction f xs ys rule: merge.induct) auto"], ["", "lemma length_merge:\n  \"length (merge f xs ys) = length xs + length ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (Common.merge f xs ys) = length xs + length ys", "by (induction f xs ys rule: merge.induct) auto"], ["", "lemma set_merge:\n  \"set (merge f xs ys) = set xs \\<union> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (Common.merge f xs ys) = set xs \\<union> set ys", "by (induction f xs ys rule: merge.induct) auto"], ["", "lemma distinct_merge:\n  assumes \"set xs \\<inter> set ys = {}\" \"distinct xs\" \"distinct ys\"\n  shows \"distinct (merge f xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (Common.merge f xs ys)", "using assms"], ["proof (prove)\nusing this:\n  set xs \\<inter> set ys = {}\n  distinct xs\n  distinct ys\n\ngoal (1 subgoal):\n 1. distinct (Common.merge f xs ys)", "by (induction f xs ys rule: merge.induct) (auto simp: set_merge)"], ["", "lemma sorted_merge:\n  assumes \"P = (\\<lambda>x y. f x \\<le> f y)\"\n  shows \"sorted_wrt P (merge f xs ys) \\<longleftrightarrow> sorted_wrt P xs \\<and> sorted_wrt P ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt P (Common.merge f xs ys) =\n    (sorted_wrt P xs \\<and> sorted_wrt P ys)", "using assms"], ["proof (prove)\nusing this:\n  P = (\\<lambda>x y. f x \\<le> f y)\n\ngoal (1 subgoal):\n 1. sorted_wrt P (Common.merge f xs ys) =\n    (sorted_wrt P xs \\<and> sorted_wrt P ys)", "by (induction f xs ys rule: merge.induct) (auto simp: set_merge)"], ["", "declare split_at_take_drop_conv [simp]"], ["", "function (sequential) mergesort_tm :: \"('b \\<Rightarrow> 'a::linorder) \\<Rightarrow> 'b list \\<Rightarrow> 'b list tm\" where\n  \"mergesort_tm f [] =1 return []\"\n| \"mergesort_tm f [x] =1 return [x]\"\n| \"mergesort_tm f xs =1 (\n    do {\n      n <- length_tm xs;\n      (xs\\<^sub>l, xs\\<^sub>r) <- split_at_tm (n div 2) xs;\n      l <- mergesort_tm f xs\\<^sub>l;\n      r <- mergesort_tm f xs\\<^sub>r;\n      merge_tm f l r\n    }\n  )\""], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>f. x = (f, []) \\<Longrightarrow> P;\n        \\<And>f xa. x = (f, [xa]) \\<Longrightarrow> P;\n        \\<And>f v vb vc. x = (f, v # vb # vc) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>f fa.\n       (f, []) = (fa, []) \\<Longrightarrow>\n       return [] \\<bind> tick =1 return []\n 3. \\<And>f fa x.\n       (f, []) = (fa, [x]) \\<Longrightarrow>\n       return [] \\<bind> tick =1 return [x]\n 4. \\<And>f fa v vb vc.\n       (f, []) = (fa, v # vb # vc) \\<Longrightarrow>\n       return [] \\<bind> tick =1\n       length_tm (v # vb # vc) \\<bind>\n       (\\<lambda>n.\n           split_at_tm (n div 2) (v # vb # vc) \\<bind>\n           (\\<lambda>(xs\\<^sub>l, xs\\<^sub>r).\n               mergesort_tm_sumC (fa, xs\\<^sub>l) \\<bind>\n               (\\<lambda>l.\n                   mergesort_tm_sumC (fa, xs\\<^sub>r) \\<bind>\n                   merge_tm fa l)))\n 5. \\<And>f x fa xa.\n       (f, [x]) = (fa, [xa]) \\<Longrightarrow>\n       return [x] \\<bind> tick =1 return [xa]\n 6. \\<And>f x fa v vb vc.\n       (f, [x]) = (fa, v # vb # vc) \\<Longrightarrow>\n       return [x] \\<bind> tick =1\n       length_tm (v # vb # vc) \\<bind>\n       (\\<lambda>n.\n           split_at_tm (n div 2) (v # vb # vc) \\<bind>\n           (\\<lambda>(xs\\<^sub>l, xs\\<^sub>r).\n               mergesort_tm_sumC (fa, xs\\<^sub>l) \\<bind>\n               (\\<lambda>l.\n                   mergesort_tm_sumC (fa, xs\\<^sub>r) \\<bind>\n                   merge_tm fa l)))\n 7. \\<And>f v vb vc fa va vba vca.\n       (f, v # vb # vc) = (fa, va # vba # vca) \\<Longrightarrow>\n       length_tm (v # vb # vc) \\<bind>\n       (\\<lambda>n.\n           split_at_tm (n div 2) (v # vb # vc) \\<bind>\n           (\\<lambda>(xs\\<^sub>l, xs\\<^sub>r).\n               mergesort_tm_sumC (f, xs\\<^sub>l) \\<bind>\n               (\\<lambda>l.\n                   mergesort_tm_sumC (f, xs\\<^sub>r) \\<bind>\n                   merge_tm f l))) \\<bind>\n       tick =1\n       length_tm (va # vba # vca) \\<bind>\n       (\\<lambda>n.\n           split_at_tm (n div 2) (va # vba # vca) \\<bind>\n           (\\<lambda>(xs\\<^sub>l, xs\\<^sub>r).\n               mergesort_tm_sumC (fa, xs\\<^sub>l) \\<bind>\n               (\\<lambda>l.\n                   mergesort_tm_sumC (fa, xs\\<^sub>r) \\<bind>\n                   merge_tm fa l)))", "by pat_completeness auto"], ["", "termination mergesort_tm"], ["proof (prove)\ngoal (1 subgoal):\n 1. All mergesort_tm_dom", "by (relation \"Wellfounded.measure (\\<lambda>(_, xs). length xs)\")\n     (auto simp add: length_eq_val_length_tm split_at_eq_val_split_at_tm)"], ["", "fun mergesort :: \"('b \\<Rightarrow> 'a::linorder) \\<Rightarrow> 'b list \\<Rightarrow> 'b list\" where\n  \"mergesort f [] = []\"\n| \"mergesort f [x] = [x]\"\n| \"mergesort f xs = ( \n    let n = length xs div 2 in\n    let (l, r) = split_at n xs in\n    merge f (mergesort f l) (mergesort f r)\n  )\""], ["", "declare split_at_take_drop_conv [simp del]"], ["", "lemma mergesort_eq_val_mergesort_tm:\n  \"val (mergesort_tm f xs) = mergesort f xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Time_Monad.val (mergesort_tm f xs) = mergesort f xs", "by (induction f xs rule: mergesort.induct)\n     (auto simp add: length_eq_val_length_tm split_at_eq_val_split_at_tm merge_eq_val_merge_tm split: prod.split)"], ["", "lemma sorted_wrt_mergesort:\n  \"sorted_wrt (\\<lambda>x y. f x \\<le> f y) (mergesort f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. f x \\<le> f y) (mergesort f xs)", "by (induction f xs rule: mergesort.induct) (auto simp: split_at_take_drop_conv sorted_merge)"], ["", "lemma set_mergesort:\n  \"set (mergesort f xs) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (mergesort f xs) = set xs", "by (induction f xs rule: mergesort.induct)\n     (simp_all add: set_merge split_at_take_drop_conv, metis list.simps(15) set_take_drop)"], ["", "lemma length_mergesort:\n  \"length (mergesort f xs) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (mergesort f xs) = length xs", "by (induction f xs rule: mergesort.induct) (auto simp: length_merge split_at_take_drop_conv)"], ["", "lemma distinct_mergesort:\n  \"distinct xs \\<Longrightarrow> distinct (mergesort f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct xs \\<Longrightarrow> distinct (mergesort f xs)", "proof (induction f xs rule: mergesort.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>f. distinct [] \\<Longrightarrow> distinct (mergesort f [])\n 2. \\<And>f x. distinct [x] \\<Longrightarrow> distinct (mergesort f [x])\n 3. \\<And>f v vb vc.\n       \\<lbrakk>\\<And>x xa xb y.\n                   \\<lbrakk>x = length (v # vb # vc) div 2;\n                    xa = split_at x (v # vb # vc); (xb, y) = xa;\n                    distinct xb\\<rbrakk>\n                   \\<Longrightarrow> distinct (mergesort f xb);\n        \\<And>x xa xb y.\n           \\<lbrakk>x = length (v # vb # vc) div 2;\n            xa = split_at x (v # vb # vc); (xb, y) = xa; distinct y\\<rbrakk>\n           \\<Longrightarrow> distinct (mergesort f y);\n        distinct (v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> distinct (mergesort f (v # vb # vc))", "case (3 f x y xs)"], ["proof (state)\nthis:\n  \\<lbrakk>?x = length (x # y # xs) div 2; ?xa = split_at ?x (x # y # xs);\n   (?xb, ?y) = ?xa; distinct ?xb\\<rbrakk>\n  \\<Longrightarrow> distinct (mergesort f ?xb)\n  \\<lbrakk>?x = length (x # y # xs) div 2; ?xa = split_at ?x (x # y # xs);\n   (?xb, ?y) = ?xa; distinct ?y\\<rbrakk>\n  \\<Longrightarrow> distinct (mergesort f ?y)\n  distinct (x # y # xs)\n\ngoal (3 subgoals):\n 1. \\<And>f. distinct [] \\<Longrightarrow> distinct (mergesort f [])\n 2. \\<And>f x. distinct [x] \\<Longrightarrow> distinct (mergesort f [x])\n 3. \\<And>f v vb vc.\n       \\<lbrakk>\\<And>x xa xb y.\n                   \\<lbrakk>x = length (v # vb # vc) div 2;\n                    xa = split_at x (v # vb # vc); (xb, y) = xa;\n                    distinct xb\\<rbrakk>\n                   \\<Longrightarrow> distinct (mergesort f xb);\n        \\<And>x xa xb y.\n           \\<lbrakk>x = length (v # vb # vc) div 2;\n            xa = split_at x (v # vb # vc); (xb, y) = xa; distinct y\\<rbrakk>\n           \\<Longrightarrow> distinct (mergesort f y);\n        distinct (v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> distinct (mergesort f (v # vb # vc))", "let ?xs' = \"x # y # xs\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>f. distinct [] \\<Longrightarrow> distinct (mergesort f [])\n 2. \\<And>f x. distinct [x] \\<Longrightarrow> distinct (mergesort f [x])\n 3. \\<And>f v vb vc.\n       \\<lbrakk>\\<And>x xa xb y.\n                   \\<lbrakk>x = length (v # vb # vc) div 2;\n                    xa = split_at x (v # vb # vc); (xb, y) = xa;\n                    distinct xb\\<rbrakk>\n                   \\<Longrightarrow> distinct (mergesort f xb);\n        \\<And>x xa xb y.\n           \\<lbrakk>x = length (v # vb # vc) div 2;\n            xa = split_at x (v # vb # vc); (xb, y) = xa; distinct y\\<rbrakk>\n           \\<Longrightarrow> distinct (mergesort f y);\n        distinct (v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> distinct (mergesort f (v # vb # vc))", "obtain l r where lr_def: \"(l, r) = split_at (length ?xs' div 2) ?xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l r.\n        (l, r) =\n        split_at (length (x # y # xs) div 2) (x # y # xs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis surj_pair)"], ["proof (state)\nthis:\n  (l, r) = split_at (length (x # y # xs) div 2) (x # y # xs)\n\ngoal (3 subgoals):\n 1. \\<And>f. distinct [] \\<Longrightarrow> distinct (mergesort f [])\n 2. \\<And>f x. distinct [x] \\<Longrightarrow> distinct (mergesort f [x])\n 3. \\<And>f v vb vc.\n       \\<lbrakk>\\<And>x xa xb y.\n                   \\<lbrakk>x = length (v # vb # vc) div 2;\n                    xa = split_at x (v # vb # vc); (xb, y) = xa;\n                    distinct xb\\<rbrakk>\n                   \\<Longrightarrow> distinct (mergesort f xb);\n        \\<And>x xa xb y.\n           \\<lbrakk>x = length (v # vb # vc) div 2;\n            xa = split_at x (v # vb # vc); (xb, y) = xa; distinct y\\<rbrakk>\n           \\<Longrightarrow> distinct (mergesort f y);\n        distinct (v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> distinct (mergesort f (v # vb # vc))", "have \"distinct l\" \"distinct r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct l &&& distinct r", "using \"3.prems\" split_at_take_drop_conv distinct_take distinct_drop lr_def"], ["proof (prove)\nusing this:\n  distinct (x # y # xs)\n  split_at ?n ?xs = (take ?n ?xs, drop ?n ?xs)\n  distinct ?xs \\<Longrightarrow> distinct (take ?i ?xs)\n  distinct ?xs \\<Longrightarrow> distinct (drop ?i ?xs)\n  (l, r) = split_at (length (x # y # xs) div 2) (x # y # xs)\n\ngoal (1 subgoal):\n 1. distinct l &&& distinct r", "by (metis prod.sel)+"], ["proof (state)\nthis:\n  distinct l\n  distinct r\n\ngoal (3 subgoals):\n 1. \\<And>f. distinct [] \\<Longrightarrow> distinct (mergesort f [])\n 2. \\<And>f x. distinct [x] \\<Longrightarrow> distinct (mergesort f [x])\n 3. \\<And>f v vb vc.\n       \\<lbrakk>\\<And>x xa xb y.\n                   \\<lbrakk>x = length (v # vb # vc) div 2;\n                    xa = split_at x (v # vb # vc); (xb, y) = xa;\n                    distinct xb\\<rbrakk>\n                   \\<Longrightarrow> distinct (mergesort f xb);\n        \\<And>x xa xb y.\n           \\<lbrakk>x = length (v # vb # vc) div 2;\n            xa = split_at x (v # vb # vc); (xb, y) = xa; distinct y\\<rbrakk>\n           \\<Longrightarrow> distinct (mergesort f y);\n        distinct (v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> distinct (mergesort f (v # vb # vc))", "hence \"distinct (mergesort f l)\" \"distinct (mergesort f r)\""], ["proof (prove)\nusing this:\n  distinct l\n  distinct r\n\ngoal (1 subgoal):\n 1. distinct (mergesort f l) &&& distinct (mergesort f r)", "using \"3.IH\" lr_def"], ["proof (prove)\nusing this:\n  distinct l\n  distinct r\n  \\<lbrakk>?x = length (x # y # xs) div 2; ?xa = split_at ?x (x # y # xs);\n   (?xb, ?y) = ?xa; distinct ?xb\\<rbrakk>\n  \\<Longrightarrow> distinct (mergesort f ?xb)\n  \\<lbrakk>?x = length (x # y # xs) div 2; ?xa = split_at ?x (x # y # xs);\n   (?xb, ?y) = ?xa; distinct ?y\\<rbrakk>\n  \\<Longrightarrow> distinct (mergesort f ?y)\n  (l, r) = split_at (length (x # y # xs) div 2) (x # y # xs)\n\ngoal (1 subgoal):\n 1. distinct (mergesort f l) &&& distinct (mergesort f r)", "by auto"], ["proof (state)\nthis:\n  distinct (mergesort f l)\n  distinct (mergesort f r)\n\ngoal (3 subgoals):\n 1. \\<And>f. distinct [] \\<Longrightarrow> distinct (mergesort f [])\n 2. \\<And>f x. distinct [x] \\<Longrightarrow> distinct (mergesort f [x])\n 3. \\<And>f v vb vc.\n       \\<lbrakk>\\<And>x xa xb y.\n                   \\<lbrakk>x = length (v # vb # vc) div 2;\n                    xa = split_at x (v # vb # vc); (xb, y) = xa;\n                    distinct xb\\<rbrakk>\n                   \\<Longrightarrow> distinct (mergesort f xb);\n        \\<And>x xa xb y.\n           \\<lbrakk>x = length (v # vb # vc) div 2;\n            xa = split_at x (v # vb # vc); (xb, y) = xa; distinct y\\<rbrakk>\n           \\<Longrightarrow> distinct (mergesort f y);\n        distinct (v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> distinct (mergesort f (v # vb # vc))", "moreover"], ["proof (state)\nthis:\n  distinct (mergesort f l)\n  distinct (mergesort f r)\n\ngoal (3 subgoals):\n 1. \\<And>f. distinct [] \\<Longrightarrow> distinct (mergesort f [])\n 2. \\<And>f x. distinct [x] \\<Longrightarrow> distinct (mergesort f [x])\n 3. \\<And>f v vb vc.\n       \\<lbrakk>\\<And>x xa xb y.\n                   \\<lbrakk>x = length (v # vb # vc) div 2;\n                    xa = split_at x (v # vb # vc); (xb, y) = xa;\n                    distinct xb\\<rbrakk>\n                   \\<Longrightarrow> distinct (mergesort f xb);\n        \\<And>x xa xb y.\n           \\<lbrakk>x = length (v # vb # vc) div 2;\n            xa = split_at x (v # vb # vc); (xb, y) = xa; distinct y\\<rbrakk>\n           \\<Longrightarrow> distinct (mergesort f y);\n        distinct (v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> distinct (mergesort f (v # vb # vc))", "have \"set l \\<inter> set r = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set l \\<inter> set r = {}", "using \"3.prems\" split_at_take_drop_conv lr_def"], ["proof (prove)\nusing this:\n  distinct (x # y # xs)\n  split_at ?n ?xs = (take ?n ?xs, drop ?n ?xs)\n  (l, r) = split_at (length (x # y # xs) div 2) (x # y # xs)\n\ngoal (1 subgoal):\n 1. set l \\<inter> set r = {}", "by (metis append_take_drop_id distinct_append prod.sel)"], ["proof (state)\nthis:\n  set l \\<inter> set r = {}\n\ngoal (3 subgoals):\n 1. \\<And>f. distinct [] \\<Longrightarrow> distinct (mergesort f [])\n 2. \\<And>f x. distinct [x] \\<Longrightarrow> distinct (mergesort f [x])\n 3. \\<And>f v vb vc.\n       \\<lbrakk>\\<And>x xa xb y.\n                   \\<lbrakk>x = length (v # vb # vc) div 2;\n                    xa = split_at x (v # vb # vc); (xb, y) = xa;\n                    distinct xb\\<rbrakk>\n                   \\<Longrightarrow> distinct (mergesort f xb);\n        \\<And>x xa xb y.\n           \\<lbrakk>x = length (v # vb # vc) div 2;\n            xa = split_at x (v # vb # vc); (xb, y) = xa; distinct y\\<rbrakk>\n           \\<Longrightarrow> distinct (mergesort f y);\n        distinct (v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> distinct (mergesort f (v # vb # vc))", "ultimately"], ["proof (chain)\npicking this:\n  distinct (mergesort f l)\n  distinct (mergesort f r)\n  set l \\<inter> set r = {}", "show ?case"], ["proof (prove)\nusing this:\n  distinct (mergesort f l)\n  distinct (mergesort f r)\n  set l \\<inter> set r = {}\n\ngoal (1 subgoal):\n 1. distinct (mergesort f (x # y # xs))", "using lr_def"], ["proof (prove)\nusing this:\n  distinct (mergesort f l)\n  distinct (mergesort f r)\n  set l \\<inter> set r = {}\n  (l, r) = split_at (length (x # y # xs) div 2) (x # y # xs)\n\ngoal (1 subgoal):\n 1. distinct (mergesort f (x # y # xs))", "by (auto simp: distinct_merge set_mergesort split: prod.splits)"], ["proof (state)\nthis:\n  distinct (mergesort f (x # y # xs))\n\ngoal (2 subgoals):\n 1. \\<And>f. distinct [] \\<Longrightarrow> distinct (mergesort f [])\n 2. \\<And>f x. distinct [x] \\<Longrightarrow> distinct (mergesort f [x])", "qed auto"], ["", "lemmas mergesort = sorted_wrt_mergesort set_mergesort length_mergesort distinct_mergesort"], ["", "lemma sorted_fst_take_less_hd_drop:\n  assumes \"sorted_fst ps\" \"n < length ps\"\n  shows \"\\<forall>p \\<in> set (take n ps). fst p \\<le> fst (hd (drop n ps))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set (take n ps). fst p \\<le> fst (hd (drop n ps))", "using assms sorted_wrt_take_less_hd_drop[of \"\\<lambda>p\\<^sub>0 p\\<^sub>1. fst p\\<^sub>0 \\<le> fst p\\<^sub>1\"] sorted_fst_def"], ["proof (prove)\nusing this:\n  sorted_fst ps\n  n < length ps\n  \\<lbrakk>sorted_wrt\n            (\\<lambda>p\\<^sub>0 p\\<^sub>1.\n                fst p\\<^sub>0 \\<le> fst p\\<^sub>1)\n            ?xs;\n   ?n < length ?xs\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set (take ?n ?xs).\n                       fst x \\<le> fst (hd (drop ?n ?xs))\n  sorted_fst ?ps =\n  sorted_wrt\n   (\\<lambda>p\\<^sub>0 p\\<^sub>1. fst p\\<^sub>0 \\<le> fst p\\<^sub>1) ?ps\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set (take n ps). fst p \\<le> fst (hd (drop n ps))", "by fastforce"], ["", "lemma sorted_fst_hd_drop_less_drop:\n  assumes \"sorted_fst ps\"\n  shows \"\\<forall>p \\<in> set (drop n ps). fst (hd (drop n ps)) \\<le> fst p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set (drop n ps). fst (hd (drop n ps)) \\<le> fst p", "using assms sorted_wrt_hd_drop_less_drop[of \"\\<lambda>p\\<^sub>0 p\\<^sub>1. fst p\\<^sub>0 \\<le> fst p\\<^sub>1\"] sorted_fst_def"], ["proof (prove)\nusing this:\n  sorted_fst ps\n  \\<lbrakk>sorted_wrt\n            (\\<lambda>p\\<^sub>0 p\\<^sub>1.\n                fst p\\<^sub>0 \\<le> fst p\\<^sub>1)\n            ?xs;\n   \\<And>x. fst x \\<le> fst x\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set (drop ?n ?xs).\n                       fst (hd (drop ?n ?xs)) \\<le> fst x\n  sorted_fst ?ps =\n  sorted_wrt\n   (\\<lambda>p\\<^sub>0 p\\<^sub>1. fst p\\<^sub>0 \\<le> fst p\\<^sub>1) ?ps\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set (drop n ps). fst (hd (drop n ps)) \\<le> fst p", "by fastforce"], ["", "subsubsection \"Time Complexity Proof\""], ["", "lemma time_merge_tm:\n  \"time (merge_tm f xs ys) \\<le> length xs + length ys + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. time (merge_tm f xs ys) \\<le> length xs + length ys + 1", "by (induction f xs ys rule: merge_tm.induct) (auto simp: time_simps)"], ["", "function mergesort_recurrence :: \"nat \\<Rightarrow> real\" where\n  \"mergesort_recurrence 0 = 1\"\n| \"mergesort_recurrence 1 = 1\"\n| \"2 \\<le> n \\<Longrightarrow> mergesort_recurrence n = 4 + 3 * n + mergesort_recurrence (nat \\<lfloor>real n / 2\\<rfloor>) + \n    mergesort_recurrence (nat \\<lceil>real n / 2\\<rceil>)\""], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>x = 0 \\<Longrightarrow> P; x = 1 \\<Longrightarrow> P;\n        \\<And>n.\n           \\<lbrakk>2 \\<le> n; x = n\\<rbrakk> \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. 0 = 0 \\<Longrightarrow> 1 = 1\n 3. 0 = 1 \\<Longrightarrow> 1 = 1\n 4. \\<And>n.\n       \\<lbrakk>2 \\<le> n; 0 = n\\<rbrakk>\n       \\<Longrightarrow> 1 =\n                         4 + 3 * real n +\n                         mergesort_recurrence_sumC\n                          (nat \\<lfloor>real n / 2\\<rfloor>) +\n                         mergesort_recurrence_sumC\n                          (nat \\<lceil>real n / 2\\<rceil>)\n 5. 1 = 1 \\<Longrightarrow> 1 = 1\n 6. \\<And>n.\n       \\<lbrakk>2 \\<le> n; 1 = n\\<rbrakk>\n       \\<Longrightarrow> 1 =\n                         4 + 3 * real n +\n                         mergesort_recurrence_sumC\n                          (nat \\<lfloor>real n / 2\\<rfloor>) +\n                         mergesort_recurrence_sumC\n                          (nat \\<lceil>real n / 2\\<rceil>)\n 7. \\<And>n na.\n       \\<lbrakk>2 \\<le> n; 2 \\<le> na; n = na\\<rbrakk>\n       \\<Longrightarrow> 4 + 3 * real n +\n                         mergesort_recurrence_sumC\n                          (nat \\<lfloor>real n / 2\\<rfloor>) +\n                         mergesort_recurrence_sumC\n                          (nat \\<lceil>real n / 2\\<rceil>) =\n                         4 + 3 * real na +\n                         mergesort_recurrence_sumC\n                          (nat \\<lfloor>real na / 2\\<rfloor>) +\n                         mergesort_recurrence_sumC\n                          (nat \\<lceil>real na / 2\\<rceil>)", "by force simp_all"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All mergesort_recurrence_dom", "by akra_bazzi_termination simp_all"], ["", "lemma mergesort_recurrence_nonneg[simp]:\n  \"0 \\<le> mergesort_recurrence n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> mergesort_recurrence n", "by (induction n rule: mergesort_recurrence.induct) (auto simp del: One_nat_def)"], ["", "lemma time_mergesort_conv_mergesort_recurrence:\n  \"time (mergesort_tm f xs) \\<le> mergesort_recurrence (length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (time (mergesort_tm f xs)) \\<le> mergesort_recurrence (length xs)", "proof (induction f xs rule: mergesort_tm.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>f.\n       real (time (mergesort_tm f []))\n       \\<le> mergesort_recurrence (length [])\n 2. \\<And>f x.\n       real (time (mergesort_tm f [x]))\n       \\<le> mergesort_recurrence (length [x])\n 3. \\<And>f v vb vc.\n       \\<lbrakk>\\<And>va vd x y.\n                   \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n                    vd =\n                    Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n                    (x, y) = vd\\<rbrakk>\n                   \\<Longrightarrow> real (time (mergesort_tm f x))\n                                     \\<le> mergesort_recurrence (length x);\n        \\<And>va vd x y ve.\n           \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n            vd = Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n            (x, y) = vd; ve = Time_Monad.val (mergesort_tm f x)\\<rbrakk>\n           \\<Longrightarrow> real (time (mergesort_tm f y))\n                             \\<le> mergesort_recurrence (length y)\\<rbrakk>\n       \\<Longrightarrow> real (time (mergesort_tm f (v # vb # vc)))\n                         \\<le> mergesort_recurrence (length (v # vb # vc))", "case (1 f)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>f.\n       real (time (mergesort_tm f []))\n       \\<le> mergesort_recurrence (length [])\n 2. \\<And>f x.\n       real (time (mergesort_tm f [x]))\n       \\<le> mergesort_recurrence (length [x])\n 3. \\<And>f v vb vc.\n       \\<lbrakk>\\<And>va vd x y.\n                   \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n                    vd =\n                    Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n                    (x, y) = vd\\<rbrakk>\n                   \\<Longrightarrow> real (time (mergesort_tm f x))\n                                     \\<le> mergesort_recurrence (length x);\n        \\<And>va vd x y ve.\n           \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n            vd = Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n            (x, y) = vd; ve = Time_Monad.val (mergesort_tm f x)\\<rbrakk>\n           \\<Longrightarrow> real (time (mergesort_tm f y))\n                             \\<le> mergesort_recurrence (length y)\\<rbrakk>\n       \\<Longrightarrow> real (time (mergesort_tm f (v # vb # vc)))\n                         \\<le> mergesort_recurrence (length (v # vb # vc))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. real (time (mergesort_tm f [])) \\<le> mergesort_recurrence (length [])", "by (auto simp: time_simps)"], ["proof (state)\nthis:\n  real (time (mergesort_tm f [])) \\<le> mergesort_recurrence (length [])\n\ngoal (2 subgoals):\n 1. \\<And>f x.\n       real (time (mergesort_tm f [x]))\n       \\<le> mergesort_recurrence (length [x])\n 2. \\<And>f v vb vc.\n       \\<lbrakk>\\<And>va vd x y.\n                   \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n                    vd =\n                    Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n                    (x, y) = vd\\<rbrakk>\n                   \\<Longrightarrow> real (time (mergesort_tm f x))\n                                     \\<le> mergesort_recurrence (length x);\n        \\<And>va vd x y ve.\n           \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n            vd = Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n            (x, y) = vd; ve = Time_Monad.val (mergesort_tm f x)\\<rbrakk>\n           \\<Longrightarrow> real (time (mergesort_tm f y))\n                             \\<le> mergesort_recurrence (length y)\\<rbrakk>\n       \\<Longrightarrow> real (time (mergesort_tm f (v # vb # vc)))\n                         \\<le> mergesort_recurrence (length (v # vb # vc))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f x.\n       real (time (mergesort_tm f [x]))\n       \\<le> mergesort_recurrence (length [x])\n 2. \\<And>f v vb vc.\n       \\<lbrakk>\\<And>va vd x y.\n                   \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n                    vd =\n                    Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n                    (x, y) = vd\\<rbrakk>\n                   \\<Longrightarrow> real (time (mergesort_tm f x))\n                                     \\<le> mergesort_recurrence (length x);\n        \\<And>va vd x y ve.\n           \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n            vd = Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n            (x, y) = vd; ve = Time_Monad.val (mergesort_tm f x)\\<rbrakk>\n           \\<Longrightarrow> real (time (mergesort_tm f y))\n                             \\<le> mergesort_recurrence (length y)\\<rbrakk>\n       \\<Longrightarrow> real (time (mergesort_tm f (v # vb # vc)))\n                         \\<le> mergesort_recurrence (length (v # vb # vc))", "case (2 f x)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>f x.\n       real (time (mergesort_tm f [x]))\n       \\<le> mergesort_recurrence (length [x])\n 2. \\<And>f v vb vc.\n       \\<lbrakk>\\<And>va vd x y.\n                   \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n                    vd =\n                    Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n                    (x, y) = vd\\<rbrakk>\n                   \\<Longrightarrow> real (time (mergesort_tm f x))\n                                     \\<le> mergesort_recurrence (length x);\n        \\<And>va vd x y ve.\n           \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n            vd = Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n            (x, y) = vd; ve = Time_Monad.val (mergesort_tm f x)\\<rbrakk>\n           \\<Longrightarrow> real (time (mergesort_tm f y))\n                             \\<le> mergesort_recurrence (length y)\\<rbrakk>\n       \\<Longrightarrow> real (time (mergesort_tm f (v # vb # vc)))\n                         \\<le> mergesort_recurrence (length (v # vb # vc))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. real (time (mergesort_tm f [x])) \\<le> mergesort_recurrence (length [x])", "using mergesort_recurrence.simps(2)"], ["proof (prove)\nusing this:\n  mergesort_recurrence 1 = 1\n\ngoal (1 subgoal):\n 1. real (time (mergesort_tm f [x])) \\<le> mergesort_recurrence (length [x])", "by (auto simp: time_simps)"], ["proof (state)\nthis:\n  real (time (mergesort_tm f [x])) \\<le> mergesort_recurrence (length [x])\n\ngoal (1 subgoal):\n 1. \\<And>f v vb vc.\n       \\<lbrakk>\\<And>va vd x y.\n                   \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n                    vd =\n                    Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n                    (x, y) = vd\\<rbrakk>\n                   \\<Longrightarrow> real (time (mergesort_tm f x))\n                                     \\<le> mergesort_recurrence (length x);\n        \\<And>va vd x y ve.\n           \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n            vd = Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n            (x, y) = vd; ve = Time_Monad.val (mergesort_tm f x)\\<rbrakk>\n           \\<Longrightarrow> real (time (mergesort_tm f y))\n                             \\<le> mergesort_recurrence (length y)\\<rbrakk>\n       \\<Longrightarrow> real (time (mergesort_tm f (v # vb # vc)))\n                         \\<le> mergesort_recurrence (length (v # vb # vc))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f v vb vc.\n       \\<lbrakk>\\<And>va vd x y.\n                   \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n                    vd =\n                    Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n                    (x, y) = vd\\<rbrakk>\n                   \\<Longrightarrow> real (time (mergesort_tm f x))\n                                     \\<le> mergesort_recurrence (length x);\n        \\<And>va vd x y ve.\n           \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n            vd = Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n            (x, y) = vd; ve = Time_Monad.val (mergesort_tm f x)\\<rbrakk>\n           \\<Longrightarrow> real (time (mergesort_tm f y))\n                             \\<le> mergesort_recurrence (length y)\\<rbrakk>\n       \\<Longrightarrow> real (time (mergesort_tm f (v # vb # vc)))\n                         \\<le> mergesort_recurrence (length (v # vb # vc))", "case (3 f x y xs')"], ["proof (state)\nthis:\n  \\<lbrakk>?va = Time_Monad.val (length_tm (x # y # xs'));\n   ?vd = Time_Monad.val (split_at_tm (?va div 2) (x # y # xs'));\n   (?x, ?y) = ?vd\\<rbrakk>\n  \\<Longrightarrow> real (time (mergesort_tm f ?x))\n                    \\<le> mergesort_recurrence (length ?x)\n  \\<lbrakk>?va = Time_Monad.val (length_tm (x # y # xs'));\n   ?vd = Time_Monad.val (split_at_tm (?va div 2) (x # y # xs'));\n   (?x, ?y) = ?vd; ?ve = Time_Monad.val (mergesort_tm f ?x)\\<rbrakk>\n  \\<Longrightarrow> real (time (mergesort_tm f ?y))\n                    \\<le> mergesort_recurrence (length ?y)\n\ngoal (1 subgoal):\n 1. \\<And>f v vb vc.\n       \\<lbrakk>\\<And>va vd x y.\n                   \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n                    vd =\n                    Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n                    (x, y) = vd\\<rbrakk>\n                   \\<Longrightarrow> real (time (mergesort_tm f x))\n                                     \\<le> mergesort_recurrence (length x);\n        \\<And>va vd x y ve.\n           \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n            vd = Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n            (x, y) = vd; ve = Time_Monad.val (mergesort_tm f x)\\<rbrakk>\n           \\<Longrightarrow> real (time (mergesort_tm f y))\n                             \\<le> mergesort_recurrence (length y)\\<rbrakk>\n       \\<Longrightarrow> real (time (mergesort_tm f (v # vb # vc)))\n                         \\<le> mergesort_recurrence (length (v # vb # vc))", "define xs where \"xs = x # y # xs'\""], ["proof (state)\nthis:\n  xs = x # y # xs'\n\ngoal (1 subgoal):\n 1. \\<And>f v vb vc.\n       \\<lbrakk>\\<And>va vd x y.\n                   \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n                    vd =\n                    Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n                    (x, y) = vd\\<rbrakk>\n                   \\<Longrightarrow> real (time (mergesort_tm f x))\n                                     \\<le> mergesort_recurrence (length x);\n        \\<And>va vd x y ve.\n           \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n            vd = Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n            (x, y) = vd; ve = Time_Monad.val (mergesort_tm f x)\\<rbrakk>\n           \\<Longrightarrow> real (time (mergesort_tm f y))\n                             \\<le> mergesort_recurrence (length y)\\<rbrakk>\n       \\<Longrightarrow> real (time (mergesort_tm f (v # vb # vc)))\n                         \\<le> mergesort_recurrence (length (v # vb # vc))", "define n where \"n = length xs\""], ["proof (state)\nthis:\n  n = length xs\n\ngoal (1 subgoal):\n 1. \\<And>f v vb vc.\n       \\<lbrakk>\\<And>va vd x y.\n                   \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n                    vd =\n                    Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n                    (x, y) = vd\\<rbrakk>\n                   \\<Longrightarrow> real (time (mergesort_tm f x))\n                                     \\<le> mergesort_recurrence (length x);\n        \\<And>va vd x y ve.\n           \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n            vd = Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n            (x, y) = vd; ve = Time_Monad.val (mergesort_tm f x)\\<rbrakk>\n           \\<Longrightarrow> real (time (mergesort_tm f y))\n                             \\<le> mergesort_recurrence (length y)\\<rbrakk>\n       \\<Longrightarrow> real (time (mergesort_tm f (v # vb # vc)))\n                         \\<le> mergesort_recurrence (length (v # vb # vc))", "obtain l r where lr_def: \"(l, r) = split_at (n div 2) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l r.\n        (l, r) = split_at (n div 2) xs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using prod.collapse"], ["proof (prove)\nusing this:\n  (fst ?prod, snd ?prod) = ?prod\n\ngoal (1 subgoal):\n 1. (\\<And>l r.\n        (l, r) = split_at (n div 2) xs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (l, r) = split_at (n div 2) xs\n\ngoal (1 subgoal):\n 1. \\<And>f v vb vc.\n       \\<lbrakk>\\<And>va vd x y.\n                   \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n                    vd =\n                    Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n                    (x, y) = vd\\<rbrakk>\n                   \\<Longrightarrow> real (time (mergesort_tm f x))\n                                     \\<le> mergesort_recurrence (length x);\n        \\<And>va vd x y ve.\n           \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n            vd = Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n            (x, y) = vd; ve = Time_Monad.val (mergesort_tm f x)\\<rbrakk>\n           \\<Longrightarrow> real (time (mergesort_tm f y))\n                             \\<le> mergesort_recurrence (length y)\\<rbrakk>\n       \\<Longrightarrow> real (time (mergesort_tm f (v # vb # vc)))\n                         \\<le> mergesort_recurrence (length (v # vb # vc))", "define l' where \"l' = mergesort f l\""], ["proof (state)\nthis:\n  l' = mergesort f l\n\ngoal (1 subgoal):\n 1. \\<And>f v vb vc.\n       \\<lbrakk>\\<And>va vd x y.\n                   \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n                    vd =\n                    Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n                    (x, y) = vd\\<rbrakk>\n                   \\<Longrightarrow> real (time (mergesort_tm f x))\n                                     \\<le> mergesort_recurrence (length x);\n        \\<And>va vd x y ve.\n           \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n            vd = Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n            (x, y) = vd; ve = Time_Monad.val (mergesort_tm f x)\\<rbrakk>\n           \\<Longrightarrow> real (time (mergesort_tm f y))\n                             \\<le> mergesort_recurrence (length y)\\<rbrakk>\n       \\<Longrightarrow> real (time (mergesort_tm f (v # vb # vc)))\n                         \\<le> mergesort_recurrence (length (v # vb # vc))", "define r' where \"r' = mergesort f r\""], ["proof (state)\nthis:\n  r' = mergesort f r\n\ngoal (1 subgoal):\n 1. \\<And>f v vb vc.\n       \\<lbrakk>\\<And>va vd x y.\n                   \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n                    vd =\n                    Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n                    (x, y) = vd\\<rbrakk>\n                   \\<Longrightarrow> real (time (mergesort_tm f x))\n                                     \\<le> mergesort_recurrence (length x);\n        \\<And>va vd x y ve.\n           \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n            vd = Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n            (x, y) = vd; ve = Time_Monad.val (mergesort_tm f x)\\<rbrakk>\n           \\<Longrightarrow> real (time (mergesort_tm f y))\n                             \\<le> mergesort_recurrence (length y)\\<rbrakk>\n       \\<Longrightarrow> real (time (mergesort_tm f (v # vb # vc)))\n                         \\<le> mergesort_recurrence (length (v # vb # vc))", "note defs = xs_def n_def lr_def l'_def r'_def"], ["proof (state)\nthis:\n  xs = x # y # xs'\n  n = length xs\n  (l, r) = split_at (n div 2) xs\n  l' = mergesort f l\n  r' = mergesort f r\n\ngoal (1 subgoal):\n 1. \\<And>f v vb vc.\n       \\<lbrakk>\\<And>va vd x y.\n                   \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n                    vd =\n                    Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n                    (x, y) = vd\\<rbrakk>\n                   \\<Longrightarrow> real (time (mergesort_tm f x))\n                                     \\<le> mergesort_recurrence (length x);\n        \\<And>va vd x y ve.\n           \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n            vd = Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n            (x, y) = vd; ve = Time_Monad.val (mergesort_tm f x)\\<rbrakk>\n           \\<Longrightarrow> real (time (mergesort_tm f y))\n                             \\<le> mergesort_recurrence (length y)\\<rbrakk>\n       \\<Longrightarrow> real (time (mergesort_tm f (v # vb # vc)))\n                         \\<le> mergesort_recurrence (length (v # vb # vc))", "have IHL: \"time (mergesort_tm f l) \\<le> mergesort_recurrence (length l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (time (mergesort_tm f l)) \\<le> mergesort_recurrence (length l)", "using defs \"3.IH\"(1)"], ["proof (prove)\nusing this:\n  xs = x # y # xs'\n  n = length xs\n  (l, r) = split_at (n div 2) xs\n  l' = mergesort f l\n  r' = mergesort f r\n  \\<lbrakk>?va = Time_Monad.val (length_tm (x # y # xs'));\n   ?vd = Time_Monad.val (split_at_tm (?va div 2) (x # y # xs'));\n   (?x, ?y) = ?vd\\<rbrakk>\n  \\<Longrightarrow> real (time (mergesort_tm f ?x))\n                    \\<le> mergesort_recurrence (length ?x)\n\ngoal (1 subgoal):\n 1. real (time (mergesort_tm f l)) \\<le> mergesort_recurrence (length l)", "by (auto simp: length_eq_val_length_tm split_at_eq_val_split_at_tm)"], ["proof (state)\nthis:\n  real (time (mergesort_tm f l)) \\<le> mergesort_recurrence (length l)\n\ngoal (1 subgoal):\n 1. \\<And>f v vb vc.\n       \\<lbrakk>\\<And>va vd x y.\n                   \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n                    vd =\n                    Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n                    (x, y) = vd\\<rbrakk>\n                   \\<Longrightarrow> real (time (mergesort_tm f x))\n                                     \\<le> mergesort_recurrence (length x);\n        \\<And>va vd x y ve.\n           \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n            vd = Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n            (x, y) = vd; ve = Time_Monad.val (mergesort_tm f x)\\<rbrakk>\n           \\<Longrightarrow> real (time (mergesort_tm f y))\n                             \\<le> mergesort_recurrence (length y)\\<rbrakk>\n       \\<Longrightarrow> real (time (mergesort_tm f (v # vb # vc)))\n                         \\<le> mergesort_recurrence (length (v # vb # vc))", "have IHR: \"time (mergesort_tm f r) \\<le> mergesort_recurrence (length r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (time (mergesort_tm f r)) \\<le> mergesort_recurrence (length r)", "using defs \"3.IH\"(2)"], ["proof (prove)\nusing this:\n  xs = x # y # xs'\n  n = length xs\n  (l, r) = split_at (n div 2) xs\n  l' = mergesort f l\n  r' = mergesort f r\n  \\<lbrakk>?va = Time_Monad.val (length_tm (x # y # xs'));\n   ?vd = Time_Monad.val (split_at_tm (?va div 2) (x # y # xs'));\n   (?x, ?y) = ?vd; ?ve = Time_Monad.val (mergesort_tm f ?x)\\<rbrakk>\n  \\<Longrightarrow> real (time (mergesort_tm f ?y))\n                    \\<le> mergesort_recurrence (length ?y)\n\ngoal (1 subgoal):\n 1. real (time (mergesort_tm f r)) \\<le> mergesort_recurrence (length r)", "by (auto simp: length_eq_val_length_tm split_at_eq_val_split_at_tm)"], ["proof (state)\nthis:\n  real (time (mergesort_tm f r)) \\<le> mergesort_recurrence (length r)\n\ngoal (1 subgoal):\n 1. \\<And>f v vb vc.\n       \\<lbrakk>\\<And>va vd x y.\n                   \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n                    vd =\n                    Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n                    (x, y) = vd\\<rbrakk>\n                   \\<Longrightarrow> real (time (mergesort_tm f x))\n                                     \\<le> mergesort_recurrence (length x);\n        \\<And>va vd x y ve.\n           \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n            vd = Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n            (x, y) = vd; ve = Time_Monad.val (mergesort_tm f x)\\<rbrakk>\n           \\<Longrightarrow> real (time (mergesort_tm f y))\n                             \\<le> mergesort_recurrence (length y)\\<rbrakk>\n       \\<Longrightarrow> real (time (mergesort_tm f (v # vb # vc)))\n                         \\<le> mergesort_recurrence (length (v # vb # vc))", "have *: \"length l = n div 2\" \"length r = n - n div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length l = n div 2 &&& length r = n - n div 2", "using defs"], ["proof (prove)\nusing this:\n  xs = x # y # xs'\n  n = length xs\n  (l, r) = split_at (n div 2) xs\n  l' = mergesort f l\n  r' = mergesort f r\n\ngoal (1 subgoal):\n 1. length l = n div 2 &&& length r = n - n div 2", "by (auto simp: split_at_take_drop_conv)"], ["proof (state)\nthis:\n  length l = n div 2\n  length r = n - n div 2\n\ngoal (1 subgoal):\n 1. \\<And>f v vb vc.\n       \\<lbrakk>\\<And>va vd x y.\n                   \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n                    vd =\n                    Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n                    (x, y) = vd\\<rbrakk>\n                   \\<Longrightarrow> real (time (mergesort_tm f x))\n                                     \\<le> mergesort_recurrence (length x);\n        \\<And>va vd x y ve.\n           \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n            vd = Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n            (x, y) = vd; ve = Time_Monad.val (mergesort_tm f x)\\<rbrakk>\n           \\<Longrightarrow> real (time (mergesort_tm f y))\n                             \\<le> mergesort_recurrence (length y)\\<rbrakk>\n       \\<Longrightarrow> real (time (mergesort_tm f (v # vb # vc)))\n                         \\<le> mergesort_recurrence (length (v # vb # vc))", "hence \"(nat \\<lfloor>real n / 2\\<rfloor>) = length l\" \"(nat \\<lceil>real n / 2\\<rceil>) = length r\""], ["proof (prove)\nusing this:\n  length l = n div 2\n  length r = n - n div 2\n\ngoal (1 subgoal):\n 1. nat \\<lfloor>real n / 2\\<rfloor> = length l &&&\n    nat \\<lceil>real n / 2\\<rceil> = length r", "by linarith+"], ["proof (state)\nthis:\n  nat \\<lfloor>real n / 2\\<rfloor> = length l\n  nat \\<lceil>real n / 2\\<rceil> = length r\n\ngoal (1 subgoal):\n 1. \\<And>f v vb vc.\n       \\<lbrakk>\\<And>va vd x y.\n                   \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n                    vd =\n                    Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n                    (x, y) = vd\\<rbrakk>\n                   \\<Longrightarrow> real (time (mergesort_tm f x))\n                                     \\<le> mergesort_recurrence (length x);\n        \\<And>va vd x y ve.\n           \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n            vd = Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n            (x, y) = vd; ve = Time_Monad.val (mergesort_tm f x)\\<rbrakk>\n           \\<Longrightarrow> real (time (mergesort_tm f y))\n                             \\<le> mergesort_recurrence (length y)\\<rbrakk>\n       \\<Longrightarrow> real (time (mergesort_tm f (v # vb # vc)))\n                         \\<le> mergesort_recurrence (length (v # vb # vc))", "hence IH: \"time (mergesort_tm f l) \\<le> mergesort_recurrence (nat \\<lfloor>real n / 2\\<rfloor>)\"\n            \"time (mergesort_tm f r) \\<le> mergesort_recurrence (nat \\<lceil>real n / 2\\<rceil>)\""], ["proof (prove)\nusing this:\n  nat \\<lfloor>real n / 2\\<rfloor> = length l\n  nat \\<lceil>real n / 2\\<rceil> = length r\n\ngoal (1 subgoal):\n 1. real (time (mergesort_tm f l))\n    \\<le> mergesort_recurrence (nat \\<lfloor>real n / 2\\<rfloor>) &&&\n    real (time (mergesort_tm f r))\n    \\<le> mergesort_recurrence (nat \\<lceil>real n / 2\\<rceil>)", "using IHL IHR"], ["proof (prove)\nusing this:\n  nat \\<lfloor>real n / 2\\<rfloor> = length l\n  nat \\<lceil>real n / 2\\<rceil> = length r\n  real (time (mergesort_tm f l)) \\<le> mergesort_recurrence (length l)\n  real (time (mergesort_tm f r)) \\<le> mergesort_recurrence (length r)\n\ngoal (1 subgoal):\n 1. real (time (mergesort_tm f l))\n    \\<le> mergesort_recurrence (nat \\<lfloor>real n / 2\\<rfloor>) &&&\n    real (time (mergesort_tm f r))\n    \\<le> mergesort_recurrence (nat \\<lceil>real n / 2\\<rceil>)", "by simp_all"], ["proof (state)\nthis:\n  real (time (mergesort_tm f l))\n  \\<le> mergesort_recurrence (nat \\<lfloor>real n / 2\\<rfloor>)\n  real (time (mergesort_tm f r))\n  \\<le> mergesort_recurrence (nat \\<lceil>real n / 2\\<rceil>)\n\ngoal (1 subgoal):\n 1. \\<And>f v vb vc.\n       \\<lbrakk>\\<And>va vd x y.\n                   \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n                    vd =\n                    Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n                    (x, y) = vd\\<rbrakk>\n                   \\<Longrightarrow> real (time (mergesort_tm f x))\n                                     \\<le> mergesort_recurrence (length x);\n        \\<And>va vd x y ve.\n           \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n            vd = Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n            (x, y) = vd; ve = Time_Monad.val (mergesort_tm f x)\\<rbrakk>\n           \\<Longrightarrow> real (time (mergesort_tm f y))\n                             \\<le> mergesort_recurrence (length y)\\<rbrakk>\n       \\<Longrightarrow> real (time (mergesort_tm f (v # vb # vc)))\n                         \\<le> mergesort_recurrence (length (v # vb # vc))", "have \"n = length l + length r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = length l + length r", "using *"], ["proof (prove)\nusing this:\n  length l = n div 2\n  length r = n - n div 2\n\ngoal (1 subgoal):\n 1. n = length l + length r", "by linarith"], ["proof (state)\nthis:\n  n = length l + length r\n\ngoal (1 subgoal):\n 1. \\<And>f v vb vc.\n       \\<lbrakk>\\<And>va vd x y.\n                   \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n                    vd =\n                    Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n                    (x, y) = vd\\<rbrakk>\n                   \\<Longrightarrow> real (time (mergesort_tm f x))\n                                     \\<le> mergesort_recurrence (length x);\n        \\<And>va vd x y ve.\n           \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n            vd = Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n            (x, y) = vd; ve = Time_Monad.val (mergesort_tm f x)\\<rbrakk>\n           \\<Longrightarrow> real (time (mergesort_tm f y))\n                             \\<le> mergesort_recurrence (length y)\\<rbrakk>\n       \\<Longrightarrow> real (time (mergesort_tm f (v # vb # vc)))\n                         \\<le> mergesort_recurrence (length (v # vb # vc))", "hence \"time (merge_tm f l' r') \\<le> n + 1\""], ["proof (prove)\nusing this:\n  n = length l + length r\n\ngoal (1 subgoal):\n 1. time (merge_tm f l' r') \\<le> n + 1", "using time_merge_tm defs"], ["proof (prove)\nusing this:\n  n = length l + length r\n  time (merge_tm ?f ?xs ?ys) \\<le> length ?xs + length ?ys + 1\n  xs = x # y # xs'\n  n = length xs\n  (l, r) = split_at (n div 2) xs\n  l' = mergesort f l\n  r' = mergesort f r\n\ngoal (1 subgoal):\n 1. time (merge_tm f l' r') \\<le> n + 1", "by (metis length_mergesort)"], ["proof (state)\nthis:\n  time (merge_tm f l' r') \\<le> n + 1\n\ngoal (1 subgoal):\n 1. \\<And>f v vb vc.\n       \\<lbrakk>\\<And>va vd x y.\n                   \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n                    vd =\n                    Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n                    (x, y) = vd\\<rbrakk>\n                   \\<Longrightarrow> real (time (mergesort_tm f x))\n                                     \\<le> mergesort_recurrence (length x);\n        \\<And>va vd x y ve.\n           \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n            vd = Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n            (x, y) = vd; ve = Time_Monad.val (mergesort_tm f x)\\<rbrakk>\n           \\<Longrightarrow> real (time (mergesort_tm f y))\n                             \\<le> mergesort_recurrence (length y)\\<rbrakk>\n       \\<Longrightarrow> real (time (mergesort_tm f (v # vb # vc)))\n                         \\<le> mergesort_recurrence (length (v # vb # vc))", "have \"time (mergesort_tm f xs) = 1 + time (length_tm xs) + time (split_at_tm (n div 2) xs) + \n          time (mergesort_tm f l) + time (mergesort_tm f r) + time (merge_tm f l' r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. time (mergesort_tm f xs) =\n    1 + time (length_tm xs) + time (split_at_tm (n div 2) xs) +\n    time (mergesort_tm f l) +\n    time (mergesort_tm f r) +\n    time (merge_tm f l' r')", "using defs"], ["proof (prove)\nusing this:\n  xs = x # y # xs'\n  n = length xs\n  (l, r) = split_at (n div 2) xs\n  l' = mergesort f l\n  r' = mergesort f r\n\ngoal (1 subgoal):\n 1. time (mergesort_tm f xs) =\n    1 + time (length_tm xs) + time (split_at_tm (n div 2) xs) +\n    time (mergesort_tm f l) +\n    time (mergesort_tm f r) +\n    time (merge_tm f l' r')", "by (auto simp add: time_simps length_eq_val_length_tm  mergesort_eq_val_mergesort_tm \n                                  split_at_eq_val_split_at_tm \n                        split: prod.split)"], ["proof (state)\nthis:\n  time (mergesort_tm f xs) =\n  1 + time (length_tm xs) + time (split_at_tm (n div 2) xs) +\n  time (mergesort_tm f l) +\n  time (mergesort_tm f r) +\n  time (merge_tm f l' r')\n\ngoal (1 subgoal):\n 1. \\<And>f v vb vc.\n       \\<lbrakk>\\<And>va vd x y.\n                   \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n                    vd =\n                    Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n                    (x, y) = vd\\<rbrakk>\n                   \\<Longrightarrow> real (time (mergesort_tm f x))\n                                     \\<le> mergesort_recurrence (length x);\n        \\<And>va vd x y ve.\n           \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n            vd = Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n            (x, y) = vd; ve = Time_Monad.val (mergesort_tm f x)\\<rbrakk>\n           \\<Longrightarrow> real (time (mergesort_tm f y))\n                             \\<le> mergesort_recurrence (length y)\\<rbrakk>\n       \\<Longrightarrow> real (time (mergesort_tm f (v # vb # vc)))\n                         \\<le> mergesort_recurrence (length (v # vb # vc))", "also"], ["proof (state)\nthis:\n  time (mergesort_tm f xs) =\n  1 + time (length_tm xs) + time (split_at_tm (n div 2) xs) +\n  time (mergesort_tm f l) +\n  time (mergesort_tm f r) +\n  time (merge_tm f l' r')\n\ngoal (1 subgoal):\n 1. \\<And>f v vb vc.\n       \\<lbrakk>\\<And>va vd x y.\n                   \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n                    vd =\n                    Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n                    (x, y) = vd\\<rbrakk>\n                   \\<Longrightarrow> real (time (mergesort_tm f x))\n                                     \\<le> mergesort_recurrence (length x);\n        \\<And>va vd x y ve.\n           \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n            vd = Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n            (x, y) = vd; ve = Time_Monad.val (mergesort_tm f x)\\<rbrakk>\n           \\<Longrightarrow> real (time (mergesort_tm f y))\n                             \\<le> mergesort_recurrence (length y)\\<rbrakk>\n       \\<Longrightarrow> real (time (mergesort_tm f (v # vb # vc)))\n                         \\<le> mergesort_recurrence (length (v # vb # vc))", "have \"... \\<le> 4 + 3 * n + time (mergesort_tm f l) + time (mergesort_tm f r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + time (length_tm xs) + time (split_at_tm (n div 2) xs) +\n    time (mergesort_tm f l) +\n    time (mergesort_tm f r) +\n    time (merge_tm f l' r')\n    \\<le> 4 + 3 * n + time (mergesort_tm f l) + time (mergesort_tm f r)", "using time_length_tm[of xs] time_split_at_tm[of \"n div 2\" xs] n_def \\<open>time (merge_tm f l' r') \\<le> n + 1\\<close>"], ["proof (prove)\nusing this:\n  time (length_tm xs) = length xs + 1\n  time (split_at_tm (n div 2) xs) = min (n div 2) (length xs) + 1\n  n = length xs\n  time (merge_tm f l' r') \\<le> n + 1\n\ngoal (1 subgoal):\n 1. 1 + time (length_tm xs) + time (split_at_tm (n div 2) xs) +\n    time (mergesort_tm f l) +\n    time (mergesort_tm f r) +\n    time (merge_tm f l' r')\n    \\<le> 4 + 3 * n + time (mergesort_tm f l) + time (mergesort_tm f r)", "by simp"], ["proof (state)\nthis:\n  1 + time (length_tm xs) + time (split_at_tm (n div 2) xs) +\n  time (mergesort_tm f l) +\n  time (mergesort_tm f r) +\n  time (merge_tm f l' r')\n  \\<le> 4 + 3 * n + time (mergesort_tm f l) + time (mergesort_tm f r)\n\ngoal (1 subgoal):\n 1. \\<And>f v vb vc.\n       \\<lbrakk>\\<And>va vd x y.\n                   \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n                    vd =\n                    Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n                    (x, y) = vd\\<rbrakk>\n                   \\<Longrightarrow> real (time (mergesort_tm f x))\n                                     \\<le> mergesort_recurrence (length x);\n        \\<And>va vd x y ve.\n           \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n            vd = Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n            (x, y) = vd; ve = Time_Monad.val (mergesort_tm f x)\\<rbrakk>\n           \\<Longrightarrow> real (time (mergesort_tm f y))\n                             \\<le> mergesort_recurrence (length y)\\<rbrakk>\n       \\<Longrightarrow> real (time (mergesort_tm f (v # vb # vc)))\n                         \\<le> mergesort_recurrence (length (v # vb # vc))", "also"], ["proof (state)\nthis:\n  1 + time (length_tm xs) + time (split_at_tm (n div 2) xs) +\n  time (mergesort_tm f l) +\n  time (mergesort_tm f r) +\n  time (merge_tm f l' r')\n  \\<le> 4 + 3 * n + time (mergesort_tm f l) + time (mergesort_tm f r)\n\ngoal (1 subgoal):\n 1. \\<And>f v vb vc.\n       \\<lbrakk>\\<And>va vd x y.\n                   \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n                    vd =\n                    Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n                    (x, y) = vd\\<rbrakk>\n                   \\<Longrightarrow> real (time (mergesort_tm f x))\n                                     \\<le> mergesort_recurrence (length x);\n        \\<And>va vd x y ve.\n           \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n            vd = Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n            (x, y) = vd; ve = Time_Monad.val (mergesort_tm f x)\\<rbrakk>\n           \\<Longrightarrow> real (time (mergesort_tm f y))\n                             \\<le> mergesort_recurrence (length y)\\<rbrakk>\n       \\<Longrightarrow> real (time (mergesort_tm f (v # vb # vc)))\n                         \\<le> mergesort_recurrence (length (v # vb # vc))", "have \"... \\<le> 4 + 3 * n + mergesort_recurrence (nat \\<lfloor>real n / 2\\<rfloor>) + mergesort_recurrence (nat \\<lceil>real n / 2\\<rceil>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (4 + 3 * n + time (mergesort_tm f l) + time (mergesort_tm f r))\n    \\<le> real (4 + 3 * n) +\n          mergesort_recurrence (nat \\<lfloor>real n / 2\\<rfloor>) +\n          mergesort_recurrence (nat \\<lceil>real n / 2\\<rceil>)", "using IH"], ["proof (prove)\nusing this:\n  real (time (mergesort_tm f l))\n  \\<le> mergesort_recurrence (nat \\<lfloor>real n / 2\\<rfloor>)\n  real (time (mergesort_tm f r))\n  \\<le> mergesort_recurrence (nat \\<lceil>real n / 2\\<rceil>)\n\ngoal (1 subgoal):\n 1. real (4 + 3 * n + time (mergesort_tm f l) + time (mergesort_tm f r))\n    \\<le> real (4 + 3 * n) +\n          mergesort_recurrence (nat \\<lfloor>real n / 2\\<rfloor>) +\n          mergesort_recurrence (nat \\<lceil>real n / 2\\<rceil>)", "by simp"], ["proof (state)\nthis:\n  real (4 + 3 * n + time (mergesort_tm f l) + time (mergesort_tm f r))\n  \\<le> real (4 + 3 * n) +\n        mergesort_recurrence (nat \\<lfloor>real n / 2\\<rfloor>) +\n        mergesort_recurrence (nat \\<lceil>real n / 2\\<rceil>)\n\ngoal (1 subgoal):\n 1. \\<And>f v vb vc.\n       \\<lbrakk>\\<And>va vd x y.\n                   \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n                    vd =\n                    Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n                    (x, y) = vd\\<rbrakk>\n                   \\<Longrightarrow> real (time (mergesort_tm f x))\n                                     \\<le> mergesort_recurrence (length x);\n        \\<And>va vd x y ve.\n           \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n            vd = Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n            (x, y) = vd; ve = Time_Monad.val (mergesort_tm f x)\\<rbrakk>\n           \\<Longrightarrow> real (time (mergesort_tm f y))\n                             \\<le> mergesort_recurrence (length y)\\<rbrakk>\n       \\<Longrightarrow> real (time (mergesort_tm f (v # vb # vc)))\n                         \\<le> mergesort_recurrence (length (v # vb # vc))", "also"], ["proof (state)\nthis:\n  real (4 + 3 * n + time (mergesort_tm f l) + time (mergesort_tm f r))\n  \\<le> real (4 + 3 * n) +\n        mergesort_recurrence (nat \\<lfloor>real n / 2\\<rfloor>) +\n        mergesort_recurrence (nat \\<lceil>real n / 2\\<rceil>)\n\ngoal (1 subgoal):\n 1. \\<And>f v vb vc.\n       \\<lbrakk>\\<And>va vd x y.\n                   \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n                    vd =\n                    Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n                    (x, y) = vd\\<rbrakk>\n                   \\<Longrightarrow> real (time (mergesort_tm f x))\n                                     \\<le> mergesort_recurrence (length x);\n        \\<And>va vd x y ve.\n           \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n            vd = Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n            (x, y) = vd; ve = Time_Monad.val (mergesort_tm f x)\\<rbrakk>\n           \\<Longrightarrow> real (time (mergesort_tm f y))\n                             \\<le> mergesort_recurrence (length y)\\<rbrakk>\n       \\<Longrightarrow> real (time (mergesort_tm f (v # vb # vc)))\n                         \\<le> mergesort_recurrence (length (v # vb # vc))", "have \"... = mergesort_recurrence n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (4 + 3 * n) +\n    mergesort_recurrence (nat \\<lfloor>real n / 2\\<rfloor>) +\n    mergesort_recurrence (nat \\<lceil>real n / 2\\<rceil>) =\n    mergesort_recurrence n", "using defs"], ["proof (prove)\nusing this:\n  xs = x # y # xs'\n  n = length xs\n  (l, r) = split_at (n div 2) xs\n  l' = mergesort f l\n  r' = mergesort f r\n\ngoal (1 subgoal):\n 1. real (4 + 3 * n) +\n    mergesort_recurrence (nat \\<lfloor>real n / 2\\<rfloor>) +\n    mergesort_recurrence (nat \\<lceil>real n / 2\\<rceil>) =\n    mergesort_recurrence n", "by simp"], ["proof (state)\nthis:\n  real (4 + 3 * n) +\n  mergesort_recurrence (nat \\<lfloor>real n / 2\\<rfloor>) +\n  mergesort_recurrence (nat \\<lceil>real n / 2\\<rceil>) =\n  mergesort_recurrence n\n\ngoal (1 subgoal):\n 1. \\<And>f v vb vc.\n       \\<lbrakk>\\<And>va vd x y.\n                   \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n                    vd =\n                    Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n                    (x, y) = vd\\<rbrakk>\n                   \\<Longrightarrow> real (time (mergesort_tm f x))\n                                     \\<le> mergesort_recurrence (length x);\n        \\<And>va vd x y ve.\n           \\<lbrakk>va = Time_Monad.val (length_tm (v # vb # vc));\n            vd = Time_Monad.val (split_at_tm (va div 2) (v # vb # vc));\n            (x, y) = vd; ve = Time_Monad.val (mergesort_tm f x)\\<rbrakk>\n           \\<Longrightarrow> real (time (mergesort_tm f y))\n                             \\<le> mergesort_recurrence (length y)\\<rbrakk>\n       \\<Longrightarrow> real (time (mergesort_tm f (v # vb # vc)))\n                         \\<le> mergesort_recurrence (length (v # vb # vc))", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow> real x \\<le> real y) \\<Longrightarrow>\n  real (time (mergesort_tm f xs)) \\<le> mergesort_recurrence n", "show ?case"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow> real x \\<le> real y) \\<Longrightarrow>\n  real (time (mergesort_tm f xs)) \\<le> mergesort_recurrence n\n\ngoal (1 subgoal):\n 1. real (time (mergesort_tm f (x # y # xs')))\n    \\<le> mergesort_recurrence (length (x # y # xs'))", "using defs"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow> real x \\<le> real y) \\<Longrightarrow>\n  real (time (mergesort_tm f xs)) \\<le> mergesort_recurrence n\n  xs = x # y # xs'\n  n = length xs\n  (l, r) = split_at (n div 2) xs\n  l' = mergesort f l\n  r' = mergesort f r\n\ngoal (1 subgoal):\n 1. real (time (mergesort_tm f (x # y # xs')))\n    \\<le> mergesort_recurrence (length (x # y # xs'))", "by simp"], ["proof (state)\nthis:\n  real (time (mergesort_tm f (x # y # xs')))\n  \\<le> mergesort_recurrence (length (x # y # xs'))\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem mergesort_recurrence:\n  \"mergesort_recurrence \\<in> \\<Theta>(\\<lambda>n. n * ln n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mergesort_recurrence \\<in> \\<Theta>(\\<lambda>x. real x * ln (real x))", "by (master_theorem) auto"], ["", "theorem time_mergesort_tm_bigo:\n  \"(\\<lambda>xs. time (mergesort_tm f xs)) \\<in> O[length going_to at_top]((\\<lambda>n. n * ln n) o length)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. real (time (mergesort_tm f x)))\n    \\<in> O[length going_to\n            sequentially]((\\<lambda>n. real n * ln (real n)) \\<circ> length)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>x. real (time (mergesort_tm f x)))\n    \\<in> O[length going_to\n            sequentially]((\\<lambda>n. real n * ln (real n)) \\<circ> length)", "have 0: \"\\<And>xs. time (mergesort_tm f xs) \\<le> (mergesort_recurrence o length) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       real (time (mergesort_tm f xs))\n       \\<le> (mergesort_recurrence \\<circ> length) xs", "unfolding comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       real (time (mergesort_tm f xs))\n       \\<le> mergesort_recurrence (length xs)", "using time_mergesort_conv_mergesort_recurrence"], ["proof (prove)\nusing this:\n  real (time (mergesort_tm ?f ?xs)) \\<le> mergesort_recurrence (length ?xs)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       real (time (mergesort_tm f xs))\n       \\<le> mergesort_recurrence (length xs)", "by blast"], ["proof (state)\nthis:\n  real (time (mergesort_tm f ?xs))\n  \\<le> (mergesort_recurrence \\<circ> length) ?xs\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. real (time (mergesort_tm f x)))\n    \\<in> O[length going_to\n            sequentially]((\\<lambda>n. real n * ln (real n)) \\<circ> length)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. real (time (mergesort_tm f x)))\n    \\<in> O[length going_to\n            sequentially]((\\<lambda>n. real n * ln (real n)) \\<circ> length)", "using bigo_measure_trans[OF 0]"], ["proof (prove)\nusing this:\n  \\<lbrakk>mergesort_recurrence \\<in> O(?f);\n   \\<And>x.\n      x \\<in> ?A \\<Longrightarrow>\n      0 \\<le> real (time (mergesort_tm f x))\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>x. real (time (mergesort_tm f x)))\n                    \\<in> O[length going_to sequentially\n                           within ?A](?f \\<circ> length)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. real (time (mergesort_tm f x)))\n    \\<in> O[length going_to\n            sequentially]((\\<lambda>n. real n * ln (real n)) \\<circ> length)", "by (simp add: bigthetaD1 mergesort_recurrence)"], ["proof (state)\nthis:\n  (\\<lambda>x. real (time (mergesort_tm f x)))\n  \\<in> O[length going_to\n          sequentially]((\\<lambda>n. real n * ln (real n)) \\<circ> length)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"Code Export\""], ["", "lemma merge_xs_Nil[simp]:\n  \"merge f xs [] = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Common.merge f xs [] = xs", "by (cases xs) auto"], ["", "fun merge_it' :: \"('b \\<Rightarrow> 'a::linorder) \\<Rightarrow> 'b list \\<Rightarrow> 'b list \\<Rightarrow> 'b list \\<Rightarrow> 'b list\" where\n  \"merge_it' f acc [] [] = rev acc\"\n| \"merge_it' f acc (x#xs) [] = merge_it' f (x#acc) xs []\"\n| \"merge_it' f acc [] (y#ys) = merge_it' f (y#acc) ys []\"\n| \"merge_it' f acc (x#xs) (y#ys) = (\n    if f x \\<le> f y then\n      merge_it' f (x#acc) xs (y#ys)\n    else\n      merge_it' f (y#acc) (x#xs) ys\n  )\""], ["", "definition merge_it :: \"('b \\<Rightarrow> 'a::linorder) \\<Rightarrow> 'b list \\<Rightarrow> 'b list \\<Rightarrow> 'b list\" where\n  \"merge_it f xs ys = merge_it' f [] xs ys\""], ["", "lemma merge_conv_merge_it':\n  \"rev acc @ merge f xs ys = merge_it' f acc xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev acc @ Common.merge f xs ys = merge_it' f acc xs ys", "by (induction f acc xs ys rule: merge_it'.induct) auto"], ["", "lemma merge_conv_merge_it[code_unfold]:\n  \"merge f xs ys = merge_it f xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Common.merge f xs ys = merge_it f xs ys", "unfolding merge_it_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Common.merge f xs ys = merge_it' f [] xs ys", "using merge_conv_merge_it' rev.simps(1) append_Nil"], ["proof (prove)\nusing this:\n  rev ?acc @ Common.merge ?f ?xs ?ys = merge_it' ?f ?acc ?xs ?ys\n  rev [] = []\n  [] @ ?ys = ?ys\n\ngoal (1 subgoal):\n 1. Common.merge f xs ys = merge_it' f [] xs ys", "by metis"], ["", "subsection \"Minimal Distance\""], ["", "definition sparse :: \"real \\<Rightarrow> point set \\<Rightarrow> bool\" where\n  \"sparse \\<delta> ps \\<longleftrightarrow> (\\<forall>p\\<^sub>0 \\<in> ps. \\<forall>p\\<^sub>1 \\<in> ps. p\\<^sub>0 \\<noteq> p\\<^sub>1 \\<longrightarrow> \\<delta> \\<le> dist p\\<^sub>0 p\\<^sub>1)\""], ["", "lemma sparse_identity:\n  assumes \"sparse \\<delta> (set ps)\" \"\\<forall>p \\<in> set ps. \\<delta> \\<le> dist p\\<^sub>0 p\"\n  shows \"sparse \\<delta> (set (p\\<^sub>0 # ps))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sparse \\<delta> (set (p\\<^sub>0 # ps))", "using assms"], ["proof (prove)\nusing this:\n  sparse \\<delta> (set ps)\n  \\<forall>p\\<in>set ps.\n     \\<delta>\n     \\<le> dist\n            (case p\\<^sub>0 of\n             (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n            (case p of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n\ngoal (1 subgoal):\n 1. sparse \\<delta> (set (p\\<^sub>0 # ps))", "by (simp add: dist_commute sparse_def)"], ["", "lemma sparse_update:\n  assumes \"sparse \\<delta> (set ps)\"\n  assumes \"dist p\\<^sub>0 p\\<^sub>1 \\<le> \\<delta>\" \"\\<forall>p \\<in> set ps. dist p\\<^sub>0 p\\<^sub>1 \\<le> dist p\\<^sub>0 p\"\n  shows \"sparse (dist p\\<^sub>0 p\\<^sub>1) (set (p\\<^sub>0 # ps))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sparse\n     (dist\n       (case p\\<^sub>0 of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n       p\\<^sub>1)\n     (set (p\\<^sub>0 # ps))", "using assms"], ["proof (prove)\nusing this:\n  sparse \\<delta> (set ps)\n  dist\n   (case p\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n   p\\<^sub>1\n  \\<le> \\<delta>\n  \\<forall>p\\<in>set ps.\n     dist\n      (case p\\<^sub>0 of\n       (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n      p\\<^sub>1\n     \\<le> dist\n            (case p\\<^sub>0 of\n             (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n            (case p of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n\ngoal (1 subgoal):\n 1. sparse\n     (dist\n       (case p\\<^sub>0 of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n       p\\<^sub>1)\n     (set (p\\<^sub>0 # ps))", "by (auto simp: dist_commute sparse_def, force+)"], ["", "lemma sparse_mono:\n  \"sparse \\<Delta> P \\<Longrightarrow> \\<delta> \\<le> \\<Delta> \\<Longrightarrow> sparse \\<delta> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sparse \\<Delta> P; \\<delta> \\<le> \\<Delta>\\<rbrakk>\n    \\<Longrightarrow> sparse \\<delta> P", "unfolding sparse_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>p\\<^sub>0\\<in>P.\n                \\<forall>p\\<^sub>1\\<in>P.\n                   p\\<^sub>0 \\<noteq> p\\<^sub>1 \\<longrightarrow>\n                   \\<Delta>\n                   \\<le> dist\n                          (case p\\<^sub>0 of\n                           (x, y) \\<Rightarrow>\n                             (real_of_int x, real_of_int y))\n                          (case p\\<^sub>1 of\n                           (x, y) \\<Rightarrow>\n                             (real_of_int x, real_of_int y));\n     \\<delta> \\<le> \\<Delta>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p\\<^sub>0\\<in>P.\n                         \\<forall>p\\<^sub>1\\<in>P.\n                            p\\<^sub>0 \\<noteq> p\\<^sub>1 \\<longrightarrow>\n                            \\<delta>\n                            \\<le> dist\n                                   (case p\\<^sub>0 of\n                                    (x, y) \\<Rightarrow>\n(real_of_int x, real_of_int y))\n                                   (case p\\<^sub>1 of\n                                    (x, y) \\<Rightarrow>\n(real_of_int x, real_of_int y))", "by fastforce"], ["", "subsection \"Distance\""], ["", "lemma dist_transform:\n  fixes p :: point and \\<delta> :: real and l :: int\n  shows \"dist p (l, snd p) < \\<delta> \\<longleftrightarrow> l - \\<delta> < fst p \\<and> fst p < l + \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (dist (case p of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n      (case (l, snd p) of\n       (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     < \\<delta>) =\n    (real_of_int l - \\<delta> < real_of_int (fst p) \\<and>\n     real_of_int (fst p) < real_of_int l + \\<delta>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (dist (case p of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n      (case (l, snd p) of\n       (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     < \\<delta>) =\n    (real_of_int l - \\<delta> < real_of_int (fst p) \\<and>\n     real_of_int (fst p) < real_of_int l + \\<delta>)", "have \"dist p (l, snd p) = sqrt ((real_of_int (fst p) - l)\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (case p of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     (case (l, snd p) of\n      (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)) =\n    sqrt ((real_of_int (fst p) - real_of_int l)\\<^sup>2)", "by (auto simp add: dist_prod_def dist_real_def prod.case_eq_if)"], ["proof (state)\nthis:\n  dist (case p of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n   (case (l, snd p) of\n    (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)) =\n  sqrt ((real_of_int (fst p) - real_of_int l)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. (dist (case p of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n      (case (l, snd p) of\n       (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     < \\<delta>) =\n    (real_of_int l - \\<delta> < real_of_int (fst p) \\<and>\n     real_of_int (fst p) < real_of_int l + \\<delta>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  dist (case p of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n   (case (l, snd p) of\n    (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)) =\n  sqrt ((real_of_int (fst p) - real_of_int l)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. (dist (case p of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n      (case (l, snd p) of\n       (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     < \\<delta>) =\n    (real_of_int l - \\<delta> < real_of_int (fst p) \\<and>\n     real_of_int (fst p) < real_of_int l + \\<delta>)", "by auto"], ["proof (state)\nthis:\n  (dist (case p of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n    (case (l, snd p) of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n   < \\<delta>) =\n  (real_of_int l - \\<delta> < real_of_int (fst p) \\<and>\n   real_of_int (fst p) < real_of_int l + \\<delta>)\n\ngoal:\nNo subgoals!", "qed"], ["", "fun dist_code :: \"point \\<Rightarrow> point \\<Rightarrow> int\" where\n  \"dist_code p\\<^sub>0 p\\<^sub>1 = (fst p\\<^sub>0 - fst p\\<^sub>1)\\<^sup>2 + (snd p\\<^sub>0 - snd p\\<^sub>1)\\<^sup>2\""], ["", "lemma dist_eq_sqrt_dist_code:\n  fixes p\\<^sub>0 :: point\n  shows \"dist p\\<^sub>0 p\\<^sub>1 = sqrt (dist_code p\\<^sub>0 p\\<^sub>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist\n     (case p\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     (case p\\<^sub>1 of\n      (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)) =\n    sqrt (real_of_int (dist_code p\\<^sub>0 p\\<^sub>1))", "by (auto simp: dist_prod_def dist_real_def split: prod.splits)"], ["", "lemma dist_eq_dist_code_lt:\n  fixes p\\<^sub>0 :: point\n  shows \"dist p\\<^sub>0 p\\<^sub>1 < dist p\\<^sub>2 p\\<^sub>3 \\<longleftrightarrow> dist_code p\\<^sub>0 p\\<^sub>1 < dist_code p\\<^sub>2 p\\<^sub>3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (dist\n      (case p\\<^sub>0 of\n       (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n      (case p\\<^sub>1 of\n       (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     < dist\n        (case p\\<^sub>2 of\n         (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n        (case p\\<^sub>3 of\n         (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))) =\n    (dist_code p\\<^sub>0 p\\<^sub>1 < dist_code p\\<^sub>2 p\\<^sub>3)", "using dist_eq_sqrt_dist_code real_sqrt_less_iff"], ["proof (prove)\nusing this:\n  dist\n   (case ?p\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n   (case ?p\\<^sub>1 of\n    (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)) =\n  sqrt (real_of_int (dist_code ?p\\<^sub>0 ?p\\<^sub>1))\n  (sqrt ?x < sqrt ?y) = (?x < ?y)\n\ngoal (1 subgoal):\n 1. (dist\n      (case p\\<^sub>0 of\n       (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n      (case p\\<^sub>1 of\n       (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     < dist\n        (case p\\<^sub>2 of\n         (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n        (case p\\<^sub>3 of\n         (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))) =\n    (dist_code p\\<^sub>0 p\\<^sub>1 < dist_code p\\<^sub>2 p\\<^sub>3)", "by presburger"], ["", "lemma dist_eq_dist_code_le:\n  fixes p\\<^sub>0 :: point\n  shows \"dist p\\<^sub>0 p\\<^sub>1 \\<le> dist p\\<^sub>2 p\\<^sub>3 \\<longleftrightarrow> dist_code p\\<^sub>0 p\\<^sub>1 \\<le> dist_code p\\<^sub>2 p\\<^sub>3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (dist\n      (case p\\<^sub>0 of\n       (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n      (case p\\<^sub>1 of\n       (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     \\<le> dist\n            (case p\\<^sub>2 of\n             (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n            (case p\\<^sub>3 of\n             (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))) =\n    (dist_code p\\<^sub>0 p\\<^sub>1 \\<le> dist_code p\\<^sub>2 p\\<^sub>3)", "using dist_eq_sqrt_dist_code real_sqrt_le_iff"], ["proof (prove)\nusing this:\n  dist\n   (case ?p\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n   (case ?p\\<^sub>1 of\n    (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)) =\n  sqrt (real_of_int (dist_code ?p\\<^sub>0 ?p\\<^sub>1))\n  (sqrt ?x \\<le> sqrt ?y) = (?x \\<le> ?y)\n\ngoal (1 subgoal):\n 1. (dist\n      (case p\\<^sub>0 of\n       (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n      (case p\\<^sub>1 of\n       (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     \\<le> dist\n            (case p\\<^sub>2 of\n             (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n            (case p\\<^sub>3 of\n             (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))) =\n    (dist_code p\\<^sub>0 p\\<^sub>1 \\<le> dist_code p\\<^sub>2 p\\<^sub>3)", "by presburger"], ["", "lemma dist_eq_dist_code_abs_lt:\n  fixes p\\<^sub>0 :: point\n  shows \"\\<bar>c\\<bar> < dist p\\<^sub>0 p\\<^sub>1 \\<longleftrightarrow> c\\<^sup>2 < dist_code p\\<^sub>0 p\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<bar>real_of_int c\\<bar>\n     < dist\n        (case p\\<^sub>0 of\n         (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n        (case p\\<^sub>1 of\n         (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))) =\n    (c\\<^sup>2 < dist_code p\\<^sub>0 p\\<^sub>1)", "using dist_eq_sqrt_dist_code"], ["proof (prove)\nusing this:\n  dist\n   (case ?p\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n   (case ?p\\<^sub>1 of\n    (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)) =\n  sqrt (real_of_int (dist_code ?p\\<^sub>0 ?p\\<^sub>1))\n\ngoal (1 subgoal):\n 1. (\\<bar>real_of_int c\\<bar>\n     < dist\n        (case p\\<^sub>0 of\n         (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n        (case p\\<^sub>1 of\n         (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))) =\n    (c\\<^sup>2 < dist_code p\\<^sub>0 p\\<^sub>1)", "by (metis of_int_less_of_int_power_cancel_iff real_sqrt_abs real_sqrt_less_iff)"], ["", "lemma dist_eq_dist_code_abs_le:\n  fixes p\\<^sub>0 :: point\n  shows \"dist p\\<^sub>0 p\\<^sub>1 \\<le> \\<bar>c\\<bar> \\<longleftrightarrow> dist_code p\\<^sub>0 p\\<^sub>1 \\<le> c\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (dist\n      (case p\\<^sub>0 of\n       (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n      (case p\\<^sub>1 of\n       (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     \\<le> \\<bar>real_of_int c\\<bar>) =\n    (dist_code p\\<^sub>0 p\\<^sub>1 \\<le> c\\<^sup>2)", "using dist_eq_sqrt_dist_code"], ["proof (prove)\nusing this:\n  dist\n   (case ?p\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n   (case ?p\\<^sub>1 of\n    (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)) =\n  sqrt (real_of_int (dist_code ?p\\<^sub>0 ?p\\<^sub>1))\n\ngoal (1 subgoal):\n 1. (dist\n      (case p\\<^sub>0 of\n       (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n      (case p\\<^sub>1 of\n       (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     \\<le> \\<bar>real_of_int c\\<bar>) =\n    (dist_code p\\<^sub>0 p\\<^sub>1 \\<le> c\\<^sup>2)", "by (metis of_int_power_le_of_int_cancel_iff real_sqrt_abs real_sqrt_le_iff)"], ["", "lemma dist_fst_abs:\n  fixes p :: point and l :: int\n  shows \"dist p (l, snd p) = \\<bar>fst p - l\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (case p of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     (case (l, snd p) of\n      (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)) =\n    real_of_int \\<bar>fst p - l\\<bar>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dist (case p of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     (case (l, snd p) of\n      (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)) =\n    real_of_int \\<bar>fst p - l\\<bar>", "have \"dist p (l, snd p) = sqrt ((real_of_int (fst p) - l)\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (case p of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     (case (l, snd p) of\n      (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)) =\n    sqrt ((real_of_int (fst p) - real_of_int l)\\<^sup>2)", "by (simp add: dist_prod_def dist_real_def prod.case_eq_if)"], ["proof (state)\nthis:\n  dist (case p of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n   (case (l, snd p) of\n    (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)) =\n  sqrt ((real_of_int (fst p) - real_of_int l)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. dist (case p of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     (case (l, snd p) of\n      (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)) =\n    real_of_int \\<bar>fst p - l\\<bar>", "thus ?thesis"], ["proof (prove)\nusing this:\n  dist (case p of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n   (case (l, snd p) of\n    (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)) =\n  sqrt ((real_of_int (fst p) - real_of_int l)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. dist (case p of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     (case (l, snd p) of\n      (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)) =\n    real_of_int \\<bar>fst p - l\\<bar>", "by simp"], ["proof (state)\nthis:\n  dist (case p of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n   (case (l, snd p) of\n    (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)) =\n  real_of_int \\<bar>fst p - l\\<bar>\n\ngoal:\nNo subgoals!", "qed"], ["", "declare dist_code.simps [simp del]"], ["", "subsection \"Brute Force Closest Pair Algorithm\""], ["", "subsubsection \"Functional Correctness Proof\""], ["", "fun find_closest_bf_tm :: \"point \\<Rightarrow> point list \\<Rightarrow> point tm\" where\n  \"find_closest_bf_tm _ [] =1 return undefined\"\n| \"find_closest_bf_tm _ [p] =1 return p\"\n| \"find_closest_bf_tm p (p\\<^sub>0 # ps) =1 (\n    do {\n      p\\<^sub>1 <- find_closest_bf_tm p ps;\n      if dist p p\\<^sub>0 < dist p p\\<^sub>1 then\n        return p\\<^sub>0\n      else\n        return p\\<^sub>1\n    }\n  )\""], ["", "fun find_closest_bf :: \"point \\<Rightarrow> point list \\<Rightarrow> point\" where\n  \"find_closest_bf _ [] = undefined\"\n| \"find_closest_bf _ [p] = p\"\n| \"find_closest_bf p (p\\<^sub>0 # ps) = (\n    let p\\<^sub>1 = find_closest_bf p ps in\n    if dist p p\\<^sub>0 < dist p p\\<^sub>1 then\n      p\\<^sub>0\n    else\n      p\\<^sub>1\n  )\""], ["", "lemma find_closest_bf_eq_val_find_closest_bf_tm:\n  \"val (find_closest_bf_tm p ps) = find_closest_bf p ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Time_Monad.val (find_closest_bf_tm p ps) = find_closest_bf p ps", "by (induction p ps rule: find_closest_bf.induct) (auto simp: Let_def)"], ["", "lemma find_closest_bf_set:\n  \"0 < length ps \\<Longrightarrow> find_closest_bf p ps \\<in> set ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length ps \\<Longrightarrow> find_closest_bf p ps \\<in> set ps", "by (induction p ps rule: find_closest_bf.induct)\n     (auto simp: Let_def split: prod.splits if_splits)"], ["", "lemma find_closest_bf_dist:\n  \"\\<forall>q \\<in> set ps. dist p (find_closest_bf p ps) \\<le> dist p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>set ps.\n       dist (case p of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n        (case find_closest_bf p ps of\n         (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n       \\<le> dist\n              (case p of\n               (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n              (case q of\n               (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))", "by (induction p ps rule: find_closest_bf.induct)\n     (auto split: prod.splits)"], ["", "fun closest_pair_bf_tm :: \"point list \\<Rightarrow> (point \\<times> point) tm\" where\n  \"closest_pair_bf_tm [] =1 return undefined\"\n| \"closest_pair_bf_tm [_] =1 return undefined\"\n| \"closest_pair_bf_tm [p\\<^sub>0, p\\<^sub>1] =1 return (p\\<^sub>0, p\\<^sub>1)\"\n| \"closest_pair_bf_tm (p\\<^sub>0 # ps) =1 (\n    do {\n      (c\\<^sub>0::point, c\\<^sub>1::point) <- closest_pair_bf_tm ps;\n      p\\<^sub>1 <- find_closest_bf_tm p\\<^sub>0 ps;\n      if dist c\\<^sub>0 c\\<^sub>1 \\<le> dist p\\<^sub>0 p\\<^sub>1 then\n        return (c\\<^sub>0, c\\<^sub>1)\n      else\n        return (p\\<^sub>0, p\\<^sub>1)\n    }\n  )\""], ["", "fun closest_pair_bf :: \"point list \\<Rightarrow> (point * point)\" where\n  \"closest_pair_bf [] = undefined\"\n| \"closest_pair_bf [_] = undefined\"\n| \"closest_pair_bf [p\\<^sub>0, p\\<^sub>1] = (p\\<^sub>0, p\\<^sub>1)\"\n| \"closest_pair_bf (p\\<^sub>0 # ps) = (\n    let (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf ps in\n    let p\\<^sub>1 = find_closest_bf p\\<^sub>0 ps in\n    if dist c\\<^sub>0 c\\<^sub>1 \\<le> dist p\\<^sub>0 p\\<^sub>1 then\n      (c\\<^sub>0, c\\<^sub>1)\n    else\n      (p\\<^sub>0, p\\<^sub>1) \n  )\""], ["", "lemma closest_pair_bf_eq_val_closest_pair_bf_tm:\n  \"val (closest_pair_bf_tm ps) = closest_pair_bf ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Time_Monad.val (closest_pair_bf_tm ps) = closest_pair_bf ps", "by (induction ps rule: closest_pair_bf.induct) \n     (auto simp: Let_def find_closest_bf_eq_val_find_closest_bf_tm split: prod.split)"], ["", "lemma closest_pair_bf_c0:\n  \"1 < length ps \\<Longrightarrow> (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf ps \\<Longrightarrow> c\\<^sub>0 \\<in> set ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < length ps;\n     (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf ps\\<rbrakk>\n    \\<Longrightarrow> c\\<^sub>0 \\<in> set ps", "by (induction ps arbitrary: c\\<^sub>0 c\\<^sub>1 rule: closest_pair_bf.induct)\n     (auto simp: Let_def find_closest_bf_set split: if_splits prod.splits)"], ["", "lemma closest_pair_bf_c1:\n  \"1 < length ps \\<Longrightarrow> (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf ps \\<Longrightarrow> c\\<^sub>1 \\<in> set ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < length ps;\n     (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf ps\\<rbrakk>\n    \\<Longrightarrow> c\\<^sub>1 \\<in> set ps", "proof (induction ps arbitrary: c\\<^sub>0 c\\<^sub>1 rule: closest_pair_bf.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf []\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<in> set []\n 2. \\<And>uu_ c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [uu_];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [uu_]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<in> set [uu_]\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<in> set [p\\<^sub>0, p\\<^sub>1]\n 4. \\<And>p\\<^sub>0 v vb vc c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>\\<And>c\\<^sub>0 c\\<^sub>1.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    (c\\<^sub>0, c\\<^sub>1) =\n                    closest_pair_bf (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> c\\<^sub>1 \\<in> set (v # vb # vc);\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<in> set (p\\<^sub>0 # v # vb # vc)", "case (4 p\\<^sub>0 p\\<^sub>2 p\\<^sub>3 ps)"], ["proof (state)\nthis:\n  \\<lbrakk>1 < length (p\\<^sub>2 # p\\<^sub>3 # ps);\n   (?c\\<^sub>0, ?c\\<^sub>1) =\n   closest_pair_bf (p\\<^sub>2 # p\\<^sub>3 # ps)\\<rbrakk>\n  \\<Longrightarrow> ?c\\<^sub>1 \\<in> set (p\\<^sub>2 # p\\<^sub>3 # ps)\n  1 < length (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps)\n  (c\\<^sub>0, c\\<^sub>1) =\n  closest_pair_bf (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps)\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf []\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<in> set []\n 2. \\<And>uu_ c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [uu_];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [uu_]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<in> set [uu_]\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<in> set [p\\<^sub>0, p\\<^sub>1]\n 4. \\<And>p\\<^sub>0 v vb vc c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>\\<And>c\\<^sub>0 c\\<^sub>1.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    (c\\<^sub>0, c\\<^sub>1) =\n                    closest_pair_bf (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> c\\<^sub>1 \\<in> set (v # vb # vc);\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<in> set (p\\<^sub>0 # v # vb # vc)", "let ?ps = \"p\\<^sub>2 # p\\<^sub>3 # ps\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf []\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<in> set []\n 2. \\<And>uu_ c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [uu_];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [uu_]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<in> set [uu_]\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<in> set [p\\<^sub>0, p\\<^sub>1]\n 4. \\<And>p\\<^sub>0 v vb vc c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>\\<And>c\\<^sub>0 c\\<^sub>1.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    (c\\<^sub>0, c\\<^sub>1) =\n                    closest_pair_bf (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> c\\<^sub>1 \\<in> set (v # vb # vc);\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<in> set (p\\<^sub>0 # v # vb # vc)", "obtain c\\<^sub>0 c\\<^sub>1 where c\\<^sub>0_def: \"(c\\<^sub>0, c\\<^sub>1) = closest_pair_bf ?ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c\\<^sub>0 c\\<^sub>1.\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf (p\\<^sub>2 # p\\<^sub>3 # ps) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using prod.collapse"], ["proof (prove)\nusing this:\n  (fst ?prod, snd ?prod) = ?prod\n\ngoal (1 subgoal):\n 1. (\\<And>c\\<^sub>0 c\\<^sub>1.\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf (p\\<^sub>2 # p\\<^sub>3 # ps) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (p\\<^sub>2 # p\\<^sub>3 # ps)\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf []\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<in> set []\n 2. \\<And>uu_ c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [uu_];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [uu_]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<in> set [uu_]\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<in> set [p\\<^sub>0, p\\<^sub>1]\n 4. \\<And>p\\<^sub>0 v vb vc c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>\\<And>c\\<^sub>0 c\\<^sub>1.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    (c\\<^sub>0, c\\<^sub>1) =\n                    closest_pair_bf (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> c\\<^sub>1 \\<in> set (v # vb # vc);\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<in> set (p\\<^sub>0 # v # vb # vc)", "define p\\<^sub>1 where p\\<^sub>1_def: \"p\\<^sub>1 = find_closest_bf p\\<^sub>0 ?ps\""], ["proof (state)\nthis:\n  p\\<^sub>1 = find_closest_bf p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps)\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf []\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<in> set []\n 2. \\<And>uu_ c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [uu_];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [uu_]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<in> set [uu_]\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<in> set [p\\<^sub>0, p\\<^sub>1]\n 4. \\<And>p\\<^sub>0 v vb vc c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>\\<And>c\\<^sub>0 c\\<^sub>1.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    (c\\<^sub>0, c\\<^sub>1) =\n                    closest_pair_bf (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> c\\<^sub>1 \\<in> set (v # vb # vc);\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<in> set (p\\<^sub>0 # v # vb # vc)", "note defs = c\\<^sub>0_def p\\<^sub>1_def"], ["proof (state)\nthis:\n  (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (p\\<^sub>2 # p\\<^sub>3 # ps)\n  p\\<^sub>1 = find_closest_bf p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps)\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf []\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<in> set []\n 2. \\<And>uu_ c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [uu_];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [uu_]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<in> set [uu_]\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<in> set [p\\<^sub>0, p\\<^sub>1]\n 4. \\<And>p\\<^sub>0 v vb vc c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>\\<And>c\\<^sub>0 c\\<^sub>1.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    (c\\<^sub>0, c\\<^sub>1) =\n                    closest_pair_bf (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> c\\<^sub>1 \\<in> set (v # vb # vc);\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<in> set (p\\<^sub>0 # v # vb # vc)", "have \"c\\<^sub>1 \\<in> set ?ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sub>1 \\<in> set (p\\<^sub>2 # p\\<^sub>3 # ps)", "using \"4.IH\" defs"], ["proof (prove)\nusing this:\n  \\<lbrakk>1 < length (p\\<^sub>2 # p\\<^sub>3 # ps);\n   (?c\\<^sub>0, ?c\\<^sub>1) =\n   closest_pair_bf (p\\<^sub>2 # p\\<^sub>3 # ps)\\<rbrakk>\n  \\<Longrightarrow> ?c\\<^sub>1 \\<in> set (p\\<^sub>2 # p\\<^sub>3 # ps)\n  (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (p\\<^sub>2 # p\\<^sub>3 # ps)\n  p\\<^sub>1 = find_closest_bf p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps)\n\ngoal (1 subgoal):\n 1. c\\<^sub>1 \\<in> set (p\\<^sub>2 # p\\<^sub>3 # ps)", "by simp"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<in> set (p\\<^sub>2 # p\\<^sub>3 # ps)\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf []\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<in> set []\n 2. \\<And>uu_ c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [uu_];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [uu_]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<in> set [uu_]\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<in> set [p\\<^sub>0, p\\<^sub>1]\n 4. \\<And>p\\<^sub>0 v vb vc c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>\\<And>c\\<^sub>0 c\\<^sub>1.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    (c\\<^sub>0, c\\<^sub>1) =\n                    closest_pair_bf (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> c\\<^sub>1 \\<in> set (v # vb # vc);\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<in> set (p\\<^sub>0 # v # vb # vc)", "moreover"], ["proof (state)\nthis:\n  c\\<^sub>1 \\<in> set (p\\<^sub>2 # p\\<^sub>3 # ps)\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf []\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<in> set []\n 2. \\<And>uu_ c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [uu_];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [uu_]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<in> set [uu_]\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<in> set [p\\<^sub>0, p\\<^sub>1]\n 4. \\<And>p\\<^sub>0 v vb vc c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>\\<And>c\\<^sub>0 c\\<^sub>1.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    (c\\<^sub>0, c\\<^sub>1) =\n                    closest_pair_bf (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> c\\<^sub>1 \\<in> set (v # vb # vc);\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<in> set (p\\<^sub>0 # v # vb # vc)", "have \"p\\<^sub>1 \\<in> set ?ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p\\<^sub>1 \\<in> set (p\\<^sub>2 # p\\<^sub>3 # ps)", "using find_closest_bf_set defs"], ["proof (prove)\nusing this:\n  0 < length ?ps \\<Longrightarrow> find_closest_bf ?p ?ps \\<in> set ?ps\n  (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (p\\<^sub>2 # p\\<^sub>3 # ps)\n  p\\<^sub>1 = find_closest_bf p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps)\n\ngoal (1 subgoal):\n 1. p\\<^sub>1 \\<in> set (p\\<^sub>2 # p\\<^sub>3 # ps)", "by blast"], ["proof (state)\nthis:\n  p\\<^sub>1 \\<in> set (p\\<^sub>2 # p\\<^sub>3 # ps)\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf []\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<in> set []\n 2. \\<And>uu_ c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [uu_];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [uu_]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<in> set [uu_]\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<in> set [p\\<^sub>0, p\\<^sub>1]\n 4. \\<And>p\\<^sub>0 v vb vc c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>\\<And>c\\<^sub>0 c\\<^sub>1.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    (c\\<^sub>0, c\\<^sub>1) =\n                    closest_pair_bf (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> c\\<^sub>1 \\<in> set (v # vb # vc);\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<in> set (p\\<^sub>0 # v # vb # vc)", "ultimately"], ["proof (chain)\npicking this:\n  c\\<^sub>1 \\<in> set (p\\<^sub>2 # p\\<^sub>3 # ps)\n  p\\<^sub>1 \\<in> set (p\\<^sub>2 # p\\<^sub>3 # ps)", "show ?case"], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<in> set (p\\<^sub>2 # p\\<^sub>3 # ps)\n  p\\<^sub>1 \\<in> set (p\\<^sub>2 # p\\<^sub>3 # ps)\n\ngoal (1 subgoal):\n 1. c\\<^sub>1'__ \\<in> set (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps)", "using \"4.prems\"(2) defs"], ["proof (prove)\nusing this:\n  c\\<^sub>1 \\<in> set (p\\<^sub>2 # p\\<^sub>3 # ps)\n  p\\<^sub>1 \\<in> set (p\\<^sub>2 # p\\<^sub>3 # ps)\n  (c\\<^sub>0'__, c\\<^sub>1'__) =\n  closest_pair_bf (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps)\n  (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (p\\<^sub>2 # p\\<^sub>3 # ps)\n  p\\<^sub>1 = find_closest_bf p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps)\n\ngoal (1 subgoal):\n 1. c\\<^sub>1'__ \\<in> set (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps)", "by (auto simp: Let_def split: prod.splits if_splits)"], ["proof (state)\nthis:\n  c\\<^sub>1'__ \\<in> set (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps)\n\ngoal (3 subgoals):\n 1. \\<And>c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf []\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<in> set []\n 2. \\<And>uu_ c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [uu_];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [uu_]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<in> set [uu_]\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 \\<in> set [p\\<^sub>0, p\\<^sub>1]", "qed auto"], ["", "lemma closest_pair_bf_c0_ne_c1:\n  \"1 < length ps \\<Longrightarrow> distinct ps \\<Longrightarrow> (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf ps \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < length ps; distinct ps;\n     (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf ps\\<rbrakk>\n    \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1", "proof (induction ps arbitrary: c\\<^sub>0 c\\<^sub>1 rule: closest_pair_bf.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length []; distinct [];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf []\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1\n 2. \\<And>uu_ c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [uu_]; distinct [uu_];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [uu_]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        distinct [p\\<^sub>0, p\\<^sub>1];\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1\n 4. \\<And>p\\<^sub>0 v vb vc c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>\\<And>c\\<^sub>0 c\\<^sub>1.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    distinct (v # vb # vc);\n                    (c\\<^sub>0, c\\<^sub>1) =\n                    closest_pair_bf (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1;\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        distinct (p\\<^sub>0 # v # vb # vc);\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1", "case (4 p\\<^sub>0 p\\<^sub>2 p\\<^sub>3 ps)"], ["proof (state)\nthis:\n  \\<lbrakk>1 < length (p\\<^sub>2 # p\\<^sub>3 # ps);\n   distinct (p\\<^sub>2 # p\\<^sub>3 # ps);\n   (?c\\<^sub>0, ?c\\<^sub>1) =\n   closest_pair_bf (p\\<^sub>2 # p\\<^sub>3 # ps)\\<rbrakk>\n  \\<Longrightarrow> ?c\\<^sub>0 \\<noteq> ?c\\<^sub>1\n  1 < length (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps)\n  distinct (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps)\n  (c\\<^sub>0, c\\<^sub>1) =\n  closest_pair_bf (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps)\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length []; distinct [];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf []\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1\n 2. \\<And>uu_ c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [uu_]; distinct [uu_];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [uu_]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        distinct [p\\<^sub>0, p\\<^sub>1];\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1\n 4. \\<And>p\\<^sub>0 v vb vc c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>\\<And>c\\<^sub>0 c\\<^sub>1.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    distinct (v # vb # vc);\n                    (c\\<^sub>0, c\\<^sub>1) =\n                    closest_pair_bf (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1;\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        distinct (p\\<^sub>0 # v # vb # vc);\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1", "let ?ps = \"p\\<^sub>2 # p\\<^sub>3 # ps\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length []; distinct [];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf []\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1\n 2. \\<And>uu_ c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [uu_]; distinct [uu_];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [uu_]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        distinct [p\\<^sub>0, p\\<^sub>1];\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1\n 4. \\<And>p\\<^sub>0 v vb vc c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>\\<And>c\\<^sub>0 c\\<^sub>1.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    distinct (v # vb # vc);\n                    (c\\<^sub>0, c\\<^sub>1) =\n                    closest_pair_bf (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1;\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        distinct (p\\<^sub>0 # v # vb # vc);\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1", "obtain c\\<^sub>0 c\\<^sub>1 where c\\<^sub>0_def: \"(c\\<^sub>0, c\\<^sub>1) = closest_pair_bf ?ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c\\<^sub>0 c\\<^sub>1.\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf (p\\<^sub>2 # p\\<^sub>3 # ps) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using prod.collapse"], ["proof (prove)\nusing this:\n  (fst ?prod, snd ?prod) = ?prod\n\ngoal (1 subgoal):\n 1. (\\<And>c\\<^sub>0 c\\<^sub>1.\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf (p\\<^sub>2 # p\\<^sub>3 # ps) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (p\\<^sub>2 # p\\<^sub>3 # ps)\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length []; distinct [];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf []\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1\n 2. \\<And>uu_ c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [uu_]; distinct [uu_];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [uu_]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        distinct [p\\<^sub>0, p\\<^sub>1];\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1\n 4. \\<And>p\\<^sub>0 v vb vc c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>\\<And>c\\<^sub>0 c\\<^sub>1.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    distinct (v # vb # vc);\n                    (c\\<^sub>0, c\\<^sub>1) =\n                    closest_pair_bf (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1;\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        distinct (p\\<^sub>0 # v # vb # vc);\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1", "define p\\<^sub>1 where p\\<^sub>1_def: \"p\\<^sub>1 = find_closest_bf p\\<^sub>0 ?ps\""], ["proof (state)\nthis:\n  p\\<^sub>1 = find_closest_bf p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps)\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length []; distinct [];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf []\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1\n 2. \\<And>uu_ c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [uu_]; distinct [uu_];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [uu_]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        distinct [p\\<^sub>0, p\\<^sub>1];\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1\n 4. \\<And>p\\<^sub>0 v vb vc c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>\\<And>c\\<^sub>0 c\\<^sub>1.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    distinct (v # vb # vc);\n                    (c\\<^sub>0, c\\<^sub>1) =\n                    closest_pair_bf (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1;\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        distinct (p\\<^sub>0 # v # vb # vc);\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1", "note defs = c\\<^sub>0_def p\\<^sub>1_def"], ["proof (state)\nthis:\n  (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (p\\<^sub>2 # p\\<^sub>3 # ps)\n  p\\<^sub>1 = find_closest_bf p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps)\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length []; distinct [];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf []\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1\n 2. \\<And>uu_ c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [uu_]; distinct [uu_];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [uu_]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        distinct [p\\<^sub>0, p\\<^sub>1];\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1\n 4. \\<And>p\\<^sub>0 v vb vc c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>\\<And>c\\<^sub>0 c\\<^sub>1.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    distinct (v # vb # vc);\n                    (c\\<^sub>0, c\\<^sub>1) =\n                    closest_pair_bf (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1;\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        distinct (p\\<^sub>0 # v # vb # vc);\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1", "have \"c\\<^sub>0 \\<noteq> c\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sub>0 \\<noteq> c\\<^sub>1", "using \"4.IH\" \"4.prems\"(2) defs"], ["proof (prove)\nusing this:\n  \\<lbrakk>1 < length (p\\<^sub>2 # p\\<^sub>3 # ps);\n   distinct (p\\<^sub>2 # p\\<^sub>3 # ps);\n   (?c\\<^sub>0, ?c\\<^sub>1) =\n   closest_pair_bf (p\\<^sub>2 # p\\<^sub>3 # ps)\\<rbrakk>\n  \\<Longrightarrow> ?c\\<^sub>0 \\<noteq> ?c\\<^sub>1\n  distinct (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps)\n  (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (p\\<^sub>2 # p\\<^sub>3 # ps)\n  p\\<^sub>1 = find_closest_bf p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps)\n\ngoal (1 subgoal):\n 1. c\\<^sub>0 \\<noteq> c\\<^sub>1", "by simp"], ["proof (state)\nthis:\n  c\\<^sub>0 \\<noteq> c\\<^sub>1\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length []; distinct [];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf []\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1\n 2. \\<And>uu_ c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [uu_]; distinct [uu_];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [uu_]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        distinct [p\\<^sub>0, p\\<^sub>1];\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1\n 4. \\<And>p\\<^sub>0 v vb vc c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>\\<And>c\\<^sub>0 c\\<^sub>1.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    distinct (v # vb # vc);\n                    (c\\<^sub>0, c\\<^sub>1) =\n                    closest_pair_bf (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1;\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        distinct (p\\<^sub>0 # v # vb # vc);\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1", "moreover"], ["proof (state)\nthis:\n  c\\<^sub>0 \\<noteq> c\\<^sub>1\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length []; distinct [];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf []\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1\n 2. \\<And>uu_ c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [uu_]; distinct [uu_];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [uu_]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        distinct [p\\<^sub>0, p\\<^sub>1];\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1\n 4. \\<And>p\\<^sub>0 v vb vc c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>\\<And>c\\<^sub>0 c\\<^sub>1.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    distinct (v # vb # vc);\n                    (c\\<^sub>0, c\\<^sub>1) =\n                    closest_pair_bf (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1;\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        distinct (p\\<^sub>0 # v # vb # vc);\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1", "have \"p\\<^sub>0 \\<noteq> p\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p\\<^sub>0 \\<noteq> p\\<^sub>1", "using find_closest_bf_set \"4.prems\"(2) defs"], ["proof (prove)\nusing this:\n  0 < length ?ps \\<Longrightarrow> find_closest_bf ?p ?ps \\<in> set ?ps\n  distinct (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps)\n  (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (p\\<^sub>2 # p\\<^sub>3 # ps)\n  p\\<^sub>1 = find_closest_bf p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps)\n\ngoal (1 subgoal):\n 1. p\\<^sub>0 \\<noteq> p\\<^sub>1", "by (metis distinct.simps(2) length_pos_if_in_set list.set_intros(1))"], ["proof (state)\nthis:\n  p\\<^sub>0 \\<noteq> p\\<^sub>1\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length []; distinct [];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf []\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1\n 2. \\<And>uu_ c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [uu_]; distinct [uu_];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [uu_]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        distinct [p\\<^sub>0, p\\<^sub>1];\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1\n 4. \\<And>p\\<^sub>0 v vb vc c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>\\<And>c\\<^sub>0 c\\<^sub>1.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    distinct (v # vb # vc);\n                    (c\\<^sub>0, c\\<^sub>1) =\n                    closest_pair_bf (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1;\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        distinct (p\\<^sub>0 # v # vb # vc);\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1", "ultimately"], ["proof (chain)\npicking this:\n  c\\<^sub>0 \\<noteq> c\\<^sub>1\n  p\\<^sub>0 \\<noteq> p\\<^sub>1", "show ?case"], ["proof (prove)\nusing this:\n  c\\<^sub>0 \\<noteq> c\\<^sub>1\n  p\\<^sub>0 \\<noteq> p\\<^sub>1\n\ngoal (1 subgoal):\n 1. c\\<^sub>0'__ \\<noteq> c\\<^sub>1'__", "using \"4.prems\"(3) defs"], ["proof (prove)\nusing this:\n  c\\<^sub>0 \\<noteq> c\\<^sub>1\n  p\\<^sub>0 \\<noteq> p\\<^sub>1\n  (c\\<^sub>0'__, c\\<^sub>1'__) =\n  closest_pair_bf (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps)\n  (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (p\\<^sub>2 # p\\<^sub>3 # ps)\n  p\\<^sub>1 = find_closest_bf p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps)\n\ngoal (1 subgoal):\n 1. c\\<^sub>0'__ \\<noteq> c\\<^sub>1'__", "by (auto simp: Let_def split: prod.splits if_splits)"], ["proof (state)\nthis:\n  c\\<^sub>0'__ \\<noteq> c\\<^sub>1'__\n\ngoal (3 subgoals):\n 1. \\<And>c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length []; distinct [];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf []\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1\n 2. \\<And>uu_ c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [uu_]; distinct [uu_];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [uu_]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        distinct [p\\<^sub>0, p\\<^sub>1];\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 \\<noteq> c\\<^sub>1", "qed auto"], ["", "lemmas closest_pair_bf_c0_c1 = closest_pair_bf_c0 closest_pair_bf_c1 closest_pair_bf_c0_ne_c1"], ["", "lemma closest_pair_bf_dist:\n  assumes \"1 < length ps\" \"(c\\<^sub>0, c\\<^sub>1) = closest_pair_bf ps\"\n  shows \"sparse (dist c\\<^sub>0 c\\<^sub>1) (set ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sparse\n     (dist\n       (case c\\<^sub>0 of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n       (case c\\<^sub>1 of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n     (set ps)", "using assms"], ["proof (prove)\nusing this:\n  1 < length ps\n  (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf ps\n\ngoal (1 subgoal):\n 1. sparse\n     (dist\n       (case c\\<^sub>0 of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n       (case c\\<^sub>1 of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n     (set ps)", "proof (induction ps arbitrary: c\\<^sub>0 c\\<^sub>1 rule: closest_pair_bf.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf []\\<rbrakk>\n       \\<Longrightarrow> sparse\n                          (dist\n                            (case c\\<^sub>0 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y))\n                            (case c\\<^sub>1 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y)))\n                          (set [])\n 2. \\<And>uu_ c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [uu_];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [uu_]\\<rbrakk>\n       \\<Longrightarrow> sparse\n                          (dist\n                            (case c\\<^sub>0 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y))\n                            (case c\\<^sub>1 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y)))\n                          (set [uu_])\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> sparse\n                          (dist\n                            (case c\\<^sub>0 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y))\n                            (case c\\<^sub>1 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y)))\n                          (set [p\\<^sub>0, p\\<^sub>1])\n 4. \\<And>p\\<^sub>0 v vb vc c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>\\<And>c\\<^sub>0 c\\<^sub>1.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    (c\\<^sub>0, c\\<^sub>1) =\n                    closest_pair_bf (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> sparse\n(dist\n  (case c\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n  (case c\\<^sub>1 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n(set (v # vb # vc));\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> sparse\n                          (dist\n                            (case c\\<^sub>0 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y))\n                            (case c\\<^sub>1 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y)))\n                          (set (p\\<^sub>0 # v # vb # vc))", "case (4 p\\<^sub>0 p\\<^sub>2 p\\<^sub>3 ps)"], ["proof (state)\nthis:\n  \\<lbrakk>1 < length (p\\<^sub>2 # p\\<^sub>3 # ps);\n   (?c\\<^sub>0, ?c\\<^sub>1) =\n   closest_pair_bf (p\\<^sub>2 # p\\<^sub>3 # ps)\\<rbrakk>\n  \\<Longrightarrow> sparse\n                     (dist\n                       (case ?c\\<^sub>0 of\n                        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n                       (case ?c\\<^sub>1 of\n                        (x, y) \\<Rightarrow>\n                          (real_of_int x, real_of_int y)))\n                     (set (p\\<^sub>2 # p\\<^sub>3 # ps))\n  1 < length (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps)\n  (c\\<^sub>0, c\\<^sub>1) =\n  closest_pair_bf (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps)\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf []\\<rbrakk>\n       \\<Longrightarrow> sparse\n                          (dist\n                            (case c\\<^sub>0 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y))\n                            (case c\\<^sub>1 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y)))\n                          (set [])\n 2. \\<And>uu_ c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [uu_];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [uu_]\\<rbrakk>\n       \\<Longrightarrow> sparse\n                          (dist\n                            (case c\\<^sub>0 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y))\n                            (case c\\<^sub>1 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y)))\n                          (set [uu_])\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> sparse\n                          (dist\n                            (case c\\<^sub>0 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y))\n                            (case c\\<^sub>1 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y)))\n                          (set [p\\<^sub>0, p\\<^sub>1])\n 4. \\<And>p\\<^sub>0 v vb vc c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>\\<And>c\\<^sub>0 c\\<^sub>1.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    (c\\<^sub>0, c\\<^sub>1) =\n                    closest_pair_bf (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> sparse\n(dist\n  (case c\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n  (case c\\<^sub>1 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n(set (v # vb # vc));\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> sparse\n                          (dist\n                            (case c\\<^sub>0 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y))\n                            (case c\\<^sub>1 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y)))\n                          (set (p\\<^sub>0 # v # vb # vc))", "let ?ps = \"p\\<^sub>2 # p\\<^sub>3 # ps\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf []\\<rbrakk>\n       \\<Longrightarrow> sparse\n                          (dist\n                            (case c\\<^sub>0 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y))\n                            (case c\\<^sub>1 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y)))\n                          (set [])\n 2. \\<And>uu_ c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [uu_];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [uu_]\\<rbrakk>\n       \\<Longrightarrow> sparse\n                          (dist\n                            (case c\\<^sub>0 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y))\n                            (case c\\<^sub>1 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y)))\n                          (set [uu_])\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> sparse\n                          (dist\n                            (case c\\<^sub>0 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y))\n                            (case c\\<^sub>1 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y)))\n                          (set [p\\<^sub>0, p\\<^sub>1])\n 4. \\<And>p\\<^sub>0 v vb vc c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>\\<And>c\\<^sub>0 c\\<^sub>1.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    (c\\<^sub>0, c\\<^sub>1) =\n                    closest_pair_bf (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> sparse\n(dist\n  (case c\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n  (case c\\<^sub>1 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n(set (v # vb # vc));\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> sparse\n                          (dist\n                            (case c\\<^sub>0 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y))\n                            (case c\\<^sub>1 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y)))\n                          (set (p\\<^sub>0 # v # vb # vc))", "obtain c\\<^sub>0 c\\<^sub>1 where c\\<^sub>0_def: \"(c\\<^sub>0, c\\<^sub>1) = closest_pair_bf ?ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c\\<^sub>0 c\\<^sub>1.\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf (p\\<^sub>2 # p\\<^sub>3 # ps) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using prod.collapse"], ["proof (prove)\nusing this:\n  (fst ?prod, snd ?prod) = ?prod\n\ngoal (1 subgoal):\n 1. (\\<And>c\\<^sub>0 c\\<^sub>1.\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf (p\\<^sub>2 # p\\<^sub>3 # ps) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (p\\<^sub>2 # p\\<^sub>3 # ps)\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf []\\<rbrakk>\n       \\<Longrightarrow> sparse\n                          (dist\n                            (case c\\<^sub>0 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y))\n                            (case c\\<^sub>1 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y)))\n                          (set [])\n 2. \\<And>uu_ c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [uu_];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [uu_]\\<rbrakk>\n       \\<Longrightarrow> sparse\n                          (dist\n                            (case c\\<^sub>0 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y))\n                            (case c\\<^sub>1 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y)))\n                          (set [uu_])\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> sparse\n                          (dist\n                            (case c\\<^sub>0 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y))\n                            (case c\\<^sub>1 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y)))\n                          (set [p\\<^sub>0, p\\<^sub>1])\n 4. \\<And>p\\<^sub>0 v vb vc c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>\\<And>c\\<^sub>0 c\\<^sub>1.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    (c\\<^sub>0, c\\<^sub>1) =\n                    closest_pair_bf (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> sparse\n(dist\n  (case c\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n  (case c\\<^sub>1 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n(set (v # vb # vc));\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> sparse\n                          (dist\n                            (case c\\<^sub>0 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y))\n                            (case c\\<^sub>1 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y)))\n                          (set (p\\<^sub>0 # v # vb # vc))", "define p\\<^sub>1 where p\\<^sub>1_def: \"p\\<^sub>1 = find_closest_bf p\\<^sub>0 ?ps\""], ["proof (state)\nthis:\n  p\\<^sub>1 = find_closest_bf p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps)\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf []\\<rbrakk>\n       \\<Longrightarrow> sparse\n                          (dist\n                            (case c\\<^sub>0 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y))\n                            (case c\\<^sub>1 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y)))\n                          (set [])\n 2. \\<And>uu_ c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [uu_];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [uu_]\\<rbrakk>\n       \\<Longrightarrow> sparse\n                          (dist\n                            (case c\\<^sub>0 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y))\n                            (case c\\<^sub>1 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y)))\n                          (set [uu_])\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> sparse\n                          (dist\n                            (case c\\<^sub>0 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y))\n                            (case c\\<^sub>1 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y)))\n                          (set [p\\<^sub>0, p\\<^sub>1])\n 4. \\<And>p\\<^sub>0 v vb vc c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>\\<And>c\\<^sub>0 c\\<^sub>1.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    (c\\<^sub>0, c\\<^sub>1) =\n                    closest_pair_bf (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> sparse\n(dist\n  (case c\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n  (case c\\<^sub>1 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n(set (v # vb # vc));\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> sparse\n                          (dist\n                            (case c\\<^sub>0 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y))\n                            (case c\\<^sub>1 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y)))\n                          (set (p\\<^sub>0 # v # vb # vc))", "note defs = c\\<^sub>0_def p\\<^sub>1_def"], ["proof (state)\nthis:\n  (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (p\\<^sub>2 # p\\<^sub>3 # ps)\n  p\\<^sub>1 = find_closest_bf p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps)\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf []\\<rbrakk>\n       \\<Longrightarrow> sparse\n                          (dist\n                            (case c\\<^sub>0 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y))\n                            (case c\\<^sub>1 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y)))\n                          (set [])\n 2. \\<And>uu_ c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [uu_];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [uu_]\\<rbrakk>\n       \\<Longrightarrow> sparse\n                          (dist\n                            (case c\\<^sub>0 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y))\n                            (case c\\<^sub>1 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y)))\n                          (set [uu_])\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> sparse\n                          (dist\n                            (case c\\<^sub>0 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y))\n                            (case c\\<^sub>1 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y)))\n                          (set [p\\<^sub>0, p\\<^sub>1])\n 4. \\<And>p\\<^sub>0 v vb vc c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>\\<And>c\\<^sub>0 c\\<^sub>1.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    (c\\<^sub>0, c\\<^sub>1) =\n                    closest_pair_bf (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> sparse\n(dist\n  (case c\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n  (case c\\<^sub>1 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n(set (v # vb # vc));\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> sparse\n                          (dist\n                            (case c\\<^sub>0 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y))\n                            (case c\\<^sub>1 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y)))\n                          (set (p\\<^sub>0 # v # vb # vc))", "hence IH: \"sparse (dist c\\<^sub>0 c\\<^sub>1) (set ?ps)\""], ["proof (prove)\nusing this:\n  (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (p\\<^sub>2 # p\\<^sub>3 # ps)\n  p\\<^sub>1 = find_closest_bf p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps)\n\ngoal (1 subgoal):\n 1. sparse\n     (dist\n       (case c\\<^sub>0 of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n       (case c\\<^sub>1 of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n     (set (p\\<^sub>2 # p\\<^sub>3 # ps))", "using 4 c\\<^sub>0_def"], ["proof (prove)\nusing this:\n  (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (p\\<^sub>2 # p\\<^sub>3 # ps)\n  p\\<^sub>1 = find_closest_bf p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps)\n  \\<lbrakk>1 < length (p\\<^sub>2 # p\\<^sub>3 # ps);\n   (?c\\<^sub>0, ?c\\<^sub>1) =\n   closest_pair_bf (p\\<^sub>2 # p\\<^sub>3 # ps)\\<rbrakk>\n  \\<Longrightarrow> sparse\n                     (dist\n                       (case ?c\\<^sub>0 of\n                        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n                       (case ?c\\<^sub>1 of\n                        (x, y) \\<Rightarrow>\n                          (real_of_int x, real_of_int y)))\n                     (set (p\\<^sub>2 # p\\<^sub>3 # ps))\n  1 < length (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps)\n  (c\\<^sub>0'__, c\\<^sub>1'__) =\n  closest_pair_bf (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps)\n  (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (p\\<^sub>2 # p\\<^sub>3 # ps)\n\ngoal (1 subgoal):\n 1. sparse\n     (dist\n       (case c\\<^sub>0 of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n       (case c\\<^sub>1 of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n     (set (p\\<^sub>2 # p\\<^sub>3 # ps))", "by simp"], ["proof (state)\nthis:\n  sparse\n   (dist\n     (case c\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     (case c\\<^sub>1 of\n      (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n   (set (p\\<^sub>2 # p\\<^sub>3 # ps))\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf []\\<rbrakk>\n       \\<Longrightarrow> sparse\n                          (dist\n                            (case c\\<^sub>0 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y))\n                            (case c\\<^sub>1 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y)))\n                          (set [])\n 2. \\<And>uu_ c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [uu_];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [uu_]\\<rbrakk>\n       \\<Longrightarrow> sparse\n                          (dist\n                            (case c\\<^sub>0 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y))\n                            (case c\\<^sub>1 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y)))\n                          (set [uu_])\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> sparse\n                          (dist\n                            (case c\\<^sub>0 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y))\n                            (case c\\<^sub>1 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y)))\n                          (set [p\\<^sub>0, p\\<^sub>1])\n 4. \\<And>p\\<^sub>0 v vb vc c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>\\<And>c\\<^sub>0 c\\<^sub>1.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    (c\\<^sub>0, c\\<^sub>1) =\n                    closest_pair_bf (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> sparse\n(dist\n  (case c\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n  (case c\\<^sub>1 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n(set (v # vb # vc));\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> sparse\n                          (dist\n                            (case c\\<^sub>0 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y))\n                            (case c\\<^sub>1 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y)))\n                          (set (p\\<^sub>0 # v # vb # vc))", "have *: \"\\<forall>p \\<in> set ?ps. (dist p\\<^sub>0 p\\<^sub>1) \\<le> dist p\\<^sub>0 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set (p\\<^sub>2 # p\\<^sub>3 # ps).\n       dist\n        (case p\\<^sub>0 of\n         (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n        (case p\\<^sub>1 of\n         (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n       \\<le> dist\n              (case p\\<^sub>0 of\n               (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n              (case p of\n               (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))", "using find_closest_bf_dist defs"], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>set ?ps.\n     dist (case ?p of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n      (case find_closest_bf ?p ?ps of\n       (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     \\<le> dist\n            (case ?p of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n            (case q of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n  (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (p\\<^sub>2 # p\\<^sub>3 # ps)\n  p\\<^sub>1 = find_closest_bf p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps)\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set (p\\<^sub>2 # p\\<^sub>3 # ps).\n       dist\n        (case p\\<^sub>0 of\n         (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n        (case p\\<^sub>1 of\n         (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n       \\<le> dist\n              (case p\\<^sub>0 of\n               (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n              (case p of\n               (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))", "by blast"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set (p\\<^sub>2 # p\\<^sub>3 # ps).\n     dist\n      (case p\\<^sub>0 of\n       (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n      (case p\\<^sub>1 of\n       (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     \\<le> dist\n            (case p\\<^sub>0 of\n             (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n            (case p of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf []\\<rbrakk>\n       \\<Longrightarrow> sparse\n                          (dist\n                            (case c\\<^sub>0 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y))\n                            (case c\\<^sub>1 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y)))\n                          (set [])\n 2. \\<And>uu_ c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [uu_];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [uu_]\\<rbrakk>\n       \\<Longrightarrow> sparse\n                          (dist\n                            (case c\\<^sub>0 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y))\n                            (case c\\<^sub>1 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y)))\n                          (set [uu_])\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> sparse\n                          (dist\n                            (case c\\<^sub>0 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y))\n                            (case c\\<^sub>1 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y)))\n                          (set [p\\<^sub>0, p\\<^sub>1])\n 4. \\<And>p\\<^sub>0 v vb vc c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>\\<And>c\\<^sub>0 c\\<^sub>1.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    (c\\<^sub>0, c\\<^sub>1) =\n                    closest_pair_bf (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> sparse\n(dist\n  (case c\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n  (case c\\<^sub>1 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n(set (v # vb # vc));\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> sparse\n                          (dist\n                            (case c\\<^sub>0 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y))\n                            (case c\\<^sub>1 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y)))\n                          (set (p\\<^sub>0 # v # vb # vc))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sparse\n     (dist\n       (case c\\<^sub>0'__ of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n       (case c\\<^sub>1'__ of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n     (set (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps))", "proof (cases \"dist c\\<^sub>0 c\\<^sub>1 \\<le> dist p\\<^sub>0 p\\<^sub>1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. dist\n     (case c\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     (case c\\<^sub>1 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n    \\<le> dist\n           (case p\\<^sub>0 of\n            (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n           (case p\\<^sub>1 of\n            (x, y) \\<Rightarrow>\n              (real_of_int x, real_of_int y)) \\<Longrightarrow>\n    sparse\n     (dist\n       (case c\\<^sub>0'__ of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n       (case c\\<^sub>1'__ of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n     (set (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps))\n 2. \\<not> dist\n            (case c\\<^sub>0 of\n             (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n            (case c\\<^sub>1 of\n             (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n           \\<le> dist\n                  (case p\\<^sub>0 of\n                   (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n                  (case p\\<^sub>1 of\n                   (x, y) \\<Rightarrow>\n                     (real_of_int x, real_of_int y)) \\<Longrightarrow>\n    sparse\n     (dist\n       (case c\\<^sub>0'__ of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n       (case c\\<^sub>1'__ of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n     (set (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps))", "case True"], ["proof (state)\nthis:\n  dist\n   (case c\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n   (case c\\<^sub>1 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n  \\<le> dist\n         (case p\\<^sub>0 of\n          (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n         (case p\\<^sub>1 of\n          (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n\ngoal (2 subgoals):\n 1. dist\n     (case c\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     (case c\\<^sub>1 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n    \\<le> dist\n           (case p\\<^sub>0 of\n            (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n           (case p\\<^sub>1 of\n            (x, y) \\<Rightarrow>\n              (real_of_int x, real_of_int y)) \\<Longrightarrow>\n    sparse\n     (dist\n       (case c\\<^sub>0'__ of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n       (case c\\<^sub>1'__ of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n     (set (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps))\n 2. \\<not> dist\n            (case c\\<^sub>0 of\n             (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n            (case c\\<^sub>1 of\n             (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n           \\<le> dist\n                  (case p\\<^sub>0 of\n                   (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n                  (case p\\<^sub>1 of\n                   (x, y) \\<Rightarrow>\n                     (real_of_int x, real_of_int y)) \\<Longrightarrow>\n    sparse\n     (dist\n       (case c\\<^sub>0'__ of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n       (case c\\<^sub>1'__ of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n     (set (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps))", "hence \"\\<forall>p \\<in> set ?ps. dist c\\<^sub>0 c\\<^sub>1 \\<le> dist p\\<^sub>0 p\""], ["proof (prove)\nusing this:\n  dist\n   (case c\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n   (case c\\<^sub>1 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n  \\<le> dist\n         (case p\\<^sub>0 of\n          (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n         (case p\\<^sub>1 of\n          (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set (p\\<^sub>2 # p\\<^sub>3 # ps).\n       dist\n        (case c\\<^sub>0 of\n         (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n        (case c\\<^sub>1 of\n         (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n       \\<le> dist\n              (case p\\<^sub>0 of\n               (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n              (case p of\n               (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))", "using *"], ["proof (prove)\nusing this:\n  dist\n   (case c\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n   (case c\\<^sub>1 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n  \\<le> dist\n         (case p\\<^sub>0 of\n          (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n         (case p\\<^sub>1 of\n          (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n  \\<forall>p\\<in>set (p\\<^sub>2 # p\\<^sub>3 # ps).\n     dist\n      (case p\\<^sub>0 of\n       (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n      (case p\\<^sub>1 of\n       (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     \\<le> dist\n            (case p\\<^sub>0 of\n             (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n            (case p of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set (p\\<^sub>2 # p\\<^sub>3 # ps).\n       dist\n        (case c\\<^sub>0 of\n         (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n        (case c\\<^sub>1 of\n         (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n       \\<le> dist\n              (case p\\<^sub>0 of\n               (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n              (case p of\n               (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))", "by auto"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set (p\\<^sub>2 # p\\<^sub>3 # ps).\n     dist\n      (case c\\<^sub>0 of\n       (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n      (case c\\<^sub>1 of\n       (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     \\<le> dist\n            (case p\\<^sub>0 of\n             (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n            (case p of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n\ngoal (2 subgoals):\n 1. dist\n     (case c\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     (case c\\<^sub>1 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n    \\<le> dist\n           (case p\\<^sub>0 of\n            (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n           (case p\\<^sub>1 of\n            (x, y) \\<Rightarrow>\n              (real_of_int x, real_of_int y)) \\<Longrightarrow>\n    sparse\n     (dist\n       (case c\\<^sub>0'__ of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n       (case c\\<^sub>1'__ of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n     (set (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps))\n 2. \\<not> dist\n            (case c\\<^sub>0 of\n             (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n            (case c\\<^sub>1 of\n             (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n           \\<le> dist\n                  (case p\\<^sub>0 of\n                   (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n                  (case p\\<^sub>1 of\n                   (x, y) \\<Rightarrow>\n                     (real_of_int x, real_of_int y)) \\<Longrightarrow>\n    sparse\n     (dist\n       (case c\\<^sub>0'__ of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n       (case c\\<^sub>1'__ of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n     (set (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps))", "hence \"sparse (dist c\\<^sub>0 c\\<^sub>1) (set (p\\<^sub>0 # ?ps))\""], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set (p\\<^sub>2 # p\\<^sub>3 # ps).\n     dist\n      (case c\\<^sub>0 of\n       (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n      (case c\\<^sub>1 of\n       (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     \\<le> dist\n            (case p\\<^sub>0 of\n             (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n            (case p of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n\ngoal (1 subgoal):\n 1. sparse\n     (dist\n       (case c\\<^sub>0 of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n       (case c\\<^sub>1 of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n     (set (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps))", "using sparse_identity IH"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set (p\\<^sub>2 # p\\<^sub>3 # ps).\n     dist\n      (case c\\<^sub>0 of\n       (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n      (case c\\<^sub>1 of\n       (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     \\<le> dist\n            (case p\\<^sub>0 of\n             (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n            (case p of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n  \\<lbrakk>sparse ?\\<delta> (set ?ps);\n   \\<forall>p\\<in>set ?ps.\n      ?\\<delta>\n      \\<le> dist\n             (case ?p\\<^sub>0 of\n              (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n             (case p of\n              (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\\<rbrakk>\n  \\<Longrightarrow> sparse ?\\<delta> (set (?p\\<^sub>0 # ?ps))\n  sparse\n   (dist\n     (case c\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     (case c\\<^sub>1 of\n      (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n   (set (p\\<^sub>2 # p\\<^sub>3 # ps))\n\ngoal (1 subgoal):\n 1. sparse\n     (dist\n       (case c\\<^sub>0 of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n       (case c\\<^sub>1 of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n     (set (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps))", "by blast"], ["proof (state)\nthis:\n  sparse\n   (dist\n     (case c\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     (case c\\<^sub>1 of\n      (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n   (set (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps))\n\ngoal (2 subgoals):\n 1. dist\n     (case c\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     (case c\\<^sub>1 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n    \\<le> dist\n           (case p\\<^sub>0 of\n            (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n           (case p\\<^sub>1 of\n            (x, y) \\<Rightarrow>\n              (real_of_int x, real_of_int y)) \\<Longrightarrow>\n    sparse\n     (dist\n       (case c\\<^sub>0'__ of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n       (case c\\<^sub>1'__ of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n     (set (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps))\n 2. \\<not> dist\n            (case c\\<^sub>0 of\n             (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n            (case c\\<^sub>1 of\n             (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n           \\<le> dist\n                  (case p\\<^sub>0 of\n                   (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n                  (case p\\<^sub>1 of\n                   (x, y) \\<Rightarrow>\n                     (real_of_int x, real_of_int y)) \\<Longrightarrow>\n    sparse\n     (dist\n       (case c\\<^sub>0'__ of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n       (case c\\<^sub>1'__ of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n     (set (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps))", "thus ?thesis"], ["proof (prove)\nusing this:\n  sparse\n   (dist\n     (case c\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     (case c\\<^sub>1 of\n      (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n   (set (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps))\n\ngoal (1 subgoal):\n 1. sparse\n     (dist\n       (case c\\<^sub>0'__ of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n       (case c\\<^sub>1'__ of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n     (set (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps))", "using True \"4.prems\" defs"], ["proof (prove)\nusing this:\n  sparse\n   (dist\n     (case c\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     (case c\\<^sub>1 of\n      (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n   (set (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps))\n  dist\n   (case c\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n   (case c\\<^sub>1 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n  \\<le> dist\n         (case p\\<^sub>0 of\n          (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n         (case p\\<^sub>1 of\n          (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n  1 < length (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps)\n  (c\\<^sub>0'__, c\\<^sub>1'__) =\n  closest_pair_bf (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps)\n  (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (p\\<^sub>2 # p\\<^sub>3 # ps)\n  p\\<^sub>1 = find_closest_bf p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps)\n\ngoal (1 subgoal):\n 1. sparse\n     (dist\n       (case c\\<^sub>0'__ of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n       (case c\\<^sub>1'__ of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n     (set (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps))", "by (auto split: prod.splits)"], ["proof (state)\nthis:\n  sparse\n   (dist\n     (case c\\<^sub>0'__ of\n      (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     (case c\\<^sub>1'__ of\n      (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n   (set (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps))\n\ngoal (1 subgoal):\n 1. \\<not> dist\n            (case c\\<^sub>0 of\n             (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n            (case c\\<^sub>1 of\n             (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n           \\<le> dist\n                  (case p\\<^sub>0 of\n                   (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n                  (case p\\<^sub>1 of\n                   (x, y) \\<Rightarrow>\n                     (real_of_int x, real_of_int y)) \\<Longrightarrow>\n    sparse\n     (dist\n       (case c\\<^sub>0'__ of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n       (case c\\<^sub>1'__ of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n     (set (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> dist\n            (case c\\<^sub>0 of\n             (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n            (case c\\<^sub>1 of\n             (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n           \\<le> dist\n                  (case p\\<^sub>0 of\n                   (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n                  (case p\\<^sub>1 of\n                   (x, y) \\<Rightarrow>\n                     (real_of_int x, real_of_int y)) \\<Longrightarrow>\n    sparse\n     (dist\n       (case c\\<^sub>0'__ of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n       (case c\\<^sub>1'__ of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n     (set (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps))", "case False"], ["proof (state)\nthis:\n  \\<not> dist\n          (case c\\<^sub>0 of\n           (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n          (case c\\<^sub>1 of\n           (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n         \\<le> dist\n                (case p\\<^sub>0 of\n                 (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n                (case p\\<^sub>1 of\n                 (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n\ngoal (1 subgoal):\n 1. \\<not> dist\n            (case c\\<^sub>0 of\n             (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n            (case c\\<^sub>1 of\n             (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n           \\<le> dist\n                  (case p\\<^sub>0 of\n                   (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n                  (case p\\<^sub>1 of\n                   (x, y) \\<Rightarrow>\n                     (real_of_int x, real_of_int y)) \\<Longrightarrow>\n    sparse\n     (dist\n       (case c\\<^sub>0'__ of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n       (case c\\<^sub>1'__ of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n     (set (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps))", "hence \"sparse (dist p\\<^sub>0 p\\<^sub>1) (set (p\\<^sub>0 # ?ps))\""], ["proof (prove)\nusing this:\n  \\<not> dist\n          (case c\\<^sub>0 of\n           (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n          (case c\\<^sub>1 of\n           (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n         \\<le> dist\n                (case p\\<^sub>0 of\n                 (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n                (case p\\<^sub>1 of\n                 (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n\ngoal (1 subgoal):\n 1. sparse\n     (dist\n       (case p\\<^sub>0 of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n       (case p\\<^sub>1 of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n     (set (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps))", "using sparse_update[of \"dist c\\<^sub>0 c\\<^sub>1\" ?ps p\\<^sub>0 p\\<^sub>1] IH * defs"], ["proof (prove)\nusing this:\n  \\<not> dist\n          (case c\\<^sub>0 of\n           (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n          (case c\\<^sub>1 of\n           (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n         \\<le> dist\n                (case p\\<^sub>0 of\n                 (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n                (case p\\<^sub>1 of\n                 (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n  \\<lbrakk>sparse\n            (dist\n              (case c\\<^sub>0 of\n               (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n              (case c\\<^sub>1 of\n               (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n            (set (p\\<^sub>2 # p\\<^sub>3 # ps));\n   dist\n    (case p\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n    (case p\\<^sub>1 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n   \\<le> dist\n          (case c\\<^sub>0 of\n           (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n          (case c\\<^sub>1 of\n           (x, y) \\<Rightarrow> (real_of_int x, real_of_int y));\n   \\<forall>p\\<in>set (p\\<^sub>2 # p\\<^sub>3 # ps).\n      dist\n       (case p\\<^sub>0 of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n       (case p\\<^sub>1 of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n      \\<le> dist\n             (case p\\<^sub>0 of\n              (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n             (case p of\n              (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\\<rbrakk>\n  \\<Longrightarrow> sparse\n                     (dist\n                       (case p\\<^sub>0 of\n                        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n                       (case p\\<^sub>1 of\n                        (x, y) \\<Rightarrow>\n                          (real_of_int x, real_of_int y)))\n                     (set (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps))\n  sparse\n   (dist\n     (case c\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     (case c\\<^sub>1 of\n      (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n   (set (p\\<^sub>2 # p\\<^sub>3 # ps))\n  \\<forall>p\\<in>set (p\\<^sub>2 # p\\<^sub>3 # ps).\n     dist\n      (case p\\<^sub>0 of\n       (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n      (case p\\<^sub>1 of\n       (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     \\<le> dist\n            (case p\\<^sub>0 of\n             (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n            (case p of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n  (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (p\\<^sub>2 # p\\<^sub>3 # ps)\n  p\\<^sub>1 = find_closest_bf p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps)\n\ngoal (1 subgoal):\n 1. sparse\n     (dist\n       (case p\\<^sub>0 of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n       (case p\\<^sub>1 of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n     (set (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps))", "by argo"], ["proof (state)\nthis:\n  sparse\n   (dist\n     (case p\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     (case p\\<^sub>1 of\n      (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n   (set (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps))\n\ngoal (1 subgoal):\n 1. \\<not> dist\n            (case c\\<^sub>0 of\n             (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n            (case c\\<^sub>1 of\n             (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n           \\<le> dist\n                  (case p\\<^sub>0 of\n                   (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n                  (case p\\<^sub>1 of\n                   (x, y) \\<Rightarrow>\n                     (real_of_int x, real_of_int y)) \\<Longrightarrow>\n    sparse\n     (dist\n       (case c\\<^sub>0'__ of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n       (case c\\<^sub>1'__ of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n     (set (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps))", "thus ?thesis"], ["proof (prove)\nusing this:\n  sparse\n   (dist\n     (case p\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     (case p\\<^sub>1 of\n      (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n   (set (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps))\n\ngoal (1 subgoal):\n 1. sparse\n     (dist\n       (case c\\<^sub>0'__ of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n       (case c\\<^sub>1'__ of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n     (set (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps))", "using False \"4.prems\" defs"], ["proof (prove)\nusing this:\n  sparse\n   (dist\n     (case p\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     (case p\\<^sub>1 of\n      (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n   (set (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps))\n  \\<not> dist\n          (case c\\<^sub>0 of\n           (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n          (case c\\<^sub>1 of\n           (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n         \\<le> dist\n                (case p\\<^sub>0 of\n                 (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n                (case p\\<^sub>1 of\n                 (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n  1 < length (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps)\n  (c\\<^sub>0'__, c\\<^sub>1'__) =\n  closest_pair_bf (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps)\n  (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (p\\<^sub>2 # p\\<^sub>3 # ps)\n  p\\<^sub>1 = find_closest_bf p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps)\n\ngoal (1 subgoal):\n 1. sparse\n     (dist\n       (case c\\<^sub>0'__ of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n       (case c\\<^sub>1'__ of\n        (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n     (set (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps))", "by (auto split: prod.splits)"], ["proof (state)\nthis:\n  sparse\n   (dist\n     (case c\\<^sub>0'__ of\n      (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     (case c\\<^sub>1'__ of\n      (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n   (set (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sparse\n   (dist\n     (case c\\<^sub>0'__ of\n      (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     (case c\\<^sub>1'__ of\n      (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n   (set (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps))\n\ngoal (3 subgoals):\n 1. \\<And>c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf []\\<rbrakk>\n       \\<Longrightarrow> sparse\n                          (dist\n                            (case c\\<^sub>0 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y))\n                            (case c\\<^sub>1 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y)))\n                          (set [])\n 2. \\<And>uu_ c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [uu_];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [uu_]\\<rbrakk>\n       \\<Longrightarrow> sparse\n                          (dist\n                            (case c\\<^sub>0 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y))\n                            (case c\\<^sub>1 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y)))\n                          (set [uu_])\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        (c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> sparse\n                          (dist\n                            (case c\\<^sub>0 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y))\n                            (case c\\<^sub>1 of\n                             (x, y) \\<Rightarrow>\n                               (real_of_int x, real_of_int y)))\n                          (set [p\\<^sub>0, p\\<^sub>1])", "qed (auto simp: dist_commute sparse_def)"], ["", "subsubsection \"Time Complexity Proof\""], ["", "lemma time_find_closest_bf_tm:\n  \"time (find_closest_bf_tm p ps) \\<le> length ps + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. time (find_closest_bf_tm p ps) \\<le> length ps + 1", "by (induction p ps rule: find_closest_bf_tm.induct) (auto simp: time_simps)"], ["", "lemma time_closest_pair_bf_tm:\n  \"time (closest_pair_bf_tm ps) \\<le> length ps * length ps + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. time (closest_pair_bf_tm ps) \\<le> length ps * length ps + 1", "proof (induction ps rule: closest_pair_bf_tm.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. time (closest_pair_bf_tm []) \\<le> length [] * length [] + 1\n 2. \\<And>uu_.\n       time (closest_pair_bf_tm [uu_]) \\<le> length [uu_] * length [uu_] + 1\n 3. \\<And>p\\<^sub>0 p\\<^sub>1.\n       time (closest_pair_bf_tm [p\\<^sub>0, p\\<^sub>1])\n       \\<le> length [p\\<^sub>0, p\\<^sub>1] * length [p\\<^sub>0, p\\<^sub>1] +\n             1\n 4. \\<And>p\\<^sub>0 v vb vc.\n       time (closest_pair_bf_tm (v # vb # vc))\n       \\<le> length (v # vb # vc) * length (v # vb # vc) +\n             1 \\<Longrightarrow>\n       time (closest_pair_bf_tm (p\\<^sub>0 # v # vb # vc))\n       \\<le> length (p\\<^sub>0 # v # vb # vc) *\n             length (p\\<^sub>0 # v # vb # vc) +\n             1", "case (4 p\\<^sub>0 p\\<^sub>2 p\\<^sub>3 ps)"], ["proof (state)\nthis:\n  time (closest_pair_bf_tm (p\\<^sub>2 # p\\<^sub>3 # ps))\n  \\<le> length (p\\<^sub>2 # p\\<^sub>3 # ps) *\n        length (p\\<^sub>2 # p\\<^sub>3 # ps) +\n        1\n\ngoal (4 subgoals):\n 1. time (closest_pair_bf_tm []) \\<le> length [] * length [] + 1\n 2. \\<And>uu_.\n       time (closest_pair_bf_tm [uu_]) \\<le> length [uu_] * length [uu_] + 1\n 3. \\<And>p\\<^sub>0 p\\<^sub>1.\n       time (closest_pair_bf_tm [p\\<^sub>0, p\\<^sub>1])\n       \\<le> length [p\\<^sub>0, p\\<^sub>1] * length [p\\<^sub>0, p\\<^sub>1] +\n             1\n 4. \\<And>p\\<^sub>0 v vb vc.\n       time (closest_pair_bf_tm (v # vb # vc))\n       \\<le> length (v # vb # vc) * length (v # vb # vc) +\n             1 \\<Longrightarrow>\n       time (closest_pair_bf_tm (p\\<^sub>0 # v # vb # vc))\n       \\<le> length (p\\<^sub>0 # v # vb # vc) *\n             length (p\\<^sub>0 # v # vb # vc) +\n             1", "let ?ps = \"p\\<^sub>2 # p\\<^sub>3 # ps\""], ["proof (state)\ngoal (4 subgoals):\n 1. time (closest_pair_bf_tm []) \\<le> length [] * length [] + 1\n 2. \\<And>uu_.\n       time (closest_pair_bf_tm [uu_]) \\<le> length [uu_] * length [uu_] + 1\n 3. \\<And>p\\<^sub>0 p\\<^sub>1.\n       time (closest_pair_bf_tm [p\\<^sub>0, p\\<^sub>1])\n       \\<le> length [p\\<^sub>0, p\\<^sub>1] * length [p\\<^sub>0, p\\<^sub>1] +\n             1\n 4. \\<And>p\\<^sub>0 v vb vc.\n       time (closest_pair_bf_tm (v # vb # vc))\n       \\<le> length (v # vb # vc) * length (v # vb # vc) +\n             1 \\<Longrightarrow>\n       time (closest_pair_bf_tm (p\\<^sub>0 # v # vb # vc))\n       \\<le> length (p\\<^sub>0 # v # vb # vc) *\n             length (p\\<^sub>0 # v # vb # vc) +\n             1", "have \"time (closest_pair_bf_tm (p\\<^sub>0 # ?ps)) = 1 + time (find_closest_bf_tm p\\<^sub>0 ?ps) + time (closest_pair_bf_tm ?ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. time (closest_pair_bf_tm (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps)) =\n    1 + time (find_closest_bf_tm p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps)) +\n    time (closest_pair_bf_tm (p\\<^sub>2 # p\\<^sub>3 # ps))", "by (auto simp: time_simps split: prod.split)"], ["proof (state)\nthis:\n  time (closest_pair_bf_tm (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps)) =\n  1 + time (find_closest_bf_tm p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps)) +\n  time (closest_pair_bf_tm (p\\<^sub>2 # p\\<^sub>3 # ps))\n\ngoal (4 subgoals):\n 1. time (closest_pair_bf_tm []) \\<le> length [] * length [] + 1\n 2. \\<And>uu_.\n       time (closest_pair_bf_tm [uu_]) \\<le> length [uu_] * length [uu_] + 1\n 3. \\<And>p\\<^sub>0 p\\<^sub>1.\n       time (closest_pair_bf_tm [p\\<^sub>0, p\\<^sub>1])\n       \\<le> length [p\\<^sub>0, p\\<^sub>1] * length [p\\<^sub>0, p\\<^sub>1] +\n             1\n 4. \\<And>p\\<^sub>0 v vb vc.\n       time (closest_pair_bf_tm (v # vb # vc))\n       \\<le> length (v # vb # vc) * length (v # vb # vc) +\n             1 \\<Longrightarrow>\n       time (closest_pair_bf_tm (p\\<^sub>0 # v # vb # vc))\n       \\<le> length (p\\<^sub>0 # v # vb # vc) *\n             length (p\\<^sub>0 # v # vb # vc) +\n             1", "also"], ["proof (state)\nthis:\n  time (closest_pair_bf_tm (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps)) =\n  1 + time (find_closest_bf_tm p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps)) +\n  time (closest_pair_bf_tm (p\\<^sub>2 # p\\<^sub>3 # ps))\n\ngoal (4 subgoals):\n 1. time (closest_pair_bf_tm []) \\<le> length [] * length [] + 1\n 2. \\<And>uu_.\n       time (closest_pair_bf_tm [uu_]) \\<le> length [uu_] * length [uu_] + 1\n 3. \\<And>p\\<^sub>0 p\\<^sub>1.\n       time (closest_pair_bf_tm [p\\<^sub>0, p\\<^sub>1])\n       \\<le> length [p\\<^sub>0, p\\<^sub>1] * length [p\\<^sub>0, p\\<^sub>1] +\n             1\n 4. \\<And>p\\<^sub>0 v vb vc.\n       time (closest_pair_bf_tm (v # vb # vc))\n       \\<le> length (v # vb # vc) * length (v # vb # vc) +\n             1 \\<Longrightarrow>\n       time (closest_pair_bf_tm (p\\<^sub>0 # v # vb # vc))\n       \\<le> length (p\\<^sub>0 # v # vb # vc) *\n             length (p\\<^sub>0 # v # vb # vc) +\n             1", "have \"... \\<le> 2 + length ?ps + time (closest_pair_bf_tm ?ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + time (find_closest_bf_tm p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps)) +\n    time (closest_pair_bf_tm (p\\<^sub>2 # p\\<^sub>3 # ps))\n    \\<le> 2 + length (p\\<^sub>2 # p\\<^sub>3 # ps) +\n          time (closest_pair_bf_tm (p\\<^sub>2 # p\\<^sub>3 # ps))", "using time_find_closest_bf_tm[of p\\<^sub>0 ?ps]"], ["proof (prove)\nusing this:\n  time (find_closest_bf_tm p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps))\n  \\<le> length (p\\<^sub>2 # p\\<^sub>3 # ps) + 1\n\ngoal (1 subgoal):\n 1. 1 + time (find_closest_bf_tm p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps)) +\n    time (closest_pair_bf_tm (p\\<^sub>2 # p\\<^sub>3 # ps))\n    \\<le> 2 + length (p\\<^sub>2 # p\\<^sub>3 # ps) +\n          time (closest_pair_bf_tm (p\\<^sub>2 # p\\<^sub>3 # ps))", "by simp"], ["proof (state)\nthis:\n  1 + time (find_closest_bf_tm p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps)) +\n  time (closest_pair_bf_tm (p\\<^sub>2 # p\\<^sub>3 # ps))\n  \\<le> 2 + length (p\\<^sub>2 # p\\<^sub>3 # ps) +\n        time (closest_pair_bf_tm (p\\<^sub>2 # p\\<^sub>3 # ps))\n\ngoal (4 subgoals):\n 1. time (closest_pair_bf_tm []) \\<le> length [] * length [] + 1\n 2. \\<And>uu_.\n       time (closest_pair_bf_tm [uu_]) \\<le> length [uu_] * length [uu_] + 1\n 3. \\<And>p\\<^sub>0 p\\<^sub>1.\n       time (closest_pair_bf_tm [p\\<^sub>0, p\\<^sub>1])\n       \\<le> length [p\\<^sub>0, p\\<^sub>1] * length [p\\<^sub>0, p\\<^sub>1] +\n             1\n 4. \\<And>p\\<^sub>0 v vb vc.\n       time (closest_pair_bf_tm (v # vb # vc))\n       \\<le> length (v # vb # vc) * length (v # vb # vc) +\n             1 \\<Longrightarrow>\n       time (closest_pair_bf_tm (p\\<^sub>0 # v # vb # vc))\n       \\<le> length (p\\<^sub>0 # v # vb # vc) *\n             length (p\\<^sub>0 # v # vb # vc) +\n             1", "also"], ["proof (state)\nthis:\n  1 + time (find_closest_bf_tm p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps)) +\n  time (closest_pair_bf_tm (p\\<^sub>2 # p\\<^sub>3 # ps))\n  \\<le> 2 + length (p\\<^sub>2 # p\\<^sub>3 # ps) +\n        time (closest_pair_bf_tm (p\\<^sub>2 # p\\<^sub>3 # ps))\n\ngoal (4 subgoals):\n 1. time (closest_pair_bf_tm []) \\<le> length [] * length [] + 1\n 2. \\<And>uu_.\n       time (closest_pair_bf_tm [uu_]) \\<le> length [uu_] * length [uu_] + 1\n 3. \\<And>p\\<^sub>0 p\\<^sub>1.\n       time (closest_pair_bf_tm [p\\<^sub>0, p\\<^sub>1])\n       \\<le> length [p\\<^sub>0, p\\<^sub>1] * length [p\\<^sub>0, p\\<^sub>1] +\n             1\n 4. \\<And>p\\<^sub>0 v vb vc.\n       time (closest_pair_bf_tm (v # vb # vc))\n       \\<le> length (v # vb # vc) * length (v # vb # vc) +\n             1 \\<Longrightarrow>\n       time (closest_pair_bf_tm (p\\<^sub>0 # v # vb # vc))\n       \\<le> length (p\\<^sub>0 # v # vb # vc) *\n             length (p\\<^sub>0 # v # vb # vc) +\n             1", "have \"... \\<le> 2 + length ?ps + length ?ps * length ?ps + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 + length (p\\<^sub>2 # p\\<^sub>3 # ps) +\n    time (closest_pair_bf_tm (p\\<^sub>2 # p\\<^sub>3 # ps))\n    \\<le> 2 + length (p\\<^sub>2 # p\\<^sub>3 # ps) +\n          length (p\\<^sub>2 # p\\<^sub>3 # ps) *\n          length (p\\<^sub>2 # p\\<^sub>3 # ps) +\n          1", "using \"4.IH\""], ["proof (prove)\nusing this:\n  time (closest_pair_bf_tm (p\\<^sub>2 # p\\<^sub>3 # ps))\n  \\<le> length (p\\<^sub>2 # p\\<^sub>3 # ps) *\n        length (p\\<^sub>2 # p\\<^sub>3 # ps) +\n        1\n\ngoal (1 subgoal):\n 1. 2 + length (p\\<^sub>2 # p\\<^sub>3 # ps) +\n    time (closest_pair_bf_tm (p\\<^sub>2 # p\\<^sub>3 # ps))\n    \\<le> 2 + length (p\\<^sub>2 # p\\<^sub>3 # ps) +\n          length (p\\<^sub>2 # p\\<^sub>3 # ps) *\n          length (p\\<^sub>2 # p\\<^sub>3 # ps) +\n          1", "by simp"], ["proof (state)\nthis:\n  2 + length (p\\<^sub>2 # p\\<^sub>3 # ps) +\n  time (closest_pair_bf_tm (p\\<^sub>2 # p\\<^sub>3 # ps))\n  \\<le> 2 + length (p\\<^sub>2 # p\\<^sub>3 # ps) +\n        length (p\\<^sub>2 # p\\<^sub>3 # ps) *\n        length (p\\<^sub>2 # p\\<^sub>3 # ps) +\n        1\n\ngoal (4 subgoals):\n 1. time (closest_pair_bf_tm []) \\<le> length [] * length [] + 1\n 2. \\<And>uu_.\n       time (closest_pair_bf_tm [uu_]) \\<le> length [uu_] * length [uu_] + 1\n 3. \\<And>p\\<^sub>0 p\\<^sub>1.\n       time (closest_pair_bf_tm [p\\<^sub>0, p\\<^sub>1])\n       \\<le> length [p\\<^sub>0, p\\<^sub>1] * length [p\\<^sub>0, p\\<^sub>1] +\n             1\n 4. \\<And>p\\<^sub>0 v vb vc.\n       time (closest_pair_bf_tm (v # vb # vc))\n       \\<le> length (v # vb # vc) * length (v # vb # vc) +\n             1 \\<Longrightarrow>\n       time (closest_pair_bf_tm (p\\<^sub>0 # v # vb # vc))\n       \\<le> length (p\\<^sub>0 # v # vb # vc) *\n             length (p\\<^sub>0 # v # vb # vc) +\n             1", "also"], ["proof (state)\nthis:\n  2 + length (p\\<^sub>2 # p\\<^sub>3 # ps) +\n  time (closest_pair_bf_tm (p\\<^sub>2 # p\\<^sub>3 # ps))\n  \\<le> 2 + length (p\\<^sub>2 # p\\<^sub>3 # ps) +\n        length (p\\<^sub>2 # p\\<^sub>3 # ps) *\n        length (p\\<^sub>2 # p\\<^sub>3 # ps) +\n        1\n\ngoal (4 subgoals):\n 1. time (closest_pair_bf_tm []) \\<le> length [] * length [] + 1\n 2. \\<And>uu_.\n       time (closest_pair_bf_tm [uu_]) \\<le> length [uu_] * length [uu_] + 1\n 3. \\<And>p\\<^sub>0 p\\<^sub>1.\n       time (closest_pair_bf_tm [p\\<^sub>0, p\\<^sub>1])\n       \\<le> length [p\\<^sub>0, p\\<^sub>1] * length [p\\<^sub>0, p\\<^sub>1] +\n             1\n 4. \\<And>p\\<^sub>0 v vb vc.\n       time (closest_pair_bf_tm (v # vb # vc))\n       \\<le> length (v # vb # vc) * length (v # vb # vc) +\n             1 \\<Longrightarrow>\n       time (closest_pair_bf_tm (p\\<^sub>0 # v # vb # vc))\n       \\<le> length (p\\<^sub>0 # v # vb # vc) *\n             length (p\\<^sub>0 # v # vb # vc) +\n             1", "have \"... \\<le> length (p\\<^sub>0 # ?ps) * length (p\\<^sub>0 # ?ps) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 + length (p\\<^sub>2 # p\\<^sub>3 # ps) +\n    length (p\\<^sub>2 # p\\<^sub>3 # ps) *\n    length (p\\<^sub>2 # p\\<^sub>3 # ps) +\n    1\n    \\<le> length (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps) *\n          length (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps) +\n          1", "by auto"], ["proof (state)\nthis:\n  2 + length (p\\<^sub>2 # p\\<^sub>3 # ps) +\n  length (p\\<^sub>2 # p\\<^sub>3 # ps) *\n  length (p\\<^sub>2 # p\\<^sub>3 # ps) +\n  1\n  \\<le> length (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps) *\n        length (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps) +\n        1\n\ngoal (4 subgoals):\n 1. time (closest_pair_bf_tm []) \\<le> length [] * length [] + 1\n 2. \\<And>uu_.\n       time (closest_pair_bf_tm [uu_]) \\<le> length [uu_] * length [uu_] + 1\n 3. \\<And>p\\<^sub>0 p\\<^sub>1.\n       time (closest_pair_bf_tm [p\\<^sub>0, p\\<^sub>1])\n       \\<le> length [p\\<^sub>0, p\\<^sub>1] * length [p\\<^sub>0, p\\<^sub>1] +\n             1\n 4. \\<And>p\\<^sub>0 v vb vc.\n       time (closest_pair_bf_tm (v # vb # vc))\n       \\<le> length (v # vb # vc) * length (v # vb # vc) +\n             1 \\<Longrightarrow>\n       time (closest_pair_bf_tm (p\\<^sub>0 # v # vb # vc))\n       \\<le> length (p\\<^sub>0 # v # vb # vc) *\n             length (p\\<^sub>0 # v # vb # vc) +\n             1", "finally"], ["proof (chain)\npicking this:\n  time (closest_pair_bf_tm (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps))\n  \\<le> length (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps) *\n        length (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps) +\n        1", "show ?case"], ["proof (prove)\nusing this:\n  time (closest_pair_bf_tm (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps))\n  \\<le> length (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps) *\n        length (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps) +\n        1\n\ngoal (1 subgoal):\n 1. time (closest_pair_bf_tm (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps))\n    \\<le> length (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps) *\n          length (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps) +\n          1", "by blast"], ["proof (state)\nthis:\n  time (closest_pair_bf_tm (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps))\n  \\<le> length (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps) *\n        length (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps) +\n        1\n\ngoal (3 subgoals):\n 1. time (closest_pair_bf_tm []) \\<le> length [] * length [] + 1\n 2. \\<And>uu_.\n       time (closest_pair_bf_tm [uu_]) \\<le> length [uu_] * length [uu_] + 1\n 3. \\<And>p\\<^sub>0 p\\<^sub>1.\n       time (closest_pair_bf_tm [p\\<^sub>0, p\\<^sub>1])\n       \\<le> length [p\\<^sub>0, p\\<^sub>1] * length [p\\<^sub>0, p\\<^sub>1] +\n             1", "qed (auto simp: time_simps)"], ["", "subsubsection \"Code Export\""], ["", "fun find_closest_bf_code :: \"point \\<Rightarrow> point list \\<Rightarrow> (int * point)\" where\n  \"find_closest_bf_code p [] = undefined\"\n| \"find_closest_bf_code p [p\\<^sub>0] = (dist_code p p\\<^sub>0, p\\<^sub>0)\"\n| \"find_closest_bf_code p (p\\<^sub>0 # ps) = (\n    let (\\<delta>\\<^sub>1, p\\<^sub>1) = find_closest_bf_code p ps in\n    let \\<delta>\\<^sub>0 = dist_code p p\\<^sub>0 in\n    if \\<delta>\\<^sub>0 < \\<delta>\\<^sub>1 then\n      (\\<delta>\\<^sub>0, p\\<^sub>0)\n    else\n      (\\<delta>\\<^sub>1, p\\<^sub>1)\n  )\""], ["", "lemma find_closest_bf_code_dist_eq:\n  \"0 < length ps \\<Longrightarrow> (\\<delta>, c) = find_closest_bf_code p ps \\<Longrightarrow> \\<delta> = dist_code p c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < length ps;\n     (\\<delta>, c) = find_closest_bf_code p ps\\<rbrakk>\n    \\<Longrightarrow> \\<delta> = dist_code p c", "by (induction p ps rule: find_closest_bf_code.induct)\n     (auto simp: Let_def split: prod.splits if_splits)"], ["", "lemma find_closest_bf_code_eq:\n  \"0 < length ps \\<Longrightarrow> c = find_closest_bf p ps \\<Longrightarrow> (\\<delta>', c') = find_closest_bf_code p ps \\<Longrightarrow> c = c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < length ps; c = find_closest_bf p ps;\n     (\\<delta>', c') = find_closest_bf_code p ps\\<rbrakk>\n    \\<Longrightarrow> c = c'", "proof (induction p ps arbitrary: c \\<delta>' c' rule: find_closest_bf.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>uu_ c \\<delta>' c'.\n       \\<lbrakk>0 < length []; c = find_closest_bf uu_ [];\n        (\\<delta>', c') = find_closest_bf_code uu_ []\\<rbrakk>\n       \\<Longrightarrow> c = c'\n 2. \\<And>uv_ p c \\<delta>' c'.\n       \\<lbrakk>0 < length [p]; c = find_closest_bf uv_ [p];\n        (\\<delta>', c') = find_closest_bf_code uv_ [p]\\<rbrakk>\n       \\<Longrightarrow> c = c'\n 3. \\<And>p p\\<^sub>0 v va c \\<delta>' c'.\n       \\<lbrakk>\\<And>c \\<delta>' c'.\n                   \\<lbrakk>0 < length (v # va);\n                    c = find_closest_bf p (v # va);\n                    (\\<delta>', c') =\n                    find_closest_bf_code p (v # va)\\<rbrakk>\n                   \\<Longrightarrow> c = c';\n        0 < length (p\\<^sub>0 # v # va);\n        c = find_closest_bf p (p\\<^sub>0 # v # va);\n        (\\<delta>', c') =\n        find_closest_bf_code p (p\\<^sub>0 # v # va)\\<rbrakk>\n       \\<Longrightarrow> c = c'", "case (3 p p\\<^sub>0 p\\<^sub>2 ps)"], ["proof (state)\nthis:\n  \\<lbrakk>0 < length (p\\<^sub>2 # ps);\n   ?c = find_closest_bf p (p\\<^sub>2 # ps);\n   (?\\<delta>', ?c') = find_closest_bf_code p (p\\<^sub>2 # ps)\\<rbrakk>\n  \\<Longrightarrow> ?c = ?c'\n  0 < length (p\\<^sub>0 # p\\<^sub>2 # ps)\n  c = find_closest_bf p (p\\<^sub>0 # p\\<^sub>2 # ps)\n  (\\<delta>', c') = find_closest_bf_code p (p\\<^sub>0 # p\\<^sub>2 # ps)\n\ngoal (3 subgoals):\n 1. \\<And>uu_ c \\<delta>' c'.\n       \\<lbrakk>0 < length []; c = find_closest_bf uu_ [];\n        (\\<delta>', c') = find_closest_bf_code uu_ []\\<rbrakk>\n       \\<Longrightarrow> c = c'\n 2. \\<And>uv_ p c \\<delta>' c'.\n       \\<lbrakk>0 < length [p]; c = find_closest_bf uv_ [p];\n        (\\<delta>', c') = find_closest_bf_code uv_ [p]\\<rbrakk>\n       \\<Longrightarrow> c = c'\n 3. \\<And>p p\\<^sub>0 v va c \\<delta>' c'.\n       \\<lbrakk>\\<And>c \\<delta>' c'.\n                   \\<lbrakk>0 < length (v # va);\n                    c = find_closest_bf p (v # va);\n                    (\\<delta>', c') =\n                    find_closest_bf_code p (v # va)\\<rbrakk>\n                   \\<Longrightarrow> c = c';\n        0 < length (p\\<^sub>0 # v # va);\n        c = find_closest_bf p (p\\<^sub>0 # v # va);\n        (\\<delta>', c') =\n        find_closest_bf_code p (p\\<^sub>0 # v # va)\\<rbrakk>\n       \\<Longrightarrow> c = c'", "define \\<delta>\\<^sub>0 \\<delta>\\<^sub>0' where \\<delta>\\<^sub>0_def: \"\\<delta>\\<^sub>0 = dist p p\\<^sub>0\" \"\\<delta>\\<^sub>0' = dist_code p p\\<^sub>0\""], ["proof (state)\nthis:\n  \\<delta>\\<^sub>0 =\n  dist (case p of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n   (case p\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n  \\<delta>\\<^sub>0' = dist_code p p\\<^sub>0\n\ngoal (3 subgoals):\n 1. \\<And>uu_ c \\<delta>' c'.\n       \\<lbrakk>0 < length []; c = find_closest_bf uu_ [];\n        (\\<delta>', c') = find_closest_bf_code uu_ []\\<rbrakk>\n       \\<Longrightarrow> c = c'\n 2. \\<And>uv_ p c \\<delta>' c'.\n       \\<lbrakk>0 < length [p]; c = find_closest_bf uv_ [p];\n        (\\<delta>', c') = find_closest_bf_code uv_ [p]\\<rbrakk>\n       \\<Longrightarrow> c = c'\n 3. \\<And>p p\\<^sub>0 v va c \\<delta>' c'.\n       \\<lbrakk>\\<And>c \\<delta>' c'.\n                   \\<lbrakk>0 < length (v # va);\n                    c = find_closest_bf p (v # va);\n                    (\\<delta>', c') =\n                    find_closest_bf_code p (v # va)\\<rbrakk>\n                   \\<Longrightarrow> c = c';\n        0 < length (p\\<^sub>0 # v # va);\n        c = find_closest_bf p (p\\<^sub>0 # v # va);\n        (\\<delta>', c') =\n        find_closest_bf_code p (p\\<^sub>0 # v # va)\\<rbrakk>\n       \\<Longrightarrow> c = c'", "obtain \\<delta>\\<^sub>1 p\\<^sub>1 \\<delta>\\<^sub>1' p\\<^sub>1' where \\<delta>\\<^sub>1_def: \"\\<delta>\\<^sub>1 = dist p p\\<^sub>1\" \"p\\<^sub>1 = find_closest_bf p (p\\<^sub>2 # ps)\"\n    \"(\\<delta>\\<^sub>1', p\\<^sub>1') = find_closest_bf_code p (p\\<^sub>2 # ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<delta>\\<^sub>1 p\\<^sub>1 \\<delta>\\<^sub>1' p\\<^sub>1'.\n        \\<lbrakk>\\<delta>\\<^sub>1 =\n                 dist\n                  (case p of\n                   (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n                  (case p\\<^sub>1 of\n                   (x, y) \\<Rightarrow> (real_of_int x, real_of_int y));\n         p\\<^sub>1 = find_closest_bf p (p\\<^sub>2 # ps);\n         (\\<delta>\\<^sub>1', p\\<^sub>1') =\n         find_closest_bf_code p (p\\<^sub>2 # ps)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod.collapse"], ["proof (prove)\nusing this:\n  (fst ?prod, snd ?prod) = ?prod\n\ngoal (1 subgoal):\n 1. (\\<And>\\<delta>\\<^sub>1 p\\<^sub>1 \\<delta>\\<^sub>1' p\\<^sub>1'.\n        \\<lbrakk>\\<delta>\\<^sub>1 =\n                 dist\n                  (case p of\n                   (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n                  (case p\\<^sub>1 of\n                   (x, y) \\<Rightarrow> (real_of_int x, real_of_int y));\n         p\\<^sub>1 = find_closest_bf p (p\\<^sub>2 # ps);\n         (\\<delta>\\<^sub>1', p\\<^sub>1') =\n         find_closest_bf_code p (p\\<^sub>2 # ps)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast+"], ["proof (state)\nthis:\n  \\<delta>\\<^sub>1 =\n  dist (case p of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n   (case p\\<^sub>1 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n  p\\<^sub>1 = find_closest_bf p (p\\<^sub>2 # ps)\n  (\\<delta>\\<^sub>1', p\\<^sub>1') = find_closest_bf_code p (p\\<^sub>2 # ps)\n\ngoal (3 subgoals):\n 1. \\<And>uu_ c \\<delta>' c'.\n       \\<lbrakk>0 < length []; c = find_closest_bf uu_ [];\n        (\\<delta>', c') = find_closest_bf_code uu_ []\\<rbrakk>\n       \\<Longrightarrow> c = c'\n 2. \\<And>uv_ p c \\<delta>' c'.\n       \\<lbrakk>0 < length [p]; c = find_closest_bf uv_ [p];\n        (\\<delta>', c') = find_closest_bf_code uv_ [p]\\<rbrakk>\n       \\<Longrightarrow> c = c'\n 3. \\<And>p p\\<^sub>0 v va c \\<delta>' c'.\n       \\<lbrakk>\\<And>c \\<delta>' c'.\n                   \\<lbrakk>0 < length (v # va);\n                    c = find_closest_bf p (v # va);\n                    (\\<delta>', c') =\n                    find_closest_bf_code p (v # va)\\<rbrakk>\n                   \\<Longrightarrow> c = c';\n        0 < length (p\\<^sub>0 # v # va);\n        c = find_closest_bf p (p\\<^sub>0 # v # va);\n        (\\<delta>', c') =\n        find_closest_bf_code p (p\\<^sub>0 # v # va)\\<rbrakk>\n       \\<Longrightarrow> c = c'", "note defs = \\<delta>\\<^sub>0_def \\<delta>\\<^sub>1_def"], ["proof (state)\nthis:\n  \\<delta>\\<^sub>0 =\n  dist (case p of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n   (case p\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n  \\<delta>\\<^sub>0' = dist_code p p\\<^sub>0\n  \\<delta>\\<^sub>1 =\n  dist (case p of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n   (case p\\<^sub>1 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n  p\\<^sub>1 = find_closest_bf p (p\\<^sub>2 # ps)\n  (\\<delta>\\<^sub>1', p\\<^sub>1') = find_closest_bf_code p (p\\<^sub>2 # ps)\n\ngoal (3 subgoals):\n 1. \\<And>uu_ c \\<delta>' c'.\n       \\<lbrakk>0 < length []; c = find_closest_bf uu_ [];\n        (\\<delta>', c') = find_closest_bf_code uu_ []\\<rbrakk>\n       \\<Longrightarrow> c = c'\n 2. \\<And>uv_ p c \\<delta>' c'.\n       \\<lbrakk>0 < length [p]; c = find_closest_bf uv_ [p];\n        (\\<delta>', c') = find_closest_bf_code uv_ [p]\\<rbrakk>\n       \\<Longrightarrow> c = c'\n 3. \\<And>p p\\<^sub>0 v va c \\<delta>' c'.\n       \\<lbrakk>\\<And>c \\<delta>' c'.\n                   \\<lbrakk>0 < length (v # va);\n                    c = find_closest_bf p (v # va);\n                    (\\<delta>', c') =\n                    find_closest_bf_code p (v # va)\\<rbrakk>\n                   \\<Longrightarrow> c = c';\n        0 < length (p\\<^sub>0 # v # va);\n        c = find_closest_bf p (p\\<^sub>0 # v # va);\n        (\\<delta>', c') =\n        find_closest_bf_code p (p\\<^sub>0 # v # va)\\<rbrakk>\n       \\<Longrightarrow> c = c'", "have *: \"p\\<^sub>1 = p\\<^sub>1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p\\<^sub>1 = p\\<^sub>1'", "using \"3.IH\" defs"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < length (p\\<^sub>2 # ps);\n   ?c = find_closest_bf p (p\\<^sub>2 # ps);\n   (?\\<delta>', ?c') = find_closest_bf_code p (p\\<^sub>2 # ps)\\<rbrakk>\n  \\<Longrightarrow> ?c = ?c'\n  \\<delta>\\<^sub>0 =\n  dist (case p of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n   (case p\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n  \\<delta>\\<^sub>0' = dist_code p p\\<^sub>0\n  \\<delta>\\<^sub>1 =\n  dist (case p of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n   (case p\\<^sub>1 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n  p\\<^sub>1 = find_closest_bf p (p\\<^sub>2 # ps)\n  (\\<delta>\\<^sub>1', p\\<^sub>1') = find_closest_bf_code p (p\\<^sub>2 # ps)\n\ngoal (1 subgoal):\n 1. p\\<^sub>1 = p\\<^sub>1'", "by simp"], ["proof (state)\nthis:\n  p\\<^sub>1 = p\\<^sub>1'\n\ngoal (3 subgoals):\n 1. \\<And>uu_ c \\<delta>' c'.\n       \\<lbrakk>0 < length []; c = find_closest_bf uu_ [];\n        (\\<delta>', c') = find_closest_bf_code uu_ []\\<rbrakk>\n       \\<Longrightarrow> c = c'\n 2. \\<And>uv_ p c \\<delta>' c'.\n       \\<lbrakk>0 < length [p]; c = find_closest_bf uv_ [p];\n        (\\<delta>', c') = find_closest_bf_code uv_ [p]\\<rbrakk>\n       \\<Longrightarrow> c = c'\n 3. \\<And>p p\\<^sub>0 v va c \\<delta>' c'.\n       \\<lbrakk>\\<And>c \\<delta>' c'.\n                   \\<lbrakk>0 < length (v # va);\n                    c = find_closest_bf p (v # va);\n                    (\\<delta>', c') =\n                    find_closest_bf_code p (v # va)\\<rbrakk>\n                   \\<Longrightarrow> c = c';\n        0 < length (p\\<^sub>0 # v # va);\n        c = find_closest_bf p (p\\<^sub>0 # v # va);\n        (\\<delta>', c') =\n        find_closest_bf_code p (p\\<^sub>0 # v # va)\\<rbrakk>\n       \\<Longrightarrow> c = c'", "hence \"\\<delta>\\<^sub>0 < \\<delta>\\<^sub>1 \\<longleftrightarrow> \\<delta>\\<^sub>0' < \\<delta>\\<^sub>1'\""], ["proof (prove)\nusing this:\n  p\\<^sub>1 = p\\<^sub>1'\n\ngoal (1 subgoal):\n 1. (\\<delta>\\<^sub>0 < \\<delta>\\<^sub>1) =\n    (\\<delta>\\<^sub>0' < \\<delta>\\<^sub>1')", "using find_closest_bf_code_dist_eq[of \"p\\<^sub>2 # ps\" \\<delta>\\<^sub>1' p\\<^sub>1' p]\n          dist_eq_dist_code_lt defs"], ["proof (prove)\nusing this:\n  p\\<^sub>1 = p\\<^sub>1'\n  \\<lbrakk>0 < length (p\\<^sub>2 # ps);\n   (\\<delta>\\<^sub>1', p\\<^sub>1') =\n   find_closest_bf_code p (p\\<^sub>2 # ps)\\<rbrakk>\n  \\<Longrightarrow> \\<delta>\\<^sub>1' = dist_code p p\\<^sub>1'\n  (dist\n    (case ?p\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n    (case ?p\\<^sub>1 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n   < dist\n      (case ?p\\<^sub>2 of\n       (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n      (case ?p\\<^sub>3 of\n       (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))) =\n  (dist_code ?p\\<^sub>0 ?p\\<^sub>1 < dist_code ?p\\<^sub>2 ?p\\<^sub>3)\n  \\<delta>\\<^sub>0 =\n  dist (case p of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n   (case p\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n  \\<delta>\\<^sub>0' = dist_code p p\\<^sub>0\n  \\<delta>\\<^sub>1 =\n  dist (case p of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n   (case p\\<^sub>1 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n  p\\<^sub>1 = find_closest_bf p (p\\<^sub>2 # ps)\n  (\\<delta>\\<^sub>1', p\\<^sub>1') = find_closest_bf_code p (p\\<^sub>2 # ps)\n\ngoal (1 subgoal):\n 1. (\\<delta>\\<^sub>0 < \\<delta>\\<^sub>1) =\n    (\\<delta>\\<^sub>0' < \\<delta>\\<^sub>1')", "by simp"], ["proof (state)\nthis:\n  (\\<delta>\\<^sub>0 < \\<delta>\\<^sub>1) =\n  (\\<delta>\\<^sub>0' < \\<delta>\\<^sub>1')\n\ngoal (3 subgoals):\n 1. \\<And>uu_ c \\<delta>' c'.\n       \\<lbrakk>0 < length []; c = find_closest_bf uu_ [];\n        (\\<delta>', c') = find_closest_bf_code uu_ []\\<rbrakk>\n       \\<Longrightarrow> c = c'\n 2. \\<And>uv_ p c \\<delta>' c'.\n       \\<lbrakk>0 < length [p]; c = find_closest_bf uv_ [p];\n        (\\<delta>', c') = find_closest_bf_code uv_ [p]\\<rbrakk>\n       \\<Longrightarrow> c = c'\n 3. \\<And>p p\\<^sub>0 v va c \\<delta>' c'.\n       \\<lbrakk>\\<And>c \\<delta>' c'.\n                   \\<lbrakk>0 < length (v # va);\n                    c = find_closest_bf p (v # va);\n                    (\\<delta>', c') =\n                    find_closest_bf_code p (v # va)\\<rbrakk>\n                   \\<Longrightarrow> c = c';\n        0 < length (p\\<^sub>0 # v # va);\n        c = find_closest_bf p (p\\<^sub>0 # v # va);\n        (\\<delta>', c') =\n        find_closest_bf_code p (p\\<^sub>0 # v # va)\\<rbrakk>\n       \\<Longrightarrow> c = c'", "thus ?case"], ["proof (prove)\nusing this:\n  (\\<delta>\\<^sub>0 < \\<delta>\\<^sub>1) =\n  (\\<delta>\\<^sub>0' < \\<delta>\\<^sub>1')\n\ngoal (1 subgoal):\n 1. c = c'", "using \"3.prems\"(2,3) * defs"], ["proof (prove)\nusing this:\n  (\\<delta>\\<^sub>0 < \\<delta>\\<^sub>1) =\n  (\\<delta>\\<^sub>0' < \\<delta>\\<^sub>1')\n  c = find_closest_bf p (p\\<^sub>0 # p\\<^sub>2 # ps)\n  (\\<delta>', c') = find_closest_bf_code p (p\\<^sub>0 # p\\<^sub>2 # ps)\n  p\\<^sub>1 = p\\<^sub>1'\n  \\<delta>\\<^sub>0 =\n  dist (case p of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n   (case p\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n  \\<delta>\\<^sub>0' = dist_code p p\\<^sub>0\n  \\<delta>\\<^sub>1 =\n  dist (case p of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n   (case p\\<^sub>1 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n  p\\<^sub>1 = find_closest_bf p (p\\<^sub>2 # ps)\n  (\\<delta>\\<^sub>1', p\\<^sub>1') = find_closest_bf_code p (p\\<^sub>2 # ps)\n\ngoal (1 subgoal):\n 1. c = c'", "by (auto split: prod.splits)"], ["proof (state)\nthis:\n  c = c'\n\ngoal (2 subgoals):\n 1. \\<And>uu_ c \\<delta>' c'.\n       \\<lbrakk>0 < length []; c = find_closest_bf uu_ [];\n        (\\<delta>', c') = find_closest_bf_code uu_ []\\<rbrakk>\n       \\<Longrightarrow> c = c'\n 2. \\<And>uv_ p c \\<delta>' c'.\n       \\<lbrakk>0 < length [p]; c = find_closest_bf uv_ [p];\n        (\\<delta>', c') = find_closest_bf_code uv_ [p]\\<rbrakk>\n       \\<Longrightarrow> c = c'", "qed auto"], ["", "declare find_closest_bf_code.simps [simp del]"], ["", "fun closest_pair_bf_code :: \"point list \\<Rightarrow> (int * point * point)\" where\n  \"closest_pair_bf_code [] = undefined\"\n| \"closest_pair_bf_code [p\\<^sub>0] = undefined\"\n| \"closest_pair_bf_code [p\\<^sub>0, p\\<^sub>1] = (dist_code p\\<^sub>0 p\\<^sub>1, p\\<^sub>0, p\\<^sub>1)\"\n| \"closest_pair_bf_code (p\\<^sub>0 # ps) = (\n    let (\\<delta>\\<^sub>c, c\\<^sub>0, c\\<^sub>1) = closest_pair_bf_code ps in\n    let (\\<delta>\\<^sub>p, p\\<^sub>1) = find_closest_bf_code p\\<^sub>0 ps in\n    if \\<delta>\\<^sub>c \\<le> \\<delta>\\<^sub>p then\n      (\\<delta>\\<^sub>c, c\\<^sub>0, c\\<^sub>1)\n    else\n      (\\<delta>\\<^sub>p, p\\<^sub>0, p\\<^sub>1) \n  )\""], ["", "lemma closest_pair_bf_code_dist_eq:\n  \"1 < length ps \\<Longrightarrow> (\\<delta>, c\\<^sub>0, c\\<^sub>1) = closest_pair_bf_code ps \\<Longrightarrow> \\<delta> = dist_code c\\<^sub>0 c\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < length ps;\n     (\\<delta>, c\\<^sub>0, c\\<^sub>1) = closest_pair_bf_code ps\\<rbrakk>\n    \\<Longrightarrow> \\<delta> = dist_code c\\<^sub>0 c\\<^sub>1", "proof (induction ps arbitrary: \\<delta> c\\<^sub>0 c\\<^sub>1 rule: closest_pair_bf_code.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>\\<delta> c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [];\n        (\\<delta>, c\\<^sub>0, c\\<^sub>1) = closest_pair_bf_code []\\<rbrakk>\n       \\<Longrightarrow> \\<delta> = dist_code c\\<^sub>0 c\\<^sub>1\n 2. \\<And>p\\<^sub>0 \\<delta> c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0];\n        (\\<delta>, c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf_code [p\\<^sub>0]\\<rbrakk>\n       \\<Longrightarrow> \\<delta> = dist_code c\\<^sub>0 c\\<^sub>1\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 \\<delta> c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        (\\<delta>, c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf_code [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> \\<delta> = dist_code c\\<^sub>0 c\\<^sub>1\n 4. \\<And>p\\<^sub>0 v vb vc \\<delta> c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>\\<And>\\<delta> c\\<^sub>0 c\\<^sub>1.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    (\\<delta>, c\\<^sub>0, c\\<^sub>1) =\n                    closest_pair_bf_code (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> \\<delta> =\n                                     dist_code c\\<^sub>0 c\\<^sub>1;\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        (\\<delta>, c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf_code (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> \\<delta> = dist_code c\\<^sub>0 c\\<^sub>1", "case (4 p\\<^sub>0 p\\<^sub>2 p\\<^sub>3 ps)"], ["proof (state)\nthis:\n  \\<lbrakk>1 < length (p\\<^sub>2 # p\\<^sub>3 # ps);\n   (?\\<delta>, ?c\\<^sub>0, ?c\\<^sub>1) =\n   closest_pair_bf_code (p\\<^sub>2 # p\\<^sub>3 # ps)\\<rbrakk>\n  \\<Longrightarrow> ?\\<delta> = dist_code ?c\\<^sub>0 ?c\\<^sub>1\n  1 < length (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps)\n  (\\<delta>, c\\<^sub>0, c\\<^sub>1) =\n  closest_pair_bf_code (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps)\n\ngoal (4 subgoals):\n 1. \\<And>\\<delta> c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [];\n        (\\<delta>, c\\<^sub>0, c\\<^sub>1) = closest_pair_bf_code []\\<rbrakk>\n       \\<Longrightarrow> \\<delta> = dist_code c\\<^sub>0 c\\<^sub>1\n 2. \\<And>p\\<^sub>0 \\<delta> c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0];\n        (\\<delta>, c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf_code [p\\<^sub>0]\\<rbrakk>\n       \\<Longrightarrow> \\<delta> = dist_code c\\<^sub>0 c\\<^sub>1\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 \\<delta> c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        (\\<delta>, c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf_code [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> \\<delta> = dist_code c\\<^sub>0 c\\<^sub>1\n 4. \\<And>p\\<^sub>0 v vb vc \\<delta> c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>\\<And>\\<delta> c\\<^sub>0 c\\<^sub>1.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    (\\<delta>, c\\<^sub>0, c\\<^sub>1) =\n                    closest_pair_bf_code (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> \\<delta> =\n                                     dist_code c\\<^sub>0 c\\<^sub>1;\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        (\\<delta>, c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf_code (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> \\<delta> = dist_code c\\<^sub>0 c\\<^sub>1", "let ?ps = \"p\\<^sub>2 # p\\<^sub>3 # ps\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>\\<delta> c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [];\n        (\\<delta>, c\\<^sub>0, c\\<^sub>1) = closest_pair_bf_code []\\<rbrakk>\n       \\<Longrightarrow> \\<delta> = dist_code c\\<^sub>0 c\\<^sub>1\n 2. \\<And>p\\<^sub>0 \\<delta> c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0];\n        (\\<delta>, c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf_code [p\\<^sub>0]\\<rbrakk>\n       \\<Longrightarrow> \\<delta> = dist_code c\\<^sub>0 c\\<^sub>1\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 \\<delta> c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        (\\<delta>, c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf_code [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> \\<delta> = dist_code c\\<^sub>0 c\\<^sub>1\n 4. \\<And>p\\<^sub>0 v vb vc \\<delta> c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>\\<And>\\<delta> c\\<^sub>0 c\\<^sub>1.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    (\\<delta>, c\\<^sub>0, c\\<^sub>1) =\n                    closest_pair_bf_code (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> \\<delta> =\n                                     dist_code c\\<^sub>0 c\\<^sub>1;\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        (\\<delta>, c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf_code (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> \\<delta> = dist_code c\\<^sub>0 c\\<^sub>1", "obtain \\<delta>\\<^sub>c c\\<^sub>0 c\\<^sub>1 where \\<delta>\\<^sub>c_def: \"(\\<delta>\\<^sub>c, c\\<^sub>0, c\\<^sub>1) = closest_pair_bf_code ?ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<delta>\\<^sub>c c\\<^sub>0 c\\<^sub>1.\n        (\\<delta>\\<^sub>c, c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf_code (p\\<^sub>2 # p\\<^sub>3 # ps) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  (\\<delta>\\<^sub>c, c\\<^sub>0, c\\<^sub>1) =\n  closest_pair_bf_code (p\\<^sub>2 # p\\<^sub>3 # ps)\n\ngoal (4 subgoals):\n 1. \\<And>\\<delta> c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [];\n        (\\<delta>, c\\<^sub>0, c\\<^sub>1) = closest_pair_bf_code []\\<rbrakk>\n       \\<Longrightarrow> \\<delta> = dist_code c\\<^sub>0 c\\<^sub>1\n 2. \\<And>p\\<^sub>0 \\<delta> c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0];\n        (\\<delta>, c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf_code [p\\<^sub>0]\\<rbrakk>\n       \\<Longrightarrow> \\<delta> = dist_code c\\<^sub>0 c\\<^sub>1\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 \\<delta> c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        (\\<delta>, c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf_code [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> \\<delta> = dist_code c\\<^sub>0 c\\<^sub>1\n 4. \\<And>p\\<^sub>0 v vb vc \\<delta> c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>\\<And>\\<delta> c\\<^sub>0 c\\<^sub>1.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    (\\<delta>, c\\<^sub>0, c\\<^sub>1) =\n                    closest_pair_bf_code (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> \\<delta> =\n                                     dist_code c\\<^sub>0 c\\<^sub>1;\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        (\\<delta>, c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf_code (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> \\<delta> = dist_code c\\<^sub>0 c\\<^sub>1", "obtain \\<delta>\\<^sub>p p\\<^sub>1 where \\<delta>\\<^sub>p_def: \"(\\<delta>\\<^sub>p, p\\<^sub>1) = find_closest_bf_code p\\<^sub>0 ?ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<delta>\\<^sub>p p\\<^sub>1.\n        (\\<delta>\\<^sub>p, p\\<^sub>1) =\n        find_closest_bf_code p\\<^sub>0\n         (p\\<^sub>2 # p\\<^sub>3 # ps) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using prod.collapse"], ["proof (prove)\nusing this:\n  (fst ?prod, snd ?prod) = ?prod\n\ngoal (1 subgoal):\n 1. (\\<And>\\<delta>\\<^sub>p p\\<^sub>1.\n        (\\<delta>\\<^sub>p, p\\<^sub>1) =\n        find_closest_bf_code p\\<^sub>0\n         (p\\<^sub>2 # p\\<^sub>3 # ps) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (\\<delta>\\<^sub>p, p\\<^sub>1) =\n  find_closest_bf_code p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps)\n\ngoal (4 subgoals):\n 1. \\<And>\\<delta> c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [];\n        (\\<delta>, c\\<^sub>0, c\\<^sub>1) = closest_pair_bf_code []\\<rbrakk>\n       \\<Longrightarrow> \\<delta> = dist_code c\\<^sub>0 c\\<^sub>1\n 2. \\<And>p\\<^sub>0 \\<delta> c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0];\n        (\\<delta>, c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf_code [p\\<^sub>0]\\<rbrakk>\n       \\<Longrightarrow> \\<delta> = dist_code c\\<^sub>0 c\\<^sub>1\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 \\<delta> c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        (\\<delta>, c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf_code [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> \\<delta> = dist_code c\\<^sub>0 c\\<^sub>1\n 4. \\<And>p\\<^sub>0 v vb vc \\<delta> c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>\\<And>\\<delta> c\\<^sub>0 c\\<^sub>1.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    (\\<delta>, c\\<^sub>0, c\\<^sub>1) =\n                    closest_pair_bf_code (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> \\<delta> =\n                                     dist_code c\\<^sub>0 c\\<^sub>1;\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        (\\<delta>, c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf_code (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> \\<delta> = dist_code c\\<^sub>0 c\\<^sub>1", "note defs = \\<delta>\\<^sub>c_def \\<delta>\\<^sub>p_def"], ["proof (state)\nthis:\n  (\\<delta>\\<^sub>c, c\\<^sub>0, c\\<^sub>1) =\n  closest_pair_bf_code (p\\<^sub>2 # p\\<^sub>3 # ps)\n  (\\<delta>\\<^sub>p, p\\<^sub>1) =\n  find_closest_bf_code p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps)\n\ngoal (4 subgoals):\n 1. \\<And>\\<delta> c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [];\n        (\\<delta>, c\\<^sub>0, c\\<^sub>1) = closest_pair_bf_code []\\<rbrakk>\n       \\<Longrightarrow> \\<delta> = dist_code c\\<^sub>0 c\\<^sub>1\n 2. \\<And>p\\<^sub>0 \\<delta> c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0];\n        (\\<delta>, c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf_code [p\\<^sub>0]\\<rbrakk>\n       \\<Longrightarrow> \\<delta> = dist_code c\\<^sub>0 c\\<^sub>1\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 \\<delta> c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        (\\<delta>, c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf_code [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> \\<delta> = dist_code c\\<^sub>0 c\\<^sub>1\n 4. \\<And>p\\<^sub>0 v vb vc \\<delta> c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>\\<And>\\<delta> c\\<^sub>0 c\\<^sub>1.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    (\\<delta>, c\\<^sub>0, c\\<^sub>1) =\n                    closest_pair_bf_code (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> \\<delta> =\n                                     dist_code c\\<^sub>0 c\\<^sub>1;\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        (\\<delta>, c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf_code (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> \\<delta> = dist_code c\\<^sub>0 c\\<^sub>1", "have \"\\<delta>\\<^sub>c = dist_code c\\<^sub>0 c\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>c = dist_code c\\<^sub>0 c\\<^sub>1", "using \"4.IH\" defs"], ["proof (prove)\nusing this:\n  \\<lbrakk>1 < length (p\\<^sub>2 # p\\<^sub>3 # ps);\n   (?\\<delta>, ?c\\<^sub>0, ?c\\<^sub>1) =\n   closest_pair_bf_code (p\\<^sub>2 # p\\<^sub>3 # ps)\\<rbrakk>\n  \\<Longrightarrow> ?\\<delta> = dist_code ?c\\<^sub>0 ?c\\<^sub>1\n  (\\<delta>\\<^sub>c, c\\<^sub>0, c\\<^sub>1) =\n  closest_pair_bf_code (p\\<^sub>2 # p\\<^sub>3 # ps)\n  (\\<delta>\\<^sub>p, p\\<^sub>1) =\n  find_closest_bf_code p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps)\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>c = dist_code c\\<^sub>0 c\\<^sub>1", "by simp"], ["proof (state)\nthis:\n  \\<delta>\\<^sub>c = dist_code c\\<^sub>0 c\\<^sub>1\n\ngoal (4 subgoals):\n 1. \\<And>\\<delta> c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [];\n        (\\<delta>, c\\<^sub>0, c\\<^sub>1) = closest_pair_bf_code []\\<rbrakk>\n       \\<Longrightarrow> \\<delta> = dist_code c\\<^sub>0 c\\<^sub>1\n 2. \\<And>p\\<^sub>0 \\<delta> c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0];\n        (\\<delta>, c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf_code [p\\<^sub>0]\\<rbrakk>\n       \\<Longrightarrow> \\<delta> = dist_code c\\<^sub>0 c\\<^sub>1\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 \\<delta> c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        (\\<delta>, c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf_code [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> \\<delta> = dist_code c\\<^sub>0 c\\<^sub>1\n 4. \\<And>p\\<^sub>0 v vb vc \\<delta> c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>\\<And>\\<delta> c\\<^sub>0 c\\<^sub>1.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    (\\<delta>, c\\<^sub>0, c\\<^sub>1) =\n                    closest_pair_bf_code (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> \\<delta> =\n                                     dist_code c\\<^sub>0 c\\<^sub>1;\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        (\\<delta>, c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf_code (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> \\<delta> = dist_code c\\<^sub>0 c\\<^sub>1", "moreover"], ["proof (state)\nthis:\n  \\<delta>\\<^sub>c = dist_code c\\<^sub>0 c\\<^sub>1\n\ngoal (4 subgoals):\n 1. \\<And>\\<delta> c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [];\n        (\\<delta>, c\\<^sub>0, c\\<^sub>1) = closest_pair_bf_code []\\<rbrakk>\n       \\<Longrightarrow> \\<delta> = dist_code c\\<^sub>0 c\\<^sub>1\n 2. \\<And>p\\<^sub>0 \\<delta> c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0];\n        (\\<delta>, c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf_code [p\\<^sub>0]\\<rbrakk>\n       \\<Longrightarrow> \\<delta> = dist_code c\\<^sub>0 c\\<^sub>1\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 \\<delta> c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        (\\<delta>, c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf_code [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> \\<delta> = dist_code c\\<^sub>0 c\\<^sub>1\n 4. \\<And>p\\<^sub>0 v vb vc \\<delta> c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>\\<And>\\<delta> c\\<^sub>0 c\\<^sub>1.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    (\\<delta>, c\\<^sub>0, c\\<^sub>1) =\n                    closest_pair_bf_code (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> \\<delta> =\n                                     dist_code c\\<^sub>0 c\\<^sub>1;\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        (\\<delta>, c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf_code (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> \\<delta> = dist_code c\\<^sub>0 c\\<^sub>1", "have \"\\<delta>\\<^sub>p = dist_code p\\<^sub>0 p\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>p = dist_code p\\<^sub>0 p\\<^sub>1", "using find_closest_bf_code_dist_eq defs"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < length ?ps;\n   (?\\<delta>, ?c) = find_closest_bf_code ?p ?ps\\<rbrakk>\n  \\<Longrightarrow> ?\\<delta> = dist_code ?p ?c\n  (\\<delta>\\<^sub>c, c\\<^sub>0, c\\<^sub>1) =\n  closest_pair_bf_code (p\\<^sub>2 # p\\<^sub>3 # ps)\n  (\\<delta>\\<^sub>p, p\\<^sub>1) =\n  find_closest_bf_code p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps)\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>p = dist_code p\\<^sub>0 p\\<^sub>1", "by blast"], ["proof (state)\nthis:\n  \\<delta>\\<^sub>p = dist_code p\\<^sub>0 p\\<^sub>1\n\ngoal (4 subgoals):\n 1. \\<And>\\<delta> c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [];\n        (\\<delta>, c\\<^sub>0, c\\<^sub>1) = closest_pair_bf_code []\\<rbrakk>\n       \\<Longrightarrow> \\<delta> = dist_code c\\<^sub>0 c\\<^sub>1\n 2. \\<And>p\\<^sub>0 \\<delta> c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0];\n        (\\<delta>, c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf_code [p\\<^sub>0]\\<rbrakk>\n       \\<Longrightarrow> \\<delta> = dist_code c\\<^sub>0 c\\<^sub>1\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 \\<delta> c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        (\\<delta>, c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf_code [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> \\<delta> = dist_code c\\<^sub>0 c\\<^sub>1\n 4. \\<And>p\\<^sub>0 v vb vc \\<delta> c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>\\<And>\\<delta> c\\<^sub>0 c\\<^sub>1.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    (\\<delta>, c\\<^sub>0, c\\<^sub>1) =\n                    closest_pair_bf_code (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> \\<delta> =\n                                     dist_code c\\<^sub>0 c\\<^sub>1;\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        (\\<delta>, c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf_code (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> \\<delta> = dist_code c\\<^sub>0 c\\<^sub>1", "ultimately"], ["proof (chain)\npicking this:\n  \\<delta>\\<^sub>c = dist_code c\\<^sub>0 c\\<^sub>1\n  \\<delta>\\<^sub>p = dist_code p\\<^sub>0 p\\<^sub>1", "show ?case"], ["proof (prove)\nusing this:\n  \\<delta>\\<^sub>c = dist_code c\\<^sub>0 c\\<^sub>1\n  \\<delta>\\<^sub>p = dist_code p\\<^sub>0 p\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<delta> = dist_code c\\<^sub>0'__ c\\<^sub>1'__", "using \"4.prems\"(2) defs"], ["proof (prove)\nusing this:\n  \\<delta>\\<^sub>c = dist_code c\\<^sub>0 c\\<^sub>1\n  \\<delta>\\<^sub>p = dist_code p\\<^sub>0 p\\<^sub>1\n  (\\<delta>, c\\<^sub>0'__, c\\<^sub>1'__) =\n  closest_pair_bf_code (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps)\n  (\\<delta>\\<^sub>c, c\\<^sub>0, c\\<^sub>1) =\n  closest_pair_bf_code (p\\<^sub>2 # p\\<^sub>3 # ps)\n  (\\<delta>\\<^sub>p, p\\<^sub>1) =\n  find_closest_bf_code p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps)\n\ngoal (1 subgoal):\n 1. \\<delta> = dist_code c\\<^sub>0'__ c\\<^sub>1'__", "by (auto split: prod.splits if_splits)"], ["proof (state)\nthis:\n  \\<delta> = dist_code c\\<^sub>0'__ c\\<^sub>1'__\n\ngoal (3 subgoals):\n 1. \\<And>\\<delta> c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [];\n        (\\<delta>, c\\<^sub>0, c\\<^sub>1) = closest_pair_bf_code []\\<rbrakk>\n       \\<Longrightarrow> \\<delta> = dist_code c\\<^sub>0 c\\<^sub>1\n 2. \\<And>p\\<^sub>0 \\<delta> c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0];\n        (\\<delta>, c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf_code [p\\<^sub>0]\\<rbrakk>\n       \\<Longrightarrow> \\<delta> = dist_code c\\<^sub>0 c\\<^sub>1\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 \\<delta> c\\<^sub>0 c\\<^sub>1.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        (\\<delta>, c\\<^sub>0, c\\<^sub>1) =\n        closest_pair_bf_code [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> \\<delta> = dist_code c\\<^sub>0 c\\<^sub>1", "qed auto"], ["", "lemma closest_pair_bf_code_eq:\n  assumes \"1 < length ps\" \n  assumes \"(c\\<^sub>0, c\\<^sub>1) = closest_pair_bf ps\" \"(\\<delta>', c\\<^sub>0', c\\<^sub>1') = closest_pair_bf_code ps\"\n  shows \"c\\<^sub>0 = c\\<^sub>0' \\<and> c\\<^sub>1 = c\\<^sub>1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sub>0 = c\\<^sub>0' \\<and> c\\<^sub>1 = c\\<^sub>1'", "using assms"], ["proof (prove)\nusing this:\n  1 < length ps\n  (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf ps\n  (\\<delta>', c\\<^sub>0', c\\<^sub>1') = closest_pair_bf_code ps\n\ngoal (1 subgoal):\n 1. c\\<^sub>0 = c\\<^sub>0' \\<and> c\\<^sub>1 = c\\<^sub>1'", "proof (induction ps arbitrary: c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1' rule: closest_pair_bf_code.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1'.\n       \\<lbrakk>1 < length []; (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code []\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'\n 2. \\<And>p\\<^sub>0 c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1'.\n       \\<lbrakk>1 < length [p\\<^sub>0];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [p\\<^sub>0];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code [p\\<^sub>0]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0'\n       c\\<^sub>1'.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [p\\<^sub>0, p\\<^sub>1];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'\n 4. \\<And>p\\<^sub>0 v vb vc c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0'\n       c\\<^sub>1'.\n       \\<lbrakk>\\<And>c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1'.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (v # vb # vc);\n                    (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n                    closest_pair_bf_code (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                                     c\\<^sub>1 = c\\<^sub>1';\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (p\\<^sub>0 # v # vb # vc);\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'", "case (4 p\\<^sub>0 p\\<^sub>2 p\\<^sub>3 ps)"], ["proof (state)\nthis:\n  \\<lbrakk>1 < length (p\\<^sub>2 # p\\<^sub>3 # ps);\n   (?c\\<^sub>0, ?c\\<^sub>1) = closest_pair_bf (p\\<^sub>2 # p\\<^sub>3 # ps);\n   (?\\<delta>', ?c\\<^sub>0', ?c\\<^sub>1') =\n   closest_pair_bf_code (p\\<^sub>2 # p\\<^sub>3 # ps)\\<rbrakk>\n  \\<Longrightarrow> ?c\\<^sub>0 = ?c\\<^sub>0' \\<and> ?c\\<^sub>1 = ?c\\<^sub>1'\n  1 < length (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps)\n  (c\\<^sub>0, c\\<^sub>1) =\n  closest_pair_bf (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps)\n  (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n  closest_pair_bf_code (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps)\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1'.\n       \\<lbrakk>1 < length []; (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code []\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'\n 2. \\<And>p\\<^sub>0 c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1'.\n       \\<lbrakk>1 < length [p\\<^sub>0];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [p\\<^sub>0];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code [p\\<^sub>0]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0'\n       c\\<^sub>1'.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [p\\<^sub>0, p\\<^sub>1];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'\n 4. \\<And>p\\<^sub>0 v vb vc c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0'\n       c\\<^sub>1'.\n       \\<lbrakk>\\<And>c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1'.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (v # vb # vc);\n                    (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n                    closest_pair_bf_code (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                                     c\\<^sub>1 = c\\<^sub>1';\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (p\\<^sub>0 # v # vb # vc);\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'", "let ?ps = \"p\\<^sub>2 # p\\<^sub>3 # ps\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1'.\n       \\<lbrakk>1 < length []; (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code []\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'\n 2. \\<And>p\\<^sub>0 c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1'.\n       \\<lbrakk>1 < length [p\\<^sub>0];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [p\\<^sub>0];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code [p\\<^sub>0]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0'\n       c\\<^sub>1'.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [p\\<^sub>0, p\\<^sub>1];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'\n 4. \\<And>p\\<^sub>0 v vb vc c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0'\n       c\\<^sub>1'.\n       \\<lbrakk>\\<And>c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1'.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (v # vb # vc);\n                    (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n                    closest_pair_bf_code (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                                     c\\<^sub>1 = c\\<^sub>1';\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (p\\<^sub>0 # v # vb # vc);\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'", "obtain c\\<^sub>0 c\\<^sub>1 \\<delta>\\<^sub>c' c\\<^sub>0' c\\<^sub>1' where \\<delta>\\<^sub>c_def: \"(c\\<^sub>0, c\\<^sub>1) = closest_pair_bf ?ps\"\n    \"(\\<delta>\\<^sub>c', c\\<^sub>0', c\\<^sub>1') = closest_pair_bf_code ?ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c\\<^sub>0 c\\<^sub>1 \\<delta>\\<^sub>c' c\\<^sub>0' c\\<^sub>1'.\n        \\<lbrakk>(c\\<^sub>0, c\\<^sub>1) =\n                 closest_pair_bf (p\\<^sub>2 # p\\<^sub>3 # ps);\n         (\\<delta>\\<^sub>c', c\\<^sub>0', c\\<^sub>1') =\n         closest_pair_bf_code (p\\<^sub>2 # p\\<^sub>3 # ps)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (p\\<^sub>2 # p\\<^sub>3 # ps)\n  (\\<delta>\\<^sub>c', c\\<^sub>0', c\\<^sub>1') =\n  closest_pair_bf_code (p\\<^sub>2 # p\\<^sub>3 # ps)\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1'.\n       \\<lbrakk>1 < length []; (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code []\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'\n 2. \\<And>p\\<^sub>0 c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1'.\n       \\<lbrakk>1 < length [p\\<^sub>0];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [p\\<^sub>0];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code [p\\<^sub>0]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0'\n       c\\<^sub>1'.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [p\\<^sub>0, p\\<^sub>1];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'\n 4. \\<And>p\\<^sub>0 v vb vc c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0'\n       c\\<^sub>1'.\n       \\<lbrakk>\\<And>c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1'.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (v # vb # vc);\n                    (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n                    closest_pair_bf_code (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                                     c\\<^sub>1 = c\\<^sub>1';\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (p\\<^sub>0 # v # vb # vc);\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'", "obtain p\\<^sub>1 \\<delta>\\<^sub>p' p\\<^sub>1' where \\<delta>\\<^sub>p_def: \"p\\<^sub>1 = find_closest_bf p\\<^sub>0 ?ps\"\n    \"(\\<delta>\\<^sub>p', p\\<^sub>1') = find_closest_bf_code p\\<^sub>0 ?ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p\\<^sub>1 \\<delta>\\<^sub>p' p\\<^sub>1'.\n        \\<lbrakk>p\\<^sub>1 =\n                 find_closest_bf p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps);\n         (\\<delta>\\<^sub>p', p\\<^sub>1') =\n         find_closest_bf_code p\\<^sub>0\n          (p\\<^sub>2 # p\\<^sub>3 # ps)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod.collapse"], ["proof (prove)\nusing this:\n  (fst ?prod, snd ?prod) = ?prod\n\ngoal (1 subgoal):\n 1. (\\<And>p\\<^sub>1 \\<delta>\\<^sub>p' p\\<^sub>1'.\n        \\<lbrakk>p\\<^sub>1 =\n                 find_closest_bf p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps);\n         (\\<delta>\\<^sub>p', p\\<^sub>1') =\n         find_closest_bf_code p\\<^sub>0\n          (p\\<^sub>2 # p\\<^sub>3 # ps)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  p\\<^sub>1 = find_closest_bf p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps)\n  (\\<delta>\\<^sub>p', p\\<^sub>1') =\n  find_closest_bf_code p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps)\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1'.\n       \\<lbrakk>1 < length []; (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code []\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'\n 2. \\<And>p\\<^sub>0 c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1'.\n       \\<lbrakk>1 < length [p\\<^sub>0];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [p\\<^sub>0];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code [p\\<^sub>0]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0'\n       c\\<^sub>1'.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [p\\<^sub>0, p\\<^sub>1];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'\n 4. \\<And>p\\<^sub>0 v vb vc c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0'\n       c\\<^sub>1'.\n       \\<lbrakk>\\<And>c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1'.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (v # vb # vc);\n                    (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n                    closest_pair_bf_code (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                                     c\\<^sub>1 = c\\<^sub>1';\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (p\\<^sub>0 # v # vb # vc);\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'", "note defs = \\<delta>\\<^sub>c_def \\<delta>\\<^sub>p_def"], ["proof (state)\nthis:\n  (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (p\\<^sub>2 # p\\<^sub>3 # ps)\n  (\\<delta>\\<^sub>c', c\\<^sub>0', c\\<^sub>1') =\n  closest_pair_bf_code (p\\<^sub>2 # p\\<^sub>3 # ps)\n  p\\<^sub>1 = find_closest_bf p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps)\n  (\\<delta>\\<^sub>p', p\\<^sub>1') =\n  find_closest_bf_code p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps)\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1'.\n       \\<lbrakk>1 < length []; (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code []\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'\n 2. \\<And>p\\<^sub>0 c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1'.\n       \\<lbrakk>1 < length [p\\<^sub>0];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [p\\<^sub>0];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code [p\\<^sub>0]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0'\n       c\\<^sub>1'.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [p\\<^sub>0, p\\<^sub>1];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'\n 4. \\<And>p\\<^sub>0 v vb vc c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0'\n       c\\<^sub>1'.\n       \\<lbrakk>\\<And>c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1'.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (v # vb # vc);\n                    (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n                    closest_pair_bf_code (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                                     c\\<^sub>1 = c\\<^sub>1';\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (p\\<^sub>0 # v # vb # vc);\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'", "have A: \"c\\<^sub>0 = c\\<^sub>0' \\<and> c\\<^sub>1 = c\\<^sub>1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sub>0 = c\\<^sub>0' \\<and> c\\<^sub>1 = c\\<^sub>1'", "using \"4.IH\" defs"], ["proof (prove)\nusing this:\n  \\<lbrakk>1 < length (p\\<^sub>2 # p\\<^sub>3 # ps);\n   (?c\\<^sub>0, ?c\\<^sub>1) = closest_pair_bf (p\\<^sub>2 # p\\<^sub>3 # ps);\n   (?\\<delta>', ?c\\<^sub>0', ?c\\<^sub>1') =\n   closest_pair_bf_code (p\\<^sub>2 # p\\<^sub>3 # ps)\\<rbrakk>\n  \\<Longrightarrow> ?c\\<^sub>0 = ?c\\<^sub>0' \\<and> ?c\\<^sub>1 = ?c\\<^sub>1'\n  (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (p\\<^sub>2 # p\\<^sub>3 # ps)\n  (\\<delta>\\<^sub>c', c\\<^sub>0', c\\<^sub>1') =\n  closest_pair_bf_code (p\\<^sub>2 # p\\<^sub>3 # ps)\n  p\\<^sub>1 = find_closest_bf p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps)\n  (\\<delta>\\<^sub>p', p\\<^sub>1') =\n  find_closest_bf_code p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps)\n\ngoal (1 subgoal):\n 1. c\\<^sub>0 = c\\<^sub>0' \\<and> c\\<^sub>1 = c\\<^sub>1'", "by simp"], ["proof (state)\nthis:\n  c\\<^sub>0 = c\\<^sub>0' \\<and> c\\<^sub>1 = c\\<^sub>1'\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1'.\n       \\<lbrakk>1 < length []; (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code []\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'\n 2. \\<And>p\\<^sub>0 c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1'.\n       \\<lbrakk>1 < length [p\\<^sub>0];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [p\\<^sub>0];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code [p\\<^sub>0]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0'\n       c\\<^sub>1'.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [p\\<^sub>0, p\\<^sub>1];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'\n 4. \\<And>p\\<^sub>0 v vb vc c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0'\n       c\\<^sub>1'.\n       \\<lbrakk>\\<And>c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1'.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (v # vb # vc);\n                    (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n                    closest_pair_bf_code (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                                     c\\<^sub>1 = c\\<^sub>1';\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (p\\<^sub>0 # v # vb # vc);\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'", "moreover"], ["proof (state)\nthis:\n  c\\<^sub>0 = c\\<^sub>0' \\<and> c\\<^sub>1 = c\\<^sub>1'\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1'.\n       \\<lbrakk>1 < length []; (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code []\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'\n 2. \\<And>p\\<^sub>0 c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1'.\n       \\<lbrakk>1 < length [p\\<^sub>0];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [p\\<^sub>0];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code [p\\<^sub>0]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0'\n       c\\<^sub>1'.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [p\\<^sub>0, p\\<^sub>1];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'\n 4. \\<And>p\\<^sub>0 v vb vc c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0'\n       c\\<^sub>1'.\n       \\<lbrakk>\\<And>c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1'.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (v # vb # vc);\n                    (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n                    closest_pair_bf_code (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                                     c\\<^sub>1 = c\\<^sub>1';\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (p\\<^sub>0 # v # vb # vc);\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'", "have B: \"p\\<^sub>1 = p\\<^sub>1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p\\<^sub>1 = p\\<^sub>1'", "using find_closest_bf_code_eq defs"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < length ?ps; ?c = find_closest_bf ?p ?ps;\n   (?\\<delta>', ?c') = find_closest_bf_code ?p ?ps\\<rbrakk>\n  \\<Longrightarrow> ?c = ?c'\n  (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (p\\<^sub>2 # p\\<^sub>3 # ps)\n  (\\<delta>\\<^sub>c', c\\<^sub>0', c\\<^sub>1') =\n  closest_pair_bf_code (p\\<^sub>2 # p\\<^sub>3 # ps)\n  p\\<^sub>1 = find_closest_bf p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps)\n  (\\<delta>\\<^sub>p', p\\<^sub>1') =\n  find_closest_bf_code p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps)\n\ngoal (1 subgoal):\n 1. p\\<^sub>1 = p\\<^sub>1'", "by blast"], ["proof (state)\nthis:\n  p\\<^sub>1 = p\\<^sub>1'\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1'.\n       \\<lbrakk>1 < length []; (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code []\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'\n 2. \\<And>p\\<^sub>0 c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1'.\n       \\<lbrakk>1 < length [p\\<^sub>0];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [p\\<^sub>0];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code [p\\<^sub>0]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0'\n       c\\<^sub>1'.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [p\\<^sub>0, p\\<^sub>1];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'\n 4. \\<And>p\\<^sub>0 v vb vc c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0'\n       c\\<^sub>1'.\n       \\<lbrakk>\\<And>c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1'.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (v # vb # vc);\n                    (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n                    closest_pair_bf_code (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                                     c\\<^sub>1 = c\\<^sub>1';\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (p\\<^sub>0 # v # vb # vc);\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'", "moreover"], ["proof (state)\nthis:\n  p\\<^sub>1 = p\\<^sub>1'\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1'.\n       \\<lbrakk>1 < length []; (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code []\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'\n 2. \\<And>p\\<^sub>0 c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1'.\n       \\<lbrakk>1 < length [p\\<^sub>0];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [p\\<^sub>0];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code [p\\<^sub>0]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0'\n       c\\<^sub>1'.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [p\\<^sub>0, p\\<^sub>1];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'\n 4. \\<And>p\\<^sub>0 v vb vc c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0'\n       c\\<^sub>1'.\n       \\<lbrakk>\\<And>c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1'.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (v # vb # vc);\n                    (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n                    closest_pair_bf_code (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                                     c\\<^sub>1 = c\\<^sub>1';\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (p\\<^sub>0 # v # vb # vc);\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'", "have \"\\<delta>\\<^sub>c' = dist_code c\\<^sub>0' c\\<^sub>1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>c' = dist_code c\\<^sub>0' c\\<^sub>1'", "using defs closest_pair_bf_code_dist_eq[of ?ps]"], ["proof (prove)\nusing this:\n  (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (p\\<^sub>2 # p\\<^sub>3 # ps)\n  (\\<delta>\\<^sub>c', c\\<^sub>0', c\\<^sub>1') =\n  closest_pair_bf_code (p\\<^sub>2 # p\\<^sub>3 # ps)\n  p\\<^sub>1 = find_closest_bf p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps)\n  (\\<delta>\\<^sub>p', p\\<^sub>1') =\n  find_closest_bf_code p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps)\n  \\<lbrakk>1 < length (p\\<^sub>2 # p\\<^sub>3 # ps);\n   (?\\<delta>, ?c\\<^sub>0, ?c\\<^sub>1) =\n   closest_pair_bf_code (p\\<^sub>2 # p\\<^sub>3 # ps)\\<rbrakk>\n  \\<Longrightarrow> ?\\<delta> = dist_code ?c\\<^sub>0 ?c\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>c' = dist_code c\\<^sub>0' c\\<^sub>1'", "by simp"], ["proof (state)\nthis:\n  \\<delta>\\<^sub>c' = dist_code c\\<^sub>0' c\\<^sub>1'\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1'.\n       \\<lbrakk>1 < length []; (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code []\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'\n 2. \\<And>p\\<^sub>0 c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1'.\n       \\<lbrakk>1 < length [p\\<^sub>0];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [p\\<^sub>0];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code [p\\<^sub>0]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0'\n       c\\<^sub>1'.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [p\\<^sub>0, p\\<^sub>1];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'\n 4. \\<And>p\\<^sub>0 v vb vc c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0'\n       c\\<^sub>1'.\n       \\<lbrakk>\\<And>c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1'.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (v # vb # vc);\n                    (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n                    closest_pair_bf_code (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                                     c\\<^sub>1 = c\\<^sub>1';\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (p\\<^sub>0 # v # vb # vc);\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'", "moreover"], ["proof (state)\nthis:\n  \\<delta>\\<^sub>c' = dist_code c\\<^sub>0' c\\<^sub>1'\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1'.\n       \\<lbrakk>1 < length []; (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code []\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'\n 2. \\<And>p\\<^sub>0 c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1'.\n       \\<lbrakk>1 < length [p\\<^sub>0];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [p\\<^sub>0];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code [p\\<^sub>0]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0'\n       c\\<^sub>1'.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [p\\<^sub>0, p\\<^sub>1];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'\n 4. \\<And>p\\<^sub>0 v vb vc c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0'\n       c\\<^sub>1'.\n       \\<lbrakk>\\<And>c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1'.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (v # vb # vc);\n                    (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n                    closest_pair_bf_code (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                                     c\\<^sub>1 = c\\<^sub>1';\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (p\\<^sub>0 # v # vb # vc);\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'", "have \"\\<delta>\\<^sub>p' = dist_code p\\<^sub>0 p\\<^sub>1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>p' = dist_code p\\<^sub>0 p\\<^sub>1'", "using defs find_closest_bf_code_dist_eq"], ["proof (prove)\nusing this:\n  (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (p\\<^sub>2 # p\\<^sub>3 # ps)\n  (\\<delta>\\<^sub>c', c\\<^sub>0', c\\<^sub>1') =\n  closest_pair_bf_code (p\\<^sub>2 # p\\<^sub>3 # ps)\n  p\\<^sub>1 = find_closest_bf p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps)\n  (\\<delta>\\<^sub>p', p\\<^sub>1') =\n  find_closest_bf_code p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps)\n  \\<lbrakk>0 < length ?ps;\n   (?\\<delta>, ?c) = find_closest_bf_code ?p ?ps\\<rbrakk>\n  \\<Longrightarrow> ?\\<delta> = dist_code ?p ?c\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>p' = dist_code p\\<^sub>0 p\\<^sub>1'", "by blast"], ["proof (state)\nthis:\n  \\<delta>\\<^sub>p' = dist_code p\\<^sub>0 p\\<^sub>1'\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1'.\n       \\<lbrakk>1 < length []; (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code []\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'\n 2. \\<And>p\\<^sub>0 c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1'.\n       \\<lbrakk>1 < length [p\\<^sub>0];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [p\\<^sub>0];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code [p\\<^sub>0]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0'\n       c\\<^sub>1'.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [p\\<^sub>0, p\\<^sub>1];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'\n 4. \\<And>p\\<^sub>0 v vb vc c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0'\n       c\\<^sub>1'.\n       \\<lbrakk>\\<And>c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1'.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (v # vb # vc);\n                    (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n                    closest_pair_bf_code (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                                     c\\<^sub>1 = c\\<^sub>1';\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (p\\<^sub>0 # v # vb # vc);\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'", "ultimately"], ["proof (chain)\npicking this:\n  c\\<^sub>0 = c\\<^sub>0' \\<and> c\\<^sub>1 = c\\<^sub>1'\n  p\\<^sub>1 = p\\<^sub>1'\n  \\<delta>\\<^sub>c' = dist_code c\\<^sub>0' c\\<^sub>1'\n  \\<delta>\\<^sub>p' = dist_code p\\<^sub>0 p\\<^sub>1'", "have \"dist c\\<^sub>0 c\\<^sub>1 \\<le> dist p\\<^sub>0 p\\<^sub>1 \\<longleftrightarrow> \\<delta>\\<^sub>c' \\<le> \\<delta>\\<^sub>p'\""], ["proof (prove)\nusing this:\n  c\\<^sub>0 = c\\<^sub>0' \\<and> c\\<^sub>1 = c\\<^sub>1'\n  p\\<^sub>1 = p\\<^sub>1'\n  \\<delta>\\<^sub>c' = dist_code c\\<^sub>0' c\\<^sub>1'\n  \\<delta>\\<^sub>p' = dist_code p\\<^sub>0 p\\<^sub>1'\n\ngoal (1 subgoal):\n 1. (dist\n      (case c\\<^sub>0 of\n       (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n      (case c\\<^sub>1 of\n       (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     \\<le> dist\n            (case p\\<^sub>0 of\n             (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n            (case p\\<^sub>1 of\n             (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))) =\n    (\\<delta>\\<^sub>c' \\<le> \\<delta>\\<^sub>p')", "by (simp add: dist_eq_dist_code_le)"], ["proof (state)\nthis:\n  (dist\n    (case c\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n    (case c\\<^sub>1 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n   \\<le> dist\n          (case p\\<^sub>0 of\n           (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n          (case p\\<^sub>1 of\n           (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))) =\n  (\\<delta>\\<^sub>c' \\<le> \\<delta>\\<^sub>p')\n\ngoal (4 subgoals):\n 1. \\<And>c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1'.\n       \\<lbrakk>1 < length []; (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code []\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'\n 2. \\<And>p\\<^sub>0 c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1'.\n       \\<lbrakk>1 < length [p\\<^sub>0];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [p\\<^sub>0];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code [p\\<^sub>0]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0'\n       c\\<^sub>1'.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [p\\<^sub>0, p\\<^sub>1];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'\n 4. \\<And>p\\<^sub>0 v vb vc c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0'\n       c\\<^sub>1'.\n       \\<lbrakk>\\<And>c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1'.\n                   \\<lbrakk>1 < length (v # vb # vc);\n                    (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (v # vb # vc);\n                    (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n                    closest_pair_bf_code (v # vb # vc)\\<rbrakk>\n                   \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                                     c\\<^sub>1 = c\\<^sub>1';\n        1 < length (p\\<^sub>0 # v # vb # vc);\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (p\\<^sub>0 # v # vb # vc);\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code (p\\<^sub>0 # v # vb # vc)\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'", "thus ?case"], ["proof (prove)\nusing this:\n  (dist\n    (case c\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n    (case c\\<^sub>1 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n   \\<le> dist\n          (case p\\<^sub>0 of\n           (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n          (case p\\<^sub>1 of\n           (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))) =\n  (\\<delta>\\<^sub>c' \\<le> \\<delta>\\<^sub>p')\n\ngoal (1 subgoal):\n 1. c\\<^sub>0''__ = c\\<^sub>0'''__ \\<and> c\\<^sub>1''__ = c\\<^sub>1'''__", "using \"4.prems\"(2,3) defs A B"], ["proof (prove)\nusing this:\n  (dist\n    (case c\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n    (case c\\<^sub>1 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n   \\<le> dist\n          (case p\\<^sub>0 of\n           (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n          (case p\\<^sub>1 of\n           (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))) =\n  (\\<delta>\\<^sub>c' \\<le> \\<delta>\\<^sub>p')\n  (c\\<^sub>0''__, c\\<^sub>1''__) =\n  closest_pair_bf (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps)\n  (\\<delta>', c\\<^sub>0'''__, c\\<^sub>1'''__) =\n  closest_pair_bf_code (p\\<^sub>0 # p\\<^sub>2 # p\\<^sub>3 # ps)\n  (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf (p\\<^sub>2 # p\\<^sub>3 # ps)\n  (\\<delta>\\<^sub>c', c\\<^sub>0', c\\<^sub>1') =\n  closest_pair_bf_code (p\\<^sub>2 # p\\<^sub>3 # ps)\n  p\\<^sub>1 = find_closest_bf p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps)\n  (\\<delta>\\<^sub>p', p\\<^sub>1') =\n  find_closest_bf_code p\\<^sub>0 (p\\<^sub>2 # p\\<^sub>3 # ps)\n  c\\<^sub>0 = c\\<^sub>0' \\<and> c\\<^sub>1 = c\\<^sub>1'\n  p\\<^sub>1 = p\\<^sub>1'\n\ngoal (1 subgoal):\n 1. c\\<^sub>0''__ = c\\<^sub>0'''__ \\<and> c\\<^sub>1''__ = c\\<^sub>1'''__", "by (auto simp: Let_def split: prod.splits)"], ["proof (state)\nthis:\n  c\\<^sub>0''__ = c\\<^sub>0'''__ \\<and> c\\<^sub>1''__ = c\\<^sub>1'''__\n\ngoal (3 subgoals):\n 1. \\<And>c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1'.\n       \\<lbrakk>1 < length []; (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code []\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'\n 2. \\<And>p\\<^sub>0 c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0' c\\<^sub>1'.\n       \\<lbrakk>1 < length [p\\<^sub>0];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [p\\<^sub>0];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code [p\\<^sub>0]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'\n 3. \\<And>p\\<^sub>0 p\\<^sub>1 c\\<^sub>0 c\\<^sub>1 \\<delta>' c\\<^sub>0'\n       c\\<^sub>1'.\n       \\<lbrakk>1 < length [p\\<^sub>0, p\\<^sub>1];\n        (c\\<^sub>0, c\\<^sub>1) = closest_pair_bf [p\\<^sub>0, p\\<^sub>1];\n        (\\<delta>', c\\<^sub>0', c\\<^sub>1') =\n        closest_pair_bf_code [p\\<^sub>0, p\\<^sub>1]\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>0 = c\\<^sub>0' \\<and>\n                         c\\<^sub>1 = c\\<^sub>1'", "qed auto"], ["", "subsection \"Geometry\""], ["", "subsubsection \"Band Filter\""], ["", "lemma set_band_filter_aux:\n  fixes \\<delta> :: real and ps :: \"point list\"\n  assumes \"p\\<^sub>0 \\<in> ps\\<^sub>L\" \"p\\<^sub>1 \\<in> ps\\<^sub>R\" \"p\\<^sub>0 \\<noteq> p\\<^sub>1\" \"dist p\\<^sub>0 p\\<^sub>1 < \\<delta>\" \"set ps = ps\\<^sub>L \\<union> ps\\<^sub>R\"\n  assumes \"\\<forall>p \\<in> ps\\<^sub>L. fst p \\<le> l\" \"\\<forall>p \\<in> ps\\<^sub>R. l \\<le> fst p\"\n  assumes \"ps' = filter (\\<lambda>p. l - \\<delta> < fst p \\<and> fst p < l + \\<delta>) ps\"\n  shows \"p\\<^sub>0 \\<in> set ps' \\<and> p\\<^sub>1 \\<in> set ps'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p\\<^sub>0 \\<in> set ps' \\<and> p\\<^sub>1 \\<in> set ps'", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (p\\<^sub>0 \\<in> set ps' \\<and>\n            p\\<^sub>1 \\<in> set ps') \\<Longrightarrow>\n    False", "assume \"\\<not> (p\\<^sub>0 \\<in> set ps' \\<and> p\\<^sub>1 \\<in> set ps')\""], ["proof (state)\nthis:\n  \\<not> (p\\<^sub>0 \\<in> set ps' \\<and> p\\<^sub>1 \\<in> set ps')\n\ngoal (1 subgoal):\n 1. \\<not> (p\\<^sub>0 \\<in> set ps' \\<and>\n            p\\<^sub>1 \\<in> set ps') \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (p\\<^sub>0 \\<in> set ps' \\<and> p\\<^sub>1 \\<in> set ps')", "consider (A) \"p\\<^sub>0 \\<notin> set ps' \\<and> p\\<^sub>1 \\<notin> set ps'\"\n              | (B) \"p\\<^sub>0 \\<in> set ps' \\<and> p\\<^sub>1 \\<notin> set ps'\"\n              | (C) \"p\\<^sub>0 \\<notin> set ps' \\<and> p\\<^sub>1 \\<in> set ps'\""], ["proof (prove)\nusing this:\n  \\<not> (p\\<^sub>0 \\<in> set ps' \\<and> p\\<^sub>1 \\<in> set ps')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p\\<^sub>0 \\<notin> set ps' \\<and>\n             p\\<^sub>1 \\<notin> set ps' \\<Longrightarrow>\n             thesis;\n     p\\<^sub>0 \\<in> set ps' \\<and>\n     p\\<^sub>1 \\<notin> set ps' \\<Longrightarrow>\n     thesis;\n     p\\<^sub>0 \\<notin> set ps' \\<and>\n     p\\<^sub>1 \\<in> set ps' \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>p\\<^sub>0 \\<notin> set ps' \\<and>\n           p\\<^sub>1 \\<notin> set ps' \\<Longrightarrow>\n           ?thesis;\n   p\\<^sub>0 \\<in> set ps' \\<and>\n   p\\<^sub>1 \\<notin> set ps' \\<Longrightarrow>\n   ?thesis;\n   p\\<^sub>0 \\<notin> set ps' \\<and>\n   p\\<^sub>1 \\<in> set ps' \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<not> (p\\<^sub>0 \\<in> set ps' \\<and>\n            p\\<^sub>1 \\<in> set ps') \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  \\<lbrakk>p\\<^sub>0 \\<notin> set ps' \\<and>\n           p\\<^sub>1 \\<notin> set ps' \\<Longrightarrow>\n           ?thesis;\n   p\\<^sub>0 \\<in> set ps' \\<and>\n   p\\<^sub>1 \\<notin> set ps' \\<Longrightarrow>\n   ?thesis;\n   p\\<^sub>0 \\<notin> set ps' \\<and>\n   p\\<^sub>1 \\<in> set ps' \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. False", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. p\\<^sub>0 \\<notin> set ps' \\<and>\n    p\\<^sub>1 \\<notin> set ps' \\<Longrightarrow>\n    False\n 2. p\\<^sub>0 \\<in> set ps' \\<and>\n    p\\<^sub>1 \\<notin> set ps' \\<Longrightarrow>\n    False\n 3. p\\<^sub>0 \\<notin> set ps' \\<and>\n    p\\<^sub>1 \\<in> set ps' \\<Longrightarrow>\n    False", "case A"], ["proof (state)\nthis:\n  p\\<^sub>0 \\<notin> set ps' \\<and> p\\<^sub>1 \\<notin> set ps'\n\ngoal (3 subgoals):\n 1. p\\<^sub>0 \\<notin> set ps' \\<and>\n    p\\<^sub>1 \\<notin> set ps' \\<Longrightarrow>\n    False\n 2. p\\<^sub>0 \\<in> set ps' \\<and>\n    p\\<^sub>1 \\<notin> set ps' \\<Longrightarrow>\n    False\n 3. p\\<^sub>0 \\<notin> set ps' \\<and>\n    p\\<^sub>1 \\<in> set ps' \\<Longrightarrow>\n    False", "hence \"fst p\\<^sub>0 \\<le> l - \\<delta> \\<or> l + \\<delta> \\<le> fst p\\<^sub>0\" \"fst p\\<^sub>1 \\<le> l - \\<delta> \\<or> l + \\<delta> \\<le> fst p\\<^sub>1\""], ["proof (prove)\nusing this:\n  p\\<^sub>0 \\<notin> set ps' \\<and> p\\<^sub>1 \\<notin> set ps'\n\ngoal (1 subgoal):\n 1. real_of_int (fst p\\<^sub>0) \\<le> real_of_int l - \\<delta> \\<or>\n    real_of_int l + \\<delta> \\<le> real_of_int (fst p\\<^sub>0) &&&\n    real_of_int (fst p\\<^sub>1) \\<le> real_of_int l - \\<delta> \\<or>\n    real_of_int l + \\<delta> \\<le> real_of_int (fst p\\<^sub>1)", "using assms(1,2,5,8)"], ["proof (prove)\nusing this:\n  p\\<^sub>0 \\<notin> set ps' \\<and> p\\<^sub>1 \\<notin> set ps'\n  p\\<^sub>0 \\<in> ps\\<^sub>L\n  p\\<^sub>1 \\<in> ps\\<^sub>R\n  set ps = ps\\<^sub>L \\<union> ps\\<^sub>R\n  ps' =\n  filter\n   (\\<lambda>p.\n       real_of_int l - \\<delta> < real_of_int (fst p) \\<and>\n       real_of_int (fst p) < real_of_int l + \\<delta>)\n   ps\n\ngoal (1 subgoal):\n 1. real_of_int (fst p\\<^sub>0) \\<le> real_of_int l - \\<delta> \\<or>\n    real_of_int l + \\<delta> \\<le> real_of_int (fst p\\<^sub>0) &&&\n    real_of_int (fst p\\<^sub>1) \\<le> real_of_int l - \\<delta> \\<or>\n    real_of_int l + \\<delta> \\<le> real_of_int (fst p\\<^sub>1)", "by auto"], ["proof (state)\nthis:\n  real_of_int (fst p\\<^sub>0) \\<le> real_of_int l - \\<delta> \\<or>\n  real_of_int l + \\<delta> \\<le> real_of_int (fst p\\<^sub>0)\n  real_of_int (fst p\\<^sub>1) \\<le> real_of_int l - \\<delta> \\<or>\n  real_of_int l + \\<delta> \\<le> real_of_int (fst p\\<^sub>1)\n\ngoal (3 subgoals):\n 1. p\\<^sub>0 \\<notin> set ps' \\<and>\n    p\\<^sub>1 \\<notin> set ps' \\<Longrightarrow>\n    False\n 2. p\\<^sub>0 \\<in> set ps' \\<and>\n    p\\<^sub>1 \\<notin> set ps' \\<Longrightarrow>\n    False\n 3. p\\<^sub>0 \\<notin> set ps' \\<and>\n    p\\<^sub>1 \\<in> set ps' \\<Longrightarrow>\n    False", "hence \"fst p\\<^sub>0 \\<le> l - \\<delta>\" \"l + \\<delta> \\<le> fst p\\<^sub>1\""], ["proof (prove)\nusing this:\n  real_of_int (fst p\\<^sub>0) \\<le> real_of_int l - \\<delta> \\<or>\n  real_of_int l + \\<delta> \\<le> real_of_int (fst p\\<^sub>0)\n  real_of_int (fst p\\<^sub>1) \\<le> real_of_int l - \\<delta> \\<or>\n  real_of_int l + \\<delta> \\<le> real_of_int (fst p\\<^sub>1)\n\ngoal (1 subgoal):\n 1. real_of_int (fst p\\<^sub>0) \\<le> real_of_int l - \\<delta> &&&\n    real_of_int l + \\<delta> \\<le> real_of_int (fst p\\<^sub>1)", "using assms(1,2,6,7)"], ["proof (prove)\nusing this:\n  real_of_int (fst p\\<^sub>0) \\<le> real_of_int l - \\<delta> \\<or>\n  real_of_int l + \\<delta> \\<le> real_of_int (fst p\\<^sub>0)\n  real_of_int (fst p\\<^sub>1) \\<le> real_of_int l - \\<delta> \\<or>\n  real_of_int l + \\<delta> \\<le> real_of_int (fst p\\<^sub>1)\n  p\\<^sub>0 \\<in> ps\\<^sub>L\n  p\\<^sub>1 \\<in> ps\\<^sub>R\n  \\<forall>p\\<in>ps\\<^sub>L. fst p \\<le> l\n  \\<forall>p\\<in>ps\\<^sub>R. l \\<le> fst p\n\ngoal (1 subgoal):\n 1. real_of_int (fst p\\<^sub>0) \\<le> real_of_int l - \\<delta> &&&\n    real_of_int l + \\<delta> \\<le> real_of_int (fst p\\<^sub>1)", "by force+"], ["proof (state)\nthis:\n  real_of_int (fst p\\<^sub>0) \\<le> real_of_int l - \\<delta>\n  real_of_int l + \\<delta> \\<le> real_of_int (fst p\\<^sub>1)\n\ngoal (3 subgoals):\n 1. p\\<^sub>0 \\<notin> set ps' \\<and>\n    p\\<^sub>1 \\<notin> set ps' \\<Longrightarrow>\n    False\n 2. p\\<^sub>0 \\<in> set ps' \\<and>\n    p\\<^sub>1 \\<notin> set ps' \\<Longrightarrow>\n    False\n 3. p\\<^sub>0 \\<notin> set ps' \\<and>\n    p\\<^sub>1 \\<in> set ps' \\<Longrightarrow>\n    False", "hence \"\\<delta> \\<le> dist (fst p\\<^sub>0) (fst p\\<^sub>1)\""], ["proof (prove)\nusing this:\n  real_of_int (fst p\\<^sub>0) \\<le> real_of_int l - \\<delta>\n  real_of_int l + \\<delta> \\<le> real_of_int (fst p\\<^sub>1)\n\ngoal (1 subgoal):\n 1. \\<delta>\n    \\<le> dist (real_of_int (fst p\\<^sub>0)) (real_of_int (fst p\\<^sub>1))", "using dist_real_def"], ["proof (prove)\nusing this:\n  real_of_int (fst p\\<^sub>0) \\<le> real_of_int l - \\<delta>\n  real_of_int l + \\<delta> \\<le> real_of_int (fst p\\<^sub>1)\n  dist ?x ?y = \\<bar>?x - ?y\\<bar>\n\ngoal (1 subgoal):\n 1. \\<delta>\n    \\<le> dist (real_of_int (fst p\\<^sub>0)) (real_of_int (fst p\\<^sub>1))", "by simp"], ["proof (state)\nthis:\n  \\<delta>\n  \\<le> dist (real_of_int (fst p\\<^sub>0)) (real_of_int (fst p\\<^sub>1))\n\ngoal (3 subgoals):\n 1. p\\<^sub>0 \\<notin> set ps' \\<and>\n    p\\<^sub>1 \\<notin> set ps' \\<Longrightarrow>\n    False\n 2. p\\<^sub>0 \\<in> set ps' \\<and>\n    p\\<^sub>1 \\<notin> set ps' \\<Longrightarrow>\n    False\n 3. p\\<^sub>0 \\<notin> set ps' \\<and>\n    p\\<^sub>1 \\<in> set ps' \\<Longrightarrow>\n    False", "hence \"\\<delta> \\<le> dist p\\<^sub>0 p\\<^sub>1\""], ["proof (prove)\nusing this:\n  \\<delta>\n  \\<le> dist (real_of_int (fst p\\<^sub>0)) (real_of_int (fst p\\<^sub>1))\n\ngoal (1 subgoal):\n 1. \\<delta>\n    \\<le> dist\n           (case p\\<^sub>0 of\n            (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n           (case p\\<^sub>1 of\n            (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))", "using dist_fst_le[of p\\<^sub>0 p\\<^sub>1]"], ["proof (prove)\nusing this:\n  \\<delta>\n  \\<le> dist (real_of_int (fst p\\<^sub>0)) (real_of_int (fst p\\<^sub>1))\n  dist\n   (fst (case p\\<^sub>0 of\n         (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n   (fst (case p\\<^sub>1 of\n         (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n  \\<le> dist\n         (case p\\<^sub>0 of\n          (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n         (case p\\<^sub>1 of\n          (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n\ngoal (1 subgoal):\n 1. \\<delta>\n    \\<le> dist\n           (case p\\<^sub>0 of\n            (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n           (case p\\<^sub>1 of\n            (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))", "by (auto split: prod.splits)"], ["proof (state)\nthis:\n  \\<delta>\n  \\<le> dist\n         (case p\\<^sub>0 of\n          (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n         (case p\\<^sub>1 of\n          (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n\ngoal (3 subgoals):\n 1. p\\<^sub>0 \\<notin> set ps' \\<and>\n    p\\<^sub>1 \\<notin> set ps' \\<Longrightarrow>\n    False\n 2. p\\<^sub>0 \\<in> set ps' \\<and>\n    p\\<^sub>1 \\<notin> set ps' \\<Longrightarrow>\n    False\n 3. p\\<^sub>0 \\<notin> set ps' \\<and>\n    p\\<^sub>1 \\<in> set ps' \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<delta>\n  \\<le> dist\n         (case p\\<^sub>0 of\n          (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n         (case p\\<^sub>1 of\n          (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<delta>\n  \\<le> dist\n         (case p\\<^sub>0 of\n          (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n         (case p\\<^sub>1 of\n          (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n\ngoal (1 subgoal):\n 1. False", "using assms(4)"], ["proof (prove)\nusing this:\n  \\<delta>\n  \\<le> dist\n         (case p\\<^sub>0 of\n          (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n         (case p\\<^sub>1 of\n          (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n  dist\n   (case p\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n   (case p\\<^sub>1 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n  < \\<delta>\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. p\\<^sub>0 \\<in> set ps' \\<and>\n    p\\<^sub>1 \\<notin> set ps' \\<Longrightarrow>\n    False\n 2. p\\<^sub>0 \\<notin> set ps' \\<and>\n    p\\<^sub>1 \\<in> set ps' \\<Longrightarrow>\n    False", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. p\\<^sub>0 \\<in> set ps' \\<and>\n    p\\<^sub>1 \\<notin> set ps' \\<Longrightarrow>\n    False\n 2. p\\<^sub>0 \\<notin> set ps' \\<and>\n    p\\<^sub>1 \\<in> set ps' \\<Longrightarrow>\n    False", "case B"], ["proof (state)\nthis:\n  p\\<^sub>0 \\<in> set ps' \\<and> p\\<^sub>1 \\<notin> set ps'\n\ngoal (2 subgoals):\n 1. p\\<^sub>0 \\<in> set ps' \\<and>\n    p\\<^sub>1 \\<notin> set ps' \\<Longrightarrow>\n    False\n 2. p\\<^sub>0 \\<notin> set ps' \\<and>\n    p\\<^sub>1 \\<in> set ps' \\<Longrightarrow>\n    False", "hence \"fst p\\<^sub>1 \\<le> l - \\<delta> \\<or> l + \\<delta> \\<le> fst p\\<^sub>1\""], ["proof (prove)\nusing this:\n  p\\<^sub>0 \\<in> set ps' \\<and> p\\<^sub>1 \\<notin> set ps'\n\ngoal (1 subgoal):\n 1. real_of_int (fst p\\<^sub>1) \\<le> real_of_int l - \\<delta> \\<or>\n    real_of_int l + \\<delta> \\<le> real_of_int (fst p\\<^sub>1)", "using assms(2,5,8)"], ["proof (prove)\nusing this:\n  p\\<^sub>0 \\<in> set ps' \\<and> p\\<^sub>1 \\<notin> set ps'\n  p\\<^sub>1 \\<in> ps\\<^sub>R\n  set ps = ps\\<^sub>L \\<union> ps\\<^sub>R\n  ps' =\n  filter\n   (\\<lambda>p.\n       real_of_int l - \\<delta> < real_of_int (fst p) \\<and>\n       real_of_int (fst p) < real_of_int l + \\<delta>)\n   ps\n\ngoal (1 subgoal):\n 1. real_of_int (fst p\\<^sub>1) \\<le> real_of_int l - \\<delta> \\<or>\n    real_of_int l + \\<delta> \\<le> real_of_int (fst p\\<^sub>1)", "by auto"], ["proof (state)\nthis:\n  real_of_int (fst p\\<^sub>1) \\<le> real_of_int l - \\<delta> \\<or>\n  real_of_int l + \\<delta> \\<le> real_of_int (fst p\\<^sub>1)\n\ngoal (2 subgoals):\n 1. p\\<^sub>0 \\<in> set ps' \\<and>\n    p\\<^sub>1 \\<notin> set ps' \\<Longrightarrow>\n    False\n 2. p\\<^sub>0 \\<notin> set ps' \\<and>\n    p\\<^sub>1 \\<in> set ps' \\<Longrightarrow>\n    False", "hence \"l + \\<delta> \\<le> fst p\\<^sub>1\""], ["proof (prove)\nusing this:\n  real_of_int (fst p\\<^sub>1) \\<le> real_of_int l - \\<delta> \\<or>\n  real_of_int l + \\<delta> \\<le> real_of_int (fst p\\<^sub>1)\n\ngoal (1 subgoal):\n 1. real_of_int l + \\<delta> \\<le> real_of_int (fst p\\<^sub>1)", "using assms(2,7)"], ["proof (prove)\nusing this:\n  real_of_int (fst p\\<^sub>1) \\<le> real_of_int l - \\<delta> \\<or>\n  real_of_int l + \\<delta> \\<le> real_of_int (fst p\\<^sub>1)\n  p\\<^sub>1 \\<in> ps\\<^sub>R\n  \\<forall>p\\<in>ps\\<^sub>R. l \\<le> fst p\n\ngoal (1 subgoal):\n 1. real_of_int l + \\<delta> \\<le> real_of_int (fst p\\<^sub>1)", "by auto"], ["proof (state)\nthis:\n  real_of_int l + \\<delta> \\<le> real_of_int (fst p\\<^sub>1)\n\ngoal (2 subgoals):\n 1. p\\<^sub>0 \\<in> set ps' \\<and>\n    p\\<^sub>1 \\<notin> set ps' \\<Longrightarrow>\n    False\n 2. p\\<^sub>0 \\<notin> set ps' \\<and>\n    p\\<^sub>1 \\<in> set ps' \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  real_of_int l + \\<delta> \\<le> real_of_int (fst p\\<^sub>1)\n\ngoal (2 subgoals):\n 1. p\\<^sub>0 \\<in> set ps' \\<and>\n    p\\<^sub>1 \\<notin> set ps' \\<Longrightarrow>\n    False\n 2. p\\<^sub>0 \\<notin> set ps' \\<and>\n    p\\<^sub>1 \\<in> set ps' \\<Longrightarrow>\n    False", "have \"fst p\\<^sub>0 \\<le> l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst p\\<^sub>0 \\<le> l", "using assms(1,6)"], ["proof (prove)\nusing this:\n  p\\<^sub>0 \\<in> ps\\<^sub>L\n  \\<forall>p\\<in>ps\\<^sub>L. fst p \\<le> l\n\ngoal (1 subgoal):\n 1. fst p\\<^sub>0 \\<le> l", "by simp"], ["proof (state)\nthis:\n  fst p\\<^sub>0 \\<le> l\n\ngoal (2 subgoals):\n 1. p\\<^sub>0 \\<in> set ps' \\<and>\n    p\\<^sub>1 \\<notin> set ps' \\<Longrightarrow>\n    False\n 2. p\\<^sub>0 \\<notin> set ps' \\<and>\n    p\\<^sub>1 \\<in> set ps' \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  real_of_int l + \\<delta> \\<le> real_of_int (fst p\\<^sub>1)\n  fst p\\<^sub>0 \\<le> l", "have \"\\<delta> \\<le> dist (fst p\\<^sub>0) (fst p\\<^sub>1)\""], ["proof (prove)\nusing this:\n  real_of_int l + \\<delta> \\<le> real_of_int (fst p\\<^sub>1)\n  fst p\\<^sub>0 \\<le> l\n\ngoal (1 subgoal):\n 1. \\<delta>\n    \\<le> dist (real_of_int (fst p\\<^sub>0)) (real_of_int (fst p\\<^sub>1))", "using dist_real_def"], ["proof (prove)\nusing this:\n  real_of_int l + \\<delta> \\<le> real_of_int (fst p\\<^sub>1)\n  fst p\\<^sub>0 \\<le> l\n  dist ?x ?y = \\<bar>?x - ?y\\<bar>\n\ngoal (1 subgoal):\n 1. \\<delta>\n    \\<le> dist (real_of_int (fst p\\<^sub>0)) (real_of_int (fst p\\<^sub>1))", "by simp"], ["proof (state)\nthis:\n  \\<delta>\n  \\<le> dist (real_of_int (fst p\\<^sub>0)) (real_of_int (fst p\\<^sub>1))\n\ngoal (2 subgoals):\n 1. p\\<^sub>0 \\<in> set ps' \\<and>\n    p\\<^sub>1 \\<notin> set ps' \\<Longrightarrow>\n    False\n 2. p\\<^sub>0 \\<notin> set ps' \\<and>\n    p\\<^sub>1 \\<in> set ps' \\<Longrightarrow>\n    False", "hence \"\\<delta> \\<le> dist p\\<^sub>0 p\\<^sub>1\""], ["proof (prove)\nusing this:\n  \\<delta>\n  \\<le> dist (real_of_int (fst p\\<^sub>0)) (real_of_int (fst p\\<^sub>1))\n\ngoal (1 subgoal):\n 1. \\<delta>\n    \\<le> dist\n           (case p\\<^sub>0 of\n            (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n           (case p\\<^sub>1 of\n            (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))", "using dist_fst_le[of p\\<^sub>0 p\\<^sub>1] less_le_trans"], ["proof (prove)\nusing this:\n  \\<delta>\n  \\<le> dist (real_of_int (fst p\\<^sub>0)) (real_of_int (fst p\\<^sub>1))\n  dist\n   (fst (case p\\<^sub>0 of\n         (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n   (fst (case p\\<^sub>1 of\n         (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n  \\<le> dist\n         (case p\\<^sub>0 of\n          (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n         (case p\\<^sub>1 of\n          (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n  \\<lbrakk>?x < ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n\ngoal (1 subgoal):\n 1. \\<delta>\n    \\<le> dist\n           (case p\\<^sub>0 of\n            (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n           (case p\\<^sub>1 of\n            (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))", "by (auto split: prod.splits)"], ["proof (state)\nthis:\n  \\<delta>\n  \\<le> dist\n         (case p\\<^sub>0 of\n          (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n         (case p\\<^sub>1 of\n          (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n\ngoal (2 subgoals):\n 1. p\\<^sub>0 \\<in> set ps' \\<and>\n    p\\<^sub>1 \\<notin> set ps' \\<Longrightarrow>\n    False\n 2. p\\<^sub>0 \\<notin> set ps' \\<and>\n    p\\<^sub>1 \\<in> set ps' \\<Longrightarrow>\n    False", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<delta>\n  \\<le> dist\n         (case p\\<^sub>0 of\n          (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n         (case p\\<^sub>1 of\n          (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n\ngoal (1 subgoal):\n 1. False", "using assms(4)"], ["proof (prove)\nusing this:\n  \\<delta>\n  \\<le> dist\n         (case p\\<^sub>0 of\n          (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n         (case p\\<^sub>1 of\n          (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n  dist\n   (case p\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n   (case p\\<^sub>1 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n  < \\<delta>\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. p\\<^sub>0 \\<notin> set ps' \\<and>\n    p\\<^sub>1 \\<in> set ps' \\<Longrightarrow>\n    False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p\\<^sub>0 \\<notin> set ps' \\<and>\n    p\\<^sub>1 \\<in> set ps' \\<Longrightarrow>\n    False", "case C"], ["proof (state)\nthis:\n  p\\<^sub>0 \\<notin> set ps' \\<and> p\\<^sub>1 \\<in> set ps'\n\ngoal (1 subgoal):\n 1. p\\<^sub>0 \\<notin> set ps' \\<and>\n    p\\<^sub>1 \\<in> set ps' \\<Longrightarrow>\n    False", "hence \"fst p\\<^sub>0 \\<le> l - \\<delta> \\<or> l + \\<delta> \\<le> fst p\\<^sub>0\""], ["proof (prove)\nusing this:\n  p\\<^sub>0 \\<notin> set ps' \\<and> p\\<^sub>1 \\<in> set ps'\n\ngoal (1 subgoal):\n 1. real_of_int (fst p\\<^sub>0) \\<le> real_of_int l - \\<delta> \\<or>\n    real_of_int l + \\<delta> \\<le> real_of_int (fst p\\<^sub>0)", "using assms(1,2,5,8)"], ["proof (prove)\nusing this:\n  p\\<^sub>0 \\<notin> set ps' \\<and> p\\<^sub>1 \\<in> set ps'\n  p\\<^sub>0 \\<in> ps\\<^sub>L\n  p\\<^sub>1 \\<in> ps\\<^sub>R\n  set ps = ps\\<^sub>L \\<union> ps\\<^sub>R\n  ps' =\n  filter\n   (\\<lambda>p.\n       real_of_int l - \\<delta> < real_of_int (fst p) \\<and>\n       real_of_int (fst p) < real_of_int l + \\<delta>)\n   ps\n\ngoal (1 subgoal):\n 1. real_of_int (fst p\\<^sub>0) \\<le> real_of_int l - \\<delta> \\<or>\n    real_of_int l + \\<delta> \\<le> real_of_int (fst p\\<^sub>0)", "by auto"], ["proof (state)\nthis:\n  real_of_int (fst p\\<^sub>0) \\<le> real_of_int l - \\<delta> \\<or>\n  real_of_int l + \\<delta> \\<le> real_of_int (fst p\\<^sub>0)\n\ngoal (1 subgoal):\n 1. p\\<^sub>0 \\<notin> set ps' \\<and>\n    p\\<^sub>1 \\<in> set ps' \\<Longrightarrow>\n    False", "hence \"fst p\\<^sub>0 \\<le> l - \\<delta>\""], ["proof (prove)\nusing this:\n  real_of_int (fst p\\<^sub>0) \\<le> real_of_int l - \\<delta> \\<or>\n  real_of_int l + \\<delta> \\<le> real_of_int (fst p\\<^sub>0)\n\ngoal (1 subgoal):\n 1. real_of_int (fst p\\<^sub>0) \\<le> real_of_int l - \\<delta>", "using assms(1,6)"], ["proof (prove)\nusing this:\n  real_of_int (fst p\\<^sub>0) \\<le> real_of_int l - \\<delta> \\<or>\n  real_of_int l + \\<delta> \\<le> real_of_int (fst p\\<^sub>0)\n  p\\<^sub>0 \\<in> ps\\<^sub>L\n  \\<forall>p\\<in>ps\\<^sub>L. fst p \\<le> l\n\ngoal (1 subgoal):\n 1. real_of_int (fst p\\<^sub>0) \\<le> real_of_int l - \\<delta>", "by auto"], ["proof (state)\nthis:\n  real_of_int (fst p\\<^sub>0) \\<le> real_of_int l - \\<delta>\n\ngoal (1 subgoal):\n 1. p\\<^sub>0 \\<notin> set ps' \\<and>\n    p\\<^sub>1 \\<in> set ps' \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  real_of_int (fst p\\<^sub>0) \\<le> real_of_int l - \\<delta>\n\ngoal (1 subgoal):\n 1. p\\<^sub>0 \\<notin> set ps' \\<and>\n    p\\<^sub>1 \\<in> set ps' \\<Longrightarrow>\n    False", "have \"l \\<le> fst p\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<le> fst p\\<^sub>1", "using assms(2,7)"], ["proof (prove)\nusing this:\n  p\\<^sub>1 \\<in> ps\\<^sub>R\n  \\<forall>p\\<in>ps\\<^sub>R. l \\<le> fst p\n\ngoal (1 subgoal):\n 1. l \\<le> fst p\\<^sub>1", "by simp"], ["proof (state)\nthis:\n  l \\<le> fst p\\<^sub>1\n\ngoal (1 subgoal):\n 1. p\\<^sub>0 \\<notin> set ps' \\<and>\n    p\\<^sub>1 \\<in> set ps' \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  real_of_int (fst p\\<^sub>0) \\<le> real_of_int l - \\<delta>\n  l \\<le> fst p\\<^sub>1", "have \"\\<delta> \\<le> dist (fst p\\<^sub>0) (fst p\\<^sub>1)\""], ["proof (prove)\nusing this:\n  real_of_int (fst p\\<^sub>0) \\<le> real_of_int l - \\<delta>\n  l \\<le> fst p\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<delta>\n    \\<le> dist (real_of_int (fst p\\<^sub>0)) (real_of_int (fst p\\<^sub>1))", "using dist_real_def"], ["proof (prove)\nusing this:\n  real_of_int (fst p\\<^sub>0) \\<le> real_of_int l - \\<delta>\n  l \\<le> fst p\\<^sub>1\n  dist ?x ?y = \\<bar>?x - ?y\\<bar>\n\ngoal (1 subgoal):\n 1. \\<delta>\n    \\<le> dist (real_of_int (fst p\\<^sub>0)) (real_of_int (fst p\\<^sub>1))", "by simp"], ["proof (state)\nthis:\n  \\<delta>\n  \\<le> dist (real_of_int (fst p\\<^sub>0)) (real_of_int (fst p\\<^sub>1))\n\ngoal (1 subgoal):\n 1. p\\<^sub>0 \\<notin> set ps' \\<and>\n    p\\<^sub>1 \\<in> set ps' \\<Longrightarrow>\n    False", "hence \"\\<delta> \\<le> dist p\\<^sub>0 p\\<^sub>1\""], ["proof (prove)\nusing this:\n  \\<delta>\n  \\<le> dist (real_of_int (fst p\\<^sub>0)) (real_of_int (fst p\\<^sub>1))\n\ngoal (1 subgoal):\n 1. \\<delta>\n    \\<le> dist\n           (case p\\<^sub>0 of\n            (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n           (case p\\<^sub>1 of\n            (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))", "using dist_fst_le[of p\\<^sub>0 p\\<^sub>1] less_le_trans"], ["proof (prove)\nusing this:\n  \\<delta>\n  \\<le> dist (real_of_int (fst p\\<^sub>0)) (real_of_int (fst p\\<^sub>1))\n  dist\n   (fst (case p\\<^sub>0 of\n         (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n   (fst (case p\\<^sub>1 of\n         (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n  \\<le> dist\n         (case p\\<^sub>0 of\n          (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n         (case p\\<^sub>1 of\n          (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n  \\<lbrakk>?x < ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n\ngoal (1 subgoal):\n 1. \\<delta>\n    \\<le> dist\n           (case p\\<^sub>0 of\n            (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n           (case p\\<^sub>1 of\n            (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))", "by (auto split: prod.splits)"], ["proof (state)\nthis:\n  \\<delta>\n  \\<le> dist\n         (case p\\<^sub>0 of\n          (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n         (case p\\<^sub>1 of\n          (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n\ngoal (1 subgoal):\n 1. p\\<^sub>0 \\<notin> set ps' \\<and>\n    p\\<^sub>1 \\<in> set ps' \\<Longrightarrow>\n    False", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<delta>\n  \\<le> dist\n         (case p\\<^sub>0 of\n          (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n         (case p\\<^sub>1 of\n          (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n\ngoal (1 subgoal):\n 1. False", "using assms(4)"], ["proof (prove)\nusing this:\n  \\<delta>\n  \\<le> dist\n         (case p\\<^sub>0 of\n          (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n         (case p\\<^sub>1 of\n          (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n  dist\n   (case p\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n   (case p\\<^sub>1 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n  < \\<delta>\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_band_filter:\n  fixes \\<delta> :: real and ps :: \"point list\"\n  assumes \"p\\<^sub>0 \\<in> set ps\" \"p\\<^sub>1 \\<in> set ps\" \"p\\<^sub>0 \\<noteq> p\\<^sub>1\" \"dist p\\<^sub>0 p\\<^sub>1 < \\<delta>\" \"set ps = ps\\<^sub>L \\<union> ps\\<^sub>R\"\n  assumes \"sparse \\<delta> ps\\<^sub>L\" \"sparse \\<delta> ps\\<^sub>R\"\n  assumes \"\\<forall>p \\<in> ps\\<^sub>L. fst p \\<le> l\" \"\\<forall>p \\<in> ps\\<^sub>R. l \\<le> fst p\"\n  assumes \"ps' = filter (\\<lambda>p. l - \\<delta> < fst p \\<and> fst p < l + \\<delta>) ps\"\n  shows \"p\\<^sub>0 \\<in> set ps' \\<and> p\\<^sub>1 \\<in> set ps'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p\\<^sub>0 \\<in> set ps' \\<and> p\\<^sub>1 \\<in> set ps'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p\\<^sub>0 \\<in> set ps' \\<and> p\\<^sub>1 \\<in> set ps'", "have \"p\\<^sub>0 \\<notin> ps\\<^sub>L \\<or> p\\<^sub>1 \\<notin> ps\\<^sub>L\" \"p\\<^sub>0 \\<notin> ps\\<^sub>R \\<or> p\\<^sub>1 \\<notin> ps\\<^sub>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p\\<^sub>0 \\<notin> ps\\<^sub>L \\<or> p\\<^sub>1 \\<notin> ps\\<^sub>L &&&\n    p\\<^sub>0 \\<notin> ps\\<^sub>R \\<or> p\\<^sub>1 \\<notin> ps\\<^sub>R", "using assms(3,4,6,7) sparse_def"], ["proof (prove)\nusing this:\n  p\\<^sub>0 \\<noteq> p\\<^sub>1\n  dist\n   (case p\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n   (case p\\<^sub>1 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n  < \\<delta>\n  sparse \\<delta> ps\\<^sub>L\n  sparse \\<delta> ps\\<^sub>R\n  sparse ?\\<delta> ?ps =\n  (\\<forall>p\\<^sub>0\\<in>?ps.\n      \\<forall>p\\<^sub>1\\<in>?ps.\n         p\\<^sub>0 \\<noteq> p\\<^sub>1 \\<longrightarrow>\n         ?\\<delta>\n         \\<le> dist\n                (case p\\<^sub>0 of\n                 (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n                (case p\\<^sub>1 of\n                 (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n\ngoal (1 subgoal):\n 1. p\\<^sub>0 \\<notin> ps\\<^sub>L \\<or> p\\<^sub>1 \\<notin> ps\\<^sub>L &&&\n    p\\<^sub>0 \\<notin> ps\\<^sub>R \\<or> p\\<^sub>1 \\<notin> ps\\<^sub>R", "by force+"], ["proof (state)\nthis:\n  p\\<^sub>0 \\<notin> ps\\<^sub>L \\<or> p\\<^sub>1 \\<notin> ps\\<^sub>L\n  p\\<^sub>0 \\<notin> ps\\<^sub>R \\<or> p\\<^sub>1 \\<notin> ps\\<^sub>R\n\ngoal (1 subgoal):\n 1. p\\<^sub>0 \\<in> set ps' \\<and> p\\<^sub>1 \\<in> set ps'", "then"], ["proof (chain)\npicking this:\n  p\\<^sub>0 \\<notin> ps\\<^sub>L \\<or> p\\<^sub>1 \\<notin> ps\\<^sub>L\n  p\\<^sub>0 \\<notin> ps\\<^sub>R \\<or> p\\<^sub>1 \\<notin> ps\\<^sub>R", "consider (A) \"p\\<^sub>0 \\<in> ps\\<^sub>L \\<and> p\\<^sub>1 \\<in> ps\\<^sub>R\" | (B) \"p\\<^sub>0 \\<in> ps\\<^sub>R \\<and> p\\<^sub>1 \\<in> ps\\<^sub>L\""], ["proof (prove)\nusing this:\n  p\\<^sub>0 \\<notin> ps\\<^sub>L \\<or> p\\<^sub>1 \\<notin> ps\\<^sub>L\n  p\\<^sub>0 \\<notin> ps\\<^sub>R \\<or> p\\<^sub>1 \\<notin> ps\\<^sub>R\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p\\<^sub>0 \\<in> ps\\<^sub>L \\<and>\n             p\\<^sub>1 \\<in> ps\\<^sub>R \\<Longrightarrow>\n             thesis;\n     p\\<^sub>0 \\<in> ps\\<^sub>R \\<and>\n     p\\<^sub>1 \\<in> ps\\<^sub>L \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms(1,2,5)"], ["proof (prove)\nusing this:\n  p\\<^sub>0 \\<notin> ps\\<^sub>L \\<or> p\\<^sub>1 \\<notin> ps\\<^sub>L\n  p\\<^sub>0 \\<notin> ps\\<^sub>R \\<or> p\\<^sub>1 \\<notin> ps\\<^sub>R\n  p\\<^sub>0 \\<in> set ps\n  p\\<^sub>1 \\<in> set ps\n  set ps = ps\\<^sub>L \\<union> ps\\<^sub>R\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p\\<^sub>0 \\<in> ps\\<^sub>L \\<and>\n             p\\<^sub>1 \\<in> ps\\<^sub>R \\<Longrightarrow>\n             thesis;\n     p\\<^sub>0 \\<in> ps\\<^sub>R \\<and>\n     p\\<^sub>1 \\<in> ps\\<^sub>L \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>p\\<^sub>0 \\<in> ps\\<^sub>L \\<and>\n           p\\<^sub>1 \\<in> ps\\<^sub>R \\<Longrightarrow>\n           ?thesis;\n   p\\<^sub>0 \\<in> ps\\<^sub>R \\<and>\n   p\\<^sub>1 \\<in> ps\\<^sub>L \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. p\\<^sub>0 \\<in> set ps' \\<and> p\\<^sub>1 \\<in> set ps'", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>p\\<^sub>0 \\<in> ps\\<^sub>L \\<and>\n           p\\<^sub>1 \\<in> ps\\<^sub>R \\<Longrightarrow>\n           ?thesis;\n   p\\<^sub>0 \\<in> ps\\<^sub>R \\<and>\n   p\\<^sub>1 \\<in> ps\\<^sub>L \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. p\\<^sub>0 \\<in> set ps' \\<and> p\\<^sub>1 \\<in> set ps'", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. p\\<^sub>0 \\<in> ps\\<^sub>L \\<and>\n    p\\<^sub>1 \\<in> ps\\<^sub>R \\<Longrightarrow>\n    p\\<^sub>0 \\<in> set ps' \\<and> p\\<^sub>1 \\<in> set ps'\n 2. p\\<^sub>0 \\<in> ps\\<^sub>R \\<and>\n    p\\<^sub>1 \\<in> ps\\<^sub>L \\<Longrightarrow>\n    p\\<^sub>0 \\<in> set ps' \\<and> p\\<^sub>1 \\<in> set ps'", "case A"], ["proof (state)\nthis:\n  p\\<^sub>0 \\<in> ps\\<^sub>L \\<and> p\\<^sub>1 \\<in> ps\\<^sub>R\n\ngoal (2 subgoals):\n 1. p\\<^sub>0 \\<in> ps\\<^sub>L \\<and>\n    p\\<^sub>1 \\<in> ps\\<^sub>R \\<Longrightarrow>\n    p\\<^sub>0 \\<in> set ps' \\<and> p\\<^sub>1 \\<in> set ps'\n 2. p\\<^sub>0 \\<in> ps\\<^sub>R \\<and>\n    p\\<^sub>1 \\<in> ps\\<^sub>L \\<Longrightarrow>\n    p\\<^sub>0 \\<in> set ps' \\<and> p\\<^sub>1 \\<in> set ps'", "thus ?thesis"], ["proof (prove)\nusing this:\n  p\\<^sub>0 \\<in> ps\\<^sub>L \\<and> p\\<^sub>1 \\<in> ps\\<^sub>R\n\ngoal (1 subgoal):\n 1. p\\<^sub>0 \\<in> set ps' \\<and> p\\<^sub>1 \\<in> set ps'", "using set_band_filter_aux assms(3,4,5,8,9,10)"], ["proof (prove)\nusing this:\n  p\\<^sub>0 \\<in> ps\\<^sub>L \\<and> p\\<^sub>1 \\<in> ps\\<^sub>R\n  \\<lbrakk>?p\\<^sub>0 \\<in> ?ps\\<^sub>L; ?p\\<^sub>1 \\<in> ?ps\\<^sub>R;\n   ?p\\<^sub>0 \\<noteq> ?p\\<^sub>1;\n   dist\n    (case ?p\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n    (case ?p\\<^sub>1 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n   < ?\\<delta>;\n   set ?ps = ?ps\\<^sub>L \\<union> ?ps\\<^sub>R;\n   \\<forall>p\\<in>?ps\\<^sub>L. fst p \\<le> ?l;\n   \\<forall>p\\<in>?ps\\<^sub>R. ?l \\<le> fst p;\n   ?ps' =\n   filter\n    (\\<lambda>p.\n        real_of_int ?l - ?\\<delta> < real_of_int (fst p) \\<and>\n        real_of_int (fst p) < real_of_int ?l + ?\\<delta>)\n    ?ps\\<rbrakk>\n  \\<Longrightarrow> ?p\\<^sub>0 \\<in> set ?ps' \\<and>\n                    ?p\\<^sub>1 \\<in> set ?ps'\n  p\\<^sub>0 \\<noteq> p\\<^sub>1\n  dist\n   (case p\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n   (case p\\<^sub>1 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n  < \\<delta>\n  set ps = ps\\<^sub>L \\<union> ps\\<^sub>R\n  \\<forall>p\\<in>ps\\<^sub>L. fst p \\<le> l\n  \\<forall>p\\<in>ps\\<^sub>R. l \\<le> fst p\n  ps' =\n  filter\n   (\\<lambda>p.\n       real_of_int l - \\<delta> < real_of_int (fst p) \\<and>\n       real_of_int (fst p) < real_of_int l + \\<delta>)\n   ps\n\ngoal (1 subgoal):\n 1. p\\<^sub>0 \\<in> set ps' \\<and> p\\<^sub>1 \\<in> set ps'", "by (auto split: prod.splits)"], ["proof (state)\nthis:\n  p\\<^sub>0 \\<in> set ps' \\<and> p\\<^sub>1 \\<in> set ps'\n\ngoal (1 subgoal):\n 1. p\\<^sub>0 \\<in> ps\\<^sub>R \\<and>\n    p\\<^sub>1 \\<in> ps\\<^sub>L \\<Longrightarrow>\n    p\\<^sub>0 \\<in> set ps' \\<and> p\\<^sub>1 \\<in> set ps'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p\\<^sub>0 \\<in> ps\\<^sub>R \\<and>\n    p\\<^sub>1 \\<in> ps\\<^sub>L \\<Longrightarrow>\n    p\\<^sub>0 \\<in> set ps' \\<and> p\\<^sub>1 \\<in> set ps'", "case B"], ["proof (state)\nthis:\n  p\\<^sub>0 \\<in> ps\\<^sub>R \\<and> p\\<^sub>1 \\<in> ps\\<^sub>L\n\ngoal (1 subgoal):\n 1. p\\<^sub>0 \\<in> ps\\<^sub>R \\<and>\n    p\\<^sub>1 \\<in> ps\\<^sub>L \\<Longrightarrow>\n    p\\<^sub>0 \\<in> set ps' \\<and> p\\<^sub>1 \\<in> set ps'", "moreover"], ["proof (state)\nthis:\n  p\\<^sub>0 \\<in> ps\\<^sub>R \\<and> p\\<^sub>1 \\<in> ps\\<^sub>L\n\ngoal (1 subgoal):\n 1. p\\<^sub>0 \\<in> ps\\<^sub>R \\<and>\n    p\\<^sub>1 \\<in> ps\\<^sub>L \\<Longrightarrow>\n    p\\<^sub>0 \\<in> set ps' \\<and> p\\<^sub>1 \\<in> set ps'", "have \"dist p\\<^sub>1 p\\<^sub>0 < \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist\n     (case p\\<^sub>1 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     (case p\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n    < \\<delta>", "using assms(4) dist_commute"], ["proof (prove)\nusing this:\n  dist\n   (case p\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n   (case p\\<^sub>1 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n  < \\<delta>\n  dist ?x ?y = dist ?y ?x\n\ngoal (1 subgoal):\n 1. dist\n     (case p\\<^sub>1 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     (case p\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n    < \\<delta>", "by metis"], ["proof (state)\nthis:\n  dist\n   (case p\\<^sub>1 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n   (case p\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n  < \\<delta>\n\ngoal (1 subgoal):\n 1. p\\<^sub>0 \\<in> ps\\<^sub>R \\<and>\n    p\\<^sub>1 \\<in> ps\\<^sub>L \\<Longrightarrow>\n    p\\<^sub>0 \\<in> set ps' \\<and> p\\<^sub>1 \\<in> set ps'", "ultimately"], ["proof (chain)\npicking this:\n  p\\<^sub>0 \\<in> ps\\<^sub>R \\<and> p\\<^sub>1 \\<in> ps\\<^sub>L\n  dist\n   (case p\\<^sub>1 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n   (case p\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n  < \\<delta>", "show ?thesis"], ["proof (prove)\nusing this:\n  p\\<^sub>0 \\<in> ps\\<^sub>R \\<and> p\\<^sub>1 \\<in> ps\\<^sub>L\n  dist\n   (case p\\<^sub>1 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n   (case p\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n  < \\<delta>\n\ngoal (1 subgoal):\n 1. p\\<^sub>0 \\<in> set ps' \\<and> p\\<^sub>1 \\<in> set ps'", "using set_band_filter_aux assms(3)[symmetric] assms(5,8,9,10)"], ["proof (prove)\nusing this:\n  p\\<^sub>0 \\<in> ps\\<^sub>R \\<and> p\\<^sub>1 \\<in> ps\\<^sub>L\n  dist\n   (case p\\<^sub>1 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n   (case p\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n  < \\<delta>\n  \\<lbrakk>?p\\<^sub>0 \\<in> ?ps\\<^sub>L; ?p\\<^sub>1 \\<in> ?ps\\<^sub>R;\n   ?p\\<^sub>0 \\<noteq> ?p\\<^sub>1;\n   dist\n    (case ?p\\<^sub>0 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n    (case ?p\\<^sub>1 of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n   < ?\\<delta>;\n   set ?ps = ?ps\\<^sub>L \\<union> ?ps\\<^sub>R;\n   \\<forall>p\\<in>?ps\\<^sub>L. fst p \\<le> ?l;\n   \\<forall>p\\<in>?ps\\<^sub>R. ?l \\<le> fst p;\n   ?ps' =\n   filter\n    (\\<lambda>p.\n        real_of_int ?l - ?\\<delta> < real_of_int (fst p) \\<and>\n        real_of_int (fst p) < real_of_int ?l + ?\\<delta>)\n    ?ps\\<rbrakk>\n  \\<Longrightarrow> ?p\\<^sub>0 \\<in> set ?ps' \\<and>\n                    ?p\\<^sub>1 \\<in> set ?ps'\n  p\\<^sub>1 \\<noteq> p\\<^sub>0\n  set ps = ps\\<^sub>L \\<union> ps\\<^sub>R\n  \\<forall>p\\<in>ps\\<^sub>L. fst p \\<le> l\n  \\<forall>p\\<in>ps\\<^sub>R. l \\<le> fst p\n  ps' =\n  filter\n   (\\<lambda>p.\n       real_of_int l - \\<delta> < real_of_int (fst p) \\<and>\n       real_of_int (fst p) < real_of_int l + \\<delta>)\n   ps\n\ngoal (1 subgoal):\n 1. p\\<^sub>0 \\<in> set ps' \\<and> p\\<^sub>1 \\<in> set ps'", "by (auto split: prod.splits)"], ["proof (state)\nthis:\n  p\\<^sub>0 \\<in> set ps' \\<and> p\\<^sub>1 \\<in> set ps'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p\\<^sub>0 \\<in> set ps' \\<and> p\\<^sub>1 \\<in> set ps'\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"2D-Boxes and Points\""], ["", "lemma cbox_2D: \n  fixes x\\<^sub>0 :: real and y\\<^sub>0 :: real\n  shows \"cbox (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>1, y\\<^sub>1) = { (x, y). x\\<^sub>0 \\<le> x \\<and> x \\<le> x\\<^sub>1 \\<and> y\\<^sub>0 \\<le> y \\<and> y \\<le> y\\<^sub>1 }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cbox (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>1, y\\<^sub>1) =\n    {(x, y).\n     x\\<^sub>0 \\<le> x \\<and>\n     x \\<le> x\\<^sub>1 \\<and> y\\<^sub>0 \\<le> y \\<and> y \\<le> y\\<^sub>1}", "by fastforce"], ["", "lemma mem_cbox_2D:\n  fixes x :: real and y :: real\n  shows \"x\\<^sub>0 \\<le> x \\<and> x \\<le> x\\<^sub>1 \\<and> y\\<^sub>0 \\<le> y \\<and> y \\<le> y\\<^sub>1 \\<longleftrightarrow> (x, y) \\<in> cbox (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>1, y\\<^sub>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sub>0 \\<le> x \\<and>\n     x \\<le> x\\<^sub>1 \\<and> y\\<^sub>0 \\<le> y \\<and> y \\<le> y\\<^sub>1) =\n    ((x, y) \\<in> cbox (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>1, y\\<^sub>1))", "by fastforce"], ["", "lemma cbox_top_un:\n  fixes x\\<^sub>0 :: real and y\\<^sub>0 :: real\n  assumes \"y\\<^sub>0 \\<le> y\\<^sub>1\" \"y\\<^sub>1 \\<le> y\\<^sub>2\"\n  shows \"cbox (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>1, y\\<^sub>1) \\<union> cbox (x\\<^sub>0, y\\<^sub>1) (x\\<^sub>1, y\\<^sub>2) = cbox (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>1, y\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cbox (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>1, y\\<^sub>1) \\<union>\n    cbox (x\\<^sub>0, y\\<^sub>1) (x\\<^sub>1, y\\<^sub>2) =\n    cbox (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>1, y\\<^sub>2)", "using assms"], ["proof (prove)\nusing this:\n  y\\<^sub>0 \\<le> y\\<^sub>1\n  y\\<^sub>1 \\<le> y\\<^sub>2\n\ngoal (1 subgoal):\n 1. cbox (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>1, y\\<^sub>1) \\<union>\n    cbox (x\\<^sub>0, y\\<^sub>1) (x\\<^sub>1, y\\<^sub>2) =\n    cbox (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>1, y\\<^sub>2)", "by auto"], ["", "lemma cbox_right_un:\n  fixes x\\<^sub>0 :: real and y\\<^sub>0 :: real\n  assumes \"x\\<^sub>0 \\<le> x\\<^sub>1\" \"x\\<^sub>1 \\<le> x\\<^sub>2\"\n  shows \"cbox (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>1, y\\<^sub>1) \\<union> cbox (x\\<^sub>1, y\\<^sub>0) (x\\<^sub>2, y\\<^sub>1) = cbox (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>2, y\\<^sub>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cbox (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>1, y\\<^sub>1) \\<union>\n    cbox (x\\<^sub>1, y\\<^sub>0) (x\\<^sub>2, y\\<^sub>1) =\n    cbox (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>2, y\\<^sub>1)", "using assms"], ["proof (prove)\nusing this:\n  x\\<^sub>0 \\<le> x\\<^sub>1\n  x\\<^sub>1 \\<le> x\\<^sub>2\n\ngoal (1 subgoal):\n 1. cbox (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>1, y\\<^sub>1) \\<union>\n    cbox (x\\<^sub>1, y\\<^sub>0) (x\\<^sub>2, y\\<^sub>1) =\n    cbox (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>2, y\\<^sub>1)", "by auto"], ["", "lemma cbox_max_dist:\n  assumes \"p\\<^sub>0 = (x, y)\" \"p\\<^sub>1 = (x + \\<delta>, y + \\<delta>)\"\n  assumes \"(x\\<^sub>0, y\\<^sub>0) \\<in> cbox p\\<^sub>0 p\\<^sub>1\" \"(x\\<^sub>1, y\\<^sub>1) \\<in> cbox p\\<^sub>0 p\\<^sub>1\" \"0 \\<le> \\<delta>\"\n  shows \"dist (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>1, y\\<^sub>1) \\<le> sqrt 2 * \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>1, y\\<^sub>1)\n    \\<le> sqrt 2 * \\<delta>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dist (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>1, y\\<^sub>1)\n    \\<le> sqrt 2 * \\<delta>", "have X: \"dist x\\<^sub>0 x\\<^sub>1 \\<le> \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x\\<^sub>0 x\\<^sub>1 \\<le> \\<delta>", "using assms dist_real_def"], ["proof (prove)\nusing this:\n  p\\<^sub>0 = (x, y)\n  p\\<^sub>1 = (x + \\<delta>, y + \\<delta>)\n  (x\\<^sub>0, y\\<^sub>0) \\<in> cbox p\\<^sub>0 p\\<^sub>1\n  (x\\<^sub>1, y\\<^sub>1) \\<in> cbox p\\<^sub>0 p\\<^sub>1\n  0 \\<le> \\<delta>\n  dist ?x ?y = \\<bar>?x - ?y\\<bar>\n\ngoal (1 subgoal):\n 1. dist x\\<^sub>0 x\\<^sub>1 \\<le> \\<delta>", "by auto"], ["proof (state)\nthis:\n  dist x\\<^sub>0 x\\<^sub>1 \\<le> \\<delta>\n\ngoal (1 subgoal):\n 1. dist (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>1, y\\<^sub>1)\n    \\<le> sqrt 2 * \\<delta>", "have Y: \"dist y\\<^sub>0 y\\<^sub>1 \\<le> \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist y\\<^sub>0 y\\<^sub>1 \\<le> \\<delta>", "using assms dist_real_def"], ["proof (prove)\nusing this:\n  p\\<^sub>0 = (x, y)\n  p\\<^sub>1 = (x + \\<delta>, y + \\<delta>)\n  (x\\<^sub>0, y\\<^sub>0) \\<in> cbox p\\<^sub>0 p\\<^sub>1\n  (x\\<^sub>1, y\\<^sub>1) \\<in> cbox p\\<^sub>0 p\\<^sub>1\n  0 \\<le> \\<delta>\n  dist ?x ?y = \\<bar>?x - ?y\\<bar>\n\ngoal (1 subgoal):\n 1. dist y\\<^sub>0 y\\<^sub>1 \\<le> \\<delta>", "by auto"], ["proof (state)\nthis:\n  dist y\\<^sub>0 y\\<^sub>1 \\<le> \\<delta>\n\ngoal (1 subgoal):\n 1. dist (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>1, y\\<^sub>1)\n    \\<le> sqrt 2 * \\<delta>", "have \"dist (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>1, y\\<^sub>1) = sqrt ((dist x\\<^sub>0 x\\<^sub>1)\\<^sup>2 + (dist y\\<^sub>0 y\\<^sub>1)\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>1, y\\<^sub>1) =\n    sqrt\n     ((dist x\\<^sub>0 x\\<^sub>1)\\<^sup>2 +\n      (dist y\\<^sub>0 y\\<^sub>1)\\<^sup>2)", "using dist_Pair_Pair"], ["proof (prove)\nusing this:\n  dist (?a, ?b) (?c, ?d) =\n  sqrt ((dist ?a ?c)\\<^sup>2 + (dist ?b ?d)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. dist (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>1, y\\<^sub>1) =\n    sqrt\n     ((dist x\\<^sub>0 x\\<^sub>1)\\<^sup>2 +\n      (dist y\\<^sub>0 y\\<^sub>1)\\<^sup>2)", "by auto"], ["proof (state)\nthis:\n  dist (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>1, y\\<^sub>1) =\n  sqrt\n   ((dist x\\<^sub>0 x\\<^sub>1)\\<^sup>2 + (dist y\\<^sub>0 y\\<^sub>1)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. dist (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>1, y\\<^sub>1)\n    \\<le> sqrt 2 * \\<delta>", "also"], ["proof (state)\nthis:\n  dist (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>1, y\\<^sub>1) =\n  sqrt\n   ((dist x\\<^sub>0 x\\<^sub>1)\\<^sup>2 + (dist y\\<^sub>0 y\\<^sub>1)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. dist (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>1, y\\<^sub>1)\n    \\<le> sqrt 2 * \\<delta>", "have \"... \\<le> sqrt (\\<delta>\\<^sup>2 + (dist y\\<^sub>0 y\\<^sub>1)\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt\n     ((dist x\\<^sub>0 x\\<^sub>1)\\<^sup>2 +\n      (dist y\\<^sub>0 y\\<^sub>1)\\<^sup>2)\n    \\<le> sqrt (\\<delta>\\<^sup>2 + (dist y\\<^sub>0 y\\<^sub>1)\\<^sup>2)", "using X power_mono"], ["proof (prove)\nusing this:\n  dist x\\<^sub>0 x\\<^sub>1 \\<le> \\<delta>\n  \\<lbrakk>?a \\<le> ?b; (0::?'a) \\<le> ?a\\<rbrakk>\n  \\<Longrightarrow> ?a ^ ?n \\<le> ?b ^ ?n\n\ngoal (1 subgoal):\n 1. sqrt\n     ((dist x\\<^sub>0 x\\<^sub>1)\\<^sup>2 +\n      (dist y\\<^sub>0 y\\<^sub>1)\\<^sup>2)\n    \\<le> sqrt (\\<delta>\\<^sup>2 + (dist y\\<^sub>0 y\\<^sub>1)\\<^sup>2)", "by fastforce"], ["proof (state)\nthis:\n  sqrt\n   ((dist x\\<^sub>0 x\\<^sub>1)\\<^sup>2 + (dist y\\<^sub>0 y\\<^sub>1)\\<^sup>2)\n  \\<le> sqrt (\\<delta>\\<^sup>2 + (dist y\\<^sub>0 y\\<^sub>1)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. dist (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>1, y\\<^sub>1)\n    \\<le> sqrt 2 * \\<delta>", "also"], ["proof (state)\nthis:\n  sqrt\n   ((dist x\\<^sub>0 x\\<^sub>1)\\<^sup>2 + (dist y\\<^sub>0 y\\<^sub>1)\\<^sup>2)\n  \\<le> sqrt (\\<delta>\\<^sup>2 + (dist y\\<^sub>0 y\\<^sub>1)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. dist (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>1, y\\<^sub>1)\n    \\<le> sqrt 2 * \\<delta>", "have \"... \\<le> sqrt (\\<delta>\\<^sup>2 + \\<delta>\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt (\\<delta>\\<^sup>2 + (dist y\\<^sub>0 y\\<^sub>1)\\<^sup>2)\n    \\<le> sqrt (\\<delta>\\<^sup>2 + \\<delta>\\<^sup>2)", "using Y power_mono"], ["proof (prove)\nusing this:\n  dist y\\<^sub>0 y\\<^sub>1 \\<le> \\<delta>\n  \\<lbrakk>?a \\<le> ?b; (0::?'a) \\<le> ?a\\<rbrakk>\n  \\<Longrightarrow> ?a ^ ?n \\<le> ?b ^ ?n\n\ngoal (1 subgoal):\n 1. sqrt (\\<delta>\\<^sup>2 + (dist y\\<^sub>0 y\\<^sub>1)\\<^sup>2)\n    \\<le> sqrt (\\<delta>\\<^sup>2 + \\<delta>\\<^sup>2)", "by fastforce"], ["proof (state)\nthis:\n  sqrt (\\<delta>\\<^sup>2 + (dist y\\<^sub>0 y\\<^sub>1)\\<^sup>2)\n  \\<le> sqrt (\\<delta>\\<^sup>2 + \\<delta>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. dist (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>1, y\\<^sub>1)\n    \\<le> sqrt 2 * \\<delta>", "also"], ["proof (state)\nthis:\n  sqrt (\\<delta>\\<^sup>2 + (dist y\\<^sub>0 y\\<^sub>1)\\<^sup>2)\n  \\<le> sqrt (\\<delta>\\<^sup>2 + \\<delta>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. dist (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>1, y\\<^sub>1)\n    \\<le> sqrt 2 * \\<delta>", "have \"... = sqrt 2 * sqrt (\\<delta>\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt (\\<delta>\\<^sup>2 + \\<delta>\\<^sup>2) =\n    sqrt 2 * sqrt (\\<delta>\\<^sup>2)", "using real_sqrt_mult"], ["proof (prove)\nusing this:\n  sqrt (?x * ?y) = sqrt ?x * sqrt ?y\n\ngoal (1 subgoal):\n 1. sqrt (\\<delta>\\<^sup>2 + \\<delta>\\<^sup>2) =\n    sqrt 2 * sqrt (\\<delta>\\<^sup>2)", "by simp"], ["proof (state)\nthis:\n  sqrt (\\<delta>\\<^sup>2 + \\<delta>\\<^sup>2) =\n  sqrt 2 * sqrt (\\<delta>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. dist (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>1, y\\<^sub>1)\n    \\<le> sqrt 2 * \\<delta>", "also"], ["proof (state)\nthis:\n  sqrt (\\<delta>\\<^sup>2 + \\<delta>\\<^sup>2) =\n  sqrt 2 * sqrt (\\<delta>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. dist (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>1, y\\<^sub>1)\n    \\<le> sqrt 2 * \\<delta>", "have \"... = sqrt 2 * \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt 2 * sqrt (\\<delta>\\<^sup>2) = sqrt 2 * \\<delta>", "using assms(5)"], ["proof (prove)\nusing this:\n  0 \\<le> \\<delta>\n\ngoal (1 subgoal):\n 1. sqrt 2 * sqrt (\\<delta>\\<^sup>2) = sqrt 2 * \\<delta>", "by simp"], ["proof (state)\nthis:\n  sqrt 2 * sqrt (\\<delta>\\<^sup>2) = sqrt 2 * \\<delta>\n\ngoal (1 subgoal):\n 1. dist (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>1, y\\<^sub>1)\n    \\<le> sqrt 2 * \\<delta>", "finally"], ["proof (chain)\npicking this:\n  dist (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>1, y\\<^sub>1) \\<le> sqrt 2 * \\<delta>", "show ?thesis"], ["proof (prove)\nusing this:\n  dist (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>1, y\\<^sub>1) \\<le> sqrt 2 * \\<delta>\n\ngoal (1 subgoal):\n 1. dist (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>1, y\\<^sub>1)\n    \\<le> sqrt 2 * \\<delta>", "."], ["proof (state)\nthis:\n  dist (x\\<^sub>0, y\\<^sub>0) (x\\<^sub>1, y\\<^sub>1) \\<le> sqrt 2 * \\<delta>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"Pigeonhole Argument\""], ["", "lemma card_le_1_if_pairwise_eq:\n  assumes \"\\<forall>x \\<in> S. \\<forall>y \\<in> S. x = y\"\n  shows \"card S \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card S \\<le> 1", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> card S \\<le> 1 \\<Longrightarrow> False", "assume \"\\<not> card S \\<le> 1\""], ["proof (state)\nthis:\n  \\<not> card S \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<not> card S \\<le> 1 \\<Longrightarrow> False", "hence \"2 \\<le> card S\""], ["proof (prove)\nusing this:\n  \\<not> card S \\<le> 1\n\ngoal (1 subgoal):\n 1. 2 \\<le> card S", "by simp"], ["proof (state)\nthis:\n  2 \\<le> card S\n\ngoal (1 subgoal):\n 1. \\<not> card S \\<le> 1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  2 \\<le> card S", "obtain T where *: \"T \\<subseteq> S \\<and> card T = 2\""], ["proof (prove)\nusing this:\n  2 \\<le> card S\n\ngoal (1 subgoal):\n 1. (\\<And>T.\n        T \\<subseteq> S \\<and> card T = 2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ex_card"], ["proof (prove)\nusing this:\n  2 \\<le> card S\n  ?n \\<le> card ?A \\<Longrightarrow> \\<exists>S\\<subseteq>?A. card S = ?n\n\ngoal (1 subgoal):\n 1. (\\<And>T.\n        T \\<subseteq> S \\<and> card T = 2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  T \\<subseteq> S \\<and> card T = 2\n\ngoal (1 subgoal):\n 1. \\<not> card S \\<le> 1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  T \\<subseteq> S \\<and> card T = 2", "obtain x y where \"x \\<in> T \\<and> y \\<in> T \\<and> x \\<noteq> y\""], ["proof (prove)\nusing this:\n  T \\<subseteq> S \\<and> card T = 2\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        x \\<in> T \\<and> y \\<in> T \\<and> x \\<noteq> y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson card_2_iff')"], ["proof (state)\nthis:\n  x \\<in> T \\<and> y \\<in> T \\<and> x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<not> card S \\<le> 1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  x \\<in> T \\<and> y \\<in> T \\<and> x \\<noteq> y", "show False"], ["proof (prove)\nusing this:\n  x \\<in> T \\<and> y \\<in> T \\<and> x \\<noteq> y\n\ngoal (1 subgoal):\n 1. False", "using * assms"], ["proof (prove)\nusing this:\n  x \\<in> T \\<and> y \\<in> T \\<and> x \\<noteq> y\n  T \\<subseteq> S \\<and> card T = 2\n  \\<forall>x\\<in>S. \\<forall>y\\<in>S. x = y\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma card_Int_if_either_in:\n  assumes \"\\<forall>x \\<in> S. \\<forall>y \\<in> S. x = y \\<or> x \\<notin> T \\<or> y \\<notin> T\" \n  shows \"card (S \\<inter> T) \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (S \\<inter> T) \\<le> 1", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> card (S \\<inter> T) \\<le> 1 \\<Longrightarrow> False", "assume \"\\<not> (card (S \\<inter> T) \\<le> 1)\""], ["proof (state)\nthis:\n  \\<not> card (S \\<inter> T) \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<not> card (S \\<inter> T) \\<le> 1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> card (S \\<inter> T) \\<le> 1", "obtain x y where *: \"x \\<in> S \\<inter> T \\<and> y \\<in> S \\<inter> T \\<and> x \\<noteq> y\""], ["proof (prove)\nusing this:\n  \\<not> card (S \\<inter> T) \\<le> 1\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        x \\<in> S \\<inter> T \\<and>\n        y \\<in> S \\<inter> T \\<and> x \\<noteq> y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson card_le_1_if_pairwise_eq)"], ["proof (state)\nthis:\n  x \\<in> S \\<inter> T \\<and> y \\<in> S \\<inter> T \\<and> x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<not> card (S \\<inter> T) \\<le> 1 \\<Longrightarrow> False", "hence \"x \\<in> T\" \"y \\<in> T\""], ["proof (prove)\nusing this:\n  x \\<in> S \\<inter> T \\<and> y \\<in> S \\<inter> T \\<and> x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<in> T &&& y \\<in> T", "by simp_all"], ["proof (state)\nthis:\n  x \\<in> T\n  y \\<in> T\n\ngoal (1 subgoal):\n 1. \\<not> card (S \\<inter> T) \\<le> 1 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  x \\<in> T\n  y \\<in> T\n\ngoal (1 subgoal):\n 1. \\<not> card (S \\<inter> T) \\<le> 1 \\<Longrightarrow> False", "have \"x \\<notin> T \\<or> y \\<notin> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> T \\<or> y \\<notin> T", "using assms *"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S.\n     \\<forall>y\\<in>S. x = y \\<or> x \\<notin> T \\<or> y \\<notin> T\n  x \\<in> S \\<inter> T \\<and> y \\<in> S \\<inter> T \\<and> x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<notin> T \\<or> y \\<notin> T", "by auto"], ["proof (state)\nthis:\n  x \\<notin> T \\<or> y \\<notin> T\n\ngoal (1 subgoal):\n 1. \\<not> card (S \\<inter> T) \\<le> 1 \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> T\n  y \\<in> T\n  x \\<notin> T \\<or> y \\<notin> T", "show False"], ["proof (prove)\nusing this:\n  x \\<in> T\n  y \\<in> T\n  x \\<notin> T \\<or> y \\<notin> T\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma card_Int_Un_le_Sum_card_Int:\n  assumes \"finite S\"\n  shows \"card (A \\<inter> \\<Union>S) \\<le> (\\<Sum>B \\<in> S. card (A \\<inter> B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (A \\<inter> \\<Union> S) \\<le> (\\<Sum>B\\<in>S. card (A \\<inter> B))", "using assms"], ["proof (prove)\nusing this:\n  finite S\n\ngoal (1 subgoal):\n 1. card (A \\<inter> \\<Union> S) \\<le> (\\<Sum>B\\<in>S. card (A \\<inter> B))", "proof (induction \"card S\" arbitrary: S)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>0 = card S; finite S\\<rbrakk>\n       \\<Longrightarrow> card (A \\<inter> \\<Union> S)\n                         \\<le> (\\<Sum>B\\<in>S. card (A \\<inter> B))\n 2. \\<And>x S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>x = card S; finite S\\<rbrakk>\n                   \\<Longrightarrow> card (A \\<inter> \\<Union> S)\n                                     \\<le> (\\<Sum>B\\<in>S.\n        card (A \\<inter> B));\n        Suc x = card S; finite S\\<rbrakk>\n       \\<Longrightarrow> card (A \\<inter> \\<Union> S)\n                         \\<le> (\\<Sum>B\\<in>S. card (A \\<inter> B))", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>n = card ?S; finite ?S\\<rbrakk>\n  \\<Longrightarrow> card (A \\<inter> \\<Union> ?S)\n                    \\<le> (\\<Sum>B\\<in>?S. card (A \\<inter> B))\n  Suc n = card S\n  finite S\n\ngoal (2 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>0 = card S; finite S\\<rbrakk>\n       \\<Longrightarrow> card (A \\<inter> \\<Union> S)\n                         \\<le> (\\<Sum>B\\<in>S. card (A \\<inter> B))\n 2. \\<And>x S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>x = card S; finite S\\<rbrakk>\n                   \\<Longrightarrow> card (A \\<inter> \\<Union> S)\n                                     \\<le> (\\<Sum>B\\<in>S.\n        card (A \\<inter> B));\n        Suc x = card S; finite S\\<rbrakk>\n       \\<Longrightarrow> card (A \\<inter> \\<Union> S)\n                         \\<le> (\\<Sum>B\\<in>S. card (A \\<inter> B))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>n = card ?S; finite ?S\\<rbrakk>\n  \\<Longrightarrow> card (A \\<inter> \\<Union> ?S)\n                    \\<le> (\\<Sum>B\\<in>?S. card (A \\<inter> B))\n  Suc n = card S\n  finite S", "obtain B T where *: \"S = { B } \\<union> T\" \"card T = n\" \"B \\<notin> T\""], ["proof (prove)\nusing this:\n  \\<lbrakk>n = card ?S; finite ?S\\<rbrakk>\n  \\<Longrightarrow> card (A \\<inter> \\<Union> ?S)\n                    \\<le> (\\<Sum>B\\<in>?S. card (A \\<inter> B))\n  Suc n = card S\n  finite S\n\ngoal (1 subgoal):\n 1. (\\<And>B T.\n        \\<lbrakk>S = {B} \\<union> T; card T = n; B \\<notin> T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis card_Suc_eq Suc_eq_plus1 insert_is_Un)"], ["proof (state)\nthis:\n  S = {B} \\<union> T\n  card T = n\n  B \\<notin> T\n\ngoal (2 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>0 = card S; finite S\\<rbrakk>\n       \\<Longrightarrow> card (A \\<inter> \\<Union> S)\n                         \\<le> (\\<Sum>B\\<in>S. card (A \\<inter> B))\n 2. \\<And>x S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>x = card S; finite S\\<rbrakk>\n                   \\<Longrightarrow> card (A \\<inter> \\<Union> S)\n                                     \\<le> (\\<Sum>B\\<in>S.\n        card (A \\<inter> B));\n        Suc x = card S; finite S\\<rbrakk>\n       \\<Longrightarrow> card (A \\<inter> \\<Union> S)\n                         \\<le> (\\<Sum>B\\<in>S. card (A \\<inter> B))", "hence \"card (A \\<inter> \\<Union>S) = card (A \\<inter> \\<Union>({ B } \\<union> T))\""], ["proof (prove)\nusing this:\n  S = {B} \\<union> T\n  card T = n\n  B \\<notin> T\n\ngoal (1 subgoal):\n 1. card (A \\<inter> \\<Union> S) =\n    card (A \\<inter> \\<Union> ({B} \\<union> T))", "by blast"], ["proof (state)\nthis:\n  card (A \\<inter> \\<Union> S) = card (A \\<inter> \\<Union> ({B} \\<union> T))\n\ngoal (2 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>0 = card S; finite S\\<rbrakk>\n       \\<Longrightarrow> card (A \\<inter> \\<Union> S)\n                         \\<le> (\\<Sum>B\\<in>S. card (A \\<inter> B))\n 2. \\<And>x S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>x = card S; finite S\\<rbrakk>\n                   \\<Longrightarrow> card (A \\<inter> \\<Union> S)\n                                     \\<le> (\\<Sum>B\\<in>S.\n        card (A \\<inter> B));\n        Suc x = card S; finite S\\<rbrakk>\n       \\<Longrightarrow> card (A \\<inter> \\<Union> S)\n                         \\<le> (\\<Sum>B\\<in>S. card (A \\<inter> B))", "also"], ["proof (state)\nthis:\n  card (A \\<inter> \\<Union> S) = card (A \\<inter> \\<Union> ({B} \\<union> T))\n\ngoal (2 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>0 = card S; finite S\\<rbrakk>\n       \\<Longrightarrow> card (A \\<inter> \\<Union> S)\n                         \\<le> (\\<Sum>B\\<in>S. card (A \\<inter> B))\n 2. \\<And>x S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>x = card S; finite S\\<rbrakk>\n                   \\<Longrightarrow> card (A \\<inter> \\<Union> S)\n                                     \\<le> (\\<Sum>B\\<in>S.\n        card (A \\<inter> B));\n        Suc x = card S; finite S\\<rbrakk>\n       \\<Longrightarrow> card (A \\<inter> \\<Union> S)\n                         \\<le> (\\<Sum>B\\<in>S. card (A \\<inter> B))", "have \"... \\<le> card (A \\<inter> B) + card (A \\<inter> \\<Union>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (A \\<inter> \\<Union> ({B} \\<union> T))\n    \\<le> card (A \\<inter> B) + card (A \\<inter> \\<Union> T)", "by (simp add: card_Un_le inf_sup_distrib1)"], ["proof (state)\nthis:\n  card (A \\<inter> \\<Union> ({B} \\<union> T))\n  \\<le> card (A \\<inter> B) + card (A \\<inter> \\<Union> T)\n\ngoal (2 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>0 = card S; finite S\\<rbrakk>\n       \\<Longrightarrow> card (A \\<inter> \\<Union> S)\n                         \\<le> (\\<Sum>B\\<in>S. card (A \\<inter> B))\n 2. \\<And>x S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>x = card S; finite S\\<rbrakk>\n                   \\<Longrightarrow> card (A \\<inter> \\<Union> S)\n                                     \\<le> (\\<Sum>B\\<in>S.\n        card (A \\<inter> B));\n        Suc x = card S; finite S\\<rbrakk>\n       \\<Longrightarrow> card (A \\<inter> \\<Union> S)\n                         \\<le> (\\<Sum>B\\<in>S. card (A \\<inter> B))", "also"], ["proof (state)\nthis:\n  card (A \\<inter> \\<Union> ({B} \\<union> T))\n  \\<le> card (A \\<inter> B) + card (A \\<inter> \\<Union> T)\n\ngoal (2 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>0 = card S; finite S\\<rbrakk>\n       \\<Longrightarrow> card (A \\<inter> \\<Union> S)\n                         \\<le> (\\<Sum>B\\<in>S. card (A \\<inter> B))\n 2. \\<And>x S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>x = card S; finite S\\<rbrakk>\n                   \\<Longrightarrow> card (A \\<inter> \\<Union> S)\n                                     \\<le> (\\<Sum>B\\<in>S.\n        card (A \\<inter> B));\n        Suc x = card S; finite S\\<rbrakk>\n       \\<Longrightarrow> card (A \\<inter> \\<Union> S)\n                         \\<le> (\\<Sum>B\\<in>S. card (A \\<inter> B))", "have \"... \\<le> card (A \\<inter> B) + (\\<Sum>B \\<in> T. card (A \\<inter> B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (A \\<inter> B) + card (A \\<inter> \\<Union> T)\n    \\<le> card (A \\<inter> B) + (\\<Sum>B\\<in>T. card (A \\<inter> B))", "using Suc *"], ["proof (prove)\nusing this:\n  \\<lbrakk>n = card ?S; finite ?S\\<rbrakk>\n  \\<Longrightarrow> card (A \\<inter> \\<Union> ?S)\n                    \\<le> (\\<Sum>B\\<in>?S. card (A \\<inter> B))\n  Suc n = card S\n  finite S\n  S = {B} \\<union> T\n  card T = n\n  B \\<notin> T\n\ngoal (1 subgoal):\n 1. card (A \\<inter> B) + card (A \\<inter> \\<Union> T)\n    \\<le> card (A \\<inter> B) + (\\<Sum>B\\<in>T. card (A \\<inter> B))", "by simp"], ["proof (state)\nthis:\n  card (A \\<inter> B) + card (A \\<inter> \\<Union> T)\n  \\<le> card (A \\<inter> B) + (\\<Sum>B\\<in>T. card (A \\<inter> B))\n\ngoal (2 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>0 = card S; finite S\\<rbrakk>\n       \\<Longrightarrow> card (A \\<inter> \\<Union> S)\n                         \\<le> (\\<Sum>B\\<in>S. card (A \\<inter> B))\n 2. \\<And>x S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>x = card S; finite S\\<rbrakk>\n                   \\<Longrightarrow> card (A \\<inter> \\<Union> S)\n                                     \\<le> (\\<Sum>B\\<in>S.\n        card (A \\<inter> B));\n        Suc x = card S; finite S\\<rbrakk>\n       \\<Longrightarrow> card (A \\<inter> \\<Union> S)\n                         \\<le> (\\<Sum>B\\<in>S. card (A \\<inter> B))", "also"], ["proof (state)\nthis:\n  card (A \\<inter> B) + card (A \\<inter> \\<Union> T)\n  \\<le> card (A \\<inter> B) + (\\<Sum>B\\<in>T. card (A \\<inter> B))\n\ngoal (2 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>0 = card S; finite S\\<rbrakk>\n       \\<Longrightarrow> card (A \\<inter> \\<Union> S)\n                         \\<le> (\\<Sum>B\\<in>S. card (A \\<inter> B))\n 2. \\<And>x S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>x = card S; finite S\\<rbrakk>\n                   \\<Longrightarrow> card (A \\<inter> \\<Union> S)\n                                     \\<le> (\\<Sum>B\\<in>S.\n        card (A \\<inter> B));\n        Suc x = card S; finite S\\<rbrakk>\n       \\<Longrightarrow> card (A \\<inter> \\<Union> S)\n                         \\<le> (\\<Sum>B\\<in>S. card (A \\<inter> B))", "have \"... \\<le> (\\<Sum>B \\<in> S. card (A \\<inter> B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (A \\<inter> B) + (\\<Sum>B\\<in>T. card (A \\<inter> B))\n    \\<le> (\\<Sum>B\\<in>S. card (A \\<inter> B))", "using Suc.prems *"], ["proof (prove)\nusing this:\n  finite S\n  S = {B} \\<union> T\n  card T = n\n  B \\<notin> T\n\ngoal (1 subgoal):\n 1. card (A \\<inter> B) + (\\<Sum>B\\<in>T. card (A \\<inter> B))\n    \\<le> (\\<Sum>B\\<in>S. card (A \\<inter> B))", "by simp"], ["proof (state)\nthis:\n  card (A \\<inter> B) + (\\<Sum>B\\<in>T. card (A \\<inter> B))\n  \\<le> (\\<Sum>B\\<in>S. card (A \\<inter> B))\n\ngoal (2 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>0 = card S; finite S\\<rbrakk>\n       \\<Longrightarrow> card (A \\<inter> \\<Union> S)\n                         \\<le> (\\<Sum>B\\<in>S. card (A \\<inter> B))\n 2. \\<And>x S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>x = card S; finite S\\<rbrakk>\n                   \\<Longrightarrow> card (A \\<inter> \\<Union> S)\n                                     \\<le> (\\<Sum>B\\<in>S.\n        card (A \\<inter> B));\n        Suc x = card S; finite S\\<rbrakk>\n       \\<Longrightarrow> card (A \\<inter> \\<Union> S)\n                         \\<le> (\\<Sum>B\\<in>S. card (A \\<inter> B))", "finally"], ["proof (chain)\npicking this:\n  card (A \\<inter> \\<Union> S) \\<le> (\\<Sum>B\\<in>S. card (A \\<inter> B))", "show ?case"], ["proof (prove)\nusing this:\n  card (A \\<inter> \\<Union> S) \\<le> (\\<Sum>B\\<in>S. card (A \\<inter> B))\n\ngoal (1 subgoal):\n 1. card (A \\<inter> \\<Union> S) \\<le> (\\<Sum>B\\<in>S. card (A \\<inter> B))", "."], ["proof (state)\nthis:\n  card (A \\<inter> \\<Union> S) \\<le> (\\<Sum>B\\<in>S. card (A \\<inter> B))\n\ngoal (1 subgoal):\n 1. \\<And>S.\n       \\<lbrakk>0 = card S; finite S\\<rbrakk>\n       \\<Longrightarrow> card (A \\<inter> \\<Union> S)\n                         \\<le> (\\<Sum>B\\<in>S. card (A \\<inter> B))", "qed simp"], ["", "lemma pigeonhole:\n  assumes \"finite T\" \"S \\<subseteq> \\<Union>T\" \"card T < card S\"\n  shows \"\\<exists>x \\<in> S. \\<exists>y \\<in> S. \\<exists>X \\<in> T. x \\<noteq> y \\<and> x \\<in> X \\<and> y \\<in> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>S.\n       \\<exists>y\\<in>S.\n          \\<exists>X\\<in>T. x \\<noteq> y \\<and> x \\<in> X \\<and> y \\<in> X", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x\\<in>S.\n               \\<exists>y\\<in>S.\n                  \\<exists>X\\<in>T.\n                     x \\<noteq> y \\<and>\n                     x \\<in> X \\<and> y \\<in> X) \\<Longrightarrow>\n    False", "assume \"\\<not> (\\<exists>x \\<in> S. \\<exists>y \\<in> S. \\<exists>X \\<in> T. x \\<noteq> y \\<and> x \\<in> X \\<and> y \\<in> X)\""], ["proof (state)\nthis:\n  \\<not> (\\<exists>x\\<in>S.\n             \\<exists>y\\<in>S.\n                \\<exists>X\\<in>T.\n                   x \\<noteq> y \\<and> x \\<in> X \\<and> y \\<in> X)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x\\<in>S.\n               \\<exists>y\\<in>S.\n                  \\<exists>X\\<in>T.\n                     x \\<noteq> y \\<and>\n                     x \\<in> X \\<and> y \\<in> X) \\<Longrightarrow>\n    False", "hence *: \"\\<forall>X \\<in> T. card (S \\<inter> X) \\<le> 1\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>x\\<in>S.\n             \\<exists>y\\<in>S.\n                \\<exists>X\\<in>T.\n                   x \\<noteq> y \\<and> x \\<in> X \\<and> y \\<in> X)\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>T. card (S \\<inter> X) \\<le> 1", "using card_Int_if_either_in"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>x\\<in>S.\n             \\<exists>y\\<in>S.\n                \\<exists>X\\<in>T.\n                   x \\<noteq> y \\<and> x \\<in> X \\<and> y \\<in> X)\n  \\<forall>x\\<in>?S.\n     \\<forall>y\\<in>?S.\n        x = y \\<or> x \\<notin> ?T \\<or> y \\<notin> ?T \\<Longrightarrow>\n  card (?S \\<inter> ?T) \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>T. card (S \\<inter> X) \\<le> 1", "by metis"], ["proof (state)\nthis:\n  \\<forall>X\\<in>T. card (S \\<inter> X) \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x\\<in>S.\n               \\<exists>y\\<in>S.\n                  \\<exists>X\\<in>T.\n                     x \\<noteq> y \\<and>\n                     x \\<in> X \\<and> y \\<in> X) \\<Longrightarrow>\n    False", "have \"card T < card (S \\<inter> \\<Union>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card T < card (S \\<inter> \\<Union> T)", "using Int_absorb2 assms"], ["proof (prove)\nusing this:\n  ?A \\<subseteq> ?B \\<Longrightarrow> ?A \\<inter> ?B = ?A\n  finite T\n  S \\<subseteq> \\<Union> T\n  card T < card S\n\ngoal (1 subgoal):\n 1. card T < card (S \\<inter> \\<Union> T)", "by fastforce"], ["proof (state)\nthis:\n  card T < card (S \\<inter> \\<Union> T)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x\\<in>S.\n               \\<exists>y\\<in>S.\n                  \\<exists>X\\<in>T.\n                     x \\<noteq> y \\<and>\n                     x \\<in> X \\<and> y \\<in> X) \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  card T < card (S \\<inter> \\<Union> T)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x\\<in>S.\n               \\<exists>y\\<in>S.\n                  \\<exists>X\\<in>T.\n                     x \\<noteq> y \\<and>\n                     x \\<in> X \\<and> y \\<in> X) \\<Longrightarrow>\n    False", "have \"... \\<le> (\\<Sum>X \\<in> T. card (S \\<inter> X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (S \\<inter> \\<Union> T) \\<le> (\\<Sum>X\\<in>T. card (S \\<inter> X))", "using assms(1) card_Int_Un_le_Sum_card_Int"], ["proof (prove)\nusing this:\n  finite T\n  finite ?S \\<Longrightarrow>\n  card (?A \\<inter> \\<Union> ?S)\n  \\<le> (\\<Sum>B\\<in>?S. card (?A \\<inter> B))\n\ngoal (1 subgoal):\n 1. card (S \\<inter> \\<Union> T) \\<le> (\\<Sum>X\\<in>T. card (S \\<inter> X))", "by blast"], ["proof (state)\nthis:\n  card (S \\<inter> \\<Union> T) \\<le> (\\<Sum>X\\<in>T. card (S \\<inter> X))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x\\<in>S.\n               \\<exists>y\\<in>S.\n                  \\<exists>X\\<in>T.\n                     x \\<noteq> y \\<and>\n                     x \\<in> X \\<and> y \\<in> X) \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  card (S \\<inter> \\<Union> T) \\<le> (\\<Sum>X\\<in>T. card (S \\<inter> X))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x\\<in>S.\n               \\<exists>y\\<in>S.\n                  \\<exists>X\\<in>T.\n                     x \\<noteq> y \\<and>\n                     x \\<in> X \\<and> y \\<in> X) \\<Longrightarrow>\n    False", "have \"... \\<le> card T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>X\\<in>T. card (S \\<inter> X)) \\<le> card T", "using * sum_mono"], ["proof (prove)\nusing this:\n  \\<forall>X\\<in>T. card (S \\<inter> X) \\<le> 1\n  (\\<And>i. i \\<in> ?K \\<Longrightarrow> ?f i \\<le> ?g i) \\<Longrightarrow>\n  sum ?f ?K \\<le> sum ?g ?K\n\ngoal (1 subgoal):\n 1. (\\<Sum>X\\<in>T. card (S \\<inter> X)) \\<le> card T", "by fastforce"], ["proof (state)\nthis:\n  (\\<Sum>X\\<in>T. card (S \\<inter> X)) \\<le> card T\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x\\<in>S.\n               \\<exists>y\\<in>S.\n                  \\<exists>X\\<in>T.\n                     x \\<noteq> y \\<and>\n                     x \\<in> X \\<and> y \\<in> X) \\<Longrightarrow>\n    False", "finally"], ["proof (chain)\npicking this:\n  card T < card T", "show False"], ["proof (prove)\nusing this:\n  card T < card T\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"Delta Sparse Points within a Square\""], ["", "lemma max_points_square:\n  assumes \"\\<forall>p \\<in> ps. p \\<in> cbox (x, y) (x + \\<delta>, y + \\<delta>)\" \"sparse \\<delta> ps\" \"0 \\<le> \\<delta>\"\n  shows \"card ps \\<le> 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card ps \\<le> 4", "proof (cases \"\\<delta> = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<delta> = 0 \\<Longrightarrow> card ps \\<le> 4\n 2. \\<delta> \\<noteq> 0 \\<Longrightarrow> card ps \\<le> 4", "case True"], ["proof (state)\nthis:\n  \\<delta> = 0\n\ngoal (2 subgoals):\n 1. \\<delta> = 0 \\<Longrightarrow> card ps \\<le> 4\n 2. \\<delta> \\<noteq> 0 \\<Longrightarrow> card ps \\<le> 4", "hence \"{ (x, y) } = cbox (x, y) (x + \\<delta>, y + \\<delta>)\""], ["proof (prove)\nusing this:\n  \\<delta> = 0\n\ngoal (1 subgoal):\n 1. {(x, y)} = cbox (x, y) (x + \\<delta>, y + \\<delta>)", "using cbox_def"], ["proof (prove)\nusing this:\n  \\<delta> = 0\n  cbox ?a ?b =\n  {x. \\<forall>i\\<in>Basis.\n         ?a \\<bullet> i \\<le> x \\<bullet> i \\<and>\n         x \\<bullet> i \\<le> ?b \\<bullet> i}\n\ngoal (1 subgoal):\n 1. {(x, y)} = cbox (x, y) (x + \\<delta>, y + \\<delta>)", "by simp"], ["proof (state)\nthis:\n  {(x, y)} = cbox (x, y) (x + \\<delta>, y + \\<delta>)\n\ngoal (2 subgoals):\n 1. \\<delta> = 0 \\<Longrightarrow> card ps \\<le> 4\n 2. \\<delta> \\<noteq> 0 \\<Longrightarrow> card ps \\<le> 4", "hence \"\\<forall>p \\<in> ps. p = (x, y)\""], ["proof (prove)\nusing this:\n  {(x, y)} = cbox (x, y) (x + \\<delta>, y + \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<forall>xa\\<in>ps.\n       (case xa of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)) =\n       (x, y)", "using assms(1)"], ["proof (prove)\nusing this:\n  {(x, y)} = cbox (x, y) (x + \\<delta>, y + \\<delta>)\n  \\<forall>p\\<in>ps.\n     (case p of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     \\<in> cbox (x, y) (x + \\<delta>, y + \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<forall>xa\\<in>ps.\n       (case xa of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)) =\n       (x, y)", "by blast"], ["proof (state)\nthis:\n  \\<forall>xa\\<in>ps.\n     (case xa of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)) =\n     (x, y)\n\ngoal (2 subgoals):\n 1. \\<delta> = 0 \\<Longrightarrow> card ps \\<le> 4\n 2. \\<delta> \\<noteq> 0 \\<Longrightarrow> card ps \\<le> 4", "hence \"\\<forall>p \\<in> ps. \\<forall>q \\<in> ps. p = q\""], ["proof (prove)\nusing this:\n  \\<forall>xa\\<in>ps.\n     (case xa of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)) =\n     (x, y)\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>ps. \\<forall>q\\<in>ps. p = q", "apply (auto split: prod.splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>\\<forall>xa\\<in>ps.\n                   \\<forall>x1 x2.\n                      xa = (x1, x2) \\<longrightarrow>\n                      real_of_int x1 = x \\<and> real_of_int x2 = y;\n        (a, b) \\<in> ps; (aa, ba) \\<in> ps\\<rbrakk>\n       \\<Longrightarrow> a = aa\n 2. \\<And>a b aa ba.\n       \\<lbrakk>\\<forall>xa\\<in>ps.\n                   \\<forall>x1 x2.\n                      xa = (x1, x2) \\<longrightarrow>\n                      real_of_int x1 = x \\<and> real_of_int x2 = y;\n        (a, b) \\<in> ps; (aa, ba) \\<in> ps\\<rbrakk>\n       \\<Longrightarrow> b = ba", "by (metis of_int_eq_iff)+"], ["proof (state)\nthis:\n  \\<forall>p\\<in>ps. \\<forall>q\\<in>ps. p = q\n\ngoal (2 subgoals):\n 1. \\<delta> = 0 \\<Longrightarrow> card ps \\<le> 4\n 2. \\<delta> \\<noteq> 0 \\<Longrightarrow> card ps \\<le> 4", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>ps. \\<forall>q\\<in>ps. p = q\n\ngoal (1 subgoal):\n 1. card ps \\<le> 4", "using card_le_1_if_pairwise_eq"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>ps. \\<forall>q\\<in>ps. p = q\n  \\<forall>x\\<in>?S. \\<forall>y\\<in>?S. x = y \\<Longrightarrow>\n  card ?S \\<le> 1\n\ngoal (1 subgoal):\n 1. card ps \\<le> 4", "by force"], ["proof (state)\nthis:\n  card ps \\<le> 4\n\ngoal (1 subgoal):\n 1. \\<delta> \\<noteq> 0 \\<Longrightarrow> card ps \\<le> 4", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<delta> \\<noteq> 0 \\<Longrightarrow> card ps \\<le> 4", "case False"], ["proof (state)\nthis:\n  \\<delta> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<delta> \\<noteq> 0 \\<Longrightarrow> card ps \\<le> 4", "hence \\<delta>: \"0 < \\<delta>\""], ["proof (prove)\nusing this:\n  \\<delta> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < \\<delta>", "using assms(3)"], ["proof (prove)\nusing this:\n  \\<delta> \\<noteq> 0\n  0 \\<le> \\<delta>\n\ngoal (1 subgoal):\n 1. 0 < \\<delta>", "by simp"], ["proof (state)\nthis:\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. \\<delta> \\<noteq> 0 \\<Longrightarrow> card ps \\<le> 4", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. card ps \\<le> 4", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> card ps \\<le> 4 \\<Longrightarrow> False", "assume A: \"\\<not> (card ps \\<le> 4)\""], ["proof (state)\nthis:\n  \\<not> card ps \\<le> 4\n\ngoal (1 subgoal):\n 1. \\<not> card ps \\<le> 4 \\<Longrightarrow> False", "define PS where PS_def: \"PS = (\\<lambda>(x, y). (real_of_int x, real_of_int y)) ` ps\""], ["proof (state)\nthis:\n  PS = (\\<lambda>(x, y). (real_of_int x, real_of_int y)) ` ps\n\ngoal (1 subgoal):\n 1. \\<not> card ps \\<le> 4 \\<Longrightarrow> False", "have \"inj_on (\\<lambda>(x, y). (real_of_int x, real_of_int y)) ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>(x, y). (real_of_int x, real_of_int y)) ps", "using inj_on_def"], ["proof (prove)\nusing this:\n  inj_on ?f ?A =\n  (\\<forall>x\\<in>?A.\n      \\<forall>y\\<in>?A. ?f x = ?f y \\<longrightarrow> x = y)\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>(x, y). (real_of_int x, real_of_int y)) ps", "by fastforce"], ["proof (state)\nthis:\n  inj_on (\\<lambda>(x, y). (real_of_int x, real_of_int y)) ps\n\ngoal (1 subgoal):\n 1. \\<not> card ps \\<le> 4 \\<Longrightarrow> False", "hence *: \"\\<not> (card PS \\<le> 4)\""], ["proof (prove)\nusing this:\n  inj_on (\\<lambda>(x, y). (real_of_int x, real_of_int y)) ps\n\ngoal (1 subgoal):\n 1. \\<not> card PS \\<le> 4", "using A PS_def"], ["proof (prove)\nusing this:\n  inj_on (\\<lambda>(x, y). (real_of_int x, real_of_int y)) ps\n  \\<not> card ps \\<le> 4\n  PS = (\\<lambda>(x, y). (real_of_int x, real_of_int y)) ` ps\n\ngoal (1 subgoal):\n 1. \\<not> card PS \\<le> 4", "by (simp add: card_image)"], ["proof (state)\nthis:\n  \\<not> card PS \\<le> 4\n\ngoal (1 subgoal):\n 1. \\<not> card ps \\<le> 4 \\<Longrightarrow> False", "let ?x' = \"x + \\<delta> / 2\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> card ps \\<le> 4 \\<Longrightarrow> False", "let ?y' = \"y + \\<delta> / 2\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> card ps \\<le> 4 \\<Longrightarrow> False", "let ?ll = \"cbox ( x ,  y ) (?x'   , ?y'   )\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> card ps \\<le> 4 \\<Longrightarrow> False", "let ?lu = \"cbox ( x , ?y') (?x'   ,  y + \\<delta>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> card ps \\<le> 4 \\<Longrightarrow> False", "let ?rl = \"cbox (?x',  y ) ( x + \\<delta>, ?y'   )\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> card ps \\<le> 4 \\<Longrightarrow> False", "let ?ru = \"cbox (?x', ?y') ( x + \\<delta>,  y + \\<delta>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> card ps \\<le> 4 \\<Longrightarrow> False", "let ?sq = \"{ ?ll, ?lu, ?rl, ?ru }\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> card ps \\<le> 4 \\<Longrightarrow> False", "have card_le_4: \"card ?sq \\<le> 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     {cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2),\n      cbox (x, y + \\<delta> / 2) (x + \\<delta> / 2, y + \\<delta>),\n      cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta> / 2),\n      cbox (x + \\<delta> / 2, y + \\<delta> / 2)\n       (x + \\<delta>, y + \\<delta>)}\n    \\<le> 4", "by (simp add: card_insert_le_m1)"], ["proof (state)\nthis:\n  card\n   {cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2),\n    cbox (x, y + \\<delta> / 2) (x + \\<delta> / 2, y + \\<delta>),\n    cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta> / 2),\n    cbox (x + \\<delta> / 2, y + \\<delta> / 2) (x + \\<delta>, y + \\<delta>)}\n  \\<le> 4\n\ngoal (1 subgoal):\n 1. \\<not> card ps \\<le> 4 \\<Longrightarrow> False", "have \"cbox (x, y) (?x', y + \\<delta>) = ?ll \\<union> ?lu\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cbox (x, y) (x + \\<delta> / 2, y + \\<delta>) =\n    cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2) \\<union>\n    cbox (x, y + \\<delta> / 2) (x + \\<delta> / 2, y + \\<delta>)", "using cbox_top_un assms(3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y\\<^sub>0 \\<le> ?y\\<^sub>1; ?y\\<^sub>1 \\<le> ?y\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> cbox (?x\\<^sub>0, ?y\\<^sub>0)\n                     (?x\\<^sub>1, ?y\\<^sub>1) \\<union>\n                    cbox (?x\\<^sub>0, ?y\\<^sub>1) (?x\\<^sub>1, ?y\\<^sub>2) =\n                    cbox (?x\\<^sub>0, ?y\\<^sub>0) (?x\\<^sub>1, ?y\\<^sub>2)\n  0 \\<le> \\<delta>\n\ngoal (1 subgoal):\n 1. cbox (x, y) (x + \\<delta> / 2, y + \\<delta>) =\n    cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2) \\<union>\n    cbox (x, y + \\<delta> / 2) (x + \\<delta> / 2, y + \\<delta>)", "by auto"], ["proof (state)\nthis:\n  cbox (x, y) (x + \\<delta> / 2, y + \\<delta>) =\n  cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2) \\<union>\n  cbox (x, y + \\<delta> / 2) (x + \\<delta> / 2, y + \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<not> card ps \\<le> 4 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  cbox (x, y) (x + \\<delta> / 2, y + \\<delta>) =\n  cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2) \\<union>\n  cbox (x, y + \\<delta> / 2) (x + \\<delta> / 2, y + \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<not> card ps \\<le> 4 \\<Longrightarrow> False", "have \"cbox (?x', y) (x + \\<delta>, y + \\<delta>) = ?rl \\<union> ?ru\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta>) =\n    cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta> / 2) \\<union>\n    cbox (x + \\<delta> / 2, y + \\<delta> / 2) (x + \\<delta>, y + \\<delta>)", "using cbox_top_un assms(3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y\\<^sub>0 \\<le> ?y\\<^sub>1; ?y\\<^sub>1 \\<le> ?y\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> cbox (?x\\<^sub>0, ?y\\<^sub>0)\n                     (?x\\<^sub>1, ?y\\<^sub>1) \\<union>\n                    cbox (?x\\<^sub>0, ?y\\<^sub>1) (?x\\<^sub>1, ?y\\<^sub>2) =\n                    cbox (?x\\<^sub>0, ?y\\<^sub>0) (?x\\<^sub>1, ?y\\<^sub>2)\n  0 \\<le> \\<delta>\n\ngoal (1 subgoal):\n 1. cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta>) =\n    cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta> / 2) \\<union>\n    cbox (x + \\<delta> / 2, y + \\<delta> / 2) (x + \\<delta>, y + \\<delta>)", "by auto"], ["proof (state)\nthis:\n  cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta>) =\n  cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta> / 2) \\<union>\n  cbox (x + \\<delta> / 2, y + \\<delta> / 2) (x + \\<delta>, y + \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<not> card ps \\<le> 4 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta>) =\n  cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta> / 2) \\<union>\n  cbox (x + \\<delta> / 2, y + \\<delta> / 2) (x + \\<delta>, y + \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<not> card ps \\<le> 4 \\<Longrightarrow> False", "have \"cbox (x, y) (?x', y + \\<delta>) \\<union> cbox (?x', y) (x + \\<delta>, y + \\<delta>) = cbox (x, y) (x + \\<delta>, y + \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cbox (x, y) (x + \\<delta> / 2, y + \\<delta>) \\<union>\n    cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta>) =\n    cbox (x, y) (x + \\<delta>, y + \\<delta>)", "using cbox_right_un assms(3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x\\<^sub>0 \\<le> ?x\\<^sub>1; ?x\\<^sub>1 \\<le> ?x\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> cbox (?x\\<^sub>0, ?y\\<^sub>0)\n                     (?x\\<^sub>1, ?y\\<^sub>1) \\<union>\n                    cbox (?x\\<^sub>1, ?y\\<^sub>0) (?x\\<^sub>2, ?y\\<^sub>1) =\n                    cbox (?x\\<^sub>0, ?y\\<^sub>0) (?x\\<^sub>2, ?y\\<^sub>1)\n  0 \\<le> \\<delta>\n\ngoal (1 subgoal):\n 1. cbox (x, y) (x + \\<delta> / 2, y + \\<delta>) \\<union>\n    cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta>) =\n    cbox (x, y) (x + \\<delta>, y + \\<delta>)", "by simp"], ["proof (state)\nthis:\n  cbox (x, y) (x + \\<delta> / 2, y + \\<delta>) \\<union>\n  cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta>) =\n  cbox (x, y) (x + \\<delta>, y + \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<not> card ps \\<le> 4 \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  cbox (x, y) (x + \\<delta> / 2, y + \\<delta>) =\n  cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2) \\<union>\n  cbox (x, y + \\<delta> / 2) (x + \\<delta> / 2, y + \\<delta>)\n  cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta>) =\n  cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta> / 2) \\<union>\n  cbox (x + \\<delta> / 2, y + \\<delta> / 2) (x + \\<delta>, y + \\<delta>)\n  cbox (x, y) (x + \\<delta> / 2, y + \\<delta>) \\<union>\n  cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta>) =\n  cbox (x, y) (x + \\<delta>, y + \\<delta>)", "have \"?ll \\<union> ?lu \\<union> ?rl \\<union> ?ru = cbox (x, y) (x + \\<delta>, y + \\<delta>)\""], ["proof (prove)\nusing this:\n  cbox (x, y) (x + \\<delta> / 2, y + \\<delta>) =\n  cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2) \\<union>\n  cbox (x, y + \\<delta> / 2) (x + \\<delta> / 2, y + \\<delta>)\n  cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta>) =\n  cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta> / 2) \\<union>\n  cbox (x + \\<delta> / 2, y + \\<delta> / 2) (x + \\<delta>, y + \\<delta>)\n  cbox (x, y) (x + \\<delta> / 2, y + \\<delta>) \\<union>\n  cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta>) =\n  cbox (x, y) (x + \\<delta>, y + \\<delta>)\n\ngoal (1 subgoal):\n 1. cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2) \\<union>\n    cbox (x, y + \\<delta> / 2) (x + \\<delta> / 2, y + \\<delta>) \\<union>\n    cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta> / 2) \\<union>\n    cbox (x + \\<delta> / 2, y + \\<delta> / 2) (x + \\<delta>, y + \\<delta>) =\n    cbox (x, y) (x + \\<delta>, y + \\<delta>)", "by blast"], ["proof (state)\nthis:\n  cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2) \\<union>\n  cbox (x, y + \\<delta> / 2) (x + \\<delta> / 2, y + \\<delta>) \\<union>\n  cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta> / 2) \\<union>\n  cbox (x + \\<delta> / 2, y + \\<delta> / 2) (x + \\<delta>, y + \\<delta>) =\n  cbox (x, y) (x + \\<delta>, y + \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<not> card ps \\<le> 4 \\<Longrightarrow> False", "hence \"PS \\<subseteq> \\<Union>(?sq)\""], ["proof (prove)\nusing this:\n  cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2) \\<union>\n  cbox (x, y + \\<delta> / 2) (x + \\<delta> / 2, y + \\<delta>) \\<union>\n  cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta> / 2) \\<union>\n  cbox (x + \\<delta> / 2, y + \\<delta> / 2) (x + \\<delta>, y + \\<delta>) =\n  cbox (x, y) (x + \\<delta>, y + \\<delta>)\n\ngoal (1 subgoal):\n 1. PS \\<subseteq> \\<Union>\n                    {cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2),\n                     cbox (x, y + \\<delta> / 2)\n                      (x + \\<delta> / 2, y + \\<delta>),\n                     cbox (x + \\<delta> / 2, y)\n                      (x + \\<delta>, y + \\<delta> / 2),\n                     cbox (x + \\<delta> / 2, y + \\<delta> / 2)\n                      (x + \\<delta>, y + \\<delta>)}", "using assms(1) PS_def"], ["proof (prove)\nusing this:\n  cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2) \\<union>\n  cbox (x, y + \\<delta> / 2) (x + \\<delta> / 2, y + \\<delta>) \\<union>\n  cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta> / 2) \\<union>\n  cbox (x + \\<delta> / 2, y + \\<delta> / 2) (x + \\<delta>, y + \\<delta>) =\n  cbox (x, y) (x + \\<delta>, y + \\<delta>)\n  \\<forall>p\\<in>ps.\n     (case p of (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n     \\<in> cbox (x, y) (x + \\<delta>, y + \\<delta>)\n  PS = (\\<lambda>(x, y). (real_of_int x, real_of_int y)) ` ps\n\ngoal (1 subgoal):\n 1. PS \\<subseteq> \\<Union>\n                    {cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2),\n                     cbox (x, y + \\<delta> / 2)\n                      (x + \\<delta> / 2, y + \\<delta>),\n                     cbox (x + \\<delta> / 2, y)\n                      (x + \\<delta>, y + \\<delta> / 2),\n                     cbox (x + \\<delta> / 2, y + \\<delta> / 2)\n                      (x + \\<delta>, y + \\<delta>)}", "by (auto split: prod.splits)"], ["proof (state)\nthis:\n  PS \\<subseteq> \\<Union>\n                  {cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2),\n                   cbox (x, y + \\<delta> / 2)\n                    (x + \\<delta> / 2, y + \\<delta>),\n                   cbox (x + \\<delta> / 2, y)\n                    (x + \\<delta>, y + \\<delta> / 2),\n                   cbox (x + \\<delta> / 2, y + \\<delta> / 2)\n                    (x + \\<delta>, y + \\<delta>)}\n\ngoal (1 subgoal):\n 1. \\<not> card ps \\<le> 4 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  PS \\<subseteq> \\<Union>\n                  {cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2),\n                   cbox (x, y + \\<delta> / 2)\n                    (x + \\<delta> / 2, y + \\<delta>),\n                   cbox (x + \\<delta> / 2, y)\n                    (x + \\<delta>, y + \\<delta> / 2),\n                   cbox (x + \\<delta> / 2, y + \\<delta> / 2)\n                    (x + \\<delta>, y + \\<delta>)}\n\ngoal (1 subgoal):\n 1. \\<not> card ps \\<le> 4 \\<Longrightarrow> False", "have \"card ?sq < card PS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     {cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2),\n      cbox (x, y + \\<delta> / 2) (x + \\<delta> / 2, y + \\<delta>),\n      cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta> / 2),\n      cbox (x + \\<delta> / 2, y + \\<delta> / 2)\n       (x + \\<delta>, y + \\<delta>)}\n    < card PS", "using * card_insert_le_m1 card_le_4"], ["proof (prove)\nusing this:\n  \\<not> card PS \\<le> 4\n  \\<lbrakk>0 < ?n; card ?y \\<le> ?n - 1\\<rbrakk>\n  \\<Longrightarrow> card (insert ?x ?y) \\<le> ?n\n  card\n   {cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2),\n    cbox (x, y + \\<delta> / 2) (x + \\<delta> / 2, y + \\<delta>),\n    cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta> / 2),\n    cbox (x + \\<delta> / 2, y + \\<delta> / 2) (x + \\<delta>, y + \\<delta>)}\n  \\<le> 4\n\ngoal (1 subgoal):\n 1. card\n     {cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2),\n      cbox (x, y + \\<delta> / 2) (x + \\<delta> / 2, y + \\<delta>),\n      cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta> / 2),\n      cbox (x + \\<delta> / 2, y + \\<delta> / 2)\n       (x + \\<delta>, y + \\<delta>)}\n    < card PS", "by linarith"], ["proof (state)\nthis:\n  card\n   {cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2),\n    cbox (x, y + \\<delta> / 2) (x + \\<delta> / 2, y + \\<delta>),\n    cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta> / 2),\n    cbox (x + \\<delta> / 2, y + \\<delta> / 2) (x + \\<delta>, y + \\<delta>)}\n  < card PS\n\ngoal (1 subgoal):\n 1. \\<not> card ps \\<le> 4 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  card\n   {cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2),\n    cbox (x, y + \\<delta> / 2) (x + \\<delta> / 2, y + \\<delta>),\n    cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta> / 2),\n    cbox (x + \\<delta> / 2, y + \\<delta> / 2) (x + \\<delta>, y + \\<delta>)}\n  < card PS\n\ngoal (1 subgoal):\n 1. \\<not> card ps \\<le> 4 \\<Longrightarrow> False", "have \"finite ?sq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2),\n      cbox (x, y + \\<delta> / 2) (x + \\<delta> / 2, y + \\<delta>),\n      cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta> / 2),\n      cbox (x + \\<delta> / 2, y + \\<delta> / 2)\n       (x + \\<delta>, y + \\<delta>)}", "by simp"], ["proof (state)\nthis:\n  finite\n   {cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2),\n    cbox (x, y + \\<delta> / 2) (x + \\<delta> / 2, y + \\<delta>),\n    cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta> / 2),\n    cbox (x + \\<delta> / 2, y + \\<delta> / 2) (x + \\<delta>, y + \\<delta>)}\n\ngoal (1 subgoal):\n 1. \\<not> card ps \\<le> 4 \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  PS \\<subseteq> \\<Union>\n                  {cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2),\n                   cbox (x, y + \\<delta> / 2)\n                    (x + \\<delta> / 2, y + \\<delta>),\n                   cbox (x + \\<delta> / 2, y)\n                    (x + \\<delta>, y + \\<delta> / 2),\n                   cbox (x + \\<delta> / 2, y + \\<delta> / 2)\n                    (x + \\<delta>, y + \\<delta>)}\n  card\n   {cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2),\n    cbox (x, y + \\<delta> / 2) (x + \\<delta> / 2, y + \\<delta>),\n    cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta> / 2),\n    cbox (x + \\<delta> / 2, y + \\<delta> / 2) (x + \\<delta>, y + \\<delta>)}\n  < card PS\n  finite\n   {cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2),\n    cbox (x, y + \\<delta> / 2) (x + \\<delta> / 2, y + \\<delta>),\n    cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta> / 2),\n    cbox (x + \\<delta> / 2, y + \\<delta> / 2) (x + \\<delta>, y + \\<delta>)}", "have \"\\<exists>p\\<^sub>0 \\<in> PS. \\<exists>p\\<^sub>1 \\<in> PS. \\<exists>S \\<in> ?sq. (p\\<^sub>0 \\<noteq> p\\<^sub>1 \\<and> p\\<^sub>0 \\<in> S \\<and> p\\<^sub>1 \\<in> S)\""], ["proof (prove)\nusing this:\n  PS \\<subseteq> \\<Union>\n                  {cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2),\n                   cbox (x, y + \\<delta> / 2)\n                    (x + \\<delta> / 2, y + \\<delta>),\n                   cbox (x + \\<delta> / 2, y)\n                    (x + \\<delta>, y + \\<delta> / 2),\n                   cbox (x + \\<delta> / 2, y + \\<delta> / 2)\n                    (x + \\<delta>, y + \\<delta>)}\n  card\n   {cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2),\n    cbox (x, y + \\<delta> / 2) (x + \\<delta> / 2, y + \\<delta>),\n    cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta> / 2),\n    cbox (x + \\<delta> / 2, y + \\<delta> / 2) (x + \\<delta>, y + \\<delta>)}\n  < card PS\n  finite\n   {cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2),\n    cbox (x, y + \\<delta> / 2) (x + \\<delta> / 2, y + \\<delta>),\n    cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta> / 2),\n    cbox (x + \\<delta> / 2, y + \\<delta> / 2) (x + \\<delta>, y + \\<delta>)}\n\ngoal (1 subgoal):\n 1. \\<exists>p\\<^sub>0\\<in>PS.\n       \\<exists>p\\<^sub>1\\<in>PS.\n          \\<exists>S\\<in>{cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2),\n                          cbox (x, y + \\<delta> / 2)\n                           (x + \\<delta> / 2, y + \\<delta>),\n                          cbox (x + \\<delta> / 2, y)\n                           (x + \\<delta>, y + \\<delta> / 2),\n                          cbox (x + \\<delta> / 2, y + \\<delta> / 2)\n                           (x + \\<delta>, y + \\<delta>)}.\n             p\\<^sub>0 \\<noteq> p\\<^sub>1 \\<and>\n             p\\<^sub>0 \\<in> S \\<and> p\\<^sub>1 \\<in> S", "using pigeonhole[of ?sq PS]"], ["proof (prove)\nusing this:\n  PS \\<subseteq> \\<Union>\n                  {cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2),\n                   cbox (x, y + \\<delta> / 2)\n                    (x + \\<delta> / 2, y + \\<delta>),\n                   cbox (x + \\<delta> / 2, y)\n                    (x + \\<delta>, y + \\<delta> / 2),\n                   cbox (x + \\<delta> / 2, y + \\<delta> / 2)\n                    (x + \\<delta>, y + \\<delta>)}\n  card\n   {cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2),\n    cbox (x, y + \\<delta> / 2) (x + \\<delta> / 2, y + \\<delta>),\n    cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta> / 2),\n    cbox (x + \\<delta> / 2, y + \\<delta> / 2) (x + \\<delta>, y + \\<delta>)}\n  < card PS\n  finite\n   {cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2),\n    cbox (x, y + \\<delta> / 2) (x + \\<delta> / 2, y + \\<delta>),\n    cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta> / 2),\n    cbox (x + \\<delta> / 2, y + \\<delta> / 2) (x + \\<delta>, y + \\<delta>)}\n  \\<lbrakk>finite\n            {cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2),\n             cbox (x, y + \\<delta> / 2) (x + \\<delta> / 2, y + \\<delta>),\n             cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta> / 2),\n             cbox (x + \\<delta> / 2, y + \\<delta> / 2)\n              (x + \\<delta>, y + \\<delta>)};\n   PS \\<subseteq> \\<Union>\n                   {cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2),\n                    cbox (x, y + \\<delta> / 2)\n                     (x + \\<delta> / 2, y + \\<delta>),\n                    cbox (x + \\<delta> / 2, y)\n                     (x + \\<delta>, y + \\<delta> / 2),\n                    cbox (x + \\<delta> / 2, y + \\<delta> / 2)\n                     (x + \\<delta>, y + \\<delta>)};\n   card\n    {cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2),\n     cbox (x, y + \\<delta> / 2) (x + \\<delta> / 2, y + \\<delta>),\n     cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta> / 2),\n     cbox (x + \\<delta> / 2, y + \\<delta> / 2) (x + \\<delta>, y + \\<delta>)}\n   < card PS\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xa\\<in>PS.\n                       \\<exists>ya\\<in>PS.\n                          \\<exists>X\\<in>{cbox (x, y)\n     (x + \\<delta> / 2, y + \\<delta> / 2),\n    cbox (x, y + \\<delta> / 2) (x + \\<delta> / 2, y + \\<delta>),\n    cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta> / 2),\n    cbox (x + \\<delta> / 2, y + \\<delta> / 2) (x + \\<delta>, y + \\<delta>)}.\n                             xa \\<noteq> ya \\<and>\n                             xa \\<in> X \\<and> ya \\<in> X\n\ngoal (1 subgoal):\n 1. \\<exists>p\\<^sub>0\\<in>PS.\n       \\<exists>p\\<^sub>1\\<in>PS.\n          \\<exists>S\\<in>{cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2),\n                          cbox (x, y + \\<delta> / 2)\n                           (x + \\<delta> / 2, y + \\<delta>),\n                          cbox (x + \\<delta> / 2, y)\n                           (x + \\<delta>, y + \\<delta> / 2),\n                          cbox (x + \\<delta> / 2, y + \\<delta> / 2)\n                           (x + \\<delta>, y + \\<delta>)}.\n             p\\<^sub>0 \\<noteq> p\\<^sub>1 \\<and>\n             p\\<^sub>0 \\<in> S \\<and> p\\<^sub>1 \\<in> S", "by blast"], ["proof (state)\nthis:\n  \\<exists>p\\<^sub>0\\<in>PS.\n     \\<exists>p\\<^sub>1\\<in>PS.\n        \\<exists>S\\<in>{cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2),\n                        cbox (x, y + \\<delta> / 2)\n                         (x + \\<delta> / 2, y + \\<delta>),\n                        cbox (x + \\<delta> / 2, y)\n                         (x + \\<delta>, y + \\<delta> / 2),\n                        cbox (x + \\<delta> / 2, y + \\<delta> / 2)\n                         (x + \\<delta>, y + \\<delta>)}.\n           p\\<^sub>0 \\<noteq> p\\<^sub>1 \\<and>\n           p\\<^sub>0 \\<in> S \\<and> p\\<^sub>1 \\<in> S\n\ngoal (1 subgoal):\n 1. \\<not> card ps \\<le> 4 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>p\\<^sub>0\\<in>PS.\n     \\<exists>p\\<^sub>1\\<in>PS.\n        \\<exists>S\\<in>{cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2),\n                        cbox (x, y + \\<delta> / 2)\n                         (x + \\<delta> / 2, y + \\<delta>),\n                        cbox (x + \\<delta> / 2, y)\n                         (x + \\<delta>, y + \\<delta> / 2),\n                        cbox (x + \\<delta> / 2, y + \\<delta> / 2)\n                         (x + \\<delta>, y + \\<delta>)}.\n           p\\<^sub>0 \\<noteq> p\\<^sub>1 \\<and>\n           p\\<^sub>0 \\<in> S \\<and> p\\<^sub>1 \\<in> S", "obtain S p\\<^sub>0 p\\<^sub>1 where #: \"p\\<^sub>0 \\<in> PS\" \"p\\<^sub>1 \\<in> PS\" \"S \\<in> ?sq\" \"p\\<^sub>0 \\<noteq> p\\<^sub>1\" \"p\\<^sub>0 \\<in> S\" \"p\\<^sub>1 \\<in> S\""], ["proof (prove)\nusing this:\n  \\<exists>p\\<^sub>0\\<in>PS.\n     \\<exists>p\\<^sub>1\\<in>PS.\n        \\<exists>S\\<in>{cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2),\n                        cbox (x, y + \\<delta> / 2)\n                         (x + \\<delta> / 2, y + \\<delta>),\n                        cbox (x + \\<delta> / 2, y)\n                         (x + \\<delta>, y + \\<delta> / 2),\n                        cbox (x + \\<delta> / 2, y + \\<delta> / 2)\n                         (x + \\<delta>, y + \\<delta>)}.\n           p\\<^sub>0 \\<noteq> p\\<^sub>1 \\<and>\n           p\\<^sub>0 \\<in> S \\<and> p\\<^sub>1 \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<And>p\\<^sub>0 p\\<^sub>1 S.\n        \\<lbrakk>p\\<^sub>0 \\<in> PS; p\\<^sub>1 \\<in> PS;\n         S \\<in> {cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2),\n                  cbox (x, y + \\<delta> / 2)\n                   (x + \\<delta> / 2, y + \\<delta>),\n                  cbox (x + \\<delta> / 2, y)\n                   (x + \\<delta>, y + \\<delta> / 2),\n                  cbox (x + \\<delta> / 2, y + \\<delta> / 2)\n                   (x + \\<delta>, y + \\<delta>)};\n         p\\<^sub>0 \\<noteq> p\\<^sub>1; p\\<^sub>0 \\<in> S;\n         p\\<^sub>1 \\<in> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  p\\<^sub>0 \\<in> PS\n  p\\<^sub>1 \\<in> PS\n  S \\<in> {cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2),\n           cbox (x, y + \\<delta> / 2) (x + \\<delta> / 2, y + \\<delta>),\n           cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta> / 2),\n           cbox (x + \\<delta> / 2, y + \\<delta> / 2)\n            (x + \\<delta>, y + \\<delta>)}\n  p\\<^sub>0 \\<noteq> p\\<^sub>1\n  p\\<^sub>0 \\<in> S\n  p\\<^sub>1 \\<in> S\n\ngoal (1 subgoal):\n 1. \\<not> card ps \\<le> 4 \\<Longrightarrow> False", "have D: \"0 \\<le> \\<delta> / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> \\<delta> / 2", "using assms(3)"], ["proof (prove)\nusing this:\n  0 \\<le> \\<delta>\n\ngoal (1 subgoal):\n 1. 0 \\<le> \\<delta> / 2", "by simp"], ["proof (state)\nthis:\n  0 \\<le> \\<delta> / 2\n\ngoal (1 subgoal):\n 1. \\<not> card ps \\<le> 4 \\<Longrightarrow> False", "have LL: \"\\<forall>p\\<^sub>0 \\<in> ?ll. \\<forall>p\\<^sub>1 \\<in> ?ll. dist p\\<^sub>0 p\\<^sub>1 \\<le> sqrt 2 * (\\<delta> / 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<^sub>0\\<in>cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2).\n       \\<forall>p\\<^sub>1\n                \\<in>cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2).\n          dist p\\<^sub>0 p\\<^sub>1 \\<le> sqrt 2 * (\\<delta> / 2)", "using cbox_max_dist[of \"(x, y)\" x y \"(?x', ?y')\" \"\\<delta> / 2\"] D"], ["proof (prove)\nusing this:\n  \\<lbrakk>(x, y) = (x, y);\n   (x + \\<delta> / 2, y + \\<delta> / 2) =\n   (x + \\<delta> / 2, y + \\<delta> / 2);\n   (?x\\<^sub>0, ?y\\<^sub>0)\n   \\<in> cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2);\n   (?x\\<^sub>1, ?y\\<^sub>1)\n   \\<in> cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2);\n   0 \\<le> \\<delta> / 2\\<rbrakk>\n  \\<Longrightarrow> dist (?x\\<^sub>0, ?y\\<^sub>0) (?x\\<^sub>1, ?y\\<^sub>1)\n                    \\<le> sqrt 2 * (\\<delta> / 2)\n  0 \\<le> \\<delta> / 2\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<^sub>0\\<in>cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2).\n       \\<forall>p\\<^sub>1\n                \\<in>cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2).\n          dist p\\<^sub>0 p\\<^sub>1 \\<le> sqrt 2 * (\\<delta> / 2)", "by auto"], ["proof (state)\nthis:\n  \\<forall>p\\<^sub>0\\<in>cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2).\n     \\<forall>p\\<^sub>1\n              \\<in>cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2).\n        dist p\\<^sub>0 p\\<^sub>1 \\<le> sqrt 2 * (\\<delta> / 2)\n\ngoal (1 subgoal):\n 1. \\<not> card ps \\<le> 4 \\<Longrightarrow> False", "have LU: \"\\<forall>p\\<^sub>0 \\<in> ?lu. \\<forall>p\\<^sub>1 \\<in> ?lu. dist p\\<^sub>0 p\\<^sub>1 \\<le> sqrt 2 * (\\<delta> / 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<^sub>0\n             \\<in>cbox (x, y + \\<delta> / 2)\n                   (x + \\<delta> / 2, y + \\<delta>).\n       \\<forall>p\\<^sub>1\n                \\<in>cbox (x, y + \\<delta> / 2)\n                      (x + \\<delta> / 2, y + \\<delta>).\n          dist p\\<^sub>0 p\\<^sub>1 \\<le> sqrt 2 * (\\<delta> / 2)", "using cbox_max_dist[of \"(x, ?y')\" x ?y' \"(?x', y + \\<delta>)\" \"\\<delta> / 2\"] D"], ["proof (prove)\nusing this:\n  \\<lbrakk>(x, y + \\<delta> / 2) = (x, y + \\<delta> / 2);\n   (x + \\<delta> / 2, y + \\<delta>) =\n   (x + \\<delta> / 2, y + \\<delta> / 2 + \\<delta> / 2);\n   (?x\\<^sub>0, ?y\\<^sub>0)\n   \\<in> cbox (x, y + \\<delta> / 2) (x + \\<delta> / 2, y + \\<delta>);\n   (?x\\<^sub>1, ?y\\<^sub>1)\n   \\<in> cbox (x, y + \\<delta> / 2) (x + \\<delta> / 2, y + \\<delta>);\n   0 \\<le> \\<delta> / 2\\<rbrakk>\n  \\<Longrightarrow> dist (?x\\<^sub>0, ?y\\<^sub>0) (?x\\<^sub>1, ?y\\<^sub>1)\n                    \\<le> sqrt 2 * (\\<delta> / 2)\n  0 \\<le> \\<delta> / 2\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<^sub>0\n             \\<in>cbox (x, y + \\<delta> / 2)\n                   (x + \\<delta> / 2, y + \\<delta>).\n       \\<forall>p\\<^sub>1\n                \\<in>cbox (x, y + \\<delta> / 2)\n                      (x + \\<delta> / 2, y + \\<delta>).\n          dist p\\<^sub>0 p\\<^sub>1 \\<le> sqrt 2 * (\\<delta> / 2)", "by auto"], ["proof (state)\nthis:\n  \\<forall>p\\<^sub>0\n           \\<in>cbox (x, y + \\<delta> / 2) (x + \\<delta> / 2, y + \\<delta>).\n     \\<forall>p\\<^sub>1\n              \\<in>cbox (x, y + \\<delta> / 2)\n                    (x + \\<delta> / 2, y + \\<delta>).\n        dist p\\<^sub>0 p\\<^sub>1 \\<le> sqrt 2 * (\\<delta> / 2)\n\ngoal (1 subgoal):\n 1. \\<not> card ps \\<le> 4 \\<Longrightarrow> False", "have RL: \"\\<forall>p\\<^sub>0 \\<in> ?rl. \\<forall>p\\<^sub>1 \\<in> ?rl. dist p\\<^sub>0 p\\<^sub>1 \\<le> sqrt 2 * (\\<delta> / 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<^sub>0\n             \\<in>cbox (x + \\<delta> / 2, y)\n                   (x + \\<delta>, y + \\<delta> / 2).\n       \\<forall>p\\<^sub>1\n                \\<in>cbox (x + \\<delta> / 2, y)\n                      (x + \\<delta>, y + \\<delta> / 2).\n          dist p\\<^sub>0 p\\<^sub>1 \\<le> sqrt 2 * (\\<delta> / 2)", "using cbox_max_dist[of \"(?x', y)\" ?x' y \"(x + \\<delta>, ?y')\" \"\\<delta> / 2\"] D"], ["proof (prove)\nusing this:\n  \\<lbrakk>(x + \\<delta> / 2, y) = (x + \\<delta> / 2, y);\n   (x + \\<delta>, y + \\<delta> / 2) =\n   (x + \\<delta> / 2 + \\<delta> / 2, y + \\<delta> / 2);\n   (?x\\<^sub>0, ?y\\<^sub>0)\n   \\<in> cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta> / 2);\n   (?x\\<^sub>1, ?y\\<^sub>1)\n   \\<in> cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta> / 2);\n   0 \\<le> \\<delta> / 2\\<rbrakk>\n  \\<Longrightarrow> dist (?x\\<^sub>0, ?y\\<^sub>0) (?x\\<^sub>1, ?y\\<^sub>1)\n                    \\<le> sqrt 2 * (\\<delta> / 2)\n  0 \\<le> \\<delta> / 2\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<^sub>0\n             \\<in>cbox (x + \\<delta> / 2, y)\n                   (x + \\<delta>, y + \\<delta> / 2).\n       \\<forall>p\\<^sub>1\n                \\<in>cbox (x + \\<delta> / 2, y)\n                      (x + \\<delta>, y + \\<delta> / 2).\n          dist p\\<^sub>0 p\\<^sub>1 \\<le> sqrt 2 * (\\<delta> / 2)", "by auto"], ["proof (state)\nthis:\n  \\<forall>p\\<^sub>0\n           \\<in>cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta> / 2).\n     \\<forall>p\\<^sub>1\n              \\<in>cbox (x + \\<delta> / 2, y)\n                    (x + \\<delta>, y + \\<delta> / 2).\n        dist p\\<^sub>0 p\\<^sub>1 \\<le> sqrt 2 * (\\<delta> / 2)\n\ngoal (1 subgoal):\n 1. \\<not> card ps \\<le> 4 \\<Longrightarrow> False", "have RU: \"\\<forall>p\\<^sub>0 \\<in> ?ru. \\<forall>p\\<^sub>1 \\<in> ?ru. dist p\\<^sub>0 p\\<^sub>1 \\<le> sqrt 2 * (\\<delta> / 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<^sub>0\n             \\<in>cbox (x + \\<delta> / 2, y + \\<delta> / 2)\n                   (x + \\<delta>, y + \\<delta>).\n       \\<forall>p\\<^sub>1\n                \\<in>cbox (x + \\<delta> / 2, y + \\<delta> / 2)\n                      (x + \\<delta>, y + \\<delta>).\n          dist p\\<^sub>0 p\\<^sub>1 \\<le> sqrt 2 * (\\<delta> / 2)", "using cbox_max_dist[of \"(?x', ?y')\" ?x' ?y' \"(x + \\<delta>, y + \\<delta>)\" \"\\<delta> / 2\"] D"], ["proof (prove)\nusing this:\n  \\<lbrakk>(x + \\<delta> / 2, y + \\<delta> / 2) =\n           (x + \\<delta> / 2, y + \\<delta> / 2);\n   (x + \\<delta>, y + \\<delta>) =\n   (x + \\<delta> / 2 + \\<delta> / 2, y + \\<delta> / 2 + \\<delta> / 2);\n   (?x\\<^sub>0, ?y\\<^sub>0)\n   \\<in> cbox (x + \\<delta> / 2, y + \\<delta> / 2)\n          (x + \\<delta>, y + \\<delta>);\n   (?x\\<^sub>1, ?y\\<^sub>1)\n   \\<in> cbox (x + \\<delta> / 2, y + \\<delta> / 2)\n          (x + \\<delta>, y + \\<delta>);\n   0 \\<le> \\<delta> / 2\\<rbrakk>\n  \\<Longrightarrow> dist (?x\\<^sub>0, ?y\\<^sub>0) (?x\\<^sub>1, ?y\\<^sub>1)\n                    \\<le> sqrt 2 * (\\<delta> / 2)\n  0 \\<le> \\<delta> / 2\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<^sub>0\n             \\<in>cbox (x + \\<delta> / 2, y + \\<delta> / 2)\n                   (x + \\<delta>, y + \\<delta>).\n       \\<forall>p\\<^sub>1\n                \\<in>cbox (x + \\<delta> / 2, y + \\<delta> / 2)\n                      (x + \\<delta>, y + \\<delta>).\n          dist p\\<^sub>0 p\\<^sub>1 \\<le> sqrt 2 * (\\<delta> / 2)", "by auto"], ["proof (state)\nthis:\n  \\<forall>p\\<^sub>0\n           \\<in>cbox (x + \\<delta> / 2, y + \\<delta> / 2)\n                 (x + \\<delta>, y + \\<delta>).\n     \\<forall>p\\<^sub>1\n              \\<in>cbox (x + \\<delta> / 2, y + \\<delta> / 2)\n                    (x + \\<delta>, y + \\<delta>).\n        dist p\\<^sub>0 p\\<^sub>1 \\<le> sqrt 2 * (\\<delta> / 2)\n\ngoal (1 subgoal):\n 1. \\<not> card ps \\<le> 4 \\<Longrightarrow> False", "have \"\\<forall>p\\<^sub>0 \\<in> S. \\<forall>p\\<^sub>1 \\<in> S. dist p\\<^sub>0 p\\<^sub>1 \\<le> sqrt 2 * (\\<delta> / 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<^sub>0\\<in>S.\n       \\<forall>p\\<^sub>1\\<in>S.\n          dist p\\<^sub>0 p\\<^sub>1 \\<le> sqrt 2 * (\\<delta> / 2)", "using # LL LU RL RU"], ["proof (prove)\nusing this:\n  p\\<^sub>0 \\<in> PS\n  p\\<^sub>1 \\<in> PS\n  S \\<in> {cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2),\n           cbox (x, y + \\<delta> / 2) (x + \\<delta> / 2, y + \\<delta>),\n           cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta> / 2),\n           cbox (x + \\<delta> / 2, y + \\<delta> / 2)\n            (x + \\<delta>, y + \\<delta>)}\n  p\\<^sub>0 \\<noteq> p\\<^sub>1\n  p\\<^sub>0 \\<in> S\n  p\\<^sub>1 \\<in> S\n  \\<forall>p\\<^sub>0\\<in>cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2).\n     \\<forall>p\\<^sub>1\n              \\<in>cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2).\n        dist p\\<^sub>0 p\\<^sub>1 \\<le> sqrt 2 * (\\<delta> / 2)\n  \\<forall>p\\<^sub>0\n           \\<in>cbox (x, y + \\<delta> / 2) (x + \\<delta> / 2, y + \\<delta>).\n     \\<forall>p\\<^sub>1\n              \\<in>cbox (x, y + \\<delta> / 2)\n                    (x + \\<delta> / 2, y + \\<delta>).\n        dist p\\<^sub>0 p\\<^sub>1 \\<le> sqrt 2 * (\\<delta> / 2)\n  \\<forall>p\\<^sub>0\n           \\<in>cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta> / 2).\n     \\<forall>p\\<^sub>1\n              \\<in>cbox (x + \\<delta> / 2, y)\n                    (x + \\<delta>, y + \\<delta> / 2).\n        dist p\\<^sub>0 p\\<^sub>1 \\<le> sqrt 2 * (\\<delta> / 2)\n  \\<forall>p\\<^sub>0\n           \\<in>cbox (x + \\<delta> / 2, y + \\<delta> / 2)\n                 (x + \\<delta>, y + \\<delta>).\n     \\<forall>p\\<^sub>1\n              \\<in>cbox (x + \\<delta> / 2, y + \\<delta> / 2)\n                    (x + \\<delta>, y + \\<delta>).\n        dist p\\<^sub>0 p\\<^sub>1 \\<le> sqrt 2 * (\\<delta> / 2)\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<^sub>0\\<in>S.\n       \\<forall>p\\<^sub>1\\<in>S.\n          dist p\\<^sub>0 p\\<^sub>1 \\<le> sqrt 2 * (\\<delta> / 2)", "by blast"], ["proof (state)\nthis:\n  \\<forall>p\\<^sub>0\\<in>S.\n     \\<forall>p\\<^sub>1\\<in>S.\n        dist p\\<^sub>0 p\\<^sub>1 \\<le> sqrt 2 * (\\<delta> / 2)\n\ngoal (1 subgoal):\n 1. \\<not> card ps \\<le> 4 \\<Longrightarrow> False", "hence \"dist p\\<^sub>0 p\\<^sub>1 \\<le> (sqrt 2 / 2) * \\<delta>\""], ["proof (prove)\nusing this:\n  \\<forall>p\\<^sub>0\\<in>S.\n     \\<forall>p\\<^sub>1\\<in>S.\n        dist p\\<^sub>0 p\\<^sub>1 \\<le> sqrt 2 * (\\<delta> / 2)\n\ngoal (1 subgoal):\n 1. dist p\\<^sub>0 p\\<^sub>1 \\<le> sqrt 2 / 2 * \\<delta>", "using #"], ["proof (prove)\nusing this:\n  \\<forall>p\\<^sub>0\\<in>S.\n     \\<forall>p\\<^sub>1\\<in>S.\n        dist p\\<^sub>0 p\\<^sub>1 \\<le> sqrt 2 * (\\<delta> / 2)\n  p\\<^sub>0 \\<in> PS\n  p\\<^sub>1 \\<in> PS\n  S \\<in> {cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2),\n           cbox (x, y + \\<delta> / 2) (x + \\<delta> / 2, y + \\<delta>),\n           cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta> / 2),\n           cbox (x + \\<delta> / 2, y + \\<delta> / 2)\n            (x + \\<delta>, y + \\<delta>)}\n  p\\<^sub>0 \\<noteq> p\\<^sub>1\n  p\\<^sub>0 \\<in> S\n  p\\<^sub>1 \\<in> S\n\ngoal (1 subgoal):\n 1. dist p\\<^sub>0 p\\<^sub>1 \\<le> sqrt 2 / 2 * \\<delta>", "by simp"], ["proof (state)\nthis:\n  dist p\\<^sub>0 p\\<^sub>1 \\<le> sqrt 2 / 2 * \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> card ps \\<le> 4 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  dist p\\<^sub>0 p\\<^sub>1 \\<le> sqrt 2 / 2 * \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> card ps \\<le> 4 \\<Longrightarrow> False", "have \"(sqrt 2 / 2) * \\<delta> < \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt 2 / 2 * \\<delta> < \\<delta>", "using sqrt2_less_2 \\<delta>"], ["proof (prove)\nusing this:\n  sqrt 2 < 2\n  0 < \\<delta>\n\ngoal (1 subgoal):\n 1. sqrt 2 / 2 * \\<delta> < \\<delta>", "by simp"], ["proof (state)\nthis:\n  sqrt 2 / 2 * \\<delta> < \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> card ps \\<le> 4 \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  dist p\\<^sub>0 p\\<^sub>1 \\<le> sqrt 2 / 2 * \\<delta>\n  sqrt 2 / 2 * \\<delta> < \\<delta>", "have \"dist p\\<^sub>0 p\\<^sub>1 < \\<delta>\""], ["proof (prove)\nusing this:\n  dist p\\<^sub>0 p\\<^sub>1 \\<le> sqrt 2 / 2 * \\<delta>\n  sqrt 2 / 2 * \\<delta> < \\<delta>\n\ngoal (1 subgoal):\n 1. dist p\\<^sub>0 p\\<^sub>1 < \\<delta>", "by simp"], ["proof (state)\nthis:\n  dist p\\<^sub>0 p\\<^sub>1 < \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> card ps \\<le> 4 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  dist p\\<^sub>0 p\\<^sub>1 < \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> card ps \\<le> 4 \\<Longrightarrow> False", "have \"\\<delta> \\<le> dist p\\<^sub>0 p\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> \\<le> dist p\\<^sub>0 p\\<^sub>1", "using assms(2) # sparse_def PS_def"], ["proof (prove)\nusing this:\n  sparse \\<delta> ps\n  p\\<^sub>0 \\<in> PS\n  p\\<^sub>1 \\<in> PS\n  S \\<in> {cbox (x, y) (x + \\<delta> / 2, y + \\<delta> / 2),\n           cbox (x, y + \\<delta> / 2) (x + \\<delta> / 2, y + \\<delta>),\n           cbox (x + \\<delta> / 2, y) (x + \\<delta>, y + \\<delta> / 2),\n           cbox (x + \\<delta> / 2, y + \\<delta> / 2)\n            (x + \\<delta>, y + \\<delta>)}\n  p\\<^sub>0 \\<noteq> p\\<^sub>1\n  p\\<^sub>0 \\<in> S\n  p\\<^sub>1 \\<in> S\n  sparse ?\\<delta> ?ps =\n  (\\<forall>p\\<^sub>0\\<in>?ps.\n      \\<forall>p\\<^sub>1\\<in>?ps.\n         p\\<^sub>0 \\<noteq> p\\<^sub>1 \\<longrightarrow>\n         ?\\<delta>\n         \\<le> dist\n                (case p\\<^sub>0 of\n                 (x, y) \\<Rightarrow> (real_of_int x, real_of_int y))\n                (case p\\<^sub>1 of\n                 (x, y) \\<Rightarrow> (real_of_int x, real_of_int y)))\n  PS = (\\<lambda>(x, y). (real_of_int x, real_of_int y)) ` ps\n\ngoal (1 subgoal):\n 1. \\<delta> \\<le> dist p\\<^sub>0 p\\<^sub>1", "by auto"], ["proof (state)\nthis:\n  \\<delta> \\<le> dist p\\<^sub>0 p\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<not> card ps \\<le> 4 \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  dist p\\<^sub>0 p\\<^sub>1 < \\<delta>\n  \\<delta> \\<le> dist p\\<^sub>0 p\\<^sub>1", "show False"], ["proof (prove)\nusing this:\n  dist p\\<^sub>0 p\\<^sub>1 < \\<delta>\n  \\<delta> \\<le> dist p\\<^sub>0 p\\<^sub>1\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card ps \\<le> 4\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}