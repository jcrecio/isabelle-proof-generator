{"file_name": "/home/qj213/afp-2021-10-22/thys/Ribbon_Proofs/Ribbons_Interfaces.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Ribbon_Proofs", "problem_names": ["lemma equiv_int_cong_hcomp: \n  \"\\<lbrakk> P \\<simeq> Q ; P' \\<simeq> Q' \\<rbrakk> \\<Longrightarrow> P \\<otimes>\\<^sub>c P' \\<simeq> Q \\<otimes>\\<^sub>c Q'\"", "lemma hcomp_comm: \n  \"(P \\<otimes> Q) = (Q \\<otimes> P)\"", "lemma hcomp_assoc:\n  \"(P \\<otimes> (Q \\<otimes> R)) = ((P \\<otimes> Q) \\<otimes> R)\"", "lemma emp_hcomp:\n  \"\\<epsilon> \\<otimes> P = P\"", "lemma hcomp_emp:\n  \"P \\<otimes> \\<epsilon> = P\"", "lemma comp_fun_commute_hcomp:\n  \"comp_fun_commute (\\<otimes>)\"", "lemma iter_hcomp_cong:\n  assumes \"\\<forall>v \\<in> fset vs. \\<phi> v = \\<phi>' v\"\n  shows \"(\\<Otimes>v|\\<in>|vs. \\<phi> v) = (\\<Otimes>v|\\<in>|vs. \\<phi>' v)\"", "lemma iter_hcomp_empty:\n  shows \"(\\<Otimes>x |\\<in>| {||}. p x) = \\<epsilon>\"", "lemma iter_hcomp_insert:\n  assumes \"v |\\<notin>| ws\"\n  shows \"(\\<Otimes>x |\\<in>| finsert v ws. p x) = (p v \\<otimes> (\\<Otimes>x |\\<in>| ws. p x))\"", "lemma iter_hcomp_union:\n  assumes \"vs |\\<inter>| ws = {||}\"\n  shows \"(\\<Otimes>x |\\<in>| vs |\\<union>| ws. p x) = ((\\<Otimes>x |\\<in>| vs. p x) \\<otimes> (\\<Otimes>x |\\<in>| ws. p x))\"", "lemma asn_simps [simp]:\n  \"asn (Ribbon p) = p\"\n  \"asn (P \\<otimes> Q) = (asn P) \\<star> (asn Q)\"\n  \"asn \\<epsilon> = Emp\"\n  \"asn (Exists_int x P) = Exists x (asn P)\"", "lemma rd_int_is_rd_ass:\n  \"rd_ass (asn P) = rd_int P\"", "lemma seq_fold: \n  \"\\<And>\\<Pi>. \\<lbrakk> length cs = chainlen \\<Pi> ; p1 = asn (pre \\<Pi>) ; p2 = asn (post \\<Pi>) ; \n  \\<And>i. i < chainlen \\<Pi> \\<Longrightarrow> prov_triple \n  (asn (fst3 (nthtriple \\<Pi> i)), cs ! i, asn (thd3 (nthtriple \\<Pi> i))) \\<rbrakk>\n  \\<Longrightarrow> prov_triple (p1, foldr (;;) cs Skip, p2)\""], "translations": [["", "lemma equiv_int_cong_hcomp: \n  \"\\<lbrakk> P \\<simeq> Q ; P' \\<simeq> Q' \\<rbrakk> \\<Longrightarrow> P \\<otimes>\\<^sub>c P' \\<simeq> Q \\<otimes>\\<^sub>c Q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<simeq> Q; P' \\<simeq> Q'\\<rbrakk>\n    \\<Longrightarrow> P \\<otimes>\\<^sub>c P' \\<simeq> Q \\<otimes>\\<^sub>c Q'", "by (metis cong_hcomp1 cong_hcomp2 equiv_int.trans)"], ["", "quotient_type interface = \"conc_interface\" / \"equiv_int\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equivp (\\<simeq>)", "apply (intro equivpI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. reflp (\\<simeq>)\n 2. symp (\\<simeq>)\n 3. transp (\\<simeq>)", "apply (intro reflpI, simp add: equiv_int.refl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. symp (\\<simeq>)\n 2. transp (\\<simeq>)", "apply (intro sympI, simp add: equiv_int.sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. transp (\\<simeq>)", "apply (intro transpI, elim equiv_int.trans, simp add: equiv_int.refl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lift_definition \n  Ribbon :: \"assertion \\<Rightarrow> interface\" \nis \"Ribbon_conc\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition\n  Emp_int :: \"interface\" (\"\\<epsilon>\")\nis \"\\<epsilon>\\<^sub>c\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition\n  Exists_int :: \"string \\<Rightarrow> interface \\<Rightarrow> interface\"\nis \"Exists_int_conc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list conc_interface1 conc_interface2.\n       conc_interface1 \\<simeq> conc_interface2 \\<Longrightarrow>\n       Exists_int_conc list conc_interface1 \\<simeq>\n       Exists_int_conc list conc_interface2", "by (rule equiv_int.cong_exists)"], ["", "lift_definition\n  HComp_int :: \"interface \\<Rightarrow> interface \\<Rightarrow> interface\" (infix \"\\<otimes>\" 50)\nis \"HComp_int_conc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conc_interface1 conc_interface2 conc_interface3 conc_interface4.\n       \\<lbrakk>conc_interface1 \\<simeq> conc_interface2;\n        conc_interface3 \\<simeq> conc_interface4\\<rbrakk>\n       \\<Longrightarrow> conc_interface1 \\<otimes>\\<^sub>c\n                         conc_interface3 \\<simeq>\n                         conc_interface2 \\<otimes>\\<^sub>c conc_interface4", "by (rule equiv_int_cong_hcomp)"], ["", "lemma hcomp_comm: \n  \"(P \\<otimes> Q) = (Q \\<otimes> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<otimes> Q) = (Q \\<otimes> P)", "by (rule hcomp_conc_comm[Transfer.transferred])"], ["", "lemma hcomp_assoc:\n  \"(P \\<otimes> (Q \\<otimes> R)) = ((P \\<otimes> Q) \\<otimes> R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<otimes> (Q \\<otimes> R)) = ((P \\<otimes> Q) \\<otimes> R)", "by (rule hcomp_conc_assoc[Transfer.transferred])"], ["", "lemma emp_hcomp:\n  \"\\<epsilon> \\<otimes> P = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<epsilon> \\<otimes> P) = P", "by (rule hcomp_conc_unit1[Transfer.transferred])"], ["", "lemma hcomp_emp:\n  \"P \\<otimes> \\<epsilon> = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<otimes> \\<epsilon>) = P", "by (rule hcomp_conc_unit2[Transfer.transferred])"], ["", "lemma comp_fun_commute_hcomp:\n  \"comp_fun_commute (\\<otimes>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_commute (\\<otimes>)", "by standard (simp add: hcomp_assoc fun_eq_iff, metis hcomp_comm)"], ["", "subsection \\<open>An iterated horizontal-composition operator\\<close>"], ["", "definition iter_hcomp :: \"('a fset) \\<Rightarrow> ('a \\<Rightarrow> interface) \\<Rightarrow> interface\"\nwhere\n  \"iter_hcomp X f \\<equiv> ffold ((\\<otimes>) \\<circ> f) \\<epsilon> X\""], ["", "syntax \"iter_hcomp_syntax\" :: \n  \"'a \\<Rightarrow> ('a fset) \\<Rightarrow> ('a \\<Rightarrow> interface) \\<Rightarrow> interface\"\n      (\"(\\<Otimes>_|\\<in>|_. _)\" [0,0,10] 10)"], ["", "translations \"\\<Otimes>x|\\<in>|M. e\" == \"CONST iter_hcomp M (\\<lambda>x. e)\""], ["", "term \"\\<Otimes>P|\\<in>|Ps. f P\" \\<comment> \\<open>this is eta-expanded, so prints in expanded form\\<close>"], ["", "term \"\\<Otimes>P|\\<in>|Ps. f\" \\<comment> \\<open>this isn't eta-expanded, so prints as written\\<close>"], ["", "lemma iter_hcomp_cong:\n  assumes \"\\<forall>v \\<in> fset vs. \\<phi> v = \\<phi>' v\"\n  shows \"(\\<Otimes>v|\\<in>|vs. \\<phi> v) = (\\<Otimes>v|\\<in>|vs. \\<phi>' v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iter_hcomp vs \\<phi> = iter_hcomp vs \\<phi>'", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>fset vs. \\<phi> v = \\<phi>' v\n\ngoal (1 subgoal):\n 1. iter_hcomp vs \\<phi> = iter_hcomp vs \\<phi>'", "unfolding iter_hcomp_def"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>fset vs. \\<phi> v = \\<phi>' v\n\ngoal (1 subgoal):\n 1. ffold ((\\<otimes>) \\<circ> \\<phi>) \\<epsilon> vs =\n    ffold ((\\<otimes>) \\<circ> \\<phi>') \\<epsilon> vs", "by (auto simp add: fmember.rep_eq comp_fun_commute.comp_comp_fun_commute comp_fun_commute_hcomp \n  intro: ffold_cong)"], ["", "lemma iter_hcomp_empty:\n  shows \"(\\<Otimes>x |\\<in>| {||}. p x) = \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iter_hcomp {||} p = \\<epsilon>", "by (metis comp_fun_commute.ffold_empty comp_fun_commute_hcomp iter_hcomp_def)"], ["", "lemma iter_hcomp_insert:\n  assumes \"v |\\<notin>| ws\"\n  shows \"(\\<Otimes>x |\\<in>| finsert v ws. p x) = (p v \\<otimes> (\\<Otimes>x |\\<in>| ws. p x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iter_hcomp (finsert v ws) p = (p v \\<otimes> iter_hcomp ws p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. iter_hcomp (finsert v ws) p = (p v \\<otimes> iter_hcomp ws p)", "interpret comp_fun_commute \"((\\<otimes>) \\<circ> p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_commute ((\\<otimes>) \\<circ> p)", "by (metis comp_fun_commute.comp_comp_fun_commute comp_fun_commute_hcomp)"], ["proof (state)\ngoal (1 subgoal):\n 1. iter_hcomp (finsert v ws) p = (p v \\<otimes> iter_hcomp ws p)", "from assms"], ["proof (chain)\npicking this:\n  v |\\<notin>| ws", "show ?thesis"], ["proof (prove)\nusing this:\n  v |\\<notin>| ws\n\ngoal (1 subgoal):\n 1. iter_hcomp (finsert v ws) p = (p v \\<otimes> iter_hcomp ws p)", "unfolding iter_hcomp_def"], ["proof (prove)\nusing this:\n  v |\\<notin>| ws\n\ngoal (1 subgoal):\n 1. ffold ((\\<otimes>) \\<circ> p) \\<epsilon> (finsert v ws) =\n    (p v \\<otimes> ffold ((\\<otimes>) \\<circ> p) \\<epsilon> ws)", "by auto"], ["proof (state)\nthis:\n  iter_hcomp (finsert v ws) p = (p v \\<otimes> iter_hcomp ws p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma iter_hcomp_union:\n  assumes \"vs |\\<inter>| ws = {||}\"\n  shows \"(\\<Otimes>x |\\<in>| vs |\\<union>| ws. p x) = ((\\<Otimes>x |\\<in>| vs. p x) \\<otimes> (\\<Otimes>x |\\<in>| ws. p x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iter_hcomp (vs |\\<union>| ws) p =\n    (iter_hcomp vs p \\<otimes> iter_hcomp ws p)", "using assms"], ["proof (prove)\nusing this:\n  vs |\\<inter>| ws = {||}\n\ngoal (1 subgoal):\n 1. iter_hcomp (vs |\\<union>| ws) p =\n    (iter_hcomp vs p \\<otimes> iter_hcomp ws p)", "by (induct vs) (auto simp add: emp_hcomp iter_hcomp_empty iter_hcomp_insert hcomp_assoc)"], ["", "subsection \\<open>Semantics of interfaces\\<close>"], ["", "text \\<open>The semantics of an interface is an assertion.\\<close>"], ["", "fun\n  conc_asn :: \"conc_interface \\<Rightarrow> assertion\"\nwhere\n  \"conc_asn (Ribbon_conc p) = p\"\n| \"conc_asn (P \\<otimes>\\<^sub>c Q) = (conc_asn P) \\<star> (conc_asn Q)\"\n| \"conc_asn (\\<epsilon>\\<^sub>c) = Emp\"\n| \"conc_asn (Exists_int_conc x P) = Exists x (conc_asn P)\""], ["", "lift_definition \n  asn :: \"interface \\<Rightarrow> assertion\"\nis \"conc_asn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conc_interface1 conc_interface2.\n       conc_interface1 \\<simeq> conc_interface2 \\<Longrightarrow>\n       conc_asn conc_interface1 = conc_asn conc_interface2", "by (induct_tac rule:equiv_int.induct) (auto simp add: star_assoc star_comm star_rot emp_star)"], ["", "lemma asn_simps [simp]:\n  \"asn (Ribbon p) = p\"\n  \"asn (P \\<otimes> Q) = (asn P) \\<star> (asn Q)\"\n  \"asn \\<epsilon> = Emp\"\n  \"asn (Exists_int x P) = Exists x (asn P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (asn (Ribbon p) = p &&& asn (P \\<otimes> Q) = asn P \\<star> asn Q) &&&\n    asn \\<epsilon> = Emp &&& asn (Exists_int x P) = Exists x (asn P)", "by (transfer, simp)+"], ["", "subsection \\<open>Program variables mentioned in an interface.\\<close>"], ["", "fun\n  rd_conc_int :: \"conc_interface \\<Rightarrow> string set\"\nwhere\n  \"rd_conc_int (Ribbon_conc p) = rd_ass p\"\n| \"rd_conc_int (P \\<otimes>\\<^sub>c Q) = rd_conc_int P \\<union> rd_conc_int Q\"\n| \"rd_conc_int (\\<epsilon>\\<^sub>c) = {}\"\n| \"rd_conc_int (Exists_int_conc x P) = rd_conc_int P\""], ["", "lift_definition\n  rd_int :: \"interface \\<Rightarrow> string set\"\nis \"rd_conc_int\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conc_interface1 conc_interface2.\n       conc_interface1 \\<simeq> conc_interface2 \\<Longrightarrow>\n       rd_conc_int conc_interface1 = rd_conc_int conc_interface2", "by (induct_tac rule: equiv_int.induct) auto"], ["", "text \\<open>The program variables read by an interface are the same as those read \n  by its corresponding assertion.\\<close>"], ["", "lemma rd_int_is_rd_ass:\n  \"rd_ass (asn P) = rd_int P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rd_ass (asn P) = rd_int P", "by (transfer, induct_tac P, auto simp add: rd_star rd_exists rd_emp)"], ["", "text \\<open>Here is an iterated version of the Hoare logic sequencing rule.\\<close>"], ["", "lemma seq_fold: \n  \"\\<And>\\<Pi>. \\<lbrakk> length cs = chainlen \\<Pi> ; p1 = asn (pre \\<Pi>) ; p2 = asn (post \\<Pi>) ; \n  \\<And>i. i < chainlen \\<Pi> \\<Longrightarrow> prov_triple \n  (asn (fst3 (nthtriple \\<Pi> i)), cs ! i, asn (thd3 (nthtriple \\<Pi> i))) \\<rbrakk>\n  \\<Longrightarrow> prov_triple (p1, foldr (;;) cs Skip, p2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Pi>.\n       \\<lbrakk>length cs = chainlen \\<Pi>; p1 = asn (pre \\<Pi>);\n        p2 = asn (post \\<Pi>);\n        \\<And>i.\n           i < chainlen \\<Pi> \\<Longrightarrow>\n           prov_triple\n            (asn (fst3 (nthtriple \\<Pi> i)), cs ! i,\n             asn (thd3 (nthtriple \\<Pi> i)))\\<rbrakk>\n       \\<Longrightarrow> prov_triple (p1, foldr (;;) cs Skip, p2)", "proof (induct cs arbitrary: p1 p2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<Pi> p1 p2.\n       \\<lbrakk>length [] = chainlen \\<Pi>; p1 = asn (pre \\<Pi>);\n        p2 = asn (post \\<Pi>);\n        \\<And>i.\n           i < chainlen \\<Pi> \\<Longrightarrow>\n           prov_triple\n            (asn (fst3 (nthtriple \\<Pi> i)), [] ! i,\n             asn (thd3 (nthtriple \\<Pi> i)))\\<rbrakk>\n       \\<Longrightarrow> prov_triple (p1, foldr (;;) [] Skip, p2)\n 2. \\<And>a cs \\<Pi> p1 p2.\n       \\<lbrakk>\\<And>\\<Pi> p1 p2.\n                   \\<lbrakk>length cs = chainlen \\<Pi>;\n                    p1 = asn (pre \\<Pi>); p2 = asn (post \\<Pi>);\n                    \\<And>i.\n                       i < chainlen \\<Pi> \\<Longrightarrow>\n                       prov_triple\n                        (asn (fst3 (nthtriple \\<Pi> i)), cs ! i,\n                         asn (thd3 (nthtriple \\<Pi> i)))\\<rbrakk>\n                   \\<Longrightarrow> prov_triple\n(p1, foldr (;;) cs Skip, p2);\n        length (a # cs) = chainlen \\<Pi>; p1 = asn (pre \\<Pi>);\n        p2 = asn (post \\<Pi>);\n        \\<And>i.\n           i < chainlen \\<Pi> \\<Longrightarrow>\n           prov_triple\n            (asn (fst3 (nthtriple \\<Pi> i)), (a # cs) ! i,\n             asn (thd3 (nthtriple \\<Pi> i)))\\<rbrakk>\n       \\<Longrightarrow> prov_triple (p1, foldr (;;) (a # cs) Skip, p2)", "case Nil"], ["proof (state)\nthis:\n  length [] = chainlen \\<Pi>\n  p1 = asn (pre \\<Pi>)\n  p2 = asn (post \\<Pi>)\n  ?i < chainlen \\<Pi> \\<Longrightarrow>\n  prov_triple\n   (asn (fst3 (nthtriple \\<Pi> ?i)), [] ! ?i,\n    asn (thd3 (nthtriple \\<Pi> ?i)))\n\ngoal (2 subgoals):\n 1. \\<And>\\<Pi> p1 p2.\n       \\<lbrakk>length [] = chainlen \\<Pi>; p1 = asn (pre \\<Pi>);\n        p2 = asn (post \\<Pi>);\n        \\<And>i.\n           i < chainlen \\<Pi> \\<Longrightarrow>\n           prov_triple\n            (asn (fst3 (nthtriple \\<Pi> i)), [] ! i,\n             asn (thd3 (nthtriple \\<Pi> i)))\\<rbrakk>\n       \\<Longrightarrow> prov_triple (p1, foldr (;;) [] Skip, p2)\n 2. \\<And>a cs \\<Pi> p1 p2.\n       \\<lbrakk>\\<And>\\<Pi> p1 p2.\n                   \\<lbrakk>length cs = chainlen \\<Pi>;\n                    p1 = asn (pre \\<Pi>); p2 = asn (post \\<Pi>);\n                    \\<And>i.\n                       i < chainlen \\<Pi> \\<Longrightarrow>\n                       prov_triple\n                        (asn (fst3 (nthtriple \\<Pi> i)), cs ! i,\n                         asn (thd3 (nthtriple \\<Pi> i)))\\<rbrakk>\n                   \\<Longrightarrow> prov_triple\n(p1, foldr (;;) cs Skip, p2);\n        length (a # cs) = chainlen \\<Pi>; p1 = asn (pre \\<Pi>);\n        p2 = asn (post \\<Pi>);\n        \\<And>i.\n           i < chainlen \\<Pi> \\<Longrightarrow>\n           prov_triple\n            (asn (fst3 (nthtriple \\<Pi> i)), (a # cs) ! i,\n             asn (thd3 (nthtriple \\<Pi> i)))\\<rbrakk>\n       \\<Longrightarrow> prov_triple (p1, foldr (;;) (a # cs) Skip, p2)", "thus ?case"], ["proof (prove)\nusing this:\n  length [] = chainlen \\<Pi>\n  p1 = asn (pre \\<Pi>)\n  p2 = asn (post \\<Pi>)\n  ?i < chainlen \\<Pi> \\<Longrightarrow>\n  prov_triple\n   (asn (fst3 (nthtriple \\<Pi> ?i)), [] ! ?i,\n    asn (thd3 (nthtriple \\<Pi> ?i)))\n\ngoal (1 subgoal):\n 1. prov_triple (p1, foldr (;;) [] Skip, p2)", "by (cases \\<Pi>, auto simp add: prov_triple.skip)"], ["proof (state)\nthis:\n  prov_triple (p1, foldr (;;) [] Skip, p2)\n\ngoal (1 subgoal):\n 1. \\<And>a cs \\<Pi> p1 p2.\n       \\<lbrakk>\\<And>\\<Pi> p1 p2.\n                   \\<lbrakk>length cs = chainlen \\<Pi>;\n                    p1 = asn (pre \\<Pi>); p2 = asn (post \\<Pi>);\n                    \\<And>i.\n                       i < chainlen \\<Pi> \\<Longrightarrow>\n                       prov_triple\n                        (asn (fst3 (nthtriple \\<Pi> i)), cs ! i,\n                         asn (thd3 (nthtriple \\<Pi> i)))\\<rbrakk>\n                   \\<Longrightarrow> prov_triple\n(p1, foldr (;;) cs Skip, p2);\n        length (a # cs) = chainlen \\<Pi>; p1 = asn (pre \\<Pi>);\n        p2 = asn (post \\<Pi>);\n        \\<And>i.\n           i < chainlen \\<Pi> \\<Longrightarrow>\n           prov_triple\n            (asn (fst3 (nthtriple \\<Pi> i)), (a # cs) ! i,\n             asn (thd3 (nthtriple \\<Pi> i)))\\<rbrakk>\n       \\<Longrightarrow> prov_triple (p1, foldr (;;) (a # cs) Skip, p2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a cs \\<Pi> p1 p2.\n       \\<lbrakk>\\<And>\\<Pi> p1 p2.\n                   \\<lbrakk>length cs = chainlen \\<Pi>;\n                    p1 = asn (pre \\<Pi>); p2 = asn (post \\<Pi>);\n                    \\<And>i.\n                       i < chainlen \\<Pi> \\<Longrightarrow>\n                       prov_triple\n                        (asn (fst3 (nthtriple \\<Pi> i)), cs ! i,\n                         asn (thd3 (nthtriple \\<Pi> i)))\\<rbrakk>\n                   \\<Longrightarrow> prov_triple\n(p1, foldr (;;) cs Skip, p2);\n        length (a # cs) = chainlen \\<Pi>; p1 = asn (pre \\<Pi>);\n        p2 = asn (post \\<Pi>);\n        \\<And>i.\n           i < chainlen \\<Pi> \\<Longrightarrow>\n           prov_triple\n            (asn (fst3 (nthtriple \\<Pi> i)), (a # cs) ! i,\n             asn (thd3 (nthtriple \\<Pi> i)))\\<rbrakk>\n       \\<Longrightarrow> prov_triple (p1, foldr (;;) (a # cs) Skip, p2)", "case (Cons c cs)"], ["proof (state)\nthis:\n  \\<lbrakk>length cs = chainlen ?\\<Pi>; ?p1.0 = asn (pre ?\\<Pi>);\n   ?p2.0 = asn (post ?\\<Pi>);\n   \\<And>i.\n      i < chainlen ?\\<Pi> \\<Longrightarrow>\n      prov_triple\n       (asn (fst3 (nthtriple ?\\<Pi> i)), cs ! i,\n        asn (thd3 (nthtriple ?\\<Pi> i)))\\<rbrakk>\n  \\<Longrightarrow> prov_triple (?p1.0, foldr (;;) cs Skip, ?p2.0)\n  length (c # cs) = chainlen \\<Pi>\n  p1 = asn (pre \\<Pi>)\n  p2 = asn (post \\<Pi>)\n  ?i < chainlen \\<Pi> \\<Longrightarrow>\n  prov_triple\n   (asn (fst3 (nthtriple \\<Pi> ?i)), (c # cs) ! ?i,\n    asn (thd3 (nthtriple \\<Pi> ?i)))\n\ngoal (1 subgoal):\n 1. \\<And>a cs \\<Pi> p1 p2.\n       \\<lbrakk>\\<And>\\<Pi> p1 p2.\n                   \\<lbrakk>length cs = chainlen \\<Pi>;\n                    p1 = asn (pre \\<Pi>); p2 = asn (post \\<Pi>);\n                    \\<And>i.\n                       i < chainlen \\<Pi> \\<Longrightarrow>\n                       prov_triple\n                        (asn (fst3 (nthtriple \\<Pi> i)), cs ! i,\n                         asn (thd3 (nthtriple \\<Pi> i)))\\<rbrakk>\n                   \\<Longrightarrow> prov_triple\n(p1, foldr (;;) cs Skip, p2);\n        length (a # cs) = chainlen \\<Pi>; p1 = asn (pre \\<Pi>);\n        p2 = asn (post \\<Pi>);\n        \\<And>i.\n           i < chainlen \\<Pi> \\<Longrightarrow>\n           prov_triple\n            (asn (fst3 (nthtriple \\<Pi> i)), (a # cs) ! i,\n             asn (thd3 (nthtriple \\<Pi> i)))\\<rbrakk>\n       \\<Longrightarrow> prov_triple (p1, foldr (;;) (a # cs) Skip, p2)", "obtain p x \\<Pi>' where \\<Pi>_def: \"\\<Pi> = \\<lbrace> p \\<rbrace> \\<cdot> x \\<cdot> \\<Pi>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p x \\<Pi>'.\n        \\<Pi> =\n        \\<lbrace> p \\<rbrace> \\<cdot> x \\<cdot> \\<Pi>' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis Cons.prems(1) chain.exhaust chainlen.simps(1) impossible_Cons le0)"], ["proof (state)\nthis:\n  \\<Pi> = \\<lbrace> p \\<rbrace> \\<cdot> x \\<cdot> \\<Pi>'\n\ngoal (1 subgoal):\n 1. \\<And>a cs \\<Pi> p1 p2.\n       \\<lbrakk>\\<And>\\<Pi> p1 p2.\n                   \\<lbrakk>length cs = chainlen \\<Pi>;\n                    p1 = asn (pre \\<Pi>); p2 = asn (post \\<Pi>);\n                    \\<And>i.\n                       i < chainlen \\<Pi> \\<Longrightarrow>\n                       prov_triple\n                        (asn (fst3 (nthtriple \\<Pi> i)), cs ! i,\n                         asn (thd3 (nthtriple \\<Pi> i)))\\<rbrakk>\n                   \\<Longrightarrow> prov_triple\n(p1, foldr (;;) cs Skip, p2);\n        length (a # cs) = chainlen \\<Pi>; p1 = asn (pre \\<Pi>);\n        p2 = asn (post \\<Pi>);\n        \\<And>i.\n           i < chainlen \\<Pi> \\<Longrightarrow>\n           prov_triple\n            (asn (fst3 (nthtriple \\<Pi> i)), (a # cs) ! i,\n             asn (thd3 (nthtriple \\<Pi> i)))\\<rbrakk>\n       \\<Longrightarrow> prov_triple (p1, foldr (;;) (a # cs) Skip, p2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. prov_triple (p1, foldr (;;) (c # cs) Skip, p2)", "apply (unfold foldr_Cons o_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. prov_triple (p1, c ;; foldr (;;) cs Skip, p2)", "apply (rule prov_triple.seq[where q = \"asn (pre \\<Pi>')\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. prov_triple (p1, c, asn (pre \\<Pi>'))\n 2. prov_triple (asn (pre \\<Pi>'), foldr (;;) cs Skip, p2)", "apply (unfold Cons.prems(2) Cons.prems(3) \\<Pi>_def pre.simps post.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. prov_triple (asn p, c, asn (pre \\<Pi>'))\n 2. prov_triple (asn (pre \\<Pi>'), foldr (;;) cs Skip, asn (post \\<Pi>'))", "apply (subst nth_Cons_0[of c cs, symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. prov_triple (asn p, (c # cs) ! 0, asn (pre \\<Pi>'))\n 2. prov_triple (asn (pre \\<Pi>'), foldr (;;) cs Skip, asn (post \\<Pi>'))", "apply (subst fst3_simp[of p x \"pre \\<Pi>'\", symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. prov_triple\n     (asn (fst3 (p, x, pre \\<Pi>')), (c # cs) ! 0, asn (pre \\<Pi>'))\n 2. prov_triple (asn (pre \\<Pi>'), foldr (;;) cs Skip, asn (post \\<Pi>'))", "apply (subst(2) thd3_simp[of p x \"pre \\<Pi>'\", symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. prov_triple\n     (asn (fst3 (p, x, pre \\<Pi>')), (c # cs) ! 0,\n      asn (thd3 (p, x, pre \\<Pi>')))\n 2. prov_triple (asn (pre \\<Pi>'), foldr (;;) cs Skip, asn (post \\<Pi>'))", "apply (subst(1 2) nthtriple.simps(1)[of p x \"\\<Pi>'\", symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. prov_triple\n     (asn (fst3\n            (nthtriple (\\<lbrace> p \\<rbrace> \\<cdot> x \\<cdot> \\<Pi>') 0)),\n      (c # cs) ! 0,\n      asn (thd3\n            (nthtriple (\\<lbrace> p \\<rbrace> \\<cdot> x \\<cdot> \\<Pi>') 0)))\n 2. prov_triple (asn (pre \\<Pi>'), foldr (;;) cs Skip, asn (post \\<Pi>'))", "apply (fold \\<Pi>_def, intro Cons.prems(4), simp add: \\<Pi>_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. prov_triple (asn (pre \\<Pi>'), foldr (;;) cs Skip, asn (post \\<Pi>'))", "apply (intro Cons.hyps, insert \\<Pi>_def Cons.prems(1), auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < chainlen \\<Pi>';\n        \\<Pi> = \\<lbrace> p \\<rbrace> \\<cdot> x \\<cdot> \\<Pi>';\n        length cs = chainlen \\<Pi>'\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (fst3 (nthtriple \\<Pi>' i)), cs ! i,\n                           asn (thd3 (nthtriple \\<Pi>' i)))", "apply (fold nth_Cons_Suc[of c cs] nthtriple.simps(2)[of p x \"\\<Pi>'\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < chainlen \\<Pi>';\n        \\<Pi> = \\<lbrace> p \\<rbrace> \\<cdot> x \\<cdot> \\<Pi>';\n        length cs = chainlen \\<Pi>'\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (fst3\n                                 (nthtriple\n                                   (\\<lbrace> p \\<rbrace> \\<cdot> x \\<cdot> \\<Pi>')\n                                   (Suc i))),\n                           (c # cs) ! Suc i,\n                           asn (thd3\n                                 (nthtriple\n                                   (\\<lbrace> p \\<rbrace> \\<cdot> x \\<cdot> \\<Pi>')\n                                   (Suc i))))", "apply (fold \\<Pi>_def, intro Cons.prems(4), simp add: \\<Pi>_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  prov_triple (p1, foldr (;;) (c # cs) Skip, p2)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}