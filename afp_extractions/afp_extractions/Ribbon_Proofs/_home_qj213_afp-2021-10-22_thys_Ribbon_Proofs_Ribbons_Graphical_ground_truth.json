{"file_name": "/home/qj213/afp-2021-10-22/thys/Ribbon_Proofs/Ribbons_Graphical.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Ribbon_Proofs", "problem_names": ["lemma linearityD:\n  assumes \"linearity E\"\n  shows \"distinct E\"\n  and \"\\<And>e f. \\<lbrakk> e \\<in> set E ; f \\<in> set E ; e \\<noteq> f \\<rbrakk> \\<Longrightarrow> \n    fst3 e |\\<inter>| fst3 f = {||} \\<and>\n    thd3 e |\\<inter>| thd3 f = {||}\"", "lemma linearityD2:\n  \"linearity E \\<Longrightarrow> (\\<forall>e f. e \\<in> set E \\<and> f \\<in> set E \\<and> e \\<noteq> f \\<longrightarrow> \n    fst3 e |\\<inter>| fst3 f = {||} \\<and>\n    thd3 e |\\<inter>| thd3 f = {||})\"", "lemma wf_dia_inv:  \n  assumes \"wf_dia (Graph V \\<Lambda> E)\"\n  shows \"\\<forall>v \\<in> fset V. wf_ass (\\<Lambda> v)\" \n    and \"\\<forall>e \\<in> set E. wf_com (snd3 e)\" \n    and \"acyclicity E\" \n    and \"linearity E\" \n    and \"\\<forall>e \\<in> set E. fst3 e |\\<union>| thd3 e |\\<subseteq>| V\"", "lemma no_edges_imp_all_nodes_initial:\n  \"initials (Graph V \\<Lambda> []) = V\"", "lemma no_edges_imp_all_nodes_terminal:\n  \"terminals (Graph V \\<Lambda> []) = V\"", "lemma initials_in_vertices:\n   \"initials G |\\<subseteq>| G^V\"", "lemma terminals_in_vertices:\n   \"terminals G |\\<subseteq>| G^V\"", "lemma linsD:\n  assumes \"\\<pi> \\<in> lins G\"\n  shows \"(distinct \\<pi>)\" \n    and \"(set \\<pi> = (fset G^V) <+> (set G^E))\" \n    and \"(\\<forall>i j v e. i < length \\<pi> \\<and> j < length \\<pi> \n     \\<and> \\<pi>!i = Inl v \\<and> \\<pi>!j = Inr e \\<and> v |\\<in>| fst3 e \\<longrightarrow> i<j)\"\n    and \"(\\<forall>j k w e. j < length \\<pi> \\<and> k < length \\<pi> \n     \\<and> \\<pi>!j = Inr e \\<and> \\<pi>!k = Inl w \\<and> w |\\<in>| thd3 e \\<longrightarrow> j<k)\"", "lemma coms_mono_helper:\n  \"(\\<forall>i<length \\<pi>. case_sum (coms_ass \\<circ> \\<Lambda>) (coms_com \\<circ> snd3) (\\<pi>!i) (cs!i)) \n  = \n  ((\\<forall>i. i<length \\<pi> \\<and> (\\<exists>v. (\\<pi>!i) = Inl v) \\<longrightarrow> \n    coms_ass (\\<Lambda> (projl (\\<pi>!i))) (cs!i)) \\<and>\n  (\\<forall>i. i<length \\<pi> \\<and> (\\<exists>e. (\\<pi>!i) = Inr e) \\<longrightarrow> \n    coms_com (snd3 (projr (\\<pi>!i))) (cs!i)))\""], "translations": [["", "lemma linearityD:\n  assumes \"linearity E\"\n  shows \"distinct E\"\n  and \"\\<And>e f. \\<lbrakk> e \\<in> set E ; f \\<in> set E ; e \\<noteq> f \\<rbrakk> \\<Longrightarrow> \n    fst3 e |\\<inter>| fst3 f = {||} \\<and>\n    thd3 e |\\<inter>| thd3 f = {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct E &&&\n    (\\<And>e f.\n        \\<lbrakk>e \\<in> set E; f \\<in> set E; e \\<noteq> f\\<rbrakk>\n        \\<Longrightarrow> fst3 e |\\<inter>| fst3 f = {||} \\<and>\n                          thd3 e |\\<inter>| thd3 f = {||})", "using assms"], ["proof (prove)\nusing this:\n  linearity E\n\ngoal (1 subgoal):\n 1. distinct E &&&\n    (\\<And>e f.\n        \\<lbrakk>e \\<in> set E; f \\<in> set E; e \\<noteq> f\\<rbrakk>\n        \\<Longrightarrow> fst3 e |\\<inter>| fst3 f = {||} \\<and>\n                          thd3 e |\\<inter>| thd3 f = {||})", "unfolding linearity_def"], ["proof (prove)\nusing this:\n  distinct E \\<and>\n  (\\<forall>e\\<in>set E.\n      \\<forall>f\\<in>set E.\n         e \\<noteq> f \\<longrightarrow>\n         fst3 e |\\<inter>| fst3 f = {||} \\<and>\n         thd3 e |\\<inter>| thd3 f = {||})\n\ngoal (1 subgoal):\n 1. distinct E &&&\n    (\\<And>e f.\n        \\<lbrakk>e \\<in> set E; f \\<in> set E; e \\<noteq> f\\<rbrakk>\n        \\<Longrightarrow> fst3 e |\\<inter>| fst3 f = {||} \\<and>\n                          thd3 e |\\<inter>| thd3 f = {||})", "by auto"], ["", "lemma linearityD2:\n  \"linearity E \\<Longrightarrow> (\\<forall>e f. e \\<in> set E \\<and> f \\<in> set E \\<and> e \\<noteq> f \\<longrightarrow> \n    fst3 e |\\<inter>| fst3 f = {||} \\<and>\n    thd3 e |\\<inter>| thd3 f = {||})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linearity E \\<Longrightarrow>\n    \\<forall>e f.\n       e \\<in> set E \\<and>\n       f \\<in> set E \\<and> e \\<noteq> f \\<longrightarrow>\n       fst3 e |\\<inter>| fst3 f = {||} \\<and>\n       thd3 e |\\<inter>| thd3 f = {||}", "unfolding linearity_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct E \\<and>\n    (\\<forall>e\\<in>set E.\n        \\<forall>f\\<in>set E.\n           e \\<noteq> f \\<longrightarrow>\n           fst3 e |\\<inter>| fst3 f = {||} \\<and>\n           thd3 e |\\<inter>| thd3 f = {||}) \\<Longrightarrow>\n    \\<forall>e f.\n       e \\<in> set E \\<and>\n       f \\<in> set E \\<and> e \\<noteq> f \\<longrightarrow>\n       fst3 e |\\<inter>| fst3 f = {||} \\<and>\n       thd3 e |\\<inter>| thd3 f = {||}", "by auto"], ["", "inductive\n  wf_ass :: \"assertion_gadget \\<Rightarrow> bool\" and\n  wf_com :: \"command_gadget \\<Rightarrow> bool\" and\n  wf_dia :: \"diagram \\<Rightarrow> bool\"\nwhere\n  wf_rib: \"wf_ass (Rib p)\" \n| wf_exists: \"wf_dia G \\<Longrightarrow> wf_ass (Exists_dia x G)\"\n| wf_com: \"wf_com (Com c)\"\n| wf_choice: \"\\<lbrakk> wf_dia G ; wf_dia H \\<rbrakk> \\<Longrightarrow> wf_com (Choose_dia G H)\"\n| wf_loop: \"wf_dia G \\<Longrightarrow> wf_com (Loop_dia G)\"\n| wf_dia: \"\\<lbrakk> \\<forall>e \\<in> set E. wf_com (snd3 e) ; \\<forall>v \\<in> fset V. wf_ass (\\<Lambda> v) ;\n  acyclicity E ; linearity E ; \\<forall>e \\<in> set E. fst3 e |\\<union>| thd3 e |\\<subseteq>| V \\<rbrakk> \\<Longrightarrow> \n  wf_dia (Graph V \\<Lambda> E)\""], ["", "inductive_cases wf_dia_inv': \"wf_dia (Graph V \\<Lambda> E)\""], ["", "lemma wf_dia_inv:  \n  assumes \"wf_dia (Graph V \\<Lambda> E)\"\n  shows \"\\<forall>v \\<in> fset V. wf_ass (\\<Lambda> v)\" \n    and \"\\<forall>e \\<in> set E. wf_com (snd3 e)\" \n    and \"acyclicity E\" \n    and \"linearity E\" \n    and \"\\<forall>e \\<in> set E. fst3 e |\\<union>| thd3 e |\\<subseteq>| V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>v\\<in>fset V. wf_ass (\\<Lambda> v) &&&\n     \\<forall>e\\<in>set E. wf_com (snd3 e)) &&&\n    acyclicity E &&&\n    linearity E &&&\n    \\<forall>e\\<in>set E. fst3 e |\\<union>| thd3 e |\\<subseteq>| V", "using assms"], ["proof (prove)\nusing this:\n  wf_dia (Graph V \\<Lambda> E)\n\ngoal (1 subgoal):\n 1. (\\<forall>v\\<in>fset V. wf_ass (\\<Lambda> v) &&&\n     \\<forall>e\\<in>set E. wf_com (snd3 e)) &&&\n    acyclicity E &&&\n    linearity E &&&\n    \\<forall>e\\<in>set E. fst3 e |\\<union>| thd3 e |\\<subseteq>| V", "apply -"], ["proof (prove)\ngoal (5 subgoals):\n 1. wf_dia (Graph V \\<Lambda> E) \\<Longrightarrow>\n    \\<forall>v\\<in>fset V. wf_ass (\\<Lambda> v)\n 2. wf_dia (Graph V \\<Lambda> E) \\<Longrightarrow>\n    \\<forall>e\\<in>set E. wf_com (snd3 e)\n 3. wf_dia (Graph V \\<Lambda> E) \\<Longrightarrow> acyclicity E\n 4. wf_dia (Graph V \\<Lambda> E) \\<Longrightarrow> linearity E\n 5. wf_dia (Graph V \\<Lambda> E) \\<Longrightarrow>\n    \\<forall>e\\<in>set E. fst3 e |\\<union>| thd3 e |\\<subseteq>| V", "(* This acts as an intro rule for &&& *)"], ["proof (prove)\ngoal (5 subgoals):\n 1. wf_dia (Graph V \\<Lambda> E) \\<Longrightarrow>\n    \\<forall>v\\<in>fset V. wf_ass (\\<Lambda> v)\n 2. wf_dia (Graph V \\<Lambda> E) \\<Longrightarrow>\n    \\<forall>e\\<in>set E. wf_com (snd3 e)\n 3. wf_dia (Graph V \\<Lambda> E) \\<Longrightarrow> acyclicity E\n 4. wf_dia (Graph V \\<Lambda> E) \\<Longrightarrow> linearity E\n 5. wf_dia (Graph V \\<Lambda> E) \\<Longrightarrow>\n    \\<forall>e\\<in>set E. fst3 e |\\<union>| thd3 e |\\<subseteq>| V", "apply (elim wf_dia_inv', simp)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Initial and terminal nodes\\<close>"], ["", "definition\n  initials :: \"diagram \\<Rightarrow> node fset\"\nwhere\n  \"initials G = ffilter (\\<lambda>v. (\\<forall>e \\<in> set G^E. v |\\<notin>| thd3 e)) G^V\""], ["", "definition\n   terminals :: \"diagram \\<Rightarrow> node fset\"\nwhere\n  \"terminals G = ffilter (\\<lambda>v. (\\<forall>e \\<in> set G^E. v |\\<notin>| fst3 e)) G^V\""], ["", "lemma no_edges_imp_all_nodes_initial:\n  \"initials (Graph V \\<Lambda> []) = V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. initials (Graph V \\<Lambda> []) = V", "by (auto simp add: initials_def)"], ["", "lemma no_edges_imp_all_nodes_terminal:\n  \"terminals (Graph V \\<Lambda> []) = V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminals (Graph V \\<Lambda> []) = V", "by (auto simp add: terminals_def)"], ["", "lemma initials_in_vertices:\n   \"initials G |\\<subseteq>| G^V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. initials G |\\<subseteq>| G^V", "unfolding initials_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ffilter (\\<lambda>v. \\<forall>e\\<in>set G^E. v |\\<notin>| thd3 e)\n     G^V |\\<subseteq>|\n    G^V", "by auto"], ["", "lemma terminals_in_vertices:\n   \"terminals G |\\<subseteq>| G^V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminals G |\\<subseteq>| G^V", "unfolding terminals_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ffilter (\\<lambda>v. \\<forall>e\\<in>set G^E. v |\\<notin>| fst3 e)\n     G^V |\\<subseteq>|\n    G^V", "by auto"], ["", "subsection \\<open>Top and bottom interfaces\\<close>"], ["", "primrec\n  top_ass :: \"assertion_gadget \\<Rightarrow> interface\" and\n  top_dia :: \"diagram \\<Rightarrow> interface\"\nwhere\n  \"top_dia (Graph V \\<Lambda> E) = (\\<Otimes>v |\\<in>| initials (Graph V \\<Lambda> E). top_ass (\\<Lambda> v))\"\n| \"top_ass (Rib p) = Ribbon p\"\n| \"top_ass (Exists_dia x G) = Exists_int x (top_dia G)\""], ["", "primrec\n  bot_ass :: \"assertion_gadget \\<Rightarrow> interface\" and\n  bot_dia :: \"diagram \\<Rightarrow> interface\"\nwhere\n  \"bot_dia (Graph V \\<Lambda> E) = (\\<Otimes>v |\\<in>| terminals (Graph V \\<Lambda> E). bot_ass (\\<Lambda> v))\"\n| \"bot_ass (Rib p) = Ribbon p\"\n| \"bot_ass (Exists_dia x G) = Exists_int x (bot_dia G)\""], ["", "subsection \\<open>Proof rules for graphical diagrams\\<close>"], ["", "inductive\n  prov_dia :: \"[diagram, interface, interface] \\<Rightarrow> bool\" and\n  prov_com :: \"[command_gadget, interface, interface] \\<Rightarrow> bool\" and\n  prov_ass :: \"assertion_gadget \\<Rightarrow> bool\"\nwhere\n  Skip: \"prov_ass (Rib p)\"\n| Exists: \"prov_dia G _ _ \\<Longrightarrow> prov_ass (Exists_dia x G)\"\n| Basic: \"prov_triple (asn P, c, asn Q) \\<Longrightarrow> prov_com (Com c) P Q\"\n| Choice: \"\\<lbrakk> prov_dia G P Q ; prov_dia H P Q \\<rbrakk> \n    \\<Longrightarrow> prov_com (Choose_dia G H) P Q\"\n| Loop: \"prov_dia G P P \\<Longrightarrow> prov_com (Loop_dia G) P P\"\n| Main: \"\\<lbrakk> wf_dia G ; \\<And>v. v \\<in> fset G^V \\<Longrightarrow> prov_ass (G^\\<Lambda> v);\n    \\<And>e. e \\<in> set G^E \\<Longrightarrow> prov_com (snd3 e) \n      (\\<Otimes>v |\\<in>| fst3 e. bot_ass (G^\\<Lambda> v))\n      (\\<Otimes>v |\\<in>| thd3 e. top_ass (G^\\<Lambda> v))\\<rbrakk> \n    \\<Longrightarrow> prov_dia G (top_dia G) (bot_dia G)\""], ["", "inductive_cases main_inv: \"prov_dia (Graph V \\<Lambda> E) P Q\""], ["", "inductive_cases loop_inv: \"prov_com (Loop_dia G) P Q\""], ["", "inductive_cases choice_inv: \"prov_com (Choose_dia G H) P Q\""], ["", "inductive_cases basic_inv: \"prov_com (Com c) P Q\""], ["", "inductive_cases exists_inv: \"prov_ass (Exists_dia x G)\""], ["", "inductive_cases skip_inv: \"prov_ass (Rib p)\""], ["", "subsection \\<open>Extracting commands from diagrams\\<close>"], ["", "type_synonym lin = \"(node + edge) list\""], ["", "text \\<open>A linear extension (lin) of a diagram is a list of its nodes and edges\n  which respects the order of those nodes and edges. That is, if an edge\n  @{term e} goes from node @{term v} to node @{term w}, then @{term v} and \n  @{term e} and @{term w} must have strictly increasing positions in the list. \n\\<close>"], ["", "definition lins :: \"diagram \\<Rightarrow> lin set\"\nwhere\n\"lins G \\<equiv> {\\<pi> :: lin. \n    (distinct \\<pi>) \n  \\<and> (set \\<pi> = (fset G^V) <+> (set G^E)) \n  \\<and> (\\<forall>i j v e. i < length \\<pi> \\<and> j < length \\<pi> \\<and> \\<pi>!i = Inl v \\<and> \\<pi>!j = Inr e \n    \\<and> v |\\<in>| fst3 e \\<longrightarrow> i<j) \n  \\<and> (\\<forall>j k w e. j < length \\<pi> \\<and> k < length \\<pi> \\<and> \\<pi>!j = Inr e \\<and> \\<pi>!k = Inl w \n    \\<and> w |\\<in>| thd3 e \\<longrightarrow> j<k) }\""], ["", "lemma linsD:\n  assumes \"\\<pi> \\<in> lins G\"\n  shows \"(distinct \\<pi>)\" \n    and \"(set \\<pi> = (fset G^V) <+> (set G^E))\" \n    and \"(\\<forall>i j v e. i < length \\<pi> \\<and> j < length \\<pi> \n     \\<and> \\<pi>!i = Inl v \\<and> \\<pi>!j = Inr e \\<and> v |\\<in>| fst3 e \\<longrightarrow> i<j)\"\n    and \"(\\<forall>j k w e. j < length \\<pi> \\<and> k < length \\<pi> \n     \\<and> \\<pi>!j = Inr e \\<and> \\<pi>!k = Inl w \\<and> w |\\<in>| thd3 e \\<longrightarrow> j<k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (distinct \\<pi> &&& set \\<pi> = fset G^V <+> set G^E) &&&\n    \\<forall>i j v e.\n       i < length \\<pi> \\<and>\n       j < length \\<pi> \\<and>\n       \\<pi> ! i = Inl v \\<and>\n       \\<pi> ! j = Inr e \\<and> v |\\<in>| fst3 e \\<longrightarrow>\n       i < j &&&\n    \\<forall>j k w e.\n       j < length \\<pi> \\<and>\n       k < length \\<pi> \\<and>\n       \\<pi> ! j = Inr e \\<and>\n       \\<pi> ! k = Inl w \\<and> w |\\<in>| thd3 e \\<longrightarrow>\n       j < k", "using assms"], ["proof (prove)\nusing this:\n  \\<pi> \\<in> lins G\n\ngoal (1 subgoal):\n 1. (distinct \\<pi> &&& set \\<pi> = fset G^V <+> set G^E) &&&\n    \\<forall>i j v e.\n       i < length \\<pi> \\<and>\n       j < length \\<pi> \\<and>\n       \\<pi> ! i = Inl v \\<and>\n       \\<pi> ! j = Inr e \\<and> v |\\<in>| fst3 e \\<longrightarrow>\n       i < j &&&\n    \\<forall>j k w e.\n       j < length \\<pi> \\<and>\n       k < length \\<pi> \\<and>\n       \\<pi> ! j = Inr e \\<and>\n       \\<pi> ! k = Inl w \\<and> w |\\<in>| thd3 e \\<longrightarrow>\n       j < k", "apply -"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<pi> \\<in> lins G \\<Longrightarrow> distinct \\<pi>\n 2. \\<pi> \\<in> lins G \\<Longrightarrow> set \\<pi> = fset G^V <+> set G^E\n 3. \\<pi> \\<in> lins G \\<Longrightarrow>\n    \\<forall>i j v e.\n       i < length \\<pi> \\<and>\n       j < length \\<pi> \\<and>\n       \\<pi> ! i = Inl v \\<and>\n       \\<pi> ! j = Inr e \\<and> v |\\<in>| fst3 e \\<longrightarrow>\n       i < j\n 4. \\<pi> \\<in> lins G \\<Longrightarrow>\n    \\<forall>j k w e.\n       j < length \\<pi> \\<and>\n       k < length \\<pi> \\<and>\n       \\<pi> ! j = Inr e \\<and>\n       \\<pi> ! k = Inl w \\<and> w |\\<in>| thd3 e \\<longrightarrow>\n       j < k", "apply (unfold lins_def Collect_iff)"], ["proof (prove)\ngoal (4 subgoals):\n 1. distinct \\<pi> \\<and>\n    set \\<pi> = fset G^V <+> set G^E \\<and>\n    (\\<forall>i j v e.\n        i < length \\<pi> \\<and>\n        j < length \\<pi> \\<and>\n        \\<pi> ! i = Inl v \\<and>\n        \\<pi> ! j = Inr e \\<and> v |\\<in>| fst3 e \\<longrightarrow>\n        i < j) \\<and>\n    (\\<forall>j k w e.\n        j < length \\<pi> \\<and>\n        k < length \\<pi> \\<and>\n        \\<pi> ! j = Inr e \\<and>\n        \\<pi> ! k = Inl w \\<and> w |\\<in>| thd3 e \\<longrightarrow>\n        j < k) \\<Longrightarrow>\n    distinct \\<pi>\n 2. distinct \\<pi> \\<and>\n    set \\<pi> = fset G^V <+> set G^E \\<and>\n    (\\<forall>i j v e.\n        i < length \\<pi> \\<and>\n        j < length \\<pi> \\<and>\n        \\<pi> ! i = Inl v \\<and>\n        \\<pi> ! j = Inr e \\<and> v |\\<in>| fst3 e \\<longrightarrow>\n        i < j) \\<and>\n    (\\<forall>j k w e.\n        j < length \\<pi> \\<and>\n        k < length \\<pi> \\<and>\n        \\<pi> ! j = Inr e \\<and>\n        \\<pi> ! k = Inl w \\<and> w |\\<in>| thd3 e \\<longrightarrow>\n        j < k) \\<Longrightarrow>\n    set \\<pi> = fset G^V <+> set G^E\n 3. distinct \\<pi> \\<and>\n    set \\<pi> = fset G^V <+> set G^E \\<and>\n    (\\<forall>i j v e.\n        i < length \\<pi> \\<and>\n        j < length \\<pi> \\<and>\n        \\<pi> ! i = Inl v \\<and>\n        \\<pi> ! j = Inr e \\<and> v |\\<in>| fst3 e \\<longrightarrow>\n        i < j) \\<and>\n    (\\<forall>j k w e.\n        j < length \\<pi> \\<and>\n        k < length \\<pi> \\<and>\n        \\<pi> ! j = Inr e \\<and>\n        \\<pi> ! k = Inl w \\<and> w |\\<in>| thd3 e \\<longrightarrow>\n        j < k) \\<Longrightarrow>\n    \\<forall>i j v e.\n       i < length \\<pi> \\<and>\n       j < length \\<pi> \\<and>\n       \\<pi> ! i = Inl v \\<and>\n       \\<pi> ! j = Inr e \\<and> v |\\<in>| fst3 e \\<longrightarrow>\n       i < j\n 4. distinct \\<pi> \\<and>\n    set \\<pi> = fset G^V <+> set G^E \\<and>\n    (\\<forall>i j v e.\n        i < length \\<pi> \\<and>\n        j < length \\<pi> \\<and>\n        \\<pi> ! i = Inl v \\<and>\n        \\<pi> ! j = Inr e \\<and> v |\\<in>| fst3 e \\<longrightarrow>\n        i < j) \\<and>\n    (\\<forall>j k w e.\n        j < length \\<pi> \\<and>\n        k < length \\<pi> \\<and>\n        \\<pi> ! j = Inr e \\<and>\n        \\<pi> ! k = Inl w \\<and> w |\\<in>| thd3 e \\<longrightarrow>\n        j < k) \\<Longrightarrow>\n    \\<forall>j k w e.\n       j < length \\<pi> \\<and>\n       k < length \\<pi> \\<and>\n       \\<pi> ! j = Inr e \\<and>\n       \\<pi> ! k = Inl w \\<and> w |\\<in>| thd3 e \\<longrightarrow>\n       j < k", "apply (elim conjE, assumption)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>The following lemma enables the inductive definition below to be\n  proved monotonic. It does this by showing how one of the premises of the\n  @{term coms_main} rule can be rewritten in a form that is more verbose but \n  easier to prove monotonic.\\<close>"], ["", "lemma coms_mono_helper:\n  \"(\\<forall>i<length \\<pi>. case_sum (coms_ass \\<circ> \\<Lambda>) (coms_com \\<circ> snd3) (\\<pi>!i) (cs!i)) \n  = \n  ((\\<forall>i. i<length \\<pi> \\<and> (\\<exists>v. (\\<pi>!i) = Inl v) \\<longrightarrow> \n    coms_ass (\\<Lambda> (projl (\\<pi>!i))) (cs!i)) \\<and>\n  (\\<forall>i. i<length \\<pi> \\<and> (\\<exists>e. (\\<pi>!i) = Inr e) \\<longrightarrow> \n    coms_com (snd3 (projr (\\<pi>!i))) (cs!i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i<length \\<pi>.\n        (case \\<pi> ! i of\n         Inl x \\<Rightarrow> (coms_ass \\<circ> \\<Lambda>) x\n         | Inr x \\<Rightarrow> (coms_com \\<circ> snd3) x)\n         (cs ! i)) =\n    ((\\<forall>i.\n         i < length \\<pi> \\<and>\n         (\\<exists>v. \\<pi> ! i = Inl v) \\<longrightarrow>\n         coms_ass (\\<Lambda> (projl (\\<pi> ! i))) (cs ! i)) \\<and>\n     (\\<forall>i.\n         i < length \\<pi> \\<and>\n         (\\<exists>e. \\<pi> ! i = Inr e) \\<longrightarrow>\n         coms_com (snd3 (projr (\\<pi> ! i))) (cs ! i)))", "apply (intro iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>i<length \\<pi>.\n       (case \\<pi> ! i of Inl x \\<Rightarrow> (coms_ass \\<circ> \\<Lambda>) x\n        | Inr x \\<Rightarrow> (coms_com \\<circ> snd3) x)\n        (cs ! i) \\<Longrightarrow>\n    (\\<forall>i.\n        i < length \\<pi> \\<and>\n        (\\<exists>v. \\<pi> ! i = Inl v) \\<longrightarrow>\n        coms_ass (\\<Lambda> (projl (\\<pi> ! i))) (cs ! i)) \\<and>\n    (\\<forall>i.\n        i < length \\<pi> \\<and>\n        (\\<exists>e. \\<pi> ! i = Inr e) \\<longrightarrow>\n        coms_com (snd3 (projr (\\<pi> ! i))) (cs ! i))\n 2. (\\<forall>i.\n        i < length \\<pi> \\<and>\n        (\\<exists>v. \\<pi> ! i = Inl v) \\<longrightarrow>\n        coms_ass (\\<Lambda> (projl (\\<pi> ! i))) (cs ! i)) \\<and>\n    (\\<forall>i.\n        i < length \\<pi> \\<and>\n        (\\<exists>e. \\<pi> ! i = Inr e) \\<longrightarrow>\n        coms_com (snd3 (projr (\\<pi> ! i))) (cs ! i)) \\<Longrightarrow>\n    \\<forall>i<length \\<pi>.\n       (case \\<pi> ! i of Inl x \\<Rightarrow> (coms_ass \\<circ> \\<Lambda>) x\n        | Inr x \\<Rightarrow> (coms_com \\<circ> snd3) x)\n        (cs ! i)", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i.\n        i < length \\<pi> \\<and>\n        (\\<exists>v. \\<pi> ! i = Inl v) \\<longrightarrow>\n        coms_ass (\\<Lambda> (projl (\\<pi> ! i))) (cs ! i)) \\<and>\n    (\\<forall>i.\n        i < length \\<pi> \\<and>\n        (\\<exists>e. \\<pi> ! i = Inr e) \\<longrightarrow>\n        coms_com (snd3 (projr (\\<pi> ! i))) (cs ! i)) \\<Longrightarrow>\n    \\<forall>i<length \\<pi>.\n       (case \\<pi> ! i of Inl x \\<Rightarrow> (coms_ass \\<circ> \\<Lambda>) x\n        | Inr x \\<Rightarrow> (coms_com \\<circ> snd3) x)\n        (cs ! i)", "apply (intro allI impI, case_tac \"\\<pi>!i\", auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>The @{term coms_dia} function extracts a set of commands from a \n  diagram. Each command in @{term \"coms_dia G\"} is obtained by extracting a \n  command from each of @{term G}'s nodes and edges (using @{term coms_ass} or \n  @{term coms_com} respectively), then picking a linear extension @{term \\<pi>} of \n  these nodes and edges (using @{term lins}), and composing the extracted \n  commands in accordance with @{term \\<pi>}.\n\\<close>"], ["", "inductive\n  coms_dia :: \"[diagram, command] \\<Rightarrow> bool\" and\n  coms_ass :: \"[assertion_gadget, command] \\<Rightarrow> bool\" and\n  coms_com :: \"[command_gadget, command] \\<Rightarrow> bool\"\nwhere\n  coms_skip: \"coms_ass (Rib p) Skip\"\n| coms_exists: \"coms_dia G c \\<Longrightarrow> coms_ass (Exists_dia x G) c\"\n| coms_basic: \"coms_com (Com c) c\"\n| coms_choice: \"\\<lbrakk> coms_dia G c; coms_dia H d \\<rbrakk> \\<Longrightarrow> \n    coms_com (Choose_dia G H) (Choose c d)\"\n| coms_loop: \"coms_dia G c \\<Longrightarrow> coms_com (Loop_dia G) (Loop c)\"\n| coms_main: \"\\<lbrakk> \\<pi> \\<in> lins (Graph V \\<Lambda> E); length cs = length \\<pi>;\n    \\<forall>i<length \\<pi>. case_sum (coms_ass \\<circ> \\<Lambda>) (coms_com \\<circ> snd3) (\\<pi>!i) (cs!i) \\<rbrakk> \n    \\<Longrightarrow> coms_dia (Graph V \\<Lambda> E) (foldr (;;) cs Skip)\"\nmonos \n  coms_mono_helper"], ["", "inductive_cases coms_skip_inv: \"coms_ass (Rib p) c\""], ["", "inductive_cases coms_exists_inv: \"coms_ass (Exists_dia x G) c\""], ["", "inductive_cases coms_basic_inv: \"coms_com (Com c') c\""], ["", "inductive_cases coms_choice_inv: \"coms_com (Choose_dia G H) c\""], ["", "inductive_cases coms_loop_inv: \"coms_com (Loop_dia G) c\""], ["", "inductive_cases coms_main_inv: \"coms_dia G c\""], ["", "end"]]}