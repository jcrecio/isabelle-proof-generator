{"file_name": "/home/qj213/afp-2021-10-22/thys/Ribbon_Proofs/Ribbons_Basic.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Ribbon_Proofs", "problem_names": ["lemma star_rot: \n  \"q \\<star> p \\<star> r = p \\<star> q \\<star> r\"", "lemma choice_lemma:\n  assumes \"prov_triple (p1, c1, q1)\" and \"prov_triple (p2, c2, q2)\"\n    and \"p = p1\" and \"p1 = p2\" and \"q = q1\" and \"q1 = q2\"\n  shows \"prov_triple (p, Choose c1 c2, q)\"", "lemma loop_lemma:\n  assumes \"prov_triple (p1, c, q1)\" and \"p = p1\" and \"p1 = q1\" and \"q1 = q\"\n  shows \"prov_triple (p, Loop c, q)\"", "lemma seq_lemma:\n  assumes \"prov_triple (p1, c1, q1)\" and \"prov_triple (p2, c2, q2)\" \n    and \"q1 = p2\"\n  shows \"prov_triple (p1, c1 ;; c2, q2)\""], "translations": [["", "lemma star_rot: \n  \"q \\<star> p \\<star> r = p \\<star> q \\<star> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<star> p \\<star> r = p \\<star> q \\<star> r", "using star_assoc star_comm"], ["proof (prove)\nusing this:\n  (?p \\<star> ?q) \\<star> ?r = ?p \\<star> ?q \\<star> ?r\n  ?p \\<star> ?q = ?q \\<star> ?p\n\ngoal (1 subgoal):\n 1. q \\<star> p \\<star> r = p \\<star> q \\<star> r", "by auto"], ["", "axiomatization \n  Exists :: \"string \\<Rightarrow> assertion \\<Rightarrow> assertion\""], ["", "text \\<open>Extracting the set of program variables mentioned in an assertion.\\<close>"], ["", "axiomatization \n  rd_ass :: \"assertion \\<Rightarrow> string set\"\nwhere rd_emp: \"rd_ass Emp = {}\"\n  and rd_star: \"rd_ass (p \\<star> q) = rd_ass p \\<union> rd_ass q\"\n  and rd_exists: \"rd_ass (Exists x p) = rd_ass p\""], ["", "subsection \\<open>Commands\\<close>"], ["", "text \\<open>The language of commands comprises (at least) non-deterministic \n  choice, non-deterministic looping, skip and sequencing.\\<close>"], ["", "typedecl command"], ["", "axiomatization \n  Choose :: \"command \\<Rightarrow> command \\<Rightarrow> command\""], ["", "axiomatization \n  Loop :: \"command \\<Rightarrow> command\""], ["", "axiomatization \n  Skip :: \"command\""], ["", "axiomatization\n  Seq :: \"command \\<Rightarrow> command \\<Rightarrow> command\" (infixr \";;\" 55)\nwhere seq_assoc: \"c1 ;; (c2 ;; c3) = (c1 ;; c2) ;; c3\"\n  and seq_skip: \"c ;; Skip = c\"\n  and skip_seq: \"Skip ;; c = c\""], ["", "text \\<open>Extracting the set of program variables read by a command.\\<close>"], ["", "axiomatization\n  rd_com :: \"command \\<Rightarrow> string set\"\nwhere rd_com_choose: \"rd_com (Choose c1 c2) = rd_com c1 \\<union> rd_com c2\"\n  and rd_com_loop: \"rd_com (Loop c) = rd_com c\"\n  and rd_com_skip: \"rd_com (Skip) = {}\"\n  and rd_com_seq: \"rd_com (c1 ;; c2) = rd_com c1 \\<union> rd_com c2\""], ["", "text \\<open>Extracting the set of program variables written by a command.\\<close>"], ["", "axiomatization\n  wr_com :: \"command \\<Rightarrow> string set\"\nwhere wr_com_choose: \"wr_com (Choose c1 c2) = wr_com c1 \\<union> wr_com c2\"\n  and wr_com_loop: \"wr_com (Loop c) = wr_com c\"\n  and wr_com_skip: \"wr_com (Skip) = {}\"\n  and wr_com_seq: \"wr_com (c1 ;; c2) = wr_com c1 \\<union> wr_com c2\""], ["", "subsection \\<open>Separation logic proof rules\\<close>"], ["", "text \\<open>Note that the frame rule has a side-condition concerning program\n  variables. When proving the soundness of our graphical formalisation of\n  ribbon proofs, we shall omit this side-condition.\\<close>"], ["", "inductive\n  prov_triple :: \"assertion \\<times> command \\<times> assertion \\<Rightarrow> bool\"\nwhere\n  exists: \"prov_triple (p, c, q) \\<Longrightarrow> prov_triple (Exists x p, c, Exists x q)\"\n| choose: \"\\<lbrakk> prov_triple (p, c1, q); prov_triple (p, c2, q) \\<rbrakk> \n  \\<Longrightarrow> prov_triple (p, Choose c1 c2, q)\"\n| loop: \"prov_triple (p, c, p) \\<Longrightarrow> prov_triple (p, Loop c, p)\" \n| frame: \"\\<lbrakk> prov_triple (p, c, q); wr_com(c) \\<inter> rd_ass(r) = {} \\<rbrakk> \n  \\<Longrightarrow> prov_triple (p \\<star> r, c, q \\<star> r)\"\n| skip: \"prov_triple (p, Skip, p)\"\n| seq: \"\\<lbrakk> prov_triple (p, c1, q); prov_triple (q, c2, r) \\<rbrakk> \n  \\<Longrightarrow> prov_triple (p, c1 ;; c2, r)\""], ["", "text \\<open>Here are some derived proof rules, which are used in our \n  ribbon-checking tool.\\<close>"], ["", "lemma choice_lemma:\n  assumes \"prov_triple (p1, c1, q1)\" and \"prov_triple (p2, c2, q2)\"\n    and \"p = p1\" and \"p1 = p2\" and \"q = q1\" and \"q1 = q2\"\n  shows \"prov_triple (p, Choose c1 c2, q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prov_triple (p, Choose c1 c2, q)", "using assms prov_triple.choose"], ["proof (prove)\nusing this:\n  prov_triple (p1, c1, q1)\n  prov_triple (p2, c2, q2)\n  p = p1\n  p1 = p2\n  q = q1\n  q1 = q2\n  \\<lbrakk>prov_triple (?p, ?c1.0, ?q); prov_triple (?p, ?c2.0, ?q)\\<rbrakk>\n  \\<Longrightarrow> prov_triple (?p, Choose ?c1.0 ?c2.0, ?q)\n\ngoal (1 subgoal):\n 1. prov_triple (p, Choose c1 c2, q)", "by auto"], ["", "lemma loop_lemma:\n  assumes \"prov_triple (p1, c, q1)\" and \"p = p1\" and \"p1 = q1\" and \"q1 = q\"\n  shows \"prov_triple (p, Loop c, q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prov_triple (p, Loop c, q)", "using assms prov_triple.loop"], ["proof (prove)\nusing this:\n  prov_triple (p1, c, q1)\n  p = p1\n  p1 = q1\n  q1 = q\n  prov_triple (?p, ?c, ?p) \\<Longrightarrow> prov_triple (?p, Loop ?c, ?p)\n\ngoal (1 subgoal):\n 1. prov_triple (p, Loop c, q)", "by auto"], ["", "lemma seq_lemma:\n  assumes \"prov_triple (p1, c1, q1)\" and \"prov_triple (p2, c2, q2)\" \n    and \"q1 = p2\"\n  shows \"prov_triple (p1, c1 ;; c2, q2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prov_triple (p1, c1 ;; c2, q2)", "using assms prov_triple.seq"], ["proof (prove)\nusing this:\n  prov_triple (p1, c1, q1)\n  prov_triple (p2, c2, q2)\n  q1 = p2\n  \\<lbrakk>prov_triple (?p, ?c1.0, ?q); prov_triple (?q, ?c2.0, ?r)\\<rbrakk>\n  \\<Longrightarrow> prov_triple (?p, ?c1.0 ;; ?c2.0, ?r)\n\ngoal (1 subgoal):\n 1. prov_triple (p1, c1 ;; c2, q2)", "by auto"], ["", "end"]]}