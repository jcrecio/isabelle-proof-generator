{"file_name": "/home/qj213/afp-2021-10-22/thys/Ribbon_Proofs/Ribbons_Stratified.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Ribbon_Proofs", "problem_names": ["lemma wr_sdia_is_wr_com:\n  fixes \\<rho>s :: \"row list\"\n  and \\<rho> :: row\n  shows \"(wr_sdia D = wr_com (com_sdia D))\"\n  and \"(wr_cell \\<gamma> = wr_com (com_cell \\<gamma>))\"\n  and \"(\\<Union>\\<rho> \\<in> set \\<rho>s. wr_cell (fst \\<rho>)) \n    = wr_com (foldr (;;) (map (\\<lambda>(\\<gamma>,F). com_cell \\<gamma>) \\<rho>s) Skip)\"\n  and \"wr_cell (fst \\<rho>) = wr_com (com_cell (fst \\<rho>))\"", "lemma soundness_strat_helper:\n  \"(prov_sdia D P Q \\<longrightarrow> prov_triple (asn P, com_sdia D, asn Q)) \\<and>\n   (prov_row \\<rho> P Q \\<longrightarrow> prov_triple (asn P, com_cell (fst \\<rho>), asn Q)) \\<and>\n   (prov_cell \\<gamma> P Q \\<longrightarrow> prov_triple (asn P, com_cell \\<gamma>, asn Q))\""], "translations": [["", "lemma wr_sdia_is_wr_com:\n  fixes \\<rho>s :: \"row list\"\n  and \\<rho> :: row\n  shows \"(wr_sdia D = wr_com (com_sdia D))\"\n  and \"(wr_cell \\<gamma> = wr_com (com_cell \\<gamma>))\"\n  and \"(\\<Union>\\<rho> \\<in> set \\<rho>s. wr_cell (fst \\<rho>)) \n    = wr_com (foldr (;;) (map (\\<lambda>(\\<gamma>,F). com_cell \\<gamma>) \\<rho>s) Skip)\"\n  and \"wr_cell (fst \\<rho>) = wr_com (com_cell (fst \\<rho>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (wr_sdia D = wr_com (com_sdia D) &&&\n     wr_cell \\<gamma> = wr_com (com_cell \\<gamma>)) &&&\n    (\\<Union>\\<rho>\\<in>set \\<rho>s. wr_cell (fst \\<rho>)) =\n    wr_com\n     (foldr (;;) (map (\\<lambda>(\\<gamma>, F). com_cell \\<gamma>) \\<rho>s)\n       Skip) &&&\n    wr_cell (fst \\<rho>) = wr_com (com_cell (fst \\<rho>))", "apply (induct D and \\<gamma> and \\<rho>s and \\<rho> rule: compat_sdiagram.induct compat_cell.induct\n  compat_cell_interface_prod_list.induct compat_cell_interface_prod.induct)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x.\n       (\\<Union>\\<rho>\\<in>set x. wr_cell (fst \\<rho>)) =\n       wr_com\n        (foldr (;;)\n          (map (\\<lambda>a.\n                   case a of (\\<gamma>, F) \\<Rightarrow> com_cell \\<gamma>)\n            x)\n          Skip) \\<Longrightarrow>\n       wr_sdia (SDiagram x) = wr_com (com_sdia (SDiagram x))\n 2. \\<And>x. wr_cell (Filler x) = wr_com (com_cell (Filler x))\n 3. \\<And>x1a x2 x3.\n       wr_cell (Basic x1a x2 x3) = wr_com (com_cell (Basic x1a x2 x3))\n 4. \\<And>x1a x2.\n       wr_sdia x2 = wr_com (com_sdia x2) \\<Longrightarrow>\n       wr_cell (Exists_sdia x1a x2) = wr_com (com_cell (Exists_sdia x1a x2))\n 5. \\<And>x1a x2 x3 x4.\n       \\<lbrakk>wr_sdia x2 = wr_com (com_sdia x2);\n        wr_sdia x3 = wr_com (com_sdia x3)\\<rbrakk>\n       \\<Longrightarrow> wr_cell (Choose_sdia x1a x2 x3 x4) =\n                         wr_com (com_cell (Choose_sdia x1a x2 x3 x4))\n 6. \\<And>x1a x2 x3.\n       wr_sdia x2 = wr_com (com_sdia x2) \\<Longrightarrow>\n       wr_cell (Loop_sdia x1a x2 x3) =\n       wr_com (com_cell (Loop_sdia x1a x2 x3))\n 7. \\<And>x1a x2.\n       wr_cell x1a = wr_com (com_cell x1a) \\<Longrightarrow>\n       wr_cell (fst (x1a, x2)) = wr_com (com_cell (fst (x1a, x2)))\n 8. (\\<Union>\\<rho>\\<in>set []. wr_cell (fst \\<rho>)) =\n    wr_com\n     (foldr (;;)\n       (map (\\<lambda>a.\n                case a of (\\<gamma>, F) \\<Rightarrow> com_cell \\<gamma>)\n         [])\n       Skip)\n 9. \\<And>x1a x2.\n       \\<lbrakk>wr_cell (fst x1a) = wr_com (com_cell (fst x1a));\n        (\\<Union>\\<rho>\\<in>set x2. wr_cell (fst \\<rho>)) =\n        wr_com\n         (foldr (;;)\n           (map (\\<lambda>a.\n                    case a of (\\<gamma>, F) \\<Rightarrow> com_cell \\<gamma>)\n             x2)\n           Skip)\\<rbrakk>\n       \\<Longrightarrow> (\\<Union>\\<rho>\\<in>set (x1a # x2).\n                             wr_cell (fst \\<rho>)) =\n                         wr_com\n                          (foldr (;;)\n                            (map (\\<lambda>a.\n                                     case a of\n                                     (\\<gamma>, F) \\<Rightarrow>\n com_cell \\<gamma>)\n                              (x1a # x2))\n                            Skip)", "apply (auto simp add: wr_com_skip wr_com_choose\n  wr_com_loop wr_com_seq split_def o_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Proof rules for stratified diagrams\\<close>"], ["", "inductive \n  prov_sdia :: \"[sdiagram, interface, interface] \\<Rightarrow> bool\" and\n  prov_row :: \"[row, interface, interface] \\<Rightarrow> bool\" and\n  prov_cell :: \"[cell, interface, interface] \\<Rightarrow> bool\"\nwhere\n  SRibbon: \"prov_cell (Filler P) P P\"\n| SBasic: \"prov_triple (asn P, c, asn Q) \\<Longrightarrow> prov_cell (Basic P c Q) P Q\"\n| SExists: \"prov_sdia D P Q \n    \\<Longrightarrow> prov_cell (Exists_sdia x D) (Exists_int x P) (Exists_int x Q)\"\n| SChoice: \"\\<lbrakk> prov_sdia D P Q ; prov_sdia E P Q \\<rbrakk> \n    \\<Longrightarrow> prov_cell (Choose_sdia P D E Q) P Q\"\n| SLoop: \"prov_sdia D P P \\<Longrightarrow> prov_cell (Loop_sdia P D P) P P\"\n| SRow: \"\\<lbrakk> prov_cell \\<gamma> P Q ; wr_cell \\<gamma> \\<inter> rd_int F = {} \\<rbrakk>\n    \\<Longrightarrow> prov_row (\\<gamma>, F) (P \\<otimes> F) (Q \\<otimes> F)\"\n| SMain: \"\\<lbrakk> chain_all (\\<lambda>(P,\\<rho>,Q). prov_row \\<rho> P Q) \\<Pi> ; 0 < chainlen \\<Pi> \\<rbrakk>\n    \\<Longrightarrow> prov_sdia (SDiagram (comlist \\<Pi>)) (pre \\<Pi>) (post \\<Pi>)\""], ["", "subsection \\<open>Soundness\\<close>"], ["", "lemma soundness_strat_helper:\n  \"(prov_sdia D P Q \\<longrightarrow> prov_triple (asn P, com_sdia D, asn Q)) \\<and>\n   (prov_row \\<rho> P Q \\<longrightarrow> prov_triple (asn P, com_cell (fst \\<rho>), asn Q)) \\<and>\n   (prov_cell \\<gamma> P Q \\<longrightarrow> prov_triple (asn P, com_cell \\<gamma>, asn Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (prov_sdia D P Q \\<longrightarrow>\n     prov_triple (asn P, com_sdia D, asn Q)) \\<and>\n    (prov_row \\<rho> P Q \\<longrightarrow>\n     prov_triple (asn P, com_cell (fst \\<rho>), asn Q)) \\<and>\n    (prov_cell \\<gamma> P Q \\<longrightarrow>\n     prov_triple (asn P, com_cell \\<gamma>, asn Q))", "proof (induct rule: prov_sdia_prov_row_prov_cell.induct)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>P. prov_triple (asn P, com_cell (Filler P), asn P)\n 2. \\<And>P c Q.\n       prov_triple (asn P, c, asn Q) \\<Longrightarrow>\n       prov_triple (asn P, com_cell (Basic P c Q), asn Q)\n 3. \\<And>D P Q x.\n       \\<lbrakk>prov_sdia D P Q;\n        prov_triple (asn P, com_sdia D, asn Q)\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (Exists_int x P), com_cell (Exists_sdia x D),\n                           asn (Exists_int x Q))\n 4. \\<And>D P Q E.\n       \\<lbrakk>prov_sdia D P Q; prov_triple (asn P, com_sdia D, asn Q);\n        prov_sdia E P Q; prov_triple (asn P, com_sdia E, asn Q)\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn P, com_cell (Choose_sdia P D E Q), asn Q)\n 5. \\<And>D P.\n       \\<lbrakk>prov_sdia D P P;\n        prov_triple (asn P, com_sdia D, asn P)\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn P, com_cell (Loop_sdia P D P), asn P)\n 6. \\<And>\\<gamma> P Q F.\n       \\<lbrakk>prov_cell \\<gamma> P Q;\n        prov_triple (asn P, com_cell \\<gamma>, asn Q);\n        wr_cell \\<gamma> \\<inter> rd_int F = {}\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (P \\<otimes> F),\n                           com_cell (fst (\\<gamma>, F)),\n                           asn (Q \\<otimes> F))\n 7. \\<And>\\<Pi>.\n       \\<lbrakk>chain_all\n                 (\\<lambda>(P, \\<rho>, Q).\n                     prov_row \\<rho> P Q \\<and>\n                     prov_triple (asn P, com_cell (fst \\<rho>), asn Q))\n                 \\<Pi>;\n        0 < chainlen \\<Pi>\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (pre \\<Pi>),\n                           com_sdia (SDiagram (comlist \\<Pi>)),\n                           asn (post \\<Pi>))", "case (SRibbon P)"], ["proof (state)\nthis:\n  \n\ngoal (7 subgoals):\n 1. \\<And>P. prov_triple (asn P, com_cell (Filler P), asn P)\n 2. \\<And>P c Q.\n       prov_triple (asn P, c, asn Q) \\<Longrightarrow>\n       prov_triple (asn P, com_cell (Basic P c Q), asn Q)\n 3. \\<And>D P Q x.\n       \\<lbrakk>prov_sdia D P Q;\n        prov_triple (asn P, com_sdia D, asn Q)\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (Exists_int x P), com_cell (Exists_sdia x D),\n                           asn (Exists_int x Q))\n 4. \\<And>D P Q E.\n       \\<lbrakk>prov_sdia D P Q; prov_triple (asn P, com_sdia D, asn Q);\n        prov_sdia E P Q; prov_triple (asn P, com_sdia E, asn Q)\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn P, com_cell (Choose_sdia P D E Q), asn Q)\n 5. \\<And>D P.\n       \\<lbrakk>prov_sdia D P P;\n        prov_triple (asn P, com_sdia D, asn P)\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn P, com_cell (Loop_sdia P D P), asn P)\n 6. \\<And>\\<gamma> P Q F.\n       \\<lbrakk>prov_cell \\<gamma> P Q;\n        prov_triple (asn P, com_cell \\<gamma>, asn Q);\n        wr_cell \\<gamma> \\<inter> rd_int F = {}\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (P \\<otimes> F),\n                           com_cell (fst (\\<gamma>, F)),\n                           asn (Q \\<otimes> F))\n 7. \\<And>\\<Pi>.\n       \\<lbrakk>chain_all\n                 (\\<lambda>(P, \\<rho>, Q).\n                     prov_row \\<rho> P Q \\<and>\n                     prov_triple (asn P, com_cell (fst \\<rho>), asn Q))\n                 \\<Pi>;\n        0 < chainlen \\<Pi>\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (pre \\<Pi>),\n                           com_sdia (SDiagram (comlist \\<Pi>)),\n                           asn (post \\<Pi>))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. prov_triple (asn P, com_cell (Filler P), asn P)", "by (auto simp add: prov_triple.skip)"], ["proof (state)\nthis:\n  prov_triple (asn P, com_cell (Filler P), asn P)\n\ngoal (6 subgoals):\n 1. \\<And>P c Q.\n       prov_triple (asn P, c, asn Q) \\<Longrightarrow>\n       prov_triple (asn P, com_cell (Basic P c Q), asn Q)\n 2. \\<And>D P Q x.\n       \\<lbrakk>prov_sdia D P Q;\n        prov_triple (asn P, com_sdia D, asn Q)\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (Exists_int x P), com_cell (Exists_sdia x D),\n                           asn (Exists_int x Q))\n 3. \\<And>D P Q E.\n       \\<lbrakk>prov_sdia D P Q; prov_triple (asn P, com_sdia D, asn Q);\n        prov_sdia E P Q; prov_triple (asn P, com_sdia E, asn Q)\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn P, com_cell (Choose_sdia P D E Q), asn Q)\n 4. \\<And>D P.\n       \\<lbrakk>prov_sdia D P P;\n        prov_triple (asn P, com_sdia D, asn P)\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn P, com_cell (Loop_sdia P D P), asn P)\n 5. \\<And>\\<gamma> P Q F.\n       \\<lbrakk>prov_cell \\<gamma> P Q;\n        prov_triple (asn P, com_cell \\<gamma>, asn Q);\n        wr_cell \\<gamma> \\<inter> rd_int F = {}\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (P \\<otimes> F),\n                           com_cell (fst (\\<gamma>, F)),\n                           asn (Q \\<otimes> F))\n 6. \\<And>\\<Pi>.\n       \\<lbrakk>chain_all\n                 (\\<lambda>(P, \\<rho>, Q).\n                     prov_row \\<rho> P Q \\<and>\n                     prov_triple (asn P, com_cell (fst \\<rho>), asn Q))\n                 \\<Pi>;\n        0 < chainlen \\<Pi>\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (pre \\<Pi>),\n                           com_sdia (SDiagram (comlist \\<Pi>)),\n                           asn (post \\<Pi>))", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>P c Q.\n       prov_triple (asn P, c, asn Q) \\<Longrightarrow>\n       prov_triple (asn P, com_cell (Basic P c Q), asn Q)\n 2. \\<And>D P Q x.\n       \\<lbrakk>prov_sdia D P Q;\n        prov_triple (asn P, com_sdia D, asn Q)\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (Exists_int x P), com_cell (Exists_sdia x D),\n                           asn (Exists_int x Q))\n 3. \\<And>D P Q E.\n       \\<lbrakk>prov_sdia D P Q; prov_triple (asn P, com_sdia D, asn Q);\n        prov_sdia E P Q; prov_triple (asn P, com_sdia E, asn Q)\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn P, com_cell (Choose_sdia P D E Q), asn Q)\n 4. \\<And>D P.\n       \\<lbrakk>prov_sdia D P P;\n        prov_triple (asn P, com_sdia D, asn P)\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn P, com_cell (Loop_sdia P D P), asn P)\n 5. \\<And>\\<gamma> P Q F.\n       \\<lbrakk>prov_cell \\<gamma> P Q;\n        prov_triple (asn P, com_cell \\<gamma>, asn Q);\n        wr_cell \\<gamma> \\<inter> rd_int F = {}\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (P \\<otimes> F),\n                           com_cell (fst (\\<gamma>, F)),\n                           asn (Q \\<otimes> F))\n 6. \\<And>\\<Pi>.\n       \\<lbrakk>chain_all\n                 (\\<lambda>(P, \\<rho>, Q).\n                     prov_row \\<rho> P Q \\<and>\n                     prov_triple (asn P, com_cell (fst \\<rho>), asn Q))\n                 \\<Pi>;\n        0 < chainlen \\<Pi>\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (pre \\<Pi>),\n                           com_sdia (SDiagram (comlist \\<Pi>)),\n                           asn (post \\<Pi>))", "case (SBasic P c Q)"], ["proof (state)\nthis:\n  prov_triple (asn P, c, asn Q)\n\ngoal (6 subgoals):\n 1. \\<And>P c Q.\n       prov_triple (asn P, c, asn Q) \\<Longrightarrow>\n       prov_triple (asn P, com_cell (Basic P c Q), asn Q)\n 2. \\<And>D P Q x.\n       \\<lbrakk>prov_sdia D P Q;\n        prov_triple (asn P, com_sdia D, asn Q)\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (Exists_int x P), com_cell (Exists_sdia x D),\n                           asn (Exists_int x Q))\n 3. \\<And>D P Q E.\n       \\<lbrakk>prov_sdia D P Q; prov_triple (asn P, com_sdia D, asn Q);\n        prov_sdia E P Q; prov_triple (asn P, com_sdia E, asn Q)\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn P, com_cell (Choose_sdia P D E Q), asn Q)\n 4. \\<And>D P.\n       \\<lbrakk>prov_sdia D P P;\n        prov_triple (asn P, com_sdia D, asn P)\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn P, com_cell (Loop_sdia P D P), asn P)\n 5. \\<And>\\<gamma> P Q F.\n       \\<lbrakk>prov_cell \\<gamma> P Q;\n        prov_triple (asn P, com_cell \\<gamma>, asn Q);\n        wr_cell \\<gamma> \\<inter> rd_int F = {}\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (P \\<otimes> F),\n                           com_cell (fst (\\<gamma>, F)),\n                           asn (Q \\<otimes> F))\n 6. \\<And>\\<Pi>.\n       \\<lbrakk>chain_all\n                 (\\<lambda>(P, \\<rho>, Q).\n                     prov_row \\<rho> P Q \\<and>\n                     prov_triple (asn P, com_cell (fst \\<rho>), asn Q))\n                 \\<Pi>;\n        0 < chainlen \\<Pi>\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (pre \\<Pi>),\n                           com_sdia (SDiagram (comlist \\<Pi>)),\n                           asn (post \\<Pi>))", "thus ?case"], ["proof (prove)\nusing this:\n  prov_triple (asn P, c, asn Q)\n\ngoal (1 subgoal):\n 1. prov_triple (asn P, com_cell (Basic P c Q), asn Q)", "by auto"], ["proof (state)\nthis:\n  prov_triple (asn P, com_cell (Basic P c Q), asn Q)\n\ngoal (5 subgoals):\n 1. \\<And>D P Q x.\n       \\<lbrakk>prov_sdia D P Q;\n        prov_triple (asn P, com_sdia D, asn Q)\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (Exists_int x P), com_cell (Exists_sdia x D),\n                           asn (Exists_int x Q))\n 2. \\<And>D P Q E.\n       \\<lbrakk>prov_sdia D P Q; prov_triple (asn P, com_sdia D, asn Q);\n        prov_sdia E P Q; prov_triple (asn P, com_sdia E, asn Q)\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn P, com_cell (Choose_sdia P D E Q), asn Q)\n 3. \\<And>D P.\n       \\<lbrakk>prov_sdia D P P;\n        prov_triple (asn P, com_sdia D, asn P)\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn P, com_cell (Loop_sdia P D P), asn P)\n 4. \\<And>\\<gamma> P Q F.\n       \\<lbrakk>prov_cell \\<gamma> P Q;\n        prov_triple (asn P, com_cell \\<gamma>, asn Q);\n        wr_cell \\<gamma> \\<inter> rd_int F = {}\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (P \\<otimes> F),\n                           com_cell (fst (\\<gamma>, F)),\n                           asn (Q \\<otimes> F))\n 5. \\<And>\\<Pi>.\n       \\<lbrakk>chain_all\n                 (\\<lambda>(P, \\<rho>, Q).\n                     prov_row \\<rho> P Q \\<and>\n                     prov_triple (asn P, com_cell (fst \\<rho>), asn Q))\n                 \\<Pi>;\n        0 < chainlen \\<Pi>\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (pre \\<Pi>),\n                           com_sdia (SDiagram (comlist \\<Pi>)),\n                           asn (post \\<Pi>))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>D P Q x.\n       \\<lbrakk>prov_sdia D P Q;\n        prov_triple (asn P, com_sdia D, asn Q)\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (Exists_int x P), com_cell (Exists_sdia x D),\n                           asn (Exists_int x Q))\n 2. \\<And>D P Q E.\n       \\<lbrakk>prov_sdia D P Q; prov_triple (asn P, com_sdia D, asn Q);\n        prov_sdia E P Q; prov_triple (asn P, com_sdia E, asn Q)\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn P, com_cell (Choose_sdia P D E Q), asn Q)\n 3. \\<And>D P.\n       \\<lbrakk>prov_sdia D P P;\n        prov_triple (asn P, com_sdia D, asn P)\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn P, com_cell (Loop_sdia P D P), asn P)\n 4. \\<And>\\<gamma> P Q F.\n       \\<lbrakk>prov_cell \\<gamma> P Q;\n        prov_triple (asn P, com_cell \\<gamma>, asn Q);\n        wr_cell \\<gamma> \\<inter> rd_int F = {}\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (P \\<otimes> F),\n                           com_cell (fst (\\<gamma>, F)),\n                           asn (Q \\<otimes> F))\n 5. \\<And>\\<Pi>.\n       \\<lbrakk>chain_all\n                 (\\<lambda>(P, \\<rho>, Q).\n                     prov_row \\<rho> P Q \\<and>\n                     prov_triple (asn P, com_cell (fst \\<rho>), asn Q))\n                 \\<Pi>;\n        0 < chainlen \\<Pi>\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (pre \\<Pi>),\n                           com_sdia (SDiagram (comlist \\<Pi>)),\n                           asn (post \\<Pi>))", "case (SExists D P Q x)"], ["proof (state)\nthis:\n  prov_sdia D P Q\n  prov_triple (asn P, com_sdia D, asn Q)\n\ngoal (5 subgoals):\n 1. \\<And>D P Q x.\n       \\<lbrakk>prov_sdia D P Q;\n        prov_triple (asn P, com_sdia D, asn Q)\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (Exists_int x P), com_cell (Exists_sdia x D),\n                           asn (Exists_int x Q))\n 2. \\<And>D P Q E.\n       \\<lbrakk>prov_sdia D P Q; prov_triple (asn P, com_sdia D, asn Q);\n        prov_sdia E P Q; prov_triple (asn P, com_sdia E, asn Q)\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn P, com_cell (Choose_sdia P D E Q), asn Q)\n 3. \\<And>D P.\n       \\<lbrakk>prov_sdia D P P;\n        prov_triple (asn P, com_sdia D, asn P)\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn P, com_cell (Loop_sdia P D P), asn P)\n 4. \\<And>\\<gamma> P Q F.\n       \\<lbrakk>prov_cell \\<gamma> P Q;\n        prov_triple (asn P, com_cell \\<gamma>, asn Q);\n        wr_cell \\<gamma> \\<inter> rd_int F = {}\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (P \\<otimes> F),\n                           com_cell (fst (\\<gamma>, F)),\n                           asn (Q \\<otimes> F))\n 5. \\<And>\\<Pi>.\n       \\<lbrakk>chain_all\n                 (\\<lambda>(P, \\<rho>, Q).\n                     prov_row \\<rho> P Q \\<and>\n                     prov_triple (asn P, com_cell (fst \\<rho>), asn Q))\n                 \\<Pi>;\n        0 < chainlen \\<Pi>\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (pre \\<Pi>),\n                           com_sdia (SDiagram (comlist \\<Pi>)),\n                           asn (post \\<Pi>))", "thus ?case"], ["proof (prove)\nusing this:\n  prov_sdia D P Q\n  prov_triple (asn P, com_sdia D, asn Q)\n\ngoal (1 subgoal):\n 1. prov_triple\n     (asn (Exists_int x P), com_cell (Exists_sdia x D),\n      asn (Exists_int x Q))", "by (auto simp add: prov_triple.exists)"], ["proof (state)\nthis:\n  prov_triple\n   (asn (Exists_int x P), com_cell (Exists_sdia x D), asn (Exists_int x Q))\n\ngoal (4 subgoals):\n 1. \\<And>D P Q E.\n       \\<lbrakk>prov_sdia D P Q; prov_triple (asn P, com_sdia D, asn Q);\n        prov_sdia E P Q; prov_triple (asn P, com_sdia E, asn Q)\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn P, com_cell (Choose_sdia P D E Q), asn Q)\n 2. \\<And>D P.\n       \\<lbrakk>prov_sdia D P P;\n        prov_triple (asn P, com_sdia D, asn P)\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn P, com_cell (Loop_sdia P D P), asn P)\n 3. \\<And>\\<gamma> P Q F.\n       \\<lbrakk>prov_cell \\<gamma> P Q;\n        prov_triple (asn P, com_cell \\<gamma>, asn Q);\n        wr_cell \\<gamma> \\<inter> rd_int F = {}\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (P \\<otimes> F),\n                           com_cell (fst (\\<gamma>, F)),\n                           asn (Q \\<otimes> F))\n 4. \\<And>\\<Pi>.\n       \\<lbrakk>chain_all\n                 (\\<lambda>(P, \\<rho>, Q).\n                     prov_row \\<rho> P Q \\<and>\n                     prov_triple (asn P, com_cell (fst \\<rho>), asn Q))\n                 \\<Pi>;\n        0 < chainlen \\<Pi>\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (pre \\<Pi>),\n                           com_sdia (SDiagram (comlist \\<Pi>)),\n                           asn (post \\<Pi>))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>D P Q E.\n       \\<lbrakk>prov_sdia D P Q; prov_triple (asn P, com_sdia D, asn Q);\n        prov_sdia E P Q; prov_triple (asn P, com_sdia E, asn Q)\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn P, com_cell (Choose_sdia P D E Q), asn Q)\n 2. \\<And>D P.\n       \\<lbrakk>prov_sdia D P P;\n        prov_triple (asn P, com_sdia D, asn P)\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn P, com_cell (Loop_sdia P D P), asn P)\n 3. \\<And>\\<gamma> P Q F.\n       \\<lbrakk>prov_cell \\<gamma> P Q;\n        prov_triple (asn P, com_cell \\<gamma>, asn Q);\n        wr_cell \\<gamma> \\<inter> rd_int F = {}\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (P \\<otimes> F),\n                           com_cell (fst (\\<gamma>, F)),\n                           asn (Q \\<otimes> F))\n 4. \\<And>\\<Pi>.\n       \\<lbrakk>chain_all\n                 (\\<lambda>(P, \\<rho>, Q).\n                     prov_row \\<rho> P Q \\<and>\n                     prov_triple (asn P, com_cell (fst \\<rho>), asn Q))\n                 \\<Pi>;\n        0 < chainlen \\<Pi>\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (pre \\<Pi>),\n                           com_sdia (SDiagram (comlist \\<Pi>)),\n                           asn (post \\<Pi>))", "case (SChoice D P Q E)"], ["proof (state)\nthis:\n  prov_sdia D P Q\n  prov_triple (asn P, com_sdia D, asn Q)\n  prov_sdia E P Q\n  prov_triple (asn P, com_sdia E, asn Q)\n\ngoal (4 subgoals):\n 1. \\<And>D P Q E.\n       \\<lbrakk>prov_sdia D P Q; prov_triple (asn P, com_sdia D, asn Q);\n        prov_sdia E P Q; prov_triple (asn P, com_sdia E, asn Q)\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn P, com_cell (Choose_sdia P D E Q), asn Q)\n 2. \\<And>D P.\n       \\<lbrakk>prov_sdia D P P;\n        prov_triple (asn P, com_sdia D, asn P)\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn P, com_cell (Loop_sdia P D P), asn P)\n 3. \\<And>\\<gamma> P Q F.\n       \\<lbrakk>prov_cell \\<gamma> P Q;\n        prov_triple (asn P, com_cell \\<gamma>, asn Q);\n        wr_cell \\<gamma> \\<inter> rd_int F = {}\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (P \\<otimes> F),\n                           com_cell (fst (\\<gamma>, F)),\n                           asn (Q \\<otimes> F))\n 4. \\<And>\\<Pi>.\n       \\<lbrakk>chain_all\n                 (\\<lambda>(P, \\<rho>, Q).\n                     prov_row \\<rho> P Q \\<and>\n                     prov_triple (asn P, com_cell (fst \\<rho>), asn Q))\n                 \\<Pi>;\n        0 < chainlen \\<Pi>\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (pre \\<Pi>),\n                           com_sdia (SDiagram (comlist \\<Pi>)),\n                           asn (post \\<Pi>))", "thus ?case"], ["proof (prove)\nusing this:\n  prov_sdia D P Q\n  prov_triple (asn P, com_sdia D, asn Q)\n  prov_sdia E P Q\n  prov_triple (asn P, com_sdia E, asn Q)\n\ngoal (1 subgoal):\n 1. prov_triple (asn P, com_cell (Choose_sdia P D E Q), asn Q)", "by (auto simp add: prov_triple.choose)"], ["proof (state)\nthis:\n  prov_triple (asn P, com_cell (Choose_sdia P D E Q), asn Q)\n\ngoal (3 subgoals):\n 1. \\<And>D P.\n       \\<lbrakk>prov_sdia D P P;\n        prov_triple (asn P, com_sdia D, asn P)\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn P, com_cell (Loop_sdia P D P), asn P)\n 2. \\<And>\\<gamma> P Q F.\n       \\<lbrakk>prov_cell \\<gamma> P Q;\n        prov_triple (asn P, com_cell \\<gamma>, asn Q);\n        wr_cell \\<gamma> \\<inter> rd_int F = {}\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (P \\<otimes> F),\n                           com_cell (fst (\\<gamma>, F)),\n                           asn (Q \\<otimes> F))\n 3. \\<And>\\<Pi>.\n       \\<lbrakk>chain_all\n                 (\\<lambda>(P, \\<rho>, Q).\n                     prov_row \\<rho> P Q \\<and>\n                     prov_triple (asn P, com_cell (fst \\<rho>), asn Q))\n                 \\<Pi>;\n        0 < chainlen \\<Pi>\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (pre \\<Pi>),\n                           com_sdia (SDiagram (comlist \\<Pi>)),\n                           asn (post \\<Pi>))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>D P.\n       \\<lbrakk>prov_sdia D P P;\n        prov_triple (asn P, com_sdia D, asn P)\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn P, com_cell (Loop_sdia P D P), asn P)\n 2. \\<And>\\<gamma> P Q F.\n       \\<lbrakk>prov_cell \\<gamma> P Q;\n        prov_triple (asn P, com_cell \\<gamma>, asn Q);\n        wr_cell \\<gamma> \\<inter> rd_int F = {}\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (P \\<otimes> F),\n                           com_cell (fst (\\<gamma>, F)),\n                           asn (Q \\<otimes> F))\n 3. \\<And>\\<Pi>.\n       \\<lbrakk>chain_all\n                 (\\<lambda>(P, \\<rho>, Q).\n                     prov_row \\<rho> P Q \\<and>\n                     prov_triple (asn P, com_cell (fst \\<rho>), asn Q))\n                 \\<Pi>;\n        0 < chainlen \\<Pi>\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (pre \\<Pi>),\n                           com_sdia (SDiagram (comlist \\<Pi>)),\n                           asn (post \\<Pi>))", "case (SLoop D P)"], ["proof (state)\nthis:\n  prov_sdia D P P\n  prov_triple (asn P, com_sdia D, asn P)\n\ngoal (3 subgoals):\n 1. \\<And>D P.\n       \\<lbrakk>prov_sdia D P P;\n        prov_triple (asn P, com_sdia D, asn P)\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn P, com_cell (Loop_sdia P D P), asn P)\n 2. \\<And>\\<gamma> P Q F.\n       \\<lbrakk>prov_cell \\<gamma> P Q;\n        prov_triple (asn P, com_cell \\<gamma>, asn Q);\n        wr_cell \\<gamma> \\<inter> rd_int F = {}\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (P \\<otimes> F),\n                           com_cell (fst (\\<gamma>, F)),\n                           asn (Q \\<otimes> F))\n 3. \\<And>\\<Pi>.\n       \\<lbrakk>chain_all\n                 (\\<lambda>(P, \\<rho>, Q).\n                     prov_row \\<rho> P Q \\<and>\n                     prov_triple (asn P, com_cell (fst \\<rho>), asn Q))\n                 \\<Pi>;\n        0 < chainlen \\<Pi>\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (pre \\<Pi>),\n                           com_sdia (SDiagram (comlist \\<Pi>)),\n                           asn (post \\<Pi>))", "thus ?case"], ["proof (prove)\nusing this:\n  prov_sdia D P P\n  prov_triple (asn P, com_sdia D, asn P)\n\ngoal (1 subgoal):\n 1. prov_triple (asn P, com_cell (Loop_sdia P D P), asn P)", "by (auto simp add: prov_triple.loop)"], ["proof (state)\nthis:\n  prov_triple (asn P, com_cell (Loop_sdia P D P), asn P)\n\ngoal (2 subgoals):\n 1. \\<And>\\<gamma> P Q F.\n       \\<lbrakk>prov_cell \\<gamma> P Q;\n        prov_triple (asn P, com_cell \\<gamma>, asn Q);\n        wr_cell \\<gamma> \\<inter> rd_int F = {}\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (P \\<otimes> F),\n                           com_cell (fst (\\<gamma>, F)),\n                           asn (Q \\<otimes> F))\n 2. \\<And>\\<Pi>.\n       \\<lbrakk>chain_all\n                 (\\<lambda>(P, \\<rho>, Q).\n                     prov_row \\<rho> P Q \\<and>\n                     prov_triple (asn P, com_cell (fst \\<rho>), asn Q))\n                 \\<Pi>;\n        0 < chainlen \\<Pi>\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (pre \\<Pi>),\n                           com_sdia (SDiagram (comlist \\<Pi>)),\n                           asn (post \\<Pi>))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<gamma> P Q F.\n       \\<lbrakk>prov_cell \\<gamma> P Q;\n        prov_triple (asn P, com_cell \\<gamma>, asn Q);\n        wr_cell \\<gamma> \\<inter> rd_int F = {}\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (P \\<otimes> F),\n                           com_cell (fst (\\<gamma>, F)),\n                           asn (Q \\<otimes> F))\n 2. \\<And>\\<Pi>.\n       \\<lbrakk>chain_all\n                 (\\<lambda>(P, \\<rho>, Q).\n                     prov_row \\<rho> P Q \\<and>\n                     prov_triple (asn P, com_cell (fst \\<rho>), asn Q))\n                 \\<Pi>;\n        0 < chainlen \\<Pi>\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (pre \\<Pi>),\n                           com_sdia (SDiagram (comlist \\<Pi>)),\n                           asn (post \\<Pi>))", "case (SRow \\<gamma> P Q F)"], ["proof (state)\nthis:\n  prov_cell \\<gamma> P Q\n  prov_triple (asn P, com_cell \\<gamma>, asn Q)\n  wr_cell \\<gamma> \\<inter> rd_int F = {}\n\ngoal (2 subgoals):\n 1. \\<And>\\<gamma> P Q F.\n       \\<lbrakk>prov_cell \\<gamma> P Q;\n        prov_triple (asn P, com_cell \\<gamma>, asn Q);\n        wr_cell \\<gamma> \\<inter> rd_int F = {}\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (P \\<otimes> F),\n                           com_cell (fst (\\<gamma>, F)),\n                           asn (Q \\<otimes> F))\n 2. \\<And>\\<Pi>.\n       \\<lbrakk>chain_all\n                 (\\<lambda>(P, \\<rho>, Q).\n                     prov_row \\<rho> P Q \\<and>\n                     prov_triple (asn P, com_cell (fst \\<rho>), asn Q))\n                 \\<Pi>;\n        0 < chainlen \\<Pi>\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (pre \\<Pi>),\n                           com_sdia (SDiagram (comlist \\<Pi>)),\n                           asn (post \\<Pi>))", "thus ?case"], ["proof (prove)\nusing this:\n  prov_cell \\<gamma> P Q\n  prov_triple (asn P, com_cell \\<gamma>, asn Q)\n  wr_cell \\<gamma> \\<inter> rd_int F = {}\n\ngoal (1 subgoal):\n 1. prov_triple\n     (asn (P \\<otimes> F), com_cell (fst (\\<gamma>, F)),\n      asn (Q \\<otimes> F))", "by (simp add: prov_triple.frame rd_int_is_rd_ass wr_sdia_is_wr_com(2))"], ["proof (state)\nthis:\n  prov_triple\n   (asn (P \\<otimes> F), com_cell (fst (\\<gamma>, F)), asn (Q \\<otimes> F))\n\ngoal (1 subgoal):\n 1. \\<And>\\<Pi>.\n       \\<lbrakk>chain_all\n                 (\\<lambda>(P, \\<rho>, Q).\n                     prov_row \\<rho> P Q \\<and>\n                     prov_triple (asn P, com_cell (fst \\<rho>), asn Q))\n                 \\<Pi>;\n        0 < chainlen \\<Pi>\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (pre \\<Pi>),\n                           com_sdia (SDiagram (comlist \\<Pi>)),\n                           asn (post \\<Pi>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<Pi>.\n       \\<lbrakk>chain_all\n                 (\\<lambda>(P, \\<rho>, Q).\n                     prov_row \\<rho> P Q \\<and>\n                     prov_triple (asn P, com_cell (fst \\<rho>), asn Q))\n                 \\<Pi>;\n        0 < chainlen \\<Pi>\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (pre \\<Pi>),\n                           com_sdia (SDiagram (comlist \\<Pi>)),\n                           asn (post \\<Pi>))", "case (SMain \\<Pi>)"], ["proof (state)\nthis:\n  chain_all\n   (\\<lambda>(P, \\<rho>, Q).\n       prov_row \\<rho> P Q \\<and>\n       prov_triple (asn P, com_cell (fst \\<rho>), asn Q))\n   \\<Pi>\n  0 < chainlen \\<Pi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<Pi>.\n       \\<lbrakk>chain_all\n                 (\\<lambda>(P, \\<rho>, Q).\n                     prov_row \\<rho> P Q \\<and>\n                     prov_triple (asn P, com_cell (fst \\<rho>), asn Q))\n                 \\<Pi>;\n        0 < chainlen \\<Pi>\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (pre \\<Pi>),\n                           com_sdia (SDiagram (comlist \\<Pi>)),\n                           asn (post \\<Pi>))", "thus ?case"], ["proof (prove)\nusing this:\n  chain_all\n   (\\<lambda>(P, \\<rho>, Q).\n       prov_row \\<rho> P Q \\<and>\n       prov_triple (asn P, com_cell (fst \\<rho>), asn Q))\n   \\<Pi>\n  0 < chainlen \\<Pi>\n\ngoal (1 subgoal):\n 1. prov_triple\n     (asn (pre \\<Pi>), com_sdia (SDiagram (comlist \\<Pi>)),\n      asn (post \\<Pi>))", "apply (unfold com_sdia.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>chain_all\n              (\\<lambda>(P, \\<rho>, Q).\n                  prov_row \\<rho> P Q \\<and>\n                  prov_triple (asn P, com_cell (fst \\<rho>), asn Q))\n              \\<Pi>;\n     0 < chainlen \\<Pi>\\<rbrakk>\n    \\<Longrightarrow> prov_triple\n                       (asn (pre \\<Pi>),\n                        foldr (;;)\n                         (map (com_cell \\<circ> fst) (comlist \\<Pi>)) Skip,\n                        asn (post \\<Pi>))", "apply (intro seq_fold[of _ \\<Pi>])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>chain_all\n              (\\<lambda>(P, \\<rho>, Q).\n                  prov_row \\<rho> P Q \\<and>\n                  prov_triple (asn P, com_cell (fst \\<rho>), asn Q))\n              \\<Pi>;\n     0 < chainlen \\<Pi>\\<rbrakk>\n    \\<Longrightarrow> length (map (com_cell \\<circ> fst) (comlist \\<Pi>)) =\n                      chainlen \\<Pi>\n 2. \\<lbrakk>chain_all\n              (\\<lambda>(P, \\<rho>, Q).\n                  prov_row \\<rho> P Q \\<and>\n                  prov_triple (asn P, com_cell (fst \\<rho>), asn Q))\n              \\<Pi>;\n     0 < chainlen \\<Pi>\\<rbrakk>\n    \\<Longrightarrow> asn (pre \\<Pi>) = asn (pre \\<Pi>)\n 3. \\<lbrakk>chain_all\n              (\\<lambda>(P, \\<rho>, Q).\n                  prov_row \\<rho> P Q \\<and>\n                  prov_triple (asn P, com_cell (fst \\<rho>), asn Q))\n              \\<Pi>;\n     0 < chainlen \\<Pi>\\<rbrakk>\n    \\<Longrightarrow> asn (post \\<Pi>) = asn (post \\<Pi>)\n 4. \\<And>i.\n       \\<lbrakk>chain_all\n                 (\\<lambda>(P, \\<rho>, Q).\n                     prov_row \\<rho> P Q \\<and>\n                     prov_triple (asn P, com_cell (fst \\<rho>), asn Q))\n                 \\<Pi>;\n        0 < chainlen \\<Pi>; i < chainlen \\<Pi>\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (fst3 (nthtriple \\<Pi> i)),\n                           map (com_cell \\<circ> fst) (comlist \\<Pi>) ! i,\n                           asn (thd3 (nthtriple \\<Pi> i)))", "apply (simp_all add: len_comlist_chainlen)[3]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>chain_all\n                 (\\<lambda>(P, \\<rho>, Q).\n                     prov_row \\<rho> P Q \\<and>\n                     prov_triple (asn P, com_cell (fst \\<rho>), asn Q))\n                 \\<Pi>;\n        0 < chainlen \\<Pi>; i < chainlen \\<Pi>\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (fst3 (nthtriple \\<Pi> i)),\n                           map (com_cell \\<circ> fst) (comlist \\<Pi>) ! i,\n                           asn (thd3 (nthtriple \\<Pi> i)))", "apply (induct \\<Pi>, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2 \\<Pi> i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>chain_all\n                             (\\<lambda>(P, \\<rho>, Q).\n                                 prov_row \\<rho> P Q \\<and>\n                                 prov_triple\n                                  (asn P, com_cell (fst \\<rho>), asn Q))\n                             \\<Pi>;\n                    0 < chainlen \\<Pi>; i < chainlen \\<Pi>\\<rbrakk>\n                   \\<Longrightarrow> prov_triple\n(asn (fst3 (nthtriple \\<Pi> i)),\n map (com_cell \\<circ> fst) (comlist \\<Pi>) ! i,\n asn (thd3 (nthtriple \\<Pi> i)));\n        chain_all\n         (\\<lambda>(P, \\<rho>, Q).\n             prov_row \\<rho> P Q \\<and>\n             prov_triple (asn P, com_cell (fst \\<rho>), asn Q))\n         (\\<lbrace> x1a \\<rbrace> \\<cdot> x2 \\<cdot> \\<Pi>);\n        0 < chainlen (\\<lbrace> x1a \\<rbrace> \\<cdot> x2 \\<cdot> \\<Pi>);\n        i < chainlen\n             (\\<lbrace> x1a \\<rbrace> \\<cdot> x2 \\<cdot> \\<Pi>)\\<rbrakk>\n       \\<Longrightarrow> prov_triple\n                          (asn (fst3\n                                 (nthtriple\n                                   (\\<lbrace> x1a \\<rbrace> \\<cdot> x2 \\<cdot> \\<Pi>)\n                                   i)),\n                           map (com_cell \\<circ> fst)\n                            (comlist\n                              (\\<lbrace> x1a \\<rbrace> \\<cdot> x2 \\<cdot> \\<Pi>)) !\n                           i,\n                           asn (thd3\n                                 (nthtriple\n                                   (\\<lbrace> x1a \\<rbrace> \\<cdot> x2 \\<cdot> \\<Pi>)\n                                   i)))", "apply (case_tac i, auto simp add: fst3_simp thd3_simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  prov_triple\n   (asn (pre \\<Pi>), com_sdia (SDiagram (comlist \\<Pi>)), asn (post \\<Pi>))\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary soundness_strat:\n  assumes \"prov_sdia D P Q\"\n  shows \"prov_triple (asn P, com_sdia D, asn Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prov_triple (asn P, com_sdia D, asn Q)", "using assms soundness_strat_helper"], ["proof (prove)\nusing this:\n  prov_sdia D P Q\n  (prov_sdia ?D ?P ?Q \\<longrightarrow>\n   prov_triple (asn ?P, com_sdia ?D, asn ?Q)) \\<and>\n  (prov_row ?\\<rho> ?P ?Q \\<longrightarrow>\n   prov_triple (asn ?P, com_cell (fst ?\\<rho>), asn ?Q)) \\<and>\n  (prov_cell ?\\<gamma> ?P ?Q \\<longrightarrow>\n   prov_triple (asn ?P, com_cell ?\\<gamma>, asn ?Q))\n\ngoal (1 subgoal):\n 1. prov_triple (asn P, com_sdia D, asn Q)", "by auto"], ["", "end"]]}