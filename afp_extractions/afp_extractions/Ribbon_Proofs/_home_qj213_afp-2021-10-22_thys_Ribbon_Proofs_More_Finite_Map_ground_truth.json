{"file_name": "/home/qj213/afp-2021-10-22/thys/Ribbon_Proofs/More_Finite_Map.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Ribbon_Proofs", "problem_names": ["lemma make_map_transfer[transfer_rule]: \"(rel_fset (=) ===> A ===> rel_map A) make_map make_map\"", "lemma dom_make_map:\n  \"dom (make_map ks v) = fset ks\"", "lemma make_fmap_empty[simp]: \"[ {||} |=> f ] = fmempty\"", "lemma fmap_add_commute:\n  assumes \"fmdom A |\\<inter>| fmdom B = {||}\"\n  shows \"A ++\\<^sub>f B = B ++\\<^sub>f A\"", "lemma make_fmap_union:\n  \"[ xs |=> v ] ++\\<^sub>f [ ys |=> v] = [ xs |\\<union>| ys |=> v ]\"", "lemma fdom_make_fmap: \"fmdom [ ks |=> v ] = ks\"", "lemma lookup_make_fmap:\n  assumes \"k \\<in> fset ks\"\n  shows \"lookup [ ks |=> v ] k = v\"", "lemma lookup_make_fmap1:\n  \"lookup [ {|k|} |=> v ] k = v\"", "lemma lookup_union1:\n  assumes \"k |\\<in>| fmdom ys\"\n  shows \"lookup (xs ++\\<^sub>f ys) k = lookup ys k\"", "lemma lookup_union2:\n  assumes \"k |\\<notin>| fmdom ys\"\n  shows \"lookup (xs ++\\<^sub>f ys) k = lookup xs k\"", "lemma lookup_union3:\n  assumes \"k |\\<notin>| fmdom xs\"\n  shows \"lookup (xs ++\\<^sub>f ys) k = lookup ys k\""], "translations": [["", "lemma make_map_transfer[transfer_rule]: \"(rel_fset (=) ===> A ===> rel_map A) make_map make_map\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_fset (=) ===> A ===> rel_map A) make_map make_map", "unfolding make_map_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_fset (=) ===> A ===> rel_map A)\n     (\\<lambda>ks v k. if k \\<in> fset ks then Some v else None)\n     (\\<lambda>ks v k. if k \\<in> fset ks then Some v else None)", "by transfer_prover"], ["", "lemma dom_make_map:\n  \"dom (make_map ks v) = fset ks\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (make_map ks v) = fset ks", "by (metis domIff make_map_def not_Some_eq set_eqI)"], ["", "lift_definition\n  make_fmap :: \"'k fset \\<Rightarrow> 'v \\<Rightarrow> ('k \\<rightharpoonup>\\<^sub>f 'v)\" (\"[ _ |=> _ ]\")\nis \"make_map\" parametric make_map_transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fset v. finite (dom (make_map fset v))", "by (unfold make_map_def dom_def, auto)"], ["", "lemma make_fmap_empty[simp]: \"[ {||} |=> f ] = fmempty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [ {||} |=> f ] = fmempty", "by transfer (simp add: make_map_def)"], ["", "subsection \\<open>Domain\\<close>"], ["", "lemma fmap_add_commute:\n  assumes \"fmdom A |\\<inter>| fmdom B = {||}\"\n  shows \"A ++\\<^sub>f B = B ++\\<^sub>f A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A ++\\<^sub>f B = B ++\\<^sub>f A", "using assms"], ["proof (prove)\nusing this:\n  fmdom A |\\<inter>| fmdom B = {||}\n\ngoal (1 subgoal):\n 1. A ++\\<^sub>f B = B ++\\<^sub>f A", "including fset.lifting"], ["proof (prove)\nusing this:\n  fmdom A |\\<inter>| fmdom B = {||}\n\ngoal (1 subgoal):\n 1. A ++\\<^sub>f B = B ++\\<^sub>f A", "apply (transfer)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A B.\n       \\<lbrakk>finite (dom A); finite (dom B);\n        dom A \\<inter> dom B = {}\\<rbrakk>\n       \\<Longrightarrow> A ++ B = B ++ A", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A B x.\n       \\<lbrakk>finite (dom A); finite (dom B);\n        dom A \\<inter> dom B = {}\\<rbrakk>\n       \\<Longrightarrow> (A ++ B) x = (B ++ A) x", "apply (auto simp: dom_def map_add_def split: option.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma make_fmap_union:\n  \"[ xs |=> v ] ++\\<^sub>f [ ys |=> v] = [ xs |\\<union>| ys |=> v ]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [ xs |=> v ] ++\\<^sub>f [ ys |=> v ] = [ xs |\\<union>| ys |=> v ]", "by (transfer, auto simp add: make_map_def map_add_def)"], ["", "lemma fdom_make_fmap: \"fmdom [ ks |=> v ] = ks\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmdom [ ks |=> v ] = ks", "(* FIXME proper transfer proof *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmdom [ ks |=> v ] = ks", "apply (subst fmdom_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (fmlookup ---> Abs_fset) dom [ ks |=> v ] = ks", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ks v. ((\\<lambda>x. x) ---> Abs_fset) dom (make_map ks v) = ks", "apply (auto simp: dom_def make_map_def fset_inverse)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Lookup\\<close>"], ["", "lift_definition\n  lookup :: \"('k \\<rightharpoonup>\\<^sub>f 'v) \\<Rightarrow> 'k \\<Rightarrow> 'v\"\nis \"(\\<circ>) the\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma lookup_make_fmap:\n  assumes \"k \\<in> fset ks\"\n  shows \"lookup [ ks |=> v ] k = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup [ ks |=> v ] k = v", "using assms"], ["proof (prove)\nusing this:\n  k \\<in> fset ks\n\ngoal (1 subgoal):\n 1. lookup [ ks |=> v ] k = v", "by (transfer, simp add: make_map_def)"], ["", "lemma lookup_make_fmap1:\n  \"lookup [ {|k|} |=> v ] k = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup [ {|k|} |=> v ] k = v", "by (metis finsert.rep_eq insert_iff lookup_make_fmap)"], ["", "lemma lookup_union1:\n  assumes \"k |\\<in>| fmdom ys\"\n  shows \"lookup (xs ++\\<^sub>f ys) k = lookup ys k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (xs ++\\<^sub>f ys) k = lookup ys k", "using assms"], ["proof (prove)\nusing this:\n  k |\\<in>| fmdom ys\n\ngoal (1 subgoal):\n 1. lookup (xs ++\\<^sub>f ys) k = lookup ys k", "including fset.lifting"], ["proof (prove)\nusing this:\n  k |\\<in>| fmdom ys\n\ngoal (1 subgoal):\n 1. lookup (xs ++\\<^sub>f ys) k = lookup ys k", "by transfer auto"], ["", "lemma lookup_union2:\n  assumes \"k |\\<notin>| fmdom ys\"\n  shows \"lookup (xs ++\\<^sub>f ys) k = lookup xs k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (xs ++\\<^sub>f ys) k = lookup xs k", "using assms"], ["proof (prove)\nusing this:\n  k |\\<notin>| fmdom ys\n\ngoal (1 subgoal):\n 1. lookup (xs ++\\<^sub>f ys) k = lookup xs k", "including fset.lifting"], ["proof (prove)\nusing this:\n  k |\\<notin>| fmdom ys\n\ngoal (1 subgoal):\n 1. lookup (xs ++\\<^sub>f ys) k = lookup xs k", "by transfer (auto simp: map_add_def split: option.splits)"], ["", "lemma lookup_union3:\n  assumes \"k |\\<notin>| fmdom xs\"\n  shows \"lookup (xs ++\\<^sub>f ys) k = lookup ys k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (xs ++\\<^sub>f ys) k = lookup ys k", "using assms"], ["proof (prove)\nusing this:\n  k |\\<notin>| fmdom xs\n\ngoal (1 subgoal):\n 1. lookup (xs ++\\<^sub>f ys) k = lookup ys k", "including fset.lifting"], ["proof (prove)\nusing this:\n  k |\\<notin>| fmdom xs\n\ngoal (1 subgoal):\n 1. lookup (xs ++\\<^sub>f ys) k = lookup ys k", "by transfer (auto simp: map_add_def split: option.splits)"], ["", "end"]]}