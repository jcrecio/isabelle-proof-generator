{"file_name": "/home/qj213/afp-2021-10-22/thys/PSemigroupsConvolution/Partial_Semigroups.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/PSemigroupsConvolution", "problem_names": ["lemma add_assocD_var1: \"D y z \\<and> D x (y \\<cdot> z) \\<Longrightarrow> D x y \\<and> D (x \\<cdot> y) z\"", "lemma add_assocD_var2: \" D x y \\<and> D (x \\<cdot> y) z \\<Longrightarrow> D y z \\<and> D x (y \\<cdot> z)\"", "lemma add_assoc_var: \" D y z \\<and> D x (y \\<cdot> z) \\<Longrightarrow> (x \\<cdot> y) \\<cdot> z = x \\<cdot> (y \\<cdot> z)\"", "lemma \"x \\<preceq>\\<^sub>R x\"", "lemma gR_rel_trans: \"x \\<preceq>\\<^sub>R y \\<Longrightarrow> y \\<preceq>\\<^sub>R z \\<Longrightarrow> x \\<preceq>\\<^sub>R z\"", "lemma gL_rel_trans: \"x \\<preceq>\\<^sub>L y \\<Longrightarrow> y \\<preceq>\\<^sub>L z \\<Longrightarrow> x \\<preceq>\\<^sub>L z\"", "lemma gR_add_isol: \"D z y \\<Longrightarrow> x \\<preceq>\\<^sub>R y \\<Longrightarrow> z \\<cdot> x \\<preceq>\\<^sub>R z \\<cdot> y\"", "lemma gL_add_isor: \"D y z \\<Longrightarrow> x \\<preceq>\\<^sub>L y \\<Longrightarrow> x \\<cdot> z \\<preceq>\\<^sub>L y \\<cdot> z\"", "lemma unique_resl: \"D x z \\<Longrightarrow> D x z' \\<Longrightarrow> x \\<cdot> z = y \\<Longrightarrow> x \\<cdot> z' = y \\<Longrightarrow> z = z'\"", "lemma unique_resr: \"D z x \\<Longrightarrow> D z' x  \\<Longrightarrow> z \\<cdot> x = y \\<Longrightarrow> z' \\<cdot> x = y \\<Longrightarrow> z = z'\"", "lemma gR_rel_mult: \"D x y \\<Longrightarrow> x \\<preceq>\\<^sub>R x \\<cdot> y\"", "lemma gL_rel_mult: \"D x y \\<Longrightarrow> y \\<preceq>\\<^sub>L x \\<cdot> y\"", "lemma quotr_unique: \"x \\<preceq>\\<^sub>R y  \\<Longrightarrow> (\\<exists>!z. D x z \\<and> y = x \\<cdot> z)\"", "lemma quotl_unique: \"x \\<preceq>\\<^sub>L y \\<Longrightarrow> (\\<exists>!z. D z x \\<and> y = z \\<cdot> x)\"", "lemma rquot_prop: \"D x z \\<and> y = x \\<cdot> z \\<Longrightarrow> z = rquot y x\"", "lemma rquot_mult: \"x \\<preceq>\\<^sub>R y \\<Longrightarrow> z = rquot y x \\<Longrightarrow> x \\<cdot> z = y\"", "lemma rquot_D: \"x \\<preceq>\\<^sub>R y \\<Longrightarrow> z = rquot y x \\<Longrightarrow> D x z\"", "lemma add_rquot: \"x \\<preceq>\\<^sub>R y \\<Longrightarrow> (D x z \\<and> x \\<oplus> z = y \\<longleftrightarrow> z = rquot y x)\"", "lemma add_canc1: \"D x y \\<Longrightarrow> rquot (x \\<cdot> y) x = y\"", "lemma add_canc2: \"x \\<preceq>\\<^sub>R y \\<Longrightarrow> x \\<cdot> (rquot y x) = y\"", "lemma add_canc2_prop: \"x \\<preceq>\\<^sub>R y \\<Longrightarrow> rquot y x \\<preceq>\\<^sub>L y\"", "lemma gR_galois_imp1: \"D x z \\<Longrightarrow> x \\<cdot> z \\<preceq>\\<^sub>R y \\<Longrightarrow> z \\<preceq>\\<^sub>R rquot y x\"", "lemma gR_galois_imp21: \"x \\<preceq>\\<^sub>R y \\<Longrightarrow> z \\<preceq>\\<^sub>R rquot y x \\<Longrightarrow> x \\<cdot> z \\<preceq>\\<^sub>R y\"", "lemma gR_galois_imp22: \"x \\<preceq>\\<^sub>R y \\<Longrightarrow> z \\<preceq>\\<^sub>R rquot y x \\<Longrightarrow> D x z\"", "lemma gR_galois: \"x \\<preceq>\\<^sub>R y \\<Longrightarrow> (D x z \\<and> x \\<cdot> z \\<preceq>\\<^sub>R y \\<longleftrightarrow> z \\<preceq>\\<^sub>R rquot y x)\"", "lemma gR_rel_defined: \"x \\<preceq>\\<^sub>R y \\<Longrightarrow> D x (rquot y x)\"", "lemma ex_add_galois: \"D x z \\<Longrightarrow> (\\<exists>y. x \\<cdot> z = y \\<longleftrightarrow> rquot y x = z)\"", "lemma units_eq_var: \"e1 \\<in> E \\<Longrightarrow> e2 \\<in> E \\<Longrightarrow> e1 \\<noteq> e2 \\<Longrightarrow> \\<not> D e1 e2\"", "lemma \"x \\<preceq>\\<^sub>R y \\<Longrightarrow> y \\<preceq>\\<^sub>R x \\<Longrightarrow> x = y\"", "lemma \"annil x \\<Longrightarrow> annil y \\<Longrightarrow> x = y\"", "lemma  \"annir x \\<Longrightarrow> annir y \\<Longrightarrow> x = y\"", "lemma canc_unitr: \"D x e \\<Longrightarrow> x \\<cdot> e = x \\<Longrightarrow> e \\<in> E\"", "lemma canc_unitl: \"D e x \\<Longrightarrow> e \\<cdot> x = x \\<Longrightarrow> e \\<in> E\"", "lemma pos_unitl: \"D x y \\<Longrightarrow> e \\<in> E \\<Longrightarrow> x \\<cdot> y = e \\<Longrightarrow> x = e\"", "lemma pos_unitr: \"D x y \\<Longrightarrow> e \\<in> E \\<Longrightarrow> x \\<cdot> y = e \\<Longrightarrow> y = e\"", "lemma D_comm: \"D x y \\<longleftrightarrow> D y x\"", "lemma add_comm': \"D x y \\<Longrightarrow> x \\<oplus> y = y \\<oplus> x\"", "lemma gL_gH_rel: \"(x \\<preceq>\\<^sub>L y) = (x \\<preceq>\\<^sub>H y)\"", "lemma gR_gH_rel: \"(x \\<preceq>\\<^sub>R y) = (x \\<preceq>\\<^sub>H y)\"", "lemma annilr: \"annil x = annir x\"", "lemma anni_unique: \"annil x \\<Longrightarrow> annil y \\<Longrightarrow> x = y\"", "lemma E_eq_one: \"E = {1}\"", "lemma one_in_E: \"1 \\<in> E\"", "lemma prod_div1: \"(x1::'a, y1::'b::pas) \\<preceq>\\<^sub>R (x2::'a, y2::'b::pas) \\<Longrightarrow> x1 = x2\"", "lemma prod_div2: \"(x1, y1) \\<preceq>\\<^sub>R (x2, y2) \\<Longrightarrow> y1 \\<preceq>\\<^sub>R y2\"", "lemma prod_div_eq: \"(x1, y1) \\<preceq>\\<^sub>R (x2, y2) \\<longleftrightarrow> x1 = x2 \\<and> y1 \\<preceq>\\<^sub>R y2\"", "lemma prod_res_eq: \"(x1, y1) \\<preceq>\\<^sub>R (x2::'a,y2::'b::cancellative_pam) \n    \\<Longrightarrow> rquot (x2, y2) (x1, y1) = (x1, rquot y2 y1)\""], "translations": [["", "lemma add_assocD_var1: \"D y z \\<and> D x (y \\<cdot> z) \\<Longrightarrow> D x y \\<and> D (x \\<cdot> y) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D y z \\<and> D x (y \\<oplus> z) \\<Longrightarrow>\n    D x y \\<and> D (x \\<oplus> y) z", "by (simp add: add_assocD)"], ["", "lemma add_assocD_var2: \" D x y \\<and> D (x \\<cdot> y) z \\<Longrightarrow> D y z \\<and> D x (y \\<cdot> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D x y \\<and> D (x \\<oplus> y) z \\<Longrightarrow>\n    D y z \\<and> D x (y \\<oplus> z)", "by (simp add: add_assocD)"], ["", "lemma add_assoc_var: \" D y z \\<and> D x (y \\<cdot> z) \\<Longrightarrow> (x \\<cdot> y) \\<cdot> z = x \\<cdot> (y \\<cdot> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D y z \\<and> D x (y \\<oplus> z) \\<Longrightarrow>\n    x \\<oplus> y \\<oplus> z = x \\<oplus> (y \\<oplus> z)", "by (simp add: add_assoc add_assocD)"], ["", "subsection \\<open>Green's Preorders and Green's Relations\\<close>"], ["", "text \\<open>We define the standard Green's preorders and Green's relations. They are usually defined on monoids. \n  On (partial) semigroups, we only obtain transitive relations.\\<close>"], ["", "definition gR_rel :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" (infix \"\\<preceq>\\<^sub>R\" 50) where\n  \"x \\<preceq>\\<^sub>R y = (\\<exists>z. D x z \\<and> x \\<cdot> z = y)\""], ["", "definition strict_gR_rel :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" (infix \"\\<prec>\\<^sub>R\" 50) where\n  \"x \\<prec>\\<^sub>R y = (x \\<preceq>\\<^sub>R y \\<and> \\<not> y \\<preceq>\\<^sub>R x)\""], ["", "definition gL_rel :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" (infix \"\\<preceq>\\<^sub>L\" 50) where\n  \"x \\<preceq>\\<^sub>L y = (\\<exists>z. D z x \\<and> z \\<cdot> x = y)\""], ["", "definition strict_gL_rel :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" (infix \"\\<prec>\\<^sub>L\" 50) where\n  \"x \\<prec>\\<^sub>L y = (x \\<preceq>\\<^sub>L y \\<and> \\<not> y \\<preceq>\\<^sub>L x)\""], ["", "definition gH_rel :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" (infix \"\\<preceq>\\<^sub>H\" 50) where\n  \"x \\<preceq>\\<^sub>H y = (x \\<preceq>\\<^sub>L y \\<and> x \\<preceq>\\<^sub>R y)\""], ["", "definition gJ_rel :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" (infix \"\\<preceq>\\<^sub>J\" 50) where\n  \"x \\<preceq>\\<^sub>J y = (\\<exists>v w. D v x \\<and> D (v \\<cdot> x) w \\<and> (v \\<cdot> x) \\<cdot> w = y)\""], ["", "definition \"gR x y = (x \\<preceq>\\<^sub>R y \\<and> y \\<preceq>\\<^sub>R x)\""], ["", "definition \"gL x y = (x \\<preceq>\\<^sub>L y \\<and> y \\<preceq>\\<^sub>L x)\""], ["", "definition \"gH x y = (x \\<preceq>\\<^sub>H y \\<and> y \\<preceq>\\<^sub>H x)\""], ["", "definition \"gJ x y = (x \\<preceq>\\<^sub>J y \\<and> y \\<preceq>\\<^sub>J x)\""], ["", "definition gR_downset :: \"'a \\<Rightarrow> 'a set\" (\"_\\<down>\" [100]100) where\n  \"x\\<down> \\<equiv> {y. y \\<preceq>\\<^sub>R x}\""], ["", "text \\<open>The following counterexample rules out reflexivity.\\<close>"], ["", "lemma \"x \\<preceq>\\<^sub>R x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<preceq>\\<^sub>R x", "(* nitpick [expect=genuine] *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<preceq>\\<^sub>R x", "oops"], ["", "lemma gR_rel_trans: \"x \\<preceq>\\<^sub>R y \\<Longrightarrow> y \\<preceq>\\<^sub>R z \\<Longrightarrow> x \\<preceq>\\<^sub>R z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<preceq>\\<^sub>R y; y \\<preceq>\\<^sub>R z\\<rbrakk>\n    \\<Longrightarrow> x \\<preceq>\\<^sub>R z", "by (metis gR_rel_def add_assoc add_assocD_var2)"], ["", "lemma gL_rel_trans: \"x \\<preceq>\\<^sub>L y \\<Longrightarrow> y \\<preceq>\\<^sub>L z \\<Longrightarrow> x \\<preceq>\\<^sub>L z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<preceq>\\<^sub>L y; y \\<preceq>\\<^sub>L z\\<rbrakk>\n    \\<Longrightarrow> x \\<preceq>\\<^sub>L z", "by (metis gL_rel_def add_assocD_var1 add_assoc_var)"], ["", "lemma gR_add_isol: \"D z y \\<Longrightarrow> x \\<preceq>\\<^sub>R y \\<Longrightarrow> z \\<cdot> x \\<preceq>\\<^sub>R z \\<cdot> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>D z y; x \\<preceq>\\<^sub>R y\\<rbrakk>\n    \\<Longrightarrow> z \\<oplus> x \\<preceq>\\<^sub>R z \\<oplus> y", "apply (simp add: gR_rel_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>D z y; \\<exists>z. D x z \\<and> x \\<oplus> z = y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>za.\n                         D (z \\<oplus> x) za \\<and>\n                         z \\<oplus> x \\<oplus> za = z \\<oplus> y", "using add_assocD_var1 add_assoc_var"], ["proof (prove)\nusing this:\n  D ?y ?z \\<and> D ?x (?y \\<oplus> ?z) \\<Longrightarrow>\n  D ?x ?y \\<and> D (?x \\<oplus> ?y) ?z\n  D ?y ?z \\<and> D ?x (?y \\<oplus> ?z) \\<Longrightarrow>\n  ?x \\<oplus> ?y \\<oplus> ?z = ?x \\<oplus> (?y \\<oplus> ?z)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>D z y; \\<exists>z. D x z \\<and> x \\<oplus> z = y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>za.\n                         D (z \\<oplus> x) za \\<and>\n                         z \\<oplus> x \\<oplus> za = z \\<oplus> y", "by blast"], ["", "lemma gL_add_isor: \"D y z \\<Longrightarrow> x \\<preceq>\\<^sub>L y \\<Longrightarrow> x \\<cdot> z \\<preceq>\\<^sub>L y \\<cdot> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>D y z; x \\<preceq>\\<^sub>L y\\<rbrakk>\n    \\<Longrightarrow> x \\<oplus> z \\<preceq>\\<^sub>L y \\<oplus> z", "apply (simp add: gL_rel_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>D y z; \\<exists>z. D z x \\<and> z \\<oplus> x = y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>za.\n                         D za (x \\<oplus> z) \\<and>\n                         za \\<oplus> (x \\<oplus> z) = y \\<oplus> z", "by (metis add_assoc add_assocD_var2)"], ["", "definition annil :: \"'a \\<Rightarrow> bool\" where\n  \"annil x = (\\<forall>y. D x y \\<and> x \\<cdot> y = x)\""], ["", "definition annir :: \"'a \\<Rightarrow> bool\" where\n  \"annir x = (\\<forall>y. D y x \\<and> y \\<cdot> x = x)\""], ["", "end"], ["", "subsection \\<open>Morphisms\\<close>"], ["", "definition ps_morphism :: \"('a::partial_semigroup \\<Rightarrow> 'b::partial_semigroup) \\<Rightarrow> bool\" where\n  \"ps_morphism f = (\\<forall>x y. D x y \\<longrightarrow> D (f x) (f y) \\<and> f (x \\<cdot> y) = (f x) \\<cdot> (f y))\""], ["", "definition strong_ps_morphism :: \"('a::partial_semigroup \\<Rightarrow> 'b::partial_semigroup) \\<Rightarrow> bool\" where\n  \"strong_ps_morphism f = (ps_morphism f \\<and> (\\<forall>x y. D (f x) (f y) \\<longrightarrow> D x y))\""], ["", "subsection \\<open> Locally Finite Partial Semigroups\\<close>"], ["", "text \\<open>In locally finite partial semigroups,  elements can only be split in finitely many ways.\\<close>"], ["", "class locally_finite_partial_semigroup = partial_semigroup +\n  assumes loc_fin: \"finite (x\\<down>)\""], ["", "subsection \\<open>Cancellative Partial Semigroups\\<close>"], ["", "class cancellative_partial_semigroup = partial_semigroup +\n  assumes add_cancl: \"D z x \\<Longrightarrow> D z y \\<Longrightarrow> z \\<cdot> x = z \\<cdot> y \\<Longrightarrow> x = y\" \n  and add_cancr: \"D x z \\<Longrightarrow> D y z \\<Longrightarrow> x \\<cdot> z = y \\<cdot> z \\<Longrightarrow> x = y\" \n    \nbegin"], ["", "lemma unique_resl: \"D x z \\<Longrightarrow> D x z' \\<Longrightarrow> x \\<cdot> z = y \\<Longrightarrow> x \\<cdot> z' = y \\<Longrightarrow> z = z'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>D x z; D x z'; x \\<oplus> z = y; x \\<oplus> z' = y\\<rbrakk>\n    \\<Longrightarrow> z = z'", "by (simp add: add_cancl)"], ["", "lemma unique_resr: \"D z x \\<Longrightarrow> D z' x  \\<Longrightarrow> z \\<cdot> x = y \\<Longrightarrow> z' \\<cdot> x = y \\<Longrightarrow> z = z'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>D z x; D z' x; z \\<oplus> x = y; z' \\<oplus> x = y\\<rbrakk>\n    \\<Longrightarrow> z = z'", "by (simp add: add_cancr)"], ["", "lemma gR_rel_mult: \"D x y \\<Longrightarrow> x \\<preceq>\\<^sub>R x \\<cdot> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D x y \\<Longrightarrow> x \\<preceq>\\<^sub>R x \\<oplus> y", "using gR_rel_def"], ["proof (prove)\nusing this:\n  (?x \\<preceq>\\<^sub>R ?y) = (\\<exists>z. D ?x z \\<and> ?x \\<oplus> z = ?y)\n\ngoal (1 subgoal):\n 1. D x y \\<Longrightarrow> x \\<preceq>\\<^sub>R x \\<oplus> y", "by force"], ["", "lemma gL_rel_mult: \"D x y \\<Longrightarrow> y \\<preceq>\\<^sub>L x \\<cdot> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D x y \\<Longrightarrow> y \\<preceq>\\<^sub>L x \\<oplus> y", "using gL_rel_def"], ["proof (prove)\nusing this:\n  (?x \\<preceq>\\<^sub>L ?y) = (\\<exists>z. D z ?x \\<and> z \\<oplus> ?x = ?y)\n\ngoal (1 subgoal):\n 1. D x y \\<Longrightarrow> y \\<preceq>\\<^sub>L x \\<oplus> y", "by force"], ["", "text \\<open>By cancellation, the element z is uniquely defined for each pair x y, provided it exists.\n       In both cases, z is therefore a function of x and y; it is a quotient or residual of x y.\\<close>"], ["", "lemma quotr_unique: \"x \\<preceq>\\<^sub>R y  \\<Longrightarrow> (\\<exists>!z. D x z \\<and> y = x \\<cdot> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<preceq>\\<^sub>R y \\<Longrightarrow>\n    \\<exists>!z. D x z \\<and> y = x \\<oplus> z", "using gR_rel_def add_cancl"], ["proof (prove)\nusing this:\n  (?x \\<preceq>\\<^sub>R ?y) = (\\<exists>z. D ?x z \\<and> ?x \\<oplus> z = ?y)\n  \\<lbrakk>D ?z ?x; D ?z ?y; ?z \\<oplus> ?x = ?z \\<oplus> ?y\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. x \\<preceq>\\<^sub>R y \\<Longrightarrow>\n    \\<exists>!z. D x z \\<and> y = x \\<oplus> z", "by force"], ["", "lemma quotl_unique: \"x \\<preceq>\\<^sub>L y \\<Longrightarrow> (\\<exists>!z. D z x \\<and> y = z \\<cdot> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<preceq>\\<^sub>L y \\<Longrightarrow>\n    \\<exists>!z. D z x \\<and> y = z \\<oplus> x", "using gL_rel_def unique_resr"], ["proof (prove)\nusing this:\n  (?x \\<preceq>\\<^sub>L ?y) = (\\<exists>z. D z ?x \\<and> z \\<oplus> ?x = ?y)\n  \\<lbrakk>D ?z ?x; D ?z' ?x; ?z \\<oplus> ?x = ?y;\n   ?z' \\<oplus> ?x = ?y\\<rbrakk>\n  \\<Longrightarrow> ?z = ?z'\n\ngoal (1 subgoal):\n 1. x \\<preceq>\\<^sub>L y \\<Longrightarrow>\n    \\<exists>!z. D z x \\<and> y = z \\<oplus> x", "by force"], ["", "definition \"rquot y x = (THE z. D x z \\<and> x \\<cdot> z = y)\""], ["", "definition \"lquot y x = (THE z. D z x \\<and> z \\<cdot> x = y)\""], ["", "lemma rquot_prop: \"D x z \\<and> y = x \\<cdot> z \\<Longrightarrow> z = rquot y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D x z \\<and> y = x \\<oplus> z \\<Longrightarrow> z = rquot y x", "by (metis (mono_tags, lifting) rquot_def the_equality unique_resl)"], ["", "lemma rquot_mult: \"x \\<preceq>\\<^sub>R y \\<Longrightarrow> z = rquot y x \\<Longrightarrow> x \\<cdot> z = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<preceq>\\<^sub>R y; z = rquot y x\\<rbrakk>\n    \\<Longrightarrow> x \\<oplus> z = y", "using gR_rel_def rquot_prop"], ["proof (prove)\nusing this:\n  (?x \\<preceq>\\<^sub>R ?y) = (\\<exists>z. D ?x z \\<and> ?x \\<oplus> z = ?y)\n  D ?x ?z \\<and> ?y = ?x \\<oplus> ?z \\<Longrightarrow> ?z = rquot ?y ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<preceq>\\<^sub>R y; z = rquot y x\\<rbrakk>\n    \\<Longrightarrow> x \\<oplus> z = y", "by force"], ["", "lemma rquot_D: \"x \\<preceq>\\<^sub>R y \\<Longrightarrow> z = rquot y x \\<Longrightarrow> D x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<preceq>\\<^sub>R y; z = rquot y x\\<rbrakk>\n    \\<Longrightarrow> D x z", "using gR_rel_def rquot_prop"], ["proof (prove)\nusing this:\n  (?x \\<preceq>\\<^sub>R ?y) = (\\<exists>z. D ?x z \\<and> ?x \\<oplus> z = ?y)\n  D ?x ?z \\<and> ?y = ?x \\<oplus> ?z \\<Longrightarrow> ?z = rquot ?y ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<preceq>\\<^sub>R y; z = rquot y x\\<rbrakk>\n    \\<Longrightarrow> D x z", "by force"], ["", "lemma add_rquot: \"x \\<preceq>\\<^sub>R y \\<Longrightarrow> (D x z \\<and> x \\<oplus> z = y \\<longleftrightarrow> z = rquot y x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<preceq>\\<^sub>R y \\<Longrightarrow>\n    (D x z \\<and> x \\<oplus> z = y) = (z = rquot y x)", "using gR_rel_def rquot_prop"], ["proof (prove)\nusing this:\n  (?x \\<preceq>\\<^sub>R ?y) = (\\<exists>z. D ?x z \\<and> ?x \\<oplus> z = ?y)\n  D ?x ?z \\<and> ?y = ?x \\<oplus> ?z \\<Longrightarrow> ?z = rquot ?y ?x\n\ngoal (1 subgoal):\n 1. x \\<preceq>\\<^sub>R y \\<Longrightarrow>\n    (D x z \\<and> x \\<oplus> z = y) = (z = rquot y x)", "by fastforce"], ["", "lemma add_canc1: \"D x y \\<Longrightarrow> rquot (x \\<cdot> y) x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D x y \\<Longrightarrow> rquot (x \\<oplus> y) x = y", "using rquot_prop"], ["proof (prove)\nusing this:\n  D ?x ?z \\<and> ?y = ?x \\<oplus> ?z \\<Longrightarrow> ?z = rquot ?y ?x\n\ngoal (1 subgoal):\n 1. D x y \\<Longrightarrow> rquot (x \\<oplus> y) x = y", "by simp"], ["", "lemma add_canc2: \"x \\<preceq>\\<^sub>R y \\<Longrightarrow> x \\<cdot> (rquot y x) = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<preceq>\\<^sub>R y \\<Longrightarrow> x \\<oplus> rquot y x = y", "using gR_rel_def add_canc1"], ["proof (prove)\nusing this:\n  (?x \\<preceq>\\<^sub>R ?y) = (\\<exists>z. D ?x z \\<and> ?x \\<oplus> z = ?y)\n  D ?x ?y \\<Longrightarrow> rquot (?x \\<oplus> ?y) ?x = ?y\n\ngoal (1 subgoal):\n 1. x \\<preceq>\\<^sub>R y \\<Longrightarrow> x \\<oplus> rquot y x = y", "by force"], ["", "lemma add_canc2_prop: \"x \\<preceq>\\<^sub>R y \\<Longrightarrow> rquot y x \\<preceq>\\<^sub>L y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<preceq>\\<^sub>R y \\<Longrightarrow> rquot y x \\<preceq>\\<^sub>L y", "using gL_rel_mult rquot_D rquot_mult"], ["proof (prove)\nusing this:\n  D ?x ?y \\<Longrightarrow> ?y \\<preceq>\\<^sub>L ?x \\<oplus> ?y\n  \\<lbrakk>?x \\<preceq>\\<^sub>R ?y; ?z = rquot ?y ?x\\<rbrakk>\n  \\<Longrightarrow> D ?x ?z\n  \\<lbrakk>?x \\<preceq>\\<^sub>R ?y; ?z = rquot ?y ?x\\<rbrakk>\n  \\<Longrightarrow> ?x \\<oplus> ?z = ?y\n\ngoal (1 subgoal):\n 1. x \\<preceq>\\<^sub>R y \\<Longrightarrow> rquot y x \\<preceq>\\<^sub>L y", "by fastforce"], ["", "text \\<open>The next set of lemmas establishes standard Galois connections for cancellative partial semigroups.\\<close>"], ["", "lemma gR_galois_imp1: \"D x z \\<Longrightarrow> x \\<cdot> z \\<preceq>\\<^sub>R y \\<Longrightarrow> z \\<preceq>\\<^sub>R rquot y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>D x z; x \\<oplus> z \\<preceq>\\<^sub>R y\\<rbrakk>\n    \\<Longrightarrow> z \\<preceq>\\<^sub>R rquot y x", "by (metis gR_rel_def add_assoc add_assocD_var2 rquot_prop)"], ["", "lemma gR_galois_imp21: \"x \\<preceq>\\<^sub>R y \\<Longrightarrow> z \\<preceq>\\<^sub>R rquot y x \\<Longrightarrow> x \\<cdot> z \\<preceq>\\<^sub>R y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<preceq>\\<^sub>R y; z \\<preceq>\\<^sub>R rquot y x\\<rbrakk>\n    \\<Longrightarrow> x \\<oplus> z \\<preceq>\\<^sub>R y", "using gR_add_isol rquot_D rquot_mult"], ["proof (prove)\nusing this:\n  \\<lbrakk>D ?z ?y; ?x \\<preceq>\\<^sub>R ?y\\<rbrakk>\n  \\<Longrightarrow> ?z \\<oplus> ?x \\<preceq>\\<^sub>R ?z \\<oplus> ?y\n  \\<lbrakk>?x \\<preceq>\\<^sub>R ?y; ?z = rquot ?y ?x\\<rbrakk>\n  \\<Longrightarrow> D ?x ?z\n  \\<lbrakk>?x \\<preceq>\\<^sub>R ?y; ?z = rquot ?y ?x\\<rbrakk>\n  \\<Longrightarrow> ?x \\<oplus> ?z = ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<preceq>\\<^sub>R y; z \\<preceq>\\<^sub>R rquot y x\\<rbrakk>\n    \\<Longrightarrow> x \\<oplus> z \\<preceq>\\<^sub>R y", "by fastforce"], ["", "lemma gR_galois_imp22: \"x \\<preceq>\\<^sub>R y \\<Longrightarrow> z \\<preceq>\\<^sub>R rquot y x \\<Longrightarrow> D x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<preceq>\\<^sub>R y; z \\<preceq>\\<^sub>R rquot y x\\<rbrakk>\n    \\<Longrightarrow> D x z", "using gR_rel_def add_assocD add_canc1"], ["proof (prove)\nusing this:\n  (?x \\<preceq>\\<^sub>R ?y) = (\\<exists>z. D ?x z \\<and> ?x \\<oplus> z = ?y)\n  (D ?y ?z \\<and> D ?x (?y \\<oplus> ?z)) =\n  (D ?x ?y \\<and> D (?x \\<oplus> ?y) ?z)\n  D ?x ?y \\<Longrightarrow> rquot (?x \\<oplus> ?y) ?x = ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<preceq>\\<^sub>R y; z \\<preceq>\\<^sub>R rquot y x\\<rbrakk>\n    \\<Longrightarrow> D x z", "by fastforce"], ["", "lemma gR_galois: \"x \\<preceq>\\<^sub>R y \\<Longrightarrow> (D x z \\<and> x \\<cdot> z \\<preceq>\\<^sub>R y \\<longleftrightarrow> z \\<preceq>\\<^sub>R rquot y x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<preceq>\\<^sub>R y \\<Longrightarrow>\n    (D x z \\<and> x \\<oplus> z \\<preceq>\\<^sub>R y) =\n    (z \\<preceq>\\<^sub>R rquot y x)", "using gR_galois_imp1 gR_galois_imp21 gR_galois_imp22"], ["proof (prove)\nusing this:\n  \\<lbrakk>D ?x ?z; ?x \\<oplus> ?z \\<preceq>\\<^sub>R ?y\\<rbrakk>\n  \\<Longrightarrow> ?z \\<preceq>\\<^sub>R rquot ?y ?x\n  \\<lbrakk>?x \\<preceq>\\<^sub>R ?y;\n   ?z \\<preceq>\\<^sub>R rquot ?y ?x\\<rbrakk>\n  \\<Longrightarrow> ?x \\<oplus> ?z \\<preceq>\\<^sub>R ?y\n  \\<lbrakk>?x \\<preceq>\\<^sub>R ?y;\n   ?z \\<preceq>\\<^sub>R rquot ?y ?x\\<rbrakk>\n  \\<Longrightarrow> D ?x ?z\n\ngoal (1 subgoal):\n 1. x \\<preceq>\\<^sub>R y \\<Longrightarrow>\n    (D x z \\<and> x \\<oplus> z \\<preceq>\\<^sub>R y) =\n    (z \\<preceq>\\<^sub>R rquot y x)", "by blast"], ["", "lemma gR_rel_defined: \"x \\<preceq>\\<^sub>R y \\<Longrightarrow> D x (rquot y x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<preceq>\\<^sub>R y \\<Longrightarrow> D x (rquot y x)", "by (simp add: rquot_D)"], ["", "lemma ex_add_galois: \"D x z \\<Longrightarrow> (\\<exists>y. x \\<cdot> z = y \\<longleftrightarrow> rquot y x = z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D x z \\<Longrightarrow> \\<exists>y. (x \\<oplus> z = y) = (rquot y x = z)", "using add_canc1"], ["proof (prove)\nusing this:\n  D ?x ?y \\<Longrightarrow> rquot (?x \\<oplus> ?y) ?x = ?y\n\ngoal (1 subgoal):\n 1. D x z \\<Longrightarrow> \\<exists>y. (x \\<oplus> z = y) = (rquot y x = z)", "by force"], ["", "end"], ["", "subsection \\<open>Partial Monoids\\<close>"], ["", "text \\<open>We allow partial monoids with multiple units. This is similar to and inspired by small categories.\\<close>"], ["", "class partial_monoid = partial_semigroup +\n  fixes E :: \"'a set\"\n  assumes unitl_ex: \"\\<exists>e \\<in> E. D e x \\<and> e \\<cdot> x = x\"\n  and unitr_ex: \"\\<exists>e \\<in> E. D x e \\<and> x \\<cdot> e = x\"\n  and units_eq: \"e1 \\<in> E \\<Longrightarrow> e2 \\<in> E \\<Longrightarrow> D e1 e2 \\<Longrightarrow> e1 = e2\""], ["", "text \\<open>Every monoid is a partial monoid.\\<close>"], ["", "sublocale monoid_mult \\<subseteq> mon: partial_monoid _ \"\\<lambda>x y. True\" \"{1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.partial_monoid (\\<oplus>) (\\<lambda>x y. True) {1::'a}", "by (standard; simp_all)"], ["", "context partial_monoid \nbegin"], ["", "lemma units_eq_var: \"e1 \\<in> E \\<Longrightarrow> e2 \\<in> E \\<Longrightarrow> e1 \\<noteq> e2 \\<Longrightarrow> \\<not> D e1 e2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>e1 \\<in> E; e2 \\<in> E; e1 \\<noteq> e2\\<rbrakk>\n    \\<Longrightarrow> \\<not> D e1 e2", "using units_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>?e1.0 \\<in> E; ?e2.0 \\<in> E; D ?e1.0 ?e2.0\\<rbrakk>\n  \\<Longrightarrow> ?e1.0 = ?e2.0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>e1 \\<in> E; e2 \\<in> E; e1 \\<noteq> e2\\<rbrakk>\n    \\<Longrightarrow> \\<not> D e1 e2", "by force"], ["", "text \\<open>In partial monoids, Green's relations become preorders, but need not be partial orders.\\<close>"], ["", "sublocale gR: preorder gR_rel strict_gR_rel"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.preorder (\\<preceq>\\<^sub>R) (\\<prec>\\<^sub>R)", "apply standard"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       (x \\<prec>\\<^sub>R y) =\n       (x \\<preceq>\\<^sub>R y \\<and> \\<not> y \\<preceq>\\<^sub>R x)\n 2. \\<And>x. x \\<preceq>\\<^sub>R x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<preceq>\\<^sub>R y; y \\<preceq>\\<^sub>R z\\<rbrakk>\n       \\<Longrightarrow> x \\<preceq>\\<^sub>R z", "apply (simp add: strict_gR_rel_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<preceq>\\<^sub>R x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<preceq>\\<^sub>R y; y \\<preceq>\\<^sub>R z\\<rbrakk>\n       \\<Longrightarrow> x \\<preceq>\\<^sub>R z", "using gR_rel_def unitr_ex"], ["proof (prove)\nusing this:\n  (?x \\<preceq>\\<^sub>R ?y) = (\\<exists>z. D ?x z \\<and> ?x \\<oplus> z = ?y)\n  \\<exists>e\\<in>E. D ?x e \\<and> ?x \\<oplus> e = ?x\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<preceq>\\<^sub>R x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<preceq>\\<^sub>R y; y \\<preceq>\\<^sub>R z\\<rbrakk>\n       \\<Longrightarrow> x \\<preceq>\\<^sub>R z", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<preceq>\\<^sub>R y; y \\<preceq>\\<^sub>R z\\<rbrakk>\n       \\<Longrightarrow> x \\<preceq>\\<^sub>R z", "using gR_rel_trans"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<preceq>\\<^sub>R ?y; ?y \\<preceq>\\<^sub>R ?z\\<rbrakk>\n  \\<Longrightarrow> ?x \\<preceq>\\<^sub>R ?z\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<preceq>\\<^sub>R y; y \\<preceq>\\<^sub>R z\\<rbrakk>\n       \\<Longrightarrow> x \\<preceq>\\<^sub>R z", "by blast"], ["", "sublocale gL: preorder gL_rel strict_gL_rel"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.preorder (\\<preceq>\\<^sub>L) (\\<prec>\\<^sub>L)", "apply standard"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       (x \\<prec>\\<^sub>L y) =\n       (x \\<preceq>\\<^sub>L y \\<and> \\<not> y \\<preceq>\\<^sub>L x)\n 2. \\<And>x. x \\<preceq>\\<^sub>L x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<preceq>\\<^sub>L y; y \\<preceq>\\<^sub>L z\\<rbrakk>\n       \\<Longrightarrow> x \\<preceq>\\<^sub>L z", "apply (simp add: strict_gL_rel_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<preceq>\\<^sub>L x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<preceq>\\<^sub>L y; y \\<preceq>\\<^sub>L z\\<rbrakk>\n       \\<Longrightarrow> x \\<preceq>\\<^sub>L z", "using gL_rel_def unitl_ex"], ["proof (prove)\nusing this:\n  (?x \\<preceq>\\<^sub>L ?y) = (\\<exists>z. D z ?x \\<and> z \\<oplus> ?x = ?y)\n  \\<exists>e\\<in>E. D e ?x \\<and> e \\<oplus> ?x = ?x\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<preceq>\\<^sub>L x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<preceq>\\<^sub>L y; y \\<preceq>\\<^sub>L z\\<rbrakk>\n       \\<Longrightarrow> x \\<preceq>\\<^sub>L z", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<preceq>\\<^sub>L y; y \\<preceq>\\<^sub>L z\\<rbrakk>\n       \\<Longrightarrow> x \\<preceq>\\<^sub>L z", "using gL_rel_trans"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<preceq>\\<^sub>L ?y; ?y \\<preceq>\\<^sub>L ?z\\<rbrakk>\n  \\<Longrightarrow> ?x \\<preceq>\\<^sub>L ?z\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<preceq>\\<^sub>L y; y \\<preceq>\\<^sub>L z\\<rbrakk>\n       \\<Longrightarrow> x \\<preceq>\\<^sub>L z", "by blast"], ["", "lemma \"x \\<preceq>\\<^sub>R y \\<Longrightarrow> y \\<preceq>\\<^sub>R x \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<preceq>\\<^sub>R y; y \\<preceq>\\<^sub>R x\\<rbrakk>\n    \\<Longrightarrow> x = y", "(* nitpick [expect=genuine] *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<preceq>\\<^sub>R y; y \\<preceq>\\<^sub>R x\\<rbrakk>\n    \\<Longrightarrow> x = y", "oops"], ["", "lemma \"annil x \\<Longrightarrow> annil y \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>annil x; annil y\\<rbrakk> \\<Longrightarrow> x = y", "(* nitpick [expext=genuine] *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>annil x; annil y\\<rbrakk> \\<Longrightarrow> x = y", "oops"], ["", "lemma  \"annir x \\<Longrightarrow> annir y \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>annir x; annir y\\<rbrakk> \\<Longrightarrow> x = y", "(* nitpick [expect=genuine] *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>annir x; annir y\\<rbrakk> \\<Longrightarrow> x = y", "oops"], ["", "end"], ["", "text \\<open>Next we define partial monoid morphisms.\\<close>"], ["", "definition pm_morphism :: \"('a::partial_monoid \\<Rightarrow> 'b::partial_monoid) \\<Rightarrow> bool\" where\n  \"pm_morphism f = (ps_morphism f \\<and> (\\<forall>e. e \\<in> E \\<longrightarrow> (f e) \\<in> E))\""], ["", "definition strong_pm_morphism :: \"('a::partial_monoid \\<Rightarrow> 'b::partial_monoid) \\<Rightarrow> bool\" where\n  \"strong_pm_morphism f = (pm_morphism f \\<and> (\\<forall>e. (f e) \\<in> E \\<longrightarrow> e \\<in> E))\""], ["", "text \\<open>Partial Monoids with a single unit form a special case.\\<close>"], ["", "class partial_monoid_one = partial_semigroup + one +\n  assumes oneDl: \"D x 1\"\n  and oneDr: \"D 1 x\"\n  and oner: \"x \\<cdot> 1 = x\" \n  and onel: \"1 \\<cdot> x = x\"\n  \nbegin"], ["", "sublocale pmo: partial_monoid _ _ \"{1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.partial_monoid (\\<oplus>) D {1::'a}", "by standard (simp_all add: oneDr onel oneDl oner)"], ["", "end"], ["", "subsection \\<open>Cancellative Partial Monoids\\<close>"], ["", "class cancellative_partial_monoid = cancellative_partial_semigroup + partial_monoid\n  \nbegin"], ["", "lemma canc_unitr: \"D x e \\<Longrightarrow> x \\<cdot> e = x \\<Longrightarrow> e \\<in> E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>D x e; x \\<oplus> e = x\\<rbrakk> \\<Longrightarrow> e \\<in> E", "by (metis add_cancl unitr_ex)"], ["", "lemma canc_unitl: \"D e x \\<Longrightarrow> e \\<cdot> x = x \\<Longrightarrow> e \\<in> E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>D e x; e \\<oplus> x = x\\<rbrakk> \\<Longrightarrow> e \\<in> E", "by (metis add_cancr unitl_ex)"], ["", "end"], ["", "subsection \\<open>Positive Partial Monoids\\<close>"], ["", "class positive_partial_monoid  = partial_monoid +\n  assumes posl: \"D x y \\<Longrightarrow> x \\<cdot> y \\<in> E \\<Longrightarrow> x \\<in> E\"\n  and posr: \"D x y \\<Longrightarrow> x \\<cdot> y \\<in> E \\<Longrightarrow> y \\<in> E\"\n  \nbegin"], ["", "lemma pos_unitl: \"D x y \\<Longrightarrow> e \\<in> E \\<Longrightarrow> x \\<cdot> y = e \\<Longrightarrow> x = e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>D x y; e \\<in> E; x \\<oplus> y = e\\<rbrakk>\n    \\<Longrightarrow> x = e", "by (metis posl posr unitr_ex units_eq_var)"], ["", "lemma pos_unitr: \"D x y \\<Longrightarrow> e \\<in> E \\<Longrightarrow> x \\<cdot> y = e \\<Longrightarrow> y = e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>D x y; e \\<in> E; x \\<oplus> y = e\\<rbrakk>\n    \\<Longrightarrow> y = e", "by (metis posl posr unitr_ex units_eq_var)"], ["", "end"], ["", "subsection \\<open>Positive Cancellative Partial Monoids\\<close>"], ["", "class positive_cancellative_partial_monoid = positive_partial_monoid + cancellative_partial_monoid\n  \nbegin"], ["", "text \\<open>In positive cancellative monoids, the Green's relations are partial orders.\\<close>"], ["", "sublocale pcpmR: order gR_rel strict_gR_rel"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.order (\\<preceq>\\<^sub>R) (\\<prec>\\<^sub>R)", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<preceq>\\<^sub>R y; y \\<preceq>\\<^sub>R x\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (clarsimp simp: gR_rel_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x z za.\n       \\<lbrakk>D x z; D (x \\<oplus> z) za;\n        x \\<oplus> z \\<oplus> za = x\\<rbrakk>\n       \\<Longrightarrow> x = x \\<oplus> z", "by (metis canc_unitr add_assoc add_assocD_var2 pos_unitl)"], ["", "sublocale pcpmL: order gL_rel strict_gL_rel"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.order (\\<preceq>\\<^sub>L) (\\<prec>\\<^sub>L)", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<preceq>\\<^sub>L y; y \\<preceq>\\<^sub>L x\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (clarsimp simp: gL_rel_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x z za.\n       \\<lbrakk>D z x; D za (z \\<oplus> x);\n        za \\<oplus> (z \\<oplus> x) = x\\<rbrakk>\n       \\<Longrightarrow> x = z \\<oplus> x", "by (metis canc_unitl add_assoc add_assocD_var1 pos_unitr)"], ["", "end"], ["", "subsection \\<open>From Partial Abelian Semigroups to Partial Abelian Monoids\\<close>"], ["", "text \\<open>Next we define partial abelian semigroups. These are interesting, e.g., for the foundations\nof quantum mechanics and as resource monoids in separation logic.\\<close>"], ["", "class pas = partial_semigroup +\n  assumes add_comm: \"D x y \\<Longrightarrow> D y x \\<and> x \\<oplus> y = y \\<oplus> x\"\n\nbegin"], ["", "lemma D_comm: \"D x y \\<longleftrightarrow> D y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D x y = D y x", "by (auto simp add: add_comm)"], ["", "lemma add_comm': \"D x y \\<Longrightarrow> x \\<oplus> y = y \\<oplus> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D x y \\<Longrightarrow> x \\<oplus> y = y \\<oplus> x", "by (auto simp add: add_comm)"], ["", "lemma gL_gH_rel: \"(x \\<preceq>\\<^sub>L y) = (x \\<preceq>\\<^sub>H y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<preceq>\\<^sub>L y) = (x \\<preceq>\\<^sub>H y)", "apply (simp add: gH_rel_def gL_rel_def gR_rel_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>z. D z x \\<and> z \\<oplus> x = y) =\n    ((\\<exists>z. D z x \\<and> z \\<oplus> x = y) \\<and>\n     (\\<exists>z. D x z \\<and> x \\<oplus> z = y))", "using add_comm"], ["proof (prove)\nusing this:\n  D ?x ?y \\<Longrightarrow> D ?y ?x \\<and> ?x \\<oplus> ?y = ?y \\<oplus> ?x\n\ngoal (1 subgoal):\n 1. (\\<exists>z. D z x \\<and> z \\<oplus> x = y) =\n    ((\\<exists>z. D z x \\<and> z \\<oplus> x = y) \\<and>\n     (\\<exists>z. D x z \\<and> x \\<oplus> z = y))", "by force"], ["", "lemma gR_gH_rel: \"(x \\<preceq>\\<^sub>R y) = (x \\<preceq>\\<^sub>H y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<preceq>\\<^sub>R y) = (x \\<preceq>\\<^sub>H y)", "apply (simp add: gH_rel_def gL_rel_def gR_rel_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>z. D x z \\<and> x \\<oplus> z = y) =\n    ((\\<exists>z. D z x \\<and> z \\<oplus> x = y) \\<and>\n     (\\<exists>z. D x z \\<and> x \\<oplus> z = y))", "using add_comm"], ["proof (prove)\nusing this:\n  D ?x ?y \\<Longrightarrow> D ?y ?x \\<and> ?x \\<oplus> ?y = ?y \\<oplus> ?x\n\ngoal (1 subgoal):\n 1. (\\<exists>z. D x z \\<and> x \\<oplus> z = y) =\n    ((\\<exists>z. D z x \\<and> z \\<oplus> x = y) \\<and>\n     (\\<exists>z. D x z \\<and> x \\<oplus> z = y))", "by blast"], ["", "lemma annilr: \"annil x = annir x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. annil x = annir x", "by (metis annil_def annir_def add_comm)"], ["", "lemma anni_unique: \"annil x \\<Longrightarrow> annil y \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>annil x; annil y\\<rbrakk> \\<Longrightarrow> x = y", "by (metis annilr annil_def annir_def)"], ["", "end"], ["", "text \\<open>The following classes collect families of partially ordered abelian semigroups and monoids.\\<close>"], ["", "class locally_finite_pas = pas + locally_finite_partial_semigroup"], ["", "class pam = pas + partial_monoid"], ["", "class cancellative_pam = pam + cancellative_partial_semigroup"], ["", "class positive_pam = pam + positive_partial_monoid"], ["", "class positive_cancellative_pam  = positive_pam + cancellative_pam"], ["", "class generalised_effect_algebra = pas + partial_monoid_one"], ["", "class cancellative_pam_one = cancellative_pam + partial_monoid_one"], ["", "class positive_cancellative_pam_one = positive_cancellative_pam  + cancellative_pam_one"], ["", "context cancellative_pam_one\nbegin"], ["", "lemma E_eq_one: \"E = {1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E = {1::'a}", "by (metis oneDr oner unitl_ex units_eq singleton_iff subsetI subset_antisym)"], ["", "lemma one_in_E: \"1 \\<in> E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) \\<in> E", "by (simp add: E_eq_one)"], ["", "end"], ["", "subsection \\<open>Alternative Definitions\\<close>"], ["", "text \\<open>PAS's can be axiomatised more compactly as follows.\\<close>"], ["", "class pas_alt = partial_times +\n  assumes pas_alt_assoc: \"D x y \\<and> D (x \\<oplus> y) z \\<Longrightarrow> D y z \\<and> D x (y \\<oplus> z) \\<and> (x \\<oplus> y) \\<oplus> z = x \\<oplus> (y \\<oplus> z)\"\n  and pas_alt_comm: \"D x y \\<Longrightarrow> D y x \\<and> x \\<oplus> y = y \\<oplus> x\""], ["", "sublocale pas_alt \\<subseteq> palt: pas"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.pas (\\<oplus>) D", "apply standard"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>y z x.\n       (D y z \\<and> D x (y \\<oplus> z)) = (D x y \\<and> D (x \\<oplus> y) z)\n 2. \\<And>x y z.\n       D x y \\<and> D (x \\<oplus> y) z \\<Longrightarrow>\n       x \\<oplus> y \\<oplus> z = x \\<oplus> (y \\<oplus> z)\n 3. \\<And>x y.\n       D x y \\<Longrightarrow> D y x \\<and> x \\<oplus> y = y \\<oplus> x", "using pas_alt_assoc pas_alt_comm"], ["proof (prove)\nusing this:\n  D ?x ?y \\<and> D (?x \\<oplus> ?y) ?z \\<Longrightarrow>\n  D ?y ?z \\<and>\n  D ?x (?y \\<oplus> ?z) \\<and>\n  ?x \\<oplus> ?y \\<oplus> ?z = ?x \\<oplus> (?y \\<oplus> ?z)\n  D ?x ?y \\<Longrightarrow> D ?y ?x \\<and> ?x \\<oplus> ?y = ?y \\<oplus> ?x\n\ngoal (3 subgoals):\n 1. \\<And>y z x.\n       (D y z \\<and> D x (y \\<oplus> z)) = (D x y \\<and> D (x \\<oplus> y) z)\n 2. \\<And>x y z.\n       D x y \\<and> D (x \\<oplus> y) z \\<Longrightarrow>\n       x \\<oplus> y \\<oplus> z = x \\<oplus> (y \\<oplus> z)\n 3. \\<And>x y.\n       D x y \\<Longrightarrow> D y x \\<and> x \\<oplus> y = y \\<oplus> x", "by blast+"], ["", "text \\<open>Positive abelian PAM's can be axiomatised more compactly as well.\\<close>"], ["", "class pam_pos_alt = pam +\n  assumes pos_alt: \"D x y \\<Longrightarrow> e \\<in> E \\<Longrightarrow> x \\<oplus> y = e \\<Longrightarrow> x = e\""], ["", "sublocale pam_pos_alt \\<subseteq> ppalt: positive_pam"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.positive_pam (\\<oplus>) D E", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>D x y; x \\<oplus> y \\<in> E\\<rbrakk>\n       \\<Longrightarrow> x \\<in> E\n 2. \\<And>x y.\n       \\<lbrakk>D x y; x \\<oplus> y \\<in> E\\<rbrakk>\n       \\<Longrightarrow> y \\<in> E", "using pos_alt"], ["proof (prove)\nusing this:\n  \\<lbrakk>D ?x ?y; ?e \\<in> E; ?x \\<oplus> ?y = ?e\\<rbrakk>\n  \\<Longrightarrow> ?x = ?e\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>D x y; x \\<oplus> y \\<in> E\\<rbrakk>\n       \\<Longrightarrow> x \\<in> E\n 2. \\<And>x y.\n       \\<lbrakk>D x y; x \\<oplus> y \\<in> E\\<rbrakk>\n       \\<Longrightarrow> y \\<in> E", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>D x y; x \\<oplus> y \\<in> E\\<rbrakk>\n       \\<Longrightarrow> y \\<in> E", "using add_comm pos_alt"], ["proof (prove)\nusing this:\n  D ?x ?y \\<Longrightarrow> D ?y ?x \\<and> ?x \\<oplus> ?y = ?y \\<oplus> ?x\n  \\<lbrakk>D ?x ?y; ?e \\<in> E; ?x \\<oplus> ?y = ?e\\<rbrakk>\n  \\<Longrightarrow> ?x = ?e\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>D x y; x \\<oplus> y \\<in> E\\<rbrakk>\n       \\<Longrightarrow> y \\<in> E", "by fastforce"], ["", "subsection \\<open>Product Constructions\\<close>"], ["", "text \\<open>We consider two kinds of product construction. The first one combines partial semigroups with sets, \n        the second one partial semigroups with partial semigroups. The first one is interesting for \n        Separation Logic. Semidirect product constructions are considered later.\\<close>"], ["", "instantiation prod :: (type, partial_semigroup) partial_semigroup\nbegin"], ["", "definition \"D_prod x y = (fst x = fst y \\<and> D (snd x) (snd y))\"\n  for x y :: \"'a \\<times> 'b\""], ["", "definition times_prod :: \"'a \\<times> 'b \\<Rightarrow> 'a \\<times> 'b \\<Rightarrow> 'a \\<times> 'b\" where\n  \"times_prod x y = (fst x, snd x \\<cdot> snd y)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<times> 'b, partial_semigroup_class)", "apply (standard, simp_all add: D_prod_def times_prod_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y z x.\n       (fst y = fst z \\<and>\n        D (snd y) (snd z) \\<and>\n        fst x = fst y \\<and> D (snd x) (snd y \\<oplus> snd z)) =\n       (fst x = fst y \\<and>\n        D (snd x) (snd y) \\<and>\n        fst x = fst z \\<and> D (snd x \\<oplus> snd y) (snd z))\n 2. \\<And>x y z.\n       fst x = fst y \\<and>\n       D (snd x) (snd y) \\<and>\n       fst x = fst z \\<and>\n       D (snd x \\<oplus> snd y) (snd z) \\<Longrightarrow>\n       snd x \\<oplus> snd y \\<oplus> snd z =\n       snd x \\<oplus> (snd y \\<oplus> snd z)", "using partial_semigroup_class.add_assocD"], ["proof (prove)\nusing this:\n  (D ?y ?z \\<and> D ?x (?y \\<oplus> ?z)) =\n  (D ?x ?y \\<and> D (?x \\<oplus> ?y) ?z)\n\ngoal (2 subgoals):\n 1. \\<And>y z x.\n       (fst y = fst z \\<and>\n        D (snd y) (snd z) \\<and>\n        fst x = fst y \\<and> D (snd x) (snd y \\<oplus> snd z)) =\n       (fst x = fst y \\<and>\n        D (snd x) (snd y) \\<and>\n        fst x = fst z \\<and> D (snd x \\<oplus> snd y) (snd z))\n 2. \\<And>x y z.\n       fst x = fst y \\<and>\n       D (snd x) (snd y) \\<and>\n       fst x = fst z \\<and>\n       D (snd x \\<oplus> snd y) (snd z) \\<Longrightarrow>\n       snd x \\<oplus> snd y \\<oplus> snd z =\n       snd x \\<oplus> (snd y \\<oplus> snd z)", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       fst x = fst y \\<and>\n       D (snd x) (snd y) \\<and>\n       fst x = fst z \\<and>\n       D (snd x \\<oplus> snd y) (snd z) \\<Longrightarrow>\n       snd x \\<oplus> snd y \\<oplus> snd z =\n       snd x \\<oplus> (snd y \\<oplus> snd z)", "by (simp add: partial_semigroup_class.add_assoc)"], ["", "end"], ["", "instantiation prod :: (type, partial_monoid) partial_monoid\nbegin"], ["", "definition E_prod :: \"('a \\<times> 'b) set\" where\n  \"E_prod = {x. snd x \\<in> E}\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<times> 'b, partial_monoid_class)", "apply (standard, simp_all add: D_prod_def times_prod_def E_prod_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<exists>b.\n          b \\<in> E \\<and> D b (snd x) \\<and> (fst x, b \\<oplus> snd x) = x\n 2. \\<And>x.\n       \\<exists>b.\n          b \\<in> E \\<and> D (snd x) b \\<and> (fst x, snd x \\<oplus> b) = x\n 3. \\<And>e1 e2.\n       \\<lbrakk>snd e1 \\<in> E; snd e2 \\<in> E;\n        fst e1 = fst e2 \\<and> D (snd e1) (snd e2)\\<rbrakk>\n       \\<Longrightarrow> e1 = e2", "using partial_monoid_class.unitl_ex"], ["proof (prove)\nusing this:\n  \\<exists>e\\<in>E. D e ?x \\<and> e \\<oplus> ?x = ?x\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<exists>b.\n          b \\<in> E \\<and> D b (snd x) \\<and> (fst x, b \\<oplus> snd x) = x\n 2. \\<And>x.\n       \\<exists>b.\n          b \\<in> E \\<and> D (snd x) b \\<and> (fst x, snd x \\<oplus> b) = x\n 3. \\<And>e1 e2.\n       \\<lbrakk>snd e1 \\<in> E; snd e2 \\<in> E;\n        fst e1 = fst e2 \\<and> D (snd e1) (snd e2)\\<rbrakk>\n       \\<Longrightarrow> e1 = e2", "apply fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<exists>b.\n          b \\<in> E \\<and> D (snd x) b \\<and> (fst x, snd x \\<oplus> b) = x\n 2. \\<And>e1 e2.\n       \\<lbrakk>snd e1 \\<in> E; snd e2 \\<in> E;\n        fst e1 = fst e2 \\<and> D (snd e1) (snd e2)\\<rbrakk>\n       \\<Longrightarrow> e1 = e2", "using partial_monoid_class.unitr_ex"], ["proof (prove)\nusing this:\n  \\<exists>e\\<in>E. D ?x e \\<and> ?x \\<oplus> e = ?x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<exists>b.\n          b \\<in> E \\<and> D (snd x) b \\<and> (fst x, snd x \\<oplus> b) = x\n 2. \\<And>e1 e2.\n       \\<lbrakk>snd e1 \\<in> E; snd e2 \\<in> E;\n        fst e1 = fst e2 \\<and> D (snd e1) (snd e2)\\<rbrakk>\n       \\<Longrightarrow> e1 = e2", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e1 e2.\n       \\<lbrakk>snd e1 \\<in> E; snd e2 \\<in> E;\n        fst e1 = fst e2 \\<and> D (snd e1) (snd e2)\\<rbrakk>\n       \\<Longrightarrow> e1 = e2", "by (simp add: partial_monoid_class.units_eq prod_eq_iff)"], ["", "end"], ["", "instance prod :: (type, pas) pas"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<times> 'b, pas_class)", "apply (standard, simp add: D_prod_def times_prod_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       fst x = fst y \\<and> D (snd x) (snd y) \\<Longrightarrow>\n       D (snd y) (snd x) \\<and> snd x \\<oplus> snd y = snd y \\<oplus> snd x", "using pas_class.add_comm"], ["proof (prove)\nusing this:\n  D ?x ?y \\<Longrightarrow> D ?y ?x \\<and> ?x \\<oplus> ?y = ?y \\<oplus> ?x\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       fst x = fst y \\<and> D (snd x) (snd y) \\<Longrightarrow>\n       D (snd y) (snd x) \\<and> snd x \\<oplus> snd y = snd y \\<oplus> snd x", "by force"], ["", "lemma prod_div1: \"(x1::'a, y1::'b::pas) \\<preceq>\\<^sub>R (x2::'a, y2::'b::pas) \\<Longrightarrow> x1 = x2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x1, y1) \\<preceq>\\<^sub>R (x2, y2) \\<Longrightarrow> x1 = x2", "by (force simp: partial_semigroup_class.gR_rel_def times_prod_def)"], ["", "lemma prod_div2: \"(x1, y1) \\<preceq>\\<^sub>R (x2, y2) \\<Longrightarrow> y1 \\<preceq>\\<^sub>R y2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x1, y1) \\<preceq>\\<^sub>R (x2, y2) \\<Longrightarrow>\n    y1 \\<preceq>\\<^sub>R y2", "by (force simp: partial_semigroup_class.gR_rel_def D_prod_def times_prod_def)"], ["", "lemma prod_div_eq: \"(x1, y1) \\<preceq>\\<^sub>R (x2, y2) \\<longleftrightarrow> x1 = x2 \\<and> y1 \\<preceq>\\<^sub>R y2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x1, y1) \\<preceq>\\<^sub>R (x2, y2)) =\n    (x1 = x2 \\<and> y1 \\<preceq>\\<^sub>R y2)", "by (force simp: partial_semigroup_class.gR_rel_def D_prod_def times_prod_def)"], ["", "instance prod :: (type, pam) pam"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<times> 'b, pam_class)", "by standard"], ["", "instance prod :: (type, cancellative_pam) cancellative_pam"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<times> 'b, cancellative_pam_class)", "by (standard, auto simp: D_prod_def times_prod_def add_cancr add_cancl)"], ["", "lemma prod_res_eq: \"(x1, y1) \\<preceq>\\<^sub>R (x2::'a,y2::'b::cancellative_pam) \n    \\<Longrightarrow> rquot (x2, y2) (x1, y1) = (x1, rquot y2 y1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x1, y1) \\<preceq>\\<^sub>R (x2, y2) \\<Longrightarrow>\n    rquot (x2, y2) (x1, y1) = (x1, rquot y2 y1)", "apply (clarsimp simp: partial_semigroup_class.gR_rel_def D_prod_def times_prod_def rquot_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>D y1 b; x1 = x2; y2 = y1 \\<oplus> b\\<rbrakk>\n       \\<Longrightarrow> (THE z.\n                             x2 = fst z \\<and>\n                             D y1 (snd z) \\<and>\n                             y1 \\<oplus> snd z = y1 \\<oplus> b) =\n                         (x2,\n                          THE z.\n                             D y1 z \\<and> y1 \\<oplus> z = y1 \\<oplus> b)", "apply (rule theI2 conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b.\n       \\<lbrakk>D y1 b; x1 = x2; y2 = y1 \\<oplus> b\\<rbrakk>\n       \\<Longrightarrow> D y1 (?a8 b) \\<and>\n                         y1 \\<oplus> ?a8 b = y1 \\<oplus> b\n 2. \\<And>b x.\n       \\<lbrakk>D y1 b; x1 = x2; y2 = y1 \\<oplus> b;\n        D y1 x \\<and> y1 \\<oplus> x = y1 \\<oplus> b\\<rbrakk>\n       \\<Longrightarrow> x = ?a8 b\n 3. \\<And>b x.\n       \\<lbrakk>D y1 b; x1 = x2; y2 = y1 \\<oplus> b;\n        D y1 x \\<and> y1 \\<oplus> x = y1 \\<oplus> b\\<rbrakk>\n       \\<Longrightarrow> (THE z.\n                             x2 = fst z \\<and>\n                             D y1 (snd z) \\<and>\n                             y1 \\<oplus> snd z = y1 \\<oplus> b) =\n                         (x2, x)", "apply force"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b x.\n       \\<lbrakk>D y1 b; x1 = x2; y2 = y1 \\<oplus> b;\n        D y1 x \\<and> y1 \\<oplus> x = y1 \\<oplus> b\\<rbrakk>\n       \\<Longrightarrow> x = b\n 2. \\<And>b x.\n       \\<lbrakk>D y1 b; x1 = x2; y2 = y1 \\<oplus> b;\n        D y1 x \\<and> y1 \\<oplus> x = y1 \\<oplus> b\\<rbrakk>\n       \\<Longrightarrow> (THE z.\n                             x2 = fst z \\<and>\n                             D y1 (snd z) \\<and>\n                             y1 \\<oplus> snd z = y1 \\<oplus> b) =\n                         (x2, x)", "using add_cancl"], ["proof (prove)\nusing this:\n  \\<lbrakk>D ?z ?x; D ?z ?y; ?z \\<oplus> ?x = ?z \\<oplus> ?y\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n\ngoal (2 subgoals):\n 1. \\<And>b x.\n       \\<lbrakk>D y1 b; x1 = x2; y2 = y1 \\<oplus> b;\n        D y1 x \\<and> y1 \\<oplus> x = y1 \\<oplus> b\\<rbrakk>\n       \\<Longrightarrow> x = b\n 2. \\<And>b x.\n       \\<lbrakk>D y1 b; x1 = x2; y2 = y1 \\<oplus> b;\n        D y1 x \\<and> y1 \\<oplus> x = y1 \\<oplus> b\\<rbrakk>\n       \\<Longrightarrow> (THE z.\n                             x2 = fst z \\<and>\n                             D y1 (snd z) \\<and>\n                             y1 \\<oplus> snd z = y1 \\<oplus> b) =\n                         (x2, x)", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b x.\n       \\<lbrakk>D y1 b; x1 = x2; y2 = y1 \\<oplus> b;\n        D y1 x \\<and> y1 \\<oplus> x = y1 \\<oplus> b\\<rbrakk>\n       \\<Longrightarrow> (THE z.\n                             x2 = fst z \\<and>\n                             D y1 (snd z) \\<and>\n                             y1 \\<oplus> snd z = y1 \\<oplus> b) =\n                         (x2, x)", "by (rule the_equality, auto simp: add_cancl)"], ["", "instance prod :: (type, positive_pam) positive_pam"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<times> 'b, positive_pam_class)", "apply (standard, simp_all add: E_prod_def D_prod_def times_prod_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>fst x = fst y \\<and> D (snd x) (snd y);\n        snd x \\<oplus> snd y \\<in> E\\<rbrakk>\n       \\<Longrightarrow> snd x \\<in> E\n 2. \\<And>x y.\n       \\<lbrakk>fst x = fst y \\<and> D (snd x) (snd y);\n        snd x \\<oplus> snd y \\<in> E\\<rbrakk>\n       \\<Longrightarrow> snd y \\<in> E", "using positive_partial_monoid_class.posl"], ["proof (prove)\nusing this:\n  \\<lbrakk>D ?x ?y; ?x \\<oplus> ?y \\<in> E\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> E\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>fst x = fst y \\<and> D (snd x) (snd y);\n        snd x \\<oplus> snd y \\<in> E\\<rbrakk>\n       \\<Longrightarrow> snd x \\<in> E\n 2. \\<And>x y.\n       \\<lbrakk>fst x = fst y \\<and> D (snd x) (snd y);\n        snd x \\<oplus> snd y \\<in> E\\<rbrakk>\n       \\<Longrightarrow> snd y \\<in> E", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>fst x = fst y \\<and> D (snd x) (snd y);\n        snd x \\<oplus> snd y \\<in> E\\<rbrakk>\n       \\<Longrightarrow> snd y \\<in> E", "using positive_partial_monoid_class.posr"], ["proof (prove)\nusing this:\n  \\<lbrakk>D ?x ?y; ?x \\<oplus> ?y \\<in> E\\<rbrakk>\n  \\<Longrightarrow> ?y \\<in> E\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>fst x = fst y \\<and> D (snd x) (snd y);\n        snd x \\<oplus> snd y \\<in> E\\<rbrakk>\n       \\<Longrightarrow> snd y \\<in> E", "by blast"], ["", "instance prod :: (type, positive_cancellative_pam) positive_cancellative_pam"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<times> 'b, positive_cancellative_pam_class)", ".."], ["", "instance prod :: (type, locally_finite_pas) locally_finite_pas"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<times> 'b, locally_finite_pas_class)", "proof (standard, case_tac x, clarsimp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa ba. finite ((aa, ba)\\<down>)", "fix s :: 'a and x :: 'b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa ba. finite ((aa, ba)\\<down>)", "have \"finite (x\\<down>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (x\\<down>)", "by (simp add: loc_fin)"], ["proof (state)\nthis:\n  finite (x\\<down>)\n\ngoal (1 subgoal):\n 1. \\<And>aa ba. finite ((aa, ba)\\<down>)", "hence \"finite {y. \\<exists>z. D y z \\<and> y \\<oplus> z = x}\""], ["proof (prove)\nusing this:\n  finite (x\\<down>)\n\ngoal (1 subgoal):\n 1. finite {y. \\<exists>z. D y z \\<and> y \\<oplus> z = x}", "by (simp add: partial_semigroup_class.gR_downset_def partial_semigroup_class.gR_rel_def)"], ["proof (state)\nthis:\n  finite {y. \\<exists>z. D y z \\<and> y \\<oplus> z = x}\n\ngoal (1 subgoal):\n 1. \\<And>aa ba. finite ((aa, ba)\\<down>)", "hence \"finite {(s, y)| y. \\<exists>z. D y z \\<and> y \\<oplus> z = x}\""], ["proof (prove)\nusing this:\n  finite {y. \\<exists>z. D y z \\<and> y \\<oplus> z = x}\n\ngoal (1 subgoal):\n 1. finite {(s, y) |y. \\<exists>z. D y z \\<and> y \\<oplus> z = x}", "by (drule_tac f=\"\\<lambda>y. (s, y)\" in finite_image_set)"], ["proof (state)\nthis:\n  finite {(s, y) |y. \\<exists>z. D y z \\<and> y \\<oplus> z = x}\n\ngoal (1 subgoal):\n 1. \\<And>aa ba. finite ((aa, ba)\\<down>)", "moreover"], ["proof (state)\nthis:\n  finite {(s, y) |y. \\<exists>z. D y z \\<and> y \\<oplus> z = x}\n\ngoal (1 subgoal):\n 1. \\<And>aa ba. finite ((aa, ba)\\<down>)", "have \"{y. \\<exists>z1 z2. D y (z1, z2) \\<and> y \\<oplus> (z1, z2) = (s, x)} \n                    \\<subseteq> {(s, y)| y. \\<exists>z. D y z \\<and> y \\<oplus> z = x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. \\<exists>z1 z2. D y (z1, z2) \\<and> y \\<oplus> (z1, z2) = (s, x)}\n    \\<subseteq> {(s, y) |y. \\<exists>z. D y z \\<and> y \\<oplus> z = x}", "by (auto simp: D_prod_def times_prod_def)"], ["proof (state)\nthis:\n  {y. \\<exists>z1 z2. D y (z1, z2) \\<and> y \\<oplus> (z1, z2) = (s, x)}\n  \\<subseteq> {(s, y) |y. \\<exists>z. D y z \\<and> y \\<oplus> z = x}\n\ngoal (1 subgoal):\n 1. \\<And>aa ba. finite ((aa, ba)\\<down>)", "ultimately"], ["proof (chain)\npicking this:\n  finite {(s, y) |y. \\<exists>z. D y z \\<and> y \\<oplus> z = x}\n  {y. \\<exists>z1 z2. D y (z1, z2) \\<and> y \\<oplus> (z1, z2) = (s, x)}\n  \\<subseteq> {(s, y) |y. \\<exists>z. D y z \\<and> y \\<oplus> z = x}", "have \"finite {y. \\<exists>z1 z2. D y (z1, z2) \\<and> y \\<oplus> (z1, z2) = (s, x)}\""], ["proof (prove)\nusing this:\n  finite {(s, y) |y. \\<exists>z. D y z \\<and> y \\<oplus> z = x}\n  {y. \\<exists>z1 z2. D y (z1, z2) \\<and> y \\<oplus> (z1, z2) = (s, x)}\n  \\<subseteq> {(s, y) |y. \\<exists>z. D y z \\<and> y \\<oplus> z = x}\n\ngoal (1 subgoal):\n 1. finite\n     {y. \\<exists>z1 z2. D y (z1, z2) \\<and> y \\<oplus> (z1, z2) = (s, x)}", "by (auto intro: finite_subset)"], ["proof (state)\nthis:\n  finite\n   {y. \\<exists>z1 z2. D y (z1, z2) \\<and> y \\<oplus> (z1, z2) = (s, x)}\n\ngoal (1 subgoal):\n 1. \\<And>aa ba. finite ((aa, ba)\\<down>)", "thus \"finite ((s, x)\\<down>)\""], ["proof (prove)\nusing this:\n  finite\n   {y. \\<exists>z1 z2. D y (z1, z2) \\<and> y \\<oplus> (z1, z2) = (s, x)}\n\ngoal (1 subgoal):\n 1. finite ((s, x)\\<down>)", "by (simp add: partial_semigroup_class.gR_downset_def partial_semigroup_class.gR_rel_def)"], ["proof (state)\nthis:\n  finite ((s, x)\\<down>)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Next we consider products of two partial semigroups.\\<close>"], ["", "definition ps_prod_D :: \"'a :: partial_semigroup \\<times> 'b :: partial_semigroup \\<Rightarrow> 'a \\<times> 'b  \\<Rightarrow> bool\"\n  where \"ps_prod_D x y \\<equiv> D (fst x) (fst y) \\<and> D (snd x) (snd y)\""], ["", "definition ps_prod_times :: \"'a :: partial_semigroup \\<times> 'b :: partial_semigroup \\<Rightarrow> 'a \\<times> 'b \\<Rightarrow> 'a \\<times> 'b\"\n   where \"ps_prod_times x y = (fst x \\<cdot> fst y, snd x \\<cdot> snd y)\""], ["", "interpretation ps_prod: partial_semigroup ps_prod_times ps_prod_D"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.partial_semigroup ps_prod_times ps_prod_D", "apply (standard, simp_all add: ps_prod_D_def ps_prod_times_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y z x.\n       (D (fst y) (fst z) \\<and>\n        D (snd y) (snd z) \\<and>\n        D (fst x) (fst y \\<oplus> fst z) \\<and>\n        D (snd x) (snd y \\<oplus> snd z)) =\n       (D (fst x) (fst y) \\<and>\n        D (snd x) (snd y) \\<and>\n        D (fst x \\<oplus> fst y) (fst z) \\<and>\n        D (snd x \\<oplus> snd y) (snd z))\n 2. \\<And>x y z.\n       D (fst x) (fst y) \\<and>\n       D (snd x) (snd y) \\<and>\n       D (fst x \\<oplus> fst y) (fst z) \\<and>\n       D (snd x \\<oplus> snd y) (snd z) \\<Longrightarrow>\n       fst x \\<oplus> fst y \\<oplus> fst z =\n       fst x \\<oplus> (fst y \\<oplus> fst z) \\<and>\n       snd x \\<oplus> snd y \\<oplus> snd z =\n       snd x \\<oplus> (snd y \\<oplus> snd z)", "apply (meson partial_semigroup_class.add_assocD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       D (fst x) (fst y) \\<and>\n       D (snd x) (snd y) \\<and>\n       D (fst x \\<oplus> fst y) (fst z) \\<and>\n       D (snd x \\<oplus> snd y) (snd z) \\<Longrightarrow>\n       fst x \\<oplus> fst y \\<oplus> fst z =\n       fst x \\<oplus> (fst y \\<oplus> fst z) \\<and>\n       snd x \\<oplus> snd y \\<oplus> snd z =\n       snd x \\<oplus> (snd y \\<oplus> snd z)", "by (simp add: partial_semigroup_class.add_assoc)"], ["", "interpretation pas_prod: pas ps_prod_times \"ps_prod_D :: 'a :: pas \\<times> 'b :: pas \\<Rightarrow> 'a \\<times> 'b  \\<Rightarrow> bool\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.pas ps_prod_times ps_prod_D", "by (standard, clarsimp simp: ps_prod_D_def ps_prod_times_def pas_class.add_comm)"], ["", "definition pm_prod_E :: \"('a :: partial_monoid \\<times> 'b :: partial_monoid) set\" where\n  \"pm_prod_E = {x. fst x \\<in> E \\<and> snd x \\<in> E}\""], ["", "interpretation pm_prod: partial_monoid ps_prod_times ps_prod_D pm_prod_E"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.partial_monoid ps_prod_times ps_prod_D pm_prod_E", "apply standard"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<exists>e\\<in>pm_prod_E. ps_prod_D e x \\<and> ps_prod_times e x = x\n 2. \\<And>x.\n       \\<exists>e\\<in>pm_prod_E. ps_prod_D x e \\<and> ps_prod_times x e = x\n 3. \\<And>e1 e2.\n       \\<lbrakk>e1 \\<in> pm_prod_E; e2 \\<in> pm_prod_E;\n        ps_prod_D e1 e2\\<rbrakk>\n       \\<Longrightarrow> e1 = e2", "apply (simp_all add: ps_prod_times_def ps_prod_D_def pm_prod_E_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<exists>a.\n          a \\<in> E \\<and>\n          (\\<exists>b.\n              b \\<in> E \\<and>\n              D a (fst x) \\<and>\n              D b (snd x) \\<and> (a \\<oplus> fst x, b \\<oplus> snd x) = x)\n 2. \\<And>x.\n       \\<exists>a.\n          a \\<in> E \\<and>\n          (\\<exists>b.\n              b \\<in> E \\<and>\n              D (fst x) a \\<and>\n              D (snd x) b \\<and> (fst x \\<oplus> a, snd x \\<oplus> b) = x)\n 3. \\<And>e1 e2.\n       \\<lbrakk>fst e1 \\<in> E \\<and> snd e1 \\<in> E;\n        fst e2 \\<in> E \\<and> snd e2 \\<in> E;\n        D (fst e1) (fst e2) \\<and> D (snd e1) (snd e2)\\<rbrakk>\n       \\<Longrightarrow> e1 = e2", "apply (metis partial_monoid_class.unitl_ex prod.collapse)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<exists>a.\n          a \\<in> E \\<and>\n          (\\<exists>b.\n              b \\<in> E \\<and>\n              D (fst x) a \\<and>\n              D (snd x) b \\<and> (fst x \\<oplus> a, snd x \\<oplus> b) = x)\n 2. \\<And>e1 e2.\n       \\<lbrakk>fst e1 \\<in> E \\<and> snd e1 \\<in> E;\n        fst e2 \\<in> E \\<and> snd e2 \\<in> E;\n        D (fst e1) (fst e2) \\<and> D (snd e1) (snd e2)\\<rbrakk>\n       \\<Longrightarrow> e1 = e2", "apply (metis partial_monoid_class.unitr_ex prod.collapse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e1 e2.\n       \\<lbrakk>fst e1 \\<in> E \\<and> snd e1 \\<in> E;\n        fst e2 \\<in> E \\<and> snd e2 \\<in> E;\n        D (fst e1) (fst e2) \\<and> D (snd e1) (snd e2)\\<rbrakk>\n       \\<Longrightarrow> e1 = e2", "by (simp add: partial_monoid_class.units_eq prod.expand)"], ["", "interpretation pam_prod: pam ps_prod_times ps_prod_D \"pm_prod_E :: ('a :: pam \\<times> 'a :: pam) set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.pam ps_prod_times ps_prod_D pm_prod_E", ".."], ["", "subsection \\<open>Partial Semigroup Actions and Semidirect Products\\<close>"], ["", "text \\<open>(Semi)group actions are a standard mathematical construction. We generalise this to partial\nsemigroups and monoids. We use it to define semidirect products of partial semigroups. A generalisation \nto wreath products might be added in the future.\\<close>"], ["", "text \\<open>First we define the (left) action of a partial semigroup on a set. A right action could be defined in a similar way, \nbut we do not pursue this at the moment.\\<close>"], ["", "locale partial_sg_laction = \n  fixes Dla :: \"'a::partial_semigroup \\<Rightarrow> 'b \\<Rightarrow> bool\"\n  and act :: \"'a::partial_semigroup \\<Rightarrow> 'b \\<Rightarrow> 'b\" (\"\\<alpha>\") \n  assumes act_assocD: \"D x y \\<and> Dla (x \\<cdot> y) p \\<longleftrightarrow> Dla y p \\<and> Dla x (\\<alpha> y p)\"\n  and act_assoc: \"D x y \\<and> Dla (x \\<cdot> y) p \\<Longrightarrow> \\<alpha> (x \\<cdot> y) p = \\<alpha> x (\\<alpha> y p)\""], ["", "text \\<open>Next we define the action of a partial semigroup on another partial semigroup.\nIn the tradition of semigroup theory we use addition as a non-commutative operation for the second semigroup.\\<close>"], ["", "locale partial_sg_sg_laction = partial_sg_laction +\n  assumes act_distribD: \"D (p::'b::partial_semigroup) q \\<and> Dla (x::'a::partial_semigroup) (p \\<oplus> q) \\<longleftrightarrow> Dla x p \\<and> Dla x q \\<and> D (\\<alpha> x p) (\\<alpha> x q)\"\n  and act_distrib: \"D p q \\<and> Dla x (p \\<oplus> q) \\<Longrightarrow> \\<alpha> x (p \\<oplus> q) = (\\<alpha> x p) \\<oplus> (\\<alpha> x q)\"  \n  \nbegin"], ["", "text \\<open>Next we define the semidirect product as a partial operation and show that the semidirect \nproduct of two partial semigroups forms a partial semigroup.\\<close>"], ["", "definition sd_D :: \"('a \\<times> 'b) \\<Rightarrow> ('a \\<times> 'b) \\<Rightarrow> bool\" where\n  \"sd_D x y \\<equiv> D (fst x) (fst y) \\<and> Dla (fst x) (snd y) \\<and> D (snd x) (\\<alpha> (fst x) (snd y))\""], ["", "definition sd_prod :: \"('a \\<times> 'b) \\<Rightarrow> ('a \\<times> 'b) \\<Rightarrow> ('a \\<times> 'b)\" where\n  \"sd_prod x y = ((fst x) \\<cdot> (fst y), (snd x) \\<oplus> (\\<alpha> (fst x) (snd y)))\""], ["", "sublocale dp_semigroup: partial_semigroup sd_prod sd_D"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.partial_semigroup sd_prod sd_D", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y z x.\n       (sd_D y z \\<and> sd_D x (sd_prod y z)) =\n       (sd_D x y \\<and> sd_D (sd_prod x y) z)\n 2. \\<And>x y z.\n       sd_D x y \\<and> sd_D (sd_prod x y) z \\<Longrightarrow>\n       sd_prod (sd_prod x y) z = sd_prod x (sd_prod y z)", "apply (simp_all add: sd_prod_def sd_D_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y z x.\n       (D (fst y) (fst z) \\<and>\n        Dla (fst y) (snd z) \\<and>\n        D (snd y) (\\<alpha> (fst y) (snd z)) \\<and>\n        D (fst x) (fst y \\<oplus> fst z) \\<and>\n        Dla (fst x) (snd y \\<oplus> \\<alpha> (fst y) (snd z)) \\<and>\n        D (snd x)\n         (\\<alpha> (fst x) (snd y \\<oplus> \\<alpha> (fst y) (snd z)))) =\n       (D (fst x) (fst y) \\<and>\n        Dla (fst x) (snd y) \\<and>\n        D (snd x) (\\<alpha> (fst x) (snd y)) \\<and>\n        D (fst x \\<oplus> fst y) (fst z) \\<and>\n        Dla (fst x \\<oplus> fst y) (snd z) \\<and>\n        D (snd x \\<oplus> \\<alpha> (fst x) (snd y))\n         (\\<alpha> (fst x \\<oplus> fst y) (snd z)))\n 2. \\<And>x y z.\n       D (fst x) (fst y) \\<and>\n       Dla (fst x) (snd y) \\<and>\n       D (snd x) (\\<alpha> (fst x) (snd y)) \\<and>\n       D (fst x \\<oplus> fst y) (fst z) \\<and>\n       Dla (fst x \\<oplus> fst y) (snd z) \\<and>\n       D (snd x \\<oplus> \\<alpha> (fst x) (snd y))\n        (\\<alpha> (fst x \\<oplus> fst y) (snd z)) \\<Longrightarrow>\n       fst x \\<oplus> fst y \\<oplus> fst z =\n       fst x \\<oplus> (fst y \\<oplus> fst z) \\<and>\n       snd x \\<oplus> \\<alpha> (fst x) (snd y) \\<oplus>\n       \\<alpha> (fst x \\<oplus> fst y) (snd z) =\n       snd x \\<oplus>\n       \\<alpha> (fst x) (snd y \\<oplus> \\<alpha> (fst y) (snd z))", "apply (clarsimp, metis act_assoc act_assocD act_distrib act_distribD add_assocD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       D (fst x) (fst y) \\<and>\n       Dla (fst x) (snd y) \\<and>\n       D (snd x) (\\<alpha> (fst x) (snd y)) \\<and>\n       D (fst x \\<oplus> fst y) (fst z) \\<and>\n       Dla (fst x \\<oplus> fst y) (snd z) \\<and>\n       D (snd x \\<oplus> \\<alpha> (fst x) (snd y))\n        (\\<alpha> (fst x \\<oplus> fst y) (snd z)) \\<Longrightarrow>\n       fst x \\<oplus> fst y \\<oplus> fst z =\n       fst x \\<oplus> (fst y \\<oplus> fst z) \\<and>\n       snd x \\<oplus> \\<alpha> (fst x) (snd y) \\<oplus>\n       \\<alpha> (fst x \\<oplus> fst y) (snd z) =\n       snd x \\<oplus>\n       \\<alpha> (fst x) (snd y \\<oplus> \\<alpha> (fst y) (snd z))", "by (clarsimp, metis act_assoc act_assocD act_distrib act_distribD add_assoc add_assocD)"], ["", "end"], ["", "text \\<open>Finally we define the semigroup action for two partial monoids and show that the semidirect product of two partial monoids\nis a partial monoid.\\<close>"], ["", "locale partial_mon_sg_laction = partial_sg_sg_laction Dla\n  for Dla :: \"'a::partial_monoid \\<Rightarrow> 'b::partial_semigroup \\<Rightarrow> bool\" +\n  assumes act_unitl: \"e \\<in> E \\<Longrightarrow> Dla e p \\<and> \\<alpha> e p = p\""], ["", "locale partial_mon_mon_laction = partial_mon_sg_laction _ Dla\n  for Dla :: \"'a::partial_monoid \\<Rightarrow> 'b::partial_monoid \\<Rightarrow> bool\" +\n  assumes act_annir: \"e \\<in> Ea \\<Longrightarrow> Dla x e \\<and> \\<alpha> x e = e\"\n\nbegin"], ["", "definition sd_E :: \"('a \\<times> 'b) set\" where\n  \"sd_E = {x. fst x \\<in> E \\<and> snd x \\<in> E}\""], ["", "sublocale dp_semigroup : partial_monoid sd_prod sd_D sd_E"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.partial_monoid sd_prod sd_D sd_E", "apply unfold_locales"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. \\<exists>e\\<in>sd_E. sd_D e x \\<and> sd_prod e x = x\n 2. \\<And>x. \\<exists>e\\<in>sd_E. sd_D x e \\<and> sd_prod x e = x\n 3. \\<And>e1 e2.\n       \\<lbrakk>e1 \\<in> sd_E; e2 \\<in> sd_E; sd_D e1 e2\\<rbrakk>\n       \\<Longrightarrow> e1 = e2", "apply (simp_all add: sd_prod_def sd_D_def sd_E_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<exists>a.\n          a \\<in> E \\<and>\n          (\\<exists>b.\n              b \\<in> E \\<and>\n              D a (fst x) \\<and>\n              Dla a (snd x) \\<and>\n              D b (\\<alpha> a (snd x)) \\<and>\n              (a \\<oplus> fst x, b \\<oplus> \\<alpha> a (snd x)) = x)\n 2. \\<And>x.\n       \\<exists>a.\n          a \\<in> E \\<and>\n          (\\<exists>b.\n              b \\<in> E \\<and>\n              D (fst x) a \\<and>\n              Dla (fst x) b \\<and>\n              D (snd x) (\\<alpha> (fst x) b) \\<and>\n              (fst x \\<oplus> a, snd x \\<oplus> \\<alpha> (fst x) b) = x)\n 3. \\<And>e1 e2.\n       \\<lbrakk>fst e1 \\<in> E \\<and> snd e1 \\<in> E;\n        fst e2 \\<in> E \\<and> snd e2 \\<in> E;\n        D (fst e1) (fst e2) \\<and>\n        Dla (fst e1) (snd e2) \\<and>\n        D (snd e1) (\\<alpha> (fst e1) (snd e2))\\<rbrakk>\n       \\<Longrightarrow> e1 = e2", "apply (metis act_annir eq_fst_iff eq_snd_iff mem_Collect_eq partial_monoid_class.unitl_ex)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<exists>a.\n          a \\<in> E \\<and>\n          (\\<exists>b.\n              b \\<in> E \\<and>\n              D (fst x) a \\<and>\n              Dla (fst x) b \\<and>\n              D (snd x) (\\<alpha> (fst x) b) \\<and>\n              (fst x \\<oplus> a, snd x \\<oplus> \\<alpha> (fst x) b) = x)\n 2. \\<And>e1 e2.\n       \\<lbrakk>fst e1 \\<in> E \\<and> snd e1 \\<in> E;\n        fst e2 \\<in> E \\<and> snd e2 \\<in> E;\n        D (fst e1) (fst e2) \\<and>\n        Dla (fst e1) (snd e2) \\<and>\n        D (snd e1) (\\<alpha> (fst e1) (snd e2))\\<rbrakk>\n       \\<Longrightarrow> e1 = e2", "apply (metis act_annir eq_fst_iff eq_snd_iff partial_monoid_class.unitr_ex)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e1 e2.\n       \\<lbrakk>fst e1 \\<in> E \\<and> snd e1 \\<in> E;\n        fst e2 \\<in> E \\<and> snd e2 \\<in> E;\n        D (fst e1) (fst e2) \\<and>\n        Dla (fst e1) (snd e2) \\<and>\n        D (snd e1) (\\<alpha> (fst e1) (snd e2))\\<rbrakk>\n       \\<Longrightarrow> e1 = e2", "by (metis act_annir partial_monoid_class.units_eq prod_eqI)"], ["", "end"], ["", "end"]]}