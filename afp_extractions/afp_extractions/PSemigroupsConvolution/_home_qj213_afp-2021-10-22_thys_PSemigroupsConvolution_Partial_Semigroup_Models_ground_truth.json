{"file_name": "/home/qj213/afp-2021-10-22/thys/PSemigroupsConvolution/Partial_Semigroup_Models.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/PSemigroupsConvolution", "problem_names": ["lemma segm_sub_morph: \"snd (Rep_segment x) = fst (Rep_segment y) \\<Longrightarrow> segm x \\<union> segm y \\<le> segm (x \\<cdot> y)\"", "lemma \"snd (Rep_segment x) = fst (Rep_segment y) \\<Longrightarrow> segm x \\<union> segm y = segm (x \\<cdot> y)\"", "lemma segm_morph: \"snd (Rep_segment x::('a::lip_order \\<times> 'a::lip_order)) = fst (Rep_segment y) \n    \\<Longrightarrow> segm x \\<union> segm y = segm (x \\<cdot> y)\"", "lemma pfun_comm: \"ortho x y \\<Longrightarrow> x ++ y = y ++ x\"", "lemma pfun_canc: \"ortho z x \\<Longrightarrow> ortho z y \\<Longrightarrow> z ++ x = z ++ y \\<Longrightarrow> x = y\""], "translations": [["", "lemma segm_sub_morph: \"snd (Rep_segment x) = fst (Rep_segment y) \\<Longrightarrow> segm x \\<union> segm y \\<le> segm (x \\<cdot> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (Rep_segment x) = fst (Rep_segment y) \\<Longrightarrow>\n    segm x \\<union> segm y \\<subseteq> segm (x \\<oplus> y)", "apply (simp add: segm_def times_segment.rep_eq, safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>snd (Rep_segment x) = fst (Rep_segment y);\n        fst (Rep_segment x) \\<le> xa; xa \\<le> fst (Rep_segment y)\\<rbrakk>\n       \\<Longrightarrow> xa \\<le> snd (Rep_segment y)\n 2. \\<And>xa.\n       \\<lbrakk>snd (Rep_segment x) = fst (Rep_segment y);\n        fst (Rep_segment y) \\<le> xa; xa \\<le> snd (Rep_segment y)\\<rbrakk>\n       \\<Longrightarrow> fst (Rep_segment x) \\<le> xa", "using Rep_segment dual_order.trans"], ["proof (prove)\nusing this:\n  Rep_segment ?x \\<in> {x. fst x \\<le> snd x}\n  \\<lbrakk>?b \\<le> ?a; ?c \\<le> ?b\\<rbrakk> \\<Longrightarrow> ?c \\<le> ?a\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>snd (Rep_segment x) = fst (Rep_segment y);\n        fst (Rep_segment x) \\<le> xa; xa \\<le> fst (Rep_segment y)\\<rbrakk>\n       \\<Longrightarrow> xa \\<le> snd (Rep_segment y)\n 2. \\<And>xa.\n       \\<lbrakk>snd (Rep_segment x) = fst (Rep_segment y);\n        fst (Rep_segment y) \\<le> xa; xa \\<le> snd (Rep_segment y)\\<rbrakk>\n       \\<Longrightarrow> fst (Rep_segment x) \\<le> xa", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>snd (Rep_segment x) = fst (Rep_segment y);\n        fst (Rep_segment y) \\<le> xa; xa \\<le> snd (Rep_segment y)\\<rbrakk>\n       \\<Longrightarrow> fst (Rep_segment x) \\<le> xa", "by (metis (mono_tags, lifting) Rep_segment dual_order.trans mem_Collect_eq)"], ["", "text \\<open>The function segm is not generally a morphism.\\<close>"], ["", "lemma \"snd (Rep_segment x) = fst (Rep_segment y) \\<Longrightarrow> segm x \\<union> segm y = segm (x \\<cdot> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (Rep_segment x) = fst (Rep_segment y) \\<Longrightarrow>\n    segm x \\<union> segm y = segm (x \\<oplus> y)", "(* nitpick [expect=genuine] *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (Rep_segment x) = fst (Rep_segment y) \\<Longrightarrow>\n    segm x \\<union> segm y = segm (x \\<oplus> y)", "oops"], ["", "text \\<open>Intervals are segments over orders that satisfy Halpern and Shoham's  linear order property. This \nis still more general than linearity of the poset.\\<close>"], ["", "class lip_order = order +\n  assumes lip: \"x \\<le> y \\<Longrightarrow> (\\<forall>v w. (x \\<le> v \\<and> v \\<le> y \\<and> x \\<le> w \\<and> w \\<le> y \\<longrightarrow> v \\<le> w \\<or> w \\<le> v))\""], ["", "text \\<open>The function segm is now a morphism.\\<close>"], ["", "lemma segm_morph: \"snd (Rep_segment x::('a::lip_order \\<times> 'a::lip_order)) = fst (Rep_segment y) \n    \\<Longrightarrow> segm x \\<union> segm y = segm (x \\<cdot> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (Rep_segment x) = fst (Rep_segment y) \\<Longrightarrow>\n    segm x \\<union> segm y = segm (x \\<oplus> y)", "apply (simp add: segm_def times_segment_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (Rep_segment x) = fst (Rep_segment y) \\<Longrightarrow>\n    {ya.\n     fst (Rep_segment x) \\<le> ya \\<and>\n     ya \\<le> fst (Rep_segment y)} \\<union>\n    {ya. fst (Rep_segment y) \\<le> ya \\<and> ya \\<le> snd (Rep_segment y)} =\n    {ya.\n     fst (Rep_segment\n           (Abs_segment (fst (Rep_segment x), snd (Rep_segment y))))\n     \\<le> ya \\<and>\n     ya \\<le> snd (Rep_segment\n                    (Abs_segment\n                      (fst (Rep_segment x), snd (Rep_segment y))))}", "apply (transfer, clarsimp simp add: Abs_segment_inverse lip, safe)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a aa ba x.\n       \\<lbrakk>a \\<le> aa; aa \\<le> ba; a \\<le> x; x \\<le> aa\\<rbrakk>\n       \\<Longrightarrow> x \\<le> ba\n 2. \\<And>a aa ba x.\n       \\<lbrakk>a \\<le> aa; aa \\<le> ba; aa \\<le> x; x \\<le> ba\\<rbrakk>\n       \\<Longrightarrow> a \\<le> x\n 3. \\<And>a aa ba x.\n       \\<lbrakk>a \\<le> aa; aa \\<le> ba; a \\<le> x; x \\<le> ba;\n        \\<not> aa \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> aa", "apply force+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ba x.\n       \\<lbrakk>a \\<le> aa; aa \\<le> ba; a \\<le> x; x \\<le> ba;\n        \\<not> aa \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> aa", "by (meson lip order_trans)"], ["", "subsection \\<open>Cancellative PAM's of Partial Functions\\<close>"], ["", "text \\<open>We show that partial functions under disjoint union form a positive cancellative PAM. \nThis is interesting for modeling the heap in separation logic.\\<close>"], ["", "type_synonym 'a pfun = \"'a \\<Rightarrow> 'a option\""], ["", "definition ortho :: \"'a pfun \\<Rightarrow> 'a pfun \\<Rightarrow> bool\"\n  where \"ortho f g \\<equiv> dom f \\<inter> dom g = {}\""], ["", "lemma pfun_comm: \"ortho x y \\<Longrightarrow> x ++ y = y ++ x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ortho x y \\<Longrightarrow> x ++ y = y ++ x", "by (force simp: ortho_def intro!: map_add_comm)"], ["", "lemma pfun_canc: \"ortho z x \\<Longrightarrow> ortho z y \\<Longrightarrow> z ++ x = z ++ y \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ortho z x; ortho z y; z ++ x = z ++ y\\<rbrakk>\n    \\<Longrightarrow> x = y", "apply (auto simp: ortho_def map_add_def option.case_eq_if fun_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>dom z \\<inter> dom x = {}; dom z \\<inter> dom y = {};\n        \\<forall>xa.\n           (if x xa = None then z xa else Some (the (x xa))) =\n           (if y xa = None then z xa else Some (the (y xa)))\\<rbrakk>\n       \\<Longrightarrow> x xa = y xa", "by (metis domIff dom_restrict option.collapse restrict_map_def)"], ["", "interpretation pfun: positive_cancellative_pam_one map_add ortho \"{Map.empty}\" Map.empty"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.positive_cancellative_pam_one (++) ortho {Map.empty} Map.empty", "apply (standard, auto simp: ortho_def pfun_canc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x z y.\n       \\<lbrakk>dom x \\<inter> dom z = {}; dom y \\<inter> dom z = {};\n        x ++ z = y ++ z\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y. dom x \\<inter> dom y = {} \\<Longrightarrow> x ++ y = y ++ x", "by (simp_all add: inf_commute map_add_comm ortho_def pfun_canc)"], ["", "subsection \\<open>PAM's of Disjoint Unions of Sets\\<close>"], ["", "text \\<open>This simple disjoint union construction underlies important compositions of graphs or partial orders,\nin particular in the context of complete joins and disjoint unions of graphs and of series and parallel products\nof partial orders.\\<close>"], ["", "instantiation set :: (type) pas\nbegin"], ["", "definition D_set :: \"'a set \\<Rightarrow> 'a set \\<Rightarrow> bool\" where \n  \"D_set x y \\<equiv> x \\<inter> y = {}\""], ["", "definition times_set :: \"'a set \\<Rightarrow> 'a set \\<Rightarrow> 'a set\" where\n  \"times_set x y = x \\<union> y\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a set, pas_class)", "by standard (auto simp: D_set_def times_set_def)"], ["", "end"], ["", "instantiation set :: (type) pam\nbegin"], ["", "definition E_set :: \"'a set set\" where\n  \"E_set = {{}}\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a set, pam_class)", "by standard (auto simp: D_set_def times_set_def E_set_def)"], ["", "end"], ["", "end"]]}