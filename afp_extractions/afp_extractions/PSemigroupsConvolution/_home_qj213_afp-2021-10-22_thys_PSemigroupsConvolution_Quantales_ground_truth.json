{"file_name": "/home/qj213/afp-2021-10-22/thys/PSemigroupsConvolution/Quantales.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/PSemigroupsConvolution", "problem_names": ["lemma (in complete_lattice) Sup_sup_pred: \"x \\<squnion> \\<Squnion>{y. P y} = \\<Squnion>{y. y = x \\<or> P y}\"", "lemma (in complete_lattice) sup_Sup: \"x \\<squnion> y = \\<Squnion>{x,y}\"", "lemma (in complete_lattice) sup_Sup_var: \"x \\<squnion> y = \\<Squnion>{z. z \\<in> {x,y}}\"", "lemma (in complete_boolean_algebra) shunt1: \"x \\<sqinter> y \\<le> z \\<longleftrightarrow> x \\<le> -y \\<squnion> z\"", "lemma (in complete_boolean_algebra) meet_shunt: \"x \\<sqinter> y = \\<bottom> \\<longleftrightarrow> x \\<le> -y\"", "lemma (in complete_boolean_algebra) join_shunt: \"x \\<squnion> y = \\<top> \\<longleftrightarrow> -x \\<le> y\"", "lemma mult_botl [simp]: \"\\<bottom> \\<cdot> x = \\<bottom>\"", "lemma sup_distr: \"(x \\<squnion> y) \\<cdot> z = (x \\<cdot> z) \\<squnion> (y \\<cdot> z)\"", "lemma mult_isor: \"x \\<le> y \\<Longrightarrow> x \\<cdot> z \\<le> y \\<cdot> z\"", "lemma bres_galois_imp: \"x \\<cdot> y \\<le> z \\<longrightarrow> y \\<le> x \\<rightarrow> z\"", "lemma fres_galois: \"x \\<cdot> y \\<le> z \\<longleftrightarrow> x \\<le> z \\<leftarrow> y\"", "lemma sup_subdistl: \"(x \\<cdot> y) \\<squnion> (x \\<cdot> z) \\<le> x \\<cdot> (y \\<squnion> z)\"", "lemma mult_isol: \"x \\<le> y \\<Longrightarrow> z \\<cdot> x \\<le> z \\<cdot> y\"", "lemma  sup_distl: \"x \\<cdot> (y \\<squnion> z) = (x \\<cdot> y) \\<squnion> (x \\<cdot> z)\"", "lemma \"y \\<le> x \\<rightarrow> z \\<longrightarrow> x \\<cdot> y \\<le> z\"", "lemma bres_galois: \"x \\<cdot> y \\<le> z \\<longleftrightarrow> y \\<le> x \\<rightarrow> z\"", "lemma iter_ref [simp]: \"iter x \\<le> 1\"", "lemma le_top: \"x \\<le> \\<top> \\<cdot> x\"", "lemma (in weak_quantale) \"x \\<cdot> \\<bottom> = \\<bottom>\"", "lemma (in unital_weak_quantale) \"x \\<cdot> \\<bottom> = \\<bottom>\"", "lemma mult_botr [simp]: \"x \\<cdot> \\<bottom> = \\<bottom>\"", "lemma bres_fres_eq: \"x \\<rightarrow> y = y \\<leftarrow> x\"", "lemma cba_bres1: \"x \\<sqinter> y \\<le> z \\<longleftrightarrow> x \\<le> cba_quantale.bres y z\"", "lemma cba_bres2: \"x \\<le> -y \\<squnion> z \\<longleftrightarrow> x \\<le> cba_quantale.bres y z\"", "lemma cba_bres_prop: \"cba_quantale.bres x y = -x \\<squnion> y\"", "lemma act_morph1: \"\\<alpha> (x \\<cdot> y) = (\\<alpha> x) \\<circ> (\\<alpha> y)\"", "lemma act_morph2: \"\\<alpha> 1 = id\"", "lemma emp_act: \"\\<alpha> (\\<Squnion>{}) p = \\<bottom>\"", "lemma emp_act_var: \"\\<alpha> \\<bottom> p = \\<bottom>\"", "lemma act_emp: \"\\<alpha> x (\\<Squnion>{}) = \\<bottom>\"", "lemma act_emp_var: \"\\<alpha> x \\<bottom> = \\<bottom>\"", "lemma act_sup_distl: \"\\<alpha> x (p \\<squnion> q) = (\\<alpha> x p) \\<squnion> (\\<alpha> x q)\"", "lemma act_sup_distr: \"\\<alpha> (x \\<squnion> y) p = (\\<alpha> x p) \\<squnion> (\\<alpha> y p)\"", "lemma act_sup_distr_var: \"\\<alpha> (x \\<squnion> y) = (\\<alpha> x) \\<squnion> (\\<alpha> y)\"", "lemma sd_distr_aux: \n  \"\\<Squnion>{snd x |x. x \\<in> X} \\<squnion> \\<Squnion>{\\<alpha> (fst x) p |x. x \\<in> X} = \\<Squnion>{snd x \\<squnion> \\<alpha> (fst x) p |x. x \\<in> X}\"", "lemma sd_distr: \"sd_prod (Sup_prod X) y = Sup_prod {sd_prod x y |x. x \\<in> X}\"", "lemma sd_distl_aux: \"Y \\<noteq> {} \\<Longrightarrow> p \\<squnion> (\\<Squnion>{\\<alpha> x (snd y) |y. y \\<in> Y}) = \\<Squnion>{p \\<squnion> \\<alpha> x (snd y) |y. y \\<in> Y}\"", "lemma sd_distl: \"Y \\<noteq> {} \\<Longrightarrow> sd_prod x (Sup_prod Y) = Sup_prod {sd_prod x y |y. y \\<in> Y}\"", "lemma sd_unitl [simp]: \"sd_prod sd_unit x = x\"", "lemma sd_unitr [simp]: \"sd_prod x sd_unit = x\"", "lemma \"sd_prod x (Sup_prod Y) = Sup_prod {sd_prod x y |y. y \\<in> Y}\"", "lemma \"sd_prod x bot_prod = bot_prod\""], "translations": [["", "lemma (in complete_lattice) Sup_sup_pred: \"x \\<squnion> \\<Squnion>{y. P y} = \\<Squnion>{y. y = x \\<or> P y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> \\<Squnion>{y. P y} = \\<Squnion>{y. y = x \\<or> P y}", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<squnion> \\<Squnion>{y. P y} \\<le> \\<Squnion>{y. y = x \\<or> P y}\n 2. \\<Squnion>{y. y = x \\<or> P y} \\<le> x \\<squnion> \\<Squnion>{y. P y}", "apply (simp add: Collect_mono Sup_subset_mono Sup_upper)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion>{y. y = x \\<or> P y} \\<le> x \\<squnion> \\<Squnion>{y. P y}", "using Sup_least Sup_upper sup.coboundedI2"], ["proof (prove)\nusing this:\n  (\\<And>x. x \\<in> ?A \\<Longrightarrow> x \\<le> ?z) \\<Longrightarrow>\n  \\<Squnion>?A \\<le> ?z\n  ?x \\<in> ?A \\<Longrightarrow> ?x \\<le> \\<Squnion>?A\n  ?c \\<le> ?b \\<Longrightarrow> ?c \\<le> ?a \\<squnion> ?b\n\ngoal (1 subgoal):\n 1. \\<Squnion>{y. y = x \\<or> P y} \\<le> x \\<squnion> \\<Squnion>{y. P y}", "by force"], ["", "lemma (in complete_lattice) sup_Sup: \"x \\<squnion> y = \\<Squnion>{x,y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> y = \\<Squnion>{x, y}", "by simp"], ["", "lemma (in complete_lattice) sup_Sup_var: \"x \\<squnion> y = \\<Squnion>{z. z \\<in> {x,y}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> y = \\<Squnion>{z. z \\<in> {x, y}}", "by (metis Collect_mem_eq sup_Sup)"], ["", "lemma (in complete_boolean_algebra) shunt1: \"x \\<sqinter> y \\<le> z \\<longleftrightarrow> x \\<le> -y \\<squnion> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> y \\<le> z) = (x \\<le> - y \\<squnion> z)", "proof standard"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<sqinter> y \\<le> z \\<Longrightarrow> x \\<le> - y \\<squnion> z\n 2. x \\<le> - y \\<squnion> z \\<Longrightarrow> x \\<sqinter> y \\<le> z", "assume \"x \\<sqinter> y \\<le> z\""], ["proof (state)\nthis:\n  x \\<sqinter> y \\<le> z\n\ngoal (2 subgoals):\n 1. x \\<sqinter> y \\<le> z \\<Longrightarrow> x \\<le> - y \\<squnion> z\n 2. x \\<le> - y \\<squnion> z \\<Longrightarrow> x \\<sqinter> y \\<le> z", "hence  \"-y \\<squnion> (x \\<sqinter> y) \\<le> -y \\<squnion> z\""], ["proof (prove)\nusing this:\n  x \\<sqinter> y \\<le> z\n\ngoal (1 subgoal):\n 1. - y \\<squnion> (x \\<sqinter> y) \\<le> - y \\<squnion> z", "using sup.mono"], ["proof (prove)\nusing this:\n  x \\<sqinter> y \\<le> z\n  \\<lbrakk>?c \\<le> ?a; ?d \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> ?c \\<squnion> ?d \\<le> ?a \\<squnion> ?b\n\ngoal (1 subgoal):\n 1. - y \\<squnion> (x \\<sqinter> y) \\<le> - y \\<squnion> z", "by blast"], ["proof (state)\nthis:\n  - y \\<squnion> (x \\<sqinter> y) \\<le> - y \\<squnion> z\n\ngoal (2 subgoals):\n 1. x \\<sqinter> y \\<le> z \\<Longrightarrow> x \\<le> - y \\<squnion> z\n 2. x \\<le> - y \\<squnion> z \\<Longrightarrow> x \\<sqinter> y \\<le> z", "hence \"-y \\<squnion> x \\<le> -y \\<squnion> z\""], ["proof (prove)\nusing this:\n  - y \\<squnion> (x \\<sqinter> y) \\<le> - y \\<squnion> z\n\ngoal (1 subgoal):\n 1. - y \\<squnion> x \\<le> - y \\<squnion> z", "by (simp add: sup_inf_distrib1)"], ["proof (state)\nthis:\n  - y \\<squnion> x \\<le> - y \\<squnion> z\n\ngoal (2 subgoals):\n 1. x \\<sqinter> y \\<le> z \\<Longrightarrow> x \\<le> - y \\<squnion> z\n 2. x \\<le> - y \\<squnion> z \\<Longrightarrow> x \\<sqinter> y \\<le> z", "thus \"x \\<le> -y \\<squnion> z\""], ["proof (prove)\nusing this:\n  - y \\<squnion> x \\<le> - y \\<squnion> z\n\ngoal (1 subgoal):\n 1. x \\<le> - y \\<squnion> z", "by simp"], ["proof (state)\nthis:\n  x \\<le> - y \\<squnion> z\n\ngoal (1 subgoal):\n 1. x \\<le> - y \\<squnion> z \\<Longrightarrow> x \\<sqinter> y \\<le> z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<le> - y \\<squnion> z \\<Longrightarrow> x \\<sqinter> y \\<le> z", "assume \"x \\<le> - y \\<squnion> z\""], ["proof (state)\nthis:\n  x \\<le> - y \\<squnion> z\n\ngoal (1 subgoal):\n 1. x \\<le> - y \\<squnion> z \\<Longrightarrow> x \\<sqinter> y \\<le> z", "hence \"x \\<sqinter> y \\<le> (-y \\<squnion> z) \\<sqinter> y\""], ["proof (prove)\nusing this:\n  x \\<le> - y \\<squnion> z\n\ngoal (1 subgoal):\n 1. x \\<sqinter> y \\<le> - y \\<squnion> z \\<sqinter> y", "using inf_mono"], ["proof (prove)\nusing this:\n  x \\<le> - y \\<squnion> z\n  \\<lbrakk>?a \\<le> ?c; ?b \\<le> ?d\\<rbrakk>\n  \\<Longrightarrow> ?a \\<sqinter> ?b \\<le> ?c \\<sqinter> ?d\n\ngoal (1 subgoal):\n 1. x \\<sqinter> y \\<le> - y \\<squnion> z \\<sqinter> y", "by auto"], ["proof (state)\nthis:\n  x \\<sqinter> y \\<le> - y \\<squnion> z \\<sqinter> y\n\ngoal (1 subgoal):\n 1. x \\<le> - y \\<squnion> z \\<Longrightarrow> x \\<sqinter> y \\<le> z", "thus  \"x \\<sqinter> y \\<le> z\""], ["proof (prove)\nusing this:\n  x \\<sqinter> y \\<le> - y \\<squnion> z \\<sqinter> y\n\ngoal (1 subgoal):\n 1. x \\<sqinter> y \\<le> z", "using inf.boundedE inf_sup_distrib2"], ["proof (prove)\nusing this:\n  x \\<sqinter> y \\<le> - y \\<squnion> z \\<sqinter> y\n  \\<lbrakk>?a \\<le> ?b \\<sqinter> ?c;\n   \\<lbrakk>?a \\<le> ?b; ?a \\<le> ?c\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  ?y \\<squnion> ?z \\<sqinter> ?x =\n  (?y \\<sqinter> ?x) \\<squnion> (?z \\<sqinter> ?x)\n\ngoal (1 subgoal):\n 1. x \\<sqinter> y \\<le> z", "by auto"], ["proof (state)\nthis:\n  x \\<sqinter> y \\<le> z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in complete_boolean_algebra) meet_shunt: \"x \\<sqinter> y = \\<bottom> \\<longleftrightarrow> x \\<le> -y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> y = \\<bottom>) = (x \\<le> - y)", "by (metis bot_least inf_absorb2 inf_compl_bot_left2 shunt1 sup_absorb1)"], ["", "lemma (in complete_boolean_algebra) join_shunt: \"x \\<squnion> y = \\<top> \\<longleftrightarrow> -x \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y = \\<top>) = (- x \\<le> y)", "by (metis compl_sup compl_top_eq double_compl meet_shunt)"], ["", "subsection \\<open> Familes of Proto-Quantales\\<close>"], ["", "text \\<open>Proto-Quanales are complete lattices equipped with an operation of composition or multiplication\nthat need not be associative.\\<close>"], ["", "class proto_near_quantale = complete_lattice + times + \n  assumes Sup_distr: \"\\<Squnion>X \\<cdot> y = \\<Squnion>{x \\<cdot> y |x. x \\<in> X}\"\n    \nbegin"], ["", "lemma mult_botl [simp]: \"\\<bottom> \\<cdot> x = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom> \\<cdot> x = \\<bottom>", "using Sup_distr[where X=\"{}\"]"], ["proof (prove)\nusing this:\n  \\<Squnion>{} \\<cdot> ?y = \\<Squnion>{x \\<cdot> ?y |x. x \\<in> {}}\n\ngoal (1 subgoal):\n 1. \\<bottom> \\<cdot> x = \\<bottom>", "by auto"], ["", "lemma sup_distr: \"(x \\<squnion> y) \\<cdot> z = (x \\<cdot> z) \\<squnion> (y \\<cdot> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y) \\<cdot> z = x \\<cdot> z \\<squnion> y \\<cdot> z", "using Sup_distr[where X=\"{x, y}\"]"], ["proof (prove)\nusing this:\n  \\<Squnion>{x, y} \\<cdot> ?y =\n  \\<Squnion>{xa \\<cdot> ?y |xa. xa \\<in> {x, y}}\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y) \\<cdot> z = x \\<cdot> z \\<squnion> y \\<cdot> z", "by (fastforce intro!: Sup_eqI)"], ["", "lemma mult_isor: \"x \\<le> y \\<Longrightarrow> x \\<cdot> z \\<le> y \\<cdot> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> x \\<cdot> z \\<le> y \\<cdot> z", "by (metis sup.absorb_iff1 sup_distr)"], ["", "definition bres :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a\" (infixr \"\\<rightarrow>\" 60) where \n  \"x \\<rightarrow> z = \\<Squnion>{y. x \\<cdot> y \\<le> z}\""], ["", "definition fres :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a\" (infixl \"\\<leftarrow>\" 60) where \n  \"z \\<leftarrow> y = \\<Squnion>{x. x \\<cdot> y \\<le> z}\""], ["", "lemma bres_galois_imp: \"x \\<cdot> y \\<le> z \\<longrightarrow> y \\<le> x \\<rightarrow> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<cdot> y \\<le> z \\<longrightarrow> y \\<le> x \\<rightarrow> z", "by (simp add: Sup_upper bres_def)"], ["", "lemma fres_galois: \"x \\<cdot> y \\<le> z \\<longleftrightarrow> x \\<le> z \\<leftarrow> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<cdot> y \\<le> z) = (x \\<le> z \\<leftarrow> y)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<cdot> y \\<le> z \\<Longrightarrow> x \\<le> z \\<leftarrow> y\n 2. x \\<le> z \\<leftarrow> y \\<Longrightarrow> x \\<cdot> y \\<le> z", "show \"x \\<cdot> y \\<le> z \\<Longrightarrow> x \\<le> z \\<leftarrow> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<cdot> y \\<le> z \\<Longrightarrow> x \\<le> z \\<leftarrow> y", "by (simp add: Sup_upper fres_def)"], ["proof (state)\nthis:\n  x \\<cdot> y \\<le> z \\<Longrightarrow> x \\<le> z \\<leftarrow> y\n\ngoal (1 subgoal):\n 1. x \\<le> z \\<leftarrow> y \\<Longrightarrow> x \\<cdot> y \\<le> z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<le> z \\<leftarrow> y \\<Longrightarrow> x \\<cdot> y \\<le> z", "assume \"x \\<le> z \\<leftarrow> y\""], ["proof (state)\nthis:\n  x \\<le> z \\<leftarrow> y\n\ngoal (1 subgoal):\n 1. x \\<le> z \\<leftarrow> y \\<Longrightarrow> x \\<cdot> y \\<le> z", "hence \"x \\<cdot> y \\<le> \\<Squnion>{x. x \\<cdot> y \\<le> z} \\<cdot> y\""], ["proof (prove)\nusing this:\n  x \\<le> z \\<leftarrow> y\n\ngoal (1 subgoal):\n 1. x \\<cdot> y \\<le> \\<Squnion>{x. x \\<cdot> y \\<le> z} \\<cdot> y", "by (simp add: fres_def mult_isor)"], ["proof (state)\nthis:\n  x \\<cdot> y \\<le> \\<Squnion>{x. x \\<cdot> y \\<le> z} \\<cdot> y\n\ngoal (1 subgoal):\n 1. x \\<le> z \\<leftarrow> y \\<Longrightarrow> x \\<cdot> y \\<le> z", "also"], ["proof (state)\nthis:\n  x \\<cdot> y \\<le> \\<Squnion>{x. x \\<cdot> y \\<le> z} \\<cdot> y\n\ngoal (1 subgoal):\n 1. x \\<le> z \\<leftarrow> y \\<Longrightarrow> x \\<cdot> y \\<le> z", "have \"... = \\<Squnion>{x \\<cdot> y |x. x \\<cdot> y \\<le> z}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion>{x. x \\<cdot> y \\<le> z} \\<cdot> y =\n    \\<Squnion>{x \\<cdot> y |x. x \\<cdot> y \\<le> z}", "by (simp add: Sup_distr)"], ["proof (state)\nthis:\n  \\<Squnion>{x. x \\<cdot> y \\<le> z} \\<cdot> y =\n  \\<Squnion>{x \\<cdot> y |x. x \\<cdot> y \\<le> z}\n\ngoal (1 subgoal):\n 1. x \\<le> z \\<leftarrow> y \\<Longrightarrow> x \\<cdot> y \\<le> z", "also"], ["proof (state)\nthis:\n  \\<Squnion>{x. x \\<cdot> y \\<le> z} \\<cdot> y =\n  \\<Squnion>{x \\<cdot> y |x. x \\<cdot> y \\<le> z}\n\ngoal (1 subgoal):\n 1. x \\<le> z \\<leftarrow> y \\<Longrightarrow> x \\<cdot> y \\<le> z", "have \"... \\<le> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion>{x \\<cdot> y |x. x \\<cdot> y \\<le> z} \\<le> z", "by (rule Sup_least, auto)"], ["proof (state)\nthis:\n  \\<Squnion>{x \\<cdot> y |x. x \\<cdot> y \\<le> z} \\<le> z\n\ngoal (1 subgoal):\n 1. x \\<le> z \\<leftarrow> y \\<Longrightarrow> x \\<cdot> y \\<le> z", "finally"], ["proof (chain)\npicking this:\n  x \\<cdot> y \\<le> z", "show \"x \\<cdot> y \\<le> z\""], ["proof (prove)\nusing this:\n  x \\<cdot> y \\<le> z\n\ngoal (1 subgoal):\n 1. x \\<cdot> y \\<le> z", "."], ["proof (state)\nthis:\n  x \\<cdot> y \\<le> z\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "class proto_pre_quantale = proto_near_quantale + \n  assumes Sup_subdistl: \"\\<Squnion>{x \\<cdot> y | y . y \\<in> Y} \\<le> x \\<cdot> \\<Squnion>Y\"\n    \nbegin"], ["", "lemma sup_subdistl: \"(x \\<cdot> y) \\<squnion> (x \\<cdot> z) \\<le> x \\<cdot> (y \\<squnion> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<cdot> y \\<squnion> x \\<cdot> z \\<le> x \\<cdot> (y \\<squnion> z)", "using Sup_subdistl[where Y=\"{y, z}\"] Sup_le_iff"], ["proof (prove)\nusing this:\n  \\<Squnion>{?x \\<cdot> ya |ya. ya \\<in> {y, z}}\n  \\<le> ?x \\<cdot> \\<Squnion>{y, z}\n  (\\<Squnion>?A \\<le> ?b) = (\\<forall>a\\<in>?A. a \\<le> ?b)\n\ngoal (1 subgoal):\n 1. x \\<cdot> y \\<squnion> x \\<cdot> z \\<le> x \\<cdot> (y \\<squnion> z)", "by auto"], ["", "lemma mult_isol: \"x \\<le> y \\<Longrightarrow> z \\<cdot> x \\<le> z \\<cdot> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> z \\<cdot> x \\<le> z \\<cdot> y", "by (metis le_iff_sup le_sup_iff sup_subdistl)"], ["", "end"], ["", "class weak_proto_quantale = proto_near_quantale +\n  assumes weak_Sup_distl: \"Y \\<noteq> {} \\<Longrightarrow> x \\<cdot> \\<Squnion>Y = \\<Squnion>{x \\<cdot> y |y. y \\<in> Y}\" \n  \nbegin"], ["", "subclass proto_pre_quantale"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.proto_pre_quantale Inf Sup (\\<sqinter>) (\\<le>) (<) (\\<squnion>)\n     \\<bottom> \\<top> (\\<cdot>)", "proof standard"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x Y.\n       \\<Squnion>{x \\<cdot> y |y. y \\<in> Y} \\<le> x \\<cdot> \\<Squnion>Y", "have a: \"\\<And>x Y. Y = {} \\<Longrightarrow> \\<Squnion>{x \\<cdot> y |y. y \\<in> Y} \\<le> x \\<cdot> \\<Squnion>Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x Y.\n       Y = {} \\<Longrightarrow>\n       \\<Squnion>{x \\<cdot> y |y. y \\<in> Y} \\<le> x \\<cdot> \\<Squnion>Y", "by simp"], ["proof (state)\nthis:\n  ?Y = {} \\<Longrightarrow>\n  \\<Squnion>{?x \\<cdot> y |y. y \\<in> ?Y} \\<le> ?x \\<cdot> \\<Squnion>?Y\n\ngoal (1 subgoal):\n 1. \\<And>x Y.\n       \\<Squnion>{x \\<cdot> y |y. y \\<in> Y} \\<le> x \\<cdot> \\<Squnion>Y", "have b: \"\\<And>x Y. Y \\<noteq> {} \\<Longrightarrow> \\<Squnion>{x \\<cdot> y |y. y \\<in> Y} \\<le> x \\<cdot> \\<Squnion>Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x Y.\n       Y \\<noteq> {} \\<Longrightarrow>\n       \\<Squnion>{x \\<cdot> y |y. y \\<in> Y} \\<le> x \\<cdot> \\<Squnion>Y", "by (simp add: weak_Sup_distl)"], ["proof (state)\nthis:\n  ?Y \\<noteq> {} \\<Longrightarrow>\n  \\<Squnion>{?x \\<cdot> y |y. y \\<in> ?Y} \\<le> ?x \\<cdot> \\<Squnion>?Y\n\ngoal (1 subgoal):\n 1. \\<And>x Y.\n       \\<Squnion>{x \\<cdot> y |y. y \\<in> Y} \\<le> x \\<cdot> \\<Squnion>Y", "show  \"\\<And>x Y. \\<Squnion>{x \\<cdot> y |y. y \\<in> Y} \\<le> x \\<cdot> \\<Squnion>Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x Y.\n       \\<Squnion>{x \\<cdot> y |y. y \\<in> Y} \\<le> x \\<cdot> \\<Squnion>Y", "using a b"], ["proof (prove)\nusing this:\n  ?Y = {} \\<Longrightarrow>\n  \\<Squnion>{?x \\<cdot> y |y. y \\<in> ?Y} \\<le> ?x \\<cdot> \\<Squnion>?Y\n  ?Y \\<noteq> {} \\<Longrightarrow>\n  \\<Squnion>{?x \\<cdot> y |y. y \\<in> ?Y} \\<le> ?x \\<cdot> \\<Squnion>?Y\n\ngoal (1 subgoal):\n 1. \\<And>x Y.\n       \\<Squnion>{x \\<cdot> y |y. y \\<in> Y} \\<le> x \\<cdot> \\<Squnion>Y", "by blast"], ["proof (state)\nthis:\n  \\<Squnion>{?x \\<cdot> y |y. y \\<in> ?Y} \\<le> ?x \\<cdot> \\<Squnion>?Y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma  sup_distl: \"x \\<cdot> (y \\<squnion> z) = (x \\<cdot> y) \\<squnion> (x \\<cdot> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<cdot> (y \\<squnion> z) = x \\<cdot> y \\<squnion> x \\<cdot> z", "using weak_Sup_distl[where Y=\"{y, z}\"]"], ["proof (prove)\nusing this:\n  {y, z} \\<noteq> {} \\<Longrightarrow>\n  ?x \\<cdot> \\<Squnion>{y, z} =\n  \\<Squnion>{?x \\<cdot> ya |ya. ya \\<in> {y, z}}\n\ngoal (1 subgoal):\n 1. x \\<cdot> (y \\<squnion> z) = x \\<cdot> y \\<squnion> x \\<cdot> z", "by (fastforce intro!: Sup_eqI)"], ["", "lemma \"y \\<le> x \\<rightarrow> z \\<longrightarrow> x \\<cdot> y \\<le> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> x \\<rightarrow> z \\<longrightarrow> x \\<cdot> y \\<le> z", "(* nitpick [expect = genuine] *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> x \\<rightarrow> z \\<longrightarrow> x \\<cdot> y \\<le> z", "oops"], ["", "end"], ["", "class proto_quantale = proto_near_quantale +\n  assumes Sup_distl: \"x \\<cdot> \\<Squnion>Y = \\<Squnion>{x \\<cdot> y |y. y \\<in> Y}\"  \n\nbegin"], ["", "subclass weak_proto_quantale"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.weak_proto_quantale Inf Sup (\\<sqinter>) (\\<le>) (<) (\\<squnion>)\n     \\<bottom> \\<top> (\\<cdot>)", "by standard (simp add: Sup_distl)"], ["", "lemma bres_galois: \"x \\<cdot> y \\<le> z \\<longleftrightarrow> y \\<le> x \\<rightarrow> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<cdot> y \\<le> z) = (y \\<le> x \\<rightarrow> z)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<cdot> y \\<le> z \\<Longrightarrow> y \\<le> x \\<rightarrow> z\n 2. y \\<le> x \\<rightarrow> z \\<Longrightarrow> x \\<cdot> y \\<le> z", "show \"x \\<cdot> y \\<le> z \\<Longrightarrow> y \\<le> x \\<rightarrow> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<cdot> y \\<le> z \\<Longrightarrow> y \\<le> x \\<rightarrow> z", "by (simp add: Sup_upper bres_def)"], ["proof (state)\nthis:\n  x \\<cdot> y \\<le> z \\<Longrightarrow> y \\<le> x \\<rightarrow> z\n\ngoal (1 subgoal):\n 1. y \\<le> x \\<rightarrow> z \\<Longrightarrow> x \\<cdot> y \\<le> z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<le> x \\<rightarrow> z \\<Longrightarrow> x \\<cdot> y \\<le> z", "assume \"y \\<le> x \\<rightarrow> z\""], ["proof (state)\nthis:\n  y \\<le> x \\<rightarrow> z\n\ngoal (1 subgoal):\n 1. y \\<le> x \\<rightarrow> z \\<Longrightarrow> x \\<cdot> y \\<le> z", "hence \"x \\<cdot> y \\<le> x \\<cdot> \\<Squnion>{y. x \\<cdot> y \\<le> z}\""], ["proof (prove)\nusing this:\n  y \\<le> x \\<rightarrow> z\n\ngoal (1 subgoal):\n 1. x \\<cdot> y \\<le> x \\<cdot> \\<Squnion>{y. x \\<cdot> y \\<le> z}", "by (simp add: bres_def mult_isol)"], ["proof (state)\nthis:\n  x \\<cdot> y \\<le> x \\<cdot> \\<Squnion>{y. x \\<cdot> y \\<le> z}\n\ngoal (1 subgoal):\n 1. y \\<le> x \\<rightarrow> z \\<Longrightarrow> x \\<cdot> y \\<le> z", "also"], ["proof (state)\nthis:\n  x \\<cdot> y \\<le> x \\<cdot> \\<Squnion>{y. x \\<cdot> y \\<le> z}\n\ngoal (1 subgoal):\n 1. y \\<le> x \\<rightarrow> z \\<Longrightarrow> x \\<cdot> y \\<le> z", "have \"... = \\<Squnion>{x \\<cdot> y |y. x \\<cdot> y \\<le> z}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<cdot> \\<Squnion>{y. x \\<cdot> y \\<le> z} =\n    \\<Squnion>{x \\<cdot> y |y. x \\<cdot> y \\<le> z}", "by (simp add: Sup_distl)"], ["proof (state)\nthis:\n  x \\<cdot> \\<Squnion>{y. x \\<cdot> y \\<le> z} =\n  \\<Squnion>{x \\<cdot> y |y. x \\<cdot> y \\<le> z}\n\ngoal (1 subgoal):\n 1. y \\<le> x \\<rightarrow> z \\<Longrightarrow> x \\<cdot> y \\<le> z", "also"], ["proof (state)\nthis:\n  x \\<cdot> \\<Squnion>{y. x \\<cdot> y \\<le> z} =\n  \\<Squnion>{x \\<cdot> y |y. x \\<cdot> y \\<le> z}\n\ngoal (1 subgoal):\n 1. y \\<le> x \\<rightarrow> z \\<Longrightarrow> x \\<cdot> y \\<le> z", "have \"... \\<le> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion>{x \\<cdot> y |y. x \\<cdot> y \\<le> z} \\<le> z", "by (rule Sup_least, auto)"], ["proof (state)\nthis:\n  \\<Squnion>{x \\<cdot> y |y. x \\<cdot> y \\<le> z} \\<le> z\n\ngoal (1 subgoal):\n 1. y \\<le> x \\<rightarrow> z \\<Longrightarrow> x \\<cdot> y \\<le> z", "finally"], ["proof (chain)\npicking this:\n  x \\<cdot> y \\<le> z", "show \"x \\<cdot> y \\<le> z\""], ["proof (prove)\nusing this:\n  x \\<cdot> y \\<le> z\n\ngoal (1 subgoal):\n 1. x \\<cdot> y \\<le> z", "."], ["proof (state)\nthis:\n  x \\<cdot> y \\<le> z\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Families of Quantales\\<close>"], ["", "class near_quantale = proto_near_quantale + semigroup_mult"], ["", "class unital_near_quantale = near_quantale + monoid_mult\n\nbegin"], ["", "definition iter :: \"'a \\<Rightarrow> 'a\" where\n  \"iter x \\<equiv> \\<Sqinter>{y. \\<exists>i. y = x ^ i}\""], ["", "lemma iter_ref [simp]: \"iter x \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iter x \\<le> (1::'a)", "apply (simp add: iter_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter>{y. \\<exists>i. y = x ^ i} \\<le> (1::'a)", "by (metis (mono_tags, lifting) Inf_lower local.power.power_0 mem_Collect_eq)"], ["", "lemma le_top: \"x \\<le> \\<top> \\<cdot> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> \\<top> \\<cdot> x", "by (metis mult_isor mult.monoid_axioms top_greatest monoid.left_neutral)"], ["", "end"], ["", "class pre_quantale = proto_pre_quantale + semigroup_mult"], ["", "subclass (in pre_quantale) near_quantale"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.near_quantale (\\<cdot>) Inf Sup (\\<sqinter>) (\\<le>) (<)\n     (\\<squnion>) \\<bottom> \\<top>", ".."], ["", "class unital_pre_quantale = pre_quantale + monoid_mult"], ["", "subclass (in unital_pre_quantale) unital_near_quantale"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.unital_near_quantale (1::'a) (\\<cdot>) Inf Sup (\\<sqinter>)\n     (\\<le>) (<) (\\<squnion>) \\<bottom> \\<top>", ".."], ["", "class weak_quantale = weak_proto_quantale + semigroup_mult"], ["", "subclass (in weak_quantale) pre_quantale"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.pre_quantale (\\<cdot>) Inf Sup (\\<sqinter>) (\\<le>) (<)\n     (\\<squnion>) \\<bottom> \\<top>", ".."], ["", "text \\<open>The following counterexample shows an important consequence of weakness: \nthe absence of right annihilation.\\<close>"], ["", "lemma (in weak_quantale) \"x \\<cdot> \\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<cdot> \\<bottom> = \\<bottom>", "(*nitpick[expect=genuine]*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<cdot> \\<bottom> = \\<bottom>", "oops"], ["", "class unital_weak_quantale = weak_quantale + monoid_mult"], ["", "lemma (in unital_weak_quantale) \"x \\<cdot> \\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<cdot> \\<bottom> = \\<bottom>", "(*nitpick[expect=genuine]*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<cdot> \\<bottom> = \\<bottom>", "oops"], ["", "subclass (in unital_weak_quantale) unital_pre_quantale"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.unital_pre_quantale (1::'a) (\\<cdot>) Inf Sup (\\<sqinter>) (\\<le>)\n     (<) (\\<squnion>) \\<bottom> \\<top>", ".."], ["", "class quantale = proto_quantale + semigroup_mult \n  \nbegin"], ["", "subclass weak_quantale"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.weak_quantale (\\<cdot>) Inf Sup (\\<sqinter>) (\\<le>) (<)\n     (\\<squnion>) \\<bottom> \\<top>", ".."], ["", "lemma mult_botr [simp]: \"x \\<cdot> \\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<cdot> \\<bottom> = \\<bottom>", "using Sup_distl[where Y=\"{}\"]"], ["proof (prove)\nusing this:\n  ?x \\<cdot> \\<Squnion>{} = \\<Squnion>{?x \\<cdot> y |y. y \\<in> {}}\n\ngoal (1 subgoal):\n 1. x \\<cdot> \\<bottom> = \\<bottom>", "by auto"], ["", "end"], ["", "class unital_quantale = quantale + monoid_mult"], ["", "subclass (in unital_quantale) unital_weak_quantale"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.unital_weak_quantale (1::'a) (\\<cdot>) Inf Sup (\\<sqinter>)\n     (\\<le>) (<) (\\<squnion>) \\<bottom> \\<top>", ".."], ["", "class ab_quantale = quantale + ab_semigroup_mult\n\nbegin"], ["", "lemma bres_fres_eq: \"x \\<rightarrow> y = y \\<leftarrow> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<rightarrow> y = y \\<leftarrow> x", "by (simp add: fres_def bres_def mult_commute)"], ["", "end"], ["", "class ab_unital_quantale = ab_quantale + unital_quantale"], ["", "class distrib_quantale = quantale + complete_distrib_lattice"], ["", "class bool_quantale = quantale + complete_boolean_algebra"], ["", "class distrib_unital_quantale = unital_quantale + complete_distrib_lattice"], ["", "class bool_unital_quantale = unital_quantale + complete_boolean_algebra"], ["", "class distrib_ab_quantale = distrib_quantale + ab_quantale"], ["", "class bool_ab_quantale = bool_quantale + ab_quantale"], ["", "class distrib_ab_unital_quantale = distrib_quantale + unital_quantale"], ["", "class bool_ab_unital_quantale = bool_ab_quantale + unital_quantale"], ["", "subsection \\<open>Quantales of Booleans and Complete Boolean Algebras\\<close>"], ["", "instantiation bool :: bool_ab_unital_quantale\nbegin"], ["", "definition \"one_bool = True\""], ["", "definition \"times_bool = (\\<lambda>x y. x \\<and> y)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(bool, bool_ab_unital_quantale_class)", "by standard (auto simp: times_bool_def one_bool_def)"], ["", "end"], ["", "context complete_distrib_lattice\nbegin"], ["", "interpretation cdl_quantale: distrib_quantale _ _ _ _ _ _ _ _ inf"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.distrib_quantale Inf Sup (\\<sqinter>) (\\<le>) (<) (\\<squnion>)\n     \\<bottom> \\<top> (\\<sqinter>)", "by standard (simp_all add: inf.assoc Setcompr_eq_image Sup_inf inf_Sup)"], ["", "end"], ["", "context complete_boolean_algebra\nbegin"], ["", "interpretation cba_quantale: bool_ab_unital_quantale inf _ _ _ _ _ _ _ _ _ _ top"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.bool_ab_unital_quantale (\\<sqinter>) Inf Sup (\\<sqinter>) (\\<le>)\n     (<) (\\<squnion>) \\<bottom> \\<top> (-) uminus \\<top>", "apply standard"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a b c. a \\<sqinter> b \\<sqinter> c = a \\<sqinter> (b \\<sqinter> c)\n 2. \\<And>a b. a \\<sqinter> b = b \\<sqinter> a\n 3. \\<And>X y.\n       \\<Squnion>X \\<sqinter> y = \\<Squnion>{x \\<sqinter> y |x. x \\<in> X}\n 4. \\<And>x Y.\n       x \\<sqinter> \\<Squnion>Y = \\<Squnion>{x \\<sqinter> y |y. y \\<in> Y}\n 5. \\<And>a. \\<top> \\<sqinter> a = a\n 6. \\<And>a. a \\<sqinter> \\<top> = a", "apply (simp add: inf.assoc)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b. a \\<sqinter> b = b \\<sqinter> a\n 2. \\<And>X y.\n       \\<Squnion>X \\<sqinter> y = \\<Squnion>{x \\<sqinter> y |x. x \\<in> X}\n 3. \\<And>x Y.\n       x \\<sqinter> \\<Squnion>Y = \\<Squnion>{x \\<sqinter> y |y. y \\<in> Y}\n 4. \\<And>a. \\<top> \\<sqinter> a = a\n 5. \\<And>a. a \\<sqinter> \\<top> = a", "apply (simp add: inf.commute)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>X y.\n       \\<Squnion>X \\<sqinter> y = \\<Squnion>{x \\<sqinter> y |x. x \\<in> X}\n 2. \\<And>x Y.\n       x \\<sqinter> \\<Squnion>Y = \\<Squnion>{x \\<sqinter> y |y. y \\<in> Y}\n 3. \\<And>a. \\<top> \\<sqinter> a = a\n 4. \\<And>a. a \\<sqinter> \\<top> = a", "apply (simp add: Setcompr_eq_image Sup_inf)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x Y.\n       x \\<sqinter> \\<Squnion>Y = \\<Squnion>{x \\<sqinter> y |y. y \\<in> Y}\n 2. \\<And>a. \\<top> \\<sqinter> a = a\n 3. \\<And>a. a \\<sqinter> \\<top> = a", "apply (simp add: Setcompr_eq_image inf_Sup)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a. \\<top> \\<sqinter> a = a\n 2. \\<And>a. a \\<sqinter> \\<top> = a", "by simp_all"], ["", "text \\<open>In this setting, residuation can be translated like classical implication.\\<close>"], ["", "lemma cba_bres1: \"x \\<sqinter> y \\<le> z \\<longleftrightarrow> x \\<le> cba_quantale.bres y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> y \\<le> z) =\n    (x \\<le> proto_near_quantale.bres Sup (\\<le>) (\\<sqinter>) y z)", "using cba_quantale.bres_galois inf.commute"], ["proof (prove)\nusing this:\n  (?x \\<sqinter> ?y \\<le> ?z) =\n  (?y \\<le> proto_near_quantale.bres Sup (\\<le>) (\\<sqinter>) ?x ?z)\n  ?a \\<sqinter> ?b = ?b \\<sqinter> ?a\n\ngoal (1 subgoal):\n 1. (x \\<sqinter> y \\<le> z) =\n    (x \\<le> proto_near_quantale.bres Sup (\\<le>) (\\<sqinter>) y z)", "by fastforce"], ["", "lemma cba_bres2: \"x \\<le> -y \\<squnion> z \\<longleftrightarrow> x \\<le> cba_quantale.bres y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> - y \\<squnion> z) =\n    (x \\<le> proto_near_quantale.bres Sup (\\<le>) (\\<sqinter>) y z)", "using cba_bres1 shunt1"], ["proof (prove)\nusing this:\n  (?x \\<sqinter> ?y \\<le> ?z) =\n  (?x \\<le> proto_near_quantale.bres Sup (\\<le>) (\\<sqinter>) ?y ?z)\n  (?x \\<sqinter> ?y \\<le> ?z) = (?x \\<le> - ?y \\<squnion> ?z)\n\ngoal (1 subgoal):\n 1. (x \\<le> - y \\<squnion> z) =\n    (x \\<le> proto_near_quantale.bres Sup (\\<le>) (\\<sqinter>) y z)", "by auto"], ["", "lemma cba_bres_prop: \"cba_quantale.bres x y = -x \\<squnion> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proto_near_quantale.bres Sup (\\<le>) (\\<sqinter>) x y = - x \\<squnion> y", "using cba_bres2 eq_iff"], ["proof (prove)\nusing this:\n  (?x \\<le> - ?y \\<squnion> ?z) =\n  (?x \\<le> proto_near_quantale.bres Sup (\\<le>) (\\<sqinter>) ?y ?z)\n  (?x = ?y) = (?x \\<le> ?y \\<and> ?y \\<le> ?x)\n\ngoal (1 subgoal):\n 1. proto_near_quantale.bres Sup (\\<le>) (\\<sqinter>) x y = - x \\<squnion> y", "by blast"], ["", "end"], ["", "text \\<open>Other models will follow.\\<close>"], ["", "subsection \\<open>Products of Quantales\\<close>"], ["", "definition \"Inf_prod X = (\\<Sqinter>{fst x |x. x \\<in> X}, \\<Sqinter>{snd x |x.  x \\<in> X})\""], ["", "definition \"inf_prod x y = (fst x \\<sqinter> fst y, snd x \\<sqinter> snd y)\""], ["", "definition \"bot_prod = (bot,bot)\""], ["", "definition \"Sup_prod X = (\\<Squnion>{fst x |x. x \\<in> X}, \\<Squnion>{snd x |x.  x \\<in> X})\""], ["", "definition \"sup_prod x y = (fst x \\<squnion> fst y, snd x \\<squnion> snd y)\""], ["", "definition \"top_prod = (top,top)\""], ["", "definition \"less_eq_prod x y \\<equiv> less_eq (fst x) (fst y) \\<and> less_eq (snd x) (snd y)\""], ["", "definition \"less_prod x y \\<equiv> less_eq (fst x) (fst y) \\<and> less_eq (snd x) (snd y) \\<and> x \\<noteq> y\""], ["", "definition \"times_prod' x y = (fst x \\<cdot> fst y, snd x \\<cdot> snd y)\""], ["", "definition \"one_prod = (1,1)\""], ["", "interpretation prod: complete_lattice Inf_prod Sup_prod inf_prod less_eq_prod less_prod sup_prod bot_prod \"top_prod :: ('a::complete_lattice \\<times> 'b::complete_lattice)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.complete_lattice Inf_prod Sup_prod inf_prod less_eq_prod less_prod\n     sup_prod bot_prod top_prod", "apply standard"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>x y.\n       less_prod x y = (less_eq_prod x y \\<and> \\<not> less_eq_prod y x)\n 2. \\<And>x. less_eq_prod x x\n 3. \\<And>x y z.\n       \\<lbrakk>less_eq_prod x y; less_eq_prod y z\\<rbrakk>\n       \\<Longrightarrow> less_eq_prod x z\n 4. \\<And>x y.\n       \\<lbrakk>less_eq_prod x y; less_eq_prod y x\\<rbrakk>\n       \\<Longrightarrow> x = y\n 5. \\<And>x y. less_eq_prod (inf_prod x y) x\n 6. \\<And>x y. less_eq_prod (inf_prod x y) y\n 7. \\<And>x y z.\n       \\<lbrakk>less_eq_prod x y; less_eq_prod x z\\<rbrakk>\n       \\<Longrightarrow> less_eq_prod x (inf_prod y z)\n 8. \\<And>x y. less_eq_prod x (sup_prod x y)\n 9. \\<And>y x. less_eq_prod y (sup_prod x y)\n 10. \\<And>y x z.\n        \\<lbrakk>less_eq_prod y x; less_eq_prod z x\\<rbrakk>\n        \\<Longrightarrow> less_eq_prod (sup_prod y z) x\nA total of 16 subgoals...", "apply (simp_all add: Inf_prod_def Sup_prod_def inf_prod_def sup_prod_def bot_prod_def top_prod_def less_eq_prod_def less_prod_def Sup_distl Sup_distr)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x y.\n       (fst x \\<le> fst y \\<and> snd x \\<le> snd y \\<and> x \\<noteq> y) =\n       (fst x \\<le> fst y \\<and>\n        snd x \\<le> snd y \\<and>\n        (fst y \\<le> fst x \\<longrightarrow> \\<not> snd y \\<le> snd x))\n 2. \\<And>x y z.\n       \\<lbrakk>fst x \\<le> fst y \\<and> snd x \\<le> snd y;\n        fst y \\<le> fst z \\<and> snd y \\<le> snd z\\<rbrakk>\n       \\<Longrightarrow> fst x \\<le> fst z \\<and> snd x \\<le> snd z\n 3. \\<And>x y.\n       \\<lbrakk>fst x \\<le> fst y \\<and> snd x \\<le> snd y;\n        fst y \\<le> fst x \\<and> snd y \\<le> snd x\\<rbrakk>\n       \\<Longrightarrow> x = y\n 4. \\<And>x A.\n       x \\<in> A \\<Longrightarrow>\n       \\<Sqinter>{uu_. \\<exists>b. (uu_, b) \\<in> A} \\<le> fst x \\<and>\n       \\<Sqinter>{uu_. \\<exists>a. (a, uu_) \\<in> A} \\<le> snd x\n 5. \\<And>A z.\n       (\\<And>x.\n           x \\<in> A \\<Longrightarrow>\n           fst z \\<le> fst x \\<and> snd z \\<le> snd x) \\<Longrightarrow>\n       fst z \\<le> \\<Sqinter>{uu_. \\<exists>b. (uu_, b) \\<in> A} \\<and>\n       snd z \\<le> \\<Sqinter>{uu_. \\<exists>a. (a, uu_) \\<in> A}\n 6. \\<And>x A.\n       x \\<in> A \\<Longrightarrow>\n       fst x \\<le> \\<Squnion>{uu_. \\<exists>b. (uu_, b) \\<in> A} \\<and>\n       snd x \\<le> \\<Squnion>{uu_. \\<exists>a. (a, uu_) \\<in> A}\n 7. \\<And>A z.\n       (\\<And>x.\n           x \\<in> A \\<Longrightarrow>\n           fst x \\<le> fst z \\<and> snd x \\<le> snd z) \\<Longrightarrow>\n       \\<Squnion>{uu_. \\<exists>b. (uu_, b) \\<in> A} \\<le> fst z \\<and>\n       \\<Squnion>{uu_. \\<exists>a. (a, uu_) \\<in> A} \\<le> snd z", "apply force+"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x A.\n       x \\<in> A \\<Longrightarrow>\n       \\<Sqinter>{uu_. \\<exists>b. (uu_, b) \\<in> A} \\<le> fst x \\<and>\n       \\<Sqinter>{uu_. \\<exists>a. (a, uu_) \\<in> A} \\<le> snd x\n 2. \\<And>A z.\n       (\\<And>x.\n           x \\<in> A \\<Longrightarrow>\n           fst z \\<le> fst x \\<and> snd z \\<le> snd x) \\<Longrightarrow>\n       fst z \\<le> \\<Sqinter>{uu_. \\<exists>b. (uu_, b) \\<in> A} \\<and>\n       snd z \\<le> \\<Sqinter>{uu_. \\<exists>a. (a, uu_) \\<in> A}\n 3. \\<And>x A.\n       x \\<in> A \\<Longrightarrow>\n       fst x \\<le> \\<Squnion>{uu_. \\<exists>b. (uu_, b) \\<in> A} \\<and>\n       snd x \\<le> \\<Squnion>{uu_. \\<exists>a. (a, uu_) \\<in> A}\n 4. \\<And>A z.\n       (\\<And>x.\n           x \\<in> A \\<Longrightarrow>\n           fst x \\<le> fst z \\<and> snd x \\<le> snd z) \\<Longrightarrow>\n       \\<Squnion>{uu_. \\<exists>b. (uu_, b) \\<in> A} \\<le> fst z \\<and>\n       \\<Squnion>{uu_. \\<exists>a. (a, uu_) \\<in> A} \\<le> snd z", "apply (rule conjI, (rule Inf_lower, force)+)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>A z.\n       (\\<And>x.\n           x \\<in> A \\<Longrightarrow>\n           fst z \\<le> fst x \\<and> snd z \\<le> snd x) \\<Longrightarrow>\n       fst z \\<le> \\<Sqinter>{uu_. \\<exists>b. (uu_, b) \\<in> A} \\<and>\n       snd z \\<le> \\<Sqinter>{uu_. \\<exists>a. (a, uu_) \\<in> A}\n 2. \\<And>x A.\n       x \\<in> A \\<Longrightarrow>\n       fst x \\<le> \\<Squnion>{uu_. \\<exists>b. (uu_, b) \\<in> A} \\<and>\n       snd x \\<le> \\<Squnion>{uu_. \\<exists>a. (a, uu_) \\<in> A}\n 3. \\<And>A z.\n       (\\<And>x.\n           x \\<in> A \\<Longrightarrow>\n           fst x \\<le> fst z \\<and> snd x \\<le> snd z) \\<Longrightarrow>\n       \\<Squnion>{uu_. \\<exists>b. (uu_, b) \\<in> A} \\<le> fst z \\<and>\n       \\<Squnion>{uu_. \\<exists>a. (a, uu_) \\<in> A} \\<le> snd z", "apply (rule conjI, (rule Inf_greatest, force)+)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x A.\n       x \\<in> A \\<Longrightarrow>\n       fst x \\<le> \\<Squnion>{uu_. \\<exists>b. (uu_, b) \\<in> A} \\<and>\n       snd x \\<le> \\<Squnion>{uu_. \\<exists>a. (a, uu_) \\<in> A}\n 2. \\<And>A z.\n       (\\<And>x.\n           x \\<in> A \\<Longrightarrow>\n           fst x \\<le> fst z \\<and> snd x \\<le> snd z) \\<Longrightarrow>\n       \\<Squnion>{uu_. \\<exists>b. (uu_, b) \\<in> A} \\<le> fst z \\<and>\n       \\<Squnion>{uu_. \\<exists>a. (a, uu_) \\<in> A} \\<le> snd z", "apply (rule conjI, (rule Sup_upper, force)+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A z.\n       (\\<And>x.\n           x \\<in> A \\<Longrightarrow>\n           fst x \\<le> fst z \\<and> snd x \\<le> snd z) \\<Longrightarrow>\n       \\<Squnion>{uu_. \\<exists>b. (uu_, b) \\<in> A} \\<le> fst z \\<and>\n       \\<Squnion>{uu_. \\<exists>a. (a, uu_) \\<in> A} \\<le> snd z", "by (rule conjI, (rule Sup_least, force)+)"], ["", "interpretation prod: proto_near_quantale Inf_prod Sup_prod inf_prod less_eq_prod less_prod sup_prod bot_prod \"top_prod :: ('a::proto_near_quantale \\<times> 'b::proto_near_quantale)\" times_prod'"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.proto_near_quantale Inf_prod Sup_prod inf_prod less_eq_prod\n     less_prod sup_prod bot_prod top_prod times_prod'", "apply (standard, simp add: times_prod'_def Sup_prod_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X y.\n       \\<Squnion>{uu_. \\<exists>b. (uu_, b) \\<in> X} \\<cdot> fst y =\n       \\<Squnion>{uu_.\n                  \\<exists>b a.\n                     uu_ = a \\<cdot> fst y \\<and>\n                     (\\<exists>ba.\n                         b = ba \\<cdot> snd y \\<and>\n                         (a, ba) \\<in> X)} \\<and>\n       \\<Squnion>{uu_. \\<exists>a. (a, uu_) \\<in> X} \\<cdot> snd y =\n       \\<Squnion>{uu_.\n                  \\<exists>a b. uu_ = b \\<cdot> snd y \\<and> (a, b) \\<in> X}", "by (rule conjI, (simp add: Sup_distr, clarify, metis)+)"], ["", "interpretation prod: proto_quantale Inf_prod Sup_prod inf_prod less_eq_prod less_prod sup_prod bot_prod \"top_prod :: ('a::proto_quantale \\<times> 'b::proto_quantale)\" times_prod'"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.proto_quantale Inf_prod Sup_prod inf_prod less_eq_prod less_prod\n     sup_prod bot_prod top_prod times_prod'", "apply (standard, simp add: times_prod'_def Sup_prod_def less_eq_prod_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x Y.\n       fst x \\<cdot> \\<Squnion>{uu_. \\<exists>b. (uu_, b) \\<in> Y} =\n       \\<Squnion>{uu_.\n                  \\<exists>b a.\n                     uu_ = fst x \\<cdot> a \\<and>\n                     (\\<exists>ba.\n                         b = snd x \\<cdot> ba \\<and>\n                         (a, ba) \\<in> Y)} \\<and>\n       snd x \\<cdot> \\<Squnion>{uu_. \\<exists>a. (a, uu_) \\<in> Y} =\n       \\<Squnion>{uu_.\n                  \\<exists>a b. uu_ = snd x \\<cdot> b \\<and> (a, b) \\<in> Y}", "by (rule conjI, (simp add: Sup_distl, metis)+)"], ["", "interpretation prod: unital_quantale one_prod times_prod' Inf_prod Sup_prod inf_prod less_eq_prod less_prod sup_prod bot_prod \"top_prod :: ('a::unital_quantale \\<times> 'b::unital_quantale)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.unital_quantale one_prod times_prod' Inf_prod Sup_prod inf_prod\n     less_eq_prod less_prod sup_prod bot_prod top_prod", "by standard (simp_all add: one_prod_def times_prod'_def mult.assoc)"], ["", "subsection \\<open>Quantale Modules and Semidirect Products\\<close>"], ["", "text \\<open>Quantale modules are extensions of semigroup actions in that a quantale acts on a complete lattice.\\<close>"], ["", "locale unital_quantale_module = \n  fixes act :: \"'a::unital_quantale \\<Rightarrow> 'b::complete_lattice \\<Rightarrow> 'b\" (\"\\<alpha>\")\n  assumes act1: \"\\<alpha> (x \\<cdot> y) p = \\<alpha> x (\\<alpha> y p)\"\n    and act2 [simp]: \"\\<alpha> 1 p = p\" \n    and act3: \"\\<alpha> (\\<Squnion>X) p = \\<Squnion>{\\<alpha> x p |x. x \\<in> X}\"\n    and act4: \"\\<alpha> x (\\<Squnion>P) = \\<Squnion>{\\<alpha> x p |p. p \\<in> P}\""], ["", "context unital_quantale_module\nbegin"], ["", "text \\<open>Actions are morphisms. The curried notation is particularly convenient for this.\\<close>"], ["", "lemma act_morph1: \"\\<alpha> (x \\<cdot> y) = (\\<alpha> x) \\<circ> (\\<alpha> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (x \\<cdot> y) = \\<alpha> x \\<circ> \\<alpha> y", "by (simp add: fun_eq_iff act1)"], ["", "lemma act_morph2: \"\\<alpha> 1 = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (1::'a) = id", "by (simp add: fun_eq_iff)"], ["", "lemma emp_act: \"\\<alpha> (\\<Squnion>{}) p = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (\\<Squnion>{}) p = \\<bottom>", "by (simp only: act3, force)"], ["", "lemma emp_act_var: \"\\<alpha> \\<bottom> p = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> \\<bottom> p = \\<bottom>", "using emp_act"], ["proof (prove)\nusing this:\n  \\<alpha> (\\<Squnion>{}) ?p = \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<bottom> p = \\<bottom>", "by auto"], ["", "lemma act_emp: \"\\<alpha> x (\\<Squnion>{}) = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> x (\\<Squnion>{}) = \\<bottom>", "by (simp only: act4, force)"], ["", "lemma act_emp_var: \"\\<alpha> x \\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> x \\<bottom> = \\<bottom>", "using act_emp"], ["proof (prove)\nusing this:\n  \\<alpha> ?x (\\<Squnion>{}) = \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<alpha> x \\<bottom> = \\<bottom>", "by auto"], ["", "lemma act_sup_distl: \"\\<alpha> x (p \\<squnion> q) = (\\<alpha> x p) \\<squnion> (\\<alpha> x q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> x (p \\<squnion> q) = \\<alpha> x p \\<squnion> \\<alpha> x q", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<alpha> x (p \\<squnion> q) = \\<alpha> x p \\<squnion> \\<alpha> x q", "have \"\\<alpha> x (p \\<squnion> q) = \\<alpha> x (\\<Squnion>{p,q})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> x (p \\<squnion> q) = \\<alpha> x (\\<Squnion>{p, q})", "by simp"], ["proof (state)\nthis:\n  \\<alpha> x (p \\<squnion> q) = \\<alpha> x (\\<Squnion>{p, q})\n\ngoal (1 subgoal):\n 1. \\<alpha> x (p \\<squnion> q) = \\<alpha> x p \\<squnion> \\<alpha> x q", "also"], ["proof (state)\nthis:\n  \\<alpha> x (p \\<squnion> q) = \\<alpha> x (\\<Squnion>{p, q})\n\ngoal (1 subgoal):\n 1. \\<alpha> x (p \\<squnion> q) = \\<alpha> x p \\<squnion> \\<alpha> x q", "have \"... = \\<Squnion>{\\<alpha> x y |y. y \\<in> {p,q}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> x (\\<Squnion>{p, q}) =\n    \\<Squnion>{\\<alpha> x y |y. y \\<in> {p, q}}", "by (rule act4)"], ["proof (state)\nthis:\n  \\<alpha> x (\\<Squnion>{p, q}) =\n  \\<Squnion>{\\<alpha> x y |y. y \\<in> {p, q}}\n\ngoal (1 subgoal):\n 1. \\<alpha> x (p \\<squnion> q) = \\<alpha> x p \\<squnion> \\<alpha> x q", "also"], ["proof (state)\nthis:\n  \\<alpha> x (\\<Squnion>{p, q}) =\n  \\<Squnion>{\\<alpha> x y |y. y \\<in> {p, q}}\n\ngoal (1 subgoal):\n 1. \\<alpha> x (p \\<squnion> q) = \\<alpha> x p \\<squnion> \\<alpha> x q", "have \"... = \\<Squnion>{v. v = \\<alpha> x p \\<or> v = \\<alpha> x q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion>{\\<alpha> x y |y. y \\<in> {p, q}} =\n    \\<Squnion>{v. v = \\<alpha> x p \\<or> v = \\<alpha> x q}", "by (metis empty_iff insert_iff)"], ["proof (state)\nthis:\n  \\<Squnion>{\\<alpha> x y |y. y \\<in> {p, q}} =\n  \\<Squnion>{v. v = \\<alpha> x p \\<or> v = \\<alpha> x q}\n\ngoal (1 subgoal):\n 1. \\<alpha> x (p \\<squnion> q) = \\<alpha> x p \\<squnion> \\<alpha> x q", "finally"], ["proof (chain)\npicking this:\n  \\<alpha> x (p \\<squnion> q) =\n  \\<Squnion>{v. v = \\<alpha> x p \\<or> v = \\<alpha> x q}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<alpha> x (p \\<squnion> q) =\n  \\<Squnion>{v. v = \\<alpha> x p \\<or> v = \\<alpha> x q}\n\ngoal (1 subgoal):\n 1. \\<alpha> x (p \\<squnion> q) = \\<alpha> x p \\<squnion> \\<alpha> x q", "by (metis Collect_disj_eq Sup_insert ccpo_Sup_singleton insert_def singleton_conv)"], ["proof (state)\nthis:\n  \\<alpha> x (p \\<squnion> q) = \\<alpha> x p \\<squnion> \\<alpha> x q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma act_sup_distr: \"\\<alpha> (x \\<squnion> y) p = (\\<alpha> x p) \\<squnion> (\\<alpha> y p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (x \\<squnion> y) p = \\<alpha> x p \\<squnion> \\<alpha> y p", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<alpha> (x \\<squnion> y) p = \\<alpha> x p \\<squnion> \\<alpha> y p", "have \"\\<alpha> (x \\<squnion> y) p  = \\<alpha> (\\<Squnion>{x,y}) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (x \\<squnion> y) p = \\<alpha> (\\<Squnion>{x, y}) p", "by simp"], ["proof (state)\nthis:\n  \\<alpha> (x \\<squnion> y) p = \\<alpha> (\\<Squnion>{x, y}) p\n\ngoal (1 subgoal):\n 1. \\<alpha> (x \\<squnion> y) p = \\<alpha> x p \\<squnion> \\<alpha> y p", "also"], ["proof (state)\nthis:\n  \\<alpha> (x \\<squnion> y) p = \\<alpha> (\\<Squnion>{x, y}) p\n\ngoal (1 subgoal):\n 1. \\<alpha> (x \\<squnion> y) p = \\<alpha> x p \\<squnion> \\<alpha> y p", "have \"... = \\<Squnion>{\\<alpha> v p |v. v \\<in> {x,y}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (\\<Squnion>{x, y}) p =\n    \\<Squnion>{\\<alpha> v p |v. v \\<in> {x, y}}", "by (rule act3)"], ["proof (state)\nthis:\n  \\<alpha> (\\<Squnion>{x, y}) p =\n  \\<Squnion>{\\<alpha> v p |v. v \\<in> {x, y}}\n\ngoal (1 subgoal):\n 1. \\<alpha> (x \\<squnion> y) p = \\<alpha> x p \\<squnion> \\<alpha> y p", "also"], ["proof (state)\nthis:\n  \\<alpha> (\\<Squnion>{x, y}) p =\n  \\<Squnion>{\\<alpha> v p |v. v \\<in> {x, y}}\n\ngoal (1 subgoal):\n 1. \\<alpha> (x \\<squnion> y) p = \\<alpha> x p \\<squnion> \\<alpha> y p", "have \"... = \\<Squnion>{v. v = \\<alpha> x p \\<or> v = \\<alpha> y p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion>{\\<alpha> v p |v. v \\<in> {x, y}} =\n    \\<Squnion>{v. v = \\<alpha> x p \\<or> v = \\<alpha> y p}", "by (metis empty_iff insert_iff)"], ["proof (state)\nthis:\n  \\<Squnion>{\\<alpha> v p |v. v \\<in> {x, y}} =\n  \\<Squnion>{v. v = \\<alpha> x p \\<or> v = \\<alpha> y p}\n\ngoal (1 subgoal):\n 1. \\<alpha> (x \\<squnion> y) p = \\<alpha> x p \\<squnion> \\<alpha> y p", "finally"], ["proof (chain)\npicking this:\n  \\<alpha> (x \\<squnion> y) p =\n  \\<Squnion>{v. v = \\<alpha> x p \\<or> v = \\<alpha> y p}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<alpha> (x \\<squnion> y) p =\n  \\<Squnion>{v. v = \\<alpha> x p \\<or> v = \\<alpha> y p}\n\ngoal (1 subgoal):\n 1. \\<alpha> (x \\<squnion> y) p = \\<alpha> x p \\<squnion> \\<alpha> y p", "by (metis Collect_disj_eq Sup_insert ccpo_Sup_singleton insert_def singleton_conv)"], ["proof (state)\nthis:\n  \\<alpha> (x \\<squnion> y) p = \\<alpha> x p \\<squnion> \\<alpha> y p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma act_sup_distr_var: \"\\<alpha> (x \\<squnion> y) = (\\<alpha> x) \\<squnion> (\\<alpha> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (x \\<squnion> y) = \\<alpha> x \\<squnion> \\<alpha> y", "by (simp add: fun_eq_iff act_sup_distr)"], ["", "text \\<open>Next we define the semidirect product of a  unital quantale and a complete lattice. \\<close>"], ["", "definition \"sd_prod x y = (fst x \\<cdot> fst y, snd x \\<squnion> \\<alpha> (fst x) (snd y))\""], ["", "lemma sd_distr_aux: \n  \"\\<Squnion>{snd x |x. x \\<in> X} \\<squnion> \\<Squnion>{\\<alpha> (fst x) p |x. x \\<in> X} = \\<Squnion>{snd x \\<squnion> \\<alpha> (fst x) p |x. x \\<in> X}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion>{snd x |x. x \\<in> X} \\<squnion>\n    \\<Squnion>{\\<alpha> (fst x) p |x. x \\<in> X} =\n    \\<Squnion>{snd x \\<squnion> \\<alpha> (fst x) p |x. x \\<in> X}", "proof (rule antisym, rule sup_least)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<Squnion>{snd x |x. x \\<in> X}\n    \\<le> \\<Squnion>{snd x \\<squnion> \\<alpha> (fst x) p |x. x \\<in> X}\n 2. \\<Squnion>{\\<alpha> (fst x) p |x. x \\<in> X}\n    \\<le> \\<Squnion>{snd x \\<squnion> \\<alpha> (fst x) p |x. x \\<in> X}\n 3. \\<Squnion>{snd x \\<squnion> \\<alpha> (fst x) p |x. x \\<in> X}\n    \\<le> \\<Squnion>{snd x |x. x \\<in> X} \\<squnion>\n          \\<Squnion>{\\<alpha> (fst x) p |x. x \\<in> X}", "show \"\\<Squnion>{snd x |x. x \\<in> X} \\<le> \\<Squnion>{snd x \\<squnion> \\<alpha> (fst x) p |x. x \\<in> X}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion>{snd x |x. x \\<in> X}\n    \\<le> \\<Squnion>{snd x \\<squnion> \\<alpha> (fst x) p |x. x \\<in> X}", "proof (rule Sup_least)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {snd x |x. x \\<in> X} \\<Longrightarrow>\n       x \\<le> \\<Squnion>{snd x \\<squnion> \\<alpha> (fst x) p |x. x \\<in> X}", "fix x :: 'b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {snd x |x. x \\<in> X} \\<Longrightarrow>\n       x \\<le> \\<Squnion>{snd x \\<squnion> \\<alpha> (fst x) p |x. x \\<in> X}", "assume \"x \\<in> {snd x |x. x \\<in> X}\""], ["proof (state)\nthis:\n  x \\<in> {snd x |x. x \\<in> X}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {snd x |x. x \\<in> X} \\<Longrightarrow>\n       x \\<le> \\<Squnion>{snd x \\<squnion> \\<alpha> (fst x) p |x. x \\<in> X}", "hence \"\\<exists>b pa. x \\<squnion> b = snd pa \\<squnion> \\<alpha> (fst pa) p \\<and> pa \\<in> X\""], ["proof (prove)\nusing this:\n  x \\<in> {snd x |x. x \\<in> X}\n\ngoal (1 subgoal):\n 1. \\<exists>b pa.\n       x \\<squnion> b = snd pa \\<squnion> \\<alpha> (fst pa) p \\<and>\n       pa \\<in> X", "by blast"], ["proof (state)\nthis:\n  \\<exists>b pa.\n     x \\<squnion> b = snd pa \\<squnion> \\<alpha> (fst pa) p \\<and>\n     pa \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {snd x |x. x \\<in> X} \\<Longrightarrow>\n       x \\<le> \\<Squnion>{snd x \\<squnion> \\<alpha> (fst x) p |x. x \\<in> X}", "hence \"\\<exists>b. x \\<squnion> b \\<in> {snd pa \\<squnion> \\<alpha> (fst pa) p |pa. pa \\<in> X}\""], ["proof (prove)\nusing this:\n  \\<exists>b pa.\n     x \\<squnion> b = snd pa \\<squnion> \\<alpha> (fst pa) p \\<and>\n     pa \\<in> X\n\ngoal (1 subgoal):\n 1. \\<exists>b.\n       x \\<squnion> b\n       \\<in> {snd pa \\<squnion> \\<alpha> (fst pa) p |pa. pa \\<in> X}", "by blast"], ["proof (state)\nthis:\n  \\<exists>b.\n     x \\<squnion> b\n     \\<in> {snd pa \\<squnion> \\<alpha> (fst pa) p |pa. pa \\<in> X}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {snd x |x. x \\<in> X} \\<Longrightarrow>\n       x \\<le> \\<Squnion>{snd x \\<squnion> \\<alpha> (fst x) p |x. x \\<in> X}", "thus \"x \\<le> \\<Squnion>{snd pa \\<squnion> \\<alpha> (fst pa) p |pa. pa \\<in> X}\""], ["proof (prove)\nusing this:\n  \\<exists>b.\n     x \\<squnion> b\n     \\<in> {snd pa \\<squnion> \\<alpha> (fst pa) p |pa. pa \\<in> X}\n\ngoal (1 subgoal):\n 1. x \\<le> \\<Squnion>{snd pa \\<squnion> \\<alpha> (fst pa) p |pa.\n                       pa \\<in> X}", "by (meson Sup_upper sup.bounded_iff)"], ["proof (state)\nthis:\n  x \\<le> \\<Squnion>{snd pa \\<squnion> \\<alpha> (fst pa) p |pa. pa \\<in> X}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Squnion>{snd x |x. x \\<in> X}\n  \\<le> \\<Squnion>{snd x \\<squnion> \\<alpha> (fst x) p |x. x \\<in> X}\n\ngoal (2 subgoals):\n 1. \\<Squnion>{\\<alpha> (fst x) p |x. x \\<in> X}\n    \\<le> \\<Squnion>{snd x \\<squnion> \\<alpha> (fst x) p |x. x \\<in> X}\n 2. \\<Squnion>{snd x \\<squnion> \\<alpha> (fst x) p |x. x \\<in> X}\n    \\<le> \\<Squnion>{snd x |x. x \\<in> X} \\<squnion>\n          \\<Squnion>{\\<alpha> (fst x) p |x. x \\<in> X}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<Squnion>{\\<alpha> (fst x) p |x. x \\<in> X}\n    \\<le> \\<Squnion>{snd x \\<squnion> \\<alpha> (fst x) p |x. x \\<in> X}\n 2. \\<Squnion>{snd x \\<squnion> \\<alpha> (fst x) p |x. x \\<in> X}\n    \\<le> \\<Squnion>{snd x |x. x \\<in> X} \\<squnion>\n          \\<Squnion>{\\<alpha> (fst x) p |x. x \\<in> X}", "show \"\\<Squnion>{\\<alpha> (fst x) p |x. x \\<in> X} \\<le> \\<Squnion>{snd x \\<squnion> \\<alpha> (fst x) p |x. x \\<in> X}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion>{\\<alpha> (fst x) p |x. x \\<in> X}\n    \\<le> \\<Squnion>{snd x \\<squnion> \\<alpha> (fst x) p |x. x \\<in> X}", "proof (rule Sup_least)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {\\<alpha> (fst x) p |x. x \\<in> X} \\<Longrightarrow>\n       x \\<le> \\<Squnion>{snd x \\<squnion> \\<alpha> (fst x) p |x. x \\<in> X}", "fix x :: 'b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {\\<alpha> (fst x) p |x. x \\<in> X} \\<Longrightarrow>\n       x \\<le> \\<Squnion>{snd x \\<squnion> \\<alpha> (fst x) p |x. x \\<in> X}", "assume \"x \\<in> {\\<alpha> (fst x) p |x. x \\<in> X}\""], ["proof (state)\nthis:\n  x \\<in> {\\<alpha> (fst x) p |x. x \\<in> X}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {\\<alpha> (fst x) p |x. x \\<in> X} \\<Longrightarrow>\n       x \\<le> \\<Squnion>{snd x \\<squnion> \\<alpha> (fst x) p |x. x \\<in> X}", "then"], ["proof (chain)\npicking this:\n  x \\<in> {\\<alpha> (fst x) p |x. x \\<in> X}", "have \"\\<exists>b pa. b \\<squnion> x = snd pa \\<squnion> \\<alpha> (fst pa) p \\<and> pa \\<in> X\""], ["proof (prove)\nusing this:\n  x \\<in> {\\<alpha> (fst x) p |x. x \\<in> X}\n\ngoal (1 subgoal):\n 1. \\<exists>b pa.\n       b \\<squnion> x = snd pa \\<squnion> \\<alpha> (fst pa) p \\<and>\n       pa \\<in> X", "by blast"], ["proof (state)\nthis:\n  \\<exists>b pa.\n     b \\<squnion> x = snd pa \\<squnion> \\<alpha> (fst pa) p \\<and>\n     pa \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {\\<alpha> (fst x) p |x. x \\<in> X} \\<Longrightarrow>\n       x \\<le> \\<Squnion>{snd x \\<squnion> \\<alpha> (fst x) p |x. x \\<in> X}", "then"], ["proof (chain)\npicking this:\n  \\<exists>b pa.\n     b \\<squnion> x = snd pa \\<squnion> \\<alpha> (fst pa) p \\<and>\n     pa \\<in> X", "have \"\\<exists>b. b \\<squnion> x \\<in> {snd pa \\<squnion> \\<alpha> (fst pa) p |pa. pa \\<in> X}\""], ["proof (prove)\nusing this:\n  \\<exists>b pa.\n     b \\<squnion> x = snd pa \\<squnion> \\<alpha> (fst pa) p \\<and>\n     pa \\<in> X\n\ngoal (1 subgoal):\n 1. \\<exists>b.\n       b \\<squnion> x\n       \\<in> {snd pa \\<squnion> \\<alpha> (fst pa) p |pa. pa \\<in> X}", "by blast"], ["proof (state)\nthis:\n  \\<exists>b.\n     b \\<squnion> x\n     \\<in> {snd pa \\<squnion> \\<alpha> (fst pa) p |pa. pa \\<in> X}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {\\<alpha> (fst x) p |x. x \\<in> X} \\<Longrightarrow>\n       x \\<le> \\<Squnion>{snd x \\<squnion> \\<alpha> (fst x) p |x. x \\<in> X}", "then"], ["proof (chain)\npicking this:\n  \\<exists>b.\n     b \\<squnion> x\n     \\<in> {snd pa \\<squnion> \\<alpha> (fst pa) p |pa. pa \\<in> X}", "show \"x \\<le> \\<Squnion>{snd pa \\<squnion> \\<alpha> (fst pa) p |pa. pa \\<in> X}\""], ["proof (prove)\nusing this:\n  \\<exists>b.\n     b \\<squnion> x\n     \\<in> {snd pa \\<squnion> \\<alpha> (fst pa) p |pa. pa \\<in> X}\n\ngoal (1 subgoal):\n 1. x \\<le> \\<Squnion>{snd pa \\<squnion> \\<alpha> (fst pa) p |pa.\n                       pa \\<in> X}", "by (meson Sup_upper le_supE)"], ["proof (state)\nthis:\n  x \\<le> \\<Squnion>{snd pa \\<squnion> \\<alpha> (fst pa) p |pa. pa \\<in> X}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Squnion>{\\<alpha> (fst x) p |x. x \\<in> X}\n  \\<le> \\<Squnion>{snd x \\<squnion> \\<alpha> (fst x) p |x. x \\<in> X}\n\ngoal (1 subgoal):\n 1. \\<Squnion>{snd x \\<squnion> \\<alpha> (fst x) p |x. x \\<in> X}\n    \\<le> \\<Squnion>{snd x |x. x \\<in> X} \\<squnion>\n          \\<Squnion>{\\<alpha> (fst x) p |x. x \\<in> X}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Squnion>{snd x \\<squnion> \\<alpha> (fst x) p |x. x \\<in> X}\n    \\<le> \\<Squnion>{snd x |x. x \\<in> X} \\<squnion>\n          \\<Squnion>{\\<alpha> (fst x) p |x. x \\<in> X}", "show \"\\<Squnion>{snd x \\<squnion> \\<alpha> (fst x) p |x. x \\<in> X} \\<le> \\<Squnion>{snd x |x. x \\<in> X} \\<squnion> \\<Squnion>{\\<alpha> (fst x) p |x. x \\<in> X}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion>{snd x \\<squnion> \\<alpha> (fst x) p |x. x \\<in> X}\n    \\<le> \\<Squnion>{snd x |x. x \\<in> X} \\<squnion>\n          \\<Squnion>{\\<alpha> (fst x) p |x. x \\<in> X}", "apply (rule Sup_least)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {snd x \\<squnion> \\<alpha> (fst x) p |x.\n                x \\<in> X} \\<Longrightarrow>\n       x \\<le> \\<Squnion>{snd x |x. x \\<in> X} \\<squnion>\n               \\<Squnion>{\\<alpha> (fst x) p |x. x \\<in> X}", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (a, b) \\<in> X \\<Longrightarrow>\n       snd (a, b) \\<squnion> \\<alpha> (fst (a, b)) p\n       \\<le> \\<Squnion>{snd x |x. x \\<in> X} \\<squnion>\n             \\<Squnion>{\\<alpha> (fst x) p |x. x \\<in> X}", "apply (rule sup_least)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a b.\n       (a, b) \\<in> X \\<Longrightarrow>\n       snd (a, b)\n       \\<le> \\<Squnion>{snd x |x. x \\<in> X} \\<squnion>\n             \\<Squnion>{\\<alpha> (fst x) p |x. x \\<in> X}\n 2. \\<And>x a b.\n       (a, b) \\<in> X \\<Longrightarrow>\n       \\<alpha> (fst (a, b)) p\n       \\<le> \\<Squnion>{snd x |x. x \\<in> X} \\<squnion>\n             \\<Squnion>{\\<alpha> (fst x) p |x. x \\<in> X}", "apply (metis (mono_tags, lifting) Sup_upper mem_Collect_eq sup.coboundedI1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (a, b) \\<in> X \\<Longrightarrow>\n       \\<alpha> (fst (a, b)) p\n       \\<le> \\<Squnion>{snd x |x. x \\<in> X} \\<squnion>\n             \\<Squnion>{\\<alpha> (fst x) p |x. x \\<in> X}", "by (metis (mono_tags, lifting) Sup_upper mem_Collect_eq sup.coboundedI2)"], ["proof (state)\nthis:\n  \\<Squnion>{snd x \\<squnion> \\<alpha> (fst x) p |x. x \\<in> X}\n  \\<le> \\<Squnion>{snd x |x. x \\<in> X} \\<squnion>\n        \\<Squnion>{\\<alpha> (fst x) p |x. x \\<in> X}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sd_distr: \"sd_prod (Sup_prod X) y = Sup_prod {sd_prod x y |x. x \\<in> X}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sd_prod (Sup_prod X) y = Sup_prod {sd_prod x y |x. x \\<in> X}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sd_prod (Sup_prod X) y = Sup_prod {sd_prod x y |x. x \\<in> X}", "have \"sd_prod (Sup_prod X) y = sd_prod (\\<Squnion>{fst x |x. x \\<in> X}, \\<Squnion>{snd x |x. x \\<in> X}) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sd_prod (Sup_prod X) y =\n    sd_prod\n     (\\<Squnion>{fst x |x. x \\<in> X}, \\<Squnion>{snd x |x. x \\<in> X}) y", "by (simp add: Sup_prod_def)"], ["proof (state)\nthis:\n  sd_prod (Sup_prod X) y =\n  sd_prod (\\<Squnion>{fst x |x. x \\<in> X}, \\<Squnion>{snd x |x. x \\<in> X})\n   y\n\ngoal (1 subgoal):\n 1. sd_prod (Sup_prod X) y = Sup_prod {sd_prod x y |x. x \\<in> X}", "also"], ["proof (state)\nthis:\n  sd_prod (Sup_prod X) y =\n  sd_prod (\\<Squnion>{fst x |x. x \\<in> X}, \\<Squnion>{snd x |x. x \\<in> X})\n   y\n\ngoal (1 subgoal):\n 1. sd_prod (Sup_prod X) y = Sup_prod {sd_prod x y |x. x \\<in> X}", "have \n    \"... = ((\\<Squnion>{fst x |x. x \\<in> X}) \\<cdot> fst y, (\\<Squnion>{snd x |x. x \\<in> X}) \\<squnion> (\\<alpha> (\\<Squnion>{fst x | x. x \\<in> X})  (snd y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sd_prod\n     (\\<Squnion>{fst x |x. x \\<in> X}, \\<Squnion>{snd x |x. x \\<in> X}) y =\n    (\\<Squnion>{fst x |x. x \\<in> X} \\<cdot> fst y,\n     \\<Squnion>{snd x |x. x \\<in> X} \\<squnion>\n     \\<alpha> (\\<Squnion>{fst x |x. x \\<in> X}) (snd y))", "by (simp add: sd_prod_def)"], ["proof (state)\nthis:\n  sd_prod (\\<Squnion>{fst x |x. x \\<in> X}, \\<Squnion>{snd x |x. x \\<in> X})\n   y =\n  (\\<Squnion>{fst x |x. x \\<in> X} \\<cdot> fst y,\n   \\<Squnion>{snd x |x. x \\<in> X} \\<squnion>\n   \\<alpha> (\\<Squnion>{fst x |x. x \\<in> X}) (snd y))\n\ngoal (1 subgoal):\n 1. sd_prod (Sup_prod X) y = Sup_prod {sd_prod x y |x. x \\<in> X}", "also"], ["proof (state)\nthis:\n  sd_prod (\\<Squnion>{fst x |x. x \\<in> X}, \\<Squnion>{snd x |x. x \\<in> X})\n   y =\n  (\\<Squnion>{fst x |x. x \\<in> X} \\<cdot> fst y,\n   \\<Squnion>{snd x |x. x \\<in> X} \\<squnion>\n   \\<alpha> (\\<Squnion>{fst x |x. x \\<in> X}) (snd y))\n\ngoal (1 subgoal):\n 1. sd_prod (Sup_prod X) y = Sup_prod {sd_prod x y |x. x \\<in> X}", "have \n    \"... = (\\<Squnion>{fst x \\<cdot> fst y|x. x \\<in> X}, (\\<Squnion>{snd x |x. x \\<in> X}) \\<squnion> (\\<alpha> (\\<Squnion>{fst x | x. x \\<in> X})  (snd y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>{fst x |x. x \\<in> X} \\<cdot> fst y,\n     \\<Squnion>{snd x |x. x \\<in> X} \\<squnion>\n     \\<alpha> (\\<Squnion>{fst x |x. x \\<in> X}) (snd y)) =\n    (\\<Squnion>{fst x \\<cdot> fst y |x. x \\<in> X},\n     \\<Squnion>{snd x |x. x \\<in> X} \\<squnion>\n     \\<alpha> (\\<Squnion>{fst x |x. x \\<in> X}) (snd y))", "by (simp add: Sup_distr)"], ["proof (state)\nthis:\n  (\\<Squnion>{fst x |x. x \\<in> X} \\<cdot> fst y,\n   \\<Squnion>{snd x |x. x \\<in> X} \\<squnion>\n   \\<alpha> (\\<Squnion>{fst x |x. x \\<in> X}) (snd y)) =\n  (\\<Squnion>{fst x \\<cdot> fst y |x. x \\<in> X},\n   \\<Squnion>{snd x |x. x \\<in> X} \\<squnion>\n   \\<alpha> (\\<Squnion>{fst x |x. x \\<in> X}) (snd y))\n\ngoal (1 subgoal):\n 1. sd_prod (Sup_prod X) y = Sup_prod {sd_prod x y |x. x \\<in> X}", "also"], ["proof (state)\nthis:\n  (\\<Squnion>{fst x |x. x \\<in> X} \\<cdot> fst y,\n   \\<Squnion>{snd x |x. x \\<in> X} \\<squnion>\n   \\<alpha> (\\<Squnion>{fst x |x. x \\<in> X}) (snd y)) =\n  (\\<Squnion>{fst x \\<cdot> fst y |x. x \\<in> X},\n   \\<Squnion>{snd x |x. x \\<in> X} \\<squnion>\n   \\<alpha> (\\<Squnion>{fst x |x. x \\<in> X}) (snd y))\n\ngoal (1 subgoal):\n 1. sd_prod (Sup_prod X) y = Sup_prod {sd_prod x y |x. x \\<in> X}", "have \n    \"... = (\\<Squnion>{fst x \\<cdot> fst y|x. x \\<in> X}, (\\<Squnion> {snd x |x. x \\<in> X}) \\<squnion> (\\<Squnion>{\\<alpha> (fst x) (snd y) | x. x \\<in> X}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>{fst x \\<cdot> fst y |x. x \\<in> X},\n     \\<Squnion>{snd x |x. x \\<in> X} \\<squnion>\n     \\<alpha> (\\<Squnion>{fst x |x. x \\<in> X}) (snd y)) =\n    (\\<Squnion>{fst x \\<cdot> fst y |x. x \\<in> X},\n     \\<Squnion>{snd x |x. x \\<in> X} \\<squnion>\n     \\<Squnion>{\\<alpha> (fst x) (snd y) |x. x \\<in> X})", "by (simp add: act3)"], ["proof (state)\nthis:\n  (\\<Squnion>{fst x \\<cdot> fst y |x. x \\<in> X},\n   \\<Squnion>{snd x |x. x \\<in> X} \\<squnion>\n   \\<alpha> (\\<Squnion>{fst x |x. x \\<in> X}) (snd y)) =\n  (\\<Squnion>{fst x \\<cdot> fst y |x. x \\<in> X},\n   \\<Squnion>{snd x |x. x \\<in> X} \\<squnion>\n   \\<Squnion>{\\<alpha> (fst x) (snd y) |x. x \\<in> X})\n\ngoal (1 subgoal):\n 1. sd_prod (Sup_prod X) y = Sup_prod {sd_prod x y |x. x \\<in> X}", "also"], ["proof (state)\nthis:\n  (\\<Squnion>{fst x \\<cdot> fst y |x. x \\<in> X},\n   \\<Squnion>{snd x |x. x \\<in> X} \\<squnion>\n   \\<alpha> (\\<Squnion>{fst x |x. x \\<in> X}) (snd y)) =\n  (\\<Squnion>{fst x \\<cdot> fst y |x. x \\<in> X},\n   \\<Squnion>{snd x |x. x \\<in> X} \\<squnion>\n   \\<Squnion>{\\<alpha> (fst x) (snd y) |x. x \\<in> X})\n\ngoal (1 subgoal):\n 1. sd_prod (Sup_prod X) y = Sup_prod {sd_prod x y |x. x \\<in> X}", "have \"... = (\\<Squnion>{fst x \\<cdot> fst y|x. x \\<in> X}, \\<Squnion>{snd x \\<squnion> (\\<alpha> (fst x) (snd y)) | x. x \\<in> X})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>{fst x \\<cdot> fst y |x. x \\<in> X},\n     \\<Squnion>{snd x |x. x \\<in> X} \\<squnion>\n     \\<Squnion>{\\<alpha> (fst x) (snd y) |x. x \\<in> X}) =\n    (\\<Squnion>{fst x \\<cdot> fst y |x. x \\<in> X},\n     \\<Squnion>{snd x \\<squnion> \\<alpha> (fst x) (snd y) |x. x \\<in> X})", "by (simp only: sd_distr_aux)"], ["proof (state)\nthis:\n  (\\<Squnion>{fst x \\<cdot> fst y |x. x \\<in> X},\n   \\<Squnion>{snd x |x. x \\<in> X} \\<squnion>\n   \\<Squnion>{\\<alpha> (fst x) (snd y) |x. x \\<in> X}) =\n  (\\<Squnion>{fst x \\<cdot> fst y |x. x \\<in> X},\n   \\<Squnion>{snd x \\<squnion> \\<alpha> (fst x) (snd y) |x. x \\<in> X})\n\ngoal (1 subgoal):\n 1. sd_prod (Sup_prod X) y = Sup_prod {sd_prod x y |x. x \\<in> X}", "also"], ["proof (state)\nthis:\n  (\\<Squnion>{fst x \\<cdot> fst y |x. x \\<in> X},\n   \\<Squnion>{snd x |x. x \\<in> X} \\<squnion>\n   \\<Squnion>{\\<alpha> (fst x) (snd y) |x. x \\<in> X}) =\n  (\\<Squnion>{fst x \\<cdot> fst y |x. x \\<in> X},\n   \\<Squnion>{snd x \\<squnion> \\<alpha> (fst x) (snd y) |x. x \\<in> X})\n\ngoal (1 subgoal):\n 1. sd_prod (Sup_prod X) y = Sup_prod {sd_prod x y |x. x \\<in> X}", "have \"... = Sup_prod {(fst x \\<cdot> fst y, snd x \\<squnion> (\\<alpha> (fst x) (snd y))) |x. x \\<in> X}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>{fst x \\<cdot> fst y |x. x \\<in> X},\n     \\<Squnion>{snd x \\<squnion> \\<alpha> (fst x) (snd y) |x. x \\<in> X}) =\n    Sup_prod\n     {(fst x \\<cdot> fst y, snd x \\<squnion> \\<alpha> (fst x) (snd y)) |x.\n      x \\<in> X}", "by (simp add: Sup_prod_def, metis)"], ["proof (state)\nthis:\n  (\\<Squnion>{fst x \\<cdot> fst y |x. x \\<in> X},\n   \\<Squnion>{snd x \\<squnion> \\<alpha> (fst x) (snd y) |x. x \\<in> X}) =\n  Sup_prod\n   {(fst x \\<cdot> fst y, snd x \\<squnion> \\<alpha> (fst x) (snd y)) |x.\n    x \\<in> X}\n\ngoal (1 subgoal):\n 1. sd_prod (Sup_prod X) y = Sup_prod {sd_prod x y |x. x \\<in> X}", "finally"], ["proof (chain)\npicking this:\n  sd_prod (Sup_prod X) y =\n  Sup_prod\n   {(fst x \\<cdot> fst y, snd x \\<squnion> \\<alpha> (fst x) (snd y)) |x.\n    x \\<in> X}", "show ?thesis"], ["proof (prove)\nusing this:\n  sd_prod (Sup_prod X) y =\n  Sup_prod\n   {(fst x \\<cdot> fst y, snd x \\<squnion> \\<alpha> (fst x) (snd y)) |x.\n    x \\<in> X}\n\ngoal (1 subgoal):\n 1. sd_prod (Sup_prod X) y = Sup_prod {sd_prod x y |x. x \\<in> X}", "by (simp add: sd_prod_def)"], ["proof (state)\nthis:\n  sd_prod (Sup_prod X) y = Sup_prod {sd_prod x y |x. x \\<in> X}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sd_distl_aux: \"Y \\<noteq> {} \\<Longrightarrow> p \\<squnion> (\\<Squnion>{\\<alpha> x (snd y) |y. y \\<in> Y}) = \\<Squnion>{p \\<squnion> \\<alpha> x (snd y) |y. y \\<in> Y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y \\<noteq> {} \\<Longrightarrow>\n    p \\<squnion> \\<Squnion>{\\<alpha> x (snd y) |y. y \\<in> Y} =\n    \\<Squnion>{p \\<squnion> \\<alpha> x (snd y) |y. y \\<in> Y}", "proof (rule antisym, rule sup_least)"], ["proof (state)\ngoal (3 subgoals):\n 1. Y \\<noteq> {} \\<Longrightarrow>\n    p \\<le> \\<Squnion>{p \\<squnion> \\<alpha> x (snd y) |y. y \\<in> Y}\n 2. Y \\<noteq> {} \\<Longrightarrow>\n    \\<Squnion>{\\<alpha> x (snd y) |y. y \\<in> Y}\n    \\<le> \\<Squnion>{p \\<squnion> \\<alpha> x (snd y) |y. y \\<in> Y}\n 3. Y \\<noteq> {} \\<Longrightarrow>\n    \\<Squnion>{p \\<squnion> \\<alpha> x (snd y) |y. y \\<in> Y}\n    \\<le> p \\<squnion> \\<Squnion>{\\<alpha> x (snd y) |y. y \\<in> Y}", "show \"Y \\<noteq> {} \\<Longrightarrow> p \\<le> \\<Squnion>{p \\<squnion> \\<alpha> x (snd y) |y. y \\<in> Y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y \\<noteq> {} \\<Longrightarrow>\n    p \\<le> \\<Squnion>{p \\<squnion> \\<alpha> x (snd y) |y. y \\<in> Y}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Y \\<noteq> {} \\<Longrightarrow>\n    p \\<le> \\<Squnion>{p \\<squnion> \\<alpha> x (snd y) |y. y \\<in> Y}", "assume \"Y \\<noteq> {}\""], ["proof (state)\nthis:\n  Y \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Y \\<noteq> {} \\<Longrightarrow>\n    p \\<le> \\<Squnion>{p \\<squnion> \\<alpha> x (snd y) |y. y \\<in> Y}", "hence \"\\<exists>b. b \\<in> {p \\<squnion> \\<alpha> x (snd pa) |pa. pa \\<in> Y} \\<and> p \\<le> b\""], ["proof (prove)\nusing this:\n  Y \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>b.\n       b \\<in> {p \\<squnion> \\<alpha> x (snd pa) |pa. pa \\<in> Y} \\<and>\n       p \\<le> b", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>b.\n     b \\<in> {p \\<squnion> \\<alpha> x (snd pa) |pa. pa \\<in> Y} \\<and>\n     p \\<le> b\n\ngoal (1 subgoal):\n 1. Y \\<noteq> {} \\<Longrightarrow>\n    p \\<le> \\<Squnion>{p \\<squnion> \\<alpha> x (snd y) |y. y \\<in> Y}", "thus \"p \\<le> \\<Squnion>{p \\<squnion> \\<alpha> x (snd pa) |pa. pa \\<in> Y}\""], ["proof (prove)\nusing this:\n  \\<exists>b.\n     b \\<in> {p \\<squnion> \\<alpha> x (snd pa) |pa. pa \\<in> Y} \\<and>\n     p \\<le> b\n\ngoal (1 subgoal):\n 1. p \\<le> \\<Squnion>{p \\<squnion> \\<alpha> x (snd pa) |pa. pa \\<in> Y}", "by (meson Sup_upper2)"], ["proof (state)\nthis:\n  p \\<le> \\<Squnion>{p \\<squnion> \\<alpha> x (snd pa) |pa. pa \\<in> Y}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Y \\<noteq> {} \\<Longrightarrow>\n  p \\<le> \\<Squnion>{p \\<squnion> \\<alpha> x (snd y) |y. y \\<in> Y}\n\ngoal (2 subgoals):\n 1. Y \\<noteq> {} \\<Longrightarrow>\n    \\<Squnion>{\\<alpha> x (snd y) |y. y \\<in> Y}\n    \\<le> \\<Squnion>{p \\<squnion> \\<alpha> x (snd y) |y. y \\<in> Y}\n 2. Y \\<noteq> {} \\<Longrightarrow>\n    \\<Squnion>{p \\<squnion> \\<alpha> x (snd y) |y. y \\<in> Y}\n    \\<le> p \\<squnion> \\<Squnion>{\\<alpha> x (snd y) |y. y \\<in> Y}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. Y \\<noteq> {} \\<Longrightarrow>\n    \\<Squnion>{\\<alpha> x (snd y) |y. y \\<in> Y}\n    \\<le> \\<Squnion>{p \\<squnion> \\<alpha> x (snd y) |y. y \\<in> Y}\n 2. Y \\<noteq> {} \\<Longrightarrow>\n    \\<Squnion>{p \\<squnion> \\<alpha> x (snd y) |y. y \\<in> Y}\n    \\<le> p \\<squnion> \\<Squnion>{\\<alpha> x (snd y) |y. y \\<in> Y}", "show \"Y \\<noteq> {} \\<Longrightarrow> \\<Squnion>{\\<alpha> x (snd y) |y. y \\<in> Y} \\<le> \\<Squnion>{p \\<squnion> \\<alpha> x (snd y) |y. y \\<in> Y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y \\<noteq> {} \\<Longrightarrow>\n    \\<Squnion>{\\<alpha> x (snd y) |y. y \\<in> Y}\n    \\<le> \\<Squnion>{p \\<squnion> \\<alpha> x (snd y) |y. y \\<in> Y}", "apply (rule Sup_least)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>Y \\<noteq> {};\n        xa \\<in> {\\<alpha> x (snd y) |y. y \\<in> Y}\\<rbrakk>\n       \\<Longrightarrow> xa \\<le> \\<Squnion>{p \\<squnion>\n       \\<alpha> x (snd y) |\n       y. y \\<in> Y}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>Y \\<noteq> {};\n        xa \\<in> {\\<alpha> x (snd y) |y. y \\<in> Y}\\<rbrakk>\n       \\<Longrightarrow> xa \\<le> \\<Squnion>{p \\<squnion>\n       \\<alpha> x (snd y) |\n       y. y \\<in> Y}", "fix xa :: 'b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>Y \\<noteq> {};\n        xa \\<in> {\\<alpha> x (snd y) |y. y \\<in> Y}\\<rbrakk>\n       \\<Longrightarrow> xa \\<le> \\<Squnion>{p \\<squnion>\n       \\<alpha> x (snd y) |\n       y. y \\<in> Y}", "assume \"xa \\<in> {\\<alpha> x (snd y) |y. y \\<in> Y}\""], ["proof (state)\nthis:\n  xa \\<in> {\\<alpha> x (snd y) |y. y \\<in> Y}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>Y \\<noteq> {};\n        xa \\<in> {\\<alpha> x (snd y) |y. y \\<in> Y}\\<rbrakk>\n       \\<Longrightarrow> xa \\<le> \\<Squnion>{p \\<squnion>\n       \\<alpha> x (snd y) |\n       y. y \\<in> Y}", "then"], ["proof (chain)\npicking this:\n  xa \\<in> {\\<alpha> x (snd y) |y. y \\<in> Y}", "have \"\\<exists>b. (\\<exists>pa. b = p \\<squnion> \\<alpha> x (snd pa) \\<and> pa \\<in> Y) \\<and> xa \\<le> b\""], ["proof (prove)\nusing this:\n  xa \\<in> {\\<alpha> x (snd y) |y. y \\<in> Y}\n\ngoal (1 subgoal):\n 1. \\<exists>b.\n       (\\<exists>pa.\n           b = p \\<squnion> \\<alpha> x (snd pa) \\<and> pa \\<in> Y) \\<and>\n       xa \\<le> b", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>b.\n     (\\<exists>pa.\n         b = p \\<squnion> \\<alpha> x (snd pa) \\<and> pa \\<in> Y) \\<and>\n     xa \\<le> b\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>Y \\<noteq> {};\n        xa \\<in> {\\<alpha> x (snd y) |y. y \\<in> Y}\\<rbrakk>\n       \\<Longrightarrow> xa \\<le> \\<Squnion>{p \\<squnion>\n       \\<alpha> x (snd y) |\n       y. y \\<in> Y}", "then"], ["proof (chain)\npicking this:\n  \\<exists>b.\n     (\\<exists>pa.\n         b = p \\<squnion> \\<alpha> x (snd pa) \\<and> pa \\<in> Y) \\<and>\n     xa \\<le> b", "have \"\\<exists>b. b \\<in> {p \\<squnion> \\<alpha> x (snd pa) |pa. pa \\<in> Y} \\<and> xa \\<le> b\""], ["proof (prove)\nusing this:\n  \\<exists>b.\n     (\\<exists>pa.\n         b = p \\<squnion> \\<alpha> x (snd pa) \\<and> pa \\<in> Y) \\<and>\n     xa \\<le> b\n\ngoal (1 subgoal):\n 1. \\<exists>b.\n       b \\<in> {p \\<squnion> \\<alpha> x (snd pa) |pa. pa \\<in> Y} \\<and>\n       xa \\<le> b", "by blast"], ["proof (state)\nthis:\n  \\<exists>b.\n     b \\<in> {p \\<squnion> \\<alpha> x (snd pa) |pa. pa \\<in> Y} \\<and>\n     xa \\<le> b\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>Y \\<noteq> {};\n        xa \\<in> {\\<alpha> x (snd y) |y. y \\<in> Y}\\<rbrakk>\n       \\<Longrightarrow> xa \\<le> \\<Squnion>{p \\<squnion>\n       \\<alpha> x (snd y) |\n       y. y \\<in> Y}", "then"], ["proof (chain)\npicking this:\n  \\<exists>b.\n     b \\<in> {p \\<squnion> \\<alpha> x (snd pa) |pa. pa \\<in> Y} \\<and>\n     xa \\<le> b", "show \"xa \\<le> \\<Squnion>{p \\<squnion> \\<alpha> x (snd pa) |pa. pa \\<in> Y}\""], ["proof (prove)\nusing this:\n  \\<exists>b.\n     b \\<in> {p \\<squnion> \\<alpha> x (snd pa) |pa. pa \\<in> Y} \\<and>\n     xa \\<le> b\n\ngoal (1 subgoal):\n 1. xa \\<le> \\<Squnion>{p \\<squnion> \\<alpha> x (snd pa) |pa. pa \\<in> Y}", "by (meson Sup_upper2)"], ["proof (state)\nthis:\n  xa \\<le> \\<Squnion>{p \\<squnion> \\<alpha> x (snd pa) |pa. pa \\<in> Y}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Y \\<noteq> {} \\<Longrightarrow>\n  \\<Squnion>{\\<alpha> x (snd y) |y. y \\<in> Y}\n  \\<le> \\<Squnion>{p \\<squnion> \\<alpha> x (snd y) |y. y \\<in> Y}\n\ngoal (1 subgoal):\n 1. Y \\<noteq> {} \\<Longrightarrow>\n    \\<Squnion>{p \\<squnion> \\<alpha> x (snd y) |y. y \\<in> Y}\n    \\<le> p \\<squnion> \\<Squnion>{\\<alpha> x (snd y) |y. y \\<in> Y}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Y \\<noteq> {} \\<Longrightarrow>\n    \\<Squnion>{p \\<squnion> \\<alpha> x (snd y) |y. y \\<in> Y}\n    \\<le> p \\<squnion> \\<Squnion>{\\<alpha> x (snd y) |y. y \\<in> Y}", "show \"Y \\<noteq> {} \\<Longrightarrow> \\<Squnion>{p \\<squnion> \\<alpha> x (snd y) |y. y \\<in> Y} \\<le> p \\<squnion> \\<Squnion>{\\<alpha> x (snd y) |y. y \\<in> Y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y \\<noteq> {} \\<Longrightarrow>\n    \\<Squnion>{p \\<squnion> \\<alpha> x (snd y) |y. y \\<in> Y}\n    \\<le> p \\<squnion> \\<Squnion>{\\<alpha> x (snd y) |y. y \\<in> Y}", "apply (rule Sup_least)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>Y \\<noteq> {};\n        xa \\<in> {p \\<squnion> \\<alpha> x (snd y) |y. y \\<in> Y}\\<rbrakk>\n       \\<Longrightarrow> xa \\<le> p \\<squnion>\n                                  \\<Squnion>{\\<alpha> x (snd y) |y.\n       y \\<in> Y}", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa a b aa ba.\n       \\<lbrakk>(a, b) \\<in> Y;\n        \\<not> p \\<squnion> \\<alpha> x (snd (a, b))\n               \\<le> p \\<squnion>\n                     \\<Squnion>{\\<alpha> x (snd y) |y. y \\<in> Y};\n        (aa, ba) \\<in> Y\\<rbrakk>\n       \\<Longrightarrow> (aa, ba) \\<in> {}", "by (metis (mono_tags, lifting) Sup_le_iff le_sup_iff mem_Collect_eq sup_ge1 sup_ge2)"], ["proof (state)\nthis:\n  Y \\<noteq> {} \\<Longrightarrow>\n  \\<Squnion>{p \\<squnion> \\<alpha> x (snd y) |y. y \\<in> Y}\n  \\<le> p \\<squnion> \\<Squnion>{\\<alpha> x (snd y) |y. y \\<in> Y}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sd_distl: \"Y \\<noteq> {} \\<Longrightarrow> sd_prod x (Sup_prod Y) = Sup_prod {sd_prod x y |y. y \\<in> Y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y \\<noteq> {} \\<Longrightarrow>\n    sd_prod x (Sup_prod Y) = Sup_prod {sd_prod x y |y. y \\<in> Y}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Y \\<noteq> {} \\<Longrightarrow>\n    sd_prod x (Sup_prod Y) = Sup_prod {sd_prod x y |y. y \\<in> Y}", "assume a: \"Y \\<noteq> {}\""], ["proof (state)\nthis:\n  Y \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Y \\<noteq> {} \\<Longrightarrow>\n    sd_prod x (Sup_prod Y) = Sup_prod {sd_prod x y |y. y \\<in> Y}", "have \"sd_prod x (Sup_prod Y) = sd_prod x (\\<Squnion>{fst y |y. y \\<in> Y}, \\<Squnion>{snd y |y. y \\<in> Y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sd_prod x (Sup_prod Y) =\n    sd_prod x\n     (\\<Squnion>{fst y |y. y \\<in> Y}, \\<Squnion>{snd y |y. y \\<in> Y})", "by (simp add: Sup_prod_def)"], ["proof (state)\nthis:\n  sd_prod x (Sup_prod Y) =\n  sd_prod x\n   (\\<Squnion>{fst y |y. y \\<in> Y}, \\<Squnion>{snd y |y. y \\<in> Y})\n\ngoal (1 subgoal):\n 1. Y \\<noteq> {} \\<Longrightarrow>\n    sd_prod x (Sup_prod Y) = Sup_prod {sd_prod x y |y. y \\<in> Y}", "also"], ["proof (state)\nthis:\n  sd_prod x (Sup_prod Y) =\n  sd_prod x\n   (\\<Squnion>{fst y |y. y \\<in> Y}, \\<Squnion>{snd y |y. y \\<in> Y})\n\ngoal (1 subgoal):\n 1. Y \\<noteq> {} \\<Longrightarrow>\n    sd_prod x (Sup_prod Y) = Sup_prod {sd_prod x y |y. y \\<in> Y}", "have \"... = ((fst x) \\<cdot> (\\<Squnion>{fst y |y. y \\<in> Y}), (snd x \\<squnion> (\\<alpha> (fst x) (\\<Squnion>{snd y |y. y \\<in> Y}))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sd_prod x\n     (\\<Squnion>{fst y |y. y \\<in> Y}, \\<Squnion>{snd y |y. y \\<in> Y}) =\n    (fst x \\<cdot> \\<Squnion>{fst y |y. y \\<in> Y},\n     snd x \\<squnion> \\<alpha> (fst x) (\\<Squnion>{snd y |y. y \\<in> Y}))", "by (simp add: sd_prod_def)"], ["proof (state)\nthis:\n  sd_prod x\n   (\\<Squnion>{fst y |y. y \\<in> Y}, \\<Squnion>{snd y |y. y \\<in> Y}) =\n  (fst x \\<cdot> \\<Squnion>{fst y |y. y \\<in> Y},\n   snd x \\<squnion> \\<alpha> (fst x) (\\<Squnion>{snd y |y. y \\<in> Y}))\n\ngoal (1 subgoal):\n 1. Y \\<noteq> {} \\<Longrightarrow>\n    sd_prod x (Sup_prod Y) = Sup_prod {sd_prod x y |y. y \\<in> Y}", "also"], ["proof (state)\nthis:\n  sd_prod x\n   (\\<Squnion>{fst y |y. y \\<in> Y}, \\<Squnion>{snd y |y. y \\<in> Y}) =\n  (fst x \\<cdot> \\<Squnion>{fst y |y. y \\<in> Y},\n   snd x \\<squnion> \\<alpha> (fst x) (\\<Squnion>{snd y |y. y \\<in> Y}))\n\ngoal (1 subgoal):\n 1. Y \\<noteq> {} \\<Longrightarrow>\n    sd_prod x (Sup_prod Y) = Sup_prod {sd_prod x y |y. y \\<in> Y}", "have \"... = (\\<Squnion>{fst x \\<cdot> fst y |y. y \\<in> Y}, (snd x \\<squnion> (\\<alpha> (fst x) (\\<Squnion>{snd y |y. y \\<in> Y}))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst x \\<cdot> \\<Squnion>{fst y |y. y \\<in> Y},\n     snd x \\<squnion> \\<alpha> (fst x) (\\<Squnion>{snd y |y. y \\<in> Y})) =\n    (\\<Squnion>{fst x \\<cdot> fst y |y. y \\<in> Y},\n     snd x \\<squnion> \\<alpha> (fst x) (\\<Squnion>{snd y |y. y \\<in> Y}))", "by (simp add: Sup_distl)"], ["proof (state)\nthis:\n  (fst x \\<cdot> \\<Squnion>{fst y |y. y \\<in> Y},\n   snd x \\<squnion> \\<alpha> (fst x) (\\<Squnion>{snd y |y. y \\<in> Y})) =\n  (\\<Squnion>{fst x \\<cdot> fst y |y. y \\<in> Y},\n   snd x \\<squnion> \\<alpha> (fst x) (\\<Squnion>{snd y |y. y \\<in> Y}))\n\ngoal (1 subgoal):\n 1. Y \\<noteq> {} \\<Longrightarrow>\n    sd_prod x (Sup_prod Y) = Sup_prod {sd_prod x y |y. y \\<in> Y}", "also"], ["proof (state)\nthis:\n  (fst x \\<cdot> \\<Squnion>{fst y |y. y \\<in> Y},\n   snd x \\<squnion> \\<alpha> (fst x) (\\<Squnion>{snd y |y. y \\<in> Y})) =\n  (\\<Squnion>{fst x \\<cdot> fst y |y. y \\<in> Y},\n   snd x \\<squnion> \\<alpha> (fst x) (\\<Squnion>{snd y |y. y \\<in> Y}))\n\ngoal (1 subgoal):\n 1. Y \\<noteq> {} \\<Longrightarrow>\n    sd_prod x (Sup_prod Y) = Sup_prod {sd_prod x y |y. y \\<in> Y}", "have \"... = (\\<Squnion>{fst x \\<cdot> fst y |y. y \\<in> Y}, (snd x \\<squnion> (\\<Squnion>{\\<alpha> (fst x) (snd y) |y. y \\<in> Y})))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>{fst x \\<cdot> fst y |y. y \\<in> Y},\n     snd x \\<squnion> \\<alpha> (fst x) (\\<Squnion>{snd y |y. y \\<in> Y})) =\n    (\\<Squnion>{fst x \\<cdot> fst y |y. y \\<in> Y},\n     snd x \\<squnion> \\<Squnion>{\\<alpha> (fst x) (snd y) |y. y \\<in> Y})", "by (simp add: act4, meson)"], ["proof (state)\nthis:\n  (\\<Squnion>{fst x \\<cdot> fst y |y. y \\<in> Y},\n   snd x \\<squnion> \\<alpha> (fst x) (\\<Squnion>{snd y |y. y \\<in> Y})) =\n  (\\<Squnion>{fst x \\<cdot> fst y |y. y \\<in> Y},\n   snd x \\<squnion> \\<Squnion>{\\<alpha> (fst x) (snd y) |y. y \\<in> Y})\n\ngoal (1 subgoal):\n 1. Y \\<noteq> {} \\<Longrightarrow>\n    sd_prod x (Sup_prod Y) = Sup_prod {sd_prod x y |y. y \\<in> Y}", "also"], ["proof (state)\nthis:\n  (\\<Squnion>{fst x \\<cdot> fst y |y. y \\<in> Y},\n   snd x \\<squnion> \\<alpha> (fst x) (\\<Squnion>{snd y |y. y \\<in> Y})) =\n  (\\<Squnion>{fst x \\<cdot> fst y |y. y \\<in> Y},\n   snd x \\<squnion> \\<Squnion>{\\<alpha> (fst x) (snd y) |y. y \\<in> Y})\n\ngoal (1 subgoal):\n 1. Y \\<noteq> {} \\<Longrightarrow>\n    sd_prod x (Sup_prod Y) = Sup_prod {sd_prod x y |y. y \\<in> Y}", "have \"... = (\\<Squnion>{fst x \\<cdot> fst y |y. y \\<in> Y}, \\<Squnion>{snd x \\<squnion> (\\<alpha> (fst x) (snd y)) |y. y \\<in> Y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>{fst x \\<cdot> fst y |y. y \\<in> Y},\n     snd x \\<squnion> \\<Squnion>{\\<alpha> (fst x) (snd y) |y. y \\<in> Y}) =\n    (\\<Squnion>{fst x \\<cdot> fst y |y. y \\<in> Y},\n     \\<Squnion>{snd x \\<squnion> \\<alpha> (fst x) (snd y) |y. y \\<in> Y})", "using a sd_distl_aux"], ["proof (prove)\nusing this:\n  Y \\<noteq> {}\n  ?Y \\<noteq> {} \\<Longrightarrow>\n  ?p \\<squnion> \\<Squnion>{\\<alpha> ?x (snd y) |y. y \\<in> ?Y} =\n  \\<Squnion>{?p \\<squnion> \\<alpha> ?x (snd y) |y. y \\<in> ?Y}\n\ngoal (1 subgoal):\n 1. (\\<Squnion>{fst x \\<cdot> fst y |y. y \\<in> Y},\n     snd x \\<squnion> \\<Squnion>{\\<alpha> (fst x) (snd y) |y. y \\<in> Y}) =\n    (\\<Squnion>{fst x \\<cdot> fst y |y. y \\<in> Y},\n     \\<Squnion>{snd x \\<squnion> \\<alpha> (fst x) (snd y) |y. y \\<in> Y})", "by blast"], ["proof (state)\nthis:\n  (\\<Squnion>{fst x \\<cdot> fst y |y. y \\<in> Y},\n   snd x \\<squnion> \\<Squnion>{\\<alpha> (fst x) (snd y) |y. y \\<in> Y}) =\n  (\\<Squnion>{fst x \\<cdot> fst y |y. y \\<in> Y},\n   \\<Squnion>{snd x \\<squnion> \\<alpha> (fst x) (snd y) |y. y \\<in> Y})\n\ngoal (1 subgoal):\n 1. Y \\<noteq> {} \\<Longrightarrow>\n    sd_prod x (Sup_prod Y) = Sup_prod {sd_prod x y |y. y \\<in> Y}", "also"], ["proof (state)\nthis:\n  (\\<Squnion>{fst x \\<cdot> fst y |y. y \\<in> Y},\n   snd x \\<squnion> \\<Squnion>{\\<alpha> (fst x) (snd y) |y. y \\<in> Y}) =\n  (\\<Squnion>{fst x \\<cdot> fst y |y. y \\<in> Y},\n   \\<Squnion>{snd x \\<squnion> \\<alpha> (fst x) (snd y) |y. y \\<in> Y})\n\ngoal (1 subgoal):\n 1. Y \\<noteq> {} \\<Longrightarrow>\n    sd_prod x (Sup_prod Y) = Sup_prod {sd_prod x y |y. y \\<in> Y}", "have \"... = Sup_prod {(fst x \\<cdot> fst y, snd x \\<squnion> (\\<alpha> (fst x) (snd y))) |y. y \\<in> Y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>{fst x \\<cdot> fst y |y. y \\<in> Y},\n     \\<Squnion>{snd x \\<squnion> \\<alpha> (fst x) (snd y) |y. y \\<in> Y}) =\n    Sup_prod\n     {(fst x \\<cdot> fst y, snd x \\<squnion> \\<alpha> (fst x) (snd y)) |y.\n      y \\<in> Y}", "by (simp add: Sup_prod_def, metis)"], ["proof (state)\nthis:\n  (\\<Squnion>{fst x \\<cdot> fst y |y. y \\<in> Y},\n   \\<Squnion>{snd x \\<squnion> \\<alpha> (fst x) (snd y) |y. y \\<in> Y}) =\n  Sup_prod\n   {(fst x \\<cdot> fst y, snd x \\<squnion> \\<alpha> (fst x) (snd y)) |y.\n    y \\<in> Y}\n\ngoal (1 subgoal):\n 1. Y \\<noteq> {} \\<Longrightarrow>\n    sd_prod x (Sup_prod Y) = Sup_prod {sd_prod x y |y. y \\<in> Y}", "finally"], ["proof (chain)\npicking this:\n  sd_prod x (Sup_prod Y) =\n  Sup_prod\n   {(fst x \\<cdot> fst y, snd x \\<squnion> \\<alpha> (fst x) (snd y)) |y.\n    y \\<in> Y}", "show ?thesis"], ["proof (prove)\nusing this:\n  sd_prod x (Sup_prod Y) =\n  Sup_prod\n   {(fst x \\<cdot> fst y, snd x \\<squnion> \\<alpha> (fst x) (snd y)) |y.\n    y \\<in> Y}\n\ngoal (1 subgoal):\n 1. sd_prod x (Sup_prod Y) = Sup_prod {sd_prod x y |y. y \\<in> Y}", "by (simp add: sd_prod_def)"], ["proof (state)\nthis:\n  sd_prod x (Sup_prod Y) = Sup_prod {sd_prod x y |y. y \\<in> Y}\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"sd_unit = (1,\\<bottom>)\""], ["", "lemma sd_unitl [simp]: \"sd_prod sd_unit x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sd_prod sd_unit x = x", "by (simp add: sd_prod_def sd_unit_def)"], ["", "lemma sd_unitr [simp]: \"sd_prod x sd_unit = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sd_prod x sd_unit = x", "apply (simp add: sd_prod_def sd_unit_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst x, snd x \\<squnion> \\<alpha> (fst x) \\<bottom>) = x", "using act_emp"], ["proof (prove)\nusing this:\n  \\<alpha> ?x (\\<Squnion>{}) = \\<bottom>\n\ngoal (1 subgoal):\n 1. (fst x, snd x \\<squnion> \\<alpha> (fst x) \\<bottom>) = x", "by force"], ["", "text \\<open>The following counterexamples rule out that semidirect products of quantales and complete lattices form quantales.\nThe reason is that the right annihilation law fails.\\<close>"], ["", "lemma \"sd_prod x (Sup_prod Y) = Sup_prod {sd_prod x y |y. y \\<in> Y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sd_prod x (Sup_prod Y) = Sup_prod {sd_prod x y |y. y \\<in> Y}", "(*nitpick[show_all,expect=genuine]*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sd_prod x (Sup_prod Y) = Sup_prod {sd_prod x y |y. y \\<in> Y}", "oops"], ["", "lemma \"sd_prod x bot_prod = bot_prod\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sd_prod x bot_prod = bot_prod", "(*nitpick[show_all,expect=genuine]*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sd_prod x bot_prod = bot_prod", "oops"], ["", "text \\<open>However we can show that semidirect products of (unital) quantales with complete lattices form weak (unital) quantales. \\<close>"], ["", "interpretation dp_quantale: weak_quantale sd_prod Inf_prod Sup_prod inf_prod less_eq_prod less_prod sup_prod bot_prod top_prod"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.weak_quantale sd_prod Inf_prod Sup_prod inf_prod less_eq_prod\n     less_prod sup_prod bot_prod top_prod", "apply standard"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b c. sd_prod (sd_prod a b) c = sd_prod a (sd_prod b c)\n 2. \\<And>X y. sd_prod (Sup_prod X) y = Sup_prod {sd_prod x y |x. x \\<in> X}\n 3. \\<And>Y x.\n       Y \\<noteq> {} \\<Longrightarrow>\n       sd_prod x (Sup_prod Y) = Sup_prod {sd_prod x y |y. y \\<in> Y}", "apply (simp_all add: sd_distl sd_distr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c. sd_prod (sd_prod a b) c = sd_prod a (sd_prod b c)", "apply (simp_all add: sd_prod_def Inf_prod_def Sup_prod_def bot_prod_def sup_prod_def top_prod_def inf_prod_def less_eq_prod_def less_prod_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       fst a \\<cdot> fst b \\<cdot> fst c =\n       fst a \\<cdot> (fst b \\<cdot> fst c) \\<and>\n       snd a \\<squnion> \\<alpha> (fst a) (snd b) \\<squnion>\n       \\<alpha> (fst a \\<cdot> fst b) (snd c) =\n       snd a \\<squnion>\n       \\<alpha> (fst a) (snd b \\<squnion> \\<alpha> (fst b) (snd c))", "by (rule conjI, simp add: mult.assoc, simp add: act1 act_sup_distl sup_assoc)"], ["", "interpretation dpu_quantale: unital_weak_quantale sd_unit sd_prod Inf_prod Sup_prod inf_prod less_eq_prod less_prod sup_prod bot_prod top_prod"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.unital_weak_quantale sd_unit sd_prod Inf_prod Sup_prod inf_prod\n     less_eq_prod less_prod sup_prod bot_prod top_prod", "by (standard; simp_all)"], ["", "end"], ["", "end"]]}