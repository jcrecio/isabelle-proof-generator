{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/Sepref_Constraints.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemma insert_slot_rl1:\n  assumes \"PROP P \\<Longrightarrow> PROP (CONSTRAINT_SLOT (Trueprop True)) \\<Longrightarrow> PROP Q\"\n  shows \"PROP (CONSTRAINT_SLOT (PROP P)) \\<Longrightarrow> PROP Q\"", "lemma insert_slot_rl2:\n  assumes \"PROP P \\<Longrightarrow> PROP (CONSTRAINT_SLOT S) \\<Longrightarrow> PROP Q\"\n  shows \"PROP (CONSTRAINT_SLOT (PROP S &&& PROP P)) \\<Longrightarrow> PROP Q\"", "lemma remove_slot: \"PROP (CONSTRAINT_SLOT (Trueprop True))\"", "lemma CONSTRAINT_D:\n  assumes \"CONSTRAINT (P::'a => bool) x\"\n  shows \"P x\"", "lemma CONSTRAINT_I:\n  assumes \"P x\"\n  shows \"CONSTRAINT (P::'a => bool) x\"", "lemma CN_FALSEI: \"CN_FALSE P x \\<Longrightarrow> P x\"", "lemmas split_constraint_rls \n    = atomize_conj[symmetric] imp_conjunction all_conjunction conjunction_imp"], "translations": [["", "lemma insert_slot_rl1:\n  assumes \"PROP P \\<Longrightarrow> PROP (CONSTRAINT_SLOT (Trueprop True)) \\<Longrightarrow> PROP Q\"\n  shows \"PROP (CONSTRAINT_SLOT (PROP P)) \\<Longrightarrow> PROP Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CONSTRAINT_SLOT PROP P \\<Longrightarrow> PROP Q", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>PROP P; CONSTRAINT_SLOT (True)\\<rbrakk> \\<Longrightarrow> PROP Q\n\ngoal (1 subgoal):\n 1. CONSTRAINT_SLOT PROP P \\<Longrightarrow> PROP Q", "unfolding CONSTRAINT_SLOT_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>PROP P; True\\<rbrakk> \\<Longrightarrow> PROP Q\n\ngoal (1 subgoal):\n 1. PROP P \\<Longrightarrow> PROP Q", "by simp"], ["", "lemma insert_slot_rl2:\n  assumes \"PROP P \\<Longrightarrow> PROP (CONSTRAINT_SLOT S) \\<Longrightarrow> PROP Q\"\n  shows \"PROP (CONSTRAINT_SLOT (PROP S &&& PROP P)) \\<Longrightarrow> PROP Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CONSTRAINT_SLOT (PROP S &&& PROP P) \\<Longrightarrow> PROP Q", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>PROP P; CONSTRAINT_SLOT PROP S\\<rbrakk> \\<Longrightarrow> PROP Q\n\ngoal (1 subgoal):\n 1. CONSTRAINT_SLOT (PROP S &&& PROP P) \\<Longrightarrow> PROP Q", "unfolding CONSTRAINT_SLOT_def conjunction_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>PROP P; PROP S\\<rbrakk> \\<Longrightarrow> PROP Q\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        (\\<lbrakk>PROP S; PROP P\\<rbrakk>\n         \\<Longrightarrow> PROP C) \\<Longrightarrow>\n        PROP C) \\<Longrightarrow>\n    PROP Q", "."], ["", "lemma remove_slot: \"PROP (CONSTRAINT_SLOT (Trueprop True))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CONSTRAINT_SLOT (True)", "unfolding CONSTRAINT_SLOT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. True", "by (rule TrueI)"], ["", "definition CONSTRAINT where [simp]: \"CONSTRAINT P x \\<equiv> P x\""], ["", "lemma CONSTRAINT_D:\n  assumes \"CONSTRAINT (P::'a => bool) x\"\n  shows \"P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P x", "using assms"], ["proof (prove)\nusing this:\n  CONSTRAINT P x\n\ngoal (1 subgoal):\n 1. P x", "unfolding CONSTRAINT_def"], ["proof (prove)\nusing this:\n  P x\n\ngoal (1 subgoal):\n 1. P x", "by simp"], ["", "lemma CONSTRAINT_I:\n  assumes \"P x\"\n  shows \"CONSTRAINT (P::'a => bool) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CONSTRAINT P x", "using assms"], ["proof (prove)\nusing this:\n  P x\n\ngoal (1 subgoal):\n 1. CONSTRAINT P x", "unfolding CONSTRAINT_def"], ["proof (prove)\nusing this:\n  P x\n\ngoal (1 subgoal):\n 1. P x", "by simp"], ["", "text \\<open>Special predicate to indicate unsolvable constraint.\n  The constraint solver refuses to put those into slot.\n  Thus, adding safe rules introducing this can be used to indicate \n  unsolvable constraints early.\n\\<close>"], ["", "definition CN_FALSE :: \"('a\\<Rightarrow>bool) \\<Rightarrow> 'a \\<Rightarrow> bool\" where [simp]: \"CN_FALSE P x \\<equiv> False\""], ["", "lemma CN_FALSEI: \"CN_FALSE P x \\<Longrightarrow> P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CN_FALSE P x \\<Longrightarrow> P x", "by simp"], ["", "named_theorems constraint_simps \\<open>Simplification of constraints\\<close>"], ["", "named_theorems constraint_abbrevs \\<open>Constraint Solver: Abbreviations\\<close>"], ["", "lemmas split_constraint_rls \n    = atomize_conj[symmetric] imp_conjunction all_conjunction conjunction_imp"], ["", "ML \\<open>\n  signature SEPREF_CONSTRAINTS = sig\n    (******** Constraint Slot *)\n    (* Tactic with slot subgoal *)\n    val WITH_SLOT: tactic' -> tactic\n    (* Process all goals in slot *)\n    val ON_SLOT: tactic -> tactic\n    (* Create slot as last subgoal. Fail if slot already present. *)\n    val create_slot_tac: tactic\n    (* Create slot if there isn't one already *)\n    val ensure_slot_tac: tactic\n    (* Remove empty slot *)\n    val remove_slot_tac: tactic\n    (* Move slot to first subgoal *)\n    val prefer_slot_tac: tactic\n    (* Destruct slot *)\n    val dest_slot_tac: tactic'\n    (* Check if goal state has slot *)\n    val has_slot: thm -> bool\n    (* Defer subgoal to slot *)\n    val to_slot_tac: tactic'\n    (* Print slot constraints *)\n    val print_slot_tac: Proof.context -> tactic\n\n    (* Focus on goals in slot *)\n    val focus: tactic\n    (* Unfocus goals in slot *)\n    val unfocus: tactic\n    (* Unfocus goals, and insert them as first subgoals *)\n    val unfocus_ins:tactic\n\n    (* Focus on some goals in slot *)\n    val cond_focus: (term -> bool) -> tactic\n    (* Move some goals to slot *)\n    val some_to_slot_tac: (term -> bool) -> tactic\n\n\n    (******** Constraints *)\n    (* Check if subgoal is a constraint. To be used with COND' *)\n    val is_constraint_goal: term -> bool\n    (* Identity on constraint subgoal, no_tac otherwise *)\n    val is_constraint_tac: tactic'\n    (* Defer constraint to slot *)\n    val slot_constraint_tac: int -> tactic\n\n    (******** Constraint solving *)\n\n    val add_constraint_rule: thm -> Context.generic -> Context.generic\n    val del_constraint_rule: thm -> Context.generic -> Context.generic\n    val get_constraint_rules: Proof.context -> thm list\n\n    val add_safe_constraint_rule: thm -> Context.generic -> Context.generic\n    val del_safe_constraint_rule: thm -> Context.generic -> Context.generic\n    val get_safe_constraint_rules: Proof.context -> thm list\n\n    (* Solve constraint subgoal *)\n    val solve_constraint_tac: Proof.context -> tactic'\n    (* Solve constraint subgoal if solvable, fail if definitely unsolvable, \n      apply simplification and unique rules otherwise. *)\n    val safe_constraint_tac: Proof.context -> tactic'\n\n    (* CONSTRAINT tag on goal is optional *)\n    val solve_constraint'_tac: Proof.context -> tactic'\n    (* CONSTRAINT tag on goal is optional *)\n    val safe_constraint'_tac: Proof.context -> tactic'\n    \n    (* Solve, or apply safe-rules and defer to constraint slot *)\n    val constraint_tac: Proof.context -> tactic'\n\n    (* Apply safe rules to all constraint goals in slot *)\n    val process_constraint_slot: Proof.context -> tactic\n\n    (* Solve all constraint goals in slot, insert unsolved ones as first subgoals *)\n    val solve_constraint_slot: Proof.context -> tactic\n\n\n    val setup: theory -> theory\n\n  end\n\n\n  structure Sepref_Constraints: SEPREF_CONSTRAINTS  = struct\n    fun is_slot_goal @{mpat \"CONSTRAINT_SLOT _\"} = true | is_slot_goal _ = false\n\n    fun slot_goal_num st = let\n      val i = find_index is_slot_goal (Thm.prems_of st) + 1\n    in\n      i\n    end\n\n    fun has_slot st = slot_goal_num st > 0\n\n    fun WITH_SLOT tac st = let\n      val si = slot_goal_num st\n    in\n      if si>0 then tac si st else (warning \"Constraints: No slot\"; Seq.empty)\n    end\n\n    val to_slot_tac = IF_EXGOAL (fn i => WITH_SLOT (fn si => \n      if i<si then\n        prefer_tac si THEN prefer_tac (i+1)\n        THEN (\n          PRIMITIVE (fn st => Drule.comp_no_flatten (st, 0) 1 @{thm insert_slot_rl1}) \n          ORELSE PRIMITIVE (fn st => Drule.comp_no_flatten (st, 0) 1 @{thm insert_slot_rl2})\n        )\n        THEN defer_tac 1\n      else no_tac))\n\n    val create_slot_tac = \n      COND (has_slot) no_tac\n        (PRIMITIVE (Thm.implies_intr @{cterm \"CONSTRAINT_SLOT (Trueprop True)\"}) \n        THEN defer_tac 1)\n        \n    val ensure_slot_tac = TRY create_slot_tac\n          \n      \n    val prefer_slot_tac = WITH_SLOT prefer_tac\n\n    val dest_slot_tac = SELECT_GOAL (\n      ALLGOALS (\n        CONVERSION (Conv.rewr_conv @{thm CONSTRAINT_SLOT_def}) \n        THEN' Goal.conjunction_tac\n        THEN' TRY o resolve0_tac @{thms TrueI})\n      THEN distinct_subgoals_tac\n    )\n\n    val remove_slot_tac = WITH_SLOT (resolve0_tac @{thms remove_slot})\n\n    val focus = WITH_SLOT (fn i => \n      PRIMITIVE (Goal.restrict i 1) \n      THEN ALLGOALS dest_slot_tac\n      THEN create_slot_tac)\n\n    val unfocus_ins = \n      PRIMITIVE (Goal.unrestrict 1)\n      THEN WITH_SLOT defer_tac\n\n    fun some_to_slot_tac cond = (ALLGOALS (COND' (fn t => is_slot_goal t orelse not (cond t)) ORELSE' to_slot_tac))\n\n    val unfocus = \n      some_to_slot_tac (K true)\n      THEN unfocus_ins\n\n    fun cond_focus cond =\n      focus \n      THEN some_to_slot_tac (not o cond)\n\n\n    fun ON_SLOT tac = focus THEN tac THEN unfocus\n\n    fun print_slot_tac ctxt = ON_SLOT (print_tac ctxt \"SLOT:\")\n\n    local\n      (*fun prepare_constraint_conv ctxt = let\n        open Conv \n        fun CONSTRAINT_conv ct = case Thm.term_of ct of\n          @{mpat \"Trueprop (_ _)\"} => \n            HOLogic.Trueprop_conv \n              (rewr_conv @{thm CONSTRAINT_def[symmetric]}) ct\n          | _ => raise CTERM (\"CONSTRAINT_conv\", [ct])\n\n        fun rec_conv ctxt ct = (\n          CONSTRAINT_conv\n          else_conv \n          implies_conv (rec_conv ctxt) (rec_conv ctxt)\n          else_conv\n          forall_conv (rec_conv o #2) ctxt\n        ) ct\n      in\n        rec_conv ctxt\n      end*)\n\n      fun unfold_abbrevs ctxt = \n        Local_Defs.unfold0 ctxt (\n          @{thms split_constraint_rls CONSTRAINT_def} \n          @ Named_Theorems.get ctxt @{named_theorems constraint_abbrevs}\n          @ Named_Theorems.get ctxt @{named_theorems constraint_simps})\n        #> Conjunction.elim_conjunctions\n  \n      fun check_constraint_rl thm = let\n        fun ck (t as @{mpat \"Trueprop (?C _)\"}) = \n              if is_Var (Term.head_of C) then\n                raise TERM (\"Schematic head in constraint rule\",[t,Thm.prop_of thm])\n              else ()\n          | ck @{mpat \"\\<And>_. PROP ?t\"} = ck t\n          | ck @{mpat \"PROP ?s \\<Longrightarrow> PROP ?t\"} = (ck s; ck t)\n          | ck t = raise TERM (\"Invalid part of constraint rule\",[t,Thm.prop_of thm])\n  \n      in\n        ck (Thm.prop_of thm); thm\n      end\n\n      fun check_unsafe_constraint_rl thm = let\n        val _ = Thm.nprems_of thm = 0 \n          andalso raise TERM(\"Unconditional constraint rule must be safe (register this as safe rule)\",[Thm.prop_of thm])\n      in\n        thm\n      end\n\n    in\n      structure constraint_rules = Named_Sorted_Thms (\n        val name = @{binding constraint_rules}\n        val description = \"Constraint rules\"\n        val sort = K I\n        fun transform context = let\n          open Conv\n          val ctxt = Context.proof_of context\n        in\n          unfold_abbrevs ctxt #> map (check_constraint_rl o check_unsafe_constraint_rl)\n        end\n      )\n\n      structure safe_constraint_rules = Named_Sorted_Thms (\n        val name = @{binding safe_constraint_rules}\n        val description = \"Safe Constraint rules\"\n        val sort = K I\n        fun transform context = let\n          open Conv\n          val ctxt = Context.proof_of context\n        in\n          unfold_abbrevs ctxt #> map check_constraint_rl\n        end\n      )\n\n    end  \n\n    val add_constraint_rule = constraint_rules.add_thm\n    val del_constraint_rule = constraint_rules.del_thm\n    val get_constraint_rules = constraint_rules.get\n\n    val add_safe_constraint_rule = safe_constraint_rules.add_thm\n    val del_safe_constraint_rule = safe_constraint_rules.del_thm\n    val get_safe_constraint_rules = safe_constraint_rules.get\n\n    fun is_constraint_goal t = case Logic.strip_assums_concl t of\n      @{mpat \"Trueprop (CONSTRAINT _ _)\"} => true\n    | _ => false\n\n    val is_constraint_tac = COND' is_constraint_goal\n\n    fun is_slottable_constraint_goal t = case Logic.strip_assums_concl t of\n      @{mpat \"Trueprop (CONSTRAINT (CN_FALSE _) _)\"} => false\n    | @{mpat \"Trueprop (CONSTRAINT _ _)\"} => true\n    | _ => false\n\n    val slot_constraint_tac = COND' is_slottable_constraint_goal THEN' to_slot_tac\n\n    datatype 'a seq_cases = SC_NONE | SC_SINGLE of 'a Seq.seq | SC_MULTIPLE of 'a Seq.seq\n\n    fun seq_cases seq = \n      case Seq.pull seq of\n        NONE => SC_NONE\n      | SOME (st1,seq) => case Seq.pull seq of\n          NONE => SC_SINGLE (Seq.single st1)\n        | SOME (st2,seq) => SC_MULTIPLE (Seq.cons st1 (Seq.cons st2 seq))  \n\n    fun SEQ_CASES tac (single_tac, multiple_tac) st = let\n      val res = tac st\n    in\n      case seq_cases res of\n        SC_NONE => Seq.empty\n      | SC_SINGLE res => Seq.maps single_tac res\n      | SC_MULTIPLE res => Seq.maps multiple_tac res\n    end\n\n    fun SAFE tac = SEQ_CASES tac (all_tac, no_tac)\n    fun SAFE' tac = SAFE o tac\n\n    local\n      fun simp_constraints_tac ctxt = let\n        val ctxt = put_simpset HOL_basic_ss ctxt \n          addsimps (Named_Theorems.get ctxt @{named_theorems constraint_simps})\n      in\n        simp_tac ctxt\n      end\n\n      fun unfold_abbrevs_tac ctxt =  let\n        val ctxt = put_simpset HOL_basic_ss ctxt \n          addsimps (Named_Theorems.get ctxt @{named_theorems constraint_abbrevs})\n        val ethms = @{thms conjE}  \n        val ithms = @{thms conjI}  \n      in\n        full_simp_tac ctxt \n        THEN_ALL_NEW TRY o REPEAT_ALL_NEW (ematch_tac ctxt ethms)\n        THEN_ALL_NEW TRY o REPEAT_ALL_NEW (match_tac ctxt ithms)\n      end\n  \n      fun WITH_RULE_NETS tac ctxt = let\n        val scn_net = safe_constraint_rules.get ctxt |> Tactic.build_net\n        val cn_net = constraint_rules.get ctxt |> Tactic.build_net\n      in\n        tac (scn_net,cn_net) ctxt\n      end\n\n      fun wrap_tac step_tac ctxt = REPEAT_ALL_NEW (\n        simp_constraints_tac ctxt \n        THEN_ALL_NEW unfold_abbrevs_tac ctxt\n        THEN_ALL_NEW step_tac ctxt\n      )\n\n      fun solve_step_tac (scn_net,cn_net) ctxt = REPEAT_ALL_NEW (\n        DETERM o resolve_from_net_tac ctxt scn_net\n        ORELSE' resolve_from_net_tac ctxt cn_net\n      )\n\n      fun safe_step_tac (scn_net,cn_net) ctxt = REPEAT_ALL_NEW (\n        DETERM o resolve_from_net_tac ctxt scn_net\n        ORELSE' SAFE' (resolve_from_net_tac ctxt cn_net)\n      )\n\n      fun solve_tac cn_nets ctxt = SOLVED' (wrap_tac (solve_step_tac cn_nets) ctxt)\n      fun safe_tac cn_nets ctxt =  \n        simp_constraints_tac ctxt\n        THEN_ALL_NEW unfold_abbrevs_tac ctxt\n        THEN_ALL_NEW (solve_tac cn_nets ctxt ORELSE' TRY o wrap_tac (safe_step_tac cn_nets) ctxt)\n\n    in\n      val solve_constraint_tac = TRADE (fn ctxt =>\n        is_constraint_tac\n        THEN' resolve_tac ctxt @{thms CONSTRAINT_I}\n        THEN' WITH_RULE_NETS solve_tac ctxt)\n\n      val safe_constraint_tac = TRADE (fn ctxt =>\n        is_constraint_tac\n        THEN' resolve_tac ctxt @{thms CONSTRAINT_I}\n        THEN' WITH_RULE_NETS safe_tac ctxt\n        THEN_ALL_NEW fo_resolve_tac @{thms CONSTRAINT_D} ctxt) (* TODO/FIXME: fo_resolve_tac has non-canonical parameter order *)\n\n      val solve_constraint'_tac = TRADE (fn ctxt =>\n        TRY o resolve_tac ctxt @{thms CONSTRAINT_I}\n        THEN' WITH_RULE_NETS solve_tac ctxt)\n\n      val safe_constraint'_tac = TRADE (fn ctxt =>\n        TRY o resolve_tac ctxt @{thms CONSTRAINT_I}\n        THEN' WITH_RULE_NETS safe_tac ctxt)\n\n\n    end  \n\n    fun constraint_tac ctxt = \n      safe_constraint_tac ctxt THEN_ALL_NEW slot_constraint_tac\n\n    fun process_constraint_slot ctxt = ON_SLOT (ALLGOALS (TRY o safe_constraint_tac ctxt))\n\n    fun solve_constraint_slot ctxt = \n      cond_focus is_constraint_goal \n        THEN ALLGOALS (\n          COND' is_slot_goal\n          ORELSE' (\n            solve_constraint_tac ctxt\n            ORELSE' TRY o safe_constraint_tac ctxt\n          )\n        )\n      THEN unfocus_ins\n\n\n    val setup = I\n      #> constraint_rules.setup\n      #> safe_constraint_rules.setup\n\n  end\n\\<close>"], ["", "setup Sepref_Constraints.setup"], ["", "method_setup print_slot = \\<open>Scan.succeed (fn ctxt => SIMPLE_METHOD (Sepref_Constraints.print_slot_tac ctxt))\\<close>"], ["", "method_setup solve_constraint = \\<open>Scan.succeed (fn ctxt => SIMPLE_METHOD' (Sepref_Constraints.solve_constraint'_tac ctxt))\\<close>"], ["", "method_setup safe_constraint = \\<open>Scan.succeed (fn ctxt => SIMPLE_METHOD' (Sepref_Constraints.safe_constraint'_tac ctxt))\\<close>"], ["", "end"]]}