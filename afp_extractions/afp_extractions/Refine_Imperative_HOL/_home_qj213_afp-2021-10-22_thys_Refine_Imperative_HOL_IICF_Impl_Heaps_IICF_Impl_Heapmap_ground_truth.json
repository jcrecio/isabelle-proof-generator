{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/IICF/Impl/Heaps/IICF_Impl_Heapmap.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemma efficient_nat_div2[simp]: \"efficient_nat_div2 n = n div 2\"", "lemma param_prio: \"(prio,prio) \\<in> Id \\<rightarrow> Id\"", "lemmas [sepref_import_param] = param_prio", "lemmas hm_impl1_rel_defs = \n      hm_impl1_rel_def hm_weak_impl'_rel_def hm_impl1_weak_invar_def hm_impl1_invar_def hm_impl1_\\<alpha>_def in_br_conv", "lemma hm_impl_\\<alpha>_fst_eq: \n        \"(x1, x2) = hm_impl1_\\<alpha> (x1a, x2a) \\<Longrightarrow> x1 = x1a\"", "lemma hm_empty_op'_refine: \"(hm_empty_op', hm_empty_op) \\<in> \\<langle>hm_impl1_rel\\<rangle>nres_rel\"", "lemma hm_length'_refine: \"(RETURN o hm_length',RETURN o hm_length) \\<in> hm_impl1_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>nres_rel\"", "lemma hm_key_of_op'_refine: \"(hm_key_of_op', hm_key_of_op) \\<in> hm_impl1_rel \\<rightarrow> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>nres_rel\"", "lemma hm_lookup_op'_refine: \"(uncurry hm_lookup_op', uncurry (RETURN oo hm_lookup)) \n      \\<in> (hm_impl1_rel \\<times>\\<^sub>r nat_rel) \\<rightarrow>\\<^sub>f \\<langle>\\<langle>Id\\<rangle>option_rel\\<rangle>nres_rel\"", "lemma hm_contains_key_op'_refine: \"(uncurry hm_contains_key_op', uncurry hm_contains_key_op) \n      \\<in> (nat_rel \\<times>\\<^sub>r hm_impl1_rel) \\<rightarrow>\\<^sub>f \\<langle>bool_rel\\<rangle>nres_rel\"", "lemma hm_impl1_relI:\n      assumes \"hmr_invar b\"\n      assumes \"(a,b)\\<in>hm_weak_impl'_rel\"\n      shows \"(a,b)\\<in>hm_impl1_rel\"", "lemma hm_impl1_nres_relI:\n      assumes \"b \\<le>\\<^sub>n SPEC hmr_invar\"\n      assumes \"(a,b)\\<in>\\<langle>hm_weak_impl'_rel\\<rangle>nres_rel\"\n      shows \"(a,b)\\<in>\\<langle>hm_impl1_rel\\<rangle>nres_rel\"", "lemma hm_exch_op'_refine: \"(hm_exch_op', hm_exch_op) \\<in> hm_impl1_rel \\<rightarrow> nat_rel \\<rightarrow> nat_rel \\<rightarrow> \\<langle>hm_impl1_rel\\<rangle>nres_rel\"", "lemma hm_index_op'_refine: \"(hm_index_op',hm_index_op) \n      \\<in> hm_impl1_rel \\<rightarrow> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>nres_rel\"", "lemma hm_update_op'_refine: \"(hm_update_op', hm_update_op) \\<in> hm_impl1_rel \\<rightarrow> nat_rel \\<rightarrow> Id \\<rightarrow> \\<langle>hm_impl1_rel\\<rangle>nres_rel\"", "lemma hm_butlast_op_invar: \"hm_butlast_op hm \\<le>\\<^sub>n SPEC hmr_invar\"", "lemma set_butlast_distinct_conv: \n      \"\\<lbrakk>distinct l\\<rbrakk> \\<Longrightarrow> set (butlast l) = set l - {last l}\"", "lemma hm_butlast_op'_refine: \"(hm_butlast_op', hm_butlast_op) \\<in> hm_impl1_rel \\<rightarrow> \\<langle>hm_impl1_rel\\<rangle>nres_rel\"", "lemma hm_append_op'_refine: \"(uncurry2 hm_append_op', uncurry2 hm_append_op) \n      \\<in> [\\<lambda>((hm,k),v). k<maxsize]\\<^sub>f (hm_impl1_rel \\<times>\\<^sub>r nat_rel) \\<times>\\<^sub>r Id \\<rightarrow> \\<langle>hm_impl1_rel\\<rangle>nres_rel\"", "lemmas [fcomp_norm_unfold] = hm_impl_rel_def[symmetric]", "lemma param_parent: \"(efficient_nat_div2,h.parent) \\<in> Id \\<rightarrow> Id\"", "lemmas [sepref_import_param] = param_parent", "lemma param_left: \"(h.left,h.left) \\<in> Id \\<rightarrow> Id\"", "lemmas [sepref_import_param] = param_left", "lemma param_right: \"(h.right,h.right) \\<in> Id \\<rightarrow> Id\"", "lemmas [sepref_import_param] = param_right", "lemma param_prio_le: \"((\\<le>), (\\<le>)) \\<in> prio_rel \\<rightarrow> prio_rel \\<rightarrow> bool_rel\"", "lemmas [sepref_import_param] = param_prio_le", "lemma param_prio_lt: \"((<), (<)) \\<in> prio_rel \\<rightarrow> prio_rel \\<rightarrow> bool_rel\"", "lemmas [sepref_import_param] = param_prio_lt", "lemmas [sepref_fr_rules] = hm_length_impl.refine[FCOMP hm_length'_refine]", "lemmas [sepref_fr_rules] = hm_key_of_op_impl.refine[FCOMP hm_key_of_op'_refine]", "lemmas [sepref_fr_rules] = \n      hm_lookup_impl.refine[FCOMP hm_lookup_op'_refine]", "lemmas [sepref_fr_rules] = hm_exch_op_impl.refine[FCOMP hm_exch_op'_refine]", "lemmas [sepref_fr_rules] = hm_index_op_impl.refine[FCOMP hm_index_op'_refine]", "lemmas [sepref_fr_rules] = hm_update_op_impl.refine[FCOMP hm_update_op'_refine]", "lemmas [sepref_fr_rules] = hm_butlast_op_impl.refine[FCOMP hm_butlast_op'_refine]", "lemmas [sepref_fr_rules] = hm_append_op_impl.refine[FCOMP hm_append_op'_refine]", "lemmas [intf_of_assn] = intf_of_assnI[where R=\"hm_impl_rel :: (nat,'v) ahm \\<Rightarrow> _\" and 'a=\"'v i_hma\"]", "lemmas [sepref_fr_rules] = hm_valid_impl.refine", "lemma hm_the_lookup_op'_refine: \n      \"(hm_the_lookup_op', hm_the_lookup_op) \\<in> hm_impl1_rel \\<rightarrow> nat_rel \\<rightarrow> \\<langle>Id\\<rangle>nres_rel\"", "lemmas hm_the_lookup_op_impl[sepref_fr_rules] = hm_the_lookup_op_impl.refine[FCOMP hm_the_lookup_op'_refine]", "lemmas [sepref_fr_rules] = hm_val_of_op_impl.refine", "lemmas [sepref_fr_rules] = hm_prio_of_op_impl.refine", "lemma [def_pat_rules]: \"hmstruct.hm_prio_of_op$prio \\<equiv> PR_CONST hm_prio_of_op\"", "lemmas [sepref_fr_rules] = hm_swim_op_impl.refine", "lemma [def_pat_rules]: \"hmstruct.hm_swim_op$prio \\<equiv> PR_CONST hm_swim_op\"", "lemmas [sepref_fr_rules] = hm_sink_op_impl.refine", "lemma [def_pat_rules]: \"hmstruct.hm_sink_op$prio \\<equiv> PR_CONST hm_sink_op\"", "lemmas [sepref_fr_rules] = hm_repair_op_impl.refine", "lemma [def_pat_rules]: \"hmstruct.hm_repair_op$prio \\<equiv> PR_CONST hm_repair_op\"", "lemmas [fcomp_norm_unfold] = hm_rel_np_def[symmetric]", "lemmas [fcomp_norm_unfold] = hm_rel_def[symmetric]", "lemmas [intf_of_assn] = intf_of_assnI[where R=\"hm_rel K V\" and 'a=\"('kk,'vv) i_map\" for K V]", "lemma hm_rel_id_conv: \"hm_rel id_assn id_assn = hm_rel_np\"\n    \\<comment> \\<open>Used for generic algorithms: Unfold with this, then let decl-impl compose with \\<open>map_rel\\<close> again.\\<close>", "lemma [def_pat_rules]: \"op_hm_empty_sz$maxsize \\<equiv> UNPROTECT (op_hm_empty_sz maxsize)\"", "lemma hm_fold_custom_empty_sz: \n    \"op_map_empty = op_hm_empty_sz sz\"\n    \"Map.empty = op_hm_empty_sz sz\"", "lemmas mop_map_update_new_fref' = mop_map_update_new.fref[of K]", "lemmas op_map_update_fref' = op_map_update.fref[of K]", "lemma op_hm_empty_sz_hnr[sepref_fr_rules]:\n  \"(uncurry0 (hm_empty_op_impl maxsize), uncurry0 (RETURN (PR_CONST (op_hm_empty_sz maxsize)))) \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a hm_rel maxsize prio K V\"", "lemma nested_case_bind: \n  \"(case p of (a,b) \\<Rightarrow> bind (case a of (a1,a2) \\<Rightarrow> m a b a1 a2) (f a b)) \n  = (case p of ((a1,a2),b) \\<Rightarrow> bind (m (a1,a2) b a1 a2) (f (a1,a2) b))\"\n  \"(case p of (a,b) \\<Rightarrow> bind (case b of (b1,b2) \\<Rightarrow> m a b b1 b2) (f a b)) \n  = (case p of (a,b1,b2) \\<Rightarrow> bind (m a (b1,b2) b1 b2) (f a (b1,b2)))\"", "lemma it_case: \"(case p of (a,b) \\<Rightarrow> f p a b) = (case p of (a,b) \\<Rightarrow> f (a,b) a b)\"", "lemma c2l: \"(case p of (a,b) \\<Rightarrow> bind (m a b) (f a b)) = \n  do { let (a,b) = p; bind (m a b) (f a b)}\"", "lemma bind_Let: \"do { x \\<leftarrow> do { let y = v; (f y :: 'a Heap)}; g x } = do { let y=v; x \\<leftarrow> f y; g x }\"", "lemma bind_case: \"do { x \\<leftarrow> (case y of (a,b) \\<Rightarrow> f a b); (g x :: 'a Heap) } = do { let (a,b) = y; x \\<leftarrow> f a b; g x }\"", "lemma bind_case_mvup: \"do { x \\<leftarrow> f; case y of (a,b) \\<Rightarrow> g a b x } \n  = do { let (a,b) = y; x \\<leftarrow> f; (g a b x :: 'a Heap) }\"", "lemma if_case_mvup: \"(if b then case p of (x1,x2) \\<Rightarrow> f x1 x2 else e)\n  = (case p of (x1,x2) \\<Rightarrow> if b then f x1 x2 else e)\"", "lemma nested_case: \"(case p of (a,b) \\<Rightarrow> (case p of (c,d) \\<Rightarrow> f a b c d)) =\n  (case p of (a,b) \\<Rightarrow> f a b a b)\"", "lemma split_prod_bound: \"(\\<lambda>p. f p) = (\\<lambda>(a,b). f (a,b))\"", "lemma bpc_conv: \"do { (a,b) \\<leftarrow> (m::(_*_) Heap); f a b } = do {\n  ab \\<leftarrow> (m);\n  f (fst ab) (snd ab)\n}\"", "lemma it_case_pp: \"(case p of ((p1,p2)) \\<Rightarrow> case p of ((p1',p2')) \\<Rightarrow> f p1 p2 p1' p2')\n  = (case p of ((p1,p2)) \\<Rightarrow> f p1 p2 p1 p2)\"", "lemma it_case_ppp: \"(case p of ((p1,p2),p3) \\<Rightarrow> case p of ((p1',p2'),p3') \\<Rightarrow> f p1 p2 p3 p1' p2' p3')\n  = (case p of ((p1,p2),p3) \\<Rightarrow> f p1 p2 p3 p1 p2 p3)\"", "lemma it_case_pppp: \"(case a1 of\n              (((a, b), c), d) \\<Rightarrow>\n                case a1 of\n                (((a', b'), c'), d') \\<Rightarrow> f a b c d a' b' c' d') =\n       (case a1 of\n              (((a, b), c), d) \\<Rightarrow> f a b c d a b c d)\"", "lemmas inlines = hm_append_op_impl_def ial_append_def\n    marl_length_def marl_append_def hm_length_impl_def ial_length_def\n    hm_valid_impl_def hm_prio_of_op_impl_def hm_val_of_op_impl_def hm_key_of_op_impl_def\n    ial_get_def hm_the_lookup_op_impl_def heap_array_set_def marl_get_def\n    it_case_ppp it_case_pppp bind_case bind_case_mvup nested_case if_case_mvup\n    it_case_pp", "lemma hm_swim_op_impl_code[code]: \"hm_swim_op_impl prio hm i \\<equiv> ccpo.fixp (fun_lub Heap_lub) (fun_ord Heap_ord)\n       (\\<lambda>cf (a1, a2).\n           case a1 of\n           ((a1b, a2b), a2a) \\<Rightarrow>\n             case a1b of\n             (a, b) \\<Rightarrow> do {\n               let d2 = efficient_nat_div2 a2; \n               if 0 < d2 \\<and> d2 \\<le> b\n               then do {\n                      x \\<leftarrow> (case a1b of (a, n) \\<Rightarrow> Array.nth a) (d2 - Suc 0);\n                      x \\<leftarrow> Array.nth a2a x;\n                      xa \\<leftarrow> (case a1b of (a, n) \\<Rightarrow> Array.nth a) (a2 - Suc 0);\n                      xa \\<leftarrow> Array.nth a2a xa;\n                      if prio x \\<le> prio xa then return a1\n                      else do {\n                             x'g \\<leftarrow> hm_exch_op_impl a1 a2 (d2);\n                             cf (x'g, d2)\n                           }\n                    }\n               else return a1\n             })\n       (hm, i)\""], "translations": [["", "lemma efficient_nat_div2[simp]: \"efficient_nat_div2 n = n div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. efficient_nat_div2 n = n div 2", "by (simp add: efficient_nat_div2_def nat_of_integer.rep_eq)"], ["", "type_synonym 'v hma = \"nat list \\<times> ('v list)\""], ["", "sepref_decl_intf 'v i_hma is \"nat list \\<times> (nat \\<rightharpoonup> 'v)\""], ["", "locale hmstruct_impl = hmstruct prio for prio :: \"'v::heap \\<Rightarrow> 'p::linorder\"\n  begin"], ["", "lemma param_prio: \"(prio,prio) \\<in> Id \\<rightarrow> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (prio, prio) \\<in> Id \\<rightarrow> Id", "by simp"], ["", "lemmas [sepref_import_param] = param_prio"], ["", "sepref_register prio"], ["", "end"], ["", "context\n    fixes maxsize :: nat\n    fixes prio :: \"'v::heap \\<Rightarrow> 'p::linorder\"\n    notes [map_type_eqs] = map_type_eqI[Pure.of \"TYPE((nat,'v) ahm)\" \"TYPE('v i_hma)\"]\n  begin"], ["", "interpretation hmstruct"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "interpretation hmstruct_impl"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition \"hm_impl1_\\<alpha> \\<equiv> \\<lambda>(pq,ml). \n      (pq,\\<lambda>k. if k\\<in>set pq then Some (ml!k) else None)\""], ["", "definition \"hm_impl1_invar \\<equiv> \\<lambda>(pq,ml). \n        hmr_invar (hm_impl1_\\<alpha> (pq,ml))\n      \\<and> set pq \\<subseteq> {0..<maxsize}  \n      \\<and> ((pq=[] \\<and> ml=[]) \\<or> (length ml = maxsize))\""], ["", "definition \"hm_impl1_weak_invar \\<equiv> \\<lambda>(pq,ml). \n        set pq \\<subseteq> {0..<maxsize}  \n      \\<and> ((pq=[] \\<and> ml=[]) \\<or> (length ml = maxsize))\""], ["", "definition \"hm_impl1_rel \\<equiv> br hm_impl1_\\<alpha> hm_impl1_invar\""], ["", "definition \"hm_weak_impl'_rel \\<equiv> br hm_impl1_\\<alpha> hm_impl1_weak_invar\""], ["", "lemmas hm_impl1_rel_defs = \n      hm_impl1_rel_def hm_weak_impl'_rel_def hm_impl1_weak_invar_def hm_impl1_invar_def hm_impl1_\\<alpha>_def in_br_conv"], ["", "lemma hm_impl_\\<alpha>_fst_eq: \n        \"(x1, x2) = hm_impl1_\\<alpha> (x1a, x2a) \\<Longrightarrow> x1 = x1a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x1, x2) = hm_impl1_\\<alpha> (x1a, x2a) \\<Longrightarrow> x1 = x1a", "unfolding hm_impl1_\\<alpha>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x1, x2) =\n    (case (x1a, x2a) of\n     (pq, ml) \\<Rightarrow>\n       (pq,\n        \\<lambda>k.\n           if k \\<in> set pq then Some (ml ! k)\n           else None)) \\<Longrightarrow>\n    x1 = x1a", "by (auto split: if_split_asm)"], ["", "term hm_empty_op"], ["", "definition hm_empty_op' :: \"'v hma nres\" \n      where \"hm_empty_op' \\<equiv> do {\n        let pq = op_ial_empty_sz maxsize;\n        let ml = op_list_empty;\n        RETURN (pq,ml)\n      }\""], ["", "lemma hm_empty_op'_refine: \"(hm_empty_op', hm_empty_op) \\<in> \\<langle>hm_impl1_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.hm_empty_op', hm_empty_op)\n    \\<in> \\<langle>local.hm_impl1_rel\\<rangle>nres_rel", "apply (intro fun_relI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.hm_empty_op' \\<le> \\<Down> local.hm_impl1_rel hm_empty_op", "unfolding hm_empty_op'_def hm_empty_op_def hm_impl1_rel_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let pq = op_ial_empty_sz maxsize; ml = op_list_empty\n     in RETURN (pq, ml))\n    \\<le> \\<Down>\n           (br (\\<lambda>(pq, ml).\n                   (pq,\n                    \\<lambda>k.\n                       if k \\<in> set pq then Some (ml ! k) else None))\n             (\\<lambda>(pq, ml).\n                 hmr_invar\n                  (case (pq, ml) of\n                   (pq, ml) \\<Rightarrow>\n                     (pq,\n                      \\<lambda>k.\n                         if k \\<in> set pq then Some (ml ! k)\n                         else None)) \\<and>\n                 set pq \\<subseteq> {0..<maxsize} \\<and>\n                 (pq = [] \\<and> ml = [] \\<or> length ml = maxsize)))\n           (RETURN ([], Map.empty))", "by (auto simp: in_br_conv)"], ["", "definition hm_length' :: \"'v hma \\<Rightarrow> nat\" where \"hm_length' \\<equiv> \\<lambda>(pq,ml). length pq\""], ["", "lemma hm_length'_refine: \"(RETURN o hm_length',RETURN o hm_length) \\<in> hm_impl1_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN \\<circ> local.hm_length', RETURN \\<circ> hm_length)\n    \\<in> local.hm_impl1_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>nres_rel", "apply (intro fun_relI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> local.hm_impl1_rel \\<Longrightarrow>\n       (RETURN \\<circ> local.hm_length') a\n       \\<le> \\<Down> nat_rel ((RETURN \\<circ> hm_length) a')", "unfolding hm_length'_def hm_length_def hm_impl1_rel_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       a' =\n       (case a of\n        (pq, ml) \\<Rightarrow>\n          (pq,\n           \\<lambda>k.\n              if k \\<in> set pq then Some (ml ! k) else None)) \\<and>\n       (case a of\n        (pq, ml) \\<Rightarrow>\n          hmr_invar\n           (case (pq, ml) of\n            (pq, ml) \\<Rightarrow>\n              (pq,\n               \\<lambda>k.\n                  if k \\<in> set pq then Some (ml ! k) else None)) \\<and>\n          set pq \\<subseteq> {0..<maxsize} \\<and>\n          (pq = [] \\<and> ml = [] \\<or>\n           length ml = maxsize)) \\<Longrightarrow>\n       (RETURN \\<circ>\\<circ> case_prod) (\\<lambda>pq ml. length pq) a\n       \\<le> \\<Down> nat_rel\n              ((RETURN \\<circ>\\<circ> case_prod) (\\<lambda>pq _. length pq)\n                a')", "by (auto)"], ["", "term hm_key_of_op"], ["", "definition \"hm_key_of_op' \\<equiv> \\<lambda>(pq,ml) i. ASSERT (i>0) \\<then> mop_list_get pq (i - 1)\""], ["", "lemma hm_key_of_op'_refine: \"(hm_key_of_op', hm_key_of_op) \\<in> hm_impl1_rel \\<rightarrow> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hm_key_of_op', hm_key_of_op)\n    \\<in> local.hm_impl1_rel \\<rightarrow>\n          nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>nres_rel", "apply (intro fun_relI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> local.hm_impl1_rel;\n        (aa, a'a) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> hm_key_of_op' a aa\n                         \\<le> \\<Down> nat_rel (hm_key_of_op a' a'a)", "unfolding hm_key_of_op'_def hm_key_of_op_def hm_impl1_rel_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>a' =\n                (case a of\n                 (pq, ml) \\<Rightarrow>\n                   (pq,\n                    \\<lambda>k.\n                       if k \\<in> set pq then Some (ml ! k)\n                       else None)) \\<and>\n                (case a of\n                 (pq, ml) \\<Rightarrow>\n                   hmr_invar\n                    (case (pq, ml) of\n                     (pq, ml) \\<Rightarrow>\n                       (pq,\n                        \\<lambda>k.\n                           if k \\<in> set pq then Some (ml ! k)\n                           else None)) \\<and>\n                   set pq \\<subseteq> {0..<maxsize} \\<and>\n                   (pq = [] \\<and> ml = [] \\<or> length ml = maxsize));\n        (aa, a'a) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> (case a of\n                          (pq, ml) \\<Rightarrow>\n                            \\<lambda>i.\n                               ASSERT (0 < i) \\<bind>\n                               (\\<lambda>_. mop_list_get pq (i - 1)))\n                          aa\n                         \\<le> \\<Down> nat_rel\n                                ((case a' of\n                                  (pq, m) \\<Rightarrow>\n                                    \\<lambda>i.\n ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_get pq (i - 1)))\n                                  a'a)", "by (auto)"], ["", "term hm_lookup"], ["", "definition \"hm_lookup_op' \\<equiv> \\<lambda>(pq,ml) k. do {\n      if (k<maxsize) then do {    \\<comment> \\<open>TODO: This check can be eliminated, but this will complicate refinement of keys in basic ops\\<close>\n        let c = op_list_contains k pq;\n        if c then do {\n          v \\<leftarrow> mop_list_get ml k;\n          RETURN (Some v)\n        } else RETURN None\n      } else RETURN None  \n    }\""], ["", "lemma hm_lookup_op'_refine: \"(uncurry hm_lookup_op', uncurry (RETURN oo hm_lookup)) \n      \\<in> (hm_impl1_rel \\<times>\\<^sub>r nat_rel) \\<rightarrow>\\<^sub>f \\<langle>\\<langle>Id\\<rangle>option_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry local.hm_lookup_op',\n     uncurry (RETURN \\<circ>\\<circ> heapmap_\\<alpha>))\n    \\<in> local.hm_impl1_rel \\<times>\\<^sub>r\n          nat_rel \\<rightarrow>\\<^sub>f \\<langle>\\<langle>Id\\<rangle>option_rel\\<rangle>nres_rel", "apply (intro frefI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True;\n        (x, y) \\<in> local.hm_impl1_rel \\<times>\\<^sub>r nat_rel\\<rbrakk>\n       \\<Longrightarrow> uncurry local.hm_lookup_op' x\n                         \\<le> \\<Down> (\\<langle>Id\\<rangle>option_rel)\n                                (uncurry\n                                  (RETURN \\<circ>\\<circ> heapmap_\\<alpha>)\n                                  y)", "unfolding hm_lookup_op_def hm_lookup_op'_def o_def uncurry_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True;\n        (x, y) \\<in> local.hm_impl1_rel \\<times>\\<^sub>r nat_rel\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          (a, b) \\<Rightarrow>\n                            (case a of\n                             (pq, ml) \\<Rightarrow>\n                               \\<lambda>k.\n                                  if k < maxsize\n                                  then let c = op_list_contains k pq\n in if c then mop_list_get ml k \\<bind> (\\<lambda>v. RETURN (Some v))\n    else RETURN None\n                                  else RETURN None)\n                             b)\n                         \\<le> \\<Down> (\\<langle>Id\\<rangle>option_rel)\n                                (case y of\n                                 (a, b) \\<Rightarrow>\n                                   RETURN (heapmap_\\<alpha> a b))", "apply refine_vcg"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y x1 x2 x1a x1b x2a x2b.\n       \\<lbrakk>True;\n        (x, y) \\<in> local.hm_impl1_rel \\<times>\\<^sub>r nat_rel;\n        y = (x1, x2); x1a = (x1b, x2a); x = (x1a, x2b); x2b < maxsize;\n        op_list_contains x2b x1b\\<rbrakk>\n       \\<Longrightarrow> x2b < length x2a\n 2. \\<And>x y x1 x2 x1a x1b x2a x2b.\n       \\<lbrakk>True;\n        (x, y) \\<in> local.hm_impl1_rel \\<times>\\<^sub>r nat_rel;\n        y = (x1, x2); x1a = (x1b, x2a); x = (x1a, x2b); x2b < maxsize;\n        op_list_contains x2b x1b\\<rbrakk>\n       \\<Longrightarrow> (Some (x2a ! x2b), heapmap_\\<alpha> x1 x2)\n                         \\<in> \\<langle>Id\\<rangle>option_rel\n 3. \\<And>x y x1 x2 x1a x1b x2a x2b.\n       \\<lbrakk>True;\n        (x, y) \\<in> local.hm_impl1_rel \\<times>\\<^sub>r nat_rel;\n        y = (x1, x2); x1a = (x1b, x2a); x = (x1a, x2b); x2b < maxsize;\n        \\<not> op_list_contains x2b x1b\\<rbrakk>\n       \\<Longrightarrow> (None, heapmap_\\<alpha> x1 x2)\n                         \\<in> \\<langle>Id\\<rangle>option_rel\n 4. \\<And>x y x1 x2 x1a x1b x2a x2b.\n       \\<lbrakk>True;\n        (x, y) \\<in> local.hm_impl1_rel \\<times>\\<^sub>r nat_rel;\n        y = (x1, x2); x1a = (x1b, x2a); x = (x1a, x2b);\n        \\<not> x2b < maxsize\\<rbrakk>\n       \\<Longrightarrow> (None, heapmap_\\<alpha> x1 x2)\n                         \\<in> \\<langle>Id\\<rangle>option_rel", "apply (auto simp: hm_impl1_rel_defs heapmap_\\<alpha>_def hmr_invar_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "term hm_contains_key_op"], ["", "definition \"hm_contains_key_op' \\<equiv> \\<lambda>k (pq,ml). do {\n      if (k<maxsize) then do {    \\<comment> \\<open>TODO: This check can be eliminated, but this will complicate refinement of keys in basic ops\\<close>\n        RETURN (op_list_contains k pq)\n      } else RETURN False  \n    }\""], ["", "lemma hm_contains_key_op'_refine: \"(uncurry hm_contains_key_op', uncurry hm_contains_key_op) \n      \\<in> (nat_rel \\<times>\\<^sub>r hm_impl1_rel) \\<rightarrow>\\<^sub>f \\<langle>bool_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry local.hm_contains_key_op', uncurry hm_contains_key_op)\n    \\<in> nat_rel \\<times>\\<^sub>r\n          local.hm_impl1_rel \\<rightarrow>\\<^sub>f \\<langle>bool_rel\\<rangle>nres_rel", "apply (intro frefI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True;\n        (x, y) \\<in> nat_rel \\<times>\\<^sub>r local.hm_impl1_rel\\<rbrakk>\n       \\<Longrightarrow> uncurry local.hm_contains_key_op' x\n                         \\<le> \\<Down> bool_rel\n                                (uncurry hm_contains_key_op y)", "unfolding hm_contains_key_op_def hm_contains_key_op'_def o_def uncurry_def PR_CONST_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True;\n        (x, y) \\<in> nat_rel \\<times>\\<^sub>r local.hm_impl1_rel\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          (a, pq, ml) \\<Rightarrow>\n                            if a < maxsize\n                            then RETURN (op_list_contains a pq)\n                            else RETURN False)\n                         \\<le> \\<Down> bool_rel\n                                (case y of\n                                 (a, pq, m) \\<Rightarrow>\n                                   ASSERT (heapmap_invar (pq, m)) \\<bind>\n                                   (\\<lambda>_. RETURN (a \\<in> dom m)))", "apply refine_vcg"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>True;\n        (x, y) \\<in> nat_rel \\<times>\\<^sub>r local.hm_impl1_rel;\n        x2 = (x1a, x2a); y = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b);\n        heapmap_invar (x1a, x2a); x1b < maxsize\\<rbrakk>\n       \\<Longrightarrow> (op_list_contains x1b x1c, x1 \\<in> dom x2a)\n                         \\<in> bool_rel\n 2. \\<And>x y x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>True;\n        (x, y) \\<in> nat_rel \\<times>\\<^sub>r local.hm_impl1_rel;\n        x2 = (x1a, x2a); y = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b);\n        heapmap_invar (x1a, x2a); \\<not> x1b < maxsize\\<rbrakk>\n       \\<Longrightarrow> (False, x1 \\<in> dom x2a) \\<in> bool_rel", "apply (auto simp: hm_impl1_rel_defs heapmap_\\<alpha>_def hmr_invar_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "term hm_valid"], ["", "definition \"hm_exch_op' \\<equiv> \\<lambda>(pq,ml) i j. do {\n      ASSERT (hm_valid (hm_impl1_\\<alpha> (pq,ml)) i);\n      ASSERT (hm_valid (hm_impl1_\\<alpha> (pq,ml)) j);\n      pq \\<leftarrow> mop_list_swap pq (i - 1) (j - 1);\n      RETURN (pq,ml)\n    }\""], ["", "lemma hm_impl1_relI:\n      assumes \"hmr_invar b\"\n      assumes \"(a,b)\\<in>hm_weak_impl'_rel\"\n      shows \"(a,b)\\<in>hm_impl1_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> local.hm_impl1_rel", "using assms"], ["proof (prove)\nusing this:\n  hmr_invar b\n  (a, b) \\<in> local.hm_weak_impl'_rel\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> local.hm_impl1_rel", "unfolding hmr_rel_def hm_impl1_rel_def hm_weak_impl'_rel_def in_br_conv\n        hm_impl1_weak_invar_def hm_impl1_invar_def"], ["proof (prove)\nusing this:\n  hmr_invar b\n  b = hm_impl1_\\<alpha> a \\<and>\n  (case a of\n   (pq, ml) \\<Rightarrow>\n     set pq \\<subseteq> {0..<maxsize} \\<and>\n     (pq = [] \\<and> ml = [] \\<or> length ml = maxsize))\n\ngoal (1 subgoal):\n 1. b = hm_impl1_\\<alpha> a \\<and>\n    (case a of\n     (pq, ml) \\<Rightarrow>\n       hmr_invar (hm_impl1_\\<alpha> (pq, ml)) \\<and>\n       set pq \\<subseteq> {0..<maxsize} \\<and>\n       (pq = [] \\<and> ml = [] \\<or> length ml = maxsize))", "by auto"], ["", "lemma hm_impl1_nres_relI:\n      assumes \"b \\<le>\\<^sub>n SPEC hmr_invar\"\n      assumes \"(a,b)\\<in>\\<langle>hm_weak_impl'_rel\\<rangle>nres_rel\"\n      shows \"(a,b)\\<in>\\<langle>hm_impl1_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> \\<langle>local.hm_impl1_rel\\<rangle>nres_rel", "using assms hm_impl1_relI"], ["proof (prove)\nusing this:\n  b \\<le>\\<^sub>n SPEC hmr_invar\n  (a, b) \\<in> \\<langle>local.hm_weak_impl'_rel\\<rangle>nres_rel\n  \\<lbrakk>hmr_invar ?b; (?a, ?b) \\<in> local.hm_weak_impl'_rel\\<rbrakk>\n  \\<Longrightarrow> (?a, ?b) \\<in> local.hm_impl1_rel\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> \\<langle>local.hm_impl1_rel\\<rangle>nres_rel", "apply (auto simp: pw_le_iff pw_leof_iff refine_pw_simps in_br_conv nres_rel_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ba.\n       \\<lbrakk>\\<And>a b aa ba.\n                   \\<lbrakk>hmr_invar (a, b);\n                    ((aa, ba), a, b) \\<in> local.hm_weak_impl'_rel\\<rbrakk>\n                   \\<Longrightarrow> ((aa, ba), a, b)\n                                     \\<in> local.hm_impl1_rel;\n        nofail b;\n        \\<forall>a ba. inres b (a, ba) \\<longrightarrow> hmr_invar (a, ba);\n        nofail a;\n        \\<forall>aa ba.\n           inres a (aa, ba) \\<longrightarrow>\n           (\\<exists>a bb.\n               ((aa, ba), a, bb) \\<in> local.hm_weak_impl'_rel \\<and>\n               inres b (a, bb));\n        inres a (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a bb.\n                            ((aa, ba), a, bb)\n                            \\<in> local.hm_impl1_rel \\<and>\n                            inres b (a, bb)", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hm_exch_op'_refine: \"(hm_exch_op', hm_exch_op) \\<in> hm_impl1_rel \\<rightarrow> nat_rel \\<rightarrow> nat_rel \\<rightarrow> \\<langle>hm_impl1_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.hm_exch_op', hm_exch_op)\n    \\<in> local.hm_impl1_rel \\<rightarrow>\n          nat_rel \\<rightarrow>\n          nat_rel \\<rightarrow> \\<langle>local.hm_impl1_rel\\<rangle>nres_rel", "apply (intro fun_relI hm_impl1_nres_relI[OF hm_exch_op_invar])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> local.hm_impl1_rel; (aa, a'a) \\<in> nat_rel;\n        (ab, a'b) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> (local.hm_exch_op' a aa ab, hm_exch_op a' a'a a'b)\n                         \\<in> \\<langle>local.hm_weak_impl'_rel\\<rangle>nres_rel", "unfolding hm_exch_op'_def hm_exch_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> local.hm_impl1_rel; (aa, a'a) \\<in> nat_rel;\n        (ab, a'b) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> ((case a of\n                           (pq, ml) \\<Rightarrow>\n                             \\<lambda>i j.\n                                ASSERT\n                                 (hm_valid (hm_impl1_\\<alpha> (pq, ml))\n                                   i) \\<bind>\n                                (\\<lambda>_.\n                                    ASSERT\n                                     (hm_valid (hm_impl1_\\<alpha> (pq, ml))\n j) \\<bind>\n                                    (\\<lambda>_.\n  mop_list_swap pq (i - 1) (j - 1) \\<bind> (\\<lambda>pq. RETURN (pq, ml)))))\n                           aa ab,\n                          (case a' of\n                           (pq, m) \\<Rightarrow>\n                             \\<lambda>i j.\n                                ASSERT (hm_valid (pq, m) i) \\<bind>\n                                (\\<lambda>_.\n                                    ASSERT (hm_valid (pq, m) j) \\<bind>\n                                    (\\<lambda>_.\n  ASSERT (hmr_invar (pq, m)) \\<bind>\n  (\\<lambda>_.\n      mop_list_swap pq (i - 1) (j - 1) \\<bind>\n      (\\<lambda>pq. RETURN (pq, m))))))\n                           a'a a'b)\n                         \\<in> \\<langle>local.hm_weak_impl'_rel\\<rangle>nres_rel", "apply (auto simp: pw_le_iff refine_pw_simps nres_rel_def\n          hm_impl1_rel_def in_br_conv split: prod.splits)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a'a a'b x1 x2 x1a x2a.\n       \\<lbrakk>local.hm_impl1_invar (x1, x2);\n        hm_impl1_\\<alpha> (x1, x2) = (x1a, x2a); hm_valid (x1a, x2a) a'a;\n        hm_valid (x1a, x2a) a'b; hmr_invar (x1a, x2a);\n        a'a - Suc 0 < length x1a; a'b - Suc 0 < length x1a\\<rbrakk>\n       \\<Longrightarrow> a'a - Suc 0 < length x1\n 2. \\<And>a'a a'b x1 x2 x1a x2a.\n       \\<lbrakk>local.hm_impl1_invar (x1, x2);\n        hm_impl1_\\<alpha> (x1, x2) = (x1a, x2a); hm_valid (x1a, x2a) a'a;\n        hm_valid (x1a, x2a) a'b; hmr_invar (x1a, x2a);\n        a'a - Suc 0 < length x1a; a'b - Suc 0 < length x1a\\<rbrakk>\n       \\<Longrightarrow> a'b - Suc 0 < length x1\n 3. \\<And>a'a a'b x1 x2 x1a x2a ac ba.\n       \\<lbrakk>local.hm_impl1_invar (x1, x2);\n        hm_impl1_\\<alpha> (x1, x2) = (x1a, x2a); hm_valid (x1a, x2a) a'a;\n        hm_valid (x1a, x2a) a'b; hmr_invar (x1a, x2a);\n        a'a - Suc 0 < length x1a; a'b - Suc 0 < length x1a;\n        ((ac, ba), swap x1a (a'a - Suc 0) (a'b - Suc 0), x2a)\n        \\<notin> local.hm_weak_impl'_rel\\<rbrakk>\n       \\<Longrightarrow> a'a - Suc 0 < length x1\n 4. \\<And>a'a a'b x1 x2 x1a x2a ac ba.\n       \\<lbrakk>local.hm_impl1_invar (x1, x2);\n        hm_impl1_\\<alpha> (x1, x2) = (x1a, x2a); hm_valid (x1a, x2a) a'a;\n        hm_valid (x1a, x2a) a'b; hmr_invar (x1a, x2a);\n        a'a - Suc 0 < length x1a; a'b - Suc 0 < length x1a;\n        ((ac, ba), swap x1a (a'a - Suc 0) (a'b - Suc 0), x2a)\n        \\<notin> local.hm_weak_impl'_rel\\<rbrakk>\n       \\<Longrightarrow> a'b - Suc 0 < length x1\n 5. \\<And>a'a a'b x1 x1a x2a ba.\n       \\<lbrakk>local.hm_impl1_invar (x1, ba);\n        hm_impl1_\\<alpha> (x1, ba) = (x1a, x2a); hm_valid (x1a, x2a) a'a;\n        hm_valid (x1a, x2a) a'b; hmr_invar (x1a, x2a);\n        a'a - Suc 0 < length x1a; a'b - Suc 0 < length x1a\\<rbrakk>\n       \\<Longrightarrow> ((swap x1 (a'a - Suc 0) (a'b - Suc 0), ba),\n                          swap x1a (a'a - Suc 0) (a'b - Suc 0), x2a)\n                         \\<in> local.hm_weak_impl'_rel", "apply (auto simp: hm_impl1_\\<alpha>_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a'a a'b x1a ba.\n       \\<lbrakk>local.hm_impl1_invar (x1a, ba);\n        hm_valid\n         (x1a, \\<lambda>k. if k \\<in> set x1a then Some (ba ! k) else None)\n         a'a;\n        hm_valid\n         (x1a, \\<lambda>k. if k \\<in> set x1a then Some (ba ! k) else None)\n         a'b;\n        hmr_invar\n         (x1a, \\<lambda>k. if k \\<in> set x1a then Some (ba ! k) else None);\n        a'a - Suc 0 < length x1a; a'b - Suc 0 < length x1a\\<rbrakk>\n       \\<Longrightarrow> ((swap x1a (a'a - Suc 0) (a'b - Suc 0), ba),\n                          swap x1a (a'a - Suc 0) (a'b - Suc 0),\n                          \\<lambda>k.\n                             if k \\<in> set x1a then Some (ba ! k)\n                             else None)\n                         \\<in> local.hm_weak_impl'_rel", "unfolding hm_impl1_rel_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a'a a'b x1a ba.\n       \\<lbrakk>case (x1a, ba) of\n                (pq, ml) \\<Rightarrow>\n                  hmr_invar\n                   (case (pq, ml) of\n                    (pq, ml) \\<Rightarrow>\n                      (pq,\n                       \\<lambda>k.\n                          if k \\<in> set pq then Some (ml ! k)\n                          else None)) \\<and>\n                  set pq \\<subseteq> {0..<maxsize} \\<and>\n                  (pq = [] \\<and> ml = [] \\<or> length ml = maxsize);\n        hm_valid\n         (x1a, \\<lambda>k. if k \\<in> set x1a then Some (ba ! k) else None)\n         a'a;\n        hm_valid\n         (x1a, \\<lambda>k. if k \\<in> set x1a then Some (ba ! k) else None)\n         a'b;\n        hmr_invar\n         (x1a, \\<lambda>k. if k \\<in> set x1a then Some (ba ! k) else None);\n        a'a - Suc 0 < length x1a; a'b - Suc 0 < length x1a\\<rbrakk>\n       \\<Longrightarrow> (swap x1a (a'a - Suc 0) (a'b - Suc 0),\n                          \\<lambda>k.\n                             if k \\<in> set x1a then Some (ba ! k)\n                             else None) =\n                         (case (swap x1a (a'a - Suc 0) (a'b - Suc 0), ba) of\n                          (pq, ml) \\<Rightarrow>\n                            (pq,\n                             \\<lambda>k.\n                                if k \\<in> set pq then Some (ml ! k)\n                                else None)) \\<and>\n                         (case (swap x1a (a'a - Suc 0) (a'b - Suc 0), ba) of\n                          (pq, ml) \\<Rightarrow>\n                            set pq \\<subseteq> {0..<maxsize} \\<and>\n                            (pq = [] \\<and> ml = [] \\<or>\n                             length ml = maxsize))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "term hm_index_op"], ["", "definition \"hm_index_op' \\<equiv> \\<lambda>(pq,ml) k. \n      do {\n        ASSERT (hm_impl1_invar (pq,ml) \\<and> heapmap_\\<alpha> (hm_impl1_\\<alpha> (pq,ml)) k \\<noteq> None \\<and> k\\<in>set pq);\n        i \\<leftarrow> mop_list_index pq k;\n        RETURN (i+1)\n      }\""], ["", "lemma hm_index_op'_refine: \"(hm_index_op',hm_index_op) \n      \\<in> hm_impl1_rel \\<rightarrow> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.hm_index_op', hm_index_op)\n    \\<in> local.hm_impl1_rel \\<rightarrow>\n          nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>nres_rel", "apply (intro fun_relI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> local.hm_impl1_rel;\n        (aa, a'a) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> local.hm_index_op' a aa\n                         \\<le> \\<Down> nat_rel (hm_index_op a' a'a)", "unfolding hm_index_op'_def hm_index_op_def hm_impl1_rel_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>a' =\n                (case a of\n                 (pq, ml) \\<Rightarrow>\n                   (pq,\n                    \\<lambda>k.\n                       if k \\<in> set pq then Some (ml ! k)\n                       else None)) \\<and>\n                (case a of\n                 (pq, ml) \\<Rightarrow>\n                   hmr_invar\n                    (case (pq, ml) of\n                     (pq, ml) \\<Rightarrow>\n                       (pq,\n                        \\<lambda>k.\n                           if k \\<in> set pq then Some (ml ! k)\n                           else None)) \\<and>\n                   set pq \\<subseteq> {0..<maxsize} \\<and>\n                   (pq = [] \\<and> ml = [] \\<or> length ml = maxsize));\n        (aa, a'a) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> (case a of\n                          (pq, ml) \\<Rightarrow>\n                            \\<lambda>k.\n                               ASSERT\n                                ((case (pq, ml) of\n                                  (pq, ml) \\<Rightarrow>\n                                    hmr_invar\n                                     (case (pq, ml) of\n(pq, ml) \\<Rightarrow>\n  (pq, \\<lambda>k. if k \\<in> set pq then Some (ml ! k) else None)) \\<and>\n                                    set pq \\<subseteq> {0..<maxsize} \\<and>\n                                    (pq = [] \\<and> ml = [] \\<or>\n                                     length ml = maxsize)) \\<and>\n                                 heapmap_\\<alpha>\n                                  (case (pq, ml) of\n                                   (pq, ml) \\<Rightarrow>\n                                     (pq,\n\\<lambda>k. if k \\<in> set pq then Some (ml ! k) else None))\n                                  k \\<noteq>\n                                 None \\<and>\n                                 k \\<in> set pq) \\<bind>\n                               (\\<lambda>_.\n                                   mop_list_index pq k \\<bind>\n                                   (\\<lambda>i. RETURN (i + 1))))\n                          aa\n                         \\<le> \\<Down> nat_rel\n                                ((case a' of\n                                  (pq, m) \\<Rightarrow>\n                                    \\<lambda>k.\n ASSERT\n  (hmr_invar (pq, m) \\<and>\n   heapmap_\\<alpha> (pq, m) k \\<noteq> None) \\<bind>\n (\\<lambda>_. mop_list_index pq k \\<bind> (\\<lambda>i. RETURN (i + 1))))\n                                  a'a)", "apply (auto simp: pw_le_iff refine_pw_simps heapmap_\\<alpha>_def split: if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition hm_update_op' where\n      \"hm_update_op' \\<equiv> \\<lambda>(pq,ml) i v. do {\n        ASSERT (hm_valid (hm_impl1_\\<alpha> (pq,ml)) i \\<and> hm_impl1_invar (pq,ml));\n        k \\<leftarrow> mop_list_get pq (i - 1);\n        ml \\<leftarrow> mop_list_set ml k v;\n        RETURN (pq, ml)\n      }\""], ["", "lemma hm_update_op'_refine: \"(hm_update_op', hm_update_op) \\<in> hm_impl1_rel \\<rightarrow> nat_rel \\<rightarrow> Id \\<rightarrow> \\<langle>hm_impl1_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.hm_update_op', hm_update_op)\n    \\<in> local.hm_impl1_rel \\<rightarrow>\n          nat_rel \\<rightarrow>\n          Id \\<rightarrow> \\<langle>local.hm_impl1_rel\\<rangle>nres_rel", "apply (intro fun_relI hm_impl1_nres_relI[OF hm_update_op_invar])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> local.hm_impl1_rel; (aa, a'a) \\<in> nat_rel;\n        (ab, a'b) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> (local.hm_update_op' a aa ab,\n                          hm_update_op a' a'a a'b)\n                         \\<in> \\<langle>local.hm_weak_impl'_rel\\<rangle>nres_rel", "unfolding hm_update_op'_def hm_update_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> local.hm_impl1_rel; (aa, a'a) \\<in> nat_rel;\n        (ab, a'b) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> ((case a of\n                           (pq, ml) \\<Rightarrow>\n                             \\<lambda>i v.\n                                ASSERT\n                                 (hm_valid (hm_impl1_\\<alpha> (pq, ml))\n                                   i \\<and>\n                                  local.hm_impl1_invar (pq, ml)) \\<bind>\n                                (\\<lambda>_.\n                                    mop_list_get pq (i - 1) \\<bind>\n                                    (\\<lambda>k.\n  mop_list_set ml k v \\<bind> (\\<lambda>ml. RETURN (pq, ml)))))\n                           aa ab,\n                          (case a' of\n                           (pq, m) \\<Rightarrow>\n                             \\<lambda>i v.\n                                ASSERT\n                                 (hm_valid (pq, m) i \\<and>\n                                  hmr_invar (pq, m)) \\<bind>\n                                (\\<lambda>_.\n                                    mop_list_get pq (i - 1) \\<bind>\n                                    (\\<lambda>k.\n  RETURN (pq, m(k \\<mapsto> v)))))\n                           a'a a'b)\n                         \\<in> \\<langle>local.hm_weak_impl'_rel\\<rangle>nres_rel", "apply (auto simp: pw_le_iff refine_pw_simps nres_rel_def\n          hm_impl1_rel_def in_br_conv split: prod.splits)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a'a x1 x2 x1a x2a.\n       \\<lbrakk>local.hm_impl1_invar (x1, x2);\n        hm_impl1_\\<alpha> (x1, x2) = (x1a, x2a); hm_valid (x1a, x2a) a'a;\n        hmr_invar (x1a, x2a); a'a - Suc 0 < length x1a\\<rbrakk>\n       \\<Longrightarrow> a'a - Suc 0 < length x1\n 2. \\<And>a'a x1 x2 x1a x2a.\n       \\<lbrakk>local.hm_impl1_invar (x1, x2);\n        hm_impl1_\\<alpha> (x1, x2) = (x1a, x2a); hm_valid (x1a, x2a) a'a;\n        hmr_invar (x1a, x2a); a'a - Suc 0 < length x1a\\<rbrakk>\n       \\<Longrightarrow> x1 ! (a'a - Suc 0) < length x2\n 3. \\<And>a'a a'b x1 x2 x1a x2a ac ba.\n       \\<lbrakk>local.hm_impl1_invar (x1, x2);\n        hm_impl1_\\<alpha> (x1, x2) = (x1a, x2a); hm_valid (x1a, x2a) a'a;\n        hmr_invar (x1a, x2a); a'a - Suc 0 < length x1a;\n        \\<not> a'a - Suc 0 < length x1\\<rbrakk>\n       \\<Longrightarrow> ((ac, ba), x1a, x2a(x1a ! (a'a - Suc 0) \\<mapsto>\n                          a'b))\n                         \\<in> local.hm_weak_impl'_rel\n 4. \\<And>a'a a'b x1 x2 x1a x2a ac ba.\n       \\<lbrakk>local.hm_impl1_invar (x1, x2);\n        hm_impl1_\\<alpha> (x1, x2) = (x1a, x2a); hm_valid (x1a, x2a) a'a;\n        hmr_invar (x1a, x2a); a'a - Suc 0 < length x1a;\n        \\<not> x1 ! (a'a - Suc 0) < length x2\\<rbrakk>\n       \\<Longrightarrow> ((ac, ba), x1a, x2a(x1a ! (a'a - Suc 0) \\<mapsto>\n                          a'b))\n                         \\<in> local.hm_weak_impl'_rel\n 5. \\<And>a'a a'b x2 x1a x2a ac.\n       \\<lbrakk>local.hm_impl1_invar (ac, x2);\n        hm_impl1_\\<alpha> (ac, x2) = (x1a, x2a); hm_valid (x1a, x2a) a'a;\n        hmr_invar (x1a, x2a); a'a - Suc 0 < length x1a\\<rbrakk>\n       \\<Longrightarrow> ((ac, x2[ac ! (a'a - Suc 0) := a'b]), x1a, x2a\n                          (x1a ! (a'a - Suc 0) \\<mapsto> a'b))\n                         \\<in> local.hm_weak_impl'_rel", "apply (auto simp: hm_impl1_\\<alpha>_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a'a x2 x1a.\n       \\<lbrakk>local.hm_impl1_invar (x1a, x2);\n        hm_valid\n         (x1a, \\<lambda>k. if k \\<in> set x1a then Some (x2 ! k) else None)\n         a'a;\n        hmr_invar\n         (x1a, \\<lambda>k. if k \\<in> set x1a then Some (x2 ! k) else None);\n        a'a - Suc 0 < length x1a\\<rbrakk>\n       \\<Longrightarrow> x1a ! (a'a - Suc 0) < length x2\n 2. \\<And>a'a a'b x2 x1a ac ba.\n       \\<lbrakk>local.hm_impl1_invar (x1a, x2);\n        hm_valid\n         (x1a, \\<lambda>k. if k \\<in> set x1a then Some (x2 ! k) else None)\n         a'a;\n        hmr_invar\n         (x1a, \\<lambda>k. if k \\<in> set x1a then Some (x2 ! k) else None);\n        a'a - Suc 0 < length x1a;\n        \\<not> x1a ! (a'a - Suc 0) < length x2\\<rbrakk>\n       \\<Longrightarrow> ((ac, ba), x1a,\n                          (\\<lambda>k.\n                              if k \\<in> set x1a then Some (x2 ! k)\n                              else None)\n                          (x1a ! (a'a - Suc 0) \\<mapsto> a'b))\n                         \\<in> local.hm_weak_impl'_rel\n 3. \\<And>a'a a'b x2 x1a.\n       \\<lbrakk>local.hm_impl1_invar (x1a, x2);\n        hm_valid\n         (x1a, \\<lambda>k. if k \\<in> set x1a then Some (x2 ! k) else None)\n         a'a;\n        hmr_invar\n         (x1a, \\<lambda>k. if k \\<in> set x1a then Some (x2 ! k) else None);\n        a'a - Suc 0 < length x1a\\<rbrakk>\n       \\<Longrightarrow> ((x1a, x2[x1a ! (a'a - Suc 0) := a'b]), x1a,\n                          (\\<lambda>k.\n                              if k \\<in> set x1a then Some (x2 ! k)\n                              else None)\n                          (x1a ! (a'a - Suc 0) \\<mapsto> a'b))\n                         \\<in> local.hm_weak_impl'_rel", "unfolding hm_impl1_rel_defs"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a'a x2 x1a.\n       \\<lbrakk>case (x1a, x2) of\n                (pq, ml) \\<Rightarrow>\n                  hmr_invar\n                   (case (pq, ml) of\n                    (pq, ml) \\<Rightarrow>\n                      (pq,\n                       \\<lambda>k.\n                          if k \\<in> set pq then Some (ml ! k)\n                          else None)) \\<and>\n                  set pq \\<subseteq> {0..<maxsize} \\<and>\n                  (pq = [] \\<and> ml = [] \\<or> length ml = maxsize);\n        hm_valid\n         (x1a, \\<lambda>k. if k \\<in> set x1a then Some (x2 ! k) else None)\n         a'a;\n        hmr_invar\n         (x1a, \\<lambda>k. if k \\<in> set x1a then Some (x2 ! k) else None);\n        a'a - Suc 0 < length x1a\\<rbrakk>\n       \\<Longrightarrow> x1a ! (a'a - Suc 0) < length x2\n 2. \\<And>a'a a'b x2 x1a ac ba.\n       \\<lbrakk>case (x1a, x2) of\n                (pq, ml) \\<Rightarrow>\n                  hmr_invar\n                   (case (pq, ml) of\n                    (pq, ml) \\<Rightarrow>\n                      (pq,\n                       \\<lambda>k.\n                          if k \\<in> set pq then Some (ml ! k)\n                          else None)) \\<and>\n                  set pq \\<subseteq> {0..<maxsize} \\<and>\n                  (pq = [] \\<and> ml = [] \\<or> length ml = maxsize);\n        hm_valid\n         (x1a, \\<lambda>k. if k \\<in> set x1a then Some (x2 ! k) else None)\n         a'a;\n        hmr_invar\n         (x1a, \\<lambda>k. if k \\<in> set x1a then Some (x2 ! k) else None);\n        a'a - Suc 0 < length x1a;\n        \\<not> x1a ! (a'a - Suc 0) < length x2\\<rbrakk>\n       \\<Longrightarrow> (x1a,\n                          (\\<lambda>k.\n                              if k \\<in> set x1a then Some (x2 ! k)\n                              else None)\n                          (x1a ! (a'a - Suc 0) \\<mapsto> a'b)) =\n                         (case (ac, ba) of\n                          (pq, ml) \\<Rightarrow>\n                            (pq,\n                             \\<lambda>k.\n                                if k \\<in> set pq then Some (ml ! k)\n                                else None)) \\<and>\n                         (case (ac, ba) of\n                          (pq, ml) \\<Rightarrow>\n                            set pq \\<subseteq> {0..<maxsize} \\<and>\n                            (pq = [] \\<and> ml = [] \\<or>\n                             length ml = maxsize))\n 3. \\<And>a'a a'b x2 x1a.\n       \\<lbrakk>case (x1a, x2) of\n                (pq, ml) \\<Rightarrow>\n                  hmr_invar\n                   (case (pq, ml) of\n                    (pq, ml) \\<Rightarrow>\n                      (pq,\n                       \\<lambda>k.\n                          if k \\<in> set pq then Some (ml ! k)\n                          else None)) \\<and>\n                  set pq \\<subseteq> {0..<maxsize} \\<and>\n                  (pq = [] \\<and> ml = [] \\<or> length ml = maxsize);\n        hm_valid\n         (x1a, \\<lambda>k. if k \\<in> set x1a then Some (x2 ! k) else None)\n         a'a;\n        hmr_invar\n         (x1a, \\<lambda>k. if k \\<in> set x1a then Some (x2 ! k) else None);\n        a'a - Suc 0 < length x1a\\<rbrakk>\n       \\<Longrightarrow> (x1a,\n                          (\\<lambda>k.\n                              if k \\<in> set x1a then Some (x2 ! k)\n                              else None)\n                          (x1a ! (a'a - Suc 0) \\<mapsto> a'b)) =\n                         (case (x1a, x2[x1a ! (a'a - Suc 0) := a'b]) of\n                          (pq, ml) \\<Rightarrow>\n                            (pq,\n                             \\<lambda>k.\n                                if k \\<in> set pq then Some (ml ! k)\n                                else None)) \\<and>\n                         (case (x1a, x2[x1a ! (a'a - Suc 0) := a'b]) of\n                          (pq, ml) \\<Rightarrow>\n                            set pq \\<subseteq> {0..<maxsize} \\<and>\n                            (pq = [] \\<and> ml = [] \\<or>\n                             length ml = maxsize))", "apply (auto simp: subset_code(1))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "term hm_butlast_op"], ["", "lemma hm_butlast_op_invar: \"hm_butlast_op hm \\<le>\\<^sub>n SPEC hmr_invar\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_butlast_op hm \\<le>\\<^sub>n SPEC hmr_invar", "unfolding hm_butlast_op_def h.butlast_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case hm of\n     (pq, m) \\<Rightarrow>\n       ASSERT (hmr_invar (pq, m)) \\<bind>\n       (\\<lambda>_.\n           mop_list_get pq (length pq - 1) \\<bind>\n           (\\<lambda>k.\n               mop_list_butlast pq \\<bind>\n               (\\<lambda>pq.\n                   let m = m(k := None) in RETURN (pq, m))))) \\<le>\\<^sub>n\n    SPEC hmr_invar", "apply refine_vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>hm = (x1, x2); hmr_invar (x1, x2);\n        length x1 - 1 < length x1; x1 \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> hmr_invar\n                          (butlast x1, x2(x1 ! (length x1 - 1) := None))", "apply (clarsimp_all simp: hmr_rel_defs map_butlast distinct_butlast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>hm = (x1, x2); x1 \\<noteq> []; distinct x1;\n        dom x2 = set x1\\<rbrakk>\n       \\<Longrightarrow> set x1 - {x1 ! (length x1 - Suc 0)} =\n                         set (butlast x1)", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1 x2 x.\n       \\<lbrakk>hm = (x1, x2); x1 \\<noteq> []; distinct x1; dom x2 = set x1;\n        x \\<in> set x1; x \\<notin> set (butlast x1); x \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> x = x1 ! (length x1 - Suc 0)\n 2. \\<And>x1 x2 x.\n       \\<lbrakk>hm = (x1, x2); x1 \\<noteq> []; distinct x1; dom x2 = set x1;\n        x \\<in> set (butlast x1)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set x1\n 3. \\<And>x1 x2 x.\n       \\<lbrakk>hm = (x1, x2); x1 \\<noteq> []; distinct x1; dom x2 = set x1;\n        x1 ! (length x1 - Suc 0) \\<in> set (butlast x1)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (auto simp: in_set_conv_nth nth_butlast) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1 x2 i.\n       \\<lbrakk>hm = (x1, x2); distinct x1; dom x2 = set x1;\n        \\<forall>ia<length x1 - Suc 0. x1 ! ia \\<noteq> x1 ! i;\n        i < length x1\\<rbrakk>\n       \\<Longrightarrow> x1 ! i = x1 ! (length x1 - Suc 0)\n 2. \\<And>x1 x2 x.\n       \\<lbrakk>hm = (x1, x2); x1 \\<noteq> []; distinct x1; dom x2 = set x1;\n        x \\<in> set (butlast x1)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set x1\n 3. \\<And>x1 x2 x.\n       \\<lbrakk>hm = (x1, x2); x1 \\<noteq> []; distinct x1; dom x2 = set x1;\n        x1 ! (length x1 - Suc 0) \\<in> set (butlast x1)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis Suc_pred len_greater_imp_nonempty length_greater_0_conv less_antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x.\n       \\<lbrakk>hm = (x1, x2); x1 \\<noteq> []; distinct x1; dom x2 = set x1;\n        x \\<in> set (butlast x1)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set x1\n 2. \\<And>x1 x2 x.\n       \\<lbrakk>hm = (x1, x2); x1 \\<noteq> []; distinct x1; dom x2 = set x1;\n        x1 ! (length x1 - Suc 0) \\<in> set (butlast x1)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (auto dest: in_set_butlastD) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x.\n       \\<lbrakk>hm = (x1, x2); x1 \\<noteq> []; distinct x1; dom x2 = set x1;\n        x1 ! (length x1 - Suc 0) \\<in> set (butlast x1)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis One_nat_def append_butlast_last_id distinct_butlast last_conv_nth not_distinct_conv_prefix)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition hm_butlast_op' where\n      \"hm_butlast_op' \\<equiv> \\<lambda>(pq,ml). do {\n        ASSERT (hmr_invar (hm_impl1_\\<alpha> (pq,ml)));\n        pq \\<leftarrow> mop_list_butlast pq;\n        RETURN (pq,ml)\n      }\""], ["", "lemma set_butlast_distinct_conv: \n      \"\\<lbrakk>distinct l\\<rbrakk> \\<Longrightarrow> set (butlast l) = set l - {last l}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct l \\<Longrightarrow> set (butlast l) = set l - {last l}", "by (cases l rule: rev_cases; auto)"], ["", "lemma hm_butlast_op'_refine: \"(hm_butlast_op', hm_butlast_op) \\<in> hm_impl1_rel \\<rightarrow> \\<langle>hm_impl1_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hm_butlast_op', hm_butlast_op)\n    \\<in> local.hm_impl1_rel \\<rightarrow>\n          \\<langle>local.hm_impl1_rel\\<rangle>nres_rel", "apply (intro fun_relI hm_impl1_nres_relI[OF hm_butlast_op_invar])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> local.hm_impl1_rel \\<Longrightarrow>\n       (hm_butlast_op' a, hm_butlast_op a')\n       \\<in> \\<langle>local.hm_weak_impl'_rel\\<rangle>nres_rel", "unfolding hm_butlast_op'_def hm_butlast_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> local.hm_impl1_rel \\<Longrightarrow>\n       (case a of\n        (pq, ml) \\<Rightarrow>\n          ASSERT (hmr_invar (hm_impl1_\\<alpha> (pq, ml))) \\<bind>\n          (\\<lambda>_.\n              mop_list_butlast pq \\<bind> (\\<lambda>pq. RETURN (pq, ml))),\n        case a' of\n        (pq, m) \\<Rightarrow>\n          ASSERT (hmr_invar (pq, m)) \\<bind>\n          (\\<lambda>_.\n              mop_list_get pq (length pq - 1) \\<bind>\n              (\\<lambda>k.\n                  mop_list_butlast pq \\<bind>\n                  (\\<lambda>pq. let m = m(k := None) in RETURN (pq, m)))))\n       \\<in> \\<langle>local.hm_weak_impl'_rel\\<rangle>nres_rel", "apply (auto simp: pw_le_iff refine_pw_simps nres_rel_def\n          hm_impl1_rel_def in_br_conv split: prod.splits)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x2 x1a x2a.\n       \\<lbrakk>local.hm_impl1_invar ([], x2);\n        hm_impl1_\\<alpha> ([], x2) = (x1a, x2a); hmr_invar (x1a, x2a);\n        x1a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x2 x1a x2a aa ba.\n       \\<lbrakk>local.hm_impl1_invar ([], x2);\n        hm_impl1_\\<alpha> ([], x2) = (x1a, x2a); hmr_invar (x1a, x2a);\n        x1a \\<noteq> [];\n        ((aa, ba), butlast x1a, x2a(x1a ! (length x1a - Suc 0) := None))\n        \\<notin> local.hm_weak_impl'_rel\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x1 x1a x2a ba.\n       \\<lbrakk>local.hm_impl1_invar (x1, ba);\n        hm_impl1_\\<alpha> (x1, ba) = (x1a, x2a); hmr_invar (x1a, x2a);\n        x1a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> ((butlast x1, ba), butlast x1a, x2a\n                          (x1a ! (length x1a - Suc 0) := None))\n                         \\<in> local.hm_weak_impl'_rel", "apply (auto simp: hm_impl1_\\<alpha>_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a ba.\n       \\<lbrakk>local.hm_impl1_invar (x1a, ba);\n        hmr_invar\n         (x1a, \\<lambda>k. if k \\<in> set x1a then Some (ba ! k) else None);\n        x1a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> ((butlast x1a, ba), butlast x1a,\n                          (\\<lambda>k.\n                              if k \\<in> set x1a then Some (ba ! k)\n                              else None)\n                          (x1a ! (length x1a - Suc 0) := None))\n                         \\<in> local.hm_weak_impl'_rel", "unfolding hm_impl1_rel_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a ba.\n       \\<lbrakk>case (x1a, ba) of\n                (pq, ml) \\<Rightarrow>\n                  hmr_invar\n                   (case (pq, ml) of\n                    (pq, ml) \\<Rightarrow>\n                      (pq,\n                       \\<lambda>k.\n                          if k \\<in> set pq then Some (ml ! k)\n                          else None)) \\<and>\n                  set pq \\<subseteq> {0..<maxsize} \\<and>\n                  (pq = [] \\<and> ml = [] \\<or> length ml = maxsize);\n        hmr_invar\n         (x1a, \\<lambda>k. if k \\<in> set x1a then Some (ba ! k) else None);\n        x1a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (butlast x1a,\n                          (\\<lambda>k.\n                              if k \\<in> set x1a then Some (ba ! k)\n                              else None)\n                          (x1a ! (length x1a - Suc 0) := None)) =\n                         (case (butlast x1a, ba) of\n                          (pq, ml) \\<Rightarrow>\n                            (pq,\n                             \\<lambda>k.\n                                if k \\<in> set pq then Some (ml ! k)\n                                else None)) \\<and>\n                         (case (butlast x1a, ba) of\n                          (pq, ml) \\<Rightarrow>\n                            set pq \\<subseteq> {0..<maxsize} \\<and>\n                            (pq = [] \\<and> ml = [] \\<or>\n                             length ml = maxsize))", "apply (auto simp: restrict_map_def) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1a ba.\n       \\<lbrakk>hmr_invar\n                 (x1a,\n                  \\<lambda>k.\n                     if k \\<in> set x1a then Some (ba ! k) else None);\n        x1a \\<noteq> []; set x1a \\<subseteq> {0..<length ba};\n        maxsize = length ba\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>k.\n                             if k \\<in> set x1a then Some (ba ! k)\n                             else None)\n                         (x1a ! (length x1a - Suc 0) := None) =\n                         (\\<lambda>k.\n                             if k \\<in> set (butlast x1a) then Some (ba ! k)\n                             else None)\n 2. \\<And>x1a ba x.\n       \\<lbrakk>hmr_invar\n                 (x1a,\n                  \\<lambda>k.\n                     if k \\<in> set x1a then Some (ba ! k) else None);\n        x1a \\<noteq> []; set x1a \\<subseteq> {0..<length ba};\n        maxsize = length ba; x \\<in> set (butlast x1a)\\<rbrakk>\n       \\<Longrightarrow> x < length ba", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1a ba x.\n       \\<lbrakk>hmr_invar\n                 (x1a,\n                  \\<lambda>k.\n                     if k \\<in> set x1a then Some (ba ! k) else None);\n        x1a \\<noteq> []; set x1a \\<subseteq> {0..<length ba};\n        maxsize = length ba; x \\<in> set (butlast x1a)\\<rbrakk>\n       \\<Longrightarrow> x < length ba\n 2. \\<And>x1a ba.\n       \\<lbrakk>hmr_invar\n                 (x1a,\n                  \\<lambda>k.\n                     if k \\<in> set x1a then Some (ba ! k) else None);\n        x1a \\<noteq> []; set x1a \\<subseteq> {0..<length ba};\n        maxsize = length ba\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>k.\n                             if k \\<in> set x1a then Some (ba ! k)\n                             else None)\n                         (x1a ! (length x1a - Suc 0) := None) =\n                         (\\<lambda>k.\n                             if k \\<in> set (butlast x1a) then Some (ba ! k)\n                             else None)", "apply (auto dest: in_set_butlastD) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a ba.\n       \\<lbrakk>hmr_invar\n                 (x1a,\n                  \\<lambda>k.\n                     if k \\<in> set x1a then Some (ba ! k) else None);\n        x1a \\<noteq> []; set x1a \\<subseteq> {0..<length ba};\n        maxsize = length ba\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>k.\n                             if k \\<in> set x1a then Some (ba ! k)\n                             else None)\n                         (x1a ! (length x1a - Suc 0) := None) =\n                         (\\<lambda>k.\n                             if k \\<in> set (butlast x1a) then Some (ba ! k)\n                             else None)", "apply (auto intro!: ext \n        simp: hmr_invar_def set_butlast_distinct_conv last_conv_nth\n        dest: in_set_butlastD) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition hm_append_op' \n      where \"hm_append_op' \\<equiv> \\<lambda>(pq,ml) k v. do {\n        ASSERT (k \\<notin> set pq \\<and> k<maxsize);\n        ASSERT (hm_impl1_invar (pq,ml));\n        pq \\<leftarrow> mop_list_append pq k;\n        ml \\<leftarrow> (if length ml = 0 then mop_list_replicate maxsize v else RETURN ml);\n        ml \\<leftarrow> mop_list_set ml k v;\n        RETURN (pq,ml)\n      }\""], ["", "lemma hm_append_op'_refine: \"(uncurry2 hm_append_op', uncurry2 hm_append_op) \n      \\<in> [\\<lambda>((hm,k),v). k<maxsize]\\<^sub>f (hm_impl1_rel \\<times>\\<^sub>r nat_rel) \\<times>\\<^sub>r Id \\<rightarrow> \\<langle>hm_impl1_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 local.hm_append_op', uncurry2 hm_append_op)\n    \\<in> [\\<lambda>((hm, k), v).\n              k < maxsize]\\<^sub>f (local.hm_impl1_rel \\<times>\\<^sub>r\n                                    nat_rel) \\<times>\\<^sub>r\n                                   Id \\<rightarrow> \\<langle>local.hm_impl1_rel\\<rangle>nres_rel", "apply (intro frefI hm_impl1_nres_relI[OF hm_append_op_invar])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>case y of\n                (x, xa) \\<Rightarrow>\n                  (case x of (hm, k) \\<Rightarrow> \\<lambda>v. k < maxsize)\n                   xa;\n        (x, y)\n        \\<in> (local.hm_impl1_rel \\<times>\\<^sub>r nat_rel) \\<times>\\<^sub>r\n              Id\\<rbrakk>\n       \\<Longrightarrow> (uncurry2 local.hm_append_op' x,\n                          uncurry2 hm_append_op y)\n                         \\<in> \\<langle>local.hm_impl1_rel\\<rangle>nres_rel", "unfolding hm_append_op'_def hm_append_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>case y of\n                (x, xa) \\<Rightarrow>\n                  (case x of (hm, k) \\<Rightarrow> \\<lambda>v. k < maxsize)\n                   xa;\n        (x, y)\n        \\<in> (local.hm_impl1_rel \\<times>\\<^sub>r nat_rel) \\<times>\\<^sub>r\n              Id\\<rbrakk>\n       \\<Longrightarrow> (uncurry2\n                           (\\<lambda>(pq, ml) k v.\n                               ASSERT\n                                (k \\<notin> set pq \\<and>\n                                 k < maxsize) \\<bind>\n                               (\\<lambda>_.\n                                   ASSERT\n                                    (local.hm_impl1_invar (pq, ml)) \\<bind>\n                                   (\\<lambda>_.\n mop_list_append pq k \\<bind>\n (\\<lambda>pq.\n     (if length ml = 0 then mop_list_replicate maxsize v\n      else RETURN ml) \\<bind>\n     (\\<lambda>ml.\n         mop_list_set ml k v \\<bind> (\\<lambda>ml. RETURN (pq, ml)))))))\n                           x,\n                          uncurry2\n                           (\\<lambda>(pq, m) k v.\n                               ASSERT (k \\<notin> dom m) \\<bind>\n                               (\\<lambda>_.\n                                   ASSERT (hmr_invar (pq, m)) \\<bind>\n                                   (\\<lambda>_.\n mop_list_append pq k \\<bind>\n (\\<lambda>pq. let m = m(k \\<mapsto> v) in RETURN (pq, m)))))\n                           y)\n                         \\<in> \\<langle>local.hm_impl1_rel\\<rangle>nres_rel", "apply (auto simp: pw_le_iff refine_pw_simps nres_rel_def\n          hm_impl1_rel_def in_br_conv split: prod.splits)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>a ba x1 x2b.\n       \\<lbrakk>ba < maxsize; hmr_invar (hm_impl1_\\<alpha> (a, []));\n        x2b ba = None; (x1, x2b) = hm_impl1_\\<alpha> (a, []);\n        local.hm_impl1_invar (a, []); ba \\<in> set a\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a b ba x1 x2b.\n       \\<lbrakk>ba < maxsize; hmr_invar (hm_impl1_\\<alpha> (a, b));\n        x2b ba = None; (x1, x2b) = hm_impl1_\\<alpha> (a, b);\n        local.hm_impl1_invar (a, b); b \\<noteq> []; ba \\<in> set a\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a b ba x1 x2b.\n       \\<lbrakk>ba < maxsize; hmr_invar (hm_impl1_\\<alpha> (a, b));\n        x2b ba = None; (x1, x2b) = hm_impl1_\\<alpha> (a, b);\n        local.hm_impl1_invar (a, b); b \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> ba < length b\n 4. \\<And>a b ba x1 x2b ad bi.\n       \\<lbrakk>ba < maxsize; hmr_invar (hm_impl1_\\<alpha> (a, b));\n        x2b ba = None; (x1, x2b) = hm_impl1_\\<alpha> (a, b);\n        local.hm_impl1_invar (a, b); \\<not> local.hm_impl1_invar (ad, bi);\n        ba \\<in> set a\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a b ba bb x1 x2b ad bi.\n       \\<lbrakk>ba < maxsize; hmr_invar (hm_impl1_\\<alpha> (a, b));\n        x2b ba = None; (x1, x2b) = hm_impl1_\\<alpha> (a, b);\n        local.hm_impl1_invar (a, b);\n        inres\n         (if b = []\n          then mop_list_replicate maxsize bb \\<bind>\n               (\\<lambda>ml.\n                   ASSERT (ba < length ml) \\<bind>\n                   (\\<lambda>x. RETURN (a @ [ba], ml[ba := bb])))\n          else RETURN b \\<bind>\n               (\\<lambda>ml.\n                   ASSERT (ba < length ml) \\<bind>\n                   (\\<lambda>x. RETURN (a @ [ba], ml[ba := bb]))))\n         (ad, bi)\\<rbrakk>\n       \\<Longrightarrow> local.hm_impl1_invar (ad, bi)\n 6. \\<And>a b ba bb x1 x2b ad bi.\n       \\<lbrakk>ba < maxsize; hmr_invar (hm_impl1_\\<alpha> (a, b));\n        x2b ba = None; (x1, x2b) = hm_impl1_\\<alpha> (a, b);\n        local.hm_impl1_invar (a, b);\n        (x1 @ [ba], x2b(ba \\<mapsto> bb)) \\<noteq>\n        hm_impl1_\\<alpha> (ad, bi);\n        ba \\<in> set a\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a b ba bb x1 x2b ad bi.\n       \\<lbrakk>ba < maxsize; hmr_invar (hm_impl1_\\<alpha> (a, b));\n        x2b ba = None; (x1, x2b) = hm_impl1_\\<alpha> (a, b);\n        local.hm_impl1_invar (a, b);\n        inres\n         (if b = []\n          then mop_list_replicate maxsize bb \\<bind>\n               (\\<lambda>ml.\n                   ASSERT (ba < length ml) \\<bind>\n                   (\\<lambda>x. RETURN (a @ [ba], ml[ba := bb])))\n          else RETURN b \\<bind>\n               (\\<lambda>ml.\n                   ASSERT (ba < length ml) \\<bind>\n                   (\\<lambda>x. RETURN (a @ [ba], ml[ba := bb]))))\n         (ad, bi)\\<rbrakk>\n       \\<Longrightarrow> (x1 @ [ba], x2b(ba \\<mapsto> bb)) =\n                         hm_impl1_\\<alpha> (ad, bi)", "unfolding hm_impl1_rel_defs"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>a ba x1 x2b.\n       \\<lbrakk>ba < maxsize;\n        hmr_invar\n         (case (a, []) of\n          (pq, ml) \\<Rightarrow>\n            (pq,\n             \\<lambda>k. if k \\<in> set pq then Some (ml ! k) else None));\n        x2b ba = None;\n        (x1, x2b) =\n        (case (a, []) of\n         (pq, ml) \\<Rightarrow>\n           (pq,\n            \\<lambda>k. if k \\<in> set pq then Some (ml ! k) else None));\n        case (a, []) of\n        (pq, ml) \\<Rightarrow>\n          hmr_invar\n           (case (pq, ml) of\n            (pq, ml) \\<Rightarrow>\n              (pq,\n               \\<lambda>k.\n                  if k \\<in> set pq then Some (ml ! k) else None)) \\<and>\n          set pq \\<subseteq> {0..<maxsize} \\<and>\n          (pq = [] \\<and> ml = [] \\<or> length ml = maxsize);\n        ba \\<in> set a\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a b ba x1 x2b.\n       \\<lbrakk>ba < maxsize;\n        hmr_invar\n         (case (a, b) of\n          (pq, ml) \\<Rightarrow>\n            (pq,\n             \\<lambda>k. if k \\<in> set pq then Some (ml ! k) else None));\n        x2b ba = None;\n        (x1, x2b) =\n        (case (a, b) of\n         (pq, ml) \\<Rightarrow>\n           (pq,\n            \\<lambda>k. if k \\<in> set pq then Some (ml ! k) else None));\n        case (a, b) of\n        (pq, ml) \\<Rightarrow>\n          hmr_invar\n           (case (pq, ml) of\n            (pq, ml) \\<Rightarrow>\n              (pq,\n               \\<lambda>k.\n                  if k \\<in> set pq then Some (ml ! k) else None)) \\<and>\n          set pq \\<subseteq> {0..<maxsize} \\<and>\n          (pq = [] \\<and> ml = [] \\<or> length ml = maxsize);\n        b \\<noteq> []; ba \\<in> set a\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a b ba x1 x2b.\n       \\<lbrakk>ba < maxsize;\n        hmr_invar\n         (case (a, b) of\n          (pq, ml) \\<Rightarrow>\n            (pq,\n             \\<lambda>k. if k \\<in> set pq then Some (ml ! k) else None));\n        x2b ba = None;\n        (x1, x2b) =\n        (case (a, b) of\n         (pq, ml) \\<Rightarrow>\n           (pq,\n            \\<lambda>k. if k \\<in> set pq then Some (ml ! k) else None));\n        case (a, b) of\n        (pq, ml) \\<Rightarrow>\n          hmr_invar\n           (case (pq, ml) of\n            (pq, ml) \\<Rightarrow>\n              (pq,\n               \\<lambda>k.\n                  if k \\<in> set pq then Some (ml ! k) else None)) \\<and>\n          set pq \\<subseteq> {0..<maxsize} \\<and>\n          (pq = [] \\<and> ml = [] \\<or> length ml = maxsize);\n        b \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> ba < length b\n 4. \\<And>a b ba x1 x2b ad bi.\n       \\<lbrakk>ba < maxsize;\n        hmr_invar\n         (case (a, b) of\n          (pq, ml) \\<Rightarrow>\n            (pq,\n             \\<lambda>k. if k \\<in> set pq then Some (ml ! k) else None));\n        x2b ba = None;\n        (x1, x2b) =\n        (case (a, b) of\n         (pq, ml) \\<Rightarrow>\n           (pq,\n            \\<lambda>k. if k \\<in> set pq then Some (ml ! k) else None));\n        case (a, b) of\n        (pq, ml) \\<Rightarrow>\n          hmr_invar\n           (case (pq, ml) of\n            (pq, ml) \\<Rightarrow>\n              (pq,\n               \\<lambda>k.\n                  if k \\<in> set pq then Some (ml ! k) else None)) \\<and>\n          set pq \\<subseteq> {0..<maxsize} \\<and>\n          (pq = [] \\<and> ml = [] \\<or> length ml = maxsize);\n        \\<not> (case (ad, bi) of\n                (pq, ml) \\<Rightarrow>\n                  hmr_invar\n                   (case (pq, ml) of\n                    (pq, ml) \\<Rightarrow>\n                      (pq,\n                       \\<lambda>k.\n                          if k \\<in> set pq then Some (ml ! k)\n                          else None)) \\<and>\n                  set pq \\<subseteq> {0..<maxsize} \\<and>\n                  (pq = [] \\<and> ml = [] \\<or> length ml = maxsize));\n        ba \\<in> set a\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a b ba bb x1 x2b ad bi.\n       \\<lbrakk>ba < maxsize;\n        hmr_invar\n         (case (a, b) of\n          (pq, ml) \\<Rightarrow>\n            (pq,\n             \\<lambda>k. if k \\<in> set pq then Some (ml ! k) else None));\n        x2b ba = None;\n        (x1, x2b) =\n        (case (a, b) of\n         (pq, ml) \\<Rightarrow>\n           (pq,\n            \\<lambda>k. if k \\<in> set pq then Some (ml ! k) else None));\n        case (a, b) of\n        (pq, ml) \\<Rightarrow>\n          hmr_invar\n           (case (pq, ml) of\n            (pq, ml) \\<Rightarrow>\n              (pq,\n               \\<lambda>k.\n                  if k \\<in> set pq then Some (ml ! k) else None)) \\<and>\n          set pq \\<subseteq> {0..<maxsize} \\<and>\n          (pq = [] \\<and> ml = [] \\<or> length ml = maxsize);\n        inres\n         (if b = []\n          then mop_list_replicate maxsize bb \\<bind>\n               (\\<lambda>ml.\n                   ASSERT (ba < length ml) \\<bind>\n                   (\\<lambda>x. RETURN (a @ [ba], ml[ba := bb])))\n          else RETURN b \\<bind>\n               (\\<lambda>ml.\n                   ASSERT (ba < length ml) \\<bind>\n                   (\\<lambda>x. RETURN (a @ [ba], ml[ba := bb]))))\n         (ad, bi)\\<rbrakk>\n       \\<Longrightarrow> case (ad, bi) of\n                         (pq, ml) \\<Rightarrow>\n                           hmr_invar\n                            (case (pq, ml) of\n                             (pq, ml) \\<Rightarrow>\n                               (pq,\n                                \\<lambda>k.\n                                   if k \\<in> set pq then Some (ml ! k)\n                                   else None)) \\<and>\n                           set pq \\<subseteq> {0..<maxsize} \\<and>\n                           (pq = [] \\<and> ml = [] \\<or>\n                            length ml = maxsize)\n 6. \\<And>a b ba bb x1 x2b ad bi.\n       \\<lbrakk>ba < maxsize;\n        hmr_invar\n         (case (a, b) of\n          (pq, ml) \\<Rightarrow>\n            (pq,\n             \\<lambda>k. if k \\<in> set pq then Some (ml ! k) else None));\n        x2b ba = None;\n        (x1, x2b) =\n        (case (a, b) of\n         (pq, ml) \\<Rightarrow>\n           (pq,\n            \\<lambda>k. if k \\<in> set pq then Some (ml ! k) else None));\n        case (a, b) of\n        (pq, ml) \\<Rightarrow>\n          hmr_invar\n           (case (pq, ml) of\n            (pq, ml) \\<Rightarrow>\n              (pq,\n               \\<lambda>k.\n                  if k \\<in> set pq then Some (ml ! k) else None)) \\<and>\n          set pq \\<subseteq> {0..<maxsize} \\<and>\n          (pq = [] \\<and> ml = [] \\<or> length ml = maxsize);\n        (x1 @ [ba], x2b(ba \\<mapsto> bb)) \\<noteq>\n        (case (ad, bi) of\n         (pq, ml) \\<Rightarrow>\n           (pq,\n            \\<lambda>k. if k \\<in> set pq then Some (ml ! k) else None));\n        ba \\<in> set a\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a b ba bb x1 x2b ad bi.\n       \\<lbrakk>ba < maxsize;\n        hmr_invar\n         (case (a, b) of\n          (pq, ml) \\<Rightarrow>\n            (pq,\n             \\<lambda>k. if k \\<in> set pq then Some (ml ! k) else None));\n        x2b ba = None;\n        (x1, x2b) =\n        (case (a, b) of\n         (pq, ml) \\<Rightarrow>\n           (pq,\n            \\<lambda>k. if k \\<in> set pq then Some (ml ! k) else None));\n        case (a, b) of\n        (pq, ml) \\<Rightarrow>\n          hmr_invar\n           (case (pq, ml) of\n            (pq, ml) \\<Rightarrow>\n              (pq,\n               \\<lambda>k.\n                  if k \\<in> set pq then Some (ml ! k) else None)) \\<and>\n          set pq \\<subseteq> {0..<maxsize} \\<and>\n          (pq = [] \\<and> ml = [] \\<or> length ml = maxsize);\n        inres\n         (if b = []\n          then mop_list_replicate maxsize bb \\<bind>\n               (\\<lambda>ml.\n                   ASSERT (ba < length ml) \\<bind>\n                   (\\<lambda>x. RETURN (a @ [ba], ml[ba := bb])))\n          else RETURN b \\<bind>\n               (\\<lambda>ml.\n                   ASSERT (ba < length ml) \\<bind>\n                   (\\<lambda>x. RETURN (a @ [ba], ml[ba := bb]))))\n         (ad, bi)\\<rbrakk>\n       \\<Longrightarrow> (x1 @ [ba], x2b(ba \\<mapsto> bb)) =\n                         (case (ad, bi) of\n                          (pq, ml) \\<Rightarrow>\n                            (pq,\n                             \\<lambda>k.\n                                if k \\<in> set pq then Some (ml ! k)\n                                else None))", "apply (auto simp: restrict_map_def hmr_invar_def split: prod.splits if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"hm_impl2_rel \\<equiv> prod_assn (ial_assn maxsize id_assn) (array_assn id_assn)\""], ["", "definition \"hm_impl_rel \\<equiv> hr_comp hm_impl2_rel hm_impl1_rel\""], ["", "lemmas [fcomp_norm_unfold] = hm_impl_rel_def[symmetric]"], ["", "(*lemma hm_impl_rel_precise[constraint_rules]: \"precise hm_impl_rel\"\n      unfolding hm_impl_rel_def hm_impl1_rel_def hm_impl2_rel_def\n      by (constraint_rules)*)"], ["", "subsection \\<open>Implement Basic Operations\\<close>"], ["", "lemma param_parent: \"(efficient_nat_div2,h.parent) \\<in> Id \\<rightarrow> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (efficient_nat_div2, h.parent) \\<in> nat_rel \\<rightarrow> nat_rel", "by (intro fun_relI) (simp add: h.parent_def)"], ["", "lemmas [sepref_import_param] = param_parent"], ["", "sepref_register h.parent"], ["", "lemma param_left: \"(h.left,h.left) \\<in> Id \\<rightarrow> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h.left, h.left) \\<in> nat_rel \\<rightarrow> nat_rel", "by simp"], ["", "lemmas [sepref_import_param] = param_left"], ["", "sepref_register h.left"], ["", "lemma param_right: \"(h.right,h.right) \\<in> Id \\<rightarrow> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h.right, h.right) \\<in> nat_rel \\<rightarrow> nat_rel", "by simp"], ["", "lemmas [sepref_import_param] = param_right"], ["", "sepref_register h.right"], ["", "abbreviation (input) \"prio_rel \\<equiv> (Id::('p\\<times>'p) set)\""], ["", "lemma param_prio_le: \"((\\<le>), (\\<le>)) \\<in> prio_rel \\<rightarrow> prio_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<le>), (\\<le>)) \\<in> Id \\<rightarrow> Id \\<rightarrow> bool_rel", "by simp"], ["", "lemmas [sepref_import_param] = param_prio_le"], ["", "lemma param_prio_lt: \"((<), (<)) \\<in> prio_rel \\<rightarrow> prio_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((<), (<)) \\<in> Id \\<rightarrow> Id \\<rightarrow> bool_rel", "by simp"], ["", "lemmas [sepref_import_param] = param_prio_lt"], ["", "abbreviation \"I_HM_UNF \\<equiv> TYPE(nat list \\<times> 'v list)\""], ["", "sepref_definition hm_length_impl is \"RETURN o hm_length'\" :: \"hm_impl2_rel\\<^sup>k\\<rightarrow>\\<^sub>anat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, RETURN \\<circ> local.hm_length')\n    \\<in> local.hm_impl2_rel\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "unfolding hm_length'_def hm_impl2_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, (RETURN \\<circ>\\<circ> case_prod) (\\<lambda>pq ml. length pq))\n    \\<in> (ial_assn maxsize nat_assn \\<times>\\<^sub>a\n           array_assn id_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "by sepref"], ["", "lemmas [sepref_fr_rules] = hm_length_impl.refine[FCOMP hm_length'_refine]"], ["", "sepref_register \"hm_length::(nat,'v) ahm \\<Rightarrow> _\""], ["", "sepref_definition hm_key_of_op_impl is \"uncurry hm_key_of_op'\" :: \"hm_impl2_rel\\<^sup>k*\\<^sub>anat_assn\\<^sup>k \\<rightarrow>\\<^sub>anat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry hm_key_of_op')\n    \\<in> local.hm_impl2_rel\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "unfolding hm_key_of_op'_def hm_impl2_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>(pq, ml) i.\n          ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_get pq (i - 1))))\n    \\<in> (ial_assn maxsize nat_assn \\<times>\\<^sub>a\n           array_assn id_assn)\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "by sepref"], ["", "lemmas [sepref_fr_rules] = hm_key_of_op_impl.refine[FCOMP hm_key_of_op'_refine]"], ["", "sepref_register \"hm_key_of_op::(nat,'v) ahm \\<Rightarrow> _\""], ["", "context \n      notes [id_rules] = itypeI[Pure.of maxsize \"TYPE(nat)\"]\n      notes [sepref_import_param] = IdI[of maxsize]\n    begin"], ["", "sepref_definition hm_lookup_impl is \"uncurry hm_lookup_op'\" :: \"(hm_impl2_rel\\<^sup>k*\\<^sub>anat_assn\\<^sup>k \\<rightarrow>\\<^sub>aoption_assn id_assn)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry local.hm_lookup_op')\n    \\<in> local.hm_impl2_rel\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a option_assn id_assn", "unfolding hm_lookup_op'_def hm_impl2_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>(pq, ml) k.\n          if k < maxsize\n          then let c = op_list_contains k pq\n               in if c\n                  then mop_list_get ml k \\<bind>\n                       (\\<lambda>v. RETURN (Some v))\n                  else RETURN None\n          else RETURN None))\n    \\<in> (ial_assn maxsize nat_assn \\<times>\\<^sub>a\n           array_assn id_assn)\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a option_assn id_assn", "by sepref"], ["", "lemmas [sepref_fr_rules] = \n      hm_lookup_impl.refine[FCOMP hm_lookup_op'_refine]"], ["", "sepref_register \"hm_lookup::(nat,'v) ahm \\<Rightarrow> _\""], ["", "sepref_definition hm_exch_op_impl is \"uncurry2 hm_exch_op'\" :: \"hm_impl2_rel\\<^sup>d*\\<^sub>anat_assn\\<^sup>k*\\<^sub>anat_assn\\<^sup>k \\<rightarrow>\\<^sub>a hm_impl2_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3, uncurry2 local.hm_exch_op')\n    \\<in> local.hm_impl2_rel\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a local.hm_impl2_rel", "unfolding hm_exch_op'_def hm_impl2_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>(pq, ml) i j.\n          ASSERT (hm_valid (hm_impl1_\\<alpha> (pq, ml)) i) \\<bind>\n          (\\<lambda>_.\n              ASSERT (hm_valid (hm_impl1_\\<alpha> (pq, ml)) j) \\<bind>\n              (\\<lambda>_.\n                  mop_list_swap pq (i - 1) (j - 1) \\<bind>\n                  (\\<lambda>pq. RETURN (pq, ml))))))\n    \\<in> (ial_assn maxsize nat_assn \\<times>\\<^sub>a\n           array_assn id_assn)\\<^sup>d *\\<^sub>a\n          nat_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a ial_assn maxsize\n            nat_assn \\<times>\\<^sub>a\n           array_assn id_assn", "by sepref"], ["", "lemmas [sepref_fr_rules] = hm_exch_op_impl.refine[FCOMP hm_exch_op'_refine]"], ["", "sepref_register \"hm_exch_op::(nat,'v) ahm \\<Rightarrow> _\""], ["", "sepref_definition hm_index_op_impl is \"uncurry hm_index_op'\" :: \"hm_impl2_rel\\<^sup>k*\\<^sub>aid_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry local.hm_index_op')\n    \\<in> local.hm_impl2_rel\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "unfolding hm_index_op'_def hm_impl2_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>(pq, ml) k.\n          ASSERT\n           (local.hm_impl1_invar (pq, ml) \\<and>\n            heapmap_\\<alpha> (hm_impl1_\\<alpha> (pq, ml)) k \\<noteq>\n            None \\<and>\n            k \\<in> set pq) \\<bind>\n          (\\<lambda>_.\n              mop_list_index pq k \\<bind> (\\<lambda>i. RETURN (i + 1)))))\n    \\<in> (ial_assn maxsize nat_assn \\<times>\\<^sub>a\n           array_assn id_assn)\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "by sepref"], ["", "lemmas [sepref_fr_rules] = hm_index_op_impl.refine[FCOMP hm_index_op'_refine]"], ["", "sepref_register \"hm_index_op::(nat,'v) ahm \\<Rightarrow> _\""], ["", "sepref_definition hm_update_op_impl is \"uncurry2 hm_update_op'\" :: \"hm_impl2_rel\\<^sup>d*\\<^sub>aid_assn\\<^sup>k*\\<^sub>aid_assn\\<^sup>k \\<rightarrow>\\<^sub>a hm_impl2_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3, uncurry2 local.hm_update_op')\n    \\<in> local.hm_impl2_rel\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          id_assn\\<^sup>k \\<rightarrow>\\<^sub>a local.hm_impl2_rel", "unfolding hm_update_op'_def hm_impl2_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>(pq, ml) i v.\n          ASSERT\n           (hm_valid (hm_impl1_\\<alpha> (pq, ml)) i \\<and>\n            local.hm_impl1_invar (pq, ml)) \\<bind>\n          (\\<lambda>_.\n              mop_list_get pq (i - 1) \\<bind>\n              (\\<lambda>k.\n                  mop_list_set ml k v \\<bind>\n                  (\\<lambda>ml. RETURN (pq, ml))))))\n    \\<in> (ial_assn maxsize nat_assn \\<times>\\<^sub>a\n           array_assn id_assn)\\<^sup>d *\\<^sub>a\n          nat_assn\\<^sup>k *\\<^sub>a\n          id_assn\\<^sup>k \\<rightarrow>\\<^sub>a ial_assn maxsize\n           nat_assn \\<times>\\<^sub>a\n          array_assn id_assn", "by sepref"], ["", "lemmas [sepref_fr_rules] = hm_update_op_impl.refine[FCOMP hm_update_op'_refine]"], ["", "sepref_register \"hm_update_op::(nat,'v) ahm \\<Rightarrow> _\""], ["", "sepref_definition hm_butlast_op_impl is \"hm_butlast_op'\" :: \"hm_impl2_rel\\<^sup>d \\<rightarrow>\\<^sub>a hm_impl2_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, hm_butlast_op')\n    \\<in> local.hm_impl2_rel\\<^sup>d \\<rightarrow>\\<^sub>a local.hm_impl2_rel", "unfolding hm_butlast_op'_def hm_impl2_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>(pq, ml).\n        ASSERT (hmr_invar (hm_impl1_\\<alpha> (pq, ml))) \\<bind>\n        (\\<lambda>_.\n            mop_list_butlast pq \\<bind> (\\<lambda>pq. RETURN (pq, ml))))\n    \\<in> (ial_assn maxsize nat_assn \\<times>\\<^sub>a\n           array_assn\n            id_assn)\\<^sup>d \\<rightarrow>\\<^sub>a ial_assn maxsize\n              nat_assn \\<times>\\<^sub>a\n             array_assn id_assn", "by sepref"], ["", "lemmas [sepref_fr_rules] = hm_butlast_op_impl.refine[FCOMP hm_butlast_op'_refine]"], ["", "sepref_register \"hm_butlast_op::(nat,'v) ahm \\<Rightarrow> _\""], ["", "sepref_definition hm_append_op_impl is \"uncurry2 hm_append_op'\" :: \"hm_impl2_rel\\<^sup>d *\\<^sub>a id_assn\\<^sup>k *\\<^sub>a id_assn\\<^sup>k \\<rightarrow>\\<^sub>a hm_impl2_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3, uncurry2 local.hm_append_op')\n    \\<in> local.hm_impl2_rel\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          id_assn\\<^sup>k \\<rightarrow>\\<^sub>a local.hm_impl2_rel", "unfolding hm_append_op'_def hm_impl2_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>(pq, ml) k v.\n          ASSERT (k \\<notin> set pq \\<and> k < maxsize) \\<bind>\n          (\\<lambda>_.\n              ASSERT (local.hm_impl1_invar (pq, ml)) \\<bind>\n              (\\<lambda>_.\n                  mop_list_append pq k \\<bind>\n                  (\\<lambda>pq.\n                      (if length ml = 0 then mop_list_replicate maxsize v\n                       else RETURN ml) \\<bind>\n                      (\\<lambda>ml.\n                          mop_list_set ml k v \\<bind>\n                          (\\<lambda>ml. RETURN (pq, ml))))))))\n    \\<in> (ial_assn maxsize nat_assn \\<times>\\<^sub>a\n           array_assn id_assn)\\<^sup>d *\\<^sub>a\n          nat_assn\\<^sup>k *\\<^sub>a\n          id_assn\\<^sup>k \\<rightarrow>\\<^sub>a ial_assn maxsize\n           nat_assn \\<times>\\<^sub>a\n          array_assn id_assn", "apply (rewrite array_fold_custom_replicate)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>(pq, ml) k v.\n          ASSERT (k \\<notin> set pq \\<and> k < maxsize) \\<bind>\n          (\\<lambda>_.\n              ASSERT (local.hm_impl1_invar (pq, ml)) \\<bind>\n              (\\<lambda>_.\n                  mop_list_append pq k \\<bind>\n                  (\\<lambda>pq.\n                      (if length ml = 0\n                       then (RETURN \\<circ>\\<circ> op_array_replicate)\n                             maxsize v\n                       else RETURN ml) \\<bind>\n                      (\\<lambda>ml.\n                          mop_list_set ml k v \\<bind>\n                          (\\<lambda>ml. RETURN (pq, ml))))))))\n    \\<in> (ial_assn maxsize nat_assn \\<times>\\<^sub>a\n           array_assn id_assn)\\<^sup>d *\\<^sub>a\n          nat_assn\\<^sup>k *\\<^sub>a\n          id_assn\\<^sup>k \\<rightarrow>\\<^sub>a ial_assn maxsize\n           nat_assn \\<times>\\<^sub>a\n          array_assn id_assn", "by sepref"], ["", "lemmas [sepref_fr_rules] = hm_append_op_impl.refine[FCOMP hm_append_op'_refine]"], ["", "sepref_register \"hm_append_op::(nat,'v) ahm \\<Rightarrow> _\""], ["", "subsection \\<open>Auxiliary Operations\\<close>"], ["", "lemmas [intf_of_assn] = intf_of_assnI[where R=\"hm_impl_rel :: (nat,'v) ahm \\<Rightarrow> _\" and 'a=\"'v i_hma\"]"], ["", "sepref_definition hm_valid_impl is \"uncurry (RETURN oo hm_valid)\" :: \"hm_impl_rel\\<^sup>k*\\<^sub>anat_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry (RETURN \\<circ>\\<circ> hm_valid))\n    \\<in> local.hm_impl_rel\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "unfolding hm_valid_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>x.\n          RETURN \\<circ> (\\<lambda>i. 0 < i \\<and> i \\<le> hm_length x)))\n    \\<in> local.hm_impl_rel\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "by sepref"], ["", "lemmas [sepref_fr_rules] = hm_valid_impl.refine"], ["", "sepref_register \"hm_valid::(nat,'v) ahm \\<Rightarrow> _\""], ["", "(* Optimization *)"], ["", "definition \"hm_the_lookup_op' hm k \\<equiv> do {\n      let (pq,ml) = hm;\n      ASSERT (heapmap_\\<alpha> (hm_impl1_\\<alpha> hm) k \\<noteq> None \\<and> hm_impl1_invar hm);\n      v \\<leftarrow> mop_list_get ml k;\n      RETURN v\n    }\""], ["", "lemma hm_the_lookup_op'_refine: \n      \"(hm_the_lookup_op', hm_the_lookup_op) \\<in> hm_impl1_rel \\<rightarrow> nat_rel \\<rightarrow> \\<langle>Id\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.hm_the_lookup_op', hm_the_lookup_op)\n    \\<in> local.hm_impl1_rel \\<rightarrow>\n          nat_rel \\<rightarrow> \\<langle>Id\\<rangle>nres_rel", "apply (intro fun_relI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> local.hm_impl1_rel;\n        (aa, a'a) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> local.hm_the_lookup_op' a aa\n                         \\<le> \\<Down> Id (hm_the_lookup_op a' a'a)", "unfolding hm_the_lookup_op'_def hm_the_lookup_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> local.hm_impl1_rel;\n        (aa, a'a) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> (let (pq, ml) = a\n                          in ASSERT\n                              (heapmap_\\<alpha> (hm_impl1_\\<alpha> a)\n                                aa \\<noteq>\n                               None \\<and>\n                               local.hm_impl1_invar a) \\<bind>\n                             (\\<lambda>_.\n                                 mop_list_get ml aa \\<bind> RETURN))\n                         \\<le> \\<Down> Id\n                                (ASSERT\n                                  (heapmap_\\<alpha> a' a'a \\<noteq>\n                                   None \\<and>\n                                   hmr_invar a') \\<bind>\n                                 (\\<lambda>_.\n                                     RETURN\n(the (heapmap_\\<alpha> a' a'a))))", "apply refine_vcg"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a a' aa a'a ab b.\n       \\<lbrakk>(a, a') \\<in> local.hm_impl1_rel; (aa, a'a) \\<in> nat_rel;\n        heapmap_\\<alpha> a' a'a \\<noteq> None \\<and> hmr_invar a';\n        a = (ab, b)\\<rbrakk>\n       \\<Longrightarrow> heapmap_\\<alpha> (hm_impl1_\\<alpha> a) aa \\<noteq>\n                         None\n 2. \\<And>a a' aa a'a ab b.\n       \\<lbrakk>(a, a') \\<in> local.hm_impl1_rel; (aa, a'a) \\<in> nat_rel;\n        heapmap_\\<alpha> a' a'a \\<noteq> None \\<and> hmr_invar a';\n        a = (ab, b)\\<rbrakk>\n       \\<Longrightarrow> local.hm_impl1_invar a\n 3. \\<And>a a' aa a'a ab b.\n       \\<lbrakk>(a, a') \\<in> local.hm_impl1_rel; (aa, a'a) \\<in> nat_rel;\n        heapmap_\\<alpha> a' a'a \\<noteq> None \\<and> hmr_invar a';\n        a = (ab, b);\n        heapmap_\\<alpha> (hm_impl1_\\<alpha> a) aa \\<noteq> None \\<and>\n        local.hm_impl1_invar a\\<rbrakk>\n       \\<Longrightarrow> aa < length b\n 4. \\<And>a a' aa a'a ab b.\n       \\<lbrakk>(a, a') \\<in> local.hm_impl1_rel; (aa, a'a) \\<in> nat_rel;\n        heapmap_\\<alpha> a' a'a \\<noteq> None \\<and> hmr_invar a';\n        a = (ab, b);\n        heapmap_\\<alpha> (hm_impl1_\\<alpha> a) aa \\<noteq> None \\<and>\n        local.hm_impl1_invar a\\<rbrakk>\n       \\<Longrightarrow> (b ! aa, the (heapmap_\\<alpha> a' a'a)) \\<in> Id", "apply (auto simp: hm_impl1_rel_defs heapmap_\\<alpha>_def hmr_invar_def split: if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "sepref_definition hm_the_lookup_op_impl is \"uncurry hm_the_lookup_op'\" :: \"hm_impl2_rel\\<^sup>k*\\<^sub>aid_assn\\<^sup>k \\<rightarrow>\\<^sub>aid_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry local.hm_the_lookup_op')\n    \\<in> local.hm_impl2_rel\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn", "unfolding hm_the_lookup_op'_def[abs_def] hm_impl2_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>hm k.\n          let (pq, ml) = hm\n          in ASSERT\n              (heapmap_\\<alpha> (hm_impl1_\\<alpha> hm) k \\<noteq>\n               None \\<and>\n               local.hm_impl1_invar hm) \\<bind>\n             (\\<lambda>_. mop_list_get ml k \\<bind> RETURN)))\n    \\<in> (ial_assn maxsize nat_assn \\<times>\\<^sub>a\n           array_assn id_assn)\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn", "by sepref"], ["", "lemmas hm_the_lookup_op_impl[sepref_fr_rules] = hm_the_lookup_op_impl.refine[FCOMP hm_the_lookup_op'_refine]"], ["", "sepref_register \"hm_the_lookup_op::(nat,'v) ahm \\<Rightarrow> _\""], ["", "sepref_definition hm_val_of_op_impl is \"uncurry hm_val_of_op\" :: \"hm_impl_rel\\<^sup>k*\\<^sub>aid_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry hm_val_of_op)\n    \\<in> local.hm_impl_rel\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn", "unfolding hm_val_of_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>hm i.\n          hm_key_of_op hm i \\<bind>\n          (\\<lambda>k. hm_the_lookup_op hm k \\<bind> RETURN)))\n    \\<in> local.hm_impl_rel\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn", "by sepref"], ["", "lemmas [sepref_fr_rules] = hm_val_of_op_impl.refine"], ["", "sepref_register \"hm_val_of_op::(nat,'v) ahm \\<Rightarrow> _\""], ["", "sepref_definition hm_prio_of_op_impl is \"uncurry (PR_CONST hm_prio_of_op)\" :: \"hm_impl_rel\\<^sup>k*\\<^sub>aid_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry (PR_CONST hm_prio_of_op))\n    \\<in> local.hm_impl_rel\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn", "unfolding hm_prio_of_op_def[abs_def] PR_CONST_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>h i.\n          hm_val_of_op h i \\<bind> (\\<lambda>v. RETURN (prio v))))\n    \\<in> local.hm_impl_rel\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn", "by sepref"], ["", "lemmas [sepref_fr_rules] = hm_prio_of_op_impl.refine"], ["", "sepref_register \"PR_CONST hm_prio_of_op::(nat,'v) ahm \\<Rightarrow> _\""], ["", "lemma [def_pat_rules]: \"hmstruct.hm_prio_of_op$prio \\<equiv> PR_CONST hm_prio_of_op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hmstruct.hm_prio_of_op $ prio \\<equiv> PR_CONST hm_prio_of_op", "by simp"], ["", "text \\<open>No code theorem preparation, as we define optimized version later\\<close>"], ["", "sepref_definition (no_prep_code) hm_swim_op_impl is \"uncurry (PR_CONST hm_swim_op)\" :: \"hm_impl_rel\\<^sup>d*\\<^sub>anat_assn\\<^sup>k \\<rightarrow>\\<^sub>a hm_impl_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry (PR_CONST hm_swim_op))\n    \\<in> local.hm_impl_rel\\<^sup>d *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a local.hm_impl_rel", "unfolding hm_swim_op_def[abs_def] PR_CONST_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>h i.\n          REC\\<^sub>T\n           (\\<lambda>swim (h, i).\n               ASSERT\n                (hm_valid h i \\<and>\n                 h.swim_invar (hmr_\\<alpha> h) i) \\<bind>\n               (\\<lambda>_.\n                   if hm_valid h (h.parent i)\n                   then hm_prio_of_op h (h.parent i) \\<bind>\n                        (\\<lambda>ppi.\n                            hm_prio_of_op h i \\<bind>\n                            (\\<lambda>pi.\n                                if \\<not> ppi \\<le> pi\n                                then hm_exch_op h i (h.parent i) \\<bind>\n                                     (\\<lambda>h. swim (h, h.parent i))\n                                else RETURN h))\n                   else RETURN h))\n           (h, i)))\n    \\<in> local.hm_impl_rel\\<^sup>d *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a local.hm_impl_rel", "using [[goals_limit = 1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>h i.\n          REC\\<^sub>T\n           (\\<lambda>swim (h, i).\n               ASSERT\n                (hm_valid h i \\<and>\n                 h.swim_invar (hmr_\\<alpha> h) i) \\<bind>\n               (\\<lambda>_.\n                   if hm_valid h (h.parent i)\n                   then hm_prio_of_op h (h.parent i) \\<bind>\n                        (\\<lambda>ppi.\n                            hm_prio_of_op h i \\<bind>\n                            (\\<lambda>pi.\n                                if \\<not> ppi \\<le> pi\n                                then hm_exch_op h i (h.parent i) \\<bind>\n                                     (\\<lambda>h. swim (h, h.parent i))\n                                else RETURN h))\n                   else RETURN h))\n           (h, i)))\n    \\<in> local.hm_impl_rel\\<^sup>d *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a local.hm_impl_rel", "by sepref"], ["", "lemmas [sepref_fr_rules] = hm_swim_op_impl.refine"], ["", "sepref_register \"PR_CONST hm_swim_op::(nat,'v) ahm \\<Rightarrow> _\""], ["", "lemma [def_pat_rules]: \"hmstruct.hm_swim_op$prio \\<equiv> PR_CONST hm_swim_op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hmstruct.hm_swim_op $ prio \\<equiv> PR_CONST hm_swim_op", "by simp"], ["", "text \\<open>No code theorem preparation, as we define optimized version later\\<close>"], ["", "sepref_definition (no_prep_code) hm_sink_op_impl is \"uncurry (PR_CONST hm_sink_op)\" :: \"hm_impl_rel\\<^sup>d*\\<^sub>anat_assn\\<^sup>k \\<rightarrow>\\<^sub>a hm_impl_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry (PR_CONST hm_sink_op))\n    \\<in> local.hm_impl_rel\\<^sup>d *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a local.hm_impl_rel", "unfolding hm_sink_op_def[abs_def] PR_CONST_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>h k.\n          REC\\<^sub>T\n           (\\<lambda>D (h, k).\n               ASSERT (0 < k \\<and> k \\<le> hm_length h) \\<bind>\n               (\\<lambda>_.\n                   let len = hm_length h\n                   in if 2 * k \\<le> len\n                      then let j = 2 * k\n                           in hm_prio_of_op h j \\<bind>\n                              (\\<lambda>pj.\n                                  (if j < len\n                                   then hm_prio_of_op h (Suc j) \\<bind>\n  (\\<lambda>psj. if psj < pj then RETURN (j + 1) else RETURN j)\n                                   else RETURN j) \\<bind>\n                                  (\\<lambda>j.\nhm_prio_of_op h j \\<bind>\n(\\<lambda>pj.\n    hm_prio_of_op h k \\<bind>\n    (\\<lambda>pk.\n        if pj < pk then hm_exch_op h k j \\<bind> (\\<lambda>h. D (h, j))\n        else RETURN h))))\n                      else RETURN h))\n           (h, k)))\n    \\<in> local.hm_impl_rel\\<^sup>d *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a local.hm_impl_rel", "by sepref"], ["", "lemmas [sepref_fr_rules] = hm_sink_op_impl.refine"], ["", "sepref_register \"PR_CONST hm_sink_op::(nat,'v) ahm \\<Rightarrow> _\""], ["", "lemma [def_pat_rules]: \"hmstruct.hm_sink_op$prio \\<equiv> PR_CONST hm_sink_op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hmstruct.hm_sink_op $ prio \\<equiv> PR_CONST hm_sink_op", "by simp"], ["", "sepref_definition hm_repair_op_impl is \"uncurry (PR_CONST hm_repair_op)\" :: \"hm_impl_rel\\<^sup>d*\\<^sub>anat_assn\\<^sup>k \\<rightarrow>\\<^sub>a hm_impl_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry (PR_CONST hm_repair_op))\n    \\<in> local.hm_impl_rel\\<^sup>d *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a local.hm_impl_rel", "unfolding hm_repair_op_def[abs_def] PR_CONST_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>hm i.\n          hm_sink_op hm i \\<bind>\n          (\\<lambda>hm. hm_swim_op hm i \\<bind> RETURN)))\n    \\<in> local.hm_impl_rel\\<^sup>d *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a local.hm_impl_rel", "by sepref"], ["", "lemmas [sepref_fr_rules] = hm_repair_op_impl.refine"], ["", "sepref_register \"PR_CONST hm_repair_op::(nat,'v) ahm \\<Rightarrow> _\""], ["", "lemma [def_pat_rules]: \"hmstruct.hm_repair_op$prio \\<equiv> PR_CONST hm_repair_op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hmstruct.hm_repair_op $ prio \\<equiv> PR_CONST hm_repair_op", "by simp"], ["", "subsection \\<open>Interface Operations\\<close>"], ["", "definition hm_rel_np where \n    \"hm_rel_np \\<equiv> hr_comp hm_impl_rel heapmap_rel\""], ["", "lemmas [fcomp_norm_unfold] = hm_rel_np_def[symmetric]"], ["", "definition hm_rel where\n    \"hm_rel K V \\<equiv> hr_comp hm_rel_np (\\<langle>the_pure K,the_pure V\\<rangle>map_rel)\""], ["", "lemmas [fcomp_norm_unfold] = hm_rel_def[symmetric]"], ["", "lemmas [intf_of_assn] = intf_of_assnI[where R=\"hm_rel K V\" and 'a=\"('kk,'vv) i_map\" for K V]"], ["", "lemma hm_rel_id_conv: \"hm_rel id_assn id_assn = hm_rel_np\"\n    \\<comment> \\<open>Used for generic algorithms: Unfold with this, then let decl-impl compose with \\<open>map_rel\\<close> again.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.hm_rel nat_assn id_assn = local.hm_rel_np", "unfolding hm_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hr_comp local.hm_rel_np\n     (\\<langle>the_pure nat_assn, the_pure id_assn\\<rangle>map_rel) =\n    local.hm_rel_np", "by simp"], ["", "subsubsection \\<open>Synthesis\\<close>"], ["", "definition op_hm_empty_sz :: \"nat \\<Rightarrow> 'kk\\<rightharpoonup>'vv\"\n    where [simp]: \"op_hm_empty_sz sz \\<equiv> op_map_empty\""], ["", "sepref_register \"PR_CONST (op_hm_empty_sz maxsize)\" :: \"('k,'v) i_map\""], ["", "lemma [def_pat_rules]: \"op_hm_empty_sz$maxsize \\<equiv> UNPROTECT (op_hm_empty_sz maxsize)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op_hm_empty_sz $ maxsize \\<equiv> UNPROTECT (op_hm_empty_sz maxsize)", "by simp"], ["", "lemma hm_fold_custom_empty_sz: \n    \"op_map_empty = op_hm_empty_sz sz\"\n    \"Map.empty = op_hm_empty_sz sz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op_map_empty = op_hm_empty_sz sz &&& Map.empty = op_hm_empty_sz sz", "by auto"], ["", "sepref_definition hm_empty_op_impl is \"uncurry0 hm_empty_op'\" :: \"unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a hm_impl2_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2, uncurry0 local.hm_empty_op')\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a local.hm_impl2_rel", "unfolding hm_empty_op'_def hm_impl2_rel_def array.fold_custom_empty"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2,\n     uncurry0\n      (let pq = op_ial_empty_sz maxsize; ml = op_array_empty\n       in RETURN (pq, ml)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a ial_assn maxsize\n             nat_assn \\<times>\\<^sub>a\n            array_assn id_assn", "by sepref"], ["", "sepref_definition hm_insert_op_impl is \"uncurry2 hm_insert_op\" :: \"[\\<lambda>((k,_),_). k<maxsize]\\<^sub>a id_assn\\<^sup>k*\\<^sub>aid_assn\\<^sup>k*\\<^sub>ahm_impl_rel\\<^sup>d \\<rightarrow> hm_impl_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3, uncurry2 hm_insert_op)\n    \\<in> [\\<lambda>((k, uu_), uu_).\n              k < maxsize]\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n                                   id_assn\\<^sup>k *\\<^sub>a\n                                   local.hm_impl_rel\\<^sup>d \\<rightarrow> local.hm_impl_rel", "unfolding hm_insert_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>k v h.\n          ASSERT (h.heap_invar (hmr_\\<alpha> h)) \\<bind>\n          (\\<lambda>_.\n              hm_append_op h k v \\<bind>\n              (\\<lambda>h.\n                  let l = hm_length h in hm_swim_op h l \\<bind> RETURN))))\n    \\<in> [\\<lambda>((k, uu_), uu_).\n              k < maxsize]\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n                                   id_assn\\<^sup>k *\\<^sub>a\n                                   local.hm_impl_rel\\<^sup>d \\<rightarrow> local.hm_impl_rel", "by sepref"], ["", "sepref_definition hm_is_empty_op_impl is \"hm_is_empty_op\" :: \"hm_impl_rel\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, hm_is_empty_op)\n    \\<in> local.hm_impl_rel\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "unfolding hm_is_empty_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>hm.\n        ASSERT (hmr_invar hm) \\<bind>\n        (\\<lambda>_. let l = hm_length hm in RETURN (l = 0)))\n    \\<in> local.hm_impl_rel\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "by sepref"], ["", "sepref_definition hm_lookup_op_impl is \"uncurry hm_lookup_op\" :: \"id_assn\\<^sup>k*\\<^sub>ahm_impl_rel\\<^sup>k \\<rightarrow>\\<^sub>a option_assn id_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry hm_lookup_op)\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a\n          local.hm_impl_rel\\<^sup>k \\<rightarrow>\\<^sub>a option_assn\n                     id_assn", "unfolding hm_lookup_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>k hm.\n          ASSERT (heapmap_invar hm) \\<bind>\n          (\\<lambda>_. RETURN (heapmap_\\<alpha> hm k))))\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a\n          local.hm_impl_rel\\<^sup>k \\<rightarrow>\\<^sub>a option_assn\n                     id_assn", "by sepref"], ["", "sepref_definition hm_contains_key_impl is \"uncurry hm_contains_key_op'\" :: \"id_assn\\<^sup>k*\\<^sub>ahm_impl2_rel\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry local.hm_contains_key_op')\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a\n          local.hm_impl2_rel\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "unfolding hm_contains_key_op'_def hm_impl2_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>k (pq, ml).\n          if k < maxsize then RETURN (op_list_contains k pq)\n          else RETURN False))\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a\n          (ial_assn maxsize nat_assn \\<times>\\<^sub>a\n           array_assn id_assn)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "by sepref"], ["", "sepref_definition hm_decrease_key_op_impl is \"uncurry2 hm_decrease_key_op\" :: \"id_assn\\<^sup>k*\\<^sub>aid_assn\\<^sup>k*\\<^sub>ahm_impl_rel\\<^sup>d \\<rightarrow>\\<^sub>a hm_impl_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3, uncurry2 hm_decrease_key_op)\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a id_assn\\<^sup>k *\\<^sub>a\n          local.hm_impl_rel\\<^sup>d \\<rightarrow>\\<^sub>a local.hm_impl_rel", "unfolding hm_decrease_key_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>k v hm.\n          ASSERT (heapmap_invar hm) \\<bind>\n          (\\<lambda>_.\n              ASSERT\n               (heapmap_\\<alpha> hm k \\<noteq> None \\<and>\n                prio v \\<le> prio (the (heapmap_\\<alpha> hm k))) \\<bind>\n              (\\<lambda>_.\n                  hm_index_op hm k \\<bind>\n                  (\\<lambda>i.\n                      hm_update_op hm i v \\<bind>\n                      (\\<lambda>hm. hm_swim_op hm i))))))\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a id_assn\\<^sup>k *\\<^sub>a\n          local.hm_impl_rel\\<^sup>d \\<rightarrow>\\<^sub>a local.hm_impl_rel", "by sepref"], ["", "sepref_definition hm_increase_key_op_impl is \"uncurry2 hm_increase_key_op\" :: \"id_assn\\<^sup>k*\\<^sub>aid_assn\\<^sup>k*\\<^sub>ahm_impl_rel\\<^sup>d \\<rightarrow>\\<^sub>a hm_impl_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3, uncurry2 hm_increase_key_op)\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a id_assn\\<^sup>k *\\<^sub>a\n          local.hm_impl_rel\\<^sup>d \\<rightarrow>\\<^sub>a local.hm_impl_rel", "unfolding hm_increase_key_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>k v hm.\n          ASSERT (heapmap_invar hm) \\<bind>\n          (\\<lambda>_.\n              ASSERT\n               (heapmap_\\<alpha> hm k \\<noteq> None \\<and>\n                prio (the (heapmap_\\<alpha> hm k)) \\<le> prio v) \\<bind>\n              (\\<lambda>_.\n                  hm_index_op hm k \\<bind>\n                  (\\<lambda>i.\n                      hm_update_op hm i v \\<bind>\n                      (\\<lambda>hm. hm_sink_op hm i))))))\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a id_assn\\<^sup>k *\\<^sub>a\n          local.hm_impl_rel\\<^sup>d \\<rightarrow>\\<^sub>a local.hm_impl_rel", "by sepref"], ["", "sepref_definition hm_change_key_op_impl is \"uncurry2 hm_change_key_op\" :: \"id_assn\\<^sup>k*\\<^sub>aid_assn\\<^sup>k*\\<^sub>ahm_impl_rel\\<^sup>d \\<rightarrow>\\<^sub>a hm_impl_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3, uncurry2 hm_change_key_op)\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a id_assn\\<^sup>k *\\<^sub>a\n          local.hm_impl_rel\\<^sup>d \\<rightarrow>\\<^sub>a local.hm_impl_rel", "unfolding hm_change_key_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>k v hm.\n          ASSERT (heapmap_invar hm) \\<bind>\n          (\\<lambda>_.\n              ASSERT (heapmap_\\<alpha> hm k \\<noteq> None) \\<bind>\n              (\\<lambda>_.\n                  hm_index_op hm k \\<bind>\n                  (\\<lambda>i.\n                      hm_update_op hm i v \\<bind>\n                      (\\<lambda>hm. hm_repair_op hm i))))))\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a id_assn\\<^sup>k *\\<^sub>a\n          local.hm_impl_rel\\<^sup>d \\<rightarrow>\\<^sub>a local.hm_impl_rel", "by sepref"], ["", "sepref_definition hm_pop_min_op_impl is hm_pop_min_op :: \"hm_impl_rel\\<^sup>d \\<rightarrow>\\<^sub>a prod_assn (prod_assn nat_assn id_assn) hm_impl_rel \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, hm_pop_min_op)\n    \\<in> local.hm_impl_rel\\<^sup>d \\<rightarrow>\\<^sub>a (nat_assn \\<times>\\<^sub>a\n                     id_assn) \\<times>\\<^sub>a\n                    local.hm_impl_rel", "unfolding hm_pop_min_op_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>hm.\n        ASSERT (heapmap_invar hm) \\<bind>\n        (\\<lambda>_.\n            ASSERT (hm_valid hm 1) \\<bind>\n            (\\<lambda>_.\n                hm_key_of_op hm 1 \\<bind>\n                (\\<lambda>k.\n                    hm_the_lookup_op hm k \\<bind>\n                    (\\<lambda>v.\n                        let l = hm_length hm\n                        in hm_exch_op hm 1 l \\<bind>\n                           (\\<lambda>hm.\n                               hm_butlast_op hm \\<bind>\n                               (\\<lambda>hm.\n                                   if l \\<noteq> 1\n                                   then hm_sink_op hm 1 \\<bind>\n  (\\<lambda>hm. RETURN ((k, v), hm))\n                                   else RETURN ((k, v), hm))))))))\n    \\<in> local.hm_impl_rel\\<^sup>d \\<rightarrow>\\<^sub>a (nat_assn \\<times>\\<^sub>a\n                     id_assn) \\<times>\\<^sub>a\n                    local.hm_impl_rel", "by sepref"], ["", "sepref_definition hm_remove_op_impl is \"uncurry hm_remove_op\" :: \"id_assn\\<^sup>k *\\<^sub>a hm_impl_rel\\<^sup>d \\<rightarrow>\\<^sub>a hm_impl_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry hm_remove_op)\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a\n          local.hm_impl_rel\\<^sup>d \\<rightarrow>\\<^sub>a local.hm_impl_rel", "unfolding hm_remove_op_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>k hm.\n          ASSERT (heapmap_invar hm) \\<bind>\n          (\\<lambda>_.\n              ASSERT (k \\<in> dom (heapmap_\\<alpha> hm)) \\<bind>\n              (\\<lambda>_.\n                  hm_index_op hm k \\<bind>\n                  (\\<lambda>i.\n                      let l = hm_length hm\n                      in hm_exch_op hm i l \\<bind>\n                         (\\<lambda>hm.\n                             hm_butlast_op hm \\<bind>\n                             (\\<lambda>hm.\n                                 if i \\<noteq> l then hm_repair_op hm i\n                                 else RETURN hm)))))))\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a\n          local.hm_impl_rel\\<^sup>d \\<rightarrow>\\<^sub>a local.hm_impl_rel", "by sepref"], ["", "sepref_definition hm_peek_min_op_impl is \"hm_peek_min_op\" :: \"hm_impl_rel\\<^sup>k \\<rightarrow>\\<^sub>a prod_assn nat_assn id_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, hm_peek_min_op)\n    \\<in> local.hm_impl_rel\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn \\<times>\\<^sub>a\n                    id_assn", "unfolding hm_peek_min_op_def[abs_def] hm_kv_of_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>hm.\n        ASSERT (hm_valid hm 1 \\<and> hmr_invar hm) \\<bind>\n        (\\<lambda>_.\n            hm_key_of_op hm 1 \\<bind>\n            (\\<lambda>k.\n                hm_the_lookup_op hm k \\<bind> (\\<lambda>v. RETURN (k, v)))))\n    \\<in> local.hm_impl_rel\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn \\<times>\\<^sub>a\n                    id_assn", "by sepref"], ["", "subsubsection \\<open>Setup of Refinements\\<close>"], ["", "sepref_decl_impl (no_register) hm_empty: \n    hm_empty_op_impl.refine[FCOMP hm_empty_op'_refine, FCOMP hm_empty_aref]"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "context fixes K assumes \"IS_BELOW_ID K\" begin"], ["", "lemmas mop_map_update_new_fref' = mop_map_update_new.fref[of K]"], ["", "lemmas op_map_update_fref' = op_map_update.fref[of K]"], ["", "end"], ["", "sepref_decl_impl (ismop) hm_insert: hm_insert_op_impl.refine[FCOMP hm_insert_op_aref]\n    uses mop_map_update_new_fref'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>IS_BELOW_ID (the_pure K); single_valued (the_pure K);\n     single_valued ((the_pure K)\\<inverse>)\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>((a, b), ba). a < maxsize,\n                       \\<lambda>((a, b), ba). a < maxsize)\n                      \\<in> (the_pure K \\<times>\\<^sub>r\n                             the_pure V) \\<times>\\<^sub>r\n                            \\<langle>the_pure K,\n                            the_pure V\\<rangle>map_rel \\<rightarrow>\n                            bool_rel", "unfolding IS_BELOW_ID_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>the_pure K \\<subseteq> nat_rel; single_valued (the_pure K);\n     single_valued ((the_pure K)\\<inverse>)\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>((a, b), ba). a < maxsize,\n                       \\<lambda>((a, b), ba). a < maxsize)\n                      \\<in> (the_pure K \\<times>\\<^sub>r\n                             the_pure V) \\<times>\\<^sub>r\n                            \\<langle>the_pure K,\n                            the_pure V\\<rangle>map_rel \\<rightarrow>\n                            bool_rel", "apply (parametricity; auto simp: single_valued_below_Id)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "sepref_decl_impl hm_is_empty: hm_is_empty_op_impl.refine[FCOMP hm_is_empty_op_aref]"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_impl hm_lookup: hm_lookup_op_impl.refine[FCOMP hm_lookup_op_aref]"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_impl hm_contains_key: \n    hm_contains_key_impl.refine[FCOMP hm_contains_key_op'_refine, FCOMP hm_contains_key_op_aref]"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_impl (ismop) hm_decrease_key: hm_decrease_key_op_impl.refine[FCOMP hm_decrease_key_op_aref]"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_impl (ismop) hm_increase_key: hm_increase_key_op_impl.refine[FCOMP hm_increase_key_op_aref]"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_impl (ismop) hm_change_key: hm_change_key_op_impl.refine[FCOMP hm_change_key_op_aref]"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_impl (ismop) hm_remove: hm_remove_op_impl.refine[FCOMP hm_remove_op_aref]"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_impl (ismop) hm_pop_min: hm_pop_min_op_impl.refine[FCOMP hm_pop_min_op_aref]"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_impl (ismop) hm_peek_min: hm_peek_min_op_impl.refine[FCOMP hm_peek_min_op_aref]"], ["proof (prove)\ngoal:\nNo subgoals!", ".\n\n  \\<comment> \\<open>Realized as generic algorithm. Note that we use @{term id_assn} for the elements.\\<close>"], ["", "sepref_definition hm_upd_op_impl is \"uncurry2 (RETURN ooo op_map_update)\" :: \"[\\<lambda>((k,_),_). k<maxsize]\\<^sub>a id_assn\\<^sup>k *\\<^sub>a id_assn\\<^sup>k *\\<^sub>a (hm_rel id_assn id_assn)\\<^sup>d \\<rightarrow> hm_rel id_assn id_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3, uncurry2 (RETURN \\<circ>\\<circ>\\<circ> op_map_update))\n    \\<in> [\\<lambda>((k, uu_), uu_).\n              k < maxsize]\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n                                   id_assn\\<^sup>k *\\<^sub>a\n                                   (local.hm_rel nat_assn\n                                     id_assn)\\<^sup>d \\<rightarrow> local.hm_rel\n                               nat_assn id_assn", "unfolding op_pm_set_gen_impl"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>k v m.\n          RETURN (op_map_contains_key k m) \\<bind>\n          (\\<lambda>c.\n              if c then mop_map_update_ex k v m\n              else mop_map_update_new k v m)))\n    \\<in> [\\<lambda>((k, uu_), uu_).\n              k < maxsize]\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n                                   id_assn\\<^sup>k *\\<^sub>a\n                                   (local.hm_rel nat_assn\n                                     id_assn)\\<^sup>d \\<rightarrow> local.hm_rel\n                               nat_assn id_assn", "by sepref"], ["", "sepref_decl_impl hm_upd_op_impl.refine[unfolded hm_rel_id_conv] uses op_map_update_fref'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>IS_BELOW_ID (the_pure K); single_valued (the_pure K);\n     single_valued ((the_pure K)\\<inverse>)\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>((k, uu_), uu_). k < maxsize,\n                       \\<lambda>((k, uu_), uu_). k < maxsize)\n                      \\<in> (the_pure K \\<times>\\<^sub>r\n                             the_pure V) \\<times>\\<^sub>r\n                            \\<langle>the_pure K,\n                            the_pure V\\<rangle>map_rel \\<rightarrow>\n                            bool_rel", "unfolding IS_BELOW_ID_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>the_pure K \\<subseteq> nat_rel; single_valued (the_pure K);\n     single_valued ((the_pure K)\\<inverse>)\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>((k, uu_), uu_). k < maxsize,\n                       \\<lambda>((k, uu_), uu_). k < maxsize)\n                      \\<in> (the_pure K \\<times>\\<^sub>r\n                             the_pure V) \\<times>\\<^sub>r\n                            \\<langle>the_pure K,\n                            the_pure V\\<rangle>map_rel \\<rightarrow>\n                            bool_rel", "apply (parametricity; auto simp: single_valued_below_Id)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "end"], ["", "interpretation hm: map_custom_empty \"PR_CONST (op_hm_empty_sz maxsize)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_custom_empty (PR_CONST (op_hm_empty_sz maxsize))", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. PR_CONST (op_hm_empty_sz maxsize) = op_map_empty", "by simp"], ["", "lemma op_hm_empty_sz_hnr[sepref_fr_rules]:\n  \"(uncurry0 (hm_empty_op_impl maxsize), uncurry0 (RETURN (PR_CONST (op_hm_empty_sz maxsize)))) \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a hm_rel maxsize prio K V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 (hm_empty_op_impl maxsize),\n     uncurry0 (RETURN (PR_CONST (op_hm_empty_sz maxsize))))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a hm_rel maxsize prio K V", "using hm_empty_hnr"], ["proof (prove)\nusing this:\n  (uncurry0 (hm_empty_op_impl ?maxsize), uncurry0 (RETURN op_map_empty))\n  \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a hm_rel ?maxsize ?prio ?K ?V\n\ngoal (1 subgoal):\n 1. (uncurry0 (hm_empty_op_impl maxsize),\n     uncurry0 (RETURN (PR_CONST (op_hm_empty_sz maxsize))))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a hm_rel maxsize prio K V", "by simp"], ["", "subsection \\<open>Manual fine-tuning of code-lemmas\\<close>"], ["", "(* TODO: Integrate into Sepref-tool optimization phase! *)"], ["", "context\nnotes [simp del] = CNV_def efficient_nat_div2\nbegin"], ["", "lemma nested_case_bind: \n  \"(case p of (a,b) \\<Rightarrow> bind (case a of (a1,a2) \\<Rightarrow> m a b a1 a2) (f a b)) \n  = (case p of ((a1,a2),b) \\<Rightarrow> bind (m (a1,a2) b a1 a2) (f (a1,a2) b))\"\n  \"(case p of (a,b) \\<Rightarrow> bind (case b of (b1,b2) \\<Rightarrow> m a b b1 b2) (f a b)) \n  = (case p of (a,b1,b2) \\<Rightarrow> bind (m a (b1,b2) b1 b2) (f a (b1,b2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case p of\n     (a, b) \\<Rightarrow>\n       (case a of (a1, a2) \\<Rightarrow> m a b a1 a2) \\<bind> f a b) =\n    (case p of\n     ((a1, a2), b) \\<Rightarrow>\n       m (a1, a2) b a1 a2 \\<bind> f (a1, a2) b) &&&\n    (case p of\n     (a, b) \\<Rightarrow>\n       (case b of (b1, b2) \\<Rightarrow> m a b b1 b2) \\<bind> f a b) =\n    (case p of\n     (a, b1, b2) \\<Rightarrow> m a (b1, b2) b1 b2 \\<bind> f a (b1, b2))", "by (simp_all split: prod.splits)"], ["", "lemma it_case: \"(case p of (a,b) \\<Rightarrow> f p a b) = (case p of (a,b) \\<Rightarrow> f (a,b) a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case p of (a, b) \\<Rightarrow> f p a b) =\n    (case p of (a, b) \\<Rightarrow> f (a, b) a b)", "by (auto split: prod.split)"], ["", "lemma c2l: \"(case p of (a,b) \\<Rightarrow> bind (m a b) (f a b)) = \n  do { let (a,b) = p; bind (m a b) (f a b)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case p of (a, b) \\<Rightarrow> m a b \\<bind> f a b) =\n    (let (a, b) = p in m a b \\<bind> f a b)", "by simp"], ["", "lemma bind_Let: \"do { x \\<leftarrow> do { let y = v; (f y :: 'a Heap)}; g x } = do { let y=v; x \\<leftarrow> f y; g x }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Let v f \\<bind> g = (let y = v in f y \\<bind> g)", "by auto"], ["", "lemma bind_case: \"do { x \\<leftarrow> (case y of (a,b) \\<Rightarrow> f a b); (g x :: 'a Heap) } = do { let (a,b) = y; x \\<leftarrow> f a b; g x }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case y of (a, b) \\<Rightarrow> f a b) \\<bind> g =\n    (let (a, b) = y in f a b \\<bind> g)", "by (auto split: prod.splits)"], ["", "lemma bind_case_mvup: \"do { x \\<leftarrow> f; case y of (a,b) \\<Rightarrow> g a b x } \n  = do { let (a,b) = y; x \\<leftarrow> f; (g a b x :: 'a Heap) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<bind> (\\<lambda>x. case y of (a, b) \\<Rightarrow> g a b x) =\n    (let (a, b) = y in f \\<bind> g a b)", "by (auto split: prod.splits)"], ["", "lemma if_case_mvup: \"(if b then case p of (x1,x2) \\<Rightarrow> f x1 x2 else e)\n  = (case p of (x1,x2) \\<Rightarrow> if b then f x1 x2 else e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if b then case p of (x1, x2) \\<Rightarrow> f x1 x2 else e) =\n    (case p of (x1, x2) \\<Rightarrow> if b then f x1 x2 else e)", "by auto"], ["", "lemma nested_case: \"(case p of (a,b) \\<Rightarrow> (case p of (c,d) \\<Rightarrow> f a b c d)) =\n  (case p of (a,b) \\<Rightarrow> f a b a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case p of\n     (a, b) \\<Rightarrow> case p of (c, d) \\<Rightarrow> f a b c d) =\n    (case p of (a, b) \\<Rightarrow> f a b a b)", "by (auto split: prod.split)"], ["", "lemma split_prod_bound: \"(\\<lambda>p. f p) = (\\<lambda>(a,b). f (a,b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = (\\<lambda>(a, b). f (a, b))", "by auto"], ["", "lemma bpc_conv: \"do { (a,b) \\<leftarrow> (m::(_*_) Heap); f a b } = do {\n  ab \\<leftarrow> (m);\n  f (fst ab) (snd ab)\n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> (\\<lambda>(a, b). f a b) =\n    m \\<bind> (\\<lambda>ab. f (fst ab) (snd ab))", "apply (subst (2) split_prod_bound)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> (\\<lambda>(x, y). f x y) =\n    m \\<bind> (\\<lambda>(a, b). f (fst (a, b)) (snd (a, b)))", "by simp"], ["", "lemma it_case_pp: \"(case p of ((p1,p2)) \\<Rightarrow> case p of ((p1',p2')) \\<Rightarrow> f p1 p2 p1' p2')\n  = (case p of ((p1,p2)) \\<Rightarrow> f p1 p2 p1 p2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case p of\n     (p1, p2) \\<Rightarrow>\n       case p of (p1', p2') \\<Rightarrow> f p1 p2 p1' p2') =\n    (case p of (p1, p2) \\<Rightarrow> f p1 p2 p1 p2)", "by (auto split: prod.split)"], ["", "lemma it_case_ppp: \"(case p of ((p1,p2),p3) \\<Rightarrow> case p of ((p1',p2'),p3') \\<Rightarrow> f p1 p2 p3 p1' p2' p3')\n  = (case p of ((p1,p2),p3) \\<Rightarrow> f p1 p2 p3 p1 p2 p3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case p of\n     ((p1, p2), p3) \\<Rightarrow>\n       case p of ((p1', p2'), p3') \\<Rightarrow> f p1 p2 p3 p1' p2' p3') =\n    (case p of ((p1, p2), p3) \\<Rightarrow> f p1 p2 p3 p1 p2 p3)", "by (auto split: prod.split)"], ["", "lemma it_case_pppp: \"(case a1 of\n              (((a, b), c), d) \\<Rightarrow>\n                case a1 of\n                (((a', b'), c'), d') \\<Rightarrow> f a b c d a' b' c' d') =\n       (case a1 of\n              (((a, b), c), d) \\<Rightarrow> f a b c d a b c d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case a1 of\n     (((a, b), c), d) \\<Rightarrow>\n       case a1 of\n       (((a', b'), c'), d') \\<Rightarrow> f a b c d a' b' c' d') =\n    (case a1 of (((a, b), c), d) \\<Rightarrow> f a b c d a b c d)", "by (auto split: prod.splits)"], ["", "private"], ["", "lemmas inlines = hm_append_op_impl_def ial_append_def\n    marl_length_def marl_append_def hm_length_impl_def ial_length_def\n    hm_valid_impl_def hm_prio_of_op_impl_def hm_val_of_op_impl_def hm_key_of_op_impl_def\n    ial_get_def hm_the_lookup_op_impl_def heap_array_set_def marl_get_def\n    it_case_ppp it_case_pppp bind_case bind_case_mvup nested_case if_case_mvup\n    it_case_pp"], ["", "schematic_goal [code]: \"hm_insert_op_impl maxsize prio hm k v = ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_insert_op_impl maxsize prio hm k v = ?f", "unfolding hm_insert_op_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_append_op_impl maxsize v hm k \\<bind>\n    (\\<lambda>x'. hm_length_impl x' \\<bind> hm_swim_op_impl prio x') =\n    ?f", "apply (rule CNV_eqD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. CNV (hm_append_op_impl maxsize v hm k \\<bind>\n         (\\<lambda>x'. hm_length_impl x' \\<bind> hm_swim_op_impl prio x'))\n     ?f", "apply (simp add: inlines  cong: if_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. CNV (case v of\n         ((a1a, a2a), a2) \\<Rightarrow>\n           case a1a of\n           (a, b) \\<Rightarrow>\n             (case a1a of\n              (a, n) \\<Rightarrow>\n                \\<lambda>x.\n                   Array.upd n x a \\<bind> (\\<lambda>a. return (a, Suc n)))\n              hm \\<bind>\n             (\\<lambda>x.\n                 case x of\n                 (a, ba) \\<Rightarrow>\n                   Array.upd hm b a2a \\<bind>\n                   (\\<lambda>xa.\n                       Array.len a2 \\<bind>\n                       (\\<lambda>xaa.\n                           (if xaa = 0 then Array.new maxsize k\n                            else return a2) \\<bind>\n                           (\\<lambda>xaa.\n                               Array.upd hm k xaa \\<bind>\n                               (\\<lambda>xaa.\n                                   hm_swim_op_impl prio ((x, xa), xaa)\n                                    ba))))))\n     ?f", "by (rule CNV_I)"], ["", "schematic_goal \"hm_swim_op_impl prio hm i \\<equiv> ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_swim_op_impl prio hm i \\<equiv> ?f", "unfolding hm_swim_op_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap.fixp_fun\n     (\\<lambda>cf (a1, a2).\n         hm_valid_impl a1 (efficient_nat_div2 a2) \\<bind>\n         (\\<lambda>x'a.\n             if x'a\n             then hm_prio_of_op_impl prio a1 (efficient_nat_div2 a2) \\<bind>\n                  (\\<lambda>x'b.\n                      hm_prio_of_op_impl prio a1 a2 \\<bind>\n                      (\\<lambda>x'c.\n                          if \\<not> x'b \\<le> x'c\n                          then hm_exch_op_impl a1 a2\n                                (efficient_nat_div2 a2) \\<bind>\n                               (\\<lambda>x'e.\n                                   cf (x'e, efficient_nat_div2 a2))\n                          else return a1))\n             else return a1))\n     (hm, i) \\<equiv>\n    ?f", "apply (rule eq_reflection)"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap.fixp_fun\n     (\\<lambda>cf (a1, a2).\n         hm_valid_impl a1 (efficient_nat_div2 a2) \\<bind>\n         (\\<lambda>x'a.\n             if x'a\n             then hm_prio_of_op_impl prio a1 (efficient_nat_div2 a2) \\<bind>\n                  (\\<lambda>x'b.\n                      hm_prio_of_op_impl prio a1 a2 \\<bind>\n                      (\\<lambda>x'c.\n                          if \\<not> x'b \\<le> x'c\n                          then hm_exch_op_impl a1 a2\n                                (efficient_nat_div2 a2) \\<bind>\n                               (\\<lambda>x'e.\n                                   cf (x'e, efficient_nat_div2 a2))\n                          else return a1))\n             else return a1))\n     (hm, i) =\n    ?f", "apply (rule CNV_eqD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. CNV (heap.fixp_fun\n          (\\<lambda>cf (a1, a2).\n              hm_valid_impl a1 (efficient_nat_div2 a2) \\<bind>\n              (\\<lambda>x'a.\n                  if x'a\n                  then hm_prio_of_op_impl prio a1\n                        (efficient_nat_div2 a2) \\<bind>\n                       (\\<lambda>x'b.\n                           hm_prio_of_op_impl prio a1 a2 \\<bind>\n                           (\\<lambda>x'c.\n                               if \\<not> x'b \\<le> x'c\n                               then hm_exch_op_impl a1 a2\n                                     (efficient_nat_div2 a2) \\<bind>\n                                    (\\<lambda>x'e.\n  cf (x'e, efficient_nat_div2 a2))\n                               else return a1))\n                  else return a1))\n          (hm, i))\n     ?f", "apply (simp add: inlines efficient_nat_div2  \n    cong: if_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. CNV (heap.fixp_fun\n          (\\<lambda>cf (a1, a2).\n              case a1 of\n              ((a1b, a2b), a2a) \\<Rightarrow>\n                case a1b of\n                (a, b) \\<Rightarrow>\n                  if 0 < a2 div 2 \\<and> a2 div 2 \\<le> b\n                  then (case a1b of (a, n) \\<Rightarrow> Array.nth a)\n                        (a2 div 2 - Suc 0) \\<bind>\n                       (\\<lambda>x.\n                           Array.nth a2a x \\<bind>\n                           (\\<lambda>x.\n                               (case a1b of\n                                (a, n) \\<Rightarrow> Array.nth a)\n                                (a2 - Suc 0) \\<bind>\n                               (\\<lambda>xa.\n                                   Array.nth a2a xa \\<bind>\n                                   (\\<lambda>xa.\n if prio x \\<le> prio xa then return a1\n else hm_exch_op_impl a1 a2 (a2 div 2) \\<bind>\n      (\\<lambda>x'e. cf (x'e, a2 div 2))))))\n                  else return a1)\n          (hm, i))\n     ?f", "by (rule CNV_I)"], ["", "lemma hm_swim_op_impl_code[code]: \"hm_swim_op_impl prio hm i \\<equiv> ccpo.fixp (fun_lub Heap_lub) (fun_ord Heap_ord)\n       (\\<lambda>cf (a1, a2).\n           case a1 of\n           ((a1b, a2b), a2a) \\<Rightarrow>\n             case a1b of\n             (a, b) \\<Rightarrow> do {\n               let d2 = efficient_nat_div2 a2; \n               if 0 < d2 \\<and> d2 \\<le> b\n               then do {\n                      x \\<leftarrow> (case a1b of (a, n) \\<Rightarrow> Array.nth a) (d2 - Suc 0);\n                      x \\<leftarrow> Array.nth a2a x;\n                      xa \\<leftarrow> (case a1b of (a, n) \\<Rightarrow> Array.nth a) (a2 - Suc 0);\n                      xa \\<leftarrow> Array.nth a2a xa;\n                      if prio x \\<le> prio xa then return a1\n                      else do {\n                             x'g \\<leftarrow> hm_exch_op_impl a1 a2 (d2);\n                             cf (x'g, d2)\n                           }\n                    }\n               else return a1\n             })\n       (hm, i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_swim_op_impl prio hm i \\<equiv>\n    heap.fixp_fun\n     (\\<lambda>cf (a1, a2).\n         case a1 of\n         ((a1b, a2b), a2a) \\<Rightarrow>\n           case a1b of\n           (a, b) \\<Rightarrow>\n             let d2 = efficient_nat_div2 a2\n             in if 0 < d2 \\<and> d2 \\<le> b\n                then (case a1b of (a, n) \\<Rightarrow> Array.nth a)\n                      (d2 - Suc 0) \\<bind>\n                     (\\<lambda>x.\n                         Array.nth a2a x \\<bind>\n                         (\\<lambda>x.\n                             (case a1b of (a, n) \\<Rightarrow> Array.nth a)\n                              (a2 - Suc 0) \\<bind>\n                             (\\<lambda>xa.\n                                 Array.nth a2a xa \\<bind>\n                                 (\\<lambda>xa.\n                                     if prio x \\<le> prio xa then return a1\n                                     else hm_exch_op_impl a1 a2 d2 \\<bind>\n    (\\<lambda>x'g. cf (x'g, d2))))))\n                else return a1)\n     (hm, i)", "unfolding hm_swim_op_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap.fixp_fun\n     (\\<lambda>cf (a1, a2).\n         hm_valid_impl a1 (efficient_nat_div2 a2) \\<bind>\n         (\\<lambda>x'a.\n             if x'a\n             then hm_prio_of_op_impl prio a1 (efficient_nat_div2 a2) \\<bind>\n                  (\\<lambda>x'b.\n                      hm_prio_of_op_impl prio a1 a2 \\<bind>\n                      (\\<lambda>x'c.\n                          if \\<not> x'b \\<le> x'c\n                          then hm_exch_op_impl a1 a2\n                                (efficient_nat_div2 a2) \\<bind>\n                               (\\<lambda>x'e.\n                                   cf (x'e, efficient_nat_div2 a2))\n                          else return a1))\n             else return a1))\n     (hm, i) \\<equiv>\n    heap.fixp_fun\n     (\\<lambda>cf (a1, a2).\n         case a1 of\n         ((a1b, a2b), a2a) \\<Rightarrow>\n           case a1b of\n           (a, b) \\<Rightarrow>\n             let d2 = efficient_nat_div2 a2\n             in if 0 < d2 \\<and> d2 \\<le> b\n                then (case a1b of (a, n) \\<Rightarrow> Array.nth a)\n                      (d2 - Suc 0) \\<bind>\n                     (\\<lambda>x.\n                         Array.nth a2a x \\<bind>\n                         (\\<lambda>x.\n                             (case a1b of (a, n) \\<Rightarrow> Array.nth a)\n                              (a2 - Suc 0) \\<bind>\n                             (\\<lambda>xa.\n                                 Array.nth a2a xa \\<bind>\n                                 (\\<lambda>xa.\n                                     if prio x \\<le> prio xa then return a1\n                                     else hm_exch_op_impl a1 a2 d2 \\<bind>\n    (\\<lambda>x'g. cf (x'g, d2))))))\n                else return a1)\n     (hm, i)", "apply (rule eq_reflection)"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap.fixp_fun\n     (\\<lambda>cf (a1, a2).\n         hm_valid_impl a1 (efficient_nat_div2 a2) \\<bind>\n         (\\<lambda>x'a.\n             if x'a\n             then hm_prio_of_op_impl prio a1 (efficient_nat_div2 a2) \\<bind>\n                  (\\<lambda>x'b.\n                      hm_prio_of_op_impl prio a1 a2 \\<bind>\n                      (\\<lambda>x'c.\n                          if \\<not> x'b \\<le> x'c\n                          then hm_exch_op_impl a1 a2\n                                (efficient_nat_div2 a2) \\<bind>\n                               (\\<lambda>x'e.\n                                   cf (x'e, efficient_nat_div2 a2))\n                          else return a1))\n             else return a1))\n     (hm, i) =\n    heap.fixp_fun\n     (\\<lambda>cf (a1, a2).\n         case a1 of\n         ((a1b, a2b), a2a) \\<Rightarrow>\n           case a1b of\n           (a, b) \\<Rightarrow>\n             let d2 = efficient_nat_div2 a2\n             in if 0 < d2 \\<and> d2 \\<le> b\n                then (case a1b of (a, n) \\<Rightarrow> Array.nth a)\n                      (d2 - Suc 0) \\<bind>\n                     (\\<lambda>x.\n                         Array.nth a2a x \\<bind>\n                         (\\<lambda>x.\n                             (case a1b of (a, n) \\<Rightarrow> Array.nth a)\n                              (a2 - Suc 0) \\<bind>\n                             (\\<lambda>xa.\n                                 Array.nth a2a xa \\<bind>\n                                 (\\<lambda>xa.\n                                     if prio x \\<le> prio xa then return a1\n                                     else hm_exch_op_impl a1 a2 d2 \\<bind>\n    (\\<lambda>x'g. cf (x'g, d2))))))\n                else return a1)\n     (hm, i)", "apply (simp add: inlines efficient_nat_div2 Let_def \n    cong: if_cong)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "prepare_code_thms hm_swim_op_impl_code"], ["", "schematic_goal hm_sink_opt_impl_code[code]: \"hm_sink_op_impl prio hm i \\<equiv> ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_sink_op_impl prio hm i \\<equiv> ?f", "unfolding hm_sink_op_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap.fixp_fun\n     (\\<lambda>cf (a1, a2).\n         hm_length_impl a1 \\<bind>\n         (\\<lambda>x'a.\n             if 2 * a2 \\<le> x'a\n             then let x'd = 2 * a2\n                  in hm_prio_of_op_impl prio a1 x'd \\<bind>\n                     (\\<lambda>x'f.\n                         (if x'd < x'a\n                          then hm_prio_of_op_impl prio a1 (Suc x'd) \\<bind>\n                               (\\<lambda>x'h.\n                                   return\n                                    (if x'h < x'f then x'd + 1 else x'd))\n                          else return x'd) \\<bind>\n                         (\\<lambda>x'g.\n                             hm_prio_of_op_impl prio a1 x'g \\<bind>\n                             (\\<lambda>x'h.\n                                 hm_prio_of_op_impl prio a1 a2 \\<bind>\n                                 (\\<lambda>x'i.\n                                     if x'h < x'i\n                                     then hm_exch_op_impl a1 a2 x'g \\<bind>\n    (\\<lambda>x'k. cf (x'k, x'g))\n                                     else return a1))))\n             else return a1))\n     (hm, i) \\<equiv>\n    ?f", "apply (rule eq_reflection)"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap.fixp_fun\n     (\\<lambda>cf (a1, a2).\n         hm_length_impl a1 \\<bind>\n         (\\<lambda>x'a.\n             if 2 * a2 \\<le> x'a\n             then let x'd = 2 * a2\n                  in hm_prio_of_op_impl prio a1 x'd \\<bind>\n                     (\\<lambda>x'f.\n                         (if x'd < x'a\n                          then hm_prio_of_op_impl prio a1 (Suc x'd) \\<bind>\n                               (\\<lambda>x'h.\n                                   return\n                                    (if x'h < x'f then x'd + 1 else x'd))\n                          else return x'd) \\<bind>\n                         (\\<lambda>x'g.\n                             hm_prio_of_op_impl prio a1 x'g \\<bind>\n                             (\\<lambda>x'h.\n                                 hm_prio_of_op_impl prio a1 a2 \\<bind>\n                                 (\\<lambda>x'i.\n                                     if x'h < x'i\n                                     then hm_exch_op_impl a1 a2 x'g \\<bind>\n    (\\<lambda>x'k. cf (x'k, x'g))\n                                     else return a1))))\n             else return a1))\n     (hm, i) =\n    ?f", "apply (rule CNV_eqD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. CNV (heap.fixp_fun\n          (\\<lambda>cf (a1, a2).\n              hm_length_impl a1 \\<bind>\n              (\\<lambda>x'a.\n                  if 2 * a2 \\<le> x'a\n                  then let x'd = 2 * a2\n                       in hm_prio_of_op_impl prio a1 x'd \\<bind>\n                          (\\<lambda>x'f.\n                              (if x'd < x'a\n                               then hm_prio_of_op_impl prio a1\n                                     (Suc x'd) \\<bind>\n                                    (\\<lambda>x'h.\n  return (if x'h < x'f then x'd + 1 else x'd))\n                               else return x'd) \\<bind>\n                              (\\<lambda>x'g.\n                                  hm_prio_of_op_impl prio a1 x'g \\<bind>\n                                  (\\<lambda>x'h.\nhm_prio_of_op_impl prio a1 a2 \\<bind>\n(\\<lambda>x'i.\n    if x'h < x'i\n    then hm_exch_op_impl a1 a2 x'g \\<bind> (\\<lambda>x'k. cf (x'k, x'g))\n    else return a1))))\n                  else return a1))\n          (hm, i))\n     ?f", "apply (simp add: inlines \n    cong: if_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. CNV (heap.fixp_fun\n          (\\<lambda>cf (a1, a2).\n              case a1 of\n              (((a, b), a2b), a2a) \\<Rightarrow>\n                if 2 * a2 \\<le> b\n                then let x'd = 2 * a2\n                     in case a1 of\n                        ((a1b, a2b), a2a) \\<Rightarrow>\n                          (case a1b of (a, n) \\<Rightarrow> Array.nth a)\n                           (x'd - Suc 0) \\<bind>\n                          (\\<lambda>x.\n                              Array.nth a2a x \\<bind>\n                              (\\<lambda>x.\n                                  (if x'd < b\n                                   then (case a1b of\n   (a, n) \\<Rightarrow> Array.nth a)\n   x'd \\<bind>\n  (\\<lambda>xa.\n      Array.nth a2a xa \\<bind>\n      (\\<lambda>xa. return (if prio xa < prio x then Suc x'd else x'd)))\n                                   else return x'd) \\<bind>\n                                  (\\<lambda>x'g.\n(case a1b of (a, n) \\<Rightarrow> Array.nth a) (x'g - Suc 0) \\<bind>\n(\\<lambda>x.\n    Array.nth a2a x \\<bind>\n    (\\<lambda>x.\n        (case a1b of (a, n) \\<Rightarrow> Array.nth a) (a2 - Suc 0) \\<bind>\n        (\\<lambda>xa.\n            Array.nth a2a xa \\<bind>\n            (\\<lambda>xa.\n                if prio x < prio xa\n                then hm_exch_op_impl a1 a2 x'g \\<bind>\n                     (\\<lambda>x'k. cf (x'k, x'g))\n                else return a1)))))))\n                else return a1)\n          (hm, i))\n     ?f", "by (rule CNV_I)"], ["", "prepare_code_thms hm_sink_opt_impl_code"], ["", "export_code hm_swim_op_impl in SML_imp module_name Test"], ["", "schematic_goal hm_change_key_opt_impl_code[code]: \"\n  hm_change_key_op_impl prio k v hm \\<equiv> ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_change_key_op_impl prio k v hm \\<equiv> ?f", "unfolding hm_change_key_op_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_index_op_impl hm k \\<bind>\n    (\\<lambda>x'.\n        hm_update_op_impl hm x' v \\<bind>\n        (\\<lambda>x'a. hm_repair_op_impl prio x'a x')) \\<equiv>\n    ?f", "apply (rule eq_reflection)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_index_op_impl hm k \\<bind>\n    (\\<lambda>x'.\n        hm_update_op_impl hm x' v \\<bind>\n        (\\<lambda>x'a. hm_repair_op_impl prio x'a x')) =\n    ?f", "apply (rule CNV_eqD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. CNV (hm_index_op_impl hm k \\<bind>\n         (\\<lambda>x'.\n             hm_update_op_impl hm x' v \\<bind>\n             (\\<lambda>x'a. hm_repair_op_impl prio x'a x')))\n     ?f", "apply (simp add: inlines hm_contains_key_impl_def ial_contains_def\n    hm_change_key_op_impl_def hm_index_op_impl_def hm_update_op_impl_def\n    ial_index_def\n    cong: if_cong split: prod.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b ba x2.\n       hm = (((a, b), ba), x2) \\<longrightarrow>\n       CNV (Array.nth ba k \\<bind>\n            (\\<lambda>x.\n                Array.nth a x \\<bind>\n                (\\<lambda>xa.\n                    Array.upd xa v x2 \\<bind>\n                    (\\<lambda>xa.\n                        hm_repair_op_impl prio (((a, b), ba), xa)\n                         (Suc x)))))\n        ?f", "oops"], ["", "schematic_goal hm_change_key_opt_impl_code[code]: \"\n  hm_change_key_op_impl prio k v hm \\<equiv> case hm of (((a, b), ba), x2) \\<Rightarrow>\n       (do {\n              x \\<leftarrow> Array.nth ba k;\n              xa \\<leftarrow> Array.nth a x;\n              xa \\<leftarrow> Array.upd xa v x2;\n              hm_repair_op_impl prio (((a, b), ba), xa) (Suc x)\n            })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_change_key_op_impl prio k v hm \\<equiv>\n    case hm of\n    (((a, b), ba), x2) \\<Rightarrow>\n      Array.nth ba k \\<bind>\n      (\\<lambda>x.\n          Array.nth a x \\<bind>\n          (\\<lambda>xa.\n              Array.upd xa v x2 \\<bind>\n              (\\<lambda>xa.\n                  hm_repair_op_impl prio (((a, b), ba), xa) (Suc x))))", "unfolding hm_change_key_op_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_index_op_impl hm k \\<bind>\n    (\\<lambda>x'.\n        hm_update_op_impl hm x' v \\<bind>\n        (\\<lambda>x'a. hm_repair_op_impl prio x'a x')) \\<equiv>\n    case hm of\n    (((a, b), ba), x2) \\<Rightarrow>\n      Array.nth ba k \\<bind>\n      (\\<lambda>x.\n          Array.nth a x \\<bind>\n          (\\<lambda>xa.\n              Array.upd xa v x2 \\<bind>\n              (\\<lambda>xa.\n                  hm_repair_op_impl prio (((a, b), ba), xa) (Suc x))))", "apply (rule eq_reflection)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_index_op_impl hm k \\<bind>\n    (\\<lambda>x'.\n        hm_update_op_impl hm x' v \\<bind>\n        (\\<lambda>x'a. hm_repair_op_impl prio x'a x')) =\n    (case hm of\n     (((a, b), ba), x2) \\<Rightarrow>\n       Array.nth ba k \\<bind>\n       (\\<lambda>x.\n           Array.nth a x \\<bind>\n           (\\<lambda>xa.\n               Array.upd xa v x2 \\<bind>\n               (\\<lambda>xa.\n                   hm_repair_op_impl prio (((a, b), ba), xa) (Suc x)))))", "apply (simp add: inlines hm_contains_key_impl_def ial_contains_def\n    hm_change_key_op_impl_def hm_index_op_impl_def hm_update_op_impl_def\n    ial_index_def\n    cong: if_cong split: prod.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "schematic_goal hm_set_opt_impl_code[code]: \"hm_upd_op_impl maxsize prio hm k v \\<equiv> ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_upd_op_impl maxsize prio hm k v \\<equiv> ?f", "unfolding hm_upd_op_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_contains_key_impl maxsize hm v \\<bind>\n    (\\<lambda>x'.\n        if x' then hm_change_key_op_impl prio hm k v\n        else hm_insert_op_impl maxsize prio hm k v) \\<equiv>\n    ?f", "apply (rule eq_reflection)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_contains_key_impl maxsize hm v \\<bind>\n    (\\<lambda>x'.\n        if x' then hm_change_key_op_impl prio hm k v\n        else hm_insert_op_impl maxsize prio hm k v) =\n    ?f", "apply (rule CNV_eqD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. CNV (hm_contains_key_impl maxsize hm v \\<bind>\n         (\\<lambda>x'.\n             if x' then hm_change_key_op_impl prio hm k v\n             else hm_insert_op_impl maxsize prio hm k v))\n     ?f", "apply (simp add: inlines hm_contains_key_impl_def ial_contains_def\n    hm_change_key_op_impl_def hm_index_op_impl_def hm_update_op_impl_def\n    ial_index_def\n    cong: if_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. CNV (case v of\n         (a1, a2) \\<Rightarrow>\n           case a1 of\n           (a1a, a2a) \\<Rightarrow>\n             case v of\n             ((a1c, a2b), a2a) \\<Rightarrow>\n               (if hm < maxsize\n                then Array.nth a2b hm \\<bind>\n                     (\\<lambda>x'a. return (x'a < maxsize))\n                else return False) \\<bind>\n               (\\<lambda>x'.\n                   if x'\n                   then Array.nth a2b hm \\<bind>\n                        (\\<lambda>x.\n                            (case a1a of (a, n) \\<Rightarrow> Array.nth a)\n                             x \\<bind>\n                            (\\<lambda>xa.\n                                Array.upd xa k a2 \\<bind>\n                                (\\<lambda>xa.\n                                    hm_repair_op_impl prio (a1, xa)\n                                     (Suc x))))\n                   else hm_insert_op_impl maxsize prio hm k v))\n     ?f", "by (rule CNV_I)"], ["", "schematic_goal hm_pop_min_opt_impl_code[code]: \"hm_pop_min_op_impl prio hm \\<equiv> ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_pop_min_op_impl prio hm \\<equiv> ?f", "unfolding hm_pop_min_op_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_key_of_op_impl hm 1 \\<bind>\n    (\\<lambda>x'.\n        hm_the_lookup_op_impl hm x' \\<bind>\n        (\\<lambda>x'a.\n            hm_length_impl hm \\<bind>\n            (\\<lambda>x'b.\n                hm_exch_op_impl hm 1 x'b \\<bind>\n                (\\<lambda>x'd.\n                    hm_butlast_op_impl x'd \\<bind>\n                    (\\<lambda>x'e.\n                        if x'b \\<noteq> 1\n                        then hm_sink_op_impl prio x'e 1 \\<bind>\n                             (\\<lambda>x'g. return ((x', x'a), x'g))\n                        else return ((x', x'a), x'e)))))) \\<equiv>\n    ?f", "apply (rule eq_reflection)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_key_of_op_impl hm 1 \\<bind>\n    (\\<lambda>x'.\n        hm_the_lookup_op_impl hm x' \\<bind>\n        (\\<lambda>x'a.\n            hm_length_impl hm \\<bind>\n            (\\<lambda>x'b.\n                hm_exch_op_impl hm 1 x'b \\<bind>\n                (\\<lambda>x'd.\n                    hm_butlast_op_impl x'd \\<bind>\n                    (\\<lambda>x'e.\n                        if x'b \\<noteq> 1\n                        then hm_sink_op_impl prio x'e 1 \\<bind>\n                             (\\<lambda>x'g. return ((x', x'a), x'g))\n                        else return ((x', x'a), x'e)))))) =\n    ?f", "apply (rule CNV_eqD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. CNV (hm_key_of_op_impl hm 1 \\<bind>\n         (\\<lambda>x'.\n             hm_the_lookup_op_impl hm x' \\<bind>\n             (\\<lambda>x'a.\n                 hm_length_impl hm \\<bind>\n                 (\\<lambda>x'b.\n                     hm_exch_op_impl hm 1 x'b \\<bind>\n                     (\\<lambda>x'd.\n                         hm_butlast_op_impl x'd \\<bind>\n                         (\\<lambda>x'e.\n                             if x'b \\<noteq> 1\n                             then hm_sink_op_impl prio x'e 1 \\<bind>\n                                  (\\<lambda>x'g. return ((x', x'a), x'g))\n                             else return ((x', x'a), x'e)))))))\n     ?f", "apply (simp add: inlines hm_contains_key_impl_def ial_contains_def\n    hm_change_key_op_impl_def hm_index_op_impl_def hm_update_op_impl_def\n    hm_butlast_op_impl_def ial_butlast_def\n    ial_index_def\n    cong: if_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. CNV (case hm of\n         (((a, b), a2a), a2) \\<Rightarrow>\n           case hm of\n           ((a1a, a2a), a2) \\<Rightarrow>\n             (case a1a of (a, n) \\<Rightarrow> Array.nth a) 0 \\<bind>\n             (\\<lambda>x'.\n                 Array.nth a2 x' \\<bind>\n                 (\\<lambda>x'a.\n                     hm_exch_op_impl hm (Suc 0) b \\<bind>\n                     (\\<lambda>(a1, a2).\n                         case a1 of\n                         (a1, a2a) \\<Rightarrow>\n                           case a1 of\n                           (a, ba) \\<Rightarrow>\n                             (case a1 of (a, n) \\<Rightarrow> Array.nth a)\n                              (ba - Suc 0) \\<bind>\n                             (\\<lambda>x.\n                                 marl_butlast a1 \\<bind>\n                                 (\\<lambda>xa.\n                                     Array.len a2a \\<bind>\n                                     (\\<lambda>xaa.\n   Array.upd x xaa a2a \\<bind>\n   (\\<lambda>x.\n       if b = Suc 0 then return ((x', x'a), (xa, x), a2)\n       else hm_sink_op_impl prio ((xa, x), a2) (Suc 0) \\<bind>\n            (\\<lambda>x'g. return ((x', x'a), x'g))))))))))\n     ?f", "by (rule CNV_I)"], ["", "end"], ["", "export_code \n  hm_empty_op_impl \n  hm_insert_op_impl\n  hm_is_empty_op_impl\n  hm_lookup_op_impl\n  hm_contains_key_impl\n  hm_decrease_key_op_impl\n  hm_increase_key_op_impl\n  hm_change_key_op_impl\n  hm_upd_op_impl\n  hm_pop_min_op_impl\n  hm_remove_op_impl\n  hm_peek_min_op_impl\n  checking SML_imp"], ["", "end"]]}