{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/Examples/Sepref_WGraph.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemma \"\n    < is_graph n R G Gi * \\<up>(v\\<in>nodes G) > \n      succi Gi v \n    < \\<lambda>r. is_graph n R G Gi * \\<up>((r,succ G v)\\<in>\\<langle>R \\<times>\\<^sub>r node_rel n\\<rangle>list_set_rel) >\"", "lemma (in valid_graph) succ_no_node_empty: \"v\\<notin>V \\<Longrightarrow> succ G v = {}\"", "lemma [sepref_fr_rules]: \" \n    hn_refine \n      (hn_ctxt (is_graph n R) G Gi * hn_ctxt (node_assn n) v vi) \n      (succi Gi vi) \n      (hn_ctxt (is_graph n R) G Gi * hn_ctxt (node_assn n) v vi) \n      (pure (\\<langle>R \\<times>\\<^sub>r node_rel n\\<rangle>list_set_rel))\n      (RETURN$(succ$G$v))\"", "lemma node_list_rel_id: \"\\<forall>x\\<in>set l. x<n \\<Longrightarrow> (l,l)\\<in>\\<langle>node_rel n\\<rangle>list_rel\"", "lemma [sepref_fr_rules]: \"hn_refine \n    (hn_ctxt (is_graph n R) G Gi) \n    (nodes_impl Gi) \n    (hn_ctxt (is_graph n R) G Gi) \n    (pure (\\<langle>node_rel n\\<rangle>list_set_rel))\n    (RETURN$(nodes$G))\""], "translations": [["", "lemma \"\n    < is_graph n R G Gi * \\<up>(v\\<in>nodes G) > \n      succi Gi v \n    < \\<lambda>r. is_graph n R G Gi * \\<up>((r,succ G v)\\<in>\\<langle>R \\<times>\\<^sub>r node_rel n\\<rangle>list_set_rel) >\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_graph n R G Gi * \\<up> (v \\<in> nodes G)> succi Gi v\n    <\\<lambda>r.\n        is_graph n R G Gi *\n        \\<up>\n         ((r, succ G v)\n          \\<in> \\<langle>R \\<times>\\<^sub>r nbn_rel n\\<rangle>list_set_rel)>", "unfolding is_graph_def succi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <(\\<exists>\\<^sub>Al.\n         Gi \\<mapsto>\\<^sub>a l *\n         \\<up>\n          (valid_graph G \\<and>\n           n = length l \\<and>\n           nodes G = {0..<length l} \\<and>\n           (\\<forall>v\\<in>nodes G.\n               (l ! v, succ G v)\n               \\<in> \\<langle>R \\<times>\\<^sub>r\n                              nbn_rel (length l)\\<rangle>list_set_rel))) *\n     \\<up> (v \\<in> nodes G)>\n    Array.len Gi \\<bind>\n    (\\<lambda>l. if v < l then Array.nth Gi v \\<bind> return else return [])\n    <\\<lambda>r.\n        (\\<exists>\\<^sub>Al.\n            Gi \\<mapsto>\\<^sub>a l *\n            \\<up>\n             (valid_graph G \\<and>\n              n = length l \\<and>\n              nodes G = {0..<length l} \\<and>\n              (\\<forall>v\\<in>nodes G.\n                  (l ! v, succ G v)\n                  \\<in> \\<langle>R \\<times>\\<^sub>r\n                                 nbn_rel\n                                  (length l)\\<rangle>list_set_rel))) *\n        \\<up>\n         ((r, succ G v)\n          \\<in> \\<langle>R \\<times>\\<^sub>r nbn_rel n\\<rangle>list_set_rel)>", "by sep_auto"], ["", "lemma (in valid_graph) succ_no_node_empty: \"v\\<notin>V \\<Longrightarrow> succ G v = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<notin> V \\<Longrightarrow> succ G v = {}", "unfolding succ_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<notin> V \\<Longrightarrow> {(w, v'). (v, w, v') \\<in> E} = {}", "using E_valid"], ["proof (prove)\nusing this:\n  fst ` E \\<subseteq> V\n  snd ` snd ` E \\<subseteq> V\n\ngoal (1 subgoal):\n 1. v \\<notin> V \\<Longrightarrow> {(w, v'). (v, w, v') \\<in> E} = {}", "by auto"], ["", "lemma [sepref_fr_rules]: \" \n    hn_refine \n      (hn_ctxt (is_graph n R) G Gi * hn_ctxt (node_assn n) v vi) \n      (succi Gi vi) \n      (hn_ctxt (is_graph n R) G Gi * hn_ctxt (node_assn n) v vi) \n      (pure (\\<langle>R \\<times>\\<^sub>r node_rel n\\<rangle>list_set_rel))\n      (RETURN$(succ$G$v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt (is_graph n R) G Gi * hn_ctxt (nbn_assn n) v vi)\n     (succi Gi vi) (hn_ctxt (is_graph n R) G Gi * hn_ctxt (nbn_assn n) v vi)\n     (pure (\\<langle>R \\<times>\\<^sub>r nbn_rel n\\<rangle>list_set_rel))\n     (RETURN $ (succ $ G $ v))", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (RETURN $ (succ $ G $ v)) \\<Longrightarrow>\n    <hn_ctxt (is_graph n R) G Gi *\n     hn_ctxt (nbn_assn n) v\n      vi> succi Gi\n           vi <\\<lambda>r.\n                  hn_ctxt (is_graph n R) G Gi * hn_ctxt (nbn_assn n) v vi *\n                  (\\<exists>\\<^sub>Ax.\n                      pure\n                       (\\<langle>R \\<times>\\<^sub>r\n                                 nbn_rel n\\<rangle>list_set_rel)\n                       x r *\n                      \\<up>\n                       (RETURN x \\<le> RETURN $ (succ $ G $ v)))>\\<^sub>t", "unfolding hn_ctxt_def pure_def is_graph_def succi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (RETURN $ (succ $ G $ v)) \\<Longrightarrow>\n    <(\\<exists>\\<^sub>Al.\n         Gi \\<mapsto>\\<^sub>a l *\n         \\<up>\n          (valid_graph G \\<and>\n           n = length l \\<and>\n           nodes G = {0..<length l} \\<and>\n           (\\<forall>v\\<in>nodes G.\n               (l ! v, succ G v)\n               \\<in> \\<langle>R \\<times>\\<^sub>r\n                              nbn_rel (length l)\\<rangle>list_set_rel))) *\n     b_assn (\\<lambda>a c. \\<up> ((c, a) \\<in> nat_rel)) (\\<lambda>x. x < n)\n      v vi> Array.len Gi \\<bind>\n            (\\<lambda>l.\n                if vi < l then Array.nth Gi vi \\<bind> return\n                else return\n                      []) <\\<lambda>r.\n                              (\\<exists>\\<^sub>Al.\n                                  Gi \\<mapsto>\\<^sub>a l *\n                                  \\<up>\n                                   (valid_graph G \\<and>\n                                    n = length l \\<and>\n                                    nodes G = {0..<length l} \\<and>\n                                    (\\<forall>v\\<in>nodes G.\n  (l ! v, succ G v)\n  \\<in> \\<langle>R \\<times>\\<^sub>r\n                 nbn_rel (length l)\\<rangle>list_set_rel))) *\n                              b_assn\n                               (\\<lambda>a c. \\<up> ((c, a) \\<in> nat_rel))\n                               (\\<lambda>x. x < n) v vi *\n                              (\\<exists>\\<^sub>Ax.\n                                  \\<up>\n                                   ((r, x)\n                                    \\<in> \\<langle>R \\<times>\\<^sub>r\n             nbn_rel n\\<rangle>list_set_rel) *\n                                  \\<up>\n                                   (RETURN x\n                                    \\<le> RETURN $ (succ $ G $ v)))>\\<^sub>t", "by (sep_auto simp: valid_graph.succ_no_node_empty list_set_autoref_empty)"], ["", "definition nodes_impl :: \"'w::heap graph_impl \\<Rightarrow> nat list Heap\"\n    where \"nodes_impl Gi \\<equiv> do {\n    l \\<leftarrow> Array.len Gi;\n    return [0..<l]\n  }\""], ["", "lemma node_list_rel_id: \"\\<forall>x\\<in>set l. x<n \\<Longrightarrow> (l,l)\\<in>\\<langle>node_rel n\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set l. x < n \\<Longrightarrow>\n    (l, l) \\<in> \\<langle>nbn_rel n\\<rangle>list_rel", "by (induction l) auto"], ["", "lemma [sepref_fr_rules]: \"hn_refine \n    (hn_ctxt (is_graph n R) G Gi) \n    (nodes_impl Gi) \n    (hn_ctxt (is_graph n R) G Gi) \n    (pure (\\<langle>node_rel n\\<rangle>list_set_rel))\n    (RETURN$(nodes$G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt (is_graph n R) G Gi) (nodes_impl Gi)\n     (hn_ctxt (is_graph n R) G Gi)\n     (pure (\\<langle>nbn_rel n\\<rangle>list_set_rel)) (RETURN $ (nodes $ G))", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (RETURN $ (nodes $ G)) \\<Longrightarrow>\n    <hn_ctxt (is_graph n R) G\n      Gi> nodes_impl\n           Gi <\\<lambda>r.\n                  hn_ctxt (is_graph n R) G Gi *\n                  (\\<exists>\\<^sub>Ax.\n                      pure (\\<langle>nbn_rel n\\<rangle>list_set_rel) x r *\n                      \\<up> (RETURN x \\<le> RETURN $ (nodes $ G)))>\\<^sub>t", "unfolding hn_ctxt_def pure_def is_graph_def nodes_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (RETURN $ (nodes $ G)) \\<Longrightarrow>\n    <\\<exists>\\<^sub>Al.\n        Gi \\<mapsto>\\<^sub>a l *\n        \\<up>\n         (valid_graph G \\<and>\n          n = length l \\<and>\n          nodes G = {0..<length l} \\<and>\n          (\\<forall>v\\<in>nodes G.\n              (l ! v, succ G v)\n              \\<in> \\<langle>R \\<times>\\<^sub>r\n                             nbn_rel\n                              (length\n                                l)\\<rangle>list_set_rel))> Array.len\n                      Gi \\<bind>\n                     (\\<lambda>l.\n                         return\n                          [0..<\n                           l]) <\\<lambda>r.\n                                   (\\<exists>\\<^sub>Al.\n Gi \\<mapsto>\\<^sub>a l *\n \\<up>\n  (valid_graph G \\<and>\n   n = length l \\<and>\n   nodes G = {0..<length l} \\<and>\n   (\\<forall>v\\<in>nodes G.\n       (l ! v, succ G v)\n       \\<in> \\<langle>R \\<times>\\<^sub>r\n                      nbn_rel (length l)\\<rangle>list_set_rel))) *\n                                   (\\<exists>\\<^sub>Ax.\n \\<up> ((r, x) \\<in> \\<langle>nbn_rel n\\<rangle>list_set_rel) *\n \\<up> (RETURN x \\<le> RETURN $ (nodes $ G)))>\\<^sub>t", "apply (sep_auto simp: list_set_rel_def br_def intro!: relcompI node_list_rel_id)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "sepref_register succ nodes"], ["", "definition cr_graph \n    :: \"nat \\<Rightarrow> (nat \\<times> nat \\<times> 'w) list \\<Rightarrow> 'w::heap graph_impl Heap\"\n  where\n    \"cr_graph numV Es \\<equiv> do {\n      a \\<leftarrow> Array.new numV [];\n      a \\<leftarrow> imp_nfoldli Es (\\<lambda>_. return True) (\\<lambda>(u,v,w) a. do {\n        l \\<leftarrow> Array.nth a u;\n        let l = (w,v)#l;\n        a \\<leftarrow> Array.upd u l a;\n        return a\n      }) a;\n      return a\n    }\""], ["", "export_code cr_graph checking SML_imp"], ["", "end"]]}