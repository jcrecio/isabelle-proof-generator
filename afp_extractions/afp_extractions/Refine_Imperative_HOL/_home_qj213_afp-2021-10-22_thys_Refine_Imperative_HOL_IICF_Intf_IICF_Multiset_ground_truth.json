{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/IICF/Intf/IICF_Multiset.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemma rel_mset_Plus_gen: \n  assumes \"rel_mset A m m'\"\n  assumes \"rel_mset A n n'\"\n  shows \"rel_mset A (m+n) (m'+n')\"", "lemma rel_mset_single:\n  assumes \"A x y\"\n  shows \"rel_mset A {#x#} {#y#}\"", "lemma rel_mset_Minus:\n  assumes BIU: \"bi_unique A\"\n  shows \"\\<lbrakk> rel_mset A m n; A x y \\<rbrakk> \\<Longrightarrow> rel_mset A (m-{#x#}) (n-{#y#})\"", "lemma rel_mset_Minus_gen: \n  assumes BIU: \"bi_unique A\"\n  assumes \"rel_mset A m m'\"\n  assumes \"rel_mset A n n'\"\n  shows \"rel_mset A (m-n) (m'-n')\"", "lemma pcr_count:\n  assumes \"bi_unique A\"\n  shows \"rel_fun (rel_mset A) (rel_fun A (=)) count count\"", "lemma rel2p_mset[rel2p]: \"rel2p (\\<langle>A\\<rangle>mset_rel) = rel_mset (rel2p A)\"", "lemma p2re_mset[p2rel]: \"p2rel (rel_mset A) = \\<langle>p2rel A\\<rangle>mset_rel\"", "lemma mset_rel_empty[simp]: \n  \"(a,{#})\\<in>\\<langle>A\\<rangle>mset_rel \\<longleftrightarrow> a={#}\"\n  \"({#},b)\\<in>\\<langle>A\\<rangle>mset_rel \\<longleftrightarrow> b={#}\"", "lemma param_mset_empty[param]: \"({#},{#}) \\<in> \\<langle>A\\<rangle>mset_rel\"", "lemma param_mset_Plus[param]: \"((+),(+))\\<in>\\<langle>A\\<rangle>mset_rel \\<rightarrow> \\<langle>A\\<rangle>mset_rel \\<rightarrow> \\<langle>A\\<rangle>mset_rel\"", "lemma param_mset_add[param]: \"(add_mset, add_mset) \\<in> A \\<rightarrow> \\<langle>A\\<rangle>mset_rel \\<rightarrow> \\<langle>A\\<rangle>mset_rel\"", "lemma param_mset_minus[param]: \"\\<lbrakk>single_valued A; single_valued (A\\<inverse>)\\<rbrakk> \n  \\<Longrightarrow> ((-), (-)) \\<in> \\<langle>A\\<rangle>mset_rel \\<rightarrow> \\<langle>A\\<rangle>mset_rel \\<rightarrow> \\<langle>A\\<rangle>mset_rel\"", "lemma param_count[param]: \"\\<lbrakk>single_valued A; single_valued (A\\<inverse>)\\<rbrakk> \\<Longrightarrow> (count,count)\\<in>\\<langle>A\\<rangle>mset_rel \\<rightarrow> A \\<rightarrow> nat_rel\"", "lemma param_set_mset[param]: \n  shows \"(set_mset, set_mset) \\<in> \\<langle>A\\<rangle>mset_rel \\<rightarrow> \\<langle>A\\<rangle>set_rel\"", "lemma mset_is_empty_param[param]: \"(mset_is_empty,mset_is_empty) \\<in> \\<langle>A\\<rangle>mset_rel \\<rightarrow> bool_rel\"", "lemma [def_pat_rules]:\n  \"{#} \\<equiv> op_mset_empty\"\n  \"add_mset \\<equiv> op_mset_insert\"\n  \"(=) $b${#} \\<equiv> op_mset_is_empty$b\"\n  \"(=) ${#}$b \\<equiv> op_mset_is_empty$b\"\n  \"(+) $a$b \\<equiv> op_mset_plus$a$b\"\n  \"(-) $a$b \\<equiv> op_mset_minus$a$b\"", "lemma [def_pat_rules]:\n  \"(+) $b$(add_mset$x${#}) \\<equiv> op_mset_insert$x$b\"\n  \"(+) $(add_mset$x${#})$b \\<equiv> op_mset_insert$x$b\"\n  \"(-) $b$(add_mset$x${#}) \\<equiv> op_mset_delete$x$b\"\n  \"(<) $0$(count$a$x) \\<equiv> op_mset_contains$x$a\"\n  \"(\\<in>) $x$(set_mset$a) \\<equiv> op_mset_contains$x$a\"", "lemma fold_custom_empty:\n    \"{#} = op_custom_empty\"\n    \"op_mset_empty = op_custom_empty\"\n    \"mop_mset_empty = RETURN op_custom_empty\"", "lemmas custom_hnr[sepref_fr_rules] = customize_hnr_aux[folded op_custom_empty_def]"], "translations": [["", "lemma rel_mset_Plus_gen: \n  assumes \"rel_mset A m m'\"\n  assumes \"rel_mset A n n'\"\n  shows \"rel_mset A (m+n) (m'+n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_mset A (m + n) (m' + n')", "using assms"], ["proof (prove)\nusing this:\n  rel_mset A m m'\n  rel_mset A n n'\n\ngoal (1 subgoal):\n 1. rel_mset A (m + n) (m' + n')", "by induction (auto simp: algebra_simps dest: rel_mset_Plus)"], ["", "lemma rel_mset_single:\n  assumes \"A x y\"\n  shows \"rel_mset A {#x#} {#y#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_mset A {#x#} {#y#}", "unfolding rel_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs ys.\n       mset xs = {#x#} \\<and> mset ys = {#y#} \\<and> list_all2 A xs ys", "apply (rule exI[where x=\"[x]\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ys.\n       mset [x] = {#x#} \\<and> mset ys = {#y#} \\<and> list_all2 A [x] ys", "apply (rule exI[where x=\"[y]\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset [x] = {#x#} \\<and> mset [y] = {#y#} \\<and> list_all2 A [x] [y]", "using assms"], ["proof (prove)\nusing this:\n  A x y\n\ngoal (1 subgoal):\n 1. mset [x] = {#x#} \\<and> mset [y] = {#y#} \\<and> list_all2 A [x] [y]", "by auto"], ["", "lemma rel_mset_Minus:\n  assumes BIU: \"bi_unique A\"\n  shows \"\\<lbrakk> rel_mset A m n; A x y \\<rbrakk> \\<Longrightarrow> rel_mset A (m-{#x#}) (n-{#y#})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rel_mset A m n; A x y\\<rbrakk>\n    \\<Longrightarrow> rel_mset A (m - {#x#}) (n - {#y#})", "unfolding rel_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>xs ys.\n                mset xs = m \\<and> mset ys = n \\<and> list_all2 A xs ys;\n     A x y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs ys.\n                         mset xs = m - {#x#} \\<and>\n                         mset ys = n - {#y#} \\<and> list_all2 A xs ys", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>A x y; m = mset xs; list_all2 A xs ys; n = mset ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa.\n                            mset xsa = mset xs - {#x#} \\<and>\n                            (\\<exists>ysa.\n                                mset ysa = mset ys - {#y#} \\<and>\n                                list_all2 A xsa ysa)", "fix ml nl"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>A x y; m = mset xs; list_all2 A xs ys; n = mset ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa.\n                            mset xsa = mset xs - {#x#} \\<and>\n                            (\\<exists>ysa.\n                                mset ysa = mset ys - {#y#} \\<and>\n                                list_all2 A xsa ysa)", "assume A: \"A x y\""], ["proof (state)\nthis:\n  A x y\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>A x y; m = mset xs; list_all2 A xs ys; n = mset ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa.\n                            mset xsa = mset xs - {#x#} \\<and>\n                            (\\<exists>ysa.\n                                mset ysa = mset ys - {#y#} \\<and>\n                                list_all2 A xsa ysa)", "assume R: \"list_all2 A ml nl\""], ["proof (state)\nthis:\n  list_all2 A ml nl\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>A x y; m = mset xs; list_all2 A xs ys; n = mset ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa.\n                            mset xsa = mset xs - {#x#} \\<and>\n                            (\\<exists>ysa.\n                                mset ysa = mset ys - {#y#} \\<and>\n                                list_all2 A xsa ysa)", "show \"\\<exists>ml'. mset ml' = mset ml - {#x#} \\<and>\n                 (\\<exists>nl'. mset nl' = mset nl - {#y#} \\<and> list_all2 A ml' nl')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ml'.\n       mset ml' = mset ml - {#x#} \\<and>\n       (\\<exists>nl'. mset nl' = mset nl - {#y#} \\<and> list_all2 A ml' nl')", "proof (cases \"x\\<in>set ml\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> set ml \\<Longrightarrow>\n    \\<exists>ml'.\n       mset ml' = mset ml - {#x#} \\<and>\n       (\\<exists>nl'. mset nl' = mset nl - {#y#} \\<and> list_all2 A ml' nl')\n 2. x \\<notin> set ml \\<Longrightarrow>\n    \\<exists>ml'.\n       mset ml' = mset ml - {#x#} \\<and>\n       (\\<exists>nl'. mset nl' = mset nl - {#y#} \\<and> list_all2 A ml' nl')", "case False"], ["proof (state)\nthis:\n  x \\<notin> set ml\n\ngoal (2 subgoals):\n 1. x \\<in> set ml \\<Longrightarrow>\n    \\<exists>ml'.\n       mset ml' = mset ml - {#x#} \\<and>\n       (\\<exists>nl'. mset nl' = mset nl - {#y#} \\<and> list_all2 A ml' nl')\n 2. x \\<notin> set ml \\<Longrightarrow>\n    \\<exists>ml'.\n       mset ml' = mset ml - {#x#} \\<and>\n       (\\<exists>nl'. mset nl' = mset nl - {#y#} \\<and> list_all2 A ml' nl')", "have \"y \\<notin> set nl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<notin> set nl", "using A R"], ["proof (prove)\nusing this:\n  A x y\n  list_all2 A ml nl\n\ngoal (1 subgoal):\n 1. y \\<notin> set nl", "apply (auto simp: in_set_conv_decomp list_all2_append2 list_all2_Cons2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys zs us z zsa.\n       \\<lbrakk>A x y; nl = ys @ y # zs; ml = us @ z # zsa;\n        length us = length ys; length zsa = length zs; list_all2 A us ys;\n        A z y; list_all2 A zsa zs\\<rbrakk>\n       \\<Longrightarrow> False", "using False BIU[unfolded bi_unique_alt_def]"], ["proof (prove)\nusing this:\n  x \\<notin> set ml\n  left_unique A \\<and> right_unique A\n\ngoal (1 subgoal):\n 1. \\<And>ys zs us z zsa.\n       \\<lbrakk>A x y; nl = ys @ y # zs; ml = us @ z # zsa;\n        length us = length ys; length zsa = length zs; list_all2 A us ys;\n        A z y; list_all2 A zsa zs\\<rbrakk>\n       \\<Longrightarrow> False", "apply (auto dest: left_uniqueD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  y \\<notin> set nl\n\ngoal (2 subgoals):\n 1. x \\<in> set ml \\<Longrightarrow>\n    \\<exists>ml'.\n       mset ml' = mset ml - {#x#} \\<and>\n       (\\<exists>nl'. mset nl' = mset nl - {#y#} \\<and> list_all2 A ml' nl')\n 2. x \\<notin> set ml \\<Longrightarrow>\n    \\<exists>ml'.\n       mset ml' = mset ml - {#x#} \\<and>\n       (\\<exists>nl'. mset nl' = mset nl - {#y#} \\<and> list_all2 A ml' nl')", "with False R"], ["proof (chain)\npicking this:\n  x \\<notin> set ml\n  list_all2 A ml nl\n  y \\<notin> set nl", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<notin> set ml\n  list_all2 A ml nl\n  y \\<notin> set nl\n\ngoal (1 subgoal):\n 1. \\<exists>ml'.\n       mset ml' = mset ml - {#x#} \\<and>\n       (\\<exists>nl'. mset nl' = mset nl - {#y#} \\<and> list_all2 A ml' nl')", "by (auto simp: diff_single_trivial in_multiset_in_set)"], ["proof (state)\nthis:\n  \\<exists>ml'.\n     mset ml' = mset ml - {#x#} \\<and>\n     (\\<exists>nl'. mset nl' = mset nl - {#y#} \\<and> list_all2 A ml' nl')\n\ngoal (1 subgoal):\n 1. x \\<in> set ml \\<Longrightarrow>\n    \\<exists>ml'.\n       mset ml' = mset ml - {#x#} \\<and>\n       (\\<exists>nl'. mset nl' = mset nl - {#y#} \\<and> list_all2 A ml' nl')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> set ml \\<Longrightarrow>\n    \\<exists>ml'.\n       mset ml' = mset ml - {#x#} \\<and>\n       (\\<exists>nl'. mset nl' = mset nl - {#y#} \\<and> list_all2 A ml' nl')", "case True"], ["proof (state)\nthis:\n  x \\<in> set ml\n\ngoal (1 subgoal):\n 1. x \\<in> set ml \\<Longrightarrow>\n    \\<exists>ml'.\n       mset ml' = mset ml - {#x#} \\<and>\n       (\\<exists>nl'. mset nl' = mset nl - {#y#} \\<and> list_all2 A ml' nl')", "then"], ["proof (chain)\npicking this:\n  x \\<in> set ml", "obtain ml1 ml2 where [simp]: \"ml=ml1@x#ml2\""], ["proof (prove)\nusing this:\n  x \\<in> set ml\n\ngoal (1 subgoal):\n 1. (\\<And>ml1 ml2.\n        ml = ml1 @ x # ml2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: in_set_conv_decomp)"], ["proof (state)\nthis:\n  ml = ml1 @ x # ml2\n\ngoal (1 subgoal):\n 1. x \\<in> set ml \\<Longrightarrow>\n    \\<exists>ml'.\n       mset ml' = mset ml - {#x#} \\<and>\n       (\\<exists>nl'. mset nl' = mset nl - {#y#} \\<and> list_all2 A ml' nl')", "then"], ["proof (chain)\npicking this:\n  ml = ml1 @ x # ml2", "obtain nl1 nl2 where [simp]: \"nl=nl1@y#nl2\"\n      and LA: \"list_all2 A ml1 nl1\" \"list_all2 A ml2 nl2\""], ["proof (prove)\nusing this:\n  ml = ml1 @ x # ml2\n\ngoal (1 subgoal):\n 1. (\\<And>nl1 nl2.\n        \\<lbrakk>nl = nl1 @ y # nl2; list_all2 A ml1 nl1;\n         list_all2 A ml2 nl2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using A R"], ["proof (prove)\nusing this:\n  ml = ml1 @ x # ml2\n  A x y\n  list_all2 A ml nl\n\ngoal (1 subgoal):\n 1. (\\<And>nl1 nl2.\n        \\<lbrakk>nl = nl1 @ y # nl2; list_all2 A ml1 nl1;\n         list_all2 A ml2 nl2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (auto simp: in_set_conv_decomp list_all2_append1 list_all2_Cons1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>us z zs.\n       \\<lbrakk>\\<And>nl1 nl2.\n                   \\<lbrakk>us @ z # zs = nl1 @ y # nl2;\n                    list_all2 A ml1 nl1; list_all2 A ml2 nl2\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        A x y; nl = us @ z # zs; length us = length ml1;\n        length zs = length ml2; list_all2 A ml1 us; A x z;\n        list_all2 A ml2 zs\\<rbrakk>\n       \\<Longrightarrow> thesis", "using BIU[unfolded bi_unique_alt_def]"], ["proof (prove)\nusing this:\n  left_unique A \\<and> right_unique A\n\ngoal (1 subgoal):\n 1. \\<And>us z zs.\n       \\<lbrakk>\\<And>nl1 nl2.\n                   \\<lbrakk>us @ z # zs = nl1 @ y # nl2;\n                    list_all2 A ml1 nl1; list_all2 A ml2 nl2\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        A x y; nl = us @ z # zs; length us = length ml1;\n        length zs = length ml2; list_all2 A ml1 us; A x z;\n        list_all2 A ml2 zs\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (auto dest: right_uniqueD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  nl = nl1 @ y # nl2\n  list_all2 A ml1 nl1\n  list_all2 A ml2 nl2\n\ngoal (1 subgoal):\n 1. x \\<in> set ml \\<Longrightarrow>\n    \\<exists>ml'.\n       mset ml' = mset ml - {#x#} \\<and>\n       (\\<exists>nl'. mset nl' = mset nl - {#y#} \\<and> list_all2 A ml' nl')", "have \n      \"mset (ml1@ml2) = mset ml - {#x#}\"\n      \"mset (nl1@nl2) = mset nl - {#y#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (ml1 @ ml2) = mset ml - {#x#} &&&\n    mset (nl1 @ nl2) = mset nl - {#y#}", "using R"], ["proof (prove)\nusing this:\n  list_all2 A ml nl\n\ngoal (1 subgoal):\n 1. mset (ml1 @ ml2) = mset ml - {#x#} &&&\n    mset (nl1 @ nl2) = mset nl - {#y#}", "by (auto simp: algebra_simps add_implies_diff union_assoc)"], ["proof (state)\nthis:\n  mset (ml1 @ ml2) = mset ml - {#x#}\n  mset (nl1 @ nl2) = mset nl - {#y#}\n\ngoal (1 subgoal):\n 1. x \\<in> set ml \\<Longrightarrow>\n    \\<exists>ml'.\n       mset ml' = mset ml - {#x#} \\<and>\n       (\\<exists>nl'. mset nl' = mset nl - {#y#} \\<and> list_all2 A ml' nl')", "moreover"], ["proof (state)\nthis:\n  mset (ml1 @ ml2) = mset ml - {#x#}\n  mset (nl1 @ nl2) = mset nl - {#y#}\n\ngoal (1 subgoal):\n 1. x \\<in> set ml \\<Longrightarrow>\n    \\<exists>ml'.\n       mset ml' = mset ml - {#x#} \\<and>\n       (\\<exists>nl'. mset nl' = mset nl - {#y#} \\<and> list_all2 A ml' nl')", "have \"list_all2 A (ml1@ml2) (nl1@nl2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 A (ml1 @ ml2) (nl1 @ nl2)", "by (rule list_all2_appendI) fact+"], ["proof (state)\nthis:\n  list_all2 A (ml1 @ ml2) (nl1 @ nl2)\n\ngoal (1 subgoal):\n 1. x \\<in> set ml \\<Longrightarrow>\n    \\<exists>ml'.\n       mset ml' = mset ml - {#x#} \\<and>\n       (\\<exists>nl'. mset nl' = mset nl - {#y#} \\<and> list_all2 A ml' nl')", "ultimately"], ["proof (chain)\npicking this:\n  mset (ml1 @ ml2) = mset ml - {#x#}\n  mset (nl1 @ nl2) = mset nl - {#y#}\n  list_all2 A (ml1 @ ml2) (nl1 @ nl2)", "show ?thesis"], ["proof (prove)\nusing this:\n  mset (ml1 @ ml2) = mset ml - {#x#}\n  mset (nl1 @ nl2) = mset nl - {#y#}\n  list_all2 A (ml1 @ ml2) (nl1 @ nl2)\n\ngoal (1 subgoal):\n 1. \\<exists>ml'.\n       mset ml' = mset ml - {#x#} \\<and>\n       (\\<exists>nl'. mset nl' = mset nl - {#y#} \\<and> list_all2 A ml' nl')", "by blast"], ["proof (state)\nthis:\n  \\<exists>ml'.\n     mset ml' = mset ml - {#x#} \\<and>\n     (\\<exists>nl'. mset nl' = mset nl - {#y#} \\<and> list_all2 A ml' nl')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ml'.\n     mset ml' = mset ml - {#x#} \\<and>\n     (\\<exists>nl'. mset nl' = mset nl - {#y#} \\<and> list_all2 A ml' nl')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rel_mset_Minus_gen: \n  assumes BIU: \"bi_unique A\"\n  assumes \"rel_mset A m m'\"\n  assumes \"rel_mset A n n'\"\n  shows \"rel_mset A (m-n) (m'-n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_mset A (m - n) (m' - n')", "using assms(3,2)"], ["proof (prove)\nusing this:\n  rel_mset A n n'\n  rel_mset A m m'\n\ngoal (1 subgoal):\n 1. rel_mset A (m - n) (m' - n')", "apply (induction R\\<equiv>A _ _ rule: rel_mset_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. rel_mset A m m' \\<Longrightarrow> rel_mset A (m - {#}) (m' - {#})\n 2. \\<And>a b M N.\n       \\<lbrakk>A a b; rel_mset A M N;\n        rel_mset A m m' \\<Longrightarrow> rel_mset A (m - M) (m' - N);\n        rel_mset A m m'\\<rbrakk>\n       \\<Longrightarrow> rel_mset A (m - add_mset a M) (m' - add_mset b N)", "apply (auto dest: rel_mset_Minus[OF BIU] simp: algebra_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pcr_count:\n  assumes \"bi_unique A\"\n  shows \"rel_fun (rel_mset A) (rel_fun A (=)) count count\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (rel_mset A) (rel_fun A (=)) count count", "apply (intro rel_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_mset A x y; A xa ya\\<rbrakk>\n       \\<Longrightarrow> count x xa = count y ya", "unfolding rel_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>\\<exists>xs ys.\n                   mset xs = x \\<and> mset ys = y \\<and> list_all2 A xs ys;\n        A xa ya\\<rbrakk>\n       \\<Longrightarrow> count x xa = count y ya", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa ya xs ys.\n       \\<lbrakk>A xa ya; list_all2 A xs ys\\<rbrakk>\n       \\<Longrightarrow> count (mset xs) xa = count (mset ys) ya", "subgoal for x y xs ys"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A x y; list_all2 A xs ys\\<rbrakk>\n    \\<Longrightarrow> count (mset xs) x = count (mset ys) y", "apply (rotate_tac,induction xs ys rule: list_all2_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. A x y \\<Longrightarrow> count (mset []) x = count (mset []) y\n 2. \\<And>xa x' ls ls'.\n       \\<lbrakk>A xa x'; list_all2 A ls ls';\n        A x y \\<Longrightarrow> count (mset ls) x = count (mset ls') y;\n        A x y\\<rbrakk>\n       \\<Longrightarrow> count (mset (xa # ls)) x =\n                         count (mset (x' # ls')) y", "using assms"], ["proof (prove)\nusing this:\n  bi_unique A\n\ngoal (2 subgoals):\n 1. A x y \\<Longrightarrow> count (mset []) x = count (mset []) y\n 2. \\<And>xa x' ls ls'.\n       \\<lbrakk>A xa x'; list_all2 A ls ls';\n        A x y \\<Longrightarrow> count (mset ls) x = count (mset ls') y;\n        A x y\\<rbrakk>\n       \\<Longrightarrow> count (mset (xa # ls)) x =\n                         count (mset (x' # ls')) y", "by (auto simp: bi_unique_alt_def left_uniqueD right_uniqueD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Parametricity Setup\\<close>"], ["", "definition [to_relAPP]: \"mset_rel A \\<equiv> p2rel (rel_mset (rel2p A))\""], ["", "lemma rel2p_mset[rel2p]: \"rel2p (\\<langle>A\\<rangle>mset_rel) = rel_mset (rel2p A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel2p (\\<langle>A\\<rangle>mset_rel) = rel_mset (rel2p A)", "by (simp add: mset_rel_def)"], ["", "lemma p2re_mset[p2rel]: \"p2rel (rel_mset A) = \\<langle>p2rel A\\<rangle>mset_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p2rel (rel_mset A) = \\<langle>p2rel A\\<rangle>mset_rel", "by (simp add: mset_rel_def)"], ["", "lemma mset_rel_empty[simp]: \n  \"(a,{#})\\<in>\\<langle>A\\<rangle>mset_rel \\<longleftrightarrow> a={#}\"\n  \"({#},b)\\<in>\\<langle>A\\<rangle>mset_rel \\<longleftrightarrow> b={#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((a, {#}) \\<in> \\<langle>A\\<rangle>mset_rel) = (a = {#}) &&&\n    (({#}, b) \\<in> \\<langle>A\\<rangle>mset_rel) = (b = {#})", "by (auto simp: mset_rel_def p2rel_def rel_mset_def)"], ["", "lemma param_mset_empty[param]: \"({#},{#}) \\<in> \\<langle>A\\<rangle>mset_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({#}, {#}) \\<in> \\<langle>A\\<rangle>mset_rel", "unfolding mset_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ({#}, {#}) \\<in> p2rel (rel_mset (rel2p A))", "apply (simp add: p2rel_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_mset (rel2p A) {#} {#}", "by (rule rel_mset_Zero)"], ["", "lemma param_mset_Plus[param]: \"((+),(+))\\<in>\\<langle>A\\<rangle>mset_rel \\<rightarrow> \\<langle>A\\<rangle>mset_rel \\<rightarrow> \\<langle>A\\<rangle>mset_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((+), (+))\n    \\<in> \\<langle>A\\<rangle>mset_rel \\<rightarrow>\n          \\<langle>A\\<rangle>mset_rel \\<rightarrow>\n          \\<langle>A\\<rangle>mset_rel", "apply (rule rel2pD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel2p\n     (\\<langle>A\\<rangle>mset_rel \\<rightarrow>\n      \\<langle>A\\<rangle>mset_rel \\<rightarrow> \\<langle>A\\<rangle>mset_rel)\n     (+) (+)", "apply (simp add: rel2p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (rel_mset (rel2p A))\n     (rel_fun (rel_mset (rel2p A)) (rel_mset (rel2p A))) (+) (+)", "apply (intro rel_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_mset (rel2p A) x y; rel_mset (rel2p A) xa ya\\<rbrakk>\n       \\<Longrightarrow> rel_mset (rel2p A) (x + xa) (y + ya)", "by (rule rel_mset_Plus_gen)"], ["", "(*lemma param_mset_single[param]: \n  \"(Multiset.single,Multiset.single) \\<in> A \\<rightarrow> \\<langle>A\\<rangle>mset_rel\"\n  apply (rule rel2pD)\n  apply (simp add: rel2p)\n  apply (intro rel_funI)\n  by (rule rel_mset_single)*)"], ["", "lemma param_mset_add[param]: \"(add_mset, add_mset) \\<in> A \\<rightarrow> \\<langle>A\\<rangle>mset_rel \\<rightarrow> \\<langle>A\\<rangle>mset_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (add_mset, add_mset)\n    \\<in> A \\<rightarrow>\n          \\<langle>A\\<rangle>mset_rel \\<rightarrow>\n          \\<langle>A\\<rangle>mset_rel", "apply (rule rel2pD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel2p\n     (A \\<rightarrow>\n      \\<langle>A\\<rangle>mset_rel \\<rightarrow> \\<langle>A\\<rangle>mset_rel)\n     add_mset add_mset", "apply (simp add: rel2p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (rel2p A) (rel_fun (rel_mset (rel2p A)) (rel_mset (rel2p A)))\n     add_mset add_mset", "apply (intro rel_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel2p A x y; rel_mset (rel2p A) xa ya\\<rbrakk>\n       \\<Longrightarrow> rel_mset (rel2p A) (add_mset x xa) (add_mset y ya)", "by (rule rel_mset_Plus)"], ["", "lemma param_mset_minus[param]: \"\\<lbrakk>single_valued A; single_valued (A\\<inverse>)\\<rbrakk> \n  \\<Longrightarrow> ((-), (-)) \\<in> \\<langle>A\\<rangle>mset_rel \\<rightarrow> \\<langle>A\\<rangle>mset_rel \\<rightarrow> \\<langle>A\\<rangle>mset_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued A; single_valued (A\\<inverse>)\\<rbrakk>\n    \\<Longrightarrow> ((-), (-))\n                      \\<in> \\<langle>A\\<rangle>mset_rel \\<rightarrow>\n                            \\<langle>A\\<rangle>mset_rel \\<rightarrow>\n                            \\<langle>A\\<rangle>mset_rel", "apply (rule rel2pD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued A; single_valued (A\\<inverse>)\\<rbrakk>\n    \\<Longrightarrow> rel2p\n                       (\\<langle>A\\<rangle>mset_rel \\<rightarrow>\n                        \\<langle>A\\<rangle>mset_rel \\<rightarrow>\n                        \\<langle>A\\<rangle>mset_rel)\n                       (-) (-)", "apply (simp add: rel2p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued A; single_valued (A\\<inverse>)\\<rbrakk>\n    \\<Longrightarrow> rel_fun (rel_mset (rel2p A))\n                       (rel_fun (rel_mset (rel2p A)) (rel_mset (rel2p A)))\n                       (-) (-)", "apply (intro rel_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>single_valued A; single_valued (A\\<inverse>);\n        rel_mset (rel2p A) x y; rel_mset (rel2p A) xa ya\\<rbrakk>\n       \\<Longrightarrow> rel_mset (rel2p A) (x - xa) (y - ya)", "apply (rule rel_mset_Minus_gen)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>single_valued A; single_valued (A\\<inverse>);\n        rel_mset (rel2p A) x y; rel_mset (rel2p A) xa ya\\<rbrakk>\n       \\<Longrightarrow> bi_unique (rel2p A)\n 2. \\<And>x y xa ya.\n       \\<lbrakk>single_valued A; single_valued (A\\<inverse>);\n        rel_mset (rel2p A) x y; rel_mset (rel2p A) xa ya\\<rbrakk>\n       \\<Longrightarrow> rel_mset (rel2p A) x y\n 3. \\<And>x y xa ya.\n       \\<lbrakk>single_valued A; single_valued (A\\<inverse>);\n        rel_mset (rel2p A) x y; rel_mset (rel2p A) xa ya\\<rbrakk>\n       \\<Longrightarrow> rel_mset (rel2p A) xa ya", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued A; single_valued (A\\<inverse>);\n     rel_mset (rel2p A) x_ y_; rel_mset (rel2p A) xa_ ya_\\<rbrakk>\n    \\<Longrightarrow> bi_unique (rel2p A)", "apply (unfold IS_LEFT_UNIQUE_def[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued A; IS_LEFT_UNIQUE A; rel_mset (rel2p A) x_ y_;\n     rel_mset (rel2p A) xa_ ya_\\<rbrakk>\n    \\<Longrightarrow> bi_unique (rel2p A)", "by (simp add: prop2p bi_unique_alt_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>single_valued A; single_valued (A\\<inverse>);\n        rel_mset (rel2p A) x y; rel_mset (rel2p A) xa ya\\<rbrakk>\n       \\<Longrightarrow> rel_mset (rel2p A) x y\n 2. \\<And>x y xa ya.\n       \\<lbrakk>single_valued A; single_valued (A\\<inverse>);\n        rel_mset (rel2p A) x y; rel_mset (rel2p A) xa ya\\<rbrakk>\n       \\<Longrightarrow> rel_mset (rel2p A) xa ya", "apply (simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>single_valued A; single_valued (A\\<inverse>);\n        rel_mset (rel2p A) x y; rel_mset (rel2p A) xa ya\\<rbrakk>\n       \\<Longrightarrow> rel_mset (rel2p A) xa ya", "apply (simp; fail)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma param_count[param]: \"\\<lbrakk>single_valued A; single_valued (A\\<inverse>)\\<rbrakk> \\<Longrightarrow> (count,count)\\<in>\\<langle>A\\<rangle>mset_rel \\<rightarrow> A \\<rightarrow> nat_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued A; single_valued (A\\<inverse>)\\<rbrakk>\n    \\<Longrightarrow> (count, count)\n                      \\<in> \\<langle>A\\<rangle>mset_rel \\<rightarrow>\n                            A \\<rightarrow> nat_rel", "apply (rule rel2pD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued A; single_valued (A\\<inverse>)\\<rbrakk>\n    \\<Longrightarrow> rel2p\n                       (\\<langle>A\\<rangle>mset_rel \\<rightarrow>\n                        A \\<rightarrow> nat_rel)\n                       count count", "apply (simp add: prop2p rel2p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>right_unique (rel2p A); left_unique (rel2p A)\\<rbrakk>\n    \\<Longrightarrow> rel_fun (rel_mset (rel2p A)) (rel_fun (rel2p A) (=))\n                       count count", "apply (rule pcr_count)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>right_unique (rel2p A); left_unique (rel2p A)\\<rbrakk>\n    \\<Longrightarrow> bi_unique (rel2p A)", "apply (simp add: bi_unique_alt_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma param_set_mset[param]: \n  shows \"(set_mset, set_mset) \\<in> \\<langle>A\\<rangle>mset_rel \\<rightarrow> \\<langle>A\\<rangle>set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set_mset, set_mset)\n    \\<in> \\<langle>A\\<rangle>mset_rel \\<rightarrow>\n          \\<langle>A\\<rangle>set_rel", "apply (rule rel2pD; simp add: rel2p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (rel_mset (rel2p A)) (rel_set (rel2p A)) set_mset set_mset", "by (rule multiset.set_transfer)"], ["", "definition [simp]: \"mset_is_empty m \\<equiv> m = {#}\""], ["", "lemma mset_is_empty_param[param]: \"(mset_is_empty,mset_is_empty) \\<in> \\<langle>A\\<rangle>mset_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mset_is_empty, mset_is_empty)\n    \\<in> \\<langle>A\\<rangle>mset_rel \\<rightarrow> bool_rel", "unfolding mset_rel_def mset_is_empty_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>m. m = {#}, \\<lambda>m. m = {#})\n    \\<in> p2rel (rel_mset (rel2p A)) \\<rightarrow> bool_rel", "by (auto simp: p2rel_def rel_mset_def intro: nres_relI)"], ["", "subsection \\<open>Operations\\<close>"], ["", "sepref_decl_op mset_empty: \"{#}\" :: \"\\<langle>A\\<rangle>mset_rel\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_op mset_is_empty: \"\\<lambda>m. m={#}\" :: \"\\<langle>A\\<rangle>mset_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN \\<circ> (\\<lambda>m. m = {#}),\n     RETURN \\<circ> (\\<lambda>m. m = {#}))\n    \\<in> \\<langle>A\\<rangle>mset_rel \\<rightarrow>\\<^sub>f \\<langle>bool_rel\\<rangle>nres_rel", "unfolding mset_is_empty_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN \\<circ> mset_is_empty, RETURN \\<circ> mset_is_empty)\n    \\<in> \\<langle>A\\<rangle>mset_rel \\<rightarrow>\\<^sub>f \\<langle>bool_rel\\<rangle>nres_rel", "apply (rule frefI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> \\<langle>A\\<rangle>mset_rel\\<rbrakk>\n       \\<Longrightarrow> ((RETURN \\<circ> mset_is_empty) x,\n                          (RETURN \\<circ> mset_is_empty) y)\n                         \\<in> \\<langle>bool_rel\\<rangle>nres_rel", "by parametricity"], ["", "(*sepref_decl_op mset_single: \"\\<lambda>m. {#m#}\" :: \"A \\<rightarrow> \\<langle>A\\<rangle>mset_rel\" .*)"], ["", "sepref_decl_op mset_insert: \"add_mset\" :: \"A \\<rightarrow> \\<langle>A\\<rangle>mset_rel \\<rightarrow> \\<langle>A\\<rangle>mset_rel\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_op mset_delete: \"\\<lambda>x m. m - {#x#}\" :: \"A \\<rightarrow> \\<langle>A\\<rangle>mset_rel \\<rightarrow> \\<langle>A\\<rangle>mset_rel\"\n    where \"single_valued A\" \"single_valued (A\\<inverse>)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_op mset_plus: \"(+)::_ multiset \\<Rightarrow> _\" :: \"\\<langle>A\\<rangle>mset_rel \\<rightarrow> \\<langle>A\\<rangle>mset_rel \\<rightarrow> \\<langle>A\\<rangle>mset_rel\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_op mset_minus: \"(-)::_ multiset \\<Rightarrow> _\" :: \"\\<langle>A\\<rangle>mset_rel \\<rightarrow> \\<langle>A\\<rangle>mset_rel \\<rightarrow> \\<langle>A\\<rangle>mset_rel\" \n    where \"single_valued A\" \"single_valued (A\\<inverse>)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_op mset_contains: \"(\\<in>#)\" :: \"A \\<rightarrow> \\<langle>A\\<rangle>mset_rel \\<rightarrow> bool_rel\" \n    where \"single_valued A\" \"single_valued (A\\<inverse>)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_op mset_count: \"\\<lambda>x y. count y x\" :: \"A \\<rightarrow> \\<langle>A\\<rangle>mset_rel \\<rightarrow> nat_rel\" \n    where \"single_valued A\" \"single_valued (A\\<inverse>)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_op mset_pick: \"\\<lambda>m. SPEC (\\<lambda>(x,m'). m = {#x#} + m')\" :: \n    \"[\\<lambda>m. m\\<noteq>{#}]\\<^sub>f \\<langle>A\\<rangle>mset_rel \\<rightarrow> A \\<times>\\<^sub>r \\<langle>A\\<rangle>mset_rel\""], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>m. SPEC (\\<lambda>(x, m'). m = {#x#} + m'),\n     \\<lambda>m. SPEC (\\<lambda>(x, m'). m = {#x#} + m'))\n    \\<in> [\\<lambda>m.\n              m \\<noteq>\n              {#}]\\<^sub>f \\<langle>A\\<rangle>mset_rel \\<rightarrow> \\<langle>A \\<times>\\<^sub>r\n  \\<langle>A\\<rangle>mset_rel\\<rangle>nres_rel\n 2. (\\<lambda>m. m \\<noteq> {#}, \\<lambda>m. m \\<noteq> {#})\n    \\<in> \\<langle>A\\<rangle>mset_rel \\<rightarrow> bool_rel", "unfolding mset_is_empty_def[symmetric]"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>m. SPEC (\\<lambda>(x, m'). m = {#x#} + m'),\n     \\<lambda>m. SPEC (\\<lambda>(x, m'). m = {#x#} + m'))\n    \\<in> [\\<lambda>m.\n              \\<not> mset_is_empty\n                      m]\\<^sub>f \\<langle>A\\<rangle>mset_rel \\<rightarrow> \\<langle>A \\<times>\\<^sub>r\n        \\<langle>A\\<rangle>mset_rel\\<rangle>nres_rel\n 2. (\\<lambda>m. \\<not> mset_is_empty m, \\<lambda>m. \\<not> mset_is_empty m)\n    \\<in> \\<langle>A\\<rangle>mset_rel \\<rightarrow> bool_rel", "apply (intro frefI nres_relI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<not> mset_is_empty y;\n        (x, y) \\<in> \\<langle>A\\<rangle>mset_rel\\<rbrakk>\n       \\<Longrightarrow> SPEC (\\<lambda>(xa, m'). x = {#xa#} + m')\n                         \\<le> \\<Down>\n                                (A \\<times>\\<^sub>r\n                                 \\<langle>A\\<rangle>mset_rel)\n                                (SPEC (\\<lambda>(x, m'). y = {#x#} + m'))\n 2. (\\<lambda>m. \\<not> mset_is_empty m, \\<lambda>m. \\<not> mset_is_empty m)\n    \\<in> \\<langle>A\\<rangle>mset_rel \\<rightarrow> bool_rel", "apply (refine_vcg SPEC_refine)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y xa.\n       \\<lbrakk>\\<not> mset_is_empty y;\n        (x, y) \\<in> \\<langle>A\\<rangle>mset_rel;\n        case xa of (xa, m') \\<Rightarrow> x = {#xa#} + m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x'.\n                            (xa, x')\n                            \\<in> A \\<times>\\<^sub>r\n                                  \\<langle>A\\<rangle>mset_rel \\<and>\n                            (case x' of\n                             (x, m') \\<Rightarrow> y = {#x#} + m')\n 2. (\\<lambda>m. \\<not> mset_is_empty m, \\<lambda>m. \\<not> mset_is_empty m)\n    \\<in> \\<langle>A\\<rangle>mset_rel \\<rightarrow> bool_rel", "apply1 (rule ccontr; clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y a b.\n       \\<lbrakk>y \\<noteq> {#};\n        (add_mset a b, y) \\<in> \\<langle>A\\<rangle>mset_rel;\n        \\<forall>aa ba.\n           (a, aa) \\<in> A \\<and>\n           (b, ba) \\<in> \\<langle>A\\<rangle>mset_rel \\<longrightarrow>\n           y \\<noteq> add_mset aa ba\\<rbrakk>\n       \\<Longrightarrow> False\n 2. (\\<lambda>m. \\<not> mset_is_empty m, \\<lambda>m. \\<not> mset_is_empty m)\n    \\<in> \\<langle>A\\<rangle>mset_rel \\<rightarrow> bool_rel", "applyS (metis msed_rel_invL rel2p_def rel2p_mset union_ac(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>m. \\<not> mset_is_empty m, \\<lambda>m. \\<not> mset_is_empty m)\n    \\<in> \\<langle>A\\<rangle>mset_rel \\<rightarrow> bool_rel", "applyS parametricity"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Patterns\\<close>"], ["", "lemma [def_pat_rules]:\n  \"{#} \\<equiv> op_mset_empty\"\n  \"add_mset \\<equiv> op_mset_insert\"\n  \"(=) $b${#} \\<equiv> op_mset_is_empty$b\"\n  \"(=) ${#}$b \\<equiv> op_mset_is_empty$b\"\n  \"(+) $a$b \\<equiv> op_mset_plus$a$b\"\n  \"(-) $a$b \\<equiv> op_mset_minus$a$b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (({#} \\<equiv> op_mset_empty) &&&\n     (add_mset \\<equiv> op_mset_insert) &&&\n     (=) $ b $ {#} \\<equiv> op_mset_is_empty $ b) &&&\n    ((=) $ {#} $ b \\<equiv> op_mset_is_empty $ b) &&&\n    ((+) $ a $ b \\<equiv> op_mset_plus $ a $ b) &&&\n    (-) $ a $ b \\<equiv> op_mset_minus $ a $ b", "by (auto intro!: eq_reflection simp: algebra_simps)"], ["", "lemma [def_pat_rules]:\n  \"(+) $b$(add_mset$x${#}) \\<equiv> op_mset_insert$x$b\"\n  \"(+) $(add_mset$x${#})$b \\<equiv> op_mset_insert$x$b\"\n  \"(-) $b$(add_mset$x${#}) \\<equiv> op_mset_delete$x$b\"\n  \"(<) $0$(count$a$x) \\<equiv> op_mset_contains$x$a\"\n  \"(\\<in>) $x$(set_mset$a) \\<equiv> op_mset_contains$x$a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((+) $ b $ (add_mset $ x $ {#}) \\<equiv> op_mset_insert $ x $ b) &&&\n     (+) $ (add_mset $ x $ {#}) $ b \\<equiv> op_mset_insert $ x $ b) &&&\n    ((-) $ b $ (add_mset $ x $ {#}) \\<equiv> op_mset_delete $ x $ b) &&&\n    ((<) $ 0 $ (count $ a $ x) \\<equiv> op_mset_contains $ x $ a) &&&\n    (\\<in>) $ x $ (set_mset $ a) \\<equiv> op_mset_contains $ x $ a", "by (auto intro!: eq_reflection simp: algebra_simps)"], ["", "locale mset_custom_empty = \n  fixes rel empty and op_custom_empty :: \"'a multiset\"\n  assumes customize_hnr_aux: \"(uncurry0 empty,uncurry0 (RETURN (op_mset_empty::'a multiset))) \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a rel\"\n  assumes op_custom_empty_def: \"op_custom_empty = op_mset_empty\"\nbegin"], ["", "sepref_register op_custom_empty :: \"'ax multiset\""], ["", "lemma fold_custom_empty:\n    \"{#} = op_custom_empty\"\n    \"op_mset_empty = op_custom_empty\"\n    \"mop_mset_empty = RETURN op_custom_empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#} = op_custom_empty &&&\n    op_mset_empty = op_custom_empty &&&\n    mop_mset_empty = RETURN op_custom_empty", "unfolding op_custom_empty_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {#} = op_mset_empty &&&\n    op_mset_empty = op_mset_empty &&& mop_mset_empty = RETURN op_mset_empty", "by simp_all"], ["", "lemmas custom_hnr[sepref_fr_rules] = customize_hnr_aux[folded op_custom_empty_def]"], ["", "end"], ["", "end"]]}