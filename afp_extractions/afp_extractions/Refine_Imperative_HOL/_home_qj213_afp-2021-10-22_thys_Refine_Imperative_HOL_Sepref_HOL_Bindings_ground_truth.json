{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/Sepref_HOL_Bindings.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemma [def_pat_rules]: \"ASSN_ANNOT$A \\<equiv> UNPROTECT (ASSN_ANNOT A)\"", "lemma [sepref_fr_rules]: \"(return o (\\<lambda>x. x), RETURN o PR_CONST (ASSN_ANNOT A)) \\<in> A\\<^sup>d\\<rightarrow>\\<^sub>aA\"", "lemma annotate_assn: \"x \\<equiv> ASSN_ANNOT A x\"", "lemma [safe_constraint_rules]: \n  \"IS_ID Id\"\n  \"IS_ID R1 \\<Longrightarrow> IS_ID R2 \\<Longrightarrow> IS_ID (R1 \\<rightarrow> R2)\"\n  \"IS_ID R \\<Longrightarrow> IS_ID (\\<langle>R\\<rangle>option_rel)\"\n  \"IS_ID R \\<Longrightarrow> IS_ID (\\<langle>R\\<rangle>list_rel)\"\n  \"IS_ID R1 \\<Longrightarrow> IS_ID R2 \\<Longrightarrow> IS_ID (R1 \\<times>\\<^sub>r R2)\"\n  \"IS_ID R1 \\<Longrightarrow> IS_ID R2 \\<Longrightarrow> IS_ID (\\<langle>R1,R2\\<rangle>sum_rel)\"", "lemma [safe_constraint_rules]: \n  \"IS_BELOW_ID Id\"\n  \"IS_BELOW_ID R \\<Longrightarrow> IS_BELOW_ID (\\<langle>R\\<rangle>option_rel)\"\n  \"IS_BELOW_ID R1 \\<Longrightarrow> IS_BELOW_ID R2 \\<Longrightarrow> IS_BELOW_ID (R1 \\<times>\\<^sub>r R2)\"\n  \"IS_BELOW_ID R1 \\<Longrightarrow> IS_BELOW_ID R2 \\<Longrightarrow> IS_BELOW_ID (\\<langle>R1,R2\\<rangle>sum_rel)\"", "lemma IS_BELOW_ID_fun_rel_aux: \"R1\\<supseteq>Id \\<Longrightarrow> IS_BELOW_ID R2 \\<Longrightarrow> IS_BELOW_ID (R1 \\<rightarrow> R2)\"", "lemma IS_BELOW_ID_list_rel[safe_constraint_rules]: \n  \"IS_BELOW_ID R \\<Longrightarrow> IS_BELOW_ID (\\<langle>R\\<rangle>list_rel)\"", "lemma IS_ID_imp_BELOW_ID[constraint_rules]: \n  \"IS_ID R \\<Longrightarrow> IS_BELOW_ID R\"", "lemma inv_fun_rel_eq[simp]: \"(A\\<rightarrow>B)\\<inverse> = A\\<inverse>\\<rightarrow>B\\<inverse>\"", "lemma inv_option_rel_eq[simp]: \"(\\<langle>K\\<rangle>option_rel)\\<inverse> = \\<langle>K\\<inverse>\\<rangle>option_rel\"", "lemma inv_prod_rel_eq[simp]: \"(P \\<times>\\<^sub>r Q)\\<inverse> = P\\<inverse> \\<times>\\<^sub>r Q\\<inverse>\"", "lemma inv_sum_rel_eq[simp]: \"(\\<langle>P,Q\\<rangle>sum_rel)\\<inverse> = \\<langle>P\\<inverse>,Q\\<inverse>\\<rangle>sum_rel\"", "lemma inv_list_rel_eq[simp]: \"(\\<langle>R\\<rangle>list_rel)\\<inverse> = \\<langle>R\\<inverse>\\<rangle>list_rel\"", "lemmas [constraint_simps] =\n  Relation.converse_Id\n  inv_fun_rel_eq\n  inv_option_rel_eq\n  inv_prod_rel_eq\n  inv_sum_rel_eq\n  inv_list_rel_eq", "lemmas IS_RIGHT_UNIQUED = single_valuedD", "lemma IS_LEFT_UNIQUED: \"\\<lbrakk>IS_LEFT_UNIQUE r; (y, x) \\<in> r; (z, x) \\<in> r\\<rbrakk> \\<Longrightarrow> y = z\"", "lemma prop2p:\n  \"IS_LEFT_UNIQUE R = left_unique (rel2p R)\"\n  \"IS_RIGHT_UNIQUE R = right_unique (rel2p R)\"\n  \"right_unique (rel2p (R\\<inverse>)) = left_unique (rel2p R)\"\n  \"IS_LEFT_TOTAL R = left_total (rel2p R)\"\n  \"IS_RIGHT_TOTAL R = right_total (rel2p R)\"", "lemma p2prop:\n  \"left_unique P = IS_LEFT_UNIQUE (p2rel P)\"\n  \"right_unique P = IS_RIGHT_UNIQUE (p2rel P)\"\n  \"left_total P = IS_LEFT_TOTAL (p2rel P)\"\n  \"right_total P = IS_RIGHT_TOTAL (p2rel P)\"\n  \"bi_unique P \\<longleftrightarrow> left_unique P \\<and> right_unique P\"", "lemmas [safe_constraint_rules] = \n  single_valued_Id  \n  prod_rel_sv \n  list_rel_sv \n  option_rel_sv \n  sum_rel_sv", "lemma [safe_constraint_rules]:\n  \"IS_LEFT_UNIQUE Id\"\n  \"IS_LEFT_UNIQUE R1 \\<Longrightarrow> IS_LEFT_UNIQUE R2 \\<Longrightarrow> IS_LEFT_UNIQUE (R1\\<times>\\<^sub>rR2)\"\n  \"IS_LEFT_UNIQUE R1 \\<Longrightarrow> IS_LEFT_UNIQUE R2 \\<Longrightarrow> IS_LEFT_UNIQUE (\\<langle>R1,R2\\<rangle>sum_rel)\"\n  \"IS_LEFT_UNIQUE R \\<Longrightarrow> IS_LEFT_UNIQUE (\\<langle>R\\<rangle>option_rel)\"\n  \"IS_LEFT_UNIQUE R \\<Longrightarrow> IS_LEFT_UNIQUE (\\<langle>R\\<rangle>list_rel)\"", "lemma IS_LEFT_TOTAL_alt: \"IS_LEFT_TOTAL R \\<longleftrightarrow> (\\<forall>x. \\<exists>y. (x,y)\\<in>R)\"", "lemma IS_RIGHT_TOTAL_alt: \"IS_RIGHT_TOTAL R \\<longleftrightarrow> (\\<forall>x. \\<exists>y. (y,x)\\<in>R)\"", "lemma [safe_constraint_rules]:\n  \"IS_LEFT_TOTAL Id\"\n  \"IS_LEFT_TOTAL R1 \\<Longrightarrow> IS_LEFT_TOTAL R2 \\<Longrightarrow> IS_LEFT_TOTAL (R1\\<times>\\<^sub>rR2)\"\n  \"IS_LEFT_TOTAL R1 \\<Longrightarrow> IS_LEFT_TOTAL R2 \\<Longrightarrow> IS_LEFT_TOTAL (\\<langle>R1,R2\\<rangle>sum_rel)\"\n  \"IS_LEFT_TOTAL R \\<Longrightarrow> IS_LEFT_TOTAL (\\<langle>R\\<rangle>option_rel)\"", "lemma [safe_constraint_rules]: \"IS_LEFT_TOTAL R \\<Longrightarrow> IS_LEFT_TOTAL (\\<langle>R\\<rangle>list_rel)\"", "lemma [safe_constraint_rules]:\n  \"IS_RIGHT_TOTAL Id\"\n  \"IS_RIGHT_TOTAL R1 \\<Longrightarrow> IS_RIGHT_TOTAL R2 \\<Longrightarrow> IS_RIGHT_TOTAL (R1\\<times>\\<^sub>rR2)\"\n  \"IS_RIGHT_TOTAL R1 \\<Longrightarrow> IS_RIGHT_TOTAL R2 \\<Longrightarrow> IS_RIGHT_TOTAL (\\<langle>R1,R2\\<rangle>sum_rel)\"\n  \"IS_RIGHT_TOTAL R \\<Longrightarrow> IS_RIGHT_TOTAL (\\<langle>R\\<rangle>option_rel)\"", "lemma [safe_constraint_rules]: \"IS_RIGHT_TOTAL R \\<Longrightarrow> IS_RIGHT_TOTAL (\\<langle>R\\<rangle>list_rel)\"", "lemma [constraint_simps]:\n  \"IS_LEFT_TOTAL (R\\<inverse>) \\<longleftrightarrow> IS_RIGHT_TOTAL R \"\n  \"IS_RIGHT_TOTAL (R\\<inverse>) \\<longleftrightarrow> IS_LEFT_TOTAL R  \"\n  \"IS_LEFT_UNIQUE (R\\<inverse>) \\<longleftrightarrow> IS_RIGHT_UNIQUE R\"\n  \"IS_RIGHT_UNIQUE (R\\<inverse>) \\<longleftrightarrow> IS_LEFT_UNIQUE R \"", "lemma [safe_constraint_rules]:\n  \"IS_RIGHT_UNIQUE A \\<Longrightarrow> IS_RIGHT_TOTAL B \\<Longrightarrow> IS_RIGHT_TOTAL (A\\<rightarrow>B)\"\n  \"IS_RIGHT_TOTAL A \\<Longrightarrow> IS_RIGHT_UNIQUE B \\<Longrightarrow> IS_RIGHT_UNIQUE (A\\<rightarrow>B)\"\n  \"IS_LEFT_UNIQUE A \\<Longrightarrow> IS_LEFT_TOTAL B \\<Longrightarrow> IS_LEFT_TOTAL (A\\<rightarrow>B)\"\n  \"IS_LEFT_TOTAL A \\<Longrightarrow> IS_LEFT_UNIQUE B \\<Longrightarrow> IS_LEFT_UNIQUE (A\\<rightarrow>B)\"", "lemma [constraint_rules]: \n  \"IS_BELOW_ID R \\<Longrightarrow> IS_RIGHT_UNIQUE R\"\n  \"IS_BELOW_ID R \\<Longrightarrow> IS_LEFT_UNIQUE R\"\n  \"IS_ID R \\<Longrightarrow> IS_RIGHT_TOTAL R\"\n  \"IS_ID R \\<Longrightarrow> IS_LEFT_TOTAL R\"", "lemma param_distinct[param]: \"\\<lbrakk>IS_LEFT_UNIQUE A; IS_RIGHT_UNIQUE A\\<rbrakk> \\<Longrightarrow> (distinct, distinct) \\<in> \\<langle>A\\<rangle>list_rel \\<rightarrow> bool_rel\"", "lemma param_Image[param]: \n  assumes \"IS_LEFT_UNIQUE A\" \"IS_RIGHT_UNIQUE A\"\n  shows \"((``), (``)) \\<in> \\<langle>A\\<times>\\<^sub>rB\\<rangle>set_rel \\<rightarrow> \\<langle>A\\<rangle>set_rel \\<rightarrow> \\<langle>B\\<rangle>set_rel\"", "lemma pres_eq_iff_svb: \"((=),(=))\\<in>K\\<rightarrow>K\\<rightarrow>bool_rel \\<longleftrightarrow> (single_valued K \\<and> single_valued (K\\<inverse>))\"", "lemma [constraint_rules]: \"\\<lbrakk>single_valued R; single_valued (R\\<inverse>)\\<rbrakk> \\<Longrightarrow> IS_PRES_EQ R\"", "lemma b_assn_pure_conv[constraint_simps]: \"b_assn (pure R) P = pure (b_rel R P)\"", "lemmas [sepref_import_rewrite, sepref_frame_normrel_eqs, fcomp_norm_unfold] \n  = b_assn_pure_conv[symmetric]", "lemma b_rel_nesting[simp]: \n  \"b_rel (b_rel R P1) P2 = b_rel R (\\<lambda>x. P1 x \\<and> P2 x)\"", "lemma b_rel_triv[simp]: \n  \"b_rel R (\\<lambda>_. True) = R\"", "lemma b_assn_nesting[simp]: \n  \"b_assn (b_assn A P1) P2 = b_assn A (\\<lambda>x. P1 x \\<and> P2 x)\"", "lemma b_assn_triv[simp]: \n  \"b_assn A (\\<lambda>_. True) = A\"", "lemmas [simp,constraint_simps,sepref_import_rewrite, sepref_frame_normrel_eqs, fcomp_norm_unfold]\n  = b_rel_nesting b_assn_nesting", "lemma b_rel_simp[simp]: \"(x,y)\\<in>b_rel R P \\<longleftrightarrow> (x,y)\\<in>R \\<and> P y\"", "lemma b_assn_simp[simp]: \"b_assn A P x y = A x y * \\<up>(P x)\"", "lemma b_rel_Range[simp]: \"Range (b_rel R P) = Range R \\<inter> Collect P\"", "lemma b_assn_rdom[simp]: \"rdomp (b_assn R P) x \\<longleftrightarrow> rdomp R x \\<and> P x\"", "lemma b_rel_below_id[constraint_rules]: \n  \"IS_BELOW_ID R \\<Longrightarrow> IS_BELOW_ID (b_rel R P)\"", "lemma b_rel_left_unique[constraint_rules]: \n  \"IS_LEFT_UNIQUE R \\<Longrightarrow> IS_LEFT_UNIQUE (b_rel R P)\"", "lemma b_rel_right_unique[constraint_rules]: \n  \"IS_RIGHT_UNIQUE R \\<Longrightarrow> IS_RIGHT_UNIQUE (b_rel R P)\"", "lemma b_assn_is_pure[safe_constraint_rules]:\n  \"is_pure A \\<Longrightarrow> is_pure (b_assn A P)\"", "lemma b_assn_subtyping_match[sepref_frame_match_rules]:\n  assumes \"hn_ctxt (b_assn A P) x y \\<Longrightarrow>\\<^sub>t hn_ctxt A' x y\"\n  assumes \"\\<lbrakk>vassn_tag (hn_ctxt A x y); vassn_tag (hn_ctxt A' x y); P x\\<rbrakk> \\<Longrightarrow> P' x\"\n  shows \"hn_ctxt (b_assn A P) x y \\<Longrightarrow>\\<^sub>t hn_ctxt (b_assn A' P') x y\"", "lemma b_assn_subtyping_match_eqA[sepref_frame_match_rules]:\n  assumes \"\\<lbrakk>vassn_tag (hn_ctxt A x y); P x\\<rbrakk> \\<Longrightarrow> P' x\"\n  shows \"hn_ctxt (b_assn A P) x y \\<Longrightarrow>\\<^sub>t hn_ctxt (b_assn A P') x y\"", "lemma b_assn_subtyping_match_tR[sepref_frame_match_rules]:\n  assumes \"\\<lbrakk>P x\\<rbrakk> \\<Longrightarrow> hn_ctxt A x y \\<Longrightarrow>\\<^sub>t hn_ctxt A' x y\"\n  shows \"hn_ctxt (b_assn A P) x y \\<Longrightarrow>\\<^sub>t hn_ctxt A' x y\"", "lemma b_assn_subtyping_match_tL[sepref_frame_match_rules]:\n  assumes \"hn_ctxt A x y \\<Longrightarrow>\\<^sub>t hn_ctxt A' x y\"\n  assumes \"\\<lbrakk>vassn_tag (hn_ctxt A x y)\\<rbrakk> \\<Longrightarrow> P' x\"\n  shows \"hn_ctxt A x y \\<Longrightarrow>\\<^sub>t hn_ctxt (b_assn A' P') x y\"", "lemma b_assn_subtyping_match_eqA_tR[sepref_frame_match_rules]: \n  \"hn_ctxt (b_assn A P) x y \\<Longrightarrow>\\<^sub>t hn_ctxt A x y\"", "lemma b_assn_subtyping_match_eqA_tL[sepref_frame_match_rules]:\n  assumes \"\\<lbrakk>vassn_tag (hn_ctxt A x y)\\<rbrakk> \\<Longrightarrow> P' x\"\n  shows \"hn_ctxt A x y \\<Longrightarrow>\\<^sub>t hn_ctxt (b_assn A P') x y\"", "lemma b_rel_subtyping_merge[sepref_frame_merge_rules]:\n  assumes \"hn_ctxt A x y \\<or>\\<^sub>A hn_ctxt A' x y \\<Longrightarrow>\\<^sub>t hn_ctxt Am x y\"\n  shows \"hn_ctxt (b_assn A P) x y \\<or>\\<^sub>A hn_ctxt (b_assn A' P') x y \\<Longrightarrow>\\<^sub>t hn_ctxt (b_assn Am (\\<lambda>x. P x \\<or> P' x)) x y\"", "lemma b_rel_subtyping_merge_eqA[sepref_frame_merge_rules]:\n  shows \"hn_ctxt (b_assn A P) x y \\<or>\\<^sub>A hn_ctxt (b_assn A P') x y \\<Longrightarrow>\\<^sub>t hn_ctxt (b_assn A (\\<lambda>x. P x \\<or> P' x)) x y\"", "lemma b_rel_subtyping_merge_tL[sepref_frame_merge_rules]:\n  assumes \"hn_ctxt A x y \\<or>\\<^sub>A hn_ctxt A' x y \\<Longrightarrow>\\<^sub>t hn_ctxt Am x y\"\n  shows \"hn_ctxt A x y \\<or>\\<^sub>A hn_ctxt (b_assn A' P') x y \\<Longrightarrow>\\<^sub>t hn_ctxt Am x y\"", "lemma b_rel_subtyping_merge_tR[sepref_frame_merge_rules]:\n  assumes \"hn_ctxt A x y \\<or>\\<^sub>A hn_ctxt A' x y \\<Longrightarrow>\\<^sub>t hn_ctxt Am x y\"\n  shows \"hn_ctxt (b_assn A P) x y \\<or>\\<^sub>A hn_ctxt A' x y \\<Longrightarrow>\\<^sub>t hn_ctxt Am x y\"", "lemma b_rel_subtyping_merge_eqA_tL[sepref_frame_merge_rules]:\n  shows \"hn_ctxt A x y \\<or>\\<^sub>A hn_ctxt (b_assn A P') x y \\<Longrightarrow>\\<^sub>t hn_ctxt A x y\"", "lemma b_rel_subtyping_merge_eqA_tR[sepref_frame_merge_rules]:\n  shows \"hn_ctxt (b_assn A P) x y \\<or>\\<^sub>A hn_ctxt A x y \\<Longrightarrow>\\<^sub>t hn_ctxt A x y\"", "lemma b_assn_invalid_merge1: \"hn_invalid (b_assn A P) x y \\<or>\\<^sub>A hn_invalid (b_assn A P') x y\n  \\<Longrightarrow>\\<^sub>t hn_invalid (b_assn A (\\<lambda>x. P x \\<or> P' x)) x y\"", "lemma b_assn_invalid_merge2: \"hn_invalid (b_assn A P) x y \\<or>\\<^sub>A hn_invalid A x y\n  \\<Longrightarrow>\\<^sub>t hn_invalid A x y\"", "lemma b_assn_invalid_merge3: \"hn_invalid A x y \\<or>\\<^sub>A hn_invalid (b_assn A P) x y\n  \\<Longrightarrow>\\<^sub>t hn_invalid A x y\"", "lemma b_assn_invalid_merge4: \"hn_invalid (b_assn A P) x y \\<or>\\<^sub>A hn_ctxt (b_assn A P') x y\n  \\<Longrightarrow>\\<^sub>t hn_invalid (b_assn A (\\<lambda>x. P x \\<or> P' x)) x y\"", "lemma b_assn_invalid_merge5: \"hn_ctxt (b_assn A P') x y \\<or>\\<^sub>A hn_invalid (b_assn A P) x y\n  \\<Longrightarrow>\\<^sub>t hn_invalid (b_assn A (\\<lambda>x. P x \\<or> P' x)) x y\"", "lemma b_assn_invalid_merge6: \"hn_invalid (b_assn A P) x y \\<or>\\<^sub>A hn_ctxt A x y\n  \\<Longrightarrow>\\<^sub>t hn_invalid A x y\"", "lemma b_assn_invalid_merge7: \"hn_ctxt A x y \\<or>\\<^sub>A hn_invalid (b_assn A P) x y\n  \\<Longrightarrow>\\<^sub>t hn_invalid A x y\"", "lemma b_assn_invalid_merge8: \"hn_ctxt (b_assn A P) x y \\<or>\\<^sub>A hn_invalid A x y\n  \\<Longrightarrow>\\<^sub>t hn_invalid A x y\"", "lemma b_assn_invalid_merge9: \"hn_invalid A x y \\<or>\\<^sub>A hn_ctxt (b_assn A P) x y\n  \\<Longrightarrow>\\<^sub>t hn_invalid A x y\"", "lemmas b_assn_invalid_merge[sepref_frame_merge_rules] = \n  b_assn_invalid_merge1\n  b_assn_invalid_merge2\n  b_assn_invalid_merge3\n  b_assn_invalid_merge4\n  b_assn_invalid_merge5\n  b_assn_invalid_merge6\n  b_assn_invalid_merge7\n  b_assn_invalid_merge8\n  b_assn_invalid_merge9", "lemmas [sepref_relprops] = \n  sepref_relpropI[of IS_LEFT_UNIQUE]\n  sepref_relpropI[of IS_RIGHT_UNIQUE]\n  sepref_relpropI[of IS_LEFT_TOTAL]\n  sepref_relpropI[of IS_RIGHT_TOTAL]\n  sepref_relpropI[of is_pure]\n  sepref_relpropI[of \"IS_PURE \\<Phi>\" for \\<Phi>]\n  sepref_relpropI[of IS_ID]\n  sepref_relpropI[of IS_BELOW_ID]", "lemma [sepref_relprops_simps]:\n  \"CONSTRAINT (IS_PURE IS_ID) A \\<Longrightarrow> CONSTRAINT (IS_PURE IS_BELOW_ID) A\"\n  \"CONSTRAINT (IS_PURE IS_ID) A \\<Longrightarrow> CONSTRAINT (IS_PURE IS_LEFT_TOTAL) A\"\n  \"CONSTRAINT (IS_PURE IS_ID) A \\<Longrightarrow> CONSTRAINT (IS_PURE IS_RIGHT_TOTAL) A\"\n  \"CONSTRAINT (IS_PURE IS_BELOW_ID) A \\<Longrightarrow> CONSTRAINT (IS_PURE IS_LEFT_UNIQUE) A\"\n  \"CONSTRAINT (IS_PURE IS_BELOW_ID) A \\<Longrightarrow> CONSTRAINT (IS_PURE IS_RIGHT_UNIQUE) A\"", "lemma [sepref_relprops_transform]: \"single_valued (R\\<inverse>) = IS_LEFT_UNIQUE R\"", "lemma hn_if[sepref_comb_rules]:\n  assumes P: \"\\<Gamma> \\<Longrightarrow>\\<^sub>t \\<Gamma>1 * hn_val bool_rel a a'\"\n  assumes RT: \"a \\<Longrightarrow> hn_refine (\\<Gamma>1 * hn_val bool_rel a a') b' \\<Gamma>2b R b\"\n  assumes RE: \"\\<not>a \\<Longrightarrow> hn_refine (\\<Gamma>1 * hn_val bool_rel a a') c' \\<Gamma>2c R c\"\n  assumes IMP: \"TERM If \\<Longrightarrow> \\<Gamma>2b \\<or>\\<^sub>A \\<Gamma>2c \\<Longrightarrow>\\<^sub>t \\<Gamma>'\"\n  shows \"hn_refine \\<Gamma> (if a' then b' else c') \\<Gamma>' R (If$a$b$c)\"", "lemmas [sepref_opt_simps] = if_True if_False", "lemma hn_let[sepref_comb_rules]:\n  assumes P: \"\\<Gamma> \\<Longrightarrow>\\<^sub>t \\<Gamma>1 * hn_ctxt R v v'\"\n  assumes R: \"\\<And>x x'. x=v \\<Longrightarrow> hn_refine (\\<Gamma>1 * hn_ctxt R x x') (f' x') \n    (\\<Gamma>' x x') R2 (f x)\"\n  assumes F: \"\\<And>x x'. \\<Gamma>' x x' \\<Longrightarrow>\\<^sub>t \\<Gamma>2 * hn_ctxt R' x x'\"\n  shows \n    \"hn_refine \\<Gamma> (Let v' f') (\\<Gamma>2 * hn_ctxt R' v v') R2 (Let$v$(\\<lambda>\\<^sub>2x. f x))\"", "lemma hnr_default[sepref_import_param]: \"(default,default)\\<in>Id\"", "lemma unit_hnr[sepref_import_param]: \"((),())\\<in>unit_rel\"", "lemmas [sepref_import_param] = \n  param_bool\n  param_nat1\n  param_int", "lemmas [id_rules] = \n  itypeI[Pure.of 0 \"TYPE (nat)\"]\n  itypeI[Pure.of 0 \"TYPE (int)\"]\n  itypeI[Pure.of 1 \"TYPE (nat)\"]\n  itypeI[Pure.of 1 \"TYPE (int)\"]\n  itypeI[Pure.of numeral \"TYPE (num \\<Rightarrow> nat)\"]\n  itypeI[Pure.of numeral \"TYPE (num \\<Rightarrow> int)\"]\n  itype_self[of num.One]\n  itype_self[of num.Bit0]\n  itype_self[of num.Bit1]", "lemma param_min_nat[param,sepref_import_param]: \"(min,min)\\<in>nat_rel \\<rightarrow> nat_rel \\<rightarrow> nat_rel\"", "lemma param_max_nat[param,sepref_import_param]: \"(max,max)\\<in>nat_rel \\<rightarrow> nat_rel \\<rightarrow> nat_rel\"", "lemma param_min_int[param,sepref_import_param]: \"(min,min)\\<in>int_rel \\<rightarrow> int_rel \\<rightarrow> int_rel\"", "lemma param_max_int[param,sepref_import_param]: \"(max,max)\\<in>int_rel \\<rightarrow> int_rel \\<rightarrow> int_rel\"", "lemma uminus_hnr[sepref_import_param]: \"(uminus,uminus)\\<in>int_rel \\<rightarrow> int_rel\"", "lemma nat_param[param,sepref_import_param]: \"(nat,nat) \\<in> int_rel \\<rightarrow> nat_rel\"", "lemma int_param[param,sepref_import_param]: \"(int,int) \\<in> nat_rel \\<rightarrow> int_rel\"", "lemmas [sepref_import_rewrite, sepref_frame_normrel_eqs, fcomp_norm_unfold] = prod_assn_pure_conv[symmetric]", "lemma prod_assn_precise[constraint_rules]: \n  \"precise P1 \\<Longrightarrow> precise P2 \\<Longrightarrow> precise (prod_assn P1 P2)\"", "lemma  \n  \"precise P1 \\<Longrightarrow> precise P2 \\<Longrightarrow> precise (prod_assn P1 P2)\" \\<comment> \\<open>Original proof\\<close>", "lemma intf_of_prod_assn[intf_of_assn]:\n  assumes \"intf_of_assn A TYPE('a)\" \"intf_of_assn B TYPE('b)\"\n  shows \"intf_of_assn (prod_assn A B) TYPE('a * 'b)\"", "lemma pure_prod[constraint_rules]: \n  assumes P1: \"is_pure P1\" and P2: \"is_pure P2\"\n  shows \"is_pure (prod_assn P1 P2)\"", "lemma prod_frame_match[sepref_frame_match_rules]:\n  assumes \"hn_ctxt A (fst x) (fst y) \\<Longrightarrow>\\<^sub>t hn_ctxt A' (fst x) (fst y)\"\n  assumes \"hn_ctxt B (snd x) (snd y) \\<Longrightarrow>\\<^sub>t hn_ctxt B' (snd x) (snd y)\"\n  shows \"hn_ctxt (prod_assn A B) x y \\<Longrightarrow>\\<^sub>t hn_ctxt (prod_assn A' B') x y\"", "lemma prod_frame_merge[sepref_frame_merge_rules]:   \n  assumes \"hn_ctxt A (fst x) (fst y) \\<or>\\<^sub>A hn_ctxt A' (fst x) (fst y) \\<Longrightarrow>\\<^sub>t hn_ctxt Am (fst x) (fst y)\"\n  assumes \"hn_ctxt B (snd x) (snd y) \\<or>\\<^sub>A hn_ctxt B' (snd x) (snd y) \\<Longrightarrow>\\<^sub>t hn_ctxt Bm (snd x) (snd y)\"\n  shows \"hn_ctxt (prod_assn A B) x y \\<or>\\<^sub>A hn_ctxt (prod_assn A' B') x y \\<Longrightarrow>\\<^sub>t hn_ctxt (prod_assn Am Bm) x y\"", "lemma entt_invalid_prod: \"hn_invalid (prod_assn A B) p p' \\<Longrightarrow>\\<^sub>t hn_ctxt (prod_assn (invalid_assn A) (invalid_assn B)) p p'\"", "lemmas invalid_prod_merge[sepref_frame_merge_rules] = gen_merge_cons[OF entt_invalid_prod]", "lemma prod_assn_ctxt: \"prod_assn A1 A2 x y = z \\<Longrightarrow> hn_ctxt (prod_assn A1 A2) x y = z\"", "lemma hn_case_prod'[sepref_prep_comb_rule,sepref_comb_rules]:\n  assumes FR: \"\\<Gamma>\\<Longrightarrow>\\<^sub>thn_ctxt (prod_assn P1 P2) p' p * \\<Gamma>1\"\n  assumes Pair: \"\\<And>a1 a2 a1' a2'. \\<lbrakk>p'=(a1',a2')\\<rbrakk> \n    \\<Longrightarrow> hn_refine (hn_ctxt P1 a1' a1 * hn_ctxt P2 a2' a2 * \\<Gamma>1 * hn_invalid (prod_assn P1 P2) p' p) (f a1 a2) \n          (hn_ctxt P1' a1' a1 * hn_ctxt P2' a2' a2 * hn_ctxt XX1 p' p * \\<Gamma>1') R (f' a1' a2')\"\n  shows \"hn_refine \\<Gamma> (case_prod f p) (hn_ctxt (prod_assn P1' P2') p' p * \\<Gamma>1')\n    R (case_prod$(\\<lambda>\\<^sub>2a b. f' a b)$p')\" (is \"?G \\<Gamma>\")", "lemma hn_case_prod_old:\n  assumes P: \"\\<Gamma>\\<Longrightarrow>\\<^sub>t\\<Gamma>1 * hn_ctxt (prod_assn P1 P2) p' p\"\n  assumes R: \"\\<And>a1 a2 a1' a2'. \\<lbrakk>p'=(a1',a2')\\<rbrakk> \n    \\<Longrightarrow> hn_refine (\\<Gamma>1 * hn_ctxt P1 a1' a1 * hn_ctxt P2 a2' a2 * hn_invalid (prod_assn P1 P2) p' p) (f a1 a2) \n          (\\<Gamma>h a1 a1' a2 a2') R (f' a1' a2')\"\n  assumes M: \"\\<And>a1 a1' a2 a2'. \\<Gamma>h a1 a1' a2 a2' \n    \\<Longrightarrow>\\<^sub>t \\<Gamma>' * hn_ctxt P1' a1' a1 * hn_ctxt P2' a2' a2 * hn_ctxt Pxx p' p\"\n  shows \"hn_refine \\<Gamma> (case_prod f p) (\\<Gamma>' * hn_ctxt (prod_assn P1' P2') p' p)\n    R (case_prod$(\\<lambda>\\<^sub>2a b. f' a b)$p')\"", "lemma hn_Pair[sepref_fr_rules]: \"hn_refine \n  (hn_ctxt P1 x1 x1' * hn_ctxt P2 x2 x2')\n  (return (x1',x2'))\n  (hn_invalid P1 x1 x1' * hn_invalid P2 x2 x2')\n  (prod_assn P1 P2)\n  (RETURN$(Pair$x1$x2))\"", "lemma fst_hnr[sepref_fr_rules]: \"(return o fst,RETURN o fst) \\<in> (prod_assn A B)\\<^sup>d \\<rightarrow>\\<^sub>a A\"", "lemma snd_hnr[sepref_fr_rules]: \"(return o snd,RETURN o snd) \\<in> (prod_assn A B)\\<^sup>d \\<rightarrow>\\<^sub>a B\"", "lemmas [constraint_simps] = prod_assn_pure_conv", "lemmas [sepref_import_param] = param_prod_swap", "lemma rdomp_prodD[dest!]: \"rdomp (prod_assn A B) (a,b) \\<Longrightarrow> rdomp A a \\<and> rdomp B b\"", "lemma option_assn_simps[simp]:\n  \"option_assn P None v' = \\<up>(v'=None)\"\n  \"option_assn P v None = \\<up>(v=None)\"", "lemma option_assn_alt_def: \"option_assn R a b = \n  (case (a,b) of (Some x, Some y) \\<Rightarrow> R x y\n  | (None,None) \\<Rightarrow> emp\n  | _ \\<Rightarrow> false)\"", "lemma option_assn_pure_conv[constraint_simps]: \"option_assn (pure R) = pure (\\<langle>R\\<rangle>option_rel)\"", "lemmas [sepref_import_rewrite, sepref_frame_normrel_eqs, fcomp_norm_unfold] = option_assn_pure_conv[symmetric]", "lemma hr_comp_option_conv[simp, fcomp_norm_unfold]: \"\n  hr_comp (option_assn R) (\\<langle>R'\\<rangle>option_rel) \n  = option_assn (hr_comp R R')\"", "lemma option_assn_precise[safe_constraint_rules]: \n  assumes \"precise P\"  \n  shows \"precise (option_assn P)\"", "lemma pure_option[safe_constraint_rules]: \n  assumes P: \"is_pure P\"\n  shows \"is_pure (option_assn P)\"", "lemma hn_ctxt_option: \"option_assn A x y = z \\<Longrightarrow> hn_ctxt (option_assn A) x y = z\"", "lemma hn_case_option[sepref_prep_comb_rule, sepref_comb_rules]:\n  fixes p p' P\n  defines [simp]: \"INVE \\<equiv> hn_invalid (option_assn P) p p'\"\n  assumes FR: \"\\<Gamma> \\<Longrightarrow>\\<^sub>t hn_ctxt (option_assn P) p p' * F\"\n  assumes Rn: \"p=None \\<Longrightarrow> hn_refine (hn_ctxt (option_assn P) p p' * F) f1' (hn_ctxt XX1 p p' * \\<Gamma>1') R f1\"\n  assumes Rs: \"\\<And>x x'. \\<lbrakk> p=Some x; p'=Some x' \\<rbrakk> \\<Longrightarrow> \n    hn_refine (hn_ctxt P x x' * INVE * F) (f2' x') (hn_ctxt P' x x' * hn_ctxt XX2 p p' * \\<Gamma>2') R (f2 x)\"\n  assumes MERGE1: \"\\<Gamma>1' \\<or>\\<^sub>A \\<Gamma>2' \\<Longrightarrow>\\<^sub>t \\<Gamma>'\"  \n  shows \"hn_refine \\<Gamma> (case_option f1' f2' p') (hn_ctxt (option_assn P') p p' * \\<Gamma>') R (case_option$f1$(\\<lambda>\\<^sub>2x. f2 x)$p)\"", "lemma hn_None[sepref_fr_rules]:\n  \"hn_refine emp (return None) emp (option_assn P) (RETURN$None)\"", "lemma hn_Some[sepref_fr_rules]: \"hn_refine \n  (hn_ctxt P v v')\n  (return (Some v'))\n  (hn_invalid P v v')\n  (option_assn P)\n  (RETURN$(Some$v))\"", "lemma option_assn_eq[sepref_comb_rules]:\n  fixes a b :: \"'a option\"\n  assumes F1: \"\\<Gamma> \\<Longrightarrow>\\<^sub>t hn_ctxt (option_assn P) a a' * hn_ctxt (option_assn P) b b' * \\<Gamma>1\"\n  assumes EQ: \"\\<And>va va' vb vb'. hn_refine \n    (hn_ctxt P va va' * hn_ctxt P vb vb' * \\<Gamma>1)\n    (eq' va' vb') \n    (\\<Gamma>' va va' vb vb') \n    bool_assn\n    (RETURN$((=) $va$vb))\"\n  assumes F2: \n    \"\\<And>va va' vb vb'. \n      \\<Gamma>' va va' vb vb' \\<Longrightarrow>\\<^sub>t hn_ctxt P va va' * hn_ctxt P vb vb' * \\<Gamma>1\"\n  shows \"hn_refine \n    \\<Gamma> \n    (imp_option_eq eq' a' b') \n    (hn_ctxt (option_assn P) a a' * hn_ctxt (option_assn P) b b' * \\<Gamma>1)\n    bool_assn \n    (RETURN$((=) $a$b))\"", "lemma [pat_rules]: \n  \"(=) $a$None \\<equiv> is_None$a\"\n  \"(=) $None$a \\<equiv> is_None$a\"", "lemma hn_is_None[sepref_fr_rules]: \"hn_refine \n  (hn_ctxt (option_assn P) a a')\n  (return (is_None a'))\n  (hn_ctxt (option_assn P) a a')\n  bool_assn\n  (RETURN$(is_None$a))\"", "lemma (in -) sepref_the_complete[sepref_fr_rules]:\n  assumes \"x\\<noteq>None\"\n  shows \"hn_refine \n    (hn_ctxt (option_assn R) x xi) \n    (return (the xi)) \n    (hn_invalid (option_assn R) x xi)\n    (R)\n    (RETURN$(the$x))\"", "lemma (in -) sepref_the_id:\n  assumes \"CONSTRAINT (IS_PURE IS_ID) R\"\n  shows \"hn_refine \n    (hn_ctxt (option_assn R) x xi) \n    (return (the xi)) \n    (hn_ctxt (option_assn R) x xi)\n    (R)\n    (RETURN$(the$x))\"", "lemma list_assn_aux_simps[simp]:\n  \"list_assn P [] l' = (\\<up>(l'=[]))\"\n  \"list_assn P l [] = (\\<up>(l=[]))\"", "lemma list_assn_aux_append[simp]:\n  \"length l1=length l1' \\<Longrightarrow> \n    list_assn P (l1@l2) (l1'@l2') \n    = list_assn P l1 l1' * list_assn P l2 l2'\"", "lemma list_assn_aux_ineq_len: \"length l \\<noteq> length li \\<Longrightarrow> list_assn A l li = false\"", "lemma list_assn_aux_append2[simp]:\n  assumes \"length l2=length l2'\"  \n  shows \"list_assn P (l1@l2) (l1'@l2') \n    = list_assn P l1 l1' * list_assn P l2 l2'\"", "lemma list_assn_pure_conv[constraint_simps]: \"list_assn (pure R) = pure (\\<langle>R\\<rangle>list_rel)\"", "lemmas [sepref_import_rewrite, sepref_frame_normrel_eqs, fcomp_norm_unfold] = list_assn_pure_conv[symmetric]", "lemma list_assn_simps[simp]:\n  \"hn_ctxt (list_assn P) [] l' = (\\<up>(l'=[]))\"\n  \"hn_ctxt (list_assn P) l [] = (\\<up>(l=[]))\"\n  \"hn_ctxt (list_assn P) [] [] = emp\"\n  \"hn_ctxt (list_assn P) (a#as) (c#cs) = hn_ctxt P a c * hn_ctxt (list_assn P) as cs\"\n  \"hn_ctxt (list_assn P) (a#as) [] = false\"\n  \"hn_ctxt (list_assn P) [] (c#cs) = false\"", "lemma list_assn_precise[constraint_rules]: \"precise P \\<Longrightarrow> precise (list_assn P)\"", "lemma list_assn_pure[constraint_rules]: \n  assumes P: \"is_pure P\" \n  shows \"is_pure (list_assn P)\"", "lemma list_assn_mono: \n  \"\\<lbrakk>\\<And>x x'. P x x'\\<Longrightarrow>\\<^sub>AP' x x'\\<rbrakk> \\<Longrightarrow> list_assn P l l' \\<Longrightarrow>\\<^sub>A list_assn P' l l'\"", "lemma list_assn_monot: \n  \"\\<lbrakk>\\<And>x x'. P x x'\\<Longrightarrow>\\<^sub>tP' x x'\\<rbrakk> \\<Longrightarrow> list_assn P l l' \\<Longrightarrow>\\<^sub>t list_assn P' l l'\"", "lemma list_match_cong[sepref_frame_match_rules]: \n  \"\\<lbrakk>\\<And>x x'. \\<lbrakk>x\\<in>set l; x'\\<in>set l'\\<rbrakk> \\<Longrightarrow> hn_ctxt A x x' \\<Longrightarrow>\\<^sub>t hn_ctxt A' x x' \\<rbrakk> \\<Longrightarrow> hn_ctxt (list_assn A) l l' \\<Longrightarrow>\\<^sub>t hn_ctxt (list_assn A') l l'\"", "lemma list_merge_cong[sepref_frame_merge_rules]:\n  assumes \"\\<And>x x'. \\<lbrakk>x\\<in>set l; x'\\<in>set l'\\<rbrakk> \\<Longrightarrow> hn_ctxt A x x' \\<or>\\<^sub>A hn_ctxt A' x x' \\<Longrightarrow>\\<^sub>t hn_ctxt Am x x'\"\n  shows \"hn_ctxt (list_assn A) l l' \\<or>\\<^sub>A hn_ctxt (list_assn A') l l' \\<Longrightarrow>\\<^sub>t hn_ctxt (list_assn Am) l l'\"", "lemma invalid_list_split: \n  \"invalid_assn (list_assn A) (x#xs) (y#ys) \\<Longrightarrow>\\<^sub>t invalid_assn A x y * invalid_assn (list_assn A) xs ys\"", "lemma entt_invalid_list: \"hn_invalid (list_assn A) l l' \\<Longrightarrow>\\<^sub>t hn_ctxt (list_assn (invalid_assn A)) l l'\"", "lemmas invalid_list_merge[sepref_frame_merge_rules] = gen_merge_cons[OF entt_invalid_list]", "lemma list_assn_comp[fcomp_norm_unfold]: \"hr_comp (list_assn A) (\\<langle>B\\<rangle>list_rel) = list_assn (hr_comp A B)\"", "lemma hn_ctxt_eq: \"A x y = z \\<Longrightarrow> hn_ctxt A x y = z\"", "lemmas hn_ctxt_list = hn_ctxt_eq[of \"list_assn A\" for A]", "lemma hn_case_list[sepref_prep_comb_rule, sepref_comb_rules]:\n  fixes p p' P\n  defines [simp]: \"INVE \\<equiv> hn_invalid (list_assn P) p p'\"\n  assumes FR: \"\\<Gamma> \\<Longrightarrow>\\<^sub>t hn_ctxt (list_assn P) p p' * F\"\n  assumes Rn: \"p=[] \\<Longrightarrow> hn_refine (hn_ctxt (list_assn P) p p' * F) f1' (hn_ctxt XX1 p p' * \\<Gamma>1') R f1\"\n  assumes Rs: \"\\<And>x l x' l'. \\<lbrakk> p=x#l; p'=x'#l' \\<rbrakk> \\<Longrightarrow> \n    hn_refine (hn_ctxt P x x' * hn_ctxt (list_assn P) l l' * INVE * F) (f2' x' l') (hn_ctxt P1' x x' * hn_ctxt (list_assn P2') l l' * hn_ctxt XX2 p p' * \\<Gamma>2') R (f2 x l)\"\n  assumes MERGE1[unfolded hn_ctxt_def]: \"\\<And>x x'. hn_ctxt P1' x x' \\<or>\\<^sub>A hn_ctxt P2' x x' \\<Longrightarrow>\\<^sub>t hn_ctxt P' x x'\"  \n  assumes MERGE2: \"\\<Gamma>1' \\<or>\\<^sub>A \\<Gamma>2' \\<Longrightarrow>\\<^sub>t \\<Gamma>'\"  \n  shows \"hn_refine \\<Gamma> (case_list f1' f2' p') (hn_ctxt (list_assn P') p p' * \\<Gamma>') R (case_list$f1$(\\<lambda>\\<^sub>2x l. f2 x l)$p)\"", "lemma hn_Nil[sepref_fr_rules]: \n  \"hn_refine emp (return []) emp (list_assn P) (RETURN$[])\"", "lemma hn_Cons[sepref_fr_rules]: \"hn_refine (hn_ctxt P x x' * hn_ctxt (list_assn P) xs xs') \n  (return (x'#xs')) (hn_invalid P x x' * hn_invalid (list_assn P) xs xs') (list_assn P)\n  (RETURN$((#) $x$xs))\"", "lemma list_assn_aux_len: \n  \"list_assn P l l' = list_assn P l l' * \\<up>(length l = length l')\"", "lemma list_assn_aux_eqlen_simp: \n  \"vassn_tag (list_assn P l l') \\<Longrightarrow> length l' = length l\"\n  \"h \\<Turnstile> (list_assn P l l') \\<Longrightarrow> length l' = length l\"", "lemma hn_append[sepref_fr_rules]: \"hn_refine (hn_ctxt (list_assn P) l1 l1' * hn_ctxt (list_assn P) l2 l2')\n  (return (l1'@l2')) (hn_invalid (list_assn P) l1 l1' * hn_invalid (list_assn P) l2 l2') (list_assn P)\n  (RETURN$((@) $l1$l2))\"", "lemma list_assn_aux_cons_conv1:\n  \"list_assn R (a#l) m = (\\<exists>\\<^sub>Ab m'. R a b * list_assn R l m' * \\<up>(m=b#m'))\"", "lemma list_assn_aux_cons_conv2:\n  \"list_assn R l (b#m) = (\\<exists>\\<^sub>Aa l'. R a b * list_assn R l' m * \\<up>(l=a#l'))\"", "lemmas list_assn_aux_cons_conv = list_assn_aux_cons_conv1 list_assn_aux_cons_conv2", "lemma list_assn_aux_append_conv1:\n  \"list_assn R (l1@l2) m = (\\<exists>\\<^sub>Am1 m2. list_assn R l1 m1 * list_assn R l2 m2 * \\<up>(m=m1@m2))\"", "lemma list_assn_aux_append_conv2:\n  \"list_assn R l (m1@m2) = (\\<exists>\\<^sub>Al1 l2. list_assn R l1 m1 * list_assn R l2 m2 * \\<up>(l=l1@l2))\"", "lemmas list_assn_aux_append_conv = list_assn_aux_append_conv1 list_assn_aux_append_conv2", "lemma sum_assn_pure[safe_constraint_rules]: \"\\<lbrakk>is_pure A; is_pure B\\<rbrakk> \\<Longrightarrow> is_pure (sum_assn A B)\"", "lemma sum_assn_id[simp]: \"sum_assn id_assn id_assn = id_assn\"", "lemma sum_assn_pure_conv[simp]: \"sum_assn (pure A) (pure B) = pure (\\<langle>A,B\\<rangle>sum_rel)\"", "lemma sum_match_cong[sepref_frame_match_rules]: \n  \"\\<lbrakk>\n    \\<And>x y. \\<lbrakk>e = Inl x; e'=Inl y\\<rbrakk> \\<Longrightarrow> hn_ctxt A x y \\<Longrightarrow>\\<^sub>t hn_ctxt A' x y;\n    \\<And>x y. \\<lbrakk>e = Inr x; e'=Inr y\\<rbrakk> \\<Longrightarrow> hn_ctxt B x y \\<Longrightarrow>\\<^sub>t hn_ctxt B' x y\n  \\<rbrakk> \\<Longrightarrow> hn_ctxt (sum_assn A B) e e' \\<Longrightarrow>\\<^sub>t hn_ctxt (sum_assn A' B') e e'\"", "lemma enum_merge_cong[sepref_frame_merge_rules]:\n  assumes \"\\<And>x y. \\<lbrakk>e=Inl x; e'=Inl y\\<rbrakk> \\<Longrightarrow> hn_ctxt A x y \\<or>\\<^sub>A hn_ctxt A' x y \\<Longrightarrow>\\<^sub>t hn_ctxt Am x y\"\n  assumes \"\\<And>x y. \\<lbrakk>e=Inr x; e'=Inr y\\<rbrakk> \\<Longrightarrow> hn_ctxt B x y \\<or>\\<^sub>A hn_ctxt B' x y \\<Longrightarrow>\\<^sub>t hn_ctxt Bm x y\"\n  shows \"hn_ctxt (sum_assn A B) e e' \\<or>\\<^sub>A hn_ctxt (sum_assn A' B') e e' \\<Longrightarrow>\\<^sub>t hn_ctxt (sum_assn Am Bm) e e'\"", "lemma entt_invalid_sum: \"hn_invalid (sum_assn A B) e e' \\<Longrightarrow>\\<^sub>t hn_ctxt (sum_assn (invalid_assn A) (invalid_assn B)) e e'\"", "lemmas invalid_sum_merge[sepref_frame_merge_rules] = gen_merge_cons[OF entt_invalid_sum]", "lemma [sepref_fr_rules]: \"(return o Inl,RETURN o Inl) \\<in> A\\<^sup>d \\<rightarrow>\\<^sub>a sum_assn A B\"", "lemma [sepref_fr_rules]: \"(return o Inr,RETURN o Inr) \\<in> B\\<^sup>d \\<rightarrow>\\<^sub>a sum_assn A B\"", "lemma [sepref_monadify_arity]: \"case_sum \\<equiv> \\<lambda>\\<^sub>2f1 f2 x. SP case_sum$(\\<lambda>\\<^sub>2x. f1$x)$(\\<lambda>\\<^sub>2x. f2$x)$x\"", "lemma [sepref_monadify_comb]: \"case_sum$f1$f2$x \\<equiv> (\\<bind>) $(EVAL$x)$(\\<lambda>\\<^sub>2x. SP case_sum$f1$f2$x)\"", "lemma [sepref_monadify_comb]: \"EVAL$(case_sum$(\\<lambda>\\<^sub>2x. f1 x)$(\\<lambda>\\<^sub>2x. f2 x)$x) \n  \\<equiv> (\\<bind>) $(EVAL$x)$(\\<lambda>\\<^sub>2x. SP case_sum$(\\<lambda>\\<^sub>2x. EVAL $ f1 x)$(\\<lambda>\\<^sub>2x. EVAL $ f2 x)$x)\"", "lemma sum_assn_ctxt: \"sum_assn A B x y = z \\<Longrightarrow> hn_ctxt (sum_assn A B) x y = z\"", "lemma sum_cases_hnr:\n  fixes A B e e'\n  defines [simp]: \"INVe \\<equiv> hn_invalid (sum_assn A B) e e'\"\n  assumes FR: \"\\<Gamma> \\<Longrightarrow>\\<^sub>t hn_ctxt (sum_assn A B) e e' * F\"\n  assumes E1: \"\\<And>x1 x1a. \\<lbrakk>e = Inl x1; e' = Inl x1a\\<rbrakk> \\<Longrightarrow> hn_refine (hn_ctxt A x1 x1a * INVe * F) (f1' x1a) (hn_ctxt A' x1 x1a * hn_ctxt XX1 e e' * \\<Gamma>1') R (f1 x1)\"\n  assumes E2: \"\\<And>x2 x2a. \\<lbrakk>e = Inr x2; e' = Inr x2a\\<rbrakk> \\<Longrightarrow> hn_refine (hn_ctxt B x2 x2a * INVe * F) (f2' x2a) (hn_ctxt B' x2 x2a * hn_ctxt XX2 e e' * \\<Gamma>2') R (f2 x2)\"\n  assumes MERGE[unfolded hn_ctxt_def]: \"\\<Gamma>1' \\<or>\\<^sub>A \\<Gamma>2' \\<Longrightarrow>\\<^sub>t \\<Gamma>'\"\n  shows \"hn_refine \\<Gamma> (case_sum f1' f2' e') (hn_ctxt (sum_assn A' B') e e' * \\<Gamma>') R (case_sum$(\\<lambda>\\<^sub>2x. f1 x)$(\\<lambda>\\<^sub>2x. f2 x)$e)\"", "lemmas [sepref_comb_rules] = sum_cases_hnr[sepref_prep_comb_rule]", "lemma isl_hnr[sepref_fr_rules]: \"(return o isl,RETURN o isl) \\<in> (sum_assn A B)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\"", "lemma projl_hnr[sepref_fr_rules]: \"(return o projl,RETURN o projl) \\<in> [isl]\\<^sub>a (sum_assn A B)\\<^sup>d \\<rightarrow> A\"", "lemma projr_hnr[sepref_fr_rules]: \"(return o projr,RETURN o projr) \\<in> [Not o isl]\\<^sub>a (sum_assn A B)\\<^sup>d \\<rightarrow> B\"", "lemma empty_literal_hnr [sepref_import_param]:\n  \"(String.empty_literal, PR_CONST String.empty_literal) \\<in> Id\"", "lemma empty_literal_pat [def_pat_rules]:\n  \"String.empty_literal \\<equiv> UNPROTECT String.empty_literal\"", "lemma Literal_hnr [sepref_import_param]:\n  \"(String.Literal b0 b1 b2 b3 b4 b5 b6 s,\n    PR_CONST (String.Literal b0 b1 b2 b3 b4 b5 b6 s)) \\<in> Id\"", "lemma Literal_pat [def_pat_rules]:\n  \"String.Literal $ b0 $ b1 $ b2 $ b3 $ b4 $ b5 $ b6 $ s \\<equiv>\n    UNPROTECT (String.Literal $ b0 $ b1 $ b2 $ b3 $ b4 $ b5 $ b6 $ s)\""], "translations": [["", "lemma [def_pat_rules]: \"ASSN_ANNOT$A \\<equiv> UNPROTECT (ASSN_ANNOT A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSN_ANNOT $ A \\<equiv> UNPROTECT (ASSN_ANNOT A)", "by simp"], ["", "lemma [sepref_fr_rules]: \"(return o (\\<lambda>x. x), RETURN o PR_CONST (ASSN_ANNOT A)) \\<in> A\\<^sup>d\\<rightarrow>\\<^sub>aA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (return \\<circ> (\\<lambda>x. x),\n     (RETURN \\<circ>\\<circ> PR_CONST) (ASSN_ANNOT A))\n    \\<in> A\\<^sup>d \\<rightarrow>\\<^sub>a A", "by sepref_to_hoare sep_auto"], ["", "end"], ["", "lemma annotate_assn: \"x \\<equiv> ASSN_ANNOT A x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<equiv> ASSN_ANNOT A x", "by simp"], ["", "subsection \\<open>Shortcuts\\<close>"], ["", "abbreviation \"nat_assn \\<equiv> (id_assn::nat \\<Rightarrow> _)\""], ["", "abbreviation \"int_assn \\<equiv> (id_assn::int \\<Rightarrow> _)\""], ["", "abbreviation \"bool_assn \\<equiv> (id_assn::bool \\<Rightarrow> _)\""], ["", "subsection \\<open>Identity Relations\\<close>"], ["", "definition \"IS_ID R \\<equiv> R=Id\""], ["", "definition \"IS_BELOW_ID R \\<equiv> R\\<subseteq>Id\""], ["", "lemma [safe_constraint_rules]: \n  \"IS_ID Id\"\n  \"IS_ID R1 \\<Longrightarrow> IS_ID R2 \\<Longrightarrow> IS_ID (R1 \\<rightarrow> R2)\"\n  \"IS_ID R \\<Longrightarrow> IS_ID (\\<langle>R\\<rangle>option_rel)\"\n  \"IS_ID R \\<Longrightarrow> IS_ID (\\<langle>R\\<rangle>list_rel)\"\n  \"IS_ID R1 \\<Longrightarrow> IS_ID R2 \\<Longrightarrow> IS_ID (R1 \\<times>\\<^sub>r R2)\"\n  \"IS_ID R1 \\<Longrightarrow> IS_ID R2 \\<Longrightarrow> IS_ID (\\<langle>R1,R2\\<rangle>sum_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (IS_ID Id &&&\n     (\\<lbrakk>IS_ID R1; IS_ID R2\\<rbrakk>\n      \\<Longrightarrow> IS_ID (R1 \\<rightarrow> R2)) &&&\n     (IS_ID R \\<Longrightarrow> IS_ID (\\<langle>R\\<rangle>option_rel))) &&&\n    (IS_ID R \\<Longrightarrow> IS_ID (\\<langle>R\\<rangle>list_rel)) &&&\n    (\\<lbrakk>IS_ID R1; IS_ID R2\\<rbrakk>\n     \\<Longrightarrow> IS_ID (R1 \\<times>\\<^sub>r R2)) &&&\n    (\\<lbrakk>IS_ID R1; IS_ID R2\\<rbrakk>\n     \\<Longrightarrow> IS_ID (\\<langle>R1, R2\\<rangle>sum_rel))", "by (auto simp: IS_ID_def)"], ["", "lemma [safe_constraint_rules]: \n  \"IS_BELOW_ID Id\"\n  \"IS_BELOW_ID R \\<Longrightarrow> IS_BELOW_ID (\\<langle>R\\<rangle>option_rel)\"\n  \"IS_BELOW_ID R1 \\<Longrightarrow> IS_BELOW_ID R2 \\<Longrightarrow> IS_BELOW_ID (R1 \\<times>\\<^sub>r R2)\"\n  \"IS_BELOW_ID R1 \\<Longrightarrow> IS_BELOW_ID R2 \\<Longrightarrow> IS_BELOW_ID (\\<langle>R1,R2\\<rangle>sum_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (IS_BELOW_ID Id &&&\n     (IS_BELOW_ID R \\<Longrightarrow>\n      IS_BELOW_ID (\\<langle>R\\<rangle>option_rel))) &&&\n    (\\<lbrakk>IS_BELOW_ID R1; IS_BELOW_ID R2\\<rbrakk>\n     \\<Longrightarrow> IS_BELOW_ID (R1 \\<times>\\<^sub>r R2)) &&&\n    (\\<lbrakk>IS_BELOW_ID R1; IS_BELOW_ID R2\\<rbrakk>\n     \\<Longrightarrow> IS_BELOW_ID (\\<langle>R1, R2\\<rangle>sum_rel))", "by (auto simp: IS_ID_def IS_BELOW_ID_def option_rel_def sum_rel_def list_rel_def)"], ["", "lemma IS_BELOW_ID_fun_rel_aux: \"R1\\<supseteq>Id \\<Longrightarrow> IS_BELOW_ID R2 \\<Longrightarrow> IS_BELOW_ID (R1 \\<rightarrow> R2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Id \\<subseteq> R1; IS_BELOW_ID R2\\<rbrakk>\n    \\<Longrightarrow> IS_BELOW_ID (R1 \\<rightarrow> R2)", "by (auto simp: IS_BELOW_ID_def dest: fun_relD)"], ["", "corollary IS_BELOW_ID_fun_rel[safe_constraint_rules]: \n  \"IS_ID R1 \\<Longrightarrow> IS_BELOW_ID R2 \\<Longrightarrow> IS_BELOW_ID (R1 \\<rightarrow> R2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>IS_ID R1; IS_BELOW_ID R2\\<rbrakk>\n    \\<Longrightarrow> IS_BELOW_ID (R1 \\<rightarrow> R2)", "using IS_BELOW_ID_fun_rel_aux[of Id R2]"], ["proof (prove)\nusing this:\n  \\<lbrakk>Id \\<subseteq> Id; IS_BELOW_ID R2\\<rbrakk>\n  \\<Longrightarrow> IS_BELOW_ID (Id \\<rightarrow> R2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>IS_ID R1; IS_BELOW_ID R2\\<rbrakk>\n    \\<Longrightarrow> IS_BELOW_ID (R1 \\<rightarrow> R2)", "by (auto simp: IS_ID_def)"], ["", "lemma IS_BELOW_ID_list_rel[safe_constraint_rules]: \n  \"IS_BELOW_ID R \\<Longrightarrow> IS_BELOW_ID (\\<langle>R\\<rangle>list_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IS_BELOW_ID R \\<Longrightarrow>\n    IS_BELOW_ID (\\<langle>R\\<rangle>list_rel)", "unfolding IS_BELOW_ID_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<subseteq> Id \\<Longrightarrow>\n    \\<langle>R\\<rangle>list_rel \\<subseteq> Id", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>R \\<subseteq> Id;\n        (a, b) \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> a = b", "fix l l'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>R \\<subseteq> Id;\n        (a, b) \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> a = b", "assume A: \"R\\<subseteq>Id\""], ["proof (state)\nthis:\n  R \\<subseteq> Id\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>R \\<subseteq> Id;\n        (a, b) \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> a = b", "assume \"(l,l')\\<in>\\<langle>R\\<rangle>list_rel\""], ["proof (state)\nthis:\n  (l, l') \\<in> \\<langle>R\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>R \\<subseteq> Id;\n        (a, b) \\<in> \\<langle>R\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> a = b", "thus \"l=l'\""], ["proof (prove)\nusing this:\n  (l, l') \\<in> \\<langle>R\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. l = l'", "apply induction"], ["proof (prove)\ngoal (2 subgoals):\n 1. [] = []\n 2. \\<And>x x' l l'.\n       \\<lbrakk>(x, x') \\<in> R; (l, l') \\<in> \\<langle>R\\<rangle>list_rel;\n        l = l'\\<rbrakk>\n       \\<Longrightarrow> x # l = x' # l'", "using A"], ["proof (prove)\nusing this:\n  R \\<subseteq> Id\n\ngoal (2 subgoals):\n 1. [] = []\n 2. \\<And>x x' l l'.\n       \\<lbrakk>(x, x') \\<in> R; (l, l') \\<in> \\<langle>R\\<rangle>list_rel;\n        l = l'\\<rbrakk>\n       \\<Longrightarrow> x # l = x' # l'", "by auto"], ["proof (state)\nthis:\n  l = l'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma IS_ID_imp_BELOW_ID[constraint_rules]: \n  \"IS_ID R \\<Longrightarrow> IS_BELOW_ID R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IS_ID R \\<Longrightarrow> IS_BELOW_ID R", "by (auto simp: IS_ID_def IS_BELOW_ID_def )"], ["", "subsection \\<open>Inverse Relation\\<close>"], ["", "lemma inv_fun_rel_eq[simp]: \"(A\\<rightarrow>B)\\<inverse> = A\\<inverse>\\<rightarrow>B\\<inverse>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<rightarrow> B)\\<inverse> = A\\<inverse> \\<rightarrow> B\\<inverse>", "by (auto dest: fun_relD)"], ["", "lemma inv_option_rel_eq[simp]: \"(\\<langle>K\\<rangle>option_rel)\\<inverse> = \\<langle>K\\<inverse>\\<rangle>option_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<langle>K\\<rangle>option_rel)\\<inverse> =\n    \\<langle>K\\<inverse>\\<rangle>option_rel", "by (auto simp: option_rel_def)"], ["", "lemma inv_prod_rel_eq[simp]: \"(P \\<times>\\<^sub>r Q)\\<inverse> = P\\<inverse> \\<times>\\<^sub>r Q\\<inverse>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<times>\\<^sub>r Q)\\<inverse> =\n    P\\<inverse> \\<times>\\<^sub>r Q\\<inverse>", "by (auto)"], ["", "lemma inv_sum_rel_eq[simp]: \"(\\<langle>P,Q\\<rangle>sum_rel)\\<inverse> = \\<langle>P\\<inverse>,Q\\<inverse>\\<rangle>sum_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<langle>P, Q\\<rangle>sum_rel)\\<inverse> = \\<langle>P\\<inverse>,\n    Q\\<inverse>\\<rangle>sum_rel", "by (auto simp: sum_rel_def)"], ["", "lemma inv_list_rel_eq[simp]: \"(\\<langle>R\\<rangle>list_rel)\\<inverse> = \\<langle>R\\<inverse>\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<langle>R\\<rangle>list_rel)\\<inverse> =\n    \\<langle>R\\<inverse>\\<rangle>list_rel", "unfolding list_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(l, l'). list_all2 (\\<lambda>x x'. (x, x') \\<in> R) l l'}\\<inverse> =\n    {(l, l'). list_all2 (\\<lambda>x x'. (x, x') \\<in> R\\<inverse>) l l'}", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       list_all2 (\\<lambda>x x'. (x, x') \\<in> R) b a \\<Longrightarrow>\n       list_all2 (\\<lambda>x x'. (x, x') \\<in> R\\<inverse>) a b\n 2. \\<And>a b.\n       list_all2 (\\<lambda>x x'. (x, x') \\<in> R\\<inverse>) a\n        b \\<Longrightarrow>\n       list_all2 (\\<lambda>x x'. (x, x') \\<in> R) b a", "apply (subst list.rel_flip[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       list_all2 (\\<lambda>x x'. (x, x') \\<in> R) b a \\<Longrightarrow>\n       list_all2\n        (\\<lambda>x x'. (x, x') \\<in> R\\<inverse>)\\<inverse>\\<inverse> b a\n 2. \\<And>a b.\n       list_all2 (\\<lambda>x x'. (x, x') \\<in> R\\<inverse>) a\n        b \\<Longrightarrow>\n       list_all2 (\\<lambda>x x'. (x, x') \\<in> R) b a", "apply (simp add: conversep_iff[abs_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       list_all2 (\\<lambda>x x'. (x, x') \\<in> R\\<inverse>) a\n        b \\<Longrightarrow>\n       list_all2 (\\<lambda>x x'. (x, x') \\<in> R) b a", "apply (subst list.rel_flip[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       list_all2 (\\<lambda>x x'. (x, x') \\<in> R\\<inverse>) a\n        b \\<Longrightarrow>\n       list_all2 (\\<lambda>x x'. (x, x') \\<in> R)\\<inverse>\\<inverse> a b", "apply (simp add: conversep_iff[abs_def])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas [constraint_simps] =\n  Relation.converse_Id\n  inv_fun_rel_eq\n  inv_option_rel_eq\n  inv_prod_rel_eq\n  inv_sum_rel_eq\n  inv_list_rel_eq"], ["", "subsection \\<open>Single Valued and Total Relations\\<close>"], ["", "(* TODO: Link to other such theories: Transfer, Autoref *)"], ["", "definition \"IS_LEFT_UNIQUE R \\<equiv> single_valued (R\\<inverse>)\""], ["", "definition \"IS_LEFT_TOTAL R \\<equiv> Domain R = UNIV\""], ["", "definition \"IS_RIGHT_TOTAL R \\<equiv> Range R = UNIV\""], ["", "abbreviation (input) \"IS_RIGHT_UNIQUE \\<equiv> single_valued\""], ["", "lemmas IS_RIGHT_UNIQUED = single_valuedD"], ["", "lemma IS_LEFT_UNIQUED: \"\\<lbrakk>IS_LEFT_UNIQUE r; (y, x) \\<in> r; (z, x) \\<in> r\\<rbrakk> \\<Longrightarrow> y = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>IS_LEFT_UNIQUE r; (y, x) \\<in> r; (z, x) \\<in> r\\<rbrakk>\n    \\<Longrightarrow> y = z", "by (auto simp: IS_LEFT_UNIQUE_def dest: single_valuedD)"], ["", "lemma prop2p:\n  \"IS_LEFT_UNIQUE R = left_unique (rel2p R)\"\n  \"IS_RIGHT_UNIQUE R = right_unique (rel2p R)\"\n  \"right_unique (rel2p (R\\<inverse>)) = left_unique (rel2p R)\"\n  \"IS_LEFT_TOTAL R = left_total (rel2p R)\"\n  \"IS_RIGHT_TOTAL R = right_total (rel2p R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (IS_LEFT_UNIQUE R = left_unique (rel2p R) &&&\n     single_valued R = right_unique (rel2p R)) &&&\n    right_unique (rel2p (R\\<inverse>)) = left_unique (rel2p R) &&&\n    IS_LEFT_TOTAL R = left_total (rel2p R) &&&\n    IS_RIGHT_TOTAL R = right_total (rel2p R)", "by (auto \n    simp: IS_LEFT_UNIQUE_def left_unique_def single_valued_def\n    simp: right_unique_def\n    simp: IS_LEFT_TOTAL_def left_total_def\n    simp: IS_RIGHT_TOTAL_def right_total_def\n    simp: rel2p_def\n    )"], ["", "lemma p2prop:\n  \"left_unique P = IS_LEFT_UNIQUE (p2rel P)\"\n  \"right_unique P = IS_RIGHT_UNIQUE (p2rel P)\"\n  \"left_total P = IS_LEFT_TOTAL (p2rel P)\"\n  \"right_total P = IS_RIGHT_TOTAL (p2rel P)\"\n  \"bi_unique P \\<longleftrightarrow> left_unique P \\<and> right_unique P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (left_unique P = IS_LEFT_UNIQUE (p2rel P) &&&\n     right_unique P = single_valued (p2rel P)) &&&\n    left_total P = IS_LEFT_TOTAL (p2rel P) &&&\n    right_total P = IS_RIGHT_TOTAL (p2rel P) &&&\n    bi_unique P = (left_unique P \\<and> right_unique P)", "by (auto \n    simp: IS_LEFT_UNIQUE_def left_unique_def single_valued_def\n    simp: right_unique_def bi_unique_alt_def\n    simp: IS_LEFT_TOTAL_def left_total_def\n    simp: IS_RIGHT_TOTAL_def right_total_def\n    simp: p2rel_def\n    )"], ["", "lemmas [safe_constraint_rules] = \n  single_valued_Id  \n  prod_rel_sv \n  list_rel_sv \n  option_rel_sv \n  sum_rel_sv"], ["", "lemma [safe_constraint_rules]:\n  \"IS_LEFT_UNIQUE Id\"\n  \"IS_LEFT_UNIQUE R1 \\<Longrightarrow> IS_LEFT_UNIQUE R2 \\<Longrightarrow> IS_LEFT_UNIQUE (R1\\<times>\\<^sub>rR2)\"\n  \"IS_LEFT_UNIQUE R1 \\<Longrightarrow> IS_LEFT_UNIQUE R2 \\<Longrightarrow> IS_LEFT_UNIQUE (\\<langle>R1,R2\\<rangle>sum_rel)\"\n  \"IS_LEFT_UNIQUE R \\<Longrightarrow> IS_LEFT_UNIQUE (\\<langle>R\\<rangle>option_rel)\"\n  \"IS_LEFT_UNIQUE R \\<Longrightarrow> IS_LEFT_UNIQUE (\\<langle>R\\<rangle>list_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (IS_LEFT_UNIQUE Id &&&\n     (\\<lbrakk>IS_LEFT_UNIQUE R1; IS_LEFT_UNIQUE R2\\<rbrakk>\n      \\<Longrightarrow> IS_LEFT_UNIQUE (R1 \\<times>\\<^sub>r R2))) &&&\n    (\\<lbrakk>IS_LEFT_UNIQUE R1; IS_LEFT_UNIQUE R2\\<rbrakk>\n     \\<Longrightarrow> IS_LEFT_UNIQUE (\\<langle>R1, R2\\<rangle>sum_rel)) &&&\n    (IS_LEFT_UNIQUE R \\<Longrightarrow>\n     IS_LEFT_UNIQUE (\\<langle>R\\<rangle>option_rel)) &&&\n    (IS_LEFT_UNIQUE R \\<Longrightarrow>\n     IS_LEFT_UNIQUE (\\<langle>R\\<rangle>list_rel))", "by (auto simp: IS_LEFT_UNIQUE_def prod_rel_sv sum_rel_sv option_rel_sv list_rel_sv)"], ["", "lemma IS_LEFT_TOTAL_alt: \"IS_LEFT_TOTAL R \\<longleftrightarrow> (\\<forall>x. \\<exists>y. (x,y)\\<in>R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IS_LEFT_TOTAL R = (\\<forall>x. \\<exists>y. (x, y) \\<in> R)", "by (auto simp: IS_LEFT_TOTAL_def)"], ["", "lemma IS_RIGHT_TOTAL_alt: \"IS_RIGHT_TOTAL R \\<longleftrightarrow> (\\<forall>x. \\<exists>y. (y,x)\\<in>R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IS_RIGHT_TOTAL R = (\\<forall>x. \\<exists>y. (y, x) \\<in> R)", "by (auto simp: IS_RIGHT_TOTAL_def)"], ["", "lemma [safe_constraint_rules]:\n  \"IS_LEFT_TOTAL Id\"\n  \"IS_LEFT_TOTAL R1 \\<Longrightarrow> IS_LEFT_TOTAL R2 \\<Longrightarrow> IS_LEFT_TOTAL (R1\\<times>\\<^sub>rR2)\"\n  \"IS_LEFT_TOTAL R1 \\<Longrightarrow> IS_LEFT_TOTAL R2 \\<Longrightarrow> IS_LEFT_TOTAL (\\<langle>R1,R2\\<rangle>sum_rel)\"\n  \"IS_LEFT_TOTAL R \\<Longrightarrow> IS_LEFT_TOTAL (\\<langle>R\\<rangle>option_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (IS_LEFT_TOTAL Id &&&\n     (\\<lbrakk>IS_LEFT_TOTAL R1; IS_LEFT_TOTAL R2\\<rbrakk>\n      \\<Longrightarrow> IS_LEFT_TOTAL (R1 \\<times>\\<^sub>r R2))) &&&\n    (\\<lbrakk>IS_LEFT_TOTAL R1; IS_LEFT_TOTAL R2\\<rbrakk>\n     \\<Longrightarrow> IS_LEFT_TOTAL (\\<langle>R1, R2\\<rangle>sum_rel)) &&&\n    (IS_LEFT_TOTAL R \\<Longrightarrow>\n     IS_LEFT_TOTAL (\\<langle>R\\<rangle>option_rel))", "apply (auto simp: IS_LEFT_TOTAL_alt sum_rel_def option_rel_def list_rel_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x. \\<exists>y. (x, y) \\<in> R1;\n        \\<forall>x. \\<exists>y. (x, y) \\<in> R2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>a.\n                                x = Inl a \\<and>\n                                (\\<exists>a'.\n                                    y = Inl a' \\<and>\n                                    (a, a') \\<in> R1)) \\<or>\n                            (\\<exists>a.\n                                x = Inr a \\<and>\n                                (\\<exists>a'.\n                                    y = Inr a' \\<and> (a, a') \\<in> R2))\n 2. \\<And>x.\n       \\<forall>x. \\<exists>y. (x, y) \\<in> R \\<Longrightarrow>\n       \\<exists>y.\n          x = None \\<and> y = None \\<or>\n          (\\<exists>a.\n              x = Some a \\<and>\n              (\\<exists>a'. y = Some a' \\<and> (a, a') \\<in> R))", "apply (rename_tac x; case_tac x; auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>x. \\<exists>y. (x, y) \\<in> R \\<Longrightarrow>\n       \\<exists>y.\n          x = None \\<and> y = None \\<or>\n          (\\<exists>a.\n              x = Some a \\<and>\n              (\\<exists>a'. y = Some a' \\<and> (a, a') \\<in> R))", "apply (rename_tac x; case_tac x; auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [safe_constraint_rules]: \"IS_LEFT_TOTAL R \\<Longrightarrow> IS_LEFT_TOTAL (\\<langle>R\\<rangle>list_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IS_LEFT_TOTAL R \\<Longrightarrow>\n    IS_LEFT_TOTAL (\\<langle>R\\<rangle>list_rel)", "unfolding IS_LEFT_TOTAL_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. \\<exists>y. (x, y) \\<in> R \\<Longrightarrow>\n    \\<forall>x. \\<exists>y. (x, y) \\<in> \\<langle>R\\<rangle>list_rel", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>x. \\<exists>y. (x, y) \\<in> R \\<Longrightarrow>\n       \\<exists>y. (x, y) \\<in> \\<langle>R\\<rangle>list_rel", "assume A: \"\\<forall>x.\\<exists>y. (x,y)\\<in>R\""], ["proof (state)\nthis:\n  \\<forall>x. \\<exists>y. (x, y) \\<in> R\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>x. \\<exists>y. (x, y) \\<in> R \\<Longrightarrow>\n       \\<exists>y. (x, y) \\<in> \\<langle>R\\<rangle>list_rel", "fix l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>x. \\<exists>y. (x, y) \\<in> R \\<Longrightarrow>\n       \\<exists>y. (x, y) \\<in> \\<langle>R\\<rangle>list_rel", "show \"\\<exists>l'. (l,l')\\<in>\\<langle>R\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l'. (l, l') \\<in> \\<langle>R\\<rangle>list_rel", "apply (induction l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>l'. ([], l') \\<in> \\<langle>R\\<rangle>list_rel\n 2. \\<And>a l.\n       \\<exists>l'.\n          (l, l') \\<in> \\<langle>R\\<rangle>list_rel \\<Longrightarrow>\n       \\<exists>l'. (a # l, l') \\<in> \\<langle>R\\<rangle>list_rel", "using A"], ["proof (prove)\nusing this:\n  \\<forall>x. \\<exists>y. (x, y) \\<in> R\n\ngoal (2 subgoals):\n 1. \\<exists>l'. ([], l') \\<in> \\<langle>R\\<rangle>list_rel\n 2. \\<And>a l.\n       \\<exists>l'.\n          (l, l') \\<in> \\<langle>R\\<rangle>list_rel \\<Longrightarrow>\n       \\<exists>l'. (a # l, l') \\<in> \\<langle>R\\<rangle>list_rel", "by (auto simp: list_rel_split_right_iff)"], ["proof (state)\nthis:\n  \\<exists>l'. (l, l') \\<in> \\<langle>R\\<rangle>list_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma [safe_constraint_rules]:\n  \"IS_RIGHT_TOTAL Id\"\n  \"IS_RIGHT_TOTAL R1 \\<Longrightarrow> IS_RIGHT_TOTAL R2 \\<Longrightarrow> IS_RIGHT_TOTAL (R1\\<times>\\<^sub>rR2)\"\n  \"IS_RIGHT_TOTAL R1 \\<Longrightarrow> IS_RIGHT_TOTAL R2 \\<Longrightarrow> IS_RIGHT_TOTAL (\\<langle>R1,R2\\<rangle>sum_rel)\"\n  \"IS_RIGHT_TOTAL R \\<Longrightarrow> IS_RIGHT_TOTAL (\\<langle>R\\<rangle>option_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (IS_RIGHT_TOTAL Id &&&\n     (\\<lbrakk>IS_RIGHT_TOTAL R1; IS_RIGHT_TOTAL R2\\<rbrakk>\n      \\<Longrightarrow> IS_RIGHT_TOTAL (R1 \\<times>\\<^sub>r R2))) &&&\n    (\\<lbrakk>IS_RIGHT_TOTAL R1; IS_RIGHT_TOTAL R2\\<rbrakk>\n     \\<Longrightarrow> IS_RIGHT_TOTAL (\\<langle>R1, R2\\<rangle>sum_rel)) &&&\n    (IS_RIGHT_TOTAL R \\<Longrightarrow>\n     IS_RIGHT_TOTAL (\\<langle>R\\<rangle>option_rel))", "apply (auto simp: IS_RIGHT_TOTAL_alt sum_rel_def option_rel_def) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>IS_RIGHT_TOTAL R1; IS_RIGHT_TOTAL R2\\<rbrakk>\n    \\<Longrightarrow> IS_RIGHT_TOTAL (R1 \\<times>\\<^sub>r R2)\n 2. \\<lbrakk>IS_RIGHT_TOTAL R1; IS_RIGHT_TOTAL R2\\<rbrakk>\n    \\<Longrightarrow> IS_RIGHT_TOTAL (\\<langle>R1, R2\\<rangle>sum_rel)\n 3. IS_RIGHT_TOTAL R \\<Longrightarrow>\n    IS_RIGHT_TOTAL (\\<langle>R\\<rangle>option_rel)", "apply (auto simp: IS_RIGHT_TOTAL_alt sum_rel_def option_rel_def) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>IS_RIGHT_TOTAL R1; IS_RIGHT_TOTAL R2\\<rbrakk>\n    \\<Longrightarrow> IS_RIGHT_TOTAL (\\<langle>R1, R2\\<rangle>sum_rel)\n 2. IS_RIGHT_TOTAL R \\<Longrightarrow>\n    IS_RIGHT_TOTAL (\\<langle>R\\<rangle>option_rel)", "apply (auto simp: IS_RIGHT_TOTAL_alt sum_rel_def option_rel_def) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x. \\<exists>y. (y, x) \\<in> R1;\n        \\<forall>x. \\<exists>y. (y, x) \\<in> R2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>a.\n                                y = Inl a \\<and>\n                                (\\<exists>a'.\n                                    x = Inl a' \\<and>\n                                    (a, a') \\<in> R1)) \\<or>\n                            (\\<exists>a.\n                                y = Inr a \\<and>\n                                (\\<exists>a'.\n                                    x = Inr a' \\<and> (a, a') \\<in> R2))\n 2. IS_RIGHT_TOTAL R \\<Longrightarrow>\n    IS_RIGHT_TOTAL (\\<langle>R\\<rangle>option_rel)", "apply (rename_tac x; case_tac x; auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. IS_RIGHT_TOTAL R \\<Longrightarrow>\n    IS_RIGHT_TOTAL (\\<langle>R\\<rangle>option_rel)", "apply (clarsimp simp: IS_RIGHT_TOTAL_alt option_rel_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>x. \\<exists>y. (y, x) \\<in> R \\<Longrightarrow>\n       \\<exists>y.\n          y = None \\<and> x = None \\<or>\n          (\\<exists>a.\n              y = Some a \\<and>\n              (\\<exists>a'. x = Some a' \\<and> (a, a') \\<in> R))", "apply (rename_tac x; case_tac x; auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [safe_constraint_rules]: \"IS_RIGHT_TOTAL R \\<Longrightarrow> IS_RIGHT_TOTAL (\\<langle>R\\<rangle>list_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IS_RIGHT_TOTAL R \\<Longrightarrow>\n    IS_RIGHT_TOTAL (\\<langle>R\\<rangle>list_rel)", "unfolding IS_RIGHT_TOTAL_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. \\<exists>y. (y, x) \\<in> R \\<Longrightarrow>\n    \\<forall>x. \\<exists>y. (y, x) \\<in> \\<langle>R\\<rangle>list_rel", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>x. \\<exists>y. (y, x) \\<in> R \\<Longrightarrow>\n       \\<exists>y. (y, x) \\<in> \\<langle>R\\<rangle>list_rel", "assume A: \"\\<forall>x.\\<exists>y. (y,x)\\<in>R\""], ["proof (state)\nthis:\n  \\<forall>x. \\<exists>y. (y, x) \\<in> R\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>x. \\<exists>y. (y, x) \\<in> R \\<Longrightarrow>\n       \\<exists>y. (y, x) \\<in> \\<langle>R\\<rangle>list_rel", "fix l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>x. \\<exists>y. (y, x) \\<in> R \\<Longrightarrow>\n       \\<exists>y. (y, x) \\<in> \\<langle>R\\<rangle>list_rel", "show \"\\<exists>l'. (l',l)\\<in>\\<langle>R\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l'. (l', l) \\<in> \\<langle>R\\<rangle>list_rel", "apply (induction l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>l'. (l', []) \\<in> \\<langle>R\\<rangle>list_rel\n 2. \\<And>a l.\n       \\<exists>l'.\n          (l', l) \\<in> \\<langle>R\\<rangle>list_rel \\<Longrightarrow>\n       \\<exists>l'. (l', a # l) \\<in> \\<langle>R\\<rangle>list_rel", "using A"], ["proof (prove)\nusing this:\n  \\<forall>x. \\<exists>y. (y, x) \\<in> R\n\ngoal (2 subgoals):\n 1. \\<exists>l'. (l', []) \\<in> \\<langle>R\\<rangle>list_rel\n 2. \\<And>a l.\n       \\<exists>l'.\n          (l', l) \\<in> \\<langle>R\\<rangle>list_rel \\<Longrightarrow>\n       \\<exists>l'. (l', a # l) \\<in> \\<langle>R\\<rangle>list_rel", "by (auto simp: list_rel_split_left_iff)"], ["proof (state)\nthis:\n  \\<exists>l'. (l', l) \\<in> \\<langle>R\\<rangle>list_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma [constraint_simps]:\n  \"IS_LEFT_TOTAL (R\\<inverse>) \\<longleftrightarrow> IS_RIGHT_TOTAL R \"\n  \"IS_RIGHT_TOTAL (R\\<inverse>) \\<longleftrightarrow> IS_LEFT_TOTAL R  \"\n  \"IS_LEFT_UNIQUE (R\\<inverse>) \\<longleftrightarrow> IS_RIGHT_UNIQUE R\"\n  \"IS_RIGHT_UNIQUE (R\\<inverse>) \\<longleftrightarrow> IS_LEFT_UNIQUE R \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (IS_LEFT_TOTAL (R\\<inverse>) = IS_RIGHT_TOTAL R &&&\n     IS_RIGHT_TOTAL (R\\<inverse>) = IS_LEFT_TOTAL R) &&&\n    IS_LEFT_UNIQUE (R\\<inverse>) = single_valued R &&&\n    single_valued (R\\<inverse>) = IS_LEFT_UNIQUE R", "by (auto simp: IS_RIGHT_TOTAL_alt IS_LEFT_TOTAL_alt IS_LEFT_UNIQUE_def)"], ["", "lemma [safe_constraint_rules]:\n  \"IS_RIGHT_UNIQUE A \\<Longrightarrow> IS_RIGHT_TOTAL B \\<Longrightarrow> IS_RIGHT_TOTAL (A\\<rightarrow>B)\"\n  \"IS_RIGHT_TOTAL A \\<Longrightarrow> IS_RIGHT_UNIQUE B \\<Longrightarrow> IS_RIGHT_UNIQUE (A\\<rightarrow>B)\"\n  \"IS_LEFT_UNIQUE A \\<Longrightarrow> IS_LEFT_TOTAL B \\<Longrightarrow> IS_LEFT_TOTAL (A\\<rightarrow>B)\"\n  \"IS_LEFT_TOTAL A \\<Longrightarrow> IS_LEFT_UNIQUE B \\<Longrightarrow> IS_LEFT_UNIQUE (A\\<rightarrow>B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>single_valued A; IS_RIGHT_TOTAL B\\<rbrakk>\n      \\<Longrightarrow> IS_RIGHT_TOTAL (A \\<rightarrow> B)) &&&\n     (\\<lbrakk>IS_RIGHT_TOTAL A; single_valued B\\<rbrakk>\n      \\<Longrightarrow> single_valued (A \\<rightarrow> B))) &&&\n    (\\<lbrakk>IS_LEFT_UNIQUE A; IS_LEFT_TOTAL B\\<rbrakk>\n     \\<Longrightarrow> IS_LEFT_TOTAL (A \\<rightarrow> B)) &&&\n    (\\<lbrakk>IS_LEFT_TOTAL A; IS_LEFT_UNIQUE B\\<rbrakk>\n     \\<Longrightarrow> IS_LEFT_UNIQUE (A \\<rightarrow> B))", "apply (simp_all add: prop2p rel2p)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>right_unique (rel2p A); right_total (rel2p B)\\<rbrakk>\n    \\<Longrightarrow> right_total (rel_fun (rel2p A) (rel2p B))\n 2. \\<lbrakk>right_total (rel2p A); right_unique (rel2p B)\\<rbrakk>\n    \\<Longrightarrow> right_unique (rel_fun (rel2p A) (rel2p B))\n 3. \\<lbrakk>left_unique (rel2p A); left_total (rel2p B)\\<rbrakk>\n    \\<Longrightarrow> left_total (rel_fun (rel2p A) (rel2p B))\n 4. \\<lbrakk>left_total (rel2p A); left_unique (rel2p B)\\<rbrakk>\n    \\<Longrightarrow> left_unique (rel_fun (rel2p A) (rel2p B))", "(*apply transfer_step TODO: Isabelle 2016 *)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>right_unique (rel2p A); right_total (rel2p B)\\<rbrakk>\n    \\<Longrightarrow> right_total (rel_fun (rel2p A) (rel2p B))\n 2. \\<lbrakk>right_total (rel2p A); right_unique (rel2p B)\\<rbrakk>\n    \\<Longrightarrow> right_unique (rel_fun (rel2p A) (rel2p B))\n 3. \\<lbrakk>left_unique (rel2p A); left_total (rel2p B)\\<rbrakk>\n    \\<Longrightarrow> left_total (rel_fun (rel2p A) (rel2p B))\n 4. \\<lbrakk>left_total (rel2p A); left_unique (rel2p B)\\<rbrakk>\n    \\<Longrightarrow> left_unique (rel_fun (rel2p A) (rel2p B))", "apply (blast intro!: transfer_raw)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [constraint_rules]: \n  \"IS_BELOW_ID R \\<Longrightarrow> IS_RIGHT_UNIQUE R\"\n  \"IS_BELOW_ID R \\<Longrightarrow> IS_LEFT_UNIQUE R\"\n  \"IS_ID R \\<Longrightarrow> IS_RIGHT_TOTAL R\"\n  \"IS_ID R \\<Longrightarrow> IS_LEFT_TOTAL R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((IS_BELOW_ID R \\<Longrightarrow> single_valued R) &&&\n     (IS_BELOW_ID R \\<Longrightarrow> IS_LEFT_UNIQUE R)) &&&\n    (IS_ID R \\<Longrightarrow> IS_RIGHT_TOTAL R) &&&\n    (IS_ID R \\<Longrightarrow> IS_LEFT_TOTAL R)", "by (auto simp: IS_BELOW_ID_def IS_ID_def IS_LEFT_UNIQUE_def IS_RIGHT_TOTAL_def IS_LEFT_TOTAL_def\n    intro: single_valuedI)"], ["", "thm constraint_rules"], ["", "subsubsection \\<open>Additional Parametricity Lemmas\\<close>"], ["", "(* TODO: Move. Problem: Depend on IS_LEFT_UNIQUE, which has to be moved to!*)"], ["", "lemma param_distinct[param]: \"\\<lbrakk>IS_LEFT_UNIQUE A; IS_RIGHT_UNIQUE A\\<rbrakk> \\<Longrightarrow> (distinct, distinct) \\<in> \\<langle>A\\<rangle>list_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>IS_LEFT_UNIQUE A; single_valued A\\<rbrakk>\n    \\<Longrightarrow> (distinct, distinct)\n                      \\<in> \\<langle>A\\<rangle>list_rel \\<rightarrow>\n                            bool_rel", "apply (fold rel2p_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>IS_LEFT_UNIQUE A; single_valued A\\<rbrakk>\n    \\<Longrightarrow> rel2p\n                       (\\<langle>A\\<rangle>list_rel \\<rightarrow> bool_rel)\n                       distinct distinct", "apply (simp add: rel2p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>IS_LEFT_UNIQUE A; single_valued A\\<rbrakk>\n    \\<Longrightarrow> rel_fun (list_all2 (rel2p A)) (=) distinct distinct", "apply (rule distinct_transfer)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>IS_LEFT_UNIQUE A; single_valued A\\<rbrakk>\n    \\<Longrightarrow> bi_unique (rel2p A)", "apply (simp add: p2prop)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma param_Image[param]: \n  assumes \"IS_LEFT_UNIQUE A\" \"IS_RIGHT_UNIQUE A\"\n  shows \"((``), (``)) \\<in> \\<langle>A\\<times>\\<^sub>rB\\<rangle>set_rel \\<rightarrow> \\<langle>A\\<rangle>set_rel \\<rightarrow> \\<langle>B\\<rangle>set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((``), (``))\n    \\<in> \\<langle>A \\<times>\\<^sub>r B\\<rangle>set_rel \\<rightarrow>\n          \\<langle>A\\<rangle>set_rel \\<rightarrow>\n          \\<langle>B\\<rangle>set_rel", "apply (clarsimp simp: set_rel_def; intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>\\<forall>x\\<in>a.\n                   \\<exists>y\\<in>a'. (x, y) \\<in> A \\<times>\\<^sub>r B;\n        \\<forall>y\\<in>a'.\n           \\<exists>x\\<in>a. (x, y) \\<in> A \\<times>\\<^sub>r B;\n        \\<forall>x\\<in>aa. \\<exists>y\\<in>a'a. (x, y) \\<in> A;\n        \\<forall>y\\<in>a'a. \\<exists>x\\<in>aa. (x, y) \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>a `` aa.\n                            \\<exists>y\\<in>a' `` a'a. (x, y) \\<in> B\n 2. \\<And>a a' aa a'a.\n       \\<lbrakk>\\<forall>x\\<in>a.\n                   \\<exists>y\\<in>a'. (x, y) \\<in> A \\<times>\\<^sub>r B;\n        \\<forall>y\\<in>a'.\n           \\<exists>x\\<in>a. (x, y) \\<in> A \\<times>\\<^sub>r B;\n        \\<forall>x\\<in>aa. \\<exists>y\\<in>a'a. (x, y) \\<in> A;\n        \\<forall>y\\<in>a'a. \\<exists>x\\<in>aa. (x, y) \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<forall>y\\<in>a' `` a'a.\n                            \\<exists>x\\<in>a `` aa. (x, y) \\<in> B", "apply (fastforce dest: IS_RIGHT_UNIQUED[OF assms(2)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>\\<forall>x\\<in>a.\n                   \\<exists>y\\<in>a'. (x, y) \\<in> A \\<times>\\<^sub>r B;\n        \\<forall>y\\<in>a'.\n           \\<exists>x\\<in>a. (x, y) \\<in> A \\<times>\\<^sub>r B;\n        \\<forall>x\\<in>aa. \\<exists>y\\<in>a'a. (x, y) \\<in> A;\n        \\<forall>y\\<in>a'a. \\<exists>x\\<in>aa. (x, y) \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<forall>y\\<in>a' `` a'a.\n                            \\<exists>x\\<in>a `` aa. (x, y) \\<in> B", "apply (fastforce dest: IS_LEFT_UNIQUED[OF assms(1)])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pres_eq_iff_svb: \"((=),(=))\\<in>K\\<rightarrow>K\\<rightarrow>bool_rel \\<longleftrightarrow> (single_valued K \\<and> single_valued (K\\<inverse>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((=), (=)) \\<in> K \\<rightarrow> K \\<rightarrow> bool_rel) =\n    (single_valued K \\<and> single_valued (K\\<inverse>))", "apply (safe intro!: single_valuedI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>((=), (=)) \\<in> K \\<rightarrow> K \\<rightarrow> bool_rel;\n        (x, y) \\<in> K; (x, z) \\<in> K\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>x y z.\n       \\<lbrakk>((=), (=)) \\<in> K \\<rightarrow> K \\<rightarrow> bool_rel;\n        (y, x) \\<in> K; (z, x) \\<in> K\\<rbrakk>\n       \\<Longrightarrow> y = z\n 3. \\<And>a a' aa a'a.\n       \\<lbrakk>(aa, a') \\<in> K; (aa, a'a) \\<in> K; single_valued K;\n        single_valued (K\\<inverse>)\\<rbrakk>\n       \\<Longrightarrow> a' = a'a\n 4. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a'a) \\<in> K; (aa, a'a) \\<in> K; single_valued K;\n        single_valued (K\\<inverse>)\\<rbrakk>\n       \\<Longrightarrow> a = aa", "apply (metis (full_types) IdD fun_relD1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>((=), (=)) \\<in> K \\<rightarrow> K \\<rightarrow> bool_rel;\n        (y, x) \\<in> K; (z, x) \\<in> K\\<rbrakk>\n       \\<Longrightarrow> y = z\n 2. \\<And>a a' aa a'a.\n       \\<lbrakk>(aa, a') \\<in> K; (aa, a'a) \\<in> K; single_valued K;\n        single_valued (K\\<inverse>)\\<rbrakk>\n       \\<Longrightarrow> a' = a'a\n 3. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a'a) \\<in> K; (aa, a'a) \\<in> K; single_valued K;\n        single_valued (K\\<inverse>)\\<rbrakk>\n       \\<Longrightarrow> a = aa", "apply (metis (full_types) IdD fun_relD1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(aa, a') \\<in> K; (aa, a'a) \\<in> K; single_valued K;\n        single_valued (K\\<inverse>)\\<rbrakk>\n       \\<Longrightarrow> a' = a'a\n 2. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a'a) \\<in> K; (aa, a'a) \\<in> K; single_valued K;\n        single_valued (K\\<inverse>)\\<rbrakk>\n       \\<Longrightarrow> a = aa", "by (auto dest: single_valuedD)"], ["", "definition \"IS_PRES_EQ R \\<equiv> ((=), (=))\\<in>R\\<rightarrow>R\\<rightarrow>bool_rel\""], ["", "lemma [constraint_rules]: \"\\<lbrakk>single_valued R; single_valued (R\\<inverse>)\\<rbrakk> \\<Longrightarrow> IS_PRES_EQ R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued R; single_valued (R\\<inverse>)\\<rbrakk>\n    \\<Longrightarrow> IS_PRES_EQ R", "by (simp add: pres_eq_iff_svb IS_PRES_EQ_def)"], ["", "subsection \\<open>Bounded Assertions\\<close>"], ["", "definition \"b_rel R P \\<equiv> R \\<inter> UNIV\\<times>Collect P\""], ["", "definition \"b_assn A P \\<equiv> \\<lambda>x y. A x y * \\<up>(P x)\""], ["", "lemma b_assn_pure_conv[constraint_simps]: \"b_assn (pure R) P = pure (b_rel R P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b_assn (pure R) P = pure (b_rel R P)", "by (auto intro!: ext simp: b_rel_def b_assn_def pure_def)"], ["", "lemmas [sepref_import_rewrite, sepref_frame_normrel_eqs, fcomp_norm_unfold] \n  = b_assn_pure_conv[symmetric]"], ["", "lemma b_rel_nesting[simp]: \n  \"b_rel (b_rel R P1) P2 = b_rel R (\\<lambda>x. P1 x \\<and> P2 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b_rel (b_rel R P1) P2 = b_rel R (\\<lambda>x. P1 x \\<and> P2 x)", "by (auto simp: b_rel_def)"], ["", "lemma b_rel_triv[simp]: \n  \"b_rel R (\\<lambda>_. True) = R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b_rel R (\\<lambda>_. True) = R", "by (auto simp: b_rel_def)"], ["", "lemma b_assn_nesting[simp]: \n  \"b_assn (b_assn A P1) P2 = b_assn A (\\<lambda>x. P1 x \\<and> P2 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b_assn (b_assn A P1) P2 = b_assn A (\\<lambda>x. P1 x \\<and> P2 x)", "by (auto simp: b_assn_def pure_def intro!: ext)"], ["", "lemma b_assn_triv[simp]: \n  \"b_assn A (\\<lambda>_. True) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b_assn A (\\<lambda>_. True) = A", "by (auto simp: b_assn_def pure_def intro!: ext)"], ["", "lemmas [simp,constraint_simps,sepref_import_rewrite, sepref_frame_normrel_eqs, fcomp_norm_unfold]\n  = b_rel_nesting b_assn_nesting"], ["", "lemma b_rel_simp[simp]: \"(x,y)\\<in>b_rel R P \\<longleftrightarrow> (x,y)\\<in>R \\<and> P y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x, y) \\<in> b_rel R P) = ((x, y) \\<in> R \\<and> P y)", "by (auto simp: b_rel_def)"], ["", "lemma b_assn_simp[simp]: \"b_assn A P x y = A x y * \\<up>(P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b_assn A P x y = A x y * \\<up> (P x)", "by (auto simp: b_assn_def)"], ["", "lemma b_rel_Range[simp]: \"Range (b_rel R P) = Range R \\<inter> Collect P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Range (b_rel R P) = Range R \\<inter> Collect P", "by auto"], ["", "lemma b_assn_rdom[simp]: \"rdomp (b_assn R P) x \\<longleftrightarrow> rdomp R x \\<and> P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rdomp (b_assn R P) x = (rdomp R x \\<and> P x)", "by (auto simp: rdomp_def)"], ["", "lemma b_rel_below_id[constraint_rules]: \n  \"IS_BELOW_ID R \\<Longrightarrow> IS_BELOW_ID (b_rel R P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IS_BELOW_ID R \\<Longrightarrow> IS_BELOW_ID (b_rel R P)", "by (auto simp: IS_BELOW_ID_def)"], ["", "lemma b_rel_left_unique[constraint_rules]: \n  \"IS_LEFT_UNIQUE R \\<Longrightarrow> IS_LEFT_UNIQUE (b_rel R P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IS_LEFT_UNIQUE R \\<Longrightarrow> IS_LEFT_UNIQUE (b_rel R P)", "by (auto simp: IS_LEFT_UNIQUE_def single_valued_def)"], ["", "lemma b_rel_right_unique[constraint_rules]: \n  \"IS_RIGHT_UNIQUE R \\<Longrightarrow> IS_RIGHT_UNIQUE (b_rel R P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued R \\<Longrightarrow> single_valued (b_rel R P)", "by (auto simp: single_valued_def)\n\n\\<comment> \\<open>Registered as safe rule, although may loose information in the \n    odd case that purity depends condition.\\<close>"], ["", "lemma b_assn_is_pure[safe_constraint_rules]:\n  \"is_pure A \\<Longrightarrow> is_pure (b_assn A P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pure A \\<Longrightarrow> is_pure (b_assn A P)", "by (auto simp: is_pure_conv b_assn_pure_conv)\n\n\\<comment> \\<open>Most general form\\<close>"], ["", "lemma b_assn_subtyping_match[sepref_frame_match_rules]:\n  assumes \"hn_ctxt (b_assn A P) x y \\<Longrightarrow>\\<^sub>t hn_ctxt A' x y\"\n  assumes \"\\<lbrakk>vassn_tag (hn_ctxt A x y); vassn_tag (hn_ctxt A' x y); P x\\<rbrakk> \\<Longrightarrow> P' x\"\n  shows \"hn_ctxt (b_assn A P) x y \\<Longrightarrow>\\<^sub>t hn_ctxt (b_assn A' P') x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_ctxt (b_assn A P) x y \\<Longrightarrow>\\<^sub>t\n    hn_ctxt (b_assn A' P') x y", "using assms"], ["proof (prove)\nusing this:\n  hn_ctxt (b_assn A P) x y \\<Longrightarrow>\\<^sub>t hn_ctxt A' x y\n  \\<lbrakk>vassn_tag (hn_ctxt A x y); vassn_tag (hn_ctxt A' x y);\n   P x\\<rbrakk>\n  \\<Longrightarrow> P' x\n\ngoal (1 subgoal):\n 1. hn_ctxt (b_assn A P) x y \\<Longrightarrow>\\<^sub>t\n    hn_ctxt (b_assn A' P') x y", "unfolding hn_ctxt_def b_assn_def entailst_def entails_def"], ["proof (prove)\nusing this:\n  \\<forall>h.\n     h \\<Turnstile> A x y * \\<up> (P x) \\<longrightarrow>\n     h \\<Turnstile> A' x y * true\n  \\<lbrakk>vassn_tag (A x y); vassn_tag (A' x y); P x\\<rbrakk>\n  \\<Longrightarrow> P' x\n\ngoal (1 subgoal):\n 1. \\<forall>h.\n       h \\<Turnstile> A x y * \\<up> (P x) \\<longrightarrow>\n       h \\<Turnstile> A' x y * \\<up> (P' x) * true", "by (fastforce simp: vassn_tag_def mod_star_conv)\n  \n\\<comment> \\<open>Simplified forms:\\<close>"], ["", "lemma b_assn_subtyping_match_eqA[sepref_frame_match_rules]:\n  assumes \"\\<lbrakk>vassn_tag (hn_ctxt A x y); P x\\<rbrakk> \\<Longrightarrow> P' x\"\n  shows \"hn_ctxt (b_assn A P) x y \\<Longrightarrow>\\<^sub>t hn_ctxt (b_assn A P') x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_ctxt (b_assn A P) x y \\<Longrightarrow>\\<^sub>t\n    hn_ctxt (b_assn A P') x y", "apply (rule b_assn_subtyping_match)"], ["proof (prove)\ngoal (2 subgoals):\n 1. hn_ctxt (b_assn A P) x y \\<Longrightarrow>\\<^sub>t hn_ctxt A x y\n 2. \\<lbrakk>vassn_tag (hn_ctxt A x y); vassn_tag (hn_ctxt A x y);\n     P x\\<rbrakk>\n    \\<Longrightarrow> P' x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_ctxt (b_assn A P) x y \\<Longrightarrow>\\<^sub>t hn_ctxt A x y", "unfolding hn_ctxt_def b_assn_def entailst_def entails_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h.\n       h \\<Turnstile> A x y * \\<up> (P x) \\<longrightarrow>\n       h \\<Turnstile> A x y * true", "by (fastforce simp: vassn_tag_def mod_star_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vassn_tag (hn_ctxt A x y); vassn_tag (hn_ctxt A x y);\n     P x\\<rbrakk>\n    \\<Longrightarrow> P' x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vassn_tag (hn_ctxt A x y); vassn_tag (hn_ctxt A x y);\n     P x\\<rbrakk>\n    \\<Longrightarrow> P' x", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>vassn_tag (hn_ctxt A x y); P x\\<rbrakk> \\<Longrightarrow> P' x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>vassn_tag (hn_ctxt A x y); vassn_tag (hn_ctxt A x y);\n     P x\\<rbrakk>\n    \\<Longrightarrow> P' x", "."], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma b_assn_subtyping_match_tR[sepref_frame_match_rules]:\n  assumes \"\\<lbrakk>P x\\<rbrakk> \\<Longrightarrow> hn_ctxt A x y \\<Longrightarrow>\\<^sub>t hn_ctxt A' x y\"\n  shows \"hn_ctxt (b_assn A P) x y \\<Longrightarrow>\\<^sub>t hn_ctxt A' x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_ctxt (b_assn A P) x y \\<Longrightarrow>\\<^sub>t hn_ctxt A' x y", "using assms"], ["proof (prove)\nusing this:\n  P x \\<Longrightarrow>\n  hn_ctxt A x y \\<Longrightarrow>\\<^sub>t hn_ctxt A' x y\n\ngoal (1 subgoal):\n 1. hn_ctxt (b_assn A P) x y \\<Longrightarrow>\\<^sub>t hn_ctxt A' x y", "unfolding hn_ctxt_def b_assn_def entailst_def entails_def"], ["proof (prove)\nusing this:\n  P x \\<Longrightarrow>\n  \\<forall>h.\n     h \\<Turnstile> A x y \\<longrightarrow> h \\<Turnstile> A' x y * true\n\ngoal (1 subgoal):\n 1. \\<forall>h.\n       h \\<Turnstile> A x y * \\<up> (P x) \\<longrightarrow>\n       h \\<Turnstile> A' x y * true", "by (fastforce simp: vassn_tag_def mod_star_conv)"], ["", "lemma b_assn_subtyping_match_tL[sepref_frame_match_rules]:\n  assumes \"hn_ctxt A x y \\<Longrightarrow>\\<^sub>t hn_ctxt A' x y\"\n  assumes \"\\<lbrakk>vassn_tag (hn_ctxt A x y)\\<rbrakk> \\<Longrightarrow> P' x\"\n  shows \"hn_ctxt A x y \\<Longrightarrow>\\<^sub>t hn_ctxt (b_assn A' P') x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_ctxt A x y \\<Longrightarrow>\\<^sub>t hn_ctxt (b_assn A' P') x y", "using assms"], ["proof (prove)\nusing this:\n  hn_ctxt A x y \\<Longrightarrow>\\<^sub>t hn_ctxt A' x y\n  vassn_tag (hn_ctxt A x y) \\<Longrightarrow> P' x\n\ngoal (1 subgoal):\n 1. hn_ctxt A x y \\<Longrightarrow>\\<^sub>t hn_ctxt (b_assn A' P') x y", "unfolding hn_ctxt_def b_assn_def entailst_def entails_def"], ["proof (prove)\nusing this:\n  \\<forall>h.\n     h \\<Turnstile> A x y \\<longrightarrow> h \\<Turnstile> A' x y * true\n  vassn_tag (A x y) \\<Longrightarrow> P' x\n\ngoal (1 subgoal):\n 1. \\<forall>h.\n       h \\<Turnstile> A x y \\<longrightarrow>\n       h \\<Turnstile> A' x y * \\<up> (P' x) * true", "by (fastforce simp: vassn_tag_def mod_star_conv)"], ["", "lemma b_assn_subtyping_match_eqA_tR[sepref_frame_match_rules]: \n  \"hn_ctxt (b_assn A P) x y \\<Longrightarrow>\\<^sub>t hn_ctxt A x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_ctxt (b_assn A P) x y \\<Longrightarrow>\\<^sub>t hn_ctxt A x y", "unfolding hn_ctxt_def b_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A x y * \\<up> (P x) \\<Longrightarrow>\\<^sub>t A x y", "by (sep_auto intro!: enttI)"], ["", "lemma b_assn_subtyping_match_eqA_tL[sepref_frame_match_rules]:\n  assumes \"\\<lbrakk>vassn_tag (hn_ctxt A x y)\\<rbrakk> \\<Longrightarrow> P' x\"\n  shows \"hn_ctxt A x y \\<Longrightarrow>\\<^sub>t hn_ctxt (b_assn A P') x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_ctxt A x y \\<Longrightarrow>\\<^sub>t hn_ctxt (b_assn A P') x y", "using assms"], ["proof (prove)\nusing this:\n  vassn_tag (hn_ctxt A x y) \\<Longrightarrow> P' x\n\ngoal (1 subgoal):\n 1. hn_ctxt A x y \\<Longrightarrow>\\<^sub>t hn_ctxt (b_assn A P') x y", "unfolding hn_ctxt_def b_assn_def entailst_def entails_def"], ["proof (prove)\nusing this:\n  vassn_tag (A x y) \\<Longrightarrow> P' x\n\ngoal (1 subgoal):\n 1. \\<forall>h.\n       h \\<Turnstile> A x y \\<longrightarrow>\n       h \\<Turnstile> A x y * \\<up> (P' x) * true", "by (fastforce simp: vassn_tag_def mod_star_conv)\n\n\\<comment> \\<open>General form\\<close>"], ["", "lemma b_rel_subtyping_merge[sepref_frame_merge_rules]:\n  assumes \"hn_ctxt A x y \\<or>\\<^sub>A hn_ctxt A' x y \\<Longrightarrow>\\<^sub>t hn_ctxt Am x y\"\n  shows \"hn_ctxt (b_assn A P) x y \\<or>\\<^sub>A hn_ctxt (b_assn A' P') x y \\<Longrightarrow>\\<^sub>t hn_ctxt (b_assn Am (\\<lambda>x. P x \\<or> P' x)) x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_ctxt (b_assn A P) x y \\<or>\\<^sub>A\n    hn_ctxt (b_assn A' P') x y \\<Longrightarrow>\\<^sub>t\n    hn_ctxt (b_assn Am (\\<lambda>x. P x \\<or> P' x)) x y", "using assms"], ["proof (prove)\nusing this:\n  hn_ctxt A x y \\<or>\\<^sub>A hn_ctxt A' x y \\<Longrightarrow>\\<^sub>t\n  hn_ctxt Am x y\n\ngoal (1 subgoal):\n 1. hn_ctxt (b_assn A P) x y \\<or>\\<^sub>A\n    hn_ctxt (b_assn A' P') x y \\<Longrightarrow>\\<^sub>t\n    hn_ctxt (b_assn Am (\\<lambda>x. P x \\<or> P' x)) x y", "unfolding hn_ctxt_def b_assn_def entailst_def entails_def"], ["proof (prove)\nusing this:\n  \\<forall>h.\n     h \\<Turnstile> A x y \\<or>\\<^sub>A A' x y \\<longrightarrow>\n     h \\<Turnstile> Am x y * true\n\ngoal (1 subgoal):\n 1. \\<forall>h.\n       h \\<Turnstile>\n       A x y * \\<up> (P x) \\<or>\\<^sub>A\n       A' x y * \\<up> (P' x) \\<longrightarrow>\n       h \\<Turnstile> Am x y * \\<up> (P x \\<or> P' x) * true", "by (fastforce simp: vassn_tag_def)\n  \n\\<comment> \\<open>Simplified forms\\<close>"], ["", "lemma b_rel_subtyping_merge_eqA[sepref_frame_merge_rules]:\n  shows \"hn_ctxt (b_assn A P) x y \\<or>\\<^sub>A hn_ctxt (b_assn A P') x y \\<Longrightarrow>\\<^sub>t hn_ctxt (b_assn A (\\<lambda>x. P x \\<or> P' x)) x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_ctxt (b_assn A P) x y \\<or>\\<^sub>A\n    hn_ctxt (b_assn A P') x y \\<Longrightarrow>\\<^sub>t\n    hn_ctxt (b_assn A (\\<lambda>x. P x \\<or> P' x)) x y", "apply (rule b_rel_subtyping_merge)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_ctxt A x y \\<or>\\<^sub>A hn_ctxt A x y \\<Longrightarrow>\\<^sub>t\n    hn_ctxt A x y", "by simp"], ["", "lemma b_rel_subtyping_merge_tL[sepref_frame_merge_rules]:\n  assumes \"hn_ctxt A x y \\<or>\\<^sub>A hn_ctxt A' x y \\<Longrightarrow>\\<^sub>t hn_ctxt Am x y\"\n  shows \"hn_ctxt A x y \\<or>\\<^sub>A hn_ctxt (b_assn A' P') x y \\<Longrightarrow>\\<^sub>t hn_ctxt Am x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_ctxt A x y \\<or>\\<^sub>A\n    hn_ctxt (b_assn A' P') x y \\<Longrightarrow>\\<^sub>t\n    hn_ctxt Am x y", "using b_rel_subtyping_merge[of A x y A' Am \"\\<lambda>_. True\" P', simplified] assms"], ["proof (prove)\nusing this:\n  hn_ctxt A x y \\<or>\\<^sub>A hn_ctxt A' x y \\<Longrightarrow>\\<^sub>t\n  hn_ctxt Am x y \\<Longrightarrow>\n  hn_ctxt A x y \\<or>\\<^sub>A\n  hn_ctxt (b_assn A' P') x y \\<Longrightarrow>\\<^sub>t\n  hn_ctxt Am x y\n  hn_ctxt A x y \\<or>\\<^sub>A hn_ctxt A' x y \\<Longrightarrow>\\<^sub>t\n  hn_ctxt Am x y\n\ngoal (1 subgoal):\n 1. hn_ctxt A x y \\<or>\\<^sub>A\n    hn_ctxt (b_assn A' P') x y \\<Longrightarrow>\\<^sub>t\n    hn_ctxt Am x y", "."], ["", "lemma b_rel_subtyping_merge_tR[sepref_frame_merge_rules]:\n  assumes \"hn_ctxt A x y \\<or>\\<^sub>A hn_ctxt A' x y \\<Longrightarrow>\\<^sub>t hn_ctxt Am x y\"\n  shows \"hn_ctxt (b_assn A P) x y \\<or>\\<^sub>A hn_ctxt A' x y \\<Longrightarrow>\\<^sub>t hn_ctxt Am x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_ctxt (b_assn A P) x y \\<or>\\<^sub>A\n    hn_ctxt A' x y \\<Longrightarrow>\\<^sub>t\n    hn_ctxt Am x y", "using b_rel_subtyping_merge[of A x y A' Am P \"\\<lambda>_. True\", simplified] assms"], ["proof (prove)\nusing this:\n  hn_ctxt A x y \\<or>\\<^sub>A hn_ctxt A' x y \\<Longrightarrow>\\<^sub>t\n  hn_ctxt Am x y \\<Longrightarrow>\n  hn_ctxt (b_assn A P) x y \\<or>\\<^sub>A\n  hn_ctxt A' x y \\<Longrightarrow>\\<^sub>t\n  hn_ctxt Am x y\n  hn_ctxt A x y \\<or>\\<^sub>A hn_ctxt A' x y \\<Longrightarrow>\\<^sub>t\n  hn_ctxt Am x y\n\ngoal (1 subgoal):\n 1. hn_ctxt (b_assn A P) x y \\<or>\\<^sub>A\n    hn_ctxt A' x y \\<Longrightarrow>\\<^sub>t\n    hn_ctxt Am x y", "."], ["", "lemma b_rel_subtyping_merge_eqA_tL[sepref_frame_merge_rules]:\n  shows \"hn_ctxt A x y \\<or>\\<^sub>A hn_ctxt (b_assn A P') x y \\<Longrightarrow>\\<^sub>t hn_ctxt A x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_ctxt A x y \\<or>\\<^sub>A\n    hn_ctxt (b_assn A P') x y \\<Longrightarrow>\\<^sub>t\n    hn_ctxt A x y", "using b_rel_subtyping_merge_eqA[of A \"\\<lambda>_. True\" x y P', simplified]"], ["proof (prove)\nusing this:\n  hn_ctxt A x y \\<or>\\<^sub>A\n  hn_ctxt (b_assn A P') x y \\<Longrightarrow>\\<^sub>t\n  hn_ctxt A x y\n\ngoal (1 subgoal):\n 1. hn_ctxt A x y \\<or>\\<^sub>A\n    hn_ctxt (b_assn A P') x y \\<Longrightarrow>\\<^sub>t\n    hn_ctxt A x y", "."], ["", "lemma b_rel_subtyping_merge_eqA_tR[sepref_frame_merge_rules]:\n  shows \"hn_ctxt (b_assn A P) x y \\<or>\\<^sub>A hn_ctxt A x y \\<Longrightarrow>\\<^sub>t hn_ctxt A x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_ctxt (b_assn A P) x y \\<or>\\<^sub>A\n    hn_ctxt A x y \\<Longrightarrow>\\<^sub>t\n    hn_ctxt A x y", "using b_rel_subtyping_merge_eqA[of A P x y \"\\<lambda>_. True\", simplified]"], ["proof (prove)\nusing this:\n  hn_ctxt (b_assn A P) x y \\<or>\\<^sub>A\n  hn_ctxt A x y \\<Longrightarrow>\\<^sub>t\n  hn_ctxt A x y\n\ngoal (1 subgoal):\n 1. hn_ctxt (b_assn A P) x y \\<or>\\<^sub>A\n    hn_ctxt A x y \\<Longrightarrow>\\<^sub>t\n    hn_ctxt A x y", "."], ["", "(* TODO: Combinatorial explosion :( *)"], ["", "lemma b_assn_invalid_merge1: \"hn_invalid (b_assn A P) x y \\<or>\\<^sub>A hn_invalid (b_assn A P') x y\n  \\<Longrightarrow>\\<^sub>t hn_invalid (b_assn A (\\<lambda>x. P x \\<or> P' x)) x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_invalid (b_assn A P) x y \\<or>\\<^sub>A\n    hn_invalid (b_assn A P') x y \\<Longrightarrow>\\<^sub>t\n    hn_invalid (b_assn A (\\<lambda>x. P x \\<or> P' x)) x y", "by (sep_auto simp: hn_ctxt_def invalid_assn_def entailst_def)"], ["", "lemma b_assn_invalid_merge2: \"hn_invalid (b_assn A P) x y \\<or>\\<^sub>A hn_invalid A x y\n  \\<Longrightarrow>\\<^sub>t hn_invalid A x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_invalid (b_assn A P) x y \\<or>\\<^sub>A\n    hn_invalid A x y \\<Longrightarrow>\\<^sub>t\n    hn_invalid A x y", "by (sep_auto simp: hn_ctxt_def invalid_assn_def entailst_def)"], ["", "lemma b_assn_invalid_merge3: \"hn_invalid A x y \\<or>\\<^sub>A hn_invalid (b_assn A P) x y\n  \\<Longrightarrow>\\<^sub>t hn_invalid A x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_invalid A x y \\<or>\\<^sub>A\n    hn_invalid (b_assn A P) x y \\<Longrightarrow>\\<^sub>t\n    hn_invalid A x y", "by (sep_auto simp: hn_ctxt_def invalid_assn_def entailst_def)"], ["", "lemma b_assn_invalid_merge4: \"hn_invalid (b_assn A P) x y \\<or>\\<^sub>A hn_ctxt (b_assn A P') x y\n  \\<Longrightarrow>\\<^sub>t hn_invalid (b_assn A (\\<lambda>x. P x \\<or> P' x)) x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_invalid (b_assn A P) x y \\<or>\\<^sub>A\n    hn_ctxt (b_assn A P') x y \\<Longrightarrow>\\<^sub>t\n    hn_invalid (b_assn A (\\<lambda>x. P x \\<or> P' x)) x y", "by (sep_auto simp: hn_ctxt_def invalid_assn_def entailst_def)"], ["", "lemma b_assn_invalid_merge5: \"hn_ctxt (b_assn A P') x y \\<or>\\<^sub>A hn_invalid (b_assn A P) x y\n  \\<Longrightarrow>\\<^sub>t hn_invalid (b_assn A (\\<lambda>x. P x \\<or> P' x)) x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_ctxt (b_assn A P') x y \\<or>\\<^sub>A\n    hn_invalid (b_assn A P) x y \\<Longrightarrow>\\<^sub>t\n    hn_invalid (b_assn A (\\<lambda>x. P x \\<or> P' x)) x y", "by (sep_auto simp: hn_ctxt_def invalid_assn_def entailst_def)"], ["", "lemma b_assn_invalid_merge6: \"hn_invalid (b_assn A P) x y \\<or>\\<^sub>A hn_ctxt A x y\n  \\<Longrightarrow>\\<^sub>t hn_invalid A x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_invalid (b_assn A P) x y \\<or>\\<^sub>A\n    hn_ctxt A x y \\<Longrightarrow>\\<^sub>t\n    hn_invalid A x y", "by (sep_auto simp: hn_ctxt_def invalid_assn_def entailst_def)"], ["", "lemma b_assn_invalid_merge7: \"hn_ctxt A x y \\<or>\\<^sub>A hn_invalid (b_assn A P) x y\n  \\<Longrightarrow>\\<^sub>t hn_invalid A x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_ctxt A x y \\<or>\\<^sub>A\n    hn_invalid (b_assn A P) x y \\<Longrightarrow>\\<^sub>t\n    hn_invalid A x y", "by (sep_auto simp: hn_ctxt_def invalid_assn_def entailst_def)"], ["", "lemma b_assn_invalid_merge8: \"hn_ctxt (b_assn A P) x y \\<or>\\<^sub>A hn_invalid A x y\n  \\<Longrightarrow>\\<^sub>t hn_invalid A x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_ctxt (b_assn A P) x y \\<or>\\<^sub>A\n    hn_invalid A x y \\<Longrightarrow>\\<^sub>t\n    hn_invalid A x y", "by (sep_auto simp: hn_ctxt_def invalid_assn_def entailst_def)"], ["", "lemma b_assn_invalid_merge9: \"hn_invalid A x y \\<or>\\<^sub>A hn_ctxt (b_assn A P) x y\n  \\<Longrightarrow>\\<^sub>t hn_invalid A x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_invalid A x y \\<or>\\<^sub>A\n    hn_ctxt (b_assn A P) x y \\<Longrightarrow>\\<^sub>t\n    hn_invalid A x y", "by (sep_auto simp: hn_ctxt_def invalid_assn_def entailst_def)"], ["", "lemmas b_assn_invalid_merge[sepref_frame_merge_rules] = \n  b_assn_invalid_merge1\n  b_assn_invalid_merge2\n  b_assn_invalid_merge3\n  b_assn_invalid_merge4\n  b_assn_invalid_merge5\n  b_assn_invalid_merge6\n  b_assn_invalid_merge7\n  b_assn_invalid_merge8\n  b_assn_invalid_merge9"], ["", "(*\nlemma list_rel_b_id: \"\\<forall>x\\<in>set l. B x \\<Longrightarrow> (l,l)\\<in>\\<langle>b_rel B\\<rangle>list_rel\"\n  by (induction l) auto\n*)"], ["", "abbreviation nbn_rel :: \"nat \\<Rightarrow> (nat \\<times> nat) set\" \n  \\<comment> \\<open>Natural numbers with upper bound.\\<close>\n  where \"nbn_rel n \\<equiv> b_rel nat_rel (\\<lambda>x::nat. x<n)\""], ["", "abbreviation nbn_assn :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> assn\" \n  \\<comment> \\<open>Natural numbers with upper bound.\\<close>\n  where \"nbn_assn n \\<equiv> b_assn nat_assn (\\<lambda>x::nat. x<n)\""], ["", "(*\nsubsection \\<open>Bounded Identity Relations\\<close>\ndefinition \"b_rel B \\<equiv> {(x,x) | x. B x}\"\n\nlemma b_rel_simp[simp]: \"(x,y)\\<in>b_rel B \\<longleftrightarrow> x=y \\<and> B y\"\n  by (auto simp: b_rel_def)\n\nlemma b_rel_Range[simp]: \"Range (b_rel B) = Collect B\" by auto\n\nlemma b_rel_below_id[safe_constraint_rules]: \"IS_BELOW_ID (b_rel B)\"\n  by (auto simp: IS_BELOW_ID_def)\n\nlemma list_rel_b_id: \"\\<forall>x\\<in>set l. B x \\<Longrightarrow> (l,l)\\<in>\\<langle>b_rel B\\<rangle>list_rel\"\n  by (induction l) auto\n\nlemma b_rel_subtyping_match[sepref_frame_match_rules]:\n  \"P x \\<Longrightarrow> hn_val Id x y \\<Longrightarrow>\\<^sub>t hn_val (b_rel P) x y\"\n  \"\\<lbrakk>P1 x \\<Longrightarrow> P2 x\\<rbrakk> \\<Longrightarrow> hn_val (b_rel P1) x y \\<Longrightarrow>\\<^sub>t hn_val (b_rel P2) x y\"\n  \"hn_val (b_rel P) x y \\<Longrightarrow>\\<^sub>t hn_val Id x y\"\n  by (auto simp: hn_ctxt_def pure_def intro: enttI)\n\nlemma b_rel_subtyping_merge[sepref_frame_merge_rules]:\n  \"hn_val Id x y \\<or>\\<^sub>A hn_val (b_rel P) x y \\<Longrightarrow>\\<^sub>t hn_val Id x y\"\n  \"hn_val (b_rel P) x y \\<or>\\<^sub>A hn_val Id x y \\<Longrightarrow>\\<^sub>t hn_val Id x y\"\n  \"hn_val (b_rel P1) x y \\<or>\\<^sub>A hn_val (b_rel P2) x y \\<Longrightarrow>\\<^sub>t hn_val (b_rel (\\<lambda>x. P1 x \\<or> P2 x)) x y\"\n  by (auto simp: hn_ctxt_def pure_def intro: enttI)\n\n\nabbreviation nbn_rel :: \"nat \\<Rightarrow> (nat \\<times> nat) set\" \n  -- \\<open>Natural numbers with upper bound.\\<close>\n  where \"nbn_rel n \\<equiv> b_rel (\\<lambda>x::nat. x<n)\"  \n\n\n*)"], ["", "subsection \\<open>Tool Setup\\<close>"], ["", "lemmas [sepref_relprops] = \n  sepref_relpropI[of IS_LEFT_UNIQUE]\n  sepref_relpropI[of IS_RIGHT_UNIQUE]\n  sepref_relpropI[of IS_LEFT_TOTAL]\n  sepref_relpropI[of IS_RIGHT_TOTAL]\n  sepref_relpropI[of is_pure]\n  sepref_relpropI[of \"IS_PURE \\<Phi>\" for \\<Phi>]\n  sepref_relpropI[of IS_ID]\n  sepref_relpropI[of IS_BELOW_ID]"], ["", "lemma [sepref_relprops_simps]:\n  \"CONSTRAINT (IS_PURE IS_ID) A \\<Longrightarrow> CONSTRAINT (IS_PURE IS_BELOW_ID) A\"\n  \"CONSTRAINT (IS_PURE IS_ID) A \\<Longrightarrow> CONSTRAINT (IS_PURE IS_LEFT_TOTAL) A\"\n  \"CONSTRAINT (IS_PURE IS_ID) A \\<Longrightarrow> CONSTRAINT (IS_PURE IS_RIGHT_TOTAL) A\"\n  \"CONSTRAINT (IS_PURE IS_BELOW_ID) A \\<Longrightarrow> CONSTRAINT (IS_PURE IS_LEFT_UNIQUE) A\"\n  \"CONSTRAINT (IS_PURE IS_BELOW_ID) A \\<Longrightarrow> CONSTRAINT (IS_PURE IS_RIGHT_UNIQUE) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((CONSTRAINT (IS_PURE IS_ID) A \\<Longrightarrow>\n      CONSTRAINT (IS_PURE IS_BELOW_ID) A) &&&\n     (CONSTRAINT (IS_PURE IS_ID) A \\<Longrightarrow>\n      CONSTRAINT (IS_PURE IS_LEFT_TOTAL) A)) &&&\n    (CONSTRAINT (IS_PURE IS_ID) A \\<Longrightarrow>\n     CONSTRAINT (IS_PURE IS_RIGHT_TOTAL) A) &&&\n    (CONSTRAINT (IS_PURE IS_BELOW_ID) A \\<Longrightarrow>\n     CONSTRAINT (IS_PURE IS_LEFT_UNIQUE) A) &&&\n    (CONSTRAINT (IS_PURE IS_BELOW_ID) A \\<Longrightarrow>\n     CONSTRAINT (IS_PURE single_valued) A)", "by (auto \n    simp: IS_ID_def IS_BELOW_ID_def IS_PURE_def IS_LEFT_UNIQUE_def\n    simp: IS_LEFT_TOTAL_def IS_RIGHT_TOTAL_def\n    simp: single_valued_below_Id)"], ["", "declare True_implies_equals[sepref_relprops_simps]"], ["", "lemma [sepref_relprops_transform]: \"single_valued (R\\<inverse>) = IS_LEFT_UNIQUE R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued (R\\<inverse>) = IS_LEFT_UNIQUE R", "by (auto simp: IS_LEFT_UNIQUE_def)"], ["", "subsection \\<open>HOL Combinators\\<close>"], ["", "lemma hn_if[sepref_comb_rules]:\n  assumes P: \"\\<Gamma> \\<Longrightarrow>\\<^sub>t \\<Gamma>1 * hn_val bool_rel a a'\"\n  assumes RT: \"a \\<Longrightarrow> hn_refine (\\<Gamma>1 * hn_val bool_rel a a') b' \\<Gamma>2b R b\"\n  assumes RE: \"\\<not>a \\<Longrightarrow> hn_refine (\\<Gamma>1 * hn_val bool_rel a a') c' \\<Gamma>2c R c\"\n  assumes IMP: \"TERM If \\<Longrightarrow> \\<Gamma>2b \\<or>\\<^sub>A \\<Gamma>2c \\<Longrightarrow>\\<^sub>t \\<Gamma>'\"\n  shows \"hn_refine \\<Gamma> (if a' then b' else c') \\<Gamma>' R (If$a$b$c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine \\<Gamma> (if a' then b' else c') \\<Gamma>' R (If $ a $ b $ c)", "using P RT RE IMP[OF TERMI]"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<Longrightarrow>\\<^sub>t \\<Gamma>1 * hn_val bool_rel a a'\n  a \\<Longrightarrow>\n  hn_refine (\\<Gamma>1 * hn_val bool_rel a a') b' \\<Gamma>2b R b\n  \\<not> a \\<Longrightarrow>\n  hn_refine (\\<Gamma>1 * hn_val bool_rel a a') c' \\<Gamma>2c R c\n  \\<Gamma>2b \\<or>\\<^sub>A \\<Gamma>2c \\<Longrightarrow>\\<^sub>t \\<Gamma>'\n\ngoal (1 subgoal):\n 1. hn_refine \\<Gamma> (if a' then b' else c') \\<Gamma>' R (If $ a $ b $ c)", "unfolding APP_def PROTECT2_def"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<Longrightarrow>\\<^sub>t \\<Gamma>1 * hn_val bool_rel a a'\n  a \\<Longrightarrow>\n  hn_refine (\\<Gamma>1 * hn_val bool_rel a a') b' \\<Gamma>2b R b\n  \\<not> a \\<Longrightarrow>\n  hn_refine (\\<Gamma>1 * hn_val bool_rel a a') c' \\<Gamma>2c R c\n  \\<Gamma>2b \\<or>\\<^sub>A \\<Gamma>2c \\<Longrightarrow>\\<^sub>t \\<Gamma>'\n\ngoal (1 subgoal):\n 1. hn_refine \\<Gamma> (if a' then b' else c') \\<Gamma>' R\n     (if a then b else c)", "by (rule hnr_If)"], ["", "lemmas [sepref_opt_simps] = if_True if_False"], ["", "lemma hn_let[sepref_comb_rules]:\n  assumes P: \"\\<Gamma> \\<Longrightarrow>\\<^sub>t \\<Gamma>1 * hn_ctxt R v v'\"\n  assumes R: \"\\<And>x x'. x=v \\<Longrightarrow> hn_refine (\\<Gamma>1 * hn_ctxt R x x') (f' x') \n    (\\<Gamma>' x x') R2 (f x)\"\n  assumes F: \"\\<And>x x'. \\<Gamma>' x x' \\<Longrightarrow>\\<^sub>t \\<Gamma>2 * hn_ctxt R' x x'\"\n  shows \n    \"hn_refine \\<Gamma> (Let v' f') (\\<Gamma>2 * hn_ctxt R' v v') R2 (Let$v$(\\<lambda>\\<^sub>2x. f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine \\<Gamma> (Let v' f') (\\<Gamma>2 * hn_ctxt R' v v') R2\n     (Let $ v $ (\\<lambda>x. (#f x#)))", "apply (rule hn_refine_cons[OF P _ F entt_refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (\\<Gamma>1 * hn_ctxt R v v') (Let v' f') (\\<Gamma>' v v') R2\n     (Let $ v $ (\\<lambda>x. (#f x#)))", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (\\<Gamma>1 * hn_ctxt R v v') (f' v') (\\<Gamma>' v v') R2 (f v)", "apply (rule R)"], ["proof (prove)\ngoal (1 subgoal):\n 1. v = v", "by simp"], ["", "subsection \\<open>Basic HOL types\\<close>"], ["", "lemma hnr_default[sepref_import_param]: \"(default,default)\\<in>Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (default, default) \\<in> Id", "by simp"], ["", "lemma unit_hnr[sepref_import_param]: \"((),())\\<in>unit_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((), ()) \\<in> unit_rel", "by auto"], ["", "lemmas [sepref_import_param] = \n  param_bool\n  param_nat1\n  param_int"], ["", "lemmas [id_rules] = \n  itypeI[Pure.of 0 \"TYPE (nat)\"]\n  itypeI[Pure.of 0 \"TYPE (int)\"]\n  itypeI[Pure.of 1 \"TYPE (nat)\"]\n  itypeI[Pure.of 1 \"TYPE (int)\"]\n  itypeI[Pure.of numeral \"TYPE (num \\<Rightarrow> nat)\"]\n  itypeI[Pure.of numeral \"TYPE (num \\<Rightarrow> int)\"]\n  itype_self[of num.One]\n  itype_self[of num.Bit0]\n  itype_self[of num.Bit1]"], ["", "lemma param_min_nat[param,sepref_import_param]: \"(min,min)\\<in>nat_rel \\<rightarrow> nat_rel \\<rightarrow> nat_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (min, min) \\<in> nat_rel \\<rightarrow> nat_rel \\<rightarrow> nat_rel", "by auto"], ["", "lemma param_max_nat[param,sepref_import_param]: \"(max,max)\\<in>nat_rel \\<rightarrow> nat_rel \\<rightarrow> nat_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (max, max) \\<in> nat_rel \\<rightarrow> nat_rel \\<rightarrow> nat_rel", "by auto"], ["", "lemma param_min_int[param,sepref_import_param]: \"(min,min)\\<in>int_rel \\<rightarrow> int_rel \\<rightarrow> int_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (min, min) \\<in> int_rel \\<rightarrow> int_rel \\<rightarrow> int_rel", "by auto"], ["", "lemma param_max_int[param,sepref_import_param]: \"(max,max)\\<in>int_rel \\<rightarrow> int_rel \\<rightarrow> int_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (max, max) \\<in> int_rel \\<rightarrow> int_rel \\<rightarrow> int_rel", "by auto"], ["", "lemma uminus_hnr[sepref_import_param]: \"(uminus,uminus)\\<in>int_rel \\<rightarrow> int_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uminus, uminus) \\<in> int_rel \\<rightarrow> int_rel", "by auto"], ["", "lemma nat_param[param,sepref_import_param]: \"(nat,nat) \\<in> int_rel \\<rightarrow> nat_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (nat, nat) \\<in> int_rel \\<rightarrow> nat_rel", "by auto"], ["", "lemma int_param[param,sepref_import_param]: \"(int,int) \\<in> nat_rel \\<rightarrow> int_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (int, int) \\<in> nat_rel \\<rightarrow> int_rel", "by auto"], ["", "subsection \"Product\""], ["", "lemmas [sepref_import_rewrite, sepref_frame_normrel_eqs, fcomp_norm_unfold] = prod_assn_pure_conv[symmetric]"], ["", "lemma prod_assn_precise[constraint_rules]: \n  \"precise P1 \\<Longrightarrow> precise P2 \\<Longrightarrow> precise (prod_assn P1 P2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>precise P1; precise P2\\<rbrakk>\n    \\<Longrightarrow> precise (P1 \\<times>\\<^sub>a P2)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' h p F F'.\n       \\<lbrakk>precise P1; precise P2;\n        h \\<Turnstile>\n        (P1 \\<times>\\<^sub>a P2) a p * F \\<and>\\<^sub>A\n        (P1 \\<times>\\<^sub>a P2) a' p * F'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "apply (clarsimp simp: prod_assn_def star_assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb ac bc F F'.\n       \\<lbrakk>precise P1; precise P2;\n        (ab, bb) \\<Turnstile>\n        P1 a ac * (P2 b bc * F) \\<and>\\<^sub>A\n        P1 aa ac * (P2 ba bc * F')\\<rbrakk>\n       \\<Longrightarrow> a = aa \\<and> b = ba", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb ac bc F F'.\n       \\<lbrakk>precise P1; precise P2;\n        (ab, bb) \\<Turnstile>\n        P1 a ac * (P2 b bc * F) \\<and>\\<^sub>A\n        P1 aa ac * (P2 ba bc * F')\\<rbrakk>\n       \\<Longrightarrow> a = aa\n 2. \\<And>a b aa ba ab bb ac bc F F'.\n       \\<lbrakk>precise P1; precise P2;\n        (ab, bb) \\<Turnstile>\n        P1 a ac * (P2 b bc * F) \\<and>\\<^sub>A\n        P1 aa ac * (P2 ba bc * F')\\<rbrakk>\n       \\<Longrightarrow> b = ba", "apply (erule (1) prec_frame)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba ab bb ac bc F F'.\n       \\<lbrakk>precise P2;\n        (ab, bb) \\<Turnstile>\n        P1 a ac * (P2 b bc * F) \\<and>\\<^sub>A\n        P1 aa ac * (P2 ba bc * F')\\<rbrakk>\n       \\<Longrightarrow> P1 a ac * (P2 b bc * F) \\<Longrightarrow>\\<^sub>A\n                         P1 a (?p4 a b aa ba ab bb ac bc F F') *\n                         ?F1.4 a b aa ba ab bb ac bc F F'\n 2. \\<And>a b aa ba ab bb ac bc F F'.\n       \\<lbrakk>precise P2;\n        (ab, bb) \\<Turnstile>\n        P1 a ac * (P2 b bc * F) \\<and>\\<^sub>A\n        P1 aa ac * (P2 ba bc * F')\\<rbrakk>\n       \\<Longrightarrow> P1 aa ac *\n                         (P2 ba bc * F') \\<Longrightarrow>\\<^sub>A\n                         P1 aa (?p4 a b aa ba ab bb ac bc F F') *\n                         ?F2.4 a b aa ba ab bb ac bc F F'\n 3. \\<And>a b aa ba ab bb ac bc F F'.\n       \\<lbrakk>precise P1; precise P2;\n        (ab, bb) \\<Turnstile>\n        P1 a ac * (P2 b bc * F) \\<and>\\<^sub>A\n        P1 aa ac * (P2 ba bc * F')\\<rbrakk>\n       \\<Longrightarrow> b = ba", "apply frame_inference+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb ac bc F F'.\n       \\<lbrakk>precise P1; precise P2;\n        (ab, bb) \\<Turnstile>\n        P1 a ac * (P2 b bc * F) \\<and>\\<^sub>A\n        P1 aa ac * (P2 ba bc * F')\\<rbrakk>\n       \\<Longrightarrow> b = ba", "apply (erule (1) prec_frame)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb ac bc F F'.\n       \\<lbrakk>precise P1;\n        (ab, bb) \\<Turnstile>\n        P1 a ac * (P2 b bc * F) \\<and>\\<^sub>A\n        P1 aa ac * (P2 ba bc * F')\\<rbrakk>\n       \\<Longrightarrow> P1 a ac * (P2 b bc * F) \\<Longrightarrow>\\<^sub>A\n                         P2 b (?p24 a b aa ba ab bb ac bc F F') *\n                         ?F1.24 a b aa ba ab bb ac bc F F'\n 2. \\<And>a b aa ba ab bb ac bc F F'.\n       \\<lbrakk>precise P1;\n        (ab, bb) \\<Turnstile>\n        P1 a ac * (P2 b bc * F) \\<and>\\<^sub>A\n        P1 aa ac * (P2 ba bc * F')\\<rbrakk>\n       \\<Longrightarrow> P1 aa ac *\n                         (P2 ba bc * F') \\<Longrightarrow>\\<^sub>A\n                         P2 ba (?p24 a b aa ba ab bb ac bc F F') *\n                         ?F2.24 a b aa ba ab bb ac bc F F'", "apply frame_inference+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma  \n  \"precise P1 \\<Longrightarrow> precise P2 \\<Longrightarrow> precise (prod_assn P1 P2)\" \\<comment> \\<open>Original proof\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>precise P1; precise P2\\<rbrakk>\n    \\<Longrightarrow> precise (P1 \\<times>\\<^sub>a P2)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' h p F F'.\n       \\<lbrakk>precise P1; precise P2;\n        h \\<Turnstile>\n        (P1 \\<times>\\<^sub>a P2) a p * F \\<and>\\<^sub>A\n        (P1 \\<times>\\<^sub>a P2) a' p * F'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "apply (clarsimp simp: prod_assn_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb ac bc F F'.\n       \\<lbrakk>precise P1; precise P2;\n        (ab, bb) \\<Turnstile>\n        P1 a ac * P2 b bc * F \\<and>\\<^sub>A\n        P1 aa ac * P2 ba bc * F'\\<rbrakk>\n       \\<Longrightarrow> a = aa \\<and> b = ba", "proof (rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb ac bc F F'.\n       \\<lbrakk>precise P1; precise P2;\n        (ab, bb) \\<Turnstile>\n        P1 a ac * P2 b bc * F \\<and>\\<^sub>A\n        P1 aa ac * P2 ba bc * F'\\<rbrakk>\n       \\<Longrightarrow> a = aa\n 2. \\<And>a b aa ba ab bb ac bc F F'.\n       \\<lbrakk>precise P1; precise P2;\n        (ab, bb) \\<Turnstile>\n        P1 a ac * P2 b bc * F \\<and>\\<^sub>A\n        P1 aa ac * P2 ba bc * F'\\<rbrakk>\n       \\<Longrightarrow> b = ba", "fix F F' h as a b a' b' ap bp"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb ac bc F F'.\n       \\<lbrakk>precise P1; precise P2;\n        (ab, bb) \\<Turnstile>\n        P1 a ac * P2 b bc * F \\<and>\\<^sub>A\n        P1 aa ac * P2 ba bc * F'\\<rbrakk>\n       \\<Longrightarrow> a = aa\n 2. \\<And>a b aa ba ab bb ac bc F F'.\n       \\<lbrakk>precise P1; precise P2;\n        (ab, bb) \\<Turnstile>\n        P1 a ac * P2 b bc * F \\<and>\\<^sub>A\n        P1 aa ac * P2 ba bc * F'\\<rbrakk>\n       \\<Longrightarrow> b = ba", "assume P1: \"precise P1\" and P2: \"precise P2\""], ["proof (state)\nthis:\n  precise P1\n  precise P2\n\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb ac bc F F'.\n       \\<lbrakk>precise P1; precise P2;\n        (ab, bb) \\<Turnstile>\n        P1 a ac * P2 b bc * F \\<and>\\<^sub>A\n        P1 aa ac * P2 ba bc * F'\\<rbrakk>\n       \\<Longrightarrow> a = aa\n 2. \\<And>a b aa ba ab bb ac bc F F'.\n       \\<lbrakk>precise P1; precise P2;\n        (ab, bb) \\<Turnstile>\n        P1 a ac * P2 b bc * F \\<and>\\<^sub>A\n        P1 aa ac * P2 ba bc * F'\\<rbrakk>\n       \\<Longrightarrow> b = ba", "assume F: \"(h, as) \\<Turnstile> P1 a ap * P2 b bp * F \\<and>\\<^sub>A P1 a' ap * P2 b' bp * F'\""], ["proof (state)\nthis:\n  (h, as) \\<Turnstile>\n  P1 a ap * P2 b bp * F \\<and>\\<^sub>A P1 a' ap * P2 b' bp * F'\n\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb ac bc F F'.\n       \\<lbrakk>precise P1; precise P2;\n        (ab, bb) \\<Turnstile>\n        P1 a ac * P2 b bc * F \\<and>\\<^sub>A\n        P1 aa ac * P2 ba bc * F'\\<rbrakk>\n       \\<Longrightarrow> a = aa\n 2. \\<And>a b aa ba ab bb ac bc F F'.\n       \\<lbrakk>precise P1; precise P2;\n        (ab, bb) \\<Turnstile>\n        P1 a ac * P2 b bc * F \\<and>\\<^sub>A\n        P1 aa ac * P2 ba bc * F'\\<rbrakk>\n       \\<Longrightarrow> b = ba", "from F"], ["proof (chain)\npicking this:\n  (h, as) \\<Turnstile>\n  P1 a ap * P2 b bp * F \\<and>\\<^sub>A P1 a' ap * P2 b' bp * F'", "have \"(h, as) \\<Turnstile> P1 a ap * (P2 b bp * F) \\<and>\\<^sub>A P1 a' ap * (P2 b' bp * F')\""], ["proof (prove)\nusing this:\n  (h, as) \\<Turnstile>\n  P1 a ap * P2 b bp * F \\<and>\\<^sub>A P1 a' ap * P2 b' bp * F'\n\ngoal (1 subgoal):\n 1. (h, as) \\<Turnstile>\n    P1 a ap * (P2 b bp * F) \\<and>\\<^sub>A P1 a' ap * (P2 b' bp * F')", "by (simp only: mult.assoc)"], ["proof (state)\nthis:\n  (h, as) \\<Turnstile>\n  P1 a ap * (P2 b bp * F) \\<and>\\<^sub>A P1 a' ap * (P2 b' bp * F')\n\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb ac bc F F'.\n       \\<lbrakk>precise P1; precise P2;\n        (ab, bb) \\<Turnstile>\n        P1 a ac * P2 b bc * F \\<and>\\<^sub>A\n        P1 aa ac * P2 ba bc * F'\\<rbrakk>\n       \\<Longrightarrow> a = aa\n 2. \\<And>a b aa ba ab bb ac bc F F'.\n       \\<lbrakk>precise P1; precise P2;\n        (ab, bb) \\<Turnstile>\n        P1 a ac * P2 b bc * F \\<and>\\<^sub>A\n        P1 aa ac * P2 ba bc * F'\\<rbrakk>\n       \\<Longrightarrow> b = ba", "with preciseD[OF P1]"], ["proof (chain)\npicking this:\n  ?h \\<Turnstile>\n  P1 ?a ?p * ?F \\<and>\\<^sub>A P1 ?a' ?p * ?F' \\<Longrightarrow>\n  ?a = ?a'\n  (h, as) \\<Turnstile>\n  P1 a ap * (P2 b bp * F) \\<and>\\<^sub>A P1 a' ap * (P2 b' bp * F')", "show \"a=a'\""], ["proof (prove)\nusing this:\n  ?h \\<Turnstile>\n  P1 ?a ?p * ?F \\<and>\\<^sub>A P1 ?a' ?p * ?F' \\<Longrightarrow>\n  ?a = ?a'\n  (h, as) \\<Turnstile>\n  P1 a ap * (P2 b bp * F) \\<and>\\<^sub>A P1 a' ap * (P2 b' bp * F')\n\ngoal (1 subgoal):\n 1. a = a'", "."], ["proof (state)\nthis:\n  a = a'\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb ac bc F F'.\n       \\<lbrakk>precise P1; precise P2;\n        (ab, bb) \\<Turnstile>\n        P1 a ac * P2 b bc * F \\<and>\\<^sub>A\n        P1 aa ac * P2 ba bc * F'\\<rbrakk>\n       \\<Longrightarrow> b = ba", "from F"], ["proof (chain)\npicking this:\n  (h, as) \\<Turnstile>\n  P1 a ap * P2 b bp * F \\<and>\\<^sub>A P1 a' ap * P2 b' bp * F'", "have \"(h, as) \\<Turnstile> P2 b bp * (P1 a ap * F) \\<and>\\<^sub>A P2 b' bp * (P1 a' ap * F')\""], ["proof (prove)\nusing this:\n  (h, as) \\<Turnstile>\n  P1 a ap * P2 b bp * F \\<and>\\<^sub>A P1 a' ap * P2 b' bp * F'\n\ngoal (1 subgoal):\n 1. (h, as) \\<Turnstile>\n    P2 b bp * (P1 a ap * F) \\<and>\\<^sub>A P2 b' bp * (P1 a' ap * F')", "by (simp only: mult.assoc[where 'a=assn] mult.commute[where 'a=assn] mult.left_commute[where 'a=assn])"], ["proof (state)\nthis:\n  (h, as) \\<Turnstile>\n  P2 b bp * (P1 a ap * F) \\<and>\\<^sub>A P2 b' bp * (P1 a' ap * F')\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb ac bc F F'.\n       \\<lbrakk>precise P1; precise P2;\n        (ab, bb) \\<Turnstile>\n        P1 a ac * P2 b bc * F \\<and>\\<^sub>A\n        P1 aa ac * P2 ba bc * F'\\<rbrakk>\n       \\<Longrightarrow> b = ba", "with preciseD[OF P2]"], ["proof (chain)\npicking this:\n  ?h \\<Turnstile>\n  P2 ?a ?p * ?F \\<and>\\<^sub>A P2 ?a' ?p * ?F' \\<Longrightarrow>\n  ?a = ?a'\n  (h, as) \\<Turnstile>\n  P2 b bp * (P1 a ap * F) \\<and>\\<^sub>A P2 b' bp * (P1 a' ap * F')", "show \"b=b'\""], ["proof (prove)\nusing this:\n  ?h \\<Turnstile>\n  P2 ?a ?p * ?F \\<and>\\<^sub>A P2 ?a' ?p * ?F' \\<Longrightarrow>\n  ?a = ?a'\n  (h, as) \\<Turnstile>\n  P2 b bp * (P1 a ap * F) \\<and>\\<^sub>A P2 b' bp * (P1 a' ap * F')\n\ngoal (1 subgoal):\n 1. b = b'", "."], ["proof (state)\nthis:\n  b = b'\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO Add corresponding rules for other types and add to datatype snippet *)"], ["", "lemma intf_of_prod_assn[intf_of_assn]:\n  assumes \"intf_of_assn A TYPE('a)\" \"intf_of_assn B TYPE('b)\"\n  shows \"intf_of_assn (prod_assn A B) TYPE('a * 'b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. intf_of_assn (A \\<times>\\<^sub>a B) TYPE('a \\<times> 'b)", "by simp"], ["", "lemma pure_prod[constraint_rules]: \n  assumes P1: \"is_pure P1\" and P2: \"is_pure P2\"\n  shows \"is_pure (prod_assn P1 P2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pure (P1 \\<times>\\<^sub>a P2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_pure (P1 \\<times>\\<^sub>a P2)", "from P1"], ["proof (chain)\npicking this:\n  is_pure P1", "obtain P1' where P1': \"\\<And>x x'. P1 x x' = \\<up>(P1' x x')\""], ["proof (prove)\nusing this:\n  is_pure P1\n\ngoal (1 subgoal):\n 1. (\\<And>P1'.\n        (\\<And>x x'. P1 x x' = \\<up> (P1' x x')) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using is_pureE"], ["proof (prove)\nusing this:\n  is_pure P1\n  \\<lbrakk>is_pure ?P;\n   \\<And>P'.\n      (\\<And>x x'. ?P x x' = \\<up> (P' x x')) \\<Longrightarrow>\n      ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>P1'.\n        (\\<And>x x'. P1 x x' = \\<up> (P1' x x')) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  P1 ?x ?x' = \\<up> (P1' ?x ?x')\n\ngoal (1 subgoal):\n 1. is_pure (P1 \\<times>\\<^sub>a P2)", "from P2"], ["proof (chain)\npicking this:\n  is_pure P2", "obtain P2' where P2': \"\\<And>x x'. P2 x x' = \\<up>(P2' x x')\""], ["proof (prove)\nusing this:\n  is_pure P2\n\ngoal (1 subgoal):\n 1. (\\<And>P2'.\n        (\\<And>x x'. P2 x x' = \\<up> (P2' x x')) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using is_pureE"], ["proof (prove)\nusing this:\n  is_pure P2\n  \\<lbrakk>is_pure ?P;\n   \\<And>P'.\n      (\\<And>x x'. ?P x x' = \\<up> (P' x x')) \\<Longrightarrow>\n      ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>P2'.\n        (\\<And>x x'. P2 x x' = \\<up> (P2' x x')) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  P2 ?x ?x' = \\<up> (P2' ?x ?x')\n\ngoal (1 subgoal):\n 1. is_pure (P1 \\<times>\\<^sub>a P2)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pure (P1 \\<times>\\<^sub>a P2)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x x'. (P1 \\<times>\\<^sub>a P2) x x' = \\<up> (?P' x x')", "fix x x'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x x'. (P1 \\<times>\\<^sub>a P2) x x' = \\<up> (?P' x x')", "show \"prod_assn P1 P2 x x' =\n         \\<up> (case (x, x') of ((a1, a2), c1, c2) \\<Rightarrow> P1' a1 c1 \\<and> P2' a2 c2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P1 \\<times>\\<^sub>a P2) x x' =\n    \\<up>\n     (case (x, x') of\n      ((a1, a2), c1, c2) \\<Rightarrow> P1' a1 c1 \\<and> P2' a2 c2)", "unfolding prod_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (x, x') of ((a1, a2), c1, c2) \\<Rightarrow> P1 a1 c1 * P2 a2 c2) =\n    \\<up>\n     (case (x, x') of\n      ((a1, a2), c1, c2) \\<Rightarrow> P1' a1 c1 \\<and> P2' a2 c2)", "apply (simp add: P1' P2' split: prod.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (P1 \\<times>\\<^sub>a P2) x x' =\n  \\<up>\n   (case (x, x') of\n    ((a1, a2), c1, c2) \\<Rightarrow> P1' a1 c1 \\<and> P2' a2 c2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_pure (P1 \\<times>\\<^sub>a P2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prod_frame_match[sepref_frame_match_rules]:\n  assumes \"hn_ctxt A (fst x) (fst y) \\<Longrightarrow>\\<^sub>t hn_ctxt A' (fst x) (fst y)\"\n  assumes \"hn_ctxt B (snd x) (snd y) \\<Longrightarrow>\\<^sub>t hn_ctxt B' (snd x) (snd y)\"\n  shows \"hn_ctxt (prod_assn A B) x y \\<Longrightarrow>\\<^sub>t hn_ctxt (prod_assn A' B') x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_ctxt (A \\<times>\\<^sub>a B) x y \\<Longrightarrow>\\<^sub>t\n    hn_ctxt (A' \\<times>\\<^sub>a B') x y", "apply (cases x; cases y; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>x = (a, b); y = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt (A \\<times>\\<^sub>a B) (a, b)\n                          (aa, ba) \\<Longrightarrow>\\<^sub>t\n                         hn_ctxt (A' \\<times>\\<^sub>a B') (a, b) (aa, ba)", "apply (simp add: hn_ctxt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>x = (a, b); y = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> A a aa * B b ba \\<Longrightarrow>\\<^sub>t\n                         A' a aa * B' b ba", "apply (rule entt_star_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>x = (a, b); y = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> A a aa \\<Longrightarrow>\\<^sub>t A' a aa\n 2. \\<And>a b aa ba.\n       \\<lbrakk>x = (a, b); y = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> B b ba \\<Longrightarrow>\\<^sub>t B' b ba", "using assms"], ["proof (prove)\nusing this:\n  hn_ctxt A (fst x) (fst y) \\<Longrightarrow>\\<^sub>t\n  hn_ctxt A' (fst x) (fst y)\n  hn_ctxt B (snd x) (snd y) \\<Longrightarrow>\\<^sub>t\n  hn_ctxt B' (snd x) (snd y)\n\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>x = (a, b); y = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> A a aa \\<Longrightarrow>\\<^sub>t A' a aa\n 2. \\<And>a b aa ba.\n       \\<lbrakk>x = (a, b); y = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> B b ba \\<Longrightarrow>\\<^sub>t B' b ba", "apply (auto simp: hn_ctxt_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma prod_frame_merge[sepref_frame_merge_rules]:   \n  assumes \"hn_ctxt A (fst x) (fst y) \\<or>\\<^sub>A hn_ctxt A' (fst x) (fst y) \\<Longrightarrow>\\<^sub>t hn_ctxt Am (fst x) (fst y)\"\n  assumes \"hn_ctxt B (snd x) (snd y) \\<or>\\<^sub>A hn_ctxt B' (snd x) (snd y) \\<Longrightarrow>\\<^sub>t hn_ctxt Bm (snd x) (snd y)\"\n  shows \"hn_ctxt (prod_assn A B) x y \\<or>\\<^sub>A hn_ctxt (prod_assn A' B') x y \\<Longrightarrow>\\<^sub>t hn_ctxt (prod_assn Am Bm) x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_ctxt (A \\<times>\\<^sub>a B) x y \\<or>\\<^sub>A\n    hn_ctxt (A' \\<times>\\<^sub>a B') x y \\<Longrightarrow>\\<^sub>t\n    hn_ctxt (Am \\<times>\\<^sub>a Bm) x y", "by (blast intro: entt_disjE prod_frame_match \n    entt_disjD1[OF assms(1)] entt_disjD2[OF assms(1)]\n    entt_disjD1[OF assms(2)] entt_disjD2[OF assms(2)])"], ["", "lemma entt_invalid_prod: \"hn_invalid (prod_assn A B) p p' \\<Longrightarrow>\\<^sub>t hn_ctxt (prod_assn (invalid_assn A) (invalid_assn B)) p p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_invalid (A \\<times>\\<^sub>a B) p p' \\<Longrightarrow>\\<^sub>t\n    hn_ctxt (invalid_assn A \\<times>\\<^sub>a invalid_assn B) p p'", "apply (simp add: hn_ctxt_def invalid_assn_def[abs_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<up>\n     (\\<exists>a b.\n         (a, b) \\<Turnstile>\n         (A \\<times>\\<^sub>a B) p p') \\<Longrightarrow>\\<^sub>t\n    ((\\<lambda>x y.\n         \\<up> (\\<exists>a b. (a, b) \\<Turnstile> A x y) *\n         true) \\<times>\\<^sub>a\n     (\\<lambda>x y. \\<up> (\\<exists>a b. (a, b) \\<Turnstile> B x y) * true))\n     p p'", "apply (rule enttI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<up>\n     (\\<exists>a b.\n         (a, b) \\<Turnstile>\n         (A \\<times>\\<^sub>a B) p p') \\<Longrightarrow>\\<^sub>A\n    ((\\<lambda>x y.\n         \\<up> (\\<exists>a b. (a, b) \\<Turnstile> A x y) *\n         true) \\<times>\\<^sub>a\n     (\\<lambda>x y. \\<up> (\\<exists>a b. (a, b) \\<Turnstile> B x y) * true))\n     p p' *\n    true", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<Turnstile> (A \\<times>\\<^sub>a B) p p' \\<Longrightarrow>\n       emp \\<Longrightarrow>\\<^sub>A\n       ((\\<lambda>x y.\n            \\<up> (\\<exists>a b. (a, b) \\<Turnstile> A x y) *\n            true) \\<times>\\<^sub>a\n        (\\<lambda>x y.\n            \\<up> (\\<exists>a b. (a, b) \\<Turnstile> B x y) * true))\n        p p' *\n       true", "apply (cases p; cases p'; auto simp: mod_star_conv pure_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas invalid_prod_merge[sepref_frame_merge_rules] = gen_merge_cons[OF entt_invalid_prod]"], ["", "lemma prod_assn_ctxt: \"prod_assn A1 A2 x y = z \\<Longrightarrow> hn_ctxt (prod_assn A1 A2) x y = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A1 \\<times>\\<^sub>a A2) x y = z \\<Longrightarrow>\n    hn_ctxt (A1 \\<times>\\<^sub>a A2) x y = z", "by (simp add: hn_ctxt_def)"], ["", "lemma hn_case_prod'[sepref_prep_comb_rule,sepref_comb_rules]:\n  assumes FR: \"\\<Gamma>\\<Longrightarrow>\\<^sub>thn_ctxt (prod_assn P1 P2) p' p * \\<Gamma>1\"\n  assumes Pair: \"\\<And>a1 a2 a1' a2'. \\<lbrakk>p'=(a1',a2')\\<rbrakk> \n    \\<Longrightarrow> hn_refine (hn_ctxt P1 a1' a1 * hn_ctxt P2 a2' a2 * \\<Gamma>1 * hn_invalid (prod_assn P1 P2) p' p) (f a1 a2) \n          (hn_ctxt P1' a1' a1 * hn_ctxt P2' a2' a2 * hn_ctxt XX1 p' p * \\<Gamma>1') R (f' a1' a2')\"\n  shows \"hn_refine \\<Gamma> (case_prod f p) (hn_ctxt (prod_assn P1' P2') p' p * \\<Gamma>1')\n    R (case_prod$(\\<lambda>\\<^sub>2a b. f' a b)$p')\" (is \"?G \\<Gamma>\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine \\<Gamma> (case p of (x, xa) \\<Rightarrow> f x xa)\n     (hn_ctxt (P1' \\<times>\\<^sub>a P2') p' p * \\<Gamma>1') R\n     (case_prod $ (\\<lambda>x. (#\\<lambda>xa. (#f' x xa#)#)) $ p')", "apply1 (rule hn_refine_cons_pre[OF FR])"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt (P1 \\<times>\\<^sub>a P2) p' p * \\<Gamma>1)\n     (case p of (x, xa) \\<Rightarrow> f x xa)\n     (hn_ctxt (P1' \\<times>\\<^sub>a P2') p' p * \\<Gamma>1') R\n     (case_prod $ (\\<lambda>x. (#\\<lambda>xa. (#f' x xa#)#)) $ p')", "apply1 extract_hnr_invalids"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h h1 h2.\n       \\<lbrakk>h2 \\<Turnstile> \\<Gamma>1;\n        hn_invalid (P1 \\<times>\\<^sub>a P2) p' p = true\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (P1 \\<times>\\<^sub>a P2) p' p *\n                           \\<Gamma>1)\n                          (case p of (x, xa) \\<Rightarrow> f x xa)\n                          (hn_ctxt (P1' \\<times>\\<^sub>a P2') p' p *\n                           \\<Gamma>1')\n                          R (case_prod $\n                             (\\<lambda>x. (#\\<lambda>xa. (#f' x xa#)#)) $\n                             p')", "apply1 (cases p; cases p'; simp add: prod_assn_pair_conv[THEN prod_assn_ctxt])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h2 a b aa ba.\n       \\<lbrakk>h2 \\<Turnstile> \\<Gamma>1;\n        hn_invalid (P1 \\<times>\\<^sub>a P2) (aa, ba) (a, b) = true;\n        p = (a, b); p' = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> hn_refine (P1 aa a * P2 ba b * \\<Gamma>1) (f a b)\n                          (P1' aa a * P2' ba b * \\<Gamma>1') R (f' aa ba)", "apply (rule hn_refine_cons[OF _ Pair _ entt_refl])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>h2 a b aa ba.\n       \\<lbrakk>h2 \\<Turnstile> \\<Gamma>1;\n        hn_invalid (P1 \\<times>\\<^sub>a P2) (aa, ba) (a, b) = true;\n        p = (a, b); p' = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> P1 aa a * P2 ba b *\n                         \\<Gamma>1 \\<Longrightarrow>\\<^sub>t\n                         hn_ctxt P1 aa a * hn_ctxt P2 ba b * \\<Gamma>1 *\n                         hn_invalid (P1 \\<times>\\<^sub>a P2) p' p\n 2. \\<And>h2 a b aa ba.\n       \\<lbrakk>h2 \\<Turnstile> \\<Gamma>1;\n        hn_invalid (P1 \\<times>\\<^sub>a P2) (aa, ba) (a, b) = true;\n        p = (a, b); p' = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> p' = (aa, ba)\n 3. \\<And>h2 a b aa ba.\n       \\<lbrakk>h2 \\<Turnstile> \\<Gamma>1;\n        hn_invalid (P1 \\<times>\\<^sub>a P2) (aa, ba) (a, b) = true;\n        p = (a, b); p' = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt P1' aa a * hn_ctxt P2' ba b *\n                         hn_ctxt XX1 p' p *\n                         \\<Gamma>1' \\<Longrightarrow>\\<^sub>t\n                         P1' aa a * P2' ba b * \\<Gamma>1'", "applyS (simp add: hn_ctxt_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>h2 a b aa ba.\n       \\<lbrakk>h2 \\<Turnstile> \\<Gamma>1;\n        hn_invalid (P1 \\<times>\\<^sub>a P2) (aa, ba) (a, b) = true;\n        p = (a, b); p' = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> p' = (aa, ba)\n 2. \\<And>h2 a b aa ba.\n       \\<lbrakk>h2 \\<Turnstile> \\<Gamma>1;\n        hn_invalid (P1 \\<times>\\<^sub>a P2) (aa, ba) (a, b) = true;\n        p = (a, b); p' = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt P1' aa a * hn_ctxt P2' ba b *\n                         hn_ctxt XX1 p' p *\n                         \\<Gamma>1' \\<Longrightarrow>\\<^sub>t\n                         P1' aa a * P2' ba b * \\<Gamma>1'", "applyS simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h2 a b aa ba.\n       \\<lbrakk>h2 \\<Turnstile> \\<Gamma>1;\n        hn_invalid (P1 \\<times>\\<^sub>a P2) (aa, ba) (a, b) = true;\n        p = (a, b); p' = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt P1' aa a * hn_ctxt P2' ba b *\n                         hn_ctxt XX1 p' p *\n                         \\<Gamma>1' \\<Longrightarrow>\\<^sub>t\n                         P1' aa a * P2' ba b * \\<Gamma>1'", "applyS (simp add: hn_ctxt_def entt_fr_refl entt_fr_drop)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hn_case_prod_old:\n  assumes P: \"\\<Gamma>\\<Longrightarrow>\\<^sub>t\\<Gamma>1 * hn_ctxt (prod_assn P1 P2) p' p\"\n  assumes R: \"\\<And>a1 a2 a1' a2'. \\<lbrakk>p'=(a1',a2')\\<rbrakk> \n    \\<Longrightarrow> hn_refine (\\<Gamma>1 * hn_ctxt P1 a1' a1 * hn_ctxt P2 a2' a2 * hn_invalid (prod_assn P1 P2) p' p) (f a1 a2) \n          (\\<Gamma>h a1 a1' a2 a2') R (f' a1' a2')\"\n  assumes M: \"\\<And>a1 a1' a2 a2'. \\<Gamma>h a1 a1' a2 a2' \n    \\<Longrightarrow>\\<^sub>t \\<Gamma>' * hn_ctxt P1' a1' a1 * hn_ctxt P2' a2' a2 * hn_ctxt Pxx p' p\"\n  shows \"hn_refine \\<Gamma> (case_prod f p) (\\<Gamma>' * hn_ctxt (prod_assn P1' P2') p' p)\n    R (case_prod$(\\<lambda>\\<^sub>2a b. f' a b)$p')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine \\<Gamma> (case p of (x, xa) \\<Rightarrow> f x xa)\n     (\\<Gamma>' * hn_ctxt (P1' \\<times>\\<^sub>a P2') p' p) R\n     (case_prod $ (\\<lambda>x. (#\\<lambda>xa. (#f' x xa#)#)) $ p')", "apply1 (cases p; cases p'; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>p = (a, b); p' = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> hn_refine \\<Gamma> (f a b)\n                          (\\<Gamma>' *\n                           hn_ctxt (P1' \\<times>\\<^sub>a P2') (aa, ba)\n                            (a, b))\n                          R (f' aa ba)", "apply1 (rule hn_refine_cons_pre[OF P])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>p = (a, b); p' = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (\\<Gamma>1 *\n                           hn_ctxt (P1 \\<times>\\<^sub>a P2) p' p)\n                          (f a b)\n                          (\\<Gamma>' *\n                           hn_ctxt (P1' \\<times>\\<^sub>a P2') (aa, ba)\n                            (a, b))\n                          R (f' aa ba)", "apply (rule hn_refine_preI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba h.\n       \\<lbrakk>p = (a, b); p' = (aa, ba);\n        h \\<Turnstile>\n        \\<Gamma>1 * hn_ctxt (P1 \\<times>\\<^sub>a P2) p' p\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (\\<Gamma>1 *\n                           hn_ctxt (P1 \\<times>\\<^sub>a P2) p' p)\n                          (f a b)\n                          (\\<Gamma>' *\n                           hn_ctxt (P1' \\<times>\\<^sub>a P2') (aa, ba)\n                            (a, b))\n                          R (f' aa ba)", "apply (simp add: hn_ctxt_def assn_aci)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba h.\n       \\<lbrakk>p = (a, b); p' = (aa, ba);\n        h \\<Turnstile> \\<Gamma>1 * P1 aa a * P2 ba b\\<rbrakk>\n       \\<Longrightarrow> hn_refine (\\<Gamma>1 * P1 aa a * P2 ba b) (f a b)\n                          (\\<Gamma>' * P1' aa a * P2' ba b) R (f' aa ba)", "apply (rule hn_refine_cons[OF _ R])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b aa ba h.\n       \\<lbrakk>p = (a, b); p' = (aa, ba);\n        h \\<Turnstile> \\<Gamma>1 * P1 aa a * P2 ba b\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>1 * P1 aa a *\n                         P2 ba b \\<Longrightarrow>\\<^sub>t\n                         \\<Gamma>1 * hn_ctxt P1 aa a * hn_ctxt P2 ba b *\n                         hn_invalid (P1 \\<times>\\<^sub>a P2) p' p\n 2. \\<And>a b aa ba h.\n       \\<lbrakk>p = (a, b); p' = (aa, ba);\n        h \\<Turnstile> \\<Gamma>1 * P1 aa a * P2 ba b\\<rbrakk>\n       \\<Longrightarrow> p' = (aa, ba)\n 3. \\<And>a b aa ba h.\n       \\<lbrakk>p = (a, b); p' = (aa, ba);\n        h \\<Turnstile> \\<Gamma>1 * P1 aa a * P2 ba b\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>h a aa b ba \\<Longrightarrow>\\<^sub>t\n                         \\<Gamma>' * P1' aa a * P2' ba b\n 4. \\<And>a b aa ba h x y.\n       \\<lbrakk>p = (a, b); p' = (aa, ba);\n        h \\<Turnstile> \\<Gamma>1 * P1 aa a * P2 ba b\\<rbrakk>\n       \\<Longrightarrow> R x y \\<Longrightarrow>\\<^sub>t R x y", "apply1 (rule enttI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b aa ba h.\n       \\<lbrakk>p = (a, b); p' = (aa, ba);\n        h \\<Turnstile> \\<Gamma>1 * P1 aa a * P2 ba b\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>1 * P1 aa a *\n                         P2 ba b \\<Longrightarrow>\\<^sub>A\n                         \\<Gamma>1 * hn_ctxt P1 aa a * hn_ctxt P2 ba b *\n                         hn_invalid (P1 \\<times>\\<^sub>a P2) p' p *\n                         true\n 2. \\<And>a b aa ba h.\n       \\<lbrakk>p = (a, b); p' = (aa, ba);\n        h \\<Turnstile> \\<Gamma>1 * P1 aa a * P2 ba b\\<rbrakk>\n       \\<Longrightarrow> p' = (aa, ba)\n 3. \\<And>a b aa ba h.\n       \\<lbrakk>p = (a, b); p' = (aa, ba);\n        h \\<Turnstile> \\<Gamma>1 * P1 aa a * P2 ba b\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>h a aa b ba \\<Longrightarrow>\\<^sub>t\n                         \\<Gamma>' * P1' aa a * P2' ba b\n 4. \\<And>a b aa ba h x y.\n       \\<lbrakk>p = (a, b); p' = (aa, ba);\n        h \\<Turnstile> \\<Gamma>1 * P1 aa a * P2 ba b\\<rbrakk>\n       \\<Longrightarrow> R x y \\<Longrightarrow>\\<^sub>t R x y", "applyS (sep_auto simp add: hn_ctxt_def invalid_assn_def mod_star_conv)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba h.\n       \\<lbrakk>p = (a, b); p' = (aa, ba);\n        h \\<Turnstile> \\<Gamma>1 * P1 aa a * P2 ba b\\<rbrakk>\n       \\<Longrightarrow> p' = (aa, ba)\n 2. \\<And>a b aa ba h.\n       \\<lbrakk>p = (a, b); p' = (aa, ba);\n        h \\<Turnstile> \\<Gamma>1 * P1 aa a * P2 ba b\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>h a aa b ba \\<Longrightarrow>\\<^sub>t\n                         \\<Gamma>' * P1' aa a * P2' ba b\n 3. \\<And>a b aa ba h x y.\n       \\<lbrakk>p = (a, b); p' = (aa, ba);\n        h \\<Turnstile> \\<Gamma>1 * P1 aa a * P2 ba b\\<rbrakk>\n       \\<Longrightarrow> R x y \\<Longrightarrow>\\<^sub>t R x y", "applyS simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba h.\n       \\<lbrakk>p = (a, b); p' = (aa, ba);\n        h \\<Turnstile> \\<Gamma>1 * P1 aa a * P2 ba b\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>h a aa b ba \\<Longrightarrow>\\<^sub>t\n                         \\<Gamma>' * P1' aa a * P2' ba b\n 2. \\<And>a b aa ba h x y.\n       \\<lbrakk>p = (a, b); p' = (aa, ba);\n        h \\<Turnstile> \\<Gamma>1 * P1 aa a * P2 ba b\\<rbrakk>\n       \\<Longrightarrow> R x y \\<Longrightarrow>\\<^sub>t R x y", "apply1 (rule entt_trans[OF M])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba h.\n       \\<lbrakk>p = (a, b); p' = (aa, ba);\n        h \\<Turnstile> \\<Gamma>1 * P1 aa a * P2 ba b\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>' * hn_ctxt P1' aa a * hn_ctxt P2' ba b *\n                         hn_ctxt Pxx p' p \\<Longrightarrow>\\<^sub>t\n                         \\<Gamma>' * P1' aa a * P2' ba b\n 2. \\<And>a b aa ba h x y.\n       \\<lbrakk>p = (a, b); p' = (aa, ba);\n        h \\<Turnstile> \\<Gamma>1 * P1 aa a * P2 ba b\\<rbrakk>\n       \\<Longrightarrow> R x y \\<Longrightarrow>\\<^sub>t R x y", "applyS (sep_auto intro!: enttI simp: hn_ctxt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba h x y.\n       \\<lbrakk>p = (a, b); p' = (aa, ba);\n        h \\<Turnstile> \\<Gamma>1 * P1 aa a * P2 ba b\\<rbrakk>\n       \\<Longrightarrow> R x y \\<Longrightarrow>\\<^sub>t R x y", "applyS simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hn_Pair[sepref_fr_rules]: \"hn_refine \n  (hn_ctxt P1 x1 x1' * hn_ctxt P2 x2 x2')\n  (return (x1',x2'))\n  (hn_invalid P1 x1 x1' * hn_invalid P2 x2 x2')\n  (prod_assn P1 P2)\n  (RETURN$(Pair$x1$x2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt P1 x1 x1' * hn_ctxt P2 x2 x2') (return (x1', x2'))\n     (hn_invalid P1 x1 x1' * hn_invalid P2 x2 x2') (P1 \\<times>\\<^sub>a P2)\n     (RETURN $ (Pair $ x1 $ x2))", "unfolding hn_refine_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (RETURN $ (Pair $ x1 $ x2)) \\<longrightarrow>\n    <hn_ctxt P1 x1 x1' *\n     hn_ctxt P2 x2\n      x2'> return\n            (x1',\n             x2') <\\<lambda>r.\n                      hn_invalid P1 x1 x1' * hn_invalid P2 x2 x2' *\n                      (\\<exists>\\<^sub>Ax.\n                          (P1 \\<times>\\<^sub>a P2) x r *\n                          \\<up>\n                           (RETURN x\n                            \\<le> RETURN $ (Pair $ x1 $ x2)))>\\<^sub>t", "apply (sep_auto simp: hn_ctxt_def prod_assn_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P1 x1 x1' * P2 x2 x2' \\<Longrightarrow>\\<^sub>A\n    invalid_assn P1 x1 x1' * invalid_assn P2 x2 x2' * P1 x1 x1' *\n    P2 x2 x2' *\n    true", "apply (rule ent_frame_fwd[OF invalidate_clone'[of P1]], frame_inference)"], ["proof (prove)\ngoal (1 subgoal):\n 1. invalid_assn P1 x1 x1' * P1 x1 x1' * true *\n    P2 x2 x2' \\<Longrightarrow>\\<^sub>A\n    invalid_assn P1 x1 x1' * invalid_assn P2 x2 x2' * P1 x1 x1' *\n    P2 x2 x2' *\n    true", "apply (rule ent_frame_fwd[OF invalidate_clone'[of P2]], frame_inference)"], ["proof (prove)\ngoal (1 subgoal):\n 1. invalid_assn P2 x2 x2' * P2 x2 x2' * true *\n    (invalid_assn P1 x1 x1' * P1 x1 x1' * true) \\<Longrightarrow>\\<^sub>A\n    invalid_assn P1 x1 x1' * invalid_assn P2 x2 x2' * P1 x1 x1' *\n    P2 x2 x2' *\n    true", "apply sep_auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fst_hnr[sepref_fr_rules]: \"(return o fst,RETURN o fst) \\<in> (prod_assn A B)\\<^sup>d \\<rightarrow>\\<^sub>a A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (return \\<circ> fst, RETURN \\<circ> fst)\n    \\<in> (A \\<times>\\<^sub>a B)\\<^sup>d \\<rightarrow>\\<^sub>a A", "by sepref_to_hoare sep_auto"], ["", "lemma snd_hnr[sepref_fr_rules]: \"(return o snd,RETURN o snd) \\<in> (prod_assn A B)\\<^sup>d \\<rightarrow>\\<^sub>a B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (return \\<circ> snd, RETURN \\<circ> snd)\n    \\<in> (A \\<times>\\<^sub>a B)\\<^sup>d \\<rightarrow>\\<^sub>a B", "by sepref_to_hoare sep_auto"], ["", "lemmas [constraint_simps] = prod_assn_pure_conv"], ["", "lemmas [sepref_import_param] = param_prod_swap"], ["", "lemma rdomp_prodD[dest!]: \"rdomp (prod_assn A B) (a,b) \\<Longrightarrow> rdomp A a \\<and> rdomp B b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rdomp (A \\<times>\\<^sub>a B) (a, b) \\<Longrightarrow>\n    rdomp A a \\<and> rdomp B b", "unfolding rdomp_def prod_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>h c.\n       h \\<Turnstile>\n       (case ((a, b), c) of\n        ((a1, a2), c1, c2) \\<Rightarrow>\n          A a1 c1 * B a2 c2) \\<Longrightarrow>\n    (\\<exists>h c. h \\<Turnstile> A a c) \\<and>\n    (\\<exists>h c. h \\<Turnstile> B b c)", "by (sep_auto simp: mod_star_conv)"], ["", "subsection \"Option\""], ["", "fun option_assn :: \"('a \\<Rightarrow> 'c \\<Rightarrow> assn) \\<Rightarrow> 'a option \\<Rightarrow> 'c option \\<Rightarrow> assn\" where\n  \"option_assn P None None = emp\"\n| \"option_assn P (Some a) (Some c) = P a c\"\n| \"option_assn _ _ _ = false\""], ["", "lemma option_assn_simps[simp]:\n  \"option_assn P None v' = \\<up>(v'=None)\"\n  \"option_assn P v None = \\<up>(v=None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. option_assn P None v' = \\<up> (v' = None) &&&\n    option_assn P v None = \\<up> (v = None)", "apply (cases v', simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. option_assn P v None = \\<up> (v = None)", "apply (cases v, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma option_assn_alt_def: \"option_assn R a b = \n  (case (a,b) of (Some x, Some y) \\<Rightarrow> R x y\n  | (None,None) \\<Rightarrow> emp\n  | _ \\<Rightarrow> false)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. option_assn R a b =\n    (case (a, b) of (None, None) \\<Rightarrow> emp\n     | (None, Some a) \\<Rightarrow> false\n     | (Some x, None) \\<Rightarrow> false\n     | (Some x, Some y) \\<Rightarrow> R x y)", "by (auto split: option.split)"], ["", "lemma option_assn_pure_conv[constraint_simps]: \"option_assn (pure R) = pure (\\<langle>R\\<rangle>option_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. option_assn (pure R) = pure (\\<langle>R\\<rangle>option_rel)", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       option_assn (pure R) x xa = pure (\\<langle>R\\<rangle>option_rel) x xa", "apply (rename_tac a c)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a c.\n       option_assn (pure R) a c = pure (\\<langle>R\\<rangle>option_rel) a c", "apply (case_tac \"(pure R,a,c)\" rule: option_assn.cases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a c P.\n       (pure R, a, c) = (P, None, None) \\<Longrightarrow>\n       option_assn (pure R) a c = pure (\\<langle>R\\<rangle>option_rel) a c\n 2. \\<And>a c P aa ca.\n       (pure R, a, c) = (P, Some aa, Some ca) \\<Longrightarrow>\n       option_assn (pure R) a c = pure (\\<langle>R\\<rangle>option_rel) a c\n 3. \\<And>a c uu_ v.\n       (pure R, a, c) = (uu_, Some v, None) \\<Longrightarrow>\n       option_assn (pure R) a c = pure (\\<langle>R\\<rangle>option_rel) a c\n 4. \\<And>a c uu_ v.\n       (pure R, a, c) = (uu_, None, Some v) \\<Longrightarrow>\n       option_assn (pure R) a c = pure (\\<langle>R\\<rangle>option_rel) a c", "by (auto simp: pure_def)"], ["", "lemmas [sepref_import_rewrite, sepref_frame_normrel_eqs, fcomp_norm_unfold] = option_assn_pure_conv[symmetric]"], ["", "lemma hr_comp_option_conv[simp, fcomp_norm_unfold]: \"\n  hr_comp (option_assn R) (\\<langle>R'\\<rangle>option_rel) \n  = option_assn (hr_comp R R')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hr_comp (option_assn R) (\\<langle>R'\\<rangle>option_rel) =\n    option_assn (hr_comp R R')", "unfolding hr_comp_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a c.\n        \\<exists>\\<^sub>Ab.\n           option_assn R b c *\n           \\<up> ((b, a) \\<in> \\<langle>R'\\<rangle>option_rel)) =\n    option_assn\n     (\\<lambda>a c. \\<exists>\\<^sub>Ab. R b c * \\<up> ((b, a) \\<in> R'))", "apply (intro ext ent_iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a c.\n       \\<exists>\\<^sub>Ab.\n          option_assn R b c *\n          \\<up>\n           ((b, a)\n            \\<in> \\<langle>R'\\<rangle>option_rel) \\<Longrightarrow>\\<^sub>A\n       option_assn\n        (\\<lambda>a c. \\<exists>\\<^sub>Ab. R b c * \\<up> ((b, a) \\<in> R'))\n        a c\n 2. \\<And>a c.\n       option_assn\n        (\\<lambda>a c. \\<exists>\\<^sub>Ab. R b c * \\<up> ((b, a) \\<in> R'))\n        a c \\<Longrightarrow>\\<^sub>A\n       \\<exists>\\<^sub>Ab.\n          option_assn R b c *\n          \\<up> ((b, a) \\<in> \\<langle>R'\\<rangle>option_rel)", "apply solve_entails"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a c b.\n       (b, a) \\<in> \\<langle>R'\\<rangle>option_rel \\<Longrightarrow>\n       option_assn R b c \\<Longrightarrow>\\<^sub>A\n       option_assn\n        (\\<lambda>a c. \\<exists>\\<^sub>Ab. R b c * \\<up> ((b, a) \\<in> R'))\n        a c\n 2. \\<And>a c.\n       option_assn\n        (\\<lambda>a c. \\<exists>\\<^sub>Ab. R b c * \\<up> ((b, a) \\<in> R'))\n        a c \\<Longrightarrow>\\<^sub>A\n       \\<exists>\\<^sub>Ab.\n          option_assn R b c *\n          \\<up> ((b, a) \\<in> \\<langle>R'\\<rangle>option_rel)", "apply (case_tac \"(R,b,c)\" rule: option_assn.cases)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a c b P.\n       \\<lbrakk>(b, a) \\<in> \\<langle>R'\\<rangle>option_rel;\n        (R, b, c) = (P, None, None)\\<rbrakk>\n       \\<Longrightarrow> option_assn R b c \\<Longrightarrow>\\<^sub>A\n                         option_assn\n                          (\\<lambda>a c.\n                              \\<exists>\\<^sub>Ab.\n                                 R b c * \\<up> ((b, a) \\<in> R'))\n                          a c\n 2. \\<And>a c b P aa ca.\n       \\<lbrakk>(b, a) \\<in> \\<langle>R'\\<rangle>option_rel;\n        (R, b, c) = (P, Some aa, Some ca)\\<rbrakk>\n       \\<Longrightarrow> option_assn R b c \\<Longrightarrow>\\<^sub>A\n                         option_assn\n                          (\\<lambda>a c.\n                              \\<exists>\\<^sub>Ab.\n                                 R b c * \\<up> ((b, a) \\<in> R'))\n                          a c\n 3. \\<And>a c b uu_ v.\n       \\<lbrakk>(b, a) \\<in> \\<langle>R'\\<rangle>option_rel;\n        (R, b, c) = (uu_, Some v, None)\\<rbrakk>\n       \\<Longrightarrow> option_assn R b c \\<Longrightarrow>\\<^sub>A\n                         option_assn\n                          (\\<lambda>a c.\n                              \\<exists>\\<^sub>Ab.\n                                 R b c * \\<up> ((b, a) \\<in> R'))\n                          a c\n 4. \\<And>a c b uu_ v.\n       \\<lbrakk>(b, a) \\<in> \\<langle>R'\\<rangle>option_rel;\n        (R, b, c) = (uu_, None, Some v)\\<rbrakk>\n       \\<Longrightarrow> option_assn R b c \\<Longrightarrow>\\<^sub>A\n                         option_assn\n                          (\\<lambda>a c.\n                              \\<exists>\\<^sub>Ab.\n                                 R b c * \\<up> ((b, a) \\<in> R'))\n                          a c\n 5. \\<And>a c.\n       option_assn\n        (\\<lambda>a c. \\<exists>\\<^sub>Ab. R b c * \\<up> ((b, a) \\<in> R'))\n        a c \\<Longrightarrow>\\<^sub>A\n       \\<exists>\\<^sub>Ab.\n          option_assn R b c *\n          \\<up> ((b, a) \\<in> \\<langle>R'\\<rangle>option_rel)", "apply clarsimp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa ca.\n       (Some aa, a) \\<in> \\<langle>R'\\<rangle>option_rel \\<Longrightarrow>\n       R aa ca \\<Longrightarrow>\\<^sub>A\n       option_assn\n        (\\<lambda>a c. \\<exists>\\<^sub>Ab. R b c * \\<up> ((b, a) \\<in> R'))\n        a (Some ca)\n 2. \\<And>a c.\n       option_assn\n        (\\<lambda>a c. \\<exists>\\<^sub>Ab. R b c * \\<up> ((b, a) \\<in> R'))\n        a c \\<Longrightarrow>\\<^sub>A\n       \\<exists>\\<^sub>Ab.\n          option_assn R b c *\n          \\<up> ((b, a) \\<in> \\<langle>R'\\<rangle>option_rel)", "apply (sep_auto simp: option_assn_alt_def split: option.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a c.\n       option_assn\n        (\\<lambda>a c. \\<exists>\\<^sub>Ab. R b c * \\<up> ((b, a) \\<in> R'))\n        a c \\<Longrightarrow>\\<^sub>A\n       \\<exists>\\<^sub>Ab.\n          option_assn R b c *\n          \\<up> ((b, a) \\<in> \\<langle>R'\\<rangle>option_rel)", "apply (clarsimp simp: option_assn_alt_def split: option.splits; safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a c.\n       emp \\<Longrightarrow>\\<^sub>A\n       \\<exists>\\<^sub>Ab.\n          (case b of None \\<Rightarrow> emp\n           | Some x \\<Rightarrow>\n               case None of None \\<Rightarrow> false\n               | Some xa \\<Rightarrow> R x xa) *\n          \\<up> (b = None)\n 2. \\<And>a c x2 x2a.\n       \\<exists>\\<^sub>Ab.\n          R b x2 * \\<up> ((b, x2a) \\<in> R') \\<Longrightarrow>\\<^sub>A\n       \\<exists>\\<^sub>Ab.\n          (case b of None \\<Rightarrow> false\n           | Some x \\<Rightarrow>\n               case Some x2 of None \\<Rightarrow> false\n               | Some xa \\<Rightarrow> R x xa) *\n          \\<up> ((b, Some x2a) \\<in> \\<langle>R'\\<rangle>option_rel)", "apply (sep_auto split: option.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a c x2 x2a.\n       \\<exists>\\<^sub>Ab.\n          R b x2 * \\<up> ((b, x2a) \\<in> R') \\<Longrightarrow>\\<^sub>A\n       \\<exists>\\<^sub>Ab.\n          (case b of None \\<Rightarrow> false\n           | Some x \\<Rightarrow>\n               case Some x2 of None \\<Rightarrow> false\n               | Some xa \\<Rightarrow> R x xa) *\n          \\<up> ((b, Some x2a) \\<in> \\<langle>R'\\<rangle>option_rel)", "apply (intro ent_ex_preI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a c x2 x2a b.\n       R b x2 * \\<up> ((b, x2a) \\<in> R') \\<Longrightarrow>\\<^sub>A\n       \\<exists>\\<^sub>Ab.\n          (case b of None \\<Rightarrow> false\n           | Some x \\<Rightarrow>\n               case Some x2 of None \\<Rightarrow> false\n               | Some xa \\<Rightarrow> R x xa) *\n          \\<up> ((b, Some x2a) \\<in> \\<langle>R'\\<rangle>option_rel)", "apply (rule ent_ex_postI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a c x2 x2a b.\n       R b x2 * \\<up> ((b, x2a) \\<in> R') \\<Longrightarrow>\\<^sub>A\n       (case ?b70 a c x2 x2a b of None \\<Rightarrow> false\n        | Some x \\<Rightarrow>\n            case Some x2 of None \\<Rightarrow> false\n            | Some xa \\<Rightarrow> R x xa) *\n       \\<up>\n        ((?b70 a c x2 x2a b, Some x2a) \\<in> \\<langle>R'\\<rangle>option_rel)", "apply (sep_auto split: option.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma option_assn_precise[safe_constraint_rules]: \n  assumes \"precise P\"  \n  shows \"precise (option_assn P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. precise (option_assn P)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a' h p F F'.\n       h \\<Turnstile>\n       option_assn P a p * F \\<and>\\<^sub>A\n       option_assn P a' p * F' \\<Longrightarrow>\n       a = a'", "fix a a' p h F F'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a' h p F F'.\n       h \\<Turnstile>\n       option_assn P a p * F \\<and>\\<^sub>A\n       option_assn P a' p * F' \\<Longrightarrow>\n       a = a'", "assume A: \"h \\<Turnstile> option_assn P a p * F \\<and>\\<^sub>A option_assn P a' p * F'\""], ["proof (state)\nthis:\n  h \\<Turnstile>\n  option_assn P a p * F \\<and>\\<^sub>A option_assn P a' p * F'\n\ngoal (1 subgoal):\n 1. \\<And>a a' h p F F'.\n       h \\<Turnstile>\n       option_assn P a p * F \\<and>\\<^sub>A\n       option_assn P a' p * F' \\<Longrightarrow>\n       a = a'", "thus \"a=a'\""], ["proof (prove)\nusing this:\n  h \\<Turnstile>\n  option_assn P a p * F \\<and>\\<^sub>A option_assn P a' p * F'\n\ngoal (1 subgoal):\n 1. a = a'", "proof (cases \"(P,a,p)\" rule: option_assn.cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>Pa.\n       \\<lbrakk>h \\<Turnstile>\n                option_assn P a p * F \\<and>\\<^sub>A\n                option_assn P a' p * F';\n        (P, a, p) = (Pa, None, None)\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. \\<And>Pa aa c.\n       \\<lbrakk>h \\<Turnstile>\n                option_assn P a p * F \\<and>\\<^sub>A\n                option_assn P a' p * F';\n        (P, a, p) = (Pa, Some aa, Some c)\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. \\<And>uu_ v.\n       \\<lbrakk>h \\<Turnstile>\n                option_assn P a p * F \\<and>\\<^sub>A\n                option_assn P a' p * F';\n        (P, a, p) = (uu_, Some v, None)\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 4. \\<And>uu_ v.\n       \\<lbrakk>h \\<Turnstile>\n                option_assn P a p * F \\<and>\\<^sub>A\n                option_assn P a' p * F';\n        (P, a, p) = (uu_, None, Some v)\\<rbrakk>\n       \\<Longrightarrow> a = a'", "case (2 _ av pv)"], ["proof (state)\nthis:\n  (P, a, p) = (P_, Some av, Some pv)\n\ngoal (4 subgoals):\n 1. \\<And>Pa.\n       \\<lbrakk>h \\<Turnstile>\n                option_assn P a p * F \\<and>\\<^sub>A\n                option_assn P a' p * F';\n        (P, a, p) = (Pa, None, None)\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. \\<And>Pa aa c.\n       \\<lbrakk>h \\<Turnstile>\n                option_assn P a p * F \\<and>\\<^sub>A\n                option_assn P a' p * F';\n        (P, a, p) = (Pa, Some aa, Some c)\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. \\<And>uu_ v.\n       \\<lbrakk>h \\<Turnstile>\n                option_assn P a p * F \\<and>\\<^sub>A\n                option_assn P a' p * F';\n        (P, a, p) = (uu_, Some v, None)\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 4. \\<And>uu_ v.\n       \\<lbrakk>h \\<Turnstile>\n                option_assn P a p * F \\<and>\\<^sub>A\n                option_assn P a' p * F';\n        (P, a, p) = (uu_, None, Some v)\\<rbrakk>\n       \\<Longrightarrow> a = a'", "hence [simp]: \"a=Some av\" \"p=Some pv\""], ["proof (prove)\nusing this:\n  (P, a, p) = (P_, Some av, Some pv)\n\ngoal (1 subgoal):\n 1. a = Some av &&& p = Some pv", "by simp_all"], ["proof (state)\nthis:\n  a = Some av\n  p = Some pv\n\ngoal (4 subgoals):\n 1. \\<And>Pa.\n       \\<lbrakk>h \\<Turnstile>\n                option_assn P a p * F \\<and>\\<^sub>A\n                option_assn P a' p * F';\n        (P, a, p) = (Pa, None, None)\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. \\<And>Pa aa c.\n       \\<lbrakk>h \\<Turnstile>\n                option_assn P a p * F \\<and>\\<^sub>A\n                option_assn P a' p * F';\n        (P, a, p) = (Pa, Some aa, Some c)\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. \\<And>uu_ v.\n       \\<lbrakk>h \\<Turnstile>\n                option_assn P a p * F \\<and>\\<^sub>A\n                option_assn P a' p * F';\n        (P, a, p) = (uu_, Some v, None)\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 4. \\<And>uu_ v.\n       \\<lbrakk>h \\<Turnstile>\n                option_assn P a p * F \\<and>\\<^sub>A\n                option_assn P a' p * F';\n        (P, a, p) = (uu_, None, Some v)\\<rbrakk>\n       \\<Longrightarrow> a = a'", "from A"], ["proof (chain)\npicking this:\n  h \\<Turnstile>\n  option_assn P a p * F \\<and>\\<^sub>A option_assn P a' p * F'", "obtain av' where [simp]: \"a'=Some av'\""], ["proof (prove)\nusing this:\n  h \\<Turnstile>\n  option_assn P a p * F \\<and>\\<^sub>A option_assn P a' p * F'\n\ngoal (1 subgoal):\n 1. (\\<And>av'. a' = Some av' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases a', simp_all)"], ["proof (state)\nthis:\n  a' = Some av'\n\ngoal (4 subgoals):\n 1. \\<And>Pa.\n       \\<lbrakk>h \\<Turnstile>\n                option_assn P a p * F \\<and>\\<^sub>A\n                option_assn P a' p * F';\n        (P, a, p) = (Pa, None, None)\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. \\<And>Pa aa c.\n       \\<lbrakk>h \\<Turnstile>\n                option_assn P a p * F \\<and>\\<^sub>A\n                option_assn P a' p * F';\n        (P, a, p) = (Pa, Some aa, Some c)\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. \\<And>uu_ v.\n       \\<lbrakk>h \\<Turnstile>\n                option_assn P a p * F \\<and>\\<^sub>A\n                option_assn P a' p * F';\n        (P, a, p) = (uu_, Some v, None)\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 4. \\<And>uu_ v.\n       \\<lbrakk>h \\<Turnstile>\n                option_assn P a p * F \\<and>\\<^sub>A\n                option_assn P a' p * F';\n        (P, a, p) = (uu_, None, Some v)\\<rbrakk>\n       \\<Longrightarrow> a = a'", "from A"], ["proof (chain)\npicking this:\n  h \\<Turnstile>\n  option_assn P a p * F \\<and>\\<^sub>A option_assn P a' p * F'", "have \"h \\<Turnstile> P av pv * F \\<and>\\<^sub>A P av' pv * F'\""], ["proof (prove)\nusing this:\n  h \\<Turnstile>\n  option_assn P a p * F \\<and>\\<^sub>A option_assn P a' p * F'\n\ngoal (1 subgoal):\n 1. h \\<Turnstile> P av pv * F \\<and>\\<^sub>A P av' pv * F'", "by simp"], ["proof (state)\nthis:\n  h \\<Turnstile> P av pv * F \\<and>\\<^sub>A P av' pv * F'\n\ngoal (4 subgoals):\n 1. \\<And>Pa.\n       \\<lbrakk>h \\<Turnstile>\n                option_assn P a p * F \\<and>\\<^sub>A\n                option_assn P a' p * F';\n        (P, a, p) = (Pa, None, None)\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. \\<And>Pa aa c.\n       \\<lbrakk>h \\<Turnstile>\n                option_assn P a p * F \\<and>\\<^sub>A\n                option_assn P a' p * F';\n        (P, a, p) = (Pa, Some aa, Some c)\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. \\<And>uu_ v.\n       \\<lbrakk>h \\<Turnstile>\n                option_assn P a p * F \\<and>\\<^sub>A\n                option_assn P a' p * F';\n        (P, a, p) = (uu_, Some v, None)\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 4. \\<And>uu_ v.\n       \\<lbrakk>h \\<Turnstile>\n                option_assn P a p * F \\<and>\\<^sub>A\n                option_assn P a' p * F';\n        (P, a, p) = (uu_, None, Some v)\\<rbrakk>\n       \\<Longrightarrow> a = a'", "with \\<open>precise P\\<close>"], ["proof (chain)\npicking this:\n  precise P\n  h \\<Turnstile> P av pv * F \\<and>\\<^sub>A P av' pv * F'", "have \"av=av'\""], ["proof (prove)\nusing this:\n  precise P\n  h \\<Turnstile> P av pv * F \\<and>\\<^sub>A P av' pv * F'\n\ngoal (1 subgoal):\n 1. av = av'", "by (rule preciseD)"], ["proof (state)\nthis:\n  av = av'\n\ngoal (4 subgoals):\n 1. \\<And>Pa.\n       \\<lbrakk>h \\<Turnstile>\n                option_assn P a p * F \\<and>\\<^sub>A\n                option_assn P a' p * F';\n        (P, a, p) = (Pa, None, None)\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. \\<And>Pa aa c.\n       \\<lbrakk>h \\<Turnstile>\n                option_assn P a p * F \\<and>\\<^sub>A\n                option_assn P a' p * F';\n        (P, a, p) = (Pa, Some aa, Some c)\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. \\<And>uu_ v.\n       \\<lbrakk>h \\<Turnstile>\n                option_assn P a p * F \\<and>\\<^sub>A\n                option_assn P a' p * F';\n        (P, a, p) = (uu_, Some v, None)\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 4. \\<And>uu_ v.\n       \\<lbrakk>h \\<Turnstile>\n                option_assn P a p * F \\<and>\\<^sub>A\n                option_assn P a' p * F';\n        (P, a, p) = (uu_, None, Some v)\\<rbrakk>\n       \\<Longrightarrow> a = a'", "thus ?thesis"], ["proof (prove)\nusing this:\n  av = av'\n\ngoal (1 subgoal):\n 1. a = a'", "by simp"], ["proof (state)\nthis:\n  a = a'\n\ngoal (3 subgoals):\n 1. \\<And>Pa.\n       \\<lbrakk>h \\<Turnstile>\n                option_assn P a p * F \\<and>\\<^sub>A\n                option_assn P a' p * F';\n        (P, a, p) = (Pa, None, None)\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. \\<And>uu_ v.\n       \\<lbrakk>h \\<Turnstile>\n                option_assn P a p * F \\<and>\\<^sub>A\n                option_assn P a' p * F';\n        (P, a, p) = (uu_, Some v, None)\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. \\<And>uu_ v.\n       \\<lbrakk>h \\<Turnstile>\n                option_assn P a p * F \\<and>\\<^sub>A\n                option_assn P a' p * F';\n        (P, a, p) = (uu_, None, Some v)\\<rbrakk>\n       \\<Longrightarrow> a = a'", "qed simp_all"], ["proof (state)\nthis:\n  a = a'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pure_option[safe_constraint_rules]: \n  assumes P: \"is_pure P\"\n  shows \"is_pure (option_assn P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pure (option_assn P)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_pure (option_assn P)", "from P"], ["proof (chain)\npicking this:\n  is_pure P", "obtain P' where P': \"\\<And>x x'. P x x' = \\<up>(P' x x')\""], ["proof (prove)\nusing this:\n  is_pure P\n\ngoal (1 subgoal):\n 1. (\\<And>P'.\n        (\\<And>x x'. P x x' = \\<up> (P' x x')) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using is_pureE"], ["proof (prove)\nusing this:\n  is_pure P\n  \\<lbrakk>is_pure ?P;\n   \\<And>P'.\n      (\\<And>x x'. ?P x x' = \\<up> (P' x x')) \\<Longrightarrow>\n      ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>P'.\n        (\\<And>x x'. P x x' = \\<up> (P' x x')) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  P ?x ?x' = \\<up> (P' ?x ?x')\n\ngoal (1 subgoal):\n 1. is_pure (option_assn P)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pure (option_assn P)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x x'. option_assn P x x' = \\<up> (?P' x x')", "fix x x'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x x'. option_assn P x x' = \\<up> (?P' x x')", "show \"option_assn P x x' =\n         \\<up> (case (x, x') of \n             (None,None) \\<Rightarrow> True | (Some v, Some v') \\<Rightarrow> P' v v' | _ \\<Rightarrow> False\n           )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. option_assn P x x' =\n    \\<up>\n     (case (x, x') of (None, None) \\<Rightarrow> True\n      | (None, Some a) \\<Rightarrow> False\n      | (Some v, None) \\<Rightarrow> False\n      | (Some v, Some v') \\<Rightarrow> P' v v')", "apply (simp add: P' split: prod.split option.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  option_assn P x x' =\n  \\<up>\n   (case (x, x') of (None, None) \\<Rightarrow> True\n    | (None, Some a) \\<Rightarrow> False\n    | (Some v, None) \\<Rightarrow> False\n    | (Some v, Some v') \\<Rightarrow> P' v v')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_pure (option_assn P)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hn_ctxt_option: \"option_assn A x y = z \\<Longrightarrow> hn_ctxt (option_assn A) x y = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. option_assn A x y = z \\<Longrightarrow> hn_ctxt (option_assn A) x y = z", "by (simp add: hn_ctxt_def)"], ["", "lemma hn_case_option[sepref_prep_comb_rule, sepref_comb_rules]:\n  fixes p p' P\n  defines [simp]: \"INVE \\<equiv> hn_invalid (option_assn P) p p'\"\n  assumes FR: \"\\<Gamma> \\<Longrightarrow>\\<^sub>t hn_ctxt (option_assn P) p p' * F\"\n  assumes Rn: \"p=None \\<Longrightarrow> hn_refine (hn_ctxt (option_assn P) p p' * F) f1' (hn_ctxt XX1 p p' * \\<Gamma>1') R f1\"\n  assumes Rs: \"\\<And>x x'. \\<lbrakk> p=Some x; p'=Some x' \\<rbrakk> \\<Longrightarrow> \n    hn_refine (hn_ctxt P x x' * INVE * F) (f2' x') (hn_ctxt P' x x' * hn_ctxt XX2 p p' * \\<Gamma>2') R (f2 x)\"\n  assumes MERGE1: \"\\<Gamma>1' \\<or>\\<^sub>A \\<Gamma>2' \\<Longrightarrow>\\<^sub>t \\<Gamma>'\"  \n  shows \"hn_refine \\<Gamma> (case_option f1' f2' p') (hn_ctxt (option_assn P') p p' * \\<Gamma>') R (case_option$f1$(\\<lambda>\\<^sub>2x. f2 x)$p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine \\<Gamma>\n     (case p' of None \\<Rightarrow> f1' | Some x \\<Rightarrow> f2' x)\n     (hn_ctxt (option_assn P') p p' * \\<Gamma>') R\n     (case_option $ f1 $ (\\<lambda>x. (#f2 x#)) $ p)", "apply (rule hn_refine_cons_pre[OF FR])"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt (option_assn P) p p' * F)\n     (case p' of None \\<Rightarrow> f1' | Some x \\<Rightarrow> f2' x)\n     (hn_ctxt (option_assn P') p p' * \\<Gamma>') R\n     (case_option $ f1 $ (\\<lambda>x. (#f2 x#)) $ p)", "apply1 extract_hnr_invalids"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h h1 h2.\n       \\<lbrakk>h2 \\<Turnstile> F;\n        hn_invalid (option_assn P) p p' = true\\<rbrakk>\n       \\<Longrightarrow> hn_refine (hn_ctxt (option_assn P) p p' * F)\n                          (case p' of None \\<Rightarrow> f1'\n                           | Some x \\<Rightarrow> f2' x)\n                          (hn_ctxt (option_assn P') p p' * \\<Gamma>') R\n                          (case_option $ f1 $ (\\<lambda>x. (#f2 x#)) $ p)", "apply (cases p; cases p'; simp add: option_assn.simps[THEN hn_ctxt_option])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>h2.\n       \\<lbrakk>h2 \\<Turnstile> F;\n        hn_invalid (option_assn P) None None = true; p = None;\n        p' = None\\<rbrakk>\n       \\<Longrightarrow> hn_refine F f1' \\<Gamma>' R f1\n 2. \\<And>h2 a aa.\n       \\<lbrakk>h2 \\<Turnstile> F;\n        hn_invalid (option_assn P) (Some a) (Some aa) = true; p = Some a;\n        p' = Some aa\\<rbrakk>\n       \\<Longrightarrow> hn_refine (P a aa * F) (f2' aa)\n                          (P' a aa * \\<Gamma>') R (f2 a)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (option_assn P) None None = true; p = None;\n     p' = None\\<rbrakk>\n    \\<Longrightarrow> hn_refine F f1' \\<Gamma>' R f1", "apply (rule hn_refine_cons[OF _ Rn _ entt_refl]; assumption?)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (option_assn P) None None = true; p = None;\n     p' = None\\<rbrakk>\n    \\<Longrightarrow> F \\<Longrightarrow>\\<^sub>t\n                      hn_ctxt (option_assn P) p p' * F\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (option_assn P) None None = true; p = None;\n     p' = None\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt XX1 p p' *\n                      \\<Gamma>1' \\<Longrightarrow>\\<^sub>t\n                      \\<Gamma>'", "applyS (simp add: hn_ctxt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (option_assn P) None None = true; p = None;\n     p' = None\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt XX1 p p' *\n                      \\<Gamma>1' \\<Longrightarrow>\\<^sub>t\n                      \\<Gamma>'", "apply (subst mult.commute, rule entt_fr_drop)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (option_assn P) None None = true; p = None;\n     p' = None\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>1' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "apply (rule entt_trans[OF _ MERGE1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (option_assn P) None None = true; p = None;\n     p' = None\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>1' \\<Longrightarrow>\\<^sub>t\n                      \\<Gamma>1' \\<or>\\<^sub>A \\<Gamma>2'", "apply (simp add: ent_disjI1' ent_disjI2')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h2 a aa.\n       \\<lbrakk>h2 \\<Turnstile> F;\n        hn_invalid (option_assn P) (Some a) (Some aa) = true; p = Some a;\n        p' = Some aa\\<rbrakk>\n       \\<Longrightarrow> hn_refine (P a aa * F) (f2' aa)\n                          (P' a aa * \\<Gamma>') R (f2 a)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (option_assn P) (Some a_) (Some aa_) = true; p = Some a_;\n     p' = Some aa_\\<rbrakk>\n    \\<Longrightarrow> hn_refine (P a_ aa_ * F) (f2' aa_)\n                       (P' a_ aa_ * \\<Gamma>') R (f2 a_)", "apply (rule hn_refine_cons[OF _ Rs _ entt_refl]; assumption?)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (option_assn P) (Some a_) (Some aa_) = true; p = Some a_;\n     p' = Some aa_\\<rbrakk>\n    \\<Longrightarrow> P a_ aa_ * F \\<Longrightarrow>\\<^sub>t\n                      hn_ctxt P a_ aa_ * INVE * F\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (option_assn P) (Some a_) (Some aa_) = true; p = Some a_;\n     p' = Some aa_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt P' a_ aa_ * hn_ctxt XX2 p p' *\n                      \\<Gamma>2' \\<Longrightarrow>\\<^sub>t\n                      P' a_ aa_ * \\<Gamma>'", "applyS (simp add: hn_ctxt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (option_assn P) (Some a_) (Some aa_) = true; p = Some a_;\n     p' = Some aa_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt P' a_ aa_ * hn_ctxt XX2 p p' *\n                      \\<Gamma>2' \\<Longrightarrow>\\<^sub>t\n                      P' a_ aa_ * \\<Gamma>'", "apply (rule entt_star_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (option_assn P) (Some a_) (Some aa_) = true; p = Some a_;\n     p' = Some aa_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt P' a_ aa_ *\n                      hn_ctxt XX2 p p' \\<Longrightarrow>\\<^sub>t\n                      P' a_ aa_\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (option_assn P) (Some a_) (Some aa_) = true; p = Some a_;\n     p' = Some aa_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>2' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "apply1 (rule entt_fr_drop)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (option_assn P) (Some a_) (Some aa_) = true; p = Some a_;\n     p' = Some aa_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt P' a_ aa_ \\<Longrightarrow>\\<^sub>t P' a_ aa_\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (option_assn P) (Some a_) (Some aa_) = true; p = Some a_;\n     p' = Some aa_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>2' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "applyS (simp add: hn_ctxt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (option_assn P) (Some a_) (Some aa_) = true; p = Some a_;\n     p' = Some aa_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>2' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "apply1 (rule entt_trans[OF _ MERGE1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (option_assn P) (Some a_) (Some aa_) = true; p = Some a_;\n     p' = Some aa_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>2' \\<Longrightarrow>\\<^sub>t\n                      \\<Gamma>1' \\<or>\\<^sub>A \\<Gamma>2'", "applyS (simp add: hn_ctxt_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hn_None[sepref_fr_rules]:\n  \"hn_refine emp (return None) emp (option_assn P) (RETURN$None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine emp (return None) emp (option_assn P) (RETURN $ None)", "by rule sep_auto"], ["", "lemma hn_Some[sepref_fr_rules]: \"hn_refine \n  (hn_ctxt P v v')\n  (return (Some v'))\n  (hn_invalid P v v')\n  (option_assn P)\n  (RETURN$(Some$v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt P v v') (return (Some v')) (hn_invalid P v v')\n     (option_assn P) (RETURN $ (Some $ v))", "by rule (sep_auto simp: hn_ctxt_def invalidate_clone')"], ["", "definition \"imp_option_eq eq a b \\<equiv> case (a,b) of \n  (None,None) \\<Rightarrow> return True\n| (Some a, Some b) \\<Rightarrow> eq a b\n| _ \\<Rightarrow> return False\""], ["", "(* TODO: This is some kind of generic algorithm! Use GEN_ALGO here, and \n  let GEN_ALGO re-use the registered operator rules *)"], ["", "lemma option_assn_eq[sepref_comb_rules]:\n  fixes a b :: \"'a option\"\n  assumes F1: \"\\<Gamma> \\<Longrightarrow>\\<^sub>t hn_ctxt (option_assn P) a a' * hn_ctxt (option_assn P) b b' * \\<Gamma>1\"\n  assumes EQ: \"\\<And>va va' vb vb'. hn_refine \n    (hn_ctxt P va va' * hn_ctxt P vb vb' * \\<Gamma>1)\n    (eq' va' vb') \n    (\\<Gamma>' va va' vb vb') \n    bool_assn\n    (RETURN$((=) $va$vb))\"\n  assumes F2: \n    \"\\<And>va va' vb vb'. \n      \\<Gamma>' va va' vb vb' \\<Longrightarrow>\\<^sub>t hn_ctxt P va va' * hn_ctxt P vb vb' * \\<Gamma>1\"\n  shows \"hn_refine \n    \\<Gamma> \n    (imp_option_eq eq' a' b') \n    (hn_ctxt (option_assn P) a a' * hn_ctxt (option_assn P) b b' * \\<Gamma>1)\n    bool_assn \n    (RETURN$((=) $a$b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine \\<Gamma> (imp_option_eq eq' a' b')\n     (hn_ctxt (option_assn P) a a' * hn_ctxt (option_assn P) b b' *\n      \\<Gamma>1)\n     bool_assn (RETURN $ ((=) $ a $ b))", "apply (rule hn_refine_cons_pre[OF F1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine\n     (hn_ctxt (option_assn P) a a' * hn_ctxt (option_assn P) b b' *\n      \\<Gamma>1)\n     (imp_option_eq eq' a' b')\n     (hn_ctxt (option_assn P) a a' * hn_ctxt (option_assn P) b b' *\n      \\<Gamma>1)\n     bool_assn (RETURN $ ((=) $ a $ b))", "unfolding imp_option_eq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine\n     (hn_ctxt (option_assn P) a a' * hn_ctxt (option_assn P) b b' *\n      \\<Gamma>1)\n     (case (a', b') of (None, None) \\<Rightarrow> return True\n      | (None, Some aa) \\<Rightarrow> return False\n      | (Some a, None) \\<Rightarrow> return False\n      | (Some a, Some b) \\<Rightarrow> eq' a b)\n     (hn_ctxt (option_assn P) a a' * hn_ctxt (option_assn P) b b' *\n      \\<Gamma>1)\n     bool_assn (RETURN $ ((=) $ a $ b))", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (RETURN $ ((=) $ a $ b)) \\<Longrightarrow>\n    <hn_ctxt (option_assn P) a a' * hn_ctxt (option_assn P) b b' *\n     \\<Gamma>1> case (a', b') of (None, None) \\<Rightarrow> return True\n                | (None, Some aa) \\<Rightarrow> return False\n                | (Some a, None) \\<Rightarrow> return False\n                | (Some a, Some b) \\<Rightarrow>\n                    eq' a\n                     b <\\<lambda>r.\n                           hn_ctxt (option_assn P) a a' *\n                           hn_ctxt (option_assn P) b b' *\n                           \\<Gamma>1 *\n                           (\\<exists>\\<^sub>Ax.\n                               bool_assn x r *\n                               \\<up>\n                                (RETURN x\n                                 \\<le> RETURN $ ((=) $ a $ b)))>\\<^sub>t", "apply (simp split: option.split add: hn_ctxt_def, intro impI conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>b' = None; a' = None; a = None; b = None\\<rbrakk>\n    \\<Longrightarrow> <\\<Gamma>1> return True\n                      <\\<lambda>r.\n                          \\<exists>\\<^sub>Ax.\n                             \\<Gamma>1 * bool_assn x r * true * \\<up> x>\n 2. b' = None \\<Longrightarrow>\n    \\<forall>x2.\n       a' = Some x2 \\<longrightarrow>\n       b = None \\<longrightarrow> <option_assn P a (Some x2) * \\<Gamma>1>\n       return False\n       <\\<lambda>r.\n           \\<exists>\\<^sub>Ax.\n              option_assn P a (Some x2) * \\<Gamma>1 * bool_assn x r * true *\n              \\<up> (x = (a = None))>\n 3. \\<forall>x2.\n       b' = Some x2 \\<longrightarrow>\n       (a' = None \\<longrightarrow>\n        a = None \\<longrightarrow> <option_assn P b (Some x2) * \\<Gamma>1>\n        return False\n        <\\<lambda>r.\n            \\<exists>\\<^sub>Ax.\n               option_assn P b (Some x2) * \\<Gamma>1 * bool_assn x r *\n               true *\n               \\<up> (x = (None = b))>) \\<and>\n       (\\<forall>x2a.\n           a' = Some x2a \\<longrightarrow>\n           <option_assn P a (Some x2a) * option_assn P b (Some x2) *\n            \\<Gamma>1>\n           eq' x2a x2\n           <\\<lambda>r.\n               \\<exists>\\<^sub>Ax.\n                  option_assn P a (Some x2a) * option_assn P b (Some x2) *\n                  \\<Gamma>1 *\n                  bool_assn x r *\n                  true *\n                  \\<up> (x = (a = b))>)", "apply (sep_auto split: option.split simp: hn_ctxt_def pure_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. b' = None \\<Longrightarrow>\n    \\<forall>x2.\n       a' = Some x2 \\<longrightarrow>\n       b = None \\<longrightarrow> <option_assn P a (Some x2) * \\<Gamma>1>\n       return False\n       <\\<lambda>r.\n           \\<exists>\\<^sub>Ax.\n              option_assn P a (Some x2) * \\<Gamma>1 * bool_assn x r * true *\n              \\<up> (x = (a = None))>\n 2. \\<forall>x2.\n       b' = Some x2 \\<longrightarrow>\n       (a' = None \\<longrightarrow>\n        a = None \\<longrightarrow> <option_assn P b (Some x2) * \\<Gamma>1>\n        return False\n        <\\<lambda>r.\n            \\<exists>\\<^sub>Ax.\n               option_assn P b (Some x2) * \\<Gamma>1 * bool_assn x r *\n               true *\n               \\<up> (x = (None = b))>) \\<and>\n       (\\<forall>x2a.\n           a' = Some x2a \\<longrightarrow>\n           <option_assn P a (Some x2a) * option_assn P b (Some x2) *\n            \\<Gamma>1>\n           eq' x2a x2\n           <\\<lambda>r.\n               \\<exists>\\<^sub>Ax.\n                  option_assn P a (Some x2a) * option_assn P b (Some x2) *\n                  \\<Gamma>1 *\n                  bool_assn x r *\n                  true *\n                  \\<up> (x = (a = b))>)", "apply (cases a, (sep_auto split: option.split simp: hn_ctxt_def pure_def)+)[]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x2.\n       b' = Some x2 \\<longrightarrow>\n       (a' = None \\<longrightarrow>\n        a = None \\<longrightarrow> <option_assn P b (Some x2) * \\<Gamma>1>\n        return False\n        <\\<lambda>r.\n            \\<exists>\\<^sub>Ax.\n               option_assn P b (Some x2) * \\<Gamma>1 * bool_assn x r *\n               true *\n               \\<up> (x = (None = b))>) \\<and>\n       (\\<forall>x2a.\n           a' = Some x2a \\<longrightarrow>\n           <option_assn P a (Some x2a) * option_assn P b (Some x2) *\n            \\<Gamma>1>\n           eq' x2a x2\n           <\\<lambda>r.\n               \\<exists>\\<^sub>Ax.\n                  option_assn P a (Some x2a) * option_assn P b (Some x2) *\n                  \\<Gamma>1 *\n                  bool_assn x r *\n                  true *\n                  \\<up> (x = (a = b))>)", "apply (cases a, (sep_auto split: option.split simp: hn_ctxt_def pure_def)+)[]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa x2 x2a.\n       \\<lbrakk>a = Some aa; b' = Some x2; a' = Some x2a\\<rbrakk>\n       \\<Longrightarrow> <P aa x2a * option_assn P b (Some x2) * \\<Gamma>1>\n                         eq' x2a x2\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Ax.\n                                P aa x2a * option_assn P b (Some x2) *\n                                \\<Gamma>1 *\n                                true *\n                                \\<up> (r = x \\<and> x = (Some aa = b))>", "apply (cases b, (sep_auto split: option.split simp: hn_ctxt_def pure_def)+)[]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa x2 x2a aaa.\n       \\<lbrakk>a = Some aa; b' = Some x2; a' = Some x2a;\n        b = Some aaa\\<rbrakk>\n       \\<Longrightarrow> <P aa x2a * P aaa x2 * \\<Gamma>1> eq' x2a x2\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Ax.\n                                P aa x2a * P aaa x2 * \\<Gamma>1 * true *\n                                \\<up> (r = x \\<and> x = (aa = aaa))>", "apply (rule cons_post_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa x2 x2a aaa.\n       \\<lbrakk>a = Some aa; b' = Some x2; a' = Some x2a;\n        b = Some aaa\\<rbrakk>\n       \\<Longrightarrow> <P aa x2a * P aaa x2 * \\<Gamma>1> eq' x2a x2\n                         <?Q111 aa x2 x2a aaa>\n 2. \\<And>aa x2 x2a aaa x.\n       \\<lbrakk>a = Some aa; b' = Some x2; a' = Some x2a;\n        b = Some aaa\\<rbrakk>\n       \\<Longrightarrow> ?Q111 aa x2 x2a aaa x \\<Longrightarrow>\\<^sub>A\n                         \\<exists>\\<^sub>Axa.\n                            P aa x2a * P aaa x2 * \\<Gamma>1 * true *\n                            \\<up> (x = xa \\<and> xa = (aa = aaa))", "apply (rule hn_refineD[OF EQ[unfolded hn_ctxt_def]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa x2 x2a aaa.\n       \\<lbrakk>a = Some aa; b' = Some x2; a' = Some x2a;\n        b = Some aaa\\<rbrakk>\n       \\<Longrightarrow> nofail (RETURN $ ((=) $ aa $ aaa))\n 2. \\<And>aa x2 x2a aaa x.\n       \\<lbrakk>a = Some aa; b' = Some x2; a' = Some x2a;\n        b = Some aaa\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>' aa x2a aaa x2 *\n                         (\\<exists>\\<^sub>Axa.\n                             bool_assn xa x *\n                             \\<up>\n                              (RETURN xa \\<le> RETURN $ ((=) $ aa $ aaa))) *\n                         true \\<Longrightarrow>\\<^sub>A\n                         \\<exists>\\<^sub>Axa.\n                            P aa x2a * P aaa x2 * \\<Gamma>1 * true *\n                            \\<up> (x = xa \\<and> xa = (aa = aaa))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa x2 x2a aaa x.\n       \\<lbrakk>a = Some aa; b' = Some x2; a' = Some x2a;\n        b = Some aaa\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>' aa x2a aaa x2 *\n                         (\\<exists>\\<^sub>Axa.\n                             bool_assn xa x *\n                             \\<up>\n                              (RETURN xa \\<le> RETURN $ ((=) $ aa $ aaa))) *\n                         true \\<Longrightarrow>\\<^sub>A\n                         \\<exists>\\<^sub>Axa.\n                            P aa x2a * P aaa x2 * \\<Gamma>1 * true *\n                            \\<up> (x = xa \\<and> xa = (aa = aaa))", "apply (rule ent_frame_fwd[OF F2[THEN enttD,unfolded hn_ctxt_def]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa x2 x2a aaa x.\n       \\<lbrakk>a = Some aa; b' = Some x2; a' = Some x2a;\n        b = Some aaa\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>' aa x2a aaa x2 *\n                         (\\<exists>\\<^sub>Axa.\n                             bool_assn xa x *\n                             \\<up>\n                              (RETURN xa \\<le> RETURN $ ((=) $ aa $ aaa))) *\n                         true \\<Longrightarrow>\\<^sub>A\n                         \\<Gamma>' (?va119 aa x2 x2a aaa x)\n                          (?va'119 aa x2 x2a aaa x) (?vb119 aa x2 x2a aaa x)\n                          (?vb'119 aa x2 x2a aaa x) *\n                         ?F117 aa x2 x2a aaa x\n 2. \\<And>aa x2 x2a aaa x.\n       \\<lbrakk>a = Some aa; b' = Some x2; a' = Some x2a;\n        b = Some aaa\\<rbrakk>\n       \\<Longrightarrow> P (?va119 aa x2 x2a aaa x)\n                          (?va'119 aa x2 x2a aaa x) *\n                         P (?vb119 aa x2 x2a aaa x)\n                          (?vb'119 aa x2 x2a aaa x) *\n                         \\<Gamma>1 *\n                         true *\n                         ?F117 aa x2 x2a aaa x \\<Longrightarrow>\\<^sub>A\n                         \\<exists>\\<^sub>Axa.\n                            P aa x2a * P aaa x2 * \\<Gamma>1 * true *\n                            \\<up> (x = xa \\<and> xa = (aa = aaa))", "apply (fr_rot 2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa x2 x2a aaa x.\n       \\<lbrakk>a = Some aa; b' = Some x2; a' = Some x2a;\n        b = Some aaa\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>\\<^sub>Axa.\n                             bool_assn xa x *\n                             \\<up>\n                              (RETURN xa \\<le> RETURN $ ((=) $ aa $ aaa))) *\n                         true *\n                         \\<Gamma>' aa x2a aaa x2 \\<Longrightarrow>\\<^sub>A\n                         \\<Gamma>' (?va119 aa x2 x2a aaa x)\n                          (?va'119 aa x2 x2a aaa x) (?vb119 aa x2 x2a aaa x)\n                          (?vb'119 aa x2 x2a aaa x) *\n                         ?F117 aa x2 x2a aaa x\n 2. \\<And>aa x2 x2a aaa x.\n       \\<lbrakk>a = Some aa; b' = Some x2; a' = Some x2a;\n        b = Some aaa\\<rbrakk>\n       \\<Longrightarrow> P (?va119 aa x2 x2a aaa x)\n                          (?va'119 aa x2 x2a aaa x) *\n                         P (?vb119 aa x2 x2a aaa x)\n                          (?vb'119 aa x2 x2a aaa x) *\n                         \\<Gamma>1 *\n                         true *\n                         ?F117 aa x2 x2a aaa x \\<Longrightarrow>\\<^sub>A\n                         \\<exists>\\<^sub>Axa.\n                            P aa x2a * P aaa x2 * \\<Gamma>1 * true *\n                            \\<up> (x = xa \\<and> xa = (aa = aaa))", "apply (fr_rot_rhs 1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa x2 x2a aaa x.\n       \\<lbrakk>a = Some aa; b' = Some x2; a' = Some x2a;\n        b = Some aaa\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>\\<^sub>Axa.\n                             bool_assn xa x *\n                             \\<up>\n                              (RETURN xa \\<le> RETURN $ ((=) $ aa $ aaa))) *\n                         true *\n                         \\<Gamma>' aa x2a aaa x2 \\<Longrightarrow>\\<^sub>A\n                         ?F117 aa x2 x2a aaa x *\n                         \\<Gamma>' (?va119 aa x2 x2a aaa x)\n                          (?va'119 aa x2 x2a aaa x) (?vb119 aa x2 x2a aaa x)\n                          (?vb'119 aa x2 x2a aaa x)\n 2. \\<And>aa x2 x2a aaa x.\n       \\<lbrakk>a = Some aa; b' = Some x2; a' = Some x2a;\n        b = Some aaa\\<rbrakk>\n       \\<Longrightarrow> P (?va119 aa x2 x2a aaa x)\n                          (?va'119 aa x2 x2a aaa x) *\n                         P (?vb119 aa x2 x2a aaa x)\n                          (?vb'119 aa x2 x2a aaa x) *\n                         \\<Gamma>1 *\n                         true *\n                         ?F117 aa x2 x2a aaa x \\<Longrightarrow>\\<^sub>A\n                         \\<exists>\\<^sub>Axa.\n                            P aa x2a * P aaa x2 * \\<Gamma>1 * true *\n                            \\<up> (x = xa \\<and> xa = (aa = aaa))", "apply (rule fr_refl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa x2 x2a aaa x.\n       \\<lbrakk>a = Some aa; b' = Some x2; a' = Some x2a;\n        b = Some aaa\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>\\<^sub>Axa.\n                             bool_assn xa x *\n                             \\<up>\n                              (RETURN xa \\<le> RETURN $ ((=) $ aa $ aaa))) *\n                         true \\<Longrightarrow>\\<^sub>A\n                         ?F117 aa x2 x2a aaa x\n 2. \\<And>aa x2 x2a aaa x.\n       \\<lbrakk>a = Some aa; b' = Some x2; a' = Some x2a;\n        b = Some aaa\\<rbrakk>\n       \\<Longrightarrow> P aa x2a * P aaa x2 * \\<Gamma>1 * true *\n                         ?F117 aa x2 x2a aaa x \\<Longrightarrow>\\<^sub>A\n                         \\<exists>\\<^sub>Axa.\n                            P aa x2a * P aaa x2 * \\<Gamma>1 * true *\n                            \\<up> (x = xa \\<and> xa = (aa = aaa))", "apply (rule ent_refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa x2 x2a aaa x.\n       \\<lbrakk>a = Some aa; b' = Some x2; a' = Some x2a;\n        b = Some aaa\\<rbrakk>\n       \\<Longrightarrow> P aa x2a * P aaa x2 * \\<Gamma>1 * true *\n                         ((\\<exists>\\<^sub>Axa.\n                              bool_assn xa x *\n                              \\<up>\n                               (RETURN xa\n                                \\<le> RETURN $ ((=) $ aa $ aaa))) *\n                          true) \\<Longrightarrow>\\<^sub>A\n                         \\<exists>\\<^sub>Axa.\n                            P aa x2a * P aaa x2 * \\<Gamma>1 * true *\n                            \\<up> (x = xa \\<and> xa = (aa = aaa))", "apply (sep_auto simp: pure_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [pat_rules]: \n  \"(=) $a$None \\<equiv> is_None$a\"\n  \"(=) $None$a \\<equiv> is_None$a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) $ a $ None \\<equiv> is_None $ a) &&&\n    (=) $ None $ a \\<equiv> is_None $ a", "apply (rule eq_reflection, simp split: option.split)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hn_is_None[sepref_fr_rules]: \"hn_refine \n  (hn_ctxt (option_assn P) a a')\n  (return (is_None a'))\n  (hn_ctxt (option_assn P) a a')\n  bool_assn\n  (RETURN$(is_None$a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt (option_assn P) a a') (return (is_None a'))\n     (hn_ctxt (option_assn P) a a') bool_assn (RETURN $ (is_None $ a))", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (RETURN $ (is_None $ a)) \\<Longrightarrow>\n    <hn_ctxt (option_assn P) a\n      a'> return\n           (is_None\n             a') <\\<lambda>r.\n                     hn_ctxt (option_assn P) a a' *\n                     (\\<exists>\\<^sub>Ax.\n                         bool_assn x r *\n                         \\<up>\n                          (RETURN x \\<le> RETURN $ (is_None $ a)))>\\<^sub>t", "apply (sep_auto split: option.split simp: hn_ctxt_def pure_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in -) sepref_the_complete[sepref_fr_rules]:\n  assumes \"x\\<noteq>None\"\n  shows \"hn_refine \n    (hn_ctxt (option_assn R) x xi) \n    (return (the xi)) \n    (hn_invalid (option_assn R) x xi)\n    (R)\n    (RETURN$(the$x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt (option_assn R) x xi) (return (the xi))\n     (hn_invalid (option_assn R) x xi) R (RETURN $ (the $ x))", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> None\n\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt (option_assn R) x xi) (return (the xi))\n     (hn_invalid (option_assn R) x xi) R (RETURN $ (the $ x))", "apply (cases x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> None; x = None\\<rbrakk>\n    \\<Longrightarrow> hn_refine (hn_ctxt (option_assn R) x xi)\n                       (return (the xi)) (hn_invalid (option_assn R) x xi) R\n                       (RETURN $ (the $ x))\n 2. \\<And>a.\n       \\<lbrakk>x \\<noteq> None; x = Some a\\<rbrakk>\n       \\<Longrightarrow> hn_refine (hn_ctxt (option_assn R) x xi)\n                          (return (the xi))\n                          (hn_invalid (option_assn R) x xi) R\n                          (RETURN $ (the $ x))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>x \\<noteq> None; x = Some a\\<rbrakk>\n       \\<Longrightarrow> hn_refine (hn_ctxt (option_assn R) x xi)\n                          (return (the xi))\n                          (hn_invalid (option_assn R) x xi) R\n                          (RETURN $ (the $ x))", "apply (cases xi)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>x \\<noteq> None; x = Some a; xi = None\\<rbrakk>\n       \\<Longrightarrow> hn_refine (hn_ctxt (option_assn R) x xi)\n                          (return (the xi))\n                          (hn_invalid (option_assn R) x xi) R\n                          (RETURN $ (the $ x))\n 2. \\<And>a aa.\n       \\<lbrakk>x \\<noteq> None; x = Some a; xi = Some aa\\<rbrakk>\n       \\<Longrightarrow> hn_refine (hn_ctxt (option_assn R) x xi)\n                          (return (the xi))\n                          (hn_invalid (option_assn R) x xi) R\n                          (RETURN $ (the $ x))", "apply (simp add: hn_ctxt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa.\n       \\<lbrakk>x \\<noteq> None; x = Some a; xi = Some aa\\<rbrakk>\n       \\<Longrightarrow> hn_refine (hn_ctxt (option_assn R) x xi)\n                          (return (the xi))\n                          (hn_invalid (option_assn R) x xi) R\n                          (RETURN $ (the $ x))", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa.\n       \\<lbrakk>x \\<noteq> None; x = Some a; xi = Some aa;\n        nofail (RETURN $ (the $ x))\\<rbrakk>\n       \\<Longrightarrow> <hn_ctxt (option_assn R) x\n                           xi> return\n                                (the xi) <\\<lambda>r.\n       hn_invalid (option_assn R) x xi *\n       (\\<exists>\\<^sub>Axa.\n           R xa r * \\<up> (RETURN xa \\<le> RETURN $ (the $ x)))>\\<^sub>t", "apply (sep_auto simp: hn_ctxt_def invalidate_clone' vassn_tagI invalid_assn_const)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* As the sepref_the_complete rule does not work for us \n  --- the assertion ensuring the side-condition gets decoupled from its variable by a copy-operation ---\n  we use the following rule that only works for the identity relation *)"], ["", "lemma (in -) sepref_the_id:\n  assumes \"CONSTRAINT (IS_PURE IS_ID) R\"\n  shows \"hn_refine \n    (hn_ctxt (option_assn R) x xi) \n    (return (the xi)) \n    (hn_ctxt (option_assn R) x xi)\n    (R)\n    (RETURN$(the$x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt (option_assn R) x xi) (return (the xi))\n     (hn_ctxt (option_assn R) x xi) R (RETURN $ (the $ x))", "using assms"], ["proof (prove)\nusing this:\n  CONSTRAINT (IS_PURE IS_ID) R\n\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt (option_assn R) x xi) (return (the xi))\n     (hn_ctxt (option_assn R) x xi) R (RETURN $ (the $ x))", "apply (clarsimp simp: IS_PURE_def IS_ID_def hn_ctxt_def is_pure_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. R = id_assn \\<Longrightarrow>\n    hn_refine (option_assn id_assn x xi) (return (the xi))\n     (option_assn id_assn x xi) id_assn (RETURN (the x))", "apply (cases x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>R = id_assn; x = None\\<rbrakk>\n    \\<Longrightarrow> hn_refine (option_assn id_assn x xi) (return (the xi))\n                       (option_assn id_assn x xi) id_assn (RETURN (the x))\n 2. \\<And>a.\n       \\<lbrakk>R = id_assn; x = Some a\\<rbrakk>\n       \\<Longrightarrow> hn_refine (option_assn id_assn x xi)\n                          (return (the xi)) (option_assn id_assn x xi)\n                          id_assn (RETURN (the x))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>R = id_assn; x = None\\<rbrakk>\n    \\<Longrightarrow> hn_refine (\\<up> (xi = None)) (return (the xi))\n                       (\\<up> (xi = None)) id_assn (RETURN (the None))\n 2. \\<And>a.\n       \\<lbrakk>R = id_assn; x = Some a\\<rbrakk>\n       \\<Longrightarrow> hn_refine (option_assn id_assn x xi)\n                          (return (the xi)) (option_assn id_assn x xi)\n                          id_assn (RETURN (the x))", "apply (cases xi)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>R = id_assn; x = None; xi = None\\<rbrakk>\n    \\<Longrightarrow> hn_refine (\\<up> (xi = None)) (return (the xi))\n                       (\\<up> (xi = None)) id_assn (RETURN (the None))\n 2. \\<And>a.\n       \\<lbrakk>R = id_assn; x = None; xi = Some a\\<rbrakk>\n       \\<Longrightarrow> hn_refine (\\<up> (xi = None)) (return (the xi))\n                          (\\<up> (xi = None)) id_assn (RETURN (the None))\n 3. \\<And>a.\n       \\<lbrakk>R = id_assn; x = Some a\\<rbrakk>\n       \\<Longrightarrow> hn_refine (option_assn id_assn x xi)\n                          (return (the xi)) (option_assn id_assn x xi)\n                          id_assn (RETURN (the x))", "apply (simp add: hn_ctxt_def invalid_assn_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>R = id_assn; x = None; xi = None\\<rbrakk>\n    \\<Longrightarrow> hn_refine emp (return (the None)) emp id_assn\n                       (RETURN (the None))\n 2. \\<And>a.\n       \\<lbrakk>R = id_assn; x = None; xi = Some a\\<rbrakk>\n       \\<Longrightarrow> hn_refine (\\<up> (xi = None)) (return (the xi))\n                          (\\<up> (xi = None)) id_assn (RETURN (the None))\n 3. \\<And>a.\n       \\<lbrakk>R = id_assn; x = Some a\\<rbrakk>\n       \\<Longrightarrow> hn_refine (option_assn id_assn x xi)\n                          (return (the xi)) (option_assn id_assn x xi)\n                          id_assn (RETURN (the x))", "apply rule"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>R = id_assn; x = None; xi = None;\n     nofail (RETURN (the None))\\<rbrakk>\n    \\<Longrightarrow> <emp> return\n                             (the None) <\\<lambda>r.\n      emp *\n      (\\<exists>\\<^sub>Ax.\n          id_assn x r * \\<up> (RETURN x \\<le> RETURN (the None)))>\\<^sub>t\n 2. \\<And>a.\n       \\<lbrakk>R = id_assn; x = None; xi = Some a\\<rbrakk>\n       \\<Longrightarrow> hn_refine (\\<up> (xi = None)) (return (the xi))\n                          (\\<up> (xi = None)) id_assn (RETURN (the None))\n 3. \\<And>a.\n       \\<lbrakk>R = id_assn; x = Some a\\<rbrakk>\n       \\<Longrightarrow> hn_refine (option_assn id_assn x xi)\n                          (return (the xi)) (option_assn id_assn x xi)\n                          id_assn (RETURN (the x))", "apply (sep_auto simp: pure_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>R = id_assn; x = None; xi = Some a\\<rbrakk>\n       \\<Longrightarrow> hn_refine (\\<up> (xi = None)) (return (the xi))\n                          (\\<up> (xi = None)) id_assn (RETURN (the None))\n 2. \\<And>a.\n       \\<lbrakk>R = id_assn; x = Some a\\<rbrakk>\n       \\<Longrightarrow> hn_refine (option_assn id_assn x xi)\n                          (return (the xi)) (option_assn id_assn x xi)\n                          id_assn (RETURN (the x))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>R = id_assn; x = None; xi = Some a;\n        nofail (RETURN (the None))\\<rbrakk>\n       \\<Longrightarrow> <\\<up>\n                           (xi =\n                            None)> return\n                                    (the\nxi) <\\<lambda>r.\n        \\<up> (xi = None) *\n        (\\<exists>\\<^sub>Ax.\n            id_assn x r * \\<up> (RETURN x \\<le> RETURN (the None)))>\\<^sub>t\n 2. \\<And>a.\n       \\<lbrakk>R = id_assn; x = Some a\\<rbrakk>\n       \\<Longrightarrow> hn_refine (option_assn id_assn x xi)\n                          (return (the xi)) (option_assn id_assn x xi)\n                          id_assn (RETURN (the x))", "apply (sep_auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>R = id_assn; x = Some a\\<rbrakk>\n       \\<Longrightarrow> hn_refine (option_assn id_assn x xi)\n                          (return (the xi)) (option_assn id_assn x xi)\n                          id_assn (RETURN (the x))", "apply (simp add: option_assn_pure_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>R = id_assn; x = Some a\\<rbrakk>\n       \\<Longrightarrow> hn_refine (id_assn (Some a) xi) (return (the xi))\n                          (id_assn (Some a) xi) id_assn (RETURN a)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>R = id_assn; x = Some a; nofail (RETURN a)\\<rbrakk>\n       \\<Longrightarrow> <id_assn (Some a)\n                           xi> return\n                                (the xi) <\\<lambda>r.\n       id_assn (Some a) xi *\n       (\\<exists>\\<^sub>Ax.\n           id_assn x r * \\<up> (RETURN x \\<le> RETURN a))>\\<^sub>t", "apply (sep_auto simp: pure_def invalid_assn_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \"Lists\""], ["", "fun list_assn :: \"('a \\<Rightarrow> 'c \\<Rightarrow> assn) \\<Rightarrow> 'a list \\<Rightarrow> 'c list \\<Rightarrow> assn\" where\n  \"list_assn P [] [] = emp\"\n| \"list_assn P (a#as) (c#cs) = P a c * list_assn P as cs\"\n| \"list_assn _ _ _ = false\""], ["", "lemma list_assn_aux_simps[simp]:\n  \"list_assn P [] l' = (\\<up>(l'=[]))\"\n  \"list_assn P l [] = (\\<up>(l=[]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_assn P [] l' = \\<up> (l' = []) &&&\n    list_assn P l [] = \\<up> (l = [])", "unfolding hn_ctxt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_assn P [] l' = \\<up> (l' = []) &&&\n    list_assn P l [] = \\<up> (l = [])", "apply (cases l')"], ["proof (prove)\ngoal (3 subgoals):\n 1. l' = [] \\<Longrightarrow> list_assn P [] l' = \\<up> (l' = [])\n 2. \\<And>a list.\n       l' = a # list \\<Longrightarrow> list_assn P [] l' = \\<up> (l' = [])\n 3. list_assn P l [] = \\<up> (l = [])", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a list.\n       l' = a # list \\<Longrightarrow> list_assn P [] l' = \\<up> (l' = [])\n 2. list_assn P l [] = \\<up> (l = [])", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_assn P l [] = \\<up> (l = [])", "apply (cases l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. l = [] \\<Longrightarrow> list_assn P l [] = \\<up> (l = [])\n 2. \\<And>a list.\n       l = a # list \\<Longrightarrow> list_assn P l [] = \\<up> (l = [])", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       l = a # list \\<Longrightarrow> list_assn P l [] = \\<up> (l = [])", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma list_assn_aux_append[simp]:\n  \"length l1=length l1' \\<Longrightarrow> \n    list_assn P (l1@l2) (l1'@l2') \n    = list_assn P l1 l1' * list_assn P l2 l2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length l1 = length l1' \\<Longrightarrow>\n    list_assn P (l1 @ l2) (l1' @ l2') =\n    list_assn P l1 l1' * list_assn P l2 l2'", "apply (induct rule: list_induct2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. list_assn P ([] @ l2) ([] @ l2') =\n    list_assn P [] [] * list_assn P l2 l2'\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        list_assn P (xs @ l2) (ys @ l2') =\n        list_assn P xs ys * list_assn P l2 l2'\\<rbrakk>\n       \\<Longrightarrow> list_assn P ((x # xs) @ l2) ((y # ys) @ l2') =\n                         list_assn P (x # xs) (y # ys) * list_assn P l2 l2'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        list_assn P (xs @ l2) (ys @ l2') =\n        list_assn P xs ys * list_assn P l2 l2'\\<rbrakk>\n       \\<Longrightarrow> list_assn P ((x # xs) @ l2) ((y # ys) @ l2') =\n                         list_assn P (x # xs) (y # ys) * list_assn P l2 l2'", "apply (simp add: star_assoc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma list_assn_aux_ineq_len: \"length l \\<noteq> length li \\<Longrightarrow> list_assn A l li = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length l \\<noteq> length li \\<Longrightarrow> list_assn A l li = false", "proof (induction l arbitrary: li)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>li.\n       length [] \\<noteq> length li \\<Longrightarrow>\n       list_assn A [] li = false\n 2. \\<And>a l li.\n       \\<lbrakk>\\<And>li.\n                   length l \\<noteq> length li \\<Longrightarrow>\n                   list_assn A l li = false;\n        length (a # l) \\<noteq> length li\\<rbrakk>\n       \\<Longrightarrow> list_assn A (a # l) li = false", "case (Cons x l li)"], ["proof (state)\nthis:\n  length l \\<noteq> length ?li \\<Longrightarrow> list_assn A l ?li = false\n  length (x # l) \\<noteq> length li\n\ngoal (2 subgoals):\n 1. \\<And>li.\n       length [] \\<noteq> length li \\<Longrightarrow>\n       list_assn A [] li = false\n 2. \\<And>a l li.\n       \\<lbrakk>\\<And>li.\n                   length l \\<noteq> length li \\<Longrightarrow>\n                   list_assn A l li = false;\n        length (a # l) \\<noteq> length li\\<rbrakk>\n       \\<Longrightarrow> list_assn A (a # l) li = false", "thus ?case"], ["proof (prove)\nusing this:\n  length l \\<noteq> length ?li \\<Longrightarrow> list_assn A l ?li = false\n  length (x # l) \\<noteq> length li\n\ngoal (1 subgoal):\n 1. list_assn A (x # l) li = false", "by (cases li; auto)"], ["proof (state)\nthis:\n  list_assn A (x # l) li = false\n\ngoal (1 subgoal):\n 1. \\<And>li.\n       length [] \\<noteq> length li \\<Longrightarrow>\n       list_assn A [] li = false", "qed simp"], ["", "lemma list_assn_aux_append2[simp]:\n  assumes \"length l2=length l2'\"  \n  shows \"list_assn P (l1@l2) (l1'@l2') \n    = list_assn P l1 l1' * list_assn P l2 l2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_assn P (l1 @ l2) (l1' @ l2') =\n    list_assn P l1 l1' * list_assn P l2 l2'", "apply (cases \"length l1 = length l1'\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. length l1 = length l1' \\<Longrightarrow>\n    list_assn P (l1 @ l2) (l1' @ l2') =\n    list_assn P l1 l1' * list_assn P l2 l2'\n 2. length l1 \\<noteq> length l1' \\<Longrightarrow>\n    list_assn P (l1 @ l2) (l1' @ l2') =\n    list_assn P l1 l1' * list_assn P l2 l2'", "apply (erule list_assn_aux_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length l1 \\<noteq> length l1' \\<Longrightarrow>\n    list_assn P (l1 @ l2) (l1' @ l2') =\n    list_assn P l1 l1' * list_assn P l2 l2'", "apply (simp add: list_assn_aux_ineq_len assms)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma list_assn_pure_conv[constraint_simps]: \"list_assn (pure R) = pure (\\<langle>R\\<rangle>list_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_assn (pure R) = pure (\\<langle>R\\<rangle>list_rel)", "proof (intro ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       list_assn (pure R) x xa = pure (\\<langle>R\\<rangle>list_rel) x xa", "fix l li"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       list_assn (pure R) x xa = pure (\\<langle>R\\<rangle>list_rel) x xa", "show \"list_assn (pure R) l li = pure (\\<langle>R\\<rangle>list_rel) l li\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_assn (pure R) l li = pure (\\<langle>R\\<rangle>list_rel) l li", "apply (induction \"pure R\" l li rule: list_assn.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. list_assn (pure R) [] [] = pure (\\<langle>R\\<rangle>list_rel) [] []\n 2. \\<And>a as c cs.\n       list_assn (pure R) as cs =\n       pure (\\<langle>R\\<rangle>list_rel) as cs \\<Longrightarrow>\n       list_assn (pure R) (a # as) (c # cs) =\n       pure (\\<langle>R\\<rangle>list_rel) (a # as) (c # cs)\n 3. \\<And>v va.\n       list_assn (pure R) (v # va) [] =\n       pure (\\<langle>R\\<rangle>list_rel) (v # va) []\n 4. \\<And>v va.\n       list_assn (pure R) [] (v # va) =\n       pure (\\<langle>R\\<rangle>list_rel) [] (v # va)", "by (auto simp: pure_def)"], ["proof (state)\nthis:\n  list_assn (pure R) l li = pure (\\<langle>R\\<rangle>list_rel) l li\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas [sepref_import_rewrite, sepref_frame_normrel_eqs, fcomp_norm_unfold] = list_assn_pure_conv[symmetric]"], ["", "lemma list_assn_simps[simp]:\n  \"hn_ctxt (list_assn P) [] l' = (\\<up>(l'=[]))\"\n  \"hn_ctxt (list_assn P) l [] = (\\<up>(l=[]))\"\n  \"hn_ctxt (list_assn P) [] [] = emp\"\n  \"hn_ctxt (list_assn P) (a#as) (c#cs) = hn_ctxt P a c * hn_ctxt (list_assn P) as cs\"\n  \"hn_ctxt (list_assn P) (a#as) [] = false\"\n  \"hn_ctxt (list_assn P) [] (c#cs) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hn_ctxt (list_assn P) [] l' = \\<up> (l' = []) &&&\n     hn_ctxt (list_assn P) l [] = \\<up> (l = []) &&&\n     hn_ctxt (list_assn P) [] [] = emp) &&&\n    hn_ctxt (list_assn P) (a # as) (c # cs) =\n    hn_ctxt P a c * hn_ctxt (list_assn P) as cs &&&\n    hn_ctxt (list_assn P) (a # as) [] = false &&&\n    hn_ctxt (list_assn P) [] (c # cs) = false", "unfolding hn_ctxt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_assn P [] l' = \\<up> (l' = []) &&&\n     list_assn P l [] = \\<up> (l = []) &&& list_assn P [] [] = emp) &&&\n    list_assn P (a # as) (c # cs) = P a c * list_assn P as cs &&&\n    list_assn P (a # as) [] = false &&& list_assn P [] (c # cs) = false", "apply (cases l')"], ["proof (prove)\ngoal (7 subgoals):\n 1. l' = [] \\<Longrightarrow> list_assn P [] l' = \\<up> (l' = [])\n 2. \\<And>a list.\n       l' = a # list \\<Longrightarrow> list_assn P [] l' = \\<up> (l' = [])\n 3. list_assn P l [] = \\<up> (l = [])\n 4. list_assn P [] [] = emp\n 5. list_assn P (a # as) (c # cs) = P a c * list_assn P as cs\n 6. list_assn P (a # as) [] = false\n 7. list_assn P [] (c # cs) = false", "apply simp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a list.\n       l' = a # list \\<Longrightarrow> list_assn P [] l' = \\<up> (l' = [])\n 2. list_assn P l [] = \\<up> (l = [])\n 3. list_assn P [] [] = emp\n 4. list_assn P (a # as) (c # cs) = P a c * list_assn P as cs\n 5. list_assn P (a # as) [] = false\n 6. list_assn P [] (c # cs) = false", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. list_assn P l [] = \\<up> (l = [])\n 2. list_assn P [] [] = emp\n 3. list_assn P (a # as) (c # cs) = P a c * list_assn P as cs\n 4. list_assn P (a # as) [] = false\n 5. list_assn P [] (c # cs) = false", "apply (cases l)"], ["proof (prove)\ngoal (6 subgoals):\n 1. l = [] \\<Longrightarrow> list_assn P l [] = \\<up> (l = [])\n 2. \\<And>a list.\n       l = a # list \\<Longrightarrow> list_assn P l [] = \\<up> (l = [])\n 3. list_assn P [] [] = emp\n 4. list_assn P (a # as) (c # cs) = P a c * list_assn P as cs\n 5. list_assn P (a # as) [] = false\n 6. list_assn P [] (c # cs) = false", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a list.\n       l = a # list \\<Longrightarrow> list_assn P l [] = \\<up> (l = [])\n 2. list_assn P [] [] = emp\n 3. list_assn P (a # as) (c # cs) = P a c * list_assn P as cs\n 4. list_assn P (a # as) [] = false\n 5. list_assn P [] (c # cs) = false", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. list_assn P [] [] = emp\n 2. list_assn P (a # as) (c # cs) = P a c * list_assn P as cs\n 3. list_assn P (a # as) [] = false\n 4. list_assn P [] (c # cs) = false", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma list_assn_precise[constraint_rules]: \"precise P \\<Longrightarrow> precise (list_assn P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. precise P \\<Longrightarrow> precise (list_assn P)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a' h p F F'.\n       \\<lbrakk>precise P;\n        h \\<Turnstile>\n        list_assn P a p * F \\<and>\\<^sub>A list_assn P a' p * F'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "fix l1 l2 l h F1 F2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a' h p F F'.\n       \\<lbrakk>precise P;\n        h \\<Turnstile>\n        list_assn P a p * F \\<and>\\<^sub>A list_assn P a' p * F'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "assume P: \"precise P\""], ["proof (state)\nthis:\n  precise P\n\ngoal (1 subgoal):\n 1. \\<And>a a' h p F F'.\n       \\<lbrakk>precise P;\n        h \\<Turnstile>\n        list_assn P a p * F \\<and>\\<^sub>A list_assn P a' p * F'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "assume \"h\\<Turnstile>list_assn P l1 l * F1 \\<and>\\<^sub>A list_assn P l2 l * F2\""], ["proof (state)\nthis:\n  h \\<Turnstile> list_assn P l1 l * F1 \\<and>\\<^sub>A list_assn P l2 l * F2\n\ngoal (1 subgoal):\n 1. \\<And>a a' h p F F'.\n       \\<lbrakk>precise P;\n        h \\<Turnstile>\n        list_assn P a p * F \\<and>\\<^sub>A list_assn P a' p * F'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "thus \"l1=l2\""], ["proof (prove)\nusing this:\n  h \\<Turnstile> list_assn P l1 l * F1 \\<and>\\<^sub>A list_assn P l2 l * F2\n\ngoal (1 subgoal):\n 1. l1 = l2", "proof (induct l arbitrary: l1 l2 F1 F2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l1 l2 F1 F2.\n       h \\<Turnstile>\n       list_assn P l1 [] * F1 \\<and>\\<^sub>A\n       list_assn P l2 [] * F2 \\<Longrightarrow>\n       l1 = l2\n 2. \\<And>a l l1 l2 F1 F2.\n       \\<lbrakk>\\<And>l1 l2 F1 F2.\n                   h \\<Turnstile>\n                   list_assn P l1 l * F1 \\<and>\\<^sub>A\n                   list_assn P l2 l * F2 \\<Longrightarrow>\n                   l1 = l2;\n        h \\<Turnstile>\n        list_assn P l1 (a # l) * F1 \\<and>\\<^sub>A\n        list_assn P l2 (a # l) * F2\\<rbrakk>\n       \\<Longrightarrow> l1 = l2", "case Nil"], ["proof (state)\nthis:\n  h \\<Turnstile>\n  list_assn P l1 [] * F1 \\<and>\\<^sub>A list_assn P l2 [] * F2\n\ngoal (2 subgoals):\n 1. \\<And>l1 l2 F1 F2.\n       h \\<Turnstile>\n       list_assn P l1 [] * F1 \\<and>\\<^sub>A\n       list_assn P l2 [] * F2 \\<Longrightarrow>\n       l1 = l2\n 2. \\<And>a l l1 l2 F1 F2.\n       \\<lbrakk>\\<And>l1 l2 F1 F2.\n                   h \\<Turnstile>\n                   list_assn P l1 l * F1 \\<and>\\<^sub>A\n                   list_assn P l2 l * F2 \\<Longrightarrow>\n                   l1 = l2;\n        h \\<Turnstile>\n        list_assn P l1 (a # l) * F1 \\<and>\\<^sub>A\n        list_assn P l2 (a # l) * F2\\<rbrakk>\n       \\<Longrightarrow> l1 = l2", "thus ?case"], ["proof (prove)\nusing this:\n  h \\<Turnstile>\n  list_assn P l1 [] * F1 \\<and>\\<^sub>A list_assn P l2 [] * F2\n\ngoal (1 subgoal):\n 1. l1 = l2", "by simp"], ["proof (state)\nthis:\n  l1 = l2\n\ngoal (1 subgoal):\n 1. \\<And>a l l1 l2 F1 F2.\n       \\<lbrakk>\\<And>l1 l2 F1 F2.\n                   h \\<Turnstile>\n                   list_assn P l1 l * F1 \\<and>\\<^sub>A\n                   list_assn P l2 l * F2 \\<Longrightarrow>\n                   l1 = l2;\n        h \\<Turnstile>\n        list_assn P l1 (a # l) * F1 \\<and>\\<^sub>A\n        list_assn P l2 (a # l) * F2\\<rbrakk>\n       \\<Longrightarrow> l1 = l2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l l1 l2 F1 F2.\n       \\<lbrakk>\\<And>l1 l2 F1 F2.\n                   h \\<Turnstile>\n                   list_assn P l1 l * F1 \\<and>\\<^sub>A\n                   list_assn P l2 l * F2 \\<Longrightarrow>\n                   l1 = l2;\n        h \\<Turnstile>\n        list_assn P l1 (a # l) * F1 \\<and>\\<^sub>A\n        list_assn P l2 (a # l) * F2\\<rbrakk>\n       \\<Longrightarrow> l1 = l2", "case (Cons a ls)"], ["proof (state)\nthis:\n  h \\<Turnstile>\n  list_assn P ?l1.0 ls * ?F1.0 \\<and>\\<^sub>A\n  list_assn P ?l2.0 ls * ?F2.0 \\<Longrightarrow>\n  ?l1.0 = ?l2.0\n  h \\<Turnstile>\n  list_assn P l1 (a # ls) * F1 \\<and>\\<^sub>A list_assn P l2 (a # ls) * F2\n\ngoal (1 subgoal):\n 1. \\<And>a l l1 l2 F1 F2.\n       \\<lbrakk>\\<And>l1 l2 F1 F2.\n                   h \\<Turnstile>\n                   list_assn P l1 l * F1 \\<and>\\<^sub>A\n                   list_assn P l2 l * F2 \\<Longrightarrow>\n                   l1 = l2;\n        h \\<Turnstile>\n        list_assn P l1 (a # l) * F1 \\<and>\\<^sub>A\n        list_assn P l2 (a # l) * F2\\<rbrakk>\n       \\<Longrightarrow> l1 = l2", "from Cons"], ["proof (chain)\npicking this:\n  h \\<Turnstile>\n  list_assn P ?l1.0 ls * ?F1.0 \\<and>\\<^sub>A\n  list_assn P ?l2.0 ls * ?F2.0 \\<Longrightarrow>\n  ?l1.0 = ?l2.0\n  h \\<Turnstile>\n  list_assn P l1 (a # ls) * F1 \\<and>\\<^sub>A list_assn P l2 (a # ls) * F2", "obtain a1 ls1 where [simp]: \"l1=a1#ls1\""], ["proof (prove)\nusing this:\n  h \\<Turnstile>\n  list_assn P ?l1.0 ls * ?F1.0 \\<and>\\<^sub>A\n  list_assn P ?l2.0 ls * ?F2.0 \\<Longrightarrow>\n  ?l1.0 = ?l2.0\n  h \\<Turnstile>\n  list_assn P l1 (a # ls) * F1 \\<and>\\<^sub>A list_assn P l2 (a # ls) * F2\n\ngoal (1 subgoal):\n 1. (\\<And>a1 ls1. l1 = a1 # ls1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases l1, simp)"], ["proof (state)\nthis:\n  l1 = a1 # ls1\n\ngoal (1 subgoal):\n 1. \\<And>a l l1 l2 F1 F2.\n       \\<lbrakk>\\<And>l1 l2 F1 F2.\n                   h \\<Turnstile>\n                   list_assn P l1 l * F1 \\<and>\\<^sub>A\n                   list_assn P l2 l * F2 \\<Longrightarrow>\n                   l1 = l2;\n        h \\<Turnstile>\n        list_assn P l1 (a # l) * F1 \\<and>\\<^sub>A\n        list_assn P l2 (a # l) * F2\\<rbrakk>\n       \\<Longrightarrow> l1 = l2", "from Cons"], ["proof (chain)\npicking this:\n  h \\<Turnstile>\n  list_assn P ?l1.0 ls * ?F1.0 \\<and>\\<^sub>A\n  list_assn P ?l2.0 ls * ?F2.0 \\<Longrightarrow>\n  ?l1.0 = ?l2.0\n  h \\<Turnstile>\n  list_assn P l1 (a # ls) * F1 \\<and>\\<^sub>A list_assn P l2 (a # ls) * F2", "obtain a2 ls2 where [simp]: \"l2=a2#ls2\""], ["proof (prove)\nusing this:\n  h \\<Turnstile>\n  list_assn P ?l1.0 ls * ?F1.0 \\<and>\\<^sub>A\n  list_assn P ?l2.0 ls * ?F2.0 \\<Longrightarrow>\n  ?l1.0 = ?l2.0\n  h \\<Turnstile>\n  list_assn P l1 (a # ls) * F1 \\<and>\\<^sub>A list_assn P l2 (a # ls) * F2\n\ngoal (1 subgoal):\n 1. (\\<And>a2 ls2. l2 = a2 # ls2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases l2, simp)"], ["proof (state)\nthis:\n  l2 = a2 # ls2\n\ngoal (1 subgoal):\n 1. \\<And>a l l1 l2 F1 F2.\n       \\<lbrakk>\\<And>l1 l2 F1 F2.\n                   h \\<Turnstile>\n                   list_assn P l1 l * F1 \\<and>\\<^sub>A\n                   list_assn P l2 l * F2 \\<Longrightarrow>\n                   l1 = l2;\n        h \\<Turnstile>\n        list_assn P l1 (a # l) * F1 \\<and>\\<^sub>A\n        list_assn P l2 (a # l) * F2\\<rbrakk>\n       \\<Longrightarrow> l1 = l2", "from Cons.prems"], ["proof (chain)\npicking this:\n  h \\<Turnstile>\n  list_assn P l1 (a # ls) * F1 \\<and>\\<^sub>A list_assn P l2 (a # ls) * F2", "have M:\n      \"h \\<Turnstile> P a1 a * list_assn P ls1 ls * F1 \n        \\<and>\\<^sub>A P a2 a * list_assn P ls2 ls * F2\""], ["proof (prove)\nusing this:\n  h \\<Turnstile>\n  list_assn P l1 (a # ls) * F1 \\<and>\\<^sub>A list_assn P l2 (a # ls) * F2\n\ngoal (1 subgoal):\n 1. h \\<Turnstile>\n    P a1 a * list_assn P ls1 ls * F1 \\<and>\\<^sub>A\n    P a2 a * list_assn P ls2 ls * F2", "by simp"], ["proof (state)\nthis:\n  h \\<Turnstile>\n  P a1 a * list_assn P ls1 ls * F1 \\<and>\\<^sub>A\n  P a2 a * list_assn P ls2 ls * F2\n\ngoal (1 subgoal):\n 1. \\<And>a l l1 l2 F1 F2.\n       \\<lbrakk>\\<And>l1 l2 F1 F2.\n                   h \\<Turnstile>\n                   list_assn P l1 l * F1 \\<and>\\<^sub>A\n                   list_assn P l2 l * F2 \\<Longrightarrow>\n                   l1 = l2;\n        h \\<Turnstile>\n        list_assn P l1 (a # l) * F1 \\<and>\\<^sub>A\n        list_assn P l2 (a # l) * F2\\<rbrakk>\n       \\<Longrightarrow> l1 = l2", "have \"a1=a2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a1 = a2", "apply (rule preciseD[OF P, where a=a1 and a'=a2 and p=a\n        and F= \"list_assn P ls1 ls * F1\" \n        and F'=\"list_assn P ls2 ls * F2\"\n        ])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ?h \\<Turnstile>\n    P a1 a * (list_assn P ls1 ls * F1) \\<and>\\<^sub>A\n    P a2 a * (list_assn P ls2 ls * F2)", "using M"], ["proof (prove)\nusing this:\n  h \\<Turnstile>\n  P a1 a * list_assn P ls1 ls * F1 \\<and>\\<^sub>A\n  P a2 a * list_assn P ls2 ls * F2\n\ngoal (1 subgoal):\n 1. ?h \\<Turnstile>\n    P a1 a * (list_assn P ls1 ls * F1) \\<and>\\<^sub>A\n    P a2 a * (list_assn P ls2 ls * F2)", "by (simp add: star_assoc)"], ["proof (state)\nthis:\n  a1 = a2\n\ngoal (1 subgoal):\n 1. \\<And>a l l1 l2 F1 F2.\n       \\<lbrakk>\\<And>l1 l2 F1 F2.\n                   h \\<Turnstile>\n                   list_assn P l1 l * F1 \\<and>\\<^sub>A\n                   list_assn P l2 l * F2 \\<Longrightarrow>\n                   l1 = l2;\n        h \\<Turnstile>\n        list_assn P l1 (a # l) * F1 \\<and>\\<^sub>A\n        list_assn P l2 (a # l) * F2\\<rbrakk>\n       \\<Longrightarrow> l1 = l2", "moreover"], ["proof (state)\nthis:\n  a1 = a2\n\ngoal (1 subgoal):\n 1. \\<And>a l l1 l2 F1 F2.\n       \\<lbrakk>\\<And>l1 l2 F1 F2.\n                   h \\<Turnstile>\n                   list_assn P l1 l * F1 \\<and>\\<^sub>A\n                   list_assn P l2 l * F2 \\<Longrightarrow>\n                   l1 = l2;\n        h \\<Turnstile>\n        list_assn P l1 (a # l) * F1 \\<and>\\<^sub>A\n        list_assn P l2 (a # l) * F2\\<rbrakk>\n       \\<Longrightarrow> l1 = l2", "have \"ls1=ls2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ls1 = ls2", "apply (rule Cons.hyps[where ?F1.0=\"P a1 a * F1\" and ?F2.0=\"P a2 a * F2\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<Turnstile>\n    list_assn P ls1 ls * (P a1 a * F1) \\<and>\\<^sub>A\n    list_assn P ls2 ls * (P a2 a * F2)", "using M"], ["proof (prove)\nusing this:\n  h \\<Turnstile>\n  P a1 a * list_assn P ls1 ls * F1 \\<and>\\<^sub>A\n  P a2 a * list_assn P ls2 ls * F2\n\ngoal (1 subgoal):\n 1. h \\<Turnstile>\n    list_assn P ls1 ls * (P a1 a * F1) \\<and>\\<^sub>A\n    list_assn P ls2 ls * (P a2 a * F2)", "by (simp only: star_aci)"], ["proof (state)\nthis:\n  ls1 = ls2\n\ngoal (1 subgoal):\n 1. \\<And>a l l1 l2 F1 F2.\n       \\<lbrakk>\\<And>l1 l2 F1 F2.\n                   h \\<Turnstile>\n                   list_assn P l1 l * F1 \\<and>\\<^sub>A\n                   list_assn P l2 l * F2 \\<Longrightarrow>\n                   l1 = l2;\n        h \\<Turnstile>\n        list_assn P l1 (a # l) * F1 \\<and>\\<^sub>A\n        list_assn P l2 (a # l) * F2\\<rbrakk>\n       \\<Longrightarrow> l1 = l2", "ultimately"], ["proof (chain)\npicking this:\n  a1 = a2\n  ls1 = ls2", "show ?case"], ["proof (prove)\nusing this:\n  a1 = a2\n  ls1 = ls2\n\ngoal (1 subgoal):\n 1. l1 = l2", "by simp"], ["proof (state)\nthis:\n  l1 = l2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  l1 = l2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_assn_pure[constraint_rules]: \n  assumes P: \"is_pure P\" \n  shows \"is_pure (list_assn P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pure (list_assn P)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_pure (list_assn P)", "from P"], ["proof (chain)\npicking this:\n  is_pure P", "obtain P' where P_eq: \"\\<And>x x'. P x x' = \\<up>(P' x x')\""], ["proof (prove)\nusing this:\n  is_pure P\n\ngoal (1 subgoal):\n 1. (\\<And>P'.\n        (\\<And>x x'. P x x' = \\<up> (P' x x')) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule is_pureE) blast"], ["proof (state)\nthis:\n  P ?x ?x' = \\<up> (P' ?x ?x')\n\ngoal (1 subgoal):\n 1. is_pure (list_assn P)", "{"], ["proof (state)\nthis:\n  P ?x ?x' = \\<up> (P' ?x ?x')\n\ngoal (1 subgoal):\n 1. is_pure (list_assn P)", "fix l l'"], ["proof (state)\ngoal (1 subgoal):\n 1. is_pure (list_assn P)", "have \"list_assn P l l' = \\<up>(list_all2 P' l l')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_assn P l l' = \\<up> (list_all2 P' l l')", "by (induct P\\<equiv>P l l' rule: list_assn.induct)\n         (simp_all add: P_eq)"], ["proof (state)\nthis:\n  list_assn P l l' = \\<up> (list_all2 P' l l')\n\ngoal (1 subgoal):\n 1. is_pure (list_assn P)", "}"], ["proof (state)\nthis:\n  list_assn P ?l2 ?l'2 = \\<up> (list_all2 P' ?l2 ?l'2)\n\ngoal (1 subgoal):\n 1. is_pure (list_assn P)", "thus ?thesis"], ["proof (prove)\nusing this:\n  list_assn P ?l2 ?l'2 = \\<up> (list_all2 P' ?l2 ?l'2)\n\ngoal (1 subgoal):\n 1. is_pure (list_assn P)", "by rule"], ["proof (state)\nthis:\n  is_pure (list_assn P)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_assn_mono: \n  \"\\<lbrakk>\\<And>x x'. P x x'\\<Longrightarrow>\\<^sub>AP' x x'\\<rbrakk> \\<Longrightarrow> list_assn P l l' \\<Longrightarrow>\\<^sub>A list_assn P' l l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x x'. P x x' \\<Longrightarrow>\\<^sub>A P' x x') \\<Longrightarrow>\n    list_assn P l l' \\<Longrightarrow>\\<^sub>A list_assn P' l l'", "unfolding hn_ctxt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x x'. P x x' \\<Longrightarrow>\\<^sub>A P' x x') \\<Longrightarrow>\n    list_assn P l l' \\<Longrightarrow>\\<^sub>A list_assn P' l l'", "apply (induct P l l' rule: list_assn.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P.\n       (\\<And>x x'.\n           P x x' \\<Longrightarrow>\\<^sub>A P' x x') \\<Longrightarrow>\n       list_assn P [] [] \\<Longrightarrow>\\<^sub>A list_assn P' [] []\n 2. \\<And>P a as c cs.\n       \\<lbrakk>(\\<And>x x'.\n                    P x x' \\<Longrightarrow>\\<^sub>A\n                    P' x x') \\<Longrightarrow>\n                list_assn P as cs \\<Longrightarrow>\\<^sub>A\n                list_assn P' as cs;\n        \\<And>x x'. P x x' \\<Longrightarrow>\\<^sub>A P' x x'\\<rbrakk>\n       \\<Longrightarrow> list_assn P (a # as)\n                          (c # cs) \\<Longrightarrow>\\<^sub>A\n                         list_assn P' (a # as) (c # cs)\n 3. \\<And>uu_ v va.\n       (\\<And>x x'.\n           uu_ x x' \\<Longrightarrow>\\<^sub>A P' x x') \\<Longrightarrow>\n       list_assn uu_ (v # va) [] \\<Longrightarrow>\\<^sub>A\n       list_assn P' (v # va) []\n 4. \\<And>uu_ v va.\n       (\\<And>x x'.\n           uu_ x x' \\<Longrightarrow>\\<^sub>A P' x x') \\<Longrightarrow>\n       list_assn uu_ [] (v # va) \\<Longrightarrow>\\<^sub>A\n       list_assn P' [] (v # va)", "by (auto intro: ent_star_mono)"], ["", "lemma list_assn_monot: \n  \"\\<lbrakk>\\<And>x x'. P x x'\\<Longrightarrow>\\<^sub>tP' x x'\\<rbrakk> \\<Longrightarrow> list_assn P l l' \\<Longrightarrow>\\<^sub>t list_assn P' l l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x x'. P x x' \\<Longrightarrow>\\<^sub>t P' x x') \\<Longrightarrow>\n    list_assn P l l' \\<Longrightarrow>\\<^sub>t list_assn P' l l'", "unfolding hn_ctxt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x x'. P x x' \\<Longrightarrow>\\<^sub>t P' x x') \\<Longrightarrow>\n    list_assn P l l' \\<Longrightarrow>\\<^sub>t list_assn P' l l'", "apply (induct P l l' rule: list_assn.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P.\n       (\\<And>x x'.\n           P x x' \\<Longrightarrow>\\<^sub>t P' x x') \\<Longrightarrow>\n       list_assn P [] [] \\<Longrightarrow>\\<^sub>t list_assn P' [] []\n 2. \\<And>P a as c cs.\n       \\<lbrakk>(\\<And>x x'.\n                    P x x' \\<Longrightarrow>\\<^sub>t\n                    P' x x') \\<Longrightarrow>\n                list_assn P as cs \\<Longrightarrow>\\<^sub>t\n                list_assn P' as cs;\n        \\<And>x x'. P x x' \\<Longrightarrow>\\<^sub>t P' x x'\\<rbrakk>\n       \\<Longrightarrow> list_assn P (a # as)\n                          (c # cs) \\<Longrightarrow>\\<^sub>t\n                         list_assn P' (a # as) (c # cs)\n 3. \\<And>uu_ v va.\n       (\\<And>x x'.\n           uu_ x x' \\<Longrightarrow>\\<^sub>t P' x x') \\<Longrightarrow>\n       list_assn uu_ (v # va) [] \\<Longrightarrow>\\<^sub>t\n       list_assn P' (v # va) []\n 4. \\<And>uu_ v va.\n       (\\<And>x x'.\n           uu_ x x' \\<Longrightarrow>\\<^sub>t P' x x') \\<Longrightarrow>\n       list_assn uu_ [] (v # va) \\<Longrightarrow>\\<^sub>t\n       list_assn P' [] (v # va)", "by (auto intro: entt_star_mono)"], ["", "lemma list_match_cong[sepref_frame_match_rules]: \n  \"\\<lbrakk>\\<And>x x'. \\<lbrakk>x\\<in>set l; x'\\<in>set l'\\<rbrakk> \\<Longrightarrow> hn_ctxt A x x' \\<Longrightarrow>\\<^sub>t hn_ctxt A' x x' \\<rbrakk> \\<Longrightarrow> hn_ctxt (list_assn A) l l' \\<Longrightarrow>\\<^sub>t hn_ctxt (list_assn A') l l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x x'.\n        \\<lbrakk>x \\<in> set l; x' \\<in> set l'\\<rbrakk>\n        \\<Longrightarrow> hn_ctxt A x x' \\<Longrightarrow>\\<^sub>t\n                          hn_ctxt A' x x') \\<Longrightarrow>\n    hn_ctxt (list_assn A) l l' \\<Longrightarrow>\\<^sub>t\n    hn_ctxt (list_assn A') l l'", "unfolding hn_ctxt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x x'.\n        \\<lbrakk>x \\<in> set l; x' \\<in> set l'\\<rbrakk>\n        \\<Longrightarrow> A x x' \\<Longrightarrow>\\<^sub>t\n                          A' x x') \\<Longrightarrow>\n    list_assn A l l' \\<Longrightarrow>\\<^sub>t list_assn A' l l'", "by (induct A l l' rule: list_assn.induct) (simp_all add: entt_star_mono)"], ["", "lemma list_merge_cong[sepref_frame_merge_rules]:\n  assumes \"\\<And>x x'. \\<lbrakk>x\\<in>set l; x'\\<in>set l'\\<rbrakk> \\<Longrightarrow> hn_ctxt A x x' \\<or>\\<^sub>A hn_ctxt A' x x' \\<Longrightarrow>\\<^sub>t hn_ctxt Am x x'\"\n  shows \"hn_ctxt (list_assn A) l l' \\<or>\\<^sub>A hn_ctxt (list_assn A') l l' \\<Longrightarrow>\\<^sub>t hn_ctxt (list_assn Am) l l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_ctxt (list_assn A) l l' \\<or>\\<^sub>A\n    hn_ctxt (list_assn A') l l' \\<Longrightarrow>\\<^sub>t\n    hn_ctxt (list_assn Am) l l'", "apply (blast intro: entt_disjE list_match_cong entt_disjD1[OF assms] entt_disjD2[OF assms])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma invalid_list_split: \n  \"invalid_assn (list_assn A) (x#xs) (y#ys) \\<Longrightarrow>\\<^sub>t invalid_assn A x y * invalid_assn (list_assn A) xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invalid_assn (list_assn A) (x # xs) (y # ys) \\<Longrightarrow>\\<^sub>t\n    invalid_assn A x y * invalid_assn (list_assn A) xs ys", "by (fastforce simp: invalid_assn_def intro!: enttI simp: mod_star_conv)"], ["", "lemma entt_invalid_list: \"hn_invalid (list_assn A) l l' \\<Longrightarrow>\\<^sub>t hn_ctxt (list_assn (invalid_assn A)) l l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_invalid (list_assn A) l l' \\<Longrightarrow>\\<^sub>t\n    hn_ctxt (list_assn (invalid_assn A)) l l'", "apply (induct A l l' rule: list_assn.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P.\n       hn_invalid (list_assn P) [] [] \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn (invalid_assn P)) [] []\n 2. \\<And>P a as c cs.\n       hn_invalid (list_assn P) as cs \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn (invalid_assn P)) as cs \\<Longrightarrow>\n       hn_invalid (list_assn P) (a # as) (c # cs) \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn (invalid_assn P)) (a # as) (c # cs)\n 3. \\<And>uu_ v va.\n       hn_invalid (list_assn uu_) (v # va) [] \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn (invalid_assn uu_)) (v # va) []\n 4. \\<And>uu_ v va.\n       hn_invalid (list_assn uu_) [] (v # va) \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn (invalid_assn uu_)) [] (v # va)", "applyS simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>P a as c cs.\n       hn_invalid (list_assn P) as cs \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn (invalid_assn P)) as cs \\<Longrightarrow>\n       hn_invalid (list_assn P) (a # as) (c # cs) \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn (invalid_assn P)) (a # as) (c # cs)\n 2. \\<And>uu_ v va.\n       hn_invalid (list_assn uu_) (v # va) [] \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn (invalid_assn uu_)) (v # va) []\n 3. \\<And>uu_ v va.\n       hn_invalid (list_assn uu_) [] (v # va) \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn (invalid_assn uu_)) [] (v # va)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_invalid (list_assn P_) as_ cs_ \\<Longrightarrow>\\<^sub>t\n    hn_ctxt (list_assn (invalid_assn P_)) as_ cs_ \\<Longrightarrow>\n    hn_invalid (list_assn P_) (a_ # as_)\n     (c_ # cs_) \\<Longrightarrow>\\<^sub>t\n    hn_ctxt (list_assn (invalid_assn P_)) (a_ # as_) (c_ # cs_)", "apply1 (simp add: hn_ctxt_def cong del: invalid_assn_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. invalid_assn (list_assn P_) as_ cs_ \\<Longrightarrow>\\<^sub>t\n    list_assn (invalid_assn P_) as_ cs_ \\<Longrightarrow>\n    invalid_assn (list_assn P_) (a_ # as_)\n     (c_ # cs_) \\<Longrightarrow>\\<^sub>t\n    invalid_assn P_ a_ c_ * list_assn (invalid_assn P_) as_ cs_", "apply1 (rule entt_trans[OF invalid_list_split])"], ["proof (prove)\ngoal (1 subgoal):\n 1. invalid_assn (list_assn P_) as_ cs_ \\<Longrightarrow>\\<^sub>t\n    list_assn (invalid_assn P_) as_ cs_ \\<Longrightarrow>\n    invalid_assn P_ a_ c_ *\n    invalid_assn (list_assn P_) as_ cs_ \\<Longrightarrow>\\<^sub>t\n    invalid_assn P_ a_ c_ * list_assn (invalid_assn P_) as_ cs_", "apply (rule entt_star_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. invalid_assn (list_assn P_) as_ cs_ \\<Longrightarrow>\\<^sub>t\n    list_assn (invalid_assn P_) as_ cs_ \\<Longrightarrow>\n    invalid_assn P_ a_ c_ \\<Longrightarrow>\\<^sub>t invalid_assn P_ a_ c_\n 2. invalid_assn (list_assn P_) as_ cs_ \\<Longrightarrow>\\<^sub>t\n    list_assn (invalid_assn P_) as_ cs_ \\<Longrightarrow>\n    invalid_assn (list_assn P_) as_ cs_ \\<Longrightarrow>\\<^sub>t\n    list_assn (invalid_assn P_) as_ cs_", "applyS simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. invalid_assn (list_assn P_) as_ cs_ \\<Longrightarrow>\\<^sub>t\n    list_assn (invalid_assn P_) as_ cs_ \\<Longrightarrow>\n    invalid_assn (list_assn P_) as_ cs_ \\<Longrightarrow>\\<^sub>t\n    list_assn (invalid_assn P_) as_ cs_", "apply (rule entt_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. invalid_assn (list_assn P_) as_ cs_ \\<Longrightarrow>\\<^sub>t\n    list_assn (invalid_assn P_) as_ cs_ \\<Longrightarrow>\n    invalid_assn (list_assn P_) as_ cs_ \\<Longrightarrow>\\<^sub>t ?B12\n 2. invalid_assn (list_assn P_) as_ cs_ \\<Longrightarrow>\\<^sub>t\n    list_assn (invalid_assn P_) as_ cs_ \\<Longrightarrow>\n    ?B12 \\<Longrightarrow>\\<^sub>t list_assn (invalid_assn P_) as_ cs_", "applyS assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. invalid_assn (list_assn P_) as_ cs_ \\<Longrightarrow>\\<^sub>t\n    list_assn (invalid_assn P_) as_ cs_ \\<Longrightarrow>\n    list_assn (invalid_assn P_) as_ cs_ \\<Longrightarrow>\\<^sub>t\n    list_assn (invalid_assn P_) as_ cs_", "applyS simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>uu_ v va.\n       hn_invalid (list_assn uu_) (v # va) [] \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn (invalid_assn uu_)) (v # va) []\n 2. \\<And>uu_ v va.\n       hn_invalid (list_assn uu_) [] (v # va) \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn (invalid_assn uu_)) [] (v # va)", "applyS (simp add: hn_ctxt_def invalid_assn_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>uu_ v va.\n       hn_invalid (list_assn uu_) [] (v # va) \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn (invalid_assn uu_)) [] (v # va)", "applyS (simp add: hn_ctxt_def invalid_assn_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas invalid_list_merge[sepref_frame_merge_rules] = gen_merge_cons[OF entt_invalid_list]"], ["", "lemma list_assn_comp[fcomp_norm_unfold]: \"hr_comp (list_assn A) (\\<langle>B\\<rangle>list_rel) = list_assn (hr_comp A B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hr_comp (list_assn A) (\\<langle>B\\<rangle>list_rel) =\n    list_assn (hr_comp A B)", "proof (intro ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       hr_comp (list_assn A) (\\<langle>B\\<rangle>list_rel) x xa =\n       list_assn (hr_comp A B) x xa", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       hr_comp (list_assn A) (\\<langle>B\\<rangle>list_rel) x xa =\n       list_assn (hr_comp A B) x xa", "fix x l y m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       hr_comp (list_assn A) (\\<langle>B\\<rangle>list_rel) x xa =\n       list_assn (hr_comp A B) x xa", "have \"hr_comp (list_assn A) (\\<langle>B\\<rangle>list_rel) (x # l) (y # m) = \n      hr_comp A B x y * hr_comp (list_assn A) (\\<langle>B\\<rangle>list_rel) l m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hr_comp (list_assn A) (\\<langle>B\\<rangle>list_rel) (x # l) (y # m) =\n    hr_comp A B x y *\n    hr_comp (list_assn A) (\\<langle>B\\<rangle>list_rel) l m", "by (sep_auto \n        simp: hr_comp_def list_rel_split_left_iff\n        intro!: ent_ex_preI ent_iffI)"], ["proof (state)\nthis:\n  hr_comp (list_assn A) (\\<langle>B\\<rangle>list_rel) (x # l) (y # m) =\n  hr_comp A B x y * hr_comp (list_assn A) (\\<langle>B\\<rangle>list_rel) l m\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       hr_comp (list_assn A) (\\<langle>B\\<rangle>list_rel) x xa =\n       list_assn (hr_comp A B) x xa", "(* TODO: ent_ex_preI should be applied by default, before ent_ex_postI!*)"], ["proof (state)\nthis:\n  hr_comp (list_assn A) (\\<langle>B\\<rangle>list_rel) (x # l) (y # m) =\n  hr_comp A B x y * hr_comp (list_assn A) (\\<langle>B\\<rangle>list_rel) l m\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       hr_comp (list_assn A) (\\<langle>B\\<rangle>list_rel) x xa =\n       list_assn (hr_comp A B) x xa", "}"], ["proof (state)\nthis:\n  hr_comp (list_assn A) (\\<langle>B\\<rangle>list_rel) (?x2 # ?l2)\n   (?y2 # ?m2) =\n  hr_comp A B ?x2 ?y2 *\n  hr_comp (list_assn A) (\\<langle>B\\<rangle>list_rel) ?l2 ?m2\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       hr_comp (list_assn A) (\\<langle>B\\<rangle>list_rel) x xa =\n       list_assn (hr_comp A B) x xa", "note aux = this"], ["proof (state)\nthis:\n  hr_comp (list_assn A) (\\<langle>B\\<rangle>list_rel) (?x2 # ?l2)\n   (?y2 # ?m2) =\n  hr_comp A B ?x2 ?y2 *\n  hr_comp (list_assn A) (\\<langle>B\\<rangle>list_rel) ?l2 ?m2\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       hr_comp (list_assn A) (\\<langle>B\\<rangle>list_rel) x xa =\n       list_assn (hr_comp A B) x xa", "fix l li"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       hr_comp (list_assn A) (\\<langle>B\\<rangle>list_rel) x xa =\n       list_assn (hr_comp A B) x xa", "show \"hr_comp (list_assn A) (\\<langle>B\\<rangle>list_rel) l li = list_assn (hr_comp A B) l li\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hr_comp (list_assn A) (\\<langle>B\\<rangle>list_rel) l li =\n    list_assn (hr_comp A B) l li", "apply (induction l arbitrary: li; case_tac li; intro ent_iffI)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>li.\n       li = [] \\<Longrightarrow>\n       hr_comp (list_assn A) (\\<langle>B\\<rangle>list_rel) []\n        li \\<Longrightarrow>\\<^sub>A\n       list_assn (hr_comp A B) [] li\n 2. \\<And>li.\n       li = [] \\<Longrightarrow>\n       list_assn (hr_comp A B) [] li \\<Longrightarrow>\\<^sub>A\n       hr_comp (list_assn A) (\\<langle>B\\<rangle>list_rel) [] li\n 3. \\<And>li a list.\n       li = a # list \\<Longrightarrow>\n       hr_comp (list_assn A) (\\<langle>B\\<rangle>list_rel) []\n        li \\<Longrightarrow>\\<^sub>A\n       list_assn (hr_comp A B) [] li\n 4. \\<And>li a list.\n       li = a # list \\<Longrightarrow>\n       list_assn (hr_comp A B) [] li \\<Longrightarrow>\\<^sub>A\n       hr_comp (list_assn A) (\\<langle>B\\<rangle>list_rel) [] li\n 5. \\<And>a l li.\n       \\<lbrakk>\\<And>li.\n                   hr_comp (list_assn A) (\\<langle>B\\<rangle>list_rel) l\n                    li =\n                   list_assn (hr_comp A B) l li;\n        li = []\\<rbrakk>\n       \\<Longrightarrow> hr_comp (list_assn A) (\\<langle>B\\<rangle>list_rel)\n                          (a # l) li \\<Longrightarrow>\\<^sub>A\n                         list_assn (hr_comp A B) (a # l) li\n 6. \\<And>a l li.\n       \\<lbrakk>\\<And>li.\n                   hr_comp (list_assn A) (\\<langle>B\\<rangle>list_rel) l\n                    li =\n                   list_assn (hr_comp A B) l li;\n        li = []\\<rbrakk>\n       \\<Longrightarrow> list_assn (hr_comp A B) (a # l)\n                          li \\<Longrightarrow>\\<^sub>A\n                         hr_comp (list_assn A) (\\<langle>B\\<rangle>list_rel)\n                          (a # l) li\n 7. \\<And>a l li aa list.\n       \\<lbrakk>\\<And>li.\n                   hr_comp (list_assn A) (\\<langle>B\\<rangle>list_rel) l\n                    li =\n                   list_assn (hr_comp A B) l li;\n        li = aa # list\\<rbrakk>\n       \\<Longrightarrow> hr_comp (list_assn A) (\\<langle>B\\<rangle>list_rel)\n                          (a # l) li \\<Longrightarrow>\\<^sub>A\n                         list_assn (hr_comp A B) (a # l) li\n 8. \\<And>a l li aa list.\n       \\<lbrakk>\\<And>li.\n                   hr_comp (list_assn A) (\\<langle>B\\<rangle>list_rel) l\n                    li =\n                   list_assn (hr_comp A B) l li;\n        li = aa # list\\<rbrakk>\n       \\<Longrightarrow> list_assn (hr_comp A B) (a # l)\n                          li \\<Longrightarrow>\\<^sub>A\n                         hr_comp (list_assn A) (\\<langle>B\\<rangle>list_rel)\n                          (a # l) li", "apply (sep_auto simp: hr_comp_def; fail)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a l li aa list.\n       \\<lbrakk>\\<And>li.\n                   hr_comp (list_assn A) (\\<langle>B\\<rangle>list_rel) l\n                    li =\n                   list_assn (hr_comp A B) l li;\n        li = aa # list\\<rbrakk>\n       \\<Longrightarrow> hr_comp (list_assn A) (\\<langle>B\\<rangle>list_rel)\n                          (a # l) li \\<Longrightarrow>\\<^sub>A\n                         list_assn (hr_comp A B) (a # l) li\n 2. \\<And>a l li aa list.\n       \\<lbrakk>\\<And>li.\n                   hr_comp (list_assn A) (\\<langle>B\\<rangle>list_rel) l\n                    li =\n                   list_assn (hr_comp A B) l li;\n        li = aa # list\\<rbrakk>\n       \\<Longrightarrow> list_assn (hr_comp A B) (a # l)\n                          li \\<Longrightarrow>\\<^sub>A\n                         hr_comp (list_assn A) (\\<langle>B\\<rangle>list_rel)\n                          (a # l) li", "by (simp_all add: aux)"], ["proof (state)\nthis:\n  hr_comp (list_assn A) (\\<langle>B\\<rangle>list_rel) l li =\n  list_assn (hr_comp A B) l li\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hn_ctxt_eq: \"A x y = z \\<Longrightarrow> hn_ctxt A x y = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A x y = z \\<Longrightarrow> hn_ctxt A x y = z", "by (simp add: hn_ctxt_def)"], ["", "lemmas hn_ctxt_list = hn_ctxt_eq[of \"list_assn A\" for A]"], ["", "lemma hn_case_list[sepref_prep_comb_rule, sepref_comb_rules]:\n  fixes p p' P\n  defines [simp]: \"INVE \\<equiv> hn_invalid (list_assn P) p p'\"\n  assumes FR: \"\\<Gamma> \\<Longrightarrow>\\<^sub>t hn_ctxt (list_assn P) p p' * F\"\n  assumes Rn: \"p=[] \\<Longrightarrow> hn_refine (hn_ctxt (list_assn P) p p' * F) f1' (hn_ctxt XX1 p p' * \\<Gamma>1') R f1\"\n  assumes Rs: \"\\<And>x l x' l'. \\<lbrakk> p=x#l; p'=x'#l' \\<rbrakk> \\<Longrightarrow> \n    hn_refine (hn_ctxt P x x' * hn_ctxt (list_assn P) l l' * INVE * F) (f2' x' l') (hn_ctxt P1' x x' * hn_ctxt (list_assn P2') l l' * hn_ctxt XX2 p p' * \\<Gamma>2') R (f2 x l)\"\n  assumes MERGE1[unfolded hn_ctxt_def]: \"\\<And>x x'. hn_ctxt P1' x x' \\<or>\\<^sub>A hn_ctxt P2' x x' \\<Longrightarrow>\\<^sub>t hn_ctxt P' x x'\"  \n  assumes MERGE2: \"\\<Gamma>1' \\<or>\\<^sub>A \\<Gamma>2' \\<Longrightarrow>\\<^sub>t \\<Gamma>'\"  \n  shows \"hn_refine \\<Gamma> (case_list f1' f2' p') (hn_ctxt (list_assn P') p p' * \\<Gamma>') R (case_list$f1$(\\<lambda>\\<^sub>2x l. f2 x l)$p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine \\<Gamma>\n     (case p' of [] \\<Rightarrow> f1' | x # xa \\<Rightarrow> f2' x xa)\n     (hn_ctxt (list_assn P') p p' * \\<Gamma>') R\n     (case_list $ f1 $ (\\<lambda>x. (#\\<lambda>xa. (#f2 x xa#)#)) $ p)", "apply (rule hn_refine_cons_pre[OF FR])"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt (list_assn P) p p' * F)\n     (case p' of [] \\<Rightarrow> f1' | x # xa \\<Rightarrow> f2' x xa)\n     (hn_ctxt (list_assn P') p p' * \\<Gamma>') R\n     (case_list $ f1 $ (\\<lambda>x. (#\\<lambda>xa. (#f2 x xa#)#)) $ p)", "apply1 extract_hnr_invalids"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h h1 h2.\n       \\<lbrakk>h2 \\<Turnstile> F;\n        hn_invalid (list_assn P) p p' = true\\<rbrakk>\n       \\<Longrightarrow> hn_refine (hn_ctxt (list_assn P) p p' * F)\n                          (case p' of [] \\<Rightarrow> f1'\n                           | x # xa \\<Rightarrow> f2' x xa)\n                          (hn_ctxt (list_assn P') p p' * \\<Gamma>') R\n                          (case_list $ f1 $\n                           (\\<lambda>x. (#\\<lambda>xa. (#f2 x xa#)#)) $\n                           p)", "apply (cases p; cases p'; simp add: list_assn.simps[THEN hn_ctxt_list])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>h2.\n       \\<lbrakk>h2 \\<Turnstile> F; hn_invalid (list_assn P) [] [] = true;\n        p = []; p' = []\\<rbrakk>\n       \\<Longrightarrow> hn_refine F f1' \\<Gamma>' R f1\n 2. \\<And>h2 a list aa lista.\n       \\<lbrakk>h2 \\<Turnstile> F;\n        hn_invalid (list_assn P) (a # list) (aa # lista) = true;\n        p = a # list; p' = aa # lista\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt P a aa *\n                           hn_ctxt (list_assn P) list lista *\n                           F)\n                          (f2' aa lista)\n                          (hn_ctxt P' a aa *\n                           hn_ctxt (list_assn P') list lista *\n                           \\<Gamma>')\n                          R (f2 a list)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F; hn_invalid (list_assn P) [] [] = true;\n     p = []; p' = []\\<rbrakk>\n    \\<Longrightarrow> hn_refine F f1' \\<Gamma>' R f1", "apply (rule hn_refine_cons[OF _ Rn _ entt_refl]; assumption?)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F; hn_invalid (list_assn P) [] [] = true;\n     p = []; p' = []\\<rbrakk>\n    \\<Longrightarrow> F \\<Longrightarrow>\\<^sub>t\n                      hn_ctxt (list_assn P) p p' * F\n 2. \\<lbrakk>h2_ \\<Turnstile> F; hn_invalid (list_assn P) [] [] = true;\n     p = []; p' = []\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt XX1 p p' *\n                      \\<Gamma>1' \\<Longrightarrow>\\<^sub>t\n                      \\<Gamma>'", "applyS (simp add: hn_ctxt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F; hn_invalid (list_assn P) [] [] = true;\n     p = []; p' = []\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt XX1 p p' *\n                      \\<Gamma>1' \\<Longrightarrow>\\<^sub>t\n                      \\<Gamma>'", "apply (subst mult.commute, rule entt_fr_drop)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F; hn_invalid (list_assn P) [] [] = true;\n     p = []; p' = []\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>1' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "apply (rule entt_trans[OF _ MERGE2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F; hn_invalid (list_assn P) [] [] = true;\n     p = []; p' = []\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>1' \\<Longrightarrow>\\<^sub>t\n                      \\<Gamma>1' \\<or>\\<^sub>A \\<Gamma>2'", "apply (simp add: ent_disjI1' ent_disjI2')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h2 a list aa lista.\n       \\<lbrakk>h2 \\<Turnstile> F;\n        hn_invalid (list_assn P) (a # list) (aa # lista) = true;\n        p = a # list; p' = aa # lista\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt P a aa *\n                           hn_ctxt (list_assn P) list lista *\n                           F)\n                          (f2' aa lista)\n                          (hn_ctxt P' a aa *\n                           hn_ctxt (list_assn P') list lista *\n                           \\<Gamma>')\n                          R (f2 a list)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (list_assn P) (a_ # list_) (aa_ # lista_) = true;\n     p = a_ # list_; p' = aa_ # lista_\\<rbrakk>\n    \\<Longrightarrow> hn_refine\n                       (hn_ctxt P a_ aa_ *\n                        hn_ctxt (list_assn P) list_ lista_ *\n                        F)\n                       (f2' aa_ lista_)\n                       (hn_ctxt P' a_ aa_ *\n                        hn_ctxt (list_assn P') list_ lista_ *\n                        \\<Gamma>')\n                       R (f2 a_ list_)", "apply (rule hn_refine_cons[OF _ Rs _ entt_refl]; assumption?)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (list_assn P) (a_ # list_) (aa_ # lista_) = true;\n     p = a_ # list_; p' = aa_ # lista_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt P a_ aa_ *\n                      hn_ctxt (list_assn P) list_ lista_ *\n                      F \\<Longrightarrow>\\<^sub>t\n                      hn_ctxt P a_ aa_ *\n                      hn_ctxt (list_assn P) list_ lista_ *\n                      INVE *\n                      F\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (list_assn P) (a_ # list_) (aa_ # lista_) = true;\n     p = a_ # list_; p' = aa_ # lista_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt P1' a_ aa_ *\n                      hn_ctxt (list_assn P2') list_ lista_ *\n                      hn_ctxt XX2 p p' *\n                      \\<Gamma>2' \\<Longrightarrow>\\<^sub>t\n                      hn_ctxt P' a_ aa_ *\n                      hn_ctxt (list_assn P') list_ lista_ *\n                      \\<Gamma>'", "applyS (simp add: hn_ctxt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (list_assn P) (a_ # list_) (aa_ # lista_) = true;\n     p = a_ # list_; p' = aa_ # lista_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt P1' a_ aa_ *\n                      hn_ctxt (list_assn P2') list_ lista_ *\n                      hn_ctxt XX2 p p' *\n                      \\<Gamma>2' \\<Longrightarrow>\\<^sub>t\n                      hn_ctxt P' a_ aa_ *\n                      hn_ctxt (list_assn P') list_ lista_ *\n                      \\<Gamma>'", "apply (rule entt_star_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (list_assn P) (a_ # list_) (aa_ # lista_) = true;\n     p = a_ # list_; p' = aa_ # lista_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt P1' a_ aa_ *\n                      hn_ctxt (list_assn P2') list_ lista_ *\n                      hn_ctxt XX2 p p' \\<Longrightarrow>\\<^sub>t\n                      hn_ctxt P' a_ aa_ *\n                      hn_ctxt (list_assn P') list_ lista_\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (list_assn P) (a_ # list_) (aa_ # lista_) = true;\n     p = a_ # list_; p' = aa_ # lista_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>2' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "apply1 (rule entt_fr_drop)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (list_assn P) (a_ # list_) (aa_ # lista_) = true;\n     p = a_ # list_; p' = aa_ # lista_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt P1' a_ aa_ *\n                      hn_ctxt (list_assn P2') list_\n                       lista_ \\<Longrightarrow>\\<^sub>t\n                      hn_ctxt P' a_ aa_ *\n                      hn_ctxt (list_assn P') list_ lista_\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (list_assn P) (a_ # list_) (aa_ # lista_) = true;\n     p = a_ # list_; p' = aa_ # lista_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>2' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "apply (rule entt_star_mono)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (list_assn P) (a_ # list_) (aa_ # lista_) = true;\n     p = a_ # list_; p' = aa_ # lista_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt P1' a_ aa_ \\<Longrightarrow>\\<^sub>t\n                      hn_ctxt P' a_ aa_\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (list_assn P) (a_ # list_) (aa_ # lista_) = true;\n     p = a_ # list_; p' = aa_ # lista_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt (list_assn P2') list_\n                       lista_ \\<Longrightarrow>\\<^sub>t\n                      hn_ctxt (list_assn P') list_ lista_\n 3. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (list_assn P) (a_ # list_) (aa_ # lista_) = true;\n     p = a_ # list_; p' = aa_ # lista_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>2' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "apply1 (simp add: hn_ctxt_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     invalid_assn (\\<lambda>b c. P a_ aa_ * list_assn P list_ lista_)\n      (a_ # list_) (aa_ # lista_) =\n     true;\n     p = a_ # list_; p' = aa_ # lista_\\<rbrakk>\n    \\<Longrightarrow> P1' a_ aa_ \\<Longrightarrow>\\<^sub>t P' a_ aa_\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (list_assn P) (a_ # list_) (aa_ # lista_) = true;\n     p = a_ # list_; p' = aa_ # lista_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt (list_assn P2') list_\n                       lista_ \\<Longrightarrow>\\<^sub>t\n                      hn_ctxt (list_assn P') list_ lista_\n 3. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (list_assn P) (a_ # list_) (aa_ # lista_) = true;\n     p = a_ # list_; p' = aa_ # lista_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>2' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "apply1 (rule entt_trans[OF _ MERGE1])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     invalid_assn (\\<lambda>b c. P a_ aa_ * list_assn P list_ lista_)\n      (a_ # list_) (aa_ # lista_) =\n     true;\n     p = a_ # list_; p' = aa_ # lista_\\<rbrakk>\n    \\<Longrightarrow> P1' a_ aa_ \\<Longrightarrow>\\<^sub>t\n                      P1' a_ aa_ \\<or>\\<^sub>A P2' a_ aa_\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (list_assn P) (a_ # list_) (aa_ # lista_) = true;\n     p = a_ # list_; p' = aa_ # lista_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt (list_assn P2') list_\n                       lista_ \\<Longrightarrow>\\<^sub>t\n                      hn_ctxt (list_assn P') list_ lista_\n 3. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (list_assn P) (a_ # list_) (aa_ # lista_) = true;\n     p = a_ # list_; p' = aa_ # lista_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>2' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "applyS (simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (list_assn P) (a_ # list_) (aa_ # lista_) = true;\n     p = a_ # list_; p' = aa_ # lista_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt (list_assn P2') list_\n                       lista_ \\<Longrightarrow>\\<^sub>t\n                      hn_ctxt (list_assn P') list_ lista_\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (list_assn P) (a_ # list_) (aa_ # lista_) = true;\n     p = a_ # list_; p' = aa_ # lista_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>2' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "apply1 (simp add: hn_ctxt_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     invalid_assn (\\<lambda>b c. P a_ aa_ * list_assn P list_ lista_)\n      (a_ # list_) (aa_ # lista_) =\n     true;\n     p = a_ # list_; p' = aa_ # lista_\\<rbrakk>\n    \\<Longrightarrow> list_assn P2' list_ lista_ \\<Longrightarrow>\\<^sub>t\n                      list_assn P' list_ lista_\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (list_assn P) (a_ # list_) (aa_ # lista_) = true;\n     p = a_ # list_; p' = aa_ # lista_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>2' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "apply (rule list_assn_monot)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x'.\n       \\<lbrakk>h2_ \\<Turnstile> F;\n        invalid_assn (\\<lambda>b c. P a_ aa_ * list_assn P list_ lista_)\n         (a_ # list_) (aa_ # lista_) =\n        true;\n        p = a_ # list_; p' = aa_ # lista_\\<rbrakk>\n       \\<Longrightarrow> P2' x x' \\<Longrightarrow>\\<^sub>t P' x x'\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (list_assn P) (a_ # list_) (aa_ # lista_) = true;\n     p = a_ # list_; p' = aa_ # lista_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>2' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "apply1 (rule entt_trans[OF _ MERGE1])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x'.\n       \\<lbrakk>h2_ \\<Turnstile> F;\n        invalid_assn (\\<lambda>b c. P a_ aa_ * list_assn P list_ lista_)\n         (a_ # list_) (aa_ # lista_) =\n        true;\n        p = a_ # list_; p' = aa_ # lista_\\<rbrakk>\n       \\<Longrightarrow> P2' x x' \\<Longrightarrow>\\<^sub>t\n                         P1' x x' \\<or>\\<^sub>A P2' x x'\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (list_assn P) (a_ # list_) (aa_ # lista_) = true;\n     p = a_ # list_; p' = aa_ # lista_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>2' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "applyS (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (list_assn P) (a_ # list_) (aa_ # lista_) = true;\n     p = a_ # list_; p' = aa_ # lista_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>2' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "apply1 (rule entt_trans[OF _ MERGE2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (list_assn P) (a_ # list_) (aa_ # lista_) = true;\n     p = a_ # list_; p' = aa_ # lista_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>2' \\<Longrightarrow>\\<^sub>t\n                      \\<Gamma>1' \\<or>\\<^sub>A \\<Gamma>2'", "applyS (simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hn_Nil[sepref_fr_rules]: \n  \"hn_refine emp (return []) emp (list_assn P) (RETURN$[])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine emp (return []) emp (list_assn P) (RETURN $ [])", "unfolding hn_refine_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (RETURN $ []) \\<longrightarrow>\n    <emp> return\n           [] <\\<lambda>r.\n                  emp *\n                  (\\<exists>\\<^sub>Ax.\n                      list_assn P x r *\n                      \\<up> (RETURN x \\<le> RETURN $ []))>\\<^sub>t", "by sep_auto"], ["", "lemma hn_Cons[sepref_fr_rules]: \"hn_refine (hn_ctxt P x x' * hn_ctxt (list_assn P) xs xs') \n  (return (x'#xs')) (hn_invalid P x x' * hn_invalid (list_assn P) xs xs') (list_assn P)\n  (RETURN$((#) $x$xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt P x x' * hn_ctxt (list_assn P) xs xs')\n     (return (x' # xs'))\n     (hn_invalid P x x' * hn_invalid (list_assn P) xs xs') (list_assn P)\n     (RETURN $ ((#) $ x $ xs))", "unfolding hn_refine_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (RETURN $ ((#) $ x $ xs)) \\<longrightarrow>\n    <hn_ctxt P x x' *\n     hn_ctxt (list_assn P) xs\n      xs'> return\n            (x' #\n             xs') <\\<lambda>r.\n                      hn_invalid P x x' * hn_invalid (list_assn P) xs xs' *\n                      (\\<exists>\\<^sub>Axa.\n                          list_assn P xa r *\n                          \\<up>\n                           (RETURN xa\n                            \\<le> RETURN $ ((#) $ x $ xs)))>\\<^sub>t", "apply (sep_auto simp: hn_ctxt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P x x' * list_assn P xs xs' \\<Longrightarrow>\\<^sub>A\n    invalid_assn P x x' * invalid_assn (list_assn P) xs xs' * P x x' *\n    list_assn P xs xs' *\n    true", "apply (rule ent_frame_fwd[OF invalidate_clone'[of P]], frame_inference)"], ["proof (prove)\ngoal (1 subgoal):\n 1. invalid_assn P x x' * P x x' * true *\n    list_assn P xs xs' \\<Longrightarrow>\\<^sub>A\n    invalid_assn P x x' * invalid_assn (list_assn P) xs xs' * P x x' *\n    list_assn P xs xs' *\n    true", "apply (rule ent_frame_fwd[OF invalidate_clone'[of \"list_assn P\"]], frame_inference)"], ["proof (prove)\ngoal (1 subgoal):\n 1. invalid_assn (list_assn P) xs xs' * list_assn P xs xs' * true *\n    (invalid_assn P x x' * P x x' * true) \\<Longrightarrow>\\<^sub>A\n    invalid_assn P x x' * invalid_assn (list_assn P) xs xs' * P x x' *\n    list_assn P xs xs' *\n    true", "apply solve_entails"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma list_assn_aux_len: \n  \"list_assn P l l' = list_assn P l l' * \\<up>(length l = length l')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_assn P l l' = list_assn P l l' * \\<up> (length l = length l')", "apply (induct P\\<equiv>P l l' rule: list_assn.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. list_assn P [] [] = list_assn P [] [] * \\<up> (length [] = length [])\n 2. \\<And>a as c cs.\n       list_assn P as cs =\n       list_assn P as cs * \\<up> (length as = length cs) \\<Longrightarrow>\n       list_assn P (a # as) (c # cs) =\n       list_assn P (a # as) (c # cs) *\n       \\<up> (length (a # as) = length (c # cs))\n 3. \\<And>v va.\n       list_assn P (v # va) [] =\n       list_assn P (v # va) [] * \\<up> (length (v # va) = length [])\n 4. \\<And>v va.\n       list_assn P [] (v # va) =\n       list_assn P [] (v # va) * \\<up> (length [] = length (v # va))", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as c cs.\n       list_assn P as cs =\n       list_assn P as cs * \\<up> (length as = length cs) \\<Longrightarrow>\n       P a c * list_assn P as cs =\n       P a c * list_assn P as cs * \\<up> (length as = length cs)", "subgoal for a as c cs"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_assn P as cs =\n    list_assn P as cs * \\<up> (length as = length cs) \\<Longrightarrow>\n    P a c * list_assn P as cs =\n    P a c * list_assn P as cs * \\<up> (length as = length cs)", "by (erule_tac t=\"list_assn P as cs\" in subst[OF sym]) simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma list_assn_aux_eqlen_simp: \n  \"vassn_tag (list_assn P l l') \\<Longrightarrow> length l' = length l\"\n  \"h \\<Turnstile> (list_assn P l l') \\<Longrightarrow> length l' = length l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (vassn_tag (list_assn P l l') \\<Longrightarrow>\n     length l' = length l) &&&\n    (h \\<Turnstile> list_assn P l l' \\<Longrightarrow> length l' = length l)", "apply (subst (asm) list_assn_aux_len; auto simp: vassn_tag_def)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hn_append[sepref_fr_rules]: \"hn_refine (hn_ctxt (list_assn P) l1 l1' * hn_ctxt (list_assn P) l2 l2')\n  (return (l1'@l2')) (hn_invalid (list_assn P) l1 l1' * hn_invalid (list_assn P) l2 l2') (list_assn P)\n  (RETURN$((@) $l1$l2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt (list_assn P) l1 l1' * hn_ctxt (list_assn P) l2 l2')\n     (return (l1' @ l2'))\n     (hn_invalid (list_assn P) l1 l1' * hn_invalid (list_assn P) l2 l2')\n     (list_assn P) (RETURN $ ((@) $ l1 $ l2))", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (RETURN $ ((@) $ l1 $ l2)) \\<Longrightarrow>\n    <hn_ctxt (list_assn P) l1 l1' *\n     hn_ctxt (list_assn P) l2\n      l2'> return\n            (l1' @\n             l2') <\\<lambda>r.\n                      hn_invalid (list_assn P) l1 l1' *\n                      hn_invalid (list_assn P) l2 l2' *\n                      (\\<exists>\\<^sub>Ax.\n                          list_assn P x r *\n                          \\<up>\n                           (RETURN x\n                            \\<le> RETURN $ ((@) $ l1 $ l2)))>\\<^sub>t", "apply (sep_auto simp: hn_ctxt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_assn P l1 l1' * list_assn P l2 l2' \\<Longrightarrow>\\<^sub>A\n    invalid_assn (list_assn P) l1 l1' * invalid_assn (list_assn P) l2 l2' *\n    list_assn P (l1 @ l2) (l1' @ l2') *\n    true", "apply (subst list_assn_aux_len)"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_assn P l1 l1' * \\<up> (length l1 = length l1') *\n    list_assn P l2 l2' \\<Longrightarrow>\\<^sub>A\n    invalid_assn (list_assn P) l1 l1' * invalid_assn (list_assn P) l2 l2' *\n    list_assn P (l1 @ l2) (l1' @ l2') *\n    true", "apply (sep_auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length l1 = length l1' \\<Longrightarrow>\n    list_assn P l1 l1' * list_assn P l2 l2' \\<Longrightarrow>\\<^sub>A\n    invalid_assn (list_assn P) l1 l1' * invalid_assn (list_assn P) l2 l2' *\n    list_assn P l1 l1' *\n    list_assn P l2 l2' *\n    true", "apply (rule ent_frame_fwd[OF invalidate_clone'[of \"list_assn P\"]], frame_inference)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length l1 = length l1' \\<Longrightarrow>\n    invalid_assn (list_assn P) l2 l2' * list_assn P l2 l2' * true *\n    list_assn P l1 l1' \\<Longrightarrow>\\<^sub>A\n    invalid_assn (list_assn P) l1 l1' * invalid_assn (list_assn P) l2 l2' *\n    list_assn P l1 l1' *\n    list_assn P l2 l2' *\n    true", "apply (rule ent_frame_fwd[OF invalidate_clone'[of \"list_assn P\"]], frame_inference)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length l1 = length l1' \\<Longrightarrow>\n    invalid_assn (list_assn P) l1 l1' * list_assn P l1 l1' * true *\n    (invalid_assn (list_assn P) l2 l2' * list_assn P l2 l2' *\n     true) \\<Longrightarrow>\\<^sub>A\n    invalid_assn (list_assn P) l1 l1' * invalid_assn (list_assn P) l2 l2' *\n    list_assn P l1 l1' *\n    list_assn P l2 l2' *\n    true", "apply solve_entails"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma list_assn_aux_cons_conv1:\n  \"list_assn R (a#l) m = (\\<exists>\\<^sub>Ab m'. R a b * list_assn R l m' * \\<up>(m=b#m'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_assn R (a # l) m =\n    (\\<exists>\\<^sub>Ab m'. R a b * list_assn R l m' * \\<up> (m = b # m'))", "apply (cases m)"], ["proof (prove)\ngoal (2 subgoals):\n 1. m = [] \\<Longrightarrow>\n    list_assn R (a # l) m =\n    (\\<exists>\\<^sub>Ab m'. R a b * list_assn R l m' * \\<up> (m = b # m'))\n 2. \\<And>aa list.\n       m = aa # list \\<Longrightarrow>\n       list_assn R (a # l) m =\n       (\\<exists>\\<^sub>Ab m'.\n           R a b * list_assn R l m' * \\<up> (m = b # m'))", "apply sep_auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       m = aa # list \\<Longrightarrow>\n       list_assn R (a # l) m =\n       (\\<exists>\\<^sub>Ab m'.\n           R a b * list_assn R l m' * \\<up> (m = b # m'))", "apply (sep_auto intro!: ent_iffI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma list_assn_aux_cons_conv2:\n  \"list_assn R l (b#m) = (\\<exists>\\<^sub>Aa l'. R a b * list_assn R l' m * \\<up>(l=a#l'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_assn R l (b # m) =\n    (\\<exists>\\<^sub>Aa l'. R a b * list_assn R l' m * \\<up> (l = a # l'))", "apply (cases l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. l = [] \\<Longrightarrow>\n    list_assn R l (b # m) =\n    (\\<exists>\\<^sub>Aa l'. R a b * list_assn R l' m * \\<up> (l = a # l'))\n 2. \\<And>a list.\n       l = a # list \\<Longrightarrow>\n       list_assn R l (b # m) =\n       (\\<exists>\\<^sub>Aa l'.\n           R a b * list_assn R l' m * \\<up> (l = a # l'))", "apply sep_auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       l = a # list \\<Longrightarrow>\n       list_assn R l (b # m) =\n       (\\<exists>\\<^sub>Aa l'.\n           R a b * list_assn R l' m * \\<up> (l = a # l'))", "apply (sep_auto intro!: ent_iffI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas list_assn_aux_cons_conv = list_assn_aux_cons_conv1 list_assn_aux_cons_conv2"], ["", "lemma list_assn_aux_append_conv1:\n  \"list_assn R (l1@l2) m = (\\<exists>\\<^sub>Am1 m2. list_assn R l1 m1 * list_assn R l2 m2 * \\<up>(m=m1@m2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_assn R (l1 @ l2) m =\n    (\\<exists>\\<^sub>Am1 m2.\n        list_assn R l1 m1 * list_assn R l2 m2 * \\<up> (m = m1 @ m2))", "apply (induction l1 arbitrary: m)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m.\n       list_assn R ([] @ l2) m =\n       (\\<exists>\\<^sub>Am1 m2.\n           list_assn R [] m1 * list_assn R l2 m2 * \\<up> (m = m1 @ m2))\n 2. \\<And>a l1 m.\n       (\\<And>m.\n           list_assn R (l1 @ l2) m =\n           (\\<exists>\\<^sub>Am1 m2.\n               list_assn R l1 m1 * list_assn R l2 m2 *\n               \\<up> (m = m1 @ m2))) \\<Longrightarrow>\n       list_assn R ((a # l1) @ l2) m =\n       (\\<exists>\\<^sub>Am1 m2.\n           list_assn R (a # l1) m1 * list_assn R l2 m2 *\n           \\<up> (m = m1 @ m2))", "apply (sep_auto intro!: ent_iffI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l1 m.\n       (\\<And>m.\n           list_assn R (l1 @ l2) m =\n           (\\<exists>\\<^sub>Am1 m2.\n               list_assn R l1 m1 * list_assn R l2 m2 *\n               \\<up> (m = m1 @ m2))) \\<Longrightarrow>\n       list_assn R ((a # l1) @ l2) m =\n       (\\<exists>\\<^sub>Am1 m2.\n           list_assn R (a # l1) m1 * list_assn R l2 m2 *\n           \\<up> (m = m1 @ m2))", "apply (sep_auto intro!: ent_iffI simp: list_assn_aux_cons_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma list_assn_aux_append_conv2:\n  \"list_assn R l (m1@m2) = (\\<exists>\\<^sub>Al1 l2. list_assn R l1 m1 * list_assn R l2 m2 * \\<up>(l=l1@l2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_assn R l (m1 @ m2) =\n    (\\<exists>\\<^sub>Al1 l2.\n        list_assn R l1 m1 * list_assn R l2 m2 * \\<up> (l = l1 @ l2))", "apply (induction m1 arbitrary: l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l.\n       list_assn R l ([] @ m2) =\n       (\\<exists>\\<^sub>Al1 l2.\n           list_assn R l1 [] * list_assn R l2 m2 * \\<up> (l = l1 @ l2))\n 2. \\<And>a m1 l.\n       (\\<And>l.\n           list_assn R l (m1 @ m2) =\n           (\\<exists>\\<^sub>Al1 l2.\n               list_assn R l1 m1 * list_assn R l2 m2 *\n               \\<up> (l = l1 @ l2))) \\<Longrightarrow>\n       list_assn R l ((a # m1) @ m2) =\n       (\\<exists>\\<^sub>Al1 l2.\n           list_assn R l1 (a # m1) * list_assn R l2 m2 *\n           \\<up> (l = l1 @ l2))", "apply (sep_auto intro!: ent_iffI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a m1 l.\n       (\\<And>l.\n           list_assn R l (m1 @ m2) =\n           (\\<exists>\\<^sub>Al1 l2.\n               list_assn R l1 m1 * list_assn R l2 m2 *\n               \\<up> (l = l1 @ l2))) \\<Longrightarrow>\n       list_assn R l ((a # m1) @ m2) =\n       (\\<exists>\\<^sub>Al1 l2.\n           list_assn R l1 (a # m1) * list_assn R l2 m2 *\n           \\<up> (l = l1 @ l2))", "apply (sep_auto intro!: ent_iffI simp: list_assn_aux_cons_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas list_assn_aux_append_conv = list_assn_aux_append_conv1 list_assn_aux_append_conv2"], ["", "declare param_upt[sepref_import_param]"], ["", "subsection \\<open>Sum-Type\\<close>"], ["", "fun sum_assn :: \"('ai \\<Rightarrow> 'a \\<Rightarrow> assn) \\<Rightarrow> ('bi \\<Rightarrow> 'b \\<Rightarrow> assn) \\<Rightarrow> ('ai+'bi) \\<Rightarrow> ('a+'b) \\<Rightarrow> assn\" where\n  \"sum_assn A B (Inl ai) (Inl a) = A ai a\"\n| \"sum_assn A B (Inr bi) (Inr b) = B bi b\"\n| \"sum_assn A B _ _ = false\""], ["", "notation sum_assn (infixr \"+\\<^sub>a\" 67)"], ["", "lemma sum_assn_pure[safe_constraint_rules]: \"\\<lbrakk>is_pure A; is_pure B\\<rbrakk> \\<Longrightarrow> is_pure (sum_assn A B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_pure A; is_pure B\\<rbrakk>\n    \\<Longrightarrow> is_pure (A +\\<^sub>a B)", "apply (auto simp: is_pure_iff_pure_assn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x'.\n       \\<lbrakk>\\<forall>x x'. is_pure_assn (A x x');\n        \\<forall>x x'. is_pure_assn (B x x')\\<rbrakk>\n       \\<Longrightarrow> is_pure_assn ((A +\\<^sub>a B) x x')", "apply (rename_tac x x')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x'.\n       \\<lbrakk>\\<forall>x x'. is_pure_assn (A x x');\n        \\<forall>x x'. is_pure_assn (B x x')\\<rbrakk>\n       \\<Longrightarrow> is_pure_assn ((A +\\<^sub>a B) x x')", "apply (case_tac x; case_tac x'; simp add: pure_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sum_assn_id[simp]: \"sum_assn id_assn id_assn = id_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. id_assn +\\<^sub>a id_assn = id_assn", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa. (id_assn +\\<^sub>a id_assn) x xa = id_assn x xa", "subgoal for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. (id_assn +\\<^sub>a id_assn) x y = id_assn x y", "by (cases x; cases y; simp add: pure_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sum_assn_pure_conv[simp]: \"sum_assn (pure A) (pure B) = pure (\\<langle>A,B\\<rangle>sum_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure A +\\<^sub>a pure B = pure (\\<langle>A, B\\<rangle>sum_rel)", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       (pure A +\\<^sub>a pure B) x xa =\n       pure (\\<langle>A, B\\<rangle>sum_rel) x xa", "subgoal for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. (pure A +\\<^sub>a pure B) a b = pure (\\<langle>A, B\\<rangle>sum_rel) a b", "by (cases a; cases b; auto simp: pure_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sum_match_cong[sepref_frame_match_rules]: \n  \"\\<lbrakk>\n    \\<And>x y. \\<lbrakk>e = Inl x; e'=Inl y\\<rbrakk> \\<Longrightarrow> hn_ctxt A x y \\<Longrightarrow>\\<^sub>t hn_ctxt A' x y;\n    \\<And>x y. \\<lbrakk>e = Inr x; e'=Inr y\\<rbrakk> \\<Longrightarrow> hn_ctxt B x y \\<Longrightarrow>\\<^sub>t hn_ctxt B' x y\n  \\<rbrakk> \\<Longrightarrow> hn_ctxt (sum_assn A B) e e' \\<Longrightarrow>\\<^sub>t hn_ctxt (sum_assn A' B') e e'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y.\n                \\<lbrakk>e = Inl x; e' = Inl y\\<rbrakk>\n                \\<Longrightarrow> hn_ctxt A x y \\<Longrightarrow>\\<^sub>t\n                                  hn_ctxt A' x y;\n     \\<And>x y.\n        \\<lbrakk>e = Inr x; e' = Inr y\\<rbrakk>\n        \\<Longrightarrow> hn_ctxt B x y \\<Longrightarrow>\\<^sub>t\n                          hn_ctxt B' x y\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt (A +\\<^sub>a B) e e' \\<Longrightarrow>\\<^sub>t\n                      hn_ctxt (A' +\\<^sub>a B') e e'", "by (cases e; cases e'; simp add: hn_ctxt_def entt_star_mono)"], ["", "lemma enum_merge_cong[sepref_frame_merge_rules]:\n  assumes \"\\<And>x y. \\<lbrakk>e=Inl x; e'=Inl y\\<rbrakk> \\<Longrightarrow> hn_ctxt A x y \\<or>\\<^sub>A hn_ctxt A' x y \\<Longrightarrow>\\<^sub>t hn_ctxt Am x y\"\n  assumes \"\\<And>x y. \\<lbrakk>e=Inr x; e'=Inr y\\<rbrakk> \\<Longrightarrow> hn_ctxt B x y \\<or>\\<^sub>A hn_ctxt B' x y \\<Longrightarrow>\\<^sub>t hn_ctxt Bm x y\"\n  shows \"hn_ctxt (sum_assn A B) e e' \\<or>\\<^sub>A hn_ctxt (sum_assn A' B') e e' \\<Longrightarrow>\\<^sub>t hn_ctxt (sum_assn Am Bm) e e'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_ctxt (A +\\<^sub>a B) e e' \\<or>\\<^sub>A\n    hn_ctxt (A' +\\<^sub>a B') e e' \\<Longrightarrow>\\<^sub>t\n    hn_ctxt (Am +\\<^sub>a Bm) e e'", "apply (rule entt_disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. hn_ctxt (A +\\<^sub>a B) e e' \\<Longrightarrow>\\<^sub>t\n    hn_ctxt (Am +\\<^sub>a Bm) e e'\n 2. hn_ctxt (A' +\\<^sub>a B') e e' \\<Longrightarrow>\\<^sub>t\n    hn_ctxt (Am +\\<^sub>a Bm) e e'", "apply (rule sum_match_cong)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>e = Inl x; e' = Inl y\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt A x y \\<Longrightarrow>\\<^sub>t\n                         hn_ctxt Am x y\n 2. \\<And>x y.\n       \\<lbrakk>e = Inr x; e' = Inr y\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt B x y \\<Longrightarrow>\\<^sub>t\n                         hn_ctxt Bm x y\n 3. hn_ctxt (A' +\\<^sub>a B') e e' \\<Longrightarrow>\\<^sub>t\n    hn_ctxt (Am +\\<^sub>a Bm) e e'", "apply (rule entt_disjD1[OF assms(1)]; simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>e = Inr x; e' = Inr y\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt B x y \\<Longrightarrow>\\<^sub>t\n                         hn_ctxt Bm x y\n 2. hn_ctxt (A' +\\<^sub>a B') e e' \\<Longrightarrow>\\<^sub>t\n    hn_ctxt (Am +\\<^sub>a Bm) e e'", "apply (rule entt_disjD1[OF assms(2)]; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_ctxt (A' +\\<^sub>a B') e e' \\<Longrightarrow>\\<^sub>t\n    hn_ctxt (Am +\\<^sub>a Bm) e e'", "apply (rule sum_match_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>e = Inl x; e' = Inl y\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt A' x y \\<Longrightarrow>\\<^sub>t\n                         hn_ctxt Am x y\n 2. \\<And>x y.\n       \\<lbrakk>e = Inr x; e' = Inr y\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt B' x y \\<Longrightarrow>\\<^sub>t\n                         hn_ctxt Bm x y", "apply (rule entt_disjD2[OF assms(1)]; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>e = Inr x; e' = Inr y\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt B' x y \\<Longrightarrow>\\<^sub>t\n                         hn_ctxt Bm x y", "apply (rule entt_disjD2[OF assms(2)]; simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma entt_invalid_sum: \"hn_invalid (sum_assn A B) e e' \\<Longrightarrow>\\<^sub>t hn_ctxt (sum_assn (invalid_assn A) (invalid_assn B)) e e'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_invalid (A +\\<^sub>a B) e e' \\<Longrightarrow>\\<^sub>t\n    hn_ctxt (invalid_assn A +\\<^sub>a invalid_assn B) e e'", "apply (simp add: hn_ctxt_def invalid_assn_def[abs_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<up>\n     (\\<exists>a b.\n         (a, b) \\<Turnstile> (A +\\<^sub>a B) e e') \\<Longrightarrow>\\<^sub>t\n    ((\\<lambda>x y.\n         \\<up> (\\<exists>a b. (a, b) \\<Turnstile> A x y) * true) +\\<^sub>a\n     (\\<lambda>x y. \\<up> (\\<exists>a b. (a, b) \\<Turnstile> B x y) * true))\n     e e'", "apply (rule enttI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<up>\n     (\\<exists>a b.\n         (a, b) \\<Turnstile> (A +\\<^sub>a B) e e') \\<Longrightarrow>\\<^sub>A\n    ((\\<lambda>x y.\n         \\<up> (\\<exists>a b. (a, b) \\<Turnstile> A x y) * true) +\\<^sub>a\n     (\\<lambda>x y. \\<up> (\\<exists>a b. (a, b) \\<Turnstile> B x y) * true))\n     e e' *\n    true", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<Turnstile> (A +\\<^sub>a B) e e' \\<Longrightarrow>\n       emp \\<Longrightarrow>\\<^sub>A\n       ((\\<lambda>x y.\n            \\<up> (\\<exists>a b. (a, b) \\<Turnstile> A x y) *\n            true) +\\<^sub>a\n        (\\<lambda>x y.\n            \\<up> (\\<exists>a b. (a, b) \\<Turnstile> B x y) * true))\n        e e' *\n       true", "apply (cases e; cases e'; auto simp: mod_star_conv pure_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas invalid_sum_merge[sepref_frame_merge_rules] = gen_merge_cons[OF entt_invalid_sum]"], ["", "sepref_register Inr Inl"], ["", "lemma [sepref_fr_rules]: \"(return o Inl,RETURN o Inl) \\<in> A\\<^sup>d \\<rightarrow>\\<^sub>a sum_assn A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (return \\<circ> Inl, RETURN \\<circ> Inl)\n    \\<in> A\\<^sup>d \\<rightarrow>\\<^sub>a A +\\<^sub>a B", "by sepref_to_hoare sep_auto"], ["", "lemma [sepref_fr_rules]: \"(return o Inr,RETURN o Inr) \\<in> B\\<^sup>d \\<rightarrow>\\<^sub>a sum_assn A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (return \\<circ> Inr, RETURN \\<circ> Inr)\n    \\<in> B\\<^sup>d \\<rightarrow>\\<^sub>a A +\\<^sub>a B", "by sepref_to_hoare sep_auto"], ["", "sepref_register case_sum"], ["", "text \\<open>In the monadify phase, this eta-expands to make visible all required arguments\\<close>"], ["", "lemma [sepref_monadify_arity]: \"case_sum \\<equiv> \\<lambda>\\<^sub>2f1 f2 x. SP case_sum$(\\<lambda>\\<^sub>2x. f1$x)$(\\<lambda>\\<^sub>2x. f2$x)$x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case_sum \\<equiv>\n    \\<lambda>x.\n       (#\\<lambda>xa.\n            (#\\<lambda>xb.\n                 (#SP case_sum $ (\\<lambda>xa. (#x $ xa#)) $\n                   (\\<lambda>x. (#xa $ x#)) $\n                   xb#)#)#)", "by simp"], ["", "text \\<open>This determines an evaluation order for the first-order operands\\<close>"], ["", "lemma [sepref_monadify_comb]: \"case_sum$f1$f2$x \\<equiv> (\\<bind>) $(EVAL$x)$(\\<lambda>\\<^sub>2x. SP case_sum$f1$f2$x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case_sum $ f1 $ f2 $ x \\<equiv>\n    (\\<bind>) $ (EVAL $ x) $ (\\<lambda>x. (#SP case_sum $ f1 $ f2 $ x#))", "by simp"], ["", "text \\<open>This enables translation of the case-distinction in a non-monadic context.\\<close>"], ["", "lemma [sepref_monadify_comb]: \"EVAL$(case_sum$(\\<lambda>\\<^sub>2x. f1 x)$(\\<lambda>\\<^sub>2x. f2 x)$x) \n  \\<equiv> (\\<bind>) $(EVAL$x)$(\\<lambda>\\<^sub>2x. SP case_sum$(\\<lambda>\\<^sub>2x. EVAL $ f1 x)$(\\<lambda>\\<^sub>2x. EVAL $ f2 x)$x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. EVAL $\n    (case_sum $ (\\<lambda>x. (#f1 x#)) $ (\\<lambda>x. (#f2 x#)) $\n     x) \\<equiv>\n    (\\<bind>) $ (EVAL $ x) $\n    (\\<lambda>x.\n        (#SP case_sum $ (\\<lambda>x. (#EVAL $ f1 x#)) $\n          (\\<lambda>x. (#EVAL $ f2 x#)) $\n          x#))", "apply (rule eq_reflection)"], ["proof (prove)\ngoal (1 subgoal):\n 1. EVAL $\n    (case_sum $ (\\<lambda>x. (#f1 x#)) $ (\\<lambda>x. (#f2 x#)) $ x) =\n    (\\<bind>) $ (EVAL $ x) $\n    (\\<lambda>x.\n        (#SP case_sum $ (\\<lambda>x. (#EVAL $ f1 x#)) $\n          (\\<lambda>x. (#EVAL $ f2 x#)) $\n          x#))", "by (simp split: sum.splits)"], ["", "text \\<open>Auxiliary lemma, to lift simp-rule over \\<open>hn_ctxt\\<close>\\<close>"], ["", "lemma sum_assn_ctxt: \"sum_assn A B x y = z \\<Longrightarrow> hn_ctxt (sum_assn A B) x y = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A +\\<^sub>a B) x y = z \\<Longrightarrow>\n    hn_ctxt (A +\\<^sub>a B) x y = z", "by (simp add: hn_ctxt_def)"], ["", "text \\<open>The cases lemma first extracts the refinement for the datatype from the precondition.\n  Next, it generate proof obligations to refine the functions for every case. \n  Finally the postconditions of the refinement are merged. \n\n  Note that we handle the\n  destructed values separately, to allow reconstruction of the original datatype after the case-expression.\n\n  Moreover, we provide (invalidated) versions of the original compound value to the cases,\n  which allows access to pure compound values from inside the case.\n  \\<close>"], ["", "lemma sum_cases_hnr:\n  fixes A B e e'\n  defines [simp]: \"INVe \\<equiv> hn_invalid (sum_assn A B) e e'\"\n  assumes FR: \"\\<Gamma> \\<Longrightarrow>\\<^sub>t hn_ctxt (sum_assn A B) e e' * F\"\n  assumes E1: \"\\<And>x1 x1a. \\<lbrakk>e = Inl x1; e' = Inl x1a\\<rbrakk> \\<Longrightarrow> hn_refine (hn_ctxt A x1 x1a * INVe * F) (f1' x1a) (hn_ctxt A' x1 x1a * hn_ctxt XX1 e e' * \\<Gamma>1') R (f1 x1)\"\n  assumes E2: \"\\<And>x2 x2a. \\<lbrakk>e = Inr x2; e' = Inr x2a\\<rbrakk> \\<Longrightarrow> hn_refine (hn_ctxt B x2 x2a * INVe * F) (f2' x2a) (hn_ctxt B' x2 x2a * hn_ctxt XX2 e e' * \\<Gamma>2') R (f2 x2)\"\n  assumes MERGE[unfolded hn_ctxt_def]: \"\\<Gamma>1' \\<or>\\<^sub>A \\<Gamma>2' \\<Longrightarrow>\\<^sub>t \\<Gamma>'\"\n  shows \"hn_refine \\<Gamma> (case_sum f1' f2' e') (hn_ctxt (sum_assn A' B') e e' * \\<Gamma>') R (case_sum$(\\<lambda>\\<^sub>2x. f1 x)$(\\<lambda>\\<^sub>2x. f2 x)$e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine \\<Gamma>\n     (case e' of Inl x \\<Rightarrow> f1' x | Inr x \\<Rightarrow> f2' x)\n     (hn_ctxt (A' +\\<^sub>a B') e e' * \\<Gamma>') R\n     (case_sum $ (\\<lambda>x. (#f1 x#)) $ (\\<lambda>x. (#f2 x#)) $ e)", "apply (rule hn_refine_cons_pre[OF FR])"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt (A +\\<^sub>a B) e e' * F)\n     (case e' of Inl x \\<Rightarrow> f1' x | Inr x \\<Rightarrow> f2' x)\n     (hn_ctxt (A' +\\<^sub>a B') e e' * \\<Gamma>') R\n     (case_sum $ (\\<lambda>x. (#f1 x#)) $ (\\<lambda>x. (#f2 x#)) $ e)", "apply1 extract_hnr_invalids"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h h1 h2.\n       \\<lbrakk>h2 \\<Turnstile> F;\n        hn_invalid (A +\\<^sub>a B) e e' = true\\<rbrakk>\n       \\<Longrightarrow> hn_refine (hn_ctxt (A +\\<^sub>a B) e e' * F)\n                          (case e' of Inl x \\<Rightarrow> f1' x\n                           | Inr x \\<Rightarrow> f2' x)\n                          (hn_ctxt (A' +\\<^sub>a B') e e' * \\<Gamma>') R\n                          (case_sum $ (\\<lambda>x. (#f1 x#)) $\n                           (\\<lambda>x. (#f2 x#)) $\n                           e)", "apply (cases e; cases e'; simp add: sum_assn.simps[THEN sum_assn_ctxt])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>h2 a aa.\n       \\<lbrakk>h2 \\<Turnstile> F;\n        hn_invalid (A +\\<^sub>a B) (Inl a) (Inl aa) = true; e = Inl a;\n        e' = Inl aa\\<rbrakk>\n       \\<Longrightarrow> hn_refine (A a aa * F) (f1' aa)\n                          (A' a aa * \\<Gamma>') R (f1 a)\n 2. \\<And>h2 b ba.\n       \\<lbrakk>h2 \\<Turnstile> F;\n        hn_invalid (A +\\<^sub>a B) (Inr b) (Inr ba) = true; e = Inr b;\n        e' = Inr ba\\<rbrakk>\n       \\<Longrightarrow> hn_refine (B b ba * F) (f2' ba)\n                          (B' b ba * \\<Gamma>') R (f2 b)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (A +\\<^sub>a B) (Inl a_) (Inl aa_) = true; e = Inl a_;\n     e' = Inl aa_\\<rbrakk>\n    \\<Longrightarrow> hn_refine (A a_ aa_ * F) (f1' aa_)\n                       (A' a_ aa_ * \\<Gamma>') R (f1 a_)", "apply (rule hn_refine_cons[OF _ E1 _ entt_refl]; assumption?)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (A +\\<^sub>a B) (Inl a_) (Inl aa_) = true; e = Inl a_;\n     e' = Inl aa_\\<rbrakk>\n    \\<Longrightarrow> A a_ aa_ * F \\<Longrightarrow>\\<^sub>t\n                      hn_ctxt A a_ aa_ * INVe * F\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (A +\\<^sub>a B) (Inl a_) (Inl aa_) = true; e = Inl a_;\n     e' = Inl aa_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt A' a_ aa_ * hn_ctxt XX1 e e' *\n                      \\<Gamma>1' \\<Longrightarrow>\\<^sub>t\n                      A' a_ aa_ * \\<Gamma>'", "applyS (simp add: hn_ctxt_def) \\<comment> \\<open>Match precondition for case, get \\<open>enum_assn\\<close> from assumption generated by \\<open>extract_hnr_invalids\\<close>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (A +\\<^sub>a B) (Inl a_) (Inl aa_) = true; e = Inl a_;\n     e' = Inl aa_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt A' a_ aa_ * hn_ctxt XX1 e e' *\n                      \\<Gamma>1' \\<Longrightarrow>\\<^sub>t\n                      A' a_ aa_ * \\<Gamma>'", "apply (rule entt_star_mono) \\<comment> \\<open>Split postcondition into pairs for compounds and frame, drop \\<open>hn_ctxt XX\\<close>\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (A +\\<^sub>a B) (Inl a_) (Inl aa_) = true; e = Inl a_;\n     e' = Inl aa_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt A' a_ aa_ *\n                      hn_ctxt XX1 e e' \\<Longrightarrow>\\<^sub>t\n                      A' a_ aa_\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (A +\\<^sub>a B) (Inl a_) (Inl aa_) = true; e = Inl a_;\n     e' = Inl aa_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>1' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "apply1 (rule entt_fr_drop)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (A +\\<^sub>a B) (Inl a_) (Inl aa_) = true; e = Inl a_;\n     e' = Inl aa_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt A' a_ aa_ \\<Longrightarrow>\\<^sub>t A' a_ aa_\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (A +\\<^sub>a B) (Inl a_) (Inl aa_) = true; e = Inl a_;\n     e' = Inl aa_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>1' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "applyS (simp add: hn_ctxt_def entt_disjI1' entt_disjI2')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (A +\\<^sub>a B) (Inl a_) (Inl aa_) = true; e = Inl a_;\n     e' = Inl aa_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>1' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "apply1 (rule entt_trans[OF _ MERGE])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (A +\\<^sub>a B) (Inl a_) (Inl aa_) = true; e = Inl a_;\n     e' = Inl aa_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>1' \\<Longrightarrow>\\<^sub>t\n                      \\<Gamma>1' \\<or>\\<^sub>A \\<Gamma>2'", "applyS (simp add: entt_disjI1' entt_disjI2')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h2 b ba.\n       \\<lbrakk>h2 \\<Turnstile> F;\n        hn_invalid (A +\\<^sub>a B) (Inr b) (Inr ba) = true; e = Inr b;\n        e' = Inr ba\\<rbrakk>\n       \\<Longrightarrow> hn_refine (B b ba * F) (f2' ba)\n                          (B' b ba * \\<Gamma>') R (f2 b)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (A +\\<^sub>a B) (Inr b_) (Inr ba_) = true; e = Inr b_;\n     e' = Inr ba_\\<rbrakk>\n    \\<Longrightarrow> hn_refine (B b_ ba_ * F) (f2' ba_)\n                       (B' b_ ba_ * \\<Gamma>') R (f2 b_)", "apply (rule hn_refine_cons[OF _ E2 _ entt_refl]; assumption?)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (A +\\<^sub>a B) (Inr b_) (Inr ba_) = true; e = Inr b_;\n     e' = Inr ba_\\<rbrakk>\n    \\<Longrightarrow> B b_ ba_ * F \\<Longrightarrow>\\<^sub>t\n                      hn_ctxt B b_ ba_ * INVe * F\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (A +\\<^sub>a B) (Inr b_) (Inr ba_) = true; e = Inr b_;\n     e' = Inr ba_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt B' b_ ba_ * hn_ctxt XX2 e e' *\n                      \\<Gamma>2' \\<Longrightarrow>\\<^sub>t\n                      B' b_ ba_ * \\<Gamma>'", "applyS (simp add: hn_ctxt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (A +\\<^sub>a B) (Inr b_) (Inr ba_) = true; e = Inr b_;\n     e' = Inr ba_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt B' b_ ba_ * hn_ctxt XX2 e e' *\n                      \\<Gamma>2' \\<Longrightarrow>\\<^sub>t\n                      B' b_ ba_ * \\<Gamma>'", "apply (rule entt_star_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (A +\\<^sub>a B) (Inr b_) (Inr ba_) = true; e = Inr b_;\n     e' = Inr ba_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt B' b_ ba_ *\n                      hn_ctxt XX2 e e' \\<Longrightarrow>\\<^sub>t\n                      B' b_ ba_\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (A +\\<^sub>a B) (Inr b_) (Inr ba_) = true; e = Inr b_;\n     e' = Inr ba_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>2' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "apply1 (rule entt_fr_drop)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (A +\\<^sub>a B) (Inr b_) (Inr ba_) = true; e = Inr b_;\n     e' = Inr ba_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt B' b_ ba_ \\<Longrightarrow>\\<^sub>t B' b_ ba_\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (A +\\<^sub>a B) (Inr b_) (Inr ba_) = true; e = Inr b_;\n     e' = Inr ba_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>2' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "applyS (simp add: hn_ctxt_def entt_disjI1' entt_disjI2')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (A +\\<^sub>a B) (Inr b_) (Inr ba_) = true; e = Inr b_;\n     e' = Inr ba_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>2' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "apply1 (rule entt_trans[OF _ MERGE])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (A +\\<^sub>a B) (Inr b_) (Inr ba_) = true; e = Inr b_;\n     e' = Inr ba_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>2' \\<Longrightarrow>\\<^sub>t\n                      \\<Gamma>1' \\<or>\\<^sub>A \\<Gamma>2'", "applyS (simp add: entt_disjI1' entt_disjI2')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>After some more preprocessing (adding extra frame-rules for non-atomic postconditions, \n  and splitting the merge-terms into binary merges), this rule can be registered\\<close>"], ["", "lemmas [sepref_comb_rules] = sum_cases_hnr[sepref_prep_comb_rule]"], ["", "sepref_register isl projl projr"], ["", "lemma isl_hnr[sepref_fr_rules]: \"(return o isl,RETURN o isl) \\<in> (sum_assn A B)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (return \\<circ> isl, RETURN \\<circ> isl)\n    \\<in> (A +\\<^sub>a B)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "apply sepref_to_hoare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xi.\n       \\<lbrakk>x ::\\<^sub>i TYPE('c + 'd); nofail (RETURN (isl x))\\<rbrakk>\n       \\<Longrightarrow> <(A +\\<^sub>a B) x\n                           xi> return\n                                (isl xi) <\\<lambda>r.\n       (A +\\<^sub>a B) x xi *\n       (\\<exists>\\<^sub>Axa.\n           \\<up> ((r, xa) \\<in> bool_rel) *\n           \\<up> (RETURN xa \\<le> RETURN (isl x)))>\\<^sub>t", "subgoal for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a ::\\<^sub>i TYPE('c + 'd); nofail (RETURN (isl a))\\<rbrakk>\n    \\<Longrightarrow> <(A +\\<^sub>a B) a\n                        b> return\n                            (isl b) <\\<lambda>r.\n  (A +\\<^sub>a B) a b *\n  (\\<exists>\\<^sub>Ax.\n      \\<up> ((r, x) \\<in> bool_rel) *\n      \\<up> (RETURN x \\<le> RETURN (isl a)))>\\<^sub>t", "by (cases a; cases b; sep_auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma projl_hnr[sepref_fr_rules]: \"(return o projl,RETURN o projl) \\<in> [isl]\\<^sub>a (sum_assn A B)\\<^sup>d \\<rightarrow> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (return \\<circ> projl, RETURN \\<circ> projl)\n    \\<in> [isl]\\<^sub>a (A +\\<^sub>a B)\\<^sup>d \\<rightarrow> A", "apply sepref_to_hoare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xi.\n       \\<lbrakk>isl x; x ::\\<^sub>i TYPE('c + 'd);\n        nofail (RETURN (projl x))\\<rbrakk>\n       \\<Longrightarrow> <(A +\\<^sub>a B) x\n                           xi> return\n                                (projl\n                                  xi) <\\<lambda>r.\n    true *\n    (\\<exists>\\<^sub>Axa.\n        A xa r * \\<up> (RETURN xa \\<le> RETURN (projl x)))>\\<^sub>t", "subgoal for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>isl a; a ::\\<^sub>i TYPE('c + 'd);\n     nofail (RETURN (projl a))\\<rbrakk>\n    \\<Longrightarrow> <(A +\\<^sub>a B) a\n                        b> return\n                            (projl\n                              b) <\\<lambda>r.\n                                     true *\n                                     (\\<exists>\\<^sub>Ax.\n   A x r * \\<up> (RETURN x \\<le> RETURN (projl a)))>\\<^sub>t", "by (cases a; cases b; sep_auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma projr_hnr[sepref_fr_rules]: \"(return o projr,RETURN o projr) \\<in> [Not o isl]\\<^sub>a (sum_assn A B)\\<^sup>d \\<rightarrow> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (return \\<circ> projr, RETURN \\<circ> projr)\n    \\<in> [Not \\<circ> isl]\\<^sub>a (A +\\<^sub>a B)\\<^sup>d \\<rightarrow> B", "apply sepref_to_hoare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xi.\n       \\<lbrakk>(Not \\<circ> isl) x; x ::\\<^sub>i TYPE('c + 'd);\n        nofail (RETURN (projr x))\\<rbrakk>\n       \\<Longrightarrow> <(A +\\<^sub>a B) x\n                           xi> return\n                                (projr\n                                  xi) <\\<lambda>r.\n    true *\n    (\\<exists>\\<^sub>Axa.\n        B xa r * \\<up> (RETURN xa \\<le> RETURN (projr x)))>\\<^sub>t", "subgoal for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(Not \\<circ> isl) a; a ::\\<^sub>i TYPE('c + 'd);\n     nofail (RETURN (projr a))\\<rbrakk>\n    \\<Longrightarrow> <(A +\\<^sub>a B) a\n                        b> return\n                            (projr\n                              b) <\\<lambda>r.\n                                     true *\n                                     (\\<exists>\\<^sub>Ax.\n   B x r * \\<up> (RETURN x \\<le> RETURN (projr a)))>\\<^sub>t", "by (cases a; cases b; sep_auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>String Literals\\<close>"], ["", "sepref_register \"PR_CONST String.empty_literal\""], ["", "lemma empty_literal_hnr [sepref_import_param]:\n  \"(String.empty_literal, PR_CONST String.empty_literal) \\<in> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (STR '''', PR_CONST STR '''') \\<in> Id", "by simp"], ["", "lemma empty_literal_pat [def_pat_rules]:\n  \"String.empty_literal \\<equiv> UNPROTECT String.empty_literal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. STR '''' \\<equiv> UNPROTECT STR ''''", "by simp"], ["", "context\n  fixes b0 b1 b2 b3 b4 b5 b6 :: bool\n  and s :: String.literal\nbegin"], ["", "sepref_register \"PR_CONST (String.Literal b0 b1 b2 b3 b4 b5 b6 s)\""], ["", "lemma Literal_hnr [sepref_import_param]:\n  \"(String.Literal b0 b1 b2 b3 b4 b5 b6 s,\n    PR_CONST (String.Literal b0 b1 b2 b3 b4 b5 b6 s)) \\<in> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (String.Literal b0 b1 b2 b3 b4 b5 b6 s,\n     PR_CONST (String.Literal b0 b1 b2 b3 b4 b5 b6 s))\n    \\<in> Id", "by simp"], ["", "end"], ["", "lemma Literal_pat [def_pat_rules]:\n  \"String.Literal $ b0 $ b1 $ b2 $ b3 $ b4 $ b5 $ b6 $ s \\<equiv>\n    UNPROTECT (String.Literal $ b0 $ b1 $ b2 $ b3 $ b4 $ b5 $ b6 $ s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. String.Literal $ b0 $ b1 $ b2 $ b3 $ b4 $ b5 $ b6 $ s \\<equiv>\n    UNPROTECT (String.Literal $ b0 $ b1 $ b2 $ b3 $ b4 $ b5 $ b6 $ s)", "by simp"], ["", "end"]]}