{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/Userguides/Sepref_Guide_Reference.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemmas [sepref_fr_rules] = hm.empty_hnr[folded my_map_def]", "lemma my_fold_arity[sepref_monadify_arity]: \"my_fold \\<equiv> \\<lambda>\\<^sub>2f l s. SP my_fold$(\\<lambda>\\<^sub>2x s. f$x$s)$l$s\"", "lemma monadify_plain_my_fold[sepref_monadify_comb]: \n  \"EVAL$(my_fold$(\\<lambda>\\<^sub>2x s. f x s)$l$s) \\<equiv> (\\<bind>)$(EVAL$l)$(\\<lambda>\\<^sub>2l. (\\<bind>)$(EVAL$s)$(\\<lambda>\\<^sub>2s. nfoldli$l$(\\<lambda>\\<^sub>2_. True)$(\\<lambda>\\<^sub>2x s. EVAL$(f x s))$s))\""], "translations": [["", "lemmas [sepref_fr_rules] = hm.empty_hnr[folded my_map_def]"], ["", "sepref_thm my_map_example is \"uncurry0 (RETURN (my_map(False\\<mapsto>1)))\" :: \"unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a hm.assn bool_assn nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2, uncurry0 (RETURN (my_map(False \\<mapsto> 1))))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a hm.assn bool_assn nat_assn", "apply sepref_dbg_keep"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow>\n       hn_refine emp (?c19 x xi) (?\\<Gamma>'6 x xi) (?R6 x xi)\n        ((\\<bind>) $ (RETURN $ my_map) $\n         (\\<lambda>v0.\n             (#(\\<bind>) $ (RETURN $ False) $\n               (\\<lambda>v1.\n                   (#(\\<bind>) $\n                     ((\\<bind>) $ (RETURN $ 1) $\n                      (\\<lambda>v0. (#RETURN $ (Some $ v0)#))) $\n                     (\\<lambda>v2.\n                         (#RETURN $ (fun_upd $ v0 $ v1 $ v2)#))#))#)))\n 2. \\<And>x xi.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow> CNV (?c19 x xi) ?f5\n 3. \\<And>x xi.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow>\n       ?\\<Gamma>'6 x xi \\<Longrightarrow>\\<^sub>t emp\n 4. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow>\n       hn_ctxt (?R6 x xi) a c \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (hm.assn bool_assn nat_assn) a c\n 5. CONSTRAINT_SLOT (True)", "apply sepref_dbg_trans_keep\n  \\<comment> \\<open>Stuck at refinement for function update on map\\<close>"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x xi v0 x' v1 x'a v2 x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(unit); bind_ref_tag v0 (RETURN $ my_map);\n        bind_ref_tag v1 (RETURN $ False);\n        bind_ref_tag v2\n         ((\\<bind>) $ (RETURN $ 1) $\n          (\\<lambda>v0. (#RETURN $ (Some $ v0)#)))\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (hm.assn (?K57 x xi) (?V58 x xi)) v0 x' *\n                           hn_val bool_rel v1 x'a *\n                           hn_ctxt (option_assn nat_assn) v2 x'b)\n                          (?f'37 x xi x' x'a x'b)\n                          (?\\<Gamma>2.35 x xi v0 x' v1 x'a v2 x'b)\n                          (?R6 x xi) (RETURN $ (fun_upd $ v0 $ v1 $ v2))\n 2. \\<And>x xi v0 x' v1 x'a v2 x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(unit); bind_ref_tag v0 (RETURN $ my_map);\n        bind_ref_tag v1 (RETURN $ False)\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.35 x xi v0 x' v1 x'a v2\n                          x'b \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.26 x xi v0 x' v1 x'a *\n                         hn_ctxt (?Rx35 x xi v0 x' v1 x'a) v2 x'b\n 3. \\<And>x xi v0 x' v1 x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(unit);\n        bind_ref_tag v0 (RETURN $ my_map)\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.26 x xi v0 x' v1\n                          x'a \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.20 x xi v0 x' *\n                         hn_ctxt (?Rx26 x xi v0 x') v1 x'a\n 4. \\<And>x xi v0 x'.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow>\n       ?\\<Gamma>2.20 x xi v0 x' \\<Longrightarrow>\\<^sub>t\n       ?\\<Gamma>'6 x xi * hn_ctxt (?Rx20 x xi) v0 x'\n 5. \\<And>x xi.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow>\n       CNV (hm_new \\<bind>\n            (\\<lambda>x'.\n                return False \\<bind>\n                (\\<lambda>x'a.\n                    return 1 \\<bind>\n                    (\\<lambda>x'b. return (Some x'b)) \\<bind>\n                    ?f'37 x xi x' x'a)))\n        ?f5\n 6. \\<And>x xi.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow>\n       ?\\<Gamma>'6 x xi \\<Longrightarrow>\\<^sub>t emp\n 7. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow>\n       hn_ctxt (?R6 x xi) a c \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (hm.assn bool_assn nat_assn) a c\n 8. CONSTRAINT_SLOT (True)", "oops"], ["", "text \\<open>Solution: Register with correct interface type\\<close>"], ["", "sepref_register my_map :: \"('k,'v) i_map\""], ["", "sepref_thm my_map_example is \"uncurry0 (RETURN (my_map(False\\<mapsto>1)))\" :: \"unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a hm.assn bool_assn nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2, uncurry0 (RETURN (my_map(False \\<mapsto> 1))))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a hm.assn bool_assn nat_assn", "by sepref"], ["", "subsubsection \\<open>Monadify Phase\\<close>"], ["", "text \\<open>\n  The monadify phase rewrites the program such that every operation becomes \n  visible on the monad level, that is, nested HOL-expressions are flattened.\n  Also combinators (e.g. if, fold, case) may get flattened, if special rules \n  are registered for that.\n\n  Moreover, the monadify phase fixes the number of operands applied to an operation,\n  using eta-expansion to add missing operands. \n\n  Finally, the monadify phase handles duplicate parameters to an operation, by\n  inserting a @{const COPY} tag. This is necessary as our tool expects the \n  parameters of a function to be separate, even for read-only \n  parameters@{footnote \\<open>Using fractional permissions or some other more fine grained\n    ownership model might lift this restriction in the future.\\<close>}. \n\\<close>"], ["", "text \\<open>The monadify phase consists of a number of sub-phases.\n  The method @{method sepref_dbg_monadify} executes the monadify phase,\n  the method @{method sepref_dbg_monadify_keep} stops at a failing sub-phase\n  and presents the internal goal state before the failing sub-phase.\n\\<close>"], ["", "subsubsection \\<open>Monadify: Arity\\<close>"], ["", "text \\<open>In the first sub-phase, the rules from @{attribute sepref_monadify_arity} \n  are used to standardize the number of operands applied to a constant.\n  The rules work by rewriting each constant to a lambda-expression with the \n  desired number of arguments, and the using beta-reduction to account for\n  already existing arguments. Also higher-order arguments can be enforced,\n  for example, the rule for fold enforces three arguments, the function itself\n  having two arguments (@{thm fold_arity}).\n\n  In order to prevent arity rules being applied infinitely often, \n  the @{const SP} tag can be used on the RHS. It prevents anything inside \n  from being changed, and gets removed after the arity step.\n\n  The method @{method sepref_dbg_monadify_arity} gives you direct access to this phase.\n\n  In the Sepref-tool, we use the terminology @{emph \\<open>operator/operation\\<close>} for a function that\n  only has first-order arguments, which are evaluated before the function is applied (e.g. @{term \"(+)\"}),\n  and @{emph \\<open>combinator\\<close>} for operations with higher-order arguments or custom \n  evaluation orders (e.g. @{term \"fold\"}, @{term \"If\"}).\n\n  Note: In practice, most arity (and combinator) rules are declared automatically\n    by @{command sepref_register} or @{command sepref_decl_op}. Manual declaration\n    is only required for higher-order functions.\n\\<close>"], ["", "thm sepref_monadify_arity"], ["", "subsubsection \\<open>Monadify: Combinators\\<close>"], ["", "text \\<open>The second sub-phase flattens the term. \n  It has a rule for every function into @{typ \"_ nres\"} type, that determines\n  the evaluation order of the arguments. First-order arguments are evaluated before\n  an operation is applied. Higher-order arguments are treated specially, as they\n  are evaluated during executing the (combinator) operation. The rules are in\n  @{attribute sepref_monadify_comb}.\n\n  Evaluation of plain (non-monadic) terms is triggered by wrapping them into\n  the @{const EVAL} tag. The @{attribute sepref_monadify_comb} rules may also contain\n  rewrite-rules for the @{const EVAL} tag, for example to unfold plain combinators\n  into the monad (e.g. @{thm dflt_plain_comb}). If no such rule applies, the \n  default method is to interpret the head of the term as a function, and recursively\n  evaluate the arguments, using left-to-right evaluation order. The head of \n  a term inside @{const EVAL} must not be an abstraction. Otherwise, the \n  @{const EVAL} tag remains in the term, and the next sub-phase detects this \n  and fails.\n\n  The method @{method sepref_dbg_monadify_comb} executes the combinator-phase \n  in isolation.\n\\<close>"], ["", "subsubsection \\<open>Monadify: Check-Eval\\<close>"], ["", "text \\<open>This phase just checks for remaining @{const EVAL} tags in the term,\n  and fails if there are such tags. The method @{method sepref_dbg_monadify_check_EVAL}\n  gives direct access to this phase.\n\n  Remaining @{const EVAL} tags indicate\n  higher-order functions without an appropriate setup of the combinator-rules\n  being used. For example:\n\\<close>"], ["", "definition \"my_fold \\<equiv> fold\""], ["", "sepref_thm my_fold_test is \"\\<lambda>l. do { RETURN (my_fold (\\<lambda>x y. x+y*2) l 0)}\" :: \"(list_assn nat_assn)\\<^sup>k\\<rightarrow>\\<^sub>anat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, \\<lambda>l. RETURN (my_fold (\\<lambda>x y. x + y * 2) l 0))\n    \\<in> (list_assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "apply sepref_dbg_keep"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_refine (hn_ctxt (list_assn nat_assn) x xi) (?fi4 xi)\n        (?\\<Gamma>'5 x xi) (?R5 x xi)\n        (RETURN $\n         (my_fold $\n          (\\<lambda>x.\n              (#\\<lambda>xa. (#(+) $ x $ ((*) $ xa $ PR_CONST 2)#)#)) $\n          x $\n          0))\n 2. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn nat_assn) x xi\n 3. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (?R5 x xi) a c \\<Longrightarrow>\\<^sub>t hn_val nat_rel a c\n 4. CONSTRAINT_SLOT (True)", "apply sepref_dbg_monadify_keep\n  \\<comment> \\<open>An \\<open>EVAL\\<close>-tag with an abstraction remains. This is b/c the default heuristics\n    tries to interpret the function inside the fold as a plain value argument.\\<close>"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_refine (hn_ctxt (list_assn nat_assn) x xi) (?fi4 xi)\n        (?\\<Gamma>'5 x xi) (?R5 x xi)\n        ((\\<bind>) $\n         ((\\<bind>) $\n          (EVAL $\n           (\\<lambda>x.\n               (#\\<lambda>xa. (#(+) $ x $ ((*) $ xa $ PR_CONST 2)#)#))) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $ (RETURN $ x) $\n                (\\<lambda>v1.\n                    (#(\\<bind>) $ (RETURN $ 0) $\n                      (\\<lambda>v2.\n                          (#RETURN $ (my_fold $ v0 $ v1 $ v2)#))#))#))) $\n         (\\<lambda>x. (#RETURN $ x#)))\n 2. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn nat_assn) x xi\n 3. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (?R5 x xi) a c \\<Longrightarrow>\\<^sub>t hn_val nat_rel a c\n 4. CONSTRAINT_SLOT (True)", "oops"], ["", "text \\<open>Solution: Register appropriate arity and combinator-rules\\<close>"], ["", "lemma my_fold_arity[sepref_monadify_arity]: \"my_fold \\<equiv> \\<lambda>\\<^sub>2f l s. SP my_fold$(\\<lambda>\\<^sub>2x s. f$x$s)$l$s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. my_fold \\<equiv>\n    \\<lambda>x.\n       (#\\<lambda>xa.\n            (#\\<lambda>xb.\n                 (#SP my_fold $\n                   (\\<lambda>xa. (#\\<lambda>xb. (#x $ xa $ xb#)#)) $\n                   xa $\n                   xb#)#)#)", "by auto"], ["", "text \\<open>The combinator-rule rewrites to the already existing and set up combinator @{term nfoldli}:\\<close>"], ["", "lemma monadify_plain_my_fold[sepref_monadify_comb]: \n  \"EVAL$(my_fold$(\\<lambda>\\<^sub>2x s. f x s)$l$s) \\<equiv> (\\<bind>)$(EVAL$l)$(\\<lambda>\\<^sub>2l. (\\<bind>)$(EVAL$s)$(\\<lambda>\\<^sub>2s. nfoldli$l$(\\<lambda>\\<^sub>2_. True)$(\\<lambda>\\<^sub>2x s. EVAL$(f x s))$s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. EVAL $\n    (my_fold $ (\\<lambda>x. (#\\<lambda>xa. (#f x xa#)#)) $ l $ s) \\<equiv>\n    (\\<bind>) $ (EVAL $ l) $\n    (\\<lambda>x.\n        (#(\\<bind>) $ (EVAL $ s) $\n          (\\<lambda>xa.\n              (#nfoldli $ x $ (\\<lambda>x. (#True#)) $\n                (\\<lambda>x. (#\\<lambda>xa. (#EVAL $ f x xa#)#)) $\n                xa#))#))", "by (simp add: fold_eq_nfoldli my_fold_def)"], ["", "sepref_thm my_fold_test is \"\\<lambda>l. do { RETURN (my_fold (\\<lambda>x y. x+y*2) l 0)}\" :: \"(list_assn nat_assn)\\<^sup>k\\<rightarrow>\\<^sub>anat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, \\<lambda>l. RETURN (my_fold (\\<lambda>x y. x + y * 2) l 0))\n    \\<in> (list_assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "by sepref"], ["", "subsubsection \\<open>Monadify: Dup\\<close>"], ["", "text \\<open>The last three phases, \\<open>mark_params\\<close>, \\<open>dup\\<close>, \\<open>remove_pass\\<close> are to detect \n  duplicate parameters, and insert \\<open>COPY\\<close> tags. \n  The first phase, \\<open>mark_params\\<close>, adds @{const PASS} tags around all parameters.\n  Parameters are bound variables and terms that have a refinement in the \n  precondition.\n\n  The second phase detects duplicate parameters and inserts @{const COPY} tags\n  to remove them. Finally, the last phase removes the @{const PASS} tags again.\n\n  The methods @{method sepref_dbg_monadify_mark_params}, \n  @{method sepref_dbg_monadify_dup}, and @{method sepref_dbg_monadify_remove_pass}\n  gives you access to these phases.\n\\<close>"], ["", "subsubsection \\<open>Monadify: Step-Through Example\\<close>"], ["", "text \\<open>\n  We give an annotated example of the monadify phase.\n  Note that the program utilizes a few features of monadify:\n    \\<^item> The fold function is higher-order, and gets flattened\n    \\<^item> The first argument to fold is eta-contracted. The missing argument is added.\n    \\<^item> The multiplication uses the same argument twice. A copy-tag is inserted.\n\\<close>"], ["", "sepref_thm monadify_step_thru_test is \"\\<lambda>l. do {\n    let i = length l;\n    RETURN (fold (\\<lambda>x. (+) (x*x)) l i)\n  }\" :: \"(list_assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>l.\n        let i = length l in RETURN (fold (\\<lambda>x. (+) (x * x)) l i))\n    \\<in> (list_assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "apply sepref_dbg_preproc"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_refine (hn_ctxt (list_assn nat_assn) x xi) (?fi1 xi)\n        (hn_ctxt (list_assn nat_assn) x xi) nat_assn\n        (let i = length x in RETURN (fold (\\<lambda>x. (+) (x * x)) x i))\n 2. CONSTRAINT_SLOT (True)", "apply sepref_dbg_cons_init"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_refine (hn_ctxt (list_assn nat_assn) x xi) (?fi4 xi)\n        (?\\<Gamma>'5 x xi) (?R5 x xi)\n        (let i = length x in RETURN (fold (\\<lambda>x. (+) (x * x)) x i))\n 2. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn nat_assn) x xi\n 3. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (?R5 x xi) a c \\<Longrightarrow>\\<^sub>t hn_val nat_rel a c\n 4. CONSTRAINT_SLOT (True)", "apply sepref_dbg_id"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_refine (hn_ctxt (list_assn nat_assn) x xi) (?fi4 xi)\n        (?\\<Gamma>'5 x xi) (?R5 x xi)\n        (Let $ (op_list_length $ x) $\n         (\\<lambda>xa.\n             (#RETURN $\n               (fold $ (\\<lambda>x. (#(+) $ ((*) $ x $ x)#)) $ x $ xa)#)))\n 2. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn nat_assn) x xi\n 3. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (?R5 x xi) a c \\<Longrightarrow>\\<^sub>t hn_val nat_rel a c\n 4. CONSTRAINT_SLOT (True)", "apply sepref_dbg_monadify_arity \\<comment> \\<open>Second operand of fold-function is added\\<close>"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_refine (hn_ctxt (list_assn nat_assn) x xi) (?fi4 xi)\n        (?\\<Gamma>'5 x xi) (?R5 x xi)\n        (Let $ (op_list_length $ x) $\n         (\\<lambda>xa.\n             (#RETURN $\n               (fold $\n                (\\<lambda>x.\n                    (#\\<lambda>xa. (#(+) $ ((*) $ x $ x) $ xa#)#)) $\n                x $\n                xa)#)))\n 2. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn nat_assn) x xi\n 3. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (?R5 x xi) a c \\<Longrightarrow>\\<^sub>t hn_val nat_rel a c\n 4. CONSTRAINT_SLOT (True)", "apply sepref_dbg_monadify_comb \\<comment> \\<open>Flattened. \\<open>fold\\<close> rewritten to \\<open>monadic_nfoldli\\<close>.\\<close>"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_refine (hn_ctxt (list_assn nat_assn) x xi) (?fi4 xi)\n        (?\\<Gamma>'5 x xi) (?R5 x xi)\n        ((\\<bind>) $\n         ((\\<bind>) $ (RETURN $ x) $\n          (\\<lambda>v0. (#RETURN $ (op_list_length $ v0)#))) $\n         (\\<lambda>xa.\n             (#Let $ xa $\n               (\\<lambda>xa.\n                   (#(\\<bind>) $\n                     ((\\<bind>) $ (RETURN $ x) $\n                      (\\<lambda>x.\n                          (#(\\<bind>) $ (RETURN $ xa) $\n                            (\\<lambda>xa.\n                                (#(\\<bind>) $ (RETURN $ x) $\n                                  (\\<lambda>x.\n(#(\\<bind>) $ (RETURN $ xa) $\n  (\\<lambda>xa.\n      (#monadic_nfoldli $ x $ (\\<lambda>x. (#RETURN $ True#)) $\n        (\\<lambda>x.\n            (#\\<lambda>xa.\n                 (#(\\<bind>) $\n                   ((\\<bind>) $ (RETURN $ x) $\n                    (\\<lambda>v0.\n                        (#(\\<bind>) $ (RETURN $ x) $\n                          (\\<lambda>v1. (#RETURN $ ((*) $ v0 $ v1)#))#))) $\n                   (\\<lambda>v0.\n                       (#(\\<bind>) $ (RETURN $ xa) $\n                         (\\<lambda>v1.\n                             (#RETURN $ ((+) $ v0 $ v1)#))#))#)#)) $\n        xa#))#))#))#))) $\n                     (\\<lambda>x. (#RETURN $ x#))#))#)))\n 2. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn nat_assn) x xi\n 3. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (?R5 x xi) a c \\<Longrightarrow>\\<^sub>t hn_val nat_rel a c\n 4. CONSTRAINT_SLOT (True)", "(*apply (unfold APP_def PROTECT2_def) (* Make term readable for inspection*) *)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_refine (hn_ctxt (list_assn nat_assn) x xi) (?fi4 xi)\n        (?\\<Gamma>'5 x xi) (?R5 x xi)\n        ((\\<bind>) $\n         ((\\<bind>) $ (RETURN $ x) $\n          (\\<lambda>v0. (#RETURN $ (op_list_length $ v0)#))) $\n         (\\<lambda>xa.\n             (#Let $ xa $\n               (\\<lambda>xa.\n                   (#(\\<bind>) $\n                     ((\\<bind>) $ (RETURN $ x) $\n                      (\\<lambda>x.\n                          (#(\\<bind>) $ (RETURN $ xa) $\n                            (\\<lambda>xa.\n                                (#(\\<bind>) $ (RETURN $ x) $\n                                  (\\<lambda>x.\n(#(\\<bind>) $ (RETURN $ xa) $\n  (\\<lambda>xa.\n      (#monadic_nfoldli $ x $ (\\<lambda>x. (#RETURN $ True#)) $\n        (\\<lambda>x.\n            (#\\<lambda>xa.\n                 (#(\\<bind>) $\n                   ((\\<bind>) $ (RETURN $ x) $\n                    (\\<lambda>v0.\n                        (#(\\<bind>) $ (RETURN $ x) $\n                          (\\<lambda>v1. (#RETURN $ ((*) $ v0 $ v1)#))#))) $\n                   (\\<lambda>v0.\n                       (#(\\<bind>) $ (RETURN $ xa) $\n                         (\\<lambda>v1.\n                             (#RETURN $ ((+) $ v0 $ v1)#))#))#)#)) $\n        xa#))#))#))#))) $\n                     (\\<lambda>x. (#RETURN $ x#))#))#)))\n 2. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn nat_assn) x xi\n 3. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (?R5 x xi) a c \\<Longrightarrow>\\<^sub>t hn_val nat_rel a c\n 4. CONSTRAINT_SLOT (True)", "apply sepref_dbg_monadify_check_EVAL \\<comment> \\<open>No \\<open>EVAL\\<close> tags left\\<close>"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_refine (hn_ctxt (list_assn nat_assn) x xi) (?fi4 xi)\n        (?\\<Gamma>'5 x xi) (?R5 x xi)\n        ((\\<bind>) $\n         ((\\<bind>) $ (RETURN $ x) $\n          (\\<lambda>v0. (#RETURN $ (op_list_length $ v0)#))) $\n         (\\<lambda>xa.\n             (#Let $ xa $\n               (\\<lambda>xa.\n                   (#(\\<bind>) $\n                     ((\\<bind>) $ (RETURN $ x) $\n                      (\\<lambda>x.\n                          (#(\\<bind>) $ (RETURN $ xa) $\n                            (\\<lambda>xa.\n                                (#(\\<bind>) $ (RETURN $ x) $\n                                  (\\<lambda>x.\n(#(\\<bind>) $ (RETURN $ xa) $\n  (\\<lambda>xa.\n      (#monadic_nfoldli $ x $ (\\<lambda>x. (#RETURN $ True#)) $\n        (\\<lambda>x.\n            (#\\<lambda>xa.\n                 (#(\\<bind>) $\n                   ((\\<bind>) $ (RETURN $ x) $\n                    (\\<lambda>v0.\n                        (#(\\<bind>) $ (RETURN $ x) $\n                          (\\<lambda>v1. (#RETURN $ ((*) $ v0 $ v1)#))#))) $\n                   (\\<lambda>v0.\n                       (#(\\<bind>) $ (RETURN $ xa) $\n                         (\\<lambda>v1.\n                             (#RETURN $ ((+) $ v0 $ v1)#))#))#)#)) $\n        xa#))#))#))#))) $\n                     (\\<lambda>x. (#RETURN $ x#))#))#)))\n 2. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn nat_assn) x xi\n 3. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (?R5 x xi) a c \\<Longrightarrow>\\<^sub>t hn_val nat_rel a c\n 4. CONSTRAINT_SLOT (True)", "apply sepref_dbg_monadify_mark_params \\<comment> \\<open>Parameters marked by \\<open>PASS\\<close>. Note the multiplication \\<open>x*x\\<close>.\\<close>"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_refine (hn_ctxt (list_assn nat_assn) x xi) (?fi4 xi)\n        (?\\<Gamma>'5 x xi) (?R5 x xi)\n        ((\\<bind>) $\n         ((\\<bind>) $ (PASS $ x) $\n          (\\<lambda>v0. (#RETURN $ (op_list_length $ v0)#))) $\n         (\\<lambda>xa.\n             (#Let $ xa $\n               (\\<lambda>xa.\n                   (#(\\<bind>) $\n                     ((\\<bind>) $ (PASS $ x) $\n                      (\\<lambda>x.\n                          (#(\\<bind>) $ (PASS $ xa) $\n                            (\\<lambda>xa.\n                                (#(\\<bind>) $ (PASS $ x) $\n                                  (\\<lambda>x.\n(#(\\<bind>) $ (PASS $ xa) $\n  (\\<lambda>xa.\n      (#monadic_nfoldli $ x $ (\\<lambda>x. (#RETURN $ True#)) $\n        (\\<lambda>x.\n            (#\\<lambda>xa.\n                 (#(\\<bind>) $\n                   ((\\<bind>) $ (PASS $ x) $\n                    (\\<lambda>v0.\n                        (#(\\<bind>) $ (PASS $ x) $\n                          (\\<lambda>v1. (#RETURN $ ((*) $ v0 $ v1)#))#))) $\n                   (\\<lambda>v0.\n                       (#(\\<bind>) $ (PASS $ xa) $\n                         (\\<lambda>v1.\n                             (#RETURN $ ((+) $ v0 $ v1)#))#))#)#)) $\n        xa#))#))#))#))) $\n                     (\\<lambda>x. (#PASS $ x#))#))#)))\n 2. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn nat_assn) x xi\n 3. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (?R5 x xi) a c \\<Longrightarrow>\\<^sub>t hn_val nat_rel a c\n 4. CONSTRAINT_SLOT (True)", "(*apply (unfold APP_def PROTECT2_def) (* Make term readable for inspection*) *)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_refine (hn_ctxt (list_assn nat_assn) x xi) (?fi4 xi)\n        (?\\<Gamma>'5 x xi) (?R5 x xi)\n        ((\\<bind>) $\n         ((\\<bind>) $ (PASS $ x) $\n          (\\<lambda>v0. (#RETURN $ (op_list_length $ v0)#))) $\n         (\\<lambda>xa.\n             (#Let $ xa $\n               (\\<lambda>xa.\n                   (#(\\<bind>) $\n                     ((\\<bind>) $ (PASS $ x) $\n                      (\\<lambda>x.\n                          (#(\\<bind>) $ (PASS $ xa) $\n                            (\\<lambda>xa.\n                                (#(\\<bind>) $ (PASS $ x) $\n                                  (\\<lambda>x.\n(#(\\<bind>) $ (PASS $ xa) $\n  (\\<lambda>xa.\n      (#monadic_nfoldli $ x $ (\\<lambda>x. (#RETURN $ True#)) $\n        (\\<lambda>x.\n            (#\\<lambda>xa.\n                 (#(\\<bind>) $\n                   ((\\<bind>) $ (PASS $ x) $\n                    (\\<lambda>v0.\n                        (#(\\<bind>) $ (PASS $ x) $\n                          (\\<lambda>v1. (#RETURN $ ((*) $ v0 $ v1)#))#))) $\n                   (\\<lambda>v0.\n                       (#(\\<bind>) $ (PASS $ xa) $\n                         (\\<lambda>v1.\n                             (#RETURN $ ((+) $ v0 $ v1)#))#))#)#)) $\n        xa#))#))#))#))) $\n                     (\\<lambda>x. (#PASS $ x#))#))#)))\n 2. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn nat_assn) x xi\n 3. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (?R5 x xi) a c \\<Longrightarrow>\\<^sub>t hn_val nat_rel a c\n 4. CONSTRAINT_SLOT (True)", "apply sepref_dbg_monadify_dup \\<comment> \\<open>\\<open>COPY\\<close> tag inserted.\\<close>"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_refine (hn_ctxt (list_assn nat_assn) x xi) (?fi4 xi)\n        (?\\<Gamma>'5 x xi) (?R5 x xi)\n        ((\\<bind>) $\n         ((\\<bind>) $ (PASS $ x) $\n          (\\<lambda>v0. (#RETURN $ (op_list_length $ v0)#))) $\n         (\\<lambda>xa.\n             (#Let $ xa $\n               (\\<lambda>xa.\n                   (#(\\<bind>) $\n                     ((\\<bind>) $ (PASS $ x) $\n                      (\\<lambda>x.\n                          (#(\\<bind>) $ (PASS $ xa) $\n                            (\\<lambda>xa.\n                                (#(\\<bind>) $ (PASS $ x) $\n                                  (\\<lambda>x.\n(#(\\<bind>) $ (PASS $ xa) $\n  (\\<lambda>xa.\n      (#monadic_nfoldli $ x $ (\\<lambda>x. (#RETURN $ True#)) $\n        (\\<lambda>x.\n            (#\\<lambda>xa.\n                 (#(\\<bind>) $\n                   ((\\<bind>) $ (RETURN $ (COPY $ x)) $\n                    (\\<lambda>v0.\n                        (#(\\<bind>) $ (PASS $ x) $\n                          (\\<lambda>v1. (#RETURN $ ((*) $ v0 $ v1)#))#))) $\n                   (\\<lambda>v0.\n                       (#(\\<bind>) $ (PASS $ xa) $\n                         (\\<lambda>v1.\n                             (#RETURN $ ((+) $ v0 $ v1)#))#))#)#)) $\n        xa#))#))#))#))) $\n                     (\\<lambda>x. (#PASS $ x#))#))#)))\n 2. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn nat_assn) x xi\n 3. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (?R5 x xi) a c \\<Longrightarrow>\\<^sub>t hn_val nat_rel a c\n 4. CONSTRAINT_SLOT (True)", "(*apply (unfold APP_def PROTECT2_def) (* Make term readable for inspection*) *)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_refine (hn_ctxt (list_assn nat_assn) x xi) (?fi4 xi)\n        (?\\<Gamma>'5 x xi) (?R5 x xi)\n        ((\\<bind>) $\n         ((\\<bind>) $ (PASS $ x) $\n          (\\<lambda>v0. (#RETURN $ (op_list_length $ v0)#))) $\n         (\\<lambda>xa.\n             (#Let $ xa $\n               (\\<lambda>xa.\n                   (#(\\<bind>) $\n                     ((\\<bind>) $ (PASS $ x) $\n                      (\\<lambda>x.\n                          (#(\\<bind>) $ (PASS $ xa) $\n                            (\\<lambda>xa.\n                                (#(\\<bind>) $ (PASS $ x) $\n                                  (\\<lambda>x.\n(#(\\<bind>) $ (PASS $ xa) $\n  (\\<lambda>xa.\n      (#monadic_nfoldli $ x $ (\\<lambda>x. (#RETURN $ True#)) $\n        (\\<lambda>x.\n            (#\\<lambda>xa.\n                 (#(\\<bind>) $\n                   ((\\<bind>) $ (RETURN $ (COPY $ x)) $\n                    (\\<lambda>v0.\n                        (#(\\<bind>) $ (PASS $ x) $\n                          (\\<lambda>v1. (#RETURN $ ((*) $ v0 $ v1)#))#))) $\n                   (\\<lambda>v0.\n                       (#(\\<bind>) $ (PASS $ xa) $\n                         (\\<lambda>v1.\n                             (#RETURN $ ((+) $ v0 $ v1)#))#))#)#)) $\n        xa#))#))#))#))) $\n                     (\\<lambda>x. (#PASS $ x#))#))#)))\n 2. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn nat_assn) x xi\n 3. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (?R5 x xi) a c \\<Longrightarrow>\\<^sub>t hn_val nat_rel a c\n 4. CONSTRAINT_SLOT (True)", "apply sepref_dbg_monadify_remove_pass \\<comment> \\<open>\\<open>PASS\\<close> tag removed again\\<close>"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_refine (hn_ctxt (list_assn nat_assn) x xi) (?fi4 xi)\n        (?\\<Gamma>'5 x xi) (?R5 x xi)\n        ((\\<bind>) $ (RETURN $ (op_list_length $ x)) $\n         (\\<lambda>xa.\n             (#Let $ xa $\n               (\\<lambda>xa.\n                   (#monadic_nfoldli $ x $ (\\<lambda>x. (#RETURN $ True#)) $\n                     (\\<lambda>x.\n                         (#\\<lambda>xa.\n                              (#(\\<bind>) $\n                                ((\\<bind>) $ (RETURN $ (COPY $ x)) $\n                                 (\\<lambda>v0.\n                                     (#RETURN $ ((*) $ v0 $ x)#))) $\n                                (\\<lambda>v0.\n                                    (#RETURN $ ((+) $ v0 $ xa)#))#)#)) $\n                     xa#))#)))\n 2. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn nat_assn) x xi\n 3. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (?R5 x xi) a c \\<Longrightarrow>\\<^sub>t hn_val nat_rel a c\n 4. CONSTRAINT_SLOT (True)", "(*apply (unfold APP_def PROTECT2_def) (* Make term readable for inspection*) *)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_refine (hn_ctxt (list_assn nat_assn) x xi) (?fi4 xi)\n        (?\\<Gamma>'5 x xi) (?R5 x xi)\n        ((\\<bind>) $ (RETURN $ (op_list_length $ x)) $\n         (\\<lambda>xa.\n             (#Let $ xa $\n               (\\<lambda>xa.\n                   (#monadic_nfoldli $ x $ (\\<lambda>x. (#RETURN $ True#)) $\n                     (\\<lambda>x.\n                         (#\\<lambda>xa.\n                              (#(\\<bind>) $\n                                ((\\<bind>) $ (RETURN $ (COPY $ x)) $\n                                 (\\<lambda>v0.\n                                     (#RETURN $ ((*) $ v0 $ x)#))) $\n                                (\\<lambda>v0.\n                                    (#RETURN $ ((+) $ v0 $ xa)#))#)#)) $\n                     xa#))#)))\n 2. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn nat_assn) x xi\n 3. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (?R5 x xi) a c \\<Longrightarrow>\\<^sub>t hn_val nat_rel a c\n 4. CONSTRAINT_SLOT (True)", "apply sepref_dbg_opt_init"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_refine (hn_ctxt (list_assn nat_assn) x xi) (?c31 x xi)\n        (?\\<Gamma>'5 x xi) (?R5 x xi)\n        ((\\<bind>) $ (RETURN $ (op_list_length $ x)) $\n         (\\<lambda>xa.\n             (#Let $ xa $\n               (\\<lambda>xa.\n                   (#monadic_nfoldli $ x $ (\\<lambda>x. (#RETURN $ True#)) $\n                     (\\<lambda>x.\n                         (#\\<lambda>xa.\n                              (#(\\<bind>) $\n                                ((\\<bind>) $ (RETURN $ (COPY $ x)) $\n                                 (\\<lambda>v0.\n                                     (#RETURN $ ((*) $ v0 $ x)#))) $\n                                (\\<lambda>v0.\n                                    (#RETURN $ ((+) $ v0 $ xa)#))#)#)) $\n                     xa#))#)))\n 2. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       CNV (?c31 x xi) (?fi4 xi)\n 3. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn nat_assn) x xi\n 4. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (?R5 x xi) a c \\<Longrightarrow>\\<^sub>t hn_val nat_rel a c\n 5. CONSTRAINT_SLOT (True)", "apply sepref_dbg_trans"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       CNV (return $ (op_list_length $ xi) \\<bind>\n            (\\<lambda>x'.\n                Let x'\n                 (imp_nfoldli xi (\\<lambda>\\<sigma>. return True)\n                   (\\<lambda>xc \\<sigma>.\n                       return $ xc \\<bind>\n                       (\\<lambda>x'c. return (x'c * xc)) \\<bind>\n                       (\\<lambda>x'c. return (x'c + \\<sigma>))))))\n        (?fi4 xi)\n 2. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (list_assn nat_assn) x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn nat_assn) x xi\n 3. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_val nat_rel a c \\<Longrightarrow>\\<^sub>t hn_val nat_rel a c\n 4. CONSTRAINT_SLOT (True)", "apply sepref_dbg_opt"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (list_assn nat_assn) x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn nat_assn) x xi\n 2. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_val nat_rel a c \\<Longrightarrow>\\<^sub>t hn_val nat_rel a c\n 3. CONSTRAINT_SLOT (True)", "apply sepref_dbg_cons_solve"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_val nat_rel a c \\<Longrightarrow>\\<^sub>t hn_val nat_rel a c\n 2. CONSTRAINT_SLOT (True)", "apply sepref_dbg_cons_solve"], ["proof (prove)\ngoal (1 subgoal):\n 1. CONSTRAINT_SLOT (True)", "apply sepref_dbg_constraints"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Optimization Init Phase\\<close>"], ["", "text \\<open>This phase, accessed by @{method sepref_dbg_opt_init}, just applies the \n  rule @{thm TRANS_init} to set up a subgoal for a-posteriori optimization\\<close>"], ["", "subsubsection \\<open>Translation Phase\\<close>"], ["", "text \\<open>\n  The translation phase is the main phase of the Sepref tool. \n  It performs the actual synthesis of the imperative program from\n  the abstract one. For this, it integrates various components, among others,\n  a frame inference tool, a semantic side-condition solver and a monotonicity prover.\n\n  The translation phase consists of two major sub-phases: \n  Application of translation rules and solving of deferred constraints.\n\n  The method @{method sepref_dbg_trans} executes the translation phase,\n  @{method sepref_dbg_trans_keep} executes the translation phase, \n  presenting the internal goal state of a failed sub-phase.\n\n  The translation rule phase repeatedly applies translation steps, until the \n  subgoal is completely solved. \n\n  The main idea of the translation phase is, that for every abstract variable \\<open>x\\<close> in scope,\n  the precondition contains an assertion of the form @{term \"hn_ctxt A x xi\"}, indicating how\n  this variable is implemented. Common abbreviations are \n  @{term \"hn_val R x xi \\<equiv> hn_ctxt (pure R) x xi\"} \n  and @{term \"hn_invalid A x xi \\<equiv> hn_ctxt (invalid_assn A) x xi\"}.\n\\<close>"], ["", "subsubsection \\<open>Translation: Step\\<close>"], ["", "text \\<open>\n  A translation step applies a single synthesis step for an operator,\n  or solves a deferred side-condition. \n\n  There are two types of translation steps: Combinator steps and operator steps.\n  A combinator step consists of applying a rule from @{attribute sepref_comb_rules}\n  to the goal-state. If no such rule applies, the rules are tried again after rewriting\n  the precondition with @{attribute sepref_frame_normrel_eqs} (see frame-inference).\n  The premises of the combinator rule become new subgoals, which are solved by \n  subsequent steps. No backtracking is applied over combinator rules. \n  This restriction has been introduced to make the tool more deterministic, and hence\n  more manageable. \n\n  An operator step applies an operator rule (from @{attribute sepref_fr_rules}) \n  with frame-inference, and then tries to solve the resulting side conditions \n  immediately. If not all side-conditions can be solved, it backtracks over the \n  application of the operator rule. \n\n  Note that, currently, side conditions to operator rules cannot contain \n  synthesis goals themselves. Again, this restriction reduces the tool's \n  complexity by avoiding deep nesting of synthesis. However, it hinders\n  the important feature of generic algorithms, where an operation can issue \n  synthesis subgoals for required operations it is built from (E.g., set union\n  can be implemented by insert and iteration). Our predecessor tool, Autoref,\n  makes heavy use of this feature, and we consider dropping the restriction in \n  the near future.\n\n  An operator-step itself consists of several sub-phases:\n  \\<^descr>[Align goal] Splits the precondition into the arguments actually occurring in\n    the operation, and the rest (called frame).\n  \\<^descr>[Frame rule] Applies a frame rule to focus on the actual arguments. Moreover,\n    it inserts a subgoal of the form @{term \"RECOVER_PURE \\<Gamma> \\<Gamma>'\"}, which is used \n    to restore invalidated arguments if possible. Finally, it generates an assumption\n    of the form @{term \"vassn_tag \\<Gamma>'\"}, which means that the precondition holds\n    on some heap. This assumption is used to extract semantic information from the \n    precondition during side-condition solving.\n\n  \\<^descr>[Recover pure] This phase tries to recover invalidated arguments. \n    An invalidated argument is one that has been destroyed by a previous operation.\n    It occurs in the precondition as @{term \"hn_invalid A x xi\"}, which indicates\n    that there exists a heap where the refinement holds. However, if the refinement \n    assertion \\<open>A\\<close> does not depend on the heap (is \\<^emph>\\<open>pure\\<close>), the invalidated argument\n    can be recovered. The purity assumption is inserted as a constraint (see constraints),\n    such that it can be deferred.\n  \\<^descr>[Apply rule] This phase applies a rule from @{attribute sepref_fr_rules} to\n    the subgoal. If there is no matching rule, matching is retried after rewriting\n    the precondition with @{attribute sepref_frame_normrel_eqs}. If this does not succeed\n    either, a consequence rule is used on the precondition. The implication becomes an \n    additional side condition, which will be solved by the frame inference tool.\n\n    To avoid too much backtracking, the new precondition\n    is massaged to have the same structure as the old one, i.e., it contains a (now schematic)\n    refinement assertion for each operand. This excludes rules for which the frame inference\n    would fail anyway.\n\n    If a matching rule is found, it is applied and all new subgoals are solved by the \n    side-condition solver. If this fails, the tool backtracks over the application of \n    the @{attribute sepref_fr_rules}-rules. Note that direct matches prevent precondition \n    simplification, and matches after precondition simplification prevent the consequence \n    rule to be applied.\n\n  \n  The method @{method sepref_dbg_trans_step} performs a single translation step.\n  The method @{method sepref_dbg_trans_step_keep} presents the internal goal state \n  on failure. If it fails in the \\<open>apply-rule\\<close> phase, it presents the sequence of \n  states with partially unsolved side conditions for all matching rules. \n\\<close>"], ["", "subsubsection \\<open>Translation: Side Conditions\\<close>"], ["", "text \\<open>The side condition solver is used to discharge goals that arise as \n  side-conditions to the translation rules. It does a syntactic discrimination \n  of the side condition type, and then invokes the appropriate solver. Currently,\n  it supports the following side conditions:\n  \\<^descr>[Merge] (\\<open>_\\<or>\\<^sub>A_ \\<Longrightarrow>\\<^sub>t _\\<close>). These are used to merge postconditions from different \n    branches of the program (e.g. after an if-then-else). They are solved by the \n    frame inference tool (see section on frame inference).\n  \\<^descr>[Frame] (\\<open>_ \\<Longrightarrow>\\<^sub>t _\\<close>). Used to match up the current precondition against the \n    precondition of the applied rule. Solved by the frame inference tool (see section on frame inference).\n  \\<^descr>[Independence] (\\<open>INDEP (?R x\\<^sub>1 \\<dots> x\\<^sub>n)\\<close>). Deprecated. Used to instantiate a \n    schematic variable such that it does not depend on any bound variables any more. \n    Originally used to make goals more readable, we are considering of dropping this.\n  \\<^descr>[Constraints] (\\<open>CONSTRAINT _ _\\<close>) Apply solver for deferrable constraints (see section on constraints).\n  \\<^descr>[Monotonicity] (\\<open>mono_Heap _\\<close>) Apply monotonicity solver. Monotonicity subgoals occur when\n    translating recursion combinators. Monadic expressions are monotonic by construction, and \n    this side-condition solver just forwards to the monotonicity prover of the partial \n    function package, after stripping any preconditions from the subgoal, which are \n    not supported by the case split mechanism of the monotonicity prover (as of Isabelle2016).\n  \\<^descr>[Prefer/Defer] (\\<open>PREFER_tag _\\<close>/\\<open>DEFER_tag\\<close>). Deprecated. Invoke the tagged solver of \n    the Autoref tool. Used historically for importing refinements from the Autoref tool,\n    but as Sepref becomes more complete imports from Autoref are not required any more.\n  \\<^descr>[Resolve with Premise] \\<open>RPREM _\\<close> Resolve subgoal with one of its premises. \n    Used for translation of recursion combinators. \n  \\<^descr>[Generic Algorithm] \\<open>GEN_ALGO _ _\\<close> Triggers resolution with a rule from\n    @{attribute sepref_gen_algo_rules}. This is a poor-man's version of generic \n    algorithm, which is currently only used to synthesize to-list conversions for foreach-loops.\n  \\<^descr>[Fallback] (Any pattern not matching the above, nor being a \\<open>hn_refine\\<close> goal).\n    Unfolds the application and abstraction tagging, as well as @{term bind_ref_tag} tags \n    which are inserted by several translation rules to indicate the value a variable has \n    been bound to, and then tries to solve the goal by @{method auto}, after freezing \n    schematic variables. This tactic is used to discharge semantic side conditions, e.g.,\n    in-range conditions for array indexing. \n\n\n  Methods: @{method sepref_dbg_side} to apply a side-condition solving step,\n    @{method sepref_dbg_side_unfold} to apply the unfolding of application and binding tags and \n    @{method sepref_dbg_side_keep} to return the internal state after failed side-condition solving.\n\\<close>"], ["", "subsubsection \\<open>Translation: Constraints\\<close>"], ["", "text \\<open>During the translation phase, the refinement of operands is not \n  always known immediately, such that schematic variables may occur as refinement \n  assertions. Side conditions on those refinement assertions cannot be discharged \n  until the schematic variable gets instantiated. \n\n  Thus, side conditions may be tagged with @{const CONSTRAINT}. \n  If the side condition solver encounters a constraint side condition, it first removes\n  the constraint tag (@{thm CONSTRAINT_I}) and freezes all schematic variables to prevent them from \n  accidentally getting instantiated. Then it simplifies with @{attribute constraint_simps} and\n  tries to solve the goal using rules from \n  @{attribute safe_constraint_rules} (no backtracking) \n  and @{attribute constraint_rules} (with backtracking).\n\n  If solving the constraint is not successful, only the safe rules are applied, and the \n  remaining subgoals are moved to a special \\<open>CONSTRAINT_SLOT\\<close> subgoal, that always is the \n  last subgoal, and is initialized by the preprocessing phase of Sepref.\n  Moving the subgoal to the constraint slot looks for Isabelle's tacticals like the subgoal \n  has been solved. In reality, it is only deferred and must be solved later.\n  \n  Constraints are used in several phases of Sepref, and all constraints are solved\n  at the end of the translation phase, and at the end of the Sepref invocation.\n  \n  Methods: \n    \\<^item> @{method solve_constraint} to apply constraint solving, the @{const CONSTRAINT}-tag is optional.\n    \\<^item> @{method safe_constraint} to apply safe rules, the @{const CONSTRAINT}-tag is optional.\n    \\<^item> @{method print_slot} to print the contents of the constraint slot.\n\n\\<close>"], ["", "subsubsection \\<open>Translation: Merging and Frame Inference\\<close>"], ["", "text \\<open>Frame inference solves goals of the form \\<open>\\<Gamma> \\<Longrightarrow>\\<^sub>t \\<Gamma>'\\<close>.\n  For this, it matches \\<open>hn_ctxt\\<close> components in \\<open>\\<Gamma>'\\<close> with those in \\<open>\\<Gamma>\\<close>.\n  Matching is done according to the refined variables. \n  The matching pairs and the rest is then treated differently: \n  The rest is resolved by repeatedly applying the rules from @{thm frame_rem_thms}.\n  The matching pairs are resolved by repeatedly applying rules from \n  @{thm frame_thms} and @{attribute sepref_frame_match_rules}. \n  Any non-frame premise of these rules must be solved immediately by the \n  side-condition's constraint or fallback tactic (see above). The tool backtracks over rules.\n  If no rule matches (or side-conditions cannot be solved), it simplifies the goal \n  with @{attribute sepref_frame_normrel_eqs} and tries again.\n\n  For merge rules, the theorems @{thm merge_thms} \n  and @{attribute sepref_frame_merge_rules} are used.\n\n  Note that a smart setup of frame and match rules together with side conditions makes \n  the frame matcher a powerful tool for encoding structural and semantic information \n  into relations. An example for structural information are the match rules for lists,\n  which forward matching of list assertions to matching of the element assertions,\n  maintaining the congruence assumption that the refined elements are actually elements \n  of the list: @{thm list_match_cong}.\n  An example for semantic information is the bounded assertion, which intersects\n  any given assertion with a predicate on the abstract domain. The frame matcher is \n  set up such that it can convert between bounded assertions, generating semantic \n  side conditions to discharge implications between bounds (@{thm b_assn_subtyping_match}). \n\n  This is essentially a subtyping mechanism on the level of refinement assertions,\n  which is quite useful for maintaining natural side conditions on operands. \n  A standard example is to maintain a list of array indices: The refinement assertion \n  for array indices is @{term nat_assn} restricted to indices that are in range:\n  @{term \"nbn_assn N\"}. When inserting natural numbers into this list, one has to \n  prove that they are actually in range (conversion from @{term nat_assn} to @{term nbn_assn}).\n  Elements of the list can be used as natural numbers (conversion from @{term nbn_assn} \n  to @{term nat_assn}). Additionally, the side condition solver can derive that the predicate\n  holds on the abstract variable (via the @{const vassn_tag} inserted by the operator steps). \n\\<close>"], ["", "subsubsection \\<open>Translation: Annotated Example\\<close>"], ["", "context \n  fixes N::nat \n  notes [[sepref_register_adhoc N]]\n  notes [sepref_import_param] = IdI[of N]\nbegin"], ["", "text \\<open>This worked example utilizes the following features of the translation phase:\n  \\<^item> We have a fold combinator, which gets translated by its combinator rule\n  \\<^item> We add a type annotation which enforces converting the natural numbers\n    inserted into the list being refined by \\<open>nbn_assn N\\<close>, i.e., smaller than \\<open>N\\<close>.\n  \\<^item> We can only prove the numbers inserted into the list to be smaller than \\<open>N\\<close>  \n    because the combinator rule for \\<open>If\\<close> inserts congruence assumptions.\n  \\<^item> By moving the elements from the list to the set, they get invalidated.\n    However, as \\<open>nat_assn\\<close> is pure, they can be recovered later, allowing us to \n    mark the list argument as read-only.\n\\<close>"], ["", "sepref_thm filter_N_test is \"\\<lambda>l. RETURN (fold (\\<lambda>x s.\n  if x<N then insert (ASSN_ANNOT (nbn_assn N) x) s else s\n) l op_hs_empty)\" :: \"(list_assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a hs.assn (nbn_assn N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>l.\n        RETURN\n         (fold\n           (\\<lambda>x s.\n               if x < N then insert (ASSN_ANNOT (nbn_assn N) x) s else s)\n           l op_hs_empty))\n    \\<in> (list_assn\n            nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a hs.assn (nbn_assn N)", "apply sepref_dbg_preproc"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_refine (hn_ctxt (list_assn nat_assn) x xi) (?fi1 xi)\n        (hn_ctxt (list_assn nat_assn) x xi) (hs.assn (nbn_assn N))\n        (RETURN\n          (fold\n            (\\<lambda>x s.\n                if x < N then insert (ASSN_ANNOT (nbn_assn N) x) s else s)\n            x op_hs_empty))\n 2. CONSTRAINT_SLOT (True)", "apply sepref_dbg_cons_init"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_refine (hn_ctxt (list_assn nat_assn) x xi) (?fi4 xi)\n        (?\\<Gamma>'5 x xi) (?R5 x xi)\n        (RETURN\n          (fold\n            (\\<lambda>x s.\n                if x < N then insert (ASSN_ANNOT (nbn_assn N) x) s else s)\n            x op_hs_empty))\n 2. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn nat_assn) x xi\n 3. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (?R5 x xi) a c \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (hs.assn (nbn_assn N)) a c\n 4. CONSTRAINT_SLOT (True)", "apply sepref_dbg_id"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_refine (hn_ctxt (list_assn nat_assn) x xi) (?fi4 xi)\n        (?\\<Gamma>'5 x xi) (?R5 x xi)\n        (RETURN $\n         (fold $\n          (\\<lambda>x.\n              (#\\<lambda>xa.\n                   (#If $ ((<) $ x $ N) $\n                     (op_set_insert $\n                      (PR_CONST (ASSN_ANNOT (nbn_assn N)) $ x) $\n                      xa) $\n                     xa#)#)) $\n          x $\n          op_hs_empty))\n 2. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn nat_assn) x xi\n 3. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (?R5 x xi) a c \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (hs.assn (nbn_assn N)) a c\n 4. CONSTRAINT_SLOT (True)", "apply sepref_dbg_monadify"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_refine (hn_ctxt (list_assn nat_assn) x xi) (?fi4 xi)\n        (?\\<Gamma>'5 x xi) (?R5 x xi)\n        ((\\<bind>) $ (RETURN $ op_hs_empty) $\n         (\\<lambda>xa.\n             (#monadic_nfoldli $ x $ (\\<lambda>x. (#RETURN $ True#)) $\n               (\\<lambda>x.\n                   (#\\<lambda>xa.\n                        (#(\\<bind>) $\n                          ((\\<bind>) $ (RETURN $ N) $\n                           (\\<lambda>v1. (#RETURN $ ((<) $ x $ v1)#))) $\n                          (\\<lambda>xb.\n                              (#If $ xb $\n                                ((\\<bind>) $\n                                 (RETURN $\n                                  (PR_CONST (ASSN_ANNOT (nbn_assn N)) $\n                                   x)) $\n                                 (\\<lambda>v0.\n                                     (#RETURN $\n (op_set_insert $ v0 $ xa)#))) $\n                                (PASS $ xa)#))#)#)) $\n               xa#)))\n 2. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn nat_assn) x xi\n 3. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (?R5 x xi) a c \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (hs.assn (nbn_assn N)) a c\n 4. CONSTRAINT_SLOT (True)", "apply sepref_dbg_opt_init"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_refine (hn_ctxt (list_assn nat_assn) x xi) (?c38 x xi)\n        (?\\<Gamma>'5 x xi) (?R5 x xi)\n        ((\\<bind>) $ (RETURN $ op_hs_empty) $\n         (\\<lambda>xa.\n             (#monadic_nfoldli $ x $ (\\<lambda>x. (#RETURN $ True#)) $\n               (\\<lambda>x.\n                   (#\\<lambda>xa.\n                        (#(\\<bind>) $\n                          ((\\<bind>) $ (RETURN $ N) $\n                           (\\<lambda>v1. (#RETURN $ ((<) $ x $ v1)#))) $\n                          (\\<lambda>xb.\n                              (#If $ xb $\n                                ((\\<bind>) $\n                                 (RETURN $\n                                  (PR_CONST (ASSN_ANNOT (nbn_assn N)) $\n                                   x)) $\n                                 (\\<lambda>v0.\n                                     (#RETURN $\n (op_set_insert $ v0 $ xa)#))) $\n                                (PASS $ xa)#))#)#)) $\n               xa#)))\n 2. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       CNV (?c38 x xi) (?fi4 xi)\n 3. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn nat_assn) x xi\n 4. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (?R5 x xi) a c \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (hs.assn (nbn_assn N)) a c\n 5. CONSTRAINT_SLOT (True)", "apply sepref_dbg_trans_step \\<comment> \\<open>Combinator rule for bind, \n    generating two \\<open>hn_refine\\<close> goals, and a frame rule to\n    separate the bound variable from the rest.\\<close>"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_refine (hn_ctxt (list_assn nat_assn) x xi) (?m'39 x xi)\n        (?\\<Gamma>1.39 x xi) (?Rh39 x xi) (RETURN $ op_hs_empty)\n 2. \\<And>x xi xa x'.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty)\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?\\<Gamma>1.39 x xi * hn_ctxt (?Rh39 x xi) xa x')\n                          (?f'39 x xi x') (?\\<Gamma>2.39 x xi xa x')\n                          (?R5 x xi)\n                          (monadic_nfoldli $ x $\n                           (\\<lambda>x. (#RETURN $ True#)) $\n                           (\\<lambda>x.\n                               (#\\<lambda>xa.\n                                    (#(\\<bind>) $\n((\\<bind>) $ (RETURN $ N) $ (\\<lambda>v1. (#RETURN $ ((<) $ x $ v1)#))) $\n(\\<lambda>xb.\n    (#If $ xb $\n      ((\\<bind>) $ (RETURN $ (PR_CONST (ASSN_ANNOT (nbn_assn N)) $ x)) $\n       (\\<lambda>v0. (#RETURN $ (op_set_insert $ v0 $ xa)#))) $\n      (PASS $ xa)#))#)#)) $\n                           xa)\n 3. \\<And>x xi xa x'.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>2.39 x xi xa x' \\<Longrightarrow>\\<^sub>t\n       ?\\<Gamma>'5 x xi * hn_ctxt (?Rx39 x xi) xa x'\n 4. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       CNV (?m'39 x xi \\<bind> ?f'39 x xi) (?fi4 xi)\n 5. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn nat_assn) x xi\n 6. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (?R5 x xi) a c \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (hs.assn (nbn_assn N)) a c\n 7. CONSTRAINT_SLOT (True)", "apply sepref_dbg_trans_step \\<comment> \\<open>Rule for empty hashset, solves goal\\<close>"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x xi xa x'.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty)\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (list_assn nat_assn) x xi * emp *\n                           hn_ctxt (hs.assn (?A44 x xi)) xa x')\n                          (?f'39 x xi x') (?\\<Gamma>2.39 x xi xa x')\n                          (?R5 x xi)\n                          (monadic_nfoldli $ x $\n                           (\\<lambda>x. (#RETURN $ True#)) $\n                           (\\<lambda>x.\n                               (#\\<lambda>xa.\n                                    (#(\\<bind>) $\n((\\<bind>) $ (RETURN $ N) $ (\\<lambda>v1. (#RETURN $ ((<) $ x $ v1)#))) $\n(\\<lambda>xb.\n    (#If $ xb $\n      ((\\<bind>) $ (RETURN $ (PR_CONST (ASSN_ANNOT (nbn_assn N)) $ x)) $\n       (\\<lambda>v0. (#RETURN $ (op_set_insert $ v0 $ xa)#))) $\n      (PASS $ xa)#))#)#)) $\n                           xa)\n 2. \\<And>x xi xa x'.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>2.39 x xi xa x' \\<Longrightarrow>\\<^sub>t\n       ?\\<Gamma>'5 x xi * hn_ctxt (?Rx39 x xi) xa x'\n 3. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       CNV (hs_new \\<bind> ?f'39 x xi) (?fi4 xi)\n 4. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn nat_assn) x xi\n 5. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (?R5 x xi) a c \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (hs.assn (nbn_assn N)) a c\n 6. CONSTRAINT_SLOT (True)", "apply sepref_dbg_trans_step \\<comment> \\<open>Combinator rule for nfoldli (@{thm hn_monadic_nfoldli_rl'})\\<close>"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>x xi xa x'.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty)\\<rbrakk>\n       \\<Longrightarrow> INDEP (?Rk45 x xi xa x')\n 2. \\<And>x xi xa x'.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty)\\<rbrakk>\n       \\<Longrightarrow> INDEP (?R5 x xi)\n 3. \\<And>x xi xa x'.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty)\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt (list_assn nat_assn) x xi * emp *\n                         hn_ctxt (hs.assn (?A44 x xi)) xa\n                          x' \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>45 x xi xa x' *\n                         hn_ctxt (list_assn (?Rk45 x xi xa x')) x\n                          (?s46 x xi x') *\n                         hn_ctxt (?R5 x xi) xa (?\\<sigma>49 x xi x')\n 4. \\<And>x xi xa x' \\<sigma> \\<sigma>'.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty)\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?\\<Gamma>45 x xi xa x' *\n                           hn_ctxt (?R5 x xi) \\<sigma>' \\<sigma>)\n                          (?c47 x xi x' \\<sigma>)\n                          (?\\<Gamma>c45 x xi xa x' \\<sigma>' \\<sigma>)\n                          bool_assn (RETURN $ True)\n 5. \\<And>x xi xa x' \\<sigma>' \\<sigma>.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty);\n        TERM monadic_nfoldli\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>c45 x xi xa x' \\<sigma>'\n                          \\<sigma> \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>45 x xi xa x' *\n                         hn_ctxt (?R5 x xi) \\<sigma>' \\<sigma>\n 6. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma>.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?\\<Gamma>45 x xi xa x' *\n                           hn_ctxt (?Rk45 x xi xa x') x'a xb *\n                           hn_ctxt (?R5 x xi) \\<sigma>' \\<sigma>)\n                          (?f48 x xi x' xb \\<sigma>)\n                          (?\\<Gamma>f45 x xi xa x' x'a xb \\<sigma>'\n                            \\<sigma>)\n                          (?R5 x xi)\n                          ((\\<bind>) $\n                           ((\\<bind>) $ (RETURN $ N) $\n                            (\\<lambda>v1. (#RETURN $ ((<) $ x'a $ v1)#))) $\n                           (\\<lambda>x.\n                               (#If $ x $\n                                 ((\\<bind>) $\n                                  (RETURN $\n                                   (PR_CONST (ASSN_ANNOT (nbn_assn N)) $\n                                    x'a)) $\n                                  (\\<lambda>v0.\n(#RETURN $ (op_set_insert $ v0 $ \\<sigma>')#))) $\n                                 (PASS $ \\<sigma>')#)))\n 7. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma>.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty);\n        TERM monadic_nfoldli\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>f45 x xi xa x' x'a xb \\<sigma>'\n                          \\<sigma> \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>45 x xi xa x' *\n                         hn_ctxt (?Rk'45 x xi xa x') x'a xb *\n                         hn_ctxt (?Pf\\<sigma>45 x xi xa x') \\<sigma>'\n                          \\<sigma>\n 8. \\<And>x xi xa x' xb x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty)\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt (?Rk'45 x xi xa x') x'a xb \\<or>\\<^sub>A\n                         hn_ctxt (?Rk45 x xi xa x') x'a\n                          xb \\<Longrightarrow>\\<^sub>t\n                         hn_ctxt (?Rk''45 x xi xa x') x'a xb\n 9. \\<And>x xi xa x'.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>45 x xi xa x' *\n       hn_ctxt (list_assn (?Rk''45 x xi xa x')) x (?s46 x xi x') *\n       hn_invalid (?R5 x xi) xa\n        (?\\<sigma>49 x xi x') \\<Longrightarrow>\\<^sub>t\n       ?\\<Gamma>'5 x xi * hn_ctxt (?Rx39 x xi) xa x'\n 10. \\<And>x xi.\n        x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n        CNV (hs_new \\<bind>\n             (\\<lambda>x'.\n                 imp_nfoldli (?s46 x xi x') (?c47 x xi x') (?f48 x xi x')\n                  (?\\<sigma>49 x xi x')))\n         (?fi4 xi)\nA total of 13 subgoals...", "apply sepref_dbg_trans_step \\<comment> \\<open>INDEP\\<close>"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>x xi xa x'.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty)\\<rbrakk>\n       \\<Longrightarrow> INDEP (?R5 x xi)\n 2. \\<And>x xi xa x'.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty)\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt (list_assn nat_assn) x xi * emp *\n                         hn_ctxt (hs.assn (?A44 x xi)) xa\n                          x' \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>45 x xi xa x' *\n                         hn_ctxt (list_assn ?Rk45) x (?s46 x xi x') *\n                         hn_ctxt (?R5 x xi) xa (?\\<sigma>49 x xi x')\n 3. \\<And>x xi xa x' \\<sigma> \\<sigma>'.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty)\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?\\<Gamma>45 x xi xa x' *\n                           hn_ctxt (?R5 x xi) \\<sigma>' \\<sigma>)\n                          (?c47 x xi x' \\<sigma>)\n                          (?\\<Gamma>c45 x xi xa x' \\<sigma>' \\<sigma>)\n                          bool_assn (RETURN $ True)\n 4. \\<And>x xi xa x' \\<sigma>' \\<sigma>.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty);\n        TERM monadic_nfoldli\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>c45 x xi xa x' \\<sigma>'\n                          \\<sigma> \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>45 x xi xa x' *\n                         hn_ctxt (?R5 x xi) \\<sigma>' \\<sigma>\n 5. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma>.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?\\<Gamma>45 x xi xa x' * hn_ctxt ?Rk45 x'a xb *\n                           hn_ctxt (?R5 x xi) \\<sigma>' \\<sigma>)\n                          (?f48 x xi x' xb \\<sigma>)\n                          (?\\<Gamma>f45 x xi xa x' x'a xb \\<sigma>'\n                            \\<sigma>)\n                          (?R5 x xi)\n                          ((\\<bind>) $\n                           ((\\<bind>) $ (RETURN $ N) $\n                            (\\<lambda>v1. (#RETURN $ ((<) $ x'a $ v1)#))) $\n                           (\\<lambda>x.\n                               (#If $ x $\n                                 ((\\<bind>) $\n                                  (RETURN $\n                                   (PR_CONST (ASSN_ANNOT (nbn_assn N)) $\n                                    x'a)) $\n                                  (\\<lambda>v0.\n(#RETURN $ (op_set_insert $ v0 $ \\<sigma>')#))) $\n                                 (PASS $ \\<sigma>')#)))\n 6. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma>.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty);\n        TERM monadic_nfoldli\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>f45 x xi xa x' x'a xb \\<sigma>'\n                          \\<sigma> \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>45 x xi xa x' *\n                         hn_ctxt (?Rk'45 x xi xa x') x'a xb *\n                         hn_ctxt (?Pf\\<sigma>45 x xi xa x') \\<sigma>'\n                          \\<sigma>\n 7. \\<And>x xi xa x' xb x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty)\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt (?Rk'45 x xi xa x') x'a xb \\<or>\\<^sub>A\n                         hn_ctxt ?Rk45 x'a xb \\<Longrightarrow>\\<^sub>t\n                         hn_ctxt (?Rk''45 x xi xa x') x'a xb\n 8. \\<And>x xi xa x'.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>45 x xi xa x' *\n       hn_ctxt (list_assn (?Rk''45 x xi xa x')) x (?s46 x xi x') *\n       hn_invalid (?R5 x xi) xa\n        (?\\<sigma>49 x xi x') \\<Longrightarrow>\\<^sub>t\n       ?\\<Gamma>'5 x xi * hn_ctxt (?Rx39 x xi) xa x'\n 9. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       CNV (hs_new \\<bind>\n            (\\<lambda>x'.\n                imp_nfoldli (?s46 x xi x') (?c47 x xi x') (?f48 x xi x')\n                 (?\\<sigma>49 x xi x')))\n        (?fi4 xi)\n 10. \\<And>x xi.\n        x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n        ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n        hn_ctxt (list_assn nat_assn) x xi\nA total of 12 subgoals...", "apply sepref_dbg_trans_step \\<comment> \\<open>INDEP\\<close>"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>x xi xa x'.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty)\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt (list_assn nat_assn) x xi * emp *\n                         hn_ctxt (hs.assn (?A44 x xi)) xa\n                          x' \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>45 x xi xa x' *\n                         hn_ctxt (list_assn ?Rk45) x (?s46 x xi x') *\n                         hn_ctxt ?R5 xa (?\\<sigma>49 x xi x')\n 2. \\<And>x xi xa x' \\<sigma> \\<sigma>'.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty)\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?\\<Gamma>45 x xi xa x' *\n                           hn_ctxt ?R5 \\<sigma>' \\<sigma>)\n                          (?c47 x xi x' \\<sigma>)\n                          (?\\<Gamma>c45 x xi xa x' \\<sigma>' \\<sigma>)\n                          bool_assn (RETURN $ True)\n 3. \\<And>x xi xa x' \\<sigma>' \\<sigma>.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty);\n        TERM monadic_nfoldli\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>c45 x xi xa x' \\<sigma>'\n                          \\<sigma> \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>45 x xi xa x' *\n                         hn_ctxt ?R5 \\<sigma>' \\<sigma>\n 4. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma>.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?\\<Gamma>45 x xi xa x' * hn_ctxt ?Rk45 x'a xb *\n                           hn_ctxt ?R5 \\<sigma>' \\<sigma>)\n                          (?f48 x xi x' xb \\<sigma>)\n                          (?\\<Gamma>f45 x xi xa x' x'a xb \\<sigma>'\n                            \\<sigma>)\n                          ?R5\n                          ((\\<bind>) $\n                           ((\\<bind>) $ (RETURN $ N) $\n                            (\\<lambda>v1. (#RETURN $ ((<) $ x'a $ v1)#))) $\n                           (\\<lambda>x.\n                               (#If $ x $\n                                 ((\\<bind>) $\n                                  (RETURN $\n                                   (PR_CONST (ASSN_ANNOT (nbn_assn N)) $\n                                    x'a)) $\n                                  (\\<lambda>v0.\n(#RETURN $ (op_set_insert $ v0 $ \\<sigma>')#))) $\n                                 (PASS $ \\<sigma>')#)))\n 5. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma>.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty);\n        TERM monadic_nfoldli\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>f45 x xi xa x' x'a xb \\<sigma>'\n                          \\<sigma> \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>45 x xi xa x' *\n                         hn_ctxt (?Rk'45 x xi xa x') x'a xb *\n                         hn_ctxt (?Pf\\<sigma>45 x xi xa x') \\<sigma>'\n                          \\<sigma>\n 6. \\<And>x xi xa x' xb x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty)\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt (?Rk'45 x xi xa x') x'a xb \\<or>\\<^sub>A\n                         hn_ctxt ?Rk45 x'a xb \\<Longrightarrow>\\<^sub>t\n                         hn_ctxt (?Rk''45 x xi xa x') x'a xb\n 7. \\<And>x xi xa x'.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>45 x xi xa x' *\n       hn_ctxt (list_assn (?Rk''45 x xi xa x')) x (?s46 x xi x') *\n       hn_invalid ?R5 xa (?\\<sigma>49 x xi x') \\<Longrightarrow>\\<^sub>t\n       ?\\<Gamma>'5 x xi * hn_ctxt (?Rx39 x xi) xa x'\n 8. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       CNV (hs_new \\<bind>\n            (\\<lambda>x'.\n                imp_nfoldli (?s46 x xi x') (?c47 x xi x') (?f48 x xi x')\n                 (?\\<sigma>49 x xi x')))\n        (?fi4 xi)\n 9. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn nat_assn) x xi\n 10. \\<And>x xi a c.\n        x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n        hn_ctxt ?R5 a c \\<Longrightarrow>\\<^sub>t\n        hn_ctxt (hs.assn (nbn_assn N)) a c\nA total of 11 subgoals...", "apply sepref_dbg_trans_step \\<comment> \\<open>Frame to get list and initial state\\<close>"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>x xi xa x' \\<sigma> \\<sigma>'.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty)\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (emp * hn_ctxt (hs.assn ?A57) \\<sigma>' \\<sigma>)\n                          (?c47 x xi x' \\<sigma>)\n                          (?\\<Gamma>c45 x xi xa x' \\<sigma>' \\<sigma>)\n                          bool_assn (RETURN $ True)\n 2. \\<And>x xi xa x' \\<sigma>' \\<sigma>.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty);\n        TERM monadic_nfoldli\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>c45 x xi xa x' \\<sigma>'\n                          \\<sigma> \\<Longrightarrow>\\<^sub>t\n                         emp * hn_ctxt (hs.assn ?A57) \\<sigma>' \\<sigma>\n 3. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma>.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (emp * hn_val nat_rel x'a xb *\n                           hn_ctxt (hs.assn ?A57) \\<sigma>' \\<sigma>)\n                          (?f48 x xi x' xb \\<sigma>)\n                          (?\\<Gamma>f45 x xi xa x' x'a xb \\<sigma>'\n                            \\<sigma>)\n                          (hs.assn ?A57)\n                          ((\\<bind>) $\n                           ((\\<bind>) $ (RETURN $ N) $\n                            (\\<lambda>v1. (#RETURN $ ((<) $ x'a $ v1)#))) $\n                           (\\<lambda>x.\n                               (#If $ x $\n                                 ((\\<bind>) $\n                                  (RETURN $\n                                   (PR_CONST (ASSN_ANNOT (nbn_assn N)) $\n                                    x'a)) $\n                                  (\\<lambda>v0.\n(#RETURN $ (op_set_insert $ v0 $ \\<sigma>')#))) $\n                                 (PASS $ \\<sigma>')#)))\n 4. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma>.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty);\n        TERM monadic_nfoldli\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>f45 x xi xa x' x'a xb \\<sigma>'\n                          \\<sigma> \\<Longrightarrow>\\<^sub>t\n                         emp * hn_ctxt (?Rk'45 x xi xa x') x'a xb *\n                         hn_ctxt (?Pf\\<sigma>45 x xi xa x') \\<sigma>'\n                          \\<sigma>\n 5. \\<And>x xi xa x' xb x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty)\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt (?Rk'45 x xi xa x') x'a xb \\<or>\\<^sub>A\n                         hn_val nat_rel x'a xb \\<Longrightarrow>\\<^sub>t\n                         hn_ctxt (?Rk''45 x xi xa x') x'a xb\n 6. \\<And>x xi xa x'.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       emp * hn_ctxt (list_assn (?Rk''45 x xi xa x')) x xi *\n       hn_invalid (hs.assn ?A57) xa x' \\<Longrightarrow>\\<^sub>t\n       ?\\<Gamma>'5 x xi * hn_ctxt (?Rx39 x xi) xa x'\n 7. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       CNV (hs_new \\<bind>\n            (\\<lambda>x'. imp_nfoldli xi (?c47 x xi x') (?f48 x xi x') x'))\n        (?fi4 xi)\n 8. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn nat_assn) x xi\n 9. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (hs.assn ?A57) a c \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (hs.assn (nbn_assn N)) a c\n 10. CONSTRAINT_SLOT (True)", "apply sepref_dbg_trans_step \\<comment> \\<open>Refinement of continuation condition\\<close>"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x xi xa x' \\<sigma>' \\<sigma>.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty);\n        TERM monadic_nfoldli\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt (hs.assn ?A61) \\<sigma>' \\<sigma> *\n                         emp \\<Longrightarrow>\\<^sub>t\n                         emp * hn_ctxt (hs.assn ?A61) \\<sigma>' \\<sigma>\n 2. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma>.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (emp * hn_val nat_rel x'a xb *\n                           hn_ctxt (hs.assn ?A61) \\<sigma>' \\<sigma>)\n                          (?f48 x xi x' xb \\<sigma>)\n                          (?\\<Gamma>f45 x xi xa x' x'a xb \\<sigma>'\n                            \\<sigma>)\n                          (hs.assn ?A61)\n                          ((\\<bind>) $\n                           ((\\<bind>) $ (RETURN $ N) $\n                            (\\<lambda>v1. (#RETURN $ ((<) $ x'a $ v1)#))) $\n                           (\\<lambda>x.\n                               (#If $ x $\n                                 ((\\<bind>) $\n                                  (RETURN $\n                                   (PR_CONST (ASSN_ANNOT (nbn_assn N)) $\n                                    x'a)) $\n                                  (\\<lambda>v0.\n(#RETURN $ (op_set_insert $ v0 $ \\<sigma>')#))) $\n                                 (PASS $ \\<sigma>')#)))\n 3. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma>.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty);\n        TERM monadic_nfoldli\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>f45 x xi xa x' x'a xb \\<sigma>'\n                          \\<sigma> \\<Longrightarrow>\\<^sub>t\n                         emp * hn_ctxt (?Rk'45 x xi xa x') x'a xb *\n                         hn_ctxt (?Pf\\<sigma>45 x xi xa x') \\<sigma>'\n                          \\<sigma>\n 4. \\<And>x xi xa x' xb x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty)\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt (?Rk'45 x xi xa x') x'a xb \\<or>\\<^sub>A\n                         hn_val nat_rel x'a xb \\<Longrightarrow>\\<^sub>t\n                         hn_ctxt (?Rk''45 x xi xa x') x'a xb\n 5. \\<And>x xi xa x'.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       emp * hn_ctxt (list_assn (?Rk''45 x xi xa x')) x xi *\n       hn_invalid (hs.assn ?A61) xa x' \\<Longrightarrow>\\<^sub>t\n       ?\\<Gamma>'5 x xi * hn_ctxt (?Rx39 x xi) xa x'\n 6. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       CNV (hs_new \\<bind>\n            (\\<lambda>x'.\n                imp_nfoldli xi (\\<lambda>\\<sigma>. return True)\n                 (?f48 x xi x') x'))\n        (?fi4 xi)\n 7. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn nat_assn) x xi\n 8. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (hs.assn ?A61) a c \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (hs.assn (nbn_assn N)) a c\n 9. CONSTRAINT_SLOT (True)", "apply sepref_dbg_trans_step \\<comment> \\<open>Frame to recover state after continuation condition\\<close>\n\n    \\<comment> \\<open>Loop body\\<close>"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma>.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (emp * hn_val nat_rel x'a xb *\n                           hn_ctxt (hs.assn ?A61) \\<sigma>' \\<sigma>)\n                          (?f48 x xi x' xb \\<sigma>)\n                          (?\\<Gamma>f45 x xi xa x' x'a xb \\<sigma>'\n                            \\<sigma>)\n                          (hs.assn ?A61)\n                          ((\\<bind>) $\n                           ((\\<bind>) $ (RETURN $ N) $\n                            (\\<lambda>v1. (#RETURN $ ((<) $ x'a $ v1)#))) $\n                           (\\<lambda>x.\n                               (#If $ x $\n                                 ((\\<bind>) $\n                                  (RETURN $\n                                   (PR_CONST (ASSN_ANNOT (nbn_assn N)) $\n                                    x'a)) $\n                                  (\\<lambda>v0.\n(#RETURN $ (op_set_insert $ v0 $ \\<sigma>')#))) $\n                                 (PASS $ \\<sigma>')#)))\n 2. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma>.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty);\n        TERM monadic_nfoldli\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>f45 x xi xa x' x'a xb \\<sigma>'\n                          \\<sigma> \\<Longrightarrow>\\<^sub>t\n                         emp * hn_ctxt (?Rk'45 x xi xa x') x'a xb *\n                         hn_ctxt (?Pf\\<sigma>45 x xi xa x') \\<sigma>'\n                          \\<sigma>\n 3. \\<And>x xi xa x' xb x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty)\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt (?Rk'45 x xi xa x') x'a xb \\<or>\\<^sub>A\n                         hn_val nat_rel x'a xb \\<Longrightarrow>\\<^sub>t\n                         hn_ctxt (?Rk''45 x xi xa x') x'a xb\n 4. \\<And>x xi xa x'.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       emp * hn_ctxt (list_assn (?Rk''45 x xi xa x')) x xi *\n       hn_invalid (hs.assn ?A61) xa x' \\<Longrightarrow>\\<^sub>t\n       ?\\<Gamma>'5 x xi * hn_ctxt (?Rx39 x xi) xa x'\n 5. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       CNV (hs_new \\<bind>\n            (\\<lambda>x'.\n                imp_nfoldli xi (\\<lambda>\\<sigma>. return True)\n                 (?f48 x xi x') x'))\n        (?fi4 xi)\n 6. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn nat_assn) x xi\n 7. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (hs.assn ?A61) a c \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (hs.assn (nbn_assn N)) a c\n 8. CONSTRAINT_SLOT (True)", "apply sepref_dbg_trans_step"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma>.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (emp * hn_val nat_rel x'a xb *\n                           hn_ctxt (hs.assn ?A61) \\<sigma>' \\<sigma>)\n                          (?m'75 x xi x' xb \\<sigma>)\n                          (?\\<Gamma>1.74 x xi xa x' x'a xb \\<sigma>'\n                            \\<sigma>)\n                          (?Rh74 x xi xa x' x'a xb \\<sigma>' \\<sigma>)\n                          ((\\<bind>) $ (RETURN $ N) $\n                           (\\<lambda>v1. (#RETURN $ ((<) $ x'a $ v1)#)))\n 2. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> xc x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x;\n        bind_ref_tag xc\n         ((\\<bind>) $ (RETURN $ N) $\n          (\\<lambda>v1. (#RETURN $ ((<) $ x'a $ v1)#)))\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?\\<Gamma>1.74 x xi xa x' x'a xb \\<sigma>'\n                            \\<sigma> *\n                           hn_ctxt\n                            (?Rh74 x xi xa x' x'a xb \\<sigma>' \\<sigma>) xc\n                            x'b)\n                          (?f'76 x xi x' xb \\<sigma> x'b)\n                          (?\\<Gamma>2.74 x xi xa x' x'a xb \\<sigma>'\n                            \\<sigma> xc x'b)\n                          (hs.assn ?A61)\n                          (If $ xc $\n                           ((\\<bind>) $\n                            (RETURN $\n                             (PR_CONST (ASSN_ANNOT (nbn_assn N)) $ x'a)) $\n                            (\\<lambda>v0.\n                                (#RETURN $\n                                  (op_set_insert $ v0 $ \\<sigma>')#))) $\n                           (PASS $ \\<sigma>'))\n 3. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> xc x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.74 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          xc x'b \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>f45 x xi xa x' x'a xb \\<sigma>' \\<sigma> *\n                         hn_ctxt\n                          (?Rx74 x xi xa x' x'a xb \\<sigma>' \\<sigma>) xc\n                          x'b\n 4. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma>.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty);\n        TERM monadic_nfoldli\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>f45 x xi xa x' x'a xb \\<sigma>'\n                          \\<sigma> \\<Longrightarrow>\\<^sub>t\n                         emp * hn_ctxt (?Rk'45 x xi xa x') x'a xb *\n                         hn_ctxt (?Pf\\<sigma>45 x xi xa x') \\<sigma>'\n                          \\<sigma>\n 5. \\<And>x xi xa x' xb x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty)\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt (?Rk'45 x xi xa x') x'a xb \\<or>\\<^sub>A\n                         hn_val nat_rel x'a xb \\<Longrightarrow>\\<^sub>t\n                         hn_ctxt (?Rk''45 x xi xa x') x'a xb\n 6. \\<And>x xi xa x'.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       emp * hn_ctxt (list_assn (?Rk''45 x xi xa x')) x xi *\n       hn_invalid (hs.assn ?A61) xa x' \\<Longrightarrow>\\<^sub>t\n       ?\\<Gamma>'5 x xi * hn_ctxt (?Rx39 x xi) xa x'\n 7. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       CNV (hs_new \\<bind>\n            (\\<lambda>x'.\n                imp_nfoldli xi (\\<lambda>\\<sigma>. return True)\n                 (\\<lambda>xb \\<sigma>.\n                     ?m'75 x xi x' xb \\<sigma> \\<bind>\n                     ?f'76 x xi x' xb \\<sigma>)\n                 x'))\n        (?fi4 xi)\n 8. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn nat_assn) x xi\n 9. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (hs.assn ?A61) a c \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (hs.assn (nbn_assn N)) a c\n 10. CONSTRAINT_SLOT (True)", "apply sepref_dbg_trans_step"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma>.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (emp * hn_val nat_rel x'a xb *\n                           hn_ctxt (hs.assn ?A61) \\<sigma>' \\<sigma>)\n                          (?m'78 x xi x' xb \\<sigma>)\n                          (?\\<Gamma>1.77 x xi xa x' x'a xb \\<sigma>'\n                            \\<sigma>)\n                          (?Rh77 x xi xa x' x'a xb \\<sigma>' \\<sigma>)\n                          (RETURN $ N)\n 2. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> v1 x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x;\n        bind_ref_tag v1 (RETURN $ N)\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?\\<Gamma>1.77 x xi xa x' x'a xb \\<sigma>'\n                            \\<sigma> *\n                           hn_ctxt\n                            (?Rh77 x xi xa x' x'a xb \\<sigma>' \\<sigma>) v1\n                            x'b)\n                          (?f'79 x xi x' xb \\<sigma> x'b)\n                          (?\\<Gamma>2.77 x xi xa x' x'a xb \\<sigma>'\n                            \\<sigma> v1 x'b)\n                          (?Rh74 x xi xa x' x'a xb \\<sigma>' \\<sigma>)\n                          (RETURN $ ((<) $ x'a $ v1))\n 3. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> v1 x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.77 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          v1 x'b \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>1.74 x xi xa x' x'a xb \\<sigma>'\n                          \\<sigma> *\n                         hn_ctxt\n                          (?Rx77 x xi xa x' x'a xb \\<sigma>' \\<sigma>) v1\n                          x'b\n 4. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> xc x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x;\n        bind_ref_tag xc\n         ((\\<bind>) $ (RETURN $ N) $\n          (\\<lambda>v1. (#RETURN $ ((<) $ x'a $ v1)#)))\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?\\<Gamma>1.74 x xi xa x' x'a xb \\<sigma>'\n                            \\<sigma> *\n                           hn_ctxt\n                            (?Rh74 x xi xa x' x'a xb \\<sigma>' \\<sigma>) xc\n                            x'b)\n                          (?f'76 x xi x' xb \\<sigma> x'b)\n                          (?\\<Gamma>2.74 x xi xa x' x'a xb \\<sigma>'\n                            \\<sigma> xc x'b)\n                          (hs.assn ?A61)\n                          (If $ xc $\n                           ((\\<bind>) $\n                            (RETURN $\n                             (PR_CONST (ASSN_ANNOT (nbn_assn N)) $ x'a)) $\n                            (\\<lambda>v0.\n                                (#RETURN $\n                                  (op_set_insert $ v0 $ \\<sigma>')#))) $\n                           (PASS $ \\<sigma>'))\n 5. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> xc x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.74 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          xc x'b \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>f45 x xi xa x' x'a xb \\<sigma>' \\<sigma> *\n                         hn_ctxt\n                          (?Rx74 x xi xa x' x'a xb \\<sigma>' \\<sigma>) xc\n                          x'b\n 6. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma>.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty);\n        TERM monadic_nfoldli\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>f45 x xi xa x' x'a xb \\<sigma>'\n                          \\<sigma> \\<Longrightarrow>\\<^sub>t\n                         emp * hn_ctxt (?Rk'45 x xi xa x') x'a xb *\n                         hn_ctxt (?Pf\\<sigma>45 x xi xa x') \\<sigma>'\n                          \\<sigma>\n 7. \\<And>x xi xa x' xb x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty)\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt (?Rk'45 x xi xa x') x'a xb \\<or>\\<^sub>A\n                         hn_val nat_rel x'a xb \\<Longrightarrow>\\<^sub>t\n                         hn_ctxt (?Rk''45 x xi xa x') x'a xb\n 8. \\<And>x xi xa x'.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       emp * hn_ctxt (list_assn (?Rk''45 x xi xa x')) x xi *\n       hn_invalid (hs.assn ?A61) xa x' \\<Longrightarrow>\\<^sub>t\n       ?\\<Gamma>'5 x xi * hn_ctxt (?Rx39 x xi) xa x'\n 9. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       CNV (hs_new \\<bind>\n            (\\<lambda>x'.\n                imp_nfoldli xi (\\<lambda>\\<sigma>. return True)\n                 (\\<lambda>xb \\<sigma>.\n                     ?m'78 x xi x' xb \\<sigma> \\<bind>\n                     ?f'79 x xi x' xb \\<sigma> \\<bind>\n                     ?f'76 x xi x' xb \\<sigma>)\n                 x'))\n        (?fi4 xi)\n 10. \\<And>x xi.\n        x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n        ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n        hn_ctxt (list_assn nat_assn) x xi\nA total of 12 subgoals...", "apply sepref_dbg_trans_step"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> v1 x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x;\n        bind_ref_tag v1 (RETURN $ N)\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (hs.assn ?A61) \\<sigma>' \\<sigma> *\n                           hn_val nat_rel x'a xb *\n                           emp *\n                           hn_val nat_rel v1 x'b)\n                          (?f'79 x xi x' xb \\<sigma> x'b)\n                          (?\\<Gamma>2.77 x xi xa x' x'a xb \\<sigma>'\n                            \\<sigma> v1 x'b)\n                          (?Rh74 x xi xa x' x'a xb \\<sigma>' \\<sigma>)\n                          (RETURN $ ((<) $ x'a $ v1))\n 2. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> v1 x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.77 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          v1 x'b \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>1.74 x xi xa x' x'a xb \\<sigma>'\n                          \\<sigma> *\n                         hn_ctxt\n                          (?Rx77 x xi xa x' x'a xb \\<sigma>' \\<sigma>) v1\n                          x'b\n 3. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> xc x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x;\n        bind_ref_tag xc\n         ((\\<bind>) $ (RETURN $ N) $\n          (\\<lambda>v1. (#RETURN $ ((<) $ x'a $ v1)#)))\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?\\<Gamma>1.74 x xi xa x' x'a xb \\<sigma>'\n                            \\<sigma> *\n                           hn_ctxt\n                            (?Rh74 x xi xa x' x'a xb \\<sigma>' \\<sigma>) xc\n                            x'b)\n                          (?f'76 x xi x' xb \\<sigma> x'b)\n                          (?\\<Gamma>2.74 x xi xa x' x'a xb \\<sigma>'\n                            \\<sigma> xc x'b)\n                          (hs.assn ?A61)\n                          (If $ xc $\n                           ((\\<bind>) $\n                            (RETURN $\n                             (PR_CONST (ASSN_ANNOT (nbn_assn N)) $ x'a)) $\n                            (\\<lambda>v0.\n                                (#RETURN $\n                                  (op_set_insert $ v0 $ \\<sigma>')#))) $\n                           (PASS $ \\<sigma>'))\n 4. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> xc x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.74 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          xc x'b \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>f45 x xi xa x' x'a xb \\<sigma>' \\<sigma> *\n                         hn_ctxt\n                          (?Rx74 x xi xa x' x'a xb \\<sigma>' \\<sigma>) xc\n                          x'b\n 5. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma>.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty);\n        TERM monadic_nfoldli\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>f45 x xi xa x' x'a xb \\<sigma>'\n                          \\<sigma> \\<Longrightarrow>\\<^sub>t\n                         emp * hn_ctxt (?Rk'45 x xi xa x') x'a xb *\n                         hn_ctxt (?Pf\\<sigma>45 x xi xa x') \\<sigma>'\n                          \\<sigma>\n 6. \\<And>x xi xa x' xb x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty)\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt (?Rk'45 x xi xa x') x'a xb \\<or>\\<^sub>A\n                         hn_val nat_rel x'a xb \\<Longrightarrow>\\<^sub>t\n                         hn_ctxt (?Rk''45 x xi xa x') x'a xb\n 7. \\<And>x xi xa x'.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       emp * hn_ctxt (list_assn (?Rk''45 x xi xa x')) x xi *\n       hn_invalid (hs.assn ?A61) xa x' \\<Longrightarrow>\\<^sub>t\n       ?\\<Gamma>'5 x xi * hn_ctxt (?Rx39 x xi) xa x'\n 8. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       CNV (hs_new \\<bind>\n            (\\<lambda>x'.\n                imp_nfoldli xi (\\<lambda>\\<sigma>. return True)\n                 (\\<lambda>xb \\<sigma>.\n                     return N \\<bind> ?f'79 x xi x' xb \\<sigma> \\<bind>\n                     ?f'76 x xi x' xb \\<sigma>)\n                 x'))\n        (?fi4 xi)\n 9. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn nat_assn) x xi\n 10. \\<And>x xi a c.\n        x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n        hn_ctxt (hs.assn ?A61) a c \\<Longrightarrow>\\<^sub>t\n        hn_ctxt (hs.assn (nbn_assn N)) a c\nA total of 11 subgoals...", "apply sepref_dbg_trans_step"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> v1 x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt (hs.assn ?A61) \\<sigma>' \\<sigma> *\n                         (hn_val nat_rel x'a xb *\n                          hn_val nat_rel v1 x'b) \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>1.74 x xi xa x' x'a xb \\<sigma>'\n                          \\<sigma> *\n                         hn_ctxt\n                          (?Rx77 x xi xa x' x'a xb \\<sigma>' \\<sigma>) v1\n                          x'b\n 2. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> xc x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x;\n        bind_ref_tag xc\n         ((\\<bind>) $ (RETURN $ N) $\n          (\\<lambda>v1. (#RETURN $ ((<) $ x'a $ v1)#)))\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?\\<Gamma>1.74 x xi xa x' x'a xb \\<sigma>'\n                            \\<sigma> *\n                           hn_val bool_rel xc x'b)\n                          (?f'76 x xi x' xb \\<sigma> x'b)\n                          (?\\<Gamma>2.74 x xi xa x' x'a xb \\<sigma>'\n                            \\<sigma> xc x'b)\n                          (hs.assn ?A61)\n                          (If $ xc $\n                           ((\\<bind>) $\n                            (RETURN $\n                             (PR_CONST (ASSN_ANNOT (nbn_assn N)) $ x'a)) $\n                            (\\<lambda>v0.\n                                (#RETURN $\n                                  (op_set_insert $ v0 $ \\<sigma>')#))) $\n                           (PASS $ \\<sigma>'))\n 3. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> xc x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.74 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          xc x'b \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>f45 x xi xa x' x'a xb \\<sigma>' \\<sigma> *\n                         hn_ctxt\n                          (?Rx74 x xi xa x' x'a xb \\<sigma>' \\<sigma>) xc\n                          x'b\n 4. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma>.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty);\n        TERM monadic_nfoldli\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>f45 x xi xa x' x'a xb \\<sigma>'\n                          \\<sigma> \\<Longrightarrow>\\<^sub>t\n                         emp * hn_ctxt (?Rk'45 x xi xa x') x'a xb *\n                         hn_ctxt (?Pf\\<sigma>45 x xi xa x') \\<sigma>'\n                          \\<sigma>\n 5. \\<And>x xi xa x' xb x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty)\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt (?Rk'45 x xi xa x') x'a xb \\<or>\\<^sub>A\n                         hn_val nat_rel x'a xb \\<Longrightarrow>\\<^sub>t\n                         hn_ctxt (?Rk''45 x xi xa x') x'a xb\n 6. \\<And>x xi xa x'.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       emp * hn_ctxt (list_assn (?Rk''45 x xi xa x')) x xi *\n       hn_invalid (hs.assn ?A61) xa x' \\<Longrightarrow>\\<^sub>t\n       ?\\<Gamma>'5 x xi * hn_ctxt (?Rx39 x xi) xa x'\n 7. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       CNV (hs_new \\<bind>\n            (\\<lambda>x'.\n                imp_nfoldli xi (\\<lambda>\\<sigma>. return True)\n                 (\\<lambda>xb \\<sigma>.\n                     return N \\<bind>\n                     (\\<lambda>x'b. return (xb < x'b)) \\<bind>\n                     ?f'76 x xi x' xb \\<sigma>)\n                 x'))\n        (?fi4 xi)\n 8. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn nat_assn) x xi\n 9. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (hs.assn ?A61) a c \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (hs.assn (nbn_assn N)) a c\n 10. CONSTRAINT_SLOT (True)", "apply sepref_dbg_trans_step"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> xc x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x;\n        bind_ref_tag xc\n         ((\\<bind>) $ (RETURN $ N) $\n          (\\<lambda>v1. (#RETURN $ ((<) $ x'a $ v1)#)))\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (hs.assn ?A105) \\<sigma>' \\<sigma> *\n                           hn_val nat_rel x'a xb *\n                           hn_val bool_rel xc x'b)\n                          (?f'76 x xi x' xb \\<sigma> x'b)\n                          (?\\<Gamma>2.74 x xi xa x' x'a xb \\<sigma>'\n                            \\<sigma> xc x'b)\n                          (hs.assn ?A105)\n                          (If $ xc $\n                           ((\\<bind>) $\n                            (RETURN $\n                             (PR_CONST (ASSN_ANNOT (nbn_assn N)) $ x'a)) $\n                            (\\<lambda>v0.\n                                (#RETURN $\n                                  (op_set_insert $ v0 $ \\<sigma>')#))) $\n                           (PASS $ \\<sigma>'))\n 2. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> xc x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.74 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          xc x'b \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>f45 x xi xa x' x'a xb \\<sigma>' \\<sigma> *\n                         hn_ctxt\n                          (?Rx74 x xi xa x' x'a xb \\<sigma>' \\<sigma>) xc\n                          x'b\n 3. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma>.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty);\n        TERM monadic_nfoldli\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>f45 x xi xa x' x'a xb \\<sigma>'\n                          \\<sigma> \\<Longrightarrow>\\<^sub>t\n                         emp * hn_ctxt (?Rk'45 x xi xa x') x'a xb *\n                         hn_ctxt (?Pf\\<sigma>45 x xi xa x') \\<sigma>'\n                          \\<sigma>\n 4. \\<And>x xi xa x' xb x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty)\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt (?Rk'45 x xi xa x') x'a xb \\<or>\\<^sub>A\n                         hn_val nat_rel x'a xb \\<Longrightarrow>\\<^sub>t\n                         hn_ctxt (?Rk''45 x xi xa x') x'a xb\n 5. \\<And>x xi xa x'.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       emp * hn_ctxt (list_assn (?Rk''45 x xi xa x')) x xi *\n       hn_invalid (hs.assn ?A105) xa x' \\<Longrightarrow>\\<^sub>t\n       ?\\<Gamma>'5 x xi * hn_ctxt (?Rx39 x xi) xa x'\n 6. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       CNV (hs_new \\<bind>\n            (\\<lambda>x'.\n                imp_nfoldli xi (\\<lambda>\\<sigma>. return True)\n                 (\\<lambda>xb \\<sigma>.\n                     return N \\<bind>\n                     (\\<lambda>x'b. return (xb < x'b)) \\<bind>\n                     ?f'76 x xi x' xb \\<sigma>)\n                 x'))\n        (?fi4 xi)\n 7. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn nat_assn) x xi\n 8. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (hs.assn ?A105) a c \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (hs.assn (nbn_assn N)) a c\n 9. CONSTRAINT_SLOT (True)", "apply sepref_dbg_trans_step"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> xc x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x;\n        bind_ref_tag xc\n         ((\\<bind>) $ (RETURN $ N) $\n          (\\<lambda>v1. (#RETURN $ ((<) $ x'a $ v1)#)))\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt (hs.assn ?A105) \\<sigma>' \\<sigma> *\n                         hn_val nat_rel x'a xb *\n                         hn_val bool_rel xc x'b \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>1.106 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          xc x'b *\n                         hn_val bool_rel xc (?a'107 x xi x' xb \\<sigma> x'b)\n 2. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> xc x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x;\n        bind_ref_tag xc\n         ((\\<bind>) $ (RETURN $ N) $\n          (\\<lambda>v1. (#RETURN $ ((<) $ x'a $ v1)#)));\n        xc\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?\\<Gamma>1.106 x xi xa x' x'a xb \\<sigma>'\n                            \\<sigma> xc x'b *\n                           hn_val bool_rel xc\n                            (?a'107 x xi x' xb \\<sigma> x'b))\n                          (?b'108 x xi x' xb \\<sigma> x'b)\n                          (?\\<Gamma>2b106 x xi xa x' x'a xb \\<sigma>'\n                            \\<sigma> xc x'b)\n                          (hs.assn ?A105)\n                          ((\\<bind>) $\n                           (RETURN $\n                            (PR_CONST (ASSN_ANNOT (nbn_assn N)) $ x'a)) $\n                           (\\<lambda>v0.\n                               (#RETURN $\n                                 (op_set_insert $ v0 $ \\<sigma>')#)))\n 3. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> xc x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x;\n        bind_ref_tag xc\n         ((\\<bind>) $ (RETURN $ N) $\n          (\\<lambda>v1. (#RETURN $ ((<) $ x'a $ v1)#)));\n        \\<not> xc\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?\\<Gamma>1.106 x xi xa x' x'a xb \\<sigma>'\n                            \\<sigma> xc x'b *\n                           hn_val bool_rel xc\n                            (?a'107 x xi x' xb \\<sigma> x'b))\n                          (?c'109 x xi x' xb \\<sigma> x'b)\n                          (?\\<Gamma>2c106 x xi xa x' x'a xb \\<sigma>'\n                            \\<sigma> xc x'b)\n                          (hs.assn ?A105) (PASS $ \\<sigma>')\n 4. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> xc x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x;\n        bind_ref_tag xc\n         ((\\<bind>) $ (RETURN $ N) $\n          (\\<lambda>v1. (#RETURN $ ((<) $ x'a $ v1)#)));\n        TERM If\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2b106 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          xc x'b \\<or>\\<^sub>A\n                         ?\\<Gamma>2c106 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          xc x'b \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.74 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          xc x'b\n 5. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> xc x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.74 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          xc x'b \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>f45 x xi xa x' x'a xb \\<sigma>' \\<sigma> *\n                         hn_ctxt\n                          (?Rx74 x xi xa x' x'a xb \\<sigma>' \\<sigma>) xc\n                          x'b\n 6. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma>.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty);\n        TERM monadic_nfoldli\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>f45 x xi xa x' x'a xb \\<sigma>'\n                          \\<sigma> \\<Longrightarrow>\\<^sub>t\n                         emp * hn_ctxt (?Rk'45 x xi xa x') x'a xb *\n                         hn_ctxt (?Pf\\<sigma>45 x xi xa x') \\<sigma>'\n                          \\<sigma>\n 7. \\<And>x xi xa x' xb x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty)\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt (?Rk'45 x xi xa x') x'a xb \\<or>\\<^sub>A\n                         hn_val nat_rel x'a xb \\<Longrightarrow>\\<^sub>t\n                         hn_ctxt (?Rk''45 x xi xa x') x'a xb\n 8. \\<And>x xi xa x'.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       emp * hn_ctxt (list_assn (?Rk''45 x xi xa x')) x xi *\n       hn_invalid (hs.assn ?A105) xa x' \\<Longrightarrow>\\<^sub>t\n       ?\\<Gamma>'5 x xi * hn_ctxt (?Rx39 x xi) xa x'\n 9. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       CNV (hs_new \\<bind>\n            (\\<lambda>x'.\n                imp_nfoldli xi (\\<lambda>\\<sigma>. return True)\n                 (\\<lambda>xb \\<sigma>.\n                     return N \\<bind>\n                     (\\<lambda>x'b. return (xb < x'b)) \\<bind>\n                     (\\<lambda>x'b.\n                         if ?a'107 x xi x' xb \\<sigma> x'b\n                         then ?b'108 x xi x' xb \\<sigma> x'b\n                         else ?c'109 x xi x' xb \\<sigma> x'b))\n                 x'))\n        (?fi4 xi)\n 10. \\<And>x xi.\n        x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n        ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n        hn_ctxt (list_assn nat_assn) x xi\nA total of 12 subgoals...", "apply sepref_dbg_trans_step"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> xc x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x;\n        bind_ref_tag xc\n         ((\\<bind>) $ (RETURN $ N) $\n          (\\<lambda>v1. (#RETURN $ ((<) $ x'a $ v1)#)));\n        xc\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (hs.assn ?A105) \\<sigma>' \\<sigma> *\n                           hn_val nat_rel x'a xb *\n                           hn_val bool_rel xc x'b)\n                          (?b'108 x xi x' xb \\<sigma> x'b)\n                          (?\\<Gamma>2b106 x xi xa x' x'a xb \\<sigma>'\n                            \\<sigma> xc x'b)\n                          (hs.assn ?A105)\n                          ((\\<bind>) $\n                           (RETURN $\n                            (PR_CONST (ASSN_ANNOT (nbn_assn N)) $ x'a)) $\n                           (\\<lambda>v0.\n                               (#RETURN $\n                                 (op_set_insert $ v0 $ \\<sigma>')#)))\n 2. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> xc x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x;\n        bind_ref_tag xc\n         ((\\<bind>) $ (RETURN $ N) $\n          (\\<lambda>v1. (#RETURN $ ((<) $ x'a $ v1)#)));\n        \\<not> xc\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (hs.assn ?A105) \\<sigma>' \\<sigma> *\n                           hn_val nat_rel x'a xb *\n                           hn_val bool_rel xc x'b)\n                          (?c'109 x xi x' xb \\<sigma> x'b)\n                          (?\\<Gamma>2c106 x xi xa x' x'a xb \\<sigma>'\n                            \\<sigma> xc x'b)\n                          (hs.assn ?A105) (PASS $ \\<sigma>')\n 3. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> xc x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x;\n        bind_ref_tag xc\n         ((\\<bind>) $ (RETURN $ N) $\n          (\\<lambda>v1. (#RETURN $ ((<) $ x'a $ v1)#)));\n        TERM If\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2b106 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          xc x'b \\<or>\\<^sub>A\n                         ?\\<Gamma>2c106 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          xc x'b \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.74 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          xc x'b\n 4. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> xc x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.74 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          xc x'b \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>f45 x xi xa x' x'a xb \\<sigma>' \\<sigma> *\n                         hn_ctxt\n                          (?Rx74 x xi xa x' x'a xb \\<sigma>' \\<sigma>) xc\n                          x'b\n 5. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma>.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty);\n        TERM monadic_nfoldli\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>f45 x xi xa x' x'a xb \\<sigma>'\n                          \\<sigma> \\<Longrightarrow>\\<^sub>t\n                         emp * hn_ctxt (?Rk'45 x xi xa x') x'a xb *\n                         hn_ctxt (?Pf\\<sigma>45 x xi xa x') \\<sigma>'\n                          \\<sigma>\n 6. \\<And>x xi xa x' xb x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty)\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt (?Rk'45 x xi xa x') x'a xb \\<or>\\<^sub>A\n                         hn_val nat_rel x'a xb \\<Longrightarrow>\\<^sub>t\n                         hn_ctxt (?Rk''45 x xi xa x') x'a xb\n 7. \\<And>x xi xa x'.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       emp * hn_ctxt (list_assn (?Rk''45 x xi xa x')) x xi *\n       hn_invalid (hs.assn ?A105) xa x' \\<Longrightarrow>\\<^sub>t\n       ?\\<Gamma>'5 x xi * hn_ctxt (?Rx39 x xi) xa x'\n 8. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       CNV (hs_new \\<bind>\n            (\\<lambda>x'.\n                imp_nfoldli xi (\\<lambda>\\<sigma>. return True)\n                 (\\<lambda>xb \\<sigma>.\n                     return N \\<bind>\n                     (\\<lambda>x'b. return (xb < x'b)) \\<bind>\n                     (\\<lambda>x'b.\n                         if x'b then ?b'108 x xi x' xb \\<sigma> x'b\n                         else ?c'109 x xi x' xb \\<sigma> x'b))\n                 x'))\n        (?fi4 xi)\n 9. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn nat_assn) x xi\n 10. \\<And>x xi a c.\n        x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n        hn_ctxt (hs.assn ?A105) a c \\<Longrightarrow>\\<^sub>t\n        hn_ctxt (hs.assn (nbn_assn N)) a c\nA total of 11 subgoals...", "apply sepref_dbg_trans_step\n    \\<comment> \\<open>At this point, we arrived at the \\<open>nbn_rel\\<close> annotation. \n      There is enough information to show \\<open>x'a < N\\<close>\\<close>"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> xc x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x;\n        bind_ref_tag xc\n         ((\\<bind>) $ (RETURN $ N) $\n          (\\<lambda>v1. (#RETURN $ ((<) $ x'a $ v1)#)));\n        xc\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (hs.assn ?A105) \\<sigma>' \\<sigma> *\n                           hn_val nat_rel x'a xb *\n                           hn_val bool_rel xc x'b)\n                          (?m'118 x xi x' xb \\<sigma> x'b)\n                          (?\\<Gamma>1.117 x xi xa x' x'a xb \\<sigma>'\n                            \\<sigma> xc x'b)\n                          (?Rh117 x xi xa x' x'a xb \\<sigma>' \\<sigma> xc\n                            x'b)\n                          (RETURN $\n                           (PR_CONST (ASSN_ANNOT (nbn_assn N)) $ x'a))\n 2. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> xc x'b v0 x'c.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x;\n        bind_ref_tag xc\n         ((\\<bind>) $ (RETURN $ N) $\n          (\\<lambda>v1. (#RETURN $ ((<) $ x'a $ v1)#)));\n        xc;\n        bind_ref_tag v0\n         (RETURN $ (PR_CONST (ASSN_ANNOT (nbn_assn N)) $ x'a))\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?\\<Gamma>1.117 x xi xa x' x'a xb \\<sigma>'\n                            \\<sigma> xc x'b *\n                           hn_ctxt\n                            (?Rh117 x xi xa x' x'a xb \\<sigma>' \\<sigma> xc\n                              x'b)\n                            v0 x'c)\n                          (?f'119 x xi x' xb \\<sigma> x'b x'c)\n                          (?\\<Gamma>2.117 x xi xa x' x'a xb \\<sigma>'\n                            \\<sigma> xc x'b v0 x'c)\n                          (hs.assn ?A105)\n                          (RETURN $ (op_set_insert $ v0 $ \\<sigma>'))\n 3. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> xc x'b v0 x'c.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x;\n        bind_ref_tag xc\n         ((\\<bind>) $ (RETURN $ N) $\n          (\\<lambda>v1. (#RETURN $ ((<) $ x'a $ v1)#)));\n        xc\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.117 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          xc x'b v0 x'c \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2b106 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          xc x'b *\n                         hn_ctxt\n                          (?Rx117 x xi xa x' x'a xb \\<sigma>' \\<sigma> xc\n                            x'b)\n                          v0 x'c\n 4. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> xc x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x;\n        bind_ref_tag xc\n         ((\\<bind>) $ (RETURN $ N) $\n          (\\<lambda>v1. (#RETURN $ ((<) $ x'a $ v1)#)));\n        \\<not> xc\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (hs.assn ?A105) \\<sigma>' \\<sigma> *\n                           hn_val nat_rel x'a xb *\n                           hn_val bool_rel xc x'b)\n                          (?c'109 x xi x' xb \\<sigma> x'b)\n                          (?\\<Gamma>2c106 x xi xa x' x'a xb \\<sigma>'\n                            \\<sigma> xc x'b)\n                          (hs.assn ?A105) (PASS $ \\<sigma>')\n 5. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> xc x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x;\n        bind_ref_tag xc\n         ((\\<bind>) $ (RETURN $ N) $\n          (\\<lambda>v1. (#RETURN $ ((<) $ x'a $ v1)#)));\n        TERM If\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2b106 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          xc x'b \\<or>\\<^sub>A\n                         ?\\<Gamma>2c106 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          xc x'b \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.74 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          xc x'b\n 6. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> xc x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.74 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          xc x'b \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>f45 x xi xa x' x'a xb \\<sigma>' \\<sigma> *\n                         hn_ctxt\n                          (?Rx74 x xi xa x' x'a xb \\<sigma>' \\<sigma>) xc\n                          x'b\n 7. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma>.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty);\n        TERM monadic_nfoldli\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>f45 x xi xa x' x'a xb \\<sigma>'\n                          \\<sigma> \\<Longrightarrow>\\<^sub>t\n                         emp * hn_ctxt (?Rk'45 x xi xa x') x'a xb *\n                         hn_ctxt (?Pf\\<sigma>45 x xi xa x') \\<sigma>'\n                          \\<sigma>\n 8. \\<And>x xi xa x' xb x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty)\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt (?Rk'45 x xi xa x') x'a xb \\<or>\\<^sub>A\n                         hn_val nat_rel x'a xb \\<Longrightarrow>\\<^sub>t\n                         hn_ctxt (?Rk''45 x xi xa x') x'a xb\n 9. \\<And>x xi xa x'.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       emp * hn_ctxt (list_assn (?Rk''45 x xi xa x')) x xi *\n       hn_invalid (hs.assn ?A105) xa x' \\<Longrightarrow>\\<^sub>t\n       ?\\<Gamma>'5 x xi * hn_ctxt (?Rx39 x xi) xa x'\n 10. \\<And>x xi.\n        x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n        CNV (hs_new \\<bind>\n             (\\<lambda>x'.\n                 imp_nfoldli xi (\\<lambda>\\<sigma>. return True)\n                  (\\<lambda>xb \\<sigma>.\n                      return N \\<bind>\n                      (\\<lambda>x'b. return (xb < x'b)) \\<bind>\n                      (\\<lambda>x'b.\n                          if x'b\n                          then ?m'118 x xi x' xb \\<sigma> x'b \\<bind>\n                               ?f'119 x xi x' xb \\<sigma> x'b\n                          else ?c'109 x xi x' xb \\<sigma> x'b))\n                  x'))\n         (?fi4 xi)\nA total of 13 subgoals...", "apply sepref_dbg_trans_step"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> xc x'b v0 x'c.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x;\n        bind_ref_tag xc\n         ((\\<bind>) $ (RETURN $ N) $\n          (\\<lambda>v1. (#RETURN $ ((<) $ x'a $ v1)#)));\n        xc;\n        bind_ref_tag v0\n         (RETURN $ (PR_CONST (ASSN_ANNOT (nbn_assn N)) $ x'a))\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_val bool_rel xc x'b *\n                           hn_ctxt (hs.assn ?A4) \\<sigma>' \\<sigma> *\n                           hn_invalid (nbn_assn N) x'a xb *\n                           hn_ctxt (nbn_assn N) v0 x'c)\n                          (?f'4 x xi x' xb \\<sigma> x'b x'c)\n                          (?\\<Gamma>2.4 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                            xc x'b v0 x'c)\n                          (hs.assn ?A4)\n                          (RETURN $ (op_set_insert $ v0 $ \\<sigma>'))\n 2. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> xc x'b v0 x'c.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x;\n        bind_ref_tag xc\n         ((\\<bind>) $ (RETURN $ N) $\n          (\\<lambda>v1. (#RETURN $ ((<) $ x'a $ v1)#)));\n        xc\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.4 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          xc x'b v0 x'c \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2b4 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          xc x'b *\n                         hn_ctxt\n                          (?Rx4 x xi xa x' x'a xb \\<sigma>' \\<sigma> xc x'b)\n                          v0 x'c\n 3. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> xc x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x;\n        bind_ref_tag xc\n         ((\\<bind>) $ (RETURN $ N) $\n          (\\<lambda>v1. (#RETURN $ ((<) $ x'a $ v1)#)));\n        \\<not> xc\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (hs.assn ?A4) \\<sigma>' \\<sigma> *\n                           hn_val nat_rel x'a xb *\n                           hn_val bool_rel xc x'b)\n                          (?c'4 x xi x' xb \\<sigma> x'b)\n                          (?\\<Gamma>2c4 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                            xc x'b)\n                          (hs.assn ?A4) (PASS $ \\<sigma>')\n 4. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> xc x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x;\n        bind_ref_tag xc\n         ((\\<bind>) $ (RETURN $ N) $\n          (\\<lambda>v1. (#RETURN $ ((<) $ x'a $ v1)#)));\n        TERM If\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2b4 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          xc x'b \\<or>\\<^sub>A\n                         ?\\<Gamma>2c4 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          xc x'b \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2a4 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          xc x'b\n 5. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> xc x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2a4 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          xc x'b \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>f4 x xi xa x' x'a xb \\<sigma>' \\<sigma> *\n                         hn_ctxt\n                          (?Rxa4 x xi xa x' x'a xb \\<sigma>' \\<sigma>) xc\n                          x'b\n 6. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma>.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty);\n        TERM monadic_nfoldli\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>f4 x xi xa x' x'a xb \\<sigma>'\n                          \\<sigma> \\<Longrightarrow>\\<^sub>t\n                         emp * hn_ctxt (?Rk'4 x xi xa x') x'a xb *\n                         hn_ctxt (?Pf\\<sigma>4 x xi xa x') \\<sigma>'\n                          \\<sigma>\n 7. \\<And>x xi xa x' xb x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty)\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt (?Rk'4 x xi xa x') x'a xb \\<or>\\<^sub>A\n                         hn_val nat_rel x'a xb \\<Longrightarrow>\\<^sub>t\n                         hn_ctxt (?Rk''4 x xi xa x') x'a xb\n 8. \\<And>x xi xa x'.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       emp * hn_ctxt (list_assn (?Rk''4 x xi xa x')) x xi *\n       hn_invalid (hs.assn ?A4) xa x' \\<Longrightarrow>\\<^sub>t\n       ?\\<Gamma>'4 x xi * hn_ctxt (?Rxb4 x xi) xa x'\n 9. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       CNV (hs_new \\<bind>\n            (\\<lambda>x'.\n                imp_nfoldli xi (\\<lambda>\\<sigma>. return True)\n                 (\\<lambda>xb \\<sigma>.\n                     return N \\<bind>\n                     (\\<lambda>x'b. return (xb < x'b)) \\<bind>\n                     (\\<lambda>x'b.\n                         if x'b\n                         then return $ ((\\<lambda>x. x) $ xb) \\<bind>\n                              ?f'4 x xi x' xb \\<sigma> x'b\n                         else ?c'4 x xi x' xb \\<sigma> x'b))\n                 x'))\n        (?fi4 xi)\n 10. \\<And>x xi.\n        x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n        ?\\<Gamma>'4 x xi \\<Longrightarrow>\\<^sub>t\n        hn_ctxt (list_assn nat_assn) x xi\nA total of 12 subgoals...", "apply sepref_dbg_trans_step"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> xc x'b v0 x'c.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x;\n        bind_ref_tag xc\n         ((\\<bind>) $ (RETURN $ N) $\n          (\\<lambda>v1. (#RETURN $ ((<) $ x'a $ v1)#)));\n        xc\\<rbrakk>\n       \\<Longrightarrow> hn_invalid (nbn_assn N) x'a xb *\n                         hn_val bool_rel xc x'b *\n                         (hn_invalid (hs.assn (nbn_assn N)) \\<sigma>'\n                           \\<sigma> *\n                          hn_ctxt (nbn_assn N) v0\n                           x'c) \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2b7 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          xc x'b *\n                         hn_ctxt\n                          (?Rx7 x xi xa x' x'a xb \\<sigma>' \\<sigma> xc x'b)\n                          v0 x'c\n 2. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> xc x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x;\n        bind_ref_tag xc\n         ((\\<bind>) $ (RETURN $ N) $\n          (\\<lambda>v1. (#RETURN $ ((<) $ x'a $ v1)#)));\n        \\<not> xc\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (hs.assn (nbn_assn N)) \\<sigma>'\n                            \\<sigma> *\n                           hn_val nat_rel x'a xb *\n                           hn_val bool_rel xc x'b)\n                          (?c'7 x xi x' xb \\<sigma> x'b)\n                          (?\\<Gamma>2c7 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                            xc x'b)\n                          (hs.assn (nbn_assn N)) (PASS $ \\<sigma>')\n 3. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> xc x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x;\n        bind_ref_tag xc\n         ((\\<bind>) $ (RETURN $ N) $\n          (\\<lambda>v1. (#RETURN $ ((<) $ x'a $ v1)#)));\n        TERM If\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2b7 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          xc x'b \\<or>\\<^sub>A\n                         ?\\<Gamma>2c7 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          xc x'b \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2a7 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          xc x'b\n 4. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> xc x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2a7 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          xc x'b \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>f7 x xi xa x' x'a xb \\<sigma>' \\<sigma> *\n                         hn_ctxt\n                          (?Rxa7 x xi xa x' x'a xb \\<sigma>' \\<sigma>) xc\n                          x'b\n 5. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma>.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty);\n        TERM monadic_nfoldli\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>f7 x xi xa x' x'a xb \\<sigma>'\n                          \\<sigma> \\<Longrightarrow>\\<^sub>t\n                         emp * hn_ctxt (?Rk'7 x xi xa x') x'a xb *\n                         hn_ctxt (?Pf\\<sigma>7 x xi xa x') \\<sigma>'\n                          \\<sigma>\n 6. \\<And>x xi xa x' xb x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty)\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt (?Rk'7 x xi xa x') x'a xb \\<or>\\<^sub>A\n                         hn_val nat_rel x'a xb \\<Longrightarrow>\\<^sub>t\n                         hn_ctxt (?Rk''7 x xi xa x') x'a xb\n 7. \\<And>x xi xa x'.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       emp * hn_ctxt (list_assn (?Rk''7 x xi xa x')) x xi *\n       hn_invalid (hs.assn (nbn_assn N)) xa x' \\<Longrightarrow>\\<^sub>t\n       ?\\<Gamma>'7 x xi * hn_ctxt (?Rxb7 x xi) xa x'\n 8. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       CNV (hs_new \\<bind>\n            (\\<lambda>x'.\n                imp_nfoldli xi (\\<lambda>\\<sigma>. return True)\n                 (\\<lambda>xb \\<sigma>.\n                     return N \\<bind>\n                     (\\<lambda>x'b. return (xb < x'b)) \\<bind>\n                     (\\<lambda>x'b.\n                         if x'b\n                         then return $ ((\\<lambda>x. x) $ xb) \\<bind>\n                              (\\<lambda>x'c. hs_ins $ x'c $ \\<sigma>)\n                         else ?c'7 x xi x' xb \\<sigma> x'b))\n                 x'))\n        (?fi7 xi)\n 9. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'7 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn nat_assn) x xi\n 10. \\<And>x xi a c.\n        x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n        hn_ctxt (hs.assn (nbn_assn N)) a c \\<Longrightarrow>\\<^sub>t\n        hn_ctxt (hs.assn (nbn_assn N)) a c\nA total of 11 subgoals...", "apply sepref_dbg_trans_step"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> xc x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x;\n        bind_ref_tag xc\n         ((\\<bind>) $ (RETURN $ N) $\n          (\\<lambda>v1. (#RETURN $ ((<) $ x'a $ v1)#)));\n        \\<not> xc\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (hs.assn (nbn_assn N)) \\<sigma>'\n                            \\<sigma> *\n                           hn_val nat_rel x'a xb *\n                           hn_val bool_rel xc x'b)\n                          (?c'7 x xi x' xb \\<sigma> x'b)\n                          (?\\<Gamma>2c7 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                            xc x'b)\n                          (hs.assn (nbn_assn N)) (PASS $ \\<sigma>')\n 2. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> xc x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x;\n        bind_ref_tag xc\n         ((\\<bind>) $ (RETURN $ N) $\n          (\\<lambda>v1. (#RETURN $ ((<) $ x'a $ v1)#)));\n        TERM If\\<rbrakk>\n       \\<Longrightarrow> hn_invalid (nbn_assn N) x'a xb *\n                         hn_val bool_rel xc x'b *\n                         hn_invalid (hs.assn (nbn_assn N)) \\<sigma>'\n                          \\<sigma> \\<or>\\<^sub>A\n                         ?\\<Gamma>2c7 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          xc x'b \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2a7 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          xc x'b\n 3. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> xc x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2a7 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          xc x'b \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>f7 x xi xa x' x'a xb \\<sigma>' \\<sigma> *\n                         hn_ctxt\n                          (?Rxa7 x xi xa x' x'a xb \\<sigma>' \\<sigma>) xc\n                          x'b\n 4. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma>.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty);\n        TERM monadic_nfoldli\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>f7 x xi xa x' x'a xb \\<sigma>'\n                          \\<sigma> \\<Longrightarrow>\\<^sub>t\n                         emp * hn_ctxt (?Rk'7 x xi xa x') x'a xb *\n                         hn_ctxt (?Pf\\<sigma>7 x xi xa x') \\<sigma>'\n                          \\<sigma>\n 5. \\<And>x xi xa x' xb x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty)\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt (?Rk'7 x xi xa x') x'a xb \\<or>\\<^sub>A\n                         hn_val nat_rel x'a xb \\<Longrightarrow>\\<^sub>t\n                         hn_ctxt (?Rk''7 x xi xa x') x'a xb\n 6. \\<And>x xi xa x'.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       emp * hn_ctxt (list_assn (?Rk''7 x xi xa x')) x xi *\n       hn_invalid (hs.assn (nbn_assn N)) xa x' \\<Longrightarrow>\\<^sub>t\n       ?\\<Gamma>'7 x xi * hn_ctxt (?Rxb7 x xi) xa x'\n 7. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       CNV (hs_new \\<bind>\n            (\\<lambda>x'.\n                imp_nfoldli xi (\\<lambda>\\<sigma>. return True)\n                 (\\<lambda>xb \\<sigma>.\n                     return N \\<bind>\n                     (\\<lambda>x'b. return (xb < x'b)) \\<bind>\n                     (\\<lambda>x'b.\n                         if x'b\n                         then return $ ((\\<lambda>x. x) $ xb) \\<bind>\n                              (\\<lambda>x'c. hs_ins $ x'c $ \\<sigma>)\n                         else ?c'7 x xi x' xb \\<sigma> x'b))\n                 x'))\n        (?fi7 xi)\n 8. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'7 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn nat_assn) x xi\n 9. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (hs.assn (nbn_assn N)) a c \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (hs.assn (nbn_assn N)) a c\n 10. CONSTRAINT_SLOT (True)", "apply sepref_dbg_trans_step\n    \\<comment> \\<open>At this point, we have to merge the postconditions from the two if \n      branches. \\<open>nat_rel\\<close> gets merged with \\<open>invalid_assn (nbn_assn n)\\<close>, \n      yielding \\<open>invalid_assn nat_assn\\<close>\\<close>"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> xc x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x;\n        bind_ref_tag xc\n         ((\\<bind>) $ (RETURN $ N) $\n          (\\<lambda>v1. (#RETURN $ ((<) $ x'a $ v1)#)));\n        TERM If\\<rbrakk>\n       \\<Longrightarrow> hn_invalid (nbn_assn N) x'a xb *\n                         hn_val bool_rel xc x'b *\n                         hn_invalid (hs.assn (nbn_assn N)) \\<sigma>'\n                          \\<sigma> \\<or>\\<^sub>A\n                         hn_val bool_rel xc x'b * hn_val nat_rel x'a xb *\n                         hn_invalid (hs.assn (nbn_assn N)) \\<sigma>'\n                          \\<sigma> \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2a7 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          xc x'b\n 2. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> xc x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2a7 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          xc x'b \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>f7 x xi xa x' x'a xb \\<sigma>' \\<sigma> *\n                         hn_ctxt\n                          (?Rxa7 x xi xa x' x'a xb \\<sigma>' \\<sigma>) xc\n                          x'b\n 3. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma>.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty);\n        TERM monadic_nfoldli\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>f7 x xi xa x' x'a xb \\<sigma>'\n                          \\<sigma> \\<Longrightarrow>\\<^sub>t\n                         emp * hn_ctxt (?Rk'7 x xi xa x') x'a xb *\n                         hn_ctxt (?Pf\\<sigma>7 x xi xa x') \\<sigma>'\n                          \\<sigma>\n 4. \\<And>x xi xa x' xb x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty)\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt (?Rk'7 x xi xa x') x'a xb \\<or>\\<^sub>A\n                         hn_val nat_rel x'a xb \\<Longrightarrow>\\<^sub>t\n                         hn_ctxt (?Rk''7 x xi xa x') x'a xb\n 5. \\<And>x xi xa x'.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       emp * hn_ctxt (list_assn (?Rk''7 x xi xa x')) x xi *\n       hn_invalid (hs.assn (nbn_assn N)) xa x' \\<Longrightarrow>\\<^sub>t\n       ?\\<Gamma>'7 x xi * hn_ctxt (?Rxb7 x xi) xa x'\n 6. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       CNV (hs_new \\<bind>\n            imp_nfoldli xi (\\<lambda>\\<sigma>. return True)\n             (\\<lambda>xb \\<sigma>.\n                 return N \\<bind> (\\<lambda>x'b. return (xb < x'b)) \\<bind>\n                 (\\<lambda>x'b.\n                     if x'b\n                     then return $ ((\\<lambda>x. x) $ xb) \\<bind>\n                          (\\<lambda>x'c. hs_ins $ x'c $ \\<sigma>)\n                     else return \\<sigma>)))\n        (?fi7 xi)\n 7. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'7 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn nat_assn) x xi\n 8. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (hs.assn (nbn_assn N)) a c \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (hs.assn (nbn_assn N)) a c\n 9. CONSTRAINT_SLOT (True)", "apply sepref_dbg_trans_step"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> xc x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty); x'a \\<in> set x\\<rbrakk>\n       \\<Longrightarrow> hn_val bool_rel xc x'b *\n                         hn_invalid (hs.assn (nbn_assn N)) \\<sigma>'\n                          \\<sigma> *\n                         hn_invalid nat_assn x'a\n                          xb \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>f7 x xi xa x' x'a xb \\<sigma>' \\<sigma> *\n                         hn_ctxt\n                          (?Rxa7 x xi xa x' x'a xb \\<sigma>' \\<sigma>) xc\n                          x'b\n 2. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma>.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty);\n        TERM monadic_nfoldli\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>f7 x xi xa x' x'a xb \\<sigma>'\n                          \\<sigma> \\<Longrightarrow>\\<^sub>t\n                         emp * hn_ctxt (?Rk'7 x xi xa x') x'a xb *\n                         hn_ctxt (?Pf\\<sigma>7 x xi xa x') \\<sigma>'\n                          \\<sigma>\n 3. \\<And>x xi xa x' xb x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty)\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt (?Rk'7 x xi xa x') x'a xb \\<or>\\<^sub>A\n                         hn_val nat_rel x'a xb \\<Longrightarrow>\\<^sub>t\n                         hn_ctxt (?Rk''7 x xi xa x') x'a xb\n 4. \\<And>x xi xa x'.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       emp * hn_ctxt (list_assn (?Rk''7 x xi xa x')) x xi *\n       hn_invalid (hs.assn (nbn_assn N)) xa x' \\<Longrightarrow>\\<^sub>t\n       ?\\<Gamma>'7 x xi * hn_ctxt (?Rxb7 x xi) xa x'\n 5. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       CNV (hs_new \\<bind>\n            imp_nfoldli xi (\\<lambda>\\<sigma>. return True)\n             (\\<lambda>xb \\<sigma>.\n                 return N \\<bind> (\\<lambda>x'b. return (xb < x'b)) \\<bind>\n                 (\\<lambda>x'b.\n                     if x'b\n                     then return $ ((\\<lambda>x. x) $ xb) \\<bind>\n                          (\\<lambda>x'c. hs_ins $ x'c $ \\<sigma>)\n                     else return \\<sigma>)))\n        (?fi7 xi)\n 6. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'7 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn nat_assn) x xi\n 7. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (hs.assn (nbn_assn N)) a c \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (hs.assn (nbn_assn N)) a c\n 8. CONSTRAINT_SLOT (True)", "apply sepref_dbg_trans_step \\<comment> \\<open>Frame rule separating bound variable from rest\\<close>"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma>.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty);\n        TERM monadic_nfoldli\\<rbrakk>\n       \\<Longrightarrow> hn_invalid (hs.assn (nbn_assn N)) \\<sigma>'\n                          \\<sigma> *\n                         hn_invalid nat_assn x'a\n                          xb \\<Longrightarrow>\\<^sub>t\n                         emp * hn_ctxt (?Rk'7 x xi xa x') x'a xb *\n                         hn_ctxt (?Pf\\<sigma>7 x xi xa x') \\<sigma>'\n                          \\<sigma>\n 2. \\<And>x xi xa x' xb x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty)\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt (?Rk'7 x xi xa x') x'a xb \\<or>\\<^sub>A\n                         hn_val nat_rel x'a xb \\<Longrightarrow>\\<^sub>t\n                         hn_ctxt (?Rk''7 x xi xa x') x'a xb\n 3. \\<And>x xi xa x'.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       emp * hn_ctxt (list_assn (?Rk''7 x xi xa x')) x xi *\n       hn_invalid (hs.assn (nbn_assn N)) xa x' \\<Longrightarrow>\\<^sub>t\n       ?\\<Gamma>'7 x xi * hn_ctxt (?Rxb7 x xi) xa x'\n 4. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       CNV (hs_new \\<bind>\n            imp_nfoldli xi (\\<lambda>\\<sigma>. return True)\n             (\\<lambda>xb \\<sigma>.\n                 return N \\<bind> (\\<lambda>x'b. return (xb < x'b)) \\<bind>\n                 (\\<lambda>x'b.\n                     if x'b\n                     then return $ ((\\<lambda>x. x) $ xb) \\<bind>\n                          (\\<lambda>x'c. hs_ins $ x'c $ \\<sigma>)\n                     else return \\<sigma>)))\n        (?fi7 xi)\n 5. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'7 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn nat_assn) x xi\n 6. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (hs.assn (nbn_assn N)) a c \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (hs.assn (nbn_assn N)) a c\n 7. CONSTRAINT_SLOT (True)", "apply sepref_dbg_trans_step \\<comment> \\<open>Frame rule separating fold-state from rest\\<close>"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x xi xa x' xb x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ op_hs_empty)\\<rbrakk>\n       \\<Longrightarrow> hn_invalid nat_assn x'a xb \\<or>\\<^sub>A\n                         hn_val nat_rel x'a xb \\<Longrightarrow>\\<^sub>t\n                         hn_ctxt (?Rk''7 x xi xa x') x'a xb\n 2. \\<And>x xi xa x'.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       emp * hn_ctxt (list_assn (?Rk''7 x xi xa x')) x xi *\n       hn_invalid (hs.assn (nbn_assn N)) xa x' \\<Longrightarrow>\\<^sub>t\n       ?\\<Gamma>'7 x xi * hn_ctxt (?Rxb7 x xi) xa x'\n 3. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       CNV (hs_new \\<bind>\n            imp_nfoldli xi (\\<lambda>\\<sigma>. return True)\n             (\\<lambda>xb \\<sigma>.\n                 return N \\<bind> (\\<lambda>x'b. return (xb < x'b)) \\<bind>\n                 (\\<lambda>x'b.\n                     if x'b\n                     then return $ ((\\<lambda>x. x) $ xb) \\<bind>\n                          (\\<lambda>x'c. hs_ins $ x'c $ \\<sigma>)\n                     else return \\<sigma>)))\n        (?fi7 xi)\n 4. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'7 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn nat_assn) x xi\n 5. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (hs.assn (nbn_assn N)) a c \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (hs.assn (nbn_assn N)) a c\n 6. CONSTRAINT_SLOT (True)", "apply sepref_dbg_trans_step \\<comment> \\<open>Merging elements of list before body \n      with elements of list after body, to get refinement for resulting list\\<close>"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x xi xa x'.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       emp * hn_ctxt (list_assn (invalid_assn nat_assn)) x xi *\n       hn_invalid (hs.assn (nbn_assn N)) xa x' \\<Longrightarrow>\\<^sub>t\n       ?\\<Gamma>'7 x xi * hn_ctxt (?Rxb7 x xi) xa x'\n 2. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       CNV (hs_new \\<bind>\n            imp_nfoldli xi (\\<lambda>\\<sigma>. return True)\n             (\\<lambda>xb \\<sigma>.\n                 return N \\<bind> (\\<lambda>x'b. return (xb < x'b)) \\<bind>\n                 (\\<lambda>x'b.\n                     if x'b\n                     then return $ ((\\<lambda>x. x) $ xb) \\<bind>\n                          (\\<lambda>x'c. hs_ins $ x'c $ \\<sigma>)\n                     else return \\<sigma>)))\n        (?fi7 xi)\n 3. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'7 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn nat_assn) x xi\n 4. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (hs.assn (nbn_assn N)) a c \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (hs.assn (nbn_assn N)) a c\n 5. CONSTRAINT_SLOT (True)", "apply sepref_dbg_trans_step \\<comment> \\<open>Frame rule from initial bind, separating \n      bound variable from the rest\\<close>"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       CNV (hs_new \\<bind>\n            imp_nfoldli xi (\\<lambda>\\<sigma>. return True)\n             (\\<lambda>xb \\<sigma>.\n                 return N \\<bind> (\\<lambda>x'b. return (xb < x'b)) \\<bind>\n                 (\\<lambda>x'b.\n                     if x'b\n                     then return $ ((\\<lambda>x. x) $ xb) \\<bind>\n                          (\\<lambda>x'c. hs_ins $ x'c $ \\<sigma>)\n                     else return \\<sigma>)))\n        (?fi7 xi)\n 2. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (list_assn (invalid_assn nat_assn)) x\n        xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn nat_assn) x xi\n 3. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (hs.assn (nbn_assn N)) a c \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (hs.assn (nbn_assn N)) a c\n 4. CONSTRAINT_SLOT (True)", "apply sepref_dbg_opt"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (list_assn (invalid_assn nat_assn)) x\n        xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn nat_assn) x xi\n 2. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (hs.assn (nbn_assn N)) a c \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (hs.assn (nbn_assn N)) a c\n 3. CONSTRAINT_SLOT (True)", "apply sepref_dbg_cons_solve \\<comment> \\<open>Frame rule, recovering the invalidated list \n    or pure elements, propagating recovery over the list structure\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (hs.assn (nbn_assn N)) a c \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (hs.assn (nbn_assn N)) a c\n 2. CONSTRAINT_SLOT (True)", "apply sepref_dbg_cons_solve \\<comment> \\<open>Trivial frame rule\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. CONSTRAINT_SLOT (True)", "apply sepref_dbg_constraints"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsubsection \\<open>Optimization Phase\\<close>"], ["", "text \\<open>The optimization phase simplifies the generated\n  program, first with @{attribute sepref_opt_simps}, and\n  then with @{attribute sepref_opt_simps2}. \n  For simplification, the tag @{const CNV} is used, which is discharged\n  with @{thm CNV_I} after simplification. \n\n  Method @{method sepref_dbg_opt} gives direct access to this phase.\n  The simplification is used to beautify the generated code.\n  The most important simplifications collapse code that does not \n  depend on the heap to plain expressions (using the monad laws), and\n  apply certain deforestation optimizations.\n  \n  Consider the following example:\n\\<close>"], ["", "sepref_thm opt_example is \"\\<lambda>n. do { let r = fold (+) [1..<n] 0; RETURN (n*n+2) }\"\n  :: \"nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, \\<lambda>n. let r = fold (+) [1..<n] 0 in RETURN (n * n + 2))\n    \\<in> nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "apply sepref_dbg_preproc"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat) \\<Longrightarrow>\n       hn_refine (hn_val nat_rel x xi) (?fi1 xi) (hn_val nat_rel x xi)\n        nat_assn (let r = fold (+) [1..<x] 0 in RETURN (x * x + 2))\n 2. CONSTRAINT_SLOT (True)", "apply sepref_dbg_cons_init"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat) \\<Longrightarrow>\n       hn_refine (hn_val nat_rel x xi) (?fi4 xi) (?\\<Gamma>'5 x xi)\n        (?R5 x xi) (let r = fold (+) [1..<x] 0 in RETURN (x * x + 2))\n 2. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t hn_val nat_rel x xi\n 3. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat) \\<Longrightarrow>\n       hn_ctxt (?R5 x xi) a c \\<Longrightarrow>\\<^sub>t hn_val nat_rel a c\n 4. CONSTRAINT_SLOT (True)", "apply sepref_dbg_id"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat) \\<Longrightarrow>\n       hn_refine (hn_val nat_rel x xi) (?fi4 xi) (?\\<Gamma>'5 x xi)\n        (?R5 x xi)\n        (Let $ (fold $ (+) $ (upt $ 1 $ x) $ 0) $\n         (\\<lambda>xa. (#RETURN $ ((+) $ ((*) $ x $ x) $ PR_CONST 2)#)))\n 2. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t hn_val nat_rel x xi\n 3. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat) \\<Longrightarrow>\n       hn_ctxt (?R5 x xi) a c \\<Longrightarrow>\\<^sub>t hn_val nat_rel a c\n 4. CONSTRAINT_SLOT (True)", "apply sepref_dbg_monadify"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat) \\<Longrightarrow>\n       hn_refine (hn_val nat_rel x xi) (?fi4 xi) (?\\<Gamma>'5 x xi)\n        (?R5 x xi)\n        ((\\<bind>) $\n         ((\\<bind>) $\n          ((\\<bind>) $ (RETURN $ 1) $\n           (\\<lambda>v0. (#RETURN $ (upt $ v0 $ x)#))) $\n          (\\<lambda>x.\n              (#(\\<bind>) $ (RETURN $ 0) $\n                (\\<lambda>xa.\n                    (#monadic_nfoldli $ x $\n                      (\\<lambda>x. (#RETURN $ True#)) $\n                      (\\<lambda>x.\n                          (#\\<lambda>xa. (#RETURN $ ((+) $ x $ xa)#)#)) $\n                      xa#))#))) $\n         (\\<lambda>xa.\n             (#Let $ xa $\n               (\\<lambda>xa.\n                   (#(\\<bind>) $\n                     ((\\<bind>) $ (RETURN $ (COPY $ x)) $\n                      (\\<lambda>v0. (#RETURN $ ((*) $ v0 $ x)#))) $\n                     (\\<lambda>v0.\n                         (#(\\<bind>) $ (RETURN $ PR_CONST 2) $\n                           (\\<lambda>v1.\n                               (#RETURN $ ((+) $ v0 $ v1)#))#))#))#)))\n 2. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t hn_val nat_rel x xi\n 3. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat) \\<Longrightarrow>\n       hn_ctxt (?R5 x xi) a c \\<Longrightarrow>\\<^sub>t hn_val nat_rel a c\n 4. CONSTRAINT_SLOT (True)", "apply sepref_dbg_opt_init"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat) \\<Longrightarrow>\n       hn_refine (hn_val nat_rel x xi) (?c39 x xi) (?\\<Gamma>'5 x xi)\n        (?R5 x xi)\n        ((\\<bind>) $\n         ((\\<bind>) $\n          ((\\<bind>) $ (RETURN $ 1) $\n           (\\<lambda>v0. (#RETURN $ (upt $ v0 $ x)#))) $\n          (\\<lambda>x.\n              (#(\\<bind>) $ (RETURN $ 0) $\n                (\\<lambda>xa.\n                    (#monadic_nfoldli $ x $\n                      (\\<lambda>x. (#RETURN $ True#)) $\n                      (\\<lambda>x.\n                          (#\\<lambda>xa. (#RETURN $ ((+) $ x $ xa)#)#)) $\n                      xa#))#))) $\n         (\\<lambda>xa.\n             (#Let $ xa $\n               (\\<lambda>xa.\n                   (#(\\<bind>) $\n                     ((\\<bind>) $ (RETURN $ (COPY $ x)) $\n                      (\\<lambda>v0. (#RETURN $ ((*) $ v0 $ x)#))) $\n                     (\\<lambda>v0.\n                         (#(\\<bind>) $ (RETURN $ PR_CONST 2) $\n                           (\\<lambda>v1.\n                               (#RETURN $ ((+) $ v0 $ v1)#))#))#))#)))\n 2. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat) \\<Longrightarrow> CNV (?c39 x xi) (?fi4 xi)\n 3. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t hn_val nat_rel x xi\n 4. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat) \\<Longrightarrow>\n       hn_ctxt (?R5 x xi) a c \\<Longrightarrow>\\<^sub>t hn_val nat_rel a c\n 5. CONSTRAINT_SLOT (True)", "apply sepref_dbg_trans\n  \\<comment> \\<open>The generated program contains many superfluous binds, moreover, it actually \n    generates a list and then folds over it\\<close>"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat) \\<Longrightarrow>\n       CNV (return 1 \\<bind> (\\<lambda>x'. return [x'..<xi]) \\<bind>\n            (\\<lambda>x'.\n                return 0 \\<bind>\n                imp_nfoldli x' (\\<lambda>\\<sigma>. return True)\n                 (\\<lambda>xc \\<sigma>. return (xc + \\<sigma>))) \\<bind>\n            (\\<lambda>x'.\n                let x'a = x'\n                in return $ xi \\<bind>\n                   (\\<lambda>x'b. return (x'b * xi)) \\<bind>\n                   (\\<lambda>x'b.\n                       return 2 \\<bind>\n                       (\\<lambda>x'c. return (x'b + x'c)))))\n        (?fi4 xi)\n 2. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat) \\<Longrightarrow>\n       hn_val nat_rel x xi \\<Longrightarrow>\\<^sub>t hn_val nat_rel x xi\n 3. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat) \\<Longrightarrow>\n       hn_val nat_rel a c \\<Longrightarrow>\\<^sub>t hn_val nat_rel a c\n 4. CONSTRAINT_SLOT (True)", "supply [[show_main_goal]]"], ["proof (prove)\ngoal (4 subgoals):\nTERM ?fi4 &&&\n(?fi4, \\<lambda>n. let r = fold (+) [1..<n] 0 in RETURN (n * n + 2))\n\\<in> nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat) \\<Longrightarrow>\n       CNV (return 1 \\<bind> (\\<lambda>x'. return [x'..<xi]) \\<bind>\n            (\\<lambda>x'.\n                return 0 \\<bind>\n                imp_nfoldli x' (\\<lambda>\\<sigma>. return True)\n                 (\\<lambda>xc \\<sigma>. return (xc + \\<sigma>))) \\<bind>\n            (\\<lambda>x'.\n                let x'a = x'\n                in return $ xi \\<bind>\n                   (\\<lambda>x'b. return (x'b * xi)) \\<bind>\n                   (\\<lambda>x'b.\n                       return 2 \\<bind>\n                       (\\<lambda>x'c. return (x'b + x'c)))))\n        (?fi4 xi)\n 2. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat) \\<Longrightarrow>\n       hn_val nat_rel x xi \\<Longrightarrow>\\<^sub>t hn_val nat_rel x xi\n 3. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat) \\<Longrightarrow>\n       hn_val nat_rel a c \\<Longrightarrow>\\<^sub>t hn_val nat_rel a c\n 4. CONSTRAINT_SLOT (True)", "apply sepref_dbg_opt\n  \\<comment> \\<open>The superfluous binds have been collapsed, and the fold over the list\n    has been replaced by @{const imp_for'}, which uses a counter.\\<close>"], ["proof (prove)\ngoal (3 subgoals):\nTERM \\<lambda>xi.\n        imp_for' 1 xi (\\<lambda>xc \\<sigma>. return (xc + \\<sigma>))\n         0 \\<bind>\n        (\\<lambda>x'. return (xi * xi + 2)) &&&\n(\\<lambda>xi.\n    imp_for' 1 xi (\\<lambda>xc \\<sigma>. return (xc + \\<sigma>)) 0 \\<bind>\n    (\\<lambda>x'. return (xi * xi + 2)),\n \\<lambda>n. let r = fold (+) [1..<n] 0 in RETURN (n * n + 2))\n\\<in> nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat) \\<Longrightarrow>\n       hn_val nat_rel x xi \\<Longrightarrow>\\<^sub>t hn_val nat_rel x xi\n 2. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat) \\<Longrightarrow>\n       hn_val nat_rel a c \\<Longrightarrow>\\<^sub>t hn_val nat_rel a c\n 3. CONSTRAINT_SLOT (True)", "apply sepref_dbg_cons_solve"], ["proof (prove)\ngoal (2 subgoals):\nTERM \\<lambda>xi.\n        imp_for' 1 xi (\\<lambda>xc \\<sigma>. return (xc + \\<sigma>))\n         0 \\<bind>\n        (\\<lambda>x'. return (xi * xi + 2)) &&&\n(\\<lambda>xi.\n    imp_for' 1 xi (\\<lambda>xc \\<sigma>. return (xc + \\<sigma>)) 0 \\<bind>\n    (\\<lambda>x'. return (xi * xi + 2)),\n \\<lambda>n. let r = fold (+) [1..<n] 0 in RETURN (n * n + 2))\n\\<in> nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\n 1. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat) \\<Longrightarrow>\n       hn_val nat_rel a c \\<Longrightarrow>\\<^sub>t hn_val nat_rel a c\n 2. CONSTRAINT_SLOT (True)", "apply sepref_dbg_cons_solve"], ["proof (prove)\ngoal (1 subgoal):\nTERM \\<lambda>xi.\n        imp_for' 1 xi (\\<lambda>xc \\<sigma>. return (xc + \\<sigma>))\n         0 \\<bind>\n        (\\<lambda>x'. return (xi * xi + 2)) &&&\n(\\<lambda>xi.\n    imp_for' 1 xi (\\<lambda>xc \\<sigma>. return (xc + \\<sigma>)) 0 \\<bind>\n    (\\<lambda>x'. return (xi * xi + 2)),\n \\<lambda>n. let r = fold (+) [1..<n] 0 in RETURN (n * n + 2))\n\\<in> nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\n 1. CONSTRAINT_SLOT (True)", "apply sepref_dbg_constraints"], ["proof (prove)\ngoal:\nTERM \\<lambda>xi.\n        imp_for' 1 xi (\\<lambda>xc \\<sigma>. return (xc + \\<sigma>))\n         0 \\<bind>\n        (\\<lambda>x'. return (xi * xi + 2)) &&&\n(\\<lambda>xi.\n    imp_for' 1 xi (\\<lambda>xc \\<sigma>. return (xc + \\<sigma>)) 0 \\<bind>\n    (\\<lambda>x'. return (xi * xi + 2)),\n \\<lambda>n. let r = fold (+) [1..<n] 0 in RETURN (n * n + 2))\n\\<in> nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\nNo subgoals!", "done"], ["", "subsubsection \\<open>Cons-Solve Phases\\<close>"], ["", "text \\<open>These two phases, accessible via @{method sepref_dbg_cons_solve},\n  applies the frame inference tool to solve the two implications generated\n  by the consequence rule phase.\n\\<close>"], ["", "subsubsection \\<open>Constraints Phase\\<close>"], ["", "text \\<open>\n  This phase, accessible via @{method sepref_dbg_constraints}, solve the\n  deferred constraints that are left, and then removes the \\<open>CONSTRAINT_SLOT\\<close> \n  subgoal.\n\\<close>"], ["", "subsection \\<open>Refinement Rules\\<close>"], ["", "text \\<open>\n  There are two forms of specifying refinement between an Imperative/HOL program\n  and an abstract program in the \\<open>nres\\<close>-monad.\n  The \\<open>hn_refine\\<close> form (also hnr-form) is the more low-level form.\n  The term @{term \"P \\<Longrightarrow> hn_refine \\<Gamma> c \\<Gamma>' R a\"} states that, under precondition \\<open>P\\<close>, for \n  a heap described by \\<open>\\<Gamma>\\<close>, the Imperative/HOL program \\<open>c\\<close> produces a heap described by \n  \\<open>\\<Gamma>'\\<close> and the result is refined by \\<open>R\\<close>. Moreover, the abstract result is among the possible \n  results of the abstract program \\<open>a\\<close>.\n  \n  This low-level form formally enforces no restrictions on its arguments, however, there are\n  some assumed by our tool:\n    \\<^item> \\<open>\\<Gamma>\\<close> must have the form \\<open>hn_ctxt A\\<^sub>1 x\\<^sub>1 xi\\<^sub>1 * \\<dots> * hn_ctxt A\\<^sub>n x\\<^sub>n xi\\<^sub>n\\<close>\n    \\<^item> \\<open>\\<Gamma>'\\<close> must have the form \\<open>hn_ctxt B\\<^sub>1 x\\<^sub>1 xi\\<^sub>1 * \\<dots> * hn_ctxt B\\<^sub>n x\\<^sub>n xi\\<^sub>n\\<close>\n      where either \\<open>B\\<^sub>i = A\\<^sub>i\\<close> or \\<open>B\\<^sub>i = invalid_assn A\\<^sub>i\\<close>. This means that each argument to\n      the program is either preserved or destroyed.\n    \\<^item> \\<open>R\\<close> must not contain a \\<open>hn_ctxt\\<close> tag.\n    \\<^item> \\<open>a\\<close> must be in protected form (@{term \"($)\"} and @{term \"PROTECT2\"} tags)\n\n  The high-level \\<open>hfref\\<close> form formally enforces these restrictions. Moreover,\n  it assumes \\<open>c\\<close> and \\<open>a\\<close> to be presented as functions from exactly one argument.\n  For constants or functions with more arguments, you may use @{term uncurry0} \n  and @{term uncurry}. (Also available @{term uncurry2} to @{term uncurry5}).\n\n  The general form is \\<open>PC \\<Longrightarrow> (uncurry\\<^sub>x f, uncurry\\<^sub>x g) \\<in> [P]\\<^sub>a A\\<^sub>1\\<^sup>k\\<^sup>1 *\\<^sub>a \\<dots> *\\<^sub>a A\\<^sub>n\\<^sup>k\\<^sup>n \\<rightarrow> R\\<close>,\n  where \\<open>ki\\<close> is \\<open>k\\<close> if the argument is preserved (kept) or \\<open>d\\<close> is it is destroyed.\n  \\<open>PC\\<close> are preconditions of the rule that do not depend on the arguments, usually\n  restrictions on the relations. \\<open>P\\<close> is a predicate on the single argument of \\<open>g\\<close>,\n  representing the precondition that depends on the arguments.\n\n  Optionally, \\<open>g\\<close> may be of the form \\<open>RETURN o\\<dots>o g'\\<close>, in which case the rule \n  applies to a plain function.\n\n  If there is no precondition, there is a shorter \n  syntax: @{term \"Args\\<rightarrow>\\<^sub>aR \\<equiv> [\\<lambda>_. True]\\<^sub>a Args\\<rightarrow>R\"}.\n\n  For example, consider @{thm [source] arl_swap_hnr[unfolded pre_list_swap_def]}.\n  It reads @{term \"CONSTRAINT is_pure A \\<Longrightarrow>\n    (uncurry2 arl_swap, uncurry2 (RETURN \\<circ>\\<circ>\\<circ> op_list_swap))\n    \\<in> [\\<lambda>((l, i), j). i < length l \\<and> j < length l]\\<^sub>a \n    (arl_assn A)\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k \\<rightarrow> arl_assn A\"}\n\n  We have three arguments, the list and two indexes. The refinement assertion \\<open>A\\<close>\n  for the list elements must be pure, and the indexes must be in range.\n  The original list is destroyed, the indexes are kept.\n\\<close>"], ["", "thm arl_swap_hnr[unfolded pre_list_swap_def, no_vars]"], ["", "subsubsection \\<open>Converting between hfref and hnr form\\<close>"], ["", "text \\<open>A subgoal in hfref form is converted to hnr form by\n  the preprocessing phase of Sepref (see there for a description).\n\n  Theorems with hnr/hfref conclusions can be converted\n  using @{attribute to_hfref}/@{attribute to_hnr}.\n  This conversion is automatically done for rules registered with \n  @{attribute sepref_fr_rules}, such that this attribute accepts both forms.\n\n  Conversion to hnr-form can be controlled by specifying \n  @{attribute to_hnr_post} unfold-rules, which are applied after the conversion.\n\n  Note: These currently contain hard-coded rules to handle \\<open>RETURN o\\<dots>o _\\<close> for up \n    to six arguments. If you have more arguments, you need to add corresponding rules here,\n    until this issue is fixed and the tool can produce such rules automatically.\n    \n  Similarly, @{attribute to_hfref_post} is applied after conversion to hfref form.\n\\<close>"], ["", "thm to_hnr_post"], ["", "thm to_hfref_post"], ["", "subsubsection \\<open>Importing Parametricity Theorems\\<close>"], ["", "text \\<open>For pure refinements, it is sometimes simpler to specify a parametricity \n  theorem than a hnr/hfref theorem, in particular as there is a large number of \n  parametricity theorems readily available, in the parametricity component or Autoref,\n  and in the Lifting/Transfer tool.\n  \n  Autoref uses a set-based notation for parametricity theorems \n  (e.g. @{term \"((@),(@)) \\<in> \\<langle>A\\<rangle>list_rel \\<rightarrow> \\<langle>A\\<rangle>list_rel \\<rightarrow> \\<langle>A\\<rangle>list_rel\"}), \n  while lifting/transfer uses a predicate based notation (e.g. \n    @{term \"rel_fun (list_all2 A) (rel_fun (list_all2 A) (list_all2 A)) (@) (@)\"}).\n\n  Currently, we only support the Autoref style, but provide a few lemmas that \n  ease manual conversion from the Lifting/Transfer style.\n\n  Given a parametricity theorem, the attribute @{attribute sepref_param}\n  converts it to a hfref theorem, the attribute \n  @{attribute sepref_import_param} does the conversion and registers the result\n  as operator rule.\n  Relation variables are converted to assertion variables with an \\<open>is_pure\\<close> constraint.\n\n  The behaviour can be customized by @{attribute sepref_import_rewrite}, which\n  contains rewrite rules applied in the last but one step of the conversion, before\n  converting relation variables to assertion variables. \n  These theorems can be used to convert relations to there corresponding assertions,\n  e.g., @{thm list_assn_pure_conv[symmetric]} converts a list relation to a list \n  assertion.\n\n\n  For debugging purposes, the attribute @{attribute sepref_dbg_import_rl_only}\n  converts a parametricity theorem to a hnr-theorem. This is the first step of \n  the standard conversion, followed by a conversion to hfref form.\n\\<close>"], ["", "thm sepref_import_rewrite"], ["", "thm param_append \\<comment> \\<open>Parametricity theorem for append\\<close>"], ["", "thm param_append[sepref_param] \\<comment> \\<open>Converted to hfref-form. \n  \\<open>list_rel\\<close> is rewritten to \\<open>list_assn\\<close>, and the relation variable is replaced by an \n  assertion variable and a \\<open>is_pure\\<close> constraint.\\<close>"], ["", "thm param_append[sepref_dbg_import_rl_only]"], ["", "text \\<open>For re-using Lifting/Transfer style theorems, the constants \n  @{const p2rel} and @{const rel2p} may be helpful, however, there is no\n  automation available yet.\n\n  Usage examples can be found in, e.g., @{theory Refine_Imperative_HOL.IICF_Multiset}, where we \n  import parametricity lemmas for multisets from the Lifting/Transfer package.\n\\<close>"], ["", "thm p2rel \\<comment> \\<open>Simp rules to convert predicate to relational style\\<close>"], ["", "thm rel2p \\<comment> \\<open>Simp rules to convert relational to predicate style\\<close>"], ["", "subsection \\<open>Composition\\<close>"], ["", "subsubsection \\<open>Fref-Rules\\<close>"], ["", "text \\<open>\n  In standard parametricity theorems as described above, one cannot specify\n  preconditions for the parameters, e.g., @{term hd} is only parametric for \n  non-empty lists. \n\n  As of Isabelle2016, the Lifting/Transfer package cannot specify\n  such preconditions at all.\n\n  Autoref's parametricity tool can specify such preconditions by using first-order rules,\n  (cf. @{thm param_hd}). However, currently, @{attribute sepref_import_param} cannot handle \n  these first-order rules. \n\n  Instead, Sepref supports the fref-format for parametricity rules, which resembles the \n  hfref-format: Abstract and concrete objects are functions with exactly one parameter, \n  uncurried if necessary. Moreover, there is an explicit precondition.\n  The syntax is \\<open>(uncurry\\<^sub>x f, uncurry\\<^sub>x g) \\<in> [P]\\<^sub>f (...(R\\<^sub>1\\<times>\\<^sub>rR\\<^sub>2)\\<times>\\<^sub>r...)\\<times>\\<^sub>rR\\<^sub>n) \\<rightarrow> R\\<close>,\n  and without precondition, we have \\<open>(...(R\\<^sub>1\\<times>\\<^sub>rR\\<^sub>2)\\<times>\\<^sub>r...)\\<times>\\<^sub>rR\\<^sub>n) \\<rightarrow>\\<^sub>f R\\<close>. \n  Note the left-bracketing of the tuples, which is non-standard in Isabelle.\n  As we currently have no syntax for a left-associative product relation, we\n  use the right-associative syntax @{term \"(\\<times>\\<^sub>r)\"} and explicit brackets.\n\n  The attribute @{attribute to_fref} can convert (higher-order form) parametricity \n  theorems to the fref-form.\n\\<close>"], ["", "subsubsection \\<open>Composition of hfref and fref theorems\\<close>"], ["", "text \\<open>\n  fref and hfref theorems can be composed, if the \n  abstract function or the first theorem equals the concrete function of the \n  second theorem. Currently, we can compose an hfref with an fref theorem, \n  yielding a hfref theorem, and two fref-theorems, yielding an fref theorem.\n  As we do not support refinement of heap-programs, but only refinement \\<^emph>\\<open>into\\<close> heap \n  programs, we cannot compose two hfref theorems.\n\n  The attribute @{attribute FCOMP} does these compositions and normalizes the result.\n  Normalization consists of precondition simplification, and distributing composition\n  over products, such that composition can be done argument-wise. \n  For this, we unfold with @{attribute fcomp_norm_unfold}, and then simplify with\n  @{attribute fcomp_norm_simps}.\n\n  The \\<open>FCOMP\\<close> attribute tries to convert its arguments to hfref/fref form, such that\n  it also accepts hnr-rules and parametricity rules.\n\n  The standard use-case for \\<open>FCOMP\\<close> is to compose multiple refinement steps to\n  get the final correctness theorem. Examples for this are in the quickstart guide.\n\n  Another use-case for \\<open>FCOMP\\<close> is to compose a refinement theorem of a \n  container operation, that refines the elements by identity, with a parametricity theorem\n  for the container operation, that adds a (pure) refinement of the elements.\n  In practice, the high-level utilities @{command sepref_decl_op} and \n  @{command sepref_decl_impl} are used for this purpose. Internally, they use \\<open>FCOMP\\<close>.\n\\<close>"], ["", "thm fcomp_norm_unfold"], ["", "thm fcomp_norm_simps"], ["", "thm array_get_hnr_aux \\<comment> \\<open>Array indexing, array elements are refined by identity\\<close>"], ["", "thm \"op_list_get.fref\" \\<comment> \\<open>Parametricity theorem for list indexing\\<close>"], ["", "thm array_get_hnr_aux[FCOMP op_list_get.fref] \\<comment> \\<open>Composed theorem\\<close>\n\n\\<comment> \\<open>Note the definition @{thm array_assn_def}\\<close>"], ["", "context\n  notes [fcomp_norm_unfold] = array_assn_def[symmetric]\nbegin"], ["", "thm array_get_hnr_aux[FCOMP op_list_get.fref] \\<comment> \\<open>Composed theorem, \\<open>array_assn\\<close> folded.\\<close>"], ["", "end"], ["", "subsection \\<open>Registration of Interface Types\\<close>"], ["", "text \\<open>\n  An interface type represents some conceptual type, which is encoded to a \n  more complex type in HOL. For example, the interface type @{typ \"('k,'v)i_map\"}\n  represents maps, which are encoded as @{typ \"'k \\<Rightarrow> 'v option\"} in HOL.\n\n  New interface types must be registered by the command @{command sepref_decl_intf}.\n\\<close>"], ["", "sepref_decl_intf ('a,'b) i_my_intf is \"'a*'a \\<Rightarrow> 'b option\"\n\\<comment> \\<open>Declares @{typ \"('a,'b) i_my_intf\"} as new interface type, and registers it\n  to correspond to @{typ \"'a*'a \\<Rightarrow> 'b option\"}. \n  Note: For HOL, the interface type is just an arbitrary new type, which is \n    not related to he corresponding HOL type.\\<close>"], ["", "sepref_decl_intf ('a,'b) i_my_intf2 (infix \"*\\<rightarrow>\\<^sub>i\" 0) is \"'a*'a \\<Rightarrow> 'b option\"\n\\<comment> \\<open>There is also a version that declares infix-syntax for the interface type.\n  In this case we have @{typ \"'a *\\<rightarrow>\\<^sub>i 'b\"}. @{typ \"'a\\<rightharpoonup>'b\"}\n  Be aware of syntax space pollution, as the syntax for interface types and \n  HOL types is the same.\\<close>"], ["", "subsection \\<open>Registration of Abstract Operations\\<close>"], ["", "text \\<open>\n  Registering a new abstract operation requires some amount of setup,\n  which is automated by the \\<open>sepref_register\\<close> tool. Currently, it only \n  works for operations, not for combinators. \n\n  The @{command sepref_register} command takes a list of terms and registers \n  them as operators. Optionally, each term can have an interface type annotation. \n\n  If there is no interface type annotation, the interface type is derived from the \n  terms HOL type, which is rewritten by the theorems from @{attribute map_type_eqs}.\n  This rewriting is useful for bulk-setup of many constants with conceptual types \n  different from there HOL-types. \n  Note that the interface type must correspond to the HOL type of the registered term,\n  otherwise, you'll get an error message.\n\n  If the term is not a single constant or variable, and does not already start \n  with a @{const PR_CONST} tag, such a tag will be added, and also a pattern rule \n  will be registered to add the tag on operator identification.\n  \n  If the term has a monadic result type (@{typ \"_ nres\"}), also an \n  arity and combinator rule for the monadify phase are generated.\n\n  There is also an attribute version @{attribute \"sepref_register_adhoc\"}.\n  It has the same syntax, and generates the same theorems, but does not give\n  names to the theorems. It's main application is to conveniently register fixed\n  variables of a context. Warning: Make sure not to export such an attribute from \n  the context, as it may become meaningless outside the context, or worse, confuse \n  the tool.\n\\<close>"], ["", "text \\<open>Example for bulk-registration, utilizing type-rewriting\\<close>"], ["", "definition \"map_op1 m n \\<equiv> m(n\\<mapsto>n+1)\""], ["", "definition \"map_op2 m n \\<equiv> m(n\\<mapsto>n+2)\""], ["", "definition \"map_op3 m n \\<equiv> m(n\\<mapsto>n+3)\""], ["", "definition \"map_op_to_map (m::'a\\<rightharpoonup>'b) \\<equiv> m\""], ["", "context\n  notes [map_type_eqs] = map_type_eqI[of \"TYPE('a\\<rightharpoonup>'b)\" \"TYPE(('a,'b)i_map)\"]\nbegin"], ["", "sepref_register map_op1 map_op2 map_op3 \n  \\<comment> \\<open>Registered interface types use \\<open>i_map\\<close>\\<close>"], ["", "sepref_register map_op_to_map :: \"('a\\<rightharpoonup>'b) \\<Rightarrow> ('a,'b) i_map\"\n  \\<comment> \\<open>Explicit type annotation is not rewritten\\<close>"], ["", "end"], ["", "text \\<open>Example for insertion of \\<open>PR_CONST\\<close> tag and attribute-version\\<close>"], ["", "context\n  fixes N :: nat and D :: int\n  notes [[sepref_register_adhoc N D]]\n  \\<comment> \\<open>In order to use \\<open>N\\<close> and \\<open>D\\<close> as operators (constant) inside this context,\n    they have to be registered. However, issuing a \\<open>sepref_register\\<close> command \n    inside the context would export meaningless registrations to the global \n    theory.\\<close>\n\n  notes [sepref_import_param] = IdI[of N] IdI[of D]\n  \\<comment> \\<open>For declaring refinement rules, the \\<open>sepref_import_param\\<close> attribute comes \n    in handy here. If this is not possible, you have to work with nested contexts,\n    proving the refinement lemmas in the first level, and declaring them as\n    \\<open>sepref_fr_rules\\<close> on the second level.\\<close>\n\nbegin"], ["", "definition \"newlist \\<equiv> replicate N D\""], ["", "sepref_register newlist"], ["", "print_theorems\n  \\<comment> \\<open>\\<open>PR_CONST\\<close> tag is added, pattern rule is generated\\<close>"], ["", "sepref_register other_basename_newlist: newlist"], ["", "print_theorems\n  \\<comment> \\<open>The base name for the generated theorems can be overridden\\<close>"], ["", "sepref_register yet_another_basename_newlist: \"PR_CONST newlist\""], ["", "print_theorems\n  \\<comment> \\<open>If \\<open>PR_CONST\\<close> tag is specified, no pattern rule is generated automatically\\<close>"], ["", "end"], ["", "text \\<open>Example for mcomb/arity theorems\\<close>"], ["", "definition \"select_a_one l \\<equiv> SPEC (\\<lambda>i. i<length l \\<and> l!i = (1::nat))\""], ["", "sepref_register \"select_a_one\""], ["", "print_theorems\n  \\<comment> \\<open>Arity and mcomb theorem is generated\\<close>"], ["", "text \\<open>\n  The following command fails, as the specified interface type does not\n  correspond to the HOL type of the term:\n  @{theory_text \\<open>sepref_register hd :: \"(nat,nat) i_map\"\\<close>}\n\\<close>"], ["", "subsection \\<open>High-Level tools for Interface/Implementation Declaration\\<close>"], ["", "text \\<open>\n  The Imperative Isabelle Collections Framework (IICF), which comes with Sepref,\n  has a concept of interfaces, which specify a set of abstract operations for\n  a conceptual type, and implementations, which implement these operations.\n  \n  Each operation may have a natural precondition, which is established already \n  for the abstract operation. Many operations come in a plain version, and a \n  monadic version which asserts the precondition. Implementations may \n  strengthen the precondition with implementation specific preconditions.\n\n  Moreover, each operation comes with a parametricity lemma. \n  When registering an implementation, the refinement of the implementation is\n  combined with the parametricity lemma to allow for (pure) refinements of the \n  element types.\n\n  @{rail \\<open>@@{command sepref_decl_op} ('(' @{text flags} ')')? \\<newline>\n      (@{text name} @':')?  @{text term} @'::' @{text term} \\<newline>\n      (@'where' @{text props})? \\<close>}  \n  \n  The command @{command sepref_decl_op} declares an abstract operation.\n  It takes a term defining the operation, and a parametricity relation.\n  It generates the monadic version from the plain version, defines constants\n  for the operations, registers them, and tries to prove parametricity lemmas\n  automatically. Parametricity must be proved for the operation, and for the \n  precondition. If the automatic parametricity proofs fail, the user gets \n  presented goals that can be proven manually.\n\n  Optionally, a basename for the operation can be specified. If none is specified, \n  a heuristics tries to derive one from the specified term.\n\n  A list of properties (separated by space and/or \\<open>and\\<close>) can be specified, \n  which get constraint-preconditions of the relation. \n\n  Finally, the following flags can be specified. Each flag can be prefixed by \\<open>no_\\<close> \n  to invert its meaning:\n  \\<^descr>[mop] (default: true) Generate monadic version of operation\n  \\<^descr>[ismop] (default: false) Indicate that given term is the monadic version\n  \\<^descr>[rawgoals] (default: false) Present raw goals to user, without attempting to prove them\n  \\<^descr>[def] (default: true) Define a constant for the specified term. Otherwise, use the specified term literally.\n\n\\<close>"], ["", "text \\<open>\n  \n  @{rail \\<open>@@{command sepref_decl_impl} ('(' @{text flags} ')')? \\<newline>\n    (@{text name} @':')? (@'[' @{text term} @']')? \\<newline>\n    @{text thm} (@'uses' @{text thm})?\n    \\<close>}  \n\n  The @{command sepref_decl_impl} command declares an implementation of an interface operation.\n  It takes a refinement theorem for the implementation, and combines it with the corresponding\n  parametricity theorem. After \\<open>uses\\<close>, one can override the parametricity theorem to be used.\n  A heuristics is used to merge the preconditions of the refinement and parametricity theorem.\n  This heuristics can be overridden by specifiying the desired precondition inside \\<open>[\\<dots>]\\<close>.\n  Finally, the user gets presented remaining subgoals that cannot be solved by the heuristics.\n  The command accepts the following flags:\n  \\<^descr>[mop] (default: true) Generate implementation for monadic version\n  \\<^descr>[ismop] (default: false) Declare that the given theorems refer to the monadic version\n  \\<^descr>[transfer] (default: true) Try to automatically transfer the implementation's precondition\n    over the argument relation from the parametricity theorem.\n  \\<^descr>[rawgoals] (default: false) Do not attempt to solve or simplify the goals\n  \\<^descr>[register] (default: true) Register the generated theorems as operation rules. \n\\<close>"], ["", "subsection \\<open>Defining synthesized Constants\\<close>"], ["", "text \\<open>\n  The @{command sepref_definition} allows one to specify a name, an abstract term and\n  a desired refinement relation in hfref-form. It then sets up a goal that can be\n  massaged (usually, constants are unfolded and annotations/implementation specific \n  operations are added) and then solved by @{method sepref}.\n  After the goal is solved, the command extracts the synthesized term and defines it as\n  a constant with the specified name. Moreover, it sets up code equations for the constant,\n  correctly handling recursion combinators. Extraction of code equations is controlled by the\n  \\<open>prep_code\\<close> flag. Examples for this command can be found in the quickstart guide.\n\\<close>"], ["", "end"]]}