{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/Userguides/Sepref_Guide_Quickstart.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemma min_of_list1_refine: \"(min_of_list1,min_of_list) \\<in> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel\"", "lemma \"(min_of_list1,min_of_list) \\<in> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel\"", "lemma min_of_list2_refine: \"(min_of_list2, min_of_list1)\\<in>Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel\"", "theorem min_of_list3_correct: \"(min_of_list3,min_of_list) \\<in> (array_assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\"", "lemma \"l\\<noteq>[] \\<Longrightarrow> <array_assn nat_assn l a> min_of_list3 a <\\<lambda>x. array_assn nat_assn l a * \\<up>(\\<forall>y\\<in>set l. x\\<le>y)>\\<^sub>t\"", "lemma \"l\\<noteq>[] \\<Longrightarrow> <array_assn nat_assn l a> min_of_list3 a <\\<lambda>x. array_assn nat_assn l a * \\<up>(\\<forall>y\\<in>set l. x\\<le>y)>\\<^sub>t\"", "lemma [sepref_import_param]: \"(rand_list,rand_list)\\<in>nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_rel\"", "lemma isl1_measure: \"wf (measure (\\<lambda>(l,u,f). u-l + (if f then 0 else 1)))\"", "lemma neq_nlt_is_gt:\n  fixes a b :: \"'a::linorder\"  \n  shows \"a\\<noteq>b \\<Longrightarrow> \\<not>(a<b) \\<Longrightarrow> a>b\"", "lemma isl1_aux1:\n  assumes \"sorted xs\"\n  assumes \"i<length xs\"\n  assumes \"xs!i < x\"\n  shows \"x\\<notin>set (take i xs)\"", "lemma isl1_aux2: \n  assumes \"x \\<notin> set (take n xs)\"\n  shows \"x\\<notin>set (drop n xs) \\<longleftrightarrow> x\\<notin>set xs\"", "lemma in_sorted_list1_refine: \"(in_sorted_list1, in_sorted_list)\\<in>Id \\<rightarrow> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel\"", "lemmas in_sorted_list2_correct = in_sorted_list2.refine[FCOMP in_sorted_list1_refine]", "lemma nat_seg_map1_refine: \"(nat_seg_map1, nat_seg_map) \\<in> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel\"", "lemmas nat_seg_map2_correct = nat_seg_map2.refine[FCOMP nat_seg_map1_refine]", "lemma incr_list1_refine: \"(incr_list1, incr_list)\\<in>Id \\<rightarrow> Id\"", "lemma incr_list2_refine: \"(incr_list2,RETURN o incr_list) \\<in> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel\"", "lemmas incr_list3_correct = incr_list3.refine[FCOMP incr_list2_refine]", "lemma remdup_init_hnr: \n  \"(uncurry remdup1_initsz, uncurry remdup_initsz) \\<in> nat_assn\\<^sup>k *\\<^sub>a (list_assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a arl_assn nat_assn\"", "lemma my_remdup_impl_loc_this: \"my_remdup_impl_loc N\"", "lemma N_hnr[sepref_import_param]: \"(N,N)\\<in>nat_rel\"", "lemma N_hnr': \"(uncurry0 (return N), uncurry0 (RETURN N))\\<in>unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\"", "lemma aux1[intro]: \"\\<lbrakk> set l \\<subset> {0..<N}; distinct l \\<rbrakk> \\<Longrightarrow> length l < N\"", "lemmas remdup1_fixed_refine[sepref_fr_rules] = remdup1_fixed.refine[OF my_remdup_impl_loc_this]", "lemmas test_remdup1_refine[sepref_fr_rules] = test_remdup1.refine[of N]", "lemma test_remdup1_refine_aux: \"(test_remdup1, my_remdup_impl_loc.test_remdup) \\<in> [my_remdup_impl_loc]\\<^sub>a nat_assn\\<^sup>k \\<rightarrow> nat_assn\"", "lemma test_remdup1_refine: \"(test_remdup1, my_remdup_impl_loc.test_remdup) \\<in> [\\<lambda>N. N>0]\\<^sub>a nat_assn\\<^sup>k \\<rightarrow> nat_assn\"", "lemmas [sepref_fr_rules] = test_remdup1_refine", "lemma my_bremdup_impl_loc_this: \"my_bremdup_impl_loc N\"", "lemma N_hnr[sepref_import_param]: \"(N,N)\\<in>nat_rel\"", "lemma aux1[intro]: \"\\<lbrakk> set l \\<subset> {0..<N}; distinct l \\<rbrakk> \\<Longrightarrow> length l < N\"", "lemmas remdup1_fixed_refine[sepref_fr_rules] = bremdup1_fixed.refine[OF my_bremdup_impl_loc_this]", "lemmas test_remdup1_refine[sepref_fr_rules] = test_bremdup1.refine[of N]", "lemma test_bremdup1_refine_aux: \"(test_bremdup1, my_bremdup_impl_loc.test_remdup) \\<in> [my_bremdup_impl_loc]\\<^sub>a nat_assn\\<^sup>k \\<rightarrow> nat_assn\"", "lemma test_bremdup1_refine: \"(test_bremdup1, my_bremdup_impl_loc.test_remdup) \\<in> [\\<lambda>N. N>0]\\<^sub>a nat_assn\\<^sup>k \\<rightarrow> nat_assn\"", "lemmas [sepref_fr_rules] = test_bremdup1_refine", "lemmas [sepref_fr_rules] = co_set_gen1.refine"], "translations": [["", "lemma min_of_list1_refine: \"(min_of_list1,min_of_list) \\<in> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (min_of_list1, min_of_list)\n    \\<in> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel", "text \\<open>This lemma has to be read as follows: If the argument given to \n      @{const min_of_list1} and @{const min_of_list} are related \n      by @{const Id} (i.e.\\ are identical), then the result of @{const min_of_list1} is\n      a refinement of the result of @{const min_of_list}, wrt.\\ relation @{const Id}.\n\n      For an explanation, lets simplify the statement first:\n      \\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (min_of_list1, min_of_list)\n    \\<in> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel", "apply (clarsimp intro!: nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a'. min_of_list1 a' \\<le> min_of_list a'", "text \\<open>The @{typ \"_ nres\"} type defines the refinement ordering, which is a lifted subset ordering,\n      with @{term FAIL} being the greatest element. This means, that we can assume a \n      non-empty list during the refinement proof \n      (otherwise, the RHS will be @{term FAIL}, and the statement becomes trivial)\n\n      The Isabelle Refinement Framework provides various techniques to extract verification \n      conditions from given goals, we use the standard VCG here:\n      \\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a'. min_of_list1 a' \\<le> min_of_list a'", "unfolding min_of_list_def min_of_list1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a'.\n       ASSERT (a' \\<noteq> []) \\<bind>\n       (\\<lambda>_. RETURN (fold min (tl a') (hd a')))\n       \\<le> ASSERT (a' \\<noteq> []) \\<bind>\n             (\\<lambda>_.\n                 SPEC (\\<lambda>x. \\<forall>y\\<in>set a'. x \\<le> y))", "apply (refine_vcg)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a'.\n       \\<lbrakk>a' \\<noteq> []; a' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<forall>y\\<in>set a'.\n                            fold min (tl a') (hd a') \\<le> y", "text \\<open>The VCG leaves us with a standard HOL goal, which is easily provable\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a'.\n       \\<lbrakk>a' \\<noteq> []; a' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<forall>y\\<in>set a'.\n                            fold min (tl a') (hd a') \\<le> y", "by (auto simp: neq_Nil_conv Min.set_eq_fold[symmetric])"], ["", "text \\<open>A more concise proof of the same lemma omits the initial simplification, \n    which we only inserted to explain the refinement ordering: \\<close>"], ["", "lemma \"(min_of_list1,min_of_list) \\<in> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (min_of_list1, min_of_list)\n    \\<in> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel", "unfolding min_of_list_def[abs_def] min_of_list1_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>l.\n        ASSERT (l \\<noteq> []) \\<bind>\n        (\\<lambda>_. RETURN (fold min (tl l) (hd l))),\n     \\<lambda>l.\n        ASSERT (l \\<noteq> []) \\<bind>\n        (\\<lambda>_. SPEC (\\<lambda>x. \\<forall>y\\<in>set l. x \\<le> y)))\n    \\<in> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel", "apply (refine_vcg)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> Id; a' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> a \\<noteq> []\n 2. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> Id; a' \\<noteq> []; a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<forall>y\\<in>set a'.\n                            fold min (tl a) (hd a) \\<le> y", "by (auto simp: neq_Nil_conv Min.set_eq_fold[symmetric])"], ["", "subsubsection \\<open>Refined Abstract Algorithm\\<close>"], ["", "text \\<open>Now, we have a nice functional implementation. \n    However, we are interested in an imperative implementation.\n    Ultimately, we want to implement the list by an array. \n    Thus, we replace folding over the list by indexing into the list,\n    and also add an index-shift to get rid of the @{term hd} and @{term tl}.\n    \\<close>"], ["", "definition min_of_list2 :: \"'a::linorder list \\<Rightarrow> 'a nres\" \n    where \"min_of_list2 l \\<equiv> ASSERT (l\\<noteq>[]) \\<then> RETURN (fold (\\<lambda>i. min (l!(i+1))) [0..<length l - 1] (l!0))\""], ["", "text \\<open>Proving refinement is straightforward, using the @{thm [source] fold_idx_conv} lemma.\\<close>"], ["", "lemma min_of_list2_refine: \"(min_of_list2, min_of_list1)\\<in>Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (min_of_list2, min_of_list1)\n    \\<in> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel", "unfolding min_of_list2_def[abs_def] min_of_list1_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>l.\n        ASSERT (l \\<noteq> []) \\<bind>\n        (\\<lambda>_.\n            RETURN\n             (fold (\\<lambda>i. min (l ! (i + 1))) [0..<length l - 1]\n               (l ! 0))),\n     \\<lambda>l.\n        ASSERT (l \\<noteq> []) \\<bind>\n        (\\<lambda>_. RETURN (fold min (tl l) (hd l))))\n    \\<in> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel", "apply refine_vcg"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> Id; a' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> a \\<noteq> []\n 2. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> Id; a' \\<noteq> []; a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (fold (\\<lambda>i. min (a ! (i + 1)))\n                           [0..<length a - 1] (a ! 0),\n                          fold min (tl a') (hd a'))\n                         \\<in> Id", "apply clarsimp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<noteq> [] \\<Longrightarrow>\n       fold (\\<lambda>i. min (a ! Suc i)) [0..<length a - Suc 0] (a ! 0) =\n       fold min (tl a) (hd a)", "apply (rewrite in \"_=\\<hole>\" fold_idx_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<noteq> [] \\<Longrightarrow>\n       fold (\\<lambda>i. min (a ! Suc i)) [0..<length a - Suc 0] (a ! 0) =\n       fold (\\<lambda>i. min (tl a ! i)) [0..<length (tl a)] (hd a)", "by (auto simp: nth_tl hd_conv_nth)"], ["", "subsubsection \\<open>Imperative Algorithm\\<close>"], ["", "text \\<open>The version @{const min_of_list2} already looks like the desired imperative version,\n    only that we have lists instead of arrays, and would like to replace the folding over \n    @{term \"[0..<length l -1]\"} by a for-loop. \n\n    This is exactly what the Sepref-tool does. The following command synthesizes \n    an imperative version \\<open>min_of_list3\\<close> of the algorithm for natural numbers, \n    which uses an array instead of a list:\n    \\<close>"], ["", "sepref_definition min_of_list3 is min_of_list2 :: \"(array_assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, min_of_list2)\n    \\<in> (array_assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "unfolding min_of_list2_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>l.\n        ASSERT (l \\<noteq> []) \\<bind>\n        (\\<lambda>_.\n            RETURN\n             (fold (\\<lambda>i. min (l ! (i + 1))) [0..<length l - 1]\n               (l ! 0))))\n    \\<in> (array_assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "by sepref"], ["", "text \\<open>The generated constant represents an Imperative/HOL program, and\n    is executable: \\<close>"], ["", "thm min_of_list3_def"], ["", "export_code min_of_list3 checking SML_imp"], ["", "text \\<open>Also note that the Sepref tool applied a deforestation optimization: \n    It recognizes a fold over @{term \"[0..<n]\"}, and implements it by the \n    tail-recursive function @{const \"imp_for'\"}, which uses a counter instead of \n    an intermediate list. \n\n    There are a couple of optimizations, which come in the form of two sets of \n    simplifier rules, which are applied one after the other:\n    \\<close>"], ["", "thm sepref_opt_simps"], ["", "thm sepref_opt_simps2"], ["", "text \\<open>They are just named theorem collections, e.g., \\<open>sepref_opt_simps add/del\\<close> \n    can be used to modify them.\\<close>"], ["", "text \\<open>Moreover, a refinement theorem is generated, which states the correspondence between\n    @{const min_of_list3} and @{const min_of_list2}: \\<close>"], ["", "thm min_of_list3.refine"], ["", "text \\<open>It states the relations between the parameter and the result of \n    the concrete and abstract function. The parameter is related by \n    @{term \"array_assn nat_assn\"}. Here, @{term \"array_assn A\"} relates arrays \n    with lists, such that the elements are related @{term A} --- in our case by \n    \\<open>nat_assn\\<close>, which relates natural numbers to themselves. \n    We also say that we @{emph \\<open>implement\\<close>} lists of nats by arrays of nats.\n    The result is also implemented by natural numbers. \n\n    Moreover, the parameters may be stored on the heap, and we have to indicate whether\n    the function keeps them intact or not. Here, we use the annotation \\<open>_\\<^sup>k\\<close> (for @{emph \\<open>keep\\<close>}) to indicate \n    that the parameter is kept intact, and \\<open>_\\<^sup>d\\<close> (for @{emph \\<open>destroy\\<close>}) to indicate that it is destroyed.\n    \\<close>"], ["", "subsubsection \\<open>Overall Correctness Statement\\<close>"], ["", "text \\<open>Finally, we can use transitivity of refinement to link our implementation to\n    the specification. The @{attribute FCOMP} attribute is able to compose refinement \n    theorems:\\<close>"], ["", "theorem min_of_list3_correct: \"(min_of_list3,min_of_list) \\<in> (array_assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (min_of_list3, min_of_list)\n    \\<in> (array_assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "using min_of_list3.refine[FCOMP min_of_list2_refine, FCOMP min_of_list1_refine]"], ["proof (prove)\nusing this:\n  (min_of_list3, min_of_list)\n  \\<in> (array_assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\n\ngoal (1 subgoal):\n 1. (min_of_list3, min_of_list)\n    \\<in> (array_assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "."], ["", "text \\<open>While the above statement is suited to re-use the algorithm within the sepref-framework,\n    a more low-level correctness theorem can be stated using separation logic.\n    This has the advantage that understanding the statement depends on less \n    definitional overhead:\\<close>"], ["", "lemma \"l\\<noteq>[] \\<Longrightarrow> <array_assn nat_assn l a> min_of_list3 a <\\<lambda>x. array_assn nat_assn l a * \\<up>(\\<forall>y\\<in>set l. x\\<le>y)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    <array_assn nat_assn l\n      a> min_of_list3\n          a <\\<lambda>r.\n                array_assn nat_assn l a *\n                \\<up> (\\<forall>y\\<in>set l. r \\<le> y)>\\<^sub>t", "text \\<open>The proof of this theorem has to unfold the several layers of the Sepref framework,\n      down to the separation logic layer. An explanation of these layers is out of scope of this\n      quickstart guide, we just present some proof techniques that often work. In the best case,\n      the fully automatic proof will work:\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    <array_assn nat_assn l\n      a> min_of_list3\n          a <\\<lambda>r.\n                array_assn nat_assn l a *\n                \\<up> (\\<forall>y\\<in>set l. r \\<le> y)>\\<^sub>t", "by (sep_auto \n      simp: min_of_list_def pure_def pw_le_iff refine_pw_simps\n      heap: min_of_list3_correct[THEN hfrefD, of l a, THEN hn_refineD, simplified])"], ["", "text \\<open>If the automatic method does not work, here is a more explicit proof, \n    that can be adapted for proving similar statements:\\<close>"], ["", "lemma \"l\\<noteq>[] \\<Longrightarrow> <array_assn nat_assn l a> min_of_list3 a <\\<lambda>x. array_assn nat_assn l a * \\<up>(\\<forall>y\\<in>set l. x\\<le>y)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    <array_assn nat_assn l\n      a> min_of_list3\n          a <\\<lambda>r.\n                array_assn nat_assn l a *\n                \\<up> (\\<forall>y\\<in>set l. r \\<le> y)>\\<^sub>t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    <array_assn nat_assn l\n      a> min_of_list3\n          a <\\<lambda>r.\n                array_assn nat_assn l a *\n                \\<up> (\\<forall>y\\<in>set l. r \\<le> y)>\\<^sub>t", "text \\<open>We inlined the definition of @{const min_of_list}. \n      This will yield two proof obligations later, which we discharge as auxiliary lemmas here\n      \\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    <array_assn nat_assn l\n      a> min_of_list3\n          a <\\<lambda>r.\n                array_assn nat_assn l a *\n                \\<up> (\\<forall>y\\<in>set l. r \\<le> y)>\\<^sub>t", "assume [simp]: \"l\\<noteq>[]\""], ["proof (state)\nthis:\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    <array_assn nat_assn l\n      a> min_of_list3\n          a <\\<lambda>r.\n                array_assn nat_assn l a *\n                \\<up> (\\<forall>y\\<in>set l. r \\<le> y)>\\<^sub>t", "have [simp]: \"nofail (min_of_list l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (min_of_list l)", "by (auto simp: min_of_list_def refine_pw_simps)"], ["proof (state)\nthis:\n  nofail (min_of_list l)\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    <array_assn nat_assn l\n      a> min_of_list3\n          a <\\<lambda>r.\n                array_assn nat_assn l a *\n                \\<up> (\\<forall>y\\<in>set l. r \\<le> y)>\\<^sub>t", "have 1: \"\\<And>x. RETURN x \\<le> min_of_list l \\<Longrightarrow> \\<forall>y\\<in>set l. x\\<le>y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       RETURN x \\<le> min_of_list l \\<Longrightarrow>\n       \\<forall>y\\<in>set l. x \\<le> y", "by (auto simp: min_of_list_def pw_le_iff refine_pw_simps)"], ["proof (state)\nthis:\n  RETURN ?x \\<le> min_of_list l \\<Longrightarrow>\n  \\<forall>y\\<in>set l. ?x \\<le> y\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    <array_assn nat_assn l\n      a> min_of_list3\n          a <\\<lambda>r.\n                array_assn nat_assn l a *\n                \\<up> (\\<forall>y\\<in>set l. r \\<le> y)>\\<^sub>t", "note rl = min_of_list3_correct[THEN hfrefD, of l a, THEN hn_refineD, simplified]"], ["proof (state)\nthis:\n  <array_assn nat_assn l a> min_of_list3 a\n  <\\<lambda>r.\n      \\<exists>\\<^sub>Ax.\n         array_assn nat_assn l a * nat_assn x r * true *\n         \\<up> (RETURN x \\<le> min_of_list l)>\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    <array_assn nat_assn l\n      a> min_of_list3\n          a <\\<lambda>r.\n                array_assn nat_assn l a *\n                \\<up> (\\<forall>y\\<in>set l. r \\<le> y)>\\<^sub>t", "text \\<open>This should yield a Hoare-triple for @{term \"min_of_list3 a\"}, \n      which can now be used to prove the desired statement via a consequence rule\\<close>"], ["proof (state)\nthis:\n  <array_assn nat_assn l a> min_of_list3 a\n  <\\<lambda>r.\n      \\<exists>\\<^sub>Ax.\n         array_assn nat_assn l a * nat_assn x r * true *\n         \\<up> (RETURN x \\<le> min_of_list l)>\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    <array_assn nat_assn l\n      a> min_of_list3\n          a <\\<lambda>r.\n                array_assn nat_assn l a *\n                \\<up> (\\<forall>y\\<in>set l. r \\<le> y)>\\<^sub>t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. <array_assn nat_assn l\n      a> min_of_list3\n          a <\\<lambda>r.\n                array_assn nat_assn l a *\n                \\<up> (\\<forall>y\\<in>set l. r \\<le> y)>\\<^sub>t", "apply (rule cons_rule[OF _ _ rl])"], ["proof (prove)\ngoal (2 subgoals):\n 1. array_assn nat_assn l a \\<Longrightarrow>\\<^sub>A\n    array_assn nat_assn l a\n 2. \\<And>x.\n       \\<exists>\\<^sub>Axa.\n          array_assn nat_assn l a * nat_assn xa x * true *\n          \\<up> (RETURN xa \\<le> min_of_list l) \\<Longrightarrow>\\<^sub>A\n       array_assn nat_assn l a * \\<up> (\\<forall>y\\<in>set l. x \\<le> y) *\n       true", "text \\<open>The preconditions should match, however, @{method sep_auto} is also able to discharge\n        more complicated implications here. Be sure to simplify with @{thm [source] pure_def},\n        if you have parameters that are not stored on the heap (in our case, we don't, but include the\n        simplification anyway.)\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. array_assn nat_assn l a \\<Longrightarrow>\\<^sub>A\n    array_assn nat_assn l a\n 2. \\<And>x.\n       \\<exists>\\<^sub>Axa.\n          array_assn nat_assn l a * nat_assn xa x * true *\n          \\<up> (RETURN xa \\<le> min_of_list l) \\<Longrightarrow>\\<^sub>A\n       array_assn nat_assn l a * \\<up> (\\<forall>y\\<in>set l. x \\<le> y) *\n       true", "apply (sep_auto simp: pure_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>\\<^sub>Axa.\n          array_assn nat_assn l a * nat_assn xa x * true *\n          \\<up> (RETURN xa \\<le> min_of_list l) \\<Longrightarrow>\\<^sub>A\n       array_assn nat_assn l a * \\<up> (\\<forall>y\\<in>set l. x \\<le> y) *\n       true", "text \\<open>The heap-parts of the postcondition should also match. \n        The pure parts require the auxiliary statements that we proved above.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>\\<^sub>Axa.\n          array_assn nat_assn l a * nat_assn xa x * true *\n          \\<up> (RETURN xa \\<le> min_of_list l) \\<Longrightarrow>\\<^sub>A\n       array_assn nat_assn l a * \\<up> (\\<forall>y\\<in>set l. x \\<le> y) *\n       true", "apply (sep_auto simp: pure_def dest!: 1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  <array_assn nat_assn l\n    a> min_of_list3\n        a <\\<lambda>r.\n              array_assn nat_assn l a *\n              \\<up> (\\<forall>y\\<in>set l. r \\<le> y)>\\<^sub>t\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Using the Algorithm\\<close>"], ["", "text \\<open>As an example, we now want to use our algorithm to compute the minimum value\n    of some concrete list. In order to use an algorithm, we have to declare both, \n    it's abstract version and its implementation to the Sepref tool. \n    \\<close>"], ["", "sepref_register min_of_list\n    \\<comment> \\<open>This command registers the abstract version, and generates \n        an @{emph \\<open>interface type\\<close>} for it. We will explain interface types later,  \n        and only note that, by default, the interface type corresponds to the operation's\n        HOL type.\\<close>"], ["", "declare min_of_list3_correct[sepref_fr_rules]  \n    \\<comment> \\<open>This declares the implementation to Sepref\\<close>"], ["", "text \\<open>Now we can define the abstract version of our example algorithm.\n    We compute the minimum value of pseudo-random lists of a given length\n    \\<close>"], ["", "primrec rand_list_aux :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat list\" where\n    \"rand_list_aux s 0 = []\"\n  | \"rand_list_aux s (Suc n) = (let s = (1664525 * s + 1013904223) mod 2^32 in s # rand_list_aux s n)\""], ["", "definition \"rand_list \\<equiv> rand_list_aux 42\""], ["", "definition \"min_of_rand_list n = min_of_list (rand_list n)\""], ["", "text \\<open>And use Sepref to synthesize a concrete version\\<close>"], ["", "text \\<open>We use a feature of Sepref to combine imperative and purely functional code,\n    and leave the generation of the list purely functional, then copy it into an array,\n    and invoke our algorithm. We have to declare the @{const rand_list} operation:\\<close>"], ["", "sepref_register rand_list"], ["", "lemma [sepref_import_param]: \"(rand_list,rand_list)\\<in>nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rand_list, rand_list)\n    \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_rel", "by auto"], ["", "text \\<open>Here, we use a feature of Sepref to import parametricity theorems.\n    Note that the parametricity theorem we provide here is trivial, as \n    @{const nat_rel} is identity, and @{const list_rel} as well as @{term \"(\\<rightarrow>)\"} \n    preserve identity. \n    However, we have to specify a parametricity theorem that reflects the \n    structure of the involved types.\n  \\<close>"], ["", "text \\<open>Finally, we can invoke Sepref\\<close>"], ["", "sepref_definition min_of_rand_list1 is \"min_of_rand_list\" :: \"nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, min_of_rand_list)\n    \\<in> nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "unfolding min_of_rand_list_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, \\<lambda>n. min_of_list (rand_list n))\n    \\<in> nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "text \\<open>We construct a plain list, however, the implementation of @{const min_of_list}\n      expects an array. We have to insert a conversion, which is conveniently done\n      with the @{method rewrite} method:\n      \\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, \\<lambda>n. min_of_list (rand_list n))\n    \\<in> nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "apply (rewrite in \"min_of_list \\<hole>\" array_fold_custom_of_list)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, \\<lambda>n. min_of_list (op_array_of_list (rand_list n)))\n    \\<in> nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "by sepref"], ["", "text \\<open>In the generated code, we see that the pure @{const rand_list} function \n    is invoked, its result is converted to an array, which is then passed to \n    @{const min_of_list3}.\n\n    Note that @{command sepref_definition} prints the generated theorems to the \n    output on the end of the proof. Use the output panel, or hover the mouse over \n    the by-command to see this output.\n  \\<close>"], ["", "text \\<open>The generated algorithm can be exported\\<close>"], ["", "export_code min_of_rand_list1 checking SML OCaml? Haskell? Scala"], ["", "text \\<open>and executed\\<close>"], ["", "ML_val \\<open>@{code min_of_rand_list1} (@{code nat_of_integer} 100) ()\\<close>"], ["", "text \\<open>Note that Imperative/HOL for ML generates a function from unit, \n    and applying this function triggers execution.\\<close>"], ["", "subsection \\<open>Binary Search Example\\<close>"], ["", "text \\<open>As second example, we consider a simple binary search algorithm.\n  We specify the abstract problem, i.e., finding an element in a sorted list.\n\\<close>"], ["", "definition \"in_sorted_list x xs \\<equiv> ASSERT (sorted xs) \\<then> RETURN (x\\<in>set xs)\""], ["", "text \\<open>And give a standard iterative implementation:\\<close>"], ["", "definition \"in_sorted_list1_invar x xs \\<equiv> \\<lambda>(l,u,found).\n    (l\\<le>u \\<and> u\\<le>length xs)\n  \\<and> (found \\<longrightarrow> x\\<in>set xs)\n  \\<and> (\\<not>found \\<longrightarrow> (x\\<notin>set (take l xs) \\<and> x\\<notin>set (drop u xs))\n  )\""], ["", "definition \"in_sorted_list1 x xs \\<equiv> do {\n  let l=0;\n  let u=length xs;\n  (_,_,r) \\<leftarrow> WHILEIT (in_sorted_list1_invar x xs)\n    (\\<lambda>(l,u,found). l<u \\<and> \\<not>found) (\\<lambda>(l,u,found). do {\n      let i = (l+u) div 2;\n      ASSERT (i<length xs); \\<comment> \\<open>Added here to help synthesis to prove precondition for array indexing\\<close>\n      let xi = xs!i;\n      if x=xi then\n        RETURN (l,u,True)\n      else if x<xi then\n        RETURN (l,i,False)\n      else  \n        RETURN (i+1,u,False)\n  \n    }) (l,u,False);\n  RETURN r  \n}\""], ["", "text \\<open>Note that we can refine certain operations only if we can prove that their \n  preconditions are matched. For example, we can refine list indexing to array \n  indexing only if we can prove that the index is in range. This proof has to be \n  done during the synthesis procedure. However, such precondition proofs may be \n  hard, in particular for automatic methods, and we have to do them anyway when \n  proving correct our abstract implementation. Thus, it is a good idea to assert\n  the preconditions in the abstract implementation. This way, they are immediately\n  available during synthesis (recall, when refining an assertion, you may assume\n  the asserted predicate @{thm le_ASSERTI}).\n  \n  An alternative is to use monadic list operations that already assert their precondition.\n  The advantage is that you cannot forget to assert the precondition, the disadvantage\n  is that the operation is monadic, and thus, nesting it into other operations is more cumbersome.\n  In our case, the operation would be @{const mop_list_get} \n  (Look at it's simplified definition to get an impression what it does). \n\\<close>"], ["", "thm mop_list_get_alt"], ["", "text \\<open>We first prove the refinement correct\\<close>"], ["", "context begin"], ["", "private"], ["", "lemma isl1_measure: \"wf (measure (\\<lambda>(l,u,f). u-l + (if f then 0 else 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (measure (\\<lambda>(l, u, f). u - l + (if f then 0 else 1)))", "by simp"], ["", "private"], ["", "lemma neq_nlt_is_gt:\n  fixes a b :: \"'a::linorder\"  \n  shows \"a\\<noteq>b \\<Longrightarrow> \\<not>(a<b) \\<Longrightarrow> a>b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> b; \\<not> a < b\\<rbrakk> \\<Longrightarrow> b < a", "by simp"], ["", "private"], ["", "lemma isl1_aux1:\n  assumes \"sorted xs\"\n  assumes \"i<length xs\"\n  assumes \"xs!i < x\"\n  shows \"x\\<notin>set (take i xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> set (take i xs)", "using assms"], ["proof (prove)\nusing this:\n  sorted xs\n  i < length xs\n  xs ! i < x\n\ngoal (1 subgoal):\n 1. x \\<notin> set (take i xs)", "by (auto simp: take_set leD sorted_nth_mono)"], ["", "private"], ["", "lemma isl1_aux2: \n  assumes \"x \\<notin> set (take n xs)\"\n  shows \"x\\<notin>set (drop n xs) \\<longleftrightarrow> x\\<notin>set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<notin> set (drop n xs)) = (x \\<notin> set xs)", "apply (rewrite in \"_ = \\<hole>\" append_take_drop_id[of n,symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<notin> set (drop n xs)) = (x \\<notin> set (take n xs @ drop n xs))", "using assms"], ["proof (prove)\nusing this:\n  x \\<notin> set (take n xs)\n\ngoal (1 subgoal):\n 1. (x \\<notin> set (drop n xs)) = (x \\<notin> set (take n xs @ drop n xs))", "by (auto simp del: append_take_drop_id)"], ["", "lemma in_sorted_list1_refine: \"(in_sorted_list1, in_sorted_list)\\<in>Id \\<rightarrow> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (in_sorted_list1, in_sorted_list)\n    \\<in> Id \\<rightarrow>\n          Id \\<rightarrow> \\<langle>bool_rel\\<rangle>nres_rel", "unfolding in_sorted_list1_def[abs_def] in_sorted_list_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x xs.\n        let l = 0; u = length xs\n        in WHILE\\<^sub>T\\<^bsup>in_sorted_list1_invar x xs\\<^esup>\n            (\\<lambda>(l, u, found). l < u \\<and> \\<not> found)\n            (\\<lambda>(l, u, found).\n                let i = (l + u) div 2\n                in ASSERT (i < length xs) \\<bind>\n                   (\\<lambda>_.\n                       let xi = xs ! i\n                       in if x = xi then RETURN (l, u, True)\n                          else if x < xi then RETURN (l, i, False)\n                               else RETURN (i + 1, u, False)))\n            (l, u, False) \\<bind>\n           (\\<lambda>(uu_, uu_, r). RETURN r),\n     \\<lambda>x xs.\n        ASSERT (sorted xs) \\<bind> (\\<lambda>_. RETURN (x \\<in> set xs)))\n    \\<in> Id \\<rightarrow>\n          Id \\<rightarrow> \\<langle>bool_rel\\<rangle>nres_rel", "apply (refine_vcg isl1_measure)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> Id; sorted a'a\\<rbrakk>\n       \\<Longrightarrow> in_sorted_list1_invar a aa (0, length aa, False)\n 2. \\<And>a a' aa a'a s ab b ac ba.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> Id; sorted a'a;\n        in_sorted_list1_invar a aa s;\n        case s of (l, u, found) \\<Rightarrow> l < u \\<and> \\<not> found;\n        s = (ab, b); b = (ac, ba)\\<rbrakk>\n       \\<Longrightarrow> (ab + ac) div 2 < length aa\n 3. \\<And>a a' aa a'a s ab b ac ba.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> Id; sorted a'a;\n        in_sorted_list1_invar a aa s;\n        case s of (l, u, found) \\<Rightarrow> l < u \\<and> \\<not> found;\n        s = (ab, b); b = (ac, ba); (ab + ac) div 2 < length aa;\n        a = aa ! ((ab + ac) div 2)\\<rbrakk>\n       \\<Longrightarrow> in_sorted_list1_invar a aa (ab, ac, True)\n 4. \\<And>a a' aa a'a s ab b ac ba.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> Id; sorted a'a;\n        in_sorted_list1_invar a aa s;\n        case s of (l, u, found) \\<Rightarrow> l < u \\<and> \\<not> found;\n        s = (ab, b); b = (ac, ba); (ab + ac) div 2 < length aa;\n        a = aa ! ((ab + ac) div 2)\\<rbrakk>\n       \\<Longrightarrow> ((ab, ac, True), s)\n                         \\<in> measure\n                                (\\<lambda>(l, u, f).\n                                    u - l + (if f then 0 else 1))\n 5. \\<And>a a' aa a'a s ab b ac ba.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> Id; sorted a'a;\n        in_sorted_list1_invar a aa s;\n        case s of (l, u, found) \\<Rightarrow> l < u \\<and> \\<not> found;\n        s = (ab, b); b = (ac, ba); (ab + ac) div 2 < length aa;\n        a \\<noteq> aa ! ((ab + ac) div 2);\n        a < aa ! ((ab + ac) div 2)\\<rbrakk>\n       \\<Longrightarrow> in_sorted_list1_invar a aa\n                          (ab, (ab + ac) div 2, False)\n 6. \\<And>a a' aa a'a s ab b ac ba.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> Id; sorted a'a;\n        in_sorted_list1_invar a aa s;\n        case s of (l, u, found) \\<Rightarrow> l < u \\<and> \\<not> found;\n        s = (ab, b); b = (ac, ba); (ab + ac) div 2 < length aa;\n        a \\<noteq> aa ! ((ab + ac) div 2);\n        a < aa ! ((ab + ac) div 2)\\<rbrakk>\n       \\<Longrightarrow> ((ab, (ab + ac) div 2, False), s)\n                         \\<in> measure\n                                (\\<lambda>(l, u, f).\n                                    u - l + (if f then 0 else 1))\n 7. \\<And>a a' aa a'a s ab b ac ba.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> Id; sorted a'a;\n        in_sorted_list1_invar a aa s;\n        case s of (l, u, found) \\<Rightarrow> l < u \\<and> \\<not> found;\n        s = (ab, b); b = (ac, ba); (ab + ac) div 2 < length aa;\n        a \\<noteq> aa ! ((ab + ac) div 2);\n        \\<not> a < aa ! ((ab + ac) div 2)\\<rbrakk>\n       \\<Longrightarrow> in_sorted_list1_invar a aa\n                          ((ab + ac) div 2 + 1, ac, False)\n 8. \\<And>a a' aa a'a s ab b ac ba.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> Id; sorted a'a;\n        in_sorted_list1_invar a aa s;\n        case s of (l, u, found) \\<Rightarrow> l < u \\<and> \\<not> found;\n        s = (ab, b); b = (ac, ba); (ab + ac) div 2 < length aa;\n        a \\<noteq> aa ! ((ab + ac) div 2);\n        \\<not> a < aa ! ((ab + ac) div 2)\\<rbrakk>\n       \\<Longrightarrow> (((ab + ac) div 2 + 1, ac, False), s)\n                         \\<in> measure\n                                (\\<lambda>(l, u, f).\n                                    u - l + (if f then 0 else 1))\n 9. \\<And>a a' aa a'a s ab b ac ba.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> Id; sorted a'a;\n        in_sorted_list1_invar a aa s;\n        \\<not> (case s of\n                (l, u, found) \\<Rightarrow> l < u \\<and> \\<not> found);\n        s = (ab, b); b = (ac, ba)\\<rbrakk>\n       \\<Longrightarrow> (ba, a' \\<in> set a'a) \\<in> bool_rel", "apply (vc_solve simp: in_sorted_list1_invar_def isl1_aux1 isl1_aux2 solve: asm_rl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a' a'a aba aca baa.\n       \\<lbrakk>sorted a'a; (aba + aca) div 2 < length a'a;\n        a' \\<noteq> a'a ! ((aba + aca) div 2);\n        a' < a'a ! ((aba + aca) div 2); aca \\<le> length a'a; aba < aca;\n        \\<not> baa; a' \\<notin> set (take aba a'a);\n        a' \\<notin> set (drop aca a'a)\\<rbrakk>\n       \\<Longrightarrow> aba \\<le> (aba + aca) div 2 \\<and>\n                         a' \\<notin> set (drop ((aba + aca) div 2) a'a)\n 2. \\<And>a' a'a aba aca baa.\n       \\<lbrakk>sorted a'a; (aba + aca) div 2 < length a'a;\n        a' \\<noteq> a'a ! ((aba + aca) div 2);\n        \\<not> a' < a'a ! ((aba + aca) div 2); aca \\<le> length a'a;\n        aba < aca; \\<not> baa; a' \\<notin> set (take aba a'a);\n        a' \\<notin> set (drop aca a'a)\\<rbrakk>\n       \\<Longrightarrow> Suc ((aba + aca) div 2) \\<le> aca \\<and>\n                         a' \\<notin> set\n(take (Suc ((aba + aca) div 2)) a'a)", "apply (auto simp: take_set set_drop_conv leD sorted_nth_mono) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a' a'a aba aca baa.\n       \\<lbrakk>sorted a'a; (aba + aca) div 2 < length a'a;\n        a' \\<noteq> a'a ! ((aba + aca) div 2);\n        \\<not> a' < a'a ! ((aba + aca) div 2); aca \\<le> length a'a;\n        aba < aca; \\<not> baa; a' \\<notin> set (take aba a'a);\n        a' \\<notin> set (drop aca a'a)\\<rbrakk>\n       \\<Longrightarrow> Suc ((aba + aca) div 2) \\<le> aca \\<and>\n                         a' \\<notin> set\n(take (Suc ((aba + aca) div 2)) a'a)", "apply (auto simp: take_set leD sorted_nth_mono dest: neq_nlt_is_gt) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "text \\<open>First, let's synthesize an implementation where the list elements are natural numbers. \n  We will discuss later how to generalize the implementation for arbitrary types.\n\n  For technical reasons, the Sepref tool works with uncurried functions. That is, every\n  function has exactly one argument. You can use the @{term uncurry} function,\n  and we also provide abbreviations @{term uncurry2} up to @{term uncurry5}.\n  If a function has no parameters, @{term uncurry0} adds a unit parameter.\n\\<close>"], ["", "sepref_definition in_sorted_list2 is \"uncurry in_sorted_list1\" :: \"nat_assn\\<^sup>k *\\<^sub>a (array_assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry in_sorted_list1)\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a\n          (array_assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "unfolding in_sorted_list1_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>x xs.\n          let l = 0; u = length xs\n          in WHILE\\<^sub>T\\<^bsup>in_sorted_list1_invar x xs\\<^esup>\n              (\\<lambda>(l, u, found). l < u \\<and> \\<not> found)\n              (\\<lambda>(l, u, found).\n                  let i = (l + u) div 2\n                  in ASSERT (i < length xs) \\<bind>\n                     (\\<lambda>_.\n                         let xi = xs ! i\n                         in if x = xi then RETURN (l, u, True)\n                            else if x < xi then RETURN (l, i, False)\n                                 else RETURN (i + 1, u, False)))\n              (l, u, False) \\<bind>\n             (\\<lambda>(uu_, uu_, r). RETURN r)))\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a\n          (array_assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "by sepref"], ["", "export_code in_sorted_list2 checking SML"], ["", "lemmas in_sorted_list2_correct = in_sorted_list2.refine[FCOMP in_sorted_list1_refine]"], ["", "subsection \\<open>Basic Troubleshooting\\<close>"], ["", "text \\<open>\n  In this section, we will explain how to investigate problems with the Sepref tool.\n  Most cases where @{method sepref} fails are due to some \n  missing operations, unsolvable preconditions, or an odd setup. \n\\<close>"], ["", "subsubsection \\<open>Example\\<close>"], ["", "text \\<open>We start with an example. Recall the binary search algorithm. \n  This time, we forget to assert the precondition of the indexing operation.\n\\<close>"], ["", "definition \"in_sorted_list1' x xs \\<equiv> do {\n  let l=0;\n  let u=length xs;\n  (_,_,r) \\<leftarrow> WHILEIT (in_sorted_list1_invar x xs)\n    (\\<lambda>(l,u,found). l<u \\<and> \\<not>found) (\\<lambda>(l,u,found). do {\n      let i = (l+u) div 2;\n      let xi = xs!i; \\<comment> \\<open>It's not trivial to show that \\<open>i\\<close> is in range\\<close>\n      if x=xi then\n        RETURN (l,u,True)\n      else if x<xi then\n        RETURN (l,i,False)\n      else  \n        RETURN (i+1,u,False)\n  \n    }) (l,u,False);\n  RETURN r  \n}\""], ["", "text \\<open>We try to synthesize the implementation. Note that @{command sepref_thm} behaves like \n  @{command sepref_definition}, but actually defines no constant. It only generates a refinement theorem.\\<close>"], ["", "sepref_thm in_sorted_list2 is \"uncurry in_sorted_list1'\" :: \"nat_assn\\<^sup>k *\\<^sub>a (array_assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry in_sorted_list1')\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a\n          (array_assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "unfolding in_sorted_list1'_def[abs_def]\n  (* apply sepref  Fails *)\n  \\<comment> \\<open>If @{method sepref} fails, you can use @{method sepref_dbg_keep} to get some more information.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>x xs.\n          let l = 0; u = length xs\n          in WHILE\\<^sub>T\\<^bsup>in_sorted_list1_invar x xs\\<^esup>\n              (\\<lambda>(l, u, found). l < u \\<and> \\<not> found)\n              (\\<lambda>(l, u, found).\n                  let i = (l + u) div 2; xi = xs ! i\n                  in if x = xi then RETURN (l, u, True)\n                     else if x < xi then RETURN (l, i, False)\n                          else RETURN (i + 1, u, False))\n              (l, u, False) \\<bind>\n             (\\<lambda>(uu_, uu_, r). RETURN r)))\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a\n          (array_assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "apply sepref_dbg_keep\n  \\<comment> \\<open>This prints a trace of the different phases of sepref, and stops when the first phase fails.\n    It then returns the internal proof state of the tool, which can be inspected further.\n    \n    Here, the translation phase fails. The translation phase translates the control structures and operations of\n    the abstract program to their concrete counterparts. To inspect the actual problem, we let translation run \n    until the operation where it fails:\\<close>"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>b bi a ai.\n       \\<lbrakk>a ::\\<^sub>i TYPE(nat); b ::\\<^sub>i TYPE(nat list)\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (array_assn nat_assn) b bi *\n                           hn_val nat_rel a ai)\n                          (?c142 b bi a ai) (?\\<Gamma>'7 b bi a ai)\n                          (?R7 b bi a ai)\n                          ((\\<bind>) $ (RETURN $ 0) $\n                           (\\<lambda>x.\n                               (#Let $ x $\n                                 (\\<lambda>x.\n                                     (#(\\<bind>) $\n (RETURN $ (op_list_length $ b)) $\n (\\<lambda>xa.\n     (#Let $ xa $\n       (\\<lambda>xa.\n           (#(\\<bind>) $\n             ((\\<bind>) $\n              ((\\<bind>) $\n               ((\\<bind>) $ (RETURN $ False) $\n                (\\<lambda>v1. (#RETURN $ (Pair $ xa $ v1)#))) $\n               (\\<lambda>v1. (#RETURN $ (Pair $ x $ v1)#))) $\n              (\\<lambda>x.\n                  (#PR_CONST (monadic_WHILEIT (in_sorted_list1_invar a b)) $\n                    (\\<lambda>x.\n                        (#case_prod $\n                          (\\<lambda>x.\n                              (#\\<lambda>xa.\n                                   (#case_prod $\n                                     (\\<lambda>xa.\n   (#\\<lambda>xb.\n        (#(\\<bind>) $ (RETURN $ ((<) $ x $ xa)) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $ (RETURN $ (Not $ xb)) $\n                (\\<lambda>v1. (#RETURN $ ((\\<and>) $ v0 $ v1)#))#))#)#)) $\n                                     xa#)#)) $\n                          x#)) $\n                    (\\<lambda>x.\n                        (#case_prod $\n                          (\\<lambda>x.\n                              (#\\<lambda>xa.\n                                   (#case_prod $\n                                     (\\<lambda>xa.\n   (#\\<lambda>xb.\n        (#(\\<bind>) $\n          ((\\<bind>) $ (RETURN $ ((+) $ x $ xa)) $\n           (\\<lambda>v0.\n               (#(\\<bind>) $ (RETURN $ PR_CONST 2) $\n                 (\\<lambda>v1. (#RETURN $ ((div) $ v0 $ v1)#))#))) $\n          (\\<lambda>xb.\n              (#Let $ xb $\n                (\\<lambda>xb.\n                    (#(\\<bind>) $ (RETURN $ (op_list_get $ b $ xb)) $\n                      (\\<lambda>xc.\n                          (#Let $ xc $\n                            (\\<lambda>xc.\n                                (#(\\<bind>) $ (RETURN $ ((=) $ a $ xc)) $\n                                  (\\<lambda>xd.\n(#If $ xd $\n  ((\\<bind>) $\n   ((\\<bind>) $ (RETURN $ True) $\n    (\\<lambda>v1. (#RETURN $ (Pair $ xa $ v1)#))) $\n   (\\<lambda>v1. (#RETURN $ (Pair $ x $ v1)#))) $\n  ((\\<bind>) $ (RETURN $ ((<) $ a $ xc)) $\n   (\\<lambda>xc.\n       (#If $ xc $\n         ((\\<bind>) $\n          ((\\<bind>) $ (RETURN $ False) $\n           (\\<lambda>v1. (#RETURN $ (Pair $ xb $ v1)#))) $\n          (\\<lambda>v1. (#RETURN $ (Pair $ x $ v1)#))) $\n         ((\\<bind>) $\n          ((\\<bind>) $ (RETURN $ 1) $\n           (\\<lambda>v1. (#RETURN $ ((+) $ xb $ v1)#))) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $\n                ((\\<bind>) $ (RETURN $ False) $\n                 (\\<lambda>v1. (#RETURN $ (Pair $ xa $ v1)#))) $\n                (\\<lambda>v1.\n                    (#RETURN $\n                      (Pair $ v0 $ v1)#))#)))#)))#))#))#))#))#))#)#)) $\n                                     xa#)#)) $\n                          x#)) $\n                    x#))) $\n             (\\<lambda>x.\n                 (#case_prod $\n                   (\\<lambda>x.\n                       (#\\<lambda>x.\n                            (#case_prod $\n                              (\\<lambda>x. (#\\<lambda>x. (#PASS $ x#)#)) $\n                              x#)#)) $\n                   x#))#))#))#))#)))\n 2. \\<And>b bi a ai.\n       \\<lbrakk>a ::\\<^sub>i TYPE(nat); b ::\\<^sub>i TYPE(nat list)\\<rbrakk>\n       \\<Longrightarrow> CNV (?c142 b bi a ai) (?f6 ai bi)\n 3. \\<And>b bi a ai.\n       \\<lbrakk>a ::\\<^sub>i TYPE(nat); b ::\\<^sub>i TYPE(nat list)\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>'7 b bi a ai \\<Longrightarrow>\\<^sub>t\n                         hn_ctxt (array_assn nat_assn) b bi *\n                         hn_val nat_rel a ai\n 4. \\<And>b bi a ai aa c.\n       \\<lbrakk>a ::\\<^sub>i TYPE(nat); b ::\\<^sub>i TYPE(nat list)\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt (?R7 b bi a ai) aa\n                          c \\<Longrightarrow>\\<^sub>t\n                         hn_val bool_rel aa c\n 5. CONSTRAINT_SLOT (True)", "supply [[goals_limit=1]] \\<comment> \\<open>There will be many subgoals during translation, and printing them takes very long with Isabelle :(\\<close>"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>b bi a ai.\n       \\<lbrakk>a ::\\<^sub>i TYPE(nat); b ::\\<^sub>i TYPE(nat list)\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (array_assn nat_assn) b bi *\n                           hn_val nat_rel a ai)\n                          (?c142 b bi a ai) (?\\<Gamma>'7 b bi a ai)\n                          (?R7 b bi a ai)\n                          ((\\<bind>) $ (RETURN $ 0) $\n                           (\\<lambda>x.\n                               (#Let $ x $\n                                 (\\<lambda>x.\n                                     (#(\\<bind>) $\n (RETURN $ (op_list_length $ b)) $\n (\\<lambda>xa.\n     (#Let $ xa $\n       (\\<lambda>xa.\n           (#(\\<bind>) $\n             ((\\<bind>) $\n              ((\\<bind>) $\n               ((\\<bind>) $ (RETURN $ False) $\n                (\\<lambda>v1. (#RETURN $ (Pair $ xa $ v1)#))) $\n               (\\<lambda>v1. (#RETURN $ (Pair $ x $ v1)#))) $\n              (\\<lambda>x.\n                  (#PR_CONST (monadic_WHILEIT (in_sorted_list1_invar a b)) $\n                    (\\<lambda>x.\n                        (#case_prod $\n                          (\\<lambda>x.\n                              (#\\<lambda>xa.\n                                   (#case_prod $\n                                     (\\<lambda>xa.\n   (#\\<lambda>xb.\n        (#(\\<bind>) $ (RETURN $ ((<) $ x $ xa)) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $ (RETURN $ (Not $ xb)) $\n                (\\<lambda>v1. (#RETURN $ ((\\<and>) $ v0 $ v1)#))#))#)#)) $\n                                     xa#)#)) $\n                          x#)) $\n                    (\\<lambda>x.\n                        (#case_prod $\n                          (\\<lambda>x.\n                              (#\\<lambda>xa.\n                                   (#case_prod $\n                                     (\\<lambda>xa.\n   (#\\<lambda>xb.\n        (#(\\<bind>) $\n          ((\\<bind>) $ (RETURN $ ((+) $ x $ xa)) $\n           (\\<lambda>v0.\n               (#(\\<bind>) $ (RETURN $ PR_CONST 2) $\n                 (\\<lambda>v1. (#RETURN $ ((div) $ v0 $ v1)#))#))) $\n          (\\<lambda>xb.\n              (#Let $ xb $\n                (\\<lambda>xb.\n                    (#(\\<bind>) $ (RETURN $ (op_list_get $ b $ xb)) $\n                      (\\<lambda>xc.\n                          (#Let $ xc $\n                            (\\<lambda>xc.\n                                (#(\\<bind>) $ (RETURN $ ((=) $ a $ xc)) $\n                                  (\\<lambda>xd.\n(#If $ xd $\n  ((\\<bind>) $\n   ((\\<bind>) $ (RETURN $ True) $\n    (\\<lambda>v1. (#RETURN $ (Pair $ xa $ v1)#))) $\n   (\\<lambda>v1. (#RETURN $ (Pair $ x $ v1)#))) $\n  ((\\<bind>) $ (RETURN $ ((<) $ a $ xc)) $\n   (\\<lambda>xc.\n       (#If $ xc $\n         ((\\<bind>) $\n          ((\\<bind>) $ (RETURN $ False) $\n           (\\<lambda>v1. (#RETURN $ (Pair $ xb $ v1)#))) $\n          (\\<lambda>v1. (#RETURN $ (Pair $ x $ v1)#))) $\n         ((\\<bind>) $\n          ((\\<bind>) $ (RETURN $ 1) $\n           (\\<lambda>v1. (#RETURN $ ((+) $ xb $ v1)#))) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $\n                ((\\<bind>) $ (RETURN $ False) $\n                 (\\<lambda>v1. (#RETURN $ (Pair $ xa $ v1)#))) $\n                (\\<lambda>v1.\n                    (#RETURN $\n                      (Pair $ v0 $ v1)#))#)))#)))#))#))#))#))#))#)#)) $\n                                     xa#)#)) $\n                          x#)) $\n                    x#))) $\n             (\\<lambda>x.\n                 (#case_prod $\n                   (\\<lambda>x.\n                       (#\\<lambda>x.\n                            (#case_prod $\n                              (\\<lambda>x. (#\\<lambda>x. (#PASS $ x#)#)) $\n                              x#)#)) $\n                   x#))#))#))#))#)))\nA total of 5 subgoals...", "apply sepref_dbg_trans_keep\n  \\<comment> \\<open>Things get stuck at a goal with predicate @{const hn_refine}. This is the internal refinement predicate,\n    @{term \"hn_refine \\<Gamma> c \\<Gamma>' R a\"} means, that, for operands whose refinement is described by @{term \\<Gamma>},\n    the concrete program @{term c} refines the abstract program @{term a}, such that, afterwards, the operands\n    are described by @{term \\<Gamma>'}, and the results are refined by @{term R}.\n    \n    Inspecting the first subgoal reveals that we got stuck on refining the abstract operation\n    @{term \"RETURN $ (op_list_get $ b $ xf)\"}. Note that the @{term \"($)\"} is just a constant for function \n    application, which is used to tame Isabelle's higher-order unification algorithms. You may use \n    \\<open>unfolding APP_def\\<close>, or even \\<open>simp\\<close> to get a clearer picture of the failed goal.\n\n    If a translation step fails, it may be helpful to execute as much of the translation step as possible:\\<close>"], ["proof (prove)\ngoal (19 subgoals):\n 1. \\<And>b bi a ai x x' xa x'a xb x'b xc x'c xd x'd s' s a1 a2 a1' a2' a1a\n       a2a a1'a a2'a xe x'e xf x'f.\n       \\<lbrakk>a ::\\<^sub>i TYPE(nat); b ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag x (RETURN $ 0); xa = x;\n        bind_ref_tag xb (RETURN $ (op_list_length $ b)); xc = xb;\n        bind_ref_tag xd\n         ((\\<bind>) $\n          ((\\<bind>) $ (RETURN $ False) $\n           (\\<lambda>v1. (#RETURN $ (Pair $ xc $ v1)#))) $\n          (\\<lambda>v1. (#RETURN $ (Pair $ xa $ v1)#)));\n        in_sorted_list1_invar a b s'; s' = (a1', a2'); a2' = (a1'a, a2'a);\n        bind_ref_tag xe\n         ((\\<bind>) $ (RETURN $ ((+) $ a1' $ a1'a)) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $ (RETURN $ PR_CONST 2) $\n                (\\<lambda>v1. (#RETURN $ ((div) $ v0 $ v1)#))#)));\n        xf = xe\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_invalid (nat_assn \\<times>\\<^sub>a bool_assn)\n                            a2' a2 *\n                           hn_invalid\n                            (nat_assn \\<times>\\<^sub>a\n                             nat_assn \\<times>\\<^sub>a bool_assn)\n                            s' s *\n                           hn_invalid nat_assn xa x'a *\n                           hn_val nat_rel a ai *\n                           hn_ctxt (array_assn nat_assn) b bi *\n                           hn_invalid nat_assn xc x'c *\n                           hn_val bool_rel a2'a a2a *\n                           hn_val nat_rel a1' a1 *\n                           hn_val nat_rel a1'a a1a *\n                           hn_val nat_rel xf x'f)\n                          (?m'419 b bi a ai x' x'a x'b x'c x'd s a1 a2 a1a\n                            a2a x'e x'f)\n                          (?\\<Gamma>1.418 b bi a ai x x' xa x'a xb x'b xc\n                            x'c xd x'd s' s a1 a2 a1' a2' a1a a2a a1'a a2'a\n                            xe x'e xf x'f)\n                          (?Rh418 b bi a ai x x' xa x'a xb x'b xc x'c xd x'd\n                            s' s a1 a2 a1' a2' a1a a2a a1'a a2'a xe x'e xf\n                            x'f)\n                          (RETURN $ (op_list_get $ b $ xf))\nA total of 19 subgoals...", "apply sepref_dbg_trans_step_keep\n  \\<comment> \\<open>The translation step gets stuck at proving @{term \"pre_list_get (b, xf)\"}, which is the \n    precondition for list indexing.\\<close>"], ["proof (prove)\ngoal (19 subgoals):\n 1. \\<And>b bi a ai x x' xa x'a xb x'b xc x'c xd x'd s' s a1 a2 a1' a2' a1a\n       a2a a1'a a2'a xe x'e xf x'f.\n       \\<lbrakk>a ::\\<^sub>i TYPE(nat); b ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag x (RETURN $ 0); xa = x;\n        bind_ref_tag xb (RETURN $ (op_list_length $ b)); xc = xb;\n        bind_ref_tag xd\n         ((\\<bind>) $\n          ((\\<bind>) $ (RETURN $ False) $\n           (\\<lambda>v1. (#RETURN $ (Pair $ xc $ v1)#))) $\n          (\\<lambda>v1. (#RETURN $ (Pair $ xa $ v1)#)));\n        in_sorted_list1_invar a b s'; s' = (a1', a2'); a2' = (a1'a, a2'a);\n        bind_ref_tag xe\n         ((\\<bind>) $ (RETURN $ ((+) $ a1' $ a1'a)) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $ (RETURN $ PR_CONST 2) $\n                (\\<lambda>v1. (#RETURN $ ((div) $ v0 $ v1)#))#)));\n        xf = xe;\n        vassn_tag\n         (hn_val nat_rel xf x'f *\n          hn_ctxt (array_assn nat_assn) b bi)\\<rbrakk>\n       \\<Longrightarrow> pre_list_get (b, xf)\nA total of 19 subgoals...", "apply (sepref_dbg_side_keep) \\<comment> \\<open>If you think the side-condition should be provable, this command \n    returns the left-over subgoals after some preprocessing and applying auto\\<close>"], ["proof (prove)\ngoal (19 subgoals):\n 1. \\<And>b a a1' a1'a a2'a.\n       \\<lbrakk>in_sorted_list1_invar a b (a1', a1'a, a2'a);\n        rdomp (array_assn nat_assn) b\\<rbrakk>\n       \\<Longrightarrow> (a1' + a1'a) div 2 < length b\nA total of 19 subgoals...", "(* apply sepref_dbg_side_unfold (* Preprocessing only*) *)"], ["proof (prove)\ngoal (19 subgoals):\n 1. \\<And>b a a1' a1'a a2'a.\n       \\<lbrakk>in_sorted_list1_invar a b (a1', a1'a, a2'a);\n        rdomp (array_assn nat_assn) b\\<rbrakk>\n       \\<Longrightarrow> (a1' + a1'a) div 2 < length b\nA total of 19 subgoals...", "oops"], ["", "subsubsection \\<open>Internals of Sepref\\<close>"], ["", "text \\<open>\n  Internally, @{method sepref} consists of multiple phases that are executed\n  one after the other. Each phase comes with its own debugging method, which \n  only executes that phase. We illustrate this by repeating the refinement of\n  @{const \"min_of_list2\"}. This time, we use @{command sepref_thm}, which only\n  generates a refinement theorem, but defines no constants:\n\\<close>"], ["", "sepref_thm min_of_list3' is min_of_list2 :: \"(array_assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\"\n  \\<comment> \\<open>The \\<open>sepref_thm\\<close> or \\<open>sepref_definition\\<close> command assembles a schematic \n    goal statement.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, min_of_list2)\n    \\<in> (array_assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "unfolding min_of_list2_def[abs_def] \n  \\<comment> \\<open>The preprocessing phase converts the goal into \n    the @{const \"hn_refine\"}-form. Moreover, it adds interface type \n    annotations for the parameters. (for now, the interface type is just the HOL \n    type of the parameter, in our case, @{typ \"nat list\"})\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>l.\n        ASSERT (l \\<noteq> []) \\<bind>\n        (\\<lambda>_.\n            RETURN\n             (fold (\\<lambda>i. min (l ! (i + 1))) [0..<length l - 1]\n               (l ! 0))))\n    \\<in> (array_assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "apply sepref_dbg_preproc\n  \\<comment> \\<open>The next phase applies a consequence rule for the postcondition and\n    result. This is mainly for technical reasons.\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_refine (hn_ctxt (array_assn nat_assn) x xi) (?fi1 xi)\n        (hn_ctxt (array_assn nat_assn) x xi) nat_assn\n        (ASSERT (x \\<noteq> []) \\<bind>\n         (\\<lambda>_.\n             RETURN\n              (fold (\\<lambda>i. min (x ! (i + 1))) [0..<length x - 1]\n                (x ! 0))))\n 2. CONSTRAINT_SLOT (True)", "apply sepref_dbg_cons_init\n  \\<comment> \\<open>The next phase tries to identify the abstract operations, and inserts\n    tag-constants for function application and abstraction. These tags are for \n    technical reasons, working around Isabelle/HOL's unifier idiosyncrasies.\n\n    Operation identification assigns a single constant to each abstract operation,\n    which is required for technical reasons. Note that there are terms in HOL, \n    which qualify as a single operation, but consists of multiple constants, \n    for example, @{term \"{x}\"}, which is just syntactic sugar for \n    @{term [source] \"insert x {}\"}. In our case, the operation identification \n    phase rewrites the assertion operations followed by a bind to a single \n    operation @{const op_ASSERT_bind}, and renames some operations to more \n    canonical names.\\<close>"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_refine (hn_ctxt (array_assn nat_assn) x xi) (?fi4 xi)\n        (?\\<Gamma>'5 x xi) (?R5 x xi)\n        (ASSERT (x \\<noteq> []) \\<bind>\n         (\\<lambda>_.\n             RETURN\n              (fold (\\<lambda>i. min (x ! (i + 1))) [0..<length x - 1]\n                (x ! 0))))\n 2. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (array_assn nat_assn) x xi\n 3. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (?R5 x xi) a c \\<Longrightarrow>\\<^sub>t hn_val nat_rel a c\n 4. CONSTRAINT_SLOT (True)", "apply sepref_dbg_id\n  \\<comment> \\<open>Now that it is clear which operations to execute, we have to specify an \n    execution order. Note that HOL has no notion of execution at all. However,\n    if we want to translate to operations that depend on a heap, we need a notion \n    of execution order. We use the \\<open>nres\\<close>-monad's bind operation as sequencing operator,\n    and flatten all nested operations, using left-to-right evaluation order.\\<close>"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_refine (hn_ctxt (array_assn nat_assn) x xi) (?fi4 xi)\n        (?\\<Gamma>'5 x xi) (?R5 x xi)\n        (PR_CONST (op_ASSERT_bind (x \\<noteq> [])) $\n         (RETURN $\n          (fold $\n           (\\<lambda>xa. (#min $ (op_list_get $ x $ ((+) $ xa $ 1))#)) $\n           (upt $ 0 $ ((-) $ (op_list_length $ x) $ 1)) $\n           (op_list_get $ x $ 0))))\n 2. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (array_assn nat_assn) x xi\n 3. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (?R5 x xi) a c \\<Longrightarrow>\\<^sub>t hn_val nat_rel a c\n 4. CONSTRAINT_SLOT (True)", "apply sepref_dbg_monadify\n  \\<comment> \\<open>The next step just prepares the optimization phase,\n    which will be executed on the translated program. It just applies the rule   \n    @{thm TRANS_init}.\\<close>"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_refine (hn_ctxt (array_assn nat_assn) x xi) (?fi4 xi)\n        (?\\<Gamma>'5 x xi) (?R5 x xi)\n        (PR_CONST (op_ASSERT_bind (x \\<noteq> [])) $\n         ((\\<bind>) $\n          ((\\<bind>) $ (RETURN $ 0) $\n           (\\<lambda>v0.\n               (#(\\<bind>) $\n                 ((\\<bind>) $ (RETURN $ (op_list_length $ x)) $\n                  (\\<lambda>v0.\n                      (#(\\<bind>) $ (RETURN $ 1) $\n                        (\\<lambda>v1. (#RETURN $ ((-) $ v0 $ v1)#))#))) $\n                 (\\<lambda>v1. (#RETURN $ (upt $ v0 $ v1)#))#))) $\n          (\\<lambda>xa.\n              (#(\\<bind>) $\n                ((\\<bind>) $ (RETURN $ 0) $\n                 (\\<lambda>v1. (#RETURN $ (op_list_get $ x $ v1)#))) $\n                (\\<lambda>xb.\n                    (#monadic_nfoldli $ xa $\n                      (\\<lambda>x. (#RETURN $ True#)) $\n                      (\\<lambda>xa.\n                          (#\\<lambda>xb.\n                               (#(\\<bind>) $\n                                 ((\\<bind>) $\n                                  ((\\<bind>) $ (RETURN $ 1) $\n                                   (\\<lambda>v1.\n (#RETURN $ ((+) $ xa $ v1)#))) $\n                                  (\\<lambda>v1.\n(#RETURN $ (op_list_get $ x $ v1)#))) $\n                                 (\\<lambda>v0.\n                                     (#RETURN $ (min $ v0 $ xb)#))#)#)) $\n                      xb#))#))))\n 2. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (array_assn nat_assn) x xi\n 3. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (?R5 x xi) a c \\<Longrightarrow>\\<^sub>t hn_val nat_rel a c\n 4. CONSTRAINT_SLOT (True)", "apply sepref_dbg_opt_init\n  \\<comment> \\<open>The translation phase does the main job of translating the abstract program\n    to the concrete one. It has rules how to translate abstract operations to\n    concrete ones. For technical reasons, it differentiates between \n    operations, which have only first-order arguments (e.g., @{const length})   \n    and combinators, which have also higher-order arguments (e.g., @{const fold}).\n\n    The basic idea of translation is to repeatedly apply the translation rule for the\n    topmost combinator/operator, and thus recursively translate the whole program.\n    The rules may produce various types of side-conditions, which are resolved by the tool.\\<close>"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_refine (hn_ctxt (array_assn nat_assn) x xi) (?c58 x xi)\n        (?\\<Gamma>'5 x xi) (?R5 x xi)\n        (PR_CONST (op_ASSERT_bind (x \\<noteq> [])) $\n         ((\\<bind>) $\n          ((\\<bind>) $ (RETURN $ 0) $\n           (\\<lambda>v0.\n               (#(\\<bind>) $\n                 ((\\<bind>) $ (RETURN $ (op_list_length $ x)) $\n                  (\\<lambda>v0.\n                      (#(\\<bind>) $ (RETURN $ 1) $\n                        (\\<lambda>v1. (#RETURN $ ((-) $ v0 $ v1)#))#))) $\n                 (\\<lambda>v1. (#RETURN $ (upt $ v0 $ v1)#))#))) $\n          (\\<lambda>xa.\n              (#(\\<bind>) $\n                ((\\<bind>) $ (RETURN $ 0) $\n                 (\\<lambda>v1. (#RETURN $ (op_list_get $ x $ v1)#))) $\n                (\\<lambda>xb.\n                    (#monadic_nfoldli $ xa $\n                      (\\<lambda>x. (#RETURN $ True#)) $\n                      (\\<lambda>xa.\n                          (#\\<lambda>xb.\n                               (#(\\<bind>) $\n                                 ((\\<bind>) $\n                                  ((\\<bind>) $ (RETURN $ 1) $\n                                   (\\<lambda>v1.\n (#RETURN $ ((+) $ xa $ v1)#))) $\n                                  (\\<lambda>v1.\n(#RETURN $ (op_list_get $ x $ v1)#))) $\n                                 (\\<lambda>v0.\n                                     (#RETURN $ (min $ v0 $ xb)#))#)#)) $\n                      xb#))#))))\n 2. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       CNV (?c58 x xi) (?fi4 xi)\n 3. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (array_assn nat_assn) x xi\n 4. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (?R5 x xi) a c \\<Longrightarrow>\\<^sub>t hn_val nat_rel a c\n 5. CONSTRAINT_SLOT (True)", "apply sepref_dbg_trans\n  \\<comment> \\<open>The next phase applies some simplification rules to optimize the translated program.\n    It essentially simplifies first with the rules @{thm [source] sepref_opt_simps}, and\n    then with @{thm [source] sepref_opt_simps2}.\\<close>"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       CNV (return 0 \\<bind>\n            (\\<lambda>x'.\n                Array.len $ xi \\<bind>\n                (\\<lambda>x'a.\n                    return 1 \\<bind>\n                    (\\<lambda>x'b. return (x'a - x'b))) \\<bind>\n                (\\<lambda>x'a. return [x'..<x'a])) \\<bind>\n            (\\<lambda>x'.\n                return 0 \\<bind> ($) (Array.nth $ xi) \\<bind>\n                imp_nfoldli x' (\\<lambda>\\<sigma>. return True)\n                 (\\<lambda>xc \\<sigma>.\n                     return 1 \\<bind>\n                     (\\<lambda>x'c. return (xc + x'c)) \\<bind>\n                     ($) (Array.nth $ xi) \\<bind>\n                     (\\<lambda>x'c. return (min x'c \\<sigma>)))))\n        (?fi29 xi)\n 2. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (array_assn nat_assn) x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (array_assn nat_assn) x xi\n 3. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_val nat_rel a c \\<Longrightarrow>\\<^sub>t hn_val nat_rel a c\n 4. CONSTRAINT_SLOT (True)", "apply sepref_dbg_opt\n  \\<comment> \\<open>The next two phases resolve the consequence rules introduced by the \\<open>cons_init\\<close> phase.\\<close>"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (array_assn nat_assn) x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (array_assn nat_assn) x xi\n 2. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_val nat_rel a c \\<Longrightarrow>\\<^sub>t hn_val nat_rel a c\n 3. CONSTRAINT_SLOT (True)", "apply sepref_dbg_cons_solve"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_val nat_rel a c \\<Longrightarrow>\\<^sub>t hn_val nat_rel a c\n 2. CONSTRAINT_SLOT (True)", "apply sepref_dbg_cons_solve\n  \\<comment> \\<open>The translation phase and the consequence rule solvers may postpone some\n    side conditions on yet-unknown refinement assertions. These are solved in the \n    last phase.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. CONSTRAINT_SLOT (True)", "apply sepref_dbg_constraints"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>In the next sections, we will explain, by example, how to troubleshoot \n  the various phases of the tool. We will focus on the phases that are most \n  likely to fail.\\<close>"], ["", "subsubsection \\<open>Initialization\\<close>"], ["", "text \\<open>A common mistake is to forget the keep/destroy markers for the\n  refinement assertion, or specify a refinement assertion with a non-matching\n  type. This results in a type-error on the command\\<close>"], ["", "(* Forgot keep/destroy *)\n(*sepref_thm min_of_list3' is min_of_list2 :: \"(array_assn nat_assn) \\<rightarrow>\\<^sub>a nat_assn\"*)\n\n(* Wrong type (@{term hs.assn} is for sets (hashset), not for lists) *)\n(*sepref_thm min_of_list3' is min_of_list2 :: \"(hs.assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\"*)\n\n(* Operand must be function to nres *)\n(*sepref_thm test is \"\\<lambda>x. 2+x\" :: \"nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\"*)\n(* Correct: *)"], ["", "sepref_thm test_add_2 is \"\\<lambda>x. RETURN (2+x)\" :: \"nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, \\<lambda>x. RETURN (2 + x))\n    \\<in> nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "by sepref"], ["", "(* Type correct, but nonsense: Yields a proof failed message, as the tool\n  expects a refinement assertion *)\n(*sepref_thm min_of_list3' is min_of_list2 :: \"undefined\"*)"], ["", "subsubsection \\<open>Translation Phase\\<close>"], ["", "text \\<open>In most cases, the translation phase will fail. Let's try the following refinement:\\<close>"], ["", "sepref_thm test is \"\\<lambda>l. RETURN (l!1 + 2)\" :: \"(array_assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, \\<lambda>l. RETURN (l ! 1 + 2))\n    \\<in> (array_assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "text \\<open>The @{method sepref} method will just fail. To investigate further, we use\n    @{method sepref_dbg_keep}, which executes the phases until the first one fails.\n    It returns with the proof state before the failed phase, and, moreover, outputs\n    a trace of the phases, such that you can easily see which phase failed.\n    \\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, \\<lambda>l. RETURN (l ! 1 + 2))\n    \\<in> (array_assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "apply sepref_dbg_keep\n  \\<comment> \\<open>In the trace, we see that the translation phase failed. We are presented\n    the tool's internal goal state just before translation. If a phase fails,\n    the usual procedure is to start the phase in debug mode, and see how far it gets.\n    The debug mode of the translation phase stops at the first operation or combinator\n    it cannot translate. Note, it is a good idea to limit the visible goals, as printing \n    goals in Isabelle can be very, very slow :(\\<close>"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_refine (hn_ctxt (array_assn nat_assn) x xi) (?c26 x xi)\n        (?\\<Gamma>'5 x xi) (?R5 x xi)\n        ((\\<bind>) $\n         ((\\<bind>) $ (RETURN $ 1) $\n          (\\<lambda>v1. (#RETURN $ (op_list_get $ x $ v1)#))) $\n         (\\<lambda>v0.\n             (#(\\<bind>) $ (RETURN $ PR_CONST 2) $\n               (\\<lambda>v1. (#RETURN $ ((+) $ v0 $ v1)#))#)))\n 2. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       CNV (?c26 x xi) (?fi4 xi)\n 3. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (array_assn nat_assn) x xi\n 4. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (?R5 x xi) a c \\<Longrightarrow>\\<^sub>t hn_val nat_rel a c\n 5. CONSTRAINT_SLOT (True)", "supply [[goals_limit = 1]]"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_refine (hn_ctxt (array_assn nat_assn) x xi) (?c26 x xi)\n        (?\\<Gamma>'5 x xi) (?R5 x xi)\n        ((\\<bind>) $\n         ((\\<bind>) $ (RETURN $ 1) $\n          (\\<lambda>v1. (#RETURN $ (op_list_get $ x $ v1)#))) $\n         (\\<lambda>v0.\n             (#(\\<bind>) $ (RETURN $ PR_CONST 2) $\n               (\\<lambda>v1. (#RETURN $ ((+) $ v0 $ v1)#))#)))\nA total of 5 subgoals...", "apply sepref_dbg_trans_keep\n  \\<comment> \\<open>Here, we see that translation gets stuck at \\<open>op_list_get\\<close>. This may have \n    two reasons: Either there is no rule for this operation, or a side condition \n    cannot be resolved. We apply a single translation step in debug mode, i.e., \n    the translation step is applied as far as possible, leaving unsolved side conditions:\\<close>"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x xi v1 x'.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag v1 (RETURN $ 1)\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (array_assn nat_assn) x xi * emp *\n                           hn_val nat_rel v1 x')\n                          (?f'28 x xi x') (?\\<Gamma>2.28 x xi v1 x')\n                          (?Rh27 x xi) (RETURN $ (op_list_get $ x $ v1))\nA total of 8 subgoals...", "apply sepref_dbg_trans_step_keep\n  \\<comment> \\<open>This method reports that the \"Apply rule\" phase produced a wrong number of subgoals.\n    This phase is expected to solve the goal, but left some unsolved side condition, which we\n    are presented in the goal state. We can either guess  \n    what @{term pre_list_get} means and why it cannot be solved, or try to partially\n    solve the side condition:\\<close>"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x xi v1 x'.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list); bind_ref_tag v1 (RETURN $ 1);\n        vassn_tag\n         (hn_val nat_rel v1 x' *\n          hn_ctxt (array_assn nat_assn) x xi)\\<rbrakk>\n       \\<Longrightarrow> pre_list_get (x, v1)\nA total of 8 subgoals...", "apply sepref_dbg_side_keep\n  \\<comment> \\<open>From the remaining subgoal, one can guess that there might be a problem \n    with too short lists, where index \\<open>1\\<close> does not exist.\\<close>"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x.\n       rdomp (array_assn nat_assn) x \\<Longrightarrow> Suc 0 < length x\nA total of 8 subgoals...", "(** You may use the following methods instead of sepref_dbg_side_keep to have \n    more control on how far the side-condition is solved. By default, you will see\n    the result of auto after unfolding the internal tags.\n  apply sepref_dbg_side_unfold apply simp\n  *)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x.\n       rdomp (array_assn nat_assn) x \\<Longrightarrow> Suc 0 < length x\nA total of 8 subgoals...", "oops"], ["", "text \\<open>Inserting an assertion into the abstract program solves the problem:\\<close>"], ["", "sepref_thm test is \"\\<lambda>l. ASSERT (length l > 1) \\<then> RETURN (l!1 + 2)\" :: \"(array_assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>l.\n        ASSERT (1 < length l) \\<bind> (\\<lambda>_. RETURN (l ! 1 + 2)))\n    \\<in> (array_assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "by sepref"], ["", "text \\<open>Here is an example for an unimplemented operation:\\<close>"], ["", "sepref_thm test is \"\\<lambda>l. RETURN (Min (set l))\" :: \"(array_assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, \\<lambda>l. RETURN (Min (set l)))\n    \\<in> (array_assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "supply [[goals_limit = 1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, \\<lambda>l. RETURN (Min (set l)))\n    \\<in> (array_assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "apply sepref_dbg_keep"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_refine (hn_ctxt (array_assn nat_assn) x xi) (?c14 x xi)\n        (?\\<Gamma>'5 x xi) (?R5 x xi)\n        ((\\<bind>) $ (RETURN $ (set $ x)) $\n         (\\<lambda>v0. (#RETURN $ (Min $ v0)#)))\nA total of 5 subgoals...", "apply sepref_dbg_trans_keep\n  \\<comment> \\<open>Translation stops at the \\<open>set\\<close> operation\\<close>"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_refine (hn_ctxt (array_assn nat_assn) x xi) (?m'15 x xi)\n        (?\\<Gamma>1.15 x xi) (?Rh15 x xi) (RETURN $ (set $ x))\nA total of 7 subgoals...", "apply sepref_dbg_trans_step_keep\n  \\<comment> \\<open>This tactic reports that the \"Apply rule\" phase failed, which means that \n    there is no applicable rule for the \\<open>set\\<close> operation on arrays.\\<close>"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x xi.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        vassn_tag (hn_ctxt (array_assn nat_assn) x xi)\\<rbrakk>\n       \\<Longrightarrow> hn_refine (hn_ctxt (array_assn nat_assn) x xi)\n                          (?m'15 x xi) (?\\<Gamma>''18 x xi) (?Rh15 x xi)\n                          (RETURN $ (set $ x))\nA total of 7 subgoals...", "oops"], ["", "subsection \\<open>The Isabelle Imperative Collection Framework (IICF)\\<close>"], ["", "text \\<open>\n  The IICF provides a library of imperative data structures, and some \n  management infrastructure. The main idea is to have interfaces and implementations.\n\n  An interface specifies an abstract data type (e.g., @{typ \"_ list\"}) and some operations with preconditions \n  on it (e.g., @{term \"(@)\"} or @{term \"nth\"} with in-range precondition). \n\n  An implementation of an interface provides a refinement assertion from the abstract data type to\n  some concrete data type, as well as implementations for (a subset of) the interface's operations.\n  The implementation may add some more implementation specific preconditions.\n  \n  The default interfaces of the IICF are in the folder \\<open>IICF/Intf\\<close>, and the standard implementations are in\n  \\<open>IICF/Impl\\<close>.\n\\<close>"], ["", "subsubsection \\<open>Map Example\\<close>"], ["", "text \\<open>Let's implement a function that maps a finite set to an initial \n  segment of the natural numbers\n\\<close>"], ["", "definition \"nat_seg_map s \\<equiv> \n  ASSERT (finite s) \\<then> SPEC (\\<lambda>m. dom m = s \\<and> ran m = {0..<card s})\""], ["", "text \\<open>We implement the function by iterating over the set, and building the map\\<close>"], ["", "definition \"nat_seg_map1 s \\<equiv> do {\n  ASSERT (finite s);\n  (m,_) \\<leftarrow> FOREACHi (\\<lambda>it (m,i). dom m = s-it \\<and> ran m = {0..<i} \\<and> i=card (s - it)) \n    s (\\<lambda>x (m,i). RETURN (m(x\\<mapsto>i),i+1)) (Map.empty,0);\n  RETURN m\n}\""], ["", "lemma nat_seg_map1_refine: \"(nat_seg_map1, nat_seg_map) \\<in> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (nat_seg_map1, nat_seg_map)\n    \\<in> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> Id \\<Longrightarrow>\n       (nat_seg_map1 a, nat_seg_map a') \\<in> \\<langle>Id\\<rangle>nres_rel", "unfolding nat_seg_map1_def[abs_def] nat_seg_map_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> Id \\<Longrightarrow>\n       (ASSERT (finite a) \\<bind>\n        (\\<lambda>_.\n            FOREACH\\<^bsup>\\<lambda>it (m, i).\n                              dom m = a - it \\<and>\n                              ran m = {0..<i} \\<and>\n                              i = card (a - it)\\<^esup>\n             a (\\<lambda>x (m, i). RETURN (m(x \\<mapsto> i), i + 1))\n             (Map.empty, 0) \\<bind>\n            (\\<lambda>(m, uu_). RETURN m)),\n        ASSERT (finite a') \\<bind>\n        (\\<lambda>_.\n            SPEC (\\<lambda>m. dom m = a' \\<and> ran m = {0..<card a'})))\n       \\<in> \\<langle>Id\\<rangle>nres_rel", "apply (refine_vcg)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> Id; finite a'\\<rbrakk>\n       \\<Longrightarrow> finite a\n 2. \\<And>a a' x1 x2.\n       \\<lbrakk>(a, a') \\<in> Id; finite a'; finite a;\n        (Map.empty, 0) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> dom x1 = a - a\n 3. \\<And>a a' x1 x2.\n       \\<lbrakk>(a, a') \\<in> Id; finite a'; finite a;\n        (Map.empty, 0) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> ran x1 = {0..<x2}\n 4. \\<And>a a' x1 x2.\n       \\<lbrakk>(a, a') \\<in> Id; finite a'; finite a;\n        (Map.empty, 0) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x2 = card (a - a)\n 5. \\<And>a a' x it \\<sigma> aa b x1 x2.\n       \\<lbrakk>(a, a') \\<in> Id; finite a'; finite a; x \\<in> it;\n        it \\<subseteq> a;\n        case \\<sigma> of\n        (m, i) \\<Rightarrow>\n          dom m = a - it \\<and> ran m = {0..<i} \\<and> i = card (a - it);\n        \\<sigma> = (aa, b); (aa(x \\<mapsto> b), b + 1) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> dom x1 = a - (it - {x})\n 6. \\<And>a a' x it \\<sigma> aa b x1 x2.\n       \\<lbrakk>(a, a') \\<in> Id; finite a'; finite a; x \\<in> it;\n        it \\<subseteq> a;\n        case \\<sigma> of\n        (m, i) \\<Rightarrow>\n          dom m = a - it \\<and> ran m = {0..<i} \\<and> i = card (a - it);\n        \\<sigma> = (aa, b); (aa(x \\<mapsto> b), b + 1) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> ran x1 = {0..<x2}\n 7. \\<And>a a' x it \\<sigma> aa b x1 x2.\n       \\<lbrakk>(a, a') \\<in> Id; finite a'; finite a; x \\<in> it;\n        it \\<subseteq> a;\n        case \\<sigma> of\n        (m, i) \\<Rightarrow>\n          dom m = a - it \\<and> ran m = {0..<i} \\<and> i = card (a - it);\n        \\<sigma> = (aa, b); (aa(x \\<mapsto> b), b + 1) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x2 = card (a - (it - {x}))\n 8. \\<And>a a' \\<sigma> aa b.\n       \\<lbrakk>(a, a') \\<in> Id; finite a'; finite a;\n        case \\<sigma> of\n        (m, i) \\<Rightarrow>\n          dom m = a - {} \\<and> ran m = {0..<i} \\<and> i = card (a - {});\n        \\<sigma> = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> dom aa = a'\n 9. \\<And>a a' \\<sigma> aa b.\n       \\<lbrakk>(a, a') \\<in> Id; finite a'; finite a;\n        case \\<sigma> of\n        (m, i) \\<Rightarrow>\n          dom m = a - {} \\<and> ran m = {0..<i} \\<and> i = card (a - {});\n        \\<sigma> = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> ran aa = {0..<card a'}", "apply (vc_solve simp: it_step_insert_iff solve: asm_rl dest: domD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>We use hashsets @{term \"hs.assn\"} and hashmaps (@{term \"hm.assn\"}). \\<close>"], ["", "sepref_definition nat_seg_map2 is nat_seg_map1 :: \"(hs.assn id_assn)\\<^sup>k \\<rightarrow>\\<^sub>a hm.assn id_assn nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, nat_seg_map1)\n    \\<in> (hs.assn\n            id_assn)\\<^sup>k \\<rightarrow>\\<^sub>a hm.assn id_assn nat_assn", "unfolding nat_seg_map1_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>s.\n        ASSERT (finite s) \\<bind>\n        (\\<lambda>_.\n            FOREACH\\<^bsup>\\<lambda>it (m, i).\n                              dom m = s - it \\<and>\n                              ran m = {0..<i} \\<and>\n                              i = card (s - it)\\<^esup>\n             s (\\<lambda>x (m, i). RETURN (m(x \\<mapsto> i), i + 1))\n             (Map.empty, 0) \\<bind>\n            (\\<lambda>(m, uu_). RETURN m)))\n    \\<in> (hs.assn\n            id_assn)\\<^sup>k \\<rightarrow>\\<^sub>a hm.assn id_assn nat_assn", "apply sepref_dbg_keep"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE('a set) \\<Longrightarrow>\n       hn_refine (hn_ctxt (hs.assn id_assn) x xi) (?c65 x xi)\n        (?\\<Gamma>'5 x xi) (?R5 x xi)\n        (PR_CONST (op_ASSERT_bind (finite x)) $\n         ((\\<bind>) $\n          ((\\<bind>) $\n           ((\\<bind>) $ (RETURN $ op_map_empty) $\n            (\\<lambda>v0.\n                (#(\\<bind>) $ (RETURN $ 0) $\n                  (\\<lambda>v1. (#RETURN $ (Pair $ v0 $ v1)#))#))) $\n           (\\<lambda>xa.\n               (#PR_CONST\n                  (monadic_FOREACH (\\<lambda>_ _. True)\n                    (\\<lambda>it.\n                        (#case_prod $\n                          (\\<lambda>m.\n                              (#\\<lambda>i.\n                                   (#(\\<and>) $\n                                     ((=) $ (dom $ m) $ ((-) $ x $ it)) $\n                                     ((\\<and>) $\n((=) $ (ran $ m) $ (atLeastLessThan $ 0 $ i)) $\n((=) $ i $ (card $ ((-) $ x $ it))))#)#))#))) $\n                 x $\n                 (\\<lambda>x. (#RETURN $ True#)) $\n                 (\\<lambda>x.\n                     (#\\<lambda>xa.\n                          (#case_prod $\n                            (\\<lambda>xa.\n                                (#\\<lambda>xb.\n                                     (#(\\<bind>) $\n (RETURN $ (op_map_update $ x $ xb $ xa)) $\n (\\<lambda>v0.\n     (#(\\<bind>) $\n       ((\\<bind>) $ (RETURN $ 1) $\n        (\\<lambda>v1. (#RETURN $ ((+) $ xb $ v1)#))) $\n       (\\<lambda>v1. (#RETURN $ (Pair $ v0 $ v1)#))#))#)#)) $\n                            xa#)#)) $\n                 xa#))) $\n          (\\<lambda>x.\n              (#case_prod $ (\\<lambda>x. (#\\<lambda>xa. (#PASS $ x#)#)) $\n                x#))))\n 2. \\<And>x xi.\n       x ::\\<^sub>i TYPE('a set) \\<Longrightarrow> CNV (?c65 x xi) (?fi4 xi)\n 3. \\<And>x xi.\n       x ::\\<^sub>i TYPE('a set) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (hs.assn id_assn) x xi\n 4. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE('a set) \\<Longrightarrow>\n       hn_ctxt (?R5 x xi) a c \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (hm.assn id_assn nat_assn) a c\n 5. CONSTRAINT_SLOT (True)", "apply sepref_dbg_trans_keep\n  \\<comment> \\<open>We got stuck at \\<open>op_map_empty\\<close>. This is because Sepref is very conservative \n    when it comes to guessing implementations. Actually, no constructor operation \n    will be assigned a default operation, with some obvious exceptions for numbers and Booleans.\\<close>"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>x xi.\n       \\<lbrakk>x ::\\<^sub>i TYPE('a set); finite x\\<rbrakk>\n       \\<Longrightarrow> hn_refine (hn_ctxt (hs.assn id_assn) x xi)\n                          (?m'69 x xi) (?\\<Gamma>1.69 x xi) (?Rh69 x xi)\n                          (RETURN $ op_map_empty)\n 2. \\<And>x xi v0 x'.\n       \\<lbrakk>x ::\\<^sub>i TYPE('a set); finite x;\n        bind_ref_tag v0 (RETURN $ op_map_empty)\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?\\<Gamma>1.69 x xi * hn_ctxt (?Rh69 x xi) v0 x')\n                          (?f'69 x xi x') (?\\<Gamma>2.69 x xi v0 x')\n                          (?Rh68 x xi)\n                          ((\\<bind>) $ (RETURN $ 0) $\n                           (\\<lambda>v1. (#RETURN $ (Pair $ v0 $ v1)#)))\n 3. \\<And>x xi v0 x'.\n       \\<lbrakk>x ::\\<^sub>i TYPE('a set); finite x\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.69 x xi v0 x' \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>1.68 x xi * hn_ctxt (?Rx69 x xi) v0 x'\n 4. \\<And>x xi xa x'.\n       \\<lbrakk>x ::\\<^sub>i TYPE('a set); finite x;\n        bind_ref_tag xa\n         ((\\<bind>) $ (RETURN $ op_map_empty) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $ (RETURN $ 0) $\n                (\\<lambda>v1. (#RETURN $ (Pair $ v0 $ v1)#))#)))\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?\\<Gamma>1.68 x xi * hn_ctxt (?Rh68 x xi) xa x')\n                          (?f'68 x xi x') (?\\<Gamma>2.68 x xi xa x')\n                          (?Rh67 x xi)\n                          (PR_CONST\n                            (monadic_FOREACH (\\<lambda>_ _. True)\n                              (\\<lambda>it.\n                                  (#case_prod $\n                                    (\\<lambda>m.\n  (#\\<lambda>i.\n       (#(\\<and>) $ ((=) $ (dom $ m) $ ((-) $ x $ it)) $\n         ((\\<and>) $ ((=) $ (ran $ m) $ (atLeastLessThan $ 0 $ i)) $\n          ((=) $ i $ (card $ ((-) $ x $ it))))#)#))#))) $\n                           x $\n                           (\\<lambda>x. (#RETURN $ True#)) $\n                           (\\<lambda>x.\n                               (#\\<lambda>xa.\n                                    (#case_prod $\n(\\<lambda>xa.\n    (#\\<lambda>xb.\n         (#(\\<bind>) $ (RETURN $ (op_map_update $ x $ xb $ xa)) $\n           (\\<lambda>v0.\n               (#(\\<bind>) $\n                 ((\\<bind>) $ (RETURN $ 1) $\n                  (\\<lambda>v1. (#RETURN $ ((+) $ xb $ v1)#))) $\n                 (\\<lambda>v1. (#RETURN $ (Pair $ v0 $ v1)#))#))#)#)) $\nxa#)#)) $\n                           xa)\n 5. \\<And>x xi xa x'.\n       \\<lbrakk>x ::\\<^sub>i TYPE('a set); finite x\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.68 x xi xa x' \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>1.67 x xi * hn_ctxt (?Rx68 x xi) xa x'\n 6. \\<And>x xi xa x'.\n       \\<lbrakk>x ::\\<^sub>i TYPE('a set); finite x;\n        bind_ref_tag xa\n         ((\\<bind>) $\n          ((\\<bind>) $ (RETURN $ op_map_empty) $\n           (\\<lambda>v0.\n               (#(\\<bind>) $ (RETURN $ 0) $\n                 (\\<lambda>v1. (#RETURN $ (Pair $ v0 $ v1)#))#))) $\n          (\\<lambda>xa.\n              (#PR_CONST\n                 (monadic_FOREACH (\\<lambda>_ _. True)\n                   (\\<lambda>it.\n                       (#case_prod $\n                         (\\<lambda>m.\n                             (#\\<lambda>i.\n                                  (#(\\<and>) $\n                                    ((=) $ (dom $ m) $ ((-) $ x $ it)) $\n                                    ((\\<and>) $\n                                     ((=) $ (ran $ m) $\n(atLeastLessThan $ 0 $ i)) $\n                                     ((=) $ i $\n(card $ ((-) $ x $ it))))#)#))#))) $\n                x $\n                (\\<lambda>x. (#RETURN $ True#)) $\n                (\\<lambda>x.\n                    (#\\<lambda>xa.\n                         (#case_prod $\n                           (\\<lambda>xa.\n                               (#\\<lambda>xb.\n                                    (#(\\<bind>) $\n(RETURN $ (op_map_update $ x $ xb $ xa)) $\n(\\<lambda>v0.\n    (#(\\<bind>) $\n      ((\\<bind>) $ (RETURN $ 1) $\n       (\\<lambda>v1. (#RETURN $ ((+) $ xb $ v1)#))) $\n      (\\<lambda>v1. (#RETURN $ (Pair $ v0 $ v1)#))#))#)#)) $\n                           xa#)#)) $\n                xa#)))\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?\\<Gamma>1.67 x xi * hn_ctxt (?Rh67 x xi) xa x')\n                          (?f'67 x xi x') (?\\<Gamma>2.67 x xi xa x')\n                          (?R5 x xi)\n                          (case_prod $\n                           (\\<lambda>x. (#\\<lambda>xa. (#PASS $ x#)#)) $\n                           xa)\n 7. \\<And>x xi xa x'.\n       \\<lbrakk>x ::\\<^sub>i TYPE('a set); finite x\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.67 x xi xa x' \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>'5 x xi * hn_ctxt (?Rx67 x xi) xa x'\n 8. \\<And>x xi.\n       x ::\\<^sub>i TYPE('a set) \\<Longrightarrow>\n       CNV (?m'69 x xi \\<bind> ?f'69 x xi \\<bind> ?f'68 x xi \\<bind>\n            ?f'67 x xi)\n        (?fi4 xi)\n 9. \\<And>x xi.\n       x ::\\<^sub>i TYPE('a set) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (hs.assn id_assn) x xi\n 10. \\<And>x xi a c.\n        x ::\\<^sub>i TYPE('a set) \\<Longrightarrow>\n        hn_ctxt (?R5 x xi) a c \\<Longrightarrow>\\<^sub>t\n        hn_ctxt (hm.assn id_assn nat_assn) a c\nA total of 11 subgoals...", "oops"], ["", "text \\<open>\n  Assignment of implementations to constructor operations is done by rewriting them to\n  synonyms which are bound to a specific implementation. For hashmaps, we have \n  @{const op_hm_empty}, and the rules @{thm [source] hm.fold_custom_empty}.\n\\<close>"], ["", "sepref_definition nat_seg_map2 is nat_seg_map1 :: \"(hs.assn id_assn)\\<^sup>k \\<rightarrow>\\<^sub>a hm.assn id_assn nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, nat_seg_map1)\n    \\<in> (hs.assn\n            id_assn)\\<^sup>k \\<rightarrow>\\<^sub>a hm.assn id_assn nat_assn", "unfolding nat_seg_map1_def[abs_def]\n  \\<comment> \\<open>We can use the @{method rewrite} method for position-precise rewriting:\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>s.\n        ASSERT (finite s) \\<bind>\n        (\\<lambda>_.\n            FOREACH\\<^bsup>\\<lambda>it (m, i).\n                              dom m = s - it \\<and>\n                              ran m = {0..<i} \\<and>\n                              i = card (s - it)\\<^esup>\n             s (\\<lambda>x (m, i). RETURN (m(x \\<mapsto> i), i + 1))\n             (Map.empty, 0) \\<bind>\n            (\\<lambda>(m, uu_). RETURN m)))\n    \\<in> (hs.assn\n            id_assn)\\<^sup>k \\<rightarrow>\\<^sub>a hm.assn id_assn nat_assn", "apply (rewrite in \"FOREACHi _ _ _ \\<hole>\" \"hm.fold_custom_empty\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>s.\n        ASSERT (finite s) \\<bind>\n        (\\<lambda>_.\n            FOREACH\\<^bsup>\\<lambda>it (m, i).\n                              dom m = s - it \\<and>\n                              ran m = {0..<i} \\<and>\n                              i = card (s - it)\\<^esup>\n             s (\\<lambda>x (m, i). RETURN (m(x \\<mapsto> i), i + 1))\n             (op_hm_empty, 0) \\<bind>\n            (\\<lambda>(m, uu_). RETURN m)))\n    \\<in> (hs.assn\n            id_assn)\\<^sup>k \\<rightarrow>\\<^sub>a hm.assn id_assn nat_assn", "by sepref"], ["", "export_code nat_seg_map2 checking SML"], ["", "lemmas nat_seg_map2_correct = nat_seg_map2.refine[FCOMP nat_seg_map1_refine]"], ["", "subsection \\<open>Specification of Preconditions\\<close>"], ["", "(*Move up! *)"], ["", "text \\<open>In this example, we will discuss how to specify precondition of operations, \n  which are required for refinement to work.\n  Consider the following function, which increments all members of a list by one:\n\\<close>"], ["", "definition \"incr_list l \\<equiv> map ((+) 1) l\""], ["", "text \\<open>We might want to implement it as follows\\<close>"], ["", "definition \"incr_list1 l \\<equiv> fold (\\<lambda>i l. l[i:=1 + l!i]) [0..<length l] l\""], ["", "lemma incr_list1_refine: \"(incr_list1, incr_list)\\<in>Id \\<rightarrow> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (incr_list1, incr_list) \\<in> Id \\<rightarrow> Id", "proof (intro fun_relI; simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. incr_list1 a = incr_list a", "fix l :: \"'a list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. incr_list1 a = incr_list a", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. incr_list1 a = incr_list a", "fix n m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. incr_list1 a = incr_list a", "assume \"n\\<le>m\" and \"length l = m\""], ["proof (state)\nthis:\n  n \\<le> m\n  length l = m\n\ngoal (1 subgoal):\n 1. \\<And>a. incr_list1 a = incr_list a", "hence \"fold (\\<lambda>i l. l[i:=1+l!i]) [n..<m] l = take n l @ map (((+))1) (drop n l)\""], ["proof (prove)\nusing this:\n  n \\<le> m\n  length l = m\n\ngoal (1 subgoal):\n 1. fold (\\<lambda>i l. l[i := (1::'a) + l ! i]) [n..<m] l =\n    take n l @ map ((+) (1::'a)) (drop n l)", "apply (induction  arbitrary: l rule: inc_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l.\n       length l = m \\<Longrightarrow>\n       fold (\\<lambda>i l. l[i := (1::'a) + l ! i]) [m..<m] l =\n       take m l @ map ((+) (1::'a)) (drop m l)\n 2. \\<And>na l.\n       \\<lbrakk>n \\<le> na; na < m;\n        \\<And>l.\n           length l = m \\<Longrightarrow>\n           fold (\\<lambda>i l. l[i := (1::'a) + l ! i]) [Suc na..<m] l =\n           take (Suc na) l @ map ((+) (1::'a)) (drop (Suc na) l);\n        length l = m\\<rbrakk>\n       \\<Longrightarrow> fold (\\<lambda>i l. l[i := (1::'a) + l ! i])\n                          [na..<m] l =\n                         take na l @ map ((+) (1::'a)) (drop na l)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na l.\n       \\<lbrakk>n \\<le> na; na < m;\n        \\<And>l.\n           length l = m \\<Longrightarrow>\n           fold (\\<lambda>i l. l[i := (1::'a) + l ! i]) [Suc na..<m] l =\n           take (Suc na) l @ map ((+) (1::'a)) (drop (Suc na) l);\n        length l = m\\<rbrakk>\n       \\<Longrightarrow> fold (\\<lambda>i l. l[i := (1::'a) + l ! i])\n                          [na..<m] l =\n                         take na l @ map ((+) (1::'a)) (drop na l)", "apply (clarsimp simp: upt_conv_Cons take_Suc_conv_app_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>na l.\n       \\<lbrakk>n \\<le> na; na < length l;\n        \\<And>la.\n           length la = length l \\<Longrightarrow>\n           fold (\\<lambda>i l. l[i := (1::'a) + l ! i]) [Suc na..<length l]\n            la =\n           take na la @ la ! na # map ((+) (1::'a)) (drop (Suc na) la);\n        m = length l\\<rbrakk>\n       \\<Longrightarrow> ((1::'a) + l ! na) #\n                         map ((+) (1::'a)) (drop (Suc na) l) =\n                         map ((+) (1::'a)) (drop na l)", "apply (auto simp add: list_eq_iff_nth_eq nth_Cons split: nat.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fold (\\<lambda>i l. l[i := (1::'a) + l ! i]) [n..<m] l =\n  take n l @ map ((+) (1::'a)) (drop n l)\n\ngoal (1 subgoal):\n 1. \\<And>a. incr_list1 a = incr_list a", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?n2 \\<le> ?m2; length l = ?m2\\<rbrakk>\n  \\<Longrightarrow> fold (\\<lambda>i l. l[i := (1::'a) + l ! i]) [?n2..<?m2]\n                     l =\n                    take ?n2 l @ map ((+) (1::'a)) (drop ?n2 l)\n\ngoal (1 subgoal):\n 1. \\<And>a. incr_list1 a = incr_list a", "from this[of 0 \"length l\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 \\<le> length l; length l = length l\\<rbrakk>\n  \\<Longrightarrow> fold (\\<lambda>i l. l[i := (1::'a) + l ! i])\n                     [0..<length l] l =\n                    take 0 l @ map ((+) (1::'a)) (drop 0 l)", "show \"incr_list1 l = incr_list l\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> length l; length l = length l\\<rbrakk>\n  \\<Longrightarrow> fold (\\<lambda>i l. l[i := (1::'a) + l ! i])\n                     [0..<length l] l =\n                    take 0 l @ map ((+) (1::'a)) (drop 0 l)\n\ngoal (1 subgoal):\n 1. incr_list1 l = incr_list l", "unfolding incr_list_def incr_list1_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> length l; length l = length l\\<rbrakk>\n  \\<Longrightarrow> fold (\\<lambda>i l. l[i := (1::'a) + l ! i])\n                     [0..<length l] l =\n                    take 0 l @ map ((+) (1::'a)) (drop 0 l)\n\ngoal (1 subgoal):\n 1. fold (\\<lambda>i l. l[i := (1::'a) + l ! i]) [0..<length l] l =\n    map ((+) (1::'a)) l", "by simp"], ["proof (state)\nthis:\n  incr_list1 l = incr_list l\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Trying to refine this reveals a problem:\\<close>"], ["", "sepref_thm incr_list2 is \"RETURN o incr_list1\" :: \"(array_assn nat_assn)\\<^sup>d \\<rightarrow>\\<^sub>a array_assn nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, RETURN \\<circ> incr_list1)\n    \\<in> (array_assn\n            nat_assn)\\<^sup>d \\<rightarrow>\\<^sub>a array_assn nat_assn", "unfolding incr_list1_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     RETURN \\<circ>\n     (\\<lambda>l. fold (\\<lambda>i l. l[i := 1 + l ! i]) [0..<length l] l))\n    \\<in> (array_assn\n            nat_assn)\\<^sup>d \\<rightarrow>\\<^sub>a array_assn nat_assn", "apply sepref_dbg_keep"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_refine (hn_ctxt (array_assn nat_assn) x xi) (?c44 x xi)\n        (?\\<Gamma>'5 x xi) (?R5 x xi)\n        ((\\<bind>) $\n         ((\\<bind>) $ (RETURN $ 0) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $ (RETURN $ (op_list_length $ x)) $\n                (\\<lambda>v1. (#RETURN $ (upt $ v0 $ v1)#))#))) $\n         (\\<lambda>xa.\n             (#monadic_nfoldli $ xa $ (\\<lambda>x. (#RETURN $ True#)) $\n               (\\<lambda>x.\n                   (#\\<lambda>xa.\n                        (#(\\<bind>) $\n                          ((\\<bind>) $ (RETURN $ 1) $\n                           (\\<lambda>v0.\n                               (#(\\<bind>) $\n                                 (RETURN $ (op_list_get $ xa $ x)) $\n                                 (\\<lambda>v1.\n                                     (#RETURN $ ((+) $ v0 $ v1)#))#))) $\n                          (\\<lambda>v2.\n                              (#RETURN $\n                                (op_list_set $ xa $ x $ v2)#))#)#)) $\n               x#)))\n 2. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       CNV (?c44 x xi) (?fi4 xi)\n 3. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (\\<lambda>_ _. true) x xi\n 4. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (?R5 x xi) a c \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (array_assn nat_assn) a c\n 5. CONSTRAINT_SLOT (True)", "apply sepref_dbg_trans_keep"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> v0 x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa\n         ((\\<bind>) $ (RETURN $ 0) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $ (RETURN $ (op_list_length $ x)) $\n                (\\<lambda>v1. (#RETURN $ (upt $ v0 $ v1)#))#)));\n        x'a \\<in> set xa; bind_ref_tag v0 (RETURN $ 1)\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (array_assn nat_assn) \\<sigma>'\n                            \\<sigma> *\n                           hn_val nat_rel x'a xb *\n                           emp *\n                           hn_val nat_rel v0 x'b)\n                          (?m'125 x xi x' xb \\<sigma> x'b)\n                          (?\\<Gamma>1.124 x xi xa x' x'a xb \\<sigma>'\n                            \\<sigma> v0 x'b)\n                          (?Rh124 x xi xa x' x'a xb \\<sigma>' \\<sigma> v0\n                            x'b)\n                          (RETURN $ (op_list_get $ \\<sigma>' $ x'a))\n 2. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> v0 x'b v1 x'c.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa\n         ((\\<bind>) $ (RETURN $ 0) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $ (RETURN $ (op_list_length $ x)) $\n                (\\<lambda>v1. (#RETURN $ (upt $ v0 $ v1)#))#)));\n        x'a \\<in> set xa; bind_ref_tag v0 (RETURN $ 1);\n        bind_ref_tag v1 (RETURN $ (op_list_get $ \\<sigma>' $ x'a))\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?\\<Gamma>1.124 x xi xa x' x'a xb \\<sigma>'\n                            \\<sigma> v0 x'b *\n                           hn_ctxt\n                            (?Rh124 x xi xa x' x'a xb \\<sigma>' \\<sigma> v0\n                              x'b)\n                            v1 x'c)\n                          (?f'126 x xi x' xb \\<sigma> x'b x'c)\n                          (?\\<Gamma>2.124 x xi xa x' x'a xb \\<sigma>'\n                            \\<sigma> v0 x'b v1 x'c)\n                          (?Rh112 x xi xa x' x'a xb \\<sigma>' \\<sigma>)\n                          (RETURN $ ((+) $ v0 $ v1))\n 3. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> v0 x'b v1 x'c.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa\n         ((\\<bind>) $ (RETURN $ 0) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $ (RETURN $ (op_list_length $ x)) $\n                (\\<lambda>v1. (#RETURN $ (upt $ v0 $ v1)#))#)));\n        x'a \\<in> set xa; bind_ref_tag v0 (RETURN $ 1)\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.124 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          v0 x'b v1 x'c \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.115 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          v0 x'b *\n                         hn_ctxt\n                          (?Rx124 x xi xa x' x'a xb \\<sigma>' \\<sigma> v0\n                            x'b)\n                          v1 x'c\n 4. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> v0 x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa\n         ((\\<bind>) $ (RETURN $ 0) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $ (RETURN $ (op_list_length $ x)) $\n                (\\<lambda>v1. (#RETURN $ (upt $ v0 $ v1)#))#)));\n        x'a \\<in> set xa\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.115 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          v0 x'b \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>1.112 x xi xa x' x'a xb \\<sigma>'\n                          \\<sigma> *\n                         hn_ctxt\n                          (?Rx115 x xi xa x' x'a xb \\<sigma>' \\<sigma>) v0\n                          x'b\n 5. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> v2 x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa\n         ((\\<bind>) $ (RETURN $ 0) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $ (RETURN $ (op_list_length $ x)) $\n                (\\<lambda>v1. (#RETURN $ (upt $ v0 $ v1)#))#)));\n        x'a \\<in> set xa;\n        bind_ref_tag v2\n         ((\\<bind>) $ (RETURN $ 1) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $ (RETURN $ (op_list_get $ \\<sigma>' $ x'a)) $\n                (\\<lambda>v1. (#RETURN $ ((+) $ v0 $ v1)#))#)))\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?\\<Gamma>1.112 x xi xa x' x'a xb \\<sigma>'\n                            \\<sigma> *\n                           hn_ctxt\n                            (?Rh112 x xi xa x' x'a xb \\<sigma>' \\<sigma>) v2\n                            x'b)\n                          (?f'114 x xi x' xb \\<sigma> x'b)\n                          (?\\<Gamma>2.112 x xi xa x' x'a xb \\<sigma>'\n                            \\<sigma> v2 x'b)\n                          (array_assn nat_assn)\n                          (RETURN $ (op_list_set $ \\<sigma>' $ x'a $ v2))\n 6. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> v2 x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa\n         ((\\<bind>) $ (RETURN $ 0) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $ (RETURN $ (op_list_length $ x)) $\n                (\\<lambda>v1. (#RETURN $ (upt $ v0 $ v1)#))#)));\n        x'a \\<in> set xa\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.112 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          v2 x'b \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>f86 x xi xa x' x'a xb \\<sigma>' \\<sigma> *\n                         hn_ctxt\n                          (?Rx112 x xi xa x' x'a xb \\<sigma>' \\<sigma>) v2\n                          x'b\n 7. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma>.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa\n         ((\\<bind>) $ (RETURN $ 0) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $ (RETURN $ (op_list_length $ x)) $\n                (\\<lambda>v1. (#RETURN $ (upt $ v0 $ v1)#))#)));\n        TERM monadic_nfoldli\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>f86 x xi xa x' x'a xb \\<sigma>'\n                          \\<sigma> \\<Longrightarrow>\\<^sub>t\n                         emp * hn_ctxt (?Rk'86 x xi xa x') x'a xb *\n                         hn_ctxt (?Pf\\<sigma>86 x xi xa x') \\<sigma>'\n                          \\<sigma>\n 8. \\<And>x xi xa x' xb x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa\n         ((\\<bind>) $ (RETURN $ 0) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $ (RETURN $ (op_list_length $ x)) $\n                (\\<lambda>v1. (#RETURN $ (upt $ v0 $ v1)#))#)))\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt (?Rk'86 x xi xa x') x'a xb \\<or>\\<^sub>A\n                         hn_val nat_rel x'a xb \\<Longrightarrow>\\<^sub>t\n                         hn_ctxt (?Rk''86 x xi xa x') x'a xb\n 9. \\<And>x xi xa x'.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       emp * hn_ctxt (list_assn (?Rk''86 x xi xa x')) xa x' *\n       hn_invalid (array_assn nat_assn) x xi \\<Longrightarrow>\\<^sub>t\n       ?\\<Gamma>'5 x xi * hn_ctxt (?Rx45 x xi) xa x'\n 10. \\<And>x xi.\n        x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n        CNV (return 0 \\<bind>\n             (\\<lambda>x'.\n                 Array.len $ xi \\<bind>\n                 (\\<lambda>x'a. return [x'..<x'a])) \\<bind>\n             (\\<lambda>x'.\n                 imp_nfoldli x' (\\<lambda>\\<sigma>. return True)\n                  (\\<lambda>xb \\<sigma>.\n                      return 1 \\<bind>\n                      (\\<lambda>x'b.\n                          ?m'125 x xi x' xb \\<sigma> x'b \\<bind>\n                          ?f'126 x xi x' xb \\<sigma> x'b) \\<bind>\n                      ?f'114 x xi x' xb \\<sigma>)\n                  xi))\n         (?fi4 xi)\nA total of 13 subgoals...", "apply sepref_dbg_trans_step_keep"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> v0 x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa\n         ((\\<bind>) $ (RETURN $ 0) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $ (RETURN $ (op_list_length $ x)) $\n                (\\<lambda>v1. (#RETURN $ (upt $ v0 $ v1)#))#)));\n        x'a \\<in> set xa; bind_ref_tag v0 (RETURN $ 1);\n        vassn_tag\n         (hn_val nat_rel x'a xb *\n          hn_ctxt (array_assn nat_assn) \\<sigma>' \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> pre_list_get (\\<sigma>', x'a)\n 2. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> v0 x'b v1 x'c.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa\n         ((\\<bind>) $ (RETURN $ 0) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $ (RETURN $ (op_list_length $ x)) $\n                (\\<lambda>v1. (#RETURN $ (upt $ v0 $ v1)#))#)));\n        x'a \\<in> set xa; bind_ref_tag v0 (RETURN $ 1);\n        bind_ref_tag v1 (RETURN $ (op_list_get $ \\<sigma>' $ x'a))\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_val nat_rel v0 x'b *\n                           (hn_val nat_rel x'a xb *\n                            hn_ctxt (array_assn nat_assn) \\<sigma>'\n                             \\<sigma>) *\n                           hn_val nat_rel v1 x'c)\n                          (?f'4 x xi x' xb \\<sigma> x'b x'c)\n                          (?\\<Gamma>2.4 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                            v0 x'b v1 x'c)\n                          (?Rh4 x xi xa x' x'a xb \\<sigma>' \\<sigma>)\n                          (RETURN $ ((+) $ v0 $ v1))\n 3. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> v0 x'b v1 x'c.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa\n         ((\\<bind>) $ (RETURN $ 0) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $ (RETURN $ (op_list_length $ x)) $\n                (\\<lambda>v1. (#RETURN $ (upt $ v0 $ v1)#))#)));\n        x'a \\<in> set xa; bind_ref_tag v0 (RETURN $ 1)\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.4 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          v0 x'b v1 x'c \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2a4 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          v0 x'b *\n                         hn_ctxt\n                          (?Rx4 x xi xa x' x'a xb \\<sigma>' \\<sigma> v0 x'b)\n                          v1 x'c\n 4. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> v0 x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa\n         ((\\<bind>) $ (RETURN $ 0) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $ (RETURN $ (op_list_length $ x)) $\n                (\\<lambda>v1. (#RETURN $ (upt $ v0 $ v1)#))#)));\n        x'a \\<in> set xa\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2a4 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          v0 x'b \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>1.4 x xi xa x' x'a xb \\<sigma>' \\<sigma> *\n                         hn_ctxt\n                          (?Rxa4 x xi xa x' x'a xb \\<sigma>' \\<sigma>) v0\n                          x'b\n 5. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> v2 x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa\n         ((\\<bind>) $ (RETURN $ 0) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $ (RETURN $ (op_list_length $ x)) $\n                (\\<lambda>v1. (#RETURN $ (upt $ v0 $ v1)#))#)));\n        x'a \\<in> set xa;\n        bind_ref_tag v2\n         ((\\<bind>) $ (RETURN $ 1) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $ (RETURN $ (op_list_get $ \\<sigma>' $ x'a)) $\n                (\\<lambda>v1. (#RETURN $ ((+) $ v0 $ v1)#))#)))\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?\\<Gamma>1.4 x xi xa x' x'a xb \\<sigma>'\n                            \\<sigma> *\n                           hn_ctxt\n                            (?Rh4 x xi xa x' x'a xb \\<sigma>' \\<sigma>) v2\n                            x'b)\n                          (?f'a4 x xi x' xb \\<sigma> x'b)\n                          (?\\<Gamma>2b4 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                            v2 x'b)\n                          (array_assn nat_assn)\n                          (RETURN $ (op_list_set $ \\<sigma>' $ x'a $ v2))\n 6. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> v2 x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa\n         ((\\<bind>) $ (RETURN $ 0) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $ (RETURN $ (op_list_length $ x)) $\n                (\\<lambda>v1. (#RETURN $ (upt $ v0 $ v1)#))#)));\n        x'a \\<in> set xa\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2b4 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          v2 x'b \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>f4 x xi xa x' x'a xb \\<sigma>' \\<sigma> *\n                         hn_ctxt\n                          (?Rxb4 x xi xa x' x'a xb \\<sigma>' \\<sigma>) v2\n                          x'b\n 7. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma>.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa\n         ((\\<bind>) $ (RETURN $ 0) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $ (RETURN $ (op_list_length $ x)) $\n                (\\<lambda>v1. (#RETURN $ (upt $ v0 $ v1)#))#)));\n        TERM monadic_nfoldli\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>f4 x xi xa x' x'a xb \\<sigma>'\n                          \\<sigma> \\<Longrightarrow>\\<^sub>t\n                         emp * hn_ctxt (?Rk'4 x xi xa x') x'a xb *\n                         hn_ctxt (?Pf\\<sigma>4 x xi xa x') \\<sigma>'\n                          \\<sigma>\n 8. \\<And>x xi xa x' xb x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa\n         ((\\<bind>) $ (RETURN $ 0) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $ (RETURN $ (op_list_length $ x)) $\n                (\\<lambda>v1. (#RETURN $ (upt $ v0 $ v1)#))#)))\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt (?Rk'4 x xi xa x') x'a xb \\<or>\\<^sub>A\n                         hn_val nat_rel x'a xb \\<Longrightarrow>\\<^sub>t\n                         hn_ctxt (?Rk''4 x xi xa x') x'a xb\n 9. \\<And>x xi xa x'.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       emp * hn_ctxt (list_assn (?Rk''4 x xi xa x')) xa x' *\n       hn_invalid (array_assn nat_assn) x xi \\<Longrightarrow>\\<^sub>t\n       ?\\<Gamma>'4 x xi * hn_ctxt (?Rxc4 x xi) xa x'\n 10. \\<And>x xi.\n        x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n        CNV (return 0 \\<bind>\n             (\\<lambda>x'.\n                 Array.len $ xi \\<bind>\n                 (\\<lambda>x'a. return [x'..<x'a])) \\<bind>\n             (\\<lambda>x'.\n                 imp_nfoldli x' (\\<lambda>\\<sigma>. return True)\n                  (\\<lambda>xb \\<sigma>.\n                      return 1 \\<bind>\n                      (\\<lambda>x'b.\n                          Array.nth $ \\<sigma> $ xb \\<bind>\n                          ?f'4 x xi x' xb \\<sigma> x'b) \\<bind>\n                      ?f'a4 x xi x' xb \\<sigma>)\n                  xi))\n         (?fi4 xi)\nA total of 13 subgoals...", "apply sepref_dbg_side_keep\n  \\<comment> \\<open>We get stuck at the precondition of @{const op_list_get}.\n    Indeed, we cannot prove the generated precondition, as the translation process\n    dropped any information from which we could conclude that the index is in range.\\<close>"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>x x'a \\<sigma>'.\n       \\<lbrakk>x'a < length x;\n        rdomp (array_assn nat_assn) \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> x'a < length \\<sigma>'\n 2. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> v0 x'b v1 x'c.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa\n         ((\\<bind>) $ (RETURN $ 0) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $ (RETURN $ (op_list_length $ x)) $\n                (\\<lambda>v1. (#RETURN $ (upt $ v0 $ v1)#))#)));\n        x'a \\<in> set xa; bind_ref_tag v0 (RETURN $ 1);\n        bind_ref_tag v1 (RETURN $ (op_list_get $ \\<sigma>' $ x'a))\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_val nat_rel v0 x'b *\n                           (hn_val nat_rel x'a xb *\n                            hn_ctxt (array_assn nat_assn) \\<sigma>'\n                             \\<sigma>) *\n                           hn_val nat_rel v1 x'c)\n                          (?f'4 x xi x' xb \\<sigma> x'b x'c)\n                          (?\\<Gamma>2.4 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                            v0 x'b v1 x'c)\n                          (?Rh4 x xi xa x' x'a xb \\<sigma>' \\<sigma>)\n                          (RETURN $ ((+) $ v0 $ v1))\n 3. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> v0 x'b v1 x'c.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa\n         ((\\<bind>) $ (RETURN $ 0) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $ (RETURN $ (op_list_length $ x)) $\n                (\\<lambda>v1. (#RETURN $ (upt $ v0 $ v1)#))#)));\n        x'a \\<in> set xa; bind_ref_tag v0 (RETURN $ 1)\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.4 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          v0 x'b v1 x'c \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2a4 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          v0 x'b *\n                         hn_ctxt\n                          (?Rx4 x xi xa x' x'a xb \\<sigma>' \\<sigma> v0 x'b)\n                          v1 x'c\n 4. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> v0 x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa\n         ((\\<bind>) $ (RETURN $ 0) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $ (RETURN $ (op_list_length $ x)) $\n                (\\<lambda>v1. (#RETURN $ (upt $ v0 $ v1)#))#)));\n        x'a \\<in> set xa\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2a4 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          v0 x'b \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>1.4 x xi xa x' x'a xb \\<sigma>' \\<sigma> *\n                         hn_ctxt\n                          (?Rxa4 x xi xa x' x'a xb \\<sigma>' \\<sigma>) v0\n                          x'b\n 5. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> v2 x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa\n         ((\\<bind>) $ (RETURN $ 0) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $ (RETURN $ (op_list_length $ x)) $\n                (\\<lambda>v1. (#RETURN $ (upt $ v0 $ v1)#))#)));\n        x'a \\<in> set xa;\n        bind_ref_tag v2\n         ((\\<bind>) $ (RETURN $ 1) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $ (RETURN $ (op_list_get $ \\<sigma>' $ x'a)) $\n                (\\<lambda>v1. (#RETURN $ ((+) $ v0 $ v1)#))#)))\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?\\<Gamma>1.4 x xi xa x' x'a xb \\<sigma>'\n                            \\<sigma> *\n                           hn_ctxt\n                            (?Rh4 x xi xa x' x'a xb \\<sigma>' \\<sigma>) v2\n                            x'b)\n                          (?f'a4 x xi x' xb \\<sigma> x'b)\n                          (?\\<Gamma>2b4 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                            v2 x'b)\n                          (array_assn nat_assn)\n                          (RETURN $ (op_list_set $ \\<sigma>' $ x'a $ v2))\n 6. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> v2 x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa\n         ((\\<bind>) $ (RETURN $ 0) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $ (RETURN $ (op_list_length $ x)) $\n                (\\<lambda>v1. (#RETURN $ (upt $ v0 $ v1)#))#)));\n        x'a \\<in> set xa\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2b4 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                          v2 x'b \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>f4 x xi xa x' x'a xb \\<sigma>' \\<sigma> *\n                         hn_ctxt\n                          (?Rxb4 x xi xa x' x'a xb \\<sigma>' \\<sigma>) v2\n                          x'b\n 7. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma>.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa\n         ((\\<bind>) $ (RETURN $ 0) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $ (RETURN $ (op_list_length $ x)) $\n                (\\<lambda>v1. (#RETURN $ (upt $ v0 $ v1)#))#)));\n        TERM monadic_nfoldli\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>f4 x xi xa x' x'a xb \\<sigma>'\n                          \\<sigma> \\<Longrightarrow>\\<^sub>t\n                         emp * hn_ctxt (?Rk'4 x xi xa x') x'a xb *\n                         hn_ctxt (?Pf\\<sigma>4 x xi xa x') \\<sigma>'\n                          \\<sigma>\n 8. \\<And>x xi xa x' xb x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa\n         ((\\<bind>) $ (RETURN $ 0) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $ (RETURN $ (op_list_length $ x)) $\n                (\\<lambda>v1. (#RETURN $ (upt $ v0 $ v1)#))#)))\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt (?Rk'4 x xi xa x') x'a xb \\<or>\\<^sub>A\n                         hn_val nat_rel x'a xb \\<Longrightarrow>\\<^sub>t\n                         hn_ctxt (?Rk''4 x xi xa x') x'a xb\n 9. \\<And>x xi xa x'.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       emp * hn_ctxt (list_assn (?Rk''4 x xi xa x')) xa x' *\n       hn_invalid (array_assn nat_assn) x xi \\<Longrightarrow>\\<^sub>t\n       ?\\<Gamma>'4 x xi * hn_ctxt (?Rxc4 x xi) xa x'\n 10. \\<And>x xi.\n        x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n        CNV (return 0 \\<bind>\n             (\\<lambda>x'.\n                 Array.len $ xi \\<bind>\n                 (\\<lambda>x'a. return [x'..<x'a])) \\<bind>\n             (\\<lambda>x'.\n                 imp_nfoldli x' (\\<lambda>\\<sigma>. return True)\n                  (\\<lambda>xb \\<sigma>.\n                      return 1 \\<bind>\n                      (\\<lambda>x'b.\n                          Array.nth $ \\<sigma> $ xb \\<bind>\n                          ?f'4 x xi x' xb \\<sigma> x'b) \\<bind>\n                      ?f'a4 x xi x' xb \\<sigma>)\n                  xi))\n         (?fi4 xi)\nA total of 13 subgoals...", "oops"], ["", "text \\<open>\n    Of course, the fold loop has the invariant that the length of the list does not change,\n    and thus, indexing is in range. We only cannot prove it during the automatic synthesis.\n\n    Here, the only solution is to do a manual refinement into the nres-monad, \n    and adding an assertion that indexing is always in range.\n\n    We use the @{const nfoldli} combinator, which generalizes @{const fold} in two directions:\n    \\<^enum> The function is inside the nres monad\n    \\<^enum> There is a continuation condition. If this is not satisfied, the fold returns immediately, \n      dropping the rest of the list.\n    \\<close>"], ["", "definition \"incr_list2 l \\<equiv> nfoldli \n  [0..<length l] \n  (\\<lambda>_. True)  \n  (\\<lambda>i l. ASSERT (i<length l) \\<then> RETURN (l[i:=1+l!i]))\n  l\""], ["", "text \\<open>\n  Note: Often, it is simpler to prove refinement of the abstract specification, rather\n  than proving refinement to some intermediate specification that may have already done\n  refinements \"in the wrong direction\". In our case, proving refinement of @{const incr_list1}\n  would require to generalize the statement to keep track of the list-length invariant,\n  while proving refinement of @{const incr_list} directly is as easy as proving the original \n  refinement for @{const incr_list1}.\n\\<close>"], ["", "lemma incr_list2_refine: \"(incr_list2,RETURN o incr_list) \\<in> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (incr_list2, RETURN \\<circ> incr_list)\n    \\<in> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel", "proof (intro nres_relI fun_relI; simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. incr_list2 a \\<le> RETURN (incr_list a)", "fix l :: \"'a list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. incr_list2 a \\<le> RETURN (incr_list a)", "show \"incr_list2 l \\<le> RETURN (incr_list l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incr_list2 l \\<le> RETURN (incr_list l)", "unfolding incr_list2_def incr_list_def\n    \\<comment> \\<open>@{const nfoldli} comes with an invariant proof rule. In order to use it, we have to specify\n      the invariant manually:\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli [0..<length l] (\\<lambda>_. True)\n     (\\<lambda>i l.\n         ASSERT (i < length l) \\<bind>\n         (\\<lambda>_. RETURN (l[i := (1::'a) + l ! i])))\n     l\n    \\<le> RETURN (map ((+) (1::'a)) l)", "apply (refine_vcg nfoldli_rule[where I=\"\\<lambda>l1 l2 s. s = map (((+))1) (take (length l1) l) @ drop (length l1) l\"])"], ["proof (prove)\ngoal (5 subgoals):\n 1. l = map ((+) (1::'a)) (take (length []) l) @ drop (length []) l\n 2. \\<And>x l1 l2 \\<sigma>.\n       \\<lbrakk>[0..<length l] = l1 @ x # l2;\n        \\<sigma> =\n        map ((+) (1::'a)) (take (length l1) l) @ drop (length l1) l;\n        True\\<rbrakk>\n       \\<Longrightarrow> x < length \\<sigma>\n 3. \\<And>x l1 l2 \\<sigma>.\n       \\<lbrakk>[0..<length l] = l1 @ x # l2;\n        \\<sigma> =\n        map ((+) (1::'a)) (take (length l1) l) @ drop (length l1) l;\n        True; x < length \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<sigma>[x := (1::'a) + \\<sigma> ! x] =\n                         map ((+) (1::'a)) (take (length (l1 @ [x])) l) @\n                         drop (length (l1 @ [x])) l\n 4. \\<And>l1 l2 \\<sigma>.\n       \\<lbrakk>[0..<length l] = l1 @ l2;\n        \\<sigma> =\n        map ((+) (1::'a)) (take (length l1) l) @ drop (length l1) l;\n        \\<not> True\\<rbrakk>\n       \\<Longrightarrow> map ((+) (1::'a)) l = \\<sigma>\n 5. \\<And>\\<sigma>.\n       \\<lbrakk>\\<sigma> =\n                map ((+) (1::'a)) (take (length [0..<length l]) l) @\n                drop (length [0..<length l]) l;\n        True\\<rbrakk>\n       \\<Longrightarrow> map ((+) (1::'a)) l = \\<sigma>", "apply (vc_solve \n      simp: upt_eq_append_conv upt_eq_Cons_conv\n      simp: nth_append list_update_append upd_conv_take_nth_drop take_Suc_conv_app_nth\n      solve: asm_rl\n    )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  incr_list2 l \\<le> RETURN (incr_list l)\n\ngoal:\nNo subgoals!", "qed"], ["", "sepref_definition incr_list3 is \"incr_list2\" :: \"(array_assn nat_assn)\\<^sup>d \\<rightarrow>\\<^sub>a array_assn nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, incr_list2)\n    \\<in> (array_assn\n            nat_assn)\\<^sup>d \\<rightarrow>\\<^sub>a array_assn nat_assn", "unfolding incr_list2_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>l.\n        nfoldli [0..<length l] (\\<lambda>_. True)\n         (\\<lambda>i l.\n             ASSERT (i < length l) \\<bind>\n             (\\<lambda>_. RETURN (l[i := 1 + l ! i])))\n         l)\n    \\<in> (array_assn\n            nat_assn)\\<^sup>d \\<rightarrow>\\<^sub>a array_assn nat_assn", "by sepref"], ["", "lemmas incr_list3_correct = incr_list3.refine[FCOMP incr_list2_refine]"], ["", "subsection \\<open>Linearity and Copying\\<close>"], ["", "text \\<open>Consider the following implementation of an operation to swap to list \n  indexes. While it is perfectly valid in a functional setting, an imperative \n  implementation has a problem here: Once the update a index \\<open>i\\<close> is done,\n  the old value cannot be read from index \\<open>i\\<close> any more. We try to implement the\n  list with an array:\\<close>"], ["", "sepref_thm swap_nonlinear is \"uncurry2 (\\<lambda>l i j. do {\n  ASSERT (i<length l \\<and> j<length l);\n  RETURN (l[i:=l!j, j:=l!i])\n})\" :: \"(array_assn id_assn)\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a array_assn id_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>l i j.\n          ASSERT (i < length l \\<and> j < length l) \\<bind>\n          (\\<lambda>_. RETURN (l[i := l ! j, j := l ! i]))))\n    \\<in> (array_assn id_assn)\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a array_assn id_assn", "supply [[goals_limit = 1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>l i j.\n          ASSERT (i < length l \\<and> j < length l) \\<bind>\n          (\\<lambda>_. RETURN (l[i := l ! j, j := l ! i]))))\n    \\<in> (array_assn id_assn)\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a array_assn id_assn", "apply sepref_dbg_keep"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>b bi ba bia a ai.\n       \\<lbrakk>a ::\\<^sub>i TYPE('a list); ba ::\\<^sub>i TYPE(nat);\n        b ::\\<^sub>i TYPE(nat)\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_val nat_rel b bi * hn_val nat_rel ba bia *\n                           hn_ctxt (array_assn id_assn) a ai)\n                          (?c52 b bi ba bia a ai)\n                          (?\\<Gamma>'9 b bi ba bia a ai)\n                          (?R9 b bi ba bia a ai)\n                          (PR_CONST\n                            (op_ASSERT_bind\n                              (ba < length a \\<and> b < length a)) $\n                           ((\\<bind>) $\n                            ((\\<bind>) $ (RETURN $ (op_list_get $ a $ b)) $\n                             (\\<lambda>v2.\n                                 (#RETURN $\n                                   (op_list_set $ a $ ba $ v2)#))) $\n                            (\\<lambda>v0.\n                                (#(\\<bind>) $\n                                  (RETURN $ (op_list_get $ a $ ba)) $\n                                  (\\<lambda>v2.\n(#RETURN $ (op_list_set $ v0 $ b $ v2)#))#))))\nA total of 5 subgoals...", "apply sepref_dbg_trans_keep \\<comment> \\<open>(1) We get stuck at an @{const op_list_get} operation\\<close>"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>b bi ba bia a ai v0 x'.\n       \\<lbrakk>a ::\\<^sub>i TYPE('a list); ba ::\\<^sub>i TYPE(nat);\n        b ::\\<^sub>i TYPE(nat); ba < length a \\<and> b < length a;\n        bind_ref_tag v0\n         ((\\<bind>) $ (RETURN $ (op_list_get $ a $ b)) $\n          (\\<lambda>v2. (#RETURN $ (op_list_set $ a $ ba $ v2)#)))\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_val nat_rel b bi * hn_val nat_rel ba bia *\n                           hn_invalid (array_assn id_assn) a ai *\n                           hn_ctxt (array_assn id_assn) v0 x')\n                          (?m'15 b bi ba bia a ai x')\n                          (?\\<Gamma>1.14 b bi ba bia a ai v0 x')\n                          (?Rh14 b bi ba bia a ai v0 x')\n                          (RETURN $ (op_list_get $ a $ ba))\nA total of 8 subgoals...", "apply sepref_dbg_trans_step_keep \\<comment> \\<open>(2) Further inspection reveals that the \"recover pure\" \n    phase fails, and we are left with a subgoal of the form \n    @{term \"CONSTRAINT is_pure (array_assn id_assn)\"}. Constraint side conditions are \n    deferrable side conditions: They are produced as side-conditions, and if they cannot \n    be solved immediately, they are deferred and processed later, latest at the end of the synthesis.\n    However, definitely unsolvable constraints are not deferred, but halt the translation phase immediately,\n    and this is what happened here: At (1) we can see that the refinement for the array we want to access is \n    @{term \"hn_invalid (array_assn id_assn)\"}. This means, the data structure was destroyed by some preceding \n    operation. The @{const hn_invalid} only keeps a record of this fact. When translating an operation that uses\n    an invalidated parameter, the tool tries to restore the invalidated parameter: This only works if the data \n    structure was purely functional, i.e., not stored on the heap. This is where the @{term is_pure} constraint\n    comes from. However, arrays are always stored on the heap, so this constraint is definitely unsolvable,\n    and thus immediately rejected instead of being deferred. \n\n    Note: There are scenarios where a constraint gets deferred @{emph \\<open>before\\<close>} it becomes definitely unsolvable.\n      In these cases, you only see the problem after the translation phase, and it may be somewhat tricky to figure\n      out the reason.\\<close>"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>b bi ba bia a ai v0 x'.\n       \\<lbrakk>a ::\\<^sub>i TYPE('a list); ba ::\\<^sub>i TYPE(nat);\n        b ::\\<^sub>i TYPE(nat); ba < length a \\<and> b < length a;\n        bind_ref_tag v0\n         ((\\<bind>) $ (RETURN $ (op_list_get $ a $ b)) $\n          (\\<lambda>v2. (#RETURN $ (op_list_set $ a $ ba $ v2)#)))\\<rbrakk>\n       \\<Longrightarrow> CONSTRAINT is_pure (array_assn id_assn)\nA total of 9 subgoals...", "(* TODO: Check for unsolvable constraints after each translation step, and refuse refinements that render\n      any constraints unsolvable. Make this debuggable, e.g. by injecting those constraints as additional side \n      conditions! *)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>b bi ba bia a ai v0 x'.\n       \\<lbrakk>a ::\\<^sub>i TYPE('a list); ba ::\\<^sub>i TYPE(nat);\n        b ::\\<^sub>i TYPE(nat); ba < length a \\<and> b < length a;\n        bind_ref_tag v0\n         ((\\<bind>) $ (RETURN $ (op_list_get $ a $ b)) $\n          (\\<lambda>v2. (#RETURN $ (op_list_set $ a $ ba $ v2)#)))\\<rbrakk>\n       \\<Longrightarrow> CONSTRAINT is_pure (array_assn id_assn)\nA total of 9 subgoals...", "oops"], ["", "text \\<open>The fix for our swap function is quite obvious. Using a temporary storage \n  for the intermediate value, we write:\\<close>"], ["", "sepref_thm swap_with_tmp is \"uncurry2 (\\<lambda>l i j. do {\n  ASSERT (i<length l \\<and> j<length l);\n  let tmp = l!i;\n  RETURN (l[i:=l!j, j:=tmp])\n})\" :: \"(array_assn id_assn)\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a array_assn id_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>l i j.\n          ASSERT (i < length l \\<and> j < length l) \\<bind>\n          (\\<lambda>_.\n              let tmp = l ! i in RETURN (l[i := l ! j, j := tmp]))))\n    \\<in> (array_assn id_assn)\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a array_assn id_assn", "by sepref"], ["", "text \\<open>Note that also the argument must be marked as destroyed \\<open>()\\<^sup>d\\<close>. Otherwise, we get a similar error as above,\n  but in a different phase: \\<close>"], ["", "sepref_thm swap_with_tmp is \"uncurry2 (\\<lambda>l i j. do {\n  ASSERT (i<length l \\<and> j<length l);\n  let tmp = l!i;\n  RETURN (l[i:=l!j, j:=tmp])\n})\" :: \"(array_assn id_assn)\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a array_assn id_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>l i j.\n          ASSERT (i < length l \\<and> j < length l) \\<bind>\n          (\\<lambda>_.\n              let tmp = l ! i in RETURN (l[i := l ! j, j := tmp]))))\n    \\<in> (array_assn id_assn)\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a array_assn id_assn", "apply sepref_dbg_keep \\<comment> \\<open>We get stuck at a frame, which would require restoring an invalidated array\\<close>"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b bi ba bia a ai.\n       \\<lbrakk>a ::\\<^sub>i TYPE('a list); ba ::\\<^sub>i TYPE(nat);\n        b ::\\<^sub>i TYPE(nat)\\<rbrakk>\n       \\<Longrightarrow> hn_invalid (array_assn id_assn) a ai *\n                         hn_val nat_rel ba bia *\n                         hn_val nat_rel b bi \\<Longrightarrow>\\<^sub>t\n                         hn_val nat_rel b bi * hn_val nat_rel ba bia *\n                         hn_ctxt (array_assn id_assn) a ai\n 2. \\<And>b bi ba bia a ai aa c.\n       \\<lbrakk>a ::\\<^sub>i TYPE('a list); ba ::\\<^sub>i TYPE(nat);\n        b ::\\<^sub>i TYPE(nat)\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt (array_assn id_assn) aa\n                          c \\<Longrightarrow>\\<^sub>t\n                         hn_ctxt (array_assn id_assn) aa c\n 3. CONSTRAINT_SLOT (True)", "apply sepref_dbg_cons_solve_keep \\<comment> \\<open>Which would only work if arrays were pure\\<close>"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b bi ba bia a ai.\n       \\<lbrakk>a ::\\<^sub>i TYPE('a list); ba ::\\<^sub>i TYPE(nat);\n        b ::\\<^sub>i TYPE(nat)\\<rbrakk>\n       \\<Longrightarrow> hn_invalid (array_assn id_assn) a\n                          ai \\<Longrightarrow>\\<^sub>t\n                         hn_ctxt (array_assn id_assn) a ai\n 2. \\<And>b bi ba bia a ai aa c.\n       \\<lbrakk>a ::\\<^sub>i TYPE('a list); ba ::\\<^sub>i TYPE(nat);\n        b ::\\<^sub>i TYPE(nat)\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt (array_assn id_assn) aa\n                          c \\<Longrightarrow>\\<^sub>t\n                         hn_ctxt (array_assn id_assn) aa c\n 3. CONSTRAINT_SLOT (True)", "oops"], ["", "text \\<open>If copying is really required, you have to insert it manually. \n  Reconsider the example @{const incr_list} from above. This time,\n  we want to preserve the original data (note the \\<open>()\\<^sup>k\\<close> annotation):\n\\<close>"], ["", "sepref_thm incr_list3_preserve is \"incr_list2\" :: \"(array_assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a array_assn nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, incr_list2)\n    \\<in> (array_assn\n            nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a array_assn nat_assn", "unfolding incr_list2_def[abs_def]\n  \\<comment> \\<open>We explicitly insert a copy-operation on the list, before it is passed to the fold operation\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>l.\n        nfoldli [0..<length l] (\\<lambda>_. True)\n         (\\<lambda>i l.\n             ASSERT (i < length l) \\<bind>\n             (\\<lambda>_. RETURN (l[i := 1 + l ! i])))\n         l)\n    \\<in> (array_assn\n            nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a array_assn nat_assn", "apply (rewrite in \"nfoldli _ _ _ \\<hole>\" op_list_copy_def[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>l.\n        nfoldli [0..<length l] (\\<lambda>_. True)\n         (\\<lambda>i l.\n             ASSERT (i < length l) \\<bind>\n             (\\<lambda>_. RETURN (l[i := 1 + l ! i])))\n         (op_list_copy l))\n    \\<in> (array_assn\n            nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a array_assn nat_assn", "by sepref"], ["", "subsection \\<open>Nesting of Data Structures\\<close>"], ["", "text \\<open>\n  Sepref and the IICF support nesting of data structures with some limitations:\n    \\<^item> Only the container or its elements can be visible at the same time. \n      For example, if you have a product of two arrays, you can either see the\n      two arrays, or the product. An operation like \\<open>snd\\<close> would have to destroy \n      the product, loosing the first component. Inside a case distinction, you\n      cannot access the compound object.\n    \n      These limitations are somewhat relaxed for pure data types, which can always \n      be restored.\n    \\<^item> Most IICF data structures only support pure component types. \n      Exceptions are HOL-lists, and the list-based set and multiset implementations\n      \\<open>List_MsetO\\<close> and \\<open>List_SetO\\<close> (Here, the \\<open>O\\<close> stands for \\<open>own\\<close>, which means \n      that the data-structure owns its elements.).\n\n\\<close>"], ["", "text \\<open>Works fine:\\<close>"], ["", "sepref_thm product_ex1 is \"uncurry0 (do {\n    let p = (op_array_replicate 5 True, op_array_replicate 2 False);\n    case p of (a1,a2) \\<Rightarrow> RETURN (a1!2)\n  })\" :: \"unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2,\n     uncurry0\n      (let p = (op_array_replicate 5 True, op_array_replicate 2 False)\n       in case p of (a1, a2) \\<Rightarrow> RETURN (a1 ! 2)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "by sepref"], ["", "text \\<open>Fails: We cannot access compound type inside case distinction\\<close>"], ["", "sepref_thm product_ex2 is \"uncurry0 (do {\n    let p = (op_array_replicate 5 True, op_array_replicate 2 False);\n    case p of (a1,a2) \\<Rightarrow> RETURN (snd p!1)\n  })\" :: \"unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2,\n     uncurry0\n      (let p = (op_array_replicate 5 True, op_array_replicate 2 False)\n       in case p of (a1, a2) \\<Rightarrow> RETURN (snd p ! 1)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "apply sepref_dbg_keep"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow>\n       hn_refine emp (?c50 x xi) (?\\<Gamma>'6 x xi) (?R6 x xi)\n        ((\\<bind>) $\n         ((\\<bind>) $\n          ((\\<bind>) $ (RETURN $ PR_CONST 5) $\n           (\\<lambda>v0.\n               (#(\\<bind>) $ (RETURN $ True) $\n                 (\\<lambda>v1.\n                     (#RETURN $ (op_array_replicate $ v0 $ v1)#))#))) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $\n                ((\\<bind>) $ (RETURN $ PR_CONST 2) $\n                 (\\<lambda>v0.\n                     (#(\\<bind>) $ (RETURN $ False) $\n                       (\\<lambda>v1.\n                           (#RETURN $\n                             (op_array_replicate $ v0 $ v1)#))#))) $\n                (\\<lambda>v1. (#RETURN $ (Pair $ v0 $ v1)#))#))) $\n         (\\<lambda>x.\n             (#Let $ x $\n               (\\<lambda>x.\n                   (#case_prod $\n                     (\\<lambda>xa.\n                         (#\\<lambda>xa.\n                              (#(\\<bind>) $ (RETURN $ (snd $ x)) $\n                                (\\<lambda>v0.\n                                    (#(\\<bind>) $ (RETURN $ 1) $\n(\\<lambda>v1. (#RETURN $ (op_list_get $ v0 $ v1)#))#))#)#)) $\n                     x#))#)))\n 2. \\<And>x xi.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow> CNV (?c50 x xi) ?f5\n 3. \\<And>x xi.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow>\n       ?\\<Gamma>'6 x xi \\<Longrightarrow>\\<^sub>t emp\n 4. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow>\n       hn_ctxt (?R6 x xi) a c \\<Longrightarrow>\\<^sub>t hn_val bool_rel a c\n 5. CONSTRAINT_SLOT (True)", "apply sepref_dbg_trans_keep"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>x xi xa x' xb x'a a1 a2 a1' a2'.\n       \\<lbrakk>x ::\\<^sub>i TYPE(unit);\n        bind_ref_tag xa\n         ((\\<bind>) $\n          ((\\<bind>) $ (RETURN $ PR_CONST 5) $\n           (\\<lambda>v0.\n               (#(\\<bind>) $ (RETURN $ True) $\n                 (\\<lambda>v1.\n                     (#RETURN $ (op_array_replicate $ v0 $ v1)#))#))) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $\n                ((\\<bind>) $ (RETURN $ PR_CONST 2) $\n                 (\\<lambda>v0.\n                     (#(\\<bind>) $ (RETURN $ False) $\n                       (\\<lambda>v1.\n                           (#RETURN $\n                             (op_array_replicate $ v0 $ v1)#))#))) $\n                (\\<lambda>v1. (#RETURN $ (Pair $ v0 $ v1)#))#)));\n        xb = xa; xb = (a1', a2')\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (array_assn bool_assn) a1' a1 *\n                           hn_ctxt (array_assn bool_assn) a2' a2 *\n                           emp *\n                           hn_invalid\n                            (array_assn bool_assn \\<times>\\<^sub>a\n                             array_assn bool_assn)\n                            xb x'a)\n                          (?m'60 x xi x' x'a a1 a2)\n                          (?\\<Gamma>1.59 x xi xa x' xb x'a a1 a2 a1' a2')\n                          (?Rh59 x xi xa x' xb x'a a1 a2 a1' a2')\n                          (RETURN $ (snd $ xb))\n 2. \\<And>x xi xa x' xb x'a a1 a2 a1' a2' v0 x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(unit);\n        bind_ref_tag xa\n         ((\\<bind>) $\n          ((\\<bind>) $ (RETURN $ PR_CONST 5) $\n           (\\<lambda>v0.\n               (#(\\<bind>) $ (RETURN $ True) $\n                 (\\<lambda>v1.\n                     (#RETURN $ (op_array_replicate $ v0 $ v1)#))#))) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $\n                ((\\<bind>) $ (RETURN $ PR_CONST 2) $\n                 (\\<lambda>v0.\n                     (#(\\<bind>) $ (RETURN $ False) $\n                       (\\<lambda>v1.\n                           (#RETURN $\n                             (op_array_replicate $ v0 $ v1)#))#))) $\n                (\\<lambda>v1. (#RETURN $ (Pair $ v0 $ v1)#))#)));\n        xb = xa; xb = (a1', a2');\n        bind_ref_tag v0 (RETURN $ (snd $ xb))\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?\\<Gamma>1.59 x xi xa x' xb x'a a1 a2 a1' a2' *\n                           hn_ctxt (?Rh59 x xi xa x' xb x'a a1 a2 a1' a2')\n                            v0 x'b)\n                          (?f'61 x xi x' x'a a1 a2 x'b)\n                          (?\\<Gamma>2.59 x xi xa x' xb x'a a1 a2 a1' a2' v0\n                            x'b)\n                          (?R5 x xi)\n                          ((\\<bind>) $ (RETURN $ 1) $\n                           (\\<lambda>v1.\n                               (#RETURN $ (op_list_get $ v0 $ v1)#)))\n 3. \\<And>x xi xa x' xb x'a a1 a2 a1' a2' v0 x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(unit);\n        bind_ref_tag xa\n         ((\\<bind>) $\n          ((\\<bind>) $ (RETURN $ PR_CONST 5) $\n           (\\<lambda>v0.\n               (#(\\<bind>) $ (RETURN $ True) $\n                 (\\<lambda>v1.\n                     (#RETURN $ (op_array_replicate $ v0 $ v1)#))#))) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $\n                ((\\<bind>) $ (RETURN $ PR_CONST 2) $\n                 (\\<lambda>v0.\n                     (#(\\<bind>) $ (RETURN $ False) $\n                       (\\<lambda>v1.\n                           (#RETURN $\n                             (op_array_replicate $ v0 $ v1)#))#))) $\n                (\\<lambda>v1. (#RETURN $ (Pair $ v0 $ v1)#))#)));\n        xb = xa; xb = (a1', a2')\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.59 x xi xa x' xb x'a a1 a2 a1' a2' v0\n                          x'b \\<Longrightarrow>\\<^sub>t\n                         ?Q49 x xi xa x' xb x'a a1 a2 a1' a2' *\n                         hn_ctxt (?Rx59 x xi xa x' xb x'a a1 a2 a1' a2') v0\n                          x'b\n 4. \\<And>x xi xa x' xb x'a a1 a2 a1' a2'.\n       \\<lbrakk>x ::\\<^sub>i TYPE(unit);\n        bind_ref_tag xa\n         ((\\<bind>) $\n          ((\\<bind>) $ (RETURN $ PR_CONST 5) $\n           (\\<lambda>v0.\n               (#(\\<bind>) $ (RETURN $ True) $\n                 (\\<lambda>v1.\n                     (#RETURN $ (op_array_replicate $ v0 $ v1)#))#))) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $\n                ((\\<bind>) $ (RETURN $ PR_CONST 2) $\n                 (\\<lambda>v0.\n                     (#(\\<bind>) $ (RETURN $ False) $\n                       (\\<lambda>v1.\n                           (#RETURN $\n                             (op_array_replicate $ v0 $ v1)#))#))) $\n                (\\<lambda>v1. (#RETURN $ (Pair $ v0 $ v1)#))#)));\n        xb = xa; xb = (a1', a2')\\<rbrakk>\n       \\<Longrightarrow> ?Q49 x xi xa x' xb x'a a1 a2 a1'\n                          a2' \\<Longrightarrow>\\<^sub>t\n                         hn_ctxt (?P1'49 x xi xa x' xb x'a) a1' a1 *\n                         hn_ctxt (?P2'49 x xi xa x' xb x'a) a2' a2 *\n                         hn_ctxt (?XX1.49 x xi xa x' xb x'a) xb x'a *\n                         ?\\<Gamma>1'49 x xi xa x' xb x'a\n 5. \\<And>x xi xa x' xb x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(unit);\n        bind_ref_tag xa\n         ((\\<bind>) $\n          ((\\<bind>) $ (RETURN $ PR_CONST 5) $\n           (\\<lambda>v0.\n               (#(\\<bind>) $ (RETURN $ True) $\n                 (\\<lambda>v1.\n                     (#RETURN $ (op_array_replicate $ v0 $ v1)#))#))) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $\n                ((\\<bind>) $ (RETURN $ PR_CONST 2) $\n                 (\\<lambda>v0.\n                     (#(\\<bind>) $ (RETURN $ False) $\n                       (\\<lambda>v1.\n                           (#RETURN $\n                             (op_array_replicate $ v0 $ v1)#))#))) $\n                (\\<lambda>v1. (#RETURN $ (Pair $ v0 $ v1)#))#)))\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt\n                          (?P1'49 x xi xa x' xb x'a \\<times>\\<^sub>a\n                           ?P2'49 x xi xa x' xb x'a)\n                          xb x'a *\n                         ?\\<Gamma>1'49 x xi xa x' xb\n                          x'a \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.39 x xi xa x' *\n                         hn_ctxt (?R'39 x xi xa x') xb x'a\n 6. \\<And>x xi xa x'.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow>\n       ?\\<Gamma>2.39 x xi xa x' *\n       hn_ctxt (?R'39 x xi xa x') xa x' \\<Longrightarrow>\\<^sub>t\n       ?\\<Gamma>'5 x xi * hn_ctxt (?Rxc5 x xi) xa x'\n 7. \\<And>x xi.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow>\n       CNV (return 5 \\<bind>\n            (\\<lambda>x'. return True \\<bind> ($) (Array.new $ x')) \\<bind>\n            (\\<lambda>x'.\n                return 2 \\<bind>\n                (\\<lambda>x'a.\n                    return False \\<bind> ($) (Array.new $ x'a)) \\<bind>\n                (\\<lambda>x'a. return (x', x'a))) \\<bind>\n            (\\<lambda>x'.\n                let x'a = x'\n                in case x'a of\n                   (a1, a2) \\<Rightarrow>\n                     ?m'60 x xi x' x'a a1 a2 \\<bind>\n                     ?f'61 x xi x' x'a a1 a2))\n        ?f5\n 8. \\<And>x xi.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t emp\n 9. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow>\n       hn_ctxt (?R5 x xi) a c \\<Longrightarrow>\\<^sub>t hn_val bool_rel a c\n 10. CONSTRAINT_SLOT (True)", "apply sepref_dbg_trans_step_keep"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>x xi xa x' xb x'a a1 a2 a1' a2'.\n       \\<lbrakk>x ::\\<^sub>i TYPE(unit);\n        bind_ref_tag xa\n         ((\\<bind>) $\n          ((\\<bind>) $ (RETURN $ PR_CONST 5) $\n           (\\<lambda>v0.\n               (#(\\<bind>) $ (RETURN $ True) $\n                 (\\<lambda>v1.\n                     (#RETURN $ (op_array_replicate $ v0 $ v1)#))#))) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $\n                ((\\<bind>) $ (RETURN $ PR_CONST 2) $\n                 (\\<lambda>v0.\n                     (#(\\<bind>) $ (RETURN $ False) $\n                       (\\<lambda>v1.\n                           (#RETURN $\n                             (op_array_replicate $ v0 $ v1)#))#))) $\n                (\\<lambda>v1. (#RETURN $ (Pair $ v0 $ v1)#))#)));\n        xb = xa; xb = (a1', a2')\\<rbrakk>\n       \\<Longrightarrow> CONSTRAINT is_pure\n                          (array_assn bool_assn \\<times>\\<^sub>a\n                           array_assn bool_assn)\n 2. \\<And>x xi xa x' xb x'a a1 a2 a1' a2'.\n       \\<lbrakk>x ::\\<^sub>i TYPE(unit);\n        bind_ref_tag xa\n         ((\\<bind>) $\n          ((\\<bind>) $ (RETURN $ PR_CONST 5) $\n           (\\<lambda>v0.\n               (#(\\<bind>) $ (RETURN $ True) $\n                 (\\<lambda>v1.\n                     (#RETURN $ (op_array_replicate $ v0 $ v1)#))#))) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $\n                ((\\<bind>) $ (RETURN $ PR_CONST 2) $\n                 (\\<lambda>v0.\n                     (#(\\<bind>) $ (RETURN $ False) $\n                       (\\<lambda>v1.\n                           (#RETURN $\n                             (op_array_replicate $ v0 $ v1)#))#))) $\n                (\\<lambda>v1. (#RETURN $ (Pair $ v0 $ v1)#))#)));\n        xb = xa; xb = (a1', a2');\n        vassn_tag\n         (hn_ctxt\n           (array_assn bool_assn \\<times>\\<^sub>a array_assn bool_assn) xb\n           x'a)\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt\n                            (array_assn bool_assn \\<times>\\<^sub>a\n                             array_assn bool_assn)\n                            xb x'a)\n                          (?m'60 x xi x' x'a a1 a2)\n                          (?\\<Gamma>''63 x xi xa x' xb x'a a1 a2 a1' a2')\n                          (?Rh59 x xi xa x' xb x'a a1 a2 a1' a2')\n                          (RETURN $ (snd $ xb))\n 3. \\<And>x xi xa x' xb x'a a1 a2 a1' a2' v0 x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(unit);\n        bind_ref_tag xa\n         ((\\<bind>) $\n          ((\\<bind>) $ (RETURN $ PR_CONST 5) $\n           (\\<lambda>v0.\n               (#(\\<bind>) $ (RETURN $ True) $\n                 (\\<lambda>v1.\n                     (#RETURN $ (op_array_replicate $ v0 $ v1)#))#))) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $\n                ((\\<bind>) $ (RETURN $ PR_CONST 2) $\n                 (\\<lambda>v0.\n                     (#(\\<bind>) $ (RETURN $ False) $\n                       (\\<lambda>v1.\n                           (#RETURN $\n                             (op_array_replicate $ v0 $ v1)#))#))) $\n                (\\<lambda>v1. (#RETURN $ (Pair $ v0 $ v1)#))#)));\n        xb = xa; xb = (a1', a2');\n        bind_ref_tag v0 (RETURN $ (snd $ xb))\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (array_assn bool_assn) a2' a2 *\n                           hn_ctxt (array_assn bool_assn) a1' a1 *\n                           ?\\<Gamma>''63 x xi xa x' xb x'a a1 a2 a1' a2' *\n                           hn_ctxt (?Rh59 x xi xa x' xb x'a a1 a2 a1' a2')\n                            v0 x'b)\n                          (?f'61 x xi x' x'a a1 a2 x'b)\n                          (?\\<Gamma>2.59 x xi xa x' xb x'a a1 a2 a1' a2' v0\n                            x'b)\n                          (?R5 x xi)\n                          ((\\<bind>) $ (RETURN $ 1) $\n                           (\\<lambda>v1.\n                               (#RETURN $ (op_list_get $ v0 $ v1)#)))\n 4. \\<And>x xi xa x' xb x'a a1 a2 a1' a2' v0 x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(unit);\n        bind_ref_tag xa\n         ((\\<bind>) $\n          ((\\<bind>) $ (RETURN $ PR_CONST 5) $\n           (\\<lambda>v0.\n               (#(\\<bind>) $ (RETURN $ True) $\n                 (\\<lambda>v1.\n                     (#RETURN $ (op_array_replicate $ v0 $ v1)#))#))) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $\n                ((\\<bind>) $ (RETURN $ PR_CONST 2) $\n                 (\\<lambda>v0.\n                     (#(\\<bind>) $ (RETURN $ False) $\n                       (\\<lambda>v1.\n                           (#RETURN $\n                             (op_array_replicate $ v0 $ v1)#))#))) $\n                (\\<lambda>v1. (#RETURN $ (Pair $ v0 $ v1)#))#)));\n        xb = xa; xb = (a1', a2')\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.59 x xi xa x' xb x'a a1 a2 a1' a2' v0\n                          x'b \\<Longrightarrow>\\<^sub>t\n                         ?Q49 x xi xa x' xb x'a a1 a2 a1' a2' *\n                         hn_ctxt (?Rx59 x xi xa x' xb x'a a1 a2 a1' a2') v0\n                          x'b\n 5. \\<And>x xi xa x' xb x'a a1 a2 a1' a2'.\n       \\<lbrakk>x ::\\<^sub>i TYPE(unit);\n        bind_ref_tag xa\n         ((\\<bind>) $\n          ((\\<bind>) $ (RETURN $ PR_CONST 5) $\n           (\\<lambda>v0.\n               (#(\\<bind>) $ (RETURN $ True) $\n                 (\\<lambda>v1.\n                     (#RETURN $ (op_array_replicate $ v0 $ v1)#))#))) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $\n                ((\\<bind>) $ (RETURN $ PR_CONST 2) $\n                 (\\<lambda>v0.\n                     (#(\\<bind>) $ (RETURN $ False) $\n                       (\\<lambda>v1.\n                           (#RETURN $\n                             (op_array_replicate $ v0 $ v1)#))#))) $\n                (\\<lambda>v1. (#RETURN $ (Pair $ v0 $ v1)#))#)));\n        xb = xa; xb = (a1', a2')\\<rbrakk>\n       \\<Longrightarrow> ?Q49 x xi xa x' xb x'a a1 a2 a1'\n                          a2' \\<Longrightarrow>\\<^sub>t\n                         hn_ctxt (?P1'49 x xi xa x' xb x'a) a1' a1 *\n                         hn_ctxt (?P2'49 x xi xa x' xb x'a) a2' a2 *\n                         hn_ctxt (?XX1.49 x xi xa x' xb x'a) xb x'a *\n                         ?\\<Gamma>1'49 x xi xa x' xb x'a\n 6. \\<And>x xi xa x' xb x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(unit);\n        bind_ref_tag xa\n         ((\\<bind>) $\n          ((\\<bind>) $ (RETURN $ PR_CONST 5) $\n           (\\<lambda>v0.\n               (#(\\<bind>) $ (RETURN $ True) $\n                 (\\<lambda>v1.\n                     (#RETURN $ (op_array_replicate $ v0 $ v1)#))#))) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $\n                ((\\<bind>) $ (RETURN $ PR_CONST 2) $\n                 (\\<lambda>v0.\n                     (#(\\<bind>) $ (RETURN $ False) $\n                       (\\<lambda>v1.\n                           (#RETURN $\n                             (op_array_replicate $ v0 $ v1)#))#))) $\n                (\\<lambda>v1. (#RETURN $ (Pair $ v0 $ v1)#))#)))\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt\n                          (?P1'49 x xi xa x' xb x'a \\<times>\\<^sub>a\n                           ?P2'49 x xi xa x' xb x'a)\n                          xb x'a *\n                         ?\\<Gamma>1'49 x xi xa x' xb\n                          x'a \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.39 x xi xa x' *\n                         hn_ctxt (?R'39 x xi xa x') xb x'a\n 7. \\<And>x xi xa x'.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow>\n       ?\\<Gamma>2.39 x xi xa x' *\n       hn_ctxt (?R'39 x xi xa x') xa x' \\<Longrightarrow>\\<^sub>t\n       ?\\<Gamma>'5 x xi * hn_ctxt (?Rxc5 x xi) xa x'\n 8. \\<And>x xi.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow>\n       CNV (return 5 \\<bind>\n            (\\<lambda>x'. return True \\<bind> ($) (Array.new $ x')) \\<bind>\n            (\\<lambda>x'.\n                return 2 \\<bind>\n                (\\<lambda>x'a.\n                    return False \\<bind> ($) (Array.new $ x'a)) \\<bind>\n                (\\<lambda>x'a. return (x', x'a))) \\<bind>\n            (\\<lambda>x'.\n                let x'a = x'\n                in case x'a of\n                   (a1, a2) \\<Rightarrow>\n                     ?m'60 x xi x' x'a a1 a2 \\<bind>\n                     ?f'61 x xi x' x'a a1 a2))\n        ?f5\n 9. \\<And>x xi.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t emp\n 10. \\<And>x xi a c.\n        x ::\\<^sub>i TYPE(unit) \\<Longrightarrow>\n        hn_ctxt (?R5 x xi) a c \\<Longrightarrow>\\<^sub>t hn_val bool_rel a c\nA total of 11 subgoals...", "oops"], ["", "text \\<open>Works fine, as components of product are pure, such that product can be restored inside case.\\<close>"], ["", "sepref_thm product_ex2 is \"uncurry0 (do {\n    let p = (op_list_replicate 5 True, op_list_replicate 2 False);\n    case p of (a1,a2) \\<Rightarrow> RETURN (snd p!1)\n  })\" :: \"unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2,\n     uncurry0\n      (let p = (op_list_replicate 5 True, op_list_replicate 2 False)\n       in case p of (a1, a2) \\<Rightarrow> RETURN (snd p ! 1)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "by sepref_dbg_keep"], ["", "text \\<open>Trying to create a list of arrays, first attempt: \\<close>"], ["", "sepref_thm set_of_arrays_ex is \"uncurry0 (RETURN (op_list_append [] op_array_empty))\" :: \"unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a arl_assn (array_assn nat_assn)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2, uncurry0 (RETURN (op_list_append [] op_array_empty)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a arl_assn\n             (array_assn nat_assn)", "unfolding \"arl.fold_custom_empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2,\n     uncurry0 (RETURN (op_list_append op_arl_empty op_array_empty)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a arl_assn\n             (array_assn nat_assn)", "apply sepref_dbg_keep"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow>\n       hn_refine emp (?c18 x xi) (?\\<Gamma>'6 x xi) (?R6 x xi)\n        ((\\<bind>) $ (RETURN $ op_arl_empty) $\n         (\\<lambda>v0.\n             (#(\\<bind>) $ (RETURN $ op_array_empty) $\n               (\\<lambda>v1. (#RETURN $ (op_list_append $ v0 $ v1)#))#)))\n 2. \\<And>x xi.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow> CNV (?c18 x xi) ?f5\n 3. \\<And>x xi.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow>\n       ?\\<Gamma>'6 x xi \\<Longrightarrow>\\<^sub>t emp\n 4. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow>\n       hn_ctxt (?R6 x xi) a c \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (arl_assn (array_assn nat_assn)) a c\n 5. CONSTRAINT_SLOT (True)", "apply sepref_dbg_trans_keep"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x xi v0 x' v1 x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(unit);\n        bind_ref_tag v0 (RETURN $ op_arl_empty);\n        bind_ref_tag v1 (RETURN $ op_array_empty)\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (arl_assn (?A24 x xi)) v0 x' * emp *\n                           hn_ctxt (array_assn (?A31 x xi v0 x')) v1 x'a)\n                          (?f'27 x xi x' x'a)\n                          (?\\<Gamma>2.25 x xi v0 x' v1 x'a) (?R6 x xi)\n                          (RETURN $ (op_list_append $ v0 $ v1))\n 2. \\<And>x xi v0 x' v1 x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(unit);\n        bind_ref_tag v0 (RETURN $ op_arl_empty)\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.25 x xi v0 x' v1\n                          x'a \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.19 x xi v0 x' *\n                         hn_ctxt (?Rx25 x xi v0 x') v1 x'a\n 3. \\<And>x xi v0 x'.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow>\n       ?\\<Gamma>2.19 x xi v0 x' \\<Longrightarrow>\\<^sub>t\n       ?\\<Gamma>'6 x xi * hn_ctxt (?Rx19 x xi) v0 x'\n 4. \\<And>x xi.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow>\n       CNV (arl_empty \\<bind>\n            (\\<lambda>x'. heap_array_empty \\<bind> ?f'27 x xi x'))\n        ?f5\n 5. \\<And>x xi.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow>\n       ?\\<Gamma>'6 x xi \\<Longrightarrow>\\<^sub>t emp\n 6. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow>\n       hn_ctxt (?R6 x xi) a c \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (arl_assn (array_assn nat_assn)) a c\n 7. CONSTRAINT_SLOT (True)", "apply sepref_dbg_trans_step_keep"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x xi v0 x' v1 x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(unit);\n        bind_ref_tag v0 (RETURN $ op_arl_empty);\n        bind_ref_tag v1 (RETURN $ op_array_empty);\n        vassn_tag\n         (hn_ctxt (array_assn (?A31 x xi v0 x')) v1 x'a *\n          hn_ctxt (arl_assn (?A24 x xi)) v0 x')\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (array_assn (?A31 x xi v0 x')) v1 x'a *\n                           hn_ctxt (arl_assn (?A24 x xi)) v0 x')\n                          (?f'27 x xi x' x'a)\n                          (?\\<Gamma>''34 x xi v0 x' v1 x'a) (?R6 x xi)\n                          (RETURN $ (op_list_append $ v0 $ v1))\n 2. \\<And>x xi v0 x' v1 x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(unit);\n        bind_ref_tag v0 (RETURN $ op_arl_empty)\\<rbrakk>\n       \\<Longrightarrow> emp *\n                         ?\\<Gamma>''34 x xi v0 x' v1\n                          x'a \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.19 x xi v0 x' *\n                         hn_ctxt (?Rx25 x xi v0 x') v1 x'a\n 3. \\<And>x xi v0 x'.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow>\n       ?\\<Gamma>2.19 x xi v0 x' \\<Longrightarrow>\\<^sub>t\n       ?\\<Gamma>'6 x xi * hn_ctxt (?Rx19 x xi) v0 x'\n 4. \\<And>x xi.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow>\n       CNV (arl_empty \\<bind>\n            (\\<lambda>x'. heap_array_empty \\<bind> ?f'27 x xi x'))\n        ?f5\n 5. \\<And>x xi.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow>\n       ?\\<Gamma>'6 x xi \\<Longrightarrow>\\<^sub>t emp\n 6. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow>\n       hn_ctxt (?R6 x xi) a c \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (arl_assn (array_assn nat_assn)) a c\n 7. CONSTRAINT_SLOT (True)", "supply [[goals_limit = 1, unify_trace_failure]]\n  (*apply (rule arl_append_hnr[to_hnr])*)\n  \\<comment> \\<open>Many IICF data structures, in particular the array based ones, requires the element types\n    to be of @{class default}. If this is not the case, Sepref will simply find no refinement for\n    the operations. Be aware that type-class related mistakes are hard to debug in Isabelle/HOL,\n    above we sketched how to apply the refinement rule that is supposed to match with unifier \n    tracing switched on. The @{attribute to_hnr} attribute is required to convert the rule from \n    the relational form to the internal @{const hn_refine} form. Note that some rules are already \n    in @{const hn_refine} form, and need not be converted, e.g., @{thm hn_Pair}.\\<close>"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x xi v0 x' v1 x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(unit);\n        bind_ref_tag v0 (RETURN $ op_arl_empty);\n        bind_ref_tag v1 (RETURN $ op_array_empty);\n        vassn_tag\n         (hn_ctxt (array_assn (?A31 x xi v0 x')) v1 x'a *\n          hn_ctxt (arl_assn (?A24 x xi)) v0 x')\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (array_assn (?A31 x xi v0 x')) v1 x'a *\n                           hn_ctxt (arl_assn (?A24 x xi)) v0 x')\n                          (?f'27 x xi x' x'a)\n                          (?\\<Gamma>''34 x xi v0 x' v1 x'a) (?R6 x xi)\n                          (RETURN $ (op_list_append $ v0 $ v1))\nA total of 7 subgoals...", "oops"], ["", "text \\<open>So lets choose a circular singly linked list (csll), which does not require its elements to be of default type class\\<close>"], ["", "sepref_thm set_of_arrays_ex is \"uncurry0 (RETURN (op_list_append [] op_array_empty))\" :: \"unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a csll.assn (array_assn nat_assn)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2, uncurry0 (RETURN (op_list_append [] op_array_empty)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a csll.assn\n             (array_assn nat_assn)", "unfolding \"csll.fold_custom_empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2,\n     uncurry0 (RETURN (op_list_append csll_empty op_array_empty)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a csll.assn\n             (array_assn nat_assn)", "apply sepref_dbg_keep"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow>\n       hn_refine emp (?c18 x xi) (?\\<Gamma>'6 x xi) (?R6 x xi)\n        ((\\<bind>) $ (RETURN $ csll_empty) $\n         (\\<lambda>v0.\n             (#(\\<bind>) $ (RETURN $ op_array_empty) $\n               (\\<lambda>v1. (#RETURN $ (op_list_append $ v0 $ v1)#))#)))\n 2. \\<And>x xi.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow> CNV (?c18 x xi) ?f5\n 3. \\<And>x xi.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow>\n       ?\\<Gamma>'6 x xi \\<Longrightarrow>\\<^sub>t emp\n 4. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow>\n       hn_ctxt (?R6 x xi) a c \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (csll.assn (array_assn nat_assn)) a c\n 5. CONSTRAINT_SLOT (True)", "apply sepref_dbg_trans_keep"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x xi v0 x' v1 x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(unit);\n        bind_ref_tag v0 (RETURN $ csll_empty);\n        bind_ref_tag v1 (RETURN $ op_array_empty)\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (csll.assn (?A24 x xi)) v0 x' * emp *\n                           hn_ctxt (array_assn (?A31 x xi v0 x')) v1 x'a)\n                          (?f'27 x xi x' x'a)\n                          (?\\<Gamma>2.25 x xi v0 x' v1 x'a) (?R6 x xi)\n                          (RETURN $ (op_list_append $ v0 $ v1))\n 2. \\<And>x xi v0 x' v1 x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(unit);\n        bind_ref_tag v0 (RETURN $ csll_empty)\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.25 x xi v0 x' v1\n                          x'a \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.19 x xi v0 x' *\n                         hn_ctxt (?Rx25 x xi v0 x') v1 x'a\n 3. \\<And>x xi v0 x'.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow>\n       ?\\<Gamma>2.19 x xi v0 x' \\<Longrightarrow>\\<^sub>t\n       ?\\<Gamma>'6 x xi * hn_ctxt (?Rx19 x xi) v0 x'\n 4. \\<And>x xi.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow>\n       CNV (cs_empty \\<bind>\n            (\\<lambda>x'. heap_array_empty \\<bind> ?f'27 x xi x'))\n        ?f5\n 5. \\<And>x xi.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow>\n       ?\\<Gamma>'6 x xi \\<Longrightarrow>\\<^sub>t emp\n 6. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow>\n       hn_ctxt (?R6 x xi) a c \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (csll.assn (array_assn nat_assn)) a c\n 7. CONSTRAINT_SLOT (True)", "apply sepref_dbg_trans_step_keep\n  \\<comment> \\<open>We end up with an unprovable purity-constraint: As many IICF types, csll \n    only supports pure member types. We expect this restriction to be lifted in \n    some future version.\\<close>"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x xi v0 x' v1 x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(unit);\n        bind_ref_tag v0 (RETURN $ csll_empty);\n        bind_ref_tag v1 (RETURN $ op_array_empty);\n        vassn_tag\n         (hn_ctxt (array_assn (?A38 x xi)) v1 x'a *\n          hn_ctxt (csll.assn (array_assn (?A38 x xi))) v0 x')\\<rbrakk>\n       \\<Longrightarrow> CONSTRAINT is_pure (array_assn (?A38 x xi))\n 2. \\<And>x xi v0 x' v1 x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(unit);\n        bind_ref_tag v0 (RETURN $ csll_empty)\\<rbrakk>\n       \\<Longrightarrow> emp *\n                         (hn_ctxt (array_assn (?A38 x xi)) v1 x'a *\n                          hn_invalid (csll.assn (array_assn (?A38 x xi))) v0\n                           x') \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.19 x xi v0 x' *\n                         hn_ctxt (?Rx25 x xi v0 x') v1 x'a\n 3. \\<And>x xi v0 x'.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow>\n       ?\\<Gamma>2.19 x xi v0 x' \\<Longrightarrow>\\<^sub>t\n       ?\\<Gamma>'6 x xi * hn_ctxt (?Rx19 x xi) v0 x'\n 4. \\<And>x xi.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow>\n       CNV (cs_empty \\<bind>\n            (\\<lambda>x'.\n                heap_array_empty \\<bind> ($) (swap_args2 cs_append $ x')))\n        ?f5\n 5. \\<And>x xi.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow>\n       ?\\<Gamma>'6 x xi \\<Longrightarrow>\\<^sub>t emp\n 6. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow>\n       hn_ctxt (csll.assn (array_assn (?A38 x xi))) a\n        c \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (csll.assn (array_assn nat_assn)) a c\n 7. CONSTRAINT_SLOT (True)", "oops"], ["", "text \\<open>Finally, there are a few data structures that already support nested element types, for example, functional lists:\\<close>"], ["", "sepref_thm set_of_arrays_ex is \"uncurry0 (RETURN (op_list_append [] op_array_empty))\" :: \"unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn (array_assn nat_assn)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2, uncurry0 (RETURN (op_list_append [] op_array_empty)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n             (array_assn nat_assn)", "unfolding \"HOL_list.fold_custom_empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2,\n     uncurry0 (RETURN (op_list_append op_HOL_list_empty op_array_empty)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n             (array_assn nat_assn)", "by sepref"], ["", "subsection \\<open>Fixed-Size Data Structures\\<close>"], ["", "text \\<open>For many algorithms, the required size of a data structure is already known,\n  such that it is not necessary to use data structures with dynamic resizing.\n\n  The Sepref-tool supports such data structures, however, with some limitations.\n\\<close>"], ["", "subsubsection \\<open>Running Example\\<close>"], ["", "text \\<open>\n  Assume we want to read a sequence of natural numbers in the range @{term \"{0..<N}\"},\n  and drop duplicate numbers. The following abstract algorithm may work:\n\\<close>"], ["", "definition \"remdup l \\<equiv> do {\n  (s,r) \\<leftarrow> nfoldli l (\\<lambda>_. True) \n    (\\<lambda>x (s,r). do {\n      ASSERT (distinct r \\<and> set r \\<subseteq> set l \\<and> s = set r); \\<comment> \\<open>Will be required to prove that list does not grow too long\\<close>\n      if x\\<in>s then RETURN (s,r) else RETURN (insert x s, r@[x])\n    }) \n    ({},[]);\n  RETURN r\n}\""], ["", "text \\<open>We want to use \\<open>remdup\\<close> in our abstract code, so we have to register it.\\<close>"], ["", "sepref_register remdup"], ["", "text \\<open>The straightforward version with dynamic data-structures is: \\<close>"], ["", "sepref_definition remdup1 is \"remdup\" :: \"(list_assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a arl_assn nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, remdup)\n    \\<in> (list_assn\n            nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a arl_assn nat_assn", "unfolding remdup_def[abs_def]\n  \\<comment> \\<open>Lets use a bit-vector for the set\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>l.\n        nfoldli l (\\<lambda>_. True)\n         (\\<lambda>x (s, r).\n             ASSERT\n              (distinct r \\<and>\n               set r \\<subseteq> set l \\<and> s = set r) \\<bind>\n             (\\<lambda>_.\n                 if x \\<in> s then RETURN (s, r)\n                 else RETURN (insert x s, r @ [x])))\n         ({}, []) \\<bind>\n        (\\<lambda>(s, r). RETURN r))\n    \\<in> (list_assn\n            nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a arl_assn nat_assn", "apply (rewrite in \"nfoldli _ _ _ \\<hole>\" ias.fold_custom_empty)\n  \\<comment> \\<open>And an array-list for the list\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>l.\n        nfoldli l (\\<lambda>_. True)\n         (\\<lambda>x (s, r).\n             ASSERT\n              (distinct r \\<and>\n               set r \\<subseteq> set l \\<and> s = set r) \\<bind>\n             (\\<lambda>_.\n                 if x \\<in> s then RETURN (s, r)\n                 else RETURN (insert x s, r @ [x])))\n         (op_ias_empty, []) \\<bind>\n        (\\<lambda>(s, r). RETURN r))\n    \\<in> (list_assn\n            nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a arl_assn nat_assn", "apply (rewrite in \"nfoldli _ _ _ \\<hole>\" arl.fold_custom_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>l.\n        nfoldli l (\\<lambda>_. True)\n         (\\<lambda>x (s, r).\n             ASSERT\n              (distinct r \\<and>\n               set r \\<subseteq> set l \\<and> s = set r) \\<bind>\n             (\\<lambda>_.\n                 if x \\<in> s then RETURN (s, r)\n                 else RETURN (insert x s, r @ [x])))\n         (op_ias_empty, op_arl_empty) \\<bind>\n        (\\<lambda>(s, r). RETURN r))\n    \\<in> (list_assn\n            nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a arl_assn nat_assn", "by sepref"], ["", "subsubsection \\<open>Initialization of Dynamic Data Structures\\<close>"], ["", "text \\<open>Now let's fix an upper bound for the numbers in the list.\n  Initializations and statically sized data structures must always be fixed variables,\n  they cannot be computed inside the refined program. \n\n  TODO: Lift this restriction at least for initialization hints that do not occur \n    in the refinement assertions.\n\\<close>"], ["", "context fixes N :: nat begin"], ["", "sepref_definition remdup1_initsz is \"remdup\" :: \"(list_assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a arl_assn nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, remdup)\n    \\<in> (list_assn\n            nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a arl_assn nat_assn", "unfolding remdup_def[abs_def]\n  \\<comment> \\<open>Many of the dynamic array-based data structures in the IICF can be \n    pre-initialized to a certain size. THis initialization is only a hint, \n    and has no abstract consequences. The list data structure will still be \n    resized if it grows larger than the initialization size.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>l.\n        nfoldli l (\\<lambda>_. True)\n         (\\<lambda>x (s, r).\n             ASSERT\n              (distinct r \\<and>\n               set r \\<subseteq> set l \\<and> s = set r) \\<bind>\n             (\\<lambda>_.\n                 if x \\<in> s then RETURN (s, r)\n                 else RETURN (insert x s, r @ [x])))\n         ({}, []) \\<bind>\n        (\\<lambda>(s, r). RETURN r))\n    \\<in> (list_assn\n            nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a arl_assn nat_assn", "apply (rewrite in \"nfoldli _ _ _ \\<hole>\" ias_sz.fold_custom_empty[of N])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>l.\n        nfoldli l (\\<lambda>_. True)\n         (\\<lambda>x (s, r).\n             ASSERT\n              (distinct r \\<and>\n               set r \\<subseteq> set l \\<and> s = set r) \\<bind>\n             (\\<lambda>_.\n                 if x \\<in> s then RETURN (s, r)\n                 else RETURN (insert x s, r @ [x])))\n         (PR_CONST (op_ias_empty_sz N), []) \\<bind>\n        (\\<lambda>(s, r). RETURN r))\n    \\<in> (list_assn\n            nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a arl_assn nat_assn", "apply (rewrite in \"nfoldli _ _ _ \\<hole>\" arl_sz.fold_custom_empty[of N])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>l.\n        nfoldli l (\\<lambda>_. True)\n         (\\<lambda>x (s, r).\n             ASSERT\n              (distinct r \\<and>\n               set r \\<subseteq> set l \\<and> s = set r) \\<bind>\n             (\\<lambda>_.\n                 if x \\<in> s then RETURN (s, r)\n                 else RETURN (insert x s, r @ [x])))\n         (PR_CONST (op_ias_empty_sz N),\n          PR_CONST (op_arl_empty_sz N)) \\<bind>\n        (\\<lambda>(s, r). RETURN r))\n    \\<in> (list_assn\n            nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a arl_assn nat_assn", "by sepref"], ["", "end"], ["", "text \\<open>To get a usable function, we may add the fixed \\<open>N\\<close> as a parameter, effectively converting\n  the initialization hint to a parameter, which, however, has no abstract meaning\\<close>"], ["", "definition \"remdup_initsz (N::nat) \\<equiv> remdup\""], ["", "lemma remdup_init_hnr: \n  \"(uncurry remdup1_initsz, uncurry remdup_initsz) \\<in> nat_assn\\<^sup>k *\\<^sub>a (list_assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a arl_assn nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry remdup1_initsz, uncurry remdup_initsz)\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a\n          (list_assn\n            nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a arl_assn nat_assn", "using remdup1_initsz.refine"], ["proof (prove)\nusing this:\n  (remdup1_initsz ?N, remdup)\n  \\<in> (list_assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a arl_assn nat_assn\n\ngoal (1 subgoal):\n 1. (uncurry remdup1_initsz, uncurry remdup_initsz)\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a\n          (list_assn\n            nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a arl_assn nat_assn", "unfolding remdup_initsz_def[abs_def]"], ["proof (prove)\nusing this:\n  (remdup1_initsz ?N, remdup)\n  \\<in> (list_assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a arl_assn nat_assn\n\ngoal (1 subgoal):\n 1. (uncurry remdup1_initsz, uncurry (\\<lambda>N. remdup))\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a\n          (list_assn\n            nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a arl_assn nat_assn", "unfolding hfref_def hn_refine_def"], ["proof (prove)\nusing this:\n  (remdup1_initsz ?N, remdup)\n  \\<in> {(f, g).\n         \\<forall>c a.\n            True \\<longrightarrow>\n            nofail (g a) \\<longrightarrow>\n            <fst ((list_assn nat_assn)\\<^sup>k) a\n              c> f c <\\<lambda>r.\n                         snd ((list_assn nat_assn)\\<^sup>k) a c *\n                         (\\<exists>\\<^sub>Ax.\n                             arl_assn nat_assn x r *\n                             \\<up> (RETURN x \\<le> g a))>\\<^sub>t}\n\ngoal (1 subgoal):\n 1. (uncurry remdup1_initsz, uncurry (\\<lambda>N. remdup))\n    \\<in> {(f, g).\n           \\<forall>c a.\n              True \\<longrightarrow>\n              nofail (g a) \\<longrightarrow>\n              <fst (nat_assn\\<^sup>k *\\<^sub>a (list_assn nat_assn)\\<^sup>k)\n                a c> f c <\\<lambda>r.\n                             snd (nat_assn\\<^sup>k *\\<^sub>a\n                                  (list_assn nat_assn)\\<^sup>k)\n                              a c *\n                             (\\<exists>\\<^sub>Ax.\n                                 arl_assn nat_assn x r *\n                                 \\<up> (RETURN x \\<le> g a))>\\<^sub>t}", "by (auto simp: pure_def)"], ["", "subsubsection \\<open>Static Data Structures\\<close>"], ["", "text \\<open>We use a locale to hide local declarations. Note: This locale will never be interpreted,\n  otherwise all the local setup, that does not make sense outside the locale, would become visible.\n  TODO: This is probably some abuse of locales to emulate complex private setup, \n      including declaration of constants and lemmas.\n\\<close>"], ["", "locale my_remdup_impl_loc = \n  fixes N :: nat \n  assumes \"N>0\" \\<comment> \\<open>This assumption is not necessary, but used to illustrate the \n    general case, where the locale may have such assumptions\\<close>\nbegin"], ["", "text \\<open>For locale hierarchies, the following seems not to be available directly in Isabelle,\n    however, it is useful when transferring stuff between the global theory and the locale\\<close>"], ["", "lemma my_remdup_impl_loc_this: \"my_remdup_impl_loc N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. my_remdup_impl_loc N", "by unfold_locales"], ["", "text \\<open>\n    Note that this will often require to use \\<open>N\\<close> as a usual constant, which \n    is refined. For pure refinements, we can use the @{attribute sepref_import_param}\n    attribute, which will convert a parametricity theorem to a rule for Sepref:\n    \\<close>"], ["", "sepref_register N"], ["", "lemma N_hnr[sepref_import_param]: \"(N,N)\\<in>nat_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (N, N) \\<in> nat_rel", "by simp"], ["", "thm N_hnr"], ["", "text \\<open>Alternatively, we could directly prove the following rule, which, however, is \n    more cumbersome: \\<close>"], ["", "lemma N_hnr': \"(uncurry0 (return N), uncurry0 (RETURN N))\\<in>unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 (return N), uncurry0 (RETURN N))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "by sepref_to_hoare sep_auto"], ["", "text \\<open>Next, we use an array-list with a fixed maximum capacity. \n    Note that the capacity is part of the refinement assertion now.\n  \\<close>"], ["", "sepref_definition remdup1_fixed is \"remdup\" :: \"(list_assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a marl_assn N nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, remdup)\n    \\<in> (list_assn\n            nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a marl_assn N nat_assn", "unfolding remdup_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>l.\n        nfoldli l (\\<lambda>_. True)\n         (\\<lambda>x (s, r).\n             ASSERT\n              (distinct r \\<and>\n               set r \\<subseteq> set l \\<and> s = set r) \\<bind>\n             (\\<lambda>_.\n                 if x \\<in> s then RETURN (s, r)\n                 else RETURN (insert x s, r @ [x])))\n         ({}, []) \\<bind>\n        (\\<lambda>(s, r). RETURN r))\n    \\<in> (list_assn\n            nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a marl_assn N nat_assn", "apply (rewrite in \"nfoldli _ _ _ \\<hole>\" ias_sz.fold_custom_empty[of N])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>l.\n        nfoldli l (\\<lambda>_. True)\n         (\\<lambda>x (s, r).\n             ASSERT\n              (distinct r \\<and>\n               set r \\<subseteq> set l \\<and> s = set r) \\<bind>\n             (\\<lambda>_.\n                 if x \\<in> s then RETURN (s, r)\n                 else RETURN (insert x s, r @ [x])))\n         (PR_CONST (op_ias_empty_sz N), []) \\<bind>\n        (\\<lambda>(s, r). RETURN r))\n    \\<in> (list_assn\n            nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a marl_assn N nat_assn", "apply (rewrite in \"nfoldli _ _ _ \\<hole>\" marl_fold_custom_empty_sz[of N])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>l.\n        nfoldli l (\\<lambda>_. True)\n         (\\<lambda>x (s, r).\n             ASSERT\n              (distinct r \\<and>\n               set r \\<subseteq> set l \\<and> s = set r) \\<bind>\n             (\\<lambda>_.\n                 if x \\<in> s then RETURN (s, r)\n                 else RETURN (insert x s, r @ [x])))\n         (PR_CONST (op_ias_empty_sz N), op_marl_empty_sz N) \\<bind>\n        (\\<lambda>(s, r). RETURN r))\n    \\<in> (list_assn\n            nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a marl_assn N nat_assn", "supply [[goals_limit = 1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>l.\n        nfoldli l (\\<lambda>_. True)\n         (\\<lambda>x (s, r).\n             ASSERT\n              (distinct r \\<and>\n               set r \\<subseteq> set l \\<and> s = set r) \\<bind>\n             (\\<lambda>_.\n                 if x \\<in> s then RETURN (s, r)\n                 else RETURN (insert x s, r @ [x])))\n         (PR_CONST (op_ias_empty_sz N), op_marl_empty_sz N) \\<bind>\n        (\\<lambda>(s, r). RETURN r))\n    \\<in> (list_assn\n            nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a marl_assn N nat_assn", "apply sepref_dbg_keep"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_refine (hn_ctxt (list_assn nat_assn) x xi) (?c76 x xi)\n        (?\\<Gamma>'5 x xi) (?R5 x xi)\n        ((\\<bind>) $\n         ((\\<bind>) $\n          ((\\<bind>) $ (RETURN $ PR_CONST (op_ias_empty_sz N)) $\n           (\\<lambda>v0.\n               (#(\\<bind>) $ (RETURN $ PR_CONST (op_marl_empty_sz N)) $\n                 (\\<lambda>v1. (#RETURN $ (Pair $ v0 $ v1)#))#))) $\n          (\\<lambda>xa.\n              (#monadic_nfoldli $ x $ (\\<lambda>x. (#RETURN $ True#)) $\n                (\\<lambda>xa.\n                    (#\\<lambda>xb.\n                         (#case_prod $\n                           (\\<lambda>xb.\n                               (#\\<lambda>xc.\n                                    (#PR_CONST\n (op_ASSERT_bind\n   (distinct xc \\<and> set xc \\<subseteq> set x \\<and> xb = set xc)) $\n((\\<bind>) $ (RETURN $ (op_set_member $ xa $ xb)) $\n (\\<lambda>x.\n     (#If $ x $ (RETURN $ (Pair $ xb $ xc)) $\n       ((\\<bind>) $ (RETURN $ (op_set_insert $ xa $ xb)) $\n        (\\<lambda>v0.\n            (#(\\<bind>) $ (RETURN $ (op_list_append $ xc $ xa)) $\n              (\\<lambda>v1. (#RETURN $ (Pair $ v0 $ v1)#))#)))#)))#)#)) $\n                           xb#)#)) $\n                xa#))) $\n         (\\<lambda>x.\n             (#case_prod $ (\\<lambda>x. (#\\<lambda>x. (#PASS $ x#)#)) $\n               x#)))\nA total of 5 subgoals...", "apply sepref_dbg_trans_keep"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> a1 a2 a1' a2' xc x'b v0 x'c.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa\n         ((\\<bind>) $ (RETURN $ PR_CONST (op_ias_empty_sz N)) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $ (RETURN $ PR_CONST (op_marl_empty_sz N)) $\n                (\\<lambda>v1. (#RETURN $ (Pair $ v0 $ v1)#))#)));\n        x'a \\<in> set x; \\<sigma>' = (a1', a2');\n        distinct a2' \\<and> set a2' \\<subseteq> set x \\<and> a1' = set a2';\n        bind_ref_tag xc (RETURN $ (op_set_member $ x'a $ a1')); \\<not> xc;\n        bind_ref_tag v0 (RETURN $ (op_set_insert $ x'a $ a1'))\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_val bool_rel xc x'b *\n                           hn_ctxt (marl_assn N ?A8) a2' a2 *\n                           hn_invalid\n                            (ias.assn nat_assn \\<times>\\<^sub>a\n                             marl_assn N ?A8)\n                            \\<sigma>' \\<sigma> *\n                           (hn_invalid (ias.assn nat_assn) a1' a1 *\n                            hn_val nat_rel x'a xb) *\n                           hn_ctxt (ias.assn nat_assn) v0 x'c)\n                          (?m'10 x xi x' xb \\<sigma> a1 a2 x'b x'c)\n                          (?\\<Gamma>1.9 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                            a1 a2 a1' a2' xc x'b v0 x'c)\n                          (?Rh9 x xi xa x' x'a xb \\<sigma>' \\<sigma> a1 a2\n                            a1' a2' xc x'b v0 x'c)\n                          (RETURN $ (op_list_append $ a2' $ x'a))\nA total of 16 subgoals...", "apply sepref_dbg_trans_step_keep\n    \\<comment> \\<open>In order to append to the array list, we have to show that the size is not yet exceeded.\n      This may require to add some assertions on the abstract level. We already have added\n      some assertions in the definition of @{const remdup}.\\<close>"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> a1 a2 a1' a2' xc x'b v0 x'c.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa\n         ((\\<bind>) $ (RETURN $ PR_CONST (op_ias_empty_sz N)) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $ (RETURN $ PR_CONST (op_marl_empty_sz N)) $\n                (\\<lambda>v1. (#RETURN $ (Pair $ v0 $ v1)#))#)));\n        x'a \\<in> set x; \\<sigma>' = (a1', a2');\n        distinct a2' \\<and> set a2' \\<subseteq> set x \\<and> a1' = set a2';\n        bind_ref_tag xc (RETURN $ (op_set_member $ x'a $ a1')); \\<not> xc;\n        bind_ref_tag v0 (RETURN $ (op_set_insert $ x'a $ a1'));\n        vassn_tag\n         (hn_val nat_rel x'a xb *\n          hn_ctxt (marl_assn N nat_assn) a2' a2)\\<rbrakk>\n       \\<Longrightarrow> length a2' < N\nA total of 16 subgoals...", "oops"], ["", "text \\<open>Moreover, we add a precondition on the list\\<close>"], ["", "sepref_definition remdup1_fixed is \"remdup\" :: \"[\\<lambda>l. set l \\<subseteq> {0..<N}]\\<^sub>a (list_assn nat_assn)\\<^sup>k \\<rightarrow> marl_assn N nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, remdup)\n    \\<in> [\\<lambda>l.\n              set l\n              \\<subseteq> {0..<N}]\\<^sub>a (list_assn\n       nat_assn)\\<^sup>k \\<rightarrow> marl_assn N nat_assn", "unfolding remdup_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>l.\n        nfoldli l (\\<lambda>_. True)\n         (\\<lambda>x (s, r).\n             ASSERT\n              (distinct r \\<and>\n               set r \\<subseteq> set l \\<and> s = set r) \\<bind>\n             (\\<lambda>_.\n                 if x \\<in> s then RETURN (s, r)\n                 else RETURN (insert x s, r @ [x])))\n         ({}, []) \\<bind>\n        (\\<lambda>(s, r). RETURN r))\n    \\<in> [\\<lambda>l.\n              set l\n              \\<subseteq> {0..<N}]\\<^sub>a (list_assn\n       nat_assn)\\<^sup>k \\<rightarrow> marl_assn N nat_assn", "apply (rewrite in \"nfoldli _ _ _ \\<hole>\" ias_sz.fold_custom_empty[of N])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>l.\n        nfoldli l (\\<lambda>_. True)\n         (\\<lambda>x (s, r).\n             ASSERT\n              (distinct r \\<and>\n               set r \\<subseteq> set l \\<and> s = set r) \\<bind>\n             (\\<lambda>_.\n                 if x \\<in> s then RETURN (s, r)\n                 else RETURN (insert x s, r @ [x])))\n         (PR_CONST (op_ias_empty_sz N), []) \\<bind>\n        (\\<lambda>(s, r). RETURN r))\n    \\<in> [\\<lambda>l.\n              set l\n              \\<subseteq> {0..<N}]\\<^sub>a (list_assn\n       nat_assn)\\<^sup>k \\<rightarrow> marl_assn N nat_assn", "apply (rewrite in \"nfoldli _ _ _ \\<hole>\" marl_fold_custom_empty_sz[of N])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>l.\n        nfoldli l (\\<lambda>_. True)\n         (\\<lambda>x (s, r).\n             ASSERT\n              (distinct r \\<and>\n               set r \\<subseteq> set l \\<and> s = set r) \\<bind>\n             (\\<lambda>_.\n                 if x \\<in> s then RETURN (s, r)\n                 else RETURN (insert x s, r @ [x])))\n         (PR_CONST (op_ias_empty_sz N), op_marl_empty_sz N) \\<bind>\n        (\\<lambda>(s, r). RETURN r))\n    \\<in> [\\<lambda>l.\n              set l\n              \\<subseteq> {0..<N}]\\<^sub>a (list_assn\n       nat_assn)\\<^sup>k \\<rightarrow> marl_assn N nat_assn", "supply [[goals_limit = 1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>l.\n        nfoldli l (\\<lambda>_. True)\n         (\\<lambda>x (s, r).\n             ASSERT\n              (distinct r \\<and>\n               set r \\<subseteq> set l \\<and> s = set r) \\<bind>\n             (\\<lambda>_.\n                 if x \\<in> s then RETURN (s, r)\n                 else RETURN (insert x s, r @ [x])))\n         (PR_CONST (op_ias_empty_sz N), op_marl_empty_sz N) \\<bind>\n        (\\<lambda>(s, r). RETURN r))\n    \\<in> [\\<lambda>l.\n              set l\n              \\<subseteq> {0..<N}]\\<^sub>a (list_assn\n       nat_assn)\\<^sup>k \\<rightarrow> marl_assn N nat_assn", "apply sepref_dbg_keep"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x xi.\n       \\<lbrakk>set x \\<subseteq> {0..<N};\n        x ::\\<^sub>i TYPE(nat list)\\<rbrakk>\n       \\<Longrightarrow> hn_refine (hn_ctxt (list_assn nat_assn) x xi)\n                          (?c76 x xi) (?\\<Gamma>'5 x xi) (?R5 x xi)\n                          ((\\<bind>) $\n                           ((\\<bind>) $\n                            ((\\<bind>) $\n                             (RETURN $ PR_CONST (op_ias_empty_sz N)) $\n                             (\\<lambda>v0.\n                                 (#(\\<bind>) $\n                                   (RETURN $\n                                    PR_CONST (op_marl_empty_sz N)) $\n                                   (\\<lambda>v1.\n (#RETURN $ (Pair $ v0 $ v1)#))#))) $\n                            (\\<lambda>xa.\n                                (#monadic_nfoldli $ x $\n                                  (\\<lambda>x. (#RETURN $ True#)) $\n                                  (\\<lambda>xa.\n(#\\<lambda>xb.\n     (#case_prod $\n       (\\<lambda>xb.\n           (#\\<lambda>xc.\n                (#PR_CONST\n                   (op_ASSERT_bind\n                     (distinct xc \\<and>\n                      set xc \\<subseteq> set x \\<and> xb = set xc)) $\n                  ((\\<bind>) $ (RETURN $ (op_set_member $ xa $ xb)) $\n                   (\\<lambda>x.\n                       (#If $ x $ (RETURN $ (Pair $ xb $ xc)) $\n                         ((\\<bind>) $ (RETURN $ (op_set_insert $ xa $ xb)) $\n                          (\\<lambda>v0.\n                              (#(\\<bind>) $\n                                (RETURN $ (op_list_append $ xc $ xa)) $\n                                (\\<lambda>v1.\n                                    (#RETURN $\n(Pair $ v0 $ v1)#))#)))#)))#)#)) $\n       xb#)#)) $\n                                  xa#))) $\n                           (\\<lambda>x.\n                               (#case_prod $\n                                 (\\<lambda>x.\n                                     (#\\<lambda>x. (#PASS $ x#)#)) $\n                                 x#)))\nA total of 5 subgoals...", "apply sepref_dbg_trans_keep"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> a1 a2 a1' a2' xc x'b v0 x'c.\n       \\<lbrakk>set x \\<subseteq> {0..<N}; x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa\n         ((\\<bind>) $ (RETURN $ PR_CONST (op_ias_empty_sz N)) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $ (RETURN $ PR_CONST (op_marl_empty_sz N)) $\n                (\\<lambda>v1. (#RETURN $ (Pair $ v0 $ v1)#))#)));\n        x'a \\<in> set x; \\<sigma>' = (a1', a2');\n        distinct a2' \\<and> set a2' \\<subseteq> set x \\<and> a1' = set a2';\n        bind_ref_tag xc (RETURN $ (op_set_member $ x'a $ a1')); \\<not> xc;\n        bind_ref_tag v0 (RETURN $ (op_set_insert $ x'a $ a1'))\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_val bool_rel xc x'b *\n                           hn_ctxt (marl_assn N ?A8) a2' a2 *\n                           hn_invalid\n                            (ias.assn nat_assn \\<times>\\<^sub>a\n                             marl_assn N ?A8)\n                            \\<sigma>' \\<sigma> *\n                           (hn_invalid (ias.assn nat_assn) a1' a1 *\n                            hn_val nat_rel x'a xb) *\n                           hn_ctxt (ias.assn nat_assn) v0 x'c)\n                          (?m'10 x xi x' xb \\<sigma> a1 a2 x'b x'c)\n                          (?\\<Gamma>1.9 x xi xa x' x'a xb \\<sigma>' \\<sigma>\n                            a1 a2 a1' a2' xc x'b v0 x'c)\n                          (?Rh9 x xi xa x' x'a xb \\<sigma>' \\<sigma> a1 a2\n                            a1' a2' xc x'b v0 x'c)\n                          (RETURN $ (op_list_append $ a2' $ x'a))\nA total of 16 subgoals...", "apply sepref_dbg_trans_step_keep"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>x xi xa x' x'a xb \\<sigma>' \\<sigma> a1 a2 a1' a2' xc x'b v0 x'c.\n       \\<lbrakk>set x \\<subseteq> {0..<N}; x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa\n         ((\\<bind>) $ (RETURN $ PR_CONST (op_ias_empty_sz N)) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $ (RETURN $ PR_CONST (op_marl_empty_sz N)) $\n                (\\<lambda>v1. (#RETURN $ (Pair $ v0 $ v1)#))#)));\n        x'a \\<in> set x; \\<sigma>' = (a1', a2');\n        distinct a2' \\<and> set a2' \\<subseteq> set x \\<and> a1' = set a2';\n        bind_ref_tag xc (RETURN $ (op_set_member $ x'a $ a1')); \\<not> xc;\n        bind_ref_tag v0 (RETURN $ (op_set_insert $ x'a $ a1'));\n        vassn_tag\n         (hn_val nat_rel x'a xb *\n          hn_ctxt (marl_assn N nat_assn) a2' a2)\\<rbrakk>\n       \\<Longrightarrow> length a2' < N\nA total of 16 subgoals...", "apply sepref_dbg_side_keep\n    \\<comment> \\<open>We can start from this subgoal to find missing lemmas\\<close>"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>x x'a a2' xc.\n       \\<lbrakk>set x \\<subseteq> {0..<N}; x'a \\<in> set x;\n        x'a \\<notin> set a2'; \\<not> xc; distinct a2';\n        set a2' \\<subseteq> set x; rdomp (marl_assn N nat_assn) a2'\\<rbrakk>\n       \\<Longrightarrow> length a2' < N\nA total of 16 subgoals...", "oops"], ["", "text \\<open>We can prove the remaining subgoal, e.g., by @{method auto} with the following\n    lemma declared as introduction rule:\\<close>"], ["", "lemma aux1[intro]: \"\\<lbrakk> set l \\<subset> {0..<N}; distinct l \\<rbrakk> \\<Longrightarrow> length l < N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set l \\<subset> {0..<N}; distinct l\\<rbrakk>\n    \\<Longrightarrow> length l < N", "apply (simp add: distinct_card[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set l \\<subset> {0..<N}; distinct l\\<rbrakk>\n    \\<Longrightarrow> card (set l) < N", "apply (drule psubset_card_mono[rotated])"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct l \\<Longrightarrow> finite {0..<N}\n 2. \\<lbrakk>distinct l; card (set l) < card {0..<N}\\<rbrakk>\n    \\<Longrightarrow> card (set l) < N", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>We use some standard boilerplate to define the constant globally, although\n    being inside the locale. This is required for code-generation.\\<close>"], ["", "sepref_thm remdup1_fixed is \"remdup\" :: \"[\\<lambda>l. set l \\<subseteq> {0..<N}]\\<^sub>a (list_assn nat_assn)\\<^sup>k \\<rightarrow> marl_assn N nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, remdup)\n    \\<in> [\\<lambda>l.\n              set l\n              \\<subseteq> {0..<N}]\\<^sub>a (list_assn\n       nat_assn)\\<^sup>k \\<rightarrow> marl_assn N nat_assn", "unfolding remdup_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>l.\n        nfoldli l (\\<lambda>_. True)\n         (\\<lambda>x (s, r).\n             ASSERT\n              (distinct r \\<and>\n               set r \\<subseteq> set l \\<and> s = set r) \\<bind>\n             (\\<lambda>_.\n                 if x \\<in> s then RETURN (s, r)\n                 else RETURN (insert x s, r @ [x])))\n         ({}, []) \\<bind>\n        (\\<lambda>(s, r). RETURN r))\n    \\<in> [\\<lambda>l.\n              set l\n              \\<subseteq> {0..<N}]\\<^sub>a (list_assn\n       nat_assn)\\<^sup>k \\<rightarrow> marl_assn N nat_assn", "apply (rewrite in \"nfoldli _ _ _ \\<hole>\" ias_sz.fold_custom_empty[of N])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>l.\n        nfoldli l (\\<lambda>_. True)\n         (\\<lambda>x (s, r).\n             ASSERT\n              (distinct r \\<and>\n               set r \\<subseteq> set l \\<and> s = set r) \\<bind>\n             (\\<lambda>_.\n                 if x \\<in> s then RETURN (s, r)\n                 else RETURN (insert x s, r @ [x])))\n         (PR_CONST (op_ias_empty_sz N), []) \\<bind>\n        (\\<lambda>(s, r). RETURN r))\n    \\<in> [\\<lambda>l.\n              set l\n              \\<subseteq> {0..<N}]\\<^sub>a (list_assn\n       nat_assn)\\<^sup>k \\<rightarrow> marl_assn N nat_assn", "apply (rewrite in \"nfoldli _ _ _ \\<hole>\" marl_fold_custom_empty_sz[of N])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>l.\n        nfoldli l (\\<lambda>_. True)\n         (\\<lambda>x (s, r).\n             ASSERT\n              (distinct r \\<and>\n               set r \\<subseteq> set l \\<and> s = set r) \\<bind>\n             (\\<lambda>_.\n                 if x \\<in> s then RETURN (s, r)\n                 else RETURN (insert x s, r @ [x])))\n         (PR_CONST (op_ias_empty_sz N), op_marl_empty_sz N) \\<bind>\n        (\\<lambda>(s, r). RETURN r))\n    \\<in> [\\<lambda>l.\n              set l\n              \\<subseteq> {0..<N}]\\<^sub>a (list_assn\n       nat_assn)\\<^sup>k \\<rightarrow> marl_assn N nat_assn", "by sepref"], ["", "concrete_definition (in -) remdup1_fixed uses \"my_remdup_impl_loc.remdup1_fixed.refine_raw\" is \"(?f,_)\\<in>_\""], ["", "prepare_code_thms (in -) remdup1_fixed_def"], ["", "lemmas remdup1_fixed_refine[sepref_fr_rules] = remdup1_fixed.refine[OF my_remdup_impl_loc_this]"], ["", "text \\<open>The @{command concrete_definition} command defines the constant globally, without any locale assumptions. For this,\n    it extracts the definition from the theorem, according to the specified pattern. Note, you have to\n    include the uncurrying into the pattern, e.g., \\<open>(uncurry ?f,_)\\<in>_\\<close>.\n\n    The @{command prepare_code_thms} command sets up code equations for recursion combinators that may have been synthesized. \n    This is required as the code generator works with equation systems, while the heap-monad works with \n    fixed-point combinators.\n    \n    Finally, the third lemma command imports the refinement lemma back into the locale, and registers it\n    as refinement rule for Sepref.\n    \\<close>"], ["", "text \\<open>Now, we can refine @{const remdup} to @{term \"remdup1_fixed N\"} inside the \n    locale. The latter is a global constant with an unconditional definition, thus code\n    can be generated for it.\\<close>"], ["", "text \\<open>Inside the locale, we can do some more refinements: \\<close>"], ["", "definition \"test_remdup \\<equiv> do {l \\<leftarrow> remdup [0..<N]; RETURN (length l) }\""], ["", "text \\<open>Note that the abstract @{const test_remdup} is just an abbreviation for \n    @{term \"my_remdup_impl_loc.test_remdup N\"}.\n    Whenever we want Sepref to treat a compound term like a constant, we have to wrap the term into\n    a @{const PR_CONST} tag. While @{command sepref_register} does this automatically, \n    the \\<open>PR_CONST\\<close> has to occur in the refinement rule.\\<close>"], ["", "sepref_register \"test_remdup\""], ["", "sepref_thm test_remdup1 is \n    \"uncurry0 (PR_CONST test_remdup)\" :: \"unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2, uncurry0 (PR_CONST test_remdup))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "unfolding test_remdup_def PR_CONST_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2,\n     uncurry0 (remdup [0..<N] \\<bind> (\\<lambda>l. RETURN (length l))))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "by sepref"], ["", "concrete_definition (in -) test_remdup1 uses my_remdup_impl_loc.test_remdup1.refine_raw is \"(uncurry0 ?f,_)\\<in>_\""], ["", "prepare_code_thms (in -) test_remdup1_def"], ["", "lemmas test_remdup1_refine[sepref_fr_rules] = test_remdup1.refine[of N]"], ["", "end"], ["", "text \\<open>Outside the locale, a refinement of @{term my_remdup_impl_loc.test_remdup} also makes sense,\n  however, with an extra argument @{term N}.\\<close>"], ["", "thm test_remdup1.refine"], ["", "lemma test_remdup1_refine_aux: \"(test_remdup1, my_remdup_impl_loc.test_remdup) \\<in> [my_remdup_impl_loc]\\<^sub>a nat_assn\\<^sup>k \\<rightarrow> nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (test_remdup1, my_remdup_impl_loc.test_remdup)\n    \\<in> [my_remdup_impl_loc]\\<^sub>a nat_assn\\<^sup>k \\<rightarrow> nat_assn", "using test_remdup1.refine"], ["proof (prove)\nusing this:\n  my_remdup_impl_loc ?N \\<Longrightarrow>\n  (uncurry0 (test_remdup1 ?N),\n   uncurry0 (PR_CONST (my_remdup_impl_loc.test_remdup ?N)))\n  \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\n\ngoal (1 subgoal):\n 1. (test_remdup1, my_remdup_impl_loc.test_remdup)\n    \\<in> [my_remdup_impl_loc]\\<^sub>a nat_assn\\<^sup>k \\<rightarrow> nat_assn", "unfolding hfref_def hn_refine_def"], ["proof (prove)\nusing this:\n  my_remdup_impl_loc ?N \\<Longrightarrow>\n  (uncurry0 (test_remdup1 ?N),\n   uncurry0 (PR_CONST (my_remdup_impl_loc.test_remdup ?N)))\n  \\<in> {(f, g).\n         \\<forall>c a.\n            True \\<longrightarrow>\n            nofail (g a) \\<longrightarrow>\n            <fst (unit_assn\\<^sup>k) a\n              c> f c <\\<lambda>r.\n                         snd (unit_assn\\<^sup>k) a c *\n                         (\\<exists>\\<^sub>Ax.\n                             nat_assn x r *\n                             \\<up> (RETURN x \\<le> g a))>\\<^sub>t}\n\ngoal (1 subgoal):\n 1. (test_remdup1, my_remdup_impl_loc.test_remdup)\n    \\<in> {(f, g).\n           \\<forall>c a.\n              my_remdup_impl_loc a \\<longrightarrow>\n              nofail (g a) \\<longrightarrow>\n              <fst (nat_assn\\<^sup>k) a\n                c> f c <\\<lambda>r.\n                           snd (nat_assn\\<^sup>k) a c *\n                           (\\<exists>\\<^sub>Ax.\n                               nat_assn x r *\n                               \\<up> (RETURN x \\<le> g a))>\\<^sub>t}", "by (auto simp: pure_def)"], ["", "text \\<open>We can also write a more direct precondition, as long as it implies the locale\\<close>"], ["", "lemma test_remdup1_refine: \"(test_remdup1, my_remdup_impl_loc.test_remdup) \\<in> [\\<lambda>N. N>0]\\<^sub>a nat_assn\\<^sup>k \\<rightarrow> nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (test_remdup1, my_remdup_impl_loc.test_remdup)\n    \\<in> [(<) 0]\\<^sub>a nat_assn\\<^sup>k \\<rightarrow> nat_assn", "apply (rule hfref_cons[OF test_remdup1_refine_aux _ entt_refl entt_refl entt_refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. 0 < x \\<Longrightarrow> my_remdup_impl_loc x", "by unfold_locales"], ["", "export_code test_remdup1 checking SML"], ["", "text \\<open>We can also register the abstract constant and the refinement, to use it in further refinements\\<close>"], ["", "sepref_register my_remdup_impl_loc.test_remdup"], ["", "lemmas [sepref_fr_rules] = test_remdup1_refine"], ["", "subsubsection \\<open>Static Data Structures with Custom Element Relations\\<close>"], ["", "text \\<open>In the previous section, we have presented a refinement using an array-list\n  without dynamic resizing. However, the argument that we actually could append \n  to this array was quite complicated.\n\n  Another possibility is to use bounded refinement relations, i.e., \n  a refinement relation intersected with a condition for the abstract object.\n  In our case, @{term \"nbn_assn N\"} relates natural numbers less than \\<open>N\\<close> to themselves.\n\n  We will repeat the above development, using the bounded relation approach:\n\\<close>"], ["", "definition \"bremdup l \\<equiv> do {\n  (s,r) \\<leftarrow> nfoldli l (\\<lambda>_. True) \n    (\\<lambda>x (s,r). do {\n      ASSERT (distinct r \\<and> s = set r); \\<comment> \\<open>Less assertions than last time\\<close>\n      if x\\<in>s then RETURN (s,r) else RETURN (insert x s, r@[x])\n    }) \n    ({},[]);\n  RETURN r\n}\""], ["", "sepref_register bremdup"], ["", "locale my_bremdup_impl_loc = \n  fixes N :: nat \n  assumes \"N>0\" \\<comment> \\<open>This assumption is not necessary, but used to illustrate the \n    general case, where the locale may have such assumptions\\<close>\nbegin"], ["", "lemma my_bremdup_impl_loc_this: \"my_bremdup_impl_loc N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. my_bremdup_impl_loc N", "by unfold_locales"], ["", "sepref_register N"], ["", "lemma N_hnr[sepref_import_param]: \"(N,N)\\<in>nat_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (N, N) \\<in> nat_rel", "by simp"], ["", "text \\<open>Conceptually, what we insert in our list are elements, and\n    these are less than \\<open>N\\<close>.\\<close>"], ["", "abbreviation \"elem_assn \\<equiv> nbn_assn N\""], ["", "lemma aux1[intro]: \"\\<lbrakk> set l \\<subset> {0..<N}; distinct l \\<rbrakk> \\<Longrightarrow> length l < N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set l \\<subset> {0..<N}; distinct l\\<rbrakk>\n    \\<Longrightarrow> length l < N", "apply (simp add: distinct_card[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set l \\<subset> {0..<N}; distinct l\\<rbrakk>\n    \\<Longrightarrow> card (set l) < N", "apply (drule psubset_card_mono[rotated])"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct l \\<Longrightarrow> finite {0..<N}\n 2. \\<lbrakk>distinct l; card (set l) < card {0..<N}\\<rbrakk>\n    \\<Longrightarrow> card (set l) < N", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "sepref_thm remdup1_fixed is \"remdup\" :: \"[\\<lambda>l. set l \\<subseteq> {0..<N}]\\<^sub>a (list_assn elem_assn)\\<^sup>k \\<rightarrow> marl_assn N elem_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, remdup)\n    \\<in> [\\<lambda>l.\n              set l\n              \\<subseteq> {0..<N}]\\<^sub>a (list_assn\n       elem_assn)\\<^sup>k \\<rightarrow> marl_assn N elem_assn", "unfolding remdup_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>l.\n        nfoldli l (\\<lambda>_. True)\n         (\\<lambda>x (s, r).\n             ASSERT\n              (distinct r \\<and>\n               set r \\<subseteq> set l \\<and> s = set r) \\<bind>\n             (\\<lambda>_.\n                 if x \\<in> s then RETURN (s, r)\n                 else RETURN (insert x s, r @ [x])))\n         ({}, []) \\<bind>\n        (\\<lambda>(s, r). RETURN r))\n    \\<in> [\\<lambda>l.\n              set l\n              \\<subseteq> {0..<N}]\\<^sub>a (list_assn\n       elem_assn)\\<^sup>k \\<rightarrow> marl_assn N elem_assn", "apply (rewrite in \"nfoldli _ _ _ \\<hole>\" ias_sz.fold_custom_empty[of N])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>l.\n        nfoldli l (\\<lambda>_. True)\n         (\\<lambda>x (s, r).\n             ASSERT\n              (distinct r \\<and>\n               set r \\<subseteq> set l \\<and> s = set r) \\<bind>\n             (\\<lambda>_.\n                 if x \\<in> s then RETURN (s, r)\n                 else RETURN (insert x s, r @ [x])))\n         (PR_CONST (op_ias_empty_sz N), []) \\<bind>\n        (\\<lambda>(s, r). RETURN r))\n    \\<in> [\\<lambda>l.\n              set l\n              \\<subseteq> {0..<N}]\\<^sub>a (list_assn\n       elem_assn)\\<^sup>k \\<rightarrow> marl_assn N elem_assn", "apply (rewrite in \"nfoldli _ _ _ \\<hole>\" marl_fold_custom_empty_sz[of N])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>l.\n        nfoldli l (\\<lambda>_. True)\n         (\\<lambda>x (s, r).\n             ASSERT\n              (distinct r \\<and>\n               set r \\<subseteq> set l \\<and> s = set r) \\<bind>\n             (\\<lambda>_.\n                 if x \\<in> s then RETURN (s, r)\n                 else RETURN (insert x s, r @ [x])))\n         (PR_CONST (op_ias_empty_sz N), op_marl_empty_sz N) \\<bind>\n        (\\<lambda>(s, r). RETURN r))\n    \\<in> [\\<lambda>l.\n              set l\n              \\<subseteq> {0..<N}]\\<^sub>a (list_assn\n       elem_assn)\\<^sup>k \\<rightarrow> marl_assn N elem_assn", "by sepref"], ["", "concrete_definition (in -) bremdup1_fixed uses \"my_bremdup_impl_loc.remdup1_fixed.refine_raw\" is \"(?f,_)\\<in>_\""], ["", "prepare_code_thms (in -) bremdup1_fixed_def"], ["", "lemmas remdup1_fixed_refine[sepref_fr_rules] = bremdup1_fixed.refine[OF my_bremdup_impl_loc_this]"], ["", "definition \"test_remdup \\<equiv> do {l \\<leftarrow> remdup [0..<N]; RETURN (length l) }\""], ["", "sepref_register \"test_remdup\""], ["", "text \\<open>This refinement depends on the (somewhat experimental) subtyping feature \n    to convert from @{term nat_assn} to @{term elem_assn}, based on context information\\<close>"], ["", "sepref_thm test_remdup1 is \n    \"uncurry0 (PR_CONST test_remdup)\" :: \"unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2, uncurry0 (PR_CONST test_remdup))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "unfolding test_remdup_def PR_CONST_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2,\n     uncurry0 (remdup [0..<N] \\<bind> (\\<lambda>l. RETURN (length l))))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "by sepref"], ["", "concrete_definition (in -) test_bremdup1 uses my_bremdup_impl_loc.test_remdup1.refine_raw is \"(uncurry0 ?f,_)\\<in>_\""], ["", "prepare_code_thms (in -) test_bremdup1_def"], ["", "lemmas test_remdup1_refine[sepref_fr_rules] = test_bremdup1.refine[of N]"], ["", "end"], ["", "lemma test_bremdup1_refine_aux: \"(test_bremdup1, my_bremdup_impl_loc.test_remdup) \\<in> [my_bremdup_impl_loc]\\<^sub>a nat_assn\\<^sup>k \\<rightarrow> nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (test_bremdup1, my_bremdup_impl_loc.test_remdup)\n    \\<in> [my_bremdup_impl_loc]\\<^sub>a nat_assn\\<^sup>k \\<rightarrow> nat_assn", "using test_bremdup1.refine"], ["proof (prove)\nusing this:\n  my_bremdup_impl_loc ?N \\<Longrightarrow>\n  (uncurry0 (test_bremdup1 ?N),\n   uncurry0 (PR_CONST (my_bremdup_impl_loc.test_remdup ?N)))\n  \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\n\ngoal (1 subgoal):\n 1. (test_bremdup1, my_bremdup_impl_loc.test_remdup)\n    \\<in> [my_bremdup_impl_loc]\\<^sub>a nat_assn\\<^sup>k \\<rightarrow> nat_assn", "unfolding hfref_def hn_refine_def"], ["proof (prove)\nusing this:\n  my_bremdup_impl_loc ?N \\<Longrightarrow>\n  (uncurry0 (test_bremdup1 ?N),\n   uncurry0 (PR_CONST (my_bremdup_impl_loc.test_remdup ?N)))\n  \\<in> {(f, g).\n         \\<forall>c a.\n            True \\<longrightarrow>\n            nofail (g a) \\<longrightarrow>\n            <fst (unit_assn\\<^sup>k) a\n              c> f c <\\<lambda>r.\n                         snd (unit_assn\\<^sup>k) a c *\n                         (\\<exists>\\<^sub>Ax.\n                             nat_assn x r *\n                             \\<up> (RETURN x \\<le> g a))>\\<^sub>t}\n\ngoal (1 subgoal):\n 1. (test_bremdup1, my_bremdup_impl_loc.test_remdup)\n    \\<in> {(f, g).\n           \\<forall>c a.\n              my_bremdup_impl_loc a \\<longrightarrow>\n              nofail (g a) \\<longrightarrow>\n              <fst (nat_assn\\<^sup>k) a\n                c> f c <\\<lambda>r.\n                           snd (nat_assn\\<^sup>k) a c *\n                           (\\<exists>\\<^sub>Ax.\n                               nat_assn x r *\n                               \\<up> (RETURN x \\<le> g a))>\\<^sub>t}", "by (auto simp: pure_def)"], ["", "lemma test_bremdup1_refine: \"(test_bremdup1, my_bremdup_impl_loc.test_remdup) \\<in> [\\<lambda>N. N>0]\\<^sub>a nat_assn\\<^sup>k \\<rightarrow> nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (test_bremdup1, my_bremdup_impl_loc.test_remdup)\n    \\<in> [(<) 0]\\<^sub>a nat_assn\\<^sup>k \\<rightarrow> nat_assn", "apply (rule hfref_cons[OF test_bremdup1_refine_aux _ entt_refl entt_refl entt_refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. 0 < x \\<Longrightarrow> my_bremdup_impl_loc x", "by unfold_locales"], ["", "export_code test_bremdup1 checking SML"], ["", "text \\<open>We can also register the abstract constant and the refinement, to use it in further refinements\\<close>"], ["", "sepref_register test_bremdup: my_bremdup_impl_loc.test_remdup \\<comment> \\<open>Specifying a base-name for \n    the theorems here, as default name clashes with existing names.\\<close>"], ["", "lemmas [sepref_fr_rules] = test_bremdup1_refine"], ["", "subsubsection \\<open>Fixed-Value Restriction\\<close>"], ["", "text \\<open>Initialization only works with fixed values, not with dynamically computed values\\<close>"], ["", "sepref_definition copy_list_to_array is \"\\<lambda>l. do {\n  let N = length l; \\<comment> \\<open>Introduce a \\<open>let\\<close>, such that we have a single variable as size-init\\<close>\n  let l' = op_arl_empty_sz N;\n  nfoldli l (\\<lambda>x. True) (\\<lambda>x s. mop_list_append s x) l'\n}\" :: \"(list_assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a arl_assn nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>l.\n        let N = length l\n        in Let (op_arl_empty_sz N)\n            (nfoldli l (\\<lambda>x. True)\n              (\\<lambda>x s. mop_list_append s x)))\n    \\<in> (list_assn\n            nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a arl_assn nat_assn", "apply sepref_dbg_keep"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_refine (hn_ctxt (list_assn nat_assn) x xi) (?c37 x xi)\n        (?\\<Gamma>'5 x xi) (?R5 x xi)\n        ((\\<bind>) $ (RETURN $ (op_list_length $ x)) $\n         (\\<lambda>xa.\n             (#Let $ xa $\n               (\\<lambda>xa.\n                   (#(\\<bind>) $ (RETURN $ PR_CONST (op_arl_empty_sz xa)) $\n                     (\\<lambda>xa.\n                         (#Let $ xa $\n                           (\\<lambda>xa.\n                               (#monadic_nfoldli $ x $\n                                 (\\<lambda>x. (#RETURN $ True#)) $\n                                 (\\<lambda>x.\n                                     (#\\<lambda>xa.\n    (#mop_list_append $ xa $ x#)#)) $\n                                 xa#))#))#))#)))\n 2. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       CNV (?c37 x xi) (?fi4 xi)\n 3. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn nat_assn) x xi\n 4. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (?R5 x xi) a c \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (arl_assn nat_assn) a c\n 5. CONSTRAINT_SLOT (True)", "apply sepref_dbg_trans_keep"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x xi xa x' xb x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ (op_list_length $ x)); xb = xa\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (list_assn nat_assn) x xi *\n                           hn_val nat_rel xb x'a)\n                          (?m'55 x xi x' x'a)\n                          (?\\<Gamma>1.54 x xi xa x' xb x'a)\n                          (?Rh54 x xi xa x' xb x'a)\n                          (RETURN $ PR_CONST (op_arl_empty_sz xb))\n 2. \\<And>x xi xa x' xb x'a xc x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ (op_list_length $ x)); xb = xa;\n        bind_ref_tag xc (RETURN $ PR_CONST (op_arl_empty_sz xb))\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?\\<Gamma>1.54 x xi xa x' xb x'a *\n                           hn_ctxt (?Rh54 x xi xa x' xb x'a) xc x'b)\n                          (?f'56 x xi x' x'a x'b)\n                          (?\\<Gamma>2.54 x xi xa x' xb x'a xc x'b)\n                          (?R5 x xi)\n                          (Let $ xc $\n                           (\\<lambda>xa.\n                               (#monadic_nfoldli $ x $\n                                 (\\<lambda>x. (#RETURN $ True#)) $\n                                 (\\<lambda>x.\n                                     (#\\<lambda>xa.\n    (#mop_list_append $ xa $ x#)#)) $\n                                 xa#)))\n 3. \\<And>x xi xa x' xb x'a xc x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ (op_list_length $ x)); xb = xa\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.54 x xi xa x' xb x'a xc\n                          x'b \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>'44 x xi xa x' xb x'a *\n                         hn_ctxt (?Rx54 x xi xa x' xb x'a) xc x'b\n 4. \\<And>x xi xa x' xb x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ (op_list_length $ x))\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>'44 x xi xa x' xb\n                          x'a \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.44 x xi xa x' *\n                         hn_ctxt (?R'44 x xi xa x') xb x'a\n 5. \\<And>x xi xa x'.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>2.44 x xi xa x' *\n       hn_ctxt (?R'44 x xi xa x') xa x' \\<Longrightarrow>\\<^sub>t\n       ?\\<Gamma>'5 x xi * hn_ctxt (?Rx38 x xi) xa x'\n 6. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       CNV (return $ (op_list_length $ xi) \\<bind>\n            (\\<lambda>x'.\n                let x'a = x'\n                in ?m'55 x xi x' x'a \\<bind> ?f'56 x xi x' x'a))\n        (?fi4 xi)\n 7. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn nat_assn) x xi\n 8. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (?R5 x xi) a c \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (arl_assn nat_assn) a c\n 9. CONSTRAINT_SLOT (True)", "apply sepref_dbg_trans_step_keep"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x xi xa x' xb x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ (op_list_length $ x)); xb = xa;\n        vassn_tag emp\\<rbrakk>\n       \\<Longrightarrow> hn_refine emp (?m'55 x xi x' x'a)\n                          (?\\<Gamma>''58 x xi xa x' xb x'a)\n                          (?Rh54 x xi xa x' xb x'a)\n                          (RETURN $ PR_CONST (op_arl_empty_sz xb))\n 2. \\<And>x xi xa x' xb x'a xc x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ (op_list_length $ x)); xb = xa;\n        bind_ref_tag xc (RETURN $ PR_CONST (op_arl_empty_sz xb))\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_val nat_rel xb x'a *\n                           hn_ctxt (list_assn nat_assn) x xi *\n                           ?\\<Gamma>''58 x xi xa x' xb x'a *\n                           hn_ctxt (?Rh54 x xi xa x' xb x'a) xc x'b)\n                          (?f'56 x xi x' x'a x'b)\n                          (?\\<Gamma>2.54 x xi xa x' xb x'a xc x'b)\n                          (?R5 x xi)\n                          (Let $ xc $\n                           (\\<lambda>xa.\n                               (#monadic_nfoldli $ x $\n                                 (\\<lambda>x. (#RETURN $ True#)) $\n                                 (\\<lambda>x.\n                                     (#\\<lambda>xa.\n    (#mop_list_append $ xa $ x#)#)) $\n                                 xa#)))\n 3. \\<And>x xi xa x' xb x'a xc x'b.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ (op_list_length $ x)); xb = xa\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.54 x xi xa x' xb x'a xc\n                          x'b \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>'44 x xi xa x' xb x'a *\n                         hn_ctxt (?Rx54 x xi xa x' xb x'a) xc x'b\n 4. \\<And>x xi xa x' xb x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ (op_list_length $ x))\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>'44 x xi xa x' xb\n                          x'a \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.44 x xi xa x' *\n                         hn_ctxt (?R'44 x xi xa x') xb x'a\n 5. \\<And>x xi xa x'.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>2.44 x xi xa x' *\n       hn_ctxt (?R'44 x xi xa x') xa x' \\<Longrightarrow>\\<^sub>t\n       ?\\<Gamma>'5 x xi * hn_ctxt (?Rx38 x xi) xa x'\n 6. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       CNV (return $ (op_list_length $ xi) \\<bind>\n            (\\<lambda>x'.\n                let x'a = x'\n                in ?m'55 x xi x' x'a \\<bind> ?f'56 x xi x' x'a))\n        (?fi4 xi)\n 7. \\<And>x xi.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn nat_assn) x xi\n 8. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(nat list) \\<Longrightarrow>\n       hn_ctxt (?R5 x xi) a c \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (arl_assn nat_assn) a c\n 9. CONSTRAINT_SLOT (True)", "supply [[unify_trace_failure, goals_limit=1]]\n  (*apply (rule arl_sz.custom_hnr[to_hnr])*)\n  \\<comment> \\<open>The problem manifests itself in trying to carry an abstract variable \n    (the argument to \\<open>op_arl_empty_sz\\<close>) to the concrete program (the second argument of \\<open>hn_refine\\<close>).\n    However, the concrete program can only depend on the concrete variables, so unification fails.\\<close>"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x xi xa x' xb x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat list);\n        bind_ref_tag xa (RETURN $ (op_list_length $ x)); xb = xa;\n        vassn_tag emp\\<rbrakk>\n       \\<Longrightarrow> hn_refine emp (?m'55 x xi x' x'a)\n                          (?\\<Gamma>''58 x xi xa x' xb x'a)\n                          (?Rh54 x xi xa x' xb x'a)\n                          (RETURN $ PR_CONST (op_arl_empty_sz xb))\nA total of 9 subgoals...", "oops"], ["", "subsubsection \\<open>Matrix Example\\<close>"], ["", "text \\<open>\n  We first give an example for implementing point-wise matrix operations, using\n  some utilities from the (very prototype) matrix library.\n\n  Our matrix library uses functions @{typ \"'a mtx\"} (which is @{typ \"nat\\<times>nat \\<Rightarrow> 'a\"})\n  as the abstract representation. The (currently only) implementation is by arrays,\n  mapping points at coordinates out of range to @{term 0}.\n\\<close>"], ["", "text \\<open>Pointwise unary operations are those that modify every point\n  of a matrix independently. Moreover, a zero-value must be mapped to a zero-value.\n  As an example, we duplicate every value on the diagonal of a matrix\n\\<close>"], ["", "text \\<open>Abstractly, we apply the following function to every value.\n  The first parameter are the coordinates.\\<close>"], ["", "definition mtx_dup_diag_f:: \"nat\\<times>nat \\<Rightarrow> 'a::{numeral,times,mult_zero} \\<Rightarrow> 'a\"\n  where \"mtx_dup_diag_f \\<equiv> \\<lambda>(i,j) x. if i=j then x*(2) else x\""], ["", "text \\<open>We refine this function to a heap-function,\n  using the identity mapping for values.\\<close>"], ["", "context \n  fixes dummy :: \"'a::{numeral,times,mult_zero}\"\n  notes [[sepref_register_adhoc \"PR_CONST (2::'a)\"]]\n    \\<comment> \\<open>Note: The setup for numerals, like \\<open>2\\<close>, is a bit subtle in that\n      numerals are always treated as constants, but have to be registered\n      for any type they shall be used with. By default, they are only \n      registered for @{typ int} and @{typ nat}.\\<close>\n  notes [sepref_import_param] = IdI[of \"PR_CONST (2::'a)\"]\n  notes [sepref_import_param] = IdI[of \"(*)::'a\\<Rightarrow>_\", folded fun_rel_id_simp]\nbegin"], ["", "sepref_definition mtx_dup_diag_f1 is \"uncurry (RETURN oo (mtx_dup_diag_f::_\\<Rightarrow>'a\\<Rightarrow>_))\" :: \"(prod_assn nat_assn nat_assn)\\<^sup>k*\\<^sub>aid_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry (RETURN \\<circ>\\<circ> mtx_dup_diag_f))\n    \\<in> (nat_assn \\<times>\\<^sub>a nat_assn)\\<^sup>k *\\<^sub>a\n          id_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn", "unfolding mtx_dup_diag_f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      ((RETURN \\<circ>\\<circ>\\<circ> case_prod)\n        (\\<lambda>i j x. if i = j then x * (2::'a) else x)))\n    \\<in> (nat_assn \\<times>\\<^sub>a nat_assn)\\<^sup>k *\\<^sub>a\n          id_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn", "by sepref"], ["", "end"], ["", "text \\<open>Then, we instantiate the corresponding locale, to get an implementation for \n  array matrices. Note that we restrict ourselves to square matrices here: \\<close>"], ["", "interpretation dup_diag: amtx_pointwise_unop_impl N N mtx_dup_diag_f id_assn mtx_dup_diag_f1"], ["proof (prove)\ngoal (1 subgoal):\n 1. amtx_pointwise_unop_impl N N mtx_dup_diag_f id_assn mtx_dup_diag_f1", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       N \\<le> i \\<or> N \\<le> j \\<Longrightarrow>\n       mtx_dup_diag_f (i, j) (0::'a) = (0::'a)\n 2. (uncurry mtx_dup_diag_f1,\n     uncurry (RETURN \\<circ>\\<circ> mtx_dup_diag_f))\n    \\<in> (nat_assn \\<times>\\<^sub>a nat_assn)\\<^sup>k *\\<^sub>a\n          id_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn", "applyS (simp add: mtx_dup_diag_f_def) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry mtx_dup_diag_f1,\n     uncurry (RETURN \\<circ>\\<circ> mtx_dup_diag_f))\n    \\<in> (nat_assn \\<times>\\<^sub>a nat_assn)\\<^sup>k *\\<^sub>a\n          id_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn", "applyS (rule mtx_dup_diag_f1.refine)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>We introduce an abbreviation for the abstract operation.\n  Note: We do not have to register it (this is done once and for all \n    for @{const mtx_pointwise_unop}), nor do we have to declare a refinement rule \n    (done by \\<open>amtx_pointwise_unop_impl\\<close>-locale)   \n\\<close>"], ["", "abbreviation \"mtx_dup_diag \\<equiv> mtx_pointwise_unop mtx_dup_diag_f\""], ["", "text \\<open>The operation is usable now:\\<close>"], ["", "sepref_thm mtx_dup_test is \"\\<lambda>m. RETURN (mtx_dup_diag (mtx_dup_diag m))\" :: \"(asmtx_assn N int_assn)\\<^sup>d \\<rightarrow>\\<^sub>a asmtx_assn N int_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, \\<lambda>m. RETURN (mtx_dup_diag (mtx_dup_diag m)))\n    \\<in> (asmtx_assn N\n            int_assn)\\<^sup>d \\<rightarrow>\\<^sub>a asmtx_assn N int_assn", "by sepref"], ["", "text \\<open>Similarly, there are operations to combine to matrices, and to compare two matrices:\\<close>"], ["", "interpretation pw_add: amtx_pointwise_binop_impl N M \"(((+))::(_::monoid_add) \\<Rightarrow> _)\" id_assn \"return oo ((+))\"\n  for N M"], ["proof (prove)\ngoal (1 subgoal):\n 1. amtx_pointwise_binop_impl (+) id_assn (return \\<circ>\\<circ> (+))", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. (0::'a) + (0::'a) = (0::'a)\n 2. (uncurry (return \\<circ>\\<circ> (+)),\n     uncurry (RETURN \\<circ>\\<circ> (+)))\n    \\<in> id_assn\\<^sup>k *\\<^sub>a\n          id_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry (return \\<circ>\\<circ> (+)),\n     uncurry (RETURN \\<circ>\\<circ> (+)))\n    \\<in> id_assn\\<^sup>k *\\<^sub>a\n          id_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn", "apply (sepref_to_hoare)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi a ai.\n       \\<lbrakk>a ::\\<^sub>i TYPE('a); b ::\\<^sub>i TYPE('a);\n        nofail (RETURN (a + b))\\<rbrakk>\n       \\<Longrightarrow> <\\<up> ((bi, b) \\<in> Id) *\n                          \\<up>\n                           ((ai, a)\n                            \\<in> Id)> return\n  (ai +\n   bi) <\\<lambda>r.\n           \\<up> ((bi, b) \\<in> Id) * \\<up> ((ai, a) \\<in> Id) *\n           (\\<exists>\\<^sub>Ax.\n               \\<up> ((r, x) \\<in> Id) *\n               \\<up> (RETURN x \\<le> RETURN (a + b)))>\\<^sub>t", "apply sep_auto \\<comment> \\<open>Alternative to \n    synthesize concrete operation, for simple ad-hoc refinements\\<close>"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "abbreviation \"mtx_add \\<equiv> mtx_pointwise_binop ((+))\""], ["", "sepref_thm mtx_add_test is \"uncurry2 (\\<lambda>m1 m2 m3. RETURN (mtx_add m1 (mtx_add m2 m3)))\" \n  :: \"(amtx_assn N M int_assn)\\<^sup>d *\\<^sub>a (amtx_assn N M int_assn)\\<^sup>d *\\<^sub>a (amtx_assn N M int_assn)\\<^sup>k \\<rightarrow>\\<^sub>a amtx_assn N M int_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2 (\\<lambda>m1 m2 m3. RETURN (mtx_add m1 (mtx_add m2 m3))))\n    \\<in> (amtx_assn N M int_assn)\\<^sup>d *\\<^sub>a\n          (amtx_assn N M int_assn)\\<^sup>d *\\<^sub>a\n          (amtx_assn N M\n            int_assn)\\<^sup>k \\<rightarrow>\\<^sub>a amtx_assn N M int_assn", "by sepref"], ["", "text \\<open>A limitation here is, that the first operand is destroyed on a coarse-grained level.\n  Although adding a matrix to itself would be valid, our tool does not support this.\n  (However, you may use an unary operation)\\<close>"], ["", "sepref_thm mtx_dup_alt_test is \"(\\<lambda>m. RETURN (mtx_add m m))\" \n  :: \"(amtx_assn N M int_assn)\\<^sup>d \\<rightarrow>\\<^sub>a amtx_assn N M int_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, \\<lambda>m. RETURN (mtx_add m m))\n    \\<in> (amtx_assn N M\n            int_assn)\\<^sup>d \\<rightarrow>\\<^sub>a amtx_assn N M int_assn", "apply sepref_dbg_keep"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(int i_mtx) \\<Longrightarrow>\n       hn_refine (hn_ctxt (amtx_assn N M int_assn) x xi) (?c18 x xi)\n        (?\\<Gamma>'5 x xi) (?R5 x xi)\n        ((\\<bind>) $ (RETURN $ (COPY $ x)) $\n         (\\<lambda>v0. (#RETURN $ (PR_CONST mtx_add $ v0 $ x)#)))\n 2. \\<And>x xi.\n       x ::\\<^sub>i TYPE(int i_mtx) \\<Longrightarrow>\n       CNV (?c18 x xi) (?fi4 xi)\n 3. \\<And>x xi.\n       x ::\\<^sub>i TYPE(int i_mtx) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (\\<lambda>_ _. true) x xi\n 4. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(int i_mtx) \\<Longrightarrow>\n       hn_ctxt (?R5 x xi) a c \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (amtx_assn N M int_assn) a c\n 5. CONSTRAINT_SLOT (True)", "apply sepref_dbg_trans_keep\n  \\<comment> \\<open>We get stuck at a @{const COPY} goal, indicating that a matrix has to be copied.\\<close>"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(int i_mtx) \\<Longrightarrow>\n       hn_refine (hn_ctxt (amtx_assn N M int_assn) x xi) (?m'19 x xi)\n        (?\\<Gamma>1.19 x xi) (?Rh19 x xi) (RETURN $ (COPY $ x))\n 2. \\<And>x xi v0 x'.\n       \\<lbrakk>x ::\\<^sub>i TYPE(int i_mtx);\n        bind_ref_tag v0 (RETURN $ (COPY $ x))\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?\\<Gamma>1.19 x xi * hn_ctxt (?Rh19 x xi) v0 x')\n                          (?f'19 x xi x') (?\\<Gamma>2.19 x xi v0 x')\n                          (?R5 x xi) (RETURN $ (PR_CONST mtx_add $ v0 $ x))\n 3. \\<And>x xi v0 x'.\n       x ::\\<^sub>i TYPE(int i_mtx) \\<Longrightarrow>\n       ?\\<Gamma>2.19 x xi v0 x' \\<Longrightarrow>\\<^sub>t\n       ?\\<Gamma>'5 x xi * hn_ctxt (?Rx19 x xi) v0 x'\n 4. \\<And>x xi.\n       x ::\\<^sub>i TYPE(int i_mtx) \\<Longrightarrow>\n       CNV (?m'19 x xi \\<bind> ?f'19 x xi) (?fi4 xi)\n 5. \\<And>x xi.\n       x ::\\<^sub>i TYPE(int i_mtx) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (\\<lambda>_ _. true) x xi\n 6. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(int i_mtx) \\<Longrightarrow>\n       hn_ctxt (?R5 x xi) a c \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (amtx_assn N M int_assn) a c\n 7. CONSTRAINT_SLOT (True)", "apply sepref_dbg_trans_step_keep\n  \\<comment> \\<open>Which only works for pure refinements\\<close>"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x xi.\n       \\<lbrakk>x ::\\<^sub>i TYPE(int i_mtx);\n        vassn_tag (hn_ctxt (amtx_assn N M int_assn) x xi)\\<rbrakk>\n       \\<Longrightarrow> CONSTRAINT is_pure (amtx_assn N M int_assn)\n 2. \\<And>x xi v0 x'.\n       \\<lbrakk>x ::\\<^sub>i TYPE(int i_mtx);\n        bind_ref_tag v0 (RETURN $ (COPY $ x))\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (emp * hn_ctxt (amtx_assn N M int_assn) x xi *\n                           hn_ctxt (amtx_assn N M int_assn) v0 x')\n                          (?f'19 x xi x') (?\\<Gamma>2.19 x xi v0 x')\n                          (?R5 x xi) (RETURN $ (PR_CONST mtx_add $ v0 $ x))\n 3. \\<And>x xi v0 x'.\n       x ::\\<^sub>i TYPE(int i_mtx) \\<Longrightarrow>\n       ?\\<Gamma>2.19 x xi v0 x' \\<Longrightarrow>\\<^sub>t\n       ?\\<Gamma>'5 x xi * hn_ctxt (?Rx19 x xi) v0 x'\n 4. \\<And>x xi.\n       x ::\\<^sub>i TYPE(int i_mtx) \\<Longrightarrow>\n       CNV (return $ xi \\<bind> ?f'19 x xi) (?fi4 xi)\n 5. \\<And>x xi.\n       x ::\\<^sub>i TYPE(int i_mtx) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (\\<lambda>_ _. true) x xi\n 6. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(int i_mtx) \\<Longrightarrow>\n       hn_ctxt (?R5 x xi) a c \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (amtx_assn N M int_assn) a c\n 7. CONSTRAINT_SLOT (True)", "oops"], ["", "text \\<open>Of course, you can always copy the matrix manually:\\<close>"], ["", "sepref_thm mtx_dup_alt_test is \"(\\<lambda>m. RETURN (mtx_add (op_mtx_copy m) m))\" \n  :: \"(amtx_assn N M int_assn)\\<^sup>k \\<rightarrow>\\<^sub>a amtx_assn N M int_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, \\<lambda>m. RETURN (mtx_add (op_mtx_copy m) m))\n    \\<in> (amtx_assn N M\n            int_assn)\\<^sup>k \\<rightarrow>\\<^sub>a amtx_assn N M int_assn", "by sepref"], ["", "text \\<open>A compare operation checks that all pairs of entries fulfill some property \\<open>f\\<close>, and\n  at least one entry fullfills a property \\<open>g\\<close>.\\<close>"], ["", "interpretation pw_lt: amtx_pointwise_cmpop_impl N M \"((\\<le>)::(_::order) \\<Rightarrow> _)\" \"((\\<noteq>)::(_::order) \\<Rightarrow> _)\" id_assn \"return oo (\\<le>)\" \"return oo (\\<noteq>)\"\n  for N M"], ["proof (prove)\ngoal (1 subgoal):\n 1. amtx_pointwise_cmpop_impl (\\<le>) (\\<noteq>) id_assn\n     (return \\<circ>\\<circ> (\\<le>)) (return \\<circ>\\<circ> (\\<noteq>))", "apply standard"], ["proof (prove)\ngoal (4 subgoals):\n 1. ((0::'a) \\<le> (0::'a)) = True\n 2. ((0::'a) \\<noteq> (0::'a)) = False\n 3. (uncurry (return \\<circ>\\<circ> (\\<le>)),\n     uncurry (RETURN \\<circ>\\<circ> (\\<le>)))\n    \\<in> id_assn\\<^sup>k *\\<^sub>a\n          id_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\n 4. (uncurry (return \\<circ>\\<circ> (\\<noteq>)),\n     uncurry (RETURN \\<circ>\\<circ> (\\<noteq>)))\n    \\<in> id_assn\\<^sup>k *\\<^sub>a\n          id_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. ((0::'a) \\<noteq> (0::'a)) = False\n 2. (uncurry (return \\<circ>\\<circ> (\\<le>)),\n     uncurry (RETURN \\<circ>\\<circ> (\\<le>)))\n    \\<in> id_assn\\<^sup>k *\\<^sub>a\n          id_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\n 3. (uncurry (return \\<circ>\\<circ> (\\<noteq>)),\n     uncurry (RETURN \\<circ>\\<circ> (\\<noteq>)))\n    \\<in> id_assn\\<^sup>k *\\<^sub>a\n          id_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. (uncurry (return \\<circ>\\<circ> (\\<le>)),\n     uncurry (RETURN \\<circ>\\<circ> (\\<le>)))\n    \\<in> id_assn\\<^sup>k *\\<^sub>a\n          id_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\n 2. (uncurry (return \\<circ>\\<circ> (\\<noteq>)),\n     uncurry (RETURN \\<circ>\\<circ> (\\<noteq>)))\n    \\<in> id_assn\\<^sup>k *\\<^sub>a\n          id_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "apply (sepref_to_hoare)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b bi a ai.\n       \\<lbrakk>a ::\\<^sub>i TYPE('a); b ::\\<^sub>i TYPE('a);\n        nofail (RETURN (a \\<le> b))\\<rbrakk>\n       \\<Longrightarrow> <\\<up> ((bi, b) \\<in> Id) *\n                          \\<up>\n                           ((ai, a)\n                            \\<in> Id)> return\n  (ai \\<le> bi) <\\<lambda>r.\n                    \\<up> ((bi, b) \\<in> Id) * \\<up> ((ai, a) \\<in> Id) *\n                    (\\<exists>\\<^sub>Ax.\n                        \\<up> ((r, x) \\<in> bool_rel) *\n                        \\<up> (RETURN x \\<le> RETURN (a \\<le> b)))>\\<^sub>t\n 2. (uncurry (return \\<circ>\\<circ> (\\<noteq>)),\n     uncurry (RETURN \\<circ>\\<circ> (\\<noteq>)))\n    \\<in> id_assn\\<^sup>k *\\<^sub>a\n          id_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "apply sep_auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry (return \\<circ>\\<circ> (\\<noteq>)),\n     uncurry (RETURN \\<circ>\\<circ> (\\<noteq>)))\n    \\<in> id_assn\\<^sup>k *\\<^sub>a\n          id_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "apply (sepref_to_hoare)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi a ai.\n       \\<lbrakk>a ::\\<^sub>i TYPE('a); b ::\\<^sub>i TYPE('a);\n        nofail (RETURN (a \\<noteq> b))\\<rbrakk>\n       \\<Longrightarrow> <\\<up> ((bi, b) \\<in> Id) *\n                          \\<up>\n                           ((ai, a)\n                            \\<in> Id)> return\n  (ai \\<noteq>\n   bi) <\\<lambda>r.\n           \\<up> ((bi, b) \\<in> Id) * \\<up> ((ai, a) \\<in> Id) *\n           (\\<exists>\\<^sub>Ax.\n               \\<up> ((r, x) \\<in> bool_rel) *\n               \\<up> (RETURN x \\<le> RETURN (a \\<noteq> b)))>\\<^sub>t", "apply sep_auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "abbreviation \"mtx_lt \\<equiv> mtx_pointwise_cmpop (\\<le>) (\\<noteq>)\""], ["", "sepref_thm test_mtx_cmp is \"(\\<lambda>m. do { RETURN (mtx_lt (op_amtx_dfltNxM N M 0) m) })\" :: \"(amtx_assn N M int_assn)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, \\<lambda>m. RETURN (mtx_lt (op_amtx_dfltNxM N M 0) m))\n    \\<in> (amtx_assn N M int_assn)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "by sepref \\<comment> \\<open>Note: Better fold over single matrix (currently no locale for that), instead of creating a new matrix.\\<close>"], ["", "text \\<open>In a final example, we store some coordinates in a set, and then\n  use the stored coordinates to access the matrix again. This illustrates how \n  bounded relations can be used to maintain extra information, i.e., coordinates \n  being in range\\<close>"], ["", "context\n  fixes N M :: nat\n  notes [[sepref_register_adhoc N M]]\n  notes [sepref_import_param] = IdI[of N] IdI[of M]\nbegin"], ["", "text \\<open>We introduce an assertion for coordinates\\<close>"], ["", "abbreviation \"co_assn \\<equiv> prod_assn (nbn_assn N) (nbn_assn M)\""], ["", "text \\<open>And one for integer matrices\\<close>"], ["", "abbreviation \"mtx_assn \\<equiv> amtx_assn N M int_assn\""], ["", "definition \"co_set_gen \\<equiv> do {\n    nfoldli [0..<N] (\\<lambda>_. True) (\\<lambda>i. nfoldli [0..<M] (\\<lambda>_. True) (\\<lambda>j s. \n      if max i j - min i j \\<le> 1 then RETURN (insert (i,j) s)\n      else RETURN s\n    )) {}\n  }\""], ["", "sepref_definition co_set_gen1 is \"uncurry0 co_set_gen\" :: \"unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a hs.assn co_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2, uncurry0 local.co_set_gen)\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a hs.assn local.co_assn", "unfolding co_set_gen_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2,\n     uncurry0\n      (nfoldli [0..<N] (\\<lambda>_. True)\n        (\\<lambda>i.\n            nfoldli [0..<M] (\\<lambda>_. True)\n             (\\<lambda>j s.\n                 if max i j - min i j \\<le> 1 then RETURN (insert (i, j) s)\n                 else RETURN s))\n        {}))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a hs.assn local.co_assn", "apply (rewrite \"hs.fold_custom_empty\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2,\n     uncurry0\n      (nfoldli [0..<N] (\\<lambda>_. True)\n        (\\<lambda>i.\n            nfoldli [0..<M] (\\<lambda>_. True)\n             (\\<lambda>j s.\n                 if max i j - min i j \\<le> 1 then RETURN (insert (i, j) s)\n                 else RETURN s))\n        op_hs_empty))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a hs.assn local.co_assn", "apply sepref_dbg_keep"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow>\n       hn_ctxt (hs.assn (nat_assn \\<times>\\<^sub>a nat_assn)) a\n        c \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (hs.assn local.co_assn) a c\n 2. CONSTRAINT_SLOT (True)", "apply sepref_dbg_trans_keep\n    \\<comment> \\<open>We run into the problem that the Sepref tool uses \\<open>nat_assn\\<close> to refine natural\n      numbers, and only later tries to convert it to \\<open>nbn_assn\\<close>. However, at this point, the\n      information is already lost.\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(unit) \\<Longrightarrow>\n       hn_ctxt (hs.assn (nat_assn \\<times>\\<^sub>a nat_assn)) a\n        c \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (hs.assn local.co_assn) a c\n 2. CONSTRAINT_SLOT (True)", "oops"], ["", "text \\<open>We can use a feature of Sepref, to annotate the desired assertion directly \n    into the abstract program. For this, we use @{thm [source] annotate_assn}, \n    which inserts the (special) constant @{const ASSN_ANNOT}, which is just identity, \n    but enforces refinement with the given assertion.\\<close>"], ["", "sepref_definition co_set_gen1 is \"uncurry0 (PR_CONST co_set_gen)\" :: \"unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a hs.assn co_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2, uncurry0 (PR_CONST local.co_set_gen))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a hs.assn local.co_assn", "unfolding co_set_gen_def PR_CONST_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2,\n     uncurry0\n      (nfoldli [0..<N] (\\<lambda>_. True)\n        (\\<lambda>i.\n            nfoldli [0..<M] (\\<lambda>_. True)\n             (\\<lambda>j s.\n                 if max i j - min i j \\<le> 1 then RETURN (insert (i, j) s)\n                 else RETURN s))\n        {}))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a hs.assn local.co_assn", "apply (rewrite \"hs.fold_custom_empty\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2,\n     uncurry0\n      (nfoldli [0..<N] (\\<lambda>_. True)\n        (\\<lambda>i.\n            nfoldli [0..<M] (\\<lambda>_. True)\n             (\\<lambda>j s.\n                 if max i j - min i j \\<le> 1 then RETURN (insert (i, j) s)\n                 else RETURN s))\n        op_hs_empty))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a hs.assn local.co_assn", "apply (rewrite in \"insert \\<hole> _\" annotate_assn[where A=co_assn])\n      \\<comment> \\<open>Annotate the pair as coordinate before insertion\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2,\n     uncurry0\n      (nfoldli [0..<N] (\\<lambda>_. True)\n        (\\<lambda>i.\n            nfoldli [0..<M] (\\<lambda>_. True)\n             (\\<lambda>j s.\n                 if max i j - min i j \\<le> 1\n                 then RETURN (insert (ASSN_ANNOT local.co_assn (i, j)) s)\n                 else RETURN s))\n        op_hs_empty))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a hs.assn local.co_assn", "by sepref"], ["", "lemmas [sepref_fr_rules] = co_set_gen1.refine"], ["", "sepref_register \"co_set_gen\""], ["", "text \\<open>Now we can use the entries from the set as coordinates, \n    without any worries about them being out of range\\<close>"], ["", "sepref_thm co_set_use is \"(\\<lambda>m. do {\n    co \\<leftarrow> co_set_gen;\n    FOREACH co (\\<lambda>(i,j) m. RETURN ( m((i,j) := 1))) m\n  })\" :: \"mtx_assn\\<^sup>d \\<rightarrow>\\<^sub>a mtx_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>m.\n        local.co_set_gen \\<bind>\n        (\\<lambda>co.\n            FOREACH co (\\<lambda>(i, j) m. RETURN (m((i, j) := 1))) m))\n    \\<in> local.mtx_assn\\<^sup>d \\<rightarrow>\\<^sub>a local.mtx_assn", "by sepref"], ["", "end"], ["", "subsection \\<open>Type Classes\\<close>"], ["", "text \\<open>TBD\\<close>"], ["", "subsection \\<open>Higher-Order\\<close>"], ["", "text \\<open>TBD\\<close>"], ["", "subsection \\<open>A-Posteriori Optimizations\\<close>"], ["", "text \\<open>The theorem collection @{attribute sepref_opt_simps}\n  and @{attribute sepref_opt_simps2} contain simplifier lemmas that are\n  applied, in two stages, to the generated Imperative/HOL program.\n\n  This is the place where some optimizations, such as deforestation, and\n  simplifying monad-expressions using the monad laws, take place.\n\\<close>"], ["", "thm sepref_opt_simps"], ["", "thm sepref_opt_simps2"], ["", "subsection \\<open>Short-Circuit Evaluation\\<close>"], ["", "text \\<open>Consider\\<close>"], ["", "sepref_thm test_sc_eval is \"RETURN o (\\<lambda>l. length l > 0 \\<and> hd l)\" :: \"(list_assn bool_assn)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, RETURN \\<circ> (\\<lambda>l. 0 < length l \\<and> hd l))\n    \\<in> (list_assn bool_assn)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "apply sepref_dbg_keep"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x xi.\n       x ::\\<^sub>i TYPE(bool list) \\<Longrightarrow>\n       hn_refine (hn_ctxt (list_assn bool_assn) x xi) (?c28 x xi)\n        (?\\<Gamma>'5 x xi) (?R5 x xi)\n        ((\\<bind>) $\n         ((\\<bind>) $ (RETURN $ 0) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $ (RETURN $ (op_list_length $ x)) $\n                (\\<lambda>v1. (#RETURN $ ((<) $ v0 $ v1)#))#))) $\n         (\\<lambda>v0.\n             (#(\\<bind>) $ (RETURN $ (op_list_hd $ x)) $\n               (\\<lambda>v1. (#RETURN $ ((\\<and>) $ v0 $ v1)#))#)))\n 2. \\<And>x xi.\n       x ::\\<^sub>i TYPE(bool list) \\<Longrightarrow>\n       CNV (?c28 x xi) (?fi4 xi)\n 3. \\<And>x xi.\n       x ::\\<^sub>i TYPE(bool list) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn bool_assn) x xi\n 4. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(bool list) \\<Longrightarrow>\n       hn_ctxt (?R5 x xi) a c \\<Longrightarrow>\\<^sub>t hn_val bool_rel a c\n 5. CONSTRAINT_SLOT (True)", "apply sepref_dbg_trans_keep"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x xi v0 x'.\n       \\<lbrakk>x ::\\<^sub>i TYPE(bool list);\n        bind_ref_tag v0\n         ((\\<bind>) $ (RETURN $ 0) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $ (RETURN $ (op_list_length $ x)) $\n                (\\<lambda>v1. (#RETURN $ ((<) $ v0 $ v1)#))#)))\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (list_assn bool_assn) x xi *\n                           hn_val bool_rel v0 x')\n                          (?m'72 x xi x') (?\\<Gamma>1.71 x xi v0 x')\n                          (?Rh71 x xi v0 x') (RETURN $ (op_list_hd $ x))\n 2. \\<And>x xi v0 x' v1 x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(bool list);\n        bind_ref_tag v0\n         ((\\<bind>) $ (RETURN $ 0) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $ (RETURN $ (op_list_length $ x)) $\n                (\\<lambda>v1. (#RETURN $ ((<) $ v0 $ v1)#))#)));\n        bind_ref_tag v1 (RETURN $ (op_list_hd $ x))\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?\\<Gamma>1.71 x xi v0 x' *\n                           hn_ctxt (?Rh71 x xi v0 x') v1 x'a)\n                          (?f'73 x xi x' x'a)\n                          (?\\<Gamma>2.71 x xi v0 x' v1 x'a) (?R5 x xi)\n                          (RETURN $ ((\\<and>) $ v0 $ v1))\n 3. \\<And>x xi v0 x' v1 x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(bool list);\n        bind_ref_tag v0\n         ((\\<bind>) $ (RETURN $ 0) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $ (RETURN $ (op_list_length $ x)) $\n                (\\<lambda>v1. (#RETURN $ ((<) $ v0 $ v1)#))#)))\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.71 x xi v0 x' v1\n                          x'a \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.29 x xi v0 x' *\n                         hn_ctxt (?Rx71 x xi v0 x') v1 x'a\n 4. \\<And>x xi v0 x'.\n       x ::\\<^sub>i TYPE(bool list) \\<Longrightarrow>\n       ?\\<Gamma>2.29 x xi v0 x' \\<Longrightarrow>\\<^sub>t\n       ?\\<Gamma>'5 x xi * hn_ctxt (?Rx29 x xi) v0 x'\n 5. \\<And>x xi.\n       x ::\\<^sub>i TYPE(bool list) \\<Longrightarrow>\n       CNV (return 0 \\<bind>\n            (\\<lambda>x'.\n                return $ (op_list_length $ xi) \\<bind>\n                (\\<lambda>x'a. return (x' < x'a))) \\<bind>\n            (\\<lambda>x'. ?m'72 x xi x' \\<bind> ?f'73 x xi x'))\n        (?fi4 xi)\n 6. \\<And>x xi.\n       x ::\\<^sub>i TYPE(bool list) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn bool_assn) x xi\n 7. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(bool list) \\<Longrightarrow>\n       hn_ctxt (?R5 x xi) a c \\<Longrightarrow>\\<^sub>t hn_val bool_rel a c\n 8. CONSTRAINT_SLOT (True)", "apply sepref_dbg_trans_step_keep\n  \\<comment> \\<open>Got stuck, as the operands of \\<open>\\<and>\\<close> are evaluated before applying the operator, i.e.,\n    \\<open>hd\\<close> is also applied to empty lists\\<close>"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x xi v0 x'.\n       \\<lbrakk>x ::\\<^sub>i TYPE(bool list);\n        bind_ref_tag v0\n         ((\\<bind>) $ (RETURN $ 0) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $ (RETURN $ (op_list_length $ x)) $\n                (\\<lambda>v1. (#RETURN $ ((<) $ v0 $ v1)#))#)));\n        vassn_tag (hn_ctxt (list_assn bool_assn) x xi)\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> []\n 2. \\<And>x xi v0 x' v1 x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(bool list);\n        bind_ref_tag v0\n         ((\\<bind>) $ (RETURN $ 0) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $ (RETURN $ (op_list_length $ x)) $\n                (\\<lambda>v1. (#RETURN $ ((<) $ v0 $ v1)#))#)));\n        bind_ref_tag v1 (RETURN $ (op_list_hd $ x))\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_val bool_rel v0 x' *\n                           hn_invalid (list_assn bool_assn) x xi *\n                           hn_val bool_rel v1 x'a)\n                          (?f'73 x xi x' x'a)\n                          (?\\<Gamma>2.71 x xi v0 x' v1 x'a) (?R5 x xi)\n                          (RETURN $ ((\\<and>) $ v0 $ v1))\n 3. \\<And>x xi v0 x' v1 x'a.\n       \\<lbrakk>x ::\\<^sub>i TYPE(bool list);\n        bind_ref_tag v0\n         ((\\<bind>) $ (RETURN $ 0) $\n          (\\<lambda>v0.\n              (#(\\<bind>) $ (RETURN $ (op_list_length $ x)) $\n                (\\<lambda>v1. (#RETURN $ ((<) $ v0 $ v1)#))#)))\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.71 x xi v0 x' v1\n                          x'a \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.29 x xi v0 x' *\n                         hn_ctxt (?Rx71 x xi v0 x') v1 x'a\n 4. \\<And>x xi v0 x'.\n       x ::\\<^sub>i TYPE(bool list) \\<Longrightarrow>\n       ?\\<Gamma>2.29 x xi v0 x' \\<Longrightarrow>\\<^sub>t\n       ?\\<Gamma>'5 x xi * hn_ctxt (?Rx29 x xi) v0 x'\n 5. \\<And>x xi.\n       x ::\\<^sub>i TYPE(bool list) \\<Longrightarrow>\n       CNV (return 0 \\<bind>\n            (\\<lambda>x'.\n                return $ (op_list_length $ xi) \\<bind>\n                (\\<lambda>x'a. return (x' < x'a))) \\<bind>\n            (\\<lambda>x'. return $ (op_list_hd $ xi) \\<bind> ?f'73 x xi x'))\n        (?fi4 xi)\n 6. \\<And>x xi.\n       x ::\\<^sub>i TYPE(bool list) \\<Longrightarrow>\n       ?\\<Gamma>'5 x xi \\<Longrightarrow>\\<^sub>t\n       hn_ctxt (list_assn bool_assn) x xi\n 7. \\<And>x xi a c.\n       x ::\\<^sub>i TYPE(bool list) \\<Longrightarrow>\n       hn_ctxt (?R5 x xi) a c \\<Longrightarrow>\\<^sub>t hn_val bool_rel a c\n 8. CONSTRAINT_SLOT (True)", "oops"], ["", "sepref_thm test_sc_eval is \"RETURN o (\\<lambda>l. length l > 0 \\<and> hd l)\" :: \"(list_assn bool_assn)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, RETURN \\<circ> (\\<lambda>l. 0 < length l \\<and> hd l))\n    \\<in> (list_assn bool_assn)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "unfolding short_circuit_conv \\<comment> \\<open>Enables short-circuit evaluation \n    by rewriting \\<open>\\<and>\\<close>, \\<open>\\<or>\\<close>, and \\<open>\\<longrightarrow>\\<close> to \\<open>if\\<close>-expressions\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     RETURN \\<circ> (\\<lambda>l. if 0 < length l then hd l else False))\n    \\<in> (list_assn bool_assn)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "by sepref"], ["", "end"]]}