{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/Examples/Sepref_Dijkstra.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemma infty_assn_pure_conv: \"infty_assn (pure A) = pure (\\<langle>A\\<rangle>infty_rel)\"", "lemmas [sepref_import_rewrite, fcomp_norm_unfold, sepref_frame_normrel_eqs] =\n  infty_assn_pure_conv[symmetric]", "lemmas [constraint_simps] = infty_assn_pure_conv", "lemma infty_assn_pure[safe_constraint_rules]: \"is_pure A \\<Longrightarrow> is_pure (infty_assn A)\"", "lemma infty_assn_id[simp]: \"infty_assn id_assn = id_assn\"", "lemma [safe_constraint_rules]: \"IS_BELOW_ID R \\<Longrightarrow> IS_BELOW_ID (\\<langle>R\\<rangle>infty_rel)\"", "lemma Num_hnr[sepref_fr_rules]: \"(return o Num,RETURN o Num)\\<in>A\\<^sup>d \\<rightarrow>\\<^sub>a infty_assn A\"", "lemma Infty_hnr[sepref_fr_rules]: \"(uncurry0 (return Infty),uncurry0 (RETURN Infty))\\<in>unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a infty_assn A\"", "lemma [sepref_monadify_arity]: \"case_infty \\<equiv> \\<lambda>\\<^sub>2f1 f2 x. SP case_infty$f1$(\\<lambda>\\<^sub>2x. f2$x)$x\"", "lemma [sepref_monadify_comb]: \"case_infty$f1$f2$x \\<equiv> (\\<bind>)$(EVAL$x)$(\\<lambda>\\<^sub>2x. SP case_infty$f1$f2$x)\"", "lemma [sepref_monadify_comb]: \"EVAL$(case_infty$f1$(\\<lambda>\\<^sub>2x. f2 x)$x) \n  \\<equiv> (\\<bind>)$(EVAL$x)$(\\<lambda>\\<^sub>2x. SP case_infty$(EVAL $ f1)$(\\<lambda>\\<^sub>2x. EVAL $ f2 x)$x)\"", "lemma infty_assn_ctxt: \"infty_assn A x y = z \\<Longrightarrow> hn_ctxt (infty_assn A) x y = z\"", "lemma infty_cases_hnr[sepref_prep_comb_rule, sepref_comb_rules]:\n  fixes A e e'\n  defines [simp]: \"INVe \\<equiv> hn_invalid (infty_assn A) e e'\"\n  assumes FR: \"\\<Gamma> \\<Longrightarrow>\\<^sub>t hn_ctxt (infty_assn A) e e' * F\"\n  assumes Infty: \"\\<lbrakk>e = Infty; e' = Infty\\<rbrakk> \\<Longrightarrow> hn_refine (hn_ctxt (infty_assn A) e e' * F) f1' (hn_ctxt XX1 e e' * \\<Gamma>1') R f1\"\n  assumes Num: \"\\<And>x1 x1a. \\<lbrakk>e = Num x1; e' = Num x1a\\<rbrakk> \\<Longrightarrow> hn_refine (hn_ctxt A x1 x1a * INVe * F) (f2' x1a) (hn_ctxt A' x1 x1a * hn_ctxt XX2 e e' * \\<Gamma>2') R (f2 x1)\"\n  assumes MERGE2[unfolded hn_ctxt_def]: \"\\<Gamma>1' \\<or>\\<^sub>A \\<Gamma>2' \\<Longrightarrow>\\<^sub>t \\<Gamma>'\"\n  shows \"hn_refine \\<Gamma> (case_infty f1' f2' e') (hn_ctxt (infty_assn A') e e' * \\<Gamma>') R (case_infty$f1$(\\<lambda>\\<^sub>2x. f2 x)$e)\"", "lemma hnr_val[sepref_fr_rules]: \"(return o Weight.val,RETURN o Weight.val) \\<in> [\\<lambda>x. x\\<noteq>Infty]\\<^sub>a (infty_assn A)\\<^sup>d \\<rightarrow> A\"", "lemmas [sepref_fr_rules] = infty_plus_impl.refine", "lemma infty_less_param[param]:\n  \"(infty_less,infty_less) \\<in> (R\\<rightarrow>R\\<rightarrow>bool_rel) \\<rightarrow> \\<langle>R\\<rangle>infty_rel \\<rightarrow> \\<langle>R\\<rangle>infty_rel \\<rightarrow> bool_rel\"", "lemma infty_less_eq_less: \"infty_less (<) = (<)\"", "lemmas [sepref_fr_rules] = infty_less_impl.refine", "lemma param_mpath': \"(mpath',mpath')\n  \\<in> \\<langle>\\<langle>A\\<times>\\<^sub>r B \\<times>\\<^sub>r A\\<rangle>list_rel \\<times>\\<^sub>r B\\<rangle>option_rel \\<rightarrow> \\<langle>\\<langle>A\\<times>\\<^sub>r B \\<times>\\<^sub>r A\\<rangle>list_rel\\<rangle>option_rel\"", "lemmas (in -) [sepref_import_param] = param_mpath'", "lemma param_mpath_weight': \n  \"(mpath_weight', mpath_weight') \\<in> \\<langle>\\<langle>A\\<times>\\<^sub>rB\\<times>\\<^sub>rA\\<rangle>list_rel \\<times>\\<^sub>r B\\<rangle>option_rel \\<rightarrow> \\<langle>B\\<rangle>infty_rel\"", "lemmas [sepref_import_param] = param_mpath_weight'", "lemmas impl_aux = mdijkstra_def[unfolded mdinit_def mpop_min_def mupdate_def]", "lemma mdijkstra_correct:  \n    \"(mdijkstra, SPEC (is_shortest_path_map v0)) \\<in> \\<langle>br \\<alpha>r res_invarm\\<rangle>nres_rel\"", "lemmas [sepref_import_param] = \n    IdI[of \"0::'W\"]", "lemma w_plus_param: \"((+), (+)::'W\\<Rightarrow>_) \\<in> Id \\<rightarrow> Id \\<rightarrow> Id\"", "lemma w_less_param: \"((<), (<)::'W\\<Rightarrow>_) \\<in> Id \\<rightarrow> Id \\<rightarrow> Id\"", "lemmas [sepref_import_param] = w_plus_param w_less_param", "lemma [sepref_gen_algo_rules]: \n    \"GEN_ALGO (return oo (+)) (\\<lambda>f. (uncurry f, uncurry (RETURN \\<circ>\\<circ> (+))) \\<in> id_assn\\<^sup>k *\\<^sub>a id_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn)\"\n    \"GEN_ALGO (return oo (<)) (\\<lambda>f. (uncurry f, uncurry (RETURN \\<circ>\\<circ> (<))) \\<in> id_assn\\<^sup>k *\\<^sub>a id_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn)\"", "lemma conv_prio_pop_min: \"prio_pop_min m = do {\n      ASSERT (dom m \\<noteq> {}); \n      ((k,v),m) \\<leftarrow> mop_pm_pop_min id m;\n      RETURN (k,v,m)\n    }\"", "lemma mdijkstra'_aref: \"(uncurry mdijkstra',uncurry (SPEC oo weighted_graph.is_shortest_path_map))\n  \\<in> [\\<lambda>(G,v0). Dijkstra G v0]\\<^sub>f Id\\<times>\\<^sub>rId \\<rightarrow> \\<langle>br Dijkstra.\\<alpha>r Dijkstra.res_invarm\\<rangle>nres_rel\"", "theorem dijkstra_imp_correct: \"(uncurry (dijkstra_imp N), uncurry (SPEC \\<circ>\\<circ> weighted_graph.is_shortest_path_map))\n  \\<in> [\\<lambda>(G, v0). v0 \\<in> nodes G \\<and> (\\<forall>(v, w, v') \\<in> edges G. 0 \\<le> w)]\\<^sub>a (is_graph N Id)\\<^sup>k *\\<^sub>a (node_assn N)\\<^sup>k \\<rightarrow> drmap_assn N\""], "translations": [["", "lemma infty_assn_pure_conv: \"infty_assn (pure A) = pure (\\<langle>A\\<rangle>infty_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infty_assn (pure A) = pure (\\<langle>A\\<rangle>infty_rel)", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       infty_assn (pure A) x xa = pure (\\<langle>A\\<rangle>infty_rel) x xa", "subgoal for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. infty_assn (pure A) x y = pure (\\<langle>A\\<rangle>infty_rel) x y", "by (cases x; cases y; simp add: pure_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas [sepref_import_rewrite, fcomp_norm_unfold, sepref_frame_normrel_eqs] =\n  infty_assn_pure_conv[symmetric]"], ["", "lemmas [constraint_simps] = infty_assn_pure_conv"], ["", "lemma infty_assn_pure[safe_constraint_rules]: \"is_pure A \\<Longrightarrow> is_pure (infty_assn A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pure A \\<Longrightarrow> is_pure (infty_assn A)", "by (auto simp: is_pure_conv infty_assn_pure_conv)"], ["", "lemma infty_assn_id[simp]: \"infty_assn id_assn = id_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infty_assn id_assn = id_assn", "by (simp add: infty_assn_pure_conv)"], ["", "lemma [safe_constraint_rules]: \"IS_BELOW_ID R \\<Longrightarrow> IS_BELOW_ID (\\<langle>R\\<rangle>infty_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IS_BELOW_ID R \\<Longrightarrow>\n    IS_BELOW_ID (\\<langle>R\\<rangle>infty_rel)", "by (auto simp: infty_rel_def IS_BELOW_ID_def)"], ["", "sepref_register Num Infty"], ["", "lemma Num_hnr[sepref_fr_rules]: \"(return o Num,RETURN o Num)\\<in>A\\<^sup>d \\<rightarrow>\\<^sub>a infty_assn A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (return \\<circ> Num, RETURN \\<circ> Num)\n    \\<in> A\\<^sup>d \\<rightarrow>\\<^sub>a infty_assn A", "by sepref_to_hoare sep_auto"], ["", "lemma Infty_hnr[sepref_fr_rules]: \"(uncurry0 (return Infty),uncurry0 (RETURN Infty))\\<in>unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a infty_assn A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 (return infty.Infty), uncurry0 (RETURN infty.Infty))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a infty_assn A", "by sepref_to_hoare sep_auto"], ["", "sepref_register case_infty"], ["", "lemma [sepref_monadify_arity]: \"case_infty \\<equiv> \\<lambda>\\<^sub>2f1 f2 x. SP case_infty$f1$(\\<lambda>\\<^sub>2x. f2$x)$x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case_infty \\<equiv>\n    \\<lambda>x.\n       (#\\<lambda>xa.\n            (#\\<lambda>xb.\n                 (#SP case_infty $ x $ (\\<lambda>x. (#xa $ x#)) $ xb#)#)#)", "by simp"], ["", "lemma [sepref_monadify_comb]: \"case_infty$f1$f2$x \\<equiv> (\\<bind>)$(EVAL$x)$(\\<lambda>\\<^sub>2x. SP case_infty$f1$f2$x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case_infty $ f1 $ f2 $ x \\<equiv>\n    (\\<bind>) $ (EVAL $ x) $ (\\<lambda>x. (#SP case_infty $ f1 $ f2 $ x#))", "by simp"], ["", "lemma [sepref_monadify_comb]: \"EVAL$(case_infty$f1$(\\<lambda>\\<^sub>2x. f2 x)$x) \n  \\<equiv> (\\<bind>)$(EVAL$x)$(\\<lambda>\\<^sub>2x. SP case_infty$(EVAL $ f1)$(\\<lambda>\\<^sub>2x. EVAL $ f2 x)$x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. EVAL $ (case_infty $ f1 $ (\\<lambda>x. (#f2 x#)) $ x) \\<equiv>\n    (\\<bind>) $ (EVAL $ x) $\n    (\\<lambda>x.\n        (#SP case_infty $ (EVAL $ f1) $ (\\<lambda>x. (#EVAL $ f2 x#)) $ x#))", "apply (rule eq_reflection)"], ["proof (prove)\ngoal (1 subgoal):\n 1. EVAL $ (case_infty $ f1 $ (\\<lambda>x. (#f2 x#)) $ x) =\n    (\\<bind>) $ (EVAL $ x) $\n    (\\<lambda>x.\n        (#SP case_infty $ (EVAL $ f1) $ (\\<lambda>x. (#EVAL $ f2 x#)) $ x#))", "by (simp split: infty.splits)"], ["", "lemma infty_assn_ctxt: \"infty_assn A x y = z \\<Longrightarrow> hn_ctxt (infty_assn A) x y = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infty_assn A x y = z \\<Longrightarrow> hn_ctxt (infty_assn A) x y = z", "by (simp add: hn_ctxt_def)"], ["", "lemma infty_cases_hnr[sepref_prep_comb_rule, sepref_comb_rules]:\n  fixes A e e'\n  defines [simp]: \"INVe \\<equiv> hn_invalid (infty_assn A) e e'\"\n  assumes FR: \"\\<Gamma> \\<Longrightarrow>\\<^sub>t hn_ctxt (infty_assn A) e e' * F\"\n  assumes Infty: \"\\<lbrakk>e = Infty; e' = Infty\\<rbrakk> \\<Longrightarrow> hn_refine (hn_ctxt (infty_assn A) e e' * F) f1' (hn_ctxt XX1 e e' * \\<Gamma>1') R f1\"\n  assumes Num: \"\\<And>x1 x1a. \\<lbrakk>e = Num x1; e' = Num x1a\\<rbrakk> \\<Longrightarrow> hn_refine (hn_ctxt A x1 x1a * INVe * F) (f2' x1a) (hn_ctxt A' x1 x1a * hn_ctxt XX2 e e' * \\<Gamma>2') R (f2 x1)\"\n  assumes MERGE2[unfolded hn_ctxt_def]: \"\\<Gamma>1' \\<or>\\<^sub>A \\<Gamma>2' \\<Longrightarrow>\\<^sub>t \\<Gamma>'\"\n  shows \"hn_refine \\<Gamma> (case_infty f1' f2' e') (hn_ctxt (infty_assn A') e e' * \\<Gamma>') R (case_infty$f1$(\\<lambda>\\<^sub>2x. f2 x)$e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine \\<Gamma>\n     (case e' of infty.Infty \\<Rightarrow> f1' | Num x \\<Rightarrow> f2' x)\n     (hn_ctxt (infty_assn A') e e' * \\<Gamma>') R\n     (case_infty $ f1 $ (\\<lambda>x. (#f2 x#)) $ e)", "apply (rule hn_refine_cons_pre[OF FR])"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt (infty_assn A) e e' * F)\n     (case e' of infty.Infty \\<Rightarrow> f1' | Num x \\<Rightarrow> f2' x)\n     (hn_ctxt (infty_assn A') e e' * \\<Gamma>') R\n     (case_infty $ f1 $ (\\<lambda>x. (#f2 x#)) $ e)", "apply1 extract_hnr_invalids"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h h1 h2.\n       \\<lbrakk>h2 \\<Turnstile> F;\n        hn_invalid (infty_assn A) e e' = true\\<rbrakk>\n       \\<Longrightarrow> hn_refine (hn_ctxt (infty_assn A) e e' * F)\n                          (case e' of infty.Infty \\<Rightarrow> f1'\n                           | Num x \\<Rightarrow> f2' x)\n                          (hn_ctxt (infty_assn A') e e' * \\<Gamma>') R\n                          (case_infty $ f1 $ (\\<lambda>x. (#f2 x#)) $ e)", "apply (cases e; cases e'; simp add: infty_assn.simps[THEN infty_assn_ctxt])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>h2.\n       \\<lbrakk>h2 \\<Turnstile> F;\n        hn_invalid (infty_assn A) infty.Infty infty.Infty = true;\n        e = infty.Infty; e' = infty.Infty\\<rbrakk>\n       \\<Longrightarrow> hn_refine F f1' \\<Gamma>' R f1\n 2. \\<And>h2 x2 x2a.\n       \\<lbrakk>h2 \\<Turnstile> F;\n        hn_invalid (infty_assn A) (Num x2) (Num x2a) = true; e = Num x2;\n        e' = Num x2a\\<rbrakk>\n       \\<Longrightarrow> hn_refine (A x2 x2a * F) (f2' x2a)\n                          (A' x2 x2a * \\<Gamma>') R (f2 x2)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (infty_assn A) infty.Infty infty.Infty = true;\n     e = infty.Infty; e' = infty.Infty\\<rbrakk>\n    \\<Longrightarrow> hn_refine F f1' \\<Gamma>' R f1", "apply (rule hn_refine_cons[OF _ Infty _ entt_refl]; assumption?)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (infty_assn A) infty.Infty infty.Infty = true;\n     e = infty.Infty; e' = infty.Infty\\<rbrakk>\n    \\<Longrightarrow> F \\<Longrightarrow>\\<^sub>t\n                      hn_ctxt (infty_assn A) e e' * F\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (infty_assn A) infty.Infty infty.Infty = true;\n     e = infty.Infty; e' = infty.Infty\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt XX1 e e' *\n                      \\<Gamma>1' \\<Longrightarrow>\\<^sub>t\n                      \\<Gamma>'", "applyS (simp add: hn_ctxt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (infty_assn A) infty.Infty infty.Infty = true;\n     e = infty.Infty; e' = infty.Infty\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt XX1 e e' *\n                      \\<Gamma>1' \\<Longrightarrow>\\<^sub>t\n                      \\<Gamma>'", "apply (subst mult.commute, rule entt_fr_drop)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (infty_assn A) infty.Infty infty.Infty = true;\n     e = infty.Infty; e' = infty.Infty\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>1' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "apply (rule entt_trans[OF _ MERGE2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (infty_assn A) infty.Infty infty.Infty = true;\n     e = infty.Infty; e' = infty.Infty\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>1' \\<Longrightarrow>\\<^sub>t\n                      \\<Gamma>1' \\<or>\\<^sub>A \\<Gamma>2'", "apply (simp add:)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h2 x2 x2a.\n       \\<lbrakk>h2 \\<Turnstile> F;\n        hn_invalid (infty_assn A) (Num x2) (Num x2a) = true; e = Num x2;\n        e' = Num x2a\\<rbrakk>\n       \\<Longrightarrow> hn_refine (A x2 x2a * F) (f2' x2a)\n                          (A' x2 x2a * \\<Gamma>') R (f2 x2)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (infty_assn A) (Num x2_) (Num x2a_) = true; e = Num x2_;\n     e' = Num x2a_\\<rbrakk>\n    \\<Longrightarrow> hn_refine (A x2_ x2a_ * F) (f2' x2a_)\n                       (A' x2_ x2a_ * \\<Gamma>') R (f2 x2_)", "apply (rule hn_refine_cons[OF _ Num _ entt_refl]; assumption?)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (infty_assn A) (Num x2_) (Num x2a_) = true; e = Num x2_;\n     e' = Num x2a_\\<rbrakk>\n    \\<Longrightarrow> A x2_ x2a_ * F \\<Longrightarrow>\\<^sub>t\n                      hn_ctxt A x2_ x2a_ * INVe * F\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (infty_assn A) (Num x2_) (Num x2a_) = true; e = Num x2_;\n     e' = Num x2a_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt A' x2_ x2a_ * hn_ctxt XX2 e e' *\n                      \\<Gamma>2' \\<Longrightarrow>\\<^sub>t\n                      A' x2_ x2a_ * \\<Gamma>'", "applyS (simp add: hn_ctxt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (infty_assn A) (Num x2_) (Num x2a_) = true; e = Num x2_;\n     e' = Num x2a_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt A' x2_ x2a_ * hn_ctxt XX2 e e' *\n                      \\<Gamma>2' \\<Longrightarrow>\\<^sub>t\n                      A' x2_ x2a_ * \\<Gamma>'", "apply (rule entt_star_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (infty_assn A) (Num x2_) (Num x2a_) = true; e = Num x2_;\n     e' = Num x2a_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt A' x2_ x2a_ *\n                      hn_ctxt XX2 e e' \\<Longrightarrow>\\<^sub>t\n                      A' x2_ x2a_\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (infty_assn A) (Num x2_) (Num x2a_) = true; e = Num x2_;\n     e' = Num x2a_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>2' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "apply1 (rule entt_fr_drop)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (infty_assn A) (Num x2_) (Num x2a_) = true; e = Num x2_;\n     e' = Num x2a_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt A' x2_ x2a_ \\<Longrightarrow>\\<^sub>t\n                      A' x2_ x2a_\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (infty_assn A) (Num x2_) (Num x2a_) = true; e = Num x2_;\n     e' = Num x2a_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>2' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "applyS (simp add: hn_ctxt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (infty_assn A) (Num x2_) (Num x2a_) = true; e = Num x2_;\n     e' = Num x2a_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>2' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "apply1 (rule entt_trans[OF _ MERGE2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (infty_assn A) (Num x2_) (Num x2a_) = true; e = Num x2_;\n     e' = Num x2a_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>2' \\<Longrightarrow>\\<^sub>t\n                      \\<Gamma>1' \\<or>\\<^sub>A \\<Gamma>2'", "applyS (simp add:)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hnr_val[sepref_fr_rules]: \"(return o Weight.val,RETURN o Weight.val) \\<in> [\\<lambda>x. x\\<noteq>Infty]\\<^sub>a (infty_assn A)\\<^sup>d \\<rightarrow> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (return \\<circ> Weight.val, RETURN \\<circ> Weight.val)\n    \\<in> [\\<lambda>x.\n              x \\<noteq>\n              infty.Infty]\\<^sub>a (infty_assn A)\\<^sup>d \\<rightarrow> A", "apply sepref_to_hoare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xi.\n       \\<lbrakk>x \\<noteq> infty.Infty; x ::\\<^sub>i TYPE('b infty);\n        nofail (RETURN (Weight.val x))\\<rbrakk>\n       \\<Longrightarrow> <infty_assn A x\n                           xi> return\n                                (Weight.val\n                                  xi) <\\<lambda>r.\n    true *\n    (\\<exists>\\<^sub>Axa.\n        A xa r * \\<up> (RETURN xa \\<le> RETURN (Weight.val x)))>\\<^sub>t", "subgoal for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> infty.Infty; x ::\\<^sub>i TYPE('b infty);\n     nofail (RETURN (Weight.val x))\\<rbrakk>\n    \\<Longrightarrow> <infty_assn A x\n                        y> return\n                            (Weight.val\n                              y) <\\<lambda>r.\n                                     true *\n                                     (\\<exists>\\<^sub>Axa.\n   A xa r * \\<up> (RETURN xa \\<le> RETURN (Weight.val x)))>\\<^sub>t", "by (cases x; cases y; sep_auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "context\n  fixes A :: \"'a::weight \\<Rightarrow> 'b \\<Rightarrow> assn\"\n  fixes plusi\n  assumes GA[unfolded GEN_ALGO_def, sepref_fr_rules]: \"GEN_ALGO plusi (\\<lambda>f. (uncurry f,uncurry (RETURN oo (+)))\\<in>A\\<^sup>k*\\<^sub>aA\\<^sup>k \\<rightarrow>\\<^sub>a A)\"\nbegin"], ["", "sepref_thm infty_plus_impl is \"uncurry (RETURN oo (+))\" :: \"((infty_assn A)\\<^sup>k *\\<^sub>a (infty_assn A)\\<^sup>k \\<rightarrow>\\<^sub>a infty_assn A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry (RETURN \\<circ>\\<circ> (+)))\n    \\<in> (infty_assn A)\\<^sup>k *\\<^sub>a\n          (infty_assn A)\\<^sup>k \\<rightarrow>\\<^sub>a infty_assn A", "unfolding infty_plus_eq_plus[symmetric] infty_plus_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>x.\n          RETURN \\<circ>\n          (\\<lambda>b.\n              case (x, b) of (infty.Infty, ba) \\<Rightarrow> infty.Infty\n              | (Num a, infty.Infty) \\<Rightarrow> infty.Infty\n              | (Num a, Num b) \\<Rightarrow> Num (a + b))))\n    \\<in> (infty_assn A)\\<^sup>k *\\<^sub>a\n          (infty_assn A)\\<^sup>k \\<rightarrow>\\<^sub>a infty_assn A", "by sepref"], ["", "end"], ["", "concrete_definition infty_plus_impl uses infty_plus_impl.refine_raw is \"(uncurry ?impl,_)\\<in>_\""], ["", "lemmas [sepref_fr_rules] = infty_plus_impl.refine"], ["", "definition infty_less where\n  \"infty_less lt a b \\<equiv> case (a,b) of (Num a, Num b) \\<Rightarrow> lt a b | (Num _, Infty) \\<Rightarrow> True | _ \\<Rightarrow> False\""], ["", "lemma infty_less_param[param]:\n  \"(infty_less,infty_less) \\<in> (R\\<rightarrow>R\\<rightarrow>bool_rel) \\<rightarrow> \\<langle>R\\<rangle>infty_rel \\<rightarrow> \\<langle>R\\<rangle>infty_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (infty_less, infty_less)\n    \\<in> (R \\<rightarrow> R \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>R\\<rangle>infty_rel \\<rightarrow>\n          \\<langle>R\\<rangle>infty_rel \\<rightarrow> bool_rel", "unfolding infty_less_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>lt a b.\n        case (a, b) of (infty.Infty, ba) \\<Rightarrow> False\n        | (Num a, infty.Infty) \\<Rightarrow> True\n        | (Num a, Num b) \\<Rightarrow> lt a b,\n     \\<lambda>lt a b.\n        case (a, b) of (infty.Infty, ba) \\<Rightarrow> False\n        | (Num a, infty.Infty) \\<Rightarrow> True\n        | (Num a, Num b) \\<Rightarrow> lt a b)\n    \\<in> (R \\<rightarrow> R \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>R\\<rangle>infty_rel \\<rightarrow>\n          \\<langle>R\\<rangle>infty_rel \\<rightarrow> bool_rel", "by parametricity"], ["", "lemma infty_less_eq_less: \"infty_less (<) = (<)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infty_less (<) = (<)", "unfolding infty_less_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a b.\n        case (a, b) of (infty.Infty, ba) \\<Rightarrow> False\n        | (Num a, infty.Infty) \\<Rightarrow> True\n        | (Num a, Num x) \\<Rightarrow> a < x) =\n    (<)", "apply (clarsimp intro!: ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (case a of infty.Infty \\<Rightarrow> False\n        | Num a \\<Rightarrow>\n            case b of infty.Infty \\<Rightarrow> True\n            | Num x \\<Rightarrow> a < x) =\n       (a < b)", "subgoal for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case a of infty.Infty \\<Rightarrow> False\n     | Num a \\<Rightarrow>\n         case b of infty.Infty \\<Rightarrow> True\n         | Num x \\<Rightarrow> a < x) =\n    (a < b)", "by (cases a; cases b; auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "context\n  fixes A :: \"'a::weight \\<Rightarrow> 'b \\<Rightarrow> assn\"\n  fixes lessi\n  assumes GA[unfolded GEN_ALGO_def, sepref_fr_rules]: \"GEN_ALGO lessi (\\<lambda>f. (uncurry f,uncurry (RETURN oo (<)))\\<in>A\\<^sup>k*\\<^sub>aA\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn)\"\nbegin"], ["", "sepref_thm infty_less_impl is \"uncurry (RETURN oo (<))\" :: \"((infty_assn A)\\<^sup>k *\\<^sub>a (infty_assn A)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry (RETURN \\<circ>\\<circ> (<)))\n    \\<in> (infty_assn A)\\<^sup>k *\\<^sub>a\n          (infty_assn A)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "unfolding infty_less_eq_less[symmetric] infty_less_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>x.\n          RETURN \\<circ>\n          (\\<lambda>b.\n              case (x, b) of (infty.Infty, ba) \\<Rightarrow> False\n              | (Num a, infty.Infty) \\<Rightarrow> True\n              | (Num a, Num x) \\<Rightarrow> a < x)))\n    \\<in> (infty_assn A)\\<^sup>k *\\<^sub>a\n          (infty_assn A)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "by sepref"], ["", "end"], ["", "concrete_definition infty_less_impl uses infty_less_impl.refine_raw is \"(uncurry ?impl,_)\\<in>_\""], ["", "lemmas [sepref_fr_rules] = infty_less_impl.refine"], ["", "lemma param_mpath': \"(mpath',mpath')\n  \\<in> \\<langle>\\<langle>A\\<times>\\<^sub>r B \\<times>\\<^sub>r A\\<rangle>list_rel \\<times>\\<^sub>r B\\<rangle>option_rel \\<rightarrow> \\<langle>\\<langle>A\\<times>\\<^sub>r B \\<times>\\<^sub>r A\\<rangle>list_rel\\<rangle>option_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mpath', mpath')\n    \\<in> \\<langle>\\<langle>A \\<times>\\<^sub>r\n                            B \\<times>\\<^sub>r\n                            A\\<rangle>list_rel \\<times>\\<^sub>r\n                   B\\<rangle>option_rel \\<rightarrow>\n          \\<langle>\\<langle>A \\<times>\\<^sub>r\n                            B \\<times>\\<^sub>r\n                            A\\<rangle>list_rel\\<rangle>option_rel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (mpath', mpath')\n    \\<in> \\<langle>\\<langle>A \\<times>\\<^sub>r\n                            B \\<times>\\<^sub>r\n                            A\\<rangle>list_rel \\<times>\\<^sub>r\n                   B\\<rangle>option_rel \\<rightarrow>\n          \\<langle>\\<langle>A \\<times>\\<^sub>r\n                            B \\<times>\\<^sub>r\n                            A\\<rangle>list_rel\\<rangle>option_rel", "have 1: \"mpath' = map_option fst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpath' = map_option fst", "apply (intro ext, rename_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. mpath' x = map_option fst x", "apply (case_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x = None \\<Longrightarrow> mpath' x = map_option fst x\n 2. \\<And>x a. x = Some a \\<Longrightarrow> mpath' x = map_option fst x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a. x = Some a \\<Longrightarrow> mpath' x = map_option fst x", "apply (rename_tac a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a. x = Some a \\<Longrightarrow> mpath' x = map_option fst x", "apply (case_tac a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a aa b.\n       \\<lbrakk>x = Some a; a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> mpath' x = map_option fst x", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  mpath' = map_option fst\n\ngoal (1 subgoal):\n 1. (mpath', mpath')\n    \\<in> \\<langle>\\<langle>A \\<times>\\<^sub>r\n                            B \\<times>\\<^sub>r\n                            A\\<rangle>list_rel \\<times>\\<^sub>r\n                   B\\<rangle>option_rel \\<rightarrow>\n          \\<langle>\\<langle>A \\<times>\\<^sub>r\n                            B \\<times>\\<^sub>r\n                            A\\<rangle>list_rel\\<rangle>option_rel", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mpath', mpath')\n    \\<in> \\<langle>\\<langle>A \\<times>\\<^sub>r\n                            B \\<times>\\<^sub>r\n                            A\\<rangle>list_rel \\<times>\\<^sub>r\n                   B\\<rangle>option_rel \\<rightarrow>\n          \\<langle>\\<langle>A \\<times>\\<^sub>r\n                            B \\<times>\\<^sub>r\n                            A\\<rangle>list_rel\\<rangle>option_rel", "unfolding 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_option fst, map_option fst)\n    \\<in> \\<langle>\\<langle>A \\<times>\\<^sub>r\n                            B \\<times>\\<^sub>r\n                            A\\<rangle>list_rel \\<times>\\<^sub>r\n                   B\\<rangle>option_rel \\<rightarrow>\n          \\<langle>\\<langle>A \\<times>\\<^sub>r\n                            B \\<times>\\<^sub>r\n                            A\\<rangle>list_rel\\<rangle>option_rel", "by parametricity"], ["proof (state)\nthis:\n  (mpath', mpath')\n  \\<in> \\<langle>\\<langle>A \\<times>\\<^sub>r\n                          B \\<times>\\<^sub>r\n                          A\\<rangle>list_rel \\<times>\\<^sub>r\n                 B\\<rangle>option_rel \\<rightarrow>\n        \\<langle>\\<langle>A \\<times>\\<^sub>r\n                          B \\<times>\\<^sub>r\n                          A\\<rangle>list_rel\\<rangle>option_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas (in -) [sepref_import_param] = param_mpath'"], ["", "lemma param_mpath_weight': \n  \"(mpath_weight', mpath_weight') \\<in> \\<langle>\\<langle>A\\<times>\\<^sub>rB\\<times>\\<^sub>rA\\<rangle>list_rel \\<times>\\<^sub>r B\\<rangle>option_rel \\<rightarrow> \\<langle>B\\<rangle>infty_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mpath_weight', mpath_weight')\n    \\<in> \\<langle>\\<langle>A \\<times>\\<^sub>r\n                            B \\<times>\\<^sub>r\n                            A\\<rangle>list_rel \\<times>\\<^sub>r\n                   B\\<rangle>option_rel \\<rightarrow>\n          \\<langle>B\\<rangle>infty_rel", "by (auto elim!: option_relE simp: infty_rel_def top_infty_def)"], ["", "lemmas [sepref_import_param] = param_mpath_weight'"], ["", "context Dijkstra begin"], ["", "lemmas impl_aux = mdijkstra_def[unfolded mdinit_def mpop_min_def mupdate_def]"], ["", "lemma mdijkstra_correct:  \n    \"(mdijkstra, SPEC (is_shortest_path_map v0)) \\<in> \\<langle>br \\<alpha>r res_invarm\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mdijkstra, SPEC (is_shortest_path_map v0))\n    \\<in> \\<langle>br \\<alpha>r res_invarm\\<rangle>nres_rel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (mdijkstra, SPEC (is_shortest_path_map v0))\n    \\<in> \\<langle>br \\<alpha>r res_invarm\\<rangle>nres_rel", "note mdijkstra_refines"], ["proof (state)\nthis:\n  mdijkstra \\<le> \\<Down> (br \\<alpha>r res_invarm) dijkstra'\n\ngoal (1 subgoal):\n 1. (mdijkstra, SPEC (is_shortest_path_map v0))\n    \\<in> \\<langle>br \\<alpha>r res_invarm\\<rangle>nres_rel", "also"], ["proof (state)\nthis:\n  mdijkstra \\<le> \\<Down> (br \\<alpha>r res_invarm) dijkstra'\n\ngoal (1 subgoal):\n 1. (mdijkstra, SPEC (is_shortest_path_map v0))\n    \\<in> \\<langle>br \\<alpha>r res_invarm\\<rangle>nres_rel", "note dijkstra'_refines"], ["proof (state)\nthis:\n  dijkstra' \\<le> \\<Down> Id dijkstra\n\ngoal (1 subgoal):\n 1. (mdijkstra, SPEC (is_shortest_path_map v0))\n    \\<in> \\<langle>br \\<alpha>r res_invarm\\<rangle>nres_rel", "also"], ["proof (state)\nthis:\n  dijkstra' \\<le> \\<Down> Id dijkstra\n\ngoal (1 subgoal):\n 1. (mdijkstra, SPEC (is_shortest_path_map v0))\n    \\<in> \\<langle>br \\<alpha>r res_invarm\\<rangle>nres_rel", "note dijkstra_correct"], ["proof (state)\nthis:\n  dijkstra \\<le> SPEC (is_shortest_path_map v0)\n\ngoal (1 subgoal):\n 1. (mdijkstra, SPEC (is_shortest_path_map v0))\n    \\<in> \\<langle>br \\<alpha>r res_invarm\\<rangle>nres_rel", "finally"], ["proof (chain)\npicking this:\n  mdijkstra\n  \\<le> \\<Down> (br \\<alpha>r res_invarm) (SPEC (is_shortest_path_map v0))", "show ?thesis"], ["proof (prove)\nusing this:\n  mdijkstra\n  \\<le> \\<Down> (br \\<alpha>r res_invarm) (SPEC (is_shortest_path_map v0))\n\ngoal (1 subgoal):\n 1. (mdijkstra, SPEC (is_shortest_path_map v0))\n    \\<in> \\<langle>br \\<alpha>r res_invarm\\<rangle>nres_rel", "by (rule nres_relI)"], ["proof (state)\nthis:\n  (mdijkstra, SPEC (is_shortest_path_map v0))\n  \\<in> \\<langle>br \\<alpha>r res_invarm\\<rangle>nres_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale Dijkstra_Impl = fixes w_dummy :: \"'W::{weight,heap}\"\nbegin"], ["", "text \\<open>Weights\\<close>"], ["", "sepref_register \"0::'W\""], ["", "lemmas [sepref_import_param] = \n    IdI[of \"0::'W\"]"], ["", "abbreviation \"weight_assn \\<equiv> id_assn :: 'W \\<Rightarrow> _\""], ["", "lemma w_plus_param: \"((+), (+)::'W\\<Rightarrow>_) \\<in> Id \\<rightarrow> Id \\<rightarrow> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((+), (+)) \\<in> Id \\<rightarrow> Id \\<rightarrow> Id", "by simp"], ["", "lemma w_less_param: \"((<), (<)::'W\\<Rightarrow>_) \\<in> Id \\<rightarrow> Id \\<rightarrow> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((<), (<)) \\<in> Id \\<rightarrow> Id \\<rightarrow> bool_rel", "by simp"], ["", "lemmas [sepref_import_param] = w_plus_param w_less_param"], ["", "lemma [sepref_gen_algo_rules]: \n    \"GEN_ALGO (return oo (+)) (\\<lambda>f. (uncurry f, uncurry (RETURN \\<circ>\\<circ> (+))) \\<in> id_assn\\<^sup>k *\\<^sub>a id_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn)\"\n    \"GEN_ALGO (return oo (<)) (\\<lambda>f. (uncurry f, uncurry (RETURN \\<circ>\\<circ> (<))) \\<in> id_assn\\<^sup>k *\\<^sub>a id_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GEN_ALGO (return \\<circ>\\<circ> (+))\n     (\\<lambda>f.\n         (uncurry f, uncurry (RETURN \\<circ>\\<circ> (+)))\n         \\<in> id_assn\\<^sup>k *\\<^sub>a\n               id_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn) &&&\n    GEN_ALGO (return \\<circ>\\<circ> (<))\n     (\\<lambda>f.\n         (uncurry f, uncurry (RETURN \\<circ>\\<circ> (<)))\n         \\<in> id_assn\\<^sup>k *\\<^sub>a\n               id_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn)", "by (sep_auto simp: GEN_ALGO_def pure_def intro!: hfrefI hn_refineI)+"], ["", "lemma conv_prio_pop_min: \"prio_pop_min m = do {\n      ASSERT (dom m \\<noteq> {}); \n      ((k,v),m) \\<leftarrow> mop_pm_pop_min id m;\n      RETURN (k,v,m)\n    }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prio_pop_min m =\n    ASSERT (dom m \\<noteq> {}) \\<bind>\n    (\\<lambda>_.\n        mop_pm_pop_min id m \\<bind>\n        (\\<lambda>((k, v), m). RETURN (k, v, m)))", "unfolding prio_pop_min_def mop_pm_pop_min_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (dom m \\<noteq> {}) \\<bind>\n    (\\<lambda>_.\n        SPEC\n         (\\<lambda>(e, w, q').\n             q' = m(e := None) \\<and>\n             m e = Some w \\<and>\n             (\\<forall>e' w'.\n                 m e' = Some w' \\<longrightarrow> w \\<le> w'))) =\n    ASSERT (dom m \\<noteq> {}) \\<bind>\n    (\\<lambda>_.\n        mop pre_pm_pop_min (PR_CONST (op_pm_pop_min id)) m \\<bind>\n        (\\<lambda>((k, v), m). RETURN (k, v, m)))", "by (auto simp: pw_eq_iff refine_pw_simps ran_def)"], ["", "end"], ["", "context fixes N :: nat and w_dummy::\"'W::{heap,weight}\" begin"], ["", "interpretation Dijkstra_Impl w_dummy"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition \"drmap_assn2 \\<equiv> IICF_Sepl_Binding.iam.assn \n    (pure (node_rel N))  \n    (prod_assn\n      (list_assn (prod_assn (pure (node_rel N)) (prod_assn weight_assn (pure (node_rel N)))))\n      weight_assn)\n    \""], ["", "concrete_definition mdijkstra' uses Dijkstra.impl_aux"], ["", "sepref_definition dijkstra_imp is \"uncurry mdijkstra'\" \n    :: \"(is_graph N (Id::('W\\<times>'W) set))\\<^sup>k *\\<^sub>a (pure (node_rel N))\\<^sup>k \\<rightarrow>\\<^sub>a drmap_assn2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry local.mdijkstra')\n    \\<in> (is_graph N Id)\\<^sup>k *\\<^sub>a\n          (pure (nbn_rel N))\\<^sup>k \\<rightarrow>\\<^sub>a local.drmap_assn2", "unfolding mdijkstra'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>G v0.\n          FOREACH (nodes G)\n           (\\<lambda>v wl. RETURN (wl(v \\<mapsto> infty.Infty)))\n           Map.empty \\<bind>\n          (\\<lambda>wl.\n              RETURN\n               (wl(v0 \\<mapsto> Num (0::'W)),\n                [v0 \\<mapsto> ([], 0::'W)])) \\<bind>\n          (\\<lambda>\\<sigma>0.\n              WHILE\\<^sub>T\\<^bsup>Dijkstra.dinvarm\\<^esup>\n               (\\<lambda>(wl, uu_). dom wl \\<noteq> {})\n               (\\<lambda>\\<sigma>.\n                   (let (wl, res) = \\<sigma>\n                    in prio_pop_min wl \\<bind>\n                       (\\<lambda>(v, w, wl').\n                           RETURN (v, w, wl', res))) \\<bind>\n                   (\\<lambda>(v, wv, \\<sigma>').\n                       ASSERT\n                        (Dijkstra.update_pre G v0 v\n                          (Dijkstra.\\<alpha>s \\<sigma>') \\<and>\n                         wv = mpath_weight' (snd \\<sigma>' v)) \\<bind>\n                       (\\<lambda>_.\n                           let (wl, res) = \\<sigma>'; pv = mpath' (res v)\n                           in FOREACH\\<^bsup>Dijkstra.uinvarm G v0 v\n        (Dijkstra.\\<alpha>w wl) (Dijkstra.\\<alpha>r res)\\<^esup>\n                               (succ G v)\n                               (\\<lambda>(w', v') (wl, res).\n                                   if wv + Num w' < mpath_weight' (res v')\n                                   then ASSERT\n   (v' \\<in> dom wl \\<and> pv \\<noteq> None) \\<bind>\n  (\\<lambda>_.\n      ASSERT (wv \\<noteq> infty.Infty) \\<bind>\n      (\\<lambda>_.\n          RETURN\n           (wl(v' \\<mapsto> wv + Num w'), res(v' \\<mapsto>\n            ((v, w', v') # the pv, Weight.val wv + w')))))\n                                   else RETURN (wl, res))\n                               (wl, res))))\n               \\<sigma>0 \\<bind>\n              (\\<lambda>(uu_, res). RETURN res))))\n    \\<in> (is_graph N Id)\\<^sup>k *\\<^sub>a\n          (pure (nbn_rel N))\\<^sup>k \\<rightarrow>\\<^sub>a local.drmap_assn2", "apply (subst conv_prio_pop_min)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>G v0.\n          FOREACH (nodes G)\n           (\\<lambda>v wl. RETURN (wl(v \\<mapsto> infty.Infty)))\n           Map.empty \\<bind>\n          (\\<lambda>wl.\n              RETURN\n               (wl(v0 \\<mapsto> Num (0::'W)),\n                [v0 \\<mapsto> ([], 0::'W)])) \\<bind>\n          (\\<lambda>\\<sigma>0.\n              WHILE\\<^sub>T\\<^bsup>Dijkstra.dinvarm\\<^esup>\n               (\\<lambda>(wl, uu_). dom wl \\<noteq> {})\n               (\\<lambda>\\<sigma>.\n                   (let (wl, res) = \\<sigma>\n                    in ASSERT (dom wl \\<noteq> {}) \\<bind>\n                       (\\<lambda>_.\n                           mop_pm_pop_min id wl \\<bind>\n                           (\\<lambda>((k, v), m). RETURN (k, v, m))) \\<bind>\n                       (\\<lambda>(v, w, wl').\n                           RETURN (v, w, wl', res))) \\<bind>\n                   (\\<lambda>(v, wv, \\<sigma>').\n                       ASSERT\n                        (Dijkstra.update_pre G v0 v\n                          (Dijkstra.\\<alpha>s \\<sigma>') \\<and>\n                         wv = mpath_weight' (snd \\<sigma>' v)) \\<bind>\n                       (\\<lambda>_.\n                           let (wl, res) = \\<sigma>'; pv = mpath' (res v)\n                           in FOREACH\\<^bsup>Dijkstra.uinvarm G v0 v\n        (Dijkstra.\\<alpha>w wl) (Dijkstra.\\<alpha>r res)\\<^esup>\n                               (succ G v)\n                               (\\<lambda>(w', v') (wl, res).\n                                   if wv + Num w' < mpath_weight' (res v')\n                                   then ASSERT\n   (v' \\<in> dom wl \\<and> pv \\<noteq> None) \\<bind>\n  (\\<lambda>_.\n      ASSERT (wv \\<noteq> infty.Infty) \\<bind>\n      (\\<lambda>_.\n          RETURN\n           (wl(v' \\<mapsto> wv + Num w'), res(v' \\<mapsto>\n            ((v, w', v') # the pv, Weight.val wv + w')))))\n                                   else RETURN (wl, res))\n                               (wl, res))))\n               \\<sigma>0 \\<bind>\n              (\\<lambda>(uu_, y). RETURN y))))\n    \\<in> (is_graph N Id)\\<^sup>k *\\<^sub>a\n          (pure (nbn_rel N))\\<^sup>k \\<rightarrow>\\<^sub>a local.drmap_assn2", "apply (rewrite in \"RETURN (_,\\<hole>)\" iam.fold_custom_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>G v0.\n          FOREACH (nodes G)\n           (\\<lambda>v wl. RETURN (wl(v \\<mapsto> infty.Infty)))\n           Map.empty \\<bind>\n          (\\<lambda>wl.\n              RETURN\n               (wl(v0 \\<mapsto> Num (0::'W)), op_iam_empty(v0 \\<mapsto>\n                ([], 0::'W)))) \\<bind>\n          (\\<lambda>\\<sigma>0.\n              WHILE\\<^sub>T\\<^bsup>Dijkstra.dinvarm\\<^esup>\n               (\\<lambda>(wl, uu_). dom wl \\<noteq> {})\n               (\\<lambda>\\<sigma>.\n                   (let (wl, res) = \\<sigma>\n                    in ASSERT (dom wl \\<noteq> {}) \\<bind>\n                       (\\<lambda>_.\n                           mop_pm_pop_min id wl \\<bind>\n                           (\\<lambda>((k, v), m). RETURN (k, v, m))) \\<bind>\n                       (\\<lambda>(v, w, wl').\n                           RETURN (v, w, wl', res))) \\<bind>\n                   (\\<lambda>(v, wv, \\<sigma>').\n                       ASSERT\n                        (Dijkstra.update_pre G v0 v\n                          (Dijkstra.\\<alpha>s \\<sigma>') \\<and>\n                         wv = mpath_weight' (snd \\<sigma>' v)) \\<bind>\n                       (\\<lambda>_.\n                           let (wl, res) = \\<sigma>'; pv = mpath' (res v)\n                           in FOREACH\\<^bsup>Dijkstra.uinvarm G v0 v\n        (Dijkstra.\\<alpha>w wl) (Dijkstra.\\<alpha>r res)\\<^esup>\n                               (succ G v)\n                               (\\<lambda>(w', v') (wl, res).\n                                   if wv + Num w' < mpath_weight' (res v')\n                                   then ASSERT\n   (v' \\<in> dom wl \\<and> pv \\<noteq> None) \\<bind>\n  (\\<lambda>_.\n      ASSERT (wv \\<noteq> infty.Infty) \\<bind>\n      (\\<lambda>_.\n          RETURN\n           (wl(v' \\<mapsto> wv + Num w'), res(v' \\<mapsto>\n            ((v, w', v') # the pv, Weight.val wv + w')))))\n                                   else RETURN (wl, res))\n                               (wl, res))))\n               \\<sigma>0 \\<bind>\n              (\\<lambda>(uu_, y). RETURN y))))\n    \\<in> (is_graph N Id)\\<^sup>k *\\<^sub>a\n          (pure (nbn_rel N))\\<^sup>k \\<rightarrow>\\<^sub>a local.drmap_assn2", "apply (rewrite hm_fold_custom_empty_sz[of N])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>G v0.\n          FOREACH (nodes G)\n           (\\<lambda>v wl. RETURN (wl(v \\<mapsto> infty.Infty)))\n           (op_hm_empty_sz N) \\<bind>\n          (\\<lambda>wl.\n              RETURN\n               (wl(v0 \\<mapsto> Num (0::'W)), op_iam_empty(v0 \\<mapsto>\n                ([], 0::'W)))) \\<bind>\n          (\\<lambda>\\<sigma>0.\n              WHILE\\<^sub>T\\<^bsup>Dijkstra.dinvarm\\<^esup>\n               (\\<lambda>(wl, uu_). dom wl \\<noteq> {})\n               (\\<lambda>\\<sigma>.\n                   (let (wl, res) = \\<sigma>\n                    in ASSERT (dom wl \\<noteq> {}) \\<bind>\n                       (\\<lambda>_.\n                           mop_pm_pop_min id wl \\<bind>\n                           (\\<lambda>((k, v), m). RETURN (k, v, m))) \\<bind>\n                       (\\<lambda>(v, w, wl').\n                           RETURN (v, w, wl', res))) \\<bind>\n                   (\\<lambda>(v, wv, \\<sigma>').\n                       ASSERT\n                        (Dijkstra.update_pre G v0 v\n                          (Dijkstra.\\<alpha>s \\<sigma>') \\<and>\n                         wv = mpath_weight' (snd \\<sigma>' v)) \\<bind>\n                       (\\<lambda>_.\n                           let (wl, res) = \\<sigma>'; pv = mpath' (res v)\n                           in FOREACH\\<^bsup>Dijkstra.uinvarm G v0 v\n        (Dijkstra.\\<alpha>w wl) (Dijkstra.\\<alpha>r res)\\<^esup>\n                               (succ G v)\n                               (\\<lambda>(w', v') (wl, res).\n                                   if wv + Num w' < mpath_weight' (res v')\n                                   then ASSERT\n   (v' \\<in> dom wl \\<and> pv \\<noteq> None) \\<bind>\n  (\\<lambda>_.\n      ASSERT (wv \\<noteq> infty.Infty) \\<bind>\n      (\\<lambda>_.\n          RETURN\n           (wl(v' \\<mapsto> wv + Num w'), res(v' \\<mapsto>\n            ((v, w', v') # the pv, Weight.val wv + w')))))\n                                   else RETURN (wl, res))\n                               (wl, res))))\n               \\<sigma>0 \\<bind>\n              (\\<lambda>(uu_, y). RETURN y))))\n    \\<in> (is_graph N Id)\\<^sup>k *\\<^sub>a\n          (pure (nbn_rel N))\\<^sup>k \\<rightarrow>\\<^sub>a local.drmap_assn2", "apply (rewrite in \"_(_ \\<mapsto> (\\<hole>,0))\" HOL_list.fold_custom_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>G v0.\n          FOREACH (nodes G)\n           (\\<lambda>v wl. RETURN (wl(v \\<mapsto> infty.Infty)))\n           (op_hm_empty_sz N) \\<bind>\n          (\\<lambda>wl.\n              RETURN\n               (wl(v0 \\<mapsto> Num (0::'W)), op_iam_empty(v0 \\<mapsto>\n                (op_HOL_list_empty, 0::'W)))) \\<bind>\n          (\\<lambda>\\<sigma>0.\n              WHILE\\<^sub>T\\<^bsup>Dijkstra.dinvarm\\<^esup>\n               (\\<lambda>(wl, uu_). dom wl \\<noteq> {})\n               (\\<lambda>\\<sigma>.\n                   (let (wl, res) = \\<sigma>\n                    in ASSERT (dom wl \\<noteq> {}) \\<bind>\n                       (\\<lambda>_.\n                           mop_pm_pop_min id wl \\<bind>\n                           (\\<lambda>((k, v), m). RETURN (k, v, m))) \\<bind>\n                       (\\<lambda>(v, w, wl').\n                           RETURN (v, w, wl', res))) \\<bind>\n                   (\\<lambda>(v, wv, \\<sigma>').\n                       ASSERT\n                        (Dijkstra.update_pre G v0 v\n                          (Dijkstra.\\<alpha>s \\<sigma>') \\<and>\n                         wv = mpath_weight' (snd \\<sigma>' v)) \\<bind>\n                       (\\<lambda>_.\n                           let (wl, res) = \\<sigma>'; pv = mpath' (res v)\n                           in FOREACH\\<^bsup>Dijkstra.uinvarm G v0 v\n        (Dijkstra.\\<alpha>w wl) (Dijkstra.\\<alpha>r res)\\<^esup>\n                               (succ G v)\n                               (\\<lambda>(w', v') (wl, res).\n                                   if wv + Num w' < mpath_weight' (res v')\n                                   then ASSERT\n   (v' \\<in> dom wl \\<and> pv \\<noteq> None) \\<bind>\n  (\\<lambda>_.\n      ASSERT (wv \\<noteq> infty.Infty) \\<bind>\n      (\\<lambda>_.\n          RETURN\n           (wl(v' \\<mapsto> wv + Num w'), res(v' \\<mapsto>\n            ((v, w', v') # the pv, Weight.val wv + w')))))\n                                   else RETURN (wl, res))\n                               (wl, res))))\n               \\<sigma>0 \\<bind>\n              (\\<lambda>(uu_, y). RETURN y))))\n    \\<in> (is_graph N Id)\\<^sup>k *\\<^sub>a\n          (pure (nbn_rel N))\\<^sup>k \\<rightarrow>\\<^sub>a local.drmap_assn2", "unfolding drmap_assn2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>G v0.\n          FOREACH (nodes G)\n           (\\<lambda>v wl. RETURN (wl(v \\<mapsto> infty.Infty)))\n           (op_hm_empty_sz N) \\<bind>\n          (\\<lambda>wl.\n              RETURN\n               (wl(v0 \\<mapsto> Num (0::'W)), op_iam_empty(v0 \\<mapsto>\n                (op_HOL_list_empty, 0::'W)))) \\<bind>\n          (\\<lambda>\\<sigma>0.\n              WHILE\\<^sub>T\\<^bsup>Dijkstra.dinvarm\\<^esup>\n               (\\<lambda>(wl, uu_). dom wl \\<noteq> {})\n               (\\<lambda>\\<sigma>.\n                   (let (wl, res) = \\<sigma>\n                    in ASSERT (dom wl \\<noteq> {}) \\<bind>\n                       (\\<lambda>_.\n                           mop_pm_pop_min id wl \\<bind>\n                           (\\<lambda>((k, v), m). RETURN (k, v, m))) \\<bind>\n                       (\\<lambda>(v, w, wl').\n                           RETURN (v, w, wl', res))) \\<bind>\n                   (\\<lambda>(v, wv, \\<sigma>').\n                       ASSERT\n                        (Dijkstra.update_pre G v0 v\n                          (Dijkstra.\\<alpha>s \\<sigma>') \\<and>\n                         wv = mpath_weight' (snd \\<sigma>' v)) \\<bind>\n                       (\\<lambda>_.\n                           let (wl, res) = \\<sigma>'; pv = mpath' (res v)\n                           in FOREACH\\<^bsup>Dijkstra.uinvarm G v0 v\n        (Dijkstra.\\<alpha>w wl) (Dijkstra.\\<alpha>r res)\\<^esup>\n                               (succ G v)\n                               (\\<lambda>(w', v') (wl, res).\n                                   if wv + Num w' < mpath_weight' (res v')\n                                   then ASSERT\n   (v' \\<in> dom wl \\<and> pv \\<noteq> None) \\<bind>\n  (\\<lambda>_.\n      ASSERT (wv \\<noteq> infty.Infty) \\<bind>\n      (\\<lambda>_.\n          RETURN\n           (wl(v' \\<mapsto> wv + Num w'), res(v' \\<mapsto>\n            ((v, w', v') # the pv, Weight.val wv + w')))))\n                                   else RETURN (wl, res))\n                               (wl, res))))\n               \\<sigma>0 \\<bind>\n              (\\<lambda>(uu_, y). RETURN y))))\n    \\<in> (is_graph N Id)\\<^sup>k *\\<^sub>a\n          (pure\n            (nbn_rel\n              N))\\<^sup>k \\<rightarrow>\\<^sub>a iam.assn (pure (nbn_rel N))\n           (list_assn\n             (pure (nbn_rel N) \\<times>\\<^sub>a\n              weight_assn \\<times>\\<^sub>a\n              pure (nbn_rel N)) \\<times>\\<^sub>a\n            weight_assn)", "using [[id_debug, goals_limit = 1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>G v0.\n          FOREACH (nodes G)\n           (\\<lambda>v wl. RETURN (wl(v \\<mapsto> infty.Infty)))\n           (op_hm_empty_sz N) \\<bind>\n          (\\<lambda>wl.\n              RETURN\n               (wl(v0 \\<mapsto> Num (0::'W)), op_iam_empty(v0 \\<mapsto>\n                (op_HOL_list_empty, 0::'W)))) \\<bind>\n          (\\<lambda>\\<sigma>0.\n              WHILE\\<^sub>T\\<^bsup>Dijkstra.dinvarm\\<^esup>\n               (\\<lambda>(wl, uu_). dom wl \\<noteq> {})\n               (\\<lambda>\\<sigma>.\n                   (let (wl, res) = \\<sigma>\n                    in ASSERT (dom wl \\<noteq> {}) \\<bind>\n                       (\\<lambda>_.\n                           mop_pm_pop_min id wl \\<bind>\n                           (\\<lambda>((k, v), m). RETURN (k, v, m))) \\<bind>\n                       (\\<lambda>(v, w, wl').\n                           RETURN (v, w, wl', res))) \\<bind>\n                   (\\<lambda>(v, wv, \\<sigma>').\n                       ASSERT\n                        (Dijkstra.update_pre G v0 v\n                          (Dijkstra.\\<alpha>s \\<sigma>') \\<and>\n                         wv = mpath_weight' (snd \\<sigma>' v)) \\<bind>\n                       (\\<lambda>_.\n                           let (wl, res) = \\<sigma>'; pv = mpath' (res v)\n                           in FOREACH\\<^bsup>Dijkstra.uinvarm G v0 v\n        (Dijkstra.\\<alpha>w wl) (Dijkstra.\\<alpha>r res)\\<^esup>\n                               (succ G v)\n                               (\\<lambda>(w', v') (wl, res).\n                                   if wv + Num w' < mpath_weight' (res v')\n                                   then ASSERT\n   (v' \\<in> dom wl \\<and> pv \\<noteq> None) \\<bind>\n  (\\<lambda>_.\n      ASSERT (wv \\<noteq> infty.Infty) \\<bind>\n      (\\<lambda>_.\n          RETURN\n           (wl(v' \\<mapsto> wv + Num w'), res(v' \\<mapsto>\n            ((v, w', v') # the pv, Weight.val wv + w')))))\n                                   else RETURN (wl, res))\n                               (wl, res))))\n               \\<sigma>0 \\<bind>\n              (\\<lambda>(uu_, y). RETURN y))))\n    \\<in> (is_graph N Id)\\<^sup>k *\\<^sub>a\n          (pure\n            (nbn_rel\n              N))\\<^sup>k \\<rightarrow>\\<^sub>a iam.assn (pure (nbn_rel N))\n           (list_assn\n             (pure (nbn_rel N) \\<times>\\<^sub>a\n              weight_assn \\<times>\\<^sub>a\n              pure (nbn_rel N)) \\<times>\\<^sub>a\n            weight_assn)", "by sepref"], ["", "export_code dijkstra_imp checking SML_imp"], ["", "end"], ["", "text \\<open>The main correctness theorem\\<close>"], ["", "thm Dijkstra.mdijkstra_correct"], ["", "lemma mdijkstra'_aref: \"(uncurry mdijkstra',uncurry (SPEC oo weighted_graph.is_shortest_path_map))\n  \\<in> [\\<lambda>(G,v0). Dijkstra G v0]\\<^sub>f Id\\<times>\\<^sub>rId \\<rightarrow> \\<langle>br Dijkstra.\\<alpha>r Dijkstra.res_invarm\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry mdijkstra',\n     uncurry (SPEC \\<circ>\\<circ> weighted_graph.is_shortest_path_map))\n    \\<in> [\\<lambda>(G, v0).\n              Dijkstra G\n               v0]\\<^sub>f Id \\<times>\\<^sub>r\n                           Id \\<rightarrow> \\<langle>br Dijkstra.\\<alpha>r\n                Dijkstra.res_invarm\\<rangle>nres_rel", "using Dijkstra.mdijkstra_correct"], ["proof (prove)\nusing this:\n  Dijkstra ?G ?v0.0 \\<Longrightarrow>\n  (Dijkstra.mdijkstra ?G ?v0.0,\n   SPEC (weighted_graph.is_shortest_path_map ?G ?v0.0))\n  \\<in> \\<langle>br Dijkstra.\\<alpha>r Dijkstra.res_invarm\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (uncurry mdijkstra',\n     uncurry (SPEC \\<circ>\\<circ> weighted_graph.is_shortest_path_map))\n    \\<in> [\\<lambda>(G, v0).\n              Dijkstra G\n               v0]\\<^sub>f Id \\<times>\\<^sub>r\n                           Id \\<rightarrow> \\<langle>br Dijkstra.\\<alpha>r\n                Dijkstra.res_invarm\\<rangle>nres_rel", "by (fastforce intro!: frefI simp: mdijkstra'.refine[symmetric])"], ["", "definition \"drmap_assn N \\<equiv> hr_comp (drmap_assn2 N) (br Dijkstra.\\<alpha>r Dijkstra.res_invarm)\""], ["", "context notes [fcomp_norm_unfold] = drmap_assn_def[symmetric] begin"], ["", "theorem dijkstra_imp_correct: \"(uncurry (dijkstra_imp N), uncurry (SPEC \\<circ>\\<circ> weighted_graph.is_shortest_path_map))\n  \\<in> [\\<lambda>(G, v0). v0 \\<in> nodes G \\<and> (\\<forall>(v, w, v') \\<in> edges G. 0 \\<le> w)]\\<^sub>a (is_graph N Id)\\<^sup>k *\\<^sub>a (node_assn N)\\<^sup>k \\<rightarrow> drmap_assn N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry (dijkstra_imp N),\n     uncurry (SPEC \\<circ>\\<circ> weighted_graph.is_shortest_path_map))\n    \\<in> [\\<lambda>(G, v0).\n              v0 \\<in> nodes G \\<and>\n              (\\<forall>(v, w, v')\\<in>edges G.\n                  (0::'a)\n                  \\<le> w)]\\<^sub>a (is_graph N Id)\\<^sup>k *\\<^sub>a\n                                    (nbn_assn\nN)\\<^sup>k \\<rightarrow> drmap_assn N", "apply (rule hfref_weaken_pre'[OF _ dijkstra_imp.refine[FCOMP mdijkstra'_aref]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>case x of\n                (G, v0) \\<Rightarrow>\n                  v0 \\<in> nodes G \\<and>\n                  (\\<forall>(v, w, v')\\<in>edges G. (0::'a) \\<le> w);\n        rdomp (fst ((is_graph N Id)\\<^sup>k *\\<^sub>a (nbn_assn N)\\<^sup>k))\n         x\\<rbrakk>\n       \\<Longrightarrow> case x of (x, xa) \\<Rightarrow> Dijkstra x xa", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>b \\<in> nodes a;\n        \\<forall>x\\<in>edges a.\n           case x of (v, w, v') \\<Rightarrow> (0::'a) \\<le> w;\n        rdomp (is_graph N Id) a; b < N\\<rbrakk>\n       \\<Longrightarrow> Dijkstra a b", "fix G :: \"(nat,'w::{weight,heap}) graph\" and v0"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>b \\<in> nodes a;\n        \\<forall>x\\<in>edges a.\n           case x of (v, w, v') \\<Rightarrow> (0::'a) \\<le> w;\n        rdomp (is_graph N Id) a; b < N\\<rbrakk>\n       \\<Longrightarrow> Dijkstra a b", "assume v0_is_node: \"v0 \\<in> nodes G\"\n    and nonneg_weights: \"\\<forall>(v, w, v') \\<in> edges G. 0 \\<le> w\"\n    and \"v0<N\" \n    and RDOM: \"rdomp (is_graph N Id) G\""], ["proof (state)\nthis:\n  v0 \\<in> nodes G\n  \\<forall>(v, w, v')\\<in>edges G. (0::'w) \\<le> w\n  v0 < N\n  rdomp (is_graph N Id) G\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>b \\<in> nodes a;\n        \\<forall>x\\<in>edges a.\n           case x of (v, w, v') \\<Rightarrow> (0::'a) \\<le> w;\n        rdomp (is_graph N Id) a; b < N\\<rbrakk>\n       \\<Longrightarrow> Dijkstra a b", "from RDOM"], ["proof (chain)\npicking this:\n  rdomp (is_graph N Id) G", "interpret valid_graph G"], ["proof (prove)\nusing this:\n  rdomp (is_graph N Id) G\n\ngoal (1 subgoal):\n 1. valid_graph G", "unfolding is_graph_def rdomp_def"], ["proof (prove)\nusing this:\n  \\<exists>h c.\n     h \\<Turnstile>\n     (\\<exists>\\<^sub>Al.\n         c \\<mapsto>\\<^sub>a l *\n         \\<up>\n          (valid_graph G \\<and>\n           N = length l \\<and>\n           nodes G = {0..<length l} \\<and>\n           (\\<forall>v\\<in>nodes G.\n               (l ! v, succ G v)\n               \\<in> \\<langle>Id \\<times>\\<^sub>r\n                              nbn_rel (length l)\\<rangle>list_set_rel)))\n\ngoal (1 subgoal):\n 1. valid_graph G", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>b \\<in> nodes a;\n        \\<forall>x\\<in>edges a.\n           case x of (v, w, v') \\<Rightarrow> (0::'a) \\<le> w;\n        rdomp (is_graph N Id) a; b < N\\<rbrakk>\n       \\<Longrightarrow> Dijkstra a b", "from RDOM"], ["proof (chain)\npicking this:\n  rdomp (is_graph N Id) G", "have [simp]: \"finite V\""], ["proof (prove)\nusing this:\n  rdomp (is_graph N Id) G\n\ngoal (1 subgoal):\n 1. finite V", "unfolding is_graph_def rdomp_def"], ["proof (prove)\nusing this:\n  \\<exists>h c.\n     h \\<Turnstile>\n     (\\<exists>\\<^sub>Al.\n         c \\<mapsto>\\<^sub>a l *\n         \\<up>\n          (valid_graph G \\<and>\n           N = length l \\<and>\n           V = {0..<length l} \\<and>\n           (\\<forall>v\\<in>V.\n               (l ! v, succ G v)\n               \\<in> \\<langle>Id \\<times>\\<^sub>r\n                              nbn_rel (length l)\\<rangle>list_set_rel)))\n\ngoal (1 subgoal):\n 1. finite V", "by auto"], ["proof (state)\nthis:\n  finite V\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>b \\<in> nodes a;\n        \\<forall>x\\<in>edges a.\n           case x of (v, w, v') \\<Rightarrow> (0::'a) \\<le> w;\n        rdomp (is_graph N Id) a; b < N\\<rbrakk>\n       \\<Longrightarrow> Dijkstra a b", "from RDOM"], ["proof (chain)\npicking this:\n  rdomp (is_graph N Id) G", "have \"\\<forall>v\\<in>V. {(w, v'). (v, w, v') \\<in> E} \\<in> \n    Range (\\<langle>Id \\<times>\\<^sub>r node_rel N\\<rangle>list_set_rel)\""], ["proof (prove)\nusing this:\n  rdomp (is_graph N Id) G\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>V.\n       {(w, v'). (v, w, v') \\<in> E}\n       \\<in> Range\n              (\\<langle>Id \\<times>\\<^sub>r nbn_rel N\\<rangle>list_set_rel)", "by (auto simp: succ_def is_graph_def rdomp_def)"], ["proof (state)\nthis:\n  \\<forall>v\\<in>V.\n     {(w, v'). (v, w, v') \\<in> E}\n     \\<in> Range\n            (\\<langle>Id \\<times>\\<^sub>r nbn_rel N\\<rangle>list_set_rel)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>b \\<in> nodes a;\n        \\<forall>x\\<in>edges a.\n           case x of (v, w, v') \\<Rightarrow> (0::'a) \\<le> w;\n        rdomp (is_graph N Id) a; b < N\\<rbrakk>\n       \\<Longrightarrow> Dijkstra a b", "hence \"\\<forall>v\\<in>V. finite {(w, v'). (v, w, v') \\<in> E}\""], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>V.\n     {(w, v'). (v, w, v') \\<in> E}\n     \\<in> Range\n            (\\<langle>Id \\<times>\\<^sub>r nbn_rel N\\<rangle>list_set_rel)\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>V. finite {(w, v'). (v, w, v') \\<in> E}", "unfolding list_set_rel_range"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>V.\n     {(w, v'). (v, w, v') \\<in> E}\n     \\<in> {S. finite S \\<and>\n               S \\<subseteq> Range (Id \\<times>\\<^sub>r nbn_rel N)}\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>V. finite {(w, v'). (v, w, v') \\<in> E}", "by simp"], ["proof (state)\nthis:\n  \\<forall>v\\<in>V. finite {(w, v'). (v, w, v') \\<in> E}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>b \\<in> nodes a;\n        \\<forall>x\\<in>edges a.\n           case x of (v, w, v') \\<Rightarrow> (0::'a) \\<le> w;\n        rdomp (is_graph N Id) a; b < N\\<rbrakk>\n       \\<Longrightarrow> Dijkstra a b", "hence \"finite (Sigma V (\\<lambda>v. {(w, v'). (v, w, v') \\<in> E}))\""], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>V. finite {(w, v'). (v, w, v') \\<in> E}\n\ngoal (1 subgoal):\n 1. finite (SIGMA v:V. {(w, v'). (v, w, v') \\<in> E})", "by auto"], ["proof (state)\nthis:\n  finite (SIGMA v:V. {(w, v'). (v, w, v') \\<in> E})\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>b \\<in> nodes a;\n        \\<forall>x\\<in>edges a.\n           case x of (v, w, v') \\<Rightarrow> (0::'a) \\<le> w;\n        rdomp (is_graph N Id) a; b < N\\<rbrakk>\n       \\<Longrightarrow> Dijkstra a b", "also"], ["proof (state)\nthis:\n  finite (SIGMA v:V. {(w, v'). (v, w, v') \\<in> E})\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>b \\<in> nodes a;\n        \\<forall>x\\<in>edges a.\n           case x of (v, w, v') \\<Rightarrow> (0::'a) \\<le> w;\n        rdomp (is_graph N Id) a; b < N\\<rbrakk>\n       \\<Longrightarrow> Dijkstra a b", "have \"E \\<subseteq> (Sigma V (\\<lambda>v. {(w, v'). (v, w, v') \\<in> E}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E \\<subseteq> (SIGMA v:V. {(w, v'). (v, w, v') \\<in> E})", "using E_valid"], ["proof (prove)\nusing this:\n  fst ` E \\<subseteq> V\n  snd ` snd ` E \\<subseteq> V\n\ngoal (1 subgoal):\n 1. E \\<subseteq> (SIGMA v:V. {(w, v'). (v, w, v') \\<in> E})", "by auto"], ["proof (state)\nthis:\n  E \\<subseteq> (SIGMA v:V. {(w, v'). (v, w, v') \\<in> E})\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>b \\<in> nodes a;\n        \\<forall>x\\<in>edges a.\n           case x of (v, w, v') \\<Rightarrow> (0::'a) \\<le> w;\n        rdomp (is_graph N Id) a; b < N\\<rbrakk>\n       \\<Longrightarrow> Dijkstra a b", "finally (finite_subset[rotated])"], ["proof (chain)\npicking this:\n  finite E", "have [simp]: \"finite E\""], ["proof (prove)\nusing this:\n  finite E\n\ngoal (1 subgoal):\n 1. finite E", "."], ["proof (state)\nthis:\n  finite E\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>b \\<in> nodes a;\n        \\<forall>x\\<in>edges a.\n           case x of (v, w, v') \\<Rightarrow> (0::'a) \\<le> w;\n        rdomp (is_graph N Id) a; b < N\\<rbrakk>\n       \\<Longrightarrow> Dijkstra a b", "show \"Dijkstra G v0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dijkstra G v0", "apply (unfold_locales)"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite V\n 2. finite E\n 3. v0 \\<in> V\n 4. \\<And>v w v'. (v, w, v') \\<in> E \\<Longrightarrow> (0::'w) \\<le> w", "unfolding is_graph_def"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite V\n 2. finite E\n 3. v0 \\<in> V\n 4. \\<And>v w v'. (v, w, v') \\<in> E \\<Longrightarrow> (0::'w) \\<le> w", "using v0_is_node nonneg_weights"], ["proof (prove)\nusing this:\n  v0 \\<in> V\n  \\<forall>(v, w, v')\\<in>E. (0::'w) \\<le> w\n\ngoal (4 subgoals):\n 1. finite V\n 2. finite E\n 3. v0 \\<in> V\n 4. \\<And>v w v'. (v, w, v') \\<in> E \\<Longrightarrow> (0::'w) \\<le> w", "by auto"], ["proof (state)\nthis:\n  Dijkstra G v0\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "corollary dijkstra_imp_rule: \"\n  <is_graph n Id G Gi * \\<up>(v0 \\<in> nodes G \\<and> (\\<forall>(v, w, v') \\<in> edges G. 0 \\<le> w))> \n    dijkstra_imp n Gi v0 \n  <\\<lambda>mi. (is_graph n Id) G Gi \n      * (\\<exists>\\<^sub>Am. drmap_assn n m mi * \\<up>(weighted_graph.is_shortest_path_map G v0 m)) >\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_graph n Id G Gi *\n     \\<up>\n      (v0 \\<in> nodes G \\<and>\n       (\\<forall>(v, w, v')\\<in>edges G.\n           (0::'a)\n           \\<le> w))> dijkstra_imp n Gi\n                       v0 <\\<lambda>r.\n                              is_graph n Id G Gi *\n                              (\\<exists>\\<^sub>Am.\n                                  drmap_assn n m r *\n                                  \\<up>\n                                   (weighted_graph.is_shortest_path_map G v0\n                                     m))>\\<^sub>t", "using dijkstra_imp_correct[to_hnr, of v0 G n v0 Gi]"], ["proof (prove)\nusing this:\n  \\<lbrakk>v0 \\<in> nodes G;\n   \\<forall>(v, w, v')\\<in>edges G. (0::'a) \\<le> w\\<rbrakk>\n  \\<Longrightarrow> hn_refine\n                     (hn_ctxt (nbn_assn n) v0 v0 *\n                      hn_ctxt (is_graph n Id) G Gi)\n                     (dijkstra_imp n $ Gi $ v0)\n                     (hn_ctxt (nbn_assn n) v0 v0 *\n                      hn_ctxt (is_graph n Id) G Gi)\n                     (drmap_assn n)\n                     ((SPEC \\<circ>\\<circ>\n                       weighted_graph.is_shortest_path_map) $\n                      G $\n                      v0)\n\ngoal (1 subgoal):\n 1. <is_graph n Id G Gi *\n     \\<up>\n      (v0 \\<in> nodes G \\<and>\n       (\\<forall>(v, w, v')\\<in>edges G.\n           (0::'a)\n           \\<le> w))> dijkstra_imp n Gi\n                       v0 <\\<lambda>r.\n                              is_graph n Id G Gi *\n                              (\\<exists>\\<^sub>Am.\n                                  drmap_assn n m r *\n                                  \\<up>\n                                   (weighted_graph.is_shortest_path_map G v0\n                                     m))>\\<^sub>t", "unfolding hn_refine_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>v0 \\<in> nodes G;\n   \\<forall>(v, w, v')\\<in>edges G. (0::'a) \\<le> w\\<rbrakk>\n  \\<Longrightarrow> nofail\n                     ((SPEC \\<circ>\\<circ>\n                       weighted_graph.is_shortest_path_map) $\n                      G $\n                      v0) \\<longrightarrow>\n                    <hn_ctxt (nbn_assn n) v0 v0 *\n                     hn_ctxt (is_graph n Id) G\n                      Gi> dijkstra_imp n $ Gi $\n                          v0 <\\<lambda>r.\n                                 hn_ctxt (nbn_assn n) v0 v0 *\n                                 hn_ctxt (is_graph n Id) G Gi *\n                                 (\\<exists>\\<^sub>Ax.\n                                     drmap_assn n x r *\n                                     \\<up>\n(RETURN x\n \\<le> (SPEC \\<circ>\\<circ> weighted_graph.is_shortest_path_map) $ G $\n       v0))>\\<^sub>t\n\ngoal (1 subgoal):\n 1. <is_graph n Id G Gi *\n     \\<up>\n      (v0 \\<in> nodes G \\<and>\n       (\\<forall>(v, w, v')\\<in>edges G.\n           (0::'a)\n           \\<le> w))> dijkstra_imp n Gi\n                       v0 <\\<lambda>r.\n                              is_graph n Id G Gi *\n                              (\\<exists>\\<^sub>Am.\n                                  drmap_assn n m r *\n                                  \\<up>\n                                   (weighted_graph.is_shortest_path_map G v0\n                                     m))>\\<^sub>t", "apply (clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk><hn_ctxt (nbn_assn n) v0 v0 * hn_ctxt (is_graph n Id) G Gi>\n             dijkstra_imp n Gi v0\n             <\\<lambda>r.\n                 \\<exists>\\<^sub>Ax.\n                    hn_ctxt (nbn_assn n) v0 v0 *\n                    hn_ctxt (is_graph n Id) G Gi *\n                    drmap_assn n x r *\n                    true *\n                    \\<up> (weighted_graph.is_shortest_path_map G v0 x)>;\n     v0 \\<in> nodes G;\n     \\<forall>x\\<in>edges G.\n        case x of (v, w, v') \\<Rightarrow> (0::'a) \\<le> w\\<rbrakk>\n    \\<Longrightarrow> <is_graph n Id G Gi> dijkstra_imp n Gi v0\n                      <\\<lambda>r.\n                          \\<exists>\\<^sub>Am.\n                             is_graph n Id G Gi * drmap_assn n m r * true *\n                             \\<up>\n                              (weighted_graph.is_shortest_path_map G v0 m)>", "apply (erule cons_rule[rotated -1])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>v0 \\<in> nodes G;\n     \\<forall>x\\<in>edges G.\n        case x of (v, w, v') \\<Rightarrow> (0::'a) \\<le> w\\<rbrakk>\n    \\<Longrightarrow> is_graph n Id G Gi \\<Longrightarrow>\\<^sub>A\n                      hn_ctxt (nbn_assn n) v0 v0 *\n                      hn_ctxt (is_graph n Id) G Gi\n 2. \\<And>x.\n       \\<lbrakk>v0 \\<in> nodes G;\n        \\<forall>x\\<in>edges G.\n           case x of (v, w, v') \\<Rightarrow> (0::'a) \\<le> w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<^sub>Axa.\n                            hn_ctxt (nbn_assn n) v0 v0 *\n                            hn_ctxt (is_graph n Id) G Gi *\n                            drmap_assn n xa x *\n                            true *\n                            \\<up>\n                             (weighted_graph.is_shortest_path_map G v0\n                               xa) \\<Longrightarrow>\\<^sub>A\n                         \\<exists>\\<^sub>Am.\n                            is_graph n Id G Gi * drmap_assn n m x * true *\n                            \\<up>\n                             (weighted_graph.is_shortest_path_map G v0 m)", "apply (sep_auto simp: hn_ctxt_def pure_def is_graph_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>v0 \\<in> nodes G;\n        \\<forall>x\\<in>edges G.\n           case x of (v, w, v') \\<Rightarrow> (0::'a) \\<le> w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<^sub>Axa.\n                            hn_ctxt (nbn_assn n) v0 v0 *\n                            hn_ctxt (is_graph n Id) G Gi *\n                            drmap_assn n xa x *\n                            true *\n                            \\<up>\n                             (weighted_graph.is_shortest_path_map G v0\n                               xa) \\<Longrightarrow>\\<^sub>A\n                         \\<exists>\\<^sub>Am.\n                            is_graph n Id G Gi * drmap_assn n m x * true *\n                            \\<up>\n                             (weighted_graph.is_shortest_path_map G v0 m)", "apply (sep_auto simp: hn_ctxt_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}