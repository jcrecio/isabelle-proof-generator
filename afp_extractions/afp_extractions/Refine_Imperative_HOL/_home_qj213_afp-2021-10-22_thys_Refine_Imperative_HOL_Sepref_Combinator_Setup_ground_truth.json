{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/Sepref_Combinator_Setup.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemma unit_eq: \"(a::unit) \\<equiv> b\"", "lemma map_type_eqI: \"map_type_eq L R\"", "lemma start_eval: \"x \\<equiv> SP x\"", "lemma add_eval: \"f x \\<equiv> (\\<bind>)$(EVAL$x)$(\\<lambda>\\<^sub>2x. f x)\"", "lemma init_mk_arity: \"f \\<equiv> id (SP f)\"", "lemma add_mk_arity: \"id f \\<equiv> (\\<lambda>\\<^sub>2x. id (f$x))\"", "lemma finish_mk_arity: \"id f \\<equiv> f\"", "lemma \n      mk_mcomb1: \"\\<And>c. c$x1 \\<equiv> (\\<bind>)$(EVAL$x1)$(\\<lambda>\\<^sub>2x1. SP (c$x1))\"\n  and mk_mcomb2: \"\\<And>c. c$x1$x2 \\<equiv> (\\<bind>)$(EVAL$x1)$(\\<lambda>\\<^sub>2x1. (\\<bind>)$(EVAL$x2)$(\\<lambda>\\<^sub>2x2. SP (c$x1$x2)))\"\n  and mk_mcomb3: \"\\<And>c. c$x1$x2$x3 \\<equiv> (\\<bind>)$(EVAL$x1)$(\\<lambda>\\<^sub>2x1. (\\<bind>)$(EVAL$x2)$(\\<lambda>\\<^sub>2x2. (\\<bind>)$(EVAL$x3)$(\\<lambda>\\<^sub>2x3. SP (c$x1$x2$x3))))\""], "translations": [["", "lemma unit_eq: \"(a::unit) \\<equiv> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<equiv> b", "by simp"], ["", "named_theorems \"__itype_rewrite\""], ["", "ML \\<open>\n    signature SEPREF_INTF_TYPES = sig\n      (* Declare new interface type *)\n      val decl_intf_type_cmd: ((string list * binding) * mixfix) * string -> local_theory -> local_theory\n      (* Register interface type rewrite rule *)\n      val register_itype_rewrite: typ -> typ -> Proof.context -> local_theory\n\n      (* Convert interface type to logical type*)\n      val norm_intf_type: Proof.context -> typ -> typ\n\n      (* Check whether interface type matches operation's type *)\n      val check_intf_type: Proof.context -> typ -> typ -> bool\n      (* Invoke msg with (normalized) non-matching types in case of no-match *)\n      val check_intf_type_msg: (typ * typ -> unit) -> Proof.context -> typ -> typ -> unit\n      (* Trigger error message if no match *)\n      val check_intf_type_err: Proof.context -> typ -> typ -> unit\n\n    end\n\n    structure Sepref_Intf_Types: SEPREF_INTF_TYPES = struct\n      fun t2t (Type(name,args)) = \n        @{term T}\n          $HOLogic.mk_string name\n          $HOLogic.mk_list @{typ unit} (map t2t args)\n      | t2t (TFree (name,_)) = Var ((\"F\"^name,0),HOLogic.unitT)\n      | t2t (TVar ((name,i),_)) = Var ((\"V\"^name,i),HOLogic.unitT)\n  \n      fun tt2 (t as (Var ((name,i),_))) = \n        if match_string \"F*\" name then TFree (unprefix \"F\" name, dummyS)\n        else if match_string \"V*\" name then TVar ((unprefix \"V\" name,i), dummyS)\n        else raise TERM(\"tt2: Invalid var\",[t])\n      | tt2 @{mpat \"T ?name ?args\"} = Type (HOLogic.dest_string name, HOLogic.dest_list args |> map tt2)\n      | tt2 t = raise TERM(\"tt2: Invalid\",[t])\n  \n      fun mk_t2t_rew ctxt T1 T2 = let\n        fun chk_vars T = exists_subtype is_TVar T andalso raise TYPE(\"Type must not contain schematics\",[T],[])\n        val _ = chk_vars T1 \n        val _ = chk_vars T2\n  \n        val free1 = Term.add_tfreesT T1 []\n        val free2 = Term.add_tfreesT T2 []\n  \n        val _ = subset (=) (free2,free1) orelse raise TYPE(\"Free variables on RHS must also occur on LHS\",[T1,T2],[])\n  \n      in\n        Thm.instantiate' [] [\n            t2t T1 |> Thm.cterm_of ctxt |> SOME,\n            t2t T2 |> Thm.cterm_of ctxt |> SOME\n          ] \n          @{thm unit_eq}\n      end\n  \n      fun register_itype_rewrite T1 T2 lthy =\n        lthy \n        |> Local_Theory.note ((Binding.empty,@{attributes [\"__itype_rewrite\"]}),[mk_t2t_rew lthy T1 T2])\n        |> #2\n  \n      val decl_intf_type_parser = \n        Parse.type_args -- Parse.binding -- Parse.opt_mixfix --| @{keyword \"is\"} -- Parse.typ\n  \n      fun decl_intf_type_cmd (((args,a),mx),T2_raw) lthy = let\n        val (T1,lthy) = Typedecl.typedecl {final = true} (a, map (rpair dummyS) args, mx) lthy\n        val T2 = Syntax.read_typ lthy T2_raw\n      in \n        register_itype_rewrite T1 T2 lthy\n      end\n  \n      fun norm_intf_typet ctxt T = let\n        val rew_rls = Named_Theorems.get ctxt @{named_theorems \"__itype_rewrite\"}\n      in  \n           t2t T \n        |> Thm.cterm_of ctxt \n        |> Drule.mk_term\n        |> Local_Defs.unfold0 ctxt rew_rls\n        |> Drule.dest_term\n        |> Thm.term_of\n      end\n  \n      fun norm_intf_type ctxt T = norm_intf_typet ctxt T |> tt2\n  \n      fun check_intf_type ctxt iT cT = let\n        val it = norm_intf_typet ctxt iT\n        val ct = t2t cT\n        val thy = Proof_Context.theory_of ctxt\n      in\n        Pattern.matches thy (it,ct)\n      end\n  \n      fun check_intf_type_msg msg ctxt iT cT = let\n        val it = norm_intf_typet ctxt iT\n        val ct = t2t cT\n        val thy = Proof_Context.theory_of ctxt\n      in\n        if Pattern.matches thy (it,ct) then ()\n        else msg (tt2 it, tt2 ct)\n      end\n  \n      fun check_intf_type_err ctxt iT cT = let\n        fun msg (iT',cT') = Pretty.block [\n          Pretty.str \"Interface type and logical type do not match\",\n          Pretty.fbrk,\n          Pretty.str \"Interface: \",Syntax.pretty_typ ctxt iT, Pretty.brk 1, \n          Pretty.str \"  is   \", Syntax.pretty_typ ctxt iT', Pretty.fbrk,\n          Pretty.str \"Logical: \",Syntax.pretty_typ ctxt cT, Pretty.brk 1, \n          Pretty.str \"  is   \", Syntax.pretty_typ ctxt cT', Pretty.fbrk\n        ] |> Pretty.string_of |> error\n\n      in\n        check_intf_type_msg msg ctxt iT cT\n      end\n\n      val _ =\n        Outer_Syntax.local_theory \n          @{command_keyword \"sepref_decl_intf\"} \n          \"Declare interface type\"\n          ( decl_intf_type_parser >> decl_intf_type_cmd);\n    end\n  \\<close>"], ["", "end"], ["", "subsection \\<open>Rewriting Inferred Interface Types\\<close>"], ["", "definition map_type_eq :: \"'a itself \\<Rightarrow> 'b itself \\<Rightarrow> bool\" \n  (infixr \"\\<rightarrow>\\<^sub>n\\<^sub>t\" 60)\n  where [simp]: \"map_type_eq _ _ \\<equiv> True\""], ["", "lemma map_type_eqI: \"map_type_eq L R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L \\<rightarrow>\\<^sub>n\\<^sub>t R", "by auto"], ["", "named_theorems_rev map_type_eqs"], ["", "subsection \\<open>ML-Code\\<close>"], ["", "context begin"], ["", "private"], ["", "lemma start_eval: \"x \\<equiv> SP x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<equiv> SP x", "by auto"], ["", "private"], ["", "lemma add_eval: \"f x \\<equiv> (\\<bind>)$(EVAL$x)$(\\<lambda>\\<^sub>2x. f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x \\<equiv> (\\<bind>) $ (EVAL $ x) $ (\\<lambda>x. (#f x#))", "by auto"], ["", "private"], ["", "lemma init_mk_arity: \"f \\<equiv> id (SP f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<equiv> id (SP f)", "by simp"], ["", "private"], ["", "lemma add_mk_arity: \"id f \\<equiv> (\\<lambda>\\<^sub>2x. id (f$x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. id f \\<equiv> \\<lambda>x. (#id (f $ x)#)", "by auto"], ["", "private"], ["", "lemma finish_mk_arity: \"id f \\<equiv> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. id f \\<equiv> f", "by simp"], ["", "ML \\<open>\n  structure Sepref_Combinator_Setup = struct\n\n    (* Check whether this term is a valid abstract operation *)\n    fun is_valid_abs_op _ (Const _) = true\n      | is_valid_abs_op ctxt (Free (name,_)) = Variable.is_fixed ctxt name\n      | is_valid_abs_op _ @{mpat \"PR_CONST _\"} = true\n      | is_valid_abs_op _ _ = false\n\n    fun mk_itype ctxt t tyt = let\n      val cert = Thm.cterm_of ctxt\n      val t = cert t\n      val tyt = cert tyt\n    in\n      Drule.infer_instantiate' ctxt [SOME t, SOME tyt] @{thm itypeI}\n    end\n\n    (* Generate mcomb-theorem, required for monadify transformation.\n      t$x1$...$xn = x1\\<leftarrow>EVAL x1; ...; xn\\<leftarrow>EVAL xn; SP (t$x1$...$xn)\n    *)\n    fun mk_mcomb ctxt t n = let\n      val T = fastype_of t\n      val (argsT,_) = strip_type T\n      val _ = length argsT >= n orelse raise TERM(\"Too few arguments\",[t])\n      val effT = take n argsT\n\n      val orig_ctxt = ctxt\n      val names = map (fn i => \"x\"^string_of_int i) (1 upto n)\n      val (names,ctxt) = Variable.variant_fixes names ctxt\n      val vars = map Free (names ~~ effT)\n\n      val lhs = Autoref_Tagging.list_APP (t,vars)\n        |> Thm.cterm_of ctxt\n     \n      fun add_EVAL x thm = \n        case Thm.prop_of thm of\n          @{mpat \"_ \\<equiv> ?rhs\"} => let\n            val f = lambda x rhs |> Thm.cterm_of ctxt\n            val x = Thm.cterm_of ctxt x\n            val eval_thm = Drule.infer_instantiate' ctxt\n              [SOME f, SOME x] @{thm add_eval}\n            val thm = @{thm transitive} OF [thm,eval_thm]\n          in thm end\n        | _ => raise THM (\"mk_mcomb internal: Expected lhs==rhs\",~1,[thm])  \n\n      val thm = Drule.infer_instantiate' ctxt [SOME lhs] @{thm start_eval}\n      val thm = fold add_EVAL (rev vars) thm\n      val thm = singleton (Proof_Context.export ctxt orig_ctxt) thm\n    in\n      thm\n    end;\n\n    (*\n      Generate arity-theorem: t = \\<lambda>x1...xn. SP t$x1$...$xn\n    *)\n    fun mk_arity ctxt t n = let\n      val t = Thm.cterm_of ctxt t\n      val thm = Drule.infer_instantiate' ctxt [SOME t] @{thm init_mk_arity}\n      val add_mk_arity = Conv.fconv_rule (\n        Refine_Util.ftop_conv (K (Conv.rewr_conv @{thm add_mk_arity})) ctxt)\n      val thm = funpow n add_mk_arity thm\n      val thm = Conv.fconv_rule (\n        Refine_Util.ftop_conv (K (Conv.rewr_conv @{thm finish_mk_arity})) ctxt) thm\n    in\n      thm\n    end;\n\n    datatype opkind = PURE | COMB\n\n\n    fun analyze_decl c tyt = let\n      fun add_tcons_of (Type (name,args)) l = fold add_tcons_of args (name::l)\n        | add_tcons_of _ l = l\n\n      fun all_tcons_of P T = forall P (add_tcons_of T [])\n\n      val T = Logic.dest_type tyt\n      val (argsT,resT) = strip_type T\n\n      val _ = forall (all_tcons_of (fn tn => tn <> @{type_name nres})) argsT \n        orelse raise TYPE (\n          \"Arguments contain nres-type \"  \n        ^ \"(currently not supported by this attribute)\",\n        argsT,[c,tyt])\n\n      val kind = case resT of  \n        Type (@{type_name nres},_) => COMB\n      | T => let\n          val _ = all_tcons_of (fn tn => tn <> @{type_name nres}) T \n            orelse raise TYPE (\n              \"Result contains inner nres-type\",\n            argsT,[c,tyt])\n        in\n          PURE\n        end\n\n    in (kind,(argsT,resT)) end\n\n\n    fun analyze_itype_thm thm = \n      case Thm.prop_of thm of\n        @{mpat (typs) \"Trueprop (intf_type ?c (_::?'v_T itself))\"} => let\n          val tyt = Logic.mk_type T\n          val (kind,(argsT,resT)) = analyze_decl c tyt\n        in (c,kind,(argsT,resT)) end\n      | _ => raise THM(\"Invalid itype-theorem\",~1,[thm]) \n\n\n    (*fun register_combinator itype_thm context = let\n      val ctxt = Context.proof_of context\n      val (t,kind,(argsT,_)) = analyze_itype_thm itype_thm\n      val n = length argsT\n    in  \n      case kind of\n        PURE => context\n          |> Named_Theorems_Rev.add_thm @{named_theorems_rev id_rules} itype_thm\n      | COMB => let    \n          val arity_thm = mk_arity ctxt t n\n          (*val skel_thm = mk_skel ctxt t n*)\n          val mcomb_thm = mk_mcomb ctxt t n\n        in\n          context\n          |> Named_Theorems_Rev.add_thm @{named_theorems_rev id_rules} itype_thm\n          |> Named_Theorems_Rev.add_thm @{named_theorems_rev sepref_monadify_arity} arity_thm\n          |> Named_Theorems_Rev.add_thm @{named_theorems_rev sepref_monadify_comb} mcomb_thm\n          (*|> Named_Theorems_Rev.add_thm @{named_theorems_rev sepref_la_skel} skel_thm*)\n        end\n    end\n    *)\n    \n    fun generate_basename ctxt t = let\n      fun fail () = raise TERM (\"Basename generation heuristics failed. Specify a basename.\",[t])\n      fun gb (Const (n,_)) = \n        (* TODO: There should be a cleaner way than handling this on string level!*)\n        n |> space_explode \".\" |> List.last\n        | gb (@{mpat \"PR_CONST ?t\"}) = gb t\n        | gb (t as (_$_)) = let\n            val h = head_of t\n            val _ = is_Const h orelse is_Free h orelse fail ()\n          in\n            gb h\n          end\n        | gb (Free (n,_)) = \n            if Variable.is_fixed ctxt n then n \n            else fail ()\n        | gb _ = fail ()    \n    in\n      gb t \n    end\n\n    fun map_type_raw ctxt rls T = let\n      val thy = Proof_Context.theory_of ctxt\n  \n      fun rewr_this (lhs,rhs) T = let\n        val env = Sign.typ_match thy (lhs,T) Vartab.empty\n      in \n        Envir.norm_type env rhs\n      end\n  \n      fun map_Targs f (Type (name,args)) = Type (name,map f args)\n        | map_Targs _ T = T\n  \n      fun \n        rewr_thiss (r::rls) T = \n          (SOME (rewr_this r T) handle Type.TYPE_MATCH => rewr_thiss rls T)\n      | rewr_thiss [] _ = NONE\n  \n      fun \n        map_type_aux T = \n          let\n            val T = map_Targs map_type_aux T\n          in \n            case rewr_thiss rls T of\n              SOME T => map_type_aux T\n            | NONE => T  \n          end\n    in\n      map_type_aux T\n    end      \n\n    fun get_nt_rule thm = case Thm.prop_of thm of\n      @{mpat (typs) \"Trueprop (map_type_eq (_::?'v_L itself) (_::?'v_R itself))\"} =>\n      let\n        val Lvars = Term.add_tvar_namesT L []\n        val Rvars = Term.add_tvar_namesT R []\n\n        val _ = subset (=) (Rvars, Lvars) orelse (\n          let\n            val frees = subtract (=) Lvars Rvars\n              |> map (Term.string_of_vname)\n              |> Pretty.str_list \"[\" \"]\"\n              |> Pretty.string_of\n          in \n            raise THM (\"Free variables on RHS: \"^frees,~1,[thm])\n          end)\n\n      in\n        (L,R)\n      end\n\n    | _ => raise THM(\"No map_type_eq theorem\",~1,[thm])\n\n    fun map_type ctxt T = let\n      val rls = \n          Named_Theorems_Rev.get ctxt @{named_theorems_rev map_type_eqs}\n       |> map get_nt_rule\n    in map_type_raw ctxt rls T end  \n\n    fun read_term_type ts tys lthy = case tys of\n      SOME ty => let\n        val ty = Syntax.read_typ lthy ty \n        val ctxt = Variable.declare_typ ty lthy\n        val t = Syntax.read_term ctxt ts \n        val ctxt = Variable.declare_term t ctxt\n      in\n        ((t,ty),ctxt)\n      end\n    | NONE => let\n        val t = Syntax.read_term lthy ts\n        val ctxt = Variable.declare_term t lthy\n\n        val tyt = fastype_of t |> map_type ctxt |> Logic.mk_type\n\n        val tyt = tyt |> singleton (Variable.export_terms ctxt lthy)\n        val (tyt,ctxt) = yield_singleton (Variable.import_terms true) tyt ctxt\n        val ty = Logic.dest_type tyt\n      in  \n        ((t,ty),ctxt)\n      end\n  \n    fun check_type_intf ctxt Tc Ti = let\n      fun type2term (TFree (name,_)) = Var ((\"F\"^name,0),HOLogic.unitT)\n        | type2term (TVar ((name,i),_)) = Var ((\"V\"^name,i),HOLogic.unitT)\n        | type2term (Type (@{type_name \"fun\"},[T1,T2])) =\n            Free (\"F\",HOLogic.unitT --> HOLogic.unitT --> HOLogic.unitT)\n              $type2term T1$type2term T2\n        | type2term (Type (name,argsT)) = let\n            val args = map type2term argsT\n            val n = length args\n            val T = replicate n HOLogic.unitT ---> HOLogic.unitT\n            val v = Var ((\"T\"^name,0),T)\n          in list_comb (v, args) end\n    \n      val c = type2term Tc\n      val i = type2term Ti\n      val thy = Proof_Context.theory_of ctxt\n    in\n      Pattern.matches thy (i,c)\n    end\n\n    (* Import all terms into context, with disjoint free variables *)\n    fun import_terms_disj ts ctxt = let\n      fun exp ctxt t = let \n        val new_ctxt = Variable.declare_term t ctxt\n        val t = singleton (Variable.export_terms new_ctxt ctxt) t\n      in t end\n  \n      val ts = map (exp ctxt) ts\n  \n      fun cons_fst f a (l,b) = let val (a,b) = f a b in (a::l,b) end\n  \n      val (ts,ctxt) = fold_rev (cons_fst (yield_singleton (Variable.import_terms true))) ts ([],ctxt)\n    in\n      (ts,ctxt)\n    end\n  \n    type reg_thms = {\n      itype_thm: thm,\n      arity_thm: thm option,\n      mcomb_thm: thm option\n    }  \n\n    fun cr_reg_thms t ty ctxt = let\n      val orig_ctxt = ctxt\n      val tyt = Logic.mk_type ty\n      val ([t,tyt],ctxt) = import_terms_disj [t,tyt] ctxt\n\n      val (kind,(argsT,_)) = analyze_decl t tyt\n      val n = length argsT\n\n      val _ = Sepref_Intf_Types.check_intf_type_err ctxt ty (fastype_of t)\n\n      val _ = is_valid_abs_op ctxt t \n        orelse raise TERM(\"Malformed abstract operation. Use PR_CONST for complex terms.\",[t])\n      \n      val itype_thm = mk_itype ctxt t tyt \n        |> singleton (Variable.export ctxt orig_ctxt)\n    in\n      case kind of\n        PURE => {itype_thm = itype_thm, arity_thm = NONE, mcomb_thm = NONE}\n      | COMB => let    \n          val arity_thm = mk_arity ctxt t n \n            |> singleton (Variable.export ctxt orig_ctxt)\n          val mcomb_thm = mk_mcomb ctxt t n\n            |> singleton (Variable.export ctxt orig_ctxt)\n        in    \n          {itype_thm = itype_thm, arity_thm = SOME arity_thm, mcomb_thm = SOME mcomb_thm}\n        end\n    end\n\n    fun gen_pr_const_pat ctxt t = \n      if is_valid_abs_op ctxt t then (NONE,t)\n      else \n        let\n          val ct = Thm.cterm_of ctxt t\n          val thm = Drule.infer_instantiate' ctxt [SOME ct] @{thm UNPROTECT_def[symmetric]}\n            |> Conv.fconv_rule (Conv.arg1_conv (Id_Op.protect_conv ctxt))\n        in\n          (SOME thm,@{mk_term \"PR_CONST ?t\"})\n        end\n\n\n    fun sepref_register_single basename t ty lthy = let\n      fun mk_qualified basename q = Binding.qualify true basename (Binding.name q);\n      fun \n        do_note _ _ NONE = I\n      | do_note q attrs (SOME thm) = \n           Local_Theory.note ((mk_qualified basename q,attrs),[thm]) #> snd\n\n      val (pat_thm,t) = gen_pr_const_pat lthy t\n\n      val {itype_thm, arity_thm, mcomb_thm} = cr_reg_thms t ty lthy\n\n      val lthy = lthy\n          |> do_note \"pat\" @{attributes [def_pat_rules]} pat_thm\n          |> do_note \"itype\" @{attributes [id_rules]} (SOME itype_thm)\n          |> do_note \"arity\" @{attributes [sepref_monadify_arity]} arity_thm\n          |> do_note \"mcomb\" @{attributes [sepref_monadify_comb]} mcomb_thm\n      \n    in\n      (((arity_thm,mcomb_thm),itype_thm),lthy)\n    end\n\n    fun sepref_register_single_cmd ((basename,ts),tys) lthy = let\n      val t = Syntax.read_term lthy ts\n      val ty = map_option (Syntax.read_typ lthy) tys\n\n      val ty = case ty of SOME ty => ty | NONE => fastype_of t |> map_type lthy\n\n      val basename = case basename of\n        NONE => generate_basename lthy t\n        | SOME n => n\n      \n      val ((_,itype_thm),lthy) = sepref_register_single basename t ty lthy\n      val _ = Thy_Output.pretty_thm lthy itype_thm |> Pretty.string_of |> writeln\n\n    in\n      lthy\n    end\n\n    val sepref_register_cmd = fold sepref_register_single_cmd\n\n    val sepref_register_parser = Scan.repeat1 ( \n        Scan.option (Parse.name --| @{keyword \":\"}) \n        -- Parse.term \n        -- Scan.option (@{keyword \"::\"} |-- Parse.typ)\n      )\n\n    val _ =\n      Outer_Syntax.local_theory \n        @{command_keyword \"sepref_register\"} \n        \"Register operation for sepref\"\n        ( sepref_register_parser\n          >> sepref_register_cmd);\n\n    val sepref_register_adhoc_parser = Scan.repeat1 (\n      Args.term -- Scan.option (Scan.lift (Args.$$$ \"::\") |-- Args.typ)\n    )\n\n    fun sepref_register_adhoc_single (t,ty) context = let\n      val ctxt = Context.proof_of context\n\n      (* TODO: Map-type probably not clean, as it draws info from (current) context,\n        which may have changed if registered elsewhere ...\n      *)\n      val ty = case ty of SOME ty => ty | NONE => fastype_of t |> map_type ctxt\n\n      val (pat_thm,t) = gen_pr_const_pat ctxt t\n\n      val {itype_thm, arity_thm, mcomb_thm} = cr_reg_thms t ty ctxt\n      \n      fun app _ NONE = I\n        | app attr (SOME thm) = Thm.apply_attribute attr thm #> snd\n\n    in\n      context \n      |> app (Named_Theorems_Rev.add @{named_theorems_rev def_pat_rules}) pat_thm\n      |> app (Named_Theorems_Rev.add @{named_theorems_rev id_rules}) (SOME itype_thm)\n      |> app (Named_Theorems_Rev.add @{named_theorems_rev sepref_monadify_arity}) arity_thm\n      |> app (Named_Theorems_Rev.add @{named_theorems_rev sepref_monadify_comb}) mcomb_thm\n    end\n\n    val sepref_register_adhoc = fold sepref_register_adhoc_single\n\n    fun sepref_register_adhoc_attr ttys = Thm.declaration_attribute (K (sepref_register_adhoc ttys))\n\n    val sepref_register_adhoc_attr_decl = sepref_register_adhoc_parser >> sepref_register_adhoc_attr\n\n  end\n\\<close>"], ["", "end"], ["", "attribute_setup sepref_register_adhoc = Sepref_Combinator_Setup.sepref_register_adhoc_attr_decl\n  \\<open>Register operations in ad-hoc manner. Improper if this gets exported!\\<close>"], ["", "(*\nattribute_setup sepref_register_combinator = \n  \\<open>Scan.succeed (Thm.declaration_attribute Sepref_Combinator_Setup.register_combinator)\\<close>\n  \\<open>Register combinator by its itype-rule. Set up itype,skel,arity, and mcomb rules.\\<close>\n*)"], ["", "subsection \\<open>Obsolete Manual Setup Rules\\<close>"], ["", "lemma \n      mk_mcomb1: \"\\<And>c. c$x1 \\<equiv> (\\<bind>)$(EVAL$x1)$(\\<lambda>\\<^sub>2x1. SP (c$x1))\"\n  and mk_mcomb2: \"\\<And>c. c$x1$x2 \\<equiv> (\\<bind>)$(EVAL$x1)$(\\<lambda>\\<^sub>2x1. (\\<bind>)$(EVAL$x2)$(\\<lambda>\\<^sub>2x2. SP (c$x1$x2)))\"\n  and mk_mcomb3: \"\\<And>c. c$x1$x2$x3 \\<equiv> (\\<bind>)$(EVAL$x1)$(\\<lambda>\\<^sub>2x1. (\\<bind>)$(EVAL$x2)$(\\<lambda>\\<^sub>2x2. (\\<bind>)$(EVAL$x3)$(\\<lambda>\\<^sub>2x3. SP (c$x1$x2$x3))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        c $ x1 \\<equiv>\n        (\\<bind>) $ (EVAL $ x1) $ (\\<lambda>x. (#SP (c $ x)#))) &&&\n    (\\<And>c.\n        c $ x1 $ x2 \\<equiv>\n        (\\<bind>) $ (EVAL $ x1) $\n        (\\<lambda>x.\n            (#(\\<bind>) $ (EVAL $ x2) $\n              (\\<lambda>xa. (#SP (c $ x $ xa)#))#))) &&&\n    (\\<And>c.\n        c $ x1 $ x2 $ x3 \\<equiv>\n        (\\<bind>) $ (EVAL $ x1) $\n        (\\<lambda>x.\n            (#(\\<bind>) $ (EVAL $ x2) $\n              (\\<lambda>xa.\n                  (#(\\<bind>) $ (EVAL $ x3) $\n                    (\\<lambda>xb. (#SP (c $ x $ xa $ xb)#))#))#)))", "by auto"], ["", "end"]]}