{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/IICF/Impl/IICF_List_SetO.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemmas [fcomp_norm_unfold] = lso_assn_def[symmetric]", "lemma lso_is_pure[safe_constraint_rules]: \"is_pure A \\<Longrightarrow> is_pure (lso_assn A)\"", "lemma lso_empty_aref: \"(uncurry0 (RETURN []), uncurry0 (RETURN op_set_empty)) \n    \\<in> unit_rel  \\<rightarrow>\\<^sub>f \\<langle>br set (\\<lambda>_. True)\\<rangle>nres_rel\"", "lemma lso_ins_aref: \"(uncurry (RETURN oo ((#) )), uncurry (RETURN oo op_set_insert)) \n    \\<in> Id \\<times>\\<^sub>r br set (\\<lambda>_. True) \\<rightarrow>\\<^sub>f \\<langle>br set (\\<lambda>_. True)\\<rangle>nres_rel\"", "lemma lso_fold_custom_empty:\n    \"{} = op_lso_empty\"\n    \"op_set_empty = op_lso_empty\"", "lemmas [sepref_fr_rules] = lso_empty_hnr[folded op_lso_empty_def]", "lemma fold_lso_bex: \"Bex \\<equiv> \\<lambda>s P. op_lso_bex P s\"", "lemma op_mop_lso_bex:  \"RETURN (op_lso_bex P S) = mop_lso_bex (RETURN o P) S\"", "lemma lso_bex_arity[sepref_monadify_arity]: \n    \"op_lso_bex \\<equiv> \\<lambda>\\<^sub>2P s. SP op_lso_bex$(\\<lambda>\\<^sub>2x. P$x)$s\"", "lemma op_lso_bex_monadify[sepref_monadify_comb]:  \n    \"EVAL$(op_lso_bex$(\\<lambda>\\<^sub>2x. P x)$s) \\<equiv> (\\<bind>) $(EVAL$s)$(\\<lambda>\\<^sub>2s. mop_lso_bex$(\\<lambda>\\<^sub>2x. EVAL $ P x)$s)\"", "lemma lso_abex_to_set: \"lso_abex P l \\<le> mop_lso_bex P (set l)\"", "lemma [sepref_comb_rules]:\n      assumes \"\\<Gamma> \\<Longrightarrow>\\<^sub>t F' * F * hn_ctxt A x xi\"\n      assumes \"x\\<in>set l\"\n      shows \"hn_refine \\<Gamma> (Pi xi) (F' * F * hn_ctxt A x xi) bool_assn (P$x)\"", "lemma hn_lso_bex[sepref_prep_comb_rule,sepref_comb_rules]: \n    assumes FR: \"\\<Gamma> \\<Longrightarrow>\\<^sub>t hn_ctxt (lso_assn A) s li * F\"\n    assumes Prl: \"\\<And>x xi. \\<lbrakk>x\\<in>s\\<rbrakk> \\<Longrightarrow> hn_refine (F * hn_ctxt A x xi) (Pi xi) (F * hn_ctxt A x xi) bool_assn (P x)\"\n    notes [simp del] = mop_lso_bex_def\n    shows \"hn_refine \\<Gamma> (lso_bex_impl Pi li) (F * hn_ctxt (lso_assn A) s li) bool_assn (mop_lso_bex$(\\<lambda>\\<^sub>2x. P x)$s)\""], "translations": [["", "lemmas [fcomp_norm_unfold] = lso_assn_def[symmetric]"], ["", "lemma lso_is_pure[safe_constraint_rules]: \"is_pure A \\<Longrightarrow> is_pure (lso_assn A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pure A \\<Longrightarrow> is_pure (lso_assn A)", "unfolding lso_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pure A \\<Longrightarrow>\n    is_pure (hr_comp (list_assn A) (br set (\\<lambda>_. True)))", "by safe_constraint"], ["", "lemma lso_empty_aref: \"(uncurry0 (RETURN []), uncurry0 (RETURN op_set_empty)) \n    \\<in> unit_rel  \\<rightarrow>\\<^sub>f \\<langle>br set (\\<lambda>_. True)\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 (RETURN []), uncurry0 (RETURN op_set_empty))\n    \\<in> unit_rel \\<rightarrow>\\<^sub>f \\<langle>br set\n             (\\<lambda>_. True)\\<rangle>nres_rel", "by (auto simp: in_br_conv intro!: frefI nres_relI)"], ["", "lemma lso_ins_aref: \"(uncurry (RETURN oo ((#) )), uncurry (RETURN oo op_set_insert)) \n    \\<in> Id \\<times>\\<^sub>r br set (\\<lambda>_. True) \\<rightarrow>\\<^sub>f \\<langle>br set (\\<lambda>_. True)\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry (RETURN \\<circ>\\<circ> (#)),\n     uncurry (RETURN \\<circ>\\<circ> op_set_insert))\n    \\<in> Id \\<times>\\<^sub>r\n          br set\n           (\\<lambda>_.\n               True) \\<rightarrow>\\<^sub>f \\<langle>br set\n               (\\<lambda>_. True)\\<rangle>nres_rel", "by (auto simp: in_br_conv intro!: frefI nres_relI)"], ["", "sepref_decl_impl (no_register) lso_empty: hn_Nil[to_hfref] uses lso_empty_aref"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition [simp]: \"op_lso_empty \\<equiv> op_set_empty\""], ["", "lemma lso_fold_custom_empty:\n    \"{} = op_lso_empty\"\n    \"op_set_empty = op_lso_empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} = op_lso_empty &&& op_set_empty = op_lso_empty", "by auto"], ["", "lemmas [sepref_fr_rules] = lso_empty_hnr[folded op_lso_empty_def]"], ["", "sepref_decl_impl lso_insert: hn_Cons[to_hfref] uses lso_ins_aref"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "thm hn_Cons[FCOMP lso_ins_aref]"], ["", "(* TODO: Allow (controlled) backtracking over comb-rules, then we can have a general list-bex operation! *)"], ["", "definition [simp]: \"op_lso_bex P S \\<equiv> \\<exists>x\\<in>S. P x\""], ["", "lemma fold_lso_bex: \"Bex \\<equiv> \\<lambda>s P. op_lso_bex P s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Bex \\<equiv> \\<lambda>s P. op_lso_bex P s", "by auto"], ["", "definition [simp]: \"mop_lso_bex P S \\<equiv> ASSERT (\\<forall>x\\<in>S. \\<exists>y. P x = RETURN y) \\<then> RETURN (\\<exists>x\\<in>S. P x = RETURN True)\""], ["", "lemma op_mop_lso_bex:  \"RETURN (op_lso_bex P S) = mop_lso_bex (RETURN o P) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN (op_lso_bex P S) = mop_lso_bex (RETURN \\<circ> P) S", "by simp"], ["", "sepref_register op_lso_bex"], ["", "lemma lso_bex_arity[sepref_monadify_arity]: \n    \"op_lso_bex \\<equiv> \\<lambda>\\<^sub>2P s. SP op_lso_bex$(\\<lambda>\\<^sub>2x. P$x)$s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op_lso_bex \\<equiv>\n    \\<lambda>x.\n       (#\\<lambda>xa. (#SP op_lso_bex $ (\\<lambda>xa. (#x $ xa#)) $ xa#)#)", "by (auto intro!: eq_reflection ext)"], ["", "lemma op_lso_bex_monadify[sepref_monadify_comb]:  \n    \"EVAL$(op_lso_bex$(\\<lambda>\\<^sub>2x. P x)$s) \\<equiv> (\\<bind>) $(EVAL$s)$(\\<lambda>\\<^sub>2s. mop_lso_bex$(\\<lambda>\\<^sub>2x. EVAL $ P x)$s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. EVAL $ (op_lso_bex $ (\\<lambda>x. (#P x#)) $ s) \\<equiv>\n    (\\<bind>) $ (EVAL $ s) $\n    (\\<lambda>x. (#mop_lso_bex $ (\\<lambda>x. (#EVAL $ P x#)) $ x#))", "by simp"], ["", "definition \"lso_abex P l \\<equiv> nfoldli l (Not) (\\<lambda>x _. P x) False\""], ["", "lemma lso_abex_to_set: \"lso_abex P l \\<le> mop_lso_bex P (set l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lso_abex P l \\<le> mop_lso_bex P (set l)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lso_abex P l \\<le> mop_lso_bex P (set l)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. lso_abex P l \\<le> mop_lso_bex P (set l)", "fix b"], ["proof (state)\ngoal (1 subgoal):\n 1. lso_abex P l \\<le> mop_lso_bex P (set l)", "have \"nfoldli l (Not) (\\<lambda>x _. P x) b \\<le> ASSERT (\\<forall>x\\<in>set l. \\<exists>y. P x = RETURN y) \\<then> RETURN ((\\<exists>x\\<in>set l. P x = RETURN True) \\<or> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli l Not (\\<lambda>x _. P x) b\n    \\<le> ASSERT (\\<forall>x\\<in>set l. \\<exists>y. P x = RETURN y) \\<bind>\n          (\\<lambda>_.\n              RETURN ((\\<exists>x\\<in>set l. P x = RETURN True) \\<or> b))", "apply (induction l arbitrary: b)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b.\n       nfoldli [] Not (\\<lambda>x _. P x) b\n       \\<le> ASSERT\n              (\\<forall>x\\<in>set []. \\<exists>y. P x = RETURN y) \\<bind>\n             (\\<lambda>_.\n                 RETURN\n                  ((\\<exists>x\\<in>set []. P x = RETURN True) \\<or> b))\n 2. \\<And>a l b.\n       (\\<And>b.\n           nfoldli l Not (\\<lambda>x _. P x) b\n           \\<le> ASSERT\n                  (\\<forall>x\\<in>set l. \\<exists>y. P x = RETURN y) \\<bind>\n                 (\\<lambda>_.\n                     RETURN\n                      ((\\<exists>x\\<in>set l. P x = RETURN True) \\<or>\n                       b))) \\<Longrightarrow>\n       nfoldli (a # l) Not (\\<lambda>x _. P x) b\n       \\<le> ASSERT\n              (\\<forall>x\\<in>set (a # l).\n                  \\<exists>y. P x = RETURN y) \\<bind>\n             (\\<lambda>_.\n                 RETURN\n                  ((\\<exists>x\\<in>set (a # l). P x = RETURN True) \\<or> b))", "applyS simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l b.\n       (\\<And>b.\n           nfoldli l Not (\\<lambda>x _. P x) b\n           \\<le> ASSERT\n                  (\\<forall>x\\<in>set l. \\<exists>y. P x = RETURN y) \\<bind>\n                 (\\<lambda>_.\n                     RETURN\n                      ((\\<exists>x\\<in>set l. P x = RETURN True) \\<or>\n                       b))) \\<Longrightarrow>\n       nfoldli (a # l) Not (\\<lambda>x _. P x) b\n       \\<le> ASSERT\n              (\\<forall>x\\<in>set (a # l).\n                  \\<exists>y. P x = RETURN y) \\<bind>\n             (\\<lambda>_.\n                 RETURN\n                  ((\\<exists>x\\<in>set (a # l). P x = RETURN True) \\<or> b))", "applyS (clarsimp simp add: pw_le_iff refine_pw_simps; blast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  nfoldli l Not (\\<lambda>x _. P x) b\n  \\<le> ASSERT (\\<forall>x\\<in>set l. \\<exists>y. P x = RETURN y) \\<bind>\n        (\\<lambda>_.\n            RETURN ((\\<exists>x\\<in>set l. P x = RETURN True) \\<or> b))\n\ngoal (1 subgoal):\n 1. lso_abex P l \\<le> mop_lso_bex P (set l)", "}"], ["proof (state)\nthis:\n  nfoldli l Not (\\<lambda>x _. P x) ?b2\n  \\<le> ASSERT (\\<forall>x\\<in>set l. \\<exists>y. P x = RETURN y) \\<bind>\n        (\\<lambda>_.\n            RETURN ((\\<exists>x\\<in>set l. P x = RETURN True) \\<or> ?b2))\n\ngoal (1 subgoal):\n 1. lso_abex P l \\<le> mop_lso_bex P (set l)", "from this[of False]"], ["proof (chain)\npicking this:\n  nfoldli l Not (\\<lambda>x _. P x) False\n  \\<le> ASSERT (\\<forall>x\\<in>set l. \\<exists>y. P x = RETURN y) \\<bind>\n        (\\<lambda>_.\n            RETURN ((\\<exists>x\\<in>set l. P x = RETURN True) \\<or> False))", "show ?thesis"], ["proof (prove)\nusing this:\n  nfoldli l Not (\\<lambda>x _. P x) False\n  \\<le> ASSERT (\\<forall>x\\<in>set l. \\<exists>y. P x = RETURN y) \\<bind>\n        (\\<lambda>_.\n            RETURN ((\\<exists>x\\<in>set l. P x = RETURN True) \\<or> False))\n\ngoal (1 subgoal):\n 1. lso_abex P l \\<le> mop_lso_bex P (set l)", "by (simp add: lso_abex_def)"], ["proof (state)\nthis:\n  lso_abex P l \\<le> mop_lso_bex P (set l)\n\ngoal:\nNo subgoals!", "qed"], ["", "locale lso_bex_impl_loc = \n    fixes Pi and P :: \"'a \\<Rightarrow> bool nres\"\n    fixes li :: \"'c list\" and l :: \"'a list\"\n    fixes A :: \"'a \\<Rightarrow> 'c \\<Rightarrow> assn\"\n    fixes F :: assn\n    \n    assumes Prl: \"\\<And>x xi. \\<lbrakk>x\\<in>set l\\<rbrakk> \\<Longrightarrow> hn_refine (F * hn_ctxt A x xi) (Pi xi) (F * hn_ctxt A x xi) bool_assn (P x)\"\n  begin"], ["", "sepref_register l"], ["", "sepref_register P"], ["", "lemma [sepref_comb_rules]:\n      assumes \"\\<Gamma> \\<Longrightarrow>\\<^sub>t F' * F * hn_ctxt A x xi\"\n      assumes \"x\\<in>set l\"\n      shows \"hn_refine \\<Gamma> (Pi xi) (F' * F * hn_ctxt A x xi) bool_assn (P$x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine \\<Gamma> (Pi xi) (F' * F * hn_ctxt A x xi) bool_assn (P $ x)", "using hn_refine_frame[OF Prl[OF assms(2)], of \\<Gamma> F'] assms(1)"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<Longrightarrow>\\<^sub>t\n  F' * (F * hn_ctxt A x ?xi1) \\<Longrightarrow>\n  hn_refine \\<Gamma> (Pi ?xi1) (F' * (F * hn_ctxt A x ?xi1)) bool_assn (P x)\n  \\<Gamma> \\<Longrightarrow>\\<^sub>t F' * F * hn_ctxt A x xi\n\ngoal (1 subgoal):\n 1. hn_refine \\<Gamma> (Pi xi) (F' * F * hn_ctxt A x xi) bool_assn (P $ x)", "by (simp add: assn_assoc)"], ["", "schematic_goal lso_bex_impl: \n      \"hn_refine (hn_ctxt (list_assn A) l li * F) (?c) (F * hn_ctxt (list_assn A) l li) bool_assn (lso_abex P l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt (list_assn A) l li * F) ?c\n     (F * hn_ctxt (list_assn A) l li) bool_assn (lso_abex P l)", "unfolding lso_abex_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt (list_assn A) l li * F) ?c\n     (F * hn_ctxt (list_assn A) l li) bool_assn\n     (nfoldli l Not (\\<lambda>x _. P x) False)", "by sepref"], ["", "end"], ["", "concrete_definition lso_bex_impl uses lso_bex_impl_loc.lso_bex_impl"], ["", "lemma hn_lso_bex[sepref_prep_comb_rule,sepref_comb_rules]: \n    assumes FR: \"\\<Gamma> \\<Longrightarrow>\\<^sub>t hn_ctxt (lso_assn A) s li * F\"\n    assumes Prl: \"\\<And>x xi. \\<lbrakk>x\\<in>s\\<rbrakk> \\<Longrightarrow> hn_refine (F * hn_ctxt A x xi) (Pi xi) (F * hn_ctxt A x xi) bool_assn (P x)\"\n    notes [simp del] = mop_lso_bex_def\n    shows \"hn_refine \\<Gamma> (lso_bex_impl Pi li) (F * hn_ctxt (lso_assn A) s li) bool_assn (mop_lso_bex$(\\<lambda>\\<^sub>2x. P x)$s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine \\<Gamma> (lso_bex_impl Pi li) (F * hn_ctxt (lso_assn A) s li)\n     bool_assn (mop_lso_bex $ (\\<lambda>x. (#P x#)) $ s)", "apply (rule hn_refine_cons_pre[OF FR])"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt (lso_assn A) s li * F) (lso_bex_impl Pi li)\n     (F * hn_ctxt (lso_assn A) s li) bool_assn\n     (mop_lso_bex $ (\\<lambda>x. (#P x#)) $ s)", "apply (clarsimp simp: hn_ctxt_def lso_assn_def hr_comp_def in_br_conv hnr_pre_ex_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       hn_refine (list_assn A b li * F * \\<up> (s = set b))\n        (lso_bex_impl Pi li)\n        (\\<exists>\\<^sub>Ab. F * list_assn A b li * \\<up> (s = set b))\n        bool_assn (mop_lso_bex P s)", "apply (rule hn_refine_preI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b h.\n       h \\<Turnstile>\n       list_assn A b li * F * \\<up> (s = set b) \\<Longrightarrow>\n       hn_refine (list_assn A b li * F * \\<up> (s = set b))\n        (lso_bex_impl Pi li)\n        (\\<exists>\\<^sub>Ab. F * list_assn A b li * \\<up> (s = set b))\n        bool_assn (mop_lso_bex P s)", "apply (drule mod_starD; clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b a ba.\n       \\<lbrakk>s = set b;\n        (a, ba) \\<Turnstile> list_assn A b li * F\\<rbrakk>\n       \\<Longrightarrow> hn_refine (list_assn A b li * F)\n                          (lso_bex_impl Pi li)\n                          (\\<exists>\\<^sub>Aba.\n                              F * list_assn A ba li *\n                              \\<up> (set b = set ba))\n                          bool_assn (mop_lso_bex P (set b))", "apply (rule hn_refine_ref[OF lso_abex_to_set])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b a ba.\n       \\<lbrakk>s = set b;\n        (a, ba) \\<Turnstile> list_assn A b li * F\\<rbrakk>\n       \\<Longrightarrow> hn_refine (list_assn A b li * F)\n                          (lso_bex_impl Pi li)\n                          (\\<exists>\\<^sub>Aba.\n                              F * list_assn A ba li *\n                              \\<up> (set b = set ba))\n                          bool_assn (lso_abex P b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b a ba.\n       \\<lbrakk>s = set b;\n        (a, ba) \\<Turnstile> list_assn A b li * F\\<rbrakk>\n       \\<Longrightarrow> hn_refine (list_assn A b li * F)\n                          (lso_bex_impl Pi li)\n                          (\\<exists>\\<^sub>Aba.\n                              F * list_assn A ba li *\n                              \\<up> (set b = set ba))\n                          bool_assn (lso_abex P b)", "fix l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b a ba.\n       \\<lbrakk>s = set b;\n        (a, ba) \\<Turnstile> list_assn A b li * F\\<rbrakk>\n       \\<Longrightarrow> hn_refine (list_assn A b li * F)\n                          (lso_bex_impl Pi li)\n                          (\\<exists>\\<^sub>Aba.\n                              F * list_assn A ba li *\n                              \\<up> (set b = set ba))\n                          bool_assn (lso_abex P b)", "assume [simp]: \"s=set l\""], ["proof (state)\nthis:\n  s = set l\n\ngoal (1 subgoal):\n 1. \\<And>b a ba.\n       \\<lbrakk>s = set b;\n        (a, ba) \\<Turnstile> list_assn A b li * F\\<rbrakk>\n       \\<Longrightarrow> hn_refine (list_assn A b li * F)\n                          (lso_bex_impl Pi li)\n                          (\\<exists>\\<^sub>Aba.\n                              F * list_assn A ba li *\n                              \\<up> (set b = set ba))\n                          bool_assn (lso_abex P b)", "from Prl"], ["proof (chain)\npicking this:\n  ?x \\<in> s \\<Longrightarrow>\n  hn_refine (F * hn_ctxt A ?x ?xi) (Pi ?xi) (F * hn_ctxt A ?x ?xi) bool_assn\n   (P ?x)", "have Prl': \"\\<And>x xi. \\<lbrakk>x\\<in>set l\\<rbrakk> \\<Longrightarrow> hn_refine (F * hn_ctxt A x xi) (Pi xi) (F * hn_ctxt A x xi) bool_assn (P x)\""], ["proof (prove)\nusing this:\n  ?x \\<in> s \\<Longrightarrow>\n  hn_refine (F * hn_ctxt A ?x ?xi) (Pi ?xi) (F * hn_ctxt A ?x ?xi) bool_assn\n   (P ?x)\n\ngoal (1 subgoal):\n 1. \\<And>x xi.\n       x \\<in> set l \\<Longrightarrow>\n       hn_refine (F * hn_ctxt A x xi) (Pi xi) (F * hn_ctxt A x xi) bool_assn\n        (P x)", "by simp"], ["proof (state)\nthis:\n  ?x \\<in> set l \\<Longrightarrow>\n  hn_refine (F * hn_ctxt A ?x ?xi) (Pi ?xi) (F * hn_ctxt A ?x ?xi) bool_assn\n   (P ?x)\n\ngoal (1 subgoal):\n 1. \\<And>b a ba.\n       \\<lbrakk>s = set b;\n        (a, ba) \\<Turnstile> list_assn A b li * F\\<rbrakk>\n       \\<Longrightarrow> hn_refine (list_assn A b li * F)\n                          (lso_bex_impl Pi li)\n                          (\\<exists>\\<^sub>Aba.\n                              F * list_assn A ba li *\n                              \\<up> (set b = set ba))\n                          bool_assn (lso_abex P b)", "show \"hn_refine (list_assn A l li * F) (lso_bex_impl Pi li) (\\<exists>\\<^sub>Aba. F * list_assn A ba li * \\<up> (set l = set ba)) bool_assn\n           (lso_abex P l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (list_assn A l li * F) (lso_bex_impl Pi li)\n     (\\<exists>\\<^sub>Aba. F * list_assn A ba li * \\<up> (set l = set ba))\n     bool_assn (lso_abex P l)", "apply (rule hn_refine_cons[OF _ lso_bex_impl.refine])"], ["proof (prove)\ngoal (4 subgoals):\n 1. list_assn A l li * F \\<Longrightarrow>\\<^sub>t\n    hn_ctxt (list_assn ?A1) l li * ?F1\n 2. lso_bex_impl_loc Pi P l ?A1 ?F1\n 3. ?F1 * hn_ctxt (list_assn ?A1) l li \\<Longrightarrow>\\<^sub>t\n    \\<exists>\\<^sub>Aba. F * list_assn A ba li * \\<up> (set l = set ba)\n 4. \\<And>x y. bool_assn x y \\<Longrightarrow>\\<^sub>t bool_assn x y", "applyS (simp add: hn_ctxt_def; rule entt_refl)"], ["proof (prove)\ngoal (3 subgoals):\n 1. lso_bex_impl_loc Pi P l A F\n 2. F * hn_ctxt (list_assn A) l li \\<Longrightarrow>\\<^sub>t\n    \\<exists>\\<^sub>Aba. F * list_assn A ba li * \\<up> (set l = set ba)\n 3. \\<And>x y. bool_assn x y \\<Longrightarrow>\\<^sub>t bool_assn x y", "apply1 unfold_locales"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xi.\n       x \\<in> set l \\<Longrightarrow>\n       hn_refine (F * hn_ctxt A x xi) (Pi xi) (F * hn_ctxt A x xi) bool_assn\n        (P x)\n 2. F * hn_ctxt (list_assn A) l li \\<Longrightarrow>\\<^sub>t\n    \\<exists>\\<^sub>Aba. F * list_assn A ba li * \\<up> (set l = set ba)\n 3. \\<And>x y. bool_assn x y \\<Longrightarrow>\\<^sub>t bool_assn x y", "apply1 (rule Prl')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xi. x \\<in> set l \\<Longrightarrow> x \\<in> set l\n 2. F * hn_ctxt (list_assn A) l li \\<Longrightarrow>\\<^sub>t\n    \\<exists>\\<^sub>Aba. F * list_assn A ba li * \\<up> (set l = set ba)\n 3. \\<And>x y. bool_assn x y \\<Longrightarrow>\\<^sub>t bool_assn x y", "applyS simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. F * hn_ctxt (list_assn A) l li \\<Longrightarrow>\\<^sub>t\n    \\<exists>\\<^sub>Aba. F * list_assn A ba li * \\<up> (set l = set ba)\n 2. \\<And>x y. bool_assn x y \\<Longrightarrow>\\<^sub>t bool_assn x y", "applyS (sep_auto intro!: enttI simp: hn_ctxt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. bool_assn x y \\<Longrightarrow>\\<^sub>t bool_assn x y", "applyS (rule entt_refl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  hn_refine (list_assn A l li * F) (lso_bex_impl Pi li)\n   (\\<exists>\\<^sub>Aba. F * list_assn A ba li * \\<up> (set l = set ba))\n   bool_assn (lso_abex P l)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}