{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/Sepref_Tool.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemma CONS_init: \n  assumes \"hn_refine \\<Gamma> c \\<Gamma>' R a\"\n  assumes \"\\<Gamma>' \\<Longrightarrow>\\<^sub>t \\<Gamma>c'\"\n  assumes \"\\<And>a c. hn_ctxt R a c \\<Longrightarrow>\\<^sub>t hn_ctxt Rc a c\"\n  shows \"hn_refine \\<Gamma> c \\<Gamma>c' Rc a\"", "lemma ID_init: \"\\<lbrakk>ID a a' TYPE('T); hn_refine \\<Gamma> c \\<Gamma>' R a'\\<rbrakk> \n  \\<Longrightarrow> hn_refine \\<Gamma> c \\<Gamma>' R a\"", "lemma TRANS_init: \"\\<lbrakk> hn_refine \\<Gamma> c \\<Gamma>' R a; CNV c c' \\<rbrakk> \n  \\<Longrightarrow> hn_refine \\<Gamma> c' \\<Gamma>' R a\"", "lemma infer_post_triv: \"P \\<Longrightarrow>\\<^sub>t P\"", "lemma return_bind_eq_let: \"do { x\\<leftarrow>return v; f x } = do { let x=v; f x }\"", "lemmas [sepref_opt_simps] = return_bind_eq_let bind_return bind_bind id_def", "lemmas [sepref_opt_simps] = Autoref_Tagging.APP_def", "lemma case_prod_return_opt[sepref_opt_simps]:\n  \"case_prod (\\<lambda>a b. return (f a b)) p = return (case_prod f p)\"", "lemma case_option_return_opt[sepref_opt_simps]:\n  \"case_option (return fn) (\\<lambda>s. return (fs s)) v = return (case_option fn fs v)\"", "lemma case_list_return[sepref_opt_simps]:\n  \"case_list (return fn) (\\<lambda>x xs. return (fc x xs)) l = return (case_list fn fc l)\"", "lemma if_return[sepref_opt_simps]:\n  \"If b (return t) (return e) = return (If b t e)\"", "lemma case_prod_opt2[sepref_opt_simps2]:\n  \"(\\<lambda>x. return (case x of (a,b) \\<Rightarrow> f a b)) \n  = (\\<lambda>(a,b). return (f a b))\"", "lemma fold_COPY: \"x = COPY x\"", "lemma hnr_pure_COPY[sepref_fr_rules]:\n  \"CONSTRAINT is_pure R \\<Longrightarrow> (return, RETURN o COPY) \\<in> R\\<^sup>k \\<rightarrow>\\<^sub>a R\"", "lemma short_circuit_conv:  \n  \"(a \\<and> b) \\<longleftrightarrow> (if a then b else False)\"\n  \"(a \\<or> b) \\<longleftrightarrow> (if a then True else b)\"\n  \"(a\\<longrightarrow>b) \\<longleftrightarrow> (if a then b else True)\"", "lemma ho_prod_move[sepref_preproc]: \"case_prod (\\<lambda>a b x. f x a b) = (\\<lambda>p x. case_prod (f x) p)\"", "lemma prec_specI: \"h \\<Turnstile> \\<Gamma> \\<and>\\<^sub>A \\<Gamma>' \\<Longrightarrow> prec_spec h \\<Gamma> \\<Gamma>'\"", "lemma prec_split1_aux: \"A*B*true \\<Longrightarrow>\\<^sub>A A*true\"", "lemma prec_split2_aux: \"A*B*true \\<Longrightarrow>\\<^sub>A B*true\"", "lemma prec_spec_splitE: \n    assumes \"prec_spec h (A*B) (C*D)\"  \n    obtains \"prec_spec h A C\" \"prec_spec h B D\"", "lemma prec_specD:\n    assumes \"precise R\"\n    assumes \"prec_spec h (R a p) (R a' p)\"\n    shows \"a=a'\"", "lemma split_merge: \"\\<lbrakk>A \\<or>\\<^sub>A B \\<Longrightarrow>\\<^sub>t X; X \\<or>\\<^sub>A C \\<Longrightarrow>\\<^sub>t D\\<rbrakk> \\<Longrightarrow> (A \\<or>\\<^sub>A B \\<or>\\<^sub>A C \\<Longrightarrow>\\<^sub>t D)\""], "translations": [["", "lemma CONS_init: \n  assumes \"hn_refine \\<Gamma> c \\<Gamma>' R a\"\n  assumes \"\\<Gamma>' \\<Longrightarrow>\\<^sub>t \\<Gamma>c'\"\n  assumes \"\\<And>a c. hn_ctxt R a c \\<Longrightarrow>\\<^sub>t hn_ctxt Rc a c\"\n  shows \"hn_refine \\<Gamma> c \\<Gamma>c' Rc a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine \\<Gamma> c \\<Gamma>c' Rc a", "apply (rule hn_refine_cons)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<Gamma> \\<Longrightarrow>\\<^sub>t ?P'\n 2. hn_refine ?P' c ?Q ?R a\n 3. ?Q \\<Longrightarrow>\\<^sub>t \\<Gamma>c'\n 4. \\<And>x y. ?R x y \\<Longrightarrow>\\<^sub>t Rc x y", "apply (rule entt_refl)"], ["proof (prove)\ngoal (3 subgoals):\n 1. hn_refine \\<Gamma> c ?Q ?R a\n 2. ?Q \\<Longrightarrow>\\<^sub>t \\<Gamma>c'\n 3. \\<And>x y. ?R x y \\<Longrightarrow>\\<^sub>t Rc x y", "apply (rule assms[unfolded hn_ctxt_def])+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ID_init: \"\\<lbrakk>ID a a' TYPE('T); hn_refine \\<Gamma> c \\<Gamma>' R a'\\<rbrakk> \n  \\<Longrightarrow> hn_refine \\<Gamma> c \\<Gamma>' R a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ID a a' TYPE('T); hn_refine \\<Gamma> c \\<Gamma>' R a'\\<rbrakk>\n    \\<Longrightarrow> hn_refine \\<Gamma> c \\<Gamma>' R a", "by simp"], ["", "lemma TRANS_init: \"\\<lbrakk> hn_refine \\<Gamma> c \\<Gamma>' R a; CNV c c' \\<rbrakk> \n  \\<Longrightarrow> hn_refine \\<Gamma> c' \\<Gamma>' R a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hn_refine \\<Gamma> c \\<Gamma>' R a; CNV c c'\\<rbrakk>\n    \\<Longrightarrow> hn_refine \\<Gamma> c' \\<Gamma>' R a", "by simp"], ["", "lemma infer_post_triv: \"P \\<Longrightarrow>\\<^sub>t P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<Longrightarrow>\\<^sub>t P", "by (rule entt_refl)"], ["", "ML \\<open>\n  structure Sepref = struct\n    structure sepref_preproc_simps = Named_Thms (\n      val name = @{binding sepref_preproc}\n      val description = \"Sepref: Preprocessor simplifications\"\n    )\n\n    structure sepref_opt_simps = Named_Thms (\n      val name = @{binding sepref_opt_simps}\n      val description = \"Sepref: Post-Translation optimizations, phase 1\"\n    )\n\n    structure sepref_opt_simps2 = Named_Thms (\n      val name = @{binding sepref_opt_simps2}\n      val description = \"Sepref: Post-Translation optimizations, phase 2\"\n    )\n\n    fun cons_init_tac ctxt = Sepref_Frame.weaken_post_tac ctxt THEN' resolve_tac ctxt @{thms CONS_init}\n    fun cons_solve_tac dbg ctxt = let\n      val dbgSOLVED' = if dbg then I else SOLVED'\n    in\n      dbgSOLVED' (\n        resolve_tac ctxt @{thms infer_post_triv}\n        ORELSE' Sepref_Translate.side_frame_tac ctxt\n      )\n    end\n\n    fun preproc_tac ctxt = let\n      val ctxt = put_simpset HOL_basic_ss ctxt\n      val ctxt = ctxt addsimps (sepref_preproc_simps.get ctxt)  \n    in\n      Sepref_Rules.prepare_hfref_synth_tac ctxt THEN'\n      Simplifier.simp_tac ctxt\n    end\n\n    fun id_tac ctxt = \n      resolve_tac ctxt @{thms ID_init} \n      THEN' CONVERSION Thm.eta_conversion\n      THEN' DETERM o Id_Op.id_tac Id_Op.Normal ctxt\n\n    fun id_init_tac ctxt = \n      resolve_tac ctxt @{thms ID_init} \n      THEN' CONVERSION Thm.eta_conversion\n      THEN' Id_Op.id_tac Id_Op.Init ctxt\n\n    fun id_step_tac ctxt = \n      Id_Op.id_tac Id_Op.Step ctxt\n\n    fun id_solve_tac ctxt = \n      Id_Op.id_tac Id_Op.Solve ctxt\n\n    (*fun id_param_tac ctxt = CONVERSION (Refine_Util.HOL_concl_conv \n      (K (Sepref_Param.id_param_conv ctxt)) ctxt)*)\n\n    fun monadify_tac ctxt = Sepref_Monadify.monadify_tac ctxt\n\n    (*fun lin_ana_tac ctxt = Sepref_Lin_Ana.lin_ana_tac ctxt*)\n\n    fun trans_tac ctxt = Sepref_Translate.trans_tac ctxt\n\n    fun opt_tac ctxt = let \n      val opt1_ss = put_simpset HOL_basic_ss ctxt\n        addsimps sepref_opt_simps.get ctxt\n        addsimprocs [@{simproc \"HOL.let_simp\"}]\n      |> Simplifier.add_cong @{thm SP_cong}\n      |> Simplifier.add_cong @{thm PR_CONST_cong}\n\n      val unsp_ss = put_simpset HOL_basic_ss ctxt addsimps @{thms SP_def}\n\n      val opt2_ss = put_simpset HOL_basic_ss ctxt\n        addsimps sepref_opt_simps2.get ctxt\n        addsimprocs [@{simproc \"HOL.let_simp\"}]\n\n    in \n      simp_tac opt1_ss THEN' simp_tac unsp_ss THEN'\n      simp_tac opt2_ss THEN' simp_tac unsp_ss THEN'\n      CONVERSION Thm.eta_conversion THEN'\n      resolve_tac ctxt @{thms CNV_I}\n    end\n\n    fun sepref_tac dbg ctxt = \n      (K Sepref_Constraints.ensure_slot_tac) \n      THEN'\n      Sepref_Basic.PHASES'\n        [ \n          (\"preproc\",preproc_tac,0),\n          (\"cons_init\",cons_init_tac,2),\n          (\"id\",id_tac,0),\n          (\"monadify\",monadify_tac false,0),\n          (\"opt_init\",fn ctxt => resolve_tac ctxt @{thms TRANS_init},1),\n          (\"trans\",trans_tac,~1),\n          (\"opt\",opt_tac,~1),\n          (\"cons_solve1\",cons_solve_tac false,~1),\n          (\"cons_solve2\",cons_solve_tac false,~1),\n          (\"constraints\",fn ctxt => K (Sepref_Constraints.solve_constraint_slot ctxt THEN Sepref_Constraints.remove_slot_tac),~1)\n        ] (Sepref_Basic.flag_phases_ctrl dbg) ctxt\n    \n    val setup = I\n      #> sepref_preproc_simps.setup \n      #> sepref_opt_simps.setup \n      #> sepref_opt_simps2.setup\n  end\n\\<close>"], ["", "setup Sepref.setup"], ["", "method_setup sepref = \\<open>Scan.succeed (fn ctxt =>\n  SIMPLE_METHOD (DETERM (SOLVED' (IF_EXGOAL (\n      Sepref.sepref_tac false ctxt  \n    )) 1)))\\<close>\n  \\<open>Automatic refinement to Imperative/HOL\\<close>"], ["", "method_setup sepref_dbg_keep = \\<open>Scan.succeed (fn ctxt => let\n    (*val ctxt = Config.put Id_Op.cfg_id_debug true ctxt*)\n  in\n    SIMPLE_METHOD (IF_EXGOAL (Sepref.sepref_tac true ctxt) 1)\n  end)\\<close>\n  \\<open>Automatic refinement to Imperative/HOL, debug mode\\<close>"], ["", "subsubsection \\<open>Default Optimizer Setup\\<close>"], ["", "lemma return_bind_eq_let: \"do { x\\<leftarrow>return v; f x } = do { let x=v; f x }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. return v \\<bind> f = Let v f", "by simp"], ["", "lemmas [sepref_opt_simps] = return_bind_eq_let bind_return bind_bind id_def"], ["", "text \\<open>We allow the synthesized function to contain tagged function applications.\n  This is important to avoid higher-order unification problems when synthesizing\n  generic algorithms, for example the to-list algorithm for foreach-loops.\\<close>"], ["", "lemmas [sepref_opt_simps] = Autoref_Tagging.APP_def"], ["", "text \\<open>Revert case-pulling done by monadify\\<close>"], ["", "lemma case_prod_return_opt[sepref_opt_simps]:\n  \"case_prod (\\<lambda>a b. return (f a b)) p = return (case_prod f p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case p of (a, b) \\<Rightarrow> return (f a b)) =\n    return (case p of (x, xa) \\<Rightarrow> f x xa)", "by (simp split: prod.split)"], ["", "lemma case_option_return_opt[sepref_opt_simps]:\n  \"case_option (return fn) (\\<lambda>s. return (fs s)) v = return (case_option fn fs v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case v of None \\<Rightarrow> return fn\n     | Some s \\<Rightarrow> return (fs s)) =\n    return (case v of None \\<Rightarrow> fn | Some x \\<Rightarrow> fs x)", "by (simp split: option.split)"], ["", "lemma case_list_return[sepref_opt_simps]:\n  \"case_list (return fn) (\\<lambda>x xs. return (fc x xs)) l = return (case_list fn fc l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case l of [] \\<Rightarrow> return fn\n     | x # xs \\<Rightarrow> return (fc x xs)) =\n    return (case l of [] \\<Rightarrow> fn | x # xa \\<Rightarrow> fc x xa)", "by (simp split: list.split)"], ["", "lemma if_return[sepref_opt_simps]:\n  \"If b (return t) (return e) = return (If b t e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if b then return t else return e) = return (if b then t else e)", "by simp"], ["", "text \\<open>In some cases, pushing in the returns is more convenient\\<close>"], ["", "lemma case_prod_opt2[sepref_opt_simps2]:\n  \"(\\<lambda>x. return (case x of (a,b) \\<Rightarrow> f a b)) \n  = (\\<lambda>(a,b). return (f a b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. return (case x of (a, b) \\<Rightarrow> f a b)) =\n    (\\<lambda>(a, b). return (f a b))", "by auto"], ["", "subsection \\<open>Debugging Methods\\<close>"], ["", "ML \\<open>\n  fun SIMPLE_METHOD_NOPARAM' tac = Scan.succeed (fn ctxt => SIMPLE_METHOD' (IF_EXGOAL (tac ctxt)))\n  fun SIMPLE_METHOD_NOPARAM tac = Scan.succeed (fn ctxt => SIMPLE_METHOD (tac ctxt))\n\\<close>"], ["", "method_setup sepref_dbg_preproc = \\<open>SIMPLE_METHOD_NOPARAM' (fn ctxt => K (Sepref_Constraints.ensure_slot_tac) THEN' Sepref.preproc_tac ctxt)\\<close>\n  \\<open>Sepref debug: Preprocessing phase\\<close>"], ["", "(*method_setup sepref_dbg_id_param = \\<open>SIMPLE_METHOD_NOPARAM' Sepref.id_param_tac\\<close>\n  \\<open>Sepref debug: Identify parameters phase\\<close>*)"], ["", "method_setup sepref_dbg_cons_init = \\<open>SIMPLE_METHOD_NOPARAM' Sepref.cons_init_tac\\<close>\n  \\<open>Sepref debug: Initialize consequence reasoning\\<close>"], ["", "method_setup sepref_dbg_id = \\<open>SIMPLE_METHOD_NOPARAM' (Sepref.id_tac)\\<close>\n  \\<open>Sepref debug: Identify operations phase\\<close>"], ["", "method_setup sepref_dbg_id_keep = \\<open>SIMPLE_METHOD_NOPARAM' (Config.put Id_Op.cfg_id_debug true #> Sepref.id_tac)\\<close>\n  \\<open>Sepref debug: Identify operations phase. Debug mode, keep intermediate subgoals on failure.\\<close>"], ["", "method_setup sepref_dbg_monadify = \\<open>SIMPLE_METHOD_NOPARAM' (Sepref.monadify_tac false)\\<close>\n  \\<open>Sepref debug: Monadify phase\\<close>"], ["", "method_setup sepref_dbg_monadify_keep = \\<open>SIMPLE_METHOD_NOPARAM' (Sepref.monadify_tac true)\\<close>\n  \\<open>Sepref debug: Monadify phase\\<close>"], ["", "method_setup sepref_dbg_monadify_arity = \\<open>SIMPLE_METHOD_NOPARAM' (Sepref_Monadify.arity_tac)\\<close>\n  \\<open>Sepref debug: Monadify phase: Arity phase\\<close>"], ["", "method_setup sepref_dbg_monadify_comb = \\<open>SIMPLE_METHOD_NOPARAM' (Sepref_Monadify.comb_tac)\\<close>\n  \\<open>Sepref debug: Monadify phase: Comb phase\\<close>"], ["", "method_setup sepref_dbg_monadify_check_EVAL = \\<open>SIMPLE_METHOD_NOPARAM' (K (CONCL_COND' (not o Sepref_Monadify.contains_eval)))\\<close>\n  \\<open>Sepref debug: Monadify phase: check_EVAL phase\\<close>"], ["", "method_setup sepref_dbg_monadify_mark_params = \\<open>SIMPLE_METHOD_NOPARAM' (Sepref_Monadify.mark_params_tac)\\<close>\n  \\<open>Sepref debug: Monadify phase: mark_params phase\\<close>"], ["", "method_setup sepref_dbg_monadify_dup = \\<open>SIMPLE_METHOD_NOPARAM' (Sepref_Monadify.dup_tac)\\<close>\n  \\<open>Sepref debug: Monadify phase: dup phase\\<close>"], ["", "method_setup sepref_dbg_monadify_remove_pass = \\<open>SIMPLE_METHOD_NOPARAM' (Sepref_Monadify.remove_pass_tac)\\<close>\n  \\<open>Sepref debug: Monadify phase: remove_pass phase\\<close>"], ["", "(*method_setup sepref_dbg_lin_ana = \\<open>SIMPLE_METHOD_NOPARAM' (Sepref.lin_ana_tac true)\\<close>\n  \\<open>Sepref debug: Linearity analysis phase\\<close>*)"], ["", "method_setup sepref_dbg_opt_init = \\<open>SIMPLE_METHOD_NOPARAM' (fn ctxt => resolve_tac ctxt @{thms TRANS_init})\\<close>\n  \\<open>Sepref debug: Translation phase initialization\\<close>"], ["", "method_setup sepref_dbg_trans = \\<open>SIMPLE_METHOD_NOPARAM' Sepref.trans_tac\\<close>\n  \\<open>Sepref debug: Translation phase\\<close>"], ["", "method_setup sepref_dbg_opt = \\<open>SIMPLE_METHOD_NOPARAM' (fn ctxt => \n  Sepref.opt_tac ctxt\n  THEN' CONVERSION Thm.eta_conversion\n  THEN' TRY o resolve_tac ctxt @{thms CNV_I}\n)\\<close>\n  \\<open>Sepref debug: Optimization phase\\<close>"], ["", "method_setup sepref_dbg_cons_solve = \\<open>SIMPLE_METHOD_NOPARAM' (Sepref.cons_solve_tac false)\\<close>\n  \\<open>Sepref debug: Solve post-consequences\\<close>"], ["", "method_setup sepref_dbg_cons_solve_keep = \\<open>SIMPLE_METHOD_NOPARAM' (Sepref.cons_solve_tac true)\\<close>\n  \\<open>Sepref debug: Solve post-consequences, keep intermediate results\\<close>"], ["", "method_setup sepref_dbg_constraints = \\<open>SIMPLE_METHOD_NOPARAM' (fn ctxt => IF_EXGOAL (K (\n    Sepref_Constraints.solve_constraint_slot ctxt\n    THEN Sepref_Constraints.remove_slot_tac\n  )))\\<close>\n  \\<open>Sepref debug: Solve accumulated constraints\\<close>"], ["", "(*\n  apply sepref_dbg_preproc\n  apply sepref_dbg_cons_init\n  apply sepref_dbg_id\n  apply sepref_dbg_monadify\n  apply sepref_dbg_opt_init\n  apply sepref_dbg_trans\n  apply sepref_dbg_opt\n  apply sepref_dbg_cons_solve\n  apply sepref_dbg_cons_solve\n  apply sepref_dbg_constraints\n\n*)"], ["", "method_setup sepref_dbg_id_init = \\<open>SIMPLE_METHOD_NOPARAM' Sepref.id_init_tac\\<close>\n  \\<open>Sepref debug: Initialize operation identification phase\\<close>"], ["", "method_setup sepref_dbg_id_step = \\<open>SIMPLE_METHOD_NOPARAM' Sepref.id_step_tac\\<close>\n  \\<open>Sepref debug: Single step operation identification phase\\<close>"], ["", "method_setup sepref_dbg_id_solve = \\<open>SIMPLE_METHOD_NOPARAM' Sepref.id_solve_tac\\<close>\n  \\<open>Sepref debug: Complete current operation identification goal\\<close>"], ["", "method_setup sepref_dbg_trans_keep = \\<open>SIMPLE_METHOD_NOPARAM' Sepref_Translate.trans_keep_tac\\<close>\n  \\<open>Sepref debug: Translation phase, stop at failed subgoal\\<close>"], ["", "method_setup sepref_dbg_trans_step = \\<open>SIMPLE_METHOD_NOPARAM' Sepref_Translate.trans_step_tac\\<close>\n  \\<open>Sepref debug: Translation step\\<close>"], ["", "method_setup sepref_dbg_trans_step_keep = \\<open>SIMPLE_METHOD_NOPARAM' Sepref_Translate.trans_step_keep_tac\\<close>\n  \\<open>Sepref debug: Translation step, keep unsolved subgoals\\<close>"], ["", "method_setup sepref_dbg_side = \\<open>SIMPLE_METHOD_NOPARAM' (fn ctxt => REPEAT_ALL_NEW_FWD (Sepref_Translate.side_cond_dispatch_tac false (K no_tac) ctxt))\\<close>"], ["", "method_setup sepref_dbg_side_unfold = \\<open>SIMPLE_METHOD_NOPARAM' (Sepref_Translate.side_unfold_tac)\\<close>"], ["", "method_setup sepref_dbg_side_keep = \\<open>SIMPLE_METHOD_NOPARAM' (fn ctxt => REPEAT_ALL_NEW_FWD (Sepref_Translate.side_cond_dispatch_tac true (K no_tac) ctxt))\\<close>"], ["", "method_setup sepref_dbg_prepare_frame = \\<open>SIMPLE_METHOD_NOPARAM' Sepref_Frame.prepare_frame_tac\\<close>\n  \\<open>Sepref debug: Prepare frame inference\\<close>"], ["", "method_setup sepref_dbg_frame = \\<open>SIMPLE_METHOD_NOPARAM' (Sepref_Frame.frame_tac (Sepref_Translate.side_fallback_tac))\\<close>\n  \\<open>Sepref debug: Frame inference\\<close>"], ["", "method_setup sepref_dbg_merge = \\<open>SIMPLE_METHOD_NOPARAM' (Sepref_Frame.merge_tac (Sepref_Translate.side_fallback_tac))\\<close>\n  \\<open>Sepref debug: Frame inference, merge\\<close>"], ["", "method_setup sepref_dbg_frame_step = \\<open>SIMPLE_METHOD_NOPARAM' (Sepref_Frame.frame_step_tac (Sepref_Translate.side_fallback_tac) false)\\<close>\n  \\<open>Sepref debug: Frame inference, single-step\\<close>"], ["", "method_setup sepref_dbg_frame_step_keep = \\<open>SIMPLE_METHOD_NOPARAM' (Sepref_Frame.frame_step_tac (Sepref_Translate.side_fallback_tac) true)\\<close>\n  \\<open>Sepref debug: Frame inference, single-step, keep partially solved side conditions\\<close>"], ["", "subsection \\<open>Utilities\\<close>"], ["", "subsubsection \\<open>Manual hfref-proofs\\<close>"], ["", "method_setup sepref_to_hnr = \\<open>SIMPLE_METHOD_NOPARAM' (fn ctxt => \n  Sepref.preproc_tac ctxt THEN' Sepref_Frame.weaken_post_tac ctxt)\\<close>\n  \\<open>Sepref: Convert to hnr-goal and weaken postcondition\\<close>"], ["", "method_setup sepref_to_hoare = \\<open>\n  let\n    fun sepref_to_hoare_tac ctxt = let\n      val ss = put_simpset HOL_basic_ss ctxt\n        addsimps @{thms hn_ctxt_def pure_def}\n\n    in\n      Sepref.preproc_tac ctxt \n      THEN' Sepref_Frame.weaken_post_tac ctxt \n      THEN' resolve_tac ctxt @{thms hn_refineI}\n      THEN' asm_full_simp_tac ss\n    end  \n  in\n    SIMPLE_METHOD_NOPARAM' sepref_to_hoare_tac\n  end\n\\<close> \\<open>Sepref: Convert to hoare-triple\\<close>"], ["", "subsubsection \\<open>Copying of Parameters\\<close>"], ["", "lemma fold_COPY: \"x = COPY x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = COPY x", "by simp"], ["", "sepref_register COPY"], ["", "text \\<open>Copy is treated as normal operator, and one can just declare rules for it! \\<close>"], ["", "lemma hnr_pure_COPY[sepref_fr_rules]:\n  \"CONSTRAINT is_pure R \\<Longrightarrow> (return, RETURN o COPY) \\<in> R\\<^sup>k \\<rightarrow>\\<^sub>a R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CONSTRAINT is_pure R \\<Longrightarrow>\n    (return, RETURN \\<circ> COPY) \\<in> R\\<^sup>k \\<rightarrow>\\<^sub>a R", "by (sep_auto simp: is_pure_conv pure_def intro!: hfrefI hn_refineI)"], ["", "subsubsection \\<open>Short-Circuit Boolean Evaluation\\<close>"], ["", "text \\<open>Convert boolean operators to short-circuiting. \n  When applied before monadify, this will generate a short-circuit execution.\\<close>"], ["", "lemma short_circuit_conv:  \n  \"(a \\<and> b) \\<longleftrightarrow> (if a then b else False)\"\n  \"(a \\<or> b) \\<longleftrightarrow> (if a then True else b)\"\n  \"(a\\<longrightarrow>b) \\<longleftrightarrow> (if a then b else True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<and> b) = (if a then b else False) &&&\n    (a \\<or> b) = (if a then True else b) &&&\n    (a \\<longrightarrow> b) = (if a then b else True)", "by auto"], ["", "subsubsection \\<open>Eliminating higher-order\\<close>"], ["", "(* TODO: Add similar rules for other cases! *)"], ["", "lemma ho_prod_move[sepref_preproc]: \"case_prod (\\<lambda>a b x. f x a b) = (\\<lambda>p x. case_prod (f x) p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(a, b) x. f x a b) =\n    (\\<lambda>p x. case p of (xa, xb) \\<Rightarrow> f x xa xb)", "by (auto intro!: ext)"], ["", "declare o_apply[sepref_preproc]"], ["", "subsubsection \\<open>Precision Proofs\\<close>"], ["", "text \\<open>\n    We provide a method that tries to extract equalities from\n    an assumption of the form \n    \\<open>_ \\<Turnstile> P1 * \\<dots> * Pn \\<and>\\<^sub>A P1' * \\<dots> * Pn'\\<close>,\n    if it find a precision rule for Pi and Pi'.\n    The precision rules are extracted from the constraint rules.\n\n    TODO: Extracting the precision rules from the constraint rules\n      is not a clean solution. It might be better to collect precision rules\n      separately, and feed them into the constraint solver.\n    \\<close>"], ["", "definition \"prec_spec h \\<Gamma> \\<Gamma>' \\<equiv> h \\<Turnstile> \\<Gamma> * true \\<and>\\<^sub>A \\<Gamma>' * true\""], ["", "lemma prec_specI: \"h \\<Turnstile> \\<Gamma> \\<and>\\<^sub>A \\<Gamma>' \\<Longrightarrow> prec_spec h \\<Gamma> \\<Gamma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<Turnstile> \\<Gamma> \\<and>\\<^sub>A \\<Gamma>' \\<Longrightarrow>\n    prec_spec h \\<Gamma> \\<Gamma>'", "unfolding prec_spec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<Turnstile> \\<Gamma> \\<and>\\<^sub>A \\<Gamma>' \\<Longrightarrow>\n    h \\<Turnstile> \\<Gamma> * true \\<and>\\<^sub>A \\<Gamma>' * true", "by (auto simp: mod_and_dist mod_star_trueI)"], ["", "lemma prec_split1_aux: \"A*B*true \\<Longrightarrow>\\<^sub>A A*true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * B * true \\<Longrightarrow>\\<^sub>A A * true", "apply (fr_rot 2, fr_rot_rhs 1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. B * true * A \\<Longrightarrow>\\<^sub>A true * A", "apply (rule ent_star_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. B * true \\<Longrightarrow>\\<^sub>A true\n 2. A \\<Longrightarrow>\\<^sub>A A", "by simp_all"], ["", "lemma prec_split2_aux: \"A*B*true \\<Longrightarrow>\\<^sub>A B*true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * B * true \\<Longrightarrow>\\<^sub>A B * true", "apply (fr_rot 1, fr_rot_rhs 1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. true * A * B \\<Longrightarrow>\\<^sub>A true * B", "apply (rule ent_star_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. true * A \\<Longrightarrow>\\<^sub>A true\n 2. B \\<Longrightarrow>\\<^sub>A B", "by simp_all"], ["", "lemma prec_spec_splitE: \n    assumes \"prec_spec h (A*B) (C*D)\"  \n    obtains \"prec_spec h A C\" \"prec_spec h B D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>prec_spec h A C; prec_spec h B D\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (thin_tac \"\\<lbrakk>_;_\\<rbrakk> \\<Longrightarrow> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "apply (rule that)"], ["proof (prove)\ngoal (2 subgoals):\n 1. prec_spec h A C\n 2. prec_spec h B D", "using assms"], ["proof (prove)\nusing this:\n  prec_spec h (A * B) (C * D)\n\ngoal (2 subgoals):\n 1. prec_spec h A C\n 2. prec_spec h B D", "apply -"], ["proof (prove)\ngoal (2 subgoals):\n 1. prec_spec h (A * B) (C * D) \\<Longrightarrow> prec_spec h A C\n 2. prec_spec h (A * B) (C * D) \\<Longrightarrow> prec_spec h B D", "unfolding prec_spec_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. h \\<Turnstile>\n    A * B * true \\<and>\\<^sub>A C * D * true \\<Longrightarrow>\n    h \\<Turnstile> A * true \\<and>\\<^sub>A C * true\n 2. h \\<Turnstile>\n    A * B * true \\<and>\\<^sub>A C * D * true \\<Longrightarrow>\n    h \\<Turnstile> B * true \\<and>\\<^sub>A D * true", "apply (erule entailsD[rotated])"], ["proof (prove)\ngoal (2 subgoals):\n 1. A * B * true \\<and>\\<^sub>A C * D * true \\<Longrightarrow>\\<^sub>A\n    A * true \\<and>\\<^sub>A C * true\n 2. h \\<Turnstile>\n    A * B * true \\<and>\\<^sub>A C * D * true \\<Longrightarrow>\n    h \\<Turnstile> B * true \\<and>\\<^sub>A D * true", "apply (rule ent_conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. A * B * true \\<and>\\<^sub>A C * D * true \\<Longrightarrow>\\<^sub>A\n    A * true\n 2. A * B * true \\<and>\\<^sub>A C * D * true \\<Longrightarrow>\\<^sub>A\n    C * true\n 3. h \\<Turnstile>\n    A * B * true \\<and>\\<^sub>A C * D * true \\<Longrightarrow>\n    h \\<Turnstile> B * true \\<and>\\<^sub>A D * true", "apply (rule ent_conjE1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. A * B * true \\<Longrightarrow>\\<^sub>A A * true\n 2. A * B * true \\<and>\\<^sub>A C * D * true \\<Longrightarrow>\\<^sub>A\n    C * true\n 3. h \\<Turnstile>\n    A * B * true \\<and>\\<^sub>A C * D * true \\<Longrightarrow>\n    h \\<Turnstile> B * true \\<and>\\<^sub>A D * true", "apply (rule prec_split1_aux)"], ["proof (prove)\ngoal (2 subgoals):\n 1. A * B * true \\<and>\\<^sub>A C * D * true \\<Longrightarrow>\\<^sub>A\n    C * true\n 2. h \\<Turnstile>\n    A * B * true \\<and>\\<^sub>A C * D * true \\<Longrightarrow>\n    h \\<Turnstile> B * true \\<and>\\<^sub>A D * true", "apply (rule ent_conjE2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. C * D * true \\<Longrightarrow>\\<^sub>A C * true\n 2. h \\<Turnstile>\n    A * B * true \\<and>\\<^sub>A C * D * true \\<Longrightarrow>\n    h \\<Turnstile> B * true \\<and>\\<^sub>A D * true", "apply (rule prec_split1_aux)"], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<Turnstile>\n    A * B * true \\<and>\\<^sub>A C * D * true \\<Longrightarrow>\n    h \\<Turnstile> B * true \\<and>\\<^sub>A D * true", "apply (erule entailsD[rotated])"], ["proof (prove)\ngoal (1 subgoal):\n 1. A * B * true \\<and>\\<^sub>A C * D * true \\<Longrightarrow>\\<^sub>A\n    B * true \\<and>\\<^sub>A D * true", "apply (rule ent_conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. A * B * true \\<and>\\<^sub>A C * D * true \\<Longrightarrow>\\<^sub>A\n    B * true\n 2. A * B * true \\<and>\\<^sub>A C * D * true \\<Longrightarrow>\\<^sub>A\n    D * true", "apply (rule ent_conjE1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. A * B * true \\<Longrightarrow>\\<^sub>A B * true\n 2. A * B * true \\<and>\\<^sub>A C * D * true \\<Longrightarrow>\\<^sub>A\n    D * true", "apply (rule prec_split2_aux)"], ["proof (prove)\ngoal (1 subgoal):\n 1. A * B * true \\<and>\\<^sub>A C * D * true \\<Longrightarrow>\\<^sub>A\n    D * true", "apply (rule ent_conjE2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. C * D * true \\<Longrightarrow>\\<^sub>A D * true", "apply (rule prec_split2_aux)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma prec_specD:\n    assumes \"precise R\"\n    assumes \"prec_spec h (R a p) (R a' p)\"\n    shows \"a=a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = a'", "using assms"], ["proof (prove)\nusing this:\n  precise R\n  prec_spec h (R a p) (R a' p)\n\ngoal (1 subgoal):\n 1. a = a'", "unfolding precise_def prec_spec_def CONSTRAINT_def"], ["proof (prove)\nusing this:\n  \\<forall>a a' h p F F'.\n     h \\<Turnstile> R a p * F \\<and>\\<^sub>A R a' p * F' \\<longrightarrow>\n     a = a'\n  h \\<Turnstile> R a p * true \\<and>\\<^sub>A R a' p * true\n\ngoal (1 subgoal):\n 1. a = a'", "by blast"], ["", "ML \\<open>\n    fun prec_extract_eqs_tac ctxt = let\n      fun is_precise thm = case Thm.concl_of thm of\n        @{mpat \"Trueprop (precise _)\"} => true\n      | _ => false  \n  \n      val thms = Sepref_Constraints.get_constraint_rules ctxt\n        @ Sepref_Constraints.get_safe_constraint_rules ctxt\n      val thms = thms  \n        |> filter is_precise \n      val thms = @{thms snga_prec sngr_prec} @ thms\n      val thms = map (fn thm => thm RS @{thm prec_specD}) thms\n  \n      val thin_prec_spec_rls = @{thms thin_rl[Pure.of \"prec_spec a b c\" for a b c]}\n  \n      val tac = \n        forward_tac ctxt @{thms prec_specI}\n        THEN' REPEAT_ALL_NEW (ematch_tac ctxt @{thms prec_spec_splitE})\n        THEN' REPEAT o (dresolve_tac ctxt thms)\n        THEN' REPEAT o (eresolve_tac ctxt thin_prec_spec_rls )\n    in tac end    \n\\<close>"], ["", "method_setup prec_extract_eqs = \\<open>SIMPLE_METHOD_NOPARAM' prec_extract_eqs_tac\\<close>\n    \\<open>Extract equalities from \"_ |= _ & _\" assumption, using precision rules\\<close>"], ["", "subsubsection \\<open>Combinator Rules\\<close>"], ["", "lemma split_merge: \"\\<lbrakk>A \\<or>\\<^sub>A B \\<Longrightarrow>\\<^sub>t X; X \\<or>\\<^sub>A C \\<Longrightarrow>\\<^sub>t D\\<rbrakk> \\<Longrightarrow> (A \\<or>\\<^sub>A B \\<or>\\<^sub>A C \\<Longrightarrow>\\<^sub>t D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<or>\\<^sub>A B \\<Longrightarrow>\\<^sub>t X;\n     X \\<or>\\<^sub>A C \\<Longrightarrow>\\<^sub>t D\\<rbrakk>\n    \\<Longrightarrow> A \\<or>\\<^sub>A\n                      B \\<or>\\<^sub>A C \\<Longrightarrow>\\<^sub>t\n                      D", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<or>\\<^sub>A B \\<Longrightarrow>\\<^sub>t X;\n     X \\<or>\\<^sub>A C \\<Longrightarrow>\\<^sub>t D\\<rbrakk>\n    \\<Longrightarrow> A \\<or>\\<^sub>A\n                      B \\<or>\\<^sub>A C \\<Longrightarrow>\\<^sub>t\n                      D", "assume a1: \"X \\<or>\\<^sub>A C \\<Longrightarrow>\\<^sub>t D\""], ["proof (state)\nthis:\n  X \\<or>\\<^sub>A C \\<Longrightarrow>\\<^sub>t D\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<or>\\<^sub>A B \\<Longrightarrow>\\<^sub>t X;\n     X \\<or>\\<^sub>A C \\<Longrightarrow>\\<^sub>t D\\<rbrakk>\n    \\<Longrightarrow> A \\<or>\\<^sub>A\n                      B \\<or>\\<^sub>A C \\<Longrightarrow>\\<^sub>t\n                      D", "assume \"A \\<or>\\<^sub>A B \\<Longrightarrow>\\<^sub>t X\""], ["proof (state)\nthis:\n  A \\<or>\\<^sub>A B \\<Longrightarrow>\\<^sub>t X\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<or>\\<^sub>A B \\<Longrightarrow>\\<^sub>t X;\n     X \\<or>\\<^sub>A C \\<Longrightarrow>\\<^sub>t D\\<rbrakk>\n    \\<Longrightarrow> A \\<or>\\<^sub>A\n                      B \\<or>\\<^sub>A C \\<Longrightarrow>\\<^sub>t\n                      D", "then"], ["proof (chain)\npicking this:\n  A \\<or>\\<^sub>A B \\<Longrightarrow>\\<^sub>t X", "have \"A \\<or>\\<^sub>A B \\<Longrightarrow>\\<^sub>A D * true\""], ["proof (prove)\nusing this:\n  A \\<or>\\<^sub>A B \\<Longrightarrow>\\<^sub>t X\n\ngoal (1 subgoal):\n 1. A \\<or>\\<^sub>A B \\<Longrightarrow>\\<^sub>A D * true", "using a1"], ["proof (prove)\nusing this:\n  A \\<or>\\<^sub>A B \\<Longrightarrow>\\<^sub>t X\n  X \\<or>\\<^sub>A C \\<Longrightarrow>\\<^sub>t D\n\ngoal (1 subgoal):\n 1. A \\<or>\\<^sub>A B \\<Longrightarrow>\\<^sub>A D * true", "by (meson ent_disjI1_direct ent_frame_fwd enttD entt_def_true)"], ["proof (state)\nthis:\n  A \\<or>\\<^sub>A B \\<Longrightarrow>\\<^sub>A D * true\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<or>\\<^sub>A B \\<Longrightarrow>\\<^sub>t X;\n     X \\<or>\\<^sub>A C \\<Longrightarrow>\\<^sub>t D\\<rbrakk>\n    \\<Longrightarrow> A \\<or>\\<^sub>A\n                      B \\<or>\\<^sub>A C \\<Longrightarrow>\\<^sub>t\n                      D", "then"], ["proof (chain)\npicking this:\n  A \\<or>\\<^sub>A B \\<Longrightarrow>\\<^sub>A D * true", "show ?thesis"], ["proof (prove)\nusing this:\n  A \\<or>\\<^sub>A B \\<Longrightarrow>\\<^sub>A D * true\n\ngoal (1 subgoal):\n 1. A \\<or>\\<^sub>A B \\<or>\\<^sub>A C \\<Longrightarrow>\\<^sub>t D", "using a1"], ["proof (prove)\nusing this:\n  A \\<or>\\<^sub>A B \\<Longrightarrow>\\<^sub>A D * true\n  X \\<or>\\<^sub>A C \\<Longrightarrow>\\<^sub>t D\n\ngoal (1 subgoal):\n 1. A \\<or>\\<^sub>A B \\<or>\\<^sub>A C \\<Longrightarrow>\\<^sub>t D", "by (metis (no_types) Assertions.ent_disjI2 ent_disjE enttD enttI semigroup.assoc sup.semigroup_axioms)"], ["proof (state)\nthis:\n  A \\<or>\\<^sub>A B \\<or>\\<^sub>A C \\<Longrightarrow>\\<^sub>t D\n\ngoal:\nNo subgoals!", "qed"], ["", "ML \\<open>\n    fun prep_comb_rule thm = let\n      fun mrg t = case Logic.strip_assums_concl t of\n        @{mpat \"Trueprop (_ \\<or>\\<^sub>A _ \\<or>\\<^sub>A _ \\<Longrightarrow>\\<^sub>t _)\"} => (@{thm split_merge},true)\n      | @{mpat \"Trueprop (hn_refine _ _ ?G _ _)\"} => (\n          if not (is_Var (head_of G)) then (@{thm hn_refine_cons_post}, true)\n          else (asm_rl,false)\n        )\n      | _ => (asm_rl,false)\n      \n      val inst = Thm.prems_of thm |> map mrg\n    in\n      if exists snd inst then\n        prep_comb_rule (thm OF (map fst inst))\n      else\n        thm |> zero_var_indexes\n    end\n  \\<close>"], ["", "attribute_setup sepref_prep_comb_rule = \\<open>Scan.succeed (Thm.rule_attribute [] (K prep_comb_rule))\\<close>\n    \\<open>Preprocess combinator rule: Split merge-rules and add missing frame rules\\<close>"], ["", "end"]]}