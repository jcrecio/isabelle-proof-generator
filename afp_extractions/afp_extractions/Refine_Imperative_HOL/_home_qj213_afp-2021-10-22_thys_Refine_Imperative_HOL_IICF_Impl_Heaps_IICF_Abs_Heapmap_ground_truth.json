{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/IICF/Impl/Heaps/IICF_Abs_Heapmap.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemmas hmr_rel_defs = hmr_rel_def br_def hmr_\\<alpha>_def hmr_invar_def", "lemma hmr_empty_invar[simp]: \"hmr_invar ([],Map.empty)\"", "lemmas heapmap_rel_defs = heapmap_rel_def br_def heapmap_\\<alpha>_def heapmap_invar_def", "lemma [refine_dref_RELATES]: \"RELATES hmr_rel\"", "lemma h_heap_invarI[simp]: \"heapmap_invar hm \\<Longrightarrow> h.heap_invar (hmr_\\<alpha> hm)\"", "lemma hmr_invarI[simp]: \"heapmap_invar hm \\<Longrightarrow> hmr_invar hm\"", "lemma set_hmr_\\<alpha>[simp]: \"hmr_invar hm \\<Longrightarrow> set (hmr_\\<alpha> hm) = ran (heapmap_\\<alpha> hm)\"", "lemma in_h_hmr_\\<alpha>_conv[simp]: \"hmr_invar hm \\<Longrightarrow> x \\<in># h.\\<alpha> (hmr_\\<alpha> hm) \\<longleftrightarrow> x \\<in> ran (heapmap_\\<alpha> hm)\"", "lemma hm_length_refine: \"(hm_length, length) \\<in> hmr_rel \\<rightarrow> nat_rel\"", "lemma hm_length_hmr_\\<alpha>[simp]: \"length (hmr_\\<alpha> hm) = hm_length hm\"", "lemmas [refine] = hm_length_refine[param_fo]", "lemma hm_valid_refine: \"(hm_valid,h.valid)\\<in>hmr_rel \\<rightarrow> nat_rel \\<rightarrow> bool_rel\"", "lemma hm_valid_hmr_\\<alpha>[simp]: \"h.valid (hmr_\\<alpha> hm) = hm_valid hm\"", "lemma hm_key_of_op_unfold:\n      shows \"hm_key_of_op hm i = ASSERT (hm_valid hm i) \\<then> RETURN (hm_key_of hm i)\"", "lemma val_of_hmr_\\<alpha>[simp]: \"hm_valid hm i \\<Longrightarrow> h.val_of (hmr_\\<alpha> hm) i \n      = the (heapmap_\\<alpha> hm (hm_key_of hm i))\"", "lemma hm_\\<alpha>_key_ex[simp]:\n      \"\\<lbrakk>hmr_invar hm; hm_valid hm i\\<rbrakk> \\<Longrightarrow> (heapmap_\\<alpha> hm (hm_key_of hm i) \\<noteq> None)\"", "lemma hm_exch_op_invar: \"hm_exch_op hm i j \\<le>\\<^sub>n SPEC hmr_invar\"", "lemma hm_exch_op_refine: \"(hm_exch_op,h.exch_op) \\<in> hmr_rel \\<rightarrow> nat_rel \\<rightarrow> nat_rel \\<rightarrow> \\<langle>hmr_rel\\<rangle>nres_rel\"", "lemmas hm_exch_op_refine'[refine] = hm_exch_op_refine[param_fo, THEN nres_relD]", "lemma hm_exch_op_\\<alpha>_correct: \"hm_exch_op hm i j \\<le>\\<^sub>n SPEC (\\<lambda>hm'. \n      hm_valid hm i \\<and> hm_valid hm j \\<and> hm'=hm_exch hm i j\n      )\"", "lemma hm_exch_\\<alpha>[simp]: \"heapmap_\\<alpha> (hm_exch hm i j) = (heapmap_\\<alpha> hm)\"", "lemma hm_exch_valid[simp]: \"hm_valid (hm_exch hm i j) = hm_valid hm\"", "lemma hm_exch_length[simp]: \"hm_length (hm_exch hm i j) = hm_length hm\"", "lemma hm_exch_same[simp]: \"hm_exch hm i i = hm\"", "lemma hm_key_of_exch_conv[simp]:   \n      \"\\<lbrakk>hm_valid hm i; hm_valid hm j; hm_valid hm k\\<rbrakk> \\<Longrightarrow> \n        hm_key_of (hm_exch hm i j) k = (\n          if k=i then hm_key_of hm j\n          else if k=j then hm_key_of hm i\n          else hm_key_of hm k\n          )\"", "lemma hm_key_of_exch_matching[simp]:  \n      \"\\<lbrakk>hm_valid hm i; hm_valid hm j\\<rbrakk> \\<Longrightarrow> hm_key_of (hm_exch hm i j) i = hm_key_of hm j\"\n      \"\\<lbrakk>hm_valid hm i; hm_valid hm j\\<rbrakk> \\<Longrightarrow> hm_key_of (hm_exch hm i j) j = hm_key_of hm i\"", "lemma hm_index_valid[simp]: \"\\<lbrakk>hmr_invar hm; heapmap_\\<alpha> hm k \\<noteq> None\\<rbrakk> \\<Longrightarrow> hm_valid hm (hm_index hm k)\"", "lemma hm_index_key_of[simp]: \"\\<lbrakk>hmr_invar hm; heapmap_\\<alpha> hm k \\<noteq> None\\<rbrakk> \\<Longrightarrow> hm_key_of hm (hm_index hm k) = k\"", "lemma hm_index_op_correct:\n      assumes \"hmr_invar hm\"\n      assumes \"heapmap_\\<alpha> hm k \\<noteq> None\"\n      shows \"hm_index_op hm k \\<le> SPEC (\\<lambda>r. r= hm_index hm k)\"", "lemmas [refine_vcg] = hm_index_op_correct", "lemma hm_update_op_invar: \"hm_update_op hm k v \\<le>\\<^sub>n SPEC hmr_invar\"", "lemma hm_update_op_refine: \"(hm_update_op, h.update_op) \\<in> hmr_rel \\<rightarrow> nat_rel \\<rightarrow> Id \\<rightarrow> \\<langle>hmr_rel\\<rangle>nres_rel\"", "lemmas [refine] = hm_update_op_refine[param_fo, THEN nres_relD]", "lemma hm_update_op_\\<alpha>_correct:\n      assumes \"hmr_invar hm\"\n      assumes \"heapmap_\\<alpha> hm k \\<noteq> None\"\n      shows \"hm_update_op hm (hm_index hm k) v \\<le>\\<^sub>n SPEC (\\<lambda>hm'. heapmap_\\<alpha> hm' = (heapmap_\\<alpha> hm)(k\\<mapsto>v))\"", "lemma hm_butlast_op_refine: \"(hm_butlast_op, h.butlast_op) \\<in> hmr_rel \\<rightarrow> \\<langle>hmr_rel\\<rangle>nres_rel\"", "lemmas [refine] = hm_butlast_op_refine[param_fo, THEN nres_relD]", "lemma hm_butlast_op_\\<alpha>_correct: \"hm_butlast_op hm \\<le>\\<^sub>n SPEC (\n      \\<lambda>hm'. heapmap_\\<alpha> hm' = (heapmap_\\<alpha> hm)( hm_key_of hm (hm_length hm) := None ))\"", "lemma hm_append_op_invar: \"hm_append_op hm k v \\<le>\\<^sub>n SPEC hmr_invar\"", "lemma hm_append_op_refine: \"\\<lbrakk> heapmap_\\<alpha> hm k = None; (hm,h)\\<in>hmr_rel \\<rbrakk> \n      \\<Longrightarrow> (hm_append_op hm k v, h.append_op h v) \\<in> \\<langle>hmr_rel\\<rangle>nres_rel\"", "lemmas hm_append_op_refine'[refine] = hm_append_op_refine[param_fo, THEN nres_relD]", "lemma hm_append_op_\\<alpha>_correct: \n      \"hm_append_op hm k v \\<le>\\<^sub>n SPEC (\\<lambda>hm'. heapmap_\\<alpha> hm' = (heapmap_\\<alpha> hm) (k \\<mapsto> v))\"", "lemma heapmap_hmr_relI: \"(hm,h)\\<in>heapmap_rel \\<Longrightarrow> (hm,hmr_\\<alpha> hm) \\<in> hmr_rel\"", "lemma heapmap_hmr_relI': \"heapmap_invar hm \\<Longrightarrow> (hm,hmr_\\<alpha> hm) \\<in> hmr_rel\"", "lemma heapmap_nres_relI':\n      assumes \"hm \\<le> \\<Down>hmr_rel h'\"\n      assumes \"h' \\<le> SPEC (h.heap_invar)\"\n      assumes \"hm \\<le>\\<^sub>n SPEC (\\<lambda>hm'. RETURN (heapmap_\\<alpha> hm') \\<le> h)\"\n      shows \"hm \\<le> \\<Down>heapmap_rel h\"", "lemma heapmap_nres_relI'':\n      assumes \"hm \\<le> \\<Down>hmr_rel h'\"\n      assumes \"h' \\<le> SPEC \\<Phi>\"\n      assumes \"\\<And>h'. \\<Phi> h' \\<Longrightarrow> h.heap_invar h'\"\n      assumes \"hm \\<le>\\<^sub>n SPEC (\\<lambda>hm'. RETURN (heapmap_\\<alpha> hm') \\<le> h)\"\n      shows \"hm \\<le> \\<Down>heapmap_rel h\"", "lemma hm_val_of_op_refine: \"(hm_val_of_op,h.val_of_op) \\<in> (hmr_rel \\<rightarrow> nat_rel \\<rightarrow> \\<langle>Id\\<rangle>nres_rel)\"", "lemmas [refine] = hm_val_of_op_refine[param_fo, THEN nres_relD]", "lemma hm_prio_of_op_refine: \"(hm_prio_of_op, h.prio_of_op) \\<in> hmr_rel \\<rightarrow> nat_rel \\<rightarrow> \\<langle>Id\\<rangle>nres_rel\"", "lemmas hm_prio_of_op_refine'[refine] = hm_prio_of_op_refine[param_fo, THEN nres_relD]", "lemma hm_swim_op_refine: \"(hm_swim_op, h.swim_op) \\<in> hmr_rel \\<rightarrow> nat_rel \\<rightarrow> \\<langle>hmr_rel\\<rangle>nres_rel\"", "lemmas hm_swim_op_refine'[refine] = hm_swim_op_refine[param_fo, THEN nres_relD]", "lemma hm_swim_op_nofail_imp_valid: \n      \"nofail (hm_swim_op hm i) \\<Longrightarrow> hm_valid hm i \\<and> h.swim_invar (hmr_\\<alpha> hm) i\"", "lemma hm_swim_op_\\<alpha>_correct: \"hm_swim_op hm i \\<le>\\<^sub>n SPEC (\\<lambda>hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm)\"", "lemma hm_sink_op_refine: \"(hm_sink_op, h.sink_op) \\<in> hmr_rel \\<rightarrow> nat_rel \\<rightarrow> \\<langle>hmr_rel\\<rangle>nres_rel\"", "lemmas hm_sink_op_refine'[refine] = hm_sink_op_refine[param_fo, THEN nres_relD]", "lemma hm_sink_op_nofail_imp_valid: \"nofail (hm_sink_op hm i) \\<Longrightarrow> hm_valid hm i\"", "lemma hm_sink_op_\\<alpha>_correct: \"hm_sink_op hm i \\<le>\\<^sub>n SPEC (\\<lambda>hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm)\"", "lemma hm_repair_op_refine: \"(hm_repair_op, h.repair_op) \\<in> hmr_rel \\<rightarrow> nat_rel \\<rightarrow> \\<langle>hmr_rel\\<rangle>nres_rel\"", "lemmas hm_repair_op_refine'[refine] = hm_repair_op_refine[param_fo, THEN nres_relD]", "lemma hm_repair_op_\\<alpha>_correct: \"hm_repair_op hm i \\<le>\\<^sub>n SPEC (\\<lambda>hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm)\"", "lemma hm_empty_aref: \"(hm_empty_op,RETURN op_map_empty) \\<in> \\<langle>heapmap_rel\\<rangle>nres_rel\"", "lemma hm_insert_op_refine[refine]: \"\\<lbrakk> heapmap_\\<alpha> hm k = None; (hm,h)\\<in>hmr_rel \\<rbrakk> \\<Longrightarrow>\n      hm_insert_op k v hm \\<le> \\<Down>hmr_rel (h.insert_op v h)\"", "lemma hm_insert_op_aref: \n      \"(hm_insert_op,mop_map_update_new) \\<in> Id \\<rightarrow> Id \\<rightarrow> heapmap_rel \\<rightarrow> \\<langle>heapmap_rel\\<rangle>nres_rel\"", "lemma hmr_\\<alpha>_empty_iff[simp]: \n      \"hmr_invar hm \\<Longrightarrow> hmr_\\<alpha> hm = [] \\<longleftrightarrow> heapmap_\\<alpha> hm = Map.empty\"", "lemma hm_is_empty_op_refine: \"(hm_is_empty_op, h.is_empty_op) \\<in> hmr_rel \\<rightarrow> \\<langle>bool_rel\\<rangle>nres_rel\"", "lemma hm_is_empty_op_aref: \"(hm_is_empty_op, RETURN o op_map_is_empty) \\<in> heapmap_rel \\<rightarrow> \\<langle>bool_rel\\<rangle>nres_rel\"", "lemma hm_lookup_op_aref: \"(hm_lookup_op,RETURN oo op_map_lookup) \\<in> Id \\<rightarrow> heapmap_rel \\<rightarrow> \\<langle>\\<langle>Id\\<rangle>option_rel\\<rangle>nres_rel\"", "lemma hm_contains_key_op_aref: \"(hm_contains_key_op,RETURN oo op_map_contains_key) \\<in> Id \\<rightarrow> heapmap_rel \\<rightarrow> \\<langle>bool_rel\\<rangle>nres_rel\"", "lemma (in heapstruct) decrease_key_op_invar: \n      \"\\<lbrakk>heap_invar h; valid h i; prio v \\<le> prio_of h i\\<rbrakk> \\<Longrightarrow> decrease_key_op i v h \\<le> SPEC heap_invar\"", "lemma index_op_inline_refine:\n      assumes \"heapmap_invar hm\"\n      assumes \"heapmap_\\<alpha> hm k \\<noteq> None\"\n      assumes \"f (hm_index hm k) \\<le> m\"\n      shows \"do {i \\<leftarrow> hm_index_op hm k; f i} \\<le> m\"", "lemma hm_decrease_key_op_refine: \n      \"\\<lbrakk>(hm,h)\\<in>hmr_rel; (hm,m)\\<in>heapmap_rel; m k = Some v'\\<rbrakk> \n        \\<Longrightarrow> hm_decrease_key_op k v hm \\<le>\\<Down>hmr_rel (h.decrease_key_op (hm_index hm k) v h)\"", "lemma hm_index_op_inline_leof: \n      assumes \"f (hm_index hm k) \\<le>\\<^sub>n m\"\n      shows \"do {i \\<leftarrow> hm_index_op hm k; f i} \\<le>\\<^sub>n m\"", "lemma hm_decrease_key_op_\\<alpha>_correct: \n      \"heapmap_invar hm \\<Longrightarrow> hm_decrease_key_op k v hm \\<le>\\<^sub>n SPEC (\\<lambda>hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm(k\\<mapsto>v))\"", "lemma hm_decrease_key_op_aref: \n      \"(hm_decrease_key_op, PR_CONST (mop_pm_decrease_key prio)) \\<in> Id \\<rightarrow> Id \\<rightarrow> heapmap_rel \\<rightarrow> \\<langle>heapmap_rel\\<rangle>nres_rel\"", "lemma (in heapstruct) increase_key_op_invar: \n      \"\\<lbrakk>heap_invar h; valid h i; prio v \\<ge> prio_of h i\\<rbrakk> \\<Longrightarrow> increase_key_op i v h \\<le> SPEC heap_invar\"", "lemma hm_increase_key_op_refine: \n      \"\\<lbrakk>(hm,h)\\<in>hmr_rel; (hm,m)\\<in>heapmap_rel; m k = Some v'\\<rbrakk> \n        \\<Longrightarrow> hm_increase_key_op k v hm \\<le>\\<Down>hmr_rel (h.increase_key_op (hm_index hm k) v h)\"", "lemma hm_increase_key_op_\\<alpha>_correct: \n      \"heapmap_invar hm \\<Longrightarrow> hm_increase_key_op k v hm \\<le>\\<^sub>n SPEC (\\<lambda>hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm(k\\<mapsto>v))\"", "lemma hm_increase_key_op_aref: \n      \"(hm_increase_key_op, PR_CONST (mop_pm_increase_key prio)) \\<in> Id \\<rightarrow> Id \\<rightarrow> heapmap_rel \\<rightarrow> \\<langle>heapmap_rel\\<rangle>nres_rel\"", "lemma (in heapstruct) change_key_op_invar: \n      \"\\<lbrakk>heap_invar h; valid h i\\<rbrakk> \\<Longrightarrow> change_key_op i v h \\<le> SPEC heap_invar\"", "lemma hm_change_key_op_refine: \n      \"\\<lbrakk>(hm,h)\\<in>hmr_rel; (hm,m)\\<in>heapmap_rel; m k = Some v'\\<rbrakk> \n        \\<Longrightarrow> hm_change_key_op k v hm \\<le>\\<Down>hmr_rel (h.change_key_op (hm_index hm k) v h)\"", "lemma hm_change_key_op_\\<alpha>_correct: \n      \"heapmap_invar hm \\<Longrightarrow> hm_change_key_op k v hm \\<le>\\<^sub>n SPEC (\\<lambda>hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm(k\\<mapsto>v))\"", "lemma hm_change_key_op_aref: \n      \"(hm_change_key_op, mop_map_update_ex) \\<in> Id \\<rightarrow> Id \\<rightarrow> heapmap_rel \\<rightarrow> \\<langle>heapmap_rel\\<rangle>nres_rel\"", "lemma (in -) op_pm_set_gen_impl: \"RETURN ooo op_map_update = (\\<lambda>k v m. do {\n      c \\<leftarrow> RETURN (op_map_contains_key k m);\n      if c then \n        mop_map_update_ex k v m\n      else\n        mop_map_update_new k v m\n    })\"", "lemma hm_set_op_aref: \n      \"(hm_set_op, RETURN ooo op_map_update) \\<in> Id \\<rightarrow> Id \\<rightarrow> heapmap_rel \\<rightarrow> \\<langle>heapmap_rel\\<rangle>nres_rel\"", "lemma hm_pop_min_op_refine: \n      \"(hm_pop_min_op, h.pop_min_op) \\<in> hmr_rel \\<rightarrow> \\<langle>UNIV \\<times>\\<^sub>r hmr_rel\\<rangle>nres_rel\"", "lemma heapmap_min_prop:\n      assumes INV: \"heapmap_invar hm\"  \n      assumes V': \"heapmap_\\<alpha> hm k = Some v'\"\n      assumes NE: \"hm_valid hm (Suc 0)\"\n      shows \"prio (the (heapmap_\\<alpha> hm (hm_key_of hm (Suc 0)))) \\<le> prio v'\"", "lemma hm_pop_min_\\<alpha>_correct: \"hm_pop_min_op hm \\<le>\\<^sub>n SPEC (\\<lambda>((k,v),hm'). \n        heapmap_\\<alpha> hm k = Some v \n      \\<and> heapmap_\\<alpha> hm' = (heapmap_\\<alpha> hm)(k:=None) \n      \\<and> (\\<forall>k' v'. heapmap_\\<alpha> hm k' = Some v' \\<longrightarrow> prio v \\<le> prio v'))\"", "lemma heapmap_nres_rel_prodI:\n      assumes \"hmx \\<le> \\<Down>(UNIV \\<times>\\<^sub>r hmr_rel) h'x\"\n      assumes \"h'x \\<le> SPEC (\\<lambda>(_,h'). h.heap_invar h')\"\n      assumes \"hmx \\<le>\\<^sub>n SPEC (\\<lambda>(r,hm'). RETURN (r,heapmap_\\<alpha> hm') \\<le> \\<Down>(R\\<times>\\<^sub>rId) hx)\"\n      shows \"hmx \\<le> \\<Down>(R\\<times>\\<^sub>rheapmap_rel) hx\"", "lemma hm_pop_min_op_aref: \"(hm_pop_min_op, PR_CONST (mop_pm_pop_min prio)) \\<in> heapmap_rel \\<rightarrow> \\<langle>(Id\\<times>\\<^sub>rId)\\<times>\\<^sub>rheapmap_rel\\<rangle>nres_rel\"", "lemma hm_kv_op_refine[refine]:\n      assumes \"(hm,h)\\<in>hmr_rel\"\n      shows \"hm_kv_of_op hm i \\<le> \\<Down>(kvi_rel hm i) (h.val_of_op h i)\"", "lemma hm_pop_min_op_refine': \n      \"\\<lbrakk> (hm,h)\\<in>hmr_rel \\<rbrakk> \\<Longrightarrow> hm_pop_min_op' hm \\<le> \\<Down>(kvi_rel hm 1 \\<times>\\<^sub>r hmr_rel) (h.pop_min_op h)\"", "lemma heapmap_nres_rel_prodI':\n      assumes \"hmx \\<le> \\<Down>(S \\<times>\\<^sub>r hmr_rel) h'x\"\n      assumes \"h'x \\<le> SPEC \\<Phi>\"\n      assumes \"\\<And>h' r. \\<Phi> (r,h') \\<Longrightarrow> h.heap_invar h'\"\n      assumes \"hmx \\<le>\\<^sub>n SPEC (\\<lambda>(r,hm'). (\\<exists>r'. (r,r')\\<in>S \\<and> \\<Phi> (r',hmr_\\<alpha> hm')) \\<and> hmr_invar hm' \\<longrightarrow> RETURN (r,heapmap_\\<alpha> hm') \\<le> \\<Down>(R\\<times>\\<^sub>rId) hx)\"\n      shows \"hmx \\<le> \\<Down>(R\\<times>\\<^sub>rheapmap_rel) hx\"", "lemma ex_in_kvi_rel_conv:\n      \"(\\<exists>r'. (r,r')\\<in>kvi_rel hm i \\<and> \\<Phi> r') \\<longleftrightarrow> (fst r = hm_key_of hm i \\<and> \\<Phi> (snd r))\"", "lemma hm_pop_min_aref': \"(hm_pop_min_op', mop_pm_pop_min prio) \\<in> heapmap_rel \\<rightarrow> \\<langle>(Id\\<times>\\<^sub>rId) \\<times>\\<^sub>r heapmap_rel\\<rangle>nres_rel\"", "lemma (in -) swap_empty_iff[iff]: \"swap l i j = [] \\<longleftrightarrow> l=[]\"", "lemma (in heapstruct) \n      butlast_exch_last: \"butlast (exch h i (length h)) = update (butlast h) i (last h)\"", "lemma (in heapstruct) remove_op_invar: \n      \"\\<lbrakk> heap_invar h; valid h i \\<rbrakk> \\<Longrightarrow> remove_op i h \\<le> SPEC heap_invar\"", "lemma hm_remove_op_refine[refine]: \n      \"\\<lbrakk> (hm,m)\\<in>heapmap_rel; (hm,h)\\<in>hmr_rel; heapmap_\\<alpha> hm k \\<noteq> None\\<rbrakk> \\<Longrightarrow> \n        hm_remove_op k hm \\<le> \\<Down>hmr_rel (h.remove_op (hm_index hm k) h)\"", "lemma hm_remove_op_\\<alpha>_correct: \n      \"hm_remove_op k hm \\<le>\\<^sub>n SPEC (\\<lambda>hm'. heapmap_\\<alpha> hm' = (heapmap_\\<alpha> hm)(k:=None))\"", "lemma hm_remove_op_aref:\n      \"(hm_remove_op,mop_map_delete_ex) \\<in> Id \\<rightarrow> heapmap_rel \\<rightarrow> \\<langle>heapmap_rel\\<rangle>nres_rel\"", "lemma hm_peek_min_op_aref: \n      \"(hm_peek_min_op, PR_CONST (mop_pm_peek_min prio)) \\<in> heapmap_rel \\<rightarrow> \\<langle>Id\\<times>\\<^sub>rId\\<rangle>nres_rel\""], "translations": [["", "lemmas hmr_rel_defs = hmr_rel_def br_def hmr_\\<alpha>_def hmr_invar_def"], ["", "lemma hmr_empty_invar[simp]: \"hmr_invar ([],Map.empty)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hmr_invar ([], Map.empty)", "by (auto simp: hmr_invar_def)"], ["", "locale hmstruct = h: heapstruct prio for prio :: \"'v \\<Rightarrow> 'b::linorder\"\n  begin"], ["", "text \\<open>Next, we define a mapping to priority maps.\\<close>"], ["", "definition heapmap_\\<alpha> :: \"('k,'v) ahm \\<Rightarrow> ('k \\<rightharpoonup> 'v)\" where\n      \"heapmap_\\<alpha> \\<equiv> \\<lambda>(pq,m). m\""], ["", "definition heapmap_invar :: \"('k,'v) ahm \\<Rightarrow> bool\" where\n      \"heapmap_invar \\<equiv> \\<lambda>hm. hmr_invar hm \\<and> h.heap_invar (hmr_\\<alpha> hm)\""], ["", "definition \"heapmap_rel \\<equiv> br heapmap_\\<alpha> heapmap_invar\""], ["", "lemmas heapmap_rel_defs = heapmap_rel_def br_def heapmap_\\<alpha>_def heapmap_invar_def"], ["", "lemma [refine_dref_RELATES]: \"RELATES hmr_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RELATES hmr_rel", "by (simp add: RELATES_def)"], ["", "lemma h_heap_invarI[simp]: \"heapmap_invar hm \\<Longrightarrow> h.heap_invar (hmr_\\<alpha> hm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heapmap_invar hm \\<Longrightarrow> h.heap_invar (hmr_\\<alpha> hm)", "by (simp add: heapmap_invar_def)"], ["", "lemma hmr_invarI[simp]: \"heapmap_invar hm \\<Longrightarrow> hmr_invar hm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heapmap_invar hm \\<Longrightarrow> hmr_invar hm", "unfolding heapmap_invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hmr_invar hm \\<and> h.heap_invar (hmr_\\<alpha> hm) \\<Longrightarrow>\n    hmr_invar hm", "by blast"], ["", "lemma set_hmr_\\<alpha>[simp]: \"hmr_invar hm \\<Longrightarrow> set (hmr_\\<alpha> hm) = ran (heapmap_\\<alpha> hm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hmr_invar hm \\<Longrightarrow>\n    set (hmr_\\<alpha> hm) = ran (heapmap_\\<alpha> hm)", "apply (clarsimp simp: hmr_\\<alpha>_def hmr_invar_def heapmap_\\<alpha>_def \n        eq_commute[of \"dom _\" \"set _\"] ran_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>hm = (x, y); distinct x; set x = dom y\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. the (y x)) ` dom y =\n                         {b. \\<exists>a. y a = Some b}", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma in_h_hmr_\\<alpha>_conv[simp]: \"hmr_invar hm \\<Longrightarrow> x \\<in># h.\\<alpha> (hmr_\\<alpha> hm) \\<longleftrightarrow> x \\<in> ran (heapmap_\\<alpha> hm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hmr_invar hm \\<Longrightarrow>\n    (x \\<in># h.\\<alpha> (hmr_\\<alpha> hm)) =\n    (x \\<in> ran (heapmap_\\<alpha> hm))", "by (force simp: hmr_\\<alpha>_def hmr_invar_def heapmap_\\<alpha>_def in_multiset_in_set ran_is_image)"], ["", "subsection \\<open>Basic Operations\\<close>"], ["", "(* length, val_of_op, update, butlast, append, empty *)"], ["", "text \\<open>In this section, we define the basic operations on heapmaps, \n      and their relations to heaps and maps.\\<close>"], ["", "subsubsection \\<open>Length\\<close>"], ["", "text \\<open>Length of the list that represents the heap\\<close>"], ["", "definition hm_length :: \"('k,'v) ahm \\<Rightarrow> nat\" where\n      \"hm_length \\<equiv> \\<lambda>(pq,_). length pq\""], ["", "lemma hm_length_refine: \"(hm_length, length) \\<in> hmr_rel \\<rightarrow> nat_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hm_length, length) \\<in> hmr_rel \\<rightarrow> nat_rel", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> hmr_rel \\<Longrightarrow>\n       (hm_length a, length a') \\<in> nat_rel", "unfolding hm_length_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> hmr_rel \\<Longrightarrow>\n       (case a of (pq, uu_) \\<Rightarrow> length pq, length a')\n       \\<in> nat_rel", "by (auto simp: hmr_rel_defs)"], ["", "lemma hm_length_hmr_\\<alpha>[simp]: \"length (hmr_\\<alpha> hm) = hm_length hm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (hmr_\\<alpha> hm) = hm_length hm", "by (auto simp: hm_length_def hmr_\\<alpha>_def split: prod.splits)"], ["", "lemmas [refine] = hm_length_refine[param_fo]"], ["", "subsubsection \\<open>Valid\\<close>"], ["", "text \\<open>Check whether index is valid\\<close>"], ["", "definition \"hm_valid hm i \\<equiv> i>0 \\<and> i\\<le> hm_length hm\""], ["", "lemma hm_valid_refine: \"(hm_valid,h.valid)\\<in>hmr_rel \\<rightarrow> nat_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hm_valid, h.valid)\n    \\<in> hmr_rel \\<rightarrow> nat_rel \\<rightarrow> bool_rel", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> (hm_valid a aa, h.valid a' a'a) \\<in> bool_rel", "unfolding hm_valid_def h.valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> (0 < aa \\<and> aa \\<le> hm_length a,\n                          0 < a'a \\<and> a'a \\<le> length a')\n                         \\<in> bool_rel", "by (parametricity add: hm_length_refine)"], ["", "lemma hm_valid_hmr_\\<alpha>[simp]: \"h.valid (hmr_\\<alpha> hm) = hm_valid hm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h.valid (hmr_\\<alpha> hm) = hm_valid hm", "by (intro ext) (auto simp: h.valid_def hm_valid_def)"], ["", "subsubsection \\<open>Key-Of\\<close>"], ["", "definition hm_key_of :: \"('k,'v) ahm \\<Rightarrow> nat \\<Rightarrow> 'k\" where  \n      \"hm_key_of \\<equiv> \\<lambda>(pq,m) i. pq!(i - 1)\""], ["", "definition hm_key_of_op :: \"('k,'v) ahm \\<Rightarrow> nat \\<Rightarrow> 'k nres\" where\n      \"hm_key_of_op \\<equiv> \\<lambda>(pq,m) i. ASSERT (i>0) \\<then> mop_list_get pq (i - 1)\""], ["", "lemma hm_key_of_op_unfold:\n      shows \"hm_key_of_op hm i = ASSERT (hm_valid hm i) \\<then> RETURN (hm_key_of hm i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_key_of_op hm i =\n    ASSERT (hm_valid hm i) \\<bind> (\\<lambda>_. RETURN (hm_key_of hm i))", "unfolding hm_valid_def hm_length_def hm_key_of_op_def hm_key_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case hm of\n     (pq, m) \\<Rightarrow>\n       \\<lambda>i.\n          ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_get pq (i - 1)))\n     i =\n    ASSERT\n     (0 < i \\<and>\n      i \\<le> (case hm of (pq, uu_) \\<Rightarrow> length pq)) \\<bind>\n    (\\<lambda>_.\n        RETURN\n         ((case hm of (pq, m) \\<Rightarrow> \\<lambda>i. pq ! (i - 1)) i))", "by (auto split: prod.splits simp: pw_eq_iff refine_pw_simps)"], ["", "lemma val_of_hmr_\\<alpha>[simp]: \"hm_valid hm i \\<Longrightarrow> h.val_of (hmr_\\<alpha> hm) i \n      = the (heapmap_\\<alpha> hm (hm_key_of hm i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_valid hm i \\<Longrightarrow>\n    h.val_of (hmr_\\<alpha> hm) i =\n    the (heapmap_\\<alpha> hm (hm_key_of hm i))", "by (auto \n        simp: hmr_\\<alpha>_def h.val_of_def heapmap_\\<alpha>_def hm_key_of_def hm_valid_def hm_length_def\n        split: prod.splits)"], ["", "lemma hm_\\<alpha>_key_ex[simp]:\n      \"\\<lbrakk>hmr_invar hm; hm_valid hm i\\<rbrakk> \\<Longrightarrow> (heapmap_\\<alpha> hm (hm_key_of hm i) \\<noteq> None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hmr_invar hm; hm_valid hm i\\<rbrakk>\n    \\<Longrightarrow> heapmap_\\<alpha> hm (hm_key_of hm i) \\<noteq> None", "unfolding heapmap_invar_def hmr_invar_def hm_valid_def heapmap_\\<alpha>_def \n        hm_key_of_def hm_length_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>case hm of\n             (pq, m) \\<Rightarrow> distinct pq \\<and> dom m = set pq;\n     0 < i \\<and>\n     i \\<le> (case hm of (pq, uu_) \\<Rightarrow> length pq)\\<rbrakk>\n    \\<Longrightarrow> (case hm of (pq, m) \\<Rightarrow> m)\n                       ((case hm of\n                         (pq, m) \\<Rightarrow> \\<lambda>i. pq ! (i - 1))\n                         i) \\<noteq>\n                      None", "by (auto split: prod.splits)"], ["", "subsubsection \\<open>Lookup\\<close>"], ["", "abbreviation (input) hm_lookup where \"hm_lookup \\<equiv> heapmap_\\<alpha>\""], ["", "definition \"hm_the_lookup_op hm k \\<equiv> \n      ASSERT (heapmap_\\<alpha> hm k \\<noteq> None \\<and> hmr_invar hm) \n      \\<then> RETURN (the (heapmap_\\<alpha> hm k))\""], ["", "subsubsection \\<open>Exchange\\<close>"], ["", "text \\<open>Exchange two indices\\<close>"], ["", "definition \"hm_exch_op \\<equiv> \\<lambda>(pq,m) i j. do {\n      ASSERT (hm_valid (pq,m) i);\n      ASSERT (hm_valid (pq,m) j);\n      ASSERT (hmr_invar (pq,m));\n      pq \\<leftarrow> mop_list_swap pq (i - 1) (j - 1);\n      RETURN (pq,m)\n    }\""], ["", "lemma hm_exch_op_invar: \"hm_exch_op hm i j \\<le>\\<^sub>n SPEC hmr_invar\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_exch_op hm i j \\<le>\\<^sub>n SPEC hmr_invar", "unfolding hm_exch_op_def h.exch_op_def h.val_of_op_def h.update_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case hm of\n     (pq, m) \\<Rightarrow>\n       \\<lambda>i j.\n          ASSERT (hm_valid (pq, m) i) \\<bind>\n          (\\<lambda>_.\n              ASSERT (hm_valid (pq, m) j) \\<bind>\n              (\\<lambda>_.\n                  ASSERT (hmr_invar (pq, m)) \\<bind>\n                  (\\<lambda>_.\n                      mop_list_swap pq (i - 1) (j - 1) \\<bind>\n                      (\\<lambda>pq. RETURN (pq, m))))))\n     i j \\<le>\\<^sub>n\n    SPEC hmr_invar", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case hm of\n     (pq, m) \\<Rightarrow>\n       \\<lambda>i j.\n          ASSERT (hm_valid (pq, m) i) \\<bind>\n          (\\<lambda>_.\n              ASSERT (hm_valid (pq, m) j) \\<bind>\n              (\\<lambda>_.\n                  ASSERT (hmr_invar (pq, m)) \\<bind>\n                  (\\<lambda>_.\n                      ASSERT\n                       (i - Suc 0 < length pq \\<and>\n                        j - Suc 0 < length pq) \\<bind>\n                      (\\<lambda>x.\n                          RETURN (swap pq (i - Suc 0) (j - Suc 0), m))))))\n     i j \\<le>\\<^sub>n\n    SPEC hmr_invar", "apply refine_vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>hm = (x1, x2); hm_valid (x1, x2) i; hm_valid (x1, x2) j;\n        hmr_invar (x1, x2);\n        i - Suc 0 < length x1 \\<and> j - Suc 0 < length x1\\<rbrakk>\n       \\<Longrightarrow> hmr_invar (swap x1 (i - Suc 0) (j - Suc 0), x2)", "apply (auto simp: hm_valid_def map_swap hm_length_def hmr_rel_defs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hm_exch_op_refine: \"(hm_exch_op,h.exch_op) \\<in> hmr_rel \\<rightarrow> nat_rel \\<rightarrow> nat_rel \\<rightarrow> \\<langle>hmr_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hm_exch_op, h.exch_op)\n    \\<in> hmr_rel \\<rightarrow>\n          nat_rel \\<rightarrow>\n          nat_rel \\<rightarrow> \\<langle>hmr_rel\\<rangle>nres_rel", "apply (intro fun_relI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n        (ab, a'b) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> hm_exch_op a aa ab\n                         \\<le> \\<Down> hmr_rel (h.exch_op a' a'a a'b)", "unfolding hm_exch_op_def h.exch_op_def h.val_of_op_def h.update_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n        (ab, a'b) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> (case a of\n                          (pq, m) \\<Rightarrow>\n                            \\<lambda>i j.\n                               ASSERT (hm_valid (pq, m) i) \\<bind>\n                               (\\<lambda>_.\n                                   ASSERT (hm_valid (pq, m) j) \\<bind>\n                                   (\\<lambda>_.\n ASSERT (hmr_invar (pq, m)) \\<bind>\n (\\<lambda>_.\n     mop_list_swap pq (i - 1) (j - 1) \\<bind>\n     (\\<lambda>pq. RETURN (pq, m))))))\n                          aa ab\n                         \\<le> \\<Down> hmr_rel\n                                (ASSERT (0 < a'a \\<and> 0 < a'b) \\<bind>\n                                 (\\<lambda>_.\n                                     mop_list_swap a' (a'a - 1)\n(a'b - 1) \\<bind>\n                                     RETURN))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; aa = a'a; ab = a'b\\<rbrakk>\n       \\<Longrightarrow> (case a of\n                          (pq, m) \\<Rightarrow>\n                            \\<lambda>i j.\n                               ASSERT (hm_valid (pq, m) i) \\<bind>\n                               (\\<lambda>_.\n                                   ASSERT (hm_valid (pq, m) j) \\<bind>\n                                   (\\<lambda>_.\n ASSERT (hmr_invar (pq, m)) \\<bind>\n (\\<lambda>_.\n     ASSERT (i - Suc 0 < length pq \\<and> j - Suc 0 < length pq) \\<bind>\n     (\\<lambda>x. RETURN (swap pq (i - Suc 0) (j - Suc 0), m))))))\n                          a'a a'b\n                         \\<le> \\<Down> hmr_rel\n                                (ASSERT (0 < a'a \\<and> 0 < a'b) \\<bind>\n                                 (\\<lambda>_.\n                                     ASSERT\n(a'a - Suc 0 < length a' \\<and> a'b - Suc 0 < length a') \\<bind>\n                                     (\\<lambda>_.\n   RETURN (swap a' (a'a - Suc 0) (a'b - Suc 0)))))", "apply refine_vcg"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a a' aa a'a ab a'b x1 x2.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; aa = a'a; ab = a'b;\n        0 < a'a \\<and> 0 < a'b;\n        a'a - Suc 0 < length a' \\<and> a'b - Suc 0 < length a';\n        a = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> hm_valid (x1, x2) a'a\n 2. \\<And>a a' aa a'a ab a'b x1 x2.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; aa = a'a; ab = a'b;\n        0 < a'a \\<and> 0 < a'b;\n        a'a - Suc 0 < length a' \\<and> a'b - Suc 0 < length a';\n        a = (x1, x2); hm_valid (x1, x2) a'a\\<rbrakk>\n       \\<Longrightarrow> hm_valid (x1, x2) a'b\n 3. \\<And>a a' aa a'a ab a'b x1 x2.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; aa = a'a; ab = a'b;\n        0 < a'a \\<and> 0 < a'b;\n        a'a - Suc 0 < length a' \\<and> a'b - Suc 0 < length a';\n        a = (x1, x2); hm_valid (x1, x2) a'a; hm_valid (x1, x2) a'b\\<rbrakk>\n       \\<Longrightarrow> hmr_invar (x1, x2)\n 4. \\<And>a a' aa a'a ab a'b x1 x2.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; aa = a'a; ab = a'b;\n        0 < a'a \\<and> 0 < a'b;\n        a'a - Suc 0 < length a' \\<and> a'b - Suc 0 < length a';\n        a = (x1, x2); hm_valid (x1, x2) a'a; hm_valid (x1, x2) a'b;\n        hmr_invar (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> a'a - Suc 0 < length x1\n 5. \\<And>a a' aa a'a ab a'b x1 x2.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; aa = a'a; ab = a'b;\n        0 < a'a \\<and> 0 < a'b;\n        a'a - Suc 0 < length a' \\<and> a'b - Suc 0 < length a';\n        a = (x1, x2); hm_valid (x1, x2) a'a; hm_valid (x1, x2) a'b;\n        hmr_invar (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> a'b - Suc 0 < length x1\n 6. \\<And>a a' aa a'a ab a'b x1 x2.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; aa = a'a; ab = a'b;\n        0 < a'a \\<and> 0 < a'b;\n        a'a - Suc 0 < length a' \\<and> a'b - Suc 0 < length a';\n        a = (x1, x2); hm_valid (x1, x2) a'a; hm_valid (x1, x2) a'b;\n        hmr_invar (x1, x2);\n        a'a - Suc 0 < length x1 \\<and> a'b - Suc 0 < length x1\\<rbrakk>\n       \\<Longrightarrow> ((swap x1 (a'a - Suc 0) (a'b - Suc 0), x2),\n                          swap a' (a'a - Suc 0) (a'b - Suc 0))\n                         \\<in> hmr_rel", "apply (auto simp: hm_valid_def map_swap hm_length_def hmr_rel_defs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas hm_exch_op_refine'[refine] = hm_exch_op_refine[param_fo, THEN nres_relD]"], ["", "definition hm_exch :: \"('k,'v) ahm \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> ('k,'v) ahm\"\n      where \"hm_exch \\<equiv> \\<lambda>(pq,m) i j. (swap pq (i-1) (j-1),m)\""], ["", "lemma hm_exch_op_\\<alpha>_correct: \"hm_exch_op hm i j \\<le>\\<^sub>n SPEC (\\<lambda>hm'. \n      hm_valid hm i \\<and> hm_valid hm j \\<and> hm'=hm_exch hm i j\n      )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_exch_op hm i j \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>hm'.\n         hm_valid hm i \\<and> hm_valid hm j \\<and> hm' = hm_exch hm i j)", "unfolding hm_exch_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case hm of\n     (pq, m) \\<Rightarrow>\n       \\<lambda>i j.\n          ASSERT (hm_valid (pq, m) i) \\<bind>\n          (\\<lambda>_.\n              ASSERT (hm_valid (pq, m) j) \\<bind>\n              (\\<lambda>_.\n                  ASSERT (hmr_invar (pq, m)) \\<bind>\n                  (\\<lambda>_.\n                      mop_list_swap pq (i - 1) (j - 1) \\<bind>\n                      (\\<lambda>pq. RETURN (pq, m))))))\n     i j \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>hm'.\n         hm_valid hm i \\<and> hm_valid hm j \\<and> hm' = hm_exch hm i j)", "apply refine_vcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>hm = (x1, x2); hm_valid (x1, x2) i; hm_valid (x1, x2) j;\n        hmr_invar (x1, x2);\n        i - 1 < length x1 \\<and> j - 1 < length x1\\<rbrakk>\n       \\<Longrightarrow> hm_valid hm i\n 2. \\<And>x1 x2.\n       \\<lbrakk>hm = (x1, x2); hm_valid (x1, x2) i; hm_valid (x1, x2) j;\n        hmr_invar (x1, x2);\n        i - 1 < length x1 \\<and> j - 1 < length x1\\<rbrakk>\n       \\<Longrightarrow> hm_valid hm j\n 3. \\<And>x1 x2.\n       \\<lbrakk>hm = (x1, x2); hm_valid (x1, x2) i; hm_valid (x1, x2) j;\n        hmr_invar (x1, x2);\n        i - 1 < length x1 \\<and> j - 1 < length x1\\<rbrakk>\n       \\<Longrightarrow> (swap x1 (i - 1) (j - 1), x2) = hm_exch hm i j", "apply (vc_solve simp: hm_valid_def hm_length_def heapmap_\\<alpha>_def solve: asm_rl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>hm = (x1, x2); hmr_invar (x1, x2); 0 < i; i \\<le> length x1;\n        0 < j; j \\<le> length x1; i - Suc 0 < length x1;\n        j - Suc 0 < length x1\\<rbrakk>\n       \\<Longrightarrow> (swap x1 (i - Suc 0) (j - Suc 0), x2) =\n                         hm_exch (x1, x2) i j", "apply (auto simp add: hm_key_of_def hm_exch_def swap_def) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hm_exch_\\<alpha>[simp]: \"heapmap_\\<alpha> (hm_exch hm i j) = (heapmap_\\<alpha> hm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heapmap_\\<alpha> (hm_exch hm i j) = heapmap_\\<alpha> hm", "by (auto simp: heapmap_\\<alpha>_def hm_exch_def split: prod.splits)"], ["", "lemma hm_exch_valid[simp]: \"hm_valid (hm_exch hm i j) = hm_valid hm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_valid (hm_exch hm i j) = hm_valid hm", "by (intro ext) (auto simp: hm_valid_def hm_length_def hm_exch_def split: prod.splits)"], ["", "lemma hm_exch_length[simp]: \"hm_length (hm_exch hm i j) = hm_length hm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_length (hm_exch hm i j) = hm_length hm", "by (auto simp: hm_length_def hm_exch_def split: prod.splits)"], ["", "lemma hm_exch_same[simp]: \"hm_exch hm i i = hm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_exch hm i i = hm", "by (auto simp: hm_exch_def split: prod.splits)"], ["", "lemma hm_key_of_exch_conv[simp]:   \n      \"\\<lbrakk>hm_valid hm i; hm_valid hm j; hm_valid hm k\\<rbrakk> \\<Longrightarrow> \n        hm_key_of (hm_exch hm i j) k = (\n          if k=i then hm_key_of hm j\n          else if k=j then hm_key_of hm i\n          else hm_key_of hm k\n          )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hm_valid hm i; hm_valid hm j; hm_valid hm k\\<rbrakk>\n    \\<Longrightarrow> hm_key_of (hm_exch hm i j) k =\n                      (if k = i then hm_key_of hm j\n                       else if k = j then hm_key_of hm i\n                            else hm_key_of hm k)", "unfolding hm_exch_def hm_valid_def hm_length_def hm_key_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < i \\<and>\n             i \\<le> (case hm of (pq, uu_) \\<Rightarrow> length pq);\n     0 < j \\<and> j \\<le> (case hm of (pq, uu_) \\<Rightarrow> length pq);\n     0 < k \\<and>\n     k \\<le> (case hm of (pq, uu_) \\<Rightarrow> length pq)\\<rbrakk>\n    \\<Longrightarrow> (case (case hm of\n                             (pq, m) \\<Rightarrow>\n                               \\<lambda>i j. (swap pq (i - 1) (j - 1), m))\n                             i j of\n                       (pq, m) \\<Rightarrow> \\<lambda>i. pq ! (i - 1))\n                       k =\n                      (if k = i\n                       then (case hm of\n                             (pq, m) \\<Rightarrow> \\<lambda>i. pq ! (i - 1))\n                             j\n                       else if k = j\n                            then (case hm of\n                                  (pq, m) \\<Rightarrow>\n                                    \\<lambda>i. pq ! (i - 1))\n                                  i\n                            else (case hm of\n                                  (pq, m) \\<Rightarrow>\n                                    \\<lambda>i. pq ! (i - 1))\n                                  k)", "by (auto split: prod.splits)"], ["", "lemma hm_key_of_exch_matching[simp]:  \n      \"\\<lbrakk>hm_valid hm i; hm_valid hm j\\<rbrakk> \\<Longrightarrow> hm_key_of (hm_exch hm i j) i = hm_key_of hm j\"\n      \"\\<lbrakk>hm_valid hm i; hm_valid hm j\\<rbrakk> \\<Longrightarrow> hm_key_of (hm_exch hm i j) j = hm_key_of hm i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>hm_valid hm i; hm_valid hm j\\<rbrakk>\n     \\<Longrightarrow> hm_key_of (hm_exch hm i j) i = hm_key_of hm j) &&&\n    (\\<lbrakk>hm_valid hm i; hm_valid hm j\\<rbrakk>\n     \\<Longrightarrow> hm_key_of (hm_exch hm i j) j = hm_key_of hm i)", "by simp_all"], ["", "subsubsection \\<open>Index\\<close>"], ["", "text \\<open>Obtaining the index of a key\\<close>"], ["", "definition \"hm_index \\<equiv> \\<lambda>(pq,m) k. index pq k + 1\""], ["", "lemma hm_index_valid[simp]: \"\\<lbrakk>hmr_invar hm; heapmap_\\<alpha> hm k \\<noteq> None\\<rbrakk> \\<Longrightarrow> hm_valid hm (hm_index hm k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hmr_invar hm; heapmap_\\<alpha> hm k \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> hm_valid hm (hm_index hm k)", "by (force simp: hm_valid_def heapmap_\\<alpha>_def hmr_invar_def hm_index_def hm_length_def Suc_le_eq)"], ["", "lemma hm_index_key_of[simp]: \"\\<lbrakk>hmr_invar hm; heapmap_\\<alpha> hm k \\<noteq> None\\<rbrakk> \\<Longrightarrow> hm_key_of hm (hm_index hm k) = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hmr_invar hm; heapmap_\\<alpha> hm k \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> hm_key_of hm (hm_index hm k) = k", "by (force \n          simp: hm_valid_def heapmap_\\<alpha>_def hmr_invar_def hm_index_def hm_length_def hm_key_of_def Suc_le_eq)"], ["", "definition \"hm_index_op \\<equiv> \\<lambda>(pq,m) k. \n      do {\n        ASSERT (hmr_invar (pq,m) \\<and> heapmap_\\<alpha> (pq,m) k \\<noteq> None);\n        i \\<leftarrow> mop_list_index pq k;\n        RETURN (i+1)\n      }\""], ["", "lemma hm_index_op_correct:\n      assumes \"hmr_invar hm\"\n      assumes \"heapmap_\\<alpha> hm k \\<noteq> None\"\n      shows \"hm_index_op hm k \\<le> SPEC (\\<lambda>r. r= hm_index hm k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_index_op hm k \\<le> SPEC (\\<lambda>r. r = hm_index hm k)", "using assms"], ["proof (prove)\nusing this:\n  hmr_invar hm\n  heapmap_\\<alpha> hm k \\<noteq> None\n\ngoal (1 subgoal):\n 1. hm_index_op hm k \\<le> SPEC (\\<lambda>r. r = hm_index hm k)", "unfolding hm_index_op_def"], ["proof (prove)\nusing this:\n  hmr_invar hm\n  heapmap_\\<alpha> hm k \\<noteq> None\n\ngoal (1 subgoal):\n 1. (case hm of\n     (pq, m) \\<Rightarrow>\n       \\<lambda>k.\n          ASSERT\n           (hmr_invar (pq, m) \\<and>\n            heapmap_\\<alpha> (pq, m) k \\<noteq> None) \\<bind>\n          (\\<lambda>_.\n              mop_list_index pq k \\<bind> (\\<lambda>i. RETURN (i + 1))))\n     k\n    \\<le> SPEC (\\<lambda>r. r = hm_index hm k)", "apply refine_vcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>hmr_invar hm; heapmap_\\<alpha> hm k \\<noteq> None;\n        hm = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> hmr_invar (x1, x2)\n 2. \\<And>x1 x2.\n       \\<lbrakk>hmr_invar hm; heapmap_\\<alpha> hm k \\<noteq> None;\n        hm = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> heapmap_\\<alpha> (x1, x2) k \\<noteq> None\n 3. \\<And>x1 x2.\n       \\<lbrakk>hmr_invar hm; heapmap_\\<alpha> hm k \\<noteq> None;\n        hm = (x1, x2);\n        hmr_invar (x1, x2) \\<and>\n        heapmap_\\<alpha> (x1, x2) k \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> index x1 k + 1 = hm_index hm k", "apply (auto simp: heapmap_\\<alpha>_def hmr_invar_def hm_index_def index_nth_id)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas [refine_vcg] = hm_index_op_correct"], ["", "subsubsection \\<open>Update\\<close>"], ["", "text \\<open>Updating the heap at an index\\<close>"], ["", "definition hm_update_op :: \"('k,'v) ahm \\<Rightarrow> nat \\<Rightarrow> 'v \\<Rightarrow> ('k,'v) ahm nres\" where\n      \"hm_update_op \\<equiv> \\<lambda>(pq,m) i v. do {\n        ASSERT (hm_valid (pq,m) i \\<and> hmr_invar (pq,m));\n        k \\<leftarrow> mop_list_get pq (i - 1);\n        RETURN (pq, m(k \\<mapsto> v))\n      }\""], ["", "lemma hm_update_op_invar: \"hm_update_op hm k v \\<le>\\<^sub>n SPEC hmr_invar\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_update_op hm k v \\<le>\\<^sub>n SPEC hmr_invar", "unfolding hm_update_op_def h.update_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case hm of\n     (pq, m) \\<Rightarrow>\n       \\<lambda>i v.\n          ASSERT (hm_valid (pq, m) i \\<and> hmr_invar (pq, m)) \\<bind>\n          (\\<lambda>_.\n              mop_list_get pq (i - 1) \\<bind>\n              (\\<lambda>k. RETURN (pq, m(k \\<mapsto> v)))))\n     k v \\<le>\\<^sub>n\n    SPEC hmr_invar", "apply refine_vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>hm = (x1, x2);\n        hm_valid (x1, x2) k \\<and> hmr_invar (x1, x2);\n        k - 1 < length x1\\<rbrakk>\n       \\<Longrightarrow> hmr_invar (x1, x2(x1 ! (k - 1) \\<mapsto> v))", "by (auto simp: hmr_rel_defs map_distinct_upd_conv hm_valid_def hm_length_def)"], ["", "lemma hm_update_op_refine: \"(hm_update_op, h.update_op) \\<in> hmr_rel \\<rightarrow> nat_rel \\<rightarrow> Id \\<rightarrow> \\<langle>hmr_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hm_update_op, h.update_op)\n    \\<in> hmr_rel \\<rightarrow>\n          nat_rel \\<rightarrow>\n          Id \\<rightarrow> \\<langle>hmr_rel\\<rangle>nres_rel", "apply (intro fun_relI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n        (ab, a'b) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> hm_update_op a aa ab\n                         \\<le> \\<Down> hmr_rel (h.update_op a' a'a a'b)", "unfolding hm_update_op_def h.update_op_def mop_list_get_alt mop_list_set_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n        (ab, a'b) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> (case a of\n                          (pq, m) \\<Rightarrow>\n                            \\<lambda>i v.\n                               ASSERT\n                                (hm_valid (pq, m) i \\<and>\n                                 hmr_invar (pq, m)) \\<bind>\n                               (\\<lambda>_.\n                                   ASSERT (pre_list_get (pq, i - 1)) \\<bind>\n                                   (\\<lambda>_.\n RETURN (op_list_get pq (i - 1))) \\<bind>\n                                   (\\<lambda>k.\n RETURN (pq, m(k \\<mapsto> v)))))\n                          aa ab\n                         \\<le> \\<Down> hmr_rel\n                                (ASSERT (0 < a'a) \\<bind>\n                                 (\\<lambda>_.\n                                     ASSERT\n(pre_list_set ((a', a'a - 1), a'b)) \\<bind>\n                                     (\\<lambda>_.\n   RETURN (op_list_set a' (a'a - 1) a'b))))", "apply refine_vcg"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a a' aa a'a ab a'b x1 x2.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n        (ab, a'b) \\<in> Id; 0 < a'a; pre_list_set ((a', a'a - 1), a'b);\n        a = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> hm_valid (x1, x2) aa\n 2. \\<And>a a' aa a'a ab a'b x1 x2.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n        (ab, a'b) \\<in> Id; 0 < a'a; pre_list_set ((a', a'a - 1), a'b);\n        a = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> hmr_invar (x1, x2)\n 3. \\<And>a a' aa a'a ab a'b x1 x2.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n        (ab, a'b) \\<in> Id; 0 < a'a; pre_list_set ((a', a'a - 1), a'b);\n        a = (x1, x2);\n        hm_valid (x1, x2) aa \\<and> hmr_invar (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> pre_list_get (x1, aa - 1)\n 4. \\<And>a a' aa a'a ab a'b x1 x2.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n        (ab, a'b) \\<in> Id; 0 < a'a; pre_list_set ((a', a'a - 1), a'b);\n        a = (x1, x2); hm_valid (x1, x2) aa \\<and> hmr_invar (x1, x2);\n        pre_list_get (x1, aa - 1)\\<rbrakk>\n       \\<Longrightarrow> ((x1, x2(op_list_get x1 (aa - 1) \\<mapsto> ab)),\n                          op_list_set a' (a'a - 1) a'b)\n                         \\<in> hmr_rel", "apply (auto simp: hmr_rel_defs map_distinct_upd_conv hm_valid_def hm_length_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas [refine] = hm_update_op_refine[param_fo, THEN nres_relD]"], ["", "lemma hm_update_op_\\<alpha>_correct:\n      assumes \"hmr_invar hm\"\n      assumes \"heapmap_\\<alpha> hm k \\<noteq> None\"\n      shows \"hm_update_op hm (hm_index hm k) v \\<le>\\<^sub>n SPEC (\\<lambda>hm'. heapmap_\\<alpha> hm' = (heapmap_\\<alpha> hm)(k\\<mapsto>v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_update_op hm (hm_index hm k) v \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>hm'.\n         heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm(k \\<mapsto> v))", "using assms"], ["proof (prove)\nusing this:\n  hmr_invar hm\n  heapmap_\\<alpha> hm k \\<noteq> None\n\ngoal (1 subgoal):\n 1. hm_update_op hm (hm_index hm k) v \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>hm'.\n         heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm(k \\<mapsto> v))", "unfolding hm_update_op_def"], ["proof (prove)\nusing this:\n  hmr_invar hm\n  heapmap_\\<alpha> hm k \\<noteq> None\n\ngoal (1 subgoal):\n 1. (case hm of\n     (pq, m) \\<Rightarrow>\n       \\<lambda>i v.\n          ASSERT (hm_valid (pq, m) i \\<and> hmr_invar (pq, m)) \\<bind>\n          (\\<lambda>_.\n              mop_list_get pq (i - 1) \\<bind>\n              (\\<lambda>k. RETURN (pq, m(k \\<mapsto> v)))))\n     (hm_index hm k) v \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>hm'.\n         heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm(k \\<mapsto> v))", "apply refine_vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>hmr_invar hm; heapmap_\\<alpha> hm k \\<noteq> None;\n        hm = (x1, x2);\n        hm_valid (x1, x2) (hm_index hm k) \\<and> hmr_invar (x1, x2);\n        hm_index hm k - 1 < length x1\\<rbrakk>\n       \\<Longrightarrow> heapmap_\\<alpha>\n                          (x1, x2(x1 ! (hm_index hm k - 1) \\<mapsto> v)) =\n                         heapmap_\\<alpha> hm(k \\<mapsto> v)", "apply (force simp: heapmap_rel_defs hmr_rel_defs hm_index_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Butlast\\<close>"], ["", "text \\<open>Remove last element\\<close>"], ["", "definition hm_butlast_op :: \"('k,'v) ahm \\<Rightarrow> ('k,'v) ahm nres\" where\n      \"hm_butlast_op \\<equiv> \\<lambda>(pq,m). do {\n        ASSERT (hmr_invar (pq,m));\n        k \\<leftarrow> mop_list_get pq (length pq - 1);\n        pq \\<leftarrow> mop_list_butlast pq;\n        let m = m(k:=None);\n        RETURN (pq,m)\n      }\""], ["", "lemma hm_butlast_op_refine: \"(hm_butlast_op, h.butlast_op) \\<in> hmr_rel \\<rightarrow> \\<langle>hmr_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hm_butlast_op, h.butlast_op)\n    \\<in> hmr_rel \\<rightarrow> \\<langle>hmr_rel\\<rangle>nres_rel", "supply [simp del] = map_upd_eq_restrict"], ["proof (prove)\ngoal (1 subgoal):\n 1. (hm_butlast_op, h.butlast_op)\n    \\<in> hmr_rel \\<rightarrow> \\<langle>hmr_rel\\<rangle>nres_rel", "apply (intro fun_relI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> hmr_rel \\<Longrightarrow>\n       hm_butlast_op a \\<le> \\<Down> hmr_rel (h.butlast_op a')", "unfolding hm_butlast_op_def h.butlast_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> hmr_rel \\<Longrightarrow>\n       (case a of\n        (pq, m) \\<Rightarrow>\n          ASSERT (hmr_invar (pq, m)) \\<bind>\n          (\\<lambda>_.\n              mop_list_get pq (length pq - 1) \\<bind>\n              (\\<lambda>k.\n                  mop_list_butlast pq \\<bind>\n                  (\\<lambda>pq. let m = m(k := None) in RETURN (pq, m)))))\n       \\<le> \\<Down> hmr_rel (mop_list_butlast a')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> hmr_rel \\<Longrightarrow>\n       (case a of\n        (pq, m) \\<Rightarrow>\n          ASSERT (hmr_invar (pq, m)) \\<bind>\n          (\\<lambda>_.\n              ASSERT (length pq - Suc 0 < length pq) \\<bind>\n              (\\<lambda>x.\n                  ASSERT (pq \\<noteq> []) \\<bind>\n                  (\\<lambda>x.\n                      RETURN\n                       (butlast pq, m(pq ! (length pq - Suc 0) := None))))))\n       \\<le> \\<Down> hmr_rel\n              (ASSERT (a' \\<noteq> []) \\<bind>\n               (\\<lambda>_. RETURN (butlast a')))", "apply refine_vcg"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a a' aa b.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; a' \\<noteq> []; a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> hmr_invar (aa, b)\n 2. \\<And>a a' aa b.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; a' \\<noteq> []; a = (aa, b);\n        hmr_invar (aa, b)\\<rbrakk>\n       \\<Longrightarrow> length aa - Suc 0 < length aa\n 3. \\<And>a a' aa b.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; a' \\<noteq> []; a = (aa, b);\n        hmr_invar (aa, b); length aa - Suc 0 < length aa\\<rbrakk>\n       \\<Longrightarrow> aa \\<noteq> []\n 4. \\<And>a a' aa b.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; a' \\<noteq> []; a = (aa, b);\n        hmr_invar (aa, b); length aa - Suc 0 < length aa;\n        aa \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> ((butlast aa, b(aa ! (length aa - Suc 0) := None)),\n                          butlast a')\n                         \\<in> hmr_rel", "apply (clarsimp_all simp: hmr_rel_defs map_butlast distinct_butlast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ba.\n       \\<lbrakk>aa \\<noteq> []; distinct aa; dom ba = set aa\\<rbrakk>\n       \\<Longrightarrow> butlast (map (the \\<circ> ba) aa) =\n                         butlast\n                          (map ((the \\<circ>\\<circ>\\<circ> fun_upd ba)\n                                 (aa ! (length aa - Suc 0)) None)\n                            aa) \\<and>\n                         set aa - {aa ! (length aa - Suc 0)} =\n                         set (butlast aa)", "apply (auto simp: neq_Nil_rev_conv) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas [refine] = hm_butlast_op_refine[param_fo, THEN nres_relD]"], ["", "lemma hm_butlast_op_\\<alpha>_correct: \"hm_butlast_op hm \\<le>\\<^sub>n SPEC (\n      \\<lambda>hm'. heapmap_\\<alpha> hm' = (heapmap_\\<alpha> hm)( hm_key_of hm (hm_length hm) := None ))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_butlast_op hm \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>hm'.\n         heapmap_\\<alpha> hm' = (heapmap_\\<alpha> hm)\n         (hm_key_of hm (hm_length hm) := None))", "unfolding hm_butlast_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case hm of\n     (pq, m) \\<Rightarrow>\n       ASSERT (hmr_invar (pq, m)) \\<bind>\n       (\\<lambda>_.\n           mop_list_get pq (length pq - 1) \\<bind>\n           (\\<lambda>k.\n               mop_list_butlast pq \\<bind>\n               (\\<lambda>pq.\n                   let m = m(k := None) in RETURN (pq, m))))) \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>hm'.\n         heapmap_\\<alpha> hm' = (heapmap_\\<alpha> hm)\n         (hm_key_of hm (hm_length hm) := None))", "apply refine_vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>hm = (x1, x2); hmr_invar (x1, x2);\n        length x1 - 1 < length x1; x1 \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> heapmap_\\<alpha>\n                          (butlast x1, x2(x1 ! (length x1 - 1) := None)) =\n                         (heapmap_\\<alpha> hm)\n                         (hm_key_of hm (hm_length hm) := None)", "apply (auto simp: heapmap_\\<alpha>_def hm_key_of_def hm_length_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Append\\<close>"], ["", "text \\<open>Append new element at end of heap\\<close>"], ["", "definition hm_append_op :: \"('k,'v) ahm \\<Rightarrow> 'k \\<Rightarrow> 'v \\<Rightarrow> ('k,'v) ahm nres\"\n      where \"hm_append_op \\<equiv> \\<lambda>(pq,m) k v. do {\n        ASSERT (k \\<notin> dom m);\n        ASSERT (hmr_invar (pq,m));\n        pq \\<leftarrow> mop_list_append pq k;\n        let m = m (k \\<mapsto> v);\n        RETURN (pq,m)\n      }\""], ["", "lemma hm_append_op_invar: \"hm_append_op hm k v \\<le>\\<^sub>n SPEC hmr_invar\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_append_op hm k v \\<le>\\<^sub>n SPEC hmr_invar", "unfolding hm_append_op_def h.append_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case hm of\n     (pq, m) \\<Rightarrow>\n       \\<lambda>k v.\n          ASSERT (k \\<notin> dom m) \\<bind>\n          (\\<lambda>_.\n              ASSERT (hmr_invar (pq, m)) \\<bind>\n              (\\<lambda>_.\n                  mop_list_append pq k \\<bind>\n                  (\\<lambda>pq.\n                      let m = m(k \\<mapsto> v) in RETURN (pq, m)))))\n     k v \\<le>\\<^sub>n\n    SPEC hmr_invar", "apply refine_vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>hm = (x1, x2); k \\<notin> dom x2;\n        hmr_invar (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> hmr_invar (x1 @ [k], x2(k \\<mapsto> v))", "unfolding heapmap_\\<alpha>_def hmr_rel_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>hm = (x1, x2); k \\<notin> dom x2;\n        case (x1, x2) of\n        (pq, m) \\<Rightarrow> distinct pq \\<and> dom m = set pq\\<rbrakk>\n       \\<Longrightarrow> case (x1 @ [k], x2(k \\<mapsto> v)) of\n                         (pq, m) \\<Rightarrow>\n                           distinct pq \\<and> dom m = set pq", "apply (auto simp: )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hm_append_op_refine: \"\\<lbrakk> heapmap_\\<alpha> hm k = None; (hm,h)\\<in>hmr_rel \\<rbrakk> \n      \\<Longrightarrow> (hm_append_op hm k v, h.append_op h v) \\<in> \\<langle>hmr_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heapmap_\\<alpha> hm k = None; (hm, h) \\<in> hmr_rel\\<rbrakk>\n    \\<Longrightarrow> (hm_append_op hm k v, h.append_op h v)\n                      \\<in> \\<langle>hmr_rel\\<rangle>nres_rel", "apply (intro fun_relI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heapmap_\\<alpha> hm k = None; (hm, h) \\<in> hmr_rel\\<rbrakk>\n    \\<Longrightarrow> hm_append_op hm k v\n                      \\<le> \\<Down> hmr_rel (h.append_op h v)", "unfolding hm_append_op_def h.append_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heapmap_\\<alpha> hm k = None; (hm, h) \\<in> hmr_rel\\<rbrakk>\n    \\<Longrightarrow> (case hm of\n                       (pq, m) \\<Rightarrow>\n                         \\<lambda>k v.\n                            ASSERT (k \\<notin> dom m) \\<bind>\n                            (\\<lambda>_.\n                                ASSERT (hmr_invar (pq, m)) \\<bind>\n                                (\\<lambda>_.\n                                    mop_list_append pq k \\<bind>\n                                    (\\<lambda>pq.\n  let m = m(k \\<mapsto> v) in RETURN (pq, m)))))\n                       k v\n                      \\<le> \\<Down> hmr_rel (mop_list_append h v)", "apply refine_vcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>heapmap_\\<alpha> hm k = None; (hm, h) \\<in> hmr_rel;\n        hm = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> k \\<notin> dom x2\n 2. \\<And>x1 x2.\n       \\<lbrakk>heapmap_\\<alpha> hm k = None; (hm, h) \\<in> hmr_rel;\n        hm = (x1, x2); k \\<notin> dom x2\\<rbrakk>\n       \\<Longrightarrow> hmr_invar (x1, x2)\n 3. \\<And>x1 x2.\n       \\<lbrakk>heapmap_\\<alpha> hm k = None; (hm, h) \\<in> hmr_rel;\n        hm = (x1, x2); k \\<notin> dom x2; hmr_invar (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> mop_list_append x1 k \\<bind>\n                         (\\<lambda>pq.\n                             let m = x2(k \\<mapsto> v) in RETURN (pq, m))\n                         \\<le> \\<Down> hmr_rel (mop_list_append h v)", "unfolding heapmap_\\<alpha>_def hmr_rel_defs"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>(case hm of (pq, m) \\<Rightarrow> m) k = None;\n        (hm, h)\n        \\<in> {(c, a).\n               a =\n               (case c of\n                (pq, m) \\<Rightarrow> map (the \\<circ> m) pq) \\<and>\n               (case c of\n                (pq, m) \\<Rightarrow> distinct pq \\<and> dom m = set pq)};\n        hm = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> k \\<notin> dom x2\n 2. \\<And>x1 x2.\n       \\<lbrakk>(case hm of (pq, m) \\<Rightarrow> m) k = None;\n        (hm, h)\n        \\<in> {(c, a).\n               a =\n               (case c of\n                (pq, m) \\<Rightarrow> map (the \\<circ> m) pq) \\<and>\n               (case c of\n                (pq, m) \\<Rightarrow> distinct pq \\<and> dom m = set pq)};\n        hm = (x1, x2); k \\<notin> dom x2\\<rbrakk>\n       \\<Longrightarrow> case (x1, x2) of\n                         (pq, m) \\<Rightarrow>\n                           distinct pq \\<and> dom m = set pq\n 3. \\<And>x1 x2.\n       \\<lbrakk>(case hm of (pq, m) \\<Rightarrow> m) k = None;\n        (hm, h)\n        \\<in> {(c, a).\n               a =\n               (case c of\n                (pq, m) \\<Rightarrow> map (the \\<circ> m) pq) \\<and>\n               (case c of\n                (pq, m) \\<Rightarrow> distinct pq \\<and> dom m = set pq)};\n        hm = (x1, x2); k \\<notin> dom x2;\n        case (x1, x2) of\n        (pq, m) \\<Rightarrow> distinct pq \\<and> dom m = set pq\\<rbrakk>\n       \\<Longrightarrow> mop_list_append x1 k \\<bind>\n                         (\\<lambda>pq.\n                             let m = x2(k \\<mapsto> v) in RETURN (pq, m))\n                         \\<le> \\<Down>\n                                {(c, a).\n                                 a =\n                                 (case c of\n                                  (pq, m) \\<Rightarrow>\n                                    map (the \\<circ> m) pq) \\<and>\n                                 (case c of\n                                  (pq, m) \\<Rightarrow>\n                                    distinct pq \\<and> dom m = set pq)}\n                                (mop_list_append h v)", "apply (auto simp: )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas hm_append_op_refine'[refine] = hm_append_op_refine[param_fo, THEN nres_relD]"], ["", "lemma hm_append_op_\\<alpha>_correct: \n      \"hm_append_op hm k v \\<le>\\<^sub>n SPEC (\\<lambda>hm'. heapmap_\\<alpha> hm' = (heapmap_\\<alpha> hm) (k \\<mapsto> v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_append_op hm k v \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>hm'.\n         heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm(k \\<mapsto> v))", "unfolding hm_append_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case hm of\n     (pq, m) \\<Rightarrow>\n       \\<lambda>k v.\n          ASSERT (k \\<notin> dom m) \\<bind>\n          (\\<lambda>_.\n              ASSERT (hmr_invar (pq, m)) \\<bind>\n              (\\<lambda>_.\n                  mop_list_append pq k \\<bind>\n                  (\\<lambda>pq.\n                      let m = m(k \\<mapsto> v) in RETURN (pq, m)))))\n     k v \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>hm'.\n         heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm(k \\<mapsto> v))", "apply refine_vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>hm = (x1, x2); k \\<notin> dom x2;\n        hmr_invar (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> heapmap_\\<alpha> (x1 @ [k], x2(k \\<mapsto> v)) =\n                         heapmap_\\<alpha> hm(k \\<mapsto> v)", "by (auto simp: heapmap_\\<alpha>_def)"], ["", "subsection \\<open>Auxiliary Operations\\<close>"], ["", "text \\<open>Auxiliary operations on heapmaps, which are derived \n      from the basic operations, but do not correspond to \n      operations of the priority map interface\\<close>"], ["", "text \\<open>We start with some setup\\<close>"], ["", "lemma heapmap_hmr_relI: \"(hm,h)\\<in>heapmap_rel \\<Longrightarrow> (hm,hmr_\\<alpha> hm) \\<in> hmr_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hm, h) \\<in> heapmap_rel \\<Longrightarrow>\n    (hm, hmr_\\<alpha> hm) \\<in> hmr_rel", "by (auto simp: heapmap_rel_defs hmr_rel_defs)"], ["", "lemma heapmap_hmr_relI': \"heapmap_invar hm \\<Longrightarrow> (hm,hmr_\\<alpha> hm) \\<in> hmr_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heapmap_invar hm \\<Longrightarrow> (hm, hmr_\\<alpha> hm) \\<in> hmr_rel", "by (auto simp: heapmap_rel_defs hmr_rel_defs)"], ["", "text \\<open>The basic principle how we prove correctness of our operations:\n      Invariant preservation is shown by relating the operations to \n      operations on heaps. Then, only correctness on the abstraction \n      remains to be shown, assuming the operation does not fail.\n      \\<close>"], ["", "lemma heapmap_nres_relI':\n      assumes \"hm \\<le> \\<Down>hmr_rel h'\"\n      assumes \"h' \\<le> SPEC (h.heap_invar)\"\n      assumes \"hm \\<le>\\<^sub>n SPEC (\\<lambda>hm'. RETURN (heapmap_\\<alpha> hm') \\<le> h)\"\n      shows \"hm \\<le> \\<Down>heapmap_rel h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hm \\<le> \\<Down> heapmap_rel h", "using assms"], ["proof (prove)\nusing this:\n  hm \\<le> \\<Down> hmr_rel h'\n  h' \\<le> SPEC h.heap_invar\n  hm \\<le>\\<^sub>n\n  SPEC (\\<lambda>hm'. RETURN (heapmap_\\<alpha> hm') \\<le> h)\n\ngoal (1 subgoal):\n 1. hm \\<le> \\<Down> heapmap_rel h", "unfolding heapmap_rel_defs hmr_rel_def"], ["proof (prove)\nusing this:\n  hm \\<le> \\<Down> {(c, a). a = hmr_\\<alpha> c \\<and> hmr_invar c} h'\n  h' \\<le> SPEC h.heap_invar\n  hm \\<le>\\<^sub>n\n  SPEC (\\<lambda>hm'. RETURN (case hm' of (pq, m) \\<Rightarrow> m) \\<le> h)\n\ngoal (1 subgoal):\n 1. hm \\<le> \\<Down>\n              {(c, a).\n               a = (case c of (pq, m) \\<Rightarrow> m) \\<and>\n               hmr_invar c \\<and> h.heap_invar (hmr_\\<alpha> c)}\n              h", "by (auto simp: pw_le_iff pw_leof_iff refine_pw_simps)"], ["", "lemma heapmap_nres_relI'':\n      assumes \"hm \\<le> \\<Down>hmr_rel h'\"\n      assumes \"h' \\<le> SPEC \\<Phi>\"\n      assumes \"\\<And>h'. \\<Phi> h' \\<Longrightarrow> h.heap_invar h'\"\n      assumes \"hm \\<le>\\<^sub>n SPEC (\\<lambda>hm'. RETURN (heapmap_\\<alpha> hm') \\<le> h)\"\n      shows \"hm \\<le> \\<Down>heapmap_rel h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hm \\<le> \\<Down> heapmap_rel h", "apply (rule heapmap_nres_relI')"], ["proof (prove)\ngoal (3 subgoals):\n 1. hm \\<le> \\<Down> hmr_rel ?h'\n 2. ?h' \\<le> SPEC h.heap_invar\n 3. hm \\<le>\\<^sub>n\n    SPEC (\\<lambda>hm'. RETURN (heapmap_\\<alpha> hm') \\<le> h)", "apply fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. h' \\<le> SPEC h.heap_invar\n 2. hm \\<le>\\<^sub>n\n    SPEC (\\<lambda>hm'. RETURN (heapmap_\\<alpha> hm') \\<le> h)", "apply (rule order_trans, fact)"], ["proof (prove)\ngoal (2 subgoals):\n 1. SPEC \\<Phi> \\<le> SPEC h.heap_invar\n 2. hm \\<le>\\<^sub>n\n    SPEC (\\<lambda>hm'. RETURN (heapmap_\\<alpha> hm') \\<le> h)", "apply (clarsimp; fact)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hm \\<le>\\<^sub>n\n    SPEC (\\<lambda>hm'. RETURN (heapmap_\\<alpha> hm') \\<le> h)", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Val-of\\<close>"], ["", "text \\<open>Indexing into the heap\\<close>"], ["", "definition hm_val_of_op :: \"('k,'v) ahm \\<Rightarrow> nat \\<Rightarrow> 'v nres\" where\n      \"hm_val_of_op \\<equiv> \\<lambda>hm i. do {\n        k \\<leftarrow> hm_key_of_op hm i;\n        v \\<leftarrow> hm_the_lookup_op hm k;\n        RETURN v\n      }\""], ["", "lemma hm_val_of_op_refine: \"(hm_val_of_op,h.val_of_op) \\<in> (hmr_rel \\<rightarrow> nat_rel \\<rightarrow> \\<langle>Id\\<rangle>nres_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hm_val_of_op, h.val_of_op)\n    \\<in> hmr_rel \\<rightarrow>\n          nat_rel \\<rightarrow> \\<langle>Id\\<rangle>nres_rel", "apply (intro fun_relI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> hm_val_of_op a aa\n                         \\<le> \\<Down> Id (h.val_of_op a' a'a)", "unfolding hm_val_of_op_def h.val_of_op_def \n        hm_key_of_op_def hm_key_of_def hm_valid_def hm_length_def\n        hm_the_lookup_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> (case a of\n                          (pq, m) \\<Rightarrow>\n                            \\<lambda>i.\n                               ASSERT (0 < i) \\<bind>\n                               (\\<lambda>_. mop_list_get pq (i - 1)))\n                          aa \\<bind>\n                         (\\<lambda>k.\n                             ASSERT\n                              (heapmap_\\<alpha> a k \\<noteq> None \\<and>\n                               hmr_invar a) \\<bind>\n                             (\\<lambda>_.\n                                 RETURN\n                                  (the (heapmap_\\<alpha> a k))) \\<bind>\n                             RETURN)\n                         \\<le> \\<Down> Id\n                                (ASSERT (0 < a'a) \\<bind>\n                                 (\\<lambda>_. mop_list_get a' (a'a - 1)))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b a' a'a.\n       ((a, b), a') \\<in> hmr_rel \\<Longrightarrow>\n       ASSERT (0 < a'a) \\<bind>\n       (\\<lambda>x.\n           ASSERT (a'a - Suc 0 < length a) \\<bind>\n           (\\<lambda>x.\n               ASSERT\n                ((\\<exists>y.\n                     heapmap_\\<alpha> (a, b) (a ! (a'a - Suc 0)) =\n                     Some y) \\<and>\n                 hmr_invar (a, b)) \\<bind>\n               (\\<lambda>_.\n                   RETURN\n                    (the (heapmap_\\<alpha> (a, b) (a ! (a'a - Suc 0)))))))\n       \\<le> ASSERT (0 < a'a) \\<bind>\n             (\\<lambda>_.\n                 ASSERT (a'a - Suc 0 < length a') \\<bind>\n                 (\\<lambda>_. RETURN (a' ! (a'a - Suc 0))))", "apply (rule refine_IdD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b a' a'a.\n       ((a, b), a') \\<in> hmr_rel \\<Longrightarrow>\n       ASSERT (0 < a'a) \\<bind>\n       (\\<lambda>x.\n           ASSERT (a'a - Suc 0 < length a) \\<bind>\n           (\\<lambda>x.\n               ASSERT\n                ((\\<exists>y.\n                     heapmap_\\<alpha> (a, b) (a ! (a'a - Suc 0)) =\n                     Some y) \\<and>\n                 hmr_invar (a, b)) \\<bind>\n               (\\<lambda>_.\n                   RETURN\n                    (the (heapmap_\\<alpha> (a, b) (a ! (a'a - Suc 0)))))))\n       \\<le> \\<Down> Id\n              (ASSERT (0 < a'a) \\<bind>\n               (\\<lambda>_.\n                   ASSERT (a'a - Suc 0 < length a') \\<bind>\n                   (\\<lambda>_. RETURN (a' ! (a'a - Suc 0)))))", "apply refine_vcg"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b a' a'a.\n       \\<lbrakk>((a, b), a') \\<in> hmr_rel; 0 < a'a;\n        a'a - Suc 0 < length a'; 0 < a'a\\<rbrakk>\n       \\<Longrightarrow> a'a - Suc 0 < length a\n 2. \\<And>a b a' a'a.\n       \\<lbrakk>((a, b), a') \\<in> hmr_rel; 0 < a'a;\n        a'a - Suc 0 < length a'; 0 < a'a; a'a - Suc 0 < length a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            heapmap_\\<alpha> (a, b) (a ! (a'a - Suc 0)) =\n                            Some y\n 3. \\<And>a b a' a'a.\n       \\<lbrakk>((a, b), a') \\<in> hmr_rel; 0 < a'a;\n        a'a - Suc 0 < length a'; 0 < a'a; a'a - Suc 0 < length a\\<rbrakk>\n       \\<Longrightarrow> hmr_invar (a, b)\n 4. \\<And>a b a' a'a.\n       \\<lbrakk>((a, b), a') \\<in> hmr_rel; 0 < a'a;\n        a'a - Suc 0 < length a'; 0 < a'a; a'a - Suc 0 < length a;\n        (\\<exists>y.\n            heapmap_\\<alpha> (a, b) (a ! (a'a - Suc 0)) = Some y) \\<and>\n        hmr_invar (a, b)\\<rbrakk>\n       \\<Longrightarrow> (the (heapmap_\\<alpha> (a, b) (a ! (a'a - Suc 0))),\n                          a' ! (a'a - Suc 0))\n                         \\<in> Id", "apply (auto simp: hmr_rel_defs heapmap_\\<alpha>_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas [refine] = hm_val_of_op_refine[param_fo, THEN nres_relD]"], ["", "subsubsection \\<open>Prio-of\\<close>"], ["", "text \\<open>Priority of key\\<close>"], ["", "definition \"hm_prio_of_op h i \\<equiv> do {v \\<leftarrow> hm_val_of_op h i; RETURN (prio v)}\""], ["", "lemma hm_prio_of_op_refine: \"(hm_prio_of_op, h.prio_of_op) \\<in> hmr_rel \\<rightarrow> nat_rel \\<rightarrow> \\<langle>Id\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hm_prio_of_op, h.prio_of_op)\n    \\<in> hmr_rel \\<rightarrow>\n          nat_rel \\<rightarrow> \\<langle>Id\\<rangle>nres_rel", "apply (intro fun_relI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> hm_prio_of_op a aa\n                         \\<le> \\<Down> Id (h.prio_of_op a' a'a)", "unfolding hm_prio_of_op_def h.prio_of_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> hm_val_of_op a aa \\<bind>\n                         (\\<lambda>v. RETURN (prio v))\n                         \\<le> \\<Down> Id\n                                (h.val_of_op a' a'a \\<bind>\n                                 (\\<lambda>v. RETURN (prio v)))", "apply refine_rcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a v va.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n        (v, va) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> (prio v, prio va) \\<in> Id", "by auto"], ["", "lemmas hm_prio_of_op_refine'[refine] = hm_prio_of_op_refine[param_fo, THEN nres_relD]"], ["", "subsubsection \\<open>Swim\\<close>"], ["", "definition hm_swim_op :: \"('k,'v) ahm \\<Rightarrow> nat \\<Rightarrow> ('k,'v) ahm nres\" where\n      \"hm_swim_op h i \\<equiv> do {\n        RECT (\\<lambda>swim (h,i). do {\n          ASSERT (hm_valid h i \\<and> h.swim_invar (hmr_\\<alpha> h) i);\n          if hm_valid h (h.parent i) then do {\n            ppi \\<leftarrow> hm_prio_of_op h (h.parent i);\n            pi \\<leftarrow> hm_prio_of_op h i;\n            if (\\<not>ppi \\<le> pi) then do {\n              h \\<leftarrow> hm_exch_op h i (h.parent i);\n              swim (h, h.parent i)\n            } else\n              RETURN h\n          } else \n            RETURN h\n        }) (h,i)\n      }\""], ["", "lemma hm_swim_op_refine: \"(hm_swim_op, h.swim_op) \\<in> hmr_rel \\<rightarrow> nat_rel \\<rightarrow> \\<langle>hmr_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hm_swim_op, h.swim_op)\n    \\<in> hmr_rel \\<rightarrow>\n          nat_rel \\<rightarrow> \\<langle>hmr_rel\\<rangle>nres_rel", "apply (intro fun_relI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> hm_swim_op a aa\n                         \\<le> \\<Down> hmr_rel (h.swim_op a' a'a)", "unfolding hm_swim_op_def h.swim_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> REC\\<^sub>T\n                          (\\<lambda>swim (h, i).\n                              ASSERT\n                               (hm_valid h i \\<and>\n                                h.swim_invar (hmr_\\<alpha> h) i) \\<bind>\n                              (\\<lambda>_.\n                                  if hm_valid h (h.parent i)\n                                  then hm_prio_of_op h (h.parent i) \\<bind>\n (\\<lambda>ppi.\n     hm_prio_of_op h i \\<bind>\n     (\\<lambda>pi.\n         if \\<not> ppi \\<le> pi\n         then hm_exch_op h i (h.parent i) \\<bind>\n              (\\<lambda>h. swim (h, h.parent i))\n         else RETURN h))\n                                  else RETURN h))\n                          (a, aa)\n                         \\<le> \\<Down> hmr_rel\n                                (REC\\<^sub>T\n                                  (\\<lambda>swim (h, i).\nASSERT (h.valid h i \\<and> h.swim_invar h i) \\<bind>\n(\\<lambda>_.\n    if h.has_parent h i\n    then h.prio_of_op h (h.parent i) \\<bind>\n         (\\<lambda>ppi.\n             h.prio_of_op h i \\<bind>\n             (\\<lambda>pi.\n                 if \\<not> ppi \\<le> pi\n                 then h.exch_op h i (h.parent i) \\<bind>\n                      (\\<lambda>h. swim (h, h.parent i))\n                 else RETURN h))\n    else RETURN h))\n                                  (a', a'a))", "apply refine_rcg"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> ((a, aa), a', a'a) \\<in> ?R3 a a' aa a'a\n 2. \\<And>a a' aa a'a swim swima x x' x1 x2 x1a x2a.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n        \\<And>x x'.\n           (x, x') \\<in> ?R3 a a' aa a'a \\<Longrightarrow>\n           swim x \\<le> \\<Down> hmr_rel (swima x');\n        (x, x') \\<in> ?R3 a a' aa a'a; x' = (x1, x2); x = (x1a, x2a);\n        h.valid x1 x2 \\<and> h.swim_invar x1 x2\\<rbrakk>\n       \\<Longrightarrow> hm_valid x1a x2a\n 3. \\<And>a a' aa a'a swim swima x x' x1 x2 x1a x2a.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n        \\<And>x x'.\n           (x, x') \\<in> ?R3 a a' aa a'a \\<Longrightarrow>\n           swim x \\<le> \\<Down> hmr_rel (swima x');\n        (x, x') \\<in> ?R3 a a' aa a'a; x' = (x1, x2); x = (x1a, x2a);\n        h.valid x1 x2 \\<and> h.swim_invar x1 x2\\<rbrakk>\n       \\<Longrightarrow> h.swim_invar (hmr_\\<alpha> x1a) x2a\n 4. \\<And>a a' aa a'a swim swima x x' x1 x2 x1a x2a.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n        \\<And>x x'.\n           (x, x') \\<in> ?R3 a a' aa a'a \\<Longrightarrow>\n           swim x \\<le> \\<Down> hmr_rel (swima x');\n        (x, x') \\<in> ?R3 a a' aa a'a; x' = (x1, x2); x = (x1a, x2a);\n        h.valid x1 x2 \\<and> h.swim_invar x1 x2;\n        hm_valid x1a x2a \\<and> h.swim_invar (hmr_\\<alpha> x1a) x2a\\<rbrakk>\n       \\<Longrightarrow> hm_valid x1a (h.parent x2a) = h.has_parent x1 x2\n 5. \\<And>a a' aa a'a swim swima x x' x1 x2 x1a x2a.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n        \\<And>x x'.\n           (x, x') \\<in> ?R3 a a' aa a'a \\<Longrightarrow>\n           swim x \\<le> \\<Down> hmr_rel (swima x');\n        (x, x') \\<in> ?R3 a a' aa a'a; x' = (x1, x2); x = (x1a, x2a);\n        h.valid x1 x2 \\<and> h.swim_invar x1 x2;\n        hm_valid x1a x2a \\<and> h.swim_invar (hmr_\\<alpha> x1a) x2a;\n        hm_valid x1a (h.parent x2a); h.has_parent x1 x2\\<rbrakk>\n       \\<Longrightarrow> (x1a, x1) \\<in> hmr_rel\n 6. \\<And>a a' aa a'a swim swima x x' x1 x2 x1a x2a.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n        \\<And>x x'.\n           (x, x') \\<in> ?R3 a a' aa a'a \\<Longrightarrow>\n           swim x \\<le> \\<Down> hmr_rel (swima x');\n        (x, x') \\<in> ?R3 a a' aa a'a; x' = (x1, x2); x = (x1a, x2a);\n        h.valid x1 x2 \\<and> h.swim_invar x1 x2;\n        hm_valid x1a x2a \\<and> h.swim_invar (hmr_\\<alpha> x1a) x2a;\n        hm_valid x1a (h.parent x2a); h.has_parent x1 x2\\<rbrakk>\n       \\<Longrightarrow> (h.parent x2a, h.parent x2) \\<in> nat_rel\n 7. \\<And>a a' aa a'a swim swima x x' x1 x2 x1a x2a ppi ppia.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n        \\<And>x x'.\n           (x, x') \\<in> ?R3 a a' aa a'a \\<Longrightarrow>\n           swim x \\<le> \\<Down> hmr_rel (swima x');\n        (x, x') \\<in> ?R3 a a' aa a'a; x' = (x1, x2); x = (x1a, x2a);\n        h.valid x1 x2 \\<and> h.swim_invar x1 x2;\n        hm_valid x1a x2a \\<and> h.swim_invar (hmr_\\<alpha> x1a) x2a;\n        hm_valid x1a (h.parent x2a); h.has_parent x1 x2;\n        (ppi, ppia) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> (x1a, x1) \\<in> hmr_rel\n 8. \\<And>a a' aa a'a swim swima x x' x1 x2 x1a x2a ppi ppia.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n        \\<And>x x'.\n           (x, x') \\<in> ?R3 a a' aa a'a \\<Longrightarrow>\n           swim x \\<le> \\<Down> hmr_rel (swima x');\n        (x, x') \\<in> ?R3 a a' aa a'a; x' = (x1, x2); x = (x1a, x2a);\n        h.valid x1 x2 \\<and> h.swim_invar x1 x2;\n        hm_valid x1a x2a \\<and> h.swim_invar (hmr_\\<alpha> x1a) x2a;\n        hm_valid x1a (h.parent x2a); h.has_parent x1 x2;\n        (ppi, ppia) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> nat_rel\n 9. \\<And>a a' aa a'a swim swima x x' x1 x2 x1a x2a ppi ppia pi pia.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n        \\<And>x x'.\n           (x, x') \\<in> ?R3 a a' aa a'a \\<Longrightarrow>\n           swim x \\<le> \\<Down> hmr_rel (swima x');\n        (x, x') \\<in> ?R3 a a' aa a'a; x' = (x1, x2); x = (x1a, x2a);\n        h.valid x1 x2 \\<and> h.swim_invar x1 x2;\n        hm_valid x1a x2a \\<and> h.swim_invar (hmr_\\<alpha> x1a) x2a;\n        hm_valid x1a (h.parent x2a); h.has_parent x1 x2;\n        (ppi, ppia) \\<in> Id; (pi, pia) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> (\\<not> ppi \\<le> pi) = (\\<not> ppia \\<le> pia)\n 10. \\<And>a a' aa a'a swim swima x x' x1 x2 x1a x2a ppi ppia pi pia.\n        \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n         \\<And>x x'.\n            (x, x') \\<in> ?R3 a a' aa a'a \\<Longrightarrow>\n            swim x \\<le> \\<Down> hmr_rel (swima x');\n         (x, x') \\<in> ?R3 a a' aa a'a; x' = (x1, x2); x = (x1a, x2a);\n         h.valid x1 x2 \\<and> h.swim_invar x1 x2;\n         hm_valid x1a x2a \\<and> h.swim_invar (hmr_\\<alpha> x1a) x2a;\n         hm_valid x1a (h.parent x2a); h.has_parent x1 x2;\n         (ppi, ppia) \\<in> Id; (pi, pia) \\<in> Id; \\<not> ppi \\<le> pi;\n         \\<not> ppia \\<le> pia\\<rbrakk>\n        \\<Longrightarrow> (x1a, x1) \\<in> hmr_rel\nA total of 15 subgoals...", "apply refine_dref_type"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> ((a, aa), a', a'a)\n                         \\<in> hmr_rel \\<times>\\<^sub>r nat_rel\n 2. \\<And>a a' aa a'a swim swima x x' x1 x2 x1a x2a.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n        \\<And>x x'.\n           (x, x') \\<in> hmr_rel \\<times>\\<^sub>r nat_rel \\<Longrightarrow>\n           swim x \\<le> \\<Down> hmr_rel (swima x');\n        (x, x') \\<in> hmr_rel \\<times>\\<^sub>r nat_rel; x' = (x1, x2);\n        x = (x1a, x2a); h.valid x1 x2 \\<and> h.swim_invar x1 x2\\<rbrakk>\n       \\<Longrightarrow> hm_valid x1a x2a\n 3. \\<And>a a' aa a'a swim swima x x' x1 x2 x1a x2a.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n        \\<And>x x'.\n           (x, x') \\<in> hmr_rel \\<times>\\<^sub>r nat_rel \\<Longrightarrow>\n           swim x \\<le> \\<Down> hmr_rel (swima x');\n        (x, x') \\<in> hmr_rel \\<times>\\<^sub>r nat_rel; x' = (x1, x2);\n        x = (x1a, x2a); h.valid x1 x2 \\<and> h.swim_invar x1 x2\\<rbrakk>\n       \\<Longrightarrow> h.swim_invar (hmr_\\<alpha> x1a) x2a\n 4. \\<And>a a' aa a'a swim swima x x' x1 x2 x1a x2a.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n        \\<And>x x'.\n           (x, x') \\<in> hmr_rel \\<times>\\<^sub>r nat_rel \\<Longrightarrow>\n           swim x \\<le> \\<Down> hmr_rel (swima x');\n        (x, x') \\<in> hmr_rel \\<times>\\<^sub>r nat_rel; x' = (x1, x2);\n        x = (x1a, x2a); h.valid x1 x2 \\<and> h.swim_invar x1 x2;\n        hm_valid x1a x2a \\<and> h.swim_invar (hmr_\\<alpha> x1a) x2a\\<rbrakk>\n       \\<Longrightarrow> hm_valid x1a (h.parent x2a) = h.has_parent x1 x2\n 5. \\<And>a a' aa a'a swim swima x x' x1 x2 x1a x2a.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n        \\<And>x x'.\n           (x, x') \\<in> hmr_rel \\<times>\\<^sub>r nat_rel \\<Longrightarrow>\n           swim x \\<le> \\<Down> hmr_rel (swima x');\n        (x, x') \\<in> hmr_rel \\<times>\\<^sub>r nat_rel; x' = (x1, x2);\n        x = (x1a, x2a); h.valid x1 x2 \\<and> h.swim_invar x1 x2;\n        hm_valid x1a x2a \\<and> h.swim_invar (hmr_\\<alpha> x1a) x2a;\n        hm_valid x1a (h.parent x2a); h.has_parent x1 x2\\<rbrakk>\n       \\<Longrightarrow> (x1a, x1) \\<in> hmr_rel\n 6. \\<And>a a' aa a'a swim swima x x' x1 x2 x1a x2a.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n        \\<And>x x'.\n           (x, x') \\<in> hmr_rel \\<times>\\<^sub>r nat_rel \\<Longrightarrow>\n           swim x \\<le> \\<Down> hmr_rel (swima x');\n        (x, x') \\<in> hmr_rel \\<times>\\<^sub>r nat_rel; x' = (x1, x2);\n        x = (x1a, x2a); h.valid x1 x2 \\<and> h.swim_invar x1 x2;\n        hm_valid x1a x2a \\<and> h.swim_invar (hmr_\\<alpha> x1a) x2a;\n        hm_valid x1a (h.parent x2a); h.has_parent x1 x2\\<rbrakk>\n       \\<Longrightarrow> (h.parent x2a, h.parent x2) \\<in> nat_rel\n 7. \\<And>a a' aa a'a swim swima x x' x1 x2 x1a x2a ppi ppia.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n        \\<And>x x'.\n           (x, x') \\<in> hmr_rel \\<times>\\<^sub>r nat_rel \\<Longrightarrow>\n           swim x \\<le> \\<Down> hmr_rel (swima x');\n        (x, x') \\<in> hmr_rel \\<times>\\<^sub>r nat_rel; x' = (x1, x2);\n        x = (x1a, x2a); h.valid x1 x2 \\<and> h.swim_invar x1 x2;\n        hm_valid x1a x2a \\<and> h.swim_invar (hmr_\\<alpha> x1a) x2a;\n        hm_valid x1a (h.parent x2a); h.has_parent x1 x2;\n        (ppi, ppia) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> (x1a, x1) \\<in> hmr_rel\n 8. \\<And>a a' aa a'a swim swima x x' x1 x2 x1a x2a ppi ppia.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n        \\<And>x x'.\n           (x, x') \\<in> hmr_rel \\<times>\\<^sub>r nat_rel \\<Longrightarrow>\n           swim x \\<le> \\<Down> hmr_rel (swima x');\n        (x, x') \\<in> hmr_rel \\<times>\\<^sub>r nat_rel; x' = (x1, x2);\n        x = (x1a, x2a); h.valid x1 x2 \\<and> h.swim_invar x1 x2;\n        hm_valid x1a x2a \\<and> h.swim_invar (hmr_\\<alpha> x1a) x2a;\n        hm_valid x1a (h.parent x2a); h.has_parent x1 x2;\n        (ppi, ppia) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> nat_rel\n 9. \\<And>a a' aa a'a swim swima x x' x1 x2 x1a x2a ppi ppia pi pia.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n        \\<And>x x'.\n           (x, x') \\<in> hmr_rel \\<times>\\<^sub>r nat_rel \\<Longrightarrow>\n           swim x \\<le> \\<Down> hmr_rel (swima x');\n        (x, x') \\<in> hmr_rel \\<times>\\<^sub>r nat_rel; x' = (x1, x2);\n        x = (x1a, x2a); h.valid x1 x2 \\<and> h.swim_invar x1 x2;\n        hm_valid x1a x2a \\<and> h.swim_invar (hmr_\\<alpha> x1a) x2a;\n        hm_valid x1a (h.parent x2a); h.has_parent x1 x2;\n        (ppi, ppia) \\<in> Id; (pi, pia) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> (\\<not> ppi \\<le> pi) = (\\<not> ppia \\<le> pia)\n 10. \\<And>a a' aa a'a swim swima x x' x1 x2 x1a x2a ppi ppia pi pia.\n        \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n         \\<And>x x'.\n            (x, x') \\<in> hmr_rel \\<times>\\<^sub>r nat_rel \\<Longrightarrow>\n            swim x \\<le> \\<Down> hmr_rel (swima x');\n         (x, x') \\<in> hmr_rel \\<times>\\<^sub>r nat_rel; x' = (x1, x2);\n         x = (x1a, x2a); h.valid x1 x2 \\<and> h.swim_invar x1 x2;\n         hm_valid x1a x2a \\<and> h.swim_invar (hmr_\\<alpha> x1a) x2a;\n         hm_valid x1a (h.parent x2a); h.has_parent x1 x2;\n         (ppi, ppia) \\<in> Id; (pi, pia) \\<in> Id; \\<not> ppi \\<le> pi;\n         \\<not> ppia \\<le> pia\\<rbrakk>\n        \\<Longrightarrow> (x1a, x1) \\<in> hmr_rel\nA total of 15 subgoals...", "apply (clarsimp_all simp: hm_valid_refine[param_fo, THEN IdD])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b a' swim swima x1 x2 ad bd.\n       \\<lbrakk>((a, b), a') \\<in> hmr_rel;\n        \\<And>a b ba aa.\n           ((a, b), aa) \\<in> hmr_rel \\<Longrightarrow>\n           swim ((a, b), ba) \\<le> \\<Down> hmr_rel (swima (aa, ba));\n        ((ad, bd), x1) \\<in> hmr_rel; h.valid x1 x2;\n        h.swim_invar x1 x2\\<rbrakk>\n       \\<Longrightarrow> h.swim_invar (hmr_\\<alpha> (ad, bd)) x2", "apply (simp add: hmr_rel_def in_br_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas hm_swim_op_refine'[refine] = hm_swim_op_refine[param_fo, THEN nres_relD]"], ["", "lemma hm_swim_op_nofail_imp_valid: \n      \"nofail (hm_swim_op hm i) \\<Longrightarrow> hm_valid hm i \\<and> h.swim_invar (hmr_\\<alpha> hm) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (hm_swim_op hm i) \\<Longrightarrow>\n    hm_valid hm i \\<and> h.swim_invar (hmr_\\<alpha> hm) i", "unfolding hm_swim_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail\n     (REC\\<^sub>T\n       (\\<lambda>swim (h, i).\n           ASSERT\n            (hm_valid h i \\<and> h.swim_invar (hmr_\\<alpha> h) i) \\<bind>\n           (\\<lambda>_.\n               if hm_valid h (h.parent i)\n               then hm_prio_of_op h (h.parent i) \\<bind>\n                    (\\<lambda>ppi.\n                        hm_prio_of_op h i \\<bind>\n                        (\\<lambda>pi.\n                            if \\<not> ppi \\<le> pi\n                            then hm_exch_op h i (h.parent i) \\<bind>\n                                 (\\<lambda>h. swim (h, h.parent i))\n                            else RETURN h))\n               else RETURN h))\n       (hm, i)) \\<Longrightarrow>\n    hm_valid hm i \\<and> h.swim_invar (hmr_\\<alpha> hm) i", "apply (subst (asm) RECT_unfold, refine_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail\n     (case (hm, i) of\n      (h, i) \\<Rightarrow>\n        ASSERT (hm_valid h i \\<and> h.swim_invar (hmr_\\<alpha> h) i) \\<bind>\n        (\\<lambda>_.\n            if hm_valid h (h.parent i)\n            then hm_prio_of_op h (h.parent i) \\<bind>\n                 (\\<lambda>ppi.\n                     hm_prio_of_op h i \\<bind>\n                     (\\<lambda>pi.\n                         if \\<not> ppi \\<le> pi\n                         then hm_exch_op h i (h.parent i) \\<bind>\n                              (\\<lambda>h.\n                                  REC\\<^sub>T\n                                   (\\<lambda>swim (h, i).\n ASSERT (hm_valid h i \\<and> h.swim_invar (hmr_\\<alpha> h) i) \\<bind>\n (\\<lambda>_.\n     if hm_valid h (h.parent i)\n     then hm_prio_of_op h (h.parent i) \\<bind>\n          (\\<lambda>ppi.\n              hm_prio_of_op h i \\<bind>\n              (\\<lambda>pi.\n                  if \\<not> ppi \\<le> pi\n                  then hm_exch_op h i (h.parent i) \\<bind>\n                       (\\<lambda>h. swim (h, h.parent i))\n                  else RETURN h))\n     else RETURN h))\n                                   (h, h.parent i))\n                         else RETURN h))\n            else RETURN h)) \\<Longrightarrow>\n    hm_valid hm i \\<and> h.swim_invar (hmr_\\<alpha> hm) i", "by (auto simp: refine_pw_simps)"], ["", "lemma hm_swim_op_\\<alpha>_correct: \"hm_swim_op hm i \\<le>\\<^sub>n SPEC (\\<lambda>hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_swim_op hm i \\<le>\\<^sub>n\n    SPEC (\\<lambda>hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm)", "apply (rule leof_add_nofailI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (hm_swim_op hm i) \\<Longrightarrow>\n    hm_swim_op hm i \\<le>\\<^sub>n\n    SPEC (\\<lambda>hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm)", "apply (drule hm_swim_op_nofail_imp_valid)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_valid hm i \\<and> h.swim_invar (hmr_\\<alpha> hm) i \\<Longrightarrow>\n    hm_swim_op hm i \\<le>\\<^sub>n\n    SPEC (\\<lambda>hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm)", "unfolding hm_swim_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_valid hm i \\<and> h.swim_invar (hmr_\\<alpha> hm) i \\<Longrightarrow>\n    REC\\<^sub>T\n     (\\<lambda>swim (h, i).\n         ASSERT\n          (hm_valid h i \\<and> h.swim_invar (hmr_\\<alpha> h) i) \\<bind>\n         (\\<lambda>_.\n             if hm_valid h (h.parent i)\n             then hm_prio_of_op h (h.parent i) \\<bind>\n                  (\\<lambda>ppi.\n                      hm_prio_of_op h i \\<bind>\n                      (\\<lambda>pi.\n                          if \\<not> ppi \\<le> pi\n                          then hm_exch_op h i (h.parent i) \\<bind>\n                               (\\<lambda>h. swim (h, h.parent i))\n                          else RETURN h))\n             else RETURN h))\n     (hm, i) \\<le>\\<^sub>n\n    SPEC (\\<lambda>hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm)", "apply (rule RECT_rule_leof[where \n            pre=\"\\<lambda>(hm',i). hm_valid hm' i \\<and> heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm\"\n            and V = \"inv_image less_than snd\"\n            ])"], ["proof (prove)\ngoal (3 subgoals):\n 1. hm_valid hm i \\<and> h.swim_invar (hmr_\\<alpha> hm) i \\<Longrightarrow>\n    wf (inv_image less_than snd)\n 2. hm_valid hm i \\<and> h.swim_invar (hmr_\\<alpha> hm) i \\<Longrightarrow>\n    case (hm, i) of\n    (hm', i) \\<Rightarrow>\n      hm_valid hm' i \\<and> heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm\n 3. \\<And>f x.\n       \\<lbrakk>hm_valid hm i \\<and> h.swim_invar (hmr_\\<alpha> hm) i;\n        \\<And>x'.\n           \\<lbrakk>case x' of\n                    (hm', i) \\<Rightarrow>\n                      hm_valid hm' i \\<and>\n                      heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm;\n            (x', x) \\<in> inv_image less_than snd\\<rbrakk>\n           \\<Longrightarrow> f x' \\<le>\\<^sub>n\n                             SPEC\n                              (\\<lambda>hm'.\n                                  heapmap_\\<alpha> hm' =\n                                  heapmap_\\<alpha> hm);\n        case x of\n        (hm', i) \\<Rightarrow>\n          hm_valid hm' i \\<and> heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm;\n        REC\\<^sub>T\n         (\\<lambda>swim a.\n             case a of\n             (h, i) \\<Rightarrow>\n               ASSERT\n                (hm_valid h i \\<and>\n                 h.swim_invar (hmr_\\<alpha> h) i) \\<bind>\n               (\\<lambda>_.\n                   if hm_valid h (h.parent i)\n                   then hm_prio_of_op h (h.parent i) \\<bind>\n                        (\\<lambda>ppi.\n                            hm_prio_of_op h i \\<bind>\n                            (\\<lambda>pi.\n                                if \\<not> ppi \\<le> pi\n                                then hm_exch_op h i (h.parent i) \\<bind>\n                                     (\\<lambda>h. swim (h, h.parent i))\n                                else RETURN h))\n                   else RETURN h)) =\n        f\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          (h, i) \\<Rightarrow>\n                            ASSERT\n                             (hm_valid h i \\<and>\n                              h.swim_invar (hmr_\\<alpha> h) i) \\<bind>\n                            (\\<lambda>_.\n                                if hm_valid h (h.parent i)\n                                then hm_prio_of_op h (h.parent i) \\<bind>\n                                     (\\<lambda>ppi.\n   hm_prio_of_op h i \\<bind>\n   (\\<lambda>pi.\n       if \\<not> ppi \\<le> pi\n       then hm_exch_op h i (h.parent i) \\<bind>\n            (\\<lambda>h. f (h, h.parent i))\n       else RETURN h))\n                                else RETURN h)) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>hm'.\n                              heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. hm_valid hm i \\<and> h.swim_invar (hmr_\\<alpha> hm) i \\<Longrightarrow>\n    case (hm, i) of\n    (hm', i) \\<Rightarrow>\n      hm_valid hm' i \\<and> heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm\n 2. \\<And>f x.\n       \\<lbrakk>hm_valid hm i \\<and> h.swim_invar (hmr_\\<alpha> hm) i;\n        \\<And>x'.\n           \\<lbrakk>case x' of\n                    (hm', i) \\<Rightarrow>\n                      hm_valid hm' i \\<and>\n                      heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm;\n            (x', x) \\<in> inv_image less_than snd\\<rbrakk>\n           \\<Longrightarrow> f x' \\<le>\\<^sub>n\n                             SPEC\n                              (\\<lambda>hm'.\n                                  heapmap_\\<alpha> hm' =\n                                  heapmap_\\<alpha> hm);\n        case x of\n        (hm', i) \\<Rightarrow>\n          hm_valid hm' i \\<and> heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm;\n        REC\\<^sub>T\n         (\\<lambda>swim a.\n             case a of\n             (h, i) \\<Rightarrow>\n               ASSERT\n                (hm_valid h i \\<and>\n                 h.swim_invar (hmr_\\<alpha> h) i) \\<bind>\n               (\\<lambda>_.\n                   if hm_valid h (h.parent i)\n                   then hm_prio_of_op h (h.parent i) \\<bind>\n                        (\\<lambda>ppi.\n                            hm_prio_of_op h i \\<bind>\n                            (\\<lambda>pi.\n                                if \\<not> ppi \\<le> pi\n                                then hm_exch_op h i (h.parent i) \\<bind>\n                                     (\\<lambda>h. swim (h, h.parent i))\n                                else RETURN h))\n                   else RETURN h)) =\n        f\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          (h, i) \\<Rightarrow>\n                            ASSERT\n                             (hm_valid h i \\<and>\n                              h.swim_invar (hmr_\\<alpha> h) i) \\<bind>\n                            (\\<lambda>_.\n                                if hm_valid h (h.parent i)\n                                then hm_prio_of_op h (h.parent i) \\<bind>\n                                     (\\<lambda>ppi.\n   hm_prio_of_op h i \\<bind>\n   (\\<lambda>pi.\n       if \\<not> ppi \\<le> pi\n       then hm_exch_op h i (h.parent i) \\<bind>\n            (\\<lambda>h. f (h, h.parent i))\n       else RETURN h))\n                                else RETURN h)) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>hm'.\n                              heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f x.\n       \\<lbrakk>hm_valid hm i \\<and> h.swim_invar (hmr_\\<alpha> hm) i;\n        \\<And>x'.\n           \\<lbrakk>case x' of\n                    (hm', i) \\<Rightarrow>\n                      hm_valid hm' i \\<and>\n                      heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm;\n            (x', x) \\<in> inv_image less_than snd\\<rbrakk>\n           \\<Longrightarrow> f x' \\<le>\\<^sub>n\n                             SPEC\n                              (\\<lambda>hm'.\n                                  heapmap_\\<alpha> hm' =\n                                  heapmap_\\<alpha> hm);\n        case x of\n        (hm', i) \\<Rightarrow>\n          hm_valid hm' i \\<and> heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm;\n        REC\\<^sub>T\n         (\\<lambda>swim a.\n             case a of\n             (h, i) \\<Rightarrow>\n               ASSERT\n                (hm_valid h i \\<and>\n                 h.swim_invar (hmr_\\<alpha> h) i) \\<bind>\n               (\\<lambda>_.\n                   if hm_valid h (h.parent i)\n                   then hm_prio_of_op h (h.parent i) \\<bind>\n                        (\\<lambda>ppi.\n                            hm_prio_of_op h i \\<bind>\n                            (\\<lambda>pi.\n                                if \\<not> ppi \\<le> pi\n                                then hm_exch_op h i (h.parent i) \\<bind>\n                                     (\\<lambda>h. swim (h, h.parent i))\n                                else RETURN h))\n                   else RETURN h)) =\n        f\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          (h, i) \\<Rightarrow>\n                            ASSERT\n                             (hm_valid h i \\<and>\n                              h.swim_invar (hmr_\\<alpha> h) i) \\<bind>\n                            (\\<lambda>_.\n                                if hm_valid h (h.parent i)\n                                then hm_prio_of_op h (h.parent i) \\<bind>\n                                     (\\<lambda>ppi.\n   hm_prio_of_op h i \\<bind>\n   (\\<lambda>pi.\n       if \\<not> ppi \\<le> pi\n       then hm_exch_op h i (h.parent i) \\<bind>\n            (\\<lambda>h. f (h, h.parent i))\n       else RETURN h))\n                                else RETURN h)) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>hm'.\n                              heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm)", "unfolding hm_prio_of_op_def hm_val_of_op_def \n        hm_exch_op_def hm_key_of_op_def hm_the_lookup_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f x.\n       \\<lbrakk>hm_valid hm i \\<and> h.swim_invar (hmr_\\<alpha> hm) i;\n        \\<And>x'.\n           \\<lbrakk>case x' of\n                    (hm', i) \\<Rightarrow>\n                      hm_valid hm' i \\<and>\n                      heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm;\n            (x', x) \\<in> inv_image less_than snd\\<rbrakk>\n           \\<Longrightarrow> f x' \\<le>\\<^sub>n\n                             SPEC\n                              (\\<lambda>hm'.\n                                  heapmap_\\<alpha> hm' =\n                                  heapmap_\\<alpha> hm);\n        case x of\n        (hm', i) \\<Rightarrow>\n          hm_valid hm' i \\<and> heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm;\n        REC\\<^sub>T\n         (\\<lambda>swim a.\n             case a of\n             (h, i) \\<Rightarrow>\n               ASSERT\n                (hm_valid h i \\<and>\n                 h.swim_invar (hmr_\\<alpha> h) i) \\<bind>\n               (\\<lambda>_.\n                   if hm_valid h (h.parent i)\n                   then (case h of\n                         (pq, m) \\<Rightarrow>\n                           \\<lambda>i.\n                              ASSERT (0 < i) \\<bind>\n                              (\\<lambda>_. mop_list_get pq (i - 1)))\n                         (h.parent i) \\<bind>\n                        (\\<lambda>k.\n                            ASSERT\n                             (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                              hmr_invar h) \\<bind>\n                            (\\<lambda>_.\n                                RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                            RETURN) \\<bind>\n                        (\\<lambda>v. RETURN (prio v)) \\<bind>\n                        (\\<lambda>ppi.\n                            (case h of\n                             (pq, m) \\<Rightarrow>\n                               \\<lambda>i.\n                                  ASSERT (0 < i) \\<bind>\n                                  (\\<lambda>_. mop_list_get pq (i - 1)))\n                             i \\<bind>\n                            (\\<lambda>k.\n                                ASSERT\n                                 (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                                  hmr_invar h) \\<bind>\n                                (\\<lambda>_.\n                                    RETURN\n                                     (the (heapmap_\\<alpha> h k))) \\<bind>\n                                RETURN) \\<bind>\n                            (\\<lambda>v. RETURN (prio v)) \\<bind>\n                            (\\<lambda>pi.\n                                if \\<not> ppi \\<le> pi\n                                then (case h of\n(pq, m) \\<Rightarrow>\n  \\<lambda>i j.\n     ASSERT (hm_valid (pq, m) i) \\<bind>\n     (\\<lambda>_.\n         ASSERT (hm_valid (pq, m) j) \\<bind>\n         (\\<lambda>_.\n             ASSERT (hmr_invar (pq, m)) \\<bind>\n             (\\<lambda>_.\n                 mop_list_swap pq (i - 1) (j - 1) \\<bind>\n                 (\\<lambda>pq. RETURN (pq, m))))))\ni (h.parent i) \\<bind>\n                                     (\\<lambda>h. swim (h, h.parent i))\n                                else RETURN h))\n                   else RETURN h)) =\n        f\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          (h, i) \\<Rightarrow>\n                            ASSERT\n                             (hm_valid h i \\<and>\n                              h.swim_invar (hmr_\\<alpha> h) i) \\<bind>\n                            (\\<lambda>_.\n                                if hm_valid h (h.parent i)\n                                then (case h of\n(pq, m) \\<Rightarrow>\n  \\<lambda>i. ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_get pq (i - 1)))\n(h.parent i) \\<bind>\n                                     (\\<lambda>k.\n   ASSERT (heapmap_\\<alpha> h k \\<noteq> None \\<and> hmr_invar h) \\<bind>\n   (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n   RETURN) \\<bind>\n                                     (\\<lambda>v. RETURN (prio v)) \\<bind>\n                                     (\\<lambda>ppi.\n   (case h of\n    (pq, m) \\<Rightarrow>\n      \\<lambda>i.\n         ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_get pq (i - 1)))\n    i \\<bind>\n   (\\<lambda>k.\n       ASSERT\n        (heapmap_\\<alpha> h k \\<noteq> None \\<and> hmr_invar h) \\<bind>\n       (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n       RETURN) \\<bind>\n   (\\<lambda>v. RETURN (prio v)) \\<bind>\n   (\\<lambda>pi.\n       if \\<not> ppi \\<le> pi\n       then (case h of\n             (pq, m) \\<Rightarrow>\n               \\<lambda>i j.\n                  ASSERT (hm_valid (pq, m) i) \\<bind>\n                  (\\<lambda>_.\n                      ASSERT (hm_valid (pq, m) j) \\<bind>\n                      (\\<lambda>_.\n                          ASSERT (hmr_invar (pq, m)) \\<bind>\n                          (\\<lambda>_.\n                              mop_list_swap pq (i - 1) (j - 1) \\<bind>\n                              (\\<lambda>pq. RETURN (pq, m))))))\n             i (h.parent i) \\<bind>\n            (\\<lambda>h. f (h, h.parent i))\n       else RETURN h))\n                                else RETURN h)) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>hm'.\n                              heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm)", "apply (refine_vcg)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>f x x1 x1a x2 x1b x2a x2b.\n       \\<lbrakk>hm_valid hm i \\<and> h.swim_invar (hmr_\\<alpha> hm) i;\n        \\<And>x'.\n           \\<lbrakk>case x' of\n                    (hm', i) \\<Rightarrow>\n                      hm_valid hm' i \\<and>\n                      heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm;\n            (x', x) \\<in> inv_image less_than snd\\<rbrakk>\n           \\<Longrightarrow> f x' \\<le>\\<^sub>n\n                             SPEC\n                              (\\<lambda>hm'.\n                                  heapmap_\\<alpha> hm' =\n                                  heapmap_\\<alpha> hm);\n        case x of\n        (hm', i) \\<Rightarrow>\n          hm_valid hm' i \\<and> heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm;\n        REC\\<^sub>T\n         (\\<lambda>swim a.\n             case a of\n             (h, i) \\<Rightarrow>\n               ASSERT\n                (hm_valid h i \\<and>\n                 h.swim_invar (hmr_\\<alpha> h) i) \\<bind>\n               (\\<lambda>_.\n                   if hm_valid h (h.parent i)\n                   then (case h of\n                         (pq, m) \\<Rightarrow>\n                           \\<lambda>i.\n                              ASSERT (0 < i) \\<bind>\n                              (\\<lambda>_. mop_list_get pq (i - 1)))\n                         (h.parent i) \\<bind>\n                        (\\<lambda>k.\n                            ASSERT\n                             (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                              hmr_invar h) \\<bind>\n                            (\\<lambda>_.\n                                RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                            RETURN) \\<bind>\n                        (\\<lambda>v. RETURN (prio v)) \\<bind>\n                        (\\<lambda>ppi.\n                            (case h of\n                             (pq, m) \\<Rightarrow>\n                               \\<lambda>i.\n                                  ASSERT (0 < i) \\<bind>\n                                  (\\<lambda>_. mop_list_get pq (i - 1)))\n                             i \\<bind>\n                            (\\<lambda>k.\n                                ASSERT\n                                 (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                                  hmr_invar h) \\<bind>\n                                (\\<lambda>_.\n                                    RETURN\n                                     (the (heapmap_\\<alpha> h k))) \\<bind>\n                                RETURN) \\<bind>\n                            (\\<lambda>v. RETURN (prio v)) \\<bind>\n                            (\\<lambda>pi.\n                                if \\<not> ppi \\<le> pi\n                                then (case h of\n(pq, m) \\<Rightarrow>\n  \\<lambda>i j.\n     ASSERT (hm_valid (pq, m) i) \\<bind>\n     (\\<lambda>_.\n         ASSERT (hm_valid (pq, m) j) \\<bind>\n         (\\<lambda>_.\n             ASSERT (hmr_invar (pq, m)) \\<bind>\n             (\\<lambda>_.\n                 mop_list_swap pq (i - 1) (j - 1) \\<bind>\n                 (\\<lambda>pq. RETURN (pq, m))))))\ni (h.parent i) \\<bind>\n                                     (\\<lambda>h. swim (h, h.parent i))\n                                else RETURN h))\n                   else RETURN h)) =\n        f;\n        x1 = (x1a, x2); x1 = (x1b, x2a); x = (x1, x2b);\n        hm_valid x1 x2b \\<and> h.swim_invar (hmr_\\<alpha> x1) x2b;\n        hm_valid x1 (h.parent x2b); 0 < h.parent x2b;\n        h.parent x2b - 1 < length x1b;\n        heapmap_\\<alpha> x1 (x1b ! (h.parent x2b - 1)) \\<noteq> None \\<and>\n        hmr_invar x1;\n        0 < x2b; x2b - 1 < length x1b;\n        heapmap_\\<alpha> x1 (x1b ! (x2b - 1)) \\<noteq> None \\<and>\n        hmr_invar x1;\n        \\<not> prio (the (heapmap_\\<alpha> x1 (x1b ! (h.parent x2b - 1))))\n               \\<le> prio (the (heapmap_\\<alpha> x1 (x1b ! (x2b - 1))));\n        hm_valid (x1a, x2) x2b; hm_valid (x1a, x2) (h.parent x2b);\n        hmr_invar (x1a, x2);\n        x2b - 1 < length x1a \\<and> h.parent x2b - 1 < length x1a\\<rbrakk>\n       \\<Longrightarrow> f ((swap x1a (x2b - 1) (h.parent x2b - 1), x2),\n                            h.parent x2b) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>hm'.\n                              heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm)\n 2. \\<And>f x x1 x1a x2 x1b x2a x2b.\n       \\<lbrakk>hm_valid hm i \\<and> h.swim_invar (hmr_\\<alpha> hm) i;\n        \\<And>x'.\n           \\<lbrakk>case x' of\n                    (hm', i) \\<Rightarrow>\n                      hm_valid hm' i \\<and>\n                      heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm;\n            (x', x) \\<in> inv_image less_than snd\\<rbrakk>\n           \\<Longrightarrow> f x' \\<le>\\<^sub>n\n                             SPEC\n                              (\\<lambda>hm'.\n                                  heapmap_\\<alpha> hm' =\n                                  heapmap_\\<alpha> hm);\n        case x of\n        (hm', i) \\<Rightarrow>\n          hm_valid hm' i \\<and> heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm;\n        REC\\<^sub>T\n         (\\<lambda>swim a.\n             case a of\n             (h, i) \\<Rightarrow>\n               ASSERT\n                (hm_valid h i \\<and>\n                 h.swim_invar (hmr_\\<alpha> h) i) \\<bind>\n               (\\<lambda>_.\n                   if hm_valid h (h.parent i)\n                   then (case h of\n                         (pq, m) \\<Rightarrow>\n                           \\<lambda>i.\n                              ASSERT (0 < i) \\<bind>\n                              (\\<lambda>_. mop_list_get pq (i - 1)))\n                         (h.parent i) \\<bind>\n                        (\\<lambda>k.\n                            ASSERT\n                             (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                              hmr_invar h) \\<bind>\n                            (\\<lambda>_.\n                                RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                            RETURN) \\<bind>\n                        (\\<lambda>v. RETURN (prio v)) \\<bind>\n                        (\\<lambda>ppi.\n                            (case h of\n                             (pq, m) \\<Rightarrow>\n                               \\<lambda>i.\n                                  ASSERT (0 < i) \\<bind>\n                                  (\\<lambda>_. mop_list_get pq (i - 1)))\n                             i \\<bind>\n                            (\\<lambda>k.\n                                ASSERT\n                                 (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                                  hmr_invar h) \\<bind>\n                                (\\<lambda>_.\n                                    RETURN\n                                     (the (heapmap_\\<alpha> h k))) \\<bind>\n                                RETURN) \\<bind>\n                            (\\<lambda>v. RETURN (prio v)) \\<bind>\n                            (\\<lambda>pi.\n                                if \\<not> ppi \\<le> pi\n                                then (case h of\n(pq, m) \\<Rightarrow>\n  \\<lambda>i j.\n     ASSERT (hm_valid (pq, m) i) \\<bind>\n     (\\<lambda>_.\n         ASSERT (hm_valid (pq, m) j) \\<bind>\n         (\\<lambda>_.\n             ASSERT (hmr_invar (pq, m)) \\<bind>\n             (\\<lambda>_.\n                 mop_list_swap pq (i - 1) (j - 1) \\<bind>\n                 (\\<lambda>pq. RETURN (pq, m))))))\ni (h.parent i) \\<bind>\n                                     (\\<lambda>h. swim (h, h.parent i))\n                                else RETURN h))\n                   else RETURN h)) =\n        f;\n        x1 = (x1a, x2); x1 = (x1b, x2a); x = (x1, x2b);\n        hm_valid x1 x2b \\<and> h.swim_invar (hmr_\\<alpha> x1) x2b;\n        hm_valid x1 (h.parent x2b); 0 < h.parent x2b;\n        h.parent x2b - 1 < length x1b;\n        heapmap_\\<alpha> x1 (x1b ! (h.parent x2b - 1)) \\<noteq> None \\<and>\n        hmr_invar x1;\n        0 < x2b; x2b - 1 < length x1b;\n        heapmap_\\<alpha> x1 (x1b ! (x2b - 1)) \\<noteq> None \\<and>\n        hmr_invar x1;\n        \\<not> \\<not> prio\n                       (the (heapmap_\\<alpha> x1\n                              (x1b ! (h.parent x2b - 1))))\n                      \\<le> prio\n                             (the (heapmap_\\<alpha> x1\n                                    (x1b ! (x2b - 1))))\\<rbrakk>\n       \\<Longrightarrow> heapmap_\\<alpha> x1 = heapmap_\\<alpha> hm\n 3. \\<And>f x x1 x1a x2 x1b x2a x2b.\n       \\<lbrakk>hm_valid hm i \\<and> h.swim_invar (hmr_\\<alpha> hm) i;\n        \\<And>x'.\n           \\<lbrakk>case x' of\n                    (hm', i) \\<Rightarrow>\n                      hm_valid hm' i \\<and>\n                      heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm;\n            (x', x) \\<in> inv_image less_than snd\\<rbrakk>\n           \\<Longrightarrow> f x' \\<le>\\<^sub>n\n                             SPEC\n                              (\\<lambda>hm'.\n                                  heapmap_\\<alpha> hm' =\n                                  heapmap_\\<alpha> hm);\n        case x of\n        (hm', i) \\<Rightarrow>\n          hm_valid hm' i \\<and> heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm;\n        REC\\<^sub>T\n         (\\<lambda>swim a.\n             case a of\n             (h, i) \\<Rightarrow>\n               ASSERT\n                (hm_valid h i \\<and>\n                 h.swim_invar (hmr_\\<alpha> h) i) \\<bind>\n               (\\<lambda>_.\n                   if hm_valid h (h.parent i)\n                   then (case h of\n                         (pq, m) \\<Rightarrow>\n                           \\<lambda>i.\n                              ASSERT (0 < i) \\<bind>\n                              (\\<lambda>_. mop_list_get pq (i - 1)))\n                         (h.parent i) \\<bind>\n                        (\\<lambda>k.\n                            ASSERT\n                             (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                              hmr_invar h) \\<bind>\n                            (\\<lambda>_.\n                                RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                            RETURN) \\<bind>\n                        (\\<lambda>v. RETURN (prio v)) \\<bind>\n                        (\\<lambda>ppi.\n                            (case h of\n                             (pq, m) \\<Rightarrow>\n                               \\<lambda>i.\n                                  ASSERT (0 < i) \\<bind>\n                                  (\\<lambda>_. mop_list_get pq (i - 1)))\n                             i \\<bind>\n                            (\\<lambda>k.\n                                ASSERT\n                                 (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                                  hmr_invar h) \\<bind>\n                                (\\<lambda>_.\n                                    RETURN\n                                     (the (heapmap_\\<alpha> h k))) \\<bind>\n                                RETURN) \\<bind>\n                            (\\<lambda>v. RETURN (prio v)) \\<bind>\n                            (\\<lambda>pi.\n                                if \\<not> ppi \\<le> pi\n                                then (case h of\n(pq, m) \\<Rightarrow>\n  \\<lambda>i j.\n     ASSERT (hm_valid (pq, m) i) \\<bind>\n     (\\<lambda>_.\n         ASSERT (hm_valid (pq, m) j) \\<bind>\n         (\\<lambda>_.\n             ASSERT (hmr_invar (pq, m)) \\<bind>\n             (\\<lambda>_.\n                 mop_list_swap pq (i - 1) (j - 1) \\<bind>\n                 (\\<lambda>pq. RETURN (pq, m))))))\ni (h.parent i) \\<bind>\n                                     (\\<lambda>h. swim (h, h.parent i))\n                                else RETURN h))\n                   else RETURN h)) =\n        f;\n        x1 = (x1a, x2); x1 = (x1b, x2a); x = (x1, x2b);\n        hm_valid x1 x2b \\<and> h.swim_invar (hmr_\\<alpha> x1) x2b;\n        \\<not> hm_valid x1 (h.parent x2b)\\<rbrakk>\n       \\<Longrightarrow> heapmap_\\<alpha> x1 = heapmap_\\<alpha> hm", "apply (vc_solve simp add: hm_valid_def hm_length_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2 x2b y ya.\n       \\<lbrakk>\\<And>a b ba.\n                   \\<lbrakk>0 < ba \\<and>\n                            ba \\<le> length a \\<and>\n                            heapmap_\\<alpha> (a, b) = heapmap_\\<alpha> hm;\n                    ba < x2b\\<rbrakk>\n                   \\<Longrightarrow> REC\\<^sub>T\n(\\<lambda>swim (h, i).\n    ASSERT\n     (0 < i \\<and>\n      i \\<le> (case h of (pq, uu_) \\<Rightarrow> length pq) \\<and>\n      h.swim_invar (hmr_\\<alpha> h) i) \\<bind>\n    (\\<lambda>_.\n        if 0 < h.parent i \\<and>\n           h.parent i \\<le> (case h of (pq, uu_) \\<Rightarrow> length pq)\n        then (case h of\n              (pq, m) \\<Rightarrow>\n                \\<lambda>i.\n                   ASSERT (0 < i) \\<bind>\n                   (\\<lambda>_. mop_list_get pq (i - 1)))\n              (h.parent i) \\<bind>\n             (\\<lambda>k.\n                 ASSERT\n                  (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                   hmr_invar h) \\<bind>\n                 (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                 RETURN) \\<bind>\n             (\\<lambda>v. RETURN (prio v)) \\<bind>\n             (\\<lambda>ppi.\n                 (case h of\n                  (pq, m) \\<Rightarrow>\n                    \\<lambda>i.\n                       ASSERT (0 < i) \\<bind>\n                       (\\<lambda>_. mop_list_get pq (i - 1)))\n                  i \\<bind>\n                 (\\<lambda>k.\n                     ASSERT\n                      (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                       hmr_invar h) \\<bind>\n                     (\\<lambda>_.\n                         RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                     RETURN) \\<bind>\n                 (\\<lambda>v. RETURN (prio v)) \\<bind>\n                 (\\<lambda>pi.\n                     if \\<not> ppi \\<le> pi\n                     then (case h of\n                           (pq, m) \\<Rightarrow>\n                             \\<lambda>i j.\n                                ASSERT (hm_valid (pq, m) i) \\<bind>\n                                (\\<lambda>_.\n                                    ASSERT (hm_valid (pq, m) j) \\<bind>\n                                    (\\<lambda>_.\n  ASSERT (hmr_invar (pq, m)) \\<bind>\n  (\\<lambda>_.\n      mop_list_swap pq (i - 1) (j - 1) \\<bind>\n      (\\<lambda>pq. RETURN (pq, m))))))\n                           i (h.parent i) \\<bind>\n                          (\\<lambda>h. swim (h, h.parent i))\n                     else RETURN h))\n        else RETURN h))\n((a, b), ba) \\<le>\\<^sub>n\n                                     SPEC\n(\\<lambda>hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm);\n        h.swim_invar (hmr_\\<alpha> (x1a, x2)) x2b;\n        h.parent x2b \\<le> length x1a; 0 < h.parent x2b;\n        h.parent x2b - Suc 0 < length x1a; 0 < x2b;\n        x2b - Suc 0 < length x1a; \\<not> prio y \\<le> prio ya;\n        hmr_invar (x1a, x2);\n        heapmap_\\<alpha> hm (x1a ! (h.parent x2b - Suc 0)) = Some y;\n        heapmap_\\<alpha> hm (x1a ! (x2b - Suc 0)) = Some ya; 0 < i;\n        x2b \\<le> length x1a;\n        heapmap_\\<alpha> (x1a, x2) = heapmap_\\<alpha> hm;\n        i \\<le> (case hm of (pq, uu_) \\<Rightarrow> length pq);\n        h.swim_invar (hmr_\\<alpha> hm) i\\<rbrakk>\n       \\<Longrightarrow> REC\\<^sub>T\n                          (\\<lambda>swim (h, i).\n                              ASSERT\n                               (0 < i \\<and>\n                                i \\<le> (case h of\n   (pq, uu_) \\<Rightarrow> length pq) \\<and>\n                                h.swim_invar (hmr_\\<alpha> h) i) \\<bind>\n                              (\\<lambda>_.\n                                  if 0 < h.parent i \\<and>\n                                     h.parent i\n                                     \\<le> (case h of\n      (pq, uu_) \\<Rightarrow> length pq)\n                                  then (case h of\n  (pq, m) \\<Rightarrow>\n    \\<lambda>i.\n       ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_get pq (i - 1)))\n  (h.parent i) \\<bind>\n (\\<lambda>k.\n     ASSERT (heapmap_\\<alpha> h k \\<noteq> None \\<and> hmr_invar h) \\<bind>\n     (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n     RETURN) \\<bind>\n (\\<lambda>v. RETURN (prio v)) \\<bind>\n (\\<lambda>ppi.\n     (case h of\n      (pq, m) \\<Rightarrow>\n        \\<lambda>i.\n           ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_get pq (i - 1)))\n      i \\<bind>\n     (\\<lambda>k.\n         ASSERT\n          (heapmap_\\<alpha> h k \\<noteq> None \\<and> hmr_invar h) \\<bind>\n         (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n         RETURN) \\<bind>\n     (\\<lambda>v. RETURN (prio v)) \\<bind>\n     (\\<lambda>pi.\n         if \\<not> ppi \\<le> pi\n         then (case h of\n               (pq, m) \\<Rightarrow>\n                 \\<lambda>i j.\n                    ASSERT (hm_valid (pq, m) i) \\<bind>\n                    (\\<lambda>_.\n                        ASSERT (hm_valid (pq, m) j) \\<bind>\n                        (\\<lambda>_.\n                            ASSERT (hmr_invar (pq, m)) \\<bind>\n                            (\\<lambda>_.\n                                mop_list_swap pq (i - 1) (j - 1) \\<bind>\n                                (\\<lambda>pq. RETURN (pq, m))))))\n               i (h.parent i) \\<bind>\n              (\\<lambda>h. swim (h, h.parent i))\n         else RETURN h))\n                                  else RETURN h))\n                          ((swap x1a (x2b - Suc 0) (h.parent x2b - Suc 0),\n                            x2),\n                           h.parent x2b) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>hm'.\n                              heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm)", "apply rprems"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1a x2 x2b y ya.\n       \\<lbrakk>h.swim_invar (hmr_\\<alpha> (x1a, x2)) x2b;\n        h.parent x2b \\<le> length x1a; 0 < h.parent x2b;\n        h.parent x2b - Suc 0 < length x1a; 0 < x2b;\n        x2b - Suc 0 < length x1a; \\<not> prio y \\<le> prio ya;\n        hmr_invar (x1a, x2);\n        heapmap_\\<alpha> hm (x1a ! (h.parent x2b - Suc 0)) = Some y;\n        heapmap_\\<alpha> hm (x1a ! (x2b - Suc 0)) = Some ya; 0 < i;\n        x2b \\<le> length x1a;\n        heapmap_\\<alpha> (x1a, x2) = heapmap_\\<alpha> hm;\n        i \\<le> (case hm of (pq, uu_) \\<Rightarrow> length pq);\n        h.swim_invar (hmr_\\<alpha> hm) i\\<rbrakk>\n       \\<Longrightarrow> 0 < h.parent x2b \\<and>\n                         h.parent x2b\n                         \\<le> length\n                                (swap x1a (x2b - Suc 0)\n                                  (h.parent x2b - Suc 0)) \\<and>\n                         heapmap_\\<alpha>\n                          (swap x1a (x2b - Suc 0) (h.parent x2b - Suc 0),\n                           x2) =\n                         heapmap_\\<alpha> hm\n 2. \\<And>x1a x2 x2b y ya.\n       \\<lbrakk>h.swim_invar (hmr_\\<alpha> (x1a, x2)) x2b;\n        h.parent x2b \\<le> length x1a; 0 < h.parent x2b;\n        h.parent x2b - Suc 0 < length x1a; 0 < x2b;\n        x2b - Suc 0 < length x1a; \\<not> prio y \\<le> prio ya;\n        hmr_invar (x1a, x2);\n        heapmap_\\<alpha> hm (x1a ! (h.parent x2b - Suc 0)) = Some y;\n        heapmap_\\<alpha> hm (x1a ! (x2b - Suc 0)) = Some ya; 0 < i;\n        x2b \\<le> length x1a;\n        heapmap_\\<alpha> (x1a, x2) = heapmap_\\<alpha> hm;\n        i \\<le> (case hm of (pq, uu_) \\<Rightarrow> length pq);\n        h.swim_invar (hmr_\\<alpha> hm) i\\<rbrakk>\n       \\<Longrightarrow> h.parent x2b < x2b", "apply (vc_solve simp: heapmap_\\<alpha>_def h.parent_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Sink\\<close>"], ["", "definition hm_sink_op\n    where   \n      \"hm_sink_op h k \\<equiv> RECT (\\<lambda>D (h,k). do {\n        ASSERT (k>0 \\<and> k\\<le>hm_length h);\n        let len = hm_length h;\n        if (2*k \\<le> len) then do {\n          let j = 2*k;\n          pj \\<leftarrow> hm_prio_of_op h j;\n\n          j \\<leftarrow> (\n            if j<len then do {\n              psj \\<leftarrow> hm_prio_of_op h (Suc j);\n              if pj>psj then RETURN (j+1) else RETURN j\n            } else RETURN j);\n\n          pj \\<leftarrow> hm_prio_of_op h j;\n          pk \\<leftarrow> hm_prio_of_op h k;\n          if (pk > pj) then do {\n            h \\<leftarrow> hm_exch_op h k j;\n            D (h,j)\n          } else\n            RETURN h\n        } else RETURN h    \n      }) (h,k)\""], ["", "lemma hm_sink_op_refine: \"(hm_sink_op, h.sink_op) \\<in> hmr_rel \\<rightarrow> nat_rel \\<rightarrow> \\<langle>hmr_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hm_sink_op, h.sink_op)\n    \\<in> hmr_rel \\<rightarrow>\n          nat_rel \\<rightarrow> \\<langle>hmr_rel\\<rangle>nres_rel", "apply (intro fun_relI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> hm_sink_op a aa\n                         \\<le> \\<Down> hmr_rel (h.sink_op a' a'a)", "unfolding hm_sink_op_def h.sink_op_opt_eq[symmetric] h.sink_op_opt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> REC\\<^sub>T\n                          (\\<lambda>D (h, k).\n                              ASSERT\n                               (0 < k \\<and> k \\<le> hm_length h) \\<bind>\n                              (\\<lambda>_.\n                                  let len = hm_length h\n                                  in if 2 * k \\<le> len\n                                     then let j = 2 * k\n    in hm_prio_of_op h j \\<bind>\n       (\\<lambda>pj.\n           (if j < len\n            then hm_prio_of_op h (Suc j) \\<bind>\n                 (\\<lambda>psj.\n                     if psj < pj then RETURN (j + 1) else RETURN j)\n            else RETURN j) \\<bind>\n           (\\<lambda>j.\n               hm_prio_of_op h j \\<bind>\n               (\\<lambda>pj.\n                   hm_prio_of_op h k \\<bind>\n                   (\\<lambda>pk.\n                       if pj < pk\n                       then hm_exch_op h k j \\<bind> (\\<lambda>h. D (h, j))\n                       else RETURN h))))\n                                     else RETURN h))\n                          (a, aa)\n                         \\<le> \\<Down> hmr_rel\n                                (REC\\<^sub>T\n                                  (\\<lambda>D (h, k).\nASSERT (0 < k \\<and> k \\<le> length h) \\<bind>\n(\\<lambda>_.\n    let len = length h\n    in if 2 * k \\<le> len\n       then let j = 2 * k\n            in h.prio_of_op h j \\<bind>\n               (\\<lambda>pj.\n                   (if j < len\n                    then h.prio_of_op h (Suc j) \\<bind>\n                         (\\<lambda>psj.\n                             if psj < pj then RETURN (j + 1) else RETURN j)\n                    else RETURN j) \\<bind>\n                   (\\<lambda>j.\n                       h.prio_of_op h j \\<bind>\n                       (\\<lambda>pj.\n                           h.prio_of_op h k \\<bind>\n                           (\\<lambda>pk.\n                               if pj < pk\n                               then h.exch_op h k j \\<bind>\n                                    (\\<lambda>h. D (h, j))\n                               else RETURN h))))\n       else RETURN h))\n                                  (a', a'a))", "apply refine_rcg"], ["proof (prove)\ngoal (24 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> ((a, aa), a', a'a) \\<in> ?R3 a a' aa a'a\n 2. \\<And>a a' aa a'a D Da x x' x1 x2 x1a x2a.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n        \\<And>x x'.\n           (x, x') \\<in> ?R3 a a' aa a'a \\<Longrightarrow>\n           D x \\<le> \\<Down> hmr_rel (Da x');\n        (x, x') \\<in> ?R3 a a' aa a'a; x' = (x1, x2); x = (x1a, x2a);\n        0 < x2 \\<and> x2 \\<le> length x1\\<rbrakk>\n       \\<Longrightarrow> 0 < x2a\n 3. \\<And>a a' aa a'a D Da x x' x1 x2 x1a x2a.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n        \\<And>x x'.\n           (x, x') \\<in> ?R3 a a' aa a'a \\<Longrightarrow>\n           D x \\<le> \\<Down> hmr_rel (Da x');\n        (x, x') \\<in> ?R3 a a' aa a'a; x' = (x1, x2); x = (x1a, x2a);\n        0 < x2 \\<and> x2 \\<le> length x1\\<rbrakk>\n       \\<Longrightarrow> x2a \\<le> hm_length x1a\n 4. \\<And>a a' aa a'a D Da x x' x1 x2 x1a x2a.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n        \\<And>x x'.\n           (x, x') \\<in> ?R3 a a' aa a'a \\<Longrightarrow>\n           D x \\<le> \\<Down> hmr_rel (Da x');\n        (x, x') \\<in> ?R3 a a' aa a'a; x' = (x1, x2); x = (x1a, x2a);\n        0 < x2 \\<and> x2 \\<le> length x1;\n        0 < x2a \\<and> x2a \\<le> hm_length x1a\\<rbrakk>\n       \\<Longrightarrow> (2 * x2a \\<le> hm_length x1a) =\n                         (2 * x2 \\<le> length x1)\n 5. \\<And>a a' aa a'a D Da x x' x1 x2 x1a x2a.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n        \\<And>x x'.\n           (x, x') \\<in> ?R3 a a' aa a'a \\<Longrightarrow>\n           D x \\<le> \\<Down> hmr_rel (Da x');\n        (x, x') \\<in> ?R3 a a' aa a'a; x' = (x1, x2); x = (x1a, x2a);\n        0 < x2 \\<and> x2 \\<le> length x1;\n        0 < x2a \\<and> x2a \\<le> hm_length x1a; 2 * x2a \\<le> hm_length x1a;\n        2 * x2 \\<le> length x1\\<rbrakk>\n       \\<Longrightarrow> (x1a, x1) \\<in> hmr_rel\n 6. \\<And>a a' aa a'a D Da x x' x1 x2 x1a x2a.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n        \\<And>x x'.\n           (x, x') \\<in> ?R3 a a' aa a'a \\<Longrightarrow>\n           D x \\<le> \\<Down> hmr_rel (Da x');\n        (x, x') \\<in> ?R3 a a' aa a'a; x' = (x1, x2); x = (x1a, x2a);\n        0 < x2 \\<and> x2 \\<le> length x1;\n        0 < x2a \\<and> x2a \\<le> hm_length x1a; 2 * x2a \\<le> hm_length x1a;\n        2 * x2 \\<le> length x1\\<rbrakk>\n       \\<Longrightarrow> (2 * x2a, 2 * x2) \\<in> nat_rel\n 7. \\<And>a a' aa a'a D Da x x' x1 x2 x1a x2a pj pja.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n        \\<And>x x'.\n           (x, x') \\<in> ?R3 a a' aa a'a \\<Longrightarrow>\n           D x \\<le> \\<Down> hmr_rel (Da x');\n        (x, x') \\<in> ?R3 a a' aa a'a; x' = (x1, x2); x = (x1a, x2a);\n        0 < x2 \\<and> x2 \\<le> length x1;\n        0 < x2a \\<and> x2a \\<le> hm_length x1a; 2 * x2a \\<le> hm_length x1a;\n        2 * x2 \\<le> length x1; (pj, pja) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> (2 * x2a < hm_length x1a) = (2 * x2 < length x1)\n 8. \\<And>a a' aa a'a D Da x x' x1 x2 x1a x2a pj pja.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n        \\<And>x x'.\n           (x, x') \\<in> ?R3 a a' aa a'a \\<Longrightarrow>\n           D x \\<le> \\<Down> hmr_rel (Da x');\n        (x, x') \\<in> ?R3 a a' aa a'a; x' = (x1, x2); x = (x1a, x2a);\n        0 < x2 \\<and> x2 \\<le> length x1;\n        0 < x2a \\<and> x2a \\<le> hm_length x1a; 2 * x2a \\<le> hm_length x1a;\n        2 * x2 \\<le> length x1; (pj, pja) \\<in> Id; 2 * x2a < hm_length x1a;\n        2 * x2 < length x1\\<rbrakk>\n       \\<Longrightarrow> (x1a, x1) \\<in> hmr_rel\n 9. \\<And>a a' aa a'a D Da x x' x1 x2 x1a x2a pj pja.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n        \\<And>x x'.\n           (x, x') \\<in> ?R3 a a' aa a'a \\<Longrightarrow>\n           D x \\<le> \\<Down> hmr_rel (Da x');\n        (x, x') \\<in> ?R3 a a' aa a'a; x' = (x1, x2); x = (x1a, x2a);\n        0 < x2 \\<and> x2 \\<le> length x1;\n        0 < x2a \\<and> x2a \\<le> hm_length x1a; 2 * x2a \\<le> hm_length x1a;\n        2 * x2 \\<le> length x1; (pj, pja) \\<in> Id; 2 * x2a < hm_length x1a;\n        2 * x2 < length x1\\<rbrakk>\n       \\<Longrightarrow> (Suc (2 * x2a), Suc (2 * x2)) \\<in> nat_rel\n 10. \\<And>a a' aa a'a D Da x x' x1 x2 x1a x2a pj pja psj psja.\n        \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n         \\<And>x x'.\n            (x, x') \\<in> ?R3 a a' aa a'a \\<Longrightarrow>\n            D x \\<le> \\<Down> hmr_rel (Da x');\n         (x, x') \\<in> ?R3 a a' aa a'a; x' = (x1, x2); x = (x1a, x2a);\n         0 < x2 \\<and> x2 \\<le> length x1;\n         0 < x2a \\<and> x2a \\<le> hm_length x1a;\n         2 * x2a \\<le> hm_length x1a; 2 * x2 \\<le> length x1;\n         (pj, pja) \\<in> Id; 2 * x2a < hm_length x1a; 2 * x2 < length x1;\n         (psj, psja) \\<in> Id\\<rbrakk>\n        \\<Longrightarrow> (psj < pj) = (psja < pja)\nA total of 24 subgoals...", "apply refine_dref_type"], ["proof (prove)\ngoal (22 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> ((a, aa), a', a'a)\n                         \\<in> hmr_rel \\<times>\\<^sub>r nat_rel\n 2. \\<And>a a' aa a'a D Da x x' x1 x2 x1a x2a.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n        \\<And>x x'.\n           (x, x') \\<in> hmr_rel \\<times>\\<^sub>r nat_rel \\<Longrightarrow>\n           D x \\<le> \\<Down> hmr_rel (Da x');\n        (x, x') \\<in> hmr_rel \\<times>\\<^sub>r nat_rel; x' = (x1, x2);\n        x = (x1a, x2a); 0 < x2 \\<and> x2 \\<le> length x1\\<rbrakk>\n       \\<Longrightarrow> 0 < x2a\n 3. \\<And>a a' aa a'a D Da x x' x1 x2 x1a x2a.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n        \\<And>x x'.\n           (x, x') \\<in> hmr_rel \\<times>\\<^sub>r nat_rel \\<Longrightarrow>\n           D x \\<le> \\<Down> hmr_rel (Da x');\n        (x, x') \\<in> hmr_rel \\<times>\\<^sub>r nat_rel; x' = (x1, x2);\n        x = (x1a, x2a); 0 < x2 \\<and> x2 \\<le> length x1\\<rbrakk>\n       \\<Longrightarrow> x2a \\<le> hm_length x1a\n 4. \\<And>a a' aa a'a D Da x x' x1 x2 x1a x2a.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n        \\<And>x x'.\n           (x, x') \\<in> hmr_rel \\<times>\\<^sub>r nat_rel \\<Longrightarrow>\n           D x \\<le> \\<Down> hmr_rel (Da x');\n        (x, x') \\<in> hmr_rel \\<times>\\<^sub>r nat_rel; x' = (x1, x2);\n        x = (x1a, x2a); 0 < x2 \\<and> x2 \\<le> length x1;\n        0 < x2a \\<and> x2a \\<le> hm_length x1a\\<rbrakk>\n       \\<Longrightarrow> (2 * x2a \\<le> hm_length x1a) =\n                         (2 * x2 \\<le> length x1)\n 5. \\<And>a a' aa a'a D Da x x' x1 x2 x1a x2a.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n        \\<And>x x'.\n           (x, x') \\<in> hmr_rel \\<times>\\<^sub>r nat_rel \\<Longrightarrow>\n           D x \\<le> \\<Down> hmr_rel (Da x');\n        (x, x') \\<in> hmr_rel \\<times>\\<^sub>r nat_rel; x' = (x1, x2);\n        x = (x1a, x2a); 0 < x2 \\<and> x2 \\<le> length x1;\n        0 < x2a \\<and> x2a \\<le> hm_length x1a; 2 * x2a \\<le> hm_length x1a;\n        2 * x2 \\<le> length x1\\<rbrakk>\n       \\<Longrightarrow> (x1a, x1) \\<in> hmr_rel\n 6. \\<And>a a' aa a'a D Da x x' x1 x2 x1a x2a.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n        \\<And>x x'.\n           (x, x') \\<in> hmr_rel \\<times>\\<^sub>r nat_rel \\<Longrightarrow>\n           D x \\<le> \\<Down> hmr_rel (Da x');\n        (x, x') \\<in> hmr_rel \\<times>\\<^sub>r nat_rel; x' = (x1, x2);\n        x = (x1a, x2a); 0 < x2 \\<and> x2 \\<le> length x1;\n        0 < x2a \\<and> x2a \\<le> hm_length x1a; 2 * x2a \\<le> hm_length x1a;\n        2 * x2 \\<le> length x1\\<rbrakk>\n       \\<Longrightarrow> (2 * x2a, 2 * x2) \\<in> nat_rel\n 7. \\<And>a a' aa a'a D Da x x' x1 x2 x1a x2a pj pja.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n        \\<And>x x'.\n           (x, x') \\<in> hmr_rel \\<times>\\<^sub>r nat_rel \\<Longrightarrow>\n           D x \\<le> \\<Down> hmr_rel (Da x');\n        (x, x') \\<in> hmr_rel \\<times>\\<^sub>r nat_rel; x' = (x1, x2);\n        x = (x1a, x2a); 0 < x2 \\<and> x2 \\<le> length x1;\n        0 < x2a \\<and> x2a \\<le> hm_length x1a; 2 * x2a \\<le> hm_length x1a;\n        2 * x2 \\<le> length x1; (pj, pja) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> (2 * x2a < hm_length x1a) = (2 * x2 < length x1)\n 8. \\<And>a a' aa a'a D Da x x' x1 x2 x1a x2a pj pja.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n        \\<And>x x'.\n           (x, x') \\<in> hmr_rel \\<times>\\<^sub>r nat_rel \\<Longrightarrow>\n           D x \\<le> \\<Down> hmr_rel (Da x');\n        (x, x') \\<in> hmr_rel \\<times>\\<^sub>r nat_rel; x' = (x1, x2);\n        x = (x1a, x2a); 0 < x2 \\<and> x2 \\<le> length x1;\n        0 < x2a \\<and> x2a \\<le> hm_length x1a; 2 * x2a \\<le> hm_length x1a;\n        2 * x2 \\<le> length x1; (pj, pja) \\<in> Id; 2 * x2a < hm_length x1a;\n        2 * x2 < length x1\\<rbrakk>\n       \\<Longrightarrow> (x1a, x1) \\<in> hmr_rel\n 9. \\<And>a a' aa a'a D Da x x' x1 x2 x1a x2a pj pja.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n        \\<And>x x'.\n           (x, x') \\<in> hmr_rel \\<times>\\<^sub>r nat_rel \\<Longrightarrow>\n           D x \\<le> \\<Down> hmr_rel (Da x');\n        (x, x') \\<in> hmr_rel \\<times>\\<^sub>r nat_rel; x' = (x1, x2);\n        x = (x1a, x2a); 0 < x2 \\<and> x2 \\<le> length x1;\n        0 < x2a \\<and> x2a \\<le> hm_length x1a; 2 * x2a \\<le> hm_length x1a;\n        2 * x2 \\<le> length x1; (pj, pja) \\<in> Id; 2 * x2a < hm_length x1a;\n        2 * x2 < length x1\\<rbrakk>\n       \\<Longrightarrow> (Suc (2 * x2a), Suc (2 * x2)) \\<in> nat_rel\n 10. \\<And>a a' aa a'a D Da x x' x1 x2 x1a x2a pj pja psj psja.\n        \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel;\n         \\<And>x x'.\n            (x, x') \\<in> hmr_rel \\<times>\\<^sub>r nat_rel \\<Longrightarrow>\n            D x \\<le> \\<Down> hmr_rel (Da x');\n         (x, x') \\<in> hmr_rel \\<times>\\<^sub>r nat_rel; x' = (x1, x2);\n         x = (x1a, x2a); 0 < x2 \\<and> x2 \\<le> length x1;\n         0 < x2a \\<and> x2a \\<le> hm_length x1a;\n         2 * x2a \\<le> hm_length x1a; 2 * x2 \\<le> length x1;\n         (pj, pja) \\<in> Id; 2 * x2a < hm_length x1a; 2 * x2 < length x1;\n         (psj, psja) \\<in> Id\\<rbrakk>\n        \\<Longrightarrow> (psj < pj) = (psja < pja)\nA total of 22 subgoals...", "unfolding hmr_rel_def heapmap_rel_def"], ["proof (prove)\ngoal (22 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> br hmr_\\<alpha> hmr_invar;\n        (aa, a'a) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> ((a, aa), a', a'a)\n                         \\<in> br hmr_\\<alpha> hmr_invar \\<times>\\<^sub>r\n                               nat_rel\n 2. \\<And>a a' aa a'a D Da x x' x1 x2 x1a x2a.\n       \\<lbrakk>(a, a') \\<in> br hmr_\\<alpha> hmr_invar;\n        (aa, a'a) \\<in> nat_rel;\n        \\<And>x x'.\n           (x, x')\n           \\<in> br hmr_\\<alpha> hmr_invar \\<times>\\<^sub>r\n                 nat_rel \\<Longrightarrow>\n           D x \\<le> \\<Down> (br hmr_\\<alpha> hmr_invar) (Da x');\n        (x, x') \\<in> br hmr_\\<alpha> hmr_invar \\<times>\\<^sub>r nat_rel;\n        x' = (x1, x2); x = (x1a, x2a);\n        0 < x2 \\<and> x2 \\<le> length x1\\<rbrakk>\n       \\<Longrightarrow> 0 < x2a\n 3. \\<And>a a' aa a'a D Da x x' x1 x2 x1a x2a.\n       \\<lbrakk>(a, a') \\<in> br hmr_\\<alpha> hmr_invar;\n        (aa, a'a) \\<in> nat_rel;\n        \\<And>x x'.\n           (x, x')\n           \\<in> br hmr_\\<alpha> hmr_invar \\<times>\\<^sub>r\n                 nat_rel \\<Longrightarrow>\n           D x \\<le> \\<Down> (br hmr_\\<alpha> hmr_invar) (Da x');\n        (x, x') \\<in> br hmr_\\<alpha> hmr_invar \\<times>\\<^sub>r nat_rel;\n        x' = (x1, x2); x = (x1a, x2a);\n        0 < x2 \\<and> x2 \\<le> length x1\\<rbrakk>\n       \\<Longrightarrow> x2a \\<le> hm_length x1a\n 4. \\<And>a a' aa a'a D Da x x' x1 x2 x1a x2a.\n       \\<lbrakk>(a, a') \\<in> br hmr_\\<alpha> hmr_invar;\n        (aa, a'a) \\<in> nat_rel;\n        \\<And>x x'.\n           (x, x')\n           \\<in> br hmr_\\<alpha> hmr_invar \\<times>\\<^sub>r\n                 nat_rel \\<Longrightarrow>\n           D x \\<le> \\<Down> (br hmr_\\<alpha> hmr_invar) (Da x');\n        (x, x') \\<in> br hmr_\\<alpha> hmr_invar \\<times>\\<^sub>r nat_rel;\n        x' = (x1, x2); x = (x1a, x2a); 0 < x2 \\<and> x2 \\<le> length x1;\n        0 < x2a \\<and> x2a \\<le> hm_length x1a\\<rbrakk>\n       \\<Longrightarrow> (2 * x2a \\<le> hm_length x1a) =\n                         (2 * x2 \\<le> length x1)\n 5. \\<And>a a' aa a'a D Da x x' x1 x2 x1a x2a.\n       \\<lbrakk>(a, a') \\<in> br hmr_\\<alpha> hmr_invar;\n        (aa, a'a) \\<in> nat_rel;\n        \\<And>x x'.\n           (x, x')\n           \\<in> br hmr_\\<alpha> hmr_invar \\<times>\\<^sub>r\n                 nat_rel \\<Longrightarrow>\n           D x \\<le> \\<Down> (br hmr_\\<alpha> hmr_invar) (Da x');\n        (x, x') \\<in> br hmr_\\<alpha> hmr_invar \\<times>\\<^sub>r nat_rel;\n        x' = (x1, x2); x = (x1a, x2a); 0 < x2 \\<and> x2 \\<le> length x1;\n        0 < x2a \\<and> x2a \\<le> hm_length x1a; 2 * x2a \\<le> hm_length x1a;\n        2 * x2 \\<le> length x1\\<rbrakk>\n       \\<Longrightarrow> (x1a, x1) \\<in> br hmr_\\<alpha> hmr_invar\n 6. \\<And>a a' aa a'a D Da x x' x1 x2 x1a x2a.\n       \\<lbrakk>(a, a') \\<in> br hmr_\\<alpha> hmr_invar;\n        (aa, a'a) \\<in> nat_rel;\n        \\<And>x x'.\n           (x, x')\n           \\<in> br hmr_\\<alpha> hmr_invar \\<times>\\<^sub>r\n                 nat_rel \\<Longrightarrow>\n           D x \\<le> \\<Down> (br hmr_\\<alpha> hmr_invar) (Da x');\n        (x, x') \\<in> br hmr_\\<alpha> hmr_invar \\<times>\\<^sub>r nat_rel;\n        x' = (x1, x2); x = (x1a, x2a); 0 < x2 \\<and> x2 \\<le> length x1;\n        0 < x2a \\<and> x2a \\<le> hm_length x1a; 2 * x2a \\<le> hm_length x1a;\n        2 * x2 \\<le> length x1\\<rbrakk>\n       \\<Longrightarrow> (2 * x2a, 2 * x2) \\<in> nat_rel\n 7. \\<And>a a' aa a'a D Da x x' x1 x2 x1a x2a pj pja.\n       \\<lbrakk>(a, a') \\<in> br hmr_\\<alpha> hmr_invar;\n        (aa, a'a) \\<in> nat_rel;\n        \\<And>x x'.\n           (x, x')\n           \\<in> br hmr_\\<alpha> hmr_invar \\<times>\\<^sub>r\n                 nat_rel \\<Longrightarrow>\n           D x \\<le> \\<Down> (br hmr_\\<alpha> hmr_invar) (Da x');\n        (x, x') \\<in> br hmr_\\<alpha> hmr_invar \\<times>\\<^sub>r nat_rel;\n        x' = (x1, x2); x = (x1a, x2a); 0 < x2 \\<and> x2 \\<le> length x1;\n        0 < x2a \\<and> x2a \\<le> hm_length x1a; 2 * x2a \\<le> hm_length x1a;\n        2 * x2 \\<le> length x1; (pj, pja) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> (2 * x2a < hm_length x1a) = (2 * x2 < length x1)\n 8. \\<And>a a' aa a'a D Da x x' x1 x2 x1a x2a pj pja.\n       \\<lbrakk>(a, a') \\<in> br hmr_\\<alpha> hmr_invar;\n        (aa, a'a) \\<in> nat_rel;\n        \\<And>x x'.\n           (x, x')\n           \\<in> br hmr_\\<alpha> hmr_invar \\<times>\\<^sub>r\n                 nat_rel \\<Longrightarrow>\n           D x \\<le> \\<Down> (br hmr_\\<alpha> hmr_invar) (Da x');\n        (x, x') \\<in> br hmr_\\<alpha> hmr_invar \\<times>\\<^sub>r nat_rel;\n        x' = (x1, x2); x = (x1a, x2a); 0 < x2 \\<and> x2 \\<le> length x1;\n        0 < x2a \\<and> x2a \\<le> hm_length x1a; 2 * x2a \\<le> hm_length x1a;\n        2 * x2 \\<le> length x1; (pj, pja) \\<in> Id; 2 * x2a < hm_length x1a;\n        2 * x2 < length x1\\<rbrakk>\n       \\<Longrightarrow> (x1a, x1) \\<in> br hmr_\\<alpha> hmr_invar\n 9. \\<And>a a' aa a'a D Da x x' x1 x2 x1a x2a pj pja.\n       \\<lbrakk>(a, a') \\<in> br hmr_\\<alpha> hmr_invar;\n        (aa, a'a) \\<in> nat_rel;\n        \\<And>x x'.\n           (x, x')\n           \\<in> br hmr_\\<alpha> hmr_invar \\<times>\\<^sub>r\n                 nat_rel \\<Longrightarrow>\n           D x \\<le> \\<Down> (br hmr_\\<alpha> hmr_invar) (Da x');\n        (x, x') \\<in> br hmr_\\<alpha> hmr_invar \\<times>\\<^sub>r nat_rel;\n        x' = (x1, x2); x = (x1a, x2a); 0 < x2 \\<and> x2 \\<le> length x1;\n        0 < x2a \\<and> x2a \\<le> hm_length x1a; 2 * x2a \\<le> hm_length x1a;\n        2 * x2 \\<le> length x1; (pj, pja) \\<in> Id; 2 * x2a < hm_length x1a;\n        2 * x2 < length x1\\<rbrakk>\n       \\<Longrightarrow> (Suc (2 * x2a), Suc (2 * x2)) \\<in> nat_rel\n 10. \\<And>a a' aa a'a D Da x x' x1 x2 x1a x2a pj pja psj psja.\n        \\<lbrakk>(a, a') \\<in> br hmr_\\<alpha> hmr_invar;\n         (aa, a'a) \\<in> nat_rel;\n         \\<And>x x'.\n            (x, x')\n            \\<in> br hmr_\\<alpha> hmr_invar \\<times>\\<^sub>r\n                  nat_rel \\<Longrightarrow>\n            D x \\<le> \\<Down> (br hmr_\\<alpha> hmr_invar) (Da x');\n         (x, x') \\<in> br hmr_\\<alpha> hmr_invar \\<times>\\<^sub>r nat_rel;\n         x' = (x1, x2); x = (x1a, x2a); 0 < x2 \\<and> x2 \\<le> length x1;\n         0 < x2a \\<and> x2a \\<le> hm_length x1a;\n         2 * x2a \\<le> hm_length x1a; 2 * x2 \\<le> length x1;\n         (pj, pja) \\<in> Id; 2 * x2a < hm_length x1a; 2 * x2 < length x1;\n         (psj, psja) \\<in> Id\\<rbrakk>\n        \\<Longrightarrow> (psj < pj) = (psja < pja)\nA total of 22 subgoals...", "apply (clarsimp_all simp: in_br_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas hm_sink_op_refine'[refine] = hm_sink_op_refine[param_fo, THEN nres_relD]"], ["", "lemma hm_sink_op_nofail_imp_valid: \"nofail (hm_sink_op hm i) \\<Longrightarrow> hm_valid hm i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (hm_sink_op hm i) \\<Longrightarrow> hm_valid hm i", "unfolding hm_sink_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail\n     (REC\\<^sub>T\n       (\\<lambda>D (h, k).\n           ASSERT (0 < k \\<and> k \\<le> hm_length h) \\<bind>\n           (\\<lambda>_.\n               let len = hm_length h\n               in if 2 * k \\<le> len\n                  then let j = 2 * k\n                       in hm_prio_of_op h j \\<bind>\n                          (\\<lambda>pj.\n                              (if j < len\n                               then hm_prio_of_op h (Suc j) \\<bind>\n                                    (\\<lambda>psj.\n  if psj < pj then RETURN (j + 1) else RETURN j)\n                               else RETURN j) \\<bind>\n                              (\\<lambda>j.\n                                  hm_prio_of_op h j \\<bind>\n                                  (\\<lambda>pj.\nhm_prio_of_op h k \\<bind>\n(\\<lambda>pk.\n    if pj < pk then hm_exch_op h k j \\<bind> (\\<lambda>h. D (h, j))\n    else RETURN h))))\n                  else RETURN h))\n       (hm, i)) \\<Longrightarrow>\n    hm_valid hm i", "apply (subst (asm) RECT_unfold, refine_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail\n     (case (hm, i) of\n      (h, k) \\<Rightarrow>\n        ASSERT (0 < k \\<and> k \\<le> hm_length h) \\<bind>\n        (\\<lambda>_.\n            let len = hm_length h\n            in if 2 * k \\<le> len\n               then let j = 2 * k\n                    in hm_prio_of_op h j \\<bind>\n                       (\\<lambda>pj.\n                           (if j < len\n                            then hm_prio_of_op h (Suc j) \\<bind>\n                                 (\\<lambda>psj.\n                                     if psj < pj then RETURN (j + 1)\n                                     else RETURN j)\n                            else RETURN j) \\<bind>\n                           (\\<lambda>j.\n                               hm_prio_of_op h j \\<bind>\n                               (\\<lambda>pj.\n                                   hm_prio_of_op h k \\<bind>\n                                   (\\<lambda>pk.\n if pj < pk\n then hm_exch_op h k j \\<bind>\n      (\\<lambda>h.\n          REC\\<^sub>T\n           (\\<lambda>D (h, k).\n               ASSERT (0 < k \\<and> k \\<le> hm_length h) \\<bind>\n               (\\<lambda>_.\n                   let len = hm_length h\n                   in if 2 * k \\<le> len\n                      then let j = 2 * k\n                           in hm_prio_of_op h j \\<bind>\n                              (\\<lambda>pj.\n                                  (if j < len\n                                   then hm_prio_of_op h (Suc j) \\<bind>\n  (\\<lambda>psj. if psj < pj then RETURN (j + 1) else RETURN j)\n                                   else RETURN j) \\<bind>\n                                  (\\<lambda>j.\nhm_prio_of_op h j \\<bind>\n(\\<lambda>pj.\n    hm_prio_of_op h k \\<bind>\n    (\\<lambda>pk.\n        if pj < pk then hm_exch_op h k j \\<bind> (\\<lambda>h. D (h, j))\n        else RETURN h))))\n                      else RETURN h))\n           (h, j))\n else RETURN h))))\n               else RETURN h)) \\<Longrightarrow>\n    hm_valid hm i", "by (auto simp: refine_pw_simps hm_valid_def)"], ["", "lemma hm_sink_op_\\<alpha>_correct: \"hm_sink_op hm i \\<le>\\<^sub>n SPEC (\\<lambda>hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_sink_op hm i \\<le>\\<^sub>n\n    SPEC (\\<lambda>hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm)", "apply (rule leof_add_nofailI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (hm_sink_op hm i) \\<Longrightarrow>\n    hm_sink_op hm i \\<le>\\<^sub>n\n    SPEC (\\<lambda>hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm)", "apply (drule hm_sink_op_nofail_imp_valid)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_valid hm i \\<Longrightarrow>\n    hm_sink_op hm i \\<le>\\<^sub>n\n    SPEC (\\<lambda>hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm)", "unfolding hm_sink_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_valid hm i \\<Longrightarrow>\n    REC\\<^sub>T\n     (\\<lambda>D (h, k).\n         ASSERT (0 < k \\<and> k \\<le> hm_length h) \\<bind>\n         (\\<lambda>_.\n             let len = hm_length h\n             in if 2 * k \\<le> len\n                then let j = 2 * k\n                     in hm_prio_of_op h j \\<bind>\n                        (\\<lambda>pj.\n                            (if j < len\n                             then hm_prio_of_op h (Suc j) \\<bind>\n                                  (\\<lambda>psj.\nif psj < pj then RETURN (j + 1) else RETURN j)\n                             else RETURN j) \\<bind>\n                            (\\<lambda>j.\n                                hm_prio_of_op h j \\<bind>\n                                (\\<lambda>pj.\n                                    hm_prio_of_op h k \\<bind>\n                                    (\\<lambda>pk.\n  if pj < pk then hm_exch_op h k j \\<bind> (\\<lambda>h. D (h, j))\n  else RETURN h))))\n                else RETURN h))\n     (hm, i) \\<le>\\<^sub>n\n    SPEC (\\<lambda>hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm)", "apply (rule RECT_rule_leof[where \n            pre=\"\\<lambda>(hm',i). hm_valid hm' i \\<and> heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm \\<and> hm_length hm' = hm_length hm\"\n            and V = \"measure (\\<lambda>(hm',i). hm_length hm' - i)\"\n            ])"], ["proof (prove)\ngoal (3 subgoals):\n 1. hm_valid hm i \\<Longrightarrow>\n    wf (measure (\\<lambda>(hm', i). hm_length hm' - i))\n 2. hm_valid hm i \\<Longrightarrow>\n    case (hm, i) of\n    (hm', i) \\<Rightarrow>\n      hm_valid hm' i \\<and>\n      heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm \\<and>\n      hm_length hm' = hm_length hm\n 3. \\<And>f x.\n       \\<lbrakk>hm_valid hm i;\n        \\<And>x'.\n           \\<lbrakk>case x' of\n                    (hm', i) \\<Rightarrow>\n                      hm_valid hm' i \\<and>\n                      heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm \\<and>\n                      hm_length hm' = hm_length hm;\n            (x', x)\n            \\<in> measure (\\<lambda>(hm', i). hm_length hm' - i)\\<rbrakk>\n           \\<Longrightarrow> f x' \\<le>\\<^sub>n\n                             SPEC\n                              (\\<lambda>hm'.\n                                  heapmap_\\<alpha> hm' =\n                                  heapmap_\\<alpha> hm);\n        case x of\n        (hm', i) \\<Rightarrow>\n          hm_valid hm' i \\<and>\n          heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm \\<and>\n          hm_length hm' = hm_length hm;\n        REC\\<^sub>T\n         (\\<lambda>D a.\n             case a of\n             (h, k) \\<Rightarrow>\n               ASSERT (0 < k \\<and> k \\<le> hm_length h) \\<bind>\n               (\\<lambda>_.\n                   let len = hm_length h\n                   in if 2 * k \\<le> len\n                      then let j = 2 * k\n                           in hm_prio_of_op h j \\<bind>\n                              (\\<lambda>pj.\n                                  (if j < len\n                                   then hm_prio_of_op h (Suc j) \\<bind>\n  (\\<lambda>psj. if psj < pj then RETURN (j + 1) else RETURN j)\n                                   else RETURN j) \\<bind>\n                                  (\\<lambda>j.\nhm_prio_of_op h j \\<bind>\n(\\<lambda>pj.\n    hm_prio_of_op h k \\<bind>\n    (\\<lambda>pk.\n        if pj < pk then hm_exch_op h k j \\<bind> (\\<lambda>h. D (h, j))\n        else RETURN h))))\n                      else RETURN h)) =\n        f\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          (h, k) \\<Rightarrow>\n                            ASSERT\n                             (0 < k \\<and> k \\<le> hm_length h) \\<bind>\n                            (\\<lambda>_.\n                                let len = hm_length h\n                                in if 2 * k \\<le> len\n                                   then let j = 2 * k\n  in hm_prio_of_op h j \\<bind>\n     (\\<lambda>pj.\n         (if j < len\n          then hm_prio_of_op h (Suc j) \\<bind>\n               (\\<lambda>psj. if psj < pj then RETURN (j + 1) else RETURN j)\n          else RETURN j) \\<bind>\n         (\\<lambda>j.\n             hm_prio_of_op h j \\<bind>\n             (\\<lambda>pj.\n                 hm_prio_of_op h k \\<bind>\n                 (\\<lambda>pk.\n                     if pj < pk\n                     then hm_exch_op h k j \\<bind> (\\<lambda>h. f (h, j))\n                     else RETURN h))))\n                                   else RETURN h)) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>hm'.\n                              heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. hm_valid hm i \\<Longrightarrow>\n    case (hm, i) of\n    (hm', i) \\<Rightarrow>\n      hm_valid hm' i \\<and>\n      heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm \\<and>\n      hm_length hm' = hm_length hm\n 2. \\<And>f x.\n       \\<lbrakk>hm_valid hm i;\n        \\<And>x'.\n           \\<lbrakk>case x' of\n                    (hm', i) \\<Rightarrow>\n                      hm_valid hm' i \\<and>\n                      heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm \\<and>\n                      hm_length hm' = hm_length hm;\n            (x', x)\n            \\<in> measure (\\<lambda>(hm', i). hm_length hm' - i)\\<rbrakk>\n           \\<Longrightarrow> f x' \\<le>\\<^sub>n\n                             SPEC\n                              (\\<lambda>hm'.\n                                  heapmap_\\<alpha> hm' =\n                                  heapmap_\\<alpha> hm);\n        case x of\n        (hm', i) \\<Rightarrow>\n          hm_valid hm' i \\<and>\n          heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm \\<and>\n          hm_length hm' = hm_length hm;\n        REC\\<^sub>T\n         (\\<lambda>D a.\n             case a of\n             (h, k) \\<Rightarrow>\n               ASSERT (0 < k \\<and> k \\<le> hm_length h) \\<bind>\n               (\\<lambda>_.\n                   let len = hm_length h\n                   in if 2 * k \\<le> len\n                      then let j = 2 * k\n                           in hm_prio_of_op h j \\<bind>\n                              (\\<lambda>pj.\n                                  (if j < len\n                                   then hm_prio_of_op h (Suc j) \\<bind>\n  (\\<lambda>psj. if psj < pj then RETURN (j + 1) else RETURN j)\n                                   else RETURN j) \\<bind>\n                                  (\\<lambda>j.\nhm_prio_of_op h j \\<bind>\n(\\<lambda>pj.\n    hm_prio_of_op h k \\<bind>\n    (\\<lambda>pk.\n        if pj < pk then hm_exch_op h k j \\<bind> (\\<lambda>h. D (h, j))\n        else RETURN h))))\n                      else RETURN h)) =\n        f\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          (h, k) \\<Rightarrow>\n                            ASSERT\n                             (0 < k \\<and> k \\<le> hm_length h) \\<bind>\n                            (\\<lambda>_.\n                                let len = hm_length h\n                                in if 2 * k \\<le> len\n                                   then let j = 2 * k\n  in hm_prio_of_op h j \\<bind>\n     (\\<lambda>pj.\n         (if j < len\n          then hm_prio_of_op h (Suc j) \\<bind>\n               (\\<lambda>psj. if psj < pj then RETURN (j + 1) else RETURN j)\n          else RETURN j) \\<bind>\n         (\\<lambda>j.\n             hm_prio_of_op h j \\<bind>\n             (\\<lambda>pj.\n                 hm_prio_of_op h k \\<bind>\n                 (\\<lambda>pk.\n                     if pj < pk\n                     then hm_exch_op h k j \\<bind> (\\<lambda>h. f (h, j))\n                     else RETURN h))))\n                                   else RETURN h)) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>hm'.\n                              heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f x.\n       \\<lbrakk>hm_valid hm i;\n        \\<And>x'.\n           \\<lbrakk>case x' of\n                    (hm', i) \\<Rightarrow>\n                      hm_valid hm' i \\<and>\n                      heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm \\<and>\n                      hm_length hm' = hm_length hm;\n            (x', x)\n            \\<in> measure (\\<lambda>(hm', i). hm_length hm' - i)\\<rbrakk>\n           \\<Longrightarrow> f x' \\<le>\\<^sub>n\n                             SPEC\n                              (\\<lambda>hm'.\n                                  heapmap_\\<alpha> hm' =\n                                  heapmap_\\<alpha> hm);\n        case x of\n        (hm', i) \\<Rightarrow>\n          hm_valid hm' i \\<and>\n          heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm \\<and>\n          hm_length hm' = hm_length hm;\n        REC\\<^sub>T\n         (\\<lambda>D a.\n             case a of\n             (h, k) \\<Rightarrow>\n               ASSERT (0 < k \\<and> k \\<le> hm_length h) \\<bind>\n               (\\<lambda>_.\n                   let len = hm_length h\n                   in if 2 * k \\<le> len\n                      then let j = 2 * k\n                           in hm_prio_of_op h j \\<bind>\n                              (\\<lambda>pj.\n                                  (if j < len\n                                   then hm_prio_of_op h (Suc j) \\<bind>\n  (\\<lambda>psj. if psj < pj then RETURN (j + 1) else RETURN j)\n                                   else RETURN j) \\<bind>\n                                  (\\<lambda>j.\nhm_prio_of_op h j \\<bind>\n(\\<lambda>pj.\n    hm_prio_of_op h k \\<bind>\n    (\\<lambda>pk.\n        if pj < pk then hm_exch_op h k j \\<bind> (\\<lambda>h. D (h, j))\n        else RETURN h))))\n                      else RETURN h)) =\n        f\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          (h, k) \\<Rightarrow>\n                            ASSERT\n                             (0 < k \\<and> k \\<le> hm_length h) \\<bind>\n                            (\\<lambda>_.\n                                let len = hm_length h\n                                in if 2 * k \\<le> len\n                                   then let j = 2 * k\n  in hm_prio_of_op h j \\<bind>\n     (\\<lambda>pj.\n         (if j < len\n          then hm_prio_of_op h (Suc j) \\<bind>\n               (\\<lambda>psj. if psj < pj then RETURN (j + 1) else RETURN j)\n          else RETURN j) \\<bind>\n         (\\<lambda>j.\n             hm_prio_of_op h j \\<bind>\n             (\\<lambda>pj.\n                 hm_prio_of_op h k \\<bind>\n                 (\\<lambda>pk.\n                     if pj < pk\n                     then hm_exch_op h k j \\<bind> (\\<lambda>h. f (h, j))\n                     else RETURN h))))\n                                   else RETURN h)) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>hm'.\n                              heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm)", "unfolding hm_prio_of_op_def hm_val_of_op_def hm_exch_op_def \n        hm_key_of_op_def hm_the_lookup_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f x.\n       \\<lbrakk>hm_valid hm i;\n        \\<And>x'.\n           \\<lbrakk>case x' of\n                    (hm', i) \\<Rightarrow>\n                      hm_valid hm' i \\<and>\n                      heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm \\<and>\n                      hm_length hm' = hm_length hm;\n            (x', x)\n            \\<in> measure (\\<lambda>(hm', i). hm_length hm' - i)\\<rbrakk>\n           \\<Longrightarrow> f x' \\<le>\\<^sub>n\n                             SPEC\n                              (\\<lambda>hm'.\n                                  heapmap_\\<alpha> hm' =\n                                  heapmap_\\<alpha> hm);\n        case x of\n        (hm', i) \\<Rightarrow>\n          hm_valid hm' i \\<and>\n          heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm \\<and>\n          hm_length hm' = hm_length hm;\n        REC\\<^sub>T\n         (\\<lambda>D a.\n             case a of\n             (h, k) \\<Rightarrow>\n               ASSERT (0 < k \\<and> k \\<le> hm_length h) \\<bind>\n               (\\<lambda>_.\n                   let len = hm_length h\n                   in if 2 * k \\<le> len\n                      then let j = 2 * k\n                           in (case h of\n                               (pq, m) \\<Rightarrow>\n                                 \\<lambda>i.\n                                    ASSERT (0 < i) \\<bind>\n                                    (\\<lambda>_. mop_list_get pq (i - 1)))\n                               j \\<bind>\n                              (\\<lambda>k.\n                                  ASSERT\n                                   (heapmap_\\<alpha> h k \\<noteq>\n                                    None \\<and>\n                                    hmr_invar h) \\<bind>\n                                  (\\<lambda>_.\nRETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                                  RETURN) \\<bind>\n                              (\\<lambda>v. RETURN (prio v)) \\<bind>\n                              (\\<lambda>pj.\n                                  (if j < len\n                                   then (case h of\n   (pq, m) \\<Rightarrow>\n     \\<lambda>i.\n        ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_get pq (i - 1)))\n   (Suc j) \\<bind>\n  (\\<lambda>k.\n      ASSERT (heapmap_\\<alpha> h k \\<noteq> None \\<and> hmr_invar h) \\<bind>\n      (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n      RETURN) \\<bind>\n  (\\<lambda>v. RETURN (prio v)) \\<bind>\n  (\\<lambda>psj. if psj < pj then RETURN (j + 1) else RETURN j)\n                                   else RETURN j) \\<bind>\n                                  (\\<lambda>j.\n(case h of\n (pq, m) \\<Rightarrow>\n   \\<lambda>i. ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_get pq (i - 1)))\n j \\<bind>\n(\\<lambda>k.\n    ASSERT (heapmap_\\<alpha> h k \\<noteq> None \\<and> hmr_invar h) \\<bind>\n    (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n    RETURN) \\<bind>\n(\\<lambda>v. RETURN (prio v)) \\<bind>\n(\\<lambda>pj.\n    (case h of\n     (pq, m) \\<Rightarrow>\n       \\<lambda>i.\n          ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_get pq (i - 1)))\n     k \\<bind>\n    (\\<lambda>k.\n        ASSERT\n         (heapmap_\\<alpha> h k \\<noteq> None \\<and> hmr_invar h) \\<bind>\n        (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n        RETURN) \\<bind>\n    (\\<lambda>v. RETURN (prio v)) \\<bind>\n    (\\<lambda>pk.\n        if pj < pk\n        then (case h of\n              (pq, m) \\<Rightarrow>\n                \\<lambda>i j.\n                   ASSERT (hm_valid (pq, m) i) \\<bind>\n                   (\\<lambda>_.\n                       ASSERT (hm_valid (pq, m) j) \\<bind>\n                       (\\<lambda>_.\n                           ASSERT (hmr_invar (pq, m)) \\<bind>\n                           (\\<lambda>_.\n                               mop_list_swap pq (i - 1) (j - 1) \\<bind>\n                               (\\<lambda>pq. RETURN (pq, m))))))\n              k j \\<bind>\n             (\\<lambda>h. D (h, j))\n        else RETURN h))))\n                      else RETURN h)) =\n        f\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          (h, k) \\<Rightarrow>\n                            ASSERT\n                             (0 < k \\<and> k \\<le> hm_length h) \\<bind>\n                            (\\<lambda>_.\n                                let len = hm_length h\n                                in if 2 * k \\<le> len\n                                   then let j = 2 * k\n  in (case h of\n      (pq, m) \\<Rightarrow>\n        \\<lambda>i.\n           ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_get pq (i - 1)))\n      j \\<bind>\n     (\\<lambda>k.\n         ASSERT\n          (heapmap_\\<alpha> h k \\<noteq> None \\<and> hmr_invar h) \\<bind>\n         (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n         RETURN) \\<bind>\n     (\\<lambda>v. RETURN (prio v)) \\<bind>\n     (\\<lambda>pj.\n         (if j < len\n          then (case h of\n                (pq, m) \\<Rightarrow>\n                  \\<lambda>i.\n                     ASSERT (0 < i) \\<bind>\n                     (\\<lambda>_. mop_list_get pq (i - 1)))\n                (Suc j) \\<bind>\n               (\\<lambda>k.\n                   ASSERT\n                    (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                     hmr_invar h) \\<bind>\n                   (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                   RETURN) \\<bind>\n               (\\<lambda>v. RETURN (prio v)) \\<bind>\n               (\\<lambda>psj. if psj < pj then RETURN (j + 1) else RETURN j)\n          else RETURN j) \\<bind>\n         (\\<lambda>j.\n             (case h of\n              (pq, m) \\<Rightarrow>\n                \\<lambda>i.\n                   ASSERT (0 < i) \\<bind>\n                   (\\<lambda>_. mop_list_get pq (i - 1)))\n              j \\<bind>\n             (\\<lambda>k.\n                 ASSERT\n                  (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                   hmr_invar h) \\<bind>\n                 (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                 RETURN) \\<bind>\n             (\\<lambda>v. RETURN (prio v)) \\<bind>\n             (\\<lambda>pj.\n                 (case h of\n                  (pq, m) \\<Rightarrow>\n                    \\<lambda>i.\n                       ASSERT (0 < i) \\<bind>\n                       (\\<lambda>_. mop_list_get pq (i - 1)))\n                  k \\<bind>\n                 (\\<lambda>k.\n                     ASSERT\n                      (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                       hmr_invar h) \\<bind>\n                     (\\<lambda>_.\n                         RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                     RETURN) \\<bind>\n                 (\\<lambda>v. RETURN (prio v)) \\<bind>\n                 (\\<lambda>pk.\n                     if pj < pk\n                     then (case h of\n                           (pq, m) \\<Rightarrow>\n                             \\<lambda>i j.\n                                ASSERT (hm_valid (pq, m) i) \\<bind>\n                                (\\<lambda>_.\n                                    ASSERT (hm_valid (pq, m) j) \\<bind>\n                                    (\\<lambda>_.\n  ASSERT (hmr_invar (pq, m)) \\<bind>\n  (\\<lambda>_.\n      mop_list_swap pq (i - 1) (j - 1) \\<bind>\n      (\\<lambda>pq. RETURN (pq, m))))))\n                           k j \\<bind>\n                          (\\<lambda>h. f (h, j))\n                     else RETURN h))))\n                                   else RETURN h)) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>hm'.\n                              heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm)", "apply (refine_vcg)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>f x x1 x1a x2 x1b x2a x2b.\n       \\<lbrakk>hm_valid hm i;\n        \\<And>x'.\n           \\<lbrakk>case x' of\n                    (hm', i) \\<Rightarrow>\n                      hm_valid hm' i \\<and>\n                      heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm \\<and>\n                      hm_length hm' = hm_length hm;\n            (x', x)\n            \\<in> measure (\\<lambda>(hm', i). hm_length hm' - i)\\<rbrakk>\n           \\<Longrightarrow> f x' \\<le>\\<^sub>n\n                             SPEC\n                              (\\<lambda>hm'.\n                                  heapmap_\\<alpha> hm' =\n                                  heapmap_\\<alpha> hm);\n        case x of\n        (hm', i) \\<Rightarrow>\n          hm_valid hm' i \\<and>\n          heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm \\<and>\n          hm_length hm' = hm_length hm;\n        REC\\<^sub>T\n         (\\<lambda>D a.\n             case a of\n             (h, k) \\<Rightarrow>\n               ASSERT (0 < k \\<and> k \\<le> hm_length h) \\<bind>\n               (\\<lambda>_.\n                   let len = hm_length h\n                   in if 2 * k \\<le> len\n                      then let j = 2 * k\n                           in (case h of\n                               (pq, m) \\<Rightarrow>\n                                 \\<lambda>i.\n                                    ASSERT (0 < i) \\<bind>\n                                    (\\<lambda>_. mop_list_get pq (i - 1)))\n                               j \\<bind>\n                              (\\<lambda>k.\n                                  ASSERT\n                                   (heapmap_\\<alpha> h k \\<noteq>\n                                    None \\<and>\n                                    hmr_invar h) \\<bind>\n                                  (\\<lambda>_.\nRETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                                  RETURN) \\<bind>\n                              (\\<lambda>v. RETURN (prio v)) \\<bind>\n                              (\\<lambda>pj.\n                                  (if j < len\n                                   then (case h of\n   (pq, m) \\<Rightarrow>\n     \\<lambda>i.\n        ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_get pq (i - 1)))\n   (Suc j) \\<bind>\n  (\\<lambda>k.\n      ASSERT (heapmap_\\<alpha> h k \\<noteq> None \\<and> hmr_invar h) \\<bind>\n      (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n      RETURN) \\<bind>\n  (\\<lambda>v. RETURN (prio v)) \\<bind>\n  (\\<lambda>psj. if psj < pj then RETURN (j + 1) else RETURN j)\n                                   else RETURN j) \\<bind>\n                                  (\\<lambda>j.\n(case h of\n (pq, m) \\<Rightarrow>\n   \\<lambda>i. ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_get pq (i - 1)))\n j \\<bind>\n(\\<lambda>k.\n    ASSERT (heapmap_\\<alpha> h k \\<noteq> None \\<and> hmr_invar h) \\<bind>\n    (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n    RETURN) \\<bind>\n(\\<lambda>v. RETURN (prio v)) \\<bind>\n(\\<lambda>pj.\n    (case h of\n     (pq, m) \\<Rightarrow>\n       \\<lambda>i.\n          ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_get pq (i - 1)))\n     k \\<bind>\n    (\\<lambda>k.\n        ASSERT\n         (heapmap_\\<alpha> h k \\<noteq> None \\<and> hmr_invar h) \\<bind>\n        (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n        RETURN) \\<bind>\n    (\\<lambda>v. RETURN (prio v)) \\<bind>\n    (\\<lambda>pk.\n        if pj < pk\n        then (case h of\n              (pq, m) \\<Rightarrow>\n                \\<lambda>i j.\n                   ASSERT (hm_valid (pq, m) i) \\<bind>\n                   (\\<lambda>_.\n                       ASSERT (hm_valid (pq, m) j) \\<bind>\n                       (\\<lambda>_.\n                           ASSERT (hmr_invar (pq, m)) \\<bind>\n                           (\\<lambda>_.\n                               mop_list_swap pq (i - 1) (j - 1) \\<bind>\n                               (\\<lambda>pq. RETURN (pq, m))))))\n              k j \\<bind>\n             (\\<lambda>h. D (h, j))\n        else RETURN h))))\n                      else RETURN h)) =\n        f;\n        x1 = (x1a, x2); x1 = (x1b, x2a); x = (x1, x2b);\n        0 < x2b \\<and> x2b \\<le> hm_length x1; 2 * x2b \\<le> hm_length x1;\n        0 < 2 * x2b; 2 * x2b - 1 < length x1b;\n        heapmap_\\<alpha> x1 (x1b ! (2 * x2b - 1)) \\<noteq> None \\<and>\n        hmr_invar x1;\n        2 * x2b < hm_length x1; 0 < Suc (2 * x2b);\n        Suc (2 * x2b) - 1 < length x1b;\n        heapmap_\\<alpha> x1 (x1b ! (Suc (2 * x2b) - 1)) \\<noteq> None \\<and>\n        hmr_invar x1;\n        prio (the (heapmap_\\<alpha> x1 (x1b ! (Suc (2 * x2b) - 1))))\n        < prio (the (heapmap_\\<alpha> x1 (x1b ! (2 * x2b - 1))));\n        0 < 2 * x2b + 1; 2 * x2b + 1 - 1 < length x1b;\n        heapmap_\\<alpha> x1 (x1b ! (2 * x2b + 1 - 1)) \\<noteq> None \\<and>\n        hmr_invar x1;\n        0 < x2b; x2b - 1 < length x1b;\n        heapmap_\\<alpha> x1 (x1b ! (x2b - 1)) \\<noteq> None \\<and>\n        hmr_invar x1;\n        prio (the (heapmap_\\<alpha> x1 (x1b ! (2 * x2b + 1 - 1))))\n        < prio (the (heapmap_\\<alpha> x1 (x1b ! (x2b - 1))));\n        hm_valid (x1a, x2) x2b; hm_valid (x1a, x2) (2 * x2b + 1);\n        hmr_invar (x1a, x2);\n        x2b - 1 < length x1a \\<and> 2 * x2b + 1 - 1 < length x1a\\<rbrakk>\n       \\<Longrightarrow> f ((swap x1a (x2b - 1) (2 * x2b + 1 - 1), x2),\n                            2 * x2b + 1) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>hm'.\n                              heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm)\n 2. \\<And>f x x1 x1a x2 x1b x2a x2b.\n       \\<lbrakk>hm_valid hm i;\n        \\<And>x'.\n           \\<lbrakk>case x' of\n                    (hm', i) \\<Rightarrow>\n                      hm_valid hm' i \\<and>\n                      heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm \\<and>\n                      hm_length hm' = hm_length hm;\n            (x', x)\n            \\<in> measure (\\<lambda>(hm', i). hm_length hm' - i)\\<rbrakk>\n           \\<Longrightarrow> f x' \\<le>\\<^sub>n\n                             SPEC\n                              (\\<lambda>hm'.\n                                  heapmap_\\<alpha> hm' =\n                                  heapmap_\\<alpha> hm);\n        case x of\n        (hm', i) \\<Rightarrow>\n          hm_valid hm' i \\<and>\n          heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm \\<and>\n          hm_length hm' = hm_length hm;\n        REC\\<^sub>T\n         (\\<lambda>D a.\n             case a of\n             (h, k) \\<Rightarrow>\n               ASSERT (0 < k \\<and> k \\<le> hm_length h) \\<bind>\n               (\\<lambda>_.\n                   let len = hm_length h\n                   in if 2 * k \\<le> len\n                      then let j = 2 * k\n                           in (case h of\n                               (pq, m) \\<Rightarrow>\n                                 \\<lambda>i.\n                                    ASSERT (0 < i) \\<bind>\n                                    (\\<lambda>_. mop_list_get pq (i - 1)))\n                               j \\<bind>\n                              (\\<lambda>k.\n                                  ASSERT\n                                   (heapmap_\\<alpha> h k \\<noteq>\n                                    None \\<and>\n                                    hmr_invar h) \\<bind>\n                                  (\\<lambda>_.\nRETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                                  RETURN) \\<bind>\n                              (\\<lambda>v. RETURN (prio v)) \\<bind>\n                              (\\<lambda>pj.\n                                  (if j < len\n                                   then (case h of\n   (pq, m) \\<Rightarrow>\n     \\<lambda>i.\n        ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_get pq (i - 1)))\n   (Suc j) \\<bind>\n  (\\<lambda>k.\n      ASSERT (heapmap_\\<alpha> h k \\<noteq> None \\<and> hmr_invar h) \\<bind>\n      (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n      RETURN) \\<bind>\n  (\\<lambda>v. RETURN (prio v)) \\<bind>\n  (\\<lambda>psj. if psj < pj then RETURN (j + 1) else RETURN j)\n                                   else RETURN j) \\<bind>\n                                  (\\<lambda>j.\n(case h of\n (pq, m) \\<Rightarrow>\n   \\<lambda>i. ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_get pq (i - 1)))\n j \\<bind>\n(\\<lambda>k.\n    ASSERT (heapmap_\\<alpha> h k \\<noteq> None \\<and> hmr_invar h) \\<bind>\n    (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n    RETURN) \\<bind>\n(\\<lambda>v. RETURN (prio v)) \\<bind>\n(\\<lambda>pj.\n    (case h of\n     (pq, m) \\<Rightarrow>\n       \\<lambda>i.\n          ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_get pq (i - 1)))\n     k \\<bind>\n    (\\<lambda>k.\n        ASSERT\n         (heapmap_\\<alpha> h k \\<noteq> None \\<and> hmr_invar h) \\<bind>\n        (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n        RETURN) \\<bind>\n    (\\<lambda>v. RETURN (prio v)) \\<bind>\n    (\\<lambda>pk.\n        if pj < pk\n        then (case h of\n              (pq, m) \\<Rightarrow>\n                \\<lambda>i j.\n                   ASSERT (hm_valid (pq, m) i) \\<bind>\n                   (\\<lambda>_.\n                       ASSERT (hm_valid (pq, m) j) \\<bind>\n                       (\\<lambda>_.\n                           ASSERT (hmr_invar (pq, m)) \\<bind>\n                           (\\<lambda>_.\n                               mop_list_swap pq (i - 1) (j - 1) \\<bind>\n                               (\\<lambda>pq. RETURN (pq, m))))))\n              k j \\<bind>\n             (\\<lambda>h. D (h, j))\n        else RETURN h))))\n                      else RETURN h)) =\n        f;\n        x1 = (x1a, x2); x1 = (x1b, x2a); x = (x1, x2b);\n        0 < x2b \\<and> x2b \\<le> hm_length x1; 2 * x2b \\<le> hm_length x1;\n        0 < 2 * x2b; 2 * x2b - 1 < length x1b;\n        heapmap_\\<alpha> x1 (x1b ! (2 * x2b - 1)) \\<noteq> None \\<and>\n        hmr_invar x1;\n        2 * x2b < hm_length x1; 0 < Suc (2 * x2b);\n        Suc (2 * x2b) - 1 < length x1b;\n        heapmap_\\<alpha> x1 (x1b ! (Suc (2 * x2b) - 1)) \\<noteq> None \\<and>\n        hmr_invar x1;\n        prio (the (heapmap_\\<alpha> x1 (x1b ! (Suc (2 * x2b) - 1))))\n        < prio (the (heapmap_\\<alpha> x1 (x1b ! (2 * x2b - 1))));\n        0 < 2 * x2b + 1; 2 * x2b + 1 - 1 < length x1b;\n        heapmap_\\<alpha> x1 (x1b ! (2 * x2b + 1 - 1)) \\<noteq> None \\<and>\n        hmr_invar x1;\n        0 < x2b; x2b - 1 < length x1b;\n        heapmap_\\<alpha> x1 (x1b ! (x2b - 1)) \\<noteq> None \\<and>\n        hmr_invar x1;\n        \\<not> prio (the (heapmap_\\<alpha> x1 (x1b ! (2 * x2b + 1 - 1))))\n               < prio (the (heapmap_\\<alpha> x1 (x1b ! (x2b - 1))))\\<rbrakk>\n       \\<Longrightarrow> heapmap_\\<alpha> x1 = heapmap_\\<alpha> hm\n 3. \\<And>f x x1 x1a x2 x1b x2a x2b.\n       \\<lbrakk>hm_valid hm i;\n        \\<And>x'.\n           \\<lbrakk>case x' of\n                    (hm', i) \\<Rightarrow>\n                      hm_valid hm' i \\<and>\n                      heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm \\<and>\n                      hm_length hm' = hm_length hm;\n            (x', x)\n            \\<in> measure (\\<lambda>(hm', i). hm_length hm' - i)\\<rbrakk>\n           \\<Longrightarrow> f x' \\<le>\\<^sub>n\n                             SPEC\n                              (\\<lambda>hm'.\n                                  heapmap_\\<alpha> hm' =\n                                  heapmap_\\<alpha> hm);\n        case x of\n        (hm', i) \\<Rightarrow>\n          hm_valid hm' i \\<and>\n          heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm \\<and>\n          hm_length hm' = hm_length hm;\n        REC\\<^sub>T\n         (\\<lambda>D a.\n             case a of\n             (h, k) \\<Rightarrow>\n               ASSERT (0 < k \\<and> k \\<le> hm_length h) \\<bind>\n               (\\<lambda>_.\n                   let len = hm_length h\n                   in if 2 * k \\<le> len\n                      then let j = 2 * k\n                           in (case h of\n                               (pq, m) \\<Rightarrow>\n                                 \\<lambda>i.\n                                    ASSERT (0 < i) \\<bind>\n                                    (\\<lambda>_. mop_list_get pq (i - 1)))\n                               j \\<bind>\n                              (\\<lambda>k.\n                                  ASSERT\n                                   (heapmap_\\<alpha> h k \\<noteq>\n                                    None \\<and>\n                                    hmr_invar h) \\<bind>\n                                  (\\<lambda>_.\nRETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                                  RETURN) \\<bind>\n                              (\\<lambda>v. RETURN (prio v)) \\<bind>\n                              (\\<lambda>pj.\n                                  (if j < len\n                                   then (case h of\n   (pq, m) \\<Rightarrow>\n     \\<lambda>i.\n        ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_get pq (i - 1)))\n   (Suc j) \\<bind>\n  (\\<lambda>k.\n      ASSERT (heapmap_\\<alpha> h k \\<noteq> None \\<and> hmr_invar h) \\<bind>\n      (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n      RETURN) \\<bind>\n  (\\<lambda>v. RETURN (prio v)) \\<bind>\n  (\\<lambda>psj. if psj < pj then RETURN (j + 1) else RETURN j)\n                                   else RETURN j) \\<bind>\n                                  (\\<lambda>j.\n(case h of\n (pq, m) \\<Rightarrow>\n   \\<lambda>i. ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_get pq (i - 1)))\n j \\<bind>\n(\\<lambda>k.\n    ASSERT (heapmap_\\<alpha> h k \\<noteq> None \\<and> hmr_invar h) \\<bind>\n    (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n    RETURN) \\<bind>\n(\\<lambda>v. RETURN (prio v)) \\<bind>\n(\\<lambda>pj.\n    (case h of\n     (pq, m) \\<Rightarrow>\n       \\<lambda>i.\n          ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_get pq (i - 1)))\n     k \\<bind>\n    (\\<lambda>k.\n        ASSERT\n         (heapmap_\\<alpha> h k \\<noteq> None \\<and> hmr_invar h) \\<bind>\n        (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n        RETURN) \\<bind>\n    (\\<lambda>v. RETURN (prio v)) \\<bind>\n    (\\<lambda>pk.\n        if pj < pk\n        then (case h of\n              (pq, m) \\<Rightarrow>\n                \\<lambda>i j.\n                   ASSERT (hm_valid (pq, m) i) \\<bind>\n                   (\\<lambda>_.\n                       ASSERT (hm_valid (pq, m) j) \\<bind>\n                       (\\<lambda>_.\n                           ASSERT (hmr_invar (pq, m)) \\<bind>\n                           (\\<lambda>_.\n                               mop_list_swap pq (i - 1) (j - 1) \\<bind>\n                               (\\<lambda>pq. RETURN (pq, m))))))\n              k j \\<bind>\n             (\\<lambda>h. D (h, j))\n        else RETURN h))))\n                      else RETURN h)) =\n        f;\n        x1 = (x1a, x2); x1 = (x1b, x2a); x = (x1, x2b);\n        0 < x2b \\<and> x2b \\<le> hm_length x1; 2 * x2b \\<le> hm_length x1;\n        0 < 2 * x2b; 2 * x2b - 1 < length x1b;\n        heapmap_\\<alpha> x1 (x1b ! (2 * x2b - 1)) \\<noteq> None \\<and>\n        hmr_invar x1;\n        2 * x2b < hm_length x1; 0 < Suc (2 * x2b);\n        Suc (2 * x2b) - 1 < length x1b;\n        heapmap_\\<alpha> x1 (x1b ! (Suc (2 * x2b) - 1)) \\<noteq> None \\<and>\n        hmr_invar x1;\n        \\<not> prio (the (heapmap_\\<alpha> x1 (x1b ! (Suc (2 * x2b) - 1))))\n               < prio (the (heapmap_\\<alpha> x1 (x1b ! (2 * x2b - 1))));\n        0 < 2 * x2b; 2 * x2b - 1 < length x1b;\n        heapmap_\\<alpha> x1 (x1b ! (2 * x2b - 1)) \\<noteq> None \\<and>\n        hmr_invar x1;\n        0 < x2b; x2b - 1 < length x1b;\n        heapmap_\\<alpha> x1 (x1b ! (x2b - 1)) \\<noteq> None \\<and>\n        hmr_invar x1;\n        prio (the (heapmap_\\<alpha> x1 (x1b ! (2 * x2b - 1))))\n        < prio (the (heapmap_\\<alpha> x1 (x1b ! (x2b - 1))));\n        hm_valid (x1a, x2) x2b; hm_valid (x1a, x2) (2 * x2b);\n        hmr_invar (x1a, x2);\n        x2b - 1 < length x1a \\<and> 2 * x2b - 1 < length x1a\\<rbrakk>\n       \\<Longrightarrow> f ((swap x1a (x2b - 1) (2 * x2b - 1), x2),\n                            2 * x2b) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>hm'.\n                              heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm)\n 4. \\<And>f x x1 x1a x2 x1b x2a x2b.\n       \\<lbrakk>hm_valid hm i;\n        \\<And>x'.\n           \\<lbrakk>case x' of\n                    (hm', i) \\<Rightarrow>\n                      hm_valid hm' i \\<and>\n                      heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm \\<and>\n                      hm_length hm' = hm_length hm;\n            (x', x)\n            \\<in> measure (\\<lambda>(hm', i). hm_length hm' - i)\\<rbrakk>\n           \\<Longrightarrow> f x' \\<le>\\<^sub>n\n                             SPEC\n                              (\\<lambda>hm'.\n                                  heapmap_\\<alpha> hm' =\n                                  heapmap_\\<alpha> hm);\n        case x of\n        (hm', i) \\<Rightarrow>\n          hm_valid hm' i \\<and>\n          heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm \\<and>\n          hm_length hm' = hm_length hm;\n        REC\\<^sub>T\n         (\\<lambda>D a.\n             case a of\n             (h, k) \\<Rightarrow>\n               ASSERT (0 < k \\<and> k \\<le> hm_length h) \\<bind>\n               (\\<lambda>_.\n                   let len = hm_length h\n                   in if 2 * k \\<le> len\n                      then let j = 2 * k\n                           in (case h of\n                               (pq, m) \\<Rightarrow>\n                                 \\<lambda>i.\n                                    ASSERT (0 < i) \\<bind>\n                                    (\\<lambda>_. mop_list_get pq (i - 1)))\n                               j \\<bind>\n                              (\\<lambda>k.\n                                  ASSERT\n                                   (heapmap_\\<alpha> h k \\<noteq>\n                                    None \\<and>\n                                    hmr_invar h) \\<bind>\n                                  (\\<lambda>_.\nRETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                                  RETURN) \\<bind>\n                              (\\<lambda>v. RETURN (prio v)) \\<bind>\n                              (\\<lambda>pj.\n                                  (if j < len\n                                   then (case h of\n   (pq, m) \\<Rightarrow>\n     \\<lambda>i.\n        ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_get pq (i - 1)))\n   (Suc j) \\<bind>\n  (\\<lambda>k.\n      ASSERT (heapmap_\\<alpha> h k \\<noteq> None \\<and> hmr_invar h) \\<bind>\n      (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n      RETURN) \\<bind>\n  (\\<lambda>v. RETURN (prio v)) \\<bind>\n  (\\<lambda>psj. if psj < pj then RETURN (j + 1) else RETURN j)\n                                   else RETURN j) \\<bind>\n                                  (\\<lambda>j.\n(case h of\n (pq, m) \\<Rightarrow>\n   \\<lambda>i. ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_get pq (i - 1)))\n j \\<bind>\n(\\<lambda>k.\n    ASSERT (heapmap_\\<alpha> h k \\<noteq> None \\<and> hmr_invar h) \\<bind>\n    (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n    RETURN) \\<bind>\n(\\<lambda>v. RETURN (prio v)) \\<bind>\n(\\<lambda>pj.\n    (case h of\n     (pq, m) \\<Rightarrow>\n       \\<lambda>i.\n          ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_get pq (i - 1)))\n     k \\<bind>\n    (\\<lambda>k.\n        ASSERT\n         (heapmap_\\<alpha> h k \\<noteq> None \\<and> hmr_invar h) \\<bind>\n        (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n        RETURN) \\<bind>\n    (\\<lambda>v. RETURN (prio v)) \\<bind>\n    (\\<lambda>pk.\n        if pj < pk\n        then (case h of\n              (pq, m) \\<Rightarrow>\n                \\<lambda>i j.\n                   ASSERT (hm_valid (pq, m) i) \\<bind>\n                   (\\<lambda>_.\n                       ASSERT (hm_valid (pq, m) j) \\<bind>\n                       (\\<lambda>_.\n                           ASSERT (hmr_invar (pq, m)) \\<bind>\n                           (\\<lambda>_.\n                               mop_list_swap pq (i - 1) (j - 1) \\<bind>\n                               (\\<lambda>pq. RETURN (pq, m))))))\n              k j \\<bind>\n             (\\<lambda>h. D (h, j))\n        else RETURN h))))\n                      else RETURN h)) =\n        f;\n        x1 = (x1a, x2); x1 = (x1b, x2a); x = (x1, x2b);\n        0 < x2b \\<and> x2b \\<le> hm_length x1; 2 * x2b \\<le> hm_length x1;\n        0 < 2 * x2b; 2 * x2b - 1 < length x1b;\n        heapmap_\\<alpha> x1 (x1b ! (2 * x2b - 1)) \\<noteq> None \\<and>\n        hmr_invar x1;\n        2 * x2b < hm_length x1; 0 < Suc (2 * x2b);\n        Suc (2 * x2b) - 1 < length x1b;\n        heapmap_\\<alpha> x1 (x1b ! (Suc (2 * x2b) - 1)) \\<noteq> None \\<and>\n        hmr_invar x1;\n        \\<not> prio (the (heapmap_\\<alpha> x1 (x1b ! (Suc (2 * x2b) - 1))))\n               < prio (the (heapmap_\\<alpha> x1 (x1b ! (2 * x2b - 1))));\n        0 < 2 * x2b; 2 * x2b - 1 < length x1b;\n        heapmap_\\<alpha> x1 (x1b ! (2 * x2b - 1)) \\<noteq> None \\<and>\n        hmr_invar x1;\n        0 < x2b; x2b - 1 < length x1b;\n        heapmap_\\<alpha> x1 (x1b ! (x2b - 1)) \\<noteq> None \\<and>\n        hmr_invar x1;\n        \\<not> prio (the (heapmap_\\<alpha> x1 (x1b ! (2 * x2b - 1))))\n               < prio (the (heapmap_\\<alpha> x1 (x1b ! (x2b - 1))))\\<rbrakk>\n       \\<Longrightarrow> heapmap_\\<alpha> x1 = heapmap_\\<alpha> hm\n 5. \\<And>f x x1 x1a x2 x1b x2a x2b.\n       \\<lbrakk>hm_valid hm i;\n        \\<And>x'.\n           \\<lbrakk>case x' of\n                    (hm', i) \\<Rightarrow>\n                      hm_valid hm' i \\<and>\n                      heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm \\<and>\n                      hm_length hm' = hm_length hm;\n            (x', x)\n            \\<in> measure (\\<lambda>(hm', i). hm_length hm' - i)\\<rbrakk>\n           \\<Longrightarrow> f x' \\<le>\\<^sub>n\n                             SPEC\n                              (\\<lambda>hm'.\n                                  heapmap_\\<alpha> hm' =\n                                  heapmap_\\<alpha> hm);\n        case x of\n        (hm', i) \\<Rightarrow>\n          hm_valid hm' i \\<and>\n          heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm \\<and>\n          hm_length hm' = hm_length hm;\n        REC\\<^sub>T\n         (\\<lambda>D a.\n             case a of\n             (h, k) \\<Rightarrow>\n               ASSERT (0 < k \\<and> k \\<le> hm_length h) \\<bind>\n               (\\<lambda>_.\n                   let len = hm_length h\n                   in if 2 * k \\<le> len\n                      then let j = 2 * k\n                           in (case h of\n                               (pq, m) \\<Rightarrow>\n                                 \\<lambda>i.\n                                    ASSERT (0 < i) \\<bind>\n                                    (\\<lambda>_. mop_list_get pq (i - 1)))\n                               j \\<bind>\n                              (\\<lambda>k.\n                                  ASSERT\n                                   (heapmap_\\<alpha> h k \\<noteq>\n                                    None \\<and>\n                                    hmr_invar h) \\<bind>\n                                  (\\<lambda>_.\nRETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                                  RETURN) \\<bind>\n                              (\\<lambda>v. RETURN (prio v)) \\<bind>\n                              (\\<lambda>pj.\n                                  (if j < len\n                                   then (case h of\n   (pq, m) \\<Rightarrow>\n     \\<lambda>i.\n        ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_get pq (i - 1)))\n   (Suc j) \\<bind>\n  (\\<lambda>k.\n      ASSERT (heapmap_\\<alpha> h k \\<noteq> None \\<and> hmr_invar h) \\<bind>\n      (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n      RETURN) \\<bind>\n  (\\<lambda>v. RETURN (prio v)) \\<bind>\n  (\\<lambda>psj. if psj < pj then RETURN (j + 1) else RETURN j)\n                                   else RETURN j) \\<bind>\n                                  (\\<lambda>j.\n(case h of\n (pq, m) \\<Rightarrow>\n   \\<lambda>i. ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_get pq (i - 1)))\n j \\<bind>\n(\\<lambda>k.\n    ASSERT (heapmap_\\<alpha> h k \\<noteq> None \\<and> hmr_invar h) \\<bind>\n    (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n    RETURN) \\<bind>\n(\\<lambda>v. RETURN (prio v)) \\<bind>\n(\\<lambda>pj.\n    (case h of\n     (pq, m) \\<Rightarrow>\n       \\<lambda>i.\n          ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_get pq (i - 1)))\n     k \\<bind>\n    (\\<lambda>k.\n        ASSERT\n         (heapmap_\\<alpha> h k \\<noteq> None \\<and> hmr_invar h) \\<bind>\n        (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n        RETURN) \\<bind>\n    (\\<lambda>v. RETURN (prio v)) \\<bind>\n    (\\<lambda>pk.\n        if pj < pk\n        then (case h of\n              (pq, m) \\<Rightarrow>\n                \\<lambda>i j.\n                   ASSERT (hm_valid (pq, m) i) \\<bind>\n                   (\\<lambda>_.\n                       ASSERT (hm_valid (pq, m) j) \\<bind>\n                       (\\<lambda>_.\n                           ASSERT (hmr_invar (pq, m)) \\<bind>\n                           (\\<lambda>_.\n                               mop_list_swap pq (i - 1) (j - 1) \\<bind>\n                               (\\<lambda>pq. RETURN (pq, m))))))\n              k j \\<bind>\n             (\\<lambda>h. D (h, j))\n        else RETURN h))))\n                      else RETURN h)) =\n        f;\n        x1 = (x1a, x2); x1 = (x1b, x2a); x = (x1, x2b);\n        0 < x2b \\<and> x2b \\<le> hm_length x1; 2 * x2b \\<le> hm_length x1;\n        0 < 2 * x2b; 2 * x2b - 1 < length x1b;\n        heapmap_\\<alpha> x1 (x1b ! (2 * x2b - 1)) \\<noteq> None \\<and>\n        hmr_invar x1;\n        \\<not> 2 * x2b < hm_length x1; 0 < 2 * x2b;\n        2 * x2b - 1 < length x1b;\n        heapmap_\\<alpha> x1 (x1b ! (2 * x2b - 1)) \\<noteq> None \\<and>\n        hmr_invar x1;\n        0 < x2b; x2b - 1 < length x1b;\n        heapmap_\\<alpha> x1 (x1b ! (x2b - 1)) \\<noteq> None \\<and>\n        hmr_invar x1;\n        prio (the (heapmap_\\<alpha> x1 (x1b ! (2 * x2b - 1))))\n        < prio (the (heapmap_\\<alpha> x1 (x1b ! (x2b - 1))));\n        hm_valid (x1a, x2) x2b; hm_valid (x1a, x2) (2 * x2b);\n        hmr_invar (x1a, x2);\n        x2b - 1 < length x1a \\<and> 2 * x2b - 1 < length x1a\\<rbrakk>\n       \\<Longrightarrow> f ((swap x1a (x2b - 1) (2 * x2b - 1), x2),\n                            2 * x2b) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>hm'.\n                              heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm)\n 6. \\<And>f x x1 x1a x2 x1b x2a x2b.\n       \\<lbrakk>hm_valid hm i;\n        \\<And>x'.\n           \\<lbrakk>case x' of\n                    (hm', i) \\<Rightarrow>\n                      hm_valid hm' i \\<and>\n                      heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm \\<and>\n                      hm_length hm' = hm_length hm;\n            (x', x)\n            \\<in> measure (\\<lambda>(hm', i). hm_length hm' - i)\\<rbrakk>\n           \\<Longrightarrow> f x' \\<le>\\<^sub>n\n                             SPEC\n                              (\\<lambda>hm'.\n                                  heapmap_\\<alpha> hm' =\n                                  heapmap_\\<alpha> hm);\n        case x of\n        (hm', i) \\<Rightarrow>\n          hm_valid hm' i \\<and>\n          heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm \\<and>\n          hm_length hm' = hm_length hm;\n        REC\\<^sub>T\n         (\\<lambda>D a.\n             case a of\n             (h, k) \\<Rightarrow>\n               ASSERT (0 < k \\<and> k \\<le> hm_length h) \\<bind>\n               (\\<lambda>_.\n                   let len = hm_length h\n                   in if 2 * k \\<le> len\n                      then let j = 2 * k\n                           in (case h of\n                               (pq, m) \\<Rightarrow>\n                                 \\<lambda>i.\n                                    ASSERT (0 < i) \\<bind>\n                                    (\\<lambda>_. mop_list_get pq (i - 1)))\n                               j \\<bind>\n                              (\\<lambda>k.\n                                  ASSERT\n                                   (heapmap_\\<alpha> h k \\<noteq>\n                                    None \\<and>\n                                    hmr_invar h) \\<bind>\n                                  (\\<lambda>_.\nRETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                                  RETURN) \\<bind>\n                              (\\<lambda>v. RETURN (prio v)) \\<bind>\n                              (\\<lambda>pj.\n                                  (if j < len\n                                   then (case h of\n   (pq, m) \\<Rightarrow>\n     \\<lambda>i.\n        ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_get pq (i - 1)))\n   (Suc j) \\<bind>\n  (\\<lambda>k.\n      ASSERT (heapmap_\\<alpha> h k \\<noteq> None \\<and> hmr_invar h) \\<bind>\n      (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n      RETURN) \\<bind>\n  (\\<lambda>v. RETURN (prio v)) \\<bind>\n  (\\<lambda>psj. if psj < pj then RETURN (j + 1) else RETURN j)\n                                   else RETURN j) \\<bind>\n                                  (\\<lambda>j.\n(case h of\n (pq, m) \\<Rightarrow>\n   \\<lambda>i. ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_get pq (i - 1)))\n j \\<bind>\n(\\<lambda>k.\n    ASSERT (heapmap_\\<alpha> h k \\<noteq> None \\<and> hmr_invar h) \\<bind>\n    (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n    RETURN) \\<bind>\n(\\<lambda>v. RETURN (prio v)) \\<bind>\n(\\<lambda>pj.\n    (case h of\n     (pq, m) \\<Rightarrow>\n       \\<lambda>i.\n          ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_get pq (i - 1)))\n     k \\<bind>\n    (\\<lambda>k.\n        ASSERT\n         (heapmap_\\<alpha> h k \\<noteq> None \\<and> hmr_invar h) \\<bind>\n        (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n        RETURN) \\<bind>\n    (\\<lambda>v. RETURN (prio v)) \\<bind>\n    (\\<lambda>pk.\n        if pj < pk\n        then (case h of\n              (pq, m) \\<Rightarrow>\n                \\<lambda>i j.\n                   ASSERT (hm_valid (pq, m) i) \\<bind>\n                   (\\<lambda>_.\n                       ASSERT (hm_valid (pq, m) j) \\<bind>\n                       (\\<lambda>_.\n                           ASSERT (hmr_invar (pq, m)) \\<bind>\n                           (\\<lambda>_.\n                               mop_list_swap pq (i - 1) (j - 1) \\<bind>\n                               (\\<lambda>pq. RETURN (pq, m))))))\n              k j \\<bind>\n             (\\<lambda>h. D (h, j))\n        else RETURN h))))\n                      else RETURN h)) =\n        f;\n        x1 = (x1a, x2); x1 = (x1b, x2a); x = (x1, x2b);\n        0 < x2b \\<and> x2b \\<le> hm_length x1; 2 * x2b \\<le> hm_length x1;\n        0 < 2 * x2b; 2 * x2b - 1 < length x1b;\n        heapmap_\\<alpha> x1 (x1b ! (2 * x2b - 1)) \\<noteq> None \\<and>\n        hmr_invar x1;\n        \\<not> 2 * x2b < hm_length x1; 0 < 2 * x2b;\n        2 * x2b - 1 < length x1b;\n        heapmap_\\<alpha> x1 (x1b ! (2 * x2b - 1)) \\<noteq> None \\<and>\n        hmr_invar x1;\n        0 < x2b; x2b - 1 < length x1b;\n        heapmap_\\<alpha> x1 (x1b ! (x2b - 1)) \\<noteq> None \\<and>\n        hmr_invar x1;\n        \\<not> prio (the (heapmap_\\<alpha> x1 (x1b ! (2 * x2b - 1))))\n               < prio (the (heapmap_\\<alpha> x1 (x1b ! (x2b - 1))))\\<rbrakk>\n       \\<Longrightarrow> heapmap_\\<alpha> x1 = heapmap_\\<alpha> hm\n 7. \\<And>f x x1 x1a x2 x1b x2a x2b.\n       \\<lbrakk>hm_valid hm i;\n        \\<And>x'.\n           \\<lbrakk>case x' of\n                    (hm', i) \\<Rightarrow>\n                      hm_valid hm' i \\<and>\n                      heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm \\<and>\n                      hm_length hm' = hm_length hm;\n            (x', x)\n            \\<in> measure (\\<lambda>(hm', i). hm_length hm' - i)\\<rbrakk>\n           \\<Longrightarrow> f x' \\<le>\\<^sub>n\n                             SPEC\n                              (\\<lambda>hm'.\n                                  heapmap_\\<alpha> hm' =\n                                  heapmap_\\<alpha> hm);\n        case x of\n        (hm', i) \\<Rightarrow>\n          hm_valid hm' i \\<and>\n          heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm \\<and>\n          hm_length hm' = hm_length hm;\n        REC\\<^sub>T\n         (\\<lambda>D a.\n             case a of\n             (h, k) \\<Rightarrow>\n               ASSERT (0 < k \\<and> k \\<le> hm_length h) \\<bind>\n               (\\<lambda>_.\n                   let len = hm_length h\n                   in if 2 * k \\<le> len\n                      then let j = 2 * k\n                           in (case h of\n                               (pq, m) \\<Rightarrow>\n                                 \\<lambda>i.\n                                    ASSERT (0 < i) \\<bind>\n                                    (\\<lambda>_. mop_list_get pq (i - 1)))\n                               j \\<bind>\n                              (\\<lambda>k.\n                                  ASSERT\n                                   (heapmap_\\<alpha> h k \\<noteq>\n                                    None \\<and>\n                                    hmr_invar h) \\<bind>\n                                  (\\<lambda>_.\nRETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                                  RETURN) \\<bind>\n                              (\\<lambda>v. RETURN (prio v)) \\<bind>\n                              (\\<lambda>pj.\n                                  (if j < len\n                                   then (case h of\n   (pq, m) \\<Rightarrow>\n     \\<lambda>i.\n        ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_get pq (i - 1)))\n   (Suc j) \\<bind>\n  (\\<lambda>k.\n      ASSERT (heapmap_\\<alpha> h k \\<noteq> None \\<and> hmr_invar h) \\<bind>\n      (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n      RETURN) \\<bind>\n  (\\<lambda>v. RETURN (prio v)) \\<bind>\n  (\\<lambda>psj. if psj < pj then RETURN (j + 1) else RETURN j)\n                                   else RETURN j) \\<bind>\n                                  (\\<lambda>j.\n(case h of\n (pq, m) \\<Rightarrow>\n   \\<lambda>i. ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_get pq (i - 1)))\n j \\<bind>\n(\\<lambda>k.\n    ASSERT (heapmap_\\<alpha> h k \\<noteq> None \\<and> hmr_invar h) \\<bind>\n    (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n    RETURN) \\<bind>\n(\\<lambda>v. RETURN (prio v)) \\<bind>\n(\\<lambda>pj.\n    (case h of\n     (pq, m) \\<Rightarrow>\n       \\<lambda>i.\n          ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_get pq (i - 1)))\n     k \\<bind>\n    (\\<lambda>k.\n        ASSERT\n         (heapmap_\\<alpha> h k \\<noteq> None \\<and> hmr_invar h) \\<bind>\n        (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n        RETURN) \\<bind>\n    (\\<lambda>v. RETURN (prio v)) \\<bind>\n    (\\<lambda>pk.\n        if pj < pk\n        then (case h of\n              (pq, m) \\<Rightarrow>\n                \\<lambda>i j.\n                   ASSERT (hm_valid (pq, m) i) \\<bind>\n                   (\\<lambda>_.\n                       ASSERT (hm_valid (pq, m) j) \\<bind>\n                       (\\<lambda>_.\n                           ASSERT (hmr_invar (pq, m)) \\<bind>\n                           (\\<lambda>_.\n                               mop_list_swap pq (i - 1) (j - 1) \\<bind>\n                               (\\<lambda>pq. RETURN (pq, m))))))\n              k j \\<bind>\n             (\\<lambda>h. D (h, j))\n        else RETURN h))))\n                      else RETURN h)) =\n        f;\n        x1 = (x1a, x2); x1 = (x1b, x2a); x = (x1, x2b);\n        0 < x2b \\<and> x2b \\<le> hm_length x1;\n        \\<not> 2 * x2b \\<le> hm_length x1\\<rbrakk>\n       \\<Longrightarrow> heapmap_\\<alpha> x1 = heapmap_\\<alpha> hm", "apply (vc_solve simp add: hm_valid_def hm_length_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1a x2 x2b y ya yb.\n       \\<lbrakk>\\<And>a b ba.\n                   \\<lbrakk>0 < ba \\<and>\n                            ba \\<le> length a \\<and>\n                            heapmap_\\<alpha> (a, b) =\n                            heapmap_\\<alpha> hm \\<and>\n                            length a =\n                            (case hm of (pq, uu_) \\<Rightarrow> length pq);\n                    (case hm of (pq, uu_) \\<Rightarrow> length pq) - ba\n                    < (case hm of (pq, uu_) \\<Rightarrow> length pq) -\n                      x2b\\<rbrakk>\n                   \\<Longrightarrow> REC\\<^sub>T\n(\\<lambda>D (h, k).\n    ASSERT\n     (0 < k \\<and>\n      k \\<le> (case h of (pq, uu_) \\<Rightarrow> length pq)) \\<bind>\n    (\\<lambda>_.\n        let len = case h of (pq, uu_) \\<Rightarrow> length pq\n        in if 2 * k \\<le> len\n           then let j = 2 * k\n                in (case h of\n                    (pq, m) \\<Rightarrow>\n                      \\<lambda>i.\n                         ASSERT (0 < i) \\<bind>\n                         (\\<lambda>_. mop_list_get pq (i - 1)))\n                    j \\<bind>\n                   (\\<lambda>k.\n                       ASSERT\n                        (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                         hmr_invar h) \\<bind>\n                       (\\<lambda>_.\n                           RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                       RETURN) \\<bind>\n                   (\\<lambda>v. RETURN (prio v)) \\<bind>\n                   (\\<lambda>pj.\n                       (if j < len\n                        then (case h of\n                              (pq, m) \\<Rightarrow>\n                                \\<lambda>i.\n                                   ASSERT (0 < i) \\<bind>\n                                   (\\<lambda>_. mop_list_get pq (i - 1)))\n                              (Suc j) \\<bind>\n                             (\\<lambda>k.\n                                 ASSERT\n                                  (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                                   hmr_invar h) \\<bind>\n                                 (\\<lambda>_.\n                                     RETURN\n(the (heapmap_\\<alpha> h k))) \\<bind>\n                                 RETURN) \\<bind>\n                             (\\<lambda>v. RETURN (prio v)) \\<bind>\n                             (\\<lambda>psj.\n                                 if psj < pj then RETURN (j + 1)\n                                 else RETURN j)\n                        else RETURN j) \\<bind>\n                       (\\<lambda>j.\n                           (case h of\n                            (pq, m) \\<Rightarrow>\n                              \\<lambda>i.\n                                 ASSERT (0 < i) \\<bind>\n                                 (\\<lambda>_. mop_list_get pq (i - 1)))\n                            j \\<bind>\n                           (\\<lambda>k.\n                               ASSERT\n                                (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                                 hmr_invar h) \\<bind>\n                               (\\<lambda>_.\n                                   RETURN\n                                    (the (heapmap_\\<alpha> h k))) \\<bind>\n                               RETURN) \\<bind>\n                           (\\<lambda>v. RETURN (prio v)) \\<bind>\n                           (\\<lambda>pj.\n                               (case h of\n                                (pq, m) \\<Rightarrow>\n                                  \\<lambda>i.\n                                     ASSERT (0 < i) \\<bind>\n                                     (\\<lambda>_. mop_list_get pq (i - 1)))\n                                k \\<bind>\n                               (\\<lambda>k.\n                                   ASSERT\n                                    (heapmap_\\<alpha> h k \\<noteq>\n                                     None \\<and>\n                                     hmr_invar h) \\<bind>\n                                   (\\<lambda>_.\n RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                                   RETURN) \\<bind>\n                               (\\<lambda>v. RETURN (prio v)) \\<bind>\n                               (\\<lambda>pk.\n                                   if pj < pk\n                                   then (case h of\n   (pq, m) \\<Rightarrow>\n     \\<lambda>i j.\n        ASSERT (hm_valid (pq, m) i) \\<bind>\n        (\\<lambda>_.\n            ASSERT (hm_valid (pq, m) j) \\<bind>\n            (\\<lambda>_.\n                ASSERT (hmr_invar (pq, m)) \\<bind>\n                (\\<lambda>_.\n                    mop_list_swap pq (i - 1) (j - 1) \\<bind>\n                    (\\<lambda>pq. RETURN (pq, m))))))\n   k j \\<bind>\n  (\\<lambda>h. D (h, j))\n                                   else RETURN h))))\n           else RETURN h))\n((a, b), ba) \\<le>\\<^sub>n\n                                     SPEC\n(\\<lambda>hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm);\n        2 * x2b - Suc 0 < (case hm of (pq, uu_) \\<Rightarrow> length pq);\n        2 * x2b < (case hm of (pq, uu_) \\<Rightarrow> length pq);\n        prio ya < prio y; 0 < x2b;\n        x2b - Suc 0 < (case hm of (pq, uu_) \\<Rightarrow> length pq);\n        prio ya < prio yb; hmr_invar (x1a, x2);\n        heapmap_\\<alpha> hm (x1a ! (2 * x2b - Suc 0)) = Some y;\n        heapmap_\\<alpha> hm (x1a ! (2 * x2b)) = Some ya;\n        heapmap_\\<alpha> hm (x1a ! (x2b - Suc 0)) = Some yb; 0 < i;\n        i \\<le> (case hm of (pq, uu_) \\<Rightarrow> length pq);\n        heapmap_\\<alpha> (x1a, x2) = heapmap_\\<alpha> hm;\n        length x1a = (case hm of (pq, uu_) \\<Rightarrow> length pq)\\<rbrakk>\n       \\<Longrightarrow> REC\\<^sub>T\n                          (\\<lambda>D (h, k).\n                              ASSERT\n                               (0 < k \\<and>\n                                k \\<le> (case h of\n   (pq, uu_) \\<Rightarrow> length pq)) \\<bind>\n                              (\\<lambda>_.\n                                  let len =\n  case h of (pq, uu_) \\<Rightarrow> length pq\n                                  in if 2 * k \\<le> len\n                                     then let j = 2 * k\n    in (case h of\n        (pq, m) \\<Rightarrow>\n          \\<lambda>i.\n             ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_get pq (i - 1)))\n        j \\<bind>\n       (\\<lambda>k.\n           ASSERT\n            (heapmap_\\<alpha> h k \\<noteq> None \\<and> hmr_invar h) \\<bind>\n           (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n           RETURN) \\<bind>\n       (\\<lambda>v. RETURN (prio v)) \\<bind>\n       (\\<lambda>pj.\n           (if j < len\n            then (case h of\n                  (pq, m) \\<Rightarrow>\n                    \\<lambda>i.\n                       ASSERT (0 < i) \\<bind>\n                       (\\<lambda>_. mop_list_get pq (i - 1)))\n                  (Suc j) \\<bind>\n                 (\\<lambda>k.\n                     ASSERT\n                      (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                       hmr_invar h) \\<bind>\n                     (\\<lambda>_.\n                         RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                     RETURN) \\<bind>\n                 (\\<lambda>v. RETURN (prio v)) \\<bind>\n                 (\\<lambda>psj.\n                     if psj < pj then RETURN (j + 1) else RETURN j)\n            else RETURN j) \\<bind>\n           (\\<lambda>j.\n               (case h of\n                (pq, m) \\<Rightarrow>\n                  \\<lambda>i.\n                     ASSERT (0 < i) \\<bind>\n                     (\\<lambda>_. mop_list_get pq (i - 1)))\n                j \\<bind>\n               (\\<lambda>k.\n                   ASSERT\n                    (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                     hmr_invar h) \\<bind>\n                   (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                   RETURN) \\<bind>\n               (\\<lambda>v. RETURN (prio v)) \\<bind>\n               (\\<lambda>pj.\n                   (case h of\n                    (pq, m) \\<Rightarrow>\n                      \\<lambda>i.\n                         ASSERT (0 < i) \\<bind>\n                         (\\<lambda>_. mop_list_get pq (i - 1)))\n                    k \\<bind>\n                   (\\<lambda>k.\n                       ASSERT\n                        (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                         hmr_invar h) \\<bind>\n                       (\\<lambda>_.\n                           RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                       RETURN) \\<bind>\n                   (\\<lambda>v. RETURN (prio v)) \\<bind>\n                   (\\<lambda>pk.\n                       if pj < pk\n                       then (case h of\n                             (pq, m) \\<Rightarrow>\n                               \\<lambda>i j.\n                                  ASSERT (hm_valid (pq, m) i) \\<bind>\n                                  (\\<lambda>_.\nASSERT (hm_valid (pq, m) j) \\<bind>\n(\\<lambda>_.\n    ASSERT (hmr_invar (pq, m)) \\<bind>\n    (\\<lambda>_.\n        mop_list_swap pq (i - 1) (j - 1) \\<bind>\n        (\\<lambda>pq. RETURN (pq, m))))))\n                             k j \\<bind>\n                            (\\<lambda>h. D (h, j))\n                       else RETURN h))))\n                                     else RETURN h))\n                          ((swap x1a (x2b - Suc 0) (2 * x2b), x2),\n                           Suc (2 * x2b)) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>hm'.\n                              heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm)\n 2. \\<And>x1a x2 x2b y ya yb.\n       \\<lbrakk>\\<And>a b ba.\n                   \\<lbrakk>0 < ba \\<and>\n                            ba \\<le> length a \\<and>\n                            heapmap_\\<alpha> (a, b) =\n                            heapmap_\\<alpha> hm \\<and>\n                            length a =\n                            (case hm of (pq, uu_) \\<Rightarrow> length pq);\n                    (case hm of (pq, uu_) \\<Rightarrow> length pq) - ba\n                    < (case hm of (pq, uu_) \\<Rightarrow> length pq) -\n                      x2b\\<rbrakk>\n                   \\<Longrightarrow> REC\\<^sub>T\n(\\<lambda>D (h, k).\n    ASSERT\n     (0 < k \\<and>\n      k \\<le> (case h of (pq, uu_) \\<Rightarrow> length pq)) \\<bind>\n    (\\<lambda>_.\n        let len = case h of (pq, uu_) \\<Rightarrow> length pq\n        in if 2 * k \\<le> len\n           then let j = 2 * k\n                in (case h of\n                    (pq, m) \\<Rightarrow>\n                      \\<lambda>i.\n                         ASSERT (0 < i) \\<bind>\n                         (\\<lambda>_. mop_list_get pq (i - 1)))\n                    j \\<bind>\n                   (\\<lambda>k.\n                       ASSERT\n                        (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                         hmr_invar h) \\<bind>\n                       (\\<lambda>_.\n                           RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                       RETURN) \\<bind>\n                   (\\<lambda>v. RETURN (prio v)) \\<bind>\n                   (\\<lambda>pj.\n                       (if j < len\n                        then (case h of\n                              (pq, m) \\<Rightarrow>\n                                \\<lambda>i.\n                                   ASSERT (0 < i) \\<bind>\n                                   (\\<lambda>_. mop_list_get pq (i - 1)))\n                              (Suc j) \\<bind>\n                             (\\<lambda>k.\n                                 ASSERT\n                                  (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                                   hmr_invar h) \\<bind>\n                                 (\\<lambda>_.\n                                     RETURN\n(the (heapmap_\\<alpha> h k))) \\<bind>\n                                 RETURN) \\<bind>\n                             (\\<lambda>v. RETURN (prio v)) \\<bind>\n                             (\\<lambda>psj.\n                                 if psj < pj then RETURN (j + 1)\n                                 else RETURN j)\n                        else RETURN j) \\<bind>\n                       (\\<lambda>j.\n                           (case h of\n                            (pq, m) \\<Rightarrow>\n                              \\<lambda>i.\n                                 ASSERT (0 < i) \\<bind>\n                                 (\\<lambda>_. mop_list_get pq (i - 1)))\n                            j \\<bind>\n                           (\\<lambda>k.\n                               ASSERT\n                                (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                                 hmr_invar h) \\<bind>\n                               (\\<lambda>_.\n                                   RETURN\n                                    (the (heapmap_\\<alpha> h k))) \\<bind>\n                               RETURN) \\<bind>\n                           (\\<lambda>v. RETURN (prio v)) \\<bind>\n                           (\\<lambda>pj.\n                               (case h of\n                                (pq, m) \\<Rightarrow>\n                                  \\<lambda>i.\n                                     ASSERT (0 < i) \\<bind>\n                                     (\\<lambda>_. mop_list_get pq (i - 1)))\n                                k \\<bind>\n                               (\\<lambda>k.\n                                   ASSERT\n                                    (heapmap_\\<alpha> h k \\<noteq>\n                                     None \\<and>\n                                     hmr_invar h) \\<bind>\n                                   (\\<lambda>_.\n RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                                   RETURN) \\<bind>\n                               (\\<lambda>v. RETURN (prio v)) \\<bind>\n                               (\\<lambda>pk.\n                                   if pj < pk\n                                   then (case h of\n   (pq, m) \\<Rightarrow>\n     \\<lambda>i j.\n        ASSERT (hm_valid (pq, m) i) \\<bind>\n        (\\<lambda>_.\n            ASSERT (hm_valid (pq, m) j) \\<bind>\n            (\\<lambda>_.\n                ASSERT (hmr_invar (pq, m)) \\<bind>\n                (\\<lambda>_.\n                    mop_list_swap pq (i - 1) (j - 1) \\<bind>\n                    (\\<lambda>pq. RETURN (pq, m))))))\n   k j \\<bind>\n  (\\<lambda>h. D (h, j))\n                                   else RETURN h))))\n           else RETURN h))\n((a, b), ba) \\<le>\\<^sub>n\n                                     SPEC\n(\\<lambda>hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm);\n        2 * x2b - Suc 0 < (case hm of (pq, uu_) \\<Rightarrow> length pq);\n        2 * x2b < (case hm of (pq, uu_) \\<Rightarrow> length pq);\n        \\<not> prio ya < prio y; 0 < x2b;\n        x2b - Suc 0 < (case hm of (pq, uu_) \\<Rightarrow> length pq);\n        prio y < prio yb; hmr_invar (x1a, x2);\n        heapmap_\\<alpha> hm (x1a ! (2 * x2b - Suc 0)) = Some y;\n        heapmap_\\<alpha> hm (x1a ! (2 * x2b)) = Some ya;\n        heapmap_\\<alpha> hm (x1a ! (x2b - Suc 0)) = Some yb; 0 < i;\n        i \\<le> (case hm of (pq, uu_) \\<Rightarrow> length pq);\n        heapmap_\\<alpha> (x1a, x2) = heapmap_\\<alpha> hm;\n        length x1a = (case hm of (pq, uu_) \\<Rightarrow> length pq)\\<rbrakk>\n       \\<Longrightarrow> REC\\<^sub>T\n                          (\\<lambda>D (h, k).\n                              ASSERT\n                               (0 < k \\<and>\n                                k \\<le> (case h of\n   (pq, uu_) \\<Rightarrow> length pq)) \\<bind>\n                              (\\<lambda>_.\n                                  let len =\n  case h of (pq, uu_) \\<Rightarrow> length pq\n                                  in if 2 * k \\<le> len\n                                     then let j = 2 * k\n    in (case h of\n        (pq, m) \\<Rightarrow>\n          \\<lambda>i.\n             ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_get pq (i - 1)))\n        j \\<bind>\n       (\\<lambda>k.\n           ASSERT\n            (heapmap_\\<alpha> h k \\<noteq> None \\<and> hmr_invar h) \\<bind>\n           (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n           RETURN) \\<bind>\n       (\\<lambda>v. RETURN (prio v)) \\<bind>\n       (\\<lambda>pj.\n           (if j < len\n            then (case h of\n                  (pq, m) \\<Rightarrow>\n                    \\<lambda>i.\n                       ASSERT (0 < i) \\<bind>\n                       (\\<lambda>_. mop_list_get pq (i - 1)))\n                  (Suc j) \\<bind>\n                 (\\<lambda>k.\n                     ASSERT\n                      (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                       hmr_invar h) \\<bind>\n                     (\\<lambda>_.\n                         RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                     RETURN) \\<bind>\n                 (\\<lambda>v. RETURN (prio v)) \\<bind>\n                 (\\<lambda>psj.\n                     if psj < pj then RETURN (j + 1) else RETURN j)\n            else RETURN j) \\<bind>\n           (\\<lambda>j.\n               (case h of\n                (pq, m) \\<Rightarrow>\n                  \\<lambda>i.\n                     ASSERT (0 < i) \\<bind>\n                     (\\<lambda>_. mop_list_get pq (i - 1)))\n                j \\<bind>\n               (\\<lambda>k.\n                   ASSERT\n                    (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                     hmr_invar h) \\<bind>\n                   (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                   RETURN) \\<bind>\n               (\\<lambda>v. RETURN (prio v)) \\<bind>\n               (\\<lambda>pj.\n                   (case h of\n                    (pq, m) \\<Rightarrow>\n                      \\<lambda>i.\n                         ASSERT (0 < i) \\<bind>\n                         (\\<lambda>_. mop_list_get pq (i - 1)))\n                    k \\<bind>\n                   (\\<lambda>k.\n                       ASSERT\n                        (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                         hmr_invar h) \\<bind>\n                       (\\<lambda>_.\n                           RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                       RETURN) \\<bind>\n                   (\\<lambda>v. RETURN (prio v)) \\<bind>\n                   (\\<lambda>pk.\n                       if pj < pk\n                       then (case h of\n                             (pq, m) \\<Rightarrow>\n                               \\<lambda>i j.\n                                  ASSERT (hm_valid (pq, m) i) \\<bind>\n                                  (\\<lambda>_.\nASSERT (hm_valid (pq, m) j) \\<bind>\n(\\<lambda>_.\n    ASSERT (hmr_invar (pq, m)) \\<bind>\n    (\\<lambda>_.\n        mop_list_swap pq (i - 1) (j - 1) \\<bind>\n        (\\<lambda>pq. RETURN (pq, m))))))\n                             k j \\<bind>\n                            (\\<lambda>h. D (h, j))\n                       else RETURN h))))\n                                     else RETURN h))\n                          ((swap x1a (x2b - Suc 0) (2 * x2b - Suc 0), x2),\n                           2 * x2b) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>hm'.\n                              heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm)\n 3. \\<And>x1a x2 x2b y ya.\n       \\<lbrakk>\\<And>a b ba.\n                   \\<lbrakk>0 < ba \\<and>\n                            ba \\<le> length a \\<and>\n                            heapmap_\\<alpha> (a, b) =\n                            heapmap_\\<alpha> hm \\<and>\n                            length a =\n                            (case hm of (pq, uu_) \\<Rightarrow> length pq);\n                    (case hm of (pq, uu_) \\<Rightarrow> length pq) - ba\n                    < (case hm of (pq, uu_) \\<Rightarrow> length pq) -\n                      x2b\\<rbrakk>\n                   \\<Longrightarrow> REC\\<^sub>T\n(\\<lambda>D (h, k).\n    ASSERT\n     (0 < k \\<and>\n      k \\<le> (case h of (pq, uu_) \\<Rightarrow> length pq)) \\<bind>\n    (\\<lambda>_.\n        let len = case h of (pq, uu_) \\<Rightarrow> length pq\n        in if 2 * k \\<le> len\n           then let j = 2 * k\n                in (case h of\n                    (pq, m) \\<Rightarrow>\n                      \\<lambda>i.\n                         ASSERT (0 < i) \\<bind>\n                         (\\<lambda>_. mop_list_get pq (i - 1)))\n                    j \\<bind>\n                   (\\<lambda>k.\n                       ASSERT\n                        (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                         hmr_invar h) \\<bind>\n                       (\\<lambda>_.\n                           RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                       RETURN) \\<bind>\n                   (\\<lambda>v. RETURN (prio v)) \\<bind>\n                   (\\<lambda>pj.\n                       (if j < len\n                        then (case h of\n                              (pq, m) \\<Rightarrow>\n                                \\<lambda>i.\n                                   ASSERT (0 < i) \\<bind>\n                                   (\\<lambda>_. mop_list_get pq (i - 1)))\n                              (Suc j) \\<bind>\n                             (\\<lambda>k.\n                                 ASSERT\n                                  (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                                   hmr_invar h) \\<bind>\n                                 (\\<lambda>_.\n                                     RETURN\n(the (heapmap_\\<alpha> h k))) \\<bind>\n                                 RETURN) \\<bind>\n                             (\\<lambda>v. RETURN (prio v)) \\<bind>\n                             (\\<lambda>psj.\n                                 if psj < pj then RETURN (j + 1)\n                                 else RETURN j)\n                        else RETURN j) \\<bind>\n                       (\\<lambda>j.\n                           (case h of\n                            (pq, m) \\<Rightarrow>\n                              \\<lambda>i.\n                                 ASSERT (0 < i) \\<bind>\n                                 (\\<lambda>_. mop_list_get pq (i - 1)))\n                            j \\<bind>\n                           (\\<lambda>k.\n                               ASSERT\n                                (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                                 hmr_invar h) \\<bind>\n                               (\\<lambda>_.\n                                   RETURN\n                                    (the (heapmap_\\<alpha> h k))) \\<bind>\n                               RETURN) \\<bind>\n                           (\\<lambda>v. RETURN (prio v)) \\<bind>\n                           (\\<lambda>pj.\n                               (case h of\n                                (pq, m) \\<Rightarrow>\n                                  \\<lambda>i.\n                                     ASSERT (0 < i) \\<bind>\n                                     (\\<lambda>_. mop_list_get pq (i - 1)))\n                                k \\<bind>\n                               (\\<lambda>k.\n                                   ASSERT\n                                    (heapmap_\\<alpha> h k \\<noteq>\n                                     None \\<and>\n                                     hmr_invar h) \\<bind>\n                                   (\\<lambda>_.\n RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                                   RETURN) \\<bind>\n                               (\\<lambda>v. RETURN (prio v)) \\<bind>\n                               (\\<lambda>pk.\n                                   if pj < pk\n                                   then (case h of\n   (pq, m) \\<Rightarrow>\n     \\<lambda>i j.\n        ASSERT (hm_valid (pq, m) i) \\<bind>\n        (\\<lambda>_.\n            ASSERT (hm_valid (pq, m) j) \\<bind>\n            (\\<lambda>_.\n                ASSERT (hmr_invar (pq, m)) \\<bind>\n                (\\<lambda>_.\n                    mop_list_swap pq (i - 1) (j - 1) \\<bind>\n                    (\\<lambda>pq. RETURN (pq, m))))))\n   k j \\<bind>\n  (\\<lambda>h. D (h, j))\n                                   else RETURN h))))\n           else RETURN h))\n((a, b), ba) \\<le>\\<^sub>n\n                                     SPEC\n(\\<lambda>hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm);\n        2 * x2b = (case hm of (pq, uu_) \\<Rightarrow> length pq);\n        x2b - Suc 0 < (case hm of (pq, uu_) \\<Rightarrow> length pq);\n        prio y < prio ya; hmr_invar (x1a, x2);\n        heapmap_\\<alpha> hm\n         (x1a ! ((case hm of (pq, uu_) \\<Rightarrow> length pq) - Suc 0)) =\n        Some y;\n        heapmap_\\<alpha> hm (x1a ! (x2b - Suc 0)) = Some ya; 0 < i;\n        i \\<le> (case hm of (pq, uu_) \\<Rightarrow> length pq);\n        heapmap_\\<alpha> (x1a, x2) = heapmap_\\<alpha> hm;\n        length x1a = (case hm of (pq, uu_) \\<Rightarrow> length pq)\\<rbrakk>\n       \\<Longrightarrow> REC\\<^sub>T\n                          (\\<lambda>D (h, k).\n                              ASSERT\n                               (0 < k \\<and>\n                                k \\<le> (case h of\n   (pq, uu_) \\<Rightarrow> length pq)) \\<bind>\n                              (\\<lambda>_.\n                                  let len =\n  case h of (pq, uu_) \\<Rightarrow> length pq\n                                  in if 2 * k \\<le> len\n                                     then let j = 2 * k\n    in (case h of\n        (pq, m) \\<Rightarrow>\n          \\<lambda>i.\n             ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_get pq (i - 1)))\n        j \\<bind>\n       (\\<lambda>k.\n           ASSERT\n            (heapmap_\\<alpha> h k \\<noteq> None \\<and> hmr_invar h) \\<bind>\n           (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n           RETURN) \\<bind>\n       (\\<lambda>v. RETURN (prio v)) \\<bind>\n       (\\<lambda>pj.\n           (if j < len\n            then (case h of\n                  (pq, m) \\<Rightarrow>\n                    \\<lambda>i.\n                       ASSERT (0 < i) \\<bind>\n                       (\\<lambda>_. mop_list_get pq (i - 1)))\n                  (Suc j) \\<bind>\n                 (\\<lambda>k.\n                     ASSERT\n                      (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                       hmr_invar h) \\<bind>\n                     (\\<lambda>_.\n                         RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                     RETURN) \\<bind>\n                 (\\<lambda>v. RETURN (prio v)) \\<bind>\n                 (\\<lambda>psj.\n                     if psj < pj then RETURN (j + 1) else RETURN j)\n            else RETURN j) \\<bind>\n           (\\<lambda>j.\n               (case h of\n                (pq, m) \\<Rightarrow>\n                  \\<lambda>i.\n                     ASSERT (0 < i) \\<bind>\n                     (\\<lambda>_. mop_list_get pq (i - 1)))\n                j \\<bind>\n               (\\<lambda>k.\n                   ASSERT\n                    (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                     hmr_invar h) \\<bind>\n                   (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                   RETURN) \\<bind>\n               (\\<lambda>v. RETURN (prio v)) \\<bind>\n               (\\<lambda>pj.\n                   (case h of\n                    (pq, m) \\<Rightarrow>\n                      \\<lambda>i.\n                         ASSERT (0 < i) \\<bind>\n                         (\\<lambda>_. mop_list_get pq (i - 1)))\n                    k \\<bind>\n                   (\\<lambda>k.\n                       ASSERT\n                        (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                         hmr_invar h) \\<bind>\n                       (\\<lambda>_.\n                           RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                       RETURN) \\<bind>\n                   (\\<lambda>v. RETURN (prio v)) \\<bind>\n                   (\\<lambda>pk.\n                       if pj < pk\n                       then (case h of\n                             (pq, m) \\<Rightarrow>\n                               \\<lambda>i j.\n                                  ASSERT (hm_valid (pq, m) i) \\<bind>\n                                  (\\<lambda>_.\nASSERT (hm_valid (pq, m) j) \\<bind>\n(\\<lambda>_.\n    ASSERT (hmr_invar (pq, m)) \\<bind>\n    (\\<lambda>_.\n        mop_list_swap pq (i - 1) (j - 1) \\<bind>\n        (\\<lambda>pq. RETURN (pq, m))))))\n                             k j \\<bind>\n                            (\\<lambda>h. D (h, j))\n                       else RETURN h))))\n                                     else RETURN h))\n                          ((swap x1a (x2b - Suc 0)\n                             ((case hm of\n                               (pq, uu_) \\<Rightarrow> length pq) -\n                              Suc 0),\n                            x2),\n                           case hm of\n                           (pq, uu_) \\<Rightarrow> length pq) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>hm'.\n                              heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm)", "(* Takes long *)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1a x2 x2b y ya yb.\n       \\<lbrakk>\\<And>a b ba.\n                   \\<lbrakk>0 < ba \\<and>\n                            ba \\<le> length a \\<and>\n                            heapmap_\\<alpha> (a, b) =\n                            heapmap_\\<alpha> hm \\<and>\n                            length a =\n                            (case hm of (pq, uu_) \\<Rightarrow> length pq);\n                    (case hm of (pq, uu_) \\<Rightarrow> length pq) - ba\n                    < (case hm of (pq, uu_) \\<Rightarrow> length pq) -\n                      x2b\\<rbrakk>\n                   \\<Longrightarrow> REC\\<^sub>T\n(\\<lambda>D (h, k).\n    ASSERT\n     (0 < k \\<and>\n      k \\<le> (case h of (pq, uu_) \\<Rightarrow> length pq)) \\<bind>\n    (\\<lambda>_.\n        let len = case h of (pq, uu_) \\<Rightarrow> length pq\n        in if 2 * k \\<le> len\n           then let j = 2 * k\n                in (case h of\n                    (pq, m) \\<Rightarrow>\n                      \\<lambda>i.\n                         ASSERT (0 < i) \\<bind>\n                         (\\<lambda>_. mop_list_get pq (i - 1)))\n                    j \\<bind>\n                   (\\<lambda>k.\n                       ASSERT\n                        (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                         hmr_invar h) \\<bind>\n                       (\\<lambda>_.\n                           RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                       RETURN) \\<bind>\n                   (\\<lambda>v. RETURN (prio v)) \\<bind>\n                   (\\<lambda>pj.\n                       (if j < len\n                        then (case h of\n                              (pq, m) \\<Rightarrow>\n                                \\<lambda>i.\n                                   ASSERT (0 < i) \\<bind>\n                                   (\\<lambda>_. mop_list_get pq (i - 1)))\n                              (Suc j) \\<bind>\n                             (\\<lambda>k.\n                                 ASSERT\n                                  (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                                   hmr_invar h) \\<bind>\n                                 (\\<lambda>_.\n                                     RETURN\n(the (heapmap_\\<alpha> h k))) \\<bind>\n                                 RETURN) \\<bind>\n                             (\\<lambda>v. RETURN (prio v)) \\<bind>\n                             (\\<lambda>psj.\n                                 if psj < pj then RETURN (j + 1)\n                                 else RETURN j)\n                        else RETURN j) \\<bind>\n                       (\\<lambda>j.\n                           (case h of\n                            (pq, m) \\<Rightarrow>\n                              \\<lambda>i.\n                                 ASSERT (0 < i) \\<bind>\n                                 (\\<lambda>_. mop_list_get pq (i - 1)))\n                            j \\<bind>\n                           (\\<lambda>k.\n                               ASSERT\n                                (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                                 hmr_invar h) \\<bind>\n                               (\\<lambda>_.\n                                   RETURN\n                                    (the (heapmap_\\<alpha> h k))) \\<bind>\n                               RETURN) \\<bind>\n                           (\\<lambda>v. RETURN (prio v)) \\<bind>\n                           (\\<lambda>pj.\n                               (case h of\n                                (pq, m) \\<Rightarrow>\n                                  \\<lambda>i.\n                                     ASSERT (0 < i) \\<bind>\n                                     (\\<lambda>_. mop_list_get pq (i - 1)))\n                                k \\<bind>\n                               (\\<lambda>k.\n                                   ASSERT\n                                    (heapmap_\\<alpha> h k \\<noteq>\n                                     None \\<and>\n                                     hmr_invar h) \\<bind>\n                                   (\\<lambda>_.\n RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                                   RETURN) \\<bind>\n                               (\\<lambda>v. RETURN (prio v)) \\<bind>\n                               (\\<lambda>pk.\n                                   if pj < pk\n                                   then (case h of\n   (pq, m) \\<Rightarrow>\n     \\<lambda>i j.\n        ASSERT (hm_valid (pq, m) i) \\<bind>\n        (\\<lambda>_.\n            ASSERT (hm_valid (pq, m) j) \\<bind>\n            (\\<lambda>_.\n                ASSERT (hmr_invar (pq, m)) \\<bind>\n                (\\<lambda>_.\n                    mop_list_swap pq (i - 1) (j - 1) \\<bind>\n                    (\\<lambda>pq. RETURN (pq, m))))))\n   k j \\<bind>\n  (\\<lambda>h. D (h, j))\n                                   else RETURN h))))\n           else RETURN h))\n((a, b), ba) \\<le>\\<^sub>n\n                                     SPEC\n(\\<lambda>hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm);\n        2 * x2b - Suc 0 < (case hm of (pq, uu_) \\<Rightarrow> length pq);\n        2 * x2b < (case hm of (pq, uu_) \\<Rightarrow> length pq);\n        prio ya < prio y; 0 < x2b;\n        x2b - Suc 0 < (case hm of (pq, uu_) \\<Rightarrow> length pq);\n        prio ya < prio yb; hmr_invar (x1a, x2);\n        heapmap_\\<alpha> hm (x1a ! (2 * x2b - Suc 0)) = Some y;\n        heapmap_\\<alpha> hm (x1a ! (2 * x2b)) = Some ya;\n        heapmap_\\<alpha> hm (x1a ! (x2b - Suc 0)) = Some yb; 0 < i;\n        i \\<le> (case hm of (pq, uu_) \\<Rightarrow> length pq);\n        heapmap_\\<alpha> (x1a, x2) = heapmap_\\<alpha> hm;\n        length x1a = (case hm of (pq, uu_) \\<Rightarrow> length pq)\\<rbrakk>\n       \\<Longrightarrow> REC\\<^sub>T\n                          (\\<lambda>D (h, k).\n                              ASSERT\n                               (0 < k \\<and>\n                                k \\<le> (case h of\n   (pq, uu_) \\<Rightarrow> length pq)) \\<bind>\n                              (\\<lambda>_.\n                                  let len =\n  case h of (pq, uu_) \\<Rightarrow> length pq\n                                  in if 2 * k \\<le> len\n                                     then let j = 2 * k\n    in (case h of\n        (pq, m) \\<Rightarrow>\n          \\<lambda>i.\n             ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_get pq (i - 1)))\n        j \\<bind>\n       (\\<lambda>k.\n           ASSERT\n            (heapmap_\\<alpha> h k \\<noteq> None \\<and> hmr_invar h) \\<bind>\n           (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n           RETURN) \\<bind>\n       (\\<lambda>v. RETURN (prio v)) \\<bind>\n       (\\<lambda>pj.\n           (if j < len\n            then (case h of\n                  (pq, m) \\<Rightarrow>\n                    \\<lambda>i.\n                       ASSERT (0 < i) \\<bind>\n                       (\\<lambda>_. mop_list_get pq (i - 1)))\n                  (Suc j) \\<bind>\n                 (\\<lambda>k.\n                     ASSERT\n                      (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                       hmr_invar h) \\<bind>\n                     (\\<lambda>_.\n                         RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                     RETURN) \\<bind>\n                 (\\<lambda>v. RETURN (prio v)) \\<bind>\n                 (\\<lambda>psj.\n                     if psj < pj then RETURN (j + 1) else RETURN j)\n            else RETURN j) \\<bind>\n           (\\<lambda>j.\n               (case h of\n                (pq, m) \\<Rightarrow>\n                  \\<lambda>i.\n                     ASSERT (0 < i) \\<bind>\n                     (\\<lambda>_. mop_list_get pq (i - 1)))\n                j \\<bind>\n               (\\<lambda>k.\n                   ASSERT\n                    (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                     hmr_invar h) \\<bind>\n                   (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                   RETURN) \\<bind>\n               (\\<lambda>v. RETURN (prio v)) \\<bind>\n               (\\<lambda>pj.\n                   (case h of\n                    (pq, m) \\<Rightarrow>\n                      \\<lambda>i.\n                         ASSERT (0 < i) \\<bind>\n                         (\\<lambda>_. mop_list_get pq (i - 1)))\n                    k \\<bind>\n                   (\\<lambda>k.\n                       ASSERT\n                        (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                         hmr_invar h) \\<bind>\n                       (\\<lambda>_.\n                           RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                       RETURN) \\<bind>\n                   (\\<lambda>v. RETURN (prio v)) \\<bind>\n                   (\\<lambda>pk.\n                       if pj < pk\n                       then (case h of\n                             (pq, m) \\<Rightarrow>\n                               \\<lambda>i j.\n                                  ASSERT (hm_valid (pq, m) i) \\<bind>\n                                  (\\<lambda>_.\nASSERT (hm_valid (pq, m) j) \\<bind>\n(\\<lambda>_.\n    ASSERT (hmr_invar (pq, m)) \\<bind>\n    (\\<lambda>_.\n        mop_list_swap pq (i - 1) (j - 1) \\<bind>\n        (\\<lambda>pq. RETURN (pq, m))))))\n                             k j \\<bind>\n                            (\\<lambda>h. D (h, j))\n                       else RETURN h))))\n                                     else RETURN h))\n                          ((swap x1a (x2b - Suc 0) (2 * x2b), x2),\n                           Suc (2 * x2b)) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>hm'.\n                              heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm)\n 2. \\<And>x1a x2 x2b y ya yb.\n       \\<lbrakk>\\<And>a b ba.\n                   \\<lbrakk>0 < ba \\<and>\n                            ba \\<le> length a \\<and>\n                            heapmap_\\<alpha> (a, b) =\n                            heapmap_\\<alpha> hm \\<and>\n                            length a =\n                            (case hm of (pq, uu_) \\<Rightarrow> length pq);\n                    (case hm of (pq, uu_) \\<Rightarrow> length pq) - ba\n                    < (case hm of (pq, uu_) \\<Rightarrow> length pq) -\n                      x2b\\<rbrakk>\n                   \\<Longrightarrow> REC\\<^sub>T\n(\\<lambda>D (h, k).\n    ASSERT\n     (0 < k \\<and>\n      k \\<le> (case h of (pq, uu_) \\<Rightarrow> length pq)) \\<bind>\n    (\\<lambda>_.\n        let len = case h of (pq, uu_) \\<Rightarrow> length pq\n        in if 2 * k \\<le> len\n           then let j = 2 * k\n                in (case h of\n                    (pq, m) \\<Rightarrow>\n                      \\<lambda>i.\n                         ASSERT (0 < i) \\<bind>\n                         (\\<lambda>_. mop_list_get pq (i - 1)))\n                    j \\<bind>\n                   (\\<lambda>k.\n                       ASSERT\n                        (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                         hmr_invar h) \\<bind>\n                       (\\<lambda>_.\n                           RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                       RETURN) \\<bind>\n                   (\\<lambda>v. RETURN (prio v)) \\<bind>\n                   (\\<lambda>pj.\n                       (if j < len\n                        then (case h of\n                              (pq, m) \\<Rightarrow>\n                                \\<lambda>i.\n                                   ASSERT (0 < i) \\<bind>\n                                   (\\<lambda>_. mop_list_get pq (i - 1)))\n                              (Suc j) \\<bind>\n                             (\\<lambda>k.\n                                 ASSERT\n                                  (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                                   hmr_invar h) \\<bind>\n                                 (\\<lambda>_.\n                                     RETURN\n(the (heapmap_\\<alpha> h k))) \\<bind>\n                                 RETURN) \\<bind>\n                             (\\<lambda>v. RETURN (prio v)) \\<bind>\n                             (\\<lambda>psj.\n                                 if psj < pj then RETURN (j + 1)\n                                 else RETURN j)\n                        else RETURN j) \\<bind>\n                       (\\<lambda>j.\n                           (case h of\n                            (pq, m) \\<Rightarrow>\n                              \\<lambda>i.\n                                 ASSERT (0 < i) \\<bind>\n                                 (\\<lambda>_. mop_list_get pq (i - 1)))\n                            j \\<bind>\n                           (\\<lambda>k.\n                               ASSERT\n                                (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                                 hmr_invar h) \\<bind>\n                               (\\<lambda>_.\n                                   RETURN\n                                    (the (heapmap_\\<alpha> h k))) \\<bind>\n                               RETURN) \\<bind>\n                           (\\<lambda>v. RETURN (prio v)) \\<bind>\n                           (\\<lambda>pj.\n                               (case h of\n                                (pq, m) \\<Rightarrow>\n                                  \\<lambda>i.\n                                     ASSERT (0 < i) \\<bind>\n                                     (\\<lambda>_. mop_list_get pq (i - 1)))\n                                k \\<bind>\n                               (\\<lambda>k.\n                                   ASSERT\n                                    (heapmap_\\<alpha> h k \\<noteq>\n                                     None \\<and>\n                                     hmr_invar h) \\<bind>\n                                   (\\<lambda>_.\n RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                                   RETURN) \\<bind>\n                               (\\<lambda>v. RETURN (prio v)) \\<bind>\n                               (\\<lambda>pk.\n                                   if pj < pk\n                                   then (case h of\n   (pq, m) \\<Rightarrow>\n     \\<lambda>i j.\n        ASSERT (hm_valid (pq, m) i) \\<bind>\n        (\\<lambda>_.\n            ASSERT (hm_valid (pq, m) j) \\<bind>\n            (\\<lambda>_.\n                ASSERT (hmr_invar (pq, m)) \\<bind>\n                (\\<lambda>_.\n                    mop_list_swap pq (i - 1) (j - 1) \\<bind>\n                    (\\<lambda>pq. RETURN (pq, m))))))\n   k j \\<bind>\n  (\\<lambda>h. D (h, j))\n                                   else RETURN h))))\n           else RETURN h))\n((a, b), ba) \\<le>\\<^sub>n\n                                     SPEC\n(\\<lambda>hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm);\n        2 * x2b - Suc 0 < (case hm of (pq, uu_) \\<Rightarrow> length pq);\n        2 * x2b < (case hm of (pq, uu_) \\<Rightarrow> length pq);\n        \\<not> prio ya < prio y; 0 < x2b;\n        x2b - Suc 0 < (case hm of (pq, uu_) \\<Rightarrow> length pq);\n        prio y < prio yb; hmr_invar (x1a, x2);\n        heapmap_\\<alpha> hm (x1a ! (2 * x2b - Suc 0)) = Some y;\n        heapmap_\\<alpha> hm (x1a ! (2 * x2b)) = Some ya;\n        heapmap_\\<alpha> hm (x1a ! (x2b - Suc 0)) = Some yb; 0 < i;\n        i \\<le> (case hm of (pq, uu_) \\<Rightarrow> length pq);\n        heapmap_\\<alpha> (x1a, x2) = heapmap_\\<alpha> hm;\n        length x1a = (case hm of (pq, uu_) \\<Rightarrow> length pq)\\<rbrakk>\n       \\<Longrightarrow> REC\\<^sub>T\n                          (\\<lambda>D (h, k).\n                              ASSERT\n                               (0 < k \\<and>\n                                k \\<le> (case h of\n   (pq, uu_) \\<Rightarrow> length pq)) \\<bind>\n                              (\\<lambda>_.\n                                  let len =\n  case h of (pq, uu_) \\<Rightarrow> length pq\n                                  in if 2 * k \\<le> len\n                                     then let j = 2 * k\n    in (case h of\n        (pq, m) \\<Rightarrow>\n          \\<lambda>i.\n             ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_get pq (i - 1)))\n        j \\<bind>\n       (\\<lambda>k.\n           ASSERT\n            (heapmap_\\<alpha> h k \\<noteq> None \\<and> hmr_invar h) \\<bind>\n           (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n           RETURN) \\<bind>\n       (\\<lambda>v. RETURN (prio v)) \\<bind>\n       (\\<lambda>pj.\n           (if j < len\n            then (case h of\n                  (pq, m) \\<Rightarrow>\n                    \\<lambda>i.\n                       ASSERT (0 < i) \\<bind>\n                       (\\<lambda>_. mop_list_get pq (i - 1)))\n                  (Suc j) \\<bind>\n                 (\\<lambda>k.\n                     ASSERT\n                      (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                       hmr_invar h) \\<bind>\n                     (\\<lambda>_.\n                         RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                     RETURN) \\<bind>\n                 (\\<lambda>v. RETURN (prio v)) \\<bind>\n                 (\\<lambda>psj.\n                     if psj < pj then RETURN (j + 1) else RETURN j)\n            else RETURN j) \\<bind>\n           (\\<lambda>j.\n               (case h of\n                (pq, m) \\<Rightarrow>\n                  \\<lambda>i.\n                     ASSERT (0 < i) \\<bind>\n                     (\\<lambda>_. mop_list_get pq (i - 1)))\n                j \\<bind>\n               (\\<lambda>k.\n                   ASSERT\n                    (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                     hmr_invar h) \\<bind>\n                   (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                   RETURN) \\<bind>\n               (\\<lambda>v. RETURN (prio v)) \\<bind>\n               (\\<lambda>pj.\n                   (case h of\n                    (pq, m) \\<Rightarrow>\n                      \\<lambda>i.\n                         ASSERT (0 < i) \\<bind>\n                         (\\<lambda>_. mop_list_get pq (i - 1)))\n                    k \\<bind>\n                   (\\<lambda>k.\n                       ASSERT\n                        (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                         hmr_invar h) \\<bind>\n                       (\\<lambda>_.\n                           RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                       RETURN) \\<bind>\n                   (\\<lambda>v. RETURN (prio v)) \\<bind>\n                   (\\<lambda>pk.\n                       if pj < pk\n                       then (case h of\n                             (pq, m) \\<Rightarrow>\n                               \\<lambda>i j.\n                                  ASSERT (hm_valid (pq, m) i) \\<bind>\n                                  (\\<lambda>_.\nASSERT (hm_valid (pq, m) j) \\<bind>\n(\\<lambda>_.\n    ASSERT (hmr_invar (pq, m)) \\<bind>\n    (\\<lambda>_.\n        mop_list_swap pq (i - 1) (j - 1) \\<bind>\n        (\\<lambda>pq. RETURN (pq, m))))))\n                             k j \\<bind>\n                            (\\<lambda>h. D (h, j))\n                       else RETURN h))))\n                                     else RETURN h))\n                          ((swap x1a (x2b - Suc 0) (2 * x2b - Suc 0), x2),\n                           2 * x2b) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>hm'.\n                              heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm)\n 3. \\<And>x1a x2 x2b y ya.\n       \\<lbrakk>\\<And>a b ba.\n                   \\<lbrakk>0 < ba \\<and>\n                            ba \\<le> length a \\<and>\n                            heapmap_\\<alpha> (a, b) =\n                            heapmap_\\<alpha> hm \\<and>\n                            length a =\n                            (case hm of (pq, uu_) \\<Rightarrow> length pq);\n                    (case hm of (pq, uu_) \\<Rightarrow> length pq) - ba\n                    < (case hm of (pq, uu_) \\<Rightarrow> length pq) -\n                      x2b\\<rbrakk>\n                   \\<Longrightarrow> REC\\<^sub>T\n(\\<lambda>D (h, k).\n    ASSERT\n     (0 < k \\<and>\n      k \\<le> (case h of (pq, uu_) \\<Rightarrow> length pq)) \\<bind>\n    (\\<lambda>_.\n        let len = case h of (pq, uu_) \\<Rightarrow> length pq\n        in if 2 * k \\<le> len\n           then let j = 2 * k\n                in (case h of\n                    (pq, m) \\<Rightarrow>\n                      \\<lambda>i.\n                         ASSERT (0 < i) \\<bind>\n                         (\\<lambda>_. mop_list_get pq (i - 1)))\n                    j \\<bind>\n                   (\\<lambda>k.\n                       ASSERT\n                        (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                         hmr_invar h) \\<bind>\n                       (\\<lambda>_.\n                           RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                       RETURN) \\<bind>\n                   (\\<lambda>v. RETURN (prio v)) \\<bind>\n                   (\\<lambda>pj.\n                       (if j < len\n                        then (case h of\n                              (pq, m) \\<Rightarrow>\n                                \\<lambda>i.\n                                   ASSERT (0 < i) \\<bind>\n                                   (\\<lambda>_. mop_list_get pq (i - 1)))\n                              (Suc j) \\<bind>\n                             (\\<lambda>k.\n                                 ASSERT\n                                  (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                                   hmr_invar h) \\<bind>\n                                 (\\<lambda>_.\n                                     RETURN\n(the (heapmap_\\<alpha> h k))) \\<bind>\n                                 RETURN) \\<bind>\n                             (\\<lambda>v. RETURN (prio v)) \\<bind>\n                             (\\<lambda>psj.\n                                 if psj < pj then RETURN (j + 1)\n                                 else RETURN j)\n                        else RETURN j) \\<bind>\n                       (\\<lambda>j.\n                           (case h of\n                            (pq, m) \\<Rightarrow>\n                              \\<lambda>i.\n                                 ASSERT (0 < i) \\<bind>\n                                 (\\<lambda>_. mop_list_get pq (i - 1)))\n                            j \\<bind>\n                           (\\<lambda>k.\n                               ASSERT\n                                (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                                 hmr_invar h) \\<bind>\n                               (\\<lambda>_.\n                                   RETURN\n                                    (the (heapmap_\\<alpha> h k))) \\<bind>\n                               RETURN) \\<bind>\n                           (\\<lambda>v. RETURN (prio v)) \\<bind>\n                           (\\<lambda>pj.\n                               (case h of\n                                (pq, m) \\<Rightarrow>\n                                  \\<lambda>i.\n                                     ASSERT (0 < i) \\<bind>\n                                     (\\<lambda>_. mop_list_get pq (i - 1)))\n                                k \\<bind>\n                               (\\<lambda>k.\n                                   ASSERT\n                                    (heapmap_\\<alpha> h k \\<noteq>\n                                     None \\<and>\n                                     hmr_invar h) \\<bind>\n                                   (\\<lambda>_.\n RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                                   RETURN) \\<bind>\n                               (\\<lambda>v. RETURN (prio v)) \\<bind>\n                               (\\<lambda>pk.\n                                   if pj < pk\n                                   then (case h of\n   (pq, m) \\<Rightarrow>\n     \\<lambda>i j.\n        ASSERT (hm_valid (pq, m) i) \\<bind>\n        (\\<lambda>_.\n            ASSERT (hm_valid (pq, m) j) \\<bind>\n            (\\<lambda>_.\n                ASSERT (hmr_invar (pq, m)) \\<bind>\n                (\\<lambda>_.\n                    mop_list_swap pq (i - 1) (j - 1) \\<bind>\n                    (\\<lambda>pq. RETURN (pq, m))))))\n   k j \\<bind>\n  (\\<lambda>h. D (h, j))\n                                   else RETURN h))))\n           else RETURN h))\n((a, b), ba) \\<le>\\<^sub>n\n                                     SPEC\n(\\<lambda>hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm);\n        2 * x2b = (case hm of (pq, uu_) \\<Rightarrow> length pq);\n        x2b - Suc 0 < (case hm of (pq, uu_) \\<Rightarrow> length pq);\n        prio y < prio ya; hmr_invar (x1a, x2);\n        heapmap_\\<alpha> hm\n         (x1a ! ((case hm of (pq, uu_) \\<Rightarrow> length pq) - Suc 0)) =\n        Some y;\n        heapmap_\\<alpha> hm (x1a ! (x2b - Suc 0)) = Some ya; 0 < i;\n        i \\<le> (case hm of (pq, uu_) \\<Rightarrow> length pq);\n        heapmap_\\<alpha> (x1a, x2) = heapmap_\\<alpha> hm;\n        length x1a = (case hm of (pq, uu_) \\<Rightarrow> length pq)\\<rbrakk>\n       \\<Longrightarrow> REC\\<^sub>T\n                          (\\<lambda>D (h, k).\n                              ASSERT\n                               (0 < k \\<and>\n                                k \\<le> (case h of\n   (pq, uu_) \\<Rightarrow> length pq)) \\<bind>\n                              (\\<lambda>_.\n                                  let len =\n  case h of (pq, uu_) \\<Rightarrow> length pq\n                                  in if 2 * k \\<le> len\n                                     then let j = 2 * k\n    in (case h of\n        (pq, m) \\<Rightarrow>\n          \\<lambda>i.\n             ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_get pq (i - 1)))\n        j \\<bind>\n       (\\<lambda>k.\n           ASSERT\n            (heapmap_\\<alpha> h k \\<noteq> None \\<and> hmr_invar h) \\<bind>\n           (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n           RETURN) \\<bind>\n       (\\<lambda>v. RETURN (prio v)) \\<bind>\n       (\\<lambda>pj.\n           (if j < len\n            then (case h of\n                  (pq, m) \\<Rightarrow>\n                    \\<lambda>i.\n                       ASSERT (0 < i) \\<bind>\n                       (\\<lambda>_. mop_list_get pq (i - 1)))\n                  (Suc j) \\<bind>\n                 (\\<lambda>k.\n                     ASSERT\n                      (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                       hmr_invar h) \\<bind>\n                     (\\<lambda>_.\n                         RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                     RETURN) \\<bind>\n                 (\\<lambda>v. RETURN (prio v)) \\<bind>\n                 (\\<lambda>psj.\n                     if psj < pj then RETURN (j + 1) else RETURN j)\n            else RETURN j) \\<bind>\n           (\\<lambda>j.\n               (case h of\n                (pq, m) \\<Rightarrow>\n                  \\<lambda>i.\n                     ASSERT (0 < i) \\<bind>\n                     (\\<lambda>_. mop_list_get pq (i - 1)))\n                j \\<bind>\n               (\\<lambda>k.\n                   ASSERT\n                    (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                     hmr_invar h) \\<bind>\n                   (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                   RETURN) \\<bind>\n               (\\<lambda>v. RETURN (prio v)) \\<bind>\n               (\\<lambda>pj.\n                   (case h of\n                    (pq, m) \\<Rightarrow>\n                      \\<lambda>i.\n                         ASSERT (0 < i) \\<bind>\n                         (\\<lambda>_. mop_list_get pq (i - 1)))\n                    k \\<bind>\n                   (\\<lambda>k.\n                       ASSERT\n                        (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                         hmr_invar h) \\<bind>\n                       (\\<lambda>_.\n                           RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                       RETURN) \\<bind>\n                   (\\<lambda>v. RETURN (prio v)) \\<bind>\n                   (\\<lambda>pk.\n                       if pj < pk\n                       then (case h of\n                             (pq, m) \\<Rightarrow>\n                               \\<lambda>i j.\n                                  ASSERT (hm_valid (pq, m) i) \\<bind>\n                                  (\\<lambda>_.\nASSERT (hm_valid (pq, m) j) \\<bind>\n(\\<lambda>_.\n    ASSERT (hmr_invar (pq, m)) \\<bind>\n    (\\<lambda>_.\n        mop_list_swap pq (i - 1) (j - 1) \\<bind>\n        (\\<lambda>pq. RETURN (pq, m))))))\n                             k j \\<bind>\n                            (\\<lambda>h. D (h, j))\n                       else RETURN h))))\n                                     else RETURN h))\n                          ((swap x1a (x2b - Suc 0)\n                             ((case hm of\n                               (pq, uu_) \\<Rightarrow> length pq) -\n                              Suc 0),\n                            x2),\n                           case hm of\n                           (pq, uu_) \\<Rightarrow> length pq) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>hm'.\n                              heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm)", "apply rprems"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1a x2 x2b y ya yb.\n       \\<lbrakk>2 * x2b - Suc 0\n                < (case hm of (pq, uu_) \\<Rightarrow> length pq);\n        2 * x2b < (case hm of (pq, uu_) \\<Rightarrow> length pq);\n        prio ya < prio y; 0 < x2b;\n        x2b - Suc 0 < (case hm of (pq, uu_) \\<Rightarrow> length pq);\n        prio ya < prio yb; hmr_invar (x1a, x2);\n        heapmap_\\<alpha> hm (x1a ! (2 * x2b - Suc 0)) = Some y;\n        heapmap_\\<alpha> hm (x1a ! (2 * x2b)) = Some ya;\n        heapmap_\\<alpha> hm (x1a ! (x2b - Suc 0)) = Some yb; 0 < i;\n        i \\<le> (case hm of (pq, uu_) \\<Rightarrow> length pq);\n        heapmap_\\<alpha> (x1a, x2) = heapmap_\\<alpha> hm;\n        length x1a = (case hm of (pq, uu_) \\<Rightarrow> length pq)\\<rbrakk>\n       \\<Longrightarrow> 0 < Suc (2 * x2b) \\<and>\n                         Suc (2 * x2b)\n                         \\<le> length\n                                (swap x1a (x2b - Suc 0) (2 * x2b)) \\<and>\n                         heapmap_\\<alpha>\n                          (swap x1a (x2b - Suc 0) (2 * x2b), x2) =\n                         heapmap_\\<alpha> hm \\<and>\n                         length (swap x1a (x2b - Suc 0) (2 * x2b)) =\n                         (case hm of (pq, uu_) \\<Rightarrow> length pq)\n 2. \\<And>x1a x2 x2b y ya yb.\n       \\<lbrakk>2 * x2b - Suc 0\n                < (case hm of (pq, uu_) \\<Rightarrow> length pq);\n        2 * x2b < (case hm of (pq, uu_) \\<Rightarrow> length pq);\n        prio ya < prio y; 0 < x2b;\n        x2b - Suc 0 < (case hm of (pq, uu_) \\<Rightarrow> length pq);\n        prio ya < prio yb; hmr_invar (x1a, x2);\n        heapmap_\\<alpha> hm (x1a ! (2 * x2b - Suc 0)) = Some y;\n        heapmap_\\<alpha> hm (x1a ! (2 * x2b)) = Some ya;\n        heapmap_\\<alpha> hm (x1a ! (x2b - Suc 0)) = Some yb; 0 < i;\n        i \\<le> (case hm of (pq, uu_) \\<Rightarrow> length pq);\n        heapmap_\\<alpha> (x1a, x2) = heapmap_\\<alpha> hm;\n        length x1a = (case hm of (pq, uu_) \\<Rightarrow> length pq)\\<rbrakk>\n       \\<Longrightarrow> (case hm of (pq, uu_) \\<Rightarrow> length pq) -\n                         Suc (2 * x2b)\n                         < (case hm of (pq, uu_) \\<Rightarrow> length pq) -\n                           x2b\n 3. \\<And>x1a x2 x2b y ya yb.\n       \\<lbrakk>\\<And>a b ba.\n                   \\<lbrakk>0 < ba \\<and>\n                            ba \\<le> length a \\<and>\n                            heapmap_\\<alpha> (a, b) =\n                            heapmap_\\<alpha> hm \\<and>\n                            length a =\n                            (case hm of (pq, uu_) \\<Rightarrow> length pq);\n                    (case hm of (pq, uu_) \\<Rightarrow> length pq) - ba\n                    < (case hm of (pq, uu_) \\<Rightarrow> length pq) -\n                      x2b\\<rbrakk>\n                   \\<Longrightarrow> REC\\<^sub>T\n(\\<lambda>D (h, k).\n    ASSERT\n     (0 < k \\<and>\n      k \\<le> (case h of (pq, uu_) \\<Rightarrow> length pq)) \\<bind>\n    (\\<lambda>_.\n        let len = case h of (pq, uu_) \\<Rightarrow> length pq\n        in if 2 * k \\<le> len\n           then let j = 2 * k\n                in (case h of\n                    (pq, m) \\<Rightarrow>\n                      \\<lambda>i.\n                         ASSERT (0 < i) \\<bind>\n                         (\\<lambda>_. mop_list_get pq (i - 1)))\n                    j \\<bind>\n                   (\\<lambda>k.\n                       ASSERT\n                        (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                         hmr_invar h) \\<bind>\n                       (\\<lambda>_.\n                           RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                       RETURN) \\<bind>\n                   (\\<lambda>v. RETURN (prio v)) \\<bind>\n                   (\\<lambda>pj.\n                       (if j < len\n                        then (case h of\n                              (pq, m) \\<Rightarrow>\n                                \\<lambda>i.\n                                   ASSERT (0 < i) \\<bind>\n                                   (\\<lambda>_. mop_list_get pq (i - 1)))\n                              (Suc j) \\<bind>\n                             (\\<lambda>k.\n                                 ASSERT\n                                  (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                                   hmr_invar h) \\<bind>\n                                 (\\<lambda>_.\n                                     RETURN\n(the (heapmap_\\<alpha> h k))) \\<bind>\n                                 RETURN) \\<bind>\n                             (\\<lambda>v. RETURN (prio v)) \\<bind>\n                             (\\<lambda>psj.\n                                 if psj < pj then RETURN (j + 1)\n                                 else RETURN j)\n                        else RETURN j) \\<bind>\n                       (\\<lambda>j.\n                           (case h of\n                            (pq, m) \\<Rightarrow>\n                              \\<lambda>i.\n                                 ASSERT (0 < i) \\<bind>\n                                 (\\<lambda>_. mop_list_get pq (i - 1)))\n                            j \\<bind>\n                           (\\<lambda>k.\n                               ASSERT\n                                (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                                 hmr_invar h) \\<bind>\n                               (\\<lambda>_.\n                                   RETURN\n                                    (the (heapmap_\\<alpha> h k))) \\<bind>\n                               RETURN) \\<bind>\n                           (\\<lambda>v. RETURN (prio v)) \\<bind>\n                           (\\<lambda>pj.\n                               (case h of\n                                (pq, m) \\<Rightarrow>\n                                  \\<lambda>i.\n                                     ASSERT (0 < i) \\<bind>\n                                     (\\<lambda>_. mop_list_get pq (i - 1)))\n                                k \\<bind>\n                               (\\<lambda>k.\n                                   ASSERT\n                                    (heapmap_\\<alpha> h k \\<noteq>\n                                     None \\<and>\n                                     hmr_invar h) \\<bind>\n                                   (\\<lambda>_.\n RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                                   RETURN) \\<bind>\n                               (\\<lambda>v. RETURN (prio v)) \\<bind>\n                               (\\<lambda>pk.\n                                   if pj < pk\n                                   then (case h of\n   (pq, m) \\<Rightarrow>\n     \\<lambda>i j.\n        ASSERT (hm_valid (pq, m) i) \\<bind>\n        (\\<lambda>_.\n            ASSERT (hm_valid (pq, m) j) \\<bind>\n            (\\<lambda>_.\n                ASSERT (hmr_invar (pq, m)) \\<bind>\n                (\\<lambda>_.\n                    mop_list_swap pq (i - 1) (j - 1) \\<bind>\n                    (\\<lambda>pq. RETURN (pq, m))))))\n   k j \\<bind>\n  (\\<lambda>h. D (h, j))\n                                   else RETURN h))))\n           else RETURN h))\n((a, b), ba) \\<le>\\<^sub>n\n                                     SPEC\n(\\<lambda>hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm);\n        2 * x2b - Suc 0 < (case hm of (pq, uu_) \\<Rightarrow> length pq);\n        2 * x2b < (case hm of (pq, uu_) \\<Rightarrow> length pq);\n        \\<not> prio ya < prio y; 0 < x2b;\n        x2b - Suc 0 < (case hm of (pq, uu_) \\<Rightarrow> length pq);\n        prio y < prio yb; hmr_invar (x1a, x2);\n        heapmap_\\<alpha> hm (x1a ! (2 * x2b - Suc 0)) = Some y;\n        heapmap_\\<alpha> hm (x1a ! (2 * x2b)) = Some ya;\n        heapmap_\\<alpha> hm (x1a ! (x2b - Suc 0)) = Some yb; 0 < i;\n        i \\<le> (case hm of (pq, uu_) \\<Rightarrow> length pq);\n        heapmap_\\<alpha> (x1a, x2) = heapmap_\\<alpha> hm;\n        length x1a = (case hm of (pq, uu_) \\<Rightarrow> length pq)\\<rbrakk>\n       \\<Longrightarrow> REC\\<^sub>T\n                          (\\<lambda>D (h, k).\n                              ASSERT\n                               (0 < k \\<and>\n                                k \\<le> (case h of\n   (pq, uu_) \\<Rightarrow> length pq)) \\<bind>\n                              (\\<lambda>_.\n                                  let len =\n  case h of (pq, uu_) \\<Rightarrow> length pq\n                                  in if 2 * k \\<le> len\n                                     then let j = 2 * k\n    in (case h of\n        (pq, m) \\<Rightarrow>\n          \\<lambda>i.\n             ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_get pq (i - 1)))\n        j \\<bind>\n       (\\<lambda>k.\n           ASSERT\n            (heapmap_\\<alpha> h k \\<noteq> None \\<and> hmr_invar h) \\<bind>\n           (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n           RETURN) \\<bind>\n       (\\<lambda>v. RETURN (prio v)) \\<bind>\n       (\\<lambda>pj.\n           (if j < len\n            then (case h of\n                  (pq, m) \\<Rightarrow>\n                    \\<lambda>i.\n                       ASSERT (0 < i) \\<bind>\n                       (\\<lambda>_. mop_list_get pq (i - 1)))\n                  (Suc j) \\<bind>\n                 (\\<lambda>k.\n                     ASSERT\n                      (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                       hmr_invar h) \\<bind>\n                     (\\<lambda>_.\n                         RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                     RETURN) \\<bind>\n                 (\\<lambda>v. RETURN (prio v)) \\<bind>\n                 (\\<lambda>psj.\n                     if psj < pj then RETURN (j + 1) else RETURN j)\n            else RETURN j) \\<bind>\n           (\\<lambda>j.\n               (case h of\n                (pq, m) \\<Rightarrow>\n                  \\<lambda>i.\n                     ASSERT (0 < i) \\<bind>\n                     (\\<lambda>_. mop_list_get pq (i - 1)))\n                j \\<bind>\n               (\\<lambda>k.\n                   ASSERT\n                    (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                     hmr_invar h) \\<bind>\n                   (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                   RETURN) \\<bind>\n               (\\<lambda>v. RETURN (prio v)) \\<bind>\n               (\\<lambda>pj.\n                   (case h of\n                    (pq, m) \\<Rightarrow>\n                      \\<lambda>i.\n                         ASSERT (0 < i) \\<bind>\n                         (\\<lambda>_. mop_list_get pq (i - 1)))\n                    k \\<bind>\n                   (\\<lambda>k.\n                       ASSERT\n                        (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                         hmr_invar h) \\<bind>\n                       (\\<lambda>_.\n                           RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                       RETURN) \\<bind>\n                   (\\<lambda>v. RETURN (prio v)) \\<bind>\n                   (\\<lambda>pk.\n                       if pj < pk\n                       then (case h of\n                             (pq, m) \\<Rightarrow>\n                               \\<lambda>i j.\n                                  ASSERT (hm_valid (pq, m) i) \\<bind>\n                                  (\\<lambda>_.\nASSERT (hm_valid (pq, m) j) \\<bind>\n(\\<lambda>_.\n    ASSERT (hmr_invar (pq, m)) \\<bind>\n    (\\<lambda>_.\n        mop_list_swap pq (i - 1) (j - 1) \\<bind>\n        (\\<lambda>pq. RETURN (pq, m))))))\n                             k j \\<bind>\n                            (\\<lambda>h. D (h, j))\n                       else RETURN h))))\n                                     else RETURN h))\n                          ((swap x1a (x2b - Suc 0) (2 * x2b - Suc 0), x2),\n                           2 * x2b) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>hm'.\n                              heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm)\n 4. \\<And>x1a x2 x2b y ya.\n       \\<lbrakk>\\<And>a b ba.\n                   \\<lbrakk>0 < ba \\<and>\n                            ba \\<le> length a \\<and>\n                            heapmap_\\<alpha> (a, b) =\n                            heapmap_\\<alpha> hm \\<and>\n                            length a =\n                            (case hm of (pq, uu_) \\<Rightarrow> length pq);\n                    (case hm of (pq, uu_) \\<Rightarrow> length pq) - ba\n                    < (case hm of (pq, uu_) \\<Rightarrow> length pq) -\n                      x2b\\<rbrakk>\n                   \\<Longrightarrow> REC\\<^sub>T\n(\\<lambda>D (h, k).\n    ASSERT\n     (0 < k \\<and>\n      k \\<le> (case h of (pq, uu_) \\<Rightarrow> length pq)) \\<bind>\n    (\\<lambda>_.\n        let len = case h of (pq, uu_) \\<Rightarrow> length pq\n        in if 2 * k \\<le> len\n           then let j = 2 * k\n                in (case h of\n                    (pq, m) \\<Rightarrow>\n                      \\<lambda>i.\n                         ASSERT (0 < i) \\<bind>\n                         (\\<lambda>_. mop_list_get pq (i - 1)))\n                    j \\<bind>\n                   (\\<lambda>k.\n                       ASSERT\n                        (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                         hmr_invar h) \\<bind>\n                       (\\<lambda>_.\n                           RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                       RETURN) \\<bind>\n                   (\\<lambda>v. RETURN (prio v)) \\<bind>\n                   (\\<lambda>pj.\n                       (if j < len\n                        then (case h of\n                              (pq, m) \\<Rightarrow>\n                                \\<lambda>i.\n                                   ASSERT (0 < i) \\<bind>\n                                   (\\<lambda>_. mop_list_get pq (i - 1)))\n                              (Suc j) \\<bind>\n                             (\\<lambda>k.\n                                 ASSERT\n                                  (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                                   hmr_invar h) \\<bind>\n                                 (\\<lambda>_.\n                                     RETURN\n(the (heapmap_\\<alpha> h k))) \\<bind>\n                                 RETURN) \\<bind>\n                             (\\<lambda>v. RETURN (prio v)) \\<bind>\n                             (\\<lambda>psj.\n                                 if psj < pj then RETURN (j + 1)\n                                 else RETURN j)\n                        else RETURN j) \\<bind>\n                       (\\<lambda>j.\n                           (case h of\n                            (pq, m) \\<Rightarrow>\n                              \\<lambda>i.\n                                 ASSERT (0 < i) \\<bind>\n                                 (\\<lambda>_. mop_list_get pq (i - 1)))\n                            j \\<bind>\n                           (\\<lambda>k.\n                               ASSERT\n                                (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                                 hmr_invar h) \\<bind>\n                               (\\<lambda>_.\n                                   RETURN\n                                    (the (heapmap_\\<alpha> h k))) \\<bind>\n                               RETURN) \\<bind>\n                           (\\<lambda>v. RETURN (prio v)) \\<bind>\n                           (\\<lambda>pj.\n                               (case h of\n                                (pq, m) \\<Rightarrow>\n                                  \\<lambda>i.\n                                     ASSERT (0 < i) \\<bind>\n                                     (\\<lambda>_. mop_list_get pq (i - 1)))\n                                k \\<bind>\n                               (\\<lambda>k.\n                                   ASSERT\n                                    (heapmap_\\<alpha> h k \\<noteq>\n                                     None \\<and>\n                                     hmr_invar h) \\<bind>\n                                   (\\<lambda>_.\n RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                                   RETURN) \\<bind>\n                               (\\<lambda>v. RETURN (prio v)) \\<bind>\n                               (\\<lambda>pk.\n                                   if pj < pk\n                                   then (case h of\n   (pq, m) \\<Rightarrow>\n     \\<lambda>i j.\n        ASSERT (hm_valid (pq, m) i) \\<bind>\n        (\\<lambda>_.\n            ASSERT (hm_valid (pq, m) j) \\<bind>\n            (\\<lambda>_.\n                ASSERT (hmr_invar (pq, m)) \\<bind>\n                (\\<lambda>_.\n                    mop_list_swap pq (i - 1) (j - 1) \\<bind>\n                    (\\<lambda>pq. RETURN (pq, m))))))\n   k j \\<bind>\n  (\\<lambda>h. D (h, j))\n                                   else RETURN h))))\n           else RETURN h))\n((a, b), ba) \\<le>\\<^sub>n\n                                     SPEC\n(\\<lambda>hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm);\n        2 * x2b = (case hm of (pq, uu_) \\<Rightarrow> length pq);\n        x2b - Suc 0 < (case hm of (pq, uu_) \\<Rightarrow> length pq);\n        prio y < prio ya; hmr_invar (x1a, x2);\n        heapmap_\\<alpha> hm\n         (x1a ! ((case hm of (pq, uu_) \\<Rightarrow> length pq) - Suc 0)) =\n        Some y;\n        heapmap_\\<alpha> hm (x1a ! (x2b - Suc 0)) = Some ya; 0 < i;\n        i \\<le> (case hm of (pq, uu_) \\<Rightarrow> length pq);\n        heapmap_\\<alpha> (x1a, x2) = heapmap_\\<alpha> hm;\n        length x1a = (case hm of (pq, uu_) \\<Rightarrow> length pq)\\<rbrakk>\n       \\<Longrightarrow> REC\\<^sub>T\n                          (\\<lambda>D (h, k).\n                              ASSERT\n                               (0 < k \\<and>\n                                k \\<le> (case h of\n   (pq, uu_) \\<Rightarrow> length pq)) \\<bind>\n                              (\\<lambda>_.\n                                  let len =\n  case h of (pq, uu_) \\<Rightarrow> length pq\n                                  in if 2 * k \\<le> len\n                                     then let j = 2 * k\n    in (case h of\n        (pq, m) \\<Rightarrow>\n          \\<lambda>i.\n             ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_get pq (i - 1)))\n        j \\<bind>\n       (\\<lambda>k.\n           ASSERT\n            (heapmap_\\<alpha> h k \\<noteq> None \\<and> hmr_invar h) \\<bind>\n           (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n           RETURN) \\<bind>\n       (\\<lambda>v. RETURN (prio v)) \\<bind>\n       (\\<lambda>pj.\n           (if j < len\n            then (case h of\n                  (pq, m) \\<Rightarrow>\n                    \\<lambda>i.\n                       ASSERT (0 < i) \\<bind>\n                       (\\<lambda>_. mop_list_get pq (i - 1)))\n                  (Suc j) \\<bind>\n                 (\\<lambda>k.\n                     ASSERT\n                      (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                       hmr_invar h) \\<bind>\n                     (\\<lambda>_.\n                         RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                     RETURN) \\<bind>\n                 (\\<lambda>v. RETURN (prio v)) \\<bind>\n                 (\\<lambda>psj.\n                     if psj < pj then RETURN (j + 1) else RETURN j)\n            else RETURN j) \\<bind>\n           (\\<lambda>j.\n               (case h of\n                (pq, m) \\<Rightarrow>\n                  \\<lambda>i.\n                     ASSERT (0 < i) \\<bind>\n                     (\\<lambda>_. mop_list_get pq (i - 1)))\n                j \\<bind>\n               (\\<lambda>k.\n                   ASSERT\n                    (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                     hmr_invar h) \\<bind>\n                   (\\<lambda>_. RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                   RETURN) \\<bind>\n               (\\<lambda>v. RETURN (prio v)) \\<bind>\n               (\\<lambda>pj.\n                   (case h of\n                    (pq, m) \\<Rightarrow>\n                      \\<lambda>i.\n                         ASSERT (0 < i) \\<bind>\n                         (\\<lambda>_. mop_list_get pq (i - 1)))\n                    k \\<bind>\n                   (\\<lambda>k.\n                       ASSERT\n                        (heapmap_\\<alpha> h k \\<noteq> None \\<and>\n                         hmr_invar h) \\<bind>\n                       (\\<lambda>_.\n                           RETURN (the (heapmap_\\<alpha> h k))) \\<bind>\n                       RETURN) \\<bind>\n                   (\\<lambda>v. RETURN (prio v)) \\<bind>\n                   (\\<lambda>pk.\n                       if pj < pk\n                       then (case h of\n                             (pq, m) \\<Rightarrow>\n                               \\<lambda>i j.\n                                  ASSERT (hm_valid (pq, m) i) \\<bind>\n                                  (\\<lambda>_.\nASSERT (hm_valid (pq, m) j) \\<bind>\n(\\<lambda>_.\n    ASSERT (hmr_invar (pq, m)) \\<bind>\n    (\\<lambda>_.\n        mop_list_swap pq (i - 1) (j - 1) \\<bind>\n        (\\<lambda>pq. RETURN (pq, m))))))\n                             k j \\<bind>\n                            (\\<lambda>h. D (h, j))\n                       else RETURN h))))\n                                     else RETURN h))\n                          ((swap x1a (x2b - Suc 0)\n                             ((case hm of\n                               (pq, uu_) \\<Rightarrow> length pq) -\n                              Suc 0),\n                            x2),\n                           case hm of\n                           (pq, uu_) \\<Rightarrow> length pq) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>hm'.\n                              heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm)", "apply (vc_solve simp: heapmap_\\<alpha>_def h.parent_def split: prod.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2b y ya yb x1 x2a.\n       \\<lbrakk>2 * x2b < length x1; prio ya < prio y; 0 < x2b;\n        x2b - Suc 0 < length x1; prio ya < prio yb; hmr_invar (x1a, x2a);\n        x2a (x1a ! (2 * x2b - Suc 0)) = Some y;\n        x2a (x1a ! (2 * x2b)) = Some ya;\n        x2a (x1a ! (x2b - Suc 0)) = Some yb; 0 < i; i \\<le> length x1;\n        length x1a = length x1; hm = (x1, x2a);\n        2 * x2b - Suc 0 < length x1\\<rbrakk>\n       \\<Longrightarrow> length x1 - Suc (2 * x2b) < length x1 - x2b", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Repair\\<close>"], ["", "definition \"hm_repair_op hm i \\<equiv> do {\n      hm \\<leftarrow> hm_sink_op hm i;\n      hm \\<leftarrow> hm_swim_op hm i;\n      RETURN hm\n    }\""], ["", "lemma hm_repair_op_refine: \"(hm_repair_op, h.repair_op) \\<in> hmr_rel \\<rightarrow> nat_rel \\<rightarrow> \\<langle>hmr_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hm_repair_op, h.repair_op)\n    \\<in> hmr_rel \\<rightarrow>\n          nat_rel \\<rightarrow> \\<langle>hmr_rel\\<rangle>nres_rel", "apply (intro fun_relI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> hm_repair_op a aa\n                         \\<le> \\<Down> hmr_rel (h.repair_op a' a'a)", "unfolding hm_repair_op_def h.repair_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; (aa, a'a) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> hm_sink_op a aa \\<bind>\n                         (\\<lambda>hm. hm_swim_op hm aa \\<bind> RETURN)\n                         \\<le> \\<Down> hmr_rel\n                                (h.sink_op a' a'a \\<bind>\n                                 (\\<lambda>h.\n                                     h.swim_op h a'a \\<bind> RETURN))", "by refine_rcg"], ["", "lemmas hm_repair_op_refine'[refine] = hm_repair_op_refine[param_fo, THEN nres_relD]"], ["", "lemma hm_repair_op_\\<alpha>_correct: \"hm_repair_op hm i \\<le>\\<^sub>n SPEC (\\<lambda>hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_repair_op hm i \\<le>\\<^sub>n\n    SPEC (\\<lambda>hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm)", "unfolding hm_repair_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_sink_op hm i \\<bind>\n    (\\<lambda>hm. hm_swim_op hm i \\<bind> RETURN) \\<le>\\<^sub>n\n    SPEC (\\<lambda>hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm)", "apply (refine_vcg \n        hm_swim_op_\\<alpha>_correct[THEN leof_trans] \n        hm_sink_op_\\<alpha>_correct[THEN leof_trans])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> {hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm};\n        xa \\<in> {hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> x}\\<rbrakk>\n       \\<Longrightarrow> heapmap_\\<alpha> xa = heapmap_\\<alpha> hm", "by auto"], ["", "subsection \\<open>Operations\\<close>"], ["", "text \\<open>In this section, we define the operations that implement the priority-map interface\\<close>"], ["", "subsubsection \\<open>Empty\\<close>"], ["", "definition hm_empty_op :: \"('k,'v) ahm nres\" \n      where \"hm_empty_op \\<equiv> RETURN ([],Map.empty)\""], ["", "lemma hm_empty_aref: \"(hm_empty_op,RETURN op_map_empty) \\<in> \\<langle>heapmap_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hm_empty_op, RETURN op_map_empty)\n    \\<in> \\<langle>heapmap_rel\\<rangle>nres_rel", "unfolding hm_empty_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN ([], Map.empty), RETURN op_map_empty)\n    \\<in> \\<langle>heapmap_rel\\<rangle>nres_rel", "by (auto simp: heapmap_rel_defs hmr_rel_defs intro: nres_relI)"], ["", "subsubsection \\<open>Insert\\<close>"], ["", "definition hm_insert_op :: \"'k \\<Rightarrow> 'v \\<Rightarrow> ('k,'v) ahm \\<Rightarrow> ('k,'v) ahm nres\" where\n      \"hm_insert_op \\<equiv> \\<lambda>k v h. do {\n        ASSERT (h.heap_invar (hmr_\\<alpha> h));\n        h \\<leftarrow> hm_append_op h k v;\n        let l = hm_length h;\n        h \\<leftarrow> hm_swim_op h l;\n        RETURN h\n      }\""], ["", "lemma hm_insert_op_refine[refine]: \"\\<lbrakk> heapmap_\\<alpha> hm k = None; (hm,h)\\<in>hmr_rel \\<rbrakk> \\<Longrightarrow>\n      hm_insert_op k v hm \\<le> \\<Down>hmr_rel (h.insert_op v h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heapmap_\\<alpha> hm k = None; (hm, h) \\<in> hmr_rel\\<rbrakk>\n    \\<Longrightarrow> hm_insert_op k v hm\n                      \\<le> \\<Down> hmr_rel (h.insert_op v h)", "unfolding hm_insert_op_def h.insert_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heapmap_\\<alpha> hm k = None; (hm, h) \\<in> hmr_rel\\<rbrakk>\n    \\<Longrightarrow> ASSERT (h.heap_invar (hmr_\\<alpha> hm)) \\<bind>\n                      (\\<lambda>_.\n                          hm_append_op hm k v \\<bind>\n                          (\\<lambda>h.\n                              let l = hm_length h\n                              in hm_swim_op h l \\<bind> RETURN))\n                      \\<le> \\<Down> hmr_rel\n                             (ASSERT (h.heap_invar h) \\<bind>\n                              (\\<lambda>_.\n                                  h.append_op h v \\<bind>\n                                  (\\<lambda>h.\nlet l = length h in h.swim_op h l \\<bind> RETURN)))", "apply refine_rcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heapmap_\\<alpha> hm k = None; (hm, h) \\<in> hmr_rel;\n     h.heap_invar h\\<rbrakk>\n    \\<Longrightarrow> h.heap_invar (hmr_\\<alpha> hm)", "by (auto simp: hmr_rel_def br_def)"], ["", "lemma hm_insert_op_aref: \n      \"(hm_insert_op,mop_map_update_new) \\<in> Id \\<rightarrow> Id \\<rightarrow> heapmap_rel \\<rightarrow> \\<langle>heapmap_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hm_insert_op, mop_map_update_new)\n    \\<in> Id \\<rightarrow>\n          Id \\<rightarrow>\n          heapmap_rel \\<rightarrow> \\<langle>heapmap_rel\\<rangle>nres_rel", "apply (intro fun_relI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> Id;\n        (ab, a'b) \\<in> heapmap_rel\\<rbrakk>\n       \\<Longrightarrow> hm_insert_op a aa ab\n                         \\<le> \\<Down> heapmap_rel\n                                (mop_map_update_new a' a'a a'b)", "unfolding mop_map_update_new_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> Id;\n        (ab, a'b) \\<in> heapmap_rel\\<rbrakk>\n       \\<Longrightarrow> hm_insert_op a aa ab\n                         \\<le> \\<Down> heapmap_rel\n                                (ASSERT\n                                  (pre_map_update_new\n                                    ((a', a'a), a'b)) \\<bind>\n                                 (\\<lambda>_.\n                                     RETURN (op_map_update_new a' a'a a'b)))", "apply (rule ASSERT_refine_right)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> Id;\n        (ab, a'b) \\<in> heapmap_rel;\n        pre_map_update_new ((a', a'a), a'b)\\<rbrakk>\n       \\<Longrightarrow> hm_insert_op a aa ab\n                         \\<le> \\<Down> heapmap_rel\n                                (RETURN (op_map_update_new a' a'a a'b))", "apply (rule heapmap_nres_relI''[OF hm_insert_op_refine h.insert_op_correct])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> Id;\n        (ab, a'b) \\<in> heapmap_rel;\n        pre_map_update_new ((a', a'a), a'b)\\<rbrakk>\n       \\<Longrightarrow> heapmap_\\<alpha> ab a = None\n 2. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> Id;\n        (ab, a'b) \\<in> heapmap_rel;\n        pre_map_update_new ((a', a'a), a'b)\\<rbrakk>\n       \\<Longrightarrow> (ab, ?h7 a a' aa a'a ab a'b) \\<in> hmr_rel\n 3. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> Id;\n        (ab, a'b) \\<in> heapmap_rel;\n        pre_map_update_new ((a', a'a), a'b)\\<rbrakk>\n       \\<Longrightarrow> h.heap_invar (?h7 a a' aa a'a ab a'b)\n 4. \\<And>a a' aa a'a ab a'b h'.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> Id;\n        (ab, a'b) \\<in> heapmap_rel; pre_map_update_new ((a', a'a), a'b);\n        h.heap_invar h' \\<and>\n        h.\\<alpha> h' =\n        h.\\<alpha> (?h7 a a' aa a'a ab a'b) + {#aa#}\\<rbrakk>\n       \\<Longrightarrow> h.heap_invar h'\n 5. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> Id;\n        (ab, a'b) \\<in> heapmap_rel;\n        pre_map_update_new ((a', a'a), a'b)\\<rbrakk>\n       \\<Longrightarrow> hm_insert_op a aa ab \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>hm'.\n                              RETURN (heapmap_\\<alpha> hm')\n                              \\<le> RETURN (op_map_update_new a' a'a a'b))", "apply (unfold heapmap_rel_def in_br_conv; clarsimp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> Id;\n        (ab, a'b) \\<in> heapmap_rel;\n        pre_map_update_new ((a', a'a), a'b)\\<rbrakk>\n       \\<Longrightarrow> (ab, ?h7 a a' aa a'a ab a'b) \\<in> hmr_rel\n 2. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> Id;\n        (ab, a'b) \\<in> heapmap_rel;\n        pre_map_update_new ((a', a'a), a'b)\\<rbrakk>\n       \\<Longrightarrow> h.heap_invar (?h7 a a' aa a'a ab a'b)\n 3. \\<And>a a' aa a'a ab a'b h'.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> Id;\n        (ab, a'b) \\<in> heapmap_rel; pre_map_update_new ((a', a'a), a'b);\n        h.heap_invar h' \\<and>\n        h.\\<alpha> h' =\n        h.\\<alpha> (?h7 a a' aa a'a ab a'b) + {#aa#}\\<rbrakk>\n       \\<Longrightarrow> h.heap_invar h'\n 4. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> Id;\n        (ab, a'b) \\<in> heapmap_rel;\n        pre_map_update_new ((a', a'a), a'b)\\<rbrakk>\n       \\<Longrightarrow> hm_insert_op a aa ab \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>hm'.\n                              RETURN (heapmap_\\<alpha> hm')\n                              \\<le> RETURN (op_map_update_new a' a'a a'b))", "apply (erule heapmap_hmr_relI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> Id;\n        (ab, a'b) \\<in> heapmap_rel;\n        pre_map_update_new ((a', a'a), a'b)\\<rbrakk>\n       \\<Longrightarrow> h.heap_invar (hmr_\\<alpha> ab)\n 2. \\<And>a a' aa a'a ab a'b h'.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> Id;\n        (ab, a'b) \\<in> heapmap_rel; pre_map_update_new ((a', a'a), a'b);\n        h.heap_invar h' \\<and>\n        h.\\<alpha> h' = h.\\<alpha> (hmr_\\<alpha> ab) + {#aa#}\\<rbrakk>\n       \\<Longrightarrow> h.heap_invar h'\n 3. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> Id;\n        (ab, a'b) \\<in> heapmap_rel;\n        pre_map_update_new ((a', a'a), a'b)\\<rbrakk>\n       \\<Longrightarrow> hm_insert_op a aa ab \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>hm'.\n                              RETURN (heapmap_\\<alpha> hm')\n                              \\<le> RETURN (op_map_update_new a' a'a a'b))", "apply (unfold heapmap_rel_def in_br_conv; clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' aa a'a ab a'b h'.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> Id;\n        (ab, a'b) \\<in> heapmap_rel; pre_map_update_new ((a', a'a), a'b);\n        h.heap_invar h' \\<and>\n        h.\\<alpha> h' = h.\\<alpha> (hmr_\\<alpha> ab) + {#aa#}\\<rbrakk>\n       \\<Longrightarrow> h.heap_invar h'\n 2. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> Id;\n        (ab, a'b) \\<in> heapmap_rel;\n        pre_map_update_new ((a', a'a), a'b)\\<rbrakk>\n       \\<Longrightarrow> hm_insert_op a aa ab \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>hm'.\n                              RETURN (heapmap_\\<alpha> hm')\n                              \\<le> RETURN (op_map_update_new a' a'a a'b))", "apply (unfold heapmap_rel_def in_br_conv; clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> Id;\n        (ab, a'b) \\<in> heapmap_rel;\n        pre_map_update_new ((a', a'a), a'b)\\<rbrakk>\n       \\<Longrightarrow> hm_insert_op a aa ab \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>hm'.\n                              RETURN (heapmap_\\<alpha> hm')\n                              \\<le> RETURN (op_map_update_new a' a'a a'b))", "unfolding hm_insert_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> Id;\n        (ab, a'b) \\<in> heapmap_rel;\n        pre_map_update_new ((a', a'a), a'b)\\<rbrakk>\n       \\<Longrightarrow> ASSERT (h.heap_invar (hmr_\\<alpha> ab)) \\<bind>\n                         (\\<lambda>_.\n                             hm_append_op ab a aa \\<bind>\n                             (\\<lambda>h.\n                                 let l = hm_length h\n                                 in hm_swim_op h l \\<bind>\n                                    RETURN)) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>hm'.\n                              RETURN (heapmap_\\<alpha> hm')\n                              \\<le> RETURN (op_map_update_new a' a'a a'b))", "apply (refine_vcg \n        hm_append_op_\\<alpha>_correct[THEN leof_trans]\n        hm_swim_op_\\<alpha>_correct[THEN leof_trans])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b x xa.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> Id;\n        (ab, a'b) \\<in> heapmap_rel; pre_map_update_new ((a', a'a), a'b);\n        h.heap_invar (hmr_\\<alpha> ab);\n        x \\<in> {hm'.\n                 heapmap_\\<alpha> hm' = heapmap_\\<alpha> ab(a \\<mapsto>\n                 aa)};\n        xa \\<in> {hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> x}\\<rbrakk>\n       \\<Longrightarrow> op_map_update_new a' a'a a'b = heapmap_\\<alpha> xa", "apply (unfold heapmap_rel_def in_br_conv; clarsimp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Is-Empty\\<close>"], ["", "lemma hmr_\\<alpha>_empty_iff[simp]: \n      \"hmr_invar hm \\<Longrightarrow> hmr_\\<alpha> hm = [] \\<longleftrightarrow> heapmap_\\<alpha> hm = Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hmr_invar hm \\<Longrightarrow>\n    (hmr_\\<alpha> hm = []) = (heapmap_\\<alpha> hm = Map.empty)", "by (auto \n        simp: hmr_\\<alpha>_def heapmap_invar_def heapmap_\\<alpha>_def hmr_invar_def\n        split: prod.split)"], ["", "definition hm_is_empty_op :: \"('k,'v) ahm \\<Rightarrow> bool nres\" where\n      \"hm_is_empty_op \\<equiv> \\<lambda>hm. do {\n        ASSERT (hmr_invar hm);\n        let l = hm_length hm;\n        RETURN (l=0)\n      }\""], ["", "lemma hm_is_empty_op_refine: \"(hm_is_empty_op, h.is_empty_op) \\<in> hmr_rel \\<rightarrow> \\<langle>bool_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hm_is_empty_op, h.is_empty_op)\n    \\<in> hmr_rel \\<rightarrow> \\<langle>bool_rel\\<rangle>nres_rel", "apply (intro fun_relI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> hmr_rel \\<Longrightarrow>\n       hm_is_empty_op a \\<le> \\<Down> bool_rel (h.is_empty_op a')", "unfolding hm_is_empty_op_def h.is_empty_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> hmr_rel \\<Longrightarrow>\n       ASSERT (hmr_invar a) \\<bind>\n       (\\<lambda>_. let l = hm_length a in RETURN (l = 0))\n       \\<le> \\<Down> bool_rel\n              (ASSERT (h.heap_invar a') \\<bind>\n               (\\<lambda>_. let l = length a' in RETURN (l = 0)))", "apply refine_rcg"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; h.heap_invar a'\\<rbrakk>\n       \\<Longrightarrow> hmr_invar a\n 2. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; h.heap_invar a'; hmr_invar a\\<rbrakk>\n       \\<Longrightarrow> (hm_length a = 0, length a' = 0) \\<in> bool_rel", "apply (auto simp: hmr_rel_defs) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; h.heap_invar a'; hmr_invar a\\<rbrakk>\n       \\<Longrightarrow> (hm_length a = 0, length a' = 0) \\<in> bool_rel", "apply (parametricity add: hm_length_refine)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hm_is_empty_op_aref: \"(hm_is_empty_op, RETURN o op_map_is_empty) \\<in> heapmap_rel \\<rightarrow> \\<langle>bool_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hm_is_empty_op, RETURN \\<circ> op_map_is_empty)\n    \\<in> heapmap_rel \\<rightarrow> \\<langle>bool_rel\\<rangle>nres_rel", "apply (intro fun_relI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> heapmap_rel \\<Longrightarrow>\n       hm_is_empty_op a\n       \\<le> \\<Down> bool_rel ((RETURN \\<circ> op_map_is_empty) a')", "unfolding hm_is_empty_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> heapmap_rel \\<Longrightarrow>\n       ASSERT (hmr_invar a) \\<bind>\n       (\\<lambda>_. let l = hm_length a in RETURN (l = 0))\n       \\<le> \\<Down> bool_rel ((RETURN \\<circ> op_map_is_empty) a')", "apply refine_vcg"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a'. (a, a') \\<in> heapmap_rel \\<Longrightarrow> hmr_invar a\n 2. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> heapmap_rel; hmr_invar a\\<rbrakk>\n       \\<Longrightarrow> RETURN (hm_length a = 0)\n                         \\<le> \\<Down> bool_rel\n                                ((RETURN \\<circ> op_map_is_empty) a')", "apply (auto simp: hmr_rel_defs heapmap_rel_defs hm_length_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Lookup\\<close>"], ["", "definition hm_lookup_op :: \"'k \\<Rightarrow> ('k,'v) ahm \\<Rightarrow> 'v option nres\"\n      where \"hm_lookup_op \\<equiv> \\<lambda>k hm. ASSERT (heapmap_invar hm) \\<then> RETURN (hm_lookup hm k)\""], ["", "lemma hm_lookup_op_aref: \"(hm_lookup_op,RETURN oo op_map_lookup) \\<in> Id \\<rightarrow> heapmap_rel \\<rightarrow> \\<langle>\\<langle>Id\\<rangle>option_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hm_lookup_op, RETURN \\<circ>\\<circ> op_map_lookup)\n    \\<in> Id \\<rightarrow>\n          heapmap_rel \\<rightarrow>\n          \\<langle>\\<langle>Id\\<rangle>option_rel\\<rangle>nres_rel", "apply (intro fun_relI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> heapmap_rel\\<rbrakk>\n       \\<Longrightarrow> hm_lookup_op a aa\n                         \\<le> \\<Down> (\\<langle>Id\\<rangle>option_rel)\n                                ((RETURN \\<circ>\\<circ> op_map_lookup) a'\n                                  a'a)", "unfolding hm_lookup_op_def heapmap_rel_def in_br_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Id;\n        a'a = heapmap_\\<alpha> aa \\<and> heapmap_invar aa\\<rbrakk>\n       \\<Longrightarrow> ASSERT (heapmap_invar aa) \\<bind>\n                         (\\<lambda>_. RETURN (heapmap_\\<alpha> aa a))\n                         \\<le> \\<Down> (\\<langle>Id\\<rangle>option_rel)\n                                ((RETURN \\<circ>\\<circ> op_map_lookup) a'\n                                  a'a)", "apply refine_vcg"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Id;\n        a'a = heapmap_\\<alpha> aa \\<and> heapmap_invar aa\\<rbrakk>\n       \\<Longrightarrow> heapmap_invar aa\n 2. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Id;\n        a'a = heapmap_\\<alpha> aa \\<and> heapmap_invar aa;\n        heapmap_invar aa\\<rbrakk>\n       \\<Longrightarrow> RETURN (heapmap_\\<alpha> aa a)\n                         \\<le> \\<Down> (\\<langle>Id\\<rangle>option_rel)\n                                ((RETURN \\<circ>\\<circ> op_map_lookup) a'\n                                  a'a)", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Contains-Key\\<close>"], ["", "definition \"hm_contains_key_op \\<equiv> \\<lambda>k (pq,m). ASSERT (heapmap_invar (pq,m)) \\<then> RETURN (k\\<in>dom m)\""], ["", "lemma hm_contains_key_op_aref: \"(hm_contains_key_op,RETURN oo op_map_contains_key) \\<in> Id \\<rightarrow> heapmap_rel \\<rightarrow> \\<langle>bool_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hm_contains_key_op, RETURN \\<circ>\\<circ> op_map_contains_key)\n    \\<in> Id \\<rightarrow>\n          heapmap_rel \\<rightarrow> \\<langle>bool_rel\\<rangle>nres_rel", "apply (intro fun_relI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> heapmap_rel\\<rbrakk>\n       \\<Longrightarrow> hm_contains_key_op a aa\n                         \\<le> \\<Down> bool_rel\n                                ((RETURN \\<circ>\\<circ> op_map_contains_key)\n                                  a' a'a)", "unfolding hm_contains_key_op_def heapmap_rel_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Id;\n        (aa, a'a)\n        \\<in> {(c, a).\n               a = (case c of (pq, m) \\<Rightarrow> m) \\<and>\n               hmr_invar c \\<and> h.heap_invar (hmr_\\<alpha> c)}\\<rbrakk>\n       \\<Longrightarrow> (case aa of\n                          (pq, m) \\<Rightarrow>\n                            ASSERT\n                             (hmr_invar (pq, m) \\<and>\n                              h.heap_invar (hmr_\\<alpha> (pq, m))) \\<bind>\n                            (\\<lambda>_. RETURN (a \\<in> dom m)))\n                         \\<le> \\<Down> bool_rel\n                                ((RETURN \\<circ>\\<circ> op_map_contains_key)\n                                  a' a'a)", "apply refine_vcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a a' aa a'a x1 x2.\n       \\<lbrakk>(a, a') \\<in> Id;\n        (aa, a'a)\n        \\<in> {(c, a).\n               a = (case c of (pq, m) \\<Rightarrow> m) \\<and>\n               hmr_invar c \\<and> h.heap_invar (hmr_\\<alpha> c)};\n        aa = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> hmr_invar (x1, x2)\n 2. \\<And>a a' aa a'a x1 x2.\n       \\<lbrakk>(a, a') \\<in> Id;\n        (aa, a'a)\n        \\<in> {(c, a).\n               a = (case c of (pq, m) \\<Rightarrow> m) \\<and>\n               hmr_invar c \\<and> h.heap_invar (hmr_\\<alpha> c)};\n        aa = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> h.heap_invar (hmr_\\<alpha> (x1, x2))\n 3. \\<And>a a' aa a'a x1 x2.\n       \\<lbrakk>(a, a') \\<in> Id;\n        (aa, a'a)\n        \\<in> {(c, a).\n               a = (case c of (pq, m) \\<Rightarrow> m) \\<and>\n               hmr_invar c \\<and> h.heap_invar (hmr_\\<alpha> c)};\n        aa = (x1, x2);\n        hmr_invar (x1, x2) \\<and>\n        h.heap_invar (hmr_\\<alpha> (x1, x2))\\<rbrakk>\n       \\<Longrightarrow> RETURN (a \\<in> dom x2)\n                         \\<le> \\<Down> bool_rel\n                                ((RETURN \\<circ>\\<circ> op_map_contains_key)\n                                  a' a'a)", "by (auto)"], ["", "subsubsection \\<open>Decrease-Key\\<close>"], ["", "definition \"hm_decrease_key_op \\<equiv> \\<lambda>k v hm. do {\n      ASSERT (heapmap_invar hm);\n      ASSERT (heapmap_\\<alpha> hm k \\<noteq> None \\<and> prio v \\<le> prio (the (heapmap_\\<alpha> hm k)));\n      i \\<leftarrow> hm_index_op hm k;\n      hm \\<leftarrow> hm_update_op hm i v;\n      hm_swim_op hm i\n    }\""], ["", "definition (in heapstruct) \"decrease_key_op i v h \\<equiv> do {\n      ASSERT (valid h i \\<and> prio v \\<le> prio_of h i);\n      h \\<leftarrow> update_op h i v;\n      swim_op h i\n    }\""], ["", "lemma (in heapstruct) decrease_key_op_invar: \n      \"\\<lbrakk>heap_invar h; valid h i; prio v \\<le> prio_of h i\\<rbrakk> \\<Longrightarrow> decrease_key_op i v h \\<le> SPEC heap_invar\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heap_invar h; valid h i; prio v \\<le> prio_of h i\\<rbrakk>\n    \\<Longrightarrow> decrease_key_op i v h \\<le> SPEC heap_invar", "unfolding decrease_key_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heap_invar h; valid h i; prio v \\<le> prio_of h i\\<rbrakk>\n    \\<Longrightarrow> ASSERT\n                       (valid h i \\<and> prio v \\<le> prio_of h i) \\<bind>\n                      (\\<lambda>_.\n                          update_op h i v \\<bind> (\\<lambda>h. swim_op h i))\n                      \\<le> SPEC heap_invar", "apply refine_vcg"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>heap_invar h; valid h i; prio v \\<le> prio_of h i;\n        valid h i \\<and> prio v \\<le> prio_of h i; x = update h i v\\<rbrakk>\n       \\<Longrightarrow> swim_invar x i\n 2. \\<And>x xa.\n       \\<lbrakk>heap_invar h; valid h i; prio v \\<le> prio_of h i;\n        valid h i \\<and> prio v \\<le> prio_of h i; x = update h i v;\n        \\<alpha> xa = \\<alpha> x \\<and>\n        heap_invar xa \\<and> length xa = length x\\<rbrakk>\n       \\<Longrightarrow> heap_invar xa", "by (auto simp: swim_invar_decr)"], ["", "lemma index_op_inline_refine:\n      assumes \"heapmap_invar hm\"\n      assumes \"heapmap_\\<alpha> hm k \\<noteq> None\"\n      assumes \"f (hm_index hm k) \\<le> m\"\n      shows \"do {i \\<leftarrow> hm_index_op hm k; f i} \\<le> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_index_op hm k \\<bind> f \\<le> m", "using hm_index_op_correct[of hm k] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>hmr_invar hm; heapmap_\\<alpha> hm k \\<noteq> None\\<rbrakk>\n  \\<Longrightarrow> hm_index_op hm k\n                    \\<le> SPEC (\\<lambda>r. r = hm_index hm k)\n  heapmap_invar hm\n  heapmap_\\<alpha> hm k \\<noteq> None\n  f (hm_index hm k) \\<le> m\n\ngoal (1 subgoal):\n 1. hm_index_op hm k \\<bind> f \\<le> m", "by (auto simp: pw_le_iff refine_pw_simps)"], ["", "lemma hm_decrease_key_op_refine: \n      \"\\<lbrakk>(hm,h)\\<in>hmr_rel; (hm,m)\\<in>heapmap_rel; m k = Some v'\\<rbrakk> \n        \\<Longrightarrow> hm_decrease_key_op k v hm \\<le>\\<Down>hmr_rel (h.decrease_key_op (hm_index hm k) v h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(hm, h) \\<in> hmr_rel; (hm, m) \\<in> heapmap_rel;\n     m k = Some v'\\<rbrakk>\n    \\<Longrightarrow> hm_decrease_key_op k v hm\n                      \\<le> \\<Down> hmr_rel\n                             (h.decrease_key_op (hm_index hm k) v h)", "unfolding hm_decrease_key_op_def h.decrease_key_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(hm, h) \\<in> hmr_rel; (hm, m) \\<in> heapmap_rel;\n     m k = Some v'\\<rbrakk>\n    \\<Longrightarrow> ASSERT (heapmap_invar hm) \\<bind>\n                      (\\<lambda>_.\n                          ASSERT\n                           (heapmap_\\<alpha> hm k \\<noteq> None \\<and>\n                            prio v\n                            \\<le> prio\n                                   (the (heapmap_\\<alpha> hm k))) \\<bind>\n                          (\\<lambda>_.\n                              hm_index_op hm k \\<bind>\n                              (\\<lambda>i.\n                                  hm_update_op hm i v \\<bind>\n                                  (\\<lambda>hm. hm_swim_op hm i))))\n                      \\<le> \\<Down> hmr_rel\n                             (ASSERT\n                               (h.valid h (hm_index hm k) \\<and>\n                                prio v\n                                \\<le> h.prio_of h (hm_index hm k)) \\<bind>\n                              (\\<lambda>_.\n                                  h.update_op h (hm_index hm k) v \\<bind>\n                                  (\\<lambda>h.\nh.swim_op h (hm_index hm k))))", "(*apply (rewrite at \"Let (hm_index hm k) _\" Let_def)*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(hm, h) \\<in> hmr_rel; (hm, m) \\<in> heapmap_rel;\n     m k = Some v'\\<rbrakk>\n    \\<Longrightarrow> ASSERT (heapmap_invar hm) \\<bind>\n                      (\\<lambda>_.\n                          ASSERT\n                           (heapmap_\\<alpha> hm k \\<noteq> None \\<and>\n                            prio v\n                            \\<le> prio\n                                   (the (heapmap_\\<alpha> hm k))) \\<bind>\n                          (\\<lambda>_.\n                              hm_index_op hm k \\<bind>\n                              (\\<lambda>i.\n                                  hm_update_op hm i v \\<bind>\n                                  (\\<lambda>hm. hm_swim_op hm i))))\n                      \\<le> \\<Down> hmr_rel\n                             (ASSERT\n                               (h.valid h (hm_index hm k) \\<and>\n                                prio v\n                                \\<le> h.prio_of h (hm_index hm k)) \\<bind>\n                              (\\<lambda>_.\n                                  h.update_op h (hm_index hm k) v \\<bind>\n                                  (\\<lambda>h.\nh.swim_op h (hm_index hm k))))", "apply (refine_rcg index_op_inline_refine)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>(hm, h) \\<in> hmr_rel; (hm, m) \\<in> heapmap_rel;\n     m k = Some v';\n     h.valid h (hm_index hm k) \\<and>\n     prio v \\<le> h.prio_of h (hm_index hm k)\\<rbrakk>\n    \\<Longrightarrow> heapmap_invar hm\n 2. \\<lbrakk>(hm, h) \\<in> hmr_rel; (hm, m) \\<in> heapmap_rel;\n     m k = Some v';\n     h.valid h (hm_index hm k) \\<and>\n     prio v \\<le> h.prio_of h (hm_index hm k);\n     heapmap_invar hm\\<rbrakk>\n    \\<Longrightarrow> heapmap_\\<alpha> hm k \\<noteq> None\n 3. \\<lbrakk>(hm, h) \\<in> hmr_rel; (hm, m) \\<in> heapmap_rel;\n     m k = Some v';\n     h.valid h (hm_index hm k) \\<and>\n     prio v \\<le> h.prio_of h (hm_index hm k);\n     heapmap_invar hm\\<rbrakk>\n    \\<Longrightarrow> prio v \\<le> prio (the (heapmap_\\<alpha> hm k))\n 4. \\<lbrakk>(hm, h) \\<in> hmr_rel; (hm, m) \\<in> heapmap_rel;\n     m k = Some v';\n     h.valid h (hm_index hm k) \\<and>\n     prio v \\<le> h.prio_of h (hm_index hm k);\n     heapmap_invar hm;\n     heapmap_\\<alpha> hm k \\<noteq> None \\<and>\n     prio v \\<le> prio (the (heapmap_\\<alpha> hm k))\\<rbrakk>\n    \\<Longrightarrow> heapmap_\\<alpha> hm k \\<noteq> None\n 5. \\<lbrakk>(hm, h) \\<in> hmr_rel; (hm, m) \\<in> heapmap_rel;\n     m k = Some v';\n     h.valid h (hm_index hm k) \\<and>\n     prio v \\<le> h.prio_of h (hm_index hm k);\n     heapmap_invar hm;\n     heapmap_\\<alpha> hm k \\<noteq> None \\<and>\n     prio v \\<le> prio (the (heapmap_\\<alpha> hm k))\\<rbrakk>\n    \\<Longrightarrow> (hm_index hm k, hm_index hm k) \\<in> nat_rel\n 6. \\<lbrakk>(hm, h) \\<in> hmr_rel; (hm, m) \\<in> heapmap_rel;\n     m k = Some v';\n     h.valid h (hm_index hm k) \\<and>\n     prio v \\<le> h.prio_of h (hm_index hm k);\n     heapmap_invar hm;\n     heapmap_\\<alpha> hm k \\<noteq> None \\<and>\n     prio v \\<le> prio (the (heapmap_\\<alpha> hm k))\\<rbrakk>\n    \\<Longrightarrow> (v, v) \\<in> Id\n 7. \\<And>hma ha.\n       \\<lbrakk>(hm, h) \\<in> hmr_rel; (hm, m) \\<in> heapmap_rel;\n        m k = Some v';\n        h.valid h (hm_index hm k) \\<and>\n        prio v \\<le> h.prio_of h (hm_index hm k);\n        heapmap_invar hm;\n        heapmap_\\<alpha> hm k \\<noteq> None \\<and>\n        prio v \\<le> prio (the (heapmap_\\<alpha> hm k));\n        (hma, ha) \\<in> hmr_rel\\<rbrakk>\n       \\<Longrightarrow> (hm_index hm k, hm_index hm k) \\<in> nat_rel", "unfolding hmr_rel_def heapmap_rel_def in_br_conv"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>h = hmr_\\<alpha> hm \\<and> hmr_invar hm;\n     m = heapmap_\\<alpha> hm \\<and> heapmap_invar hm; m k = Some v';\n     h.valid h (hm_index hm k) \\<and>\n     prio v \\<le> h.prio_of h (hm_index hm k)\\<rbrakk>\n    \\<Longrightarrow> heapmap_invar hm\n 2. \\<lbrakk>h = hmr_\\<alpha> hm \\<and> hmr_invar hm;\n     m = heapmap_\\<alpha> hm \\<and> heapmap_invar hm; m k = Some v';\n     h.valid h (hm_index hm k) \\<and>\n     prio v \\<le> h.prio_of h (hm_index hm k);\n     heapmap_invar hm\\<rbrakk>\n    \\<Longrightarrow> heapmap_\\<alpha> hm k \\<noteq> None\n 3. \\<lbrakk>h = hmr_\\<alpha> hm \\<and> hmr_invar hm;\n     m = heapmap_\\<alpha> hm \\<and> heapmap_invar hm; m k = Some v';\n     h.valid h (hm_index hm k) \\<and>\n     prio v \\<le> h.prio_of h (hm_index hm k);\n     heapmap_invar hm\\<rbrakk>\n    \\<Longrightarrow> prio v \\<le> prio (the (heapmap_\\<alpha> hm k))\n 4. \\<lbrakk>h = hmr_\\<alpha> hm \\<and> hmr_invar hm;\n     m = heapmap_\\<alpha> hm \\<and> heapmap_invar hm; m k = Some v';\n     h.valid h (hm_index hm k) \\<and>\n     prio v \\<le> h.prio_of h (hm_index hm k);\n     heapmap_invar hm;\n     heapmap_\\<alpha> hm k \\<noteq> None \\<and>\n     prio v \\<le> prio (the (heapmap_\\<alpha> hm k))\\<rbrakk>\n    \\<Longrightarrow> heapmap_\\<alpha> hm k \\<noteq> None\n 5. \\<lbrakk>h = hmr_\\<alpha> hm \\<and> hmr_invar hm;\n     m = heapmap_\\<alpha> hm \\<and> heapmap_invar hm; m k = Some v';\n     h.valid h (hm_index hm k) \\<and>\n     prio v \\<le> h.prio_of h (hm_index hm k);\n     heapmap_invar hm;\n     heapmap_\\<alpha> hm k \\<noteq> None \\<and>\n     prio v \\<le> prio (the (heapmap_\\<alpha> hm k))\\<rbrakk>\n    \\<Longrightarrow> (hm_index hm k, hm_index hm k) \\<in> nat_rel\n 6. \\<lbrakk>h = hmr_\\<alpha> hm \\<and> hmr_invar hm;\n     m = heapmap_\\<alpha> hm \\<and> heapmap_invar hm; m k = Some v';\n     h.valid h (hm_index hm k) \\<and>\n     prio v \\<le> h.prio_of h (hm_index hm k);\n     heapmap_invar hm;\n     heapmap_\\<alpha> hm k \\<noteq> None \\<and>\n     prio v \\<le> prio (the (heapmap_\\<alpha> hm k))\\<rbrakk>\n    \\<Longrightarrow> (v, v) \\<in> Id\n 7. \\<And>hma ha.\n       \\<lbrakk>h = hmr_\\<alpha> hm \\<and> hmr_invar hm;\n        m = heapmap_\\<alpha> hm \\<and> heapmap_invar hm; m k = Some v';\n        h.valid h (hm_index hm k) \\<and>\n        prio v \\<le> h.prio_of h (hm_index hm k);\n        heapmap_invar hm;\n        heapmap_\\<alpha> hm k \\<noteq> None \\<and>\n        prio v \\<le> prio (the (heapmap_\\<alpha> hm k));\n        ha = hmr_\\<alpha> hma \\<and> hmr_invar hma\\<rbrakk>\n       \\<Longrightarrow> (hm_index hm k, hm_index hm k) \\<in> nat_rel", "apply (clarsimp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hm_index_op_inline_leof: \n      assumes \"f (hm_index hm k) \\<le>\\<^sub>n m\"\n      shows \"do {i \\<leftarrow> hm_index_op hm k; f i} \\<le>\\<^sub>n m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_index_op hm k \\<bind> f \\<le>\\<^sub>n m", "using hm_index_op_correct[of hm k] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>hmr_invar hm; heapmap_\\<alpha> hm k \\<noteq> None\\<rbrakk>\n  \\<Longrightarrow> hm_index_op hm k\n                    \\<le> SPEC (\\<lambda>r. r = hm_index hm k)\n  f (hm_index hm k) \\<le>\\<^sub>n m\n\ngoal (1 subgoal):\n 1. hm_index_op hm k \\<bind> f \\<le>\\<^sub>n m", "unfolding hm_index_op_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>hmr_invar hm; heapmap_\\<alpha> hm k \\<noteq> None\\<rbrakk>\n  \\<Longrightarrow> (case hm of\n                     (pq, m) \\<Rightarrow>\n                       \\<lambda>k.\n                          ASSERT\n                           (hmr_invar (pq, m) \\<and>\n                            heapmap_\\<alpha> (pq, m) k \\<noteq>\n                            None) \\<bind>\n                          (\\<lambda>_.\n                              mop_list_index pq k \\<bind>\n                              (\\<lambda>i. RETURN (i + 1))))\n                     k\n                    \\<le> SPEC (\\<lambda>r. r = hm_index hm k)\n  f (hm_index hm k) \\<le>\\<^sub>n m\n\ngoal (1 subgoal):\n 1. (case hm of\n     (pq, m) \\<Rightarrow>\n       \\<lambda>k.\n          ASSERT\n           (hmr_invar (pq, m) \\<and>\n            heapmap_\\<alpha> (pq, m) k \\<noteq> None) \\<bind>\n          (\\<lambda>_.\n              mop_list_index pq k \\<bind> (\\<lambda>i. RETURN (i + 1))))\n     k \\<bind>\n    f \\<le>\\<^sub>n\n    m", "by (auto simp: pw_le_iff pw_leof_iff refine_pw_simps split: prod.splits)"], ["", "lemma hm_decrease_key_op_\\<alpha>_correct: \n      \"heapmap_invar hm \\<Longrightarrow> hm_decrease_key_op k v hm \\<le>\\<^sub>n SPEC (\\<lambda>hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm(k\\<mapsto>v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heapmap_invar hm \\<Longrightarrow>\n    hm_decrease_key_op k v hm \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>hm'.\n         heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm(k \\<mapsto> v))", "unfolding hm_decrease_key_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. heapmap_invar hm \\<Longrightarrow>\n    ASSERT (heapmap_invar hm) \\<bind>\n    (\\<lambda>_.\n        ASSERT\n         (heapmap_\\<alpha> hm k \\<noteq> None \\<and>\n          prio v \\<le> prio (the (heapmap_\\<alpha> hm k))) \\<bind>\n        (\\<lambda>_.\n            hm_index_op hm k \\<bind>\n            (\\<lambda>i.\n                hm_update_op hm i v \\<bind>\n                (\\<lambda>hm. hm_swim_op hm i)))) \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>hm'.\n         heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm(k \\<mapsto> v))", "apply (refine_vcg \n        hm_update_op_\\<alpha>_correct[THEN leof_trans] \n        hm_swim_op_\\<alpha>_correct[THEN leof_trans]\n        hm_index_op_inline_leof\n        )"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>heapmap_invar hm; heapmap_invar hm;\n     heapmap_\\<alpha> hm k \\<noteq> None \\<and>\n     prio v \\<le> prio (the (heapmap_\\<alpha> hm k))\\<rbrakk>\n    \\<Longrightarrow> hmr_invar hm\n 2. \\<lbrakk>heapmap_invar hm; heapmap_invar hm;\n     heapmap_\\<alpha> hm k \\<noteq> None \\<and>\n     prio v \\<le> prio (the (heapmap_\\<alpha> hm k))\\<rbrakk>\n    \\<Longrightarrow> heapmap_\\<alpha> hm k \\<noteq> None\n 3. \\<And>x xa.\n       \\<lbrakk>heapmap_invar hm; heapmap_invar hm;\n        heapmap_\\<alpha> hm k \\<noteq> None \\<and>\n        prio v \\<le> prio (the (heapmap_\\<alpha> hm k));\n        x \\<in> {hm'.\n                 heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm(k \\<mapsto> v)};\n        xa \\<in> {hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> x}\\<rbrakk>\n       \\<Longrightarrow> heapmap_\\<alpha> xa = heapmap_\\<alpha> hm(k \n                         \\<mapsto> v)", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hm_decrease_key_op_aref: \n      \"(hm_decrease_key_op, PR_CONST (mop_pm_decrease_key prio)) \\<in> Id \\<rightarrow> Id \\<rightarrow> heapmap_rel \\<rightarrow> \\<langle>heapmap_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hm_decrease_key_op, PR_CONST (mop_pm_decrease_key prio))\n    \\<in> Id \\<rightarrow>\n          Id \\<rightarrow>\n          heapmap_rel \\<rightarrow> \\<langle>heapmap_rel\\<rangle>nres_rel", "unfolding PR_CONST_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (hm_decrease_key_op, mop_pm_decrease_key prio)\n    \\<in> Id \\<rightarrow>\n          Id \\<rightarrow>\n          heapmap_rel \\<rightarrow> \\<langle>heapmap_rel\\<rangle>nres_rel", "apply (intro fun_relI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> Id;\n        (ab, a'b) \\<in> heapmap_rel\\<rbrakk>\n       \\<Longrightarrow> hm_decrease_key_op a aa ab\n                         \\<le> \\<Down> heapmap_rel\n                                (mop_pm_decrease_key prio a' a'a a'b)", "apply (frule heapmap_hmr_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> Id;\n        (ab, a'b) \\<in> heapmap_rel;\n        (ab, hmr_\\<alpha> ab) \\<in> hmr_rel\\<rbrakk>\n       \\<Longrightarrow> hm_decrease_key_op a aa ab\n                         \\<le> \\<Down> heapmap_rel\n                                (mop_pm_decrease_key prio a' a'a a'b)", "unfolding mop_pm_decrease_key_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> Id;\n        (ab, a'b) \\<in> heapmap_rel;\n        (ab, hmr_\\<alpha> ab) \\<in> hmr_rel\\<rbrakk>\n       \\<Longrightarrow> hm_decrease_key_op a aa ab\n                         \\<le> \\<Down> heapmap_rel\n                                (ASSERT\n                                  (pre_pm_decrease_key prio\n                                    ((a', a'a), a'b)) \\<bind>\n                                 (\\<lambda>_.\n                                     RETURN\n(op_pm_decrease_key a' a'a a'b)))", "apply (rule ASSERT_refine_right; clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a' a'a ab b a'b y.\n       \\<lbrakk>((ab, b), a'b) \\<in> heapmap_rel;\n        ((ab, b), hmr_\\<alpha> (ab, b)) \\<in> hmr_rel;\n        prio a'a \\<le> prio y; a'b a' = Some y\\<rbrakk>\n       \\<Longrightarrow> hm_decrease_key_op a' a'a (ab, b)\n                         \\<le> \\<Down> heapmap_rel\n                                (RETURN (a'b(a' \\<mapsto> a'a)))", "apply (rule heapmap_nres_relI')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a' a'a ab b a'b y.\n       \\<lbrakk>((ab, b), a'b) \\<in> heapmap_rel;\n        ((ab, b), hmr_\\<alpha> (ab, b)) \\<in> hmr_rel;\n        prio a'a \\<le> prio y; a'b a' = Some y\\<rbrakk>\n       \\<Longrightarrow> hm_decrease_key_op a' a'a (ab, b)\n                         \\<le> \\<Down> hmr_rel (?h'18 a' a'a ab b a'b y)\n 2. \\<And>a' a'a ab b a'b y.\n       \\<lbrakk>((ab, b), a'b) \\<in> heapmap_rel;\n        ((ab, b), hmr_\\<alpha> (ab, b)) \\<in> hmr_rel;\n        prio a'a \\<le> prio y; a'b a' = Some y\\<rbrakk>\n       \\<Longrightarrow> ?h'18 a' a'a ab b a'b y \\<le> SPEC h.heap_invar\n 3. \\<And>a' a'a ab b a'b y.\n       \\<lbrakk>((ab, b), a'b) \\<in> heapmap_rel;\n        ((ab, b), hmr_\\<alpha> (ab, b)) \\<in> hmr_rel;\n        prio a'a \\<le> prio y; a'b a' = Some y\\<rbrakk>\n       \\<Longrightarrow> hm_decrease_key_op a' a'a (ab, b) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>hm'.\n                              RETURN (heapmap_\\<alpha> hm')\n                              \\<le> RETURN (a'b(a' \\<mapsto> a'a)))", "apply (rule hm_decrease_key_op_refine; assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a' a'a ab b a'b y.\n       \\<lbrakk>((ab, b), a'b) \\<in> heapmap_rel;\n        ((ab, b), hmr_\\<alpha> (ab, b)) \\<in> hmr_rel;\n        prio a'a \\<le> prio y; a'b a' = Some y\\<rbrakk>\n       \\<Longrightarrow> h.decrease_key_op (hm_index (ab, b) a') a'a\n                          (hmr_\\<alpha> (ab, b))\n                         \\<le> SPEC h.heap_invar\n 2. \\<And>a' a'a ab b a'b y.\n       \\<lbrakk>((ab, b), a'b) \\<in> heapmap_rel;\n        ((ab, b), hmr_\\<alpha> (ab, b)) \\<in> hmr_rel;\n        prio a'a \\<le> prio y; a'b a' = Some y\\<rbrakk>\n       \\<Longrightarrow> hm_decrease_key_op a' a'a (ab, b) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>hm'.\n                              RETURN (heapmap_\\<alpha> hm')\n                              \\<le> RETURN (a'b(a' \\<mapsto> a'a)))", "unfolding heapmap_rel_def hmr_rel_def in_br_conv"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a' a'a ab b a'b y.\n       \\<lbrakk>a'b = heapmap_\\<alpha> (ab, b) \\<and> heapmap_invar (ab, b);\n        hmr_\\<alpha> (ab, b) = hmr_\\<alpha> (ab, b) \\<and>\n        hmr_invar (ab, b);\n        prio a'a \\<le> prio y; a'b a' = Some y\\<rbrakk>\n       \\<Longrightarrow> h.decrease_key_op (hm_index (ab, b) a') a'a\n                          (hmr_\\<alpha> (ab, b))\n                         \\<le> SPEC h.heap_invar\n 2. \\<And>a' a'a ab b a'b y.\n       \\<lbrakk>a'b = heapmap_\\<alpha> (ab, b) \\<and> heapmap_invar (ab, b);\n        hmr_\\<alpha> (ab, b) = hmr_\\<alpha> (ab, b) \\<and>\n        hmr_invar (ab, b);\n        prio a'a \\<le> prio y; a'b a' = Some y\\<rbrakk>\n       \\<Longrightarrow> hm_decrease_key_op a' a'a (ab, b) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>hm'.\n                              RETURN (heapmap_\\<alpha> hm')\n                              \\<le> RETURN (a'b(a' \\<mapsto> a'a)))", "apply (rule h.decrease_key_op_invar; simp; fail )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a' a'a ab b a'b y.\n       \\<lbrakk>a'b = heapmap_\\<alpha> (ab, b) \\<and> heapmap_invar (ab, b);\n        hmr_\\<alpha> (ab, b) = hmr_\\<alpha> (ab, b) \\<and>\n        hmr_invar (ab, b);\n        prio a'a \\<le> prio y; a'b a' = Some y\\<rbrakk>\n       \\<Longrightarrow> hm_decrease_key_op a' a'a (ab, b) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>hm'.\n                              RETURN (heapmap_\\<alpha> hm')\n                              \\<le> RETURN (a'b(a' \\<mapsto> a'a)))", "apply (refine_vcg hm_decrease_key_op_\\<alpha>_correct[THEN leof_trans]; simp; fail)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Increase-Key\\<close>"], ["", "definition \"hm_increase_key_op \\<equiv> \\<lambda>k v hm. do {\n      ASSERT (heapmap_invar hm);\n      ASSERT (heapmap_\\<alpha> hm k \\<noteq> None \\<and> prio v \\<ge> prio (the (heapmap_\\<alpha> hm k)));\n      i \\<leftarrow> hm_index_op hm k;\n      hm \\<leftarrow> hm_update_op hm i v;\n      hm_sink_op hm i\n    }\""], ["", "definition (in heapstruct) \"increase_key_op i v h \\<equiv> do {\n      ASSERT (valid h i \\<and> prio v \\<ge> prio_of h i);\n      h \\<leftarrow> update_op h i v;\n      sink_op h i\n    }\""], ["", "lemma (in heapstruct) increase_key_op_invar: \n      \"\\<lbrakk>heap_invar h; valid h i; prio v \\<ge> prio_of h i\\<rbrakk> \\<Longrightarrow> increase_key_op i v h \\<le> SPEC heap_invar\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heap_invar h; valid h i; prio_of h i \\<le> prio v\\<rbrakk>\n    \\<Longrightarrow> increase_key_op i v h \\<le> SPEC heap_invar", "unfolding increase_key_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heap_invar h; valid h i; prio_of h i \\<le> prio v\\<rbrakk>\n    \\<Longrightarrow> ASSERT\n                       (valid h i \\<and> prio_of h i \\<le> prio v) \\<bind>\n                      (\\<lambda>_.\n                          update_op h i v \\<bind> (\\<lambda>h. sink_op h i))\n                      \\<le> SPEC heap_invar", "apply refine_vcg"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>heap_invar h; valid h i; prio_of h i \\<le> prio v;\n        valid h i \\<and> prio_of h i \\<le> prio v; x = update h i v\\<rbrakk>\n       \\<Longrightarrow> sink_invar x i\n 2. \\<And>x xa.\n       \\<lbrakk>heap_invar h; valid h i; prio_of h i \\<le> prio v;\n        valid h i \\<and> prio_of h i \\<le> prio v; x = update h i v;\n        \\<alpha> xa = \\<alpha> x \\<and>\n        heap_invar xa \\<and> length xa = length x\\<rbrakk>\n       \\<Longrightarrow> heap_invar xa", "by (auto simp: sink_invar_incr)"], ["", "lemma hm_increase_key_op_refine: \n      \"\\<lbrakk>(hm,h)\\<in>hmr_rel; (hm,m)\\<in>heapmap_rel; m k = Some v'\\<rbrakk> \n        \\<Longrightarrow> hm_increase_key_op k v hm \\<le>\\<Down>hmr_rel (h.increase_key_op (hm_index hm k) v h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(hm, h) \\<in> hmr_rel; (hm, m) \\<in> heapmap_rel;\n     m k = Some v'\\<rbrakk>\n    \\<Longrightarrow> hm_increase_key_op k v hm\n                      \\<le> \\<Down> hmr_rel\n                             (h.increase_key_op (hm_index hm k) v h)", "unfolding hm_increase_key_op_def h.increase_key_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(hm, h) \\<in> hmr_rel; (hm, m) \\<in> heapmap_rel;\n     m k = Some v'\\<rbrakk>\n    \\<Longrightarrow> ASSERT (heapmap_invar hm) \\<bind>\n                      (\\<lambda>_.\n                          ASSERT\n                           (heapmap_\\<alpha> hm k \\<noteq> None \\<and>\n                            prio (the (heapmap_\\<alpha> hm k))\n                            \\<le> prio v) \\<bind>\n                          (\\<lambda>_.\n                              hm_index_op hm k \\<bind>\n                              (\\<lambda>i.\n                                  hm_update_op hm i v \\<bind>\n                                  (\\<lambda>hm. hm_sink_op hm i))))\n                      \\<le> \\<Down> hmr_rel\n                             (ASSERT\n                               (h.valid h (hm_index hm k) \\<and>\n                                h.prio_of h (hm_index hm k)\n                                \\<le> prio v) \\<bind>\n                              (\\<lambda>_.\n                                  h.update_op h (hm_index hm k) v \\<bind>\n                                  (\\<lambda>h.\nh.sink_op h (hm_index hm k))))", "(*apply (rewrite at \"Let (hm_index hm k) _\" Let_def)*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(hm, h) \\<in> hmr_rel; (hm, m) \\<in> heapmap_rel;\n     m k = Some v'\\<rbrakk>\n    \\<Longrightarrow> ASSERT (heapmap_invar hm) \\<bind>\n                      (\\<lambda>_.\n                          ASSERT\n                           (heapmap_\\<alpha> hm k \\<noteq> None \\<and>\n                            prio (the (heapmap_\\<alpha> hm k))\n                            \\<le> prio v) \\<bind>\n                          (\\<lambda>_.\n                              hm_index_op hm k \\<bind>\n                              (\\<lambda>i.\n                                  hm_update_op hm i v \\<bind>\n                                  (\\<lambda>hm. hm_sink_op hm i))))\n                      \\<le> \\<Down> hmr_rel\n                             (ASSERT\n                               (h.valid h (hm_index hm k) \\<and>\n                                h.prio_of h (hm_index hm k)\n                                \\<le> prio v) \\<bind>\n                              (\\<lambda>_.\n                                  h.update_op h (hm_index hm k) v \\<bind>\n                                  (\\<lambda>h.\nh.sink_op h (hm_index hm k))))", "apply (refine_rcg index_op_inline_refine)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>(hm, h) \\<in> hmr_rel; (hm, m) \\<in> heapmap_rel;\n     m k = Some v';\n     h.valid h (hm_index hm k) \\<and>\n     h.prio_of h (hm_index hm k) \\<le> prio v\\<rbrakk>\n    \\<Longrightarrow> heapmap_invar hm\n 2. \\<lbrakk>(hm, h) \\<in> hmr_rel; (hm, m) \\<in> heapmap_rel;\n     m k = Some v';\n     h.valid h (hm_index hm k) \\<and>\n     h.prio_of h (hm_index hm k) \\<le> prio v;\n     heapmap_invar hm\\<rbrakk>\n    \\<Longrightarrow> heapmap_\\<alpha> hm k \\<noteq> None\n 3. \\<lbrakk>(hm, h) \\<in> hmr_rel; (hm, m) \\<in> heapmap_rel;\n     m k = Some v';\n     h.valid h (hm_index hm k) \\<and>\n     h.prio_of h (hm_index hm k) \\<le> prio v;\n     heapmap_invar hm\\<rbrakk>\n    \\<Longrightarrow> prio (the (heapmap_\\<alpha> hm k)) \\<le> prio v\n 4. \\<lbrakk>(hm, h) \\<in> hmr_rel; (hm, m) \\<in> heapmap_rel;\n     m k = Some v';\n     h.valid h (hm_index hm k) \\<and>\n     h.prio_of h (hm_index hm k) \\<le> prio v;\n     heapmap_invar hm;\n     heapmap_\\<alpha> hm k \\<noteq> None \\<and>\n     prio (the (heapmap_\\<alpha> hm k)) \\<le> prio v\\<rbrakk>\n    \\<Longrightarrow> heapmap_\\<alpha> hm k \\<noteq> None\n 5. \\<lbrakk>(hm, h) \\<in> hmr_rel; (hm, m) \\<in> heapmap_rel;\n     m k = Some v';\n     h.valid h (hm_index hm k) \\<and>\n     h.prio_of h (hm_index hm k) \\<le> prio v;\n     heapmap_invar hm;\n     heapmap_\\<alpha> hm k \\<noteq> None \\<and>\n     prio (the (heapmap_\\<alpha> hm k)) \\<le> prio v\\<rbrakk>\n    \\<Longrightarrow> (hm_index hm k, hm_index hm k) \\<in> nat_rel\n 6. \\<lbrakk>(hm, h) \\<in> hmr_rel; (hm, m) \\<in> heapmap_rel;\n     m k = Some v';\n     h.valid h (hm_index hm k) \\<and>\n     h.prio_of h (hm_index hm k) \\<le> prio v;\n     heapmap_invar hm;\n     heapmap_\\<alpha> hm k \\<noteq> None \\<and>\n     prio (the (heapmap_\\<alpha> hm k)) \\<le> prio v\\<rbrakk>\n    \\<Longrightarrow> (v, v) \\<in> Id\n 7. \\<And>hma ha.\n       \\<lbrakk>(hm, h) \\<in> hmr_rel; (hm, m) \\<in> heapmap_rel;\n        m k = Some v';\n        h.valid h (hm_index hm k) \\<and>\n        h.prio_of h (hm_index hm k) \\<le> prio v;\n        heapmap_invar hm;\n        heapmap_\\<alpha> hm k \\<noteq> None \\<and>\n        prio (the (heapmap_\\<alpha> hm k)) \\<le> prio v;\n        (hma, ha) \\<in> hmr_rel\\<rbrakk>\n       \\<Longrightarrow> (hm_index hm k, hm_index hm k) \\<in> nat_rel", "unfolding hmr_rel_def heapmap_rel_def in_br_conv"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>h = hmr_\\<alpha> hm \\<and> hmr_invar hm;\n     m = heapmap_\\<alpha> hm \\<and> heapmap_invar hm; m k = Some v';\n     h.valid h (hm_index hm k) \\<and>\n     h.prio_of h (hm_index hm k) \\<le> prio v\\<rbrakk>\n    \\<Longrightarrow> heapmap_invar hm\n 2. \\<lbrakk>h = hmr_\\<alpha> hm \\<and> hmr_invar hm;\n     m = heapmap_\\<alpha> hm \\<and> heapmap_invar hm; m k = Some v';\n     h.valid h (hm_index hm k) \\<and>\n     h.prio_of h (hm_index hm k) \\<le> prio v;\n     heapmap_invar hm\\<rbrakk>\n    \\<Longrightarrow> heapmap_\\<alpha> hm k \\<noteq> None\n 3. \\<lbrakk>h = hmr_\\<alpha> hm \\<and> hmr_invar hm;\n     m = heapmap_\\<alpha> hm \\<and> heapmap_invar hm; m k = Some v';\n     h.valid h (hm_index hm k) \\<and>\n     h.prio_of h (hm_index hm k) \\<le> prio v;\n     heapmap_invar hm\\<rbrakk>\n    \\<Longrightarrow> prio (the (heapmap_\\<alpha> hm k)) \\<le> prio v\n 4. \\<lbrakk>h = hmr_\\<alpha> hm \\<and> hmr_invar hm;\n     m = heapmap_\\<alpha> hm \\<and> heapmap_invar hm; m k = Some v';\n     h.valid h (hm_index hm k) \\<and>\n     h.prio_of h (hm_index hm k) \\<le> prio v;\n     heapmap_invar hm;\n     heapmap_\\<alpha> hm k \\<noteq> None \\<and>\n     prio (the (heapmap_\\<alpha> hm k)) \\<le> prio v\\<rbrakk>\n    \\<Longrightarrow> heapmap_\\<alpha> hm k \\<noteq> None\n 5. \\<lbrakk>h = hmr_\\<alpha> hm \\<and> hmr_invar hm;\n     m = heapmap_\\<alpha> hm \\<and> heapmap_invar hm; m k = Some v';\n     h.valid h (hm_index hm k) \\<and>\n     h.prio_of h (hm_index hm k) \\<le> prio v;\n     heapmap_invar hm;\n     heapmap_\\<alpha> hm k \\<noteq> None \\<and>\n     prio (the (heapmap_\\<alpha> hm k)) \\<le> prio v\\<rbrakk>\n    \\<Longrightarrow> (hm_index hm k, hm_index hm k) \\<in> nat_rel\n 6. \\<lbrakk>h = hmr_\\<alpha> hm \\<and> hmr_invar hm;\n     m = heapmap_\\<alpha> hm \\<and> heapmap_invar hm; m k = Some v';\n     h.valid h (hm_index hm k) \\<and>\n     h.prio_of h (hm_index hm k) \\<le> prio v;\n     heapmap_invar hm;\n     heapmap_\\<alpha> hm k \\<noteq> None \\<and>\n     prio (the (heapmap_\\<alpha> hm k)) \\<le> prio v\\<rbrakk>\n    \\<Longrightarrow> (v, v) \\<in> Id\n 7. \\<And>hma ha.\n       \\<lbrakk>h = hmr_\\<alpha> hm \\<and> hmr_invar hm;\n        m = heapmap_\\<alpha> hm \\<and> heapmap_invar hm; m k = Some v';\n        h.valid h (hm_index hm k) \\<and>\n        h.prio_of h (hm_index hm k) \\<le> prio v;\n        heapmap_invar hm;\n        heapmap_\\<alpha> hm k \\<noteq> None \\<and>\n        prio (the (heapmap_\\<alpha> hm k)) \\<le> prio v;\n        ha = hmr_\\<alpha> hma \\<and> hmr_invar hma\\<rbrakk>\n       \\<Longrightarrow> (hm_index hm k, hm_index hm k) \\<in> nat_rel", "apply (clarsimp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hm_increase_key_op_\\<alpha>_correct: \n      \"heapmap_invar hm \\<Longrightarrow> hm_increase_key_op k v hm \\<le>\\<^sub>n SPEC (\\<lambda>hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm(k\\<mapsto>v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heapmap_invar hm \\<Longrightarrow>\n    hm_increase_key_op k v hm \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>hm'.\n         heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm(k \\<mapsto> v))", "unfolding hm_increase_key_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. heapmap_invar hm \\<Longrightarrow>\n    ASSERT (heapmap_invar hm) \\<bind>\n    (\\<lambda>_.\n        ASSERT\n         (heapmap_\\<alpha> hm k \\<noteq> None \\<and>\n          prio (the (heapmap_\\<alpha> hm k)) \\<le> prio v) \\<bind>\n        (\\<lambda>_.\n            hm_index_op hm k \\<bind>\n            (\\<lambda>i.\n                hm_update_op hm i v \\<bind>\n                (\\<lambda>hm. hm_sink_op hm i)))) \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>hm'.\n         heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm(k \\<mapsto> v))", "apply (refine_vcg \n        hm_update_op_\\<alpha>_correct[THEN leof_trans] \n        hm_sink_op_\\<alpha>_correct[THEN leof_trans]\n        hm_index_op_inline_leof)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>heapmap_invar hm; heapmap_invar hm;\n     heapmap_\\<alpha> hm k \\<noteq> None \\<and>\n     prio (the (heapmap_\\<alpha> hm k)) \\<le> prio v\\<rbrakk>\n    \\<Longrightarrow> hmr_invar hm\n 2. \\<lbrakk>heapmap_invar hm; heapmap_invar hm;\n     heapmap_\\<alpha> hm k \\<noteq> None \\<and>\n     prio (the (heapmap_\\<alpha> hm k)) \\<le> prio v\\<rbrakk>\n    \\<Longrightarrow> heapmap_\\<alpha> hm k \\<noteq> None\n 3. \\<And>x xa.\n       \\<lbrakk>heapmap_invar hm; heapmap_invar hm;\n        heapmap_\\<alpha> hm k \\<noteq> None \\<and>\n        prio (the (heapmap_\\<alpha> hm k)) \\<le> prio v;\n        x \\<in> {hm'.\n                 heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm(k \\<mapsto> v)};\n        xa \\<in> {hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> x}\\<rbrakk>\n       \\<Longrightarrow> heapmap_\\<alpha> xa = heapmap_\\<alpha> hm(k \n                         \\<mapsto> v)", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hm_increase_key_op_aref: \n      \"(hm_increase_key_op, PR_CONST (mop_pm_increase_key prio)) \\<in> Id \\<rightarrow> Id \\<rightarrow> heapmap_rel \\<rightarrow> \\<langle>heapmap_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hm_increase_key_op, PR_CONST (mop_pm_increase_key prio))\n    \\<in> Id \\<rightarrow>\n          Id \\<rightarrow>\n          heapmap_rel \\<rightarrow> \\<langle>heapmap_rel\\<rangle>nres_rel", "unfolding PR_CONST_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (hm_increase_key_op, mop_pm_increase_key prio)\n    \\<in> Id \\<rightarrow>\n          Id \\<rightarrow>\n          heapmap_rel \\<rightarrow> \\<langle>heapmap_rel\\<rangle>nres_rel", "apply (intro fun_relI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> Id;\n        (ab, a'b) \\<in> heapmap_rel\\<rbrakk>\n       \\<Longrightarrow> hm_increase_key_op a aa ab\n                         \\<le> \\<Down> heapmap_rel\n                                (mop_pm_increase_key prio a' a'a a'b)", "apply (frule heapmap_hmr_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> Id;\n        (ab, a'b) \\<in> heapmap_rel;\n        (ab, hmr_\\<alpha> ab) \\<in> hmr_rel\\<rbrakk>\n       \\<Longrightarrow> hm_increase_key_op a aa ab\n                         \\<le> \\<Down> heapmap_rel\n                                (mop_pm_increase_key prio a' a'a a'b)", "unfolding mop_pm_increase_key_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> Id;\n        (ab, a'b) \\<in> heapmap_rel;\n        (ab, hmr_\\<alpha> ab) \\<in> hmr_rel\\<rbrakk>\n       \\<Longrightarrow> hm_increase_key_op a aa ab\n                         \\<le> \\<Down> heapmap_rel\n                                (ASSERT\n                                  (pre_pm_increase_key prio\n                                    ((a', a'a), a'b)) \\<bind>\n                                 (\\<lambda>_.\n                                     RETURN\n(op_pm_increase_key a' a'a a'b)))", "apply (rule ASSERT_refine_right; clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a' a'a ab b a'b y.\n       \\<lbrakk>((ab, b), a'b) \\<in> heapmap_rel;\n        ((ab, b), hmr_\\<alpha> (ab, b)) \\<in> hmr_rel;\n        prio y \\<le> prio a'a; a'b a' = Some y\\<rbrakk>\n       \\<Longrightarrow> hm_increase_key_op a' a'a (ab, b)\n                         \\<le> \\<Down> heapmap_rel\n                                (RETURN (a'b(a' \\<mapsto> a'a)))", "apply (rule heapmap_nres_relI')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a' a'a ab b a'b y.\n       \\<lbrakk>((ab, b), a'b) \\<in> heapmap_rel;\n        ((ab, b), hmr_\\<alpha> (ab, b)) \\<in> hmr_rel;\n        prio y \\<le> prio a'a; a'b a' = Some y\\<rbrakk>\n       \\<Longrightarrow> hm_increase_key_op a' a'a (ab, b)\n                         \\<le> \\<Down> hmr_rel (?h'18 a' a'a ab b a'b y)\n 2. \\<And>a' a'a ab b a'b y.\n       \\<lbrakk>((ab, b), a'b) \\<in> heapmap_rel;\n        ((ab, b), hmr_\\<alpha> (ab, b)) \\<in> hmr_rel;\n        prio y \\<le> prio a'a; a'b a' = Some y\\<rbrakk>\n       \\<Longrightarrow> ?h'18 a' a'a ab b a'b y \\<le> SPEC h.heap_invar\n 3. \\<And>a' a'a ab b a'b y.\n       \\<lbrakk>((ab, b), a'b) \\<in> heapmap_rel;\n        ((ab, b), hmr_\\<alpha> (ab, b)) \\<in> hmr_rel;\n        prio y \\<le> prio a'a; a'b a' = Some y\\<rbrakk>\n       \\<Longrightarrow> hm_increase_key_op a' a'a (ab, b) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>hm'.\n                              RETURN (heapmap_\\<alpha> hm')\n                              \\<le> RETURN (a'b(a' \\<mapsto> a'a)))", "apply (rule hm_increase_key_op_refine; assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a' a'a ab b a'b y.\n       \\<lbrakk>((ab, b), a'b) \\<in> heapmap_rel;\n        ((ab, b), hmr_\\<alpha> (ab, b)) \\<in> hmr_rel;\n        prio y \\<le> prio a'a; a'b a' = Some y\\<rbrakk>\n       \\<Longrightarrow> h.increase_key_op (hm_index (ab, b) a') a'a\n                          (hmr_\\<alpha> (ab, b))\n                         \\<le> SPEC h.heap_invar\n 2. \\<And>a' a'a ab b a'b y.\n       \\<lbrakk>((ab, b), a'b) \\<in> heapmap_rel;\n        ((ab, b), hmr_\\<alpha> (ab, b)) \\<in> hmr_rel;\n        prio y \\<le> prio a'a; a'b a' = Some y\\<rbrakk>\n       \\<Longrightarrow> hm_increase_key_op a' a'a (ab, b) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>hm'.\n                              RETURN (heapmap_\\<alpha> hm')\n                              \\<le> RETURN (a'b(a' \\<mapsto> a'a)))", "unfolding heapmap_rel_def hmr_rel_def in_br_conv"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a' a'a ab b a'b y.\n       \\<lbrakk>a'b = heapmap_\\<alpha> (ab, b) \\<and> heapmap_invar (ab, b);\n        hmr_\\<alpha> (ab, b) = hmr_\\<alpha> (ab, b) \\<and>\n        hmr_invar (ab, b);\n        prio y \\<le> prio a'a; a'b a' = Some y\\<rbrakk>\n       \\<Longrightarrow> h.increase_key_op (hm_index (ab, b) a') a'a\n                          (hmr_\\<alpha> (ab, b))\n                         \\<le> SPEC h.heap_invar\n 2. \\<And>a' a'a ab b a'b y.\n       \\<lbrakk>a'b = heapmap_\\<alpha> (ab, b) \\<and> heapmap_invar (ab, b);\n        hmr_\\<alpha> (ab, b) = hmr_\\<alpha> (ab, b) \\<and>\n        hmr_invar (ab, b);\n        prio y \\<le> prio a'a; a'b a' = Some y\\<rbrakk>\n       \\<Longrightarrow> hm_increase_key_op a' a'a (ab, b) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>hm'.\n                              RETURN (heapmap_\\<alpha> hm')\n                              \\<le> RETURN (a'b(a' \\<mapsto> a'a)))", "apply (rule h.increase_key_op_invar; simp; fail )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a' a'a ab b a'b y.\n       \\<lbrakk>a'b = heapmap_\\<alpha> (ab, b) \\<and> heapmap_invar (ab, b);\n        hmr_\\<alpha> (ab, b) = hmr_\\<alpha> (ab, b) \\<and>\n        hmr_invar (ab, b);\n        prio y \\<le> prio a'a; a'b a' = Some y\\<rbrakk>\n       \\<Longrightarrow> hm_increase_key_op a' a'a (ab, b) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>hm'.\n                              RETURN (heapmap_\\<alpha> hm')\n                              \\<le> RETURN (a'b(a' \\<mapsto> a'a)))", "apply (refine_vcg hm_increase_key_op_\\<alpha>_correct[THEN leof_trans]; simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Change-Key\\<close>"], ["", "definition \"hm_change_key_op \\<equiv> \\<lambda>k v hm. do {\n      ASSERT (heapmap_invar hm);\n      ASSERT (heapmap_\\<alpha> hm k \\<noteq> None);\n      i \\<leftarrow> hm_index_op hm k;\n      hm \\<leftarrow> hm_update_op hm i v;\n      hm_repair_op hm i\n    }\""], ["", "definition (in heapstruct) \"change_key_op i v h \\<equiv> do {\n      ASSERT (valid h i);\n      h \\<leftarrow> update_op h i v;\n      repair_op h i\n    }\""], ["", "lemma (in heapstruct) change_key_op_invar: \n      \"\\<lbrakk>heap_invar h; valid h i\\<rbrakk> \\<Longrightarrow> change_key_op i v h \\<le> SPEC heap_invar\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heap_invar h; valid h i\\<rbrakk>\n    \\<Longrightarrow> change_key_op i v h \\<le> SPEC heap_invar", "unfolding change_key_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heap_invar h; valid h i\\<rbrakk>\n    \\<Longrightarrow> ASSERT (valid h i) \\<bind>\n                      (\\<lambda>_.\n                          update_op h i v \\<bind>\n                          (\\<lambda>h. repair_op h i))\n                      \\<le> SPEC heap_invar", "apply (refine_vcg)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>heap_invar h; valid h i; valid h i;\n        x = update h i v\\<rbrakk>\n       \\<Longrightarrow> repair_op x i \\<le> SPEC heap_invar", "apply hypsubst"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>heap_invar h; valid h i; valid h i\\<rbrakk>\n       \\<Longrightarrow> repair_op (update h i v) i \\<le> SPEC heap_invar", "apply refine_vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>heap_invar h; valid h i; valid h i;\n        heap_invar xa \\<and>\n        \\<alpha> xa = \\<alpha> (update h i v) \\<and>\n        length xa = length h\\<rbrakk>\n       \\<Longrightarrow> heap_invar xa", "by (auto simp: sink_invar_incr)"], ["", "lemma hm_change_key_op_refine: \n      \"\\<lbrakk>(hm,h)\\<in>hmr_rel; (hm,m)\\<in>heapmap_rel; m k = Some v'\\<rbrakk> \n        \\<Longrightarrow> hm_change_key_op k v hm \\<le>\\<Down>hmr_rel (h.change_key_op (hm_index hm k) v h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(hm, h) \\<in> hmr_rel; (hm, m) \\<in> heapmap_rel;\n     m k = Some v'\\<rbrakk>\n    \\<Longrightarrow> hm_change_key_op k v hm\n                      \\<le> \\<Down> hmr_rel\n                             (h.change_key_op (hm_index hm k) v h)", "unfolding hm_change_key_op_def h.change_key_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(hm, h) \\<in> hmr_rel; (hm, m) \\<in> heapmap_rel;\n     m k = Some v'\\<rbrakk>\n    \\<Longrightarrow> ASSERT (heapmap_invar hm) \\<bind>\n                      (\\<lambda>_.\n                          ASSERT\n                           (heapmap_\\<alpha> hm k \\<noteq> None) \\<bind>\n                          (\\<lambda>_.\n                              hm_index_op hm k \\<bind>\n                              (\\<lambda>i.\n                                  hm_update_op hm i v \\<bind>\n                                  (\\<lambda>hm. hm_repair_op hm i))))\n                      \\<le> \\<Down> hmr_rel\n                             (ASSERT (h.valid h (hm_index hm k)) \\<bind>\n                              (\\<lambda>_.\n                                  h.update_op h (hm_index hm k) v \\<bind>\n                                  (\\<lambda>h.\nh.repair_op h (hm_index hm k))))", "(*apply (rewrite at \"Let (hm_index hm k) _\" Let_def)*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(hm, h) \\<in> hmr_rel; (hm, m) \\<in> heapmap_rel;\n     m k = Some v'\\<rbrakk>\n    \\<Longrightarrow> ASSERT (heapmap_invar hm) \\<bind>\n                      (\\<lambda>_.\n                          ASSERT\n                           (heapmap_\\<alpha> hm k \\<noteq> None) \\<bind>\n                          (\\<lambda>_.\n                              hm_index_op hm k \\<bind>\n                              (\\<lambda>i.\n                                  hm_update_op hm i v \\<bind>\n                                  (\\<lambda>hm. hm_repair_op hm i))))\n                      \\<le> \\<Down> hmr_rel\n                             (ASSERT (h.valid h (hm_index hm k)) \\<bind>\n                              (\\<lambda>_.\n                                  h.update_op h (hm_index hm k) v \\<bind>\n                                  (\\<lambda>h.\nh.repair_op h (hm_index hm k))))", "apply (refine_rcg index_op_inline_refine)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>(hm, h) \\<in> hmr_rel; (hm, m) \\<in> heapmap_rel;\n     m k = Some v'; h.valid h (hm_index hm k)\\<rbrakk>\n    \\<Longrightarrow> heapmap_invar hm\n 2. \\<lbrakk>(hm, h) \\<in> hmr_rel; (hm, m) \\<in> heapmap_rel;\n     m k = Some v'; h.valid h (hm_index hm k); heapmap_invar hm\\<rbrakk>\n    \\<Longrightarrow> heapmap_\\<alpha> hm k \\<noteq> None\n 3. \\<lbrakk>(hm, h) \\<in> hmr_rel; (hm, m) \\<in> heapmap_rel;\n     m k = Some v'; h.valid h (hm_index hm k); heapmap_invar hm;\n     heapmap_\\<alpha> hm k \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> (hm_index hm k, hm_index hm k) \\<in> nat_rel\n 4. \\<lbrakk>(hm, h) \\<in> hmr_rel; (hm, m) \\<in> heapmap_rel;\n     m k = Some v'; h.valid h (hm_index hm k); heapmap_invar hm;\n     heapmap_\\<alpha> hm k \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> (v, v) \\<in> Id\n 5. \\<And>hma ha.\n       \\<lbrakk>(hm, h) \\<in> hmr_rel; (hm, m) \\<in> heapmap_rel;\n        m k = Some v'; h.valid h (hm_index hm k); heapmap_invar hm;\n        heapmap_\\<alpha> hm k \\<noteq> None;\n        (hma, ha) \\<in> hmr_rel\\<rbrakk>\n       \\<Longrightarrow> (hm_index hm k, hm_index hm k) \\<in> nat_rel", "unfolding hmr_rel_def heapmap_rel_def in_br_conv"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>h = hmr_\\<alpha> hm \\<and> hmr_invar hm;\n     m = heapmap_\\<alpha> hm \\<and> heapmap_invar hm; m k = Some v';\n     h.valid h (hm_index hm k)\\<rbrakk>\n    \\<Longrightarrow> heapmap_invar hm\n 2. \\<lbrakk>h = hmr_\\<alpha> hm \\<and> hmr_invar hm;\n     m = heapmap_\\<alpha> hm \\<and> heapmap_invar hm; m k = Some v';\n     h.valid h (hm_index hm k); heapmap_invar hm\\<rbrakk>\n    \\<Longrightarrow> heapmap_\\<alpha> hm k \\<noteq> None\n 3. \\<lbrakk>h = hmr_\\<alpha> hm \\<and> hmr_invar hm;\n     m = heapmap_\\<alpha> hm \\<and> heapmap_invar hm; m k = Some v';\n     h.valid h (hm_index hm k); heapmap_invar hm;\n     heapmap_\\<alpha> hm k \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> (hm_index hm k, hm_index hm k) \\<in> nat_rel\n 4. \\<lbrakk>h = hmr_\\<alpha> hm \\<and> hmr_invar hm;\n     m = heapmap_\\<alpha> hm \\<and> heapmap_invar hm; m k = Some v';\n     h.valid h (hm_index hm k); heapmap_invar hm;\n     heapmap_\\<alpha> hm k \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> (v, v) \\<in> Id\n 5. \\<And>hma ha.\n       \\<lbrakk>h = hmr_\\<alpha> hm \\<and> hmr_invar hm;\n        m = heapmap_\\<alpha> hm \\<and> heapmap_invar hm; m k = Some v';\n        h.valid h (hm_index hm k); heapmap_invar hm;\n        heapmap_\\<alpha> hm k \\<noteq> None;\n        ha = hmr_\\<alpha> hma \\<and> hmr_invar hma\\<rbrakk>\n       \\<Longrightarrow> (hm_index hm k, hm_index hm k) \\<in> nat_rel", "apply (clarsimp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hm_change_key_op_\\<alpha>_correct: \n      \"heapmap_invar hm \\<Longrightarrow> hm_change_key_op k v hm \\<le>\\<^sub>n SPEC (\\<lambda>hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm(k\\<mapsto>v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heapmap_invar hm \\<Longrightarrow>\n    hm_change_key_op k v hm \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>hm'.\n         heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm(k \\<mapsto> v))", "unfolding hm_change_key_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. heapmap_invar hm \\<Longrightarrow>\n    ASSERT (heapmap_invar hm) \\<bind>\n    (\\<lambda>_.\n        ASSERT (heapmap_\\<alpha> hm k \\<noteq> None) \\<bind>\n        (\\<lambda>_.\n            hm_index_op hm k \\<bind>\n            (\\<lambda>i.\n                hm_update_op hm i v \\<bind>\n                (\\<lambda>hm. hm_repair_op hm i)))) \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>hm'.\n         heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm(k \\<mapsto> v))", "apply (refine_vcg \n        hm_update_op_\\<alpha>_correct[THEN leof_trans] \n        hm_repair_op_\\<alpha>_correct[THEN leof_trans]\n        hm_index_op_inline_leof)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>heapmap_invar hm; heapmap_invar hm;\n     heapmap_\\<alpha> hm k \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> hmr_invar hm\n 2. \\<And>x xa.\n       \\<lbrakk>heapmap_invar hm; heapmap_invar hm;\n        heapmap_\\<alpha> hm k \\<noteq> None;\n        x \\<in> {hm'.\n                 heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm(k \\<mapsto> v)};\n        xa \\<in> {hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> x}\\<rbrakk>\n       \\<Longrightarrow> heapmap_\\<alpha> xa = heapmap_\\<alpha> hm(k \n                         \\<mapsto> v)", "unfolding heapmap_rel_def in_br_conv"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>heapmap_invar hm; heapmap_invar hm;\n     heapmap_\\<alpha> hm k \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> hmr_invar hm\n 2. \\<And>x xa.\n       \\<lbrakk>heapmap_invar hm; heapmap_invar hm;\n        heapmap_\\<alpha> hm k \\<noteq> None;\n        x \\<in> {hm'.\n                 heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm(k \\<mapsto> v)};\n        xa \\<in> {hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> x}\\<rbrakk>\n       \\<Longrightarrow> heapmap_\\<alpha> xa = heapmap_\\<alpha> hm(k \n                         \\<mapsto> v)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>heapmap_invar hm; heapmap_invar hm;\n        heapmap_\\<alpha> hm k \\<noteq> None;\n        x \\<in> {hm'.\n                 heapmap_\\<alpha> hm' = heapmap_\\<alpha> hm(k \\<mapsto> v)};\n        xa \\<in> {hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> x}\\<rbrakk>\n       \\<Longrightarrow> heapmap_\\<alpha> xa = heapmap_\\<alpha> hm(k \n                         \\<mapsto> v)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hm_change_key_op_aref: \n      \"(hm_change_key_op, mop_map_update_ex) \\<in> Id \\<rightarrow> Id \\<rightarrow> heapmap_rel \\<rightarrow> \\<langle>heapmap_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hm_change_key_op, mop_map_update_ex)\n    \\<in> Id \\<rightarrow>\n          Id \\<rightarrow>\n          heapmap_rel \\<rightarrow> \\<langle>heapmap_rel\\<rangle>nres_rel", "apply (intro fun_relI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> Id;\n        (ab, a'b) \\<in> heapmap_rel\\<rbrakk>\n       \\<Longrightarrow> hm_change_key_op a aa ab\n                         \\<le> \\<Down> heapmap_rel\n                                (mop_map_update_ex a' a'a a'b)", "apply (frule heapmap_hmr_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> Id;\n        (ab, a'b) \\<in> heapmap_rel;\n        (ab, hmr_\\<alpha> ab) \\<in> hmr_rel\\<rbrakk>\n       \\<Longrightarrow> hm_change_key_op a aa ab\n                         \\<le> \\<Down> heapmap_rel\n                                (mop_map_update_ex a' a'a a'b)", "unfolding mop_map_update_ex_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> Id;\n        (ab, a'b) \\<in> heapmap_rel;\n        (ab, hmr_\\<alpha> ab) \\<in> hmr_rel\\<rbrakk>\n       \\<Longrightarrow> hm_change_key_op a aa ab\n                         \\<le> \\<Down> heapmap_rel\n                                (ASSERT\n                                  (pre_map_update_ex\n                                    ((a', a'a), a'b)) \\<bind>\n                                 (\\<lambda>_.\n                                     RETURN (op_map_update_ex a' a'a a'b)))", "apply (rule ASSERT_refine_right; clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a' a'a ab b a'b y.\n       \\<lbrakk>((ab, b), a'b) \\<in> heapmap_rel;\n        ((ab, b), hmr_\\<alpha> (ab, b)) \\<in> hmr_rel;\n        a'b a' = Some y\\<rbrakk>\n       \\<Longrightarrow> hm_change_key_op a' a'a (ab, b)\n                         \\<le> \\<Down> heapmap_rel\n                                (RETURN (a'b(a' \\<mapsto> a'a)))", "apply (rule heapmap_nres_relI')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a' a'a ab b a'b y.\n       \\<lbrakk>((ab, b), a'b) \\<in> heapmap_rel;\n        ((ab, b), hmr_\\<alpha> (ab, b)) \\<in> hmr_rel;\n        a'b a' = Some y\\<rbrakk>\n       \\<Longrightarrow> hm_change_key_op a' a'a (ab, b)\n                         \\<le> \\<Down> hmr_rel (?h'17 a' a'a ab b a'b y)\n 2. \\<And>a' a'a ab b a'b y.\n       \\<lbrakk>((ab, b), a'b) \\<in> heapmap_rel;\n        ((ab, b), hmr_\\<alpha> (ab, b)) \\<in> hmr_rel;\n        a'b a' = Some y\\<rbrakk>\n       \\<Longrightarrow> ?h'17 a' a'a ab b a'b y \\<le> SPEC h.heap_invar\n 3. \\<And>a' a'a ab b a'b y.\n       \\<lbrakk>((ab, b), a'b) \\<in> heapmap_rel;\n        ((ab, b), hmr_\\<alpha> (ab, b)) \\<in> hmr_rel;\n        a'b a' = Some y\\<rbrakk>\n       \\<Longrightarrow> hm_change_key_op a' a'a (ab, b) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>hm'.\n                              RETURN (heapmap_\\<alpha> hm')\n                              \\<le> RETURN (a'b(a' \\<mapsto> a'a)))", "apply (rule hm_change_key_op_refine; assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a' a'a ab b a'b y.\n       \\<lbrakk>((ab, b), a'b) \\<in> heapmap_rel;\n        ((ab, b), hmr_\\<alpha> (ab, b)) \\<in> hmr_rel;\n        a'b a' = Some y\\<rbrakk>\n       \\<Longrightarrow> h.change_key_op (hm_index (ab, b) a') a'a\n                          (hmr_\\<alpha> (ab, b))\n                         \\<le> SPEC h.heap_invar\n 2. \\<And>a' a'a ab b a'b y.\n       \\<lbrakk>((ab, b), a'b) \\<in> heapmap_rel;\n        ((ab, b), hmr_\\<alpha> (ab, b)) \\<in> hmr_rel;\n        a'b a' = Some y\\<rbrakk>\n       \\<Longrightarrow> hm_change_key_op a' a'a (ab, b) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>hm'.\n                              RETURN (heapmap_\\<alpha> hm')\n                              \\<le> RETURN (a'b(a' \\<mapsto> a'a)))", "unfolding heapmap_rel_def hmr_rel_def in_br_conv"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a' a'a ab b a'b y.\n       \\<lbrakk>a'b = heapmap_\\<alpha> (ab, b) \\<and> heapmap_invar (ab, b);\n        hmr_\\<alpha> (ab, b) = hmr_\\<alpha> (ab, b) \\<and>\n        hmr_invar (ab, b);\n        a'b a' = Some y\\<rbrakk>\n       \\<Longrightarrow> h.change_key_op (hm_index (ab, b) a') a'a\n                          (hmr_\\<alpha> (ab, b))\n                         \\<le> SPEC h.heap_invar\n 2. \\<And>a' a'a ab b a'b y.\n       \\<lbrakk>a'b = heapmap_\\<alpha> (ab, b) \\<and> heapmap_invar (ab, b);\n        hmr_\\<alpha> (ab, b) = hmr_\\<alpha> (ab, b) \\<and>\n        hmr_invar (ab, b);\n        a'b a' = Some y\\<rbrakk>\n       \\<Longrightarrow> hm_change_key_op a' a'a (ab, b) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>hm'.\n                              RETURN (heapmap_\\<alpha> hm')\n                              \\<le> RETURN (a'b(a' \\<mapsto> a'a)))", "apply (rule h.change_key_op_invar; simp; fail )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a' a'a ab b a'b y.\n       \\<lbrakk>a'b = heapmap_\\<alpha> (ab, b) \\<and> heapmap_invar (ab, b);\n        hmr_\\<alpha> (ab, b) = hmr_\\<alpha> (ab, b) \\<and>\n        hmr_invar (ab, b);\n        a'b a' = Some y\\<rbrakk>\n       \\<Longrightarrow> hm_change_key_op a' a'a (ab, b) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>hm'.\n                              RETURN (heapmap_\\<alpha> hm')\n                              \\<le> RETURN (a'b(a' \\<mapsto> a'a)))", "apply ((refine_vcg hm_change_key_op_\\<alpha>_correct[THEN leof_trans]; simp))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Set\\<close>"], ["", "text \\<open>Realized as generic algorithm!\\<close>"], ["", "(* TODO: Implement as such! *)"], ["", "lemma (in -) op_pm_set_gen_impl: \"RETURN ooo op_map_update = (\\<lambda>k v m. do {\n      c \\<leftarrow> RETURN (op_map_contains_key k m);\n      if c then \n        mop_map_update_ex k v m\n      else\n        mop_map_update_new k v m\n    })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN \\<circ>\\<circ>\\<circ> op_map_update =\n    (\\<lambda>k v m.\n        RETURN (op_map_contains_key k m) \\<bind>\n        (\\<lambda>c.\n            if c then mop_map_update_ex k v m\n            else mop_map_update_new k v m))", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa m.\n       (RETURN \\<circ>\\<circ>\\<circ> op_map_update) x xa m =\n       RETURN (op_map_contains_key x m) \\<bind>\n       (\\<lambda>c.\n           if c then mop_map_update_ex x xa m\n           else mop_map_update_new x xa m)", "unfolding op_map_contains_key_def mop_map_update_ex_def mop_map_update_new_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa m.\n       (RETURN \\<circ>\\<circ>\\<circ> op_map_update) x xa m =\n       RETURN (x \\<in> dom m) \\<bind>\n       (\\<lambda>c.\n           if c\n           then curry2\n                 (mop pre_map_update_ex\n                   (uncurry2\n                     (RETURN \\<circ>\\<circ>\\<circ> op_map_update_ex)))\n                 x xa m\n           else curry2\n                 (mop pre_map_update_new\n                   (uncurry2\n                     (RETURN \\<circ>\\<circ>\\<circ> op_map_update_new)))\n                 x xa m)", "by simp"], ["", "definition \"hm_set_op k v hm \\<equiv> do {\n      c \\<leftarrow> hm_contains_key_op k hm;\n      if c then\n        hm_change_key_op k v hm\n      else\n        hm_insert_op k v hm\n    }\""], ["", "lemma hm_set_op_aref: \n      \"(hm_set_op, RETURN ooo op_map_update) \\<in> Id \\<rightarrow> Id \\<rightarrow> heapmap_rel \\<rightarrow> \\<langle>heapmap_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hm_set_op, RETURN \\<circ>\\<circ>\\<circ> op_map_update)\n    \\<in> Id \\<rightarrow>\n          Id \\<rightarrow>\n          heapmap_rel \\<rightarrow> \\<langle>heapmap_rel\\<rangle>nres_rel", "unfolding op_pm_set_gen_impl"], ["proof (prove)\ngoal (1 subgoal):\n 1. (hm_set_op,\n     \\<lambda>k v m.\n        RETURN (op_map_contains_key k m) \\<bind>\n        (\\<lambda>c.\n            if c then mop_map_update_ex k v m\n            else mop_map_update_new k v m))\n    \\<in> Id \\<rightarrow>\n          Id \\<rightarrow>\n          heapmap_rel \\<rightarrow> \\<langle>heapmap_rel\\<rangle>nres_rel", "apply (intro fun_relI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> Id;\n        (ab, a'b) \\<in> heapmap_rel\\<rbrakk>\n       \\<Longrightarrow> hm_set_op a aa ab\n                         \\<le> \\<Down> heapmap_rel\n                                (RETURN (op_map_contains_key a' a'b) \\<bind>\n                                 (\\<lambda>c.\n                                     if c then mop_map_update_ex a' a'a a'b\n                                     else mop_map_update_new a' a'a a'b))", "unfolding hm_set_op_def o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> Id;\n        (ab, a'b) \\<in> heapmap_rel\\<rbrakk>\n       \\<Longrightarrow> hm_contains_key_op a ab \\<bind>\n                         (\\<lambda>c.\n                             if c then hm_change_key_op a aa ab\n                             else hm_insert_op a aa ab)\n                         \\<le> \\<Down> heapmap_rel\n                                (RETURN (op_map_contains_key a' a'b) \\<bind>\n                                 (\\<lambda>c.\n                                     if c then mop_map_update_ex a' a'a a'b\n                                     else mop_map_update_new a' a'a a'b))", "apply (refine_rcg \n        hm_contains_key_op_aref[param_fo, unfolded o_def, THEN nres_relD]\n        hm_change_key_op_aref[param_fo, THEN nres_relD]\n        hm_insert_op_aref[param_fo, THEN nres_relD]\n        )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b c ca.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> Id;\n        (ab, a'b) \\<in> heapmap_rel; (c, ca) \\<in> bool_rel\\<rbrakk>\n       \\<Longrightarrow> c = ca", "by auto"], ["", "subsubsection \\<open>Pop-Min\\<close>"], ["", "definition hm_pop_min_op :: \"('k,'v) ahm \\<Rightarrow> (('k\\<times>'v) \\<times> ('k,'v) ahm) nres\" where\n      \"hm_pop_min_op hm \\<equiv> do {\n        ASSERT (heapmap_invar hm);\n        ASSERT (hm_valid hm 1);\n        k \\<leftarrow> hm_key_of_op hm 1;\n        v \\<leftarrow> hm_the_lookup_op hm k;\n        let l = hm_length hm;\n        hm \\<leftarrow> hm_exch_op hm 1 l;\n        hm \\<leftarrow> hm_butlast_op hm;\n        \n        if (l\\<noteq>1) then do {\n          hm \\<leftarrow> hm_sink_op hm 1;\n          RETURN ((k,v),hm)\n        } else RETURN ((k,v),hm)\n      }\""], ["", "lemma hm_pop_min_op_refine: \n      \"(hm_pop_min_op, h.pop_min_op) \\<in> hmr_rel \\<rightarrow> \\<langle>UNIV \\<times>\\<^sub>r hmr_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hm_pop_min_op, h.pop_min_op)\n    \\<in> hmr_rel \\<rightarrow>\n          \\<langle>UNIV \\<times>\\<^sub>r hmr_rel\\<rangle>nres_rel", "apply (intro fun_relI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> hmr_rel \\<Longrightarrow>\n       hm_pop_min_op a\n       \\<le> \\<Down> (UNIV \\<times>\\<^sub>r hmr_rel) (h.pop_min_op a')", "unfolding hm_pop_min_op_def h.pop_min_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> hmr_rel \\<Longrightarrow>\n       ASSERT (heapmap_invar a) \\<bind>\n       (\\<lambda>_.\n           ASSERT (hm_valid a 1) \\<bind>\n           (\\<lambda>_.\n               hm_key_of_op a 1 \\<bind>\n               (\\<lambda>k.\n                   hm_the_lookup_op a k \\<bind>\n                   (\\<lambda>v.\n                       let l = hm_length a\n                       in hm_exch_op a 1 l \\<bind>\n                          (\\<lambda>hm.\n                              hm_butlast_op hm \\<bind>\n                              (\\<lambda>hm.\n                                  if l \\<noteq> 1\n                                  then hm_sink_op hm 1 \\<bind>\n (\\<lambda>hm. RETURN ((k, v), hm))\n                                  else RETURN ((k, v), hm)))))))\n       \\<le> \\<Down> (UNIV \\<times>\\<^sub>r hmr_rel)\n              (ASSERT (h.heap_invar a') \\<bind>\n               (\\<lambda>_.\n                   ASSERT (h.valid a' 1) \\<bind>\n                   (\\<lambda>_.\n                       h.val_of_op a' 1 \\<bind>\n                       (\\<lambda>m.\n                           let l = length a'\n                           in h.exch_op a' 1 l \\<bind>\n                              (\\<lambda>h.\n                                  h.butlast_op h \\<bind>\n                                  (\\<lambda>h.\nif l \\<noteq> 1 then h.sink_op h 1 \\<bind> (\\<lambda>h. RETURN (m, h))\nelse RETURN (m, h)))))))", "(* Project away stuff of second component *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> hmr_rel \\<Longrightarrow>\n       ASSERT (heapmap_invar a) \\<bind>\n       (\\<lambda>_.\n           ASSERT (hm_valid a 1) \\<bind>\n           (\\<lambda>_.\n               hm_key_of_op a 1 \\<bind>\n               (\\<lambda>k.\n                   hm_the_lookup_op a k \\<bind>\n                   (\\<lambda>v.\n                       let l = hm_length a\n                       in hm_exch_op a 1 l \\<bind>\n                          (\\<lambda>hm.\n                              hm_butlast_op hm \\<bind>\n                              (\\<lambda>hm.\n                                  if l \\<noteq> 1\n                                  then hm_sink_op hm 1 \\<bind>\n (\\<lambda>hm. RETURN ((k, v), hm))\n                                  else RETURN ((k, v), hm)))))))\n       \\<le> \\<Down> (UNIV \\<times>\\<^sub>r hmr_rel)\n              (ASSERT (h.heap_invar a') \\<bind>\n               (\\<lambda>_.\n                   ASSERT (h.valid a' 1) \\<bind>\n                   (\\<lambda>_.\n                       h.val_of_op a' 1 \\<bind>\n                       (\\<lambda>m.\n                           let l = length a'\n                           in h.exch_op a' 1 l \\<bind>\n                              (\\<lambda>h.\n                                  h.butlast_op h \\<bind>\n                                  (\\<lambda>h.\nif l \\<noteq> 1 then h.sink_op h 1 \\<bind> (\\<lambda>h. RETURN (m, h))\nelse RETURN (m, h)))))))", "unfolding ignore_snd_refine_conv hm_the_lookup_op_def hm_key_of_op_unfold"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> hmr_rel \\<Longrightarrow>\n       ASSERT (heapmap_invar a) \\<bind>\n       (\\<lambda>_.\n           ASSERT (hm_valid a 1) \\<bind>\n           (\\<lambda>_.\n               ASSERT (hm_valid a 1) \\<bind>\n               (\\<lambda>_. RETURN (hm_key_of a 1)) \\<bind>\n               (\\<lambda>k.\n                   ASSERT\n                    (heapmap_\\<alpha> a k \\<noteq> None \\<and>\n                     hmr_invar a) \\<bind>\n                   (\\<lambda>_. RETURN (the (heapmap_\\<alpha> a k))) \\<bind>\n                   (\\<lambda>v.\n                       let l = hm_length a\n                       in hm_exch_op a 1 l \\<bind>\n                          (\\<lambda>hm.\n                              hm_butlast_op hm \\<bind>\n                              (\\<lambda>hm.\n                                  if l \\<noteq> 1\n                                  then hm_sink_op hm 1 \\<bind>\n (\\<lambda>hm. RETURN ((k, v), hm))\n                                  else RETURN ((k, v), hm)))))))\n       \\<le> \\<Down> (UNIV \\<times>\\<^sub>r hmr_rel)\n              (ASSERT (h.heap_invar a') \\<bind>\n               (\\<lambda>_.\n                   ASSERT (h.valid a' 1) \\<bind>\n                   (\\<lambda>_.\n                       h.val_of_op a' 1 \\<bind>\n                       (\\<lambda>m.\n                           let l = length a'\n                           in h.exch_op a' 1 l \\<bind>\n                              (\\<lambda>h.\n                                  h.butlast_op h \\<bind>\n                                  (\\<lambda>h.\nif l \\<noteq> 1 then h.sink_op h 1 \\<bind> (\\<lambda>h. RETURN (m, h))\nelse RETURN (m, h)))))))", "apply (simp cong: if_cong add: Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> hmr_rel \\<Longrightarrow>\n       ASSERT (heapmap_invar a) \\<bind>\n       (\\<lambda>_.\n           ASSERT (hm_valid a (Suc 0)) \\<bind>\n           (\\<lambda>_.\n               ASSERT (hm_valid a (Suc 0)) \\<bind>\n               (\\<lambda>x.\n                   ASSERT\n                    ((\\<exists>y.\n                         heapmap_\\<alpha> a (hm_key_of a (Suc 0)) =\n                         Some y) \\<and>\n                     hmr_invar a) \\<bind>\n                   (\\<lambda>x.\n                       hm_exch_op a (Suc 0) (hm_length a) \\<bind>\n                       (\\<lambda>hm.\n                           hm_butlast_op hm \\<bind>\n                           (\\<lambda>hm.\n                               if hm_length a = Suc 0\n                               then RETURN\n                                     ((hm_key_of a (Suc 0),\n the (heapmap_\\<alpha> a (hm_key_of a (Suc 0)))),\nhm)\n                               else hm_sink_op hm (Suc 0) \\<bind>\n                                    (\\<lambda>hm.\n  RETURN\n   ((hm_key_of a (Suc 0), the (heapmap_\\<alpha> a (hm_key_of a (Suc 0)))),\n    hm))))))))\n       \\<le> \\<Down> (UNIV \\<times>\\<^sub>r hmr_rel)\n              (ASSERT (h.heap_invar a') \\<bind>\n               (\\<lambda>_.\n                   ASSERT (h.valid a' (Suc 0)) \\<bind>\n                   (\\<lambda>_.\n                       h.val_of_op a' (Suc 0) \\<bind>\n                       (\\<lambda>m.\n                           h.exch_op a' (Suc 0) (length a') \\<bind>\n                           (\\<lambda>h.\n                               h.butlast_op h \\<bind>\n                               (\\<lambda>h.\n                                   if length a' = Suc 0 then RETURN (m, h)\n                                   else h.sink_op h (Suc 0) \\<bind>\n  (\\<lambda>h. RETURN (m, h))))))))", "apply (simp add: unused_bind_conv h.val_of_op_def refine_pw_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> hmr_rel \\<Longrightarrow>\n       ASSERT (heapmap_invar a) \\<bind>\n       (\\<lambda>_.\n           ASSERT (hm_valid a (Suc 0)) \\<bind>\n           (\\<lambda>_.\n               ASSERT (hm_valid a (Suc 0)) \\<bind>\n               (\\<lambda>x.\n                   ASSERT\n                    ((\\<exists>y.\n                         heapmap_\\<alpha> a (hm_key_of a (Suc 0)) =\n                         Some y) \\<and>\n                     hmr_invar a) \\<bind>\n                   (\\<lambda>x.\n                       hm_exch_op a (Suc 0) (hm_length a) \\<bind>\n                       (\\<lambda>hm.\n                           hm_butlast_op hm \\<bind>\n                           (\\<lambda>hm.\n                               if hm_length a = Suc 0\n                               then RETURN\n                                     ((hm_key_of a (Suc 0),\n the (heapmap_\\<alpha> a (hm_key_of a (Suc 0)))),\nhm)\n                               else hm_sink_op hm (Suc 0) \\<bind>\n                                    (\\<lambda>hm.\n  RETURN\n   ((hm_key_of a (Suc 0), the (heapmap_\\<alpha> a (hm_key_of a (Suc 0)))),\n    hm))))))))\n       \\<le> \\<Down> (UNIV \\<times>\\<^sub>r hmr_rel)\n              (ASSERT (h.heap_invar a') \\<bind>\n               (\\<lambda>_.\n                   ASSERT (h.valid a' (Suc 0)) \\<bind>\n                   (\\<lambda>_.\n                       ASSERT (a' \\<noteq> []) \\<bind>\n                       (\\<lambda>x.\n                           h.exch_op a' (Suc 0) (length a') \\<bind>\n                           (\\<lambda>h.\n                               h.butlast_op h \\<bind>\n                               (\\<lambda>h.\n                                   if length a' = Suc 0\n                                   then RETURN (a' ! 0, h)\n                                   else h.sink_op h (Suc 0) \\<bind>\n  (\\<lambda>h. RETURN (a' ! 0, h))))))))", "(* Prove refinement *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> hmr_rel \\<Longrightarrow>\n       ASSERT (heapmap_invar a) \\<bind>\n       (\\<lambda>_.\n           ASSERT (hm_valid a (Suc 0)) \\<bind>\n           (\\<lambda>_.\n               ASSERT (hm_valid a (Suc 0)) \\<bind>\n               (\\<lambda>x.\n                   ASSERT\n                    ((\\<exists>y.\n                         heapmap_\\<alpha> a (hm_key_of a (Suc 0)) =\n                         Some y) \\<and>\n                     hmr_invar a) \\<bind>\n                   (\\<lambda>x.\n                       hm_exch_op a (Suc 0) (hm_length a) \\<bind>\n                       (\\<lambda>hm.\n                           hm_butlast_op hm \\<bind>\n                           (\\<lambda>hm.\n                               if hm_length a = Suc 0\n                               then RETURN\n                                     ((hm_key_of a (Suc 0),\n the (heapmap_\\<alpha> a (hm_key_of a (Suc 0)))),\nhm)\n                               else hm_sink_op hm (Suc 0) \\<bind>\n                                    (\\<lambda>hm.\n  RETURN\n   ((hm_key_of a (Suc 0), the (heapmap_\\<alpha> a (hm_key_of a (Suc 0)))),\n    hm))))))))\n       \\<le> \\<Down> (UNIV \\<times>\\<^sub>r hmr_rel)\n              (ASSERT (h.heap_invar a') \\<bind>\n               (\\<lambda>_.\n                   ASSERT (h.valid a' (Suc 0)) \\<bind>\n                   (\\<lambda>_.\n                       ASSERT (a' \\<noteq> []) \\<bind>\n                       (\\<lambda>x.\n                           h.exch_op a' (Suc 0) (length a') \\<bind>\n                           (\\<lambda>h.\n                               h.butlast_op h \\<bind>\n                               (\\<lambda>h.\n                                   if length a' = Suc 0\n                                   then RETURN (a' ! 0, h)\n                                   else h.sink_op h (Suc 0) \\<bind>\n  (\\<lambda>h. RETURN (a' ! 0, h))))))))", "apply refine_rcg"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; h.heap_invar a'; h.valid a' (Suc 0);\n        a' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> heapmap_invar a\n 2. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; h.heap_invar a'; h.valid a' (Suc 0);\n        a' \\<noteq> []; heapmap_invar a\\<rbrakk>\n       \\<Longrightarrow> hm_valid a (Suc 0)\n 3. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; h.heap_invar a'; h.valid a' (Suc 0);\n        a' \\<noteq> []; heapmap_invar a; hm_valid a (Suc 0);\n        hm_valid a (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            heapmap_\\<alpha> a (hm_key_of a (Suc 0)) =\n                            Some y\n 4. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; h.heap_invar a'; h.valid a' (Suc 0);\n        a' \\<noteq> []; heapmap_invar a; hm_valid a (Suc 0);\n        hm_valid a (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> hmr_invar a\n 5. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; h.heap_invar a'; h.valid a' (Suc 0);\n        a' \\<noteq> []; heapmap_invar a; hm_valid a (Suc 0);\n        hm_valid a (Suc 0);\n        (\\<exists>y.\n            heapmap_\\<alpha> a (hm_key_of a (Suc 0)) = Some y) \\<and>\n        hmr_invar a\\<rbrakk>\n       \\<Longrightarrow> (Suc 0, Suc 0) \\<in> nat_rel\n 6. \\<And>a a' hm h hma ha.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; h.heap_invar a'; h.valid a' (Suc 0);\n        a' \\<noteq> []; heapmap_invar a; hm_valid a (Suc 0);\n        hm_valid a (Suc 0);\n        (\\<exists>y.\n            heapmap_\\<alpha> a (hm_key_of a (Suc 0)) = Some y) \\<and>\n        hmr_invar a;\n        (hm, h) \\<in> hmr_rel; (hma, ha) \\<in> hmr_rel\\<rbrakk>\n       \\<Longrightarrow> (hm_length a = Suc 0) = (length a' = Suc 0)\n 7. \\<And>a a' hm h hma ha.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; h.heap_invar a'; h.valid a' (Suc 0);\n        a' \\<noteq> []; heapmap_invar a; hm_valid a (Suc 0);\n        hm_valid a (Suc 0);\n        (\\<exists>y.\n            heapmap_\\<alpha> a (hm_key_of a (Suc 0)) = Some y) \\<and>\n        hmr_invar a;\n        (hm, h) \\<in> hmr_rel; (hma, ha) \\<in> hmr_rel; hm_length a = Suc 0;\n        length a' = Suc 0\\<rbrakk>\n       \\<Longrightarrow> (((hm_key_of a (Suc 0),\n                            the (heapmap_\\<alpha> a (hm_key_of a (Suc 0)))),\n                           hma),\n                          a' ! 0, ha)\n                         \\<in> UNIV \\<times>\\<^sub>r hmr_rel\n 8. \\<And>a a' hm h hma ha.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; h.heap_invar a'; h.valid a' (Suc 0);\n        a' \\<noteq> []; heapmap_invar a; hm_valid a (Suc 0);\n        hm_valid a (Suc 0);\n        (\\<exists>y.\n            heapmap_\\<alpha> a (hm_key_of a (Suc 0)) = Some y) \\<and>\n        hmr_invar a;\n        (hm, h) \\<in> hmr_rel; (hma, ha) \\<in> hmr_rel;\n        hm_length a \\<noteq> Suc 0; length a' \\<noteq> Suc 0\\<rbrakk>\n       \\<Longrightarrow> (Suc 0, Suc 0) \\<in> nat_rel\n 9. \\<And>a a' hm h hma ha hmb hb.\n       \\<lbrakk>(a, a') \\<in> hmr_rel; h.heap_invar a'; h.valid a' (Suc 0);\n        a' \\<noteq> []; heapmap_invar a; hm_valid a (Suc 0);\n        hm_valid a (Suc 0);\n        (\\<exists>y.\n            heapmap_\\<alpha> a (hm_key_of a (Suc 0)) = Some y) \\<and>\n        hmr_invar a;\n        (hm, h) \\<in> hmr_rel; (hma, ha) \\<in> hmr_rel;\n        hm_length a \\<noteq> Suc 0; length a' \\<noteq> Suc 0;\n        (hmb, hb) \\<in> hmr_rel\\<rbrakk>\n       \\<Longrightarrow> (((hm_key_of a (Suc 0),\n                            the (heapmap_\\<alpha> a (hm_key_of a (Suc 0)))),\n                           hmb),\n                          a' ! 0, hb)\n                         \\<in> UNIV \\<times>\\<^sub>r hmr_rel", "unfolding hmr_rel_def in_br_conv"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>a' = hmr_\\<alpha> a \\<and> hmr_invar a; h.heap_invar a';\n        h.valid a' (Suc 0); a' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> heapmap_invar a\n 2. \\<And>a a'.\n       \\<lbrakk>a' = hmr_\\<alpha> a \\<and> hmr_invar a; h.heap_invar a';\n        h.valid a' (Suc 0); a' \\<noteq> []; heapmap_invar a\\<rbrakk>\n       \\<Longrightarrow> hm_valid a (Suc 0)\n 3. \\<And>a a'.\n       \\<lbrakk>a' = hmr_\\<alpha> a \\<and> hmr_invar a; h.heap_invar a';\n        h.valid a' (Suc 0); a' \\<noteq> []; heapmap_invar a;\n        hm_valid a (Suc 0); hm_valid a (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            heapmap_\\<alpha> a (hm_key_of a (Suc 0)) =\n                            Some y\n 4. \\<And>a a'.\n       \\<lbrakk>a' = hmr_\\<alpha> a \\<and> hmr_invar a; h.heap_invar a';\n        h.valid a' (Suc 0); a' \\<noteq> []; heapmap_invar a;\n        hm_valid a (Suc 0); hm_valid a (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> hmr_invar a\n 5. \\<And>a a'.\n       \\<lbrakk>a' = hmr_\\<alpha> a \\<and> hmr_invar a; h.heap_invar a';\n        h.valid a' (Suc 0); a' \\<noteq> []; heapmap_invar a;\n        hm_valid a (Suc 0); hm_valid a (Suc 0);\n        (\\<exists>y.\n            heapmap_\\<alpha> a (hm_key_of a (Suc 0)) = Some y) \\<and>\n        hmr_invar a\\<rbrakk>\n       \\<Longrightarrow> (Suc 0, Suc 0) \\<in> nat_rel\n 6. \\<And>a a' hm h hma ha.\n       \\<lbrakk>a' = hmr_\\<alpha> a \\<and> hmr_invar a; h.heap_invar a';\n        h.valid a' (Suc 0); a' \\<noteq> []; heapmap_invar a;\n        hm_valid a (Suc 0); hm_valid a (Suc 0);\n        (\\<exists>y.\n            heapmap_\\<alpha> a (hm_key_of a (Suc 0)) = Some y) \\<and>\n        hmr_invar a;\n        h = hmr_\\<alpha> hm \\<and> hmr_invar hm;\n        ha = hmr_\\<alpha> hma \\<and> hmr_invar hma\\<rbrakk>\n       \\<Longrightarrow> (hm_length a = Suc 0) = (length a' = Suc 0)\n 7. \\<And>a a' hm h hma ha.\n       \\<lbrakk>a' = hmr_\\<alpha> a \\<and> hmr_invar a; h.heap_invar a';\n        h.valid a' (Suc 0); a' \\<noteq> []; heapmap_invar a;\n        hm_valid a (Suc 0); hm_valid a (Suc 0);\n        (\\<exists>y.\n            heapmap_\\<alpha> a (hm_key_of a (Suc 0)) = Some y) \\<and>\n        hmr_invar a;\n        h = hmr_\\<alpha> hm \\<and> hmr_invar hm;\n        ha = hmr_\\<alpha> hma \\<and> hmr_invar hma; hm_length a = Suc 0;\n        length a' = Suc 0\\<rbrakk>\n       \\<Longrightarrow> (((hm_key_of a (Suc 0),\n                            the (heapmap_\\<alpha> a (hm_key_of a (Suc 0)))),\n                           hma),\n                          a' ! 0, ha)\n                         \\<in> UNIV \\<times>\\<^sub>r\n                               br hmr_\\<alpha> hmr_invar\n 8. \\<And>a a' hm h hma ha.\n       \\<lbrakk>a' = hmr_\\<alpha> a \\<and> hmr_invar a; h.heap_invar a';\n        h.valid a' (Suc 0); a' \\<noteq> []; heapmap_invar a;\n        hm_valid a (Suc 0); hm_valid a (Suc 0);\n        (\\<exists>y.\n            heapmap_\\<alpha> a (hm_key_of a (Suc 0)) = Some y) \\<and>\n        hmr_invar a;\n        h = hmr_\\<alpha> hm \\<and> hmr_invar hm;\n        ha = hmr_\\<alpha> hma \\<and> hmr_invar hma;\n        hm_length a \\<noteq> Suc 0; length a' \\<noteq> Suc 0\\<rbrakk>\n       \\<Longrightarrow> (Suc 0, Suc 0) \\<in> nat_rel\n 9. \\<And>a a' hm h hma ha hmb hb.\n       \\<lbrakk>a' = hmr_\\<alpha> a \\<and> hmr_invar a; h.heap_invar a';\n        h.valid a' (Suc 0); a' \\<noteq> []; heapmap_invar a;\n        hm_valid a (Suc 0); hm_valid a (Suc 0);\n        (\\<exists>y.\n            heapmap_\\<alpha> a (hm_key_of a (Suc 0)) = Some y) \\<and>\n        hmr_invar a;\n        h = hmr_\\<alpha> hm \\<and> hmr_invar hm;\n        ha = hmr_\\<alpha> hma \\<and> hmr_invar hma;\n        hm_length a \\<noteq> Suc 0; length a' \\<noteq> Suc 0;\n        hb = hmr_\\<alpha> hmb \\<and> hmr_invar hmb\\<rbrakk>\n       \\<Longrightarrow> (((hm_key_of a (Suc 0),\n                            the (heapmap_\\<alpha> a (hm_key_of a (Suc 0)))),\n                           hmb),\n                          a' ! 0, hb)\n                         \\<in> UNIV \\<times>\\<^sub>r\n                               br hmr_\\<alpha> hmr_invar", "apply (unfold heapmap_invar_def;simp)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>a' = hmr_\\<alpha> a \\<and> hmr_invar a; h.heap_invar a';\n        h.valid a' (Suc 0); a' \\<noteq> []; heapmap_invar a\\<rbrakk>\n       \\<Longrightarrow> hm_valid a (Suc 0)\n 2. \\<And>a a'.\n       \\<lbrakk>a' = hmr_\\<alpha> a \\<and> hmr_invar a; h.heap_invar a';\n        h.valid a' (Suc 0); a' \\<noteq> []; heapmap_invar a;\n        hm_valid a (Suc 0); hm_valid a (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            heapmap_\\<alpha> a (hm_key_of a (Suc 0)) =\n                            Some y\n 3. \\<And>a a'.\n       \\<lbrakk>a' = hmr_\\<alpha> a \\<and> hmr_invar a; h.heap_invar a';\n        h.valid a' (Suc 0); a' \\<noteq> []; heapmap_invar a;\n        hm_valid a (Suc 0); hm_valid a (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> hmr_invar a\n 4. \\<And>a a'.\n       \\<lbrakk>a' = hmr_\\<alpha> a \\<and> hmr_invar a; h.heap_invar a';\n        h.valid a' (Suc 0); a' \\<noteq> []; heapmap_invar a;\n        hm_valid a (Suc 0); hm_valid a (Suc 0);\n        (\\<exists>y.\n            heapmap_\\<alpha> a (hm_key_of a (Suc 0)) = Some y) \\<and>\n        hmr_invar a\\<rbrakk>\n       \\<Longrightarrow> (Suc 0, Suc 0) \\<in> nat_rel\n 5. \\<And>a a' hm h hma ha.\n       \\<lbrakk>a' = hmr_\\<alpha> a \\<and> hmr_invar a; h.heap_invar a';\n        h.valid a' (Suc 0); a' \\<noteq> []; heapmap_invar a;\n        hm_valid a (Suc 0); hm_valid a (Suc 0);\n        (\\<exists>y.\n            heapmap_\\<alpha> a (hm_key_of a (Suc 0)) = Some y) \\<and>\n        hmr_invar a;\n        h = hmr_\\<alpha> hm \\<and> hmr_invar hm;\n        ha = hmr_\\<alpha> hma \\<and> hmr_invar hma\\<rbrakk>\n       \\<Longrightarrow> (hm_length a = Suc 0) = (length a' = Suc 0)\n 6. \\<And>a a' hm h hma ha.\n       \\<lbrakk>a' = hmr_\\<alpha> a \\<and> hmr_invar a; h.heap_invar a';\n        h.valid a' (Suc 0); a' \\<noteq> []; heapmap_invar a;\n        hm_valid a (Suc 0); hm_valid a (Suc 0);\n        (\\<exists>y.\n            heapmap_\\<alpha> a (hm_key_of a (Suc 0)) = Some y) \\<and>\n        hmr_invar a;\n        h = hmr_\\<alpha> hm \\<and> hmr_invar hm;\n        ha = hmr_\\<alpha> hma \\<and> hmr_invar hma; hm_length a = Suc 0;\n        length a' = Suc 0\\<rbrakk>\n       \\<Longrightarrow> (((hm_key_of a (Suc 0),\n                            the (heapmap_\\<alpha> a (hm_key_of a (Suc 0)))),\n                           hma),\n                          a' ! 0, ha)\n                         \\<in> UNIV \\<times>\\<^sub>r\n                               br hmr_\\<alpha> hmr_invar\n 7. \\<And>a a' hm h hma ha.\n       \\<lbrakk>a' = hmr_\\<alpha> a \\<and> hmr_invar a; h.heap_invar a';\n        h.valid a' (Suc 0); a' \\<noteq> []; heapmap_invar a;\n        hm_valid a (Suc 0); hm_valid a (Suc 0);\n        (\\<exists>y.\n            heapmap_\\<alpha> a (hm_key_of a (Suc 0)) = Some y) \\<and>\n        hmr_invar a;\n        h = hmr_\\<alpha> hm \\<and> hmr_invar hm;\n        ha = hmr_\\<alpha> hma \\<and> hmr_invar hma;\n        hm_length a \\<noteq> Suc 0; length a' \\<noteq> Suc 0\\<rbrakk>\n       \\<Longrightarrow> (Suc 0, Suc 0) \\<in> nat_rel\n 8. \\<And>a a' hm h hma ha hmb hb.\n       \\<lbrakk>a' = hmr_\\<alpha> a \\<and> hmr_invar a; h.heap_invar a';\n        h.valid a' (Suc 0); a' \\<noteq> []; heapmap_invar a;\n        hm_valid a (Suc 0); hm_valid a (Suc 0);\n        (\\<exists>y.\n            heapmap_\\<alpha> a (hm_key_of a (Suc 0)) = Some y) \\<and>\n        hmr_invar a;\n        h = hmr_\\<alpha> hm \\<and> hmr_invar hm;\n        ha = hmr_\\<alpha> hma \\<and> hmr_invar hma;\n        hm_length a \\<noteq> Suc 0; length a' \\<noteq> Suc 0;\n        hb = hmr_\\<alpha> hmb \\<and> hmr_invar hmb\\<rbrakk>\n       \\<Longrightarrow> (((hm_key_of a (Suc 0),\n                            the (heapmap_\\<alpha> a (hm_key_of a (Suc 0)))),\n                           hmb),\n                          a' ! 0, hb)\n                         \\<in> UNIV \\<times>\\<^sub>r\n                               br hmr_\\<alpha> hmr_invar", "apply (auto simp: in_br_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>We demonstrate two different approaches for proving correctness \n      here.\n      The first approach uses the relation to plain heaps only to establish\n      the invariant. \n\n      The second approach also uses the relation to heaps to establish \n      correctness of the result.\n\n      The first approach seems to be more robust against badly set \n      up simpsets, which may be the case in early stages of development.\n\n      Assuming a working simpset, the second approach may be less work,\n      and the proof may look more elegant.\n      \\<close>"], ["", "text_raw \\<open>\\paragraph{First approach}\\<close>"], ["", "text \\<open>Transfer heapmin-property to heapmap-domain\\<close>"], ["", "lemma heapmap_min_prop:\n      assumes INV: \"heapmap_invar hm\"  \n      assumes V': \"heapmap_\\<alpha> hm k = Some v'\"\n      assumes NE: \"hm_valid hm (Suc 0)\"\n      shows \"prio (the (heapmap_\\<alpha> hm (hm_key_of hm (Suc 0)))) \\<le> prio v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prio (the (heapmap_\\<alpha> hm (hm_key_of hm (Suc 0)))) \\<le> prio v'", "proof -  \n      \\<comment> \\<open>Transform into the domain of heaps\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. prio (the (heapmap_\\<alpha> hm (hm_key_of hm (Suc 0)))) \\<le> prio v'", "obtain pq m where [simp]: \"hm=(pq,m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pq m. hm = (pq, m) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases hm)"], ["proof (state)\nthis:\n  hm = (pq, m)\n\ngoal (1 subgoal):\n 1. prio (the (heapmap_\\<alpha> hm (hm_key_of hm (Suc 0)))) \\<le> prio v'", "from NE"], ["proof (chain)\npicking this:\n  hm_valid hm (Suc 0)", "have [simp]: \"pq\\<noteq>[]\""], ["proof (prove)\nusing this:\n  hm_valid hm (Suc 0)\n\ngoal (1 subgoal):\n 1. pq \\<noteq> []", "by (auto simp: hm_valid_def hm_length_def)"], ["proof (state)\nthis:\n  pq \\<noteq> []\n\ngoal (1 subgoal):\n 1. prio (the (heapmap_\\<alpha> hm (hm_key_of hm (Suc 0)))) \\<le> prio v'", "have CNV_LHS: \"prio (the (heapmap_\\<alpha> hm (hm_key_of hm (Suc 0)))) \n        = h.prio_of (hmr_\\<alpha> hm) (Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prio (the (heapmap_\\<alpha> hm (hm_key_of hm (Suc 0)))) =\n    h.prio_of (hmr_\\<alpha> hm) (Suc 0)", "by (auto simp: heapmap_\\<alpha>_def hm_key_of_def hmr_\\<alpha>_def h.val_of_def)"], ["proof (state)\nthis:\n  prio (the (heapmap_\\<alpha> hm (hm_key_of hm (Suc 0)))) =\n  h.prio_of (hmr_\\<alpha> hm) (Suc 0)\n\ngoal (1 subgoal):\n 1. prio (the (heapmap_\\<alpha> hm (hm_key_of hm (Suc 0)))) \\<le> prio v'", "from INV"], ["proof (chain)\npicking this:\n  heapmap_invar hm", "have INV': \"h.heap_invar (hmr_\\<alpha> hm)\""], ["proof (prove)\nusing this:\n  heapmap_invar hm\n\ngoal (1 subgoal):\n 1. h.heap_invar (hmr_\\<alpha> hm)", "unfolding heapmap_invar_def"], ["proof (prove)\nusing this:\n  hmr_invar hm \\<and> h.heap_invar (hmr_\\<alpha> hm)\n\ngoal (1 subgoal):\n 1. h.heap_invar (hmr_\\<alpha> hm)", "by auto"], ["proof (state)\nthis:\n  h.heap_invar (hmr_\\<alpha> hm)\n\ngoal (1 subgoal):\n 1. prio (the (heapmap_\\<alpha> hm (hm_key_of hm (Suc 0)))) \\<le> prio v'", "from V' INV"], ["proof (chain)\npicking this:\n  heapmap_\\<alpha> hm k = Some v'\n  heapmap_invar hm", "obtain i where IDX: \"h.valid (hmr_\\<alpha> hm) i\" \n        and CNV_RHS: \"prio v' = h.prio_of (hmr_\\<alpha> hm) i\""], ["proof (prove)\nusing this:\n  heapmap_\\<alpha> hm k = Some v'\n  heapmap_invar hm\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>h.valid (hmr_\\<alpha> hm) i;\n         prio v' = h.prio_of (hmr_\\<alpha> hm) i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (clarsimp simp: heapmap_\\<alpha>_def heapmap_invar_def hmr_invar_def hmr_\\<alpha>_def\n          h.valid_def h.val_of_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i.\n                \\<lbrakk>0 < i \\<and> i \\<le> length pq;\n                 prio v' =\n                 prio (map (the \\<circ> m) pq ! (i - Suc 0))\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     m k = Some v'; distinct pq; dom m = set pq;\n     h.heap_invar (map (the \\<circ> m) pq)\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (metis (no_types, hide_lams) Suc_leI comp_apply diff_Suc_Suc \n          diff_zero domI index_less_size_conv neq0_conv nth_index nth_map \n          old.nat.distinct(2) option.sel)"], ["proof (state)\nthis:\n  h.valid (hmr_\\<alpha> hm) i\n  prio v' = h.prio_of (hmr_\\<alpha> hm) i\n\ngoal (1 subgoal):\n 1. prio (the (heapmap_\\<alpha> hm (hm_key_of hm (Suc 0)))) \\<le> prio v'", "from h.heap_min_prop[OF INV' IDX]"], ["proof (chain)\npicking this:\n  h.prio_of (hmr_\\<alpha> hm) (Suc 0) \\<le> h.prio_of (hmr_\\<alpha> hm) i", "show ?thesis"], ["proof (prove)\nusing this:\n  h.prio_of (hmr_\\<alpha> hm) (Suc 0) \\<le> h.prio_of (hmr_\\<alpha> hm) i\n\ngoal (1 subgoal):\n 1. prio (the (heapmap_\\<alpha> hm (hm_key_of hm (Suc 0)))) \\<le> prio v'", "unfolding CNV_LHS CNV_RHS"], ["proof (prove)\nusing this:\n  h.prio_of (hmr_\\<alpha> hm) (Suc 0) \\<le> h.prio_of (hmr_\\<alpha> hm) i\n\ngoal (1 subgoal):\n 1. h.prio_of (hmr_\\<alpha> hm) (Suc 0) \\<le> h.prio_of (hmr_\\<alpha> hm) i", "."], ["proof (state)\nthis:\n  prio (the (heapmap_\\<alpha> hm (hm_key_of hm (Suc 0)))) \\<le> prio v'\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>With the above lemma, the correctness proof is straightforward\\<close>"], ["", "lemma hm_pop_min_\\<alpha>_correct: \"hm_pop_min_op hm \\<le>\\<^sub>n SPEC (\\<lambda>((k,v),hm'). \n        heapmap_\\<alpha> hm k = Some v \n      \\<and> heapmap_\\<alpha> hm' = (heapmap_\\<alpha> hm)(k:=None) \n      \\<and> (\\<forall>k' v'. heapmap_\\<alpha> hm k' = Some v' \\<longrightarrow> prio v \\<le> prio v'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_pop_min_op hm \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>((k, v), hm').\n         heapmap_\\<alpha> hm k = Some v \\<and>\n         heapmap_\\<alpha> hm' = (heapmap_\\<alpha> hm)(k := None) \\<and>\n         (\\<forall>k' v'.\n             heapmap_\\<alpha> hm k' = Some v' \\<longrightarrow>\n             prio v \\<le> prio v'))", "unfolding hm_pop_min_op_def hm_key_of_op_unfold hm_the_lookup_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (heapmap_invar hm) \\<bind>\n    (\\<lambda>_.\n        ASSERT (hm_valid hm 1) \\<bind>\n        (\\<lambda>_.\n            ASSERT (hm_valid hm 1) \\<bind>\n            (\\<lambda>_. RETURN (hm_key_of hm 1)) \\<bind>\n            (\\<lambda>k.\n                ASSERT\n                 (heapmap_\\<alpha> hm k \\<noteq> None \\<and>\n                  hmr_invar hm) \\<bind>\n                (\\<lambda>_. RETURN (the (heapmap_\\<alpha> hm k))) \\<bind>\n                (\\<lambda>v.\n                    let l = hm_length hm\n                    in hm_exch_op hm 1 l \\<bind>\n                       (\\<lambda>hm.\n                           hm_butlast_op hm \\<bind>\n                           (\\<lambda>hm.\n                               if l \\<noteq> 1\n                               then hm_sink_op hm 1 \\<bind>\n                                    (\\<lambda>hm. RETURN ((k, v), hm))\n                               else RETURN ((k, v), hm))))))) \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>((k, v), hm').\n         heapmap_\\<alpha> hm k = Some v \\<and>\n         heapmap_\\<alpha> hm' = (heapmap_\\<alpha> hm)(k := None) \\<and>\n         (\\<forall>k' v'.\n             heapmap_\\<alpha> hm k' = Some v' \\<longrightarrow>\n             prio v \\<le> prio v'))", "apply (refine_vcg \n        hm_exch_op_\\<alpha>_correct[THEN leof_trans]\n        hm_butlast_op_\\<alpha>_correct[THEN leof_trans]\n        hm_sink_op_\\<alpha>_correct[THEN leof_trans]\n        )"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x xa xb x1 x1a x2 x2a.\n       \\<lbrakk>heapmap_invar hm; hm_valid hm 1; hm_valid hm 1;\n        heapmap_\\<alpha> hm (hm_key_of hm 1) \\<noteq> None \\<and>\n        hmr_invar hm;\n        x \\<in> {hm'.\n                 hm_valid hm 1 \\<and>\n                 hm_valid hm (hm_length hm) \\<and>\n                 hm' = hm_exch hm 1 (hm_length hm)};\n        xa \\<in> {hm'.\n                  heapmap_\\<alpha> hm' = (heapmap_\\<alpha> x)\n                  (hm_key_of x (hm_length x) := None)};\n        hm_length hm \\<noteq> 1;\n        xb \\<in> {hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> xa};\n        x1 = (x1a, x2);\n        ((hm_key_of hm 1, the (heapmap_\\<alpha> hm (hm_key_of hm 1))), xb) =\n        (x1, x2a)\\<rbrakk>\n       \\<Longrightarrow> heapmap_\\<alpha> hm x1a = Some x2\n 2. \\<And>x xa xb x1 x1a x2 x2a.\n       \\<lbrakk>heapmap_invar hm; hm_valid hm 1; hm_valid hm 1;\n        heapmap_\\<alpha> hm (hm_key_of hm 1) \\<noteq> None \\<and>\n        hmr_invar hm;\n        x \\<in> {hm'.\n                 hm_valid hm 1 \\<and>\n                 hm_valid hm (hm_length hm) \\<and>\n                 hm' = hm_exch hm 1 (hm_length hm)};\n        xa \\<in> {hm'.\n                  heapmap_\\<alpha> hm' = (heapmap_\\<alpha> x)\n                  (hm_key_of x (hm_length x) := None)};\n        hm_length hm \\<noteq> 1;\n        xb \\<in> {hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> xa};\n        x1 = (x1a, x2);\n        ((hm_key_of hm 1, the (heapmap_\\<alpha> hm (hm_key_of hm 1))), xb) =\n        (x1, x2a)\\<rbrakk>\n       \\<Longrightarrow> heapmap_\\<alpha> x2a = (heapmap_\\<alpha> hm)\n                         (x1a := None)\n 3. \\<And>x xa xb x1 x1a x2 x2a k' v'.\n       \\<lbrakk>heapmap_invar hm; hm_valid hm 1; hm_valid hm 1;\n        heapmap_\\<alpha> hm (hm_key_of hm 1) \\<noteq> None \\<and>\n        hmr_invar hm;\n        x \\<in> {hm'.\n                 hm_valid hm 1 \\<and>\n                 hm_valid hm (hm_length hm) \\<and>\n                 hm' = hm_exch hm 1 (hm_length hm)};\n        xa \\<in> {hm'.\n                  heapmap_\\<alpha> hm' = (heapmap_\\<alpha> x)\n                  (hm_key_of x (hm_length x) := None)};\n        hm_length hm \\<noteq> 1;\n        xb \\<in> {hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> xa};\n        x1 = (x1a, x2);\n        ((hm_key_of hm 1, the (heapmap_\\<alpha> hm (hm_key_of hm 1))), xb) =\n        (x1, x2a);\n        heapmap_\\<alpha> hm k' = Some v'\\<rbrakk>\n       \\<Longrightarrow> prio x2 \\<le> prio v'\n 4. \\<And>x xa x1 x1a x2 x2a.\n       \\<lbrakk>heapmap_invar hm; hm_valid hm 1; hm_valid hm 1;\n        heapmap_\\<alpha> hm (hm_key_of hm 1) \\<noteq> None \\<and>\n        hmr_invar hm;\n        x \\<in> {hm'.\n                 hm_valid hm 1 \\<and>\n                 hm_valid hm (hm_length hm) \\<and>\n                 hm' = hm_exch hm 1 (hm_length hm)};\n        xa \\<in> {hm'.\n                  heapmap_\\<alpha> hm' = (heapmap_\\<alpha> x)\n                  (hm_key_of x (hm_length x) := None)};\n        \\<not> hm_length hm \\<noteq> 1; x1 = (x1a, x2);\n        ((hm_key_of hm 1, the (heapmap_\\<alpha> hm (hm_key_of hm 1))), xa) =\n        (x1, x2a)\\<rbrakk>\n       \\<Longrightarrow> heapmap_\\<alpha> hm x1a = Some x2\n 5. \\<And>x xa x1 x1a x2 x2a.\n       \\<lbrakk>heapmap_invar hm; hm_valid hm 1; hm_valid hm 1;\n        heapmap_\\<alpha> hm (hm_key_of hm 1) \\<noteq> None \\<and>\n        hmr_invar hm;\n        x \\<in> {hm'.\n                 hm_valid hm 1 \\<and>\n                 hm_valid hm (hm_length hm) \\<and>\n                 hm' = hm_exch hm 1 (hm_length hm)};\n        xa \\<in> {hm'.\n                  heapmap_\\<alpha> hm' = (heapmap_\\<alpha> x)\n                  (hm_key_of x (hm_length x) := None)};\n        \\<not> hm_length hm \\<noteq> 1; x1 = (x1a, x2);\n        ((hm_key_of hm 1, the (heapmap_\\<alpha> hm (hm_key_of hm 1))), xa) =\n        (x1, x2a)\\<rbrakk>\n       \\<Longrightarrow> heapmap_\\<alpha> x2a = (heapmap_\\<alpha> hm)\n                         (x1a := None)\n 6. \\<And>x xa x1 x1a x2 x2a k' v'.\n       \\<lbrakk>heapmap_invar hm; hm_valid hm 1; hm_valid hm 1;\n        heapmap_\\<alpha> hm (hm_key_of hm 1) \\<noteq> None \\<and>\n        hmr_invar hm;\n        x \\<in> {hm'.\n                 hm_valid hm 1 \\<and>\n                 hm_valid hm (hm_length hm) \\<and>\n                 hm' = hm_exch hm 1 (hm_length hm)};\n        xa \\<in> {hm'.\n                  heapmap_\\<alpha> hm' = (heapmap_\\<alpha> x)\n                  (hm_key_of x (hm_length x) := None)};\n        \\<not> hm_length hm \\<noteq> 1; x1 = (x1a, x2);\n        ((hm_key_of hm 1, the (heapmap_\\<alpha> hm (hm_key_of hm 1))), xa) =\n        (x1, x2a);\n        heapmap_\\<alpha> hm k' = Some v'\\<rbrakk>\n       \\<Longrightarrow> prio x2 \\<le> prio v'", "apply (auto simp: heapmap_min_prop)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma heapmap_nres_rel_prodI:\n      assumes \"hmx \\<le> \\<Down>(UNIV \\<times>\\<^sub>r hmr_rel) h'x\"\n      assumes \"h'x \\<le> SPEC (\\<lambda>(_,h'). h.heap_invar h')\"\n      assumes \"hmx \\<le>\\<^sub>n SPEC (\\<lambda>(r,hm'). RETURN (r,heapmap_\\<alpha> hm') \\<le> \\<Down>(R\\<times>\\<^sub>rId) hx)\"\n      shows \"hmx \\<le> \\<Down>(R\\<times>\\<^sub>rheapmap_rel) hx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hmx \\<le> \\<Down> (R \\<times>\\<^sub>r heapmap_rel) hx", "using assms"], ["proof (prove)\nusing this:\n  hmx \\<le> \\<Down> (UNIV \\<times>\\<^sub>r hmr_rel) h'x\n  h'x \\<le> SPEC (\\<lambda>(uu_, y). h.heap_invar y)\n  hmx \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>(r, hm').\n       RETURN (r, heapmap_\\<alpha> hm')\n       \\<le> \\<Down> (R \\<times>\\<^sub>r Id) hx)\n\ngoal (1 subgoal):\n 1. hmx \\<le> \\<Down> (R \\<times>\\<^sub>r heapmap_rel) hx", "unfolding heapmap_rel_def hmr_rel_def br_def heapmap_invar_def"], ["proof (prove)\nusing this:\n  hmx\n  \\<le> \\<Down>\n         (UNIV \\<times>\\<^sub>r\n          {(c, a). a = hmr_\\<alpha> c \\<and> hmr_invar c})\n         h'x\n  h'x \\<le> SPEC (\\<lambda>(uu_, y). h.heap_invar y)\n  hmx \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>(r, hm').\n       RETURN (r, heapmap_\\<alpha> hm')\n       \\<le> \\<Down> (R \\<times>\\<^sub>r Id) hx)\n\ngoal (1 subgoal):\n 1. hmx\n    \\<le> \\<Down>\n           (R \\<times>\\<^sub>r\n            {(c, a).\n             a = heapmap_\\<alpha> c \\<and>\n             hmr_invar c \\<and> h.heap_invar (hmr_\\<alpha> c)})\n           hx", "apply (auto simp: pw_le_iff pw_leof_iff refine_pw_simps; blast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hm_pop_min_op_aref: \"(hm_pop_min_op, PR_CONST (mop_pm_pop_min prio)) \\<in> heapmap_rel \\<rightarrow> \\<langle>(Id\\<times>\\<^sub>rId)\\<times>\\<^sub>rheapmap_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hm_pop_min_op, PR_CONST (mop_pm_pop_min prio))\n    \\<in> heapmap_rel \\<rightarrow>\n          \\<langle>(Id \\<times>\\<^sub>r Id) \\<times>\\<^sub>r\n                   heapmap_rel\\<rangle>nres_rel", "unfolding PR_CONST_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (hm_pop_min_op, mop_pm_pop_min prio)\n    \\<in> heapmap_rel \\<rightarrow>\n          \\<langle>(Id \\<times>\\<^sub>r Id) \\<times>\\<^sub>r\n                   heapmap_rel\\<rangle>nres_rel", "apply (intro fun_relI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> heapmap_rel \\<Longrightarrow>\n       hm_pop_min_op a\n       \\<le> \\<Down> ((Id \\<times>\\<^sub>r Id) \\<times>\\<^sub>r heapmap_rel)\n              (mop_pm_pop_min prio a')", "apply (frule heapmap_hmr_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> heapmap_rel;\n        (a, hmr_\\<alpha> a) \\<in> hmr_rel\\<rbrakk>\n       \\<Longrightarrow> hm_pop_min_op a\n                         \\<le> \\<Down>\n                                ((Id \\<times>\\<^sub>r Id) \\<times>\\<^sub>r\n                                 heapmap_rel)\n                                (mop_pm_pop_min prio a')", "unfolding mop_pm_pop_min_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> heapmap_rel;\n        (a, hmr_\\<alpha> a) \\<in> hmr_rel\\<rbrakk>\n       \\<Longrightarrow> hm_pop_min_op a\n                         \\<le> \\<Down>\n                                ((Id \\<times>\\<^sub>r Id) \\<times>\\<^sub>r\n                                 heapmap_rel)\n                                (ASSERT (pre_pm_pop_min a') \\<bind>\n                                 (\\<lambda>_.\n                                     PR_CONST (op_pm_pop_min prio) a'))", "apply (intro ASSERT_refine_right)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> heapmap_rel;\n        (a, hmr_\\<alpha> a) \\<in> hmr_rel; pre_pm_pop_min a'\\<rbrakk>\n       \\<Longrightarrow> hm_pop_min_op a\n                         \\<le> \\<Down>\n                                ((Id \\<times>\\<^sub>r Id) \\<times>\\<^sub>r\n                                 heapmap_rel)\n                                (PR_CONST (op_pm_pop_min prio) a')", "apply (rule heapmap_nres_rel_prodI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> heapmap_rel;\n        (a, hmr_\\<alpha> a) \\<in> hmr_rel; pre_pm_pop_min a'\\<rbrakk>\n       \\<Longrightarrow> hm_pop_min_op a\n                         \\<le> \\<Down> (UNIV \\<times>\\<^sub>r hmr_rel)\n                                (?h'x5 a a')\n 2. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> heapmap_rel;\n        (a, hmr_\\<alpha> a) \\<in> hmr_rel; pre_pm_pop_min a'\\<rbrakk>\n       \\<Longrightarrow> ?h'x5 a a'\n                         \\<le> SPEC (\\<lambda>(uu_, y). h.heap_invar y)\n 3. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> heapmap_rel;\n        (a, hmr_\\<alpha> a) \\<in> hmr_rel; pre_pm_pop_min a'\\<rbrakk>\n       \\<Longrightarrow> hm_pop_min_op a \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>(r, hm').\n                              RETURN (r, heapmap_\\<alpha> hm')\n                              \\<le> \\<Down>\n                                     ((Id \\<times>\\<^sub>r\n Id) \\<times>\\<^sub>r\nId)\n                                     (PR_CONST (op_pm_pop_min prio) a'))", "apply (rule hm_pop_min_op_refine[param_fo, THEN nres_relD]; assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> heapmap_rel;\n        (a, hmr_\\<alpha> a) \\<in> hmr_rel; pre_pm_pop_min a'\\<rbrakk>\n       \\<Longrightarrow> h.pop_min_op (hmr_\\<alpha> a)\n                         \\<le> SPEC (\\<lambda>(uu_, y). h.heap_invar y)\n 2. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> heapmap_rel;\n        (a, hmr_\\<alpha> a) \\<in> hmr_rel; pre_pm_pop_min a'\\<rbrakk>\n       \\<Longrightarrow> hm_pop_min_op a \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>(r, hm').\n                              RETURN (r, heapmap_\\<alpha> hm')\n                              \\<le> \\<Down>\n                                     ((Id \\<times>\\<^sub>r\n Id) \\<times>\\<^sub>r\nId)\n                                     (PR_CONST (op_pm_pop_min prio) a'))", "unfolding heapmap_rel_def hmr_rel_def in_br_conv"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>a' = heapmap_\\<alpha> a \\<and> heapmap_invar a;\n        hmr_\\<alpha> a = hmr_\\<alpha> a \\<and> hmr_invar a;\n        pre_pm_pop_min a'\\<rbrakk>\n       \\<Longrightarrow> h.pop_min_op (hmr_\\<alpha> a)\n                         \\<le> SPEC (\\<lambda>(uu_, y). h.heap_invar y)\n 2. \\<And>a a'.\n       \\<lbrakk>a' = heapmap_\\<alpha> a \\<and> heapmap_invar a;\n        hmr_\\<alpha> a = hmr_\\<alpha> a \\<and> hmr_invar a;\n        pre_pm_pop_min a'\\<rbrakk>\n       \\<Longrightarrow> hm_pop_min_op a \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>(r, hm').\n                              RETURN (r, heapmap_\\<alpha> hm')\n                              \\<le> \\<Down>\n                                     ((Id \\<times>\\<^sub>r\n Id) \\<times>\\<^sub>r\nId)\n                                     (PR_CONST (op_pm_pop_min prio) a'))", "apply (refine_vcg; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>a' = heapmap_\\<alpha> a \\<and> heapmap_invar a;\n        hmr_\\<alpha> a = hmr_\\<alpha> a \\<and> hmr_invar a;\n        pre_pm_pop_min a'\\<rbrakk>\n       \\<Longrightarrow> hm_pop_min_op a \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>(r, hm').\n                              RETURN (r, heapmap_\\<alpha> hm')\n                              \\<le> \\<Down>\n                                     ((Id \\<times>\\<^sub>r\n Id) \\<times>\\<^sub>r\nId)\n                                     (PR_CONST (op_pm_pop_min prio) a'))", "apply (refine_vcg hm_pop_min_\\<alpha>_correct[THEN leof_trans]; simp split: prod.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text_raw \\<open>\\paragraph{Second approach}\\<close>"], ["", "(* Alternative approach: Also use knowledge about result\n      in multiset domain. Obtaining property seems infeasible at first attempt! *)"], ["", "definition \"hm_kv_of_op hm i \\<equiv> do {\n      ASSERT (hm_valid hm i \\<and> hmr_invar hm);\n      k \\<leftarrow> hm_key_of_op hm i;\n      v \\<leftarrow> hm_the_lookup_op hm k;\n      RETURN (k, v)\n    }\""], ["", "definition \"kvi_rel hm i \\<equiv> {((k,v),v) | k v. hm_key_of hm i = k}\""], ["", "lemma hm_kv_op_refine[refine]:\n      assumes \"(hm,h)\\<in>hmr_rel\"\n      shows \"hm_kv_of_op hm i \\<le> \\<Down>(kvi_rel hm i) (h.val_of_op h i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_kv_of_op hm i \\<le> \\<Down> (kvi_rel hm i) (h.val_of_op h i)", "unfolding hm_kv_of_op_def h.val_of_op_def kvi_rel_def \n        hm_key_of_op_unfold hm_the_lookup_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (hm_valid hm i \\<and> hmr_invar hm) \\<bind>\n    (\\<lambda>_.\n        ASSERT (hm_valid hm i) \\<bind>\n        (\\<lambda>_. RETURN (hm_key_of hm i)) \\<bind>\n        (\\<lambda>k.\n            ASSERT\n             (heapmap_\\<alpha> hm k \\<noteq> None \\<and>\n              hmr_invar hm) \\<bind>\n            (\\<lambda>_. RETURN (the (heapmap_\\<alpha> hm k))) \\<bind>\n            (\\<lambda>v. RETURN (k, v))))\n    \\<le> \\<Down> {((k, v), v) |k v. hm_key_of hm i = k}\n           (ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_get h (i - 1)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (hm_valid hm i \\<and> hmr_invar hm) \\<bind>\n    (\\<lambda>_.\n        ASSERT (hm_valid hm i) \\<bind>\n        (\\<lambda>x.\n            ASSERT\n             ((\\<exists>y.\n                  heapmap_\\<alpha> hm (hm_key_of hm i) = Some y) \\<and>\n              hmr_invar hm) \\<bind>\n            (\\<lambda>x.\n                RETURN\n                 (hm_key_of hm i,\n                  the (heapmap_\\<alpha> hm (hm_key_of hm i))))))\n    \\<le> \\<Down> {uu_. \\<exists>v. uu_ = ((hm_key_of hm i, v), v)}\n           (ASSERT (0 < i) \\<bind>\n            (\\<lambda>_.\n                ASSERT (i - Suc 0 < length h) \\<bind>\n                (\\<lambda>_. RETURN (h ! (i - Suc 0)))))", "apply refine_vcg"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>0 < i; i - Suc 0 < length h\\<rbrakk>\n    \\<Longrightarrow> hm_valid hm i\n 2. \\<lbrakk>0 < i; i - Suc 0 < length h\\<rbrakk>\n    \\<Longrightarrow> hmr_invar hm\n 3. \\<lbrakk>0 < i; i - Suc 0 < length h;\n     hm_valid hm i \\<and> hmr_invar hm\\<rbrakk>\n    \\<Longrightarrow> hm_valid hm i\n 4. \\<lbrakk>0 < i; i - Suc 0 < length h; hm_valid hm i \\<and> hmr_invar hm;\n     hm_valid hm i\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y.\n                         heapmap_\\<alpha> hm (hm_key_of hm i) = Some y\n 5. \\<lbrakk>0 < i; i - Suc 0 < length h; hm_valid hm i \\<and> hmr_invar hm;\n     hm_valid hm i\\<rbrakk>\n    \\<Longrightarrow> hmr_invar hm\n 6. \\<lbrakk>0 < i; i - Suc 0 < length h; hm_valid hm i \\<and> hmr_invar hm;\n     hm_valid hm i;\n     (\\<exists>y. heapmap_\\<alpha> hm (hm_key_of hm i) = Some y) \\<and>\n     hmr_invar hm\\<rbrakk>\n    \\<Longrightarrow> ((hm_key_of hm i,\n                        the (heapmap_\\<alpha> hm (hm_key_of hm i))),\n                       h ! (i - Suc 0))\n                      \\<in> {uu_.\n                             \\<exists>v. uu_ = ((hm_key_of hm i, v), v)}", "using assms"], ["proof (prove)\nusing this:\n  (hm, h) \\<in> hmr_rel\n\ngoal (6 subgoals):\n 1. \\<lbrakk>0 < i; i - Suc 0 < length h\\<rbrakk>\n    \\<Longrightarrow> hm_valid hm i\n 2. \\<lbrakk>0 < i; i - Suc 0 < length h\\<rbrakk>\n    \\<Longrightarrow> hmr_invar hm\n 3. \\<lbrakk>0 < i; i - Suc 0 < length h;\n     hm_valid hm i \\<and> hmr_invar hm\\<rbrakk>\n    \\<Longrightarrow> hm_valid hm i\n 4. \\<lbrakk>0 < i; i - Suc 0 < length h; hm_valid hm i \\<and> hmr_invar hm;\n     hm_valid hm i\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y.\n                         heapmap_\\<alpha> hm (hm_key_of hm i) = Some y\n 5. \\<lbrakk>0 < i; i - Suc 0 < length h; hm_valid hm i \\<and> hmr_invar hm;\n     hm_valid hm i\\<rbrakk>\n    \\<Longrightarrow> hmr_invar hm\n 6. \\<lbrakk>0 < i; i - Suc 0 < length h; hm_valid hm i \\<and> hmr_invar hm;\n     hm_valid hm i;\n     (\\<exists>y. heapmap_\\<alpha> hm (hm_key_of hm i) = Some y) \\<and>\n     hmr_invar hm\\<rbrakk>\n    \\<Longrightarrow> ((hm_key_of hm i,\n                        the (heapmap_\\<alpha> hm (hm_key_of hm i))),\n                       h ! (i - Suc 0))\n                      \\<in> {uu_.\n                             \\<exists>v. uu_ = ((hm_key_of hm i, v), v)}", "by (auto \n        simp: hm_valid_def hm_length_def hmr_rel_defs heapmap_\\<alpha>_def hm_key_of_def\n        split: prod.splits)"], ["", "definition hm_pop_min_op' :: \"('k,'v) ahm \\<Rightarrow> (('k\\<times>'v) \\<times> ('k,'v) ahm) nres\" where\n      \"hm_pop_min_op' hm \\<equiv> do {\n        ASSERT (heapmap_invar hm);\n        ASSERT (hm_valid hm 1);\n        kv \\<leftarrow> hm_kv_of_op hm 1;\n        let l = hm_length hm;\n        hm \\<leftarrow> hm_exch_op hm 1 l;\n        hm \\<leftarrow> hm_butlast_op hm;\n        \n        if (l\\<noteq>1) then do {\n          hm \\<leftarrow> hm_sink_op hm 1;\n          RETURN (kv,hm)\n        } else RETURN (kv,hm)\n      }\""], ["", "lemma hm_pop_min_op_refine': \n      \"\\<lbrakk> (hm,h)\\<in>hmr_rel \\<rbrakk> \\<Longrightarrow> hm_pop_min_op' hm \\<le> \\<Down>(kvi_rel hm 1 \\<times>\\<^sub>r hmr_rel) (h.pop_min_op h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hm, h) \\<in> hmr_rel \\<Longrightarrow>\n    hm_pop_min_op' hm\n    \\<le> \\<Down> (kvi_rel hm 1 \\<times>\\<^sub>r hmr_rel) (h.pop_min_op h)", "unfolding hm_pop_min_op'_def h.pop_min_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (hm, h) \\<in> hmr_rel \\<Longrightarrow>\n    ASSERT (heapmap_invar hm) \\<bind>\n    (\\<lambda>_.\n        ASSERT (hm_valid hm 1) \\<bind>\n        (\\<lambda>_.\n            hm_kv_of_op hm 1 \\<bind>\n            (\\<lambda>kv.\n                let l = hm_length hm\n                in hm_exch_op hm 1 l \\<bind>\n                   (\\<lambda>hm.\n                       hm_butlast_op hm \\<bind>\n                       (\\<lambda>hm.\n                           if l \\<noteq> 1\n                           then hm_sink_op hm 1 \\<bind>\n                                (\\<lambda>hm. RETURN (kv, hm))\n                           else RETURN (kv, hm))))))\n    \\<le> \\<Down> (kvi_rel hm 1 \\<times>\\<^sub>r hmr_rel)\n           (ASSERT (h.heap_invar h) \\<bind>\n            (\\<lambda>_.\n                ASSERT (h.valid h 1) \\<bind>\n                (\\<lambda>_.\n                    h.val_of_op h 1 \\<bind>\n                    (\\<lambda>m.\n                        let l = length h\n                        in h.exch_op h 1 l \\<bind>\n                           (\\<lambda>h.\n                               h.butlast_op h \\<bind>\n                               (\\<lambda>h.\n                                   if l \\<noteq> 1\n                                   then h.sink_op h 1 \\<bind>\n  (\\<lambda>h. RETURN (m, h))\n                                   else RETURN (m, h)))))))", "(* Project away stuff of second component *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (hm, h) \\<in> hmr_rel \\<Longrightarrow>\n    ASSERT (heapmap_invar hm) \\<bind>\n    (\\<lambda>_.\n        ASSERT (hm_valid hm 1) \\<bind>\n        (\\<lambda>_.\n            hm_kv_of_op hm 1 \\<bind>\n            (\\<lambda>kv.\n                let l = hm_length hm\n                in hm_exch_op hm 1 l \\<bind>\n                   (\\<lambda>hm.\n                       hm_butlast_op hm \\<bind>\n                       (\\<lambda>hm.\n                           if l \\<noteq> 1\n                           then hm_sink_op hm 1 \\<bind>\n                                (\\<lambda>hm. RETURN (kv, hm))\n                           else RETURN (kv, hm))))))\n    \\<le> \\<Down> (kvi_rel hm 1 \\<times>\\<^sub>r hmr_rel)\n           (ASSERT (h.heap_invar h) \\<bind>\n            (\\<lambda>_.\n                ASSERT (h.valid h 1) \\<bind>\n                (\\<lambda>_.\n                    h.val_of_op h 1 \\<bind>\n                    (\\<lambda>m.\n                        let l = length h\n                        in h.exch_op h 1 l \\<bind>\n                           (\\<lambda>h.\n                               h.butlast_op h \\<bind>\n                               (\\<lambda>h.\n                                   if l \\<noteq> 1\n                                   then h.sink_op h 1 \\<bind>\n  (\\<lambda>h. RETURN (m, h))\n                                   else RETURN (m, h)))))))", "unfolding ignore_snd_refine_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (hm, h) \\<in> hmr_rel \\<Longrightarrow>\n    ASSERT (heapmap_invar hm) \\<bind>\n    (\\<lambda>_.\n        ASSERT (hm_valid hm 1) \\<bind>\n        (\\<lambda>_.\n            hm_kv_of_op hm 1 \\<bind>\n            (\\<lambda>kv.\n                let l = hm_length hm\n                in hm_exch_op hm 1 l \\<bind>\n                   (\\<lambda>hm.\n                       hm_butlast_op hm \\<bind>\n                       (\\<lambda>hm.\n                           if l \\<noteq> 1\n                           then hm_sink_op hm 1 \\<bind>\n                                (\\<lambda>hm. RETURN (kv, hm))\n                           else RETURN (kv, hm))))))\n    \\<le> \\<Down> (kvi_rel hm 1 \\<times>\\<^sub>r hmr_rel)\n           (ASSERT (h.heap_invar h) \\<bind>\n            (\\<lambda>_.\n                ASSERT (h.valid h 1) \\<bind>\n                (\\<lambda>_.\n                    h.val_of_op h 1 \\<bind>\n                    (\\<lambda>m.\n                        let l = length h\n                        in h.exch_op h 1 l \\<bind>\n                           (\\<lambda>h.\n                               h.butlast_op h \\<bind>\n                               (\\<lambda>h.\n                                   if l \\<noteq> 1\n                                   then h.sink_op h 1 \\<bind>\n  (\\<lambda>h. RETURN (m, h))\n                                   else RETURN (m, h)))))))", "(* Prove refinement *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (hm, h) \\<in> hmr_rel \\<Longrightarrow>\n    ASSERT (heapmap_invar hm) \\<bind>\n    (\\<lambda>_.\n        ASSERT (hm_valid hm 1) \\<bind>\n        (\\<lambda>_.\n            hm_kv_of_op hm 1 \\<bind>\n            (\\<lambda>kv.\n                let l = hm_length hm\n                in hm_exch_op hm 1 l \\<bind>\n                   (\\<lambda>hm.\n                       hm_butlast_op hm \\<bind>\n                       (\\<lambda>hm.\n                           if l \\<noteq> 1\n                           then hm_sink_op hm 1 \\<bind>\n                                (\\<lambda>hm. RETURN (kv, hm))\n                           else RETURN (kv, hm))))))\n    \\<le> \\<Down> (kvi_rel hm 1 \\<times>\\<^sub>r hmr_rel)\n           (ASSERT (h.heap_invar h) \\<bind>\n            (\\<lambda>_.\n                ASSERT (h.valid h 1) \\<bind>\n                (\\<lambda>_.\n                    h.val_of_op h 1 \\<bind>\n                    (\\<lambda>m.\n                        let l = length h\n                        in h.exch_op h 1 l \\<bind>\n                           (\\<lambda>h.\n                               h.butlast_op h \\<bind>\n                               (\\<lambda>h.\n                                   if l \\<noteq> 1\n                                   then h.sink_op h 1 \\<bind>\n  (\\<lambda>h. RETURN (m, h))\n                                   else RETURN (m, h)))))))", "apply refine_rcg"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>(hm, h) \\<in> hmr_rel; h.heap_invar h; h.valid h 1\\<rbrakk>\n    \\<Longrightarrow> heapmap_invar hm\n 2. \\<lbrakk>(hm, h) \\<in> hmr_rel; h.heap_invar h; h.valid h 1;\n     heapmap_invar hm\\<rbrakk>\n    \\<Longrightarrow> hm_valid hm 1\n 3. \\<And>kv m.\n       \\<lbrakk>(hm, h) \\<in> hmr_rel; h.heap_invar h; h.valid h 1;\n        heapmap_invar hm; hm_valid hm 1; (kv, m) \\<in> kvi_rel hm 1\\<rbrakk>\n       \\<Longrightarrow> (1, 1) \\<in> nat_rel\n 4. \\<And>kv m hma ha hmaa haa.\n       \\<lbrakk>(hm, h) \\<in> hmr_rel; h.heap_invar h; h.valid h 1;\n        heapmap_invar hm; hm_valid hm 1; (kv, m) \\<in> kvi_rel hm 1;\n        (hma, ha) \\<in> hmr_rel; (hmaa, haa) \\<in> hmr_rel\\<rbrakk>\n       \\<Longrightarrow> (hm_length hm \\<noteq> 1) = (length h \\<noteq> 1)\n 5. \\<And>kv m hma ha hmaa haa.\n       \\<lbrakk>(hm, h) \\<in> hmr_rel; h.heap_invar h; h.valid h 1;\n        heapmap_invar hm; hm_valid hm 1; (kv, m) \\<in> kvi_rel hm 1;\n        (hma, ha) \\<in> hmr_rel; (hmaa, haa) \\<in> hmr_rel;\n        hm_length hm \\<noteq> 1; length h \\<noteq> 1\\<rbrakk>\n       \\<Longrightarrow> (1, 1) \\<in> nat_rel\n 6. \\<And>kv m hma ha hmaa haa hmb hb.\n       \\<lbrakk>(hm, h) \\<in> hmr_rel; h.heap_invar h; h.valid h 1;\n        heapmap_invar hm; hm_valid hm 1; (kv, m) \\<in> kvi_rel hm 1;\n        (hma, ha) \\<in> hmr_rel; (hmaa, haa) \\<in> hmr_rel;\n        hm_length hm \\<noteq> 1; length h \\<noteq> 1;\n        (hmb, hb) \\<in> hmr_rel\\<rbrakk>\n       \\<Longrightarrow> ((kv, hmb), m, hb)\n                         \\<in> kvi_rel hm 1 \\<times>\\<^sub>r hmr_rel\n 7. \\<And>kv m hma ha hmaa haa.\n       \\<lbrakk>(hm, h) \\<in> hmr_rel; h.heap_invar h; h.valid h 1;\n        heapmap_invar hm; hm_valid hm 1; (kv, m) \\<in> kvi_rel hm 1;\n        (hma, ha) \\<in> hmr_rel; (hmaa, haa) \\<in> hmr_rel;\n        \\<not> hm_length hm \\<noteq> 1; \\<not> length h \\<noteq> 1\\<rbrakk>\n       \\<Longrightarrow> ((kv, hmaa), m, haa)\n                         \\<in> kvi_rel hm 1 \\<times>\\<^sub>r hmr_rel", "unfolding hmr_rel_def heapmap_rel_def"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>(hm, h) \\<in> br hmr_\\<alpha> hmr_invar; h.heap_invar h;\n     h.valid h 1\\<rbrakk>\n    \\<Longrightarrow> heapmap_invar hm\n 2. \\<lbrakk>(hm, h) \\<in> br hmr_\\<alpha> hmr_invar; h.heap_invar h;\n     h.valid h 1; heapmap_invar hm\\<rbrakk>\n    \\<Longrightarrow> hm_valid hm 1\n 3. \\<And>kv m.\n       \\<lbrakk>(hm, h) \\<in> br hmr_\\<alpha> hmr_invar; h.heap_invar h;\n        h.valid h 1; heapmap_invar hm; hm_valid hm 1;\n        (kv, m) \\<in> kvi_rel hm 1\\<rbrakk>\n       \\<Longrightarrow> (1, 1) \\<in> nat_rel\n 4. \\<And>kv m hma ha hmaa haa.\n       \\<lbrakk>(hm, h) \\<in> br hmr_\\<alpha> hmr_invar; h.heap_invar h;\n        h.valid h 1; heapmap_invar hm; hm_valid hm 1;\n        (kv, m) \\<in> kvi_rel hm 1;\n        (hma, ha) \\<in> br hmr_\\<alpha> hmr_invar;\n        (hmaa, haa) \\<in> br hmr_\\<alpha> hmr_invar\\<rbrakk>\n       \\<Longrightarrow> (hm_length hm \\<noteq> 1) = (length h \\<noteq> 1)\n 5. \\<And>kv m hma ha hmaa haa.\n       \\<lbrakk>(hm, h) \\<in> br hmr_\\<alpha> hmr_invar; h.heap_invar h;\n        h.valid h 1; heapmap_invar hm; hm_valid hm 1;\n        (kv, m) \\<in> kvi_rel hm 1;\n        (hma, ha) \\<in> br hmr_\\<alpha> hmr_invar;\n        (hmaa, haa) \\<in> br hmr_\\<alpha> hmr_invar;\n        hm_length hm \\<noteq> 1; length h \\<noteq> 1\\<rbrakk>\n       \\<Longrightarrow> (1, 1) \\<in> nat_rel\n 6. \\<And>kv m hma ha hmaa haa hmb hb.\n       \\<lbrakk>(hm, h) \\<in> br hmr_\\<alpha> hmr_invar; h.heap_invar h;\n        h.valid h 1; heapmap_invar hm; hm_valid hm 1;\n        (kv, m) \\<in> kvi_rel hm 1;\n        (hma, ha) \\<in> br hmr_\\<alpha> hmr_invar;\n        (hmaa, haa) \\<in> br hmr_\\<alpha> hmr_invar;\n        hm_length hm \\<noteq> 1; length h \\<noteq> 1;\n        (hmb, hb) \\<in> br hmr_\\<alpha> hmr_invar\\<rbrakk>\n       \\<Longrightarrow> ((kv, hmb), m, hb)\n                         \\<in> kvi_rel hm 1 \\<times>\\<^sub>r\n                               br hmr_\\<alpha> hmr_invar\n 7. \\<And>kv m hma ha hmaa haa.\n       \\<lbrakk>(hm, h) \\<in> br hmr_\\<alpha> hmr_invar; h.heap_invar h;\n        h.valid h 1; heapmap_invar hm; hm_valid hm 1;\n        (kv, m) \\<in> kvi_rel hm 1;\n        (hma, ha) \\<in> br hmr_\\<alpha> hmr_invar;\n        (hmaa, haa) \\<in> br hmr_\\<alpha> hmr_invar;\n        \\<not> hm_length hm \\<noteq> 1; \\<not> length h \\<noteq> 1\\<rbrakk>\n       \\<Longrightarrow> ((kv, hmaa), m, haa)\n                         \\<in> kvi_rel hm 1 \\<times>\\<^sub>r\n                               br hmr_\\<alpha> hmr_invar", "apply (unfold heapmap_invar_def; simp add: in_br_conv)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>(hm, h) \\<in> br hmr_\\<alpha> hmr_invar; h.heap_invar h;\n     h.valid h 1; heapmap_invar hm\\<rbrakk>\n    \\<Longrightarrow> hm_valid hm 1\n 2. \\<And>kv m.\n       \\<lbrakk>(hm, h) \\<in> br hmr_\\<alpha> hmr_invar; h.heap_invar h;\n        h.valid h 1; heapmap_invar hm; hm_valid hm 1;\n        (kv, m) \\<in> kvi_rel hm 1\\<rbrakk>\n       \\<Longrightarrow> (1, 1) \\<in> nat_rel\n 3. \\<And>kv m hma ha hmaa haa.\n       \\<lbrakk>(hm, h) \\<in> br hmr_\\<alpha> hmr_invar; h.heap_invar h;\n        h.valid h 1; heapmap_invar hm; hm_valid hm 1;\n        (kv, m) \\<in> kvi_rel hm 1;\n        (hma, ha) \\<in> br hmr_\\<alpha> hmr_invar;\n        (hmaa, haa) \\<in> br hmr_\\<alpha> hmr_invar\\<rbrakk>\n       \\<Longrightarrow> (hm_length hm \\<noteq> 1) = (length h \\<noteq> 1)\n 4. \\<And>kv m hma ha hmaa haa.\n       \\<lbrakk>(hm, h) \\<in> br hmr_\\<alpha> hmr_invar; h.heap_invar h;\n        h.valid h 1; heapmap_invar hm; hm_valid hm 1;\n        (kv, m) \\<in> kvi_rel hm 1;\n        (hma, ha) \\<in> br hmr_\\<alpha> hmr_invar;\n        (hmaa, haa) \\<in> br hmr_\\<alpha> hmr_invar;\n        hm_length hm \\<noteq> 1; length h \\<noteq> 1\\<rbrakk>\n       \\<Longrightarrow> (1, 1) \\<in> nat_rel\n 5. \\<And>kv m hma ha hmaa haa hmb hb.\n       \\<lbrakk>(hm, h) \\<in> br hmr_\\<alpha> hmr_invar; h.heap_invar h;\n        h.valid h 1; heapmap_invar hm; hm_valid hm 1;\n        (kv, m) \\<in> kvi_rel hm 1;\n        (hma, ha) \\<in> br hmr_\\<alpha> hmr_invar;\n        (hmaa, haa) \\<in> br hmr_\\<alpha> hmr_invar;\n        hm_length hm \\<noteq> 1; length h \\<noteq> 1;\n        (hmb, hb) \\<in> br hmr_\\<alpha> hmr_invar\\<rbrakk>\n       \\<Longrightarrow> ((kv, hmb), m, hb)\n                         \\<in> kvi_rel hm 1 \\<times>\\<^sub>r\n                               br hmr_\\<alpha> hmr_invar\n 6. \\<And>kv m hma ha hmaa haa.\n       \\<lbrakk>(hm, h) \\<in> br hmr_\\<alpha> hmr_invar; h.heap_invar h;\n        h.valid h 1; heapmap_invar hm; hm_valid hm 1;\n        (kv, m) \\<in> kvi_rel hm 1;\n        (hma, ha) \\<in> br hmr_\\<alpha> hmr_invar;\n        (hmaa, haa) \\<in> br hmr_\\<alpha> hmr_invar;\n        \\<not> hm_length hm \\<noteq> 1; \\<not> length h \\<noteq> 1\\<rbrakk>\n       \\<Longrightarrow> ((kv, hmaa), m, haa)\n                         \\<in> kvi_rel hm 1 \\<times>\\<^sub>r\n                               br hmr_\\<alpha> hmr_invar", "apply (simp_all add: in_br_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma heapmap_nres_rel_prodI':\n      assumes \"hmx \\<le> \\<Down>(S \\<times>\\<^sub>r hmr_rel) h'x\"\n      assumes \"h'x \\<le> SPEC \\<Phi>\"\n      assumes \"\\<And>h' r. \\<Phi> (r,h') \\<Longrightarrow> h.heap_invar h'\"\n      assumes \"hmx \\<le>\\<^sub>n SPEC (\\<lambda>(r,hm'). (\\<exists>r'. (r,r')\\<in>S \\<and> \\<Phi> (r',hmr_\\<alpha> hm')) \\<and> hmr_invar hm' \\<longrightarrow> RETURN (r,heapmap_\\<alpha> hm') \\<le> \\<Down>(R\\<times>\\<^sub>rId) hx)\"\n      shows \"hmx \\<le> \\<Down>(R\\<times>\\<^sub>rheapmap_rel) hx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hmx \\<le> \\<Down> (R \\<times>\\<^sub>r heapmap_rel) hx", "using assms"], ["proof (prove)\nusing this:\n  hmx \\<le> \\<Down> (S \\<times>\\<^sub>r hmr_rel) h'x\n  h'x \\<le> SPEC \\<Phi>\n  \\<Phi> (?r34, ?h'34) \\<Longrightarrow> h.heap_invar ?h'34\n  hmx \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>(r, hm').\n       (\\<exists>r'.\n           (r, r') \\<in> S \\<and> \\<Phi> (r', hmr_\\<alpha> hm')) \\<and>\n       hmr_invar hm' \\<longrightarrow>\n       RETURN (r, heapmap_\\<alpha> hm')\n       \\<le> \\<Down> (R \\<times>\\<^sub>r Id) hx)\n\ngoal (1 subgoal):\n 1. hmx \\<le> \\<Down> (R \\<times>\\<^sub>r heapmap_rel) hx", "unfolding heapmap_rel_def hmr_rel_def heapmap_invar_def"], ["proof (prove)\nusing this:\n  hmx \\<le> \\<Down> (S \\<times>\\<^sub>r br hmr_\\<alpha> hmr_invar) h'x\n  h'x \\<le> SPEC \\<Phi>\n  \\<Phi> (?r34, ?h'34) \\<Longrightarrow> h.heap_invar ?h'34\n  hmx \\<le>\\<^sub>n\n  SPEC\n   (\\<lambda>(r, hm').\n       (\\<exists>r'.\n           (r, r') \\<in> S \\<and> \\<Phi> (r', hmr_\\<alpha> hm')) \\<and>\n       hmr_invar hm' \\<longrightarrow>\n       RETURN (r, heapmap_\\<alpha> hm')\n       \\<le> \\<Down> (R \\<times>\\<^sub>r Id) hx)\n\ngoal (1 subgoal):\n 1. hmx\n    \\<le> \\<Down>\n           (R \\<times>\\<^sub>r\n            br heapmap_\\<alpha>\n             (\\<lambda>hm.\n                 hmr_invar hm \\<and> h.heap_invar (hmr_\\<alpha> hm)))\n           hx", "apply (auto \n        simp: pw_le_iff pw_leof_iff refine_pw_simps in_br_conv\n        )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>\\<And>r h'.\n                   \\<Phi> (r, h') \\<Longrightarrow> h.heap_invar h';\n        \\<forall>a aa b.\n           inres hmx (a, aa, b) \\<longrightarrow>\n           (\\<exists>r'.\n               (a, r') \\<in> S \\<and>\n               \\<Phi> (r', hmr_\\<alpha> (aa, b))) \\<and>\n           hmr_invar (aa, b) \\<longrightarrow>\n           (\\<exists>ab.\n               (a, ab) \\<in> R \\<and>\n               inres hx (ab, heapmap_\\<alpha> (aa, b)));\n        nofail hmx;\n        \\<forall>a aa b.\n           inres hmx (a, aa, b) \\<longrightarrow>\n           (\\<exists>ab.\n               (a, ab) \\<in> S \\<and>\n               hmr_invar (aa, b) \\<and>\n               inres h'x (ab, hmr_\\<alpha> (aa, b)));\n        nofail h'x;\n        \\<forall>a b. inres h'x (a, b) \\<longrightarrow> \\<Phi> (a, b);\n        nofail hx; inres hmx (a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ab.\n                            (a, ab) \\<in> R \\<and>\n                            hmr_invar (aa, b) \\<and>\n                            h.heap_invar (hmr_\\<alpha> (aa, b)) \\<and>\n                            inres hx (ab, heapmap_\\<alpha> (aa, b))", "by meson"], ["", "lemma ex_in_kvi_rel_conv:\n      \"(\\<exists>r'. (r,r')\\<in>kvi_rel hm i \\<and> \\<Phi> r') \\<longleftrightarrow> (fst r = hm_key_of hm i \\<and> \\<Phi> (snd r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>r'. (r, r') \\<in> kvi_rel hm i \\<and> \\<Phi> r') =\n    (fst r = hm_key_of hm i \\<and> \\<Phi> (snd r))", "unfolding kvi_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>r'.\n        (r, r') \\<in> {((k, v), v) |k v. hm_key_of hm i = k} \\<and>\n        \\<Phi> r') =\n    (fst r = hm_key_of hm i \\<and> \\<Phi> (snd r))", "apply (cases r)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       r = (a, b) \\<Longrightarrow>\n       (\\<exists>r'.\n           (r, r') \\<in> {((k, v), v) |k v. hm_key_of hm i = k} \\<and>\n           \\<Phi> r') =\n       (fst r = hm_key_of hm i \\<and> \\<Phi> (snd r))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hm_pop_min_aref': \"(hm_pop_min_op', mop_pm_pop_min prio) \\<in> heapmap_rel \\<rightarrow> \\<langle>(Id\\<times>\\<^sub>rId) \\<times>\\<^sub>r heapmap_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hm_pop_min_op', mop_pm_pop_min prio)\n    \\<in> heapmap_rel \\<rightarrow>\n          \\<langle>(Id \\<times>\\<^sub>r Id) \\<times>\\<^sub>r\n                   heapmap_rel\\<rangle>nres_rel", "apply (intro fun_relI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> heapmap_rel \\<Longrightarrow>\n       hm_pop_min_op' a\n       \\<le> \\<Down> ((Id \\<times>\\<^sub>r Id) \\<times>\\<^sub>r heapmap_rel)\n              (mop_pm_pop_min prio a')", "apply (frule heapmap_hmr_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> heapmap_rel;\n        (a, hmr_\\<alpha> a) \\<in> hmr_rel\\<rbrakk>\n       \\<Longrightarrow> hm_pop_min_op' a\n                         \\<le> \\<Down>\n                                ((Id \\<times>\\<^sub>r Id) \\<times>\\<^sub>r\n                                 heapmap_rel)\n                                (mop_pm_pop_min prio a')", "unfolding mop_pm_pop_min_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> heapmap_rel;\n        (a, hmr_\\<alpha> a) \\<in> hmr_rel\\<rbrakk>\n       \\<Longrightarrow> hm_pop_min_op' a\n                         \\<le> \\<Down>\n                                ((Id \\<times>\\<^sub>r Id) \\<times>\\<^sub>r\n                                 heapmap_rel)\n                                (ASSERT (pre_pm_pop_min a') \\<bind>\n                                 (\\<lambda>_.\n                                     PR_CONST (op_pm_pop_min prio) a'))", "apply (intro ASSERT_refine_right)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> heapmap_rel;\n        (a, hmr_\\<alpha> a) \\<in> hmr_rel; pre_pm_pop_min a'\\<rbrakk>\n       \\<Longrightarrow> hm_pop_min_op' a\n                         \\<le> \\<Down>\n                                ((Id \\<times>\\<^sub>r Id) \\<times>\\<^sub>r\n                                 heapmap_rel)\n                                (PR_CONST (op_pm_pop_min prio) a')", "apply (rule heapmap_nres_rel_prodI')"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> heapmap_rel;\n        (a, hmr_\\<alpha> a) \\<in> hmr_rel; pre_pm_pop_min a'\\<rbrakk>\n       \\<Longrightarrow> hm_pop_min_op' a\n                         \\<le> \\<Down> (?S5 a a' \\<times>\\<^sub>r hmr_rel)\n                                (?h'x5 a a')\n 2. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> heapmap_rel;\n        (a, hmr_\\<alpha> a) \\<in> hmr_rel; pre_pm_pop_min a'\\<rbrakk>\n       \\<Longrightarrow> ?h'x5 a a' \\<le> SPEC (?\\<Phi>5 a a')\n 3. \\<And>a a' h' r.\n       \\<lbrakk>(a, a') \\<in> heapmap_rel;\n        (a, hmr_\\<alpha> a) \\<in> hmr_rel; pre_pm_pop_min a';\n        ?\\<Phi>5 a a' (r, h')\\<rbrakk>\n       \\<Longrightarrow> h.heap_invar h'\n 4. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> heapmap_rel;\n        (a, hmr_\\<alpha> a) \\<in> hmr_rel; pre_pm_pop_min a'\\<rbrakk>\n       \\<Longrightarrow> hm_pop_min_op' a \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>(r, hm').\n                              (\\<exists>r'.\n                                  (r, r') \\<in> ?S5 a a' \\<and>\n                                  ?\\<Phi>5 a a'\n                                   (r', hmr_\\<alpha> hm')) \\<and>\n                              hmr_invar hm' \\<longrightarrow>\n                              RETURN (r, heapmap_\\<alpha> hm')\n                              \\<le> \\<Down>\n                                     ((Id \\<times>\\<^sub>r\n Id) \\<times>\\<^sub>r\nId)\n                                     (PR_CONST (op_pm_pop_min prio) a'))", "apply (erule hm_pop_min_op_refine')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> heapmap_rel;\n        (a, hmr_\\<alpha> a) \\<in> hmr_rel; pre_pm_pop_min a'\\<rbrakk>\n       \\<Longrightarrow> h.pop_min_op (hmr_\\<alpha> a)\n                         \\<le> SPEC (?\\<Phi>5 a a')\n 2. \\<And>a a' h' r.\n       \\<lbrakk>(a, a') \\<in> heapmap_rel;\n        (a, hmr_\\<alpha> a) \\<in> hmr_rel; pre_pm_pop_min a';\n        ?\\<Phi>5 a a' (r, h')\\<rbrakk>\n       \\<Longrightarrow> h.heap_invar h'\n 3. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> heapmap_rel;\n        (a, hmr_\\<alpha> a) \\<in> hmr_rel; pre_pm_pop_min a'\\<rbrakk>\n       \\<Longrightarrow> hm_pop_min_op' a \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>(r, hm').\n                              (\\<exists>r'.\n                                  (r, r') \\<in> kvi_rel a 1 \\<and>\n                                  ?\\<Phi>5 a a'\n                                   (r', hmr_\\<alpha> hm')) \\<and>\n                              hmr_invar hm' \\<longrightarrow>\n                              RETURN (r, heapmap_\\<alpha> hm')\n                              \\<le> \\<Down>\n                                     ((Id \\<times>\\<^sub>r\n Id) \\<times>\\<^sub>r\nId)\n                                     (PR_CONST (op_pm_pop_min prio) a'))", "apply (unfold heapmap_rel_def hmr_rel_def in_br_conv) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>a' = heapmap_\\<alpha> a \\<and> heapmap_invar a;\n        hmr_\\<alpha> a = hmr_\\<alpha> a \\<and> hmr_invar a;\n        pre_pm_pop_min a'\\<rbrakk>\n       \\<Longrightarrow> h.pop_min_op (hmr_\\<alpha> a)\n                         \\<le> SPEC (?\\<Phi>5 a a')\n 2. \\<And>a a' h' r.\n       \\<lbrakk>(a, a') \\<in> heapmap_rel;\n        (a, hmr_\\<alpha> a) \\<in> hmr_rel; pre_pm_pop_min a';\n        ?\\<Phi>5 a a' (r, h')\\<rbrakk>\n       \\<Longrightarrow> h.heap_invar h'\n 3. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> heapmap_rel;\n        (a, hmr_\\<alpha> a) \\<in> hmr_rel; pre_pm_pop_min a'\\<rbrakk>\n       \\<Longrightarrow> hm_pop_min_op' a \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>(r, hm').\n                              (\\<exists>r'.\n                                  (r, r') \\<in> kvi_rel a 1 \\<and>\n                                  ?\\<Phi>5 a a'\n                                   (r', hmr_\\<alpha> hm')) \\<and>\n                              hmr_invar hm' \\<longrightarrow>\n                              RETURN (r, heapmap_\\<alpha> hm')\n                              \\<le> \\<Down>\n                                     ((Id \\<times>\\<^sub>r\n Id) \\<times>\\<^sub>r\nId)\n                                     (PR_CONST (op_pm_pop_min prio) a'))", "apply (rule h.pop_min_op_correct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>a' = heapmap_\\<alpha> a \\<and> heapmap_invar a;\n        hmr_\\<alpha> a = hmr_\\<alpha> a \\<and> hmr_invar a;\n        pre_pm_pop_min a'\\<rbrakk>\n       \\<Longrightarrow> h.heap_invar (hmr_\\<alpha> a)\n 2. \\<And>a a'.\n       \\<lbrakk>a' = heapmap_\\<alpha> a \\<and> heapmap_invar a;\n        hmr_\\<alpha> a = hmr_\\<alpha> a \\<and> hmr_invar a;\n        pre_pm_pop_min a'\\<rbrakk>\n       \\<Longrightarrow> h.\\<alpha> (hmr_\\<alpha> a) \\<noteq> {#}\n 3. \\<And>a a' h' r.\n       \\<lbrakk>(a, a') \\<in> heapmap_rel;\n        (a, hmr_\\<alpha> a) \\<in> hmr_rel; pre_pm_pop_min a';\n        case (r, h') of\n        (v, h') \\<Rightarrow>\n          h.heap_invar h' \\<and>\n          v \\<in># h.\\<alpha> (hmr_\\<alpha> a) \\<and>\n          h.\\<alpha> h' = h.\\<alpha> (hmr_\\<alpha> a) - {#v#} \\<and>\n          (\\<forall>v'\\<in>#h.\\<alpha> (hmr_\\<alpha> a).\n              prio v \\<le> prio v')\\<rbrakk>\n       \\<Longrightarrow> h.heap_invar h'\n 4. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> heapmap_rel;\n        (a, hmr_\\<alpha> a) \\<in> hmr_rel; pre_pm_pop_min a'\\<rbrakk>\n       \\<Longrightarrow> hm_pop_min_op' a \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>(r, hm').\n                              (\\<exists>r'.\n                                  (r, r') \\<in> kvi_rel a 1 \\<and>\n                                  (case (r', hmr_\\<alpha> hm') of\n                                   (v, h') \\<Rightarrow>\n                                     h.heap_invar h' \\<and>\n                                     v \\<in># h.\\<alpha>\n         (hmr_\\<alpha> a) \\<and>\n                                     h.\\<alpha> h' =\n                                     h.\\<alpha> (hmr_\\<alpha> a) -\n                                     {#v#} \\<and>\n                                     (\\<forall>v'\\<in>#h.\\<alpha>\n                  (hmr_\\<alpha> a).\n   prio v \\<le> prio v'))) \\<and>\n                              hmr_invar hm' \\<longrightarrow>\n                              RETURN (r, heapmap_\\<alpha> hm')\n                              \\<le> \\<Down>\n                                     ((Id \\<times>\\<^sub>r\n Id) \\<times>\\<^sub>r\nId)\n                                     (PR_CONST (op_pm_pop_min prio) a'))", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>a' = heapmap_\\<alpha> a \\<and> heapmap_invar a;\n        hmr_\\<alpha> a = hmr_\\<alpha> a \\<and> hmr_invar a;\n        pre_pm_pop_min a'\\<rbrakk>\n       \\<Longrightarrow> h.\\<alpha> (hmr_\\<alpha> a) \\<noteq> {#}\n 2. \\<And>a a' h' r.\n       \\<lbrakk>(a, a') \\<in> heapmap_rel;\n        (a, hmr_\\<alpha> a) \\<in> hmr_rel; pre_pm_pop_min a';\n        case (r, h') of\n        (v, h') \\<Rightarrow>\n          h.heap_invar h' \\<and>\n          v \\<in># h.\\<alpha> (hmr_\\<alpha> a) \\<and>\n          h.\\<alpha> h' = h.\\<alpha> (hmr_\\<alpha> a) - {#v#} \\<and>\n          (\\<forall>v'\\<in>#h.\\<alpha> (hmr_\\<alpha> a).\n              prio v \\<le> prio v')\\<rbrakk>\n       \\<Longrightarrow> h.heap_invar h'\n 3. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> heapmap_rel;\n        (a, hmr_\\<alpha> a) \\<in> hmr_rel; pre_pm_pop_min a'\\<rbrakk>\n       \\<Longrightarrow> hm_pop_min_op' a \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>(r, hm').\n                              (\\<exists>r'.\n                                  (r, r') \\<in> kvi_rel a 1 \\<and>\n                                  (case (r', hmr_\\<alpha> hm') of\n                                   (v, h') \\<Rightarrow>\n                                     h.heap_invar h' \\<and>\n                                     v \\<in># h.\\<alpha>\n         (hmr_\\<alpha> a) \\<and>\n                                     h.\\<alpha> h' =\n                                     h.\\<alpha> (hmr_\\<alpha> a) -\n                                     {#v#} \\<and>\n                                     (\\<forall>v'\\<in>#h.\\<alpha>\n                  (hmr_\\<alpha> a).\n   prio v \\<le> prio v'))) \\<and>\n                              hmr_invar hm' \\<longrightarrow>\n                              RETURN (r, heapmap_\\<alpha> hm')\n                              \\<le> \\<Down>\n                                     ((Id \\<times>\\<^sub>r\n Id) \\<times>\\<^sub>r\nId)\n                                     (PR_CONST (op_pm_pop_min prio) a'))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' h' r.\n       \\<lbrakk>(a, a') \\<in> heapmap_rel;\n        (a, hmr_\\<alpha> a) \\<in> hmr_rel; pre_pm_pop_min a';\n        case (r, h') of\n        (v, h') \\<Rightarrow>\n          h.heap_invar h' \\<and>\n          v \\<in># h.\\<alpha> (hmr_\\<alpha> a) \\<and>\n          h.\\<alpha> h' = h.\\<alpha> (hmr_\\<alpha> a) - {#v#} \\<and>\n          (\\<forall>v'\\<in>#h.\\<alpha> (hmr_\\<alpha> a).\n              prio v \\<le> prio v')\\<rbrakk>\n       \\<Longrightarrow> h.heap_invar h'\n 2. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> heapmap_rel;\n        (a, hmr_\\<alpha> a) \\<in> hmr_rel; pre_pm_pop_min a'\\<rbrakk>\n       \\<Longrightarrow> hm_pop_min_op' a \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>(r, hm').\n                              (\\<exists>r'.\n                                  (r, r') \\<in> kvi_rel a 1 \\<and>\n                                  (case (r', hmr_\\<alpha> hm') of\n                                   (v, h') \\<Rightarrow>\n                                     h.heap_invar h' \\<and>\n                                     v \\<in># h.\\<alpha>\n         (hmr_\\<alpha> a) \\<and>\n                                     h.\\<alpha> h' =\n                                     h.\\<alpha> (hmr_\\<alpha> a) -\n                                     {#v#} \\<and>\n                                     (\\<forall>v'\\<in>#h.\\<alpha>\n                  (hmr_\\<alpha> a).\n   prio v \\<le> prio v'))) \\<and>\n                              hmr_invar hm' \\<longrightarrow>\n                              RETURN (r, heapmap_\\<alpha> hm')\n                              \\<le> \\<Down>\n                                     ((Id \\<times>\\<^sub>r\n Id) \\<times>\\<^sub>r\nId)\n                                     (PR_CONST (op_pm_pop_min prio) a'))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> heapmap_rel;\n        (a, hmr_\\<alpha> a) \\<in> hmr_rel; pre_pm_pop_min a'\\<rbrakk>\n       \\<Longrightarrow> hm_pop_min_op' a \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>(r, hm').\n                              (\\<exists>r'.\n                                  (r, r') \\<in> kvi_rel a 1 \\<and>\n                                  (case (r', hmr_\\<alpha> hm') of\n                                   (v, h') \\<Rightarrow>\n                                     h.heap_invar h' \\<and>\n                                     v \\<in># h.\\<alpha>\n         (hmr_\\<alpha> a) \\<and>\n                                     h.\\<alpha> h' =\n                                     h.\\<alpha> (hmr_\\<alpha> a) -\n                                     {#v#} \\<and>\n                                     (\\<forall>v'\\<in>#h.\\<alpha>\n                  (hmr_\\<alpha> a).\n   prio v \\<le> prio v'))) \\<and>\n                              hmr_invar hm' \\<longrightarrow>\n                              RETURN (r, heapmap_\\<alpha> hm')\n                              \\<le> \\<Down>\n                                     ((Id \\<times>\\<^sub>r\n Id) \\<times>\\<^sub>r\nId)\n                                     (PR_CONST (op_pm_pop_min prio) a'))", "apply (clarsimp simp: ex_in_kvi_rel_conv split: prod.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b a'.\n       \\<lbrakk>((a, b), a') \\<in> heapmap_rel;\n        ((a, b), hmr_\\<alpha> (a, b)) \\<in> hmr_rel;\n        Map.empty \\<noteq> a'\\<rbrakk>\n       \\<Longrightarrow> hm_pop_min_op' (a, b) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>(r, hm').\n                              fst r = hm_key_of (a, b) (Suc 0) \\<and>\n                              h.heap_invar (hmr_\\<alpha> hm') \\<and>\n                              snd r \\<in> set (hmr_\\<alpha> (a, b)) \\<and>\n                              h.\\<alpha> (hmr_\\<alpha> hm') =\n                              h.\\<alpha> (hmr_\\<alpha> (a, b)) -\n                              {#snd r#} \\<and>\n                              (\\<forall>v'\\<in>set (hmr_\\<alpha> (a, b)).\n                                  prio (snd r) \\<le> prio v') \\<and>\n                              hmr_invar hm' \\<longrightarrow>\n                              (case r of\n                               (k, v) \\<Rightarrow>\n                                 \\<lambda>m'.\n                                    a' k = Some v \\<and>\n                                    m' = a'(k := None) \\<and>\n                                    (\\<forall>k' v'.\n  a' k' = Some v' \\<longrightarrow> prio v \\<le> prio v'))\n                               (heapmap_\\<alpha> hm'))", "unfolding hm_pop_min_op'_def hm_kv_of_op_def hm_key_of_op_unfold\n          hm_the_lookup_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b a'.\n       \\<lbrakk>((a, b), a') \\<in> heapmap_rel;\n        ((a, b), hmr_\\<alpha> (a, b)) \\<in> hmr_rel;\n        Map.empty \\<noteq> a'\\<rbrakk>\n       \\<Longrightarrow> ASSERT (heapmap_invar (a, b)) \\<bind>\n                         (\\<lambda>_.\n                             ASSERT (hm_valid (a, b) 1) \\<bind>\n                             (\\<lambda>_.\n                                 ASSERT\n                                  (hm_valid (a, b) 1 \\<and>\n                                   hmr_invar (a, b)) \\<bind>\n                                 (\\<lambda>_.\n                                     ASSERT (hm_valid (a, b) 1) \\<bind>\n                                     (\\<lambda>_.\n   RETURN (hm_key_of (a, b) 1)) \\<bind>\n                                     (\\<lambda>k.\n   ASSERT\n    (heapmap_\\<alpha> (a, b) k \\<noteq> None \\<and>\n     hmr_invar (a, b)) \\<bind>\n   (\\<lambda>_. RETURN (the (heapmap_\\<alpha> (a, b) k))) \\<bind>\n   (\\<lambda>v. RETURN (k, v)))) \\<bind>\n                                 (\\<lambda>kv.\n                                     let l = hm_length (a, b)\n                                     in hm_exch_op (a, b) 1 l \\<bind>\n  (\\<lambda>hm.\n      hm_butlast_op hm \\<bind>\n      (\\<lambda>hm.\n          if l \\<noteq> 1\n          then hm_sink_op hm 1 \\<bind> (\\<lambda>hm. RETURN (kv, hm))\n          else RETURN (kv, hm)))))) \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>(r, hm').\n                              fst r = hm_key_of (a, b) (Suc 0) \\<and>\n                              h.heap_invar (hmr_\\<alpha> hm') \\<and>\n                              snd r \\<in> set (hmr_\\<alpha> (a, b)) \\<and>\n                              h.\\<alpha> (hmr_\\<alpha> hm') =\n                              h.\\<alpha> (hmr_\\<alpha> (a, b)) -\n                              {#snd r#} \\<and>\n                              (\\<forall>v'\\<in>set (hmr_\\<alpha> (a, b)).\n                                  prio (snd r) \\<le> prio v') \\<and>\n                              hmr_invar hm' \\<longrightarrow>\n                              (case r of\n                               (k, v) \\<Rightarrow>\n                                 \\<lambda>m'.\n                                    a' k = Some v \\<and>\n                                    m' = a'(k := None) \\<and>\n                                    (\\<forall>k' v'.\n  a' k' = Some v' \\<longrightarrow> prio v \\<le> prio v'))\n                               (heapmap_\\<alpha> hm'))", "apply (refine_vcg \n          hm_exch_op_\\<alpha>_correct[THEN leof_trans]\n          hm_butlast_op_\\<alpha>_correct[THEN leof_trans]\n          hm_sink_op_\\<alpha>_correct[THEN leof_trans]\n          )"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a b a' x xa xb x1 x1a x2 x2a.\n       \\<lbrakk>((a, b), a') \\<in> heapmap_rel;\n        ((a, b), hmr_\\<alpha> (a, b)) \\<in> hmr_rel; Map.empty \\<noteq> a';\n        heapmap_invar (a, b); hm_valid (a, b) 1;\n        hm_valid (a, b) 1 \\<and> hmr_invar (a, b); hm_valid (a, b) 1;\n        heapmap_\\<alpha> (a, b) (hm_key_of (a, b) 1) \\<noteq> None \\<and>\n        hmr_invar (a, b);\n        x \\<in> {hm'.\n                 hm_valid (a, b) 1 \\<and>\n                 hm_valid (a, b) (hm_length (a, b)) \\<and>\n                 hm' = hm_exch (a, b) 1 (hm_length (a, b))};\n        xa \\<in> {hm'.\n                  heapmap_\\<alpha> hm' = (heapmap_\\<alpha> x)\n                  (hm_key_of x (hm_length x) := None)};\n        hm_length (a, b) \\<noteq> 1;\n        xb \\<in> {hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> xa};\n        x1 = (x1a, x2);\n        ((hm_key_of (a, b) 1,\n          the (heapmap_\\<alpha> (a, b) (hm_key_of (a, b) 1))),\n         xb) =\n        (x1, x2a);\n        fst x1 = hm_key_of (a, b) (Suc 0) \\<and>\n        h.heap_invar (hmr_\\<alpha> x2a) \\<and>\n        snd x1 \\<in> set (hmr_\\<alpha> (a, b)) \\<and>\n        h.\\<alpha> (hmr_\\<alpha> x2a) =\n        h.\\<alpha> (hmr_\\<alpha> (a, b)) - {#snd x1#} \\<and>\n        (\\<forall>v'\\<in>set (hmr_\\<alpha> (a, b)).\n            prio (snd x1) \\<le> prio v') \\<and>\n        hmr_invar x2a\\<rbrakk>\n       \\<Longrightarrow> a' x1a = Some x2\n 2. \\<And>a b a' x xa xb x1 x1a x2 x2a.\n       \\<lbrakk>((a, b), a') \\<in> heapmap_rel;\n        ((a, b), hmr_\\<alpha> (a, b)) \\<in> hmr_rel; Map.empty \\<noteq> a';\n        heapmap_invar (a, b); hm_valid (a, b) 1;\n        hm_valid (a, b) 1 \\<and> hmr_invar (a, b); hm_valid (a, b) 1;\n        heapmap_\\<alpha> (a, b) (hm_key_of (a, b) 1) \\<noteq> None \\<and>\n        hmr_invar (a, b);\n        x \\<in> {hm'.\n                 hm_valid (a, b) 1 \\<and>\n                 hm_valid (a, b) (hm_length (a, b)) \\<and>\n                 hm' = hm_exch (a, b) 1 (hm_length (a, b))};\n        xa \\<in> {hm'.\n                  heapmap_\\<alpha> hm' = (heapmap_\\<alpha> x)\n                  (hm_key_of x (hm_length x) := None)};\n        hm_length (a, b) \\<noteq> 1;\n        xb \\<in> {hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> xa};\n        x1 = (x1a, x2);\n        ((hm_key_of (a, b) 1,\n          the (heapmap_\\<alpha> (a, b) (hm_key_of (a, b) 1))),\n         xb) =\n        (x1, x2a);\n        fst x1 = hm_key_of (a, b) (Suc 0) \\<and>\n        h.heap_invar (hmr_\\<alpha> x2a) \\<and>\n        snd x1 \\<in> set (hmr_\\<alpha> (a, b)) \\<and>\n        h.\\<alpha> (hmr_\\<alpha> x2a) =\n        h.\\<alpha> (hmr_\\<alpha> (a, b)) - {#snd x1#} \\<and>\n        (\\<forall>v'\\<in>set (hmr_\\<alpha> (a, b)).\n            prio (snd x1) \\<le> prio v') \\<and>\n        hmr_invar x2a\\<rbrakk>\n       \\<Longrightarrow> heapmap_\\<alpha> x2a = a'(x1a := None)\n 3. \\<And>a b a' x xa xb x1 x1a x2 x2a k' v'.\n       \\<lbrakk>((a, b), a') \\<in> heapmap_rel;\n        ((a, b), hmr_\\<alpha> (a, b)) \\<in> hmr_rel; Map.empty \\<noteq> a';\n        heapmap_invar (a, b); hm_valid (a, b) 1;\n        hm_valid (a, b) 1 \\<and> hmr_invar (a, b); hm_valid (a, b) 1;\n        heapmap_\\<alpha> (a, b) (hm_key_of (a, b) 1) \\<noteq> None \\<and>\n        hmr_invar (a, b);\n        x \\<in> {hm'.\n                 hm_valid (a, b) 1 \\<and>\n                 hm_valid (a, b) (hm_length (a, b)) \\<and>\n                 hm' = hm_exch (a, b) 1 (hm_length (a, b))};\n        xa \\<in> {hm'.\n                  heapmap_\\<alpha> hm' = (heapmap_\\<alpha> x)\n                  (hm_key_of x (hm_length x) := None)};\n        hm_length (a, b) \\<noteq> 1;\n        xb \\<in> {hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> xa};\n        x1 = (x1a, x2);\n        ((hm_key_of (a, b) 1,\n          the (heapmap_\\<alpha> (a, b) (hm_key_of (a, b) 1))),\n         xb) =\n        (x1, x2a);\n        fst x1 = hm_key_of (a, b) (Suc 0) \\<and>\n        h.heap_invar (hmr_\\<alpha> x2a) \\<and>\n        snd x1 \\<in> set (hmr_\\<alpha> (a, b)) \\<and>\n        h.\\<alpha> (hmr_\\<alpha> x2a) =\n        h.\\<alpha> (hmr_\\<alpha> (a, b)) - {#snd x1#} \\<and>\n        (\\<forall>v'\\<in>set (hmr_\\<alpha> (a, b)).\n            prio (snd x1) \\<le> prio v') \\<and>\n        hmr_invar x2a;\n        a' k' = Some v'\\<rbrakk>\n       \\<Longrightarrow> prio x2 \\<le> prio v'\n 4. \\<And>a b a' x xa x1 x1a x2 x2a.\n       \\<lbrakk>((a, b), a') \\<in> heapmap_rel;\n        ((a, b), hmr_\\<alpha> (a, b)) \\<in> hmr_rel; Map.empty \\<noteq> a';\n        heapmap_invar (a, b); hm_valid (a, b) 1;\n        hm_valid (a, b) 1 \\<and> hmr_invar (a, b); hm_valid (a, b) 1;\n        heapmap_\\<alpha> (a, b) (hm_key_of (a, b) 1) \\<noteq> None \\<and>\n        hmr_invar (a, b);\n        x \\<in> {hm'.\n                 hm_valid (a, b) 1 \\<and>\n                 hm_valid (a, b) (hm_length (a, b)) \\<and>\n                 hm' = hm_exch (a, b) 1 (hm_length (a, b))};\n        xa \\<in> {hm'.\n                  heapmap_\\<alpha> hm' = (heapmap_\\<alpha> x)\n                  (hm_key_of x (hm_length x) := None)};\n        \\<not> hm_length (a, b) \\<noteq> 1; x1 = (x1a, x2);\n        ((hm_key_of (a, b) 1,\n          the (heapmap_\\<alpha> (a, b) (hm_key_of (a, b) 1))),\n         xa) =\n        (x1, x2a);\n        fst x1 = hm_key_of (a, b) (Suc 0) \\<and>\n        h.heap_invar (hmr_\\<alpha> x2a) \\<and>\n        snd x1 \\<in> set (hmr_\\<alpha> (a, b)) \\<and>\n        h.\\<alpha> (hmr_\\<alpha> x2a) =\n        h.\\<alpha> (hmr_\\<alpha> (a, b)) - {#snd x1#} \\<and>\n        (\\<forall>v'\\<in>set (hmr_\\<alpha> (a, b)).\n            prio (snd x1) \\<le> prio v') \\<and>\n        hmr_invar x2a\\<rbrakk>\n       \\<Longrightarrow> a' x1a = Some x2\n 5. \\<And>a b a' x xa x1 x1a x2 x2a.\n       \\<lbrakk>((a, b), a') \\<in> heapmap_rel;\n        ((a, b), hmr_\\<alpha> (a, b)) \\<in> hmr_rel; Map.empty \\<noteq> a';\n        heapmap_invar (a, b); hm_valid (a, b) 1;\n        hm_valid (a, b) 1 \\<and> hmr_invar (a, b); hm_valid (a, b) 1;\n        heapmap_\\<alpha> (a, b) (hm_key_of (a, b) 1) \\<noteq> None \\<and>\n        hmr_invar (a, b);\n        x \\<in> {hm'.\n                 hm_valid (a, b) 1 \\<and>\n                 hm_valid (a, b) (hm_length (a, b)) \\<and>\n                 hm' = hm_exch (a, b) 1 (hm_length (a, b))};\n        xa \\<in> {hm'.\n                  heapmap_\\<alpha> hm' = (heapmap_\\<alpha> x)\n                  (hm_key_of x (hm_length x) := None)};\n        \\<not> hm_length (a, b) \\<noteq> 1; x1 = (x1a, x2);\n        ((hm_key_of (a, b) 1,\n          the (heapmap_\\<alpha> (a, b) (hm_key_of (a, b) 1))),\n         xa) =\n        (x1, x2a);\n        fst x1 = hm_key_of (a, b) (Suc 0) \\<and>\n        h.heap_invar (hmr_\\<alpha> x2a) \\<and>\n        snd x1 \\<in> set (hmr_\\<alpha> (a, b)) \\<and>\n        h.\\<alpha> (hmr_\\<alpha> x2a) =\n        h.\\<alpha> (hmr_\\<alpha> (a, b)) - {#snd x1#} \\<and>\n        (\\<forall>v'\\<in>set (hmr_\\<alpha> (a, b)).\n            prio (snd x1) \\<le> prio v') \\<and>\n        hmr_invar x2a\\<rbrakk>\n       \\<Longrightarrow> heapmap_\\<alpha> x2a = a'(x1a := None)\n 6. \\<And>a b a' x xa x1 x1a x2 x2a k' v'.\n       \\<lbrakk>((a, b), a') \\<in> heapmap_rel;\n        ((a, b), hmr_\\<alpha> (a, b)) \\<in> hmr_rel; Map.empty \\<noteq> a';\n        heapmap_invar (a, b); hm_valid (a, b) 1;\n        hm_valid (a, b) 1 \\<and> hmr_invar (a, b); hm_valid (a, b) 1;\n        heapmap_\\<alpha> (a, b) (hm_key_of (a, b) 1) \\<noteq> None \\<and>\n        hmr_invar (a, b);\n        x \\<in> {hm'.\n                 hm_valid (a, b) 1 \\<and>\n                 hm_valid (a, b) (hm_length (a, b)) \\<and>\n                 hm' = hm_exch (a, b) 1 (hm_length (a, b))};\n        xa \\<in> {hm'.\n                  heapmap_\\<alpha> hm' = (heapmap_\\<alpha> x)\n                  (hm_key_of x (hm_length x) := None)};\n        \\<not> hm_length (a, b) \\<noteq> 1; x1 = (x1a, x2);\n        ((hm_key_of (a, b) 1,\n          the (heapmap_\\<alpha> (a, b) (hm_key_of (a, b) 1))),\n         xa) =\n        (x1, x2a);\n        fst x1 = hm_key_of (a, b) (Suc 0) \\<and>\n        h.heap_invar (hmr_\\<alpha> x2a) \\<and>\n        snd x1 \\<in> set (hmr_\\<alpha> (a, b)) \\<and>\n        h.\\<alpha> (hmr_\\<alpha> x2a) =\n        h.\\<alpha> (hmr_\\<alpha> (a, b)) - {#snd x1#} \\<and>\n        (\\<forall>v'\\<in>set (hmr_\\<alpha> (a, b)).\n            prio (snd x1) \\<le> prio v') \\<and>\n        hmr_invar x2a;\n        a' k' = Some v'\\<rbrakk>\n       \\<Longrightarrow> prio x2 \\<le> prio v'", "unfolding heapmap_rel_def hmr_rel_def in_br_conv"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a b a' x xa xb x1 x1a x2 x2a.\n       \\<lbrakk>a' = heapmap_\\<alpha> (a, b) \\<and> heapmap_invar (a, b);\n        hmr_\\<alpha> (a, b) = hmr_\\<alpha> (a, b) \\<and> hmr_invar (a, b);\n        Map.empty \\<noteq> a'; heapmap_invar (a, b); hm_valid (a, b) 1;\n        hm_valid (a, b) 1 \\<and> hmr_invar (a, b); hm_valid (a, b) 1;\n        heapmap_\\<alpha> (a, b) (hm_key_of (a, b) 1) \\<noteq> None \\<and>\n        hmr_invar (a, b);\n        x \\<in> {hm'.\n                 hm_valid (a, b) 1 \\<and>\n                 hm_valid (a, b) (hm_length (a, b)) \\<and>\n                 hm' = hm_exch (a, b) 1 (hm_length (a, b))};\n        xa \\<in> {hm'.\n                  heapmap_\\<alpha> hm' = (heapmap_\\<alpha> x)\n                  (hm_key_of x (hm_length x) := None)};\n        hm_length (a, b) \\<noteq> 1;\n        xb \\<in> {hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> xa};\n        x1 = (x1a, x2);\n        ((hm_key_of (a, b) 1,\n          the (heapmap_\\<alpha> (a, b) (hm_key_of (a, b) 1))),\n         xb) =\n        (x1, x2a);\n        fst x1 = hm_key_of (a, b) (Suc 0) \\<and>\n        h.heap_invar (hmr_\\<alpha> x2a) \\<and>\n        snd x1 \\<in> set (hmr_\\<alpha> (a, b)) \\<and>\n        h.\\<alpha> (hmr_\\<alpha> x2a) =\n        h.\\<alpha> (hmr_\\<alpha> (a, b)) - {#snd x1#} \\<and>\n        (\\<forall>v'\\<in>set (hmr_\\<alpha> (a, b)).\n            prio (snd x1) \\<le> prio v') \\<and>\n        hmr_invar x2a\\<rbrakk>\n       \\<Longrightarrow> a' x1a = Some x2\n 2. \\<And>a b a' x xa xb x1 x1a x2 x2a.\n       \\<lbrakk>a' = heapmap_\\<alpha> (a, b) \\<and> heapmap_invar (a, b);\n        hmr_\\<alpha> (a, b) = hmr_\\<alpha> (a, b) \\<and> hmr_invar (a, b);\n        Map.empty \\<noteq> a'; heapmap_invar (a, b); hm_valid (a, b) 1;\n        hm_valid (a, b) 1 \\<and> hmr_invar (a, b); hm_valid (a, b) 1;\n        heapmap_\\<alpha> (a, b) (hm_key_of (a, b) 1) \\<noteq> None \\<and>\n        hmr_invar (a, b);\n        x \\<in> {hm'.\n                 hm_valid (a, b) 1 \\<and>\n                 hm_valid (a, b) (hm_length (a, b)) \\<and>\n                 hm' = hm_exch (a, b) 1 (hm_length (a, b))};\n        xa \\<in> {hm'.\n                  heapmap_\\<alpha> hm' = (heapmap_\\<alpha> x)\n                  (hm_key_of x (hm_length x) := None)};\n        hm_length (a, b) \\<noteq> 1;\n        xb \\<in> {hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> xa};\n        x1 = (x1a, x2);\n        ((hm_key_of (a, b) 1,\n          the (heapmap_\\<alpha> (a, b) (hm_key_of (a, b) 1))),\n         xb) =\n        (x1, x2a);\n        fst x1 = hm_key_of (a, b) (Suc 0) \\<and>\n        h.heap_invar (hmr_\\<alpha> x2a) \\<and>\n        snd x1 \\<in> set (hmr_\\<alpha> (a, b)) \\<and>\n        h.\\<alpha> (hmr_\\<alpha> x2a) =\n        h.\\<alpha> (hmr_\\<alpha> (a, b)) - {#snd x1#} \\<and>\n        (\\<forall>v'\\<in>set (hmr_\\<alpha> (a, b)).\n            prio (snd x1) \\<le> prio v') \\<and>\n        hmr_invar x2a\\<rbrakk>\n       \\<Longrightarrow> heapmap_\\<alpha> x2a = a'(x1a := None)\n 3. \\<And>a b a' x xa xb x1 x1a x2 x2a k' v'.\n       \\<lbrakk>a' = heapmap_\\<alpha> (a, b) \\<and> heapmap_invar (a, b);\n        hmr_\\<alpha> (a, b) = hmr_\\<alpha> (a, b) \\<and> hmr_invar (a, b);\n        Map.empty \\<noteq> a'; heapmap_invar (a, b); hm_valid (a, b) 1;\n        hm_valid (a, b) 1 \\<and> hmr_invar (a, b); hm_valid (a, b) 1;\n        heapmap_\\<alpha> (a, b) (hm_key_of (a, b) 1) \\<noteq> None \\<and>\n        hmr_invar (a, b);\n        x \\<in> {hm'.\n                 hm_valid (a, b) 1 \\<and>\n                 hm_valid (a, b) (hm_length (a, b)) \\<and>\n                 hm' = hm_exch (a, b) 1 (hm_length (a, b))};\n        xa \\<in> {hm'.\n                  heapmap_\\<alpha> hm' = (heapmap_\\<alpha> x)\n                  (hm_key_of x (hm_length x) := None)};\n        hm_length (a, b) \\<noteq> 1;\n        xb \\<in> {hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> xa};\n        x1 = (x1a, x2);\n        ((hm_key_of (a, b) 1,\n          the (heapmap_\\<alpha> (a, b) (hm_key_of (a, b) 1))),\n         xb) =\n        (x1, x2a);\n        fst x1 = hm_key_of (a, b) (Suc 0) \\<and>\n        h.heap_invar (hmr_\\<alpha> x2a) \\<and>\n        snd x1 \\<in> set (hmr_\\<alpha> (a, b)) \\<and>\n        h.\\<alpha> (hmr_\\<alpha> x2a) =\n        h.\\<alpha> (hmr_\\<alpha> (a, b)) - {#snd x1#} \\<and>\n        (\\<forall>v'\\<in>set (hmr_\\<alpha> (a, b)).\n            prio (snd x1) \\<le> prio v') \\<and>\n        hmr_invar x2a;\n        a' k' = Some v'\\<rbrakk>\n       \\<Longrightarrow> prio x2 \\<le> prio v'\n 4. \\<And>a b a' x xa x1 x1a x2 x2a.\n       \\<lbrakk>a' = heapmap_\\<alpha> (a, b) \\<and> heapmap_invar (a, b);\n        hmr_\\<alpha> (a, b) = hmr_\\<alpha> (a, b) \\<and> hmr_invar (a, b);\n        Map.empty \\<noteq> a'; heapmap_invar (a, b); hm_valid (a, b) 1;\n        hm_valid (a, b) 1 \\<and> hmr_invar (a, b); hm_valid (a, b) 1;\n        heapmap_\\<alpha> (a, b) (hm_key_of (a, b) 1) \\<noteq> None \\<and>\n        hmr_invar (a, b);\n        x \\<in> {hm'.\n                 hm_valid (a, b) 1 \\<and>\n                 hm_valid (a, b) (hm_length (a, b)) \\<and>\n                 hm' = hm_exch (a, b) 1 (hm_length (a, b))};\n        xa \\<in> {hm'.\n                  heapmap_\\<alpha> hm' = (heapmap_\\<alpha> x)\n                  (hm_key_of x (hm_length x) := None)};\n        \\<not> hm_length (a, b) \\<noteq> 1; x1 = (x1a, x2);\n        ((hm_key_of (a, b) 1,\n          the (heapmap_\\<alpha> (a, b) (hm_key_of (a, b) 1))),\n         xa) =\n        (x1, x2a);\n        fst x1 = hm_key_of (a, b) (Suc 0) \\<and>\n        h.heap_invar (hmr_\\<alpha> x2a) \\<and>\n        snd x1 \\<in> set (hmr_\\<alpha> (a, b)) \\<and>\n        h.\\<alpha> (hmr_\\<alpha> x2a) =\n        h.\\<alpha> (hmr_\\<alpha> (a, b)) - {#snd x1#} \\<and>\n        (\\<forall>v'\\<in>set (hmr_\\<alpha> (a, b)).\n            prio (snd x1) \\<le> prio v') \\<and>\n        hmr_invar x2a\\<rbrakk>\n       \\<Longrightarrow> a' x1a = Some x2\n 5. \\<And>a b a' x xa x1 x1a x2 x2a.\n       \\<lbrakk>a' = heapmap_\\<alpha> (a, b) \\<and> heapmap_invar (a, b);\n        hmr_\\<alpha> (a, b) = hmr_\\<alpha> (a, b) \\<and> hmr_invar (a, b);\n        Map.empty \\<noteq> a'; heapmap_invar (a, b); hm_valid (a, b) 1;\n        hm_valid (a, b) 1 \\<and> hmr_invar (a, b); hm_valid (a, b) 1;\n        heapmap_\\<alpha> (a, b) (hm_key_of (a, b) 1) \\<noteq> None \\<and>\n        hmr_invar (a, b);\n        x \\<in> {hm'.\n                 hm_valid (a, b) 1 \\<and>\n                 hm_valid (a, b) (hm_length (a, b)) \\<and>\n                 hm' = hm_exch (a, b) 1 (hm_length (a, b))};\n        xa \\<in> {hm'.\n                  heapmap_\\<alpha> hm' = (heapmap_\\<alpha> x)\n                  (hm_key_of x (hm_length x) := None)};\n        \\<not> hm_length (a, b) \\<noteq> 1; x1 = (x1a, x2);\n        ((hm_key_of (a, b) 1,\n          the (heapmap_\\<alpha> (a, b) (hm_key_of (a, b) 1))),\n         xa) =\n        (x1, x2a);\n        fst x1 = hm_key_of (a, b) (Suc 0) \\<and>\n        h.heap_invar (hmr_\\<alpha> x2a) \\<and>\n        snd x1 \\<in> set (hmr_\\<alpha> (a, b)) \\<and>\n        h.\\<alpha> (hmr_\\<alpha> x2a) =\n        h.\\<alpha> (hmr_\\<alpha> (a, b)) - {#snd x1#} \\<and>\n        (\\<forall>v'\\<in>set (hmr_\\<alpha> (a, b)).\n            prio (snd x1) \\<le> prio v') \\<and>\n        hmr_invar x2a\\<rbrakk>\n       \\<Longrightarrow> heapmap_\\<alpha> x2a = a'(x1a := None)\n 6. \\<And>a b a' x xa x1 x1a x2 x2a k' v'.\n       \\<lbrakk>a' = heapmap_\\<alpha> (a, b) \\<and> heapmap_invar (a, b);\n        hmr_\\<alpha> (a, b) = hmr_\\<alpha> (a, b) \\<and> hmr_invar (a, b);\n        Map.empty \\<noteq> a'; heapmap_invar (a, b); hm_valid (a, b) 1;\n        hm_valid (a, b) 1 \\<and> hmr_invar (a, b); hm_valid (a, b) 1;\n        heapmap_\\<alpha> (a, b) (hm_key_of (a, b) 1) \\<noteq> None \\<and>\n        hmr_invar (a, b);\n        x \\<in> {hm'.\n                 hm_valid (a, b) 1 \\<and>\n                 hm_valid (a, b) (hm_length (a, b)) \\<and>\n                 hm' = hm_exch (a, b) 1 (hm_length (a, b))};\n        xa \\<in> {hm'.\n                  heapmap_\\<alpha> hm' = (heapmap_\\<alpha> x)\n                  (hm_key_of x (hm_length x) := None)};\n        \\<not> hm_length (a, b) \\<noteq> 1; x1 = (x1a, x2);\n        ((hm_key_of (a, b) 1,\n          the (heapmap_\\<alpha> (a, b) (hm_key_of (a, b) 1))),\n         xa) =\n        (x1, x2a);\n        fst x1 = hm_key_of (a, b) (Suc 0) \\<and>\n        h.heap_invar (hmr_\\<alpha> x2a) \\<and>\n        snd x1 \\<in> set (hmr_\\<alpha> (a, b)) \\<and>\n        h.\\<alpha> (hmr_\\<alpha> x2a) =\n        h.\\<alpha> (hmr_\\<alpha> (a, b)) - {#snd x1#} \\<and>\n        (\\<forall>v'\\<in>set (hmr_\\<alpha> (a, b)).\n            prio (snd x1) \\<le> prio v') \\<and>\n        hmr_invar x2a;\n        a' k' = Some v'\\<rbrakk>\n       \\<Longrightarrow> prio x2 \\<le> prio v'", "apply (auto intro: ranI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Remove\\<close>"], ["", "definition \"hm_remove_op k hm \\<equiv> do {\n      ASSERT (heapmap_invar hm);\n      ASSERT (k \\<in> dom (heapmap_\\<alpha> hm));\n      i \\<leftarrow> hm_index_op hm k;\n      let l = hm_length hm;\n      hm \\<leftarrow> hm_exch_op hm i l;\n      hm \\<leftarrow> hm_butlast_op hm;\n      if i \\<noteq> l then\n        hm_repair_op hm i\n      else  \n        RETURN hm\n    }\""], ["", "definition (in heapstruct) \"remove_op i h \\<equiv> do {\n      ASSERT (heap_invar h);\n      ASSERT (valid h i);\n      let l = length h;\n      h \\<leftarrow> exch_op h i l;\n      h \\<leftarrow> butlast_op h;\n      if i \\<noteq> l then\n        repair_op h i\n      else  \n        RETURN h\n    }\""], ["", "lemma (in -) swap_empty_iff[iff]: \"swap l i j = [] \\<longleftrightarrow> l=[]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (swap l i j = []) = (l = [])", "by (auto simp: swap_def)"], ["", "lemma (in heapstruct) \n      butlast_exch_last: \"butlast (exch h i (length h)) = update (butlast h) i (last h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. butlast (exch h i (length h)) = update (butlast h) i (last h)", "unfolding exch_def update_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. butlast (swap h (i - 1) (length h - 1)) = (butlast h)[i - 1 := last h]", "apply (cases h rule: rev_cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. h = [] \\<Longrightarrow>\n    butlast (swap h (i - 1) (length h - 1)) = (butlast h)[i - 1 := last h]\n 2. \\<And>ys y.\n       h = ys @ [y] \\<Longrightarrow>\n       butlast (swap h (i - 1) (length h - 1)) = (butlast h)\n       [i - 1 := last h]", "apply (auto simp: swap_def butlast_list_update)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in heapstruct) remove_op_invar: \n      \"\\<lbrakk> heap_invar h; valid h i \\<rbrakk> \\<Longrightarrow> remove_op i h \\<le> SPEC heap_invar\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heap_invar h; valid h i\\<rbrakk>\n    \\<Longrightarrow> remove_op i h \\<le> SPEC heap_invar", "unfolding remove_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heap_invar h; valid h i\\<rbrakk>\n    \\<Longrightarrow> ASSERT (heap_invar h) \\<bind>\n                      (\\<lambda>_.\n                          ASSERT (valid h i) \\<bind>\n                          (\\<lambda>_.\n                              let l = length h\n                              in exch_op h i l \\<bind>\n                                 (\\<lambda>h.\n                                     butlast_op h \\<bind>\n                                     (\\<lambda>h.\n   if i \\<noteq> l then repair_op h i else RETURN h))))\n                      \\<le> SPEC heap_invar", "apply refine_vcg"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>heap_invar h; valid h i; heap_invar h; valid h i\\<rbrakk>\n    \\<Longrightarrow> valid h (length h)\n 2. \\<And>x.\n       \\<lbrakk>heap_invar h; valid h i; heap_invar h; valid h i;\n        x = exch h i (length h)\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> []\n 3. \\<And>x xa.\n       \\<lbrakk>heap_invar h; valid h i; heap_invar h; valid h i;\n        x = exch h i (length h); xa = butlast x;\n        i \\<noteq> length h\\<rbrakk>\n       \\<Longrightarrow> repair_op xa i \\<le> SPEC heap_invar\n 4. \\<And>x xa.\n       \\<lbrakk>heap_invar h; valid h i; heap_invar h; valid h i;\n        x = exch h i (length h); xa = butlast x;\n        \\<not> i \\<noteq> length h\\<rbrakk>\n       \\<Longrightarrow> heap_invar xa", "apply (auto simp: valid_def) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>heap_invar h; valid h i; heap_invar h; valid h i;\n        x = exch h i (length h)\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> []\n 2. \\<And>x xa.\n       \\<lbrakk>heap_invar h; valid h i; heap_invar h; valid h i;\n        x = exch h i (length h); xa = butlast x;\n        i \\<noteq> length h\\<rbrakk>\n       \\<Longrightarrow> repair_op xa i \\<le> SPEC heap_invar\n 3. \\<And>x xa.\n       \\<lbrakk>heap_invar h; valid h i; heap_invar h; valid h i;\n        x = exch h i (length h); xa = butlast x;\n        \\<not> i \\<noteq> length h\\<rbrakk>\n       \\<Longrightarrow> heap_invar xa", "apply (auto simp: valid_def exch_def) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>heap_invar h; valid h i; heap_invar h; valid h i;\n        x = exch h i (length h); xa = butlast x;\n        i \\<noteq> length h\\<rbrakk>\n       \\<Longrightarrow> repair_op xa i \\<le> SPEC heap_invar\n 2. \\<And>x xa.\n       \\<lbrakk>heap_invar h; valid h i; heap_invar h; valid h i;\n        x = exch h i (length h); xa = butlast x;\n        \\<not> i \\<noteq> length h\\<rbrakk>\n       \\<Longrightarrow> heap_invar xa", "apply (simp add: butlast_exch_last)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>heap_invar h; valid h i; x = exch h i (length h);\n        xa = update (butlast h) i (last h); i \\<noteq> length h\\<rbrakk>\n       \\<Longrightarrow> repair_op (update (butlast h) i (last h)) i\n                         \\<le> SPEC heap_invar\n 2. \\<And>x xa.\n       \\<lbrakk>heap_invar h; valid h i; heap_invar h; valid h i;\n        x = exch h i (length h); xa = butlast x;\n        \\<not> i \\<noteq> length h\\<rbrakk>\n       \\<Longrightarrow> heap_invar xa", "apply refine_vcg"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>heap_invar h; valid h i; x = exch h i (length h);\n        xa = update (butlast h) i (last h); i \\<noteq> length h\\<rbrakk>\n       \\<Longrightarrow> heap_invar (butlast h)\n 2. \\<And>x xa.\n       \\<lbrakk>heap_invar h; valid h i; x = exch h i (length h);\n        xa = update (butlast h) i (last h); i \\<noteq> length h\\<rbrakk>\n       \\<Longrightarrow> valid (butlast h) i\n 3. \\<And>x xa xb.\n       \\<lbrakk>heap_invar h; valid h i; x = exch h i (length h);\n        xa = update (butlast h) i (last h); i \\<noteq> length h;\n        heap_invar xb \\<and>\n        \\<alpha> xb = \\<alpha> (update (butlast h) i (last h)) \\<and>\n        length xb = length (butlast h)\\<rbrakk>\n       \\<Longrightarrow> heap_invar xb\n 4. \\<And>x xa.\n       \\<lbrakk>heap_invar h; valid h i; heap_invar h; valid h i;\n        x = exch h i (length h); xa = butlast x;\n        \\<not> i \\<noteq> length h\\<rbrakk>\n       \\<Longrightarrow> heap_invar xa", "apply auto []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>heap_invar h; valid h i; x = exch h i (length h);\n        xa = update (butlast h) i (last h); i \\<noteq> length h\\<rbrakk>\n       \\<Longrightarrow> valid (butlast h) i\n 2. \\<And>x xa xb.\n       \\<lbrakk>heap_invar h; valid h i; x = exch h i (length h);\n        xa = update (butlast h) i (last h); i \\<noteq> length h;\n        heap_invar xb \\<and>\n        \\<alpha> xb = \\<alpha> (update (butlast h) i (last h)) \\<and>\n        length xb = length (butlast h)\\<rbrakk>\n       \\<Longrightarrow> heap_invar xb\n 3. \\<And>x xa.\n       \\<lbrakk>heap_invar h; valid h i; heap_invar h; valid h i;\n        x = exch h i (length h); xa = butlast x;\n        \\<not> i \\<noteq> length h\\<rbrakk>\n       \\<Longrightarrow> heap_invar xa", "apply auto []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>heap_invar h; valid h i; i \\<noteq> length h\\<rbrakk>\n    \\<Longrightarrow> i < length h\n 2. \\<And>x xa xb.\n       \\<lbrakk>heap_invar h; valid h i; x = exch h i (length h);\n        xa = update (butlast h) i (last h); i \\<noteq> length h;\n        heap_invar xb \\<and>\n        \\<alpha> xb = \\<alpha> (update (butlast h) i (last h)) \\<and>\n        length xb = length (butlast h)\\<rbrakk>\n       \\<Longrightarrow> heap_invar xb\n 3. \\<And>x xa.\n       \\<lbrakk>heap_invar h; valid h i; heap_invar h; valid h i;\n        x = exch h i (length h); xa = butlast x;\n        \\<not> i \\<noteq> length h\\<rbrakk>\n       \\<Longrightarrow> heap_invar xa", "apply (auto simp: valid_def) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       \\<lbrakk>heap_invar h; valid h i; x = exch h i (length h);\n        xa = update (butlast h) i (last h); i \\<noteq> length h;\n        heap_invar xb \\<and>\n        \\<alpha> xb = \\<alpha> (update (butlast h) i (last h)) \\<and>\n        length xb = length (butlast h)\\<rbrakk>\n       \\<Longrightarrow> heap_invar xb\n 2. \\<And>x xa.\n       \\<lbrakk>heap_invar h; valid h i; heap_invar h; valid h i;\n        x = exch h i (length h); xa = butlast x;\n        \\<not> i \\<noteq> length h\\<rbrakk>\n       \\<Longrightarrow> heap_invar xa", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>heap_invar h; valid h i; heap_invar h; valid h i;\n        x = exch h i (length h); xa = butlast x;\n        \\<not> i \\<noteq> length h\\<rbrakk>\n       \\<Longrightarrow> heap_invar xa", "apply auto []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hm_remove_op_refine[refine]: \n      \"\\<lbrakk> (hm,m)\\<in>heapmap_rel; (hm,h)\\<in>hmr_rel; heapmap_\\<alpha> hm k \\<noteq> None\\<rbrakk> \\<Longrightarrow> \n        hm_remove_op k hm \\<le> \\<Down>hmr_rel (h.remove_op (hm_index hm k) h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(hm, m) \\<in> heapmap_rel; (hm, h) \\<in> hmr_rel;\n     heapmap_\\<alpha> hm k \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> hm_remove_op k hm\n                      \\<le> \\<Down> hmr_rel (h.remove_op (hm_index hm k) h)", "unfolding hm_remove_op_def h.remove_op_def heapmap_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(hm, m) \\<in> br heapmap_\\<alpha> heapmap_invar;\n     (hm, h) \\<in> hmr_rel; heapmap_\\<alpha> hm k \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> ASSERT (heapmap_invar hm) \\<bind>\n                      (\\<lambda>_.\n                          ASSERT (k \\<in> dom (heapmap_\\<alpha> hm)) \\<bind>\n                          (\\<lambda>_.\n                              hm_index_op hm k \\<bind>\n                              (\\<lambda>i.\n                                  let l = hm_length hm\n                                  in hm_exch_op hm i l \\<bind>\n                                     (\\<lambda>hm.\n   hm_butlast_op hm \\<bind>\n   (\\<lambda>hm. if i \\<noteq> l then hm_repair_op hm i else RETURN hm)))))\n                      \\<le> \\<Down> hmr_rel\n                             (ASSERT (h.heap_invar h) \\<bind>\n                              (\\<lambda>_.\n                                  ASSERT (h.valid h (hm_index hm k)) \\<bind>\n                                  (\\<lambda>_.\nlet l = length h\nin h.exch_op h (hm_index hm k) l \\<bind>\n   (\\<lambda>h.\n       h.butlast_op h \\<bind>\n       (\\<lambda>h.\n           if hm_index hm k \\<noteq> l then h.repair_op h (hm_index hm k)\n           else RETURN h)))))", "(*apply (rewrite at \"Let (hm_index hm k) _\" Let_def)*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(hm, m) \\<in> br heapmap_\\<alpha> heapmap_invar;\n     (hm, h) \\<in> hmr_rel; heapmap_\\<alpha> hm k \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> ASSERT (heapmap_invar hm) \\<bind>\n                      (\\<lambda>_.\n                          ASSERT (k \\<in> dom (heapmap_\\<alpha> hm)) \\<bind>\n                          (\\<lambda>_.\n                              hm_index_op hm k \\<bind>\n                              (\\<lambda>i.\n                                  let l = hm_length hm\n                                  in hm_exch_op hm i l \\<bind>\n                                     (\\<lambda>hm.\n   hm_butlast_op hm \\<bind>\n   (\\<lambda>hm. if i \\<noteq> l then hm_repair_op hm i else RETURN hm)))))\n                      \\<le> \\<Down> hmr_rel\n                             (ASSERT (h.heap_invar h) \\<bind>\n                              (\\<lambda>_.\n                                  ASSERT (h.valid h (hm_index hm k)) \\<bind>\n                                  (\\<lambda>_.\nlet l = length h\nin h.exch_op h (hm_index hm k) l \\<bind>\n   (\\<lambda>h.\n       h.butlast_op h \\<bind>\n       (\\<lambda>h.\n           if hm_index hm k \\<noteq> l then h.repair_op h (hm_index hm k)\n           else RETURN h)))))", "apply (refine_rcg index_op_inline_refine)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>(hm, m) \\<in> br heapmap_\\<alpha> heapmap_invar;\n     (hm, h) \\<in> hmr_rel; heapmap_\\<alpha> hm k \\<noteq> None;\n     h.heap_invar h; h.valid h (hm_index hm k)\\<rbrakk>\n    \\<Longrightarrow> heapmap_invar hm\n 2. \\<lbrakk>(hm, m) \\<in> br heapmap_\\<alpha> heapmap_invar;\n     (hm, h) \\<in> hmr_rel; heapmap_\\<alpha> hm k \\<noteq> None;\n     h.heap_invar h; h.valid h (hm_index hm k); heapmap_invar hm\\<rbrakk>\n    \\<Longrightarrow> k \\<in> dom (heapmap_\\<alpha> hm)\n 3. \\<lbrakk>(hm, m) \\<in> br heapmap_\\<alpha> heapmap_invar;\n     (hm, h) \\<in> hmr_rel; heapmap_\\<alpha> hm k \\<noteq> None;\n     h.heap_invar h; h.valid h (hm_index hm k); heapmap_invar hm;\n     k \\<in> dom (heapmap_\\<alpha> hm)\\<rbrakk>\n    \\<Longrightarrow> (hm_index hm k, hm_index hm k) \\<in> nat_rel\n 4. \\<And>hma ha hmaa haa.\n       \\<lbrakk>(hm, m) \\<in> br heapmap_\\<alpha> heapmap_invar;\n        (hm, h) \\<in> hmr_rel; heapmap_\\<alpha> hm k \\<noteq> None;\n        h.heap_invar h; h.valid h (hm_index hm k); heapmap_invar hm;\n        k \\<in> dom (heapmap_\\<alpha> hm); (hma, ha) \\<in> hmr_rel;\n        (hmaa, haa) \\<in> hmr_rel\\<rbrakk>\n       \\<Longrightarrow> (hm_index hm k \\<noteq> hm_length hm) =\n                         (hm_index hm k \\<noteq> length h)\n 5. \\<And>hma ha hmaa haa.\n       \\<lbrakk>(hm, m) \\<in> br heapmap_\\<alpha> heapmap_invar;\n        (hm, h) \\<in> hmr_rel; heapmap_\\<alpha> hm k \\<noteq> None;\n        h.heap_invar h; h.valid h (hm_index hm k); heapmap_invar hm;\n        k \\<in> dom (heapmap_\\<alpha> hm); (hma, ha) \\<in> hmr_rel;\n        (hmaa, haa) \\<in> hmr_rel; hm_index hm k \\<noteq> hm_length hm;\n        hm_index hm k \\<noteq> length h\\<rbrakk>\n       \\<Longrightarrow> (hm_index hm k, hm_index hm k) \\<in> nat_rel", "unfolding hmr_rel_def"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>(hm, m) \\<in> br heapmap_\\<alpha> heapmap_invar;\n     (hm, h) \\<in> br hmr_\\<alpha> hmr_invar;\n     heapmap_\\<alpha> hm k \\<noteq> None; h.heap_invar h;\n     h.valid h (hm_index hm k)\\<rbrakk>\n    \\<Longrightarrow> heapmap_invar hm\n 2. \\<lbrakk>(hm, m) \\<in> br heapmap_\\<alpha> heapmap_invar;\n     (hm, h) \\<in> br hmr_\\<alpha> hmr_invar;\n     heapmap_\\<alpha> hm k \\<noteq> None; h.heap_invar h;\n     h.valid h (hm_index hm k); heapmap_invar hm\\<rbrakk>\n    \\<Longrightarrow> k \\<in> dom (heapmap_\\<alpha> hm)\n 3. \\<lbrakk>(hm, m) \\<in> br heapmap_\\<alpha> heapmap_invar;\n     (hm, h) \\<in> br hmr_\\<alpha> hmr_invar;\n     heapmap_\\<alpha> hm k \\<noteq> None; h.heap_invar h;\n     h.valid h (hm_index hm k); heapmap_invar hm;\n     k \\<in> dom (heapmap_\\<alpha> hm)\\<rbrakk>\n    \\<Longrightarrow> (hm_index hm k, hm_index hm k) \\<in> nat_rel\n 4. \\<And>hma ha hmaa haa.\n       \\<lbrakk>(hm, m) \\<in> br heapmap_\\<alpha> heapmap_invar;\n        (hm, h) \\<in> br hmr_\\<alpha> hmr_invar;\n        heapmap_\\<alpha> hm k \\<noteq> None; h.heap_invar h;\n        h.valid h (hm_index hm k); heapmap_invar hm;\n        k \\<in> dom (heapmap_\\<alpha> hm);\n        (hma, ha) \\<in> br hmr_\\<alpha> hmr_invar;\n        (hmaa, haa) \\<in> br hmr_\\<alpha> hmr_invar\\<rbrakk>\n       \\<Longrightarrow> (hm_index hm k \\<noteq> hm_length hm) =\n                         (hm_index hm k \\<noteq> length h)\n 5. \\<And>hma ha hmaa haa.\n       \\<lbrakk>(hm, m) \\<in> br heapmap_\\<alpha> heapmap_invar;\n        (hm, h) \\<in> br hmr_\\<alpha> hmr_invar;\n        heapmap_\\<alpha> hm k \\<noteq> None; h.heap_invar h;\n        h.valid h (hm_index hm k); heapmap_invar hm;\n        k \\<in> dom (heapmap_\\<alpha> hm);\n        (hma, ha) \\<in> br hmr_\\<alpha> hmr_invar;\n        (hmaa, haa) \\<in> br hmr_\\<alpha> hmr_invar;\n        hm_index hm k \\<noteq> hm_length hm;\n        hm_index hm k \\<noteq> length h\\<rbrakk>\n       \\<Longrightarrow> (hm_index hm k, hm_index hm k) \\<in> nat_rel", "apply (auto simp: in_br_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hm_remove_op_\\<alpha>_correct: \n      \"hm_remove_op k hm \\<le>\\<^sub>n SPEC (\\<lambda>hm'. heapmap_\\<alpha> hm' = (heapmap_\\<alpha> hm)(k:=None))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_remove_op k hm \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>hm'. heapmap_\\<alpha> hm' = (heapmap_\\<alpha> hm)(k := None))", "unfolding hm_remove_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (heapmap_invar hm) \\<bind>\n    (\\<lambda>_.\n        ASSERT (k \\<in> dom (heapmap_\\<alpha> hm)) \\<bind>\n        (\\<lambda>_.\n            hm_index_op hm k \\<bind>\n            (\\<lambda>i.\n                let l = hm_length hm\n                in hm_exch_op hm i l \\<bind>\n                   (\\<lambda>hm.\n                       hm_butlast_op hm \\<bind>\n                       (\\<lambda>hm.\n                           if i \\<noteq> l then hm_repair_op hm i\n                           else RETURN hm))))) \\<le>\\<^sub>n\n    SPEC\n     (\\<lambda>hm'. heapmap_\\<alpha> hm' = (heapmap_\\<alpha> hm)(k := None))", "apply (refine_vcg \n        hm_exch_op_\\<alpha>_correct[THEN leof_trans]\n        hm_butlast_op_\\<alpha>_correct[THEN leof_trans]\n        hm_repair_op_\\<alpha>_correct[THEN leof_trans]\n        hm_index_op_inline_leof\n        )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       \\<lbrakk>heapmap_invar hm; k \\<in> dom (heapmap_\\<alpha> hm);\n        x \\<in> {hm'.\n                 hm_valid hm (hm_index hm k) \\<and>\n                 hm_valid hm (hm_length hm) \\<and>\n                 hm' = hm_exch hm (hm_index hm k) (hm_length hm)};\n        xa \\<in> {hm'.\n                  heapmap_\\<alpha> hm' = (heapmap_\\<alpha> x)\n                  (hm_key_of x (hm_length x) := None)};\n        hm_index hm k \\<noteq> hm_length hm;\n        xb \\<in> {hm'. heapmap_\\<alpha> hm' = heapmap_\\<alpha> xa}\\<rbrakk>\n       \\<Longrightarrow> heapmap_\\<alpha> xb = (heapmap_\\<alpha> hm)\n                         (k := None)\n 2. \\<And>x xa.\n       \\<lbrakk>heapmap_invar hm; k \\<in> dom (heapmap_\\<alpha> hm);\n        x \\<in> {hm'.\n                 hm_valid hm (hm_index hm k) \\<and>\n                 hm_valid hm (hm_length hm) \\<and>\n                 hm' = hm_exch hm (hm_index hm k) (hm_length hm)};\n        xa \\<in> {hm'.\n                  heapmap_\\<alpha> hm' = (heapmap_\\<alpha> x)\n                  (hm_key_of x (hm_length x) := None)};\n        \\<not> hm_index hm k \\<noteq> hm_length hm\\<rbrakk>\n       \\<Longrightarrow> heapmap_\\<alpha> xa = (heapmap_\\<alpha> hm)\n                         (k := None)", "apply (auto; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>heapmap_invar hm; k \\<in> dom (heapmap_\\<alpha> hm);\n        x \\<in> {hm'.\n                 hm_valid hm (hm_index hm k) \\<and>\n                 hm_valid hm (hm_length hm) \\<and>\n                 hm' = hm_exch hm (hm_index hm k) (hm_length hm)};\n        xa \\<in> {hm'.\n                  heapmap_\\<alpha> hm' = (heapmap_\\<alpha> x)\n                  (hm_key_of x (hm_length x) := None)};\n        \\<not> hm_index hm k \\<noteq> hm_length hm\\<rbrakk>\n       \\<Longrightarrow> heapmap_\\<alpha> xa = (heapmap_\\<alpha> hm)\n                         (k := None)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b y.\n       \\<lbrakk>heapmap_invar hm; hm_valid hm (hm_length hm);\n        heapmap_\\<alpha> (a, b) = (heapmap_\\<alpha> hm)\n        (hm_key_of hm (hm_length hm) := None);\n        hm_index hm k = hm_length hm;\n        heapmap_\\<alpha> hm k = Some y\\<rbrakk>\n       \\<Longrightarrow> (heapmap_\\<alpha> hm)\n                         (hm_key_of hm (hm_length hm) := None) =\n                         (heapmap_\\<alpha> hm)(k := None)", "apply (rewrite at \"hm_index _ k = hm_length _\" in asm eq_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b y.\n       \\<lbrakk>heapmap_invar hm; hm_valid hm (hm_length hm);\n        heapmap_\\<alpha> (a, b) = (heapmap_\\<alpha> hm)\n        (hm_key_of hm (hm_length hm) := None);\n        hm_length hm = hm_index hm k;\n        heapmap_\\<alpha> hm k = Some y\\<rbrakk>\n       \\<Longrightarrow> (heapmap_\\<alpha> hm)\n                         (hm_key_of hm (hm_length hm) := None) =\n                         (heapmap_\\<alpha> hm)(k := None)", "apply (auto; fail)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hm_remove_op_aref:\n      \"(hm_remove_op,mop_map_delete_ex) \\<in> Id \\<rightarrow> heapmap_rel \\<rightarrow> \\<langle>heapmap_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hm_remove_op, mop_map_delete_ex)\n    \\<in> Id \\<rightarrow>\n          heapmap_rel \\<rightarrow> \\<langle>heapmap_rel\\<rangle>nres_rel", "apply (intro fun_relI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> heapmap_rel\\<rbrakk>\n       \\<Longrightarrow> hm_remove_op a aa\n                         \\<le> \\<Down> heapmap_rel\n                                (mop_map_delete_ex a' a'a)", "unfolding mop_map_delete_ex_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> heapmap_rel\\<rbrakk>\n       \\<Longrightarrow> hm_remove_op a aa\n                         \\<le> \\<Down> heapmap_rel\n                                (ASSERT\n                                  (pre_map_delete_ex (a', a'a)) \\<bind>\n                                 (\\<lambda>_.\n                                     RETURN (op_map_delete_ex a' a'a)))", "apply (rule ASSERT_refine_right)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> heapmap_rel;\n        pre_map_delete_ex (a', a'a)\\<rbrakk>\n       \\<Longrightarrow> hm_remove_op a aa\n                         \\<le> \\<Down> heapmap_rel\n                                (RETURN (op_map_delete_ex a' a'a))", "apply (frule heapmap_hmr_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> heapmap_rel;\n        pre_map_delete_ex (a', a'a);\n        (aa, hmr_\\<alpha> aa) \\<in> hmr_rel\\<rbrakk>\n       \\<Longrightarrow> hm_remove_op a aa\n                         \\<le> \\<Down> heapmap_rel\n                                (RETURN (op_map_delete_ex a' a'a))", "apply (rule heapmap_nres_relI')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> heapmap_rel;\n        pre_map_delete_ex (a', a'a);\n        (aa, hmr_\\<alpha> aa) \\<in> hmr_rel\\<rbrakk>\n       \\<Longrightarrow> hm_remove_op a aa\n                         \\<le> \\<Down> hmr_rel (?h'7 a a' aa a'a)\n 2. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> heapmap_rel;\n        pre_map_delete_ex (a', a'a);\n        (aa, hmr_\\<alpha> aa) \\<in> hmr_rel\\<rbrakk>\n       \\<Longrightarrow> ?h'7 a a' aa a'a \\<le> SPEC h.heap_invar\n 3. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> heapmap_rel;\n        pre_map_delete_ex (a', a'a);\n        (aa, hmr_\\<alpha> aa) \\<in> hmr_rel\\<rbrakk>\n       \\<Longrightarrow> hm_remove_op a aa \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>hm'.\n                              RETURN (heapmap_\\<alpha> hm')\n                              \\<le> RETURN (op_map_delete_ex a' a'a))", "apply (rule hm_remove_op_refine; assumption?)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> heapmap_rel;\n        pre_map_delete_ex (a', a'a);\n        (aa, hmr_\\<alpha> aa) \\<in> hmr_rel\\<rbrakk>\n       \\<Longrightarrow> heapmap_\\<alpha> aa a \\<noteq> None\n 2. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> heapmap_rel;\n        pre_map_delete_ex (a', a'a);\n        (aa, hmr_\\<alpha> aa) \\<in> hmr_rel\\<rbrakk>\n       \\<Longrightarrow> h.remove_op (hm_index aa a) (hmr_\\<alpha> aa)\n                         \\<le> SPEC h.heap_invar\n 3. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> heapmap_rel;\n        pre_map_delete_ex (a', a'a);\n        (aa, hmr_\\<alpha> aa) \\<in> hmr_rel\\<rbrakk>\n       \\<Longrightarrow> hm_remove_op a aa \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>hm'.\n                              RETURN (heapmap_\\<alpha> hm')\n                              \\<le> RETURN (op_map_delete_ex a' a'a))", "apply (unfold heapmap_rel_def in_br_conv; auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> heapmap_rel;\n        pre_map_delete_ex (a', a'a);\n        (aa, hmr_\\<alpha> aa) \\<in> hmr_rel\\<rbrakk>\n       \\<Longrightarrow> h.remove_op (hm_index aa a) (hmr_\\<alpha> aa)\n                         \\<le> SPEC h.heap_invar\n 2. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> heapmap_rel;\n        pre_map_delete_ex (a', a'a);\n        (aa, hmr_\\<alpha> aa) \\<in> hmr_rel\\<rbrakk>\n       \\<Longrightarrow> hm_remove_op a aa \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>hm'.\n                              RETURN (heapmap_\\<alpha> hm')\n                              \\<le> RETURN (op_map_delete_ex a' a'a))", "unfolding heapmap_rel_def hmr_rel_def in_br_conv"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Id;\n        a'a = heapmap_\\<alpha> aa \\<and> heapmap_invar aa;\n        pre_map_delete_ex (a', a'a);\n        hmr_\\<alpha> aa = hmr_\\<alpha> aa \\<and> hmr_invar aa\\<rbrakk>\n       \\<Longrightarrow> h.remove_op (hm_index aa a) (hmr_\\<alpha> aa)\n                         \\<le> SPEC h.heap_invar\n 2. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Id;\n        a'a = heapmap_\\<alpha> aa \\<and> heapmap_invar aa;\n        pre_map_delete_ex (a', a'a);\n        hmr_\\<alpha> aa = hmr_\\<alpha> aa \\<and> hmr_invar aa\\<rbrakk>\n       \\<Longrightarrow> hm_remove_op a aa \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>hm'.\n                              RETURN (heapmap_\\<alpha> hm')\n                              \\<le> RETURN (op_map_delete_ex a' a'a))", "apply (refine_vcg h.remove_op_invar; clarsimp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Id;\n        a'a = heapmap_\\<alpha> aa \\<and> heapmap_invar aa;\n        pre_map_delete_ex (a', a'a);\n        hmr_\\<alpha> aa = hmr_\\<alpha> aa \\<and> hmr_invar aa\\<rbrakk>\n       \\<Longrightarrow> hm_remove_op a aa \\<le>\\<^sub>n\n                         SPEC\n                          (\\<lambda>hm'.\n                              RETURN (heapmap_\\<alpha> hm')\n                              \\<le> RETURN (op_map_delete_ex a' a'a))", "apply (refine_vcg hm_remove_op_\\<alpha>_correct[THEN leof_trans]; simp; fail)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Peek-Min\\<close>"], ["", "definition hm_peek_min_op :: \"('k,'v) ahm \\<Rightarrow> ('k\\<times>'v) nres\" where\n      \"hm_peek_min_op hm \\<equiv> hm_kv_of_op hm 1\""], ["", "lemma hm_peek_min_op_aref: \n      \"(hm_peek_min_op, PR_CONST (mop_pm_peek_min prio)) \\<in> heapmap_rel \\<rightarrow> \\<langle>Id\\<times>\\<^sub>rId\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hm_peek_min_op, PR_CONST (mop_pm_peek_min prio))\n    \\<in> heapmap_rel \\<rightarrow>\n          \\<langle>Id \\<times>\\<^sub>r Id\\<rangle>nres_rel", "unfolding PR_CONST_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (hm_peek_min_op, mop_pm_peek_min prio)\n    \\<in> heapmap_rel \\<rightarrow>\n          \\<langle>Id \\<times>\\<^sub>r Id\\<rangle>nres_rel", "apply (intro fun_relI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> heapmap_rel \\<Longrightarrow>\n       hm_peek_min_op a\n       \\<le> \\<Down> (Id \\<times>\\<^sub>r Id) (mop_pm_peek_min prio a')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> heapmap_rel \\<Longrightarrow>\n       hm_peek_min_op a\n       \\<le> \\<Down> (Id \\<times>\\<^sub>r Id) (mop_pm_peek_min prio a')", "fix hm and m :: \"'k \\<rightharpoonup> 'v\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> heapmap_rel \\<Longrightarrow>\n       hm_peek_min_op a\n       \\<le> \\<Down> (Id \\<times>\\<^sub>r Id) (mop_pm_peek_min prio a')", "assume A: \"(hm,m)\\<in>heapmap_rel\""], ["proof (state)\nthis:\n  (hm, m) \\<in> heapmap_rel\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> heapmap_rel \\<Longrightarrow>\n       hm_peek_min_op a\n       \\<le> \\<Down> (Id \\<times>\\<^sub>r Id) (mop_pm_peek_min prio a')", "from A"], ["proof (chain)\npicking this:\n  (hm, m) \\<in> heapmap_rel", "have [simp]: \"h.heap_invar (hmr_\\<alpha> hm)\" \"hmr_invar hm\" \"m=heapmap_\\<alpha> hm\""], ["proof (prove)\nusing this:\n  (hm, m) \\<in> heapmap_rel\n\ngoal (1 subgoal):\n 1. h.heap_invar (hmr_\\<alpha> hm) &&&\n    hmr_invar hm &&& m = heapmap_\\<alpha> hm", "unfolding heapmap_rel_def in_br_conv heapmap_invar_def"], ["proof (prove)\nusing this:\n  m = heapmap_\\<alpha> hm \\<and>\n  hmr_invar hm \\<and> h.heap_invar (hmr_\\<alpha> hm)\n\ngoal (1 subgoal):\n 1. h.heap_invar (hmr_\\<alpha> hm) &&&\n    hmr_invar hm &&& m = heapmap_\\<alpha> hm", "by simp_all"], ["proof (state)\nthis:\n  h.heap_invar (hmr_\\<alpha> hm)\n  hmr_invar hm\n  m = heapmap_\\<alpha> hm\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> heapmap_rel \\<Longrightarrow>\n       hm_peek_min_op a\n       \\<le> \\<Down> (Id \\<times>\\<^sub>r Id) (mop_pm_peek_min prio a')", "have \"hm_peek_min_op hm \\<le> \\<Down> (kvi_rel hm 1) (h.peek_min_op (hmr_\\<alpha> hm))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_peek_min_op hm\n    \\<le> \\<Down> (kvi_rel hm 1) (h.peek_min_op (hmr_\\<alpha> hm))", "unfolding hm_peek_min_op_def  h.peek_min_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_kv_of_op hm 1\n    \\<le> \\<Down> (kvi_rel hm 1)\n           (ASSERT (h.heap_invar (hmr_\\<alpha> hm)) \\<bind>\n            (\\<lambda>_.\n                ASSERT (h.valid (hmr_\\<alpha> hm) 1) \\<bind>\n                (\\<lambda>_. h.val_of_op (hmr_\\<alpha> hm) 1)))", "apply (refine_rcg hm_kv_op_refine)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h.heap_invar (hmr_\\<alpha> hm);\n     h.valid (hmr_\\<alpha> hm) 1\\<rbrakk>\n    \\<Longrightarrow> (hm, hmr_\\<alpha> hm) \\<in> hmr_rel", "using A"], ["proof (prove)\nusing this:\n  (hm, m) \\<in> heapmap_rel\n\ngoal (1 subgoal):\n 1. \\<lbrakk>h.heap_invar (hmr_\\<alpha> hm);\n     h.valid (hmr_\\<alpha> hm) 1\\<rbrakk>\n    \\<Longrightarrow> (hm, hmr_\\<alpha> hm) \\<in> hmr_rel", "apply (simp add: heapmap_hmr_relI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  hm_peek_min_op hm\n  \\<le> \\<Down> (kvi_rel hm 1) (h.peek_min_op (hmr_\\<alpha> hm))\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> heapmap_rel \\<Longrightarrow>\n       hm_peek_min_op a\n       \\<le> \\<Down> (Id \\<times>\\<^sub>r Id) (mop_pm_peek_min prio a')", "also"], ["proof (state)\nthis:\n  hm_peek_min_op hm\n  \\<le> \\<Down> (kvi_rel hm 1) (h.peek_min_op (hmr_\\<alpha> hm))\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> heapmap_rel \\<Longrightarrow>\n       hm_peek_min_op a\n       \\<le> \\<Down> (Id \\<times>\\<^sub>r Id) (mop_pm_peek_min prio a')", "have \"\\<lbrakk>hmr_\\<alpha> hm \\<noteq> []\\<rbrakk> \\<Longrightarrow> (h.peek_min_op (hmr_\\<alpha> hm)) \n        \\<le> SPEC (\\<lambda>v. v\\<in>ran (heapmap_\\<alpha> hm) \\<and> (\\<forall>v'\\<in>ran (heapmap_\\<alpha> hm). prio v \\<le> prio v'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hmr_\\<alpha> hm \\<noteq> [] \\<Longrightarrow>\n    h.peek_min_op (hmr_\\<alpha> hm)\n    \\<le> SPEC\n           (\\<lambda>v.\n               v \\<in> ran (heapmap_\\<alpha> hm) \\<and>\n               (\\<forall>v'\\<in>ran (heapmap_\\<alpha> hm).\n                   prio v \\<le> prio v'))", "apply refine_vcg"], ["proof (prove)\ngoal (4 subgoals):\n 1. hmr_\\<alpha> hm \\<noteq> [] \\<Longrightarrow>\n    h.heap_invar (hmr_\\<alpha> hm)\n 2. hmr_\\<alpha> hm \\<noteq> [] \\<Longrightarrow>\n    h.\\<alpha> (hmr_\\<alpha> hm) \\<noteq> {#}\n 3. \\<And>x.\n       \\<lbrakk>hmr_\\<alpha> hm \\<noteq> [];\n        x \\<in># h.\\<alpha> (hmr_\\<alpha> hm) \\<and>\n        (\\<forall>v'\\<in>#h.\\<alpha> (hmr_\\<alpha> hm).\n            prio x \\<le> prio v')\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ran (heapmap_\\<alpha> hm)\n 4. \\<And>x.\n       \\<lbrakk>hmr_\\<alpha> hm \\<noteq> [];\n        x \\<in># h.\\<alpha> (hmr_\\<alpha> hm) \\<and>\n        (\\<forall>v'\\<in>#h.\\<alpha> (hmr_\\<alpha> hm).\n            prio x \\<le> prio v')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v'\\<in>ran (heapmap_\\<alpha> hm).\n                            prio x \\<le> prio v'", "by simp_all"], ["proof (state)\nthis:\n  hmr_\\<alpha> hm \\<noteq> [] \\<Longrightarrow>\n  h.peek_min_op (hmr_\\<alpha> hm)\n  \\<le> SPEC\n         (\\<lambda>v.\n             v \\<in> ran (heapmap_\\<alpha> hm) \\<and>\n             (\\<forall>v'\\<in>ran (heapmap_\\<alpha> hm).\n                 prio v \\<le> prio v'))\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> heapmap_rel \\<Longrightarrow>\n       hm_peek_min_op a\n       \\<le> \\<Down> (Id \\<times>\\<^sub>r Id) (mop_pm_peek_min prio a')", "finally"], ["proof (chain)\npicking this:\n  hmr_\\<alpha> hm \\<noteq> [] \\<Longrightarrow>\n  hm_peek_min_op hm\n  \\<le> \\<Down> (kvi_rel hm 1)\n         (SPEC\n           (\\<lambda>v.\n               v \\<in> ran (heapmap_\\<alpha> hm) \\<and>\n               (\\<forall>v'\\<in>ran (heapmap_\\<alpha> hm).\n                   prio v \\<le> prio v')))", "show \"hm_peek_min_op hm \\<le> \\<Down> (Id \\<times>\\<^sub>r Id) (mop_pm_peek_min prio m)\""], ["proof (prove)\nusing this:\n  hmr_\\<alpha> hm \\<noteq> [] \\<Longrightarrow>\n  hm_peek_min_op hm\n  \\<le> \\<Down> (kvi_rel hm 1)\n         (SPEC\n           (\\<lambda>v.\n               v \\<in> ran (heapmap_\\<alpha> hm) \\<and>\n               (\\<forall>v'\\<in>ran (heapmap_\\<alpha> hm).\n                   prio v \\<le> prio v')))\n\ngoal (1 subgoal):\n 1. hm_peek_min_op hm\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r Id) (mop_pm_peek_min prio m)", "unfolding mop_pm_peek_min_alt"], ["proof (prove)\nusing this:\n  hmr_\\<alpha> hm \\<noteq> [] \\<Longrightarrow>\n  hm_peek_min_op hm\n  \\<le> \\<Down> (kvi_rel hm 1)\n         (SPEC\n           (\\<lambda>v.\n               v \\<in> ran (heapmap_\\<alpha> hm) \\<and>\n               (\\<forall>v'\\<in>ran (heapmap_\\<alpha> hm).\n                   prio v \\<le> prio v')))\n\ngoal (1 subgoal):\n 1. hm_peek_min_op hm\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r Id)\n           (ASSERT (pre_pm_peek_min m) \\<bind>\n            (\\<lambda>_. PR_CONST (op_pm_peek_min prio) m))", "apply (simp add: pw_le_iff refine_pw_simps hm_peek_min_op_def hm_kv_of_op_def \n            hm_key_of_op_unfold hm_the_lookup_op_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (heapmap_\\<alpha> hm \\<noteq> Map.empty \\<Longrightarrow>\n     hm_valid hm (Suc 0) \\<and>\n     (\\<exists>y.\n         heapmap_\\<alpha> hm (hm_key_of hm (Suc 0)) = Some y) \\<and>\n     (\\<forall>a b.\n         (hm_valid hm (Suc 0) \\<longrightarrow>\n          (\\<exists>y.\n              heapmap_\\<alpha> hm (hm_key_of hm (Suc 0)) =\n              Some y) \\<longrightarrow>\n          hm_key_of hm (Suc 0) = a \\<and>\n          the (heapmap_\\<alpha> hm (hm_key_of hm (Suc 0))) =\n          b) \\<longrightarrow>\n         (\\<exists>s'.\n             ((a, b), s') \\<in> kvi_rel hm (Suc 0) \\<and>\n             s' \\<in> ran (heapmap_\\<alpha> hm) \\<and>\n             (\\<forall>v'\\<in>ran (heapmap_\\<alpha> hm).\n                 prio s' \\<le> prio v')))) \\<Longrightarrow>\n    Map.empty \\<noteq> heapmap_\\<alpha> hm \\<longrightarrow>\n    (\\<forall>k' v'.\n        heapmap_\\<alpha> hm k' = Some v' \\<longrightarrow>\n        prio (the (heapmap_\\<alpha> hm (hm_key_of hm (Suc 0))))\n        \\<le> prio v')", "apply (fastforce simp: kvi_rel_def ran_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  hm_peek_min_op hm\n  \\<le> \\<Down> (Id \\<times>\\<^sub>r Id) (mop_pm_peek_min prio m)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}