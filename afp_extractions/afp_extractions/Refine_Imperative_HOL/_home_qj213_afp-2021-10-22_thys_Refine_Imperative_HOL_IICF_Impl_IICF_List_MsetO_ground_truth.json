{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/IICF/Impl/IICF_List_MsetO.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemmas [fcomp_norm_unfold] = lmso_assn_def[symmetric]", "lemma lmso_is_pure[safe_constraint_rules]: \"is_pure A \\<Longrightarrow> is_pure (lmso_assn A)\"", "lemma lmso_empty_aref: \"(uncurry0 (RETURN []), uncurry0 (RETURN op_mset_empty)) \\<in> unit_rel \\<rightarrow>\\<^sub>f \\<langle>br mset (\\<lambda>_. True)\\<rangle>nres_rel\"", "lemma lmso_is_empty_aref: \"(RETURN o List.null, RETURN o op_mset_is_empty) \\<in> br mset (\\<lambda>_. True) \\<rightarrow>\\<^sub>f \\<langle>bool_rel\\<rangle>nres_rel\"", "lemma lmso_insert_aref: \"(uncurry (RETURN oo (#) ), uncurry (RETURN oo op_mset_insert)) \\<in> (Id \\<times>\\<^sub>r br mset (\\<lambda>_. True)) \\<rightarrow>\\<^sub>f \\<langle>br mset (\\<lambda>_. True)\\<rangle>nres_rel\"", "lemma hd_tl_opt[sepref_opt_simps]: \"hd_tl l = (case l of (x#xs) \\<Rightarrow> (x,xs) | _ \\<Rightarrow> CODE_ABORT (\\<lambda>_. (hd l, tl l)))\"", "lemma lmso_pick_aref: \"(RETURN o hd_tl,op_mset_pick) \\<in> [\\<lambda>m. m\\<noteq>{#}]\\<^sub>f br mset (\\<lambda>_. True) \\<rightarrow> \\<langle>Id \\<times>\\<^sub>r br mset (\\<lambda>_. True)\\<rangle>nres_rel\"", "lemma hd_tl_hnr: \"(return o hd_tl,RETURN o hd_tl) \\<in> [\\<lambda>l. \\<not>is_Nil l]\\<^sub>a (list_assn A)\\<^sup>d \\<rightarrow> prod_assn A (list_assn A)\"", "lemma lmso_fold_custom_empty: \n    \"{#} = op_lmso_empty\"\n    \"op_mset_empty = op_lmso_empty\"\n    \"mop_mset_empty = RETURN op_lmso_empty\"", "lemmas [sepref_fr_rules] = lmso_empty_hnr[folded op_lmso_empty_def]", "lemma list_null_hnr: \"(return o List.null,RETURN o List.null) \\<in> (list_assn A)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\"", "lemma op_mset_pick_dummy_param: \"(op_mset_pick, op_mset_pick) \\<in> Id \\<rightarrow>\\<^sub>f \\<langle>Id\\<rangle>nres_rel\""], "translations": [["", "lemmas [fcomp_norm_unfold] = lmso_assn_def[symmetric]"], ["", "lemma lmso_is_pure[safe_constraint_rules]: \"is_pure A \\<Longrightarrow> is_pure (lmso_assn A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pure A \\<Longrightarrow> is_pure (lmso_assn A)", "unfolding lmso_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pure A \\<Longrightarrow>\n    is_pure (hr_comp (list_assn A) (br mset (\\<lambda>_. True)))", "by safe_constraint"], ["", "lemma lmso_empty_aref: \"(uncurry0 (RETURN []), uncurry0 (RETURN op_mset_empty)) \\<in> unit_rel \\<rightarrow>\\<^sub>f \\<langle>br mset (\\<lambda>_. True)\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 (RETURN []), uncurry0 (RETURN op_mset_empty))\n    \\<in> unit_rel \\<rightarrow>\\<^sub>f \\<langle>br mset\n             (\\<lambda>_. True)\\<rangle>nres_rel", "by (auto intro!: frefI nres_relI simp: in_br_conv)"], ["", "(*  \n  definition [simp]: \"list_single x \\<equiv> [x]\"\n  lemma lmso_single_aref: \"(RETURN o list_single,RETURN o op_mset_single) \\<in> Id \\<rightarrow>\\<^sub>f \\<langle>br mset (\\<lambda>_. True)\\<rangle>nres_rel\"  \n    by (auto intro!: frefI nres_relI simp: in_br_conv)\n  *)"], ["", "lemma lmso_is_empty_aref: \"(RETURN o List.null, RETURN o op_mset_is_empty) \\<in> br mset (\\<lambda>_. True) \\<rightarrow>\\<^sub>f \\<langle>bool_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN \\<circ> List.null, RETURN \\<circ> op_mset_is_empty)\n    \\<in> br mset\n           (\\<lambda>_.\n               True) \\<rightarrow>\\<^sub>f \\<langle>bool_rel\\<rangle>nres_rel", "by (auto intro!: frefI nres_relI simp: in_br_conv List.null_def split: list.split)"], ["", "lemma lmso_insert_aref: \"(uncurry (RETURN oo (#) ), uncurry (RETURN oo op_mset_insert)) \\<in> (Id \\<times>\\<^sub>r br mset (\\<lambda>_. True)) \\<rightarrow>\\<^sub>f \\<langle>br mset (\\<lambda>_. True)\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry (RETURN \\<circ>\\<circ> (#)),\n     uncurry (RETURN \\<circ>\\<circ> op_mset_insert))\n    \\<in> Id \\<times>\\<^sub>r\n          br mset\n           (\\<lambda>_.\n               True) \\<rightarrow>\\<^sub>f \\<langle>br mset\n               (\\<lambda>_. True)\\<rangle>nres_rel", "by (auto intro!: frefI nres_relI simp: in_br_conv)"], ["", "(*  \n  lemma list_single_hnr: \"(return o list_single, RETURN o list_single) \\<in> A\\<^sup>d \\<rightarrow>\\<^sub>a list_assn A\"  \n    apply sepref_to_hoare\n    apply sep_auto\n    done  \n  *)"], ["", "definition [simp]: \"hd_tl l \\<equiv> (hd l, tl l)\""], ["", "lemma hd_tl_opt[sepref_opt_simps]: \"hd_tl l = (case l of (x#xs) \\<Rightarrow> (x,xs) | _ \\<Rightarrow> CODE_ABORT (\\<lambda>_. (hd l, tl l)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd_tl l =\n    (case l of [] \\<Rightarrow> CODE_ABORT (\\<lambda>_. (hd l, tl l))\n     | x # xs \\<Rightarrow> (x, xs))", "by (auto split: list.split)"], ["", "lemma lmso_pick_aref: \"(RETURN o hd_tl,op_mset_pick) \\<in> [\\<lambda>m. m\\<noteq>{#}]\\<^sub>f br mset (\\<lambda>_. True) \\<rightarrow> \\<langle>Id \\<times>\\<^sub>r br mset (\\<lambda>_. True)\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN \\<circ> hd_tl, op_mset_pick)\n    \\<in> [\\<lambda>m.\n              m \\<noteq>\n              {#}]\\<^sub>f br mset\n                            (\\<lambda>_.\n                                True) \\<rightarrow> \\<langle>Id \\<times>\\<^sub>r\n                       br mset (\\<lambda>_. True)\\<rangle>nres_rel", "by (auto intro!: frefI nres_relI simp: in_br_conv pw_le_iff refine_pw_simps neq_Nil_conv algebra_simps)"], ["", "lemma hd_tl_hnr: \"(return o hd_tl,RETURN o hd_tl) \\<in> [\\<lambda>l. \\<not>is_Nil l]\\<^sub>a (list_assn A)\\<^sup>d \\<rightarrow> prod_assn A (list_assn A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (return \\<circ> hd_tl, RETURN \\<circ> hd_tl)\n    \\<in> [\\<lambda>l.\n              \\<not> is_Nil\n                      l]\\<^sub>a (list_assn\n                                   A)\\<^sup>d \\<rightarrow> A \\<times>\\<^sub>a\n                      list_assn A", "apply sepref_to_hoare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xi.\n       \\<lbrakk>\\<not> is_Nil x; x ::\\<^sub>i TYPE('b list);\n        nofail (RETURN (hd_tl x))\\<rbrakk>\n       \\<Longrightarrow> <list_assn A x\n                           xi> return\n                                (hd_tl\n                                  xi) <\\<lambda>r.\n    true *\n    (\\<exists>\\<^sub>Axa.\n        (A \\<times>\\<^sub>a list_assn A) xa r *\n        \\<up> (RETURN xa \\<le> RETURN (hd_tl x)))>\\<^sub>t", "subgoal for l li"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> is_Nil l; l ::\\<^sub>i TYPE('b list);\n     nofail (RETURN (hd_tl l))\\<rbrakk>\n    \\<Longrightarrow> <list_assn A l\n                        li> return\n                             (hd_tl\n                               li) <\\<lambda>r.\n true *\n (\\<exists>\\<^sub>Ax.\n     (A \\<times>\\<^sub>a list_assn A) x r *\n     \\<up> (RETURN x \\<le> RETURN (hd_tl l)))>\\<^sub>t", "by (cases l; cases li; sep_auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "sepref_decl_impl (no_register) lmso_empty: hn_Nil[to_hfref] uses lmso_empty_aref"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition [simp]: \"op_lmso_empty \\<equiv> op_mset_empty\""], ["", "sepref_register op_lmso_empty"], ["", "lemma lmso_fold_custom_empty: \n    \"{#} = op_lmso_empty\"\n    \"op_mset_empty = op_lmso_empty\"\n    \"mop_mset_empty = RETURN op_lmso_empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#} = op_lmso_empty &&&\n    op_mset_empty = op_lmso_empty &&& mop_mset_empty = RETURN op_lmso_empty", "by auto"], ["", "lemmas [sepref_fr_rules] = lmso_empty_hnr[folded op_lmso_empty_def]"], ["", "(*\n  sepref_decl_impl (no_register) lmso_single: list_single_hnr uses lmso_single_aref .\n  definition [simp]: \"op_lmso_single \\<equiv> op_mset_single\"\n  sepref_register op_lmso_single\n  lemma lmso_fold_custom_single: \n    \"{#x#} = op_lmso_single x\"\n    \"op_mset_single x = op_lmso_single x\"\n    \"mop_mset_single x = RETURN (op_lmso_single x)\"\n    by auto\n  lemmas [sepref_fr_rules] = lmso_single_hnr[folded op_lmso_single_def]  \n *)"], ["", "lemma list_null_hnr: \"(return o List.null,RETURN o List.null) \\<in> (list_assn A)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (return \\<circ> List.null, RETURN \\<circ> List.null)\n    \\<in> (list_assn A)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "apply sepref_to_hoare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xi.\n       \\<lbrakk>x ::\\<^sub>i TYPE('b list);\n        nofail (RETURN (List.null x))\\<rbrakk>\n       \\<Longrightarrow> <list_assn A x\n                           xi> return\n                                (List.null\n                                  xi) <\\<lambda>r.\n    list_assn A x xi *\n    (\\<exists>\\<^sub>Axa.\n        \\<up> ((r, xa) \\<in> bool_rel) *\n        \\<up> (RETURN xa \\<le> RETURN (List.null x)))>\\<^sub>t", "subgoal for l li"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l ::\\<^sub>i TYPE('b list);\n     nofail (RETURN (List.null l))\\<rbrakk>\n    \\<Longrightarrow> <list_assn A l\n                        li> return\n                             (List.null\n                               li) <\\<lambda>r.\n list_assn A l li *\n (\\<exists>\\<^sub>Ax.\n     \\<up> ((r, x) \\<in> bool_rel) *\n     \\<up> (RETURN x \\<le> RETURN (List.null l)))>\\<^sub>t", "by (cases l; cases li; sep_auto simp: List.null_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "sepref_decl_impl lmso_is_empty: list_null_hnr uses lmso_is_empty_aref"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_impl lmso_insert: hn_Cons[to_hfref] uses lmso_insert_aref"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "(* As parametricity heuristics of sepref_decl_impl fails here,\n    we use FCOMP and some dummy-lemma to still get the automation benefits of \n    sepref_decl_impl. *)"], ["", "context notes [simp] = in_br_conv and [split] = list.splits begin"], ["", "text \\<open>Dummy lemma, to exloit \\<open>sepref_decl_impl\\<close> automation without parametricity stuff.\\<close>"], ["", "private"], ["", "lemma op_mset_pick_dummy_param: \"(op_mset_pick, op_mset_pick) \\<in> Id \\<rightarrow>\\<^sub>f \\<langle>Id\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (op_mset_pick, op_mset_pick)\n    \\<in> Id \\<rightarrow>\\<^sub>f \\<langle>Id\\<rangle>nres_rel", "by (auto intro!: frefI nres_relI)"], ["", "sepref_decl_impl lmso_pick: hd_tl_hnr[FCOMP lmso_pick_aref] uses op_mset_pick_dummy_param"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. x \\<noteq> {#}, \\<lambda>x. x \\<noteq> {#})\n    \\<in> Id \\<rightarrow> bool_rel", "by simp"], ["", "end"], ["", "end"]]}