{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/benchmarks/Dijkstra/isabelle/Dijkstra_Benchmark.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemma nat_dijkstra_imp_eq: \"nat_dijkstra_imp = dijkstra_imp\""], "translations": [["", "lemma nat_dijkstra_imp_eq: \"nat_dijkstra_imp = dijkstra_imp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_dijkstra_imp = dijkstra_imp", "unfolding dijkstra_imp_def[abs_def] nat_dijkstra_imp_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>N ai bi.\n        nodes_impl ai \\<bind>\n        (\\<lambda>x.\n            hm_empty_op_impl N \\<bind>\n            (\\<lambda>xa.\n                imp_nfoldli x (\\<lambda>\\<sigma>. return True)\n                 (\\<lambda>xb.\n                     hm_upd_op_impl N (\\<lambda>x. x) xb infty.Infty)\n                 xa \\<bind>\n                (\\<lambda>x.\n                    hm_upd_op_impl N (\\<lambda>x. x) bi (Num 0) x \\<bind>\n                    (\\<lambda>x.\n                        iam_new \\<bind>\n                        (\\<lambda>xa.\n                            Array_Map_Impl.iam_update bi ([], 0) xa \\<bind>\n                            (\\<lambda>xa.\n                                heap_WHILET\n                                 (\\<lambda>(a1, a2).\n                                     hm_is_empty_op_impl a1 \\<bind>\n                                     (\\<lambda>x'a. return (\\<not> x'a)))\n                                 (\\<lambda>s.\n                                     (case s of\n(a1, a2) \\<Rightarrow>\n  hm_pop_min_op_impl (\\<lambda>x. x) a1 \\<bind>\n  (\\<lambda>x.\n      return\n       (case case x of ((a1b, a2b), a2a) \\<Rightarrow> (a1b, a2b, a2a) of\n        (a1a, a1b, a2b) \\<Rightarrow> (a1a, a1b, a2b, a2)))) \\<bind>\n                                     (\\<lambda>(a1, a1a, a1b, a2b).\n   Array_Map_Impl.iam_lookup a1 a2b \\<bind>\n   (\\<lambda>x.\n       succi ai a1 \\<bind>\n       (\\<lambda>x'e.\n           imp_nfoldli x'e (\\<lambda>\\<sigma>. return True)\n            (\\<lambda>xg \\<sigma>.\n                case xg of\n                (a1c, a2c) \\<Rightarrow>\n                  case \\<sigma> of\n                  (a1d, a2d) \\<Rightarrow>\n                    infty_plus_impl (return \\<circ>\\<circ> (+)) a1a\n                     (Num a1c) \\<bind>\n                    (\\<lambda>xa.\n                        Array_Map_Impl.iam_lookup a2c a2d \\<bind>\n                        (\\<lambda>xaa.\n                            infty_less_impl (return \\<circ>\\<circ> (<)) xa\n                             (mpath_weight' xaa) \\<bind>\n                            (\\<lambda>x'h.\n                                if x'h\n                                then infty_plus_impl\n(return \\<circ>\\<circ> (+)) a1a (Num a1c) \\<bind>\n                                     (\\<lambda>xa.\n   hm_upd_op_impl N (\\<lambda>x. x) a2c xa a1d \\<bind>\n   (\\<lambda>x'i.\n       Array_Map_Impl.iam_update a2c\n        (op_list_prepend (a1, a1c, a2c) (the (mpath' x)),\n         Weight.val a1a + a1c)\n        a2d \\<bind>\n       (\\<lambda>x'j. return (x'i, x'j))))\n                                else return (a1d, a2d)))))\n            (a1b, a2b)))))\n                                 (x, xa) \\<bind>\n                                (\\<lambda>(a1, y). return y)))))))) =\n    (\\<lambda>N ai bi.\n        nodes_impl ai \\<bind>\n        (\\<lambda>x.\n            hm_empty_op_impl N \\<bind>\n            (\\<lambda>xa.\n                imp_nfoldli x (\\<lambda>\\<sigma>. return True)\n                 (\\<lambda>xb.\n                     hm_upd_op_impl N (\\<lambda>x. x) xb infty.Infty)\n                 xa \\<bind>\n                (\\<lambda>x.\n                    hm_upd_op_impl N (\\<lambda>x. x) bi (Num 0) x \\<bind>\n                    (\\<lambda>x.\n                        iam_new \\<bind>\n                        (\\<lambda>xa.\n                            Array_Map_Impl.iam_update bi ([], 0) xa \\<bind>\n                            (\\<lambda>xa.\n                                heap_WHILET\n                                 (\\<lambda>(a1, a2).\n                                     hm_is_empty_op_impl a1 \\<bind>\n                                     (\\<lambda>x'a. return (\\<not> x'a)))\n                                 (\\<lambda>s.\n                                     (case s of\n(a1, a2) \\<Rightarrow>\n  hm_pop_min_op_impl (\\<lambda>x. x) a1 \\<bind>\n  (\\<lambda>x.\n      return\n       (case case x of ((a1b, a2b), a2a) \\<Rightarrow> (a1b, a2b, a2a) of\n        (a1a, a1b, a2b) \\<Rightarrow> (a1a, a1b, a2b, a2)))) \\<bind>\n                                     (\\<lambda>(a1, a1a, a1b, a2b).\n   Array_Map_Impl.iam_lookup a1 a2b \\<bind>\n   (\\<lambda>x.\n       succi ai a1 \\<bind>\n       (\\<lambda>x'e.\n           imp_nfoldli x'e (\\<lambda>\\<sigma>. return True)\n            (\\<lambda>xg \\<sigma>.\n                case xg of\n                (a1c, a2c) \\<Rightarrow>\n                  case \\<sigma> of\n                  (a1d, a2d) \\<Rightarrow>\n                    infty_plus_impl (return \\<circ>\\<circ> (+)) a1a\n                     (Num a1c) \\<bind>\n                    (\\<lambda>xa.\n                        Array_Map_Impl.iam_lookup a2c a2d \\<bind>\n                        (\\<lambda>xaa.\n                            infty_less_impl (return \\<circ>\\<circ> (<)) xa\n                             (mpath_weight' xaa) \\<bind>\n                            (\\<lambda>x'h.\n                                if x'h\n                                then infty_plus_impl\n(return \\<circ>\\<circ> (+)) a1a (Num a1c) \\<bind>\n                                     (\\<lambda>xa.\n   hm_upd_op_impl N (\\<lambda>x. x) a2c xa a1d \\<bind>\n   (\\<lambda>x'i.\n       Array_Map_Impl.iam_update a2c\n        (op_list_prepend (a1, a1c, a2c) (the (mpath' x)),\n         Weight.val a1a + a1c)\n        a2d \\<bind>\n       (\\<lambda>x'j. return (x'i, x'j))))\n                                else return (a1d, a2d)))))\n            (a1b, a2b)))))\n                                 (x, xa) \\<bind>\n                                (\\<lambda>(a1, y). return y))))))))", "by simp"], ["", "(*definition nat_dijkstra_imp \n  :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat graph_impl \\<Rightarrow> ((nat \\<times> nat \\<times> nat) list \\<times> nat) option Heap.array Heap\"\n  where\n  \"nat_dijkstra_imp \\<equiv> dijkstra_imp\"\n*)"], ["", "definition \"nat_cr_graph_fun nn es \\<equiv> hlg_from_list_nat ([0..<nn], es)\""], ["", "export_code \n  integer_of_nat nat_of_integer\n\n  ran_graph\n\n  nat_cr_graph_fun nat_dijkstra \n\n  nat_cr_graph_imp nat_dijkstra_imp \n  in SML_imp module_name Dijkstra\n  file \\<open>dijkstra_export.sml\\<close>"], ["", "end"]]}