{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/Sepref_Foreach.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemma FOREACH_oci_to_monadic:\n  \"FOREACHoci R \\<Phi> S c f \\<sigma>0 = monadic_FOREACH R \\<Phi> S (\\<lambda>\\<sigma>. RETURN (c \\<sigma>)) f \\<sigma>0\"", "lemma monadic_nfoldli_eq:\n  \"monadic_nfoldli l c f s = (\n    case l of \n      [] \\<Rightarrow> RETURN s \n    | x#ls \\<Rightarrow> do {\n        b\\<leftarrow>c s; \n        if b then f x s \\<bind> monadic_nfoldli ls c f else RETURN s\n      }\n  )\"", "lemma monadic_nfoldli_simp[simp]:\n  \"monadic_nfoldli [] c f s = RETURN s\"\n  \"monadic_nfoldli (x#ls) c f s = do {\n    b\\<leftarrow>c s;\n    if b then f x s \\<bind> monadic_nfoldli ls c f else RETURN s\n  }\"", "lemma nfoldli_to_monadic:\n  \"nfoldli l c f = monadic_nfoldli l (\\<lambda>x. RETURN (c x)) f\"", "lemma nfoldli_alt_eq:\n  \"nfoldli_alt l c f s = (\n    case l of \n      [] \\<Rightarrow> RETURN s \n    | x#ls \\<Rightarrow> do {let b=c s; if b then f x s \\<bind> nfoldli_alt ls c f else RETURN s}\n  )\"", "lemma nfoldli_alt_simp[simp]:\n  \"nfoldli_alt [] c f s = RETURN s\"\n  \"nfoldli_alt (x#ls) c f s = do {\n    let b = c s;\n    if b then f x s \\<bind> nfoldli_alt ls c f else RETURN s\n  }\"", "lemma nfoldli_alt:\n  \"(nfoldli::'a list \\<Rightarrow> ('b \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> 'b \\<Rightarrow> 'b nres) \\<Rightarrow> 'b \\<Rightarrow> 'b nres)\n  = nfoldli_alt\"", "lemma monadic_nfoldli_rec:\n  \"monadic_nfoldli x' c f \\<sigma>\n          \\<le>\\<Down>Id (REC\\<^sub>T\n             (\\<lambda>W (xs, \\<sigma>).\n                 ASSERT (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n                 (\\<lambda>_. if xs = [] then RETURN (xs, \\<sigma>)\n                      else c \\<sigma> \\<bind>\n                           (\\<lambda>b. if b then FOREACH_body f (xs, \\<sigma>) \\<bind> W\n                                else RETURN (xs, \\<sigma>))))\n             (x', \\<sigma>) \\<bind>\n            (\\<lambda>(_, y). RETURN y))\"", "lemma monadic_nfoldli_arities[sepref_monadify_arity]:\n  \"monadic_nfoldli \\<equiv> \\<lambda>\\<^sub>2s c f \\<sigma>. SP (monadic_nfoldli)$s$(\\<lambda>\\<^sub>2x. c$x)$(\\<lambda>\\<^sub>2x \\<sigma>. f$x$\\<sigma>)$\\<sigma>\"", "lemma monadic_nfoldli_comb[sepref_monadify_comb]:\n  \"\\<And>s c f \\<sigma>. (monadic_nfoldli)$s$c$f$\\<sigma> \\<equiv> \n    Refine_Basic.bind$(EVAL$s)$(\\<lambda>\\<^sub>2s. Refine_Basic.bind$(EVAL$\\<sigma>)$(\\<lambda>\\<^sub>2\\<sigma>. \n      SP (monadic_nfoldli)$s$c$f$\\<sigma>\n    ))\"", "lemma list_rel_congD: \n  assumes A: \"(li,l)\\<in>\\<langle>S\\<rangle>list_rel\" \n  shows \"(li,l)\\<in>\\<langle>S\\<inter>(set li\\<times>set l)\\<rangle>list_rel\"", "lemma monadic_nfoldli_refine[refine]:\n  assumes L: \"(li, l) \\<in> \\<langle>S\\<rangle>list_rel\"\n    and  [simp]: \"(si, s) \\<in> R\"\n    and CR[refine]: \"\\<And>si s. (si,s)\\<in>R \\<Longrightarrow> ci si \\<le>\\<Down>bool_rel (c s)\"\n    and [refine]: \"\\<And>xi x si s. \\<lbrakk> (xi,x)\\<in>S; x\\<in>set l; (si,s)\\<in>R; inres (c s) True \\<rbrakk> \\<Longrightarrow> fi xi si \\<le> \\<Down>R (f x s)\"\n  shows \"monadic_nfoldli li ci fi si \\<le> \\<Down> R (monadic_nfoldli l c f s)\"", "lemma monadic_FOREACH_itsl:\n  fixes R I tsl\n  shows \n    \"do { l \\<leftarrow> it_to_sorted_list R s; monadic_nfoldli l c f \\<sigma> } \n     \\<le> monadic_FOREACH R I s c f \\<sigma>\"", "lemma FOREACHoci_itsl:\n  fixes R I tsl\n  shows \n    \"do { l \\<leftarrow> it_to_sorted_list R s; nfoldli l c f \\<sigma> } \n     \\<le> FOREACHoci R I s c f \\<sigma>\"", "lemma [def_pat_rules]:\n  \"FOREACHc \\<equiv> PR_CONST (FOREACHoci (\\<lambda>_ _. True) (\\<lambda>_ _. True))\"\n  \"FOREACHci$I \\<equiv> PR_CONST (FOREACHoci (\\<lambda>_ _. True) I)\"\n  \"FOREACHi$I \\<equiv> \\<lambda>\\<^sub>2s. PR_CONST (FOREACHoci (\\<lambda>_ _. True) I)$s$(\\<lambda>\\<^sub>2x. True)\"\n  \"FOREACH \\<equiv> FOREACHi$(\\<lambda>\\<^sub>2_ _. True)\"", "lemma id_FOREACHoci[id_rules]: \"PR_CONST (FOREACHoci R I) ::\\<^sub>i \n  TYPE('c set \\<Rightarrow> ('d \\<Rightarrow> bool) \\<Rightarrow> ('c \\<Rightarrow> 'd \\<Rightarrow> 'd nres) \\<Rightarrow> 'd \\<Rightarrow> 'd nres)\"", "lemma FOREACH_arities[sepref_monadify_arity]:\n  (*\"FOREACHc \\<equiv> FOREACHoci$(\\<lambda>\\<^sub>2_ _. True)$(\\<lambda>\\<^sub>2_ _. True)\"\n  \"FOREACHci \\<equiv> FOREACHoci$(\\<lambda>\\<^sub>2_ _. True)\"\n  \"FOREACHi \\<equiv> \\<lambda>\\<^sub>2I s. FOREACHci$I$s$(\\<lambda>\\<^sub>2x. True)\"\n  \"FOREACH \\<equiv> FOREACHi$(\\<lambda>\\<^sub>2_ _. True)\"*)\n  \"PR_CONST (FOREACHoci R I) \\<equiv> \\<lambda>\\<^sub>2s c f \\<sigma>. SP (PR_CONST (FOREACHoci R I))$s$(\\<lambda>\\<^sub>2x. c$x)$(\\<lambda>\\<^sub>2x \\<sigma>. f$x$\\<sigma>)$\\<sigma>\"", "lemma FOREACHoci_comb[sepref_monadify_comb]:\n  \"\\<And>s c f \\<sigma>. (PR_CONST (FOREACHoci R I))$s$(\\<lambda>\\<^sub>2x. c x)$f$\\<sigma> \\<equiv> \n    Refine_Basic.bind$(EVAL$s)$(\\<lambda>\\<^sub>2s. Refine_Basic.bind$(EVAL$\\<sigma>)$(\\<lambda>\\<^sub>2\\<sigma>. \n      SP (PR_CONST (monadic_FOREACH R I))$s$(\\<lambda>\\<^sub>2x. (EVAL$(c x)))$f$\\<sigma>\n    ))\"", "lemma imp_nfoldli_simps[simp,code]:\n  \"imp_nfoldli [] c f s = return s\"\n  \"imp_nfoldli (x#ls) c f s = (do {\n    b \\<leftarrow> c s;\n    if b then do { \n      s'\\<leftarrow>f x s; \n      imp_nfoldli ls c f s'\n    } else return s\n  })\"", "lemma monadic_nfoldli_refine_aux:\n  assumes c_ref: \"\\<And>s s'. hn_refine \n    (\\<Gamma> * hn_ctxt Rs s' s) \n    (c s) \n    (\\<Gamma> * hn_ctxt Rs s' s) \n    bool_assn\n    (c' s')\"\n  assumes f_ref: \"\\<And>x x' s s'. hn_refine \n    (\\<Gamma> * hn_ctxt Rl x' x * hn_ctxt Rs s' s)\n    (f x s)\n    (\\<Gamma> * hn_invalid Rl x' x * hn_invalid Rs s' s) Rs\n    (f' x' s')\"\n\n  shows \"hn_refine \n    (\\<Gamma> * hn_ctxt (list_assn Rl) l' l * hn_ctxt Rs s' s) \n    (imp_nfoldli l c f s) \n    (\\<Gamma> * hn_invalid (list_assn Rl) l' l * hn_invalid Rs s' s) Rs\n    (monadic_nfoldli l' c' f' s')\"", "lemma hn_monadic_nfoldli:\n  assumes FR: \"P \\<Longrightarrow>\\<^sub>t \\<Gamma> * hn_ctxt (list_assn Rl) l' l * hn_ctxt Rs s' s\"\n  assumes c_ref: \"\\<And>s s'. hn_refine \n    (\\<Gamma> * hn_ctxt Rs s' s) \n    (c s) \n    (\\<Gamma> * hn_ctxt Rs s' s)\n    bool_assn \n    (c'$s')\"\n  assumes f_ref: \"\\<And>x x' s s'. hn_refine \n    (\\<Gamma> * hn_ctxt Rl x' x * hn_ctxt Rs s' s)\n    (f x s)\n    (\\<Gamma> * hn_invalid Rl x' x * hn_invalid Rs s' s) Rs\n    (f'$x'$s')\"\n  shows \"hn_refine \n    P \n    (imp_nfoldli l c f s) \n    (\\<Gamma> * hn_invalid (list_assn Rl) l' l * hn_invalid Rs s' s)\n    Rs\n    (monadic_nfoldli$l'$c'$f'$s')\n    \"", "lemma heap_fixp_mono[partial_function_mono]:\n  assumes [partial_function_mono]: \n    \"\\<And>x d. mono_Heap (\\<lambda>xa. B x xa d)\"\n    \"\\<And>Z xa. mono_Heap (\\<lambda>a. B a Z xa)\" \n  shows \"mono_Heap (\\<lambda>x. heap.fixp_fun (\\<lambda>D \\<sigma>. B x D \\<sigma>) \\<sigma>)\"", "lemma imp_nfoldli_mono[partial_function_mono]:\n  assumes [partial_function_mono]: \"\\<And>x \\<sigma>. mono_Heap (\\<lambda>fa. f fa x \\<sigma>)\"\n  shows \"mono_Heap (\\<lambda>x. imp_nfoldli l c (f x) \\<sigma>)\"", "lemma imp_foreach_mono[partial_function_mono]:\n  assumes [partial_function_mono]: \"\\<And>x \\<sigma>. mono_Heap (\\<lambda>fa. f fa x \\<sigma>)\"\n  shows \"mono_Heap (\\<lambda>x. imp_foreach tsl l c (f x) \\<sigma>)\"", "lemmas [sepref_opt_simps] = imp_foreach_def", "lemma IS_TO_SORTED_LISTI:\n  assumes \"(tsl,PR_CONST (it_to_sorted_list \\<Omega>)) \\<in> (Rs)\\<^sup>k \\<rightarrow>\\<^sub>a list_assn Rk\"\n  shows \"IS_TO_SORTED_LIST \\<Omega> Rs Rk tsl\"", "lemma hn_monadic_FOREACH[sepref_comb_rules]:\n  assumes \"INDEP Rk\" \"INDEP Rs\" \"INDEP R\\<sigma>\"\n  assumes FR: \"P \\<Longrightarrow>\\<^sub>t \\<Gamma> * hn_ctxt Rs s' s * hn_ctxt R\\<sigma> \\<sigma>' \\<sigma>\"\n  assumes STL: \"GEN_ALGO tsl (IS_TO_SORTED_LIST ordR Rs Rk)\"\n  assumes c_ref: \"\\<And>\\<sigma> \\<sigma>'. hn_refine \n    (\\<Gamma> * hn_ctxt Rs s' s * hn_ctxt R\\<sigma> \\<sigma>' \\<sigma>) \n    (c \\<sigma>) \n    (\\<Gamma>c \\<sigma>' \\<sigma>) \n    bool_assn \n    (c' \\<sigma>')\"\n  assumes C_FR: \n    \"\\<And>\\<sigma>' \\<sigma>. TERM monadic_FOREACH \\<Longrightarrow> \n      \\<Gamma>c \\<sigma>' \\<sigma> \\<Longrightarrow>\\<^sub>t \\<Gamma> * hn_ctxt Rs s' s * hn_ctxt R\\<sigma> \\<sigma>' \\<sigma>\"\n\n  assumes f_ref: \"\\<And>x' x \\<sigma>' \\<sigma>. hn_refine \n    (\\<Gamma> * hn_ctxt Rs s' s * hn_ctxt Rk x' x * hn_ctxt R\\<sigma> \\<sigma>' \\<sigma>)\n    (f x \\<sigma>)\n    (\\<Gamma>f x' x \\<sigma>' \\<sigma>) R\\<sigma>\n    (f' x' \\<sigma>')\"\n  assumes F_FR: \"\\<And>x' x \\<sigma>' \\<sigma>. TERM monadic_FOREACH \\<Longrightarrow> \\<Gamma>f x' x \\<sigma>' \\<sigma> \\<Longrightarrow>\\<^sub>t \n    \\<Gamma> * hn_ctxt Rs s' s * hn_ctxt Pfx x' x * hn_ctxt Pf\\<sigma> \\<sigma>' \\<sigma>\"\n\n  shows \"hn_refine \n    P \n    (imp_foreach tsl s c f \\<sigma>) \n    (\\<Gamma> * hn_ctxt Rs s' s * hn_invalid R\\<sigma> \\<sigma>' \\<sigma>)\n    R\\<sigma>\n    ((PR_CONST (monadic_FOREACH ordR I))\n      $s'$(\\<lambda>\\<^sub>2\\<sigma>'. c' \\<sigma>')$(\\<lambda>\\<^sub>2x' \\<sigma>'. f' x' \\<sigma>')$\\<sigma>'\n    )\"", "lemma monadic_nfoldli_assert_aux:\n  assumes \"set l \\<subseteq> S\"\n  shows \"monadic_nfoldli l c (\\<lambda>x s. ASSERT (x\\<in>S)\\<then>f x s) s = monadic_nfoldli l c f s\"", "lemmas monadic_nfoldli_assert = monadic_nfoldli_assert_aux[OF order_refl]", "lemma nfoldli_arities[sepref_monadify_arity]:\n  \"nfoldli \\<equiv> \\<lambda>\\<^sub>2s c f \\<sigma>. SP (nfoldli)$s$(\\<lambda>\\<^sub>2x. c$x)$(\\<lambda>\\<^sub>2x \\<sigma>. f$x$\\<sigma>)$\\<sigma>\"", "lemma nfoldli_comb[sepref_monadify_comb]:\n  \"\\<And>s c f \\<sigma>. (nfoldli)$s$(\\<lambda>\\<^sub>2x. c x)$f$\\<sigma> \\<equiv> \n    Refine_Basic.bind$(EVAL$s)$(\\<lambda>\\<^sub>2s. Refine_Basic.bind$(EVAL$\\<sigma>)$(\\<lambda>\\<^sub>2\\<sigma>. \n      SP (monadic_nfoldli)$s$(\\<lambda>\\<^sub>2x. (EVAL$(c x)))$f$\\<sigma>\n    ))\"", "lemma monadic_nfoldli_refine_aux':\n  assumes SS: \"set l' \\<subseteq> S\"\n  assumes c_ref: \"\\<And>s s'. hn_refine \n    (\\<Gamma> * hn_ctxt Rs s' s) \n    (c s) \n    (\\<Gamma> * hn_ctxt Rs s' s) \n    bool_assn\n    (c' s')\"\n  assumes f_ref: \"\\<And>x x' s s'. \\<lbrakk>x' \\<in> S\\<rbrakk> \\<Longrightarrow> hn_refine \n    (\\<Gamma> * hn_ctxt Rl x' x * hn_ctxt Rs s' s)\n    (f x s)\n    (\\<Gamma> * hn_ctxt Rl' x' x * hn_invalid Rs s' s) Rs\n    (f' x' s')\"\n\n  assumes merge[sepref_frame_merge_rules]: \"\\<And>x x'. hn_ctxt Rl' x' x \\<or>\\<^sub>A hn_ctxt Rl x' x \\<Longrightarrow>\\<^sub>t hn_ctxt Rl'' x' x\"\n  notes [sepref_frame_merge_rules] = merge_sat2[OF merge]\n\n  shows \"hn_refine \n    (\\<Gamma> * hn_ctxt (list_assn Rl) l' l * hn_ctxt Rs s' s) \n    (imp_nfoldli l c f s) \n    (\\<Gamma> * hn_ctxt (list_assn Rl'') l' l * hn_invalid Rs s' s) Rs\n    (monadic_nfoldli l' c' f' s')\"", "lemma hn_monadic_nfoldli_rl'[sepref_comb_rules]:\n  assumes \"INDEP Rk\" \"INDEP R\\<sigma>\"\n  assumes FR: \"P \\<Longrightarrow>\\<^sub>t \\<Gamma> * hn_ctxt (list_assn Rk) s' s * hn_ctxt R\\<sigma> \\<sigma>' \\<sigma>\"\n  assumes c_ref: \"\\<And>\\<sigma> \\<sigma>'. hn_refine \n    (\\<Gamma> * hn_ctxt R\\<sigma> \\<sigma>' \\<sigma>) \n    (c \\<sigma>) \n    (\\<Gamma>c \\<sigma>' \\<sigma>) \n    bool_assn \n    (c' \\<sigma>')\"\n  assumes C_FR: \n    \"\\<And>\\<sigma>' \\<sigma>. TERM monadic_nfoldli \\<Longrightarrow> \n      \\<Gamma>c \\<sigma>' \\<sigma> \\<Longrightarrow>\\<^sub>t \\<Gamma> * hn_ctxt R\\<sigma> \\<sigma>' \\<sigma>\"\n\n  assumes f_ref: \"\\<And>x' x \\<sigma>' \\<sigma>. \\<lbrakk>x'\\<in>set s'\\<rbrakk> \\<Longrightarrow> hn_refine \n    (\\<Gamma> * hn_ctxt Rk x' x * hn_ctxt R\\<sigma> \\<sigma>' \\<sigma>)\n    (f x \\<sigma>)\n    (\\<Gamma>f x' x \\<sigma>' \\<sigma>) R\\<sigma>\n    (f' x' \\<sigma>')\"\n  assumes F_FR: \"\\<And>x' x \\<sigma>' \\<sigma>. TERM monadic_nfoldli \\<Longrightarrow> \\<Gamma>f x' x \\<sigma>' \\<sigma> \\<Longrightarrow>\\<^sub>t \n    \\<Gamma> * hn_ctxt Rk' x' x * hn_ctxt Pf\\<sigma> \\<sigma>' \\<sigma>\"\n\n  assumes MERGE: \"\\<And>x x'. hn_ctxt Rk' x' x \\<or>\\<^sub>A hn_ctxt Rk x' x \\<Longrightarrow>\\<^sub>t hn_ctxt Rk'' x' x\"  \n\n  shows \"hn_refine \n    P \n    (imp_nfoldli s c f \\<sigma>) \n    (\\<Gamma> * hn_ctxt (list_assn Rk'') s' s * hn_invalid R\\<sigma> \\<sigma>' \\<sigma>)\n    R\\<sigma>\n    ((monadic_nfoldli)\n      $s'$(\\<lambda>\\<^sub>2\\<sigma>'. c' \\<sigma>')$(\\<lambda>\\<^sub>2x' \\<sigma>'. f' x' \\<sigma>')$\\<sigma>'\n    )\"", "lemma nfoldli_assert:\n  assumes \"set l \\<subseteq> S\"\n  shows \"nfoldli l c (\\<lambda> x s. ASSERT (x \\<in> S) \\<then> f x s) s = nfoldli l c f s\"", "lemmas nfoldli_assert' = nfoldli_assert[OF order.refl]", "lemma fold_eq_nfoldli:\n  \"RETURN (fold f l s) = nfoldli l (\\<lambda>_. True) (\\<lambda>x s. RETURN (f x s)) s\"", "lemma fold_eq_nfoldli_assert:\n  \"RETURN (fold f l s) = nfoldli l (\\<lambda>_. True) (\\<lambda>x s. ASSERT (x\\<in>set l) \\<then> RETURN (f x s)) s\"", "lemma fold_arity[sepref_monadify_arity]: \"fold \\<equiv> \\<lambda>\\<^sub>2f l s. SP fold$(\\<lambda>\\<^sub>2x s. f$x$s)$l$s\"", "lemma monadify_plain_fold[sepref_monadify_comb]: \n  \"EVAL$(fold$(\\<lambda>\\<^sub>2x s. f x s)$l$s) \\<equiv> (\\<bind>)$(EVAL$l)$(\\<lambda>\\<^sub>2l. (\\<bind>)$(EVAL$s)$(\\<lambda>\\<^sub>2s. nfoldli$l$(\\<lambda>\\<^sub>2_. True)$(\\<lambda>\\<^sub>2x s. EVAL$(f x s))$s))\"", "lemma monadify_plain_fold_old_rl: \n  \"EVAL$(fold$(\\<lambda>\\<^sub>2x s. f x s)$l$s) \\<equiv> (\\<bind>)$(EVAL$l)$(\\<lambda>\\<^sub>2l. (\\<bind>)$(EVAL$s)$(\\<lambda>\\<^sub>2s. nfoldli$l$(\\<lambda>\\<^sub>2_. True)$(\\<lambda>\\<^sub>2x s. PR_CONST (op_ASSERT_bind (x\\<in>set l))$(EVAL$(f x s)))$s))\"", "lemma foldli_eq_nfoldli:\n  \"RETURN (foldli l c f s) = nfoldli l c (\\<lambda>x s. RETURN (f x s)) s\"", "lemma foldli_arities[sepref_monadify_arity]:\n  \"foldli \\<equiv> \\<lambda>\\<^sub>2s c f \\<sigma>. SP (foldli)$s$(\\<lambda>\\<^sub>2x. c$x)$(\\<lambda>\\<^sub>2x \\<sigma>. f$x$\\<sigma>)$\\<sigma>\"", "lemma monadify_plain_foldli[sepref_monadify_comb]: \n  \"EVAL$(foldli$l$c$(\\<lambda>\\<^sub>2x s. f x s)$s) \\<equiv>\n    (\\<bind>)$(EVAL$l)$\n     (\\<lambda>\\<^sub>2l. (\\<bind>)$(EVAL$s)$\n      (\\<lambda>\\<^sub>2s. nfoldli$l$c$(\\<lambda>\\<^sub>2x s. (EVAL$(f x s)))$s))\"", "lemma nfoldli_filter_deforestation: \n  \"nfoldli (filter P xs) c f s = nfoldli xs c (\\<lambda>x s. if P x then f x s else RETURN s) s\"", "lemma extend_list_of_filtered_set:\n  assumes [simp, intro!]: \"finite S\" \n    and A: \"distinct xs'\" \"set xs' = {x \\<in> S. P x}\"\n  obtains xs where \"xs' = filter P xs\" \"distinct xs\" \"set xs = S\"", "lemma FOREACHc_filter_deforestation:\n  assumes FIN[simp, intro!]: \"finite S\"\n  shows \"(FOREACHc {x\\<in>S. P x} c f s) \n    = FOREACHc S c (\\<lambda>x s. if P x then f x s else RETURN s) s\"", "lemma FOREACHc_filter_deforestation2:\n  assumes [simp]: \"distinct xs\"\n  shows \"(FOREACHc (set (filter P xs)) c f s) \n    = FOREACHc (set xs) c (\\<lambda>x s. if P x then f x s else RETURN s) s\"", "lemma [simp]:\n  \"i \\<ge> u \\<Longrightarrow> imp_for i u c f s = return s\"\n  \"i < u \\<Longrightarrow> imp_for i u c f s = do {ctn <- c s; if ctn then f i s \\<bind> imp_for (i + 1) u c f else return s}\"", "lemma imp_nfoldli_deforest[sepref_opt_simps]:\n  \"imp_nfoldli [l..<u] c = imp_for l u c\"", "lemma [simp]:\n  \"i \\<ge> u \\<Longrightarrow> imp_for' i u f s = return s\"\n  \"i < u \\<Longrightarrow> imp_for' i u f s = f i s \\<bind> imp_for' (i + 1) u f\"", "lemma imp_for_imp_for'[sepref_opt_simps]:\n  \"imp_for i u (\\<lambda> _. return True) = imp_for' i u\"", "lemma imp_nfoldli_deforest_down[sepref_opt_simps]:\n  \"imp_nfoldli (rev [l..<u]) c = \n    (\\<lambda>f s. if u\\<le>l then return s else imp_for_down l u c f s)\"", "lemma imp_for_down_no_cond[sepref_opt_simps]:\n  \"imp_for_down l u (\\<lambda>_. return True) = imp_for_down' l u\"", "lemma imp_for'_rule:\n  assumes LESS: \"l\\<le>u\"\n  assumes PRE: \"P \\<Longrightarrow>\\<^sub>A I l s\"\n  assumes STEP: \"\\<And>i s. \\<lbrakk> l\\<le>i; i<u \\<rbrakk> \\<Longrightarrow> <I i s> f i s <I (i+1)>\"\n  shows \"<P> imp_for' l u f s <I u>\"", "lemma fold_idx_conv: \"fold f l s = fold (\\<lambda>i. f (l!i)) [0..<length l] s\""], "translations": [["", "lemma FOREACH_oci_to_monadic:\n  \"FOREACHoci R \\<Phi> S c f \\<sigma>0 = monadic_FOREACH R \\<Phi> S (\\<lambda>\\<sigma>. RETURN (c \\<sigma>)) f \\<sigma>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>O\\<^sub>C\\<^bsup>R,\\<Phi>\\<^esup> S c f \\<sigma>0 =\n    monadic_FOREACH R \\<Phi> S (\\<lambda>\\<sigma>. RETURN (c \\<sigma>)) f\n     \\<sigma>0", "unfolding FOREACHoci_def monadic_FOREACH_def WHILEIT_def WHILEI_body_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (finite S) \\<bind>\n    (\\<lambda>_.\n        SPEC\n         (\\<lambda>xs.\n             distinct xs \\<and> S = set xs \\<and> sorted_wrt R xs) \\<bind>\n        (\\<lambda>xs.\n            REC\\<^sub>T\n             (\\<lambda>W s.\n                 if case s of\n                    (it, \\<sigma>) \\<Rightarrow>\n                      \\<exists>xs'.\n                         xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>\n                 then if FOREACH_cond c s then FOREACH_body f s \\<bind> W\n                      else RETURN s\n                 else FAIL)\n             (xs, \\<sigma>0) \\<bind>\n            (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>))) =\n    ASSERT (finite S) \\<bind>\n    (\\<lambda>_.\n        it_to_sorted_list R S \\<bind>\n        (\\<lambda>xs0.\n            REC\\<^sub>T\n             (\\<lambda>W (xs, \\<sigma>).\n                 ASSERT (FOREACH_inv xs0 \\<Phi> (xs, \\<sigma>)) \\<bind>\n                 (\\<lambda>_.\n                     if xs \\<noteq> []\n                     then RETURN (c \\<sigma>) \\<bind>\n                          (\\<lambda>b.\n                              if b\n                              then FOREACH_body f (xs, \\<sigma>) \\<bind> W\n                              else RETURN (xs, \\<sigma>))\n                     else RETURN (xs, \\<sigma>)))\n             (xs0, \\<sigma>0) \\<bind>\n            (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>)))", "unfolding it_to_sorted_list_def FOREACH_cond_def FOREACH_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (finite S) \\<bind>\n    (\\<lambda>_.\n        SPEC\n         (\\<lambda>xs.\n             distinct xs \\<and> S = set xs \\<and> sorted_wrt R xs) \\<bind>\n        (\\<lambda>xs.\n            REC\\<^sub>T\n             (\\<lambda>W s.\n                 if case s of\n                    (it, \\<sigma>) \\<Rightarrow>\n                      \\<exists>xs'.\n                         xs = xs' @ it \\<and> \\<Phi> (set it) \\<sigma>\n                 then if case s of\n                         (xs, \\<sigma>) \\<Rightarrow>\n                           xs \\<noteq> [] \\<and> c \\<sigma>\n                      then FOREACH_body f s \\<bind> W else RETURN s\n                 else FAIL)\n             (xs, \\<sigma>0) \\<bind>\n            (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>))) =\n    ASSERT (finite S) \\<bind>\n    (\\<lambda>_.\n        SPEC\n         (\\<lambda>l.\n             distinct l \\<and> S = set l \\<and> sorted_wrt R l) \\<bind>\n        (\\<lambda>xs0.\n            REC\\<^sub>T\n             (\\<lambda>W (xs, \\<sigma>).\n                 ASSERT\n                  (case (xs, \\<sigma>) of\n                   (it, \\<sigma>) \\<Rightarrow>\n                     \\<exists>xs'.\n                        xs0 = xs' @ it \\<and>\n                        \\<Phi> (set it) \\<sigma>) \\<bind>\n                 (\\<lambda>_.\n                     if xs \\<noteq> []\n                     then RETURN (c \\<sigma>) \\<bind>\n                          (\\<lambda>b.\n                              if b\n                              then FOREACH_body f (xs, \\<sigma>) \\<bind> W\n                              else RETURN (xs, \\<sigma>))\n                     else RETURN (xs, \\<sigma>)))\n             (xs0, \\<sigma>0) \\<bind>\n            (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (finite S) \\<bind>\n    (\\<lambda>_.\n        SPEC\n         (\\<lambda>xs.\n             distinct xs \\<and> S = set xs \\<and> sorted_wrt R xs) \\<bind>\n        (\\<lambda>xs.\n            REC\\<^sub>T\n             (\\<lambda>W s.\n                 if case s of\n                    (it, \\<sigma>) \\<Rightarrow>\n                      (\\<exists>xs'. xs = xs' @ it) \\<and>\n                      \\<Phi> (set it) \\<sigma>\n                 then if case s of\n                         (xs, \\<sigma>) \\<Rightarrow>\n                           xs \\<noteq> [] \\<and> c \\<sigma>\n                      then FOREACH_body f s \\<bind> W else RETURN s\n                 else FAIL)\n             (xs, \\<sigma>0) \\<bind>\n            (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>))) =\n    ASSERT (finite S) \\<bind>\n    (\\<lambda>_.\n        SPEC\n         (\\<lambda>l.\n             distinct l \\<and> S = set l \\<and> sorted_wrt R l) \\<bind>\n        (\\<lambda>xs0.\n            REC\\<^sub>T\n             (\\<lambda>W (xs, \\<sigma>).\n                 ASSERT\n                  ((\\<exists>xs'. xs0 = xs' @ xs) \\<and>\n                   \\<Phi> (set xs) \\<sigma>) \\<bind>\n                 (\\<lambda>_.\n                     if xs = [] then RETURN (xs, \\<sigma>)\n                     else RETURN (c \\<sigma>) \\<bind>\n                          (\\<lambda>b.\n                              if b\n                              then FOREACH_body f (xs, \\<sigma>) \\<bind> W\n                              else RETURN (xs, \\<sigma>))))\n             (xs0, \\<sigma>0) \\<bind>\n            (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>)))", "apply (fo_rule arg_cong[THEN cong] | rule refl ext)+"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>_ xs W s.\n       (if case s of\n           (it, \\<sigma>) \\<Rightarrow>\n             (\\<exists>xs'. xs = xs' @ it) \\<and> \\<Phi> (set it) \\<sigma>\n        then if case s of\n                (xs, \\<sigma>) \\<Rightarrow>\n                  xs \\<noteq> [] \\<and> c \\<sigma>\n             then FOREACH_body f s \\<bind> W else RETURN s\n        else FAIL) =\n       (case s of\n        (xsa, \\<sigma>) \\<Rightarrow>\n          ASSERT\n           ((\\<exists>xs'. xs = xs' @ xsa) \\<and>\n            \\<Phi> (set xsa) \\<sigma>) \\<bind>\n          (\\<lambda>_.\n              if xsa = [] then RETURN (xsa, \\<sigma>)\n              else RETURN (c \\<sigma>) \\<bind>\n                   (\\<lambda>b.\n                       if b then FOREACH_body f (xsa, \\<sigma>) \\<bind> W\n                       else RETURN (xsa, \\<sigma>))))\n 2. \\<And>_ xs. (xs, \\<sigma>0) = (xs, \\<sigma>0)\n 3. \\<And>_ xs.\n       (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>) =\n       (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>)", "apply (simp split: prod.split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>_ xs. (xs, \\<sigma>0) = (xs, \\<sigma>0)\n 2. \\<And>_ xs.\n       (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>) =\n       (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>)", "apply (rule refl)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Next, we define a characterization w.r.t. \\<open>nfoldli\\<close>\\<close>"], ["", "definition \"monadic_nfoldli l c f s \\<equiv> RECT (\\<lambda>D (l,s). case l of \n    [] \\<Rightarrow> RETURN s\n  | x#ls \\<Rightarrow> do {\n      b \\<leftarrow> c s;\n      if b then do { s'\\<leftarrow>f x s; D (ls,s')} else RETURN s\n    }\n  ) (l,s)\""], ["", "lemma monadic_nfoldli_eq:\n  \"monadic_nfoldli l c f s = (\n    case l of \n      [] \\<Rightarrow> RETURN s \n    | x#ls \\<Rightarrow> do {\n        b\\<leftarrow>c s; \n        if b then f x s \\<bind> monadic_nfoldli ls c f else RETURN s\n      }\n  )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monadic_nfoldli l c f s =\n    (case l of [] \\<Rightarrow> RETURN s\n     | x # ls \\<Rightarrow>\n         c s \\<bind>\n         (\\<lambda>b.\n             if b then f x s \\<bind> monadic_nfoldli ls c f else RETURN s))", "apply (subst monadic_nfoldli_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. REC\\<^sub>T\n     (\\<lambda>D (l, s).\n         case l of [] \\<Rightarrow> RETURN s\n         | x # ls \\<Rightarrow>\n             c s \\<bind>\n             (\\<lambda>b.\n                 if b then f x s \\<bind> (\\<lambda>s'. D (ls, s'))\n                 else RETURN s))\n     (l, s) =\n    (case l of [] \\<Rightarrow> RETURN s\n     | x # ls \\<Rightarrow>\n         c s \\<bind>\n         (\\<lambda>b.\n             if b then f x s \\<bind> monadic_nfoldli ls c f else RETURN s))", "apply (subst RECT_unfold)"], ["proof (prove)\ngoal (2 subgoals):\n 1. trimono\n     (\\<lambda>D (l, s).\n         case l of [] \\<Rightarrow> RETURN s\n         | x # ls \\<Rightarrow>\n             c s \\<bind>\n             (\\<lambda>b.\n                 if b then f x s \\<bind> (\\<lambda>s'. D (ls, s'))\n                 else RETURN s))\n 2. (case (l, s) of ([], s) \\<Rightarrow> RETURN s\n     | (x # ls, s) \\<Rightarrow>\n         c s \\<bind>\n         (\\<lambda>b.\n             if b\n             then f x s \\<bind>\n                  (\\<lambda>s'.\n                      REC\\<^sub>T\n                       (\\<lambda>D (l, s).\n                           case l of [] \\<Rightarrow> RETURN s\n                           | x # ls \\<Rightarrow>\n                               c s \\<bind>\n                               (\\<lambda>b.\n                                   if b\n                                   then f x s \\<bind>\n  (\\<lambda>s'. D (ls, s'))\n                                   else RETURN s))\n                       (ls, s'))\n             else RETURN s)) =\n    (case l of [] \\<Rightarrow> RETURN s\n     | x # ls \\<Rightarrow>\n         c s \\<bind>\n         (\\<lambda>b.\n             if b then f x s \\<bind> monadic_nfoldli ls c f else RETURN s))", "apply (tagged_solver)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (l, s) of ([], s) \\<Rightarrow> RETURN s\n     | (x # ls, s) \\<Rightarrow>\n         c s \\<bind>\n         (\\<lambda>b.\n             if b\n             then f x s \\<bind>\n                  (\\<lambda>s'.\n                      REC\\<^sub>T\n                       (\\<lambda>D (l, s).\n                           case l of [] \\<Rightarrow> RETURN s\n                           | x # ls \\<Rightarrow>\n                               c s \\<bind>\n                               (\\<lambda>b.\n                                   if b\n                                   then f x s \\<bind>\n  (\\<lambda>s'. D (ls, s'))\n                                   else RETURN s))\n                       (ls, s'))\n             else RETURN s)) =\n    (case l of [] \\<Rightarrow> RETURN s\n     | x # ls \\<Rightarrow>\n         c s \\<bind>\n         (\\<lambda>b.\n             if b then f x s \\<bind> monadic_nfoldli ls c f else RETURN s))", "apply (subst monadic_nfoldli_def[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (l, s) of ([], s) \\<Rightarrow> RETURN s\n     | (x # ls, s) \\<Rightarrow>\n         c s \\<bind>\n         (\\<lambda>b.\n             if b then f x s \\<bind> monadic_nfoldli ls c f\n             else RETURN s)) =\n    (case l of [] \\<Rightarrow> RETURN s\n     | x # ls \\<Rightarrow>\n         c s \\<bind>\n         (\\<lambda>b.\n             if b then f x s \\<bind> monadic_nfoldli ls c f else RETURN s))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma monadic_nfoldli_simp[simp]:\n  \"monadic_nfoldli [] c f s = RETURN s\"\n  \"monadic_nfoldli (x#ls) c f s = do {\n    b\\<leftarrow>c s;\n    if b then f x s \\<bind> monadic_nfoldli ls c f else RETURN s\n  }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monadic_nfoldli [] c f s = RETURN s &&&\n    monadic_nfoldli (x # ls) c f s =\n    c s \\<bind>\n    (\\<lambda>b.\n        if b then f x s \\<bind> monadic_nfoldli ls c f else RETURN s)", "apply (subst monadic_nfoldli_eq, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. monadic_nfoldli (x # ls) c f s =\n    c s \\<bind>\n    (\\<lambda>b.\n        if b then f x s \\<bind> monadic_nfoldli ls c f else RETURN s)", "apply (subst monadic_nfoldli_eq, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nfoldli_to_monadic:\n  \"nfoldli l c f = monadic_nfoldli l (\\<lambda>x. RETURN (c x)) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli l c f = monadic_nfoldli l (\\<lambda>x. RETURN (c x)) f", "apply (induct l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. nfoldli [] c f = monadic_nfoldli [] (\\<lambda>x. RETURN (c x)) f\n 2. \\<And>a l.\n       nfoldli l c f =\n       monadic_nfoldli l (\\<lambda>x. RETURN (c x)) f \\<Longrightarrow>\n       nfoldli (a # l) c f =\n       monadic_nfoldli (a # l) (\\<lambda>x. RETURN (c x)) f", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"nfoldli_alt l c f s \\<equiv> RECT (\\<lambda>D (l,s). case l of \n    [] \\<Rightarrow> RETURN s\n  | x#ls \\<Rightarrow> do {\n      let b = c s;\n      if b then do { s'\\<leftarrow>f x s; D (ls,s')} else RETURN s\n    }\n  ) (l,s)\""], ["", "lemma nfoldli_alt_eq:\n  \"nfoldli_alt l c f s = (\n    case l of \n      [] \\<Rightarrow> RETURN s \n    | x#ls \\<Rightarrow> do {let b=c s; if b then f x s \\<bind> nfoldli_alt ls c f else RETURN s}\n  )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli_alt l c f s =\n    (case l of [] \\<Rightarrow> RETURN s\n     | x # ls \\<Rightarrow>\n         let b = c s\n         in if b then f x s \\<bind> nfoldli_alt ls c f else RETURN s)", "apply (subst nfoldli_alt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. REC\\<^sub>T\n     (\\<lambda>D (l, s).\n         case l of [] \\<Rightarrow> RETURN s\n         | x # ls \\<Rightarrow>\n             let b = c s\n             in if b then f x s \\<bind> (\\<lambda>s'. D (ls, s'))\n                else RETURN s)\n     (l, s) =\n    (case l of [] \\<Rightarrow> RETURN s\n     | x # ls \\<Rightarrow>\n         let b = c s\n         in if b then f x s \\<bind> nfoldli_alt ls c f else RETURN s)", "apply (subst RECT_unfold)"], ["proof (prove)\ngoal (2 subgoals):\n 1. trimono\n     (\\<lambda>D (l, s).\n         case l of [] \\<Rightarrow> RETURN s\n         | x # ls \\<Rightarrow>\n             let b = c s\n             in if b then f x s \\<bind> (\\<lambda>s'. D (ls, s'))\n                else RETURN s)\n 2. (case (l, s) of ([], s) \\<Rightarrow> RETURN s\n     | (x # ls, s) \\<Rightarrow>\n         let b = c s\n         in if b\n            then f x s \\<bind>\n                 (\\<lambda>s'.\n                     REC\\<^sub>T\n                      (\\<lambda>D (l, s).\n                          case l of [] \\<Rightarrow> RETURN s\n                          | x # ls \\<Rightarrow>\n                              let b = c s\n                              in if b\n                                 then f x s \\<bind>\n(\\<lambda>s'. D (ls, s'))\n                                 else RETURN s)\n                      (ls, s'))\n            else RETURN s) =\n    (case l of [] \\<Rightarrow> RETURN s\n     | x # ls \\<Rightarrow>\n         let b = c s\n         in if b then f x s \\<bind> nfoldli_alt ls c f else RETURN s)", "apply (tagged_solver)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (l, s) of ([], s) \\<Rightarrow> RETURN s\n     | (x # ls, s) \\<Rightarrow>\n         let b = c s\n         in if b\n            then f x s \\<bind>\n                 (\\<lambda>s'.\n                     REC\\<^sub>T\n                      (\\<lambda>D (l, s).\n                          case l of [] \\<Rightarrow> RETURN s\n                          | x # ls \\<Rightarrow>\n                              let b = c s\n                              in if b\n                                 then f x s \\<bind>\n(\\<lambda>s'. D (ls, s'))\n                                 else RETURN s)\n                      (ls, s'))\n            else RETURN s) =\n    (case l of [] \\<Rightarrow> RETURN s\n     | x # ls \\<Rightarrow>\n         let b = c s\n         in if b then f x s \\<bind> nfoldli_alt ls c f else RETURN s)", "apply (subst nfoldli_alt_def[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (l, s) of ([], s) \\<Rightarrow> RETURN s\n     | (x # ls, s) \\<Rightarrow>\n         let b = c s\n         in if b then f x s \\<bind> nfoldli_alt ls c f else RETURN s) =\n    (case l of [] \\<Rightarrow> RETURN s\n     | x # ls \\<Rightarrow>\n         let b = c s\n         in if b then f x s \\<bind> nfoldli_alt ls c f else RETURN s)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nfoldli_alt_simp[simp]:\n  \"nfoldli_alt [] c f s = RETURN s\"\n  \"nfoldli_alt (x#ls) c f s = do {\n    let b = c s;\n    if b then f x s \\<bind> nfoldli_alt ls c f else RETURN s\n  }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli_alt [] c f s = RETURN s &&&\n    nfoldli_alt (x # ls) c f s =\n    (let b = c s\n     in if b then f x s \\<bind> nfoldli_alt ls c f else RETURN s)", "apply (subst nfoldli_alt_eq, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli_alt (x # ls) c f s =\n    (let b = c s\n     in if b then f x s \\<bind> nfoldli_alt ls c f else RETURN s)", "apply (subst nfoldli_alt_eq, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nfoldli_alt:\n  \"(nfoldli::'a list \\<Rightarrow> ('b \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> 'b \\<Rightarrow> 'b nres) \\<Rightarrow> 'b \\<Rightarrow> 'b nres)\n  = nfoldli_alt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli = nfoldli_alt", "proof (intro ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa xb xc. nfoldli x xa xb xc = nfoldli_alt x xa xb xc", "fix l::\"'a list\" and c::\"'b \\<Rightarrow> bool\" and f::\"'a \\<Rightarrow> 'b \\<Rightarrow> 'b nres\" and s :: 'b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa xb xc. nfoldli x xa xb xc = nfoldli_alt x xa xb xc", "have \"nfoldli l c f = nfoldli_alt l c f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli l c f = nfoldli_alt l c f", "by (induct l) auto"], ["proof (state)\nthis:\n  nfoldli l c f = nfoldli_alt l c f\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb xc. nfoldli x xa xb xc = nfoldli_alt x xa xb xc", "thus \"nfoldli l c f s = nfoldli_alt l c f s\""], ["proof (prove)\nusing this:\n  nfoldli l c f = nfoldli_alt l c f\n\ngoal (1 subgoal):\n 1. nfoldli l c f s = nfoldli_alt l c f s", "by simp"], ["proof (state)\nthis:\n  nfoldli l c f s = nfoldli_alt l c f s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monadic_nfoldli_rec:\n  \"monadic_nfoldli x' c f \\<sigma>\n          \\<le>\\<Down>Id (REC\\<^sub>T\n             (\\<lambda>W (xs, \\<sigma>).\n                 ASSERT (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n                 (\\<lambda>_. if xs = [] then RETURN (xs, \\<sigma>)\n                      else c \\<sigma> \\<bind>\n                           (\\<lambda>b. if b then FOREACH_body f (xs, \\<sigma>) \\<bind> W\n                                else RETURN (xs, \\<sigma>))))\n             (x', \\<sigma>) \\<bind>\n            (\\<lambda>(_, y). RETURN y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monadic_nfoldli x' c f \\<sigma>\n    \\<le> \\<Down> Id\n           (REC\\<^sub>T\n             (\\<lambda>W (xs, \\<sigma>).\n                 ASSERT (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n                 (\\<lambda>_.\n                     if xs = [] then RETURN (xs, \\<sigma>)\n                     else c \\<sigma> \\<bind>\n                          (\\<lambda>b.\n                              if b\n                              then FOREACH_body f (xs, \\<sigma>) \\<bind> W\n                              else RETURN (xs, \\<sigma>))))\n             (x', \\<sigma>) \\<bind>\n            (\\<lambda>(uu_, y). RETURN y))", "apply (induct x' arbitrary: \\<sigma>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       monadic_nfoldli [] c f \\<sigma>\n       \\<le> \\<Down> Id\n              (REC\\<^sub>T\n                (\\<lambda>W (xs, \\<sigma>).\n                    ASSERT (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n                    (\\<lambda>_.\n                        if xs = [] then RETURN (xs, \\<sigma>)\n                        else c \\<sigma> \\<bind>\n                             (\\<lambda>b.\n                                 if b\n                                 then FOREACH_body f (xs, \\<sigma>) \\<bind>\nW\n                                 else RETURN (xs, \\<sigma>))))\n                ([], \\<sigma>) \\<bind>\n               (\\<lambda>(uu_, y). RETURN y))\n 2. \\<And>a x' \\<sigma>.\n       (\\<And>\\<sigma>.\n           monadic_nfoldli x' c f \\<sigma>\n           \\<le> \\<Down> Id\n                  (REC\\<^sub>T\n                    (\\<lambda>W (xs, \\<sigma>).\n                        ASSERT (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n                        (\\<lambda>_.\n                            if xs = [] then RETURN (xs, \\<sigma>)\n                            else c \\<sigma> \\<bind>\n                                 (\\<lambda>b.\n                                     if b\n                                     then FOREACH_body f\n     (xs, \\<sigma>) \\<bind>\n    W\n                                     else RETURN (xs, \\<sigma>))))\n                    (x', \\<sigma>) \\<bind>\n                   (\\<lambda>(uu_, y). RETURN y))) \\<Longrightarrow>\n       monadic_nfoldli (a # x') c f \\<sigma>\n       \\<le> \\<Down> Id\n              (REC\\<^sub>T\n                (\\<lambda>W (xs, \\<sigma>).\n                    ASSERT (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n                    (\\<lambda>_.\n                        if xs = [] then RETURN (xs, \\<sigma>)\n                        else c \\<sigma> \\<bind>\n                             (\\<lambda>b.\n                                 if b\n                                 then FOREACH_body f (xs, \\<sigma>) \\<bind>\nW\n                                 else RETURN (xs, \\<sigma>))))\n                (a # x', \\<sigma>) \\<bind>\n               (\\<lambda>(uu_, y). RETURN y))", "apply (subst RECT_unfold, refine_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       monadic_nfoldli [] c f \\<sigma>\n       \\<le> \\<Down> Id\n              ((case ([], \\<sigma>) of\n                (xs, \\<sigma>) \\<Rightarrow>\n                  ASSERT (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n                  (\\<lambda>_.\n                      if xs = [] then RETURN (xs, \\<sigma>)\n                      else c \\<sigma> \\<bind>\n                           (\\<lambda>b.\n                               if b\n                               then FOREACH_body f (xs, \\<sigma>) \\<bind>\n                                    REC\\<^sub>T\n                                     (\\<lambda>W (xs, \\<sigma>).\n   ASSERT (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n   (\\<lambda>_.\n       if xs = [] then RETURN (xs, \\<sigma>)\n       else c \\<sigma> \\<bind>\n            (\\<lambda>b.\n                if b then FOREACH_body f (xs, \\<sigma>) \\<bind> W\n                else RETURN (xs, \\<sigma>))))\n                               else RETURN (xs, \\<sigma>)))) \\<bind>\n               (\\<lambda>(uu_, y). RETURN y))\n 2. \\<And>a x' \\<sigma>.\n       (\\<And>\\<sigma>.\n           monadic_nfoldli x' c f \\<sigma>\n           \\<le> \\<Down> Id\n                  (REC\\<^sub>T\n                    (\\<lambda>W (xs, \\<sigma>).\n                        ASSERT (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n                        (\\<lambda>_.\n                            if xs = [] then RETURN (xs, \\<sigma>)\n                            else c \\<sigma> \\<bind>\n                                 (\\<lambda>b.\n                                     if b\n                                     then FOREACH_body f\n     (xs, \\<sigma>) \\<bind>\n    W\n                                     else RETURN (xs, \\<sigma>))))\n                    (x', \\<sigma>) \\<bind>\n                   (\\<lambda>(uu_, y). RETURN y))) \\<Longrightarrow>\n       monadic_nfoldli (a # x') c f \\<sigma>\n       \\<le> \\<Down> Id\n              (REC\\<^sub>T\n                (\\<lambda>W (xs, \\<sigma>).\n                    ASSERT (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n                    (\\<lambda>_.\n                        if xs = [] then RETURN (xs, \\<sigma>)\n                        else c \\<sigma> \\<bind>\n                             (\\<lambda>b.\n                                 if b\n                                 then FOREACH_body f (xs, \\<sigma>) \\<bind>\nW\n                                 else RETURN (xs, \\<sigma>))))\n                (a # x', \\<sigma>) \\<bind>\n               (\\<lambda>(uu_, y). RETURN y))", "apply (simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       RETURN \\<sigma>\n       \\<le> ASSERT (FOREACH_inv xs0 I ([], \\<sigma>)) \\<bind>\n             (\\<lambda>x. RETURN \\<sigma>)\n 2. \\<And>a x' \\<sigma>.\n       (\\<And>\\<sigma>.\n           monadic_nfoldli x' c f \\<sigma>\n           \\<le> \\<Down> Id\n                  (REC\\<^sub>T\n                    (\\<lambda>W (xs, \\<sigma>).\n                        ASSERT (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n                        (\\<lambda>_.\n                            if xs = [] then RETURN (xs, \\<sigma>)\n                            else c \\<sigma> \\<bind>\n                                 (\\<lambda>b.\n                                     if b\n                                     then FOREACH_body f\n     (xs, \\<sigma>) \\<bind>\n    W\n                                     else RETURN (xs, \\<sigma>))))\n                    (x', \\<sigma>) \\<bind>\n                   (\\<lambda>(uu_, y). RETURN y))) \\<Longrightarrow>\n       monadic_nfoldli (a # x') c f \\<sigma>\n       \\<le> \\<Down> Id\n              (REC\\<^sub>T\n                (\\<lambda>W (xs, \\<sigma>).\n                    ASSERT (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n                    (\\<lambda>_.\n                        if xs = [] then RETURN (xs, \\<sigma>)\n                        else c \\<sigma> \\<bind>\n                             (\\<lambda>b.\n                                 if b\n                                 then FOREACH_body f (xs, \\<sigma>) \\<bind>\nW\n                                 else RETURN (xs, \\<sigma>))))\n                (a # x', \\<sigma>) \\<bind>\n               (\\<lambda>(uu_, y). RETURN y))", "apply (rule le_ASSERTI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       FOREACH_inv xs0 I ([], \\<sigma>) \\<Longrightarrow>\n       RETURN \\<sigma> \\<le> RETURN \\<sigma>\n 2. \\<And>a x' \\<sigma>.\n       (\\<And>\\<sigma>.\n           monadic_nfoldli x' c f \\<sigma>\n           \\<le> \\<Down> Id\n                  (REC\\<^sub>T\n                    (\\<lambda>W (xs, \\<sigma>).\n                        ASSERT (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n                        (\\<lambda>_.\n                            if xs = [] then RETURN (xs, \\<sigma>)\n                            else c \\<sigma> \\<bind>\n                                 (\\<lambda>b.\n                                     if b\n                                     then FOREACH_body f\n     (xs, \\<sigma>) \\<bind>\n    W\n                                     else RETURN (xs, \\<sigma>))))\n                    (x', \\<sigma>) \\<bind>\n                   (\\<lambda>(uu_, y). RETURN y))) \\<Longrightarrow>\n       monadic_nfoldli (a # x') c f \\<sigma>\n       \\<le> \\<Down> Id\n              (REC\\<^sub>T\n                (\\<lambda>W (xs, \\<sigma>).\n                    ASSERT (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n                    (\\<lambda>_.\n                        if xs = [] then RETURN (xs, \\<sigma>)\n                        else c \\<sigma> \\<bind>\n                             (\\<lambda>b.\n                                 if b\n                                 then FOREACH_body f (xs, \\<sigma>) \\<bind>\nW\n                                 else RETURN (xs, \\<sigma>))))\n                (a # x', \\<sigma>) \\<bind>\n               (\\<lambda>(uu_, y). RETURN y))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a x' \\<sigma>.\n       (\\<And>\\<sigma>.\n           monadic_nfoldli x' c f \\<sigma>\n           \\<le> \\<Down> Id\n                  (REC\\<^sub>T\n                    (\\<lambda>W (xs, \\<sigma>).\n                        ASSERT (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n                        (\\<lambda>_.\n                            if xs = [] then RETURN (xs, \\<sigma>)\n                            else c \\<sigma> \\<bind>\n                                 (\\<lambda>b.\n                                     if b\n                                     then FOREACH_body f\n     (xs, \\<sigma>) \\<bind>\n    W\n                                     else RETURN (xs, \\<sigma>))))\n                    (x', \\<sigma>) \\<bind>\n                   (\\<lambda>(uu_, y). RETURN y))) \\<Longrightarrow>\n       monadic_nfoldli (a # x') c f \\<sigma>\n       \\<le> \\<Down> Id\n              (REC\\<^sub>T\n                (\\<lambda>W (xs, \\<sigma>).\n                    ASSERT (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n                    (\\<lambda>_.\n                        if xs = [] then RETURN (xs, \\<sigma>)\n                        else c \\<sigma> \\<bind>\n                             (\\<lambda>b.\n                                 if b\n                                 then FOREACH_body f (xs, \\<sigma>) \\<bind>\nW\n                                 else RETURN (xs, \\<sigma>))))\n                (a # x', \\<sigma>) \\<bind>\n               (\\<lambda>(uu_, y). RETURN y))", "apply (subst RECT_unfold, refine_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a x' \\<sigma>.\n       (\\<And>\\<sigma>.\n           monadic_nfoldli x' c f \\<sigma>\n           \\<le> \\<Down> Id\n                  (REC\\<^sub>T\n                    (\\<lambda>W (xs, \\<sigma>).\n                        ASSERT (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n                        (\\<lambda>_.\n                            if xs = [] then RETURN (xs, \\<sigma>)\n                            else c \\<sigma> \\<bind>\n                                 (\\<lambda>b.\n                                     if b\n                                     then FOREACH_body f\n     (xs, \\<sigma>) \\<bind>\n    W\n                                     else RETURN (xs, \\<sigma>))))\n                    (x', \\<sigma>) \\<bind>\n                   (\\<lambda>(uu_, y). RETURN y))) \\<Longrightarrow>\n       monadic_nfoldli (a # x') c f \\<sigma>\n       \\<le> \\<Down> Id\n              ((case (a # x', \\<sigma>) of\n                (xs, \\<sigma>) \\<Rightarrow>\n                  ASSERT (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n                  (\\<lambda>_.\n                      if xs = [] then RETURN (xs, \\<sigma>)\n                      else c \\<sigma> \\<bind>\n                           (\\<lambda>b.\n                               if b\n                               then FOREACH_body f (xs, \\<sigma>) \\<bind>\n                                    REC\\<^sub>T\n                                     (\\<lambda>W (xs, \\<sigma>).\n   ASSERT (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n   (\\<lambda>_.\n       if xs = [] then RETURN (xs, \\<sigma>)\n       else c \\<sigma> \\<bind>\n            (\\<lambda>b.\n                if b then FOREACH_body f (xs, \\<sigma>) \\<bind> W\n                else RETURN (xs, \\<sigma>))))\n                               else RETURN (xs, \\<sigma>)))) \\<bind>\n               (\\<lambda>(uu_, y). RETURN y))", "apply (subst monadic_nfoldli_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a x' \\<sigma>.\n       (\\<And>\\<sigma>.\n           monadic_nfoldli x' c f \\<sigma>\n           \\<le> \\<Down> Id\n                  (REC\\<^sub>T\n                    (\\<lambda>W (xs, \\<sigma>).\n                        ASSERT (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n                        (\\<lambda>_.\n                            if xs = [] then RETURN (xs, \\<sigma>)\n                            else c \\<sigma> \\<bind>\n                                 (\\<lambda>b.\n                                     if b\n                                     then FOREACH_body f\n     (xs, \\<sigma>) \\<bind>\n    W\n                                     else RETURN (xs, \\<sigma>))))\n                    (x', \\<sigma>) \\<bind>\n                   (\\<lambda>(uu_, y). RETURN y))) \\<Longrightarrow>\n       c \\<sigma> \\<bind>\n       (\\<lambda>b.\n           if b then f a \\<sigma> \\<bind> monadic_nfoldli x' c f\n           else RETURN \\<sigma>)\n       \\<le> \\<Down> Id\n              ((case (a # x', \\<sigma>) of\n                (xs, \\<sigma>) \\<Rightarrow>\n                  ASSERT (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n                  (\\<lambda>_.\n                      if xs = [] then RETURN (xs, \\<sigma>)\n                      else c \\<sigma> \\<bind>\n                           (\\<lambda>b.\n                               if b\n                               then FOREACH_body f (xs, \\<sigma>) \\<bind>\n                                    REC\\<^sub>T\n                                     (\\<lambda>W (xs, \\<sigma>).\n   ASSERT (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n   (\\<lambda>_.\n       if xs = [] then RETURN (xs, \\<sigma>)\n       else c \\<sigma> \\<bind>\n            (\\<lambda>b.\n                if b then FOREACH_body f (xs, \\<sigma>) \\<bind> W\n                else RETURN (xs, \\<sigma>))))\n                               else RETURN (xs, \\<sigma>)))) \\<bind>\n               (\\<lambda>(uu_, y). RETURN y))", "apply (simp del: conc_Id cong: if_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a x' \\<sigma>.\n       (\\<And>\\<sigma>.\n           monadic_nfoldli x' c f \\<sigma>\n           \\<le> \\<Down> Id\n                  (REC\\<^sub>T\n                    (\\<lambda>W (xs, \\<sigma>).\n                        ASSERT (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n                        (\\<lambda>_.\n                            if xs = [] then RETURN ([], \\<sigma>)\n                            else c \\<sigma> \\<bind>\n                                 (\\<lambda>b.\n                                     if b\n                                     then FOREACH_body f\n     (xs, \\<sigma>) \\<bind>\n    W\n                                     else RETURN (xs, \\<sigma>))))\n                    (x', \\<sigma>) \\<bind>\n                   (\\<lambda>(uu_, y). RETURN y))) \\<Longrightarrow>\n       c \\<sigma> \\<bind>\n       (\\<lambda>b.\n           if b then f a \\<sigma> \\<bind> monadic_nfoldli x' c f\n           else RETURN \\<sigma>)\n       \\<le> \\<Down> Id\n              (ASSERT (FOREACH_inv xs0 I (a # x', \\<sigma>)) \\<bind>\n               (\\<lambda>x.\n                   c \\<sigma> \\<bind>\n                   (\\<lambda>x.\n                       if x\n                       then FOREACH_body f (a # x', \\<sigma>) \\<bind>\n                            (\\<lambda>x.\n                                REC\\<^sub>T\n                                 (\\<lambda>W (xs, \\<sigma>).\n                                     ASSERT\n(FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n                                     (\\<lambda>_.\n   if xs = [] then RETURN ([], \\<sigma>)\n   else c \\<sigma> \\<bind>\n        (\\<lambda>b.\n            if b then FOREACH_body f (xs, \\<sigma>) \\<bind> W\n            else RETURN (xs, \\<sigma>))))\n                                 x \\<bind>\n                                (\\<lambda>(uu_, y). RETURN y))\n                       else RETURN \\<sigma>)))", "apply refine_rcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a x' \\<sigma> b x.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   monadic_nfoldli x' c f \\<sigma>\n                   \\<le> \\<Down> Id\n                          (REC\\<^sub>T\n                            (\\<lambda>W (xs, \\<sigma>).\n                                ASSERT\n                                 (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n                                (\\<lambda>_.\n                                    if xs = [] then RETURN ([], \\<sigma>)\n                                    else c \\<sigma> \\<bind>\n   (\\<lambda>b.\n       if b then FOREACH_body f (xs, \\<sigma>) \\<bind> W\n       else RETURN (xs, \\<sigma>))))\n                            (x', \\<sigma>) \\<bind>\n                           (\\<lambda>(uu_, y). RETURN y));\n        FOREACH_inv xs0 I (a # x', \\<sigma>); (b, x) \\<in> bool_rel\\<rbrakk>\n       \\<Longrightarrow> b = x\n 2. \\<And>a x' \\<sigma> b x.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   monadic_nfoldli x' c f \\<sigma>\n                   \\<le> \\<Down> Id\n                          (REC\\<^sub>T\n                            (\\<lambda>W (xs, \\<sigma>).\n                                ASSERT\n                                 (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n                                (\\<lambda>_.\n                                    if xs = [] then RETURN ([], \\<sigma>)\n                                    else c \\<sigma> \\<bind>\n   (\\<lambda>b.\n       if b then FOREACH_body f (xs, \\<sigma>) \\<bind> W\n       else RETURN (xs, \\<sigma>))))\n                            (x', \\<sigma>) \\<bind>\n                           (\\<lambda>(uu_, y). RETURN y));\n        FOREACH_inv xs0 I (a # x', \\<sigma>); (b, x) \\<in> bool_rel; b;\n        x\\<rbrakk>\n       \\<Longrightarrow> f a \\<sigma>\n                         \\<le> \\<Down> (?R'517 a x' \\<sigma> b x)\n                                (FOREACH_body f (a # x', \\<sigma>))\n 3. \\<And>a x' \\<sigma> b x xa xb.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   monadic_nfoldli x' c f \\<sigma>\n                   \\<le> \\<Down> Id\n                          (REC\\<^sub>T\n                            (\\<lambda>W (xs, \\<sigma>).\n                                ASSERT\n                                 (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n                                (\\<lambda>_.\n                                    if xs = [] then RETURN ([], \\<sigma>)\n                                    else c \\<sigma> \\<bind>\n   (\\<lambda>b.\n       if b then FOREACH_body f (xs, \\<sigma>) \\<bind> W\n       else RETURN (xs, \\<sigma>))))\n                            (x', \\<sigma>) \\<bind>\n                           (\\<lambda>(uu_, y). RETURN y));\n        FOREACH_inv xs0 I (a # x', \\<sigma>); (b, x) \\<in> bool_rel; b; x;\n        (xa, xb) \\<in> ?R'517 a x' \\<sigma> b x\\<rbrakk>\n       \\<Longrightarrow> monadic_nfoldli x' c f xa\n                         \\<le> \\<Down> Id\n                                (REC\\<^sub>T\n                                  (\\<lambda>W (xs, \\<sigma>).\nASSERT (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n(\\<lambda>_.\n    if xs = [] then RETURN ([], \\<sigma>)\n    else c \\<sigma> \\<bind>\n         (\\<lambda>b.\n             if b then FOREACH_body f (xs, \\<sigma>) \\<bind> W\n             else RETURN (xs, \\<sigma>))))\n                                  xb \\<bind>\n                                 (\\<lambda>(uu_, y). RETURN y))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a x' \\<sigma> b x.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   monadic_nfoldli x' c f \\<sigma>\n                   \\<le> \\<Down> Id\n                          (REC\\<^sub>T\n                            (\\<lambda>W (xs, \\<sigma>).\n                                ASSERT\n                                 (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n                                (\\<lambda>_.\n                                    if xs = [] then RETURN ([], \\<sigma>)\n                                    else c \\<sigma> \\<bind>\n   (\\<lambda>b.\n       if b then FOREACH_body f (xs, \\<sigma>) \\<bind> W\n       else RETURN (xs, \\<sigma>))))\n                            (x', \\<sigma>) \\<bind>\n                           (\\<lambda>(uu_, y). RETURN y));\n        FOREACH_inv xs0 I (a # x', \\<sigma>); (b, x) \\<in> bool_rel; b;\n        x\\<rbrakk>\n       \\<Longrightarrow> f a \\<sigma>\n                         \\<le> \\<Down> (?R'517 a x' \\<sigma> b x)\n                                (FOREACH_body f (a # x', \\<sigma>))\n 2. \\<And>a x' \\<sigma> b x xa xb.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   monadic_nfoldli x' c f \\<sigma>\n                   \\<le> \\<Down> Id\n                          (REC\\<^sub>T\n                            (\\<lambda>W (xs, \\<sigma>).\n                                ASSERT\n                                 (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n                                (\\<lambda>_.\n                                    if xs = [] then RETURN ([], \\<sigma>)\n                                    else c \\<sigma> \\<bind>\n   (\\<lambda>b.\n       if b then FOREACH_body f (xs, \\<sigma>) \\<bind> W\n       else RETURN (xs, \\<sigma>))))\n                            (x', \\<sigma>) \\<bind>\n                           (\\<lambda>(uu_, y). RETURN y));\n        FOREACH_inv xs0 I (a # x', \\<sigma>); (b, x) \\<in> bool_rel; b; x;\n        (xa, xb) \\<in> ?R'517 a x' \\<sigma> b x\\<rbrakk>\n       \\<Longrightarrow> monadic_nfoldli x' c f xa\n                         \\<le> \\<Down> Id\n                                (REC\\<^sub>T\n                                  (\\<lambda>W (xs, \\<sigma>).\nASSERT (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n(\\<lambda>_.\n    if xs = [] then RETURN ([], \\<sigma>)\n    else c \\<sigma> \\<bind>\n         (\\<lambda>b.\n             if b then FOREACH_body f (xs, \\<sigma>) \\<bind> W\n             else RETURN (xs, \\<sigma>))))\n                                  xb \\<bind>\n                                 (\\<lambda>(uu_, y). RETURN y))", "apply (clarsimp simp add: FOREACH_body_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a x' \\<sigma> b x.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   monadic_nfoldli x' c f \\<sigma>\n                   \\<le> REC\\<^sub>T\n                          (\\<lambda>W (xs, \\<sigma>).\n                              ASSERT\n                               (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n                              (\\<lambda>_.\n                                  if xs = [] then RETURN ([], \\<sigma>)\n                                  else c \\<sigma> \\<bind>\n (\\<lambda>b.\n     if b then FOREACH_body f (xs, \\<sigma>) \\<bind> W\n     else RETURN (xs, \\<sigma>))))\n                          (x', \\<sigma>) \\<bind>\n                         (\\<lambda>(uu_, y). RETURN y);\n        FOREACH_inv xs0 I (a # x', \\<sigma>); b; x\\<rbrakk>\n       \\<Longrightarrow> f a \\<sigma>\n                         \\<le> \\<Down> (?R'517 a x' \\<sigma> True True)\n                                (f a \\<sigma> \\<bind>\n                                 (\\<lambda>\\<sigma>'.\n                                     RETURN (x', \\<sigma>')))\n 2. \\<And>a x' \\<sigma> b x xa xb.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   monadic_nfoldli x' c f \\<sigma>\n                   \\<le> \\<Down> Id\n                          (REC\\<^sub>T\n                            (\\<lambda>W (xs, \\<sigma>).\n                                ASSERT\n                                 (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n                                (\\<lambda>_.\n                                    if xs = [] then RETURN ([], \\<sigma>)\n                                    else c \\<sigma> \\<bind>\n   (\\<lambda>b.\n       if b then FOREACH_body f (xs, \\<sigma>) \\<bind> W\n       else RETURN (xs, \\<sigma>))))\n                            (x', \\<sigma>) \\<bind>\n                           (\\<lambda>(uu_, y). RETURN y));\n        FOREACH_inv xs0 I (a # x', \\<sigma>); (b, x) \\<in> bool_rel; b; x;\n        (xa, xb) \\<in> ?R'517 a x' \\<sigma> b x\\<rbrakk>\n       \\<Longrightarrow> monadic_nfoldli x' c f xa\n                         \\<le> \\<Down> Id\n                                (REC\\<^sub>T\n                                  (\\<lambda>W (xs, \\<sigma>).\nASSERT (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n(\\<lambda>_.\n    if xs = [] then RETURN ([], \\<sigma>)\n    else c \\<sigma> \\<bind>\n         (\\<lambda>b.\n             if b then FOREACH_body f (xs, \\<sigma>) \\<bind> W\n             else RETURN (xs, \\<sigma>))))\n                                  xb \\<bind>\n                                 (\\<lambda>(uu_, y). RETURN y))", "apply (rule_tac R=\"br (Pair x') (\\<lambda>_. True)\" in intro_prgR)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a x' \\<sigma> b x.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   monadic_nfoldli x' c f \\<sigma>\n                   \\<le> REC\\<^sub>T\n                          (\\<lambda>W (xs, \\<sigma>).\n                              ASSERT\n                               (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n                              (\\<lambda>_.\n                                  if xs = [] then RETURN ([], \\<sigma>)\n                                  else c \\<sigma> \\<bind>\n (\\<lambda>b.\n     if b then FOREACH_body f (xs, \\<sigma>) \\<bind> W\n     else RETURN (xs, \\<sigma>))))\n                          (x', \\<sigma>) \\<bind>\n                         (\\<lambda>(uu_, y). RETURN y);\n        FOREACH_inv xs0 I (a # x', \\<sigma>); b; x\\<rbrakk>\n       \\<Longrightarrow> f a \\<sigma>\n                         \\<le> \\<Down> (br (Pair x') (\\<lambda>_. True))\n                                (f a \\<sigma> \\<bind>\n                                 (\\<lambda>\\<sigma>'.\n                                     RETURN (x', \\<sigma>')))\n 2. \\<And>a x' \\<sigma> b x xa xb.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   monadic_nfoldli x' c f \\<sigma>\n                   \\<le> \\<Down> Id\n                          (REC\\<^sub>T\n                            (\\<lambda>W (xs, \\<sigma>).\n                                ASSERT\n                                 (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n                                (\\<lambda>_.\n                                    if xs = [] then RETURN ([], \\<sigma>)\n                                    else c \\<sigma> \\<bind>\n   (\\<lambda>b.\n       if b then FOREACH_body f (xs, \\<sigma>) \\<bind> W\n       else RETURN (xs, \\<sigma>))))\n                            (x', \\<sigma>) \\<bind>\n                           (\\<lambda>(uu_, y). RETURN y));\n        FOREACH_inv xs0 I (a # x', \\<sigma>); (b, x) \\<in> bool_rel; b; x;\n        (xa, xb) \\<in> br (Pair x') (\\<lambda>_. x)\\<rbrakk>\n       \\<Longrightarrow> monadic_nfoldli x' c f xa\n                         \\<le> \\<Down> Id\n                                (REC\\<^sub>T\n                                  (\\<lambda>W (xs, \\<sigma>).\nASSERT (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n(\\<lambda>_.\n    if xs = [] then RETURN ([], \\<sigma>)\n    else c \\<sigma> \\<bind>\n         (\\<lambda>b.\n             if b then FOREACH_body f (xs, \\<sigma>) \\<bind> W\n             else RETURN (xs, \\<sigma>))))\n                                  xb \\<bind>\n                                 (\\<lambda>(uu_, y). RETURN y))", "apply (simp add: pw_le_iff refine_pw_simps br_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a x' \\<sigma> b x xa xb.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   monadic_nfoldli x' c f \\<sigma>\n                   \\<le> \\<Down> Id\n                          (REC\\<^sub>T\n                            (\\<lambda>W (xs, \\<sigma>).\n                                ASSERT\n                                 (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n                                (\\<lambda>_.\n                                    if xs = [] then RETURN ([], \\<sigma>)\n                                    else c \\<sigma> \\<bind>\n   (\\<lambda>b.\n       if b then FOREACH_body f (xs, \\<sigma>) \\<bind> W\n       else RETURN (xs, \\<sigma>))))\n                            (x', \\<sigma>) \\<bind>\n                           (\\<lambda>(uu_, y). RETURN y));\n        FOREACH_inv xs0 I (a # x', \\<sigma>); (b, x) \\<in> bool_rel; b; x;\n        (xa, xb) \\<in> br (Pair x') (\\<lambda>_. x)\\<rbrakk>\n       \\<Longrightarrow> monadic_nfoldli x' c f xa\n                         \\<le> \\<Down> Id\n                                (REC\\<^sub>T\n                                  (\\<lambda>W (xs, \\<sigma>).\nASSERT (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n(\\<lambda>_.\n    if xs = [] then RETURN ([], \\<sigma>)\n    else c \\<sigma> \\<bind>\n         (\\<lambda>b.\n             if b then FOREACH_body f (xs, \\<sigma>) \\<bind> W\n             else RETURN (xs, \\<sigma>))))\n                                  xb \\<bind>\n                                 (\\<lambda>(uu_, y). RETURN y))", "apply (rule order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a x' \\<sigma> b x xa xb.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   monadic_nfoldli x' c f \\<sigma>\n                   \\<le> \\<Down> Id\n                          (REC\\<^sub>T\n                            (\\<lambda>W (xs, \\<sigma>).\n                                ASSERT\n                                 (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n                                (\\<lambda>_.\n                                    if xs = [] then RETURN ([], \\<sigma>)\n                                    else c \\<sigma> \\<bind>\n   (\\<lambda>b.\n       if b then FOREACH_body f (xs, \\<sigma>) \\<bind> W\n       else RETURN (xs, \\<sigma>))))\n                            (x', \\<sigma>) \\<bind>\n                           (\\<lambda>(uu_, y). RETURN y));\n        FOREACH_inv xs0 I (a # x', \\<sigma>); (b, x) \\<in> bool_rel; b; x;\n        (xa, xb) \\<in> br (Pair x') (\\<lambda>_. x)\\<rbrakk>\n       \\<Longrightarrow> monadic_nfoldli x' c f xa\n                         \\<le> ?y523 a x' \\<sigma> b x xa xb\n 2. \\<And>a x' \\<sigma> b x xa xb.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   monadic_nfoldli x' c f \\<sigma>\n                   \\<le> \\<Down> Id\n                          (REC\\<^sub>T\n                            (\\<lambda>W (xs, \\<sigma>).\n                                ASSERT\n                                 (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n                                (\\<lambda>_.\n                                    if xs = [] then RETURN ([], \\<sigma>)\n                                    else c \\<sigma> \\<bind>\n   (\\<lambda>b.\n       if b then FOREACH_body f (xs, \\<sigma>) \\<bind> W\n       else RETURN (xs, \\<sigma>))))\n                            (x', \\<sigma>) \\<bind>\n                           (\\<lambda>(uu_, y). RETURN y));\n        FOREACH_inv xs0 I (a # x', \\<sigma>); (b, x) \\<in> bool_rel; b; x;\n        (xa, xb) \\<in> br (Pair x') (\\<lambda>_. x)\\<rbrakk>\n       \\<Longrightarrow> ?y523 a x' \\<sigma> b x xa xb\n                         \\<le> \\<Down> Id\n                                (REC\\<^sub>T\n                                  (\\<lambda>W (xs, \\<sigma>).\nASSERT (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n(\\<lambda>_.\n    if xs = [] then RETURN ([], \\<sigma>)\n    else c \\<sigma> \\<bind>\n         (\\<lambda>b.\n             if b then FOREACH_body f (xs, \\<sigma>) \\<bind> W\n             else RETURN (xs, \\<sigma>))))\n                                  xb \\<bind>\n                                 (\\<lambda>(uu_, y). RETURN y))", "apply rprems"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a x' \\<sigma> b x xa xb.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   monadic_nfoldli x' c f \\<sigma>\n                   \\<le> \\<Down> Id\n                          (REC\\<^sub>T\n                            (\\<lambda>W (xs, \\<sigma>).\n                                ASSERT\n                                 (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n                                (\\<lambda>_.\n                                    if xs = [] then RETURN ([], \\<sigma>)\n                                    else c \\<sigma> \\<bind>\n   (\\<lambda>b.\n       if b then FOREACH_body f (xs, \\<sigma>) \\<bind> W\n       else RETURN (xs, \\<sigma>))))\n                            (x', \\<sigma>) \\<bind>\n                           (\\<lambda>(uu_, y). RETURN y));\n        FOREACH_inv xs0 I (a # x', \\<sigma>); (b, x) \\<in> bool_rel; b; x;\n        (xa, xb) \\<in> br (Pair x') (\\<lambda>_. x)\\<rbrakk>\n       \\<Longrightarrow> \\<Down> Id\n                          (REC\\<^sub>T\n                            (\\<lambda>W (xs, \\<sigma>).\n                                ASSERT\n                                 (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n                                (\\<lambda>_.\n                                    if xs = [] then RETURN ([], \\<sigma>)\n                                    else c \\<sigma> \\<bind>\n   (\\<lambda>b.\n       if b then FOREACH_body f (xs, \\<sigma>) \\<bind> W\n       else RETURN (xs, \\<sigma>))))\n                            (x', xa) \\<bind>\n                           (\\<lambda>(uu_, y). RETURN y))\n                         \\<le> \\<Down> Id\n                                (REC\\<^sub>T\n                                  (\\<lambda>W (xs, \\<sigma>).\nASSERT (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n(\\<lambda>_.\n    if xs = [] then RETURN ([], \\<sigma>)\n    else c \\<sigma> \\<bind>\n         (\\<lambda>b.\n             if b then FOREACH_body f (xs, \\<sigma>) \\<bind> W\n             else RETURN (xs, \\<sigma>))))\n                                  xb \\<bind>\n                                 (\\<lambda>(uu_, y). RETURN y))", "apply (simp add: br_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma monadic_nfoldli_arities[sepref_monadify_arity]:\n  \"monadic_nfoldli \\<equiv> \\<lambda>\\<^sub>2s c f \\<sigma>. SP (monadic_nfoldli)$s$(\\<lambda>\\<^sub>2x. c$x)$(\\<lambda>\\<^sub>2x \\<sigma>. f$x$\\<sigma>)$\\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monadic_nfoldli \\<equiv>\n    \\<lambda>x.\n       (#\\<lambda>xa.\n            (#\\<lambda>xb.\n                 (#\\<lambda>xc.\n                      (#SP monadic_nfoldli $ x $ (\\<lambda>x. (#xa $ x#)) $\n                        (\\<lambda>x. (#\\<lambda>xa. (#xb $ x $ xa#)#)) $\n                        xc#)#)#)#)", "by (simp_all)"], ["", "lemma monadic_nfoldli_comb[sepref_monadify_comb]:\n  \"\\<And>s c f \\<sigma>. (monadic_nfoldli)$s$c$f$\\<sigma> \\<equiv> \n    Refine_Basic.bind$(EVAL$s)$(\\<lambda>\\<^sub>2s. Refine_Basic.bind$(EVAL$\\<sigma>)$(\\<lambda>\\<^sub>2\\<sigma>. \n      SP (monadic_nfoldli)$s$c$f$\\<sigma>\n    ))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s c f \\<sigma>.\n       monadic_nfoldli $ s $ c $ f $ \\<sigma> \\<equiv>\n       (\\<bind>) $ (EVAL $ s) $\n       (\\<lambda>x.\n           (#(\\<bind>) $ (EVAL $ \\<sigma>) $\n             (\\<lambda>xa. (#SP monadic_nfoldli $ x $ c $ f $ xa#))#))", "by (simp_all)"], ["", "lemma list_rel_congD: \n  assumes A: \"(li,l)\\<in>\\<langle>S\\<rangle>list_rel\" \n  shows \"(li,l)\\<in>\\<langle>S\\<inter>(set li\\<times>set l)\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (li, l) \\<in> \\<langle>S \\<inter> set li \\<times> set l\\<rangle>list_rel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (li, l) \\<in> \\<langle>S \\<inter> set li \\<times> set l\\<rangle>list_rel", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (li, l) \\<in> \\<langle>S \\<inter> set li \\<times> set l\\<rangle>list_rel", "fix Si0 S0"], ["proof (state)\ngoal (1 subgoal):\n 1. (li, l) \\<in> \\<langle>S \\<inter> set li \\<times> set l\\<rangle>list_rel", "assume \"set li \\<subseteq> Si0\" \"set l \\<subseteq> S0\""], ["proof (state)\nthis:\n  set li \\<subseteq> Si0\n  set l \\<subseteq> S0\n\ngoal (1 subgoal):\n 1. (li, l) \\<in> \\<langle>S \\<inter> set li \\<times> set l\\<rangle>list_rel", "with A"], ["proof (chain)\npicking this:\n  (li, l) \\<in> \\<langle>S\\<rangle>list_rel\n  set li \\<subseteq> Si0\n  set l \\<subseteq> S0", "have \"(li,l)\\<in>\\<langle>S\\<inter>(Si0\\<times>S0)\\<rangle>list_rel\""], ["proof (prove)\nusing this:\n  (li, l) \\<in> \\<langle>S\\<rangle>list_rel\n  set li \\<subseteq> Si0\n  set l \\<subseteq> S0\n\ngoal (1 subgoal):\n 1. (li, l) \\<in> \\<langle>S \\<inter> Si0 \\<times> S0\\<rangle>list_rel", "by (induction rule: list_rel_induct) auto"], ["proof (state)\nthis:\n  (li, l) \\<in> \\<langle>S \\<inter> Si0 \\<times> S0\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (li, l) \\<in> \\<langle>S \\<inter> set li \\<times> set l\\<rangle>list_rel", "}"], ["proof (state)\nthis:\n  \\<lbrakk>set li \\<subseteq> ?Si0.2; set l \\<subseteq> ?S0.2\\<rbrakk>\n  \\<Longrightarrow> (li, l)\n                    \\<in> \\<langle>S \\<inter>\n                                   ?Si0.2 \\<times> ?S0.2\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (li, l) \\<in> \\<langle>S \\<inter> set li \\<times> set l\\<rangle>list_rel", "from this[OF order_refl order_refl]"], ["proof (chain)\npicking this:\n  (li, l) \\<in> \\<langle>S \\<inter> set li \\<times> set l\\<rangle>list_rel", "show ?thesis"], ["proof (prove)\nusing this:\n  (li, l) \\<in> \\<langle>S \\<inter> set li \\<times> set l\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (li, l) \\<in> \\<langle>S \\<inter> set li \\<times> set l\\<rangle>list_rel", "."], ["proof (state)\nthis:\n  (li, l) \\<in> \\<langle>S \\<inter> set li \\<times> set l\\<rangle>list_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monadic_nfoldli_refine[refine]:\n  assumes L: \"(li, l) \\<in> \\<langle>S\\<rangle>list_rel\"\n    and  [simp]: \"(si, s) \\<in> R\"\n    and CR[refine]: \"\\<And>si s. (si,s)\\<in>R \\<Longrightarrow> ci si \\<le>\\<Down>bool_rel (c s)\"\n    and [refine]: \"\\<And>xi x si s. \\<lbrakk> (xi,x)\\<in>S; x\\<in>set l; (si,s)\\<in>R; inres (c s) True \\<rbrakk> \\<Longrightarrow> fi xi si \\<le> \\<Down>R (f x s)\"\n  shows \"monadic_nfoldli li ci fi si \\<le> \\<Down> R (monadic_nfoldli l c f s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monadic_nfoldli li ci fi si \\<le> \\<Down> R (monadic_nfoldli l c f s)", "supply RELATESI[of \"S\\<inter>(set li\\<times>set l)\", refine_dref_RELATES]"], ["proof (prove)\ngoal (1 subgoal):\n 1. monadic_nfoldli li ci fi si \\<le> \\<Down> R (monadic_nfoldli l c f s)", "supply RELATESI[of R, refine_dref_RELATES]"], ["proof (prove)\ngoal (1 subgoal):\n 1. monadic_nfoldli li ci fi si \\<le> \\<Down> R (monadic_nfoldli l c f s)", "unfolding monadic_nfoldli_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. REC\\<^sub>T\n     (\\<lambda>D (l, s).\n         case l of [] \\<Rightarrow> RETURN s\n         | x # ls \\<Rightarrow>\n             ci s \\<bind>\n             (\\<lambda>b.\n                 if b then fi x s \\<bind> (\\<lambda>s'. D (ls, s'))\n                 else RETURN s))\n     (li, si)\n    \\<le> \\<Down> R\n           (REC\\<^sub>T\n             (\\<lambda>D (l, s).\n                 case l of [] \\<Rightarrow> RETURN s\n                 | x # ls \\<Rightarrow>\n                     c s \\<bind>\n                     (\\<lambda>b.\n                         if b then f x s \\<bind> (\\<lambda>s'. D (ls, s'))\n                         else RETURN s))\n             (l, s))", "apply (refine_rcg bind_refine')"], ["proof (prove)\ngoal (11 subgoals):\n 1. ((li, si), l, s) \\<in> ?R\n 2. \\<And>D Da x x' x1 x2 x1a x2a.\n       \\<lbrakk>\\<And>x x'.\n                   (x, x') \\<in> ?R \\<Longrightarrow>\n                   D x \\<le> \\<Down> R (Da x');\n        (x, x') \\<in> ?R; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x1a, x1)\n                         \\<in> \\<langle>?S15 D Da x x' x1 x2 x1a\n   x2a\\<rangle>list_rel\n 3. \\<And>D Da x x' x1 x2 x1a x2a.\n       \\<lbrakk>\\<And>x x'.\n                   (x, x') \\<in> ?R \\<Longrightarrow>\n                   D x \\<le> \\<Down> R (Da x');\n        (x, x') \\<in> ?R; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R\n 4. \\<And>D Da x x' x1 x2 x1a x2a xa xb ls lsa.\n       \\<lbrakk>\\<And>x x'.\n                   (x, x') \\<in> ?R \\<Longrightarrow>\n                   D x \\<le> \\<Down> R (Da x');\n        (x, x') \\<in> ?R; x' = (x1, x2); x = (x1a, x2a);\n        (xa, xb) \\<in> ?S15 D Da x x' x1 x2 x1a x2a;\n        (ls, lsa)\n        \\<in> \\<langle>?S15 D Da x x' x1 x2 x1a x2a\\<rangle>list_rel;\n        x1a = xa # ls; x1 = xb # lsa\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R\n 5. \\<And>D Da x x' x1 x2 x1a x2a xa xb ls lsa b ba.\n       \\<lbrakk>\\<And>x x'.\n                   (x, x') \\<in> ?R \\<Longrightarrow>\n                   D x \\<le> \\<Down> R (Da x');\n        (x, x') \\<in> ?R; x' = (x1, x2); x = (x1a, x2a);\n        (xa, xb) \\<in> ?S15 D Da x x' x1 x2 x1a x2a;\n        (ls, lsa)\n        \\<in> \\<langle>?S15 D Da x x' x1 x2 x1a x2a\\<rangle>list_rel;\n        x1a = xa # ls; x1 = xb # lsa; (b, ba) \\<in> bool_rel;\n        inres (ci x2a) b; inres (c x2) ba; nofail (ci x2a);\n        nofail (c x2)\\<rbrakk>\n       \\<Longrightarrow> b = ba\n 6. \\<And>D Da x x' x1 x2 x1a x2a xa xb ls lsa b ba.\n       \\<lbrakk>\\<And>x x'.\n                   (x, x') \\<in> ?R \\<Longrightarrow>\n                   D x \\<le> \\<Down> R (Da x');\n        (x, x') \\<in> ?R; x' = (x1, x2); x = (x1a, x2a);\n        (xa, xb) \\<in> ?S15 D Da x x' x1 x2 x1a x2a;\n        (ls, lsa)\n        \\<in> \\<langle>?S15 D Da x x' x1 x2 x1a x2a\\<rangle>list_rel;\n        x1a = xa # ls; x1 = xb # lsa; (b, ba) \\<in> bool_rel;\n        inres (ci x2a) b; inres (c x2) ba; nofail (ci x2a); nofail (c x2);\n        b; ba\\<rbrakk>\n       \\<Longrightarrow> (xa, xb) \\<in> S\n 7. \\<And>D Da x x' x1 x2 x1a x2a xa xb ls lsa b ba.\n       \\<lbrakk>\\<And>x x'.\n                   (x, x') \\<in> ?R \\<Longrightarrow>\n                   D x \\<le> \\<Down> R (Da x');\n        (x, x') \\<in> ?R; x' = (x1, x2); x = (x1a, x2a);\n        (xa, xb) \\<in> ?S15 D Da x x' x1 x2 x1a x2a;\n        (ls, lsa)\n        \\<in> \\<langle>?S15 D Da x x' x1 x2 x1a x2a\\<rangle>list_rel;\n        x1a = xa # ls; x1 = xb # lsa; (b, ba) \\<in> bool_rel;\n        inres (ci x2a) b; inres (c x2) ba; nofail (ci x2a); nofail (c x2);\n        b; ba\\<rbrakk>\n       \\<Longrightarrow> xb \\<in> set l\n 8. \\<And>D Da x x' x1 x2 x1a x2a xa xb ls lsa b ba.\n       \\<lbrakk>\\<And>x x'.\n                   (x, x') \\<in> ?R \\<Longrightarrow>\n                   D x \\<le> \\<Down> R (Da x');\n        (x, x') \\<in> ?R; x' = (x1, x2); x = (x1a, x2a);\n        (xa, xb) \\<in> ?S15 D Da x x' x1 x2 x1a x2a;\n        (ls, lsa)\n        \\<in> \\<langle>?S15 D Da x x' x1 x2 x1a x2a\\<rangle>list_rel;\n        x1a = xa # ls; x1 = xb # lsa; (b, ba) \\<in> bool_rel;\n        inres (ci x2a) b; inres (c x2) ba; nofail (ci x2a); nofail (c x2);\n        b; ba\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R\n 9. \\<And>D Da x x' x1 x2 x1a x2a xa xb ls lsa b ba.\n       \\<lbrakk>\\<And>x x'.\n                   (x, x') \\<in> ?R \\<Longrightarrow>\n                   D x \\<le> \\<Down> R (Da x');\n        (x, x') \\<in> ?R; x' = (x1, x2); x = (x1a, x2a);\n        (xa, xb) \\<in> ?S15 D Da x x' x1 x2 x1a x2a;\n        (ls, lsa)\n        \\<in> \\<langle>?S15 D Da x x' x1 x2 x1a x2a\\<rangle>list_rel;\n        x1a = xa # ls; x1 = xb # lsa; (b, ba) \\<in> bool_rel;\n        inres (ci x2a) b; inres (c x2) ba; nofail (ci x2a); nofail (c x2);\n        b; ba\\<rbrakk>\n       \\<Longrightarrow> inres (c x2) True\n 10. \\<And>D Da x x' x1 x2 x1a x2a xa xb ls lsa b ba s' s'a.\n        \\<lbrakk>\\<And>x x'.\n                    (x, x') \\<in> ?R \\<Longrightarrow>\n                    D x \\<le> \\<Down> R (Da x');\n         (x, x') \\<in> ?R; x' = (x1, x2); x = (x1a, x2a);\n         (xa, xb) \\<in> ?S15 D Da x x' x1 x2 x1a x2a;\n         (ls, lsa)\n         \\<in> \\<langle>?S15 D Da x x' x1 x2 x1a x2a\\<rangle>list_rel;\n         x1a = xa # ls; x1 = xb # lsa; (b, ba) \\<in> bool_rel;\n         inres (ci x2a) b; inres (c x2) ba; nofail (ci x2a); nofail (c x2);\n         b; ba; (s', s'a) \\<in> R; inres (fi xa x2a) s';\n         inres (f xb x2) s'a; nofail (fi xa x2a); nofail (f xb x2)\\<rbrakk>\n        \\<Longrightarrow> D (ls, s') \\<le> \\<Down> R (Da (lsa, s'a))\nA total of 11 subgoals...", "apply refine_dref_type"], ["proof (prove)\ngoal (11 subgoals):\n 1. ((li, si), l, s)\n    \\<in> \\<langle>S \\<inter>\n                   set li \\<times> set l\\<rangle>list_rel \\<times>\\<^sub>r\n          R\n 2. \\<And>D Da x x' x1 x2 x1a x2a.\n       \\<lbrakk>\\<And>x x'.\n                   (x, x')\n                   \\<in> \\<langle>S \\<inter>\n                                  set li \\<times>\n                                  set l\\<rangle>list_rel \\<times>\\<^sub>r\n                         R \\<Longrightarrow>\n                   D x \\<le> \\<Down> R (Da x');\n        (x, x')\n        \\<in> \\<langle>S \\<inter>\n                       set li \\<times>\n                       set l\\<rangle>list_rel \\<times>\\<^sub>r\n              R;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x1a, x1)\n                         \\<in> \\<langle>S \\<inter>\n  set li \\<times> set l\\<rangle>list_rel\n 3. \\<And>D Da x x' x1 x2 x1a x2a.\n       \\<lbrakk>\\<And>x x'.\n                   (x, x')\n                   \\<in> \\<langle>S \\<inter>\n                                  set li \\<times>\n                                  set l\\<rangle>list_rel \\<times>\\<^sub>r\n                         R \\<Longrightarrow>\n                   D x \\<le> \\<Down> R (Da x');\n        (x, x')\n        \\<in> \\<langle>S \\<inter>\n                       set li \\<times>\n                       set l\\<rangle>list_rel \\<times>\\<^sub>r\n              R;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R\n 4. \\<And>D Da x x' x1 x2 x1a x2a xa xb ls lsa.\n       \\<lbrakk>\\<And>x x'.\n                   (x, x')\n                   \\<in> \\<langle>S \\<inter>\n                                  set li \\<times>\n                                  set l\\<rangle>list_rel \\<times>\\<^sub>r\n                         R \\<Longrightarrow>\n                   D x \\<le> \\<Down> R (Da x');\n        (x, x')\n        \\<in> \\<langle>S \\<inter>\n                       set li \\<times>\n                       set l\\<rangle>list_rel \\<times>\\<^sub>r\n              R;\n        x' = (x1, x2); x = (x1a, x2a);\n        (xa, xb) \\<in> S \\<inter> set li \\<times> set l;\n        (ls, lsa)\n        \\<in> \\<langle>S \\<inter> set li \\<times> set l\\<rangle>list_rel;\n        x1a = xa # ls; x1 = xb # lsa\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R\n 5. \\<And>D Da x x' x1 x2 x1a x2a xa xb ls lsa b ba.\n       \\<lbrakk>\\<And>x x'.\n                   (x, x')\n                   \\<in> \\<langle>S \\<inter>\n                                  set li \\<times>\n                                  set l\\<rangle>list_rel \\<times>\\<^sub>r\n                         R \\<Longrightarrow>\n                   D x \\<le> \\<Down> R (Da x');\n        (x, x')\n        \\<in> \\<langle>S \\<inter>\n                       set li \\<times>\n                       set l\\<rangle>list_rel \\<times>\\<^sub>r\n              R;\n        x' = (x1, x2); x = (x1a, x2a);\n        (xa, xb) \\<in> S \\<inter> set li \\<times> set l;\n        (ls, lsa)\n        \\<in> \\<langle>S \\<inter> set li \\<times> set l\\<rangle>list_rel;\n        x1a = xa # ls; x1 = xb # lsa; (b, ba) \\<in> bool_rel;\n        inres (ci x2a) b; inres (c x2) ba; nofail (ci x2a);\n        nofail (c x2)\\<rbrakk>\n       \\<Longrightarrow> b = ba\n 6. \\<And>D Da x x' x1 x2 x1a x2a xa xb ls lsa b ba.\n       \\<lbrakk>\\<And>x x'.\n                   (x, x')\n                   \\<in> \\<langle>S \\<inter>\n                                  set li \\<times>\n                                  set l\\<rangle>list_rel \\<times>\\<^sub>r\n                         R \\<Longrightarrow>\n                   D x \\<le> \\<Down> R (Da x');\n        (x, x')\n        \\<in> \\<langle>S \\<inter>\n                       set li \\<times>\n                       set l\\<rangle>list_rel \\<times>\\<^sub>r\n              R;\n        x' = (x1, x2); x = (x1a, x2a);\n        (xa, xb) \\<in> S \\<inter> set li \\<times> set l;\n        (ls, lsa)\n        \\<in> \\<langle>S \\<inter> set li \\<times> set l\\<rangle>list_rel;\n        x1a = xa # ls; x1 = xb # lsa; (b, ba) \\<in> bool_rel;\n        inres (ci x2a) b; inres (c x2) ba; nofail (ci x2a); nofail (c x2);\n        b; ba\\<rbrakk>\n       \\<Longrightarrow> (xa, xb) \\<in> S\n 7. \\<And>D Da x x' x1 x2 x1a x2a xa xb ls lsa b ba.\n       \\<lbrakk>\\<And>x x'.\n                   (x, x')\n                   \\<in> \\<langle>S \\<inter>\n                                  set li \\<times>\n                                  set l\\<rangle>list_rel \\<times>\\<^sub>r\n                         R \\<Longrightarrow>\n                   D x \\<le> \\<Down> R (Da x');\n        (x, x')\n        \\<in> \\<langle>S \\<inter>\n                       set li \\<times>\n                       set l\\<rangle>list_rel \\<times>\\<^sub>r\n              R;\n        x' = (x1, x2); x = (x1a, x2a);\n        (xa, xb) \\<in> S \\<inter> set li \\<times> set l;\n        (ls, lsa)\n        \\<in> \\<langle>S \\<inter> set li \\<times> set l\\<rangle>list_rel;\n        x1a = xa # ls; x1 = xb # lsa; (b, ba) \\<in> bool_rel;\n        inres (ci x2a) b; inres (c x2) ba; nofail (ci x2a); nofail (c x2);\n        b; ba\\<rbrakk>\n       \\<Longrightarrow> xb \\<in> set l\n 8. \\<And>D Da x x' x1 x2 x1a x2a xa xb ls lsa b ba.\n       \\<lbrakk>\\<And>x x'.\n                   (x, x')\n                   \\<in> \\<langle>S \\<inter>\n                                  set li \\<times>\n                                  set l\\<rangle>list_rel \\<times>\\<^sub>r\n                         R \\<Longrightarrow>\n                   D x \\<le> \\<Down> R (Da x');\n        (x, x')\n        \\<in> \\<langle>S \\<inter>\n                       set li \\<times>\n                       set l\\<rangle>list_rel \\<times>\\<^sub>r\n              R;\n        x' = (x1, x2); x = (x1a, x2a);\n        (xa, xb) \\<in> S \\<inter> set li \\<times> set l;\n        (ls, lsa)\n        \\<in> \\<langle>S \\<inter> set li \\<times> set l\\<rangle>list_rel;\n        x1a = xa # ls; x1 = xb # lsa; (b, ba) \\<in> bool_rel;\n        inres (ci x2a) b; inres (c x2) ba; nofail (ci x2a); nofail (c x2);\n        b; ba\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> R\n 9. \\<And>D Da x x' x1 x2 x1a x2a xa xb ls lsa b ba.\n       \\<lbrakk>\\<And>x x'.\n                   (x, x')\n                   \\<in> \\<langle>S \\<inter>\n                                  set li \\<times>\n                                  set l\\<rangle>list_rel \\<times>\\<^sub>r\n                         R \\<Longrightarrow>\n                   D x \\<le> \\<Down> R (Da x');\n        (x, x')\n        \\<in> \\<langle>S \\<inter>\n                       set li \\<times>\n                       set l\\<rangle>list_rel \\<times>\\<^sub>r\n              R;\n        x' = (x1, x2); x = (x1a, x2a);\n        (xa, xb) \\<in> S \\<inter> set li \\<times> set l;\n        (ls, lsa)\n        \\<in> \\<langle>S \\<inter> set li \\<times> set l\\<rangle>list_rel;\n        x1a = xa # ls; x1 = xb # lsa; (b, ba) \\<in> bool_rel;\n        inres (ci x2a) b; inres (c x2) ba; nofail (ci x2a); nofail (c x2);\n        b; ba\\<rbrakk>\n       \\<Longrightarrow> inres (c x2) True\n 10. \\<And>D Da x x' x1 x2 x1a x2a xa xb ls lsa b ba s' s'a.\n        \\<lbrakk>\\<And>x x'.\n                    (x, x')\n                    \\<in> \\<langle>S \\<inter>\n                                   set li \\<times>\n                                   set l\\<rangle>list_rel \\<times>\\<^sub>r\n                          R \\<Longrightarrow>\n                    D x \\<le> \\<Down> R (Da x');\n         (x, x')\n         \\<in> \\<langle>S \\<inter>\n                        set li \\<times>\n                        set l\\<rangle>list_rel \\<times>\\<^sub>r\n               R;\n         x' = (x1, x2); x = (x1a, x2a);\n         (xa, xb) \\<in> S \\<inter> set li \\<times> set l;\n         (ls, lsa)\n         \\<in> \\<langle>S \\<inter> set li \\<times> set l\\<rangle>list_rel;\n         x1a = xa # ls; x1 = xb # lsa; (b, ba) \\<in> bool_rel;\n         inres (ci x2a) b; inres (c x2) ba; nofail (ci x2a); nofail (c x2);\n         b; ba; (s', s'a) \\<in> R; inres (fi xa x2a) s';\n         inres (f xb x2) s'a; nofail (fi xa x2a); nofail (f xb x2)\\<rbrakk>\n        \\<Longrightarrow> D (ls, s') \\<le> \\<Down> R (Da (lsa, s'a))\nA total of 11 subgoals...", "apply (vc_solve simp: list_rel_congD[OF L])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma monadic_FOREACH_itsl:\n  fixes R I tsl\n  shows \n    \"do { l \\<leftarrow> it_to_sorted_list R s; monadic_nfoldli l c f \\<sigma> } \n     \\<le> monadic_FOREACH R I s c f \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. it_to_sorted_list R s \\<bind>\n    (\\<lambda>l. monadic_nfoldli l c f \\<sigma>)\n    \\<le> monadic_FOREACH R I s c f \\<sigma>", "apply (rule refine_IdD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. it_to_sorted_list R s \\<bind>\n    (\\<lambda>l. monadic_nfoldli l c f \\<sigma>)\n    \\<le> \\<Down> Id (monadic_FOREACH R I s c f \\<sigma>)", "unfolding monadic_FOREACH_def it_to_sorted_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. SPEC\n     (\\<lambda>l. distinct l \\<and> s = set l \\<and> sorted_wrt R l) \\<bind>\n    (\\<lambda>l. monadic_nfoldli l c f \\<sigma>)\n    \\<le> \\<Down> Id\n           (ASSERT (finite s) \\<bind>\n            (\\<lambda>_.\n                SPEC\n                 (\\<lambda>l.\n                     distinct l \\<and>\n                     s = set l \\<and> sorted_wrt R l) \\<bind>\n                (\\<lambda>xs0.\n                    REC\\<^sub>T\n                     (\\<lambda>W (xs, \\<sigma>).\n                         ASSERT (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n                         (\\<lambda>_.\n                             if xs \\<noteq> []\n                             then c \\<sigma> \\<bind>\n                                  (\\<lambda>b.\nif b then FOREACH_body f (xs, \\<sigma>) \\<bind> W\nelse RETURN (xs, \\<sigma>))\n                             else RETURN (xs, \\<sigma>)))\n                     (xs0, \\<sigma>) \\<bind>\n                    (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>))))", "apply (refine_rcg)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l xs0.\n       \\<lbrakk>finite s; (l, xs0) \\<in> Id;\n        l \\<in> {l. distinct l \\<and> s = set l \\<and> sorted_wrt R l};\n        xs0\n        \\<in> {l. distinct l \\<and>\n                  s = set l \\<and> sorted_wrt R l}\\<rbrakk>\n       \\<Longrightarrow> monadic_nfoldli l c f \\<sigma>\n                         \\<le> \\<Down> Id\n                                (REC\\<^sub>T\n                                  (\\<lambda>W (xs, \\<sigma>).\nASSERT (FOREACH_inv xs0 I (xs, \\<sigma>)) \\<bind>\n(\\<lambda>_.\n    if xs \\<noteq> []\n    then c \\<sigma> \\<bind>\n         (\\<lambda>b.\n             if b then FOREACH_body f (xs, \\<sigma>) \\<bind> W\n             else RETURN (xs, \\<sigma>))\n    else RETURN (xs, \\<sigma>)))\n                                  (xs0, \\<sigma>) \\<bind>\n                                 (\\<lambda>(uu_, \\<sigma>).\n                                     RETURN \\<sigma>))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       distinct l \\<and> s = set l \\<and> sorted_wrt R l \\<Longrightarrow>\n       monadic_nfoldli l c f \\<sigma>\n       \\<le> REC\\<^sub>T\n              (\\<lambda>W (xs, \\<sigma>).\n                  ASSERT (FOREACH_inv l I (xs, \\<sigma>)) \\<bind>\n                  (\\<lambda>_.\n                      if xs = [] then RETURN (xs, \\<sigma>)\n                      else c \\<sigma> \\<bind>\n                           (\\<lambda>b.\n                               if b\n                               then FOREACH_body f (xs, \\<sigma>) \\<bind> W\n                               else RETURN (xs, \\<sigma>))))\n              (l, \\<sigma>) \\<bind>\n             (\\<lambda>(uu_, y). RETURN y)", "apply (rule monadic_nfoldli_rec[simplified])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma FOREACHoci_itsl:\n  fixes R I tsl\n  shows \n    \"do { l \\<leftarrow> it_to_sorted_list R s; nfoldli l c f \\<sigma> } \n     \\<le> FOREACHoci R I s c f \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. it_to_sorted_list R s \\<bind> (\\<lambda>l. nfoldli l c f \\<sigma>)\n    \\<le> FOREACH\\<^sub>O\\<^sub>C\\<^bsup>R,I\\<^esup> s c f \\<sigma>", "apply (rule refine_IdD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. it_to_sorted_list R s \\<bind> (\\<lambda>l. nfoldli l c f \\<sigma>)\n    \\<le> \\<Down> Id\n           (FOREACH\\<^sub>O\\<^sub>C\\<^bsup>R,I\\<^esup> s c f \\<sigma>)", "unfolding FOREACHoci_def it_to_sorted_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. SPEC\n     (\\<lambda>l. distinct l \\<and> s = set l \\<and> sorted_wrt R l) \\<bind>\n    (\\<lambda>l. nfoldli l c f \\<sigma>)\n    \\<le> \\<Down> Id\n           (ASSERT (finite s) \\<bind>\n            (\\<lambda>_.\n                SPEC\n                 (\\<lambda>xs.\n                     distinct xs \\<and>\n                     s = set xs \\<and> sorted_wrt R xs) \\<bind>\n                (\\<lambda>xs.\n                    WHILE\\<^sub>T\\<^bsup>\\<lambda>(it, \\<sigma>).\n      \\<exists>xs'. xs = xs' @ it \\<and> I (set it) \\<sigma>\\<^esup>\n                     (FOREACH_cond c) (FOREACH_body f)\n                     (xs, \\<sigma>) \\<bind>\n                    (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>))))", "apply refine_rcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l xs.\n       \\<lbrakk>finite s; (l, xs) \\<in> Id;\n        l \\<in> {l. distinct l \\<and> s = set l \\<and> sorted_wrt R l};\n        xs \\<in> {xs.\n                  distinct xs \\<and>\n                  s = set xs \\<and> sorted_wrt R xs}\\<rbrakk>\n       \\<Longrightarrow> nfoldli l c f \\<sigma>\n                         \\<le> \\<Down> Id\n                                (WHILE\\<^sub>T\\<^bsup>\\<lambda>(it,\n                   \\<sigma>).\n                   \\<exists>xs'.\n                      xs = xs' @ it \\<and> I (set it) \\<sigma>\\<^esup>\n                                  (FOREACH_cond c) (FOREACH_body f)\n                                  (xs, \\<sigma>) \\<bind>\n                                 (\\<lambda>(uu_, \\<sigma>).\n                                     RETURN \\<sigma>))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       distinct l \\<and> s = set l \\<and> sorted_wrt R l \\<Longrightarrow>\n       nfoldli l c f \\<sigma>\n       \\<le> WHILE\\<^sub>T\\<^bsup>\\<lambda>(it, \\<sigma>).\n                                     (\\<exists>xs'. l = xs' @ it) \\<and>\n                                     I (set it) \\<sigma>\\<^esup>\n              (FOREACH_cond c) (FOREACH_body f) (l, \\<sigma>) \\<bind>\n             (\\<lambda>(uu_, y). RETURN y)", "apply (rule nfoldli_while)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [def_pat_rules]:\n  \"FOREACHc \\<equiv> PR_CONST (FOREACHoci (\\<lambda>_ _. True) (\\<lambda>_ _. True))\"\n  \"FOREACHci$I \\<equiv> PR_CONST (FOREACHoci (\\<lambda>_ _. True) I)\"\n  \"FOREACHi$I \\<equiv> \\<lambda>\\<^sub>2s. PR_CONST (FOREACHoci (\\<lambda>_ _. True) I)$s$(\\<lambda>\\<^sub>2x. True)\"\n  \"FOREACH \\<equiv> FOREACHi$(\\<lambda>\\<^sub>2_ _. True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((FOREACH\\<^sub>C \\<equiv>\n      PR_CONST\n       FOREACH\\<^sub>O\\<^sub>C\\<^bsup>\\<lambda>_ _.\n   True,\\<lambda>_ _. True\\<^esup>) &&&\n     FOREACHci $ I \\<equiv>\n     PR_CONST\n      FOREACH\\<^sub>O\\<^sub>C\\<^bsup>\\<lambda>_ _. True,I\\<^esup>) &&&\n    (FOREACHi $ I \\<equiv>\n     \\<lambda>x.\n        (#PR_CONST\n           FOREACH\\<^sub>O\\<^sub>C\\<^bsup>\\<lambda>_ _. True,I\\<^esup> $\n          x $\n          (\\<lambda>x. (#True#))#)) &&&\n    FOREACH \\<equiv> FOREACHi $ (\\<lambda>x. (#\\<lambda>x. (#True#)#))", "by (simp_all add: \n    FOREACHci_def FOREACHi_def[abs_def] FOREACHc_def FOREACH_def[abs_def])"], ["", "term \"FOREACHoci R I\""], ["", "lemma id_FOREACHoci[id_rules]: \"PR_CONST (FOREACHoci R I) ::\\<^sub>i \n  TYPE('c set \\<Rightarrow> ('d \\<Rightarrow> bool) \\<Rightarrow> ('c \\<Rightarrow> 'd \\<Rightarrow> 'd nres) \\<Rightarrow> 'd \\<Rightarrow> 'd nres)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PR_CONST FOREACH\\<^sub>O\\<^sub>C\\<^bsup>R,I\\<^esup> ::\\<^sub>i\n    TYPE('c set\n         \\<Rightarrow> ('d \\<Rightarrow> bool)\n                       \\<Rightarrow> ('c\n\\<Rightarrow> 'd \\<Rightarrow> 'd nres)\n                                     \\<Rightarrow> 'd \\<Rightarrow> 'd nres)", "by simp"], ["", "text \\<open>We set up the monadify-phase such that all FOREACH-loops get\n  rewritten to the monadic version of FOREACH\\<close>"], ["", "lemma FOREACH_arities[sepref_monadify_arity]:\n  (*\"FOREACHc \\<equiv> FOREACHoci$(\\<lambda>\\<^sub>2_ _. True)$(\\<lambda>\\<^sub>2_ _. True)\"\n  \"FOREACHci \\<equiv> FOREACHoci$(\\<lambda>\\<^sub>2_ _. True)\"\n  \"FOREACHi \\<equiv> \\<lambda>\\<^sub>2I s. FOREACHci$I$s$(\\<lambda>\\<^sub>2x. True)\"\n  \"FOREACH \\<equiv> FOREACHi$(\\<lambda>\\<^sub>2_ _. True)\"*)\n  \"PR_CONST (FOREACHoci R I) \\<equiv> \\<lambda>\\<^sub>2s c f \\<sigma>. SP (PR_CONST (FOREACHoci R I))$s$(\\<lambda>\\<^sub>2x. c$x)$(\\<lambda>\\<^sub>2x \\<sigma>. f$x$\\<sigma>)$\\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PR_CONST FOREACH\\<^sub>O\\<^sub>C\\<^bsup>R,I\\<^esup> \\<equiv>\n    \\<lambda>x.\n       (#\\<lambda>xa.\n            (#\\<lambda>xb.\n                 (#\\<lambda>xc.\n                      (#SP (PR_CONST\n                             FOREACH\\<^sub>O\\<^sub>C\\<^bsup>R,I\\<^esup>) $\n                        x $\n                        (\\<lambda>x. (#xa $ x#)) $\n                        (\\<lambda>x. (#\\<lambda>xa. (#xb $ x $ xa#)#)) $\n                        xc#)#)#)#)", "by (simp_all)"], ["", "lemma FOREACHoci_comb[sepref_monadify_comb]:\n  \"\\<And>s c f \\<sigma>. (PR_CONST (FOREACHoci R I))$s$(\\<lambda>\\<^sub>2x. c x)$f$\\<sigma> \\<equiv> \n    Refine_Basic.bind$(EVAL$s)$(\\<lambda>\\<^sub>2s. Refine_Basic.bind$(EVAL$\\<sigma>)$(\\<lambda>\\<^sub>2\\<sigma>. \n      SP (PR_CONST (monadic_FOREACH R I))$s$(\\<lambda>\\<^sub>2x. (EVAL$(c x)))$f$\\<sigma>\n    ))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s c f \\<sigma>.\n       PR_CONST FOREACH\\<^sub>O\\<^sub>C\\<^bsup>R,I\\<^esup> $ s $\n       (\\<lambda>x. (#c x#)) $\n       f $\n       \\<sigma> \\<equiv>\n       (\\<bind>) $ (EVAL $ s) $\n       (\\<lambda>x.\n           (#(\\<bind>) $ (EVAL $ \\<sigma>) $\n             (\\<lambda>xa.\n                 (#SP (PR_CONST (monadic_FOREACH R I)) $ x $\n                   (\\<lambda>x. (#EVAL $ c x#)) $\n                   f $\n                   xa#))#))", "by (simp_all add: FOREACH_oci_to_monadic)"], ["", "subsubsection \"Imperative Version of nfoldli\""], ["", "text \\<open>We define an imperative version of \\<open>nfoldli\\<close>. It is the\n  equivalent to the monadic version in the nres-monad\\<close>"], ["", "definition \"imp_nfoldli l c f s \\<equiv> heap.fixp_fun (\\<lambda>D (l,s). case l of \n    [] \\<Rightarrow> return s\n  | x#ls \\<Rightarrow> do {\n      b\\<leftarrow>c s;\n      if b then do { s'\\<leftarrow>f x s; D (ls,s')} else return s\n    }\n  ) (l,s)\""], ["", "declare imp_nfoldli_def[code del]"], ["", "lemma imp_nfoldli_simps[simp,code]:\n  \"imp_nfoldli [] c f s = return s\"\n  \"imp_nfoldli (x#ls) c f s = (do {\n    b \\<leftarrow> c s;\n    if b then do { \n      s'\\<leftarrow>f x s; \n      imp_nfoldli ls c f s'\n    } else return s\n  })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_nfoldli [] c f s = return s &&&\n    imp_nfoldli (x # ls) c f s =\n    c s \\<bind>\n    (\\<lambda>b. if b then f x s \\<bind> imp_nfoldli ls c f else return s)", "apply -"], ["proof (prove)\ngoal (2 subgoals):\n 1. imp_nfoldli [] c f s = return s\n 2. imp_nfoldli (x # ls) c f s =\n    c s \\<bind>\n    (\\<lambda>b. if b then f x s \\<bind> imp_nfoldli ls c f else return s)", "unfolding imp_nfoldli_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. heap.fixp_fun\n     (\\<lambda>D (l, s).\n         case l of [] \\<Rightarrow> return s\n         | x # ls \\<Rightarrow>\n             c s \\<bind>\n             (\\<lambda>b.\n                 if b then f x s \\<bind> (\\<lambda>s'. D (ls, s'))\n                 else return s))\n     ([], s) =\n    return s\n 2. heap.fixp_fun\n     (\\<lambda>D (l, s).\n         case l of [] \\<Rightarrow> return s\n         | x # ls \\<Rightarrow>\n             c s \\<bind>\n             (\\<lambda>b.\n                 if b then f x s \\<bind> (\\<lambda>s'. D (ls, s'))\n                 else return s))\n     (x # ls, s) =\n    c s \\<bind>\n    (\\<lambda>b.\n        if b\n        then f x s \\<bind>\n             (\\<lambda>s'.\n                 heap.fixp_fun\n                  (\\<lambda>D (l, s).\n                      case l of [] \\<Rightarrow> return s\n                      | x # ls \\<Rightarrow>\n                          c s \\<bind>\n                          (\\<lambda>b.\n                              if b\n                              then f x s \\<bind> (\\<lambda>s'. D (ls, s'))\n                              else return s))\n                  (ls, s'))\n        else return s)", "apply (subst heap.mono_body_fixp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       mono_Heap\n        (\\<lambda>fa.\n            case x of ([], s) \\<Rightarrow> return s\n            | (x # ls, s) \\<Rightarrow>\n                c s \\<bind>\n                (\\<lambda>b.\n                    if b then f x s \\<bind> (\\<lambda>s'. fa (ls, s'))\n                    else return s))\n 2. (case ([], s) of ([], s) \\<Rightarrow> return s\n     | (x # ls, s) \\<Rightarrow>\n         c s \\<bind>\n         (\\<lambda>b.\n             if b\n             then f x s \\<bind>\n                  (\\<lambda>s'.\n                      heap.fixp_fun\n                       (\\<lambda>D (l, s).\n                           case l of [] \\<Rightarrow> return s\n                           | x # ls \\<Rightarrow>\n                               c s \\<bind>\n                               (\\<lambda>b.\n                                   if b\n                                   then f x s \\<bind>\n  (\\<lambda>s'. D (ls, s'))\n                                   else return s))\n                       (ls, s'))\n             else return s)) =\n    return s\n 3. heap.fixp_fun\n     (\\<lambda>D (l, s).\n         case l of [] \\<Rightarrow> return s\n         | x # ls \\<Rightarrow>\n             c s \\<bind>\n             (\\<lambda>b.\n                 if b then f x s \\<bind> (\\<lambda>s'. D (ls, s'))\n                 else return s))\n     (x # ls, s) =\n    c s \\<bind>\n    (\\<lambda>b.\n        if b\n        then f x s \\<bind>\n             (\\<lambda>s'.\n                 heap.fixp_fun\n                  (\\<lambda>D (l, s).\n                      case l of [] \\<Rightarrow> return s\n                      | x # ls \\<Rightarrow>\n                          c s \\<bind>\n                          (\\<lambda>b.\n                              if b\n                              then f x s \\<bind> (\\<lambda>s'. D (ls, s'))\n                              else return s))\n                  (ls, s'))\n        else return s)", "apply pf_mono"], ["proof (prove)\ngoal (2 subgoals):\n 1. (case ([], s) of ([], s) \\<Rightarrow> return s\n     | (x # ls, s) \\<Rightarrow>\n         c s \\<bind>\n         (\\<lambda>b.\n             if b\n             then f x s \\<bind>\n                  (\\<lambda>s'.\n                      heap.fixp_fun\n                       (\\<lambda>D (l, s).\n                           case l of [] \\<Rightarrow> return s\n                           | x # ls \\<Rightarrow>\n                               c s \\<bind>\n                               (\\<lambda>b.\n                                   if b\n                                   then f x s \\<bind>\n  (\\<lambda>s'. D (ls, s'))\n                                   else return s))\n                       (ls, s'))\n             else return s)) =\n    return s\n 2. heap.fixp_fun\n     (\\<lambda>D (l, s).\n         case l of [] \\<Rightarrow> return s\n         | x # ls \\<Rightarrow>\n             c s \\<bind>\n             (\\<lambda>b.\n                 if b then f x s \\<bind> (\\<lambda>s'. D (ls, s'))\n                 else return s))\n     (x # ls, s) =\n    c s \\<bind>\n    (\\<lambda>b.\n        if b\n        then f x s \\<bind>\n             (\\<lambda>s'.\n                 heap.fixp_fun\n                  (\\<lambda>D (l, s).\n                      case l of [] \\<Rightarrow> return s\n                      | x # ls \\<Rightarrow>\n                          c s \\<bind>\n                          (\\<lambda>b.\n                              if b\n                              then f x s \\<bind> (\\<lambda>s'. D (ls, s'))\n                              else return s))\n                  (ls, s'))\n        else return s)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap.fixp_fun\n     (\\<lambda>D (l, s).\n         case l of [] \\<Rightarrow> return s\n         | x # ls \\<Rightarrow>\n             c s \\<bind>\n             (\\<lambda>b.\n                 if b then f x s \\<bind> (\\<lambda>s'. D (ls, s'))\n                 else return s))\n     (x # ls, s) =\n    c s \\<bind>\n    (\\<lambda>b.\n        if b\n        then f x s \\<bind>\n             (\\<lambda>s'.\n                 heap.fixp_fun\n                  (\\<lambda>D (l, s).\n                      case l of [] \\<Rightarrow> return s\n                      | x # ls \\<Rightarrow>\n                          c s \\<bind>\n                          (\\<lambda>b.\n                              if b\n                              then f x s \\<bind> (\\<lambda>s'. D (ls, s'))\n                              else return s))\n                  (ls, s'))\n        else return s)", "apply (subst heap.mono_body_fixp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       mono_Heap\n        (\\<lambda>fa.\n            case x of ([], s) \\<Rightarrow> return s\n            | (x # ls, s) \\<Rightarrow>\n                c s \\<bind>\n                (\\<lambda>b.\n                    if b then f x s \\<bind> (\\<lambda>s'. fa (ls, s'))\n                    else return s))\n 2. (case (x # ls, s) of ([], s) \\<Rightarrow> return s\n     | (x # ls, s) \\<Rightarrow>\n         c s \\<bind>\n         (\\<lambda>b.\n             if b\n             then f x s \\<bind>\n                  (\\<lambda>s'.\n                      heap.fixp_fun\n                       (\\<lambda>D (l, s).\n                           case l of [] \\<Rightarrow> return s\n                           | x # ls \\<Rightarrow>\n                               c s \\<bind>\n                               (\\<lambda>b.\n                                   if b\n                                   then f x s \\<bind>\n  (\\<lambda>s'. D (ls, s'))\n                                   else return s))\n                       (ls, s'))\n             else return s)) =\n    c s \\<bind>\n    (\\<lambda>b.\n        if b\n        then f x s \\<bind>\n             (\\<lambda>s'.\n                 heap.fixp_fun\n                  (\\<lambda>D (l, s).\n                      case l of [] \\<Rightarrow> return s\n                      | x # ls \\<Rightarrow>\n                          c s \\<bind>\n                          (\\<lambda>b.\n                              if b\n                              then f x s \\<bind> (\\<lambda>s'. D (ls, s'))\n                              else return s))\n                  (ls, s'))\n        else return s)", "apply pf_mono"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (x # ls, s) of ([], s) \\<Rightarrow> return s\n     | (x # ls, s) \\<Rightarrow>\n         c s \\<bind>\n         (\\<lambda>b.\n             if b\n             then f x s \\<bind>\n                  (\\<lambda>s'.\n                      heap.fixp_fun\n                       (\\<lambda>D (l, s).\n                           case l of [] \\<Rightarrow> return s\n                           | x # ls \\<Rightarrow>\n                               c s \\<bind>\n                               (\\<lambda>b.\n                                   if b\n                                   then f x s \\<bind>\n  (\\<lambda>s'. D (ls, s'))\n                                   else return s))\n                       (ls, s'))\n             else return s)) =\n    c s \\<bind>\n    (\\<lambda>b.\n        if b\n        then f x s \\<bind>\n             (\\<lambda>s'.\n                 heap.fixp_fun\n                  (\\<lambda>D (l, s).\n                      case l of [] \\<Rightarrow> return s\n                      | x # ls \\<Rightarrow>\n                          c s \\<bind>\n                          (\\<lambda>b.\n                              if b\n                              then f x s \\<bind> (\\<lambda>s'. D (ls, s'))\n                              else return s))\n                  (ls, s'))\n        else return s)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma monadic_nfoldli_refine_aux:\n  assumes c_ref: \"\\<And>s s'. hn_refine \n    (\\<Gamma> * hn_ctxt Rs s' s) \n    (c s) \n    (\\<Gamma> * hn_ctxt Rs s' s) \n    bool_assn\n    (c' s')\"\n  assumes f_ref: \"\\<And>x x' s s'. hn_refine \n    (\\<Gamma> * hn_ctxt Rl x' x * hn_ctxt Rs s' s)\n    (f x s)\n    (\\<Gamma> * hn_invalid Rl x' x * hn_invalid Rs s' s) Rs\n    (f' x' s')\"\n\n  shows \"hn_refine \n    (\\<Gamma> * hn_ctxt (list_assn Rl) l' l * hn_ctxt Rs s' s) \n    (imp_nfoldli l c f s) \n    (\\<Gamma> * hn_invalid (list_assn Rl) l' l * hn_invalid Rs s' s) Rs\n    (monadic_nfoldli l' c' f' s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (\\<Gamma> * hn_ctxt (list_assn Rl) l' l * hn_ctxt Rs s' s)\n     (imp_nfoldli l c f s)\n     (\\<Gamma> * hn_invalid (list_assn Rl) l' l * hn_invalid Rs s' s) Rs\n     (monadic_nfoldli l' c' f' s')", "applyF (induct p\\<equiv>Rl l' l \n    arbitrary: s s'\n    rule: list_assn.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s s'.\n       hn_refine (\\<Gamma> * hn_ctxt (list_assn Rl) [] [] * hn_ctxt Rs s' s)\n        (imp_nfoldli [] c f s)\n        (\\<Gamma> * hn_invalid (list_assn Rl) [] [] * hn_invalid Rs s' s) Rs\n        (monadic_nfoldli [] c' f' s')\n 2. \\<And>a as ca cs s s'.\n       (\\<And>s s'.\n           hn_refine\n            (\\<Gamma> * hn_ctxt (list_assn Rl) as cs * hn_ctxt Rs s' s)\n            (imp_nfoldli cs c f s)\n            (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n             hn_invalid Rs s' s)\n            Rs (monadic_nfoldli as c' f' s')) \\<Longrightarrow>\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n         hn_ctxt Rs s' s)\n        (imp_nfoldli (ca # cs) c f s)\n        (\\<Gamma> * hn_invalid (list_assn Rl) (a # as) (ca # cs) *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli (a # as) c' f' s')\n 3. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) (v # va) [] * hn_ctxt Rs s' s)\n        (imp_nfoldli [] c f s)\n        (\\<Gamma> * hn_invalid (list_assn Rl) (v # va) [] *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli (v # va) c' f' s')\n 4. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) [] (v # va) * hn_ctxt Rs s' s)\n        (imp_nfoldli (v # va) c f s)\n        (\\<Gamma> * hn_invalid (list_assn Rl) [] (v # va) *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli [] c' f' s')", "applyF simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       hn_refine (\\<Gamma> * hn_ctxt Rs s' s) (return s)\n        (\\<Gamma> * hn_invalid (list_assn Rl) [] [] * hn_invalid Rs s' s) Rs\n        (RETURN s')", "apply (rule hn_refine_cons_post)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       hn_refine (\\<Gamma> * hn_ctxt Rs s' s) (return s) (?Q5 s s') Rs\n        (RETURN s')\n 2. \\<And>s s'.\n       ?Q5 s s' \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_invalid (list_assn Rl) [] [] * hn_invalid Rs s' s", "apply (rule hn_refine_frame[OF hnr_RETURN_pass])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<Gamma> * hn_ctxt Rs s' s \\<Longrightarrow>\\<^sub>t\n       ?F8 s s' * hn_ctxt Rs s' s\n 2. \\<And>s s'.\n       ?F8 s s' * hn_invalid Rs s' s \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_invalid (list_assn Rl) [] [] * hn_invalid Rs s' s", "apply (tactic \\<open>Sepref_Frame.frame_tac (K (K no_tac)) @{context} 1\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<Gamma> * hn_invalid Rs s' s \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_invalid (list_assn Rl) [] [] * hn_invalid Rs s' s", "apply (simp add: hn_ctxt_def ent_true_drop invalid_assn_const)"], ["proof (prove)\ngoal:\nNo subgoals!", "solved"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a as ca cs s s'.\n       (\\<And>s s'.\n           hn_refine\n            (\\<Gamma> * hn_ctxt (list_assn Rl) as cs * hn_ctxt Rs s' s)\n            (imp_nfoldli cs c f s)\n            (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n             hn_invalid Rs s' s)\n            Rs (monadic_nfoldli as c' f' s')) \\<Longrightarrow>\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n         hn_ctxt Rs s' s)\n        (imp_nfoldli (ca # cs) c f s)\n        (\\<Gamma> * hn_invalid (list_assn Rl) (a # as) (ca # cs) *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli (a # as) c' f' s')\n 2. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) (v # va) [] * hn_ctxt Rs s' s)\n        (imp_nfoldli [] c f s)\n        (\\<Gamma> * hn_invalid (list_assn Rl) (v # va) [] *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli (v # va) c' f' s')\n 3. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) [] (v # va) * hn_ctxt Rs s' s)\n        (imp_nfoldli (v # va) c f s)\n        (\\<Gamma> * hn_invalid (list_assn Rl) [] (v # va) *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli [] c' f' s')", "apply1 weaken_hnr_post"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a as ca cs s s'.\n       (\\<And>s s'.\n           hn_refine\n            (\\<Gamma> * hn_ctxt (list_assn Rl) as cs * hn_ctxt Rs s' s)\n            (imp_nfoldli cs c f s)\n            (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n             hn_invalid Rs s' s)\n            Rs (monadic_nfoldli as c' f' s')) \\<Longrightarrow>\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n         hn_ctxt Rs s' s)\n        (imp_nfoldli (ca # cs) c f s)\n        (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) (a # as) (ca # cs) *\n         hn_ctxt (\\<lambda>_ _. true) s' s)\n        Rs (monadic_nfoldli (a # as) c' f' s')\n 2. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) (v # va) [] * hn_ctxt Rs s' s)\n        (imp_nfoldli [] c f s)\n        (\\<Gamma> * hn_invalid (list_assn Rl) (v # va) [] *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli (v # va) c' f' s')\n 3. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) [] (v # va) * hn_ctxt Rs s' s)\n        (imp_nfoldli (v # va) c f s)\n        (\\<Gamma> * hn_invalid (list_assn Rl) [] (v # va) *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli [] c' f' s')", "apply1 (simp only: imp_nfoldli_simps monadic_nfoldli_simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a as ca cs s s'.\n       (\\<And>s s'.\n           hn_refine\n            (\\<Gamma> * hn_ctxt (list_assn Rl) as cs * hn_ctxt Rs s' s)\n            (imp_nfoldli cs c f s)\n            (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n             hn_invalid Rs s' s)\n            Rs (monadic_nfoldli as c' f' s')) \\<Longrightarrow>\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n         hn_ctxt Rs s' s)\n        (c s \\<bind>\n         (\\<lambda>b.\n             if b then f ca s \\<bind> imp_nfoldli cs c f else return s))\n        (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) (a # as) (ca # cs) *\n         hn_ctxt (\\<lambda>_ _. true) s' s)\n        Rs (c' s' \\<bind>\n            (\\<lambda>b.\n                if b then f' a s' \\<bind> monadic_nfoldli as c' f'\n                else RETURN s'))\n 2. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) (v # va) [] * hn_ctxt Rs s' s)\n        (imp_nfoldli [] c f s)\n        (\\<Gamma> * hn_invalid (list_assn Rl) (v # va) [] *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli (v # va) c' f' s')\n 3. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) [] (v # va) * hn_ctxt Rs s' s)\n        (imp_nfoldli (v # va) c f s)\n        (\\<Gamma> * hn_invalid (list_assn Rl) [] (v # va) *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli [] c' f' s')", "applyF (rule hnr_bind)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a as ca cs s s'.\n       (\\<And>s s'.\n           hn_refine\n            (\\<Gamma> * hn_ctxt (list_assn Rl) as cs * hn_ctxt Rs s' s)\n            (imp_nfoldli cs c f s)\n            (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n             hn_invalid Rs s' s)\n            Rs (monadic_nfoldli as c' f' s')) \\<Longrightarrow>\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n         hn_ctxt Rs s' s)\n        (c s) (?\\<Gamma>1.30 a as ca cs s s') (?Rh30 a as ca cs s s')\n        (c' s')\n 2. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN x \\<le> c' s'\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?\\<Gamma>1.30 a as ca cs s s' *\n                           hn_ctxt (?Rh30 a as ca cs s s') x x')\n                          (if x' then f ca s \\<bind> imp_nfoldli cs c f\n                           else return s)\n                          (?\\<Gamma>2.30 a as ca cs s s' x x') Rs\n                          (if x\n                           then f' a s' \\<bind> monadic_nfoldli as c' f'\n                           else RETURN s')\n 3. \\<And>a as ca cs s s' x x'.\n       (\\<And>s s'.\n           hn_refine\n            (\\<Gamma> * hn_ctxt (list_assn Rl) as cs * hn_ctxt Rs s' s)\n            (imp_nfoldli cs c f s)\n            (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n             hn_invalid Rs s' s)\n            Rs (monadic_nfoldli as c' f' s')) \\<Longrightarrow>\n       ?\\<Gamma>2.30 a as ca cs s s' x x' \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt (\\<lambda>_ _. true) (a # as) (ca # cs) *\n       hn_ctxt (\\<lambda>_ _. true) s' s *\n       hn_ctxt (?Rx30 a as ca cs s s') x x'", "apply1 (rule hn_refine_frame[OF c_ref])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a as ca cs s s'.\n       (\\<And>s s'.\n           hn_refine\n            (\\<Gamma> * hn_ctxt (list_assn Rl) as cs * hn_ctxt Rs s' s)\n            (imp_nfoldli cs c f s)\n            (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n             hn_invalid Rs s' s)\n            Rs (monadic_nfoldli as c' f' s')) \\<Longrightarrow>\n       \\<Gamma> * hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n       hn_ctxt Rs s' s \\<Longrightarrow>\\<^sub>t\n       ?F35 a as ca cs s s' * (\\<Gamma> * hn_ctxt Rs s' s)\n 2. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN x \\<le> c' s'\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?F35 a as ca cs s s' *\n                           (\\<Gamma> * hn_ctxt Rs s' s) *\n                           hn_val bool_rel x x')\n                          (if x' then f ca s \\<bind> imp_nfoldli cs c f\n                           else return s)\n                          (?\\<Gamma>2.30 a as ca cs s s' x x') Rs\n                          (if x\n                           then f' a s' \\<bind> monadic_nfoldli as c' f'\n                           else RETURN s')\n 3. \\<And>a as ca cs s s' x x'.\n       (\\<And>s s'.\n           hn_refine\n            (\\<Gamma> * hn_ctxt (list_assn Rl) as cs * hn_ctxt Rs s' s)\n            (imp_nfoldli cs c f s)\n            (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n             hn_invalid Rs s' s)\n            Rs (monadic_nfoldli as c' f' s')) \\<Longrightarrow>\n       ?\\<Gamma>2.30 a as ca cs s s' x x' \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt (\\<lambda>_ _. true) (a # as) (ca # cs) *\n       hn_ctxt (\\<lambda>_ _. true) s' s *\n       hn_ctxt (?Rx30 a as ca cs s s') x x'", "applyS (tactic \\<open>Sepref_Frame.frame_tac (K (K no_tac)) @{context} 1\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN x \\<le> c' s'\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n                           (\\<Gamma> * hn_ctxt Rs s' s) *\n                           hn_val bool_rel x x')\n                          (if x' then f ca s \\<bind> imp_nfoldli cs c f\n                           else return s)\n                          (?\\<Gamma>2.30 a as ca cs s s' x x') Rs\n                          (if x\n                           then f' a s' \\<bind> monadic_nfoldli as c' f'\n                           else RETURN s')\n 2. \\<And>a as ca cs s s' x x'.\n       (\\<And>s s'.\n           hn_refine\n            (\\<Gamma> * hn_ctxt (list_assn Rl) as cs * hn_ctxt Rs s' s)\n            (imp_nfoldli cs c f s)\n            (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n             hn_invalid Rs s' s)\n            Rs (monadic_nfoldli as c' f' s')) \\<Longrightarrow>\n       ?\\<Gamma>2.30 a as ca cs s s' x x' \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt (\\<lambda>_ _. true) (a # as) (ca # cs) *\n       hn_ctxt (\\<lambda>_ _. true) s' s *\n       hn_ctxt (?Rx30 a as ca cs s s') x x'", "applyF (rule hnr_If)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN x \\<le> c' s'\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n                         (\\<Gamma> * hn_ctxt Rs s' s) *\n                         hn_val bool_rel x x' \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>1.49 a as ca cs s s' x x' *\n                         hn_val bool_rel x x'\n 2. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN x \\<le> c' s'; x\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?\\<Gamma>1.49 a as ca cs s s' x x' *\n                           hn_val bool_rel x x')\n                          (f ca s \\<bind> imp_nfoldli cs c f)\n                          (?\\<Gamma>2b49 a as ca cs s s' x x') Rs\n                          (f' a s' \\<bind> monadic_nfoldli as c' f')\n 3. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN x \\<le> c' s'; \\<not> x\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?\\<Gamma>1.49 a as ca cs s s' x x' *\n                           hn_val bool_rel x x')\n                          (return s) (?\\<Gamma>2c49 a as ca cs s s' x x') Rs\n                          (RETURN s')\n 4. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN x \\<le> c' s'\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2b49 a as ca cs s s' x x' \\<or>\\<^sub>A\n                         ?\\<Gamma>2c49 a as ca cs s s' x\n                          x' \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.30 a as ca cs s s' x x'", "applyS (tactic \\<open>Sepref_Frame.frame_tac (K (K no_tac)) @{context} 1\\<close>)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN x \\<le> c' s'; x\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n                           \\<Gamma> *\n                           hn_ctxt Rs s' s *\n                           hn_val bool_rel x x')\n                          (f ca s \\<bind> imp_nfoldli cs c f)\n                          (?\\<Gamma>2b49 a as ca cs s s' x x') Rs\n                          (f' a s' \\<bind> monadic_nfoldli as c' f')\n 2. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN x \\<le> c' s'; \\<not> x\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n                           \\<Gamma> *\n                           hn_ctxt Rs s' s *\n                           hn_val bool_rel x x')\n                          (return s) (?\\<Gamma>2c49 a as ca cs s s' x x') Rs\n                          (RETURN s')\n 3. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN x \\<le> c' s'\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2b49 a as ca cs s s' x x' \\<or>\\<^sub>A\n                         ?\\<Gamma>2c49 a as ca cs s s' x\n                          x' \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.30 a as ca cs s s' x x'", "applyF (rule hnr_bind)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN x \\<le> c' s'; x\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n                           \\<Gamma> *\n                           hn_ctxt Rs s' s *\n                           hn_val bool_rel x x')\n                          (f ca s) (?\\<Gamma>1.64 a as ca cs s s' x x')\n                          (?Rh64 a as ca cs s s' x x') (f' a s')\n 2. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN x \\<le> c' s'; x; RETURN xa \\<le> f' a s'\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?\\<Gamma>1.64 a as ca cs s s' x x' *\n                           hn_ctxt (?Rh64 a as ca cs s s' x x') xa x'a)\n                          (imp_nfoldli cs c f x'a)\n                          (?\\<Gamma>2.64 a as ca cs s s' x x' xa x'a) Rs\n                          (monadic_nfoldli as c' f' xa)\n 3. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN x \\<le> c' s'; x\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.64 a as ca cs s s' x x' xa\n                          x'a \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2b49 a as ca cs s s' x x' *\n                         hn_ctxt (?Rx64 a as ca cs s s' x x') xa x'a", "apply1 (rule hn_refine_frame[OF f_ref])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN x \\<le> c' s'; x\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n                         \\<Gamma> *\n                         hn_ctxt Rs s' s *\n                         hn_val bool_rel x x' \\<Longrightarrow>\\<^sub>t\n                         ?F69 a as ca cs s s' x x' *\n                         (\\<Gamma> * hn_ctxt Rl a ca * hn_ctxt Rs s' s)\n 2. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN x \\<le> c' s'; x; RETURN xa \\<le> f' a s'\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?F69 a as ca cs s s' x x' *\n                           (\\<Gamma> * hn_invalid Rl a ca *\n                            hn_invalid Rs s' s) *\n                           hn_ctxt Rs xa x'a)\n                          (imp_nfoldli cs c f x'a)\n                          (?\\<Gamma>2.64 a as ca cs s s' x x' xa x'a) Rs\n                          (monadic_nfoldli as c' f' xa)\n 3. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN x \\<le> c' s'; x\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.64 a as ca cs s s' x x' xa\n                          x'a \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2b49 a as ca cs s s' x x' *\n                         hn_ctxt (?Rx64 a as ca cs s s' x x') xa x'a", "apply1 (simp add: assn_assoc)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN True \\<le> c' s'; x\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt Rl a ca * hn_ctxt (list_assn Rl) as cs *\n                         \\<Gamma> *\n                         hn_ctxt Rs s' s *\n                         hn_val bool_rel True x' \\<Longrightarrow>\\<^sub>t\n                         ?F69 a as ca cs s s' True x' * \\<Gamma> *\n                         hn_ctxt Rl a ca *\n                         hn_ctxt Rs s' s\n 2. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN x \\<le> c' s'; x; RETURN xa \\<le> f' a s'\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?F69 a as ca cs s s' x x' *\n                           (\\<Gamma> * hn_invalid Rl a ca *\n                            hn_invalid Rs s' s) *\n                           hn_ctxt Rs xa x'a)\n                          (imp_nfoldli cs c f x'a)\n                          (?\\<Gamma>2.64 a as ca cs s s' x x' xa x'a) Rs\n                          (monadic_nfoldli as c' f' xa)\n 3. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN x \\<le> c' s'; x\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.64 a as ca cs s s' x x' xa\n                          x'a \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2b49 a as ca cs s s' x x' *\n                         hn_ctxt (?Rx64 a as ca cs s s' x x') xa x'a", "apply1 (rule ent_imp_entt)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN True \\<le> c' s'; x\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt Rl a ca * hn_ctxt (list_assn Rl) as cs *\n                         \\<Gamma> *\n                         hn_ctxt Rs s' s *\n                         hn_val bool_rel True x' \\<Longrightarrow>\\<^sub>A\n                         ?F69 a as ca cs s s' True x' * \\<Gamma> *\n                         hn_ctxt Rl a ca *\n                         hn_ctxt Rs s' s\n 2. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN x \\<le> c' s'; x; RETURN xa \\<le> f' a s'\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?F69 a as ca cs s s' x x' *\n                           (\\<Gamma> * hn_invalid Rl a ca *\n                            hn_invalid Rs s' s) *\n                           hn_ctxt Rs xa x'a)\n                          (imp_nfoldli cs c f x'a)\n                          (?\\<Gamma>2.64 a as ca cs s s' x x' xa x'a) Rs\n                          (monadic_nfoldli as c' f' xa)\n 3. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN x \\<le> c' s'; x\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.64 a as ca cs s s' x x' xa\n                          x'a \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2b49 a as ca cs s s' x x' *\n                         hn_ctxt (?Rx64 a as ca cs s s' x x') xa x'a", "apply1 (fr_rot 1, rule fr_refl)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN True \\<le> c' s'; x\\<rbrakk>\n       \\<Longrightarrow> hn_val bool_rel True x' * hn_ctxt Rl a ca *\n                         hn_ctxt (list_assn Rl) as cs *\n                         \\<Gamma> \\<Longrightarrow>\\<^sub>A\n                         ?F69 a as ca cs s s' True x' * \\<Gamma> *\n                         hn_ctxt Rl a ca\n 2. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN x \\<le> c' s'; x; RETURN xa \\<le> f' a s'\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?F69 a as ca cs s s' x x' *\n                           (\\<Gamma> * hn_invalid Rl a ca *\n                            hn_invalid Rs s' s) *\n                           hn_ctxt Rs xa x'a)\n                          (imp_nfoldli cs c f x'a)\n                          (?\\<Gamma>2.64 a as ca cs s s' x x' xa x'a) Rs\n                          (monadic_nfoldli as c' f' xa)\n 3. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN x \\<le> c' s'; x\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.64 a as ca cs s s' x x' xa\n                          x'a \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2b49 a as ca cs s s' x x' *\n                         hn_ctxt (?Rx64 a as ca cs s s' x x') xa x'a", "apply1 (fr_rot 2, rule fr_refl)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN True \\<le> c' s'; x\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt (list_assn Rl) as cs * \\<Gamma> *\n                         hn_val bool_rel True x' \\<Longrightarrow>\\<^sub>A\n                         ?F69 a as ca cs s s' True x' * \\<Gamma>\n 2. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN x \\<le> c' s'; x; RETURN xa \\<le> f' a s'\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?F69 a as ca cs s s' x x' *\n                           (\\<Gamma> * hn_invalid Rl a ca *\n                            hn_invalid Rs s' s) *\n                           hn_ctxt Rs xa x'a)\n                          (imp_nfoldli cs c f x'a)\n                          (?\\<Gamma>2.64 a as ca cs s s' x x' xa x'a) Rs\n                          (monadic_nfoldli as c' f' xa)\n 3. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN x \\<le> c' s'; x\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.64 a as ca cs s s' x x' xa\n                          x'a \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2b49 a as ca cs s s' x x' *\n                         hn_ctxt (?Rx64 a as ca cs s s' x x') xa x'a", "apply1 (fr_rot 1, rule fr_refl)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN True \\<le> c' s'; x\\<rbrakk>\n       \\<Longrightarrow> hn_val bool_rel True x' *\n                         hn_ctxt (list_assn Rl) as\n                          cs \\<Longrightarrow>\\<^sub>A\n                         ?F69 a as ca cs s s' True x'\n 2. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN x \\<le> c' s'; x; RETURN xa \\<le> f' a s'\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?F69 a as ca cs s s' x x' *\n                           (\\<Gamma> * hn_invalid Rl a ca *\n                            hn_invalid Rs s' s) *\n                           hn_ctxt Rs xa x'a)\n                          (imp_nfoldli cs c f x'a)\n                          (?\\<Gamma>2.64 a as ca cs s s' x x' xa x'a) Rs\n                          (monadic_nfoldli as c' f' xa)\n 3. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN x \\<le> c' s'; x\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.64 a as ca cs s s' x x' xa\n                          x'a \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2b49 a as ca cs s s' x x' *\n                         hn_ctxt (?Rx64 a as ca cs s s' x x') xa x'a", "applyS (rule ent_refl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN x \\<le> c' s'; x; RETURN xa \\<le> f' a s'\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_val bool_rel x x' *\n                           hn_ctxt (list_assn Rl) as cs *\n                           (\\<Gamma> * hn_invalid Rl a ca *\n                            hn_invalid Rs s' s) *\n                           hn_ctxt Rs xa x'a)\n                          (imp_nfoldli cs c f x'a)\n                          (?\\<Gamma>2.64 a as ca cs s s' x x' xa x'a) Rs\n                          (monadic_nfoldli as c' f' xa)\n 2. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN x \\<le> c' s'; x\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.64 a as ca cs s s' x x' xa\n                          x'a \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2b49 a as ca cs s s' x x' *\n                         hn_ctxt (?Rx64 a as ca cs s s' x x') xa x'a", "applyF (rule hn_refine_frame)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN x \\<le> c' s'; x; RETURN xa \\<le> f' a s'\\<rbrakk>\n       \\<Longrightarrow> hn_refine (?P'100 a as ca cs s s' x x' xa x'a)\n                          (imp_nfoldli cs c f x'a)\n                          (?Q'100 a as ca cs s s' x x' xa x'a) Rs\n                          (monadic_nfoldli as c' f' xa)\n 2. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN x \\<le> c' s'; x; RETURN xa \\<le> f' a s'\\<rbrakk>\n       \\<Longrightarrow> hn_val bool_rel x x' *\n                         hn_ctxt (list_assn Rl) as cs *\n                         (\\<Gamma> * hn_invalid Rl a ca *\n                          hn_invalid Rs s' s) *\n                         hn_ctxt Rs xa x'a \\<Longrightarrow>\\<^sub>t\n                         ?F100 a as ca cs s s' x x' xa x'a *\n                         ?P'100 a as ca cs s s' x x' xa x'a", "applyS rprems"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN x \\<le> c' s'; x; RETURN xa \\<le> f' a s'\\<rbrakk>\n       \\<Longrightarrow> hn_val bool_rel x x' *\n                         hn_ctxt (list_assn Rl) as cs *\n                         (\\<Gamma> * hn_invalid Rl a ca *\n                          hn_invalid Rs s' s) *\n                         hn_ctxt Rs xa x'a \\<Longrightarrow>\\<^sub>t\n                         ?F100 a as ca cs s s' x x' xa x'a *\n                         (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                          hn_ctxt Rs xa x'a)", "apply1 (simp add: assn_assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN True \\<le> c' s'; x; RETURN xa \\<le> f' a s'\\<rbrakk>\n       \\<Longrightarrow> hn_val bool_rel True x' *\n                         hn_ctxt (list_assn Rl) as cs *\n                         \\<Gamma> *\n                         hn_invalid Rl a ca *\n                         hn_invalid Rs s' s *\n                         hn_ctxt Rs xa x'a \\<Longrightarrow>\\<^sub>t\n                         ?F100 a as ca cs s s' True x' xa x'a * \\<Gamma> *\n                         hn_ctxt (list_assn Rl) as cs *\n                         hn_ctxt Rs xa x'a", "apply1 (rule ent_imp_entt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN True \\<le> c' s'; x; RETURN xa \\<le> f' a s'\\<rbrakk>\n       \\<Longrightarrow> hn_val bool_rel True x' *\n                         hn_ctxt (list_assn Rl) as cs *\n                         \\<Gamma> *\n                         hn_invalid Rl a ca *\n                         hn_invalid Rs s' s *\n                         hn_ctxt Rs xa x'a \\<Longrightarrow>\\<^sub>A\n                         ?F100 a as ca cs s s' True x' xa x'a * \\<Gamma> *\n                         hn_ctxt (list_assn Rl) as cs *\n                         hn_ctxt Rs xa x'a", "apply (rule fr_refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN True \\<le> c' s'; x; RETURN xa \\<le> f' a s'\\<rbrakk>\n       \\<Longrightarrow> hn_val bool_rel True x' *\n                         hn_ctxt (list_assn Rl) as cs *\n                         \\<Gamma> *\n                         hn_invalid Rl a ca *\n                         hn_invalid Rs s' s \\<Longrightarrow>\\<^sub>A\n                         ?F100 a as ca cs s s' True x' xa x'a * \\<Gamma> *\n                         hn_ctxt (list_assn Rl) as cs", "apply1 (fr_rot 3, rule fr_refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN True \\<le> c' s'; x; RETURN xa \\<le> f' a s'\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> * hn_invalid Rl a ca *\n                         hn_invalid Rs s' s *\n                         hn_val bool_rel True x' \\<Longrightarrow>\\<^sub>A\n                         ?F100 a as ca cs s s' True x' xa x'a * \\<Gamma>", "apply1 (fr_rot 3, rule fr_refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN True \\<le> c' s'; x; RETURN xa \\<le> f' a s'\\<rbrakk>\n       \\<Longrightarrow> hn_invalid Rl a ca * hn_invalid Rs s' s *\n                         hn_val bool_rel True x' \\<Longrightarrow>\\<^sub>A\n                         ?F100 a as ca cs s s' True x' xa x'a", "applyS (rule ent_refl)"], ["proof (prove)\ngoal:\nNo subgoals!", "solved"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN x \\<le> c' s'; x\\<rbrakk>\n       \\<Longrightarrow> hn_invalid Rl a ca * hn_invalid Rs s' s *\n                         hn_val bool_rel x x' *\n                         (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                          hn_invalid Rs xa x'a) \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2b49 a as ca cs s s' x x' *\n                         hn_ctxt (?Rx64 a as ca cs s s' x x') xa x'a", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN True \\<le> c' s'; x\\<rbrakk>\n       \\<Longrightarrow> hn_invalid Rl a ca * hn_invalid Rs s' s *\n                         hn_val bool_rel True x' *\n                         (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                          hn_invalid Rs xa x'a) \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2b49 a as ca cs s s' True x' *\n                         hn_ctxt (?Rx64 a as ca cs s s' True x') xa x'a", "applyS (tactic \\<open>Sepref_Frame.frame_tac (K (K no_tac)) @{context} 1\\<close>)"], ["proof (prove)\ngoal:\nNo subgoals!", "solved"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN x \\<le> c' s'; \\<not> x\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n                           \\<Gamma> *\n                           hn_ctxt Rs s' s *\n                           hn_val bool_rel x x')\n                          (return s) (?\\<Gamma>2c49 a as ca cs s s' x x') Rs\n                          (RETURN s')\n 2. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN x \\<le> c' s'\\<rbrakk>\n       \\<Longrightarrow> hn_invalid Rl a ca * hn_invalid Rs s' s *\n                         hn_val bool_rel x x' *\n                         \\<Gamma> *\n                         hn_invalid (list_assn Rl) as cs \\<or>\\<^sub>A\n                         ?\\<Gamma>2c49 a as ca cs s s' x\n                          x' \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.30 a as ca cs s s' x x'", "apply1 (rule hn_refine_frame[OF hnr_RETURN_pass])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN x \\<le> c' s'; \\<not> x\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n                         \\<Gamma> *\n                         hn_ctxt Rs s' s *\n                         hn_val bool_rel x x' \\<Longrightarrow>\\<^sub>t\n                         ?F254 a as ca cs s s' x x' * hn_ctxt Rs s' s\n 2. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN x \\<le> c' s'\\<rbrakk>\n       \\<Longrightarrow> hn_invalid Rl a ca * hn_invalid Rs s' s *\n                         hn_val bool_rel x x' *\n                         \\<Gamma> *\n                         hn_invalid (list_assn Rl) as cs \\<or>\\<^sub>A\n                         ?F254 a as ca cs s s' x x' *\n                         hn_invalid Rs s' s \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.30 a as ca cs s s' x x'", "applyS (tactic \\<open>Sepref_Frame.frame_tac (K (K no_tac)) @{context} 1\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN x \\<le> c' s'\\<rbrakk>\n       \\<Longrightarrow> hn_invalid Rl a ca * hn_invalid Rs s' s *\n                         hn_val bool_rel x x' *\n                         \\<Gamma> *\n                         hn_invalid (list_assn Rl) as cs \\<or>\\<^sub>A\n                         hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n                         \\<Gamma> *\n                         hn_val bool_rel x x' *\n                         hn_invalid Rs s' s \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.30 a as ca cs s s' x x'", "apply1 (simp add: assn_assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c' f' s');\n        RETURN x \\<le> c' s'\\<rbrakk>\n       \\<Longrightarrow> hn_invalid Rl a ca * hn_invalid Rs s' s *\n                         hn_val bool_rel x x' *\n                         \\<Gamma> *\n                         hn_invalid (list_assn Rl) as cs \\<or>\\<^sub>A\n                         hn_ctxt Rl a ca * hn_ctxt (list_assn Rl) as cs *\n                         \\<Gamma> *\n                         hn_val bool_rel x x' *\n                         hn_invalid Rs s' s \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.30 a as ca cs s s' x x'", "applyS (tactic \\<open>Sepref_Frame.merge_tac (K (K no_tac)) @{context} 1\\<close>)"], ["proof (prove)\ngoal:\nNo subgoals!", "solved"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as ca cs s s' x x'.\n       (\\<And>s s'.\n           hn_refine\n            (\\<Gamma> * hn_ctxt (list_assn Rl) as cs * hn_ctxt Rs s' s)\n            (imp_nfoldli cs c f s)\n            (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n             hn_invalid Rs s' s)\n            Rs (monadic_nfoldli as c' f' s')) \\<Longrightarrow>\n       \\<Gamma> * hn_val bool_rel x x' * hn_invalid Rs s' s *\n       hn_invalid (list_assn Rl) as cs *\n       hn_invalid Rl a ca \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt (\\<lambda>_ _. true) (a # as) (ca # cs) *\n       hn_ctxt (\\<lambda>_ _. true) s' s *\n       hn_ctxt (?Rx30 a as ca cs s s') x x'", "apply (rule enttI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as ca cs s s' x x'.\n       (\\<And>s s'.\n           hn_refine\n            (\\<Gamma> * hn_ctxt (list_assn Rl) as cs * hn_ctxt Rs s' s)\n            (imp_nfoldli cs c f s)\n            (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n             hn_invalid Rs s' s)\n            Rs (monadic_nfoldli as c' f' s')) \\<Longrightarrow>\n       \\<Gamma> * hn_val bool_rel x x' * hn_invalid Rs s' s *\n       hn_invalid (list_assn Rl) as cs *\n       hn_invalid Rl a ca \\<Longrightarrow>\\<^sub>A\n       \\<Gamma> * hn_ctxt (\\<lambda>_ _. true) (a # as) (ca # cs) *\n       hn_ctxt (\\<lambda>_ _. true) s' s *\n       hn_ctxt (?Rx30 a as ca cs s s') x x' *\n       true", "apply (fr_rot_rhs 1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as ca cs s s' x x'.\n       (\\<And>s s'.\n           hn_refine\n            (\\<Gamma> * hn_ctxt (list_assn Rl) as cs * hn_ctxt Rs s' s)\n            (imp_nfoldli cs c f s)\n            (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n             hn_invalid Rs s' s)\n            Rs (monadic_nfoldli as c' f' s')) \\<Longrightarrow>\n       \\<Gamma> * hn_val bool_rel x x' * hn_invalid Rs s' s *\n       hn_invalid (list_assn Rl) as cs *\n       hn_invalid Rl a ca \\<Longrightarrow>\\<^sub>A\n       true * \\<Gamma> * hn_ctxt (\\<lambda>_ _. true) (a # as) (ca # cs) *\n       hn_ctxt (\\<lambda>_ _. true) s' s *\n       hn_ctxt (?Rx30 a as ca cs s s') x x'", "apply (fr_rot 3, rule fr_refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as ca cs s s' x x'.\n       (\\<And>s s'.\n           hn_refine\n            (\\<Gamma> * hn_ctxt (list_assn Rl) as cs * hn_ctxt Rs s' s)\n            (imp_nfoldli cs c f s)\n            (\\<Gamma> * hn_invalid (list_assn Rl) as cs *\n             hn_invalid Rs s' s)\n            Rs (monadic_nfoldli as c' f' s')) \\<Longrightarrow>\n       hn_invalid Rs s' s * hn_invalid (list_assn Rl) as cs *\n       hn_invalid Rl a ca *\n       \\<Gamma> \\<Longrightarrow>\\<^sub>A\n       true * \\<Gamma> * hn_ctxt (\\<lambda>_ _. true) (a # as) (ca # cs) *\n       hn_ctxt (\\<lambda>_ _. true) s' s", "applyS (fr_rot 3, rule ent_star_mono[rotated]; sep_auto simp: hn_ctxt_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "solved"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) (v # va) [] * hn_ctxt Rs s' s)\n        (imp_nfoldli [] c f s)\n        (\\<Gamma> * hn_invalid (list_assn Rl) (v # va) [] *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli (v # va) c' f' s')\n 2. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) [] (v # va) * hn_ctxt Rs s' s)\n        (imp_nfoldli (v # va) c f s)\n        (\\<Gamma> * hn_invalid (list_assn Rl) [] (v # va) *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli [] c' f' s')", "applyS (simp add: hn_ctxt_def invalid_assn_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) [] (v # va) * hn_ctxt Rs s' s)\n        (imp_nfoldli (v # va) c f s)\n        (\\<Gamma> * hn_invalid (list_assn Rl) [] (v # va) *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli [] c' f' s')", "applyS (rule, sep_auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "solved"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hn_monadic_nfoldli:\n  assumes FR: \"P \\<Longrightarrow>\\<^sub>t \\<Gamma> * hn_ctxt (list_assn Rl) l' l * hn_ctxt Rs s' s\"\n  assumes c_ref: \"\\<And>s s'. hn_refine \n    (\\<Gamma> * hn_ctxt Rs s' s) \n    (c s) \n    (\\<Gamma> * hn_ctxt Rs s' s)\n    bool_assn \n    (c'$s')\"\n  assumes f_ref: \"\\<And>x x' s s'. hn_refine \n    (\\<Gamma> * hn_ctxt Rl x' x * hn_ctxt Rs s' s)\n    (f x s)\n    (\\<Gamma> * hn_invalid Rl x' x * hn_invalid Rs s' s) Rs\n    (f'$x'$s')\"\n  shows \"hn_refine \n    P \n    (imp_nfoldli l c f s) \n    (\\<Gamma> * hn_invalid (list_assn Rl) l' l * hn_invalid Rs s' s)\n    Rs\n    (monadic_nfoldli$l'$c'$f'$s')\n    \""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine P (imp_nfoldli l c f s)\n     (\\<Gamma> * hn_invalid (list_assn Rl) l' l * hn_invalid Rs s' s) Rs\n     (monadic_nfoldli $ l' $ c' $ f' $ s')", "apply (rule hn_refine_cons_pre[OF FR])"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (\\<Gamma> * hn_ctxt (list_assn Rl) l' l * hn_ctxt Rs s' s)\n     (imp_nfoldli l c f s)\n     (\\<Gamma> * hn_invalid (list_assn Rl) l' l * hn_invalid Rs s' s) Rs\n     (monadic_nfoldli $ l' $ c' $ f' $ s')", "unfolding APP_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (\\<Gamma> * hn_ctxt (list_assn Rl) l' l * hn_ctxt Rs s' s)\n     (imp_nfoldli l c f s)\n     (\\<Gamma> * hn_invalid (list_assn Rl) l' l * hn_invalid Rs s' s) Rs\n     (monadic_nfoldli l' c' f' s')", "apply (rule monadic_nfoldli_refine_aux)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       hn_refine (\\<Gamma> * hn_ctxt Rs s' s) (c s)\n        (\\<Gamma> * hn_ctxt Rs s' s) bool_assn (c' s')\n 2. \\<And>x x' s s'.\n       hn_refine (\\<Gamma> * hn_ctxt Rl x' x * hn_ctxt Rs s' s) (f x s)\n        (\\<Gamma> * hn_invalid Rl x' x * hn_invalid Rs s' s) Rs (f' x' s')", "apply (rule c_ref[unfolded APP_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x' s s'.\n       hn_refine (\\<Gamma> * hn_ctxt Rl x' x * hn_ctxt Rs s' s) (f x s)\n        (\\<Gamma> * hn_invalid Rl x' x * hn_invalid Rs s' s) Rs (f' x' s')", "apply (rule f_ref[unfolded APP_def])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \n  imp_foreach :: \"('b \\<Rightarrow> 'c list Heap) \\<Rightarrow> 'b \\<Rightarrow> ('a \\<Rightarrow> bool Heap) \\<Rightarrow> ('c \\<Rightarrow> 'a \\<Rightarrow> 'a Heap) \\<Rightarrow> 'a \\<Rightarrow> 'a Heap\"\n  where\n    \"imp_foreach tsl s c f \\<sigma> \\<equiv> do { l \\<leftarrow> tsl s; imp_nfoldli l c f \\<sigma>}\""], ["", "lemma heap_fixp_mono[partial_function_mono]:\n  assumes [partial_function_mono]: \n    \"\\<And>x d. mono_Heap (\\<lambda>xa. B x xa d)\"\n    \"\\<And>Z xa. mono_Heap (\\<lambda>a. B a Z xa)\" \n  shows \"mono_Heap (\\<lambda>x. heap.fixp_fun (\\<lambda>D \\<sigma>. B x D \\<sigma>) \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono_Heap (\\<lambda>x. heap.fixp_fun (B x) \\<sigma>)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       heap.le_fun x y \\<Longrightarrow>\n       Heap_ord (heap.fixp_fun (B x) \\<sigma>)\n        (heap.fixp_fun (B y) \\<sigma>)", "apply (rule ccpo.fixp_mono[OF heap.ccpo, THEN fun_ordD])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       heap.le_fun x y \\<Longrightarrow>\n       monotone heap.le_fun heap.le_fun (B x)\n 2. \\<And>x y.\n       heap.le_fun x y \\<Longrightarrow>\n       monotone heap.le_fun heap.le_fun (B y)\n 3. \\<And>x y Z.\n       heap.le_fun x y \\<Longrightarrow> heap.le_fun (B x Z) (B y Z)", "apply (rule mono_fun_fun_cnv, erule thin_rl, pf_mono)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y Z.\n       heap.le_fun x y \\<Longrightarrow> heap.le_fun (B x Z) (B y Z)", "apply (rule fun_ordI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y Z xa.\n       heap.le_fun x y \\<Longrightarrow> Heap_ord (B x Z xa) (B y Z xa)", "apply (erule monotoneD[of \"fun_ord Heap_ord\" Heap_ord, rotated])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y Z xa. mono_Heap (\\<lambda>a. B a Z xa)", "apply pf_mono"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma imp_nfoldli_mono[partial_function_mono]:\n  assumes [partial_function_mono]: \"\\<And>x \\<sigma>. mono_Heap (\\<lambda>fa. f fa x \\<sigma>)\"\n  shows \"mono_Heap (\\<lambda>x. imp_nfoldli l c (f x) \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono_Heap (\\<lambda>x. imp_nfoldli l c (f x) \\<sigma>)", "unfolding imp_nfoldli_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mono_Heap\n     (\\<lambda>x.\n         heap.fixp_fun\n          (\\<lambda>D (l, s).\n              case l of [] \\<Rightarrow> return s\n              | xa # ls \\<Rightarrow>\n                  c s \\<bind>\n                  (\\<lambda>b.\n                      if b then f x xa s \\<bind> (\\<lambda>s'. D (ls, s'))\n                      else return s))\n          (l, \\<sigma>))", "by pf_mono"], ["", "lemma imp_foreach_mono[partial_function_mono]:\n  assumes [partial_function_mono]: \"\\<And>x \\<sigma>. mono_Heap (\\<lambda>fa. f fa x \\<sigma>)\"\n  shows \"mono_Heap (\\<lambda>x. imp_foreach tsl l c (f x) \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono_Heap (\\<lambda>x. imp_foreach tsl l c (f x) \\<sigma>)", "unfolding imp_foreach_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mono_Heap\n     (\\<lambda>x.\n         tsl l \\<bind> (\\<lambda>l. imp_nfoldli l c (f x) \\<sigma>))", "by pf_mono"], ["", "(* Inline foreach and nfoldli as fixed-points *)"], ["", "lemmas [sepref_opt_simps] = imp_foreach_def"], ["", "(*imp_nfoldli_def*)"], ["", "definition  \n  \"IS_TO_SORTED_LIST \\<Omega> Rs Rk tsl \\<equiv> (tsl,it_to_sorted_list \\<Omega>) \\<in> (Rs)\\<^sup>k \\<rightarrow>\\<^sub>a list_assn Rk\""], ["", "lemma IS_TO_SORTED_LISTI:\n  assumes \"(tsl,PR_CONST (it_to_sorted_list \\<Omega>)) \\<in> (Rs)\\<^sup>k \\<rightarrow>\\<^sub>a list_assn Rk\"\n  shows \"IS_TO_SORTED_LIST \\<Omega> Rs Rk tsl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IS_TO_SORTED_LIST \\<Omega> Rs Rk tsl", "using assms"], ["proof (prove)\nusing this:\n  (tsl, PR_CONST (it_to_sorted_list \\<Omega>))\n  \\<in> Rs\\<^sup>k \\<rightarrow>\\<^sub>a list_assn Rk\n\ngoal (1 subgoal):\n 1. IS_TO_SORTED_LIST \\<Omega> Rs Rk tsl", "unfolding IS_TO_SORTED_LIST_def PR_CONST_def"], ["proof (prove)\nusing this:\n  (tsl, it_to_sorted_list \\<Omega>)\n  \\<in> Rs\\<^sup>k \\<rightarrow>\\<^sub>a list_assn Rk\n\ngoal (1 subgoal):\n 1. (tsl, it_to_sorted_list \\<Omega>)\n    \\<in> Rs\\<^sup>k \\<rightarrow>\\<^sub>a list_assn Rk", "."], ["", "lemma hn_monadic_FOREACH[sepref_comb_rules]:\n  assumes \"INDEP Rk\" \"INDEP Rs\" \"INDEP R\\<sigma>\"\n  assumes FR: \"P \\<Longrightarrow>\\<^sub>t \\<Gamma> * hn_ctxt Rs s' s * hn_ctxt R\\<sigma> \\<sigma>' \\<sigma>\"\n  assumes STL: \"GEN_ALGO tsl (IS_TO_SORTED_LIST ordR Rs Rk)\"\n  assumes c_ref: \"\\<And>\\<sigma> \\<sigma>'. hn_refine \n    (\\<Gamma> * hn_ctxt Rs s' s * hn_ctxt R\\<sigma> \\<sigma>' \\<sigma>) \n    (c \\<sigma>) \n    (\\<Gamma>c \\<sigma>' \\<sigma>) \n    bool_assn \n    (c' \\<sigma>')\"\n  assumes C_FR: \n    \"\\<And>\\<sigma>' \\<sigma>. TERM monadic_FOREACH \\<Longrightarrow> \n      \\<Gamma>c \\<sigma>' \\<sigma> \\<Longrightarrow>\\<^sub>t \\<Gamma> * hn_ctxt Rs s' s * hn_ctxt R\\<sigma> \\<sigma>' \\<sigma>\"\n\n  assumes f_ref: \"\\<And>x' x \\<sigma>' \\<sigma>. hn_refine \n    (\\<Gamma> * hn_ctxt Rs s' s * hn_ctxt Rk x' x * hn_ctxt R\\<sigma> \\<sigma>' \\<sigma>)\n    (f x \\<sigma>)\n    (\\<Gamma>f x' x \\<sigma>' \\<sigma>) R\\<sigma>\n    (f' x' \\<sigma>')\"\n  assumes F_FR: \"\\<And>x' x \\<sigma>' \\<sigma>. TERM monadic_FOREACH \\<Longrightarrow> \\<Gamma>f x' x \\<sigma>' \\<sigma> \\<Longrightarrow>\\<^sub>t \n    \\<Gamma> * hn_ctxt Rs s' s * hn_ctxt Pfx x' x * hn_ctxt Pf\\<sigma> \\<sigma>' \\<sigma>\"\n\n  shows \"hn_refine \n    P \n    (imp_foreach tsl s c f \\<sigma>) \n    (\\<Gamma> * hn_ctxt Rs s' s * hn_invalid R\\<sigma> \\<sigma>' \\<sigma>)\n    R\\<sigma>\n    ((PR_CONST (monadic_FOREACH ordR I))\n      $s'$(\\<lambda>\\<^sub>2\\<sigma>'. c' \\<sigma>')$(\\<lambda>\\<^sub>2x' \\<sigma>'. f' x' \\<sigma>')$\\<sigma>'\n    )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine P (imp_foreach tsl s c f \\<sigma>)\n     (\\<Gamma> * hn_ctxt Rs s' s * hn_invalid R\\<sigma> \\<sigma>' \\<sigma>)\n     R\\<sigma>\n     (PR_CONST (monadic_FOREACH ordR I) $ s' $ (\\<lambda>x. (#c' x#)) $\n      (\\<lambda>x. (#\\<lambda>xa. (#f' x xa#)#)) $\n      \\<sigma>')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. hn_refine P (imp_foreach tsl s c f \\<sigma>)\n     (\\<Gamma> * hn_ctxt Rs s' s * hn_invalid R\\<sigma> \\<sigma>' \\<sigma>)\n     R\\<sigma>\n     (PR_CONST (monadic_FOREACH ordR I) $ s' $ (\\<lambda>x. (#c' x#)) $\n      (\\<lambda>x. (#\\<lambda>xa. (#f' x xa#)#)) $\n      \\<sigma>')", "from STL"], ["proof (chain)\npicking this:\n  GEN_ALGO tsl (IS_TO_SORTED_LIST ordR Rs Rk)", "have STL: \"(tsl,it_to_sorted_list ordR) \\<in> (Rs)\\<^sup>k \\<rightarrow>\\<^sub>a list_assn Rk\""], ["proof (prove)\nusing this:\n  GEN_ALGO tsl (IS_TO_SORTED_LIST ordR Rs Rk)\n\ngoal (1 subgoal):\n 1. (tsl, it_to_sorted_list ordR)\n    \\<in> Rs\\<^sup>k \\<rightarrow>\\<^sub>a list_assn Rk", "unfolding GEN_ALGO_def IS_TO_SORTED_LIST_def"], ["proof (prove)\nusing this:\n  (tsl, it_to_sorted_list ordR)\n  \\<in> Rs\\<^sup>k \\<rightarrow>\\<^sub>a list_assn Rk\n\ngoal (1 subgoal):\n 1. (tsl, it_to_sorted_list ordR)\n    \\<in> Rs\\<^sup>k \\<rightarrow>\\<^sub>a list_assn Rk", "by simp"], ["proof (state)\nthis:\n  (tsl, it_to_sorted_list ordR)\n  \\<in> Rs\\<^sup>k \\<rightarrow>\\<^sub>a list_assn Rk\n\ngoal (1 subgoal):\n 1. hn_refine P (imp_foreach tsl s c f \\<sigma>)\n     (\\<Gamma> * hn_ctxt Rs s' s * hn_invalid R\\<sigma> \\<sigma>' \\<sigma>)\n     R\\<sigma>\n     (PR_CONST (monadic_FOREACH ordR I) $ s' $ (\\<lambda>x. (#c' x#)) $\n      (\\<lambda>x. (#\\<lambda>xa. (#f' x xa#)#)) $\n      \\<sigma>')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine P (imp_foreach tsl s c f \\<sigma>)\n     (\\<Gamma> * hn_ctxt Rs s' s * hn_invalid R\\<sigma> \\<sigma>' \\<sigma>)\n     R\\<sigma>\n     (PR_CONST (monadic_FOREACH ordR I) $ s' $ (\\<lambda>x. (#c' x#)) $\n      (\\<lambda>x. (#\\<lambda>xa. (#f' x xa#)#)) $\n      \\<sigma>')", "apply (rule hn_refine_cons_pre[OF FR])"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine\n     (\\<Gamma> * hn_ctxt Rs s' s * hn_ctxt R\\<sigma> \\<sigma>' \\<sigma>)\n     (imp_foreach tsl s c f \\<sigma>)\n     (\\<Gamma> * hn_ctxt Rs s' s * hn_invalid R\\<sigma> \\<sigma>' \\<sigma>)\n     R\\<sigma>\n     (PR_CONST (monadic_FOREACH ordR I) $ s' $ (\\<lambda>x. (#c' x#)) $\n      (\\<lambda>x. (#\\<lambda>xa. (#f' x xa#)#)) $\n      \\<sigma>')", "apply weaken_hnr_post"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine\n     (\\<Gamma> * hn_ctxt Rs s' s * hn_ctxt R\\<sigma> \\<sigma>' \\<sigma>)\n     (imp_foreach tsl s c f \\<sigma>)\n     (\\<Gamma> * hn_ctxt Rs s' s *\n      hn_ctxt (\\<lambda>_ _. true) \\<sigma>' \\<sigma>)\n     R\\<sigma>\n     (PR_CONST (monadic_FOREACH ordR I) $ s' $ (\\<lambda>x. (#c' x#)) $\n      (\\<lambda>x. (#\\<lambda>xa. (#f' x xa#)#)) $\n      \\<sigma>')", "unfolding APP_def PROTECT2_def PR_CONST_def imp_foreach_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine\n     (\\<Gamma> * hn_ctxt Rs s' s * hn_ctxt R\\<sigma> \\<sigma>' \\<sigma>)\n     (tsl s \\<bind> (\\<lambda>l. imp_nfoldli l c f \\<sigma>))\n     (\\<Gamma> * hn_ctxt Rs s' s *\n      hn_ctxt (\\<lambda>_ _. true) \\<sigma>' \\<sigma>)\n     R\\<sigma> (monadic_FOREACH ordR I s' c' f' \\<sigma>')", "apply (rule hn_refine_ref[OF monadic_FOREACH_itsl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine\n     (\\<Gamma> * hn_ctxt Rs s' s * hn_ctxt R\\<sigma> \\<sigma>' \\<sigma>)\n     (tsl s \\<bind> (\\<lambda>l. imp_nfoldli l c f \\<sigma>))\n     (\\<Gamma> * hn_ctxt Rs s' s *\n      hn_ctxt (\\<lambda>_ _. true) \\<sigma>' \\<sigma>)\n     R\\<sigma>\n     (it_to_sorted_list ordR s' \\<bind>\n      (\\<lambda>l. monadic_nfoldli l c' f' \\<sigma>'))", "apply (rule hn_refine_guessI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. hn_refine\n     (\\<Gamma> * hn_ctxt Rs s' s * hn_ctxt R\\<sigma> \\<sigma>' \\<sigma>)\n     ?f11\n     (\\<Gamma> * hn_ctxt Rs s' s *\n      hn_ctxt (\\<lambda>_ _. true) \\<sigma>' \\<sigma>)\n     R\\<sigma>\n     (it_to_sorted_list ordR s' \\<bind>\n      (\\<lambda>l. monadic_nfoldli l c' f' \\<sigma>'))\n 2. ?f11 = tsl s \\<bind> (\\<lambda>l. imp_nfoldli l c f \\<sigma>)", "apply (rule hnr_bind)"], ["proof (prove)\ngoal (4 subgoals):\n 1. hn_refine\n     (\\<Gamma> * hn_ctxt Rs s' s * hn_ctxt R\\<sigma> \\<sigma>' \\<sigma>)\n     ?m'14 ?\\<Gamma>1.14 ?Rh14 (it_to_sorted_list ordR s')\n 2. \\<And>x x'.\n       RETURN x \\<le> it_to_sorted_list ordR s' \\<Longrightarrow>\n       hn_refine (?\\<Gamma>1.14 * hn_ctxt ?Rh14 x x') (?f'14 x')\n        (?\\<Gamma>2.14 x x') R\\<sigma> (monadic_nfoldli x c' f' \\<sigma>')\n 3. \\<And>x x'.\n       ?\\<Gamma>2.14 x x' \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt Rs s' s *\n       hn_ctxt (\\<lambda>_ _. true) \\<sigma>' \\<sigma> *\n       hn_ctxt ?Rx14 x x'\n 4. ?m'14 \\<bind> ?f'14 =\n    tsl s \\<bind> (\\<lambda>l. imp_nfoldli l c f \\<sigma>)", "apply (rule hn_refine_frame)"], ["proof (prove)\ngoal (5 subgoals):\n 1. hn_refine ?P'18 ?m'14 ?Q'18 ?Rh14 (it_to_sorted_list ordR s')\n 2. \\<Gamma> * hn_ctxt Rs s' s *\n    hn_ctxt R\\<sigma> \\<sigma>' \\<sigma> \\<Longrightarrow>\\<^sub>t\n    ?F18 * ?P'18\n 3. \\<And>x x'.\n       RETURN x \\<le> it_to_sorted_list ordR s' \\<Longrightarrow>\n       hn_refine (?F18 * ?Q'18 * hn_ctxt ?Rh14 x x') (?f'14 x')\n        (?\\<Gamma>2.14 x x') R\\<sigma> (monadic_nfoldli x c' f' \\<sigma>')\n 4. \\<And>x x'.\n       ?\\<Gamma>2.14 x x' \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt Rs s' s *\n       hn_ctxt (\\<lambda>_ _. true) \\<sigma>' \\<sigma> *\n       hn_ctxt ?Rx14 x x'\n 5. ?m'14 \\<bind> ?f'14 =\n    tsl s \\<bind> (\\<lambda>l. imp_nfoldli l c f \\<sigma>)", "apply (rule STL[to_hnr, unfolded APP_def])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<Gamma> * hn_ctxt Rs s' s *\n    hn_ctxt R\\<sigma> \\<sigma>' \\<sigma> \\<Longrightarrow>\\<^sub>t\n    ?F18 * hn_ctxt Rs s' ?xi21\n 2. \\<And>x x'.\n       RETURN x \\<le> it_to_sorted_list ordR s' \\<Longrightarrow>\n       hn_refine (?F18 * hn_ctxt Rs s' ?xi21 * hn_ctxt (list_assn Rk) x x')\n        (?f'14 x') (?\\<Gamma>2.14 x x') R\\<sigma>\n        (monadic_nfoldli x c' f' \\<sigma>')\n 3. \\<And>x x'.\n       ?\\<Gamma>2.14 x x' \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt Rs s' s *\n       hn_ctxt (\\<lambda>_ _. true) \\<sigma>' \\<sigma> *\n       hn_ctxt ?Rx14 x x'\n 4. tsl ?xi21 \\<bind> ?f'14 =\n    tsl s \\<bind> (\\<lambda>l. imp_nfoldli l c f \\<sigma>)", "apply (tactic \\<open>Sepref_Frame.frame_tac (K (K no_tac)) @{context} 1\\<close>)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x x'.\n       RETURN x \\<le> it_to_sorted_list ordR s' \\<Longrightarrow>\n       hn_refine\n        (\\<Gamma> * hn_ctxt R\\<sigma> \\<sigma>' \\<sigma> * hn_ctxt Rs s' s *\n         hn_ctxt (list_assn Rk) x x')\n        (?f'14 x') (?\\<Gamma>2.14 x x') R\\<sigma>\n        (monadic_nfoldli x c' f' \\<sigma>')\n 2. \\<And>x x'.\n       ?\\<Gamma>2.14 x x' \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt Rs s' s *\n       hn_ctxt (\\<lambda>_ _. true) \\<sigma>' \\<sigma> *\n       hn_ctxt ?Rx14 x x'\n 3. tsl s \\<bind> ?f'14 =\n    tsl s \\<bind> (\\<lambda>l. imp_nfoldli l c f \\<sigma>)", "apply (rule hn_monadic_nfoldli[unfolded APP_def])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x x'.\n       RETURN x \\<le> it_to_sorted_list ordR s' \\<Longrightarrow>\n       \\<Gamma> * hn_ctxt R\\<sigma> \\<sigma>' \\<sigma> * hn_ctxt Rs s' s *\n       hn_ctxt (list_assn Rk) x x' \\<Longrightarrow>\\<^sub>t\n       ?\\<Gamma>29 x x' * hn_ctxt (list_assn (?Rl29 x x')) x (?l30 x') *\n       hn_ctxt R\\<sigma> \\<sigma>' (?s33 x')\n 2. \\<And>x x' s s'a.\n       RETURN x \\<le> it_to_sorted_list ordR s' \\<Longrightarrow>\n       hn_refine (?\\<Gamma>29 x x' * hn_ctxt R\\<sigma> s'a s) (?c31 x' s)\n        (?\\<Gamma>29 x x' * hn_ctxt R\\<sigma> s'a s) bool_assn (c' s'a)\n 3. \\<And>x x' xa x'a s s'a.\n       RETURN x \\<le> it_to_sorted_list ordR s' \\<Longrightarrow>\n       hn_refine\n        (?\\<Gamma>29 x x' * hn_ctxt (?Rl29 x x') x'a xa *\n         hn_ctxt R\\<sigma> s'a s)\n        (?f32 x' xa s)\n        (?\\<Gamma>29 x x' * hn_invalid (?Rl29 x x') x'a xa *\n         hn_invalid R\\<sigma> s'a s)\n        R\\<sigma> (f' x'a s'a)\n 4. \\<And>x x'.\n       ?\\<Gamma>29 x x' * hn_invalid (list_assn (?Rl29 x x')) x (?l30 x') *\n       hn_invalid R\\<sigma> \\<sigma>' (?s33 x') \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt Rs s' s *\n       hn_ctxt (\\<lambda>_ _. true) \\<sigma>' \\<sigma> *\n       hn_ctxt ?Rx14 x x'\n 5. tsl s \\<bind>\n    (\\<lambda>x'. imp_nfoldli (?l30 x') (?c31 x') (?f32 x') (?s33 x')) =\n    tsl s \\<bind> (\\<lambda>l. imp_nfoldli l c f \\<sigma>)", "apply (tactic \\<open>Sepref_Frame.frame_tac (K (K no_tac)) @{context} 1\\<close>)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x x' sa s'a.\n       RETURN x \\<le> it_to_sorted_list ordR s' \\<Longrightarrow>\n       hn_refine (\\<Gamma> * hn_ctxt Rs s' s * hn_ctxt R\\<sigma> s'a sa)\n        (?c31 x' sa) (\\<Gamma> * hn_ctxt Rs s' s * hn_ctxt R\\<sigma> s'a sa)\n        bool_assn (c' s'a)\n 2. \\<And>x x' xa x'a sa s'a.\n       RETURN x \\<le> it_to_sorted_list ordR s' \\<Longrightarrow>\n       hn_refine\n        (\\<Gamma> * hn_ctxt Rs s' s * hn_ctxt Rk x'a xa *\n         hn_ctxt R\\<sigma> s'a sa)\n        (?f32 x' xa sa)\n        (\\<Gamma> * hn_ctxt Rs s' s * hn_invalid Rk x'a xa *\n         hn_invalid R\\<sigma> s'a sa)\n        R\\<sigma> (f' x'a s'a)\n 3. \\<And>x x'.\n       \\<Gamma> * hn_ctxt Rs s' s * hn_invalid (list_assn Rk) x x' *\n       hn_invalid R\\<sigma> \\<sigma>' \\<sigma> \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt Rs s' s *\n       hn_ctxt (\\<lambda>_ _. true) \\<sigma>' \\<sigma> *\n       hn_ctxt ?Rx14 x x'\n 4. tsl s \\<bind>\n    (\\<lambda>x'. imp_nfoldli x' (?c31 x') (?f32 x') \\<sigma>) =\n    tsl s \\<bind> (\\<lambda>l. imp_nfoldli l c f \\<sigma>)", "apply (rule hn_refine_cons_post)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x x' sa s'a.\n       RETURN x \\<le> it_to_sorted_list ordR s' \\<Longrightarrow>\n       hn_refine (\\<Gamma> * hn_ctxt Rs s' s * hn_ctxt R\\<sigma> s'a sa)\n        (?c31 x' sa) (?Q44 x x' sa s'a) bool_assn (c' s'a)\n 2. \\<And>x x' sa s'a.\n       RETURN x \\<le> it_to_sorted_list ordR s' \\<Longrightarrow>\n       ?Q44 x x' sa s'a \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt Rs s' s * hn_ctxt R\\<sigma> s'a sa\n 3. \\<And>x x' xa x'a sa s'a.\n       RETURN x \\<le> it_to_sorted_list ordR s' \\<Longrightarrow>\n       hn_refine\n        (\\<Gamma> * hn_ctxt Rs s' s * hn_ctxt Rk x'a xa *\n         hn_ctxt R\\<sigma> s'a sa)\n        (?f32 x' xa sa)\n        (\\<Gamma> * hn_ctxt Rs s' s * hn_invalid Rk x'a xa *\n         hn_invalid R\\<sigma> s'a sa)\n        R\\<sigma> (f' x'a s'a)\n 4. \\<And>x x'.\n       \\<Gamma> * hn_ctxt Rs s' s * hn_invalid (list_assn Rk) x x' *\n       hn_invalid R\\<sigma> \\<sigma>' \\<sigma> \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt Rs s' s *\n       hn_ctxt (\\<lambda>_ _. true) \\<sigma>' \\<sigma> *\n       hn_ctxt ?Rx14 x x'\n 5. tsl s \\<bind>\n    (\\<lambda>x'. imp_nfoldli x' (?c31 x') (?f32 x') \\<sigma>) =\n    tsl s \\<bind> (\\<lambda>l. imp_nfoldli l c f \\<sigma>)", "apply (rule c_ref[unfolded APP_def])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x x' sa s'a.\n       RETURN x \\<le> it_to_sorted_list ordR s' \\<Longrightarrow>\n       \\<Gamma>c s'a sa \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt Rs s' s * hn_ctxt R\\<sigma> s'a sa\n 2. \\<And>x x' xa x'a sa s'a.\n       RETURN x \\<le> it_to_sorted_list ordR s' \\<Longrightarrow>\n       hn_refine\n        (\\<Gamma> * hn_ctxt Rs s' s * hn_ctxt Rk x'a xa *\n         hn_ctxt R\\<sigma> s'a sa)\n        (?f32 x' xa sa)\n        (\\<Gamma> * hn_ctxt Rs s' s * hn_invalid Rk x'a xa *\n         hn_invalid R\\<sigma> s'a sa)\n        R\\<sigma> (f' x'a s'a)\n 3. \\<And>x x'.\n       \\<Gamma> * hn_ctxt Rs s' s * hn_invalid (list_assn Rk) x x' *\n       hn_invalid R\\<sigma> \\<sigma>' \\<sigma> \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt Rs s' s *\n       hn_ctxt (\\<lambda>_ _. true) \\<sigma>' \\<sigma> *\n       hn_ctxt ?Rx14 x x'\n 4. tsl s \\<bind> (\\<lambda>x'. imp_nfoldli x' c (?f32 x') \\<sigma>) =\n    tsl s \\<bind> (\\<lambda>l. imp_nfoldli l c f \\<sigma>)", "apply (rule C_FR)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x x' s s'a.\n       RETURN x \\<le> it_to_sorted_list ordR s' \\<Longrightarrow>\n       TERM monadic_FOREACH\n 2. \\<And>x x' xa x'a sa s'a.\n       RETURN x \\<le> it_to_sorted_list ordR s' \\<Longrightarrow>\n       hn_refine\n        (\\<Gamma> * hn_ctxt Rs s' s * hn_ctxt Rk x'a xa *\n         hn_ctxt R\\<sigma> s'a sa)\n        (?f32 x' xa sa)\n        (\\<Gamma> * hn_ctxt Rs s' s * hn_invalid Rk x'a xa *\n         hn_invalid R\\<sigma> s'a sa)\n        R\\<sigma> (f' x'a s'a)\n 3. \\<And>x x'.\n       \\<Gamma> * hn_ctxt Rs s' s * hn_invalid (list_assn Rk) x x' *\n       hn_invalid R\\<sigma> \\<sigma>' \\<sigma> \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt Rs s' s *\n       hn_ctxt (\\<lambda>_ _. true) \\<sigma>' \\<sigma> *\n       hn_ctxt ?Rx14 x x'\n 4. tsl s \\<bind> (\\<lambda>x'. imp_nfoldli x' c (?f32 x') \\<sigma>) =\n    tsl s \\<bind> (\\<lambda>l. imp_nfoldli l c f \\<sigma>)", "apply (rule TERMI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x x' xa x'a sa s'a.\n       RETURN x \\<le> it_to_sorted_list ordR s' \\<Longrightarrow>\n       hn_refine\n        (\\<Gamma> * hn_ctxt Rs s' s * hn_ctxt Rk x'a xa *\n         hn_ctxt R\\<sigma> s'a sa)\n        (?f32 x' xa sa)\n        (\\<Gamma> * hn_ctxt Rs s' s * hn_invalid Rk x'a xa *\n         hn_invalid R\\<sigma> s'a sa)\n        R\\<sigma> (f' x'a s'a)\n 2. \\<And>x x'.\n       \\<Gamma> * hn_ctxt Rs s' s * hn_invalid (list_assn Rk) x x' *\n       hn_invalid R\\<sigma> \\<sigma>' \\<sigma> \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt Rs s' s *\n       hn_ctxt (\\<lambda>_ _. true) \\<sigma>' \\<sigma> *\n       hn_ctxt ?Rx14 x x'\n 3. tsl s \\<bind> (\\<lambda>x'. imp_nfoldli x' c (?f32 x') \\<sigma>) =\n    tsl s \\<bind> (\\<lambda>l. imp_nfoldli l c f \\<sigma>)", "apply weaken_hnr_post"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x x' xa x'a sa s'a.\n       RETURN x \\<le> it_to_sorted_list ordR s' \\<Longrightarrow>\n       hn_refine\n        (\\<Gamma> * hn_ctxt Rs s' s * hn_ctxt Rk x'a xa *\n         hn_ctxt R\\<sigma> s'a sa)\n        (?fa10 x' xa sa)\n        (\\<Gamma> * hn_ctxt Rs s' s * hn_ctxt (\\<lambda>_ _. true) x'a xa *\n         hn_ctxt (\\<lambda>_ _. true) s'a sa)\n        R\\<sigma> (f' x'a s'a)\n 2. \\<And>x x'.\n       \\<Gamma> * hn_ctxt Rs s' s * hn_invalid (list_assn Rk) x x' *\n       hn_invalid R\\<sigma> \\<sigma>' \\<sigma> \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt Rs s' s *\n       hn_ctxt (\\<lambda>_ _. true) \\<sigma>' \\<sigma> *\n       hn_ctxt ?Rx10 x x'\n 3. tsl s \\<bind> (\\<lambda>x'. imp_nfoldli x' c (?fa10 x') \\<sigma>) =\n    tsl s \\<bind> (\\<lambda>l. imp_nfoldli l c f \\<sigma>)", "apply (rule hn_refine_cons_post)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x x' xa x'a sa s'a.\n       RETURN x \\<le> it_to_sorted_list ordR s' \\<Longrightarrow>\n       hn_refine\n        (\\<Gamma> * hn_ctxt Rs s' s * hn_ctxt Rk x'a xa *\n         hn_ctxt R\\<sigma> s'a sa)\n        (?fa10 x' xa sa) (?Q11 x x' xa x'a sa s'a) R\\<sigma> (f' x'a s'a)\n 2. \\<And>x x' xa x'a sa s'a.\n       RETURN x \\<le> it_to_sorted_list ordR s' \\<Longrightarrow>\n       ?Q11 x x' xa x'a sa s'a \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt Rs s' s * hn_ctxt (\\<lambda>_ _. true) x'a xa *\n       hn_ctxt (\\<lambda>_ _. true) s'a sa\n 3. \\<And>x x'.\n       \\<Gamma> * hn_ctxt Rs s' s * hn_invalid (list_assn Rk) x x' *\n       hn_invalid R\\<sigma> \\<sigma>' \\<sigma> \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt Rs s' s *\n       hn_ctxt (\\<lambda>_ _. true) \\<sigma>' \\<sigma> *\n       hn_ctxt ?Rx10 x x'\n 4. tsl s \\<bind> (\\<lambda>x'. imp_nfoldli x' c (?fa10 x') \\<sigma>) =\n    tsl s \\<bind> (\\<lambda>l. imp_nfoldli l c f \\<sigma>)", "apply (rule f_ref[unfolded APP_def])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x x' xa x'a sa s'a.\n       RETURN x \\<le> it_to_sorted_list ordR s' \\<Longrightarrow>\n       \\<Gamma>f x'a xa s'a sa \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt Rs s' s * hn_ctxt (\\<lambda>_ _. true) x'a xa *\n       hn_ctxt (\\<lambda>_ _. true) s'a sa\n 2. \\<And>x x'.\n       \\<Gamma> * hn_ctxt Rs s' s * hn_invalid (list_assn Rk) x x' *\n       hn_invalid R\\<sigma> \\<sigma>' \\<sigma> \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt Rs s' s *\n       hn_ctxt (\\<lambda>_ _. true) \\<sigma>' \\<sigma> *\n       hn_ctxt ?Rx10 x x'\n 3. tsl s \\<bind> (\\<lambda>x'. imp_nfoldli x' c f \\<sigma>) =\n    tsl s \\<bind> (\\<lambda>l. imp_nfoldli l c f \\<sigma>)", "apply (rule entt_trans[OF F_FR])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x x' xa x'a s s'a.\n       RETURN x \\<le> it_to_sorted_list ordR s' \\<Longrightarrow>\n       TERM monadic_FOREACH\n 2. \\<And>x x' xa x'a sa s'a.\n       RETURN x \\<le> it_to_sorted_list ordR s' \\<Longrightarrow>\n       \\<Gamma> * hn_ctxt Rs s' s * hn_ctxt Pfx x'a xa *\n       hn_ctxt Pf\\<sigma> s'a sa \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt Rs s' s * hn_ctxt (\\<lambda>_ _. true) x'a xa *\n       hn_ctxt (\\<lambda>_ _. true) s'a sa\n 3. \\<And>x x'.\n       \\<Gamma> * hn_ctxt Rs s' s * hn_invalid (list_assn Rk) x x' *\n       hn_invalid R\\<sigma> \\<sigma>' \\<sigma> \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt Rs s' s *\n       hn_ctxt (\\<lambda>_ _. true) \\<sigma>' \\<sigma> *\n       hn_ctxt ?Rx10 x x'\n 4. tsl s \\<bind> (\\<lambda>x'. imp_nfoldli x' c f \\<sigma>) =\n    tsl s \\<bind> (\\<lambda>l. imp_nfoldli l c f \\<sigma>)", "apply (rule TERMI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x x' xa x'a sa s'a.\n       RETURN x \\<le> it_to_sorted_list ordR s' \\<Longrightarrow>\n       \\<Gamma> * hn_ctxt Rs s' s * hn_ctxt Pfx x'a xa *\n       hn_ctxt Pf\\<sigma> s'a sa \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt Rs s' s * hn_ctxt (\\<lambda>_ _. true) x'a xa *\n       hn_ctxt (\\<lambda>_ _. true) s'a sa\n 2. \\<And>x x'.\n       \\<Gamma> * hn_ctxt Rs s' s * hn_invalid (list_assn Rk) x x' *\n       hn_invalid R\\<sigma> \\<sigma>' \\<sigma> \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt Rs s' s *\n       hn_ctxt (\\<lambda>_ _. true) \\<sigma>' \\<sigma> *\n       hn_ctxt ?Rx10 x x'\n 3. tsl s \\<bind> (\\<lambda>x'. imp_nfoldli x' c f \\<sigma>) =\n    tsl s \\<bind> (\\<lambda>l. imp_nfoldli l c f \\<sigma>)", "applyS (tactic \\<open>Sepref_Frame.frame_tac (K (K no_tac)) @{context} 1\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x'.\n       \\<Gamma> * hn_ctxt Rs s' s * hn_invalid (list_assn Rk) x x' *\n       hn_invalid R\\<sigma> \\<sigma>' \\<sigma> \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt Rs s' s *\n       hn_ctxt (\\<lambda>_ _. true) \\<sigma>' \\<sigma> *\n       hn_ctxt ?Rx10 x x'\n 2. tsl s \\<bind> (\\<lambda>x'. imp_nfoldli x' c f \\<sigma>) =\n    tsl s \\<bind> (\\<lambda>l. imp_nfoldli l c f \\<sigma>)", "applyS (tactic \\<open>Sepref_Frame.frame_tac (K (K no_tac)) @{context} 1\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. tsl s \\<bind> (\\<lambda>x'. imp_nfoldli x' c f \\<sigma>) =\n    tsl s \\<bind> (\\<lambda>l. imp_nfoldli l c f \\<sigma>)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  hn_refine P (imp_foreach tsl s c f \\<sigma>)\n   (\\<Gamma> * hn_ctxt Rs s' s * hn_invalid R\\<sigma> \\<sigma>' \\<sigma>)\n   R\\<sigma>\n   (PR_CONST (monadic_FOREACH ordR I) $ s' $ (\\<lambda>x. (#c' x#)) $\n    (\\<lambda>x. (#\\<lambda>xa. (#f' x xa#)#)) $\n    \\<sigma>')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monadic_nfoldli_assert_aux:\n  assumes \"set l \\<subseteq> S\"\n  shows \"monadic_nfoldli l c (\\<lambda>x s. ASSERT (x\\<in>S)\\<then>f x s) s = monadic_nfoldli l c f s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monadic_nfoldli l c\n     (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f x s)) s =\n    monadic_nfoldli l c f s", "using assms"], ["proof (prove)\nusing this:\n  set l \\<subseteq> S\n\ngoal (1 subgoal):\n 1. monadic_nfoldli l c\n     (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f x s)) s =\n    monadic_nfoldli l c f s", "apply (induction l arbitrary: s)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       set [] \\<subseteq> S \\<Longrightarrow>\n       monadic_nfoldli [] c\n        (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f x s)) s =\n       monadic_nfoldli [] c f s\n 2. \\<And>a l s.\n       \\<lbrakk>\\<And>s.\n                   set l \\<subseteq> S \\<Longrightarrow>\n                   monadic_nfoldli l c\n                    (\\<lambda>x s.\n                        ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f x s))\n                    s =\n                   monadic_nfoldli l c f s;\n        set (a # l) \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> monadic_nfoldli (a # l) c\n                          (\\<lambda>x s.\n                              ASSERT (x \\<in> S) \\<bind>\n                              (\\<lambda>_. f x s))\n                          s =\n                         monadic_nfoldli (a # l) c f s", "apply (auto simp: pw_eq_iff refine_pw_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas monadic_nfoldli_assert = monadic_nfoldli_assert_aux[OF order_refl]"], ["", "(* Refinement Setup for nfoldli  *)"], ["", "lemma nfoldli_arities[sepref_monadify_arity]:\n  \"nfoldli \\<equiv> \\<lambda>\\<^sub>2s c f \\<sigma>. SP (nfoldli)$s$(\\<lambda>\\<^sub>2x. c$x)$(\\<lambda>\\<^sub>2x \\<sigma>. f$x$\\<sigma>)$\\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli \\<equiv>\n    \\<lambda>x.\n       (#\\<lambda>xa.\n            (#\\<lambda>xb.\n                 (#\\<lambda>xc.\n                      (#SP nfoldli $ x $ (\\<lambda>x. (#xa $ x#)) $\n                        (\\<lambda>x. (#\\<lambda>xa. (#xb $ x $ xa#)#)) $\n                        xc#)#)#)#)", "by (simp_all)"], ["", "lemma nfoldli_comb[sepref_monadify_comb]:\n  \"\\<And>s c f \\<sigma>. (nfoldli)$s$(\\<lambda>\\<^sub>2x. c x)$f$\\<sigma> \\<equiv> \n    Refine_Basic.bind$(EVAL$s)$(\\<lambda>\\<^sub>2s. Refine_Basic.bind$(EVAL$\\<sigma>)$(\\<lambda>\\<^sub>2\\<sigma>. \n      SP (monadic_nfoldli)$s$(\\<lambda>\\<^sub>2x. (EVAL$(c x)))$f$\\<sigma>\n    ))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s c f \\<sigma>.\n       nfoldli $ s $ (\\<lambda>x. (#c x#)) $ f $ \\<sigma> \\<equiv>\n       (\\<bind>) $ (EVAL $ s) $\n       (\\<lambda>x.\n           (#(\\<bind>) $ (EVAL $ \\<sigma>) $\n             (\\<lambda>xa.\n                 (#SP monadic_nfoldli $ x $ (\\<lambda>x. (#EVAL $ c x#)) $\n                   f $\n                   xa#))#))", "by (simp_all add: nfoldli_to_monadic)"], ["", "lemma monadic_nfoldli_refine_aux':\n  assumes SS: \"set l' \\<subseteq> S\"\n  assumes c_ref: \"\\<And>s s'. hn_refine \n    (\\<Gamma> * hn_ctxt Rs s' s) \n    (c s) \n    (\\<Gamma> * hn_ctxt Rs s' s) \n    bool_assn\n    (c' s')\"\n  assumes f_ref: \"\\<And>x x' s s'. \\<lbrakk>x' \\<in> S\\<rbrakk> \\<Longrightarrow> hn_refine \n    (\\<Gamma> * hn_ctxt Rl x' x * hn_ctxt Rs s' s)\n    (f x s)\n    (\\<Gamma> * hn_ctxt Rl' x' x * hn_invalid Rs s' s) Rs\n    (f' x' s')\"\n\n  assumes merge[sepref_frame_merge_rules]: \"\\<And>x x'. hn_ctxt Rl' x' x \\<or>\\<^sub>A hn_ctxt Rl x' x \\<Longrightarrow>\\<^sub>t hn_ctxt Rl'' x' x\"\n  notes [sepref_frame_merge_rules] = merge_sat2[OF merge]\n\n  shows \"hn_refine \n    (\\<Gamma> * hn_ctxt (list_assn Rl) l' l * hn_ctxt Rs s' s) \n    (imp_nfoldli l c f s) \n    (\\<Gamma> * hn_ctxt (list_assn Rl'') l' l * hn_invalid Rs s' s) Rs\n    (monadic_nfoldli l' c' f' s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (\\<Gamma> * hn_ctxt (list_assn Rl) l' l * hn_ctxt Rs s' s)\n     (imp_nfoldli l c f s)\n     (\\<Gamma> * hn_ctxt (list_assn Rl'') l' l * hn_invalid Rs s' s) Rs\n     (monadic_nfoldli l' c' f' s')", "apply1 (subst monadic_nfoldli_assert_aux[OF SS,symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (\\<Gamma> * hn_ctxt (list_assn Rl) l' l * hn_ctxt Rs s' s)\n     (imp_nfoldli l c f s)\n     (\\<Gamma> * hn_ctxt (list_assn Rl'') l' l * hn_invalid Rs s' s) Rs\n     (monadic_nfoldli l' c'\n       (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s)) s')", "applyF (induct p\\<equiv>Rl l' l \n    arbitrary: s s'\n    rule: list_assn.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s s'.\n       hn_refine (\\<Gamma> * hn_ctxt (list_assn Rl) [] [] * hn_ctxt Rs s' s)\n        (imp_nfoldli [] c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') [] [] * hn_invalid Rs s' s) Rs\n        (monadic_nfoldli [] c'\n          (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n          s')\n 2. \\<And>a as ca cs s s'.\n       (\\<And>s s'.\n           hn_refine\n            (\\<Gamma> * hn_ctxt (list_assn Rl) as cs * hn_ctxt Rs s' s)\n            (imp_nfoldli cs c f s)\n            (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs * hn_invalid Rs s' s)\n            Rs (monadic_nfoldli as c'\n                 (\\<lambda>x s.\n                     ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n                 s')) \\<Longrightarrow>\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n         hn_ctxt Rs s' s)\n        (imp_nfoldli (ca # cs) c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') (a # as) (ca # cs) *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli (a # as) c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')\n 3. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) (v # va) [] * hn_ctxt Rs s' s)\n        (imp_nfoldli [] c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') (v # va) [] *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli (v # va) c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')\n 4. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) [] (v # va) * hn_ctxt Rs s' s)\n        (imp_nfoldli (v # va) c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') [] (v # va) *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli [] c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')", "applyF simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       hn_refine (\\<Gamma> * hn_ctxt Rs s' s) (return s)\n        (\\<Gamma> * hn_invalid Rs s' s) Rs (RETURN s')", "apply (rule hn_refine_cons_post)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       hn_refine (\\<Gamma> * hn_ctxt Rs s' s) (return s) (?Q5 s s') Rs\n        (RETURN s')\n 2. \\<And>s s'.\n       ?Q5 s s' \\<Longrightarrow>\\<^sub>t \\<Gamma> * hn_invalid Rs s' s", "apply (rule hn_refine_frame[OF hnr_RETURN_pass])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<Gamma> * hn_ctxt Rs s' s \\<Longrightarrow>\\<^sub>t\n       ?F8 s s' * hn_ctxt Rs s' s\n 2. \\<And>s s'.\n       ?F8 s s' * hn_invalid Rs s' s \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_invalid Rs s' s", "apply (tactic \\<open>Sepref_Frame.frame_tac (K (K no_tac)) @{context} 1\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<Gamma> * hn_invalid Rs s' s \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_invalid Rs s' s", "apply (simp add: hn_ctxt_def ent_true_drop)"], ["proof (prove)\ngoal:\nNo subgoals!", "solved"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a as ca cs s s'.\n       (\\<And>s s'.\n           hn_refine\n            (\\<Gamma> * hn_ctxt (list_assn Rl) as cs * hn_ctxt Rs s' s)\n            (imp_nfoldli cs c f s)\n            (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs * hn_invalid Rs s' s)\n            Rs (monadic_nfoldli as c'\n                 (\\<lambda>x s.\n                     ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n                 s')) \\<Longrightarrow>\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n         hn_ctxt Rs s' s)\n        (imp_nfoldli (ca # cs) c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') (a # as) (ca # cs) *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli (a # as) c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')\n 2. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) (v # va) [] * hn_ctxt Rs s' s)\n        (imp_nfoldli [] c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') (v # va) [] *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli (v # va) c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')\n 3. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) [] (v # va) * hn_ctxt Rs s' s)\n        (imp_nfoldli (v # va) c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') [] (v # va) *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli [] c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')", "apply (simp only: imp_nfoldli_simps monadic_nfoldli_simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a as ca cs s s'.\n       (\\<And>s s'.\n           hn_refine\n            (\\<Gamma> * hn_ctxt (list_assn Rl) as cs * hn_ctxt Rs s' s)\n            (imp_nfoldli cs c f s)\n            (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs * hn_invalid Rs s' s)\n            Rs (monadic_nfoldli as c'\n                 (\\<lambda>x s.\n                     ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n                 s')) \\<Longrightarrow>\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n         hn_ctxt Rs s' s)\n        (c s \\<bind>\n         (\\<lambda>b.\n             if b then f ca s \\<bind> imp_nfoldli cs c f else return s))\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') (a # as) (ca # cs) *\n         hn_invalid Rs s' s)\n        Rs (c' s' \\<bind>\n            (\\<lambda>b.\n                if b\n                then ASSERT (a \\<in> S) \\<bind>\n                     (\\<lambda>_. f' a s') \\<bind>\n                     monadic_nfoldli as c'\n                      (\\<lambda>x s.\n                          ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n                else RETURN s'))\n 2. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) (v # va) [] * hn_ctxt Rs s' s)\n        (imp_nfoldli [] c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') (v # va) [] *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli (v # va) c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')\n 3. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) [] (v # va) * hn_ctxt Rs s' s)\n        (imp_nfoldli (v # va) c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') [] (v # va) *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli [] c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')", "apply (rule hnr_bind)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a as ca cs s s'.\n       (\\<And>s s'.\n           hn_refine\n            (\\<Gamma> * hn_ctxt (list_assn Rl) as cs * hn_ctxt Rs s' s)\n            (imp_nfoldli cs c f s)\n            (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs * hn_invalid Rs s' s)\n            Rs (monadic_nfoldli as c'\n                 (\\<lambda>x s.\n                     ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n                 s')) \\<Longrightarrow>\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n         hn_ctxt Rs s' s)\n        (c s) (?\\<Gamma>1.19 a as ca cs s s') (?Rh19 a as ca cs s s')\n        (c' s')\n 2. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN x \\<le> c' s'\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?\\<Gamma>1.19 a as ca cs s s' *\n                           hn_ctxt (?Rh19 a as ca cs s s') x x')\n                          (if x' then f ca s \\<bind> imp_nfoldli cs c f\n                           else return s)\n                          (?\\<Gamma>2.19 a as ca cs s s' x x') Rs\n                          (if x\n                           then ASSERT (a \\<in> S) \\<bind>\n                                (\\<lambda>_. f' a s') \\<bind>\n                                monadic_nfoldli as c'\n                                 (\\<lambda>x s.\n                                     ASSERT (x \\<in> S) \\<bind>\n                                     (\\<lambda>_. f' x s))\n                           else RETURN s')\n 3. \\<And>a as ca cs s s' x x'.\n       (\\<And>s s'.\n           hn_refine\n            (\\<Gamma> * hn_ctxt (list_assn Rl) as cs * hn_ctxt Rs s' s)\n            (imp_nfoldli cs c f s)\n            (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs * hn_invalid Rs s' s)\n            Rs (monadic_nfoldli as c'\n                 (\\<lambda>x s.\n                     ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n                 s')) \\<Longrightarrow>\n       ?\\<Gamma>2.19 a as ca cs s s' x x' \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt (list_assn Rl'') (a # as) (ca # cs) *\n       hn_invalid Rs s' s *\n       hn_ctxt (?Rx19 a as ca cs s s') x x'\n 4. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) (v # va) [] * hn_ctxt Rs s' s)\n        (imp_nfoldli [] c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') (v # va) [] *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli (v # va) c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')\n 5. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) [] (v # va) * hn_ctxt Rs s' s)\n        (imp_nfoldli (v # va) c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') [] (v # va) *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli [] c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')", "apply (rule hn_refine_frame[OF c_ref])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a as ca cs s s'.\n       (\\<And>s s'.\n           hn_refine\n            (\\<Gamma> * hn_ctxt (list_assn Rl) as cs * hn_ctxt Rs s' s)\n            (imp_nfoldli cs c f s)\n            (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs * hn_invalid Rs s' s)\n            Rs (monadic_nfoldli as c'\n                 (\\<lambda>x s.\n                     ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n                 s')) \\<Longrightarrow>\n       \\<Gamma> * hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n       hn_ctxt Rs s' s \\<Longrightarrow>\\<^sub>t\n       ?F23 a as ca cs s s' * (\\<Gamma> * hn_ctxt Rs s' s)\n 2. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN x \\<le> c' s'\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?F23 a as ca cs s s' *\n                           (\\<Gamma> * hn_ctxt Rs s' s) *\n                           hn_val bool_rel x x')\n                          (if x' then f ca s \\<bind> imp_nfoldli cs c f\n                           else return s)\n                          (?\\<Gamma>2.19 a as ca cs s s' x x') Rs\n                          (if x\n                           then ASSERT (a \\<in> S) \\<bind>\n                                (\\<lambda>_. f' a s') \\<bind>\n                                monadic_nfoldli as c'\n                                 (\\<lambda>x s.\n                                     ASSERT (x \\<in> S) \\<bind>\n                                     (\\<lambda>_. f' x s))\n                           else RETURN s')\n 3. \\<And>a as ca cs s s' x x'.\n       (\\<And>s s'.\n           hn_refine\n            (\\<Gamma> * hn_ctxt (list_assn Rl) as cs * hn_ctxt Rs s' s)\n            (imp_nfoldli cs c f s)\n            (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs * hn_invalid Rs s' s)\n            Rs (monadic_nfoldli as c'\n                 (\\<lambda>x s.\n                     ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n                 s')) \\<Longrightarrow>\n       ?\\<Gamma>2.19 a as ca cs s s' x x' \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt (list_assn Rl'') (a # as) (ca # cs) *\n       hn_invalid Rs s' s *\n       hn_ctxt (?Rx19 a as ca cs s s') x x'\n 4. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) (v # va) [] * hn_ctxt Rs s' s)\n        (imp_nfoldli [] c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') (v # va) [] *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli (v # va) c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')\n 5. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) [] (v # va) * hn_ctxt Rs s' s)\n        (imp_nfoldli (v # va) c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') [] (v # va) *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli [] c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')", "apply (tactic \\<open>Sepref_Frame.frame_tac (K (K no_tac)) @{context} 1\\<close>)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN x \\<le> c' s'\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n                           (\\<Gamma> * hn_ctxt Rs s' s) *\n                           hn_val bool_rel x x')\n                          (if x' then f ca s \\<bind> imp_nfoldli cs c f\n                           else return s)\n                          (?\\<Gamma>2.19 a as ca cs s s' x x') Rs\n                          (if x\n                           then ASSERT (a \\<in> S) \\<bind>\n                                (\\<lambda>_. f' a s') \\<bind>\n                                monadic_nfoldli as c'\n                                 (\\<lambda>x s.\n                                     ASSERT (x \\<in> S) \\<bind>\n                                     (\\<lambda>_. f' x s))\n                           else RETURN s')\n 2. \\<And>a as ca cs s s' x x'.\n       (\\<And>s s'.\n           hn_refine\n            (\\<Gamma> * hn_ctxt (list_assn Rl) as cs * hn_ctxt Rs s' s)\n            (imp_nfoldli cs c f s)\n            (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs * hn_invalid Rs s' s)\n            Rs (monadic_nfoldli as c'\n                 (\\<lambda>x s.\n                     ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n                 s')) \\<Longrightarrow>\n       ?\\<Gamma>2.19 a as ca cs s s' x x' \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt (list_assn Rl'') (a # as) (ca # cs) *\n       hn_invalid Rs s' s *\n       hn_ctxt (?Rx19 a as ca cs s s') x x'\n 3. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) (v # va) [] * hn_ctxt Rs s' s)\n        (imp_nfoldli [] c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') (v # va) [] *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli (v # va) c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')\n 4. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) [] (v # va) * hn_ctxt Rs s' s)\n        (imp_nfoldli (v # va) c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') [] (v # va) *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli [] c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')", "apply (rule hnr_If)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN x \\<le> c' s'\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n                         (\\<Gamma> * hn_ctxt Rs s' s) *\n                         hn_val bool_rel x x' \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>1.33 a as ca cs s s' x x' *\n                         hn_val bool_rel x x'\n 2. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN x \\<le> c' s'; x\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?\\<Gamma>1.33 a as ca cs s s' x x' *\n                           hn_val bool_rel x x')\n                          (f ca s \\<bind> imp_nfoldli cs c f)\n                          (?\\<Gamma>2b33 a as ca cs s s' x x') Rs\n                          (ASSERT (a \\<in> S) \\<bind>\n                           (\\<lambda>_. f' a s') \\<bind>\n                           monadic_nfoldli as c'\n                            (\\<lambda>x s.\n                                ASSERT (x \\<in> S) \\<bind>\n                                (\\<lambda>_. f' x s)))\n 3. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN x \\<le> c' s'; \\<not> x\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?\\<Gamma>1.33 a as ca cs s s' x x' *\n                           hn_val bool_rel x x')\n                          (return s) (?\\<Gamma>2c33 a as ca cs s s' x x') Rs\n                          (RETURN s')\n 4. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN x \\<le> c' s'\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2b33 a as ca cs s s' x x' \\<or>\\<^sub>A\n                         ?\\<Gamma>2c33 a as ca cs s s' x\n                          x' \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.19 a as ca cs s s' x x'\n 5. \\<And>a as ca cs s s' x x'.\n       (\\<And>s s'.\n           hn_refine\n            (\\<Gamma> * hn_ctxt (list_assn Rl) as cs * hn_ctxt Rs s' s)\n            (imp_nfoldli cs c f s)\n            (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs * hn_invalid Rs s' s)\n            Rs (monadic_nfoldli as c'\n                 (\\<lambda>x s.\n                     ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n                 s')) \\<Longrightarrow>\n       ?\\<Gamma>2.19 a as ca cs s s' x x' \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt (list_assn Rl'') (a # as) (ca # cs) *\n       hn_invalid Rs s' s *\n       hn_ctxt (?Rx19 a as ca cs s s') x x'\n 6. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) (v # va) [] * hn_ctxt Rs s' s)\n        (imp_nfoldli [] c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') (v # va) [] *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli (v # va) c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')\n 7. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) [] (v # va) * hn_ctxt Rs s' s)\n        (imp_nfoldli (v # va) c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') [] (v # va) *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli [] c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')", "apply (tactic \\<open>Sepref_Frame.frame_tac (K (K no_tac)) @{context} 1\\<close>)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN x \\<le> c' s'; x\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n                           \\<Gamma> *\n                           hn_ctxt Rs s' s *\n                           hn_val bool_rel x x')\n                          (f ca s \\<bind> imp_nfoldli cs c f)\n                          (?\\<Gamma>2b33 a as ca cs s s' x x') Rs\n                          (ASSERT (a \\<in> S) \\<bind>\n                           (\\<lambda>_. f' a s') \\<bind>\n                           monadic_nfoldli as c'\n                            (\\<lambda>x s.\n                                ASSERT (x \\<in> S) \\<bind>\n                                (\\<lambda>_. f' x s)))\n 2. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN x \\<le> c' s'; \\<not> x\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n                           \\<Gamma> *\n                           hn_ctxt Rs s' s *\n                           hn_val bool_rel x x')\n                          (return s) (?\\<Gamma>2c33 a as ca cs s s' x x') Rs\n                          (RETURN s')\n 3. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN x \\<le> c' s'\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2b33 a as ca cs s s' x x' \\<or>\\<^sub>A\n                         ?\\<Gamma>2c33 a as ca cs s s' x\n                          x' \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.19 a as ca cs s s' x x'\n 4. \\<And>a as ca cs s s' x x'.\n       (\\<And>s s'.\n           hn_refine\n            (\\<Gamma> * hn_ctxt (list_assn Rl) as cs * hn_ctxt Rs s' s)\n            (imp_nfoldli cs c f s)\n            (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs * hn_invalid Rs s' s)\n            Rs (monadic_nfoldli as c'\n                 (\\<lambda>x s.\n                     ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n                 s')) \\<Longrightarrow>\n       ?\\<Gamma>2.19 a as ca cs s s' x x' \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt (list_assn Rl'') (a # as) (ca # cs) *\n       hn_invalid Rs s' s *\n       hn_ctxt (?Rx19 a as ca cs s s') x x'\n 5. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) (v # va) [] * hn_ctxt Rs s' s)\n        (imp_nfoldli [] c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') (v # va) [] *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli (v # va) c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')\n 6. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) [] (v # va) * hn_ctxt Rs s' s)\n        (imp_nfoldli (v # va) c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') [] (v # va) *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli [] c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')", "apply (simp only: nres_monad_laws)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n                           \\<Gamma> *\n                           hn_ctxt Rs s' s *\n                           hn_val bool_rel True x')\n                          (f ca s \\<bind> imp_nfoldli cs c f)\n                          (?\\<Gamma>2b33 a as ca cs s s' True x') Rs\n                          (ASSERT (a \\<in> S) \\<bind>\n                           (\\<lambda>x.\n                               f' a s' \\<bind>\n                               monadic_nfoldli as c'\n                                (\\<lambda>x s.\n                                    ASSERT (x \\<in> S) \\<bind>\n                                    (\\<lambda>_. f' x s))))\n 2. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN x \\<le> c' s'; \\<not> x\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n                           \\<Gamma> *\n                           hn_ctxt Rs s' s *\n                           hn_val bool_rel x x')\n                          (return s) (?\\<Gamma>2c33 a as ca cs s s' x x') Rs\n                          (RETURN s')\n 3. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN x \\<le> c' s'\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2b33 a as ca cs s s' x x' \\<or>\\<^sub>A\n                         ?\\<Gamma>2c33 a as ca cs s s' x\n                          x' \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.19 a as ca cs s s' x x'\n 4. \\<And>a as ca cs s s' x x'.\n       (\\<And>s s'.\n           hn_refine\n            (\\<Gamma> * hn_ctxt (list_assn Rl) as cs * hn_ctxt Rs s' s)\n            (imp_nfoldli cs c f s)\n            (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs * hn_invalid Rs s' s)\n            Rs (monadic_nfoldli as c'\n                 (\\<lambda>x s.\n                     ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n                 s')) \\<Longrightarrow>\n       ?\\<Gamma>2.19 a as ca cs s s' x x' \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt (list_assn Rl'') (a # as) (ca # cs) *\n       hn_invalid Rs s' s *\n       hn_ctxt (?Rx19 a as ca cs s s') x x'\n 5. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) (v # va) [] * hn_ctxt Rs s' s)\n        (imp_nfoldli [] c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') (v # va) [] *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli (v # va) c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')\n 6. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) [] (v # va) * hn_ctxt Rs s' s)\n        (imp_nfoldli (v # va) c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') [] (v # va) *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli [] c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')", "apply (rule hnr_ASSERT)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n                           \\<Gamma> *\n                           hn_ctxt Rs s' s *\n                           hn_val bool_rel True x')\n                          (f ca s \\<bind> imp_nfoldli cs c f)\n                          (?\\<Gamma>2b33 a as ca cs s s' True x') Rs\n                          (f' a s' \\<bind>\n                           monadic_nfoldli as c'\n                            (\\<lambda>x s.\n                                ASSERT (x \\<in> S) \\<bind>\n                                (\\<lambda>_. f' x s)))\n 2. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN x \\<le> c' s'; \\<not> x\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n                           \\<Gamma> *\n                           hn_ctxt Rs s' s *\n                           hn_val bool_rel x x')\n                          (return s) (?\\<Gamma>2c33 a as ca cs s s' x x') Rs\n                          (RETURN s')\n 3. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN x \\<le> c' s'\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2b33 a as ca cs s s' x x' \\<or>\\<^sub>A\n                         ?\\<Gamma>2c33 a as ca cs s s' x\n                          x' \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.19 a as ca cs s s' x x'\n 4. \\<And>a as ca cs s s' x x'.\n       (\\<And>s s'.\n           hn_refine\n            (\\<Gamma> * hn_ctxt (list_assn Rl) as cs * hn_ctxt Rs s' s)\n            (imp_nfoldli cs c f s)\n            (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs * hn_invalid Rs s' s)\n            Rs (monadic_nfoldli as c'\n                 (\\<lambda>x s.\n                     ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n                 s')) \\<Longrightarrow>\n       ?\\<Gamma>2.19 a as ca cs s s' x x' \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt (list_assn Rl'') (a # as) (ca # cs) *\n       hn_invalid Rs s' s *\n       hn_ctxt (?Rx19 a as ca cs s s') x x'\n 5. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) (v # va) [] * hn_ctxt Rs s' s)\n        (imp_nfoldli [] c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') (v # va) [] *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli (v # va) c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')\n 6. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) [] (v # va) * hn_ctxt Rs s' s)\n        (imp_nfoldli (v # va) c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') [] (v # va) *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli [] c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')", "apply (rule hnr_bind)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n                           \\<Gamma> *\n                           hn_ctxt Rs s' s *\n                           hn_val bool_rel True x')\n                          (f ca s) (?\\<Gamma>1.48 a as ca cs s s' x x')\n                          (?Rh48 a as ca cs s s' x x') (f' a s')\n 2. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S;\n        RETURN xa \\<le> f' a s'\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?\\<Gamma>1.48 a as ca cs s s' x x' *\n                           hn_ctxt (?Rh48 a as ca cs s s' x x') xa x'a)\n                          (imp_nfoldli cs c f x'a)\n                          (?\\<Gamma>2.48 a as ca cs s s' x x' xa x'a) Rs\n                          (monadic_nfoldli as c'\n                            (\\<lambda>x s.\n                                ASSERT (x \\<in> S) \\<bind>\n                                (\\<lambda>_. f' x s))\n                            xa)\n 3. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.48 a as ca cs s s' x x' xa\n                          x'a \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2b33 a as ca cs s s' True x' *\n                         hn_ctxt (?Rx48 a as ca cs s s' x x') xa x'a\n 4. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN x \\<le> c' s'; \\<not> x\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n                           \\<Gamma> *\n                           hn_ctxt Rs s' s *\n                           hn_val bool_rel x x')\n                          (return s) (?\\<Gamma>2c33 a as ca cs s s' x x') Rs\n                          (RETURN s')\n 5. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN x \\<le> c' s'\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2b33 a as ca cs s s' x x' \\<or>\\<^sub>A\n                         ?\\<Gamma>2c33 a as ca cs s s' x\n                          x' \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.19 a as ca cs s s' x x'\n 6. \\<And>a as ca cs s s' x x'.\n       (\\<And>s s'.\n           hn_refine\n            (\\<Gamma> * hn_ctxt (list_assn Rl) as cs * hn_ctxt Rs s' s)\n            (imp_nfoldli cs c f s)\n            (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs * hn_invalid Rs s' s)\n            Rs (monadic_nfoldli as c'\n                 (\\<lambda>x s.\n                     ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n                 s')) \\<Longrightarrow>\n       ?\\<Gamma>2.19 a as ca cs s s' x x' \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt (list_assn Rl'') (a # as) (ca # cs) *\n       hn_invalid Rs s' s *\n       hn_ctxt (?Rx19 a as ca cs s s') x x'\n 7. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) (v # va) [] * hn_ctxt Rs s' s)\n        (imp_nfoldli [] c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') (v # va) [] *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli (v # va) c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')\n 8. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) [] (v # va) * hn_ctxt Rs s' s)\n        (imp_nfoldli (v # va) c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') [] (v # va) *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli [] c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')", "apply (rule hn_refine_frame[OF f_ref])"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S\\<rbrakk>\n       \\<Longrightarrow> a \\<in> S\n 2. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n                         \\<Gamma> *\n                         hn_ctxt Rs s' s *\n                         hn_val bool_rel True x' \\<Longrightarrow>\\<^sub>t\n                         ?F53 a as ca cs s s' x x' *\n                         (\\<Gamma> * hn_ctxt Rl a ca * hn_ctxt Rs s' s)\n 3. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S;\n        RETURN xa \\<le> f' a s'\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?F53 a as ca cs s s' x x' *\n                           (\\<Gamma> * hn_ctxt Rl' a ca *\n                            hn_invalid Rs s' s) *\n                           hn_ctxt Rs xa x'a)\n                          (imp_nfoldli cs c f x'a)\n                          (?\\<Gamma>2.48 a as ca cs s s' x x' xa x'a) Rs\n                          (monadic_nfoldli as c'\n                            (\\<lambda>x s.\n                                ASSERT (x \\<in> S) \\<bind>\n                                (\\<lambda>_. f' x s))\n                            xa)\n 4. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.48 a as ca cs s s' x x' xa\n                          x'a \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2b33 a as ca cs s s' True x' *\n                         hn_ctxt (?Rx48 a as ca cs s s' x x') xa x'a\n 5. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN x \\<le> c' s'; \\<not> x\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n                           \\<Gamma> *\n                           hn_ctxt Rs s' s *\n                           hn_val bool_rel x x')\n                          (return s) (?\\<Gamma>2c33 a as ca cs s s' x x') Rs\n                          (RETURN s')\n 6. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN x \\<le> c' s'\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2b33 a as ca cs s s' x x' \\<or>\\<^sub>A\n                         ?\\<Gamma>2c33 a as ca cs s s' x\n                          x' \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.19 a as ca cs s s' x x'\n 7. \\<And>a as ca cs s s' x x'.\n       (\\<And>s s'.\n           hn_refine\n            (\\<Gamma> * hn_ctxt (list_assn Rl) as cs * hn_ctxt Rs s' s)\n            (imp_nfoldli cs c f s)\n            (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs * hn_invalid Rs s' s)\n            Rs (monadic_nfoldli as c'\n                 (\\<lambda>x s.\n                     ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n                 s')) \\<Longrightarrow>\n       ?\\<Gamma>2.19 a as ca cs s s' x x' \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt (list_assn Rl'') (a # as) (ca # cs) *\n       hn_invalid Rs s' s *\n       hn_ctxt (?Rx19 a as ca cs s s') x x'\n 8. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) (v # va) [] * hn_ctxt Rs s' s)\n        (imp_nfoldli [] c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') (v # va) [] *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli (v # va) c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')\n 9. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) [] (v # va) * hn_ctxt Rs s' s)\n        (imp_nfoldli (v # va) c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') [] (v # va) *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli [] c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')", "apply assumption"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n                         \\<Gamma> *\n                         hn_ctxt Rs s' s *\n                         hn_val bool_rel True x' \\<Longrightarrow>\\<^sub>t\n                         ?F53 a as ca cs s s' x x' *\n                         (\\<Gamma> * hn_ctxt Rl a ca * hn_ctxt Rs s' s)\n 2. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S;\n        RETURN xa \\<le> f' a s'\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?F53 a as ca cs s s' x x' *\n                           (\\<Gamma> * hn_ctxt Rl' a ca *\n                            hn_invalid Rs s' s) *\n                           hn_ctxt Rs xa x'a)\n                          (imp_nfoldli cs c f x'a)\n                          (?\\<Gamma>2.48 a as ca cs s s' x x' xa x'a) Rs\n                          (monadic_nfoldli as c'\n                            (\\<lambda>x s.\n                                ASSERT (x \\<in> S) \\<bind>\n                                (\\<lambda>_. f' x s))\n                            xa)\n 3. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.48 a as ca cs s s' x x' xa\n                          x'a \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2b33 a as ca cs s s' True x' *\n                         hn_ctxt (?Rx48 a as ca cs s s' x x') xa x'a\n 4. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN x \\<le> c' s'; \\<not> x\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n                           \\<Gamma> *\n                           hn_ctxt Rs s' s *\n                           hn_val bool_rel x x')\n                          (return s) (?\\<Gamma>2c33 a as ca cs s s' x x') Rs\n                          (RETURN s')\n 5. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN x \\<le> c' s'\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2b33 a as ca cs s s' x x' \\<or>\\<^sub>A\n                         ?\\<Gamma>2c33 a as ca cs s s' x\n                          x' \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.19 a as ca cs s s' x x'\n 6. \\<And>a as ca cs s s' x x'.\n       (\\<And>s s'.\n           hn_refine\n            (\\<Gamma> * hn_ctxt (list_assn Rl) as cs * hn_ctxt Rs s' s)\n            (imp_nfoldli cs c f s)\n            (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs * hn_invalid Rs s' s)\n            Rs (monadic_nfoldli as c'\n                 (\\<lambda>x s.\n                     ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n                 s')) \\<Longrightarrow>\n       ?\\<Gamma>2.19 a as ca cs s s' x x' \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt (list_assn Rl'') (a # as) (ca # cs) *\n       hn_invalid Rs s' s *\n       hn_ctxt (?Rx19 a as ca cs s s') x x'\n 7. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) (v # va) [] * hn_ctxt Rs s' s)\n        (imp_nfoldli [] c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') (v # va) [] *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli (v # va) c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')\n 8. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) [] (v # va) * hn_ctxt Rs s' s)\n        (imp_nfoldli (v # va) c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') [] (v # va) *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli [] c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')", "apply (simp add: assn_aci)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt Rs s' s *\n                     hn_ctxt (list_assn Rl) as cs)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid Rs s' s *\n                     hn_ctxt (list_assn Rl'') as cs)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> * hn_ctxt Rl a ca * hn_ctxt Rs s' s *\n                         hn_val bool_rel True x' *\n                         hn_ctxt (list_assn Rl) as\n                          cs \\<Longrightarrow>\\<^sub>t\n                         \\<Gamma> * hn_ctxt Rl a ca * hn_ctxt Rs s' s *\n                         ?F53 a as ca cs s s' True x'\n 2. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S;\n        RETURN xa \\<le> f' a s'\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?F53 a as ca cs s s' x x' *\n                           (\\<Gamma> * hn_ctxt Rl' a ca *\n                            hn_invalid Rs s' s) *\n                           hn_ctxt Rs xa x'a)\n                          (imp_nfoldli cs c f x'a)\n                          (?\\<Gamma>2.48 a as ca cs s s' x x' xa x'a) Rs\n                          (monadic_nfoldli as c'\n                            (\\<lambda>x s.\n                                ASSERT (x \\<in> S) \\<bind>\n                                (\\<lambda>_. f' x s))\n                            xa)\n 3. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.48 a as ca cs s s' x x' xa\n                          x'a \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2b33 a as ca cs s s' True x' *\n                         hn_ctxt (?Rx48 a as ca cs s s' x x') xa x'a\n 4. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN x \\<le> c' s'; \\<not> x\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n                           \\<Gamma> *\n                           hn_ctxt Rs s' s *\n                           hn_val bool_rel x x')\n                          (return s) (?\\<Gamma>2c33 a as ca cs s s' x x') Rs\n                          (RETURN s')\n 5. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN x \\<le> c' s'\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2b33 a as ca cs s s' x x' \\<or>\\<^sub>A\n                         ?\\<Gamma>2c33 a as ca cs s s' x\n                          x' \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.19 a as ca cs s s' x x'\n 6. \\<And>a as ca cs s s' x x'.\n       (\\<And>s s'.\n           hn_refine\n            (\\<Gamma> * hn_ctxt (list_assn Rl) as cs * hn_ctxt Rs s' s)\n            (imp_nfoldli cs c f s)\n            (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs * hn_invalid Rs s' s)\n            Rs (monadic_nfoldli as c'\n                 (\\<lambda>x s.\n                     ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n                 s')) \\<Longrightarrow>\n       ?\\<Gamma>2.19 a as ca cs s s' x x' \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt (list_assn Rl'') (a # as) (ca # cs) *\n       hn_invalid Rs s' s *\n       hn_ctxt (?Rx19 a as ca cs s s') x x'\n 7. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) (v # va) [] * hn_ctxt Rs s' s)\n        (imp_nfoldli [] c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') (v # va) [] *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli (v # va) c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')\n 8. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) [] (v # va) * hn_ctxt Rs s' s)\n        (imp_nfoldli (v # va) c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') [] (v # va) *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli [] c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')", "apply (rule ent_imp_entt)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt Rs s' s *\n                     hn_ctxt (list_assn Rl) as cs)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid Rs s' s *\n                     hn_ctxt (list_assn Rl'') as cs)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> * hn_ctxt Rl a ca * hn_ctxt Rs s' s *\n                         hn_val bool_rel True x' *\n                         hn_ctxt (list_assn Rl) as\n                          cs \\<Longrightarrow>\\<^sub>A\n                         \\<Gamma> * hn_ctxt Rl a ca * hn_ctxt Rs s' s *\n                         ?F53 a as ca cs s s' True x'\n 2. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S;\n        RETURN xa \\<le> f' a s'\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?F53 a as ca cs s s' x x' *\n                           (\\<Gamma> * hn_ctxt Rl' a ca *\n                            hn_invalid Rs s' s) *\n                           hn_ctxt Rs xa x'a)\n                          (imp_nfoldli cs c f x'a)\n                          (?\\<Gamma>2.48 a as ca cs s s' x x' xa x'a) Rs\n                          (monadic_nfoldli as c'\n                            (\\<lambda>x s.\n                                ASSERT (x \\<in> S) \\<bind>\n                                (\\<lambda>_. f' x s))\n                            xa)\n 3. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.48 a as ca cs s s' x x' xa\n                          x'a \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2b33 a as ca cs s s' True x' *\n                         hn_ctxt (?Rx48 a as ca cs s s' x x') xa x'a\n 4. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN x \\<le> c' s'; \\<not> x\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n                           \\<Gamma> *\n                           hn_ctxt Rs s' s *\n                           hn_val bool_rel x x')\n                          (return s) (?\\<Gamma>2c33 a as ca cs s s' x x') Rs\n                          (RETURN s')\n 5. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN x \\<le> c' s'\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2b33 a as ca cs s s' x x' \\<or>\\<^sub>A\n                         ?\\<Gamma>2c33 a as ca cs s s' x\n                          x' \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.19 a as ca cs s s' x x'\n 6. \\<And>a as ca cs s s' x x'.\n       (\\<And>s s'.\n           hn_refine\n            (\\<Gamma> * hn_ctxt (list_assn Rl) as cs * hn_ctxt Rs s' s)\n            (imp_nfoldli cs c f s)\n            (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs * hn_invalid Rs s' s)\n            Rs (monadic_nfoldli as c'\n                 (\\<lambda>x s.\n                     ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n                 s')) \\<Longrightarrow>\n       ?\\<Gamma>2.19 a as ca cs s s' x x' \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt (list_assn Rl'') (a # as) (ca # cs) *\n       hn_invalid Rs s' s *\n       hn_ctxt (?Rx19 a as ca cs s s') x x'\n 7. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) (v # va) [] * hn_ctxt Rs s' s)\n        (imp_nfoldli [] c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') (v # va) [] *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli (v # va) c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')\n 8. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) [] (v # va) * hn_ctxt Rs s' s)\n        (imp_nfoldli (v # va) c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') [] (v # va) *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli [] c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')", "apply (fr_rot_rhs 1)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt Rs s' s *\n                     hn_ctxt (list_assn Rl) as cs)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid Rs s' s *\n                     hn_ctxt (list_assn Rl'') as cs)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> * hn_ctxt Rl a ca * hn_ctxt Rs s' s *\n                         hn_val bool_rel True x' *\n                         hn_ctxt (list_assn Rl) as\n                          cs \\<Longrightarrow>\\<^sub>A\n                         ?F53 a as ca cs s s' True x' * \\<Gamma> *\n                         hn_ctxt Rl a ca *\n                         hn_ctxt Rs s' s\n 2. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S;\n        RETURN xa \\<le> f' a s'\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?F53 a as ca cs s s' x x' *\n                           (\\<Gamma> * hn_ctxt Rl' a ca *\n                            hn_invalid Rs s' s) *\n                           hn_ctxt Rs xa x'a)\n                          (imp_nfoldli cs c f x'a)\n                          (?\\<Gamma>2.48 a as ca cs s s' x x' xa x'a) Rs\n                          (monadic_nfoldli as c'\n                            (\\<lambda>x s.\n                                ASSERT (x \\<in> S) \\<bind>\n                                (\\<lambda>_. f' x s))\n                            xa)\n 3. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.48 a as ca cs s s' x x' xa\n                          x'a \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2b33 a as ca cs s s' True x' *\n                         hn_ctxt (?Rx48 a as ca cs s s' x x') xa x'a\n 4. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN x \\<le> c' s'; \\<not> x\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n                           \\<Gamma> *\n                           hn_ctxt Rs s' s *\n                           hn_val bool_rel x x')\n                          (return s) (?\\<Gamma>2c33 a as ca cs s s' x x') Rs\n                          (RETURN s')\n 5. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN x \\<le> c' s'\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2b33 a as ca cs s s' x x' \\<or>\\<^sub>A\n                         ?\\<Gamma>2c33 a as ca cs s s' x\n                          x' \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.19 a as ca cs s s' x x'\n 6. \\<And>a as ca cs s s' x x'.\n       (\\<And>s s'.\n           hn_refine\n            (\\<Gamma> * hn_ctxt (list_assn Rl) as cs * hn_ctxt Rs s' s)\n            (imp_nfoldli cs c f s)\n            (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs * hn_invalid Rs s' s)\n            Rs (monadic_nfoldli as c'\n                 (\\<lambda>x s.\n                     ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n                 s')) \\<Longrightarrow>\n       ?\\<Gamma>2.19 a as ca cs s s' x x' \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt (list_assn Rl'') (a # as) (ca # cs) *\n       hn_invalid Rs s' s *\n       hn_ctxt (?Rx19 a as ca cs s s') x x'\n 7. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) (v # va) [] * hn_ctxt Rs s' s)\n        (imp_nfoldli [] c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') (v # va) [] *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli (v # va) c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')\n 8. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) [] (v # va) * hn_ctxt Rs s' s)\n        (imp_nfoldli (v # va) c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') [] (v # va) *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli [] c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')", "apply (fr_rot 2)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt Rs s' s *\n                     hn_ctxt (list_assn Rl) as cs)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid Rs s' s *\n                     hn_ctxt (list_assn Rl'') as cs)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S\\<rbrakk>\n       \\<Longrightarrow> hn_val bool_rel True x' *\n                         hn_ctxt (list_assn Rl) as cs *\n                         \\<Gamma> *\n                         hn_ctxt Rl a ca *\n                         hn_ctxt Rs s' s \\<Longrightarrow>\\<^sub>A\n                         ?F53 a as ca cs s s' True x' * \\<Gamma> *\n                         hn_ctxt Rl a ca *\n                         hn_ctxt Rs s' s\n 2. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S;\n        RETURN xa \\<le> f' a s'\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?F53 a as ca cs s s' x x' *\n                           (\\<Gamma> * hn_ctxt Rl' a ca *\n                            hn_invalid Rs s' s) *\n                           hn_ctxt Rs xa x'a)\n                          (imp_nfoldli cs c f x'a)\n                          (?\\<Gamma>2.48 a as ca cs s s' x x' xa x'a) Rs\n                          (monadic_nfoldli as c'\n                            (\\<lambda>x s.\n                                ASSERT (x \\<in> S) \\<bind>\n                                (\\<lambda>_. f' x s))\n                            xa)\n 3. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.48 a as ca cs s s' x x' xa\n                          x'a \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2b33 a as ca cs s s' True x' *\n                         hn_ctxt (?Rx48 a as ca cs s s' x x') xa x'a\n 4. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN x \\<le> c' s'; \\<not> x\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n                           \\<Gamma> *\n                           hn_ctxt Rs s' s *\n                           hn_val bool_rel x x')\n                          (return s) (?\\<Gamma>2c33 a as ca cs s s' x x') Rs\n                          (RETURN s')\n 5. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN x \\<le> c' s'\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2b33 a as ca cs s s' x x' \\<or>\\<^sub>A\n                         ?\\<Gamma>2c33 a as ca cs s s' x\n                          x' \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.19 a as ca cs s s' x x'\n 6. \\<And>a as ca cs s s' x x'.\n       (\\<And>s s'.\n           hn_refine\n            (\\<Gamma> * hn_ctxt (list_assn Rl) as cs * hn_ctxt Rs s' s)\n            (imp_nfoldli cs c f s)\n            (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs * hn_invalid Rs s' s)\n            Rs (monadic_nfoldli as c'\n                 (\\<lambda>x s.\n                     ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n                 s')) \\<Longrightarrow>\n       ?\\<Gamma>2.19 a as ca cs s s' x x' \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt (list_assn Rl'') (a # as) (ca # cs) *\n       hn_invalid Rs s' s *\n       hn_ctxt (?Rx19 a as ca cs s s') x x'\n 7. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) (v # va) [] * hn_ctxt Rs s' s)\n        (imp_nfoldli [] c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') (v # va) [] *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli (v # va) c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')\n 8. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) [] (v # va) * hn_ctxt Rs s' s)\n        (imp_nfoldli (v # va) c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') [] (v # va) *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli [] c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')", "apply (rule fr_refl)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt Rs s' s *\n                     hn_ctxt (list_assn Rl) as cs)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid Rs s' s *\n                     hn_ctxt (list_assn Rl'') as cs)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S\\<rbrakk>\n       \\<Longrightarrow> hn_val bool_rel True x' *\n                         hn_ctxt (list_assn Rl) as cs *\n                         \\<Gamma> *\n                         hn_ctxt Rl a ca \\<Longrightarrow>\\<^sub>A\n                         ?F53 a as ca cs s s' True x' * \\<Gamma> *\n                         hn_ctxt Rl a ca\n 2. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S;\n        RETURN xa \\<le> f' a s'\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?F53 a as ca cs s s' x x' *\n                           (\\<Gamma> * hn_ctxt Rl' a ca *\n                            hn_invalid Rs s' s) *\n                           hn_ctxt Rs xa x'a)\n                          (imp_nfoldli cs c f x'a)\n                          (?\\<Gamma>2.48 a as ca cs s s' x x' xa x'a) Rs\n                          (monadic_nfoldli as c'\n                            (\\<lambda>x s.\n                                ASSERT (x \\<in> S) \\<bind>\n                                (\\<lambda>_. f' x s))\n                            xa)\n 3. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.48 a as ca cs s s' x x' xa\n                          x'a \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2b33 a as ca cs s s' True x' *\n                         hn_ctxt (?Rx48 a as ca cs s s' x x') xa x'a\n 4. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN x \\<le> c' s'; \\<not> x\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n                           \\<Gamma> *\n                           hn_ctxt Rs s' s *\n                           hn_val bool_rel x x')\n                          (return s) (?\\<Gamma>2c33 a as ca cs s s' x x') Rs\n                          (RETURN s')\n 5. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN x \\<le> c' s'\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2b33 a as ca cs s s' x x' \\<or>\\<^sub>A\n                         ?\\<Gamma>2c33 a as ca cs s s' x\n                          x' \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.19 a as ca cs s s' x x'\n 6. \\<And>a as ca cs s s' x x'.\n       (\\<And>s s'.\n           hn_refine\n            (\\<Gamma> * hn_ctxt (list_assn Rl) as cs * hn_ctxt Rs s' s)\n            (imp_nfoldli cs c f s)\n            (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs * hn_invalid Rs s' s)\n            Rs (monadic_nfoldli as c'\n                 (\\<lambda>x s.\n                     ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n                 s')) \\<Longrightarrow>\n       ?\\<Gamma>2.19 a as ca cs s s' x x' \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt (list_assn Rl'') (a # as) (ca # cs) *\n       hn_invalid Rs s' s *\n       hn_ctxt (?Rx19 a as ca cs s s') x x'\n 7. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) (v # va) [] * hn_ctxt Rs s' s)\n        (imp_nfoldli [] c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') (v # va) [] *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli (v # va) c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')\n 8. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) [] (v # va) * hn_ctxt Rs s' s)\n        (imp_nfoldli (v # va) c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') [] (v # va) *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli [] c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')", "apply (rule fr_refl)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt Rs s' s *\n                     hn_ctxt (list_assn Rl) as cs)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid Rs s' s *\n                     hn_ctxt (list_assn Rl'') as cs)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S\\<rbrakk>\n       \\<Longrightarrow> hn_val bool_rel True x' *\n                         hn_ctxt (list_assn Rl) as cs *\n                         \\<Gamma> \\<Longrightarrow>\\<^sub>A\n                         ?F53 a as ca cs s s' True x' * \\<Gamma>\n 2. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S;\n        RETURN xa \\<le> f' a s'\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?F53 a as ca cs s s' x x' *\n                           (\\<Gamma> * hn_ctxt Rl' a ca *\n                            hn_invalid Rs s' s) *\n                           hn_ctxt Rs xa x'a)\n                          (imp_nfoldli cs c f x'a)\n                          (?\\<Gamma>2.48 a as ca cs s s' x x' xa x'a) Rs\n                          (monadic_nfoldli as c'\n                            (\\<lambda>x s.\n                                ASSERT (x \\<in> S) \\<bind>\n                                (\\<lambda>_. f' x s))\n                            xa)\n 3. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.48 a as ca cs s s' x x' xa\n                          x'a \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2b33 a as ca cs s s' True x' *\n                         hn_ctxt (?Rx48 a as ca cs s s' x x') xa x'a\n 4. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN x \\<le> c' s'; \\<not> x\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n                           \\<Gamma> *\n                           hn_ctxt Rs s' s *\n                           hn_val bool_rel x x')\n                          (return s) (?\\<Gamma>2c33 a as ca cs s s' x x') Rs\n                          (RETURN s')\n 5. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN x \\<le> c' s'\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2b33 a as ca cs s s' x x' \\<or>\\<^sub>A\n                         ?\\<Gamma>2c33 a as ca cs s s' x\n                          x' \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.19 a as ca cs s s' x x'\n 6. \\<And>a as ca cs s s' x x'.\n       (\\<And>s s'.\n           hn_refine\n            (\\<Gamma> * hn_ctxt (list_assn Rl) as cs * hn_ctxt Rs s' s)\n            (imp_nfoldli cs c f s)\n            (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs * hn_invalid Rs s' s)\n            Rs (monadic_nfoldli as c'\n                 (\\<lambda>x s.\n                     ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n                 s')) \\<Longrightarrow>\n       ?\\<Gamma>2.19 a as ca cs s s' x x' \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt (list_assn Rl'') (a # as) (ca # cs) *\n       hn_invalid Rs s' s *\n       hn_ctxt (?Rx19 a as ca cs s s') x x'\n 7. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) (v # va) [] * hn_ctxt Rs s' s)\n        (imp_nfoldli [] c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') (v # va) [] *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli (v # va) c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')\n 8. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) [] (v # va) * hn_ctxt Rs s' s)\n        (imp_nfoldli (v # va) c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') [] (v # va) *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli [] c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')", "apply (rule fr_refl)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt Rs s' s *\n                     hn_ctxt (list_assn Rl) as cs)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid Rs s' s *\n                     hn_ctxt (list_assn Rl'') as cs)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S\\<rbrakk>\n       \\<Longrightarrow> hn_val bool_rel True x' *\n                         hn_ctxt (list_assn Rl) as\n                          cs \\<Longrightarrow>\\<^sub>A\n                         ?F53 a as ca cs s s' True x'\n 2. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S;\n        RETURN xa \\<le> f' a s'\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?F53 a as ca cs s s' x x' *\n                           (\\<Gamma> * hn_ctxt Rl' a ca *\n                            hn_invalid Rs s' s) *\n                           hn_ctxt Rs xa x'a)\n                          (imp_nfoldli cs c f x'a)\n                          (?\\<Gamma>2.48 a as ca cs s s' x x' xa x'a) Rs\n                          (monadic_nfoldli as c'\n                            (\\<lambda>x s.\n                                ASSERT (x \\<in> S) \\<bind>\n                                (\\<lambda>_. f' x s))\n                            xa)\n 3. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.48 a as ca cs s s' x x' xa\n                          x'a \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2b33 a as ca cs s s' True x' *\n                         hn_ctxt (?Rx48 a as ca cs s s' x x') xa x'a\n 4. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN x \\<le> c' s'; \\<not> x\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n                           \\<Gamma> *\n                           hn_ctxt Rs s' s *\n                           hn_val bool_rel x x')\n                          (return s) (?\\<Gamma>2c33 a as ca cs s s' x x') Rs\n                          (RETURN s')\n 5. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN x \\<le> c' s'\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2b33 a as ca cs s s' x x' \\<or>\\<^sub>A\n                         ?\\<Gamma>2c33 a as ca cs s s' x\n                          x' \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.19 a as ca cs s s' x x'\n 6. \\<And>a as ca cs s s' x x'.\n       (\\<And>s s'.\n           hn_refine\n            (\\<Gamma> * hn_ctxt (list_assn Rl) as cs * hn_ctxt Rs s' s)\n            (imp_nfoldli cs c f s)\n            (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs * hn_invalid Rs s' s)\n            Rs (monadic_nfoldli as c'\n                 (\\<lambda>x s.\n                     ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n                 s')) \\<Longrightarrow>\n       ?\\<Gamma>2.19 a as ca cs s s' x x' \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt (list_assn Rl'') (a # as) (ca # cs) *\n       hn_invalid Rs s' s *\n       hn_ctxt (?Rx19 a as ca cs s s') x x'\n 7. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) (v # va) [] * hn_ctxt Rs s' s)\n        (imp_nfoldli [] c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') (v # va) [] *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli (v # va) c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')\n 8. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) [] (v # va) * hn_ctxt Rs s' s)\n        (imp_nfoldli (v # va) c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') [] (v # va) *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli [] c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')", "apply (rule ent_refl)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S;\n        RETURN xa \\<le> f' a s'\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_val bool_rel x x' *\n                           hn_ctxt (list_assn Rl) as cs *\n                           (\\<Gamma> * hn_ctxt Rl' a ca *\n                            hn_invalid Rs s' s) *\n                           hn_ctxt Rs xa x'a)\n                          (imp_nfoldli cs c f x'a)\n                          (?\\<Gamma>2.48 a as ca cs s s' x x' xa x'a) Rs\n                          (monadic_nfoldli as c'\n                            (\\<lambda>x s.\n                                ASSERT (x \\<in> S) \\<bind>\n                                (\\<lambda>_. f' x s))\n                            xa)\n 2. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.48 a as ca cs s s' x x' xa\n                          x'a \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2b33 a as ca cs s s' True x' *\n                         hn_ctxt (?Rx48 a as ca cs s s' x x') xa x'a\n 3. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN x \\<le> c' s'; \\<not> x\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n                           \\<Gamma> *\n                           hn_ctxt Rs s' s *\n                           hn_val bool_rel x x')\n                          (return s) (?\\<Gamma>2c33 a as ca cs s s' x x') Rs\n                          (RETURN s')\n 4. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN x \\<le> c' s'\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2b33 a as ca cs s s' x x' \\<or>\\<^sub>A\n                         ?\\<Gamma>2c33 a as ca cs s s' x\n                          x' \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.19 a as ca cs s s' x x'\n 5. \\<And>a as ca cs s s' x x'.\n       (\\<And>s s'.\n           hn_refine\n            (\\<Gamma> * hn_ctxt (list_assn Rl) as cs * hn_ctxt Rs s' s)\n            (imp_nfoldli cs c f s)\n            (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs * hn_invalid Rs s' s)\n            Rs (monadic_nfoldli as c'\n                 (\\<lambda>x s.\n                     ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n                 s')) \\<Longrightarrow>\n       ?\\<Gamma>2.19 a as ca cs s s' x x' \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt (list_assn Rl'') (a # as) (ca # cs) *\n       hn_invalid Rs s' s *\n       hn_ctxt (?Rx19 a as ca cs s s') x x'\n 6. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) (v # va) [] * hn_ctxt Rs s' s)\n        (imp_nfoldli [] c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') (v # va) [] *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli (v # va) c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')\n 7. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) [] (v # va) * hn_ctxt Rs s' s)\n        (imp_nfoldli (v # va) c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') [] (v # va) *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli [] c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')", "applyF (rule hn_refine_frame)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S;\n        RETURN xa \\<le> f' a s'\\<rbrakk>\n       \\<Longrightarrow> hn_refine (?P'72 a as ca cs s s' x x' xa x'a)\n                          (imp_nfoldli cs c f x'a)\n                          (?Q'72 a as ca cs s s' x x' xa x'a) Rs\n                          (monadic_nfoldli as c'\n                            (\\<lambda>x s.\n                                ASSERT (x \\<in> S) \\<bind>\n                                (\\<lambda>_. f' x s))\n                            xa)\n 2. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S;\n        RETURN xa \\<le> f' a s'\\<rbrakk>\n       \\<Longrightarrow> hn_val bool_rel x x' *\n                         hn_ctxt (list_assn Rl) as cs *\n                         (\\<Gamma> * hn_ctxt Rl' a ca *\n                          hn_invalid Rs s' s) *\n                         hn_ctxt Rs xa x'a \\<Longrightarrow>\\<^sub>t\n                         ?F72 a as ca cs s s' x x' xa x'a *\n                         ?P'72 a as ca cs s s' x x' xa x'a", "applyS rprems"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S;\n        RETURN xa \\<le> f' a s'\\<rbrakk>\n       \\<Longrightarrow> hn_val bool_rel x x' *\n                         hn_ctxt (list_assn Rl) as cs *\n                         (\\<Gamma> * hn_ctxt Rl' a ca *\n                          hn_invalid Rs s' s) *\n                         hn_ctxt Rs xa x'a \\<Longrightarrow>\\<^sub>t\n                         ?F72 a as ca cs s s' x x' xa x'a *\n                         (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                          hn_ctxt Rs xa x'a)", "focus"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S;\n        RETURN xa \\<le> f' a s'\\<rbrakk>\n       \\<Longrightarrow> hn_val bool_rel x x' *\n                         hn_ctxt (list_assn Rl) as cs *\n                         (\\<Gamma> * hn_ctxt Rl' a ca *\n                          hn_invalid Rs s' s) *\n                         hn_ctxt Rs xa x'a \\<Longrightarrow>\\<^sub>t\n                         ?F72 a as ca cs s s' x x' xa x'a *\n                         (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                          hn_ctxt Rs xa x'a)", "apply (simp add: assn_aci)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt Rs s' s *\n                     hn_ctxt (list_assn Rl) as cs)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid Rs s' s *\n                     hn_ctxt (list_assn Rl'') as cs)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S;\n        RETURN xa \\<le> f' a s'\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> * hn_ctxt Rl' a ca * hn_ctxt Rs xa x'a *\n                         hn_invalid Rs s' s *\n                         hn_val bool_rel True x' *\n                         hn_ctxt (list_assn Rl) as\n                          cs \\<Longrightarrow>\\<^sub>t\n                         \\<Gamma> * hn_ctxt Rs xa x'a *\n                         hn_ctxt (list_assn Rl) as cs *\n                         ?F72 a as ca cs s s' True x' xa x'a", "apply (rule ent_imp_entt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt Rs s' s *\n                     hn_ctxt (list_assn Rl) as cs)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid Rs s' s *\n                     hn_ctxt (list_assn Rl'') as cs)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S;\n        RETURN xa \\<le> f' a s'\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> * hn_ctxt Rl' a ca * hn_ctxt Rs xa x'a *\n                         hn_invalid Rs s' s *\n                         hn_val bool_rel True x' *\n                         hn_ctxt (list_assn Rl) as\n                          cs \\<Longrightarrow>\\<^sub>A\n                         \\<Gamma> * hn_ctxt Rs xa x'a *\n                         hn_ctxt (list_assn Rl) as cs *\n                         ?F72 a as ca cs s s' True x' xa x'a", "apply (fr_rot_rhs 1, rule fr_refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt Rs s' s *\n                     hn_ctxt (list_assn Rl) as cs)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid Rs s' s *\n                     hn_ctxt (list_assn Rl'') as cs)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S;\n        RETURN xa \\<le> f' a s'\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> * hn_ctxt Rl' a ca * hn_ctxt Rs xa x'a *\n                         hn_invalid Rs s' s *\n                         hn_val bool_rel True x' \\<Longrightarrow>\\<^sub>A\n                         ?F72 a as ca cs s s' True x' xa x'a * \\<Gamma> *\n                         hn_ctxt Rs xa x'a", "apply (fr_rot 2, rule fr_refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt Rs s' s *\n                     hn_ctxt (list_assn Rl) as cs)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid Rs s' s *\n                     hn_ctxt (list_assn Rl'') as cs)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S;\n        RETURN xa \\<le> f' a s'\\<rbrakk>\n       \\<Longrightarrow> hn_invalid Rs s' s * hn_val bool_rel True x' *\n                         \\<Gamma> *\n                         hn_ctxt Rl' a ca \\<Longrightarrow>\\<^sub>A\n                         ?F72 a as ca cs s s' True x' xa x'a * \\<Gamma>", "apply (fr_rot 1, rule fr_refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt Rs s' s *\n                     hn_ctxt (list_assn Rl) as cs)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_invalid Rs s' s *\n                     hn_ctxt (list_assn Rl'') as cs)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S;\n        RETURN xa \\<le> f' a s'\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt Rl' a ca * hn_invalid Rs s' s *\n                         hn_val bool_rel True x' \\<Longrightarrow>\\<^sub>A\n                         ?F72 a as ca cs s s' True x' xa x'a", "apply (rule ent_refl)"], ["proof (prove)\ngoal:\nNo subgoals!", "solved"], ["proof (prove)\ngoal:\nNo subgoals!", "solved"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt Rl' a ca * hn_invalid Rs s' s *\n                         hn_val bool_rel x x' *\n                         (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                          hn_invalid Rs xa x'a) \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2b33 a as ca cs s s' True x' *\n                         hn_ctxt (?Rx48 a as ca cs s s' x x') xa x'a\n 2. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN x \\<le> c' s'; \\<not> x\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n                           \\<Gamma> *\n                           hn_ctxt Rs s' s *\n                           hn_val bool_rel x x')\n                          (return s) (?\\<Gamma>2c33 a as ca cs s s' x x') Rs\n                          (RETURN s')\n 3. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN x \\<le> c' s'\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2b33 a as ca cs s s' x x' \\<or>\\<^sub>A\n                         ?\\<Gamma>2c33 a as ca cs s s' x\n                          x' \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.19 a as ca cs s s' x x'\n 4. \\<And>a as ca cs s s' x x'.\n       (\\<And>s s'.\n           hn_refine\n            (\\<Gamma> * hn_ctxt (list_assn Rl) as cs * hn_ctxt Rs s' s)\n            (imp_nfoldli cs c f s)\n            (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs * hn_invalid Rs s' s)\n            Rs (monadic_nfoldli as c'\n                 (\\<lambda>x s.\n                     ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n                 s')) \\<Longrightarrow>\n       ?\\<Gamma>2.19 a as ca cs s s' x x' \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt (list_assn Rl'') (a # as) (ca # cs) *\n       hn_invalid Rs s' s *\n       hn_ctxt (?Rx19 a as ca cs s s') x x'\n 5. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) (v # va) [] * hn_ctxt Rs s' s)\n        (imp_nfoldli [] c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') (v # va) [] *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli (v # va) c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')\n 6. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) [] (v # va) * hn_ctxt Rs s' s)\n        (imp_nfoldli (v # va) c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') [] (v # va) *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli [] c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')", "focus (simp add: assn_assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt Rl' a ca * hn_invalid Rs s' s *\n                         hn_val bool_rel True x' *\n                         \\<Gamma> *\n                         hn_ctxt (list_assn Rl'') as cs *\n                         hn_invalid Rs xa x'a \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2b33 a as ca cs s s' True x' *\n                         hn_ctxt (?Rx48 a as ca cs s s' True x') xa x'a", "apply (rule ent_imp_entt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt Rl' a ca * hn_invalid Rs s' s *\n                         hn_val bool_rel True x' *\n                         \\<Gamma> *\n                         hn_ctxt (list_assn Rl'') as cs *\n                         hn_invalid Rs xa x'a \\<Longrightarrow>\\<^sub>A\n                         ?\\<Gamma>2b33 a as ca cs s s' True x' *\n                         hn_ctxt (?Rx48 a as ca cs s s' True x') xa x'a", "apply (rule fr_refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as ca cs s s' x x' xa x'a.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN True \\<le> c' s'; x; a \\<in> S\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt Rl' a ca * hn_invalid Rs s' s *\n                         hn_val bool_rel True x' *\n                         \\<Gamma> *\n                         hn_ctxt (list_assn Rl'') as\n                          cs \\<Longrightarrow>\\<^sub>A\n                         ?\\<Gamma>2b33 a as ca cs s s' True x'", "apply (rule ent_refl)"], ["proof (prove)\ngoal:\nNo subgoals!", "solved"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN x \\<le> c' s'; \\<not> x\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n                           \\<Gamma> *\n                           hn_ctxt Rs s' s *\n                           hn_val bool_rel x x')\n                          (return s) (?\\<Gamma>2c33 a as ca cs s s' x x') Rs\n                          (RETURN s')\n 2. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN x \\<le> c' s'\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt Rl' a ca * hn_invalid Rs s' s *\n                         hn_val bool_rel x x' *\n                         \\<Gamma> *\n                         hn_ctxt (list_assn Rl'') as cs \\<or>\\<^sub>A\n                         ?\\<Gamma>2c33 a as ca cs s s' x\n                          x' \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.19 a as ca cs s s' x x'\n 3. \\<And>a as ca cs s s' x x'.\n       (\\<And>s s'.\n           hn_refine\n            (\\<Gamma> * hn_ctxt (list_assn Rl) as cs * hn_ctxt Rs s' s)\n            (imp_nfoldli cs c f s)\n            (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs * hn_invalid Rs s' s)\n            Rs (monadic_nfoldli as c'\n                 (\\<lambda>x s.\n                     ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n                 s')) \\<Longrightarrow>\n       ?\\<Gamma>2.19 a as ca cs s s' x x' \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt (list_assn Rl'') (a # as) (ca # cs) *\n       hn_invalid Rs s' s *\n       hn_ctxt (?Rx19 a as ca cs s s') x x'\n 4. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) (v # va) [] * hn_ctxt Rs s' s)\n        (imp_nfoldli [] c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') (v # va) [] *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli (v # va) c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')\n 5. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) [] (v # va) * hn_ctxt Rs s' s)\n        (imp_nfoldli (v # va) c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') [] (v # va) *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli [] c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')", "apply1 (rule hn_refine_frame[OF hnr_RETURN_pass])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN x \\<le> c' s'; \\<not> x\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n                         \\<Gamma> *\n                         hn_ctxt Rs s' s *\n                         hn_val bool_rel x x' \\<Longrightarrow>\\<^sub>t\n                         ?F186 a as ca cs s s' x x' * hn_ctxt Rs s' s\n 2. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN x \\<le> c' s'\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt Rl' a ca * hn_invalid Rs s' s *\n                         hn_val bool_rel x x' *\n                         \\<Gamma> *\n                         hn_ctxt (list_assn Rl'') as cs \\<or>\\<^sub>A\n                         ?F186 a as ca cs s s' x x' *\n                         hn_invalid Rs s' s \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.19 a as ca cs s s' x x'\n 3. \\<And>a as ca cs s s' x x'.\n       (\\<And>s s'.\n           hn_refine\n            (\\<Gamma> * hn_ctxt (list_assn Rl) as cs * hn_ctxt Rs s' s)\n            (imp_nfoldli cs c f s)\n            (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs * hn_invalid Rs s' s)\n            Rs (monadic_nfoldli as c'\n                 (\\<lambda>x s.\n                     ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n                 s')) \\<Longrightarrow>\n       ?\\<Gamma>2.19 a as ca cs s s' x x' \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt (list_assn Rl'') (a # as) (ca # cs) *\n       hn_invalid Rs s' s *\n       hn_ctxt (?Rx19 a as ca cs s s') x x'\n 4. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) (v # va) [] * hn_ctxt Rs s' s)\n        (imp_nfoldli [] c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') (v # va) [] *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli (v # va) c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')\n 5. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) [] (v # va) * hn_ctxt Rs s' s)\n        (imp_nfoldli (v # va) c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') [] (v # va) *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli [] c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')", "applyS (tactic \\<open>Sepref_Frame.frame_tac (K (K no_tac)) @{context} 1\\<close>)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN x \\<le> c' s'\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt Rl' a ca * hn_invalid Rs s' s *\n                         hn_val bool_rel x x' *\n                         \\<Gamma> *\n                         hn_ctxt (list_assn Rl'') as cs \\<or>\\<^sub>A\n                         hn_ctxt (list_assn Rl) (a # as) (ca # cs) *\n                         \\<Gamma> *\n                         hn_val bool_rel x x' *\n                         hn_invalid Rs s' s \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.19 a as ca cs s s' x x'\n 2. \\<And>a as ca cs s s' x x'.\n       (\\<And>s s'.\n           hn_refine\n            (\\<Gamma> * hn_ctxt (list_assn Rl) as cs * hn_ctxt Rs s' s)\n            (imp_nfoldli cs c f s)\n            (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs * hn_invalid Rs s' s)\n            Rs (monadic_nfoldli as c'\n                 (\\<lambda>x s.\n                     ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n                 s')) \\<Longrightarrow>\n       ?\\<Gamma>2.19 a as ca cs s s' x x' \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt (list_assn Rl'') (a # as) (ca # cs) *\n       hn_invalid Rs s' s *\n       hn_ctxt (?Rx19 a as ca cs s s') x x'\n 3. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) (v # va) [] * hn_ctxt Rs s' s)\n        (imp_nfoldli [] c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') (v # va) [] *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli (v # va) c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')\n 4. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) [] (v # va) * hn_ctxt Rs s' s)\n        (imp_nfoldli (v # va) c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') [] (v # va) *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli [] c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')", "apply1 (simp add: assn_assoc)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a as ca cs s s' x x'.\n       \\<lbrakk>\\<And>s s'.\n                   hn_refine\n                    (\\<Gamma> * hn_ctxt (list_assn Rl) as cs *\n                     hn_ctxt Rs s' s)\n                    (imp_nfoldli cs c f s)\n                    (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs *\n                     hn_invalid Rs s' s)\n                    Rs (monadic_nfoldli as c'\n                         (\\<lambda>x s.\n                             ASSERT (x \\<in> S) \\<bind>\n                             (\\<lambda>_. f' x s))\n                         s');\n        RETURN x \\<le> c' s'\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt Rl' a ca * hn_invalid Rs s' s *\n                         hn_val bool_rel x x' *\n                         \\<Gamma> *\n                         hn_ctxt (list_assn Rl'') as cs \\<or>\\<^sub>A\n                         hn_ctxt Rl a ca * hn_ctxt (list_assn Rl) as cs *\n                         \\<Gamma> *\n                         hn_val bool_rel x x' *\n                         hn_invalid Rs s' s \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.19 a as ca cs s s' x x'\n 2. \\<And>a as ca cs s s' x x'.\n       (\\<And>s s'.\n           hn_refine\n            (\\<Gamma> * hn_ctxt (list_assn Rl) as cs * hn_ctxt Rs s' s)\n            (imp_nfoldli cs c f s)\n            (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs * hn_invalid Rs s' s)\n            Rs (monadic_nfoldli as c'\n                 (\\<lambda>x s.\n                     ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n                 s')) \\<Longrightarrow>\n       ?\\<Gamma>2.19 a as ca cs s s' x x' \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt (list_assn Rl'') (a # as) (ca # cs) *\n       hn_invalid Rs s' s *\n       hn_ctxt (?Rx19 a as ca cs s s') x x'\n 3. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) (v # va) [] * hn_ctxt Rs s' s)\n        (imp_nfoldli [] c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') (v # va) [] *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli (v # va) c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')\n 4. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) [] (v # va) * hn_ctxt Rs s' s)\n        (imp_nfoldli (v # va) c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') [] (v # va) *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli [] c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')", "applyS (tactic \\<open>Sepref_Frame.merge_tac (K (K no_tac)) @{context} 1\\<close>)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a as ca cs s s' x x'.\n       (\\<And>s s'.\n           hn_refine\n            (\\<Gamma> * hn_ctxt (list_assn Rl) as cs * hn_ctxt Rs s' s)\n            (imp_nfoldli cs c f s)\n            (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs * hn_invalid Rs s' s)\n            Rs (monadic_nfoldli as c'\n                 (\\<lambda>x s.\n                     ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n                 s')) \\<Longrightarrow>\n       \\<Gamma> * hn_val bool_rel x x' * hn_invalid Rs s' s *\n       hn_ctxt (list_assn Rl'') as cs *\n       hn_ctxt Rl'' a ca \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt (list_assn Rl'') (a # as) (ca # cs) *\n       hn_invalid Rs s' s *\n       hn_ctxt (?Rx19 a as ca cs s s') x x'\n 2. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) (v # va) [] * hn_ctxt Rs s' s)\n        (imp_nfoldli [] c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') (v # va) [] *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli (v # va) c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')\n 3. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) [] (v # va) * hn_ctxt Rs s' s)\n        (imp_nfoldli (v # va) c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') [] (v # va) *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli [] c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a as ca cs s s' x x'.\n       (\\<And>s s'.\n           hn_refine\n            (\\<Gamma> * hn_ctxt (list_assn Rl) as cs * hn_ctxt Rs s' s)\n            (imp_nfoldli cs c f s)\n            (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs * hn_invalid Rs s' s)\n            Rs (monadic_nfoldli as c'\n                 (\\<lambda>x s.\n                     ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n                 s')) \\<Longrightarrow>\n       \\<Gamma> * hn_val bool_rel x x' * hn_invalid Rs s' s *\n       hn_ctxt (list_assn Rl'') as cs *\n       hn_ctxt Rl'' a ca \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * (hn_ctxt Rl'' a ca * hn_ctxt (list_assn Rl'') as cs) *\n       hn_invalid Rs s' s *\n       hn_ctxt (?Rx19 a as ca cs s s') x x'\n 2. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) (v # va) [] * hn_ctxt Rs s' s)\n        (imp_nfoldli [] c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') (v # va) [] *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli (v # va) c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')\n 3. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) [] (v # va) * hn_ctxt Rs s' s)\n        (imp_nfoldli (v # va) c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') [] (v # va) *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli [] c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')", "apply (rule ent_imp_entt)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a as ca cs s s' x x'.\n       (\\<And>s s'.\n           hn_refine\n            (\\<Gamma> * hn_ctxt (list_assn Rl) as cs * hn_ctxt Rs s' s)\n            (imp_nfoldli cs c f s)\n            (\\<Gamma> * hn_ctxt (list_assn Rl'') as cs * hn_invalid Rs s' s)\n            Rs (monadic_nfoldli as c'\n                 (\\<lambda>x s.\n                     ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n                 s')) \\<Longrightarrow>\n       \\<Gamma> * hn_val bool_rel x x' * hn_invalid Rs s' s *\n       hn_ctxt (list_assn Rl'') as cs *\n       hn_ctxt Rl'' a ca \\<Longrightarrow>\\<^sub>A\n       \\<Gamma> * (hn_ctxt Rl'' a ca * hn_ctxt (list_assn Rl'') as cs) *\n       hn_invalid Rs s' s *\n       hn_ctxt (?Rx19 a as ca cs s s') x x'\n 2. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) (v # va) [] * hn_ctxt Rs s' s)\n        (imp_nfoldli [] c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') (v # va) [] *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli (v # va) c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')\n 3. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) [] (v # va) * hn_ctxt Rs s' s)\n        (imp_nfoldli (v # va) c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') [] (v # va) *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli [] c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')", "apply solve_entails"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) (v # va) [] * hn_ctxt Rs s' s)\n        (imp_nfoldli [] c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') (v # va) [] *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli (v # va) c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')\n 2. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) [] (v # va) * hn_ctxt Rs s' s)\n        (imp_nfoldli (v # va) c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') [] (v # va) *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli [] c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')", "apply (rule, sep_auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v va s s'.\n       hn_refine\n        (\\<Gamma> * hn_ctxt (list_assn Rl) [] (v # va) * hn_ctxt Rs s' s)\n        (imp_nfoldli (v # va) c f s)\n        (\\<Gamma> * hn_ctxt (list_assn Rl'') [] (v # va) *\n         hn_invalid Rs s' s)\n        Rs (monadic_nfoldli [] c'\n             (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f' x s))\n             s')", "apply (rule, sep_auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "solved"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hn_monadic_nfoldli_rl'[sepref_comb_rules]:\n  assumes \"INDEP Rk\" \"INDEP R\\<sigma>\"\n  assumes FR: \"P \\<Longrightarrow>\\<^sub>t \\<Gamma> * hn_ctxt (list_assn Rk) s' s * hn_ctxt R\\<sigma> \\<sigma>' \\<sigma>\"\n  assumes c_ref: \"\\<And>\\<sigma> \\<sigma>'. hn_refine \n    (\\<Gamma> * hn_ctxt R\\<sigma> \\<sigma>' \\<sigma>) \n    (c \\<sigma>) \n    (\\<Gamma>c \\<sigma>' \\<sigma>) \n    bool_assn \n    (c' \\<sigma>')\"\n  assumes C_FR: \n    \"\\<And>\\<sigma>' \\<sigma>. TERM monadic_nfoldli \\<Longrightarrow> \n      \\<Gamma>c \\<sigma>' \\<sigma> \\<Longrightarrow>\\<^sub>t \\<Gamma> * hn_ctxt R\\<sigma> \\<sigma>' \\<sigma>\"\n\n  assumes f_ref: \"\\<And>x' x \\<sigma>' \\<sigma>. \\<lbrakk>x'\\<in>set s'\\<rbrakk> \\<Longrightarrow> hn_refine \n    (\\<Gamma> * hn_ctxt Rk x' x * hn_ctxt R\\<sigma> \\<sigma>' \\<sigma>)\n    (f x \\<sigma>)\n    (\\<Gamma>f x' x \\<sigma>' \\<sigma>) R\\<sigma>\n    (f' x' \\<sigma>')\"\n  assumes F_FR: \"\\<And>x' x \\<sigma>' \\<sigma>. TERM monadic_nfoldli \\<Longrightarrow> \\<Gamma>f x' x \\<sigma>' \\<sigma> \\<Longrightarrow>\\<^sub>t \n    \\<Gamma> * hn_ctxt Rk' x' x * hn_ctxt Pf\\<sigma> \\<sigma>' \\<sigma>\"\n\n  assumes MERGE: \"\\<And>x x'. hn_ctxt Rk' x' x \\<or>\\<^sub>A hn_ctxt Rk x' x \\<Longrightarrow>\\<^sub>t hn_ctxt Rk'' x' x\"  \n\n  shows \"hn_refine \n    P \n    (imp_nfoldli s c f \\<sigma>) \n    (\\<Gamma> * hn_ctxt (list_assn Rk'') s' s * hn_invalid R\\<sigma> \\<sigma>' \\<sigma>)\n    R\\<sigma>\n    ((monadic_nfoldli)\n      $s'$(\\<lambda>\\<^sub>2\\<sigma>'. c' \\<sigma>')$(\\<lambda>\\<^sub>2x' \\<sigma>'. f' x' \\<sigma>')$\\<sigma>'\n    )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine P (imp_nfoldli s c f \\<sigma>)\n     (\\<Gamma> * hn_ctxt (list_assn Rk'') s' s *\n      hn_invalid R\\<sigma> \\<sigma>' \\<sigma>)\n     R\\<sigma>\n     (monadic_nfoldli $ s' $ (\\<lambda>x. (#c' x#)) $\n      (\\<lambda>x. (#\\<lambda>xa. (#f' x xa#)#)) $\n      \\<sigma>')", "unfolding APP_def PROTECT2_def PR_CONST_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine P (imp_nfoldli s c f \\<sigma>)\n     (\\<Gamma> * hn_ctxt (list_assn Rk'') s' s *\n      hn_invalid R\\<sigma> \\<sigma>' \\<sigma>)\n     R\\<sigma> (monadic_nfoldli s' c' f' \\<sigma>')", "apply1 (rule hn_refine_cons_pre[OF FR])"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine\n     (\\<Gamma> * hn_ctxt (list_assn Rk) s' s *\n      hn_ctxt R\\<sigma> \\<sigma>' \\<sigma>)\n     (imp_nfoldli s c f \\<sigma>)\n     (\\<Gamma> * hn_ctxt (list_assn Rk'') s' s *\n      hn_invalid R\\<sigma> \\<sigma>' \\<sigma>)\n     R\\<sigma> (monadic_nfoldli s' c' f' \\<sigma>')", "apply1 weaken_hnr_post"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine\n     (\\<Gamma> * hn_ctxt (list_assn Rk) s' s *\n      hn_ctxt R\\<sigma> \\<sigma>' \\<sigma>)\n     (imp_nfoldli s c f \\<sigma>)\n     (\\<Gamma> * hn_ctxt (list_assn Rk'') s' s *\n      hn_ctxt (\\<lambda>_ _. true) \\<sigma>' \\<sigma>)\n     R\\<sigma> (monadic_nfoldli s' c' f' \\<sigma>')", "applyF (rule hn_refine_cons[rotated])"], ["proof (prove)\ngoal (4 subgoals):\n 1. hn_refine ?P'13 (imp_nfoldli s c f \\<sigma>) ?Q13 ?R13\n     (monadic_nfoldli s' c' f' \\<sigma>')\n 2. ?Q13 \\<Longrightarrow>\\<^sub>t\n    \\<Gamma> * hn_ctxt (list_assn Rk'') s' s *\n    hn_ctxt (\\<lambda>_ _. true) \\<sigma>' \\<sigma>\n 3. \\<And>x y. ?R13 x y \\<Longrightarrow>\\<^sub>t R\\<sigma> x y\n 4. \\<Gamma> * hn_ctxt (list_assn Rk) s' s *\n    hn_ctxt R\\<sigma> \\<sigma>' \\<sigma> \\<Longrightarrow>\\<^sub>t\n    ?P'13", "applyF (rule monadic_nfoldli_refine_aux'[OF order_refl])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s s'.\n       hn_refine (?\\<Gamma>19 * hn_ctxt ?R13 s' s) (c s)\n        (?\\<Gamma>19 * hn_ctxt ?R13 s' s) bool_assn (c' s')\n 2. \\<And>x x' s s'a.\n       x' \\<in> set s' \\<Longrightarrow>\n       hn_refine (?\\<Gamma>19 * hn_ctxt ?Rl19 x' x * hn_ctxt ?R13 s'a s)\n        (f x s) (?\\<Gamma>19 * hn_ctxt ?Rl'19 x' x * hn_invalid ?R13 s'a s)\n        ?R13 (f' x' s'a)\n 3. \\<And>x x'.\n       hn_ctxt ?Rl'19 x' x \\<or>\\<^sub>A\n       hn_ctxt ?Rl19 x' x \\<Longrightarrow>\\<^sub>t\n       hn_ctxt ?Rl''19 x' x", "focus"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       hn_refine (?\\<Gamma>19 * hn_ctxt ?R13 s' s) (c s)\n        (?\\<Gamma>19 * hn_ctxt ?R13 s' s) bool_assn (c' s')", "apply (rule hn_refine_cons_post)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       hn_refine (?\\<Gamma>19 * hn_ctxt ?R13 s' s) (c s) (?Q25 s s')\n        bool_assn (c' s')\n 2. \\<And>s s'.\n       ?Q25 s s' \\<Longrightarrow>\\<^sub>t ?\\<Gamma>19 * hn_ctxt ?R13 s' s", "applyS (rule c_ref)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<Gamma>c s' s \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt R\\<sigma> s' s", "apply1 (rule entt_trans[OF C_FR[OF TERMI]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<Gamma> * hn_ctxt R\\<sigma> s' s \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt R\\<sigma> s' s", "applyS (rule entt_refl)"], ["proof (prove)\ngoal:\nNo subgoals!", "solved"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x' s s'a.\n       x' \\<in> set s' \\<Longrightarrow>\n       hn_refine (\\<Gamma> * hn_ctxt ?Rl19 x' x * hn_ctxt R\\<sigma> s'a s)\n        (f x s)\n        (\\<Gamma> * hn_ctxt ?Rl'19 x' x * hn_invalid R\\<sigma> s'a s)\n        R\\<sigma> (f' x' s'a)\n 2. \\<And>x x'.\n       hn_ctxt ?Rl'19 x' x \\<or>\\<^sub>A\n       hn_ctxt ?Rl19 x' x \\<Longrightarrow>\\<^sub>t\n       hn_ctxt ?Rl''19 x' x", "apply1 weaken_hnr_post"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x' s s'a.\n       x' \\<in> set s' \\<Longrightarrow>\n       hn_refine (\\<Gamma> * hn_ctxt ?Rl8 x' x * hn_ctxt R\\<sigma> s'a s)\n        (f x s)\n        (\\<Gamma> * hn_ctxt ?Rl'8 x' x * hn_ctxt (\\<lambda>_ _. true) s'a s)\n        R\\<sigma> (f' x' s'a)\n 2. \\<And>x x'.\n       hn_ctxt ?Rl'8 x' x \\<or>\\<^sub>A\n       hn_ctxt ?Rl8 x' x \\<Longrightarrow>\\<^sub>t\n       hn_ctxt ?Rl''8 x' x", "applyF (rule hn_refine_cons_post)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x' s s'a.\n       x' \\<in> set s' \\<Longrightarrow>\n       hn_refine (\\<Gamma> * hn_ctxt ?Rl8 x' x * hn_ctxt R\\<sigma> s'a s)\n        (f x s) (?Q11 x x' s s'a) R\\<sigma> (f' x' s'a)\n 2. \\<And>x x' s s'a.\n       x' \\<in> set s' \\<Longrightarrow>\n       ?Q11 x x' s s'a \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt ?Rl'8 x' x * hn_ctxt (\\<lambda>_ _. true) s'a s", "applyS (rule f_ref; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x' s s'a.\n       x' \\<in> set s' \\<Longrightarrow>\n       \\<Gamma>f x' x s'a s \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt ?Rl'8 x' x * hn_ctxt (\\<lambda>_ _. true) s'a s", "apply1 (rule entt_trans[OF F_FR[OF TERMI]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x' s s'a.\n       x' \\<in> set s' \\<Longrightarrow>\n       \\<Gamma> * hn_ctxt Rk' x' x *\n       hn_ctxt Pf\\<sigma> s'a s \\<Longrightarrow>\\<^sub>t\n       \\<Gamma> * hn_ctxt ?Rl'8 x' x * hn_ctxt (\\<lambda>_ _. true) s'a s", "applyS (tactic \\<open>Sepref_Frame.frame_tac (K (K no_tac)) @{context} 1\\<close>)"], ["proof (prove)\ngoal:\nNo subgoals!", "solved"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x'.\n       hn_ctxt Rk' x' x \\<or>\\<^sub>A\n       hn_ctxt Rk x' x \\<Longrightarrow>\\<^sub>t\n       hn_ctxt ?Rl''8 x' x", "apply (rule MERGE)"], ["proof (prove)\ngoal:\nNo subgoals!", "solved"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<Gamma> * hn_ctxt (list_assn Rk'') s' s *\n    hn_invalid R\\<sigma> \\<sigma>' \\<sigma> \\<Longrightarrow>\\<^sub>t\n    \\<Gamma> * hn_ctxt (list_assn Rk'') s' s *\n    hn_ctxt (\\<lambda>_ _. true) \\<sigma>' \\<sigma>\n 2. \\<And>x y. R\\<sigma> x y \\<Longrightarrow>\\<^sub>t R\\<sigma> x y\n 3. \\<Gamma> * hn_ctxt (list_assn Rk) s' s *\n    hn_ctxt R\\<sigma> \\<sigma>' \\<sigma> \\<Longrightarrow>\\<^sub>t\n    \\<Gamma> * hn_ctxt (list_assn Rk) s' s *\n    hn_ctxt R\\<sigma> \\<sigma>' \\<sigma>", "applyS (tactic \\<open>Sepref_Frame.frame_tac (K (K no_tac)) @{context} 1\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y. R\\<sigma> x y \\<Longrightarrow>\\<^sub>t R\\<sigma> x y\n 2. \\<Gamma> * hn_ctxt (list_assn Rk) s' s *\n    hn_ctxt R\\<sigma> \\<sigma>' \\<sigma> \\<Longrightarrow>\\<^sub>t\n    \\<Gamma> * hn_ctxt (list_assn Rk) s' s *\n    hn_ctxt R\\<sigma> \\<sigma>' \\<sigma>", "applyS (tactic \\<open>Sepref_Frame.frame_tac (K (K no_tac)) @{context} 1\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> * hn_ctxt (list_assn Rk) s' s *\n    hn_ctxt R\\<sigma> \\<sigma>' \\<sigma> \\<Longrightarrow>\\<^sub>t\n    \\<Gamma> * hn_ctxt (list_assn Rk) s' s *\n    hn_ctxt R\\<sigma> \\<sigma>' \\<sigma>", "applyS (tactic \\<open>Sepref_Frame.frame_tac (K (K no_tac)) @{context} 1\\<close>)"], ["proof (prove)\ngoal:\nNo subgoals!", "solved"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nfoldli_assert:\n  assumes \"set l \\<subseteq> S\"\n  shows \"nfoldli l c (\\<lambda> x s. ASSERT (x \\<in> S) \\<then> f x s) s = nfoldli l c f s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli l c\n     (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f x s)) s =\n    nfoldli l c f s", "using assms"], ["proof (prove)\nusing this:\n  set l \\<subseteq> S\n\ngoal (1 subgoal):\n 1. nfoldli l c\n     (\\<lambda>x s. ASSERT (x \\<in> S) \\<bind> (\\<lambda>_. f x s)) s =\n    nfoldli l c f s", "by (induction l arbitrary: s) (auto simp: pw_eq_iff refine_pw_simps)"], ["", "lemmas nfoldli_assert' = nfoldli_assert[OF order.refl]"], ["", "lemma fold_eq_nfoldli:\n  \"RETURN (fold f l s) = nfoldli l (\\<lambda>_. True) (\\<lambda>x s. RETURN (f x s)) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN (fold f l s) =\n    nfoldli l (\\<lambda>_. True) (\\<lambda>x s. RETURN (f x s)) s", "apply (induction l arbitrary: s)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       RETURN (fold f [] s) =\n       nfoldli [] (\\<lambda>_. True) (\\<lambda>x s. RETURN (f x s)) s\n 2. \\<And>a l s.\n       (\\<And>s.\n           RETURN (fold f l s) =\n           nfoldli l (\\<lambda>_. True) (\\<lambda>x s. RETURN (f x s))\n            s) \\<Longrightarrow>\n       RETURN (fold f (a # l) s) =\n       nfoldli (a # l) (\\<lambda>_. True) (\\<lambda>x s. RETURN (f x s)) s", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fold_eq_nfoldli_assert:\n  \"RETURN (fold f l s) = nfoldli l (\\<lambda>_. True) (\\<lambda>x s. ASSERT (x\\<in>set l) \\<then> RETURN (f x s)) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN (fold f l s) =\n    nfoldli l (\\<lambda>_. True)\n     (\\<lambda>x s.\n         ASSERT (x \\<in> set l) \\<bind> (\\<lambda>_. RETURN (f x s)))\n     s", "by (simp add: nfoldli_assert' fold_eq_nfoldli)"], ["", "lemma fold_arity[sepref_monadify_arity]: \"fold \\<equiv> \\<lambda>\\<^sub>2f l s. SP fold$(\\<lambda>\\<^sub>2x s. f$x$s)$l$s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold \\<equiv>\n    \\<lambda>x.\n       (#\\<lambda>xa.\n            (#\\<lambda>xb.\n                 (#SP fold $\n                   (\\<lambda>xa. (#\\<lambda>xb. (#x $ xa $ xb#)#)) $\n                   xa $\n                   xb#)#)#)", "by auto"], ["", "lemma monadify_plain_fold[sepref_monadify_comb]: \n  \"EVAL$(fold$(\\<lambda>\\<^sub>2x s. f x s)$l$s) \\<equiv> (\\<bind>)$(EVAL$l)$(\\<lambda>\\<^sub>2l. (\\<bind>)$(EVAL$s)$(\\<lambda>\\<^sub>2s. nfoldli$l$(\\<lambda>\\<^sub>2_. True)$(\\<lambda>\\<^sub>2x s. EVAL$(f x s))$s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. EVAL $\n    (fold $ (\\<lambda>x. (#\\<lambda>xa. (#f x xa#)#)) $ l $ s) \\<equiv>\n    (\\<bind>) $ (EVAL $ l) $\n    (\\<lambda>x.\n        (#(\\<bind>) $ (EVAL $ s) $\n          (\\<lambda>xa.\n              (#nfoldli $ x $ (\\<lambda>x. (#True#)) $\n                (\\<lambda>x. (#\\<lambda>xa. (#EVAL $ f x xa#)#)) $\n                xa#))#))", "by (simp add: fold_eq_nfoldli)"], ["", "lemma monadify_plain_fold_old_rl: \n  \"EVAL$(fold$(\\<lambda>\\<^sub>2x s. f x s)$l$s) \\<equiv> (\\<bind>)$(EVAL$l)$(\\<lambda>\\<^sub>2l. (\\<bind>)$(EVAL$s)$(\\<lambda>\\<^sub>2s. nfoldli$l$(\\<lambda>\\<^sub>2_. True)$(\\<lambda>\\<^sub>2x s. PR_CONST (op_ASSERT_bind (x\\<in>set l))$(EVAL$(f x s)))$s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. EVAL $\n    (fold $ (\\<lambda>x. (#\\<lambda>xa. (#f x xa#)#)) $ l $ s) \\<equiv>\n    (\\<bind>) $ (EVAL $ l) $\n    (\\<lambda>x.\n        (#(\\<bind>) $ (EVAL $ s) $\n          (\\<lambda>xa.\n              (#nfoldli $ x $ (\\<lambda>x. (#True#)) $\n                (\\<lambda>xa.\n                    (#\\<lambda>xb.\n                         (#PR_CONST (op_ASSERT_bind (xa \\<in> set x)) $\n                           (EVAL $ f xa xb)#)#)) $\n                xa#))#))", "by (simp add: fold_eq_nfoldli_assert)"], ["", "text \\<open>foldli\\<close>"], ["", "lemma foldli_eq_nfoldli:\n  \"RETURN (foldli l c f s) = nfoldli l c (\\<lambda>x s. RETURN (f x s)) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN (foldli l c f s) = nfoldli l c (\\<lambda>x s. RETURN (f x s)) s", "by (induction l arbitrary: s) auto"], ["", "lemma foldli_arities[sepref_monadify_arity]:\n  \"foldli \\<equiv> \\<lambda>\\<^sub>2s c f \\<sigma>. SP (foldli)$s$(\\<lambda>\\<^sub>2x. c$x)$(\\<lambda>\\<^sub>2x \\<sigma>. f$x$\\<sigma>)$\\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli \\<equiv>\n    \\<lambda>x.\n       (#\\<lambda>xa.\n            (#\\<lambda>xb.\n                 (#\\<lambda>xc.\n                      (#SP foldli $ x $ (\\<lambda>x. (#xa $ x#)) $\n                        (\\<lambda>x. (#\\<lambda>xa. (#xb $ x $ xa#)#)) $\n                        xc#)#)#)#)", "by (simp_all)"], ["", "lemma monadify_plain_foldli[sepref_monadify_comb]: \n  \"EVAL$(foldli$l$c$(\\<lambda>\\<^sub>2x s. f x s)$s) \\<equiv>\n    (\\<bind>)$(EVAL$l)$\n     (\\<lambda>\\<^sub>2l. (\\<bind>)$(EVAL$s)$\n      (\\<lambda>\\<^sub>2s. nfoldli$l$c$(\\<lambda>\\<^sub>2x s. (EVAL$(f x s)))$s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. EVAL $\n    (foldli $ l $ c $ (\\<lambda>x. (#\\<lambda>xa. (#f x xa#)#)) $\n     s) \\<equiv>\n    (\\<bind>) $ (EVAL $ l) $\n    (\\<lambda>x.\n        (#(\\<bind>) $ (EVAL $ s) $\n          (\\<lambda>xa.\n              (#nfoldli $ x $ c $\n                (\\<lambda>x. (#\\<lambda>xa. (#EVAL $ f x xa#)#)) $\n                xa#))#))", "by (simp add: foldli_eq_nfoldli)"], ["", "subsubsection \\<open>Deforestation\\<close>"], ["", "lemma nfoldli_filter_deforestation: \n  \"nfoldli (filter P xs) c f s = nfoldli xs c (\\<lambda>x s. if P x then f x s else RETURN s) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli (filter P xs) c f s =\n    nfoldli xs c (\\<lambda>x s. if P x then f x s else RETURN s) s", "apply (induction xs arbitrary: s)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       nfoldli (filter P []) c f s =\n       nfoldli [] c (\\<lambda>x s. if P x then f x s else RETURN s) s\n 2. \\<And>a xs s.\n       (\\<And>s.\n           nfoldli (filter P xs) c f s =\n           nfoldli xs c (\\<lambda>x s. if P x then f x s else RETURN s)\n            s) \\<Longrightarrow>\n       nfoldli (filter P (a # xs)) c f s =\n       nfoldli (a # xs) c (\\<lambda>x s. if P x then f x s else RETURN s) s", "by (auto simp: pw_eq_iff refine_pw_simps)"], ["", "lemma extend_list_of_filtered_set:\n  assumes [simp, intro!]: \"finite S\" \n    and A: \"distinct xs'\" \"set xs' = {x \\<in> S. P x}\"\n  obtains xs where \"xs' = filter P xs\" \"distinct xs\" \"set xs = S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>xs' = filter P xs; distinct xs; set xs = S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>xs' = filter P xs; distinct xs; set xs = S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain xs2 where \"{x\\<in>S. \\<not>P x} = set xs2\" \"distinct xs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs2.\n        \\<lbrakk>{x \\<in> S. \\<not> P x} = set xs2; distinct xs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using finite_distinct_list[where A=\"{x\\<in>S. \\<not>P x}\"]"], ["proof (prove)\nusing this:\n  finite {x \\<in> S. \\<not> P x} \\<Longrightarrow>\n  \\<exists>xs. set xs = {x \\<in> S. \\<not> P x} \\<and> distinct xs\n\ngoal (1 subgoal):\n 1. (\\<And>xs2.\n        \\<lbrakk>{x \\<in> S. \\<not> P x} = set xs2; distinct xs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  {x \\<in> S. \\<not> P x} = set xs2\n  distinct xs2\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>xs' = filter P xs; distinct xs; set xs = S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with A"], ["proof (chain)\npicking this:\n  distinct xs'\n  set xs' = {x \\<in> S. P x}\n  {x \\<in> S. \\<not> P x} = set xs2\n  distinct xs2", "have \"xs' = filter P (xs'@xs2)\" \"distinct (xs'@xs2)\" \"set (xs'@xs2) = S\""], ["proof (prove)\nusing this:\n  distinct xs'\n  set xs' = {x \\<in> S. P x}\n  {x \\<in> S. \\<not> P x} = set xs2\n  distinct xs2\n\ngoal (1 subgoal):\n 1. xs' = filter P (xs' @ xs2) &&&\n    distinct (xs' @ xs2) &&& set (xs' @ xs2) = S", "by (auto simp: filter_empty_conv)"], ["proof (state)\nthis:\n  xs' = filter P (xs' @ xs2)\n  distinct (xs' @ xs2)\n  set (xs' @ xs2) = S\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>xs' = filter P xs; distinct xs; set xs = S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from that[OF this]"], ["proof (chain)\npicking this:\n  thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  thesis\n\ngoal (1 subgoal):\n 1. thesis", "."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma FOREACHc_filter_deforestation:\n  assumes FIN[simp, intro!]: \"finite S\"\n  shows \"(FOREACHc {x\\<in>S. P x} c f s) \n    = FOREACHc S c (\\<lambda>x s. if P x then f x s else RETURN s) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>C {x \\<in> S. P x} c f s =\n    FOREACH\\<^sub>C S c (\\<lambda>x s. if P x then f x s else RETURN s) s", "unfolding FOREACHc_def FOREACHci_def FOREACHoci_by_LIST_FOREACH LIST_FOREACH'_eq\n      LIST_FOREACH'_def it_to_sorted_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (finite {x \\<in> S. P x}) \\<bind>\n    (\\<lambda>_.\n        SPEC\n         (\\<lambda>l.\n             distinct l \\<and>\n             {x \\<in> S. P x} = set l \\<and>\n             sorted_wrt (\\<lambda>_ _. True) l) \\<bind>\n        (\\<lambda>xs. nfoldli xs c f s)) =\n    ASSERT (finite S) \\<bind>\n    (\\<lambda>_.\n        SPEC\n         (\\<lambda>l.\n             distinct l \\<and>\n             S = set l \\<and> sorted_wrt (\\<lambda>_ _. True) l) \\<bind>\n        (\\<lambda>xs.\n            nfoldli xs c (\\<lambda>x s. if P x then f x s else RETURN s) s))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (finite {x \\<in> S. P x}) \\<bind>\n    (\\<lambda>_.\n        SPEC\n         (\\<lambda>l.\n             distinct l \\<and>\n             {x \\<in> S. P x} = set l \\<and>\n             sorted_wrt (\\<lambda>_ _. True) l) \\<bind>\n        (\\<lambda>xs. nfoldli xs c f s)) =\n    ASSERT (finite S) \\<bind>\n    (\\<lambda>_.\n        SPEC\n         (\\<lambda>l.\n             distinct l \\<and>\n             S = set l \\<and> sorted_wrt (\\<lambda>_ _. True) l) \\<bind>\n        (\\<lambda>xs.\n            nfoldli xs c (\\<lambda>x s. if P x then f x s else RETURN s) s))", "proof (induction rule: antisym[consumes 0, case_names 1 2])"], ["proof (state)\ngoal (2 subgoals):\n 1. ASSERT (finite {x \\<in> S. P x}) \\<bind>\n    (\\<lambda>_.\n        SPEC\n         (\\<lambda>l.\n             distinct l \\<and>\n             {x \\<in> S. P x} = set l \\<and>\n             sorted_wrt (\\<lambda>_ _. True) l) \\<bind>\n        (\\<lambda>xs. nfoldli xs c f s))\n    \\<le> ASSERT (finite S) \\<bind>\n          (\\<lambda>_.\n              SPEC\n               (\\<lambda>l.\n                   distinct l \\<and>\n                   S = set l \\<and>\n                   sorted_wrt (\\<lambda>_ _. True) l) \\<bind>\n              (\\<lambda>xs.\n                  nfoldli xs c\n                   (\\<lambda>x s. if P x then f x s else RETURN s) s))\n 2. ASSERT (finite S) \\<bind>\n    (\\<lambda>_.\n        SPEC\n         (\\<lambda>l.\n             distinct l \\<and>\n             S = set l \\<and> sorted_wrt (\\<lambda>_ _. True) l) \\<bind>\n        (\\<lambda>xs.\n            nfoldli xs c (\\<lambda>x s. if P x then f x s else RETURN s) s))\n    \\<le> ASSERT (finite {x \\<in> S. P x}) \\<bind>\n          (\\<lambda>_.\n              SPEC\n               (\\<lambda>l.\n                   distinct l \\<and>\n                   {x \\<in> S. P x} = set l \\<and>\n                   sorted_wrt (\\<lambda>_ _. True) l) \\<bind>\n              (\\<lambda>xs. nfoldli xs c f s))", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. ASSERT (finite {x \\<in> S. P x}) \\<bind>\n    (\\<lambda>_.\n        SPEC\n         (\\<lambda>l.\n             distinct l \\<and>\n             {x \\<in> S. P x} = set l \\<and>\n             sorted_wrt (\\<lambda>_ _. True) l) \\<bind>\n        (\\<lambda>xs. nfoldli xs c f s))\n    \\<le> ASSERT (finite S) \\<bind>\n          (\\<lambda>_.\n              SPEC\n               (\\<lambda>l.\n                   distinct l \\<and>\n                   S = set l \\<and>\n                   sorted_wrt (\\<lambda>_ _. True) l) \\<bind>\n              (\\<lambda>xs.\n                  nfoldli xs c\n                   (\\<lambda>x s. if P x then f x s else RETURN s) s))\n 2. ASSERT (finite S) \\<bind>\n    (\\<lambda>_.\n        SPEC\n         (\\<lambda>l.\n             distinct l \\<and>\n             S = set l \\<and> sorted_wrt (\\<lambda>_ _. True) l) \\<bind>\n        (\\<lambda>xs.\n            nfoldli xs c (\\<lambda>x s. if P x then f x s else RETURN s) s))\n    \\<le> ASSERT (finite {x \\<in> S. P x}) \\<bind>\n          (\\<lambda>_.\n              SPEC\n               (\\<lambda>l.\n                   distinct l \\<and>\n                   {x \\<in> S. P x} = set l \\<and>\n                   sorted_wrt (\\<lambda>_ _. True) l) \\<bind>\n              (\\<lambda>xs. nfoldli xs c f s))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (finite {x \\<in> S. P x}) \\<bind>\n    (\\<lambda>_.\n        SPEC\n         (\\<lambda>l.\n             distinct l \\<and>\n             {x \\<in> S. P x} = set l \\<and>\n             sorted_wrt (\\<lambda>_ _. True) l) \\<bind>\n        (\\<lambda>xs. nfoldli xs c f s))\n    \\<le> ASSERT (finite S) \\<bind>\n          (\\<lambda>_.\n              SPEC\n               (\\<lambda>l.\n                   distinct l \\<and>\n                   S = set l \\<and>\n                   sorted_wrt (\\<lambda>_ _. True) l) \\<bind>\n              (\\<lambda>xs.\n                  nfoldli xs c\n                   (\\<lambda>x s. if P x then f x s else RETURN s) s))", "apply (rule le_ASSERTI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite S \\<Longrightarrow>\n    ASSERT (finite {x \\<in> S. P x}) \\<bind>\n    (\\<lambda>_.\n        SPEC\n         (\\<lambda>l.\n             distinct l \\<and>\n             {x \\<in> S. P x} = set l \\<and>\n             sorted_wrt (\\<lambda>_ _. True) l) \\<bind>\n        (\\<lambda>xs. nfoldli xs c f s))\n    \\<le> SPEC\n           (\\<lambda>l.\n               distinct l \\<and>\n               S = set l \\<and> sorted_wrt (\\<lambda>_ _. True) l) \\<bind>\n          (\\<lambda>xs.\n              nfoldli xs c (\\<lambda>x s. if P x then f x s else RETURN s)\n               s)", "apply (rule ASSERT_leI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite S; finite {x \\<in> S. P x}\\<rbrakk>\n    \\<Longrightarrow> SPEC\n                       (\\<lambda>l.\n                           distinct l \\<and>\n                           {x \\<in> S. P x} = set l \\<and>\n                           sorted_wrt (\\<lambda>_ _. True) l) \\<bind>\n                      (\\<lambda>xs. nfoldli xs c f s)\n                      \\<le> SPEC\n                             (\\<lambda>l.\n                                 distinct l \\<and>\n                                 S = set l \\<and>\n                                 sorted_wrt (\\<lambda>_ _. True) l) \\<bind>\n                            (\\<lambda>xs.\n                                nfoldli xs c\n                                 (\\<lambda>x s.\n                                     if P x then f x s else RETURN s)\n                                 s)", "apply (rule intro_spec_refine[where R=Id, simplified]; clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>distinct xs; {x \\<in> S. P x} = set xs\\<rbrakk>\n       \\<Longrightarrow> nfoldli xs c f s\n                         \\<le> SPEC\n                                (\\<lambda>l.\n                                    distinct l \\<and> S = set l) \\<bind>\n                               (\\<lambda>xs.\n                                   nfoldli xs c\n                                    (\\<lambda>x s.\n  if P x then f x s else RETURN s)\n                                    s)", "apply (rule extend_list_of_filtered_set[OF FIN _ sym], assumption, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs xsa.\n       \\<lbrakk>distinct xs; {x \\<in> S. P x} = set xs; xs = filter P xsa;\n        distinct xsa; set xsa = S\\<rbrakk>\n       \\<Longrightarrow> nfoldli xs c f s\n                         \\<le> SPEC\n                                (\\<lambda>l.\n                                    distinct l \\<and> S = set l) \\<bind>\n                               (\\<lambda>xs.\n                                   nfoldli xs c\n                                    (\\<lambda>x s.\n  if P x then f x s else RETURN s)\n                                    s)", "subgoal for xs' xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs'; {x \\<in> S. P x} = set xs'; xs' = filter P xs;\n     distinct xs; set xs = S\\<rbrakk>\n    \\<Longrightarrow> nfoldli xs' c f s\n                      \\<le> SPEC\n                             (\\<lambda>l.\n                                 distinct l \\<and> S = set l) \\<bind>\n                            (\\<lambda>xs.\n                                nfoldli xs c\n                                 (\\<lambda>x s.\n                                     if P x then f x s else RETURN s)\n                                 s)", "apply (rule rhs_step_bind_SPEC[where R=Id and x'=\"xs\", simplified])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct xs'; {x \\<in> S. P x} = set xs'; xs' = filter P xs;\n     distinct xs; set xs = S\\<rbrakk>\n    \\<Longrightarrow> distinct xs \\<and> S = set xs\n 2. \\<lbrakk>distinct xs'; {x \\<in> S. P x} = set xs'; xs' = filter P xs;\n     distinct xs; set xs = S\\<rbrakk>\n    \\<Longrightarrow> nfoldli xs' c f s\n                      \\<le> nfoldli xs c\n                             (\\<lambda>x s. if P x then f x s else RETURN s)\n                             s", "applyS simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs'; {x \\<in> S. P x} = set xs'; xs' = filter P xs;\n     distinct xs; set xs = S\\<rbrakk>\n    \\<Longrightarrow> nfoldli xs' c f s\n                      \\<le> nfoldli xs c\n                             (\\<lambda>x s. if P x then f x s else RETURN s)\n                             s", "applyS (simp add: nfoldli_filter_deforestation)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ASSERT (finite {x \\<in> S. P x}) \\<bind>\n  (\\<lambda>_.\n      SPEC\n       (\\<lambda>l.\n           distinct l \\<and>\n           {x \\<in> S. P x} = set l \\<and>\n           sorted_wrt (\\<lambda>_ _. True) l) \\<bind>\n      (\\<lambda>xs. nfoldli xs c f s))\n  \\<le> ASSERT (finite S) \\<bind>\n        (\\<lambda>_.\n            SPEC\n             (\\<lambda>l.\n                 distinct l \\<and>\n                 S = set l \\<and> sorted_wrt (\\<lambda>_ _. True) l) \\<bind>\n            (\\<lambda>xs.\n                nfoldli xs c (\\<lambda>x s. if P x then f x s else RETURN s)\n                 s))\n\ngoal (1 subgoal):\n 1. ASSERT (finite S) \\<bind>\n    (\\<lambda>_.\n        SPEC\n         (\\<lambda>l.\n             distinct l \\<and>\n             S = set l \\<and> sorted_wrt (\\<lambda>_ _. True) l) \\<bind>\n        (\\<lambda>xs.\n            nfoldli xs c (\\<lambda>x s. if P x then f x s else RETURN s) s))\n    \\<le> ASSERT (finite {x \\<in> S. P x}) \\<bind>\n          (\\<lambda>_.\n              SPEC\n               (\\<lambda>l.\n                   distinct l \\<and>\n                   {x \\<in> S. P x} = set l \\<and>\n                   sorted_wrt (\\<lambda>_ _. True) l) \\<bind>\n              (\\<lambda>xs. nfoldli xs c f s))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ASSERT (finite S) \\<bind>\n    (\\<lambda>_.\n        SPEC\n         (\\<lambda>l.\n             distinct l \\<and>\n             S = set l \\<and> sorted_wrt (\\<lambda>_ _. True) l) \\<bind>\n        (\\<lambda>xs.\n            nfoldli xs c (\\<lambda>x s. if P x then f x s else RETURN s) s))\n    \\<le> ASSERT (finite {x \\<in> S. P x}) \\<bind>\n          (\\<lambda>_.\n              SPEC\n               (\\<lambda>l.\n                   distinct l \\<and>\n                   {x \\<in> S. P x} = set l \\<and>\n                   sorted_wrt (\\<lambda>_ _. True) l) \\<bind>\n              (\\<lambda>xs. nfoldli xs c f s))", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. ASSERT (finite S) \\<bind>\n    (\\<lambda>_.\n        SPEC\n         (\\<lambda>l.\n             distinct l \\<and>\n             S = set l \\<and> sorted_wrt (\\<lambda>_ _. True) l) \\<bind>\n        (\\<lambda>xs.\n            nfoldli xs c (\\<lambda>x s. if P x then f x s else RETURN s) s))\n    \\<le> ASSERT (finite {x \\<in> S. P x}) \\<bind>\n          (\\<lambda>_.\n              SPEC\n               (\\<lambda>l.\n                   distinct l \\<and>\n                   {x \\<in> S. P x} = set l \\<and>\n                   sorted_wrt (\\<lambda>_ _. True) l) \\<bind>\n              (\\<lambda>xs. nfoldli xs c f s))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (finite S) \\<bind>\n    (\\<lambda>_.\n        SPEC\n         (\\<lambda>l.\n             distinct l \\<and>\n             S = set l \\<and> sorted_wrt (\\<lambda>_ _. True) l) \\<bind>\n        (\\<lambda>xs.\n            nfoldli xs c (\\<lambda>x s. if P x then f x s else RETURN s) s))\n    \\<le> ASSERT (finite {x \\<in> S. P x}) \\<bind>\n          (\\<lambda>_.\n              SPEC\n               (\\<lambda>l.\n                   distinct l \\<and>\n                   {x \\<in> S. P x} = set l \\<and>\n                   sorted_wrt (\\<lambda>_ _. True) l) \\<bind>\n              (\\<lambda>xs. nfoldli xs c f s))", "apply (rule le_ASSERTI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x \\<in> S. P x} \\<Longrightarrow>\n    ASSERT (finite S) \\<bind>\n    (\\<lambda>_.\n        SPEC\n         (\\<lambda>l.\n             distinct l \\<and>\n             S = set l \\<and> sorted_wrt (\\<lambda>_ _. True) l) \\<bind>\n        (\\<lambda>xs.\n            nfoldli xs c (\\<lambda>x s. if P x then f x s else RETURN s) s))\n    \\<le> SPEC\n           (\\<lambda>l.\n               distinct l \\<and>\n               {x \\<in> S. P x} = set l \\<and>\n               sorted_wrt (\\<lambda>_ _. True) l) \\<bind>\n          (\\<lambda>xs. nfoldli xs c f s)", "apply (rule ASSERT_leI, (simp; fail))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite {x \\<in> S. P x}; finite S\\<rbrakk>\n    \\<Longrightarrow> SPEC\n                       (\\<lambda>l.\n                           distinct l \\<and>\n                           S = set l \\<and>\n                           sorted_wrt (\\<lambda>_ _. True) l) \\<bind>\n                      (\\<lambda>xs.\n                          nfoldli xs c\n                           (\\<lambda>x s. if P x then f x s else RETURN s)\n                           s)\n                      \\<le> SPEC\n                             (\\<lambda>l.\n                                 distinct l \\<and>\n                                 {x \\<in> S. P x} = set l \\<and>\n                                 sorted_wrt (\\<lambda>_ _. True) l) \\<bind>\n                            (\\<lambda>xs. nfoldli xs c f s)", "apply (rule intro_spec_refine[where R=Id, simplified]; clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>distinct xs; S = set xs\\<rbrakk>\n       \\<Longrightarrow> nfoldli xs c\n                          (\\<lambda>x s. if P x then f x s else RETURN s) s\n                         \\<le> SPEC\n                                (\\<lambda>l.\n                                    distinct l \\<and>\n                                    {x \\<in> set xs. P x} = set l) \\<bind>\n                               (\\<lambda>xs. nfoldli xs c f s)", "subgoal for xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; S = set xs\\<rbrakk>\n    \\<Longrightarrow> nfoldli xs c\n                       (\\<lambda>x s. if P x then f x s else RETURN s) s\n                      \\<le> SPEC\n                             (\\<lambda>l.\n                                 distinct l \\<and>\n                                 {x \\<in> set xs. P x} = set l) \\<bind>\n                            (\\<lambda>xs. nfoldli xs c f s)", "apply (rule rhs_step_bind_SPEC[where R=Id and x'=\"filter P xs\", simplified])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct xs; S = set xs\\<rbrakk>\n    \\<Longrightarrow> distinct (filter P xs) \\<and>\n                      {x \\<in> set xs. P x} = set (filter P xs)\n 2. \\<lbrakk>distinct xs; S = set xs\\<rbrakk>\n    \\<Longrightarrow> nfoldli xs c\n                       (\\<lambda>x s. if P x then f x s else RETURN s) s\n                      \\<le> nfoldli (filter P xs) c f s", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; S = set xs\\<rbrakk>\n    \\<Longrightarrow> nfoldli xs c\n                       (\\<lambda>x s. if P x then f x s else RETURN s) s\n                      \\<le> nfoldli (filter P xs) c f s", "apply (simp add: nfoldli_filter_deforestation)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ASSERT (finite S) \\<bind>\n  (\\<lambda>_.\n      SPEC\n       (\\<lambda>l.\n           distinct l \\<and>\n           S = set l \\<and> sorted_wrt (\\<lambda>_ _. True) l) \\<bind>\n      (\\<lambda>xs.\n          nfoldli xs c (\\<lambda>x s. if P x then f x s else RETURN s) s))\n  \\<le> ASSERT (finite {x \\<in> S. P x}) \\<bind>\n        (\\<lambda>_.\n            SPEC\n             (\\<lambda>l.\n                 distinct l \\<and>\n                 {x \\<in> S. P x} = set l \\<and>\n                 sorted_wrt (\\<lambda>_ _. True) l) \\<bind>\n            (\\<lambda>xs. nfoldli xs c f s))\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma FOREACHc_filter_deforestation2:\n  assumes [simp]: \"distinct xs\"\n  shows \"(FOREACHc (set (filter P xs)) c f s) \n    = FOREACHc (set xs) c (\\<lambda>x s. if P x then f x s else RETURN s) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>C (set (filter P xs)) c f s =\n    FOREACH\\<^sub>C (set xs) c\n     (\\<lambda>x s. if P x then f x s else RETURN s) s", "using FOREACHc_filter_deforestation[of \"set xs\", simplified, folded set_filter]"], ["proof (prove)\nusing this:\n  FOREACH\\<^sub>C (set (filter ?P xs)) ?c ?f ?s =\n  FOREACH\\<^sub>C (set xs) ?c\n   (\\<lambda>x s. if ?P x then ?f x s else RETURN s) ?s\n\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>C (set (filter P xs)) c f s =\n    FOREACH\\<^sub>C (set xs) c\n     (\\<lambda>x s. if P x then f x s else RETURN s) s", "."], ["", "subsection \\<open>For Loops\\<close>"], ["", "partial_function (heap) imp_for :: \"nat \\<Rightarrow> nat \\<Rightarrow> ('a \\<Rightarrow> bool Heap) \\<Rightarrow> (nat \\<Rightarrow> 'a \\<Rightarrow> 'a Heap) \\<Rightarrow> 'a \\<Rightarrow> 'a Heap\" where\n  \"imp_for i u c f s = (if i \\<ge> u then return s else do {ctn <- c s; if ctn then f i s \\<bind> imp_for (i + 1) u c f else return s})\""], ["", "declare imp_for.simps[code]"], ["", "lemma [simp]:\n  \"i \\<ge> u \\<Longrightarrow> imp_for i u c f s = return s\"\n  \"i < u \\<Longrightarrow> imp_for i u c f s = do {ctn <- c s; if ctn then f i s \\<bind> imp_for (i + 1) u c f else return s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u \\<le> i \\<Longrightarrow> imp_for i u c f s = return s) &&&\n    (i < u \\<Longrightarrow>\n     imp_for i u c f s =\n     c s \\<bind>\n     (\\<lambda>ctn.\n         if ctn then f i s \\<bind> imp_for (i + 1) u c f else return s))", "by (auto simp: imp_for.simps)"], ["", "lemma imp_nfoldli_deforest[sepref_opt_simps]:\n  \"imp_nfoldli [l..<u] c = imp_for l u c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_nfoldli [l..<u] c = imp_for l u c", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa. imp_nfoldli [l..<u] c x xa = imp_for l u c x xa", "subgoal for f s"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_nfoldli [l..<u] c f s = imp_for l u c f s", "apply (induction \"u - l\" arbitrary: l u s)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l u s.\n       0 = u - l \\<Longrightarrow>\n       imp_nfoldli [l..<u] c f s = imp_for l u c f s\n 2. \\<And>x l u s.\n       \\<lbrakk>\\<And>l u s.\n                   x = u - l \\<Longrightarrow>\n                   imp_nfoldli [l..<u] c f s = imp_for l u c f s;\n        Suc x = u - l\\<rbrakk>\n       \\<Longrightarrow> imp_nfoldli [l..<u] c f s = imp_for l u c f s", "apply (simp add: upt_conv_Cons; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x l u s.\n       \\<lbrakk>\\<And>l u s.\n                   x = u - l \\<Longrightarrow>\n                   imp_nfoldli [l..<u] c f s = imp_for l u c f s;\n        Suc x = u - l\\<rbrakk>\n       \\<Longrightarrow> imp_nfoldli [l..<u] c f s = imp_for l u c f s", "apply (simp add: upt_conv_Cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x l u s.\n       \\<lbrakk>\\<And>l u s.\n                   x = u - l \\<Longrightarrow>\n                   imp_nfoldli [l..<u] c f s = imp_for l u c f s;\n        Suc x = u - l\\<rbrakk>\n       \\<Longrightarrow> c s \\<bind>\n                         (\\<lambda>b.\n                             if b\n                             then f l s \\<bind> imp_nfoldli [Suc l..<u] c f\n                             else return s) =\n                         c s \\<bind>\n                         (\\<lambda>ctn.\n                             if ctn then f l s \\<bind> imp_for (l + 1) u c f\n                             else return s)", "apply (fo_rule arg_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x l u s.\n       \\<lbrakk>\\<And>l u s.\n                   x = u - l \\<Longrightarrow>\n                   imp_nfoldli [l..<u] c f s = imp_for l u c f s;\n        Suc x = u - l\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>b.\n                             if b\n                             then f l s \\<bind> imp_nfoldli [Suc l..<u] c f\n                             else return s) =\n                         (\\<lambda>ctn.\n                             if ctn then f l s \\<bind> imp_for (l + 1) u c f\n                             else return s)", "by (auto cong: if_cong)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "partial_function (heap) imp_for' :: \"nat \\<Rightarrow> nat \\<Rightarrow> (nat \\<Rightarrow> 'a \\<Rightarrow> 'a Heap) \\<Rightarrow> 'a \\<Rightarrow> 'a Heap\" where\n  \"imp_for' i u f s = (if i \\<ge> u then return s else f i s \\<bind> imp_for' (i + 1) u f)\""], ["", "declare imp_for'.simps[code]"], ["", "lemma [simp]:\n  \"i \\<ge> u \\<Longrightarrow> imp_for' i u f s = return s\"\n  \"i < u \\<Longrightarrow> imp_for' i u f s = f i s \\<bind> imp_for' (i + 1) u f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u \\<le> i \\<Longrightarrow> imp_for' i u f s = return s) &&&\n    (i < u \\<Longrightarrow>\n     imp_for' i u f s = f i s \\<bind> imp_for' (i + 1) u f)", "by (auto simp: imp_for'.simps)"], ["", "lemma imp_for_imp_for'[sepref_opt_simps]:\n  \"imp_for i u (\\<lambda> _. return True) = imp_for' i u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_for i u (\\<lambda>_. return True) = imp_for' i u", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       imp_for i u (\\<lambda>_. return True) x xa = imp_for' i u x xa", "subgoal for f s"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_for i u (\\<lambda>_. return True) f s = imp_for' i u f s", "apply (induction \"u - i\" arbitrary: i u s)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i u s.\n       0 = u - i \\<Longrightarrow>\n       imp_for i u (\\<lambda>_. return True) f s = imp_for' i u f s\n 2. \\<And>x i u s.\n       \\<lbrakk>\\<And>i u s.\n                   x = u - i \\<Longrightarrow>\n                   imp_for i u (\\<lambda>_. return True) f s =\n                   imp_for' i u f s;\n        Suc x = u - i\\<rbrakk>\n       \\<Longrightarrow> imp_for i u (\\<lambda>_. return True) f s =\n                         imp_for' i u f s", "apply (simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x i u s.\n       \\<lbrakk>\\<And>i u s.\n                   x = u - i \\<Longrightarrow>\n                   imp_for i u (\\<lambda>_. return True) f s =\n                   imp_for' i u f s;\n        Suc x = u - i\\<rbrakk>\n       \\<Longrightarrow> imp_for i u (\\<lambda>_. return True) f s =\n                         imp_for' i u f s", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x i u s.\n       \\<lbrakk>\\<And>i u s.\n                   x = u - i \\<Longrightarrow>\n                   imp_for i u (\\<lambda>_. return True) f s =\n                   imp_for' i u f s;\n        Suc x = u - i\\<rbrakk>\n       \\<Longrightarrow> f i s \\<bind>\n                         imp_for (Suc i) u (\\<lambda>_. return True) f =\n                         f i s \\<bind> imp_for' (Suc i) u f", "apply (fo_rule arg_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x i u s.\n       \\<lbrakk>\\<And>i u s.\n                   x = u - i \\<Longrightarrow>\n                   imp_for i u (\\<lambda>_. return True) f s =\n                   imp_for' i u f s;\n        Suc x = u - i\\<rbrakk>\n       \\<Longrightarrow> imp_for (Suc i) u (\\<lambda>_. return True) f =\n                         imp_for' (Suc i) u f", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "partial_function (heap) imp_for_down :: \"nat \\<Rightarrow> nat \\<Rightarrow> ('a \\<Rightarrow> bool Heap) \\<Rightarrow> (nat \\<Rightarrow> 'a \\<Rightarrow> 'a Heap) \\<Rightarrow> 'a \\<Rightarrow> 'a Heap\" where\n  \"imp_for_down l i c f s = do {\n    let i = i - 1;\n    ctn \\<leftarrow> c s;\n    if ctn then do {\n      s \\<leftarrow> f i s;\n      if i>l then imp_for_down l i c f s else return s\n    } else return s\n  }\""], ["", "declare imp_for_down.simps[code]"], ["", "lemma imp_nfoldli_deforest_down[sepref_opt_simps]:\n  \"imp_nfoldli (rev [l..<u]) c = \n    (\\<lambda>f s. if u\\<le>l then return s else imp_for_down l u c f s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_nfoldli (rev [l..<u]) c =\n    (\\<lambda>f s. if u \\<le> l then return s else imp_for_down l u c f s)", "proof (intro ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f s.\n       imp_nfoldli (rev [l..<u]) c f s =\n       (if u \\<le> l then return s else imp_for_down l u c f s)", "fix f s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f s.\n       imp_nfoldli (rev [l..<u]) c f s =\n       (if u \\<le> l then return s else imp_for_down l u c f s)", "show \"imp_nfoldli (rev [l..<u]) c f s =\n          (if l \\<ge> u then return s else imp_for_down l u c f s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_nfoldli (rev [l..<u]) c f s =\n    (if u \\<le> l then return s else imp_for_down l u c f s)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    imp_nfoldli (rev [l..<u]) c f s =\n    (if u \\<le> l then return s else imp_for_down l u c f s)\n 2. \\<not> ?P \\<Longrightarrow>\n    imp_nfoldli (rev [l..<u]) c f s =\n    (if u \\<le> l then return s else imp_for_down l u c f s)", "assume \"l\\<ge>u\""], ["proof (state)\nthis:\n  u \\<le> l\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    imp_nfoldli (rev [l..<u]) c f s =\n    (if u \\<le> l then return s else imp_for_down l u c f s)\n 2. \\<not> ?P \\<Longrightarrow>\n    imp_nfoldli (rev [l..<u]) c f s =\n    (if u \\<le> l then return s else imp_for_down l u c f s)", "thus ?thesis"], ["proof (prove)\nusing this:\n  u \\<le> l\n\ngoal (1 subgoal):\n 1. imp_nfoldli (rev [l..<u]) c f s =\n    (if u \\<le> l then return s else imp_for_down l u c f s)", "by auto"], ["proof (state)\nthis:\n  imp_nfoldli (rev [l..<u]) c f s =\n  (if u \\<le> l then return s else imp_for_down l u c f s)\n\ngoal (1 subgoal):\n 1. \\<not> u \\<le> l \\<Longrightarrow>\n    imp_nfoldli (rev [l..<u]) c f s =\n    (if u \\<le> l then return s else imp_for_down l u c f s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> u \\<le> l \\<Longrightarrow>\n    imp_nfoldli (rev [l..<u]) c f s =\n    (if u \\<le> l then return s else imp_for_down l u c f s)", "assume \"\\<not>(l\\<ge>u)\""], ["proof (state)\nthis:\n  \\<not> u \\<le> l\n\ngoal (1 subgoal):\n 1. \\<not> u \\<le> l \\<Longrightarrow>\n    imp_nfoldli (rev [l..<u]) c f s =\n    (if u \\<le> l then return s else imp_for_down l u c f s)", "hence \"l<u\""], ["proof (prove)\nusing this:\n  \\<not> u \\<le> l\n\ngoal (1 subgoal):\n 1. l < u", "by auto"], ["proof (state)\nthis:\n  l < u\n\ngoal (1 subgoal):\n 1. \\<not> u \\<le> l \\<Longrightarrow>\n    imp_nfoldli (rev [l..<u]) c f s =\n    (if u \\<le> l then return s else imp_for_down l u c f s)", "thus ?thesis"], ["proof (prove)\nusing this:\n  l < u\n\ngoal (1 subgoal):\n 1. imp_nfoldli (rev [l..<u]) c f s =\n    (if u \\<le> l then return s else imp_for_down l u c f s)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. l < u \\<Longrightarrow>\n    imp_nfoldli (rev [l..<u]) c f s = imp_for_down l u c f s", "proof (induction \"u - l\" arbitrary: u s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u s.\n       \\<lbrakk>0 = u - l; l < u\\<rbrakk>\n       \\<Longrightarrow> imp_nfoldli (rev [l..<u]) c f s =\n                         imp_for_down l u c f s\n 2. \\<And>x u s.\n       \\<lbrakk>\\<And>u s.\n                   \\<lbrakk>x = u - l; l < u\\<rbrakk>\n                   \\<Longrightarrow> imp_nfoldli (rev [l..<u]) c f s =\n                                     imp_for_down l u c f s;\n        Suc x = u - l; l < u\\<rbrakk>\n       \\<Longrightarrow> imp_nfoldli (rev [l..<u]) c f s =\n                         imp_for_down l u c f s", "case 0"], ["proof (state)\nthis:\n  0 = u - l\n  l < u\n\ngoal (2 subgoals):\n 1. \\<And>u s.\n       \\<lbrakk>0 = u - l; l < u\\<rbrakk>\n       \\<Longrightarrow> imp_nfoldli (rev [l..<u]) c f s =\n                         imp_for_down l u c f s\n 2. \\<And>x u s.\n       \\<lbrakk>\\<And>u s.\n                   \\<lbrakk>x = u - l; l < u\\<rbrakk>\n                   \\<Longrightarrow> imp_nfoldli (rev [l..<u]) c f s =\n                                     imp_for_down l u c f s;\n        Suc x = u - l; l < u\\<rbrakk>\n       \\<Longrightarrow> imp_nfoldli (rev [l..<u]) c f s =\n                         imp_for_down l u c f s", "thus ?case"], ["proof (prove)\nusing this:\n  0 = u - l\n  l < u\n\ngoal (1 subgoal):\n 1. imp_nfoldli (rev [l..<u]) c f s = imp_for_down l u c f s", "by auto"], ["proof (state)\nthis:\n  imp_nfoldli (rev [l..<u]) c f s = imp_for_down l u c f s\n\ngoal (1 subgoal):\n 1. \\<And>x u s.\n       \\<lbrakk>\\<And>u s.\n                   \\<lbrakk>x = u - l; l < u\\<rbrakk>\n                   \\<Longrightarrow> imp_nfoldli (rev [l..<u]) c f s =\n                                     imp_for_down l u c f s;\n        Suc x = u - l; l < u\\<rbrakk>\n       \\<Longrightarrow> imp_nfoldli (rev [l..<u]) c f s =\n                         imp_for_down l u c f s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x u s.\n       \\<lbrakk>\\<And>u s.\n                   \\<lbrakk>x = u - l; l < u\\<rbrakk>\n                   \\<Longrightarrow> imp_nfoldli (rev [l..<u]) c f s =\n                                     imp_for_down l u c f s;\n        Suc x = u - l; l < u\\<rbrakk>\n       \\<Longrightarrow> imp_nfoldli (rev [l..<u]) c f s =\n                         imp_for_down l u c f s", "case (Suc u')"], ["proof (state)\nthis:\n  \\<lbrakk>u' = ?u - l; l < ?u\\<rbrakk>\n  \\<Longrightarrow> imp_nfoldli (rev [l..<?u]) c f ?s =\n                    imp_for_down l ?u c f ?s\n  Suc u' = u - l\n  l < u\n\ngoal (1 subgoal):\n 1. \\<And>x u s.\n       \\<lbrakk>\\<And>u s.\n                   \\<lbrakk>x = u - l; l < u\\<rbrakk>\n                   \\<Longrightarrow> imp_nfoldli (rev [l..<u]) c f s =\n                                     imp_for_down l u c f s;\n        Suc x = u - l; l < u\\<rbrakk>\n       \\<Longrightarrow> imp_nfoldli (rev [l..<u]) c f s =\n                         imp_for_down l u c f s", "from Suc.prems Suc.hyps(2)"], ["proof (chain)\npicking this:\n  l < u\n  Suc u' = u - l", "have [simp]: \"rev [l..<u] = (u-1)#rev [l..<u-1]\""], ["proof (prove)\nusing this:\n  l < u\n  Suc u' = u - l\n\ngoal (1 subgoal):\n 1. rev [l..<u] = (u - 1) # rev [l..<u - 1]", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l < u; Suc u' = u - l\\<rbrakk>\n    \\<Longrightarrow> [l..<u] = [l..<u - Suc 0] @ [u - Suc 0]", "apply (subst upt_Suc_append[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>l < u; Suc u' = u - l\\<rbrakk>\n    \\<Longrightarrow> l \\<le> u - Suc 0\n 2. \\<lbrakk>l < u; Suc u' = u - l\\<rbrakk>\n    \\<Longrightarrow> [l..<u] = [l..<Suc (u - Suc 0)]", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rev [l..<u] = (u - 1) # rev [l..<u - 1]\n\ngoal (1 subgoal):\n 1. \\<And>x u s.\n       \\<lbrakk>\\<And>u s.\n                   \\<lbrakk>x = u - l; l < u\\<rbrakk>\n                   \\<Longrightarrow> imp_nfoldli (rev [l..<u]) c f s =\n                                     imp_for_down l u c f s;\n        Suc x = u - l; l < u\\<rbrakk>\n       \\<Longrightarrow> imp_nfoldli (rev [l..<u]) c f s =\n                         imp_for_down l u c f s", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_nfoldli (rev [l..<u]) c f s = imp_for_down l u c f s", "using Suc.hyps(1)[of \"u-1\"] Suc.hyps(2) Suc.prems"], ["proof (prove)\nusing this:\n  \\<lbrakk>u' = u - 1 - l; l < u - 1\\<rbrakk>\n  \\<Longrightarrow> imp_nfoldli (rev [l..<u - 1]) c f ?s =\n                    imp_for_down l (u - 1) c f ?s\n  Suc u' = u - l\n  l < u\n\ngoal (1 subgoal):\n 1. imp_nfoldli (rev [l..<u]) c f s = imp_for_down l u c f s", "apply (subst imp_for_down.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s.\n                \\<lbrakk>u' = u - 1 - l; l < u - 1\\<rbrakk>\n                \\<Longrightarrow> imp_nfoldli (rev [l..<u - 1]) c f s =\n                                  imp_for_down l (u - 1) c f s;\n     Suc u' = u - l; l < u\\<rbrakk>\n    \\<Longrightarrow> imp_nfoldli (rev [l..<u]) c f s =\n                      (let i = u - 1\n                       in c s \\<bind>\n                          (\\<lambda>ctn.\n                              if ctn\n                              then f i s \\<bind>\n                                   (\\<lambda>s.\n if l < i then imp_for_down l i c f s else return s)\n                              else return s))", "apply (cases \"l < u - Suc 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>s.\n                \\<lbrakk>u' = u - 1 - l; l < u - 1\\<rbrakk>\n                \\<Longrightarrow> imp_nfoldli (rev [l..<u - 1]) c f s =\n                                  imp_for_down l (u - 1) c f s;\n     Suc u' = u - l; l < u; l < u - Suc 0\\<rbrakk>\n    \\<Longrightarrow> imp_nfoldli (rev [l..<u]) c f s =\n                      (let i = u - 1\n                       in c s \\<bind>\n                          (\\<lambda>ctn.\n                              if ctn\n                              then f i s \\<bind>\n                                   (\\<lambda>s.\n if l < i then imp_for_down l i c f s else return s)\n                              else return s))\n 2. \\<lbrakk>\\<And>s.\n                \\<lbrakk>u' = u - 1 - l; l < u - 1\\<rbrakk>\n                \\<Longrightarrow> imp_nfoldli (rev [l..<u - 1]) c f s =\n                                  imp_for_down l (u - 1) c f s;\n     Suc u' = u - l; l < u; \\<not> l < u - Suc 0\\<rbrakk>\n    \\<Longrightarrow> imp_nfoldli (rev [l..<u]) c f s =\n                      (let i = u - 1\n                       in c s \\<bind>\n                          (\\<lambda>ctn.\n                              if ctn\n                              then f i s \\<bind>\n                                   (\\<lambda>s.\n if l < i then imp_for_down l i c f s else return s)\n                              else return s))", "apply (auto simp: Let_def cong: if_cong)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  imp_nfoldli (rev [l..<u]) c f s = imp_for_down l u c f s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  imp_nfoldli (rev [l..<u]) c f s =\n  (if u \\<le> l then return s else imp_for_down l u c f s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  imp_nfoldli (rev [l..<u]) c f s =\n  (if u \\<le> l then return s else imp_for_down l u c f s)\n\ngoal:\nNo subgoals!", "qed"], ["", "context begin"], ["", "private"], ["", "fun imp_for_down_induction_scheme :: \"nat \\<Rightarrow> nat \\<Rightarrow> unit\" where\n  \"imp_for_down_induction_scheme l i = (\n    let i=i-1 in \n    if i>l then \n      imp_for_down_induction_scheme l i\n    else ()  \n  )\""], ["", "partial_function (heap) imp_for_down' :: \"nat \\<Rightarrow> nat \\<Rightarrow> (nat \\<Rightarrow> 'a \\<Rightarrow> 'a Heap) \\<Rightarrow> 'a \\<Rightarrow> 'a Heap\" where\n  \"imp_for_down' l i f s = do {\n    let i = i - 1;\n    s \\<leftarrow> f i s;\n    if i>l then imp_for_down' l i f s else return s\n  }\""], ["", "declare imp_for_down'.simps[code]"], ["", "lemma imp_for_down_no_cond[sepref_opt_simps]:\n  \"imp_for_down l u (\\<lambda>_. return True) = imp_for_down' l u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_for_down l u (\\<lambda>_. return True) = imp_for_down' l u", "apply (induction l u rule: imp_for_down_induction_scheme.induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l i.\n       (\\<And>x.\n           \\<lbrakk>x = i - 1; l < x\\<rbrakk>\n           \\<Longrightarrow> imp_for_down l x (\\<lambda>_. return True) =\n                             imp_for_down' l x) \\<Longrightarrow>\n       imp_for_down l i (\\<lambda>_. return True) = imp_for_down' l i", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l i x xa.\n       (\\<And>x.\n           \\<lbrakk>x = i - 1; l < x\\<rbrakk>\n           \\<Longrightarrow> imp_for_down l x (\\<lambda>_. return True) =\n                             imp_for_down' l x) \\<Longrightarrow>\n       imp_for_down l i (\\<lambda>_. return True) x xa =\n       imp_for_down' l i x xa", "apply (subst imp_for_down.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l i x xa.\n       (\\<And>x.\n           \\<lbrakk>x = i - 1; l < x\\<rbrakk>\n           \\<Longrightarrow> imp_for_down l x (\\<lambda>_. return True) =\n                             imp_for_down' l x) \\<Longrightarrow>\n       (let i = i - 1\n        in return True \\<bind>\n           (\\<lambda>ctn.\n               if ctn\n               then x i xa \\<bind>\n                    (\\<lambda>s.\n                        if l < i\n                        then imp_for_down l i (\\<lambda>_. return True) x s\n                        else return s)\n               else return xa)) =\n       imp_for_down' l i x xa", "apply (subst imp_for_down'.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l i x xa.\n       (\\<And>x.\n           \\<lbrakk>x = i - 1; l < x\\<rbrakk>\n           \\<Longrightarrow> imp_for_down l x (\\<lambda>_. return True) =\n                             imp_for_down' l x) \\<Longrightarrow>\n       (let i = i - 1\n        in return True \\<bind>\n           (\\<lambda>ctn.\n               if ctn\n               then x i xa \\<bind>\n                    (\\<lambda>s.\n                        if l < i\n                        then imp_for_down l i (\\<lambda>_. return True) x s\n                        else return s)\n               else return xa)) =\n       (let i = i - 1\n        in x i xa \\<bind>\n           (\\<lambda>s. if l < i then imp_for_down' l i x s else return s))", "apply (simp cong: if_cong)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "(* TODO: Move. Add rule for imp_for! *)"], ["", "lemma imp_for'_rule:\n  assumes LESS: \"l\\<le>u\"\n  assumes PRE: \"P \\<Longrightarrow>\\<^sub>A I l s\"\n  assumes STEP: \"\\<And>i s. \\<lbrakk> l\\<le>i; i<u \\<rbrakk> \\<Longrightarrow> <I i s> f i s <I (i+1)>\"\n  shows \"<P> imp_for' l u f s <I u>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <P> imp_for' l u f s <I u>", "apply (rule Hoare_Triple.cons_pre_rule[OF PRE])"], ["proof (prove)\ngoal (1 subgoal):\n 1. <I l s> imp_for' l u f s <I u>", "using LESS"], ["proof (prove)\nusing this:\n  l \\<le> u\n\ngoal (1 subgoal):\n 1. <I l s> imp_for' l u f s <I u>", "proof (induction arbitrary: s rule: inc_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s. <I u s> imp_for' u u f s <I u>\n 2. \\<And>n s.\n       \\<lbrakk>l \\<le> n; n < u;\n        \\<And>s. <I (Suc n) s> imp_for' (Suc n) u f s <I u>\\<rbrakk>\n       \\<Longrightarrow> <I n s> imp_for' n u f s <I u>", "case base"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>s. <I u s> imp_for' u u f s <I u>\n 2. \\<And>n s.\n       \\<lbrakk>l \\<le> n; n < u;\n        \\<And>s. <I (Suc n) s> imp_for' (Suc n) u f s <I u>\\<rbrakk>\n       \\<Longrightarrow> <I n s> imp_for' n u f s <I u>", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. <I u s> imp_for' u u f s <I u>", "by sep_auto"], ["proof (state)\nthis:\n  <I u s> imp_for' u u f s <I u>\n\ngoal (1 subgoal):\n 1. \\<And>n s.\n       \\<lbrakk>l \\<le> n; n < u;\n        \\<And>s. <I (Suc n) s> imp_for' (Suc n) u f s <I u>\\<rbrakk>\n       \\<Longrightarrow> <I n s> imp_for' n u f s <I u>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n s.\n       \\<lbrakk>l \\<le> n; n < u;\n        \\<And>s. <I (Suc n) s> imp_for' (Suc n) u f s <I u>\\<rbrakk>\n       \\<Longrightarrow> <I n s> imp_for' n u f s <I u>", "case (step k)"], ["proof (state)\nthis:\n  l \\<le> k\n  k < u\n  <I (Suc k) ?s> imp_for' (Suc k) u f ?s <I u>\n\ngoal (1 subgoal):\n 1. \\<And>n s.\n       \\<lbrakk>l \\<le> n; n < u;\n        \\<And>s. <I (Suc n) s> imp_for' (Suc n) u f s <I u>\\<rbrakk>\n       \\<Longrightarrow> <I n s> imp_for' n u f s <I u>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. <I k s> imp_for' k u f s <I u>", "using step.hyps"], ["proof (prove)\nusing this:\n  l \\<le> k\n  k < u\n\ngoal (1 subgoal):\n 1. <I k s> imp_for' k u f s <I u>", "by (sep_auto heap: STEP step.IH)"], ["proof (state)\nthis:\n  <I k s> imp_for' k u f s <I u>\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>This lemma is used to manually convert a fold to a loop over indices. \\<close>"], ["", "lemma fold_idx_conv: \"fold f l s = fold (\\<lambda>i. f (l!i)) [0..<length l] s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold f l s = fold (\\<lambda>i. f (l ! i)) [0..<length l] s", "proof (induction l arbitrary: s rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s. fold f [] s = fold (\\<lambda>i. f ([] ! i)) [0..<length []] s\n 2. \\<And>x xs s.\n       (\\<And>s.\n           fold f xs s =\n           fold (\\<lambda>i. f (xs ! i)) [0..<length xs]\n            s) \\<Longrightarrow>\n       fold f (xs @ [x]) s =\n       fold (\\<lambda>i. f ((xs @ [x]) ! i)) [0..<length (xs @ [x])] s", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>s. fold f [] s = fold (\\<lambda>i. f ([] ! i)) [0..<length []] s\n 2. \\<And>x xs s.\n       (\\<And>s.\n           fold f xs s =\n           fold (\\<lambda>i. f (xs ! i)) [0..<length xs]\n            s) \\<Longrightarrow>\n       fold f (xs @ [x]) s =\n       fold (\\<lambda>i. f ((xs @ [x]) ! i)) [0..<length (xs @ [x])] s", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. fold f [] s = fold (\\<lambda>i. f ([] ! i)) [0..<length []] s", "by simp"], ["proof (state)\nthis:\n  fold f [] s = fold (\\<lambda>i. f ([] ! i)) [0..<length []] s\n\ngoal (1 subgoal):\n 1. \\<And>x xs s.\n       (\\<And>s.\n           fold f xs s =\n           fold (\\<lambda>i. f (xs ! i)) [0..<length xs]\n            s) \\<Longrightarrow>\n       fold f (xs @ [x]) s =\n       fold (\\<lambda>i. f ((xs @ [x]) ! i)) [0..<length (xs @ [x])] s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs s.\n       (\\<And>s.\n           fold f xs s =\n           fold (\\<lambda>i. f (xs ! i)) [0..<length xs]\n            s) \\<Longrightarrow>\n       fold f (xs @ [x]) s =\n       fold (\\<lambda>i. f ((xs @ [x]) ! i)) [0..<length (xs @ [x])] s", "case (snoc x l)"], ["proof (state)\nthis:\n  fold f l ?s = fold (\\<lambda>i. f (l ! i)) [0..<length l] ?s\n\ngoal (1 subgoal):\n 1. \\<And>x xs s.\n       (\\<And>s.\n           fold f xs s =\n           fold (\\<lambda>i. f (xs ! i)) [0..<length xs]\n            s) \\<Longrightarrow>\n       fold f (xs @ [x]) s =\n       fold (\\<lambda>i. f ((xs @ [x]) ! i)) [0..<length (xs @ [x])] s", "{"], ["proof (state)\nthis:\n  fold f l ?s = fold (\\<lambda>i. f (l ! i)) [0..<length l] ?s\n\ngoal (1 subgoal):\n 1. \\<And>x xs s.\n       (\\<And>s.\n           fold f xs s =\n           fold (\\<lambda>i. f (xs ! i)) [0..<length xs]\n            s) \\<Longrightarrow>\n       fold f (xs @ [x]) s =\n       fold (\\<lambda>i. f ((xs @ [x]) ! i)) [0..<length (xs @ [x])] s", "fix x s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs s.\n       (\\<And>s.\n           fold f xs s =\n           fold (\\<lambda>i. f (xs ! i)) [0..<length xs]\n            s) \\<Longrightarrow>\n       fold f (xs @ [x]) s =\n       fold (\\<lambda>i. f ((xs @ [x]) ! i)) [0..<length (xs @ [x])] s", "have \"fold (\\<lambda>a. f ((l @ [x]) ! a)) [0..<length l] s = fold (\\<lambda>a. f (l ! a)) [0..<length l] s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>a. f ((l @ [x]) ! a)) [0..<length l] s =\n    fold (\\<lambda>a. f (l ! a)) [0..<length l] s", "by (rule fold_cong) (simp_all add: nth_append)"], ["proof (state)\nthis:\n  fold (\\<lambda>a. f ((l @ [x]) ! a)) [0..<length l] s =\n  fold (\\<lambda>a. f (l ! a)) [0..<length l] s\n\ngoal (1 subgoal):\n 1. \\<And>x xs s.\n       (\\<And>s.\n           fold f xs s =\n           fold (\\<lambda>i. f (xs ! i)) [0..<length xs]\n            s) \\<Longrightarrow>\n       fold f (xs @ [x]) s =\n       fold (\\<lambda>i. f ((xs @ [x]) ! i)) [0..<length (xs @ [x])] s", "}"], ["proof (state)\nthis:\n  fold (\\<lambda>a. f ((l @ [?xa2]) ! a)) [0..<length l] ?sb2 =\n  fold (\\<lambda>a. f (l ! a)) [0..<length l] ?sb2\n\ngoal (1 subgoal):\n 1. \\<And>x xs s.\n       (\\<And>s.\n           fold f xs s =\n           fold (\\<lambda>i. f (xs ! i)) [0..<length xs]\n            s) \\<Longrightarrow>\n       fold f (xs @ [x]) s =\n       fold (\\<lambda>i. f ((xs @ [x]) ! i)) [0..<length (xs @ [x])] s", "with snoc"], ["proof (chain)\npicking this:\n  fold f l ?s = fold (\\<lambda>i. f (l ! i)) [0..<length l] ?s\n  fold (\\<lambda>a. f ((l @ [?xa2]) ! a)) [0..<length l] ?sb2 =\n  fold (\\<lambda>a. f (l ! a)) [0..<length l] ?sb2", "show ?case"], ["proof (prove)\nusing this:\n  fold f l ?s = fold (\\<lambda>i. f (l ! i)) [0..<length l] ?s\n  fold (\\<lambda>a. f ((l @ [?xa2]) ! a)) [0..<length l] ?sb2 =\n  fold (\\<lambda>a. f (l ! a)) [0..<length l] ?sb2\n\ngoal (1 subgoal):\n 1. fold f (l @ [x]) s =\n    fold (\\<lambda>i. f ((l @ [x]) ! i)) [0..<length (l @ [x])] s", "by simp"], ["proof (state)\nthis:\n  fold f (l @ [x]) s =\n  fold (\\<lambda>i. f ((l @ [x]) ! i)) [0..<length (l @ [x])] s\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}