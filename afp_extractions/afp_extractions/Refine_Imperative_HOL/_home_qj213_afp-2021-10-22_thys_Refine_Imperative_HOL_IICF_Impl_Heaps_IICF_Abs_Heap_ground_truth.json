{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/IICF/Impl/Heaps/IICF_Abs_Heap.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemma valid_empty[simp]: \"\\<not>valid [] i\"", "lemma valid0[simp]: \"\\<not>valid h 0\"", "lemma valid_glen[simp]: \"i>length h \\<Longrightarrow> \\<not>valid h i\"", "lemma valid_len[simp]: \"h\\<noteq>[] \\<Longrightarrow> valid h (length h)\"", "lemma validI: \"0<i \\<Longrightarrow> i\\<le>length h \\<Longrightarrow> valid h i\"", "lemma parent_left_id[simp]: \"parent (left i) = i\"", "lemma parent_right_id[simp]: \"parent (right i) = i\"", "lemma child_of_parentD:\n      \"has_parent l i \\<Longrightarrow> left (parent i) = i \\<or> right (parent i) = i\"", "lemma rc_imp_lc: \"\\<lbrakk>valid h i; has_right h i\\<rbrakk> \\<Longrightarrow> has_left h i\"", "lemma plr_corner_cases[simp]: \n      assumes \"0<i\"\n      shows \n      \"i\\<noteq>parent i\"\n      \"i\\<noteq>left i\"\n      \"i\\<noteq>right i\"\n      \"parent i \\<noteq> i\"\n      \"left i \\<noteq> i\"\n      \"right i \\<noteq> i\"", "lemma i_eq_parent_conv[simp]: \"i=parent i \\<longleftrightarrow> i=0\"", "lemma heap_invar_empty[simp]: \"heap_invar []\"", "lemma \n      heap_parent_le: \"\\<lbrakk>heap_invar l; valid l i; has_parent l i\\<rbrakk> \n        \\<Longrightarrow> pparent l i \\<le> prio_of l i\"", "lemma heap_min_prop:\n      assumes H: \"heap_invar h\"\n      assumes V: \"valid h i\"\n      shows \"prio_of h (Suc 0) \\<le> prio_of h i\"", "lemma heap_eq_heap':\n      shows \"heap_invar h \\<longleftrightarrow> heap_invar' h\"", "lemma val_of_correct[refine_vcg]: \n      \"val_of_pre l i \\<Longrightarrow> val_of_op l i \\<le> SPEC (\\<lambda>r. r = val_of l i)\"", "lemma prio_of_op_correct[refine_vcg]: \n      \"prio_of_pre l i \\<Longrightarrow> prio_of_op l i \\<le> SPEC (\\<lambda>r. r = prio_of l i)\"", "lemma update_correct[refine_vcg]:\n      \"update_pre h i v \\<Longrightarrow> update_op h i v \\<le> SPEC(\\<lambda>r. r = update h i v)\"", "lemma update_valid[simp]: \"valid (update h i v) j \\<longleftrightarrow> valid h j\"", "lemma val_of_update[simp]: \"\\<lbrakk>update_pre h i v; valid h j\\<rbrakk> \\<Longrightarrow> val_of (update h i v) j = (\n      if i=j then v else val_of h j)\"", "lemma length_update[simp]: \"length (update l i v) = length l\"", "lemma exch_op_alt: \"exch_op l i j = do { \n      vi \\<leftarrow> val_of_op l i;\n      vj \\<leftarrow> val_of_op l j;\n      l \\<leftarrow> update_op l i vj;\n      l \\<leftarrow> update_op l j vi;\n      RETURN l }\"", "lemma exch_op_correct[refine_vcg]: \n      \"exch_pre l i j \\<Longrightarrow> exch_op l i j \\<le> SPEC (\\<lambda>r. r = exch l i j)\"", "lemma valid_exch[simp]: \"valid (exch l i j) k = valid l k\"", "lemma val_of_exch[simp]: \"\\<lbrakk>valid l i; valid l j; valid l k\\<rbrakk> \\<Longrightarrow> \n      val_of (exch l i j) k = (\n        if k=i then val_of l j\n        else if k=j then val_of l i\n        else val_of l k\n      )\"", "lemma exch_eq[simp]: \"exch h i i = h\"", "lemma \\<alpha>_exch[simp]: \"\\<lbrakk>valid l i; valid l j\\<rbrakk> \n      \\<Longrightarrow> \\<alpha> (exch l i j) = \\<alpha> l\"", "lemma length_exch[simp]: \"length (exch l i j) = length l\"", "lemma butlast_op_correct[refine_vcg]: \n      \"butlast_pre l \\<Longrightarrow> butlast_op l \\<le> SPEC (\\<lambda>r. r = butlast l)\"", "lemma valid_butlast_conv[simp]: \"valid (butlast h) i \\<longleftrightarrow> valid h i \\<and> i < length h\"", "lemma valid_butlast: \"valid (butlast h) i \\<Longrightarrow> valid h i\"", "lemma val_of_butlast[simp]: \"\\<lbrakk>valid h i; i<length h\\<rbrakk> \n      \\<Longrightarrow> val_of (butlast h) i = val_of h i\"", "lemma val_of_butlast'[simp]: \n      \"valid (butlast h) i \\<Longrightarrow> val_of (butlast h) i = val_of h i\"", "lemma \\<alpha>_butlast[simp]: \"\\<lbrakk> length h \\<noteq> 0 \\<rbrakk> \n      \\<Longrightarrow> \\<alpha> (butlast h) = \\<alpha> h - {# val_of h (length h)#}\"", "lemma heap_invar_butlast[simp]: \"heap_invar h \\<Longrightarrow> heap_invar (butlast h)\"", "lemma append_op_correct[refine_vcg]: \n      \"append_op l v \\<le> SPEC (\\<lambda>r. r = l@[v])\"", "lemma valid_append[simp]: \"valid (l@[v]) i \\<longleftrightarrow> valid l i \\<or> i = length l + 1\"", "lemma val_of_append[simp]: \"valid (l@[v]) i \\<Longrightarrow> \n      val_of (l@[v]) i = (if valid l i then val_of l i else v)\"", "lemma \\<alpha>_append[simp]: \"\\<alpha> (l@[v]) = \\<alpha> l + {#v#}\"", "lemma swim_invar_valid: \"swim_invar h i \\<Longrightarrow> valid h i\"", "lemma swim_invar_exit1: \"\\<not>has_parent h i \\<Longrightarrow> swim_invar h i \\<Longrightarrow> heap_invar h\"", "lemma swim_invar_exit2: \"pparent h i \\<le> prio_of h i \\<Longrightarrow> swim_invar h i \\<Longrightarrow> heap_invar h\"", "lemma swim_invar_pres:\n      assumes HPI: \"has_parent h i\" \n      assumes VIOLATED: \"pparent h i > prio_of h i\" \n      and INV: \"swim_invar h i\"\n      defines \"h' \\<equiv> exch h i (parent i)\"\n      shows \"swim_invar h' (parent i)\"", "lemma swim_invar_decr:\n      assumes INV: \"heap_invar h\"\n      assumes V: \"valid h i\"\n      assumes DECR: \"prio v \\<le> prio_of h i\"\n      shows \"swim_invar (update h i v) i\"", "lemma swim_op_correct[refine_vcg]: \n    \"\\<lbrakk>swim_invar h i\\<rbrakk> \\<Longrightarrow>\n      swim_op h i \\<le> SPEC (\\<lambda>h'. \\<alpha> h' = \\<alpha> h \\<and> heap_invar h' \\<and> length h' = length h)\"", "lemma sink_invar_valid: \"sink_invar l i \\<Longrightarrow> valid l i\"", "lemma sink_invar_exit: \"\\<lbrakk>sink_invar l i; children_ge l (prio_of l i) i\\<rbrakk> \n      \\<Longrightarrow> heap_invar' l\"", "lemma sink_aux1: \"\\<not> (2*i \\<le> length h) \\<Longrightarrow> \\<not>has_left h i \\<and> \\<not>has_right h i\"", "lemma sink_invar_pres1:\n      assumes \"sink_invar h i\"\n      assumes \"has_left h i\" \"has_right h i\"\n      assumes \"prio_of h i \\<ge> pleft h i\"\n      assumes \"pleft h i \\<ge> pright h i\"\n      shows \"sink_invar (exch h i (right i)) (right i)\"", "lemma sink_invar_pres2:\n      assumes \"sink_invar h i\"\n      assumes \"has_left h i\" \"has_right h i\"\n      assumes \"prio_of h i \\<ge> pleft h i\"\n      assumes \"pleft h i \\<le> pright h i\"\n      shows \"sink_invar (exch h i (left i)) (left i)\"", "lemma sink_invar_pres3:\n      assumes \"sink_invar h i\"\n      assumes \"has_left h i\" \"has_right h i\"\n      assumes \"prio_of h i \\<ge> pright h i\"\n      assumes \"pleft h i \\<le> pright h i\"\n      shows \"sink_invar (exch h i (left i)) (left i)\"", "lemma sink_invar_pres4:\n      assumes \"sink_invar h i\"\n      assumes \"has_left h i\" \"has_right h i\"\n      assumes \"prio_of h i \\<ge> pright h i\"\n      assumes \"pleft h i \\<ge> pright h i\"\n      shows \"sink_invar (exch h i (right i)) (right i)\"", "lemma sink_invar_pres5:\n      assumes \"sink_invar h i\"\n      assumes \"has_left h i\" \"\\<not>has_right h i\"\n      assumes \"prio_of h i \\<ge> pleft h i\"\n      shows \"sink_invar (exch h i (left i)) (left i)\"", "lemmas sink_invar_pres = \n      sink_invar_pres1 \n      sink_invar_pres2 \n      sink_invar_pres3 \n      sink_invar_pres4 \n      sink_invar_pres5", "lemma sink_invar_incr:\n      assumes INV: \"heap_invar h\"\n      assumes V: \"valid h i\"\n      assumes INCR: \"prio v \\<ge> prio_of h i\"\n      shows \"sink_invar (update h i v) i\"", "lemma sink_op_correct[refine_vcg]: \n    \"\\<lbrakk>sink_invar h i\\<rbrakk> \\<Longrightarrow>\n      sink_op h i \\<le> SPEC (\\<lambda>h'. \\<alpha> h' = \\<alpha> h \\<and> heap_invar h' \\<and> length h' = length h)\"", "lemma sink_op_swim_rule: \n      \"swim_invar h i \\<Longrightarrow> sink_op h i \\<le> SPEC (\\<lambda>h'. h'=h)\"", "lemma sink_op_opt_eq: \"sink_op_opt h k = sink_op h k\"", "lemma update_sink_swim_cases:\n      assumes \"heap_invar h\"\n      assumes \"valid h i\"\n      obtains \"swim_invar (update h i v) i\" | \"sink_invar (update h i v) i\"", "lemma heap_invar_imp_swim_invar: \"\\<lbrakk>heap_invar h; valid h i\\<rbrakk> \\<Longrightarrow> swim_invar h i\"", "lemma repair_correct[refine_vcg]:\n      assumes \"heap_invar h\" and \"valid h i\"\n      shows \"repair_op (update h i v) i \\<le> SPEC (\\<lambda>h'.\n        heap_invar h' \\<and> \\<alpha> h' = \\<alpha> (update h i v) \\<and> length h' = length h)\"", "lemma empty_op_correct[refine_vcg]:\n      \"empty_op \\<le> SPEC (\\<lambda>r. \\<alpha> r = {#} \\<and> heap_invar r)\"", "lemma is_empty_op_correct[refine_vcg]: \n      \"heap_invar h \\<Longrightarrow> is_empty_op h \\<le> SPEC (\\<lambda>r. r\\<longleftrightarrow>\\<alpha> h = {#})\"", "lemma swim_invar_insert: \"heap_invar l \\<Longrightarrow> swim_invar (l@[x]) (Suc (length l))\"", "lemma  \n      \"(insert_op,RETURN oo op_mset_insert) \\<in> Id \\<rightarrow> heap_rel1 \\<rightarrow> \\<langle>heap_rel1\\<rangle>nres_rel\"", "lemma insert_op_correct:\n      \"heap_invar h \\<Longrightarrow> insert_op v h \\<le> SPEC (\\<lambda>h'. heap_invar h' \\<and> \\<alpha> h' = \\<alpha> h + {#v#})\"", "lemmas [refine_vcg] = insert_op_correct", "lemma left_not_one[simp]: \"left j \\<noteq> Suc 0\"", "lemma right_one_conv[simp]: \"right j = Suc 0 \\<longleftrightarrow> j=0\"", "lemma parent_one_conv[simp]: \"parent (Suc 0) = 0\"", "lemma sink_invar_init:\n      assumes I: \"heap_invar h\" \n      assumes NE: \"length h > 1\" \n      shows \"sink_invar (butlast (exch h (Suc 0) (length h))) (Suc 0)\"", "lemma in_set_conv_val: \"v \\<in> set h \\<longleftrightarrow> (\\<exists>i. valid h i \\<and> v = val_of h i)\"", "lemma pop_min_op_correct: \n      assumes \"heap_invar h\" \"\\<alpha> h \\<noteq> {#}\" \n      shows \"pop_min_op h \\<le> SPEC (\\<lambda>(v,h'). heap_invar h' \\<and>\n        v \\<in># \\<alpha> h \\<and> \\<alpha> h' = \\<alpha> h - {#v#} \\<and> (\\<forall>v'\\<in>set_mset (\\<alpha> h). prio v \\<le> prio v'))\"", "lemmas [refine_vcg] = pop_min_op_correct", "lemma peek_min_op_correct:\n      assumes \"heap_invar h\" \"\\<alpha> h \\<noteq> {#}\" \n      shows \"peek_min_op h \\<le> SPEC (\\<lambda>v. \n        v \\<in># \\<alpha> h \\<and> (\\<forall>v'\\<in>set_mset (\\<alpha> h). prio v \\<le> prio v'))\"", "lemmas peek_min_op_correct'[refine_vcg] = peek_min_op_correct", "lemma empty_op_refine: \"(empty_op,RETURN op_mset_empty)\\<in>\\<langle>heap_rel1\\<rangle>nres_rel\"", "lemma is_empty_op_refine: \"(is_empty_op,RETURN o op_mset_is_empty) \\<in> heap_rel1 \\<rightarrow> \\<langle>bool_rel\\<rangle>nres_rel\"", "lemma insert_op_refine: \"(insert_op,RETURN oo op_mset_insert) \\<in> Id \\<rightarrow> heap_rel1 \\<rightarrow> \\<langle>heap_rel1\\<rangle>nres_rel\"", "lemma pop_min_op_refine: \n      \"(pop_min_op, PR_CONST (mop_prio_pop_min prio)) \\<in> heap_rel1 \\<rightarrow> \\<langle>Id \\<times>\\<^sub>r heap_rel1\\<rangle>nres_rel\"", "lemma peek_min_op_refine: \n      \"(peek_min_op, PR_CONST (mop_prio_peek_min prio)) \\<in> heap_rel1 \\<rightarrow> \\<langle>Id\\<rangle>nres_rel\""], "translations": [["", "lemma valid_empty[simp]: \"\\<not>valid [] i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> valid [] i", "by (auto simp: valid_def)"], ["", "lemma valid0[simp]: \"\\<not>valid h 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> valid h 0", "by (auto simp: valid_def)"], ["", "lemma valid_glen[simp]: \"i>length h \\<Longrightarrow> \\<not>valid h i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length h < i \\<Longrightarrow> \\<not> valid h i", "by (auto simp: valid_def)"], ["", "lemma valid_len[simp]: \"h\\<noteq>[] \\<Longrightarrow> valid h (length h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<noteq> [] \\<Longrightarrow> valid h (length h)", "by (auto simp: valid_def)"], ["", "lemma validI: \"0<i \\<Longrightarrow> i\\<le>length h \\<Longrightarrow> valid h i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < i; i \\<le> length h\\<rbrakk> \\<Longrightarrow> valid h i", "by (auto simp: valid_def)"], ["", "definition val_of :: \"'a heap \\<Rightarrow> nat \\<Rightarrow> 'a\" where \"val_of l i \\<equiv> l!(i-1)\""], ["", "abbreviation prio_of :: \"'a heap \\<Rightarrow> nat \\<Rightarrow> 'b\" where\n      \"prio_of l i \\<equiv> prio (val_of l i)\""], ["", "subsubsection \\<open>Navigating the tree\\<close>"], ["", "definition parent :: \"nat \\<Rightarrow> nat\" where \"parent i \\<equiv> i div 2\""], ["", "definition left :: \"nat \\<Rightarrow> nat\" where \"left i \\<equiv> 2*i\""], ["", "definition right :: \"nat \\<Rightarrow> nat\" where \"right i \\<equiv> 2*i + 1\""], ["", "abbreviation \"has_parent h i \\<equiv> valid h (parent i)\""], ["", "abbreviation \"has_left h i \\<equiv> valid h (left i)\""], ["", "abbreviation \"has_right h i \\<equiv> valid h (right i)\""], ["", "abbreviation \"vparent h i == val_of h (parent i)\""], ["", "abbreviation \"vleft h i == val_of h (left i)\""], ["", "abbreviation \"vright h i == val_of h (right i)\""], ["", "abbreviation \"pparent h i == prio_of h (parent i)\""], ["", "abbreviation \"pleft h i == prio_of h (left i)\""], ["", "abbreviation \"pright h i == prio_of h (right i)\""], ["", "lemma parent_left_id[simp]: \"parent (left i) = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parent (left i) = i", "unfolding parent_def left_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * i div 2 = i", "by auto"], ["", "lemma parent_right_id[simp]: \"parent (right i) = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parent (right i) = i", "unfolding parent_def right_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 * i + 1) div 2 = i", "by auto"], ["", "lemma child_of_parentD:\n      \"has_parent l i \\<Longrightarrow> left (parent i) = i \\<or> right (parent i) = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_parent l i \\<Longrightarrow>\n    left (parent i) = i \\<or> right (parent i) = i", "unfolding parent_def left_def right_def valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < i div 2 \\<and> i div 2 \\<le> length l \\<Longrightarrow>\n    2 * (i div 2) = i \\<or> 2 * (i div 2) + 1 = i", "by auto"], ["", "lemma rc_imp_lc: \"\\<lbrakk>valid h i; has_right h i\\<rbrakk> \\<Longrightarrow> has_left h i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid h i; has_right h i\\<rbrakk>\n    \\<Longrightarrow> has_left h i", "by (auto simp: valid_def left_def right_def)"], ["", "lemma plr_corner_cases[simp]: \n      assumes \"0<i\"\n      shows \n      \"i\\<noteq>parent i\"\n      \"i\\<noteq>left i\"\n      \"i\\<noteq>right i\"\n      \"parent i \\<noteq> i\"\n      \"left i \\<noteq> i\"\n      \"right i \\<noteq> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i \\<noteq> parent i &&& i \\<noteq> left i &&& i \\<noteq> right i) &&&\n    parent i \\<noteq> i &&& left i \\<noteq> i &&& right i \\<noteq> i", "using assms"], ["proof (prove)\nusing this:\n  0 < i\n\ngoal (1 subgoal):\n 1. (i \\<noteq> parent i &&& i \\<noteq> left i &&& i \\<noteq> right i) &&&\n    parent i \\<noteq> i &&& left i \\<noteq> i &&& right i \\<noteq> i", "by (auto simp: parent_def left_def right_def)"], ["", "lemma i_eq_parent_conv[simp]: \"i=parent i \\<longleftrightarrow> i=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i = parent i) = (i = 0)", "by (auto simp: parent_def)"], ["", "subsubsection \\<open>Heap Property\\<close>"], ["", "text \\<open>The heap property states, that every node's priority is greater \n      or equal to its parent's priority \\<close>"], ["", "definition heap_invar :: \"'a heap \\<Rightarrow> bool\"\n      where \"heap_invar l \n      \\<equiv> \\<forall>i. valid l i \\<longrightarrow> has_parent l i \\<longrightarrow> pparent l i \\<le> prio_of l i\""], ["", "definition \"heap_rel1 \\<equiv> br \\<alpha> heap_invar\""], ["", "lemma heap_invar_empty[simp]: \"heap_invar []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_invar []", "by (auto simp: heap_invar_def)"], ["", "function heap_induction_scheme :: \"nat \\<Rightarrow> unit\" where\n      \"heap_induction_scheme i = (\n        if i>1 then heap_induction_scheme (parent i) else ())\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x. (\\<And>i. x = i \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>i ia.\n       i = ia \\<Longrightarrow>\n       (if 1 < i then heap_induction_scheme_sumC (parent i) else ()) =\n       (if 1 < ia then heap_induction_scheme_sumC (parent ia) else ())", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. Wellfounded.accp heap_induction_scheme_rel x", "apply (relation \"less_than\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. wf less_than\n 2. \\<And>i. 1 < i \\<Longrightarrow> (parent i, i) \\<in> less_than", "apply (auto simp: parent_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \n      heap_parent_le: \"\\<lbrakk>heap_invar l; valid l i; has_parent l i\\<rbrakk> \n        \\<Longrightarrow> pparent l i \\<le> prio_of l i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heap_invar l; valid l i; has_parent l i\\<rbrakk>\n    \\<Longrightarrow> pparent l i \\<le> prio_of l i", "unfolding heap_invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i.\n                valid l i \\<longrightarrow>\n                has_parent l i \\<longrightarrow>\n                pparent l i \\<le> prio_of l i;\n     valid l i; has_parent l i\\<rbrakk>\n    \\<Longrightarrow> pparent l i \\<le> prio_of l i", "by auto"], ["", "lemma heap_min_prop:\n      assumes H: \"heap_invar h\"\n      assumes V: \"valid h i\"\n      shows \"prio_of h (Suc 0) \\<le> prio_of h i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prio_of h (Suc 0) \\<le> prio_of h i", "proof (cases \"i>1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 1 < i \\<Longrightarrow> prio_of h (Suc 0) \\<le> prio_of h i\n 2. \\<not> 1 < i \\<Longrightarrow> prio_of h (Suc 0) \\<le> prio_of h i", "case False"], ["proof (state)\nthis:\n  \\<not> 1 < i\n\ngoal (2 subgoals):\n 1. 1 < i \\<Longrightarrow> prio_of h (Suc 0) \\<le> prio_of h i\n 2. \\<not> 1 < i \\<Longrightarrow> prio_of h (Suc 0) \\<le> prio_of h i", "with V"], ["proof (chain)\npicking this:\n  valid h i\n  \\<not> 1 < i", "show ?thesis"], ["proof (prove)\nusing this:\n  valid h i\n  \\<not> 1 < i\n\ngoal (1 subgoal):\n 1. prio_of h (Suc 0) \\<le> prio_of h i", "by (auto simp: valid_def intro: Suc_lessI)"], ["proof (state)\nthis:\n  prio_of h (Suc 0) \\<le> prio_of h i\n\ngoal (1 subgoal):\n 1. 1 < i \\<Longrightarrow> prio_of h (Suc 0) \\<le> prio_of h i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 < i \\<Longrightarrow> prio_of h (Suc 0) \\<le> prio_of h i", "case True"], ["proof (state)\nthis:\n  1 < i\n\ngoal (1 subgoal):\n 1. 1 < i \\<Longrightarrow> prio_of h (Suc 0) \\<le> prio_of h i", "from V"], ["proof (chain)\npicking this:\n  valid h i", "have \"i\\<le>length h\" \"valid h (Suc 0)\""], ["proof (prove)\nusing this:\n  valid h i\n\ngoal (1 subgoal):\n 1. i \\<le> length h &&& valid h (Suc 0)", "by (auto simp: valid_def)"], ["proof (state)\nthis:\n  i \\<le> length h\n  valid h (Suc 0)\n\ngoal (1 subgoal):\n 1. 1 < i \\<Longrightarrow> prio_of h (Suc 0) \\<le> prio_of h i", "with True"], ["proof (chain)\npicking this:\n  1 < i\n  i \\<le> length h\n  valid h (Suc 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  1 < i\n  i \\<le> length h\n  valid h (Suc 0)\n\ngoal (1 subgoal):\n 1. prio_of h (Suc 0) \\<le> prio_of h i", "apply (induction i rule: heap_induction_scheme.induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<lbrakk>1 < i; 1 < parent i; parent i \\<le> length h;\n                 valid h (Suc 0)\\<rbrakk>\n                \\<Longrightarrow> prio_of h (Suc 0) \\<le> pparent h i;\n        1 < i; i \\<le> length h; valid h (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> prio_of h (Suc 0) \\<le> prio_of h i", "apply (rename_tac i)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<lbrakk>1 < i; 1 < parent i; parent i \\<le> length h;\n                 valid h (Suc 0)\\<rbrakk>\n                \\<Longrightarrow> prio_of h (Suc 0) \\<le> pparent h i;\n        1 < i; i \\<le> length h; valid h (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> prio_of h (Suc 0) \\<le> prio_of h i", "apply (case_tac \"parent i = Suc 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>\\<lbrakk>1 < i; 1 < parent i; parent i \\<le> length h;\n                 valid h (Suc 0)\\<rbrakk>\n                \\<Longrightarrow> prio_of h (Suc 0) \\<le> pparent h i;\n        1 < i; i \\<le> length h; valid h (Suc 0); parent i = Suc 0\\<rbrakk>\n       \\<Longrightarrow> prio_of h (Suc 0) \\<le> prio_of h i\n 2. \\<And>i.\n       \\<lbrakk>\\<lbrakk>1 < i; 1 < parent i; parent i \\<le> length h;\n                 valid h (Suc 0)\\<rbrakk>\n                \\<Longrightarrow> prio_of h (Suc 0) \\<le> pparent h i;\n        1 < i; i \\<le> length h; valid h (Suc 0);\n        parent i \\<noteq> Suc 0\\<rbrakk>\n       \\<Longrightarrow> prio_of h (Suc 0) \\<le> prio_of h i", "apply (rule order_trans[rotated])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>\\<lbrakk>1 < i; 1 < parent i; parent i \\<le> length h;\n                 valid h (Suc 0)\\<rbrakk>\n                \\<Longrightarrow> prio_of h (Suc 0) \\<le> pparent h i;\n        1 < i; i \\<le> length h; valid h (Suc 0); parent i = Suc 0\\<rbrakk>\n       \\<Longrightarrow> ?y2 i \\<le> prio_of h i\n 2. \\<And>i.\n       \\<lbrakk>\\<lbrakk>1 < i; 1 < parent i; parent i \\<le> length h;\n                 valid h (Suc 0)\\<rbrakk>\n                \\<Longrightarrow> prio_of h (Suc 0) \\<le> pparent h i;\n        1 < i; i \\<le> length h; valid h (Suc 0); parent i = Suc 0\\<rbrakk>\n       \\<Longrightarrow> prio_of h (Suc 0) \\<le> ?y2 i\n 3. \\<And>i.\n       \\<lbrakk>\\<lbrakk>1 < i; 1 < parent i; parent i \\<le> length h;\n                 valid h (Suc 0)\\<rbrakk>\n                \\<Longrightarrow> prio_of h (Suc 0) \\<le> pparent h i;\n        1 < i; i \\<le> length h; valid h (Suc 0);\n        parent i \\<noteq> Suc 0\\<rbrakk>\n       \\<Longrightarrow> prio_of h (Suc 0) \\<le> prio_of h i", "apply (rule heap_parent_le[OF H])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>\\<lbrakk>1 < i; 1 < parent i; parent i \\<le> length h;\n                 valid h (Suc 0)\\<rbrakk>\n                \\<Longrightarrow> prio_of h (Suc 0) \\<le> pparent h i;\n        1 < i; i \\<le> length h; valid h (Suc 0); parent i = Suc 0\\<rbrakk>\n       \\<Longrightarrow> valid h i\n 2. \\<And>i.\n       \\<lbrakk>\\<lbrakk>1 < i; 1 < parent i; parent i \\<le> length h;\n                 valid h (Suc 0)\\<rbrakk>\n                \\<Longrightarrow> prio_of h (Suc 0) \\<le> pparent h i;\n        1 < i; i \\<le> length h; valid h (Suc 0); parent i = Suc 0\\<rbrakk>\n       \\<Longrightarrow> has_parent h i\n 3. \\<And>i.\n       \\<lbrakk>\\<lbrakk>1 < i; 1 < parent i; parent i \\<le> length h;\n                 valid h (Suc 0)\\<rbrakk>\n                \\<Longrightarrow> prio_of h (Suc 0) \\<le> pparent h i;\n        1 < i; i \\<le> length h; valid h (Suc 0); parent i = Suc 0\\<rbrakk>\n       \\<Longrightarrow> prio_of h (Suc 0) \\<le> pparent h i\n 4. \\<And>i.\n       \\<lbrakk>\\<lbrakk>1 < i; 1 < parent i; parent i \\<le> length h;\n                 valid h (Suc 0)\\<rbrakk>\n                \\<Longrightarrow> prio_of h (Suc 0) \\<le> pparent h i;\n        1 < i; i \\<le> length h; valid h (Suc 0);\n        parent i \\<noteq> Suc 0\\<rbrakk>\n       \\<Longrightarrow> prio_of h (Suc 0) \\<le> prio_of h i", "apply (auto simp: valid_def) [3]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<lbrakk>1 < i; 1 < parent i; parent i \\<le> length h;\n                 valid h (Suc 0)\\<rbrakk>\n                \\<Longrightarrow> prio_of h (Suc 0) \\<le> pparent h i;\n        1 < i; i \\<le> length h; valid h (Suc 0);\n        parent i \\<noteq> Suc 0\\<rbrakk>\n       \\<Longrightarrow> prio_of h (Suc 0) \\<le> prio_of h i", "apply (rule order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>\\<lbrakk>1 < i; 1 < parent i; parent i \\<le> length h;\n                 valid h (Suc 0)\\<rbrakk>\n                \\<Longrightarrow> prio_of h (Suc 0) \\<le> pparent h i;\n        1 < i; i \\<le> length h; valid h (Suc 0);\n        parent i \\<noteq> Suc 0\\<rbrakk>\n       \\<Longrightarrow> prio_of h (Suc 0) \\<le> ?y10 i\n 2. \\<And>i.\n       \\<lbrakk>\\<lbrakk>1 < i; 1 < parent i; parent i \\<le> length h;\n                 valid h (Suc 0)\\<rbrakk>\n                \\<Longrightarrow> prio_of h (Suc 0) \\<le> pparent h i;\n        1 < i; i \\<le> length h; valid h (Suc 0);\n        parent i \\<noteq> Suc 0\\<rbrakk>\n       \\<Longrightarrow> ?y10 i \\<le> prio_of h i", "apply (rprems)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>1 < i; i \\<le> length h; valid h (Suc 0);\n        parent i \\<noteq> Suc 0\\<rbrakk>\n       \\<Longrightarrow> 1 < i\n 2. \\<And>i.\n       \\<lbrakk>1 < i; i \\<le> length h; valid h (Suc 0);\n        parent i \\<noteq> Suc 0\\<rbrakk>\n       \\<Longrightarrow> 1 < parent i\n 3. \\<And>i.\n       \\<lbrakk>1 < i; i \\<le> length h; valid h (Suc 0);\n        parent i \\<noteq> Suc 0\\<rbrakk>\n       \\<Longrightarrow> parent i \\<le> length h\n 4. \\<And>i.\n       \\<lbrakk>1 < i; i \\<le> length h; valid h (Suc 0);\n        parent i \\<noteq> Suc 0\\<rbrakk>\n       \\<Longrightarrow> valid h (Suc 0)\n 5. \\<And>i.\n       \\<lbrakk>\\<lbrakk>1 < i; 1 < parent i; parent i \\<le> length h;\n                 valid h (Suc 0)\\<rbrakk>\n                \\<Longrightarrow> prio_of h (Suc 0) \\<le> pparent h i;\n        1 < i; i \\<le> length h; valid h (Suc 0);\n        parent i \\<noteq> Suc 0\\<rbrakk>\n       \\<Longrightarrow> pparent h i \\<le> prio_of h i", "apply (auto simp: parent_def) [4]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<lbrakk>1 < i; 1 < parent i; parent i \\<le> length h;\n                 valid h (Suc 0)\\<rbrakk>\n                \\<Longrightarrow> prio_of h (Suc 0) \\<le> pparent h i;\n        1 < i; i \\<le> length h; valid h (Suc 0);\n        parent i \\<noteq> Suc 0\\<rbrakk>\n       \\<Longrightarrow> pparent h i \\<le> prio_of h i", "apply (rule heap_parent_le[OF H])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>\\<lbrakk>1 < i; 1 < parent i; parent i \\<le> length h;\n                 valid h (Suc 0)\\<rbrakk>\n                \\<Longrightarrow> prio_of h (Suc 0) \\<le> pparent h i;\n        1 < i; i \\<le> length h; valid h (Suc 0);\n        parent i \\<noteq> Suc 0\\<rbrakk>\n       \\<Longrightarrow> valid h i\n 2. \\<And>i.\n       \\<lbrakk>\\<lbrakk>1 < i; 1 < parent i; parent i \\<le> length h;\n                 valid h (Suc 0)\\<rbrakk>\n                \\<Longrightarrow> prio_of h (Suc 0) \\<le> pparent h i;\n        1 < i; i \\<le> length h; valid h (Suc 0);\n        parent i \\<noteq> Suc 0\\<rbrakk>\n       \\<Longrightarrow> has_parent h i", "apply (auto simp: valid_def parent_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  prio_of h (Suc 0) \\<le> prio_of h i\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open> Obviously, the heap property can also be stated in terms of children,\n      i.e., each node's priority is smaller or equal to it's children's priority.\\<close>"], ["", "definition \"children_ge h p i \\<equiv> \n      (has_left h i \\<longrightarrow> p \\<le> pleft h i)\n    \\<and> (has_right h i \\<longrightarrow> p \\<le> pright h i)\""], ["", "definition \"heap_invar' h \\<equiv> \\<forall>i. valid h i \\<longrightarrow> children_ge h (prio_of h i) i\""], ["", "lemma heap_eq_heap':\n      shows \"heap_invar h \\<longleftrightarrow> heap_invar' h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_invar h = heap_invar' h", "unfolding heap_invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i.\n        valid h i \\<longrightarrow>\n        has_parent h i \\<longrightarrow> pparent h i \\<le> prio_of h i) =\n    heap_invar' h", "unfolding heap_invar'_def children_ge_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i.\n        valid h i \\<longrightarrow>\n        has_parent h i \\<longrightarrow> pparent h i \\<le> prio_of h i) =\n    (\\<forall>i.\n        valid h i \\<longrightarrow>\n        (has_left h i \\<longrightarrow> prio_of h i \\<le> pleft h i) \\<and>\n        (has_right h i \\<longrightarrow> prio_of h i \\<le> pright h i))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>i.\n       valid h i \\<longrightarrow>\n       has_parent h i \\<longrightarrow>\n       pparent h i \\<le> prio_of h i \\<Longrightarrow>\n    \\<forall>i.\n       valid h i \\<longrightarrow>\n       (has_left h i \\<longrightarrow> prio_of h i \\<le> pleft h i) \\<and>\n       (has_right h i \\<longrightarrow> prio_of h i \\<le> pright h i)\n 2. \\<forall>i.\n       valid h i \\<longrightarrow>\n       (has_left h i \\<longrightarrow> prio_of h i \\<le> pleft h i) \\<and>\n       (has_right h i \\<longrightarrow>\n        prio_of h i \\<le> pright h i) \\<Longrightarrow>\n    \\<forall>i.\n       valid h i \\<longrightarrow>\n       has_parent h i \\<longrightarrow> pparent h i \\<le> prio_of h i", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       valid h i \\<longrightarrow>\n       (has_left h i \\<longrightarrow> prio_of h i \\<le> pleft h i) \\<and>\n       (has_right h i \\<longrightarrow>\n        prio_of h i \\<le> pright h i) \\<Longrightarrow>\n    \\<forall>i.\n       valid h i \\<longrightarrow>\n       has_parent h i \\<longrightarrow> pparent h i \\<le> prio_of h i", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>i.\n                   valid h i \\<longrightarrow>\n                   (has_left h i \\<longrightarrow>\n                    prio_of h i \\<le> pleft h i) \\<and>\n                   (has_right h i \\<longrightarrow>\n                    prio_of h i \\<le> pright h i);\n        valid h i; has_parent h i\\<rbrakk>\n       \\<Longrightarrow> pparent h i \\<le> prio_of h i", "apply (frule child_of_parentD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>i.\n                   valid h i \\<longrightarrow>\n                   (has_left h i \\<longrightarrow>\n                    prio_of h i \\<le> pleft h i) \\<and>\n                   (has_right h i \\<longrightarrow>\n                    prio_of h i \\<le> pright h i);\n        valid h i; has_parent h i;\n        left (parent i) = i \\<or> right (parent i) = i\\<rbrakk>\n       \\<Longrightarrow> pparent h i \\<le> prio_of h i", "apply auto []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Basic Operations\\<close>"], ["", "text \\<open>The basic operations are the only operations that directly \n      modify the underlying data structure.\\<close>"], ["", "subsubsection \\<open>Val-Of\\<close>"], ["", "abbreviation (input) \"val_of_pre l i \\<equiv> valid l i\""], ["", "definition val_of_op :: \"'a heap \\<Rightarrow> nat \\<Rightarrow> 'a nres\" \n      where \"val_of_op l i \\<equiv> ASSERT (i>0) \\<then> mop_list_get l (i-1)\""], ["", "lemma val_of_correct[refine_vcg]: \n      \"val_of_pre l i \\<Longrightarrow> val_of_op l i \\<le> SPEC (\\<lambda>r. r = val_of l i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid l i \\<Longrightarrow>\n    val_of_op l i \\<le> SPEC (\\<lambda>r. r = val_of l i)", "unfolding val_of_op_def val_of_def valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < i \\<and> i \\<le> length l \\<Longrightarrow>\n    ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_get l (i - 1))\n    \\<le> SPEC (\\<lambda>r. r = l ! (i - 1))", "by refine_vcg auto"], ["", "abbreviation (input) \"prio_of_pre \\<equiv> val_of_pre\""], ["", "definition \"prio_of_op l i \\<equiv> do {v \\<leftarrow> val_of_op l i; RETURN (prio v)}\""], ["", "lemma prio_of_op_correct[refine_vcg]: \n      \"prio_of_pre l i \\<Longrightarrow> prio_of_op l i \\<le> SPEC (\\<lambda>r. r = prio_of l i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid l i \\<Longrightarrow>\n    prio_of_op l i \\<le> SPEC (\\<lambda>r. r = prio_of l i)", "unfolding prio_of_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid l i \\<Longrightarrow>\n    val_of_op l i \\<bind> (\\<lambda>v. RETURN (prio v))\n    \\<le> SPEC (\\<lambda>r. r = prio_of l i)", "apply refine_vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>valid l i; x = val_of l i\\<rbrakk>\n       \\<Longrightarrow> prio x = prio_of l i", "by simp"], ["", "subsubsection \\<open>Update\\<close>"], ["", "abbreviation \"update_pre h i v \\<equiv> valid h i\""], ["", "definition update :: \"'a heap \\<Rightarrow> nat \\<Rightarrow> 'a \\<Rightarrow> 'a heap\" \n      where \"update h i v \\<equiv> h[i - 1 := v]\""], ["", "definition update_op :: \"'a heap \\<Rightarrow> nat \\<Rightarrow> 'a \\<Rightarrow> 'a heap nres\" \n      where \"update_op h i v \\<equiv> ASSERT (i>0) \\<then> mop_list_set h (i-1) v\""], ["", "lemma update_correct[refine_vcg]:\n      \"update_pre h i v \\<Longrightarrow> update_op h i v \\<le> SPEC(\\<lambda>r. r = update h i v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid h i \\<Longrightarrow>\n    update_op h i v \\<le> SPEC (\\<lambda>r. r = update h i v)", "unfolding update_op_def update_def valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < i \\<and> i \\<le> length h \\<Longrightarrow>\n    ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_set h (i - 1) v)\n    \\<le> SPEC (\\<lambda>r. r = h[i - 1 := v])", "by refine_vcg auto"], ["", "lemma update_valid[simp]: \"valid (update h i v) j \\<longleftrightarrow> valid h j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (update h i v) j = valid h j", "by (auto simp: update_def valid_def)"], ["", "lemma val_of_update[simp]: \"\\<lbrakk>update_pre h i v; valid h j\\<rbrakk> \\<Longrightarrow> val_of (update h i v) j = (\n      if i=j then v else val_of h j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid h i; valid h j\\<rbrakk>\n    \\<Longrightarrow> val_of (update h i v) j =\n                      (if i = j then v else val_of h j)", "unfolding update_def val_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid h i; valid h j\\<rbrakk>\n    \\<Longrightarrow> h[i - 1 := v] ! (j - 1) =\n                      (if i = j then v else h ! (j - 1))", "by (auto simp: nth_list_update valid_def)"], ["", "lemma length_update[simp]: \"length (update l i v) = length l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (update l i v) = length l", "by (auto simp: update_def)"], ["", "subsubsection \\<open>Exchange\\<close>"], ["", "text \\<open> Exchange two elements \\<close>"], ["", "definition exch :: \"'a heap \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 'a heap\" where\n      \"exch l i j \\<equiv> swap l (i - 1) (j - 1)\""], ["", "abbreviation \"exch_pre l i j \\<equiv> valid l i \\<and> valid l j\""], ["", "definition exch_op :: \"'a list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 'a list nres\"\n    where \"exch_op l i j \\<equiv> do { \n      ASSERT (i>0 \\<and> j>0);\n      l \\<leftarrow> mop_list_swap l (i - 1) (j - 1);\n      RETURN l\n    }\""], ["", "lemma exch_op_alt: \"exch_op l i j = do { \n      vi \\<leftarrow> val_of_op l i;\n      vj \\<leftarrow> val_of_op l j;\n      l \\<leftarrow> update_op l i vj;\n      l \\<leftarrow> update_op l j vi;\n      RETURN l }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exch_op l i j =\n    val_of_op l i \\<bind>\n    (\\<lambda>vi.\n        val_of_op l j \\<bind>\n        (\\<lambda>vj.\n            update_op l i vj \\<bind>\n            (\\<lambda>l. update_op l j vi \\<bind> RETURN)))", "by (auto simp: exch_op_def swap_def val_of_op_def update_op_def \n        pw_eq_iff refine_pw_simps)"], ["", "lemma exch_op_correct[refine_vcg]: \n      \"exch_pre l i j \\<Longrightarrow> exch_op l i j \\<le> SPEC (\\<lambda>r. r = exch l i j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exch_pre l i j \\<Longrightarrow>\n    exch_op l i j \\<le> SPEC (\\<lambda>r. r = exch l i j)", "unfolding exch_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. exch_pre l i j \\<Longrightarrow>\n    ASSERT (0 < i \\<and> 0 < j) \\<bind>\n    (\\<lambda>_. mop_list_swap l (i - 1) (j - 1) \\<bind> RETURN)\n    \\<le> SPEC (\\<lambda>r. r = exch l i j)", "apply refine_vcg"], ["proof (prove)\ngoal (5 subgoals):\n 1. exch_pre l i j \\<Longrightarrow> 0 < i\n 2. exch_pre l i j \\<Longrightarrow> 0 < j\n 3. \\<lbrakk>exch_pre l i j; 0 < i \\<and> 0 < j\\<rbrakk>\n    \\<Longrightarrow> i - 1 < length l\n 4. \\<lbrakk>exch_pre l i j; 0 < i \\<and> 0 < j\\<rbrakk>\n    \\<Longrightarrow> j - 1 < length l\n 5. \\<lbrakk>exch_pre l i j; 0 < i \\<and> 0 < j\\<rbrakk>\n    \\<Longrightarrow> swap l (i - 1) (j - 1) = exch l i j", "apply (auto simp: exch_def valid_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma valid_exch[simp]: \"valid (exch l i j) k = valid l k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (exch l i j) k = valid l k", "unfolding exch_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (swap l (i - 1) (j - 1)) k = valid l k", "by (auto simp: valid_def)"], ["", "lemma val_of_exch[simp]: \"\\<lbrakk>valid l i; valid l j; valid l k\\<rbrakk> \\<Longrightarrow> \n      val_of (exch l i j) k = (\n        if k=i then val_of l j\n        else if k=j then val_of l i\n        else val_of l k\n      )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid l i; valid l j; valid l k\\<rbrakk>\n    \\<Longrightarrow> val_of (exch l i j) k =\n                      (if k = i then val_of l j\n                       else if k = j then val_of l i else val_of l k)", "unfolding exch_def val_of_def valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < i \\<and> i \\<le> length l; 0 < j \\<and> j \\<le> length l;\n     0 < k \\<and> k \\<le> length l\\<rbrakk>\n    \\<Longrightarrow> swap l (i - 1) (j - 1) ! (k - 1) =\n                      (if k = i then l ! (j - 1)\n                       else if k = j then l ! (i - 1) else l ! (k - 1))", "by (auto)"], ["", "lemma exch_eq[simp]: \"exch h i i = h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exch h i i = h", "by (auto simp: exch_def)"], ["", "lemma \\<alpha>_exch[simp]: \"\\<lbrakk>valid l i; valid l j\\<rbrakk> \n      \\<Longrightarrow> \\<alpha> (exch l i j) = \\<alpha> l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid l i; valid l j\\<rbrakk>\n    \\<Longrightarrow> \\<alpha> (exch l i j) = \\<alpha> l", "unfolding exch_def valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < i \\<and> i \\<le> length l;\n     0 < j \\<and> j \\<le> length l\\<rbrakk>\n    \\<Longrightarrow> \\<alpha> (swap l (i - 1) (j - 1)) = \\<alpha> l", "by (auto)"], ["", "lemma length_exch[simp]: \"length (exch l i j) = length l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (exch l i j) = length l", "by (auto simp: exch_def)"], ["", "subsubsection \\<open>Butlast\\<close>"], ["", "text \\<open>Remove last element\\<close>"], ["", "abbreviation \"butlast_pre l \\<equiv> l\\<noteq>[]\""], ["", "definition butlast_op :: \"'a heap \\<Rightarrow> 'a heap nres\"\n      where \"butlast_op l \\<equiv> mop_list_butlast l\""], ["", "lemma butlast_op_correct[refine_vcg]: \n      \"butlast_pre l \\<Longrightarrow> butlast_op l \\<le> SPEC (\\<lambda>r. r = butlast l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    butlast_op l \\<le> SPEC (\\<lambda>r. r = butlast l)", "unfolding butlast_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    mop_list_butlast l \\<le> SPEC (\\<lambda>r. r = butlast l)", "by (refine_vcg; auto)"], ["", "lemma valid_butlast_conv[simp]: \"valid (butlast h) i \\<longleftrightarrow> valid h i \\<and> i < length h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (butlast h) i = (valid h i \\<and> i < length h)", "by (auto simp: valid_def)"], ["", "lemma valid_butlast: \"valid (butlast h) i \\<Longrightarrow> valid h i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (butlast h) i \\<Longrightarrow> valid h i", "by (cases h rule: rev_cases) (auto simp: valid_def)"], ["", "lemma val_of_butlast[simp]: \"\\<lbrakk>valid h i; i<length h\\<rbrakk> \n      \\<Longrightarrow> val_of (butlast h) i = val_of h i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid h i; i < length h\\<rbrakk>\n    \\<Longrightarrow> val_of (butlast h) i = val_of h i", "by (auto simp: valid_def val_of_def nth_butlast)"], ["", "lemma val_of_butlast'[simp]: \n      \"valid (butlast h) i \\<Longrightarrow> val_of (butlast h) i = val_of h i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (butlast h) i \\<Longrightarrow> val_of (butlast h) i = val_of h i", "by (cases h rule: rev_cases) (auto simp: valid_def val_of_def nth_append)"], ["", "lemma \\<alpha>_butlast[simp]: \"\\<lbrakk> length h \\<noteq> 0 \\<rbrakk> \n      \\<Longrightarrow> \\<alpha> (butlast h) = \\<alpha> h - {# val_of h (length h)#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length h \\<noteq> 0 \\<Longrightarrow>\n    \\<alpha> (butlast h) = \\<alpha> h - {#val_of h (length h)#}", "apply (cases h rule: rev_cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>length h \\<noteq> 0; h = []\\<rbrakk>\n    \\<Longrightarrow> \\<alpha> (butlast h) =\n                      \\<alpha> h - {#val_of h (length h)#}\n 2. \\<And>ys y.\n       \\<lbrakk>length h \\<noteq> 0; h = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (butlast h) =\n                         \\<alpha> h - {#val_of h (length h)#}", "apply (auto simp: val_of_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma heap_invar_butlast[simp]: \"heap_invar h \\<Longrightarrow> heap_invar (butlast h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_invar h \\<Longrightarrow> heap_invar (butlast h)", "apply (cases \"h = []\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>heap_invar h; h = []\\<rbrakk>\n    \\<Longrightarrow> heap_invar (butlast h)\n 2. \\<lbrakk>heap_invar h; h \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> heap_invar (butlast h)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heap_invar h; h \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> heap_invar (butlast h)", "apply (auto simp: heap_invar_def dest: valid_butlast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Append\\<close>"], ["", "definition append_op :: \"'a heap \\<Rightarrow> 'a \\<Rightarrow> 'a heap nres\"\n      where \"append_op l v \\<equiv> mop_list_append l v\""], ["", "lemma append_op_correct[refine_vcg]: \n      \"append_op l v \\<le> SPEC (\\<lambda>r. r = l@[v])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. append_op l v \\<le> SPEC (\\<lambda>r. r = l @ [v])", "unfolding append_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mop_list_append l v \\<le> SPEC (\\<lambda>r. r = l @ [v])", "by (refine_vcg; auto)"], ["", "lemma valid_append[simp]: \"valid (l@[v]) i \\<longleftrightarrow> valid l i \\<or> i = length l + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (l @ [v]) i = (valid l i \\<or> i = length l + 1)", "by (auto simp: valid_def)"], ["", "lemma val_of_append[simp]: \"valid (l@[v]) i \\<Longrightarrow> \n      val_of (l@[v]) i = (if valid l i then val_of l i else v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (l @ [v]) i \\<Longrightarrow>\n    val_of (l @ [v]) i = (if valid l i then val_of l i else v)", "unfolding valid_def val_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < i \\<and> i \\<le> length (l @ [v]) \\<Longrightarrow>\n    (l @ [v]) ! (i - 1) =\n    (if 0 < i \\<and> i \\<le> length l then l ! (i - 1) else v)", "by (auto simp: nth_append)"], ["", "lemma \\<alpha>_append[simp]: \"\\<alpha> (l@[v]) = \\<alpha> l + {#v#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (l @ [v]) = \\<alpha> l + {#v#}", "by (auto simp: )"], ["", "subsection \\<open>Auxiliary operations\\<close>"], ["", "text \\<open>The auxiliary operations do not have a corresponding abstract operation, but\n      are to restore the heap property after modification.\\<close>"], ["", "subsubsection \\<open>Swim\\<close>"], ["", "text \\<open>This invariant expresses that the heap has a single defect,\n      which can be repaired by swimming up\\<close>"], ["", "definition swim_invar :: \"'a heap \\<Rightarrow> nat \\<Rightarrow> bool\"\n      where \"swim_invar h i \\<equiv> \n        valid h i\n      \\<and> (\\<forall>j. valid h j \\<and> has_parent h j \\<and> j\\<noteq>i \\<longrightarrow> pparent h j \\<le> prio_of h j)\n      \\<and> (has_parent h i \\<longrightarrow> \n        (\\<forall>j. valid h j \\<and> has_parent h j \\<and> parent j = i \n          \\<longrightarrow> pparent h i \\<le> prio_of h j))\""], ["", "text \\<open>Move up an element that is too small, until it fits\\<close>"], ["", "definition swim_op :: \"'a heap \\<Rightarrow> nat \\<Rightarrow> 'a heap nres\" where\n      \"swim_op h i \\<equiv> do {\n        RECT (\\<lambda>swim (h,i). do {\n          ASSERT (valid h i \\<and> swim_invar h i);\n          if has_parent h i then do {\n            ppi \\<leftarrow> prio_of_op h (parent i);\n            pi \\<leftarrow> prio_of_op h i;\n            if (\\<not>ppi \\<le> pi) then do {\n              h \\<leftarrow> exch_op h i (parent i);\n              swim (h, parent i)\n            } else\n              RETURN h\n          } else \n            RETURN h\n        }) (h,i)\n      }\""], ["", "lemma swim_invar_valid: \"swim_invar h i \\<Longrightarrow> valid h i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swim_invar h i \\<Longrightarrow> valid h i", "unfolding swim_invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid h i \\<and>\n    (\\<forall>j.\n        valid h j \\<and>\n        has_parent h j \\<and> j \\<noteq> i \\<longrightarrow>\n        pparent h j \\<le> prio_of h j) \\<and>\n    (has_parent h i \\<longrightarrow>\n     (\\<forall>j.\n         valid h j \\<and>\n         has_parent h j \\<and> parent j = i \\<longrightarrow>\n         pparent h i \\<le> prio_of h j)) \\<Longrightarrow>\n    valid h i", "by simp"], ["", "lemma swim_invar_exit1: \"\\<not>has_parent h i \\<Longrightarrow> swim_invar h i \\<Longrightarrow> heap_invar h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> has_parent h i; swim_invar h i\\<rbrakk>\n    \\<Longrightarrow> heap_invar h", "unfolding heap_invar_def swim_invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> has_parent h i;\n     valid h i \\<and>\n     (\\<forall>j.\n         valid h j \\<and>\n         has_parent h j \\<and> j \\<noteq> i \\<longrightarrow>\n         pparent h j \\<le> prio_of h j) \\<and>\n     (has_parent h i \\<longrightarrow>\n      (\\<forall>j.\n          valid h j \\<and>\n          has_parent h j \\<and> parent j = i \\<longrightarrow>\n          pparent h i \\<le> prio_of h j))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i.\n                         valid h i \\<longrightarrow>\n                         has_parent h i \\<longrightarrow>\n                         pparent h i \\<le> prio_of h i", "by auto"], ["", "lemma swim_invar_exit2: \"pparent h i \\<le> prio_of h i \\<Longrightarrow> swim_invar h i \\<Longrightarrow> heap_invar h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pparent h i \\<le> prio_of h i; swim_invar h i\\<rbrakk>\n    \\<Longrightarrow> heap_invar h", "unfolding heap_invar_def swim_invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pparent h i \\<le> prio_of h i;\n     valid h i \\<and>\n     (\\<forall>j.\n         valid h j \\<and>\n         has_parent h j \\<and> j \\<noteq> i \\<longrightarrow>\n         pparent h j \\<le> prio_of h j) \\<and>\n     (has_parent h i \\<longrightarrow>\n      (\\<forall>j.\n          valid h j \\<and>\n          has_parent h j \\<and> parent j = i \\<longrightarrow>\n          pparent h i \\<le> prio_of h j))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i.\n                         valid h i \\<longrightarrow>\n                         has_parent h i \\<longrightarrow>\n                         pparent h i \\<le> prio_of h i", "by auto"], ["", "lemma swim_invar_pres:\n      assumes HPI: \"has_parent h i\" \n      assumes VIOLATED: \"pparent h i > prio_of h i\" \n      and INV: \"swim_invar h i\"\n      defines \"h' \\<equiv> exch h i (parent i)\"\n      shows \"swim_invar h' (parent i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swim_invar h' (parent i)", "unfolding swim_invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. has_parent h' i \\<and>\n    (\\<forall>j.\n        valid h' j \\<and>\n        has_parent h' j \\<and> j \\<noteq> parent i \\<longrightarrow>\n        pparent h' j \\<le> prio_of h' j) \\<and>\n    (has_parent h' (parent i) \\<longrightarrow>\n     (\\<forall>j.\n         valid h' j \\<and>\n         has_parent h' j \\<and> parent j = parent i \\<longrightarrow>\n         pparent h' (parent i) \\<le> prio_of h' j))", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. has_parent h' i\n 2. \\<And>j.\n       \\<lbrakk>valid h' j; has_parent h' j; j \\<noteq> parent i\\<rbrakk>\n       \\<Longrightarrow> pparent h' j \\<le> prio_of h' j\n 3. \\<And>j.\n       \\<lbrakk>has_parent h' (parent i); valid h' j; has_parent h' j;\n        parent j = parent i\\<rbrakk>\n       \\<Longrightarrow> pparent h' (parent i) \\<le> prio_of h' j", "apply (simp add: h'_def HPI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>valid h' j; has_parent h' j; j \\<noteq> parent i\\<rbrakk>\n       \\<Longrightarrow> pparent h' j \\<le> prio_of h' j\n 2. \\<And>j.\n       \\<lbrakk>has_parent h' (parent i); valid h' j; has_parent h' j;\n        parent j = parent i\\<rbrakk>\n       \\<Longrightarrow> pparent h' (parent i) \\<le> prio_of h' j", "using HPI VIOLATED INV"], ["proof (prove)\nusing this:\n  has_parent h i\n  prio_of h i < pparent h i\n  swim_invar h i\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>valid h' j; has_parent h' j; j \\<noteq> parent i\\<rbrakk>\n       \\<Longrightarrow> pparent h' j \\<le> prio_of h' j\n 2. \\<And>j.\n       \\<lbrakk>has_parent h' (parent i); valid h' j; has_parent h' j;\n        parent j = parent i\\<rbrakk>\n       \\<Longrightarrow> pparent h' (parent i) \\<le> prio_of h' j", "unfolding swim_invar_def h'_def"], ["proof (prove)\nusing this:\n  has_parent h i\n  prio_of h i < pparent h i\n  valid h i \\<and>\n  (\\<forall>j.\n      valid h j \\<and> has_parent h j \\<and> j \\<noteq> i \\<longrightarrow>\n      pparent h j \\<le> prio_of h j) \\<and>\n  (has_parent h i \\<longrightarrow>\n   (\\<forall>j.\n       valid h j \\<and> has_parent h j \\<and> parent j = i \\<longrightarrow>\n       pparent h i \\<le> prio_of h j))\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>valid (exch h i (parent i)) j;\n        has_parent (exch h i (parent i)) j; j \\<noteq> parent i\\<rbrakk>\n       \\<Longrightarrow> pparent (exch h i (parent i)) j\n                         \\<le> prio_of (exch h i (parent i)) j\n 2. \\<And>j.\n       \\<lbrakk>has_parent (exch h i (parent i)) (parent i);\n        valid (exch h i (parent i)) j; has_parent (exch h i (parent i)) j;\n        parent j = parent i\\<rbrakk>\n       \\<Longrightarrow> pparent (exch h i (parent i)) (parent i)\n                         \\<le> prio_of (exch h i (parent i)) j", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>has_parent (exch h i (parent i)) (parent i);\n        valid (exch h i (parent i)) j; has_parent (exch h i (parent i)) j;\n        parent j = parent i\\<rbrakk>\n       \\<Longrightarrow> pparent (exch h i (parent i)) (parent i)\n                         \\<le> prio_of (exch h i (parent i)) j", "using HPI VIOLATED INV"], ["proof (prove)\nusing this:\n  has_parent h i\n  prio_of h i < pparent h i\n  swim_invar h i\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>has_parent (exch h i (parent i)) (parent i);\n        valid (exch h i (parent i)) j; has_parent (exch h i (parent i)) j;\n        parent j = parent i\\<rbrakk>\n       \\<Longrightarrow> pparent (exch h i (parent i)) (parent i)\n                         \\<le> prio_of (exch h i (parent i)) j", "unfolding swim_invar_def h'_def"], ["proof (prove)\nusing this:\n  has_parent h i\n  prio_of h i < pparent h i\n  valid h i \\<and>\n  (\\<forall>j.\n      valid h j \\<and> has_parent h j \\<and> j \\<noteq> i \\<longrightarrow>\n      pparent h j \\<le> prio_of h j) \\<and>\n  (has_parent h i \\<longrightarrow>\n   (\\<forall>j.\n       valid h j \\<and> has_parent h j \\<and> parent j = i \\<longrightarrow>\n       pparent h i \\<le> prio_of h j))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>has_parent (exch h i (parent i)) (parent i);\n        valid (exch h i (parent i)) j; has_parent (exch h i (parent i)) j;\n        parent j = parent i\\<rbrakk>\n       \\<Longrightarrow> pparent (exch h i (parent i)) (parent i)\n                         \\<le> prio_of (exch h i (parent i)) j", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>has_parent h (parent i); valid h j; parent j = parent i;\n        has_parent h i; prio_of h i < pparent h i; valid h i;\n        \\<forall>j.\n           valid h j \\<and>\n           has_parent h j \\<and> j \\<noteq> i \\<longrightarrow>\n           pparent h j \\<le> prio_of h j;\n        \\<forall>j.\n           valid h j \\<and>\n           has_parent h j \\<and> parent j = i \\<longrightarrow>\n           pparent h i \\<le> prio_of h j;\n        parent (parent i) \\<noteq> parent i; parent (parent i) \\<noteq> i;\n        j \\<noteq> parent i; j \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> pparent h (parent i) \\<le> prio_of h j", "by (metis order_trans)"], ["", "lemma swim_invar_decr:\n      assumes INV: \"heap_invar h\"\n      assumes V: \"valid h i\"\n      assumes DECR: \"prio v \\<le> prio_of h i\"\n      shows \"swim_invar (update h i v) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swim_invar (update h i v) i", "using INV V DECR"], ["proof (prove)\nusing this:\n  heap_invar h\n  valid h i\n  prio v \\<le> prio_of h i\n\ngoal (1 subgoal):\n 1. swim_invar (update h i v) i", "apply (auto simp: swim_invar_def heap_invar_def intro: dual_order.trans)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma swim_op_correct[refine_vcg]: \n    \"\\<lbrakk>swim_invar h i\\<rbrakk> \\<Longrightarrow>\n      swim_op h i \\<le> SPEC (\\<lambda>h'. \\<alpha> h' = \\<alpha> h \\<and> heap_invar h' \\<and> length h' = length h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swim_invar h i \\<Longrightarrow>\n    swim_op h i\n    \\<le> SPEC\n           (\\<lambda>h'.\n               \\<alpha> h' = \\<alpha> h \\<and>\n               heap_invar h' \\<and> length h' = length h)", "unfolding swim_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. swim_invar h i \\<Longrightarrow>\n    REC\\<^sub>T\n     (\\<lambda>swim (h, i).\n         ASSERT (valid h i \\<and> swim_invar h i) \\<bind>\n         (\\<lambda>_.\n             if has_parent h i\n             then prio_of_op h (parent i) \\<bind>\n                  (\\<lambda>ppi.\n                      prio_of_op h i \\<bind>\n                      (\\<lambda>pi.\n                          if \\<not> ppi \\<le> pi\n                          then exch_op h i (parent i) \\<bind>\n                               (\\<lambda>h. swim (h, parent i))\n                          else RETURN h))\n             else RETURN h))\n     (h, i)\n    \\<le> SPEC\n           (\\<lambda>h'.\n               \\<alpha> h' = \\<alpha> h \\<and>\n               heap_invar h' \\<and> length h' = length h)", "using [[goals_limit = 1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. swim_invar h i \\<Longrightarrow>\n    REC\\<^sub>T\n     (\\<lambda>swim (h, i).\n         ASSERT (valid h i \\<and> swim_invar h i) \\<bind>\n         (\\<lambda>_.\n             if has_parent h i\n             then prio_of_op h (parent i) \\<bind>\n                  (\\<lambda>ppi.\n                      prio_of_op h i \\<bind>\n                      (\\<lambda>pi.\n                          if \\<not> ppi \\<le> pi\n                          then exch_op h i (parent i) \\<bind>\n                               (\\<lambda>h. swim (h, parent i))\n                          else RETURN h))\n             else RETURN h))\n     (h, i)\n    \\<le> SPEC\n           (\\<lambda>h'.\n               \\<alpha> h' = \\<alpha> h \\<and>\n               heap_invar h' \\<and> length h' = length h)", "apply (refine_vcg  RECT_rule[where \n          pre=\"\\<lambda>(hh,i). \n            swim_invar hh i \n          \\<and> \\<alpha> hh = \\<alpha> h \n          \\<and> length hh = length h\" and\n          V = \"inv_image less_than snd\"\n          ])"], ["proof (prove)\ngoal (15 subgoals):\n 1. swim_invar h i \\<Longrightarrow> wf (inv_image less_than snd)\nA total of 15 subgoals...", "apply (auto) []"], ["proof (prove)\ngoal (14 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>swim_invar h i; (h, i) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> swim_invar x1 x2\nA total of 14 subgoals...", "apply (auto) []"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>swim_invar h i; (h, i) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> x1 = \\<alpha> h\nA total of 13 subgoals...", "apply (auto) []"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>swim_invar h i; (h, i) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> length x1 = length h\nA total of 12 subgoals...", "apply (auto) []"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>f x a b.\n       \\<lbrakk>swim_invar h i;\n        \\<And>x'.\n           \\<lbrakk>case x' of\n                    (hh, i) \\<Rightarrow>\n                      swim_invar hh i \\<and>\n                      \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n            (x', x) \\<in> inv_image less_than snd\\<rbrakk>\n           \\<Longrightarrow> f x'\n                             \\<le> SPEC\n                                    (\\<lambda>h'.\n  \\<alpha> h' = \\<alpha> h \\<and>\n  heap_invar h' \\<and> length h' = length h);\n        case x of\n        (hh, i) \\<Rightarrow>\n          swim_invar hh i \\<and>\n          \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n        REC\\<^sub>T\n         (\\<lambda>swim a.\n             case a of\n             (h, i) \\<Rightarrow>\n               ASSERT (valid h i \\<and> swim_invar h i) \\<bind>\n               (\\<lambda>_.\n                   if has_parent h i\n                   then prio_of_op h (parent i) \\<bind>\n                        (\\<lambda>ppi.\n                            prio_of_op h i \\<bind>\n                            (\\<lambda>pi.\n                                if \\<not> ppi \\<le> pi\n                                then exch_op h i (parent i) \\<bind>\n                                     (\\<lambda>h. swim (h, parent i))\n                                else RETURN h))\n                   else RETURN h)) =\n        f;\n        x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> valid a b\nA total of 11 subgoals...", "apply (auto simp: swim_invar_valid) []"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>f x a b.\n       \\<lbrakk>swim_invar h i;\n        \\<And>x'.\n           \\<lbrakk>case x' of\n                    (hh, i) \\<Rightarrow>\n                      swim_invar hh i \\<and>\n                      \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n            (x', x) \\<in> inv_image less_than snd\\<rbrakk>\n           \\<Longrightarrow> f x'\n                             \\<le> SPEC\n                                    (\\<lambda>h'.\n  \\<alpha> h' = \\<alpha> h \\<and>\n  heap_invar h' \\<and> length h' = length h);\n        case x of\n        (hh, i) \\<Rightarrow>\n          swim_invar hh i \\<and>\n          \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n        REC\\<^sub>T\n         (\\<lambda>swim a.\n             case a of\n             (h, i) \\<Rightarrow>\n               ASSERT (valid h i \\<and> swim_invar h i) \\<bind>\n               (\\<lambda>_.\n                   if has_parent h i\n                   then prio_of_op h (parent i) \\<bind>\n                        (\\<lambda>ppi.\n                            prio_of_op h i \\<bind>\n                            (\\<lambda>pi.\n                                if \\<not> ppi \\<le> pi\n                                then exch_op h i (parent i) \\<bind>\n                                     (\\<lambda>h. swim (h, parent i))\n                                else RETURN h))\n                   else RETURN h)) =\n        f;\n        x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> swim_invar a b\nA total of 10 subgoals...", "apply (auto) []"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>f x a b xa.\n       \\<lbrakk>swim_invar h i;\n        \\<And>x'.\n           \\<lbrakk>case x' of\n                    (hh, i) \\<Rightarrow>\n                      swim_invar hh i \\<and>\n                      \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n            (x', x) \\<in> inv_image less_than snd\\<rbrakk>\n           \\<Longrightarrow> f x'\n                             \\<le> SPEC\n                                    (\\<lambda>h'.\n  \\<alpha> h' = \\<alpha> h \\<and>\n  heap_invar h' \\<and> length h' = length h);\n        case x of\n        (hh, i) \\<Rightarrow>\n          swim_invar hh i \\<and>\n          \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n        REC\\<^sub>T\n         (\\<lambda>swim a.\n             case a of\n             (h, i) \\<Rightarrow>\n               ASSERT (valid h i \\<and> swim_invar h i) \\<bind>\n               (\\<lambda>_.\n                   if has_parent h i\n                   then prio_of_op h (parent i) \\<bind>\n                        (\\<lambda>ppi.\n                            prio_of_op h i \\<bind>\n                            (\\<lambda>pi.\n                                if \\<not> ppi \\<le> pi\n                                then exch_op h i (parent i) \\<bind>\n                                     (\\<lambda>h. swim (h, parent i))\n                                else RETURN h))\n                   else RETURN h)) =\n        f;\n        x = (a, b); valid a b \\<and> swim_invar a b; has_parent a b;\n        xa = pparent a b\\<rbrakk>\n       \\<Longrightarrow> valid a b\nA total of 9 subgoals...", "apply (auto) []"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>f x a b xa xb.\n       \\<lbrakk>swim_invar h i;\n        \\<And>x'.\n           \\<lbrakk>case x' of\n                    (hh, i) \\<Rightarrow>\n                      swim_invar hh i \\<and>\n                      \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n            (x', x) \\<in> inv_image less_than snd\\<rbrakk>\n           \\<Longrightarrow> f x'\n                             \\<le> SPEC\n                                    (\\<lambda>h'.\n  \\<alpha> h' = \\<alpha> h \\<and>\n  heap_invar h' \\<and> length h' = length h);\n        case x of\n        (hh, i) \\<Rightarrow>\n          swim_invar hh i \\<and>\n          \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n        REC\\<^sub>T\n         (\\<lambda>swim a.\n             case a of\n             (h, i) \\<Rightarrow>\n               ASSERT (valid h i \\<and> swim_invar h i) \\<bind>\n               (\\<lambda>_.\n                   if has_parent h i\n                   then prio_of_op h (parent i) \\<bind>\n                        (\\<lambda>ppi.\n                            prio_of_op h i \\<bind>\n                            (\\<lambda>pi.\n                                if \\<not> ppi \\<le> pi\n                                then exch_op h i (parent i) \\<bind>\n                                     (\\<lambda>h. swim (h, parent i))\n                                else RETURN h))\n                   else RETURN h)) =\n        f;\n        x = (a, b); valid a b \\<and> swim_invar a b; has_parent a b;\n        xa = pparent a b; xb = prio_of a b; \\<not> xa \\<le> xb\\<rbrakk>\n       \\<Longrightarrow> valid a b\nA total of 8 subgoals...", "apply (auto) []"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>f x a b xa xb xc.\n       \\<lbrakk>swim_invar h i;\n        \\<And>x'.\n           \\<lbrakk>case x' of\n                    (hh, i) \\<Rightarrow>\n                      swim_invar hh i \\<and>\n                      \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n            (x', x) \\<in> inv_image less_than snd\\<rbrakk>\n           \\<Longrightarrow> f x'\n                             \\<le> SPEC\n                                    (\\<lambda>h'.\n  \\<alpha> h' = \\<alpha> h \\<and>\n  heap_invar h' \\<and> length h' = length h);\n        case x of\n        (hh, i) \\<Rightarrow>\n          swim_invar hh i \\<and>\n          \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n        REC\\<^sub>T\n         (\\<lambda>swim a.\n             case a of\n             (h, i) \\<Rightarrow>\n               ASSERT (valid h i \\<and> swim_invar h i) \\<bind>\n               (\\<lambda>_.\n                   if has_parent h i\n                   then prio_of_op h (parent i) \\<bind>\n                        (\\<lambda>ppi.\n                            prio_of_op h i \\<bind>\n                            (\\<lambda>pi.\n                                if \\<not> ppi \\<le> pi\n                                then exch_op h i (parent i) \\<bind>\n                                     (\\<lambda>h. swim (h, parent i))\n                                else RETURN h))\n                   else RETURN h)) =\n        f;\n        x = (a, b); valid a b \\<and> swim_invar a b; has_parent a b;\n        xa = pparent a b; xb = prio_of a b; \\<not> xa \\<le> xb;\n        xc = exch a b (parent b)\\<rbrakk>\n       \\<Longrightarrow> f (xc, parent b)\n                         \\<le> SPEC\n                                (\\<lambda>h'.\n                                    \\<alpha> h' = \\<alpha> h \\<and>\n                                    heap_invar h' \\<and>\n                                    length h' = length h)\nA total of 7 subgoals...", "apply rprems"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>f x a b xa xb xc.\n       \\<lbrakk>swim_invar h i;\n        case x of\n        (hh, i) \\<Rightarrow>\n          swim_invar hh i \\<and>\n          \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n        REC\\<^sub>T\n         (\\<lambda>swim a.\n             case a of\n             (h, i) \\<Rightarrow>\n               ASSERT (valid h i \\<and> swim_invar h i) \\<bind>\n               (\\<lambda>_.\n                   if has_parent h i\n                   then prio_of_op h (parent i) \\<bind>\n                        (\\<lambda>ppi.\n                            prio_of_op h i \\<bind>\n                            (\\<lambda>pi.\n                                if \\<not> ppi \\<le> pi\n                                then exch_op h i (parent i) \\<bind>\n                                     (\\<lambda>h. swim (h, parent i))\n                                else RETURN h))\n                   else RETURN h)) =\n        f;\n        x = (a, b); valid a b \\<and> swim_invar a b; has_parent a b;\n        xa = pparent a b; xb = prio_of a b; \\<not> xa \\<le> xb;\n        xc = exch a b (parent b)\\<rbrakk>\n       \\<Longrightarrow> case (xc, parent b) of\n                         (hh, i) \\<Rightarrow>\n                           swim_invar hh i \\<and>\n                           \\<alpha> hh = \\<alpha> h \\<and>\n                           length hh = length h\nA total of 8 subgoals...", "apply (auto simp: swim_invar_pres) []"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>f x a b xa xb xc.\n       \\<lbrakk>swim_invar h i;\n        case x of\n        (hh, i) \\<Rightarrow>\n          swim_invar hh i \\<and>\n          \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n        REC\\<^sub>T\n         (\\<lambda>swim a.\n             case a of\n             (h, i) \\<Rightarrow>\n               ASSERT (valid h i \\<and> swim_invar h i) \\<bind>\n               (\\<lambda>_.\n                   if has_parent h i\n                   then prio_of_op h (parent i) \\<bind>\n                        (\\<lambda>ppi.\n                            prio_of_op h i \\<bind>\n                            (\\<lambda>pi.\n                                if \\<not> ppi \\<le> pi\n                                then exch_op h i (parent i) \\<bind>\n                                     (\\<lambda>h. swim (h, parent i))\n                                else RETURN h))\n                   else RETURN h)) =\n        f;\n        x = (a, b); valid a b \\<and> swim_invar a b; has_parent a b;\n        xa = pparent a b; xb = prio_of a b; \\<not> xa \\<le> xb;\n        xc = exch a b (parent b)\\<rbrakk>\n       \\<Longrightarrow> ((xc, parent b), x) \\<in> inv_image less_than snd\nA total of 7 subgoals...", "apply (auto simp: parent_def valid_def) []"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>f x a b xa xb.\n       \\<lbrakk>swim_invar h i;\n        \\<And>x'.\n           \\<lbrakk>case x' of\n                    (hh, i) \\<Rightarrow>\n                      swim_invar hh i \\<and>\n                      \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n            (x', x) \\<in> inv_image less_than snd\\<rbrakk>\n           \\<Longrightarrow> f x'\n                             \\<le> SPEC\n                                    (\\<lambda>h'.\n  \\<alpha> h' = \\<alpha> h \\<and>\n  heap_invar h' \\<and> length h' = length h);\n        case x of\n        (hh, i) \\<Rightarrow>\n          swim_invar hh i \\<and>\n          \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n        REC\\<^sub>T\n         (\\<lambda>swim a.\n             case a of\n             (h, i) \\<Rightarrow>\n               ASSERT (valid h i \\<and> swim_invar h i) \\<bind>\n               (\\<lambda>_.\n                   if has_parent h i\n                   then prio_of_op h (parent i) \\<bind>\n                        (\\<lambda>ppi.\n                            prio_of_op h i \\<bind>\n                            (\\<lambda>pi.\n                                if \\<not> ppi \\<le> pi\n                                then exch_op h i (parent i) \\<bind>\n                                     (\\<lambda>h. swim (h, parent i))\n                                else RETURN h))\n                   else RETURN h)) =\n        f;\n        x = (a, b); valid a b \\<and> swim_invar a b; has_parent a b;\n        xa = pparent a b; xb = prio_of a b;\n        \\<not> \\<not> xa \\<le> xb\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> a = \\<alpha> h\nA total of 6 subgoals...", "apply (auto) []"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>f x a b xa xb.\n       \\<lbrakk>swim_invar h i;\n        \\<And>x'.\n           \\<lbrakk>case x' of\n                    (hh, i) \\<Rightarrow>\n                      swim_invar hh i \\<and>\n                      \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n            (x', x) \\<in> inv_image less_than snd\\<rbrakk>\n           \\<Longrightarrow> f x'\n                             \\<le> SPEC\n                                    (\\<lambda>h'.\n  \\<alpha> h' = \\<alpha> h \\<and>\n  heap_invar h' \\<and> length h' = length h);\n        case x of\n        (hh, i) \\<Rightarrow>\n          swim_invar hh i \\<and>\n          \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n        REC\\<^sub>T\n         (\\<lambda>swim a.\n             case a of\n             (h, i) \\<Rightarrow>\n               ASSERT (valid h i \\<and> swim_invar h i) \\<bind>\n               (\\<lambda>_.\n                   if has_parent h i\n                   then prio_of_op h (parent i) \\<bind>\n                        (\\<lambda>ppi.\n                            prio_of_op h i \\<bind>\n                            (\\<lambda>pi.\n                                if \\<not> ppi \\<le> pi\n                                then exch_op h i (parent i) \\<bind>\n                                     (\\<lambda>h. swim (h, parent i))\n                                else RETURN h))\n                   else RETURN h)) =\n        f;\n        x = (a, b); valid a b \\<and> swim_invar a b; has_parent a b;\n        xa = pparent a b; xb = prio_of a b;\n        \\<not> \\<not> xa \\<le> xb\\<rbrakk>\n       \\<Longrightarrow> heap_invar a\nA total of 5 subgoals...", "apply (auto simp: swim_invar_exit2) []"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>f x a b xa xb.\n       \\<lbrakk>swim_invar h i;\n        \\<And>x'.\n           \\<lbrakk>case x' of\n                    (hh, i) \\<Rightarrow>\n                      swim_invar hh i \\<and>\n                      \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n            (x', x) \\<in> inv_image less_than snd\\<rbrakk>\n           \\<Longrightarrow> f x'\n                             \\<le> SPEC\n                                    (\\<lambda>h'.\n  \\<alpha> h' = \\<alpha> h \\<and>\n  heap_invar h' \\<and> length h' = length h);\n        case x of\n        (hh, i) \\<Rightarrow>\n          swim_invar hh i \\<and>\n          \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n        REC\\<^sub>T\n         (\\<lambda>swim a.\n             case a of\n             (h, i) \\<Rightarrow>\n               ASSERT (valid h i \\<and> swim_invar h i) \\<bind>\n               (\\<lambda>_.\n                   if has_parent h i\n                   then prio_of_op h (parent i) \\<bind>\n                        (\\<lambda>ppi.\n                            prio_of_op h i \\<bind>\n                            (\\<lambda>pi.\n                                if \\<not> ppi \\<le> pi\n                                then exch_op h i (parent i) \\<bind>\n                                     (\\<lambda>h. swim (h, parent i))\n                                else RETURN h))\n                   else RETURN h)) =\n        f;\n        x = (a, b); valid a b \\<and> swim_invar a b; has_parent a b;\n        xa = pparent a b; xb = prio_of a b;\n        \\<not> \\<not> xa \\<le> xb\\<rbrakk>\n       \\<Longrightarrow> length a = length h\nA total of 4 subgoals...", "apply (auto) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>f x a b.\n       \\<lbrakk>swim_invar h i;\n        \\<And>x'.\n           \\<lbrakk>case x' of\n                    (hh, i) \\<Rightarrow>\n                      swim_invar hh i \\<and>\n                      \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n            (x', x) \\<in> inv_image less_than snd\\<rbrakk>\n           \\<Longrightarrow> f x'\n                             \\<le> SPEC\n                                    (\\<lambda>h'.\n  \\<alpha> h' = \\<alpha> h \\<and>\n  heap_invar h' \\<and> length h' = length h);\n        case x of\n        (hh, i) \\<Rightarrow>\n          swim_invar hh i \\<and>\n          \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n        REC\\<^sub>T\n         (\\<lambda>swim a.\n             case a of\n             (h, i) \\<Rightarrow>\n               ASSERT (valid h i \\<and> swim_invar h i) \\<bind>\n               (\\<lambda>_.\n                   if has_parent h i\n                   then prio_of_op h (parent i) \\<bind>\n                        (\\<lambda>ppi.\n                            prio_of_op h i \\<bind>\n                            (\\<lambda>pi.\n                                if \\<not> ppi \\<le> pi\n                                then exch_op h i (parent i) \\<bind>\n                                     (\\<lambda>h. swim (h, parent i))\n                                else RETURN h))\n                   else RETURN h)) =\n        f;\n        x = (a, b); valid a b \\<and> swim_invar a b;\n        \\<not> has_parent a b\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> a = \\<alpha> h\nA total of 3 subgoals...", "apply (auto) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f x a b.\n       \\<lbrakk>swim_invar h i;\n        \\<And>x'.\n           \\<lbrakk>case x' of\n                    (hh, i) \\<Rightarrow>\n                      swim_invar hh i \\<and>\n                      \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n            (x', x) \\<in> inv_image less_than snd\\<rbrakk>\n           \\<Longrightarrow> f x'\n                             \\<le> SPEC\n                                    (\\<lambda>h'.\n  \\<alpha> h' = \\<alpha> h \\<and>\n  heap_invar h' \\<and> length h' = length h);\n        case x of\n        (hh, i) \\<Rightarrow>\n          swim_invar hh i \\<and>\n          \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n        REC\\<^sub>T\n         (\\<lambda>swim a.\n             case a of\n             (h, i) \\<Rightarrow>\n               ASSERT (valid h i \\<and> swim_invar h i) \\<bind>\n               (\\<lambda>_.\n                   if has_parent h i\n                   then prio_of_op h (parent i) \\<bind>\n                        (\\<lambda>ppi.\n                            prio_of_op h i \\<bind>\n                            (\\<lambda>pi.\n                                if \\<not> ppi \\<le> pi\n                                then exch_op h i (parent i) \\<bind>\n                                     (\\<lambda>h. swim (h, parent i))\n                                else RETURN h))\n                   else RETURN h)) =\n        f;\n        x = (a, b); valid a b \\<and> swim_invar a b;\n        \\<not> has_parent a b\\<rbrakk>\n       \\<Longrightarrow> heap_invar a\nA total of 2 subgoals...", "apply (auto simp: swim_invar_exit1) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f x a b.\n       \\<lbrakk>swim_invar h i;\n        \\<And>x'.\n           \\<lbrakk>case x' of\n                    (hh, i) \\<Rightarrow>\n                      swim_invar hh i \\<and>\n                      \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n            (x', x) \\<in> inv_image less_than snd\\<rbrakk>\n           \\<Longrightarrow> f x'\n                             \\<le> SPEC\n                                    (\\<lambda>h'.\n  \\<alpha> h' = \\<alpha> h \\<and>\n  heap_invar h' \\<and> length h' = length h);\n        case x of\n        (hh, i) \\<Rightarrow>\n          swim_invar hh i \\<and>\n          \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n        REC\\<^sub>T\n         (\\<lambda>swim a.\n             case a of\n             (h, i) \\<Rightarrow>\n               ASSERT (valid h i \\<and> swim_invar h i) \\<bind>\n               (\\<lambda>_.\n                   if has_parent h i\n                   then prio_of_op h (parent i) \\<bind>\n                        (\\<lambda>ppi.\n                            prio_of_op h i \\<bind>\n                            (\\<lambda>pi.\n                                if \\<not> ppi \\<le> pi\n                                then exch_op h i (parent i) \\<bind>\n                                     (\\<lambda>h. swim (h, parent i))\n                                else RETURN h))\n                   else RETURN h)) =\n        f;\n        x = (a, b); valid a b \\<and> swim_invar a b;\n        \\<not> has_parent a b\\<rbrakk>\n       \\<Longrightarrow> length a = length h", "apply (auto) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Sink\\<close>"], ["", "text \\<open>Move down an element that is too big, until it fits in\\<close>"], ["", "definition sink_op :: \"'a heap \\<Rightarrow> nat \\<Rightarrow> 'a heap nres\" where\n      \"sink_op h i \\<equiv> do {\n        RECT (\\<lambda>sink (h,i). do {\n          ASSERT (valid h i);\n          if has_right h i then do {\n            ASSERT (has_left h i);\n            lp \\<leftarrow> prio_of_op h (left i);\n            rp \\<leftarrow> prio_of_op h (right i);\n            p \\<leftarrow> prio_of_op h i;\n            if (lp < p \\<and> rp \\<ge> lp) then do {\n              h \\<leftarrow> exch_op h i (left i);\n              sink (h,left i)\n            } else if (rp<lp \\<and> rp < p) then do {\n              h \\<leftarrow> exch_op h i (right i);\n              sink (h,right i)\n            } else \n              RETURN h\n          } else if (has_left h i) then do {\n            lp \\<leftarrow> prio_of_op h (left i);\n            p \\<leftarrow> prio_of_op h i;\n            if (lp < p) then do {\n              h \\<leftarrow> exch_op h i (left i);\n              sink (h,left i)\n            } else\n              RETURN h\n            \n          } else \n            RETURN h\n        }) (h,i)\n      }\""], ["", "text \\<open>This invariant expresses that the heap has a single defect, \n      which can be repaired by sinking\\<close>"], ["", "definition \"sink_invar l i \\<equiv> \n      valid l i\n    \\<and> (\\<forall>j. valid l j \\<and> j\\<noteq>i \\<longrightarrow> children_ge l (prio_of l j) j)\n    \\<and> (has_parent l i \\<longrightarrow> children_ge l (pparent l i) i)\""], ["", "lemma sink_invar_valid: \"sink_invar l i \\<Longrightarrow> valid l i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sink_invar l i \\<Longrightarrow> valid l i", "unfolding sink_invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid l i \\<and>\n    (\\<forall>j.\n        valid l j \\<and> j \\<noteq> i \\<longrightarrow>\n        children_ge l (prio_of l j) j) \\<and>\n    (has_parent l i \\<longrightarrow>\n     children_ge l (pparent l i) i) \\<Longrightarrow>\n    valid l i", "by auto"], ["", "lemma sink_invar_exit: \"\\<lbrakk>sink_invar l i; children_ge l (prio_of l i) i\\<rbrakk> \n      \\<Longrightarrow> heap_invar' l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sink_invar l i; children_ge l (prio_of l i) i\\<rbrakk>\n    \\<Longrightarrow> heap_invar' l", "unfolding heap_invar'_def sink_invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid l i \\<and>\n             (\\<forall>j.\n                 valid l j \\<and> j \\<noteq> i \\<longrightarrow>\n                 children_ge l (prio_of l j) j) \\<and>\n             (has_parent l i \\<longrightarrow>\n              children_ge l (pparent l i) i);\n     children_ge l (prio_of l i) i\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i.\n                         valid l i \\<longrightarrow>\n                         children_ge l (prio_of l i) i", "by auto"], ["", "lemma sink_aux1: \"\\<not> (2*i \\<le> length h) \\<Longrightarrow> \\<not>has_left h i \\<and> \\<not>has_right h i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> 2 * i \\<le> length h \\<Longrightarrow>\n    \\<not> has_left h i \\<and> \\<not> has_right h i", "unfolding valid_def left_def right_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> 2 * i \\<le> length h \\<Longrightarrow>\n    \\<not> (0 < 2 * i \\<and> 2 * i \\<le> length h) \\<and>\n    \\<not> (0 < 2 * i + 1 \\<and> 2 * i + 1 \\<le> length h)", "by auto"], ["", "lemma sink_invar_pres1:\n      assumes \"sink_invar h i\"\n      assumes \"has_left h i\" \"has_right h i\"\n      assumes \"prio_of h i \\<ge> pleft h i\"\n      assumes \"pleft h i \\<ge> pright h i\"\n      shows \"sink_invar (exch h i (right i)) (right i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sink_invar (exch h i (right i)) (right i)", "using assms"], ["proof (prove)\nusing this:\n  sink_invar h i\n  has_left h i\n  has_right h i\n  pleft h i \\<le> prio_of h i\n  pright h i \\<le> pleft h i\n\ngoal (1 subgoal):\n 1. sink_invar (exch h i (right i)) (right i)", "unfolding sink_invar_def"], ["proof (prove)\nusing this:\n  valid h i \\<and>\n  (\\<forall>j.\n      valid h j \\<and> j \\<noteq> i \\<longrightarrow>\n      children_ge h (prio_of h j) j) \\<and>\n  (has_parent h i \\<longrightarrow> children_ge h (pparent h i) i)\n  has_left h i\n  has_right h i\n  pleft h i \\<le> prio_of h i\n  pright h i \\<le> pleft h i\n\ngoal (1 subgoal):\n 1. has_right (exch h i (right i)) i \\<and>\n    (\\<forall>j.\n        valid (exch h i (right i)) j \\<and>\n        j \\<noteq> right i \\<longrightarrow>\n        children_ge (exch h i (right i)) (prio_of (exch h i (right i)) j)\n         j) \\<and>\n    (has_parent (exch h i (right i)) (right i) \\<longrightarrow>\n     children_ge (exch h i (right i))\n      (pparent (exch h i (right i)) (right i)) (right i))", "apply auto"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>has_left h i; has_right h i; pleft h i \\<le> prio_of h i;\n     pright h i \\<le> pleft h i; valid h i;\n     \\<forall>j.\n        valid h j \\<and> j \\<noteq> i \\<longrightarrow>\n        children_ge h (prio_of h j) j;\n     \\<not> has_parent h i; i \\<noteq> right i\\<rbrakk>\n    \\<Longrightarrow> children_ge (exch h i (right i)) (pright h i) i\n 2. \\<And>j.\n       \\<lbrakk>has_left h i; has_right h i; pleft h i \\<le> prio_of h i;\n        pright h i \\<le> pleft h i; valid h i;\n        \\<forall>j.\n           valid h j \\<and> j \\<noteq> i \\<longrightarrow>\n           children_ge h (prio_of h j) j;\n        \\<not> has_parent h i; j \\<noteq> i; valid h j;\n        j \\<noteq> right i\\<rbrakk>\n       \\<Longrightarrow> children_ge (exch h i (right i)) (prio_of h j) j\n 3. \\<lbrakk>has_left h i; has_right h i; pleft h i \\<le> prio_of h i;\n     pright h i \\<le> pleft h i; valid h i;\n     \\<forall>j.\n        valid h j \\<and> j \\<noteq> i \\<longrightarrow>\n        children_ge h (prio_of h j) j;\n     \\<not> has_parent h i\\<rbrakk>\n    \\<Longrightarrow> children_ge (exch h i (right i)) (pright h i)\n                       (right i)\n 4. \\<lbrakk>has_left h i; has_right h i; pleft h i \\<le> prio_of h i;\n     pright h i \\<le> pleft h i; valid h i;\n     \\<forall>j.\n        valid h j \\<and> j \\<noteq> i \\<longrightarrow>\n        children_ge h (prio_of h j) j;\n     children_ge h (pparent h i) i; i \\<noteq> right i\\<rbrakk>\n    \\<Longrightarrow> children_ge (exch h i (right i)) (pright h i) i\n 5. \\<And>j.\n       \\<lbrakk>has_left h i; has_right h i; pleft h i \\<le> prio_of h i;\n        pright h i \\<le> pleft h i; valid h i;\n        \\<forall>j.\n           valid h j \\<and> j \\<noteq> i \\<longrightarrow>\n           children_ge h (prio_of h j) j;\n        children_ge h (pparent h i) i; j \\<noteq> i; valid h j;\n        j \\<noteq> right i\\<rbrakk>\n       \\<Longrightarrow> children_ge (exch h i (right i)) (prio_of h j) j\n 6. \\<lbrakk>has_left h i; has_right h i; pleft h i \\<le> prio_of h i;\n     pright h i \\<le> pleft h i; valid h i;\n     \\<forall>j.\n        valid h j \\<and> j \\<noteq> i \\<longrightarrow>\n        children_ge h (prio_of h j) j;\n     children_ge h (pparent h i) i\\<rbrakk>\n    \\<Longrightarrow> children_ge (exch h i (right i)) (pright h i)\n                       (right i)", "apply (auto simp: children_ge_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sink_invar_pres2:\n      assumes \"sink_invar h i\"\n      assumes \"has_left h i\" \"has_right h i\"\n      assumes \"prio_of h i \\<ge> pleft h i\"\n      assumes \"pleft h i \\<le> pright h i\"\n      shows \"sink_invar (exch h i (left i)) (left i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sink_invar (exch h i (left i)) (left i)", "using assms"], ["proof (prove)\nusing this:\n  sink_invar h i\n  has_left h i\n  has_right h i\n  pleft h i \\<le> prio_of h i\n  pleft h i \\<le> pright h i\n\ngoal (1 subgoal):\n 1. sink_invar (exch h i (left i)) (left i)", "unfolding sink_invar_def"], ["proof (prove)\nusing this:\n  valid h i \\<and>\n  (\\<forall>j.\n      valid h j \\<and> j \\<noteq> i \\<longrightarrow>\n      children_ge h (prio_of h j) j) \\<and>\n  (has_parent h i \\<longrightarrow> children_ge h (pparent h i) i)\n  has_left h i\n  has_right h i\n  pleft h i \\<le> prio_of h i\n  pleft h i \\<le> pright h i\n\ngoal (1 subgoal):\n 1. has_left (exch h i (left i)) i \\<and>\n    (\\<forall>j.\n        valid (exch h i (left i)) j \\<and>\n        j \\<noteq> left i \\<longrightarrow>\n        children_ge (exch h i (left i)) (prio_of (exch h i (left i)) j)\n         j) \\<and>\n    (has_parent (exch h i (left i)) (left i) \\<longrightarrow>\n     children_ge (exch h i (left i)) (pparent (exch h i (left i)) (left i))\n      (left i))", "apply auto"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>has_left h i; has_right h i; pleft h i \\<le> prio_of h i;\n     pleft h i \\<le> pright h i; valid h i;\n     \\<forall>j.\n        valid h j \\<and> j \\<noteq> i \\<longrightarrow>\n        children_ge h (prio_of h j) j;\n     \\<not> has_parent h i; i \\<noteq> left i\\<rbrakk>\n    \\<Longrightarrow> children_ge (exch h i (left i)) (pleft h i) i\n 2. \\<And>j.\n       \\<lbrakk>has_left h i; has_right h i; pleft h i \\<le> prio_of h i;\n        pleft h i \\<le> pright h i; valid h i;\n        \\<forall>j.\n           valid h j \\<and> j \\<noteq> i \\<longrightarrow>\n           children_ge h (prio_of h j) j;\n        \\<not> has_parent h i; j \\<noteq> i; valid h j;\n        j \\<noteq> left i\\<rbrakk>\n       \\<Longrightarrow> children_ge (exch h i (left i)) (prio_of h j) j\n 3. \\<lbrakk>has_left h i; has_right h i; pleft h i \\<le> prio_of h i;\n     pleft h i \\<le> pright h i; valid h i;\n     \\<forall>j.\n        valid h j \\<and> j \\<noteq> i \\<longrightarrow>\n        children_ge h (prio_of h j) j;\n     \\<not> has_parent h i\\<rbrakk>\n    \\<Longrightarrow> children_ge (exch h i (left i)) (pleft h i) (left i)\n 4. \\<lbrakk>has_left h i; has_right h i; pleft h i \\<le> prio_of h i;\n     pleft h i \\<le> pright h i; valid h i;\n     \\<forall>j.\n        valid h j \\<and> j \\<noteq> i \\<longrightarrow>\n        children_ge h (prio_of h j) j;\n     children_ge h (pparent h i) i; i \\<noteq> left i\\<rbrakk>\n    \\<Longrightarrow> children_ge (exch h i (left i)) (pleft h i) i\n 5. \\<And>j.\n       \\<lbrakk>has_left h i; has_right h i; pleft h i \\<le> prio_of h i;\n        pleft h i \\<le> pright h i; valid h i;\n        \\<forall>j.\n           valid h j \\<and> j \\<noteq> i \\<longrightarrow>\n           children_ge h (prio_of h j) j;\n        children_ge h (pparent h i) i; j \\<noteq> i; valid h j;\n        j \\<noteq> left i\\<rbrakk>\n       \\<Longrightarrow> children_ge (exch h i (left i)) (prio_of h j) j\n 6. \\<lbrakk>has_left h i; has_right h i; pleft h i \\<le> prio_of h i;\n     pleft h i \\<le> pright h i; valid h i;\n     \\<forall>j.\n        valid h j \\<and> j \\<noteq> i \\<longrightarrow>\n        children_ge h (prio_of h j) j;\n     children_ge h (pparent h i) i\\<rbrakk>\n    \\<Longrightarrow> children_ge (exch h i (left i)) (pleft h i) (left i)", "apply (auto simp: children_ge_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sink_invar_pres3:\n      assumes \"sink_invar h i\"\n      assumes \"has_left h i\" \"has_right h i\"\n      assumes \"prio_of h i \\<ge> pright h i\"\n      assumes \"pleft h i \\<le> pright h i\"\n      shows \"sink_invar (exch h i (left i)) (left i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sink_invar (exch h i (left i)) (left i)", "using assms"], ["proof (prove)\nusing this:\n  sink_invar h i\n  has_left h i\n  has_right h i\n  pright h i \\<le> prio_of h i\n  pleft h i \\<le> pright h i\n\ngoal (1 subgoal):\n 1. sink_invar (exch h i (left i)) (left i)", "unfolding sink_invar_def"], ["proof (prove)\nusing this:\n  valid h i \\<and>\n  (\\<forall>j.\n      valid h j \\<and> j \\<noteq> i \\<longrightarrow>\n      children_ge h (prio_of h j) j) \\<and>\n  (has_parent h i \\<longrightarrow> children_ge h (pparent h i) i)\n  has_left h i\n  has_right h i\n  pright h i \\<le> prio_of h i\n  pleft h i \\<le> pright h i\n\ngoal (1 subgoal):\n 1. has_left (exch h i (left i)) i \\<and>\n    (\\<forall>j.\n        valid (exch h i (left i)) j \\<and>\n        j \\<noteq> left i \\<longrightarrow>\n        children_ge (exch h i (left i)) (prio_of (exch h i (left i)) j)\n         j) \\<and>\n    (has_parent (exch h i (left i)) (left i) \\<longrightarrow>\n     children_ge (exch h i (left i)) (pparent (exch h i (left i)) (left i))\n      (left i))", "apply auto"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>has_left h i; has_right h i; pright h i \\<le> prio_of h i;\n     pleft h i \\<le> pright h i; valid h i;\n     \\<forall>j.\n        valid h j \\<and> j \\<noteq> i \\<longrightarrow>\n        children_ge h (prio_of h j) j;\n     \\<not> has_parent h i; i \\<noteq> left i\\<rbrakk>\n    \\<Longrightarrow> children_ge (exch h i (left i)) (pleft h i) i\n 2. \\<And>j.\n       \\<lbrakk>has_left h i; has_right h i; pright h i \\<le> prio_of h i;\n        pleft h i \\<le> pright h i; valid h i;\n        \\<forall>j.\n           valid h j \\<and> j \\<noteq> i \\<longrightarrow>\n           children_ge h (prio_of h j) j;\n        \\<not> has_parent h i; j \\<noteq> i; valid h j;\n        j \\<noteq> left i\\<rbrakk>\n       \\<Longrightarrow> children_ge (exch h i (left i)) (prio_of h j) j\n 3. \\<lbrakk>has_left h i; has_right h i; pright h i \\<le> prio_of h i;\n     pleft h i \\<le> pright h i; valid h i;\n     \\<forall>j.\n        valid h j \\<and> j \\<noteq> i \\<longrightarrow>\n        children_ge h (prio_of h j) j;\n     \\<not> has_parent h i\\<rbrakk>\n    \\<Longrightarrow> children_ge (exch h i (left i)) (pleft h i) (left i)\n 4. \\<lbrakk>has_left h i; has_right h i; pright h i \\<le> prio_of h i;\n     pleft h i \\<le> pright h i; valid h i;\n     \\<forall>j.\n        valid h j \\<and> j \\<noteq> i \\<longrightarrow>\n        children_ge h (prio_of h j) j;\n     children_ge h (pparent h i) i; i \\<noteq> left i\\<rbrakk>\n    \\<Longrightarrow> children_ge (exch h i (left i)) (pleft h i) i\n 5. \\<And>j.\n       \\<lbrakk>has_left h i; has_right h i; pright h i \\<le> prio_of h i;\n        pleft h i \\<le> pright h i; valid h i;\n        \\<forall>j.\n           valid h j \\<and> j \\<noteq> i \\<longrightarrow>\n           children_ge h (prio_of h j) j;\n        children_ge h (pparent h i) i; j \\<noteq> i; valid h j;\n        j \\<noteq> left i\\<rbrakk>\n       \\<Longrightarrow> children_ge (exch h i (left i)) (prio_of h j) j\n 6. \\<lbrakk>has_left h i; has_right h i; pright h i \\<le> prio_of h i;\n     pleft h i \\<le> pright h i; valid h i;\n     \\<forall>j.\n        valid h j \\<and> j \\<noteq> i \\<longrightarrow>\n        children_ge h (prio_of h j) j;\n     children_ge h (pparent h i) i\\<rbrakk>\n    \\<Longrightarrow> children_ge (exch h i (left i)) (pleft h i) (left i)", "apply (auto simp: children_ge_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sink_invar_pres4:\n      assumes \"sink_invar h i\"\n      assumes \"has_left h i\" \"has_right h i\"\n      assumes \"prio_of h i \\<ge> pright h i\"\n      assumes \"pleft h i \\<ge> pright h i\"\n      shows \"sink_invar (exch h i (right i)) (right i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sink_invar (exch h i (right i)) (right i)", "using assms"], ["proof (prove)\nusing this:\n  sink_invar h i\n  has_left h i\n  has_right h i\n  pright h i \\<le> prio_of h i\n  pright h i \\<le> pleft h i\n\ngoal (1 subgoal):\n 1. sink_invar (exch h i (right i)) (right i)", "unfolding sink_invar_def"], ["proof (prove)\nusing this:\n  valid h i \\<and>\n  (\\<forall>j.\n      valid h j \\<and> j \\<noteq> i \\<longrightarrow>\n      children_ge h (prio_of h j) j) \\<and>\n  (has_parent h i \\<longrightarrow> children_ge h (pparent h i) i)\n  has_left h i\n  has_right h i\n  pright h i \\<le> prio_of h i\n  pright h i \\<le> pleft h i\n\ngoal (1 subgoal):\n 1. has_right (exch h i (right i)) i \\<and>\n    (\\<forall>j.\n        valid (exch h i (right i)) j \\<and>\n        j \\<noteq> right i \\<longrightarrow>\n        children_ge (exch h i (right i)) (prio_of (exch h i (right i)) j)\n         j) \\<and>\n    (has_parent (exch h i (right i)) (right i) \\<longrightarrow>\n     children_ge (exch h i (right i))\n      (pparent (exch h i (right i)) (right i)) (right i))", "apply auto"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>has_left h i; has_right h i; pright h i \\<le> prio_of h i;\n     pright h i \\<le> pleft h i; valid h i;\n     \\<forall>j.\n        valid h j \\<and> j \\<noteq> i \\<longrightarrow>\n        children_ge h (prio_of h j) j;\n     \\<not> has_parent h i; i \\<noteq> right i\\<rbrakk>\n    \\<Longrightarrow> children_ge (exch h i (right i)) (pright h i) i\n 2. \\<And>j.\n       \\<lbrakk>has_left h i; has_right h i; pright h i \\<le> prio_of h i;\n        pright h i \\<le> pleft h i; valid h i;\n        \\<forall>j.\n           valid h j \\<and> j \\<noteq> i \\<longrightarrow>\n           children_ge h (prio_of h j) j;\n        \\<not> has_parent h i; j \\<noteq> i; valid h j;\n        j \\<noteq> right i\\<rbrakk>\n       \\<Longrightarrow> children_ge (exch h i (right i)) (prio_of h j) j\n 3. \\<lbrakk>has_left h i; has_right h i; pright h i \\<le> prio_of h i;\n     pright h i \\<le> pleft h i; valid h i;\n     \\<forall>j.\n        valid h j \\<and> j \\<noteq> i \\<longrightarrow>\n        children_ge h (prio_of h j) j;\n     \\<not> has_parent h i\\<rbrakk>\n    \\<Longrightarrow> children_ge (exch h i (right i)) (pright h i)\n                       (right i)\n 4. \\<lbrakk>has_left h i; has_right h i; pright h i \\<le> prio_of h i;\n     pright h i \\<le> pleft h i; valid h i;\n     \\<forall>j.\n        valid h j \\<and> j \\<noteq> i \\<longrightarrow>\n        children_ge h (prio_of h j) j;\n     children_ge h (pparent h i) i; i \\<noteq> right i\\<rbrakk>\n    \\<Longrightarrow> children_ge (exch h i (right i)) (pright h i) i\n 5. \\<And>j.\n       \\<lbrakk>has_left h i; has_right h i; pright h i \\<le> prio_of h i;\n        pright h i \\<le> pleft h i; valid h i;\n        \\<forall>j.\n           valid h j \\<and> j \\<noteq> i \\<longrightarrow>\n           children_ge h (prio_of h j) j;\n        children_ge h (pparent h i) i; j \\<noteq> i; valid h j;\n        j \\<noteq> right i\\<rbrakk>\n       \\<Longrightarrow> children_ge (exch h i (right i)) (prio_of h j) j\n 6. \\<lbrakk>has_left h i; has_right h i; pright h i \\<le> prio_of h i;\n     pright h i \\<le> pleft h i; valid h i;\n     \\<forall>j.\n        valid h j \\<and> j \\<noteq> i \\<longrightarrow>\n        children_ge h (prio_of h j) j;\n     children_ge h (pparent h i) i\\<rbrakk>\n    \\<Longrightarrow> children_ge (exch h i (right i)) (pright h i)\n                       (right i)", "apply (auto simp: children_ge_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sink_invar_pres5:\n      assumes \"sink_invar h i\"\n      assumes \"has_left h i\" \"\\<not>has_right h i\"\n      assumes \"prio_of h i \\<ge> pleft h i\"\n      shows \"sink_invar (exch h i (left i)) (left i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sink_invar (exch h i (left i)) (left i)", "using assms"], ["proof (prove)\nusing this:\n  sink_invar h i\n  has_left h i\n  \\<not> has_right h i\n  pleft h i \\<le> prio_of h i\n\ngoal (1 subgoal):\n 1. sink_invar (exch h i (left i)) (left i)", "unfolding sink_invar_def"], ["proof (prove)\nusing this:\n  valid h i \\<and>\n  (\\<forall>j.\n      valid h j \\<and> j \\<noteq> i \\<longrightarrow>\n      children_ge h (prio_of h j) j) \\<and>\n  (has_parent h i \\<longrightarrow> children_ge h (pparent h i) i)\n  has_left h i\n  \\<not> has_right h i\n  pleft h i \\<le> prio_of h i\n\ngoal (1 subgoal):\n 1. has_left (exch h i (left i)) i \\<and>\n    (\\<forall>j.\n        valid (exch h i (left i)) j \\<and>\n        j \\<noteq> left i \\<longrightarrow>\n        children_ge (exch h i (left i)) (prio_of (exch h i (left i)) j)\n         j) \\<and>\n    (has_parent (exch h i (left i)) (left i) \\<longrightarrow>\n     children_ge (exch h i (left i)) (pparent (exch h i (left i)) (left i))\n      (left i))", "apply auto"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>has_left h i; \\<not> has_right h i;\n     pleft h i \\<le> prio_of h i; valid h i;\n     \\<forall>j.\n        valid h j \\<and> j \\<noteq> i \\<longrightarrow>\n        children_ge h (prio_of h j) j;\n     \\<not> has_parent h i; i \\<noteq> left i\\<rbrakk>\n    \\<Longrightarrow> children_ge (exch h i (left i)) (pleft h i) i\n 2. \\<And>j.\n       \\<lbrakk>has_left h i; \\<not> has_right h i;\n        pleft h i \\<le> prio_of h i; valid h i;\n        \\<forall>j.\n           valid h j \\<and> j \\<noteq> i \\<longrightarrow>\n           children_ge h (prio_of h j) j;\n        \\<not> has_parent h i; j \\<noteq> i; valid h j;\n        j \\<noteq> left i\\<rbrakk>\n       \\<Longrightarrow> children_ge (exch h i (left i)) (prio_of h j) j\n 3. \\<lbrakk>has_left h i; \\<not> has_right h i;\n     pleft h i \\<le> prio_of h i; valid h i;\n     \\<forall>j.\n        valid h j \\<and> j \\<noteq> i \\<longrightarrow>\n        children_ge h (prio_of h j) j;\n     \\<not> has_parent h i\\<rbrakk>\n    \\<Longrightarrow> children_ge (exch h i (left i)) (pleft h i) (left i)\n 4. \\<lbrakk>has_left h i; \\<not> has_right h i;\n     pleft h i \\<le> prio_of h i; valid h i;\n     \\<forall>j.\n        valid h j \\<and> j \\<noteq> i \\<longrightarrow>\n        children_ge h (prio_of h j) j;\n     children_ge h (pparent h i) i; i \\<noteq> left i\\<rbrakk>\n    \\<Longrightarrow> children_ge (exch h i (left i)) (pleft h i) i\n 5. \\<And>j.\n       \\<lbrakk>has_left h i; \\<not> has_right h i;\n        pleft h i \\<le> prio_of h i; valid h i;\n        \\<forall>j.\n           valid h j \\<and> j \\<noteq> i \\<longrightarrow>\n           children_ge h (prio_of h j) j;\n        children_ge h (pparent h i) i; j \\<noteq> i; valid h j;\n        j \\<noteq> left i\\<rbrakk>\n       \\<Longrightarrow> children_ge (exch h i (left i)) (prio_of h j) j\n 6. \\<lbrakk>has_left h i; \\<not> has_right h i;\n     pleft h i \\<le> prio_of h i; valid h i;\n     \\<forall>j.\n        valid h j \\<and> j \\<noteq> i \\<longrightarrow>\n        children_ge h (prio_of h j) j;\n     children_ge h (pparent h i) i\\<rbrakk>\n    \\<Longrightarrow> children_ge (exch h i (left i)) (pleft h i) (left i)", "apply (auto simp: children_ge_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas sink_invar_pres = \n      sink_invar_pres1 \n      sink_invar_pres2 \n      sink_invar_pres3 \n      sink_invar_pres4 \n      sink_invar_pres5"], ["", "lemma sink_invar_incr:\n      assumes INV: \"heap_invar h\"\n      assumes V: \"valid h i\"\n      assumes INCR: \"prio v \\<ge> prio_of h i\"\n      shows \"sink_invar (update h i v) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sink_invar (update h i v) i", "using INV V INCR"], ["proof (prove)\nusing this:\n  heap_invar h\n  valid h i\n  prio_of h i \\<le> prio v\n\ngoal (1 subgoal):\n 1. sink_invar (update h i v) i", "apply (auto simp: sink_invar_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>heap_invar h; valid h i; prio_of h i \\<le> prio v; 0 < i;\n        valid h j; j \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> children_ge (update h i v) (prio_of h j) j\n 2. \\<lbrakk>heap_invar h; valid h i; prio_of h i \\<le> prio v; 0 < i;\n     has_parent h i\\<rbrakk>\n    \\<Longrightarrow> children_ge (update h i v) (pparent h i) i", "apply (auto simp: children_ge_def heap_invar_def) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heap_invar h; valid h i; prio_of h i \\<le> prio v; 0 < i;\n     has_parent h i\\<rbrakk>\n    \\<Longrightarrow> children_ge (update h i v) (pparent h i) i", "apply (auto simp: children_ge_def heap_invar_def intro: order_trans) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>i.\n                valid h i \\<longrightarrow>\n                has_parent h i \\<longrightarrow>\n                pparent h i \\<le> prio_of h i;\n     valid h i; prio_of h i \\<le> prio v; 0 < i; has_parent h i;\n     has_left h i\\<rbrakk>\n    \\<Longrightarrow> pparent h i \\<le> pleft h i\n 2. \\<lbrakk>\\<forall>i.\n                valid h i \\<longrightarrow>\n                has_parent h i \\<longrightarrow>\n                pparent h i \\<le> prio_of h i;\n     valid h i; prio_of h i \\<le> prio v; 0 < i; has_parent h i;\n     has_right h i\\<rbrakk>\n    \\<Longrightarrow> pparent h i \\<le> pright h i", "apply (frule spec[where x=\"left i\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>i.\n                valid h i \\<longrightarrow>\n                has_parent h i \\<longrightarrow>\n                pparent h i \\<le> prio_of h i;\n     valid h i; prio_of h i \\<le> prio v; 0 < i; has_parent h i;\n     has_left h i;\n     has_left h i \\<longrightarrow>\n     has_parent h (left i) \\<longrightarrow>\n     pparent h (left i) \\<le> pleft h i\\<rbrakk>\n    \\<Longrightarrow> pparent h i \\<le> pleft h i\n 2. \\<lbrakk>\\<forall>i.\n                valid h i \\<longrightarrow>\n                has_parent h i \\<longrightarrow>\n                pparent h i \\<le> prio_of h i;\n     valid h i; prio_of h i \\<le> prio v; 0 < i; has_parent h i;\n     has_right h i\\<rbrakk>\n    \\<Longrightarrow> pparent h i \\<le> pright h i", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i.\n                valid h i \\<longrightarrow>\n                has_parent h i \\<longrightarrow>\n                pparent h i \\<le> prio_of h i;\n     valid h i; prio_of h i \\<le> prio v; 0 < i; has_parent h i;\n     has_right h i\\<rbrakk>\n    \\<Longrightarrow> pparent h i \\<le> pright h i", "apply (frule spec[where x=\"right i\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i.\n                valid h i \\<longrightarrow>\n                has_parent h i \\<longrightarrow>\n                pparent h i \\<le> prio_of h i;\n     valid h i; prio_of h i \\<le> prio v; 0 < i; has_parent h i;\n     has_right h i;\n     has_right h i \\<longrightarrow>\n     has_parent h (right i) \\<longrightarrow>\n     pparent h (right i) \\<le> pright h i\\<rbrakk>\n    \\<Longrightarrow> pparent h i \\<le> pright h i", "apply auto []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sink_op_correct[refine_vcg]: \n    \"\\<lbrakk>sink_invar h i\\<rbrakk> \\<Longrightarrow>\n      sink_op h i \\<le> SPEC (\\<lambda>h'. \\<alpha> h' = \\<alpha> h \\<and> heap_invar h' \\<and> length h' = length h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sink_invar h i \\<Longrightarrow>\n    sink_op h i\n    \\<le> SPEC\n           (\\<lambda>h'.\n               \\<alpha> h' = \\<alpha> h \\<and>\n               heap_invar h' \\<and> length h' = length h)", "unfolding sink_op_def heap_eq_heap'"], ["proof (prove)\ngoal (1 subgoal):\n 1. sink_invar h i \\<Longrightarrow>\n    REC\\<^sub>T\n     (\\<lambda>sink (h, i).\n         ASSERT (valid h i) \\<bind>\n         (\\<lambda>_.\n             if has_right h i\n             then ASSERT (has_left h i) \\<bind>\n                  (\\<lambda>_.\n                      prio_of_op h (left i) \\<bind>\n                      (\\<lambda>lp.\n                          prio_of_op h (right i) \\<bind>\n                          (\\<lambda>rp.\n                              prio_of_op h i \\<bind>\n                              (\\<lambda>p.\n                                  if lp < p \\<and> lp \\<le> rp\n                                  then exch_op h i (left i) \\<bind>\n (\\<lambda>h. sink (h, left i))\n                                  else if rp < lp \\<and> rp < p\n then exch_op h i (right i) \\<bind> (\\<lambda>h. sink (h, right i))\n else RETURN h))))\n             else if has_left h i\n                  then prio_of_op h (left i) \\<bind>\n                       (\\<lambda>lp.\n                           prio_of_op h i \\<bind>\n                           (\\<lambda>p.\n                               if lp < p\n                               then exch_op h i (left i) \\<bind>\n                                    (\\<lambda>h. sink (h, left i))\n                               else RETURN h))\n                  else RETURN h))\n     (h, i)\n    \\<le> SPEC\n           (\\<lambda>h'.\n               \\<alpha> h' = \\<alpha> h \\<and>\n               heap_invar' h' \\<and> length h' = length h)", "using [[goals_limit = 1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. sink_invar h i \\<Longrightarrow>\n    REC\\<^sub>T\n     (\\<lambda>sink (h, i).\n         ASSERT (valid h i) \\<bind>\n         (\\<lambda>_.\n             if has_right h i\n             then ASSERT (has_left h i) \\<bind>\n                  (\\<lambda>_.\n                      prio_of_op h (left i) \\<bind>\n                      (\\<lambda>lp.\n                          prio_of_op h (right i) \\<bind>\n                          (\\<lambda>rp.\n                              prio_of_op h i \\<bind>\n                              (\\<lambda>p.\n                                  if lp < p \\<and> lp \\<le> rp\n                                  then exch_op h i (left i) \\<bind>\n (\\<lambda>h. sink (h, left i))\n                                  else if rp < lp \\<and> rp < p\n then exch_op h i (right i) \\<bind> (\\<lambda>h. sink (h, right i))\n else RETURN h))))\n             else if has_left h i\n                  then prio_of_op h (left i) \\<bind>\n                       (\\<lambda>lp.\n                           prio_of_op h i \\<bind>\n                           (\\<lambda>p.\n                               if lp < p\n                               then exch_op h i (left i) \\<bind>\n                                    (\\<lambda>h. sink (h, left i))\n                               else RETURN h))\n                  else RETURN h))\n     (h, i)\n    \\<le> SPEC\n           (\\<lambda>h'.\n               \\<alpha> h' = \\<alpha> h \\<and>\n               heap_invar' h' \\<and> length h' = length h)", "apply (refine_vcg  RECT_rule[where \n          pre=\"\\<lambda>(hh,i). sink_invar hh i \\<and> \\<alpha> hh = \\<alpha> h \\<and> length hh = length h\" and\n          V = \"measure (\\<lambda>(l,i). length l - i)\"\n          ])"], ["proof (prove)\ngoal (18 subgoals):\n 1. sink_invar h i \\<Longrightarrow>\n    wf (measure (\\<lambda>(l, i). length l - i))\nA total of 18 subgoals...", "apply (auto) []"], ["proof (prove)\ngoal (17 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>sink_invar h i; (h, i) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> sink_invar x1 x2\nA total of 17 subgoals...", "apply (auto) []"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>sink_invar h i; (h, i) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> x1 = \\<alpha> h\nA total of 16 subgoals...", "apply (auto) []"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>sink_invar h i; (h, i) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> length x1 = length h\nA total of 15 subgoals...", "apply (auto) []"], ["proof (prove)\ngoal (14 subgoals):\n 1. \\<And>f x a b.\n       \\<lbrakk>sink_invar h i;\n        \\<And>x'.\n           \\<lbrakk>case x' of\n                    (hh, i) \\<Rightarrow>\n                      sink_invar hh i \\<and>\n                      \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n            (x', x) \\<in> measure (\\<lambda>(l, i). length l - i)\\<rbrakk>\n           \\<Longrightarrow> f x'\n                             \\<le> SPEC\n                                    (\\<lambda>h'.\n  \\<alpha> h' = \\<alpha> h \\<and>\n  heap_invar' h' \\<and> length h' = length h);\n        case x of\n        (hh, i) \\<Rightarrow>\n          sink_invar hh i \\<and>\n          \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n        REC\\<^sub>T\n         (\\<lambda>sink a.\n             case a of\n             (h, i) \\<Rightarrow>\n               ASSERT (valid h i) \\<bind>\n               (\\<lambda>_.\n                   if has_right h i\n                   then ASSERT (has_left h i) \\<bind>\n                        (\\<lambda>_.\n                            prio_of_op h (left i) \\<bind>\n                            (\\<lambda>lp.\n                                prio_of_op h (right i) \\<bind>\n                                (\\<lambda>rp.\n                                    prio_of_op h i \\<bind>\n                                    (\\<lambda>p.\n  if lp < p \\<and> lp \\<le> rp\n  then exch_op h i (left i) \\<bind> (\\<lambda>h. sink (h, left i))\n  else if rp < lp \\<and> rp < p\n       then exch_op h i (right i) \\<bind> (\\<lambda>h. sink (h, right i))\n       else RETURN h))))\n                   else if has_left h i\n                        then prio_of_op h (left i) \\<bind>\n                             (\\<lambda>lp.\n                                 prio_of_op h i \\<bind>\n                                 (\\<lambda>p.\n                                     if lp < p\n                                     then exch_op h i (left i) \\<bind>\n    (\\<lambda>h. sink (h, left i))\n                                     else RETURN h))\n                        else RETURN h)) =\n        f;\n        x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> valid a b\nA total of 14 subgoals...", "apply (auto simp: sink_invar_valid) []"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>f x a b.\n       \\<lbrakk>sink_invar h i;\n        \\<And>x'.\n           \\<lbrakk>case x' of\n                    (hh, i) \\<Rightarrow>\n                      sink_invar hh i \\<and>\n                      \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n            (x', x) \\<in> measure (\\<lambda>(l, i). length l - i)\\<rbrakk>\n           \\<Longrightarrow> f x'\n                             \\<le> SPEC\n                                    (\\<lambda>h'.\n  \\<alpha> h' = \\<alpha> h \\<and>\n  heap_invar' h' \\<and> length h' = length h);\n        case x of\n        (hh, i) \\<Rightarrow>\n          sink_invar hh i \\<and>\n          \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n        REC\\<^sub>T\n         (\\<lambda>sink a.\n             case a of\n             (h, i) \\<Rightarrow>\n               ASSERT (valid h i) \\<bind>\n               (\\<lambda>_.\n                   if has_right h i\n                   then ASSERT (has_left h i) \\<bind>\n                        (\\<lambda>_.\n                            prio_of_op h (left i) \\<bind>\n                            (\\<lambda>lp.\n                                prio_of_op h (right i) \\<bind>\n                                (\\<lambda>rp.\n                                    prio_of_op h i \\<bind>\n                                    (\\<lambda>p.\n  if lp < p \\<and> lp \\<le> rp\n  then exch_op h i (left i) \\<bind> (\\<lambda>h. sink (h, left i))\n  else if rp < lp \\<and> rp < p\n       then exch_op h i (right i) \\<bind> (\\<lambda>h. sink (h, right i))\n       else RETURN h))))\n                   else if has_left h i\n                        then prio_of_op h (left i) \\<bind>\n                             (\\<lambda>lp.\n                                 prio_of_op h i \\<bind>\n                                 (\\<lambda>p.\n                                     if lp < p\n                                     then exch_op h i (left i) \\<bind>\n    (\\<lambda>h. sink (h, left i))\n                                     else RETURN h))\n                        else RETURN h)) =\n        f;\n        x = (a, b); valid a b; has_right a b\\<rbrakk>\n       \\<Longrightarrow> has_left a b\nA total of 13 subgoals...", "apply (auto simp: valid_def left_def right_def) []"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>f x a b xa xb xc xd.\n       \\<lbrakk>sink_invar h i;\n        \\<And>x'.\n           \\<lbrakk>case x' of\n                    (hh, i) \\<Rightarrow>\n                      sink_invar hh i \\<and>\n                      \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n            (x', x) \\<in> measure (\\<lambda>(l, i). length l - i)\\<rbrakk>\n           \\<Longrightarrow> f x'\n                             \\<le> SPEC\n                                    (\\<lambda>h'.\n  \\<alpha> h' = \\<alpha> h \\<and>\n  heap_invar' h' \\<and> length h' = length h);\n        case x of\n        (hh, i) \\<Rightarrow>\n          sink_invar hh i \\<and>\n          \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n        REC\\<^sub>T\n         (\\<lambda>sink a.\n             case a of\n             (h, i) \\<Rightarrow>\n               ASSERT (valid h i) \\<bind>\n               (\\<lambda>_.\n                   if has_right h i\n                   then ASSERT (has_left h i) \\<bind>\n                        (\\<lambda>_.\n                            prio_of_op h (left i) \\<bind>\n                            (\\<lambda>lp.\n                                prio_of_op h (right i) \\<bind>\n                                (\\<lambda>rp.\n                                    prio_of_op h i \\<bind>\n                                    (\\<lambda>p.\n  if lp < p \\<and> lp \\<le> rp\n  then exch_op h i (left i) \\<bind> (\\<lambda>h. sink (h, left i))\n  else if rp < lp \\<and> rp < p\n       then exch_op h i (right i) \\<bind> (\\<lambda>h. sink (h, right i))\n       else RETURN h))))\n                   else if has_left h i\n                        then prio_of_op h (left i) \\<bind>\n                             (\\<lambda>lp.\n                                 prio_of_op h i \\<bind>\n                                 (\\<lambda>p.\n                                     if lp < p\n                                     then exch_op h i (left i) \\<bind>\n    (\\<lambda>h. sink (h, left i))\n                                     else RETURN h))\n                        else RETURN h)) =\n        f;\n        x = (a, b); valid a b; has_right a b; has_left a b; xa = pleft a b;\n        xb = pright a b; xc = prio_of a b; xa < xc \\<and> xa \\<le> xb;\n        xd = exch a b (left b)\\<rbrakk>\n       \\<Longrightarrow> f (xd, left b)\n                         \\<le> SPEC\n                                (\\<lambda>h'.\n                                    \\<alpha> h' = \\<alpha> h \\<and>\n                                    heap_invar' h' \\<and>\n                                    length h' = length h)\nA total of 12 subgoals...", "apply rprems"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>f x a b xa xb xc xd.\n       \\<lbrakk>sink_invar h i;\n        case x of\n        (hh, i) \\<Rightarrow>\n          sink_invar hh i \\<and>\n          \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n        REC\\<^sub>T\n         (\\<lambda>sink a.\n             case a of\n             (h, i) \\<Rightarrow>\n               ASSERT (valid h i) \\<bind>\n               (\\<lambda>_.\n                   if has_right h i\n                   then ASSERT (has_left h i) \\<bind>\n                        (\\<lambda>_.\n                            prio_of_op h (left i) \\<bind>\n                            (\\<lambda>lp.\n                                prio_of_op h (right i) \\<bind>\n                                (\\<lambda>rp.\n                                    prio_of_op h i \\<bind>\n                                    (\\<lambda>p.\n  if lp < p \\<and> lp \\<le> rp\n  then exch_op h i (left i) \\<bind> (\\<lambda>h. sink (h, left i))\n  else if rp < lp \\<and> rp < p\n       then exch_op h i (right i) \\<bind> (\\<lambda>h. sink (h, right i))\n       else RETURN h))))\n                   else if has_left h i\n                        then prio_of_op h (left i) \\<bind>\n                             (\\<lambda>lp.\n                                 prio_of_op h i \\<bind>\n                                 (\\<lambda>p.\n                                     if lp < p\n                                     then exch_op h i (left i) \\<bind>\n    (\\<lambda>h. sink (h, left i))\n                                     else RETURN h))\n                        else RETURN h)) =\n        f;\n        x = (a, b); valid a b; has_right a b; has_left a b; xa = pleft a b;\n        xb = pright a b; xc = prio_of a b; xa < xc \\<and> xa \\<le> xb;\n        xd = exch a b (left b)\\<rbrakk>\n       \\<Longrightarrow> case (xd, left b) of\n                         (hh, i) \\<Rightarrow>\n                           sink_invar hh i \\<and>\n                           \\<alpha> hh = \\<alpha> h \\<and>\n                           length hh = length h\nA total of 13 subgoals...", "apply (auto intro: sink_invar_pres) []"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>f x a b xa xb xc xd.\n       \\<lbrakk>sink_invar h i;\n        case x of\n        (hh, i) \\<Rightarrow>\n          sink_invar hh i \\<and>\n          \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n        REC\\<^sub>T\n         (\\<lambda>sink a.\n             case a of\n             (h, i) \\<Rightarrow>\n               ASSERT (valid h i) \\<bind>\n               (\\<lambda>_.\n                   if has_right h i\n                   then ASSERT (has_left h i) \\<bind>\n                        (\\<lambda>_.\n                            prio_of_op h (left i) \\<bind>\n                            (\\<lambda>lp.\n                                prio_of_op h (right i) \\<bind>\n                                (\\<lambda>rp.\n                                    prio_of_op h i \\<bind>\n                                    (\\<lambda>p.\n  if lp < p \\<and> lp \\<le> rp\n  then exch_op h i (left i) \\<bind> (\\<lambda>h. sink (h, left i))\n  else if rp < lp \\<and> rp < p\n       then exch_op h i (right i) \\<bind> (\\<lambda>h. sink (h, right i))\n       else RETURN h))))\n                   else if has_left h i\n                        then prio_of_op h (left i) \\<bind>\n                             (\\<lambda>lp.\n                                 prio_of_op h i \\<bind>\n                                 (\\<lambda>p.\n                                     if lp < p\n                                     then exch_op h i (left i) \\<bind>\n    (\\<lambda>h. sink (h, left i))\n                                     else RETURN h))\n                        else RETURN h)) =\n        f;\n        x = (a, b); valid a b; has_right a b; has_left a b; xa = pleft a b;\n        xb = pright a b; xc = prio_of a b; xa < xc \\<and> xa \\<le> xb;\n        xd = exch a b (left b)\\<rbrakk>\n       \\<Longrightarrow> ((xd, left b), x)\n                         \\<in> measure (\\<lambda>(l, y). length l - y)\nA total of 12 subgoals...", "apply (auto simp: valid_def left_def right_def) []"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>f x a b xa xb xc xd.\n       \\<lbrakk>sink_invar h i;\n        \\<And>x'.\n           \\<lbrakk>case x' of\n                    (hh, i) \\<Rightarrow>\n                      sink_invar hh i \\<and>\n                      \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n            (x', x) \\<in> measure (\\<lambda>(l, i). length l - i)\\<rbrakk>\n           \\<Longrightarrow> f x'\n                             \\<le> SPEC\n                                    (\\<lambda>h'.\n  \\<alpha> h' = \\<alpha> h \\<and>\n  heap_invar' h' \\<and> length h' = length h);\n        case x of\n        (hh, i) \\<Rightarrow>\n          sink_invar hh i \\<and>\n          \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n        REC\\<^sub>T\n         (\\<lambda>sink a.\n             case a of\n             (h, i) \\<Rightarrow>\n               ASSERT (valid h i) \\<bind>\n               (\\<lambda>_.\n                   if has_right h i\n                   then ASSERT (has_left h i) \\<bind>\n                        (\\<lambda>_.\n                            prio_of_op h (left i) \\<bind>\n                            (\\<lambda>lp.\n                                prio_of_op h (right i) \\<bind>\n                                (\\<lambda>rp.\n                                    prio_of_op h i \\<bind>\n                                    (\\<lambda>p.\n  if lp < p \\<and> lp \\<le> rp\n  then exch_op h i (left i) \\<bind> (\\<lambda>h. sink (h, left i))\n  else if rp < lp \\<and> rp < p\n       then exch_op h i (right i) \\<bind> (\\<lambda>h. sink (h, right i))\n       else RETURN h))))\n                   else if has_left h i\n                        then prio_of_op h (left i) \\<bind>\n                             (\\<lambda>lp.\n                                 prio_of_op h i \\<bind>\n                                 (\\<lambda>p.\n                                     if lp < p\n                                     then exch_op h i (left i) \\<bind>\n    (\\<lambda>h. sink (h, left i))\n                                     else RETURN h))\n                        else RETURN h)) =\n        f;\n        x = (a, b); valid a b; has_right a b; has_left a b; xa = pleft a b;\n        xb = pright a b; xc = prio_of a b;\n        \\<not> (xa < xc \\<and> xa \\<le> xb); xb < xa \\<and> xb < xc;\n        xd = exch a b (right b)\\<rbrakk>\n       \\<Longrightarrow> f (xd, right b)\n                         \\<le> SPEC\n                                (\\<lambda>h'.\n                                    \\<alpha> h' = \\<alpha> h \\<and>\n                                    heap_invar' h' \\<and>\n                                    length h' = length h)\nA total of 11 subgoals...", "apply rprems"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>f x a b xa xb xc xd.\n       \\<lbrakk>sink_invar h i;\n        case x of\n        (hh, i) \\<Rightarrow>\n          sink_invar hh i \\<and>\n          \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n        REC\\<^sub>T\n         (\\<lambda>sink a.\n             case a of\n             (h, i) \\<Rightarrow>\n               ASSERT (valid h i) \\<bind>\n               (\\<lambda>_.\n                   if has_right h i\n                   then ASSERT (has_left h i) \\<bind>\n                        (\\<lambda>_.\n                            prio_of_op h (left i) \\<bind>\n                            (\\<lambda>lp.\n                                prio_of_op h (right i) \\<bind>\n                                (\\<lambda>rp.\n                                    prio_of_op h i \\<bind>\n                                    (\\<lambda>p.\n  if lp < p \\<and> lp \\<le> rp\n  then exch_op h i (left i) \\<bind> (\\<lambda>h. sink (h, left i))\n  else if rp < lp \\<and> rp < p\n       then exch_op h i (right i) \\<bind> (\\<lambda>h. sink (h, right i))\n       else RETURN h))))\n                   else if has_left h i\n                        then prio_of_op h (left i) \\<bind>\n                             (\\<lambda>lp.\n                                 prio_of_op h i \\<bind>\n                                 (\\<lambda>p.\n                                     if lp < p\n                                     then exch_op h i (left i) \\<bind>\n    (\\<lambda>h. sink (h, left i))\n                                     else RETURN h))\n                        else RETURN h)) =\n        f;\n        x = (a, b); valid a b; has_right a b; has_left a b; xa = pleft a b;\n        xb = pright a b; xc = prio_of a b;\n        \\<not> (xa < xc \\<and> xa \\<le> xb); xb < xa \\<and> xb < xc;\n        xd = exch a b (right b)\\<rbrakk>\n       \\<Longrightarrow> case (xd, right b) of\n                         (hh, i) \\<Rightarrow>\n                           sink_invar hh i \\<and>\n                           \\<alpha> hh = \\<alpha> h \\<and>\n                           length hh = length h\nA total of 12 subgoals...", "apply (auto intro: sink_invar_pres) []"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>f x a b xa xb xc xd.\n       \\<lbrakk>sink_invar h i;\n        case x of\n        (hh, i) \\<Rightarrow>\n          sink_invar hh i \\<and>\n          \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n        REC\\<^sub>T\n         (\\<lambda>sink a.\n             case a of\n             (h, i) \\<Rightarrow>\n               ASSERT (valid h i) \\<bind>\n               (\\<lambda>_.\n                   if has_right h i\n                   then ASSERT (has_left h i) \\<bind>\n                        (\\<lambda>_.\n                            prio_of_op h (left i) \\<bind>\n                            (\\<lambda>lp.\n                                prio_of_op h (right i) \\<bind>\n                                (\\<lambda>rp.\n                                    prio_of_op h i \\<bind>\n                                    (\\<lambda>p.\n  if lp < p \\<and> lp \\<le> rp\n  then exch_op h i (left i) \\<bind> (\\<lambda>h. sink (h, left i))\n  else if rp < lp \\<and> rp < p\n       then exch_op h i (right i) \\<bind> (\\<lambda>h. sink (h, right i))\n       else RETURN h))))\n                   else if has_left h i\n                        then prio_of_op h (left i) \\<bind>\n                             (\\<lambda>lp.\n                                 prio_of_op h i \\<bind>\n                                 (\\<lambda>p.\n                                     if lp < p\n                                     then exch_op h i (left i) \\<bind>\n    (\\<lambda>h. sink (h, left i))\n                                     else RETURN h))\n                        else RETURN h)) =\n        f;\n        x = (a, b); valid a b; has_right a b; has_left a b; xa = pleft a b;\n        xb = pright a b; xc = prio_of a b;\n        \\<not> (xa < xc \\<and> xa \\<le> xb); xb < xa \\<and> xb < xc;\n        xd = exch a b (right b)\\<rbrakk>\n       \\<Longrightarrow> ((xd, right b), x)\n                         \\<in> measure (\\<lambda>(l, y). length l - y)\nA total of 11 subgoals...", "apply (auto simp: valid_def left_def right_def) []"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>f x a b xa xb xc.\n       \\<lbrakk>sink_invar h i;\n        \\<And>x'.\n           \\<lbrakk>case x' of\n                    (hh, i) \\<Rightarrow>\n                      sink_invar hh i \\<and>\n                      \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n            (x', x) \\<in> measure (\\<lambda>(l, i). length l - i)\\<rbrakk>\n           \\<Longrightarrow> f x'\n                             \\<le> SPEC\n                                    (\\<lambda>h'.\n  \\<alpha> h' = \\<alpha> h \\<and>\n  heap_invar' h' \\<and> length h' = length h);\n        case x of\n        (hh, i) \\<Rightarrow>\n          sink_invar hh i \\<and>\n          \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n        REC\\<^sub>T\n         (\\<lambda>sink a.\n             case a of\n             (h, i) \\<Rightarrow>\n               ASSERT (valid h i) \\<bind>\n               (\\<lambda>_.\n                   if has_right h i\n                   then ASSERT (has_left h i) \\<bind>\n                        (\\<lambda>_.\n                            prio_of_op h (left i) \\<bind>\n                            (\\<lambda>lp.\n                                prio_of_op h (right i) \\<bind>\n                                (\\<lambda>rp.\n                                    prio_of_op h i \\<bind>\n                                    (\\<lambda>p.\n  if lp < p \\<and> lp \\<le> rp\n  then exch_op h i (left i) \\<bind> (\\<lambda>h. sink (h, left i))\n  else if rp < lp \\<and> rp < p\n       then exch_op h i (right i) \\<bind> (\\<lambda>h. sink (h, right i))\n       else RETURN h))))\n                   else if has_left h i\n                        then prio_of_op h (left i) \\<bind>\n                             (\\<lambda>lp.\n                                 prio_of_op h i \\<bind>\n                                 (\\<lambda>p.\n                                     if lp < p\n                                     then exch_op h i (left i) \\<bind>\n    (\\<lambda>h. sink (h, left i))\n                                     else RETURN h))\n                        else RETURN h)) =\n        f;\n        x = (a, b); valid a b; has_right a b; has_left a b; xa = pleft a b;\n        xb = pright a b; xc = prio_of a b;\n        \\<not> (xa < xc \\<and> xa \\<le> xb);\n        \\<not> (xb < xa \\<and> xb < xc)\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> a = \\<alpha> h\nA total of 10 subgoals...", "apply (auto) []"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>f x a b xa xb xc.\n       \\<lbrakk>sink_invar h i;\n        \\<And>x'.\n           \\<lbrakk>case x' of\n                    (hh, i) \\<Rightarrow>\n                      sink_invar hh i \\<and>\n                      \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n            (x', x) \\<in> measure (\\<lambda>(l, i). length l - i)\\<rbrakk>\n           \\<Longrightarrow> f x'\n                             \\<le> SPEC\n                                    (\\<lambda>h'.\n  \\<alpha> h' = \\<alpha> h \\<and>\n  heap_invar' h' \\<and> length h' = length h);\n        case x of\n        (hh, i) \\<Rightarrow>\n          sink_invar hh i \\<and>\n          \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n        REC\\<^sub>T\n         (\\<lambda>sink a.\n             case a of\n             (h, i) \\<Rightarrow>\n               ASSERT (valid h i) \\<bind>\n               (\\<lambda>_.\n                   if has_right h i\n                   then ASSERT (has_left h i) \\<bind>\n                        (\\<lambda>_.\n                            prio_of_op h (left i) \\<bind>\n                            (\\<lambda>lp.\n                                prio_of_op h (right i) \\<bind>\n                                (\\<lambda>rp.\n                                    prio_of_op h i \\<bind>\n                                    (\\<lambda>p.\n  if lp < p \\<and> lp \\<le> rp\n  then exch_op h i (left i) \\<bind> (\\<lambda>h. sink (h, left i))\n  else if rp < lp \\<and> rp < p\n       then exch_op h i (right i) \\<bind> (\\<lambda>h. sink (h, right i))\n       else RETURN h))))\n                   else if has_left h i\n                        then prio_of_op h (left i) \\<bind>\n                             (\\<lambda>lp.\n                                 prio_of_op h i \\<bind>\n                                 (\\<lambda>p.\n                                     if lp < p\n                                     then exch_op h i (left i) \\<bind>\n    (\\<lambda>h. sink (h, left i))\n                                     else RETURN h))\n                        else RETURN h)) =\n        f;\n        x = (a, b); valid a b; has_right a b; has_left a b; xa = pleft a b;\n        xb = pright a b; xc = prio_of a b;\n        \\<not> (xa < xc \\<and> xa \\<le> xb);\n        \\<not> (xb < xa \\<and> xb < xc)\\<rbrakk>\n       \\<Longrightarrow> heap_invar' a\nA total of 9 subgoals...", "apply clarsimp"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>aa ba.\n       \\<lbrakk>sink_invar h i;\n        \\<And>a b.\n           \\<lbrakk>sink_invar a b \\<and>\n                    \\<alpha> a = \\<alpha> h \\<and> length a = length h;\n            length h - b < length h - ba\\<rbrakk>\n           \\<Longrightarrow> REC\\<^sub>T\n                              (\\<lambda>sink (h, i).\n                                  ASSERT (valid h i) \\<bind>\n                                  (\\<lambda>_.\nif has_right h i\nthen ASSERT (has_left h i) \\<bind>\n     (\\<lambda>_.\n         prio_of_op h (left i) \\<bind>\n         (\\<lambda>lp.\n             prio_of_op h (right i) \\<bind>\n             (\\<lambda>rp.\n                 prio_of_op h i \\<bind>\n                 (\\<lambda>p.\n                     if lp < p \\<and> lp \\<le> rp\n                     then exch_op h i (left i) \\<bind>\n                          (\\<lambda>h. sink (h, left i))\n                     else if rp < lp \\<and> rp < p\n                          then exch_op h i (right i) \\<bind>\n                               (\\<lambda>h. sink (h, right i))\n                          else RETURN h))))\nelse if has_left h i\n     then prio_of_op h (left i) \\<bind>\n          (\\<lambda>lp.\n              prio_of_op h i \\<bind>\n              (\\<lambda>p.\n                  if lp < p\n                  then exch_op h i (left i) \\<bind>\n                       (\\<lambda>h. sink (h, left i))\n                  else RETURN h))\n     else RETURN h))\n                              (a, b)\n                             \\<le> SPEC\n                                    (\\<lambda>h'.\n  \\<alpha> h' = \\<alpha> h \\<and>\n  heap_invar' h' \\<and> length h' = length h);\n        valid aa ba; has_right aa ba; has_left aa ba;\n        pleft aa ba < prio_of aa ba \\<longrightarrow>\n        \\<not> pleft aa ba \\<le> pright aa ba;\n        pright aa ba < pleft aa ba \\<longrightarrow>\n        \\<not> pright aa ba < prio_of aa ba;\n        sink_invar aa ba; \\<alpha> aa = \\<alpha> h;\n        length aa = length h\\<rbrakk>\n       \\<Longrightarrow> heap_invar' aa\nA total of 9 subgoals...", "apply (rule sink_invar_exit, assumption) []"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>aa ba.\n       \\<lbrakk>sink_invar h i;\n        \\<And>a b.\n           \\<lbrakk>sink_invar a b \\<and>\n                    \\<alpha> a = \\<alpha> h \\<and> length a = length h;\n            length h - b < length h - ba\\<rbrakk>\n           \\<Longrightarrow> REC\\<^sub>T\n                              (\\<lambda>sink (h, i).\n                                  ASSERT (valid h i) \\<bind>\n                                  (\\<lambda>_.\nif has_right h i\nthen ASSERT (has_left h i) \\<bind>\n     (\\<lambda>_.\n         prio_of_op h (left i) \\<bind>\n         (\\<lambda>lp.\n             prio_of_op h (right i) \\<bind>\n             (\\<lambda>rp.\n                 prio_of_op h i \\<bind>\n                 (\\<lambda>p.\n                     if lp < p \\<and> lp \\<le> rp\n                     then exch_op h i (left i) \\<bind>\n                          (\\<lambda>h. sink (h, left i))\n                     else if rp < lp \\<and> rp < p\n                          then exch_op h i (right i) \\<bind>\n                               (\\<lambda>h. sink (h, right i))\n                          else RETURN h))))\nelse if has_left h i\n     then prio_of_op h (left i) \\<bind>\n          (\\<lambda>lp.\n              prio_of_op h i \\<bind>\n              (\\<lambda>p.\n                  if lp < p\n                  then exch_op h i (left i) \\<bind>\n                       (\\<lambda>h. sink (h, left i))\n                  else RETURN h))\n     else RETURN h))\n                              (a, b)\n                             \\<le> SPEC\n                                    (\\<lambda>h'.\n  \\<alpha> h' = \\<alpha> h \\<and>\n  heap_invar' h' \\<and> length h' = length h);\n        valid aa ba; has_right aa ba; has_left aa ba;\n        pleft aa ba < prio_of aa ba \\<longrightarrow>\n        \\<not> pleft aa ba \\<le> pright aa ba;\n        pright aa ba < pleft aa ba \\<longrightarrow>\n        \\<not> pright aa ba < prio_of aa ba;\n        sink_invar aa ba; \\<alpha> aa = \\<alpha> h;\n        length aa = length h\\<rbrakk>\n       \\<Longrightarrow> children_ge aa (prio_of aa ba) ba\nA total of 9 subgoals...", "apply (auto simp: children_ge_def) []"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>f x a b xa xb xc.\n       \\<lbrakk>sink_invar h i;\n        \\<And>x'.\n           \\<lbrakk>case x' of\n                    (hh, i) \\<Rightarrow>\n                      sink_invar hh i \\<and>\n                      \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n            (x', x) \\<in> measure (\\<lambda>(l, i). length l - i)\\<rbrakk>\n           \\<Longrightarrow> f x'\n                             \\<le> SPEC\n                                    (\\<lambda>h'.\n  \\<alpha> h' = \\<alpha> h \\<and>\n  heap_invar' h' \\<and> length h' = length h);\n        case x of\n        (hh, i) \\<Rightarrow>\n          sink_invar hh i \\<and>\n          \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n        REC\\<^sub>T\n         (\\<lambda>sink a.\n             case a of\n             (h, i) \\<Rightarrow>\n               ASSERT (valid h i) \\<bind>\n               (\\<lambda>_.\n                   if has_right h i\n                   then ASSERT (has_left h i) \\<bind>\n                        (\\<lambda>_.\n                            prio_of_op h (left i) \\<bind>\n                            (\\<lambda>lp.\n                                prio_of_op h (right i) \\<bind>\n                                (\\<lambda>rp.\n                                    prio_of_op h i \\<bind>\n                                    (\\<lambda>p.\n  if lp < p \\<and> lp \\<le> rp\n  then exch_op h i (left i) \\<bind> (\\<lambda>h. sink (h, left i))\n  else if rp < lp \\<and> rp < p\n       then exch_op h i (right i) \\<bind> (\\<lambda>h. sink (h, right i))\n       else RETURN h))))\n                   else if has_left h i\n                        then prio_of_op h (left i) \\<bind>\n                             (\\<lambda>lp.\n                                 prio_of_op h i \\<bind>\n                                 (\\<lambda>p.\n                                     if lp < p\n                                     then exch_op h i (left i) \\<bind>\n    (\\<lambda>h. sink (h, left i))\n                                     else RETURN h))\n                        else RETURN h)) =\n        f;\n        x = (a, b); valid a b; has_right a b; has_left a b; xa = pleft a b;\n        xb = pright a b; xc = prio_of a b;\n        \\<not> (xa < xc \\<and> xa \\<le> xb);\n        \\<not> (xb < xa \\<and> xb < xc)\\<rbrakk>\n       \\<Longrightarrow> length a = length h\nA total of 8 subgoals...", "apply (auto) []"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>f x a b xa xb xc.\n       \\<lbrakk>sink_invar h i;\n        \\<And>x'.\n           \\<lbrakk>case x' of\n                    (hh, i) \\<Rightarrow>\n                      sink_invar hh i \\<and>\n                      \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n            (x', x) \\<in> measure (\\<lambda>(l, i). length l - i)\\<rbrakk>\n           \\<Longrightarrow> f x'\n                             \\<le> SPEC\n                                    (\\<lambda>h'.\n  \\<alpha> h' = \\<alpha> h \\<and>\n  heap_invar' h' \\<and> length h' = length h);\n        case x of\n        (hh, i) \\<Rightarrow>\n          sink_invar hh i \\<and>\n          \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n        REC\\<^sub>T\n         (\\<lambda>sink a.\n             case a of\n             (h, i) \\<Rightarrow>\n               ASSERT (valid h i) \\<bind>\n               (\\<lambda>_.\n                   if has_right h i\n                   then ASSERT (has_left h i) \\<bind>\n                        (\\<lambda>_.\n                            prio_of_op h (left i) \\<bind>\n                            (\\<lambda>lp.\n                                prio_of_op h (right i) \\<bind>\n                                (\\<lambda>rp.\n                                    prio_of_op h i \\<bind>\n                                    (\\<lambda>p.\n  if lp < p \\<and> lp \\<le> rp\n  then exch_op h i (left i) \\<bind> (\\<lambda>h. sink (h, left i))\n  else if rp < lp \\<and> rp < p\n       then exch_op h i (right i) \\<bind> (\\<lambda>h. sink (h, right i))\n       else RETURN h))))\n                   else if has_left h i\n                        then prio_of_op h (left i) \\<bind>\n                             (\\<lambda>lp.\n                                 prio_of_op h i \\<bind>\n                                 (\\<lambda>p.\n                                     if lp < p\n                                     then exch_op h i (left i) \\<bind>\n    (\\<lambda>h. sink (h, left i))\n                                     else RETURN h))\n                        else RETURN h)) =\n        f;\n        x = (a, b); valid a b; \\<not> has_right a b; has_left a b;\n        xa = pleft a b; xb = prio_of a b; xa < xb;\n        xc = exch a b (left b)\\<rbrakk>\n       \\<Longrightarrow> f (xc, left b)\n                         \\<le> SPEC\n                                (\\<lambda>h'.\n                                    \\<alpha> h' = \\<alpha> h \\<and>\n                                    heap_invar' h' \\<and>\n                                    length h' = length h)\nA total of 7 subgoals...", "apply rprems"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>f x a b xa xb xc.\n       \\<lbrakk>sink_invar h i;\n        case x of\n        (hh, i) \\<Rightarrow>\n          sink_invar hh i \\<and>\n          \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n        REC\\<^sub>T\n         (\\<lambda>sink a.\n             case a of\n             (h, i) \\<Rightarrow>\n               ASSERT (valid h i) \\<bind>\n               (\\<lambda>_.\n                   if has_right h i\n                   then ASSERT (has_left h i) \\<bind>\n                        (\\<lambda>_.\n                            prio_of_op h (left i) \\<bind>\n                            (\\<lambda>lp.\n                                prio_of_op h (right i) \\<bind>\n                                (\\<lambda>rp.\n                                    prio_of_op h i \\<bind>\n                                    (\\<lambda>p.\n  if lp < p \\<and> lp \\<le> rp\n  then exch_op h i (left i) \\<bind> (\\<lambda>h. sink (h, left i))\n  else if rp < lp \\<and> rp < p\n       then exch_op h i (right i) \\<bind> (\\<lambda>h. sink (h, right i))\n       else RETURN h))))\n                   else if has_left h i\n                        then prio_of_op h (left i) \\<bind>\n                             (\\<lambda>lp.\n                                 prio_of_op h i \\<bind>\n                                 (\\<lambda>p.\n                                     if lp < p\n                                     then exch_op h i (left i) \\<bind>\n    (\\<lambda>h. sink (h, left i))\n                                     else RETURN h))\n                        else RETURN h)) =\n        f;\n        x = (a, b); valid a b; \\<not> has_right a b; has_left a b;\n        xa = pleft a b; xb = prio_of a b; xa < xb;\n        xc = exch a b (left b)\\<rbrakk>\n       \\<Longrightarrow> case (xc, left b) of\n                         (hh, i) \\<Rightarrow>\n                           sink_invar hh i \\<and>\n                           \\<alpha> hh = \\<alpha> h \\<and>\n                           length hh = length h\nA total of 8 subgoals...", "apply (auto intro: sink_invar_pres) []"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>f x a b xa xb xc.\n       \\<lbrakk>sink_invar h i;\n        case x of\n        (hh, i) \\<Rightarrow>\n          sink_invar hh i \\<and>\n          \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n        REC\\<^sub>T\n         (\\<lambda>sink a.\n             case a of\n             (h, i) \\<Rightarrow>\n               ASSERT (valid h i) \\<bind>\n               (\\<lambda>_.\n                   if has_right h i\n                   then ASSERT (has_left h i) \\<bind>\n                        (\\<lambda>_.\n                            prio_of_op h (left i) \\<bind>\n                            (\\<lambda>lp.\n                                prio_of_op h (right i) \\<bind>\n                                (\\<lambda>rp.\n                                    prio_of_op h i \\<bind>\n                                    (\\<lambda>p.\n  if lp < p \\<and> lp \\<le> rp\n  then exch_op h i (left i) \\<bind> (\\<lambda>h. sink (h, left i))\n  else if rp < lp \\<and> rp < p\n       then exch_op h i (right i) \\<bind> (\\<lambda>h. sink (h, right i))\n       else RETURN h))))\n                   else if has_left h i\n                        then prio_of_op h (left i) \\<bind>\n                             (\\<lambda>lp.\n                                 prio_of_op h i \\<bind>\n                                 (\\<lambda>p.\n                                     if lp < p\n                                     then exch_op h i (left i) \\<bind>\n    (\\<lambda>h. sink (h, left i))\n                                     else RETURN h))\n                        else RETURN h)) =\n        f;\n        x = (a, b); valid a b; \\<not> has_right a b; has_left a b;\n        xa = pleft a b; xb = prio_of a b; xa < xb;\n        xc = exch a b (left b)\\<rbrakk>\n       \\<Longrightarrow> ((xc, left b), x)\n                         \\<in> measure (\\<lambda>(l, y). length l - y)\nA total of 7 subgoals...", "apply (auto simp: valid_def left_def right_def) []"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>f x a b xa xb.\n       \\<lbrakk>sink_invar h i;\n        \\<And>x'.\n           \\<lbrakk>case x' of\n                    (hh, i) \\<Rightarrow>\n                      sink_invar hh i \\<and>\n                      \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n            (x', x) \\<in> measure (\\<lambda>(l, i). length l - i)\\<rbrakk>\n           \\<Longrightarrow> f x'\n                             \\<le> SPEC\n                                    (\\<lambda>h'.\n  \\<alpha> h' = \\<alpha> h \\<and>\n  heap_invar' h' \\<and> length h' = length h);\n        case x of\n        (hh, i) \\<Rightarrow>\n          sink_invar hh i \\<and>\n          \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n        REC\\<^sub>T\n         (\\<lambda>sink a.\n             case a of\n             (h, i) \\<Rightarrow>\n               ASSERT (valid h i) \\<bind>\n               (\\<lambda>_.\n                   if has_right h i\n                   then ASSERT (has_left h i) \\<bind>\n                        (\\<lambda>_.\n                            prio_of_op h (left i) \\<bind>\n                            (\\<lambda>lp.\n                                prio_of_op h (right i) \\<bind>\n                                (\\<lambda>rp.\n                                    prio_of_op h i \\<bind>\n                                    (\\<lambda>p.\n  if lp < p \\<and> lp \\<le> rp\n  then exch_op h i (left i) \\<bind> (\\<lambda>h. sink (h, left i))\n  else if rp < lp \\<and> rp < p\n       then exch_op h i (right i) \\<bind> (\\<lambda>h. sink (h, right i))\n       else RETURN h))))\n                   else if has_left h i\n                        then prio_of_op h (left i) \\<bind>\n                             (\\<lambda>lp.\n                                 prio_of_op h i \\<bind>\n                                 (\\<lambda>p.\n                                     if lp < p\n                                     then exch_op h i (left i) \\<bind>\n    (\\<lambda>h. sink (h, left i))\n                                     else RETURN h))\n                        else RETURN h)) =\n        f;\n        x = (a, b); valid a b; \\<not> has_right a b; has_left a b;\n        xa = pleft a b; xb = prio_of a b; \\<not> xa < xb\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> a = \\<alpha> h\nA total of 6 subgoals...", "apply (auto) []"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>f x a b xa xb.\n       \\<lbrakk>sink_invar h i;\n        \\<And>x'.\n           \\<lbrakk>case x' of\n                    (hh, i) \\<Rightarrow>\n                      sink_invar hh i \\<and>\n                      \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n            (x', x) \\<in> measure (\\<lambda>(l, i). length l - i)\\<rbrakk>\n           \\<Longrightarrow> f x'\n                             \\<le> SPEC\n                                    (\\<lambda>h'.\n  \\<alpha> h' = \\<alpha> h \\<and>\n  heap_invar' h' \\<and> length h' = length h);\n        case x of\n        (hh, i) \\<Rightarrow>\n          sink_invar hh i \\<and>\n          \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n        REC\\<^sub>T\n         (\\<lambda>sink a.\n             case a of\n             (h, i) \\<Rightarrow>\n               ASSERT (valid h i) \\<bind>\n               (\\<lambda>_.\n                   if has_right h i\n                   then ASSERT (has_left h i) \\<bind>\n                        (\\<lambda>_.\n                            prio_of_op h (left i) \\<bind>\n                            (\\<lambda>lp.\n                                prio_of_op h (right i) \\<bind>\n                                (\\<lambda>rp.\n                                    prio_of_op h i \\<bind>\n                                    (\\<lambda>p.\n  if lp < p \\<and> lp \\<le> rp\n  then exch_op h i (left i) \\<bind> (\\<lambda>h. sink (h, left i))\n  else if rp < lp \\<and> rp < p\n       then exch_op h i (right i) \\<bind> (\\<lambda>h. sink (h, right i))\n       else RETURN h))))\n                   else if has_left h i\n                        then prio_of_op h (left i) \\<bind>\n                             (\\<lambda>lp.\n                                 prio_of_op h i \\<bind>\n                                 (\\<lambda>p.\n                                     if lp < p\n                                     then exch_op h i (left i) \\<bind>\n    (\\<lambda>h. sink (h, left i))\n                                     else RETURN h))\n                        else RETURN h)) =\n        f;\n        x = (a, b); valid a b; \\<not> has_right a b; has_left a b;\n        xa = pleft a b; xb = prio_of a b; \\<not> xa < xb\\<rbrakk>\n       \\<Longrightarrow> heap_invar' a\nA total of 5 subgoals...", "apply clarsimp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>aa ba.\n       \\<lbrakk>sink_invar h i;\n        \\<And>a b.\n           \\<lbrakk>sink_invar a b \\<and>\n                    \\<alpha> a = \\<alpha> h \\<and> length a = length h;\n            length h - b < length h - ba\\<rbrakk>\n           \\<Longrightarrow> REC\\<^sub>T\n                              (\\<lambda>sink (h, i).\n                                  ASSERT (valid h i) \\<bind>\n                                  (\\<lambda>_.\nif has_right h i\nthen ASSERT (has_left h i) \\<bind>\n     (\\<lambda>_.\n         prio_of_op h (left i) \\<bind>\n         (\\<lambda>lp.\n             prio_of_op h (right i) \\<bind>\n             (\\<lambda>rp.\n                 prio_of_op h i \\<bind>\n                 (\\<lambda>p.\n                     if lp < p \\<and> lp \\<le> rp\n                     then exch_op h i (left i) \\<bind>\n                          (\\<lambda>h. sink (h, left i))\n                     else if rp < lp \\<and> rp < p\n                          then exch_op h i (right i) \\<bind>\n                               (\\<lambda>h. sink (h, right i))\n                          else RETURN h))))\nelse if has_left h i\n     then prio_of_op h (left i) \\<bind>\n          (\\<lambda>lp.\n              prio_of_op h i \\<bind>\n              (\\<lambda>p.\n                  if lp < p\n                  then exch_op h i (left i) \\<bind>\n                       (\\<lambda>h. sink (h, left i))\n                  else RETURN h))\n     else RETURN h))\n                              (a, b)\n                             \\<le> SPEC\n                                    (\\<lambda>h'.\n  \\<alpha> h' = \\<alpha> h \\<and>\n  heap_invar' h' \\<and> length h' = length h);\n        valid aa ba; \\<not> has_right aa ba; has_left aa ba;\n        \\<not> pleft aa ba < prio_of aa ba; sink_invar aa ba;\n        \\<alpha> aa = \\<alpha> h; length aa = length h\\<rbrakk>\n       \\<Longrightarrow> heap_invar' aa\nA total of 5 subgoals...", "apply (rule sink_invar_exit, assumption) []"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>aa ba.\n       \\<lbrakk>sink_invar h i;\n        \\<And>a b.\n           \\<lbrakk>sink_invar a b \\<and>\n                    \\<alpha> a = \\<alpha> h \\<and> length a = length h;\n            length h - b < length h - ba\\<rbrakk>\n           \\<Longrightarrow> REC\\<^sub>T\n                              (\\<lambda>sink (h, i).\n                                  ASSERT (valid h i) \\<bind>\n                                  (\\<lambda>_.\nif has_right h i\nthen ASSERT (has_left h i) \\<bind>\n     (\\<lambda>_.\n         prio_of_op h (left i) \\<bind>\n         (\\<lambda>lp.\n             prio_of_op h (right i) \\<bind>\n             (\\<lambda>rp.\n                 prio_of_op h i \\<bind>\n                 (\\<lambda>p.\n                     if lp < p \\<and> lp \\<le> rp\n                     then exch_op h i (left i) \\<bind>\n                          (\\<lambda>h. sink (h, left i))\n                     else if rp < lp \\<and> rp < p\n                          then exch_op h i (right i) \\<bind>\n                               (\\<lambda>h. sink (h, right i))\n                          else RETURN h))))\nelse if has_left h i\n     then prio_of_op h (left i) \\<bind>\n          (\\<lambda>lp.\n              prio_of_op h i \\<bind>\n              (\\<lambda>p.\n                  if lp < p\n                  then exch_op h i (left i) \\<bind>\n                       (\\<lambda>h. sink (h, left i))\n                  else RETURN h))\n     else RETURN h))\n                              (a, b)\n                             \\<le> SPEC\n                                    (\\<lambda>h'.\n  \\<alpha> h' = \\<alpha> h \\<and>\n  heap_invar' h' \\<and> length h' = length h);\n        valid aa ba; \\<not> has_right aa ba; has_left aa ba;\n        \\<not> pleft aa ba < prio_of aa ba; sink_invar aa ba;\n        \\<alpha> aa = \\<alpha> h; length aa = length h\\<rbrakk>\n       \\<Longrightarrow> children_ge aa (prio_of aa ba) ba\nA total of 5 subgoals...", "apply (auto simp: children_ge_def) []"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>f x a b xa xb.\n       \\<lbrakk>sink_invar h i;\n        \\<And>x'.\n           \\<lbrakk>case x' of\n                    (hh, i) \\<Rightarrow>\n                      sink_invar hh i \\<and>\n                      \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n            (x', x) \\<in> measure (\\<lambda>(l, i). length l - i)\\<rbrakk>\n           \\<Longrightarrow> f x'\n                             \\<le> SPEC\n                                    (\\<lambda>h'.\n  \\<alpha> h' = \\<alpha> h \\<and>\n  heap_invar' h' \\<and> length h' = length h);\n        case x of\n        (hh, i) \\<Rightarrow>\n          sink_invar hh i \\<and>\n          \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n        REC\\<^sub>T\n         (\\<lambda>sink a.\n             case a of\n             (h, i) \\<Rightarrow>\n               ASSERT (valid h i) \\<bind>\n               (\\<lambda>_.\n                   if has_right h i\n                   then ASSERT (has_left h i) \\<bind>\n                        (\\<lambda>_.\n                            prio_of_op h (left i) \\<bind>\n                            (\\<lambda>lp.\n                                prio_of_op h (right i) \\<bind>\n                                (\\<lambda>rp.\n                                    prio_of_op h i \\<bind>\n                                    (\\<lambda>p.\n  if lp < p \\<and> lp \\<le> rp\n  then exch_op h i (left i) \\<bind> (\\<lambda>h. sink (h, left i))\n  else if rp < lp \\<and> rp < p\n       then exch_op h i (right i) \\<bind> (\\<lambda>h. sink (h, right i))\n       else RETURN h))))\n                   else if has_left h i\n                        then prio_of_op h (left i) \\<bind>\n                             (\\<lambda>lp.\n                                 prio_of_op h i \\<bind>\n                                 (\\<lambda>p.\n                                     if lp < p\n                                     then exch_op h i (left i) \\<bind>\n    (\\<lambda>h. sink (h, left i))\n                                     else RETURN h))\n                        else RETURN h)) =\n        f;\n        x = (a, b); valid a b; \\<not> has_right a b; has_left a b;\n        xa = pleft a b; xb = prio_of a b; \\<not> xa < xb\\<rbrakk>\n       \\<Longrightarrow> length a = length h\nA total of 4 subgoals...", "apply (auto) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>f x a b.\n       \\<lbrakk>sink_invar h i;\n        \\<And>x'.\n           \\<lbrakk>case x' of\n                    (hh, i) \\<Rightarrow>\n                      sink_invar hh i \\<and>\n                      \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n            (x', x) \\<in> measure (\\<lambda>(l, i). length l - i)\\<rbrakk>\n           \\<Longrightarrow> f x'\n                             \\<le> SPEC\n                                    (\\<lambda>h'.\n  \\<alpha> h' = \\<alpha> h \\<and>\n  heap_invar' h' \\<and> length h' = length h);\n        case x of\n        (hh, i) \\<Rightarrow>\n          sink_invar hh i \\<and>\n          \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n        REC\\<^sub>T\n         (\\<lambda>sink a.\n             case a of\n             (h, i) \\<Rightarrow>\n               ASSERT (valid h i) \\<bind>\n               (\\<lambda>_.\n                   if has_right h i\n                   then ASSERT (has_left h i) \\<bind>\n                        (\\<lambda>_.\n                            prio_of_op h (left i) \\<bind>\n                            (\\<lambda>lp.\n                                prio_of_op h (right i) \\<bind>\n                                (\\<lambda>rp.\n                                    prio_of_op h i \\<bind>\n                                    (\\<lambda>p.\n  if lp < p \\<and> lp \\<le> rp\n  then exch_op h i (left i) \\<bind> (\\<lambda>h. sink (h, left i))\n  else if rp < lp \\<and> rp < p\n       then exch_op h i (right i) \\<bind> (\\<lambda>h. sink (h, right i))\n       else RETURN h))))\n                   else if has_left h i\n                        then prio_of_op h (left i) \\<bind>\n                             (\\<lambda>lp.\n                                 prio_of_op h i \\<bind>\n                                 (\\<lambda>p.\n                                     if lp < p\n                                     then exch_op h i (left i) \\<bind>\n    (\\<lambda>h. sink (h, left i))\n                                     else RETURN h))\n                        else RETURN h)) =\n        f;\n        x = (a, b); valid a b; \\<not> has_right a b;\n        \\<not> has_left a b\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> a = \\<alpha> h\nA total of 3 subgoals...", "apply (auto) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f x a b.\n       \\<lbrakk>sink_invar h i;\n        \\<And>x'.\n           \\<lbrakk>case x' of\n                    (hh, i) \\<Rightarrow>\n                      sink_invar hh i \\<and>\n                      \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n            (x', x) \\<in> measure (\\<lambda>(l, i). length l - i)\\<rbrakk>\n           \\<Longrightarrow> f x'\n                             \\<le> SPEC\n                                    (\\<lambda>h'.\n  \\<alpha> h' = \\<alpha> h \\<and>\n  heap_invar' h' \\<and> length h' = length h);\n        case x of\n        (hh, i) \\<Rightarrow>\n          sink_invar hh i \\<and>\n          \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n        REC\\<^sub>T\n         (\\<lambda>sink a.\n             case a of\n             (h, i) \\<Rightarrow>\n               ASSERT (valid h i) \\<bind>\n               (\\<lambda>_.\n                   if has_right h i\n                   then ASSERT (has_left h i) \\<bind>\n                        (\\<lambda>_.\n                            prio_of_op h (left i) \\<bind>\n                            (\\<lambda>lp.\n                                prio_of_op h (right i) \\<bind>\n                                (\\<lambda>rp.\n                                    prio_of_op h i \\<bind>\n                                    (\\<lambda>p.\n  if lp < p \\<and> lp \\<le> rp\n  then exch_op h i (left i) \\<bind> (\\<lambda>h. sink (h, left i))\n  else if rp < lp \\<and> rp < p\n       then exch_op h i (right i) \\<bind> (\\<lambda>h. sink (h, right i))\n       else RETURN h))))\n                   else if has_left h i\n                        then prio_of_op h (left i) \\<bind>\n                             (\\<lambda>lp.\n                                 prio_of_op h i \\<bind>\n                                 (\\<lambda>p.\n                                     if lp < p\n                                     then exch_op h i (left i) \\<bind>\n    (\\<lambda>h. sink (h, left i))\n                                     else RETURN h))\n                        else RETURN h)) =\n        f;\n        x = (a, b); valid a b; \\<not> has_right a b;\n        \\<not> has_left a b\\<rbrakk>\n       \\<Longrightarrow> heap_invar' a\nA total of 2 subgoals...", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ba.\n       \\<lbrakk>sink_invar h i;\n        \\<And>a b.\n           \\<lbrakk>sink_invar a b \\<and>\n                    \\<alpha> a = \\<alpha> h \\<and> length a = length h;\n            length h - b < length h - ba\\<rbrakk>\n           \\<Longrightarrow> REC\\<^sub>T\n                              (\\<lambda>sink (h, i).\n                                  ASSERT (valid h i) \\<bind>\n                                  (\\<lambda>_.\nif has_right h i\nthen ASSERT (has_left h i) \\<bind>\n     (\\<lambda>_.\n         prio_of_op h (left i) \\<bind>\n         (\\<lambda>lp.\n             prio_of_op h (right i) \\<bind>\n             (\\<lambda>rp.\n                 prio_of_op h i \\<bind>\n                 (\\<lambda>p.\n                     if lp < p \\<and> lp \\<le> rp\n                     then exch_op h i (left i) \\<bind>\n                          (\\<lambda>h. sink (h, left i))\n                     else if rp < lp \\<and> rp < p\n                          then exch_op h i (right i) \\<bind>\n                               (\\<lambda>h. sink (h, right i))\n                          else RETURN h))))\nelse if has_left h i\n     then prio_of_op h (left i) \\<bind>\n          (\\<lambda>lp.\n              prio_of_op h i \\<bind>\n              (\\<lambda>p.\n                  if lp < p\n                  then exch_op h i (left i) \\<bind>\n                       (\\<lambda>h. sink (h, left i))\n                  else RETURN h))\n     else RETURN h))\n                              (a, b)\n                             \\<le> SPEC\n                                    (\\<lambda>h'.\n  \\<alpha> h' = \\<alpha> h \\<and>\n  heap_invar' h' \\<and> length h' = length h);\n        valid aa ba; \\<not> has_right aa ba; \\<not> has_left aa ba;\n        sink_invar aa ba; \\<alpha> aa = \\<alpha> h;\n        length aa = length h\\<rbrakk>\n       \\<Longrightarrow> heap_invar' aa\nA total of 2 subgoals...", "apply (rule sink_invar_exit, assumption) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ba.\n       \\<lbrakk>sink_invar h i;\n        \\<And>a b.\n           \\<lbrakk>sink_invar a b \\<and>\n                    \\<alpha> a = \\<alpha> h \\<and> length a = length h;\n            length h - b < length h - ba\\<rbrakk>\n           \\<Longrightarrow> REC\\<^sub>T\n                              (\\<lambda>sink (h, i).\n                                  ASSERT (valid h i) \\<bind>\n                                  (\\<lambda>_.\nif has_right h i\nthen ASSERT (has_left h i) \\<bind>\n     (\\<lambda>_.\n         prio_of_op h (left i) \\<bind>\n         (\\<lambda>lp.\n             prio_of_op h (right i) \\<bind>\n             (\\<lambda>rp.\n                 prio_of_op h i \\<bind>\n                 (\\<lambda>p.\n                     if lp < p \\<and> lp \\<le> rp\n                     then exch_op h i (left i) \\<bind>\n                          (\\<lambda>h. sink (h, left i))\n                     else if rp < lp \\<and> rp < p\n                          then exch_op h i (right i) \\<bind>\n                               (\\<lambda>h. sink (h, right i))\n                          else RETURN h))))\nelse if has_left h i\n     then prio_of_op h (left i) \\<bind>\n          (\\<lambda>lp.\n              prio_of_op h i \\<bind>\n              (\\<lambda>p.\n                  if lp < p\n                  then exch_op h i (left i) \\<bind>\n                       (\\<lambda>h. sink (h, left i))\n                  else RETURN h))\n     else RETURN h))\n                              (a, b)\n                             \\<le> SPEC\n                                    (\\<lambda>h'.\n  \\<alpha> h' = \\<alpha> h \\<and>\n  heap_invar' h' \\<and> length h' = length h);\n        valid aa ba; \\<not> has_right aa ba; \\<not> has_left aa ba;\n        sink_invar aa ba; \\<alpha> aa = \\<alpha> h;\n        length aa = length h\\<rbrakk>\n       \\<Longrightarrow> children_ge aa (prio_of aa ba) ba\nA total of 2 subgoals...", "apply (auto simp: children_ge_def) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f x a b.\n       \\<lbrakk>sink_invar h i;\n        \\<And>x'.\n           \\<lbrakk>case x' of\n                    (hh, i) \\<Rightarrow>\n                      sink_invar hh i \\<and>\n                      \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n            (x', x) \\<in> measure (\\<lambda>(l, i). length l - i)\\<rbrakk>\n           \\<Longrightarrow> f x'\n                             \\<le> SPEC\n                                    (\\<lambda>h'.\n  \\<alpha> h' = \\<alpha> h \\<and>\n  heap_invar' h' \\<and> length h' = length h);\n        case x of\n        (hh, i) \\<Rightarrow>\n          sink_invar hh i \\<and>\n          \\<alpha> hh = \\<alpha> h \\<and> length hh = length h;\n        REC\\<^sub>T\n         (\\<lambda>sink a.\n             case a of\n             (h, i) \\<Rightarrow>\n               ASSERT (valid h i) \\<bind>\n               (\\<lambda>_.\n                   if has_right h i\n                   then ASSERT (has_left h i) \\<bind>\n                        (\\<lambda>_.\n                            prio_of_op h (left i) \\<bind>\n                            (\\<lambda>lp.\n                                prio_of_op h (right i) \\<bind>\n                                (\\<lambda>rp.\n                                    prio_of_op h i \\<bind>\n                                    (\\<lambda>p.\n  if lp < p \\<and> lp \\<le> rp\n  then exch_op h i (left i) \\<bind> (\\<lambda>h. sink (h, left i))\n  else if rp < lp \\<and> rp < p\n       then exch_op h i (right i) \\<bind> (\\<lambda>h. sink (h, right i))\n       else RETURN h))))\n                   else if has_left h i\n                        then prio_of_op h (left i) \\<bind>\n                             (\\<lambda>lp.\n                                 prio_of_op h i \\<bind>\n                                 (\\<lambda>p.\n                                     if lp < p\n                                     then exch_op h i (left i) \\<bind>\n    (\\<lambda>h. sink (h, left i))\n                                     else RETURN h))\n                        else RETURN h)) =\n        f;\n        x = (a, b); valid a b; \\<not> has_right a b;\n        \\<not> has_left a b\\<rbrakk>\n       \\<Longrightarrow> length a = length h", "apply (auto) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sink_op_swim_rule: \n      \"swim_invar h i \\<Longrightarrow> sink_op h i \\<le> SPEC (\\<lambda>h'. h'=h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swim_invar h i \\<Longrightarrow>\n    sink_op h i \\<le> SPEC (\\<lambda>h'. h' = h)", "apply (frule swim_invar_valid)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>swim_invar h i; valid h i\\<rbrakk>\n    \\<Longrightarrow> sink_op h i \\<le> SPEC (\\<lambda>h'. h' = h)", "unfolding sink_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>swim_invar h i; valid h i\\<rbrakk>\n    \\<Longrightarrow> REC\\<^sub>T\n                       (\\<lambda>sink (h, i).\n                           ASSERT (valid h i) \\<bind>\n                           (\\<lambda>_.\n                               if has_right h i\n                               then ASSERT (has_left h i) \\<bind>\n                                    (\\<lambda>_.\n  prio_of_op h (left i) \\<bind>\n  (\\<lambda>lp.\n      prio_of_op h (right i) \\<bind>\n      (\\<lambda>rp.\n          prio_of_op h i \\<bind>\n          (\\<lambda>p.\n              if lp < p \\<and> lp \\<le> rp\n              then exch_op h i (left i) \\<bind>\n                   (\\<lambda>h. sink (h, left i))\n              else if rp < lp \\<and> rp < p\n                   then exch_op h i (right i) \\<bind>\n                        (\\<lambda>h. sink (h, right i))\n                   else RETURN h))))\n                               else if has_left h i\n                                    then prio_of_op h (left i) \\<bind>\n   (\\<lambda>lp.\n       prio_of_op h i \\<bind>\n       (\\<lambda>p.\n           if lp < p\n           then exch_op h i (left i) \\<bind> (\\<lambda>h. sink (h, left i))\n           else RETURN h))\n                                    else RETURN h))\n                       (h, i)\n                      \\<le> SPEC (\\<lambda>h'. h' = h)", "apply (subst RECT_unfold, refine_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>swim_invar h i; valid h i\\<rbrakk>\n    \\<Longrightarrow> (case (h, i) of\n                       (h, i) \\<Rightarrow>\n                         ASSERT (valid h i) \\<bind>\n                         (\\<lambda>_.\n                             if has_right h i\n                             then ASSERT (has_left h i) \\<bind>\n                                  (\\<lambda>_.\nprio_of_op h (left i) \\<bind>\n(\\<lambda>lp.\n    prio_of_op h (right i) \\<bind>\n    (\\<lambda>rp.\n        prio_of_op h i \\<bind>\n        (\\<lambda>p.\n            if lp < p \\<and> lp \\<le> rp\n            then exch_op h i (left i) \\<bind>\n                 (\\<lambda>h.\n                     REC\\<^sub>T\n                      (\\<lambda>sink (h, i).\n                          ASSERT (valid h i) \\<bind>\n                          (\\<lambda>_.\n                              if has_right h i\n                              then ASSERT (has_left h i) \\<bind>\n                                   (\\<lambda>_.\n prio_of_op h (left i) \\<bind>\n (\\<lambda>lp.\n     prio_of_op h (right i) \\<bind>\n     (\\<lambda>rp.\n         prio_of_op h i \\<bind>\n         (\\<lambda>p.\n             if lp < p \\<and> lp \\<le> rp\n             then exch_op h i (left i) \\<bind>\n                  (\\<lambda>h. sink (h, left i))\n             else if rp < lp \\<and> rp < p\n                  then exch_op h i (right i) \\<bind>\n                       (\\<lambda>h. sink (h, right i))\n                  else RETURN h))))\n                              else if has_left h i\n                                   then prio_of_op h (left i) \\<bind>\n  (\\<lambda>lp.\n      prio_of_op h i \\<bind>\n      (\\<lambda>p.\n          if lp < p\n          then exch_op h i (left i) \\<bind> (\\<lambda>h. sink (h, left i))\n          else RETURN h))\n                                   else RETURN h))\n                      (h, left i))\n            else if rp < lp \\<and> rp < p\n                 then exch_op h i (right i) \\<bind>\n                      (\\<lambda>h.\n                          REC\\<^sub>T\n                           (\\<lambda>sink (h, i).\n                               ASSERT (valid h i) \\<bind>\n                               (\\<lambda>_.\n                                   if has_right h i\n                                   then ASSERT (has_left h i) \\<bind>\n  (\\<lambda>_.\n      prio_of_op h (left i) \\<bind>\n      (\\<lambda>lp.\n          prio_of_op h (right i) \\<bind>\n          (\\<lambda>rp.\n              prio_of_op h i \\<bind>\n              (\\<lambda>p.\n                  if lp < p \\<and> lp \\<le> rp\n                  then exch_op h i (left i) \\<bind>\n                       (\\<lambda>h. sink (h, left i))\n                  else if rp < lp \\<and> rp < p\n                       then exch_op h i (right i) \\<bind>\n                            (\\<lambda>h. sink (h, right i))\n                       else RETURN h))))\n                                   else if has_left h i\n  then prio_of_op h (left i) \\<bind>\n       (\\<lambda>lp.\n           prio_of_op h i \\<bind>\n           (\\<lambda>p.\n               if lp < p\n               then exch_op h i (left i) \\<bind>\n                    (\\<lambda>h. sink (h, left i))\n               else RETURN h))\n  else RETURN h))\n                           (h, right i))\n                 else RETURN h))))\n                             else if has_left h i\n                                  then prio_of_op h (left i) \\<bind>\n (\\<lambda>lp.\n     prio_of_op h i \\<bind>\n     (\\<lambda>p.\n         if lp < p\n         then exch_op h i (left i) \\<bind>\n              (\\<lambda>h.\n                  REC\\<^sub>T\n                   (\\<lambda>sink (h, i).\n                       ASSERT (valid h i) \\<bind>\n                       (\\<lambda>_.\n                           if has_right h i\n                           then ASSERT (has_left h i) \\<bind>\n                                (\\<lambda>_.\n                                    prio_of_op h (left i) \\<bind>\n                                    (\\<lambda>lp.\n  prio_of_op h (right i) \\<bind>\n  (\\<lambda>rp.\n      prio_of_op h i \\<bind>\n      (\\<lambda>p.\n          if lp < p \\<and> lp \\<le> rp\n          then exch_op h i (left i) \\<bind> (\\<lambda>h. sink (h, left i))\n          else if rp < lp \\<and> rp < p\n               then exch_op h i (right i) \\<bind>\n                    (\\<lambda>h. sink (h, right i))\n               else RETURN h))))\n                           else if has_left h i\n                                then prio_of_op h (left i) \\<bind>\n                                     (\\<lambda>lp.\n   prio_of_op h i \\<bind>\n   (\\<lambda>p.\n       if lp < p\n       then exch_op h i (left i) \\<bind> (\\<lambda>h. sink (h, left i))\n       else RETURN h))\n                                else RETURN h))\n                   (h, left i))\n         else RETURN h))\n                                  else RETURN h))\n                      \\<le> SPEC (\\<lambda>h'. h' = h)", "apply (fold sink_op_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>swim_invar h i; valid h i\\<rbrakk>\n    \\<Longrightarrow> (case (h, i) of\n                       (h, i) \\<Rightarrow>\n                         ASSERT (valid h i) \\<bind>\n                         (\\<lambda>_.\n                             if has_right h i\n                             then ASSERT (has_left h i) \\<bind>\n                                  (\\<lambda>_.\nprio_of_op h (left i) \\<bind>\n(\\<lambda>lp.\n    prio_of_op h (right i) \\<bind>\n    (\\<lambda>rp.\n        prio_of_op h i \\<bind>\n        (\\<lambda>p.\n            if lp < p \\<and> lp \\<le> rp\n            then exch_op h i (left i) \\<bind>\n                 (\\<lambda>h. sink_op h (left i))\n            else if rp < lp \\<and> rp < p\n                 then exch_op h i (right i) \\<bind>\n                      (\\<lambda>h. sink_op h (right i))\n                 else RETURN h))))\n                             else if has_left h i\n                                  then prio_of_op h (left i) \\<bind>\n (\\<lambda>lp.\n     prio_of_op h i \\<bind>\n     (\\<lambda>p.\n         if lp < p\n         then exch_op h i (left i) \\<bind> (\\<lambda>h. sink_op h (left i))\n         else RETURN h))\n                                  else RETURN h))\n                      \\<le> SPEC (\\<lambda>h'. h' = h)", "apply refine_vcg"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>swim_invar h i; valid h i; (h, i) = (a, b)\\<rbrakk>\n       \\<Longrightarrow> valid a b\n 2. \\<And>a b.\n       \\<lbrakk>swim_invar h i; valid h i; (h, i) = (a, b); valid a b;\n        has_right a b\\<rbrakk>\n       \\<Longrightarrow> has_left a b\n 3. \\<And>a b x xa xb xc.\n       \\<lbrakk>swim_invar h i; valid h i; (h, i) = (a, b); valid a b;\n        has_right a b; has_left a b; x = pleft a b; xa = pright a b;\n        xb = prio_of a b; x < xb \\<and> x \\<le> xa;\n        xc = exch a b (left b)\\<rbrakk>\n       \\<Longrightarrow> sink_invar xc (left b)\n 4. \\<And>a b x xa xb xc xd.\n       \\<lbrakk>swim_invar h i; valid h i; (h, i) = (a, b); valid a b;\n        has_right a b; has_left a b; x = pleft a b; xa = pright a b;\n        xb = prio_of a b; x < xb \\<and> x \\<le> xa; xc = exch a b (left b);\n        \\<alpha> xd = \\<alpha> xc \\<and>\n        heap_invar xd \\<and> length xd = length xc\\<rbrakk>\n       \\<Longrightarrow> xd = h\n 5. \\<And>a b x xa xb xc.\n       \\<lbrakk>swim_invar h i; valid h i; (h, i) = (a, b); valid a b;\n        has_right a b; has_left a b; x = pleft a b; xa = pright a b;\n        xb = prio_of a b; \\<not> (x < xb \\<and> x \\<le> xa);\n        xa < x \\<and> xa < xb; xc = exch a b (right b)\\<rbrakk>\n       \\<Longrightarrow> sink_invar xc (right b)\n 6. \\<And>a b x xa xb xc xd.\n       \\<lbrakk>swim_invar h i; valid h i; (h, i) = (a, b); valid a b;\n        has_right a b; has_left a b; x = pleft a b; xa = pright a b;\n        xb = prio_of a b; \\<not> (x < xb \\<and> x \\<le> xa);\n        xa < x \\<and> xa < xb; xc = exch a b (right b);\n        \\<alpha> xd = \\<alpha> xc \\<and>\n        heap_invar xd \\<and> length xd = length xc\\<rbrakk>\n       \\<Longrightarrow> xd = h\n 7. \\<And>a b x xa xb.\n       \\<lbrakk>swim_invar h i; valid h i; (h, i) = (a, b); valid a b;\n        has_right a b; has_left a b; x = pleft a b; xa = pright a b;\n        xb = prio_of a b; \\<not> (x < xb \\<and> x \\<le> xa);\n        \\<not> (xa < x \\<and> xa < xb)\\<rbrakk>\n       \\<Longrightarrow> a = h\n 8. \\<And>a b x xa xb.\n       \\<lbrakk>swim_invar h i; valid h i; (h, i) = (a, b); valid a b;\n        \\<not> has_right a b; has_left a b; x = pleft a b; xa = prio_of a b;\n        x < xa; xb = exch a b (left b)\\<rbrakk>\n       \\<Longrightarrow> sink_invar xb (left b)\n 9. \\<And>a b x xa xb xc.\n       \\<lbrakk>swim_invar h i; valid h i; (h, i) = (a, b); valid a b;\n        \\<not> has_right a b; has_left a b; x = pleft a b; xa = prio_of a b;\n        x < xa; xb = exch a b (left b);\n        \\<alpha> xc = \\<alpha> xb \\<and>\n        heap_invar xc \\<and> length xc = length xb\\<rbrakk>\n       \\<Longrightarrow> xc = h\n 10. \\<And>a b x xa.\n        \\<lbrakk>swim_invar h i; valid h i; (h, i) = (a, b); valid a b;\n         \\<not> has_right a b; has_left a b; x = pleft a b;\n         xa = prio_of a b; \\<not> x < xa\\<rbrakk>\n        \\<Longrightarrow> a = h\nA total of 11 subgoals...", "apply (simp_all)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>swim_invar a i; h = a; valid a i; has_right a i\\<rbrakk>\n       \\<Longrightarrow> has_left a i\n 2. \\<And>a x xa xb xc.\n       \\<lbrakk>swim_invar a i; h = a; valid a i; has_right a i;\n        has_left a i; x = pleft a i; xa = pright a i; xb = prio_of a i;\n        pleft a i < prio_of a i \\<and> pleft a i \\<le> pright a i;\n        xc = exch a i (left i)\\<rbrakk>\n       \\<Longrightarrow> sink_invar (exch a i (left i)) (left i)\n 3. \\<And>a x xa xb xc xd.\n       \\<lbrakk>swim_invar a i; h = a; valid a i; has_right a i;\n        has_left a i; x = pleft a i; xa = pright a i; xb = prio_of a i;\n        pleft a i < prio_of a i \\<and> pleft a i \\<le> pright a i;\n        xc = exch a i (left i);\n        \\<alpha> xd = \\<alpha> a \\<and>\n        heap_invar xd \\<and> length xd = length a\\<rbrakk>\n       \\<Longrightarrow> xd = a\n 4. \\<And>a x xa xb xc.\n       \\<lbrakk>swim_invar a i; h = a; valid a i; has_right a i;\n        has_left a i; x = pleft a i; xa = pright a i; xb = prio_of a i;\n        pleft a i < prio_of a i \\<longrightarrow>\n        \\<not> pleft a i \\<le> pright a i;\n        pright a i < pleft a i \\<and> pright a i < prio_of a i;\n        xc = exch a i (right i)\\<rbrakk>\n       \\<Longrightarrow> sink_invar (exch a i (right i)) (right i)\n 5. \\<And>a x xa xb xc xd.\n       \\<lbrakk>swim_invar a i; h = a; valid a i; has_right a i;\n        has_left a i; x = pleft a i; xa = pright a i; xb = prio_of a i;\n        pleft a i < prio_of a i \\<longrightarrow>\n        \\<not> pleft a i \\<le> pright a i;\n        pright a i < pleft a i \\<and> pright a i < prio_of a i;\n        xc = exch a i (right i);\n        \\<alpha> xd = \\<alpha> a \\<and>\n        heap_invar xd \\<and> length xd = length a\\<rbrakk>\n       \\<Longrightarrow> xd = a\n 6. \\<And>a x xa xb.\n       \\<lbrakk>swim_invar a i; h = a; valid a i; \\<not> has_right a i;\n        has_left a i; x = pleft a i; xa = prio_of a i;\n        pleft a i < prio_of a i; xb = exch a i (left i)\\<rbrakk>\n       \\<Longrightarrow> sink_invar (exch a i (left i)) (left i)\n 7. \\<And>a x xa xb xc.\n       \\<lbrakk>swim_invar a i; h = a; valid a i; \\<not> has_right a i;\n        has_left a i; x = pleft a i; xa = prio_of a i;\n        pleft a i < prio_of a i; xb = exch a i (left i);\n        \\<alpha> xc = \\<alpha> a \\<and>\n        heap_invar xc \\<and> length xc = length a\\<rbrakk>\n       \\<Longrightarrow> xc = a", "apply (auto simp add: valid_def left_def right_def dest: swim_invar_valid) []"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a x xa xb xc.\n       \\<lbrakk>swim_invar a i; h = a; valid a i; has_right a i;\n        has_left a i; x = pleft a i; xa = pright a i; xb = prio_of a i;\n        pleft a i < prio_of a i \\<and> pleft a i \\<le> pright a i;\n        xc = exch a i (left i)\\<rbrakk>\n       \\<Longrightarrow> sink_invar (exch a i (left i)) (left i)\n 2. \\<And>a x xa xb xc xd.\n       \\<lbrakk>swim_invar a i; h = a; valid a i; has_right a i;\n        has_left a i; x = pleft a i; xa = pright a i; xb = prio_of a i;\n        pleft a i < prio_of a i \\<and> pleft a i \\<le> pright a i;\n        xc = exch a i (left i);\n        \\<alpha> xd = \\<alpha> a \\<and>\n        heap_invar xd \\<and> length xd = length a\\<rbrakk>\n       \\<Longrightarrow> xd = a\n 3. \\<And>a x xa xb xc.\n       \\<lbrakk>swim_invar a i; h = a; valid a i; has_right a i;\n        has_left a i; x = pleft a i; xa = pright a i; xb = prio_of a i;\n        pleft a i < prio_of a i \\<longrightarrow>\n        \\<not> pleft a i \\<le> pright a i;\n        pright a i < pleft a i \\<and> pright a i < prio_of a i;\n        xc = exch a i (right i)\\<rbrakk>\n       \\<Longrightarrow> sink_invar (exch a i (right i)) (right i)\n 4. \\<And>a x xa xb xc xd.\n       \\<lbrakk>swim_invar a i; h = a; valid a i; has_right a i;\n        has_left a i; x = pleft a i; xa = pright a i; xb = prio_of a i;\n        pleft a i < prio_of a i \\<longrightarrow>\n        \\<not> pleft a i \\<le> pright a i;\n        pright a i < pleft a i \\<and> pright a i < prio_of a i;\n        xc = exch a i (right i);\n        \\<alpha> xd = \\<alpha> a \\<and>\n        heap_invar xd \\<and> length xd = length a\\<rbrakk>\n       \\<Longrightarrow> xd = a\n 5. \\<And>a x xa xb.\n       \\<lbrakk>swim_invar a i; h = a; valid a i; \\<not> has_right a i;\n        has_left a i; x = pleft a i; xa = prio_of a i;\n        pleft a i < prio_of a i; xb = exch a i (left i)\\<rbrakk>\n       \\<Longrightarrow> sink_invar (exch a i (left i)) (left i)\n 6. \\<And>a x xa xb xc.\n       \\<lbrakk>swim_invar a i; h = a; valid a i; \\<not> has_right a i;\n        has_left a i; x = pleft a i; xa = prio_of a i;\n        pleft a i < prio_of a i; xb = exch a i (left i);\n        \\<alpha> xc = \\<alpha> a \\<and>\n        heap_invar xc \\<and> length xc = length a\\<rbrakk>\n       \\<Longrightarrow> xc = a", "apply (auto simp: swim_invar_def) []"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a x xa xb xc xd.\n       \\<lbrakk>swim_invar a i; h = a; valid a i; has_right a i;\n        has_left a i; x = pleft a i; xa = pright a i; xb = prio_of a i;\n        pleft a i < prio_of a i \\<and> pleft a i \\<le> pright a i;\n        xc = exch a i (left i);\n        \\<alpha> xd = \\<alpha> a \\<and>\n        heap_invar xd \\<and> length xd = length a\\<rbrakk>\n       \\<Longrightarrow> xd = a\n 2. \\<And>a x xa xb xc.\n       \\<lbrakk>swim_invar a i; h = a; valid a i; has_right a i;\n        has_left a i; x = pleft a i; xa = pright a i; xb = prio_of a i;\n        pleft a i < prio_of a i \\<longrightarrow>\n        \\<not> pleft a i \\<le> pright a i;\n        pright a i < pleft a i \\<and> pright a i < prio_of a i;\n        xc = exch a i (right i)\\<rbrakk>\n       \\<Longrightarrow> sink_invar (exch a i (right i)) (right i)\n 3. \\<And>a x xa xb xc xd.\n       \\<lbrakk>swim_invar a i; h = a; valid a i; has_right a i;\n        has_left a i; x = pleft a i; xa = pright a i; xb = prio_of a i;\n        pleft a i < prio_of a i \\<longrightarrow>\n        \\<not> pleft a i \\<le> pright a i;\n        pright a i < pleft a i \\<and> pright a i < prio_of a i;\n        xc = exch a i (right i);\n        \\<alpha> xd = \\<alpha> a \\<and>\n        heap_invar xd \\<and> length xd = length a\\<rbrakk>\n       \\<Longrightarrow> xd = a\n 4. \\<And>a x xa xb.\n       \\<lbrakk>swim_invar a i; h = a; valid a i; \\<not> has_right a i;\n        has_left a i; x = pleft a i; xa = prio_of a i;\n        pleft a i < prio_of a i; xb = exch a i (left i)\\<rbrakk>\n       \\<Longrightarrow> sink_invar (exch a i (left i)) (left i)\n 5. \\<And>a x xa xb xc.\n       \\<lbrakk>swim_invar a i; h = a; valid a i; \\<not> has_right a i;\n        has_left a i; x = pleft a i; xa = prio_of a i;\n        pleft a i < prio_of a i; xb = exch a i (left i);\n        \\<alpha> xc = \\<alpha> a \\<and>\n        heap_invar xc \\<and> length xc = length a\\<rbrakk>\n       \\<Longrightarrow> xc = a", "apply (auto simp: swim_invar_def) []"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a x xa xb xc.\n       \\<lbrakk>swim_invar a i; h = a; valid a i; has_right a i;\n        has_left a i; x = pleft a i; xa = pright a i; xb = prio_of a i;\n        pleft a i < prio_of a i \\<longrightarrow>\n        \\<not> pleft a i \\<le> pright a i;\n        pright a i < pleft a i \\<and> pright a i < prio_of a i;\n        xc = exch a i (right i)\\<rbrakk>\n       \\<Longrightarrow> sink_invar (exch a i (right i)) (right i)\n 2. \\<And>a x xa xb xc xd.\n       \\<lbrakk>swim_invar a i; h = a; valid a i; has_right a i;\n        has_left a i; x = pleft a i; xa = pright a i; xb = prio_of a i;\n        pleft a i < prio_of a i \\<longrightarrow>\n        \\<not> pleft a i \\<le> pright a i;\n        pright a i < pleft a i \\<and> pright a i < prio_of a i;\n        xc = exch a i (right i);\n        \\<alpha> xd = \\<alpha> a \\<and>\n        heap_invar xd \\<and> length xd = length a\\<rbrakk>\n       \\<Longrightarrow> xd = a\n 3. \\<And>a x xa xb.\n       \\<lbrakk>swim_invar a i; h = a; valid a i; \\<not> has_right a i;\n        has_left a i; x = pleft a i; xa = prio_of a i;\n        pleft a i < prio_of a i; xb = exch a i (left i)\\<rbrakk>\n       \\<Longrightarrow> sink_invar (exch a i (left i)) (left i)\n 4. \\<And>a x xa xb xc.\n       \\<lbrakk>swim_invar a i; h = a; valid a i; \\<not> has_right a i;\n        has_left a i; x = pleft a i; xa = prio_of a i;\n        pleft a i < prio_of a i; xb = exch a i (left i);\n        \\<alpha> xc = \\<alpha> a \\<and>\n        heap_invar xc \\<and> length xc = length a\\<rbrakk>\n       \\<Longrightarrow> xc = a", "apply (auto simp: swim_invar_def) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a x xa xb xc xd.\n       \\<lbrakk>swim_invar a i; h = a; valid a i; has_right a i;\n        has_left a i; x = pleft a i; xa = pright a i; xb = prio_of a i;\n        pleft a i < prio_of a i \\<longrightarrow>\n        \\<not> pleft a i \\<le> pright a i;\n        pright a i < pleft a i \\<and> pright a i < prio_of a i;\n        xc = exch a i (right i);\n        \\<alpha> xd = \\<alpha> a \\<and>\n        heap_invar xd \\<and> length xd = length a\\<rbrakk>\n       \\<Longrightarrow> xd = a\n 2. \\<And>a x xa xb.\n       \\<lbrakk>swim_invar a i; h = a; valid a i; \\<not> has_right a i;\n        has_left a i; x = pleft a i; xa = prio_of a i;\n        pleft a i < prio_of a i; xb = exch a i (left i)\\<rbrakk>\n       \\<Longrightarrow> sink_invar (exch a i (left i)) (left i)\n 3. \\<And>a x xa xb xc.\n       \\<lbrakk>swim_invar a i; h = a; valid a i; \\<not> has_right a i;\n        has_left a i; x = pleft a i; xa = prio_of a i;\n        pleft a i < prio_of a i; xb = exch a i (left i);\n        \\<alpha> xc = \\<alpha> a \\<and>\n        heap_invar xc \\<and> length xc = length a\\<rbrakk>\n       \\<Longrightarrow> xc = a", "apply (auto simp: swim_invar_def) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a x xa xb.\n       \\<lbrakk>swim_invar a i; h = a; valid a i; \\<not> has_right a i;\n        has_left a i; x = pleft a i; xa = prio_of a i;\n        pleft a i < prio_of a i; xb = exch a i (left i)\\<rbrakk>\n       \\<Longrightarrow> sink_invar (exch a i (left i)) (left i)\n 2. \\<And>a x xa xb xc.\n       \\<lbrakk>swim_invar a i; h = a; valid a i; \\<not> has_right a i;\n        has_left a i; x = pleft a i; xa = prio_of a i;\n        pleft a i < prio_of a i; xb = exch a i (left i);\n        \\<alpha> xc = \\<alpha> a \\<and>\n        heap_invar xc \\<and> length xc = length a\\<rbrakk>\n       \\<Longrightarrow> xc = a", "apply (auto simp: swim_invar_def) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a x xa xb xc.\n       \\<lbrakk>swim_invar a i; h = a; valid a i; \\<not> has_right a i;\n        has_left a i; x = pleft a i; xa = prio_of a i;\n        pleft a i < prio_of a i; xb = exch a i (left i);\n        \\<alpha> xc = \\<alpha> a \\<and>\n        heap_invar xc \\<and> length xc = length a\\<rbrakk>\n       \\<Longrightarrow> xc = a", "apply (auto simp: swim_invar_def) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition sink_op_opt\n      \\<comment> \\<open>Sink operation as presented in Sedgewick et al. Algs4 reference implementation\\<close>\n    where   \n      \"sink_op_opt h k \\<equiv> RECT (\\<lambda>D (h,k). do {\n        ASSERT (k>0 \\<and> k\\<le>length h);\n        let len = length h;\n        if (2*k \\<le> len) then do {\n          let j = 2*k;\n          pj \\<leftarrow> prio_of_op h j;\n\n          j \\<leftarrow> (\n            if j<len then do {\n              psj \\<leftarrow> prio_of_op h (Suc j);\n              if pj>psj then RETURN (j+1) else RETURN j\n            } else RETURN j);\n\n          pj \\<leftarrow> prio_of_op h j;\n          pk \\<leftarrow> prio_of_op h k;\n          if (pk > pj) then do {\n            h \\<leftarrow> exch_op h k j;\n            D (h,j)\n          } else\n            RETURN h\n        } else RETURN h    \n      }) (h,k)\""], ["", "lemma sink_op_opt_eq: \"sink_op_opt h k = sink_op h k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sink_op_opt h k = sink_op h k", "unfolding sink_op_opt_def sink_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. REC\\<^sub>T\n     (\\<lambda>D (h, k).\n         ASSERT (0 < k \\<and> k \\<le> length h) \\<bind>\n         (\\<lambda>_.\n             let len = length h\n             in if 2 * k \\<le> len\n                then let j = 2 * k\n                     in prio_of_op h j \\<bind>\n                        (\\<lambda>pj.\n                            (if j < len\n                             then prio_of_op h (Suc j) \\<bind>\n                                  (\\<lambda>psj.\nif psj < pj then RETURN (j + 1) else RETURN j)\n                             else RETURN j) \\<bind>\n                            (\\<lambda>j.\n                                prio_of_op h j \\<bind>\n                                (\\<lambda>pj.\n                                    prio_of_op h k \\<bind>\n                                    (\\<lambda>pk.\n  if pj < pk then exch_op h k j \\<bind> (\\<lambda>h. D (h, j))\n  else RETURN h))))\n                else RETURN h))\n     (h, k) =\n    REC\\<^sub>T\n     (\\<lambda>sink (h, i).\n         ASSERT (valid h i) \\<bind>\n         (\\<lambda>_.\n             if has_right h i\n             then ASSERT (has_left h i) \\<bind>\n                  (\\<lambda>_.\n                      prio_of_op h (left i) \\<bind>\n                      (\\<lambda>lp.\n                          prio_of_op h (right i) \\<bind>\n                          (\\<lambda>rp.\n                              prio_of_op h i \\<bind>\n                              (\\<lambda>p.\n                                  if lp < p \\<and> lp \\<le> rp\n                                  then exch_op h i (left i) \\<bind>\n (\\<lambda>h. sink (h, left i))\n                                  else if rp < lp \\<and> rp < p\n then exch_op h i (right i) \\<bind> (\\<lambda>h. sink (h, right i))\n else RETURN h))))\n             else if has_left h i\n                  then prio_of_op h (left i) \\<bind>\n                       (\\<lambda>lp.\n                           prio_of_op h i \\<bind>\n                           (\\<lambda>p.\n                               if lp < p\n                               then exch_op h i (left i) \\<bind>\n                                    (\\<lambda>h. sink (h, left i))\n                               else RETURN h))\n                  else RETURN h))\n     (h, k)", "apply (fo_rule arg_cong fun_cong)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>D (h, k).\n        ASSERT (0 < k \\<and> k \\<le> length h) \\<bind>\n        (\\<lambda>_.\n            let len = length h\n            in if 2 * k \\<le> len\n               then let j = 2 * k\n                    in prio_of_op h j \\<bind>\n                       (\\<lambda>pj.\n                           (if j < len\n                            then prio_of_op h (Suc j) \\<bind>\n                                 (\\<lambda>psj.\n                                     if psj < pj then RETURN (j + 1)\n                                     else RETURN j)\n                            else RETURN j) \\<bind>\n                           (\\<lambda>j.\n                               prio_of_op h j \\<bind>\n                               (\\<lambda>pj.\n                                   prio_of_op h k \\<bind>\n                                   (\\<lambda>pk.\n if pj < pk then exch_op h k j \\<bind> (\\<lambda>h. D (h, j))\n else RETURN h))))\n               else RETURN h)) =\n    (\\<lambda>sink (h, i).\n        ASSERT (valid h i) \\<bind>\n        (\\<lambda>_.\n            if has_right h i\n            then ASSERT (has_left h i) \\<bind>\n                 (\\<lambda>_.\n                     prio_of_op h (left i) \\<bind>\n                     (\\<lambda>lp.\n                         prio_of_op h (right i) \\<bind>\n                         (\\<lambda>rp.\n                             prio_of_op h i \\<bind>\n                             (\\<lambda>p.\n                                 if lp < p \\<and> lp \\<le> rp\n                                 then exch_op h i (left i) \\<bind>\n(\\<lambda>h. sink (h, left i))\n                                 else if rp < lp \\<and> rp < p\nthen exch_op h i (right i) \\<bind> (\\<lambda>h. sink (h, right i))\nelse RETURN h))))\n            else if has_left h i\n                 then prio_of_op h (left i) \\<bind>\n                      (\\<lambda>lp.\n                          prio_of_op h i \\<bind>\n                          (\\<lambda>p.\n                              if lp < p\n                              then exch_op h i (left i) \\<bind>\n                                   (\\<lambda>h. sink (h, left i))\n                              else RETURN h))\n                 else RETURN h))", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D x.\n       (case x of\n        (h, k) \\<Rightarrow>\n          ASSERT (0 < k \\<and> k \\<le> length h) \\<bind>\n          (\\<lambda>_.\n              let len = length h\n              in if 2 * k \\<le> len\n                 then let j = 2 * k\n                      in prio_of_op h j \\<bind>\n                         (\\<lambda>pj.\n                             (if j < len\n                              then prio_of_op h (Suc j) \\<bind>\n                                   (\\<lambda>psj.\n if psj < pj then RETURN (j + 1) else RETURN j)\n                              else RETURN j) \\<bind>\n                             (\\<lambda>j.\n                                 prio_of_op h j \\<bind>\n                                 (\\<lambda>pj.\n                                     prio_of_op h k \\<bind>\n                                     (\\<lambda>pk.\n   if pj < pk then exch_op h k j \\<bind> (\\<lambda>h. D (h, j))\n   else RETURN h))))\n                 else RETURN h)) =\n       (case x of\n        (h, i) \\<Rightarrow>\n          ASSERT (valid h i) \\<bind>\n          (\\<lambda>_.\n              if has_right h i\n              then ASSERT (has_left h i) \\<bind>\n                   (\\<lambda>_.\n                       prio_of_op h (left i) \\<bind>\n                       (\\<lambda>lp.\n                           prio_of_op h (right i) \\<bind>\n                           (\\<lambda>rp.\n                               prio_of_op h i \\<bind>\n                               (\\<lambda>p.\n                                   if lp < p \\<and> lp \\<le> rp\n                                   then exch_op h i (left i) \\<bind>\n  (\\<lambda>h. D (h, left i))\n                                   else if rp < lp \\<and> rp < p\n  then exch_op h i (right i) \\<bind> (\\<lambda>h. D (h, right i))\n  else RETURN h))))\n              else if has_left h i\n                   then prio_of_op h (left i) \\<bind>\n                        (\\<lambda>lp.\n                            prio_of_op h i \\<bind>\n                            (\\<lambda>p.\n                                if lp < p\n                                then exch_op h i (left i) \\<bind>\n                                     (\\<lambda>h. D (h, left i))\n                                else RETURN h))\n                   else RETURN h))", "unfolding sink_op_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D x.\n       (case x of\n        (h, k) \\<Rightarrow>\n          ASSERT (0 < k \\<and> k \\<le> length h) \\<bind>\n          (\\<lambda>_.\n              let len = length h\n              in if 2 * k \\<le> len\n                 then let j = 2 * k\n                      in prio_of_op h j \\<bind>\n                         (\\<lambda>pj.\n                             (if j < len\n                              then prio_of_op h (Suc j) \\<bind>\n                                   (\\<lambda>psj.\n if psj < pj then RETURN (j + 1) else RETURN j)\n                              else RETURN j) \\<bind>\n                             (\\<lambda>j.\n                                 prio_of_op h j \\<bind>\n                                 (\\<lambda>pj.\n                                     prio_of_op h k \\<bind>\n                                     (\\<lambda>pk.\n   if pj < pk then exch_op h k j \\<bind> (\\<lambda>h. D (h, j))\n   else RETURN h))))\n                 else RETURN h)) =\n       (case x of\n        (h, i) \\<Rightarrow>\n          ASSERT (valid h i) \\<bind>\n          (\\<lambda>_.\n              if has_right h i\n              then ASSERT (has_left h i) \\<bind>\n                   (\\<lambda>_.\n                       prio_of_op h (left i) \\<bind>\n                       (\\<lambda>lp.\n                           prio_of_op h (right i) \\<bind>\n                           (\\<lambda>rp.\n                               prio_of_op h i \\<bind>\n                               (\\<lambda>p.\n                                   if lp < p \\<and> lp \\<le> rp\n                                   then exch_op h i (left i) \\<bind>\n  (\\<lambda>h. D (h, left i))\n                                   else if rp < lp \\<and> rp < p\n  then exch_op h i (right i) \\<bind> (\\<lambda>h. D (h, right i))\n  else RETURN h))))\n              else if has_left h i\n                   then prio_of_op h (left i) \\<bind>\n                        (\\<lambda>lp.\n                            prio_of_op h i \\<bind>\n                            (\\<lambda>p.\n                                if lp < p\n                                then exch_op h i (left i) \\<bind>\n                                     (\\<lambda>h. D (h, left i))\n                                else RETURN h))\n                   else RETURN h))", "apply (simp cong: if_cong split del: if_split add: Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D x.\n       (case x of\n        (h, k) \\<Rightarrow>\n          ASSERT (0 < k \\<and> k \\<le> length h) \\<bind>\n          (\\<lambda>_.\n              if 2 * k \\<le> length h\n              then prio_of_op h (2 * k) \\<bind>\n                   (\\<lambda>pj.\n                       if 2 * k < length h\n                       then prio_of_op h (Suc (2 * k)) \\<bind>\n                            (\\<lambda>x.\n                                if x < pj\n                                then prio_of_op h (Suc (2 * k)) \\<bind>\n                                     (\\<lambda>pj.\n   prio_of_op h k \\<bind>\n   (\\<lambda>pk.\n       if pj < pk\n       then exch_op h k (Suc (2 * k)) \\<bind>\n            (\\<lambda>h. D (h, Suc (2 * k)))\n       else RETURN h))\n                                else prio_of_op h (2 * k) \\<bind>\n                                     (\\<lambda>pj.\n   prio_of_op h k \\<bind>\n   (\\<lambda>pk.\n       if pj < pk\n       then exch_op h k (2 * k) \\<bind> (\\<lambda>h. D (h, 2 * k))\n       else RETURN h)))\n                       else prio_of_op h (2 * k) \\<bind>\n                            (\\<lambda>pj.\n                                prio_of_op h k \\<bind>\n                                (\\<lambda>pk.\n                                    if pj < pk\n                                    then exch_op h k (2 * k) \\<bind>\n   (\\<lambda>h. D (h, 2 * k))\n                                    else RETURN h)))\n              else RETURN h)) =\n       (case x of\n        (h, i) \\<Rightarrow>\n          ASSERT (valid h i) \\<bind>\n          (\\<lambda>_.\n              if has_right h i\n              then ASSERT (has_left h i) \\<bind>\n                   (\\<lambda>_.\n                       prio_of_op h (left i) \\<bind>\n                       (\\<lambda>lp.\n                           prio_of_op h (right i) \\<bind>\n                           (\\<lambda>rp.\n                               prio_of_op h i \\<bind>\n                               (\\<lambda>p.\n                                   if lp < p \\<and> lp \\<le> rp\n                                   then exch_op h i (left i) \\<bind>\n  (\\<lambda>h. D (h, left i))\n                                   else if rp < lp \\<and> rp < p\n  then exch_op h i (right i) \\<bind> (\\<lambda>h. D (h, right i))\n  else RETURN h))))\n              else if has_left h i\n                   then prio_of_op h (left i) \\<bind>\n                        (\\<lambda>lp.\n                            prio_of_op h i \\<bind>\n                            (\\<lambda>p.\n                                if lp < p\n                                then exch_op h i (left i) \\<bind>\n                                     (\\<lambda>h. D (h, left i))\n                                else RETURN h))\n                   else RETURN h))", "apply (auto simp: valid_def left_def right_def prio_of_op_def val_of_op_def \n        val_of_def less_imp_diff_less ASSERT_same_eq_conv nz_le_conv_less) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Repair\\<close>"], ["", "text \\<open>Repair a local defect in the heap. This can be done \n      by swimming and sinking. Note that, depending on the defect, only one\n      of the operations will change the heap. \n      Moreover, note that we do not need repair to implement the heap operations. \n      However, it is required for heapmaps. \\<close>"], ["", "definition \"repair_op h i \\<equiv> do {\n      h \\<leftarrow> sink_op h i;\n      h \\<leftarrow> swim_op h i;\n      RETURN h\n    }\""], ["", "lemma update_sink_swim_cases:\n      assumes \"heap_invar h\"\n      assumes \"valid h i\"\n      obtains \"swim_invar (update h i v) i\" | \"sink_invar (update h i v) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>swim_invar (update h i v) i \\<Longrightarrow> thesis;\n     sink_invar (update h i v) i \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (cases rule: linear[of \"prio v\" \"prio_of h i\", THEN disjE])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>swim_invar (update h i v) i \\<Longrightarrow> thesis;\n     sink_invar (update h i v) i \\<Longrightarrow> thesis;\n     prio v \\<le> prio_of h i\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>swim_invar (update h i v) i \\<Longrightarrow> thesis;\n     sink_invar (update h i v) i \\<Longrightarrow> thesis;\n     prio_of h i \\<le> prio v\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (blast dest: swim_invar_decr[OF assms])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>swim_invar (update h i v) i \\<Longrightarrow> thesis;\n     sink_invar (update h i v) i \\<Longrightarrow> thesis;\n     prio_of h i \\<le> prio v\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (blast dest: sink_invar_incr[OF assms])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma heap_invar_imp_swim_invar: \"\\<lbrakk>heap_invar h; valid h i\\<rbrakk> \\<Longrightarrow> swim_invar h i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heap_invar h; valid h i\\<rbrakk>\n    \\<Longrightarrow> swim_invar h i", "unfolding heap_invar_def swim_invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i.\n                valid h i \\<longrightarrow>\n                has_parent h i \\<longrightarrow>\n                pparent h i \\<le> prio_of h i;\n     valid h i\\<rbrakk>\n    \\<Longrightarrow> valid h i \\<and>\n                      (\\<forall>j.\n                          valid h j \\<and>\n                          has_parent h j \\<and>\n                          j \\<noteq> i \\<longrightarrow>\n                          pparent h j \\<le> prio_of h j) \\<and>\n                      (has_parent h i \\<longrightarrow>\n                       (\\<forall>j.\n                           valid h j \\<and>\n                           has_parent h j \\<and>\n                           parent j = i \\<longrightarrow>\n                           pparent h i \\<le> prio_of h j))", "by (auto intro: order_trans)"], ["", "lemma repair_correct[refine_vcg]:\n      assumes \"heap_invar h\" and \"valid h i\"\n      shows \"repair_op (update h i v) i \\<le> SPEC (\\<lambda>h'.\n        heap_invar h' \\<and> \\<alpha> h' = \\<alpha> (update h i v) \\<and> length h' = length h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. repair_op (update h i v) i\n    \\<le> SPEC\n           (\\<lambda>h'.\n               heap_invar h' \\<and>\n               \\<alpha> h' = \\<alpha> (update h i v) \\<and>\n               length h' = length h)", "apply (rule update_sink_swim_cases[of h i v, OF assms])"], ["proof (prove)\ngoal (2 subgoals):\n 1. swim_invar (update h i v) i \\<Longrightarrow>\n    repair_op (update h i v) i\n    \\<le> SPEC\n           (\\<lambda>h'.\n               heap_invar h' \\<and>\n               \\<alpha> h' = \\<alpha> (update h i v) \\<and>\n               length h' = length h)\n 2. sink_invar (update h i v) i \\<Longrightarrow>\n    repair_op (update h i v) i\n    \\<le> SPEC\n           (\\<lambda>h'.\n               heap_invar h' \\<and>\n               \\<alpha> h' = \\<alpha> (update h i v) \\<and>\n               length h' = length h)", "unfolding repair_op_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. swim_invar (update h i v) i \\<Longrightarrow>\n    sink_op (update h i v) i \\<bind>\n    (\\<lambda>h. swim_op h i \\<bind> RETURN)\n    \\<le> SPEC\n           (\\<lambda>h'.\n               heap_invar h' \\<and>\n               \\<alpha> h' = \\<alpha> (update h i v) \\<and>\n               length h' = length h)\n 2. sink_invar (update h i v) i \\<Longrightarrow>\n    sink_op (update h i v) i \\<bind>\n    (\\<lambda>h. swim_op h i \\<bind> RETURN)\n    \\<le> SPEC\n           (\\<lambda>h'.\n               heap_invar h' \\<and>\n               \\<alpha> h' = \\<alpha> (update h i v) \\<and>\n               length h' = length h)", "apply (refine_vcg sink_op_swim_rule)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>swim_invar (update h i v) i; x = update h i v\\<rbrakk>\n       \\<Longrightarrow> swim_invar x i\n 2. \\<And>x xa.\n       \\<lbrakk>swim_invar (update h i v) i; x = update h i v;\n        \\<alpha> xa = \\<alpha> x \\<and>\n        heap_invar xa \\<and> length xa = length x\\<rbrakk>\n       \\<Longrightarrow> heap_invar xa\n 3. \\<And>x xa.\n       \\<lbrakk>swim_invar (update h i v) i; x = update h i v;\n        \\<alpha> xa = \\<alpha> x \\<and>\n        heap_invar xa \\<and> length xa = length x\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> xa = \\<alpha> (update h i v)\n 4. \\<And>x xa.\n       \\<lbrakk>swim_invar (update h i v) i; x = update h i v;\n        \\<alpha> xa = \\<alpha> x \\<and>\n        heap_invar xa \\<and> length xa = length x\\<rbrakk>\n       \\<Longrightarrow> length xa = length h\n 5. sink_invar (update h i v) i \\<Longrightarrow>\n    sink_op (update h i v) i \\<bind>\n    (\\<lambda>h. swim_op h i \\<bind> RETURN)\n    \\<le> SPEC\n           (\\<lambda>h'.\n               heap_invar h' \\<and>\n               \\<alpha> h' = \\<alpha> (update h i v) \\<and>\n               length h' = length h)", "apply auto [4]"], ["proof (prove)\ngoal (1 subgoal):\n 1. sink_invar (update h i v) i \\<Longrightarrow>\n    sink_op (update h i v) i \\<bind>\n    (\\<lambda>h. swim_op h i \\<bind> RETURN)\n    \\<le> SPEC\n           (\\<lambda>h'.\n               heap_invar h' \\<and>\n               \\<alpha> h' = \\<alpha> (update h i v) \\<and>\n               length h' = length h)", "apply (refine_vcg)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sink_invar (update h i v) i;\n        \\<alpha> x = \\<alpha> (update h i v) \\<and>\n        heap_invar x \\<and> length x = length (update h i v)\\<rbrakk>\n       \\<Longrightarrow> swim_invar x i\n 2. \\<And>x xa.\n       \\<lbrakk>sink_invar (update h i v) i;\n        \\<alpha> x = \\<alpha> (update h i v) \\<and>\n        heap_invar x \\<and> length x = length (update h i v);\n        \\<alpha> xa = \\<alpha> x \\<and>\n        heap_invar xa \\<and> length xa = length x\\<rbrakk>\n       \\<Longrightarrow> heap_invar xa\n 3. \\<And>x xa.\n       \\<lbrakk>sink_invar (update h i v) i;\n        \\<alpha> x = \\<alpha> (update h i v) \\<and>\n        heap_invar x \\<and> length x = length (update h i v);\n        \\<alpha> xa = \\<alpha> x \\<and>\n        heap_invar xa \\<and> length xa = length x\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> xa = \\<alpha> (update h i v)\n 4. \\<And>x xa.\n       \\<lbrakk>sink_invar (update h i v) i;\n        \\<alpha> x = \\<alpha> (update h i v) \\<and>\n        heap_invar x \\<and> length x = length (update h i v);\n        \\<alpha> xa = \\<alpha> x \\<and>\n        heap_invar xa \\<and> length xa = length x\\<rbrakk>\n       \\<Longrightarrow> length xa = length h", "using assms(2)"], ["proof (prove)\nusing this:\n  valid h i\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sink_invar (update h i v) i;\n        \\<alpha> x = \\<alpha> (update h i v) \\<and>\n        heap_invar x \\<and> length x = length (update h i v)\\<rbrakk>\n       \\<Longrightarrow> swim_invar x i\n 2. \\<And>x xa.\n       \\<lbrakk>sink_invar (update h i v) i;\n        \\<alpha> x = \\<alpha> (update h i v) \\<and>\n        heap_invar x \\<and> length x = length (update h i v);\n        \\<alpha> xa = \\<alpha> x \\<and>\n        heap_invar xa \\<and> length xa = length x\\<rbrakk>\n       \\<Longrightarrow> heap_invar xa\n 3. \\<And>x xa.\n       \\<lbrakk>sink_invar (update h i v) i;\n        \\<alpha> x = \\<alpha> (update h i v) \\<and>\n        heap_invar x \\<and> length x = length (update h i v);\n        \\<alpha> xa = \\<alpha> x \\<and>\n        heap_invar xa \\<and> length xa = length x\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> xa = \\<alpha> (update h i v)\n 4. \\<And>x xa.\n       \\<lbrakk>sink_invar (update h i v) i;\n        \\<alpha> x = \\<alpha> (update h i v) \\<and>\n        heap_invar x \\<and> length x = length (update h i v);\n        \\<alpha> xa = \\<alpha> x \\<and>\n        heap_invar xa \\<and> length xa = length x\\<rbrakk>\n       \\<Longrightarrow> length xa = length h", "apply (auto intro: heap_invar_imp_swim_invar simp: valid_def) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>sink_invar (update h i v) i;\n        \\<alpha> x = \\<alpha> (update h i v) \\<and>\n        heap_invar x \\<and> length x = length (update h i v);\n        \\<alpha> xa = \\<alpha> x \\<and>\n        heap_invar xa \\<and> length xa = length x\\<rbrakk>\n       \\<Longrightarrow> heap_invar xa\n 2. \\<And>x xa.\n       \\<lbrakk>sink_invar (update h i v) i;\n        \\<alpha> x = \\<alpha> (update h i v) \\<and>\n        heap_invar x \\<and> length x = length (update h i v);\n        \\<alpha> xa = \\<alpha> x \\<and>\n        heap_invar xa \\<and> length xa = length x\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> xa = \\<alpha> (update h i v)\n 3. \\<And>x xa.\n       \\<lbrakk>sink_invar (update h i v) i;\n        \\<alpha> x = \\<alpha> (update h i v) \\<and>\n        heap_invar x \\<and> length x = length (update h i v);\n        \\<alpha> xa = \\<alpha> x \\<and>\n        heap_invar xa \\<and> length xa = length x\\<rbrakk>\n       \\<Longrightarrow> length xa = length h", "apply auto [3]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Operations\\<close>"], ["", "(*\n    subsubsection \\<open>Length\\<close>\n    definition length_op :: \"'a heap \\<Rightarrow> nat nres\" where \"length_op \\<equiv> lst_op_length\"\n\n    lemma [refine_vcg]: \"length_op l \\<le> SPEC (\\<lambda>r. r = length l)\"\n      unfolding length_op_def\n      by refine_vcg\n    *)"], ["", "subsubsection \\<open>Empty\\<close>"], ["", "abbreviation (input) empty :: \"'a heap\" \\<comment> \\<open>The empty heap\\<close>\n      where \"empty \\<equiv> []\""], ["", "definition empty_op :: \"'a heap nres\" \n      where \"empty_op \\<equiv> mop_list_empty\""], ["", "lemma empty_op_correct[refine_vcg]:\n      \"empty_op \\<le> SPEC (\\<lambda>r. \\<alpha> r = {#} \\<and> heap_invar r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. empty_op \\<le> SPEC (\\<lambda>r. \\<alpha> r = {#} \\<and> heap_invar r)", "unfolding empty_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mop_list_empty\n    \\<le> SPEC (\\<lambda>r. \\<alpha> r = {#} \\<and> heap_invar r)", "apply refine_vcg"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<alpha> [] = {#}\n 2. heap_invar []", "by auto"], ["", "subsubsection \\<open>Emptiness check\\<close>"], ["", "definition is_empty_op :: \"'a heap \\<Rightarrow> bool nres\" \\<comment> \\<open>Check for emptiness\\<close>\n      where \"is_empty_op h \\<equiv> do {ASSERT (heap_invar h); let l=length h; RETURN (l=0)}\""], ["", "lemma is_empty_op_correct[refine_vcg]: \n      \"heap_invar h \\<Longrightarrow> is_empty_op h \\<le> SPEC (\\<lambda>r. r\\<longleftrightarrow>\\<alpha> h = {#})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_invar h \\<Longrightarrow>\n    is_empty_op h \\<le> SPEC (\\<lambda>r. r = (\\<alpha> h = {#}))", "unfolding is_empty_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_invar h \\<Longrightarrow>\n    ASSERT (heap_invar h) \\<bind>\n    (\\<lambda>_. let l = length h in RETURN (l = 0))\n    \\<le> SPEC (\\<lambda>r. r = (\\<alpha> h = {#}))", "apply refine_vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heap_invar h; heap_invar h\\<rbrakk>\n    \\<Longrightarrow> (length h = 0) = (\\<alpha> h = {#})", "by auto"], ["", "subsubsection \\<open>Insert\\<close>"], ["", "definition insert_op :: \"'a \\<Rightarrow> 'a heap \\<Rightarrow> 'a heap nres\" \\<comment> \\<open>Insert element\\<close>\n      where \"insert_op v h \\<equiv> do {\n        ASSERT (heap_invar h);\n        h \\<leftarrow> append_op h v;\n        let l = length h;\n        h \\<leftarrow> swim_op h l;\n        RETURN h\n      }\""], ["", "lemma swim_invar_insert: \"heap_invar l \\<Longrightarrow> swim_invar (l@[x]) (Suc (length l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_invar l \\<Longrightarrow> swim_invar (l @ [x]) (Suc (length l))", "unfolding swim_invar_def heap_invar_def valid_def parent_def val_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       0 < i \\<and> i \\<le> length l \\<longrightarrow>\n       0 < i div 2 \\<and> i div 2 \\<le> length l \\<longrightarrow>\n       prio (l ! (i div 2 - 1)) \\<le> prio (l ! (i - 1)) \\<Longrightarrow>\n    (0 < Suc (length l) \\<and> Suc (length l) \\<le> length (l @ [x])) \\<and>\n    (\\<forall>j.\n        (0 < j \\<and> j \\<le> length (l @ [x])) \\<and>\n        (0 < j div 2 \\<and> j div 2 \\<le> length (l @ [x])) \\<and>\n        j \\<noteq> Suc (length l) \\<longrightarrow>\n        prio ((l @ [x]) ! (j div 2 - 1))\n        \\<le> prio ((l @ [x]) ! (j - 1))) \\<and>\n    (0 < Suc (length l) div 2 \\<and>\n     Suc (length l) div 2 \\<le> length (l @ [x]) \\<longrightarrow>\n     (\\<forall>j.\n         (0 < j \\<and> j \\<le> length (l @ [x])) \\<and>\n         (0 < j div 2 \\<and> j div 2 \\<le> length (l @ [x])) \\<and>\n         j div 2 = Suc (length l) \\<longrightarrow>\n         prio ((l @ [x]) ! (Suc (length l) div 2 - 1))\n         \\<le> prio ((l @ [x]) ! (j - 1))))", "by (fastforce simp: nth_append)"], ["", "lemma  \n      \"(insert_op,RETURN oo op_mset_insert) \\<in> Id \\<rightarrow> heap_rel1 \\<rightarrow> \\<langle>heap_rel1\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (insert_op, RETURN \\<circ>\\<circ> op_mset_insert)\n    \\<in> Id \\<rightarrow>\n          heap_rel1 \\<rightarrow> \\<langle>heap_rel1\\<rangle>nres_rel", "unfolding insert_op_def[abs_def] heap_rel1_def o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>v h.\n        ASSERT (heap_invar h) \\<bind>\n        (\\<lambda>_.\n            append_op h v \\<bind>\n            (\\<lambda>h. let l = length h in swim_op h l \\<bind> RETURN)),\n     \\<lambda>x xa. RETURN (op_mset_insert x xa))\n    \\<in> Id \\<rightarrow>\n          br \\<alpha> heap_invar \\<rightarrow>\n          \\<langle>br \\<alpha> heap_invar\\<rangle>nres_rel", "by refine_vcg (auto simp: swim_invar_insert in_br_conv)"], ["", "lemma insert_op_correct:\n      \"heap_invar h \\<Longrightarrow> insert_op v h \\<le> SPEC (\\<lambda>h'. heap_invar h' \\<and> \\<alpha> h' = \\<alpha> h + {#v#})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_invar h \\<Longrightarrow>\n    insert_op v h\n    \\<le> SPEC\n           (\\<lambda>h'.\n               heap_invar h' \\<and> \\<alpha> h' = \\<alpha> h + {#v#})", "unfolding insert_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_invar h \\<Longrightarrow>\n    ASSERT (heap_invar h) \\<bind>\n    (\\<lambda>_.\n        append_op h v \\<bind>\n        (\\<lambda>h. let l = length h in swim_op h l \\<bind> RETURN))\n    \\<le> SPEC\n           (\\<lambda>h'.\n               heap_invar h' \\<and> \\<alpha> h' = \\<alpha> h + {#v#})", "by (refine_vcg) (auto simp: swim_invar_insert)"], ["", "lemmas [refine_vcg] = insert_op_correct"], ["", "subsubsection \\<open>Pop minimum element\\<close>"], ["", "definition pop_min_op :: \"'a heap \\<Rightarrow> ('a \\<times> 'a heap) nres\" where\n      \"pop_min_op h \\<equiv> do {\n        ASSERT (heap_invar h);\n        ASSERT (valid h 1);\n        m \\<leftarrow> val_of_op h 1;\n        let l = length h;\n        h \\<leftarrow> exch_op h 1 l;\n        h \\<leftarrow> butlast_op h;\n        \n        if (l\\<noteq>1) then do {\n          h \\<leftarrow> sink_op h 1;\n          RETURN (m,h)\n        } else RETURN (m,h)\n      }\""], ["", "lemma left_not_one[simp]: \"left j \\<noteq> Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left j \\<noteq> Suc 0", "by (auto simp: left_def)"], ["", "lemma right_one_conv[simp]: \"right j = Suc 0 \\<longleftrightarrow> j=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (right j = Suc 0) = (j = 0)", "by (auto simp: right_def)"], ["", "lemma parent_one_conv[simp]: \"parent (Suc 0) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parent (Suc 0) = 0", "by (auto simp: parent_def)"], ["", "lemma sink_invar_init:\n      assumes I: \"heap_invar h\" \n      assumes NE: \"length h > 1\" \n      shows \"sink_invar (butlast (exch h (Suc 0) (length h))) (Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sink_invar (butlast (exch h (Suc 0) (length h))) (Suc 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sink_invar (butlast (exch h (Suc 0) (length h))) (Suc 0)", "from NE"], ["proof (chain)\npicking this:\n  1 < length h", "have V: \"valid h (Suc 0)\" \"valid h (length h)\""], ["proof (prove)\nusing this:\n  1 < length h\n\ngoal (1 subgoal):\n 1. valid h (Suc 0) &&& valid h (length h)", "apply -"], ["proof (prove)\ngoal (2 subgoals):\n 1. 1 < length h \\<Longrightarrow> valid h (Suc 0)\n 2. 1 < length h \\<Longrightarrow> valid h (length h)", "apply (auto simp: valid_def neq_Nil_conv) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < length h \\<Longrightarrow> valid h (length h)", "by (cases h) (auto simp: valid_def)"], ["proof (state)\nthis:\n  valid h (Suc 0)\n  valid h (length h)\n\ngoal (1 subgoal):\n 1. sink_invar (butlast (exch h (Suc 0) (length h))) (Suc 0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sink_invar (butlast (exch h (Suc 0) (length h))) (Suc 0)", "using I"], ["proof (prove)\nusing this:\n  heap_invar h\n\ngoal (1 subgoal):\n 1. sink_invar (butlast (exch h (Suc 0) (length h))) (Suc 0)", "unfolding heap_eq_heap' heap_invar'_def sink_invar_def"], ["proof (prove)\nusing this:\n  \\<forall>i. valid h i \\<longrightarrow> children_ge h (prio_of h i) i\n\ngoal (1 subgoal):\n 1. valid (butlast (exch h (Suc 0) (length h))) (Suc 0) \\<and>\n    (\\<forall>j.\n        valid (butlast (exch h (Suc 0) (length h))) j \\<and>\n        j \\<noteq> Suc 0 \\<longrightarrow>\n        children_ge (butlast (exch h (Suc 0) (length h)))\n         (prio_of (butlast (exch h (Suc 0) (length h))) j) j) \\<and>\n    (has_parent (butlast (exch h (Suc 0) (length h)))\n      (Suc 0) \\<longrightarrow>\n     children_ge (butlast (exch h (Suc 0) (length h)))\n      (pparent (butlast (exch h (Suc 0) (length h))) (Suc 0)) (Suc 0))", "apply (intro impI conjI allI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>i.\n       valid h i \\<longrightarrow>\n       children_ge h (prio_of h i) i \\<Longrightarrow>\n    valid (butlast (exch h (Suc 0) (length h))) (Suc 0)\n 2. \\<And>j.\n       \\<lbrakk>\\<forall>i.\n                   valid h i \\<longrightarrow>\n                   children_ge h (prio_of h i) i;\n        valid (butlast (exch h (Suc 0) (length h))) j \\<and>\n        j \\<noteq> Suc 0\\<rbrakk>\n       \\<Longrightarrow> children_ge (butlast (exch h (Suc 0) (length h)))\n                          (prio_of (butlast (exch h (Suc 0) (length h))) j)\n                          j\n 3. \\<lbrakk>\\<forall>i.\n                valid h i \\<longrightarrow> children_ge h (prio_of h i) i;\n     has_parent (butlast (exch h (Suc 0) (length h))) (Suc 0)\\<rbrakk>\n    \\<Longrightarrow> children_ge (butlast (exch h (Suc 0) (length h)))\n                       (pparent (butlast (exch h (Suc 0) (length h)))\n                         (Suc 0))\n                       (Suc 0)", "using NE"], ["proof (prove)\nusing this:\n  1 < length h\n\ngoal (3 subgoals):\n 1. \\<forall>i.\n       valid h i \\<longrightarrow>\n       children_ge h (prio_of h i) i \\<Longrightarrow>\n    valid (butlast (exch h (Suc 0) (length h))) (Suc 0)\n 2. \\<And>j.\n       \\<lbrakk>\\<forall>i.\n                   valid h i \\<longrightarrow>\n                   children_ge h (prio_of h i) i;\n        valid (butlast (exch h (Suc 0) (length h))) j \\<and>\n        j \\<noteq> Suc 0\\<rbrakk>\n       \\<Longrightarrow> children_ge (butlast (exch h (Suc 0) (length h)))\n                          (prio_of (butlast (exch h (Suc 0) (length h))) j)\n                          j\n 3. \\<lbrakk>\\<forall>i.\n                valid h i \\<longrightarrow> children_ge h (prio_of h i) i;\n     has_parent (butlast (exch h (Suc 0) (length h))) (Suc 0)\\<rbrakk>\n    \\<Longrightarrow> children_ge (butlast (exch h (Suc 0) (length h)))\n                       (pparent (butlast (exch h (Suc 0) (length h)))\n                         (Suc 0))\n                       (Suc 0)", "apply (auto simp: V valid_butlast_conv) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>\\<forall>i.\n                   valid h i \\<longrightarrow>\n                   children_ge h (prio_of h i) i;\n        valid (butlast (exch h (Suc 0) (length h))) j \\<and>\n        j \\<noteq> Suc 0\\<rbrakk>\n       \\<Longrightarrow> children_ge (butlast (exch h (Suc 0) (length h)))\n                          (prio_of (butlast (exch h (Suc 0) (length h))) j)\n                          j\n 2. \\<lbrakk>\\<forall>i.\n                valid h i \\<longrightarrow> children_ge h (prio_of h i) i;\n     has_parent (butlast (exch h (Suc 0) (length h))) (Suc 0)\\<rbrakk>\n    \\<Longrightarrow> children_ge (butlast (exch h (Suc 0) (length h)))\n                       (pparent (butlast (exch h (Suc 0) (length h)))\n                         (Suc 0))\n                       (Suc 0)", "apply (auto simp add: children_ge_def V NE valid_butlast_conv) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i.\n                valid h i \\<longrightarrow> children_ge h (prio_of h i) i;\n     has_parent (butlast (exch h (Suc 0) (length h))) (Suc 0)\\<rbrakk>\n    \\<Longrightarrow> children_ge (butlast (exch h (Suc 0) (length h)))\n                       (pparent (butlast (exch h (Suc 0) (length h)))\n                         (Suc 0))\n                       (Suc 0)", "apply (auto simp add: children_ge_def V NE valid_butlast_conv) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sink_invar (butlast (exch h (Suc 0) (length h))) (Suc 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_set_conv_val: \"v \\<in> set h \\<longleftrightarrow> (\\<exists>i. valid h i \\<and> v = val_of h i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v \\<in> set h) = (\\<exists>i. valid h i \\<and> v = val_of h i)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. v \\<in> set h \\<Longrightarrow>\n    \\<exists>i. valid h i \\<and> v = val_of h i\n 2. \\<exists>i. valid h i \\<and> v = val_of h i \\<Longrightarrow>\n    v \\<in> set h", "apply (clarsimp simp add: valid_def val_of_def in_set_conv_nth)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < length h; v = h ! i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia>0.\n                            ia \\<le> length h \\<and>\n                            h ! i = h ! (ia - Suc 0)\n 2. \\<exists>i. valid h i \\<and> v = val_of h i \\<Longrightarrow>\n    v \\<in> set h", "apply (rule_tac x=\"Suc i\" in exI; auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i. valid h i \\<and> v = val_of h i \\<Longrightarrow>\n    v \\<in> set h", "apply (clarsimp simp add: valid_def val_of_def in_set_conv_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>0 < i; i \\<le> length h; v = h ! (i - Suc 0)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia<length h. h ! ia = h ! (i - Suc 0)", "apply (rule_tac x=\"i - Suc 0\" in exI; auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pop_min_op_correct: \n      assumes \"heap_invar h\" \"\\<alpha> h \\<noteq> {#}\" \n      shows \"pop_min_op h \\<le> SPEC (\\<lambda>(v,h'). heap_invar h' \\<and>\n        v \\<in># \\<alpha> h \\<and> \\<alpha> h' = \\<alpha> h - {#v#} \\<and> (\\<forall>v'\\<in>set_mset (\\<alpha> h). prio v \\<le> prio v'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pop_min_op h\n    \\<le> SPEC\n           (\\<lambda>(v, h').\n               heap_invar h' \\<and>\n               v \\<in># \\<alpha> h \\<and>\n               \\<alpha> h' = \\<alpha> h - {#v#} \\<and>\n               (\\<forall>v'\\<in>#\\<alpha> h. prio v \\<le> prio v'))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pop_min_op h\n    \\<le> SPEC\n           (\\<lambda>(v, h').\n               heap_invar h' \\<and>\n               v \\<in># \\<alpha> h \\<and>\n               \\<alpha> h' = \\<alpha> h - {#v#} \\<and>\n               (\\<forall>v'\\<in>#\\<alpha> h. prio v \\<le> prio v'))", "note [simp del] = length_greater_0_conv"], ["proof (state)\nthis:\n  (0 < length ?xs) = (?xs \\<noteq> [])\n\ngoal (1 subgoal):\n 1. pop_min_op h\n    \\<le> SPEC\n           (\\<lambda>(v, h').\n               heap_invar h' \\<and>\n               v \\<in># \\<alpha> h \\<and>\n               \\<alpha> h' = \\<alpha> h - {#v#} \\<and>\n               (\\<forall>v'\\<in>#\\<alpha> h. prio v \\<le> prio v'))", "note LG = length_greater_0_conv[symmetric]"], ["proof (state)\nthis:\n  (?xs \\<noteq> []) = (0 < length ?xs)\n\ngoal (1 subgoal):\n 1. pop_min_op h\n    \\<le> SPEC\n           (\\<lambda>(v, h').\n               heap_invar h' \\<and>\n               v \\<in># \\<alpha> h \\<and>\n               \\<alpha> h' = \\<alpha> h - {#v#} \\<and>\n               (\\<forall>v'\\<in>#\\<alpha> h. prio v \\<le> prio v'))", "from assms"], ["proof (chain)\npicking this:\n  heap_invar h\n  \\<alpha> h \\<noteq> {#}", "show ?thesis"], ["proof (prove)\nusing this:\n  heap_invar h\n  \\<alpha> h \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. pop_min_op h\n    \\<le> SPEC\n           (\\<lambda>(v, h').\n               heap_invar h' \\<and>\n               v \\<in># \\<alpha> h \\<and>\n               \\<alpha> h' = \\<alpha> h - {#v#} \\<and>\n               (\\<forall>v'\\<in>#\\<alpha> h. prio v \\<le> prio v'))", "unfolding pop_min_op_def"], ["proof (prove)\nusing this:\n  heap_invar h\n  \\<alpha> h \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. ASSERT (heap_invar h) \\<bind>\n    (\\<lambda>_.\n        ASSERT (valid h 1) \\<bind>\n        (\\<lambda>_.\n            val_of_op h 1 \\<bind>\n            (\\<lambda>m.\n                let l = length h\n                in exch_op h 1 l \\<bind>\n                   (\\<lambda>h.\n                       butlast_op h \\<bind>\n                       (\\<lambda>h.\n                           if l \\<noteq> 1\n                           then sink_op h 1 \\<bind>\n                                (\\<lambda>h. RETURN (m, h))\n                           else RETURN (m, h))))))\n    \\<le> SPEC\n           (\\<lambda>(v, h').\n               heap_invar h' \\<and>\n               v \\<in># \\<alpha> h \\<and>\n               \\<alpha> h' = \\<alpha> h - {#v#} \\<and>\n               (\\<forall>v'\\<in>#\\<alpha> h. prio v \\<le> prio v'))", "apply refine_vcg"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<lbrakk>heap_invar h; \\<alpha> h \\<noteq> {#}; heap_invar h\\<rbrakk>\n    \\<Longrightarrow> valid h 1\n 2. \\<And>x.\n       \\<lbrakk>heap_invar h; \\<alpha> h \\<noteq> {#}; heap_invar h;\n        valid h 1; x = val_of h 1\\<rbrakk>\n       \\<Longrightarrow> valid h (length h)\n 3. \\<And>x xa.\n       \\<lbrakk>heap_invar h; \\<alpha> h \\<noteq> {#}; heap_invar h;\n        valid h 1; x = val_of h 1; xa = exch h 1 (length h)\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> []\n 4. \\<And>x xa xb.\n       \\<lbrakk>heap_invar h; \\<alpha> h \\<noteq> {#}; heap_invar h;\n        valid h 1; x = val_of h 1; xa = exch h 1 (length h);\n        xb = butlast xa; length h \\<noteq> 1\\<rbrakk>\n       \\<Longrightarrow> sink_invar xb 1\n 5. \\<And>x xa xb xc x1 x2.\n       \\<lbrakk>heap_invar h; \\<alpha> h \\<noteq> {#}; heap_invar h;\n        valid h 1; x = val_of h 1; xa = exch h 1 (length h);\n        xb = butlast xa; length h \\<noteq> 1;\n        \\<alpha> xc = \\<alpha> xb \\<and>\n        heap_invar xc \\<and> length xc = length xb;\n        (x, xc) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> heap_invar x2\n 6. \\<And>x xa xb xc x1 x2.\n       \\<lbrakk>heap_invar h; \\<alpha> h \\<noteq> {#}; heap_invar h;\n        valid h 1; x = val_of h 1; xa = exch h 1 (length h);\n        xb = butlast xa; length h \\<noteq> 1;\n        \\<alpha> xc = \\<alpha> xb \\<and>\n        heap_invar xc \\<and> length xc = length xb;\n        (x, xc) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x1 \\<in># \\<alpha> h\n 7. \\<And>x xa xb xc x1 x2.\n       \\<lbrakk>heap_invar h; \\<alpha> h \\<noteq> {#}; heap_invar h;\n        valid h 1; x = val_of h 1; xa = exch h 1 (length h);\n        xb = butlast xa; length h \\<noteq> 1;\n        \\<alpha> xc = \\<alpha> xb \\<and>\n        heap_invar xc \\<and> length xc = length xb;\n        (x, xc) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> x2 = \\<alpha> h - {#x1#}\n 8. \\<And>x xa xb xc x1 x2.\n       \\<lbrakk>heap_invar h; \\<alpha> h \\<noteq> {#}; heap_invar h;\n        valid h 1; x = val_of h 1; xa = exch h 1 (length h);\n        xb = butlast xa; length h \\<noteq> 1;\n        \\<alpha> xc = \\<alpha> xb \\<and>\n        heap_invar xc \\<and> length xc = length xb;\n        (x, xc) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v'\\<in>#\\<alpha> h. prio x1 \\<le> prio v'\n 9. \\<And>x xa xb x1 x2.\n       \\<lbrakk>heap_invar h; \\<alpha> h \\<noteq> {#}; heap_invar h;\n        valid h 1; x = val_of h 1; xa = exch h 1 (length h);\n        xb = butlast xa; \\<not> length h \\<noteq> 1;\n        (x, xb) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> heap_invar x2\n 10. \\<And>x xa xb x1 x2.\n        \\<lbrakk>heap_invar h; \\<alpha> h \\<noteq> {#}; heap_invar h;\n         valid h 1; x = val_of h 1; xa = exch h 1 (length h);\n         xb = butlast xa; \\<not> length h \\<noteq> 1;\n         (x, xb) = (x1, x2)\\<rbrakk>\n        \\<Longrightarrow> x1 \\<in># \\<alpha> h\nA total of 12 subgoals...", "apply (simp_all add: sink_invar_init LG)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>0 < length h; heap_invar h\\<rbrakk>\n    \\<Longrightarrow> valid h (Suc 0)\n 2. \\<And>x xa xb xc x1.\n       \\<lbrakk>0 < length h; heap_invar h; valid h (Suc 0); x = x1;\n        xa = exch h (Suc 0) (length h);\n        xb = butlast (exch h (Suc 0) (length h)); length h \\<noteq> Suc 0;\n        \\<alpha> xc = \\<alpha> h - {#x1#} \\<and>\n        heap_invar xc \\<and> length xc = length h - Suc 0;\n        val_of h (Suc 0) = x1\\<rbrakk>\n       \\<Longrightarrow> x1 \\<in> set h\n 3. \\<And>x xa xb xc x1.\n       \\<lbrakk>0 < length h; heap_invar h; valid h (Suc 0); x = x1;\n        xa = exch h (Suc 0) (length h);\n        xb = butlast (exch h (Suc 0) (length h)); length h \\<noteq> Suc 0;\n        \\<alpha> xc = \\<alpha> h - {#x1#} \\<and>\n        heap_invar xc \\<and> length xc = length h - Suc 0;\n        val_of h (Suc 0) = x1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v'\\<in>set h. prio x1 \\<le> prio v'\n 4. \\<And>x xa xb x1.\n       \\<lbrakk>heap_invar h; valid h (Suc 0); x = x1; xa = h;\n        xb = butlast h; length h = Suc 0; val_of h (Suc 0) = x1\\<rbrakk>\n       \\<Longrightarrow> x1 \\<in> set h\n 5. \\<And>x xa xb x1.\n       \\<lbrakk>heap_invar h; valid h (Suc 0); x = x1; xa = h;\n        xb = butlast h; length h = Suc 0; val_of h (Suc 0) = x1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v'\\<in>set h. prio x1 \\<le> prio v'", "apply (auto simp: valid_def) []"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xa xb xc x1.\n       \\<lbrakk>0 < length h; heap_invar h; valid h (Suc 0); x = x1;\n        xa = exch h (Suc 0) (length h);\n        xb = butlast (exch h (Suc 0) (length h)); length h \\<noteq> Suc 0;\n        \\<alpha> xc = \\<alpha> h - {#x1#} \\<and>\n        heap_invar xc \\<and> length xc = length h - Suc 0;\n        val_of h (Suc 0) = x1\\<rbrakk>\n       \\<Longrightarrow> x1 \\<in> set h\n 2. \\<And>x xa xb xc x1.\n       \\<lbrakk>0 < length h; heap_invar h; valid h (Suc 0); x = x1;\n        xa = exch h (Suc 0) (length h);\n        xb = butlast (exch h (Suc 0) (length h)); length h \\<noteq> Suc 0;\n        \\<alpha> xc = \\<alpha> h - {#x1#} \\<and>\n        heap_invar xc \\<and> length xc = length h - Suc 0;\n        val_of h (Suc 0) = x1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v'\\<in>set h. prio x1 \\<le> prio v'\n 3. \\<And>x xa xb x1.\n       \\<lbrakk>heap_invar h; valid h (Suc 0); x = x1; xa = h;\n        xb = butlast h; length h = Suc 0; val_of h (Suc 0) = x1\\<rbrakk>\n       \\<Longrightarrow> x1 \\<in> set h\n 4. \\<And>x xa xb x1.\n       \\<lbrakk>heap_invar h; valid h (Suc 0); x = x1; xa = h;\n        xb = butlast h; length h = Suc 0; val_of h (Suc 0) = x1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v'\\<in>set h. prio x1 \\<le> prio v'", "apply (cases h; auto simp: val_of_def) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa xb xc x1.\n       \\<lbrakk>0 < length h; heap_invar h; valid h (Suc 0); x = x1;\n        xa = exch h (Suc 0) (length h);\n        xb = butlast (exch h (Suc 0) (length h)); length h \\<noteq> Suc 0;\n        \\<alpha> xc = \\<alpha> h - {#x1#} \\<and>\n        heap_invar xc \\<and> length xc = length h - Suc 0;\n        val_of h (Suc 0) = x1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v'\\<in>set h. prio x1 \\<le> prio v'\n 2. \\<And>x xa xb x1.\n       \\<lbrakk>heap_invar h; valid h (Suc 0); x = x1; xa = h;\n        xb = butlast h; length h = Suc 0; val_of h (Suc 0) = x1\\<rbrakk>\n       \\<Longrightarrow> x1 \\<in> set h\n 3. \\<And>x xa xb x1.\n       \\<lbrakk>heap_invar h; valid h (Suc 0); x = x1; xa = h;\n        xb = butlast h; length h = Suc 0; val_of h (Suc 0) = x1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v'\\<in>set h. prio x1 \\<le> prio v'", "(* FIXME: Looking below val_of! *)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa xb xc x1.\n       \\<lbrakk>0 < length h; heap_invar h; valid h (Suc 0); x = x1;\n        xa = exch h (Suc 0) (length h);\n        xb = butlast (exch h (Suc 0) (length h)); length h \\<noteq> Suc 0;\n        \\<alpha> xc = \\<alpha> h - {#x1#} \\<and>\n        heap_invar xc \\<and> length xc = length h - Suc 0;\n        val_of h (Suc 0) = x1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v'\\<in>set h. prio x1 \\<le> prio v'\n 2. \\<And>x xa xb x1.\n       \\<lbrakk>heap_invar h; valid h (Suc 0); x = x1; xa = h;\n        xb = butlast h; length h = Suc 0; val_of h (Suc 0) = x1\\<rbrakk>\n       \\<Longrightarrow> x1 \\<in> set h\n 3. \\<And>x xa xb x1.\n       \\<lbrakk>heap_invar h; valid h (Suc 0); x = x1; xa = h;\n        xb = butlast h; length h = Suc 0; val_of h (Suc 0) = x1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v'\\<in>set h. prio x1 \\<le> prio v'", "apply (auto simp: in_set_conv_val simp: heap_min_prop) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa xb x1.\n       \\<lbrakk>heap_invar h; valid h (Suc 0); x = x1; xa = h;\n        xb = butlast h; length h = Suc 0; val_of h (Suc 0) = x1\\<rbrakk>\n       \\<Longrightarrow> x1 \\<in> set h\n 2. \\<And>x xa xb x1.\n       \\<lbrakk>heap_invar h; valid h (Suc 0); x = x1; xa = h;\n        xb = butlast h; length h = Suc 0; val_of h (Suc 0) = x1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v'\\<in>set h. prio x1 \\<le> prio v'", "apply auto []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>heap_invar h; valid h (Suc 0); length h = Suc 0\\<rbrakk>\n    \\<Longrightarrow> val_of h (Suc 0) \\<in> set h\n 2. \\<And>x xa xb x1.\n       \\<lbrakk>heap_invar h; valid h (Suc 0); x = x1; xa = h;\n        xb = butlast h; length h = Suc 0; val_of h (Suc 0) = x1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v'\\<in>set h. prio x1 \\<le> prio v'", "apply (cases h; auto simp: val_of_def) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb x1.\n       \\<lbrakk>heap_invar h; valid h (Suc 0); x = x1; xa = h;\n        xb = butlast h; length h = Suc 0; val_of h (Suc 0) = x1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v'\\<in>set h. prio x1 \\<le> prio v'", "(* FIXME: Looking below val_of! *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb x1.\n       \\<lbrakk>heap_invar h; valid h (Suc 0); x = x1; xa = h;\n        xb = butlast h; length h = Suc 0; val_of h (Suc 0) = x1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v'\\<in>set h. prio x1 \\<le> prio v'", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v'.\n       \\<lbrakk>heap_invar h; valid h (Suc 0); length h = Suc 0;\n        v' \\<in> set h\\<rbrakk>\n       \\<Longrightarrow> prio_of h (Suc 0) \\<le> prio v'", "apply (cases h; auto simp: val_of_def) []"], ["proof (prove)\ngoal:\nNo subgoals!", "(* FIXME: Looking below val_of! *)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  pop_min_op h\n  \\<le> SPEC\n         (\\<lambda>(v, h').\n             heap_invar h' \\<and>\n             v \\<in># \\<alpha> h \\<and>\n             \\<alpha> h' = \\<alpha> h - {#v#} \\<and>\n             (\\<forall>v'\\<in>#\\<alpha> h. prio v \\<le> prio v'))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas [refine_vcg] = pop_min_op_correct"], ["", "subsubsection \\<open>Peek minimum element\\<close>"], ["", "definition peek_min_op :: \"'a heap \\<Rightarrow> 'a nres\" where\n      \"peek_min_op h \\<equiv> do {\n        ASSERT (heap_invar h);\n        ASSERT (valid h 1);\n        val_of_op h 1\n      }\""], ["", "lemma peek_min_op_correct:\n      assumes \"heap_invar h\" \"\\<alpha> h \\<noteq> {#}\" \n      shows \"peek_min_op h \\<le> SPEC (\\<lambda>v. \n        v \\<in># \\<alpha> h \\<and> (\\<forall>v'\\<in>set_mset (\\<alpha> h). prio v \\<le> prio v'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. peek_min_op h\n    \\<le> SPEC\n           (\\<lambda>v.\n               v \\<in># \\<alpha> h \\<and>\n               (\\<forall>v'\\<in>#\\<alpha> h. prio v \\<le> prio v'))", "unfolding peek_min_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (heap_invar h) \\<bind>\n    (\\<lambda>_. ASSERT (valid h 1) \\<bind> (\\<lambda>_. val_of_op h 1))\n    \\<le> SPEC\n           (\\<lambda>v.\n               v \\<in># \\<alpha> h \\<and>\n               (\\<forall>v'\\<in>#\\<alpha> h. prio v \\<le> prio v'))", "apply refine_vcg"], ["proof (prove)\ngoal (4 subgoals):\n 1. heap_invar h\n 2. heap_invar h \\<Longrightarrow> valid h 1\n 3. \\<And>x.\n       \\<lbrakk>heap_invar h; valid h 1; x = val_of h 1\\<rbrakk>\n       \\<Longrightarrow> x \\<in># \\<alpha> h\n 4. \\<And>x.\n       \\<lbrakk>heap_invar h; valid h 1; x = val_of h 1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v'\\<in>#\\<alpha> h. prio x \\<le> prio v'", "using assms"], ["proof (prove)\nusing this:\n  heap_invar h\n  \\<alpha> h \\<noteq> {#}\n\ngoal (4 subgoals):\n 1. heap_invar h\n 2. heap_invar h \\<Longrightarrow> valid h 1\n 3. \\<And>x.\n       \\<lbrakk>heap_invar h; valid h 1; x = val_of h 1\\<rbrakk>\n       \\<Longrightarrow> x \\<in># \\<alpha> h\n 4. \\<And>x.\n       \\<lbrakk>heap_invar h; valid h 1; x = val_of h 1\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v'\\<in>#\\<alpha> h. prio x \\<le> prio v'", "apply clarsimp_all"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>heap_invar h; h \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> valid h (Suc 0)\n 2. \\<lbrakk>valid h (Suc 0); heap_invar h; h \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> val_of h (Suc 0) \\<in> set h\n 3. \\<And>v'.\n       \\<lbrakk>valid h (Suc 0); heap_invar h; h \\<noteq> [];\n        v' \\<in> set h\\<rbrakk>\n       \\<Longrightarrow> prio_of h (Suc 0) \\<le> prio v'", "apply (auto simp: valid_def) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>valid h (Suc 0); heap_invar h; h \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> val_of h (Suc 0) \\<in> set h\n 2. \\<And>v'.\n       \\<lbrakk>valid h (Suc 0); heap_invar h; h \\<noteq> [];\n        v' \\<in> set h\\<rbrakk>\n       \\<Longrightarrow> prio_of h (Suc 0) \\<le> prio v'", "apply (cases h; auto simp: val_of_def) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v'.\n       \\<lbrakk>valid h (Suc 0); heap_invar h; h \\<noteq> [];\n        v' \\<in> set h\\<rbrakk>\n       \\<Longrightarrow> prio_of h (Suc 0) \\<le> prio v'", "(* FIXME: Looking below val_of! *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v'.\n       \\<lbrakk>valid h (Suc 0); heap_invar h; h \\<noteq> [];\n        v' \\<in> set h\\<rbrakk>\n       \\<Longrightarrow> prio_of h (Suc 0) \\<le> prio v'", "apply (auto simp: in_set_conv_val simp: heap_min_prop) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas peek_min_op_correct'[refine_vcg] = peek_min_op_correct"], ["", "subsection \\<open>Operations as Relator-Style Refinement\\<close>"], ["", "lemma empty_op_refine: \"(empty_op,RETURN op_mset_empty)\\<in>\\<langle>heap_rel1\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (empty_op, RETURN op_mset_empty)\n    \\<in> \\<langle>heap_rel1\\<rangle>nres_rel", "apply (rule nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. empty_op \\<le> \\<Down> heap_rel1 (RETURN op_mset_empty)", "apply (rule order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. empty_op \\<le> ?y2\n 2. ?y2 \\<le> \\<Down> heap_rel1 (RETURN op_mset_empty)", "apply (rule empty_op_correct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. SPEC (\\<lambda>r. \\<alpha> r = {#} \\<and> heap_invar r)\n    \\<le> \\<Down> heap_rel1 (RETURN op_mset_empty)", "apply (auto simp: heap_rel1_def br_def pw_le_iff refine_pw_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_empty_op_refine: \"(is_empty_op,RETURN o op_mset_is_empty) \\<in> heap_rel1 \\<rightarrow> \\<langle>bool_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (is_empty_op, RETURN \\<circ> op_mset_is_empty)\n    \\<in> heap_rel1 \\<rightarrow> \\<langle>bool_rel\\<rangle>nres_rel", "apply (intro nres_relI fun_relI; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> heap_rel1 \\<Longrightarrow>\n       is_empty_op a \\<le> RETURN (a' = {#})", "apply refine_vcg"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a'. (a, a') \\<in> heap_rel1 \\<Longrightarrow> heap_invar a\n 2. \\<And>a a' x.\n       \\<lbrakk>(a, a') \\<in> heap_rel1; x = (\\<alpha> a = {#})\\<rbrakk>\n       \\<Longrightarrow> (a' = {#}) = x", "apply (auto simp: heap_rel1_def br_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma insert_op_refine: \"(insert_op,RETURN oo op_mset_insert) \\<in> Id \\<rightarrow> heap_rel1 \\<rightarrow> \\<langle>heap_rel1\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (insert_op, RETURN \\<circ>\\<circ> op_mset_insert)\n    \\<in> Id \\<rightarrow>\n          heap_rel1 \\<rightarrow> \\<langle>heap_rel1\\<rangle>nres_rel", "apply (intro nres_relI fun_relI; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>a = a'; (aa, a'a) \\<in> heap_rel1\\<rbrakk>\n       \\<Longrightarrow> insert_op a' aa\n                         \\<le> \\<Down> heap_rel1 (RETURN (add_mset a' a'a))", "apply (refine_vcg RETURN_as_SPEC_refine)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>a = a'; (aa, a'a) \\<in> heap_rel1\\<rbrakk>\n       \\<Longrightarrow> heap_invar aa\n 2. \\<And>a a' aa a'a x.\n       \\<lbrakk>a = a'; (aa, a'a) \\<in> heap_rel1;\n        heap_invar x \\<and> \\<alpha> x = \\<alpha> aa + {#a'#}\\<rbrakk>\n       \\<Longrightarrow> (x, add_mset a' a'a) \\<in> heap_rel1", "apply (auto simp: heap_rel1_def br_def pw_le_iff refine_pw_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pop_min_op_refine: \n      \"(pop_min_op, PR_CONST (mop_prio_pop_min prio)) \\<in> heap_rel1 \\<rightarrow> \\<langle>Id \\<times>\\<^sub>r heap_rel1\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pop_min_op, PR_CONST (mop_prio_pop_min prio))\n    \\<in> heap_rel1 \\<rightarrow>\n          \\<langle>Id \\<times>\\<^sub>r heap_rel1\\<rangle>nres_rel", "apply (intro fun_relI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> heap_rel1 \\<Longrightarrow>\n       pop_min_op a\n       \\<le> \\<Down> (Id \\<times>\\<^sub>r heap_rel1)\n              (PR_CONST (mop_prio_pop_min prio) a')", "unfolding mop_prio_pop_min_def PR_CONST_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> heap_rel1 \\<Longrightarrow>\n       pop_min_op a\n       \\<le> \\<Down> (Id \\<times>\\<^sub>r heap_rel1)\n              (ASSERT (a' \\<noteq> {#}) \\<bind>\n               (\\<lambda>_.\n                   SPEC\n                    (\\<lambda>(v, b').\n                        v \\<in># a' \\<and>\n                        b' = a' - {#v#} \\<and>\n                        (\\<forall>v'\\<in>#a'. prio v \\<le> prio v'))))", "apply (refine_vcg SPEC_refine)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> heap_rel1; a' \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> heap_invar a\n 2. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> heap_rel1; a' \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> a \\<noteq> {#}\n 3. \\<And>a a' x.\n       \\<lbrakk>(a, a') \\<in> heap_rel1; a' \\<noteq> {#};\n        case x of\n        (v, h') \\<Rightarrow>\n          heap_invar h' \\<and>\n          v \\<in># \\<alpha> a \\<and>\n          \\<alpha> h' = \\<alpha> a - {#v#} \\<and>\n          (\\<forall>v'\\<in>#\\<alpha> a. prio v \\<le> prio v')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x'.\n                            (x, x')\n                            \\<in> Id \\<times>\\<^sub>r heap_rel1 \\<and>\n                            (case x' of\n                             (v, b') \\<Rightarrow>\n                               v \\<in># a' \\<and>\n                               b' = a' - {#v#} \\<and>\n                               (\\<forall>v'\\<in>#a'. prio v \\<le> prio v'))", "apply (auto simp: heap_rel1_def br_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma peek_min_op_refine: \n      \"(peek_min_op, PR_CONST (mop_prio_peek_min prio)) \\<in> heap_rel1 \\<rightarrow> \\<langle>Id\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (peek_min_op, PR_CONST (mop_prio_peek_min prio))\n    \\<in> heap_rel1 \\<rightarrow> \\<langle>Id\\<rangle>nres_rel", "apply (intro fun_relI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> heap_rel1 \\<Longrightarrow>\n       peek_min_op a \\<le> \\<Down> Id (PR_CONST (mop_prio_peek_min prio) a')", "unfolding mop_prio_peek_min_def PR_CONST_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> heap_rel1 \\<Longrightarrow>\n       peek_min_op a\n       \\<le> \\<Down> Id\n              (ASSERT (a' \\<noteq> {#}) \\<bind>\n               (\\<lambda>_.\n                   SPEC\n                    (\\<lambda>v.\n                        v \\<in># a' \\<and>\n                        (\\<forall>v'\\<in>#a'. prio v \\<le> prio v'))))", "apply (refine_vcg RES_refine)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> heap_rel1; a' \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> heap_invar a\n 2. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> heap_rel1; a' \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> a \\<noteq> {#}\n 3. \\<And>a a' x.\n       \\<lbrakk>(a, a') \\<in> heap_rel1; a' \\<noteq> {#};\n        x \\<in># \\<alpha> a \\<and>\n        (\\<forall>v'\\<in>#\\<alpha> a. prio x \\<le> prio v')\\<rbrakk>\n       \\<Longrightarrow> x \\<in># a'\n 4. \\<And>a a' x.\n       \\<lbrakk>(a, a') \\<in> heap_rel1; a' \\<noteq> {#};\n        x \\<in># \\<alpha> a \\<and>\n        (\\<forall>v'\\<in>#\\<alpha> a. prio x \\<le> prio v')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v'\\<in>#a'. prio x \\<le> prio v'", "apply (auto simp: heap_rel1_def br_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "end"]]}