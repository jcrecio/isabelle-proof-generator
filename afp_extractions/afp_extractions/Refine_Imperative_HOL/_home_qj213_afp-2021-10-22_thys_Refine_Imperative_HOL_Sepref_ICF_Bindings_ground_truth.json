{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/Sepref_ICF_Bindings.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemma (in -) rev_append_hnr[param,sepref_import_param]:\n    \"(rev_append, rev_append) \\<in> \\<langle>A\\<rangle>list_rel \\<rightarrow> \\<langle>A\\<rangle>list_rel \\<rightarrow> \\<langle>A\\<rangle>list_rel\"", "lemma lsr_finite[simp, intro]: \"(l,s)\\<in>\\<langle>R\\<rangle>list_set_rel \\<Longrightarrow> finite s\"", "lemma it_to_sorted_list_triv:  \n    assumes \"distinct l\"\n    shows \"RETURN l \\<le> it_to_sorted_list (\\<lambda>_ _. True) (set l)\"", "lemma [sepref_gen_algo_rules]: \"GEN_ALGO (return) (IS_TO_SORTED_LIST (\\<lambda>_ _. True) (pure (\\<langle>A\\<rangle>list_set_rel)) (pure A))\"", "lemma list_set_rel_compp:\n    assumes \"IS_LEFT_UNIQUE A\" \"IS_RIGHT_UNIQUE A\"  \n    shows \"\\<langle>Id\\<rangle>list_set_rel O \\<langle>A\\<rangle>set_rel = \\<langle>A\\<rangle>list_set_rel\"", "lemma GEN_OP_EQ_Id: \"GEN_OP (=) (=) (Id\\<rightarrow>Id\\<rightarrow>bool_rel)\"", "lemma autoref_import_set_unfolds:\n    \"{} = op_set_empty\"\n    \"uncurry (RETURN oo (\\<in>)) = uncurry (RETURN oo op_set_member)\"\n    \"Intf_Set.op_set_isEmpty = IICF_Set.op_set_is_empty\"\n    \"Intf_Set.op_set_delete = IICF_Set.op_set_delete\"\n    \"insert = IICF_Set.op_set_insert\"", "lemma APA: \"\\<lbrakk>PROP Q; CONSTRAINT is_pure A\\<rbrakk> \\<Longrightarrow> PROP Q\"", "lemma APAru: \"\\<lbrakk>PROP Q; CONSTRAINT (IS_PURE IS_RIGHT_UNIQUE) A\\<rbrakk> \\<Longrightarrow> PROP Q\"", "lemma APAlu: \"\\<lbrakk>PROP Q; CONSTRAINT (IS_PURE IS_LEFT_UNIQUE) A\\<rbrakk> \\<Longrightarrow> PROP Q\"", "lemma APAbu: \"\\<lbrakk>PROP Q; CONSTRAINT (IS_PURE IS_LEFT_UNIQUE) A; CONSTRAINT (IS_PURE IS_RIGHT_UNIQUE) A\\<rbrakk> \\<Longrightarrow> PROP Q\"", "lemmas hnr_op_ls_empty = list_set_autoref_empty[of Id, sepref_param, unfolded autoref_import_set_unfolds,\n        FCOMP op_set_empty.fref[of \"the_pure A\"]]", "lemmas hnr_mop_ls_empty = hnr_op_ls_empty[FCOMP mk_mop_rl0_np[OF mop_set_empty_alt]]", "lemmas hnr_op_ls_is_empty[sepref_fr_rules] = list_set_autoref_isEmpty[of Id, sepref_param, THEN APA, unfolded autoref_import_set_unfolds,\n        FCOMP op_set_is_empty.fref[of \"the_pure A\"]]", "lemmas hnr_mop_ls_is_empty[sepref_fr_rules] = hnr_op_ls_is_empty[FCOMP mk_mop_rl1_np[OF mop_set_is_empty_alt]]", "lemmas hnr_op_ls_member[sepref_fr_rules] = list_set_autoref_member[OF GEN_OP_EQ_Id, sepref_param, THEN APAlu, unfolded autoref_import_set_unfolds,\n        FCOMP op_set_member.fref[of \"the_pure A\"]]", "lemmas hnr_mop_ls_member[sepref_fr_rules] = hnr_op_ls_member[FCOMP mk_mop_rl2_np[OF mop_set_member_alt]]", "lemmas hnr_op_ls_insert[sepref_fr_rules] = list_set_autoref_insert[OF GEN_OP_EQ_Id, sepref_param, THEN APAru, unfolded autoref_import_set_unfolds,\n        FCOMP op_set_insert.fref[of \"the_pure A\"]]", "lemmas hnr_mop_ls_insert[sepref_fr_rules] = hnr_op_ls_insert[FCOMP mk_mop_rl2_np[OF mop_set_insert_alt]]", "lemmas hnr_op_ls_delete[sepref_fr_rules] = list_set_autoref_delete[OF GEN_OP_EQ_Id, sepref_param, THEN APAbu, unfolded autoref_import_set_unfolds,\n        FCOMP op_set_delete.fref[of \"the_pure A\"]]", "lemmas hnr_mop_ls_delete[sepref_fr_rules] = hnr_op_ls_delete[FCOMP mk_mop_rl2_np[OF mop_set_delete_alt]]", "lemma fold_set_insert_dj: \"Set.insert = op_set_insert_dj\"", "lemma ls_insert_dj_hnr_aux: \n        \"(uncurry (return oo Cons), uncurry mop_set_insert_dj) \\<in> (pure Id)\\<^sup>k *\\<^sub>a (pure (\\<langle>Id\\<rangle>list_set_rel))\\<^sup>k \\<rightarrow>\\<^sub>a pure (\\<langle>Id\\<rangle>list_set_rel)\"", "lemmas ls_insert_dj_hnr[sepref_fr_rules] = ls_insert_dj_hnr_aux[THEN APAbu, FCOMP mop_set_insert_dj.fref[of \"the_pure A\"]]", "lemmas ls_insert_dj_hnr_mop[sepref_fr_rules] \n        = ls_insert_dj_hnr[FCOMP mk_op_rl2[OF mop_set_insert_dj_alt]]", "lemma hd_in_set_conv: \"hd l \\<in> set l \\<longleftrightarrow> l\\<noteq>[]\"", "lemma ls_pick_hnr_aux: \"(return o hd, mop_set_pick) \\<in> (pure (\\<langle>Id\\<rangle>list_set_rel))\\<^sup>k \\<rightarrow>\\<^sub>a id_assn\"", "lemmas ls_pick_hnr[sepref_fr_rules] = ls_pick_hnr_aux[THEN APA,FCOMP mop_set_pick.fref[of \"the_pure A\"]]", "lemma ls_pick_hnr_mop[sepref_fr_rules]: \"CONSTRAINT is_pure A \\<Longrightarrow> (return \\<circ> hd, op_set_pick) \\<in> [\\<lambda>s. s\\<noteq>{}]\\<^sub>a list_set_assn\\<^sup>k \\<rightarrow> A\"", "lemmas [sepref_fr_rules] = hnr_op_ls_empty[folded op_ls_empty_def]"], "translations": [["", "lemma (in -) rev_append_hnr[param,sepref_import_param]:\n    \"(rev_append, rev_append) \\<in> \\<langle>A\\<rangle>list_rel \\<rightarrow> \\<langle>A\\<rangle>list_rel \\<rightarrow> \\<langle>A\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rev_append, rev_append)\n    \\<in> \\<langle>A\\<rangle>list_rel \\<rightarrow>\n          \\<langle>A\\<rangle>list_rel \\<rightarrow>\n          \\<langle>A\\<rangle>list_rel", "unfolding rev_append_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rec_list (\\<lambda>ac. ac) (\\<lambda>x xs xsa ac. xsa (x # ac)),\n     rec_list (\\<lambda>ac. ac) (\\<lambda>x xs xsa ac. xsa (x # ac)))\n    \\<in> \\<langle>A\\<rangle>list_rel \\<rightarrow>\n          \\<langle>A\\<rangle>list_rel \\<rightarrow>\n          \\<langle>A\\<rangle>list_rel", "by parametricity"], ["", "subsection \\<open>Sets by List\\<close>"], ["", "(* TODO: Move to Collections *)"], ["", "lemma lsr_finite[simp, intro]: \"(l,s)\\<in>\\<langle>R\\<rangle>list_set_rel \\<Longrightarrow> finite s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l, s) \\<in> \\<langle>R\\<rangle>list_set_rel \\<Longrightarrow> finite s", "by (auto simp: list_set_rel_def br_def)"], ["", "lemma it_to_sorted_list_triv:  \n    assumes \"distinct l\"\n    shows \"RETURN l \\<le> it_to_sorted_list (\\<lambda>_ _. True) (set l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN l \\<le> it_to_sorted_list (\\<lambda>_ _. True) (set l)", "using assms"], ["proof (prove)\nusing this:\n  distinct l\n\ngoal (1 subgoal):\n 1. RETURN l \\<le> it_to_sorted_list (\\<lambda>_ _. True) (set l)", "unfolding it_to_sorted_list_def"], ["proof (prove)\nusing this:\n  distinct l\n\ngoal (1 subgoal):\n 1. RETURN l\n    \\<le> SPEC\n           (\\<lambda>la.\n               distinct la \\<and>\n               set l = set la \\<and> sorted_wrt (\\<lambda>_ _. True) la)", "by refine_vcg auto"], ["", "lemma [sepref_gen_algo_rules]: \"GEN_ALGO (return) (IS_TO_SORTED_LIST (\\<lambda>_ _. True) (pure (\\<langle>A\\<rangle>list_set_rel)) (pure A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GEN_ALGO return\n     (IS_TO_SORTED_LIST (\\<lambda>_ _. True)\n       (pure (\\<langle>A\\<rangle>list_set_rel)) (pure A))", "unfolding GEN_ALGO_def IS_TO_SORTED_LIST_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (return, it_to_sorted_list (\\<lambda>_ _. True))\n    \\<in> (pure\n            (\\<langle>A\\<rangle>list_set_rel))\\<^sup>k \\<rightarrow>\\<^sub>a list_assn\n  (pure A)", "apply (simp add: list_assn_pure_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (return, it_to_sorted_list (\\<lambda>_ _. True))\n    \\<in> (pure (\\<langle>A\\<rangle>list_set_rel),\n           pure\n            (\\<langle>A\\<rangle>list_set_rel)) \\<rightarrow>\\<^sub>a pure\n                                (\\<langle>A\\<rangle>list_rel)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c a.\n       True \\<Longrightarrow>\n       hn_refine\n        (fst (pure (\\<langle>A\\<rangle>list_set_rel),\n              pure (\\<langle>A\\<rangle>list_set_rel))\n          a c)\n        (return c)\n        (snd (pure (\\<langle>A\\<rangle>list_set_rel),\n              pure (\\<langle>A\\<rangle>list_set_rel))\n          a c)\n        (pure (\\<langle>A\\<rangle>list_rel))\n        (it_to_sorted_list (\\<lambda>_ _. True) a)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c a.\n       \\<lbrakk>True;\n        nofail (it_to_sorted_list (\\<lambda>_ _. True) a)\\<rbrakk>\n       \\<Longrightarrow> <fst (pure (\\<langle>A\\<rangle>list_set_rel),\n                               pure (\\<langle>A\\<rangle>list_set_rel))\n                           a c> return\n                                 c <\\<lambda>r.\n snd (pure (\\<langle>A\\<rangle>list_set_rel),\n      pure (\\<langle>A\\<rangle>list_set_rel))\n  a c *\n (\\<exists>\\<^sub>Ax.\n     pure (\\<langle>A\\<rangle>list_rel) x r *\n     \\<up>\n      (RETURN x \\<le> it_to_sorted_list (\\<lambda>_ _. True) a))>\\<^sub>t", "apply (sep_auto simp: pure_def intro: it_to_sorted_list_triv simp: list_set_rel_def br_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma list_set_rel_compp:\n    assumes \"IS_LEFT_UNIQUE A\" \"IS_RIGHT_UNIQUE A\"  \n    shows \"\\<langle>Id\\<rangle>list_set_rel O \\<langle>A\\<rangle>set_rel = \\<langle>A\\<rangle>list_set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Id\\<rangle>list_set_rel O \\<langle>A\\<rangle>set_rel =\n    \\<langle>A\\<rangle>list_set_rel", "unfolding list_set_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<langle>Id\\<rangle>list_rel O br set distinct) O\n    \\<langle>A\\<rangle>set_rel =\n    \\<langle>A\\<rangle>list_rel O br set distinct", "proof (safe; clarsimp simp: in_br_conv)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>z ya.\n       \\<lbrakk>(set ya, z) \\<in> \\<langle>A\\<rangle>set_rel;\n        distinct ya\\<rbrakk>\n       \\<Longrightarrow> (ya, z)\n                         \\<in> \\<langle>A\\<rangle>list_rel O br set distinct\n 2. \\<And>x y.\n       \\<lbrakk>(x, y) \\<in> \\<langle>A\\<rangle>list_rel;\n        distinct y\\<rbrakk>\n       \\<Longrightarrow> (x, set y)\n                         \\<in> br set distinct O \\<langle>A\\<rangle>set_rel", "fix x z"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>z ya.\n       \\<lbrakk>(set ya, z) \\<in> \\<langle>A\\<rangle>set_rel;\n        distinct ya\\<rbrakk>\n       \\<Longrightarrow> (ya, z)\n                         \\<in> \\<langle>A\\<rangle>list_rel O br set distinct\n 2. \\<And>x y.\n       \\<lbrakk>(x, y) \\<in> \\<langle>A\\<rangle>list_rel;\n        distinct y\\<rbrakk>\n       \\<Longrightarrow> (x, set y)\n                         \\<in> br set distinct O \\<langle>A\\<rangle>set_rel", "assume \"(set x,z)\\<in>\\<langle>A\\<rangle>set_rel\" \"distinct x\""], ["proof (state)\nthis:\n  (set x, z) \\<in> \\<langle>A\\<rangle>set_rel\n  distinct x\n\ngoal (2 subgoals):\n 1. \\<And>z ya.\n       \\<lbrakk>(set ya, z) \\<in> \\<langle>A\\<rangle>set_rel;\n        distinct ya\\<rbrakk>\n       \\<Longrightarrow> (ya, z)\n                         \\<in> \\<langle>A\\<rangle>list_rel O br set distinct\n 2. \\<And>x y.\n       \\<lbrakk>(x, y) \\<in> \\<langle>A\\<rangle>list_rel;\n        distinct y\\<rbrakk>\n       \\<Longrightarrow> (x, set y)\n                         \\<in> br set distinct O \\<langle>A\\<rangle>set_rel", "from obtain_list_from_setrel[OF \\<open>IS_RIGHT_UNIQUE A\\<close> this(1)]"], ["proof (chain)\npicking this:\n  (\\<And>m.\n      \\<lbrakk>z = set m; (x, m) \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain zl where\n      [simp]: \"z = set zl\" and X_ZL: \"(x, zl) \\<in> \\<langle>A\\<rangle>list_rel\""], ["proof (prove)\nusing this:\n  (\\<And>m.\n      \\<lbrakk>z = set m; (x, m) \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>zl.\n        \\<lbrakk>z = set zl;\n         (x, zl) \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  z = set zl\n  (x, zl) \\<in> \\<langle>A\\<rangle>list_rel\n\ngoal (2 subgoals):\n 1. \\<And>z ya.\n       \\<lbrakk>(set ya, z) \\<in> \\<langle>A\\<rangle>set_rel;\n        distinct ya\\<rbrakk>\n       \\<Longrightarrow> (ya, z)\n                         \\<in> \\<langle>A\\<rangle>list_rel O br set distinct\n 2. \\<And>x y.\n       \\<lbrakk>(x, y) \\<in> \\<langle>A\\<rangle>list_rel;\n        distinct y\\<rbrakk>\n       \\<Longrightarrow> (x, set y)\n                         \\<in> br set distinct O \\<langle>A\\<rangle>set_rel", "have \"distinct zl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct zl", "using param_distinct[OF assms, THEN fun_relD, OF X_ZL] \\<open>distinct x\\<close>"], ["proof (prove)\nusing this:\n  (distinct x, distinct zl) \\<in> bool_rel\n  distinct x\n\ngoal (1 subgoal):\n 1. distinct zl", "by auto"], ["proof (state)\nthis:\n  distinct zl\n\ngoal (2 subgoals):\n 1. \\<And>z ya.\n       \\<lbrakk>(set ya, z) \\<in> \\<langle>A\\<rangle>set_rel;\n        distinct ya\\<rbrakk>\n       \\<Longrightarrow> (ya, z)\n                         \\<in> \\<langle>A\\<rangle>list_rel O br set distinct\n 2. \\<And>x y.\n       \\<lbrakk>(x, y) \\<in> \\<langle>A\\<rangle>list_rel;\n        distinct y\\<rbrakk>\n       \\<Longrightarrow> (x, set y)\n                         \\<in> br set distinct O \\<langle>A\\<rangle>set_rel", "show \"(x,z) \\<in> \\<langle>A\\<rangle>list_rel O br set distinct\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, z) \\<in> \\<langle>A\\<rangle>list_rel O br set distinct", "apply (rule relcompI[OF X_ZL])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (zl, z) \\<in> br set distinct", "by (auto simp: in_br_conv \\<open>distinct zl\\<close>)"], ["proof (state)\nthis:\n  (x, z) \\<in> \\<langle>A\\<rangle>list_rel O br set distinct\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>(x, y) \\<in> \\<langle>A\\<rangle>list_rel;\n        distinct y\\<rbrakk>\n       \\<Longrightarrow> (x, set y)\n                         \\<in> br set distinct O \\<langle>A\\<rangle>set_rel", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>(x, y) \\<in> \\<langle>A\\<rangle>list_rel;\n        distinct y\\<rbrakk>\n       \\<Longrightarrow> (x, set y)\n                         \\<in> br set distinct O \\<langle>A\\<rangle>set_rel", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>(x, y) \\<in> \\<langle>A\\<rangle>list_rel;\n        distinct y\\<rbrakk>\n       \\<Longrightarrow> (x, set y)\n                         \\<in> br set distinct O \\<langle>A\\<rangle>set_rel", "assume XY: \"(x, y) \\<in> \\<langle>A\\<rangle>list_rel\" and \"distinct y\""], ["proof (state)\nthis:\n  (x, y) \\<in> \\<langle>A\\<rangle>list_rel\n  distinct y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>(x, y) \\<in> \\<langle>A\\<rangle>list_rel;\n        distinct y\\<rbrakk>\n       \\<Longrightarrow> (x, set y)\n                         \\<in> br set distinct O \\<langle>A\\<rangle>set_rel", "have \"distinct x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct x", "using param_distinct[OF assms, THEN fun_relD, OF XY] \\<open>distinct y\\<close>"], ["proof (prove)\nusing this:\n  (distinct x, distinct y) \\<in> bool_rel\n  distinct y\n\ngoal (1 subgoal):\n 1. distinct x", "by auto"], ["proof (state)\nthis:\n  distinct x\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>(x, y) \\<in> \\<langle>A\\<rangle>list_rel;\n        distinct y\\<rbrakk>\n       \\<Longrightarrow> (x, set y)\n                         \\<in> br set distinct O \\<langle>A\\<rangle>set_rel", "show \"(x, set y) \\<in> br set distinct O \\<langle>A\\<rangle>set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, set y) \\<in> br set distinct O \\<langle>A\\<rangle>set_rel", "apply (rule relcompI[where b=\"set x\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. (x, set x) \\<in> br set distinct\n 2. (set x, set y) \\<in> \\<langle>A\\<rangle>set_rel", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, set x) \\<in> br set distinct", "by (auto simp: in_br_conv \\<open>distinct x\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (set x, set y) \\<in> \\<langle>A\\<rangle>set_rel", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (set x, set y) \\<in> \\<langle>A\\<rangle>set_rel", "by (rule param_set[OF \\<open>IS_RIGHT_UNIQUE A\\<close>, THEN fun_relD, OF XY])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (x, set y) \\<in> br set distinct O \\<langle>A\\<rangle>set_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma GEN_OP_EQ_Id: \"GEN_OP (=) (=) (Id\\<rightarrow>Id\\<rightarrow>bool_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GEN_OP (=) (=) (Id \\<rightarrow> Id \\<rightarrow> bool_rel)", "by simp"], ["", "hide_const (open) Intf_Set.op_set_isEmpty Intf_Set.op_set_delete"], ["", "lemma autoref_import_set_unfolds:\n    \"{} = op_set_empty\"\n    \"uncurry (RETURN oo (\\<in>)) = uncurry (RETURN oo op_set_member)\"\n    \"Intf_Set.op_set_isEmpty = IICF_Set.op_set_is_empty\"\n    \"Intf_Set.op_set_delete = IICF_Set.op_set_delete\"\n    \"insert = IICF_Set.op_set_insert\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({} = op_set_empty &&&\n     uncurry (RETURN \\<circ>\\<circ> (\\<in>)) =\n     uncurry (RETURN \\<circ>\\<circ> op_set_member)) &&&\n    Intf_Set.op_set_isEmpty = op_set_is_empty &&&\n    Intf_Set.op_set_delete = op_set_delete &&& insert = op_set_insert", "by (auto intro!: ext)"], ["", "context fixes A :: \"'a \\<Rightarrow> 'ai \\<Rightarrow> assn\" begin"], ["", "private"], ["", "lemma APA: \"\\<lbrakk>PROP Q; CONSTRAINT is_pure A\\<rbrakk> \\<Longrightarrow> PROP Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>PROP Q; Sepref_Constraints.CONSTRAINT is_pure A\\<rbrakk>\n    \\<Longrightarrow> PROP Q", "."], ["", "private"], ["", "lemma APAru: \"\\<lbrakk>PROP Q; CONSTRAINT (IS_PURE IS_RIGHT_UNIQUE) A\\<rbrakk> \\<Longrightarrow> PROP Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>PROP Q;\n     Sepref_Constraints.CONSTRAINT (IS_PURE single_valued) A\\<rbrakk>\n    \\<Longrightarrow> PROP Q", "."], ["", "private"], ["", "lemma APAlu: \"\\<lbrakk>PROP Q; CONSTRAINT (IS_PURE IS_LEFT_UNIQUE) A\\<rbrakk> \\<Longrightarrow> PROP Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>PROP Q;\n     Sepref_Constraints.CONSTRAINT (IS_PURE IS_LEFT_UNIQUE) A\\<rbrakk>\n    \\<Longrightarrow> PROP Q", "."], ["", "private"], ["", "lemma APAbu: \"\\<lbrakk>PROP Q; CONSTRAINT (IS_PURE IS_LEFT_UNIQUE) A; CONSTRAINT (IS_PURE IS_RIGHT_UNIQUE) A\\<rbrakk> \\<Longrightarrow> PROP Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>PROP Q;\n     Sepref_Constraints.CONSTRAINT (IS_PURE IS_LEFT_UNIQUE) A;\n     Sepref_Constraints.CONSTRAINT (IS_PURE single_valued) A\\<rbrakk>\n    \\<Longrightarrow> PROP Q", "."], ["", "definition \"list_set_assn = pure (\\<langle>Id\\<rangle>list_set_rel O \\<langle>the_pure A\\<rangle>set_rel)\""], ["", "context\n      notes [fcomp_norm_unfold] = list_set_assn_def[symmetric]\n      notes [simp] = IS_LEFT_UNIQUE_def\n    begin"], ["", "lemmas hnr_op_ls_empty = list_set_autoref_empty[of Id, sepref_param, unfolded autoref_import_set_unfolds,\n        FCOMP op_set_empty.fref[of \"the_pure A\"]]"], ["", "lemmas hnr_mop_ls_empty = hnr_op_ls_empty[FCOMP mk_mop_rl0_np[OF mop_set_empty_alt]]"], ["", "definition [simp]: \"op_ls_empty = op_set_empty\""], ["", "sepref_register op_ls_empty"], ["", "lemmas hnr_op_ls_is_empty[sepref_fr_rules] = list_set_autoref_isEmpty[of Id, sepref_param, THEN APA, unfolded autoref_import_set_unfolds,\n        FCOMP op_set_is_empty.fref[of \"the_pure A\"]]"], ["", "lemmas hnr_mop_ls_is_empty[sepref_fr_rules] = hnr_op_ls_is_empty[FCOMP mk_mop_rl1_np[OF mop_set_is_empty_alt]]"], ["", "lemmas hnr_op_ls_member[sepref_fr_rules] = list_set_autoref_member[OF GEN_OP_EQ_Id, sepref_param, THEN APAlu, unfolded autoref_import_set_unfolds,\n        FCOMP op_set_member.fref[of \"the_pure A\"]]"], ["", "lemmas hnr_mop_ls_member[sepref_fr_rules] = hnr_op_ls_member[FCOMP mk_mop_rl2_np[OF mop_set_member_alt]]"], ["", "lemmas hnr_op_ls_insert[sepref_fr_rules] = list_set_autoref_insert[OF GEN_OP_EQ_Id, sepref_param, THEN APAru, unfolded autoref_import_set_unfolds,\n        FCOMP op_set_insert.fref[of \"the_pure A\"]]"], ["", "lemmas hnr_mop_ls_insert[sepref_fr_rules] = hnr_op_ls_insert[FCOMP mk_mop_rl2_np[OF mop_set_insert_alt]]"], ["", "lemmas hnr_op_ls_delete[sepref_fr_rules] = list_set_autoref_delete[OF GEN_OP_EQ_Id, sepref_param, THEN APAbu, unfolded autoref_import_set_unfolds,\n        FCOMP op_set_delete.fref[of \"the_pure A\"]]"], ["", "lemmas hnr_mop_ls_delete[sepref_fr_rules] = hnr_op_ls_delete[FCOMP mk_mop_rl2_np[OF mop_set_delete_alt]]"], ["", "text \\<open>Adapting this optimization from Autoref. \\<close>"], ["", "sepref_decl_op set_insert_dj: \"insert\" :: \"[\\<lambda>(x,s). x\\<notin>s]\\<^sub>f K \\<times>\\<^sub>r \\<langle>K\\<rangle>set_rel \\<rightarrow> \\<langle>K\\<rangle>set_rel\" \n        where \"IS_RIGHT_UNIQUE K\" \"IS_LEFT_UNIQUE K\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma fold_set_insert_dj: \"Set.insert = op_set_insert_dj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert = op_set_insert_dj", "by simp"], ["", "lemma ls_insert_dj_hnr_aux: \n        \"(uncurry (return oo Cons), uncurry mop_set_insert_dj) \\<in> (pure Id)\\<^sup>k *\\<^sub>a (pure (\\<langle>Id\\<rangle>list_set_rel))\\<^sup>k \\<rightarrow>\\<^sub>a pure (\\<langle>Id\\<rangle>list_set_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry (return \\<circ>\\<circ> (#)), uncurry mop_set_insert_dj)\n    \\<in> id_assn\\<^sup>k *\\<^sub>a\n          (pure\n            (\\<langle>Id\\<rangle>list_set_rel))\\<^sup>k \\<rightarrow>\\<^sub>a pure\n   (\\<langle>Id\\<rangle>list_set_rel)", "using list_set_autoref_insert_dj[where R=Id,param_fo]"], ["proof (prove)\nusing this:\n  \\<lbrakk>PRIO_TAG_OPTIMIZATION; SIDE_PRECOND_OPT (?x' \\<notin> ?s');\n   (?x, ?x') \\<in> Id;\n   (?s, ?s') \\<in> \\<langle>Id\\<rangle>list_set_rel\\<rbrakk>\n  \\<Longrightarrow> (?x # ?s,\n                     (OP insert :::\n                      Id \\<rightarrow>\n                      \\<langle>Id\\<rangle>list_set_rel \\<rightarrow>\n                      \\<langle>Id\\<rangle>list_set_rel) $\n                     ?x' $\n                     ?s')\n                    \\<in> \\<langle>Id\\<rangle>list_set_rel\n\ngoal (1 subgoal):\n 1. (uncurry (return \\<circ>\\<circ> (#)), uncurry mop_set_insert_dj)\n    \\<in> id_assn\\<^sup>k *\\<^sub>a\n          (pure\n            (\\<langle>Id\\<rangle>list_set_rel))\\<^sup>k \\<rightarrow>\\<^sub>a pure\n   (\\<langle>Id\\<rangle>list_set_rel)", "apply (sep_auto intro!: hfrefI hn_refineI simp: pure_def refine_pw_simps eintros del: exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b aa ba a bb.\n       \\<lbrakk>\\<And>x' s' x s.\n                   \\<lbrakk>x' \\<notin> s'; x = x';\n                    (s, s') \\<in> \\<langle>Id\\<rangle>list_set_rel\\<rbrakk>\n                   \\<Longrightarrow> (x # s, insert x' s')\n                                     \\<in> \\<langle>Id\\<rangle>list_set_rel;\n        aa \\<notin> ba; (b, ba) \\<in> \\<langle>Id\\<rangle>list_set_rel;\n        (a, bb) \\<Turnstile> emp\\<rbrakk>\n       \\<Longrightarrow> (aa # b, insert aa ba)\n                         \\<in> \\<langle>Id\\<rangle>list_set_rel", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas ls_insert_dj_hnr[sepref_fr_rules] = ls_insert_dj_hnr_aux[THEN APAbu, FCOMP mop_set_insert_dj.fref[of \"the_pure A\"]]"], ["", "lemmas ls_insert_dj_hnr_mop[sepref_fr_rules] \n        = ls_insert_dj_hnr[FCOMP mk_op_rl2[OF mop_set_insert_dj_alt]]"], ["", "private"], ["", "lemma hd_in_set_conv: \"hd l \\<in> set l \\<longleftrightarrow> l\\<noteq>[]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hd l \\<in> set l) = (l \\<noteq> [])", "by auto"], ["", "lemma ls_pick_hnr_aux: \"(return o hd, mop_set_pick) \\<in> (pure (\\<langle>Id\\<rangle>list_set_rel))\\<^sup>k \\<rightarrow>\\<^sub>a id_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (return \\<circ> hd, mop_set_pick)\n    \\<in> (pure\n            (\\<langle>Id\\<rangle>list_set_rel))\\<^sup>k \\<rightarrow>\\<^sub>a id_assn", "apply (sep_auto \n          intro!: hfrefI hn_refineI \n          simp: pure_def IS_PURE_def IS_ID_def list_set_rel_def refine_pw_simps\n          eintros del: exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c a aa b x.\n       \\<lbrakk>(c, a) \\<in> br set distinct; (aa, b) \\<Turnstile> emp;\n        hd c \\<notin> a; x \\<in> a\\<rbrakk>\n       \\<Longrightarrow> False", "apply (auto simp: in_br_conv hd_in_set_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas ls_pick_hnr[sepref_fr_rules] = ls_pick_hnr_aux[THEN APA,FCOMP mop_set_pick.fref[of \"the_pure A\"]]"], ["", "lemma ls_pick_hnr_mop[sepref_fr_rules]: \"CONSTRAINT is_pure A \\<Longrightarrow> (return \\<circ> hd, op_set_pick) \\<in> [\\<lambda>s. s\\<noteq>{}]\\<^sub>a list_set_assn\\<^sup>k \\<rightarrow> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sepref_Constraints.CONSTRAINT is_pure A \\<Longrightarrow>\n    (return \\<circ> hd, IICF_Set.op_set_pick)\n    \\<in> [\\<lambda>s.\n              s \\<noteq>\n              {}]\\<^sub>a local.list_set_assn\\<^sup>k \\<rightarrow> A", "using ls_pick_hnr"], ["proof (prove)\nusing this:\n  Sepref_Constraints.CONSTRAINT is_pure A \\<Longrightarrow>\n  (return \\<circ> hd, mop_set_pick)\n  \\<in> local.list_set_assn\\<^sup>k \\<rightarrow>\\<^sub>a A\n\ngoal (1 subgoal):\n 1. Sepref_Constraints.CONSTRAINT is_pure A \\<Longrightarrow>\n    (return \\<circ> hd, IICF_Set.op_set_pick)\n    \\<in> [\\<lambda>s.\n              s \\<noteq>\n              {}]\\<^sub>a local.list_set_assn\\<^sup>k \\<rightarrow> A", "by (simp add: hfref_to_ASSERT_conv mop_set_pick_alt[abs_def])"], ["", "end"], ["", "end"], ["", "interpretation ls: set_custom_empty \"return []\" op_ls_empty"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_custom_empty op_ls_empty", "by unfold_locales simp"], ["", "lemmas [sepref_fr_rules] = hnr_op_ls_empty[folded op_ls_empty_def]"], ["", "end"]]}