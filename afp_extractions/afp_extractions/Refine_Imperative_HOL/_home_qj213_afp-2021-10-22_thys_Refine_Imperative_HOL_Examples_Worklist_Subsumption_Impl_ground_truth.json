{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/Examples/Worklist_Subsumption_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemma [def_pat_rules]:\n      \"a\\<^sub>0 \\<equiv> UNPROTECT a\\<^sub>0\" \"F \\<equiv> UNPROTECT F\" \"(\\<preceq>) \\<equiv> UNPROTECT (\\<preceq>)\" \"succs \\<equiv> UNPROTECT succs\"", "lemma take_from_mset_as_mop_mset_pick: \"take_from_mset = mop_mset_pick\"", "lemma [safe_constraint_rules]: \"CN_FALSE is_pure A \\<Longrightarrow> is_pure A\"", "lemma Worklist2_this: \"Worklist2 E a\\<^sub>0 F (\\<preceq>) succs A succsi a\\<^sub>0i Fi Lei\"", "lemma hnr_F_reachable: \"(uncurry0 (worklist_algo2 Lei a\\<^sub>0i Fi succsi), uncurry0 (RETURN F_reachable)) \n      \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\"", "lemma [def_pat_rules]: \"F_reachable \\<equiv> op_F_reachable\"", "lemma hnr_op_F_reachable:\n      assumes \"GEN_ALGO a\\<^sub>0i (\\<lambda>a\\<^sub>0i. (uncurry0 a\\<^sub>0i, uncurry0 (RETURN a\\<^sub>0)) \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a A)\"\n      assumes \"GEN_ALGO Fi (\\<lambda>Fi. (Fi,RETURN o F) \\<in> A\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn)\"\n      assumes \"GEN_ALGO Lei (\\<lambda>Lei. (uncurry Lei,uncurry (RETURN oo (\\<preceq>))) \\<in> A\\<^sup>k *\\<^sub>a A\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn)\"\n      assumes \"GEN_ALGO succsi (\\<lambda>succsi. (succsi,RETURN o succs) \\<in> A\\<^sup>k \\<rightarrow>\\<^sub>a list_assn A)\"\n      shows \"(uncurry0 (worklist_algo2 Lei a\\<^sub>0i Fi succsi), uncurry0 (RETURN (PR_CONST op_F_reachable))) \n        \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\""], "translations": [["", "lemma [def_pat_rules]:\n      \"a\\<^sub>0 \\<equiv> UNPROTECT a\\<^sub>0\" \"F \\<equiv> UNPROTECT F\" \"(\\<preceq>) \\<equiv> UNPROTECT (\\<preceq>)\" \"succs \\<equiv> UNPROTECT succs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((a\\<^sub>0 \\<equiv> UNPROTECT a\\<^sub>0) &&&\n     F \\<equiv> UNPROTECT F) &&&\n    ((\\<preceq>) \\<equiv> UNPROTECT (\\<preceq>)) &&&\n    succs \\<equiv> UNPROTECT succs", "by simp_all"], ["", "lemma take_from_mset_as_mop_mset_pick: \"take_from_mset = mop_mset_pick\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take_from_mset = mop_mset_pick", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. take_from_mset x = mop_mset_pick x", "unfolding take_from_mset_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       ASSERT (x \\<noteq> {#}) \\<bind>\n       (\\<lambda>_.\n           SPEC (\\<lambda>(xa, s'). xa \\<in># x \\<and> s' = x - {#xa#})) =\n       mop_mset_pick x", "by (auto simp: pw_eq_iff refine_pw_simps)"], ["", "lemma [safe_constraint_rules]: \"CN_FALSE is_pure A \\<Longrightarrow> is_pure A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CN_FALSE is_pure A \\<Longrightarrow> is_pure A", "by simp"], ["", "sepref_thm worklist_algo2 is \"uncurry0 worklist_algo1\" :: \"unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2, uncurry0 worklist_algo1)\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "unfolding worklist_algo1_def add_succ1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2,\n     uncurry0\n      (if F a\\<^sub>0 then RETURN True\n       else let passed = {}; wait = {#a\\<^sub>0#}\n            in WHILE\\<^sub>T\\<^bsup>worklist_inv\\<^esup>\n                (\\<lambda>(passed, wait, brk).\n                    \\<not> brk \\<and> wait \\<noteq> {#})\n                (\\<lambda>(passed, wait, brk).\n                    take_from_mset wait \\<bind>\n                    (\\<lambda>(a, wait).\n                        if Bex passed ((\\<preceq>) a)\n                        then RETURN (passed, wait, brk)\n                        else nfoldli (succs a)\n                              (\\<lambda>(uu_, brk). \\<not> brk)\n                              (\\<lambda>a (wait, brk).\n                                  if F a then RETURN (wait, True)\n                                  else RETURN (wait + {#a#}, False))\n                              (wait, False) \\<bind>\n                             (\\<lambda>(wait, brk).\n                                 let passed = insert a passed\n                                 in RETURN (passed, wait, brk))))\n                (passed, wait, False) \\<bind>\n               (\\<lambda>(passed, wait, y). RETURN y)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "supply [[goals_limit = 1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2,\n     uncurry0\n      (if F a\\<^sub>0 then RETURN True\n       else let passed = {}; wait = {#a\\<^sub>0#}\n            in WHILE\\<^sub>T\\<^bsup>worklist_inv\\<^esup>\n                (\\<lambda>(passed, wait, brk).\n                    \\<not> brk \\<and> wait \\<noteq> {#})\n                (\\<lambda>(passed, wait, brk).\n                    take_from_mset wait \\<bind>\n                    (\\<lambda>(a, wait).\n                        if Bex passed ((\\<preceq>) a)\n                        then RETURN (passed, wait, brk)\n                        else nfoldli (succs a)\n                              (\\<lambda>(uu_, brk). \\<not> brk)\n                              (\\<lambda>a (wait, brk).\n                                  if F a then RETURN (wait, True)\n                                  else RETURN (wait + {#a#}, False))\n                              (wait, False) \\<bind>\n                             (\\<lambda>(wait, brk).\n                                 let passed = insert a passed\n                                 in RETURN (passed, wait, brk))))\n                (passed, wait, False) \\<bind>\n               (\\<lambda>(passed, wait, y). RETURN y)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "apply (rewrite in \"Let \\<hole> _\" lso_fold_custom_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2,\n     uncurry0\n      (if F a\\<^sub>0 then RETURN True\n       else let passed = op_lso_empty; wait = {#a\\<^sub>0#}\n            in WHILE\\<^sub>T\\<^bsup>worklist_inv\\<^esup>\n                (\\<lambda>(passed, wait, brk).\n                    \\<not> brk \\<and> wait \\<noteq> {#})\n                (\\<lambda>(passed, wait, brk).\n                    take_from_mset wait \\<bind>\n                    (\\<lambda>(a, wait).\n                        if Bex passed ((\\<preceq>) a)\n                        then RETURN (passed, wait, brk)\n                        else nfoldli (succs a)\n                              (\\<lambda>(uu_, brk). \\<not> brk)\n                              (\\<lambda>a (wait, brk).\n                                  if F a then RETURN (wait, True)\n                                  else RETURN (wait + {#a#}, False))\n                              (wait, False) \\<bind>\n                             (\\<lambda>(wait, brk).\n                                 let passed = insert a passed\n                                 in RETURN (passed, wait, brk))))\n                (passed, wait, False) \\<bind>\n               (\\<lambda>(passed, wait, y). RETURN y)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "apply (rewrite in \"{#a\\<^sub>0#}\" lmso_fold_custom_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2,\n     uncurry0\n      (if F a\\<^sub>0 then RETURN True\n       else let passed = op_lso_empty;\n                wait = add_mset a\\<^sub>0 op_lmso_empty\n            in WHILE\\<^sub>T\\<^bsup>worklist_inv\\<^esup>\n                (\\<lambda>(passed, wait, brk).\n                    \\<not> brk \\<and> wait \\<noteq> {#})\n                (\\<lambda>(passed, wait, brk).\n                    take_from_mset wait \\<bind>\n                    (\\<lambda>(a, wait).\n                        if Bex passed ((\\<preceq>) a)\n                        then RETURN (passed, wait, brk)\n                        else nfoldli (succs a)\n                              (\\<lambda>(uu_, brk). \\<not> brk)\n                              (\\<lambda>a (wait, brk).\n                                  if F a then RETURN (wait, True)\n                                  else RETURN (wait + {#a#}, False))\n                              (wait, False) \\<bind>\n                             (\\<lambda>(wait, brk).\n                                 let passed = insert a passed\n                                 in RETURN (passed, wait, brk))))\n                (passed, wait, False) \\<bind>\n               (\\<lambda>(passed, wait, y). RETURN y)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "unfolding take_from_mset_as_mop_mset_pick fold_lso_bex"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2,\n     uncurry0\n      (if F a\\<^sub>0 then RETURN True\n       else let passed = op_lso_empty;\n                wait = add_mset a\\<^sub>0 op_lmso_empty\n            in WHILE\\<^sub>T\\<^bsup>worklist_inv\\<^esup>\n                (\\<lambda>(passed, wait, brk).\n                    \\<not> brk \\<and> wait \\<noteq> {#})\n                (\\<lambda>(passed, wait, brk).\n                    mop_mset_pick wait \\<bind>\n                    (\\<lambda>(a, wait).\n                        if op_lso_bex ((\\<preceq>) a) passed\n                        then RETURN (passed, wait, brk)\n                        else nfoldli (succs a)\n                              (\\<lambda>(uu_, brk). \\<not> brk)\n                              (\\<lambda>a (wait, brk).\n                                  if F a then RETURN (wait, True)\n                                  else RETURN (wait + {#a#}, False))\n                              (wait, False) \\<bind>\n                             (\\<lambda>(wait, brk).\n                                 let passed = insert a passed\n                                 in RETURN (passed, wait, brk))))\n                (passed, wait, False) \\<bind>\n               (\\<lambda>(passed, wait, y). RETURN y)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "by sepref"], ["", "end"], ["", "concrete_definition worklist_algo2 \n    for Lei a\\<^sub>0i Fi succsi\n    uses Worklist2.worklist_algo2.refine_raw is \"(uncurry0 ?f,_)\\<in>_\""], ["", "thm worklist_algo2_def"], ["", "context Worklist2 begin"], ["", "lemma Worklist2_this: \"Worklist2 E a\\<^sub>0 F (\\<preceq>) succs A succsi a\\<^sub>0i Fi Lei\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Worklist2 E a\\<^sub>0 F (\\<preceq>) succs A succsi a\\<^sub>0i Fi Lei", "by unfold_locales"], ["", "lemma hnr_F_reachable: \"(uncurry0 (worklist_algo2 Lei a\\<^sub>0i Fi succsi), uncurry0 (RETURN F_reachable)) \n      \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 (worklist_algo2 Lei a\\<^sub>0i Fi succsi),\n     uncurry0 (RETURN F_reachable))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "using worklist_algo2.refine[OF Worklist2_this, \n        FCOMP worklist_algo1_ref[THEN nres_relI],\n        FCOMP worklist_algo_correct[THEN Id_SPEC_refine, THEN nres_relI]]"], ["proof (prove)\nusing this:\n  (uncurry0 (worklist_algo2 Lei a\\<^sub>0i Fi succsi),\n   uncurry0 (SPEC (\\<lambda>brk. brk = F_reachable)))\n  \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\n\ngoal (1 subgoal):\n 1. (uncurry0 (worklist_algo2 Lei a\\<^sub>0i Fi succsi),\n     uncurry0 (RETURN F_reachable))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "by (simp add: RETURN_def)"], ["", "end"], ["", "context Worklist1 begin"], ["", "sepref_decl_op F_reachable :: \"bool_rel\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma [def_pat_rules]: \"F_reachable \\<equiv> op_F_reachable\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F_reachable \\<equiv> op_F_reachable", "by simp"], ["", "lemma hnr_op_F_reachable:\n      assumes \"GEN_ALGO a\\<^sub>0i (\\<lambda>a\\<^sub>0i. (uncurry0 a\\<^sub>0i, uncurry0 (RETURN a\\<^sub>0)) \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a A)\"\n      assumes \"GEN_ALGO Fi (\\<lambda>Fi. (Fi,RETURN o F) \\<in> A\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn)\"\n      assumes \"GEN_ALGO Lei (\\<lambda>Lei. (uncurry Lei,uncurry (RETURN oo (\\<preceq>))) \\<in> A\\<^sup>k *\\<^sub>a A\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn)\"\n      assumes \"GEN_ALGO succsi (\\<lambda>succsi. (succsi,RETURN o succs) \\<in> A\\<^sup>k \\<rightarrow>\\<^sub>a list_assn A)\"\n      shows \"(uncurry0 (worklist_algo2 Lei a\\<^sub>0i Fi succsi), uncurry0 (RETURN (PR_CONST op_F_reachable))) \n        \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 (worklist_algo2 Lei a\\<^sub>0i Fi succsi),\n     uncurry0 (RETURN (PR_CONST op_F_reachable)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (uncurry0 (worklist_algo2 Lei a\\<^sub>0i Fi succsi),\n     uncurry0 (RETURN (PR_CONST op_F_reachable)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "from assms"], ["proof (chain)\npicking this:\n  GEN_ALGO a\\<^sub>0i\n   (\\<lambda>a\\<^sub>0i.\n       (uncurry0 a\\<^sub>0i, uncurry0 (RETURN a\\<^sub>0))\n       \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a A)\n  GEN_ALGO Fi\n   (\\<lambda>Fi.\n       (Fi, RETURN \\<circ> F)\n       \\<in> A\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn)\n  GEN_ALGO Lei\n   (\\<lambda>Lei.\n       (uncurry Lei, uncurry (RETURN \\<circ>\\<circ> (\\<preceq>)))\n       \\<in> A\\<^sup>k *\\<^sub>a A\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn)\n  GEN_ALGO succsi\n   (\\<lambda>succsi.\n       (succsi, RETURN \\<circ> succs)\n       \\<in> A\\<^sup>k \\<rightarrow>\\<^sub>a list_assn A)", "interpret Worklist2 E a\\<^sub>0 F \"(\\<preceq>)\" succs A succsi a\\<^sub>0i Fi Lei"], ["proof (prove)\nusing this:\n  GEN_ALGO a\\<^sub>0i\n   (\\<lambda>a\\<^sub>0i.\n       (uncurry0 a\\<^sub>0i, uncurry0 (RETURN a\\<^sub>0))\n       \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a A)\n  GEN_ALGO Fi\n   (\\<lambda>Fi.\n       (Fi, RETURN \\<circ> F)\n       \\<in> A\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn)\n  GEN_ALGO Lei\n   (\\<lambda>Lei.\n       (uncurry Lei, uncurry (RETURN \\<circ>\\<circ> (\\<preceq>)))\n       \\<in> A\\<^sup>k *\\<^sub>a A\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn)\n  GEN_ALGO succsi\n   (\\<lambda>succsi.\n       (succsi, RETURN \\<circ> succs)\n       \\<in> A\\<^sup>k \\<rightarrow>\\<^sub>a list_assn A)\n\ngoal (1 subgoal):\n 1. Worklist2 E a\\<^sub>0 F (\\<preceq>) succs A succsi a\\<^sub>0i Fi Lei", "by (unfold_locales; simp add: GEN_ALGO_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. (uncurry0 (worklist_algo2 Lei a\\<^sub>0i Fi succsi),\n     uncurry0 (RETURN (PR_CONST op_F_reachable)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "from hnr_F_reachable"], ["proof (chain)\npicking this:\n  (uncurry0 (worklist_algo2 Lei a\\<^sub>0i Fi succsi),\n   uncurry0 (RETURN F_reachable))\n  \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "show ?thesis"], ["proof (prove)\nusing this:\n  (uncurry0 (worklist_algo2 Lei a\\<^sub>0i Fi succsi),\n   uncurry0 (RETURN F_reachable))\n  \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\n\ngoal (1 subgoal):\n 1. (uncurry0 (worklist_algo2 Lei a\\<^sub>0i Fi succsi),\n     uncurry0 (RETURN (PR_CONST op_F_reachable)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "by simp"], ["proof (state)\nthis:\n  (uncurry0 (worklist_algo2 Lei a\\<^sub>0i Fi succsi),\n   uncurry0 (RETURN (PR_CONST op_F_reachable)))\n  \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\n\ngoal:\nNo subgoals!", "qed"], ["", "sepref_decl_impl hnr_op_F_reachable"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "end"]]}