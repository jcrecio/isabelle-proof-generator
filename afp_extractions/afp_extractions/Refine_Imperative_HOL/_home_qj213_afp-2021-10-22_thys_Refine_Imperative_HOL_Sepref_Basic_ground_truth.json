{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/Sepref_Basic.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemma pure_app_eq: \"pure R a c = \\<up>((c,a)\\<in>R)\"", "lemma pure_eq_conv[simp]: \"pure R = pure R' \\<longleftrightarrow> R=R'\"", "lemma pure_rel_eq_false_iff: \"pure R x y = false \\<longleftrightarrow> (y,x)\\<notin>R\"", "lemma is_pureI[intro?]: \n  assumes \"\\<And>x x'. P x x' = \\<up>(P' x x')\"\n  shows \"is_pure P\"", "lemma is_pureE:\n  assumes \"is_pure P\"\n  obtains P' where \"\\<And>x x'. P x x' = \\<up>(P' x x')\"", "lemma pure_pure[simp]: \"is_pure (pure P)\"", "lemma pure_hn_ctxt[intro!]: \"is_pure P \\<Longrightarrow> is_pure (hn_ctxt P)\"", "lemma the_pure_pure[simp]: \"the_pure (pure R) = R\"", "lemma is_pure_alt_def: \"is_pure R \\<longleftrightarrow> (\\<exists>Ri. \\<forall>x y. R x y = \\<up>((y,x)\\<in>Ri))\"", "lemma pure_the_pure[simp]: \"is_pure R \\<Longrightarrow> pure (the_pure R) = R\"", "lemma is_pure_conv: \"is_pure R \\<longleftrightarrow> (\\<exists>R'. R = pure R')\"", "lemma is_pure_the_pure_id_eq[simp]: \"is_pure R \\<Longrightarrow> the_pure R = Id \\<longleftrightarrow> R=pure Id\"", "lemma is_pure_iff_pure_assn: \"is_pure P = (\\<forall>x x'. is_pure_assn (P x x'))\"", "lemma hn_val_unfold: \"hn_val R a b = \\<up>((b,a)\\<in>R)\"", "lemma invalidate_clone: \"R x y \\<Longrightarrow>\\<^sub>A invalid_assn R x y * R x y\"", "lemma invalidate_clone': \"R x y \\<Longrightarrow>\\<^sub>A invalid_assn R x y * R x y * true\"", "lemma invalidate: \"R x y \\<Longrightarrow>\\<^sub>A invalid_assn R x y\"", "lemma invalid_pure_recover: \"invalid_assn (pure R) x y = pure R x y * true\"", "lemma hn_invalidI: \"h\\<Turnstile>hn_ctxt P x y \\<Longrightarrow> hn_invalid P x y = true\"", "lemma invalid_assn_cong[cong]:\n  assumes \"x\\<equiv>x'\"\n  assumes \"y\\<equiv>y'\"\n  assumes \"R x' y' \\<equiv> R' x' y'\"\n  shows \"invalid_assn R x y = invalid_assn R' x' y'\"", "lemma mod_pure_conv[simp]: \"(h,as)\\<Turnstile>pure R a b \\<longleftrightarrow> (as={} \\<and> (b,a)\\<in>R)\"", "lemma rdomp_ctxt[simp]: \"rdomp (hn_ctxt R) = rdomp R\"", "lemma rdomp_pure[simp]: \"rdomp (pure R) a \\<longleftrightarrow> a\\<in>Range R\"", "lemma rdom_pure[simp]: \"rdom (pure R) = Range R\"", "lemma Range_of_constraint_conv[simp]: \"Range (A\\<inter>UNIV\\<times>C) = Range A \\<inter> C\"", "lemma hn_refineI[intro?]:\n  assumes \"nofail m \n    \\<Longrightarrow> <\\<Gamma>> c <\\<lambda>r. \\<Gamma>' * (\\<exists>\\<^sub>Ax. R x r * \\<up>(RETURN x \\<le> m)) >\\<^sub>t\"\n  shows \"hn_refine \\<Gamma> c \\<Gamma>' R m\"", "lemma hn_refineD:\n  assumes \"hn_refine \\<Gamma> c \\<Gamma>' R m\"\n  assumes \"nofail m\"\n  shows \"<\\<Gamma>> c <\\<lambda>r. \\<Gamma>' * (\\<exists>\\<^sub>Ax. R x r * \\<up>(RETURN x \\<le> m)) >\\<^sub>t\"", "lemma hn_refine_preI: \n  assumes \"\\<And>h. h\\<Turnstile>\\<Gamma> \\<Longrightarrow> hn_refine \\<Gamma> c \\<Gamma>' R a\"\n  shows \"hn_refine \\<Gamma> c \\<Gamma>' R a\"", "lemma hn_refine_nofailI: \n  assumes \"nofail a \\<Longrightarrow> hn_refine \\<Gamma> c \\<Gamma>' R a\"  \n  shows \"hn_refine \\<Gamma> c \\<Gamma>' R a\"", "lemma hn_refine_false[simp]: \"hn_refine false c \\<Gamma>' R m\"", "lemma hn_refine_fail[simp]: \"hn_refine \\<Gamma> c \\<Gamma>' R FAIL\"", "lemma hn_refine_frame:\n  assumes \"hn_refine P' c Q' R m\"\n  assumes \"P \\<Longrightarrow>\\<^sub>t F * P'\"\n  shows \"hn_refine P c (F * Q') R m\"", "lemma hn_refine_cons:\n  assumes I: \"P\\<Longrightarrow>\\<^sub>tP'\"\n  assumes R: \"hn_refine P' c Q R m\"\n  assumes I': \"Q\\<Longrightarrow>\\<^sub>tQ'\"\n  assumes R': \"\\<And>x y. R x y \\<Longrightarrow>\\<^sub>t R' x y\"\n  shows \"hn_refine P c Q' R' m\"", "lemma hn_refine_cons_pre:\n  assumes I: \"P\\<Longrightarrow>\\<^sub>tP'\"\n  assumes R: \"hn_refine P' c Q R m\"\n  shows \"hn_refine P c Q R m\"", "lemma hn_refine_cons_post:\n  assumes R: \"hn_refine P c Q R m\"\n  assumes I: \"Q\\<Longrightarrow>\\<^sub>tQ'\"\n  shows \"hn_refine P c Q' R m\"", "lemma hn_refine_cons_res: \n  \"\\<lbrakk> hn_refine \\<Gamma> f \\<Gamma>' R g; \\<And>a c. R a c \\<Longrightarrow>\\<^sub>t R' a c \\<rbrakk> \\<Longrightarrow> hn_refine \\<Gamma> f \\<Gamma>' R' g\"", "lemma hn_refine_ref:\n  assumes LE: \"m\\<le>m'\"\n  assumes R: \"hn_refine P c Q R m\"\n  shows \"hn_refine P c Q R m'\"", "lemma hn_refine_cons_complete:\n  assumes I: \"P\\<Longrightarrow>\\<^sub>tP'\"\n  assumes R: \"hn_refine P' c Q R m\"\n  assumes I': \"Q\\<Longrightarrow>\\<^sub>tQ'\"\n  assumes R': \"\\<And>x y. R x y \\<Longrightarrow>\\<^sub>t R' x y\"\n  assumes LE: \"m\\<le>m'\"\n  shows \"hn_refine P c Q' R' m'\"", "lemma hn_refine_augment_res:\n  assumes A: \"hn_refine \\<Gamma> f \\<Gamma>' R g\"\n  assumes B: \"g \\<le>\\<^sub>n SPEC \\<Phi>\"\n  shows \"hn_refine \\<Gamma> f \\<Gamma>' (\\<lambda>a c. R a c * \\<up>(\\<Phi> a)) g\"", "lemma prod_assn_pure_conv[simp]: \"prod_assn (pure R1) (pure R2) = pure (R1 \\<times>\\<^sub>r R2)\"", "lemma prod_assn_pair_conv[simp]: \n  \"prod_assn A B (a1,b1) (a2,b2) = A a1 a2 * B b1 b2\"", "lemma prod_assn_true[simp]: \"prod_assn (\\<lambda>_ _. true) (\\<lambda>_ _. true) = (\\<lambda>_ _. true)\"", "lemma hn_refine_guessI:\n  assumes \"hn_refine P f P' R f'\"\n  assumes \"f=f_conc\"\n  shows \"hn_refine P f_conc P' R f'\"\n  \\<comment> \\<open>To prove a refinement, first synthesize one, and then prove equality\\<close>", "lemma imp_correctI:\n  assumes R: \"hn_refine \\<Gamma> c \\<Gamma>' R a\"\n  assumes C: \"a \\<le> SPEC \\<Phi>\"\n  shows \"<\\<Gamma>> c <\\<lambda>r'. \\<exists>\\<^sub>Ar. \\<Gamma>' * R r r' * \\<up>(\\<Phi> r)>\\<^sub>t\"", "lemma hnr_pre_ex_conv: \n  shows \"hn_refine (\\<exists>\\<^sub>Ax. \\<Gamma> x) c \\<Gamma>' R a \\<longleftrightarrow> (\\<forall>x. hn_refine (\\<Gamma> x) c \\<Gamma>' R a)\"", "lemma hnr_pre_pure_conv:  \n  shows \"hn_refine (\\<Gamma> * \\<up>P) c \\<Gamma>' R a \\<longleftrightarrow> (P \\<longrightarrow> hn_refine \\<Gamma> c \\<Gamma>' R a)\"", "lemma hn_refine_split_post:\n  assumes \"hn_refine \\<Gamma> c \\<Gamma>' R a\"\n  shows \"hn_refine \\<Gamma> c (\\<Gamma>' \\<or>\\<^sub>A \\<Gamma>'') R a\"", "lemma hn_refine_post_other: \n  assumes \"hn_refine \\<Gamma> c \\<Gamma>'' R a\"\n  shows \"hn_refine \\<Gamma> c (\\<Gamma>' \\<or>\\<^sub>A \\<Gamma>'') R a\"", "lemma hnr_RETURN_pass:\n  \"hn_refine (hn_ctxt R x p) (return p) (hn_invalid R x p) R (RETURN x)\"\n  \\<comment> \\<open>Pass on a value from the heap as return value\\<close>", "lemma hnr_RETURN_pure:\n  assumes \"(c,a)\\<in>R\"\n  shows \"hn_refine emp (return c) emp (pure R) (RETURN a)\"\n  \\<comment> \\<open>Return pure value\\<close>", "lemma hnr_FAIL[simp, intro!]: \"hn_refine \\<Gamma> c \\<Gamma>' R FAIL\"", "lemma hnr_ASSERT:\n  assumes \"\\<Phi> \\<Longrightarrow> hn_refine \\<Gamma> c \\<Gamma>' R c'\"\n  shows \"hn_refine \\<Gamma> c \\<Gamma>' R (do { ASSERT \\<Phi>; c'})\"", "lemma bind_det_aux: \"\\<lbrakk> RETURN x \\<le> m; RETURN y \\<le> f x \\<rbrakk> \\<Longrightarrow> RETURN y \\<le> m \\<bind> f\"", "lemma hnr_bind:\n  assumes D1: \"hn_refine \\<Gamma> m' \\<Gamma>1 Rh m\"\n  assumes D2: \n    \"\\<And>x x'. RETURN x \\<le> m \\<Longrightarrow> hn_refine (\\<Gamma>1 * hn_ctxt Rh x x') (f' x') (\\<Gamma>2 x x') R (f x)\"\n  assumes IMP: \"\\<And>x x'. \\<Gamma>2 x x' \\<Longrightarrow>\\<^sub>t \\<Gamma>' * hn_ctxt Rx x x'\"\n  shows \"hn_refine \\<Gamma> (m'\\<bind>f') \\<Gamma>' R (m\\<bind>f)\"", "lemma hn_refine_alt: \"hn_refine Fpre c Fpost P m \\<equiv> nofail m \\<longrightarrow>\n  <Fpre> c <\\<lambda>r. hn_rel P m r * Fpost>\\<^sub>t\"", "lemma wit_swap_forall:\n  assumes W: \"<P> c <\\<lambda>_. true>\"\n  assumes T: \"(\\<forall>x. A x \\<longrightarrow> <P> c <Q x>)\"\n  shows \"<P> c <\\<lambda>r. \\<not>\\<^sub>A (\\<exists>\\<^sub>Ax. \\<up>(A x) * \\<not>\\<^sub>A Q x r)>\"", "lemma hn_admissible:\n  assumes PREC: \"precise Ry\"\n  assumes E: \"\\<forall>f\\<in>A. nofail (f x) \\<longrightarrow> <P> c <\\<lambda>r. hn_rel Ry (f x) r * F>\"\n  assumes NF: \"nofail (INF f\\<in>A. f x)\"\n  shows \"<P> c <\\<lambda>r. hn_rel Ry (INF f\\<in>A. f x) r * F>\"", "lemma hn_admissible':\n  assumes PREC: \"precise Ry\"\n  assumes E: \"\\<forall>f\\<in>A. nofail (f x) \\<longrightarrow> <P> c <\\<lambda>r. hn_rel Ry (f x) r * F>\\<^sub>t\"\n  assumes NF: \"nofail (INF f\\<in>A. f x)\"\n  shows \"<P> c <\\<lambda>r. hn_rel Ry (INF f\\<in>A. f x) r * F>\\<^sub>t\"", "lemma hnr_RECT_old:\n  assumes S: \"\\<And>cf af ax px. \\<lbrakk>\n    \\<And>ax px. hn_refine (hn_ctxt Rx ax px * F) (cf px) (F' ax px) Ry (af ax)\\<rbrakk> \n    \\<Longrightarrow> hn_refine (hn_ctxt Rx ax px * F) (cB cf px) (F' ax px) Ry (aB af ax)\"\n  assumes M: \"(\\<And>x. mono_Heap (\\<lambda>f. cB f x))\"\n  assumes PREC: \"precise Ry\"\n  shows \"hn_refine \n    (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px) Ry (RECT aB ax)\"", "lemma hnr_RECT:\n  assumes S: \"\\<And>cf af ax px. \\<lbrakk>\n    \\<And>ax px. hn_refine (hn_ctxt Rx ax px * F) (cf px) (F' ax px) Ry (af ax)\\<rbrakk> \n    \\<Longrightarrow> hn_refine (hn_ctxt Rx ax px * F) (cB cf px) (F' ax px) Ry (aB af ax)\"\n  assumes M: \"(\\<And>x. mono_Heap (\\<lambda>f. cB f x))\"\n  shows \"hn_refine \n    (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px) Ry (RECT aB ax)\"", "lemma hnr_If:\n  assumes P: \"\\<Gamma> \\<Longrightarrow>\\<^sub>t \\<Gamma>1 * hn_val bool_rel a a'\"\n  assumes RT: \"a \\<Longrightarrow> hn_refine (\\<Gamma>1 * hn_val bool_rel a a') b' \\<Gamma>2b R b\"\n  assumes RE: \"\\<not>a \\<Longrightarrow> hn_refine (\\<Gamma>1 * hn_val bool_rel a a') c' \\<Gamma>2c R c\"\n  assumes IMP: \"\\<Gamma>2b \\<or>\\<^sub>A \\<Gamma>2c \\<Longrightarrow>\\<^sub>t \\<Gamma>'\"\n  shows \"hn_refine \\<Gamma> (if a' then b' else c') \\<Gamma>' R (if a then b else c)\""], "translations": [["", "lemma pure_app_eq: \"pure R a c = \\<up>((c,a)\\<in>R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure R a c = \\<up> ((c, a) \\<in> R)", "by (auto simp: pure_def)"], ["", "lemma pure_eq_conv[simp]: \"pure R = pure R' \\<longleftrightarrow> R=R'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pure R = pure R') = (R = R')", "unfolding pure_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>a c. \\<up> ((c, a) \\<in> R)) =\n     (\\<lambda>a c. \\<up> ((c, a) \\<in> R'))) =\n    (R = R')", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>a c. \\<up> ((c, a) \\<in> R)) =\n    (\\<lambda>a c. \\<up> ((c, a) \\<in> R')) \\<Longrightarrow>\n    R = R'\n 2. R = R' \\<Longrightarrow>\n    (\\<lambda>a c. \\<up> ((c, a) \\<in> R)) =\n    (\\<lambda>a c. \\<up> ((c, a) \\<in> R'))", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>(\\<lambda>a c. \\<up> ((c, a) \\<in> R)) =\n                (\\<lambda>a c. \\<up> ((c, a) \\<in> R'));\n        (a, b) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> R'\n 2. \\<And>a b.\n       \\<lbrakk>(\\<lambda>a c. \\<up> ((c, a) \\<in> R)) =\n                (\\<lambda>a c. \\<up> ((c, a) \\<in> R'));\n        (a, b) \\<in> R'\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> R", "apply (meson pure_assn_eq_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(\\<lambda>a c. \\<up> ((c, a) \\<in> R)) =\n                (\\<lambda>a c. \\<up> ((c, a) \\<in> R'));\n        (a, b) \\<in> R'\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> R", "apply (meson pure_assn_eq_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pure_rel_eq_false_iff: \"pure R x y = false \\<longleftrightarrow> (y,x)\\<notin>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pure R x y = false) = ((y, x) \\<notin> R)", "by (auto simp: pure_def)"], ["", "definition \"is_pure P \\<equiv> \\<exists>P'. \\<forall>x x'. P x x'=\\<up>(P' x x')\""], ["", "lemma is_pureI[intro?]: \n  assumes \"\\<And>x x'. P x x' = \\<up>(P' x x')\"\n  shows \"is_pure P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pure P", "using assms"], ["proof (prove)\nusing this:\n  P ?x ?x' = \\<up> (P' ?x ?x')\n\ngoal (1 subgoal):\n 1. is_pure P", "unfolding is_pure_def"], ["proof (prove)\nusing this:\n  P ?x ?x' = \\<up> (P' ?x ?x')\n\ngoal (1 subgoal):\n 1. \\<exists>P'. \\<forall>x x'. P x x' = \\<up> (P' x x')", "by blast"], ["", "lemma is_pureE:\n  assumes \"is_pure P\"\n  obtains P' where \"\\<And>x x'. P x x' = \\<up>(P' x x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P'.\n        (\\<And>x x'. P x x' = \\<up> (P' x x')) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  is_pure P\n\ngoal (1 subgoal):\n 1. (\\<And>P'.\n        (\\<And>x x'. P x x' = \\<up> (P' x x')) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding is_pure_def"], ["proof (prove)\nusing this:\n  \\<exists>P'. \\<forall>x x'. P x x' = \\<up> (P' x x')\n\ngoal (1 subgoal):\n 1. (\\<And>P'.\n        (\\<And>x x'. P x x' = \\<up> (P' x x')) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["", "lemma pure_pure[simp]: \"is_pure (pure P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pure (pure P)", "unfolding pure_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pure (\\<lambda>a c. \\<up> ((c, a) \\<in> P))", "by rule blast"], ["", "lemma pure_hn_ctxt[intro!]: \"is_pure P \\<Longrightarrow> is_pure (hn_ctxt P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pure P \\<Longrightarrow> is_pure (hn_ctxt P)", "unfolding hn_ctxt_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pure P \\<Longrightarrow> is_pure P", "."], ["", "definition \"the_pure P \\<equiv> THE P'. \\<forall>x x'. P x x'=\\<up>((x',x)\\<in>P')\""], ["", "lemma the_pure_pure[simp]: \"the_pure (pure R) = R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_pure (pure R) = R", "unfolding pure_def the_pure_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE P'.\n        \\<forall>x x'. \\<up> ((x', x) \\<in> R) = \\<up> ((x', x) \\<in> P')) =\n    R", "by (rule theI2[where a=R]) auto"], ["", "lemma is_pure_alt_def: \"is_pure R \\<longleftrightarrow> (\\<exists>Ri. \\<forall>x y. R x y = \\<up>((y,x)\\<in>Ri))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pure R = (\\<exists>Ri. \\<forall>x y. R x y = \\<up> ((y, x) \\<in> Ri))", "unfolding is_pure_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>P'. \\<forall>x x'. R x x' = \\<up> (P' x x')) =\n    (\\<exists>Ri. \\<forall>x y. R x y = \\<up> ((y, x) \\<in> Ri))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P'.\n       \\<forall>x x'. R x x' = \\<up> (P' x x') \\<Longrightarrow>\n       \\<exists>Ri. \\<forall>x y. P' x y = ((y, x) \\<in> Ri)", "apply (rename_tac P')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P'.\n       \\<forall>x x'. R x x' = \\<up> (P' x x') \\<Longrightarrow>\n       \\<exists>Ri. \\<forall>x y. P' x y = ((y, x) \\<in> Ri)", "apply (rule_tac x=\"{(x,y). P' y x}\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P'.\n       \\<forall>x x'. R x x' = \\<up> (P' x x') \\<Longrightarrow>\n       \\<forall>x y. P' x y = ((y, x) \\<in> {(x, y). P' y x})", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pure_the_pure[simp]: \"is_pure R \\<Longrightarrow> pure (the_pure R) = R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pure R \\<Longrightarrow> pure (the_pure R) = R", "unfolding is_pure_alt_def pure_def the_pure_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Ri.\n       \\<forall>x y. R x y = \\<up> ((y, x) \\<in> Ri) \\<Longrightarrow>\n    (\\<lambda>a c.\n        \\<up>\n         ((c, a)\n          \\<in> (THE P'.\n                    \\<forall>x x'. R x x' = \\<up> ((x', x) \\<in> P')))) =\n    R", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a c.\n       \\<exists>Ri.\n          \\<forall>x y. R x y = \\<up> ((y, x) \\<in> Ri) \\<Longrightarrow>\n       \\<up>\n        ((c, a)\n         \\<in> (THE P'. \\<forall>x x'. R x x' = \\<up> ((x', x) \\<in> P'))) =\n       R a c", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a c Ri.\n       \\<forall>x y. R x y = \\<up> ((y, x) \\<in> Ri) \\<Longrightarrow>\n       ((c, a)\n        \\<in> (THE P'.\n                  \\<forall>x x'. ((x', x) \\<in> Ri) = ((x', x) \\<in> P'))) =\n       ((c, a) \\<in> Ri)", "apply (rename_tac a c Ri)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a c Ri.\n       \\<forall>x y. R x y = \\<up> ((y, x) \\<in> Ri) \\<Longrightarrow>\n       ((c, a)\n        \\<in> (THE P'.\n                  \\<forall>x x'. ((x', x) \\<in> Ri) = ((x', x) \\<in> P'))) =\n       ((c, a) \\<in> Ri)", "apply (rule_tac a=Ri in theI2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a c Ri.\n       \\<forall>x y. R x y = \\<up> ((y, x) \\<in> Ri) \\<Longrightarrow>\n       \\<forall>x x'. ((x', x) \\<in> Ri) = ((x', x) \\<in> Ri)\n 2. \\<And>a c Ri x.\n       \\<lbrakk>\\<forall>x y. R x y = \\<up> ((y, x) \\<in> Ri);\n        \\<forall>xa x'. ((x', xa) \\<in> Ri) = ((x', xa) \\<in> x)\\<rbrakk>\n       \\<Longrightarrow> x = Ri\n 3. \\<And>a c Ri x.\n       \\<lbrakk>\\<forall>x y. R x y = \\<up> ((y, x) \\<in> Ri);\n        \\<forall>xa x'. ((x', xa) \\<in> Ri) = ((x', xa) \\<in> x)\\<rbrakk>\n       \\<Longrightarrow> ((c, a) \\<in> x) = ((c, a) \\<in> Ri)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_pure_conv: \"is_pure R \\<longleftrightarrow> (\\<exists>R'. R = pure R')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pure R = (\\<exists>R'. R = pure R')", "unfolding pure_def is_pure_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>Ri. \\<forall>x y. R x y = \\<up> ((y, x) \\<in> Ri)) =\n    (\\<exists>R'. R = (\\<lambda>a c. \\<up> ((c, a) \\<in> R')))", "by force"], ["", "lemma is_pure_the_pure_id_eq[simp]: \"is_pure R \\<Longrightarrow> the_pure R = Id \\<longleftrightarrow> R=pure Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pure R \\<Longrightarrow> (the_pure R = Id) = (R = pure Id)", "by (auto simp: is_pure_conv)"], ["", "lemma is_pure_iff_pure_assn: \"is_pure P = (\\<forall>x x'. is_pure_assn (P x x'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pure P = (\\<forall>x x'. is_pure_assn (P x x'))", "unfolding is_pure_def is_pure_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>P'. \\<forall>x x'. P x x' = \\<up> (P' x x')) =\n    (\\<forall>x x'. \\<exists>Pa. P x x' = \\<up> Pa)", "by metis"], ["", "abbreviation \"hn_val R \\<equiv> hn_ctxt (pure R)\""], ["", "lemma hn_val_unfold: \"hn_val R a b = \\<up>((b,a)\\<in>R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_val R a b = \\<up> ((b, a) \\<in> R)", "by (simp add: hn_ctxt_def pure_def)"], ["", "definition \"invalid_assn R x y \\<equiv> \\<up>(\\<exists>h. h\\<Turnstile>R x y) * true\""], ["", "abbreviation \"hn_invalid R \\<equiv> hn_ctxt (invalid_assn R)\""], ["", "lemma invalidate_clone: \"R x y \\<Longrightarrow>\\<^sub>A invalid_assn R x y * R x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R x y \\<Longrightarrow>\\<^sub>A invalid_assn R x y * R x y", "apply (rule entailsI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       h \\<Turnstile> R x y \\<Longrightarrow>\n       h \\<Turnstile> invalid_assn R x y * R x y", "unfolding invalid_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       h \\<Turnstile> R x y \\<Longrightarrow>\n       h \\<Turnstile>\n       \\<up> (\\<exists>h. h \\<Turnstile> R x y) * true * R x y", "apply (auto simp: models_in_range mod_star_trueI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma invalidate_clone': \"R x y \\<Longrightarrow>\\<^sub>A invalid_assn R x y * R x y * true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R x y \\<Longrightarrow>\\<^sub>A invalid_assn R x y * R x y * true", "apply (rule entailsI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       h \\<Turnstile> R x y \\<Longrightarrow>\n       h \\<Turnstile> invalid_assn R x y * R x y * true", "unfolding invalid_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       h \\<Turnstile> R x y \\<Longrightarrow>\n       h \\<Turnstile>\n       \\<up> (\\<exists>h. h \\<Turnstile> R x y) * true * R x y * true", "apply (auto simp: models_in_range mod_star_trueI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma invalidate: \"R x y \\<Longrightarrow>\\<^sub>A invalid_assn R x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R x y \\<Longrightarrow>\\<^sub>A invalid_assn R x y", "apply (rule entailsI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       h \\<Turnstile> R x y \\<Longrightarrow>\n       h \\<Turnstile> invalid_assn R x y", "unfolding invalid_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       h \\<Turnstile> R x y \\<Longrightarrow>\n       h \\<Turnstile> \\<up> (\\<exists>h. h \\<Turnstile> R x y) * true", "apply (auto simp: models_in_range mod_star_trueI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma invalid_pure_recover: \"invalid_assn (pure R) x y = pure R x y * true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invalid_assn (pure R) x y = pure R x y * true", "apply (rule ent_iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. invalid_assn (pure R) x y \\<Longrightarrow>\\<^sub>A pure R x y * true\n 2. pure R x y * true \\<Longrightarrow>\\<^sub>A invalid_assn (pure R) x y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. invalid_assn (pure R) x y \\<Longrightarrow>\\<^sub>A pure R x y * true", "apply (rule entailsI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       h \\<Turnstile> invalid_assn (pure R) x y \\<Longrightarrow>\n       h \\<Turnstile> pure R x y * true", "unfolding invalid_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       h \\<Turnstile>\n       \\<up> (\\<exists>h. h \\<Turnstile> pure R x y) *\n       true \\<Longrightarrow>\n       h \\<Turnstile> pure R x y * true", "by (auto simp: pure_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. pure R x y * true \\<Longrightarrow>\\<^sub>A invalid_assn (pure R) x y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. pure R x y * true \\<Longrightarrow>\\<^sub>A invalid_assn (pure R) x y", "unfolding invalid_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pure R x y * true \\<Longrightarrow>\\<^sub>A\n    \\<up> (\\<exists>h. h \\<Turnstile> pure R x y) * true", "by (auto simp: pure_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hn_invalidI: \"h\\<Turnstile>hn_ctxt P x y \\<Longrightarrow> hn_invalid P x y = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<Turnstile> hn_ctxt P x y \\<Longrightarrow> hn_invalid P x y = true", "apply (cases h)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>h \\<Turnstile> hn_ctxt P x y; h = (a, b)\\<rbrakk>\n       \\<Longrightarrow> hn_invalid P x y = true", "apply (rule ent_iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>h \\<Turnstile> hn_ctxt P x y; h = (a, b)\\<rbrakk>\n       \\<Longrightarrow> hn_invalid P x y \\<Longrightarrow>\\<^sub>A true\n 2. \\<And>a b.\n       \\<lbrakk>h \\<Turnstile> hn_ctxt P x y; h = (a, b)\\<rbrakk>\n       \\<Longrightarrow> true \\<Longrightarrow>\\<^sub>A hn_invalid P x y", "apply (auto simp: invalid_assn_def hn_ctxt_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma invalid_assn_cong[cong]:\n  assumes \"x\\<equiv>x'\"\n  assumes \"y\\<equiv>y'\"\n  assumes \"R x' y' \\<equiv> R' x' y'\"\n  shows \"invalid_assn R x y = invalid_assn R' x' y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invalid_assn R x y = invalid_assn R' x' y'", "using assms"], ["proof (prove)\nusing this:\n  x \\<equiv> x'\n  y \\<equiv> y'\n  R x' y' \\<equiv> R' x' y'\n\ngoal (1 subgoal):\n 1. invalid_assn R x y = invalid_assn R' x' y'", "unfolding invalid_assn_def"], ["proof (prove)\nusing this:\n  x \\<equiv> x'\n  y \\<equiv> y'\n  R x' y' \\<equiv> R' x' y'\n\ngoal (1 subgoal):\n 1. \\<up> (\\<exists>h. h \\<Turnstile> R x y) * true =\n    \\<up> (\\<exists>h. h \\<Turnstile> R' x' y') * true", "by simp"], ["", "subsection \\<open>Constraints in Refinement Relations\\<close>"], ["", "lemma mod_pure_conv[simp]: \"(h,as)\\<Turnstile>pure R a b \\<longleftrightarrow> (as={} \\<and> (b,a)\\<in>R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((h, as) \\<Turnstile> pure R a b) = (as = {} \\<and> (b, a) \\<in> R)", "by (auto simp: pure_def)"], ["", "definition rdomp :: \"('a \\<Rightarrow> 'c \\<Rightarrow> assn) \\<Rightarrow> 'a \\<Rightarrow> bool\" where\n  \"rdomp R a \\<equiv> \\<exists>h c. h \\<Turnstile> R a c\""], ["", "abbreviation \"rdom R \\<equiv> Collect (rdomp R)\""], ["", "lemma rdomp_ctxt[simp]: \"rdomp (hn_ctxt R) = rdomp R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rdomp (hn_ctxt R) = rdomp R", "by (simp add: hn_ctxt_def[abs_def])"], ["", "lemma rdomp_pure[simp]: \"rdomp (pure R) a \\<longleftrightarrow> a\\<in>Range R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rdomp (pure R) a = (a \\<in> Range R)", "unfolding rdomp_def pure_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>h c. h \\<Turnstile> \\<up> ((c, a) \\<in> R)) =\n    (a \\<in> Range R)", "by auto"], ["", "lemma rdom_pure[simp]: \"rdom (pure R) = Range R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rdom (pure R) = Range R", "unfolding rdomp_def[abs_def] pure_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {a. \\<exists>h c. h \\<Turnstile> \\<up> ((c, a) \\<in> R)} = Range R", "by auto"], ["", "lemma Range_of_constraint_conv[simp]: \"Range (A\\<inter>UNIV\\<times>C) = Range A \\<inter> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Range (A \\<inter> UNIV \\<times> C) = Range A \\<inter> C", "by auto"], ["", "subsection \\<open>Heap-Nres Refinement Calculus\\<close>"], ["", "text \\<open>Predicate that expresses refinement. Given a heap\n  \\<open>\\<Gamma>\\<close>, program \\<open>c\\<close> produces a heap \\<open>\\<Gamma>'\\<close> and\n  a concrete result that is related with predicate \\<open>R\\<close> to some\n  abstract result from \\<open>m\\<close>\\<close>"], ["", "definition \"hn_refine \\<Gamma> c \\<Gamma>' R m \\<equiv> nofail m \\<longrightarrow>\n  <\\<Gamma>> c <\\<lambda>r. \\<Gamma>' * (\\<exists>\\<^sub>Ax. R x r * \\<up>(RETURN x \\<le> m)) >\\<^sub>t\""], ["", "(* TODO: Can we change the patterns of assn_simproc to add this pattern? *)"], ["", "simproc_setup assn_simproc_hnr (\"hn_refine \\<Gamma> c \\<Gamma>'\")\n  = \\<open>K Seplogic_Auto.assn_simproc_fun\\<close>"], ["", "lemma hn_refineI[intro?]:\n  assumes \"nofail m \n    \\<Longrightarrow> <\\<Gamma>> c <\\<lambda>r. \\<Gamma>' * (\\<exists>\\<^sub>Ax. R x r * \\<up>(RETURN x \\<le> m)) >\\<^sub>t\"\n  shows \"hn_refine \\<Gamma> c \\<Gamma>' R m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine \\<Gamma> c \\<Gamma>' R m", "using assms"], ["proof (prove)\nusing this:\n  nofail m \\<Longrightarrow>\n  <\\<Gamma>> c <\\<lambda>r.\n                   \\<Gamma>' *\n                   (\\<exists>\\<^sub>Ax.\n                       R x r * \\<up> (RETURN x \\<le> m))>\\<^sub>t\n\ngoal (1 subgoal):\n 1. hn_refine \\<Gamma> c \\<Gamma>' R m", "unfolding hn_refine_def"], ["proof (prove)\nusing this:\n  nofail m \\<Longrightarrow>\n  <\\<Gamma>> c <\\<lambda>r.\n                   \\<Gamma>' *\n                   (\\<exists>\\<^sub>Ax.\n                       R x r * \\<up> (RETURN x \\<le> m))>\\<^sub>t\n\ngoal (1 subgoal):\n 1. nofail m \\<longrightarrow>\n    <\\<Gamma>> c <\\<lambda>r.\n                     \\<Gamma>' *\n                     (\\<exists>\\<^sub>Ax.\n                         R x r * \\<up> (RETURN x \\<le> m))>\\<^sub>t", "by blast"], ["", "lemma hn_refineD:\n  assumes \"hn_refine \\<Gamma> c \\<Gamma>' R m\"\n  assumes \"nofail m\"\n  shows \"<\\<Gamma>> c <\\<lambda>r. \\<Gamma>' * (\\<exists>\\<^sub>Ax. R x r * \\<up>(RETURN x \\<le> m)) >\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<Gamma>> c <\\<lambda>r.\n                     \\<Gamma>' *\n                     (\\<exists>\\<^sub>Ax.\n                         R x r * \\<up> (RETURN x \\<le> m))>\\<^sub>t", "using assms"], ["proof (prove)\nusing this:\n  hn_refine \\<Gamma> c \\<Gamma>' R m\n  nofail m\n\ngoal (1 subgoal):\n 1. <\\<Gamma>> c <\\<lambda>r.\n                     \\<Gamma>' *\n                     (\\<exists>\\<^sub>Ax.\n                         R x r * \\<up> (RETURN x \\<le> m))>\\<^sub>t", "unfolding hn_refine_def"], ["proof (prove)\nusing this:\n  nofail m \\<longrightarrow>\n  <\\<Gamma>> c <\\<lambda>r.\n                   \\<Gamma>' *\n                   (\\<exists>\\<^sub>Ax.\n                       R x r * \\<up> (RETURN x \\<le> m))>\\<^sub>t\n  nofail m\n\ngoal (1 subgoal):\n 1. <\\<Gamma>> c <\\<lambda>r.\n                     \\<Gamma>' *\n                     (\\<exists>\\<^sub>Ax.\n                         R x r * \\<up> (RETURN x \\<le> m))>\\<^sub>t", "by blast"], ["", "lemma hn_refine_preI: \n  assumes \"\\<And>h. h\\<Turnstile>\\<Gamma> \\<Longrightarrow> hn_refine \\<Gamma> c \\<Gamma>' R a\"\n  shows \"hn_refine \\<Gamma> c \\<Gamma>' R a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine \\<Gamma> c \\<Gamma>' R a", "using assms"], ["proof (prove)\nusing this:\n  ?h \\<Turnstile> \\<Gamma> \\<Longrightarrow>\n  hn_refine \\<Gamma> c \\<Gamma>' R a\n\ngoal (1 subgoal):\n 1. hn_refine \\<Gamma> c \\<Gamma>' R a", "unfolding hn_refine_def"], ["proof (prove)\nusing this:\n  ?h \\<Turnstile> \\<Gamma> \\<Longrightarrow>\n  nofail a \\<longrightarrow>\n  <\\<Gamma>> c <\\<lambda>r.\n                   \\<Gamma>' *\n                   (\\<exists>\\<^sub>Ax.\n                       R x r * \\<up> (RETURN x \\<le> a))>\\<^sub>t\n\ngoal (1 subgoal):\n 1. nofail a \\<longrightarrow>\n    <\\<Gamma>> c <\\<lambda>r.\n                     \\<Gamma>' *\n                     (\\<exists>\\<^sub>Ax.\n                         R x r * \\<up> (RETURN x \\<le> a))>\\<^sub>t", "by (auto intro: hoare_triple_preI)"], ["", "lemma hn_refine_nofailI: \n  assumes \"nofail a \\<Longrightarrow> hn_refine \\<Gamma> c \\<Gamma>' R a\"  \n  shows \"hn_refine \\<Gamma> c \\<Gamma>' R a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine \\<Gamma> c \\<Gamma>' R a", "using assms"], ["proof (prove)\nusing this:\n  nofail a \\<Longrightarrow> hn_refine \\<Gamma> c \\<Gamma>' R a\n\ngoal (1 subgoal):\n 1. hn_refine \\<Gamma> c \\<Gamma>' R a", "by (auto simp: hn_refine_def)"], ["", "lemma hn_refine_false[simp]: \"hn_refine false c \\<Gamma>' R m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine false c \\<Gamma>' R m", "by rule auto"], ["", "lemma hn_refine_fail[simp]: \"hn_refine \\<Gamma> c \\<Gamma>' R FAIL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine \\<Gamma> c \\<Gamma>' R FAIL", "by rule auto"], ["", "lemma hn_refine_frame:\n  assumes \"hn_refine P' c Q' R m\"\n  assumes \"P \\<Longrightarrow>\\<^sub>t F * P'\"\n  shows \"hn_refine P c (F * Q') R m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine P c (F * Q') R m", "using assms"], ["proof (prove)\nusing this:\n  hn_refine P' c Q' R m\n  P \\<Longrightarrow>\\<^sub>t F * P'\n\ngoal (1 subgoal):\n 1. hn_refine P c (F * Q') R m", "unfolding hn_refine_def entailst_def"], ["proof (prove)\nusing this:\n  nofail m \\<longrightarrow>\n  <P'> c <\\<lambda>r.\n             Q' *\n             (\\<exists>\\<^sub>Ax. R x r * \\<up> (RETURN x \\<le> m))>\\<^sub>t\n  P \\<Longrightarrow>\\<^sub>A F * P' * true\n\ngoal (1 subgoal):\n 1. nofail m \\<longrightarrow>\n    <P> c <\\<lambda>r.\n              F * Q' *\n              (\\<exists>\\<^sub>Ax.\n                  R x r * \\<up> (RETURN x \\<le> m))>\\<^sub>t", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<Longrightarrow>\\<^sub>A F * P' * true; nofail m;\n     <P'> c\n     <\\<lambda>r.\n         \\<exists>\\<^sub>Ax.\n            Q' * R x r * true * \\<up> (RETURN x \\<le> m)>\\<rbrakk>\n    \\<Longrightarrow> <P> c\n                      <\\<lambda>r.\n                          \\<exists>\\<^sub>Ax.\n                             F * Q' * R x r * true *\n                             \\<up> (RETURN x \\<le> m)>", "apply (erule cons_pre_rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nofail m;\n     <P'> c\n     <\\<lambda>r.\n         \\<exists>\\<^sub>Ax.\n            Q' * R x r * true * \\<up> (RETURN x \\<le> m)>\\<rbrakk>\n    \\<Longrightarrow> <F * P' * true> c\n                      <\\<lambda>x.\n                          \\<exists>\\<^sub>Axa.\n                             F * Q' * R xa x * true *\n                             \\<up> (RETURN xa \\<le> m)>", "apply (rule cons_post_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>nofail m;\n     <P'> c\n     <\\<lambda>r.\n         \\<exists>\\<^sub>Ax.\n            Q' * R x r * true * \\<up> (RETURN x \\<le> m)>\\<rbrakk>\n    \\<Longrightarrow> <F * P' * true> c <?Q8>\n 2. \\<And>x.\n       \\<lbrakk>nofail m;\n        <P'> c\n        <\\<lambda>r.\n            \\<exists>\\<^sub>Ax.\n               Q' * R x r * true * \\<up> (RETURN x \\<le> m)>\\<rbrakk>\n       \\<Longrightarrow> ?Q8 x \\<Longrightarrow>\\<^sub>A\n                         \\<exists>\\<^sub>Axa.\n                            F * Q' * R xa x * true *\n                            \\<up> (RETURN xa \\<le> m)", "apply (erule fi_rule, frame_inference)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>nofail m;\n        <P'> c\n        <\\<lambda>r.\n            \\<exists>\\<^sub>Ax.\n               Q' * R x r * true * \\<up> (RETURN x \\<le> m)>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>\\<^sub>Axa.\n                             Q' * R xa x * true *\n                             \\<up> (RETURN xa \\<le> m)) *\n                         (F * true) \\<Longrightarrow>\\<^sub>A\n                         \\<exists>\\<^sub>Axa.\n                            F * Q' * R xa x * true *\n                            \\<up> (RETURN xa \\<le> m)", "apply (simp only: star_aci)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>nofail m;\n        <P'> c\n        <\\<lambda>r.\n            \\<exists>\\<^sub>Ax.\n               true * (Q' * (R x r * \\<up> (RETURN x \\<le> m)))>\\<rbrakk>\n       \\<Longrightarrow> F *\n                         (true *\n                          (\\<exists>\\<^sub>Axa.\n                              true *\n                              (Q' *\n                               (R xa x *\n                                \\<up>\n                                 (RETURN xa\n                                  \\<le> m))))) \\<Longrightarrow>\\<^sub>A\n                         \\<exists>\\<^sub>Axa.\n                            F *\n                            (true *\n                             (Q' * (R xa x * \\<up> (RETURN xa \\<le> m))))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hn_refine_cons:\n  assumes I: \"P\\<Longrightarrow>\\<^sub>tP'\"\n  assumes R: \"hn_refine P' c Q R m\"\n  assumes I': \"Q\\<Longrightarrow>\\<^sub>tQ'\"\n  assumes R': \"\\<And>x y. R x y \\<Longrightarrow>\\<^sub>t R' x y\"\n  shows \"hn_refine P c Q' R' m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine P c Q' R' m", "using R"], ["proof (prove)\nusing this:\n  hn_refine P' c Q R m\n\ngoal (1 subgoal):\n 1. hn_refine P c Q' R' m", "unfolding hn_refine_def"], ["proof (prove)\nusing this:\n  nofail m \\<longrightarrow>\n  <P'> c <\\<lambda>r.\n             Q *\n             (\\<exists>\\<^sub>Ax. R x r * \\<up> (RETURN x \\<le> m))>\\<^sub>t\n\ngoal (1 subgoal):\n 1. nofail m \\<longrightarrow>\n    <P> c <\\<lambda>r.\n              Q' *\n              (\\<exists>\\<^sub>Ax.\n                  R' x r * \\<up> (RETURN x \\<le> m))>\\<^sub>t", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nofail m;\n     <P'> c <\\<lambda>r.\n                Q *\n                (\\<exists>\\<^sub>Ax.\n                    R x r * \\<up> (RETURN x \\<le> m))>\\<^sub>t\\<rbrakk>\n    \\<Longrightarrow> <P> c <\\<lambda>r.\n                                Q' *\n                                (\\<exists>\\<^sub>Ax.\n                                    R' x r *\n                                    \\<up> (RETURN x \\<le> m))>\\<^sub>t", "apply (rule cons_pre_rulet[OF I])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nofail m;\n     <P'> c <\\<lambda>r.\n                Q *\n                (\\<exists>\\<^sub>Ax.\n                    R x r * \\<up> (RETURN x \\<le> m))>\\<^sub>t\\<rbrakk>\n    \\<Longrightarrow> <P'> c <\\<lambda>r.\n                                 Q' *\n                                 (\\<exists>\\<^sub>Ax.\n                                     R' x r *\n                                     \\<up> (RETURN x \\<le> m))>\\<^sub>t", "apply (rule cons_post_rulet)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>nofail m;\n     <P'> c <\\<lambda>r.\n                Q *\n                (\\<exists>\\<^sub>Ax.\n                    R x r * \\<up> (RETURN x \\<le> m))>\\<^sub>t\\<rbrakk>\n    \\<Longrightarrow> <P'> c <?Q6>\\<^sub>t\n 2. \\<And>x.\n       \\<lbrakk>nofail m;\n        <P'> c <\\<lambda>r.\n                   Q *\n                   (\\<exists>\\<^sub>Ax.\n                       R x r * \\<up> (RETURN x \\<le> m))>\\<^sub>t\\<rbrakk>\n       \\<Longrightarrow> ?Q6 x \\<Longrightarrow>\\<^sub>t\n                         Q' *\n                         (\\<exists>\\<^sub>Axa.\n                             R' xa x * \\<up> (RETURN xa \\<le> m))", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>nofail m;\n        <P'> c <\\<lambda>r.\n                   Q *\n                   (\\<exists>\\<^sub>Ax.\n                       R x r * \\<up> (RETURN x \\<le> m))>\\<^sub>t\\<rbrakk>\n       \\<Longrightarrow> Q *\n                         (\\<exists>\\<^sub>Axa.\n                             R xa x *\n                             \\<up>\n                              (RETURN xa \\<le> m)) \\<Longrightarrow>\\<^sub>t\n                         Q' *\n                         (\\<exists>\\<^sub>Axa.\n                             R' xa x * \\<up> (RETURN xa \\<le> m))", "apply (sep_auto simp: entailst_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>nofail m;\n        <P'> c\n        <\\<lambda>r.\n            \\<exists>\\<^sub>Ax.\n               Q * R x r * true * \\<up> (RETURN x \\<le> m)>;\n        RETURN xa \\<le> m\\<rbrakk>\n       \\<Longrightarrow> Q * R xa x \\<Longrightarrow>\\<^sub>A\n                         Q' * R' xa x * true", "apply (rule enttD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>nofail m;\n        <P'> c\n        <\\<lambda>r.\n            \\<exists>\\<^sub>Ax.\n               Q * R x r * true * \\<up> (RETURN x \\<le> m)>;\n        RETURN xa \\<le> m\\<rbrakk>\n       \\<Longrightarrow> Q * R xa x \\<Longrightarrow>\\<^sub>t Q' * R' xa x", "apply (intro entt_star_mono I' R')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*lemma hn_refine_cons:\n  assumes I: \"P\\<Longrightarrow>\\<^sub>AP'\"\n  assumes R: \"hn_refine P' c Q R m\"\n  assumes I': \"Q\\<Longrightarrow>\\<^sub>AQ'\"\n  assumes R': \"\\<And>x y. R x y \\<Longrightarrow>\\<^sub>A R' x y\"\n  shows \"hn_refine P c Q' R' m\"\n  using R unfolding hn_refine_def\n  apply clarsimp\n  apply (rule cons_pre_rule[OF I])\n  apply (erule cons_post_rule)\n  apply (rule ent_star_mono ent_refl I' R' ent_ex_preI ent_ex_postI)+\n  done\n*)"], ["", "lemma hn_refine_cons_pre:\n  assumes I: \"P\\<Longrightarrow>\\<^sub>tP'\"\n  assumes R: \"hn_refine P' c Q R m\"\n  shows \"hn_refine P c Q R m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine P c Q R m", "by (rule hn_refine_cons[OF I R]) sep_auto+"], ["", "lemma hn_refine_cons_post:\n  assumes R: \"hn_refine P c Q R m\"\n  assumes I: \"Q\\<Longrightarrow>\\<^sub>tQ'\"\n  shows \"hn_refine P c Q' R m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine P c Q' R m", "using assms"], ["proof (prove)\nusing this:\n  hn_refine P c Q R m\n  Q \\<Longrightarrow>\\<^sub>t Q'\n\ngoal (1 subgoal):\n 1. hn_refine P c Q' R m", "by (rule hn_refine_cons[OF entt_refl _ _ entt_refl])"], ["", "lemma hn_refine_cons_res: \n  \"\\<lbrakk> hn_refine \\<Gamma> f \\<Gamma>' R g; \\<And>a c. R a c \\<Longrightarrow>\\<^sub>t R' a c \\<rbrakk> \\<Longrightarrow> hn_refine \\<Gamma> f \\<Gamma>' R' g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hn_refine \\<Gamma> f \\<Gamma>' R g;\n     \\<And>a c. R a c \\<Longrightarrow>\\<^sub>t R' a c\\<rbrakk>\n    \\<Longrightarrow> hn_refine \\<Gamma> f \\<Gamma>' R' g", "by (erule hn_refine_cons[OF entt_refl]) sep_auto+"], ["", "lemma hn_refine_ref:\n  assumes LE: \"m\\<le>m'\"\n  assumes R: \"hn_refine P c Q R m\"\n  shows \"hn_refine P c Q R m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine P c Q R m'", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail m' \\<Longrightarrow>\n    <P> c <\\<lambda>r.\n              Q *\n              (\\<exists>\\<^sub>Ax.\n                  R x r * \\<up> (RETURN x \\<le> m'))>\\<^sub>t", "apply (rule cons_post_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. nofail m' \\<Longrightarrow> <P> c <?Q2>\n 2. \\<And>x.\n       nofail m' \\<Longrightarrow>\n       ?Q2 x \\<Longrightarrow>\\<^sub>A\n       Q * (\\<exists>\\<^sub>Axa. R xa x * \\<up> (RETURN xa \\<le> m')) * true", "apply (rule hn_refineD[OF R])"], ["proof (prove)\ngoal (2 subgoals):\n 1. nofail m' \\<Longrightarrow> nofail m\n 2. \\<And>x.\n       nofail m' \\<Longrightarrow>\n       Q * (\\<exists>\\<^sub>Axa. R xa x * \\<up> (RETURN xa \\<le> m)) *\n       true \\<Longrightarrow>\\<^sub>A\n       Q * (\\<exists>\\<^sub>Axa. R xa x * \\<up> (RETURN xa \\<le> m')) * true", "using LE"], ["proof (prove)\nusing this:\n  m \\<le> m'\n\ngoal (2 subgoals):\n 1. nofail m' \\<Longrightarrow> nofail m\n 2. \\<And>x.\n       nofail m' \\<Longrightarrow>\n       Q * (\\<exists>\\<^sub>Axa. R xa x * \\<up> (RETURN xa \\<le> m)) *\n       true \\<Longrightarrow>\\<^sub>A\n       Q * (\\<exists>\\<^sub>Axa. R xa x * \\<up> (RETURN xa \\<le> m')) * true", "apply (simp add: pw_le_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       nofail m' \\<Longrightarrow>\n       Q * (\\<exists>\\<^sub>Axa. R xa x * \\<up> (RETURN xa \\<le> m)) *\n       true \\<Longrightarrow>\\<^sub>A\n       Q * (\\<exists>\\<^sub>Axa. R xa x * \\<up> (RETURN xa \\<le> m')) * true", "apply (sep_auto intro: order_trans[OF _ LE])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hn_refine_cons_complete:\n  assumes I: \"P\\<Longrightarrow>\\<^sub>tP'\"\n  assumes R: \"hn_refine P' c Q R m\"\n  assumes I': \"Q\\<Longrightarrow>\\<^sub>tQ'\"\n  assumes R': \"\\<And>x y. R x y \\<Longrightarrow>\\<^sub>t R' x y\"\n  assumes LE: \"m\\<le>m'\"\n  shows \"hn_refine P c Q' R' m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine P c Q' R' m'", "apply (rule hn_refine_ref[OF LE])"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine P c Q' R' m", "apply (rule hn_refine_cons[OF I R I' R'])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hn_refine_augment_res:\n  assumes A: \"hn_refine \\<Gamma> f \\<Gamma>' R g\"\n  assumes B: \"g \\<le>\\<^sub>n SPEC \\<Phi>\"\n  shows \"hn_refine \\<Gamma> f \\<Gamma>' (\\<lambda>a c. R a c * \\<up>(\\<Phi> a)) g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine \\<Gamma> f \\<Gamma>' (\\<lambda>a c. R a c * \\<up> (\\<Phi> a))\n     g", "apply (rule hn_refineI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail g \\<Longrightarrow>\n    <\\<Gamma>> f <\\<lambda>r.\n                     \\<Gamma>' *\n                     (\\<exists>\\<^sub>Ax.\n                         R x r * \\<up> (\\<Phi> x) *\n                         \\<up> (RETURN x \\<le> g))>\\<^sub>t", "apply (rule cons_post_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. nofail g \\<Longrightarrow> <\\<Gamma>> f <?Q2>\n 2. \\<And>x.\n       nofail g \\<Longrightarrow>\n       ?Q2 x \\<Longrightarrow>\\<^sub>A\n       \\<Gamma>' *\n       (\\<exists>\\<^sub>Axa.\n           R xa x * \\<up> (\\<Phi> xa) * \\<up> (RETURN xa \\<le> g)) *\n       true", "apply (erule A[THEN hn_refineD])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       nofail g \\<Longrightarrow>\n       \\<Gamma>' *\n       (\\<exists>\\<^sub>Axa. R xa x * \\<up> (RETURN xa \\<le> g)) *\n       true \\<Longrightarrow>\\<^sub>A\n       \\<Gamma>' *\n       (\\<exists>\\<^sub>Axa.\n           R xa x * \\<up> (\\<Phi> xa) * \\<up> (RETURN xa \\<le> g)) *\n       true", "using B"], ["proof (prove)\nusing this:\n  g \\<le>\\<^sub>n SPEC \\<Phi>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       nofail g \\<Longrightarrow>\n       \\<Gamma>' *\n       (\\<exists>\\<^sub>Axa. R xa x * \\<up> (RETURN xa \\<le> g)) *\n       true \\<Longrightarrow>\\<^sub>A\n       \\<Gamma>' *\n       (\\<exists>\\<^sub>Axa.\n           R xa x * \\<up> (\\<Phi> xa) * \\<up> (RETURN xa \\<le> g)) *\n       true", "apply (sep_auto simp: pw_le_iff pw_leof_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Product Types\\<close>"], ["", "text \\<open>Some notion for product types is already defined here, as it is used \n  for currying and uncurrying, which is fundamental for the sepref tool\\<close>"], ["", "definition prod_assn :: \"('a1\\<Rightarrow>'c1\\<Rightarrow>assn) \\<Rightarrow> ('a2\\<Rightarrow>'c2\\<Rightarrow>assn) \n  \\<Rightarrow> 'a1*'a2 \\<Rightarrow> 'c1*'c2 \\<Rightarrow> assn\" where\n  \"prod_assn P1 P2 a c \\<equiv> case (a,c) of ((a1,a2),(c1,c2)) \\<Rightarrow>\n  P1 a1 c1 * P2 a2 c2\""], ["", "notation prod_assn (infixr \"\\<times>\\<^sub>a\" 70)"], ["", "lemma prod_assn_pure_conv[simp]: \"prod_assn (pure R1) (pure R2) = pure (R1 \\<times>\\<^sub>r R2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure R1 \\<times>\\<^sub>a pure R2 = pure (R1 \\<times>\\<^sub>r R2)", "by (auto simp: pure_def prod_assn_def intro!: ext)"], ["", "lemma prod_assn_pair_conv[simp]: \n  \"prod_assn A B (a1,b1) (a2,b2) = A a1 a2 * B b1 b2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<times>\\<^sub>a B) (a1, b1) (a2, b2) = A a1 a2 * B b1 b2", "unfolding prod_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case ((a1, b1), a2, b2) of\n     ((a1, a2), c1, c2) \\<Rightarrow> A a1 c1 * B a2 c2) =\n    A a1 a2 * B b1 b2", "by auto"], ["", "lemma prod_assn_true[simp]: \"prod_assn (\\<lambda>_ _. true) (\\<lambda>_ _. true) = (\\<lambda>_ _. true)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>_ _. true) \\<times>\\<^sub>a (\\<lambda>_ _. true) =\n    (\\<lambda>_ _. true)", "by (auto intro!: ext simp: hn_ctxt_def prod_assn_def)"], ["", "subsection \"Convenience Lemmas\""], ["", "lemma hn_refine_guessI:\n  assumes \"hn_refine P f P' R f'\"\n  assumes \"f=f_conc\"\n  shows \"hn_refine P f_conc P' R f'\"\n  \\<comment> \\<open>To prove a refinement, first synthesize one, and then prove equality\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine P f_conc P' R f'", "using assms"], ["proof (prove)\nusing this:\n  hn_refine P f P' R f'\n  f = f_conc\n\ngoal (1 subgoal):\n 1. hn_refine P f_conc P' R f'", "by simp"], ["", "lemma imp_correctI:\n  assumes R: \"hn_refine \\<Gamma> c \\<Gamma>' R a\"\n  assumes C: \"a \\<le> SPEC \\<Phi>\"\n  shows \"<\\<Gamma>> c <\\<lambda>r'. \\<exists>\\<^sub>Ar. \\<Gamma>' * R r r' * \\<up>(\\<Phi> r)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<Gamma>> c <\\<lambda>r.\n                     \\<exists>\\<^sub>Ara.\n                        \\<Gamma>' * R ra r * \\<up> (\\<Phi> ra)>\\<^sub>t", "apply (rule cons_post_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. <\\<Gamma>> c <?Q>\n 2. \\<And>x.\n       ?Q x \\<Longrightarrow>\\<^sub>A\n       (\\<exists>\\<^sub>Ar. \\<Gamma>' * R r x * \\<up> (\\<Phi> r)) * true", "apply (rule hn_refineD[OF R])"], ["proof (prove)\ngoal (2 subgoals):\n 1. nofail a\n 2. \\<And>x.\n       \\<Gamma>' *\n       (\\<exists>\\<^sub>Axa. R xa x * \\<up> (RETURN xa \\<le> a)) *\n       true \\<Longrightarrow>\\<^sub>A\n       (\\<exists>\\<^sub>Ar. \\<Gamma>' * R r x * \\<up> (\\<Phi> r)) * true", "apply (rule le_RES_nofailI[OF C])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<Gamma>' *\n       (\\<exists>\\<^sub>Axa. R xa x * \\<up> (RETURN xa \\<le> a)) *\n       true \\<Longrightarrow>\\<^sub>A\n       (\\<exists>\\<^sub>Ar. \\<Gamma>' * R r x * \\<up> (\\<Phi> r)) * true", "apply (sep_auto dest: order_trans[OF _ C])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hnr_pre_ex_conv: \n  shows \"hn_refine (\\<exists>\\<^sub>Ax. \\<Gamma> x) c \\<Gamma>' R a \\<longleftrightarrow> (\\<forall>x. hn_refine (\\<Gamma> x) c \\<Gamma>' R a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (\\<exists>\\<^sub>Ax. \\<Gamma> x) c \\<Gamma>' R a =\n    (\\<forall>x. hn_refine (\\<Gamma> x) c \\<Gamma>' R a)", "unfolding hn_refine_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (nofail a \\<longrightarrow>\n     <ex_assn\n       \\<Gamma>> c <\\<lambda>r.\n                       \\<Gamma>' *\n                       (\\<exists>\\<^sub>Ax.\n                           R x r * \\<up> (RETURN x \\<le> a))>\\<^sub>t) =\n    (\\<forall>x.\n        nofail a \\<longrightarrow>\n        <\\<Gamma>\n          x> c <\\<lambda>r.\n                   \\<Gamma>' *\n                   (\\<exists>\\<^sub>Ax.\n                       R x r * \\<up> (RETURN x \\<le> a))>\\<^sub>t)", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>nofail a;\n        <ex_assn\n          \\<Gamma>> c <\\<lambda>r.\n                          \\<Gamma>' *\n                          (\\<exists>\\<^sub>Ax.\n                              R x r *\n                              \\<up> (RETURN x \\<le> a))>\\<^sub>t\\<rbrakk>\n       \\<Longrightarrow> <\\<Gamma>\n                           x> c <\\<lambda>r.\n                                    \\<Gamma>' *\n                                    (\\<exists>\\<^sub>Ax.\n  R x r * \\<up> (RETURN x \\<le> a))>\\<^sub>t\n 2. \\<lbrakk>\\<forall>x.\n                nofail a \\<longrightarrow>\n                <\\<Gamma>\n                  x> c <\\<lambda>r.\n                           \\<Gamma>' *\n                           (\\<exists>\\<^sub>Ax.\n                               R x r * \\<up> (RETURN x \\<le> a))>\\<^sub>t;\n     nofail a\\<rbrakk>\n    \\<Longrightarrow> <ex_assn\n                        \\<Gamma>> c <\\<lambda>r.\n  \\<Gamma>' *\n  (\\<exists>\\<^sub>Ax. R x r * \\<up> (RETURN x \\<le> a))>\\<^sub>t", "apply (erule cons_pre_rule[rotated])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       nofail a \\<Longrightarrow>\n       \\<Gamma> x \\<Longrightarrow>\\<^sub>A ex_assn \\<Gamma>\n 2. \\<lbrakk>\\<forall>x.\n                nofail a \\<longrightarrow>\n                <\\<Gamma>\n                  x> c <\\<lambda>r.\n                           \\<Gamma>' *\n                           (\\<exists>\\<^sub>Ax.\n                               R x r * \\<up> (RETURN x \\<le> a))>\\<^sub>t;\n     nofail a\\<rbrakk>\n    \\<Longrightarrow> <ex_assn\n                        \\<Gamma>> c <\\<lambda>r.\n  \\<Gamma>' *\n  (\\<exists>\\<^sub>Ax. R x r * \\<up> (RETURN x \\<le> a))>\\<^sub>t", "apply (rule ent_ex_postI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       nofail a \\<Longrightarrow>\n       \\<Gamma> x \\<Longrightarrow>\\<^sub>A \\<Gamma> (?x7 x)\n 2. \\<lbrakk>\\<forall>x.\n                nofail a \\<longrightarrow>\n                <\\<Gamma>\n                  x> c <\\<lambda>r.\n                           \\<Gamma>' *\n                           (\\<exists>\\<^sub>Ax.\n                               R x r * \\<up> (RETURN x \\<le> a))>\\<^sub>t;\n     nofail a\\<rbrakk>\n    \\<Longrightarrow> <ex_assn\n                        \\<Gamma>> c <\\<lambda>r.\n  \\<Gamma>' *\n  (\\<exists>\\<^sub>Ax. R x r * \\<up> (RETURN x \\<le> a))>\\<^sub>t", "apply (rule ent_refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x.\n                nofail a \\<longrightarrow>\n                <\\<Gamma>\n                  x> c <\\<lambda>r.\n                           \\<Gamma>' *\n                           (\\<exists>\\<^sub>Ax.\n                               R x r * \\<up> (RETURN x \\<le> a))>\\<^sub>t;\n     nofail a\\<rbrakk>\n    \\<Longrightarrow> <ex_assn\n                        \\<Gamma>> c <\\<lambda>r.\n  \\<Gamma>' *\n  (\\<exists>\\<^sub>Ax. R x r * \\<up> (RETURN x \\<le> a))>\\<^sub>t", "apply sep_auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hnr_pre_pure_conv:  \n  shows \"hn_refine (\\<Gamma> * \\<up>P) c \\<Gamma>' R a \\<longleftrightarrow> (P \\<longrightarrow> hn_refine \\<Gamma> c \\<Gamma>' R a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (\\<Gamma> * \\<up> P) c \\<Gamma>' R a =\n    (P \\<longrightarrow> hn_refine \\<Gamma> c \\<Gamma>' R a)", "unfolding hn_refine_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (nofail a \\<longrightarrow>\n     <\\<Gamma> *\n      \\<up>\n       P> c <\\<lambda>r.\n                \\<Gamma>' *\n                (\\<exists>\\<^sub>Ax.\n                    R x r * \\<up> (RETURN x \\<le> a))>\\<^sub>t) =\n    (P \\<longrightarrow>\n     nofail a \\<longrightarrow>\n     <\\<Gamma>> c <\\<lambda>r.\n                      \\<Gamma>' *\n                      (\\<exists>\\<^sub>Ax.\n                          R x r * \\<up> (RETURN x \\<le> a))>\\<^sub>t)", "by auto"], ["", "lemma hn_refine_split_post:\n  assumes \"hn_refine \\<Gamma> c \\<Gamma>' R a\"\n  shows \"hn_refine \\<Gamma> c (\\<Gamma>' \\<or>\\<^sub>A \\<Gamma>'') R a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine \\<Gamma> c (\\<Gamma>' \\<or>\\<^sub>A \\<Gamma>'') R a", "apply (rule hn_refine_cons_post[OF assms])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>' \\<Longrightarrow>\\<^sub>t \\<Gamma>' \\<or>\\<^sub>A \\<Gamma>''", "by (rule entt_disjI1_direct)"], ["", "lemma hn_refine_post_other: \n  assumes \"hn_refine \\<Gamma> c \\<Gamma>'' R a\"\n  shows \"hn_refine \\<Gamma> c (\\<Gamma>' \\<or>\\<^sub>A \\<Gamma>'') R a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine \\<Gamma> c (\\<Gamma>' \\<or>\\<^sub>A \\<Gamma>'') R a", "apply (rule hn_refine_cons_post[OF assms])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>'' \\<Longrightarrow>\\<^sub>t \\<Gamma>' \\<or>\\<^sub>A \\<Gamma>''", "by (rule entt_disjI2_direct)"], ["", "subsubsection \\<open>Return\\<close>"], ["", "lemma hnr_RETURN_pass:\n  \"hn_refine (hn_ctxt R x p) (return p) (hn_invalid R x p) R (RETURN x)\"\n  \\<comment> \\<open>Pass on a value from the heap as return value\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt R x p) (return p) (hn_invalid R x p) R (RETURN x)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (RETURN x) \\<Longrightarrow>\n    <hn_ctxt R x\n      p> return\n          p <\\<lambda>r.\n                hn_invalid R x p *\n                (\\<exists>\\<^sub>Axa.\n                    R xa r * \\<up> (RETURN xa \\<le> RETURN x))>\\<^sub>t", "apply (sep_auto simp: hn_ctxt_def eintros: invalidate_clone')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hnr_RETURN_pure:\n  assumes \"(c,a)\\<in>R\"\n  shows \"hn_refine emp (return c) emp (pure R) (RETURN a)\"\n  \\<comment> \\<open>Return pure value\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine emp (return c) emp (pure R) (RETURN a)", "unfolding hn_refine_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (RETURN a) \\<longrightarrow>\n    <emp> return\n           c <\\<lambda>r.\n                 emp *\n                 (\\<exists>\\<^sub>Ax.\n                     pure R x r * \\<up> (RETURN x \\<le> RETURN a))>\\<^sub>t", "using assms"], ["proof (prove)\nusing this:\n  (c, a) \\<in> R\n\ngoal (1 subgoal):\n 1. nofail (RETURN a) \\<longrightarrow>\n    <emp> return\n           c <\\<lambda>r.\n                 emp *\n                 (\\<exists>\\<^sub>Ax.\n                     pure R x r * \\<up> (RETURN x \\<le> RETURN a))>\\<^sub>t", "by (sep_auto simp: pure_def)"], ["", "subsubsection \\<open>Assertion\\<close>"], ["", "lemma hnr_FAIL[simp, intro!]: \"hn_refine \\<Gamma> c \\<Gamma>' R FAIL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine \\<Gamma> c \\<Gamma>' R FAIL", "unfolding hn_refine_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail FAIL \\<longrightarrow>\n    <\\<Gamma>> c <\\<lambda>r.\n                     \\<Gamma>' *\n                     (\\<exists>\\<^sub>Ax.\n                         R x r * \\<up> (RETURN x \\<le> FAIL))>\\<^sub>t", "by simp"], ["", "lemma hnr_ASSERT:\n  assumes \"\\<Phi> \\<Longrightarrow> hn_refine \\<Gamma> c \\<Gamma>' R c'\"\n  shows \"hn_refine \\<Gamma> c \\<Gamma>' R (do { ASSERT \\<Phi>; c'})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine \\<Gamma> c \\<Gamma>' R\n     (ASSERT \\<Phi> \\<bind> (\\<lambda>_. c'))", "using assms"], ["proof (prove)\nusing this:\n  \\<Phi> \\<Longrightarrow> hn_refine \\<Gamma> c \\<Gamma>' R c'\n\ngoal (1 subgoal):\n 1. hn_refine \\<Gamma> c \\<Gamma>' R\n     (ASSERT \\<Phi> \\<bind> (\\<lambda>_. c'))", "apply (cases \\<Phi>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Phi> \\<Longrightarrow> hn_refine \\<Gamma> c \\<Gamma>' R c';\n     \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> hn_refine \\<Gamma> c \\<Gamma>' R\n                       (ASSERT \\<Phi> \\<bind> (\\<lambda>_. c'))\n 2. \\<lbrakk>\\<Phi> \\<Longrightarrow> hn_refine \\<Gamma> c \\<Gamma>' R c';\n     \\<not> \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> hn_refine \\<Gamma> c \\<Gamma>' R\n                       (ASSERT \\<Phi> \\<bind> (\\<lambda>_. c'))", "by auto"], ["", "subsubsection \\<open>Bind\\<close>"], ["", "lemma bind_det_aux: \"\\<lbrakk> RETURN x \\<le> m; RETURN y \\<le> f x \\<rbrakk> \\<Longrightarrow> RETURN y \\<le> m \\<bind> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>RETURN x \\<le> m; RETURN y \\<le> f x\\<rbrakk>\n    \\<Longrightarrow> RETURN y \\<le> m \\<bind> f", "apply (rule order_trans[rotated])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>RETURN x \\<le> m; RETURN y \\<le> f x\\<rbrakk>\n    \\<Longrightarrow> ?y \\<le> m \\<bind> f\n 2. \\<lbrakk>RETURN x \\<le> m; RETURN y \\<le> f x\\<rbrakk>\n    \\<Longrightarrow> RETURN y \\<le> ?y", "apply (rule Refine_Basic.bind_mono)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>RETURN x \\<le> m; RETURN y \\<le> f x\\<rbrakk>\n    \\<Longrightarrow> ?M3 \\<le> m\n 2. \\<And>xa.\n       \\<lbrakk>RETURN x \\<le> m; RETURN y \\<le> f x;\n        RETURN xa \\<le> ?M3\\<rbrakk>\n       \\<Longrightarrow> ?f3 xa \\<le> f xa\n 3. \\<lbrakk>RETURN x \\<le> m; RETURN y \\<le> f x\\<rbrakk>\n    \\<Longrightarrow> RETURN y \\<le> ?M3 \\<bind> ?f3", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>RETURN x \\<le> m; RETURN y \\<le> f x;\n        RETURN xa \\<le> RETURN x\\<rbrakk>\n       \\<Longrightarrow> ?f3 xa \\<le> f xa\n 2. \\<lbrakk>RETURN x \\<le> m; RETURN y \\<le> f x\\<rbrakk>\n    \\<Longrightarrow> RETURN y \\<le> RETURN x \\<bind> ?f3", "apply (rule order_refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>RETURN x \\<le> m; RETURN y \\<le> f x\\<rbrakk>\n    \\<Longrightarrow> RETURN y \\<le> RETURN x \\<bind> f", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hnr_bind:\n  assumes D1: \"hn_refine \\<Gamma> m' \\<Gamma>1 Rh m\"\n  assumes D2: \n    \"\\<And>x x'. RETURN x \\<le> m \\<Longrightarrow> hn_refine (\\<Gamma>1 * hn_ctxt Rh x x') (f' x') (\\<Gamma>2 x x') R (f x)\"\n  assumes IMP: \"\\<And>x x'. \\<Gamma>2 x x' \\<Longrightarrow>\\<^sub>t \\<Gamma>' * hn_ctxt Rx x x'\"\n  shows \"hn_refine \\<Gamma> (m'\\<bind>f') \\<Gamma>' R (m\\<bind>f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine \\<Gamma> (m' \\<bind> f') \\<Gamma>' R (m \\<bind> f)", "using assms"], ["proof (prove)\nusing this:\n  hn_refine \\<Gamma> m' \\<Gamma>1 Rh m\n  RETURN ?x \\<le> m \\<Longrightarrow>\n  hn_refine (\\<Gamma>1 * hn_ctxt Rh ?x ?x') (f' ?x') (\\<Gamma>2 ?x ?x') R\n   (f ?x)\n  \\<Gamma>2 ?x ?x' \\<Longrightarrow>\\<^sub>t \\<Gamma>' * hn_ctxt Rx ?x ?x'\n\ngoal (1 subgoal):\n 1. hn_refine \\<Gamma> (m' \\<bind> f') \\<Gamma>' R (m \\<bind> f)", "unfolding hn_refine_def"], ["proof (prove)\nusing this:\n  nofail m \\<longrightarrow>\n  <\\<Gamma>> m' <\\<lambda>r.\n                    \\<Gamma>1 *\n                    (\\<exists>\\<^sub>Ax.\n                        Rh x r * \\<up> (RETURN x \\<le> m))>\\<^sub>t\n  RETURN ?x \\<le> m \\<Longrightarrow>\n  nofail (f ?x) \\<longrightarrow>\n  <\\<Gamma>1 *\n   hn_ctxt Rh ?x\n    ?x'> f' ?x' <\\<lambda>r.\n                    \\<Gamma>2 ?x ?x' *\n                    (\\<exists>\\<^sub>Ax.\n                        R x r * \\<up> (RETURN x \\<le> f ?x))>\\<^sub>t\n  \\<Gamma>2 ?x ?x' \\<Longrightarrow>\\<^sub>t \\<Gamma>' * hn_ctxt Rx ?x ?x'\n\ngoal (1 subgoal):\n 1. nofail (m \\<bind> f) \\<longrightarrow>\n    <\\<Gamma>> m' \\<bind>\n               f' <\\<lambda>r.\n                      \\<Gamma>' *\n                      (\\<exists>\\<^sub>Ax.\n                          R x r *\n                          \\<up> (RETURN x \\<le> m \\<bind> f))>\\<^sub>t", "apply (clarsimp simp add: pw_bind_nofail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x x'.\n                RETURN x \\<le> m \\<Longrightarrow>\n                nofail (f x) \\<longrightarrow> <\\<Gamma>1 * hn_ctxt Rh x x'>\n                f' x'\n                <\\<lambda>r.\n                    \\<exists>\\<^sub>Axa.\n                       \\<Gamma>2 x x' * R xa r * true *\n                       \\<up> (RETURN xa \\<le> f x)>;\n     \\<And>x x'.\n        \\<Gamma>2 x x' \\<Longrightarrow>\\<^sub>t\n        \\<Gamma>' * hn_ctxt Rx x x';\n     nofail m; \\<forall>x. inres m x \\<longrightarrow> nofail (f x);\n     <\\<Gamma>> m'\n     <\\<lambda>r.\n         \\<exists>\\<^sub>Ax.\n            \\<Gamma>1 * Rh x r * true * \\<up> (RETURN x \\<le> m)>\\<rbrakk>\n    \\<Longrightarrow> <\\<Gamma>> m' \\<bind> f'\n                      <\\<lambda>r.\n                          \\<exists>\\<^sub>Ax.\n                             \\<Gamma>' * R x r * true *\n                             \\<up> (RETURN x \\<le> m \\<bind> f)>", "apply (rule Hoare_Triple.bind_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x x'.\n                RETURN x \\<le> m \\<Longrightarrow>\n                nofail (f x) \\<longrightarrow> <\\<Gamma>1 * hn_ctxt Rh x x'>\n                f' x'\n                <\\<lambda>r.\n                    \\<exists>\\<^sub>Axa.\n                       \\<Gamma>2 x x' * R xa r * true *\n                       \\<up> (RETURN xa \\<le> f x)>;\n     \\<And>x x'.\n        \\<Gamma>2 x x' \\<Longrightarrow>\\<^sub>t\n        \\<Gamma>' * hn_ctxt Rx x x';\n     nofail m; \\<forall>x. inres m x \\<longrightarrow> nofail (f x);\n     <\\<Gamma>> m'\n     <\\<lambda>r.\n         \\<exists>\\<^sub>Ax.\n            \\<Gamma>1 * Rh x r * true * \\<up> (RETURN x \\<le> m)>\\<rbrakk>\n    \\<Longrightarrow> <\\<Gamma>> m' <?R9>\n 2. \\<And>x.\n       \\<lbrakk>\\<And>x x'.\n                   RETURN x \\<le> m \\<Longrightarrow>\n                   nofail (f x) \\<longrightarrow>\n                   <\\<Gamma>1 * hn_ctxt Rh x x'> f' x'\n                   <\\<lambda>r.\n                       \\<exists>\\<^sub>Axa.\n                          \\<Gamma>2 x x' * R xa r * true *\n                          \\<up> (RETURN xa \\<le> f x)>;\n        \\<And>x x'.\n           \\<Gamma>2 x x' \\<Longrightarrow>\\<^sub>t\n           \\<Gamma>' * hn_ctxt Rx x x';\n        nofail m; \\<forall>x. inres m x \\<longrightarrow> nofail (f x);\n        <\\<Gamma>> m'\n        <\\<lambda>r.\n            \\<exists>\\<^sub>Ax.\n               \\<Gamma>1 * Rh x r * true *\n               \\<up> (RETURN x \\<le> m)>\\<rbrakk>\n       \\<Longrightarrow> <?R9 x> f' x\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Ax.\n                                \\<Gamma>' * R x r * true *\n                                \\<up> (RETURN x \\<le> m \\<bind> f)>", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>x x'.\n                   RETURN x \\<le> m \\<Longrightarrow>\n                   nofail (f x) \\<longrightarrow>\n                   <\\<Gamma>1 * hn_ctxt Rh x x'> f' x'\n                   <\\<lambda>r.\n                       \\<exists>\\<^sub>Axa.\n                          \\<Gamma>2 x x' * R xa r * true *\n                          \\<up> (RETURN xa \\<le> f x)>;\n        \\<And>x x'.\n           \\<Gamma>2 x x' \\<Longrightarrow>\\<^sub>t\n           \\<Gamma>' * hn_ctxt Rx x x';\n        nofail m; \\<forall>x. inres m x \\<longrightarrow> nofail (f x);\n        <\\<Gamma>> m'\n        <\\<lambda>r.\n            \\<exists>\\<^sub>Ax.\n               \\<Gamma>1 * Rh x r * true *\n               \\<up> (RETURN x \\<le> m)>\\<rbrakk>\n       \\<Longrightarrow> <\\<exists>\\<^sub>Axa.\n                             \\<Gamma>1 * Rh xa x * true *\n                             \\<up> (RETURN xa \\<le> m)>\n                         f' x\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Ax.\n                                \\<Gamma>' * R x r * true *\n                                \\<up> (RETURN x \\<le> m \\<bind> f)>", "apply (clarsimp intro!: normalize_rules simp: hn_ctxt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<And>x x'.\n                   RETURN x \\<le> m \\<Longrightarrow>\n                   nofail (f x) \\<longrightarrow> <\\<Gamma>1 * Rh x x'>\n                   f' x'\n                   <\\<lambda>r.\n                       \\<exists>\\<^sub>Axa.\n                          \\<Gamma>2 x x' * R xa r * true *\n                          \\<up> (RETURN xa \\<le> f x)>;\n        \\<And>x x'.\n           \\<Gamma>2 x x' \\<Longrightarrow>\\<^sub>t \\<Gamma>' * Rx x x';\n        nofail m; \\<forall>x. inres m x \\<longrightarrow> nofail (f x);\n        <\\<Gamma>> m'\n        <\\<lambda>r.\n            \\<exists>\\<^sub>Ax.\n               \\<Gamma>1 * Rh x r * true * \\<up> (RETURN x \\<le> m)>;\n        RETURN xa \\<le> m\\<rbrakk>\n       \\<Longrightarrow> <\\<Gamma>1 * Rh xa x * true> f' x\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Ax.\n                                \\<Gamma>' * R x r * true *\n                                \\<up> (RETURN x \\<le> m \\<bind> f)>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<And>x x'.\n                   RETURN x \\<le> m \\<Longrightarrow>\n                   nofail (f x) \\<longrightarrow> <\\<Gamma>1 * Rh x x'>\n                   f' x'\n                   <\\<lambda>r.\n                       \\<exists>\\<^sub>Axa.\n                          \\<Gamma>2 x x' * R xa r * true *\n                          \\<up> (RETURN xa \\<le> f x)>;\n        \\<And>x x'.\n           \\<Gamma>2 x x' \\<Longrightarrow>\\<^sub>t \\<Gamma>' * Rx x x';\n        nofail m; \\<forall>x. inres m x \\<longrightarrow> nofail (f x);\n        <\\<Gamma>> m'\n        <\\<lambda>r.\n            \\<exists>\\<^sub>Ax.\n               \\<Gamma>1 * Rh x r * true * \\<up> (RETURN x \\<le> m)>;\n        RETURN xa \\<le> m\\<rbrakk>\n       \\<Longrightarrow> <\\<Gamma>1 * Rh xa x * true> f' x\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Ax.\n                                \\<Gamma>' * R x r * true *\n                                \\<up> (RETURN x \\<le> m \\<bind> f)>", "fix x' x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<And>x x'.\n                   RETURN x \\<le> m \\<Longrightarrow>\n                   nofail (f x) \\<longrightarrow> <\\<Gamma>1 * Rh x x'>\n                   f' x'\n                   <\\<lambda>r.\n                       \\<exists>\\<^sub>Axa.\n                          \\<Gamma>2 x x' * R xa r * true *\n                          \\<up> (RETURN xa \\<le> f x)>;\n        \\<And>x x'.\n           \\<Gamma>2 x x' \\<Longrightarrow>\\<^sub>t \\<Gamma>' * Rx x x';\n        nofail m; \\<forall>x. inres m x \\<longrightarrow> nofail (f x);\n        <\\<Gamma>> m'\n        <\\<lambda>r.\n            \\<exists>\\<^sub>Ax.\n               \\<Gamma>1 * Rh x r * true * \\<up> (RETURN x \\<le> m)>;\n        RETURN xa \\<le> m\\<rbrakk>\n       \\<Longrightarrow> <\\<Gamma>1 * Rh xa x * true> f' x\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Ax.\n                                \\<Gamma>' * R x r * true *\n                                \\<up> (RETURN x \\<le> m \\<bind> f)>", "assume 1: \"RETURN x \\<le> m\" \n    and \"nofail m\" \"\\<forall>x. inres m x \\<longrightarrow> nofail (f x)\""], ["proof (state)\nthis:\n  RETURN x \\<le> m\n  nofail m\n  \\<forall>x. inres m x \\<longrightarrow> nofail (f x)\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<And>x x'.\n                   RETURN x \\<le> m \\<Longrightarrow>\n                   nofail (f x) \\<longrightarrow> <\\<Gamma>1 * Rh x x'>\n                   f' x'\n                   <\\<lambda>r.\n                       \\<exists>\\<^sub>Axa.\n                          \\<Gamma>2 x x' * R xa r * true *\n                          \\<up> (RETURN xa \\<le> f x)>;\n        \\<And>x x'.\n           \\<Gamma>2 x x' \\<Longrightarrow>\\<^sub>t \\<Gamma>' * Rx x x';\n        nofail m; \\<forall>x. inres m x \\<longrightarrow> nofail (f x);\n        <\\<Gamma>> m'\n        <\\<lambda>r.\n            \\<exists>\\<^sub>Ax.\n               \\<Gamma>1 * Rh x r * true * \\<up> (RETURN x \\<le> m)>;\n        RETURN xa \\<le> m\\<rbrakk>\n       \\<Longrightarrow> <\\<Gamma>1 * Rh xa x * true> f' x\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Ax.\n                                \\<Gamma>' * R x r * true *\n                                \\<up> (RETURN x \\<le> m \\<bind> f)>", "hence \"nofail (f x)\""], ["proof (prove)\nusing this:\n  RETURN x \\<le> m\n  nofail m\n  \\<forall>x. inres m x \\<longrightarrow> nofail (f x)\n\ngoal (1 subgoal):\n 1. nofail (f x)", "by (auto simp: pw_le_iff)"], ["proof (state)\nthis:\n  nofail (f x)\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<And>x x'.\n                   RETURN x \\<le> m \\<Longrightarrow>\n                   nofail (f x) \\<longrightarrow> <\\<Gamma>1 * Rh x x'>\n                   f' x'\n                   <\\<lambda>r.\n                       \\<exists>\\<^sub>Axa.\n                          \\<Gamma>2 x x' * R xa r * true *\n                          \\<up> (RETURN xa \\<le> f x)>;\n        \\<And>x x'.\n           \\<Gamma>2 x x' \\<Longrightarrow>\\<^sub>t \\<Gamma>' * Rx x x';\n        nofail m; \\<forall>x. inres m x \\<longrightarrow> nofail (f x);\n        <\\<Gamma>> m'\n        <\\<lambda>r.\n            \\<exists>\\<^sub>Ax.\n               \\<Gamma>1 * Rh x r * true * \\<up> (RETURN x \\<le> m)>;\n        RETURN xa \\<le> m\\<rbrakk>\n       \\<Longrightarrow> <\\<Gamma>1 * Rh xa x * true> f' x\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Ax.\n                                \\<Gamma>' * R x r * true *\n                                \\<up> (RETURN x \\<le> m \\<bind> f)>", "moreover"], ["proof (state)\nthis:\n  nofail (f x)\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<And>x x'.\n                   RETURN x \\<le> m \\<Longrightarrow>\n                   nofail (f x) \\<longrightarrow> <\\<Gamma>1 * Rh x x'>\n                   f' x'\n                   <\\<lambda>r.\n                       \\<exists>\\<^sub>Axa.\n                          \\<Gamma>2 x x' * R xa r * true *\n                          \\<up> (RETURN xa \\<le> f x)>;\n        \\<And>x x'.\n           \\<Gamma>2 x x' \\<Longrightarrow>\\<^sub>t \\<Gamma>' * Rx x x';\n        nofail m; \\<forall>x. inres m x \\<longrightarrow> nofail (f x);\n        <\\<Gamma>> m'\n        <\\<lambda>r.\n            \\<exists>\\<^sub>Ax.\n               \\<Gamma>1 * Rh x r * true * \\<up> (RETURN x \\<le> m)>;\n        RETURN xa \\<le> m\\<rbrakk>\n       \\<Longrightarrow> <\\<Gamma>1 * Rh xa x * true> f' x\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Ax.\n                                \\<Gamma>' * R x r * true *\n                                \\<up> (RETURN x \\<le> m \\<bind> f)>", "assume \"\\<And>x x'. RETURN x \\<le> m \\<Longrightarrow>\n           nofail (f x) \\<longrightarrow> <\\<Gamma>1 * Rh x x'> f' x'\n           <\\<lambda>r'. \\<exists>\\<^sub>Ar. \\<Gamma>2 x x' * R r r' * true * \\<up> (RETURN r \\<le> f x)>\""], ["proof (state)\nthis:\n  RETURN ?x \\<le> m \\<Longrightarrow>\n  nofail (f ?x) \\<longrightarrow> <\\<Gamma>1 * Rh ?x ?x'> f' ?x'\n  <\\<lambda>r'.\n      \\<exists>\\<^sub>Ar.\n         \\<Gamma>2 ?x ?x' * R r r' * true * \\<up> (RETURN r \\<le> f ?x)>\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<And>x x'.\n                   RETURN x \\<le> m \\<Longrightarrow>\n                   nofail (f x) \\<longrightarrow> <\\<Gamma>1 * Rh x x'>\n                   f' x'\n                   <\\<lambda>r.\n                       \\<exists>\\<^sub>Axa.\n                          \\<Gamma>2 x x' * R xa r * true *\n                          \\<up> (RETURN xa \\<le> f x)>;\n        \\<And>x x'.\n           \\<Gamma>2 x x' \\<Longrightarrow>\\<^sub>t \\<Gamma>' * Rx x x';\n        nofail m; \\<forall>x. inres m x \\<longrightarrow> nofail (f x);\n        <\\<Gamma>> m'\n        <\\<lambda>r.\n            \\<exists>\\<^sub>Ax.\n               \\<Gamma>1 * Rh x r * true * \\<up> (RETURN x \\<le> m)>;\n        RETURN xa \\<le> m\\<rbrakk>\n       \\<Longrightarrow> <\\<Gamma>1 * Rh xa x * true> f' x\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Ax.\n                                \\<Gamma>' * R x r * true *\n                                \\<up> (RETURN x \\<le> m \\<bind> f)>", "ultimately"], ["proof (chain)\npicking this:\n  nofail (f x)\n  RETURN ?x \\<le> m \\<Longrightarrow>\n  nofail (f ?x) \\<longrightarrow> <\\<Gamma>1 * Rh ?x ?x'> f' ?x'\n  <\\<lambda>r'.\n      \\<exists>\\<^sub>Ar.\n         \\<Gamma>2 ?x ?x' * R r r' * true * \\<up> (RETURN r \\<le> f ?x)>", "have \"\\<And>x'. <\\<Gamma>1 * Rh x x'> f' x'\n           <\\<lambda>r'. \\<exists>\\<^sub>Ar. \\<Gamma>2 x x' * R r r' * true * \\<up> (RETURN r \\<le> f x)>\""], ["proof (prove)\nusing this:\n  nofail (f x)\n  RETURN ?x \\<le> m \\<Longrightarrow>\n  nofail (f ?x) \\<longrightarrow> <\\<Gamma>1 * Rh ?x ?x'> f' ?x'\n  <\\<lambda>r'.\n      \\<exists>\\<^sub>Ar.\n         \\<Gamma>2 ?x ?x' * R r r' * true * \\<up> (RETURN r \\<le> f ?x)>\n\ngoal (1 subgoal):\n 1. \\<And>x'.\n       <\\<Gamma>1 * Rh x x'> f' x'\n       <\\<lambda>r'.\n           \\<exists>\\<^sub>Ar.\n              \\<Gamma>2 x x' * R r r' * true * \\<up> (RETURN r \\<le> f x)>", "using 1"], ["proof (prove)\nusing this:\n  nofail (f x)\n  RETURN ?x \\<le> m \\<Longrightarrow>\n  nofail (f ?x) \\<longrightarrow> <\\<Gamma>1 * Rh ?x ?x'> f' ?x'\n  <\\<lambda>r'.\n      \\<exists>\\<^sub>Ar.\n         \\<Gamma>2 ?x ?x' * R r r' * true * \\<up> (RETURN r \\<le> f ?x)>\n  RETURN x \\<le> m\n\ngoal (1 subgoal):\n 1. \\<And>x'.\n       <\\<Gamma>1 * Rh x x'> f' x'\n       <\\<lambda>r'.\n           \\<exists>\\<^sub>Ar.\n              \\<Gamma>2 x x' * R r r' * true * \\<up> (RETURN r \\<le> f x)>", "by simp"], ["proof (state)\nthis:\n  <\\<Gamma>1 * Rh x ?x'> f' ?x'\n  <\\<lambda>r'.\n      \\<exists>\\<^sub>Ar.\n         \\<Gamma>2 x ?x' * R r r' * true * \\<up> (RETURN r \\<le> f x)>\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<And>x x'.\n                   RETURN x \\<le> m \\<Longrightarrow>\n                   nofail (f x) \\<longrightarrow> <\\<Gamma>1 * Rh x x'>\n                   f' x'\n                   <\\<lambda>r.\n                       \\<exists>\\<^sub>Axa.\n                          \\<Gamma>2 x x' * R xa r * true *\n                          \\<up> (RETURN xa \\<le> f x)>;\n        \\<And>x x'.\n           \\<Gamma>2 x x' \\<Longrightarrow>\\<^sub>t \\<Gamma>' * Rx x x';\n        nofail m; \\<forall>x. inres m x \\<longrightarrow> nofail (f x);\n        <\\<Gamma>> m'\n        <\\<lambda>r.\n            \\<exists>\\<^sub>Ax.\n               \\<Gamma>1 * Rh x r * true * \\<up> (RETURN x \\<le> m)>;\n        RETURN xa \\<le> m\\<rbrakk>\n       \\<Longrightarrow> <\\<Gamma>1 * Rh xa x * true> f' x\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Ax.\n                                \\<Gamma>' * R x r * true *\n                                \\<up> (RETURN x \\<le> m \\<bind> f)>", "also"], ["proof (state)\nthis:\n  <\\<Gamma>1 * Rh x ?x'> f' ?x'\n  <\\<lambda>r'.\n      \\<exists>\\<^sub>Ar.\n         \\<Gamma>2 x ?x' * R r r' * true * \\<up> (RETURN r \\<le> f x)>\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<And>x x'.\n                   RETURN x \\<le> m \\<Longrightarrow>\n                   nofail (f x) \\<longrightarrow> <\\<Gamma>1 * Rh x x'>\n                   f' x'\n                   <\\<lambda>r.\n                       \\<exists>\\<^sub>Axa.\n                          \\<Gamma>2 x x' * R xa r * true *\n                          \\<up> (RETURN xa \\<le> f x)>;\n        \\<And>x x'.\n           \\<Gamma>2 x x' \\<Longrightarrow>\\<^sub>t \\<Gamma>' * Rx x x';\n        nofail m; \\<forall>x. inres m x \\<longrightarrow> nofail (f x);\n        <\\<Gamma>> m'\n        <\\<lambda>r.\n            \\<exists>\\<^sub>Ax.\n               \\<Gamma>1 * Rh x r * true * \\<up> (RETURN x \\<le> m)>;\n        RETURN xa \\<le> m\\<rbrakk>\n       \\<Longrightarrow> <\\<Gamma>1 * Rh xa x * true> f' x\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Ax.\n                                \\<Gamma>' * R x r * true *\n                                \\<up> (RETURN x \\<le> m \\<bind> f)>", "have \"\\<And>r'. \\<exists>\\<^sub>Ar. \\<Gamma>2 x x' * R r r' * true * \\<up> (RETURN r \\<le> f x) \\<Longrightarrow>\\<^sub>A\n    \\<exists>\\<^sub>Ar. \\<Gamma>' * R r r' * true * \\<up> (RETURN r \\<le> f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r'.\n       \\<exists>\\<^sub>Ar.\n          \\<Gamma>2 x x' * R r r' * true *\n          \\<up> (RETURN r \\<le> f x) \\<Longrightarrow>\\<^sub>A\n       \\<exists>\\<^sub>Ar.\n          \\<Gamma>' * R r r' * true * \\<up> (RETURN r \\<le> f x)", "apply (sep_auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r' r.\n       RETURN r \\<le> f x \\<Longrightarrow>\n       \\<Gamma>2 x x' * R r r' * true \\<Longrightarrow>\\<^sub>A\n       \\<Gamma>' * R r r' * true", "apply (rule ent_frame_fwd[OF IMP[THEN enttD]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r' r.\n       RETURN r \\<le> f x \\<Longrightarrow>\n       \\<Gamma>2 x x' * R r r' * true \\<Longrightarrow>\\<^sub>A\n       \\<Gamma>2 (?x18 r' r) (?x'18 r' r) * ?F16 r' r\n 2. \\<And>r' r.\n       RETURN r \\<le> f x \\<Longrightarrow>\n       \\<Gamma>' * hn_ctxt Rx (?x18 r' r) (?x'18 r' r) * true *\n       ?F16 r' r \\<Longrightarrow>\\<^sub>A\n       \\<Gamma>' * R r r' * true", "apply frame_inference"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r' r.\n       RETURN r \\<le> f x \\<Longrightarrow>\n       \\<Gamma>' * hn_ctxt Rx x x' * true *\n       (R r r' * true) \\<Longrightarrow>\\<^sub>A\n       \\<Gamma>' * R r r' * true", "apply (solve_entails)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>\\<^sub>Ar.\n     \\<Gamma>2 x x' * R r ?r' * true *\n     \\<up> (RETURN r \\<le> f x) \\<Longrightarrow>\\<^sub>A\n  \\<exists>\\<^sub>Ar.\n     \\<Gamma>' * R r ?r' * true * \\<up> (RETURN r \\<le> f x)\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<And>x x'.\n                   RETURN x \\<le> m \\<Longrightarrow>\n                   nofail (f x) \\<longrightarrow> <\\<Gamma>1 * Rh x x'>\n                   f' x'\n                   <\\<lambda>r.\n                       \\<exists>\\<^sub>Axa.\n                          \\<Gamma>2 x x' * R xa r * true *\n                          \\<up> (RETURN xa \\<le> f x)>;\n        \\<And>x x'.\n           \\<Gamma>2 x x' \\<Longrightarrow>\\<^sub>t \\<Gamma>' * Rx x x';\n        nofail m; \\<forall>x. inres m x \\<longrightarrow> nofail (f x);\n        <\\<Gamma>> m'\n        <\\<lambda>r.\n            \\<exists>\\<^sub>Ax.\n               \\<Gamma>1 * Rh x r * true * \\<up> (RETURN x \\<le> m)>;\n        RETURN xa \\<le> m\\<rbrakk>\n       \\<Longrightarrow> <\\<Gamma>1 * Rh xa x * true> f' x\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Ax.\n                                \\<Gamma>' * R x r * true *\n                                \\<up> (RETURN x \\<le> m \\<bind> f)>", "finally (cons_post_rule)"], ["proof (chain)\npicking this:\n  <\\<Gamma>1 * Rh x x'> f' x'\n  <\\<lambda>xa.\n      \\<exists>\\<^sub>Ar.\n         \\<Gamma>' * R r xa * true * \\<up> (RETURN r \\<le> f x)>", "have \n    R: \"<\\<Gamma>1 * Rh x x'> f' x' \n        <\\<lambda>r'. \\<exists>\\<^sub>Ar. \\<Gamma>' * R r r' * true * \\<up>(RETURN r \\<le> f x)>\""], ["proof (prove)\nusing this:\n  <\\<Gamma>1 * Rh x x'> f' x'\n  <\\<lambda>xa.\n      \\<exists>\\<^sub>Ar.\n         \\<Gamma>' * R r xa * true * \\<up> (RETURN r \\<le> f x)>\n\ngoal (1 subgoal):\n 1. <\\<Gamma>1 * Rh x x'> f' x'\n    <\\<lambda>r'.\n        \\<exists>\\<^sub>Ar.\n           \\<Gamma>' * R r r' * true * \\<up> (RETURN r \\<le> f x)>", "."], ["proof (state)\nthis:\n  <\\<Gamma>1 * Rh x x'> f' x'\n  <\\<lambda>r'.\n      \\<exists>\\<^sub>Ar.\n         \\<Gamma>' * R r r' * true * \\<up> (RETURN r \\<le> f x)>\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<And>x x'.\n                   RETURN x \\<le> m \\<Longrightarrow>\n                   nofail (f x) \\<longrightarrow> <\\<Gamma>1 * Rh x x'>\n                   f' x'\n                   <\\<lambda>r.\n                       \\<exists>\\<^sub>Axa.\n                          \\<Gamma>2 x x' * R xa r * true *\n                          \\<up> (RETURN xa \\<le> f x)>;\n        \\<And>x x'.\n           \\<Gamma>2 x x' \\<Longrightarrow>\\<^sub>t \\<Gamma>' * Rx x x';\n        nofail m; \\<forall>x. inres m x \\<longrightarrow> nofail (f x);\n        <\\<Gamma>> m'\n        <\\<lambda>r.\n            \\<exists>\\<^sub>Ax.\n               \\<Gamma>1 * Rh x r * true * \\<up> (RETURN x \\<le> m)>;\n        RETURN xa \\<le> m\\<rbrakk>\n       \\<Longrightarrow> <\\<Gamma>1 * Rh xa x * true> f' x\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Ax.\n                                \\<Gamma>' * R x r * true *\n                                \\<up> (RETURN x \\<le> m \\<bind> f)>", "show \"<\\<Gamma>1 * Rh x x' * true> f' x'\n          <\\<lambda>r'. \\<exists>\\<^sub>Ar. \\<Gamma>' * R r r' * true * \\<up> (RETURN r \\<le> m \\<bind> f)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<Gamma>1 * Rh x x' * true> f' x'\n    <\\<lambda>r'.\n        \\<exists>\\<^sub>Ar.\n           \\<Gamma>' * R r r' * true * \\<up> (RETURN r \\<le> m \\<bind> f)>", "by (sep_auto heap: R intro: bind_det_aux[OF 1])"], ["proof (state)\nthis:\n  <\\<Gamma>1 * Rh x x' * true> f' x'\n  <\\<lambda>r'.\n      \\<exists>\\<^sub>Ar.\n         \\<Gamma>' * R r r' * true * \\<up> (RETURN r \\<le> m \\<bind> f)>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Recursion\\<close>"], ["", "definition \"hn_rel P m \\<equiv> \\<lambda>r. \\<exists>\\<^sub>Ax. P x r * \\<up>(RETURN x \\<le> m)\""], ["", "lemma hn_refine_alt: \"hn_refine Fpre c Fpost P m \\<equiv> nofail m \\<longrightarrow>\n  <Fpre> c <\\<lambda>r. hn_rel P m r * Fpost>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine Fpre c Fpost P m \\<equiv>\n    nofail m \\<longrightarrow>\n    <Fpre> c <\\<lambda>r. hn_rel P m r * Fpost>\\<^sub>t", "apply (rule eq_reflection)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine Fpre c Fpost P m =\n    (nofail m \\<longrightarrow>\n     <Fpre> c <\\<lambda>r. hn_rel P m r * Fpost>\\<^sub>t)", "unfolding hn_refine_def hn_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (nofail m \\<longrightarrow>\n     <Fpre> c <\\<lambda>r.\n                  Fpost *\n                  (\\<exists>\\<^sub>Ax.\n                      P x r * \\<up> (RETURN x \\<le> m))>\\<^sub>t) =\n    (nofail m \\<longrightarrow>\n     <Fpre> c <\\<lambda>r.\n                  (\\<exists>\\<^sub>Ax. P x r * \\<up> (RETURN x \\<le> m)) *\n                  Fpost>\\<^sub>t)", "apply (simp add: hn_ctxt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (nofail m \\<longrightarrow> <Fpre> c\n     <\\<lambda>r.\n         \\<exists>\\<^sub>Ax.\n            Fpost * P x r * true * \\<up> (RETURN x \\<le> m)>) =\n    (nofail m \\<longrightarrow> <Fpre> c\n     <\\<lambda>r.\n         \\<exists>\\<^sub>Ax.\n            P x r * Fpost * true * \\<up> (RETURN x \\<le> m)>)", "apply (simp only: star_aci)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wit_swap_forall:\n  assumes W: \"<P> c <\\<lambda>_. true>\"\n  assumes T: \"(\\<forall>x. A x \\<longrightarrow> <P> c <Q x>)\"\n  shows \"<P> c <\\<lambda>r. \\<not>\\<^sub>A (\\<exists>\\<^sub>Ax. \\<up>(A x) * \\<not>\\<^sub>A Q x r)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <P> c\n    <\\<lambda>r.\n        \\<not>\\<^sub>A (\\<exists>\\<^sub>Ax.\n                           \\<up> (A x) * \\<not>\\<^sub>A Q x r)>", "unfolding hoare_triple_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h as \\<sigma> r.\n       (h, as) \\<Turnstile> P \\<and>\n       run c (Some h) \\<sigma> r \\<longrightarrow>\n       \\<not> is_exn \\<sigma> \\<and>\n       (the_state \\<sigma>,\n        new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n       \\<not>\\<^sub>A (\\<exists>\\<^sub>Ax.\n                          \\<up> (A x) * \\<not>\\<^sub>A Q x r) \\<and>\n       relH {a. a < lim h \\<and> a \\<notin> as} h\n        (the_state \\<sigma>) \\<and>\n       lim h \\<le> lim (the_state \\<sigma>)", "apply (intro conjI impI allI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>h as \\<sigma> r.\n       (h, as) \\<Turnstile> P \\<and>\n       run c (Some h) \\<sigma> r \\<Longrightarrow>\n       \\<not> is_exn \\<sigma>\n 2. \\<And>h as \\<sigma> r.\n       (h, as) \\<Turnstile> P \\<and>\n       run c (Some h) \\<sigma> r \\<Longrightarrow>\n       (the_state \\<sigma>,\n        new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n       \\<not>\\<^sub>A (\\<exists>\\<^sub>Ax.\n                          \\<up> (A x) * \\<not>\\<^sub>A Q x r)\n 3. \\<And>h as \\<sigma> r.\n       (h, as) \\<Turnstile> P \\<and>\n       run c (Some h) \\<sigma> r \\<Longrightarrow>\n       relH {a. a < lim h \\<and> a \\<notin> as} h (the_state \\<sigma>)\n 4. \\<And>h as \\<sigma> r.\n       (h, as) \\<Turnstile> P \\<and>\n       run c (Some h) \\<sigma> r \\<Longrightarrow>\n       lim h \\<le> lim (the_state \\<sigma>)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (h_, as_) \\<Turnstile> P \\<and>\n    run c (Some h_) \\<sigma>_ r_ \\<Longrightarrow>\n    \\<not> is_exn \\<sigma>_", "by (elim conjE) (rule hoare_tripleD[OF W], assumption+) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>h as \\<sigma> r.\n       (h, as) \\<Turnstile> P \\<and>\n       run c (Some h) \\<sigma> r \\<Longrightarrow>\n       (the_state \\<sigma>,\n        new_addrs h as (the_state \\<sigma>)) \\<Turnstile>\n       \\<not>\\<^sub>A (\\<exists>\\<^sub>Ax.\n                          \\<up> (A x) * \\<not>\\<^sub>A Q x r)\n 2. \\<And>h as \\<sigma> r.\n       (h, as) \\<Turnstile> P \\<and>\n       run c (Some h) \\<sigma> r \\<Longrightarrow>\n       relH {a. a < lim h \\<and> a \\<notin> as} h (the_state \\<sigma>)\n 3. \\<And>h as \\<sigma> r.\n       (h, as) \\<Turnstile> P \\<and>\n       run c (Some h) \\<sigma> r \\<Longrightarrow>\n       lim h \\<le> lim (the_state \\<sigma>)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (h_, as_) \\<Turnstile> P \\<and>\n    run c (Some h_) \\<sigma>_ r_ \\<Longrightarrow>\n    (the_state \\<sigma>_,\n     new_addrs h_ as_ (the_state \\<sigma>_)) \\<Turnstile>\n    \\<not>\\<^sub>A (\\<exists>\\<^sub>Ax. \\<up> (A x) * \\<not>\\<^sub>A Q x r_)", "apply (clarsimp, intro conjI allI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(h_, as_) \\<Turnstile> P; run c (Some h_) \\<sigma>_ r_\\<rbrakk>\n    \\<Longrightarrow> in_range\n                       (the_state \\<sigma>_,\n                        new_addrs h_ as_ (the_state \\<sigma>_))\n 2. \\<And>x.\n       \\<lbrakk>(h_, as_) \\<Turnstile> P;\n        run c (Some h_) \\<sigma>_ r_\\<rbrakk>\n       \\<Longrightarrow> (the_state \\<sigma>_,\n                          new_addrs h_ as_\n                           (the_state \\<sigma>_)) \\<Turnstile>\n                         Q x r_ \\<or>\n                         \\<not> A x", "apply1 (rule models_in_range)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(h_, as_) \\<Turnstile> P; run c (Some h_) \\<sigma>_ r_\\<rbrakk>\n    \\<Longrightarrow> (the_state \\<sigma>_,\n                       new_addrs h_ as_ (the_state \\<sigma>_)) \\<Turnstile>\n                      ?P5\n 2. \\<And>x.\n       \\<lbrakk>(h_, as_) \\<Turnstile> P;\n        run c (Some h_) \\<sigma>_ r_\\<rbrakk>\n       \\<Longrightarrow> (the_state \\<sigma>_,\n                          new_addrs h_ as_\n                           (the_state \\<sigma>_)) \\<Turnstile>\n                         Q x r_ \\<or>\n                         \\<not> A x", "applyS (rule hoare_tripleD[OF W]; assumption; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>(h_, as_) \\<Turnstile> P;\n        run c (Some h_) \\<sigma>_ r_\\<rbrakk>\n       \\<Longrightarrow> (the_state \\<sigma>_,\n                          new_addrs h_ as_\n                           (the_state \\<sigma>_)) \\<Turnstile>\n                         Q x r_ \\<or>\n                         \\<not> A x", "apply1 (simp only: disj_not2, intro impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>(h_, as_) \\<Turnstile> P; run c (Some h_) \\<sigma>_ r_;\n        A x\\<rbrakk>\n       \\<Longrightarrow> (the_state \\<sigma>_,\n                          new_addrs h_ as_\n                           (the_state \\<sigma>_)) \\<Turnstile>\n                         Q x r_", "apply1 (drule spec[OF T, THEN mp])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>(h_, as_) \\<Turnstile> P; run c (Some h_) \\<sigma>_ r_;\n        <P> c <Q x>\\<rbrakk>\n       \\<Longrightarrow> (the_state \\<sigma>_,\n                          new_addrs h_ as_\n                           (the_state \\<sigma>_)) \\<Turnstile>\n                         Q x r_", "apply1 (drule (2) hoare_tripleD(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>(h_, as_) \\<Turnstile> P; run c (Some h_) \\<sigma>_ r_;\n        (the_state \\<sigma>_,\n         new_addrs h_ as_ (the_state \\<sigma>_)) \\<Turnstile>\n        Q x r_\\<rbrakk>\n       \\<Longrightarrow> (the_state \\<sigma>_,\n                          new_addrs h_ as_\n                           (the_state \\<sigma>_)) \\<Turnstile>\n                         Q x r_", "by assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>h as \\<sigma> r.\n       (h, as) \\<Turnstile> P \\<and>\n       run c (Some h) \\<sigma> r \\<Longrightarrow>\n       relH {a. a < lim h \\<and> a \\<notin> as} h (the_state \\<sigma>)\n 2. \\<And>h as \\<sigma> r.\n       (h, as) \\<Turnstile> P \\<and>\n       run c (Some h) \\<sigma> r \\<Longrightarrow>\n       lim h \\<le> lim (the_state \\<sigma>)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (h_, as_) \\<Turnstile> P \\<and>\n    run c (Some h_) \\<sigma>_ r_ \\<Longrightarrow>\n    relH {a. a < lim h_ \\<and> a \\<notin> as_} h_ (the_state \\<sigma>_)", "by (elim conjE) (rule hoare_tripleD[OF W], assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h as \\<sigma> r.\n       (h, as) \\<Turnstile> P \\<and>\n       run c (Some h) \\<sigma> r \\<Longrightarrow>\n       lim h \\<le> lim (the_state \\<sigma>)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (h_, as_) \\<Turnstile> P \\<and>\n    run c (Some h_) \\<sigma>_ r_ \\<Longrightarrow>\n    lim h_ \\<le> lim (the_state \\<sigma>_)", "by (elim conjE) (rule hoare_tripleD[OF W], assumption+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hn_admissible:\n  assumes PREC: \"precise Ry\"\n  assumes E: \"\\<forall>f\\<in>A. nofail (f x) \\<longrightarrow> <P> c <\\<lambda>r. hn_rel Ry (f x) r * F>\"\n  assumes NF: \"nofail (INF f\\<in>A. f x)\"\n  shows \"<P> c <\\<lambda>r. hn_rel Ry (INF f\\<in>A. f x) r * F>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <P> c <\\<lambda>r. hn_rel Ry (INF f\\<in>A. f x) r * F>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. <P> c <\\<lambda>r. hn_rel Ry (INF f\\<in>A. f x) r * F>", "from NF"], ["proof (chain)\npicking this:\n  nofail (INF f\\<in>A. f x)", "obtain f where \"f\\<in>A\" and \"nofail (f x)\""], ["proof (prove)\nusing this:\n  nofail (INF f\\<in>A. f x)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> A; nofail (f x)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp only: refine_pw_simps) blast"], ["proof (state)\nthis:\n  f \\<in> A\n  nofail (f x)\n\ngoal (1 subgoal):\n 1. <P> c <\\<lambda>r. hn_rel Ry (INF f\\<in>A. f x) r * F>", "with E"], ["proof (chain)\npicking this:\n  \\<forall>f\\<in>A.\n     nofail (f x) \\<longrightarrow> <P> c\n     <\\<lambda>r. hn_rel Ry (f x) r * F>\n  f \\<in> A\n  nofail (f x)", "have \"<P> c <\\<lambda>r. hn_rel Ry (f x) r * F>\""], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>A.\n     nofail (f x) \\<longrightarrow> <P> c\n     <\\<lambda>r. hn_rel Ry (f x) r * F>\n  f \\<in> A\n  nofail (f x)\n\ngoal (1 subgoal):\n 1. <P> c <\\<lambda>r. hn_rel Ry (f x) r * F>", "by blast"], ["proof (state)\nthis:\n  <P> c <\\<lambda>r. hn_rel Ry (f x) r * F>\n\ngoal (1 subgoal):\n 1. <P> c <\\<lambda>r. hn_rel Ry (INF f\\<in>A. f x) r * F>", "hence W: \"<P> c <\\<lambda>_. true>\""], ["proof (prove)\nusing this:\n  <P> c <\\<lambda>r. hn_rel Ry (f x) r * F>\n\ngoal (1 subgoal):\n 1. <P> c <\\<lambda>_. true>", "by (rule cons_post_rule, simp)"], ["proof (state)\nthis:\n  <P> c <\\<lambda>_. true>\n\ngoal (1 subgoal):\n 1. <P> c <\\<lambda>r. hn_rel Ry (INF f\\<in>A. f x) r * F>", "from E"], ["proof (chain)\npicking this:\n  \\<forall>f\\<in>A.\n     nofail (f x) \\<longrightarrow> <P> c\n     <\\<lambda>r. hn_rel Ry (f x) r * F>", "have \n    E': \"\\<forall>f. f\\<in>A \\<and> nofail (f x) \\<longrightarrow> <P> c <\\<lambda>r. hn_rel Ry (f x) r * F>\""], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>A.\n     nofail (f x) \\<longrightarrow> <P> c\n     <\\<lambda>r. hn_rel Ry (f x) r * F>\n\ngoal (1 subgoal):\n 1. \\<forall>f.\n       f \\<in> A \\<and> nofail (f x) \\<longrightarrow> <P> c\n       <\\<lambda>r. hn_rel Ry (f x) r * F>", "by blast"], ["proof (state)\nthis:\n  \\<forall>f.\n     f \\<in> A \\<and> nofail (f x) \\<longrightarrow> <P> c\n     <\\<lambda>r. hn_rel Ry (f x) r * F>\n\ngoal (1 subgoal):\n 1. <P> c <\\<lambda>r. hn_rel Ry (INF f\\<in>A. f x) r * F>", "from wit_swap_forall[OF W E']"], ["proof (chain)\npicking this:\n  <P> c\n  <\\<lambda>r.\n      \\<not>\\<^sub>A (\\<exists>\\<^sub>Axa.\n                         \\<up> (xa \\<in> A \\<and> nofail (xa x)) *\n                         \\<not>\\<^sub>A (hn_rel Ry (xa x) r * F))>", "have \n    E'': \"<P> c\n     <\\<lambda>r. \\<not>\\<^sub>A (\\<exists>\\<^sub>Axa. \\<up> (xa \\<in> A \\<and> nofail (xa x)) *\n                \\<not>\\<^sub>A (hn_rel Ry (xa x) r * F))>\""], ["proof (prove)\nusing this:\n  <P> c\n  <\\<lambda>r.\n      \\<not>\\<^sub>A (\\<exists>\\<^sub>Axa.\n                         \\<up> (xa \\<in> A \\<and> nofail (xa x)) *\n                         \\<not>\\<^sub>A (hn_rel Ry (xa x) r * F))>\n\ngoal (1 subgoal):\n 1. <P> c\n    <\\<lambda>r.\n        \\<not>\\<^sub>A (\\<exists>\\<^sub>Axa.\n                           \\<up> (xa \\<in> A \\<and> nofail (xa x)) *\n                           \\<not>\\<^sub>A (hn_rel Ry (xa x) r * F))>", "."], ["proof (state)\nthis:\n  <P> c\n  <\\<lambda>r.\n      \\<not>\\<^sub>A (\\<exists>\\<^sub>Axa.\n                         \\<up> (xa \\<in> A \\<and> nofail (xa x)) *\n                         \\<not>\\<^sub>A (hn_rel Ry (xa x) r * F))>\n\ngoal (1 subgoal):\n 1. <P> c <\\<lambda>r. hn_rel Ry (INF f\\<in>A. f x) r * F>", "thus ?thesis"], ["proof (prove)\nusing this:\n  <P> c\n  <\\<lambda>r.\n      \\<not>\\<^sub>A (\\<exists>\\<^sub>Axa.\n                         \\<up> (xa \\<in> A \\<and> nofail (xa x)) *\n                         \\<not>\\<^sub>A (hn_rel Ry (xa x) r * F))>\n\ngoal (1 subgoal):\n 1. <P> c <\\<lambda>r. hn_rel Ry (INF f\\<in>A. f x) r * F>", "apply (rule cons_post_rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<not>\\<^sub>A (\\<exists>\\<^sub>Axaa.\n                          \\<up> (xaa \\<in> A \\<and> nofail (xaa x)) *\n                          \\<not>\\<^sub>A (hn_rel Ry (xaa x) xa *\n    F)) \\<Longrightarrow>\\<^sub>A\n       hn_rel Ry (INF f\\<in>A. f x) xa * F", "unfolding entails_def hn_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<forall>h.\n          h \\<Turnstile>\n          \\<not>\\<^sub>A (\\<exists>\\<^sub>Axaa.\n                             \\<up> (xaa \\<in> A \\<and> nofail (xaa x)) *\n                             \\<not>\\<^sub>A ((\\<exists>\\<^sub>Axb.\n           Ry xb xa * \\<up> (RETURN xb \\<le> xaa x)) *\n       F)) \\<longrightarrow>\n          h \\<Turnstile>\n          (\\<exists>\\<^sub>Axb.\n              Ry xb xa * \\<up> (RETURN xb \\<le> (INF f\\<in>A. f x))) *\n          F", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa a b.\n       \\<lbrakk>in_range (a, b);\n        \\<forall>xaa.\n           xaa \\<in> A \\<longrightarrow>\n           (\\<exists>xb.\n               (a, b) \\<Turnstile> Ry xb xa * F \\<and>\n               RETURN xb \\<le> xaa x) \\<or>\n           \\<not> nofail (xaa x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb.\n                            (a, b) \\<Turnstile> Ry xb xa * F \\<and>\n                            RETURN xb \\<le> (INF f\\<in>A. f x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa a b.\n       \\<lbrakk>in_range (a, b);\n        \\<forall>xaa.\n           xaa \\<in> A \\<longrightarrow>\n           (\\<exists>xb.\n               (a, b) \\<Turnstile> Ry xb xa * F \\<and>\n               RETURN xb \\<le> xaa x) \\<or>\n           \\<not> nofail (xaa x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb.\n                            (a, b) \\<Turnstile> Ry xb xa * F \\<and>\n                            RETURN xb \\<le> (INF f\\<in>A. f x)", "fix h as p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa a b.\n       \\<lbrakk>in_range (a, b);\n        \\<forall>xaa.\n           xaa \\<in> A \\<longrightarrow>\n           (\\<exists>xb.\n               (a, b) \\<Turnstile> Ry xb xa * F \\<and>\n               RETURN xb \\<le> xaa x) \\<or>\n           \\<not> nofail (xaa x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb.\n                            (a, b) \\<Turnstile> Ry xb xa * F \\<and>\n                            RETURN xb \\<le> (INF f\\<in>A. f x)", "assume A: \"\\<forall>f. f\\<in>A \\<longrightarrow> (\\<exists>a.\n      ((h, as) \\<Turnstile> Ry a p * F \\<and> RETURN a \\<le> f x)) \\<or> \\<not> nofail (f x)\""], ["proof (state)\nthis:\n  \\<forall>f.\n     f \\<in> A \\<longrightarrow>\n     (\\<exists>a.\n         (h, as) \\<Turnstile> Ry a p * F \\<and> RETURN a \\<le> f x) \\<or>\n     \\<not> nofail (f x)\n\ngoal (1 subgoal):\n 1. \\<And>xa a b.\n       \\<lbrakk>in_range (a, b);\n        \\<forall>xaa.\n           xaa \\<in> A \\<longrightarrow>\n           (\\<exists>xb.\n               (a, b) \\<Turnstile> Ry xb xa * F \\<and>\n               RETURN xb \\<le> xaa x) \\<or>\n           \\<not> nofail (xaa x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb.\n                            (a, b) \\<Turnstile> Ry xb xa * F \\<and>\n                            RETURN xb \\<le> (INF f\\<in>A. f x)", "with \\<open>f\\<in>A\\<close> and \\<open>nofail (f x)\\<close>"], ["proof (chain)\npicking this:\n  f \\<in> A\n  nofail (f x)\n  \\<forall>f.\n     f \\<in> A \\<longrightarrow>\n     (\\<exists>a.\n         (h, as) \\<Turnstile> Ry a p * F \\<and> RETURN a \\<le> f x) \\<or>\n     \\<not> nofail (f x)", "obtain a where \n      1: \"(h, as) \\<Turnstile> Ry a p * F\" and \"RETURN a \\<le> f x\""], ["proof (prove)\nusing this:\n  f \\<in> A\n  nofail (f x)\n  \\<forall>f.\n     f \\<in> A \\<longrightarrow>\n     (\\<exists>a.\n         (h, as) \\<Turnstile> Ry a p * F \\<and> RETURN a \\<le> f x) \\<or>\n     \\<not> nofail (f x)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>(h, as) \\<Turnstile> Ry a p * F;\n         RETURN a \\<le> f x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (h, as) \\<Turnstile> Ry a p * F\n  RETURN a \\<le> f x\n\ngoal (1 subgoal):\n 1. \\<And>xa a b.\n       \\<lbrakk>in_range (a, b);\n        \\<forall>xaa.\n           xaa \\<in> A \\<longrightarrow>\n           (\\<exists>xb.\n               (a, b) \\<Turnstile> Ry xb xa * F \\<and>\n               RETURN xb \\<le> xaa x) \\<or>\n           \\<not> nofail (xaa x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb.\n                            (a, b) \\<Turnstile> Ry xb xa * F \\<and>\n                            RETURN xb \\<le> (INF f\\<in>A. f x)", "have\n      \"\\<forall>f\\<in>A. nofail (f x) \\<longrightarrow> (h, as) \\<Turnstile> Ry a p * F \\<and> RETURN a \\<le> f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>A.\n       nofail (f x) \\<longrightarrow>\n       (h, as) \\<Turnstile> Ry a p * F \\<and> RETURN a \\<le> f x", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> A; nofail (f x)\\<rbrakk>\n       \\<Longrightarrow> (h, as) \\<Turnstile> Ry a p * F \\<and>\n                         RETURN a \\<le> f x", "fix f'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> A; nofail (f x)\\<rbrakk>\n       \\<Longrightarrow> (h, as) \\<Turnstile> Ry a p * F \\<and>\n                         RETURN a \\<le> f x", "assume \"f'\\<in>A\" and \"nofail (f' x)\""], ["proof (state)\nthis:\n  f' \\<in> A\n  nofail (f' x)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> A; nofail (f x)\\<rbrakk>\n       \\<Longrightarrow> (h, as) \\<Turnstile> Ry a p * F \\<and>\n                         RETURN a \\<le> f x", "with A"], ["proof (chain)\npicking this:\n  \\<forall>f.\n     f \\<in> A \\<longrightarrow>\n     (\\<exists>a.\n         (h, as) \\<Turnstile> Ry a p * F \\<and> RETURN a \\<le> f x) \\<or>\n     \\<not> nofail (f x)\n  f' \\<in> A\n  nofail (f' x)", "obtain a' where \n        2: \"(h, as) \\<Turnstile> Ry a' p * F\" and \"RETURN a' \\<le> f' x\""], ["proof (prove)\nusing this:\n  \\<forall>f.\n     f \\<in> A \\<longrightarrow>\n     (\\<exists>a.\n         (h, as) \\<Turnstile> Ry a p * F \\<and> RETURN a \\<le> f x) \\<or>\n     \\<not> nofail (f x)\n  f' \\<in> A\n  nofail (f' x)\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>(h, as) \\<Turnstile> Ry a' p * F;\n         RETURN a' \\<le> f' x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (h, as) \\<Turnstile> Ry a' p * F\n  RETURN a' \\<le> f' x\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> A; nofail (f x)\\<rbrakk>\n       \\<Longrightarrow> (h, as) \\<Turnstile> Ry a p * F \\<and>\n                         RETURN a \\<le> f x", "moreover"], ["proof (state)\nthis:\n  (h, as) \\<Turnstile> Ry a' p * F\n  RETURN a' \\<le> f' x\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> A; nofail (f x)\\<rbrakk>\n       \\<Longrightarrow> (h, as) \\<Turnstile> Ry a p * F \\<and>\n                         RETURN a \\<le> f x", "note preciseD'[OF PREC 1 2]"], ["proof (state)\nthis:\n  a = a'\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> A; nofail (f x)\\<rbrakk>\n       \\<Longrightarrow> (h, as) \\<Turnstile> Ry a p * F \\<and>\n                         RETURN a \\<le> f x", "ultimately"], ["proof (chain)\npicking this:\n  (h, as) \\<Turnstile> Ry a' p * F\n  RETURN a' \\<le> f' x\n  a = a'", "show \"(h, as) \\<Turnstile> Ry a p * F \\<and> RETURN a \\<le> f' x\""], ["proof (prove)\nusing this:\n  (h, as) \\<Turnstile> Ry a' p * F\n  RETURN a' \\<le> f' x\n  a = a'\n\ngoal (1 subgoal):\n 1. (h, as) \\<Turnstile> Ry a p * F \\<and> RETURN a \\<le> f' x", "by simp"], ["proof (state)\nthis:\n  (h, as) \\<Turnstile> Ry a p * F \\<and> RETURN a \\<le> f' x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>f\\<in>A.\n     nofail (f x) \\<longrightarrow>\n     (h, as) \\<Turnstile> Ry a p * F \\<and> RETURN a \\<le> f x\n\ngoal (1 subgoal):\n 1. \\<And>xa a b.\n       \\<lbrakk>in_range (a, b);\n        \\<forall>xaa.\n           xaa \\<in> A \\<longrightarrow>\n           (\\<exists>xb.\n               (a, b) \\<Turnstile> Ry xb xa * F \\<and>\n               RETURN xb \\<le> xaa x) \\<or>\n           \\<not> nofail (xaa x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb.\n                            (a, b) \\<Turnstile> Ry xb xa * F \\<and>\n                            RETURN xb \\<le> (INF f\\<in>A. f x)", "hence \"RETURN a \\<le> (INF f\\<in>A. f x)\""], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>A.\n     nofail (f x) \\<longrightarrow>\n     (h, as) \\<Turnstile> Ry a p * F \\<and> RETURN a \\<le> f x\n\ngoal (1 subgoal):\n 1. RETURN a \\<le> (INF f\\<in>A. f x)", "by (metis (mono_tags) le_INF_iff le_nofailI)"], ["proof (state)\nthis:\n  RETURN a \\<le> (INF f\\<in>A. f x)\n\ngoal (1 subgoal):\n 1. \\<And>xa a b.\n       \\<lbrakk>in_range (a, b);\n        \\<forall>xaa.\n           xaa \\<in> A \\<longrightarrow>\n           (\\<exists>xb.\n               (a, b) \\<Turnstile> Ry xb xa * F \\<and>\n               RETURN xb \\<le> xaa x) \\<or>\n           \\<not> nofail (xaa x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb.\n                            (a, b) \\<Turnstile> Ry xb xa * F \\<and>\n                            RETURN xb \\<le> (INF f\\<in>A. f x)", "with 1"], ["proof (chain)\npicking this:\n  (h, as) \\<Turnstile> Ry a p * F\n  RETURN a \\<le> (INF f\\<in>A. f x)", "show \"\\<exists>a. (h, as) \\<Turnstile> Ry a p * F \\<and> RETURN a \\<le> (INF f\\<in>A. f x)\""], ["proof (prove)\nusing this:\n  (h, as) \\<Turnstile> Ry a p * F\n  RETURN a \\<le> (INF f\\<in>A. f x)\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       (h, as) \\<Turnstile> Ry a p * F \\<and>\n       RETURN a \\<le> (INF f\\<in>A. f x)", "by blast"], ["proof (state)\nthis:\n  \\<exists>a.\n     (h, as) \\<Turnstile> Ry a p * F \\<and>\n     RETURN a \\<le> (INF f\\<in>A. f x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  <P> c <\\<lambda>r. hn_rel Ry (INF f\\<in>A. f x) r * F>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hn_admissible':\n  assumes PREC: \"precise Ry\"\n  assumes E: \"\\<forall>f\\<in>A. nofail (f x) \\<longrightarrow> <P> c <\\<lambda>r. hn_rel Ry (f x) r * F>\\<^sub>t\"\n  assumes NF: \"nofail (INF f\\<in>A. f x)\"\n  shows \"<P> c <\\<lambda>r. hn_rel Ry (INF f\\<in>A. f x) r * F>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <P> c <\\<lambda>r. hn_rel Ry (INF f\\<in>A. f x) r * F>\\<^sub>t", "apply (rule hn_admissible[OF PREC, where F=\"F*true\", simplified])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>f\\<in>A.\n       nofail (f x) \\<longrightarrow> <P> c\n       <\\<lambda>r. hn_rel Ry (f x) r * (F * true)>\n 2. nofail (INF f\\<in>A. f x)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>f\\<in>A.\n       nofail (f x) \\<longrightarrow>\n       <P> c <\\<lambda>r. hn_rel Ry (f x) r * F>\\<^sub>t\n 2. nofail (INF f\\<in>A. f x)", "by fact+"], ["", "lemma hnr_RECT_old:\n  assumes S: \"\\<And>cf af ax px. \\<lbrakk>\n    \\<And>ax px. hn_refine (hn_ctxt Rx ax px * F) (cf px) (F' ax px) Ry (af ax)\\<rbrakk> \n    \\<Longrightarrow> hn_refine (hn_ctxt Rx ax px * F) (cB cf px) (F' ax px) Ry (aB af ax)\"\n  assumes M: \"(\\<And>x. mono_Heap (\\<lambda>f. cB f x))\"\n  assumes PREC: \"precise Ry\"\n  shows \"hn_refine \n    (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px) Ry (RECT aB ax)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px) Ry\n     (REC\\<^sub>T aB ax)", "unfolding RECT_gfp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px) Ry\n     (if trimono aB then gfp aB ax else FAIL)", "proof (simp, intro conjI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. trimono aB \\<Longrightarrow>\n    hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px) Ry\n     (gfp aB ax)", "assume \"trimono aB\""], ["proof (state)\nthis:\n  trimono aB\n\ngoal (1 subgoal):\n 1. trimono aB \\<Longrightarrow>\n    hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px) Ry\n     (gfp aB ax)", "hence \"mono aB\""], ["proof (prove)\nusing this:\n  trimono aB\n\ngoal (1 subgoal):\n 1. mono aB", "by (simp add: trimonoD)"], ["proof (state)\nthis:\n  mono aB\n\ngoal (1 subgoal):\n 1. trimono aB \\<Longrightarrow>\n    hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px) Ry\n     (gfp aB ax)", "have \"\\<forall>ax px. \n    hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px) Ry \n      (gfp aB ax)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ax px.\n       hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px) Ry\n        (gfp aB ax)", "apply (rule gfp_cadm_induct[OF _ _ \\<open>mono aB\\<close>])"], ["proof (prove)\ngoal (3 subgoals):\n 1. dual_chain_admissible\n     (\\<lambda>a.\n         \\<forall>ax px.\n            hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px)\n             (F' ax px) Ry (a ax))\n 2. \\<forall>ax px.\n       hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px) Ry\n        (Inf {} ax)\n 3. \\<And>x.\n       \\<forall>ax px.\n          hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px)\n           Ry (x ax) \\<Longrightarrow>\n       \\<forall>ax px.\n          hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px)\n           Ry (aB x ax)", "apply rule"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>is_dual_chain A; A \\<noteq> {};\n        \\<forall>x\\<in>A.\n           \\<forall>ax px.\n              hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px)\n               (F' ax px) Ry (x ax)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ax px.\n                            hn_refine (hn_ctxt Rx ax px * F)\n                             (heap.fixp_fun cB px) (F' ax px) Ry (Inf A ax)\n 2. \\<forall>ax px.\n       hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px) Ry\n        (Inf {} ax)\n 3. \\<And>x.\n       \\<forall>ax px.\n          hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px)\n           Ry (x ax) \\<Longrightarrow>\n       \\<forall>ax px.\n          hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px)\n           Ry (aB x ax)", "apply (auto simp: hn_refine_alt intro: hn_admissible'[OF PREC]) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>ax px.\n       hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px) Ry\n        (Inf {} ax)\n 2. \\<And>x.\n       \\<forall>ax px.\n          hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px)\n           Ry (x ax) \\<Longrightarrow>\n       \\<forall>ax px.\n          hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px)\n           Ry (aB x ax)", "apply (auto simp: hn_refine_alt) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>ax px.\n          hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px)\n           Ry (x ax) \\<Longrightarrow>\n       \\<forall>ax px.\n          hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px)\n           Ry (aB x ax)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x ax px.\n       \\<forall>ax px.\n          hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px)\n           Ry (x ax) \\<Longrightarrow>\n       hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px) Ry\n        (aB x ax)", "apply (subst heap.mono_body_fixp[of cB, OF M])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x ax px.\n       \\<forall>ax px.\n          hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px)\n           Ry (x ax) \\<Longrightarrow>\n       hn_refine (hn_ctxt Rx ax px * F) (cB (heap.fixp_fun cB) px)\n        (F' ax px) Ry (aB x ax)", "apply (rule S)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x ax px axa pxa.\n       \\<forall>ax px.\n          hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px)\n           Ry (x ax) \\<Longrightarrow>\n       hn_refine (hn_ctxt Rx axa pxa * F) (heap.fixp_fun cB pxa)\n        (F' axa pxa) Ry (x axa)", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>ax px.\n     hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px) Ry\n      (gfp aB ax)\n\ngoal (1 subgoal):\n 1. trimono aB \\<Longrightarrow>\n    hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px) Ry\n     (gfp aB ax)", "thus \"hn_refine (hn_ctxt Rx ax px * F)\n     (ccpo.fixp (fun_lub Heap_lub) (fun_ord Heap_ord) cB px) (F' ax px) Ry\n     (gfp aB ax)\""], ["proof (prove)\nusing this:\n  \\<forall>ax px.\n     hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px) Ry\n      (gfp aB ax)\n\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px) Ry\n     (gfp aB ax)", "by simp"], ["proof (state)\nthis:\n  hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px) Ry\n   (gfp aB ax)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hnr_RECT:\n  assumes S: \"\\<And>cf af ax px. \\<lbrakk>\n    \\<And>ax px. hn_refine (hn_ctxt Rx ax px * F) (cf px) (F' ax px) Ry (af ax)\\<rbrakk> \n    \\<Longrightarrow> hn_refine (hn_ctxt Rx ax px * F) (cB cf px) (F' ax px) Ry (aB af ax)\"\n  assumes M: \"(\\<And>x. mono_Heap (\\<lambda>f. cB f x))\"\n  shows \"hn_refine \n    (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px) Ry (RECT aB ax)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px) Ry\n     (REC\\<^sub>T aB ax)", "unfolding RECT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px) Ry\n     (if trimono aB then flatf_gfp aB ax else FAIL)", "proof (simp, intro conjI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. trimono aB \\<Longrightarrow>\n    hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px) Ry\n     (flatf_gfp aB ax)", "assume \"trimono aB\""], ["proof (state)\nthis:\n  trimono aB\n\ngoal (1 subgoal):\n 1. trimono aB \\<Longrightarrow>\n    hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px) Ry\n     (flatf_gfp aB ax)", "hence \"flatf_mono_ge aB\""], ["proof (prove)\nusing this:\n  trimono aB\n\ngoal (1 subgoal):\n 1. flatf_mono FAIL aB", "by (simp add: trimonoD)"], ["proof (state)\nthis:\n  flatf_mono FAIL aB\n\ngoal (1 subgoal):\n 1. trimono aB \\<Longrightarrow>\n    hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px) Ry\n     (flatf_gfp aB ax)", "have \"\\<forall>ax px. \n    hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px) Ry \n      (flatf_gfp aB ax)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ax px.\n       hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px) Ry\n        (flatf_gfp aB ax)", "apply (rule flatf_ord.fixp_induct[OF _ \\<open>flatf_mono_ge aB\\<close>])"], ["proof (prove)\ngoal (3 subgoals):\n 1. ccpo.admissible (flatf_lub FAIL) (flatf_ord FAIL)\n     (\\<lambda>a.\n         \\<forall>ax px.\n            hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px)\n             (F' ax px) Ry (a ax))\n 2. \\<forall>ax px.\n       hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px) Ry\n        (flatf_lub FAIL {} ax)\n 3. \\<And>x.\n       \\<forall>ax px.\n          hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px)\n           Ry (x ax) \\<Longrightarrow>\n       \\<forall>ax px.\n          hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px)\n           Ry (aB x ax)", "apply (rule flatf_admissible_pointwise)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ax.\n       \\<forall>px.\n          hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px)\n           Ry FAIL\n 2. \\<forall>ax px.\n       hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px) Ry\n        (flatf_lub FAIL {} ax)\n 3. \\<And>x.\n       \\<forall>ax px.\n          hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px)\n           Ry (x ax) \\<Longrightarrow>\n       \\<forall>ax px.\n          hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px)\n           Ry (aB x ax)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>ax px.\n       hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px) Ry\n        (flatf_lub FAIL {} ax)\n 2. \\<And>x.\n       \\<forall>ax px.\n          hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px)\n           Ry (x ax) \\<Longrightarrow>\n       \\<forall>ax px.\n          hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px)\n           Ry (aB x ax)", "apply (auto simp: hn_refine_alt) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>ax px.\n          hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px)\n           Ry (x ax) \\<Longrightarrow>\n       \\<forall>ax px.\n          hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px)\n           Ry (aB x ax)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x ax px.\n       \\<forall>ax px.\n          hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px)\n           Ry (x ax) \\<Longrightarrow>\n       hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px) Ry\n        (aB x ax)", "apply (subst heap.mono_body_fixp[of cB, OF M])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x ax px.\n       \\<forall>ax px.\n          hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px)\n           Ry (x ax) \\<Longrightarrow>\n       hn_refine (hn_ctxt Rx ax px * F) (cB (heap.fixp_fun cB) px)\n        (F' ax px) Ry (aB x ax)", "apply (rule S)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x ax px axa pxa.\n       \\<forall>ax px.\n          hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px)\n           Ry (x ax) \\<Longrightarrow>\n       hn_refine (hn_ctxt Rx axa pxa * F) (heap.fixp_fun cB pxa)\n        (F' axa pxa) Ry (x axa)", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>ax px.\n     hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px) Ry\n      (flatf_gfp aB ax)\n\ngoal (1 subgoal):\n 1. trimono aB \\<Longrightarrow>\n    hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px) Ry\n     (flatf_gfp aB ax)", "thus \"hn_refine (hn_ctxt Rx ax px * F)\n     (ccpo.fixp (fun_lub Heap_lub) (fun_ord Heap_ord) cB px) (F' ax px) Ry\n     (flatf_gfp aB ax)\""], ["proof (prove)\nusing this:\n  \\<forall>ax px.\n     hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px) Ry\n      (flatf_gfp aB ax)\n\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px) Ry\n     (flatf_gfp aB ax)", "by simp"], ["proof (state)\nthis:\n  hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px) (F' ax px) Ry\n   (flatf_gfp aB ax)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hnr_If:\n  assumes P: \"\\<Gamma> \\<Longrightarrow>\\<^sub>t \\<Gamma>1 * hn_val bool_rel a a'\"\n  assumes RT: \"a \\<Longrightarrow> hn_refine (\\<Gamma>1 * hn_val bool_rel a a') b' \\<Gamma>2b R b\"\n  assumes RE: \"\\<not>a \\<Longrightarrow> hn_refine (\\<Gamma>1 * hn_val bool_rel a a') c' \\<Gamma>2c R c\"\n  assumes IMP: \"\\<Gamma>2b \\<or>\\<^sub>A \\<Gamma>2c \\<Longrightarrow>\\<^sub>t \\<Gamma>'\"\n  shows \"hn_refine \\<Gamma> (if a' then b' else c') \\<Gamma>' R (if a then b else c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine \\<Gamma> (if a' then b' else c') \\<Gamma>' R\n     (if a then b else c)", "apply (rule hn_refine_cons[OF P])"], ["proof (prove)\ngoal (3 subgoals):\n 1. hn_refine (\\<Gamma>1 * hn_val bool_rel a a') (if a' then b' else c') ?Q\n     ?R (if a then b else c)\n 2. ?Q \\<Longrightarrow>\\<^sub>t \\<Gamma>'\n 3. \\<And>x y. ?R x y \\<Longrightarrow>\\<^sub>t R x y", "apply1 (rule hn_refine_preI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>h.\n       h \\<Turnstile> \\<Gamma>1 * hn_val bool_rel a a' \\<Longrightarrow>\n       hn_refine (\\<Gamma>1 * hn_val bool_rel a a') (if a' then b' else c')\n        ?Q ?R (if a then b else c)\n 2. ?Q \\<Longrightarrow>\\<^sub>t \\<Gamma>'\n 3. \\<And>x y. ?R x y \\<Longrightarrow>\\<^sub>t R x y", "applyF (cases a; simp add: hn_ctxt_def pure_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>h.\n       \\<lbrakk>h \\<Turnstile> \\<Gamma>1 \\<and> a'; a\\<rbrakk>\n       \\<Longrightarrow> hn_refine \\<Gamma>1 b' ?Q ?R b\n 2. \\<And>h.\n       \\<lbrakk>h \\<Turnstile> \\<Gamma>1 \\<and> \\<not> a'; \\<not> a\\<rbrakk>\n       \\<Longrightarrow> hn_refine \\<Gamma>1 c' ?Q ?R c", "focus"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       \\<lbrakk>h \\<Turnstile> \\<Gamma>1 \\<and> a'; a\\<rbrakk>\n       \\<Longrightarrow> hn_refine \\<Gamma>1 b' ?Q ?R b", "apply1 (rule hn_refine_split_post)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       \\<lbrakk>h \\<Turnstile> \\<Gamma>1 \\<and> a'; a\\<rbrakk>\n       \\<Longrightarrow> hn_refine \\<Gamma>1 b' ?\\<Gamma>'19 ?R b", "applyF (rule hn_refine_cons_pre[OF _ RT])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>h.\n       \\<lbrakk>h \\<Turnstile> \\<Gamma>1 \\<and> a'; a\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>1 \\<Longrightarrow>\\<^sub>t\n                         \\<Gamma>1 * hn_val bool_rel a a'\n 2. \\<And>h.\n       \\<lbrakk>h \\<Turnstile> \\<Gamma>1 \\<and> a'; a\\<rbrakk>\n       \\<Longrightarrow> a", "applyS (simp add: hn_ctxt_def pure_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       \\<lbrakk>h \\<Turnstile> \\<Gamma>1 \\<and> a'; a\\<rbrakk>\n       \\<Longrightarrow> a", "applyS simp"], ["proof (prove)\ngoal:\nNo subgoals!", "solved"], ["proof (prove)\ngoal:\nNo subgoals!", "solved"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       \\<lbrakk>h \\<Turnstile> \\<Gamma>1 \\<and> \\<not> a'; \\<not> a\\<rbrakk>\n       \\<Longrightarrow> hn_refine \\<Gamma>1 c'\n                          (\\<Gamma>2b \\<or>\\<^sub>A ?\\<Gamma>''20) R c", "apply1 (rule hn_refine_post_other)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       \\<lbrakk>h \\<Turnstile> \\<Gamma>1 \\<and> \\<not> a'; \\<not> a\\<rbrakk>\n       \\<Longrightarrow> hn_refine \\<Gamma>1 c' ?\\<Gamma>''20 R c", "applyF (rule hn_refine_cons_pre[OF _ RE])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>h.\n       \\<lbrakk>h \\<Turnstile> \\<Gamma>1 \\<and> \\<not> a'; \\<not> a\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>1 \\<Longrightarrow>\\<^sub>t\n                         \\<Gamma>1 * hn_val bool_rel a a'\n 2. \\<And>h.\n       \\<lbrakk>h \\<Turnstile> \\<Gamma>1 \\<and> \\<not> a'; \\<not> a\\<rbrakk>\n       \\<Longrightarrow> \\<not> a", "applyS (simp add: hn_ctxt_def pure_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       \\<lbrakk>h \\<Turnstile> \\<Gamma>1 \\<and> \\<not> a'; \\<not> a\\<rbrakk>\n       \\<Longrightarrow> \\<not> a", "applyS simp"], ["proof (prove)\ngoal:\nNo subgoals!", "solved"], ["proof (prove)\ngoal:\nNo subgoals!", "solved"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<Gamma>2b \\<or>\\<^sub>A \\<Gamma>2c \\<Longrightarrow>\\<^sub>t \\<Gamma>'\n 2. \\<And>x y. R x y \\<Longrightarrow>\\<^sub>t R x y", "applyS (rule IMP)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. R x y \\<Longrightarrow>\\<^sub>t R x y", "applyS (rule entt_refl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>ML-Level Utilities\\<close>"], ["", "ML \\<open>\n  signature SEPREF_BASIC = sig\n    (* Destroy lambda term, return function to reconstruct. Bound var is replaced by free. *)\n    val dest_lambda_rc: Proof.context -> term -> ((term * (term -> term)) * Proof.context)\n    (* Apply function under lambda. Bound var is replaced by free. *)\n    val apply_under_lambda: (Proof.context -> term -> term) -> Proof.context -> term -> term\n\n    (* 'a nres type *)\n    val is_nresT: typ -> bool\n    val mk_nresT: typ -> typ\n    val dest_nresT: typ -> typ\n\n    (* Make certified == *)\n    val mk_cequals: cterm * cterm -> cterm\n    (* Make \\<Longrightarrow>\\<^sub>A *)\n    val mk_entails: term * term -> term\n\n\n    (* Operations on pre-terms *)\n    val constrain_type_pre: typ -> term -> term (* t::T *)\n\n    val mk_pair_in_pre: term -> term -> term -> term (* (c,a) \\<in> R *)\n\n    val mk_compN_pre: int -> term -> term -> term  (* f o...o g*)\n\n    val mk_curry0_pre: term -> term                (* curry0 f *) \n    val mk_curry_pre: term -> term                 (* curry f *) \n    val mk_curryN_pre: int -> term -> term         (* curry (...(curry f)...) *) \n\n    val mk_uncurry0_pre: term -> term              (* uncurry0 f *)       \n    val mk_uncurry_pre: term -> term               (* uncurry f *)\n    val mk_uncurryN_pre: int -> term -> term       (* uncurry (...(uncurry f)...) *)\n\n\n\n    (* Conversion for hn_refine - term*)\n    val hn_refine_conv: conv -> conv -> conv -> conv -> conv -> conv\n\n    (* Conversion on abstract value (last argument) of hn_refine - term *)\n    val hn_refine_conv_a: conv -> conv\n\n    (* Conversion on abstract value of hn_refine term in conclusion of theorem *)\n    val hn_refine_concl_conv_a: (Proof.context -> conv) -> Proof.context -> conv\n\n    (* Destruct hn_refine term *)\n    val dest_hn_refine: term -> term * term * term * term * term \n    (* Make hn_refine term *)\n    val mk_hn_refine: term * term * term * term * term -> term\n    (* Check if given term is Trueprop (hn_refine ...). Use with CONCL_COND'. *)\n    val is_hn_refine_concl: term -> bool\n\n    (* Destruct abs-fun, returns RETURN-flag, (f, args) *)\n    val dest_hnr_absfun: term -> bool * (term * term list)\n    (* Make abs-fun. *)\n    val mk_hnr_absfun: bool * (term * term list) -> term\n    (* Make abs-fun. Guess RETURN-flag from type. *)\n    val mk_hnr_absfun': (term * term list) -> term\n    \n    (* Prove permutation of *. To be used with f_tac_conv. *)\n    val star_permute_tac: Proof.context -> tactic\n\n    (* Make separation conjunction *)\n    val mk_star: term * term -> term\n    (* Make separation conjunction from list. \"[]\" yields \"emp\". *)\n    val list_star: term list -> term\n    (* Decompose separation conjunction. \"emp\" yields \"[]\". *)\n    val strip_star: term -> term list\n\n    (* Check if true-assertion *)\n    val is_true: term -> bool\n\n    (* Check if term is hn_ctxt-assertion *)\n    val is_hn_ctxt: term -> bool \n    (* Decompose hn_ctxt-assertion *)\n    val dest_hn_ctxt: term -> term * term * term\n    (* Decompose hn_ctxt-assertion, NONE if term has wrong format *)\n    val dest_hn_ctxt_opt: term -> (term * term * term) option\n      \n\n    type phases_ctrl = {\n      trace: bool,            (* Trace phases *)\n      int_res: bool,          (* Stop with intermediate result *)\n      start: string option,   (* Start with this phase. NONE: First phase *)\n      stop: string option     (* Stop after this phase. NONE: Last phase *)\n    }\n\n    (* No tracing or intermediate result, all phases *)\n    val dflt_phases_ctrl: phases_ctrl \n    (* Tracing, intermediate result, all phases *)\n    val dbg_phases_ctrl: phases_ctrl\n    val flag_phases_ctrl: bool -> phases_ctrl\n\n    (* Name, tactic, expected number of created goals (may be negative for solved goals) *)\n    type phase = string * (Proof.context -> tactic') * int\n\n    (* Perform sequence of tactics (tac,n), each expected to create n new goals, \n       or solve goals if n is negative. \n       Debug-flag: Stop with intermediate state after tactic \n       fails or produces less/more goals as expected. *)   \n    val PHASES': phase list -> phases_ctrl -> Proof.context -> tactic'\n\n  end\n\n  structure Sepref_Basic: SEPREF_BASIC = struct\n\n    fun is_nresT (Type (@{type_name nres},[_])) = true | is_nresT _ = false\n    fun mk_nresT T = Type(@{type_name nres},[T])\n    fun dest_nresT (Type (@{type_name nres},[T])) = T | dest_nresT T = raise TYPE(\"dest_nresT\",[T],[])\n\n\n    fun dest_lambda_rc ctxt (Abs (x,T,t)) = let\n        val (u,ctxt) = yield_singleton Variable.variant_fixes x ctxt\n        val u = Free (u,T)\n        val t = subst_bound (u,t)\n        val reconstruct = Term.lambda_name (x,u)\n      in\n        ((t,reconstruct),ctxt)\n      end\n    | dest_lambda_rc _ t = raise TERM(\"dest_lambda_rc\",[t])\n\n    fun apply_under_lambda f ctxt t = let\n      val ((t,rc),ctxt) = dest_lambda_rc ctxt t\n      val t = f ctxt t\n    in\n      rc t\n    end\n\n\n    (* Functions on pre-terms *)\n    fun mk_pair_in_pre x y r = Const (@{const_name Set.member}, dummyT) $\n      (Const (@{const_name Product_Type.Pair}, dummyT) $ x $ y) $ r\n\n\n    fun mk_uncurry_pre t = Const(@{const_name uncurry}, dummyT)$t\n    fun mk_uncurry0_pre t = Const(@{const_name uncurry0}, dummyT)$t\n    fun mk_uncurryN_pre 0 = mk_uncurry0_pre\n      | mk_uncurryN_pre 1 = I\n      | mk_uncurryN_pre n = mk_uncurry_pre o mk_uncurryN_pre (n-1)\n\n    fun mk_curry_pre t = Const(@{const_name curry}, dummyT)$t\n    fun mk_curry0_pre t = Const(@{const_name curry0}, dummyT)$t\n    fun mk_curryN_pre 0 = mk_curry0_pre\n      | mk_curryN_pre 1 = I\n      | mk_curryN_pre n = mk_curry_pre o mk_curryN_pre (n-1)\n\n\n    fun mk_compN_pre 0 f g = f $ g\n      | mk_compN_pre n f g = let\n          val g = fold (fn i => fn t => t$Bound i) (n-2 downto 0) g\n          val t = Const(@{const_name \"Fun.comp\"},dummyT) $ f $ g\n\n          val t = fold (fn i => fn t => Abs (\"x\"^string_of_int i,dummyT,t)) (n-1 downto 1) t\n        in\n          t\n        end\n\n    fun constrain_type_pre T t = Const(@{syntax_const \"_type_constraint_\"},T-->T) $ t\n\n\n\n\n    local open Conv in\n      fun hn_refine_conv c1 c2 c3 c4 c5 ct = case Thm.term_of ct of\n        @{mpat \"hn_refine _ _ _ _ _\"} => let\n          val cc = combination_conv\n        in\n          cc (cc (cc (cc (cc all_conv c1) c2) c3) c4) c5 ct\n        end\n      | _ => raise CTERM (\"hn_refine_conv\",[ct])\n  \n      val hn_refine_conv_a = hn_refine_conv all_conv all_conv all_conv all_conv\n  \n      fun hn_refine_concl_conv_a conv ctxt = Refine_Util.HOL_concl_conv \n        (fn ctxt => hn_refine_conv_a (conv ctxt)) ctxt\n  \n    end\n\n    (* FIXME: Strange dependency! *)\n    val mk_cequals = uncurry SMT_Util.mk_cequals\n  \n    val mk_entails = HOLogic.mk_binrel @{const_name \"entails\"}\n  \n    val mk_star = HOLogic.mk_binop @{const_name \"Groups.times_class.times\"}\n\n    fun list_star [] = @{term \"emp::assn\"}\n      | list_star [a] = a\n      | list_star (a::l) = mk_star (list_star l,a)\n\n    fun strip_star @{mpat \"?a*?b\"} = strip_star a @ strip_star b\n      | strip_star @{mpat \"emp\"} = []\n      | strip_star t = [t]\n\n    fun is_true @{mpat \"true\"} = true | is_true _ = false\n  \n    fun is_hn_ctxt @{mpat \"hn_ctxt _ _ _\"} = true | is_hn_ctxt _ = false\n    fun dest_hn_ctxt @{mpat \"hn_ctxt ?R ?a ?p\"} = (R,a,p) \n      | dest_hn_ctxt t = raise TERM(\"dest_hn_ctxt\",[t])\n  \n    fun dest_hn_ctxt_opt @{mpat \"hn_ctxt ?R ?a ?p\"} = SOME (R,a,p) \n      | dest_hn_ctxt_opt _ = NONE\n  \n    fun strip_abs_args (t as @{mpat \"PR_CONST _\"}) = (t,[])\n      | strip_abs_args @{mpat \"?f$?a\"} = (case strip_abs_args f of (f,args) => (f,args@[a]))\n      | strip_abs_args t = (t,[])\n  \n    fun dest_hnr_absfun @{mpat \"RETURN$?a\"} = (true, strip_abs_args a)\n      | dest_hnr_absfun f = (false, strip_abs_args f)\n  \n    fun mk_hnr_absfun (true,fa) = Autoref_Tagging.list_APP fa |> (fn a => @{mk_term \"RETURN$?a\"})\n      | mk_hnr_absfun (false,fa) = Autoref_Tagging.list_APP fa\n  \n    fun mk_hnr_absfun' fa = let\n      val t = Autoref_Tagging.list_APP fa\n      val T = fastype_of t\n    in\n      case T of\n        Type (@{type_name nres},_) => t\n      | _ => @{mk_term \"RETURN$?t\"}\n  \n    end  \n  \n    fun dest_hn_refine @{mpat \"hn_refine ?P ?c ?Q ?R ?a\"} = (P,c,Q,R,a)\n      | dest_hn_refine t = raise TERM(\"dest_hn_refine\",[t])\n  \n    fun mk_hn_refine (P,c,Q,R,a) = @{mk_term \"hn_refine ?P ?c ?Q ?R ?a\"}\n  \n    val is_hn_refine_concl = can (HOLogic.dest_Trueprop #> dest_hn_refine)\n  \n    fun star_permute_tac ctxt = ALLGOALS (simp_tac (put_simpset HOL_basic_ss ctxt addsimps @{thms star_aci}))\n      \n\n    type phases_ctrl = {\n      trace: bool,            \n      int_res: bool,          \n      start: string option,   \n      stop: string option     \n    }\n\n    val dflt_phases_ctrl = {trace=false,int_res=false,start=NONE,stop=NONE} \n    val dbg_phases_ctrl = {trace=true,int_res=true,start=NONE,stop=NONE}\n    fun flag_phases_ctrl dbg = if dbg then dbg_phases_ctrl else dflt_phases_ctrl\n\n    type phase = string * (Proof.context -> tactic') * int\n\n    local\n      fun ph_range phases start stop = let\n        fun find_phase name = let\n          val i = find_index (fn (n,_,_) => n=name) phases\n          val _ = if i<0 then error (\"No such phase: \" ^ name) else ()\n        in\n          i\n        end\n\n        val i = case start of NONE => 0 | SOME n => find_phase n\n        val j = case stop of NONE => length phases - 1 | SOME n => find_phase n\n\n        val phases = take (j+1) phases |> drop i\n\n        val _ = case phases of [] => error \"No phases selected, range is empty\" | _ => ()\n      in\n        phases\n      end\n    in  \n  \n      fun PHASES' phases ctrl ctxt = let\n        val phases = ph_range phases (#start ctrl) (#stop ctrl)\n        val phases = map (fn (n,tac,d) => (n,tac ctxt,d)) phases\n  \n        fun r [] _ st = Seq.single st\n          | r ((name,tac,d)::tacs) i st = let\n              val n = Thm.nprems_of st\n              val bailout_tac = if #int_res ctrl then all_tac else no_tac\n              fun trace_tac msg st = (if #trace ctrl then tracing msg else (); Seq.single st)\n              val trace_start_tac = trace_tac (\"Phase \" ^ name)\n            in\n              K trace_start_tac THEN' IF_EXGOAL (tac)\n              THEN_ELSE' (\n                fn i => fn st => \n                  (* Bail out if a phase does not solve/create exactly the expected subgoals *)\n                  if Thm.nprems_of st = n+d then\n                    ((trace_tac \"  Done\" THEN r tacs i) st)\n                  else\n                    (trace_tac \"*** Wrong number of produced goals\" THEN bailout_tac) st\n              , \n                K (trace_tac \"*** Phase tactic failed\" THEN bailout_tac))\n            end i st\n  \n      in\n        r phases\n      end\n\n\n    end\n\n(*    (* Perform sequence of tactics (tac,n), each expected to create n new goals, \n       or solve goals if n is negative. \n       Debug-flag: Stop with intermediate state after tactic \n       fails or produces less/more goals as expected. *)   \n    val PHASES': phase list -> phases_ctrl -> Proof.context -> tactic'\n*)\n\n\n\n(*\n\n    fun xPHASES' dbg tacs ctxt = let\n      val tacs = map (fn (tac,d) => (tac ctxt,d)) tacs\n\n      fun r [] _ st = Seq.single st\n        | r ((tac,d)::tacs) i st = let\n            val n = Thm.nprems_of st\n            val bailout_tac = if dbg then all_tac else no_tac\n          in\n            IF_EXGOAL (tac)\n            THEN_ELSE' (\n              fn i => fn st => \n                (* Bail out if a phase does not solve/create exactly the expected subgoals *)\n                if Thm.nprems_of st = n+d then\n                  (r tacs i st)\n                else\n                  bailout_tac st\n            , \n              K bailout_tac)\n          end i st\n\n    in\n      r tacs\n    end\n*)\n  end\n\n\n  signature SEPREF_DEBUGGING = sig\n    (*************************)\n    (* Debugging *)\n    (* Centralized debugging mode flag *)\n    val cfg_debug_all: bool Config.T\n\n    val is_debug: bool Config.T -> Proof.context -> bool\n    val is_debug': Proof.context -> bool\n\n    (* Conversion, trace errors if custom or central debugging flag is activated *)\n    val DBG_CONVERSION: bool Config.T -> Proof.context -> conv -> tactic'\n\n    (* Conversion, trace errors if central debugging flag is activated *)\n    val DBG_CONVERSION': Proof.context -> conv -> tactic'\n\n    (* Tracing message and current subgoal *)\n    val tracing_tac': string -> Proof.context -> tactic'\n    (* Warning message and current subgoal *)\n    val warning_tac': string -> Proof.context -> tactic'\n    (* Error message and current subgoal *)\n    val error_tac': string -> Proof.context -> tactic'\n\n    (* Trace debug message *)\n    val dbg_trace_msg: bool Config.T -> Proof.context -> string -> unit\n    val dbg_trace_msg': Proof.context -> string -> unit\n\n    val dbg_msg_tac: bool Config.T -> (Proof.context -> int -> thm -> string) -> Proof.context -> tactic'\n    val dbg_msg_tac': (Proof.context -> int -> thm -> string) -> Proof.context -> tactic'\n\n    val msg_text: string -> Proof.context -> int -> thm -> string\n    val msg_subgoal: string -> Proof.context -> int -> thm -> string\n    val msg_from_subgoal: string -> (term -> Proof.context -> string) -> Proof.context -> int -> thm -> string\n    val msg_allgoals: string -> Proof.context -> int -> thm -> string\n\n  end\n\n  structure Sepref_Debugging: SEPREF_DEBUGGING = struct\n\n    val cfg_debug_all = \n      Attrib.setup_config_bool @{binding sepref_debug_all} (K false)\n\n    fun is_debug cfg ctxt = Config.get ctxt cfg orelse Config.get ctxt cfg_debug_all\n    fun is_debug' ctxt = Config.get ctxt cfg_debug_all\n\n    fun dbg_trace cfg ctxt obj = \n      if is_debug cfg ctxt then  \n        tracing (@{make_string} obj)\n      else ()\n\n    fun dbg_trace' ctxt obj = \n      if is_debug' ctxt then  \n        tracing (@{make_string} obj)\n      else ()\n\n    fun dbg_trace_msg cfg ctxt msg =   \n      if is_debug cfg ctxt then  \n        tracing msg\n      else ()\n    fun dbg_trace_msg' ctxt msg = \n      if is_debug' ctxt then  \n        tracing msg\n      else ()\n\n    fun DBG_CONVERSION cfg ctxt cv i st = \n      Seq.single (Conv.gconv_rule cv i st)\n      handle e as THM _ => (dbg_trace cfg ctxt e; Seq.empty)\n           | e as CTERM _ => (dbg_trace cfg ctxt e; Seq.empty)\n           | e as TERM _ => (dbg_trace cfg ctxt e; Seq.empty)\n           | e as TYPE _ => (dbg_trace cfg ctxt e; Seq.empty);\n\n    fun DBG_CONVERSION' ctxt cv i st = \n      Seq.single (Conv.gconv_rule cv i st)\n      handle e as THM _ => (dbg_trace' ctxt e; Seq.empty)\n           | e as CTERM _ => (dbg_trace' ctxt e; Seq.empty)\n           | e as TERM _ => (dbg_trace' ctxt e; Seq.empty)\n           | e as TYPE _ => (dbg_trace' ctxt e; Seq.empty);\n\n\n    local \n      fun gen_subgoal_msg_tac do_msg msg ctxt = IF_EXGOAL (fn i => fn st => let\n        val t = nth (Thm.prems_of st) (i-1)\n        val _ = Pretty.block [Pretty.str msg, Pretty.fbrk, Syntax.pretty_term ctxt t]\n          |> Pretty.string_of |> do_msg\n\n      in\n        Seq.single st\n      end)\n    in       \n      val tracing_tac' = gen_subgoal_msg_tac tracing\n      val warning_tac' = gen_subgoal_msg_tac warning\n      val error_tac' = gen_subgoal_msg_tac error\n    end\n\n\n    fun dbg_msg_tac cfg msg ctxt =\n      if is_debug cfg ctxt then (fn i => fn st => (tracing (msg ctxt i st); Seq.single st))\n      else K all_tac\n    fun dbg_msg_tac' msg ctxt =\n      if is_debug' ctxt then (fn i => fn st => (tracing (msg ctxt i st); Seq.single st))\n      else K all_tac\n\n    fun msg_text msg _ _ _ = msg\n\n    fun msg_from_subgoal msg sgmsg ctxt i st = \n      case try (nth (Thm.prems_of st)) (i-1) of\n        NONE => msg ^ \"\\n\" ^ \"Subgoal out of range\"\n      | SOME t => msg ^ \"\\n\" ^ sgmsg t ctxt\n\n    fun msg_subgoal msg = msg_from_subgoal msg (fn t => fn ctxt =>\n      Syntax.pretty_term ctxt t |> Pretty.string_of\n    )\n\n    fun msg_allgoals msg ctxt _ st = \n      msg ^ \"\\n\" ^ Pretty.string_of (Pretty.chunks (Goal_Display.pretty_goals ctxt st))\n\n  end\n\\<close>"], ["", "ML \\<open>\n  (* Tactics for produced subgoals *)\n  infix 1 THEN_NEXT THEN_ALL_NEW_LIST THEN_ALL_NEW_LIST'\n  signature STACTICAL = sig\n    (* Apply first tactic on this subgoal, and then second tactic on next subgoal *)\n    val THEN_NEXT: tactic' * tactic' -> tactic'\n    (* Apply tactics to the current and following subgoals *)\n    val APPLY_LIST: tactic' list -> tactic'\n    (* Apply list of tactics on subgoals emerging from tactic. \n      Requires exactly one tactic per emerging subgoal.*)\n    val THEN_ALL_NEW_LIST: tactic' * tactic' list -> tactic'\n    (* Apply list of tactics to subgoals emerging from tactic, use fallback for additional subgoals. *)\n    val THEN_ALL_NEW_LIST': tactic' * (tactic' list * tactic') -> tactic'\n\n  end\n\n  structure STactical : STACTICAL = struct\n    infix 1 THEN_WITH_GOALDIFF\n    fun (tac1 THEN_WITH_GOALDIFF tac2) st = let\n      val n1 = Thm.nprems_of st\n    in\n      st |> (tac1 THEN (fn st => tac2 (Thm.nprems_of st - n1) st ))\n    end\n\n    fun (tac1 THEN_NEXT tac2) i = \n      tac1 i THEN_WITH_GOALDIFF (fn d => (\n        if d < ~1 then \n          (error \"THEN_NEXT: Tactic solved more than one goal\"; no_tac) \n        else \n          tac2 (i+1+d)\n      ))\n\n    fun APPLY_LIST [] = K all_tac\n      | APPLY_LIST (tac::tacs) = tac THEN_NEXT APPLY_LIST tacs\n            \n    fun (tac1 THEN_ALL_NEW_LIST tacs) i = \n      tac1 i \n      THEN_WITH_GOALDIFF (fn d =>\n        if d+1 <> length tacs then (\n          error \"THEN_ALL_NEW_LIST: Tactic produced wrong number of goals\"; no_tac\n        ) else APPLY_LIST tacs i\n      )\n\n    fun (tac1 THEN_ALL_NEW_LIST' (tacs,rtac)) i =  \n      tac1 i \n      THEN_WITH_GOALDIFF (fn d => let\n        val _ = if d+1 < length tacs then error \"THEN_ALL_NEW_LIST': Tactic produced too few goals\" else ();\n        val tacs' = tacs @ replicate (d + 1 - length tacs) rtac\n      in    \n        APPLY_LIST tacs' i\n      end)\n\n\n  end\n\n\n  open STactical\n\\<close>"], ["", "end"]]}