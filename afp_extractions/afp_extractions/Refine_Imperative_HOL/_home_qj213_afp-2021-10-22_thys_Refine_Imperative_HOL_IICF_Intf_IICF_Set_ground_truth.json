{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/IICF/Intf/IICF_Set.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemma op_set_is_empty_param[param]: \"(op_set_is_empty,op_set_is_empty)\\<in>\\<langle>A\\<rangle>set_rel \\<rightarrow> bool_rel\"", "lemma pat_set[def_pat_rules]:\n  \"{} \\<equiv> op_set_empty\"\n  \"(\\<in>) \\<equiv> op_set_member\"    \n  \"Set.insert \\<equiv> op_set_insert\"\n  \"(\\<union>) \\<equiv> op_set_union\"\n  \"(\\<inter>) \\<equiv> op_set_inter\"\n  \"(-) \\<equiv> op_set_diff\"\n  \"(\\<subseteq>) \\<equiv> op_set_subseteq\"\n  \"(\\<subset>) \\<equiv> op_set_subset\"", "lemma pat_set2[pat_rules]: \n  \"(=) $s${} \\<equiv> op_set_is_empty$s\"\n  \"(=) ${}$s \\<equiv> op_set_is_empty$s\"\n\n  \"(-) $s$(Set.insert$x${}) \\<equiv> op_set_delete$x$s\"\n  \"SPEC$(\\<lambda>\\<^sub>2x. (\\<in>) $x$s) \\<equiv> op_set_pick s\"\n  \"RES$s \\<equiv> op_set_pick s\"", "lemma fold_custom_empty:\n    \"{} = op_custom_empty\"\n    \"op_set_empty = op_custom_empty\"\n    \"mop_set_empty = RETURN op_custom_empty\""], "translations": [["", "lemma op_set_is_empty_param[param]: \"(op_set_is_empty,op_set_is_empty)\\<in>\\<langle>A\\<rangle>set_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (op_set_is_empty, op_set_is_empty)\n    \\<in> \\<langle>A\\<rangle>set_rel \\<rightarrow> bool_rel", "by auto"], ["", "context \n  notes [simp] = IS_LEFT_UNIQUE_def (* Argh, the set parametricity lemmas use single_valued (K\\<inverse>) here. *)\nbegin"], ["", "sepref_decl_op set_empty: \"{}\" :: \"\\<langle>A\\<rangle>set_rel\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_op (no_def) set_is_empty: op_set_is_empty :: \"\\<langle>A\\<rangle>set_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_op set_member: \"(\\<in>)\" :: \"A \\<rightarrow> \\<langle>A\\<rangle>set_rel \\<rightarrow> bool_rel\" where \"IS_LEFT_UNIQUE A\" \"IS_RIGHT_UNIQUE A\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_op set_insert: Set.insert :: \"A \\<rightarrow> \\<langle>A\\<rangle>set_rel \\<rightarrow> \\<langle>A\\<rangle>set_rel\" where \"IS_RIGHT_UNIQUE A\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_op set_delete: \"\\<lambda>x s. s - {x}\" :: \"A \\<rightarrow> \\<langle>A\\<rangle>set_rel \\<rightarrow> \\<langle>A\\<rangle>set_rel\" \n  where \"IS_LEFT_UNIQUE A\" \"IS_RIGHT_UNIQUE A\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_op set_union: \"(\\<union>)\" :: \"\\<langle>A\\<rangle>set_rel \\<rightarrow> \\<langle>A\\<rangle>set_rel \\<rightarrow> \\<langle>A\\<rangle>set_rel\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_op set_inter: \"(\\<inter>)\" :: \"\\<langle>A\\<rangle>set_rel \\<rightarrow> \\<langle>A\\<rangle>set_rel \\<rightarrow> \\<langle>A\\<rangle>set_rel\" where \"IS_LEFT_UNIQUE A\"  \"IS_RIGHT_UNIQUE A\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_op set_diff: \"(-) ::_ set \\<Rightarrow> _\" :: \"\\<langle>A\\<rangle>set_rel \\<rightarrow> \\<langle>A\\<rangle>set_rel \\<rightarrow> \\<langle>A\\<rangle>set_rel\" where \"IS_LEFT_UNIQUE A\"  \"IS_RIGHT_UNIQUE A\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_op set_subseteq: \"(\\<subseteq>)\" :: \"\\<langle>A\\<rangle>set_rel \\<rightarrow> \\<langle>A\\<rangle>set_rel \\<rightarrow> bool_rel\" where \"IS_LEFT_UNIQUE A\"  \"IS_RIGHT_UNIQUE A\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_op set_subset: \"(\\<subset>)\" :: \"\\<langle>A\\<rangle>set_rel \\<rightarrow> \\<langle>A\\<rangle>set_rel \\<rightarrow> bool_rel\" where \"IS_LEFT_UNIQUE A\" \"IS_RIGHT_UNIQUE A\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "(* TODO: We may want different operations here: pick with predicate returning option,\n  pick with remove, ... *)"], ["", "sepref_decl_op set_pick: \"RES\" :: \"[\\<lambda>s. s\\<noteq>{}]\\<^sub>f \\<langle>K\\<rangle>set_rel \\<rightarrow> K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s. s \\<noteq> {}, \\<lambda>s. s \\<noteq> {})\n    \\<in> \\<langle>K\\<rangle>set_rel \\<rightarrow> bool_rel", "by auto"], ["", "end"], ["", "(* TODO: Set-pick. Move from where it is already defined! *)"], ["", "subsection \\<open>Patterns\\<close>"], ["", "lemma pat_set[def_pat_rules]:\n  \"{} \\<equiv> op_set_empty\"\n  \"(\\<in>) \\<equiv> op_set_member\"    \n  \"Set.insert \\<equiv> op_set_insert\"\n  \"(\\<union>) \\<equiv> op_set_union\"\n  \"(\\<inter>) \\<equiv> op_set_inter\"\n  \"(-) \\<equiv> op_set_diff\"\n  \"(\\<subseteq>) \\<equiv> op_set_subseteq\"\n  \"(\\<subset>) \\<equiv> op_set_subset\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((({} \\<equiv> op_set_empty) &&& (\\<in>) \\<equiv> op_set_member) &&&\n     (insert \\<equiv> op_set_insert) &&&\n     (\\<union>) \\<equiv> op_set_union) &&&\n    (((\\<inter>) \\<equiv> op_set_inter) &&& (-) \\<equiv> op_set_diff) &&&\n    ((\\<subseteq>) \\<equiv> op_set_subseteq) &&&\n    (\\<subset>) \\<equiv> op_set_subset", "by (auto intro!: eq_reflection)"], ["", "lemma pat_set2[pat_rules]: \n  \"(=) $s${} \\<equiv> op_set_is_empty$s\"\n  \"(=) ${}$s \\<equiv> op_set_is_empty$s\"\n\n  \"(-) $s$(Set.insert$x${}) \\<equiv> op_set_delete$x$s\"\n  \"SPEC$(\\<lambda>\\<^sub>2x. (\\<in>) $x$s) \\<equiv> op_set_pick s\"\n  \"RES$s \\<equiv> op_set_pick s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((=) $ s $ {} \\<equiv> op_set_is_empty $ s) &&&\n     (=) $ {} $ s \\<equiv> op_set_is_empty $ s) &&&\n    ((-) $ s $ (insert $ x $ {}) \\<equiv> op_set_delete $ x $ s) &&&\n    (SPEC $ (\\<lambda>x. (#(\\<in>) $ x $ s#)) \\<equiv> op_set_pick s) &&&\n    RES $ s \\<equiv> op_set_pick s", "by (auto intro!: eq_reflection)"], ["", "locale set_custom_empty = \n  fixes empty and op_custom_empty :: \"'a set\"\n  assumes op_custom_empty_def: \"op_custom_empty = op_set_empty\"\nbegin"], ["", "sepref_register op_custom_empty :: \"'ax set\""], ["", "lemma fold_custom_empty:\n    \"{} = op_custom_empty\"\n    \"op_set_empty = op_custom_empty\"\n    \"mop_set_empty = RETURN op_custom_empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} = op_custom_empty &&&\n    op_set_empty = op_custom_empty &&&\n    mop_set_empty = RETURN op_custom_empty", "unfolding op_custom_empty_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {} = op_set_empty &&&\n    op_set_empty = op_set_empty &&& mop_set_empty = RETURN op_set_empty", "by simp_all"], ["", "end"], ["", "end"]]}