{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/Sepref_Translate.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemma vassn_tagI: \"h\\<Turnstile>\\<Gamma> \\<Longrightarrow> vassn_tag \\<Gamma>\"", "lemma vassn_dest[dest!]:\n  \"vassn_tag (\\<Gamma>\\<^sub>1 * \\<Gamma>\\<^sub>2) \\<Longrightarrow> vassn_tag \\<Gamma>\\<^sub>1 \\<and> vassn_tag \\<Gamma>\\<^sub>2\"\n  \"vassn_tag (hn_ctxt R a b) \\<Longrightarrow> a\\<in>rdom R\"", "lemma entails_preI:\n  assumes \"vassn_tag A \\<Longrightarrow> A \\<Longrightarrow>\\<^sub>A B\"\n  shows \"A \\<Longrightarrow>\\<^sub>A B\"", "lemma invalid_assn_const: \n  \"invalid_assn (\\<lambda>_ _. P) x y = \\<up>(vassn_tag P) * true\"", "lemma vassn_tag_simps[simp]: \n  \"vassn_tag emp\"\n  \"vassn_tag true\"", "lemma is_GEN_ALGO: \"GEN_ALGO f \\<Phi> \\<Longrightarrow> GEN_ALGO f \\<Phi>\"", "lemma RPREMI: \"P \\<Longrightarrow> RPREM P\"", "lemma trans_frame_rule:\n  assumes \"RECOVER_PURE \\<Gamma> \\<Gamma>'\"\n  assumes \"vassn_tag \\<Gamma>' \\<Longrightarrow> hn_refine \\<Gamma>' c \\<Gamma>'' R a\"\n  shows \"hn_refine (F*\\<Gamma>) c (F*\\<Gamma>'') R a\"", "lemma recover_pure_cons: \\<comment> \\<open>Used for debugging\\<close>\n  assumes \"RECOVER_PURE \\<Gamma> \\<Gamma>'\"\n  assumes \"hn_refine \\<Gamma>' c \\<Gamma>'' R a\"\n  shows \"hn_refine (\\<Gamma>) c (\\<Gamma>'') R a\"", "lemma CPR_TAG_starI:\n  assumes \"CPR_TAG P1 Q1\"\n  assumes \"CPR_TAG P2 Q2\"\n  shows \"CPR_TAG (P1*P2) (Q1*Q2)\"", "lemma CPR_tag_ctxtI: \"CPR_TAG (hn_ctxt R x xi) (hn_ctxt R' x xi)\"", "lemma CPR_tag_fallbackI: \"CPR_TAG P Q\"", "lemmas CPR_TAG_rules = CPR_TAG_starI CPR_tag_ctxtI CPR_tag_fallbackI", "lemma cons_pre_rule: \\<comment> \\<open>Consequence rule to be applied if no direct operation rule matches\\<close>\n  assumes \"CPR_TAG P P'\"\n  assumes \"P \\<Longrightarrow>\\<^sub>t P'\"\n  assumes \"hn_refine P' c Q R m\"\n  shows \"hn_refine P c Q R m\"", "lemma hn_pass[sepref_fr_rules]:\n  shows \"hn_refine (hn_ctxt P x x') (return x') (hn_invalid P x x') P (PASS$x)\"", "lemma hn_bind[sepref_comb_rules]:\n  assumes D1: \"hn_refine \\<Gamma> m' \\<Gamma>1 Rh m\"\n  assumes D2: \n    \"\\<And>x x'. bind_ref_tag x m \\<Longrightarrow> \n      hn_refine (\\<Gamma>1 * hn_ctxt Rh x x') (f' x') (\\<Gamma>2 x x') R (f x)\"\n  assumes IMP: \"\\<And>x x'. \\<Gamma>2 x x' \\<Longrightarrow>\\<^sub>t \\<Gamma>' * hn_ctxt Rx x x'\"\n  shows \"hn_refine \\<Gamma> (m'\\<bind>f') \\<Gamma>' R (Refine_Basic.bind$m$(\\<lambda>\\<^sub>2x. f x))\"", "lemma hn_RECT'[sepref_comb_rules]:\n  assumes \"INDEP Ry\" \"INDEP Rx\" \"INDEP Rx'\"\n  assumes FR: \"P \\<Longrightarrow>\\<^sub>t hn_ctxt Rx ax px * F\"\n  assumes S: \"\\<And>cf af ax px. \\<lbrakk>\n    \\<And>ax px. hn_refine (hn_ctxt Rx ax px * F) (cf px) (hn_ctxt Rx' ax px * F) Ry \n      (RCALL$af$ax)\\<rbrakk> \n    \\<Longrightarrow> hn_refine (hn_ctxt Rx ax px * F) (cB cf px) (F' ax px) Ry \n          (aB af ax)\"\n  assumes FR': \"\\<And>ax px. F' ax px \\<Longrightarrow>\\<^sub>t hn_ctxt Rx' ax px * F\"\n  assumes M: \"(\\<And>x. mono_Heap (\\<lambda>f. cB f x))\"\n  (*assumes PREC[unfolded CONSTRAINT_def]: \"CONSTRAINT precise Ry\"*)\n  shows \"hn_refine \n    (P) (heap.fixp_fun cB px) (hn_ctxt Rx' ax px * F) Ry \n        (RECT$(\\<lambda>\\<^sub>2D x. aB D x)$ax)\"", "lemma hn_RCALL[sepref_comb_rules]:\n  assumes \"RPREM (hn_refine P' c Q' R (RCALL $ a $ b))\"\n    and \"P \\<Longrightarrow>\\<^sub>t F * P'\"\n  shows \"hn_refine P c (F * Q') R (RCALL $ a $ b)\"", "lemma heap_WHILET_unfold[code]: \"heap_WHILET b f s = \n  do {\n    bv \\<leftarrow> b s;\n    if bv then do {\n      s \\<leftarrow> f s;\n      heap_WHILET b f s\n    } else\n      return s\n  }\"", "lemma WHILEIT_to_monadic: \"WHILEIT I b f s = monadic_WHILEIT I (\\<lambda>s. RETURN (b s)) f s\"", "lemma WHILEIT_pat[def_pat_rules]:\n  \"WHILEIT$I \\<equiv> UNPROTECT (WHILEIT I)\"\n  \"WHILET \\<equiv> PR_CONST (WHILEIT (\\<lambda>_. True))\"", "lemma id_WHILEIT[id_rules]: \n  \"PR_CONST (WHILEIT I) ::\\<^sub>i TYPE(('a \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> 'a nres) \\<Rightarrow> 'a \\<Rightarrow> 'a nres)\"", "lemma WHILE_arities[sepref_monadify_arity]:\n  (*\"WHILET \\<equiv> WHILEIT$(\\<lambda>\\<^sub>2_. True)\"*)\n  \"PR_CONST (WHILEIT I) \\<equiv> \\<lambda>\\<^sub>2b f s. SP (PR_CONST (WHILEIT I))$(\\<lambda>\\<^sub>2s. b$s)$(\\<lambda>\\<^sub>2s. f$s)$s\"", "lemma WHILEIT_comb[sepref_monadify_comb]:\n  \"PR_CONST (WHILEIT I)$(\\<lambda>\\<^sub>2x. b x)$f$s \\<equiv> \n    Refine_Basic.bind$(EVAL$s)$(\\<lambda>\\<^sub>2s. \n      SP (PR_CONST (monadic_WHILEIT I))$(\\<lambda>\\<^sub>2x. (EVAL$(b x)))$f$s\n    )\"", "lemma hn_monadic_WHILE_aux:\n  assumes FR: \"P \\<Longrightarrow>\\<^sub>t \\<Gamma> * hn_ctxt Rs s' s\"\n  assumes b_ref: \"\\<And>s s'. I s' \\<Longrightarrow> hn_refine \n    (\\<Gamma> * hn_ctxt Rs s' s)\n    (b s)\n    (\\<Gamma>b s' s)\n    (pure bool_rel)\n    (b' s')\"\n  assumes b_fr: \"\\<And>s' s. \\<Gamma>b s' s \\<Longrightarrow>\\<^sub>t \\<Gamma> * hn_ctxt Rs s' s\"\n\n  assumes f_ref: \"\\<And>s' s. \\<lbrakk>I s'\\<rbrakk> \\<Longrightarrow> hn_refine\n    (\\<Gamma> * hn_ctxt Rs s' s)\n    (f s)\n    (\\<Gamma>f s' s)\n    Rs\n    (f' s')\"\n  assumes f_fr: \"\\<And>s' s. \\<Gamma>f s' s \\<Longrightarrow>\\<^sub>t \\<Gamma> * hn_ctxt (\\<lambda>_ _. true) s' s\"\n  (*assumes PREC: \"precise Rs\"*)\n  shows \"hn_refine (P) (heap_WHILET b f s) (\\<Gamma> * hn_invalid Rs s' s) Rs (monadic_WHILEIT I b' f' s')\"", "lemma hn_monadic_WHILE_lin[sepref_comb_rules]:\n  assumes \"INDEP Rs\"\n  assumes FR: \"P \\<Longrightarrow>\\<^sub>t \\<Gamma> * hn_ctxt Rs s' s\"\n  assumes b_ref: \"\\<And>s s'. I s' \\<Longrightarrow> hn_refine \n    (\\<Gamma> * hn_ctxt Rs s' s)\n    (b s)\n    (\\<Gamma>b s' s)\n    (pure bool_rel)\n    (b' s')\"\n  assumes b_fr: \"\\<And>s' s. TERM (monadic_WHILEIT,''cond'') \\<Longrightarrow> \\<Gamma>b s' s \\<Longrightarrow>\\<^sub>t \\<Gamma> * hn_ctxt Rs s' s\"\n\n  assumes f_ref: \"\\<And>s' s. I s' \\<Longrightarrow> hn_refine\n    (\\<Gamma> * hn_ctxt Rs s' s)\n    (f s)\n    (\\<Gamma>f s' s)\n    Rs\n    (f' s')\"\n  assumes f_fr: \"\\<And>s' s. TERM (monadic_WHILEIT,''body'') \\<Longrightarrow> \\<Gamma>f s' s \\<Longrightarrow>\\<^sub>t \\<Gamma> * hn_ctxt (\\<lambda>_ _. true) s' s\"\n  shows \"hn_refine \n    P \n    (heap_WHILET b f s) \n    (\\<Gamma> * hn_invalid Rs s' s) \n    Rs \n    (PR_CONST (monadic_WHILEIT I)$(\\<lambda>\\<^sub>2s'. b' s')$(\\<lambda>\\<^sub>2s'. f' s')$(s'))\"", "lemma monadic_WHILEIT_refine[refine]:  \n  assumes [refine]: \"(s',s) \\<in> R\"\n  assumes [refine]: \"\\<And>s' s. \\<lbrakk> (s',s)\\<in>R; I s \\<rbrakk> \\<Longrightarrow> I' s'\"  \n  assumes [refine]: \"\\<And>s' s. \\<lbrakk> (s',s)\\<in>R; I s; I' s' \\<rbrakk> \\<Longrightarrow> b' s' \\<le>\\<Down>bool_rel (b s)\"\n  assumes [refine]: \"\\<And>s' s. \\<lbrakk> (s',s)\\<in>R; I s; I' s'; nofail (b s); inres (b s) True \\<rbrakk> \\<Longrightarrow> f' s' \\<le>\\<Down>R (f s)\"\n  shows \"monadic_WHILEIT I' b' f' s' \\<le>\\<Down>R (monadic_WHILEIT I b f s)\"", "lemma monadic_WHILEIT_refine_WHILEIT[refine]:  \n  assumes [refine]: \"(s',s) \\<in> R\"\n  assumes [refine]: \"\\<And>s' s. \\<lbrakk> (s',s)\\<in>R; I s \\<rbrakk> \\<Longrightarrow> I' s'\"  \n  assumes [THEN order_trans,refine_vcg]: \"\\<And>s' s. \\<lbrakk> (s',s)\\<in>R; I s; I' s' \\<rbrakk> \\<Longrightarrow> b' s' \\<le> SPEC (\\<lambda>r. r = b s)\"\n  assumes [refine]: \"\\<And>s' s. \\<lbrakk> (s',s)\\<in>R; I s; I' s'; b s \\<rbrakk> \\<Longrightarrow> f' s' \\<le>\\<Down>R (f s)\"\n  shows \"monadic_WHILEIT I' b' f' s' \\<le>\\<Down>R (WHILEIT I b f s)\"", "lemma monadic_WHILEIT_refine_WHILET[refine]:  \n  assumes [refine]: \"(s',s) \\<in> R\"\n  assumes [THEN order_trans,refine_vcg]: \"\\<And>s' s. \\<lbrakk> (s',s)\\<in>R \\<rbrakk> \\<Longrightarrow> b' s' \\<le> SPEC (\\<lambda>r. r = b s)\"\n  assumes [refine]: \"\\<And>s' s. \\<lbrakk> (s',s)\\<in>R; b s \\<rbrakk> \\<Longrightarrow> f' s' \\<le>\\<Down>R (f s)\"\n  shows \"monadic_WHILEIT (\\<lambda>_. True) b' f' s' \\<le>\\<Down>R (WHILET b f s)\"", "lemma monadic_WHILEIT_pat[def_pat_rules]:\n  \"monadic_WHILEIT$I \\<equiv> UNPROTECT (monadic_WHILEIT I)\"", "lemma id_monadic_WHILEIT[id_rules]: \n  \"PR_CONST (monadic_WHILEIT I) ::\\<^sub>i TYPE(('a \\<Rightarrow> bool nres) \\<Rightarrow> ('a \\<Rightarrow> 'a nres) \\<Rightarrow> 'a \\<Rightarrow> 'a nres)\"", "lemma monadic_WHILEIT_arities[sepref_monadify_arity]:\n  \"PR_CONST (monadic_WHILEIT I) \\<equiv> \\<lambda>\\<^sub>2b f s. SP (PR_CONST (monadic_WHILEIT I))$(\\<lambda>\\<^sub>2s. b$s)$(\\<lambda>\\<^sub>2s. f$s)$s\"", "lemma monadic_WHILEIT_comb[sepref_monadify_comb]:\n  \"PR_CONST (monadic_WHILEIT I)$b$f$s \\<equiv> \n    Refine_Basic.bind$(EVAL$s)$(\\<lambda>\\<^sub>2s. \n      SP (PR_CONST (monadic_WHILEIT I))$b$f$s\n    )\"", "lemma pat_ASSERT_bind[def_pat_rules]:\n  \"Refine_Basic.bind$(ASSERT$I)$(\\<lambda>\\<^sub>2_. m) \\<equiv> UNPROTECT (op_ASSERT_bind I)$m\"", "lemma id_op_ASSERT_bind[id_rules]: \n  \"PR_CONST (op_ASSERT_bind I) ::\\<^sub>i TYPE('a nres \\<Rightarrow> 'a nres)\"", "lemma arity_ASSERT_bind[sepref_monadify_arity]:\n  \"PR_CONST (op_ASSERT_bind I) \\<equiv> \\<lambda>\\<^sub>2m. SP (PR_CONST (op_ASSERT_bind I))$m\"", "lemma hn_ASSERT_bind[sepref_comb_rules]: \n  assumes \"I \\<Longrightarrow> hn_refine \\<Gamma> c \\<Gamma>' R m\"\n  shows \"hn_refine \\<Gamma> c \\<Gamma>' R (PR_CONST (op_ASSERT_bind I)$m)\"", "lemma pat_ASSUME_bind[def_pat_rules]:\n  \"Refine_Basic.bind$(ASSUME$I)$(\\<lambda>\\<^sub>2_. m) \\<equiv> UNPROTECT (op_ASSUME_bind I)$m\"", "lemma id_op_ASSUME_bind[id_rules]: \n  \"PR_CONST (op_ASSUME_bind I) ::\\<^sub>i TYPE('a nres \\<Rightarrow> 'a nres)\"", "lemma arity_ASSUME_bind[sepref_monadify_arity]:\n  \"PR_CONST (op_ASSUME_bind I) \\<equiv> \\<lambda>\\<^sub>2m. SP (PR_CONST (op_ASSUME_bind I))$m\"", "lemma hn_ASSUME_bind[sepref_comb_rules]: \n  assumes \"vassn_tag \\<Gamma> \\<Longrightarrow> I\"\n  assumes \"I \\<Longrightarrow> hn_refine \\<Gamma> c \\<Gamma>' R m\"\n  shows \"hn_refine \\<Gamma> c \\<Gamma>' R (PR_CONST (op_ASSUME_bind I)$m)\"", "lemma pure_hn_refineI:\n  assumes \"Q \\<longrightarrow> (c,a)\\<in>R\"\n  shows \"hn_refine (\\<up>Q) (return c) (\\<up>Q) (pure R) (RETURN a)\"", "lemma pure_hn_refineI_no_asm:\n  assumes \"(c,a)\\<in>R\"\n  shows \"hn_refine emp (return c) emp (pure R) (RETURN a)\"", "lemma import_param_0:\n  \"(P\\<Longrightarrow>Q) \\<equiv> Trueprop (PROTECT P \\<longrightarrow> Q)\"", "lemma import_param_1: \n  \"(P\\<Longrightarrow>Q) \\<equiv> Trueprop (P\\<longrightarrow>Q)\"\n  \"(P\\<longrightarrow>Q\\<longrightarrow>R) \\<longleftrightarrow> (P\\<and>Q \\<longrightarrow> R)\"\n  \"PROTECT (P \\<and> Q) \\<equiv> PROTECT P \\<and> PROTECT Q\"\n  \"(P \\<and> Q) \\<and> R \\<equiv> P \\<and> Q \\<and> R\"\n  \"(a,c)\\<in>Rel \\<and> PROTECT P \\<longleftrightarrow> PROTECT P \\<and> (a,c)\\<in>Rel\"", "lemma import_param_2:\n  \"Trueprop (PROTECT P \\<and> Q \\<longrightarrow> R) \\<equiv> (P \\<Longrightarrow> Q\\<longrightarrow>R)\"", "lemma import_param_3:\n  \"\\<up>(P \\<and> Q) = \\<up>P*\\<up>Q\"\n  \"\\<up>((c,a)\\<in>R) = hn_val R a c\"", "lemma to_import_frefD: \n  assumes \"(f,g)\\<in>fref P R S\"\n  shows \"\\<lbrakk>PROTECT (P y); (x,y)\\<in>R\\<rbrakk> \\<Longrightarrow> (f x, g y)\\<in>S\"", "lemma add_PR_CONST: \"(c,a)\\<in>R \\<Longrightarrow> (c,PR_CONST a)\\<in>R\"", "lemma import_rel1_pure_conv: \"import_rel1 R (pure A) = pure (\\<langle>A\\<rangle>R)\"", "lemma import_rel2_pure_conv: \"import_rel2 R (pure A) (pure B) = pure (\\<langle>A,B\\<rangle>R)\"", "lemma precise_pure[constraint_rules]: \"single_valued R \\<Longrightarrow> precise (pure R)\"", "lemma precise_pure_iff_sv: \"precise (pure R) \\<longleftrightarrow> single_valued R\"", "lemma pure_precise_iff_sv: \"\\<lbrakk>is_pure R\\<rbrakk> \n  \\<Longrightarrow> precise R \\<longleftrightarrow> single_valued (the_pure R)\"", "lemmas [safe_constraint_rules] = single_valued_Id br_sv"], "translations": [["", "lemma vassn_tagI: \"h\\<Turnstile>\\<Gamma> \\<Longrightarrow> vassn_tag \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<Turnstile> \\<Gamma> \\<Longrightarrow> vassn_tag \\<Gamma>", "unfolding vassn_tag_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<Turnstile> \\<Gamma> \\<Longrightarrow>\n    \\<exists>h. h \\<Turnstile> \\<Gamma>", ".."], ["", "lemma vassn_dest[dest!]:\n  \"vassn_tag (\\<Gamma>\\<^sub>1 * \\<Gamma>\\<^sub>2) \\<Longrightarrow> vassn_tag \\<Gamma>\\<^sub>1 \\<and> vassn_tag \\<Gamma>\\<^sub>2\"\n  \"vassn_tag (hn_ctxt R a b) \\<Longrightarrow> a\\<in>rdom R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (vassn_tag (\\<Gamma>\\<^sub>1 * \\<Gamma>\\<^sub>2) \\<Longrightarrow>\n     vassn_tag \\<Gamma>\\<^sub>1 \\<and> vassn_tag \\<Gamma>\\<^sub>2) &&&\n    (vassn_tag (hn_ctxt R a b) \\<Longrightarrow> a \\<in> rdom R)", "unfolding vassn_tag_def rdomp_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>h.\n        h \\<Turnstile> \\<Gamma>\\<^sub>1 * \\<Gamma>\\<^sub>2 \\<Longrightarrow>\n     (\\<exists>h. h \\<Turnstile> \\<Gamma>\\<^sub>1) \\<and>\n     (\\<exists>h. h \\<Turnstile> \\<Gamma>\\<^sub>2)) &&&\n    (\\<exists>h. h \\<Turnstile> hn_ctxt R a b \\<Longrightarrow>\n     a \\<in> {a. \\<exists>h c. h \\<Turnstile> R a c})", "by (auto simp: mod_star_conv hn_ctxt_def)"], ["", "lemma entails_preI:\n  assumes \"vassn_tag A \\<Longrightarrow> A \\<Longrightarrow>\\<^sub>A B\"\n  shows \"A \\<Longrightarrow>\\<^sub>A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<Longrightarrow>\\<^sub>A B", "using assms"], ["proof (prove)\nusing this:\n  vassn_tag A \\<Longrightarrow> A \\<Longrightarrow>\\<^sub>A B\n\ngoal (1 subgoal):\n 1. A \\<Longrightarrow>\\<^sub>A B", "by (auto simp: entails_def vassn_tag_def)"], ["", "lemma invalid_assn_const: \n  \"invalid_assn (\\<lambda>_ _. P) x y = \\<up>(vassn_tag P) * true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invalid_assn (\\<lambda>_ _. P) x y = \\<up> (vassn_tag P) * true", "by (simp_all add: invalid_assn_def vassn_tag_def)"], ["", "lemma vassn_tag_simps[simp]: \n  \"vassn_tag emp\"\n  \"vassn_tag true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vassn_tag emp &&& vassn_tag true", "by (sep_auto simp: vassn_tag_def mod_emp)+"], ["", "definition \"GEN_ALGO f \\<Phi> \\<equiv> \\<Phi> f\"\n\\<comment> \\<open>Tag to synthesize @{term f} with property @{term \\<Phi>}.\\<close>"], ["", "lemma is_GEN_ALGO: \"GEN_ALGO f \\<Phi> \\<Longrightarrow> GEN_ALGO f \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GEN_ALGO f \\<Phi> \\<Longrightarrow> GEN_ALGO f \\<Phi>", "."], ["", "text \\<open>Tag for side-condition solver to discharge by assumption\\<close>"], ["", "definition RPREM :: \"bool \\<Rightarrow> bool\" where [simp]: \"RPREM P = P\""], ["", "lemma RPREMI: \"P \\<Longrightarrow> RPREM P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<Longrightarrow> RPREM P", "by simp"], ["", "lemma trans_frame_rule:\n  assumes \"RECOVER_PURE \\<Gamma> \\<Gamma>'\"\n  assumes \"vassn_tag \\<Gamma>' \\<Longrightarrow> hn_refine \\<Gamma>' c \\<Gamma>'' R a\"\n  shows \"hn_refine (F*\\<Gamma>) c (F*\\<Gamma>'') R a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (F * \\<Gamma>) c (F * \\<Gamma>'') R a", "apply (rule hn_refine_frame[OF _ entt_refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine \\<Gamma> c \\<Gamma>'' R a", "applyF (rule hn_refine_cons_pre)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<Gamma> \\<Longrightarrow>\\<^sub>t ?P'5\n 2. hn_refine ?P'5 c \\<Gamma>'' R a", "focus"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<Longrightarrow>\\<^sub>t ?P'5", "using assms(1)"], ["proof (prove)\nusing this:\n  RECOVER_PURE \\<Gamma> \\<Gamma>'\n\ngoal (1 subgoal):\n 1. \\<Gamma> \\<Longrightarrow>\\<^sub>t ?P'5", "unfolding RECOVER_PURE_def"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<Longrightarrow>\\<^sub>t \\<Gamma>'\n\ngoal (1 subgoal):\n 1. \\<Gamma> \\<Longrightarrow>\\<^sub>t ?P'5", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "solved"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine \\<Gamma>' c \\<Gamma>'' R a", "apply1 (rule hn_refine_preI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       h \\<Turnstile> \\<Gamma>' \\<Longrightarrow>\n       hn_refine \\<Gamma>' c \\<Gamma>'' R a", "apply1 (rule assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h. h \\<Turnstile> \\<Gamma>' \\<Longrightarrow> vassn_tag \\<Gamma>'", "applyS (auto simp add: vassn_tag_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "solved"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma recover_pure_cons: \\<comment> \\<open>Used for debugging\\<close>\n  assumes \"RECOVER_PURE \\<Gamma> \\<Gamma>'\"\n  assumes \"hn_refine \\<Gamma>' c \\<Gamma>'' R a\"\n  shows \"hn_refine (\\<Gamma>) c (\\<Gamma>'') R a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine \\<Gamma> c \\<Gamma>'' R a", "using trans_frame_rule[where F=emp, OF assms]"], ["proof (prove)\nusing this:\n  hn_refine (emp * \\<Gamma>) c (emp * \\<Gamma>'') R a\n\ngoal (1 subgoal):\n 1. hn_refine \\<Gamma> c \\<Gamma>'' R a", "by simp\n\n\n\\<comment> \\<open>Tag to align structure of refinement assertions for consequence rule\\<close>"], ["", "definition CPR_TAG :: \"assn \\<Rightarrow> assn \\<Rightarrow> bool\" where [simp]: \"CPR_TAG y x \\<equiv> True\""], ["", "lemma CPR_TAG_starI:\n  assumes \"CPR_TAG P1 Q1\"\n  assumes \"CPR_TAG P2 Q2\"\n  shows \"CPR_TAG (P1*P2) (Q1*Q2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CPR_TAG (P1 * P2) (Q1 * Q2)", "by simp"], ["", "lemma CPR_tag_ctxtI: \"CPR_TAG (hn_ctxt R x xi) (hn_ctxt R' x xi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CPR_TAG (hn_ctxt R x xi) (hn_ctxt R' x xi)", "by simp"], ["", "lemma CPR_tag_fallbackI: \"CPR_TAG P Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CPR_TAG P Q", "by simp"], ["", "lemmas CPR_TAG_rules = CPR_TAG_starI CPR_tag_ctxtI CPR_tag_fallbackI"], ["", "lemma cons_pre_rule: \\<comment> \\<open>Consequence rule to be applied if no direct operation rule matches\\<close>\n  assumes \"CPR_TAG P P'\"\n  assumes \"P \\<Longrightarrow>\\<^sub>t P'\"\n  assumes \"hn_refine P' c Q R m\"\n  shows \"hn_refine P c Q R m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine P c Q R m", "using assms(2-)"], ["proof (prove)\nusing this:\n  P \\<Longrightarrow>\\<^sub>t P'\n  hn_refine P' c Q R m\n\ngoal (1 subgoal):\n 1. hn_refine P c Q R m", "by (rule hn_refine_cons_pre)"], ["", "named_theorems_rev sepref_gen_algo_rules \\<open>Sepref: Generic algorithm rules\\<close>"], ["", "ML \\<open>\n\nstructure Sepref_Translate = struct\n\n  val cfg_debug = \n    Attrib.setup_config_bool @{binding sepref_debug_translate} (K false)\n  \n  val dbg_msg_tac = Sepref_Debugging.dbg_msg_tac cfg_debug  \n\n  fun gen_msg_analyze t ctxt = let\n    val t = Logic.strip_assums_concl t\n  in\n    case t of\n      @{mpat \"Trueprop ?t\"} => (case t of\n            @{mpat \"_ \\<or>\\<^sub>A _ \\<Longrightarrow>\\<^sub>t _\"} => \"t_merge\"\n          | @{mpat \"_ \\<Longrightarrow>\\<^sub>t _\"} => \"t_frame\"\n          | @{mpat \"INDEP _\"} => \"t_indep\"\n          | @{mpat \"CONSTRAINT _ _\"} => \"t_constraint\"\n          | @{mpat \"mono_Heap _\"} => \"t_mono\"\n          | @{mpat \"PREFER_tag _\"} => \"t_prefer\"\n          | @{mpat \"DEFER_tag _\"} => \"t_defer\"\n          | @{mpat \"RPREM _\"} => \"t_rprem\" \n          | @{mpat \"hn_refine _ _ _ _ ?a\"} => Pretty.block [Pretty.str \"t_hnr: \",Pretty.brk 1, Syntax.pretty_term ctxt a] |> Pretty.string_of \n          | _ => \"Unknown goal type\"\n        )\n    | _ => \"Non-Trueprop goal\"\n  end  \n\n  fun msg_analyze msg = Sepref_Debugging.msg_from_subgoal msg gen_msg_analyze\n\n  fun check_side_conds thm = let\n    open Sepref_Basic\n    (* Check that term is no binary operator on assertions *)\n    fun is_atomic (Const (_,@{typ \"assn\\<Rightarrow>assn\\<Rightarrow>assn\"})$_$_) = false\n      | is_atomic _ = true\n\n    val is_atomic_star_list = (\"Expected atoms separated by star\",forall is_atomic o strip_star)\n\n    val is_trueprop = (\"Expected Trueprop conclusion\",can HOLogic.dest_Trueprop)\n\n    fun assert t' (msg,p) t = if p t then () else raise TERM(msg,[t',t])\n\n    fun chk_prem t = let\n      val assert = assert t\n      \n      fun chk @{mpat \"?l \\<or>\\<^sub>A ?r \\<Longrightarrow>\\<^sub>t ?m\"} = (\n            assert is_atomic_star_list l;\n            assert is_atomic_star_list r;\n            assert is_atomic_star_list m\n          )\n        | chk (t as @{mpat \"_ \\<Longrightarrow>\\<^sub>A _\"}) = raise TERM(\"Invalid frame side condition (old-style ent)\",[t])\n        | chk @{mpat \"?l \\<Longrightarrow>\\<^sub>t ?r\"} = (\n            assert is_atomic_star_list l;\n            assert is_atomic_star_list r\n          )\n        | chk _ = ()  \n\n      val t = Logic.strip_assums_concl t \n    in\n      assert is_trueprop t;\n      chk (HOLogic.dest_Trueprop t)\n    end    \n\n  in\n    map chk_prem (Thm.prems_of thm)\n  end\n\n  structure sepref_comb_rules = Named_Sorted_Thms (\n    val name = @{binding \"sepref_comb_rules\"}\n    val description = \"Sepref: Combinator rules\"\n    val sort = K I\n    fun transform _ thm = let\n      val _ = check_side_conds thm  \n    in\n      [thm]\n    end\n  )\n\n  structure sepref_fr_rules = Named_Sorted_Thms (\n    val name = @{binding \"sepref_fr_rules\"}\n    val description = \"Sepref: Frame-based rules\"\n    val sort = K I\n    fun transform context thm = let\n      val ctxt = Context.proof_of context\n      val thm = Sepref_Rules.ensure_hnr ctxt thm\n        |> Conv.fconv_rule (Sepref_Frame.align_rl_conv ctxt)\n\n      val _ = check_side_conds thm  \n      val _ = case try (Sepref_Rules.analyze_hnr ctxt) thm of \n          NONE =>\n            (Pretty.block [\n              Pretty.str \"hnr-analysis failed\", \n              Pretty.str \":\", \n              Pretty.brk 1, \n              Thm.pretty_thm ctxt thm])\n            |> Pretty.string_of |> error  \n        | SOME ana => let\n            val _ = Sepref_Combinator_Setup.is_valid_abs_op ctxt (fst (#ahead ana))\n              orelse Pretty.block [\n                Pretty.str \"Invalid abstract head:\",\n                Pretty.brk 1,\n                Pretty.enclose \"(\" \")\" [Syntax.pretty_term ctxt (fst (#ahead ana))],\n                Pretty.brk 1,\n                Pretty.str \"in thm\",\n                Pretty.brk 1,\n                Thm.pretty_thm ctxt thm                \n              ]\n            |> Pretty.string_of |> error  \n          in () end\n    in\n      [thm]\n    end\n  )\n\n  (***** Side Condition Solving *)\n  local\n    open Sepref_Basic\n  in\n  \n    fun side_unfold_tac ctxt = let\n      (*val ctxt = put_simpset HOL_basic_ss ctxt\n        addsimps sepref_prep_side_simps.get ctxt*)\n    in\n      CONVERSION (Id_Op.unprotect_conv ctxt)\n      THEN' SELECT_GOAL (Local_Defs.unfold0_tac ctxt @{thms bind_ref_tag_def})\n      (*THEN' asm_full_simp_tac ctxt*)\n    end\n  \n    fun side_fallback_tac ctxt = side_unfold_tac ctxt THEN' TRADE (SELECT_GOAL o auto_tac) ctxt\n  \n    val side_frame_tac = Sepref_Frame.frame_tac side_fallback_tac\n    val side_merge_tac = Sepref_Frame.merge_tac side_fallback_tac\n    fun side_constraint_tac ctxt = Sepref_Constraints.constraint_tac ctxt\n    fun side_mono_tac ctxt = side_unfold_tac ctxt THEN' TRADE Pf_Mono_Prover.mono_tac ctxt\n  \n    fun side_gen_algo_tac ctxt = \n      side_unfold_tac ctxt\n      THEN' resolve_tac ctxt (Named_Theorems_Rev.get ctxt @{named_theorems_rev sepref_gen_algo_rules})\n  \n    fun side_pref_def_tac ctxt = \n      side_unfold_tac ctxt THEN' \n      TRADE (fn ctxt => \n        resolve_tac ctxt @{thms PREFER_tagI DEFER_tagI} \n        THEN' (Sepref_Debugging.warning_tac' \"Obsolete PREFER/DEFER side condition\" ctxt THEN' Tagged_Solver.solve_tac ctxt)\n      ) ctxt\n\n\n    fun side_rprem_tac ctxt = \n      resolve_tac ctxt @{thms RPREMI} THEN' Refine_Util.rprems_tac ctxt\n      THEN' (K (smash_new_rule ctxt))\n\n    (*\n      Solve side condition, or invoke hnr_tac on hn_refine goal.\n\n      In debug mode, side-condition solvers are allowed to not completely solve \n      the side condition, but must change the goal.\n    *)  \n    fun side_cond_dispatch_tac dbg hnr_tac ctxt = let\n      fun MK tac = if dbg then CHANGED o tac ctxt else SOLVED' (tac ctxt)\n\n      val t_merge = MK side_merge_tac\n      val t_frame = MK side_frame_tac\n      val t_indep = MK Indep_Vars.indep_tac\n      val t_constraint = MK side_constraint_tac\n      val t_mono = MK side_mono_tac\n      val t_pref_def = MK side_pref_def_tac\n      val t_rprem = MK side_rprem_tac\n      val t_gen_algo = side_gen_algo_tac ctxt\n      val t_fallback = MK side_fallback_tac\n    in\n      WITH_concl \n        (fn @{mpat \"Trueprop ?t\"} => (case t of\n              @{mpat \"_ \\<or>\\<^sub>A _ \\<Longrightarrow>\\<^sub>t _\"} => t_merge\n            | @{mpat \"_ \\<Longrightarrow>\\<^sub>t _\"} => t_frame\n            | @{mpat \"_ \\<Longrightarrow>\\<^sub>A _\"} => Sepref_Debugging.warning_tac' \"Old-style frame side condition\" ctxt THEN' (K no_tac)\n            | @{mpat \"INDEP _\"} => t_indep     (* TODO: Get rid of this!? *)\n            | @{mpat \"CONSTRAINT _ _\"} => t_constraint\n            | @{mpat \"mono_Heap _\"} => t_mono\n            | @{mpat \"PREFER_tag _\"} => t_pref_def\n            | @{mpat \"DEFER_tag _\"} => t_pref_def\n            | @{mpat \"RPREM _\"} => t_rprem\n            | @{mpat \"GEN_ALGO _ _\"} => t_gen_algo\n            | @{mpat \"hn_refine _ _ _ _ _\"} => hnr_tac \n            | _ => t_fallback\n          )\n        | _ => K no_tac  \n      )\n    end\n\n  end  \n\n  (***** Main Translation Tactic *)\n  local\n    open Sepref_Basic STactical\n\n    (* ATTENTION: Beware of evaluation order, as some initialization operations on\n      context are expensive, and should not be repeated during proof search! *)\n  in\n\n\n    (* Translate combinator, yields new translation goals and side conditions\n      which must be processed in order. *)\n    fun trans_comb_tac ctxt = let\n      val comb_rl_net = sepref_comb_rules.get ctxt\n        |> Tactic.build_net\n\n    in\n      DETERM o (\n        resolve_from_net_tac ctxt comb_rl_net \n        ORELSE' ( \n          Sepref_Frame.norm_goal_pre_tac ctxt \n          THEN' resolve_from_net_tac ctxt comb_rl_net\n        )\n      )\n    end\n\n    (* Translate operator. Only succeeds if it finds an operator rule such that\n      all resulting side conditions can be solved. Takes the first such rule.\n\n      In debug mode, it returns a sequence of the unsolved side conditions of\n      each applicable rule.\n    *)\n    fun gen_trans_op_tac dbg ctxt = let\n      val fr_rl_net = sepref_fr_rules.get ctxt |> Tactic.build_net\n      val fr_rl_tac = \n        resolve_from_net_tac ctxt fr_rl_net (* Try direct match *)\n        ORELSE' (\n          Sepref_Frame.norm_goal_pre_tac ctxt (* Normalize precondition *) \n          THEN' (\n            resolve_from_net_tac ctxt fr_rl_net\n            ORELSE' (\n              resolve_tac ctxt @{thms cons_pre_rule} (* Finally, generate a frame condition *)\n              THEN_ALL_NEW_LIST [\n                SOLVED' (REPEAT_ALL_NEW_FWD (DETERM o resolve_tac ctxt @{thms CPR_TAG_rules})),\n                K all_tac,  (* Frame remains unchanged as first goal, even if fr_rl creates side-conditions *)\n                resolve_from_net_tac ctxt fr_rl_net\n              ]\n            )\n          )  \n        )\n      \n      val side_tac = REPEAT_ALL_NEW_FWD (side_cond_dispatch_tac false (K no_tac) ctxt)\n\n      val fr_tac = \n        if dbg then (* Present all possibilities with (partially resolved) side conditions *)\n          fr_rl_tac THEN_ALL_NEW_FWD (TRY o side_tac)\n        else (* Choose first rule that solves all side conditions *)\n          DETERM o SOLVED' (fr_rl_tac THEN_ALL_NEW_FWD (SOLVED' side_tac))\n\n    in\n      PHASES' [\n        (\"Align goal\",Sepref_Frame.align_goal_tac, 0),\n        (\"Frame rule\",fn ctxt => resolve_tac ctxt @{thms trans_frame_rule}, 1),\n        (* RECOVER_PURE goal *)\n        (\"Recover pure\",Sepref_Frame.recover_pure_tac, ~1),\n        (* hn-refine goal with stripped precondition *)\n        (\"Apply rule\",K fr_tac,~1)\n      ] (flag_phases_ctrl dbg) ctxt\n    end\n\n    (* Translate combinator, operator, or side condition. *)\n    fun gen_trans_step_tac dbg ctxt = side_cond_dispatch_tac dbg\n      (trans_comb_tac ctxt ORELSE' gen_trans_op_tac dbg ctxt)\n      ctxt\n\n    val trans_step_tac = gen_trans_step_tac false  \n    val trans_step_keep_tac = gen_trans_step_tac true\n\n    fun gen_trans_tac dbg ctxt = \n      PHASES' [\n        (\"Translation steps\",REPEAT_DETERM' o trans_step_tac,~1),\n        (\"Constraint solving\",fn ctxt => fn _ => Sepref_Constraints.process_constraint_slot ctxt, 0)\n      ] (flag_phases_ctrl dbg) ctxt\n\n    val trans_tac = gen_trans_tac false  \n    val trans_keep_tac = gen_trans_tac true\n\n\n  end\n\n\n  val setup = I\n    #> sepref_fr_rules.setup\n    #> sepref_comb_rules.setup\n\n\nend\n\n\\<close>"], ["", "setup Sepref_Translate.setup"], ["", "subsubsection \\<open>Basic Setup\\<close>"], ["", "lemma hn_pass[sepref_fr_rules]:\n  shows \"hn_refine (hn_ctxt P x x') (return x') (hn_invalid P x x') P (PASS$x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt P x x') (return x') (hn_invalid P x x') P (PASS $ x)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (PASS $ x) \\<Longrightarrow>\n    <hn_ctxt P x\n      x'> return\n           x' <\\<lambda>r.\n                  hn_invalid P x x' *\n                  (\\<exists>\\<^sub>Axa.\n                      P xa r * \\<up> (RETURN xa \\<le> PASS $ x))>\\<^sub>t", "apply (sep_auto simp: hn_ctxt_def invalidate_clone')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*lemma hn_pass_pure[sepref_fr_rules]:\n  shows \"hn_refine (hn_val P x x') (return x') (hn_val P x x') (pure P) (PASS$x)\"\n  by rule (sep_auto simp: hn_ctxt_def pure_def)\n*)"], ["", "lemma hn_bind[sepref_comb_rules]:\n  assumes D1: \"hn_refine \\<Gamma> m' \\<Gamma>1 Rh m\"\n  assumes D2: \n    \"\\<And>x x'. bind_ref_tag x m \\<Longrightarrow> \n      hn_refine (\\<Gamma>1 * hn_ctxt Rh x x') (f' x') (\\<Gamma>2 x x') R (f x)\"\n  assumes IMP: \"\\<And>x x'. \\<Gamma>2 x x' \\<Longrightarrow>\\<^sub>t \\<Gamma>' * hn_ctxt Rx x x'\"\n  shows \"hn_refine \\<Gamma> (m'\\<bind>f') \\<Gamma>' R (Refine_Basic.bind$m$(\\<lambda>\\<^sub>2x. f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine \\<Gamma> (m' \\<bind> f') \\<Gamma>' R\n     ((\\<bind>) $ m $ (\\<lambda>x. (#f x#)))", "using assms"], ["proof (prove)\nusing this:\n  hn_refine \\<Gamma> m' \\<Gamma>1 Rh m\n  bind_ref_tag ?x m \\<Longrightarrow>\n  hn_refine (\\<Gamma>1 * hn_ctxt Rh ?x ?x') (f' ?x') (\\<Gamma>2 ?x ?x') R\n   (f ?x)\n  \\<Gamma>2 ?x ?x' \\<Longrightarrow>\\<^sub>t \\<Gamma>' * hn_ctxt Rx ?x ?x'\n\ngoal (1 subgoal):\n 1. hn_refine \\<Gamma> (m' \\<bind> f') \\<Gamma>' R\n     ((\\<bind>) $ m $ (\\<lambda>x. (#f x#)))", "unfolding APP_def PROTECT2_def bind_ref_tag_def"], ["proof (prove)\nusing this:\n  hn_refine \\<Gamma> m' \\<Gamma>1 Rh m\n  RETURN ?x \\<le> m \\<Longrightarrow>\n  hn_refine (\\<Gamma>1 * hn_ctxt Rh ?x ?x') (f' ?x') (\\<Gamma>2 ?x ?x') R\n   (f ?x)\n  \\<Gamma>2 ?x ?x' \\<Longrightarrow>\\<^sub>t \\<Gamma>' * hn_ctxt Rx ?x ?x'\n\ngoal (1 subgoal):\n 1. hn_refine \\<Gamma> (m' \\<bind> f') \\<Gamma>' R (m \\<bind> f)", "by (rule hnr_bind)"], ["", "lemma hn_RECT'[sepref_comb_rules]:\n  assumes \"INDEP Ry\" \"INDEP Rx\" \"INDEP Rx'\"\n  assumes FR: \"P \\<Longrightarrow>\\<^sub>t hn_ctxt Rx ax px * F\"\n  assumes S: \"\\<And>cf af ax px. \\<lbrakk>\n    \\<And>ax px. hn_refine (hn_ctxt Rx ax px * F) (cf px) (hn_ctxt Rx' ax px * F) Ry \n      (RCALL$af$ax)\\<rbrakk> \n    \\<Longrightarrow> hn_refine (hn_ctxt Rx ax px * F) (cB cf px) (F' ax px) Ry \n          (aB af ax)\"\n  assumes FR': \"\\<And>ax px. F' ax px \\<Longrightarrow>\\<^sub>t hn_ctxt Rx' ax px * F\"\n  assumes M: \"(\\<And>x. mono_Heap (\\<lambda>f. cB f x))\"\n  (*assumes PREC[unfolded CONSTRAINT_def]: \"CONSTRAINT precise Ry\"*)\n  shows \"hn_refine \n    (P) (heap.fixp_fun cB px) (hn_ctxt Rx' ax px * F) Ry \n        (RECT$(\\<lambda>\\<^sub>2D x. aB D x)$ax)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine P (heap.fixp_fun cB px) (hn_ctxt Rx' ax px * F) Ry\n     (REC\\<^sub>T $ (\\<lambda>x. (#\\<lambda>xa. (#aB x xa#)#)) $ ax)", "unfolding APP_def PROTECT2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine P (heap.fixp_fun cB px) (hn_ctxt Rx' ax px * F) Ry\n     (REC\\<^sub>T aB ax)", "apply (rule hn_refine_cons_pre[OF FR])"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt Rx ax px * F) (heap.fixp_fun cB px)\n     (hn_ctxt Rx' ax px * F) Ry (REC\\<^sub>T aB ax)", "apply (rule hnr_RECT)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cf af ax px.\n       (\\<And>ax px.\n           hn_refine (hn_ctxt Rx ax px * F) (cf px) (hn_ctxt Rx' ax px * F)\n            Ry (af ax)) \\<Longrightarrow>\n       hn_refine (hn_ctxt Rx ax px * F) (cB cf px) (hn_ctxt Rx' ax px * F)\n        Ry (aB af ax)\n 2. \\<And>x. mono_Heap (\\<lambda>f. cB f x)", "apply (rule hn_refine_cons_post[OF _ FR'])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cf af ax px.\n       (\\<And>ax px.\n           hn_refine (hn_ctxt Rx ax px * F) (cf px) (hn_ctxt Rx' ax px * F)\n            Ry (af ax)) \\<Longrightarrow>\n       hn_refine (hn_ctxt Rx ax px * F) (cB cf px) (F' ax px) Ry (aB af ax)\n 2. \\<And>x. mono_Heap (\\<lambda>f. cB f x)", "apply (rule S[unfolded RCALL_def APP_def])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cf af ax px axa pxa.\n       (\\<And>ax px.\n           hn_refine (hn_ctxt Rx ax px * F) (cf px) (hn_ctxt Rx' ax px * F)\n            Ry (af ax)) \\<Longrightarrow>\n       hn_refine (hn_ctxt Rx axa pxa * F) (cf pxa) (hn_ctxt Rx' axa pxa * F)\n        Ry (af axa)\n 2. \\<And>x. mono_Heap (\\<lambda>f. cB f x)", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. mono_Heap (\\<lambda>f. cB f x)", "apply fact+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hn_RCALL[sepref_comb_rules]:\n  assumes \"RPREM (hn_refine P' c Q' R (RCALL $ a $ b))\"\n    and \"P \\<Longrightarrow>\\<^sub>t F * P'\"\n  shows \"hn_refine P c (F * Q') R (RCALL $ a $ b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine P c (F * Q') R (RCALL $ a $ b)", "using assms hn_refine_frame[where m=\"RCALL$a$b\"]"], ["proof (prove)\nusing this:\n  RPREM (hn_refine P' c Q' R (RCALL $ a $ b))\n  P \\<Longrightarrow>\\<^sub>t F * P'\n  \\<lbrakk>hn_refine ?P' ?c ?Q' ?R (RCALL $ a $ b);\n   ?P \\<Longrightarrow>\\<^sub>t ?F * ?P'\\<rbrakk>\n  \\<Longrightarrow> hn_refine ?P ?c (?F * ?Q') ?R (RCALL $ a $ b)\n\ngoal (1 subgoal):\n 1. hn_refine P c (F * Q') R (RCALL $ a $ b)", "by simp"], ["", "definition \"monadic_WHILEIT I b f s \\<equiv> do {\n  RECT (\\<lambda>D s. do {\n    ASSERT (I s);\n    bv \\<leftarrow> b s;\n    if bv then do {\n      s \\<leftarrow> f s;\n      D s\n    } else do {RETURN s}\n  }) s\n}\""], ["", "definition \"heap_WHILET b f s \\<equiv> do {\n  heap.fixp_fun (\\<lambda>D s. do {\n    bv \\<leftarrow> b s;\n    if bv then do {\n      s \\<leftarrow> f s;\n      D s\n    } else do {return s}\n  }) s\n}\""], ["", "lemma heap_WHILET_unfold[code]: \"heap_WHILET b f s = \n  do {\n    bv \\<leftarrow> b s;\n    if bv then do {\n      s \\<leftarrow> f s;\n      heap_WHILET b f s\n    } else\n      return s\n  }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_WHILET b f s =\n    b s \\<bind>\n    (\\<lambda>bv. if bv then f s \\<bind> heap_WHILET b f else return s)", "unfolding heap_WHILET_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap.fixp_fun\n     (\\<lambda>D s.\n         b s \\<bind> (\\<lambda>bv. if bv then f s \\<bind> D else return s))\n     s =\n    b s \\<bind>\n    (\\<lambda>bv.\n        if bv\n        then f s \\<bind>\n             heap.fixp_fun\n              (\\<lambda>D s.\n                  b s \\<bind>\n                  (\\<lambda>bv. if bv then f s \\<bind> D else return s))\n        else return s)", "apply (subst heap.mono_body_fixp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       mono_Heap\n        (\\<lambda>fa.\n            b x \\<bind>\n            (\\<lambda>bv. if bv then f x \\<bind> fa else return x))\n 2. b s \\<bind>\n    (\\<lambda>bv.\n        if bv\n        then f s \\<bind>\n             heap.fixp_fun\n              (\\<lambda>D s.\n                  b s \\<bind>\n                  (\\<lambda>bv. if bv then f s \\<bind> D else return s))\n        else return s) =\n    b s \\<bind>\n    (\\<lambda>bv.\n        if bv\n        then f s \\<bind>\n             heap.fixp_fun\n              (\\<lambda>D s.\n                  b s \\<bind>\n                  (\\<lambda>bv. if bv then f s \\<bind> D else return s))\n        else return s)", "apply pf_mono"], ["proof (prove)\ngoal (1 subgoal):\n 1. b s \\<bind>\n    (\\<lambda>bv.\n        if bv\n        then f s \\<bind>\n             heap.fixp_fun\n              (\\<lambda>D s.\n                  b s \\<bind>\n                  (\\<lambda>bv. if bv then f s \\<bind> D else return s))\n        else return s) =\n    b s \\<bind>\n    (\\<lambda>bv.\n        if bv\n        then f s \\<bind>\n             heap.fixp_fun\n              (\\<lambda>D s.\n                  b s \\<bind>\n                  (\\<lambda>bv. if bv then f s \\<bind> D else return s))\n        else return s)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma WHILEIT_to_monadic: \"WHILEIT I b f s = monadic_WHILEIT I (\\<lambda>s. RETURN (b s)) f s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE\\<^sub>T\\<^bsup>I\\<^esup> b f s =\n    monadic_WHILEIT I (\\<lambda>s. RETURN (b s)) f s", "unfolding WHILEIT_def monadic_WHILEIT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. REC\\<^sub>T (WHILEI_body (\\<bind>) RETURN I b f) s =\n    REC\\<^sub>T\n     (\\<lambda>D s.\n         ASSERT (I s) \\<bind>\n         (\\<lambda>_.\n             RETURN (b s) \\<bind>\n             (\\<lambda>bv. if bv then f s \\<bind> D else RETURN s)))\n     s", "unfolding WHILEI_body_def bind_ASSERT_eq_if"], ["proof (prove)\ngoal (1 subgoal):\n 1. REC\\<^sub>T\n     (\\<lambda>W s.\n         if I s then if b s then f s \\<bind> W else RETURN s else FAIL)\n     s =\n    REC\\<^sub>T\n     (\\<lambda>D s.\n         if I s\n         then RETURN (b s) \\<bind>\n              (\\<lambda>bv. if bv then f s \\<bind> D else RETURN s)\n         else FAIL)\n     s", "by (simp cong: if_cong)"], ["", "lemma WHILEIT_pat[def_pat_rules]:\n  \"WHILEIT$I \\<equiv> UNPROTECT (WHILEIT I)\"\n  \"WHILET \\<equiv> PR_CONST (WHILEIT (\\<lambda>_. True))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (WHILEIT $ I \\<equiv> UNPROTECT WHILE\\<^sub>T\\<^bsup>I\\<^esup>) &&&\n    WHILE\\<^sub>T \\<equiv>\n    PR_CONST WHILE\\<^sub>T\\<^bsup>\\<lambda>_. True\\<^esup>", "by (simp_all add: WHILET_def)"], ["", "lemma id_WHILEIT[id_rules]: \n  \"PR_CONST (WHILEIT I) ::\\<^sub>i TYPE(('a \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> 'a nres) \\<Rightarrow> 'a \\<Rightarrow> 'a nres)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PR_CONST WHILE\\<^sub>T\\<^bsup>I\\<^esup> ::\\<^sub>i\n    TYPE(('a \\<Rightarrow> bool)\n         \\<Rightarrow> ('a \\<Rightarrow> 'a nres)\n                       \\<Rightarrow> 'a \\<Rightarrow> 'a nres)", "by simp"], ["", "lemma WHILE_arities[sepref_monadify_arity]:\n  (*\"WHILET \\<equiv> WHILEIT$(\\<lambda>\\<^sub>2_. True)\"*)\n  \"PR_CONST (WHILEIT I) \\<equiv> \\<lambda>\\<^sub>2b f s. SP (PR_CONST (WHILEIT I))$(\\<lambda>\\<^sub>2s. b$s)$(\\<lambda>\\<^sub>2s. f$s)$s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PR_CONST WHILE\\<^sub>T\\<^bsup>I\\<^esup> \\<equiv>\n    \\<lambda>x.\n       (#\\<lambda>xa.\n            (#\\<lambda>xb.\n                 (#SP (PR_CONST WHILE\\<^sub>T\\<^bsup>I\\<^esup>) $\n                   (\\<lambda>xa. (#x $ xa#)) $\n                   (\\<lambda>x. (#xa $ x#)) $\n                   xb#)#)#)", "by (simp_all add: WHILET_def)"], ["", "lemma WHILEIT_comb[sepref_monadify_comb]:\n  \"PR_CONST (WHILEIT I)$(\\<lambda>\\<^sub>2x. b x)$f$s \\<equiv> \n    Refine_Basic.bind$(EVAL$s)$(\\<lambda>\\<^sub>2s. \n      SP (PR_CONST (monadic_WHILEIT I))$(\\<lambda>\\<^sub>2x. (EVAL$(b x)))$f$s\n    )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PR_CONST WHILE\\<^sub>T\\<^bsup>I\\<^esup> $ (\\<lambda>x. (#b x#)) $ f $\n    s \\<equiv>\n    (\\<bind>) $ (EVAL $ s) $\n    (\\<lambda>x.\n        (#SP (PR_CONST (monadic_WHILEIT I)) $ (\\<lambda>x. (#EVAL $ b x#)) $\n          f $\n          x#))", "by (simp_all add: WHILEIT_to_monadic)"], ["", "lemma hn_monadic_WHILE_aux:\n  assumes FR: \"P \\<Longrightarrow>\\<^sub>t \\<Gamma> * hn_ctxt Rs s' s\"\n  assumes b_ref: \"\\<And>s s'. I s' \\<Longrightarrow> hn_refine \n    (\\<Gamma> * hn_ctxt Rs s' s)\n    (b s)\n    (\\<Gamma>b s' s)\n    (pure bool_rel)\n    (b' s')\"\n  assumes b_fr: \"\\<And>s' s. \\<Gamma>b s' s \\<Longrightarrow>\\<^sub>t \\<Gamma> * hn_ctxt Rs s' s\"\n\n  assumes f_ref: \"\\<And>s' s. \\<lbrakk>I s'\\<rbrakk> \\<Longrightarrow> hn_refine\n    (\\<Gamma> * hn_ctxt Rs s' s)\n    (f s)\n    (\\<Gamma>f s' s)\n    Rs\n    (f' s')\"\n  assumes f_fr: \"\\<And>s' s. \\<Gamma>f s' s \\<Longrightarrow>\\<^sub>t \\<Gamma> * hn_ctxt (\\<lambda>_ _. true) s' s\"\n  (*assumes PREC: \"precise Rs\"*)\n  shows \"hn_refine (P) (heap_WHILET b f s) (\\<Gamma> * hn_invalid Rs s' s) Rs (monadic_WHILEIT I b' f' s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine P (heap_WHILET b f s) (\\<Gamma> * hn_invalid Rs s' s) Rs\n     (monadic_WHILEIT I b' f' s')", "unfolding monadic_WHILEIT_def heap_WHILET_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine P\n     (heap.fixp_fun\n       (\\<lambda>D s.\n           b s \\<bind>\n           (\\<lambda>bv. if bv then f s \\<bind> D else return s))\n       s)\n     (\\<Gamma> * hn_invalid Rs s' s) Rs\n     (REC\\<^sub>T\n       (\\<lambda>D s.\n           ASSERT (I s) \\<bind>\n           (\\<lambda>_.\n               b' s \\<bind>\n               (\\<lambda>bv. if bv then f' s \\<bind> D else RETURN s)))\n       s')", "apply1 (rule hn_refine_cons_pre[OF FR])"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (\\<Gamma> * hn_ctxt Rs s' s)\n     (heap.fixp_fun\n       (\\<lambda>D s.\n           b s \\<bind>\n           (\\<lambda>bv. if bv then f s \\<bind> D else return s))\n       s)\n     (\\<Gamma> * hn_invalid Rs s' s) Rs\n     (REC\\<^sub>T\n       (\\<lambda>D s.\n           ASSERT (I s) \\<bind>\n           (\\<lambda>_.\n               b' s \\<bind>\n               (\\<lambda>bv. if bv then f' s \\<bind> D else RETURN s)))\n       s')", "apply weaken_hnr_post"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (\\<Gamma> * hn_ctxt Rs s' s)\n     (heap.fixp_fun\n       (\\<lambda>D s.\n           b s \\<bind>\n           (\\<lambda>bv. if bv then f s \\<bind> D else return s))\n       s)\n     (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) s' s) Rs\n     (REC\\<^sub>T\n       (\\<lambda>D s.\n           ASSERT (I s) \\<bind>\n           (\\<lambda>_.\n               b' s \\<bind>\n               (\\<lambda>bv. if bv then f' s \\<bind> D else RETURN s)))\n       s')", "focus (rule hn_refine_cons_pre[OF _ hnr_RECT])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<Gamma> * hn_ctxt Rs s' s \\<Longrightarrow>\\<^sub>t\n    hn_ctxt ?Rx10 s' s * ?F10\n 2. \\<And>cf af ax px.\n       (\\<And>ax px.\n           hn_refine (hn_ctxt ?Rx10 ax px * ?F10) (cf px)\n            (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n            (af ax)) \\<Longrightarrow>\n       hn_refine (hn_ctxt ?Rx10 ax px * ?F10)\n        (b px \\<bind>\n         (\\<lambda>bv. if bv then f px \\<bind> cf else return px))\n        (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n        (ASSERT (I ax) \\<bind>\n         (\\<lambda>_.\n             b' ax \\<bind>\n             (\\<lambda>bv. if bv then f' ax \\<bind> af else RETURN ax)))\n 3. \\<And>x.\n       mono_Heap\n        (\\<lambda>fa.\n            b x \\<bind>\n            (\\<lambda>bv. if bv then f x \\<bind> fa else return x))", "applyS (subst mult_ac(2)[of \\<Gamma>]; rule entt_refl; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cf af ax px.\n       (\\<And>ax px.\n           hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n            (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n            (af ax)) \\<Longrightarrow>\n       hn_refine (hn_ctxt Rs ax px * \\<Gamma>)\n        (b px \\<bind>\n         (\\<lambda>bv. if bv then f px \\<bind> cf else return px))\n        (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n        (ASSERT (I ax) \\<bind>\n         (\\<lambda>_.\n             b' ax \\<bind>\n             (\\<lambda>bv. if bv then f' ax \\<bind> af else RETURN ax)))\n 2. \\<And>x.\n       mono_Heap\n        (\\<lambda>fa.\n            b x \\<bind>\n            (\\<lambda>bv. if bv then f x \\<bind> fa else return x))", "apply1 (rule hnr_ASSERT)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cf af ax px.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax\\<rbrakk>\n       \\<Longrightarrow> hn_refine (hn_ctxt Rs ax px * \\<Gamma>)\n                          (b px \\<bind>\n                           (\\<lambda>bv.\n                               if bv then f px \\<bind> cf else return px))\n                          (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                          (b' ax \\<bind>\n                           (\\<lambda>bv.\n                               if bv then f' ax \\<bind> af else RETURN ax))\n 2. \\<And>x.\n       mono_Heap\n        (\\<lambda>fa.\n            b x \\<bind>\n            (\\<lambda>bv. if bv then f x \\<bind> fa else return x))", "focus (rule hnr_bind)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>cf af ax px.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax\\<rbrakk>\n       \\<Longrightarrow> hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (b px)\n                          (?\\<Gamma>1.28 cf af ax px) (?Rh28 cf af ax px)\n                          (b' ax)\n 2. \\<And>cf af ax px x x'.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax; RETURN x \\<le> b' ax\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?\\<Gamma>1.28 cf af ax px *\n                           hn_ctxt (?Rh28 cf af ax px) x x')\n                          (if x' then f px \\<bind> cf else return px)\n                          (?\\<Gamma>2.28 cf af ax px x x') Rs\n                          (if x then f' ax \\<bind> af else RETURN ax)\n 3. \\<And>cf af ax px x x'.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.28 cf af ax px x\n                          x' \\<Longrightarrow>\\<^sub>t\n                         \\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px *\n                         hn_ctxt (?Rx28 cf af ax px) x x'", "focus (rule hn_refine_cons[OF _ b_ref b_fr entt_refl])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cf af ax px.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt Rs ax px *\n                         \\<Gamma> \\<Longrightarrow>\\<^sub>t\n                         \\<Gamma> * hn_ctxt Rs ax px\n 2. \\<And>cf af ax px.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax\\<rbrakk>\n       \\<Longrightarrow> I ax", "applyS (simp add: star_aci)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cf af ax px.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax\\<rbrakk>\n       \\<Longrightarrow> I ax", "applyS assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "solved"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cf af ax px x x'.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax; RETURN x \\<le> b' ax\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (\\<Gamma> * hn_ctxt Rs ax px *\n                           hn_val bool_rel x x')\n                          (if x' then f px \\<bind> cf else return px)\n                          (?\\<Gamma>2.28 cf af ax px x x') Rs\n                          (if x then f' ax \\<bind> af else RETURN ax)\n 2. \\<And>cf af ax px x x'.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.28 cf af ax px x\n                          x' \\<Longrightarrow>\\<^sub>t\n                         \\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px *\n                         hn_ctxt (?Rx28 cf af ax px) x x'", "focus (rule hnr_If)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>cf af ax px x x'.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax; RETURN x \\<le> b' ax\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> * hn_ctxt Rs ax px *\n                         hn_val bool_rel x x' \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>1.46 cf af ax px x x' *\n                         hn_val bool_rel x x'\n 2. \\<And>cf af ax px x x'.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax; RETURN x \\<le> b' ax; x\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?\\<Gamma>1.46 cf af ax px x x' *\n                           hn_val bool_rel x x')\n                          (f px \\<bind> cf) (?\\<Gamma>2b46 cf af ax px x x')\n                          Rs (f' ax \\<bind> af)\n 3. \\<And>cf af ax px x x'.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax; RETURN x \\<le> b' ax; \\<not> x\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?\\<Gamma>1.46 cf af ax px x x' *\n                           hn_val bool_rel x x')\n                          (return px) (?\\<Gamma>2c46 cf af ax px x x') Rs\n                          (RETURN ax)\n 4. \\<And>cf af ax px x x'.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax; RETURN x \\<le> b' ax\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2b46 cf af ax px x x' \\<or>\\<^sub>A\n                         ?\\<Gamma>2c46 cf af ax px x\n                          x' \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.28 cf af ax px x x'", "applyS (sep_auto; fail)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>cf af ax px x x'.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax; RETURN x \\<le> b' ax; x\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (\\<Gamma> * hn_ctxt Rs ax px *\n                           hn_val bool_rel x x')\n                          (f px \\<bind> cf) (?\\<Gamma>2b46 cf af ax px x x')\n                          Rs (f' ax \\<bind> af)\n 2. \\<And>cf af ax px x x'.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax; RETURN x \\<le> b' ax; \\<not> x\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (\\<Gamma> * hn_ctxt Rs ax px *\n                           hn_val bool_rel x x')\n                          (return px) (?\\<Gamma>2c46 cf af ax px x x') Rs\n                          (RETURN ax)\n 3. \\<And>cf af ax px x x'.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax; RETURN x \\<le> b' ax\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2b46 cf af ax px x x' \\<or>\\<^sub>A\n                         ?\\<Gamma>2c46 cf af ax px x\n                          x' \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.28 cf af ax px x x'", "focus (rule hnr_bind)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>cf af ax px x x'.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax; RETURN x \\<le> b' ax; x\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (\\<Gamma> * hn_ctxt Rs ax px *\n                           hn_val bool_rel x x')\n                          (f px) (?\\<Gamma>1.57 cf af ax px x x')\n                          (?Rh57 cf af ax px x x') (f' ax)\n 2. \\<And>cf af ax px x x' xa x'a.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax; RETURN x \\<le> b' ax; x; RETURN xa \\<le> f' ax\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (?\\<Gamma>1.57 cf af ax px x x' *\n                           hn_ctxt (?Rh57 cf af ax px x x') xa x'a)\n                          (cf x'a) (?\\<Gamma>2.57 cf af ax px x x' xa x'a)\n                          Rs (af xa)\n 3. \\<And>cf af ax px x x' xa x'a.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax; RETURN x \\<le> b' ax; x\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.57 cf af ax px x x' xa\n                          x'a \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2b46 cf af ax px x x' *\n                         hn_ctxt (?Rx57 cf af ax px x x') xa x'a", "focus (rule hn_refine_cons[OF _ f_ref f_fr entt_refl])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cf af ax px x x'.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax; RETURN x \\<le> b' ax; x\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> * hn_ctxt Rs ax px *\n                         hn_val bool_rel x x' \\<Longrightarrow>\\<^sub>t\n                         \\<Gamma> * hn_ctxt Rs ax px\n 2. \\<And>cf af ax px x x'.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax; RETURN x \\<le> b' ax; x\\<rbrakk>\n       \\<Longrightarrow> I ax", "apply (sep_auto simp: hn_ctxt_def pure_def intro!: enttI; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cf af ax px x x'.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax; RETURN x \\<le> b' ax; x\\<rbrakk>\n       \\<Longrightarrow> I ax", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "solved"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cf af ax px x x' xa x'a.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax; RETURN x \\<le> b' ax; x; RETURN xa \\<le> f' ax\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px *\n                           hn_ctxt Rs xa x'a)\n                          (cf x'a) (?\\<Gamma>2.57 cf af ax px x x' xa x'a)\n                          Rs (af xa)\n 2. \\<And>cf af ax px x x' xa x'a.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax; RETURN x \\<le> b' ax; x\\<rbrakk>\n       \\<Longrightarrow> ?\\<Gamma>2.57 cf af ax px x x' xa\n                          x'a \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2b46 cf af ax px x x' *\n                         hn_ctxt (?Rx57 cf af ax px x x') xa x'a", "focus (rule hn_refine_frame)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cf af ax px x x' xa x'a.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax; RETURN x \\<le> b' ax; x; RETURN xa \\<le> f' ax\\<rbrakk>\n       \\<Longrightarrow> hn_refine (?P'86 cf af ax px x x' xa x'a) (cf x'a)\n                          (?Q'86 cf af ax px x x' xa x'a) Rs (af xa)\n 2. \\<And>cf af ax px x x' xa x'a.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax; RETURN x \\<le> b' ax; x; RETURN xa \\<le> f' ax\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px *\n                         hn_ctxt Rs xa x'a \\<Longrightarrow>\\<^sub>t\n                         ?F86 cf af ax px x x' xa x'a *\n                         ?P'86 cf af ax px x x' xa x'a", "applyS rprems"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cf af ax px x x' xa x'a.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax; RETURN x \\<le> b' ax; x; RETURN xa \\<le> f' ax\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px *\n                         hn_ctxt Rs xa x'a \\<Longrightarrow>\\<^sub>t\n                         ?F86 cf af ax px x x' xa x'a *\n                         (hn_ctxt Rs xa x'a * \\<Gamma>)", "applyS (rule enttI; solve_entails)"], ["proof (prove)\ngoal:\nNo subgoals!", "solved"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cf af ax px x x' xa x'a.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax; RETURN x \\<le> b' ax; x\\<rbrakk>\n       \\<Longrightarrow> hn_ctxt (\\<lambda>_ _. true) ax px *\n                         (\\<Gamma> *\n                          hn_ctxt (\\<lambda>_ _. true) xa\n                           x'a) \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2b46 cf af ax px x x' *\n                         hn_ctxt (?Rx57 cf af ax px x x') xa x'a", "apply (sep_auto intro!: enttI; fail)"], ["proof (prove)\ngoal:\nNo subgoals!", "solved"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cf af ax px x x'.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax; RETURN x \\<le> b' ax; \\<not> x\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (\\<Gamma> * hn_ctxt Rs ax px *\n                           hn_val bool_rel x x')\n                          (return px) (?\\<Gamma>2c46 cf af ax px x x') Rs\n                          (RETURN ax)\n 2. \\<And>cf af ax px x x'.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax; RETURN x \\<le> b' ax\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<or>\\<^sub>A\n                         ?\\<Gamma>2c46 cf af ax px x\n                          x' \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.28 cf af ax px x x'", "applyF (sep_auto,rule hn_refine_frame)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cf af ax px x x'.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax; RETURN False \\<le> b' ax; \\<not> x\\<rbrakk>\n       \\<Longrightarrow> hn_refine (?P'228 cf af ax px x x') (return px)\n                          (?Q'229 cf af ax px False x') Rs (RETURN ax)\n 2. \\<And>cf af ax px x x'.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax; RETURN False \\<le> b' ax; \\<not> x\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> * hn_ctxt Rs ax px *\n                         hn_val bool_rel False x' \\<Longrightarrow>\\<^sub>t\n                         ?F230 cf af ax px False x' *\n                         ?P'228 cf af ax px x x'", "applyS (rule hnr_RETURN_pass)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cf af ax px x x'.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax; RETURN False \\<le> b' ax; \\<not> x\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> * hn_ctxt Rs ax px *\n                         hn_val bool_rel False x' \\<Longrightarrow>\\<^sub>t\n                         ?F230 cf af ax px False x' * hn_ctxt Rs ax px", "(*apply (tactic {* Sepref_Frame.frame_tac @{context} 1*})*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cf af ax px x x'.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax; RETURN False \\<le> b' ax; \\<not> x\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> * hn_ctxt Rs ax px *\n                         hn_val bool_rel False x' \\<Longrightarrow>\\<^sub>t\n                         ?F230 cf af ax px False x' * hn_ctxt Rs ax px", "apply (rule enttI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cf af ax px x x'.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax; RETURN False \\<le> b' ax; \\<not> x\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> * hn_ctxt Rs ax px *\n                         hn_val bool_rel False x' \\<Longrightarrow>\\<^sub>A\n                         ?F230 cf af ax px False x' * hn_ctxt Rs ax px *\n                         true", "apply (fr_rot_rhs 1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cf af ax px x x'.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax; RETURN False \\<le> b' ax; \\<not> x\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> * hn_ctxt Rs ax px *\n                         hn_val bool_rel False x' \\<Longrightarrow>\\<^sub>A\n                         true * ?F230 cf af ax px False x' *\n                         hn_ctxt Rs ax px", "apply (fr_rot 1, rule fr_refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cf af ax px x x'.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax; RETURN False \\<le> b' ax; \\<not> x\\<rbrakk>\n       \\<Longrightarrow> hn_val bool_rel False x' *\n                         \\<Gamma> \\<Longrightarrow>\\<^sub>A\n                         true * ?F230 cf af ax px False x'", "apply (rule fr_refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cf af ax px x x'.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax; RETURN False \\<le> b' ax; \\<not> x\\<rbrakk>\n       \\<Longrightarrow> hn_val bool_rel False x' \\<Longrightarrow>\\<^sub>A\n                         true", "apply solve_entails"], ["proof (prove)\ngoal:\nNo subgoals!", "solved"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cf af ax px x x'.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax; RETURN x \\<le> b' ax\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<or>\\<^sub>A\n                         \\<Gamma> *\n                         hn_invalid Rs ax px \\<Longrightarrow>\\<^sub>t\n                         ?\\<Gamma>2.28 cf af ax px x x'", "apply (rule entt_refl)"], ["proof (prove)\ngoal:\nNo subgoals!", "solved"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cf af ax px x x'.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<or>\\<^sub>A\n                         \\<Gamma> *\n                         hn_invalid Rs ax px \\<Longrightarrow>\\<^sub>t\n                         \\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px *\n                         hn_ctxt (?Rx28 cf af ax px) x x'", "apply (rule enttI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cf af ax px x x'.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<or>\\<^sub>A\n                         \\<Gamma> *\n                         hn_invalid Rs ax px \\<Longrightarrow>\\<^sub>A\n                         \\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px *\n                         hn_ctxt (?Rx28 cf af ax px) x x' *\n                         true", "applyF (rule ent_disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cf af ax px x x'.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<Longrightarrow>\\<^sub>A\n                         \\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px *\n                         hn_ctxt (?Rx28 cf af ax px) x x' *\n                         true\n 2. \\<And>cf af ax px x x'.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> *\n                         hn_invalid Rs ax px \\<Longrightarrow>\\<^sub>A\n                         \\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px *\n                         hn_ctxt (?Rx28 cf af ax px) x x' *\n                         true", "apply1 (sep_auto simp: hn_ctxt_def pure_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cf af ax px x x'.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (Rs ax px * \\<Gamma>) (cf px) (\\<Gamma> * true)\n                    Rs (af ax);\n        I ax\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<Longrightarrow>\\<^sub>A\n                         \\<Gamma> * ?Rx28 cf af ax px x x' * true\n 2. \\<And>cf af ax px x x'.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> *\n                         hn_invalid Rs ax px \\<Longrightarrow>\\<^sub>A\n                         \\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px *\n                         hn_ctxt (?Rx28 cf af ax px) x x' *\n                         true", "apply1 (rule ent_true_drop)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cf af ax px x x'.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (Rs ax px * \\<Gamma>) (cf px) (\\<Gamma> * true)\n                    Rs (af ax);\n        I ax\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<Longrightarrow>\\<^sub>A\n                         \\<Gamma> * ?Rx28 cf af ax px x x'\n 2. \\<And>cf af ax px x x'.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> *\n                         hn_invalid Rs ax px \\<Longrightarrow>\\<^sub>A\n                         \\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px *\n                         hn_ctxt (?Rx28 cf af ax px) x x' *\n                         true", "apply1 (rule ent_true_drop)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cf af ax px x x'.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (Rs ax px * \\<Gamma>) (cf px) (\\<Gamma> * true)\n                    Rs (af ax);\n        I ax\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<Longrightarrow>\\<^sub>A \\<Gamma>\n 2. \\<And>cf af ax px x x'.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> *\n                         hn_invalid Rs ax px \\<Longrightarrow>\\<^sub>A\n                         \\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px *\n                         hn_ctxt (\\<lambda>x x'. true) x x' *\n                         true", "applyS (rule ent_refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cf af ax px x x'.\n       \\<lbrakk>\\<And>ax px.\n                   hn_refine (hn_ctxt Rs ax px * \\<Gamma>) (cf px)\n                    (\\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px) Rs\n                    (af ax);\n        I ax\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> *\n                         hn_invalid Rs ax px \\<Longrightarrow>\\<^sub>A\n                         \\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ax px *\n                         hn_ctxt (\\<lambda>x x'. true) x x' *\n                         true", "applyS (sep_auto simp: hn_ctxt_def pure_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "solved"], ["proof (prove)\ngoal:\nNo subgoals!", "solved"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       mono_Heap\n        (\\<lambda>fa.\n            b x \\<bind>\n            (\\<lambda>bv. if bv then f x \\<bind> fa else return x))", "apply pf_mono"], ["proof (prove)\ngoal:\nNo subgoals!", "solved"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hn_monadic_WHILE_lin[sepref_comb_rules]:\n  assumes \"INDEP Rs\"\n  assumes FR: \"P \\<Longrightarrow>\\<^sub>t \\<Gamma> * hn_ctxt Rs s' s\"\n  assumes b_ref: \"\\<And>s s'. I s' \\<Longrightarrow> hn_refine \n    (\\<Gamma> * hn_ctxt Rs s' s)\n    (b s)\n    (\\<Gamma>b s' s)\n    (pure bool_rel)\n    (b' s')\"\n  assumes b_fr: \"\\<And>s' s. TERM (monadic_WHILEIT,''cond'') \\<Longrightarrow> \\<Gamma>b s' s \\<Longrightarrow>\\<^sub>t \\<Gamma> * hn_ctxt Rs s' s\"\n\n  assumes f_ref: \"\\<And>s' s. I s' \\<Longrightarrow> hn_refine\n    (\\<Gamma> * hn_ctxt Rs s' s)\n    (f s)\n    (\\<Gamma>f s' s)\n    Rs\n    (f' s')\"\n  assumes f_fr: \"\\<And>s' s. TERM (monadic_WHILEIT,''body'') \\<Longrightarrow> \\<Gamma>f s' s \\<Longrightarrow>\\<^sub>t \\<Gamma> * hn_ctxt (\\<lambda>_ _. true) s' s\"\n  shows \"hn_refine \n    P \n    (heap_WHILET b f s) \n    (\\<Gamma> * hn_invalid Rs s' s) \n    Rs \n    (PR_CONST (monadic_WHILEIT I)$(\\<lambda>\\<^sub>2s'. b' s')$(\\<lambda>\\<^sub>2s'. f' s')$(s'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine P (heap_WHILET b f s) (\\<Gamma> * hn_invalid Rs s' s) Rs\n     (PR_CONST (monadic_WHILEIT I) $ (\\<lambda>x. (#b' x#)) $\n      (\\<lambda>x. (#f' x#)) $\n      s')", "using assms(2-)"], ["proof (prove)\nusing this:\n  P \\<Longrightarrow>\\<^sub>t \\<Gamma> * hn_ctxt Rs s' s\n  I ?s' \\<Longrightarrow>\n  hn_refine (\\<Gamma> * hn_ctxt Rs ?s' ?s) (b ?s) (\\<Gamma>b ?s' ?s) id_assn\n   (b' ?s')\n  TERM (monadic_WHILEIT, ''cond'') \\<Longrightarrow>\n  \\<Gamma>b ?s' ?s \\<Longrightarrow>\\<^sub>t \\<Gamma> * hn_ctxt Rs ?s' ?s\n  I ?s' \\<Longrightarrow>\n  hn_refine (\\<Gamma> * hn_ctxt Rs ?s' ?s) (f ?s) (\\<Gamma>f ?s' ?s) Rs\n   (f' ?s')\n  TERM (monadic_WHILEIT, ''body'') \\<Longrightarrow>\n  \\<Gamma>f ?s' ?s \\<Longrightarrow>\\<^sub>t\n  \\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ?s' ?s\n\ngoal (1 subgoal):\n 1. hn_refine P (heap_WHILET b f s) (\\<Gamma> * hn_invalid Rs s' s) Rs\n     (PR_CONST (monadic_WHILEIT I) $ (\\<lambda>x. (#b' x#)) $\n      (\\<lambda>x. (#f' x#)) $\n      s')", "unfolding APP_def PROTECT2_def CONSTRAINT_def PR_CONST_def"], ["proof (prove)\nusing this:\n  P \\<Longrightarrow>\\<^sub>t \\<Gamma> * hn_ctxt Rs s' s\n  I ?s' \\<Longrightarrow>\n  hn_refine (\\<Gamma> * hn_ctxt Rs ?s' ?s) (b ?s) (\\<Gamma>b ?s' ?s) id_assn\n   (b' ?s')\n  TERM (monadic_WHILEIT, ''cond'') \\<Longrightarrow>\n  \\<Gamma>b ?s' ?s \\<Longrightarrow>\\<^sub>t \\<Gamma> * hn_ctxt Rs ?s' ?s\n  I ?s' \\<Longrightarrow>\n  hn_refine (\\<Gamma> * hn_ctxt Rs ?s' ?s) (f ?s) (\\<Gamma>f ?s' ?s) Rs\n   (f' ?s')\n  TERM (monadic_WHILEIT, ''body'') \\<Longrightarrow>\n  \\<Gamma>f ?s' ?s \\<Longrightarrow>\\<^sub>t\n  \\<Gamma> * hn_ctxt (\\<lambda>_ _. true) ?s' ?s\n\ngoal (1 subgoal):\n 1. hn_refine P (heap_WHILET b f s) (\\<Gamma> * hn_invalid Rs s' s) Rs\n     (monadic_WHILEIT I b' f' s')", "by (rule hn_monadic_WHILE_aux)"], ["", "lemma monadic_WHILEIT_refine[refine]:  \n  assumes [refine]: \"(s',s) \\<in> R\"\n  assumes [refine]: \"\\<And>s' s. \\<lbrakk> (s',s)\\<in>R; I s \\<rbrakk> \\<Longrightarrow> I' s'\"  \n  assumes [refine]: \"\\<And>s' s. \\<lbrakk> (s',s)\\<in>R; I s; I' s' \\<rbrakk> \\<Longrightarrow> b' s' \\<le>\\<Down>bool_rel (b s)\"\n  assumes [refine]: \"\\<And>s' s. \\<lbrakk> (s',s)\\<in>R; I s; I' s'; nofail (b s); inres (b s) True \\<rbrakk> \\<Longrightarrow> f' s' \\<le>\\<Down>R (f s)\"\n  shows \"monadic_WHILEIT I' b' f' s' \\<le>\\<Down>R (monadic_WHILEIT I b f s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monadic_WHILEIT I' b' f' s' \\<le> \\<Down> R (monadic_WHILEIT I b f s)", "unfolding monadic_WHILEIT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. REC\\<^sub>T\n     (\\<lambda>D s.\n         ASSERT (I' s) \\<bind>\n         (\\<lambda>_.\n             b' s \\<bind>\n             (\\<lambda>bv. if bv then f' s \\<bind> D else RETURN s)))\n     s'\n    \\<le> \\<Down> R\n           (REC\\<^sub>T\n             (\\<lambda>D s.\n                 ASSERT (I s) \\<bind>\n                 (\\<lambda>_.\n                     b s \\<bind>\n                     (\\<lambda>bv. if bv then f s \\<bind> D else RETURN s)))\n             s)", "by (refine_rcg bind_refine'; assumption?; auto)"], ["", "lemma monadic_WHILEIT_refine_WHILEIT[refine]:  \n  assumes [refine]: \"(s',s) \\<in> R\"\n  assumes [refine]: \"\\<And>s' s. \\<lbrakk> (s',s)\\<in>R; I s \\<rbrakk> \\<Longrightarrow> I' s'\"  \n  assumes [THEN order_trans,refine_vcg]: \"\\<And>s' s. \\<lbrakk> (s',s)\\<in>R; I s; I' s' \\<rbrakk> \\<Longrightarrow> b' s' \\<le> SPEC (\\<lambda>r. r = b s)\"\n  assumes [refine]: \"\\<And>s' s. \\<lbrakk> (s',s)\\<in>R; I s; I' s'; b s \\<rbrakk> \\<Longrightarrow> f' s' \\<le>\\<Down>R (f s)\"\n  shows \"monadic_WHILEIT I' b' f' s' \\<le>\\<Down>R (WHILEIT I b f s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monadic_WHILEIT I' b' f' s'\n    \\<le> \\<Down> R (WHILE\\<^sub>T\\<^bsup>I\\<^esup> b f s)", "unfolding WHILEIT_to_monadic"], ["proof (prove)\ngoal (1 subgoal):\n 1. monadic_WHILEIT I' b' f' s'\n    \\<le> \\<Down> R (monadic_WHILEIT I (\\<lambda>s. RETURN (b s)) f s)", "by (refine_vcg; assumption?; auto)"], ["", "lemma monadic_WHILEIT_refine_WHILET[refine]:  \n  assumes [refine]: \"(s',s) \\<in> R\"\n  assumes [THEN order_trans,refine_vcg]: \"\\<And>s' s. \\<lbrakk> (s',s)\\<in>R \\<rbrakk> \\<Longrightarrow> b' s' \\<le> SPEC (\\<lambda>r. r = b s)\"\n  assumes [refine]: \"\\<And>s' s. \\<lbrakk> (s',s)\\<in>R; b s \\<rbrakk> \\<Longrightarrow> f' s' \\<le>\\<Down>R (f s)\"\n  shows \"monadic_WHILEIT (\\<lambda>_. True) b' f' s' \\<le>\\<Down>R (WHILET b f s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monadic_WHILEIT (\\<lambda>_. True) b' f' s'\n    \\<le> \\<Down> R (WHILE\\<^sub>T b f s)", "unfolding WHILET_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. monadic_WHILEIT (\\<lambda>_. True) b' f' s'\n    \\<le> \\<Down> R (WHILE\\<^sub>T\\<^bsup>\\<lambda>_. True\\<^esup> b f s)", "by (refine_vcg; assumption?)"], ["", "lemma monadic_WHILEIT_pat[def_pat_rules]:\n  \"monadic_WHILEIT$I \\<equiv> UNPROTECT (monadic_WHILEIT I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monadic_WHILEIT $ I \\<equiv> UNPROTECT (monadic_WHILEIT I)", "by auto"], ["", "lemma id_monadic_WHILEIT[id_rules]: \n  \"PR_CONST (monadic_WHILEIT I) ::\\<^sub>i TYPE(('a \\<Rightarrow> bool nres) \\<Rightarrow> ('a \\<Rightarrow> 'a nres) \\<Rightarrow> 'a \\<Rightarrow> 'a nres)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PR_CONST (monadic_WHILEIT I) ::\\<^sub>i\n    TYPE(('a \\<Rightarrow> bool nres)\n         \\<Rightarrow> ('a \\<Rightarrow> 'a nres)\n                       \\<Rightarrow> 'a \\<Rightarrow> 'a nres)", "by simp"], ["", "lemma monadic_WHILEIT_arities[sepref_monadify_arity]:\n  \"PR_CONST (monadic_WHILEIT I) \\<equiv> \\<lambda>\\<^sub>2b f s. SP (PR_CONST (monadic_WHILEIT I))$(\\<lambda>\\<^sub>2s. b$s)$(\\<lambda>\\<^sub>2s. f$s)$s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PR_CONST (monadic_WHILEIT I) \\<equiv>\n    \\<lambda>x.\n       (#\\<lambda>xa.\n            (#\\<lambda>xb.\n                 (#SP (PR_CONST (monadic_WHILEIT I)) $\n                   (\\<lambda>xa. (#x $ xa#)) $\n                   (\\<lambda>x. (#xa $ x#)) $\n                   xb#)#)#)", "by (simp)"], ["", "lemma monadic_WHILEIT_comb[sepref_monadify_comb]:\n  \"PR_CONST (monadic_WHILEIT I)$b$f$s \\<equiv> \n    Refine_Basic.bind$(EVAL$s)$(\\<lambda>\\<^sub>2s. \n      SP (PR_CONST (monadic_WHILEIT I))$b$f$s\n    )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PR_CONST (monadic_WHILEIT I) $ b $ f $ s \\<equiv>\n    (\\<bind>) $ (EVAL $ s) $\n    (\\<lambda>x. (#SP (PR_CONST (monadic_WHILEIT I)) $ b $ f $ x#))", "by (simp)"], ["", "definition [simp]: \"op_ASSERT_bind I m \\<equiv> Refine_Basic.bind (ASSERT I) (\\<lambda>_. m)\""], ["", "lemma pat_ASSERT_bind[def_pat_rules]:\n  \"Refine_Basic.bind$(ASSERT$I)$(\\<lambda>\\<^sub>2_. m) \\<equiv> UNPROTECT (op_ASSERT_bind I)$m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<bind>) $ (ASSERT $ I) $ (\\<lambda>x. (#m#)) \\<equiv>\n    UNPROTECT (op_ASSERT_bind I) $ m", "by simp"], ["", "term \"PR_CONST (op_ASSERT_bind I)\""], ["", "lemma id_op_ASSERT_bind[id_rules]: \n  \"PR_CONST (op_ASSERT_bind I) ::\\<^sub>i TYPE('a nres \\<Rightarrow> 'a nres)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PR_CONST (op_ASSERT_bind I) ::\\<^sub>i\n    TYPE('a nres \\<Rightarrow> 'a nres)", "by simp"], ["", "lemma arity_ASSERT_bind[sepref_monadify_arity]:\n  \"PR_CONST (op_ASSERT_bind I) \\<equiv> \\<lambda>\\<^sub>2m. SP (PR_CONST (op_ASSERT_bind I))$m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PR_CONST (op_ASSERT_bind I) \\<equiv>\n    \\<lambda>x. (#SP (PR_CONST (op_ASSERT_bind I)) $ x#)", "apply (rule eq_reflection)"], ["proof (prove)\ngoal (1 subgoal):\n 1. PR_CONST (op_ASSERT_bind I) =\n    (\\<lambda>x. (#SP (PR_CONST (op_ASSERT_bind I)) $ x#))", "by auto"], ["", "lemma hn_ASSERT_bind[sepref_comb_rules]: \n  assumes \"I \\<Longrightarrow> hn_refine \\<Gamma> c \\<Gamma>' R m\"\n  shows \"hn_refine \\<Gamma> c \\<Gamma>' R (PR_CONST (op_ASSERT_bind I)$m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine \\<Gamma> c \\<Gamma>' R (PR_CONST (op_ASSERT_bind I) $ m)", "using assms"], ["proof (prove)\nusing this:\n  I \\<Longrightarrow> hn_refine \\<Gamma> c \\<Gamma>' R m\n\ngoal (1 subgoal):\n 1. hn_refine \\<Gamma> c \\<Gamma>' R (PR_CONST (op_ASSERT_bind I) $ m)", "apply (cases I)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<Longrightarrow> hn_refine \\<Gamma> c \\<Gamma>' R m;\n     I\\<rbrakk>\n    \\<Longrightarrow> hn_refine \\<Gamma> c \\<Gamma>' R\n                       (PR_CONST (op_ASSERT_bind I) $ m)\n 2. \\<lbrakk>I \\<Longrightarrow> hn_refine \\<Gamma> c \\<Gamma>' R m;\n     \\<not> I\\<rbrakk>\n    \\<Longrightarrow> hn_refine \\<Gamma> c \\<Gamma>' R\n                       (PR_CONST (op_ASSERT_bind I) $ m)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition [simp]: \"op_ASSUME_bind I m \\<equiv> Refine_Basic.bind (ASSUME I) (\\<lambda>_. m)\""], ["", "lemma pat_ASSUME_bind[def_pat_rules]:\n  \"Refine_Basic.bind$(ASSUME$I)$(\\<lambda>\\<^sub>2_. m) \\<equiv> UNPROTECT (op_ASSUME_bind I)$m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<bind>) $ (ASSUME $ I) $ (\\<lambda>x. (#m#)) \\<equiv>\n    UNPROTECT (op_ASSUME_bind I) $ m", "by simp"], ["", "lemma id_op_ASSUME_bind[id_rules]: \n  \"PR_CONST (op_ASSUME_bind I) ::\\<^sub>i TYPE('a nres \\<Rightarrow> 'a nres)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PR_CONST (op_ASSUME_bind I) ::\\<^sub>i\n    TYPE('a nres \\<Rightarrow> 'a nres)", "by simp"], ["", "lemma arity_ASSUME_bind[sepref_monadify_arity]:\n  \"PR_CONST (op_ASSUME_bind I) \\<equiv> \\<lambda>\\<^sub>2m. SP (PR_CONST (op_ASSUME_bind I))$m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PR_CONST (op_ASSUME_bind I) \\<equiv>\n    \\<lambda>x. (#SP (PR_CONST (op_ASSUME_bind I)) $ x#)", "apply (rule eq_reflection)"], ["proof (prove)\ngoal (1 subgoal):\n 1. PR_CONST (op_ASSUME_bind I) =\n    (\\<lambda>x. (#SP (PR_CONST (op_ASSUME_bind I)) $ x#))", "by auto"], ["", "lemma hn_ASSUME_bind[sepref_comb_rules]: \n  assumes \"vassn_tag \\<Gamma> \\<Longrightarrow> I\"\n  assumes \"I \\<Longrightarrow> hn_refine \\<Gamma> c \\<Gamma>' R m\"\n  shows \"hn_refine \\<Gamma> c \\<Gamma>' R (PR_CONST (op_ASSUME_bind I)$m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine \\<Gamma> c \\<Gamma>' R (PR_CONST (op_ASSUME_bind I) $ m)", "apply (rule hn_refine_preI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       h \\<Turnstile> \\<Gamma> \\<Longrightarrow>\n       hn_refine \\<Gamma> c \\<Gamma>' R (PR_CONST (op_ASSUME_bind I) $ m)", "using assms"], ["proof (prove)\nusing this:\n  vassn_tag \\<Gamma> \\<Longrightarrow> I\n  I \\<Longrightarrow> hn_refine \\<Gamma> c \\<Gamma>' R m\n\ngoal (1 subgoal):\n 1. \\<And>h.\n       h \\<Turnstile> \\<Gamma> \\<Longrightarrow>\n       hn_refine \\<Gamma> c \\<Gamma>' R (PR_CONST (op_ASSUME_bind I) $ m)", "apply (cases I)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>h.\n       \\<lbrakk>h \\<Turnstile> \\<Gamma>;\n        vassn_tag \\<Gamma> \\<Longrightarrow> I;\n        I \\<Longrightarrow> hn_refine \\<Gamma> c \\<Gamma>' R m; I\\<rbrakk>\n       \\<Longrightarrow> hn_refine \\<Gamma> c \\<Gamma>' R\n                          (PR_CONST (op_ASSUME_bind I) $ m)\n 2. \\<And>h.\n       \\<lbrakk>h \\<Turnstile> \\<Gamma>;\n        vassn_tag \\<Gamma> \\<Longrightarrow> I;\n        I \\<Longrightarrow> hn_refine \\<Gamma> c \\<Gamma>' R m;\n        \\<not> I\\<rbrakk>\n       \\<Longrightarrow> hn_refine \\<Gamma> c \\<Gamma>' R\n                          (PR_CONST (op_ASSUME_bind I) $ m)", "apply (auto simp: vassn_tag_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \"Import of Parametricity Theorems\""], ["", "lemma pure_hn_refineI:\n  assumes \"Q \\<longrightarrow> (c,a)\\<in>R\"\n  shows \"hn_refine (\\<up>Q) (return c) (\\<up>Q) (pure R) (RETURN a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (\\<up> Q) (return c) (\\<up> Q) (pure R) (RETURN a)", "unfolding hn_refine_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (RETURN a) \\<longrightarrow>\n    <\\<up>\n      Q> return\n          c <\\<lambda>r.\n                \\<up> Q *\n                (\\<exists>\\<^sub>Ax.\n                    pure R x r * \\<up> (RETURN x \\<le> RETURN a))>\\<^sub>t", "using assms"], ["proof (prove)\nusing this:\n  Q \\<longrightarrow> (c, a) \\<in> R\n\ngoal (1 subgoal):\n 1. nofail (RETURN a) \\<longrightarrow>\n    <\\<up>\n      Q> return\n          c <\\<lambda>r.\n                \\<up> Q *\n                (\\<exists>\\<^sub>Ax.\n                    pure R x r * \\<up> (RETURN x \\<le> RETURN a))>\\<^sub>t", "by (sep_auto simp: pure_def)"], ["", "lemma pure_hn_refineI_no_asm:\n  assumes \"(c,a)\\<in>R\"\n  shows \"hn_refine emp (return c) emp (pure R) (RETURN a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine emp (return c) emp (pure R) (RETURN a)", "unfolding hn_refine_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (RETURN a) \\<longrightarrow>\n    <emp> return\n           c <\\<lambda>r.\n                 emp *\n                 (\\<exists>\\<^sub>Ax.\n                     pure R x r * \\<up> (RETURN x \\<le> RETURN a))>\\<^sub>t", "using assms"], ["proof (prove)\nusing this:\n  (c, a) \\<in> R\n\ngoal (1 subgoal):\n 1. nofail (RETURN a) \\<longrightarrow>\n    <emp> return\n           c <\\<lambda>r.\n                 emp *\n                 (\\<exists>\\<^sub>Ax.\n                     pure R x r * \\<up> (RETURN x \\<le> RETURN a))>\\<^sub>t", "by (sep_auto simp: pure_def)"], ["", "lemma import_param_0:\n  \"(P\\<Longrightarrow>Q) \\<equiv> Trueprop (PROTECT P \\<longrightarrow> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<Longrightarrow> Q) \\<equiv> PROTECT P \\<longrightarrow> Q", "apply (rule, simp+)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma import_param_1: \n  \"(P\\<Longrightarrow>Q) \\<equiv> Trueprop (P\\<longrightarrow>Q)\"\n  \"(P\\<longrightarrow>Q\\<longrightarrow>R) \\<longleftrightarrow> (P\\<and>Q \\<longrightarrow> R)\"\n  \"PROTECT (P \\<and> Q) \\<equiv> PROTECT P \\<and> PROTECT Q\"\n  \"(P \\<and> Q) \\<and> R \\<equiv> P \\<and> Q \\<and> R\"\n  \"(a,c)\\<in>Rel \\<and> PROTECT P \\<longleftrightarrow> PROTECT P \\<and> (a,c)\\<in>Rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((P \\<Longrightarrow> Q) \\<equiv> P \\<longrightarrow> Q) &&&\n     (P \\<longrightarrow> Q \\<longrightarrow> R) =\n     (P \\<and> Q \\<longrightarrow> R)) &&&\n    (PROTECT (P \\<and> Q) \\<equiv> PROTECT P \\<and> PROTECT Q) &&&\n    ((P \\<and> Q) \\<and> R \\<equiv> P \\<and> Q \\<and> R) &&&\n    ((a, c) \\<in> Rel \\<and> PROTECT P) =\n    (PROTECT P \\<and> (a, c) \\<in> Rel)", "apply (rule, simp+)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma import_param_2:\n  \"Trueprop (PROTECT P \\<and> Q \\<longrightarrow> R) \\<equiv> (P \\<Longrightarrow> Q\\<longrightarrow>R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PROTECT P \\<and> Q \\<longrightarrow> R \\<equiv>\n    (P \\<Longrightarrow> Q \\<longrightarrow> R)", "apply (rule, simp+)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma import_param_3:\n  \"\\<up>(P \\<and> Q) = \\<up>P*\\<up>Q\"\n  \"\\<up>((c,a)\\<in>R) = hn_val R a c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<up> (P \\<and> Q) = \\<up> P * \\<up> Q &&&\n    \\<up> ((c, a) \\<in> R) = hn_val R a c", "by (simp_all add: hn_ctxt_def pure_def)"], ["", "named_theorems_rev sepref_import_rewrite \\<open>Rewrite rules on importing parametricity theorems\\<close>"], ["", "lemma to_import_frefD: \n  assumes \"(f,g)\\<in>fref P R S\"\n  shows \"\\<lbrakk>PROTECT (P y); (x,y)\\<in>R\\<rbrakk> \\<Longrightarrow> (f x, g y)\\<in>S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>PROTECT (P y); (x, y) \\<in> R\\<rbrakk>\n    \\<Longrightarrow> (f x, g y) \\<in> S", "using assms"], ["proof (prove)\nusing this:\n  (f, g) \\<in> [P]\\<^sub>f R \\<rightarrow> S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>PROTECT (P y); (x, y) \\<in> R\\<rbrakk>\n    \\<Longrightarrow> (f x, g y) \\<in> S", "unfolding fref_def"], ["proof (prove)\nusing this:\n  (f, g)\n  \\<in> {(f, g).\n         \\<forall>x y.\n            P y \\<and> (x, y) \\<in> R \\<longrightarrow> (f x, g y) \\<in> S}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>PROTECT (P y); (x, y) \\<in> R\\<rbrakk>\n    \\<Longrightarrow> (f x, g y) \\<in> S", "by auto"], ["", "lemma add_PR_CONST: \"(c,a)\\<in>R \\<Longrightarrow> (c,PR_CONST a)\\<in>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c, a) \\<in> R \\<Longrightarrow> (c, PR_CONST a) \\<in> R", "by simp"], ["", "ML \\<open>\nstructure Sepref_Import_Param = struct\n\n  (* TODO: Almost clone of Sepref_Rules.to_foparam*)\n  fun to_import_fo ctxt thm = let\n    val unf_thms = @{thms \n      split_tupled_all prod_rel_simp uncurry_apply cnv_conj_to_meta Product_Type.split}\n  in\n    case Thm.concl_of thm of\n      @{mpat \"Trueprop ((_,_) \\<in> fref _ _ _)\"} =>\n        (@{thm to_import_frefD} OF [thm])\n        |> forall_intr_vars\n        |> Local_Defs.unfold0 ctxt unf_thms\n        |> Variable.gen_all ctxt\n    | @{mpat \"Trueprop ((_,_) \\<in> _)\"} =>\n        Parametricity.fo_rule thm\n    | _ => raise THM(\"Expected parametricity or fref theorem\",~1,[thm])\n  end\n\n  fun add_PR_CONST thm = case Thm.concl_of thm of\n    @{mpat \"Trueprop ((_,_) \\<in> fref _ _ _)\"} => thm (* TODO: Hack. Need clean interfaces for fref and param rules. Also add PR_CONST to fref rules! *)\n  | @{mpat \"Trueprop ((_,PR_CONST _) \\<in> _)\"} => thm\n  | @{mpat \"Trueprop ((_,?a) \\<in> _)\"} => if is_Const a orelse is_Free a orelse is_Var a then\n      thm\n    else\n      thm RS @{thm add_PR_CONST}\n  | _ => thm  \n\n\n  fun import ctxt thm = let\n    open Sepref_Basic\n    val thm = thm\n      |> Conv.fconv_rule Thm.eta_conversion\n      |> add_PR_CONST\n      |> Local_Defs.unfold0 ctxt @{thms import_param_0}\n      |> Local_Defs.unfold0 ctxt @{thms imp_to_meta}\n      |> to_import_fo ctxt\n      |> Local_Defs.unfold0 ctxt @{thms import_param_1}\n      |> Local_Defs.unfold0 ctxt @{thms import_param_2}\n\n    val thm = case Thm.concl_of thm of\n      @{mpat \"Trueprop (_\\<longrightarrow>_)\"} => thm RS @{thm pure_hn_refineI}\n    | _ => thm RS @{thm pure_hn_refineI_no_asm}\n\n    val thm = Local_Defs.unfold0 ctxt @{thms import_param_3} thm\n      |> Conv.fconv_rule (hn_refine_concl_conv_a (K (Id_Op.protect_conv ctxt)) ctxt)\n\n    val thm = Local_Defs.unfold0 ctxt (Named_Theorems_Rev.get ctxt @{named_theorems_rev sepref_import_rewrite}) thm\n    val thm = Sepref_Rules.add_pure_constraints_rule ctxt thm\n  in\n    thm\n  end\n\n  val import_attr = Scan.succeed (Thm.mixed_attribute (fn (context,thm) =>\n    let\n      val thm = import (Context.proof_of context) thm\n      val context = Sepref_Translate.sepref_fr_rules.add_thm thm context\n    in (context,thm) end\n  ))\n\n  val import_attr_rl = Scan.succeed (Thm.rule_attribute [] (fn context =>\n    import (Context.proof_of context) #> Sepref_Rules.ensure_hfref (Context.proof_of context)\n  ))\n\n  val setup = I\n    #> Attrib.setup @{binding sepref_import_param} import_attr\n        \"Sepref: Import parametricity rule\"\n    #> Attrib.setup @{binding sepref_param} import_attr_rl\n        \"Sepref: Transform parametricity rule to sepref rule\"\n    #> Attrib.setup @{binding sepref_dbg_import_rl_only} \n        (Scan.succeed (Thm.rule_attribute [] (import o Context.proof_of)))\n        \"Sepref: Parametricity to hnr-rule, no conversion to hfref\"    \n\nend\n\\<close>"], ["", "setup Sepref_Import_Param.setup"], ["", "subsection \"Purity\""], ["", "definition \"import_rel1 R \\<equiv> \\<lambda>A c ci. \\<up>(is_pure A \\<and> (ci,c)\\<in>\\<langle>the_pure A\\<rangle>R)\""], ["", "definition \"import_rel2 R \\<equiv> \\<lambda>A B c ci. \\<up>(is_pure A \\<and> is_pure B \\<and> (ci,c)\\<in>\\<langle>the_pure A, the_pure B\\<rangle>R)\""], ["", "lemma import_rel1_pure_conv: \"import_rel1 R (pure A) = pure (\\<langle>A\\<rangle>R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. import_rel1 R (pure A) = pure (\\<langle>A\\<rangle>R)", "unfolding import_rel1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>c ci.\n        \\<up>\n         (is_pure (pure A) \\<and>\n          (ci, c) \\<in> \\<langle>the_pure (pure A)\\<rangle>R)) =\n    pure (\\<langle>A\\<rangle>R)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>c ci. \\<up> ((ci, c) \\<in> \\<langle>A\\<rangle>R)) =\n    pure (\\<langle>A\\<rangle>R)", "apply (simp add: pure_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma import_rel2_pure_conv: \"import_rel2 R (pure A) (pure B) = pure (\\<langle>A,B\\<rangle>R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. import_rel2 R (pure A) (pure B) = pure (\\<langle>A, B\\<rangle>R)", "unfolding import_rel2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>c ci.\n        \\<up>\n         (is_pure (pure A) \\<and>\n          is_pure (pure B) \\<and>\n          (ci, c) \\<in> \\<langle>the_pure (pure A),\n          the_pure (pure B)\\<rangle>R)) =\n    pure (\\<langle>A, B\\<rangle>R)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>c ci. \\<up> ((ci, c) \\<in> \\<langle>A, B\\<rangle>R)) =\n    pure (\\<langle>A, B\\<rangle>R)", "apply (simp add: pure_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma precise_pure[constraint_rules]: \"single_valued R \\<Longrightarrow> precise (pure R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued R \\<Longrightarrow> precise (pure R)", "unfolding precise_def pure_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued R \\<Longrightarrow>\n    \\<forall>a a' h p F F'.\n       h \\<Turnstile>\n       \\<up> ((p, a) \\<in> R) * F \\<and>\\<^sub>A\n       \\<up> ((p, a') \\<in> R) * F' \\<longrightarrow>\n       a = a'", "by (auto dest: single_valuedD)"], ["", "lemma precise_pure_iff_sv: \"precise (pure R) \\<longleftrightarrow> single_valued R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. precise (pure R) = single_valued R", "apply (auto simp: precise_pure)"], ["proof (prove)\ngoal (1 subgoal):\n 1. precise (pure R) \\<Longrightarrow> single_valued R", "using preciseD[where R=\"pure R\" and F=emp and F'=emp]"], ["proof (prove)\nusing this:\n  \\<lbrakk>precise (pure R);\n   ?h \\<Turnstile>\n   pure R ?a ?p * emp \\<and>\\<^sub>A pure R ?a' ?p * emp\\<rbrakk>\n  \\<Longrightarrow> ?a = ?a'\n\ngoal (1 subgoal):\n 1. precise (pure R) \\<Longrightarrow> single_valued R", "by (sep_auto simp: mod_and_dist intro: single_valuedI)"], ["", "lemma pure_precise_iff_sv: \"\\<lbrakk>is_pure R\\<rbrakk> \n  \\<Longrightarrow> precise R \\<longleftrightarrow> single_valued (the_pure R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pure R \\<Longrightarrow> precise R = single_valued (the_pure R)", "by (auto simp: is_pure_conv precise_pure_iff_sv)"], ["", "lemmas [safe_constraint_rules] = single_valued_Id br_sv"], ["", "end"]]}