{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/IICF/Impl/IICF_HOL_List.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemma id_take_nth_drop_rl:\n  assumes \"i<length l\"\n  assumes \"\\<And>l1 x l2. \\<lbrakk>l=l1@x#l2; i = length l1 \\<rbrakk> \\<Longrightarrow> P (l1@x#l2)\"\n  shows \"P l\"", "lemma list_set_entails_aux: \n  shows \"list_assn A l li * A x xi \\<Longrightarrow>\\<^sub>A list_assn A (l[i := x]) (li[i := xi]) * true\"", "lemma list_set_hd_tl_aux: \n  \"a \\<noteq> [] \\<Longrightarrow> list_assn R a c \\<Longrightarrow>\\<^sub>A R (hd a) (hd c) * true\"\n  \"a \\<noteq> [] \\<Longrightarrow> list_assn R a c \\<Longrightarrow>\\<^sub>A list_assn R (tl a) (tl c) * true\"", "lemma list_set_last_butlast_aux:\n  \"a \\<noteq> [] \\<Longrightarrow> list_assn R a c \\<Longrightarrow>\\<^sub>A R (last a) (last c) * true\"\n  \"a \\<noteq> [] \\<Longrightarrow> list_assn R a c \\<Longrightarrow>\\<^sub>A list_assn R (butlast a) (butlast c) * true\"", "lemma swap_decomp_simp[simp]: \n  \"swap (l1 @ x # c21' @ xa # l2a) (length l1) (Suc (length l1 + length c21')) = l1@xa#c21'@x#l2a\"\n  \"swap (l1 @ x # c21' @ xa # l2a) (Suc (length l1 + length c21')) (length l1) = l1@xa#c21'@x#l2a\"", "lemma list_swap_aux: \"\\<lbrakk>i < length l; j < length l\\<rbrakk> \\<Longrightarrow> list_assn A l li \\<Longrightarrow>\\<^sub>A list_assn A (swap l i j) (swap li i j) * true\"", "lemma list_rotate1_aux: \"list_assn A a c \\<Longrightarrow>\\<^sub>A list_assn A (rotate1 a) (rotate1 c) * true\"", "lemma list_rev_aux: \"list_assn A a c \\<Longrightarrow>\\<^sub>A list_assn A (rev a) (rev c) * true\"", "lemma mod_starE: \n  assumes \"h \\<Turnstile> A*B\"\n  obtains h1 h2 where \"h1\\<Turnstile>A\" \"h2\\<Turnstile>B\"", "lemma CONSTRAINT_is_pureE:\n  assumes \"CONSTRAINT is_pure A\"\n  obtains R where \"A=pure R\"", "lemma HOL_list_empty_hnr_aux: \"(uncurry0 (return op_list_empty), uncurry0 (RETURN op_list_empty)) \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a (list_assn A)\"", "lemma HOL_list_is_empty_hnr[sepref_fr_rules]: \"(return \\<circ> op_list_is_empty, RETURN \\<circ> op_list_is_empty) \\<in> (list_assn A)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\"", "lemma HOL_list_prepend_hnr[sepref_fr_rules]: \"(uncurry (return \\<circ>\\<circ> op_list_prepend), uncurry (RETURN \\<circ>\\<circ> op_list_prepend)) \\<in> A\\<^sup>d *\\<^sub>a (list_assn A)\\<^sup>d \\<rightarrow>\\<^sub>a list_assn A\"", "lemma HOL_list_append_hnr[sepref_fr_rules]: \"(uncurry (return \\<circ>\\<circ> op_list_append), uncurry (RETURN \\<circ>\\<circ> op_list_append)) \\<in> (list_assn A)\\<^sup>d *\\<^sub>a A\\<^sup>d \\<rightarrow>\\<^sub>a list_assn A\"", "lemma HOL_list_concat_hnr[sepref_fr_rules]: \"(uncurry (return \\<circ>\\<circ> op_list_concat), uncurry (RETURN \\<circ>\\<circ> op_list_concat)) \\<in> (list_assn A)\\<^sup>d *\\<^sub>a (list_assn A)\\<^sup>d \\<rightarrow>\\<^sub>a list_assn A\"", "lemma HOL_list_length_hnr[sepref_fr_rules]: \"(return \\<circ> op_list_length, RETURN \\<circ> op_list_length) \\<in> (list_assn A)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\"", "lemma HOL_list_set_hnr[sepref_fr_rules]: \"(uncurry2 (return \\<circ>\\<circ>\\<circ> op_list_set), uncurry2 (RETURN \\<circ>\\<circ>\\<circ> op_list_set)) \\<in> (list_assn A)\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a A\\<^sup>d \\<rightarrow>\\<^sub>a list_assn A\"", "lemma HOL_list_hd_hnr[sepref_fr_rules]: \"(return \\<circ> op_list_hd, RETURN \\<circ> op_list_hd) \\<in> [\\<lambda>y. y \\<noteq> []]\\<^sub>a (list_assn R)\\<^sup>d \\<rightarrow> R\"", "lemma HOL_list_tl_hnr[sepref_fr_rules]: \"(return \\<circ> op_list_tl, RETURN \\<circ> op_list_tl) \\<in> [\\<lambda>y. y \\<noteq> []]\\<^sub>a (list_assn A)\\<^sup>d \\<rightarrow> list_assn A\"", "lemma HOL_list_last_hnr[sepref_fr_rules]: \"(return \\<circ> op_list_last, RETURN \\<circ> op_list_last) \\<in> [\\<lambda>y. y \\<noteq> []]\\<^sub>a (list_assn R)\\<^sup>d \\<rightarrow> R\"", "lemma HOL_list_butlast_hnr[sepref_fr_rules]: \"(return \\<circ> op_list_butlast, RETURN \\<circ> op_list_butlast) \\<in> [\\<lambda>y. y \\<noteq> []]\\<^sub>a (list_assn A)\\<^sup>d \\<rightarrow> list_assn A\"", "lemma HOL_list_swap_hnr[sepref_fr_rules]: \"(uncurry2 (return \\<circ>\\<circ>\\<circ> op_list_swap), uncurry2 (RETURN \\<circ>\\<circ>\\<circ> op_list_swap))\n \\<in> [\\<lambda>((a, b), ba). b < length a \\<and> ba < length a]\\<^sub>a (list_assn A)\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k \\<rightarrow> list_assn A\"", "lemma HOL_list_rotate1_hnr[sepref_fr_rules]: \"(return \\<circ> op_list_rotate1, RETURN \\<circ> op_list_rotate1) \\<in> (list_assn A)\\<^sup>d \\<rightarrow>\\<^sub>a list_assn A\"", "lemma HOL_list_rev_hnr[sepref_fr_rules]: \"(return \\<circ> op_list_rev, RETURN \\<circ> op_list_rev) \\<in> (list_assn A)\\<^sup>d \\<rightarrow>\\<^sub>a list_assn A\"", "lemma HOL_list_replicate_hnr[sepref_fr_rules]: \"CONSTRAINT is_pure A \\<Longrightarrow> (uncurry (return \\<circ>\\<circ> op_list_replicate), uncurry (RETURN \\<circ>\\<circ> op_list_replicate)) \\<in> nat_assn\\<^sup>k *\\<^sub>a A\\<^sup>k \\<rightarrow>\\<^sub>a list_assn A\"", "lemma HOL_list_get_hnr[sepref_fr_rules]: \"CONSTRAINT is_pure A \\<Longrightarrow> (uncurry (return \\<circ>\\<circ> op_list_get), uncurry (RETURN \\<circ>\\<circ> op_list_get)) \\<in> [\\<lambda>(a, b). b < length a]\\<^sub>a (list_assn A)\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k \\<rightarrow> A\"", "lemma bool_by_paramE: \"\\<lbrakk> a; (a,b)\\<in>Id \\<rbrakk> \\<Longrightarrow> b\"", "lemma bool_by_paramE': \"\\<lbrakk> a; (b,a)\\<in>Id \\<rbrakk> \\<Longrightarrow> b\"", "lemma HOL_list_contains_hnr[sepref_fr_rules]: \"\\<lbrakk>CONSTRAINT is_pure A; single_valued (the_pure A); single_valued ((the_pure A)\\<inverse>)\\<rbrakk>\n  \\<Longrightarrow> (uncurry (return \\<circ>\\<circ> op_list_contains), uncurry (RETURN \\<circ>\\<circ> op_list_contains)) \\<in> A\\<^sup>k *\\<^sub>a (list_assn A)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\"", "lemmas HOL_list_empty_hnr_mop = HOL_list_empty_hnr_aux[FCOMP mk_mop_rl0_np[OF mop_list_empty_alt]]", "lemmas HOL_list_is_empty_hnr_mop[sepref_fr_rules] = HOL_list_is_empty_hnr[FCOMP mk_mop_rl1_np[OF mop_list_is_empty_alt]]", "lemmas HOL_list_prepend_hnr_mop[sepref_fr_rules] = HOL_list_prepend_hnr[FCOMP mk_mop_rl2_np[OF mop_list_prepend_alt]]", "lemmas HOL_list_append_hnr_mop[sepref_fr_rules] = HOL_list_append_hnr[FCOMP mk_mop_rl2_np[OF mop_list_append_alt]]", "lemmas HOL_list_concat_hnr_mop[sepref_fr_rules] = HOL_list_concat_hnr[FCOMP mk_mop_rl2_np[OF mop_list_concat_alt]]", "lemmas HOL_list_length_hnr_mop[sepref_fr_rules] = HOL_list_length_hnr[FCOMP mk_mop_rl1_np[OF mop_list_length_alt]]", "lemmas HOL_list_set_hnr_mop[sepref_fr_rules] = HOL_list_set_hnr[FCOMP mk_mop_rl3[OF mop_list_set_alt]]", "lemmas HOL_list_hd_hnr_mop[sepref_fr_rules] = HOL_list_hd_hnr[FCOMP mk_mop_rl1[OF mop_list_hd_alt]]", "lemmas HOL_list_tl_hnr_mop[sepref_fr_rules] = HOL_list_tl_hnr[FCOMP mk_mop_rl1[OF mop_list_tl_alt]]", "lemmas HOL_list_last_hnr_mop[sepref_fr_rules] = HOL_list_last_hnr[FCOMP mk_mop_rl1[OF mop_list_last_alt]]", "lemmas HOL_list_butlast_hnr_mop[sepref_fr_rules] = HOL_list_butlast_hnr[FCOMP mk_mop_rl1[OF mop_list_butlast_alt]]", "lemmas HOL_list_swap_hnr_mop[sepref_fr_rules] = HOL_list_swap_hnr[FCOMP mk_mop_rl3[OF mop_list_swap_alt]]", "lemmas HOL_list_rotate1_hnr_mop[sepref_fr_rules] = HOL_list_rotate1_hnr[FCOMP mk_mop_rl1_np[OF mop_list_rotate1_alt]]", "lemmas HOL_list_rev_hnr_mop[sepref_fr_rules] = HOL_list_rev_hnr[FCOMP mk_mop_rl1_np[OF mop_list_rev_alt]]", "lemmas HOL_list_replicate_hnr_mop[sepref_fr_rules] = HOL_list_replicate_hnr[FCOMP mk_mop_rl2_np[OF mop_list_replicate_alt]]", "lemmas HOL_list_get_hnr_mop[sepref_fr_rules] = HOL_list_get_hnr[FCOMP mk_mop_rl2[OF mop_list_get_alt]]", "lemmas HOL_list_contains_hnr_mop[sepref_fr_rules] = HOL_list_contains_hnr[FCOMP mk_mop_rl2_np[OF mop_list_contains_alt]]", "lemmas HOL_list_empty_hnr = HOL_list_empty_hnr_aux HOL_list_empty_hnr_mop"], "translations": [["", "lemma id_take_nth_drop_rl:\n  assumes \"i<length l\"\n  assumes \"\\<And>l1 x l2. \\<lbrakk>l=l1@x#l2; i = length l1 \\<rbrakk> \\<Longrightarrow> P (l1@x#l2)\"\n  shows \"P l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P l", "apply (subst id_take_nth_drop[OF assms(1)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (take i l @ l ! i # drop (Suc i) l)", "apply (rule assms(2))"], ["proof (prove)\ngoal (2 subgoals):\n 1. l = take i l @ l ! i # drop (Suc i) l\n 2. i = length (take i l)", "apply (subst id_take_nth_drop[OF assms(1)])"], ["proof (prove)\ngoal (2 subgoals):\n 1. take i l @ l ! i # drop (Suc i) l = take i l @ l ! i # drop (Suc i) l\n 2. i = length (take i l)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. i = length (take i l)", "apply (simp add: assms(1))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "private"], ["", "lemma list_set_entails_aux: \n  shows \"list_assn A l li * A x xi \\<Longrightarrow>\\<^sub>A list_assn A (l[i := x]) (li[i := xi]) * true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_assn A l li * A x xi \\<Longrightarrow>\\<^sub>A\n    list_assn A (l[i := x]) (li[i := xi]) * true", "apply (rule entails_preI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. vassn_tag (list_assn A l li * A x xi) \\<Longrightarrow>\n    list_assn A l li * A x xi \\<Longrightarrow>\\<^sub>A\n    list_assn A (l[i := x]) (li[i := xi]) * true", "apply (clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vassn_tag (list_assn A l li); vassn_tag (A x xi)\\<rbrakk>\n    \\<Longrightarrow> list_assn A l li * A x xi \\<Longrightarrow>\\<^sub>A\n                      list_assn A (l[i := x]) (li[i := xi]) * true", "apply (cases \"i < length l\"; cases \"i < length li\"; (sep_auto dest!: list_assn_aux_eqlen_simp;fail)?)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vassn_tag (list_assn A l li); vassn_tag (A x xi); i < length l;\n     i < length li\\<rbrakk>\n    \\<Longrightarrow> list_assn A l li * A x xi \\<Longrightarrow>\\<^sub>A\n                      list_assn A (l[i := x]) (li[i := xi]) * true", "apply (erule id_take_nth_drop_rl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l1 xa l2.\n       \\<lbrakk>vassn_tag (list_assn A l li); vassn_tag (A x xi);\n        i < length li; l = l1 @ xa # l2; i = length l1\\<rbrakk>\n       \\<Longrightarrow> list_assn A (l1 @ xa # l2) li *\n                         A x xi \\<Longrightarrow>\\<^sub>A\n                         list_assn A ((l1 @ xa # l2)[i := x])\n                          (li[i := xi]) *\n                         true", "apply (erule id_take_nth_drop_rl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l1 xa l2 l1a xaa l2a.\n       \\<lbrakk>vassn_tag (list_assn A l li); vassn_tag (A x xi);\n        l = l1 @ xa # l2; i = length l1; li = l1a @ xaa # l2a;\n        i = length l1a\\<rbrakk>\n       \\<Longrightarrow> list_assn A (l1 @ xa # l2) (l1a @ xaa # l2a) *\n                         A x xi \\<Longrightarrow>\\<^sub>A\n                         list_assn A ((l1 @ xa # l2)[i := x])\n                          ((l1a @ xaa # l2a)[i := xi]) *\n                         true", "apply (sep_auto simp add: list_update_append)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "private"], ["", "lemma list_set_hd_tl_aux: \n  \"a \\<noteq> [] \\<Longrightarrow> list_assn R a c \\<Longrightarrow>\\<^sub>A R (hd a) (hd c) * true\"\n  \"a \\<noteq> [] \\<Longrightarrow> list_assn R a c \\<Longrightarrow>\\<^sub>A list_assn R (tl a) (tl c) * true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<noteq> [] \\<Longrightarrow>\n     list_assn R a c \\<Longrightarrow>\\<^sub>A R (hd a) (hd c) * true) &&&\n    (a \\<noteq> [] \\<Longrightarrow>\n     list_assn R a c \\<Longrightarrow>\\<^sub>A\n     list_assn R (tl a) (tl c) * true)", "by (cases c; cases a; sep_auto; fail)+"], ["", "private"], ["", "lemma list_set_last_butlast_aux:\n  \"a \\<noteq> [] \\<Longrightarrow> list_assn R a c \\<Longrightarrow>\\<^sub>A R (last a) (last c) * true\"\n  \"a \\<noteq> [] \\<Longrightarrow> list_assn R a c \\<Longrightarrow>\\<^sub>A list_assn R (butlast a) (butlast c) * true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<noteq> [] \\<Longrightarrow>\n     list_assn R a c \\<Longrightarrow>\\<^sub>A\n     R (last a) (last c) * true) &&&\n    (a \\<noteq> [] \\<Longrightarrow>\n     list_assn R a c \\<Longrightarrow>\\<^sub>A\n     list_assn R (butlast a) (butlast c) * true)", "by (cases c rule: rev_cases; cases a  rule: rev_cases; sep_auto; fail)+"], ["", "private"], ["", "lemma swap_decomp_simp[simp]: \n  \"swap (l1 @ x # c21' @ xa # l2a) (length l1) (Suc (length l1 + length c21')) = l1@xa#c21'@x#l2a\"\n  \"swap (l1 @ x # c21' @ xa # l2a) (Suc (length l1 + length c21')) (length l1) = l1@xa#c21'@x#l2a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swap (l1 @ x # c21' @ xa # l2a) (length l1)\n     (Suc (length l1 + length c21')) =\n    l1 @ xa # c21' @ x # l2a &&&\n    swap (l1 @ x # c21' @ xa # l2a) (Suc (length l1 + length c21'))\n     (length l1) =\n    l1 @ xa # c21' @ x # l2a", "by (auto simp: swap_def list_update_append nth_append)"], ["", "private"], ["", "lemma list_swap_aux: \"\\<lbrakk>i < length l; j < length l\\<rbrakk> \\<Longrightarrow> list_assn A l li \\<Longrightarrow>\\<^sub>A list_assn A (swap l i j) (swap li i j) * true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length l; j < length l\\<rbrakk>\n    \\<Longrightarrow> list_assn A l li \\<Longrightarrow>\\<^sub>A\n                      list_assn A (swap l i j) (swap li i j) * true", "apply (subst list_assn_aux_len; clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length li; j < length li; length l = length li\\<rbrakk>\n    \\<Longrightarrow> list_assn A l li \\<Longrightarrow>\\<^sub>A\n                      list_assn A (swap l i j) (swap li i j) * true", "apply (cases \"i=j\"; (sep_auto;fail)?)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length li; j < length li; length l = length li;\n     i \\<noteq> j\\<rbrakk>\n    \\<Longrightarrow> list_assn A l li \\<Longrightarrow>\\<^sub>A\n                      list_assn A (swap l i j) (swap li i j) * true", "apply (rule id_take_nth_drop_rl[where l=l and i=i]; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l1 x l2.\n       \\<lbrakk>j < length li; Suc (length l1 + length l2) = length li;\n        length l1 \\<noteq> j; l = l1 @ x # l2; i = length l1\\<rbrakk>\n       \\<Longrightarrow> list_assn A (l1 @ x # l2)\n                          li \\<Longrightarrow>\\<^sub>A\n                         list_assn A (swap (l1 @ x # l2) (length l1) j)\n                          (swap li (length l1) j) *\n                         true", "apply (rule id_take_nth_drop_rl[where l=l and i=j]; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l1 x l2 l1a xa l2a.\n       \\<lbrakk>length l1a < length li;\n        Suc (length l1 + length l2) = length li;\n        length l1 \\<noteq> length l1a; l1a @ xa # l2a = l1 @ x # l2;\n        i = length l1; l = l1 @ x # l2; j = length l1a\\<rbrakk>\n       \\<Longrightarrow> list_assn A (l1 @ x # l2)\n                          li \\<Longrightarrow>\\<^sub>A\n                         list_assn A\n                          (swap (l1 @ x # l2) (length l1) (length l1a))\n                          (swap li (length l1) (length l1a)) *\n                         true", "apply (erule list_match_lel_lel; simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l1 x l2 l1a xa l2a c21'.\n       \\<lbrakk>Suc (Suc (length l1 + (length c21' + length l2a))) =\n                length li;\n        i = length l1; l = l1 @ x # c21' @ xa # l2a;\n        j = Suc (length l1 + length c21'); l1a = l1 @ x # c21';\n        l2 = c21' @ xa # l2a\\<rbrakk>\n       \\<Longrightarrow> list_assn A (l1 @ x # c21' @ xa # l2a)\n                          li \\<Longrightarrow>\\<^sub>A\n                         list_assn A (l1 @ xa # c21' @ x # l2a)\n                          (swap li (length l1)\n                            (Suc (length l1 + length c21'))) *\n                         true\n 2. \\<And>l1 x l2 l1a xa l2a c21.\n       \\<lbrakk>Suc (Suc (length l1a + length c21 + length l2)) = length li;\n        i = Suc (length l1a + length c21); l = l1a @ xa # c21 @ x # l2;\n        j = length l1a; l1 = l1a @ xa # c21; l2a = c21 @ x # l2\\<rbrakk>\n       \\<Longrightarrow> list_assn A (l1a @ xa # c21 @ x # l2)\n                          li \\<Longrightarrow>\\<^sub>A\n                         list_assn A (l1a @ x # c21 @ xa # l2)\n                          (swap li (Suc (length l1a + length c21))\n                            (length l1a)) *\n                         true", "apply (split_list_according li l; sep_auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l1 x l2 l1a xa l2a c21.\n       \\<lbrakk>Suc (Suc (length l1a + length c21 + length l2)) = length li;\n        i = Suc (length l1a + length c21); l = l1a @ xa # c21 @ x # l2;\n        j = length l1a; l1 = l1a @ xa # c21; l2a = c21 @ x # l2\\<rbrakk>\n       \\<Longrightarrow> list_assn A (l1a @ xa # c21 @ x # l2)\n                          li \\<Longrightarrow>\\<^sub>A\n                         list_assn A (l1a @ x # c21 @ xa # l2)\n                          (swap li (Suc (length l1a + length c21))\n                            (length l1a)) *\n                         true", "apply (split_list_according li l; sep_auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "private"], ["", "lemma list_rotate1_aux: \"list_assn A a c \\<Longrightarrow>\\<^sub>A list_assn A (rotate1 a) (rotate1 c) * true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_assn A a c \\<Longrightarrow>\\<^sub>A\n    list_assn A (rotate1 a) (rotate1 c) * true", "by (cases a; cases c; sep_auto)"], ["", "private"], ["", "lemma list_rev_aux: \"list_assn A a c \\<Longrightarrow>\\<^sub>A list_assn A (rev a) (rev c) * true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_assn A a c \\<Longrightarrow>\\<^sub>A\n    list_assn A (rev a) (rev c) * true", "apply (subst list_assn_aux_len; clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length a = length c \\<Longrightarrow>\n    list_assn A a c \\<Longrightarrow>\\<^sub>A\n    list_assn A (rev a) (rev c) * true", "apply (induction rule: list_induct2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. list_assn A [] [] \\<Longrightarrow>\\<^sub>A\n    list_assn A (rev []) (rev []) * true\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        list_assn A xs ys \\<Longrightarrow>\\<^sub>A\n        list_assn A (rev xs) (rev ys) * true\\<rbrakk>\n       \\<Longrightarrow> list_assn A (x # xs)\n                          (y # ys) \\<Longrightarrow>\\<^sub>A\n                         list_assn A (rev (x # xs)) (rev (y # ys)) * true", "apply sep_auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        list_assn A xs ys \\<Longrightarrow>\\<^sub>A\n        list_assn A (rev xs) (rev ys) * true\\<rbrakk>\n       \\<Longrightarrow> list_assn A (x # xs)\n                          (y # ys) \\<Longrightarrow>\\<^sub>A\n                         list_assn A (rev (x # xs)) (rev (y # ys)) * true", "apply sep_auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        list_assn A xs ys \\<Longrightarrow>\\<^sub>A\n        list_assn A (rev xs) (rev ys) * true\\<rbrakk>\n       \\<Longrightarrow> A x y * list_assn A xs ys \\<Longrightarrow>\\<^sub>A\n                         list_assn A (rev xs) (rev ys) * A x y * true", "apply (erule ent_frame_fwd, frame_inference)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       length xs = length ys \\<Longrightarrow>\n       list_assn A (rev xs) (rev ys) * true *\n       A x y \\<Longrightarrow>\\<^sub>A\n       list_assn A (rev xs) (rev ys) * A x y * true", "apply sep_auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mod_starE: \n  assumes \"h \\<Turnstile> A*B\"\n  obtains h1 h2 where \"h1\\<Turnstile>A\" \"h2\\<Turnstile>B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h1 h2.\n        \\<lbrakk>h1 \\<Turnstile> A; h2 \\<Turnstile> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  h \\<Turnstile> A * B\n\ngoal (1 subgoal):\n 1. (\\<And>h1 h2.\n        \\<lbrakk>h1 \\<Turnstile> A; h2 \\<Turnstile> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: mod_star_conv)"], ["", "private"], ["", "lemma CONSTRAINT_is_pureE:\n  assumes \"CONSTRAINT is_pure A\"\n  obtains R where \"A=pure R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>R. A = pure R \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  CONSTRAINT is_pure A\n\ngoal (1 subgoal):\n 1. (\\<And>R. A = pure R \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (auto simp: is_pure_conv)"], ["", "private"], ["", "method solve_dbg = \n  ( (elim CONSTRAINT_is_pureE; (simp only: list_assn_pure_conv the_pure_pure)?)?;\n    sep_auto \n      simp: pure_def hn_ctxt_def invalid_assn_def list_assn_aux_eqlen_simp \n      intro!: hn_refineI[THEN hn_refine_preI] hfrefI \n      elim!: mod_starE\n      intro: list_set_entails_aux list_set_hd_tl_aux list_set_last_butlast_aux\n             list_swap_aux list_rotate1_aux list_rev_aux\n    ;\n    ((rule entails_preI; sep_auto simp: list_assn_aux_eqlen_simp | (parametricity; simp; fail))?)\n  )"], ["", "private"], ["", "method solve = solve_dbg; fail"], ["", "(* TODO: Establish sepref_import param mechanism that can handle this! *)"], ["", "lemma HOL_list_empty_hnr_aux: \"(uncurry0 (return op_list_empty), uncurry0 (RETURN op_list_empty)) \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a (list_assn A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 (return op_list_empty), uncurry0 (RETURN op_list_empty))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn A", "by solve"], ["", "lemma HOL_list_is_empty_hnr[sepref_fr_rules]: \"(return \\<circ> op_list_is_empty, RETURN \\<circ> op_list_is_empty) \\<in> (list_assn A)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (return \\<circ> op_list_is_empty, RETURN \\<circ> op_list_is_empty)\n    \\<in> (list_assn A)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "by solve"], ["", "lemma HOL_list_prepend_hnr[sepref_fr_rules]: \"(uncurry (return \\<circ>\\<circ> op_list_prepend), uncurry (RETURN \\<circ>\\<circ> op_list_prepend)) \\<in> A\\<^sup>d *\\<^sub>a (list_assn A)\\<^sup>d \\<rightarrow>\\<^sub>a list_assn A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry (return \\<circ>\\<circ> op_list_prepend),\n     uncurry (RETURN \\<circ>\\<circ> op_list_prepend))\n    \\<in> A\\<^sup>d *\\<^sub>a\n          (list_assn A)\\<^sup>d \\<rightarrow>\\<^sub>a list_assn A", "by solve"], ["", "lemma HOL_list_append_hnr[sepref_fr_rules]: \"(uncurry (return \\<circ>\\<circ> op_list_append), uncurry (RETURN \\<circ>\\<circ> op_list_append)) \\<in> (list_assn A)\\<^sup>d *\\<^sub>a A\\<^sup>d \\<rightarrow>\\<^sub>a list_assn A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry (return \\<circ>\\<circ> op_list_append),\n     uncurry (RETURN \\<circ>\\<circ> op_list_append))\n    \\<in> (list_assn A)\\<^sup>d *\\<^sub>a\n          A\\<^sup>d \\<rightarrow>\\<^sub>a list_assn A", "by solve"], ["", "lemma HOL_list_concat_hnr[sepref_fr_rules]: \"(uncurry (return \\<circ>\\<circ> op_list_concat), uncurry (RETURN \\<circ>\\<circ> op_list_concat)) \\<in> (list_assn A)\\<^sup>d *\\<^sub>a (list_assn A)\\<^sup>d \\<rightarrow>\\<^sub>a list_assn A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry (return \\<circ>\\<circ> op_list_concat),\n     uncurry (RETURN \\<circ>\\<circ> op_list_concat))\n    \\<in> (list_assn A)\\<^sup>d *\\<^sub>a\n          (list_assn A)\\<^sup>d \\<rightarrow>\\<^sub>a list_assn A", "by solve"], ["", "lemma HOL_list_length_hnr[sepref_fr_rules]: \"(return \\<circ> op_list_length, RETURN \\<circ> op_list_length) \\<in> (list_assn A)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (return \\<circ> op_list_length, RETURN \\<circ> op_list_length)\n    \\<in> (list_assn A)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "by solve"], ["", "lemma HOL_list_set_hnr[sepref_fr_rules]: \"(uncurry2 (return \\<circ>\\<circ>\\<circ> op_list_set), uncurry2 (RETURN \\<circ>\\<circ>\\<circ> op_list_set)) \\<in> (list_assn A)\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a A\\<^sup>d \\<rightarrow>\\<^sub>a list_assn A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (return \\<circ>\\<circ>\\<circ> op_list_set),\n     uncurry2 (RETURN \\<circ>\\<circ>\\<circ> op_list_set))\n    \\<in> (list_assn A)\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          A\\<^sup>d \\<rightarrow>\\<^sub>a list_assn A", "by solve"], ["", "lemma HOL_list_hd_hnr[sepref_fr_rules]: \"(return \\<circ> op_list_hd, RETURN \\<circ> op_list_hd) \\<in> [\\<lambda>y. y \\<noteq> []]\\<^sub>a (list_assn R)\\<^sup>d \\<rightarrow> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (return \\<circ> op_list_hd, RETURN \\<circ> op_list_hd)\n    \\<in> [\\<lambda>y.\n              y \\<noteq> []]\\<^sub>a (list_assn R)\\<^sup>d \\<rightarrow> R", "by solve"], ["", "lemma HOL_list_tl_hnr[sepref_fr_rules]: \"(return \\<circ> op_list_tl, RETURN \\<circ> op_list_tl) \\<in> [\\<lambda>y. y \\<noteq> []]\\<^sub>a (list_assn A)\\<^sup>d \\<rightarrow> list_assn A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (return \\<circ> op_list_tl, RETURN \\<circ> op_list_tl)\n    \\<in> [\\<lambda>y.\n              y \\<noteq>\n              []]\\<^sub>a (list_assn A)\\<^sup>d \\<rightarrow> list_assn A", "by solve"], ["", "lemma HOL_list_last_hnr[sepref_fr_rules]: \"(return \\<circ> op_list_last, RETURN \\<circ> op_list_last) \\<in> [\\<lambda>y. y \\<noteq> []]\\<^sub>a (list_assn R)\\<^sup>d \\<rightarrow> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (return \\<circ> op_list_last, RETURN \\<circ> op_list_last)\n    \\<in> [\\<lambda>y.\n              y \\<noteq> []]\\<^sub>a (list_assn R)\\<^sup>d \\<rightarrow> R", "by solve"], ["", "lemma HOL_list_butlast_hnr[sepref_fr_rules]: \"(return \\<circ> op_list_butlast, RETURN \\<circ> op_list_butlast) \\<in> [\\<lambda>y. y \\<noteq> []]\\<^sub>a (list_assn A)\\<^sup>d \\<rightarrow> list_assn A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (return \\<circ> op_list_butlast, RETURN \\<circ> op_list_butlast)\n    \\<in> [\\<lambda>y.\n              y \\<noteq>\n              []]\\<^sub>a (list_assn A)\\<^sup>d \\<rightarrow> list_assn A", "by solve"], ["", "lemma HOL_list_swap_hnr[sepref_fr_rules]: \"(uncurry2 (return \\<circ>\\<circ>\\<circ> op_list_swap), uncurry2 (RETURN \\<circ>\\<circ>\\<circ> op_list_swap))\n \\<in> [\\<lambda>((a, b), ba). b < length a \\<and> ba < length a]\\<^sub>a (list_assn A)\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k \\<rightarrow> list_assn A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (return \\<circ>\\<circ>\\<circ> op_list_swap),\n     uncurry2 (RETURN \\<circ>\\<circ>\\<circ> op_list_swap))\n    \\<in> [\\<lambda>((a, b), ba).\n              b < length a \\<and>\n              ba < length\n                    a]\\<^sub>a (list_assn A)\\<^sup>d *\\<^sub>a\n                               nat_assn\\<^sup>k *\\<^sub>a\n                               nat_assn\\<^sup>k \\<rightarrow> list_assn A", "by solve"], ["", "lemma HOL_list_rotate1_hnr[sepref_fr_rules]: \"(return \\<circ> op_list_rotate1, RETURN \\<circ> op_list_rotate1) \\<in> (list_assn A)\\<^sup>d \\<rightarrow>\\<^sub>a list_assn A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (return \\<circ> op_list_rotate1, RETURN \\<circ> op_list_rotate1)\n    \\<in> (list_assn A)\\<^sup>d \\<rightarrow>\\<^sub>a list_assn A", "by solve"], ["", "lemma HOL_list_rev_hnr[sepref_fr_rules]: \"(return \\<circ> op_list_rev, RETURN \\<circ> op_list_rev) \\<in> (list_assn A)\\<^sup>d \\<rightarrow>\\<^sub>a list_assn A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (return \\<circ> op_list_rev, RETURN \\<circ> op_list_rev)\n    \\<in> (list_assn A)\\<^sup>d \\<rightarrow>\\<^sub>a list_assn A", "by solve"], ["", "lemma HOL_list_replicate_hnr[sepref_fr_rules]: \"CONSTRAINT is_pure A \\<Longrightarrow> (uncurry (return \\<circ>\\<circ> op_list_replicate), uncurry (RETURN \\<circ>\\<circ> op_list_replicate)) \\<in> nat_assn\\<^sup>k *\\<^sub>a A\\<^sup>k \\<rightarrow>\\<^sub>a list_assn A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CONSTRAINT is_pure A \\<Longrightarrow>\n    (uncurry (return \\<circ>\\<circ> op_list_replicate),\n     uncurry (RETURN \\<circ>\\<circ> op_list_replicate))\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a\n          A\\<^sup>k \\<rightarrow>\\<^sub>a list_assn A", "by solve"], ["", "lemma HOL_list_get_hnr[sepref_fr_rules]: \"CONSTRAINT is_pure A \\<Longrightarrow> (uncurry (return \\<circ>\\<circ> op_list_get), uncurry (RETURN \\<circ>\\<circ> op_list_get)) \\<in> [\\<lambda>(a, b). b < length a]\\<^sub>a (list_assn A)\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k \\<rightarrow> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CONSTRAINT is_pure A \\<Longrightarrow>\n    (uncurry (return \\<circ>\\<circ> op_list_get),\n     uncurry (RETURN \\<circ>\\<circ> op_list_get))\n    \\<in> [\\<lambda>(a, b).\n              b < length\n                   a]\\<^sub>a (list_assn A)\\<^sup>k *\\<^sub>a\n                              nat_assn\\<^sup>k \\<rightarrow> A", "by solve"], ["", "(* TODO: Ad-hoc hack! *)\nprivate"], ["", "lemma bool_by_paramE: \"\\<lbrakk> a; (a,b)\\<in>Id \\<rbrakk> \\<Longrightarrow> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a; (a, b) \\<in> bool_rel\\<rbrakk> \\<Longrightarrow> b", "by simp"], ["", "private"], ["", "lemma bool_by_paramE': \"\\<lbrakk> a; (b,a)\\<in>Id \\<rbrakk> \\<Longrightarrow> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a; (b, a) \\<in> bool_rel\\<rbrakk> \\<Longrightarrow> b", "by simp"], ["", "lemma HOL_list_contains_hnr[sepref_fr_rules]: \"\\<lbrakk>CONSTRAINT is_pure A; single_valued (the_pure A); single_valued ((the_pure A)\\<inverse>)\\<rbrakk>\n  \\<Longrightarrow> (uncurry (return \\<circ>\\<circ> op_list_contains), uncurry (RETURN \\<circ>\\<circ> op_list_contains)) \\<in> A\\<^sup>k *\\<^sub>a (list_assn A)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>CONSTRAINT is_pure A; single_valued (the_pure A);\n     single_valued ((the_pure A)\\<inverse>)\\<rbrakk>\n    \\<Longrightarrow> (uncurry (return \\<circ>\\<circ> op_list_contains),\n                       uncurry (RETURN \\<circ>\\<circ> op_list_contains))\n                      \\<in> A\\<^sup>k *\\<^sub>a\n                            (list_assn\n                              A)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "apply solve_dbg"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>R a b aa ba ab bb.\n       \\<lbrakk>single_valued R; single_valued (R\\<inverse>);\n        A = (\\<lambda>a c. \\<up> ((c, a) \\<in> R)); (a, aa) \\<in> R;\n        (b, ba) \\<in> \\<langle>R\\<rangle>list_rel;\n        (ab, bb) \\<Turnstile> emp; a \\<in> set b\\<rbrakk>\n       \\<Longrightarrow> aa \\<in> set ba\n 2. \\<And>R a b aa ba ab bb.\n       \\<lbrakk>single_valued R; single_valued (R\\<inverse>);\n        A = (\\<lambda>a c. \\<up> ((c, a) \\<in> R)); (a, aa) \\<in> R;\n        (b, ba) \\<in> \\<langle>R\\<rangle>list_rel;\n        (ab, bb) \\<Turnstile> emp; aa \\<in> set ba\\<rbrakk>\n       \\<Longrightarrow> a \\<in> set b", "apply (erule bool_by_paramE[where a=\"_\\<in>set _\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>R a b aa ba ab bb.\n       \\<lbrakk>single_valued R; single_valued (R\\<inverse>);\n        A = (\\<lambda>a c. \\<up> ((c, a) \\<in> R)); (a, aa) \\<in> R;\n        (b, ba) \\<in> \\<langle>R\\<rangle>list_rel;\n        (ab, bb) \\<Turnstile> emp\\<rbrakk>\n       \\<Longrightarrow> (a \\<in> set b, aa \\<in> set ba) \\<in> bool_rel\n 2. \\<And>R a b aa ba ab bb.\n       \\<lbrakk>single_valued R; single_valued (R\\<inverse>);\n        A = (\\<lambda>a c. \\<up> ((c, a) \\<in> R)); (a, aa) \\<in> R;\n        (b, ba) \\<in> \\<langle>R\\<rangle>list_rel;\n        (ab, bb) \\<Turnstile> emp; aa \\<in> set ba\\<rbrakk>\n       \\<Longrightarrow> a \\<in> set b", "apply parametricity"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>R a b aa ba ab bb.\n       \\<lbrakk>single_valued R; single_valued (R\\<inverse>);\n        A = (\\<lambda>a c. \\<up> ((c, a) \\<in> R)); (a, aa) \\<in> R;\n        (b, ba) \\<in> \\<langle>R\\<rangle>list_rel;\n        (ab, bb) \\<Turnstile> emp; aa \\<in> set ba\\<rbrakk>\n       \\<Longrightarrow> a \\<in> set b", "apply (erule bool_by_paramE'[where a=\"_\\<in>set _\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>R a b aa ba ab bb.\n       \\<lbrakk>single_valued R; single_valued (R\\<inverse>);\n        A = (\\<lambda>a c. \\<up> ((c, a) \\<in> R)); (a, aa) \\<in> R;\n        (b, ba) \\<in> \\<langle>R\\<rangle>list_rel;\n        (ab, bb) \\<Turnstile> emp\\<rbrakk>\n       \\<Longrightarrow> (a \\<in> set b, aa \\<in> set ba) \\<in> bool_rel", "apply parametricity"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas HOL_list_empty_hnr_mop = HOL_list_empty_hnr_aux[FCOMP mk_mop_rl0_np[OF mop_list_empty_alt]]"], ["", "lemmas HOL_list_is_empty_hnr_mop[sepref_fr_rules] = HOL_list_is_empty_hnr[FCOMP mk_mop_rl1_np[OF mop_list_is_empty_alt]]"], ["", "lemmas HOL_list_prepend_hnr_mop[sepref_fr_rules] = HOL_list_prepend_hnr[FCOMP mk_mop_rl2_np[OF mop_list_prepend_alt]]"], ["", "lemmas HOL_list_append_hnr_mop[sepref_fr_rules] = HOL_list_append_hnr[FCOMP mk_mop_rl2_np[OF mop_list_append_alt]]"], ["", "lemmas HOL_list_concat_hnr_mop[sepref_fr_rules] = HOL_list_concat_hnr[FCOMP mk_mop_rl2_np[OF mop_list_concat_alt]]"], ["", "lemmas HOL_list_length_hnr_mop[sepref_fr_rules] = HOL_list_length_hnr[FCOMP mk_mop_rl1_np[OF mop_list_length_alt]]"], ["", "lemmas HOL_list_set_hnr_mop[sepref_fr_rules] = HOL_list_set_hnr[FCOMP mk_mop_rl3[OF mop_list_set_alt]]"], ["", "lemmas HOL_list_hd_hnr_mop[sepref_fr_rules] = HOL_list_hd_hnr[FCOMP mk_mop_rl1[OF mop_list_hd_alt]]"], ["", "lemmas HOL_list_tl_hnr_mop[sepref_fr_rules] = HOL_list_tl_hnr[FCOMP mk_mop_rl1[OF mop_list_tl_alt]]"], ["", "lemmas HOL_list_last_hnr_mop[sepref_fr_rules] = HOL_list_last_hnr[FCOMP mk_mop_rl1[OF mop_list_last_alt]]"], ["", "lemmas HOL_list_butlast_hnr_mop[sepref_fr_rules] = HOL_list_butlast_hnr[FCOMP mk_mop_rl1[OF mop_list_butlast_alt]]"], ["", "lemmas HOL_list_swap_hnr_mop[sepref_fr_rules] = HOL_list_swap_hnr[FCOMP mk_mop_rl3[OF mop_list_swap_alt]]"], ["", "lemmas HOL_list_rotate1_hnr_mop[sepref_fr_rules] = HOL_list_rotate1_hnr[FCOMP mk_mop_rl1_np[OF mop_list_rotate1_alt]]"], ["", "lemmas HOL_list_rev_hnr_mop[sepref_fr_rules] = HOL_list_rev_hnr[FCOMP mk_mop_rl1_np[OF mop_list_rev_alt]]"], ["", "lemmas HOL_list_replicate_hnr_mop[sepref_fr_rules] = HOL_list_replicate_hnr[FCOMP mk_mop_rl2_np[OF mop_list_replicate_alt]]"], ["", "lemmas HOL_list_get_hnr_mop[sepref_fr_rules] = HOL_list_get_hnr[FCOMP mk_mop_rl2[OF mop_list_get_alt]]"], ["", "lemmas HOL_list_contains_hnr_mop[sepref_fr_rules] = HOL_list_contains_hnr[FCOMP mk_mop_rl2_np[OF mop_list_contains_alt]]"], ["", "lemmas HOL_list_empty_hnr = HOL_list_empty_hnr_aux HOL_list_empty_hnr_mop"], ["", "end"], ["", "definition [simp]: \"op_HOL_list_empty \\<equiv> op_list_empty\""], ["", "interpretation HOL_list: list_custom_empty \"list_assn A\" \"return []\" op_HOL_list_empty"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_custom_empty (list_assn A) (return []) op_HOL_list_empty", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. (uncurry0 (return []), uncurry0 (RETURN op_list_empty))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn A\n 2. op_HOL_list_empty = op_list_empty", "apply (sep_auto intro!: hfrefI hn_refineI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. op_HOL_list_empty = op_list_empty", "by simp"], ["", "schematic_goal\n  notes [sepref_fr_rules] = HOL_list_empty_hnr\n  shows\n  \"hn_refine (emp) (?c::?'c Heap) ?\\<Gamma>' ?R (do {\n    x \\<leftarrow> RETURN [1,2,3::nat];\n    let x2 = op_list_append x 5;\n    ASSERT (length x = 4);\n    let x = op_list_swap x 1 2;\n    x \\<leftarrow> mop_list_swap x 1 2;\n    RETURN (x@x)\n  })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine emp ?c ?\\<Gamma>' ?R\n     (RETURN [1, 2, 3] \\<bind>\n      (\\<lambda>x.\n          let x2 = op_list_append x 5\n          in ASSERT (length x = 4) \\<bind>\n             (\\<lambda>_.\n                 let x = op_list_swap x 1 2\n                 in mop_list_swap x 1 2 \\<bind>\n                    (\\<lambda>x. RETURN (x @ x)))))", "by sepref"], ["", "end"]]}