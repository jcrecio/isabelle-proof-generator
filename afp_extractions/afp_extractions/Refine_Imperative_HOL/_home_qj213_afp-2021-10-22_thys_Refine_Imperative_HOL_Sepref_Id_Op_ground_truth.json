{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/Sepref_Id_Op.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemma beta: \"(\\<lambda>\\<^sub>2x. f x)$x \\<equiv> f x\"", "lemma itypeI: \"c::\\<^sub>iI\"", "lemma itypeI': \"intf_type c TYPE('T)\"", "lemma itype_self: \"(c::'a) ::\\<^sub>i TYPE('a)\"", "lemma ID_unfold_vars: \"ID x y T \\<Longrightarrow> x\\<equiv>y\"", "lemma ID_PR_CONST_trigger: \"ID (PR_CONST x) y T \\<Longrightarrow> ID (PR_CONST x) y T\"", "lemma pat_rule:\n  \"\\<lbrakk> p\\<equiv>p'; ID p' t' T \\<rbrakk> \\<Longrightarrow> ID p t' T\"", "lemma app_rule:\n  \"\\<lbrakk> ID f f' TYPE('a\\<Rightarrow>'b); ID x x' TYPE('a)\\<rbrakk> \\<Longrightarrow> ID (f$x) (f'$x') TYPE('b)\"", "lemma app'_rule:\n  \"\\<lbrakk> ID f f' TYPE('a\\<Rightarrow>'b); ID x x' TYPE('a)\\<rbrakk> \\<Longrightarrow> ID (f$'x) (f'$x') TYPE('b)\"", "lemma abs_rule:\n  \"\\<lbrakk> \\<And>x x'. ID x x' TYPE('a) \\<Longrightarrow> ID (t x) (t' x x') TYPE('b) \\<rbrakk> \\<Longrightarrow>\n    ID (\\<lambda>\\<^sub>2x. t x) (\\<lambda>\\<^sub>2x'. t' x' x') TYPE('a\\<Rightarrow>'b)\"", "lemma id_rule: \"c::\\<^sub>iI \\<Longrightarrow> ID c c I\"", "lemma annot_rule: \"ID t t' I \\<Longrightarrow> ID (t:::\\<^sub>iI) t' I\"", "lemma fallback_rule:\n  \"ID (c::'a) c TYPE('c)\"", "lemma unprotect_rl1: \"ID (PR_CONST x) t T \\<Longrightarrow> ID (UNPROTECT x) t T\"", "lemma pat_numeral[def_pat_rules]: \"numeral$x \\<equiv> UNPROTECT (numeral$x)\"", "lemma id_nat_const[id_rules]: \"(PR_CONST (a::nat)) ::\\<^sub>i TYPE(nat)\"", "lemma id_int_const[id_rules]: \"(PR_CONST (a::int)) ::\\<^sub>i TYPE(int)\""], "translations": [["", "lemma beta: \"(\\<lambda>\\<^sub>2x. f x)$x \\<equiv> f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. (#f x#)) $ x \\<equiv> f x", "by simp"], ["", "text \\<open>\n  Another version of @{const \"APP\"}. Treated like @{const APP} by our tool.\n  Required to avoid infinite pattern rewriting in some cases, e.g., map-lookup.\n\\<close>"], ["", "definition APP' (infixl \"$''\" 900) where [simp, autoref_tag_defs]: \"f$'a \\<equiv> f a\""], ["", "text \\<open>\n  Sometimes, whole terms should be protected from being processed by our tool.\n  For example, our tool should not look into numerals. For this reason,\n  the \\<open>PR_CONST\\<close> tag indicates terms that our tool shall handle as\n  atomic constants, an never look into them.\n\n  The special form \\<open>UNPROTECT\\<close> can be used inside pattern rewrite rules.\n  It has the effect to revert the protection from its argument, and then wrap\n  it into a \\<open>PR_CONST\\<close>.\n\\<close>"], ["", "definition [simp, autoref_tag_defs]: \"PR_CONST x \\<equiv> x\" \\<comment> \\<open>Tag to protect constant\\<close>"], ["", "definition [simp, autoref_tag_defs]: \"UNPROTECT x \\<equiv> x\" \\<comment> \\<open>Gets \n  converted to @{term PR_CONST}, after unprotecting its content\\<close>"], ["", "subsection \\<open>Operation Identification\\<close>"], ["", "text \\<open> Indicator predicate for conceptual typing of a constant \\<close>"], ["", "definition intf_type :: \"'a \\<Rightarrow> 'b itself \\<Rightarrow> bool\" (infix \"::\\<^sub>i\" 10) where\n  [simp]: \"c::\\<^sub>iI \\<equiv> True\""], ["", "lemma itypeI: \"c::\\<^sub>iI\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c ::\\<^sub>i I", "by simp"], ["", "lemma itypeI': \"intf_type c TYPE('T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c ::\\<^sub>i TYPE('T)", "by (rule itypeI)"], ["", "lemma itype_self: \"(c::'a) ::\\<^sub>i TYPE('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c ::\\<^sub>i TYPE('a)", "by simp"], ["", "definition CTYPE_ANNOT :: \"'b \\<Rightarrow> 'a itself \\<Rightarrow> 'b\" (infix \":::\\<^sub>i\" 10) where\n  [simp]: \"c:::\\<^sub>iI \\<equiv> c\""], ["", "text \\<open> Wrapper predicate for an conceptual type inference \\<close>"], ["", "definition ID :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'c itself \\<Rightarrow> bool\" \n  where [simp]: \"ID t t' T \\<equiv> t=t'\""], ["", "subsubsection \\<open>Conceptual Typing Rules\\<close>"], ["", "lemma ID_unfold_vars: \"ID x y T \\<Longrightarrow> x\\<equiv>y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ID x y T \\<Longrightarrow> x \\<equiv> y", "by simp"], ["", "lemma ID_PR_CONST_trigger: \"ID (PR_CONST x) y T \\<Longrightarrow> ID (PR_CONST x) y T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ID (PR_CONST x) y T \\<Longrightarrow> ID (PR_CONST x) y T", "."], ["", "lemma pat_rule:\n  \"\\<lbrakk> p\\<equiv>p'; ID p' t' T \\<rbrakk> \\<Longrightarrow> ID p t' T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<equiv> p'; ID p' t' T\\<rbrakk> \\<Longrightarrow> ID p t' T", "by simp"], ["", "lemma app_rule:\n  \"\\<lbrakk> ID f f' TYPE('a\\<Rightarrow>'b); ID x x' TYPE('a)\\<rbrakk> \\<Longrightarrow> ID (f$x) (f'$x') TYPE('b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ID f f' TYPE('a \\<Rightarrow> 'b); ID x x' TYPE('a)\\<rbrakk>\n    \\<Longrightarrow> ID (f $ x) (f' $ x') TYPE('b)", "by simp"], ["", "lemma app'_rule:\n  \"\\<lbrakk> ID f f' TYPE('a\\<Rightarrow>'b); ID x x' TYPE('a)\\<rbrakk> \\<Longrightarrow> ID (f$'x) (f'$x') TYPE('b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ID f f' TYPE('a \\<Rightarrow> 'b); ID x x' TYPE('a)\\<rbrakk>\n    \\<Longrightarrow> ID (f $' x) (f' $ x') TYPE('b)", "by simp"], ["", "lemma abs_rule:\n  \"\\<lbrakk> \\<And>x x'. ID x x' TYPE('a) \\<Longrightarrow> ID (t x) (t' x x') TYPE('b) \\<rbrakk> \\<Longrightarrow>\n    ID (\\<lambda>\\<^sub>2x. t x) (\\<lambda>\\<^sub>2x'. t' x' x') TYPE('a\\<Rightarrow>'b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x x'.\n        ID x x' TYPE('a) \\<Longrightarrow>\n        ID (t x) (t' x x') TYPE('b)) \\<Longrightarrow>\n    ID (\\<lambda>x. (#t x#)) (\\<lambda>x. (#t' x x#))\n     TYPE('a \\<Rightarrow> 'b)", "by simp"], ["", "lemma id_rule: \"c::\\<^sub>iI \\<Longrightarrow> ID c c I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c ::\\<^sub>i I \\<Longrightarrow> ID c c I", "by simp"], ["", "lemma annot_rule: \"ID t t' I \\<Longrightarrow> ID (t:::\\<^sub>iI) t' I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ID t t' I \\<Longrightarrow> ID (t :::\\<^sub>i I) t' I", "by simp"], ["", "lemma fallback_rule:\n  \"ID (c::'a) c TYPE('c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ID c c TYPE('c)", "by simp"], ["", "lemma unprotect_rl1: \"ID (PR_CONST x) t T \\<Longrightarrow> ID (UNPROTECT x) t T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ID (PR_CONST x) t T \\<Longrightarrow> ID (UNPROTECT x) t T", "by simp"], ["", "subsection \\<open> ML-Level code \\<close>"], ["", "ML \\<open>\ninfix 0 THEN_ELSE_COMB'\n\nsignature ID_OP_TACTICAL = sig\n  val SOLVE_FWD: tactic' -> tactic'\n  val DF_SOLVE_FWD: bool -> tactic' -> tactic'\nend\n\nstructure Id_Op_Tactical :ID_OP_TACTICAL = struct\n\n  fun SOLVE_FWD tac i st = SOLVED' (\n    tac \n    THEN_ALL_NEW_FWD (SOLVE_FWD tac)) i st\n\n\n  (* Search for solution with DFS-strategy. If dbg-flag is given,\n    return sequence of stuck states if no solution is found.\n  *)\n  fun DF_SOLVE_FWD dbg tac = let\n    val stuck_list_ref = Unsynchronized.ref []\n\n    fun stuck_tac _ st = if dbg then (\n      stuck_list_ref := st :: !stuck_list_ref;\n      Seq.empty\n    ) else Seq.empty\n\n    fun rec_tac i st = (\n        (tac THEN_ALL_NEW_FWD (SOLVED' rec_tac))\n        ORELSE' stuck_tac\n      ) i st\n\n    fun fail_tac _ _ = if dbg then\n      Seq.of_list (rev (!stuck_list_ref))\n    else Seq.empty\n  in\n    rec_tac ORELSE' fail_tac    \n  end\n\nend\n\\<close>"], ["", "named_theorems_rev id_rules \"Operation identification rules\""], ["", "named_theorems_rev pat_rules \"Operation pattern rules\""], ["", "named_theorems_rev def_pat_rules \"Definite operation pattern rules (not backtracked over)\""], ["", "ML \\<open>\n\n  structure Id_Op = struct\n\n    fun id_a_conv cnv ct = case Thm.term_of ct of\n      @{mpat \"ID _ _ _\"} => Conv.fun_conv (Conv.fun_conv (Conv.arg_conv cnv)) ct\n    | _ => raise CTERM(\"id_a_conv\",[ct])\n\n    fun \n      protect env (@{mpat \"?t:::\\<^sub>i?I\"}) = let\n        val t = protect env t\n      in \n        @{mk_term env: \"?t:::\\<^sub>i?I\"}\n      end\n    | protect _ (t as @{mpat \"PR_CONST _\"}) = t\n    | protect env (t1$t2) = let\n        val t1 = protect env t1\n        val t2 = protect env t2\n      in\n        @{mk_term env: \"?t1.0 $ ?t2.0\"}\n      end\n    | protect env (Abs (x,T,t)) = let\n        val t = protect (T::env) t\n      in\n        @{mk_term env: \"\\<lambda>v_x::?'v_T. PROTECT2 ?t DUMMY\"}\n      end\n    | protect _ t = t\n\n    fun protect_conv ctxt = Refine_Util.f_tac_conv ctxt\n      (protect []) \n      (simp_tac \n        (put_simpset HOL_basic_ss ctxt addsimps @{thms PROTECT2_def APP_def}) 1)\n\n    fun unprotect_conv ctxt\n      = Simplifier.rewrite (put_simpset HOL_basic_ss ctxt \n        addsimps @{thms PROTECT2_def APP_def})\n\n    fun do_unprotect_tac ctxt =\n      resolve_tac ctxt @{thms unprotect_rl1} THEN'\n      CONVERSION (Refine_Util.HOL_concl_conv (fn ctxt => id_a_conv (unprotect_conv ctxt)) ctxt)\n\n    val cfg_id_debug = \n      Attrib.setup_config_bool @{binding id_debug} (K false)\n\n    val cfg_id_trace_fallback = \n      Attrib.setup_config_bool @{binding id_trace_fallback} (K false)\n\n    fun dest_id_rl thm = case Thm.concl_of thm of\n      @{mpat (typs) \"Trueprop (?c::\\<^sub>iTYPE(?'v_T))\"} => (c,T)\n    | _ => raise THM(\"dest_id_rl\",~1,[thm])\n\n    \n    val add_id_rule = snd oo Thm.proof_attributes [Named_Theorems_Rev.add @{named_theorems_rev id_rules}]\n\n    datatype id_tac_mode = Init | Step | Normal | Solve\n\n    fun id_tac ss ctxt = let\n      open Id_Op_Tactical\n      val certT = Thm.ctyp_of ctxt\n      val cert = Thm.cterm_of ctxt\n\n      val thy = Proof_Context.theory_of ctxt\n\n      val id_rules = Named_Theorems_Rev.get ctxt @{named_theorems_rev id_rules}\n      val pat_rules = Named_Theorems_Rev.get ctxt @{named_theorems_rev pat_rules}\n      val def_pat_rules = Named_Theorems_Rev.get ctxt @{named_theorems_rev def_pat_rules}\n\n      val rl_net = Tactic.build_net (\n        (pat_rules |> map (fn thm => thm RS @{thm pat_rule})) \n        @ @{thms annot_rule app_rule app'_rule abs_rule} \n        @ (id_rules |> map (fn thm => thm RS @{thm id_rule}))\n      )\n\n      val def_rl_net = Tactic.build_net (\n        (def_pat_rules |> map (fn thm => thm RS @{thm pat_rule}))\n      )  \n\n      val id_pr_const_rename_tac = \n          resolve_tac ctxt @{thms ID_PR_CONST_trigger} THEN'\n          Subgoal.FOCUS (fn { context=ctxt, prems, ... } => \n            let\n              fun is_ID @{mpat \"Trueprop (ID _ _ _)\"} = true | is_ID _ = false\n              val prems = filter (Thm.prop_of #> is_ID) prems\n              val eqs = map (fn thm => thm RS @{thm ID_unfold_vars}) prems\n              val conv = Conv.rewrs_conv eqs\n              val conv = fn ctxt => (Conv.top_sweep_conv (K conv) ctxt)\n              val conv = fn ctxt => Conv.fun2_conv (Conv.arg_conv (conv ctxt))\n              val conv = Refine_Util.HOL_concl_conv conv ctxt\n            in CONVERSION conv 1 end \n          ) ctxt THEN'\n          resolve_tac ctxt @{thms id_rule} THEN'\n          resolve_tac ctxt id_rules \n\n      val ityping = id_rules \n        |> map dest_id_rl\n        |> filter (is_Const o #1)\n        |> map (apfst (#1 o dest_Const))\n        |> Symtab.make_list\n\n      val has_type = Symtab.defined ityping\n\n      fun mk_fallback name cT =\n        case try (Sign.the_const_constraint thy) name of\n          SOME T => try (Thm.instantiate' \n                          [SOME (certT cT), SOME (certT T)] [SOME (cert (Const (name,cT)))])\n                        @{thm fallback_rule} \n        | NONE => NONE\n\n      fun trace_fallback thm = \n        Config.get ctxt cfg_id_trace_fallback       \n        andalso let \n          open Pretty\n          val p = block [str \"ID_OP: Applying fallback rule: \", Thm.pretty_thm ctxt thm]\n        in \n          string_of p |> tracing; \n          false\n        end  \n\n      val fallback_tac = CONVERSION Thm.eta_conversion THEN' IF_EXGOAL (fn i => fn st =>\n        case Logic.concl_of_goal (Thm.prop_of st) i of\n          @{mpat \"Trueprop (ID (mpaq_STRUCT (mpaq_Const ?name ?cT)) _ _)\"} => (\n            if not (has_type name) then \n              case mk_fallback name cT of\n                SOME thm => (trace_fallback thm; resolve_tac ctxt [thm] i st)\n              | NONE => Seq.empty  \n            else Seq.empty\n          )\n        | _ => Seq.empty)\n\n      val init_tac = CONVERSION (\n        Refine_Util.HOL_concl_conv (fn ctxt => (id_a_conv (protect_conv ctxt))) \n          ctxt\n      )\n\n      val step_tac = (FIRST' [\n        assume_tac ctxt, \n        eresolve_tac ctxt @{thms id_rule},\n        resolve_from_net_tac ctxt def_rl_net, \n        resolve_from_net_tac ctxt rl_net, \n        id_pr_const_rename_tac,\n        do_unprotect_tac ctxt, \n        fallback_tac])\n\n      val solve_tac = DF_SOLVE_FWD (Config.get ctxt cfg_id_debug) step_tac  \n\n    in\n      case ss of\n        Init => init_tac \n      | Step => step_tac \n      | Normal => init_tac THEN' solve_tac\n      | Solve => solve_tac\n\n    end\n\n  end\n\n\\<close>"], ["", "subsection \\<open>Default Setup\\<close>"], ["", "subsubsection \\<open>Numerals\\<close>"], ["", "lemma pat_numeral[def_pat_rules]: \"numeral$x \\<equiv> UNPROTECT (numeral$x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. numeral $ x \\<equiv> UNPROTECT (numeral $ x)", "by simp"], ["", "lemma id_nat_const[id_rules]: \"(PR_CONST (a::nat)) ::\\<^sub>i TYPE(nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PR_CONST a ::\\<^sub>i TYPE(nat)", "by simp"], ["", "lemma id_int_const[id_rules]: \"(PR_CONST (a::int)) ::\\<^sub>i TYPE(int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PR_CONST a ::\\<^sub>i TYPE(int)", "by simp"], ["", "(*subsection \\<open>Example\\<close>\nschematic_lemma \n  \"ID (\\<lambda>a b. (b(1::int\\<mapsto>2::nat) |`(-{3})) a, Map.empty, \\<lambda>a. case a of None \\<Rightarrow> Some a | Some _ \\<Rightarrow> None) (?c) (?T::?'d itself)\"\n  (*\"TERM (?c,?T)\"*)\n  using [[id_debug]]\n  apply (tactic {* Id_Op.id_tac Id_Op.Normal @{context} 1  *})  \n  done\n*)"], ["", "end"]]}