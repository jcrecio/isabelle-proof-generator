{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/Examples/Sepref_Minitests.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemma [sepref_fr_rules]: \"(uncurry mop_plusi,uncurry mop_plus) \\<in> nat_assn\\<^sup>k*\\<^sub>anat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\"", "lemma ID_unfold_vars: \"ID x y T \\<Longrightarrow> x\\<equiv>y\"", "lemmas [id_rules] = \n  itypeI[Pure.of RECT \"TYPE ((('a \\<Rightarrow> 'b) \\<Rightarrow> 'a \\<Rightarrow> 'b) \\<Rightarrow> 'a \\<Rightarrow> 'b)\"]\n  itypeI[Pure.of case_list \"TYPE('a \\<Rightarrow> ('b \\<Rightarrow> 'b list \\<Rightarrow> 'a) \\<Rightarrow> 'b list \\<Rightarrow> 'a)\"]", "lemma\n \"ias_ins k a = do {\n    l\\<leftarrow>Array.len a;\n    if k<l then \n      Array.upd k True a\n    else do {\n      let newsz = max (k+1) (2 * l + 3);\n      a\\<leftarrow>Array_Blit.array_grow a newsz False;\n      Array.upd k True a\n    }    \n  }\"", "lemmas [sepref_fr_rules] = smart_match_test1_impl.refine"], "translations": [["", "lemma [sepref_fr_rules]: \"(uncurry mop_plusi,uncurry mop_plus) \\<in> nat_assn\\<^sup>k*\\<^sub>anat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry mop_plusi, uncurry mop_plus)\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "by (sep_auto intro!: hfrefI hn_refineI simp: pure_def)"], ["", "sepref_register mop_plus"], ["", "sepref_definition copy_test is \"(\\<lambda>x. do {\n    let y = x+ x;\n    mop_plus y y\n    })\" :: \"((nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a UNSPEC)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, \\<lambda>x. let y = x + x in mop_plus y y)\n    \\<in> nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a ?S'1", "by sepref"], ["", "definition \"bar s \\<equiv> do {\n    x\\<leftarrow>RETURN (insert (1::nat) s);\n    y\\<leftarrow>RETURN (insert (1::nat) x);\n    ASSERT (y\\<noteq>{});\n    if 1\\<in>y then\n      RETURN (y)\n    else RETURN (insert (1::nat) y)\n  }\""], ["", "definition \"bar2 s \\<equiv> do {\n    if (1::nat)\\<in>s then\n      RETURN True\n    else RETURN False\n  }\""], ["", "definition \"bar' \\<equiv> do {\n    y \\<leftarrow> RETURN {1,1::nat};\n    if 1\\<in>y then\n      RETURN (y)\n    else RETURN (insert 1 y)\n  }\""], ["", "definition \"foo \\<equiv> do {\n  s \\<leftarrow> RETURN [1,1,1::nat];\n  y \\<leftarrow> RETURN ({}::nat set);\n  RECT (\\<lambda>D l. \n    case l of \n      [] \\<Rightarrow> RETURN (case [0,1] of [] \\<Rightarrow> {} | x#xs \\<Rightarrow> {x})\n    | x#l \\<Rightarrow> do {\n        \\<^cancel>\\<open>r \\<leftarrow> RETURN (y\\<union>y);\\<close>\n        r \\<leftarrow> D l;\n        \\<^cancel>\\<open>RETURN (insert (x+1) r)\\<close>\n        RETURN (if x<1 then insert x r else insert (x+1) r)\n    }) s\n  }\n\""], ["", "definition \"simple_rec \\<equiv> do {\n  RECT (\\<lambda>D l. case l of \n    [] \\<Rightarrow> RETURN 0 \n  | x#xs \\<Rightarrow> do {\n      a\\<leftarrow>D xs;\n      RETURN (a+x)\n    }\n  ) [1,0::nat]\n}\""], ["", "definition \"simple_while \\<equiv> do {\n  WHILEIT (\\<lambda>(i,m). i \\<notin> dom m) (\\<lambda>(i,m). i\\<ge>1) (\\<lambda>(i,m). do {\n    let i=i+1;\n    RETURN (i,m)\n  }) (10::nat, Map.empty::nat \\<rightharpoonup> nat)\n}\""], ["", "definition \"lst_mem_to_sets \\<equiv> do {\n  l\\<leftarrow>RETURN [0,1,0::nat];\n  RECT (\\<lambda>D l. \n    case l of \n      [] \\<Rightarrow> RETURN []\n    | x#l \\<Rightarrow> do {\n        r \\<leftarrow> D l;\n        RETURN ({x}#r)\n    }) l\n  }\n\""], ["", "definition \"lst_mem_to_sets_nonlin \\<equiv> do {\n  l\\<leftarrow>RETURN [0,1,0::nat];\n  RECT (\\<lambda>D l. \n    case l of \n      [] \\<Rightarrow> RETURN []\n    | x#l \\<Rightarrow> do {\n        r \\<leftarrow> D l;\n        RETURN ({x,x}#r)\n    }) l\n  }\n\""], ["", "definition \"lst_mem_to_sets_nonlin2 \\<equiv> do {\n  l\\<leftarrow>RETURN [0,1,0::nat];\n  RECT (\\<lambda>D l. \n    case l of \n      [] \\<Rightarrow> RETURN []\n    | x#l \\<Rightarrow> do {\n        r \\<leftarrow> D l;\n        RETURN ({x}#r@r)\n    }) l\n  }\n\""], ["", "definition \"lst_nonlin \\<equiv> do {\n  l\\<leftarrow>RETURN [0::nat];\n  RETURN (case l of [] \\<Rightarrow> l | x#xs \\<Rightarrow> x#l)\n}\""], ["", "definition \"lst_nonlin2 \\<equiv> do {\n  l\\<leftarrow>RETURN [0::nat];\n  RETURN (case l of [] \\<Rightarrow> [] | x#xs \\<Rightarrow> x#(x#xs))\n}\""], ["", "definition \"lst_nonlin3 \\<equiv> do {\n  l\\<leftarrow>RETURN [{0::nat}];\n  RETURN (case l of [] \\<Rightarrow> [] | x#xs \\<Rightarrow> x#(x#xs))\n}\""], ["", "definition \"lst_nonlin4 \\<equiv> do {\n  l\\<leftarrow>RETURN [{0::nat}];\n  RETURN (l@l)\n}\""], ["", "definition \"dup_arg == do {\n  x <- RETURN [1::nat];\n  RETURN (x@x)\n}\""], ["", "definition \"big_list == RETURN [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1::nat]\""], ["", "definition \"big_list2 == do {\n  x1 <- RETURN ({}::nat set);\n  x2 <- RETURN {};\n  x3 <- RETURN {};\n  x4 <- RETURN {};\n  x5 <- RETURN {};\n  x6 <- RETURN {};\n  x7 <- RETURN {};\n  x8 <- RETURN {};\n\\<^cancel>\\<open>  x9 <- RETURN {};\n  x10 <- RETURN {};\n  x11 <- RETURN {};\n  x12 <- RETURN {};\n  x13 <- RETURN {};\n  x14 <- RETURN {};\n  x15 <- RETURN {};\n  x16 <- RETURN {};\\<close>\n  RETURN [x1,x2,x3,x4,x5,x6,x7,x8\\<^cancel>\\<open>,x9,x10,x11,x12,x13,x14,x14,x15,x16]\\<close>]\n}\""], ["", "term Set.insert"], ["", "definition \"foo1 \\<equiv> \n  case [] of \n    [] \\<Rightarrow> RETURN {} \n  | x#l \\<Rightarrow> do {\n      r \\<leftarrow> RETURN ({}::nat set);\n      RETURN (if x<1 then insert x r else insert x r)\n  }\n\""], ["", "definition \"basic_foreach \\<equiv> do {\n  FOREACH\\<^sub>C {0,1::nat} (\\<lambda>s. s>1) (\\<lambda>x s. RETURN (x+s)) 0\n}\""], ["", "definition \"basic_foreach2 \\<equiv> do {\n  FOREACH\\<^sub>C {0,1::nat} (\\<lambda>_. True) (\\<lambda>x s. RETURN (insert x s)) {}\n}\""], ["", "definition \"basic_option \\<equiv> do {\n  let a={};\n  let b=Some a;\n  let c=Some (0::nat);\n  let d=Some (1::nat);\n  RETURN (b,c=d)\n}\""], ["", "definition dfs :: \"(('a\\<times>'a) set) \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> ('a set \\<times> bool) nres\" \n  where\n  \"\\<And>E vd v0. dfs E vd v0 \\<equiv> REC\\<^sub>T (\\<lambda>D (V,v). \n    if v=vd then RETURN (V,True)\n    else if v\\<in>V then RETURN (V,False)\n    else do {\n      let V=insert v V;\n      FOREACH\\<^sub>C (E``{v}) (\\<lambda>(_,b). b=False) (\\<lambda>v' (V,_). D (V,v')) (V,False) }\n  ) ({},v0)\""], ["", "lemma ID_unfold_vars: \"ID x y T \\<Longrightarrow> x\\<equiv>y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ID x y T \\<Longrightarrow> x \\<equiv> y", "by simp"], ["", "schematic_goal testsuite_basic_param:\n  fixes s\n  notes [id_rules] = \n    itypeI[Pure.of s \"TYPE(nat set)\"]\n  shows \n    \"hn_refine (emp * hn_ctxt (hs.assn id_assn) s s') (?c1::?'c1 Heap) ?\\<Gamma>1' ?R1 (bar s)\"\n    \"hn_refine (emp * hn_ctxt (hs.assn id_assn) s s') (?c2::?'c2 Heap) ?\\<Gamma>2' ?R2 (bar2 s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (emp * hn_ctxt (hs.assn nat_assn) s s') ?c1 ?\\<Gamma>1' ?R1\n     (bar s) &&&\n    hn_refine (emp * hn_ctxt (hs.assn nat_assn) s s') ?c2 ?\\<Gamma>2' ?R2\n     (bar2 s)", "unfolding bar_def bar2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (emp * hn_ctxt (hs.assn nat_assn) s s') ?c1 ?\\<Gamma>1' ?R1\n     (RETURN (insert 1 s) \\<bind>\n      (\\<lambda>x.\n          RETURN (insert 1 x) \\<bind>\n          (\\<lambda>y.\n              ASSERT (y \\<noteq> {}) \\<bind>\n              (\\<lambda>_.\n                  if 1 \\<in> y then RETURN y\n                  else RETURN (insert 1 y))))) &&&\n    hn_refine (emp * hn_ctxt (hs.assn nat_assn) s s') ?c2 ?\\<Gamma>2' ?R2\n     (if 1 \\<in> s then RETURN True else RETURN False)", "using [[id_debug]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (emp * hn_ctxt (hs.assn nat_assn) s s') ?c1 ?\\<Gamma>1' ?R1\n     (RETURN (insert 1 s) \\<bind>\n      (\\<lambda>x.\n          RETURN (insert 1 x) \\<bind>\n          (\\<lambda>y.\n              ASSERT (y \\<noteq> {}) \\<bind>\n              (\\<lambda>_.\n                  if 1 \\<in> y then RETURN y\n                  else RETURN (insert 1 y))))) &&&\n    hn_refine (emp * hn_ctxt (hs.assn nat_assn) s s') ?c2 ?\\<Gamma>2' ?R2\n     (if 1 \\<in> s then RETURN True else RETURN False)", "by sepref+"], ["", "term case_list"], ["", "thm id_rules"], ["", "lemmas [id_rules] = \n  itypeI[Pure.of RECT \"TYPE ((('a \\<Rightarrow> 'b) \\<Rightarrow> 'a \\<Rightarrow> 'b) \\<Rightarrow> 'a \\<Rightarrow> 'b)\"]\n  itypeI[Pure.of case_list \"TYPE('a \\<Rightarrow> ('b \\<Rightarrow> 'b list \\<Rightarrow> 'a) \\<Rightarrow> 'b list \\<Rightarrow> 'a)\"]"], ["", "ML \\<open>\n  fun is_eta_norm t = t aconv (Envir.eta_contract t)\n\n\n  fun find_not_eta_norm (a$b) = (find_not_eta_norm a @ find_not_eta_norm b)\n    | find_not_eta_norm (t as Abs (_,_,t'$Bound 0)) = t :: find_not_eta_norm t'\n    | find_not_eta_norm (Abs (_,_,t)) = find_not_eta_norm t\n    | find_not_eta_norm _ = []\n\n  fun is_eta_norm_tac st = if is_eta_norm (Thm.prop_of st) then Seq.single st\n    else (raise TERM (\"\\<not>eta-norm\",find_not_eta_norm (Thm.prop_of st)))\n\n\\<close>"], ["", "definition \"xfoo \\<equiv> do {\n  s \\<leftarrow> RETURN [1::nat];\n  y \\<leftarrow> RETURN ({}::nat set);\n  RECT (\\<lambda>D l. \n    case l of \n      [] \\<Rightarrow> RETURN ({0})\n    | x#l \\<Rightarrow> do {\n        r \\<leftarrow> D l;\n        RETURN (insert x r)\n    }) s\n  }\n\""], ["", "schematic_goal testsuite_basic1:\n  notes [sepref_fr_rules] = HOL_list_empty_hnr hs.hnr_op_empty[of nat_assn] (* TODO: handle open relations *)\n  shows \"hn_refine emp (?c1::?'c1 Heap) ?\\<Gamma>1' ?R1 bar'\"\n  and \"hn_refine emp (?c2::?'c2 Heap) ?\\<Gamma>2' ?R2 foo\"\n  and \"hn_refine emp (?c3::?'c3 Heap) ?\\<Gamma>3' ?R3 simple_rec\"\n  and \"hn_refine emp (?c4::?'c4 Heap) ?\\<Gamma>4' ?R4 lst_mem_to_sets\"\n  and \"hn_refine emp (?c5::?'c5 Heap) ?\\<Gamma>5' ?R5 lst_mem_to_sets_nonlin\"\n  (*and \"hn_refine emp (?c6::?'c6 Heap) ?\\<Gamma>6' ?R6 lst_mem_to_sets_nonlin2\"*)\n  and \"hn_refine emp (?c7::?'c7 Heap) ?\\<Gamma>7' ?R7 lst_nonlin\"\n  and \"hn_refine emp (?c8::?'c8 Heap) ?\\<Gamma>8' ?R8 lst_nonlin2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hn_refine emp ?c1 ?\\<Gamma>1' ?R1 bar' &&&\n     hn_refine emp ?c2 ?\\<Gamma>2' ?R2 foo &&&\n     hn_refine emp ?c3 ?\\<Gamma>3' ?R3 simple_rec) &&&\n    (hn_refine emp ?c4 ?\\<Gamma>4' ?R4 lst_mem_to_sets &&&\n     hn_refine emp ?c5 ?\\<Gamma>5' ?R5 lst_mem_to_sets_nonlin) &&&\n    hn_refine emp ?c7 ?\\<Gamma>7' ?R7 lst_nonlin &&&\n    hn_refine emp ?c8 ?\\<Gamma>8' ?R8 lst_nonlin2", "(*and \"hn_refine emp (?c9::?'c9 Heap) ?\\<Gamma>9' ?R9 lst_nonlin3\"*)\n  (*and \"hn_refine emp (?ca::?'ca Heap) ?\\<Gamma>a' ?Ra lst_nonlin4\"*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (hn_refine emp ?c1 ?\\<Gamma>1' ?R1 bar' &&&\n     hn_refine emp ?c2 ?\\<Gamma>2' ?R2 foo &&&\n     hn_refine emp ?c3 ?\\<Gamma>3' ?R3 simple_rec) &&&\n    (hn_refine emp ?c4 ?\\<Gamma>4' ?R4 lst_mem_to_sets &&&\n     hn_refine emp ?c5 ?\\<Gamma>5' ?R5 lst_mem_to_sets_nonlin) &&&\n    hn_refine emp ?c7 ?\\<Gamma>7' ?R7 lst_nonlin &&&\n    hn_refine emp ?c8 ?\\<Gamma>8' ?R8 lst_nonlin2", "unfolding bar'_def foo_def simple_rec_def lst_mem_to_sets_def \n    lst_mem_to_sets_nonlin_def lst_mem_to_sets_nonlin2_def\n    lst_nonlin_def lst_nonlin2_def lst_nonlin3_def lst_nonlin4_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (hn_refine emp ?c1 ?\\<Gamma>1' ?R1\n      (RETURN {1, 1} \\<bind>\n       (\\<lambda>y.\n           if 1 \\<in> y then RETURN y else RETURN (insert 1 y))) &&&\n     hn_refine emp ?c2 ?\\<Gamma>2' ?R2\n      (RETURN [1, 1, 1] \\<bind>\n       (\\<lambda>s.\n           RETURN {} \\<bind>\n           (\\<lambda>y.\n               REC\\<^sub>T\n                (\\<lambda>D l.\n                    case l of\n                    [] \\<Rightarrow>\n                      RETURN\n                       (case [0, 1] of [] \\<Rightarrow> {}\n                        | x # xs \\<Rightarrow> {x})\n                    | x # l \\<Rightarrow>\n                        D l \\<bind>\n                        (\\<lambda>r.\n                            RETURN\n                             (if x < 1 then insert x r\n                              else insert (x + 1) r)))\n                s))) &&&\n     hn_refine emp ?c3 ?\\<Gamma>3' ?R3\n      (REC\\<^sub>T\n        (\\<lambda>D l.\n            case l of [] \\<Rightarrow> RETURN 0\n            | x # xs \\<Rightarrow>\n                D xs \\<bind> (\\<lambda>a. RETURN (a + x)))\n        [1, 0])) &&&\n    (hn_refine emp ?c4 ?\\<Gamma>4' ?R4\n      (RETURN [0, 1, 0] \\<bind>\n       REC\\<^sub>T\n        (\\<lambda>D l.\n            case l of [] \\<Rightarrow> RETURN []\n            | x # l \\<Rightarrow>\n                D l \\<bind> (\\<lambda>r. RETURN ({x} # r)))) &&&\n     hn_refine emp ?c5 ?\\<Gamma>5' ?R5\n      (RETURN [0, 1, 0] \\<bind>\n       REC\\<^sub>T\n        (\\<lambda>D l.\n            case l of [] \\<Rightarrow> RETURN []\n            | x # l \\<Rightarrow>\n                D l \\<bind> (\\<lambda>r. RETURN ({x, x} # r))))) &&&\n    hn_refine emp ?c7 ?\\<Gamma>7' ?R7\n     (RETURN [0] \\<bind>\n      (\\<lambda>l.\n          RETURN\n           (case l of [] \\<Rightarrow> l | x # xs \\<Rightarrow> x # l))) &&&\n    hn_refine emp ?c8 ?\\<Gamma>8' ?R8\n     (RETURN [0] \\<bind>\n      (\\<lambda>l.\n          RETURN\n           (case l of [] \\<Rightarrow> []\n            | x # xs \\<Rightarrow> x # x # xs)))", "using [[goals_limit = 1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (hn_refine emp ?c1 ?\\<Gamma>1' ?R1\n      (RETURN {1, 1} \\<bind>\n       (\\<lambda>y.\n           if 1 \\<in> y then RETURN y else RETURN (insert 1 y))) &&&\n     hn_refine emp ?c2 ?\\<Gamma>2' ?R2\n      (RETURN [1, 1, 1] \\<bind>\n       (\\<lambda>s.\n           RETURN {} \\<bind>\n           (\\<lambda>y.\n               REC\\<^sub>T\n                (\\<lambda>D l.\n                    case l of\n                    [] \\<Rightarrow>\n                      RETURN\n                       (case [0, 1] of [] \\<Rightarrow> {}\n                        | x # xs \\<Rightarrow> {x})\n                    | x # l \\<Rightarrow>\n                        D l \\<bind>\n                        (\\<lambda>r.\n                            RETURN\n                             (if x < 1 then insert x r\n                              else insert (x + 1) r)))\n                s))) &&&\n     hn_refine emp ?c3 ?\\<Gamma>3' ?R3\n      (REC\\<^sub>T\n        (\\<lambda>D l.\n            case l of [] \\<Rightarrow> RETURN 0\n            | x # xs \\<Rightarrow>\n                D xs \\<bind> (\\<lambda>a. RETURN (a + x)))\n        [1, 0])) &&&\n    (hn_refine emp ?c4 ?\\<Gamma>4' ?R4\n      (RETURN [0, 1, 0] \\<bind>\n       REC\\<^sub>T\n        (\\<lambda>D l.\n            case l of [] \\<Rightarrow> RETURN []\n            | x # l \\<Rightarrow>\n                D l \\<bind> (\\<lambda>r. RETURN ({x} # r)))) &&&\n     hn_refine emp ?c5 ?\\<Gamma>5' ?R5\n      (RETURN [0, 1, 0] \\<bind>\n       REC\\<^sub>T\n        (\\<lambda>D l.\n            case l of [] \\<Rightarrow> RETURN []\n            | x # l \\<Rightarrow>\n                D l \\<bind> (\\<lambda>r. RETURN ({x, x} # r))))) &&&\n    hn_refine emp ?c7 ?\\<Gamma>7' ?R7\n     (RETURN [0] \\<bind>\n      (\\<lambda>l.\n          RETURN\n           (case l of [] \\<Rightarrow> l | x # xs \\<Rightarrow> x # l))) &&&\n    hn_refine emp ?c8 ?\\<Gamma>8' ?R8\n     (RETURN [0] \\<bind>\n      (\\<lambda>l.\n          RETURN\n           (case l of [] \\<Rightarrow> []\n            | x # xs \\<Rightarrow> x # x # xs)))", "apply sepref+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "schematic_goal testsuite_basic2:\n  notes [sepref_fr_rules] = HOL_list_empty_hnr hs.hnr_op_empty hm.empty_hnr\n  shows \"hn_refine emp (?c1::?'c1 Heap) ?\\<Gamma>1' ?R1 dup_arg\"\n  and \"hn_refine emp (?c2::?'c2 Heap) ?\\<Gamma>2' ?R2 big_list\"\n  and \"hn_refine emp (?c3::?'c3 Heap) ?\\<Gamma>3' ?R3 big_list2\"\n  and \"hn_refine emp (?c4::?'c4 Heap) ?\\<Gamma>4' ?R4 foo1\"\n  and \"hn_refine emp (?c5::?'c5 Heap) ?\\<Gamma>5' ?R5 basic_foreach\"\n  and \"hn_refine emp (?c6::?'c6 Heap) ?\\<Gamma>6' ?R6 basic_foreach2\"\n  and \"hn_refine emp (?c7::?'c7 Heap) ?\\<Gamma>7' ?R7 basic_option\"\n  and \"hn_refine emp (?c8::?'c8 Heap) ?\\<Gamma>8' ?R8 simple_while\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((hn_refine emp ?c1 ?\\<Gamma>1' ?R1 dup_arg &&&\n      hn_refine emp ?c2 ?\\<Gamma>2' ?R2 big_list) &&&\n     hn_refine emp ?c3 ?\\<Gamma>3' ?R3 big_list2 &&&\n     hn_refine emp ?c4 ?\\<Gamma>4' ?R4 foo1) &&&\n    (hn_refine emp ?c5 ?\\<Gamma>5' ?R5 basic_foreach &&&\n     hn_refine emp ?c6 ?\\<Gamma>6' ?R6 basic_foreach2) &&&\n    hn_refine emp ?c7 ?\\<Gamma>7' ?R7 basic_option &&&\n    hn_refine emp ?c8 ?\\<Gamma>8' ?R8 simple_while", "unfolding dup_arg_def big_list_def big_list2_def foo1_def \n    basic_foreach_def basic_foreach2_def simple_while_def\n    basic_option_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((hn_refine emp ?c1 ?\\<Gamma>1' ?R1\n       (RETURN [1] \\<bind> (\\<lambda>x. RETURN (x @ x))) &&&\n      hn_refine emp ?c2 ?\\<Gamma>2' ?R2\n       (RETURN\n         [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n          1])) &&&\n     hn_refine emp ?c3 ?\\<Gamma>3' ?R3\n      (RETURN {} \\<bind>\n       (\\<lambda>x1.\n           RETURN {} \\<bind>\n           (\\<lambda>x2.\n               RETURN {} \\<bind>\n               (\\<lambda>x3.\n                   RETURN {} \\<bind>\n                   (\\<lambda>x4.\n                       RETURN {} \\<bind>\n                       (\\<lambda>x5.\n                           RETURN {} \\<bind>\n                           (\\<lambda>x6.\n                               RETURN {} \\<bind>\n                               (\\<lambda>x7.\n                                   RETURN {} \\<bind>\n                                   (\\<lambda>x8.\n RETURN [x1, x2, x3, x4, x5, x6, x7, x8]))))))))) &&&\n     hn_refine emp ?c4 ?\\<Gamma>4' ?R4\n      (case [] of [] \\<Rightarrow> RETURN {}\n       | x # l \\<Rightarrow>\n           RETURN {} \\<bind>\n           (\\<lambda>r.\n               RETURN (if x < 1 then insert x r else insert x r)))) &&&\n    (hn_refine emp ?c5 ?\\<Gamma>5' ?R5\n      (FOREACH\\<^sub>C {0, 1} ((<) 1) (\\<lambda>x s. RETURN (x + s)) 0) &&&\n     hn_refine emp ?c6 ?\\<Gamma>6' ?R6\n      (FOREACH\\<^sub>C {0, 1} (\\<lambda>_. True)\n        (\\<lambda>x s. RETURN (insert x s)) {})) &&&\n    hn_refine emp ?c7 ?\\<Gamma>7' ?R7\n     (let a = {}; b = Some a; c = Some 0; d = Some 1\n      in RETURN (b, c = d)) &&&\n    hn_refine emp ?c8 ?\\<Gamma>8' ?R8\n     (WHILE\\<^sub>T\\<^bsup>\\<lambda>(i, m). i \\<notin> dom m\\<^esup>\n       (\\<lambda>(i, m). 1 \\<le> i)\n       (\\<lambda>(i, m). let i = i + 1 in RETURN (i, m)) (10, Map.empty))", "using [[goals_limit = 1, id_debug]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((hn_refine emp ?c1 ?\\<Gamma>1' ?R1\n       (RETURN [1] \\<bind> (\\<lambda>x. RETURN (x @ x))) &&&\n      hn_refine emp ?c2 ?\\<Gamma>2' ?R2\n       (RETURN\n         [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n          1])) &&&\n     hn_refine emp ?c3 ?\\<Gamma>3' ?R3\n      (RETURN {} \\<bind>\n       (\\<lambda>x1.\n           RETURN {} \\<bind>\n           (\\<lambda>x2.\n               RETURN {} \\<bind>\n               (\\<lambda>x3.\n                   RETURN {} \\<bind>\n                   (\\<lambda>x4.\n                       RETURN {} \\<bind>\n                       (\\<lambda>x5.\n                           RETURN {} \\<bind>\n                           (\\<lambda>x6.\n                               RETURN {} \\<bind>\n                               (\\<lambda>x7.\n                                   RETURN {} \\<bind>\n                                   (\\<lambda>x8.\n RETURN [x1, x2, x3, x4, x5, x6, x7, x8]))))))))) &&&\n     hn_refine emp ?c4 ?\\<Gamma>4' ?R4\n      (case [] of [] \\<Rightarrow> RETURN {}\n       | x # l \\<Rightarrow>\n           RETURN {} \\<bind>\n           (\\<lambda>r.\n               RETURN (if x < 1 then insert x r else insert x r)))) &&&\n    (hn_refine emp ?c5 ?\\<Gamma>5' ?R5\n      (FOREACH\\<^sub>C {0, 1} ((<) 1) (\\<lambda>x s. RETURN (x + s)) 0) &&&\n     hn_refine emp ?c6 ?\\<Gamma>6' ?R6\n      (FOREACH\\<^sub>C {0, 1} (\\<lambda>_. True)\n        (\\<lambda>x s. RETURN (insert x s)) {})) &&&\n    hn_refine emp ?c7 ?\\<Gamma>7' ?R7\n     (let a = {}; b = Some a; c = Some 0; d = Some 1\n      in RETURN (b, c = d)) &&&\n    hn_refine emp ?c8 ?\\<Gamma>8' ?R8\n     (WHILE\\<^sub>T\\<^bsup>\\<lambda>(i, m). i \\<notin> dom m\\<^esup>\n       (\\<lambda>(i, m). 1 \\<le> i)\n       (\\<lambda>(i, m). let i = i + 1 in RETURN (i, m)) (10, Map.empty))", "apply sepref+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "sepref_definition imp_dfs is \"uncurry2 dfs\" :: \"((adjg_assn nat_assn)\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a prod_assn (hs.assn nat_assn) bool_assn)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3, uncurry2 dfs)\n    \\<in> (adjg_assn nat_assn)\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a hs.assn\n            nat_assn \\<times>\\<^sub>a\n           bool_assn", "unfolding dfs_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>E vd v0.\n          REC\\<^sub>T\n           (\\<lambda>D (V, v).\n               if v = vd then RETURN (V, True)\n               else if v \\<in> V then RETURN (V, False)\n                    else let V = insert v V\n                         in FOREACH\\<^sub>C (E `` {v})\n                             (\\<lambda>(uu_, b). b = False)\n                             (\\<lambda>v' (V, uu_). D (V, v')) (V, False))\n           ({}, v0)))\n    \\<in> (adjg_assn nat_assn)\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a hs.assn\n            nat_assn \\<times>\\<^sub>a\n           bool_assn", "apply (rewrite in \"FOREACHc \\<hole>\" op_graph_succ_def[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>E vd v0.\n          REC\\<^sub>T\n           (\\<lambda>D (V, v).\n               if v = vd then RETURN (V, True)\n               else if v \\<in> V then RETURN (V, False)\n                    else let V = insert v V\n                         in FOREACH\\<^sub>C (op_graph_succ E v)\n                             (\\<lambda>(uu_, b). b = False)\n                             (\\<lambda>v' (V, uu_). D (V, v')) (V, False))\n           ({}, v0)))\n    \\<in> (adjg_assn nat_assn)\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a hs.assn\n            nat_assn \\<times>\\<^sub>a\n           bool_assn", "apply (rewrite in \"(\\<hole>,_)\" hs.fold_custom_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>E vd v0.\n          REC\\<^sub>T\n           (\\<lambda>D (V, v).\n               if v = vd then RETURN (V, True)\n               else if v \\<in> V then RETURN (V, False)\n                    else let V = insert v V\n                         in FOREACH\\<^sub>C (op_graph_succ E v)\n                             (\\<lambda>(uu_, b). b = False)\n                             (\\<lambda>v' (V, uu_). D (V, v')) (V, False))\n           (op_hs_empty, v0)))\n    \\<in> (adjg_assn nat_assn)\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a hs.assn\n            nat_assn \\<times>\\<^sub>a\n           bool_assn", "using [[goals_limit = 1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>E vd v0.\n          REC\\<^sub>T\n           (\\<lambda>D (V, v).\n               if v = vd then RETURN (V, True)\n               else if v \\<in> V then RETURN (V, False)\n                    else let V = insert v V\n                         in FOREACH\\<^sub>C (op_graph_succ E v)\n                             (\\<lambda>(uu_, b). b = False)\n                             (\\<lambda>v' (V, uu_). D (V, v')) (V, False))\n           (op_hs_empty, v0)))\n    \\<in> (adjg_assn nat_assn)\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a hs.assn\n            nat_assn \\<times>\\<^sub>a\n           bool_assn", "by sepref"], ["", "export_code imp_dfs checking SML_imp"], ["", "definition \"simple_algo a c m x = do {\n  let s = {m};\n  RECT (\\<lambda>D (x,s,l).\n    if x\\<in>s then RETURN l\n    else D ((a*x+c) mod m,insert x s,l+1)\n  ) (x::nat,s,0::nat)\n}\""], ["", "schematic_goal sa_impl:\n  notes [autoref_tyrel] = ty_REL[where 'a = \"nat set\" \n    and R=\"\\<langle>nat_rel\\<rangle>iam_set_rel\"]\n  assumes [autoref_rules]: \"(a,a)\\<in>nat_rel\" \n  assumes [autoref_rules]: \"(c,c)\\<in>nat_rel\" \n  assumes [autoref_rules]: \"(m,m)\\<in>nat_rel\" \n  assumes [autoref_rules]: \"(x,x)\\<in>nat_rel\" \n  shows \"(?c::?'c,simple_algo a c m x)\\<in>?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, simple_algo a c m x) \\<in> ?R", "unfolding simple_algo_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     let s = {m}\n     in REC\\<^sub>T\n         (\\<lambda>D (x, s, l).\n             if x \\<in> s then RETURN l\n             else D ((a * x + c) mod m, insert x s, l + 1))\n         (x, s, 0))\n    \\<in> ?R", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     let s = {m}\n     in REC\\<^sub>T\n         (\\<lambda>D (x, s, l).\n             if x \\<in> s then RETURN l\n             else D ((a * x + c) mod m, insert x s, l + 1))\n         (x, s, 0))\n    \\<in> ?R", "apply autoref_monadic"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition sa_impl uses sa_impl"], ["", "prepare_code_thms sa_impl_def"], ["", "export_code sa_impl checking SML"], ["", "sepref_definition sai_impl is \n    \"(uncurry2 (uncurry simple_algo))\" \n  :: \"(nat_assn\\<^sup>k*\\<^sub>anat_assn\\<^sup>k*\\<^sub>anat_assn\\<^sup>k*\\<^sub>anat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (uncurry ?f4), uncurry2 (uncurry simple_algo))\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "unfolding simple_algo_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (uncurry ?f4),\n     uncurry2\n      (uncurry\n        (\\<lambda>a c m x.\n            let s = {m}\n            in REC\\<^sub>T\n                (\\<lambda>D (x, s, l).\n                    if x \\<in> s then RETURN l\n                    else D ((a * x + c) mod m, insert x s, l + 1))\n                (x, s, 0))))\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "unfolding ias.fold_custom_empty"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (uncurry ?f4),\n     uncurry2\n      (uncurry\n        (\\<lambda>a c m x.\n            let s = insert m op_ias_empty\n            in REC\\<^sub>T\n                (\\<lambda>D (x, s, l).\n                    if x \\<in> s then RETURN l\n                    else D ((a * x + c) mod m, insert x s, l + 1))\n                (x, s, 0))))\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "using [[goals_limit = 1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (uncurry ?f4),\n     uncurry2\n      (uncurry\n        (\\<lambda>a c m x.\n            let s = insert m op_ias_empty\n            in REC\\<^sub>T\n                (\\<lambda>D (x, s, l).\n                    if x \\<in> s then RETURN l\n                    else D ((a * x + c) mod m, insert x s, l + 1))\n                (x, s, 0))))\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "using [[id_debug]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (uncurry ?f4),\n     uncurry2\n      (uncurry\n        (\\<lambda>a c m x.\n            let s = insert m op_ias_empty\n            in REC\\<^sub>T\n                (\\<lambda>D (x, s, l).\n                    if x \\<in> s then RETURN l\n                    else D ((a * x + c) mod m, insert x s, l + 1))\n                (x, s, 0))))\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "by sepref"], ["", "export_code sai_impl checking SML"], ["", "term Array.upd"], ["", "definition \"sad_impl a c m x \\<equiv> do {\n  s\\<leftarrow>Array.new m False;\n  heap.fixp_fun (\\<lambda>D (x,s,l). do {\n    brk\\<leftarrow>Array.nth s x;\n    if brk then return l\n    else do {\n      _\\<leftarrow>Array.len s;\n      _\\<leftarrow>if x<l then return True else return False; \n      s\\<leftarrow>Array.upd x True s;\n      D ((a*x+c) mod m,s,l+1)\n    }\n  }) (x,s,0::nat)\n}\""], ["", "definition \"sad_impl2 a c m x \\<equiv> do {\n  s\\<leftarrow>Array.new m False;\n  heap.fixp_fun (\\<lambda>D (x,l). do {\n    brk\\<leftarrow>Array.nth s x;\n    if brk then return l\n    else do {\n      Array.upd x True s;\n      D ((a*x+c) mod m,l+1)\n    }\n  }) (x,0::nat)\n}\""], ["", "prepare_code_thms sad_impl_def"], ["", "prepare_code_thms sad_impl2_def"], ["", "code_thms sai_impl"], ["", "lemma\n \"ias_ins k a = do {\n    l\\<leftarrow>Array.len a;\n    if k<l then \n      Array.upd k True a\n    else do {\n      let newsz = max (k+1) (2 * l + 3);\n      a\\<leftarrow>Array_Blit.array_grow a newsz False;\n      Array.upd k True a\n    }    \n  }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ias_ins k a =\n    Array.len a \\<bind>\n    (\\<lambda>l.\n        if k < l then Array.upd k True a\n        else let newsz = max (k + 1) (2 * l + 3)\n             in Array_Blit.array_grow a newsz False \\<bind>\n                Array.upd k True)", "unfolding ias_ins_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.len a \\<bind>\n    (\\<lambda>l.\n        (if l \\<le> k\n         then let newsz = max (k + 1) (2 * l + 3)\n              in Array_Blit.array_grow a newsz False\n         else return a) \\<bind>\n        Array.upd k True) =\n    Array.len a \\<bind>\n    (\\<lambda>l.\n        if k < l then Array.upd k True a\n        else let newsz = max (k + 1) (2 * l + 3)\n             in Array_Blit.array_grow a newsz False \\<bind>\n                Array.upd k True)", "apply (fo_rule cong[OF arg_cong])"], ["proof (prove)\ngoal (2 subgoals):\n 1. Array.len a = Array.len a\n 2. (\\<lambda>l.\n        (if l \\<le> k\n         then let newsz = max (k + 1) (2 * l + 3)\n              in Array_Blit.array_grow a newsz False\n         else return a) \\<bind>\n        Array.upd k True) =\n    (\\<lambda>l.\n        if k < l then Array.upd k True a\n        else let newsz = max (k + 1) (2 * l + 3)\n             in Array_Blit.array_grow a newsz False \\<bind>\n                Array.upd k True)", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "export_code sa_impl sad_impl sad_impl2 sai_impl \n  checking SML_imp"], ["", "schematic_goal\n  shows \"hn_refine emp (?c1::?'c1 Heap) ?\\<Gamma>1' ?R1 \n  (do {\n    let x=(1::nat);\n    RETURN {x,x}\n  })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine emp ?c1 ?\\<Gamma>1' ?R1 (let x = 1 in RETURN {x, x})", "apply (rewrite in \"RETURN \\<hole>\" hs.fold_custom_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine emp ?c1 ?\\<Gamma>1' ?R1\n     (let x = 1 in RETURN (insert x (insert x op_hs_empty)))", "apply sepref"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "term hn_invalid"], ["", "definition \"remdup l \\<equiv> \n  RECT (\\<lambda>remdup. \\<lambda>(\n    [],s) \\<Rightarrow> RETURN op_HOL_list_empty \n  | (x#xs,s) \\<Rightarrow> if x\\<in>s then \n      remdup (xs,s )\n    else do {\n      l \\<leftarrow> remdup (xs, insert x s);\n      RETURN (x#l)\n    } \n  ) (l,op_hs_empty)\n\""], ["", "schematic_goal \n  fixes l :: \"nat list\"\n  notes [id_rules] = itypeI[Pure.of l \"TYPE(nat list)\"]\n  shows \"hn_refine ( (hn_ctxt (list_assn (pure Id))) l li) (?c::?'c Heap) ?\\<Gamma> ?R (remdup l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt (list_assn nat_assn) l li) ?c ?\\<Gamma> ?R (remdup l)", "unfolding remdup_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt (list_assn nat_assn) l li) ?c ?\\<Gamma> ?R\n     (REC\\<^sub>T\n       (\\<lambda>remdup xa.\n           case xa of ([], s) \\<Rightarrow> RETURN op_HOL_list_empty\n           | (x # xs, s) \\<Rightarrow>\n               if x \\<in> s then remdup (xs, s)\n               else remdup (xs, insert x s) \\<bind>\n                    (\\<lambda>l. RETURN (x # l)))\n       (l, op_hs_empty))", "using [[id_debug]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt (list_assn nat_assn) l li) ?c ?\\<Gamma> ?R\n     (REC\\<^sub>T\n       (\\<lambda>remdup xa.\n           case xa of ([], s) \\<Rightarrow> RETURN op_HOL_list_empty\n           | (x # xs, s) \\<Rightarrow>\n               if x \\<in> s then remdup (xs, s)\n               else remdup (xs, insert x s) \\<bind>\n                    (\\<lambda>l. RETURN (x # l)))\n       (l, op_hs_empty))", "by sepref"], ["", "text \\<open>Test structural frame-inference and merging (on product type)\\<close>"], ["", "definition \"smart_match_test1 \\<equiv> \\<lambda>(p1,p2). RETURN (p1+p2)\""], ["", "sepref_definition smart_match_test1_impl is \"smart_match_test1\" :: \"((prod_assn nat_assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, smart_match_test1)\n    \\<in> (nat_assn \\<times>\\<^sub>a\n           nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "unfolding smart_match_test1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, \\<lambda>(p1, p2). RETURN (p1 + p2))\n    \\<in> (nat_assn \\<times>\\<^sub>a\n           nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "by sepref"], ["", "sepref_register smart_match_test1"], ["", "lemmas [sepref_fr_rules] = smart_match_test1_impl.refine"], ["", "definition \"smart_match_test2 \\<equiv> do {\n    let p = (2::nat,2::nat);\n\n    f \\<leftarrow> if True then\n      case p of (a,b) \\<Rightarrow> RETURN (Some b)\n    else  \n      case p of (a,b) \\<Rightarrow> RETURN (Some a);\n\n    smart_match_test1 p\n  }\""], ["", "sepref_thm smart_match_test2_impl is \"uncurry0 smart_match_test2\" :: \"unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2, uncurry0 smart_match_test2)\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "unfolding smart_match_test2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2,\n     uncurry0\n      (let p = (2, 2)\n       in (if True then case p of (a, b) \\<Rightarrow> RETURN (Some b)\n           else case p of (a, b) \\<Rightarrow> RETURN (Some a)) \\<bind>\n          (\\<lambda>f. smart_match_test1 p)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "by sepref"], ["", "(* Regression from incomplete monadify, that could not not handle nested \n    plain operations that get converted to monadic operations. *)"], ["", "sepref_thm regr_incomplete_monadify is \"RETURN o (\\<lambda>l. fold (\\<lambda>x. (#) (case x of (x, xa) \\<Rightarrow> x + xa)) l [])\" :: \"(list_assn (prod_assn nat_assn nat_assn))\\<^sup>k \\<rightarrow>\\<^sub>a list_assn nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     RETURN \\<circ>\n     (\\<lambda>l.\n         fold (\\<lambda>x. (#) (case x of (x, xa) \\<Rightarrow> x + xa)) l\n          []))\n    \\<in> (list_assn\n            (nat_assn \\<times>\\<^sub>a\n             nat_assn))\\<^sup>k \\<rightarrow>\\<^sub>a list_assn nat_assn", "unfolding test_def[abs_def] \"HOL_list.fold_custom_empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     RETURN \\<circ>\n     (\\<lambda>l.\n         fold (\\<lambda>x. (#) (case x of (x, xa) \\<Rightarrow> x + xa)) l\n          op_HOL_list_empty))\n    \\<in> (list_assn\n            (nat_assn \\<times>\\<^sub>a\n             nat_assn))\\<^sup>k \\<rightarrow>\\<^sub>a list_assn nat_assn", "by sepref"], ["", "end"], ["", "(*>*)"]]}