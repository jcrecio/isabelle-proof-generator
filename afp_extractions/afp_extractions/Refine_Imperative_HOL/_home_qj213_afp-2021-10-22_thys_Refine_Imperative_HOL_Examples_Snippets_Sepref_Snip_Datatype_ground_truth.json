{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/Examples/Snippets/Sepref_Snip_Datatype.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemma enum_assn_pure[safe_constraint_rules]: \"is_pure A \\<Longrightarrow> is_pure (enum_assn A)\"", "lemma enum_assn_id[simp]: \"enum_assn id_assn = id_assn\"", "lemma enum_match_nocong: \"\\<lbrakk>\\<And>x y. hn_ctxt A x y \\<Longrightarrow>\\<^sub>t hn_ctxt A' x y\\<rbrakk> \\<Longrightarrow> hn_ctxt (enum_assn A) e e' \\<Longrightarrow>\\<^sub>t hn_ctxt (enum_assn A') e e'\"", "lemma enum_merge_nocong:\n    assumes \"\\<And>x y. hn_ctxt A x y \\<or>\\<^sub>A hn_ctxt A' x y \\<Longrightarrow>\\<^sub>A hn_ctxt Am x y\"\n    shows \"hn_ctxt (enum_assn A) e e' \\<or>\\<^sub>A hn_ctxt (enum_assn A') e e' \\<Longrightarrow>\\<^sub>A hn_ctxt (enum_assn Am) e e'\"", "lemma enum_match_cong[sepref_frame_match_rules]: \n    \"\\<lbrakk>\\<And>x y. \\<lbrakk>x\\<in>set_enum e; y\\<in>set_enum e'\\<rbrakk> \\<Longrightarrow> hn_ctxt A x y \\<Longrightarrow>\\<^sub>t hn_ctxt A' x y\\<rbrakk> \\<Longrightarrow> hn_ctxt (enum_assn A) e e' \\<Longrightarrow>\\<^sub>t hn_ctxt (enum_assn A') e e'\"", "lemma enum_merge_cong[sepref_frame_merge_rules]:\n    assumes \"\\<And>x y. \\<lbrakk>x\\<in>set_enum e; y\\<in>set_enum e'\\<rbrakk> \\<Longrightarrow> hn_ctxt A x y \\<or>\\<^sub>A hn_ctxt A' x y \\<Longrightarrow>\\<^sub>t hn_ctxt Am x y\"\n    shows \"hn_ctxt (enum_assn A) e e' \\<or>\\<^sub>A hn_ctxt (enum_assn A') e e' \\<Longrightarrow>\\<^sub>t hn_ctxt (enum_assn Am) e e'\"", "lemma entt_invalid_enum: \"hn_invalid (enum_assn A) e e' \\<Longrightarrow>\\<^sub>t hn_ctxt (enum_assn (invalid_assn A)) e e'\"", "lemmas invalid_enum_merge[sepref_frame_merge_rules] = gen_merge_cons[OF entt_invalid_enum]", "lemma [sepref_fr_rules]: \"(return o E1,RETURN o E1) \\<in> A\\<^sup>d \\<rightarrow>\\<^sub>a enum_assn A\"", "lemma [sepref_fr_rules]: \"(return o E2,RETURN o E2) \\<in> A\\<^sup>d \\<rightarrow>\\<^sub>a enum_assn A\"", "lemma [sepref_fr_rules]: \"(uncurry0 (return E3),uncurry0 (RETURN E3)) \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a enum_assn A\"", "lemma [sepref_fr_rules]: \"(uncurry (return oo E4),uncurry (RETURN oo E4)) \\<in> A\\<^sup>d*\\<^sub>aA\\<^sup>d \\<rightarrow>\\<^sub>a enum_assn A\"", "lemma [sepref_fr_rules]: \"(uncurry (return oo E5),uncurry (RETURN oo E5)) \\<in> bool_assn\\<^sup>k*\\<^sub>aA\\<^sup>d \\<rightarrow>\\<^sub>a enum_assn A\"", "lemma [sepref_monadify_arity]: \"case_enum \\<equiv> \\<lambda>\\<^sub>2f1 f2 f3 f4 f5 x. SP case_enum$(\\<lambda>\\<^sub>2x. f1$x)$(\\<lambda>\\<^sub>2x. f2$x)$f3$(\\<lambda>\\<^sub>2x y. f4$x$y)$(\\<lambda>\\<^sub>2x y. f5$x$y)$x\"", "lemma [sepref_monadify_comb]: \"case_enum$f1$f2$f3$f4$f5$x \\<equiv> (\\<bind>)$(EVAL$x)$(\\<lambda>\\<^sub>2x. SP case_enum$f1$f2$f3$f4$f5$x)\"", "lemma [sepref_monadify_comb]: \"EVAL$(case_enum$(\\<lambda>\\<^sub>2x. f1 x)$(\\<lambda>\\<^sub>2x. f2 x)$f3$(\\<lambda>\\<^sub>2x y. f4 x y)$(\\<lambda>\\<^sub>2x y. f5 x y)$x) \n    \\<equiv> (\\<bind>)$(EVAL$x)$(\\<lambda>\\<^sub>2x. SP case_enum$(\\<lambda>\\<^sub>2x. EVAL $ f1 x)$(\\<lambda>\\<^sub>2x. EVAL $ f2 x)$(EVAL $ f3)$(\\<lambda>\\<^sub>2x y. EVAL $ f4 x y)$(\\<lambda>\\<^sub>2x y. EVAL $ f5 x y)$x)\"", "lemma enum_assn_ctxt: \"enum_assn A x y = z \\<Longrightarrow> hn_ctxt (enum_assn A) x y = z\"", "lemma enum_cases_hnr:\n    fixes A e e'\n    defines [simp]: \"INVe \\<equiv> hn_invalid (enum_assn A) e e'\"\n    assumes FR: \"\\<Gamma> \\<Longrightarrow>\\<^sub>t hn_ctxt (enum_assn A) e e' * F\"\n    assumes E1: \"\\<And>x1 x1a. \\<lbrakk>e = E1 x1; e' = E1 x1a\\<rbrakk> \\<Longrightarrow> hn_refine (hn_ctxt A x1 x1a * INVe * F) (f1' x1a) (hn_ctxt A1' x1 x1a * hn_ctxt XX1 e e' * \\<Gamma>1') R (f1 x1)\"\n    assumes E2: \"\\<And>x2 x2a. \\<lbrakk>e = E2 x2; e' = E2 x2a\\<rbrakk> \\<Longrightarrow> hn_refine (hn_ctxt A x2 x2a * INVe * F) (f2' x2a) (hn_ctxt A2' x2 x2a * hn_ctxt XX2 e e' * \\<Gamma>2') R (f2 x2)\"\n    assumes E3: \"\\<lbrakk>e = E3; e' = E3\\<rbrakk> \\<Longrightarrow> hn_refine (hn_ctxt (enum_assn A) e e' * F) f3' (hn_ctxt XX3 e e' * \\<Gamma>3') R f3\"\n    assumes E4: \"\\<And>x41 x42 x41a x42a.\n       \\<lbrakk>e = E4 x41 x42; e' = E4 x41a x42a\\<rbrakk>\n       \\<Longrightarrow> hn_refine (hn_ctxt A x41 x41a * hn_ctxt A x42 x42a * INVe * F) (f4' x41a x42a) (hn_ctxt A4a' x41 x41a * hn_ctxt A4b' x42 x42a * hn_ctxt XX4 e e' * \\<Gamma>4') R\n            (f4 x41 x42)\"\n    assumes E5: \"\\<And>x51 x52 x51a x52a.\n       \\<lbrakk>e = E5 x51 x52; e' = E5 x51a x52a\\<rbrakk>\n       \\<Longrightarrow> hn_refine (hn_ctxt bool_assn x51 x51a * hn_ctxt A x52 x52a * INVe * F) (f5' x51a x52a)\n            (hn_ctxt bool_assn x51 x51a * hn_ctxt A5' x52 x52a * hn_ctxt XX5 e e' * \\<Gamma>5') R (f5 x51 x52)\"\n    assumes MERGE1[unfolded hn_ctxt_def]: \"\\<And>x x'. hn_ctxt A1' x x' \\<or>\\<^sub>A hn_ctxt A2' x x' \\<or>\\<^sub>A hn_ctxt A3' x x' \\<or>\\<^sub>A hn_ctxt A4a' x x' \\<or>\\<^sub>A hn_ctxt A4b' x x' \\<or>\\<^sub>A hn_ctxt A5' x x' \\<Longrightarrow>\\<^sub>t hn_ctxt A' x x'\"\n    assumes MERGE2[unfolded hn_ctxt_def]: \"\\<Gamma>1' \\<or>\\<^sub>A \\<Gamma>2' \\<or>\\<^sub>A \\<Gamma>3' \\<or>\\<^sub>A \\<Gamma>4' \\<or>\\<^sub>A \\<Gamma>5' \\<Longrightarrow>\\<^sub>t \\<Gamma>'\"\n    shows \"hn_refine \\<Gamma> (case_enum f1' f2' f3' f4' f5' e') (hn_ctxt (enum_assn A') e e' * \\<Gamma>') R (case_enum$(\\<lambda>\\<^sub>2x. f1 x)$(\\<lambda>\\<^sub>2x. f2 x)$f3$(\\<lambda>\\<^sub>2x y. f4 x y)$(\\<lambda>\\<^sub>2x y. f5 x y)$e)\"", "lemmas [sepref_comb_rules] = enum_cases_hnr[sepref_prep_comb_rule]", "lemmas [sepref_fr_rules] = test1_impl.refine", "lemmas [safe_constraint_rules] = CN_FALSEI[of is_pure \"invalid_assn A\" for A]"], "translations": [["", "lemma enum_assn_pure[safe_constraint_rules]: \"is_pure A \\<Longrightarrow> is_pure (enum_assn A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pure A \\<Longrightarrow> is_pure (enum_assn A)", "apply (auto simp: is_pure_iff_pure_assn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x'.\n       \\<forall>x x'. is_pure_assn (A x x') \\<Longrightarrow>\n       is_pure_assn (enum_assn A x x')", "apply (rename_tac x x')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x'.\n       \\<forall>x x'. is_pure_assn (A x x') \\<Longrightarrow>\n       is_pure_assn (enum_assn A x x')", "apply (case_tac x; case_tac x'; simp add: pure_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>An identitiy rule is required to easily prove trivial refinement theorems\\<close>"], ["", "lemma enum_assn_id[simp]: \"enum_assn id_assn = id_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enum_assn id_assn = id_assn", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa. enum_assn id_assn x xa = id_assn x xa", "subgoal for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. enum_assn id_assn x y = id_assn x y", "by (cases x; cases y; simp add: pure_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Structural rules. \\<close>"], ["", "text \\<open>Without congruence condition\\<close>"], ["", "lemma enum_match_nocong: \"\\<lbrakk>\\<And>x y. hn_ctxt A x y \\<Longrightarrow>\\<^sub>t hn_ctxt A' x y\\<rbrakk> \\<Longrightarrow> hn_ctxt (enum_assn A) e e' \\<Longrightarrow>\\<^sub>t hn_ctxt (enum_assn A') e e'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        hn_ctxt A x y \\<Longrightarrow>\\<^sub>t\n        hn_ctxt A' x y) \\<Longrightarrow>\n    hn_ctxt (enum_assn A) e e' \\<Longrightarrow>\\<^sub>t\n    hn_ctxt (enum_assn A') e e'", "by (cases e; cases e'; simp add: hn_ctxt_def entt_star_mono)"], ["", "lemma enum_merge_nocong:\n    assumes \"\\<And>x y. hn_ctxt A x y \\<or>\\<^sub>A hn_ctxt A' x y \\<Longrightarrow>\\<^sub>A hn_ctxt Am x y\"\n    shows \"hn_ctxt (enum_assn A) e e' \\<or>\\<^sub>A hn_ctxt (enum_assn A') e e' \\<Longrightarrow>\\<^sub>A hn_ctxt (enum_assn Am) e e'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_ctxt (enum_assn A) e e' \\<or>\\<^sub>A\n    hn_ctxt (enum_assn A') e e' \\<Longrightarrow>\\<^sub>A\n    hn_ctxt (enum_assn Am) e e'", "using assms"], ["proof (prove)\nusing this:\n  hn_ctxt A ?x ?y \\<or>\\<^sub>A hn_ctxt A' ?x ?y \\<Longrightarrow>\\<^sub>A\n  hn_ctxt Am ?x ?y\n\ngoal (1 subgoal):\n 1. hn_ctxt (enum_assn A) e e' \\<or>\\<^sub>A\n    hn_ctxt (enum_assn A') e e' \\<Longrightarrow>\\<^sub>A\n    hn_ctxt (enum_assn Am) e e'", "by (cases e; cases e'; simp add: hn_ctxt_def ent_disj_star_mono)"], ["", "text \\<open>With congruence condition\\<close>"], ["", "lemma enum_match_cong[sepref_frame_match_rules]: \n    \"\\<lbrakk>\\<And>x y. \\<lbrakk>x\\<in>set_enum e; y\\<in>set_enum e'\\<rbrakk> \\<Longrightarrow> hn_ctxt A x y \\<Longrightarrow>\\<^sub>t hn_ctxt A' x y\\<rbrakk> \\<Longrightarrow> hn_ctxt (enum_assn A) e e' \\<Longrightarrow>\\<^sub>t hn_ctxt (enum_assn A') e e'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<in> set_enum e; y \\<in> set_enum e'\\<rbrakk>\n        \\<Longrightarrow> hn_ctxt A x y \\<Longrightarrow>\\<^sub>t\n                          hn_ctxt A' x y) \\<Longrightarrow>\n    hn_ctxt (enum_assn A) e e' \\<Longrightarrow>\\<^sub>t\n    hn_ctxt (enum_assn A') e e'", "by (cases e; cases e'; simp add: hn_ctxt_def entt_star_mono)"], ["", "lemma enum_merge_cong[sepref_frame_merge_rules]:\n    assumes \"\\<And>x y. \\<lbrakk>x\\<in>set_enum e; y\\<in>set_enum e'\\<rbrakk> \\<Longrightarrow> hn_ctxt A x y \\<or>\\<^sub>A hn_ctxt A' x y \\<Longrightarrow>\\<^sub>t hn_ctxt Am x y\"\n    shows \"hn_ctxt (enum_assn A) e e' \\<or>\\<^sub>A hn_ctxt (enum_assn A') e e' \\<Longrightarrow>\\<^sub>t hn_ctxt (enum_assn Am) e e'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_ctxt (enum_assn A) e e' \\<or>\\<^sub>A\n    hn_ctxt (enum_assn A') e e' \\<Longrightarrow>\\<^sub>t\n    hn_ctxt (enum_assn Am) e e'", "apply (blast intro: entt_disjE enum_match_cong entt_disjD1[OF assms] entt_disjD2[OF assms])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Propagating invalid\\<close>"], ["", "lemma entt_invalid_enum: \"hn_invalid (enum_assn A) e e' \\<Longrightarrow>\\<^sub>t hn_ctxt (enum_assn (invalid_assn A)) e e'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_invalid (enum_assn A) e e' \\<Longrightarrow>\\<^sub>t\n    hn_ctxt (enum_assn (invalid_assn A)) e e'", "apply (simp add: hn_ctxt_def invalid_assn_def[abs_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<up>\n     (\\<exists>a b.\n         (a, b) \\<Turnstile> enum_assn A e e') \\<Longrightarrow>\\<^sub>t\n    enum_assn\n     (\\<lambda>x y. \\<up> (\\<exists>a b. (a, b) \\<Turnstile> A x y) * true)\n     e e'", "apply (rule enttI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<up>\n     (\\<exists>a b.\n         (a, b) \\<Turnstile> enum_assn A e e') \\<Longrightarrow>\\<^sub>A\n    enum_assn\n     (\\<lambda>x y. \\<up> (\\<exists>a b. (a, b) \\<Turnstile> A x y) * true)\n     e e' *\n    true", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<Turnstile> enum_assn A e e' \\<Longrightarrow>\n       emp \\<Longrightarrow>\\<^sub>A\n       enum_assn\n        (\\<lambda>x y.\n            \\<up> (\\<exists>a b. (a, b) \\<Turnstile> A x y) * true)\n        e e' *\n       true", "apply (cases e; cases e'; auto simp: mod_star_conv pure_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas invalid_enum_merge[sepref_frame_merge_rules] = gen_merge_cons[OF entt_invalid_enum]"], ["", "subsection \\<open>Constructors\\<close>"], ["", "text \\<open>Constructors need to be registered\\<close>"], ["", "sepref_register E1 E2 E3 E4 E5"], ["", "text \\<open>Refinement rules can be proven straightforwardly on the separation logic level (method @{method sepref_to_hoare})\\<close>"], ["", "lemma [sepref_fr_rules]: \"(return o E1,RETURN o E1) \\<in> A\\<^sup>d \\<rightarrow>\\<^sub>a enum_assn A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (return \\<circ> E1, RETURN \\<circ> E1)\n    \\<in> A\\<^sup>d \\<rightarrow>\\<^sub>a enum_assn A", "by sepref_to_hoare sep_auto"], ["", "lemma [sepref_fr_rules]: \"(return o E2,RETURN o E2) \\<in> A\\<^sup>d \\<rightarrow>\\<^sub>a enum_assn A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (return \\<circ> E2, RETURN \\<circ> E2)\n    \\<in> A\\<^sup>d \\<rightarrow>\\<^sub>a enum_assn A", "by sepref_to_hoare sep_auto"], ["", "lemma [sepref_fr_rules]: \"(uncurry0 (return E3),uncurry0 (RETURN E3)) \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a enum_assn A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 (return E3), uncurry0 (RETURN E3))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a enum_assn A", "by sepref_to_hoare sep_auto"], ["", "lemma [sepref_fr_rules]: \"(uncurry (return oo E4),uncurry (RETURN oo E4)) \\<in> A\\<^sup>d*\\<^sub>aA\\<^sup>d \\<rightarrow>\\<^sub>a enum_assn A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry (return \\<circ>\\<circ> E4), uncurry (RETURN \\<circ>\\<circ> E4))\n    \\<in> A\\<^sup>d *\\<^sub>a A\\<^sup>d \\<rightarrow>\\<^sub>a enum_assn A", "by sepref_to_hoare sep_auto"], ["", "lemma [sepref_fr_rules]: \"(uncurry (return oo E5),uncurry (RETURN oo E5)) \\<in> bool_assn\\<^sup>k*\\<^sub>aA\\<^sup>d \\<rightarrow>\\<^sub>a enum_assn A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry (return \\<circ>\\<circ> E5), uncurry (RETURN \\<circ>\\<circ> E5))\n    \\<in> bool_assn\\<^sup>k *\\<^sub>a\n          A\\<^sup>d \\<rightarrow>\\<^sub>a enum_assn A", "by sepref_to_hoare (sep_auto simp: pure_def)"], ["", "subsection \\<open>Destructor\\<close>"], ["", "text \\<open>There is currently no automation for destructors, so all the registration boilerplate \n    needs to be done manually\\<close>"], ["", "text \\<open>Set ups operation identification heuristics\\<close>"], ["", "sepref_register case_enum"], ["", "text \\<open>In the monadify phase, this eta-expands to make visible all required arguments\\<close>"], ["", "lemma [sepref_monadify_arity]: \"case_enum \\<equiv> \\<lambda>\\<^sub>2f1 f2 f3 f4 f5 x. SP case_enum$(\\<lambda>\\<^sub>2x. f1$x)$(\\<lambda>\\<^sub>2x. f2$x)$f3$(\\<lambda>\\<^sub>2x y. f4$x$y)$(\\<lambda>\\<^sub>2x y. f5$x$y)$x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case_enum \\<equiv>\n    \\<lambda>x.\n       (#\\<lambda>xa.\n            (#\\<lambda>xb.\n                 (#\\<lambda>xc.\n                      (#\\<lambda>xd.\n                           (#\\<lambda>xe.\n                                (#SP case_enum $ (\\<lambda>xa. (#x $ xa#)) $\n                                  (\\<lambda>x. (#xa $ x#)) $\n                                  xb $\n                                  (\\<lambda>x.\n(#\\<lambda>xa. (#xc $ x $ xa#)#)) $\n                                  (\\<lambda>x.\n(#\\<lambda>xa. (#xd $ x $ xa#)#)) $\n                                  xe#)#)#)#)#)#)", "by simp"], ["", "text \\<open>This determines an evaluation order for the first-order operands\\<close>"], ["", "lemma [sepref_monadify_comb]: \"case_enum$f1$f2$f3$f4$f5$x \\<equiv> (\\<bind>)$(EVAL$x)$(\\<lambda>\\<^sub>2x. SP case_enum$f1$f2$f3$f4$f5$x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case_enum $ f1 $ f2 $ f3 $ f4 $ f5 $ x \\<equiv>\n    (\\<bind>) $ (EVAL $ x) $\n    (\\<lambda>x. (#SP case_enum $ f1 $ f2 $ f3 $ f4 $ f5 $ x#))", "by simp"], ["", "text \\<open>This enables translation of the case-distinction in a non-monadic context.\\<close>"], ["", "lemma [sepref_monadify_comb]: \"EVAL$(case_enum$(\\<lambda>\\<^sub>2x. f1 x)$(\\<lambda>\\<^sub>2x. f2 x)$f3$(\\<lambda>\\<^sub>2x y. f4 x y)$(\\<lambda>\\<^sub>2x y. f5 x y)$x) \n    \\<equiv> (\\<bind>)$(EVAL$x)$(\\<lambda>\\<^sub>2x. SP case_enum$(\\<lambda>\\<^sub>2x. EVAL $ f1 x)$(\\<lambda>\\<^sub>2x. EVAL $ f2 x)$(EVAL $ f3)$(\\<lambda>\\<^sub>2x y. EVAL $ f4 x y)$(\\<lambda>\\<^sub>2x y. EVAL $ f5 x y)$x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. EVAL $\n    (case_enum $ (\\<lambda>x. (#f1 x#)) $ (\\<lambda>x. (#f2 x#)) $ f3 $\n     (\\<lambda>x. (#\\<lambda>xa. (#f4 x xa#)#)) $\n     (\\<lambda>x. (#\\<lambda>xa. (#f5 x xa#)#)) $\n     x) \\<equiv>\n    (\\<bind>) $ (EVAL $ x) $\n    (\\<lambda>x.\n        (#SP case_enum $ (\\<lambda>x. (#EVAL $ f1 x#)) $\n          (\\<lambda>x. (#EVAL $ f2 x#)) $\n          (EVAL $ f3) $\n          (\\<lambda>x. (#\\<lambda>xa. (#EVAL $ f4 x xa#)#)) $\n          (\\<lambda>x. (#\\<lambda>xa. (#EVAL $ f5 x xa#)#)) $\n          x#))", "apply (rule eq_reflection)"], ["proof (prove)\ngoal (1 subgoal):\n 1. EVAL $\n    (case_enum $ (\\<lambda>x. (#f1 x#)) $ (\\<lambda>x. (#f2 x#)) $ f3 $\n     (\\<lambda>x. (#\\<lambda>xa. (#f4 x xa#)#)) $\n     (\\<lambda>x. (#\\<lambda>xa. (#f5 x xa#)#)) $\n     x) =\n    (\\<bind>) $ (EVAL $ x) $\n    (\\<lambda>x.\n        (#SP case_enum $ (\\<lambda>x. (#EVAL $ f1 x#)) $\n          (\\<lambda>x. (#EVAL $ f2 x#)) $\n          (EVAL $ f3) $\n          (\\<lambda>x. (#\\<lambda>xa. (#EVAL $ f4 x xa#)#)) $\n          (\\<lambda>x. (#\\<lambda>xa. (#EVAL $ f5 x xa#)#)) $\n          x#))", "by (simp split: enum.splits)"], ["", "text \\<open>Auxiliary lemma, to lift simp-rule over \\<open>hn_ctxt\\<close>\\<close>"], ["", "lemma enum_assn_ctxt: \"enum_assn A x y = z \\<Longrightarrow> hn_ctxt (enum_assn A) x y = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enum_assn A x y = z \\<Longrightarrow> hn_ctxt (enum_assn A) x y = z", "by (simp add: hn_ctxt_def)"], ["", "text \\<open>The cases lemma first extracts the refinement for the datatype from the precondition.\n    Next, it generate proof obligations to refine the functions for every case. \n    Finally the postconditions of the refinement are merged. \n\n    Note that we handle the\n    destructed values separately, to allow reconstruction of the original datatype after the case-expression.\n\n    Moreover, we provide (invalidated) versions of the original compound value to the cases,\n    which allows access to pure compound values from inside the case.\n    \\<close>"], ["", "lemma enum_cases_hnr:\n    fixes A e e'\n    defines [simp]: \"INVe \\<equiv> hn_invalid (enum_assn A) e e'\"\n    assumes FR: \"\\<Gamma> \\<Longrightarrow>\\<^sub>t hn_ctxt (enum_assn A) e e' * F\"\n    assumes E1: \"\\<And>x1 x1a. \\<lbrakk>e = E1 x1; e' = E1 x1a\\<rbrakk> \\<Longrightarrow> hn_refine (hn_ctxt A x1 x1a * INVe * F) (f1' x1a) (hn_ctxt A1' x1 x1a * hn_ctxt XX1 e e' * \\<Gamma>1') R (f1 x1)\"\n    assumes E2: \"\\<And>x2 x2a. \\<lbrakk>e = E2 x2; e' = E2 x2a\\<rbrakk> \\<Longrightarrow> hn_refine (hn_ctxt A x2 x2a * INVe * F) (f2' x2a) (hn_ctxt A2' x2 x2a * hn_ctxt XX2 e e' * \\<Gamma>2') R (f2 x2)\"\n    assumes E3: \"\\<lbrakk>e = E3; e' = E3\\<rbrakk> \\<Longrightarrow> hn_refine (hn_ctxt (enum_assn A) e e' * F) f3' (hn_ctxt XX3 e e' * \\<Gamma>3') R f3\"\n    assumes E4: \"\\<And>x41 x42 x41a x42a.\n       \\<lbrakk>e = E4 x41 x42; e' = E4 x41a x42a\\<rbrakk>\n       \\<Longrightarrow> hn_refine (hn_ctxt A x41 x41a * hn_ctxt A x42 x42a * INVe * F) (f4' x41a x42a) (hn_ctxt A4a' x41 x41a * hn_ctxt A4b' x42 x42a * hn_ctxt XX4 e e' * \\<Gamma>4') R\n            (f4 x41 x42)\"\n    assumes E5: \"\\<And>x51 x52 x51a x52a.\n       \\<lbrakk>e = E5 x51 x52; e' = E5 x51a x52a\\<rbrakk>\n       \\<Longrightarrow> hn_refine (hn_ctxt bool_assn x51 x51a * hn_ctxt A x52 x52a * INVe * F) (f5' x51a x52a)\n            (hn_ctxt bool_assn x51 x51a * hn_ctxt A5' x52 x52a * hn_ctxt XX5 e e' * \\<Gamma>5') R (f5 x51 x52)\"\n    assumes MERGE1[unfolded hn_ctxt_def]: \"\\<And>x x'. hn_ctxt A1' x x' \\<or>\\<^sub>A hn_ctxt A2' x x' \\<or>\\<^sub>A hn_ctxt A3' x x' \\<or>\\<^sub>A hn_ctxt A4a' x x' \\<or>\\<^sub>A hn_ctxt A4b' x x' \\<or>\\<^sub>A hn_ctxt A5' x x' \\<Longrightarrow>\\<^sub>t hn_ctxt A' x x'\"\n    assumes MERGE2[unfolded hn_ctxt_def]: \"\\<Gamma>1' \\<or>\\<^sub>A \\<Gamma>2' \\<or>\\<^sub>A \\<Gamma>3' \\<or>\\<^sub>A \\<Gamma>4' \\<or>\\<^sub>A \\<Gamma>5' \\<Longrightarrow>\\<^sub>t \\<Gamma>'\"\n    shows \"hn_refine \\<Gamma> (case_enum f1' f2' f3' f4' f5' e') (hn_ctxt (enum_assn A') e e' * \\<Gamma>') R (case_enum$(\\<lambda>\\<^sub>2x. f1 x)$(\\<lambda>\\<^sub>2x. f2 x)$f3$(\\<lambda>\\<^sub>2x y. f4 x y)$(\\<lambda>\\<^sub>2x y. f5 x y)$e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine \\<Gamma>\n     (case e' of E1 x \\<Rightarrow> f1' x | E2 x \\<Rightarrow> f2' x\n      | E3 \\<Rightarrow> f3' | E4 x xa \\<Rightarrow> f4' x xa\n      | E5 x xa \\<Rightarrow> f5' x xa)\n     (hn_ctxt (enum_assn A') e e' * \\<Gamma>') R\n     (case_enum $ (\\<lambda>x. (#f1 x#)) $ (\\<lambda>x. (#f2 x#)) $ f3 $\n      (\\<lambda>x. (#\\<lambda>xa. (#f4 x xa#)#)) $\n      (\\<lambda>x. (#\\<lambda>xa. (#f5 x xa#)#)) $\n      e)", "apply (rule hn_refine_cons_pre[OF FR])"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt (enum_assn A) e e' * F)\n     (case e' of E1 x \\<Rightarrow> f1' x | E2 x \\<Rightarrow> f2' x\n      | E3 \\<Rightarrow> f3' | E4 x xa \\<Rightarrow> f4' x xa\n      | E5 x xa \\<Rightarrow> f5' x xa)\n     (hn_ctxt (enum_assn A') e e' * \\<Gamma>') R\n     (case_enum $ (\\<lambda>x. (#f1 x#)) $ (\\<lambda>x. (#f2 x#)) $ f3 $\n      (\\<lambda>x. (#\\<lambda>xa. (#f4 x xa#)#)) $\n      (\\<lambda>x. (#\\<lambda>xa. (#f5 x xa#)#)) $\n      e)", "apply1 extract_hnr_invalids"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h h1 h2.\n       \\<lbrakk>h2 \\<Turnstile> F;\n        hn_invalid (enum_assn A) e e' = true\\<rbrakk>\n       \\<Longrightarrow> hn_refine (hn_ctxt (enum_assn A) e e' * F)\n                          (case e' of E1 x \\<Rightarrow> f1' x\n                           | E2 x \\<Rightarrow> f2' x | E3 \\<Rightarrow> f3'\n                           | E4 x xa \\<Rightarrow> f4' x xa\n                           | E5 x xa \\<Rightarrow> f5' x xa)\n                          (hn_ctxt (enum_assn A') e e' * \\<Gamma>') R\n                          (case_enum $ (\\<lambda>x. (#f1 x#)) $\n                           (\\<lambda>x. (#f2 x#)) $\n                           f3 $\n                           (\\<lambda>x. (#\\<lambda>xa. (#f4 x xa#)#)) $\n                           (\\<lambda>x. (#\\<lambda>xa. (#f5 x xa#)#)) $\n                           e)", "apply (cases e; cases e'; simp add: enum_assn.simps[THEN enum_assn_ctxt])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>h2 x1 x1a.\n       \\<lbrakk>h2 \\<Turnstile> F;\n        hn_invalid (enum_assn A) (E1 x1) (E1 x1a) = true; e = E1 x1;\n        e' = E1 x1a\\<rbrakk>\n       \\<Longrightarrow> hn_refine (A x1 x1a * F) (f1' x1a)\n                          (A' x1 x1a * \\<Gamma>') R (f1 x1)\n 2. \\<And>h2 x2 x2a.\n       \\<lbrakk>h2 \\<Turnstile> F;\n        hn_invalid (enum_assn A) (E2 x2) (E2 x2a) = true; e = E2 x2;\n        e' = E2 x2a\\<rbrakk>\n       \\<Longrightarrow> hn_refine (A x2 x2a * F) (f2' x2a)\n                          (A' x2 x2a * \\<Gamma>') R (f2 x2)\n 3. \\<And>h2.\n       \\<lbrakk>h2 \\<Turnstile> F; hn_invalid (enum_assn A) E3 E3 = true;\n        e = E3; e' = E3\\<rbrakk>\n       \\<Longrightarrow> hn_refine F f3' \\<Gamma>' R f3\n 4. \\<And>h2 x41 x42 x41a x42a.\n       \\<lbrakk>h2 \\<Turnstile> F;\n        hn_invalid (enum_assn A) (E4 x41 x42) (E4 x41a x42a) = true;\n        e = E4 x41 x42; e' = E4 x41a x42a\\<rbrakk>\n       \\<Longrightarrow> hn_refine (A x41 x41a * A x42 x42a * F)\n                          (f4' x41a x42a)\n                          (A' x41 x41a * A' x42 x42a * \\<Gamma>') R\n                          (f4 x41 x42)\n 5. \\<And>h2 x51 x52 x51a x52a.\n       \\<lbrakk>h2 \\<Turnstile> F;\n        hn_invalid (enum_assn A) (E5 x51 x52) (E5 x51a x52a) = true;\n        e = E5 x51 x52; e' = E5 x51a x52a\\<rbrakk>\n       \\<Longrightarrow> hn_refine (bool_assn x51 x51a * A x52 x52a * F)\n                          (f5' x51a x52a)\n                          (bool_assn x51 x51a * A' x52 x52a * \\<Gamma>') R\n                          (f5 x51 x52)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E1 x1_) (E1 x1a_) = true; e = E1 x1_;\n     e' = E1 x1a_\\<rbrakk>\n    \\<Longrightarrow> hn_refine (A x1_ x1a_ * F) (f1' x1a_)\n                       (A' x1_ x1a_ * \\<Gamma>') R (f1 x1_)", "apply (rule hn_refine_cons[OF _ E1 _ entt_refl]; assumption?)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E1 x1_) (E1 x1a_) = true; e = E1 x1_;\n     e' = E1 x1a_\\<rbrakk>\n    \\<Longrightarrow> A x1_ x1a_ * F \\<Longrightarrow>\\<^sub>t\n                      hn_ctxt A x1_ x1a_ * INVe * F\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E1 x1_) (E1 x1a_) = true; e = E1 x1_;\n     e' = E1 x1a_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt A1' x1_ x1a_ * hn_ctxt XX1 e e' *\n                      \\<Gamma>1' \\<Longrightarrow>\\<^sub>t\n                      A' x1_ x1a_ * \\<Gamma>'", "applyS (simp add: hn_ctxt_def) \\<comment> \\<open>Match precondition for case, get \\<open>enum_assn\\<close> from assumption generated by \\<open>extract_hnr_invalids\\<close>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E1 x1_) (E1 x1a_) = true; e = E1 x1_;\n     e' = E1 x1a_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt A1' x1_ x1a_ * hn_ctxt XX1 e e' *\n                      \\<Gamma>1' \\<Longrightarrow>\\<^sub>t\n                      A' x1_ x1a_ * \\<Gamma>'", "apply (rule entt_star_mono) \\<comment> \\<open>Split postcondition into pairs for compounds and frame, drop \\<open>hn_ctxt XX\\<close>\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E1 x1_) (E1 x1a_) = true; e = E1 x1_;\n     e' = E1 x1a_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt A1' x1_ x1a_ *\n                      hn_ctxt XX1 e e' \\<Longrightarrow>\\<^sub>t\n                      A' x1_ x1a_\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E1 x1_) (E1 x1a_) = true; e = E1 x1_;\n     e' = E1 x1a_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>1' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "apply1 (rule entt_fr_drop)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E1 x1_) (E1 x1a_) = true; e = E1 x1_;\n     e' = E1 x1a_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt A1' x1_ x1a_ \\<Longrightarrow>\\<^sub>t\n                      A' x1_ x1a_\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E1 x1_) (E1 x1a_) = true; e = E1 x1_;\n     e' = E1 x1a_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>1' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "apply1 (rule entt_trans[OF _ MERGE1])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E1 x1_) (E1 x1a_) = true; e = E1 x1_;\n     e' = E1 x1a_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt A1' x1_ x1a_ \\<Longrightarrow>\\<^sub>t\n                      A1' x1_ x1a_ \\<or>\\<^sub>A\n                      A2' x1_ x1a_ \\<or>\\<^sub>A\n                      A3' x1_ x1a_ \\<or>\\<^sub>A\n                      A4a' x1_ x1a_ \\<or>\\<^sub>A\n                      A4b' x1_ x1a_ \\<or>\\<^sub>A A5' x1_ x1a_\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E1 x1_) (E1 x1a_) = true; e = E1 x1_;\n     e' = E1 x1a_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>1' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "applyS (simp add: hn_ctxt_def entt_disjI1' entt_disjI2')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E1 x1_) (E1 x1a_) = true; e = E1 x1_;\n     e' = E1 x1a_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>1' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "apply1 (rule entt_trans[OF _ MERGE2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E1 x1_) (E1 x1a_) = true; e = E1 x1_;\n     e' = E1 x1a_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>1' \\<Longrightarrow>\\<^sub>t\n                      \\<Gamma>1' \\<or>\\<^sub>A\n                      \\<Gamma>2' \\<or>\\<^sub>A\n                      \\<Gamma>3' \\<or>\\<^sub>A\n                      \\<Gamma>4' \\<or>\\<^sub>A \\<Gamma>5'", "applyS (simp add: entt_disjI1' entt_disjI2')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>h2 x2 x2a.\n       \\<lbrakk>h2 \\<Turnstile> F;\n        hn_invalid (enum_assn A) (E2 x2) (E2 x2a) = true; e = E2 x2;\n        e' = E2 x2a\\<rbrakk>\n       \\<Longrightarrow> hn_refine (A x2 x2a * F) (f2' x2a)\n                          (A' x2 x2a * \\<Gamma>') R (f2 x2)\n 2. \\<And>h2.\n       \\<lbrakk>h2 \\<Turnstile> F; hn_invalid (enum_assn A) E3 E3 = true;\n        e = E3; e' = E3\\<rbrakk>\n       \\<Longrightarrow> hn_refine F f3' \\<Gamma>' R f3\n 3. \\<And>h2 x41 x42 x41a x42a.\n       \\<lbrakk>h2 \\<Turnstile> F;\n        hn_invalid (enum_assn A) (E4 x41 x42) (E4 x41a x42a) = true;\n        e = E4 x41 x42; e' = E4 x41a x42a\\<rbrakk>\n       \\<Longrightarrow> hn_refine (A x41 x41a * A x42 x42a * F)\n                          (f4' x41a x42a)\n                          (A' x41 x41a * A' x42 x42a * \\<Gamma>') R\n                          (f4 x41 x42)\n 4. \\<And>h2 x51 x52 x51a x52a.\n       \\<lbrakk>h2 \\<Turnstile> F;\n        hn_invalid (enum_assn A) (E5 x51 x52) (E5 x51a x52a) = true;\n        e = E5 x51 x52; e' = E5 x51a x52a\\<rbrakk>\n       \\<Longrightarrow> hn_refine (bool_assn x51 x51a * A x52 x52a * F)\n                          (f5' x51a x52a)\n                          (bool_assn x51 x51a * A' x52 x52a * \\<Gamma>') R\n                          (f5 x51 x52)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E2 x2_) (E2 x2a_) = true; e = E2 x2_;\n     e' = E2 x2a_\\<rbrakk>\n    \\<Longrightarrow> hn_refine (A x2_ x2a_ * F) (f2' x2a_)\n                       (A' x2_ x2a_ * \\<Gamma>') R (f2 x2_)", "apply (rule hn_refine_cons[OF _ E2 _ entt_refl]; assumption?)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E2 x2_) (E2 x2a_) = true; e = E2 x2_;\n     e' = E2 x2a_\\<rbrakk>\n    \\<Longrightarrow> A x2_ x2a_ * F \\<Longrightarrow>\\<^sub>t\n                      hn_ctxt A x2_ x2a_ * INVe * F\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E2 x2_) (E2 x2a_) = true; e = E2 x2_;\n     e' = E2 x2a_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt A2' x2_ x2a_ * hn_ctxt XX2 e e' *\n                      \\<Gamma>2' \\<Longrightarrow>\\<^sub>t\n                      A' x2_ x2a_ * \\<Gamma>'", "applyS (simp add: hn_ctxt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E2 x2_) (E2 x2a_) = true; e = E2 x2_;\n     e' = E2 x2a_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt A2' x2_ x2a_ * hn_ctxt XX2 e e' *\n                      \\<Gamma>2' \\<Longrightarrow>\\<^sub>t\n                      A' x2_ x2a_ * \\<Gamma>'", "apply (rule entt_star_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E2 x2_) (E2 x2a_) = true; e = E2 x2_;\n     e' = E2 x2a_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt A2' x2_ x2a_ *\n                      hn_ctxt XX2 e e' \\<Longrightarrow>\\<^sub>t\n                      A' x2_ x2a_\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E2 x2_) (E2 x2a_) = true; e = E2 x2_;\n     e' = E2 x2a_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>2' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "apply1 (rule entt_fr_drop)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E2 x2_) (E2 x2a_) = true; e = E2 x2_;\n     e' = E2 x2a_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt A2' x2_ x2a_ \\<Longrightarrow>\\<^sub>t\n                      A' x2_ x2a_\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E2 x2_) (E2 x2a_) = true; e = E2 x2_;\n     e' = E2 x2a_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>2' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "apply1 (rule entt_trans[OF _ MERGE1])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E2 x2_) (E2 x2a_) = true; e = E2 x2_;\n     e' = E2 x2a_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt A2' x2_ x2a_ \\<Longrightarrow>\\<^sub>t\n                      A1' x2_ x2a_ \\<or>\\<^sub>A\n                      A2' x2_ x2a_ \\<or>\\<^sub>A\n                      A3' x2_ x2a_ \\<or>\\<^sub>A\n                      A4a' x2_ x2a_ \\<or>\\<^sub>A\n                      A4b' x2_ x2a_ \\<or>\\<^sub>A A5' x2_ x2a_\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E2 x2_) (E2 x2a_) = true; e = E2 x2_;\n     e' = E2 x2a_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>2' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "applyS (simp add: hn_ctxt_def entt_disjI1' entt_disjI2')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E2 x2_) (E2 x2a_) = true; e = E2 x2_;\n     e' = E2 x2a_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>2' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "apply1 (rule entt_trans[OF _ MERGE2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E2 x2_) (E2 x2a_) = true; e = E2 x2_;\n     e' = E2 x2a_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>2' \\<Longrightarrow>\\<^sub>t\n                      \\<Gamma>1' \\<or>\\<^sub>A\n                      \\<Gamma>2' \\<or>\\<^sub>A\n                      \\<Gamma>3' \\<or>\\<^sub>A\n                      \\<Gamma>4' \\<or>\\<^sub>A \\<Gamma>5'", "applyS (simp add: entt_disjI1' entt_disjI2')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>h2.\n       \\<lbrakk>h2 \\<Turnstile> F; hn_invalid (enum_assn A) E3 E3 = true;\n        e = E3; e' = E3\\<rbrakk>\n       \\<Longrightarrow> hn_refine F f3' \\<Gamma>' R f3\n 2. \\<And>h2 x41 x42 x41a x42a.\n       \\<lbrakk>h2 \\<Turnstile> F;\n        hn_invalid (enum_assn A) (E4 x41 x42) (E4 x41a x42a) = true;\n        e = E4 x41 x42; e' = E4 x41a x42a\\<rbrakk>\n       \\<Longrightarrow> hn_refine (A x41 x41a * A x42 x42a * F)\n                          (f4' x41a x42a)\n                          (A' x41 x41a * A' x42 x42a * \\<Gamma>') R\n                          (f4 x41 x42)\n 3. \\<And>h2 x51 x52 x51a x52a.\n       \\<lbrakk>h2 \\<Turnstile> F;\n        hn_invalid (enum_assn A) (E5 x51 x52) (E5 x51a x52a) = true;\n        e = E5 x51 x52; e' = E5 x51a x52a\\<rbrakk>\n       \\<Longrightarrow> hn_refine (bool_assn x51 x51a * A x52 x52a * F)\n                          (f5' x51a x52a)\n                          (bool_assn x51 x51a * A' x52 x52a * \\<Gamma>') R\n                          (f5 x51 x52)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F; hn_invalid (enum_assn A) E3 E3 = true;\n     e = E3; e' = E3\\<rbrakk>\n    \\<Longrightarrow> hn_refine F f3' \\<Gamma>' R f3", "apply (rule hn_refine_cons[OF _ E3 _ entt_refl]; assumption?)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F; hn_invalid (enum_assn A) E3 E3 = true;\n     e = E3; e' = E3\\<rbrakk>\n    \\<Longrightarrow> F \\<Longrightarrow>\\<^sub>t\n                      hn_ctxt (enum_assn A) e e' * F\n 2. \\<lbrakk>h2_ \\<Turnstile> F; hn_invalid (enum_assn A) E3 E3 = true;\n     e = E3; e' = E3\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt XX3 e e' *\n                      \\<Gamma>3' \\<Longrightarrow>\\<^sub>t\n                      \\<Gamma>'", "applyS (simp add: hn_ctxt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F; hn_invalid (enum_assn A) E3 E3 = true;\n     e = E3; e' = E3\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt XX3 e e' *\n                      \\<Gamma>3' \\<Longrightarrow>\\<^sub>t\n                      \\<Gamma>'", "apply (subst mult.commute, rule entt_fr_drop)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F; hn_invalid (enum_assn A) E3 E3 = true;\n     e = E3; e' = E3\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>3' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "apply (rule entt_trans[OF _ MERGE2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F; hn_invalid (enum_assn A) E3 E3 = true;\n     e = E3; e' = E3\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>3' \\<Longrightarrow>\\<^sub>t\n                      \\<Gamma>1' \\<or>\\<^sub>A\n                      \\<Gamma>2' \\<or>\\<^sub>A\n                      \\<Gamma>3' \\<or>\\<^sub>A\n                      \\<Gamma>4' \\<or>\\<^sub>A \\<Gamma>5'", "apply (simp add: entt_disjI1' entt_disjI2')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>h2 x41 x42 x41a x42a.\n       \\<lbrakk>h2 \\<Turnstile> F;\n        hn_invalid (enum_assn A) (E4 x41 x42) (E4 x41a x42a) = true;\n        e = E4 x41 x42; e' = E4 x41a x42a\\<rbrakk>\n       \\<Longrightarrow> hn_refine (A x41 x41a * A x42 x42a * F)\n                          (f4' x41a x42a)\n                          (A' x41 x41a * A' x42 x42a * \\<Gamma>') R\n                          (f4 x41 x42)\n 2. \\<And>h2 x51 x52 x51a x52a.\n       \\<lbrakk>h2 \\<Turnstile> F;\n        hn_invalid (enum_assn A) (E5 x51 x52) (E5 x51a x52a) = true;\n        e = E5 x51 x52; e' = E5 x51a x52a\\<rbrakk>\n       \\<Longrightarrow> hn_refine (bool_assn x51 x51a * A x52 x52a * F)\n                          (f5' x51a x52a)\n                          (bool_assn x51 x51a * A' x52 x52a * \\<Gamma>') R\n                          (f5 x51 x52)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E4 x41_ x42_) (E4 x41a_ x42a_) = true;\n     e = E4 x41_ x42_; e' = E4 x41a_ x42a_\\<rbrakk>\n    \\<Longrightarrow> hn_refine (A x41_ x41a_ * A x42_ x42a_ * F)\n                       (f4' x41a_ x42a_)\n                       (A' x41_ x41a_ * A' x42_ x42a_ * \\<Gamma>') R\n                       (f4 x41_ x42_)", "apply (rule hn_refine_cons[OF _ E4 _ entt_refl]; assumption?)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E4 x41_ x42_) (E4 x41a_ x42a_) = true;\n     e = E4 x41_ x42_; e' = E4 x41a_ x42a_\\<rbrakk>\n    \\<Longrightarrow> A x41_ x41a_ * A x42_ x42a_ *\n                      F \\<Longrightarrow>\\<^sub>t\n                      hn_ctxt A x41_ x41a_ * hn_ctxt A x42_ x42a_ * INVe * F\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E4 x41_ x42_) (E4 x41a_ x42a_) = true;\n     e = E4 x41_ x42_; e' = E4 x41a_ x42a_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt A4a' x41_ x41a_ * hn_ctxt A4b' x42_ x42a_ *\n                      hn_ctxt XX4 e e' *\n                      \\<Gamma>4' \\<Longrightarrow>\\<^sub>t\n                      A' x41_ x41a_ * A' x42_ x42a_ * \\<Gamma>'", "applyS (simp add: hn_ctxt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E4 x41_ x42_) (E4 x41a_ x42a_) = true;\n     e = E4 x41_ x42_; e' = E4 x41a_ x42a_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt A4a' x41_ x41a_ * hn_ctxt A4b' x42_ x42a_ *\n                      hn_ctxt XX4 e e' *\n                      \\<Gamma>4' \\<Longrightarrow>\\<^sub>t\n                      A' x41_ x41a_ * A' x42_ x42a_ * \\<Gamma>'", "apply (rule entt_star_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E4 x41_ x42_) (E4 x41a_ x42a_) = true;\n     e = E4 x41_ x42_; e' = E4 x41a_ x42a_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt A4a' x41_ x41a_ * hn_ctxt A4b' x42_ x42a_ *\n                      hn_ctxt XX4 e e' \\<Longrightarrow>\\<^sub>t\n                      A' x41_ x41a_ * A' x42_ x42a_\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E4 x41_ x42_) (E4 x41a_ x42a_) = true;\n     e = E4 x41_ x42_; e' = E4 x41a_ x42a_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>4' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "apply1 (rule entt_fr_drop)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E4 x41_ x42_) (E4 x41a_ x42a_) = true;\n     e = E4 x41_ x42_; e' = E4 x41a_ x42a_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt A4a' x41_ x41a_ *\n                      hn_ctxt A4b' x42_ x42a_ \\<Longrightarrow>\\<^sub>t\n                      A' x41_ x41a_ * A' x42_ x42a_\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E4 x41_ x42_) (E4 x41a_ x42a_) = true;\n     e = E4 x41_ x42_; e' = E4 x41a_ x42a_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>4' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "apply (rule entt_star_mono)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E4 x41_ x42_) (E4 x41a_ x42a_) = true;\n     e = E4 x41_ x42_; e' = E4 x41a_ x42a_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt A4a' x41_ x41a_ \\<Longrightarrow>\\<^sub>t\n                      A' x41_ x41a_\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E4 x41_ x42_) (E4 x41a_ x42a_) = true;\n     e = E4 x41_ x42_; e' = E4 x41a_ x42a_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt A4b' x42_ x42a_ \\<Longrightarrow>\\<^sub>t\n                      A' x42_ x42a_\n 3. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E4 x41_ x42_) (E4 x41a_ x42a_) = true;\n     e = E4 x41_ x42_; e' = E4 x41a_ x42a_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>4' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "apply1 (rule entt_trans[OF _ MERGE1])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E4 x41_ x42_) (E4 x41a_ x42a_) = true;\n     e = E4 x41_ x42_; e' = E4 x41a_ x42a_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt A4a' x41_ x41a_ \\<Longrightarrow>\\<^sub>t\n                      A1' x41_ x41a_ \\<or>\\<^sub>A\n                      A2' x41_ x41a_ \\<or>\\<^sub>A\n                      A3' x41_ x41a_ \\<or>\\<^sub>A\n                      A4a' x41_ x41a_ \\<or>\\<^sub>A\n                      A4b' x41_ x41a_ \\<or>\\<^sub>A A5' x41_ x41a_\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E4 x41_ x42_) (E4 x41a_ x42a_) = true;\n     e = E4 x41_ x42_; e' = E4 x41a_ x42a_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt A4b' x42_ x42a_ \\<Longrightarrow>\\<^sub>t\n                      A' x42_ x42a_\n 3. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E4 x41_ x42_) (E4 x41a_ x42a_) = true;\n     e = E4 x41_ x42_; e' = E4 x41a_ x42a_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>4' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "applyS (simp add: hn_ctxt_def entt_disjI1' entt_disjI2')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E4 x41_ x42_) (E4 x41a_ x42a_) = true;\n     e = E4 x41_ x42_; e' = E4 x41a_ x42a_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt A4b' x42_ x42a_ \\<Longrightarrow>\\<^sub>t\n                      A' x42_ x42a_\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E4 x41_ x42_) (E4 x41a_ x42a_) = true;\n     e = E4 x41_ x42_; e' = E4 x41a_ x42a_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>4' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "apply1 (rule entt_trans[OF _ MERGE1])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E4 x41_ x42_) (E4 x41a_ x42a_) = true;\n     e = E4 x41_ x42_; e' = E4 x41a_ x42a_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt A4b' x42_ x42a_ \\<Longrightarrow>\\<^sub>t\n                      A1' x42_ x42a_ \\<or>\\<^sub>A\n                      A2' x42_ x42a_ \\<or>\\<^sub>A\n                      A3' x42_ x42a_ \\<or>\\<^sub>A\n                      A4a' x42_ x42a_ \\<or>\\<^sub>A\n                      A4b' x42_ x42a_ \\<or>\\<^sub>A A5' x42_ x42a_\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E4 x41_ x42_) (E4 x41a_ x42a_) = true;\n     e = E4 x41_ x42_; e' = E4 x41a_ x42a_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>4' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "applyS (simp add: hn_ctxt_def entt_disjI1' entt_disjI2')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E4 x41_ x42_) (E4 x41a_ x42a_) = true;\n     e = E4 x41_ x42_; e' = E4 x41a_ x42a_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>4' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "apply1 (rule entt_trans[OF _ MERGE2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E4 x41_ x42_) (E4 x41a_ x42a_) = true;\n     e = E4 x41_ x42_; e' = E4 x41a_ x42a_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>4' \\<Longrightarrow>\\<^sub>t\n                      \\<Gamma>1' \\<or>\\<^sub>A\n                      \\<Gamma>2' \\<or>\\<^sub>A\n                      \\<Gamma>3' \\<or>\\<^sub>A\n                      \\<Gamma>4' \\<or>\\<^sub>A \\<Gamma>5'", "applyS (simp add: entt_disjI1' entt_disjI2')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h2 x51 x52 x51a x52a.\n       \\<lbrakk>h2 \\<Turnstile> F;\n        hn_invalid (enum_assn A) (E5 x51 x52) (E5 x51a x52a) = true;\n        e = E5 x51 x52; e' = E5 x51a x52a\\<rbrakk>\n       \\<Longrightarrow> hn_refine (bool_assn x51 x51a * A x52 x52a * F)\n                          (f5' x51a x52a)\n                          (bool_assn x51 x51a * A' x52 x52a * \\<Gamma>') R\n                          (f5 x51 x52)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E5 x51_ x52_) (E5 x51a_ x52a_) = true;\n     e = E5 x51_ x52_; e' = E5 x51a_ x52a_\\<rbrakk>\n    \\<Longrightarrow> hn_refine (bool_assn x51_ x51a_ * A x52_ x52a_ * F)\n                       (f5' x51a_ x52a_)\n                       (bool_assn x51_ x51a_ * A' x52_ x52a_ * \\<Gamma>') R\n                       (f5 x51_ x52_)", "apply (rule hn_refine_cons[OF _ E5 _ entt_refl]; assumption?)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E5 x51_ x52_) (E5 x51a_ x52a_) = true;\n     e = E5 x51_ x52_; e' = E5 x51a_ x52a_\\<rbrakk>\n    \\<Longrightarrow> bool_assn x51_ x51a_ * A x52_ x52a_ *\n                      F \\<Longrightarrow>\\<^sub>t\n                      hn_val bool_rel x51_ x51a_ * hn_ctxt A x52_ x52a_ *\n                      INVe *\n                      F\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E5 x51_ x52_) (E5 x51a_ x52a_) = true;\n     e = E5 x51_ x52_; e' = E5 x51a_ x52a_\\<rbrakk>\n    \\<Longrightarrow> hn_val bool_rel x51_ x51a_ * hn_ctxt A5' x52_ x52a_ *\n                      hn_ctxt XX5 e e' *\n                      \\<Gamma>5' \\<Longrightarrow>\\<^sub>t\n                      bool_assn x51_ x51a_ * A' x52_ x52a_ * \\<Gamma>'", "applyS (simp add: hn_ctxt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E5 x51_ x52_) (E5 x51a_ x52a_) = true;\n     e = E5 x51_ x52_; e' = E5 x51a_ x52a_\\<rbrakk>\n    \\<Longrightarrow> hn_val bool_rel x51_ x51a_ * hn_ctxt A5' x52_ x52a_ *\n                      hn_ctxt XX5 e e' *\n                      \\<Gamma>5' \\<Longrightarrow>\\<^sub>t\n                      bool_assn x51_ x51a_ * A' x52_ x52a_ * \\<Gamma>'", "apply (rule entt_star_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E5 x51_ x52_) (E5 x51a_ x52a_) = true;\n     e = E5 x51_ x52_; e' = E5 x51a_ x52a_\\<rbrakk>\n    \\<Longrightarrow> hn_val bool_rel x51_ x51a_ * hn_ctxt A5' x52_ x52a_ *\n                      hn_ctxt XX5 e e' \\<Longrightarrow>\\<^sub>t\n                      bool_assn x51_ x51a_ * A' x52_ x52a_\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E5 x51_ x52_) (E5 x51a_ x52a_) = true;\n     e = E5 x51_ x52_; e' = E5 x51a_ x52a_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>5' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "apply1 (rule entt_fr_drop)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E5 x51_ x52_) (E5 x51a_ x52a_) = true;\n     e = E5 x51_ x52_; e' = E5 x51a_ x52a_\\<rbrakk>\n    \\<Longrightarrow> hn_val bool_rel x51_ x51a_ *\n                      hn_ctxt A5' x52_ x52a_ \\<Longrightarrow>\\<^sub>t\n                      bool_assn x51_ x51a_ * A' x52_ x52a_\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E5 x51_ x52_) (E5 x51a_ x52a_) = true;\n     e = E5 x51_ x52_; e' = E5 x51a_ x52a_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>5' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "apply (rule entt_star_mono)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E5 x51_ x52_) (E5 x51a_ x52a_) = true;\n     e = E5 x51_ x52_; e' = E5 x51a_ x52a_\\<rbrakk>\n    \\<Longrightarrow> hn_val bool_rel x51_ x51a_ \\<Longrightarrow>\\<^sub>t\n                      bool_assn x51_ x51a_\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E5 x51_ x52_) (E5 x51a_ x52a_) = true;\n     e = E5 x51_ x52_; e' = E5 x51a_ x52a_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt A5' x52_ x52a_ \\<Longrightarrow>\\<^sub>t\n                      A' x52_ x52a_\n 3. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E5 x51_ x52_) (E5 x51a_ x52a_) = true;\n     e = E5 x51_ x52_; e' = E5 x51a_ x52a_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>5' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "apply1 (rule ent_imp_entt)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E5 x51_ x52_) (E5 x51a_ x52a_) = true;\n     e = E5 x51_ x52_; e' = E5 x51a_ x52a_\\<rbrakk>\n    \\<Longrightarrow> hn_val bool_rel x51_ x51a_ \\<Longrightarrow>\\<^sub>A\n                      bool_assn x51_ x51a_\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E5 x51_ x52_) (E5 x51a_ x52a_) = true;\n     e = E5 x51_ x52_; e' = E5 x51a_ x52a_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt A5' x52_ x52a_ \\<Longrightarrow>\\<^sub>t\n                      A' x52_ x52a_\n 3. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E5 x51_ x52_) (E5 x51a_ x52a_) = true;\n     e = E5 x51_ x52_; e' = E5 x51a_ x52a_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>5' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "applyS (simp add: hn_ctxt_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E5 x51_ x52_) (E5 x51a_ x52a_) = true;\n     e = E5 x51_ x52_; e' = E5 x51a_ x52a_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt A5' x52_ x52a_ \\<Longrightarrow>\\<^sub>t\n                      A' x52_ x52a_\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E5 x51_ x52_) (E5 x51a_ x52a_) = true;\n     e = E5 x51_ x52_; e' = E5 x51a_ x52a_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>5' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "apply1 (rule entt_trans[OF _ MERGE1])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E5 x51_ x52_) (E5 x51a_ x52a_) = true;\n     e = E5 x51_ x52_; e' = E5 x51a_ x52a_\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt A5' x52_ x52a_ \\<Longrightarrow>\\<^sub>t\n                      A1' x52_ x52a_ \\<or>\\<^sub>A\n                      A2' x52_ x52a_ \\<or>\\<^sub>A\n                      A3' x52_ x52a_ \\<or>\\<^sub>A\n                      A4a' x52_ x52a_ \\<or>\\<^sub>A\n                      A4b' x52_ x52a_ \\<or>\\<^sub>A A5' x52_ x52a_\n 2. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E5 x51_ x52_) (E5 x51a_ x52a_) = true;\n     e = E5 x51_ x52_; e' = E5 x51a_ x52a_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>5' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "applyS (simp add: hn_ctxt_def entt_disjI1' entt_disjI2')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E5 x51_ x52_) (E5 x51a_ x52a_) = true;\n     e = E5 x51_ x52_; e' = E5 x51a_ x52a_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>5' \\<Longrightarrow>\\<^sub>t \\<Gamma>'", "apply1 (rule entt_trans[OF _ MERGE2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h2_ \\<Turnstile> F;\n     hn_invalid (enum_assn A) (E5 x51_ x52_) (E5 x51a_ x52a_) = true;\n     e = E5 x51_ x52_; e' = E5 x51a_ x52a_\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma>5' \\<Longrightarrow>\\<^sub>t\n                      \\<Gamma>1' \\<or>\\<^sub>A\n                      \\<Gamma>2' \\<or>\\<^sub>A\n                      \\<Gamma>3' \\<or>\\<^sub>A\n                      \\<Gamma>4' \\<or>\\<^sub>A \\<Gamma>5'", "applyS (simp add: entt_disjI1' entt_disjI2')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>After some more preprocessing (adding extra frame-rules for non-atomic postconditions, \n    and splitting the merge-terms into binary merges), this rule can be registered\\<close>"], ["", "lemmas [sepref_comb_rules] = enum_cases_hnr[sepref_prep_comb_rule]"], ["", "subsection \\<open>Regression Test\\<close>"], ["", "definition \"test1 (e::bool enum) \\<equiv> RETURN e\""], ["", "sepref_definition test1_impl is \"test1\" :: \"(enum_assn bool_assn)\\<^sup>d \\<rightarrow>\\<^sub>a enum_assn bool_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, test1)\n    \\<in> (enum_assn\n            bool_assn)\\<^sup>d \\<rightarrow>\\<^sub>a enum_assn bool_assn", "unfolding test1_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, RETURN)\n    \\<in> (enum_assn\n            bool_assn)\\<^sup>d \\<rightarrow>\\<^sub>a enum_assn bool_assn", "by sepref"], ["", "sepref_register test1"], ["", "lemmas [sepref_fr_rules] = test1_impl.refine"], ["", "definition \"test \\<equiv> do {\n    let x = E1 True;\n\n    _ \\<leftarrow> case x of\n      E1 a \\<Rightarrow> RETURN (Some a)  \\<comment> \\<open>Access and invalidate compound inside case\\<close>\n    | _ \\<Rightarrow> RETURN (Some True);  \n\n    _ \\<leftarrow> test1 x; \\<comment> \\<open>Rely on structure being there, with valid compound\\<close>\n\n    \\<comment> \\<open>Same thing again, with merge\\<close>\n    _ \\<leftarrow> if True then\n      case x of\n        E1 a \\<Rightarrow> RETURN (Some a)  \\<comment> \\<open>Access and invalidate compound inside case\\<close>\n      | _ \\<Rightarrow> RETURN (Some True)\n     else RETURN None; \n    _ \\<leftarrow> test1 x; \\<comment> \\<open>Rely on structure being there, with valid compound\\<close>\n    \n    \\<comment> \\<open>Now test with non-pure\\<close>\n    let a = op_array_replicate 4 (3::nat);\n    let x = E5 False a;\n    \n    _ \\<leftarrow> case x of\n      E1 _ \\<Rightarrow> RETURN (0::nat)\n    | E2 _ \\<Rightarrow> RETURN 1\n    | E3 \\<Rightarrow> RETURN 0\n    | E4 _ _ \\<Rightarrow> RETURN 0\n    | E5 _ a \\<Rightarrow> mop_list_get a 0;\n\n    \\<comment> \\<open>Rely on that compound still exists (it's components are only read in the case above)\\<close>\n    case x of\n      E1 a \\<Rightarrow> do {mop_list_set a 0 0; RETURN (0::nat)}\n    | E2 _ \\<Rightarrow> RETURN 1\n    | E3 \\<Rightarrow> RETURN 0\n    | E4 _ _ \\<Rightarrow> RETURN 0\n    | E5 _ _ \\<Rightarrow> RETURN 0\n  }\""], ["", "lemmas [safe_constraint_rules] = CN_FALSEI[of is_pure \"invalid_assn A\" for A]"], ["", "sepref_definition foo is \"uncurry0 test\" :: \"unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2, uncurry0 test)\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "unfolding test_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2,\n     uncurry0\n      (let x = E1 True\n       in (case x of E1 a \\<Rightarrow> RETURN (Some a)\n           | _ \\<Rightarrow> RETURN (Some True)) \\<bind>\n          (\\<lambda>_.\n              test1 x \\<bind>\n              (\\<lambda>_.\n                  (if True\n                   then case x of E1 a \\<Rightarrow> RETURN (Some a)\n                        | _ \\<Rightarrow> RETURN (Some True)\n                   else RETURN None) \\<bind>\n                  (\\<lambda>_.\n                      test1 x \\<bind>\n                      (\\<lambda>_.\n                          let a = op_array_replicate 4 3; x = E5 False a\n                          in (case x of E2 x \\<Rightarrow> RETURN 1\n                              | E5 x a \\<Rightarrow> mop_list_get a 0\n                              | _ \\<Rightarrow> RETURN 0) \\<bind>\n                             (\\<lambda>_.\n                                 case x of\n                                 E1 a \\<Rightarrow>\n                                   mop_list_set a 0 0 \\<bind>\n                                   (\\<lambda>_. RETURN 0)\n                                 | E2 x \\<Rightarrow> RETURN 1\n                                 | _ \\<Rightarrow> RETURN 0)))))))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "supply [[goals_limit=1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2,\n     uncurry0\n      (let x = E1 True\n       in (case x of E1 a \\<Rightarrow> RETURN (Some a)\n           | _ \\<Rightarrow> RETURN (Some True)) \\<bind>\n          (\\<lambda>_.\n              test1 x \\<bind>\n              (\\<lambda>_.\n                  (if True\n                   then case x of E1 a \\<Rightarrow> RETURN (Some a)\n                        | _ \\<Rightarrow> RETURN (Some True)\n                   else RETURN None) \\<bind>\n                  (\\<lambda>_.\n                      test1 x \\<bind>\n                      (\\<lambda>_.\n                          let a = op_array_replicate 4 3; x = E5 False a\n                          in (case x of E2 x \\<Rightarrow> RETURN 1\n                              | E5 x a \\<Rightarrow> mop_list_get a 0\n                              | _ \\<Rightarrow> RETURN 0) \\<bind>\n                             (\\<lambda>_.\n                                 case x of\n                                 E1 a \\<Rightarrow>\n                                   mop_list_set a 0 0 \\<bind>\n                                   (\\<lambda>_. RETURN 0)\n                                 | E2 x \\<Rightarrow> RETURN 1\n                                 | _ \\<Rightarrow> RETURN 0)))))))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "by sepref"], ["", "end"]]}