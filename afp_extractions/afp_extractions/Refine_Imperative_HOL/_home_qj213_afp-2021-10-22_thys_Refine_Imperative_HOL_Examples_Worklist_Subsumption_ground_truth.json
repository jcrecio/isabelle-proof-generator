{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/Examples/Worklist_Subsumption.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemma take_from_set_correct:\n  assumes \"s \\<noteq> {}\"\n  shows \"take_from_set s \\<le> SPEC (\\<lambda> (x, s'). x \\<in> s \\<and> s' = s - {x})\"", "lemmas [refine_vcg] = take_from_set_correct[THEN order.trans]", "lemma take_from_mset_correct:\n  assumes \"s \\<noteq> {#}\"\n  shows \"take_from_mset s \\<le> SPEC (\\<lambda> (x, s'). x \\<in># s \\<and> s' = s - {#x#})\"", "lemmas [refine_vcg] = take_from_mset_correct[THEN order.trans]", "lemma set_mset_mp: \"set_mset m \\<subseteq> s \\<Longrightarrow> n < count m x \\<Longrightarrow> x\\<in>s\"", "lemma pred_not_lt_is_zero: \"(\\<not> n - Suc 0 < n) \\<longleftrightarrow> n=0\"", "lemma start_reachable[intro!, simp]:\n    \"reachable a\\<^sub>0\"", "lemma step_reachable:\n    assumes \"reachable a\" \"E a a'\"\n    shows \"reachable a'\"", "lemma finitely_branching:\n    assumes \"reachable a\"  \n    shows \"finite (Collect (E a))\"", "lemma wf_worklist_var:\n    \"wf worklist_var\"", "lemma aux1:\n    assumes \"\\<forall>x\\<in>passed. \\<not> a \\<preceq> x\"\n        and \"passed \\<subseteq> Collect reachable\"\n        and \"reachable a\"\n    shows \"\n    ((insert a passed, wait', brk'),\n     passed, wait, brk)\n    \\<in> worklist_var\"", "lemma aux2:\n    assumes\n      \"a' \\<in> passed\"\n      \"a \\<preceq> a'\"\n      \"a \\<in># wait\"\n      \"worklist_inv_frontier passed wait\"\n    shows \"worklist_inv_frontier passed (wait - {#a#})\"", "lemma aux5:\n    assumes\n      \"a' \\<in> passed\"\n      \"a \\<preceq> a'\"\n      \"a \\<in># wait\"\n      \"start_subsumed passed wait\"\n    shows \"start_subsumed passed (wait - {#a#})\"", "lemma aux3:\n    assumes\n      \"set_mset wait \\<subseteq> Collect reachable\"\n      \"a \\<in># wait\"\n      \"set_mset wait' = set_mset (wait - {#a#}) \\<union> Collect (E a)\"\n      \"worklist_inv_frontier passed wait\"\n    shows \"worklist_inv_frontier (insert a passed) wait'\"", "lemma aux6:\n    assumes\n      \"a \\<in># wait\"\n      \"start_subsumed passed wait\"\n      \"set_mset wait' = set_mset (wait - {#a#}) \\<union> Collect (E a)\"\n    shows \"start_subsumed (insert a passed) wait'\"", "lemma aux4:\n    assumes \"worklist_inv_frontier passed {#}\" \"reachable x\" \"start_subsumed passed {#}\"\n            \"passed \\<subseteq> Collect reachable\"\n    shows \"\\<exists> x' \\<in> passed. x \\<preceq> x'\"", "theorem worklist_algo_correct:\n    \"worklist_algo \\<le> SPEC (\\<lambda> brk. brk \\<longleftrightarrow> F_reachable)\"", "lemmas [refine_vcg] = worklist_algo_correct[THEN order_trans]", "lemma add_succ1_ref[refine]: \"\\<lbrakk>(wait,wait')\\<in>Id; (a,a')\\<in>b_rel Id reachable\\<rbrakk> \\<Longrightarrow> add_succ1 wait a \\<le> \\<Down>(Id \\<times>\\<^sub>r bool_rel) (add_succ_spec wait' a')\"", "lemma worklist_algo1_ref[refine]: \"worklist_algo1 \\<le> \\<Down>Id worklist_algo\""], "translations": [["", "lemma take_from_set_correct:\n  assumes \"s \\<noteq> {}\"\n  shows \"take_from_set s \\<le> SPEC (\\<lambda> (x, s'). x \\<in> s \\<and> s' = s - {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take_from_set s\n    \\<le> SPEC (\\<lambda>(x, s'). x \\<in> s \\<and> s' = s - {x})", "using assms"], ["proof (prove)\nusing this:\n  s \\<noteq> {}\n\ngoal (1 subgoal):\n 1. take_from_set s\n    \\<le> SPEC (\\<lambda>(x, s'). x \\<in> s \\<and> s' = s - {x})", "unfolding take_from_set_def"], ["proof (prove)\nusing this:\n  s \\<noteq> {}\n\ngoal (1 subgoal):\n 1. ASSERT (s \\<noteq> {}) \\<bind>\n    (\\<lambda>_. SPEC (\\<lambda>(x, s'). x \\<in> s \\<and> s' = s - {x}))\n    \\<le> SPEC (\\<lambda>(x, s'). x \\<in> s \\<and> s' = s - {x})", "by simp"], ["", "lemmas [refine_vcg] = take_from_set_correct[THEN order.trans]"], ["", "definition take_from_mset where\n  \"take_from_mset s = ASSERT (s \\<noteq> {#}) \\<then> SPEC (\\<lambda> (x, s'). x \\<in># s \\<and> s' = s - {#x#})\""], ["", "lemma take_from_mset_correct:\n  assumes \"s \\<noteq> {#}\"\n  shows \"take_from_mset s \\<le> SPEC (\\<lambda> (x, s'). x \\<in># s \\<and> s' = s - {#x#})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take_from_mset s\n    \\<le> SPEC (\\<lambda>(x, s'). x \\<in># s \\<and> s' = s - {#x#})", "using assms"], ["proof (prove)\nusing this:\n  s \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. take_from_mset s\n    \\<le> SPEC (\\<lambda>(x, s'). x \\<in># s \\<and> s' = s - {#x#})", "unfolding take_from_mset_def"], ["proof (prove)\nusing this:\n  s \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. ASSERT (s \\<noteq> {#}) \\<bind>\n    (\\<lambda>_. SPEC (\\<lambda>(x, s'). x \\<in># s \\<and> s' = s - {#x#}))\n    \\<le> SPEC (\\<lambda>(x, s'). x \\<in># s \\<and> s' = s - {#x#})", "by simp"], ["", "lemmas [refine_vcg] = take_from_mset_correct[THEN order.trans]"], ["", "lemma set_mset_mp: \"set_mset m \\<subseteq> s \\<Longrightarrow> n < count m x \\<Longrightarrow> x\\<in>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set_mset m \\<subseteq> s; n < count m x\\<rbrakk>\n    \\<Longrightarrow> x \\<in> s", "by (meson count_greater_zero_iff le_less_trans subsetCE zero_le)"], ["", "lemma pred_not_lt_is_zero: \"(\\<not> n - Suc 0 < n) \\<longleftrightarrow> n=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> n - Suc 0 < n) = (n = 0)", "by auto"], ["", "subsection \\<open>Search Spaces\\<close>"], ["", "text \\<open>\n  A search space consists of a step relation, a start state, \n  a final state predicate, and a subsumption preorder.\n\\<close>"], ["", "locale Search_Space_Defs =\n  fixes E :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" \\<comment> \\<open>Step relation\\<close>\n    and a\\<^sub>0 :: 'a                \\<comment> \\<open>Start state\\<close> \n    and F :: \"'a \\<Rightarrow> bool\"      \\<comment> \\<open>Final states\\<close>\n    and subsumes :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" (infix \"\\<preceq>\" 50) \\<comment> \\<open>Subsumption preorder\\<close>\nbegin"], ["", "definition reachable where\n    \"reachable = E\\<^sup>*\\<^sup>* a\\<^sub>0\""], ["", "definition \"F_reachable \\<equiv> \\<exists>a. reachable a \\<and> F a\""], ["", "end"], ["", "text \\<open>The set of reachable states must be finite, \n  subsumption must be a preorder, and be compatible with steps and final states.\\<close>"], ["", "locale Search_Space = Search_Space_Defs +\n  assumes finite_reachable: \"finite {a. reachable a}\"\n\n  assumes refl[intro!, simp]: \"a \\<preceq> a\"\n      and trans[trans]: \"a \\<preceq> b \\<Longrightarrow> b \\<preceq> c \\<Longrightarrow> a \\<preceq> c\"\n\n  assumes mono: \"a \\<preceq> b \\<Longrightarrow> E a a' \\<Longrightarrow> reachable a \\<Longrightarrow> reachable b \\<Longrightarrow> \\<exists> b'. E b b' \\<and> a' \\<preceq> b'\"\n      and F_mono: \"a \\<preceq> a' \\<Longrightarrow> F a \\<Longrightarrow> F a'\"\nbegin"], ["", "lemma start_reachable[intro!, simp]:\n    \"reachable a\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable a\\<^sub>0", "unfolding reachable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. E\\<^sup>*\\<^sup>* a\\<^sub>0 a\\<^sub>0", "by simp"], ["", "lemma step_reachable:\n    assumes \"reachable a\" \"E a a'\"\n    shows \"reachable a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable a'", "using assms"], ["proof (prove)\nusing this:\n  reachable a\n  E a a'\n\ngoal (1 subgoal):\n 1. reachable a'", "unfolding reachable_def"], ["proof (prove)\nusing this:\n  E\\<^sup>*\\<^sup>* a\\<^sub>0 a\n  E a a'\n\ngoal (1 subgoal):\n 1. E\\<^sup>*\\<^sup>* a\\<^sub>0 a'", "by simp"], ["", "lemma finitely_branching:\n    assumes \"reachable a\"  \n    shows \"finite (Collect (E a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Collect (E a))", "by (metis assms finite_reachable finite_subset mem_Collect_eq step_reachable subsetI)"], ["", "end"], ["", "subsection \\<open>Worklist Algorithm\\<close>"], ["", "term card"], ["", "context Search_Space_Defs begin"], ["", "definition \"worklist_var = inv_image (finite_psupset (Collect reachable) <*lex*> measure size) (\\<lambda> (a, b,c). (a,b))\""], ["", "definition \"worklist_inv_frontier passed wait = \n    (\\<forall> a \\<in> passed. \\<forall> a'. E a a' \\<longrightarrow> (\\<exists> b' \\<in> passed \\<union> set_mset wait. a' \\<preceq> b'))\""], ["", "definition \"start_subsumed passed wait = (\\<exists> a \\<in> passed \\<union> set_mset wait. a\\<^sub>0 \\<preceq> a)\""], ["", "definition \"worklist_inv \\<equiv> \\<lambda> (passed, wait, brk).\n    passed \\<subseteq> Collect reachable \\<and>\n    (brk \\<longrightarrow> (\\<exists> f. reachable f \\<and> F f)) \\<and>\n    (\\<not> brk \\<longrightarrow> \n      worklist_inv_frontier passed wait \n    \\<and> (\\<forall> a \\<in> passed \\<union> set_mset wait. \\<not> F a) \n    \\<and> start_subsumed passed wait\n    \\<and> set_mset wait \\<subseteq> Collect reachable)\n    \""], ["", "definition \"add_succ_spec wait a \\<equiv> SPEC (\\<lambda>(wait',brk). \n    if \\<exists>a'. E a a' \\<and> F a' then \n      brk\n    else set_mset wait' = set_mset wait \\<union> {a' . E a a'} \\<and> \\<not>brk\n  )\""], ["", "definition worklist_algo where\n    \"worklist_algo = do\n      { \n        if F a\\<^sub>0 then RETURN True\n        else do {\n          let passed = {};\n          let wait = {#a\\<^sub>0#};\n          (passed, wait, brk) \\<leftarrow> WHILEIT worklist_inv (\\<lambda> (passed, wait, brk). \\<not> brk \\<and> wait \\<noteq> {#})\n            (\\<lambda> (passed, wait, brk). do\n              { \n                (a, wait) \\<leftarrow> take_from_mset wait;\n                ASSERT (reachable a);\n                if (\\<exists> a' \\<in> passed. a \\<preceq> a') then RETURN (passed, wait, brk) else\n                do\n                  {\n                    (wait,brk) \\<leftarrow> add_succ_spec wait a;\n                    let passed = insert a passed;\n                    RETURN (passed, wait, brk)\n                  }\n              }\n            )\n            (passed, wait, False);\n            RETURN brk\n        }\n      }\n    \""], ["", "end"], ["", "subsubsection \\<open>Correctness Proof\\<close>"], ["", "context Search_Space begin"], ["", "lemma wf_worklist_var:\n    \"wf worklist_var\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf worklist_var", "unfolding worklist_var_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (inv_image (finite_psupset (Collect reachable) <*lex*> measure size)\n         (\\<lambda>(a, b, c). (a, b)))", "by (auto simp: finite_reachable)"], ["", "context\n  begin"], ["", "private"], ["", "lemma aux1:\n    assumes \"\\<forall>x\\<in>passed. \\<not> a \\<preceq> x\"\n        and \"passed \\<subseteq> Collect reachable\"\n        and \"reachable a\"\n    shows \"\n    ((insert a passed, wait', brk'),\n     passed, wait, brk)\n    \\<in> worklist_var\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((insert a passed, wait', brk'), passed, wait, brk) \\<in> worklist_var", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((insert a passed, wait', brk'), passed, wait, brk) \\<in> worklist_var", "from assms"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>passed. \\<not> a \\<preceq> x\n  passed \\<subseteq> Collect reachable\n  reachable a", "have \"a \\<notin> passed\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>passed. \\<not> a \\<preceq> x\n  passed \\<subseteq> Collect reachable\n  reachable a\n\ngoal (1 subgoal):\n 1. a \\<notin> passed", "by auto"], ["proof (state)\nthis:\n  a \\<notin> passed\n\ngoal (1 subgoal):\n 1. ((insert a passed, wait', brk'), passed, wait, brk) \\<in> worklist_var", "with assms(2,3)"], ["proof (chain)\npicking this:\n  passed \\<subseteq> Collect reachable\n  reachable a\n  a \\<notin> passed", "show ?thesis"], ["proof (prove)\nusing this:\n  passed \\<subseteq> Collect reachable\n  reachable a\n  a \\<notin> passed\n\ngoal (1 subgoal):\n 1. ((insert a passed, wait', brk'), passed, wait, brk) \\<in> worklist_var", "by (auto simp: worklist_inv_def worklist_var_def finite_psupset_def)"], ["proof (state)\nthis:\n  ((insert a passed, wait', brk'), passed, wait, brk) \\<in> worklist_var\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma aux2:\n    assumes\n      \"a' \\<in> passed\"\n      \"a \\<preceq> a'\"\n      \"a \\<in># wait\"\n      \"worklist_inv_frontier passed wait\"\n    shows \"worklist_inv_frontier passed (wait - {#a#})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. worklist_inv_frontier passed (wait - {#a#})", "using assms"], ["proof (prove)\nusing this:\n  a' \\<in> passed\n  a \\<preceq> a'\n  a \\<in># wait\n  worklist_inv_frontier passed wait\n\ngoal (1 subgoal):\n 1. worklist_inv_frontier passed (wait - {#a#})", "unfolding worklist_inv_frontier_def"], ["proof (prove)\nusing this:\n  a' \\<in> passed\n  a \\<preceq> a'\n  a \\<in># wait\n  \\<forall>a\\<in>passed.\n     \\<forall>a'.\n        E a a' \\<longrightarrow>\n        Bex (passed \\<union> set_mset wait) ((\\<preceq>) a')\n\ngoal (1 subgoal):\n 1. \\<forall>aa\\<in>passed.\n       \\<forall>a'.\n          E aa a' \\<longrightarrow>\n          Bex (passed \\<union> set_mset (wait - {#a#})) ((\\<preceq>) a')", "using trans"], ["proof (prove)\nusing this:\n  a' \\<in> passed\n  a \\<preceq> a'\n  a \\<in># wait\n  \\<forall>a\\<in>passed.\n     \\<forall>a'.\n        E a a' \\<longrightarrow>\n        Bex (passed \\<union> set_mset wait) ((\\<preceq>) a')\n  \\<lbrakk>?a \\<preceq> ?b; ?b \\<preceq> ?c\\<rbrakk>\n  \\<Longrightarrow> ?a \\<preceq> ?c\n\ngoal (1 subgoal):\n 1. \\<forall>aa\\<in>passed.\n       \\<forall>a'.\n          E aa a' \\<longrightarrow>\n          Bex (passed \\<union> set_mset (wait - {#a#})) ((\\<preceq>) a')", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa a'a.\n       \\<lbrakk>a' \\<in> passed; a \\<preceq> a'; a \\<in># wait;\n        \\<forall>a\\<in>passed.\n           \\<forall>a'.\n              E a a' \\<longrightarrow>\n              (\\<exists>x\\<in>passed \\<union> set_mset wait.\n                  a' \\<preceq> x);\n        \\<And>a b c.\n           \\<lbrakk>a \\<preceq> b; b \\<preceq> c\\<rbrakk>\n           \\<Longrightarrow> a \\<preceq> c;\n        aa \\<in> passed; E aa a'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>passed \\<union>\n  set_mset (wait - {#a#}).\n                            a'a \\<preceq> x", "by (metis (no_types, lifting) Un_iff count_eq_zero_iff count_single mset_contains_eq mset_un_cases)"], ["", "private"], ["", "lemma aux5:\n    assumes\n      \"a' \\<in> passed\"\n      \"a \\<preceq> a'\"\n      \"a \\<in># wait\"\n      \"start_subsumed passed wait\"\n    shows \"start_subsumed passed (wait - {#a#})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. start_subsumed passed (wait - {#a#})", "using assms"], ["proof (prove)\nusing this:\n  a' \\<in> passed\n  a \\<preceq> a'\n  a \\<in># wait\n  start_subsumed passed wait\n\ngoal (1 subgoal):\n 1. start_subsumed passed (wait - {#a#})", "unfolding start_subsumed_def"], ["proof (prove)\nusing this:\n  a' \\<in> passed\n  a \\<preceq> a'\n  a \\<in># wait\n  Bex (passed \\<union> set_mset wait) ((\\<preceq>) a\\<^sub>0)\n\ngoal (1 subgoal):\n 1. Bex (passed \\<union> set_mset (wait - {#a#})) ((\\<preceq>) a\\<^sub>0)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>a' \\<in> passed; a \\<preceq> a'; a \\<in># wait;\n        x \\<in> passed \\<or> x \\<in># wait; a\\<^sub>0 \\<preceq> x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>passed \\<union>\n  set_mset (wait - {#a#}).\n                            a\\<^sub>0 \\<preceq> x", "by (metis Un_iff insert_DiffM2 local.trans mset_right_cancel_elem)"], ["", "private"], ["", "lemma aux3:\n    assumes\n      \"set_mset wait \\<subseteq> Collect reachable\"\n      \"a \\<in># wait\"\n      \"set_mset wait' = set_mset (wait - {#a#}) \\<union> Collect (E a)\"\n      \"worklist_inv_frontier passed wait\"\n    shows \"worklist_inv_frontier (insert a passed) wait'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. worklist_inv_frontier (insert a passed) wait'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. worklist_inv_frontier (insert a passed) wait'", "from assms(1,2)"], ["proof (chain)\npicking this:\n  set_mset wait \\<subseteq> Collect reachable\n  a \\<in># wait", "have \"reachable a\""], ["proof (prove)\nusing this:\n  set_mset wait \\<subseteq> Collect reachable\n  a \\<in># wait\n\ngoal (1 subgoal):\n 1. reachable a", "by (simp add: subset_iff)"], ["proof (state)\nthis:\n  reachable a\n\ngoal (1 subgoal):\n 1. worklist_inv_frontier (insert a passed) wait'", "with finitely_branching"], ["proof (chain)\npicking this:\n  reachable ?a \\<Longrightarrow> finite (Collect (E ?a))\n  reachable a", "have [simp, intro!]: \"finite (Collect (E a))\""], ["proof (prove)\nusing this:\n  reachable ?a \\<Longrightarrow> finite (Collect (E ?a))\n  reachable a\n\ngoal (1 subgoal):\n 1. finite (Collect (E a))", "."], ["proof (state)\nthis:\n  finite (Collect (E a))\n\ngoal (1 subgoal):\n 1. worklist_inv_frontier (insert a passed) wait'", "from assms(2,3,4)"], ["proof (chain)\npicking this:\n  a \\<in># wait\n  set_mset wait' = set_mset (wait - {#a#}) \\<union> Collect (E a)\n  worklist_inv_frontier passed wait", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<in># wait\n  set_mset wait' = set_mset (wait - {#a#}) \\<union> Collect (E a)\n  worklist_inv_frontier passed wait\n\ngoal (1 subgoal):\n 1. worklist_inv_frontier (insert a passed) wait'", "unfolding worklist_inv_frontier_def"], ["proof (prove)\nusing this:\n  a \\<in># wait\n  set_mset wait' = set_mset (wait - {#a#}) \\<union> Collect (E a)\n  \\<forall>a\\<in>passed.\n     \\<forall>a'.\n        E a a' \\<longrightarrow>\n        Bex (passed \\<union> set_mset wait) ((\\<preceq>) a')\n\ngoal (1 subgoal):\n 1. \\<forall>aa\\<in>insert a passed.\n       \\<forall>a'.\n          E aa a' \\<longrightarrow>\n          Bex (insert a passed \\<union> set_mset wait') ((\\<preceq>) a')", "by (metis Un_iff insert_DiffM insert_iff local.refl mem_Collect_eq set_mset_add_mset_insert)"], ["proof (state)\nthis:\n  worklist_inv_frontier (insert a passed) wait'\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma aux6:\n    assumes\n      \"a \\<in># wait\"\n      \"start_subsumed passed wait\"\n      \"set_mset wait' = set_mset (wait - {#a#}) \\<union> Collect (E a)\"\n    shows \"start_subsumed (insert a passed) wait'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. start_subsumed (insert a passed) wait'", "using assms"], ["proof (prove)\nusing this:\n  a \\<in># wait\n  start_subsumed passed wait\n  set_mset wait' = set_mset (wait - {#a#}) \\<union> Collect (E a)\n\ngoal (1 subgoal):\n 1. start_subsumed (insert a passed) wait'", "unfolding start_subsumed_def"], ["proof (prove)\nusing this:\n  a \\<in># wait\n  Bex (passed \\<union> set_mset wait) ((\\<preceq>) a\\<^sub>0)\n  set_mset wait' = set_mset (wait - {#a#}) \\<union> Collect (E a)\n\ngoal (1 subgoal):\n 1. Bex (insert a passed \\<union> set_mset wait') ((\\<preceq>) a\\<^sub>0)", "by (metis Un_iff insert_DiffM insert_iff set_mset_add_mset_insert)"], ["", "lemma aux4:\n    assumes \"worklist_inv_frontier passed {#}\" \"reachable x\" \"start_subsumed passed {#}\"\n            \"passed \\<subseteq> Collect reachable\"\n    shows \"\\<exists> x' \\<in> passed. x \\<preceq> x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x'\\<in>passed. x \\<preceq> x'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x'\\<in>passed. x \\<preceq> x'", "from \\<open>reachable x\\<close>"], ["proof (chain)\npicking this:\n  reachable x", "have \"E\\<^sup>*\\<^sup>* a\\<^sub>0 x\""], ["proof (prove)\nusing this:\n  reachable x\n\ngoal (1 subgoal):\n 1. E\\<^sup>*\\<^sup>* a\\<^sub>0 x", "by (simp add: reachable_def)"], ["proof (state)\nthis:\n  E\\<^sup>*\\<^sup>* a\\<^sub>0 x\n\ngoal (1 subgoal):\n 1. \\<exists>x'\\<in>passed. x \\<preceq> x'", "from assms(3)"], ["proof (chain)\npicking this:\n  start_subsumed passed {#}", "obtain b where \"a\\<^sub>0 \\<preceq> b\" \"b \\<in> passed\""], ["proof (prove)\nusing this:\n  start_subsumed passed {#}\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>a\\<^sub>0 \\<preceq> b; b \\<in> passed\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding start_subsumed_def"], ["proof (prove)\nusing this:\n  Bex (passed \\<union> set_mset {#}) ((\\<preceq>) a\\<^sub>0)\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>a\\<^sub>0 \\<preceq> b; b \\<in> passed\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a\\<^sub>0 \\<preceq> b\n  b \\<in> passed\n\ngoal (1 subgoal):\n 1. \\<exists>x'\\<in>passed. x \\<preceq> x'", "have \"\\<exists>x'. \\<exists> x''. E\\<^sup>*\\<^sup>* b x' \\<and> x \\<preceq> x' \\<and> x' \\<preceq> x'' \\<and> x'' \\<in> passed\" if\n                      \"E\\<^sup>*\\<^sup>* a x\" \"a \\<preceq> b\"    \"b \\<preceq> b'\"  \"b' \\<in> passed\"\n                      \"reachable a\" \"reachable b\" for a b b'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x' x''.\n       E\\<^sup>*\\<^sup>* b x' \\<and>\n       x \\<preceq> x' \\<and> x' \\<preceq> x'' \\<and> x'' \\<in> passed", "using that"], ["proof (prove)\nusing this:\n  E\\<^sup>*\\<^sup>* a x\n  a \\<preceq> b\n  b \\<preceq> b'\n  b' \\<in> passed\n  reachable a\n  reachable b\n\ngoal (1 subgoal):\n 1. \\<exists>x' x''.\n       E\\<^sup>*\\<^sup>* b x' \\<and>\n       x \\<preceq> x' \\<and> x' \\<preceq> x'' \\<and> x'' \\<in> passed", "proof (induction arbitrary: b b' rule: converse_rtranclp_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>b b'.\n       \\<lbrakk>x \\<preceq> b; b \\<preceq> b'; b' \\<in> passed; reachable x;\n        reachable b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x' x''.\n                            E\\<^sup>*\\<^sup>* b x' \\<and>\n                            x \\<preceq> x' \\<and>\n                            x' \\<preceq> x'' \\<and> x'' \\<in> passed\n 2. \\<And>y z b b'.\n       \\<lbrakk>E y z; E\\<^sup>*\\<^sup>* z x;\n        \\<And>b b'.\n           \\<lbrakk>z \\<preceq> b; b \\<preceq> b'; b' \\<in> passed;\n            reachable z; reachable b\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x' x''.\n                                E\\<^sup>*\\<^sup>* b x' \\<and>\n                                x \\<preceq> x' \\<and>\n                                x' \\<preceq> x'' \\<and> x'' \\<in> passed;\n        y \\<preceq> b; b \\<preceq> b'; b' \\<in> passed; reachable y;\n        reachable b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x' x''.\n                            E\\<^sup>*\\<^sup>* b x' \\<and>\n                            x \\<preceq> x' \\<and>\n                            x' \\<preceq> x'' \\<and> x'' \\<in> passed", "case base"], ["proof (state)\nthis:\n  x \\<preceq> b\n  b \\<preceq> b'\n  b' \\<in> passed\n  reachable x\n  reachable b\n\ngoal (2 subgoals):\n 1. \\<And>b b'.\n       \\<lbrakk>x \\<preceq> b; b \\<preceq> b'; b' \\<in> passed; reachable x;\n        reachable b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x' x''.\n                            E\\<^sup>*\\<^sup>* b x' \\<and>\n                            x \\<preceq> x' \\<and>\n                            x' \\<preceq> x'' \\<and> x'' \\<in> passed\n 2. \\<And>y z b b'.\n       \\<lbrakk>E y z; E\\<^sup>*\\<^sup>* z x;\n        \\<And>b b'.\n           \\<lbrakk>z \\<preceq> b; b \\<preceq> b'; b' \\<in> passed;\n            reachable z; reachable b\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x' x''.\n                                E\\<^sup>*\\<^sup>* b x' \\<and>\n                                x \\<preceq> x' \\<and>\n                                x' \\<preceq> x'' \\<and> x'' \\<in> passed;\n        y \\<preceq> b; b \\<preceq> b'; b' \\<in> passed; reachable y;\n        reachable b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x' x''.\n                            E\\<^sup>*\\<^sup>* b x' \\<and>\n                            x \\<preceq> x' \\<and>\n                            x' \\<preceq> x'' \\<and> x'' \\<in> passed", "then"], ["proof (chain)\npicking this:\n  x \\<preceq> b\n  b \\<preceq> b'\n  b' \\<in> passed\n  reachable x\n  reachable b", "show ?case"], ["proof (prove)\nusing this:\n  x \\<preceq> b\n  b \\<preceq> b'\n  b' \\<in> passed\n  reachable x\n  reachable b\n\ngoal (1 subgoal):\n 1. \\<exists>x' x''.\n       E\\<^sup>*\\<^sup>* b x' \\<and>\n       x \\<preceq> x' \\<and> x' \\<preceq> x'' \\<and> x'' \\<in> passed", "by auto"], ["proof (state)\nthis:\n  \\<exists>x' x''.\n     E\\<^sup>*\\<^sup>* b x' \\<and>\n     x \\<preceq> x' \\<and> x' \\<preceq> x'' \\<and> x'' \\<in> passed\n\ngoal (1 subgoal):\n 1. \\<And>y z b b'.\n       \\<lbrakk>E y z; E\\<^sup>*\\<^sup>* z x;\n        \\<And>b b'.\n           \\<lbrakk>z \\<preceq> b; b \\<preceq> b'; b' \\<in> passed;\n            reachable z; reachable b\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x' x''.\n                                E\\<^sup>*\\<^sup>* b x' \\<and>\n                                x \\<preceq> x' \\<and>\n                                x' \\<preceq> x'' \\<and> x'' \\<in> passed;\n        y \\<preceq> b; b \\<preceq> b'; b' \\<in> passed; reachable y;\n        reachable b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x' x''.\n                            E\\<^sup>*\\<^sup>* b x' \\<and>\n                            x \\<preceq> x' \\<and>\n                            x' \\<preceq> x'' \\<and> x'' \\<in> passed", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z b b'.\n       \\<lbrakk>E y z; E\\<^sup>*\\<^sup>* z x;\n        \\<And>b b'.\n           \\<lbrakk>z \\<preceq> b; b \\<preceq> b'; b' \\<in> passed;\n            reachable z; reachable b\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x' x''.\n                                E\\<^sup>*\\<^sup>* b x' \\<and>\n                                x \\<preceq> x' \\<and>\n                                x' \\<preceq> x'' \\<and> x'' \\<in> passed;\n        y \\<preceq> b; b \\<preceq> b'; b' \\<in> passed; reachable y;\n        reachable b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x' x''.\n                            E\\<^sup>*\\<^sup>* b x' \\<and>\n                            x \\<preceq> x' \\<and>\n                            x' \\<preceq> x'' \\<and> x'' \\<in> passed", "case (step a a1 b b')"], ["proof (state)\nthis:\n  E a a1\n  E\\<^sup>*\\<^sup>* a1 x\n  \\<lbrakk>a1 \\<preceq> ?b1; ?b1 \\<preceq> ?b'1; ?b'1 \\<in> passed;\n   reachable a1; reachable ?b1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x' x''.\n                       E\\<^sup>*\\<^sup>* ?b1 x' \\<and>\n                       x \\<preceq> x' \\<and>\n                       x' \\<preceq> x'' \\<and> x'' \\<in> passed\n  a \\<preceq> b\n  b \\<preceq> b'\n  b' \\<in> passed\n  reachable a\n  reachable b\n\ngoal (1 subgoal):\n 1. \\<And>y z b b'.\n       \\<lbrakk>E y z; E\\<^sup>*\\<^sup>* z x;\n        \\<And>b b'.\n           \\<lbrakk>z \\<preceq> b; b \\<preceq> b'; b' \\<in> passed;\n            reachable z; reachable b\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x' x''.\n                                E\\<^sup>*\\<^sup>* b x' \\<and>\n                                x \\<preceq> x' \\<and>\n                                x' \\<preceq> x'' \\<and> x'' \\<in> passed;\n        y \\<preceq> b; b \\<preceq> b'; b' \\<in> passed; reachable y;\n        reachable b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x' x''.\n                            E\\<^sup>*\\<^sup>* b x' \\<and>\n                            x \\<preceq> x' \\<and>\n                            x' \\<preceq> x'' \\<and> x'' \\<in> passed", "from \\<open>E a a1\\<close> \\<open>a \\<preceq> b\\<close> \\<open>reachable a\\<close> \\<open>reachable b\\<close>"], ["proof (chain)\npicking this:\n  E a a1\n  a \\<preceq> b\n  reachable a\n  reachable b", "obtain b1 where\n        \"E b b1\" \"a1 \\<preceq> b1\""], ["proof (prove)\nusing this:\n  E a a1\n  a \\<preceq> b\n  reachable a\n  reachable b\n\ngoal (1 subgoal):\n 1. (\\<And>b1.\n        \\<lbrakk>E b b1; a1 \\<preceq> b1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using mono"], ["proof (prove)\nusing this:\n  E a a1\n  a \\<preceq> b\n  reachable a\n  reachable b\n  \\<lbrakk>?a \\<preceq> ?b; E ?a ?a'; reachable ?a; reachable ?b\\<rbrakk>\n  \\<Longrightarrow> \\<exists>b'. E ?b b' \\<and> ?a' \\<preceq> b'\n\ngoal (1 subgoal):\n 1. (\\<And>b1.\n        \\<lbrakk>E b b1; a1 \\<preceq> b1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  E b b1\n  a1 \\<preceq> b1\n\ngoal (1 subgoal):\n 1. \\<And>y z b b'.\n       \\<lbrakk>E y z; E\\<^sup>*\\<^sup>* z x;\n        \\<And>b b'.\n           \\<lbrakk>z \\<preceq> b; b \\<preceq> b'; b' \\<in> passed;\n            reachable z; reachable b\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x' x''.\n                                E\\<^sup>*\\<^sup>* b x' \\<and>\n                                x \\<preceq> x' \\<and>\n                                x' \\<preceq> x'' \\<and> x'' \\<in> passed;\n        y \\<preceq> b; b \\<preceq> b'; b' \\<in> passed; reachable y;\n        reachable b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x' x''.\n                            E\\<^sup>*\\<^sup>* b x' \\<and>\n                            x \\<preceq> x' \\<and>\n                            x' \\<preceq> x'' \\<and> x'' \\<in> passed", "then"], ["proof (chain)\npicking this:\n  E b b1\n  a1 \\<preceq> b1", "obtain b1' where \"E b' b1'\" \"b1 \\<preceq> b1'\""], ["proof (prove)\nusing this:\n  E b b1\n  a1 \\<preceq> b1\n\ngoal (1 subgoal):\n 1. (\\<And>b1'.\n        \\<lbrakk>E b' b1'; b1 \\<preceq> b1'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(4) mono step.prems"], ["proof (prove)\nusing this:\n  E b b1\n  a1 \\<preceq> b1\n  passed \\<subseteq> Collect reachable\n  \\<lbrakk>?a \\<preceq> ?b; E ?a ?a'; reachable ?a; reachable ?b\\<rbrakk>\n  \\<Longrightarrow> \\<exists>b'. E ?b b' \\<and> ?a' \\<preceq> b'\n  a \\<preceq> b\n  b \\<preceq> b'\n  b' \\<in> passed\n  reachable a\n  reachable b\n\ngoal (1 subgoal):\n 1. (\\<And>b1'.\n        \\<lbrakk>E b' b1'; b1 \\<preceq> b1'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  E b' b1'\n  b1 \\<preceq> b1'\n\ngoal (1 subgoal):\n 1. \\<And>y z b b'.\n       \\<lbrakk>E y z; E\\<^sup>*\\<^sup>* z x;\n        \\<And>b b'.\n           \\<lbrakk>z \\<preceq> b; b \\<preceq> b'; b' \\<in> passed;\n            reachable z; reachable b\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x' x''.\n                                E\\<^sup>*\\<^sup>* b x' \\<and>\n                                x \\<preceq> x' \\<and>\n                                x' \\<preceq> x'' \\<and> x'' \\<in> passed;\n        y \\<preceq> b; b \\<preceq> b'; b' \\<in> passed; reachable y;\n        reachable b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x' x''.\n                            E\\<^sup>*\\<^sup>* b x' \\<and>\n                            x \\<preceq> x' \\<and>\n                            x' \\<preceq> x'' \\<and> x'' \\<in> passed", "with \\<open>b' \\<in> passed\\<close> assms(1)"], ["proof (chain)\npicking this:\n  b' \\<in> passed\n  worklist_inv_frontier passed {#}\n  E b' b1'\n  b1 \\<preceq> b1'", "obtain b1'' where \"b1'' \\<in> passed\" \"b1' \\<preceq> b1''\""], ["proof (prove)\nusing this:\n  b' \\<in> passed\n  worklist_inv_frontier passed {#}\n  E b' b1'\n  b1 \\<preceq> b1'\n\ngoal (1 subgoal):\n 1. (\\<And>b1''.\n        \\<lbrakk>b1'' \\<in> passed; b1' \\<preceq> b1''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding worklist_inv_frontier_def"], ["proof (prove)\nusing this:\n  b' \\<in> passed\n  \\<forall>a\\<in>passed.\n     \\<forall>a'.\n        E a a' \\<longrightarrow>\n        Bex (passed \\<union> set_mset {#}) ((\\<preceq>) a')\n  E b' b1'\n  b1 \\<preceq> b1'\n\ngoal (1 subgoal):\n 1. (\\<And>b1''.\n        \\<lbrakk>b1'' \\<in> passed; b1' \\<preceq> b1''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  b1'' \\<in> passed\n  b1' \\<preceq> b1''\n\ngoal (1 subgoal):\n 1. \\<And>y z b b'.\n       \\<lbrakk>E y z; E\\<^sup>*\\<^sup>* z x;\n        \\<And>b b'.\n           \\<lbrakk>z \\<preceq> b; b \\<preceq> b'; b' \\<in> passed;\n            reachable z; reachable b\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x' x''.\n                                E\\<^sup>*\\<^sup>* b x' \\<and>\n                                x \\<preceq> x' \\<and>\n                                x' \\<preceq> x'' \\<and> x'' \\<in> passed;\n        y \\<preceq> b; b \\<preceq> b'; b' \\<in> passed; reachable y;\n        reachable b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x' x''.\n                            E\\<^sup>*\\<^sup>* b x' \\<and>\n                            x \\<preceq> x' \\<and>\n                            x' \\<preceq> x'' \\<and> x'' \\<in> passed", "with \\<open>b1 \\<preceq> _\\<close>"], ["proof (chain)\npicking this:\n  b1 \\<preceq> b1'\n  b1'' \\<in> passed\n  b1' \\<preceq> b1''", "have \"b1 \\<preceq> b1''\""], ["proof (prove)\nusing this:\n  b1 \\<preceq> b1'\n  b1'' \\<in> passed\n  b1' \\<preceq> b1''\n\ngoal (1 subgoal):\n 1. b1 \\<preceq> b1''", "using trans"], ["proof (prove)\nusing this:\n  b1 \\<preceq> b1'\n  b1'' \\<in> passed\n  b1' \\<preceq> b1''\n  \\<lbrakk>?a \\<preceq> ?b; ?b \\<preceq> ?c\\<rbrakk>\n  \\<Longrightarrow> ?a \\<preceq> ?c\n\ngoal (1 subgoal):\n 1. b1 \\<preceq> b1''", "by blast"], ["proof (state)\nthis:\n  b1 \\<preceq> b1''\n\ngoal (1 subgoal):\n 1. \\<And>y z b b'.\n       \\<lbrakk>E y z; E\\<^sup>*\\<^sup>* z x;\n        \\<And>b b'.\n           \\<lbrakk>z \\<preceq> b; b \\<preceq> b'; b' \\<in> passed;\n            reachable z; reachable b\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x' x''.\n                                E\\<^sup>*\\<^sup>* b x' \\<and>\n                                x \\<preceq> x' \\<and>\n                                x' \\<preceq> x'' \\<and> x'' \\<in> passed;\n        y \\<preceq> b; b \\<preceq> b'; b' \\<in> passed; reachable y;\n        reachable b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x' x''.\n                            E\\<^sup>*\\<^sup>* b x' \\<and>\n                            x \\<preceq> x' \\<and>\n                            x' \\<preceq> x'' \\<and> x'' \\<in> passed", "with step.IH[OF \\<open>a1 \\<preceq> b1\\<close> this \\<open>b1'' \\<in> passed\\<close>] \\<open>reachable a\\<close> \\<open>E a a1\\<close> \\<open>reachable b\\<close> \\<open>E b b1\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>reachable a1; reachable b1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x' x''.\n                       E\\<^sup>*\\<^sup>* b1 x' \\<and>\n                       x \\<preceq> x' \\<and>\n                       x' \\<preceq> x'' \\<and> x'' \\<in> passed\n  reachable a\n  E a a1\n  reachable b\n  E b b1\n  b1 \\<preceq> b1''", "obtain x' x'' where\n        \"E\\<^sup>*\\<^sup>* b1 x'\" \"x \\<preceq> x'\" \"x' \\<preceq> x''\" \"x'' \\<in> passed\""], ["proof (prove)\nusing this:\n  \\<lbrakk>reachable a1; reachable b1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x' x''.\n                       E\\<^sup>*\\<^sup>* b1 x' \\<and>\n                       x \\<preceq> x' \\<and>\n                       x' \\<preceq> x'' \\<and> x'' \\<in> passed\n  reachable a\n  E a a1\n  reachable b\n  E b b1\n  b1 \\<preceq> b1''\n\ngoal (1 subgoal):\n 1. (\\<And>x' x''.\n        \\<lbrakk>E\\<^sup>*\\<^sup>* b1 x'; x \\<preceq> x'; x' \\<preceq> x'';\n         x'' \\<in> passed\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto intro: step_reachable)"], ["proof (state)\nthis:\n  E\\<^sup>*\\<^sup>* b1 x'\n  x \\<preceq> x'\n  x' \\<preceq> x''\n  x'' \\<in> passed\n\ngoal (1 subgoal):\n 1. \\<And>y z b b'.\n       \\<lbrakk>E y z; E\\<^sup>*\\<^sup>* z x;\n        \\<And>b b'.\n           \\<lbrakk>z \\<preceq> b; b \\<preceq> b'; b' \\<in> passed;\n            reachable z; reachable b\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x' x''.\n                                E\\<^sup>*\\<^sup>* b x' \\<and>\n                                x \\<preceq> x' \\<and>\n                                x' \\<preceq> x'' \\<and> x'' \\<in> passed;\n        y \\<preceq> b; b \\<preceq> b'; b' \\<in> passed; reachable y;\n        reachable b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x' x''.\n                            E\\<^sup>*\\<^sup>* b x' \\<and>\n                            x \\<preceq> x' \\<and>\n                            x' \\<preceq> x'' \\<and> x'' \\<in> passed", "moreover"], ["proof (state)\nthis:\n  E\\<^sup>*\\<^sup>* b1 x'\n  x \\<preceq> x'\n  x' \\<preceq> x''\n  x'' \\<in> passed\n\ngoal (1 subgoal):\n 1. \\<And>y z b b'.\n       \\<lbrakk>E y z; E\\<^sup>*\\<^sup>* z x;\n        \\<And>b b'.\n           \\<lbrakk>z \\<preceq> b; b \\<preceq> b'; b' \\<in> passed;\n            reachable z; reachable b\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x' x''.\n                                E\\<^sup>*\\<^sup>* b x' \\<and>\n                                x \\<preceq> x' \\<and>\n                                x' \\<preceq> x'' \\<and> x'' \\<in> passed;\n        y \\<preceq> b; b \\<preceq> b'; b' \\<in> passed; reachable y;\n        reachable b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x' x''.\n                            E\\<^sup>*\\<^sup>* b x' \\<and>\n                            x \\<preceq> x' \\<and>\n                            x' \\<preceq> x'' \\<and> x'' \\<in> passed", "from \\<open>E b b1\\<close> \\<open>E\\<^sup>*\\<^sup>* b1 x'\\<close>"], ["proof (chain)\npicking this:\n  E b b1\n  E\\<^sup>*\\<^sup>* b1 x'", "have \"E\\<^sup>*\\<^sup>* b x'\""], ["proof (prove)\nusing this:\n  E b b1\n  E\\<^sup>*\\<^sup>* b1 x'\n\ngoal (1 subgoal):\n 1. E\\<^sup>*\\<^sup>* b x'", "by auto"], ["proof (state)\nthis:\n  E\\<^sup>*\\<^sup>* b x'\n\ngoal (1 subgoal):\n 1. \\<And>y z b b'.\n       \\<lbrakk>E y z; E\\<^sup>*\\<^sup>* z x;\n        \\<And>b b'.\n           \\<lbrakk>z \\<preceq> b; b \\<preceq> b'; b' \\<in> passed;\n            reachable z; reachable b\\<rbrakk>\n           \\<Longrightarrow> \\<exists>x' x''.\n                                E\\<^sup>*\\<^sup>* b x' \\<and>\n                                x \\<preceq> x' \\<and>\n                                x' \\<preceq> x'' \\<and> x'' \\<in> passed;\n        y \\<preceq> b; b \\<preceq> b'; b' \\<in> passed; reachable y;\n        reachable b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x' x''.\n                            E\\<^sup>*\\<^sup>* b x' \\<and>\n                            x \\<preceq> x' \\<and>\n                            x' \\<preceq> x'' \\<and> x'' \\<in> passed", "ultimately"], ["proof (chain)\npicking this:\n  E\\<^sup>*\\<^sup>* b1 x'\n  x \\<preceq> x'\n  x' \\<preceq> x''\n  x'' \\<in> passed\n  E\\<^sup>*\\<^sup>* b x'", "show ?case"], ["proof (prove)\nusing this:\n  E\\<^sup>*\\<^sup>* b1 x'\n  x \\<preceq> x'\n  x' \\<preceq> x''\n  x'' \\<in> passed\n  E\\<^sup>*\\<^sup>* b x'\n\ngoal (1 subgoal):\n 1. \\<exists>x' x''.\n       E\\<^sup>*\\<^sup>* b x' \\<and>\n       x \\<preceq> x' \\<and> x' \\<preceq> x'' \\<and> x'' \\<in> passed", "by auto"], ["proof (state)\nthis:\n  \\<exists>x' x''.\n     E\\<^sup>*\\<^sup>* b x' \\<and>\n     x \\<preceq> x' \\<and> x' \\<preceq> x'' \\<and> x'' \\<in> passed\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>E\\<^sup>*\\<^sup>* ?a1 x; ?a1 \\<preceq> ?b1; ?b1 \\<preceq> ?b'1;\n   ?b'1 \\<in> passed; reachable ?a1; reachable ?b1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x' x''.\n                       E\\<^sup>*\\<^sup>* ?b1 x' \\<and>\n                       x \\<preceq> x' \\<and>\n                       x' \\<preceq> x'' \\<and> x'' \\<in> passed\n\ngoal (1 subgoal):\n 1. \\<exists>x'\\<in>passed. x \\<preceq> x'", "from this[OF \\<open>E\\<^sup>*\\<^sup>* a\\<^sub>0 x\\<close> \\<open>a\\<^sub>0 \\<preceq> b\\<close> refl \\<open>b \\<in> _\\<close>] assms(4) \\<open>b \\<in> passed\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>reachable a\\<^sub>0; reachable b\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x' x''.\n                       E\\<^sup>*\\<^sup>* b x' \\<and>\n                       x \\<preceq> x' \\<and>\n                       x' \\<preceq> x'' \\<and> x'' \\<in> passed\n  passed \\<subseteq> Collect reachable\n  b \\<in> passed", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>reachable a\\<^sub>0; reachable b\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x' x''.\n                       E\\<^sup>*\\<^sup>* b x' \\<and>\n                       x \\<preceq> x' \\<and>\n                       x' \\<preceq> x'' \\<and> x'' \\<in> passed\n  passed \\<subseteq> Collect reachable\n  b \\<in> passed\n\ngoal (1 subgoal):\n 1. \\<exists>x'\\<in>passed. x \\<preceq> x'", "by (auto intro: trans)"], ["proof (state)\nthis:\n  \\<exists>x'\\<in>passed. x \\<preceq> x'\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem worklist_algo_correct:\n    \"worklist_algo \\<le> SPEC (\\<lambda> brk. brk \\<longleftrightarrow> F_reachable)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. worklist_algo \\<le> SPEC (\\<lambda>brk. brk = F_reachable)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. worklist_algo \\<le> SPEC (\\<lambda>brk. brk = F_reachable)", "note [simp] = size_Diff_submset pred_not_lt_is_zero"], ["proof (state)\nthis:\n  ?M \\<subseteq># ?M' \\<Longrightarrow> size (?M' - ?M) = size ?M' - size ?M\n  (\\<not> ?n - Suc 0 < ?n) = (?n = 0)\n\ngoal (1 subgoal):\n 1. worklist_algo \\<le> SPEC (\\<lambda>brk. brk = F_reachable)", "note [dest] = set_mset_mp"], ["proof (state)\nthis:\n  \\<lbrakk>set_mset ?m \\<subseteq> ?s; ?n < count ?m ?x\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> ?s\n\ngoal (1 subgoal):\n 1. worklist_algo \\<le> SPEC (\\<lambda>brk. brk = F_reachable)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. worklist_algo \\<le> SPEC (\\<lambda>brk. brk = F_reachable)", "unfolding worklist_algo_def add_succ_spec_def F_reachable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if F a\\<^sub>0 then RETURN True\n     else let passed = {}; wait = {#a\\<^sub>0#}\n          in WHILE\\<^sub>T\\<^bsup>worklist_inv\\<^esup>\n              (\\<lambda>(passed, wait, brk).\n                  \\<not> brk \\<and> wait \\<noteq> {#})\n              (\\<lambda>(passed, wait, brk).\n                  take_from_mset wait \\<bind>\n                  (\\<lambda>(a, wait).\n                      ASSERT (reachable a) \\<bind>\n                      (\\<lambda>_.\n                          if Bex passed ((\\<preceq>) a)\n                          then RETURN (passed, wait, brk)\n                          else SPEC\n                                (\\<lambda>(wait', brk).\n                                    if \\<exists>a'. E a a' \\<and> F a'\n                                    then brk\n                                    else set_mset wait' =\n   set_mset wait \\<union> {a'. E a a'} \\<and>\n   \\<not> brk) \\<bind>\n                               (\\<lambda>(wait, brk).\n                                   let passed = insert a passed\n                                   in RETURN (passed, wait, brk)))))\n              (passed, wait, False) \\<bind>\n             (\\<lambda>(passed, wait, y). RETURN y))\n    \\<le> SPEC (\\<lambda>brk. brk = (\\<exists>a. reachable a \\<and> F a))", "apply (refine_vcg wf_worklist_var)"], ["proof (prove)\ngoal (9 subgoals):\n 1. F a\\<^sub>0 \\<Longrightarrow>\n    True = (\\<exists>a. reachable a \\<and> F a)\n 2. \\<not> F a\\<^sub>0 \\<Longrightarrow>\n    worklist_inv ({}, {#a\\<^sub>0#}, False)\n 3. \\<And>s a b aa ba.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> aa \\<noteq> {#}\n 4. \\<And>s a b aa ba x ab bb.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> reachable ab\n 5. \\<And>s a b aa ba x ab bb.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; Bex a ((\\<preceq>) ab)\\<rbrakk>\n       \\<Longrightarrow> worklist_inv (a, bb, ba)\n 6. \\<And>s a b aa ba x ab bb.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; Bex a ((\\<preceq>) ab)\\<rbrakk>\n       \\<Longrightarrow> ((a, bb, ba), s) \\<in> worklist_var\n 7. \\<And>s a b aa ba x ab bb xa ac bc.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; \\<not> Bex a ((\\<preceq>) ab);\n        case xa of\n        (wait', brk) \\<Rightarrow>\n          if \\<exists>a'. E ab a' \\<and> F a' then brk\n          else set_mset wait' = set_mset bb \\<union> {a'. E ab a'} \\<and>\n               \\<not> brk;\n        xa = (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> worklist_inv (insert ab a, ac, bc)\n 8. \\<And>s a b aa ba x ab bb xa ac bc.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; \\<not> Bex a ((\\<preceq>) ab);\n        case xa of\n        (wait', brk) \\<Rightarrow>\n          if \\<exists>a'. E ab a' \\<and> F a' then brk\n          else set_mset wait' = set_mset bb \\<union> {a'. E ab a'} \\<and>\n               \\<not> brk;\n        xa = (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> ((insert ab a, ac, bc), s) \\<in> worklist_var\n 9. \\<And>s a b aa ba.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        \\<not> (case s of\n                (passed, wait, brk) \\<Rightarrow>\n                  \\<not> brk \\<and> wait \\<noteq> {#});\n        s = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> ba = (\\<exists>a. reachable a \\<and> F a)", "(* F a\\<^sub>0*)"], ["proof (prove)\ngoal (9 subgoals):\n 1. F a\\<^sub>0 \\<Longrightarrow>\n    True = (\\<exists>a. reachable a \\<and> F a)\n 2. \\<not> F a\\<^sub>0 \\<Longrightarrow>\n    worklist_inv ({}, {#a\\<^sub>0#}, False)\n 3. \\<And>s a b aa ba.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> aa \\<noteq> {#}\n 4. \\<And>s a b aa ba x ab bb.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> reachable ab\n 5. \\<And>s a b aa ba x ab bb.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; Bex a ((\\<preceq>) ab)\\<rbrakk>\n       \\<Longrightarrow> worklist_inv (a, bb, ba)\n 6. \\<And>s a b aa ba x ab bb.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; Bex a ((\\<preceq>) ab)\\<rbrakk>\n       \\<Longrightarrow> ((a, bb, ba), s) \\<in> worklist_var\n 7. \\<And>s a b aa ba x ab bb xa ac bc.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; \\<not> Bex a ((\\<preceq>) ab);\n        case xa of\n        (wait', brk) \\<Rightarrow>\n          if \\<exists>a'. E ab a' \\<and> F a' then brk\n          else set_mset wait' = set_mset bb \\<union> {a'. E ab a'} \\<and>\n               \\<not> brk;\n        xa = (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> worklist_inv (insert ab a, ac, bc)\n 8. \\<And>s a b aa ba x ab bb xa ac bc.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; \\<not> Bex a ((\\<preceq>) ab);\n        case xa of\n        (wait', brk) \\<Rightarrow>\n          if \\<exists>a'. E ab a' \\<and> F a' then brk\n          else set_mset wait' = set_mset bb \\<union> {a'. E ab a'} \\<and>\n               \\<not> brk;\n        xa = (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> ((insert ab a, ac, bc), s) \\<in> worklist_var\n 9. \\<And>s a b aa ba.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        \\<not> (case s of\n                (passed, wait, brk) \\<Rightarrow>\n                  \\<not> brk \\<and> wait \\<noteq> {#});\n        s = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> ba = (\\<exists>a. reachable a \\<and> F a)", "apply (auto; fail) []"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<not> F a\\<^sub>0 \\<Longrightarrow>\n    worklist_inv ({}, {#a\\<^sub>0#}, False)\n 2. \\<And>s a b aa ba.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> aa \\<noteq> {#}\n 3. \\<And>s a b aa ba x ab bb.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> reachable ab\n 4. \\<And>s a b aa ba x ab bb.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; Bex a ((\\<preceq>) ab)\\<rbrakk>\n       \\<Longrightarrow> worklist_inv (a, bb, ba)\n 5. \\<And>s a b aa ba x ab bb.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; Bex a ((\\<preceq>) ab)\\<rbrakk>\n       \\<Longrightarrow> ((a, bb, ba), s) \\<in> worklist_var\n 6. \\<And>s a b aa ba x ab bb xa ac bc.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; \\<not> Bex a ((\\<preceq>) ab);\n        case xa of\n        (wait', brk) \\<Rightarrow>\n          if \\<exists>a'. E ab a' \\<and> F a' then brk\n          else set_mset wait' = set_mset bb \\<union> {a'. E ab a'} \\<and>\n               \\<not> brk;\n        xa = (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> worklist_inv (insert ab a, ac, bc)\n 7. \\<And>s a b aa ba x ab bb xa ac bc.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; \\<not> Bex a ((\\<preceq>) ab);\n        case xa of\n        (wait', brk) \\<Rightarrow>\n          if \\<exists>a'. E ab a' \\<and> F a' then brk\n          else set_mset wait' = set_mset bb \\<union> {a'. E ab a'} \\<and>\n               \\<not> brk;\n        xa = (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> ((insert ab a, ac, bc), s) \\<in> worklist_var\n 8. \\<And>s a b aa ba.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        \\<not> (case s of\n                (passed, wait, brk) \\<Rightarrow>\n                  \\<not> brk \\<and> wait \\<noteq> {#});\n        s = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> ba = (\\<exists>a. reachable a \\<and> F a)", "(* Invar start*)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<not> F a\\<^sub>0 \\<Longrightarrow>\n    worklist_inv ({}, {#a\\<^sub>0#}, False)\n 2. \\<And>s a b aa ba.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> aa \\<noteq> {#}\n 3. \\<And>s a b aa ba x ab bb.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> reachable ab\n 4. \\<And>s a b aa ba x ab bb.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; Bex a ((\\<preceq>) ab)\\<rbrakk>\n       \\<Longrightarrow> worklist_inv (a, bb, ba)\n 5. \\<And>s a b aa ba x ab bb.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; Bex a ((\\<preceq>) ab)\\<rbrakk>\n       \\<Longrightarrow> ((a, bb, ba), s) \\<in> worklist_var\n 6. \\<And>s a b aa ba x ab bb xa ac bc.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; \\<not> Bex a ((\\<preceq>) ab);\n        case xa of\n        (wait', brk) \\<Rightarrow>\n          if \\<exists>a'. E ab a' \\<and> F a' then brk\n          else set_mset wait' = set_mset bb \\<union> {a'. E ab a'} \\<and>\n               \\<not> brk;\n        xa = (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> worklist_inv (insert ab a, ac, bc)\n 7. \\<And>s a b aa ba x ab bb xa ac bc.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; \\<not> Bex a ((\\<preceq>) ab);\n        case xa of\n        (wait', brk) \\<Rightarrow>\n          if \\<exists>a'. E ab a' \\<and> F a' then brk\n          else set_mset wait' = set_mset bb \\<union> {a'. E ab a'} \\<and>\n               \\<not> brk;\n        xa = (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> ((insert ab a, ac, bc), s) \\<in> worklist_var\n 8. \\<And>s a b aa ba.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        \\<not> (case s of\n                (passed, wait, brk) \\<Rightarrow>\n                  \\<not> brk \\<and> wait \\<noteq> {#});\n        s = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> ba = (\\<exists>a. reachable a \\<and> F a)", "apply (auto simp: worklist_inv_def worklist_inv_frontier_def start_subsumed_def; fail)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>s a b aa ba.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> aa \\<noteq> {#}\n 2. \\<And>s a b aa ba x ab bb.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> reachable ab\n 3. \\<And>s a b aa ba x ab bb.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; Bex a ((\\<preceq>) ab)\\<rbrakk>\n       \\<Longrightarrow> worklist_inv (a, bb, ba)\n 4. \\<And>s a b aa ba x ab bb.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; Bex a ((\\<preceq>) ab)\\<rbrakk>\n       \\<Longrightarrow> ((a, bb, ba), s) \\<in> worklist_var\n 5. \\<And>s a b aa ba x ab bb xa ac bc.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; \\<not> Bex a ((\\<preceq>) ab);\n        case xa of\n        (wait', brk) \\<Rightarrow>\n          if \\<exists>a'. E ab a' \\<and> F a' then brk\n          else set_mset wait' = set_mset bb \\<union> {a'. E ab a'} \\<and>\n               \\<not> brk;\n        xa = (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> worklist_inv (insert ab a, ac, bc)\n 6. \\<And>s a b aa ba x ab bb xa ac bc.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; \\<not> Bex a ((\\<preceq>) ab);\n        case xa of\n        (wait', brk) \\<Rightarrow>\n          if \\<exists>a'. E ab a' \\<and> F a' then brk\n          else set_mset wait' = set_mset bb \\<union> {a'. E ab a'} \\<and>\n               \\<not> brk;\n        xa = (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> ((insert ab a, ac, bc), s) \\<in> worklist_var\n 7. \\<And>s a b aa ba.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        \\<not> (case s of\n                (passed, wait, brk) \\<Rightarrow>\n                  \\<not> brk \\<and> wait \\<noteq> {#});\n        s = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> ba = (\\<exists>a. reachable a \\<and> F a)", "(* Precondition for take-from-set *)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>s a b aa ba.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> aa \\<noteq> {#}\n 2. \\<And>s a b aa ba x ab bb.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> reachable ab\n 3. \\<And>s a b aa ba x ab bb.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; Bex a ((\\<preceq>) ab)\\<rbrakk>\n       \\<Longrightarrow> worklist_inv (a, bb, ba)\n 4. \\<And>s a b aa ba x ab bb.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; Bex a ((\\<preceq>) ab)\\<rbrakk>\n       \\<Longrightarrow> ((a, bb, ba), s) \\<in> worklist_var\n 5. \\<And>s a b aa ba x ab bb xa ac bc.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; \\<not> Bex a ((\\<preceq>) ab);\n        case xa of\n        (wait', brk) \\<Rightarrow>\n          if \\<exists>a'. E ab a' \\<and> F a' then brk\n          else set_mset wait' = set_mset bb \\<union> {a'. E ab a'} \\<and>\n               \\<not> brk;\n        xa = (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> worklist_inv (insert ab a, ac, bc)\n 6. \\<And>s a b aa ba x ab bb xa ac bc.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; \\<not> Bex a ((\\<preceq>) ab);\n        case xa of\n        (wait', brk) \\<Rightarrow>\n          if \\<exists>a'. E ab a' \\<and> F a' then brk\n          else set_mset wait' = set_mset bb \\<union> {a'. E ab a'} \\<and>\n               \\<not> brk;\n        xa = (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> ((insert ab a, ac, bc), s) \\<in> worklist_var\n 7. \\<And>s a b aa ba.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        \\<not> (case s of\n                (passed, wait, brk) \\<Rightarrow>\n                  \\<not> brk \\<and> wait \\<noteq> {#});\n        s = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> ba = (\\<exists>a. reachable a \\<and> F a)", "apply (simp; fail)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>s a b aa ba x ab bb.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> reachable ab\n 2. \\<And>s a b aa ba x ab bb.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; Bex a ((\\<preceq>) ab)\\<rbrakk>\n       \\<Longrightarrow> worklist_inv (a, bb, ba)\n 3. \\<And>s a b aa ba x ab bb.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; Bex a ((\\<preceq>) ab)\\<rbrakk>\n       \\<Longrightarrow> ((a, bb, ba), s) \\<in> worklist_var\n 4. \\<And>s a b aa ba x ab bb xa ac bc.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; \\<not> Bex a ((\\<preceq>) ab);\n        case xa of\n        (wait', brk) \\<Rightarrow>\n          if \\<exists>a'. E ab a' \\<and> F a' then brk\n          else set_mset wait' = set_mset bb \\<union> {a'. E ab a'} \\<and>\n               \\<not> brk;\n        xa = (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> worklist_inv (insert ab a, ac, bc)\n 5. \\<And>s a b aa ba x ab bb xa ac bc.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; \\<not> Bex a ((\\<preceq>) ab);\n        case xa of\n        (wait', brk) \\<Rightarrow>\n          if \\<exists>a'. E ab a' \\<and> F a' then brk\n          else set_mset wait' = set_mset bb \\<union> {a'. E ab a'} \\<and>\n               \\<not> brk;\n        xa = (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> ((insert ab a, ac, bc), s) \\<in> worklist_var\n 6. \\<And>s a b aa ba.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        \\<not> (case s of\n                (passed, wait, brk) \\<Rightarrow>\n                  \\<not> brk \\<and> wait \\<noteq> {#});\n        s = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> ba = (\\<exists>a. reachable a \\<and> F a)", "(* State is subsumed by passed*)\n        (* Assertion *)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>s a b aa ba x ab bb.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> reachable ab\n 2. \\<And>s a b aa ba x ab bb.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; Bex a ((\\<preceq>) ab)\\<rbrakk>\n       \\<Longrightarrow> worklist_inv (a, bb, ba)\n 3. \\<And>s a b aa ba x ab bb.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; Bex a ((\\<preceq>) ab)\\<rbrakk>\n       \\<Longrightarrow> ((a, bb, ba), s) \\<in> worklist_var\n 4. \\<And>s a b aa ba x ab bb xa ac bc.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; \\<not> Bex a ((\\<preceq>) ab);\n        case xa of\n        (wait', brk) \\<Rightarrow>\n          if \\<exists>a'. E ab a' \\<and> F a' then brk\n          else set_mset wait' = set_mset bb \\<union> {a'. E ab a'} \\<and>\n               \\<not> brk;\n        xa = (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> worklist_inv (insert ab a, ac, bc)\n 5. \\<And>s a b aa ba x ab bb xa ac bc.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; \\<not> Bex a ((\\<preceq>) ab);\n        case xa of\n        (wait', brk) \\<Rightarrow>\n          if \\<exists>a'. E ab a' \\<and> F a' then brk\n          else set_mset wait' = set_mset bb \\<union> {a'. E ab a'} \\<and>\n               \\<not> brk;\n        xa = (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> ((insert ab a, ac, bc), s) \\<in> worklist_var\n 6. \\<And>s a b aa ba.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        \\<not> (case s of\n                (passed, wait, brk) \\<Rightarrow>\n                  \\<not> brk \\<and> wait \\<noteq> {#});\n        s = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> ba = (\\<exists>a. reachable a \\<and> F a)", "apply (auto simp: worklist_inv_def; fail)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s a b aa ba x ab bb.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; Bex a ((\\<preceq>) ab)\\<rbrakk>\n       \\<Longrightarrow> worklist_inv (a, bb, ba)\n 2. \\<And>s a b aa ba x ab bb.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; Bex a ((\\<preceq>) ab)\\<rbrakk>\n       \\<Longrightarrow> ((a, bb, ba), s) \\<in> worklist_var\n 3. \\<And>s a b aa ba x ab bb xa ac bc.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; \\<not> Bex a ((\\<preceq>) ab);\n        case xa of\n        (wait', brk) \\<Rightarrow>\n          if \\<exists>a'. E ab a' \\<and> F a' then brk\n          else set_mset wait' = set_mset bb \\<union> {a'. E ab a'} \\<and>\n               \\<not> brk;\n        xa = (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> worklist_inv (insert ab a, ac, bc)\n 4. \\<And>s a b aa ba x ab bb xa ac bc.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; \\<not> Bex a ((\\<preceq>) ab);\n        case xa of\n        (wait', brk) \\<Rightarrow>\n          if \\<exists>a'. E ab a' \\<and> F a' then brk\n          else set_mset wait' = set_mset bb \\<union> {a'. E ab a'} \\<and>\n               \\<not> brk;\n        xa = (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> ((insert ab a, ac, bc), s) \\<in> worklist_var\n 5. \\<And>s a b aa ba.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        \\<not> (case s of\n                (passed, wait, brk) \\<Rightarrow>\n                  \\<not> brk \\<and> wait \\<noteq> {#});\n        s = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> ba = (\\<exists>a. reachable a \\<and> F a)", "(*Invariant*)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s a b aa ba x ab bb.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; Bex a ((\\<preceq>) ab)\\<rbrakk>\n       \\<Longrightarrow> worklist_inv (a, bb, ba)\n 2. \\<And>s a b aa ba x ab bb.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; Bex a ((\\<preceq>) ab)\\<rbrakk>\n       \\<Longrightarrow> ((a, bb, ba), s) \\<in> worklist_var\n 3. \\<And>s a b aa ba x ab bb xa ac bc.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; \\<not> Bex a ((\\<preceq>) ab);\n        case xa of\n        (wait', brk) \\<Rightarrow>\n          if \\<exists>a'. E ab a' \\<and> F a' then brk\n          else set_mset wait' = set_mset bb \\<union> {a'. E ab a'} \\<and>\n               \\<not> brk;\n        xa = (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> worklist_inv (insert ab a, ac, bc)\n 4. \\<And>s a b aa ba x ab bb xa ac bc.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; \\<not> Bex a ((\\<preceq>) ab);\n        case xa of\n        (wait', brk) \\<Rightarrow>\n          if \\<exists>a'. E ab a' \\<and> F a' then brk\n          else set_mset wait' = set_mset bb \\<union> {a'. E ab a'} \\<and>\n               \\<not> brk;\n        xa = (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> ((insert ab a, ac, bc), s) \\<in> worklist_var\n 5. \\<And>s a b aa ba.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        \\<not> (case s of\n                (passed, wait, brk) \\<Rightarrow>\n                  \\<not> brk \\<and> wait \\<noteq> {#});\n        s = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> ba = (\\<exists>a. reachable a \\<and> F a)", "apply (auto simp: worklist_inv_def aux2 aux5 \n              dest: in_diffD\n              split: if_split_asm; fail) []"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s a b aa ba x ab bb.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; Bex a ((\\<preceq>) ab)\\<rbrakk>\n       \\<Longrightarrow> ((a, bb, ba), s) \\<in> worklist_var\n 2. \\<And>s a b aa ba x ab bb xa ac bc.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; \\<not> Bex a ((\\<preceq>) ab);\n        case xa of\n        (wait', brk) \\<Rightarrow>\n          if \\<exists>a'. E ab a' \\<and> F a' then brk\n          else set_mset wait' = set_mset bb \\<union> {a'. E ab a'} \\<and>\n               \\<not> brk;\n        xa = (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> worklist_inv (insert ab a, ac, bc)\n 3. \\<And>s a b aa ba x ab bb xa ac bc.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; \\<not> Bex a ((\\<preceq>) ab);\n        case xa of\n        (wait', brk) \\<Rightarrow>\n          if \\<exists>a'. E ab a' \\<and> F a' then brk\n          else set_mset wait' = set_mset bb \\<union> {a'. E ab a'} \\<and>\n               \\<not> brk;\n        xa = (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> ((insert ab a, ac, bc), s) \\<in> worklist_var\n 4. \\<And>s a b aa ba.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        \\<not> (case s of\n                (passed, wait, brk) \\<Rightarrow>\n                  \\<not> brk \\<and> wait \\<noteq> {#});\n        s = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> ba = (\\<exists>a. reachable a \\<and> F a)", "(*Variant*)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s a b aa ba x ab bb.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; Bex a ((\\<preceq>) ab)\\<rbrakk>\n       \\<Longrightarrow> ((a, bb, ba), s) \\<in> worklist_var\n 2. \\<And>s a b aa ba x ab bb xa ac bc.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; \\<not> Bex a ((\\<preceq>) ab);\n        case xa of\n        (wait', brk) \\<Rightarrow>\n          if \\<exists>a'. E ab a' \\<and> F a' then brk\n          else set_mset wait' = set_mset bb \\<union> {a'. E ab a'} \\<and>\n               \\<not> brk;\n        xa = (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> worklist_inv (insert ab a, ac, bc)\n 3. \\<And>s a b aa ba x ab bb xa ac bc.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; \\<not> Bex a ((\\<preceq>) ab);\n        case xa of\n        (wait', brk) \\<Rightarrow>\n          if \\<exists>a'. E ab a' \\<and> F a' then brk\n          else set_mset wait' = set_mset bb \\<union> {a'. E ab a'} \\<and>\n               \\<not> brk;\n        xa = (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> ((insert ab a, ac, bc), s) \\<in> worklist_var\n 4. \\<And>s a b aa ba.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        \\<not> (case s of\n                (passed, wait, brk) \\<Rightarrow>\n                  \\<not> brk \\<and> wait \\<noteq> {#});\n        s = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> ba = (\\<exists>a. reachable a \\<and> F a)", "apply (auto simp: worklist_inv_def worklist_var_def intro: finite_subset[OF _ finite_reachable]; fail)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s a b aa ba x ab bb xa ac bc.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; \\<not> Bex a ((\\<preceq>) ab);\n        case xa of\n        (wait', brk) \\<Rightarrow>\n          if \\<exists>a'. E ab a' \\<and> F a' then brk\n          else set_mset wait' = set_mset bb \\<union> {a'. E ab a'} \\<and>\n               \\<not> brk;\n        xa = (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> worklist_inv (insert ab a, ac, bc)\n 2. \\<And>s a b aa ba x ab bb xa ac bc.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; \\<not> Bex a ((\\<preceq>) ab);\n        case xa of\n        (wait', brk) \\<Rightarrow>\n          if \\<exists>a'. E ab a' \\<and> F a' then brk\n          else set_mset wait' = set_mset bb \\<union> {a'. E ab a'} \\<and>\n               \\<not> brk;\n        xa = (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> ((insert ab a, ac, bc), s) \\<in> worklist_var\n 3. \\<And>s a b aa ba.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        \\<not> (case s of\n                (passed, wait, brk) \\<Rightarrow>\n                  \\<not> brk \\<and> wait \\<noteq> {#});\n        s = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> ba = (\\<exists>a. reachable a \\<and> F a)", "(* Insert successors to wait *)  \n        (*Invariant*)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s a b aa ba x ab bb xa ac bc.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; \\<not> Bex a ((\\<preceq>) ab);\n        case xa of\n        (wait', brk) \\<Rightarrow>\n          if \\<exists>a'. E ab a' \\<and> F a' then brk\n          else set_mset wait' = set_mset bb \\<union> {a'. E ab a'} \\<and>\n               \\<not> brk;\n        xa = (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> worklist_inv (insert ab a, ac, bc)\n 2. \\<And>s a b aa ba x ab bb xa ac bc.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; \\<not> Bex a ((\\<preceq>) ab);\n        case xa of\n        (wait', brk) \\<Rightarrow>\n          if \\<exists>a'. E ab a' \\<and> F a' then brk\n          else set_mset wait' = set_mset bb \\<union> {a'. E ab a'} \\<and>\n               \\<not> brk;\n        xa = (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> ((insert ab a, ac, bc), s) \\<in> worklist_var\n 3. \\<And>s a b aa ba.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        \\<not> (case s of\n                (passed, wait, brk) \\<Rightarrow>\n                  \\<not> brk \\<and> wait \\<noteq> {#});\n        s = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> ba = (\\<exists>a. reachable a \\<and> F a)", "apply (clarsimp split: if_split_asm)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>ab aaa baa aba aca bca a'.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv (ab, aaa, False);\n        aba \\<in># aaa; reachable aba;\n        \\<forall>x\\<in>ab. \\<not> aba \\<preceq> x; \\<not> baa;\n        aaa \\<noteq> {#}; E aba a'; F a'; bca\\<rbrakk>\n       \\<Longrightarrow> worklist_inv (insert aba ab, aca, True)\n 2. \\<And>ab aaa baa aba aca bca.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv (ab, aaa, False);\n        aba \\<in># aaa; reachable aba;\n        \\<forall>x\\<in>ab. \\<not> aba \\<preceq> x;\n        \\<forall>a'. E aba a' \\<longrightarrow> \\<not> F a'; \\<not> baa;\n        aaa \\<noteq> {#};\n        set_mset aca = set_mset (aaa - {#aba#}) \\<union> Collect (E aba);\n        \\<not> bca\\<rbrakk>\n       \\<Longrightarrow> worklist_inv (insert aba ab, aca, False)\n 3. \\<And>s a b aa ba x ab bb xa ac bc.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; \\<not> Bex a ((\\<preceq>) ab);\n        case xa of\n        (wait', brk) \\<Rightarrow>\n          if \\<exists>a'. E ab a' \\<and> F a' then brk\n          else set_mset wait' = set_mset bb \\<union> {a'. E ab a'} \\<and>\n               \\<not> brk;\n        xa = (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> ((insert ab a, ac, bc), s) \\<in> worklist_var\n 4. \\<And>s a b aa ba.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        \\<not> (case s of\n                (passed, wait, brk) \\<Rightarrow>\n                  \\<not> brk \\<and> wait \\<noteq> {#});\n        s = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> ba = (\\<exists>a. reachable a \\<and> F a)", "(* Split on F in successors *)\n          (* Found final state *)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>ab aaa baa aba aca bca a'.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv (ab, aaa, False);\n        aba \\<in># aaa; reachable aba;\n        \\<forall>x\\<in>ab. \\<not> aba \\<preceq> x; \\<not> baa;\n        aaa \\<noteq> {#}; E aba a'; F a'; bca\\<rbrakk>\n       \\<Longrightarrow> worklist_inv (insert aba ab, aca, True)\n 2. \\<And>ab aaa baa aba aca bca.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv (ab, aaa, False);\n        aba \\<in># aaa; reachable aba;\n        \\<forall>x\\<in>ab. \\<not> aba \\<preceq> x;\n        \\<forall>a'. E aba a' \\<longrightarrow> \\<not> F a'; \\<not> baa;\n        aaa \\<noteq> {#};\n        set_mset aca = set_mset (aaa - {#aba#}) \\<union> Collect (E aba);\n        \\<not> bca\\<rbrakk>\n       \\<Longrightarrow> worklist_inv (insert aba ab, aca, False)\n 3. \\<And>s a b aa ba x ab bb xa ac bc.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; \\<not> Bex a ((\\<preceq>) ab);\n        case xa of\n        (wait', brk) \\<Rightarrow>\n          if \\<exists>a'. E ab a' \\<and> F a' then brk\n          else set_mset wait' = set_mset bb \\<union> {a'. E ab a'} \\<and>\n               \\<not> brk;\n        xa = (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> ((insert ab a, ac, bc), s) \\<in> worklist_var\n 4. \\<And>s a b aa ba.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        \\<not> (case s of\n                (passed, wait, brk) \\<Rightarrow>\n                  \\<not> brk \\<and> wait \\<noteq> {#});\n        s = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> ba = (\\<exists>a. reachable a \\<and> F a)", "apply (clarsimp simp: worklist_inv_def; blast intro: step_reachable; fail)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ab aaa baa aba aca bca.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv (ab, aaa, False);\n        aba \\<in># aaa; reachable aba;\n        \\<forall>x\\<in>ab. \\<not> aba \\<preceq> x;\n        \\<forall>a'. E aba a' \\<longrightarrow> \\<not> F a'; \\<not> baa;\n        aaa \\<noteq> {#};\n        set_mset aca = set_mset (aaa - {#aba#}) \\<union> Collect (E aba);\n        \\<not> bca\\<rbrakk>\n       \\<Longrightarrow> worklist_inv (insert aba ab, aca, False)\n 2. \\<And>s a b aa ba x ab bb xa ac bc.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; \\<not> Bex a ((\\<preceq>) ab);\n        case xa of\n        (wait', brk) \\<Rightarrow>\n          if \\<exists>a'. E ab a' \\<and> F a' then brk\n          else set_mset wait' = set_mset bb \\<union> {a'. E ab a'} \\<and>\n               \\<not> brk;\n        xa = (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> ((insert ab a, ac, bc), s) \\<in> worklist_var\n 3. \\<And>s a b aa ba.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        \\<not> (case s of\n                (passed, wait, brk) \\<Rightarrow>\n                  \\<not> brk \\<and> wait \\<noteq> {#});\n        s = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> ba = (\\<exists>a. reachable a \\<and> F a)", "(* No final state *)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ab aaa baa aba aca bca.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv (ab, aaa, False);\n        aba \\<in># aaa; reachable aba;\n        \\<forall>x\\<in>ab. \\<not> aba \\<preceq> x;\n        \\<forall>a'. E aba a' \\<longrightarrow> \\<not> F a'; \\<not> baa;\n        aaa \\<noteq> {#};\n        set_mset aca = set_mset (aaa - {#aba#}) \\<union> Collect (E aba);\n        \\<not> bca\\<rbrakk>\n       \\<Longrightarrow> worklist_inv (insert aba ab, aca, False)\n 2. \\<And>s a b aa ba x ab bb xa ac bc.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; \\<not> Bex a ((\\<preceq>) ab);\n        case xa of\n        (wait', brk) \\<Rightarrow>\n          if \\<exists>a'. E ab a' \\<and> F a' then brk\n          else set_mset wait' = set_mset bb \\<union> {a'. E ab a'} \\<and>\n               \\<not> brk;\n        xa = (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> ((insert ab a, ac, bc), s) \\<in> worklist_var\n 3. \\<And>s a b aa ba.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        \\<not> (case s of\n                (passed, wait, brk) \\<Rightarrow>\n                  \\<not> brk \\<and> wait \\<noteq> {#});\n        s = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> ba = (\\<exists>a. reachable a \\<and> F a)", "apply (auto \n        simp: worklist_inv_def step_reachable aux3 aux6 finitely_branching\n        dest: in_diffD; fail)[]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s a b aa ba x ab bb xa ac bc.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; \\<not> Bex a ((\\<preceq>) ab);\n        case xa of\n        (wait', brk) \\<Rightarrow>\n          if \\<exists>a'. E ab a' \\<and> F a' then brk\n          else set_mset wait' = set_mset bb \\<union> {a'. E ab a'} \\<and>\n               \\<not> brk;\n        xa = (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> ((insert ab a, ac, bc), s) \\<in> worklist_var\n 2. \\<And>s a b aa ba.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        \\<not> (case s of\n                (passed, wait, brk) \\<Rightarrow>\n                  \\<not> brk \\<and> wait \\<noteq> {#});\n        s = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> ba = (\\<exists>a. reachable a \\<and> F a)", "(*Variant*)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s a b aa ba x ab bb xa ac bc.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        case s of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        s = (a, b); b = (aa, ba);\n        case x of (x, s') \\<Rightarrow> x \\<in># aa \\<and> s' = aa - {#x#};\n        x = (ab, bb); reachable ab; \\<not> Bex a ((\\<preceq>) ab);\n        case xa of\n        (wait', brk) \\<Rightarrow>\n          if \\<exists>a'. E ab a' \\<and> F a' then brk\n          else set_mset wait' = set_mset bb \\<union> {a'. E ab a'} \\<and>\n               \\<not> brk;\n        xa = (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> ((insert ab a, ac, bc), s) \\<in> worklist_var\n 2. \\<And>s a b aa ba.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        \\<not> (case s of\n                (passed, wait, brk) \\<Rightarrow>\n                  \\<not> brk \\<and> wait \\<noteq> {#});\n        s = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> ba = (\\<exists>a. reachable a \\<and> F a)", "apply (auto simp: worklist_inv_def aux1; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s a b aa ba.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        \\<not> (case s of\n                (passed, wait, brk) \\<Rightarrow>\n                  \\<not> brk \\<and> wait \\<noteq> {#});\n        s = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> ba = (\\<exists>a. reachable a \\<and> F a)", "(* I \\<and> \\<not>b \\<Longrightarrow> post *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s a b aa ba.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        \\<not> (case s of\n                (passed, wait, brk) \\<Rightarrow>\n                  \\<not> brk \\<and> wait \\<noteq> {#});\n        s = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> ba = (\\<exists>a. reachable a \\<and> F a)", "using F_mono"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<preceq> ?a'; F ?a\\<rbrakk> \\<Longrightarrow> F ?a'\n\ngoal (1 subgoal):\n 1. \\<And>s a b aa ba.\n       \\<lbrakk>\\<not> F a\\<^sub>0; worklist_inv s;\n        \\<not> (case s of\n                (passed, wait, brk) \\<Rightarrow>\n                  \\<not> brk \\<and> wait \\<noteq> {#});\n        s = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> ba = (\\<exists>a. reachable a \\<and> F a)", "apply (fastforce simp: worklist_inv_def dest!: aux4)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  worklist_algo \\<le> SPEC (\\<lambda>brk. brk = F_reachable)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas [refine_vcg] = worklist_algo_correct[THEN order_trans]"], ["", "end \\<comment> \\<open>Context\\<close>"], ["", "end \\<comment> \\<open>Search Space\\<close>"], ["", "subsection \\<open>Towards an Implementation\\<close>"], ["", "locale Worklist1_Defs = Search_Space_Defs +\n  fixes succs :: \"'a \\<Rightarrow> 'a list\""], ["", "locale Worklist1 = Worklist1_Defs + Search_Space +\n  assumes succs_correct: \"reachable a \\<Longrightarrow> set (succs a) = Collect (E a)\"\nbegin"], ["", "definition \"add_succ1 wait a \\<equiv> nfoldli (succs a) (\\<lambda>(_,brk). \\<not>brk) (\\<lambda>a (wait,brk). if F a then RETURN (wait,True) else RETURN (wait + {#a#},False)) (wait, False)\""], ["", "lemma add_succ1_ref[refine]: \"\\<lbrakk>(wait,wait')\\<in>Id; (a,a')\\<in>b_rel Id reachable\\<rbrakk> \\<Longrightarrow> add_succ1 wait a \\<le> \\<Down>(Id \\<times>\\<^sub>r bool_rel) (add_succ_spec wait' a')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(wait, wait') \\<in> Id;\n     (a, a') \\<in> b_rel Id reachable\\<rbrakk>\n    \\<Longrightarrow> add_succ1 wait a\n                      \\<le> \\<Down> (Id \\<times>\\<^sub>r bool_rel)\n                             (add_succ_spec wait' a')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wait = wait'; a = a' \\<and> reachable a'\\<rbrakk>\n    \\<Longrightarrow> add_succ1 wait' a' \\<le> add_succ_spec wait' a'", "unfolding add_succ_spec_def add_succ1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wait = wait'; a = a' \\<and> reachable a'\\<rbrakk>\n    \\<Longrightarrow> nfoldli (succs a') (\\<lambda>(uu_, brk). \\<not> brk)\n                       (\\<lambda>a (wait, brk).\n                           if F a then RETURN (wait, True)\n                           else RETURN (wait + {#a#}, False))\n                       (wait', False)\n                      \\<le> SPEC\n                             (\\<lambda>(wait'a, brk).\n                                 if \\<exists>a'a. E a' a'a \\<and> F a'a\n                                 then brk\n                                 else set_mset wait'a =\nset_mset wait' \\<union> {a'a. E a' a'a} \\<and>\n\\<not> brk)", "apply (refine_vcg nfoldli_rule[where I = \"\\<lambda>l1 _ (wait',brk). if brk then \\<exists>a'. E a a' \\<and> F a' else set_mset wait' = set_mset wait \\<union> set l1 \\<and> set l1 \\<inter> Collect F = {}\"])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>wait = wait'; a = a' \\<and> reachable a';\n        (wait', False) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> if x2 then \\<exists>a'. E a a' \\<and> F a'\n                         else set_mset x1 =\n                              set_mset wait \\<union> set [] \\<and>\n                              set [] \\<inter> Collect F = {}\n 2. \\<And>x l1 l2 \\<sigma> aa b x1 x2.\n       \\<lbrakk>wait = wait'; a = a' \\<and> reachable a';\n        succs a' = l1 @ x # l2;\n        case \\<sigma> of\n        (wait', brk) \\<Rightarrow>\n          if brk then \\<exists>a'. E a a' \\<and> F a'\n          else set_mset wait' = set_mset wait \\<union> set l1 \\<and>\n               set l1 \\<inter> Collect F = {};\n        case \\<sigma> of (uu_, brk) \\<Rightarrow> \\<not> brk;\n        \\<sigma> = (aa, b); F x; (aa, True) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> if x2 then \\<exists>a'. E a a' \\<and> F a'\n                         else set_mset x1 =\n                              set_mset wait \\<union> set (l1 @ [x]) \\<and>\n                              set (l1 @ [x]) \\<inter> Collect F = {}\n 3. \\<And>x l1 l2 \\<sigma> aa b x1 x2.\n       \\<lbrakk>wait = wait'; a = a' \\<and> reachable a';\n        succs a' = l1 @ x # l2;\n        case \\<sigma> of\n        (wait', brk) \\<Rightarrow>\n          if brk then \\<exists>a'. E a a' \\<and> F a'\n          else set_mset wait' = set_mset wait \\<union> set l1 \\<and>\n               set l1 \\<inter> Collect F = {};\n        case \\<sigma> of (uu_, brk) \\<Rightarrow> \\<not> brk;\n        \\<sigma> = (aa, b); \\<not> F x;\n        (aa + {#x#}, False) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> if x2 then \\<exists>a'. E a a' \\<and> F a'\n                         else set_mset x1 =\n                              set_mset wait \\<union> set (l1 @ [x]) \\<and>\n                              set (l1 @ [x]) \\<inter> Collect F = {}\n 4. \\<And>l1 l2 \\<sigma> x1 x2.\n       \\<lbrakk>wait = wait'; a = a' \\<and> reachable a';\n        succs a' = l1 @ l2;\n        case \\<sigma> of\n        (wait', brk) \\<Rightarrow>\n          if brk then \\<exists>a'. E a a' \\<and> F a'\n          else set_mset wait' = set_mset wait \\<union> set l1 \\<and>\n               set l1 \\<inter> Collect F = {};\n        \\<not> (case \\<sigma> of (uu_, brk) \\<Rightarrow> \\<not> brk);\n        \\<sigma> = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> if \\<exists>a'a. E a' a'a \\<and> F a'a then x2\n                         else set_mset x1 =\n                              set_mset wait' \\<union> {a'a. E a' a'a} \\<and>\n                              \\<not> x2\n 5. \\<And>\\<sigma> x1 x2.\n       \\<lbrakk>wait = wait'; a = a' \\<and> reachable a';\n        case \\<sigma> of\n        (wait', brk) \\<Rightarrow>\n          if brk then \\<exists>a'. E a a' \\<and> F a'\n          else set_mset wait' = set_mset wait \\<union> set (succs a') \\<and>\n               set (succs a') \\<inter> Collect F = {};\n        case \\<sigma> of (uu_, brk) \\<Rightarrow> \\<not> brk;\n        \\<sigma> = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> if \\<exists>a'a. E a' a'a \\<and> F a'a then x2\n                         else set_mset x1 =\n                              set_mset wait' \\<union> {a'a. E a' a'a} \\<and>\n                              \\<not> x2", "apply (auto; fail)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x l1 l2 \\<sigma> aa b x1 x2.\n       \\<lbrakk>wait = wait'; a = a' \\<and> reachable a';\n        succs a' = l1 @ x # l2;\n        case \\<sigma> of\n        (wait', brk) \\<Rightarrow>\n          if brk then \\<exists>a'. E a a' \\<and> F a'\n          else set_mset wait' = set_mset wait \\<union> set l1 \\<and>\n               set l1 \\<inter> Collect F = {};\n        case \\<sigma> of (uu_, brk) \\<Rightarrow> \\<not> brk;\n        \\<sigma> = (aa, b); F x; (aa, True) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> if x2 then \\<exists>a'. E a a' \\<and> F a'\n                         else set_mset x1 =\n                              set_mset wait \\<union> set (l1 @ [x]) \\<and>\n                              set (l1 @ [x]) \\<inter> Collect F = {}\n 2. \\<And>x l1 l2 \\<sigma> aa b x1 x2.\n       \\<lbrakk>wait = wait'; a = a' \\<and> reachable a';\n        succs a' = l1 @ x # l2;\n        case \\<sigma> of\n        (wait', brk) \\<Rightarrow>\n          if brk then \\<exists>a'. E a a' \\<and> F a'\n          else set_mset wait' = set_mset wait \\<union> set l1 \\<and>\n               set l1 \\<inter> Collect F = {};\n        case \\<sigma> of (uu_, brk) \\<Rightarrow> \\<not> brk;\n        \\<sigma> = (aa, b); \\<not> F x;\n        (aa + {#x#}, False) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> if x2 then \\<exists>a'. E a a' \\<and> F a'\n                         else set_mset x1 =\n                              set_mset wait \\<union> set (l1 @ [x]) \\<and>\n                              set (l1 @ [x]) \\<inter> Collect F = {}\n 3. \\<And>l1 l2 \\<sigma> x1 x2.\n       \\<lbrakk>wait = wait'; a = a' \\<and> reachable a';\n        succs a' = l1 @ l2;\n        case \\<sigma> of\n        (wait', brk) \\<Rightarrow>\n          if brk then \\<exists>a'. E a a' \\<and> F a'\n          else set_mset wait' = set_mset wait \\<union> set l1 \\<and>\n               set l1 \\<inter> Collect F = {};\n        \\<not> (case \\<sigma> of (uu_, brk) \\<Rightarrow> \\<not> brk);\n        \\<sigma> = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> if \\<exists>a'a. E a' a'a \\<and> F a'a then x2\n                         else set_mset x1 =\n                              set_mset wait' \\<union> {a'a. E a' a'a} \\<and>\n                              \\<not> x2\n 4. \\<And>\\<sigma> x1 x2.\n       \\<lbrakk>wait = wait'; a = a' \\<and> reachable a';\n        case \\<sigma> of\n        (wait', brk) \\<Rightarrow>\n          if brk then \\<exists>a'. E a a' \\<and> F a'\n          else set_mset wait' = set_mset wait \\<union> set (succs a') \\<and>\n               set (succs a') \\<inter> Collect F = {};\n        case \\<sigma> of (uu_, brk) \\<Rightarrow> \\<not> brk;\n        \\<sigma> = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> if \\<exists>a'a. E a' a'a \\<and> F a'a then x2\n                         else set_mset x1 =\n                              set_mset wait' \\<union> {a'a. E a' a'a} \\<and>\n                              \\<not> x2", "using succs_correct[of a]"], ["proof (prove)\nusing this:\n  reachable a \\<Longrightarrow> set (succs a) = Collect (E a)\n\ngoal (4 subgoals):\n 1. \\<And>x l1 l2 \\<sigma> aa b x1 x2.\n       \\<lbrakk>wait = wait'; a = a' \\<and> reachable a';\n        succs a' = l1 @ x # l2;\n        case \\<sigma> of\n        (wait', brk) \\<Rightarrow>\n          if brk then \\<exists>a'. E a a' \\<and> F a'\n          else set_mset wait' = set_mset wait \\<union> set l1 \\<and>\n               set l1 \\<inter> Collect F = {};\n        case \\<sigma> of (uu_, brk) \\<Rightarrow> \\<not> brk;\n        \\<sigma> = (aa, b); F x; (aa, True) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> if x2 then \\<exists>a'. E a a' \\<and> F a'\n                         else set_mset x1 =\n                              set_mset wait \\<union> set (l1 @ [x]) \\<and>\n                              set (l1 @ [x]) \\<inter> Collect F = {}\n 2. \\<And>x l1 l2 \\<sigma> aa b x1 x2.\n       \\<lbrakk>wait = wait'; a = a' \\<and> reachable a';\n        succs a' = l1 @ x # l2;\n        case \\<sigma> of\n        (wait', brk) \\<Rightarrow>\n          if brk then \\<exists>a'. E a a' \\<and> F a'\n          else set_mset wait' = set_mset wait \\<union> set l1 \\<and>\n               set l1 \\<inter> Collect F = {};\n        case \\<sigma> of (uu_, brk) \\<Rightarrow> \\<not> brk;\n        \\<sigma> = (aa, b); \\<not> F x;\n        (aa + {#x#}, False) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> if x2 then \\<exists>a'. E a a' \\<and> F a'\n                         else set_mset x1 =\n                              set_mset wait \\<union> set (l1 @ [x]) \\<and>\n                              set (l1 @ [x]) \\<inter> Collect F = {}\n 3. \\<And>l1 l2 \\<sigma> x1 x2.\n       \\<lbrakk>wait = wait'; a = a' \\<and> reachable a';\n        succs a' = l1 @ l2;\n        case \\<sigma> of\n        (wait', brk) \\<Rightarrow>\n          if brk then \\<exists>a'. E a a' \\<and> F a'\n          else set_mset wait' = set_mset wait \\<union> set l1 \\<and>\n               set l1 \\<inter> Collect F = {};\n        \\<not> (case \\<sigma> of (uu_, brk) \\<Rightarrow> \\<not> brk);\n        \\<sigma> = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> if \\<exists>a'a. E a' a'a \\<and> F a'a then x2\n                         else set_mset x1 =\n                              set_mset wait' \\<union> {a'a. E a' a'a} \\<and>\n                              \\<not> x2\n 4. \\<And>\\<sigma> x1 x2.\n       \\<lbrakk>wait = wait'; a = a' \\<and> reachable a';\n        case \\<sigma> of\n        (wait', brk) \\<Rightarrow>\n          if brk then \\<exists>a'. E a a' \\<and> F a'\n          else set_mset wait' = set_mset wait \\<union> set (succs a') \\<and>\n               set (succs a') \\<inter> Collect F = {};\n        case \\<sigma> of (uu_, brk) \\<Rightarrow> \\<not> brk;\n        \\<sigma> = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> if \\<exists>a'a. E a' a'a \\<and> F a'a then x2\n                         else set_mset x1 =\n                              set_mset wait' \\<union> {a'a. E a' a'a} \\<and>\n                              \\<not> x2", "apply (auto; fail)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x l1 l2 \\<sigma> aa b x1 x2.\n       \\<lbrakk>wait = wait'; a = a' \\<and> reachable a';\n        succs a' = l1 @ x # l2;\n        case \\<sigma> of\n        (wait', brk) \\<Rightarrow>\n          if brk then \\<exists>a'. E a a' \\<and> F a'\n          else set_mset wait' = set_mset wait \\<union> set l1 \\<and>\n               set l1 \\<inter> Collect F = {};\n        case \\<sigma> of (uu_, brk) \\<Rightarrow> \\<not> brk;\n        \\<sigma> = (aa, b); \\<not> F x;\n        (aa + {#x#}, False) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> if x2 then \\<exists>a'. E a a' \\<and> F a'\n                         else set_mset x1 =\n                              set_mset wait \\<union> set (l1 @ [x]) \\<and>\n                              set (l1 @ [x]) \\<inter> Collect F = {}\n 2. \\<And>l1 l2 \\<sigma> x1 x2.\n       \\<lbrakk>wait = wait'; a = a' \\<and> reachable a';\n        succs a' = l1 @ l2;\n        case \\<sigma> of\n        (wait', brk) \\<Rightarrow>\n          if brk then \\<exists>a'. E a a' \\<and> F a'\n          else set_mset wait' = set_mset wait \\<union> set l1 \\<and>\n               set l1 \\<inter> Collect F = {};\n        \\<not> (case \\<sigma> of (uu_, brk) \\<Rightarrow> \\<not> brk);\n        \\<sigma> = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> if \\<exists>a'a. E a' a'a \\<and> F a'a then x2\n                         else set_mset x1 =\n                              set_mset wait' \\<union> {a'a. E a' a'a} \\<and>\n                              \\<not> x2\n 3. \\<And>\\<sigma> x1 x2.\n       \\<lbrakk>wait = wait'; a = a' \\<and> reachable a';\n        case \\<sigma> of\n        (wait', brk) \\<Rightarrow>\n          if brk then \\<exists>a'. E a a' \\<and> F a'\n          else set_mset wait' = set_mset wait \\<union> set (succs a') \\<and>\n               set (succs a') \\<inter> Collect F = {};\n        case \\<sigma> of (uu_, brk) \\<Rightarrow> \\<not> brk;\n        \\<sigma> = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> if \\<exists>a'a. E a' a'a \\<and> F a'a then x2\n                         else set_mset x1 =\n                              set_mset wait' \\<union> {a'a. E a' a'a} \\<and>\n                              \\<not> x2", "using succs_correct[of a]"], ["proof (prove)\nusing this:\n  reachable a \\<Longrightarrow> set (succs a) = Collect (E a)\n\ngoal (3 subgoals):\n 1. \\<And>x l1 l2 \\<sigma> aa b x1 x2.\n       \\<lbrakk>wait = wait'; a = a' \\<and> reachable a';\n        succs a' = l1 @ x # l2;\n        case \\<sigma> of\n        (wait', brk) \\<Rightarrow>\n          if brk then \\<exists>a'. E a a' \\<and> F a'\n          else set_mset wait' = set_mset wait \\<union> set l1 \\<and>\n               set l1 \\<inter> Collect F = {};\n        case \\<sigma> of (uu_, brk) \\<Rightarrow> \\<not> brk;\n        \\<sigma> = (aa, b); \\<not> F x;\n        (aa + {#x#}, False) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> if x2 then \\<exists>a'. E a a' \\<and> F a'\n                         else set_mset x1 =\n                              set_mset wait \\<union> set (l1 @ [x]) \\<and>\n                              set (l1 @ [x]) \\<inter> Collect F = {}\n 2. \\<And>l1 l2 \\<sigma> x1 x2.\n       \\<lbrakk>wait = wait'; a = a' \\<and> reachable a';\n        succs a' = l1 @ l2;\n        case \\<sigma> of\n        (wait', brk) \\<Rightarrow>\n          if brk then \\<exists>a'. E a a' \\<and> F a'\n          else set_mset wait' = set_mset wait \\<union> set l1 \\<and>\n               set l1 \\<inter> Collect F = {};\n        \\<not> (case \\<sigma> of (uu_, brk) \\<Rightarrow> \\<not> brk);\n        \\<sigma> = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> if \\<exists>a'a. E a' a'a \\<and> F a'a then x2\n                         else set_mset x1 =\n                              set_mset wait' \\<union> {a'a. E a' a'a} \\<and>\n                              \\<not> x2\n 3. \\<And>\\<sigma> x1 x2.\n       \\<lbrakk>wait = wait'; a = a' \\<and> reachable a';\n        case \\<sigma> of\n        (wait', brk) \\<Rightarrow>\n          if brk then \\<exists>a'. E a a' \\<and> F a'\n          else set_mset wait' = set_mset wait \\<union> set (succs a') \\<and>\n               set (succs a') \\<inter> Collect F = {};\n        case \\<sigma> of (uu_, brk) \\<Rightarrow> \\<not> brk;\n        \\<sigma> = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> if \\<exists>a'a. E a' a'a \\<and> F a'a then x2\n                         else set_mset x1 =\n                              set_mset wait' \\<union> {a'a. E a' a'a} \\<and>\n                              \\<not> x2", "apply (auto; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l1 l2 \\<sigma> x1 x2.\n       \\<lbrakk>wait = wait'; a = a' \\<and> reachable a';\n        succs a' = l1 @ l2;\n        case \\<sigma> of\n        (wait', brk) \\<Rightarrow>\n          if brk then \\<exists>a'. E a a' \\<and> F a'\n          else set_mset wait' = set_mset wait \\<union> set l1 \\<and>\n               set l1 \\<inter> Collect F = {};\n        \\<not> (case \\<sigma> of (uu_, brk) \\<Rightarrow> \\<not> brk);\n        \\<sigma> = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> if \\<exists>a'a. E a' a'a \\<and> F a'a then x2\n                         else set_mset x1 =\n                              set_mset wait' \\<union> {a'a. E a' a'a} \\<and>\n                              \\<not> x2\n 2. \\<And>\\<sigma> x1 x2.\n       \\<lbrakk>wait = wait'; a = a' \\<and> reachable a';\n        case \\<sigma> of\n        (wait', brk) \\<Rightarrow>\n          if brk then \\<exists>a'. E a a' \\<and> F a'\n          else set_mset wait' = set_mset wait \\<union> set (succs a') \\<and>\n               set (succs a') \\<inter> Collect F = {};\n        case \\<sigma> of (uu_, brk) \\<Rightarrow> \\<not> brk;\n        \\<sigma> = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> if \\<exists>a'a. E a' a'a \\<and> F a'a then x2\n                         else set_mset x1 =\n                              set_mset wait' \\<union> {a'a. E a' a'a} \\<and>\n                              \\<not> x2", "apply (auto; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> x1 x2.\n       \\<lbrakk>wait = wait'; a = a' \\<and> reachable a';\n        case \\<sigma> of\n        (wait', brk) \\<Rightarrow>\n          if brk then \\<exists>a'. E a a' \\<and> F a'\n          else set_mset wait' = set_mset wait \\<union> set (succs a') \\<and>\n               set (succs a') \\<inter> Collect F = {};\n        case \\<sigma> of (uu_, brk) \\<Rightarrow> \\<not> brk;\n        \\<sigma> = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> if \\<exists>a'a. E a' a'a \\<and> F a'a then x2\n                         else set_mset x1 =\n                              set_mset wait' \\<union> {a'a. E a' a'a} \\<and>\n                              \\<not> x2", "using succs_correct[of a]"], ["proof (prove)\nusing this:\n  reachable a \\<Longrightarrow> set (succs a) = Collect (E a)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> x1 x2.\n       \\<lbrakk>wait = wait'; a = a' \\<and> reachable a';\n        case \\<sigma> of\n        (wait', brk) \\<Rightarrow>\n          if brk then \\<exists>a'. E a a' \\<and> F a'\n          else set_mset wait' = set_mset wait \\<union> set (succs a') \\<and>\n               set (succs a') \\<inter> Collect F = {};\n        case \\<sigma> of (uu_, brk) \\<Rightarrow> \\<not> brk;\n        \\<sigma> = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> if \\<exists>a'a. E a' a'a \\<and> F a'a then x2\n                         else set_mset x1 =\n                              set_mset wait' \\<union> {a'a. E a' a'a} \\<and>\n                              \\<not> x2", "apply (auto; fail)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition worklist_algo1 where\n    \"worklist_algo1 = do\n      { \n        if F a\\<^sub>0 then RETURN True\n        else do {\n          let passed = {};\n          let wait = {#a\\<^sub>0#};\n          (passed, wait, brk) \\<leftarrow> WHILEIT worklist_inv (\\<lambda> (passed, wait, brk). \\<not> brk \\<and> wait \\<noteq> {#})\n            (\\<lambda> (passed, wait, brk). do\n              { \n                (a, wait) \\<leftarrow> take_from_mset wait;\n                if (\\<exists> a' \\<in> passed. a \\<preceq> a') then RETURN (passed, wait, brk) else\n                do\n                  {\n                    (wait,brk) \\<leftarrow> add_succ1 wait a;\n                    let passed = insert a passed;\n                    RETURN (passed, wait, brk)\n                  }\n              }\n            )\n            (passed, wait, False);\n            RETURN brk\n        }\n      }\n    \""], ["", "lemma worklist_algo1_ref[refine]: \"worklist_algo1 \\<le> \\<Down>Id worklist_algo\""], ["proof (prove)\ngoal (1 subgoal):\n 1. worklist_algo1 \\<le> \\<Down> bool_rel worklist_algo", "unfolding worklist_algo1_def worklist_algo_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if F a\\<^sub>0 then RETURN True\n     else let passed = {}; wait = {#a\\<^sub>0#}\n          in WHILE\\<^sub>T\\<^bsup>worklist_inv\\<^esup>\n              (\\<lambda>(passed, wait, brk).\n                  \\<not> brk \\<and> wait \\<noteq> {#})\n              (\\<lambda>(passed, wait, brk).\n                  take_from_mset wait \\<bind>\n                  (\\<lambda>(a, wait).\n                      if Bex passed ((\\<preceq>) a)\n                      then RETURN (passed, wait, brk)\n                      else add_succ1 wait a \\<bind>\n                           (\\<lambda>(wait, brk).\n                               let passed = insert a passed\n                               in RETURN (passed, wait, brk))))\n              (passed, wait, False) \\<bind>\n             (\\<lambda>(passed, wait, y). RETURN y))\n    \\<le> \\<Down> bool_rel\n           (if F a\\<^sub>0 then RETURN True\n            else let passed = {}; wait = {#a\\<^sub>0#}\n                 in WHILE\\<^sub>T\\<^bsup>worklist_inv\\<^esup>\n                     (\\<lambda>(passed, wait, brk).\n                         \\<not> brk \\<and> wait \\<noteq> {#})\n                     (\\<lambda>(passed, wait, brk).\n                         take_from_mset wait \\<bind>\n                         (\\<lambda>(a, wait).\n                             ASSERT (reachable a) \\<bind>\n                             (\\<lambda>_.\n                                 if Bex passed ((\\<preceq>) a)\n                                 then RETURN (passed, wait, brk)\n                                 else add_succ_spec wait a \\<bind>\n(\\<lambda>(wait, brk).\n    let passed = insert a passed in RETURN (passed, wait, brk)))))\n                     (passed, wait, False) \\<bind>\n                    (\\<lambda>(passed, wait, y). RETURN y))", "apply (refine_rcg)"], ["proof (prove)\ngoal (11 subgoals):\n 1. F a\\<^sub>0 = F a\\<^sub>0\n 2. \\<lbrakk>\\<not> F a\\<^sub>0; \\<not> F a\\<^sub>0;\n     worklist_inv ({}, {#a\\<^sub>0#}, False)\\<rbrakk>\n    \\<Longrightarrow> (({}, {#a\\<^sub>0#}, False), {}, {#a\\<^sub>0#}, False)\n                      \\<in> ?R'4\n 3. \\<And>x x'.\n       \\<lbrakk>\\<not> F a\\<^sub>0; \\<not> F a\\<^sub>0; (x, x') \\<in> ?R'4;\n        worklist_inv x'\\<rbrakk>\n       \\<Longrightarrow> worklist_inv x\n 4. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>\\<not> F a\\<^sub>0; \\<not> F a\\<^sub>0; (x, x') \\<in> ?R'4;\n        worklist_inv x; worklist_inv x'; x2 = (x1a, x2a); x = (x1, x2);\n        x2b = (x1c, x2c); x' = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> x2a \\<and> x1a \\<noteq> {#}) =\n                         (\\<not> x2c \\<and> x1c \\<noteq> {#})\n 5. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>\\<not> F a\\<^sub>0; \\<not> F a\\<^sub>0; (x, x') \\<in> ?R'4;\n        case x of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        case x' of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        worklist_inv x; worklist_inv x'; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> take_from_mset x1c\n                         \\<le> \\<Down>\n                                (?R'110 x x' x1 x2 x1a x2a x1b x2b x1c x2c)\n                                (take_from_mset x1a)\n 6. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a x1d x2d x1e x2e.\n       \\<lbrakk>\\<not> F a\\<^sub>0; \\<not> F a\\<^sub>0; (x, x') \\<in> ?R'4;\n        case x of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        case x' of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        worklist_inv x; worklist_inv x'; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b);\n        (xa, x'a) \\<in> ?R'110 x x' x1 x2 x1a x2a x1b x2b x1c x2c;\n        x'a = (x1d, x2d); xa = (x1e, x2e); reachable x1d\\<rbrakk>\n       \\<Longrightarrow> Bex x1b ((\\<preceq>) x1e) =\n                         Bex x1 ((\\<preceq>) x1d)\n 7. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a x1d x2d x1e x2e.\n       \\<lbrakk>\\<not> F a\\<^sub>0; \\<not> F a\\<^sub>0; (x, x') \\<in> ?R'4;\n        case x of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        case x' of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        worklist_inv x; worklist_inv x'; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b);\n        (xa, x'a) \\<in> ?R'110 x x' x1 x2 x1a x2a x1b x2b x1c x2c;\n        x'a = (x1d, x2d); xa = (x1e, x2e); reachable x1d;\n        Bex x1b ((\\<preceq>) x1e); Bex x1 ((\\<preceq>) x1d)\\<rbrakk>\n       \\<Longrightarrow> ((x1b, x2e, x2c), x1, x2d, x2a) \\<in> ?R'4\n 8. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a x1d x2d x1e x2e.\n       \\<lbrakk>\\<not> F a\\<^sub>0; \\<not> F a\\<^sub>0; (x, x') \\<in> ?R'4;\n        case x of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        case x' of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        worklist_inv x; worklist_inv x'; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b);\n        (xa, x'a) \\<in> ?R'110 x x' x1 x2 x1a x2a x1b x2b x1c x2c;\n        x'a = (x1d, x2d); xa = (x1e, x2e); reachable x1d;\n        \\<not> Bex x1b ((\\<preceq>) x1e);\n        \\<not> Bex x1 ((\\<preceq>) x1d)\\<rbrakk>\n       \\<Longrightarrow> (x2e, x2d) \\<in> Id\n 9. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a x1d x2d x1e x2e.\n       \\<lbrakk>\\<not> F a\\<^sub>0; \\<not> F a\\<^sub>0; (x, x') \\<in> ?R'4;\n        case x of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        case x' of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        worklist_inv x; worklist_inv x'; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b);\n        (xa, x'a) \\<in> ?R'110 x x' x1 x2 x1a x2a x1b x2b x1c x2c;\n        x'a = (x1d, x2d); xa = (x1e, x2e); reachable x1d;\n        \\<not> Bex x1b ((\\<preceq>) x1e);\n        \\<not> Bex x1 ((\\<preceq>) x1d)\\<rbrakk>\n       \\<Longrightarrow> (x1e, x1d) \\<in> b_rel Id reachable\n 10. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a x1d x2d x1e x2e xb x'b\n        x1f x2f x1g x2g.\n        \\<lbrakk>\\<not> F a\\<^sub>0; \\<not> F a\\<^sub>0; (x, x') \\<in> ?R'4;\n         case x of\n         (passed, wait, brk) \\<Rightarrow>\n           \\<not> brk \\<and> wait \\<noteq> {#};\n         case x' of\n         (passed, wait, brk) \\<Rightarrow>\n           \\<not> brk \\<and> wait \\<noteq> {#};\n         worklist_inv x; worklist_inv x'; x2 = (x1a, x2a); x' = (x1, x2);\n         x2b = (x1c, x2c); x = (x1b, x2b);\n         (xa, x'a) \\<in> ?R'110 x x' x1 x2 x1a x2a x1b x2b x1c x2c;\n         x'a = (x1d, x2d); xa = (x1e, x2e); reachable x1d;\n         \\<not> Bex x1b ((\\<preceq>) x1e); \\<not> Bex x1 ((\\<preceq>) x1d);\n         (xb, x'b) \\<in> Id \\<times>\\<^sub>r bool_rel; x'b = (x1f, x2f);\n         xb = (x1g, x2g)\\<rbrakk>\n        \\<Longrightarrow> ((insert x1e x1b, x1g, x2g), insert x1d x1, x1f,\n                           x2f)\n                          \\<in> ?R'4\nA total of 11 subgoals...", "apply refine_dref_type"], ["proof (prove)\ngoal (11 subgoals):\n 1. F a\\<^sub>0 = F a\\<^sub>0\n 2. \\<lbrakk>\\<not> F a\\<^sub>0; \\<not> F a\\<^sub>0;\n     worklist_inv ({}, {#a\\<^sub>0#}, False)\\<rbrakk>\n    \\<Longrightarrow> (({}, {#a\\<^sub>0#}, False), {}, {#a\\<^sub>0#}, False)\n                      \\<in> \\<langle>Id\\<rangle>set_rel \\<times>\\<^sub>r\n                            Id \\<times>\\<^sub>r bool_rel\n 3. \\<And>x x'.\n       \\<lbrakk>\\<not> F a\\<^sub>0; \\<not> F a\\<^sub>0;\n        (x, x')\n        \\<in> \\<langle>Id\\<rangle>set_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r bool_rel;\n        worklist_inv x'\\<rbrakk>\n       \\<Longrightarrow> worklist_inv x\n 4. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>\\<not> F a\\<^sub>0; \\<not> F a\\<^sub>0;\n        (x, x')\n        \\<in> \\<langle>Id\\<rangle>set_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r bool_rel;\n        worklist_inv x; worklist_inv x'; x2 = (x1a, x2a); x = (x1, x2);\n        x2b = (x1c, x2c); x' = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> x2a \\<and> x1a \\<noteq> {#}) =\n                         (\\<not> x2c \\<and> x1c \\<noteq> {#})\n 5. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>\\<not> F a\\<^sub>0; \\<not> F a\\<^sub>0;\n        (x, x')\n        \\<in> \\<langle>Id\\<rangle>set_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r bool_rel;\n        case x of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        case x' of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        worklist_inv x; worklist_inv x'; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> take_from_mset x1c\n                         \\<le> \\<Down> (Id \\<times>\\<^sub>r Id)\n                                (take_from_mset x1a)\n 6. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a x1d x2d x1e x2e.\n       \\<lbrakk>\\<not> F a\\<^sub>0; \\<not> F a\\<^sub>0;\n        (x, x')\n        \\<in> \\<langle>Id\\<rangle>set_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r bool_rel;\n        case x of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        case x' of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        worklist_inv x; worklist_inv x'; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b);\n        (xa, x'a) \\<in> Id \\<times>\\<^sub>r Id; x'a = (x1d, x2d);\n        xa = (x1e, x2e); reachable x1d\\<rbrakk>\n       \\<Longrightarrow> Bex x1b ((\\<preceq>) x1e) =\n                         Bex x1 ((\\<preceq>) x1d)\n 7. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a x1d x2d x1e x2e.\n       \\<lbrakk>\\<not> F a\\<^sub>0; \\<not> F a\\<^sub>0;\n        (x, x')\n        \\<in> \\<langle>Id\\<rangle>set_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r bool_rel;\n        case x of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        case x' of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        worklist_inv x; worklist_inv x'; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b);\n        (xa, x'a) \\<in> Id \\<times>\\<^sub>r Id; x'a = (x1d, x2d);\n        xa = (x1e, x2e); reachable x1d; Bex x1b ((\\<preceq>) x1e);\n        Bex x1 ((\\<preceq>) x1d)\\<rbrakk>\n       \\<Longrightarrow> ((x1b, x2e, x2c), x1, x2d, x2a)\n                         \\<in> \\<langle>Id\\<rangle>set_rel \\<times>\\<^sub>r\n                               Id \\<times>\\<^sub>r bool_rel\n 8. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a x1d x2d x1e x2e.\n       \\<lbrakk>\\<not> F a\\<^sub>0; \\<not> F a\\<^sub>0;\n        (x, x')\n        \\<in> \\<langle>Id\\<rangle>set_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r bool_rel;\n        case x of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        case x' of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        worklist_inv x; worklist_inv x'; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b);\n        (xa, x'a) \\<in> Id \\<times>\\<^sub>r Id; x'a = (x1d, x2d);\n        xa = (x1e, x2e); reachable x1d; \\<not> Bex x1b ((\\<preceq>) x1e);\n        \\<not> Bex x1 ((\\<preceq>) x1d)\\<rbrakk>\n       \\<Longrightarrow> (x2e, x2d) \\<in> Id\n 9. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a x1d x2d x1e x2e.\n       \\<lbrakk>\\<not> F a\\<^sub>0; \\<not> F a\\<^sub>0;\n        (x, x')\n        \\<in> \\<langle>Id\\<rangle>set_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r bool_rel;\n        case x of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        case x' of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        worklist_inv x; worklist_inv x'; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b);\n        (xa, x'a) \\<in> Id \\<times>\\<^sub>r Id; x'a = (x1d, x2d);\n        xa = (x1e, x2e); reachable x1d; \\<not> Bex x1b ((\\<preceq>) x1e);\n        \\<not> Bex x1 ((\\<preceq>) x1d)\\<rbrakk>\n       \\<Longrightarrow> (x1e, x1d) \\<in> b_rel Id reachable\n 10. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a x1d x2d x1e x2e xb x'b\n        x1f x2f x1g x2g.\n        \\<lbrakk>\\<not> F a\\<^sub>0; \\<not> F a\\<^sub>0;\n         (x, x')\n         \\<in> \\<langle>Id\\<rangle>set_rel \\<times>\\<^sub>r\n               Id \\<times>\\<^sub>r bool_rel;\n         case x of\n         (passed, wait, brk) \\<Rightarrow>\n           \\<not> brk \\<and> wait \\<noteq> {#};\n         case x' of\n         (passed, wait, brk) \\<Rightarrow>\n           \\<not> brk \\<and> wait \\<noteq> {#};\n         worklist_inv x; worklist_inv x'; x2 = (x1a, x2a); x' = (x1, x2);\n         x2b = (x1c, x2c); x = (x1b, x2b);\n         (xa, x'a) \\<in> Id \\<times>\\<^sub>r Id; x'a = (x1d, x2d);\n         xa = (x1e, x2e); reachable x1d; \\<not> Bex x1b ((\\<preceq>) x1e);\n         \\<not> Bex x1 ((\\<preceq>) x1d);\n         (xb, x'b) \\<in> Id \\<times>\\<^sub>r bool_rel; x'b = (x1f, x2f);\n         xb = (x1g, x2g)\\<rbrakk>\n        \\<Longrightarrow> ((insert x1e x1b, x1g, x2g), insert x1d x1, x1f,\n                           x2f)\n                          \\<in> \\<langle>Id\\<rangle>set_rel \\<times>\\<^sub>r\n                                Id \\<times>\\<^sub>r bool_rel\nA total of 11 subgoals...", "unfolding worklist_inv_def"], ["proof (prove)\ngoal (11 subgoals):\n 1. F a\\<^sub>0 = F a\\<^sub>0\n 2. \\<lbrakk>\\<not> F a\\<^sub>0; \\<not> F a\\<^sub>0;\n     case ({}, {#a\\<^sub>0#}, False) of\n     (passed, wait, brk) \\<Rightarrow>\n       passed \\<subseteq> Collect reachable \\<and>\n       (brk \\<longrightarrow> (\\<exists>f. reachable f \\<and> F f)) \\<and>\n       (\\<not> brk \\<longrightarrow>\n        worklist_inv_frontier passed wait \\<and>\n        (\\<forall>a\\<in>passed \\<union> set_mset wait. \\<not> F a) \\<and>\n        start_subsumed passed wait \\<and>\n        set_mset wait \\<subseteq> Collect reachable)\\<rbrakk>\n    \\<Longrightarrow> (({}, {#a\\<^sub>0#}, False), {}, {#a\\<^sub>0#}, False)\n                      \\<in> \\<langle>Id\\<rangle>set_rel \\<times>\\<^sub>r\n                            Id \\<times>\\<^sub>r bool_rel\n 3. \\<And>x x'.\n       \\<lbrakk>\\<not> F a\\<^sub>0; \\<not> F a\\<^sub>0;\n        (x, x')\n        \\<in> \\<langle>Id\\<rangle>set_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r bool_rel;\n        case x' of\n        (passed, wait, brk) \\<Rightarrow>\n          passed \\<subseteq> Collect reachable \\<and>\n          (brk \\<longrightarrow>\n           (\\<exists>f. reachable f \\<and> F f)) \\<and>\n          (\\<not> brk \\<longrightarrow>\n           worklist_inv_frontier passed wait \\<and>\n           (\\<forall>a\\<in>passed \\<union> set_mset wait. \\<not> F a) \\<and>\n           start_subsumed passed wait \\<and>\n           set_mset wait \\<subseteq> Collect reachable)\\<rbrakk>\n       \\<Longrightarrow> case x of\n                         (passed, wait, brk) \\<Rightarrow>\n                           passed \\<subseteq> Collect reachable \\<and>\n                           (brk \\<longrightarrow>\n                            (\\<exists>f. reachable f \\<and> F f)) \\<and>\n                           (\\<not> brk \\<longrightarrow>\n                            worklist_inv_frontier passed wait \\<and>\n                            (\\<forall>a\\<in>passed \\<union> set_mset wait.\n                                \\<not> F a) \\<and>\n                            start_subsumed passed wait \\<and>\n                            set_mset wait \\<subseteq> Collect reachable)\n 4. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>\\<not> F a\\<^sub>0; \\<not> F a\\<^sub>0;\n        (x, x')\n        \\<in> \\<langle>Id\\<rangle>set_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r bool_rel;\n        case x of\n        (passed, wait, brk) \\<Rightarrow>\n          passed \\<subseteq> Collect reachable \\<and>\n          (brk \\<longrightarrow>\n           (\\<exists>f. reachable f \\<and> F f)) \\<and>\n          (\\<not> brk \\<longrightarrow>\n           worklist_inv_frontier passed wait \\<and>\n           (\\<forall>a\\<in>passed \\<union> set_mset wait. \\<not> F a) \\<and>\n           start_subsumed passed wait \\<and>\n           set_mset wait \\<subseteq> Collect reachable);\n        case x' of\n        (passed, wait, brk) \\<Rightarrow>\n          passed \\<subseteq> Collect reachable \\<and>\n          (brk \\<longrightarrow>\n           (\\<exists>f. reachable f \\<and> F f)) \\<and>\n          (\\<not> brk \\<longrightarrow>\n           worklist_inv_frontier passed wait \\<and>\n           (\\<forall>a\\<in>passed \\<union> set_mset wait. \\<not> F a) \\<and>\n           start_subsumed passed wait \\<and>\n           set_mset wait \\<subseteq> Collect reachable);\n        x2 = (x1a, x2a); x = (x1, x2); x2b = (x1c, x2c);\n        x' = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> x2a \\<and> x1a \\<noteq> {#}) =\n                         (\\<not> x2c \\<and> x1c \\<noteq> {#})\n 5. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>\\<not> F a\\<^sub>0; \\<not> F a\\<^sub>0;\n        (x, x')\n        \\<in> \\<langle>Id\\<rangle>set_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r bool_rel;\n        case x of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        case x' of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        case x of\n        (passed, wait, brk) \\<Rightarrow>\n          passed \\<subseteq> Collect reachable \\<and>\n          (brk \\<longrightarrow>\n           (\\<exists>f. reachable f \\<and> F f)) \\<and>\n          (\\<not> brk \\<longrightarrow>\n           worklist_inv_frontier passed wait \\<and>\n           (\\<forall>a\\<in>passed \\<union> set_mset wait. \\<not> F a) \\<and>\n           start_subsumed passed wait \\<and>\n           set_mset wait \\<subseteq> Collect reachable);\n        case x' of\n        (passed, wait, brk) \\<Rightarrow>\n          passed \\<subseteq> Collect reachable \\<and>\n          (brk \\<longrightarrow>\n           (\\<exists>f. reachable f \\<and> F f)) \\<and>\n          (\\<not> brk \\<longrightarrow>\n           worklist_inv_frontier passed wait \\<and>\n           (\\<forall>a\\<in>passed \\<union> set_mset wait. \\<not> F a) \\<and>\n           start_subsumed passed wait \\<and>\n           set_mset wait \\<subseteq> Collect reachable);\n        x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c);\n        x = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> take_from_mset x1c\n                         \\<le> \\<Down> (Id \\<times>\\<^sub>r Id)\n                                (take_from_mset x1a)\n 6. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a x1d x2d x1e x2e.\n       \\<lbrakk>\\<not> F a\\<^sub>0; \\<not> F a\\<^sub>0;\n        (x, x')\n        \\<in> \\<langle>Id\\<rangle>set_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r bool_rel;\n        case x of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        case x' of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        case x of\n        (passed, wait, brk) \\<Rightarrow>\n          passed \\<subseteq> Collect reachable \\<and>\n          (brk \\<longrightarrow>\n           (\\<exists>f. reachable f \\<and> F f)) \\<and>\n          (\\<not> brk \\<longrightarrow>\n           worklist_inv_frontier passed wait \\<and>\n           (\\<forall>a\\<in>passed \\<union> set_mset wait. \\<not> F a) \\<and>\n           start_subsumed passed wait \\<and>\n           set_mset wait \\<subseteq> Collect reachable);\n        case x' of\n        (passed, wait, brk) \\<Rightarrow>\n          passed \\<subseteq> Collect reachable \\<and>\n          (brk \\<longrightarrow>\n           (\\<exists>f. reachable f \\<and> F f)) \\<and>\n          (\\<not> brk \\<longrightarrow>\n           worklist_inv_frontier passed wait \\<and>\n           (\\<forall>a\\<in>passed \\<union> set_mset wait. \\<not> F a) \\<and>\n           start_subsumed passed wait \\<and>\n           set_mset wait \\<subseteq> Collect reachable);\n        x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b);\n        (xa, x'a) \\<in> Id \\<times>\\<^sub>r Id; x'a = (x1d, x2d);\n        xa = (x1e, x2e); reachable x1d\\<rbrakk>\n       \\<Longrightarrow> Bex x1b ((\\<preceq>) x1e) =\n                         Bex x1 ((\\<preceq>) x1d)\n 7. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a x1d x2d x1e x2e.\n       \\<lbrakk>\\<not> F a\\<^sub>0; \\<not> F a\\<^sub>0;\n        (x, x')\n        \\<in> \\<langle>Id\\<rangle>set_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r bool_rel;\n        case x of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        case x' of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        case x of\n        (passed, wait, brk) \\<Rightarrow>\n          passed \\<subseteq> Collect reachable \\<and>\n          (brk \\<longrightarrow>\n           (\\<exists>f. reachable f \\<and> F f)) \\<and>\n          (\\<not> brk \\<longrightarrow>\n           worklist_inv_frontier passed wait \\<and>\n           (\\<forall>a\\<in>passed \\<union> set_mset wait. \\<not> F a) \\<and>\n           start_subsumed passed wait \\<and>\n           set_mset wait \\<subseteq> Collect reachable);\n        case x' of\n        (passed, wait, brk) \\<Rightarrow>\n          passed \\<subseteq> Collect reachable \\<and>\n          (brk \\<longrightarrow>\n           (\\<exists>f. reachable f \\<and> F f)) \\<and>\n          (\\<not> brk \\<longrightarrow>\n           worklist_inv_frontier passed wait \\<and>\n           (\\<forall>a\\<in>passed \\<union> set_mset wait. \\<not> F a) \\<and>\n           start_subsumed passed wait \\<and>\n           set_mset wait \\<subseteq> Collect reachable);\n        x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b);\n        (xa, x'a) \\<in> Id \\<times>\\<^sub>r Id; x'a = (x1d, x2d);\n        xa = (x1e, x2e); reachable x1d; Bex x1b ((\\<preceq>) x1e);\n        Bex x1 ((\\<preceq>) x1d)\\<rbrakk>\n       \\<Longrightarrow> ((x1b, x2e, x2c), x1, x2d, x2a)\n                         \\<in> \\<langle>Id\\<rangle>set_rel \\<times>\\<^sub>r\n                               Id \\<times>\\<^sub>r bool_rel\n 8. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a x1d x2d x1e x2e.\n       \\<lbrakk>\\<not> F a\\<^sub>0; \\<not> F a\\<^sub>0;\n        (x, x')\n        \\<in> \\<langle>Id\\<rangle>set_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r bool_rel;\n        case x of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        case x' of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        case x of\n        (passed, wait, brk) \\<Rightarrow>\n          passed \\<subseteq> Collect reachable \\<and>\n          (brk \\<longrightarrow>\n           (\\<exists>f. reachable f \\<and> F f)) \\<and>\n          (\\<not> brk \\<longrightarrow>\n           worklist_inv_frontier passed wait \\<and>\n           (\\<forall>a\\<in>passed \\<union> set_mset wait. \\<not> F a) \\<and>\n           start_subsumed passed wait \\<and>\n           set_mset wait \\<subseteq> Collect reachable);\n        case x' of\n        (passed, wait, brk) \\<Rightarrow>\n          passed \\<subseteq> Collect reachable \\<and>\n          (brk \\<longrightarrow>\n           (\\<exists>f. reachable f \\<and> F f)) \\<and>\n          (\\<not> brk \\<longrightarrow>\n           worklist_inv_frontier passed wait \\<and>\n           (\\<forall>a\\<in>passed \\<union> set_mset wait. \\<not> F a) \\<and>\n           start_subsumed passed wait \\<and>\n           set_mset wait \\<subseteq> Collect reachable);\n        x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b);\n        (xa, x'a) \\<in> Id \\<times>\\<^sub>r Id; x'a = (x1d, x2d);\n        xa = (x1e, x2e); reachable x1d; \\<not> Bex x1b ((\\<preceq>) x1e);\n        \\<not> Bex x1 ((\\<preceq>) x1d)\\<rbrakk>\n       \\<Longrightarrow> (x2e, x2d) \\<in> Id\n 9. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a x1d x2d x1e x2e.\n       \\<lbrakk>\\<not> F a\\<^sub>0; \\<not> F a\\<^sub>0;\n        (x, x')\n        \\<in> \\<langle>Id\\<rangle>set_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r bool_rel;\n        case x of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        case x' of\n        (passed, wait, brk) \\<Rightarrow>\n          \\<not> brk \\<and> wait \\<noteq> {#};\n        case x of\n        (passed, wait, brk) \\<Rightarrow>\n          passed \\<subseteq> Collect reachable \\<and>\n          (brk \\<longrightarrow>\n           (\\<exists>f. reachable f \\<and> F f)) \\<and>\n          (\\<not> brk \\<longrightarrow>\n           worklist_inv_frontier passed wait \\<and>\n           (\\<forall>a\\<in>passed \\<union> set_mset wait. \\<not> F a) \\<and>\n           start_subsumed passed wait \\<and>\n           set_mset wait \\<subseteq> Collect reachable);\n        case x' of\n        (passed, wait, brk) \\<Rightarrow>\n          passed \\<subseteq> Collect reachable \\<and>\n          (brk \\<longrightarrow>\n           (\\<exists>f. reachable f \\<and> F f)) \\<and>\n          (\\<not> brk \\<longrightarrow>\n           worklist_inv_frontier passed wait \\<and>\n           (\\<forall>a\\<in>passed \\<union> set_mset wait. \\<not> F a) \\<and>\n           start_subsumed passed wait \\<and>\n           set_mset wait \\<subseteq> Collect reachable);\n        x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b);\n        (xa, x'a) \\<in> Id \\<times>\\<^sub>r Id; x'a = (x1d, x2d);\n        xa = (x1e, x2e); reachable x1d; \\<not> Bex x1b ((\\<preceq>) x1e);\n        \\<not> Bex x1 ((\\<preceq>) x1d)\\<rbrakk>\n       \\<Longrightarrow> (x1e, x1d) \\<in> b_rel Id reachable\n 10. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a x1d x2d x1e x2e xb x'b\n        x1f x2f x1g x2g.\n        \\<lbrakk>\\<not> F a\\<^sub>0; \\<not> F a\\<^sub>0;\n         (x, x')\n         \\<in> \\<langle>Id\\<rangle>set_rel \\<times>\\<^sub>r\n               Id \\<times>\\<^sub>r bool_rel;\n         case x of\n         (passed, wait, brk) \\<Rightarrow>\n           \\<not> brk \\<and> wait \\<noteq> {#};\n         case x' of\n         (passed, wait, brk) \\<Rightarrow>\n           \\<not> brk \\<and> wait \\<noteq> {#};\n         case x of\n         (passed, wait, brk) \\<Rightarrow>\n           passed \\<subseteq> Collect reachable \\<and>\n           (brk \\<longrightarrow>\n            (\\<exists>f. reachable f \\<and> F f)) \\<and>\n           (\\<not> brk \\<longrightarrow>\n            worklist_inv_frontier passed wait \\<and>\n            (\\<forall>a\\<in>passed \\<union> set_mset wait.\n                \\<not> F a) \\<and>\n            start_subsumed passed wait \\<and>\n            set_mset wait \\<subseteq> Collect reachable);\n         case x' of\n         (passed, wait, brk) \\<Rightarrow>\n           passed \\<subseteq> Collect reachable \\<and>\n           (brk \\<longrightarrow>\n            (\\<exists>f. reachable f \\<and> F f)) \\<and>\n           (\\<not> brk \\<longrightarrow>\n            worklist_inv_frontier passed wait \\<and>\n            (\\<forall>a\\<in>passed \\<union> set_mset wait.\n                \\<not> F a) \\<and>\n            start_subsumed passed wait \\<and>\n            set_mset wait \\<subseteq> Collect reachable);\n         x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b);\n         (xa, x'a) \\<in> Id \\<times>\\<^sub>r Id; x'a = (x1d, x2d);\n         xa = (x1e, x2e); reachable x1d; \\<not> Bex x1b ((\\<preceq>) x1e);\n         \\<not> Bex x1 ((\\<preceq>) x1d);\n         (xb, x'b) \\<in> Id \\<times>\\<^sub>r bool_rel; x'b = (x1f, x2f);\n         xb = (x1g, x2g)\\<rbrakk>\n        \\<Longrightarrow> ((insert x1e x1b, x1g, x2g), insert x1d x1, x1f,\n                           x2f)\n                          \\<in> \\<langle>Id\\<rangle>set_rel \\<times>\\<^sub>r\n                                Id \\<times>\\<^sub>r bool_rel\nA total of 11 subgoals...", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "end \\<comment> \\<open>Theory\\<close>"]]}