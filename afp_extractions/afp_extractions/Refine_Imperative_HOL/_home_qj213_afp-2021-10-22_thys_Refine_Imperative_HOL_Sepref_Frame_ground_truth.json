{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/Sepref_Frame.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemma recover_pure_aux: \"CONSTRAINT is_pure R \\<Longrightarrow> hn_invalid R x y \\<Longrightarrow>\\<^sub>t hn_ctxt R x y\"", "lemma frame_thms:\n  \"P \\<Longrightarrow>\\<^sub>t P\"\n  \"P\\<Longrightarrow>\\<^sub>tP' \\<Longrightarrow> F\\<Longrightarrow>\\<^sub>tF' \\<Longrightarrow> F*P \\<Longrightarrow>\\<^sub>t F'*P'\"\n  \"hn_ctxt R x y \\<Longrightarrow>\\<^sub>t hn_invalid R x y\"\n  \"hn_ctxt R x y \\<Longrightarrow>\\<^sub>t hn_ctxt (\\<lambda>_ _. true) x y\"\n  \"CONSTRAINT is_pure R \\<Longrightarrow> hn_invalid R x y \\<Longrightarrow>\\<^sub>t hn_ctxt R x y\"", "lemma frame_rem1: \"P\\<Longrightarrow>\\<^sub>tP\"", "lemma frame_rem2: \"F \\<Longrightarrow>\\<^sub>t F' \\<Longrightarrow> F * hn_ctxt A x y \\<Longrightarrow>\\<^sub>t F' * hn_ctxt A x y\"", "lemma frame_rem3: \"F \\<Longrightarrow>\\<^sub>t F' \\<Longrightarrow> F * hn_ctxt A x y \\<Longrightarrow>\\<^sub>t F'\"", "lemma frame_rem4: \"P \\<Longrightarrow>\\<^sub>t emp\"", "lemmas frame_rem_thms = frame_rem1 frame_rem2 frame_rem3 frame_rem4", "lemma ent_disj_star_mono:\n  \"\\<lbrakk> A \\<or>\\<^sub>A C \\<Longrightarrow>\\<^sub>A E; B \\<or>\\<^sub>A D \\<Longrightarrow>\\<^sub>A F \\<rbrakk> \\<Longrightarrow> A*B \\<or>\\<^sub>A C*D \\<Longrightarrow>\\<^sub>A E*F\"", "lemma entt_disj_star_mono:\n  \"\\<lbrakk> A \\<or>\\<^sub>A C \\<Longrightarrow>\\<^sub>t E; B \\<or>\\<^sub>A D \\<Longrightarrow>\\<^sub>t F \\<rbrakk> \\<Longrightarrow> A*B \\<or>\\<^sub>A C*D \\<Longrightarrow>\\<^sub>t E*F\"", "lemma hn_merge1:\n  (*\"emp \\<or>\\<^sub>A emp \\<Longrightarrow>\\<^sub>A emp\"*)\n  \"F \\<or>\\<^sub>A F \\<Longrightarrow>\\<^sub>t F\"\n  \"\\<lbrakk> hn_ctxt R1 x x' \\<or>\\<^sub>A hn_ctxt R2 x x' \\<Longrightarrow>\\<^sub>t hn_ctxt R x x'; Fl \\<or>\\<^sub>A Fr \\<Longrightarrow>\\<^sub>t F \\<rbrakk> \n    \\<Longrightarrow> Fl * hn_ctxt R1 x x' \\<or>\\<^sub>A Fr * hn_ctxt R2 x x' \\<Longrightarrow>\\<^sub>t F * hn_ctxt R x x'\"", "lemma hn_merge2:\n  \"hn_invalid R x x' \\<or>\\<^sub>A hn_ctxt R x x' \\<Longrightarrow>\\<^sub>t hn_invalid R x x'\"\n  \"hn_ctxt R x x' \\<or>\\<^sub>A hn_invalid R x x' \\<Longrightarrow>\\<^sub>t hn_invalid R x x'\"", "lemma invalid_assn_mono: \"hn_ctxt A x y \\<Longrightarrow>\\<^sub>t hn_ctxt B x y \n  \\<Longrightarrow> hn_invalid A x y \\<Longrightarrow>\\<^sub>t hn_invalid B x y\"", "lemma hn_merge3: (* Not used *)\n  \"\\<lbrakk>NO_MATCH (hn_invalid XX) R2; hn_ctxt R1 x x' \\<or>\\<^sub>A hn_ctxt R2 x x' \\<Longrightarrow>\\<^sub>t hn_ctxt Rm x x'\\<rbrakk> \\<Longrightarrow> hn_invalid R1 x x' \\<or>\\<^sub>A hn_ctxt R2 x x' \\<Longrightarrow>\\<^sub>t hn_invalid Rm x x'\"\n  \"\\<lbrakk>NO_MATCH (hn_invalid XX) R1; hn_ctxt R1 x x' \\<or>\\<^sub>A hn_ctxt R2 x x' \\<Longrightarrow>\\<^sub>t hn_ctxt Rm x x'\\<rbrakk> \\<Longrightarrow> hn_ctxt R1 x x' \\<or>\\<^sub>A hn_invalid R2 x x' \\<Longrightarrow>\\<^sub>t hn_invalid Rm x x'\"", "lemmas merge_thms = hn_merge1 hn_merge2", "lemma hn_merge_mismatch: \"hn_ctxt R1 x x' \\<or>\\<^sub>A hn_ctxt R2 x x' \\<Longrightarrow>\\<^sub>t hn_mismatch R1 R2 x x'\"", "lemma is_merge: \"P1\\<or>\\<^sub>AP2\\<Longrightarrow>\\<^sub>tP \\<Longrightarrow> P1\\<or>\\<^sub>AP2\\<Longrightarrow>\\<^sub>tP\"", "lemma merge_mono: \"\\<lbrakk>A\\<Longrightarrow>\\<^sub>tA'; B\\<Longrightarrow>\\<^sub>tB'; A'\\<or>\\<^sub>AB' \\<Longrightarrow>\\<^sub>t C\\<rbrakk> \\<Longrightarrow> A\\<or>\\<^sub>AB \\<Longrightarrow>\\<^sub>t C\"", "lemma gen_merge_cons1: \"\\<lbrakk>A\\<Longrightarrow>\\<^sub>tA'; A'\\<or>\\<^sub>AB \\<Longrightarrow>\\<^sub>t C\\<rbrakk> \\<Longrightarrow> A\\<or>\\<^sub>AB \\<Longrightarrow>\\<^sub>t C\"", "lemma gen_merge_cons2: \"\\<lbrakk>B\\<Longrightarrow>\\<^sub>tB'; A\\<or>\\<^sub>AB' \\<Longrightarrow>\\<^sub>t C\\<rbrakk> \\<Longrightarrow> A\\<or>\\<^sub>AB \\<Longrightarrow>\\<^sub>t C\"", "lemmas gen_merge_cons = gen_merge_cons1 gen_merge_cons2", "lemma recover_pure:\n  \"RECOVER_PURE emp emp\"\n  \"\\<lbrakk>RECOVER_PURE P2 Q2; RECOVER_PURE P1 Q1\\<rbrakk> \\<Longrightarrow> RECOVER_PURE (P1*P2) (Q1*Q2)\"\n  \"CONSTRAINT is_pure R \\<Longrightarrow> RECOVER_PURE (hn_invalid R x y) (hn_ctxt R x y)\"\n  \"RECOVER_PURE (hn_ctxt R x y) (hn_ctxt R x y)\"", "lemma recover_pure_triv: \n  \"RECOVER_PURE P P\"", "lemma weaken_hnr_postI:\n  assumes \"WEAKEN_HNR_POST \\<Gamma> \\<Gamma>'' \\<Gamma>'\"\n  assumes \"hn_refine \\<Gamma> c \\<Gamma>' R a\"\n  shows \"hn_refine \\<Gamma> c \\<Gamma>'' R a\"", "lemma weaken_hnr_post_triv: \"WEAKEN_HNR_POST \\<Gamma> P P\"", "lemma weaken_hnr_post:\n  \"\\<lbrakk>WEAKEN_HNR_POST \\<Gamma> P P'; WEAKEN_HNR_POST \\<Gamma>' Q Q'\\<rbrakk> \\<Longrightarrow> WEAKEN_HNR_POST (\\<Gamma>*\\<Gamma>') (P*Q) (P'*Q')\"\n  \"WEAKEN_HNR_POST (hn_ctxt R x y) (hn_ctxt R x y) (hn_ctxt R x y)\"\n  \"WEAKEN_HNR_POST (hn_ctxt R x y) (hn_invalid R x y) (hn_ctxt (\\<lambda>_ _. true) x y)\"", "lemma reorder_enttI:\n  assumes \"A*true = C*true\"\n  assumes \"B*true = D*true\"\n  shows \"(A\\<Longrightarrow>\\<^sub>tB) \\<equiv> (C\\<Longrightarrow>\\<^sub>tD)\"", "lemma merge_sat1: \"(A\\<or>\\<^sub>AA' \\<Longrightarrow>\\<^sub>t Am) \\<Longrightarrow> (A\\<or>\\<^sub>AAm \\<Longrightarrow>\\<^sub>t Am)\"", "lemma merge_sat2: \"(A\\<or>\\<^sub>AA' \\<Longrightarrow>\\<^sub>t Am) \\<Longrightarrow> (Am\\<or>\\<^sub>AA' \\<Longrightarrow>\\<^sub>t Am)\"", "lemmas [sepref_frame_normrel_eqs] = the_pure_pure pure_the_pure"], "translations": [["", "lemma recover_pure_aux: \"CONSTRAINT is_pure R \\<Longrightarrow> hn_invalid R x y \\<Longrightarrow>\\<^sub>t hn_ctxt R x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CONSTRAINT is_pure R \\<Longrightarrow>\n    hn_invalid R x y \\<Longrightarrow>\\<^sub>t hn_ctxt R x y", "by (auto simp: is_pure_conv invalid_pure_recover hn_ctxt_def)"], ["", "lemma frame_thms:\n  \"P \\<Longrightarrow>\\<^sub>t P\"\n  \"P\\<Longrightarrow>\\<^sub>tP' \\<Longrightarrow> F\\<Longrightarrow>\\<^sub>tF' \\<Longrightarrow> F*P \\<Longrightarrow>\\<^sub>t F'*P'\"\n  \"hn_ctxt R x y \\<Longrightarrow>\\<^sub>t hn_invalid R x y\"\n  \"hn_ctxt R x y \\<Longrightarrow>\\<^sub>t hn_ctxt (\\<lambda>_ _. true) x y\"\n  \"CONSTRAINT is_pure R \\<Longrightarrow> hn_invalid R x y \\<Longrightarrow>\\<^sub>t hn_ctxt R x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<Longrightarrow>\\<^sub>t P &&&\n     (\\<lbrakk>P \\<Longrightarrow>\\<^sub>t P';\n       F \\<Longrightarrow>\\<^sub>t F'\\<rbrakk>\n      \\<Longrightarrow> F * P \\<Longrightarrow>\\<^sub>t F' * P')) &&&\n    hn_ctxt R x y \\<Longrightarrow>\\<^sub>t hn_invalid R x y &&&\n    hn_ctxt R x y \\<Longrightarrow>\\<^sub>t\n    hn_ctxt (\\<lambda>_ _. true) x y &&&\n    (CONSTRAINT is_pure R \\<Longrightarrow>\n     hn_invalid R x y \\<Longrightarrow>\\<^sub>t hn_ctxt R x y)", "apply -"], ["proof (prove)\ngoal (5 subgoals):\n 1. P \\<Longrightarrow>\\<^sub>t P\n 2. \\<lbrakk>P \\<Longrightarrow>\\<^sub>t P';\n     F \\<Longrightarrow>\\<^sub>t F'\\<rbrakk>\n    \\<Longrightarrow> F * P \\<Longrightarrow>\\<^sub>t F' * P'\n 3. hn_ctxt R x y \\<Longrightarrow>\\<^sub>t hn_invalid R x y\n 4. hn_ctxt R x y \\<Longrightarrow>\\<^sub>t hn_ctxt (\\<lambda>_ _. true) x y\n 5. CONSTRAINT is_pure R \\<Longrightarrow>\n    hn_invalid R x y \\<Longrightarrow>\\<^sub>t hn_ctxt R x y", "applyS simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>P \\<Longrightarrow>\\<^sub>t P';\n     F \\<Longrightarrow>\\<^sub>t F'\\<rbrakk>\n    \\<Longrightarrow> F * P \\<Longrightarrow>\\<^sub>t F' * P'\n 2. hn_ctxt R x y \\<Longrightarrow>\\<^sub>t hn_invalid R x y\n 3. hn_ctxt R x y \\<Longrightarrow>\\<^sub>t hn_ctxt (\\<lambda>_ _. true) x y\n 4. CONSTRAINT is_pure R \\<Longrightarrow>\n    hn_invalid R x y \\<Longrightarrow>\\<^sub>t hn_ctxt R x y", "applyS (rule entt_star_mono; assumption)"], ["proof (prove)\ngoal (3 subgoals):\n 1. hn_ctxt R x y \\<Longrightarrow>\\<^sub>t hn_invalid R x y\n 2. hn_ctxt R x y \\<Longrightarrow>\\<^sub>t hn_ctxt (\\<lambda>_ _. true) x y\n 3. CONSTRAINT is_pure R \\<Longrightarrow>\n    hn_invalid R x y \\<Longrightarrow>\\<^sub>t hn_ctxt R x y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_ctxt R x y \\<Longrightarrow>\\<^sub>t hn_invalid R x y", "apply (simp add: hn_ctxt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. R x y \\<Longrightarrow>\\<^sub>t invalid_assn R x y", "apply (rule enttI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. R x y \\<Longrightarrow>\\<^sub>A invalid_assn R x y * true", "apply (rule ent_trans[OF invalidate[of R]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. invalid_assn R x y \\<Longrightarrow>\\<^sub>A invalid_assn R x y * true", "by solve_entails"], ["proof (prove)\ngoal (2 subgoals):\n 1. hn_ctxt R x y \\<Longrightarrow>\\<^sub>t hn_ctxt (\\<lambda>_ _. true) x y\n 2. CONSTRAINT is_pure R \\<Longrightarrow>\n    hn_invalid R x y \\<Longrightarrow>\\<^sub>t hn_ctxt R x y", "applyS (sep_auto simp: hn_ctxt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. CONSTRAINT is_pure R \\<Longrightarrow>\n    hn_invalid R x y \\<Longrightarrow>\\<^sub>t hn_ctxt R x y", "applyS (erule recover_pure_aux)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "named_theorems_rev sepref_frame_match_rules \\<open>Sepref: Additional frame rules\\<close>"], ["", "text \\<open>Rules to discharge unmatched stuff\\<close>"], ["", "(*lemma frame_rem_thms:\n  \"P \\<Longrightarrow>\\<^sub>t P\"\n  \"P \\<Longrightarrow>\\<^sub>t emp\"\n  by sep_auto+\n*)"], ["", "lemma frame_rem1: \"P\\<Longrightarrow>\\<^sub>tP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<Longrightarrow>\\<^sub>t P", "by simp"], ["", "lemma frame_rem2: \"F \\<Longrightarrow>\\<^sub>t F' \\<Longrightarrow> F * hn_ctxt A x y \\<Longrightarrow>\\<^sub>t F' * hn_ctxt A x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<Longrightarrow>\\<^sub>t F' \\<Longrightarrow>\n    F * hn_ctxt A x y \\<Longrightarrow>\\<^sub>t F' * hn_ctxt A x y", "apply (rule entt_star_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. F \\<Longrightarrow>\\<^sub>t F' \\<Longrightarrow>\n    F \\<Longrightarrow>\\<^sub>t F'\n 2. F \\<Longrightarrow>\\<^sub>t F' \\<Longrightarrow>\n    hn_ctxt A x y \\<Longrightarrow>\\<^sub>t hn_ctxt A x y", "by auto"], ["", "lemma frame_rem3: \"F \\<Longrightarrow>\\<^sub>t F' \\<Longrightarrow> F * hn_ctxt A x y \\<Longrightarrow>\\<^sub>t F'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<Longrightarrow>\\<^sub>t F' \\<Longrightarrow>\n    F * hn_ctxt A x y \\<Longrightarrow>\\<^sub>t F'", "using frame_thms(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?P \\<Longrightarrow>\\<^sub>t ?P';\n   ?F \\<Longrightarrow>\\<^sub>t ?F'\\<rbrakk>\n  \\<Longrightarrow> ?F * ?P \\<Longrightarrow>\\<^sub>t ?F' * ?P'\n\ngoal (1 subgoal):\n 1. F \\<Longrightarrow>\\<^sub>t F' \\<Longrightarrow>\n    F * hn_ctxt A x y \\<Longrightarrow>\\<^sub>t F'", "by fastforce"], ["", "lemma frame_rem4: \"P \\<Longrightarrow>\\<^sub>t emp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<Longrightarrow>\\<^sub>t emp", "by simp"], ["", "lemmas frame_rem_thms = frame_rem1 frame_rem2 frame_rem3 frame_rem4"], ["", "named_theorems_rev sepref_frame_rem_rules\n  \\<open>Sepref: Additional rules to resolve remainder of frame-pairing\\<close>"], ["", "lemma ent_disj_star_mono:\n  \"\\<lbrakk> A \\<or>\\<^sub>A C \\<Longrightarrow>\\<^sub>A E; B \\<or>\\<^sub>A D \\<Longrightarrow>\\<^sub>A F \\<rbrakk> \\<Longrightarrow> A*B \\<or>\\<^sub>A C*D \\<Longrightarrow>\\<^sub>A E*F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<or>\\<^sub>A C \\<Longrightarrow>\\<^sub>A E;\n     B \\<or>\\<^sub>A D \\<Longrightarrow>\\<^sub>A F\\<rbrakk>\n    \\<Longrightarrow> A * B \\<or>\\<^sub>A C * D \\<Longrightarrow>\\<^sub>A\n                      E * F", "by (metis ent_disjI1 ent_disjI2 ent_disjE ent_star_mono)"], ["", "lemma entt_disj_star_mono:\n  \"\\<lbrakk> A \\<or>\\<^sub>A C \\<Longrightarrow>\\<^sub>t E; B \\<or>\\<^sub>A D \\<Longrightarrow>\\<^sub>t F \\<rbrakk> \\<Longrightarrow> A*B \\<or>\\<^sub>A C*D \\<Longrightarrow>\\<^sub>t E*F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<or>\\<^sub>A C \\<Longrightarrow>\\<^sub>t E;\n     B \\<or>\\<^sub>A D \\<Longrightarrow>\\<^sub>t F\\<rbrakk>\n    \\<Longrightarrow> A * B \\<or>\\<^sub>A C * D \\<Longrightarrow>\\<^sub>t\n                      E * F", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<or>\\<^sub>A C \\<Longrightarrow>\\<^sub>t E;\n     B \\<or>\\<^sub>A D \\<Longrightarrow>\\<^sub>t F\\<rbrakk>\n    \\<Longrightarrow> A * B \\<or>\\<^sub>A C * D \\<Longrightarrow>\\<^sub>t\n                      E * F", "assume a1: \"A \\<or>\\<^sub>A C \\<Longrightarrow>\\<^sub>t E\""], ["proof (state)\nthis:\n  A \\<or>\\<^sub>A C \\<Longrightarrow>\\<^sub>t E\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<or>\\<^sub>A C \\<Longrightarrow>\\<^sub>t E;\n     B \\<or>\\<^sub>A D \\<Longrightarrow>\\<^sub>t F\\<rbrakk>\n    \\<Longrightarrow> A * B \\<or>\\<^sub>A C * D \\<Longrightarrow>\\<^sub>t\n                      E * F", "assume \"B \\<or>\\<^sub>A D \\<Longrightarrow>\\<^sub>t F\""], ["proof (state)\nthis:\n  B \\<or>\\<^sub>A D \\<Longrightarrow>\\<^sub>t F\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<or>\\<^sub>A C \\<Longrightarrow>\\<^sub>t E;\n     B \\<or>\\<^sub>A D \\<Longrightarrow>\\<^sub>t F\\<rbrakk>\n    \\<Longrightarrow> A * B \\<or>\\<^sub>A C * D \\<Longrightarrow>\\<^sub>t\n                      E * F", "then"], ["proof (chain)\npicking this:\n  B \\<or>\\<^sub>A D \\<Longrightarrow>\\<^sub>t F", "have \"A * B \\<or>\\<^sub>A C * D \\<Longrightarrow>\\<^sub>A true * E * (true * F)\""], ["proof (prove)\nusing this:\n  B \\<or>\\<^sub>A D \\<Longrightarrow>\\<^sub>t F\n\ngoal (1 subgoal):\n 1. A * B \\<or>\\<^sub>A C * D \\<Longrightarrow>\\<^sub>A\n    true * E * (true * F)", "using a1"], ["proof (prove)\nusing this:\n  B \\<or>\\<^sub>A D \\<Longrightarrow>\\<^sub>t F\n  A \\<or>\\<^sub>A C \\<Longrightarrow>\\<^sub>t E\n\ngoal (1 subgoal):\n 1. A * B \\<or>\\<^sub>A C * D \\<Longrightarrow>\\<^sub>A\n    true * E * (true * F)", "by (simp add: ent_disj_star_mono enttD)"], ["proof (state)\nthis:\n  A * B \\<or>\\<^sub>A C * D \\<Longrightarrow>\\<^sub>A true * E * (true * F)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<or>\\<^sub>A C \\<Longrightarrow>\\<^sub>t E;\n     B \\<or>\\<^sub>A D \\<Longrightarrow>\\<^sub>t F\\<rbrakk>\n    \\<Longrightarrow> A * B \\<or>\\<^sub>A C * D \\<Longrightarrow>\\<^sub>t\n                      E * F", "then"], ["proof (chain)\npicking this:\n  A * B \\<or>\\<^sub>A C * D \\<Longrightarrow>\\<^sub>A true * E * (true * F)", "show ?thesis"], ["proof (prove)\nusing this:\n  A * B \\<or>\\<^sub>A C * D \\<Longrightarrow>\\<^sub>A true * E * (true * F)\n\ngoal (1 subgoal):\n 1. A * B \\<or>\\<^sub>A C * D \\<Longrightarrow>\\<^sub>t E * F", "by (metis (no_types) assn_times_comm enttI merge_true_star_ctx star_aci(3))"], ["proof (state)\nthis:\n  A * B \\<or>\\<^sub>A C * D \\<Longrightarrow>\\<^sub>t E * F\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hn_merge1:\n  (*\"emp \\<or>\\<^sub>A emp \\<Longrightarrow>\\<^sub>A emp\"*)\n  \"F \\<or>\\<^sub>A F \\<Longrightarrow>\\<^sub>t F\"\n  \"\\<lbrakk> hn_ctxt R1 x x' \\<or>\\<^sub>A hn_ctxt R2 x x' \\<Longrightarrow>\\<^sub>t hn_ctxt R x x'; Fl \\<or>\\<^sub>A Fr \\<Longrightarrow>\\<^sub>t F \\<rbrakk> \n    \\<Longrightarrow> Fl * hn_ctxt R1 x x' \\<or>\\<^sub>A Fr * hn_ctxt R2 x x' \\<Longrightarrow>\\<^sub>t F * hn_ctxt R x x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<or>\\<^sub>A F \\<Longrightarrow>\\<^sub>t F &&&\n    (\\<lbrakk>hn_ctxt R1 x x' \\<or>\\<^sub>A\n              hn_ctxt R2 x x' \\<Longrightarrow>\\<^sub>t\n              hn_ctxt R x x';\n      Fl \\<or>\\<^sub>A Fr \\<Longrightarrow>\\<^sub>t F\\<rbrakk>\n     \\<Longrightarrow> Fl * hn_ctxt R1 x x' \\<or>\\<^sub>A\n                       Fr * hn_ctxt R2 x x' \\<Longrightarrow>\\<^sub>t\n                       F * hn_ctxt R x x')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hn_ctxt R1 x x' \\<or>\\<^sub>A\n             hn_ctxt R2 x x' \\<Longrightarrow>\\<^sub>t\n             hn_ctxt R x x';\n     Fl \\<or>\\<^sub>A Fr \\<Longrightarrow>\\<^sub>t F\\<rbrakk>\n    \\<Longrightarrow> Fl * hn_ctxt R1 x x' \\<or>\\<^sub>A\n                      Fr * hn_ctxt R2 x x' \\<Longrightarrow>\\<^sub>t\n                      F * hn_ctxt R x x'", "by (rule entt_disj_star_mono; simp)"], ["", "lemma hn_merge2:\n  \"hn_invalid R x x' \\<or>\\<^sub>A hn_ctxt R x x' \\<Longrightarrow>\\<^sub>t hn_invalid R x x'\"\n  \"hn_ctxt R x x' \\<or>\\<^sub>A hn_invalid R x x' \\<Longrightarrow>\\<^sub>t hn_invalid R x x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_invalid R x x' \\<or>\\<^sub>A hn_ctxt R x x' \\<Longrightarrow>\\<^sub>t\n    hn_invalid R x x' &&&\n    hn_ctxt R x x' \\<or>\\<^sub>A hn_invalid R x x' \\<Longrightarrow>\\<^sub>t\n    hn_invalid R x x'", "by (sep_auto eintros: invalidate ent_disjE intro!: ent_imp_entt simp: hn_ctxt_def)+"], ["", "lemma invalid_assn_mono: \"hn_ctxt A x y \\<Longrightarrow>\\<^sub>t hn_ctxt B x y \n  \\<Longrightarrow> hn_invalid A x y \\<Longrightarrow>\\<^sub>t hn_invalid B x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_ctxt A x y \\<Longrightarrow>\\<^sub>t hn_ctxt B x y \\<Longrightarrow>\n    hn_invalid A x y \\<Longrightarrow>\\<^sub>t hn_invalid B x y", "by (clarsimp simp: invalid_assn_def entailst_def entails_def hn_ctxt_def)\n      (force simp: mod_star_conv)"], ["", "lemma hn_merge3: (* Not used *)\n  \"\\<lbrakk>NO_MATCH (hn_invalid XX) R2; hn_ctxt R1 x x' \\<or>\\<^sub>A hn_ctxt R2 x x' \\<Longrightarrow>\\<^sub>t hn_ctxt Rm x x'\\<rbrakk> \\<Longrightarrow> hn_invalid R1 x x' \\<or>\\<^sub>A hn_ctxt R2 x x' \\<Longrightarrow>\\<^sub>t hn_invalid Rm x x'\"\n  \"\\<lbrakk>NO_MATCH (hn_invalid XX) R1; hn_ctxt R1 x x' \\<or>\\<^sub>A hn_ctxt R2 x x' \\<Longrightarrow>\\<^sub>t hn_ctxt Rm x x'\\<rbrakk> \\<Longrightarrow> hn_ctxt R1 x x' \\<or>\\<^sub>A hn_invalid R2 x x' \\<Longrightarrow>\\<^sub>t hn_invalid Rm x x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>NO_MATCH (hn_invalid XX) R2;\n      hn_ctxt R1 x x' \\<or>\\<^sub>A\n      hn_ctxt R2 x x' \\<Longrightarrow>\\<^sub>t\n      hn_ctxt Rm x x'\\<rbrakk>\n     \\<Longrightarrow> hn_invalid R1 x x' \\<or>\\<^sub>A\n                       hn_ctxt R2 x x' \\<Longrightarrow>\\<^sub>t\n                       hn_invalid Rm x x') &&&\n    (\\<lbrakk>NO_MATCH (hn_invalid XX) R1;\n      hn_ctxt R1 x x' \\<or>\\<^sub>A\n      hn_ctxt R2 x x' \\<Longrightarrow>\\<^sub>t\n      hn_ctxt Rm x x'\\<rbrakk>\n     \\<Longrightarrow> hn_ctxt R1 x x' \\<or>\\<^sub>A\n                       hn_invalid R2 x x' \\<Longrightarrow>\\<^sub>t\n                       hn_invalid Rm x x')", "apply (meson entt_disjD1 entt_disjD2 entt_disjE entt_trans frame_thms(3) invalid_assn_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>NO_MATCH (hn_invalid XX) R1;\n     hn_ctxt R1 x x' \\<or>\\<^sub>A hn_ctxt R2 x x' \\<Longrightarrow>\\<^sub>t\n     hn_ctxt Rm x x'\\<rbrakk>\n    \\<Longrightarrow> hn_ctxt R1 x x' \\<or>\\<^sub>A\n                      hn_invalid R2 x x' \\<Longrightarrow>\\<^sub>t\n                      hn_invalid Rm x x'", "apply (meson entt_disjD1 entt_disjD2 entt_disjE entt_trans frame_thms(3) invalid_assn_mono)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas merge_thms = hn_merge1 hn_merge2"], ["", "named_theorems sepref_frame_merge_rules \\<open>Sepref: Additional merge rules\\<close>"], ["", "lemma hn_merge_mismatch: \"hn_ctxt R1 x x' \\<or>\\<^sub>A hn_ctxt R2 x x' \\<Longrightarrow>\\<^sub>t hn_mismatch R1 R2 x x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_ctxt R1 x x' \\<or>\\<^sub>A hn_ctxt R2 x x' \\<Longrightarrow>\\<^sub>t\n    hn_mismatch R1 R2 x x'", "by (sep_auto simp: hn_ctxt_def mismatch_assn_def)"], ["", "lemma is_merge: \"P1\\<or>\\<^sub>AP2\\<Longrightarrow>\\<^sub>tP \\<Longrightarrow> P1\\<or>\\<^sub>AP2\\<Longrightarrow>\\<^sub>tP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P1 \\<or>\\<^sub>A P2 \\<Longrightarrow>\\<^sub>t P \\<Longrightarrow>\n    P1 \\<or>\\<^sub>A P2 \\<Longrightarrow>\\<^sub>t P", "."], ["", "lemma merge_mono: \"\\<lbrakk>A\\<Longrightarrow>\\<^sub>tA'; B\\<Longrightarrow>\\<^sub>tB'; A'\\<or>\\<^sub>AB' \\<Longrightarrow>\\<^sub>t C\\<rbrakk> \\<Longrightarrow> A\\<or>\\<^sub>AB \\<Longrightarrow>\\<^sub>t C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<Longrightarrow>\\<^sub>t A'; B \\<Longrightarrow>\\<^sub>t B';\n     A' \\<or>\\<^sub>A B' \\<Longrightarrow>\\<^sub>t C\\<rbrakk>\n    \\<Longrightarrow> A \\<or>\\<^sub>A B \\<Longrightarrow>\\<^sub>t C", "by (meson entt_disjE entt_disjI1_direct entt_disjI2_direct entt_trans)"], ["", "text \\<open>Apply forward rule on left or right side of merge\\<close>"], ["", "lemma gen_merge_cons1: \"\\<lbrakk>A\\<Longrightarrow>\\<^sub>tA'; A'\\<or>\\<^sub>AB \\<Longrightarrow>\\<^sub>t C\\<rbrakk> \\<Longrightarrow> A\\<or>\\<^sub>AB \\<Longrightarrow>\\<^sub>t C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<Longrightarrow>\\<^sub>t A';\n     A' \\<or>\\<^sub>A B \\<Longrightarrow>\\<^sub>t C\\<rbrakk>\n    \\<Longrightarrow> A \\<or>\\<^sub>A B \\<Longrightarrow>\\<^sub>t C", "by (meson merge_mono entt_refl)"], ["", "lemma gen_merge_cons2: \"\\<lbrakk>B\\<Longrightarrow>\\<^sub>tB'; A\\<or>\\<^sub>AB' \\<Longrightarrow>\\<^sub>t C\\<rbrakk> \\<Longrightarrow> A\\<or>\\<^sub>AB \\<Longrightarrow>\\<^sub>t C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>B \\<Longrightarrow>\\<^sub>t B';\n     A \\<or>\\<^sub>A B' \\<Longrightarrow>\\<^sub>t C\\<rbrakk>\n    \\<Longrightarrow> A \\<or>\\<^sub>A B \\<Longrightarrow>\\<^sub>t C", "by (meson merge_mono entt_refl)"], ["", "lemmas gen_merge_cons = gen_merge_cons1 gen_merge_cons2"], ["", "text \\<open>These rules are applied to recover pure values that have been destroyed by rule application\\<close>"], ["", "definition \"RECOVER_PURE P Q \\<equiv> P \\<Longrightarrow>\\<^sub>t Q\""], ["", "lemma recover_pure:\n  \"RECOVER_PURE emp emp\"\n  \"\\<lbrakk>RECOVER_PURE P2 Q2; RECOVER_PURE P1 Q1\\<rbrakk> \\<Longrightarrow> RECOVER_PURE (P1*P2) (Q1*Q2)\"\n  \"CONSTRAINT is_pure R \\<Longrightarrow> RECOVER_PURE (hn_invalid R x y) (hn_ctxt R x y)\"\n  \"RECOVER_PURE (hn_ctxt R x y) (hn_ctxt R x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (RECOVER_PURE emp emp &&&\n     (\\<lbrakk>RECOVER_PURE P2 Q2; RECOVER_PURE P1 Q1\\<rbrakk>\n      \\<Longrightarrow> RECOVER_PURE (P1 * P2) (Q1 * Q2))) &&&\n    (CONSTRAINT is_pure R \\<Longrightarrow>\n     RECOVER_PURE (hn_invalid R x y) (hn_ctxt R x y)) &&&\n    RECOVER_PURE (hn_ctxt R x y) (hn_ctxt R x y)", "unfolding RECOVER_PURE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (emp \\<Longrightarrow>\\<^sub>t emp &&&\n     (\\<lbrakk>P2 \\<Longrightarrow>\\<^sub>t Q2;\n       P1 \\<Longrightarrow>\\<^sub>t Q1\\<rbrakk>\n      \\<Longrightarrow> P1 * P2 \\<Longrightarrow>\\<^sub>t Q1 * Q2)) &&&\n    (CONSTRAINT is_pure R \\<Longrightarrow>\n     hn_invalid R x y \\<Longrightarrow>\\<^sub>t hn_ctxt R x y) &&&\n    hn_ctxt R x y \\<Longrightarrow>\\<^sub>t hn_ctxt R x y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. emp \\<Longrightarrow>\\<^sub>t emp", "by sep_auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>P2 \\<Longrightarrow>\\<^sub>t Q2;\n     P1 \\<Longrightarrow>\\<^sub>t Q1\\<rbrakk>\n    \\<Longrightarrow> P1 * P2 \\<Longrightarrow>\\<^sub>t Q1 * Q2\n 2. CONSTRAINT is_pure R \\<Longrightarrow>\n    hn_invalid R x y \\<Longrightarrow>\\<^sub>t hn_ctxt R x y\n 3. hn_ctxt R x y \\<Longrightarrow>\\<^sub>t hn_ctxt R x y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P2 \\<Longrightarrow>\\<^sub>t Q2;\n     P1 \\<Longrightarrow>\\<^sub>t Q1\\<rbrakk>\n    \\<Longrightarrow> P1 * P2 \\<Longrightarrow>\\<^sub>t Q1 * Q2", "by (drule (1) entt_star_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. CONSTRAINT is_pure R \\<Longrightarrow>\n    hn_invalid R x y \\<Longrightarrow>\\<^sub>t hn_ctxt R x y\n 2. hn_ctxt R x y \\<Longrightarrow>\\<^sub>t hn_ctxt R x y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. CONSTRAINT is_pure R \\<Longrightarrow>\n    hn_invalid R x y \\<Longrightarrow>\\<^sub>t hn_ctxt R x y", "by (rule recover_pure_aux)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_ctxt R x y \\<Longrightarrow>\\<^sub>t hn_ctxt R x y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_ctxt R x y \\<Longrightarrow>\\<^sub>t hn_ctxt R x y", "by sep_auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma recover_pure_triv: \n  \"RECOVER_PURE P P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RECOVER_PURE P P", "unfolding RECOVER_PURE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<Longrightarrow>\\<^sub>t P", "by sep_auto"], ["", "text \\<open>Weakening the postcondition by converting @{const invalid_assn} to @{term \"\\<lambda>_ _. true\"}\\<close>"], ["", "definition \"WEAKEN_HNR_POST \\<Gamma> \\<Gamma>' \\<Gamma>'' \\<equiv> (\\<exists>h. h\\<Turnstile>\\<Gamma>) \\<longrightarrow> (\\<Gamma>'' \\<Longrightarrow>\\<^sub>t \\<Gamma>')\""], ["", "lemma weaken_hnr_postI:\n  assumes \"WEAKEN_HNR_POST \\<Gamma> \\<Gamma>'' \\<Gamma>'\"\n  assumes \"hn_refine \\<Gamma> c \\<Gamma>' R a\"\n  shows \"hn_refine \\<Gamma> c \\<Gamma>'' R a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine \\<Gamma> c \\<Gamma>'' R a", "apply (rule hn_refine_preI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       h \\<Turnstile> \\<Gamma> \\<Longrightarrow>\n       hn_refine \\<Gamma> c \\<Gamma>'' R a", "apply (rule hn_refine_cons_post)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>h.\n       h \\<Turnstile> \\<Gamma> \\<Longrightarrow>\n       hn_refine \\<Gamma> c (?Q2 h) R a\n 2. \\<And>h.\n       h \\<Turnstile> \\<Gamma> \\<Longrightarrow>\n       ?Q2 h \\<Longrightarrow>\\<^sub>t \\<Gamma>''", "apply (rule assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       h \\<Turnstile> \\<Gamma> \\<Longrightarrow>\n       \\<Gamma>' \\<Longrightarrow>\\<^sub>t \\<Gamma>''", "using assms(1)"], ["proof (prove)\nusing this:\n  WEAKEN_HNR_POST \\<Gamma> \\<Gamma>'' \\<Gamma>'\n\ngoal (1 subgoal):\n 1. \\<And>h.\n       h \\<Turnstile> \\<Gamma> \\<Longrightarrow>\n       \\<Gamma>' \\<Longrightarrow>\\<^sub>t \\<Gamma>''", "unfolding WEAKEN_HNR_POST_def"], ["proof (prove)\nusing this:\n  (\\<exists>h. h \\<Turnstile> \\<Gamma>) \\<longrightarrow>\n  (\\<Gamma>' \\<Longrightarrow>\\<^sub>t \\<Gamma>'')\n\ngoal (1 subgoal):\n 1. \\<And>h.\n       h \\<Turnstile> \\<Gamma> \\<Longrightarrow>\n       \\<Gamma>' \\<Longrightarrow>\\<^sub>t \\<Gamma>''", "by blast"], ["", "lemma weaken_hnr_post_triv: \"WEAKEN_HNR_POST \\<Gamma> P P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WEAKEN_HNR_POST \\<Gamma> P P", "unfolding WEAKEN_HNR_POST_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>h. h \\<Turnstile> \\<Gamma>) \\<longrightarrow>\n    (P \\<Longrightarrow>\\<^sub>t P)", "by sep_auto"], ["", "lemma weaken_hnr_post:\n  \"\\<lbrakk>WEAKEN_HNR_POST \\<Gamma> P P'; WEAKEN_HNR_POST \\<Gamma>' Q Q'\\<rbrakk> \\<Longrightarrow> WEAKEN_HNR_POST (\\<Gamma>*\\<Gamma>') (P*Q) (P'*Q')\"\n  \"WEAKEN_HNR_POST (hn_ctxt R x y) (hn_ctxt R x y) (hn_ctxt R x y)\"\n  \"WEAKEN_HNR_POST (hn_ctxt R x y) (hn_invalid R x y) (hn_ctxt (\\<lambda>_ _. true) x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>WEAKEN_HNR_POST \\<Gamma> P P';\n      WEAKEN_HNR_POST \\<Gamma>' Q Q'\\<rbrakk>\n     \\<Longrightarrow> WEAKEN_HNR_POST (\\<Gamma> * \\<Gamma>') (P * Q)\n                        (P' * Q')) &&&\n    WEAKEN_HNR_POST (hn_ctxt R x y) (hn_ctxt R x y) (hn_ctxt R x y) &&&\n    WEAKEN_HNR_POST (hn_ctxt R x y) (hn_invalid R x y)\n     (hn_ctxt (\\<lambda>_ _. true) x y)", "proof (goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>WEAKEN_HNR_POST \\<Gamma> P P';\n     WEAKEN_HNR_POST \\<Gamma>' Q Q'\\<rbrakk>\n    \\<Longrightarrow> WEAKEN_HNR_POST (\\<Gamma> * \\<Gamma>') (P * Q)\n                       (P' * Q')\n 2. WEAKEN_HNR_POST (hn_ctxt R x y) (hn_ctxt R x y) (hn_ctxt R x y)\n 3. WEAKEN_HNR_POST (hn_ctxt R x y) (hn_invalid R x y)\n     (hn_ctxt (\\<lambda>_ _. true) x y)", "case 1"], ["proof (state)\nthis:\n  WEAKEN_HNR_POST \\<Gamma> P P'\n  WEAKEN_HNR_POST \\<Gamma>' Q Q'\n\ngoal (3 subgoals):\n 1. \\<lbrakk>WEAKEN_HNR_POST \\<Gamma> P P';\n     WEAKEN_HNR_POST \\<Gamma>' Q Q'\\<rbrakk>\n    \\<Longrightarrow> WEAKEN_HNR_POST (\\<Gamma> * \\<Gamma>') (P * Q)\n                       (P' * Q')\n 2. WEAKEN_HNR_POST (hn_ctxt R x y) (hn_ctxt R x y) (hn_ctxt R x y)\n 3. WEAKEN_HNR_POST (hn_ctxt R x y) (hn_invalid R x y)\n     (hn_ctxt (\\<lambda>_ _. true) x y)", "thus ?case"], ["proof (prove)\nusing this:\n  WEAKEN_HNR_POST \\<Gamma> P P'\n  WEAKEN_HNR_POST \\<Gamma>' Q Q'\n\ngoal (1 subgoal):\n 1. WEAKEN_HNR_POST (\\<Gamma> * \\<Gamma>') (P * Q) (P' * Q')", "unfolding WEAKEN_HNR_POST_def"], ["proof (prove)\nusing this:\n  (\\<exists>h. h \\<Turnstile> \\<Gamma>) \\<longrightarrow>\n  (P' \\<Longrightarrow>\\<^sub>t P)\n  (\\<exists>h. h \\<Turnstile> \\<Gamma>') \\<longrightarrow>\n  (Q' \\<Longrightarrow>\\<^sub>t Q)\n\ngoal (1 subgoal):\n 1. (\\<exists>h. h \\<Turnstile> \\<Gamma> * \\<Gamma>') \\<longrightarrow>\n    (P' * Q' \\<Longrightarrow>\\<^sub>t P * Q)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(\\<exists>a b.\n                    (a, b) \\<Turnstile> \\<Gamma>) \\<longrightarrow>\n                (P' \\<Longrightarrow>\\<^sub>t P);\n        (\\<exists>a b. (a, b) \\<Turnstile> \\<Gamma>') \\<longrightarrow>\n        (Q' \\<Longrightarrow>\\<^sub>t Q);\n        (a, b) \\<Turnstile> \\<Gamma> * \\<Gamma>'\\<rbrakk>\n       \\<Longrightarrow> P' * Q' \\<Longrightarrow>\\<^sub>t P * Q", "apply (rule entt_star_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>(\\<exists>a b.\n                    (a, b) \\<Turnstile> \\<Gamma>) \\<longrightarrow>\n                (P' \\<Longrightarrow>\\<^sub>t P);\n        (\\<exists>a b. (a, b) \\<Turnstile> \\<Gamma>') \\<longrightarrow>\n        (Q' \\<Longrightarrow>\\<^sub>t Q);\n        (a, b) \\<Turnstile> \\<Gamma> * \\<Gamma>'\\<rbrakk>\n       \\<Longrightarrow> P' \\<Longrightarrow>\\<^sub>t P\n 2. \\<And>a b.\n       \\<lbrakk>(\\<exists>a b.\n                    (a, b) \\<Turnstile> \\<Gamma>) \\<longrightarrow>\n                (P' \\<Longrightarrow>\\<^sub>t P);\n        (\\<exists>a b. (a, b) \\<Turnstile> \\<Gamma>') \\<longrightarrow>\n        (Q' \\<Longrightarrow>\\<^sub>t Q);\n        (a, b) \\<Turnstile> \\<Gamma> * \\<Gamma>'\\<rbrakk>\n       \\<Longrightarrow> Q' \\<Longrightarrow>\\<^sub>t Q", "by (auto simp: mod_star_conv)"], ["proof (state)\nthis:\n  WEAKEN_HNR_POST (\\<Gamma> * \\<Gamma>') (P * Q) (P' * Q')\n\ngoal (2 subgoals):\n 1. WEAKEN_HNR_POST (hn_ctxt R x y) (hn_ctxt R x y) (hn_ctxt R x y)\n 2. WEAKEN_HNR_POST (hn_ctxt R x y) (hn_invalid R x y)\n     (hn_ctxt (\\<lambda>_ _. true) x y)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. WEAKEN_HNR_POST (hn_ctxt R x y) (hn_ctxt R x y) (hn_ctxt R x y)\n 2. WEAKEN_HNR_POST (hn_ctxt R x y) (hn_invalid R x y)\n     (hn_ctxt (\\<lambda>_ _. true) x y)", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. WEAKEN_HNR_POST (hn_ctxt R x y) (hn_ctxt R x y) (hn_ctxt R x y)\n 2. WEAKEN_HNR_POST (hn_ctxt R x y) (hn_invalid R x y)\n     (hn_ctxt (\\<lambda>_ _. true) x y)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. WEAKEN_HNR_POST (hn_ctxt R x y) (hn_ctxt R x y) (hn_ctxt R x y)", "by (rule weaken_hnr_post_triv)"], ["proof (state)\nthis:\n  WEAKEN_HNR_POST (hn_ctxt R x y) (hn_ctxt R x y) (hn_ctxt R x y)\n\ngoal (1 subgoal):\n 1. WEAKEN_HNR_POST (hn_ctxt R x y) (hn_invalid R x y)\n     (hn_ctxt (\\<lambda>_ _. true) x y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. WEAKEN_HNR_POST (hn_ctxt R x y) (hn_invalid R x y)\n     (hn_ctxt (\\<lambda>_ _. true) x y)", "case 3"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. WEAKEN_HNR_POST (hn_ctxt R x y) (hn_invalid R x y)\n     (hn_ctxt (\\<lambda>_ _. true) x y)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. WEAKEN_HNR_POST (hn_ctxt R x y) (hn_invalid R x y)\n     (hn_ctxt (\\<lambda>_ _. true) x y)", "unfolding WEAKEN_HNR_POST_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>h. h \\<Turnstile> hn_ctxt R x y) \\<longrightarrow>\n    (hn_ctxt (\\<lambda>_ _. true) x y \\<Longrightarrow>\\<^sub>t\n     hn_invalid R x y)", "by (sep_auto simp: invalid_assn_def hn_ctxt_def)"], ["proof (state)\nthis:\n  WEAKEN_HNR_POST (hn_ctxt R x y) (hn_invalid R x y)\n   (hn_ctxt (\\<lambda>_ _. true) x y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reorder_enttI:\n  assumes \"A*true = C*true\"\n  assumes \"B*true = D*true\"\n  shows \"(A\\<Longrightarrow>\\<^sub>tB) \\<equiv> (C\\<Longrightarrow>\\<^sub>tD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<Longrightarrow>\\<^sub>t B \\<equiv> C \\<Longrightarrow>\\<^sub>t D", "apply (intro eq_reflection)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<Longrightarrow>\\<^sub>t B) = (C \\<Longrightarrow>\\<^sub>t D)", "unfolding entt_def_true"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A * true \\<Longrightarrow>\\<^sub>A B * true) =\n    (C * true \\<Longrightarrow>\\<^sub>A D * true)", "by (simp add: assms)"], ["", "lemma merge_sat1: \"(A\\<or>\\<^sub>AA' \\<Longrightarrow>\\<^sub>t Am) \\<Longrightarrow> (A\\<or>\\<^sub>AAm \\<Longrightarrow>\\<^sub>t Am)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<or>\\<^sub>A A' \\<Longrightarrow>\\<^sub>t Am \\<Longrightarrow>\n    A \\<or>\\<^sub>A Am \\<Longrightarrow>\\<^sub>t Am", "using entt_disjD1 entt_disjE"], ["proof (prove)\nusing this:\n  ?A \\<or>\\<^sub>A ?B \\<Longrightarrow>\\<^sub>t ?C \\<Longrightarrow>\n  ?A \\<Longrightarrow>\\<^sub>t ?C\n  \\<lbrakk>?A \\<Longrightarrow>\\<^sub>t ?M;\n   ?B \\<Longrightarrow>\\<^sub>t ?M\\<rbrakk>\n  \\<Longrightarrow> ?A \\<or>\\<^sub>A ?B \\<Longrightarrow>\\<^sub>t ?M\n\ngoal (1 subgoal):\n 1. A \\<or>\\<^sub>A A' \\<Longrightarrow>\\<^sub>t Am \\<Longrightarrow>\n    A \\<or>\\<^sub>A Am \\<Longrightarrow>\\<^sub>t Am", "by blast"], ["", "lemma merge_sat2: \"(A\\<or>\\<^sub>AA' \\<Longrightarrow>\\<^sub>t Am) \\<Longrightarrow> (Am\\<or>\\<^sub>AA' \\<Longrightarrow>\\<^sub>t Am)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<or>\\<^sub>A A' \\<Longrightarrow>\\<^sub>t Am \\<Longrightarrow>\n    Am \\<or>\\<^sub>A A' \\<Longrightarrow>\\<^sub>t Am", "using entt_disjD2 entt_disjE"], ["proof (prove)\nusing this:\n  ?A \\<or>\\<^sub>A ?B \\<Longrightarrow>\\<^sub>t ?C \\<Longrightarrow>\n  ?B \\<Longrightarrow>\\<^sub>t ?C\n  \\<lbrakk>?A \\<Longrightarrow>\\<^sub>t ?M;\n   ?B \\<Longrightarrow>\\<^sub>t ?M\\<rbrakk>\n  \\<Longrightarrow> ?A \\<or>\\<^sub>A ?B \\<Longrightarrow>\\<^sub>t ?M\n\ngoal (1 subgoal):\n 1. A \\<or>\\<^sub>A A' \\<Longrightarrow>\\<^sub>t Am \\<Longrightarrow>\n    Am \\<or>\\<^sub>A A' \\<Longrightarrow>\\<^sub>t Am", "by blast"], ["", "ML \\<open>\nsignature SEPREF_FRAME = sig\n\n\n  (* Check if subgoal is a frame obligation *)\n  (*val is_frame : term -> bool *)\n  (* Check if subgoal is a merge obligation *)\n  val is_merge: term -> bool\n  (* Perform frame inference *)\n  val frame_tac: (Proof.context -> tactic') -> Proof.context -> tactic'\n  (* Perform merging *)\n  val merge_tac: (Proof.context -> tactic') -> Proof.context -> tactic'\n\n  val frame_step_tac: (Proof.context -> tactic') -> bool -> Proof.context -> tactic'\n\n  (* Reorder frame *)\n  val prepare_frame_tac : Proof.context -> tactic'\n  (* Solve a RECOVER_PURE goal, inserting constraints as necessary *)\n  val recover_pure_tac: Proof.context -> tactic'\n\n  (* Split precondition of hnr-goal into frame and arguments *)\n  val align_goal_tac: Proof.context -> tactic'\n  (* Normalize goal's precondition *)\n  val norm_goal_pre_tac: Proof.context -> tactic'\n  (* Rearrange precondition of hnr-term according to parameter order, normalize all relations *)\n  val align_rl_conv: Proof.context -> conv\n\n  (* Convert hn_invalid to \\<lambda>_ _. true in postcondition of hnr-goal. Makes proving the goal easier.*)\n  val weaken_post_tac: Proof.context -> tactic'\n\n  val add_normrel_eq : thm -> Context.generic -> Context.generic\n  val del_normrel_eq : thm -> Context.generic -> Context.generic\n  val get_normrel_eqs : Proof.context -> thm list\n\n  val cfg_debug: bool Config.T\n\n  val setup: theory -> theory\nend\n\n\nstructure Sepref_Frame : SEPREF_FRAME = struct\n\n  val cfg_debug = \n    Attrib.setup_config_bool @{binding sepref_debug_frame} (K false)\n\n  val DCONVERSION = Sepref_Debugging.DBG_CONVERSION cfg_debug\n  val dbg_msg_tac = Sepref_Debugging.dbg_msg_tac cfg_debug\n\n\n  structure normrel_eqs = Named_Thms (\n    val name = @{binding sepref_frame_normrel_eqs}\n    val description = \"Equations to normalize relations for frame matching\"\n  )\n\n  val add_normrel_eq = normrel_eqs.add_thm\n  val del_normrel_eq = normrel_eqs.del_thm\n  val get_normrel_eqs = normrel_eqs.get\n\n  val mk_entailst = HOLogic.mk_binrel @{const_name \"entailst\"}\n\n\n  local\n    open Sepref_Basic Refine_Util Conv\n  \n    fun assn_ord p = case apply2 dest_hn_ctxt_opt p of\n        (NONE,NONE) => EQUAL\n      | (SOME _, NONE) => LESS\n      | (NONE, SOME _) => GREATER\n      | (SOME (_,a,_), SOME (_,a',_)) => Term_Ord.fast_term_ord (a,a')\n\n  in\n    fun reorder_ctxt_conv ctxt ct = let\n      val cert = Thm.cterm_of ctxt\n\n      val new_ct = Thm.term_of ct \n        |> strip_star\n        |> sort assn_ord\n        |> list_star\n        |> cert\n\n      val thm = Goal.prove_internal ctxt [] (mk_cequals (ct,new_ct)) \n        (fn _ => simp_tac \n          (put_simpset HOL_basic_ss ctxt addsimps @{thms star_aci}) 1)\n\n    in\n      thm\n    end\n  \n    fun prepare_fi_conv ctxt ct = case Thm.term_of ct of\n      @{mpat \"?P \\<Longrightarrow>\\<^sub>t ?Q\"} => let\n        val cert = Thm.cterm_of ctxt\n  \n        (* Build table from abs-vars to ctxt *)\n        val (Qm, Qum) = strip_star Q |> filter_out is_true |> List.partition is_hn_ctxt\n\n        val Qtab = (\n          Qm |> map (fn x => (#2 (dest_hn_ctxt x),(NONE,x))) \n          |> Termtab.make\n        ) handle\n            e as (Termtab.DUP _) => (\n              tracing (\"Dup heap: \" ^ @{make_string} ct); raise e)\n        \n        (* Go over entries in P and try to find a partner *)\n        val (Qtab,Pum) = fold (fn a => fn (Qtab,Pum) => \n          case dest_hn_ctxt_opt a of\n            NONE => (Qtab,a::Pum)\n          | SOME (_,p,_) => ( case Termtab.lookup Qtab p of\n              SOME (NONE,tg) => (Termtab.update (p,(SOME a,tg)) Qtab, Pum)\n            | _ => (Qtab,a::Pum)\n            )\n        ) (strip_star P) (Qtab,[])\n\n        val Pum = filter_out is_true Pum\n\n        (* Read out information from Qtab *)\n        val (pairs,Qum2) = Termtab.dest Qtab |> map #2 \n          |> List.partition (is_some o #1)\n          |> apfst (map (apfst the))\n          |> apsnd (map #2)\n  \n        (* Build reordered terms: P' = fst pairs * Pum, Q' = snd pairs * (Qum2*Qum) *)\n        val P' = mk_star (list_star (map fst pairs), list_star Pum)\n        val Q' = mk_star (list_star (map snd pairs), list_star (Qum2@Qum))\n        \n        val new_ct = mk_entailst (P', Q') |> cert\n  \n        val msg_tac = dbg_msg_tac (Sepref_Debugging.msg_allgoals \"Solving frame permutation\") ctxt 1\n        val tac = msg_tac THEN ALLGOALS (resolve_tac ctxt @{thms reorder_enttI}) THEN star_permute_tac ctxt\n\n        val thm = Goal.prove_internal ctxt [] (mk_cequals (ct,new_ct)) (fn _ => tac)\n  \n      in \n        thm\n      end\n    | _ => no_conv ct\n  \n  end\n\n  fun is_merge @{mpat \"Trueprop (_ \\<or>\\<^sub>A _ \\<Longrightarrow>\\<^sub>t _)\"} = true | is_merge _ = false\n  fun is_gen_frame @{mpat \"Trueprop (_ \\<Longrightarrow>\\<^sub>t _)\"} = true | is_gen_frame _ = false\n\n\n  fun prepare_frame_tac ctxt = let\n    open Refine_Util Conv\n    val frame_ss = put_simpset HOL_basic_ss ctxt addsimps \n      @{thms mult_1_right[where 'a=assn] mult_1_left[where 'a=assn]}\n  in\n    CONVERSION Thm.eta_conversion THEN'\n    (*CONCL_COND' is_frame THEN'*)\n    simp_tac frame_ss THEN'\n    CONVERSION (HOL_concl_conv (fn _ => prepare_fi_conv ctxt) ctxt)\n  end    \n\n\n  local\n    fun wrap_side_tac side_tac dbg tac = tac THEN_ALL_NEW_FWD (\n      CONCL_COND' is_gen_frame \n      ORELSE' (if dbg then TRY_SOLVED' else SOLVED') side_tac\n    )\n  in  \n    fun frame_step_tac side_tac dbg ctxt = let\n      open Refine_Util Conv\n\n      (* Constraint solving is built-in *)\n      val side_tac = Sepref_Constraints.constraint_tac ctxt ORELSE' side_tac ctxt\n\n      val frame_thms = @{thms frame_thms} @\n        Named_Theorems_Rev.get ctxt @{named_theorems_rev sepref_frame_match_rules} \n      val merge_thms = @{thms merge_thms} @\n        Named_Theorems.get ctxt @{named_theorems sepref_frame_merge_rules}\n      val ss = put_simpset HOL_basic_ss ctxt addsimps normrel_eqs.get ctxt\n      fun frame_thm_tac dbg = wrap_side_tac side_tac dbg (resolve_tac ctxt frame_thms)\n      fun merge_thm_tac dbg = wrap_side_tac side_tac dbg (resolve_tac ctxt merge_thms)\n  \n      fun thm_tac dbg = CONCL_COND' is_merge THEN_ELSE' (merge_thm_tac dbg, frame_thm_tac dbg)\n    in\n      full_simp_tac ss THEN' thm_tac dbg\n    end\n  end  \n\n  fun frame_loop_tac side_tac ctxt = let\n\n  in\n    TRY o (\n      REPEAT_ALL_NEW (DETERM o frame_step_tac side_tac false ctxt)\n    )\n  end\n\n\n  fun frame_tac side_tac ctxt = let\n    open Refine_Util Conv\n    val frame_rem_thms = @{thms frame_rem_thms}\n      @ Named_Theorems_Rev.get ctxt @{named_theorems_rev sepref_frame_rem_rules}\n    val solve_remainder_tac = TRY o REPEAT_ALL_NEW (DETERM o resolve_tac ctxt frame_rem_thms)\n  in\n    (prepare_frame_tac ctxt\n      THEN' resolve_tac ctxt @{thms ent_star_mono entt_star_mono})\n    THEN_ALL_NEW_LIST [\n      frame_loop_tac side_tac ctxt,\n      solve_remainder_tac\n    ]  \n  end\n\n  fun merge_tac side_tac ctxt = let\n    open Refine_Util Conv\n    val merge_conv = arg1_conv (binop_conv (reorder_ctxt_conv ctxt))\n  in\n    CONVERSION Thm.eta_conversion THEN'\n    CONCL_COND' is_merge THEN'\n    simp_tac (put_simpset HOL_basic_ss ctxt addsimps @{thms star_aci}) THEN'\n    CONVERSION (HOL_concl_conv (fn _ => merge_conv) ctxt) THEN'\n    frame_loop_tac side_tac ctxt\n  end\n\n  val setup = normrel_eqs.setup\n\n  local\n    open Sepref_Basic\n    fun is_invalid @{mpat \"hn_invalid _ _ _ :: assn\"} = true | is_invalid _ = false\n    fun contains_invalid @{mpat \"Trueprop (RECOVER_PURE ?Q _)\"} = exists is_invalid (strip_star Q)\n      | contains_invalid _ = false\n\n  in\n    fun recover_pure_tac ctxt = \n      CONCL_COND' contains_invalid THEN_ELSE' (\n        REPEAT_ALL_NEW (DETERM o (resolve_tac ctxt @{thms recover_pure} ORELSE' Sepref_Constraints.constraint_tac ctxt)),\n        resolve_tac ctxt @{thms recover_pure_triv}\n      )\n  end\n\n  local\n    open Sepref_Basic Refine_Util\n    datatype cte = Other of term | Hn of term * term * term\n    fun dest_ctxt_elem @{mpat \"hn_ctxt ?R ?a ?c\"} = Hn (R,a,c)\n      | dest_ctxt_elem t = Other t\n\n    fun mk_ctxt_elem (Other t) = t \n      | mk_ctxt_elem (Hn (R,a,c)) = @{mk_term \"hn_ctxt ?R ?a ?c\"}\n\n    fun match x (Hn (_,y,_)) = x aconv y\n      | match _ _ = false\n\n    fun dest_with_frame (*ctxt*) _ t = let\n      val (P,c,Q,R,a) = dest_hn_refine t\n  \n      val (_,(_,args)) = dest_hnr_absfun a\n      val pre_ctes = strip_star P |> map dest_ctxt_elem\n  \n      val (pre_args,frame) = \n        (case split_matching match args pre_ctes of\n            NONE => raise TERM(\"align_conv: Could not match all arguments\",[P,a])\n          | SOME x => x)\n\n    in\n      ((frame,pre_args),c,Q,R,a)\n    end\n  \n    fun align_goal_conv_aux ctxt t = let\n      val ((frame,pre_args),c,Q,R,a) = dest_with_frame ctxt t\n      val P' = apply2 (list_star o map mk_ctxt_elem) (frame,pre_args) |> mk_star\n      val t' = mk_hn_refine (P',c,Q,R,a)\n    in t' end  \n\n    fun align_rl_conv_aux ctxt t = let\n      val ((frame,pre_args),c,Q,R,a) = dest_with_frame ctxt t\n\n      val _ = frame = [] orelse raise TERM (\"align_rl_conv: Extra preconditions in rule\",[t,list_star (map mk_ctxt_elem frame)])\n\n      val P' = list_star (map mk_ctxt_elem pre_args)\n      val t' = mk_hn_refine (P',c,Q,R,a)\n    in t' end  \n\n\n    fun normrel_conv ctxt = let\n      val ss = put_simpset HOL_basic_ss ctxt addsimps normrel_eqs.get ctxt\n    in\n      Simplifier.rewrite ss\n    end\n\n  in\n    fun align_goal_conv ctxt = f_tac_conv ctxt (align_goal_conv_aux ctxt) (star_permute_tac ctxt)\n\n    fun norm_goal_pre_conv ctxt = let\n      open Conv\n      val nr_conv = normrel_conv ctxt\n    in\n      HOL_concl_conv (fn _ => hn_refine_conv nr_conv all_conv all_conv all_conv all_conv) ctxt\n    end  \n\n    fun norm_goal_pre_tac ctxt = CONVERSION (norm_goal_pre_conv ctxt)\n\n    fun align_rl_conv ctxt = let\n      open Conv\n      val nr_conv = normrel_conv ctxt\n    in\n      HOL_concl_conv (fn ctxt => f_tac_conv ctxt (align_rl_conv_aux ctxt) (star_permute_tac ctxt)) ctxt\n      then_conv HOL_concl_conv (K (hn_refine_conv nr_conv all_conv nr_conv nr_conv all_conv)) ctxt\n    end\n\n    fun align_goal_tac ctxt = \n      CONCL_COND' is_hn_refine_concl \n      THEN' DCONVERSION ctxt (HOL_concl_conv align_goal_conv ctxt)\n  end\n\n\n  fun weaken_post_tac ctxt = TRADE (fn ctxt =>\n    resolve_tac ctxt @{thms weaken_hnr_postI} \n    THEN' SOLVED' (REPEAT_ALL_NEW (DETERM o resolve_tac ctxt @{thms weaken_hnr_post weaken_hnr_post_triv}))\n  ) ctxt\n\nend\n\\<close>"], ["", "setup Sepref_Frame.setup"], ["", "method_setup weaken_hnr_post = \\<open>Scan.succeed (fn ctxt => SIMPLE_METHOD' (Sepref_Frame.weaken_post_tac ctxt))\\<close>\n  \\<open>Convert \"hn_invalid\" to \"hn_ctxt (\\<lambda>_ _. true)\" in postcondition of hn_refine goal\\<close>"], ["", "(* TODO: Improper, modifies all h\\<Turnstile>_ premises that happen to be there. Use tagging to protect! *)"], ["", "method extract_hnr_invalids = (\n  rule hn_refine_preI,\n  ((drule mod_starD hn_invalidI | elim conjE exE)+)?\n) \\<comment> \\<open>Extract \\<open>hn_invalid _ _ _ = true\\<close> preconditions from \\<open>hn_refine\\<close> goal.\\<close>"], ["", "lemmas [sepref_frame_normrel_eqs] = the_pure_pure pure_the_pure"], ["", "end"]]}