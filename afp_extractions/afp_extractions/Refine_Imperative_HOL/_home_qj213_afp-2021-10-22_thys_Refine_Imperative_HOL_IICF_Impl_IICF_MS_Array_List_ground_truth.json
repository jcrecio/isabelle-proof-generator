{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/IICF/Impl/IICF_MS_Array_List.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemma is_ms_array_list_prec[safe_constraint_rules]: \"precise (is_ms_array_list ms)\"", "lemma marl_empty_sz_rule[sep_heap_rules]: \"< emp > marl_empty_sz N <is_ms_array_list N []>\"", "lemma marl_append_rule[sep_heap_rules]: \"length l < N \\<Longrightarrow>\n    < is_ms_array_list N l a > \n      marl_append a x \n    <\\<lambda>a. is_ms_array_list N (l@[x]) a >\\<^sub>t\"", "lemma marl_length_rule[sep_heap_rules]: \"\n    <is_ms_array_list N l a> \n      marl_length a\n    <\\<lambda>r. is_ms_array_list N l a * \\<up>(r=length l)>\"", "lemma marl_is_empty_rule[sep_heap_rules]: \"\n    <is_ms_array_list N l a> \n      marl_is_empty a\n    <\\<lambda>r. is_ms_array_list N l a * \\<up>(r\\<longleftrightarrow>(l=[]))>\"", "lemma marl_last_rule[sep_heap_rules]: \"\n    l\\<noteq>[] \\<Longrightarrow>\n    <is_ms_array_list N l a> \n      marl_last a\n    <\\<lambda>r. is_ms_array_list N l a * \\<up>(r=last l)>\"", "lemma marl_butlast_rule[sep_heap_rules]: \"\n    l\\<noteq>[] \\<Longrightarrow>\n    <is_ms_array_list N l a> \n      marl_butlast a\n    <is_ms_array_list N (butlast l)>\\<^sub>t\"", "lemma marl_get_rule[sep_heap_rules]: \"\n    i<length l \\<Longrightarrow>\n    <is_ms_array_list N l a> \n      marl_get a i\n    <\\<lambda>r. is_ms_array_list N l a * \\<up>(r=l!i)>\"", "lemma marl_set_rule[sep_heap_rules]: \"\n    i<length l \\<Longrightarrow>\n    <is_ms_array_list N l a> \n      marl_set a i x\n    <is_ms_array_list N (l[i:=x])>\"", "lemmas [safe_constraint_rules] = CN_FALSEI[of is_pure \"marl_assn N A\" for N A]", "lemma [def_pat_rules]: \"op_marl_empty_sz$N \\<equiv> UNPROTECT (op_marl_empty_sz N)\"", "lemma marl_fold_custom_empty_sz: \n    \"op_list_empty = op_marl_empty_sz N\"\n    \"mop_list_empty = RETURN (op_marl_empty_sz N)\"\n    \"[] = op_marl_empty_sz N\"", "lemma marl_empty_hnr_aux: \"(uncurry0 (marl_empty_sz N), uncurry0 (RETURN op_list_empty)) \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a is_ms_array_list N\"", "lemmas marl_empty_hnr = marl_empty_hnr_aux[FCOMP op_list_empty.fref[of \"the_pure A\" for A]]", "lemmas marl_empty_hnr_mop = marl_empty_hnr[FCOMP mk_mop_rl0_np[OF mop_list_empty_alt]]", "lemma marl_empty_sz_hnr[sepref_fr_rules]:\n    \"(uncurry0 (marl_empty_sz N), uncurry0 (RETURN (PR_CONST (op_marl_empty_sz N)))) \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a marl_assn N A\"", "lemma marl_append_hnr_aux: \"(uncurry marl_append,uncurry (RETURN oo op_list_append)) \\<in> [\\<lambda>(l,_). length l<N]\\<^sub>a ((is_ms_array_list N)\\<^sup>d *\\<^sub>a id_assn\\<^sup>k) \\<rightarrow> is_ms_array_list N\"", "lemmas marl_append_hnr[sepref_fr_rules] = marl_append_hnr_aux[FCOMP op_list_append.fref]", "lemmas marl_append_hnr_mop[sepref_fr_rules] = marl_append_hnr[FCOMP mk_mop_rl2_np[OF mop_list_append_alt]]", "lemma marl_length_hnr_aux: \"(marl_length,RETURN o op_list_length) \\<in> (is_ms_array_list N)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\"", "lemmas marl_length_hnr[sepref_fr_rules] = marl_length_hnr_aux[FCOMP op_list_length.fref[of \"the_pure A\" for A]]", "lemmas marl_length_hnr_mop[sepref_fr_rules] = marl_length_hnr[FCOMP mk_mop_rl1_np[OF mop_list_length_alt]]", "lemma marl_is_empty_hnr_aux: \"(marl_is_empty,RETURN o op_list_is_empty) \\<in> (is_ms_array_list N)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\"", "lemmas marl_is_empty_hnr[sepref_fr_rules] = marl_is_empty_hnr_aux[FCOMP op_list_is_empty.fref[of \"the_pure A\" for A]]", "lemmas marl_is_empty_hnr_mop[sepref_fr_rules] = marl_is_empty_hnr[FCOMP mk_mop_rl1_np[OF mop_list_is_empty_alt]]", "lemma marl_last_hnr_aux: \"(marl_last,RETURN o op_list_last) \\<in> [\\<lambda>x. x\\<noteq>[]]\\<^sub>a (is_ms_array_list N)\\<^sup>k \\<rightarrow> id_assn\"", "lemmas marl_last_hnr[sepref_fr_rules] = marl_last_hnr_aux[FCOMP op_list_last.fref]", "lemmas marl_last_hnr_mop[sepref_fr_rules] = marl_last_hnr[FCOMP mk_mop_rl1[OF mop_list_last_alt]]", "lemma marl_butlast_hnr_aux: \"(marl_butlast,RETURN o op_list_butlast) \\<in> [\\<lambda>x. x\\<noteq>[]]\\<^sub>a (is_ms_array_list N)\\<^sup>d \\<rightarrow> (is_ms_array_list N)\"", "lemmas marl_butlast_hnr[sepref_fr_rules] = marl_butlast_hnr_aux[FCOMP op_list_butlast.fref[of \"the_pure A\" for A]]", "lemmas marl_butlast_hnr_mop[sepref_fr_rules] = marl_butlast_hnr[FCOMP mk_mop_rl1[OF mop_list_butlast_alt]]", "lemma marl_get_hnr_aux: \"(uncurry marl_get,uncurry (RETURN oo op_list_get)) \\<in> [\\<lambda>(l,i). i<length l]\\<^sub>a ((is_ms_array_list N)\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k) \\<rightarrow> id_assn\"", "lemmas marl_get_hnr[sepref_fr_rules] = marl_get_hnr_aux[FCOMP op_list_get.fref]", "lemmas marl_get_hnr_mop[sepref_fr_rules] = marl_get_hnr[FCOMP mk_mop_rl2[OF mop_list_get_alt]]", "lemma marl_set_hnr_aux: \"(uncurry2 marl_set,uncurry2 (RETURN ooo op_list_set)) \\<in> [\\<lambda>((l,i),_). i<length l]\\<^sub>a ((is_ms_array_list N)\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a id_assn\\<^sup>k) \\<rightarrow> (is_ms_array_list N)\"", "lemmas marl_set_hnr[sepref_fr_rules] = marl_set_hnr_aux[FCOMP op_list_set.fref]", "lemmas marl_set_hnr_mop[sepref_fr_rules] = marl_set_hnr[FCOMP mk_mop_rl3[OF mop_list_set_alt]]"], "translations": [["", "lemma is_ms_array_list_prec[safe_constraint_rules]: \"precise (is_ms_array_list ms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. precise (is_ms_array_list ms)", "unfolding is_ms_array_list_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. precise\n     (\\<lambda>l (a, n).\n         \\<exists>\\<^sub>Al'.\n            a \\<mapsto>\\<^sub>a l' *\n            \\<up>\n             (n \\<le> length l' \\<and> l = take n l' \\<and> ms = length l'))", "apply(rule preciseI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' h p F F'.\n       h \\<Turnstile>\n       (case p of\n        (aa, n) \\<Rightarrow>\n          \\<exists>\\<^sub>Al'.\n             aa \\<mapsto>\\<^sub>a l' *\n             \\<up>\n              (n \\<le> length l' \\<and>\n               a = take n l' \\<and> ms = length l')) *\n       F \\<and>\\<^sub>A\n       (case p of\n        (a, n) \\<Rightarrow>\n          \\<exists>\\<^sub>Al'.\n             a \\<mapsto>\\<^sub>a l' *\n             \\<up>\n              (n \\<le> length l' \\<and>\n               a' = take n l' \\<and> ms = length l')) *\n       F' \\<Longrightarrow>\n       a = a'", "apply(simp split: prod.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' h p F F' x1 x2.\n       \\<lbrakk>p = (x1, x2);\n        \\<exists>l' l'a.\n           h \\<Turnstile>\n           x1 \\<mapsto>\\<^sub>a l'a * F \\<and>\\<^sub>A\n           x1 \\<mapsto>\\<^sub>a l' * F' \\<and>\n           x2 \\<le> length l'a \\<and>\n           a = take x2 l'a \\<and>\n           ms = length l'a \\<and>\n           x2 \\<le> length l' \\<and>\n           a' = take x2 l' \\<and> ms = length l'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "using preciseD snga_prec"], ["proof (prove)\nusing this:\n  \\<lbrakk>precise ?R;\n   ?h \\<Turnstile> ?R ?a ?p * ?F \\<and>\\<^sub>A ?R ?a' ?p * ?F'\\<rbrakk>\n  \\<Longrightarrow> ?a = ?a'\n  precise (\\<lambda>x p. p \\<mapsto>\\<^sub>a x)\n\ngoal (1 subgoal):\n 1. \\<And>a a' h p F F' x1 x2.\n       \\<lbrakk>p = (x1, x2);\n        \\<exists>l' l'a.\n           h \\<Turnstile>\n           x1 \\<mapsto>\\<^sub>a l'a * F \\<and>\\<^sub>A\n           x1 \\<mapsto>\\<^sub>a l' * F' \\<and>\n           x2 \\<le> length l'a \\<and>\n           a = take x2 l'a \\<and>\n           ms = length l'a \\<and>\n           x2 \\<le> length l' \\<and>\n           a' = take x2 l' \\<and> ms = length l'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "by fastforce"], ["", "definition \"marl_empty_sz maxsize \\<equiv> do {\n    a \\<leftarrow> Array.new maxsize default;\n    return (a,0)\n  }\""], ["", "definition \"marl_append \\<equiv> \\<lambda>(a,n) x. do {\n      a \\<leftarrow> Array.upd n x a;\n      return (a,n+1)\n  }\""], ["", "definition marl_length :: \"'a::heap ms_array_list \\<Rightarrow> nat Heap\" where\n    \"marl_length \\<equiv> \\<lambda>(a,n). return (n)\""], ["", "definition marl_is_empty :: \"'a::heap ms_array_list \\<Rightarrow> bool Heap\" where\n    \"marl_is_empty \\<equiv> \\<lambda>(a,n). return (n=0)\""], ["", "definition marl_last :: \"'a::heap ms_array_list \\<Rightarrow> 'a Heap\" where\n    \"marl_last \\<equiv> \\<lambda>(a,n). do {\n      Array.nth a (n - 1)\n    }\""], ["", "definition marl_butlast :: \"'a::heap ms_array_list \\<Rightarrow> 'a ms_array_list Heap\" where\n    \"marl_butlast \\<equiv> \\<lambda>(a,n). do {\n      return (a,n - 1)\n    }\""], ["", "definition marl_get :: \"'a::heap ms_array_list \\<Rightarrow> nat \\<Rightarrow> 'a Heap\" where\n    \"marl_get \\<equiv> \\<lambda>(a,n) i. Array.nth a i\""], ["", "definition marl_set :: \"'a::heap ms_array_list \\<Rightarrow> nat \\<Rightarrow> 'a \\<Rightarrow> 'a ms_array_list Heap\" where\n    \"marl_set \\<equiv> \\<lambda>(a,n) i x. do { a \\<leftarrow> Array.upd i x a; return (a,n)}\""], ["", "lemma marl_empty_sz_rule[sep_heap_rules]: \"< emp > marl_empty_sz N <is_ms_array_list N []>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> marl_empty_sz N <is_ms_array_list N []>", "by (sep_auto simp: marl_empty_sz_def is_ms_array_list_def)"], ["", "lemma marl_append_rule[sep_heap_rules]: \"length l < N \\<Longrightarrow>\n    < is_ms_array_list N l a > \n      marl_append a x \n    <\\<lambda>a. is_ms_array_list N (l@[x]) a >\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length l < N \\<Longrightarrow>\n    <is_ms_array_list N l\n      a> marl_append a x <is_ms_array_list N (l @ [x])>\\<^sub>t", "by (sep_auto \n      simp: marl_append_def is_ms_array_list_def take_update_last \n      split: prod.splits)"], ["", "lemma marl_length_rule[sep_heap_rules]: \"\n    <is_ms_array_list N l a> \n      marl_length a\n    <\\<lambda>r. is_ms_array_list N l a * \\<up>(r=length l)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_ms_array_list N l a> marl_length a\n    <\\<lambda>r. is_ms_array_list N l a * \\<up> (r = length l)>", "by (sep_auto simp: marl_length_def is_ms_array_list_def)"], ["", "lemma marl_is_empty_rule[sep_heap_rules]: \"\n    <is_ms_array_list N l a> \n      marl_is_empty a\n    <\\<lambda>r. is_ms_array_list N l a * \\<up>(r\\<longleftrightarrow>(l=[]))>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_ms_array_list N l a> marl_is_empty a\n    <\\<lambda>r. is_ms_array_list N l a * \\<up> (r = (l = []))>", "by (sep_auto simp: marl_is_empty_def is_ms_array_list_def)"], ["", "lemma marl_last_rule[sep_heap_rules]: \"\n    l\\<noteq>[] \\<Longrightarrow>\n    <is_ms_array_list N l a> \n      marl_last a\n    <\\<lambda>r. is_ms_array_list N l a * \\<up>(r=last l)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    <is_ms_array_list N l a> marl_last a\n    <\\<lambda>r. is_ms_array_list N l a * \\<up> (r = last l)>", "by (sep_auto simp: marl_last_def is_ms_array_list_def last_take_nth_conv)"], ["", "lemma marl_butlast_rule[sep_heap_rules]: \"\n    l\\<noteq>[] \\<Longrightarrow>\n    <is_ms_array_list N l a> \n      marl_butlast a\n    <is_ms_array_list N (butlast l)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    <is_ms_array_list N l\n      a> marl_butlast a <is_ms_array_list N (butlast l)>\\<^sub>t", "by (sep_auto \n      split: prod.splits\n      simp: marl_butlast_def is_ms_array_list_def butlast_take)"], ["", "lemma marl_get_rule[sep_heap_rules]: \"\n    i<length l \\<Longrightarrow>\n    <is_ms_array_list N l a> \n      marl_get a i\n    <\\<lambda>r. is_ms_array_list N l a * \\<up>(r=l!i)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length l \\<Longrightarrow>\n    <is_ms_array_list N l a> marl_get a i\n    <\\<lambda>r. is_ms_array_list N l a * \\<up> (r = l ! i)>", "by (sep_auto simp: marl_get_def is_ms_array_list_def split: prod.split)"], ["", "lemma marl_set_rule[sep_heap_rules]: \"\n    i<length l \\<Longrightarrow>\n    <is_ms_array_list N l a> \n      marl_set a i x\n    <is_ms_array_list N (l[i:=x])>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length l \\<Longrightarrow>\n    <is_ms_array_list N l a> marl_set a i x <is_ms_array_list N (l[i := x])>", "by (sep_auto simp: marl_set_def is_ms_array_list_def split: prod.split)"], ["", "definition \"marl_assn N A \\<equiv> hr_comp (is_ms_array_list N) (\\<langle>the_pure A\\<rangle>list_rel)\""], ["", "lemmas [safe_constraint_rules] = CN_FALSEI[of is_pure \"marl_assn N A\" for N A]"], ["", "context \n  notes [fcomp_norm_unfold] = marl_assn_def[symmetric]\n  notes [intro!] = hfrefI hn_refineI[THEN hn_refine_preI]\n  notes [simp] = pure_def hn_ctxt_def invalid_assn_def\nbegin"], ["", "definition [simp]: \"op_marl_empty_sz (N::nat) \\<equiv> op_list_empty\""], ["", "context fixes N :: nat begin"], ["", "sepref_register \"PR_CONST (op_marl_empty_sz N)\""], ["", "end"], ["", "lemma [def_pat_rules]: \"op_marl_empty_sz$N \\<equiv> UNPROTECT (op_marl_empty_sz N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op_marl_empty_sz $ N \\<equiv> UNPROTECT (op_marl_empty_sz N)", "by simp"], ["", "lemma marl_fold_custom_empty_sz: \n    \"op_list_empty = op_marl_empty_sz N\"\n    \"mop_list_empty = RETURN (op_marl_empty_sz N)\"\n    \"[] = op_marl_empty_sz N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op_list_empty = op_marl_empty_sz N &&&\n    mop_list_empty = RETURN (op_marl_empty_sz N) &&& [] = op_marl_empty_sz N", "by auto"], ["", "lemma marl_empty_hnr_aux: \"(uncurry0 (marl_empty_sz N), uncurry0 (RETURN op_list_empty)) \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a is_ms_array_list N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 (marl_empty_sz N), uncurry0 (RETURN op_list_empty))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a is_ms_array_list N", "by sep_auto"], ["", "lemmas marl_empty_hnr = marl_empty_hnr_aux[FCOMP op_list_empty.fref[of \"the_pure A\" for A]]"], ["", "lemmas marl_empty_hnr_mop = marl_empty_hnr[FCOMP mk_mop_rl0_np[OF mop_list_empty_alt]]"], ["", "lemma marl_empty_sz_hnr[sepref_fr_rules]:\n    \"(uncurry0 (marl_empty_sz N), uncurry0 (RETURN (PR_CONST (op_marl_empty_sz N)))) \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a marl_assn N A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 (marl_empty_sz N),\n     uncurry0 (RETURN (PR_CONST (op_marl_empty_sz N))))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a marl_assn N A", "using marl_empty_hnr"], ["proof (prove)\nusing this:\n  (uncurry0 (marl_empty_sz ?N), uncurry0 (RETURN op_list_empty))\n  \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a marl_assn ?N ?A\n\ngoal (1 subgoal):\n 1. (uncurry0 (marl_empty_sz N),\n     uncurry0 (RETURN (PR_CONST (op_marl_empty_sz N))))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a marl_assn N A", "by simp"], ["", "lemma marl_append_hnr_aux: \"(uncurry marl_append,uncurry (RETURN oo op_list_append)) \\<in> [\\<lambda>(l,_). length l<N]\\<^sub>a ((is_ms_array_list N)\\<^sup>d *\\<^sub>a id_assn\\<^sup>k) \\<rightarrow> is_ms_array_list N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry marl_append, uncurry (RETURN \\<circ>\\<circ> op_list_append))\n    \\<in> [\\<lambda>(l, uu_).\n              length l\n              < N]\\<^sub>a (is_ms_array_list N)\\<^sup>d *\\<^sub>a\n                           id_assn\\<^sup>k \\<rightarrow> is_ms_array_list N", "by sep_auto"], ["", "lemmas marl_append_hnr[sepref_fr_rules] = marl_append_hnr_aux[FCOMP op_list_append.fref]"], ["", "lemmas marl_append_hnr_mop[sepref_fr_rules] = marl_append_hnr[FCOMP mk_mop_rl2_np[OF mop_list_append_alt]]"], ["", "lemma marl_length_hnr_aux: \"(marl_length,RETURN o op_list_length) \\<in> (is_ms_array_list N)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (marl_length, RETURN \\<circ> op_list_length)\n    \\<in> (is_ms_array_list N)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "by sep_auto"], ["", "lemmas marl_length_hnr[sepref_fr_rules] = marl_length_hnr_aux[FCOMP op_list_length.fref[of \"the_pure A\" for A]]"], ["", "lemmas marl_length_hnr_mop[sepref_fr_rules] = marl_length_hnr[FCOMP mk_mop_rl1_np[OF mop_list_length_alt]]"], ["", "lemma marl_is_empty_hnr_aux: \"(marl_is_empty,RETURN o op_list_is_empty) \\<in> (is_ms_array_list N)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (marl_is_empty, RETURN \\<circ> op_list_is_empty)\n    \\<in> (is_ms_array_list N)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "by sep_auto"], ["", "lemmas marl_is_empty_hnr[sepref_fr_rules] = marl_is_empty_hnr_aux[FCOMP op_list_is_empty.fref[of \"the_pure A\" for A]]"], ["", "lemmas marl_is_empty_hnr_mop[sepref_fr_rules] = marl_is_empty_hnr[FCOMP mk_mop_rl1_np[OF mop_list_is_empty_alt]]"], ["", "lemma marl_last_hnr_aux: \"(marl_last,RETURN o op_list_last) \\<in> [\\<lambda>x. x\\<noteq>[]]\\<^sub>a (is_ms_array_list N)\\<^sup>k \\<rightarrow> id_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (marl_last, RETURN \\<circ> op_list_last)\n    \\<in> [\\<lambda>x.\n              x \\<noteq>\n              []]\\<^sub>a (is_ms_array_list N)\\<^sup>k \\<rightarrow> id_assn", "by sep_auto"], ["", "lemmas marl_last_hnr[sepref_fr_rules] = marl_last_hnr_aux[FCOMP op_list_last.fref]"], ["", "lemmas marl_last_hnr_mop[sepref_fr_rules] = marl_last_hnr[FCOMP mk_mop_rl1[OF mop_list_last_alt]]"], ["", "lemma marl_butlast_hnr_aux: \"(marl_butlast,RETURN o op_list_butlast) \\<in> [\\<lambda>x. x\\<noteq>[]]\\<^sub>a (is_ms_array_list N)\\<^sup>d \\<rightarrow> (is_ms_array_list N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (marl_butlast, RETURN \\<circ> op_list_butlast)\n    \\<in> [\\<lambda>x.\n              x \\<noteq>\n              []]\\<^sub>a (is_ms_array_list\n                            N)\\<^sup>d \\<rightarrow> is_ms_array_list N", "by sep_auto"], ["", "lemmas marl_butlast_hnr[sepref_fr_rules] = marl_butlast_hnr_aux[FCOMP op_list_butlast.fref[of \"the_pure A\" for A]]"], ["", "lemmas marl_butlast_hnr_mop[sepref_fr_rules] = marl_butlast_hnr[FCOMP mk_mop_rl1[OF mop_list_butlast_alt]]"], ["", "lemma marl_get_hnr_aux: \"(uncurry marl_get,uncurry (RETURN oo op_list_get)) \\<in> [\\<lambda>(l,i). i<length l]\\<^sub>a ((is_ms_array_list N)\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k) \\<rightarrow> id_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry marl_get, uncurry (RETURN \\<circ>\\<circ> op_list_get))\n    \\<in> [\\<lambda>(l, i).\n              i < length\n                   l]\\<^sub>a (is_ms_array_list N)\\<^sup>k *\\<^sub>a\n                              nat_assn\\<^sup>k \\<rightarrow> id_assn", "by sep_auto"], ["", "lemmas marl_get_hnr[sepref_fr_rules] = marl_get_hnr_aux[FCOMP op_list_get.fref]"], ["", "lemmas marl_get_hnr_mop[sepref_fr_rules] = marl_get_hnr[FCOMP mk_mop_rl2[OF mop_list_get_alt]]"], ["", "lemma marl_set_hnr_aux: \"(uncurry2 marl_set,uncurry2 (RETURN ooo op_list_set)) \\<in> [\\<lambda>((l,i),_). i<length l]\\<^sub>a ((is_ms_array_list N)\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a id_assn\\<^sup>k) \\<rightarrow> (is_ms_array_list N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 marl_set, uncurry2 (RETURN \\<circ>\\<circ>\\<circ> op_list_set))\n    \\<in> [\\<lambda>((l, i), uu_).\n              i < length\n                   l]\\<^sub>a (is_ms_array_list N)\\<^sup>d *\\<^sub>a\n                              nat_assn\\<^sup>k *\\<^sub>a\n                              id_assn\\<^sup>k \\<rightarrow> is_ms_array_list\n                       N", "by sep_auto"], ["", "lemmas marl_set_hnr[sepref_fr_rules] = marl_set_hnr_aux[FCOMP op_list_set.fref]"], ["", "lemmas marl_set_hnr_mop[sepref_fr_rules] = marl_set_hnr[FCOMP mk_mop_rl3[OF mop_list_set_alt]]"], ["", "end"], ["", "context\n  fixes N :: nat\n  assumes N_sz: \"N>10\"\nbegin"], ["", "schematic_goal \"hn_refine (emp) (?c::?'c Heap) ?\\<Gamma>' ?R (do {\n  let x = op_marl_empty_sz N;\n  RETURN (x@[1::nat])\n})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine emp ?c ?\\<Gamma>' ?R\n     (let x = op_marl_empty_sz N in RETURN (x @ [1]))", "using N_sz"], ["proof (prove)\nusing this:\n  10 < N\n\ngoal (1 subgoal):\n 1. hn_refine emp ?c ?\\<Gamma>' ?R\n     (let x = op_marl_empty_sz N in RETURN (x @ [1]))", "by sepref"], ["", "end"], ["", "schematic_goal \"hn_refine (emp) (?c::?'c Heap) ?\\<Gamma>' ?R (do {\n  let x = op_list_empty;\n  RETURN (x@[1::nat])\n})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine emp ?c ?\\<Gamma>' ?R\n     (let x = op_list_empty in RETURN (x @ [1]))", "apply (subst marl_fold_custom_empty_sz[where N=10])"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine emp ?c ?\\<Gamma>' ?R\n     (let x = op_marl_empty_sz 10 in RETURN (x @ [1]))", "apply sepref"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}