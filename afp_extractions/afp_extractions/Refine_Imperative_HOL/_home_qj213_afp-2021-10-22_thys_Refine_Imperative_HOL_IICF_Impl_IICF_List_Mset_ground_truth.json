{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/IICF/Impl/IICF_List_Mset.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemma lms_empty_aref: \"([],op_mset_empty) \\<in> list_mset_rel\"", "lemma lms_is_empty_aref: \"(is_Nil,op_mset_is_empty) \\<in> list_mset_rel \\<rightarrow> bool_rel\"", "lemma lms_insert_aref: \"((#), op_mset_insert) \\<in> Id \\<rightarrow> list_mset_rel \\<rightarrow> list_mset_rel\"", "lemma lms_union_aref: \"((@), op_mset_plus) \\<in> list_mset_rel \\<rightarrow> list_mset_rel \\<rightarrow> list_mset_rel\"", "lemma lms_pick_aref: \"(\\<lambda>x#l \\<Rightarrow> RETURN (x,l), mop_mset_pick) \\<in> list_mset_rel \\<rightarrow> \\<langle>Id \\<times>\\<^sub>r list_mset_rel\\<rangle>nres_rel\"", "lemma lms_contains_aref: \"(list_contains, op_mset_contains) \\<in> Id \\<rightarrow> list_mset_rel \\<rightarrow> bool_rel\"", "lemma mset_list_remove1[simp]: \"mset (list_remove1 x l) = mset l - {#x#}\"", "lemma lms_remove_aref: \"(list_remove1, op_mset_delete) \\<in> Id \\<rightarrow> list_mset_rel \\<rightarrow> list_mset_rel\"", "lemma mset_list_count[simp]: \"list_count x ys = count (mset ys) x\"", "lemma lms_count_aref: \"(list_count, op_mset_count) \\<in> Id \\<rightarrow> list_mset_rel \\<rightarrow> nat_rel\"", "lemma list_remove_all_mset[simp]: \"mset (list_remove_all xs ys) = mset xs - mset ys\"", "lemma lms_minus_aref: \"(list_remove_all,op_mset_minus) \\<in> list_mset_rel \\<rightarrow> list_mset_rel \\<rightarrow> list_mset_rel\"", "lemma [safe_constraint_rules]: \"is_pure (list_mset_assn A)\"", "lemma lms_fold_custom_empty:\n    \"{#} = op_list_mset_empty\"\n    \"op_mset_empty = op_list_mset_empty\"", "lemmas [sepref_fr_rules] = lms_empty_hnr[folded op_list_mset_empty_def]", "lemma lms_pick_aref': \n    \"(\\<lambda>x#l \\<Rightarrow> return (x,l), mop_mset_pick) \\<in> (pure list_mset_rel)\\<^sup>k \\<rightarrow>\\<^sub>a prod_assn id_assn (pure list_mset_rel)\""], "translations": [["", "lemma lms_empty_aref: \"([],op_mset_empty) \\<in> list_mset_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([], op_mset_empty) \\<in> list_mset_rel", "unfolding list_mset_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([], op_mset_empty) \\<in> br mset (\\<lambda>_. True)", "by (auto simp: in_br_conv)"], ["", "(*definition [simp]: \"list_single x \\<equiv> [x]\"\n  lemma lms_single_aref: \"(list_single,op_mset_single) \\<in> Id \\<rightarrow> list_mset_rel\"  \n    unfolding list_mset_rel_def by (auto simp: in_br_conv split: list.splits)*)"], ["", "lemma lms_is_empty_aref: \"(is_Nil,op_mset_is_empty) \\<in> list_mset_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (is_Nil, op_mset_is_empty) \\<in> list_mset_rel \\<rightarrow> bool_rel", "unfolding list_mset_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (is_Nil, op_mset_is_empty)\n    \\<in> br mset (\\<lambda>_. True) \\<rightarrow> bool_rel", "by (auto simp: in_br_conv split: list.splits)"], ["", "lemma lms_insert_aref: \"((#), op_mset_insert) \\<in> Id \\<rightarrow> list_mset_rel \\<rightarrow> list_mset_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((#), op_mset_insert)\n    \\<in> Id \\<rightarrow> list_mset_rel \\<rightarrow> list_mset_rel", "unfolding list_mset_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((#), op_mset_insert)\n    \\<in> Id \\<rightarrow>\n          br mset (\\<lambda>_. True) \\<rightarrow>\n          br mset (\\<lambda>_. True)", "by (auto simp: in_br_conv)"], ["", "lemma lms_union_aref: \"((@), op_mset_plus) \\<in> list_mset_rel \\<rightarrow> list_mset_rel \\<rightarrow> list_mset_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((@), op_mset_plus)\n    \\<in> list_mset_rel \\<rightarrow>\n          list_mset_rel \\<rightarrow> list_mset_rel", "unfolding list_mset_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((@), op_mset_plus)\n    \\<in> br mset (\\<lambda>_. True) \\<rightarrow>\n          br mset (\\<lambda>_. True) \\<rightarrow>\n          br mset (\\<lambda>_. True)", "by (auto simp: in_br_conv)"], ["", "lemma lms_pick_aref: \"(\\<lambda>x#l \\<Rightarrow> RETURN (x,l), mop_mset_pick) \\<in> list_mset_rel \\<rightarrow> \\<langle>Id \\<times>\\<^sub>r list_mset_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>xa. case xa of x # l \\<Rightarrow> RETURN (x, l),\n     mop_mset_pick)\n    \\<in> list_mset_rel \\<rightarrow>\n          \\<langle>Id \\<times>\\<^sub>r list_mset_rel\\<rangle>nres_rel", "unfolding list_mset_rel_def mop_mset_pick_alt[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>xa. case xa of x # l \\<Rightarrow> RETURN (x, l),\n     \\<lambda>x.\n        ASSERT (pre_mset_pick x) \\<bind> (\\<lambda>_. op_mset_pick x))\n    \\<in> br mset (\\<lambda>_. True) \\<rightarrow>\n          \\<langle>Id \\<times>\\<^sub>r\n                   br mset (\\<lambda>_. True)\\<rangle>nres_rel", "apply1 (refine_vcg nres_relI fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> br mset (\\<lambda>_. True);\n        pre_mset_pick a'\\<rbrakk>\n       \\<Longrightarrow> (case a of x # l \\<Rightarrow> RETURN (x, l))\n                         \\<le> \\<Down>\n                                (Id \\<times>\\<^sub>r\n                                 br mset (\\<lambda>_. True))\n                                (op_mset_pick a')", "apply1 (clarsimp simp: in_br_conv neq_Nil_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y ys.\n       RETURN (y, ys)\n       \\<le> \\<Down> (Id \\<times>\\<^sub>r br mset (\\<lambda>_. True))\n              (SPEC\n                (\\<lambda>(x, m'). add_mset y (mset ys) = add_mset x m'))", "apply1 (refine_vcg RETURN_SPEC_refine)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y ys.\n       \\<exists>x'.\n          ((y, ys), x')\n          \\<in> Id \\<times>\\<^sub>r br mset (\\<lambda>_. True) \\<and>\n          (case x' of\n           (x, m') \\<Rightarrow> add_mset y (mset ys) = add_mset x m')", "applyS (clarsimp simp: in_br_conv algebra_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"list_contains x l \\<equiv>  list_ex ((=) x) l\""], ["", "lemma lms_contains_aref: \"(list_contains, op_mset_contains) \\<in> Id \\<rightarrow> list_mset_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_contains, op_mset_contains)\n    \\<in> Id \\<rightarrow> list_mset_rel \\<rightarrow> bool_rel", "unfolding list_mset_rel_def list_contains_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. list_ex ((=) x), op_mset_contains)\n    \\<in> Id \\<rightarrow> br mset (\\<lambda>_. True) \\<rightarrow> bool_rel", "by (auto simp: in_br_conv list_ex_iff in_multiset_in_set)"], ["", "fun list_remove1 :: \"'a \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n    \"list_remove1 x [] = []\"\n  | \"list_remove1 x (y#ys) = (if x=y then ys else y#list_remove1 x ys)\""], ["", "lemma mset_list_remove1[simp]: \"mset (list_remove1 x l) = mset l - {#x#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (list_remove1 x l) = mset l - {#x#}", "apply (induction l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. mset (list_remove1 x []) = mset [] - {#x#}\n 2. \\<And>a l.\n       mset (list_remove1 x l) = mset l - {#x#} \\<Longrightarrow>\n       mset (list_remove1 x (a # l)) = mset (a # l) - {#x#}", "applyS simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       mset (list_remove1 x l) = mset l - {#x#} \\<Longrightarrow>\n       mset (list_remove1 x (a # l)) = mset (a # l) - {#x#}", "by (clarsimp simp: algebra_simps)"], ["", "lemma lms_remove_aref: \"(list_remove1, op_mset_delete) \\<in> Id \\<rightarrow> list_mset_rel \\<rightarrow> list_mset_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_remove1, op_mset_delete)\n    \\<in> Id \\<rightarrow> list_mset_rel \\<rightarrow> list_mset_rel", "unfolding list_mset_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_remove1, op_mset_delete)\n    \\<in> Id \\<rightarrow>\n          br mset (\\<lambda>_. True) \\<rightarrow>\n          br mset (\\<lambda>_. True)", "by (auto simp: in_br_conv)"], ["", "fun list_count :: \"'a \\<Rightarrow> 'a list \\<Rightarrow> nat\" where\n    \"list_count _ [] = 0\"\n  | \"list_count x (y#ys) = (if x=y then 1 + list_count x ys else list_count x ys)\""], ["", "lemma mset_list_count[simp]: \"list_count x ys = count (mset ys) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_count x ys = count (mset ys) x", "by (induction ys) auto"], ["", "lemma lms_count_aref: \"(list_count, op_mset_count) \\<in> Id \\<rightarrow> list_mset_rel \\<rightarrow> nat_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_count, op_mset_count)\n    \\<in> Id \\<rightarrow> list_mset_rel \\<rightarrow> nat_rel", "unfolding list_mset_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_count, op_mset_count)\n    \\<in> Id \\<rightarrow> br mset (\\<lambda>_. True) \\<rightarrow> nat_rel", "by (auto simp: in_br_conv)"], ["", "definition list_remove_all :: \"'a list \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n    \"list_remove_all xs ys \\<equiv> fold list_remove1 ys xs\""], ["", "lemma list_remove_all_mset[simp]: \"mset (list_remove_all xs ys) = mset xs - mset ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (list_remove_all xs ys) = mset xs - mset ys", "unfolding list_remove_all_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (fold list_remove1 ys xs) = mset xs - mset ys", "by (induction ys arbitrary: xs) (auto simp: algebra_simps)"], ["", "lemma lms_minus_aref: \"(list_remove_all,op_mset_minus) \\<in> list_mset_rel \\<rightarrow> list_mset_rel \\<rightarrow> list_mset_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_remove_all, op_mset_minus)\n    \\<in> list_mset_rel \\<rightarrow>\n          list_mset_rel \\<rightarrow> list_mset_rel", "unfolding list_mset_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_remove_all, op_mset_minus)\n    \\<in> br mset (\\<lambda>_. True) \\<rightarrow>\n          br mset (\\<lambda>_. True) \\<rightarrow>\n          br mset (\\<lambda>_. True)", "by (auto simp: in_br_conv)"], ["", "subsection \\<open>Declaration of Implementations\\<close>"], ["", "definition \"list_mset_assn A \\<equiv> pure (list_mset_rel O \\<langle>the_pure A\\<rangle>mset_rel)\""], ["", "declare list_mset_assn_def[symmetric,fcomp_norm_unfold]"], ["", "lemma [safe_constraint_rules]: \"is_pure (list_mset_assn A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pure (list_mset_assn A)", "unfolding list_mset_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pure (pure (list_mset_rel O \\<langle>the_pure A\\<rangle>mset_rel))", "by simp"], ["", "sepref_decl_impl (no_register) lms_empty: lms_empty_aref[sepref_param]"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "(*sepref_decl_impl (no_register) lms_single: lms_single_aref[sepref_param] .*)"], ["", "definition [simp]: \"op_list_mset_empty \\<equiv> op_mset_empty\""], ["", "lemma lms_fold_custom_empty:\n    \"{#} = op_list_mset_empty\"\n    \"op_mset_empty = op_list_mset_empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#} = op_list_mset_empty &&& op_mset_empty = op_list_mset_empty", "by auto"], ["", "sepref_register op_list_mset_empty"], ["", "lemmas [sepref_fr_rules] = lms_empty_hnr[folded op_list_mset_empty_def]"], ["", "(*  \n  definition [simp]: \"op_list_mset_single \\<equiv> op_mset_single\"\n  lemma lms_fold_custom_single:\n    \"{#x#} = op_list_mset_single x\"\n    \"op_mset_single x = op_list_mset_single x\"\n    by auto\n  sepref_register op_list_mset_single\n  lemmas [sepref_fr_rules] = lms_single_hnr[folded op_list_mset_single_def]\n  *)"], ["", "sepref_decl_impl lms_is_empty: lms_is_empty_aref[sepref_param]"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_impl lms_insert: lms_insert_aref[sepref_param]"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_impl lms_union: lms_union_aref[sepref_param]"], ["proof (prove)\ngoal:\nNo subgoals!", ".\n\n  \\<comment> \\<open>Some extra work is required for nondetermistic ops\\<close>"], ["", "lemma lms_pick_aref': \n    \"(\\<lambda>x#l \\<Rightarrow> return (x,l), mop_mset_pick) \\<in> (pure list_mset_rel)\\<^sup>k \\<rightarrow>\\<^sub>a prod_assn id_assn (pure list_mset_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>xa. case xa of x # l \\<Rightarrow> return (x, l),\n     mop_mset_pick)\n    \\<in> (pure\n            list_mset_rel)\\<^sup>k \\<rightarrow>\\<^sub>a id_assn \\<times>\\<^sub>a\n                   pure list_mset_rel", "apply (simp only: prod_assn_pure_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>xa. case xa of x # l \\<Rightarrow> return (x, l),\n     mop_mset_pick)\n    \\<in> (pure\n            list_mset_rel)\\<^sup>k \\<rightarrow>\\<^sub>a pure\n                    (Id \\<times>\\<^sub>r list_mset_rel)", "apply sepref_to_hoare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xi.\n       \\<lbrakk>x ::\\<^sub>i TYPE('a multiset);\n        nofail (mop_mset_pick x)\\<rbrakk>\n       \\<Longrightarrow> <\\<up>\n                           ((xi, x)\n                            \\<in> list_mset_rel)> case xi of\n            x # l \\<Rightarrow>\n              return\n               (x, l) <\\<lambda>r.\n                          \\<up> ((xi, x) \\<in> list_mset_rel) *\n                          (\\<exists>\\<^sub>Axa.\n                              \\<up>\n                               ((r, xa)\n                                \\<in> Id \\<times>\\<^sub>r list_mset_rel) *\n                              \\<up>\n                               (RETURN xa \\<le> mop_mset_pick x))>\\<^sub>t", "apply (sep_auto simp: refine_pw_simps list_mset_rel_def in_br_conv algebra_simps eintros del: exI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "sepref_decl_impl (ismop) lms_pick: lms_pick_aref'"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_impl lms_contains: lms_contains_aref[sepref_param]"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_impl lms_remove: lms_remove_aref[sepref_param]"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_impl lms_count: lms_count_aref[sepref_param]"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_impl lms_minus: lms_minus_aref[sepref_param]"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"]]}