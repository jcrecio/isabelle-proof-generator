{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/IICF/Impl/IICF_Array_Matrix.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemma is_amtx_precise[safe_constraint_rules]: \"precise (is_amtx N M)\"", "lemma is_amtx_bounded:\n    shows \"rdomp (is_amtx N M) m \\<Longrightarrow> mtx_nonzero m \\<subseteq> {0..<N}\\<times>{0..<M}\"", "lemma mtx_idx_valid[simp]: \"\\<lbrakk>i < (N::nat); j < M\\<rbrakk> \\<Longrightarrow> i * M + j < N * M\"", "lemma mtx_idx_unique_conv[simp]: \n    fixes M :: nat\n    assumes \"j<M\" \"j'<M\"\n    shows \"(i * M + j = i' * M + j') \\<longleftrightarrow> (i=i' \\<and> j=j')\"", "lemma mtx_tabulate_rl[sep_heap_rules]:\n    assumes NONZ: \"mtx_nonzero c \\<subseteq> {0..<N}\\<times>{0..<M}\"\n    shows \"<emp> mtx_tabulate N M c <IICF_Array_Matrix.is_amtx N M c>\"", "lemma mtx_copy_rl[sep_heap_rules]:\n    \"<is_amtx N M c mtx> amtx_copy mtx <\\<lambda>r. is_amtx N M c mtx * is_amtx N M c r>\"", "lemma IS_ID_imp_PRES_ZERO_UNIQUE[constraint_rules]: \"IS_ID A \\<Longrightarrow> PRES_ZERO_UNIQUE A\"", "lemma mtx_dflt_rl[sep_heap_rules]: \"<emp> amtx_dflt N M k <is_amtx N M (op_amtx_dfltNxM N M k)>\"", "lemma mtx_get_rl[sep_heap_rules]: \"\\<lbrakk>i<N; j<M \\<rbrakk> \\<Longrightarrow> <is_amtx N M c mtx> mtx_get M mtx (i,j) <\\<lambda>r. is_amtx N M c mtx * \\<up>(r = c (i,j))>\"", "lemma mtx_set_rl[sep_heap_rules]: \"\\<lbrakk>i<N; j<M \\<rbrakk> \n    \\<Longrightarrow> <is_amtx N M c mtx> mtx_set M mtx (i,j) v <\\<lambda>r. is_amtx N M (c((i,j) := v)) r>\"", "lemmas [fcomp_norm_unfold] = amtx_assn_def[symmetric]", "lemmas [safe_constraint_rules] = CN_FALSEI[of is_pure \"amtx_assn N M A\" for N M A]", "lemma [intf_of_assn]: \"intf_of_assn A TYPE('a) \\<Longrightarrow> intf_of_assn (amtx_assn N M A) TYPE('a i_mtx)\"", "lemma mtx_rel_pres_zero:\n    assumes \"PRES_ZERO_UNIQUE A\" \n    assumes \"(m,m')\\<in>\\<langle>A\\<rangle>mtx_rel\"\n    shows \"m ij = 0 \\<longleftrightarrow> m' ij = 0\"", "lemma amtx_assn_bounded:\n    assumes \"CONSTRAINT (IS_PURE PRES_ZERO_UNIQUE) A\"\n    shows \"rdomp (amtx_assn N M A) m \\<Longrightarrow> mtx_nonzero m \\<subseteq> {0..<N}\\<times>{0..<M}\"", "lemma mtx_tabulate_aref: \n    \"(mtx_tabulate N M, RETURN o op_mtx_new) \n      \\<in> [\\<lambda>c. mtx_nonzero c \\<subseteq> {0..<N}\\<times>{0..<M}]\\<^sub>a id_assn\\<^sup>k \\<rightarrow> IICF_Array_Matrix.is_amtx N M\"", "lemma mtx_copy_aref: \n    \"(amtx_copy, RETURN o op_mtx_copy) \\<in> (is_amtx N M)\\<^sup>k \\<rightarrow>\\<^sub>a is_amtx N M\"", "lemma mtx_nonzero_bid_eq:\n    assumes \"R\\<subseteq>Id\"\n    assumes \"(a, a') \\<in> Id \\<rightarrow> R\" \n    shows \"mtx_nonzero a = mtx_nonzero a'\"", "lemma mtx_nonzero_zu_eq:\n    assumes \"PRES_ZERO_UNIQUE R\"\n    assumes \"(a, a') \\<in> Id \\<rightarrow> R\" \n    shows \"mtx_nonzero a = mtx_nonzero a'\"", "lemma op_mtx_new_fref': \n    \"CONSTRAINT PRES_ZERO_UNIQUE A \\<Longrightarrow> (RETURN \\<circ> op_mtx_new, RETURN \\<circ> op_mtx_new) \\<in> (nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow> A) \\<rightarrow>\\<^sub>f \\<langle>\\<langle>A\\<rangle>mtx_rel\\<rangle>nres_rel\"", "lemma amtx_fold_custom_new:\n    \"op_mtx_new \\<equiv> op_amtx_new N M\"\n    \"mop_mtx_new \\<equiv> \\<lambda>c. RETURN (op_amtx_new N M c)\"", "lemma amtx_new_hnr[sepref_fr_rules]: \n    fixes A :: \"'a::zero \\<Rightarrow> 'b::{zero,heap} \\<Rightarrow> assn\"\n    shows \"CONSTRAINT (IS_PURE PRES_ZERO_UNIQUE) A \\<Longrightarrow>\n    (mtx_tabulate N M, (RETURN \\<circ> PR_CONST (op_amtx_new N M)))\n    \\<in> [\\<lambda>x. mtx_nonzero x \\<subseteq> {0..<N} \\<times> {0..<M}]\\<^sub>a (pure (nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow> the_pure A))\\<^sup>k \\<rightarrow> amtx_assn N M A\"", "lemma [def_pat_rules]: \"op_amtx_new$N$M \\<equiv> UNPROTECT (op_amtx_new N M)\"", "lemma mtx_dflt_aref: \n      \"(amtx_dflt N M, RETURN o PR_CONST (op_amtx_dfltNxM N M)) \\<in> id_assn\\<^sup>k \\<rightarrow>\\<^sub>a is_amtx N M\"", "lemma amtx_get_aref: \n      \"(uncurry (mtx_get M), uncurry (RETURN oo op_mtx_get)) \\<in> [\\<lambda>(_,(i,j)). i<N \\<and> j<M]\\<^sub>a (is_amtx N M)\\<^sup>k *\\<^sub>a (prod_assn nat_assn nat_assn)\\<^sup>k \\<rightarrow> id_assn\"", "lemma amtx_set_aref: \"(uncurry2 (mtx_set M), uncurry2 (RETURN ooo op_mtx_set)) \n      \\<in> [\\<lambda>((_,(i,j)),_). i<N \\<and> j<M]\\<^sub>a (is_amtx N M)\\<^sup>d *\\<^sub>a (prod_assn nat_assn nat_assn)\\<^sup>k *\\<^sub>a id_assn\\<^sup>k \\<rightarrow> is_amtx N M\"", "lemma amtx_get_aref': \n      \"(uncurry (mtx_get M), uncurry (RETURN oo op_mtx_get)) \\<in> (is_amtx N M)\\<^sup>k *\\<^sub>a (prod_assn (pure (nbn_rel N)) (pure (nbn_rel M)))\\<^sup>k \\<rightarrow>\\<^sub>a id_assn\"", "lemma amtx_set_aref': \"(uncurry2 (mtx_set M), uncurry2 (RETURN ooo op_mtx_set)) \n      \\<in> (is_amtx N M)\\<^sup>d *\\<^sub>a (prod_assn (pure (nbn_rel N)) (pure (nbn_rel M)))\\<^sup>k *\\<^sub>a id_assn\\<^sup>k \\<rightarrow>\\<^sub>a is_amtx N M\"", "lemma op_amtx_lin_get_aref: \"(uncurry Array.nth, uncurry (RETURN oo PR_CONST op_amtx_lin_get)) \\<in> [\\<lambda>(_,i). i<N*M]\\<^sub>a (is_amtx N M)\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k \\<rightarrow> id_assn\"", "lemma op_amtx_lin_set_aref: \"(uncurry2 (\\<lambda>m i x. Array.upd i x m), uncurry2 (RETURN ooo PR_CONST op_amtx_lin_set)) \\<in> [\\<lambda>((_,i),_). i<N*M]\\<^sub>a (is_amtx N M)\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a id_assn\\<^sup>k \\<rightarrow> is_amtx N M\"", "lemma amtx_fold_lin_get: \"m (i div M, i mod M) = op_amtx_lin_get M m i\"", "lemma amtx_fold_lin_set: \"m ((i div M, i mod M) := x) = op_amtx_lin_set M m i x\"", "lemma this_loc: \"amtx_pointwise_unop_impl N M f A fi\"", "lemma op_hnr[sepref_fr_rules]: \n      assumes PURE: \"CONSTRAINT (IS_PURE PRES_ZERO_UNIQUE) A\"\n      shows \"(amtx_pointwise_unnop_fold_impl1 N M fi, RETURN \\<circ> PR_CONST (mtx_pointwise_unop f)) \\<in> (amtx_assn N M A)\\<^sup>d \\<rightarrow>\\<^sub>a amtx_assn N M A\"", "lemma this_loc: \"amtx_pointwise_binop_impl f A fi\"", "lemma op_hnr[sepref_fr_rules]: \n      assumes PURE: \"CONSTRAINT (IS_PURE PRES_ZERO_UNIQUE) A\"\n      shows \"(uncurry (amtx_pointwise_binop_fold_impl1 fi N M), uncurry (RETURN oo PR_CONST (mtx_pointwise_binop f))) \\<in> (amtx_assn N M A)\\<^sup>d *\\<^sub>a (amtx_assn N M A)\\<^sup>k \\<rightarrow>\\<^sub>a amtx_assn N M A\"", "lemma this_loc: \"amtx_pointwise_cmpop_impl f g A fi gi\"", "lemma op_hnr[sepref_fr_rules]: \n      assumes PURE: \"CONSTRAINT (IS_PURE PRES_ZERO_UNIQUE) A\"\n      shows \"(uncurry (amtx_pointwise_cmpop_fold_impl1 N M fi gi), uncurry (RETURN oo PR_CONST (mtx_pointwise_cmpop f g))) \\<in> (amtx_assn N M A)\\<^sup>d *\\<^sub>a (amtx_assn N M A)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\"", "lemma times_param: \"((*),(*)::'a\\<Rightarrow>_) \\<in> Id \\<rightarrow> Id \\<rightarrow> Id\"", "lemma [def_pat_rules]: \"IICF_Array_Matrix.diagonalN$N \\<equiv> UNPROTECT diagonalN\"", "lemma diagonalN_hnr[sepref_fr_rules]:\n        assumes \"CONSTRAINT (IS_PURE PRES_ZERO_UNIQUE) A\"\n        (*assumes \"CONSTRAINT (IS_PURE IS_ID) (A::int \\<Rightarrow> int \\<Rightarrow> assn)\"*)\n        shows \"(return o diagonalN, RETURN o (PR_CONST diagonalN)) \\<in> A\\<^sup>k \\<rightarrow>\\<^sub>a pure (nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow> the_pure A)\"", "lemma diagonal_nonzero_ltN[simp]: \"(a,b)\\<in>mtx_nonzero (diagonalN k) \\<Longrightarrow> a<N \\<and> b<N\""], "translations": [["", "lemma is_amtx_precise[safe_constraint_rules]: \"precise (is_amtx N M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. precise (is_amtx N M)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' h p F F'.\n       h \\<Turnstile>\n       is_amtx N M a p * F \\<and>\\<^sub>A\n       is_amtx N M a' p * F' \\<Longrightarrow>\n       a = a'", "unfolding is_amtx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' h p F F'.\n       h \\<Turnstile>\n       (\\<exists>\\<^sub>Al.\n           p \\<mapsto>\\<^sub>a l *\n           \\<up>\n            (length l = N * M \\<and>\n             (\\<forall>i<N. \\<forall>j<M. l ! (i * M + j) = a (i, j)) \\<and>\n             (\\<forall>i j.\n                 N \\<le> i \\<or> M \\<le> j \\<longrightarrow>\n                 a (i, j) = (0::'a)))) *\n       F \\<and>\\<^sub>A\n       (\\<exists>\\<^sub>Al.\n           p \\<mapsto>\\<^sub>a l *\n           \\<up>\n            (length l = N * M \\<and>\n             (\\<forall>i<N.\n                 \\<forall>j<M. l ! (i * M + j) = a' (i, j)) \\<and>\n             (\\<forall>i j.\n                 N \\<le> i \\<or> M \\<le> j \\<longrightarrow>\n                 a' (i, j) = (0::'a)))) *\n       F' \\<Longrightarrow>\n       a = a'", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa b p F F' l la.\n       \\<lbrakk>(aa, b) \\<Turnstile>\n                p \\<mapsto>\\<^sub>a la * F \\<and>\\<^sub>A\n                p \\<mapsto>\\<^sub>a l * F';\n        length la = N * M;\n        \\<forall>i<N. \\<forall>j<M. la ! (i * M + j) = a (i, j);\n        \\<forall>i j.\n           (N \\<le> i \\<longrightarrow> a (i, j) = (0::'a)) \\<and>\n           (M \\<le> j \\<longrightarrow> a (i, j) = (0::'a));\n        length l = N * M;\n        \\<forall>i<N. \\<forall>j<M. l ! (i * M + j) = a' (i, j);\n        \\<forall>i j.\n           (N \\<le> i \\<longrightarrow> a' (i, j) = (0::'a)) \\<and>\n           (M \\<le> j \\<longrightarrow> a' (i, j) = (0::'a))\\<rbrakk>\n       \\<Longrightarrow> a = a'", "apply prec_extract_eqs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa b p F F' l la.\n       \\<lbrakk>(aa, b) \\<Turnstile>\n                p \\<mapsto>\\<^sub>a la * F \\<and>\\<^sub>A\n                p \\<mapsto>\\<^sub>a l * F';\n        length la = N * M;\n        \\<forall>i<N. \\<forall>j<M. la ! (i * M + j) = a (i, j);\n        \\<forall>i j.\n           (N \\<le> i \\<longrightarrow> a (i, j) = (0::'a)) \\<and>\n           (M \\<le> j \\<longrightarrow> a (i, j) = (0::'a));\n        length l = N * M;\n        \\<forall>i<N. \\<forall>j<M. l ! (i * M + j) = a' (i, j);\n        \\<forall>i j.\n           (N \\<le> i \\<longrightarrow> a' (i, j) = (0::'a)) \\<and>\n           (M \\<le> j \\<longrightarrow> a' (i, j) = (0::'a));\n        la = l\\<rbrakk>\n       \\<Longrightarrow> a = a'", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa b p F F' l la x.\n       \\<lbrakk>(aa, b) \\<Turnstile>\n                p \\<mapsto>\\<^sub>a la * F \\<and>\\<^sub>A\n                p \\<mapsto>\\<^sub>a l * F';\n        length la = N * M;\n        \\<forall>i<N. \\<forall>j<M. la ! (i * M + j) = a (i, j);\n        \\<forall>i j.\n           (N \\<le> i \\<longrightarrow> a (i, j) = (0::'a)) \\<and>\n           (M \\<le> j \\<longrightarrow> a (i, j) = (0::'a));\n        length l = N * M;\n        \\<forall>i<N. \\<forall>j<M. l ! (i * M + j) = a' (i, j);\n        \\<forall>i j.\n           (N \\<le> i \\<longrightarrow> a' (i, j) = (0::'a)) \\<and>\n           (M \\<le> j \\<longrightarrow> a' (i, j) = (0::'a));\n        la = l\\<rbrakk>\n       \\<Longrightarrow> a x = a' x", "apply (rename_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa b p F F' l la x.\n       \\<lbrakk>(aa, b) \\<Turnstile>\n                p \\<mapsto>\\<^sub>a la * F \\<and>\\<^sub>A\n                p \\<mapsto>\\<^sub>a l * F';\n        length la = N * M;\n        \\<forall>i<N. \\<forall>j<M. la ! (i * M + j) = a (i, j);\n        \\<forall>i j.\n           (N \\<le> i \\<longrightarrow> a (i, j) = (0::'a)) \\<and>\n           (M \\<le> j \\<longrightarrow> a (i, j) = (0::'a));\n        length l = N * M;\n        \\<forall>i<N. \\<forall>j<M. l ! (i * M + j) = a' (i, j);\n        \\<forall>i j.\n           (N \\<le> i \\<longrightarrow> a' (i, j) = (0::'a)) \\<and>\n           (M \\<le> j \\<longrightarrow> a' (i, j) = (0::'a));\n        la = l\\<rbrakk>\n       \\<Longrightarrow> a x = a' x", "apply (case_tac x; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa b p F F' l la x ab ba.\n       \\<lbrakk>(aa, b) \\<Turnstile>\n                p \\<mapsto>\\<^sub>a l * F \\<and>\\<^sub>A\n                p \\<mapsto>\\<^sub>a l * F';\n        \\<forall>i<N. \\<forall>j<M. a' (i, j) = a (i, j);\n        \\<forall>i j.\n           (N \\<le> i \\<longrightarrow> a (i, j) = (0::'a)) \\<and>\n           (M \\<le> j \\<longrightarrow> a (i, j) = (0::'a));\n        length l = N * M;\n        \\<forall>i<N. \\<forall>j<M. l ! (i * M + j) = a (i, j);\n        \\<forall>i j.\n           (N \\<le> i \\<longrightarrow> a' (i, j) = (0::'a)) \\<and>\n           (M \\<le> j \\<longrightarrow> a' (i, j) = (0::'a));\n        la = l; x = (ab, ba)\\<rbrakk>\n       \\<Longrightarrow> a (ab, ba) = a' (ab, ba)", "apply (rename_tac i j)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa b p F F' l la x i j.\n       \\<lbrakk>(aa, b) \\<Turnstile>\n                p \\<mapsto>\\<^sub>a l * F \\<and>\\<^sub>A\n                p \\<mapsto>\\<^sub>a l * F';\n        \\<forall>i<N. \\<forall>j<M. a' (i, j) = a (i, j);\n        \\<forall>i j.\n           (N \\<le> i \\<longrightarrow> a (i, j) = (0::'a)) \\<and>\n           (M \\<le> j \\<longrightarrow> a (i, j) = (0::'a));\n        length l = N * M;\n        \\<forall>i<N. \\<forall>j<M. l ! (i * M + j) = a (i, j);\n        \\<forall>i j.\n           (N \\<le> i \\<longrightarrow> a' (i, j) = (0::'a)) \\<and>\n           (M \\<le> j \\<longrightarrow> a' (i, j) = (0::'a));\n        la = l; x = (i, j)\\<rbrakk>\n       \\<Longrightarrow> a (i, j) = a' (i, j)", "apply (case_tac \"i<N\"; case_tac \"j<M\"; simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_amtx_bounded:\n    shows \"rdomp (is_amtx N M) m \\<Longrightarrow> mtx_nonzero m \\<subseteq> {0..<N}\\<times>{0..<M}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rdomp (is_amtx N M) m \\<Longrightarrow>\n    mtx_nonzero m \\<subseteq> {0..<N} \\<times> {0..<M}", "unfolding rdomp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>h c. h \\<Turnstile> is_amtx N M m c \\<Longrightarrow>\n    mtx_nonzero m \\<subseteq> {0..<N} \\<times> {0..<M}", "apply (clarsimp simp: mtx_nonzero_def is_amtx_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba c l.\n       \\<lbrakk>m (a, b) \\<noteq> (0::'a);\n        (aa, ba) \\<Turnstile> c \\<mapsto>\\<^sub>a l; length l = N * M;\n        \\<forall>i<N. \\<forall>j<M. l ! (i * M + j) = m (i, j);\n        \\<forall>i j.\n           (N \\<le> i \\<longrightarrow> m (i, j) = (0::'a)) \\<and>\n           (M \\<le> j \\<longrightarrow> m (i, j) = (0::'a))\\<rbrakk>\n       \\<Longrightarrow> a < N \\<and> b < M", "by (meson not_less)"], ["", "(*definition \"mtx_new N M c \\<equiv> do {\n    Array.make (N*M) (\\<lambda>i. c (i div M, i mod M))\n  }\"*)"], ["", "definition \"mtx_tabulate N M c \\<equiv> do {\n    m \\<leftarrow> Array.new (N*M) 0;\n    (_,_,m) \\<leftarrow> imp_for' 0 (N*M) (\\<lambda>k (i,j,m). do {\n      Array.upd k (c (i,j)) m;\n      let j=j+1;\n      if j<M then return (i,j,m)\n      else return (i+1,0,m)\n    }) (0,0,m);\n    return m\n  }\""], ["", "definition \"amtx_copy \\<equiv> array_copy\""], ["", "definition \"amtx_dflt N M v \\<equiv> Array.make (N*M) (\\<lambda>i. v)\""], ["", "definition \"mtx_get M mtx e \\<equiv> Array.nth mtx (fst e * M + snd e)\""], ["", "definition \"mtx_set M mtx e v \\<equiv> Array.upd (fst e * M + snd e) v mtx\""], ["", "lemma mtx_idx_valid[simp]: \"\\<lbrakk>i < (N::nat); j < M\\<rbrakk> \\<Longrightarrow> i * M + j < N * M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < N; j < M\\<rbrakk> \\<Longrightarrow> i * M + j < N * M", "by (rule mlex_bound)"], ["", "lemma mtx_idx_unique_conv[simp]: \n    fixes M :: nat\n    assumes \"j<M\" \"j'<M\"\n    shows \"(i * M + j = i' * M + j') \\<longleftrightarrow> (i=i' \\<and> j=j')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i * M + j = i' * M + j') = (i = i' \\<and> j = j')", "using assms"], ["proof (prove)\nusing this:\n  j < M\n  j' < M\n\ngoal (1 subgoal):\n 1. (i * M + j = i' * M + j') = (i = i' \\<and> j = j')", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>j < M; j' < M; i * M + j = i' * M + j'\\<rbrakk>\n    \\<Longrightarrow> i = i'\n 2. \\<lbrakk>j < M; j' < M; i * M + j = i' * M + j'\\<rbrakk>\n    \\<Longrightarrow> j = j'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>j < M; j' < M; i * M + j = i' * M + j'\\<rbrakk>\n    \\<Longrightarrow> i = i'", "by (metis add_right_cancel div_if div_mult_self3 linorder_neqE_nat not_less0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>j < M; j' < M; i * M + j = i' * M + j'\\<rbrakk>\n    \\<Longrightarrow> j = j'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>j < M; j' < M; i * M + j = i' * M + j'\\<rbrakk>\n    \\<Longrightarrow> j = j'", "using \\<open>\\<lbrakk>j < M; j' < M; i * M + j = i' * M + j'\\<rbrakk> \\<Longrightarrow> i = i'\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>j < M; j' < M; i * M + j = i' * M + j'\\<rbrakk>\n  \\<Longrightarrow> i = i'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j < M; j' < M; i * M + j = i' * M + j'\\<rbrakk>\n    \\<Longrightarrow> j = j'", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*lemma mtx_index_unique[simp]: \"\\<lbrakk>i<(N::nat); j<M; i'<N; j'<M\\<rbrakk> \\<Longrightarrow> i*M+j = i'*M+j' \\<longleftrightarrow> i=i' \\<and> j=j'\"\n    by (metis ab_semigroup_add_class.add.commute add_diff_cancel_right' div_if div_mult_self3 gr0I not_less0)*)"], ["", "lemma mtx_tabulate_rl[sep_heap_rules]:\n    assumes NONZ: \"mtx_nonzero c \\<subseteq> {0..<N}\\<times>{0..<M}\"\n    shows \"<emp> mtx_tabulate N M c <IICF_Array_Matrix.is_amtx N M c>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> mtx_tabulate N M c <is_amtx N M c>", "proof (cases \"M=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. M = 0 \\<Longrightarrow> <emp> mtx_tabulate N M c <is_amtx N M c>\n 2. M \\<noteq> 0 \\<Longrightarrow> <emp> mtx_tabulate N M c <is_amtx N M c>", "case True"], ["proof (state)\nthis:\n  M = 0\n\ngoal (2 subgoals):\n 1. M = 0 \\<Longrightarrow> <emp> mtx_tabulate N M c <is_amtx N M c>\n 2. M \\<noteq> 0 \\<Longrightarrow> <emp> mtx_tabulate N M c <is_amtx N M c>", "thus ?thesis"], ["proof (prove)\nusing this:\n  M = 0\n\ngoal (1 subgoal):\n 1. <emp> mtx_tabulate N M c <is_amtx N M c>", "unfolding mtx_tabulate_def"], ["proof (prove)\nusing this:\n  M = 0\n\ngoal (1 subgoal):\n 1. <emp>\n    Array.new (N * M) (0::'a) \\<bind>\n    (\\<lambda>m.\n        imp_for' 0 (N * M)\n         (\\<lambda>k (i, j, m).\n             Array.upd k (c (i, j)) m \\<bind>\n             (\\<lambda>_.\n                 let j = j + 1\n                 in if j < M then return (i, j, m)\n                    else return (i + 1, 0, m)))\n         (0, 0, m) \\<bind>\n        (\\<lambda>(uu_, uu_, m). return m))\n    <is_amtx N M c>", "using mtx_nonzeroD[OF _ NONZ]"], ["proof (prove)\nusing this:\n  M = 0\n  \\<not> ?i < N \\<Longrightarrow> c (?i, ?j) = (0::'a)\n  \\<not> ?j < M \\<Longrightarrow> c (?i, ?j) = (0::'a)\n\ngoal (1 subgoal):\n 1. <emp>\n    Array.new (N * M) (0::'a) \\<bind>\n    (\\<lambda>m.\n        imp_for' 0 (N * M)\n         (\\<lambda>k (i, j, m).\n             Array.upd k (c (i, j)) m \\<bind>\n             (\\<lambda>_.\n                 let j = j + 1\n                 in if j < M then return (i, j, m)\n                    else return (i + 1, 0, m)))\n         (0, 0, m) \\<bind>\n        (\\<lambda>(uu_, uu_, m). return m))\n    <is_amtx N M c>", "by (sep_auto simp: is_amtx_def)"], ["proof (state)\nthis:\n  <emp> mtx_tabulate N M c <is_amtx N M c>\n\ngoal (1 subgoal):\n 1. M \\<noteq> 0 \\<Longrightarrow> <emp> mtx_tabulate N M c <is_amtx N M c>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. M \\<noteq> 0 \\<Longrightarrow> <emp> mtx_tabulate N M c <is_amtx N M c>", "case False"], ["proof (state)\nthis:\n  M \\<noteq> 0\n\ngoal (1 subgoal):\n 1. M \\<noteq> 0 \\<Longrightarrow> <emp> mtx_tabulate N M c <is_amtx N M c>", "hence M_POS: \"0<M\""], ["proof (prove)\nusing this:\n  M \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < M", "by auto"], ["proof (state)\nthis:\n  0 < M\n\ngoal (1 subgoal):\n 1. M \\<noteq> 0 \\<Longrightarrow> <emp> mtx_tabulate N M c <is_amtx N M c>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> mtx_tabulate N M c <is_amtx N M c>", "unfolding mtx_tabulate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp>\n    Array.new (N * M) (0::'a) \\<bind>\n    (\\<lambda>m.\n        imp_for' 0 (N * M)\n         (\\<lambda>k (i, j, m).\n             Array.upd k (c (i, j)) m \\<bind>\n             (\\<lambda>_.\n                 let j = j + 1\n                 in if j < M then return (i, j, m)\n                    else return (i + 1, 0, m)))\n         (0, 0, m) \\<bind>\n        (\\<lambda>(uu_, uu_, m). return m))\n    <is_amtx N M c>", "apply (sep_auto \n        decon: \n          imp_for'_rule[where \n            I=\"\\<lambda>k (i,j,mi). \\<exists>\\<^sub>Am. mi \\<mapsto>\\<^sub>a m \n            * \\<up>( k=i*M+j \\<and> j<M \\<and> k\\<le>N*M \\<and> length m = N*M )\n            * \\<up>( \\<forall>i'<i. \\<forall>j<M. m!(i'*M+j) = c (i',j) )\n            * \\<up>( \\<forall>j'<j. m!(i*M+j') = c (i,j') )\n          \"]\n        simp: nth_list_update M_POS dest: Suc_lessI\n      )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b m.\n       \\<lbrakk>N * M = a * M + aa; aa < M; length m = a * M + aa;\n        \\<forall>i'<a. \\<forall>j<M. m ! (i' * M + j) = c (i', j);\n        \\<forall>j'<aa. m ! (a * M + j') = c (a, j')\\<rbrakk>\n       \\<Longrightarrow> b \\<mapsto>\\<^sub>a m \\<Longrightarrow>\\<^sub>A\n                         is_amtx N M c b", "unfolding is_amtx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b m.\n       \\<lbrakk>N * M = a * M + aa; aa < M; length m = a * M + aa;\n        \\<forall>i'<a. \\<forall>j<M. m ! (i' * M + j) = c (i', j);\n        \\<forall>j'<aa. m ! (a * M + j') = c (a, j')\\<rbrakk>\n       \\<Longrightarrow> b \\<mapsto>\\<^sub>a m \\<Longrightarrow>\\<^sub>A\n                         \\<exists>\\<^sub>Al.\n                            b \\<mapsto>\\<^sub>a l *\n                            \\<up>\n                             (length l = N * M \\<and>\n                              (\\<forall>i<N.\n                                  \\<forall>j<M.\n                                     l ! (i * M + j) = c (i, j)) \\<and>\n                              (\\<forall>i j.\n                                  N \\<le> i \\<or>\n                                  M \\<le> j \\<longrightarrow>\n                                  c (i, j) = (0::'a)))", "using mtx_nonzeroD[OF _ NONZ]"], ["proof (prove)\nusing this:\n  \\<not> ?i < N \\<Longrightarrow> c (?i, ?j) = (0::'a)\n  \\<not> ?j < M \\<Longrightarrow> c (?i, ?j) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a aa b m.\n       \\<lbrakk>N * M = a * M + aa; aa < M; length m = a * M + aa;\n        \\<forall>i'<a. \\<forall>j<M. m ! (i' * M + j) = c (i', j);\n        \\<forall>j'<aa. m ! (a * M + j') = c (a, j')\\<rbrakk>\n       \\<Longrightarrow> b \\<mapsto>\\<^sub>a m \\<Longrightarrow>\\<^sub>A\n                         \\<exists>\\<^sub>Al.\n                            b \\<mapsto>\\<^sub>a l *\n                            \\<up>\n                             (length l = N * M \\<and>\n                              (\\<forall>i<N.\n                                  \\<forall>j<M.\n                                     l ! (i * M + j) = c (i, j)) \\<and>\n                              (\\<forall>i j.\n                                  N \\<le> i \\<or>\n                                  M \\<le> j \\<longrightarrow>\n                                  c (i, j) = (0::'a)))", "apply sep_auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b m ab ba i j.\n       \\<lbrakk>N * M = a * M + aa; aa < M; length m = a * M + aa;\n        \\<forall>i'<a. \\<forall>j<M. m ! (i' * M + j) = c (i', j);\n        \\<forall>j'<aa. m ! (a * M + j') = c (a, j');\n        \\<And>i j. \\<not> i < N \\<Longrightarrow> c (i, j) = (0::'a);\n        \\<And>j i. \\<not> j < M \\<Longrightarrow> c (i, j) = (0::'a);\n        (ab, ba) \\<Turnstile> b \\<mapsto>\\<^sub>a m; i < N; j < M\\<rbrakk>\n       \\<Longrightarrow> m ! (i * M + j) = c (i, j)", "by (metis add.right_neutral M_POS mtx_idx_unique_conv)"], ["proof (state)\nthis:\n  <emp> mtx_tabulate N M c <is_amtx N M c>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mtx_copy_rl[sep_heap_rules]:\n    \"<is_amtx N M c mtx> amtx_copy mtx <\\<lambda>r. is_amtx N M c mtx * is_amtx N M c r>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_amtx N M c mtx> amtx_copy mtx\n    <\\<lambda>r. is_amtx N M c mtx * is_amtx N M c r>", "by (sep_auto simp: amtx_copy_def is_amtx_def)"], ["", "definition \"PRES_ZERO_UNIQUE A \\<equiv> (A``{0}={0} \\<and> A\\<inverse>``{0} = {0})\""], ["", "lemma IS_ID_imp_PRES_ZERO_UNIQUE[constraint_rules]: \"IS_ID A \\<Longrightarrow> PRES_ZERO_UNIQUE A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IS_ID A \\<Longrightarrow> PRES_ZERO_UNIQUE A", "unfolding IS_ID_def PRES_ZERO_UNIQUE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A = Id \\<Longrightarrow>\n    A `` {0::'a} = {0::'a} \\<and> A\\<inverse> `` {0::'a} = {0::'a}", "by auto"], ["", "definition op_amtx_dfltNxM :: \"nat \\<Rightarrow> nat \\<Rightarrow> 'a::zero \\<Rightarrow> nat\\<times>nat\\<Rightarrow>'a\" where\n    [simp]: \"op_amtx_dfltNxM N M v \\<equiv> \\<lambda>(i,j). if i<N \\<and> j<M then v else 0\""], ["", "context fixes N M::nat begin"], ["", "sepref_decl_op (no_def) op_amtx_dfltNxM: \"op_amtx_dfltNxM N M\" :: \"A \\<rightarrow> \\<langle>A\\<rangle>mtx_rel\"\n    where \"CONSTRAINT PRES_ZERO_UNIQUE A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CONSTRAINT PRES_ZERO_UNIQUE A \\<Longrightarrow>\n    ((RETURN \\<circ>\\<circ>\\<circ> op_amtx_dfltNxM) N M,\n     (RETURN \\<circ>\\<circ>\\<circ> op_amtx_dfltNxM) N M)\n    \\<in> A \\<rightarrow>\\<^sub>f \\<langle>\\<langle>A\\<rangle>mtx_rel\\<rangle>nres_rel", "apply (rule fref_ncI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. CONSTRAINT PRES_ZERO_UNIQUE A \\<Longrightarrow>\n    ((RETURN \\<circ>\\<circ>\\<circ> op_amtx_dfltNxM) N M,\n     (RETURN \\<circ>\\<circ>\\<circ> op_amtx_dfltNxM) N M)\n    \\<in> A \\<rightarrow>\n          \\<langle>\\<langle>A\\<rangle>mtx_rel\\<rangle>nres_rel", "unfolding op_amtx_dfltNxM_def[abs_def] mtx_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CONSTRAINT PRES_ZERO_UNIQUE A \\<Longrightarrow>\n    (RETURN \\<circ>\n     (\\<lambda>v (i, j). if i < N \\<and> j < M then v else (0::'a)),\n     RETURN \\<circ>\n     (\\<lambda>v (i, j). if i < N \\<and> j < M then v else (0::'b)))\n    \\<in> A \\<rightarrow>\n          \\<langle>nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow>\n                   A\\<rangle>nres_rel", "apply parametricity"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>CONSTRAINT PRES_ZERO_UNIQUE A; (a, a') \\<in> A;\n        (aa, a'a) \\<in> nat_rel; (ab, a'b) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> (N, N) \\<in> nat_rel\n 2. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>CONSTRAINT PRES_ZERO_UNIQUE A; (a, a') \\<in> A;\n        (aa, a'a) \\<in> nat_rel; (ab, a'b) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> (M, M) \\<in> nat_rel\n 3. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>CONSTRAINT PRES_ZERO_UNIQUE A; (a, a') \\<in> A;\n        (aa, a'a) \\<in> nat_rel; (ab, a'b) \\<in> nat_rel;\n        \\<not> (aa < N \\<and> ab < M);\n        \\<not> (a'a < N \\<and> a'b < M)\\<rbrakk>\n       \\<Longrightarrow> (0::'a, 0::'b) \\<in> A", "by (auto simp add: PRES_ZERO_UNIQUE_def)"], ["", "end"], ["", "lemma mtx_dflt_rl[sep_heap_rules]: \"<emp> amtx_dflt N M k <is_amtx N M (op_amtx_dfltNxM N M k)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> amtx_dflt N M k <is_amtx N M (op_amtx_dfltNxM N M k)>", "by (sep_auto simp: amtx_dflt_def is_amtx_def)"], ["", "lemma mtx_get_rl[sep_heap_rules]: \"\\<lbrakk>i<N; j<M \\<rbrakk> \\<Longrightarrow> <is_amtx N M c mtx> mtx_get M mtx (i,j) <\\<lambda>r. is_amtx N M c mtx * \\<up>(r = c (i,j))>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < N; j < M\\<rbrakk>\n    \\<Longrightarrow> <is_amtx N M c mtx> mtx_get M mtx (i, j)\n                      <\\<lambda>r. is_amtx N M c mtx * \\<up> (r = c (i, j))>", "by (sep_auto simp: mtx_get_def is_amtx_def)"], ["", "lemma mtx_set_rl[sep_heap_rules]: \"\\<lbrakk>i<N; j<M \\<rbrakk> \n    \\<Longrightarrow> <is_amtx N M c mtx> mtx_set M mtx (i,j) v <\\<lambda>r. is_amtx N M (c((i,j) := v)) r>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < N; j < M\\<rbrakk>\n    \\<Longrightarrow> <is_amtx N M c mtx> mtx_set M mtx (i, j) v\n                      <is_amtx N M (c((i, j) := v))>", "by (sep_auto simp: mtx_set_def is_amtx_def nth_list_update)"], ["", "definition \"amtx_assn N M A \\<equiv> hr_comp (is_amtx N M) (\\<langle>the_pure A\\<rangle>mtx_rel)\""], ["", "lemmas [fcomp_norm_unfold] = amtx_assn_def[symmetric]"], ["", "lemmas [safe_constraint_rules] = CN_FALSEI[of is_pure \"amtx_assn N M A\" for N M A]"], ["", "lemma [intf_of_assn]: \"intf_of_assn A TYPE('a) \\<Longrightarrow> intf_of_assn (amtx_assn N M A) TYPE('a i_mtx)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. intf_of_assn A TYPE('a) \\<Longrightarrow>\n    intf_of_assn (amtx_assn N M A) TYPE('a i_mtx)", "by simp"], ["", "abbreviation \"asmtx_assn N A \\<equiv> amtx_assn N N A\""], ["", "lemma mtx_rel_pres_zero:\n    assumes \"PRES_ZERO_UNIQUE A\" \n    assumes \"(m,m')\\<in>\\<langle>A\\<rangle>mtx_rel\"\n    shows \"m ij = 0 \\<longleftrightarrow> m' ij = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m ij = (0::'a)) = (m' ij = (0::'b))", "using assms"], ["proof (prove)\nusing this:\n  PRES_ZERO_UNIQUE A\n  (m, m') \\<in> \\<langle>A\\<rangle>mtx_rel\n\ngoal (1 subgoal):\n 1. (m ij = (0::'a)) = (m' ij = (0::'b))", "apply1 (clarsimp simp: IS_PURE_def PRES_ZERO_UNIQUE_def is_pure_conv mtx_rel_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(m, m') \\<in> Id \\<rightarrow> A; A `` {0::'a} = {0::'b};\n     A\\<inverse> `` {0::'b} = {0::'a}\\<rbrakk>\n    \\<Longrightarrow> (m ij = (0::'a)) = (m' ij = (0::'b))", "apply (drule fun_relD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>A `` {0::'a} = {0::'b};\n     A\\<inverse> `` {0::'b} = {0::'a}\\<rbrakk>\n    \\<Longrightarrow> (?x5, ?x'5) \\<in> Id\n 2. \\<lbrakk>A `` {0::'a} = {0::'b}; A\\<inverse> `` {0::'b} = {0::'a};\n     (m ?x5, m' ?x'5) \\<in> A\\<rbrakk>\n    \\<Longrightarrow> (m ij = (0::'a)) = (m' ij = (0::'b))", "applyS (rule IdI[of ij])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A `` {0::'a} = {0::'b}; A\\<inverse> `` {0::'b} = {0::'a};\n     (m ij, m' ij) \\<in> A\\<rbrakk>\n    \\<Longrightarrow> (m ij = (0::'a)) = (m' ij = (0::'b))", "applyS auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma amtx_assn_bounded:\n    assumes \"CONSTRAINT (IS_PURE PRES_ZERO_UNIQUE) A\"\n    shows \"rdomp (amtx_assn N M A) m \\<Longrightarrow> mtx_nonzero m \\<subseteq> {0..<N}\\<times>{0..<M}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rdomp (amtx_assn N M A) m \\<Longrightarrow>\n    mtx_nonzero m \\<subseteq> {0..<N} \\<times> {0..<M}", "apply (clarsimp simp: mtx_nonzero_def amtx_assn_def rdomp_hrcomp_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b y.\n       \\<lbrakk>m (a, b) \\<noteq> (0::'a); rdomp (is_amtx N M) y;\n        (y, m) \\<in> \\<langle>the_pure A\\<rangle>mtx_rel\\<rbrakk>\n       \\<Longrightarrow> a < N \\<and> b < M", "apply (drule is_amtx_bounded)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b y.\n       \\<lbrakk>m (a, b) \\<noteq> (0::'a);\n        (y, m) \\<in> \\<langle>the_pure A\\<rangle>mtx_rel;\n        mtx_nonzero y \\<subseteq> {0..<N} \\<times> {0..<M}\\<rbrakk>\n       \\<Longrightarrow> a < N \\<and> b < M", "using assms"], ["proof (prove)\nusing this:\n  CONSTRAINT (IS_PURE PRES_ZERO_UNIQUE) A\n\ngoal (1 subgoal):\n 1. \\<And>a b y.\n       \\<lbrakk>m (a, b) \\<noteq> (0::'a);\n        (y, m) \\<in> \\<langle>the_pure A\\<rangle>mtx_rel;\n        mtx_nonzero y \\<subseteq> {0..<N} \\<times> {0..<M}\\<rbrakk>\n       \\<Longrightarrow> a < N \\<and> b < M", "by (fastforce simp: IS_PURE_def is_pure_conv mtx_rel_pres_zero[symmetric] mtx_nonzero_def)"], ["", "lemma mtx_tabulate_aref: \n    \"(mtx_tabulate N M, RETURN o op_mtx_new) \n      \\<in> [\\<lambda>c. mtx_nonzero c \\<subseteq> {0..<N}\\<times>{0..<M}]\\<^sub>a id_assn\\<^sup>k \\<rightarrow> IICF_Array_Matrix.is_amtx N M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mtx_tabulate N M, RETURN \\<circ> op_mtx_new)\n    \\<in> [\\<lambda>c.\n              mtx_nonzero c\n              \\<subseteq> {0..<N} \\<times>\n                          {0..<M}]\\<^sub>a id_assn\\<^sup>k \\<rightarrow> is_amtx\n                                    N M", "by sepref_to_hoare sep_auto"], ["", "lemma mtx_copy_aref: \n    \"(amtx_copy, RETURN o op_mtx_copy) \\<in> (is_amtx N M)\\<^sup>k \\<rightarrow>\\<^sub>a is_amtx N M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (amtx_copy, RETURN \\<circ> op_mtx_copy)\n    \\<in> (is_amtx N M)\\<^sup>k \\<rightarrow>\\<^sub>a is_amtx N M", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c a.\n       True \\<Longrightarrow>\n       hn_refine (fst ((is_amtx N M)\\<^sup>k) a c) (amtx_copy c)\n        (snd ((is_amtx N M)\\<^sup>k) a c) (is_amtx N M)\n        ((RETURN \\<circ> op_mtx_copy) a)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c a.\n       \\<lbrakk>True; nofail ((RETURN \\<circ> op_mtx_copy) a)\\<rbrakk>\n       \\<Longrightarrow> <fst ((is_amtx N M)\\<^sup>k) a\n                           c> amtx_copy\n                               c <\\<lambda>r.\n                                     snd ((is_amtx N M)\\<^sup>k) a c *\n                                     (\\<exists>\\<^sub>Ax.\n   is_amtx N M x r *\n   \\<up> (RETURN x \\<le> (RETURN \\<circ> op_mtx_copy) a))>\\<^sub>t", "apply (sep_auto simp: pure_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mtx_nonzero_bid_eq:\n    assumes \"R\\<subseteq>Id\"\n    assumes \"(a, a') \\<in> Id \\<rightarrow> R\" \n    shows \"mtx_nonzero a = mtx_nonzero a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mtx_nonzero a = mtx_nonzero a'", "using assms"], ["proof (prove)\nusing this:\n  R \\<subseteq> Id\n  (a, a') \\<in> Id \\<rightarrow> R\n\ngoal (1 subgoal):\n 1. mtx_nonzero a = mtx_nonzero a'", "apply (clarsimp simp: mtx_nonzero_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>R \\<subseteq> Id; (a, a') \\<in> Id \\<rightarrow> R\\<rbrakk>\n    \\<Longrightarrow> {(i, j). a (i, j) \\<noteq> (0::'a)} =\n                      {(i, j). a' (i, j) \\<noteq> (0::'a)}", "apply (metis fun_relE2 pair_in_Id_conv subsetCE)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mtx_nonzero_zu_eq:\n    assumes \"PRES_ZERO_UNIQUE R\"\n    assumes \"(a, a') \\<in> Id \\<rightarrow> R\" \n    shows \"mtx_nonzero a = mtx_nonzero a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mtx_nonzero a = mtx_nonzero a'", "using assms"], ["proof (prove)\nusing this:\n  PRES_ZERO_UNIQUE R\n  (a, a') \\<in> Id \\<rightarrow> R\n\ngoal (1 subgoal):\n 1. mtx_nonzero a = mtx_nonzero a'", "apply (clarsimp simp: mtx_nonzero_def PRES_ZERO_UNIQUE_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, a') \\<in> Id \\<rightarrow> R; R `` {0::'a} = {0::'b};\n     R\\<inverse> `` {0::'b} = {0::'a}\\<rbrakk>\n    \\<Longrightarrow> {(i, j). a (i, j) \\<noteq> (0::'a)} =\n                      {(i, j). a' (i, j) \\<noteq> (0::'b)}", "by (metis (no_types, hide_lams) IdI Image_singleton_iff converse_iff singletonD tagged_fun_relD_none)"], ["", "lemma op_mtx_new_fref': \n    \"CONSTRAINT PRES_ZERO_UNIQUE A \\<Longrightarrow> (RETURN \\<circ> op_mtx_new, RETURN \\<circ> op_mtx_new) \\<in> (nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow> A) \\<rightarrow>\\<^sub>f \\<langle>\\<langle>A\\<rangle>mtx_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CONSTRAINT PRES_ZERO_UNIQUE A \\<Longrightarrow>\n    (RETURN \\<circ> op_mtx_new, RETURN \\<circ> op_mtx_new)\n    \\<in> nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow>\n          A \\<rightarrow>\\<^sub>f \\<langle>\\<langle>A\\<rangle>mtx_rel\\<rangle>nres_rel", "by (rule op_mtx_new.fref)"], ["", "sepref_decl_impl (no_register) amtx_new_by_tab: mtx_tabulate_aref uses op_mtx_new_fref'"], ["proof (prove)\ngoal (1 subgoal):\n 1. CONSTRAINT PRES_ZERO_UNIQUE (the_pure A) \\<Longrightarrow>\n    (\\<lambda>c. mtx_nonzero c \\<subseteq> {0..<N} \\<times> {0..<M},\n     \\<lambda>c. mtx_nonzero c \\<subseteq> {0..<N} \\<times> {0..<M})\n    \\<in> (nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow>\n           the_pure A) \\<rightarrow>\n          bool_rel", "by (auto simp: mtx_nonzero_zu_eq)"], ["", "sepref_decl_impl amtx_copy: mtx_copy_aref"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition [simp]: \"op_amtx_new (N::nat) (M::nat) \\<equiv> op_mtx_new\""], ["", "lemma amtx_fold_custom_new:\n    \"op_mtx_new \\<equiv> op_amtx_new N M\"\n    \"mop_mtx_new \\<equiv> \\<lambda>c. RETURN (op_amtx_new N M c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (op_mtx_new \\<equiv> op_amtx_new N M) &&&\n    mop_mtx_new \\<equiv> \\<lambda>c. RETURN (op_amtx_new N M c)", "by (auto simp: mop_mtx_new_alt[abs_def])"], ["", "context fixes N M :: nat begin"], ["", "sepref_register \"PR_CONST (op_amtx_new N M)\" :: \"(nat \\<times> nat \\<Rightarrow> 'a) \\<Rightarrow> 'a i_mtx\""], ["", "end"], ["", "lemma amtx_new_hnr[sepref_fr_rules]: \n    fixes A :: \"'a::zero \\<Rightarrow> 'b::{zero,heap} \\<Rightarrow> assn\"\n    shows \"CONSTRAINT (IS_PURE PRES_ZERO_UNIQUE) A \\<Longrightarrow>\n    (mtx_tabulate N M, (RETURN \\<circ> PR_CONST (op_amtx_new N M)))\n    \\<in> [\\<lambda>x. mtx_nonzero x \\<subseteq> {0..<N} \\<times> {0..<M}]\\<^sub>a (pure (nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow> the_pure A))\\<^sup>k \\<rightarrow> amtx_assn N M A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CONSTRAINT (IS_PURE PRES_ZERO_UNIQUE) A \\<Longrightarrow>\n    (mtx_tabulate N M, (RETURN \\<circ>\\<circ> PR_CONST) (op_amtx_new N M))\n    \\<in> [\\<lambda>x.\n              mtx_nonzero x\n              \\<subseteq> {0..<N} \\<times>\n                          {0..<M}]\\<^sub>a (pure\n       (nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow>\n        the_pure A))\\<^sup>k \\<rightarrow> amtx_assn N M A", "using amtx_new_by_tab_hnr[of A N M]"], ["proof (prove)\nusing this:\n  CONSTRAINT (IS_PURE PRES_ZERO_UNIQUE) A \\<Longrightarrow>\n  (mtx_tabulate N M, RETURN \\<circ> op_mtx_new)\n  \\<in> [\\<lambda>x.\n            mtx_nonzero x\n            \\<subseteq> {0..<N} \\<times>\n                        {0..<M}]\\<^sub>a (pure\n     (nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow>\n      the_pure A))\\<^sup>k \\<rightarrow> amtx_assn N M A\n\ngoal (1 subgoal):\n 1. CONSTRAINT (IS_PURE PRES_ZERO_UNIQUE) A \\<Longrightarrow>\n    (mtx_tabulate N M, (RETURN \\<circ>\\<circ> PR_CONST) (op_amtx_new N M))\n    \\<in> [\\<lambda>x.\n              mtx_nonzero x\n              \\<subseteq> {0..<N} \\<times>\n                          {0..<M}]\\<^sub>a (pure\n       (nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow>\n        the_pure A))\\<^sup>k \\<rightarrow> amtx_assn N M A", "by simp"], ["", "lemma [def_pat_rules]: \"op_amtx_new$N$M \\<equiv> UNPROTECT (op_amtx_new N M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op_amtx_new $ N $ M \\<equiv> UNPROTECT (op_amtx_new N M)", "by simp"], ["", "context fixes N M :: nat notes [param] = IdI[of N] IdI[of M] begin"], ["", "lemma mtx_dflt_aref: \n      \"(amtx_dflt N M, RETURN o PR_CONST (op_amtx_dfltNxM N M)) \\<in> id_assn\\<^sup>k \\<rightarrow>\\<^sub>a is_amtx N M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (amtx_dflt N M, (RETURN \\<circ>\\<circ> PR_CONST) (op_amtx_dfltNxM N M))\n    \\<in> id_assn\\<^sup>k \\<rightarrow>\\<^sub>a is_amtx N M", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c a.\n       True \\<Longrightarrow>\n       hn_refine (fst (id_assn\\<^sup>k) a c) (amtx_dflt N M c)\n        (snd (id_assn\\<^sup>k) a c) (is_amtx N M)\n        ((RETURN \\<circ>\\<circ> PR_CONST) (op_amtx_dfltNxM N M) a)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c a.\n       \\<lbrakk>True;\n        nofail\n         ((RETURN \\<circ>\\<circ> PR_CONST) (op_amtx_dfltNxM N M) a)\\<rbrakk>\n       \\<Longrightarrow> <fst (id_assn\\<^sup>k) a\n                           c> amtx_dflt N M\n                               c <\\<lambda>r.\n                                     snd (id_assn\\<^sup>k) a c *\n                                     (\\<exists>\\<^sub>Ax.\n   is_amtx N M x r *\n   \\<up>\n    (RETURN x\n     \\<le> (RETURN \\<circ>\\<circ> PR_CONST) (op_amtx_dfltNxM N M)\n            a))>\\<^sub>t", "apply (sep_auto simp: pure_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "sepref_decl_impl amtx_dflt: mtx_dflt_aref"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma amtx_get_aref: \n      \"(uncurry (mtx_get M), uncurry (RETURN oo op_mtx_get)) \\<in> [\\<lambda>(_,(i,j)). i<N \\<and> j<M]\\<^sub>a (is_amtx N M)\\<^sup>k *\\<^sub>a (prod_assn nat_assn nat_assn)\\<^sup>k \\<rightarrow> id_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry (mtx_get M), uncurry (RETURN \\<circ>\\<circ> op_mtx_get))\n    \\<in> [\\<lambda>(uu_, i, j).\n              i < N \\<and>\n              j < M]\\<^sub>a (is_amtx N M)\\<^sup>k *\\<^sub>a\n                             (nat_assn \\<times>\\<^sub>a\n                              nat_assn)\\<^sup>k \\<rightarrow> id_assn", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c a.\n       case a of\n       (uu_, i, j) \\<Rightarrow> i < N \\<and> j < M \\<Longrightarrow>\n       hn_refine\n        (fst ((is_amtx N M)\\<^sup>k *\\<^sub>a\n              (nat_assn \\<times>\\<^sub>a nat_assn)\\<^sup>k)\n          a c)\n        (uncurry (mtx_get M) c)\n        (snd ((is_amtx N M)\\<^sup>k *\\<^sub>a\n              (nat_assn \\<times>\\<^sub>a nat_assn)\\<^sup>k)\n          a c)\n        id_assn (uncurry (RETURN \\<circ>\\<circ> op_mtx_get) a)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c a.\n       \\<lbrakk>case a of (uu_, i, j) \\<Rightarrow> i < N \\<and> j < M;\n        nofail (uncurry (RETURN \\<circ>\\<circ> op_mtx_get) a)\\<rbrakk>\n       \\<Longrightarrow> <fst ((is_amtx N M)\\<^sup>k *\\<^sub>a\n                               (nat_assn \\<times>\\<^sub>a nat_assn)\\<^sup>k)\n                           a c> uncurry (mtx_get M)\n                                 c <\\<lambda>r.\n snd ((is_amtx N M)\\<^sup>k *\\<^sub>a\n      (nat_assn \\<times>\\<^sub>a nat_assn)\\<^sup>k)\n  a c *\n (\\<exists>\\<^sub>Ax.\n     id_assn x r *\n     \\<up>\n      (RETURN x\n       \\<le> uncurry (RETURN \\<circ>\\<circ> op_mtx_get) a))>\\<^sub>t", "apply (sep_auto simp: pure_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "sepref_decl_impl amtx_get: amtx_get_aref"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma amtx_set_aref: \"(uncurry2 (mtx_set M), uncurry2 (RETURN ooo op_mtx_set)) \n      \\<in> [\\<lambda>((_,(i,j)),_). i<N \\<and> j<M]\\<^sub>a (is_amtx N M)\\<^sup>d *\\<^sub>a (prod_assn nat_assn nat_assn)\\<^sup>k *\\<^sub>a id_assn\\<^sup>k \\<rightarrow> is_amtx N M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (mtx_set M),\n     uncurry2 (RETURN \\<circ>\\<circ>\\<circ> op_mtx_set))\n    \\<in> [\\<lambda>((uu_, i, j), uu_).\n              i < N \\<and>\n              j < M]\\<^sub>a (is_amtx N M)\\<^sup>d *\\<^sub>a\n                             (nat_assn \\<times>\\<^sub>a\n                              nat_assn)\\<^sup>k *\\<^sub>a\n                             id_assn\\<^sup>k \\<rightarrow> is_amtx N M", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c a.\n       case a of\n       (x, xa) \\<Rightarrow>\n         (case x of\n          (uu_, i, j) \\<Rightarrow> \\<lambda>_. i < N \\<and> j < M)\n          xa \\<Longrightarrow>\n       hn_refine\n        (fst ((is_amtx N M)\\<^sup>d *\\<^sub>a\n              (nat_assn \\<times>\\<^sub>a nat_assn)\\<^sup>k *\\<^sub>a\n              id_assn\\<^sup>k)\n          a c)\n        (uncurry2 (mtx_set M) c)\n        (snd ((is_amtx N M)\\<^sup>d *\\<^sub>a\n              (nat_assn \\<times>\\<^sub>a nat_assn)\\<^sup>k *\\<^sub>a\n              id_assn\\<^sup>k)\n          a c)\n        (is_amtx N M) (uncurry2 (RETURN \\<circ>\\<circ>\\<circ> op_mtx_set) a)", "apply (rule hn_refine_preI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c a h.\n       \\<lbrakk>case a of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (uu_, i, j) \\<Rightarrow> \\<lambda>_. i < N \\<and> j < M)\n                   xa;\n        h \\<Turnstile>\n        fst ((is_amtx N M)\\<^sup>d *\\<^sub>a\n             (nat_assn \\<times>\\<^sub>a nat_assn)\\<^sup>k *\\<^sub>a\n             id_assn\\<^sup>k)\n         a c\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (fst ((is_amtx N M)\\<^sup>d *\\<^sub>a\n                                (nat_assn \\<times>\\<^sub>a\n                                 nat_assn)\\<^sup>k *\\<^sub>a\n                                id_assn\\<^sup>k)\n                            a c)\n                          (uncurry2 (mtx_set M) c)\n                          (snd ((is_amtx N M)\\<^sup>d *\\<^sub>a\n                                (nat_assn \\<times>\\<^sub>a\n                                 nat_assn)\\<^sup>k *\\<^sub>a\n                                id_assn\\<^sup>k)\n                            a c)\n                          (is_amtx N M)\n                          (uncurry2\n                            (RETURN \\<circ>\\<circ>\\<circ> op_mtx_set) a)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c a h.\n       \\<lbrakk>case a of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (uu_, i, j) \\<Rightarrow> \\<lambda>_. i < N \\<and> j < M)\n                   xa;\n        h \\<Turnstile>\n        fst ((is_amtx N M)\\<^sup>d *\\<^sub>a\n             (nat_assn \\<times>\\<^sub>a nat_assn)\\<^sup>k *\\<^sub>a\n             id_assn\\<^sup>k)\n         a c;\n        nofail\n         (uncurry2 (RETURN \\<circ>\\<circ>\\<circ> op_mtx_set) a)\\<rbrakk>\n       \\<Longrightarrow> <fst ((is_amtx N M)\\<^sup>d *\\<^sub>a\n                               (nat_assn \\<times>\\<^sub>a\n                                nat_assn)\\<^sup>k *\\<^sub>a\n                               id_assn\\<^sup>k)\n                           a c> uncurry2 (mtx_set M)\n                                 c <\\<lambda>r.\n snd ((is_amtx N M)\\<^sup>d *\\<^sub>a\n      (nat_assn \\<times>\\<^sub>a nat_assn)\\<^sup>k *\\<^sub>a\n      id_assn\\<^sup>k)\n  a c *\n (\\<exists>\\<^sub>Ax.\n     is_amtx N M x r *\n     \\<up>\n      (RETURN x\n       \\<le> uncurry2 (RETURN \\<circ>\\<circ>\\<circ> op_mtx_set) a))>\\<^sub>t", "apply (sep_auto simp: pure_def hn_ctxt_def invalid_assn_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "sepref_decl_impl amtx_set: amtx_set_aref"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma amtx_get_aref': \n      \"(uncurry (mtx_get M), uncurry (RETURN oo op_mtx_get)) \\<in> (is_amtx N M)\\<^sup>k *\\<^sub>a (prod_assn (pure (nbn_rel N)) (pure (nbn_rel M)))\\<^sup>k \\<rightarrow>\\<^sub>a id_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry (mtx_get M), uncurry (RETURN \\<circ>\\<circ> op_mtx_get))\n    \\<in> (is_amtx N M)\\<^sup>k *\\<^sub>a\n          (pure (nbn_rel N) \\<times>\\<^sub>a\n           pure (nbn_rel M))\\<^sup>k \\<rightarrow>\\<^sub>a id_assn", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c a.\n       True \\<Longrightarrow>\n       hn_refine\n        (fst ((is_amtx N M)\\<^sup>k *\\<^sub>a\n              (pure (nbn_rel N) \\<times>\\<^sub>a pure (nbn_rel M))\\<^sup>k)\n          a c)\n        (uncurry (mtx_get M) c)\n        (snd ((is_amtx N M)\\<^sup>k *\\<^sub>a\n              (pure (nbn_rel N) \\<times>\\<^sub>a pure (nbn_rel M))\\<^sup>k)\n          a c)\n        id_assn (uncurry (RETURN \\<circ>\\<circ> op_mtx_get) a)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c a.\n       \\<lbrakk>True;\n        nofail (uncurry (RETURN \\<circ>\\<circ> op_mtx_get) a)\\<rbrakk>\n       \\<Longrightarrow> <fst ((is_amtx N M)\\<^sup>k *\\<^sub>a\n                               (pure (nbn_rel N) \\<times>\\<^sub>a\n                                pure (nbn_rel M))\\<^sup>k)\n                           a c> uncurry (mtx_get M)\n                                 c <\\<lambda>r.\n snd ((is_amtx N M)\\<^sup>k *\\<^sub>a\n      (pure (nbn_rel N) \\<times>\\<^sub>a pure (nbn_rel M))\\<^sup>k)\n  a c *\n (\\<exists>\\<^sub>Ax.\n     id_assn x r *\n     \\<up>\n      (RETURN x\n       \\<le> uncurry (RETURN \\<circ>\\<circ> op_mtx_get) a))>\\<^sub>t", "apply (sep_auto simp: pure_def IS_PURE_def IS_ID_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "sepref_decl_impl amtx_get': amtx_get_aref'"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma amtx_set_aref': \"(uncurry2 (mtx_set M), uncurry2 (RETURN ooo op_mtx_set)) \n      \\<in> (is_amtx N M)\\<^sup>d *\\<^sub>a (prod_assn (pure (nbn_rel N)) (pure (nbn_rel M)))\\<^sup>k *\\<^sub>a id_assn\\<^sup>k \\<rightarrow>\\<^sub>a is_amtx N M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (mtx_set M),\n     uncurry2 (RETURN \\<circ>\\<circ>\\<circ> op_mtx_set))\n    \\<in> (is_amtx N M)\\<^sup>d *\\<^sub>a\n          (pure (nbn_rel N) \\<times>\\<^sub>a\n           pure (nbn_rel M))\\<^sup>k *\\<^sub>a\n          id_assn\\<^sup>k \\<rightarrow>\\<^sub>a is_amtx N M", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c a.\n       True \\<Longrightarrow>\n       hn_refine\n        (fst ((is_amtx N M)\\<^sup>d *\\<^sub>a\n              (pure (nbn_rel N) \\<times>\\<^sub>a\n               pure (nbn_rel M))\\<^sup>k *\\<^sub>a\n              id_assn\\<^sup>k)\n          a c)\n        (uncurry2 (mtx_set M) c)\n        (snd ((is_amtx N M)\\<^sup>d *\\<^sub>a\n              (pure (nbn_rel N) \\<times>\\<^sub>a\n               pure (nbn_rel M))\\<^sup>k *\\<^sub>a\n              id_assn\\<^sup>k)\n          a c)\n        (is_amtx N M) (uncurry2 (RETURN \\<circ>\\<circ>\\<circ> op_mtx_set) a)", "apply (rule hn_refine_preI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c a h.\n       \\<lbrakk>True;\n        h \\<Turnstile>\n        fst ((is_amtx N M)\\<^sup>d *\\<^sub>a\n             (pure (nbn_rel N) \\<times>\\<^sub>a\n              pure (nbn_rel M))\\<^sup>k *\\<^sub>a\n             id_assn\\<^sup>k)\n         a c\\<rbrakk>\n       \\<Longrightarrow> hn_refine\n                          (fst ((is_amtx N M)\\<^sup>d *\\<^sub>a\n                                (pure (nbn_rel N) \\<times>\\<^sub>a\n                                 pure (nbn_rel M))\\<^sup>k *\\<^sub>a\n                                id_assn\\<^sup>k)\n                            a c)\n                          (uncurry2 (mtx_set M) c)\n                          (snd ((is_amtx N M)\\<^sup>d *\\<^sub>a\n                                (pure (nbn_rel N) \\<times>\\<^sub>a\n                                 pure (nbn_rel M))\\<^sup>k *\\<^sub>a\n                                id_assn\\<^sup>k)\n                            a c)\n                          (is_amtx N M)\n                          (uncurry2\n                            (RETURN \\<circ>\\<circ>\\<circ> op_mtx_set) a)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c a h.\n       \\<lbrakk>True;\n        h \\<Turnstile>\n        fst ((is_amtx N M)\\<^sup>d *\\<^sub>a\n             (pure (nbn_rel N) \\<times>\\<^sub>a\n              pure (nbn_rel M))\\<^sup>k *\\<^sub>a\n             id_assn\\<^sup>k)\n         a c;\n        nofail\n         (uncurry2 (RETURN \\<circ>\\<circ>\\<circ> op_mtx_set) a)\\<rbrakk>\n       \\<Longrightarrow> <fst ((is_amtx N M)\\<^sup>d *\\<^sub>a\n                               (pure (nbn_rel N) \\<times>\\<^sub>a\n                                pure (nbn_rel M))\\<^sup>k *\\<^sub>a\n                               id_assn\\<^sup>k)\n                           a c> uncurry2 (mtx_set M)\n                                 c <\\<lambda>r.\n snd ((is_amtx N M)\\<^sup>d *\\<^sub>a\n      (pure (nbn_rel N) \\<times>\\<^sub>a pure (nbn_rel M))\\<^sup>k *\\<^sub>a\n      id_assn\\<^sup>k)\n  a c *\n (\\<exists>\\<^sub>Ax.\n     is_amtx N M x r *\n     \\<up>\n      (RETURN x\n       \\<le> uncurry2 (RETURN \\<circ>\\<circ>\\<circ> op_mtx_set) a))>\\<^sub>t", "apply (sep_auto simp: pure_def hn_ctxt_def invalid_assn_def IS_PURE_def IS_ID_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "sepref_decl_impl amtx_set': amtx_set_aref'"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "subsection \\<open>Pointwise Operations\\<close>"], ["", "context\n    fixes M N :: nat\n  begin"], ["", "sepref_decl_op amtx_lin_get: \"\\<lambda>f i. op_mtx_get f (i div M, i mod M)\" :: \"\\<langle>A\\<rangle>mtx_rel \\<rightarrow> nat_rel \\<rightarrow> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry\n      (\\<lambda>x1.\n          RETURN \\<circ> (\\<lambda>i. op_mtx_get x1 (i div M, i mod M))),\n     uncurry\n      (\\<lambda>x1.\n          RETURN \\<circ> (\\<lambda>i. op_mtx_get x1 (i div M, i mod M))))\n    \\<in> \\<langle>A\\<rangle>mtx_rel \\<times>\\<^sub>r\n          nat_rel \\<rightarrow>\\<^sub>f \\<langle>A\\<rangle>nres_rel", "unfolding op_mtx_get_def mtx_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry\n      (\\<lambda>x1. RETURN \\<circ> (\\<lambda>i. x1 (i div M, i mod M))),\n     uncurry\n      (\\<lambda>x1. RETURN \\<circ> (\\<lambda>i. x1 (i div M, i mod M))))\n    \\<in> (nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow>\n           A) \\<times>\\<^sub>r\n          nat_rel \\<rightarrow>\\<^sub>f \\<langle>A\\<rangle>nres_rel", "by (rule frefI) (parametricity; simp)"], ["", "sepref_decl_op amtx_lin_set: \"\\<lambda>f i x. op_mtx_set f (i div M, i mod M) x\" :: \"\\<langle>A\\<rangle>mtx_rel \\<rightarrow> nat_rel \\<rightarrow> A \\<rightarrow> \\<langle>A\\<rangle>mtx_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2\n      (\\<lambda>x1 x2.\n          (RETURN \\<circ>\\<circ>\\<circ> op_mtx_set) x1\n           (x2 div M, x2 mod M)),\n     uncurry2\n      (\\<lambda>x1 x2.\n          (RETURN \\<circ>\\<circ>\\<circ> op_mtx_set) x1\n           (x2 div M, x2 mod M)))\n    \\<in> (\\<langle>A\\<rangle>mtx_rel \\<times>\\<^sub>r\n           nat_rel) \\<times>\\<^sub>r\n          A \\<rightarrow>\\<^sub>f \\<langle>\\<langle>A\\<rangle>mtx_rel\\<rangle>nres_rel", "unfolding op_mtx_set_def mtx_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2\n      (\\<lambda>x1 x2.\n          (RETURN \\<circ>\\<circ>\\<circ> fun_upd) x1 (x2 div M, x2 mod M)),\n     uncurry2\n      (\\<lambda>x1 x2.\n          (RETURN \\<circ>\\<circ>\\<circ> fun_upd) x1 (x2 div M, x2 mod M)))\n    \\<in> ((nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow>\n            A) \\<times>\\<^sub>r\n           nat_rel) \\<times>\\<^sub>r\n          A \\<rightarrow>\\<^sub>f \\<langle>nat_rel \\<times>\\<^sub>r\n     nat_rel \\<rightarrow>\n     A\\<rangle>nres_rel", "apply (rule frefI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True;\n        (x, y)\n        \\<in> ((nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow>\n                A) \\<times>\\<^sub>r\n               nat_rel) \\<times>\\<^sub>r\n              A\\<rbrakk>\n       \\<Longrightarrow> (uncurry2\n                           (\\<lambda>x1 x2.\n                               (RETURN \\<circ>\\<circ>\\<circ> fun_upd) x1\n                                (x2 div M, x2 mod M))\n                           x,\n                          uncurry2\n                           (\\<lambda>x1 x2.\n                               (RETURN \\<circ>\\<circ>\\<circ> fun_upd) x1\n                                (x2 div M, x2 mod M))\n                           y)\n                         \\<in> \\<langle>nat_rel \\<times>\\<^sub>r\n  nat_rel \\<rightarrow>\n  A\\<rangle>nres_rel", "apply parametricity"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y a a' aa a'a.\n       \\<lbrakk>True;\n        (x, y)\n        \\<in> ((nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow>\n                A) \\<times>\\<^sub>r\n               nat_rel) \\<times>\\<^sub>r\n              A;\n        (a, a') \\<in> nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow> A;\n        (aa, a'a) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> ((=), (=))\n                         \\<in> nat_rel \\<times>\\<^sub>r\n                               nat_rel \\<rightarrow>\n                               nat_rel \\<times>\\<^sub>r\n                               nat_rel \\<rightarrow>\n                               bool_rel\n 2. \\<And>x y a a' aa a'a.\n       \\<lbrakk>True;\n        (x, y)\n        \\<in> ((nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow>\n                A) \\<times>\\<^sub>r\n               nat_rel) \\<times>\\<^sub>r\n              A;\n        (a, a') \\<in> nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow> A;\n        (aa, a'a) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> (M, M) \\<in> nat_rel\n 3. \\<And>x y a a' aa a'a.\n       \\<lbrakk>True;\n        (x, y)\n        \\<in> ((nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow>\n                A) \\<times>\\<^sub>r\n               nat_rel) \\<times>\\<^sub>r\n              A;\n        (a, a') \\<in> nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow> A;\n        (aa, a'a) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> (M, M) \\<in> nat_rel", "by simp_all"], ["", "lemma op_amtx_lin_get_aref: \"(uncurry Array.nth, uncurry (RETURN oo PR_CONST op_amtx_lin_get)) \\<in> [\\<lambda>(_,i). i<N*M]\\<^sub>a (is_amtx N M)\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k \\<rightarrow> id_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry Array.nth,\n     uncurry\n      ((RETURN \\<circ>\\<circ>\\<circ> PR_CONST) local.op_amtx_lin_get))\n    \\<in> [\\<lambda>(uu_, i).\n              i < N *\n                  M]\\<^sub>a (is_amtx N M)\\<^sup>k *\\<^sub>a\n                             nat_assn\\<^sup>k \\<rightarrow> id_assn", "apply sepref_to_hoare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi a ai.\n       \\<lbrakk>b < N * M;\n        a ::\\<^sub>i TYPE(nat \\<times> nat \\<Rightarrow> 'a);\n        b ::\\<^sub>i TYPE(nat);\n        nofail (RETURN (PR_CONST local.op_amtx_lin_get a b))\\<rbrakk>\n       \\<Longrightarrow> <\\<up> ((bi, b) \\<in> nat_rel) *\n                          is_amtx N M a\n                           ai> Array.nth ai\n                                bi <\\<lambda>r.\n \\<up> ((bi, b) \\<in> nat_rel) * is_amtx N M a ai *\n (\\<exists>\\<^sub>Ax.\n     \\<up> ((r, x) \\<in> Id) *\n     \\<up>\n      (RETURN x \\<le> RETURN (PR_CONST local.op_amtx_lin_get a b)))>\\<^sub>t", "unfolding is_amtx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi a ai.\n       \\<lbrakk>b < N * M;\n        a ::\\<^sub>i TYPE(nat \\<times> nat \\<Rightarrow> 'a);\n        b ::\\<^sub>i TYPE(nat);\n        nofail (RETURN (PR_CONST local.op_amtx_lin_get a b))\\<rbrakk>\n       \\<Longrightarrow> <\\<up> ((bi, b) \\<in> nat_rel) *\n                          (\\<exists>\\<^sub>Al.\n                              ai \\<mapsto>\\<^sub>a l *\n                              \\<up>\n                               (length l = N * M \\<and>\n                                (\\<forall>i<N.\n                                    \\<forall>j<M.\n l ! (i * M + j) = a (i, j)) \\<and>\n                                (\\<forall>i j.\n                                    N \\<le> i \\<or>\n                                    M \\<le> j \\<longrightarrow>\n                                    a (i, j) =\n                                    (0::'a))))> Array.nth ai\n           bi <\\<lambda>r.\n                  \\<up> ((bi, b) \\<in> nat_rel) *\n                  (\\<exists>\\<^sub>Al.\n                      ai \\<mapsto>\\<^sub>a l *\n                      \\<up>\n                       (length l = N * M \\<and>\n                        (\\<forall>i<N.\n                            \\<forall>j<M. l ! (i * M + j) = a (i, j)) \\<and>\n                        (\\<forall>i j.\n                            N \\<le> i \\<or> M \\<le> j \\<longrightarrow>\n                            a (i, j) = (0::'a)))) *\n                  (\\<exists>\\<^sub>Ax.\n                      \\<up> ((r, x) \\<in> Id) *\n                      \\<up>\n                       (RETURN x\n                        \\<le> RETURN\n                               (PR_CONST local.op_amtx_lin_get a\n                                 b)))>\\<^sub>t", "apply sep_auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b a ai l aa ba.\n       \\<lbrakk>b < N * M; length l = N * M;\n        \\<forall>i<N. \\<forall>j<M. l ! (i * M + j) = a (i, j);\n        \\<forall>i j.\n           (N \\<le> i \\<longrightarrow> a (i, j) = (0::'a)) \\<and>\n           (M \\<le> j \\<longrightarrow> a (i, j) = (0::'a));\n        (aa, ba) \\<Turnstile> ai \\<mapsto>\\<^sub>a l\\<rbrakk>\n       \\<Longrightarrow> l ! b = a (b div M, b mod M)", "apply (metis mult.commute div_eq_0_iff div_mult2_eq div_mult_mod_eq mod_less_divisor mult_is_0 not_less0)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "sepref_decl_impl amtx_lin_get: op_amtx_lin_get_aref"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(uu_, i). i < N * M, \\<lambda>(uu_, i). i < N * M)\n    \\<in> \\<langle>the_pure A\\<rangle>mtx_rel \\<times>\\<^sub>r\n          nat_rel \\<rightarrow>\n          bool_rel", "by auto"], ["", "lemma op_amtx_lin_set_aref: \"(uncurry2 (\\<lambda>m i x. Array.upd i x m), uncurry2 (RETURN ooo PR_CONST op_amtx_lin_set)) \\<in> [\\<lambda>((_,i),_). i<N*M]\\<^sub>a (is_amtx N M)\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a id_assn\\<^sup>k \\<rightarrow> is_amtx N M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (\\<lambda>m i x. Array.upd i x m),\n     uncurry2 (RETURN \\<circ>\\<circ>\\<circ> PR_CONST local.op_amtx_lin_set))\n    \\<in> [\\<lambda>((uu_, i), uu_).\n              i < N *\n                  M]\\<^sub>a (is_amtx N M)\\<^sup>d *\\<^sub>a\n                             nat_assn\\<^sup>k *\\<^sub>a\n                             id_assn\\<^sup>k \\<rightarrow> is_amtx N M", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (uncurry2 (\\<lambda>m i x. Array.upd i x m),\n     uncurry2 (RETURN \\<circ>\\<circ>\\<circ> PR_CONST local.op_amtx_lin_set))\n    \\<in> [\\<lambda>((uu_, i), uu_).\n              i < N *\n                  M]\\<^sub>a (is_amtx N M)\\<^sup>d *\\<^sub>a\n                             nat_assn\\<^sup>k *\\<^sub>a\n                             id_assn\\<^sup>k \\<rightarrow> is_amtx N M", "have [simp]: \"i < N * M \\<Longrightarrow> \\<not>(M \\<le> i mod M)\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < N * M \\<Longrightarrow> \\<not> M \\<le> i mod M", "by (cases \"N = 0 \\<or> M = 0\") (auto simp add: not_le)"], ["proof (state)\nthis:\n  ?i4 < N * M \\<Longrightarrow> \\<not> M \\<le> ?i4 mod M\n\ngoal (1 subgoal):\n 1. (uncurry2 (\\<lambda>m i x. Array.upd i x m),\n     uncurry2 (RETURN \\<circ>\\<circ>\\<circ> PR_CONST local.op_amtx_lin_set))\n    \\<in> [\\<lambda>((uu_, i), uu_).\n              i < N *\n                  M]\\<^sub>a (is_amtx N M)\\<^sup>d *\\<^sub>a\n                             nat_assn\\<^sup>k *\\<^sub>a\n                             id_assn\\<^sup>k \\<rightarrow> is_amtx N M", "have [simp]: \"i < N * M \\<Longrightarrow> \\<not>(N \\<le> i div M)\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < N * M \\<Longrightarrow> \\<not> N \\<le> i div M", "apply (cases \"N = 0 \\<or> M = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>i < N * M; N = 0 \\<or> M = 0\\<rbrakk>\n    \\<Longrightarrow> \\<not> N \\<le> i div M\n 2. \\<lbrakk>i < N * M; \\<not> (N = 0 \\<or> M = 0)\\<rbrakk>\n    \\<Longrightarrow> \\<not> N \\<le> i div M", "apply (auto simp add: not_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < N * M; 0 < N; 0 < M\\<rbrakk> \\<Longrightarrow> i div M < N", "apply (metis mult.commute div_eq_0_iff div_mult2_eq neq0_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ?i4 < N * M \\<Longrightarrow> \\<not> N \\<le> ?i4 div M\n\ngoal (1 subgoal):\n 1. (uncurry2 (\\<lambda>m i x. Array.upd i x m),\n     uncurry2 (RETURN \\<circ>\\<circ>\\<circ> PR_CONST local.op_amtx_lin_set))\n    \\<in> [\\<lambda>((uu_, i), uu_).\n              i < N *\n                  M]\\<^sub>a (is_amtx N M)\\<^sup>d *\\<^sub>a\n                             nat_assn\\<^sup>k *\\<^sub>a\n                             id_assn\\<^sup>k \\<rightarrow> is_amtx N M", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (\\<lambda>m i x. Array.upd i x m),\n     uncurry2 (RETURN \\<circ>\\<circ>\\<circ> PR_CONST local.op_amtx_lin_set))\n    \\<in> [\\<lambda>((uu_, i), uu_).\n              i < N *\n                  M]\\<^sub>a (is_amtx N M)\\<^sup>d *\\<^sub>a\n                             nat_assn\\<^sup>k *\\<^sub>a\n                             id_assn\\<^sup>k \\<rightarrow> is_amtx N M", "apply sepref_to_hoare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi ba bia a ai.\n       \\<lbrakk>ba < N * M;\n        a ::\\<^sub>i TYPE(nat \\<times> nat \\<Rightarrow> 'a);\n        ba ::\\<^sub>i TYPE(nat); b ::\\<^sub>i TYPE('a);\n        nofail (RETURN (PR_CONST local.op_amtx_lin_set a ba b))\\<rbrakk>\n       \\<Longrightarrow> <\\<up> ((bi, b) \\<in> Id) *\n                          \\<up> ((bia, ba) \\<in> nat_rel) *\n                          is_amtx N M a\n                           ai> Array.upd bia bi\n                                ai <\\<lambda>r.\n \\<up> ((bi, b) \\<in> Id) * \\<up> ((bia, ba) \\<in> nat_rel) * true *\n (\\<exists>\\<^sub>Ax.\n     is_amtx N M x r *\n     \\<up>\n      (RETURN x\n       \\<le> RETURN (PR_CONST local.op_amtx_lin_set a ba b)))>\\<^sub>t", "unfolding is_amtx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi ba bia a ai.\n       \\<lbrakk>ba < N * M;\n        a ::\\<^sub>i TYPE(nat \\<times> nat \\<Rightarrow> 'a);\n        ba ::\\<^sub>i TYPE(nat); b ::\\<^sub>i TYPE('a);\n        nofail (RETURN (PR_CONST local.op_amtx_lin_set a ba b))\\<rbrakk>\n       \\<Longrightarrow> <\\<up> ((bi, b) \\<in> Id) *\n                          \\<up> ((bia, ba) \\<in> nat_rel) *\n                          (\\<exists>\\<^sub>Al.\n                              ai \\<mapsto>\\<^sub>a l *\n                              \\<up>\n                               (length l = N * M \\<and>\n                                (\\<forall>i<N.\n                                    \\<forall>j<M.\n l ! (i * M + j) = a (i, j)) \\<and>\n                                (\\<forall>i j.\n                                    N \\<le> i \\<or>\n                                    M \\<le> j \\<longrightarrow>\n                                    a (i, j) =\n                                    (0::'a))))> Array.upd bia bi\n           ai <\\<lambda>r.\n                  \\<up> ((bi, b) \\<in> Id) *\n                  \\<up> ((bia, ba) \\<in> nat_rel) *\n                  true *\n                  (\\<exists>\\<^sub>Ax.\n                      (\\<exists>\\<^sub>Al.\n                          r \\<mapsto>\\<^sub>a l *\n                          \\<up>\n                           (length l = N * M \\<and>\n                            (\\<forall>i<N.\n                                \\<forall>j<M.\n                                   l ! (i * M + j) = x (i, j)) \\<and>\n                            (\\<forall>i j.\n                                N \\<le> i \\<or> M \\<le> j \\<longrightarrow>\n                                x (i, j) = (0::'a)))) *\n                      \\<up>\n                       (RETURN x\n                        \\<le> RETURN\n                               (PR_CONST local.op_amtx_lin_set a ba\n                                 b)))>\\<^sub>t", "by (sep_auto simp: nth_list_update)"], ["proof (state)\nthis:\n  (uncurry2 (\\<lambda>m i x. Array.upd i x m),\n   uncurry2 (RETURN \\<circ>\\<circ>\\<circ> PR_CONST local.op_amtx_lin_set))\n  \\<in> [\\<lambda>((uu_, i), uu_).\n            i < N *\n                M]\\<^sub>a (is_amtx N M)\\<^sup>d *\\<^sub>a\n                           nat_assn\\<^sup>k *\\<^sub>a\n                           id_assn\\<^sup>k \\<rightarrow> is_amtx N M\n\ngoal:\nNo subgoals!", "qed"], ["", "sepref_decl_impl amtx_lin_set: op_amtx_lin_set_aref"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>((uu_, i), uu_). i < N * M,\n     \\<lambda>((uu_, i), uu_). i < N * M)\n    \\<in> (\\<langle>the_pure A\\<rangle>mtx_rel \\<times>\\<^sub>r\n           nat_rel) \\<times>\\<^sub>r\n          the_pure A \\<rightarrow>\n          bool_rel", "by auto"], ["", "end"], ["", "lemma amtx_fold_lin_get: \"m (i div M, i mod M) = op_amtx_lin_get M m i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m (i div M, i mod M) = op_amtx_lin_get M m i", "by simp"], ["", "lemma amtx_fold_lin_set: \"m ((i div M, i mod M) := x) = op_amtx_lin_set M m i x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m((i div M, i mod M) := x) = op_amtx_lin_set M m i x", "by simp"], ["", "locale amtx_pointwise_unop_impl = mtx_pointwise_unop_loc +\n    fixes A :: \"'a \\<Rightarrow> 'ai::{zero,heap} \\<Rightarrow> assn\"\n    fixes fi :: \"nat\\<times>nat \\<Rightarrow> 'ai \\<Rightarrow> 'ai Heap\"\n    assumes fi_hnr:\n      \"(uncurry fi,uncurry (RETURN oo f)) \\<in> (prod_assn nat_assn nat_assn)\\<^sup>k *\\<^sub>a A\\<^sup>k \\<rightarrow>\\<^sub>a A\"  \n  begin"], ["", "lemma this_loc: \"amtx_pointwise_unop_impl N M f A fi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. amtx_pointwise_unop_impl N M f A fi", "by unfold_locales"], ["", "context\n      assumes PURE: \"CONSTRAINT (IS_PURE PRES_ZERO_UNIQUE) A\"\n    begin"], ["", "context \n        notes [[sepref_register_adhoc f N M]]\n        notes [sepref_import_param] = IdI[of N] IdI[of M]\n        notes [sepref_fr_rules] = fi_hnr\n        notes [safe_constraint_rules] = PURE\n        notes [simp] = algebra_simps\n      begin"], ["", "sepref_thm opr_fold_impl1 is \"RETURN o opr_fold_impl\" :: \"(amtx_assn N M A)\\<^sup>d \\<rightarrow>\\<^sub>a amtx_assn N M A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     (RETURN \\<circ>\\<circ>\\<circ> mtx_pointwise_unop_loc.opr_fold_impl N) M\n      f)\n    \\<in> (amtx_assn N M A)\\<^sup>d \\<rightarrow>\\<^sub>a amtx_assn N M A", "unfolding opr_fold_impl_def fold_prod_divmod_conv'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     (RETURN \\<circ>\\<circ>\\<circ> fold)\n      (\\<lambda>i m. m\n          ((i div M, i mod M) :=\n             f (i div M, i mod M) (m (i div M, i mod M))))\n      [0..<M * N])\n    \\<in> (amtx_assn N M A)\\<^sup>d \\<rightarrow>\\<^sub>a amtx_assn N M A", "apply (rewrite amtx_fold_lin_set)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     (RETURN \\<circ>\\<circ>\\<circ> fold)\n      (\\<lambda>i m.\n          op_amtx_lin_set M m i\n           (f (i div M, i mod M) (m (i div M, i mod M))))\n      [0..<M * N])\n    \\<in> (amtx_assn N M A)\\<^sup>d \\<rightarrow>\\<^sub>a amtx_assn N M A", "apply (rewrite in \"f _ \\<hole>\" amtx_fold_lin_get)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     (RETURN \\<circ>\\<circ>\\<circ> fold)\n      (\\<lambda>i m.\n          op_amtx_lin_set M m i\n           (f (i div M, i mod M) (op_amtx_lin_get M m i)))\n      [0..<M * N])\n    \\<in> (amtx_assn N M A)\\<^sup>d \\<rightarrow>\\<^sub>a amtx_assn N M A", "by sepref"], ["", "end"], ["", "end"], ["", "concrete_definition (in -) amtx_pointwise_unnop_fold_impl1 uses amtx_pointwise_unop_impl.opr_fold_impl1.refine_raw"], ["", "prepare_code_thms (in -) amtx_pointwise_unnop_fold_impl1_def"], ["", "lemma op_hnr[sepref_fr_rules]: \n      assumes PURE: \"CONSTRAINT (IS_PURE PRES_ZERO_UNIQUE) A\"\n      shows \"(amtx_pointwise_unnop_fold_impl1 N M fi, RETURN \\<circ> PR_CONST (mtx_pointwise_unop f)) \\<in> (amtx_assn N M A)\\<^sup>d \\<rightarrow>\\<^sub>a amtx_assn N M A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (amtx_pointwise_unnop_fold_impl1 N M fi,\n     (RETURN \\<circ>\\<circ> PR_CONST) (mtx_pointwise_unop f))\n    \\<in> (amtx_assn N M A)\\<^sup>d \\<rightarrow>\\<^sub>a amtx_assn N M A", "unfolding PR_CONST_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (amtx_pointwise_unnop_fold_impl1 N M fi,\n     (RETURN \\<circ>\\<circ> mtx_pointwise_unop) f)\n    \\<in> (amtx_assn N M A)\\<^sup>d \\<rightarrow>\\<^sub>a amtx_assn N M A", "apply (rule hfref_weaken_pre'[OF _ amtx_pointwise_unnop_fold_impl1.refine[OF this_loc PURE,FCOMP opr_fold_impl_refine]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>True; rdomp (fst ((amtx_assn N M A)\\<^sup>d)) x\\<rbrakk>\n       \\<Longrightarrow> mtx_nonzero x \\<subseteq> {0..<N} \\<times> {0..<M}", "by (simp add: amtx_assn_bounded[OF PURE])"], ["", "end"], ["", "locale amtx_pointwise_binop_impl = mtx_pointwise_binop_loc +\n    fixes A :: \"'a \\<Rightarrow> 'ai::{zero,heap} \\<Rightarrow> assn\"\n    fixes fi :: \"'ai \\<Rightarrow> 'ai \\<Rightarrow> 'ai Heap\"\n    assumes fi_hnr: \"(uncurry fi,uncurry (RETURN oo f)) \\<in> A\\<^sup>k *\\<^sub>a A\\<^sup>k \\<rightarrow>\\<^sub>a A\"  \n  begin"], ["", "lemma this_loc: \"amtx_pointwise_binop_impl f A fi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. amtx_pointwise_binop_impl f A fi", "by unfold_locales"], ["", "context \n      notes [[sepref_register_adhoc f N M]]\n      notes [sepref_import_param] = IdI[of N] IdI[of M]\n      notes [sepref_fr_rules] = fi_hnr\n      assumes PURE[safe_constraint_rules]: \"CONSTRAINT (IS_PURE PRES_ZERO_UNIQUE) A\"\n      notes [simp] = algebra_simps\n    begin"], ["", "sepref_thm opr_fold_impl1 is \"uncurry (RETURN oo opr_fold_impl)\" :: \"(amtx_assn N M A)\\<^sup>d*\\<^sub>a(amtx_assn N M A)\\<^sup>k \\<rightarrow>\\<^sub>a amtx_assn N M A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      ((RETURN \\<circ>\\<circ>\\<circ>\n        mtx_pointwise_binop_loc.opr_fold_impl N M)\n        f))\n    \\<in> (amtx_assn N M A)\\<^sup>d *\\<^sub>a\n          (amtx_assn N M A)\\<^sup>k \\<rightarrow>\\<^sub>a amtx_assn N M A", "unfolding opr_fold_impl_def[abs_def] fold_prod_divmod_conv'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>x.\n          RETURN \\<circ>\n          (\\<lambda>n.\n              fold\n               (\\<lambda>i m. m\n                   ((i div M, i mod M) :=\n                      f (m (i div M, i mod M)) (n (i div M, i mod M))))\n               [0..<M * N] x)))\n    \\<in> (amtx_assn N M A)\\<^sup>d *\\<^sub>a\n          (amtx_assn N M A)\\<^sup>k \\<rightarrow>\\<^sub>a amtx_assn N M A", "apply (rewrite amtx_fold_lin_set)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>x.\n          RETURN \\<circ>\n          (\\<lambda>n.\n              fold\n               (\\<lambda>i m.\n                   op_amtx_lin_set M m i\n                    (f (m (i div M, i mod M)) (n (i div M, i mod M))))\n               [0..<M * N] x)))\n    \\<in> (amtx_assn N M A)\\<^sup>d *\\<^sub>a\n          (amtx_assn N M A)\\<^sup>k \\<rightarrow>\\<^sub>a amtx_assn N M A", "apply (rewrite in \"f \\<hole> _\" amtx_fold_lin_get)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>x.\n          RETURN \\<circ>\n          (\\<lambda>n.\n              fold\n               (\\<lambda>i m.\n                   op_amtx_lin_set M m i\n                    (f (op_amtx_lin_get M m i) (n (i div M, i mod M))))\n               [0..<M * N] x)))\n    \\<in> (amtx_assn N M A)\\<^sup>d *\\<^sub>a\n          (amtx_assn N M A)\\<^sup>k \\<rightarrow>\\<^sub>a amtx_assn N M A", "apply (rewrite in \"f _ \\<hole>\" amtx_fold_lin_get)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>x.\n          RETURN \\<circ>\n          (\\<lambda>n.\n              fold\n               (\\<lambda>i m.\n                   op_amtx_lin_set M m i\n                    (f (op_amtx_lin_get M m i) (op_amtx_lin_get M n i)))\n               [0..<M * N] x)))\n    \\<in> (amtx_assn N M A)\\<^sup>d *\\<^sub>a\n          (amtx_assn N M A)\\<^sup>k \\<rightarrow>\\<^sub>a amtx_assn N M A", "by sepref"], ["", "end"], ["", "concrete_definition (in -) amtx_pointwise_binop_fold_impl1 for fi N M\n      uses amtx_pointwise_binop_impl.opr_fold_impl1.refine_raw is \"(uncurry ?f,_)\\<in>_\""], ["", "prepare_code_thms (in -) amtx_pointwise_binop_fold_impl1_def"], ["", "lemma op_hnr[sepref_fr_rules]: \n      assumes PURE: \"CONSTRAINT (IS_PURE PRES_ZERO_UNIQUE) A\"\n      shows \"(uncurry (amtx_pointwise_binop_fold_impl1 fi N M), uncurry (RETURN oo PR_CONST (mtx_pointwise_binop f))) \\<in> (amtx_assn N M A)\\<^sup>d *\\<^sub>a (amtx_assn N M A)\\<^sup>k \\<rightarrow>\\<^sub>a amtx_assn N M A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry (amtx_pointwise_binop_fold_impl1 fi N M),\n     uncurry\n      ((RETURN \\<circ>\\<circ>\\<circ> PR_CONST) (mtx_pointwise_binop f)))\n    \\<in> (amtx_assn N M A)\\<^sup>d *\\<^sub>a\n          (amtx_assn N M A)\\<^sup>k \\<rightarrow>\\<^sub>a amtx_assn N M A", "unfolding PR_CONST_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry (amtx_pointwise_binop_fold_impl1 fi N M),\n     uncurry ((RETURN \\<circ>\\<circ>\\<circ> mtx_pointwise_binop) f))\n    \\<in> (amtx_assn N M A)\\<^sup>d *\\<^sub>a\n          (amtx_assn N M A)\\<^sup>k \\<rightarrow>\\<^sub>a amtx_assn N M A", "apply (rule hfref_weaken_pre'[OF _ amtx_pointwise_binop_fold_impl1.refine[OF this_loc PURE,FCOMP opr_fold_impl_refine]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>True;\n        rdomp\n         (fst ((amtx_assn N M A)\\<^sup>d *\\<^sub>a\n               (amtx_assn N M A)\\<^sup>k))\n         x\\<rbrakk>\n       \\<Longrightarrow> case x of\n                         (a, b) \\<Rightarrow>\n                           mtx_nonzero a\n                           \\<subseteq> {0..<N} \\<times> {0..<M} \\<and>\n                           mtx_nonzero b\n                           \\<subseteq> {0..<N} \\<times> {0..<M}", "apply (auto dest: amtx_assn_bounded[OF PURE])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "locale amtx_pointwise_cmpop_impl = mtx_pointwise_cmpop_loc +\n    fixes A :: \"'a \\<Rightarrow> 'ai::{zero,heap} \\<Rightarrow> assn\"\n    fixes fi :: \"'ai \\<Rightarrow> 'ai \\<Rightarrow> bool Heap\"\n    fixes gi :: \"'ai \\<Rightarrow> 'ai \\<Rightarrow> bool Heap\"\n    assumes fi_hnr:\n      \"(uncurry fi,uncurry (RETURN oo f)) \\<in> A\\<^sup>k *\\<^sub>a A\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\"  \n    assumes gi_hnr:\n      \"(uncurry gi,uncurry (RETURN oo g)) \\<in> A\\<^sup>k *\\<^sub>a A\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\"  \n  begin"], ["", "lemma this_loc: \"amtx_pointwise_cmpop_impl f g A fi gi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. amtx_pointwise_cmpop_impl f g A fi gi", "by unfold_locales"], ["", "context \n      notes [[sepref_register_adhoc f g N M]]\n      notes [sepref_import_param] = IdI[of N] IdI[of M]\n      notes [sepref_fr_rules] = fi_hnr gi_hnr\n      assumes PURE[safe_constraint_rules]: \"CONSTRAINT (IS_PURE PRES_ZERO_UNIQUE) A\"\n    begin"], ["", "sepref_thm opr_fold_impl1 is \"uncurry opr_fold_impl\" :: \"(amtx_assn N M A)\\<^sup>d*\\<^sub>a(amtx_assn N M A)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry opr_fold_impl)\n    \\<in> (amtx_assn N M A)\\<^sup>d *\\<^sub>a\n          (amtx_assn N M A)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "unfolding opr_fold_impl_def[abs_def] nfoldli_prod_divmod_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>m n.\n          nfoldli [0..<N * M] (\\<lambda>s. s \\<noteq> 2)\n           (\\<lambda>i s.\n               if f (m (i div M, i mod M)) (n (i div M, i mod M))\n               then if s = 0\n                    then if g (m (i div M, i mod M)) (n (i div M, i mod M))\n                         then RETURN 1 else RETURN s\n                    else RETURN s\n               else RETURN 2)\n           0 \\<bind>\n          (\\<lambda>s. RETURN (s = 1))))\n    \\<in> (amtx_assn N M A)\\<^sup>d *\\<^sub>a\n          (amtx_assn N M A)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "apply (rewrite in \"f \\<hole> _\" amtx_fold_lin_get)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>m n.\n          nfoldli [0..<N * M] (\\<lambda>s. s \\<noteq> 2)\n           (\\<lambda>i s.\n               if f (op_amtx_lin_get M m i) (n (i div M, i mod M))\n               then if s = 0\n                    then if g (m (i div M, i mod M)) (n (i div M, i mod M))\n                         then RETURN 1 else RETURN s\n                    else RETURN s\n               else RETURN 2)\n           0 \\<bind>\n          (\\<lambda>s. RETURN (s = 1))))\n    \\<in> (amtx_assn N M A)\\<^sup>d *\\<^sub>a\n          (amtx_assn N M A)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "apply (rewrite in \"f _ \\<hole>\" amtx_fold_lin_get)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>m n.\n          nfoldli [0..<N * M] (\\<lambda>s. s \\<noteq> 2)\n           (\\<lambda>i s.\n               if f (op_amtx_lin_get M m i) (op_amtx_lin_get M n i)\n               then if s = 0\n                    then if g (m (i div M, i mod M)) (n (i div M, i mod M))\n                         then RETURN 1 else RETURN s\n                    else RETURN s\n               else RETURN 2)\n           0 \\<bind>\n          (\\<lambda>s. RETURN (s = 1))))\n    \\<in> (amtx_assn N M A)\\<^sup>d *\\<^sub>a\n          (amtx_assn N M A)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "apply (rewrite in \"g \\<hole> _\" amtx_fold_lin_get)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>m n.\n          nfoldli [0..<N * M] (\\<lambda>s. s \\<noteq> 2)\n           (\\<lambda>i s.\n               if f (op_amtx_lin_get M m i) (op_amtx_lin_get M n i)\n               then if s = 0\n                    then if g (op_amtx_lin_get M m i) (n (i div M, i mod M))\n                         then RETURN 1 else RETURN s\n                    else RETURN s\n               else RETURN 2)\n           0 \\<bind>\n          (\\<lambda>s. RETURN (s = 1))))\n    \\<in> (amtx_assn N M A)\\<^sup>d *\\<^sub>a\n          (amtx_assn N M A)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "apply (rewrite in \"g _ \\<hole>\" amtx_fold_lin_get)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>m n.\n          nfoldli [0..<N * M] (\\<lambda>s. s \\<noteq> 2)\n           (\\<lambda>i s.\n               if f (op_amtx_lin_get M m i) (op_amtx_lin_get M n i)\n               then if s = 0\n                    then if g (op_amtx_lin_get M m i)\n                             (op_amtx_lin_get M n i)\n                         then RETURN 1 else RETURN s\n                    else RETURN s\n               else RETURN 2)\n           0 \\<bind>\n          (\\<lambda>s. RETURN (s = 1))))\n    \\<in> (amtx_assn N M A)\\<^sup>d *\\<^sub>a\n          (amtx_assn N M A)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "by sepref"], ["", "end"], ["", "concrete_definition (in -) amtx_pointwise_cmpop_fold_impl1 for N M fi gi\n      uses amtx_pointwise_cmpop_impl.opr_fold_impl1.refine_raw is \"(uncurry ?f,_)\\<in>_\""], ["", "prepare_code_thms (in -) amtx_pointwise_cmpop_fold_impl1_def"], ["", "lemma op_hnr[sepref_fr_rules]: \n      assumes PURE: \"CONSTRAINT (IS_PURE PRES_ZERO_UNIQUE) A\"\n      shows \"(uncurry (amtx_pointwise_cmpop_fold_impl1 N M fi gi), uncurry (RETURN oo PR_CONST (mtx_pointwise_cmpop f g))) \\<in> (amtx_assn N M A)\\<^sup>d *\\<^sub>a (amtx_assn N M A)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry (amtx_pointwise_cmpop_fold_impl1 N M fi gi),\n     uncurry\n      ((RETURN \\<circ>\\<circ>\\<circ> PR_CONST) (mtx_pointwise_cmpop f g)))\n    \\<in> (amtx_assn N M A)\\<^sup>d *\\<^sub>a\n          (amtx_assn N M A)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "unfolding PR_CONST_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry (amtx_pointwise_cmpop_fold_impl1 N M fi gi),\n     uncurry ((RETURN \\<circ>\\<circ>\\<circ> mtx_pointwise_cmpop f) g))\n    \\<in> (amtx_assn N M A)\\<^sup>d *\\<^sub>a\n          (amtx_assn N M A)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "apply (rule hfref_weaken_pre'[OF _ amtx_pointwise_cmpop_fold_impl1.refine[OF this_loc PURE,FCOMP opr_fold_impl_refine]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>True;\n        rdomp\n         (fst ((amtx_assn N M A)\\<^sup>d *\\<^sub>a\n               (amtx_assn N M A)\\<^sup>k))\n         x\\<rbrakk>\n       \\<Longrightarrow> case x of\n                         (a, b) \\<Rightarrow>\n                           mtx_nonzero a\n                           \\<subseteq> {0..<N} \\<times> {0..<M} \\<and>\n                           mtx_nonzero b\n                           \\<subseteq> {0..<N} \\<times> {0..<M}", "apply (auto dest: amtx_assn_bounded[OF PURE])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsection \\<open>Regression Test and Usage Example\\<close>"], ["", "context begin"], ["", "text \\<open>To work with a matrix, the dimension should be fixed in a context\\<close>"], ["", "context\n      fixes N M :: nat\n      \\<comment> \\<open>We also register the dimension as an operation, such that we can \n        use it like a constant\\<close>\n      notes [[sepref_register_adhoc N M]] \n      notes [sepref_import_param] = IdI[of N] IdI[of M]\n      \\<comment> \\<open>Finally, we fix a type variable with the required type classes for matrix entries\\<close>\n      fixes dummy:: \"'a::{times,zero,heap}\"\n    begin"], ["", "text \\<open>First, we implement scalar multiplication with destructive update \n        of the matrix:\\<close>"], ["", "private"], ["", "definition scmul :: \"'a \\<Rightarrow> 'a mtx \\<Rightarrow> 'a mtx nres\" where\n        \"scmul x m \\<equiv> nfoldli [0..<N] (\\<lambda>_. True) (\\<lambda>i m. \n          nfoldli [0..<M] (\\<lambda>_. True) (\\<lambda>j m. do {\n              let mij = m(i,j);\n              RETURN (m((i,j) := x * mij))\n            }\n          ) m\n        ) m\""], ["", "text \\<open>After declaration of an implementation for multiplication,\n        refinement is straightforward. Note that we use the fixed @{term N} in\n        the refinement assertions.\\<close>"], ["", "private"], ["", "lemma times_param: \"((*),(*)::'a\\<Rightarrow>_) \\<in> Id \\<rightarrow> Id \\<rightarrow> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((*), (*)) \\<in> Id \\<rightarrow> Id \\<rightarrow> Id", "by simp"], ["", "context\n        notes [sepref_import_param] = times_param\n      begin"], ["", "sepref_definition scmul_impl \n          is \"uncurry scmul\" :: \"(id_assn\\<^sup>k *\\<^sub>a (amtx_assn N M id_assn)\\<^sup>d \\<rightarrow>\\<^sub>a amtx_assn N M id_assn)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry scmul)\n    \\<in> id_assn\\<^sup>k *\\<^sub>a\n          (amtx_assn N M\n            id_assn)\\<^sup>d \\<rightarrow>\\<^sub>a amtx_assn N M id_assn", "unfolding scmul_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>x.\n          nfoldli [0..<N] (\\<lambda>_. True)\n           (\\<lambda>i.\n               nfoldli [0..<M] (\\<lambda>_. True)\n                (\\<lambda>j m.\n                    let mij = m (i, j) in RETURN (m((i, j) := x * mij))))))\n    \\<in> id_assn\\<^sup>k *\\<^sub>a\n          (amtx_assn N M\n            id_assn)\\<^sup>d \\<rightarrow>\\<^sub>a amtx_assn N M id_assn", "by sepref"], ["", "end"], ["", "text \\<open>Initialization with default value\\<close>"], ["", "private"], ["", "definition \"init_test \\<equiv> do {\n        let m = op_amtx_dfltNxM 10 5 (0::nat);\n        RETURN (m(1,2))\n      }\""], ["", "private"], ["", "sepref_definition init_test_impl is \"uncurry0 init_test\" :: \"unit_assn\\<^sup>k\\<rightarrow>\\<^sub>anat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2, uncurry0 init_test)\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "unfolding init_test_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2,\n     uncurry0 (let m = op_amtx_dfltNxM 10 5 0 in RETURN (m (1, 2))))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "by sepref"], ["", "text \\<open>Initialization from function diagonal is more complicated:\n        First, we have to define the function as a new constant\\<close>"], ["", "(* TODO: PR_CONST option for sepref-register! *)  \n      qualified"], ["", "definition \"diagonalN k \\<equiv> \\<lambda>(i,j). if i=j \\<and> j<N then k else 0\""], ["", "text \\<open>If it carries implicit parameters, we have to wrap it into a @{term PR_CONST} tag:\\<close>"], ["", "private"], ["", "sepref_register \"PR_CONST diagonalN\""], ["", "private"], ["", "lemma [def_pat_rules]: \"IICF_Array_Matrix.diagonalN$N \\<equiv> UNPROTECT diagonalN\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IICF_Array_Matrix.diagonalN $ N \\<equiv> UNPROTECT diagonalN", "by simp"], ["", "text \\<open>Then, we have to implement the constant, where the result assertion must be for a \n        pure function. Note that, due to technical reasons, we need the \\<open>the_pure\\<close> in the function type,\n        and the refinement rule to be parameterized over an assertion variable (here \\<open>A\\<close>).\n        Of course, you can constrain \\<open>A\\<close> further, e.g., @{term \"CONSTRAINT (IS_PURE IS_ID) (A::int \\<Rightarrow> int \\<Rightarrow> assn)\"}\n        \\<close>"], ["", "private"], ["", "lemma diagonalN_hnr[sepref_fr_rules]:\n        assumes \"CONSTRAINT (IS_PURE PRES_ZERO_UNIQUE) A\"\n        (*assumes \"CONSTRAINT (IS_PURE IS_ID) (A::int \\<Rightarrow> int \\<Rightarrow> assn)\"*)\n        shows \"(return o diagonalN, RETURN o (PR_CONST diagonalN)) \\<in> A\\<^sup>k \\<rightarrow>\\<^sub>a pure (nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow> the_pure A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((return \\<circ>\\<circ> IICF_Array_Matrix.diagonalN) N,\n     (RETURN \\<circ>\\<circ> PR_CONST) diagonalN)\n    \\<in> A\\<^sup>k \\<rightarrow>\\<^sub>a pure\n     (nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow> the_pure A)", "using assms"], ["proof (prove)\nusing this:\n  CONSTRAINT (IS_PURE PRES_ZERO_UNIQUE) A\n\ngoal (1 subgoal):\n 1. ((return \\<circ>\\<circ> IICF_Array_Matrix.diagonalN) N,\n     (RETURN \\<circ>\\<circ> PR_CONST) diagonalN)\n    \\<in> A\\<^sup>k \\<rightarrow>\\<^sub>a pure\n     (nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow> the_pure A)", "apply sepref_to_hoare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xi.\n       \\<lbrakk>CONSTRAINT (IS_PURE PRES_ZERO_UNIQUE) A; hfsynth_ID_R A x;\n        nofail (RETURN (PR_CONST diagonalN x))\\<rbrakk>\n       \\<Longrightarrow> <A x xi> return\n                                   (diagonalN\n                                     xi) <\\<lambda>r.\n       A x xi *\n       (\\<exists>\\<^sub>Axa.\n           \\<up>\n            ((r, xa)\n             \\<in> nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow>\n                   the_pure A) *\n           \\<up> (RETURN xa \\<le> RETURN (PR_CONST diagonalN x)))>\\<^sub>t", "apply (sep_auto simp: diagonalN_def is_pure_conv IS_PURE_def PRES_ZERO_UNIQUE_def (*IS_ID_def*))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>In order to discharge preconditions, we need to prove some auxiliary lemma \n        that non-zero indexes are within range\\<close>"], ["", "lemma diagonal_nonzero_ltN[simp]: \"(a,b)\\<in>mtx_nonzero (diagonalN k) \\<Longrightarrow> a<N \\<and> b<N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> mtx_nonzero (diagonalN k) \\<Longrightarrow>\n    a < N \\<and> b < N", "by (auto simp: mtx_nonzero_def diagonalN_def split: if_split_asm)"], ["", "private"], ["", "definition \"init_test2 \\<equiv> do {\n        ASSERT (N>2); \\<comment> \\<open>Ensure that the coordinate \\<open>(1,2)\\<close> is valid\\<close>\n        let m = op_mtx_new (diagonalN (1::int));\n        RETURN (m(1,2))\n      }\""], ["", "private"], ["", "sepref_definition init_test2_impl is \"uncurry0 init_test2\" :: \"unit_assn\\<^sup>k\\<rightarrow>\\<^sub>aint_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2, uncurry0 init_test2)\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a int_assn", "unfolding init_test2_def amtx_fold_custom_new[of N N]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2,\n     uncurry0\n      (ASSERT (2 < N) \\<bind>\n       (\\<lambda>_.\n           let m = op_amtx_new N N (diagonalN 1) in RETURN (m (1, 2)))))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a int_assn", "by sepref"], ["", "end"], ["", "export_code scmul_impl in SML_imp"], ["", "end"], ["", "hide_const scmul_impl"], ["", "hide_const(open) is_amtx"], ["", "end"]]}