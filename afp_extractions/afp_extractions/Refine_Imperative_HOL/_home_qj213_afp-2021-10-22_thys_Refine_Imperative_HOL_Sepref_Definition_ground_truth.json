{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/Sepref_Definition.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemma heap_fixp_codegen:\n    assumes DEF: \"f \\<equiv> heap.fixp_fun cB\"\n    assumes M: \"(\\<And>x. mono_Heap (\\<lambda>f. cB f x))\"\n    shows \"f x = cB f x\"", "lemma [synth_rules]: \"CP_UNCURRY f g\"", "lemma [synth_rules]: \"CP_UNCURRY (uncurry0 f) (uncurry0 g)\"", "lemma [synth_rules]: \"CP_UNCURRY f g \\<Longrightarrow> CP_UNCURRY (uncurry f) (uncurry g)\"", "lemma [synth_rules]: \"\\<lbrakk>INTRO_KD R1 R1'; INTRO_KD R2 R2'\\<rbrakk> \\<Longrightarrow> INTRO_KD (R1*\\<^sub>aR2) (R1'*\\<^sub>aR2')\"", "lemma [synth_rules]: \"INTRO_KD (R\\<^sup>?) (hf_pres R k)\"", "lemma [synth_rules]: \"INTRO_KD (R\\<^sup>k) (R\\<^sup>k)\"", "lemma [synth_rules]: \"INTRO_KD (R\\<^sup>d) (R\\<^sup>d)\"", "lemma [synth_rules]: \"SPEC_RES_ASSN R R\"", "lemma [synth_rules]: \"SPEC_RES_ASSN UNSPEC R\"", "lemma synth_hnrI:\n    \"\\<lbrakk>CP_UNCURRY fi f; INTRO_KD R R'; SPEC_RES_ASSN S S'\\<rbrakk> \\<Longrightarrow> SYNTH_TERM (SYNTH f ([P]\\<^sub>a R\\<rightarrow>S)) ((fi,SDUMMY)\\<in>SDUMMY,(fi,f)\\<in>([P]\\<^sub>a R'\\<rightarrow>S'))\""], "translations": [["", "lemma heap_fixp_codegen:\n    assumes DEF: \"f \\<equiv> heap.fixp_fun cB\"\n    assumes M: \"(\\<And>x. mono_Heap (\\<lambda>f. cB f x))\"\n    shows \"f x = cB f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x = cB f x", "unfolding DEF"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap.fixp_fun cB x = cB (heap.fixp_fun cB) x", "apply (rule fun_cong[of _ _ x])"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap.fixp_fun cB = cB (heap.fixp_fun cB)", "apply (rule heap.mono_body_fixp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. mono_Heap (\\<lambda>f. cB f x)", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "ML \\<open>\n    structure Sepref_Extraction = struct\n      val heap_extraction: Refine_Automation.extraction = {\n          pattern = Logic.varify_global @{term \"heap.fixp_fun x\"},\n          gen_thm = @{thm heap_fixp_codegen},\n          gen_tac = (fn ctxt => \n            Pf_Mono_Prover.mono_tac ctxt\n          )\n        }\n\n      val setup = I \n        (*#> Refine_Automation.add_extraction \"trivial\" triv_extraction*)\n        #> Refine_Automation.add_extraction \"heap\" heap_extraction\n\n    end\n    \\<close>"], ["", "setup Sepref_Extraction.setup"], ["", "subsection \\<open>Synthesis setup for sepref-definition goals\\<close>"], ["", "(* TODO: The UNSPEC are an ad-hoc hack to specify the synthesis goal *)"], ["", "consts UNSPEC::'a"], ["", "abbreviation hfunspec \n    :: \"('a \\<Rightarrow> 'b \\<Rightarrow> assn) \\<Rightarrow> ('a \\<Rightarrow> 'b \\<Rightarrow> assn)\\<times>('a \\<Rightarrow> 'b \\<Rightarrow> assn)\" \n    (\"(_\\<^sup>?)\" [1000] 999)\n    where \"R\\<^sup>? \\<equiv> hf_pres R UNSPEC\""], ["", "definition SYNTH :: \"('a \\<Rightarrow> 'r nres) \\<Rightarrow> (('ai \\<Rightarrow>'ri Heap) \\<times> ('a \\<Rightarrow> 'r nres)) set \\<Rightarrow> bool\"\n    where \"SYNTH f R \\<equiv> True\""], ["", "definition [simp]: \"CP_UNCURRY _ _ \\<equiv> True\""], ["", "definition [simp]: \"INTRO_KD _ _ \\<equiv> True\""], ["", "definition [simp]: \"SPEC_RES_ASSN _ _ \\<equiv> True\""], ["", "lemma [synth_rules]: \"CP_UNCURRY f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CP_UNCURRY f g", "by simp"], ["", "lemma [synth_rules]: \"CP_UNCURRY (uncurry0 f) (uncurry0 g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CP_UNCURRY (uncurry0 f) (uncurry0 g)", "by simp"], ["", "lemma [synth_rules]: \"CP_UNCURRY f g \\<Longrightarrow> CP_UNCURRY (uncurry f) (uncurry g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CP_UNCURRY f g \\<Longrightarrow> CP_UNCURRY (uncurry f) (uncurry g)", "by simp"], ["", "lemma [synth_rules]: \"\\<lbrakk>INTRO_KD R1 R1'; INTRO_KD R2 R2'\\<rbrakk> \\<Longrightarrow> INTRO_KD (R1*\\<^sub>aR2) (R1'*\\<^sub>aR2')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>INTRO_KD R1 R1'; INTRO_KD R2 R2'\\<rbrakk>\n    \\<Longrightarrow> INTRO_KD (R1 *\\<^sub>a R2) (R1' *\\<^sub>a R2')", "by simp"], ["", "lemma [synth_rules]: \"INTRO_KD (R\\<^sup>?) (hf_pres R k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. INTRO_KD (R\\<^sup>?) (hf_pres R k)", "by simp"], ["", "lemma [synth_rules]: \"INTRO_KD (R\\<^sup>k) (R\\<^sup>k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. INTRO_KD (R\\<^sup>k) (R\\<^sup>k)", "by simp"], ["", "lemma [synth_rules]: \"INTRO_KD (R\\<^sup>d) (R\\<^sup>d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. INTRO_KD (R\\<^sup>d) (R\\<^sup>d)", "by simp"], ["", "lemma [synth_rules]: \"SPEC_RES_ASSN R R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SPEC_RES_ASSN R R", "by simp"], ["", "lemma [synth_rules]: \"SPEC_RES_ASSN UNSPEC R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SPEC_RES_ASSN UNSPEC R", "by simp"], ["", "lemma synth_hnrI:\n    \"\\<lbrakk>CP_UNCURRY fi f; INTRO_KD R R'; SPEC_RES_ASSN S S'\\<rbrakk> \\<Longrightarrow> SYNTH_TERM (SYNTH f ([P]\\<^sub>a R\\<rightarrow>S)) ((fi,SDUMMY)\\<in>SDUMMY,(fi,f)\\<in>([P]\\<^sub>a R'\\<rightarrow>S'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>CP_UNCURRY fi f; INTRO_KD R R'; SPEC_RES_ASSN S S'\\<rbrakk>\n    \\<Longrightarrow> SYNTH_TERM (SYNTH f ([P]\\<^sub>a R \\<rightarrow> S))\n                       ((fi, SDUMMY) \\<in> SDUMMY,\n                        (fi, f) \\<in> [P]\\<^sub>a R' \\<rightarrow> S')", "by (simp add: SYNTH_def)"], ["", "term starts_with"], ["", "ML \\<open>\n  structure Sepref_Definition = struct\n    fun make_hnr_goal t ctxt = let\n      val ctxt = Variable.declare_term t ctxt\n      val (pat,goal) = case Term_Synth.synth_term @{thms synth_hnrI} ctxt t of\n        @{mpat \"(?pat,?goal)\"} => (pat,goal) | t => raise TERM(\"Synthesized term does not match\",[t])\n      val pat = Thm.cterm_of ctxt pat |> Refine_Automation.prepare_cd_pattern ctxt\n      val goal = HOLogic.mk_Trueprop goal\n    in\n      ((pat,goal),ctxt)\n    end\n\n    val cfg_prep_code = Attrib.setup_config_bool @{binding sepref_definition_prep_code} (K true)\n\n    local \n      open Refine_Util\n      val flags = parse_bool_config' \"prep_code\" cfg_prep_code\n      val parse_flags = parse_paren_list' flags  \n\n    in       \n      val sd_parser = parse_flags -- Parse.binding -- Parse.opt_attribs --| @{keyword \"is\"} \n        -- Parse.term --| @{keyword \"::\"} -- Parse.term\n    end  \n\n    fun mk_synth_term ctxt t_raw r_raw = let\n        val t = Syntax.parse_term ctxt t_raw\n        val r = Syntax.parse_term ctxt r_raw\n        val t = Const (@{const_name SYNTH},dummyT)$t$r\n      in\n        Syntax.check_term ctxt t\n      end  \n\n\n    fun sd_cmd ((((flags,name),attribs),t_raw),r_raw) lthy = let\n      local\n        val ctxt = Refine_Util.apply_configs flags lthy\n      in\n        val flag_prep_code = Config.get ctxt cfg_prep_code\n      end\n\n      val t = mk_synth_term lthy t_raw r_raw\n\n      val ((pat,goal),ctxt) = make_hnr_goal t lthy\n      \n      fun \n        after_qed [[thm]] ctxt = let\n            val thm = singleton (Variable.export ctxt lthy) thm\n\n            val (_,lthy) \n              = Local_Theory.note \n                 ((Refine_Automation.mk_qualified (Binding.name_of name) \"refine_raw\",[]),[thm]) \n                 lthy;\n\n            val ((dthm,rthm),lthy) = Refine_Automation.define_concrete_fun NONE name attribs [] thm [pat] lthy\n\n            val lthy = lthy \n              |> flag_prep_code ? Refine_Automation.extract_recursion_eqs \n                [Sepref_Extraction.heap_extraction] (Binding.name_of name) dthm\n\n            val _ = Thm.pretty_thm lthy dthm |> Pretty.string_of |> writeln\n            val _ = Thm.pretty_thm lthy rthm |> Pretty.string_of |> writeln\n          in\n            lthy\n          end\n        | after_qed thmss _ = raise THM (\"After-qed: Wrong thmss structure\",~1,flat thmss)\n\n    in\n      Proof.theorem NONE after_qed [[ (goal,[]) ]] ctxt\n    end\n\n\n\n    val _ = Outer_Syntax.local_theory_to_proof @{command_keyword \"sepref_definition\"}\n      \"Synthesis of imperative program\"\n      (sd_parser >> sd_cmd)\n\n    val st_parser = Parse.binding --| @{keyword \"is\"} -- Parse.term --| @{keyword \"::\"} -- Parse.term\n\n    fun st_cmd ((name,t_raw),r_raw) lthy = let\n      val t = mk_synth_term lthy t_raw r_raw\n      val ((_,goal),ctxt) = make_hnr_goal t lthy\n      \n      fun \n        after_qed [[thm]] ctxt = let\n            val thm = singleton (Variable.export ctxt lthy) thm\n\n            val _ = Thm.pretty_thm lthy thm |> Pretty.string_of |> tracing\n  \n            val (_,lthy) \n              = Local_Theory.note \n                 ((Refine_Automation.mk_qualified (Binding.name_of name) \"refine_raw\",[]),[thm]) \n                 lthy;\n\n          in\n            lthy\n          end\n        | after_qed thmss _ = raise THM (\"After-qed: Wrong thmss structure\",~1,flat thmss)\n\n    in\n      Proof.theorem NONE after_qed [[ (goal,[]) ]] ctxt\n    end\n\n    val _ = Outer_Syntax.local_theory_to_proof @{command_keyword \"sepref_thm\"}\n      \"Synthesis of imperative program: Only generate raw refinement theorem\"\n      (st_parser >> st_cmd)\n\n  end\n\\<close>"], ["", "end"]]}