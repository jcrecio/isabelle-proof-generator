{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/IICF/Impl/IICF_Array_List.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemma is_array_list_prec[safe_constraint_rules]: \"precise is_array_list\"", "lemma arl_empty_rule[sep_heap_rules]: \"< emp > arl_empty <is_array_list []>\"", "lemma arl_empty_sz_rule[sep_heap_rules]: \"< emp > arl_empty_sz N <is_array_list []>\"", "lemma arl_copy_rule[sep_heap_rules]: \"< is_array_list l a > arl_copy a <\\<lambda>r. is_array_list l a * is_array_list l r>\"", "lemma arl_append_rule[sep_heap_rules]: \"\n    < is_array_list l a > \n      arl_append a x \n    <\\<lambda>a. is_array_list (l@[x]) a >\\<^sub>t\"", "lemma arl_length_rule[sep_heap_rules]: \"\n    <is_array_list l a> \n      arl_length a\n    <\\<lambda>r. is_array_list l a * \\<up>(r=length l)>\"", "lemma arl_is_empty_rule[sep_heap_rules]: \"\n    <is_array_list l a> \n      arl_is_empty a\n    <\\<lambda>r. is_array_list l a * \\<up>(r\\<longleftrightarrow>(l=[]))>\"", "lemma arl_last_rule[sep_heap_rules]: \"\n    l\\<noteq>[] \\<Longrightarrow>\n    <is_array_list l a> \n      arl_last a\n    <\\<lambda>r. is_array_list l a * \\<up>(r=last l)>\"", "lemma arl_butlast_rule[sep_heap_rules]: \"\n    l\\<noteq>[] \\<Longrightarrow>\n    <is_array_list l a> \n      arl_butlast a\n    <is_array_list (butlast l)>\\<^sub>t\"", "lemma arl_get_rule[sep_heap_rules]: \"\n    i<length l \\<Longrightarrow>\n    <is_array_list l a> \n      arl_get a i\n    <\\<lambda>r. is_array_list l a * \\<up>(r=l!i)>\"", "lemma arl_set_rule[sep_heap_rules]: \"\n    i<length l \\<Longrightarrow>\n    <is_array_list l a> \n      arl_set a i x\n    <is_array_list (l[i:=x])>\"", "lemmas [safe_constraint_rules] = CN_FALSEI[of is_pure \"arl_assn A\" for A]", "lemma arl_assn_comp: \"is_pure A \\<Longrightarrow> hr_comp (arl_assn A) (\\<langle>B\\<rangle>list_rel) = arl_assn (hr_comp A B)\"", "lemma arl_assn_comp': \"hr_comp (arl_assn id_assn) (\\<langle>B\\<rangle>list_rel) = arl_assn (pure B)\"", "lemma arl_empty_hnr_aux: \"(uncurry0 arl_empty,uncurry0 (RETURN op_list_empty)) \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a is_array_list\"", "lemma arl_empty_sz_hnr_aux: \"(uncurry0 (arl_empty_sz N),uncurry0 (RETURN op_list_empty)) \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a is_array_list\"", "lemma arl_copy_hnr_aux: \"(arl_copy,RETURN o op_list_copy) \\<in> is_array_list\\<^sup>k \\<rightarrow>\\<^sub>a is_array_list\"", "lemma arl_append_hnr_aux: \"(uncurry arl_append,uncurry (RETURN oo op_list_append)) \\<in> (is_array_list\\<^sup>d *\\<^sub>a id_assn\\<^sup>k) \\<rightarrow>\\<^sub>a is_array_list\"", "lemma arl_length_hnr_aux: \"(arl_length,RETURN o op_list_length) \\<in> is_array_list\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\"", "lemma arl_is_empty_hnr_aux: \"(arl_is_empty,RETURN o op_list_is_empty) \\<in> is_array_list\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\"", "lemma arl_last_hnr_aux: \"(arl_last,RETURN o op_list_last) \\<in> [pre_list_last]\\<^sub>a is_array_list\\<^sup>k \\<rightarrow> id_assn\"", "lemma arl_butlast_hnr_aux: \"(arl_butlast,RETURN o op_list_butlast) \\<in> [pre_list_butlast]\\<^sub>a is_array_list\\<^sup>d \\<rightarrow> is_array_list\"", "lemma arl_get_hnr_aux: \"(uncurry arl_get,uncurry (RETURN oo op_list_get)) \\<in> [\\<lambda>(l,i). i<length l]\\<^sub>a (is_array_list\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k) \\<rightarrow> id_assn\"", "lemma arl_set_hnr_aux: \"(uncurry2 arl_set,uncurry2 (RETURN ooo op_list_set)) \\<in> [\\<lambda>((l,i),_). i<length l]\\<^sub>a (is_array_list\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a id_assn\\<^sup>k) \\<rightarrow> is_array_list\"", "lemma [def_pat_rules]: \"op_arl_empty_sz$N \\<equiv> UNPROTECT (op_arl_empty_sz N)\""], "translations": [["", "lemma is_array_list_prec[safe_constraint_rules]: \"precise is_array_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. precise is_array_list", "unfolding is_array_list_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. precise\n     (\\<lambda>l (a, n).\n         \\<exists>\\<^sub>Al'.\n            a \\<mapsto>\\<^sub>a l' *\n            \\<up>\n             (n \\<le> length l' \\<and> l = take n l' \\<and> 0 < length l'))", "apply(rule preciseI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' h p F F'.\n       h \\<Turnstile>\n       (case p of\n        (aa, n) \\<Rightarrow>\n          \\<exists>\\<^sub>Al'.\n             aa \\<mapsto>\\<^sub>a l' *\n             \\<up>\n              (n \\<le> length l' \\<and>\n               a = take n l' \\<and> 0 < length l')) *\n       F \\<and>\\<^sub>A\n       (case p of\n        (a, n) \\<Rightarrow>\n          \\<exists>\\<^sub>Al'.\n             a \\<mapsto>\\<^sub>a l' *\n             \\<up>\n              (n \\<le> length l' \\<and>\n               a' = take n l' \\<and> 0 < length l')) *\n       F' \\<Longrightarrow>\n       a = a'", "apply(simp split: prod.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' h p F F' x1 x2.\n       \\<lbrakk>p = (x1, x2);\n        \\<exists>l' l'a.\n           h \\<Turnstile>\n           x1 \\<mapsto>\\<^sub>a l'a * F \\<and>\\<^sub>A\n           x1 \\<mapsto>\\<^sub>a l' * F' \\<and>\n           x2 \\<le> length l'a \\<and>\n           a = take x2 l'a \\<and>\n           l'a \\<noteq> [] \\<and>\n           x2 \\<le> length l' \\<and>\n           a' = take x2 l' \\<and> l' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> a = a'", "using preciseD snga_prec"], ["proof (prove)\nusing this:\n  \\<lbrakk>precise ?R;\n   ?h \\<Turnstile> ?R ?a ?p * ?F \\<and>\\<^sub>A ?R ?a' ?p * ?F'\\<rbrakk>\n  \\<Longrightarrow> ?a = ?a'\n  precise (\\<lambda>x p. p \\<mapsto>\\<^sub>a x)\n\ngoal (1 subgoal):\n 1. \\<And>a a' h p F F' x1 x2.\n       \\<lbrakk>p = (x1, x2);\n        \\<exists>l' l'a.\n           h \\<Turnstile>\n           x1 \\<mapsto>\\<^sub>a l'a * F \\<and>\\<^sub>A\n           x1 \\<mapsto>\\<^sub>a l' * F' \\<and>\n           x2 \\<le> length l'a \\<and>\n           a = take x2 l'a \\<and>\n           l'a \\<noteq> [] \\<and>\n           x2 \\<le> length l' \\<and>\n           a' = take x2 l' \\<and> l' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> a = a'", "by fastforce"], ["", "definition \"initial_capacity \\<equiv> 16::nat\""], ["", "definition \"minimum_capacity \\<equiv> 16::nat\""], ["", "definition \"arl_empty \\<equiv> do {\n    a \\<leftarrow> Array.new initial_capacity default;\n    return (a,0)\n  }\""], ["", "definition \"arl_empty_sz init_cap \\<equiv> do {\n    a \\<leftarrow> Array.new (max init_cap minimum_capacity) default;\n    return (a,0)\n  }\""], ["", "definition \"arl_append \\<equiv> \\<lambda>(a,n) x. do {\n    len \\<leftarrow> Array.len a;\n\n    if n<len then do {\n      a \\<leftarrow> Array.upd n x a;\n      return (a,n+1)\n    } else do {\n      let newcap = 2 * len;\n      a \\<leftarrow> array_grow a newcap default;\n      a \\<leftarrow> Array.upd n x a;\n      return (a,n+1)\n    }\n  }\""], ["", "definition \"arl_copy \\<equiv> \\<lambda>(a,n). do {\n    a \\<leftarrow> array_copy a;\n    return (a,n)\n  }\""], ["", "definition arl_length :: \"'a::heap array_list \\<Rightarrow> nat Heap\" where\n    \"arl_length \\<equiv> \\<lambda>(a,n). return (n)\""], ["", "definition arl_is_empty :: \"'a::heap array_list \\<Rightarrow> bool Heap\" where\n    \"arl_is_empty \\<equiv> \\<lambda>(a,n). return (n=0)\""], ["", "definition arl_last :: \"'a::heap array_list \\<Rightarrow> 'a Heap\" where\n    \"arl_last \\<equiv> \\<lambda>(a,n). do {\n      Array.nth a (n - 1)\n    }\""], ["", "definition arl_butlast :: \"'a::heap array_list \\<Rightarrow> 'a array_list Heap\" where\n    \"arl_butlast \\<equiv> \\<lambda>(a,n). do {\n      let n = n - 1;\n      len \\<leftarrow> Array.len a;\n      if (n*4 < len \\<and> n*2\\<ge>minimum_capacity) then do {\n        a \\<leftarrow> array_shrink a (n*2);\n        return (a,n)\n      } else\n        return (a,n)\n    }\""], ["", "definition arl_get :: \"'a::heap array_list \\<Rightarrow> nat \\<Rightarrow> 'a Heap\" where\n    \"arl_get \\<equiv> \\<lambda>(a,n) i. Array.nth a i\""], ["", "definition arl_set :: \"'a::heap array_list \\<Rightarrow> nat \\<Rightarrow> 'a \\<Rightarrow> 'a array_list Heap\" where\n    \"arl_set \\<equiv> \\<lambda>(a,n) i x. do { a \\<leftarrow> Array.upd i x a; return (a,n)}\""], ["", "lemma arl_empty_rule[sep_heap_rules]: \"< emp > arl_empty <is_array_list []>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> arl_empty <is_array_list []>", "by (sep_auto simp: arl_empty_def is_array_list_def initial_capacity_def)"], ["", "lemma arl_empty_sz_rule[sep_heap_rules]: \"< emp > arl_empty_sz N <is_array_list []>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> arl_empty_sz N <is_array_list []>", "by (sep_auto simp: arl_empty_sz_def is_array_list_def minimum_capacity_def)"], ["", "lemma arl_copy_rule[sep_heap_rules]: \"< is_array_list l a > arl_copy a <\\<lambda>r. is_array_list l a * is_array_list l r>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_array_list l a> arl_copy a\n    <\\<lambda>r. is_array_list l a * is_array_list l r>", "by (sep_auto simp: arl_copy_def is_array_list_def)"], ["", "lemma arl_append_rule[sep_heap_rules]: \"\n    < is_array_list l a > \n      arl_append a x \n    <\\<lambda>a. is_array_list (l@[x]) a >\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_array_list l a> arl_append a x <is_array_list (l @ [x])>\\<^sub>t", "by (sep_auto \n      simp: arl_append_def is_array_list_def take_update_last neq_Nil_conv\n      split: prod.splits nat.split)"], ["", "lemma arl_length_rule[sep_heap_rules]: \"\n    <is_array_list l a> \n      arl_length a\n    <\\<lambda>r. is_array_list l a * \\<up>(r=length l)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_array_list l a> arl_length a\n    <\\<lambda>r. is_array_list l a * \\<up> (r = length l)>", "by (sep_auto simp: arl_length_def is_array_list_def)"], ["", "lemma arl_is_empty_rule[sep_heap_rules]: \"\n    <is_array_list l a> \n      arl_is_empty a\n    <\\<lambda>r. is_array_list l a * \\<up>(r\\<longleftrightarrow>(l=[]))>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_array_list l a> arl_is_empty a\n    <\\<lambda>r. is_array_list l a * \\<up> (r = (l = []))>", "by (sep_auto simp: arl_is_empty_def is_array_list_def)"], ["", "lemma arl_last_rule[sep_heap_rules]: \"\n    l\\<noteq>[] \\<Longrightarrow>\n    <is_array_list l a> \n      arl_last a\n    <\\<lambda>r. is_array_list l a * \\<up>(r=last l)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    <is_array_list l a> arl_last a\n    <\\<lambda>r. is_array_list l a * \\<up> (r = last l)>", "by (sep_auto simp: arl_last_def is_array_list_def last_take_nth_conv)"], ["", "lemma arl_butlast_rule[sep_heap_rules]: \"\n    l\\<noteq>[] \\<Longrightarrow>\n    <is_array_list l a> \n      arl_butlast a\n    <is_array_list (butlast l)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    <is_array_list l a> arl_butlast a <is_array_list (butlast l)>\\<^sub>t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    <is_array_list l a> arl_butlast a <is_array_list (butlast l)>\\<^sub>t", "assume [simp]: \"l\\<noteq>[]\""], ["proof (state)\nthis:\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    <is_array_list l a> arl_butlast a <is_array_list (butlast l)>\\<^sub>t", "have [simp]: \"\\<And>x. min (x-Suc 0) ((x-Suc 0)*2) = x-Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. min (x - Suc 0) ((x - Suc 0) * 2) = x - Suc 0", "by auto"], ["proof (state)\nthis:\n  min (?x - Suc 0) ((?x - Suc 0) * 2) = ?x - Suc 0\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    <is_array_list l a> arl_butlast a <is_array_list (butlast l)>\\<^sub>t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_array_list l a> arl_butlast a <is_array_list (butlast l)>\\<^sub>t", "by (sep_auto \n        split: prod.splits\n        simp: arl_butlast_def is_array_list_def butlast_take minimum_capacity_def)"], ["proof (state)\nthis:\n  <is_array_list l a> arl_butlast a <is_array_list (butlast l)>\\<^sub>t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma arl_get_rule[sep_heap_rules]: \"\n    i<length l \\<Longrightarrow>\n    <is_array_list l a> \n      arl_get a i\n    <\\<lambda>r. is_array_list l a * \\<up>(r=l!i)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length l \\<Longrightarrow>\n    <is_array_list l a> arl_get a i\n    <\\<lambda>r. is_array_list l a * \\<up> (r = l ! i)>", "by (sep_auto simp: arl_get_def is_array_list_def split: prod.split)"], ["", "lemma arl_set_rule[sep_heap_rules]: \"\n    i<length l \\<Longrightarrow>\n    <is_array_list l a> \n      arl_set a i x\n    <is_array_list (l[i:=x])>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length l \\<Longrightarrow>\n    <is_array_list l a> arl_set a i x <is_array_list (l[i := x])>", "by (sep_auto simp: arl_set_def is_array_list_def split: prod.split)"], ["", "definition \"arl_assn A \\<equiv> hr_comp is_array_list (\\<langle>the_pure A\\<rangle>list_rel)\""], ["", "lemmas [safe_constraint_rules] = CN_FALSEI[of is_pure \"arl_assn A\" for A]"], ["", "lemma arl_assn_comp: \"is_pure A \\<Longrightarrow> hr_comp (arl_assn A) (\\<langle>B\\<rangle>list_rel) = arl_assn (hr_comp A B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pure A \\<Longrightarrow>\n    hr_comp (arl_assn A) (\\<langle>B\\<rangle>list_rel) =\n    arl_assn (hr_comp A B)", "unfolding arl_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pure A \\<Longrightarrow>\n    hr_comp (hr_comp is_array_list (\\<langle>the_pure A\\<rangle>list_rel))\n     (\\<langle>B\\<rangle>list_rel) =\n    hr_comp is_array_list (\\<langle>the_pure (hr_comp A B)\\<rangle>list_rel)", "by (auto simp: hr_comp_the_pure hr_comp_assoc list_rel_compp)"], ["", "lemma arl_assn_comp': \"hr_comp (arl_assn id_assn) (\\<langle>B\\<rangle>list_rel) = arl_assn (pure B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hr_comp (arl_assn id_assn) (\\<langle>B\\<rangle>list_rel) =\n    arl_assn (pure B)", "by (simp add: arl_assn_comp)"], ["", "context \n  notes [fcomp_norm_unfold] = arl_assn_def[symmetric] arl_assn_comp'\n  notes [intro!] = hfrefI hn_refineI[THEN hn_refine_preI]\n  notes [simp] = pure_def hn_ctxt_def invalid_assn_def\nbegin"], ["", "lemma arl_empty_hnr_aux: \"(uncurry0 arl_empty,uncurry0 (RETURN op_list_empty)) \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a is_array_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 arl_empty, uncurry0 (RETURN op_list_empty))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a is_array_list", "by sep_auto"], ["", "sepref_decl_impl (no_register) arl_empty: arl_empty_hnr_aux"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma arl_empty_sz_hnr_aux: \"(uncurry0 (arl_empty_sz N),uncurry0 (RETURN op_list_empty)) \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a is_array_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 (arl_empty_sz N), uncurry0 (RETURN op_list_empty))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a is_array_list", "by sep_auto"], ["", "sepref_decl_impl (no_register) arl_empty_sz: arl_empty_sz_hnr_aux"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition \"op_arl_empty \\<equiv> op_list_empty\""], ["", "definition \"op_arl_empty_sz (N::nat) \\<equiv> op_list_empty\""], ["", "lemma arl_copy_hnr_aux: \"(arl_copy,RETURN o op_list_copy) \\<in> is_array_list\\<^sup>k \\<rightarrow>\\<^sub>a is_array_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (arl_copy, RETURN \\<circ> op_list_copy)\n    \\<in> is_array_list\\<^sup>k \\<rightarrow>\\<^sub>a is_array_list", "by sep_auto"], ["", "sepref_decl_impl arl_copy: arl_copy_hnr_aux"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma arl_append_hnr_aux: \"(uncurry arl_append,uncurry (RETURN oo op_list_append)) \\<in> (is_array_list\\<^sup>d *\\<^sub>a id_assn\\<^sup>k) \\<rightarrow>\\<^sub>a is_array_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry arl_append, uncurry (RETURN \\<circ>\\<circ> op_list_append))\n    \\<in> is_array_list\\<^sup>d *\\<^sub>a\n          id_assn\\<^sup>k \\<rightarrow>\\<^sub>a is_array_list", "by sep_auto"], ["", "sepref_decl_impl arl_append: arl_append_hnr_aux"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma arl_length_hnr_aux: \"(arl_length,RETURN o op_list_length) \\<in> is_array_list\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (arl_length, RETURN \\<circ> op_list_length)\n    \\<in> is_array_list\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "by sep_auto"], ["", "sepref_decl_impl arl_length: arl_length_hnr_aux"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma arl_is_empty_hnr_aux: \"(arl_is_empty,RETURN o op_list_is_empty) \\<in> is_array_list\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (arl_is_empty, RETURN \\<circ> op_list_is_empty)\n    \\<in> is_array_list\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "by sep_auto"], ["", "sepref_decl_impl arl_is_empty: arl_is_empty_hnr_aux"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma arl_last_hnr_aux: \"(arl_last,RETURN o op_list_last) \\<in> [pre_list_last]\\<^sub>a is_array_list\\<^sup>k \\<rightarrow> id_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (arl_last, RETURN \\<circ> op_list_last)\n    \\<in> [pre_list_last]\\<^sub>a is_array_list\\<^sup>k \\<rightarrow> id_assn", "by sep_auto"], ["", "sepref_decl_impl arl_last: arl_last_hnr_aux"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma arl_butlast_hnr_aux: \"(arl_butlast,RETURN o op_list_butlast) \\<in> [pre_list_butlast]\\<^sub>a is_array_list\\<^sup>d \\<rightarrow> is_array_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (arl_butlast, RETURN \\<circ> op_list_butlast)\n    \\<in> [pre_list_butlast]\\<^sub>a is_array_list\\<^sup>d \\<rightarrow> is_array_list", "by sep_auto"], ["", "sepref_decl_impl arl_butlast: arl_butlast_hnr_aux"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma arl_get_hnr_aux: \"(uncurry arl_get,uncurry (RETURN oo op_list_get)) \\<in> [\\<lambda>(l,i). i<length l]\\<^sub>a (is_array_list\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k) \\<rightarrow> id_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry arl_get, uncurry (RETURN \\<circ>\\<circ> op_list_get))\n    \\<in> [\\<lambda>(l, i).\n              i < length\n                   l]\\<^sub>a is_array_list\\<^sup>k *\\<^sub>a\n                              nat_assn\\<^sup>k \\<rightarrow> id_assn", "by sep_auto"], ["", "sepref_decl_impl arl_get: arl_get_hnr_aux"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma arl_set_hnr_aux: \"(uncurry2 arl_set,uncurry2 (RETURN ooo op_list_set)) \\<in> [\\<lambda>((l,i),_). i<length l]\\<^sub>a (is_array_list\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a id_assn\\<^sup>k) \\<rightarrow> is_array_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 arl_set, uncurry2 (RETURN \\<circ>\\<circ>\\<circ> op_list_set))\n    \\<in> [\\<lambda>((l, i), uu_).\n              i < length\n                   l]\\<^sub>a is_array_list\\<^sup>d *\\<^sub>a\n                              nat_assn\\<^sup>k *\\<^sub>a\n                              id_assn\\<^sup>k \\<rightarrow> is_array_list", "by sep_auto"], ["", "sepref_decl_impl arl_set: arl_set_hnr_aux"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_definition arl_swap is \"uncurry2 mop_list_swap\" :: \"((arl_assn id_assn)\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a arl_assn id_assn)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3, uncurry2 mop_list_swap)\n    \\<in> (arl_assn id_assn)\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a arl_assn id_assn", "unfolding gen_mop_list_swap[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>l i j.\n          mop_list_get l i \\<bind>\n          (\\<lambda>xi.\n              mop_list_get l j \\<bind>\n              (\\<lambda>xj.\n                  mop_list_set l i xj \\<bind>\n                  (\\<lambda>l. mop_list_set l j xi \\<bind> RETURN)))))\n    \\<in> (arl_assn id_assn)\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a arl_assn id_assn", "by sepref"], ["", "sepref_decl_impl (ismop) arl_swap: arl_swap.refine"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "interpretation arl: list_custom_empty \"arl_assn A\" arl_empty op_arl_empty"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_custom_empty (arl_assn A) arl_empty op_arl_empty", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. (uncurry0 arl_empty, uncurry0 (RETURN op_list_empty))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a arl_assn A\n 2. op_arl_empty = op_list_empty", "apply (rule arl_empty_hnr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. op_arl_empty = op_list_empty", "by (auto simp: op_arl_empty_def)"], ["", "lemma [def_pat_rules]: \"op_arl_empty_sz$N \\<equiv> UNPROTECT (op_arl_empty_sz N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op_arl_empty_sz $ N \\<equiv> UNPROTECT (op_arl_empty_sz N)", "by simp"], ["", "interpretation arl_sz: list_custom_empty \"arl_assn A\" \"arl_empty_sz N\" \"PR_CONST (op_arl_empty_sz N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_custom_empty (arl_assn A) (arl_empty_sz N)\n     (PR_CONST (op_arl_empty_sz N))", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. (uncurry0 (arl_empty_sz N), uncurry0 (RETURN op_list_empty))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a arl_assn A\n 2. PR_CONST (op_arl_empty_sz N) = op_list_empty", "apply (rule arl_empty_sz_hnr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. PR_CONST (op_arl_empty_sz N) = op_list_empty", "by (auto simp: op_arl_empty_sz_def)"], ["", "end"]]}