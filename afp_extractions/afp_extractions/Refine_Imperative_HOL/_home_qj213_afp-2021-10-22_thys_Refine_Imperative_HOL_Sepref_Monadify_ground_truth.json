{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/Sepref_Monadify.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemma SP_cong[cong]: \"SP x \\<equiv> SP x\"", "lemma PR_CONST_cong[cong]: \"PR_CONST x \\<equiv> PR_CONST x\"", "lemma monadify_simps: \n  \"Refine_Basic.bind$(RETURN$x)$(\\<lambda>\\<^sub>2x. f x) = f x\" \n  \"EVAL$x \\<equiv> RETURN$x\"", "lemma remove_pass_simps:\n  \"Refine_Basic.bind$(PASS$x)$(\\<lambda>\\<^sub>2x. f x) \\<equiv> f x\" \n  \"Refine_Basic.bind$m$(\\<lambda>\\<^sub>2x. PASS$x) \\<equiv> m\"", "lemma RET_COPY_PASS_eq: \"RETURN$(COPY$p) = PASS$p\"", "lemma dflt_arity[sepref_monadify_arity]:\n  \"RETURN \\<equiv> \\<lambda>\\<^sub>2x. SP RETURN$x\" \n  \"RECT \\<equiv> \\<lambda>\\<^sub>2B x. SP RECT$(\\<lambda>\\<^sub>2D x. B$(\\<lambda>\\<^sub>2x. RCALL$D$x)$x)$x\" \n  \"case_list \\<equiv> \\<lambda>\\<^sub>2fn fc l. SP case_list$fn$(\\<lambda>\\<^sub>2x xs. fc$x$xs)$l\" \n  \"case_prod \\<equiv> \\<lambda>\\<^sub>2fp p. SP case_prod$(\\<lambda>\\<^sub>2a b. fp$a$b)$p\" \n  \"case_option \\<equiv> \\<lambda>\\<^sub>2fn fs ov. SP case_option$fn$(\\<lambda>\\<^sub>2x. fs$x)$ov\" \n  \"If \\<equiv> \\<lambda>\\<^sub>2b t e. SP If$b$t$e\" \n  \"Let \\<equiv> \\<lambda>\\<^sub>2x f. SP Let$x$(\\<lambda>\\<^sub>2x. f$x)\"", "lemma dflt_comb[sepref_monadify_comb]:\n  \"\\<And>B x. RECT$B$x \\<equiv> Refine_Basic.bind$(EVAL$x)$(\\<lambda>\\<^sub>2x. SP (RECT$B$x))\"\n  \"\\<And>D x. RCALL$D$x \\<equiv> Refine_Basic.bind$(EVAL$x)$(\\<lambda>\\<^sub>2x. SP (RCALL$D$x))\"\n  \"\\<And>fn fc l. case_list$fn$fc$l \\<equiv> Refine_Basic.bind$(EVAL$l)$(\\<lambda>\\<^sub>2l. (SP case_list$fn$fc$l))\"\n  \"\\<And>fp p. case_prod$fp$p \\<equiv> Refine_Basic.bind$(EVAL$p)$(\\<lambda>\\<^sub>2p. (SP case_prod$fp$p))\"\n  \"\\<And>fn fs ov. case_option$fn$fs$ov \n    \\<equiv> Refine_Basic.bind$(EVAL$ov)$(\\<lambda>\\<^sub>2ov. (SP case_option$fn$fs$ov))\"\n  \"\\<And>b t e. If$b$t$e \\<equiv> Refine_Basic.bind$(EVAL$b)$(\\<lambda>\\<^sub>2b. (SP If$b$t$e))\"\n  \"\\<And>x. RETURN$x \\<equiv> Refine_Basic.bind$(EVAL$x)$(\\<lambda>\\<^sub>2x. SP (RETURN$x))\"\n  \"\\<And>x f. Let$x$f \\<equiv> Refine_Basic.bind$(EVAL$x)$(\\<lambda>\\<^sub>2x. (SP Let$x$f))\"", "lemma dflt_plain_comb[sepref_monadify_comb]:\n  \"EVAL$(If$b$t$e) \\<equiv> Refine_Basic.bind$(EVAL$b)$(\\<lambda>\\<^sub>2b. If$b$(EVAL$t)$(EVAL$e))\"\n  \"EVAL$(case_list$fn$(\\<lambda>\\<^sub>2x xs. fc x xs)$l) \\<equiv> \n    Refine_Basic.bind$(EVAL$l)$(\\<lambda>\\<^sub>2l. case_list$(EVAL$fn)$(\\<lambda>\\<^sub>2x xs. EVAL$(fc x xs))$l)\"\n  \"EVAL$(case_prod$(\\<lambda>\\<^sub>2a b. fp a b)$p) \\<equiv> \n    Refine_Basic.bind$(EVAL$p)$(\\<lambda>\\<^sub>2p. case_prod$(\\<lambda>\\<^sub>2a b. EVAL$(fp a b))$p)\"\n  \"EVAL$(case_option$fn$(\\<lambda>\\<^sub>2x. fs x)$ov) \\<equiv> \n    Refine_Basic.bind$(EVAL$ov)$(\\<lambda>\\<^sub>2ov. case_option$(EVAL$fn)$(\\<lambda>\\<^sub>2x. EVAL$(fs x))$ov)\"\n  \"EVAL $ (Let $ v $ (\\<lambda>\\<^sub>2x. f x)) \\<equiv> (\\<bind>) $ (EVAL $ v) $ (\\<lambda>\\<^sub>2x. EVAL $ (f x))\"", "lemma evalcomb_PR_CONST[sepref_monadify_comb]:\n  \"EVAL$(PR_CONST x) \\<equiv> SP (RETURN$(PR_CONST x))\""], "translations": [["", "lemma SP_cong[cong]: \"SP x \\<equiv> SP x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SP x \\<equiv> SP x", "by simp"], ["", "lemma PR_CONST_cong[cong]: \"PR_CONST x \\<equiv> PR_CONST x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PR_CONST x \\<equiv> PR_CONST x", "by simp"], ["", "definition RCALL \\<comment> \\<open>Tag that marks recursive call\\<close>\n  where [simp]: \"RCALL D \\<equiv> D\""], ["", "definition EVAL \\<comment> \\<open>Tag that marks evaluation of plain expression for monadify phase\\<close>\n  where [simp]: \"EVAL x \\<equiv> RETURN x\""], ["", "text \\<open>\n  Internally, the package first applies rewriting rules from \n  \\<open>sepref_monadify_arity\\<close>, which use eta-expansion to ensure that\n  every combinator has enough actual parameters. Moreover, this phase will\n  mark recursive calls by the tag @{const RCALL}.\n\n  Next, rewriting rules from \\<open>sepref_monadify_comb\\<close> are used to\n  add @{const EVAL}-tags to plain expressions that should be evaluated\n  in the monad. The @{const EVAL} tags are flattened using a default simproc \n  that generates left-to-right argument order.\n\\<close>"], ["", "lemma monadify_simps: \n  \"Refine_Basic.bind$(RETURN$x)$(\\<lambda>\\<^sub>2x. f x) = f x\" \n  \"EVAL$x \\<equiv> RETURN$x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<bind>) $ (RETURN $ x) $ (\\<lambda>x. (#f x#)) = f x &&&\n    EVAL $ x \\<equiv> RETURN $ x", "by simp_all"], ["", "definition [simp]: \"PASS \\<equiv> RETURN\"\n  \\<comment> \\<open>Pass on value, invalidating old one\\<close>"], ["", "lemma remove_pass_simps:\n  \"Refine_Basic.bind$(PASS$x)$(\\<lambda>\\<^sub>2x. f x) \\<equiv> f x\" \n  \"Refine_Basic.bind$m$(\\<lambda>\\<^sub>2x. PASS$x) \\<equiv> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<bind>) $ (PASS $ x) $ (\\<lambda>x. (#f x#)) \\<equiv> f x) &&&\n    (\\<bind>) $ m $ (\\<lambda>x. (#PASS $ x#)) \\<equiv> m", "by simp_all"], ["", "definition COPY :: \"'a \\<Rightarrow> 'a\" \n  \\<comment> \\<open>Marks required copying of parameter\\<close>\n  where [simp]: \"COPY x \\<equiv> x\""], ["", "lemma RET_COPY_PASS_eq: \"RETURN$(COPY$p) = PASS$p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN $ (COPY $ p) = PASS $ p", "by simp"], ["", "named_theorems_rev sepref_monadify_arity \"Sepref.Monadify: Arity alignment equations\""], ["", "named_theorems_rev sepref_monadify_comb \"Sepref.Monadify: Combinator equations\""], ["", "ML \\<open>\n  structure Sepref_Monadify = struct\n    local\n      fun cr_var (i,T) = (\"v\"^string_of_int i, Free (\"__v\"^string_of_int i,T))\n\n      fun lambda2_name n t = let\n        val t = @{mk_term \"PROTECT2 ?t DUMMY\"}\n      in\n        Term.lambda_name n t\n      end\n\n\n      fun \n        bind_args exp0 [] = exp0\n      | bind_args exp0 ((x,m)::xms) = let\n          val lr = bind_args exp0 xms \n            |> incr_boundvars 1 \n            |> lambda2_name x\n        in @{mk_term \"Refine_Basic.bind$?m$?lr\"} end\n\n      fun monadify t = let\n        val (f,args) = Autoref_Tagging.strip_app t\n        val _ = not (is_Abs f) orelse \n          raise TERM (\"monadify: higher-order\",[t])\n\n        val argTs = map fastype_of args\n        (*val args = map monadify args*)\n        val args = map (fn a => @{mk_term \"EVAL$?a\"}) args\n\n        (*val fT = fastype_of f\n        val argTs = binder_types fT*)\n  \n        val argVs = tag_list 0 argTs\n          |> map cr_var\n\n        val res0 = let\n          val x = Autoref_Tagging.list_APP (f,map #2 argVs)\n        in \n          @{mk_term \"SP (RETURN$?x)\"}\n        end\n\n        val res = bind_args res0 (argVs ~~ args)\n      in\n        res\n      end\n\n      fun monadify_conv_aux ctxt ct = case Thm.term_of ct of\n        @{mpat \"EVAL$_\"} => let\n          val ss = put_simpset HOL_basic_ss ctxt\n          val ss = (ss addsimps @{thms monadify_simps SP_def})\n          val tac = (simp_tac ss 1)\n        in (*Refine_Util.monitor_conv \"monadify\"*) (\n          Refine_Util.f_tac_conv ctxt (dest_comb #> #2 #> monadify) tac) ct\n        end\n      | t => raise TERM (\"monadify_conv\",[t])\n\n      (*fun extract_comb_conv ctxt = Conv.rewrs_conv \n        (Named_Theorems_Rev.get ctxt @{named_theorems_rev sepref_monadify_evalcomb})\n      *)  \n    in\n      (*\n      val monadify_conv = Conv.top_conv \n        (fn ctxt => \n          Conv.try_conv (\n            extract_comb_conv ctxt else_conv monadify_conv_aux ctxt\n          )\n        )\n      *)  \n\n      val monadify_simproc = \n        Simplifier.make_simproc @{context} \"monadify_simproc\"\n         {lhss =\n          [Logic.varify_global @{term \"EVAL$a\"}],\n          proc = K (try o monadify_conv_aux)};\n\n    end\n\n    local\n      open Sepref_Basic\n      fun mark_params t = let\n        val (P,c,Q,R,a) = dest_hn_refine t\n        val pps = strip_star P |> map_filter (dest_hn_ctxt_opt #> map_option #2)\n\n        fun tr env (t as @{mpat \"RETURN$?x\"}) = \n              if is_Bound x orelse member (aconv) pps x then\n                @{mk_term env: \"PASS$?x\"}\n              else t\n          | tr env (t1$t2) = tr env t1 $ tr env t2\n          | tr env (Abs (x,T,t)) = Abs (x,T,tr (T::env) t)\n          | tr _ t = t\n\n        val a = tr [] a\n      in\n        mk_hn_refine (P,c,Q,R,a)\n      end\n\n    in  \n    fun mark_params_conv ctxt = Refine_Util.f_tac_conv ctxt \n      (mark_params) \n      (simp_tac (put_simpset HOL_basic_ss ctxt addsimps @{thms PASS_def}) 1)\n\n    end  \n\n    local\n\n      open Sepref_Basic\n\n      fun dp ctxt (@{mpat \"Refine_Basic.bind$(PASS$?p)$(?t' AS\\<^sub>p (\\<lambda>_. PROTECT2 _ DUMMY))\"}) = \n          let\n            val (t',ps) = let\n                val ((t',rc),ctxt) = dest_lambda_rc ctxt t'\n                val f = case t' of @{mpat \"PROTECT2 ?f _\"} => f | _ => raise Match \n                val (f,ps) = dp ctxt f\n                val t' = @{mk_term \"PROTECT2 ?f DUMMY\"}\n                val t' = rc t'\n              in\n                (t',ps)\n              end\n  \n            val dup = member (aconv) ps p\n            val t = if dup then\n              @{mk_term \"Refine_Basic.bind$(RETURN$(COPY$?p))$?t'\"}\n            else\n              @{mk_term \"Refine_Basic.bind$(PASS$?p)$?t'\"}\n          in\n            (t,p::ps)\n          end\n        | dp ctxt (t1$t2) = (#1 (dp ctxt t1) $ #1 (dp ctxt t2),[])\n        | dp ctxt (t as (Abs _)) = (apply_under_lambda (#1 oo dp) ctxt t,[])\n        | dp _ t = (t,[])\n\n      fun dp_conv ctxt = Refine_Util.f_tac_conv ctxt \n        (#1 o dp ctxt) \n        (ALLGOALS (simp_tac (put_simpset HOL_basic_ss ctxt addsimps @{thms RET_COPY_PASS_eq}))) \n\n\n    in\n      fun dup_tac ctxt = CONVERSION (Sepref_Basic.hn_refine_concl_conv_a dp_conv ctxt)\n    end\n\n\n    fun arity_tac ctxt = let\n      val arity1_ss = put_simpset HOL_basic_ss ctxt \n        addsimps ((Named_Theorems_Rev.get ctxt @{named_theorems_rev sepref_monadify_arity}))\n        |> Simplifier.add_cong @{thm SP_cong}\n        |> Simplifier.add_cong @{thm PR_CONST_cong}\n\n      val arity2_ss = put_simpset HOL_basic_ss ctxt \n        addsimps @{thms beta SP_def}\n    in\n      simp_tac arity1_ss THEN' simp_tac arity2_ss\n    end\n\n    fun comb_tac ctxt = let\n      val comb1_ss = put_simpset HOL_basic_ss ctxt \n        addsimps (Named_Theorems_Rev.get ctxt @{named_theorems_rev sepref_monadify_comb})\n        (*addsimps (Named_Theorems_Rev.get ctxt @{named_theorems_rev sepref_monadify_evalcomb})*)\n        addsimprocs [monadify_simproc]\n        |> Simplifier.add_cong @{thm SP_cong}\n        |> Simplifier.add_cong @{thm PR_CONST_cong}\n\n      val comb2_ss = put_simpset HOL_basic_ss ctxt \n        addsimps @{thms SP_def}\n    in\n      simp_tac comb1_ss THEN' simp_tac comb2_ss\n    end\n\n    (*fun ops_tac ctxt = CONVERSION (\n      Sepref_Basic.hn_refine_concl_conv_a monadify_conv ctxt)*)\n\n    fun mark_params_tac ctxt = CONVERSION (\n      Refine_Util.HOL_concl_conv (K (mark_params_conv ctxt)) ctxt)\n\n    fun contains_eval @{mpat \"Trueprop (hn_refine _ _ _ _ ?a)\"} =   \n      Term.exists_subterm (fn @{mpat EVAL} => true | _ => false) a\n    | contains_eval t = raise TERM(\"contains_eval\",[t]);  \n\n    fun remove_pass_tac ctxt = \n      simp_tac (put_simpset HOL_basic_ss ctxt addsimps @{thms remove_pass_simps})\n\n    fun monadify_tac dbg ctxt = let\n      open Sepref_Basic\n    in\n      PHASES' [\n        (\"arity\", arity_tac, 0),\n        (\"comb\", comb_tac, 0),\n        (*(\"ops\", ops_tac, 0),*)\n        (\"check_EVAL\", K (CONCL_COND' (not o contains_eval)), 0),\n        (\"mark_params\", mark_params_tac, 0),\n        (\"dup\", dup_tac, 0),\n        (\"remove_pass\", remove_pass_tac, 0)\n      ] (flag_phases_ctrl dbg) ctxt\n    end\n\n  end\n\\<close>"], ["", "lemma dflt_arity[sepref_monadify_arity]:\n  \"RETURN \\<equiv> \\<lambda>\\<^sub>2x. SP RETURN$x\" \n  \"RECT \\<equiv> \\<lambda>\\<^sub>2B x. SP RECT$(\\<lambda>\\<^sub>2D x. B$(\\<lambda>\\<^sub>2x. RCALL$D$x)$x)$x\" \n  \"case_list \\<equiv> \\<lambda>\\<^sub>2fn fc l. SP case_list$fn$(\\<lambda>\\<^sub>2x xs. fc$x$xs)$l\" \n  \"case_prod \\<equiv> \\<lambda>\\<^sub>2fp p. SP case_prod$(\\<lambda>\\<^sub>2a b. fp$a$b)$p\" \n  \"case_option \\<equiv> \\<lambda>\\<^sub>2fn fs ov. SP case_option$fn$(\\<lambda>\\<^sub>2x. fs$x)$ov\" \n  \"If \\<equiv> \\<lambda>\\<^sub>2b t e. SP If$b$t$e\" \n  \"Let \\<equiv> \\<lambda>\\<^sub>2x f. SP Let$x$(\\<lambda>\\<^sub>2x. f$x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((RETURN \\<equiv> \\<lambda>x. (#SP RETURN $ x#)) &&&\n     (REC\\<^sub>T \\<equiv>\n      \\<lambda>x.\n         (#\\<lambda>xa.\n              (#SP REC\\<^sub>T $\n                (\\<lambda>xa.\n                    (#\\<lambda>xb.\n                         (#x $ (\\<lambda>x. (#RCALL $ xa $ x#)) $ xb#)#)) $\n                xa#)#)) &&&\n     case_list \\<equiv>\n     \\<lambda>x.\n        (#\\<lambda>xa.\n             (#\\<lambda>xb.\n                  (#SP case_list $ x $\n                    (\\<lambda>x. (#\\<lambda>xb. (#xa $ x $ xb#)#)) $\n                    xb#)#)#)) &&&\n    ((case_prod \\<equiv>\n      \\<lambda>x.\n         (#\\<lambda>xa.\n              (#SP case_prod $\n                (\\<lambda>xa. (#\\<lambda>xb. (#x $ xa $ xb#)#)) $\n                xa#)#)) &&&\n     case_option \\<equiv>\n     \\<lambda>x.\n        (#\\<lambda>xa.\n             (#\\<lambda>xb.\n                  (#SP case_option $ x $ (\\<lambda>x. (#xa $ x#)) $\n                    xb#)#)#)) &&&\n    (If \\<equiv>\n     \\<lambda>x.\n        (#\\<lambda>xa. (#\\<lambda>xb. (#SP If $ x $ xa $ xb#)#)#)) &&&\n    Let \\<equiv>\n    \\<lambda>x. (#\\<lambda>xa. (#SP Let $ x $ (\\<lambda>x. (#xa $ x#))#)#)", "by (simp_all only: SP_def APP_def PROTECT2_def RCALL_def)"], ["", "lemma dflt_comb[sepref_monadify_comb]:\n  \"\\<And>B x. RECT$B$x \\<equiv> Refine_Basic.bind$(EVAL$x)$(\\<lambda>\\<^sub>2x. SP (RECT$B$x))\"\n  \"\\<And>D x. RCALL$D$x \\<equiv> Refine_Basic.bind$(EVAL$x)$(\\<lambda>\\<^sub>2x. SP (RCALL$D$x))\"\n  \"\\<And>fn fc l. case_list$fn$fc$l \\<equiv> Refine_Basic.bind$(EVAL$l)$(\\<lambda>\\<^sub>2l. (SP case_list$fn$fc$l))\"\n  \"\\<And>fp p. case_prod$fp$p \\<equiv> Refine_Basic.bind$(EVAL$p)$(\\<lambda>\\<^sub>2p. (SP case_prod$fp$p))\"\n  \"\\<And>fn fs ov. case_option$fn$fs$ov \n    \\<equiv> Refine_Basic.bind$(EVAL$ov)$(\\<lambda>\\<^sub>2ov. (SP case_option$fn$fs$ov))\"\n  \"\\<And>b t e. If$b$t$e \\<equiv> Refine_Basic.bind$(EVAL$b)$(\\<lambda>\\<^sub>2b. (SP If$b$t$e))\"\n  \"\\<And>x. RETURN$x \\<equiv> Refine_Basic.bind$(EVAL$x)$(\\<lambda>\\<^sub>2x. SP (RETURN$x))\"\n  \"\\<And>x f. Let$x$f \\<equiv> Refine_Basic.bind$(EVAL$x)$(\\<lambda>\\<^sub>2x. (SP Let$x$f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((\\<And>B x.\n          REC\\<^sub>T $ B $ x \\<equiv>\n          (\\<bind>) $ (EVAL $ x) $\n          (\\<lambda>x. (#SP (REC\\<^sub>T $ B $ x)#))) &&&\n      (\\<And>D x.\n          RCALL $ D $ x \\<equiv>\n          (\\<bind>) $ (EVAL $ x) $\n          (\\<lambda>x. (#SP (RCALL $ D $ x)#)))) &&&\n     (\\<And>fn fc l.\n         case_list $ fn $ fc $ l \\<equiv>\n         (\\<bind>) $ (EVAL $ l) $\n         (\\<lambda>x. (#SP case_list $ fn $ fc $ x#))) &&&\n     (\\<And>fp p.\n         case_prod $ fp $ p \\<equiv>\n         (\\<bind>) $ (EVAL $ p) $\n         (\\<lambda>x. (#SP case_prod $ fp $ x#)))) &&&\n    ((\\<And>fn fs ov.\n         case_option $ fn $ fs $ ov \\<equiv>\n         (\\<bind>) $ (EVAL $ ov) $\n         (\\<lambda>x. (#SP case_option $ fn $ fs $ x#))) &&&\n     (\\<And>b t e.\n         If $ b $ t $ e \\<equiv>\n         (\\<bind>) $ (EVAL $ b) $ (\\<lambda>x. (#SP If $ x $ t $ e#)))) &&&\n    (\\<And>x.\n        RETURN $ x \\<equiv>\n        (\\<bind>) $ (EVAL $ x) $ (\\<lambda>x. (#SP (RETURN $ x)#))) &&&\n    (\\<And>x f.\n        Let $ x $ f \\<equiv>\n        (\\<bind>) $ (EVAL $ x) $ (\\<lambda>x. (#SP Let $ x $ f#)))", "by (simp_all)"], ["", "lemma dflt_plain_comb[sepref_monadify_comb]:\n  \"EVAL$(If$b$t$e) \\<equiv> Refine_Basic.bind$(EVAL$b)$(\\<lambda>\\<^sub>2b. If$b$(EVAL$t)$(EVAL$e))\"\n  \"EVAL$(case_list$fn$(\\<lambda>\\<^sub>2x xs. fc x xs)$l) \\<equiv> \n    Refine_Basic.bind$(EVAL$l)$(\\<lambda>\\<^sub>2l. case_list$(EVAL$fn)$(\\<lambda>\\<^sub>2x xs. EVAL$(fc x xs))$l)\"\n  \"EVAL$(case_prod$(\\<lambda>\\<^sub>2a b. fp a b)$p) \\<equiv> \n    Refine_Basic.bind$(EVAL$p)$(\\<lambda>\\<^sub>2p. case_prod$(\\<lambda>\\<^sub>2a b. EVAL$(fp a b))$p)\"\n  \"EVAL$(case_option$fn$(\\<lambda>\\<^sub>2x. fs x)$ov) \\<equiv> \n    Refine_Basic.bind$(EVAL$ov)$(\\<lambda>\\<^sub>2ov. case_option$(EVAL$fn)$(\\<lambda>\\<^sub>2x. EVAL$(fs x))$ov)\"\n  \"EVAL $ (Let $ v $ (\\<lambda>\\<^sub>2x. f x)) \\<equiv> (\\<bind>) $ (EVAL $ v) $ (\\<lambda>\\<^sub>2x. EVAL $ (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((EVAL $ (If $ b $ t $ e) \\<equiv>\n      (\\<bind>) $ (EVAL $ b) $\n      (\\<lambda>x. (#If $ x $ (EVAL $ t) $ (EVAL $ e)#))) &&&\n     EVAL $\n     (case_list $ fn $ (\\<lambda>x. (#\\<lambda>xa. (#fc x xa#)#)) $\n      l) \\<equiv>\n     (\\<bind>) $ (EVAL $ l) $\n     (\\<lambda>x.\n         (#case_list $ (EVAL $ fn) $\n           (\\<lambda>x. (#\\<lambda>xa. (#EVAL $ fc x xa#)#)) $\n           x#))) &&&\n    (EVAL $\n     (case_prod $ (\\<lambda>x. (#\\<lambda>xa. (#fp x xa#)#)) $ p) \\<equiv>\n     (\\<bind>) $ (EVAL $ p) $\n     (\\<lambda>x.\n         (#case_prod $ (\\<lambda>x. (#\\<lambda>xa. (#EVAL $ fp x xa#)#)) $\n           x#))) &&&\n    (EVAL $ (case_option $ fn $ (\\<lambda>x. (#fs x#)) $ ov) \\<equiv>\n     (\\<bind>) $ (EVAL $ ov) $\n     (\\<lambda>x.\n         (#case_option $ (EVAL $ fn) $ (\\<lambda>x. (#EVAL $ fs x#)) $\n           x#))) &&&\n    EVAL $ (Let $ v $ (\\<lambda>x. (#f x#))) \\<equiv>\n    (\\<bind>) $ (EVAL $ v) $ (\\<lambda>x. (#EVAL $ f x#))", "apply (rule eq_reflection, simp split: list.split prod.split option.split)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma evalcomb_PR_CONST[sepref_monadify_comb]:\n  \"EVAL$(PR_CONST x) \\<equiv> SP (RETURN$(PR_CONST x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. EVAL $ PR_CONST x \\<equiv> SP (RETURN $ PR_CONST x)", "by simp"], ["", "end"]]}