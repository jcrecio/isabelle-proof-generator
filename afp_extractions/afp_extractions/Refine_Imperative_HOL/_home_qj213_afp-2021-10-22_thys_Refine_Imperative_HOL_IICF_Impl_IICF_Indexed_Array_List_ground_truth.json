{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/IICF/Impl/IICF_Indexed_Array_List.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemma l_len: \"length l \\<le> length qp\"", "lemma idx_len[simp]: \"i<length l \\<Longrightarrow> l!i < length qp\"", "lemma l_set_simp[simp]: \"k\\<in>set l \\<Longrightarrow> k < length qp\"", "lemma qpk_idx: \"k<length qp \\<Longrightarrow> qp ! k < length l \\<longleftrightarrow> k \\<in> set l\"", "lemma lqpk[simp]: \"k \\<in> set l \\<Longrightarrow> l ! (qp ! k) = k\"", "lemma \"\\<lbrakk>i<length l; j<length l; l!i=l!j\\<rbrakk> \\<Longrightarrow> i=j\"", "lemmas index_swap[simp] = index_swap_if_distinct[folded swap_def, OF l_distinct]", "lemma swap_invar:  \n      assumes \"i<length l\" \"j<length l\"\n      shows \"ial_invar (length qp) (swap l i j) (qp[l ! j := i, l ! i := j])\"", "lemmas [safe_constraint_rules] = CN_FALSEI[of is_pure \"ial_assn maxsize A\" for maxsize A]", "lemma [def_pat_rules]: \"op_ial_empty_sz$maxsize \\<equiv> UNPROTECT (op_ial_empty_sz maxsize)\"", "lemma aial_empty_impl: \"(aial_empty,RETURN op_list_empty) \\<in> \\<langle>ial_rel1 maxsize\\<rangle>nres_rel\"", "lemma ial_empty_sz_hnr[sepref_fr_rules]: \n      \"(uncurry0 local.ial_empty, uncurry0 (RETURN (PR_CONST (op_ial_empty_sz maxsize)))) \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a ial_assn maxsize A\"", "lemma in_ial_rel1_conv: \n      \"((pq, qp), l) \\<in> ial_rel1 ms \\<longleftrightarrow> pq=l \\<and> ial_invar ms l qp\"", "lemma aial_swap_impl: \n      \"(aial_swap,mop_list_swap) \\<in> ial_rel1 maxsize \\<rightarrow> nat_rel \\<rightarrow> nat_rel \\<rightarrow> \\<langle>ial_rel1 maxsize\\<rangle>nres_rel\"", "lemma aial_length_impl: \"(aial_length, mop_list_length) \\<in> ial_rel1 maxsize \\<rightarrow> \\<langle>nat_rel\\<rangle>nres_rel\"", "lemma aial_index_impl: \n      \"(uncurry aial_index, uncurry mop_list_index) \\<in> \n        [\\<lambda>(l,k). k\\<in>set l]\\<^sub>f ial_rel1 maxsize \\<times>\\<^sub>r nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>nres_rel\"", "lemma aial_butlast_refine: \"(aial_butlast, mop_list_butlast) \\<in> ial_rel1 maxsize \\<rightarrow> \\<langle>ial_rel1 maxsize\\<rangle>nres_rel\"", "lemma aial_append_refine: \n      \"(uncurry aial_append,uncurry mop_list_append) \\<in> \n        [\\<lambda>(l,k). k<maxsize \\<and> k\\<notin>set l]\\<^sub>f ial_rel1 maxsize \\<times>\\<^sub>r nat_rel \\<rightarrow> \\<langle>ial_rel1 maxsize\\<rangle>nres_rel\"", "lemma aial_append_impl_aux: \"((l, qp), l') \\<in> ial_rel1 maxsize \\<Longrightarrow> l'=l \\<and> maxsize = length qp\"", "lemma \"(\\<lambda>b. b<maxsize, X) \\<in> A \\<rightarrow> bool_rel\"", "lemma append_fref': \"\\<lbrakk>IS_BELOW_ID R\\<rbrakk> \n        \\<Longrightarrow> (uncurry mop_list_append, uncurry mop_list_append) \\<in> \\<langle>R\\<rangle>list_rel \\<times>\\<^sub>r R \\<rightarrow>\\<^sub>f \\<langle>\\<langle>R\\<rangle>list_rel\\<rangle>nres_rel\"", "lemma aial_get_refine: \"(aial_get,mop_list_get) \\<in> ial_rel1 maxsize \\<rightarrow> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>nres_rel\"", "lemma aial_contains_refine: \"(uncurry aial_contains,uncurry mop_list_contains) \n      \\<in> (nat_rel \\<times>\\<^sub>r ial_rel1 maxsize) \\<rightarrow>\\<^sub>f \\<langle>bool_rel\\<rangle>nres_rel\""], "translations": [["", "lemma l_len: \"length l \\<le> length qp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length l \\<le> length qp", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length l \\<le> length qp", "from card_mono[OF _ l_set]"], ["proof (chain)\npicking this:\n  finite {0..<length qp} \\<Longrightarrow>\n  card (set l) \\<le> card {0..<length qp}", "have \"card (set l) \\<le> length qp\""], ["proof (prove)\nusing this:\n  finite {0..<length qp} \\<Longrightarrow>\n  card (set l) \\<le> card {0..<length qp}\n\ngoal (1 subgoal):\n 1. card (set l) \\<le> length qp", "by auto"], ["proof (state)\nthis:\n  card (set l) \\<le> length qp\n\ngoal (1 subgoal):\n 1. length l \\<le> length qp", "with distinct_card[OF l_distinct]"], ["proof (chain)\npicking this:\n  card (set l) = length l\n  card (set l) \\<le> length qp", "show ?thesis"], ["proof (prove)\nusing this:\n  card (set l) = length l\n  card (set l) \\<le> length qp\n\ngoal (1 subgoal):\n 1. length l \\<le> length qp", "by simp"], ["proof (state)\nthis:\n  length l \\<le> length qp\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma idx_len[simp]: \"i<length l \\<Longrightarrow> l!i < length qp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length l \\<Longrightarrow> l ! i < length qp", "using l_set"], ["proof (prove)\nusing this:\n  set l \\<subseteq> {0..<length qp}\n\ngoal (1 subgoal):\n 1. i < length l \\<Longrightarrow> l ! i < length qp", "by (metis atLeastLessThan_iff nth_mem psubsetD psubsetI)"], ["", "lemma l_set_simp[simp]: \"k\\<in>set l \\<Longrightarrow> k < length qp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<in> set l \\<Longrightarrow> k < length qp", "by (auto dest: subsetD[OF l_set])"], ["", "lemma qpk_idx: \"k<length qp \\<Longrightarrow> qp ! k < length l \\<longleftrightarrow> k \\<in> set l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < length qp \\<Longrightarrow> (qp ! k < length l) = (k \\<in> set l)", "proof (rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>k < length qp; qp ! k < length l\\<rbrakk>\n    \\<Longrightarrow> k \\<in> set l\n 2. \\<lbrakk>k < length qp; k \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> qp ! k < length l", "assume A: \"k<length qp\""], ["proof (state)\nthis:\n  k < length qp\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k < length qp; qp ! k < length l\\<rbrakk>\n    \\<Longrightarrow> k \\<in> set l\n 2. \\<lbrakk>k < length qp; k \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> qp ! k < length l", "{"], ["proof (state)\nthis:\n  k < length qp\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k < length qp; qp ! k < length l\\<rbrakk>\n    \\<Longrightarrow> k \\<in> set l\n 2. \\<lbrakk>k < length qp; k \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> qp ! k < length l", "assume \"qp!k < length l\""], ["proof (state)\nthis:\n  qp ! k < length l\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k < length qp; qp ! k < length l\\<rbrakk>\n    \\<Longrightarrow> k \\<in> set l\n 2. \\<lbrakk>k < length qp; k \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> qp ! k < length l", "hence \"qp!k < length qp\""], ["proof (prove)\nusing this:\n  qp ! k < length l\n\ngoal (1 subgoal):\n 1. qp ! k < length qp", "using l_len"], ["proof (prove)\nusing this:\n  qp ! k < length l\n  length l \\<le> length qp\n\ngoal (1 subgoal):\n 1. qp ! k < length qp", "by simp"], ["proof (state)\nthis:\n  qp ! k < length qp\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k < length qp; qp ! k < length l\\<rbrakk>\n    \\<Longrightarrow> k \\<in> set l\n 2. \\<lbrakk>k < length qp; k \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> qp ! k < length l", "with spec[OF qp_def, of k] A"], ["proof (chain)\npicking this:\n  k < length qp \\<longrightarrow>\n  qp ! k = (if k \\<in> set l then index l k else length qp)\n  k < length qp\n  qp ! k < length qp", "show \"k\\<in>set l\""], ["proof (prove)\nusing this:\n  k < length qp \\<longrightarrow>\n  qp ! k = (if k \\<in> set l then index l k else length qp)\n  k < length qp\n  qp ! k < length qp\n\ngoal (1 subgoal):\n 1. k \\<in> set l", "by (auto split: if_split_asm)"], ["proof (state)\nthis:\n  k \\<in> set l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k < length qp; k \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> qp ! k < length l", "}"], ["proof (state)\nthis:\n  qp ! k < length l \\<Longrightarrow> k \\<in> set l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k < length qp; k \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> qp ! k < length l", "{"], ["proof (state)\nthis:\n  qp ! k < length l \\<Longrightarrow> k \\<in> set l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k < length qp; k \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> qp ! k < length l", "assume \"k\\<in>set l\""], ["proof (state)\nthis:\n  k \\<in> set l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k < length qp; k \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> qp ! k < length l", "thus \"qp!k<length l\""], ["proof (prove)\nusing this:\n  k \\<in> set l\n\ngoal (1 subgoal):\n 1. qp ! k < length l", "using qp_def"], ["proof (prove)\nusing this:\n  k \\<in> set l\n  \\<forall>k<length qp.\n     qp ! k = (if k \\<in> set l then index l k else length qp)\n\ngoal (1 subgoal):\n 1. qp ! k < length l", "by (auto split: if_split_asm) []"], ["proof (state)\nthis:\n  qp ! k < length l\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  k \\<in> set l \\<Longrightarrow> qp ! k < length l\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lqpk[simp]: \"k \\<in> set l \\<Longrightarrow> l ! (qp ! k) = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<in> set l \\<Longrightarrow> l ! (qp ! k) = k", "using spec[OF qp_def, of k]"], ["proof (prove)\nusing this:\n  k < length qp \\<longrightarrow>\n  qp ! k = (if k \\<in> set l then index l k else length qp)\n\ngoal (1 subgoal):\n 1. k \\<in> set l \\<Longrightarrow> l ! (qp ! k) = k", "by auto"], ["", "lemma \"\\<lbrakk>i<length l; j<length l; l!i=l!j\\<rbrakk> \\<Longrightarrow> i=j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length l; j < length l; l ! i = l ! j\\<rbrakk>\n    \\<Longrightarrow> i = j", "by (simp add: nth_eq_iff_index_eq)"], ["", "lemmas index_swap[simp] = index_swap_if_distinct[folded swap_def, OF l_distinct]"], ["", "lemma swap_invar:  \n      assumes \"i<length l\" \"j<length l\"\n      shows \"ial_invar (length qp) (swap l i j) (qp[l ! j := i, l ! i := j])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ial_invar (length qp) (swap l i j) (qp[l ! j := i, l ! i := j])", "using assms"], ["proof (prove)\nusing this:\n  i < length l\n  j < length l\n\ngoal (1 subgoal):\n 1. ial_invar (length qp) (swap l i j) (qp[l ! j := i, l ! i := j])", "apply unfold_locales"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>i < length l; j < length l\\<rbrakk>\n    \\<Longrightarrow> length qp = length (qp[l ! j := i, l ! i := j])\n 2. \\<lbrakk>i < length l; j < length l\\<rbrakk>\n    \\<Longrightarrow> distinct (swap l i j)\n 3. \\<lbrakk>i < length l; j < length l\\<rbrakk>\n    \\<Longrightarrow> set (swap l i j)\n                      \\<subseteq> {0..<length (qp[l ! j := i, l ! i := j])}\n 4. \\<lbrakk>i < length l; j < length l\\<rbrakk>\n    \\<Longrightarrow> \\<forall>k<length (qp[l ! j := i, l ! i := j]).\n                         qp[l ! j := i, l ! i := j] ! k =\n                         (if k \\<in> set (swap l i j)\n                          then index (swap l i j) k\n                          else length (qp[l ! j := i, l ! i := j]))", "apply auto []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>i < length l; j < length l\\<rbrakk>\n    \\<Longrightarrow> distinct (swap l i j)\n 2. \\<lbrakk>i < length l; j < length l\\<rbrakk>\n    \\<Longrightarrow> set (swap l i j)\n                      \\<subseteq> {0..<length (qp[l ! j := i, l ! i := j])}\n 3. \\<lbrakk>i < length l; j < length l\\<rbrakk>\n    \\<Longrightarrow> \\<forall>k<length (qp[l ! j := i, l ! i := j]).\n                         qp[l ! j := i, l ! i := j] ! k =\n                         (if k \\<in> set (swap l i j)\n                          then index (swap l i j) k\n                          else length (qp[l ! j := i, l ! i := j]))", "apply auto []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>i < length l; j < length l\\<rbrakk>\n    \\<Longrightarrow> set (swap l i j)\n                      \\<subseteq> {0..<length (qp[l ! j := i, l ! i := j])}\n 2. \\<lbrakk>i < length l; j < length l\\<rbrakk>\n    \\<Longrightarrow> \\<forall>k<length (qp[l ! j := i, l ! i := j]).\n                         qp[l ! j := i, l ! i := j] ! k =\n                         (if k \\<in> set (swap l i j)\n                          then index (swap l i j) k\n                          else length (qp[l ! j := i, l ! i := j]))", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length l; j < length l\\<rbrakk>\n    \\<Longrightarrow> \\<forall>k<length (qp[l ! j := i, l ! i := j]).\n                         qp[l ! j := i, l ! i := j] ! k =\n                         (if k \\<in> set (swap l i j)\n                          then index (swap l i j) k\n                          else length (qp[l ! j := i, l ! i := j]))", "apply (auto simp: simp: nth_list_update nth_eq_iff_index_eq index_nth_id) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>i < length l; j < length l; k \\<noteq> l ! j;\n        k \\<noteq> l ! i; k \\<in> set l\\<rbrakk>\n       \\<Longrightarrow> qp ! k = index l k\n 2. \\<And>k.\n       \\<lbrakk>i < length l; j < length l; k \\<noteq> l ! j;\n        k \\<noteq> l ! i; k \\<notin> set l; k < length qp\\<rbrakk>\n       \\<Longrightarrow> qp ! k = length qp", "using qp_def"], ["proof (prove)\nusing this:\n  \\<forall>k<length qp.\n     qp ! k = (if k \\<in> set l then index l k else length qp)\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>i < length l; j < length l; k \\<noteq> l ! j;\n        k \\<noteq> l ! i; k \\<in> set l\\<rbrakk>\n       \\<Longrightarrow> qp ! k = index l k\n 2. \\<And>k.\n       \\<lbrakk>i < length l; j < length l; k \\<noteq> l ! j;\n        k \\<noteq> l ! i; k \\<notin> set l; k < length qp\\<rbrakk>\n       \\<Longrightarrow> qp ! k = length qp", "apply auto [2]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "definition \"ial_rel1 maxsize \\<equiv> br fst (uncurry (ial_invar maxsize))\""], ["", "definition ial_assn2 :: \"nat \\<Rightarrow> nat list * nat list \\<Rightarrow> _\" where\n    \"ial_assn2 maxsize \\<equiv> prod_assn (marl_assn maxsize nat_assn) (array_assn nat_assn)\""], ["", "(*  definition \"ial_assn maxsize \\<equiv> hr_comp (ial_assn2 maxsize) (ial_rel1 maxsize)\"*)"], ["", "definition \"ial_assn maxsize A \\<equiv> hr_comp (hr_comp (ial_assn2 maxsize) (ial_rel1 maxsize)) (\\<langle>the_pure A\\<rangle>list_rel)\""], ["", "lemmas [safe_constraint_rules] = CN_FALSEI[of is_pure \"ial_assn maxsize A\" for maxsize A]"], ["", "(*  lemma ial_assn_precise[constraint_rules]: \"precise (ial_assn maxsize)\"\n    unfolding ial_assn_def ial_rel1_def ial_assn2_def\n    apply constraint_rules\n*)"], ["", "subsection \\<open>Empty\\<close>"], ["", "definition op_ial_empty_sz :: \"nat \\<Rightarrow> 'a list\" \n    where [simp]: \"op_ial_empty_sz ms \\<equiv> op_list_empty\""], ["", "lemma [def_pat_rules]: \"op_ial_empty_sz$maxsize \\<equiv> UNPROTECT (op_ial_empty_sz maxsize)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op_ial_empty_sz $ maxsize \\<equiv> UNPROTECT (op_ial_empty_sz maxsize)", "by simp"], ["", "context fixes maxsize :: nat begin"], ["", "sepref_register \"PR_CONST (op_ial_empty_sz maxsize)\""], ["", "end"], ["", "context \n    fixes maxsize :: nat (* If we do not fix maxsize here, the FCOMP-rule will \n      derive a more general rule with two different maxsizes! *)\n    notes [fcomp_norm_unfold] = ial_assn_def[symmetric]  \n    notes [simp] = hn_ctxt_def pure_def\n  begin"], ["", "definition \"aial_empty \\<equiv> do {\n      let l = op_marl_empty_sz maxsize;\n      let qp = op_array_replicate maxsize maxsize;\n      RETURN (l,qp)\n    }\""], ["", "lemma aial_empty_impl: \"(aial_empty,RETURN op_list_empty) \\<in> \\<langle>ial_rel1 maxsize\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.aial_empty, RETURN op_list_empty)\n    \\<in> \\<langle>ial_rel1 maxsize\\<rangle>nres_rel", "unfolding aial_empty_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let l = op_marl_empty_sz maxsize;\n         qp = op_array_replicate maxsize maxsize\n     in RETURN (l, qp),\n     RETURN op_list_empty)\n    \\<in> \\<langle>ial_rel1 maxsize\\<rangle>nres_rel", "apply (refine_vcg nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((op_marl_empty_sz maxsize, op_array_replicate maxsize maxsize),\n     op_list_empty)\n    \\<in> ial_rel1 maxsize", "apply (clarsimp simp: ial_rel1_def br_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ial_invar maxsize [] (replicate maxsize maxsize)", "apply unfold_locales"], ["proof (prove)\ngoal (4 subgoals):\n 1. maxsize = length (replicate maxsize maxsize)\n 2. distinct []\n 3. set [] \\<subseteq> {0..<length (replicate maxsize maxsize)}\n 4. \\<forall>k<length (replicate maxsize maxsize).\n       replicate maxsize maxsize ! k =\n       (if k \\<in> set [] then index [] k\n        else length (replicate maxsize maxsize))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* Note: This lemma requires some setup to handle maxsize simultaneously\n      as a parameter, and as a constant. \n    *)"], ["", "context \n      notes [id_rules] = itypeI[Pure.of maxsize \"TYPE(nat)\"]\n      notes [sepref_import_param] = IdI[of maxsize]\n    begin"], ["", "sepref_definition ial_empty is \"uncurry0 aial_empty\" :: \"unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a ial_assn2 maxsize\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2, uncurry0 local.aial_empty)\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a ial_assn2 maxsize", "unfolding aial_empty_def ial_assn2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2,\n     uncurry0\n      (let l = op_marl_empty_sz maxsize;\n           qp = op_array_replicate maxsize maxsize\n       in RETURN (l, qp)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a marl_assn maxsize\n             nat_assn \\<times>\\<^sub>a\n            array_assn nat_assn", "using [[id_debug]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2,\n     uncurry0\n      (let l = op_marl_empty_sz maxsize;\n           qp = op_array_replicate maxsize maxsize\n       in RETURN (l, qp)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a marl_assn maxsize\n             nat_assn \\<times>\\<^sub>a\n            array_assn nat_assn", "by sepref"], ["", "end"], ["", "sepref_decl_impl (no_register) ial_empty: ial_empty.refine[FCOMP aial_empty_impl]"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma ial_empty_sz_hnr[sepref_fr_rules]: \n      \"(uncurry0 local.ial_empty, uncurry0 (RETURN (PR_CONST (op_ial_empty_sz maxsize)))) \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a ial_assn maxsize A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 local.ial_empty,\n     uncurry0 (RETURN (PR_CONST (op_ial_empty_sz maxsize))))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a ial_assn maxsize A", "using ial_empty_hnr[of A]"], ["proof (prove)\nusing this:\n  (uncurry0 local.ial_empty, uncurry0 (RETURN op_list_empty))\n  \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a ial_assn maxsize A\n\ngoal (1 subgoal):\n 1. (uncurry0 local.ial_empty,\n     uncurry0 (RETURN (PR_CONST (op_ial_empty_sz maxsize))))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a ial_assn maxsize A", "by simp"], ["", "subsection \\<open>Swap\\<close>"], ["", "definition \"aial_swap \\<equiv> \\<lambda>(l,qp) i j. do {\n      vi \\<leftarrow> mop_list_get l i;\n      vj \\<leftarrow> mop_list_get l j;\n      l \\<leftarrow> mop_list_set l i vj;\n      l \\<leftarrow> mop_list_set l j vi;\n      qp \\<leftarrow> mop_list_set qp vj i;\n      qp \\<leftarrow> mop_list_set qp vi j;\n      RETURN (l,qp)\n    }\""], ["", "lemma in_ial_rel1_conv: \n      \"((pq, qp), l) \\<in> ial_rel1 ms \\<longleftrightarrow> pq=l \\<and> ial_invar ms l qp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((pq, qp), l) \\<in> ial_rel1 ms) = (pq = l \\<and> ial_invar ms l qp)", "by (auto simp: ial_rel1_def in_br_conv)"], ["", "lemma aial_swap_impl: \n      \"(aial_swap,mop_list_swap) \\<in> ial_rel1 maxsize \\<rightarrow> nat_rel \\<rightarrow> nat_rel \\<rightarrow> \\<langle>ial_rel1 maxsize\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (aial_swap, mop_list_swap)\n    \\<in> ial_rel1 maxsize \\<rightarrow>\n          nat_rel \\<rightarrow>\n          nat_rel \\<rightarrow> \\<langle>ial_rel1 maxsize\\<rangle>nres_rel", "proof (intro fun_relI nres_relI; clarsimp simp: in_ial_rel1_conv; refine_vcg; clarsimp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b a'a a'b.\n       \\<lbrakk>ial_invar maxsize a b; a'a < length a;\n        a'b < length a\\<rbrakk>\n       \\<Longrightarrow> aial_swap (a, b) a'a a'b\n                         \\<le> SPEC\n                                (\\<lambda>c.\n                                    (c, swap a a'a a'b)\n                                    \\<in> ial_rel1 maxsize)", "fix l qp i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b a'a a'b.\n       \\<lbrakk>ial_invar maxsize a b; a'a < length a;\n        a'b < length a\\<rbrakk>\n       \\<Longrightarrow> aial_swap (a, b) a'a a'b\n                         \\<le> SPEC\n                                (\\<lambda>c.\n                                    (c, swap a a'a a'b)\n                                    \\<in> ial_rel1 maxsize)", "assume [simp]: \"i<length l\" \"j<length l\" and \"ial_invar maxsize l qp\""], ["proof (state)\nthis:\n  i < length l\n  j < length l\n  ial_invar maxsize l qp\n\ngoal (1 subgoal):\n 1. \\<And>a b a'a a'b.\n       \\<lbrakk>ial_invar maxsize a b; a'a < length a;\n        a'b < length a\\<rbrakk>\n       \\<Longrightarrow> aial_swap (a, b) a'a a'b\n                         \\<le> SPEC\n                                (\\<lambda>c.\n                                    (c, swap a a'a a'b)\n                                    \\<in> ial_rel1 maxsize)", "then"], ["proof (chain)\npicking this:\n  i < length l\n  j < length l\n  ial_invar maxsize l qp", "interpret ial_invar maxsize l qp"], ["proof (prove)\nusing this:\n  i < length l\n  j < length l\n  ial_invar maxsize l qp\n\ngoal (1 subgoal):\n 1. ial_invar maxsize l qp", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b a'a a'b.\n       \\<lbrakk>ial_invar maxsize a b; a'a < length a;\n        a'b < length a\\<rbrakk>\n       \\<Longrightarrow> aial_swap (a, b) a'a a'b\n                         \\<le> SPEC\n                                (\\<lambda>c.\n                                    (c, swap a a'a a'b)\n                                    \\<in> ial_rel1 maxsize)", "show \"aial_swap (l, qp) i j \\<le> SPEC (\\<lambda>c. (c, swap l i j) \\<in> ial_rel1 maxsize)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aial_swap (l, qp) i j\n    \\<le> SPEC (\\<lambda>c. (c, swap l i j) \\<in> ial_rel1 maxsize)", "unfolding aial_swap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (l, qp) of\n     (l, qp) \\<Rightarrow>\n       \\<lambda>i j.\n          mop_list_get l i \\<bind>\n          (\\<lambda>vi.\n              mop_list_get l j \\<bind>\n              (\\<lambda>vj.\n                  mop_list_set l i vj \\<bind>\n                  (\\<lambda>l.\n                      mop_list_set l j vi \\<bind>\n                      (\\<lambda>l.\n                          mop_list_set qp vj i \\<bind>\n                          (\\<lambda>qp.\n                              mop_list_set qp vi j \\<bind>\n                              (\\<lambda>qp. RETURN (l, qp))))))))\n     i j\n    \\<le> SPEC (\\<lambda>c. (c, swap l i j) \\<in> ial_rel1 maxsize)", "apply refine_vcg"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x1 x2. (l, qp) = (x1, x2) \\<Longrightarrow> i < length x1\n 2. \\<And>x1 x2. (l, qp) = (x1, x2) \\<Longrightarrow> j < length x1\n 3. \\<And>x1 x2. (l, qp) = (x1, x2) \\<Longrightarrow> i < length x1\n 4. \\<And>x1 x2.\n       (l, qp) = (x1, x2) \\<Longrightarrow> j < length (x1[i := x1 ! j])\n 5. \\<And>x1 x2. (l, qp) = (x1, x2) \\<Longrightarrow> x1 ! j < length x2\n 6. \\<And>x1 x2.\n       (l, qp) = (x1, x2) \\<Longrightarrow>\n       x1 ! i < length (x2[x1 ! j := i])\n 7. \\<And>x1 x2.\n       (l, qp) = (x1, x2) \\<Longrightarrow>\n       ((x1[i := x1 ! j, j := x1 ! i], x2[x1 ! j := i, x1 ! i := j]),\n        swap l i j)\n       \\<in> ial_rel1 maxsize", "apply (vc_solve simp add: in_ial_rel1_conv swap_def[symmetric] swap_invar)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  aial_swap (l, qp) i j\n  \\<le> SPEC (\\<lambda>c. (c, swap l i j) \\<in> ial_rel1 maxsize)\n\ngoal:\nNo subgoals!", "qed"], ["", "sepref_definition ial_swap is\n      \"uncurry2 aial_swap\" :: \"(ial_assn2 maxsize)\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a ial_assn2 maxsize\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3, uncurry2 aial_swap)\n    \\<in> (ial_assn2 maxsize)\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a ial_assn2 maxsize", "unfolding aial_swap_def ial_assn2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>(l, qp) i j.\n          mop_list_get l i \\<bind>\n          (\\<lambda>vi.\n              mop_list_get l j \\<bind>\n              (\\<lambda>vj.\n                  mop_list_set l i vj \\<bind>\n                  (\\<lambda>l.\n                      mop_list_set l j vi \\<bind>\n                      (\\<lambda>l.\n                          mop_list_set qp vj i \\<bind>\n                          (\\<lambda>qp.\n                              mop_list_set qp vi j \\<bind>\n                              (\\<lambda>qp. RETURN (l, qp)))))))))\n    \\<in> (marl_assn maxsize nat_assn \\<times>\\<^sub>a\n           array_assn nat_assn)\\<^sup>d *\\<^sub>a\n          nat_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a marl_assn maxsize\n            nat_assn \\<times>\\<^sub>a\n           array_assn nat_assn", "by sepref"], ["", "sepref_decl_impl (ismop) test: ial_swap.refine[FCOMP aial_swap_impl] \n      uses mop_list_swap.fref"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "subsection \\<open>Length\\<close>"], ["", "definition aial_length :: \"aial \\<Rightarrow> nat nres\" \n      where \"aial_length \\<equiv> \\<lambda>(l,_). RETURN (op_list_length l)\""], ["", "lemma aial_length_impl: \"(aial_length, mop_list_length) \\<in> ial_rel1 maxsize \\<rightarrow> \\<langle>nat_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (aial_length, mop_list_length)\n    \\<in> ial_rel1 maxsize \\<rightarrow> \\<langle>nat_rel\\<rangle>nres_rel", "apply (intro fun_relI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> ial_rel1 maxsize \\<Longrightarrow>\n       aial_length a \\<le> \\<Down> nat_rel (mop_list_length a')", "unfolding ial_rel1_def in_br_conv aial_length_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       a' = fst a \\<and> uncurry (ial_invar maxsize) a \\<Longrightarrow>\n       (case a of (l, uu_) \\<Rightarrow> RETURN (op_list_length l))\n       \\<le> \\<Down> nat_rel (mop_list_length a')", "by auto"], ["", "sepref_definition ial_length is \"aial_length\" :: \"(ial_assn2 maxsize)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, aial_length)\n    \\<in> (ial_assn2 maxsize)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "unfolding aial_length_def ial_assn2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, \\<lambda>(l, uu_). RETURN (op_list_length l))\n    \\<in> (marl_assn maxsize nat_assn \\<times>\\<^sub>a\n           array_assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "by sepref"], ["", "sepref_decl_impl (ismop) ial_length: ial_length.refine[FCOMP aial_length_impl]"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "subsection \\<open>Index\\<close>"], ["", "definition aial_index :: \"aial \\<Rightarrow> nat \\<Rightarrow> nat nres\" where\n      \"aial_index \\<equiv> \\<lambda>(l,qp) k. do {\n        ASSERT (k\\<in>set l);\n        i \\<leftarrow> mop_list_get qp k;\n        RETURN i\n      }\""], ["", "lemma aial_index_impl: \n      \"(uncurry aial_index, uncurry mop_list_index) \\<in> \n        [\\<lambda>(l,k). k\\<in>set l]\\<^sub>f ial_rel1 maxsize \\<times>\\<^sub>r nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry aial_index, uncurry mop_list_index)\n    \\<in> [\\<lambda>(l, k).\n              k \\<in> set l]\\<^sub>f ial_rel1 maxsize \\<times>\\<^sub>r\n                                     nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>nres_rel", "apply (intro fun_relI nres_relI frefI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>case y of (l, k) \\<Rightarrow> k \\<in> set l;\n        (x, y) \\<in> ial_rel1 maxsize \\<times>\\<^sub>r nat_rel\\<rbrakk>\n       \\<Longrightarrow> uncurry aial_index x\n                         \\<le> \\<Down> nat_rel (uncurry mop_list_index y)", "unfolding ial_rel1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>case y of (l, k) \\<Rightarrow> k \\<in> set l;\n        (x, y)\n        \\<in> br fst (uncurry (ial_invar maxsize)) \\<times>\\<^sub>r\n              nat_rel\\<rbrakk>\n       \\<Longrightarrow> uncurry aial_index x\n                         \\<le> \\<Down> nat_rel (uncurry mop_list_index y)", "proof (clarsimp simp:  in_br_conv)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<lbrakk>ba \\<in> set a; ial_invar maxsize a b\\<rbrakk>\n       \\<Longrightarrow> aial_index (a, b) ba \\<le> RETURN (index a ba)", "fix l qp k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<lbrakk>ba \\<in> set a; ial_invar maxsize a b\\<rbrakk>\n       \\<Longrightarrow> aial_index (a, b) ba \\<le> RETURN (index a ba)", "assume \"ial_invar maxsize l qp\""], ["proof (state)\nthis:\n  ial_invar maxsize l qp\n\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<lbrakk>ba \\<in> set a; ial_invar maxsize a b\\<rbrakk>\n       \\<Longrightarrow> aial_index (a, b) ba \\<le> RETURN (index a ba)", "then"], ["proof (chain)\npicking this:\n  ial_invar maxsize l qp", "interpret ial_invar maxsize l qp"], ["proof (prove)\nusing this:\n  ial_invar maxsize l qp\n\ngoal (1 subgoal):\n 1. ial_invar maxsize l qp", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<lbrakk>ba \\<in> set a; ial_invar maxsize a b\\<rbrakk>\n       \\<Longrightarrow> aial_index (a, b) ba \\<le> RETURN (index a ba)", "assume \"k\\<in>set l\""], ["proof (state)\nthis:\n  k \\<in> set l\n\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<lbrakk>ba \\<in> set a; ial_invar maxsize a b\\<rbrakk>\n       \\<Longrightarrow> aial_index (a, b) ba \\<le> RETURN (index a ba)", "then"], ["proof (chain)\npicking this:\n  k \\<in> set l", "show \"aial_index (l,qp) k \\<le> RETURN (index l k)\""], ["proof (prove)\nusing this:\n  k \\<in> set l\n\ngoal (1 subgoal):\n 1. aial_index (l, qp) k \\<le> RETURN (index l k)", "unfolding aial_index_def"], ["proof (prove)\nusing this:\n  k \\<in> set l\n\ngoal (1 subgoal):\n 1. (case (l, qp) of\n     (l, qp) \\<Rightarrow>\n       \\<lambda>k.\n          ASSERT (k \\<in> set l) \\<bind>\n          (\\<lambda>_. mop_list_get qp k \\<bind> RETURN))\n     k\n    \\<le> RETURN (index l k)", "apply (refine_vcg)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>k \\<in> set l; (l, qp) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> k \\<in> set x1\n 2. \\<And>x1 x2.\n       \\<lbrakk>k \\<in> set l; (l, qp) = (x1, x2); k \\<in> set x1\\<rbrakk>\n       \\<Longrightarrow> k < length x2\n 3. \\<And>x1 x2.\n       \\<lbrakk>k \\<in> set l; (l, qp) = (x1, x2); k \\<in> set x1\\<rbrakk>\n       \\<Longrightarrow> index l k = x2 ! k", "by (auto simp: qp_def)"], ["proof (state)\nthis:\n  aial_index (l, qp) k \\<le> RETURN (index l k)\n\ngoal:\nNo subgoals!", "qed"], ["", "sepref_definition ial_index is \"uncurry aial_index\" :: \"(ial_assn2 maxsize)\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry aial_index)\n    \\<in> (ial_assn2 maxsize)\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "unfolding aial_index_def ial_assn2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>(l, qp) k.\n          ASSERT (k \\<in> set l) \\<bind>\n          (\\<lambda>_. mop_list_get qp k \\<bind> RETURN)))\n    \\<in> (marl_assn maxsize nat_assn \\<times>\\<^sub>a\n           array_assn nat_assn)\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "by sepref"], ["", "sepref_decl_impl (ismop) ial_index: ial_index.refine[FCOMP aial_index_impl]"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "subsection \\<open>Butlast\\<close>"], ["", "definition aial_butlast :: \"aial \\<Rightarrow> aial nres\" where\n      \"aial_butlast \\<equiv> \\<lambda>(l,qp). do {\n        ASSERT (l\\<noteq>[]);\n        len \\<leftarrow> mop_list_length l;\n        k \\<leftarrow> mop_list_get l (len - 1);\n        l \\<leftarrow> mop_list_butlast l;\n        qp \\<leftarrow> mop_list_set qp k (length qp);\n        RETURN (l,qp)\n      }\""], ["", "lemma aial_butlast_refine: \"(aial_butlast, mop_list_butlast) \\<in> ial_rel1 maxsize \\<rightarrow> \\<langle>ial_rel1 maxsize\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (aial_butlast, mop_list_butlast)\n    \\<in> ial_rel1 maxsize \\<rightarrow>\n          \\<langle>ial_rel1 maxsize\\<rangle>nres_rel", "apply (intro fun_relI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> ial_rel1 maxsize \\<Longrightarrow>\n       aial_butlast a \\<le> \\<Down> (ial_rel1 maxsize) (mop_list_butlast a')", "unfolding ial_rel1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> br fst (uncurry (ial_invar maxsize)) \\<Longrightarrow>\n       aial_butlast a\n       \\<le> \\<Down> (br fst (uncurry (ial_invar maxsize)))\n              (mop_list_butlast a')", "proof (clarsimp simp: in_br_conv simp del: mop_list_butlast_alt)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       ial_invar maxsize a b \\<Longrightarrow>\n       aial_butlast (a, b)\n       \\<le> \\<Down> (br fst (uncurry (ial_invar maxsize)))\n              (mop_list_butlast a)", "fix l qp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       ial_invar maxsize a b \\<Longrightarrow>\n       aial_butlast (a, b)\n       \\<le> \\<Down> (br fst (uncurry (ial_invar maxsize)))\n              (mop_list_butlast a)", "assume \"ial_invar maxsize l qp\""], ["proof (state)\nthis:\n  ial_invar maxsize l qp\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       ial_invar maxsize a b \\<Longrightarrow>\n       aial_butlast (a, b)\n       \\<le> \\<Down> (br fst (uncurry (ial_invar maxsize)))\n              (mop_list_butlast a)", "then"], ["proof (chain)\npicking this:\n  ial_invar maxsize l qp", "interpret ial_invar maxsize l qp"], ["proof (prove)\nusing this:\n  ial_invar maxsize l qp\n\ngoal (1 subgoal):\n 1. ial_invar maxsize l qp", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       ial_invar maxsize a b \\<Longrightarrow>\n       aial_butlast (a, b)\n       \\<le> \\<Down> (br fst (uncurry (ial_invar maxsize)))\n              (mop_list_butlast a)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       ial_invar maxsize a b \\<Longrightarrow>\n       aial_butlast (a, b)\n       \\<le> \\<Down> (br fst (uncurry (ial_invar maxsize)))\n              (mop_list_butlast a)", "assume A: \"l\\<noteq>[]\""], ["proof (state)\nthis:\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       ial_invar maxsize a b \\<Longrightarrow>\n       aial_butlast (a, b)\n       \\<le> \\<Down> (br fst (uncurry (ial_invar maxsize)))\n              (mop_list_butlast a)", "have \"ial_invar (length qp) (butlast l) (qp[l ! (length l - Suc 0) := length qp])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ial_invar (length qp) (butlast l)\n     (qp[l ! (length l - Suc 0) := length qp])", "apply standard"], ["proof (prove)\ngoal (4 subgoals):\n 1. length qp = length (qp[l ! (length l - Suc 0) := length qp])\n 2. distinct (butlast l)\n 3. set (butlast l)\n    \\<subseteq> {0..<length (qp[l ! (length l - Suc 0) := length qp])}\n 4. \\<forall>k<length (qp[l ! (length l - Suc 0) := length qp]).\n       qp[l ! (length l - Suc 0) := length qp] ! k =\n       (if k \\<in> set (butlast l) then index (butlast l) k\n        else length (qp[l ! (length l - Suc 0) := length qp]))", "apply clarsimp_all"], ["proof (prove)\ngoal (3 subgoals):\n 1. distinct (butlast l)\n 2. \\<And>x. x \\<in> set (butlast l) \\<Longrightarrow> x < length qp\n 3. \\<And>k.\n       (k \\<in> set (butlast l) \\<longrightarrow>\n        k < length qp \\<longrightarrow>\n        qp[l ! (length l - Suc 0) := length qp] ! k =\n        index (butlast l) k) \\<and>\n       (k \\<notin> set (butlast l) \\<longrightarrow>\n        k < length qp \\<longrightarrow>\n        qp[l ! (length l - Suc 0) := length qp] ! k = length qp)", "apply (auto simp: distinct_butlast) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> set (butlast l) \\<Longrightarrow> x < length qp\n 2. \\<And>k.\n       (k \\<in> set (butlast l) \\<longrightarrow>\n        k < length qp \\<longrightarrow>\n        qp[l ! (length l - Suc 0) := length qp] ! k =\n        index (butlast l) k) \\<and>\n       (k \\<notin> set (butlast l) \\<longrightarrow>\n        k < length qp \\<longrightarrow>\n        qp[l ! (length l - Suc 0) := length qp] ! k = length qp)", "using l_set"], ["proof (prove)\nusing this:\n  set l \\<subseteq> {0..<length qp}\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> set (butlast l) \\<Longrightarrow> x < length qp\n 2. \\<And>k.\n       (k \\<in> set (butlast l) \\<longrightarrow>\n        k < length qp \\<longrightarrow>\n        qp[l ! (length l - Suc 0) := length qp] ! k =\n        index (butlast l) k) \\<and>\n       (k \\<notin> set (butlast l) \\<longrightarrow>\n        k < length qp \\<longrightarrow>\n        qp[l ! (length l - Suc 0) := length qp] ! k = length qp)", "apply (auto dest: in_set_butlastD) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       (k \\<in> set (butlast l) \\<longrightarrow>\n        k < length qp \\<longrightarrow>\n        qp[l ! (length l - Suc 0) := length qp] ! k =\n        index (butlast l) k) \\<and>\n       (k \\<notin> set (butlast l) \\<longrightarrow>\n        k < length qp \\<longrightarrow>\n        qp[l ! (length l - Suc 0) := length qp] ! k = length qp)", "using qp_def A l_distinct"], ["proof (prove)\nusing this:\n  \\<forall>k<length qp.\n     qp ! k = (if k \\<in> set l then index l k else length qp)\n  l \\<noteq> []\n  distinct l\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       (k \\<in> set (butlast l) \\<longrightarrow>\n        k < length qp \\<longrightarrow>\n        qp[l ! (length l - Suc 0) := length qp] ! k =\n        index (butlast l) k) \\<and>\n       (k \\<notin> set (butlast l) \\<longrightarrow>\n        k < length qp \\<longrightarrow>\n        qp[l ! (length l - Suc 0) := length qp] ! k = length qp)", "apply (auto simp: nth_list_update neq_Nil_rev_conv index_append simp del: l_distinct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ial_invar (length qp) (butlast l)\n   (qp[l ! (length l - Suc 0) := length qp])\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       ial_invar maxsize a b \\<Longrightarrow>\n       aial_butlast (a, b)\n       \\<le> \\<Down> (br fst (uncurry (ial_invar maxsize)))\n              (mop_list_butlast a)", "}"], ["proof (state)\nthis:\n  l \\<noteq> [] \\<Longrightarrow>\n  ial_invar (length qp) (butlast l)\n   (qp[l ! (length l - Suc 0) := length qp])\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       ial_invar maxsize a b \\<Longrightarrow>\n       aial_butlast (a, b)\n       \\<le> \\<Down> (br fst (uncurry (ial_invar maxsize)))\n              (mop_list_butlast a)", "note aux1=this"], ["proof (state)\nthis:\n  l \\<noteq> [] \\<Longrightarrow>\n  ial_invar (length qp) (butlast l)\n   (qp[l ! (length l - Suc 0) := length qp])\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       ial_invar maxsize a b \\<Longrightarrow>\n       aial_butlast (a, b)\n       \\<le> \\<Down> (br fst (uncurry (ial_invar maxsize)))\n              (mop_list_butlast a)", "show \"aial_butlast (l, qp) \\<le> \\<Down> (br fst (uncurry (ial_invar maxsize))) (mop_list_butlast l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aial_butlast (l, qp)\n    \\<le> \\<Down> (br fst (uncurry (ial_invar maxsize)))\n           (mop_list_butlast l)", "unfolding aial_butlast_def mop_list_butlast_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (l, qp) of\n     (l, qp) \\<Rightarrow>\n       ASSERT (l \\<noteq> []) \\<bind>\n       (\\<lambda>_.\n           mop_list_length l \\<bind>\n           (\\<lambda>len.\n               mop_list_get l (len - 1) \\<bind>\n               (\\<lambda>k.\n                   ASSERT (pre_list_butlast l) \\<bind>\n                   (\\<lambda>_. RETURN (op_list_butlast l)) \\<bind>\n                   (\\<lambda>l.\n                       mop_list_set qp k (length qp) \\<bind>\n                       (\\<lambda>qp. RETURN (l, qp)))))))\n    \\<le> \\<Down> (br fst (uncurry (ial_invar maxsize)))\n           (ASSERT (pre_list_butlast l) \\<bind>\n            (\\<lambda>_. RETURN (op_list_butlast l)))", "apply refine_vcg"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>pre_list_butlast l; (l, qp) = (a, b)\\<rbrakk>\n       \\<Longrightarrow> a \\<noteq> []\n 2. \\<And>a b.\n       \\<lbrakk>pre_list_butlast l; (l, qp) = (a, b); a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> length a - 1 < length a\n 3. \\<And>a b.\n       \\<lbrakk>pre_list_butlast l; (l, qp) = (a, b); a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> pre_list_butlast a\n 4. \\<And>a b.\n       \\<lbrakk>pre_list_butlast l; (l, qp) = (a, b); a \\<noteq> [];\n        pre_list_butlast a\\<rbrakk>\n       \\<Longrightarrow> a ! (length a - 1) < length b\n 5. \\<And>a b.\n       \\<lbrakk>pre_list_butlast l; (l, qp) = (a, b); a \\<noteq> [];\n        pre_list_butlast a\\<rbrakk>\n       \\<Longrightarrow> ((op_list_butlast a, b\n                           [a ! (length a - 1) := length b]),\n                          op_list_butlast l)\n                         \\<in> br fst (uncurry (ial_invar maxsize))", "apply (clarsimp_all simp: in_br_conv aux1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  aial_butlast (l, qp)\n  \\<le> \\<Down> (br fst (uncurry (ial_invar maxsize))) (mop_list_butlast l)\n\ngoal:\nNo subgoals!", "qed"], ["", "sepref_definition ial_butlast is aial_butlast :: \"(ial_assn2 maxsize)\\<^sup>d \\<rightarrow>\\<^sub>a ial_assn2 maxsize\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, aial_butlast)\n    \\<in> (ial_assn2\n            maxsize)\\<^sup>d \\<rightarrow>\\<^sub>a ial_assn2 maxsize", "unfolding aial_butlast_def ial_assn2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>(l, qp).\n        ASSERT (l \\<noteq> []) \\<bind>\n        (\\<lambda>_.\n            mop_list_length l \\<bind>\n            (\\<lambda>len.\n                mop_list_get l (len - 1) \\<bind>\n                (\\<lambda>k.\n                    mop_list_butlast l \\<bind>\n                    (\\<lambda>l.\n                        mop_list_set qp k (length qp) \\<bind>\n                        (\\<lambda>qp. RETURN (l, qp)))))))\n    \\<in> (marl_assn maxsize nat_assn \\<times>\\<^sub>a\n           array_assn\n            nat_assn)\\<^sup>d \\<rightarrow>\\<^sub>a marl_assn maxsize\n               nat_assn \\<times>\\<^sub>a\n              array_assn nat_assn", "by sepref"], ["", "sepref_decl_impl (ismop) ial_butlast: ial_butlast.refine[FCOMP aial_butlast_refine]"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "subsection \\<open>Append\\<close>"], ["", "definition aial_append :: \"aial \\<Rightarrow> nat \\<Rightarrow> aial nres\" where\n      \"aial_append \\<equiv> \\<lambda>(l,qp) k. do {\n        ASSERT (k<length qp \\<and> k\\<notin>set l \\<and> length l < length qp);\n        len \\<leftarrow> mop_list_length l;\n        l \\<leftarrow> mop_list_append l k;\n        qp \\<leftarrow> mop_list_set qp k len;\n        RETURN (l,qp)\n      }\""], ["", "lemma aial_append_refine: \n      \"(uncurry aial_append,uncurry mop_list_append) \\<in> \n        [\\<lambda>(l,k). k<maxsize \\<and> k\\<notin>set l]\\<^sub>f ial_rel1 maxsize \\<times>\\<^sub>r nat_rel \\<rightarrow> \\<langle>ial_rel1 maxsize\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry aial_append, uncurry mop_list_append)\n    \\<in> [\\<lambda>(l, k).\n              k < maxsize \\<and>\n              k \\<notin> set l]\\<^sub>f ial_rel1 maxsize \\<times>\\<^sub>r\n  nat_rel \\<rightarrow> \\<langle>ial_rel1 maxsize\\<rangle>nres_rel", "apply (intro frefI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>case y of\n                (l, k) \\<Rightarrow> k < maxsize \\<and> k \\<notin> set l;\n        (x, y) \\<in> ial_rel1 maxsize \\<times>\\<^sub>r nat_rel\\<rbrakk>\n       \\<Longrightarrow> uncurry aial_append x\n                         \\<le> \\<Down> (ial_rel1 maxsize)\n                                (uncurry mop_list_append y)", "unfolding ial_rel1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>case y of\n                (l, k) \\<Rightarrow> k < maxsize \\<and> k \\<notin> set l;\n        (x, y)\n        \\<in> br fst (uncurry (ial_invar maxsize)) \\<times>\\<^sub>r\n              nat_rel\\<rbrakk>\n       \\<Longrightarrow> uncurry aial_append x\n                         \\<le> \\<Down>\n                                (br fst (uncurry (ial_invar maxsize)))\n                                (uncurry mop_list_append y)", "proof (clarsimp simp: in_br_conv)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<lbrakk>ial_invar maxsize a b; ba < maxsize;\n        ba \\<notin> set a\\<rbrakk>\n       \\<Longrightarrow> aial_append (a, b) ba\n                         \\<le> \\<Down>\n                                (br fst (uncurry (ial_invar maxsize)))\n                                (RETURN (a @ [ba]))", "fix l qp k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<lbrakk>ial_invar maxsize a b; ba < maxsize;\n        ba \\<notin> set a\\<rbrakk>\n       \\<Longrightarrow> aial_append (a, b) ba\n                         \\<le> \\<Down>\n                                (br fst (uncurry (ial_invar maxsize)))\n                                (RETURN (a @ [ba]))", "assume KLM: \"k<maxsize\" and KNL: \"k\\<notin>set l\""], ["proof (state)\nthis:\n  k < maxsize\n  k \\<notin> set l\n\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<lbrakk>ial_invar maxsize a b; ba < maxsize;\n        ba \\<notin> set a\\<rbrakk>\n       \\<Longrightarrow> aial_append (a, b) ba\n                         \\<le> \\<Down>\n                                (br fst (uncurry (ial_invar maxsize)))\n                                (RETURN (a @ [ba]))", "assume \"ial_invar maxsize l qp\""], ["proof (state)\nthis:\n  ial_invar maxsize l qp\n\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<lbrakk>ial_invar maxsize a b; ba < maxsize;\n        ba \\<notin> set a\\<rbrakk>\n       \\<Longrightarrow> aial_append (a, b) ba\n                         \\<le> \\<Down>\n                                (br fst (uncurry (ial_invar maxsize)))\n                                (RETURN (a @ [ba]))", "then"], ["proof (chain)\npicking this:\n  ial_invar maxsize l qp", "interpret ial_invar maxsize l qp"], ["proof (prove)\nusing this:\n  ial_invar maxsize l qp\n\ngoal (1 subgoal):\n 1. ial_invar maxsize l qp", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<lbrakk>ial_invar maxsize a b; ba < maxsize;\n        ba \\<notin> set a\\<rbrakk>\n       \\<Longrightarrow> aial_append (a, b) ba\n                         \\<le> \\<Down>\n                                (br fst (uncurry (ial_invar maxsize)))\n                                (RETURN (a @ [ba]))", "from KLM"], ["proof (chain)\npicking this:\n  k < maxsize", "have KLL: \"k<length qp\""], ["proof (prove)\nusing this:\n  k < maxsize\n\ngoal (1 subgoal):\n 1. k < length qp", "by simp"], ["proof (state)\nthis:\n  k < length qp\n\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<lbrakk>ial_invar maxsize a b; ba < maxsize;\n        ba \\<notin> set a\\<rbrakk>\n       \\<Longrightarrow> aial_append (a, b) ba\n                         \\<le> \\<Down>\n                                (br fst (uncurry (ial_invar maxsize)))\n                                (RETURN (a @ [ba]))", "note distinct_card[OF l_distinct, symmetric]"], ["proof (state)\nthis:\n  length l = card (set l)\n\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<lbrakk>ial_invar maxsize a b; ba < maxsize;\n        ba \\<notin> set a\\<rbrakk>\n       \\<Longrightarrow> aial_append (a, b) ba\n                         \\<le> \\<Down>\n                                (br fst (uncurry (ial_invar maxsize)))\n                                (RETURN (a @ [ba]))", "also"], ["proof (state)\nthis:\n  length l = card (set l)\n\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<lbrakk>ial_invar maxsize a b; ba < maxsize;\n        ba \\<notin> set a\\<rbrakk>\n       \\<Longrightarrow> aial_append (a, b) ba\n                         \\<le> \\<Down>\n                                (br fst (uncurry (ial_invar maxsize)))\n                                (RETURN (a @ [ba]))", "from KNL l_set"], ["proof (chain)\npicking this:\n  k \\<notin> set l\n  set l \\<subseteq> {0..<length qp}", "have \"set l \\<subseteq> {0..<k} \\<union> {Suc k..<length qp}\""], ["proof (prove)\nusing this:\n  k \\<notin> set l\n  set l \\<subseteq> {0..<length qp}\n\ngoal (1 subgoal):\n 1. set l \\<subseteq> {0..<k} \\<union> {Suc k..<length qp}", "by (auto simp: nat_less_le)"], ["proof (state)\nthis:\n  set l \\<subseteq> {0..<k} \\<union> {Suc k..<length qp}\n\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<lbrakk>ial_invar maxsize a b; ba < maxsize;\n        ba \\<notin> set a\\<rbrakk>\n       \\<Longrightarrow> aial_append (a, b) ba\n                         \\<le> \\<Down>\n                                (br fst (uncurry (ial_invar maxsize)))\n                                (RETURN (a @ [ba]))", "from card_mono[OF _ this]"], ["proof (chain)\npicking this:\n  finite ({0..<k} \\<union> {Suc k..<length qp}) \\<Longrightarrow>\n  card (set l) \\<le> card ({0..<k} \\<union> {Suc k..<length qp})", "have \"card (set l) \\<le> card \\<dots>\""], ["proof (prove)\nusing this:\n  finite ({0..<k} \\<union> {Suc k..<length qp}) \\<Longrightarrow>\n  card (set l) \\<le> card ({0..<k} \\<union> {Suc k..<length qp})\n\ngoal (1 subgoal):\n 1. card (set l) \\<le> card ({0..<k} \\<union> {Suc k..<length qp})", "by simp"], ["proof (state)\nthis:\n  card (set l) \\<le> card ({0..<k} \\<union> {Suc k..<length qp})\n\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<lbrakk>ial_invar maxsize a b; ba < maxsize;\n        ba \\<notin> set a\\<rbrakk>\n       \\<Longrightarrow> aial_append (a, b) ba\n                         \\<le> \\<Down>\n                                (br fst (uncurry (ial_invar maxsize)))\n                                (RETURN (a @ [ba]))", "also"], ["proof (state)\nthis:\n  card (set l) \\<le> card ({0..<k} \\<union> {Suc k..<length qp})\n\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<lbrakk>ial_invar maxsize a b; ba < maxsize;\n        ba \\<notin> set a\\<rbrakk>\n       \\<Longrightarrow> aial_append (a, b) ba\n                         \\<le> \\<Down>\n                                (br fst (uncurry (ial_invar maxsize)))\n                                (RETURN (a @ [ba]))", "note card_Un_le"], ["proof (state)\nthis:\n  card (?A \\<union> ?B) \\<le> card ?A + card ?B\n\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<lbrakk>ial_invar maxsize a b; ba < maxsize;\n        ba \\<notin> set a\\<rbrakk>\n       \\<Longrightarrow> aial_append (a, b) ba\n                         \\<le> \\<Down>\n                                (br fst (uncurry (ial_invar maxsize)))\n                                (RETURN (a @ [ba]))", "also"], ["proof (state)\nthis:\n  card (?A \\<union> ?B) \\<le> card ?A + card ?B\n\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<lbrakk>ial_invar maxsize a b; ba < maxsize;\n        ba \\<notin> set a\\<rbrakk>\n       \\<Longrightarrow> aial_append (a, b) ba\n                         \\<le> \\<Down>\n                                (br fst (uncurry (ial_invar maxsize)))\n                                (RETURN (a @ [ba]))", "have \"card {0..<k} + card {Suc k..<length qp} = k + (length qp - Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {0..<k} + card {Suc k..<length qp} = k + (length qp - Suc k)", "by simp"], ["proof (state)\nthis:\n  card {0..<k} + card {Suc k..<length qp} = k + (length qp - Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<lbrakk>ial_invar maxsize a b; ba < maxsize;\n        ba \\<notin> set a\\<rbrakk>\n       \\<Longrightarrow> aial_append (a, b) ba\n                         \\<le> \\<Down>\n                                (br fst (uncurry (ial_invar maxsize)))\n                                (RETURN (a @ [ba]))", "also"], ["proof (state)\nthis:\n  card {0..<k} + card {Suc k..<length qp} = k + (length qp - Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<lbrakk>ial_invar maxsize a b; ba < maxsize;\n        ba \\<notin> set a\\<rbrakk>\n       \\<Longrightarrow> aial_append (a, b) ba\n                         \\<le> \\<Down>\n                                (br fst (uncurry (ial_invar maxsize)))\n                                (RETURN (a @ [ba]))", "have \"\\<dots> < length qp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k + (length qp - Suc k) < length qp", "using KLL"], ["proof (prove)\nusing this:\n  k < length qp\n\ngoal (1 subgoal):\n 1. k + (length qp - Suc k) < length qp", "by simp"], ["proof (state)\nthis:\n  k + (length qp - Suc k) < length qp\n\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<lbrakk>ial_invar maxsize a b; ba < maxsize;\n        ba \\<notin> set a\\<rbrakk>\n       \\<Longrightarrow> aial_append (a, b) ba\n                         \\<le> \\<Down>\n                                (br fst (uncurry (ial_invar maxsize)))\n                                (RETURN (a @ [ba]))", "finally"], ["proof (chain)\npicking this:\n  length l < length qp", "have LLEN: \"length l < length qp\""], ["proof (prove)\nusing this:\n  length l < length qp\n\ngoal (1 subgoal):\n 1. length l < length qp", "."], ["proof (state)\nthis:\n  length l < length qp\n\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<lbrakk>ial_invar maxsize a b; ba < maxsize;\n        ba \\<notin> set a\\<rbrakk>\n       \\<Longrightarrow> aial_append (a, b) ba\n                         \\<le> \\<Down>\n                                (br fst (uncurry (ial_invar maxsize)))\n                                (RETURN (a @ [ba]))", "have aux1[simp]: \"ial_invar (length qp) (l @ [k]) (qp[k := length l])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ial_invar (length qp) (l @ [k]) (qp[k := length l])", "apply standard"], ["proof (prove)\ngoal (4 subgoals):\n 1. length qp = length (qp[k := length l])\n 2. distinct (l @ [k])\n 3. set (l @ [k]) \\<subseteq> {0..<length (qp[k := length l])}\n 4. \\<forall>ka<length (qp[k := length l]).\n       qp[k := length l] ! ka =\n       (if ka \\<in> set (l @ [k]) then index (l @ [k]) ka\n        else length (qp[k := length l]))", "apply (clarsimp_all simp: KNL KLL)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ka.\n       (ka = k \\<longrightarrow> length l = index (l @ [k]) k) \\<and>\n       (ka \\<in> set l \\<longrightarrow>\n        qp[k := length l] ! ka = index (l @ [k]) ka) \\<and>\n       (ka \\<noteq> k \\<and> ka \\<notin> set l \\<longrightarrow>\n        ka < length qp \\<longrightarrow> qp ! ka = length qp)", "using KLL"], ["proof (prove)\nusing this:\n  k < length qp\n\ngoal (1 subgoal):\n 1. \\<And>ka.\n       (ka = k \\<longrightarrow> length l = index (l @ [k]) k) \\<and>\n       (ka \\<in> set l \\<longrightarrow>\n        qp[k := length l] ! ka = index (l @ [k]) ka) \\<and>\n       (ka \\<noteq> k \\<and> ka \\<notin> set l \\<longrightarrow>\n        ka < length qp \\<longrightarrow> qp ! ka = length qp)", "apply (auto simp: Suc_le_eq LLEN) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. k < length qp \\<Longrightarrow> length l = index (l @ [k]) k\n 2. \\<And>ka.\n       \\<lbrakk>k < length qp; ka \\<in> set l\\<rbrakk>\n       \\<Longrightarrow> qp[k := length l] ! ka = index (l @ [k]) ka\n 3. \\<And>ka.\n       \\<lbrakk>k < length qp; ka \\<noteq> k; ka \\<notin> set l;\n        ka < length qp\\<rbrakk>\n       \\<Longrightarrow> qp ! ka = length qp", "apply (auto simp: index_append KNL nth_list_update')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>k < length qp; ka \\<in> set l; k \\<noteq> ka\\<rbrakk>\n       \\<Longrightarrow> qp ! ka = index l ka\n 2. \\<And>ka.\n       \\<lbrakk>k < length qp; ka \\<noteq> k; ka \\<notin> set l;\n        ka < length qp\\<rbrakk>\n       \\<Longrightarrow> qp ! ka = length qp", "apply (simp add: qp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ka.\n       \\<lbrakk>k < length qp; ka \\<noteq> k; ka \\<notin> set l;\n        ka < length qp\\<rbrakk>\n       \\<Longrightarrow> qp ! ka = length qp", "apply (simp add: qp_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ial_invar (length qp) (l @ [k]) (qp[k := length l])\n\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<lbrakk>ial_invar maxsize a b; ba < maxsize;\n        ba \\<notin> set a\\<rbrakk>\n       \\<Longrightarrow> aial_append (a, b) ba\n                         \\<le> \\<Down>\n                                (br fst (uncurry (ial_invar maxsize)))\n                                (RETURN (a @ [ba]))", "show \"aial_append (l, qp) k \\<le> \\<Down> (br fst (uncurry (ial_invar maxsize))) (RETURN (l@[k]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aial_append (l, qp) k\n    \\<le> \\<Down> (br fst (uncurry (ial_invar maxsize))) (RETURN (l @ [k]))", "unfolding aial_append_def mop_list_append_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (l, qp) of\n     (l, qp) \\<Rightarrow>\n       \\<lambda>k.\n          ASSERT\n           (k < length qp \\<and>\n            k \\<notin> set l \\<and> length l < length qp) \\<bind>\n          (\\<lambda>_.\n              mop_list_length l \\<bind>\n              (\\<lambda>len.\n                  curry\n                   (mop pre_list_append\n                     (uncurry (RETURN \\<circ>\\<circ> op_list_append)))\n                   l k \\<bind>\n                  (\\<lambda>l.\n                      mop_list_set qp k len \\<bind>\n                      (\\<lambda>qp. RETURN (l, qp))))))\n     k\n    \\<le> \\<Down> (br fst (uncurry (ial_invar maxsize))) (RETURN (l @ [k]))", "apply refine_vcg"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1 x2. (l, qp) = (x1, x2) \\<Longrightarrow> k < length x2\n 2. \\<And>x1 x2. (l, qp) = (x1, x2) \\<Longrightarrow> k \\<notin> set x1\n 3. \\<And>x1 x2. (l, qp) = (x1, x2) \\<Longrightarrow> length x1 < length x2\n 4. \\<And>x1 x2.\n       \\<lbrakk>(l, qp) = (x1, x2);\n        k < length x2 \\<and>\n        k \\<notin> set x1 \\<and> length x1 < length x2\\<rbrakk>\n       \\<Longrightarrow> curry\n                          (mop pre_list_append\n                            (uncurry\n                              (RETURN \\<circ>\\<circ> op_list_append)))\n                          x1 k\n                         \\<le> SPEC\n                                (\\<lambda>la.\n                                    mop_list_set x2 k (length x1) \\<bind>\n                                    (\\<lambda>qp. RETURN (la, qp))\n                                    \\<le> SPEC\n     (\\<lambda>c. (c, l @ [k]) \\<in> br fst (uncurry (ial_invar maxsize))))", "apply (clarsimp_all simp: in_br_conv KLL KNL LLEN)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  aial_append (l, qp) k\n  \\<le> \\<Down> (br fst (uncurry (ial_invar maxsize))) (RETURN (l @ [k]))\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma aial_append_impl_aux: \"((l, qp), l') \\<in> ial_rel1 maxsize \\<Longrightarrow> l'=l \\<and> maxsize = length qp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((l, qp), l') \\<in> ial_rel1 maxsize \\<Longrightarrow>\n    l' = l \\<and> maxsize = length qp", "unfolding ial_rel1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((l, qp), l')\n    \\<in> br fst (uncurry (ial_invar maxsize)) \\<Longrightarrow>\n    l' = l \\<and> maxsize = length qp", "by (clarsimp simp: in_br_conv ial_invar.maxsize_eq[symmetric])"], ["", "context      \n      notes [dest!] = aial_append_impl_aux\n    begin"], ["", "(* TODO: Should we integrate the domain-condition, or some similar condition, \n        as assertion (relating length l and length qp) or into ial_assn2 ? *)"], ["", "sepref_definition ial_append is \n        \"uncurry aial_append\" :: \"[\\<lambda>(lqp,_). lqp\\<in>Domain (ial_rel1 maxsize)]\\<^sub>a (ial_assn2 maxsize)\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k \\<rightarrow> ial_assn2 maxsize\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry aial_append)\n    \\<in> [\\<lambda>(lqp, uu_).\n              lqp\n              \\<in> Domain\n                     (ial_rel1\n                       maxsize)]\\<^sub>a (ial_assn2\n     maxsize)\\<^sup>d *\\<^sub>a\n   nat_assn\\<^sup>k \\<rightarrow> ial_assn2 maxsize", "unfolding aial_append_def ial_assn2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>(l, qp) k.\n          ASSERT\n           (k < length qp \\<and>\n            k \\<notin> set l \\<and> length l < length qp) \\<bind>\n          (\\<lambda>_.\n              mop_list_length l \\<bind>\n              (\\<lambda>len.\n                  mop_list_append l k \\<bind>\n                  (\\<lambda>l.\n                      mop_list_set qp k len \\<bind>\n                      (\\<lambda>qp. RETURN (l, qp)))))))\n    \\<in> [\\<lambda>(lqp, uu_).\n              lqp\n              \\<in> Domain\n                     (ial_rel1\n                       maxsize)]\\<^sub>a (marl_assn maxsize\n     nat_assn \\<times>\\<^sub>a\n    array_assn nat_assn)\\<^sup>d *\\<^sub>a\n   nat_assn\\<^sup>k \\<rightarrow> marl_assn maxsize\n                                   nat_assn \\<times>\\<^sub>a\n                                  array_assn nat_assn", "by sepref"], ["", "end"], ["", "lemma \"(\\<lambda>b. b<maxsize, X) \\<in> A \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>b. b < maxsize, X) \\<in> A \\<rightarrow> bool_rel", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> A; a < maxsize\\<rbrakk> \\<Longrightarrow> X a'\n 2. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> A; X a'\\<rbrakk> \\<Longrightarrow> a < maxsize", "oops"], ["", "context begin"], ["", "(* TODO: Maybe inject additional restrictions on sepref_decl_impl command *)\n      (* TODO: Maybe require Domain R \\<subseteq> {0..<maxsize} instead ? *)\n      private"], ["", "lemma append_fref': \"\\<lbrakk>IS_BELOW_ID R\\<rbrakk> \n        \\<Longrightarrow> (uncurry mop_list_append, uncurry mop_list_append) \\<in> \\<langle>R\\<rangle>list_rel \\<times>\\<^sub>r R \\<rightarrow>\\<^sub>f \\<langle>\\<langle>R\\<rangle>list_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IS_BELOW_ID R \\<Longrightarrow>\n    (uncurry mop_list_append, uncurry mop_list_append)\n    \\<in> \\<langle>R\\<rangle>list_rel \\<times>\\<^sub>r\n          R \\<rightarrow>\\<^sub>f \\<langle>\\<langle>R\\<rangle>list_rel\\<rangle>nres_rel", "by (rule mop_list_append.fref)"], ["", "sepref_decl_impl (ismop) ial_append: ial_append.refine[FCOMP aial_append_refine] uses append_fref'"], ["proof (prove)\ngoal (1 subgoal):\n 1. IS_BELOW_ID (the_pure R) \\<Longrightarrow>\n    (\\<lambda>(a, b). b < maxsize \\<and> b \\<notin> set a,\n     \\<lambda>(a, b). b < maxsize \\<and> b \\<notin> set a)\n    \\<in> \\<langle>the_pure R\\<rangle>list_rel \\<times>\\<^sub>r\n          the_pure R \\<rightarrow>\n          bool_rel", "unfolding IS_BELOW_ID_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. the_pure R \\<subseteq> nat_rel \\<Longrightarrow>\n    (\\<lambda>(a, b). b < maxsize \\<and> b \\<notin> set a,\n     \\<lambda>(a, b). b < maxsize \\<and> b \\<notin> set a)\n    \\<in> \\<langle>the_pure R\\<rangle>list_rel \\<times>\\<^sub>r\n          the_pure R \\<rightarrow>\n          bool_rel", "apply (parametricity; auto simp: single_valued_below_Id)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "(*\n    lemmas ial_append_hnr_mop[sepref_fr_rules] = ial_append.refine[FCOMP aial_append_refine]\n    lemmas ial_append_hnr[sepref_fr_rules] = ial_append_hnr_mop[FCOMP mk_op_rl2_np[OF mop_list_append_alt]]\n    *)"], ["", "subsection \\<open>Get\\<close>"], ["", "definition aial_get :: \"aial \\<Rightarrow> nat \\<Rightarrow> nat nres\" where\n      \"aial_get \\<equiv> \\<lambda>(l,qp) i. mop_list_get l i\""], ["", "lemma aial_get_refine: \"(aial_get,mop_list_get) \\<in> ial_rel1 maxsize \\<rightarrow> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (aial_get, mop_list_get)\n    \\<in> ial_rel1 maxsize \\<rightarrow>\n          nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>nres_rel", "apply (intro fun_relI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> ial_rel1 maxsize;\n        (aa, a'a) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> aial_get a aa\n                         \\<le> \\<Down> nat_rel (mop_list_get a' a'a)", "unfolding aial_get_def ial_rel1_def mop_list_get_def in_br_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>a' = fst a \\<and> uncurry (ial_invar maxsize) a;\n        (aa, a'a) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> (case a of\n                          (l, qp) \\<Rightarrow>\n                            curry\n                             (mop pre_list_get\n                               (uncurry\n                                 (RETURN \\<circ>\\<circ> op_list_get)))\n                             l)\n                          aa\n                         \\<le> \\<Down> nat_rel\n                                (curry\n                                  (mop pre_list_get\n                                    (uncurry\n(RETURN \\<circ>\\<circ> op_list_get)))\n                                  a' a'a)", "apply refine_vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a x1 x2.\n       \\<lbrakk>a' = fst a \\<and> uncurry (ial_invar maxsize) a;\n        (aa, a'a) \\<in> nat_rel; a = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> curry\n                          (mop pre_list_get\n                            (uncurry (RETURN \\<circ>\\<circ> op_list_get)))\n                          x1 aa\n                         \\<le> \\<Down> nat_rel\n                                (curry\n                                  (mop pre_list_get\n                                    (uncurry\n(RETURN \\<circ>\\<circ> op_list_get)))\n                                  a' a'a)", "apply clarsimp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "sepref_definition ial_get is \"uncurry aial_get\" :: \"(ial_assn2 maxsize)\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry aial_get)\n    \\<in> (ial_assn2 maxsize)\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "unfolding aial_get_def ial_assn2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry (\\<lambda>(l, qp). mop_list_get l))\n    \\<in> (marl_assn maxsize nat_assn \\<times>\\<^sub>a\n           array_assn nat_assn)\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "by sepref"], ["", "sepref_decl_impl (ismop) ial_get: ial_get.refine[FCOMP aial_get_refine]"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "subsection \\<open>Contains\\<close>"], ["", "definition aial_contains :: \"nat \\<Rightarrow> aial \\<Rightarrow> bool nres\" where\n      \"aial_contains \\<equiv> \\<lambda>k (l,qp). do {\n        if k<maxsize then do {\n          i \\<leftarrow> mop_list_get qp k;\n          RETURN (i<maxsize)\n        } else RETURN False  \n      }\""], ["", "lemma aial_contains_refine: \"(uncurry aial_contains,uncurry mop_list_contains) \n      \\<in> (nat_rel \\<times>\\<^sub>r ial_rel1 maxsize) \\<rightarrow>\\<^sub>f \\<langle>bool_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry local.aial_contains, uncurry mop_list_contains)\n    \\<in> nat_rel \\<times>\\<^sub>r\n          ial_rel1\n           maxsize \\<rightarrow>\\<^sub>f \\<langle>bool_rel\\<rangle>nres_rel", "apply (intro frefI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True;\n        (x, y) \\<in> nat_rel \\<times>\\<^sub>r ial_rel1 maxsize\\<rbrakk>\n       \\<Longrightarrow> uncurry local.aial_contains x\n                         \\<le> \\<Down> bool_rel\n                                (uncurry mop_list_contains y)", "unfolding ial_rel1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True;\n        (x, y)\n        \\<in> nat_rel \\<times>\\<^sub>r\n              br fst (uncurry (ial_invar maxsize))\\<rbrakk>\n       \\<Longrightarrow> uncurry local.aial_contains x\n                         \\<le> \\<Down> bool_rel\n                                (uncurry mop_list_contains y)", "proof (clarsimp simp: in_br_conv)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       ial_invar maxsize aa b \\<Longrightarrow>\n       local.aial_contains a (aa, b) \\<le> RETURN (a \\<in> set aa)", "fix l qp k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       ial_invar maxsize aa b \\<Longrightarrow>\n       local.aial_contains a (aa, b) \\<le> RETURN (a \\<in> set aa)", "(*assume A: \"k<maxsize\"*)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       ial_invar maxsize aa b \\<Longrightarrow>\n       local.aial_contains a (aa, b) \\<le> RETURN (a \\<in> set aa)", "assume \"ial_invar maxsize l qp\""], ["proof (state)\nthis:\n  ial_invar maxsize l qp\n\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       ial_invar maxsize aa b \\<Longrightarrow>\n       local.aial_contains a (aa, b) \\<le> RETURN (a \\<in> set aa)", "then"], ["proof (chain)\npicking this:\n  ial_invar maxsize l qp", "interpret ial_invar maxsize l qp"], ["proof (prove)\nusing this:\n  ial_invar maxsize l qp\n\ngoal (1 subgoal):\n 1. ial_invar maxsize l qp", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       ial_invar maxsize aa b \\<Longrightarrow>\n       local.aial_contains a (aa, b) \\<le> RETURN (a \\<in> set aa)", "show \"aial_contains k (l, qp) \\<le> RETURN (k\\<in>set l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.aial_contains k (l, qp) \\<le> RETURN (k \\<in> set l)", "unfolding aial_contains_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (l, qp) of\n     (l, qp) \\<Rightarrow>\n       if k < maxsize\n       then mop_list_get qp k \\<bind> (\\<lambda>i. RETURN (i < maxsize))\n       else RETURN False)\n    \\<le> RETURN (k \\<in> set l)", "apply refine_vcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>(l, qp) = (a, b); k < maxsize\\<rbrakk>\n       \\<Longrightarrow> k < length b\n 2. \\<And>a b.\n       \\<lbrakk>(l, qp) = (a, b); k < maxsize\\<rbrakk>\n       \\<Longrightarrow> (k \\<in> set l) = (b ! k < maxsize)\n 3. \\<And>a b.\n       \\<lbrakk>(l, qp) = (a, b); \\<not> k < maxsize\\<rbrakk>\n       \\<Longrightarrow> (k \\<in> set l) = False", "by (auto simp: l_len qp_def split: if_split_asm)"], ["proof (state)\nthis:\n  local.aial_contains k (l, qp) \\<le> RETURN (k \\<in> set l)\n\ngoal:\nNo subgoals!", "qed"], ["", "context \n      notes [id_rules] = itypeI[Pure.of maxsize \"TYPE(nat)\"]\n      notes [sepref_import_param] = IdI[of maxsize]\n    begin"], ["", "sepref_definition ial_contains is \"uncurry aial_contains\" :: \"nat_assn\\<^sup>k *\\<^sub>a (ial_assn2 maxsize)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry local.aial_contains)\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a\n          (ial_assn2 maxsize)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "unfolding aial_contains_def ial_assn2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>k (l, qp).\n          if k < maxsize\n          then mop_list_get qp k \\<bind> (\\<lambda>i. RETURN (i < maxsize))\n          else RETURN False))\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a\n          (marl_assn maxsize nat_assn \\<times>\\<^sub>a\n           array_assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "by sepref"], ["", "end"], ["", "sepref_decl_impl (ismop) ial_contains: ial_contains.refine[FCOMP aial_contains_refine]"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "end"]]}